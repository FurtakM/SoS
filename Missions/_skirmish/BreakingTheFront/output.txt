// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 602 0 0
// SetDiplomacy ;
  42: CALL 814 0 0
// PrepareGame ;
  46: CALL 896 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := 0 ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 0 0$1 trigger game and GameType = 1 and not disableGlobalTimer do
 229: LD_EXP 3
 233: PUSH
 234: LD_EXP 2
 238: PUSH
 239: LD_INT 1
 241: EQUAL
 242: AND
 243: PUSH
 244: LD_EXP 4
 248: NOT
 249: AND
 250: IFFALSE 273
 252: GO 254
 254: DISABLE
// begin enable ;
 255: ENABLE
// display_strings := [ #SkrTime , tick ] ;
 256: LD_ADDR_OWVAR 47
 260: PUSH
 261: LD_STRING #SkrTime
 263: PUSH
 264: LD_OWVAR 1
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: ST_TO_ADDR
// end ;
 273: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 274: LD_EXP 19
 278: PUSH
 279: LD_EXP 3
 283: AND
 284: PUSH
 285: LD_EXP 2
 289: PUSH
 290: LD_INT 1
 292: EQUAL
 293: AND
 294: IFFALSE 355
 296: GO 298
 298: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 299: LD_EXP 19
 303: PUSH
 304: LD_INT 1
 306: ARRAY
 307: PUSH
 308: LD_INT 1
 310: ARRAY
 311: PPUSH
 312: LD_EXP 19
 316: PUSH
 317: LD_INT 1
 319: ARRAY
 320: PUSH
 321: LD_INT 2
 323: ARRAY
 324: PPUSH
 325: LD_EXP 19
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 3
 336: ARRAY
 337: PPUSH
 338: LD_EXP 19
 342: PUSH
 343: LD_INT 1
 345: ARRAY
 346: PUSH
 347: LD_INT 4
 349: ARRAY
 350: PPUSH
 351: CALL 55930 0 4
 355: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 356: LD_EXP 19
 360: PUSH
 361: LD_EXP 3
 365: AND
 366: PUSH
 367: LD_EXP 2
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: IFFALSE 437
 378: GO 380
 380: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 381: LD_EXP 19
 385: PUSH
 386: LD_INT 2
 388: ARRAY
 389: PUSH
 390: LD_INT 1
 392: ARRAY
 393: PPUSH
 394: LD_EXP 19
 398: PUSH
 399: LD_INT 2
 401: ARRAY
 402: PUSH
 403: LD_INT 2
 405: ARRAY
 406: PPUSH
 407: LD_EXP 19
 411: PUSH
 412: LD_INT 2
 414: ARRAY
 415: PUSH
 416: LD_INT 3
 418: ARRAY
 419: PPUSH
 420: LD_EXP 19
 424: PUSH
 425: LD_INT 2
 427: ARRAY
 428: PUSH
 429: LD_INT 4
 431: ARRAY
 432: PPUSH
 433: CALL 55930 0 4
 437: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 438: LD_EXP 19
 442: PUSH
 443: LD_EXP 3
 447: AND
 448: PUSH
 449: LD_EXP 2
 453: PUSH
 454: LD_INT 1
 456: EQUAL
 457: AND
 458: IFFALSE 519
 460: GO 462
 462: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 463: LD_EXP 19
 467: PUSH
 468: LD_INT 3
 470: ARRAY
 471: PUSH
 472: LD_INT 1
 474: ARRAY
 475: PPUSH
 476: LD_EXP 19
 480: PUSH
 481: LD_INT 3
 483: ARRAY
 484: PUSH
 485: LD_INT 2
 487: ARRAY
 488: PPUSH
 489: LD_EXP 19
 493: PUSH
 494: LD_INT 3
 496: ARRAY
 497: PUSH
 498: LD_INT 3
 500: ARRAY
 501: PPUSH
 502: LD_EXP 19
 506: PUSH
 507: LD_INT 3
 509: ARRAY
 510: PUSH
 511: LD_INT 4
 513: ARRAY
 514: PPUSH
 515: CALL 55930 0 4
 519: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 520: LD_EXP 19
 524: PUSH
 525: LD_EXP 3
 529: AND
 530: PUSH
 531: LD_EXP 2
 535: PUSH
 536: LD_INT 1
 538: EQUAL
 539: AND
 540: IFFALSE 601
 542: GO 544
 544: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 545: LD_EXP 19
 549: PUSH
 550: LD_INT 4
 552: ARRAY
 553: PUSH
 554: LD_INT 1
 556: ARRAY
 557: PPUSH
 558: LD_EXP 19
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PPUSH
 571: LD_EXP 19
 575: PUSH
 576: LD_INT 4
 578: ARRAY
 579: PUSH
 580: LD_INT 3
 582: ARRAY
 583: PPUSH
 584: LD_EXP 19
 588: PUSH
 589: LD_INT 4
 591: ARRAY
 592: PUSH
 593: LD_INT 4
 595: ARRAY
 596: PPUSH
 597: CALL 55930 0 4
 601: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 602: LD_INT 0
 604: PPUSH
 605: PPUSH
 606: PPUSH
 607: PPUSH
 608: PPUSH
// if GameType = 1 then
 609: LD_EXP 2
 613: PUSH
 614: LD_INT 1
 616: EQUAL
 617: IFFALSE 686
// begin ban_techs := [ ] ;
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// if sibBombAllowed < 2 then
 626: LD_EXP 23
 630: PUSH
 631: LD_INT 2
 633: LESS
 634: IFFALSE 647
// ban_techs := [ tech_sibFiss ] ;
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: LD_INT 25
 643: PUSH
 644: EMPTY
 645: LIST
 646: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_INT 46
 654: PUSH
 655: LD_INT 47
 657: PUSH
 658: LD_INT 48
 660: PUSH
 661: LD_INT 49
 663: PUSH
 664: LD_INT 50
 666: PUSH
 667: LD_INT 39
 669: PUSH
 670: LD_INT 69
 672: PUSH
 673: LD_INT 40
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: ST_TO_ADDR
// end ; for i = 1 to 8 do
 686: LD_ADDR_VAR 0 2
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_INT 8
 698: PUSH
 699: FOR_TO
 700: IFFALSE 784
// begin if res_techs then
 702: LD_VAR 0 5
 706: IFFALSE 742
// for j in res_techs do
 708: LD_ADDR_VAR 0 3
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: FOR_IN
 719: IFFALSE 740
// SetTech ( j , i , state_researched ) ;
 721: LD_VAR 0 3
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: LD_INT 2
 733: PPUSH
 734: CALL_OW 322
 738: GO 718
 740: POP
 741: POP
// if ban_techs then
 742: LD_VAR 0 4
 746: IFFALSE 782
// for j in ban_techs do
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_VAR 0 4
 757: PUSH
 758: FOR_IN
 759: IFFALSE 780
// SetTech ( j , i , state_disabled ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 322
 778: GO 758
 780: POP
 781: POP
// end ;
 782: GO 699
 784: POP
 785: POP
// if sibBombAllowed = 1 then
 786: LD_EXP 23
 790: PUSH
 791: LD_INT 1
 793: EQUAL
 794: IFFALSE 809
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 796: LD_INT 25
 798: PPUSH
 799: LD_INT 3
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 322
// end ;
 809: LD_VAR 0 1
 813: RET
// export function SetDiplomacy ; begin
 814: LD_INT 0
 816: PPUSH
// if GameType = 1 then
 817: LD_EXP 2
 821: PUSH
 822: LD_INT 1
 824: EQUAL
 825: IFFALSE 891
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 827: LD_INT 1
 829: PPUSH
 830: LD_INT 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 843: LD_INT 3
 845: PPUSH
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 8
 864: PPUSH
 865: LD_INT 1
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 875: LD_INT 6
 877: PPUSH
 878: LD_INT 8
 880: PPUSH
 881: LD_INT 1
 883: PPUSH
 884: LD_INT 1
 886: PPUSH
 887: CALL_OW 80
// end ; end ;
 891: LD_VAR 0 1
 895: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 896: LD_INT 0
 898: PPUSH
 899: PPUSH
 900: PPUSH
 901: PPUSH
// if GameType = 1 then
 902: LD_EXP 2
 906: PUSH
 907: LD_INT 1
 909: EQUAL
 910: IFFALSE 1406
// begin game := false ;
 912: LD_ADDR_EXP 3
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// your_side := 1 ;
 920: LD_ADDR_OWVAR 2
 924: PUSH
 925: LD_INT 1
 927: ST_TO_ADDR
// mc_amer := 1 ;
 928: LD_ADDR_EXP 5
 932: PUSH
 933: LD_INT 1
 935: ST_TO_ADDR
// mc_leg := 2 ;
 936: LD_ADDR_EXP 6
 940: PUSH
 941: LD_INT 2
 943: ST_TO_ADDR
// mc_rus_1 := 3 ;
 944: LD_ADDR_EXP 7
 948: PUSH
 949: LD_INT 3
 951: ST_TO_ADDR
// mc_rus_2 := 4 ;
 952: LD_ADDR_EXP 8
 956: PUSH
 957: LD_INT 4
 959: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 960: LD_ADDR_EXP 19
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: LD_INT 200
 976: PUSH
 977: LD_INT 250
 979: PUSH
 980: LD_INT 300
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_EXP 26
 992: ARRAY
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 13
1002: PUSH
1003: LD_INT 8
1005: PUSH
1006: LD_INT 50
1008: PUSH
1009: LD_INT 500
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 17
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 50
1026: PUSH
1027: LD_INT 300
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 18
1038: PUSH
1039: LD_INT 4
1041: PUSH
1042: LD_INT 5
1044: PUSH
1045: LD_INT 6
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_EXP 26
1057: ARRAY
1058: PUSH
1059: LD_INT 30
1061: PUSH
1062: LD_INT 300
1064: PUSH
1065: LD_INT 450
1067: PUSH
1068: LD_INT 500
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_EXP 26
1080: ARRAY
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: LD_INT 190
1101: PUSH
1102: LD_INT 193
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 182
1115: PUSH
1116: LD_INT 117
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 114
1143: PUSH
1144: LD_INT 152
1146: PUSH
1147: LD_INT 2
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 85
1157: PUSH
1158: LD_INT 38
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i in sources do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: PUSH
1186: FOR_IN
1187: IFFALSE 1222
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1189: LD_VAR 0 2
1193: PUSH
1194: LD_INT 1
1196: ARRAY
1197: PPUSH
1198: LD_VAR 0 2
1202: PUSH
1203: LD_INT 2
1205: ARRAY
1206: PPUSH
1207: LD_VAR 0 2
1211: PUSH
1212: LD_INT 3
1214: ARRAY
1215: PPUSH
1216: CALL_OW 62
1220: GO 1186
1222: POP
1223: POP
// disableGlobalTimer := false ;
1224: LD_ADDR_EXP 4
1228: PUSH
1229: LD_INT 0
1231: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1232: LD_ADDR_EXP 15
1236: PUSH
1237: LD_INT 0
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_OWVAR 67
1258: ARRAY
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: ST_TO_ADDR
// ruOutpost := [ ] ;
1264: LD_ADDR_EXP 14
1268: PUSH
1269: EMPTY
1270: ST_TO_ADDR
// staticMines := [ ] ;
1271: LD_ADDR_EXP 16
1275: PUSH
1276: EMPTY
1277: ST_TO_ADDR
// baseCaptured := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// legDestCounter := 0 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 0
1293: ST_TO_ADDR
// legOfferAccepted := false ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_INT 0
1301: ST_TO_ADDR
// legChangeSide := false ;
1302: LD_ADDR_EXP 21
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// allyDestCounter := 0 ;
1310: LD_ADDR_EXP 22
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// outpostEscape := false ;
1318: LD_ADDR_EXP 27
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// dialogueMineDetected := false ;
1326: LD_ADDR_EXP 28
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// PrepareAmericans ;
1334: CALL 7606 0 0
// PrepareLegion ;
1338: CALL 5540 0 0
// PrepareRussians ;
1342: CALL 2506 0 0
// playerForces := PreparePlayer ;
1346: LD_ADDR_EXP 10
1350: PUSH
1351: CALL 8849 0 0
1355: ST_TO_ADDR
// AnimateTrees ( true ) ;
1356: LD_INT 1
1358: PPUSH
1359: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1363: LD_INT 4
1365: PPUSH
1366: LD_INT 3
1368: PPUSH
1369: LD_INT 8
1371: PPUSH
1372: LD_INT 5
1374: PPUSH
1375: LD_INT 3
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 8
1383: PPUSH
1384: LD_INT 2
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: CALL 53235 0 9
// MC_Start ;
1394: CALL 62296 0 0
// SetAdditionalRussianForces ;
1398: CALL 7275 0 0
// Action ;
1402: CALL 11206 0 0
// end ; end ;
1406: LD_VAR 0 1
1410: RET
// export function CustomInitMacro ; begin
1411: LD_INT 0
1413: PPUSH
// if GameType <> 1 then
1414: LD_EXP 2
1418: PUSH
1419: LD_INT 1
1421: NONEQUAL
1422: IFFALSE 1426
// exit ;
1424: GO 2501
// MC_SetScanArea ( mc_amer , amerBase ) ;
1426: LD_EXP 5
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: CALL 85624 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1438: LD_EXP 5
1442: PPUSH
1443: LD_INT 4
1445: PPUSH
1446: CALL 85568 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1450: LD_EXP 5
1454: PPUSH
1455: LD_INT 11
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 7
1463: PUSH
1464: LD_INT 9
1466: PUSH
1467: LD_INT 10
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: PPUSH
1477: CALL 85456 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1481: LD_EXP 5
1485: PPUSH
1486: LD_INT 5
1488: PPUSH
1489: CALL 85138 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1493: LD_EXP 5
1497: PPUSH
1498: LD_INT 3
1500: PPUSH
1501: CALL 84869 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1505: LD_EXP 5
1509: PPUSH
1510: LD_INT 4
1512: PPUSH
1513: CALL 84488 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1517: LD_EXP 5
1521: PPUSH
1522: LD_INT 3
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 2
1530: PUSH
1531: LD_INT 5
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: LD_INT 9
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 4
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: LD_INT 2
1566: PUSH
1567: LD_INT 7
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: PUSH
1576: LD_INT 4
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: LD_INT 2
1584: PUSH
1585: LD_INT 6
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL 84303 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1604: LD_EXP 5
1608: PPUSH
1609: LD_INT 33
1611: PUSH
1612: LD_INT 114
1614: PUSH
1615: LD_INT 16
1617: PUSH
1618: LD_INT 0
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 110
1632: PUSH
1633: LD_INT 12
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL 84195 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1653: LD_EXP 5
1657: PPUSH
1658: LD_INT 10
1660: PUSH
1661: LD_INT 15
1663: PUSH
1664: LD_INT 12
1666: PUSH
1667: LD_INT 11
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL 85045 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1680: LD_EXP 6
1684: PPUSH
1685: LD_INT 6
1687: PPUSH
1688: CALL 85624 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1692: LD_EXP 6
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL 85568 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1704: LD_EXP 6
1708: PPUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 27
1714: PUSH
1715: LD_INT 28
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL 85456 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1731: LD_EXP 6
1735: PPUSH
1736: LD_INT 17
1738: PPUSH
1739: CALL 85138 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1743: LD_EXP 6
1747: PPUSH
1748: LD_INT 6
1750: PPUSH
1751: CALL 84869 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1755: LD_EXP 6
1759: PPUSH
1760: LD_INT 5
1762: PPUSH
1763: CALL 84488 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1767: LD_EXP 6
1771: PPUSH
1772: LD_INT 10
1774: PPUSH
1775: LD_INT 9
1777: PPUSH
1778: CALL 83985 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1782: LD_EXP 6
1786: PPUSH
1787: LD_INT 4
1789: PUSH
1790: LD_INT 157
1792: PUSH
1793: LD_INT 144
1795: PUSH
1796: LD_INT 0
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 32
1807: PUSH
1808: LD_INT 151
1810: PUSH
1811: LD_INT 142
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 32
1825: PUSH
1826: LD_INT 161
1828: PUSH
1829: LD_INT 144
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 32
1843: PUSH
1844: LD_INT 140
1846: PUSH
1847: LD_INT 133
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL 84195 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1869: LD_EXP 6
1873: PPUSH
1874: LD_INT 13
1876: PUSH
1877: LD_INT 2
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 31
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 13
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 31
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 13
1912: PUSH
1913: LD_INT 1
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 27
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: LD_INT 13
1930: PUSH
1931: LD_INT 1
1933: PUSH
1934: LD_INT 2
1936: PUSH
1937: LD_INT 27
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: PUSH
1946: LD_INT 13
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 27
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 13
1966: PUSH
1967: LD_INT 1
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 28
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 13
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 28
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 13
2002: PUSH
2003: LD_INT 1
2005: PUSH
2006: LD_INT 2
2008: PUSH
2009: LD_INT 32
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_INT 13
2020: PUSH
2021: LD_INT 1
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_EXP 35
2031: PUSH
2032: EMPTY
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: PPUSH
2049: CALL 84303 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2053: LD_INT 165
2055: PPUSH
2056: LD_INT 156
2058: PPUSH
2059: LD_INT 8
2061: PPUSH
2062: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2066: LD_EXP 7
2070: PPUSH
2071: LD_INT 15
2073: PPUSH
2074: CALL 85624 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2078: LD_EXP 7
2082: PPUSH
2083: LD_INT 16
2085: PPUSH
2086: CALL 85568 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2090: LD_EXP 7
2094: PPUSH
2095: LD_INT 43
2097: PUSH
2098: LD_INT 47
2100: PUSH
2101: LD_INT 45
2103: PUSH
2104: LD_INT 49
2106: PUSH
2107: LD_INT 46
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: PPUSH
2117: CALL 85456 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2121: LD_EXP 7
2125: PPUSH
2126: LD_INT 13
2128: PPUSH
2129: CALL 85138 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2133: LD_EXP 7
2137: PPUSH
2138: LD_INT 15
2140: PPUSH
2141: CALL 84869 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2145: LD_EXP 7
2149: PPUSH
2150: LD_INT 5
2152: PPUSH
2153: CALL 84488 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2157: LD_EXP 7
2161: PPUSH
2162: LD_INT 23
2164: PUSH
2165: LD_INT 1
2167: PUSH
2168: LD_INT 3
2170: PUSH
2171: LD_INT 46
2173: PUSH
2174: EMPTY
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: PUSH
2180: LD_INT 23
2182: PUSH
2183: LD_INT 1
2185: PUSH
2186: LD_INT 1
2188: PUSH
2189: LD_INT 46
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: PUSH
2198: LD_INT 23
2200: PUSH
2201: LD_INT 1
2203: PUSH
2204: LD_INT 3
2206: PUSH
2207: LD_INT 45
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: LIST
2214: LIST
2215: PUSH
2216: LD_INT 23
2218: PUSH
2219: LD_INT 1
2221: PUSH
2222: LD_INT 1
2224: PUSH
2225: LD_INT 47
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 23
2236: PUSH
2237: LD_INT 1
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: LD_INT 46
2245: PUSH
2246: EMPTY
2247: LIST
2248: LIST
2249: LIST
2250: LIST
2251: PUSH
2252: LD_INT 21
2254: PUSH
2255: LD_INT 1
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 51
2263: PUSH
2264: EMPTY
2265: LIST
2266: LIST
2267: LIST
2268: LIST
2269: PUSH
2270: LD_INT 21
2272: PUSH
2273: LD_INT 1
2275: PUSH
2276: LD_INT 3
2278: PUSH
2279: LD_INT 52
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: LIST
2295: LIST
2296: PPUSH
2297: CALL 84303 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2301: LD_EXP 8
2305: PPUSH
2306: LD_INT 11
2308: PPUSH
2309: CALL 85624 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2313: LD_EXP 8
2317: PPUSH
2318: LD_INT 12
2320: PPUSH
2321: CALL 85568 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2325: LD_EXP 8
2329: PPUSH
2330: LD_INT 43
2332: PUSH
2333: LD_INT 47
2335: PUSH
2336: LD_INT 45
2338: PUSH
2339: LD_INT 49
2341: PUSH
2342: LD_INT 46
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: LIST
2349: LIST
2350: LIST
2351: PPUSH
2352: CALL 85456 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2356: LD_EXP 8
2360: PPUSH
2361: LD_INT 13
2363: PPUSH
2364: CALL 85138 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2368: LD_EXP 8
2372: PPUSH
2373: LD_INT 11
2375: PPUSH
2376: CALL 84869 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2380: LD_EXP 8
2384: PPUSH
2385: LD_INT 4
2387: PPUSH
2388: CALL 84488 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2392: LD_EXP 8
2396: PPUSH
2397: LD_INT 115
2399: PUSH
2400: LD_INT 201
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PUSH
2407: EMPTY
2408: LIST
2409: PPUSH
2410: CALL 85194 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2414: LD_EXP 8
2418: PPUSH
2419: LD_INT 24
2421: PUSH
2422: LD_INT 3
2424: PUSH
2425: LD_INT 3
2427: PUSH
2428: LD_INT 46
2430: PUSH
2431: EMPTY
2432: LIST
2433: LIST
2434: LIST
2435: LIST
2436: PUSH
2437: LD_INT 24
2439: PUSH
2440: LD_INT 3
2442: PUSH
2443: LD_INT 3
2445: PUSH
2446: LD_INT 46
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: LIST
2453: LIST
2454: PUSH
2455: LD_INT 24
2457: PUSH
2458: LD_INT 3
2460: PUSH
2461: LD_INT 3
2463: PUSH
2464: LD_INT 46
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: LIST
2471: LIST
2472: PUSH
2473: LD_INT 24
2475: PUSH
2476: LD_INT 3
2478: PUSH
2479: LD_INT 3
2481: PUSH
2482: LD_INT 46
2484: PUSH
2485: EMPTY
2486: LIST
2487: LIST
2488: LIST
2489: LIST
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: LIST
2495: LIST
2496: PPUSH
2497: CALL 84303 0 2
// end ;
2501: LD_VAR 0 1
2505: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2506: LD_INT 0
2508: PPUSH
2509: PPUSH
2510: PPUSH
2511: PPUSH
2512: PPUSH
2513: PPUSH
2514: PPUSH
2515: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2516: LD_INT 0
2518: PPUSH
2519: LD_INT 0
2521: PPUSH
2522: LD_INT 3
2524: PPUSH
2525: LD_INT 0
2527: PPUSH
2528: LD_INT 0
2530: PPUSH
2531: LD_INT 0
2533: PPUSH
2534: LD_INT 0
2536: PPUSH
2537: LD_INT 14
2539: PPUSH
2540: LD_INT 0
2542: PPUSH
2543: CALL 53235 0 9
// side := 3 ;
2547: LD_ADDR_VAR 0 5
2551: PUSH
2552: LD_INT 3
2554: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2555: LD_INT 38
2557: PPUSH
2558: LD_VAR 0 5
2562: PPUSH
2563: LD_INT 2
2565: PPUSH
2566: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2570: LD_INT 39
2572: PPUSH
2573: LD_VAR 0 5
2577: PPUSH
2578: LD_INT 2
2580: PPUSH
2581: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2585: LD_INT 34
2587: PPUSH
2588: LD_VAR 0 5
2592: PPUSH
2593: LD_INT 2
2595: PPUSH
2596: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2600: LD_ADDR_VAR 0 4
2604: PUSH
2605: LD_INT 0
2607: PUSH
2608: LD_INT 208
2610: PUSH
2611: LD_INT 163
2613: PUSH
2614: LD_INT 4
2616: PUSH
2617: LD_INT 0
2619: PUSH
2620: LD_INT 0
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 3
2633: PUSH
2634: LD_INT 194
2636: PUSH
2637: LD_INT 161
2639: PUSH
2640: LD_INT 1
2642: PUSH
2643: LD_INT 0
2645: PUSH
2646: LD_INT 0
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 17
2659: PUSH
2660: LD_INT 190
2662: PUSH
2663: LD_INT 161
2665: PUSH
2666: LD_INT 1
2668: PUSH
2669: LD_INT 0
2671: PUSH
2672: LD_INT 0
2674: PUSH
2675: EMPTY
2676: LIST
2677: LIST
2678: LIST
2679: LIST
2680: LIST
2681: LIST
2682: PUSH
2683: LD_INT 5
2685: PUSH
2686: LD_INT 200
2688: PUSH
2689: LD_INT 145
2691: PUSH
2692: LD_INT 3
2694: PUSH
2695: LD_INT 0
2697: PUSH
2698: LD_INT 0
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: LIST
2708: PUSH
2709: LD_INT 32
2711: PUSH
2712: LD_INT 192
2714: PUSH
2715: LD_INT 144
2717: PUSH
2718: LD_INT 3
2720: PUSH
2721: LD_INT 0
2723: PUSH
2724: LD_INT 0
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: LIST
2733: LIST
2734: PUSH
2735: LD_INT 26
2737: PUSH
2738: LD_INT 216
2740: PUSH
2741: LD_INT 172
2743: PUSH
2744: LD_INT 3
2746: PUSH
2747: LD_INT 0
2749: PUSH
2750: LD_INT 0
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: LIST
2757: LIST
2758: LIST
2759: LIST
2760: PUSH
2761: LD_INT 26
2763: PUSH
2764: LD_INT 218
2766: PUSH
2767: LD_INT 176
2769: PUSH
2770: LD_INT 3
2772: PUSH
2773: LD_INT 0
2775: PUSH
2776: LD_INT 0
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: LIST
2786: PUSH
2787: LD_INT 29
2789: PUSH
2790: LD_INT 182
2792: PUSH
2793: LD_INT 149
2795: PUSH
2796: LD_INT 3
2798: PUSH
2799: LD_INT 0
2801: PUSH
2802: LD_INT 0
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: LIST
2811: LIST
2812: PUSH
2813: LD_INT 8
2815: PUSH
2816: LD_INT 201
2818: PUSH
2819: LD_INT 171
2821: PUSH
2822: LD_INT 0
2824: PUSH
2825: LD_INT 10
2827: PUSH
2828: LD_INT 11
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: LIST
2837: LIST
2838: PUSH
2839: LD_INT 32
2841: PUSH
2842: LD_INT 188
2844: PUSH
2845: LD_INT 167
2847: PUSH
2848: LD_INT 0
2850: PUSH
2851: LD_INT 0
2853: PUSH
2854: LD_INT 0
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: LIST
2863: LIST
2864: PUSH
2865: LD_INT 32
2867: PUSH
2868: LD_INT 202
2870: PUSH
2871: LD_INT 179
2873: PUSH
2874: LD_INT 0
2876: PUSH
2877: LD_INT 0
2879: PUSH
2880: LD_INT 0
2882: PUSH
2883: EMPTY
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: LIST
2889: LIST
2890: PUSH
2891: LD_INT 32
2893: PUSH
2894: LD_INT 209
2896: PUSH
2897: LD_INT 182
2899: PUSH
2900: LD_INT 0
2902: PUSH
2903: LD_INT 0
2905: PUSH
2906: LD_INT 0
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: LIST
2915: LIST
2916: PUSH
2917: LD_INT 32
2919: PUSH
2920: LD_INT 220
2922: PUSH
2923: LD_INT 183
2925: PUSH
2926: LD_INT 5
2928: PUSH
2929: LD_INT 0
2931: PUSH
2932: LD_INT 0
2934: PUSH
2935: EMPTY
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: LIST
2942: PUSH
2943: LD_INT 32
2945: PUSH
2946: LD_INT 225
2948: PUSH
2949: LD_INT 181
2951: PUSH
2952: LD_INT 5
2954: PUSH
2955: LD_INT 0
2957: PUSH
2958: LD_INT 0
2960: PUSH
2961: EMPTY
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: LIST
2967: LIST
2968: PUSH
2969: LD_INT 26
2971: PUSH
2972: LD_INT 220
2974: PUSH
2975: LD_INT 174
2977: PUSH
2978: LD_INT 5
2980: PUSH
2981: LD_INT 0
2983: PUSH
2984: LD_INT 0
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: PUSH
2995: LD_INT 1
2997: PUSH
2998: LD_INT 84
3000: PUSH
3001: LD_INT 128
3003: PUSH
3004: LD_INT 4
3006: PUSH
3007: LD_INT 0
3009: PUSH
3010: LD_INT 0
3012: PUSH
3013: EMPTY
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: LIST
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 68
3026: PUSH
3027: LD_INT 121
3029: PUSH
3030: LD_INT 1
3032: PUSH
3033: LD_INT 0
3035: PUSH
3036: LD_INT 0
3038: PUSH
3039: EMPTY
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PUSH
3047: LD_INT 19
3049: PUSH
3050: LD_INT 72
3052: PUSH
3053: LD_INT 125
3055: PUSH
3056: LD_INT 5
3058: PUSH
3059: LD_INT 0
3061: PUSH
3062: LD_INT 0
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PUSH
3073: LD_INT 18
3075: PUSH
3076: LD_INT 68
3078: PUSH
3079: LD_INT 124
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: LD_INT 0
3087: PUSH
3088: LD_INT 0
3090: PUSH
3091: EMPTY
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_INT 24
3101: PUSH
3102: LD_INT 64
3104: PUSH
3105: LD_INT 121
3107: PUSH
3108: LD_INT 1
3110: PUSH
3111: LD_INT 0
3113: PUSH
3114: LD_INT 0
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: PUSH
3125: LD_INT 17
3127: PUSH
3128: LD_INT 65
3130: PUSH
3131: LD_INT 118
3133: PUSH
3134: LD_INT 2
3136: PUSH
3137: LD_INT 0
3139: PUSH
3140: LD_INT 0
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_INT 21
3153: PUSH
3154: LD_INT 68
3156: PUSH
3157: LD_INT 117
3159: PUSH
3160: LD_INT 3
3162: PUSH
3163: LD_INT 0
3165: PUSH
3166: LD_INT 0
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 8
3179: PUSH
3180: LD_INT 68
3182: PUSH
3183: LD_INT 130
3185: PUSH
3186: LD_INT 1
3188: PUSH
3189: LD_INT 14
3191: PUSH
3192: LD_INT 10
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: PUSH
3203: LD_INT 8
3205: PUSH
3206: LD_INT 67
3208: PUSH
3209: LD_INT 110
3211: PUSH
3212: LD_INT 2
3214: PUSH
3215: LD_INT 11
3217: PUSH
3218: LD_INT 12
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: PUSH
3229: LD_INT 28
3231: PUSH
3232: LD_INT 85
3234: PUSH
3235: LD_INT 108
3237: PUSH
3238: LD_INT 2
3240: PUSH
3241: LD_INT 0
3243: PUSH
3244: LD_INT 0
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: LIST
3253: LIST
3254: PUSH
3255: LD_INT 28
3257: PUSH
3258: LD_INT 85
3260: PUSH
3261: LD_INT 124
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 0
3269: PUSH
3270: LD_INT 0
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: LIST
3279: LIST
3280: PUSH
3281: LD_INT 30
3283: PUSH
3284: LD_INT 97
3286: PUSH
3287: LD_INT 119
3289: PUSH
3290: LD_INT 2
3292: PUSH
3293: LD_INT 0
3295: PUSH
3296: LD_INT 0
3298: PUSH
3299: EMPTY
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 5
3309: PUSH
3310: LD_INT 111
3312: PUSH
3313: LD_INT 138
3315: PUSH
3316: LD_INT 4
3318: PUSH
3319: LD_INT 0
3321: PUSH
3322: LD_INT 0
3324: PUSH
3325: EMPTY
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 33
3335: PUSH
3336: LD_INT 104
3338: PUSH
3339: LD_INT 130
3341: PUSH
3342: LD_INT 3
3344: PUSH
3345: LD_INT 0
3347: PUSH
3348: LD_INT 0
3350: PUSH
3351: EMPTY
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: LIST
3357: LIST
3358: PUSH
3359: LD_INT 33
3361: PUSH
3362: LD_INT 110
3364: PUSH
3365: LD_INT 142
3367: PUSH
3368: LD_INT 5
3370: PUSH
3371: LD_INT 0
3373: PUSH
3374: LD_INT 0
3376: PUSH
3377: EMPTY
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: LIST
3383: LIST
3384: PUSH
3385: LD_INT 33
3387: PUSH
3388: LD_INT 91
3390: PUSH
3391: LD_INT 131
3393: PUSH
3394: LD_INT 5
3396: PUSH
3397: LD_INT 0
3399: PUSH
3400: LD_INT 0
3402: PUSH
3403: EMPTY
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: LIST
3409: LIST
3410: PUSH
3411: LD_INT 33
3413: PUSH
3414: LD_INT 107
3416: PUSH
3417: LD_INT 157
3419: PUSH
3420: LD_INT 5
3422: PUSH
3423: LD_INT 0
3425: PUSH
3426: LD_INT 0
3428: PUSH
3429: EMPTY
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: PUSH
3437: LD_INT 33
3439: PUSH
3440: LD_INT 104
3442: PUSH
3443: LD_INT 160
3445: PUSH
3446: LD_INT 5
3448: PUSH
3449: LD_INT 0
3451: PUSH
3452: LD_INT 0
3454: PUSH
3455: EMPTY
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: LIST
3461: LIST
3462: PUSH
3463: LD_INT 33
3465: PUSH
3466: LD_INT 101
3468: PUSH
3469: LD_INT 162
3471: PUSH
3472: LD_INT 5
3474: PUSH
3475: LD_INT 0
3477: PUSH
3478: LD_INT 0
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: LIST
3488: PUSH
3489: LD_INT 32
3491: PUSH
3492: LD_INT 87
3494: PUSH
3495: LD_INT 157
3497: PUSH
3498: LD_INT 5
3500: PUSH
3501: LD_INT 0
3503: PUSH
3504: LD_INT 0
3506: PUSH
3507: EMPTY
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: LIST
3513: LIST
3514: PUSH
3515: LD_INT 32
3517: PUSH
3518: LD_INT 105
3520: PUSH
3521: LD_INT 158
3523: PUSH
3524: LD_INT 5
3526: PUSH
3527: LD_INT 0
3529: PUSH
3530: LD_INT 0
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: LD_INT 33
3543: PUSH
3544: LD_INT 91
3546: PUSH
3547: LD_INT 118
3549: PUSH
3550: LD_INT 4
3552: PUSH
3553: LD_INT 0
3555: PUSH
3556: LD_INT 0
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: LIST
3565: LIST
3566: PUSH
3567: LD_INT 33
3569: PUSH
3570: LD_INT 89
3572: PUSH
3573: LD_INT 107
3575: PUSH
3576: LD_INT 4
3578: PUSH
3579: LD_INT 0
3581: PUSH
3582: LD_INT 0
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: LIST
3592: PUSH
3593: LD_INT 5
3595: PUSH
3596: LD_INT 86
3598: PUSH
3599: LD_INT 96
3601: PUSH
3602: LD_INT 3
3604: PUSH
3605: LD_INT 0
3607: PUSH
3608: LD_INT 0
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: LIST
3617: LIST
3618: PUSH
3619: LD_INT 33
3621: PUSH
3622: LD_INT 91
3624: PUSH
3625: LD_INT 102
3627: PUSH
3628: LD_INT 4
3630: PUSH
3631: LD_INT 0
3633: PUSH
3634: LD_INT 0
3636: PUSH
3637: EMPTY
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: LIST
3643: LIST
3644: PUSH
3645: LD_INT 32
3647: PUSH
3648: LD_INT 80
3650: PUSH
3651: LD_INT 95
3653: PUSH
3654: LD_INT 3
3656: PUSH
3657: LD_INT 0
3659: PUSH
3660: LD_INT 0
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: LIST
3669: LIST
3670: PUSH
3671: LD_INT 28
3673: PUSH
3674: LD_INT 77
3676: PUSH
3677: LD_INT 105
3679: PUSH
3680: LD_INT 3
3682: PUSH
3683: LD_INT 0
3685: PUSH
3686: LD_INT 0
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: LIST
3693: LIST
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 28
3699: PUSH
3700: LD_INT 85
3702: PUSH
3703: LD_INT 113
3705: PUSH
3706: LD_INT 3
3708: PUSH
3709: LD_INT 0
3711: PUSH
3712: LD_INT 0
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: LIST
3721: LIST
3722: PUSH
3723: LD_INT 28
3725: PUSH
3726: LD_INT 55
3728: PUSH
3729: LD_INT 97
3731: PUSH
3732: LD_INT 3
3734: PUSH
3735: LD_INT 0
3737: PUSH
3738: LD_INT 0
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: LIST
3747: LIST
3748: PUSH
3749: LD_INT 28
3751: PUSH
3752: LD_INT 88
3754: PUSH
3755: LD_INT 128
3757: PUSH
3758: LD_INT 3
3760: PUSH
3761: LD_INT 0
3763: PUSH
3764: LD_INT 0
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 32
3777: PUSH
3778: LD_INT 69
3780: PUSH
3781: LD_INT 101
3783: PUSH
3784: LD_INT 2
3786: PUSH
3787: LD_INT 0
3789: PUSH
3790: LD_INT 0
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 1
3803: PUSH
3804: LD_INT 34
3806: PUSH
3807: LD_INT 23
3809: PUSH
3810: LD_INT 4
3812: PUSH
3813: LD_INT 0
3815: PUSH
3816: LD_INT 0
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 8
3829: PUSH
3830: LD_INT 25
3832: PUSH
3833: LD_INT 4
3835: PUSH
3836: LD_INT 3
3838: PUSH
3839: LD_INT 11
3841: PUSH
3842: LD_INT 10
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: LIST
3851: LIST
3852: PUSH
3853: LD_INT 8
3855: PUSH
3856: LD_INT 15
3858: PUSH
3859: LD_INT 4
3861: PUSH
3862: LD_INT 2
3864: PUSH
3865: LD_INT 14
3867: PUSH
3868: LD_INT 12
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: PUSH
3879: LD_INT 29
3881: PUSH
3882: LD_INT 55
3884: PUSH
3885: LD_INT 35
3887: PUSH
3888: LD_INT 2
3890: PUSH
3891: LD_INT 0
3893: PUSH
3894: LD_INT 0
3896: PUSH
3897: EMPTY
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: LIST
3903: LIST
3904: PUSH
3905: LD_INT 29
3907: PUSH
3908: LD_INT 24
3910: PUSH
3911: LD_INT 44
3913: PUSH
3914: LD_INT 2
3916: PUSH
3917: LD_INT 0
3919: PUSH
3920: LD_INT 0
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: PUSH
3931: LD_INT 34
3933: PUSH
3934: LD_INT 34
3936: PUSH
3937: LD_INT 32
3939: PUSH
3940: LD_INT 4
3942: PUSH
3943: LD_INT 0
3945: PUSH
3946: LD_INT 0
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: LIST
3955: LIST
3956: PUSH
3957: LD_INT 3
3959: PUSH
3960: LD_INT 14
3962: PUSH
3963: LD_INT 16
3965: PUSH
3966: LD_INT 1
3968: PUSH
3969: LD_INT 0
3971: PUSH
3972: LD_INT 0
3974: PUSH
3975: EMPTY
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: LIST
3981: LIST
3982: PUSH
3983: LD_INT 24
3985: PUSH
3986: LD_INT 10
3988: PUSH
3989: LD_INT 16
3991: PUSH
3992: LD_INT 1
3994: PUSH
3995: LD_INT 0
3997: PUSH
3998: LD_INT 0
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: LIST
4007: LIST
4008: PUSH
4009: LD_INT 21
4011: PUSH
4012: LD_INT 11
4014: PUSH
4015: LD_INT 13
4017: PUSH
4018: LD_INT 2
4020: PUSH
4021: LD_INT 0
4023: PUSH
4024: LD_INT 0
4026: PUSH
4027: EMPTY
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_INT 18
4037: PUSH
4038: LD_INT 14
4040: PUSH
4041: LD_INT 12
4043: PUSH
4044: LD_INT 3
4046: PUSH
4047: LD_INT 0
4049: PUSH
4050: LD_INT 0
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: LIST
4059: LIST
4060: PUSH
4061: LD_INT 16
4063: PUSH
4064: LD_INT 14
4066: PUSH
4067: LD_INT 19
4069: PUSH
4070: LD_INT 0
4072: PUSH
4073: LD_INT 0
4075: PUSH
4076: LD_INT 0
4078: PUSH
4079: EMPTY
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: LIST
4085: LIST
4086: PUSH
4087: LD_INT 17
4089: PUSH
4090: LD_INT 18
4092: PUSH
4093: LD_INT 20
4095: PUSH
4096: LD_INT 5
4098: PUSH
4099: LD_INT 0
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_INT 28
4115: PUSH
4116: LD_INT 10
4118: PUSH
4119: LD_INT 5
4121: PUSH
4122: LD_INT 1
4124: PUSH
4125: LD_INT 0
4127: PUSH
4128: LD_INT 0
4130: PUSH
4131: EMPTY
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: LIST
4137: LIST
4138: PUSH
4139: LD_INT 28
4141: PUSH
4142: LD_INT 8
4144: PUSH
4145: LD_INT 8
4147: PUSH
4148: LD_INT 1
4150: PUSH
4151: LD_INT 0
4153: PUSH
4154: LD_INT 0
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: LIST
4163: LIST
4164: PUSH
4165: LD_INT 26
4167: PUSH
4168: LD_INT 19
4170: PUSH
4171: LD_INT 2
4173: PUSH
4174: LD_INT 1
4176: PUSH
4177: LD_INT 0
4179: PUSH
4180: LD_INT 0
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 26
4193: PUSH
4194: LD_INT 30
4196: PUSH
4197: LD_INT 2
4199: PUSH
4200: LD_INT 1
4202: PUSH
4203: LD_INT 0
4205: PUSH
4206: LD_INT 0
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: LIST
4215: LIST
4216: PUSH
4217: LD_INT 5
4219: PUSH
4220: LD_INT 59
4222: PUSH
4223: LD_INT 20
4225: PUSH
4226: LD_INT 4
4228: PUSH
4229: LD_INT 0
4231: PUSH
4232: LD_INT 0
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: LIST
4241: LIST
4242: PUSH
4243: LD_INT 32
4245: PUSH
4246: LD_INT 60
4248: PUSH
4249: LD_INT 24
4251: PUSH
4252: LD_INT 4
4254: PUSH
4255: LD_INT 0
4257: PUSH
4258: LD_INT 0
4260: PUSH
4261: EMPTY
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: PUSH
4269: LD_INT 32
4271: PUSH
4272: LD_INT 61
4274: PUSH
4275: LD_INT 45
4277: PUSH
4278: LD_INT 5
4280: PUSH
4281: LD_INT 0
4283: PUSH
4284: LD_INT 0
4286: PUSH
4287: EMPTY
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: LIST
4294: PUSH
4295: LD_INT 32
4297: PUSH
4298: LD_INT 52
4300: PUSH
4301: LD_INT 51
4303: PUSH
4304: LD_INT 5
4306: PUSH
4307: LD_INT 0
4309: PUSH
4310: LD_INT 0
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: LIST
4319: LIST
4320: PUSH
4321: LD_INT 33
4323: PUSH
4324: LD_INT 56
4326: PUSH
4327: LD_INT 51
4329: PUSH
4330: LD_INT 5
4332: PUSH
4333: LD_INT 0
4335: PUSH
4336: LD_INT 0
4338: PUSH
4339: EMPTY
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 33
4349: PUSH
4350: LD_INT 62
4352: PUSH
4353: LD_INT 49
4355: PUSH
4356: LD_INT 5
4358: PUSH
4359: LD_INT 0
4361: PUSH
4362: LD_INT 0
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: LIST
4371: LIST
4372: PUSH
4373: LD_INT 33
4375: PUSH
4376: LD_INT 41
4378: PUSH
4379: LD_INT 47
4381: PUSH
4382: LD_INT 5
4384: PUSH
4385: LD_INT 0
4387: PUSH
4388: LD_INT 0
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: LIST
4397: LIST
4398: PUSH
4399: LD_INT 33
4401: PUSH
4402: LD_INT 33
4404: PUSH
4405: LD_INT 52
4407: PUSH
4408: LD_INT 5
4410: PUSH
4411: LD_INT 0
4413: PUSH
4414: LD_INT 0
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 5
4427: PUSH
4428: LD_INT 31
4430: PUSH
4431: LD_INT 40
4433: PUSH
4434: LD_INT 0
4436: PUSH
4437: LD_INT 0
4439: PUSH
4440: LD_INT 0
4442: PUSH
4443: EMPTY
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: PUSH
4451: LD_INT 33
4453: PUSH
4454: LD_INT 65
4456: PUSH
4457: LD_INT 37
4459: PUSH
4460: LD_INT 5
4462: PUSH
4463: LD_INT 0
4465: PUSH
4466: LD_INT 0
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: LIST
4475: LIST
4476: PUSH
4477: LD_INT 33
4479: PUSH
4480: LD_INT 63
4482: PUSH
4483: LD_INT 29
4485: PUSH
4486: LD_INT 4
4488: PUSH
4489: LD_INT 0
4491: PUSH
4492: LD_INT 0
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: LIST
4502: PUSH
4503: LD_INT 33
4505: PUSH
4506: LD_INT 54
4508: PUSH
4509: LD_INT 11
4511: PUSH
4512: LD_INT 4
4514: PUSH
4515: LD_INT 0
4517: PUSH
4518: LD_INT 0
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: LIST
4528: PUSH
4529: LD_INT 33
4531: PUSH
4532: LD_INT 56
4534: PUSH
4535: LD_INT 15
4537: PUSH
4538: LD_INT 4
4540: PUSH
4541: LD_INT 0
4543: PUSH
4544: LD_INT 0
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: LIST
4553: LIST
4554: PUSH
4555: LD_INT 33
4557: PUSH
4558: LD_INT 51
4560: PUSH
4561: LD_INT 6
4563: PUSH
4564: LD_INT 4
4566: PUSH
4567: LD_INT 0
4569: PUSH
4570: LD_INT 0
4572: PUSH
4573: EMPTY
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 26
4583: PUSH
4584: LD_INT 39
4586: PUSH
4587: LD_INT 25
4589: PUSH
4590: LD_INT 0
4592: PUSH
4593: LD_INT 0
4595: PUSH
4596: LD_INT 0
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: LIST
4605: LIST
4606: PUSH
4607: LD_INT 26
4609: PUSH
4610: LD_INT 37
4612: PUSH
4613: LD_INT 21
4615: PUSH
4616: LD_INT 0
4618: PUSH
4619: LD_INT 0
4621: PUSH
4622: LD_INT 0
4624: PUSH
4625: EMPTY
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: LIST
4631: LIST
4632: PUSH
4633: LD_INT 32
4635: PUSH
4636: LD_INT 35
4638: PUSH
4639: LD_INT 17
4641: PUSH
4642: LD_INT 4
4644: PUSH
4645: LD_INT 0
4647: PUSH
4648: LD_INT 0
4650: PUSH
4651: EMPTY
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 33
4661: PUSH
4662: LD_INT 35
4664: PUSH
4665: LD_INT 28
4667: PUSH
4668: LD_INT 4
4670: PUSH
4671: LD_INT 0
4673: PUSH
4674: LD_INT 0
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: LIST
4683: LIST
4684: PUSH
4685: LD_INT 33
4687: PUSH
4688: LD_INT 28
4690: PUSH
4691: LD_INT 46
4693: PUSH
4694: LD_INT 5
4696: PUSH
4697: LD_INT 0
4699: PUSH
4700: LD_INT 0
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: LIST
4709: LIST
4710: PUSH
4711: LD_INT 33
4713: PUSH
4714: LD_INT 31
4716: PUSH
4717: LD_INT 6
4719: PUSH
4720: LD_INT 4
4722: PUSH
4723: LD_INT 0
4725: PUSH
4726: LD_INT 0
4728: PUSH
4729: EMPTY
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: LIST
4735: LIST
4736: PUSH
4737: LD_INT 26
4739: PUSH
4740: LD_INT 54
4742: PUSH
4743: LD_INT 38
4745: PUSH
4746: LD_INT 4
4748: PUSH
4749: LD_INT 0
4751: PUSH
4752: LD_INT 0
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: PUSH
4763: LD_INT 33
4765: PUSH
4766: LD_INT 207
4768: PUSH
4769: LD_INT 167
4771: PUSH
4772: LD_INT 3
4774: PUSH
4775: LD_INT 0
4777: PUSH
4778: LD_INT 0
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: PUSH
4789: LD_INT 30
4791: PUSH
4792: LD_INT 43
4794: PUSH
4795: LD_INT 2
4797: PUSH
4798: LD_INT 4
4800: PUSH
4801: LD_INT 0
4803: PUSH
4804: LD_INT 0
4806: PUSH
4807: EMPTY
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: PUSH
4815: EMPTY
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: LIST
4900: LIST
4901: ST_TO_ADDR
// for i in tmp do
4902: LD_ADDR_VAR 0 2
4906: PUSH
4907: LD_VAR 0 4
4911: PUSH
4912: FOR_IN
4913: IFFALSE 5144
// begin uc_side := side ;
4915: LD_ADDR_OWVAR 20
4919: PUSH
4920: LD_VAR 0 5
4924: ST_TO_ADDR
// uc_nation := nation_russian ;
4925: LD_ADDR_OWVAR 21
4929: PUSH
4930: LD_INT 3
4932: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4933: LD_ADDR_OWVAR 42
4937: PUSH
4938: LD_VAR 0 2
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4947: LD_ADDR_OWVAR 43
4951: PUSH
4952: LD_INT 5
4954: PPUSH
4955: LD_INT 6
4957: PPUSH
4958: CALL_OW 12
4962: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4963: LD_ADDR_OWVAR 44
4967: PUSH
4968: LD_VAR 0 2
4972: PUSH
4973: LD_INT 5
4975: ARRAY
4976: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4977: LD_ADDR_OWVAR 45
4981: PUSH
4982: LD_VAR 0 2
4986: PUSH
4987: LD_INT 6
4989: ARRAY
4990: ST_TO_ADDR
// sr := 0 ;
4991: LD_ADDR_VAR 0 6
4995: PUSH
4996: LD_INT 0
4998: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4999: LD_VAR 0 2
5003: PUSH
5004: LD_INT 1
5006: ARRAY
5007: PUSH
5008: LD_INT 29
5010: EQUAL
5011: IFFALSE 5023
// sr := mat_oil else
5013: LD_ADDR_VAR 0 6
5017: PUSH
5018: LD_INT 2
5020: ST_TO_ADDR
5021: GO 5045
// if i [ 1 ] = b_siberite_mine then
5023: LD_VAR 0 2
5027: PUSH
5028: LD_INT 1
5030: ARRAY
5031: PUSH
5032: LD_INT 30
5034: EQUAL
5035: IFFALSE 5045
// sr := mat_siberit ;
5037: LD_ADDR_VAR 0 6
5041: PUSH
5042: LD_INT 3
5044: ST_TO_ADDR
// if sr then
5045: LD_VAR 0 6
5049: IFFALSE 5105
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5051: LD_VAR 0 2
5055: PUSH
5056: LD_INT 2
5058: ARRAY
5059: PPUSH
5060: LD_VAR 0 2
5064: PUSH
5065: LD_INT 3
5067: ARRAY
5068: PPUSH
5069: LD_VAR 0 6
5073: PPUSH
5074: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5078: LD_VAR 0 2
5082: PUSH
5083: LD_INT 2
5085: ARRAY
5086: PPUSH
5087: LD_VAR 0 2
5091: PUSH
5092: LD_INT 3
5094: ARRAY
5095: PPUSH
5096: LD_VAR 0 5
5100: PPUSH
5101: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5105: LD_ADDR_VAR 0 3
5109: PUSH
5110: LD_VAR 0 2
5114: PUSH
5115: LD_INT 2
5117: ARRAY
5118: PPUSH
5119: LD_VAR 0 2
5123: PUSH
5124: LD_INT 3
5126: ARRAY
5127: PPUSH
5128: LD_VAR 0 2
5132: PUSH
5133: LD_INT 4
5135: ARRAY
5136: PPUSH
5137: CALL_OW 47
5141: ST_TO_ADDR
// end ;
5142: GO 4912
5144: POP
5145: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5146: LD_ADDR_VAR 0 7
5150: PUSH
5151: LD_INT 22
5153: PUSH
5154: LD_VAR 0 5
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 30
5165: PUSH
5166: LD_INT 1
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PPUSH
5177: CALL_OW 69
5181: ST_TO_ADDR
// if not depot then
5182: LD_VAR 0 7
5186: NOT
5187: IFFALSE 5191
// exit ;
5189: GO 5535
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5191: LD_ADDR_VAR 0 8
5195: PUSH
5196: LD_INT 84
5198: PPUSH
5199: LD_INT 128
5201: PPUSH
5202: CALL_OW 428
5206: PPUSH
5207: LD_INT 15
5209: PPUSH
5210: LD_INT 0
5212: PPUSH
5213: LD_INT 6
5215: PUSH
5216: LD_INT 7
5218: PUSH
5219: LD_INT 8
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: LIST
5226: PUSH
5227: LD_OWVAR 67
5231: ARRAY
5232: PPUSH
5233: LD_INT 3000
5235: PUSH
5236: LD_INT 300
5238: PUSH
5239: LD_INT 100
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: PPUSH
5247: LD_INT 12
5249: PUSH
5250: LD_INT 6
5252: PUSH
5253: LD_INT 6
5255: PUSH
5256: LD_INT 4
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: LIST
5263: LIST
5264: PPUSH
5265: CALL 28182 0 6
5269: ST_TO_ADDR
// if not base then
5270: LD_VAR 0 8
5274: NOT
5275: IFFALSE 5279
// exit ;
5277: GO 5535
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5279: LD_ADDR_EXP 50
5283: PUSH
5284: LD_EXP 50
5288: PPUSH
5289: LD_EXP 7
5293: PPUSH
5294: LD_VAR 0 8
5298: PPUSH
5299: CALL_OW 1
5303: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5304: LD_ADDR_VAR 0 8
5308: PUSH
5309: LD_INT 34
5311: PPUSH
5312: LD_INT 23
5314: PPUSH
5315: CALL_OW 428
5319: PPUSH
5320: LD_INT 11
5322: PPUSH
5323: LD_INT 0
5325: PPUSH
5326: LD_INT 6
5328: PUSH
5329: LD_INT 7
5331: PUSH
5332: LD_INT 8
5334: PUSH
5335: EMPTY
5336: LIST
5337: LIST
5338: LIST
5339: PUSH
5340: LD_OWVAR 67
5344: ARRAY
5345: PPUSH
5346: LD_INT 20000
5348: PUSH
5349: LD_INT 3000
5351: PUSH
5352: LD_INT 1000
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: LIST
5359: PPUSH
5360: LD_INT 12
5362: PUSH
5363: LD_INT 6
5365: PUSH
5366: LD_INT 6
5368: PUSH
5369: LD_INT 4
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: LIST
5376: LIST
5377: PPUSH
5378: CALL 28182 0 6
5382: ST_TO_ADDR
// if not base then
5383: LD_VAR 0 8
5387: NOT
5388: IFFALSE 5392
// exit ;
5390: GO 5535
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5392: LD_ADDR_EXP 50
5396: PUSH
5397: LD_EXP 50
5401: PPUSH
5402: LD_EXP 8
5406: PPUSH
5407: LD_VAR 0 8
5411: PPUSH
5412: CALL_OW 1
5416: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5417: LD_ADDR_EXP 14
5421: PUSH
5422: LD_INT 22
5424: PUSH
5425: LD_INT 3
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: PUSH
5432: LD_INT 30
5434: PUSH
5435: LD_INT 0
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PPUSH
5446: CALL_OW 69
5450: PUSH
5451: LD_INT 1
5453: ARRAY
5454: PPUSH
5455: LD_INT 25
5457: PPUSH
5458: LD_INT 0
5460: PPUSH
5461: LD_INT 6
5463: PUSH
5464: LD_INT 7
5466: PUSH
5467: LD_INT 8
5469: PUSH
5470: EMPTY
5471: LIST
5472: LIST
5473: LIST
5474: PUSH
5475: LD_OWVAR 67
5479: ARRAY
5480: PPUSH
5481: LD_INT 500
5483: PUSH
5484: LD_INT 100
5486: PUSH
5487: LD_INT 10
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: LIST
5494: PPUSH
5495: LD_INT 6
5497: PUSH
5498: LD_INT 7
5500: PUSH
5501: LD_INT 8
5503: PUSH
5504: EMPTY
5505: LIST
5506: LIST
5507: LIST
5508: PUSH
5509: LD_OWVAR 67
5513: ARRAY
5514: PUSH
5515: LD_INT 2
5517: PUSH
5518: LD_INT 0
5520: PUSH
5521: LD_INT 1
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: PPUSH
5530: CALL 28182 0 6
5534: ST_TO_ADDR
// end ;
5535: LD_VAR 0 1
5539: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5540: LD_INT 0
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
5551: PPUSH
5552: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5553: LD_INT 0
5555: PPUSH
5556: LD_INT 0
5558: PPUSH
5559: LD_INT 6
5561: PPUSH
5562: LD_INT 0
5564: PPUSH
5565: LD_INT 0
5567: PPUSH
5568: LD_INT 0
5570: PPUSH
5571: LD_INT 0
5573: PPUSH
5574: LD_INT 8
5576: PPUSH
5577: LD_INT 0
5579: PPUSH
5580: CALL 53235 0 9
// side := 8 ;
5584: LD_ADDR_VAR 0 8
5588: PUSH
5589: LD_INT 8
5591: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5592: LD_ADDR_VAR 0 5
5596: PUSH
5597: LD_INT 20
5599: PPUSH
5600: LD_INT 0
5602: PPUSH
5603: CALL_OW 517
5607: ST_TO_ADDR
// if Difficulty > 2 then
5608: LD_OWVAR 67
5612: PUSH
5613: LD_INT 2
5615: GREATER
5616: IFFALSE 5760
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5618: LD_ADDR_VAR 0 6
5622: PUSH
5623: LD_INT 27
5625: PPUSH
5626: LD_INT 0
5628: PPUSH
5629: CALL_OW 517
5633: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5634: LD_ADDR_VAR 0 2
5638: PUSH
5639: DOUBLE
5640: LD_INT 1
5642: DEC
5643: ST_TO_ADDR
5644: LD_VAR 0 6
5648: PUSH
5649: LD_INT 1
5651: ARRAY
5652: PUSH
5653: FOR_TO
5654: IFFALSE 5758
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5656: LD_ADDR_VAR 0 5
5660: PUSH
5661: LD_VAR 0 5
5665: PPUSH
5666: LD_INT 1
5668: PUSH
5669: LD_VAR 0 5
5673: PUSH
5674: LD_INT 1
5676: ARRAY
5677: PUSH
5678: LD_INT 1
5680: PLUS
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: PPUSH
5686: LD_VAR 0 6
5690: PUSH
5691: LD_INT 1
5693: ARRAY
5694: PUSH
5695: LD_VAR 0 2
5699: ARRAY
5700: PPUSH
5701: CALL 24858 0 3
5705: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5706: LD_ADDR_VAR 0 5
5710: PUSH
5711: LD_VAR 0 5
5715: PPUSH
5716: LD_INT 2
5718: PUSH
5719: LD_VAR 0 5
5723: PUSH
5724: LD_INT 2
5726: ARRAY
5727: PUSH
5728: LD_INT 1
5730: PLUS
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: PPUSH
5736: LD_VAR 0 6
5740: PUSH
5741: LD_INT 2
5743: ARRAY
5744: PUSH
5745: LD_VAR 0 2
5749: ARRAY
5750: PPUSH
5751: CALL 24858 0 3
5755: ST_TO_ADDR
// end ;
5756: GO 5653
5758: POP
5759: POP
// end ; if tmp then
5760: LD_VAR 0 5
5764: IFFALSE 5892
// begin for i = 1 to tmp [ 1 ] do
5766: LD_ADDR_VAR 0 2
5770: PUSH
5771: DOUBLE
5772: LD_INT 1
5774: DEC
5775: ST_TO_ADDR
5776: LD_VAR 0 5
5780: PUSH
5781: LD_INT 1
5783: ARRAY
5784: PUSH
5785: FOR_TO
5786: IFFALSE 5890
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5788: LD_VAR 0 5
5792: PUSH
5793: LD_INT 1
5795: ARRAY
5796: PUSH
5797: LD_VAR 0 2
5801: ARRAY
5802: PPUSH
5803: LD_VAR 0 5
5807: PUSH
5808: LD_INT 2
5810: ARRAY
5811: PUSH
5812: LD_VAR 0 2
5816: ARRAY
5817: PPUSH
5818: LD_VAR 0 8
5822: PPUSH
5823: LD_INT 0
5825: PPUSH
5826: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5830: LD_ADDR_EXP 16
5834: PUSH
5835: LD_EXP 16
5839: PPUSH
5840: LD_EXP 16
5844: PUSH
5845: LD_INT 1
5847: PLUS
5848: PPUSH
5849: LD_VAR 0 5
5853: PUSH
5854: LD_INT 1
5856: ARRAY
5857: PUSH
5858: LD_VAR 0 2
5862: ARRAY
5863: PUSH
5864: LD_VAR 0 5
5868: PUSH
5869: LD_INT 2
5871: ARRAY
5872: PUSH
5873: LD_VAR 0 2
5877: ARRAY
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: PPUSH
5883: CALL_OW 2
5887: ST_TO_ADDR
// end ;
5888: GO 5785
5890: POP
5891: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5892: LD_ADDR_VAR 0 7
5896: PUSH
5897: LD_INT 165
5899: PUSH
5900: LD_INT 156
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: LD_INT 143
5909: PUSH
5910: LD_INT 145
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 152
5919: PUSH
5920: LD_INT 165
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: PUSH
5927: LD_INT 123
5929: PUSH
5930: LD_INT 153
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: PUSH
5937: LD_INT 161
5939: PUSH
5940: LD_INT 215
5942: PUSH
5943: EMPTY
5944: LIST
5945: LIST
5946: PUSH
5947: LD_INT 172
5949: PUSH
5950: LD_INT 100
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: PUSH
5957: LD_INT 148
5959: PUSH
5960: LD_INT 83
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: PUSH
5967: LD_INT 122
5969: PUSH
5970: LD_INT 68
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 105
5979: PUSH
5980: LD_INT 74
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PUSH
5987: LD_INT 113
5989: PUSH
5990: LD_INT 97
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: PUSH
5997: EMPTY
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: LIST
6007: LIST
6008: ST_TO_ADDR
// for i in cameras do
6009: LD_ADDR_VAR 0 2
6013: PUSH
6014: LD_VAR 0 7
6018: PUSH
6019: FOR_IN
6020: IFFALSE 6051
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
6022: LD_VAR 0 2
6026: PUSH
6027: LD_INT 1
6029: ARRAY
6030: PPUSH
6031: LD_VAR 0 2
6035: PUSH
6036: LD_INT 2
6038: ARRAY
6039: PPUSH
6040: LD_VAR 0 8
6044: PPUSH
6045: CALL_OW 244
6049: GO 6019
6051: POP
6052: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6053: LD_ADDR_VAR 0 5
6057: PUSH
6058: LD_INT 1
6060: PUSH
6061: LD_INT 144
6063: PUSH
6064: LD_INT 110
6066: PUSH
6067: LD_INT 1
6069: PUSH
6070: LD_INT 0
6072: PUSH
6073: LD_INT 0
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 3
6086: PUSH
6087: LD_INT 151
6089: PUSH
6090: LD_INT 118
6092: PUSH
6093: LD_INT 0
6095: PUSH
6096: LD_INT 0
6098: PUSH
6099: LD_INT 0
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: LIST
6108: LIST
6109: PUSH
6110: LD_INT 8
6112: PUSH
6113: LD_INT 158
6115: PUSH
6116: LD_INT 110
6118: PUSH
6119: LD_INT 4
6121: PUSH
6122: LD_INT 10
6124: PUSH
6125: LD_INT 15
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: LIST
6134: LIST
6135: PUSH
6136: LD_INT 23
6138: PUSH
6139: LD_INT 154
6141: PUSH
6142: LD_INT 121
6144: PUSH
6145: LD_INT 5
6147: PUSH
6148: LD_INT 0
6150: PUSH
6151: LD_INT 0
6153: PUSH
6154: EMPTY
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 22
6164: PUSH
6165: LD_INT 155
6167: PUSH
6168: LD_INT 118
6170: PUSH
6171: LD_INT 4
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: LD_INT 0
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: LIST
6186: LIST
6187: PUSH
6188: LD_INT 21
6190: PUSH
6191: LD_INT 151
6193: PUSH
6194: LD_INT 122
6196: PUSH
6197: LD_INT 0
6199: PUSH
6200: LD_INT 0
6202: PUSH
6203: LD_INT 0
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: LIST
6212: LIST
6213: PUSH
6214: LD_INT 18
6216: PUSH
6217: LD_INT 148
6219: PUSH
6220: LD_INT 118
6222: PUSH
6223: LD_INT 1
6225: PUSH
6226: LD_INT 0
6228: PUSH
6229: LD_INT 0
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: PUSH
6240: LD_INT 17
6242: PUSH
6243: LD_INT 147
6245: PUSH
6246: LD_INT 114
6248: PUSH
6249: LD_INT 2
6251: PUSH
6252: LD_INT 0
6254: PUSH
6255: LD_INT 0
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: LIST
6264: LIST
6265: PUSH
6266: LD_INT 29
6268: PUSH
6269: LD_INT 163
6271: PUSH
6272: LD_INT 120
6274: PUSH
6275: LD_INT 5
6277: PUSH
6278: LD_INT 0
6280: PUSH
6281: LD_INT 0
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: LIST
6290: LIST
6291: PUSH
6292: LD_INT 27
6294: PUSH
6295: LD_INT 137
6297: PUSH
6298: LD_INT 116
6300: PUSH
6301: LD_INT 3
6303: PUSH
6304: LD_INT 0
6306: PUSH
6307: LD_INT 0
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_INT 27
6320: PUSH
6321: LD_INT 133
6323: PUSH
6324: LD_INT 111
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 0
6332: PUSH
6333: LD_INT 0
6335: PUSH
6336: EMPTY
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: LIST
6342: LIST
6343: PUSH
6344: LD_INT 27
6346: PUSH
6347: LD_INT 132
6349: PUSH
6350: LD_INT 106
6352: PUSH
6353: LD_INT 4
6355: PUSH
6356: LD_INT 0
6358: PUSH
6359: LD_INT 0
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: PUSH
6370: LD_INT 26
6372: PUSH
6373: LD_INT 137
6375: PUSH
6376: LD_INT 111
6378: PUSH
6379: LD_INT 0
6381: PUSH
6382: LD_INT 0
6384: PUSH
6385: LD_INT 0
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_INT 8
6398: PUSH
6399: LD_INT 141
6401: PUSH
6402: LD_INT 117
6404: PUSH
6405: LD_INT 1
6407: PUSH
6408: LD_INT 13
6410: PUSH
6411: LD_INT 11
6413: PUSH
6414: EMPTY
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: LIST
6420: LIST
6421: PUSH
6422: LD_INT 30
6424: PUSH
6425: LD_INT 140
6427: PUSH
6428: LD_INT 128
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 0
6436: PUSH
6437: LD_INT 0
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: LIST
6446: LIST
6447: PUSH
6448: LD_INT 5
6450: PUSH
6451: LD_INT 146
6453: PUSH
6454: LD_INT 96
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 0
6462: PUSH
6463: LD_INT 0
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 32
6476: PUSH
6477: LD_INT 150
6479: PUSH
6480: LD_INT 98
6482: PUSH
6483: LD_INT 3
6485: PUSH
6486: LD_INT 0
6488: PUSH
6489: LD_INT 0
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 32
6502: PUSH
6503: LD_INT 142
6505: PUSH
6506: LD_INT 95
6508: PUSH
6509: LD_INT 3
6511: PUSH
6512: LD_INT 0
6514: PUSH
6515: LD_INT 0
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 32
6528: PUSH
6529: LD_INT 159
6531: PUSH
6532: LD_INT 104
6534: PUSH
6535: LD_INT 3
6537: PUSH
6538: LD_INT 0
6540: PUSH
6541: LD_INT 0
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: LIST
6550: LIST
6551: PUSH
6552: LD_INT 32
6554: PUSH
6555: LD_INT 133
6557: PUSH
6558: LD_INT 95
6560: PUSH
6561: LD_INT 3
6563: PUSH
6564: LD_INT 0
6566: PUSH
6567: LD_INT 0
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: LIST
6576: LIST
6577: PUSH
6578: LD_INT 32
6580: PUSH
6581: LD_INT 131
6583: PUSH
6584: LD_INT 102
6586: PUSH
6587: LD_INT 2
6589: PUSH
6590: LD_INT 0
6592: PUSH
6593: LD_INT 0
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: PUSH
6604: LD_INT 32
6606: PUSH
6607: LD_INT 164
6609: PUSH
6610: LD_INT 144
6612: PUSH
6613: LD_INT 0
6615: PUSH
6616: LD_INT 0
6618: PUSH
6619: LD_INT 0
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: LIST
6629: PUSH
6630: LD_INT 32
6632: PUSH
6633: LD_INT 146
6635: PUSH
6636: LD_INT 139
6638: PUSH
6639: LD_INT 0
6641: PUSH
6642: LD_INT 0
6644: PUSH
6645: LD_INT 0
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: LIST
6654: LIST
6655: PUSH
6656: LD_INT 26
6658: PUSH
6659: LD_INT 143
6661: PUSH
6662: LD_INT 122
6664: PUSH
6665: LD_INT 4
6667: PUSH
6668: LD_INT 0
6670: PUSH
6671: LD_INT 0
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: LIST
6680: LIST
6681: PUSH
6682: LD_INT 26
6684: PUSH
6685: LD_INT 164
6687: PUSH
6688: LD_INT 116
6690: PUSH
6691: LD_INT 2
6693: PUSH
6694: LD_INT 0
6696: PUSH
6697: LD_INT 0
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: LIST
6733: LIST
6734: ST_TO_ADDR
// for i in tmp do
6735: LD_ADDR_VAR 0 2
6739: PUSH
6740: LD_VAR 0 5
6744: PUSH
6745: FOR_IN
6746: IFFALSE 6977
// begin uc_side := side ;
6748: LD_ADDR_OWVAR 20
6752: PUSH
6753: LD_VAR 0 8
6757: ST_TO_ADDR
// uc_nation := nation_arabian ;
6758: LD_ADDR_OWVAR 21
6762: PUSH
6763: LD_INT 2
6765: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6766: LD_ADDR_OWVAR 42
6770: PUSH
6771: LD_VAR 0 2
6775: PUSH
6776: LD_INT 1
6778: ARRAY
6779: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6780: LD_ADDR_OWVAR 43
6784: PUSH
6785: LD_INT 5
6787: PPUSH
6788: LD_INT 6
6790: PPUSH
6791: CALL_OW 12
6795: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6796: LD_ADDR_OWVAR 44
6800: PUSH
6801: LD_VAR 0 2
6805: PUSH
6806: LD_INT 5
6808: ARRAY
6809: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6810: LD_ADDR_OWVAR 45
6814: PUSH
6815: LD_VAR 0 2
6819: PUSH
6820: LD_INT 6
6822: ARRAY
6823: ST_TO_ADDR
// sr := 0 ;
6824: LD_ADDR_VAR 0 9
6828: PUSH
6829: LD_INT 0
6831: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6832: LD_VAR 0 2
6836: PUSH
6837: LD_INT 1
6839: ARRAY
6840: PUSH
6841: LD_INT 29
6843: EQUAL
6844: IFFALSE 6856
// sr := mat_oil else
6846: LD_ADDR_VAR 0 9
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
6854: GO 6878
// if i [ 1 ] = b_siberite_mine then
6856: LD_VAR 0 2
6860: PUSH
6861: LD_INT 1
6863: ARRAY
6864: PUSH
6865: LD_INT 30
6867: EQUAL
6868: IFFALSE 6878
// sr := mat_siberit ;
6870: LD_ADDR_VAR 0 9
6874: PUSH
6875: LD_INT 3
6877: ST_TO_ADDR
// if sr then
6878: LD_VAR 0 9
6882: IFFALSE 6938
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6884: LD_VAR 0 2
6888: PUSH
6889: LD_INT 2
6891: ARRAY
6892: PPUSH
6893: LD_VAR 0 2
6897: PUSH
6898: LD_INT 3
6900: ARRAY
6901: PPUSH
6902: LD_VAR 0 9
6906: PPUSH
6907: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6911: LD_VAR 0 2
6915: PUSH
6916: LD_INT 2
6918: ARRAY
6919: PPUSH
6920: LD_VAR 0 2
6924: PUSH
6925: LD_INT 3
6927: ARRAY
6928: PPUSH
6929: LD_VAR 0 8
6933: PPUSH
6934: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6938: LD_ADDR_VAR 0 3
6942: PUSH
6943: LD_VAR 0 2
6947: PUSH
6948: LD_INT 2
6950: ARRAY
6951: PPUSH
6952: LD_VAR 0 2
6956: PUSH
6957: LD_INT 3
6959: ARRAY
6960: PPUSH
6961: LD_VAR 0 2
6965: PUSH
6966: LD_INT 4
6968: ARRAY
6969: PPUSH
6970: CALL_OW 47
6974: ST_TO_ADDR
// end ;
6975: GO 6745
6977: POP
6978: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6979: LD_ADDR_VAR 0 10
6983: PUSH
6984: LD_INT 22
6986: PUSH
6987: LD_VAR 0 8
6991: PUSH
6992: EMPTY
6993: LIST
6994: LIST
6995: PUSH
6996: LD_INT 30
6998: PUSH
6999: LD_INT 1
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PPUSH
7010: CALL_OW 69
7014: ST_TO_ADDR
// if not depot then
7015: LD_VAR 0 10
7019: NOT
7020: IFFALSE 7024
// exit ;
7022: GO 7270
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
7024: LD_ADDR_VAR 0 11
7028: PUSH
7029: LD_VAR 0 10
7033: PUSH
7034: LD_INT 1
7036: ARRAY
7037: PPUSH
7038: LD_INT 6
7040: PPUSH
7041: LD_INT 0
7043: PPUSH
7044: LD_INT 7
7046: PUSH
7047: LD_INT 8
7049: PUSH
7050: LD_INT 10
7052: PUSH
7053: EMPTY
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_OWVAR 67
7062: ARRAY
7063: PPUSH
7064: LD_INT 3000
7066: PUSH
7067: LD_INT 300
7069: PUSH
7070: LD_INT 100
7072: PUSH
7073: EMPTY
7074: LIST
7075: LIST
7076: LIST
7077: PPUSH
7078: LD_INT 14
7080: PUSH
7081: LD_INT 6
7083: PUSH
7084: LD_INT 6
7086: PUSH
7087: LD_INT 5
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: LIST
7094: LIST
7095: PPUSH
7096: CALL 28182 0 6
7100: ST_TO_ADDR
// if not base then
7101: LD_VAR 0 11
7105: NOT
7106: IFFALSE 7110
// exit ;
7108: GO 7270
// if Difficulty > 1 then
7110: LD_OWVAR 67
7114: PUSH
7115: LD_INT 1
7117: GREATER
7118: IFFALSE 7191
// begin InitHc ;
7120: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7124: LD_INT 1
7126: PPUSH
7127: LD_INT 5
7129: PPUSH
7130: LD_INT 5
7132: PUSH
7133: LD_INT 8
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: PUSH
7140: LD_OWVAR 67
7144: PUSH
7145: LD_INT 1
7147: MINUS
7148: ARRAY
7149: PPUSH
7150: CALL_OW 380
// for i = 1 to Difficulty do
7154: LD_ADDR_VAR 0 2
7158: PUSH
7159: DOUBLE
7160: LD_INT 1
7162: DEC
7163: ST_TO_ADDR
7164: LD_OWVAR 67
7168: PUSH
7169: FOR_TO
7170: IFFALSE 7189
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7172: CALL_OW 44
7176: PPUSH
7177: LD_INT 24
7179: PPUSH
7180: LD_INT 0
7182: PPUSH
7183: CALL_OW 49
7187: GO 7169
7189: POP
7190: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7191: LD_ADDR_EXP 50
7195: PUSH
7196: LD_EXP 50
7200: PPUSH
7201: LD_EXP 6
7205: PPUSH
7206: LD_VAR 0 11
7210: PPUSH
7211: CALL_OW 1
7215: ST_TO_ADDR
// hc_gallery := ru ;
7216: LD_ADDR_OWVAR 33
7220: PUSH
7221: LD_STRING ru
7223: ST_TO_ADDR
// hc_face_number := 44 ;
7224: LD_ADDR_OWVAR 34
7228: PUSH
7229: LD_INT 44
7231: ST_TO_ADDR
// hc_name := Robert Farmer ;
7232: LD_ADDR_OWVAR 26
7236: PUSH
7237: LD_STRING Robert Farmer
7239: ST_TO_ADDR
// hc_sex := sex_male ;
7240: LD_ADDR_OWVAR 27
7244: PUSH
7245: LD_INT 1
7247: ST_TO_ADDR
// hc_class := 1 ;
7248: LD_ADDR_OWVAR 28
7252: PUSH
7253: LD_INT 1
7255: ST_TO_ADDR
// Farmer := CreateHuman ;
7256: LD_ADDR_EXP 13
7260: PUSH
7261: CALL_OW 44
7265: ST_TO_ADDR
// InitHc ;
7266: CALL_OW 19
// end ;
7270: LD_VAR 0 1
7274: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7275: LD_INT 0
7277: PPUSH
7278: PPUSH
7279: PPUSH
7280: PPUSH
// tmp := [ ] ;
7281: LD_ADDR_VAR 0 3
7285: PUSH
7286: EMPTY
7287: ST_TO_ADDR
// for i := 1 to 3 do
7288: LD_ADDR_VAR 0 2
7292: PUSH
7293: DOUBLE
7294: LD_INT 1
7296: DEC
7297: ST_TO_ADDR
7298: LD_INT 3
7300: PUSH
7301: FOR_TO
7302: IFFALSE 7414
// begin uc_side := 3 ;
7304: LD_ADDR_OWVAR 20
7308: PUSH
7309: LD_INT 3
7311: ST_TO_ADDR
// uc_nation := 3 ;
7312: LD_ADDR_OWVAR 21
7316: PUSH
7317: LD_INT 3
7319: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7320: LD_ADDR_OWVAR 37
7324: PUSH
7325: LD_INT 22
7327: ST_TO_ADDR
// vc_engine := engine_siberite ;
7328: LD_ADDR_OWVAR 39
7332: PUSH
7333: LD_INT 3
7335: ST_TO_ADDR
// vc_control := control_computer ;
7336: LD_ADDR_OWVAR 38
7340: PUSH
7341: LD_INT 3
7343: ST_TO_ADDR
// vc_weapon := ru_crane ;
7344: LD_ADDR_OWVAR 40
7348: PUSH
7349: LD_INT 52
7351: ST_TO_ADDR
// veh := CreateVehicle ;
7352: LD_ADDR_VAR 0 4
7356: PUSH
7357: CALL_OW 45
7361: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7362: LD_VAR 0 4
7366: PPUSH
7367: LD_INT 73
7369: PPUSH
7370: LD_INT 122
7372: PPUSH
7373: LD_INT 3
7375: PPUSH
7376: LD_INT 0
7378: PPUSH
7379: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7383: LD_ADDR_VAR 0 3
7387: PUSH
7388: LD_VAR 0 3
7392: PPUSH
7393: LD_VAR 0 3
7397: PUSH
7398: LD_INT 1
7400: PLUS
7401: PPUSH
7402: LD_VAR 0 4
7406: PPUSH
7407: CALL_OW 1
7411: ST_TO_ADDR
// end ;
7412: GO 7301
7414: POP
7415: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7416: LD_ADDR_EXP 69
7420: PUSH
7421: LD_EXP 69
7425: PPUSH
7426: LD_EXP 7
7430: PPUSH
7431: LD_VAR 0 3
7435: PPUSH
7436: CALL_OW 1
7440: ST_TO_ADDR
// tmp := [ ] ;
7441: LD_ADDR_VAR 0 3
7445: PUSH
7446: EMPTY
7447: ST_TO_ADDR
// for i := 1 to 3 do
7448: LD_ADDR_VAR 0 2
7452: PUSH
7453: DOUBLE
7454: LD_INT 1
7456: DEC
7457: ST_TO_ADDR
7458: LD_INT 3
7460: PUSH
7461: FOR_TO
7462: IFFALSE 7574
// begin uc_side := 3 ;
7464: LD_ADDR_OWVAR 20
7468: PUSH
7469: LD_INT 3
7471: ST_TO_ADDR
// uc_nation := 3 ;
7472: LD_ADDR_OWVAR 21
7476: PUSH
7477: LD_INT 3
7479: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7480: LD_ADDR_OWVAR 37
7484: PUSH
7485: LD_INT 22
7487: ST_TO_ADDR
// vc_engine := engine_siberite ;
7488: LD_ADDR_OWVAR 39
7492: PUSH
7493: LD_INT 3
7495: ST_TO_ADDR
// vc_control := control_computer ;
7496: LD_ADDR_OWVAR 38
7500: PUSH
7501: LD_INT 3
7503: ST_TO_ADDR
// vc_weapon := ru_crane ;
7504: LD_ADDR_OWVAR 40
7508: PUSH
7509: LD_INT 52
7511: ST_TO_ADDR
// veh := CreateVehicle ;
7512: LD_ADDR_VAR 0 4
7516: PUSH
7517: CALL_OW 45
7521: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7522: LD_VAR 0 4
7526: PPUSH
7527: LD_INT 22
7529: PPUSH
7530: LD_INT 28
7532: PPUSH
7533: LD_INT 3
7535: PPUSH
7536: LD_INT 0
7538: PPUSH
7539: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7543: LD_ADDR_VAR 0 3
7547: PUSH
7548: LD_VAR 0 3
7552: PPUSH
7553: LD_VAR 0 3
7557: PUSH
7558: LD_INT 1
7560: PLUS
7561: PPUSH
7562: LD_VAR 0 4
7566: PPUSH
7567: CALL_OW 1
7571: ST_TO_ADDR
// end ;
7572: GO 7461
7574: POP
7575: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7576: LD_ADDR_EXP 69
7580: PUSH
7581: LD_EXP 69
7585: PPUSH
7586: LD_EXP 8
7590: PPUSH
7591: LD_VAR 0 3
7595: PPUSH
7596: CALL_OW 1
7600: ST_TO_ADDR
// end ;
7601: LD_VAR 0 1
7605: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7606: LD_INT 0
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
7613: PPUSH
7614: PPUSH
7615: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7616: LD_INT 0
7618: PPUSH
7619: LD_INT 0
7621: PPUSH
7622: LD_INT 4
7624: PPUSH
7625: LD_INT 0
7627: PPUSH
7628: LD_INT 0
7630: PPUSH
7631: LD_INT 0
7633: PPUSH
7634: LD_INT 0
7636: PPUSH
7637: LD_INT 10
7639: PPUSH
7640: LD_INT 0
7642: PPUSH
7643: CALL 53235 0 9
// side := 4 ;
7647: LD_ADDR_VAR 0 5
7651: PUSH
7652: LD_INT 4
7654: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7655: LD_ADDR_VAR 0 4
7659: PUSH
7660: LD_INT 1
7662: PUSH
7663: LD_INT 144
7665: PUSH
7666: LD_INT 18
7668: PUSH
7669: LD_INT 4
7671: PUSH
7672: LD_INT 0
7674: PUSH
7675: LD_INT 0
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 3
7688: PUSH
7689: LD_INT 137
7691: PUSH
7692: LD_INT 8
7694: PUSH
7695: LD_INT 4
7697: PUSH
7698: LD_INT 0
7700: PUSH
7701: LD_INT 0
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: LIST
7711: PUSH
7712: LD_INT 22
7714: PUSH
7715: LD_INT 141
7717: PUSH
7718: LD_INT 8
7720: PUSH
7721: LD_INT 4
7723: PUSH
7724: LD_INT 0
7726: PUSH
7727: LD_INT 0
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: LD_INT 25
7740: PUSH
7741: LD_INT 137
7743: PUSH
7744: LD_INT 5
7746: PUSH
7747: LD_INT 3
7749: PUSH
7750: LD_INT 0
7752: PUSH
7753: LD_INT 0
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 18
7766: PUSH
7767: LD_INT 137
7769: PUSH
7770: LD_INT 12
7772: PUSH
7773: LD_INT 0
7775: PUSH
7776: LD_INT 0
7778: PUSH
7779: LD_INT 0
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 17
7792: PUSH
7793: LD_INT 133
7795: PUSH
7796: LD_INT 4
7798: PUSH
7799: LD_INT 2
7801: PUSH
7802: LD_INT 0
7804: PUSH
7805: LD_INT 0
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 16
7818: PUSH
7819: LD_INT 140
7821: PUSH
7822: LD_INT 11
7824: PUSH
7825: LD_INT 5
7827: PUSH
7828: LD_INT 0
7830: PUSH
7831: LD_INT 0
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: LIST
7840: LIST
7841: PUSH
7842: LD_INT 8
7844: PUSH
7845: LD_INT 149
7847: PUSH
7848: LD_INT 26
7850: PUSH
7851: LD_INT 4
7853: PUSH
7854: LD_INT 10
7856: PUSH
7857: LD_INT 15
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: LIST
7866: LIST
7867: PUSH
7868: LD_INT 8
7870: PUSH
7871: LD_INT 142
7873: PUSH
7874: LD_INT 26
7876: PUSH
7877: LD_INT 1
7879: PUSH
7880: LD_INT 11
7882: PUSH
7883: LD_INT 12
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: LIST
7892: LIST
7893: PUSH
7894: LD_INT 27
7896: PUSH
7897: LD_INT 153
7899: PUSH
7900: LD_INT 32
7902: PUSH
7903: LD_INT 5
7905: PUSH
7906: LD_INT 0
7908: PUSH
7909: LD_INT 0
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 27
7922: PUSH
7923: LD_INT 145
7925: PUSH
7926: LD_INT 32
7928: PUSH
7929: LD_INT 3
7931: PUSH
7932: LD_INT 0
7934: PUSH
7935: LD_INT 0
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: LIST
7942: LIST
7943: LIST
7944: LIST
7945: PUSH
7946: LD_INT 27
7948: PUSH
7949: LD_INT 138
7951: PUSH
7952: LD_INT 2
7954: PUSH
7955: LD_INT 4
7957: PUSH
7958: LD_INT 0
7960: PUSH
7961: LD_INT 0
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: LIST
7968: LIST
7969: LIST
7970: LIST
7971: PUSH
7972: LD_INT 27
7974: PUSH
7975: LD_INT 144
7977: PUSH
7978: LD_INT 13
7980: PUSH
7981: LD_INT 0
7983: PUSH
7984: LD_INT 0
7986: PUSH
7987: LD_INT 0
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: LIST
7996: LIST
7997: PUSH
7998: LD_INT 26
8000: PUSH
8001: LD_INT 124
8003: PUSH
8004: LD_INT 2
8006: PUSH
8007: LD_INT 4
8009: PUSH
8010: LD_INT 0
8012: PUSH
8013: LD_INT 0
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: PUSH
8024: LD_INT 26
8026: PUSH
8027: LD_INT 121
8029: PUSH
8030: LD_INT 2
8032: PUSH
8033: LD_INT 2
8035: PUSH
8036: LD_INT 0
8038: PUSH
8039: LD_INT 0
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: LIST
8048: LIST
8049: PUSH
8050: LD_INT 26
8052: PUSH
8053: LD_INT 118
8055: PUSH
8056: LD_INT 2
8058: PUSH
8059: LD_INT 1
8061: PUSH
8062: LD_INT 0
8064: PUSH
8065: LD_INT 0
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: LIST
8074: LIST
8075: PUSH
8076: LD_INT 29
8078: PUSH
8079: LD_INT 159
8081: PUSH
8082: LD_INT 47
8084: PUSH
8085: LD_INT 2
8087: PUSH
8088: LD_INT 0
8090: PUSH
8091: LD_INT 0
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: LIST
8101: PUSH
8102: LD_INT 32
8104: PUSH
8105: LD_INT 146
8107: PUSH
8108: LD_INT 41
8110: PUSH
8111: LD_INT 0
8113: PUSH
8114: LD_INT 0
8116: PUSH
8117: LD_INT 0
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: LIST
8126: LIST
8127: PUSH
8128: LD_INT 33
8130: PUSH
8131: LD_INT 136
8133: PUSH
8134: LD_INT 37
8136: PUSH
8137: LD_INT 0
8139: PUSH
8140: LD_INT 0
8142: PUSH
8143: LD_INT 0
8145: PUSH
8146: EMPTY
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: LIST
8152: LIST
8153: PUSH
8154: LD_INT 33
8156: PUSH
8157: LD_INT 132
8159: PUSH
8160: LD_INT 34
8162: PUSH
8163: LD_INT 0
8165: PUSH
8166: LD_INT 0
8168: PUSH
8169: LD_INT 0
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: LIST
8178: LIST
8179: PUSH
8180: LD_INT 36
8182: PUSH
8183: LD_INT 124
8185: PUSH
8186: LD_INT 7
8188: PUSH
8189: LD_INT 1
8191: PUSH
8192: LD_INT 0
8194: PUSH
8195: LD_INT 0
8197: PUSH
8198: EMPTY
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: LIST
8204: LIST
8205: PUSH
8206: LD_INT 5
8208: PUSH
8209: LD_INT 124
8211: PUSH
8212: LD_INT 19
8214: PUSH
8215: LD_INT 0
8217: PUSH
8218: LD_INT 0
8220: PUSH
8221: LD_INT 0
8223: PUSH
8224: EMPTY
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 32
8234: PUSH
8235: LD_INT 127
8237: PUSH
8238: LD_INT 23
8240: PUSH
8241: LD_INT 0
8243: PUSH
8244: LD_INT 0
8246: PUSH
8247: LD_INT 0
8249: PUSH
8250: EMPTY
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: LIST
8256: LIST
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: LIST
8281: LIST
8282: ST_TO_ADDR
// for i in tmp do
8283: LD_ADDR_VAR 0 2
8287: PUSH
8288: LD_VAR 0 4
8292: PUSH
8293: FOR_IN
8294: IFFALSE 8525
// begin uc_side := side ;
8296: LD_ADDR_OWVAR 20
8300: PUSH
8301: LD_VAR 0 5
8305: ST_TO_ADDR
// uc_nation := nation_american ;
8306: LD_ADDR_OWVAR 21
8310: PUSH
8311: LD_INT 1
8313: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8314: LD_ADDR_OWVAR 42
8318: PUSH
8319: LD_VAR 0 2
8323: PUSH
8324: LD_INT 1
8326: ARRAY
8327: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8328: LD_ADDR_OWVAR 43
8332: PUSH
8333: LD_INT 5
8335: PPUSH
8336: LD_INT 6
8338: PPUSH
8339: CALL_OW 12
8343: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8344: LD_ADDR_OWVAR 44
8348: PUSH
8349: LD_VAR 0 2
8353: PUSH
8354: LD_INT 5
8356: ARRAY
8357: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8358: LD_ADDR_OWVAR 45
8362: PUSH
8363: LD_VAR 0 2
8367: PUSH
8368: LD_INT 6
8370: ARRAY
8371: ST_TO_ADDR
// sr := 0 ;
8372: LD_ADDR_VAR 0 6
8376: PUSH
8377: LD_INT 0
8379: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8380: LD_VAR 0 2
8384: PUSH
8385: LD_INT 1
8387: ARRAY
8388: PUSH
8389: LD_INT 29
8391: EQUAL
8392: IFFALSE 8404
// sr := mat_oil else
8394: LD_ADDR_VAR 0 6
8398: PUSH
8399: LD_INT 2
8401: ST_TO_ADDR
8402: GO 8426
// if i [ 1 ] = b_siberite_mine then
8404: LD_VAR 0 2
8408: PUSH
8409: LD_INT 1
8411: ARRAY
8412: PUSH
8413: LD_INT 30
8415: EQUAL
8416: IFFALSE 8426
// sr := mat_siberit ;
8418: LD_ADDR_VAR 0 6
8422: PUSH
8423: LD_INT 3
8425: ST_TO_ADDR
// if sr then
8426: LD_VAR 0 6
8430: IFFALSE 8486
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8432: LD_VAR 0 2
8436: PUSH
8437: LD_INT 2
8439: ARRAY
8440: PPUSH
8441: LD_VAR 0 2
8445: PUSH
8446: LD_INT 3
8448: ARRAY
8449: PPUSH
8450: LD_VAR 0 6
8454: PPUSH
8455: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8459: LD_VAR 0 2
8463: PUSH
8464: LD_INT 2
8466: ARRAY
8467: PPUSH
8468: LD_VAR 0 2
8472: PUSH
8473: LD_INT 3
8475: ARRAY
8476: PPUSH
8477: LD_VAR 0 5
8481: PPUSH
8482: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8486: LD_ADDR_VAR 0 3
8490: PUSH
8491: LD_VAR 0 2
8495: PUSH
8496: LD_INT 2
8498: ARRAY
8499: PPUSH
8500: LD_VAR 0 2
8504: PUSH
8505: LD_INT 3
8507: ARRAY
8508: PPUSH
8509: LD_VAR 0 2
8513: PUSH
8514: LD_INT 4
8516: ARRAY
8517: PPUSH
8518: CALL_OW 47
8522: ST_TO_ADDR
// end ;
8523: GO 8293
8525: POP
8526: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8527: LD_ADDR_VAR 0 8
8531: PUSH
8532: LD_INT 22
8534: PUSH
8535: LD_VAR 0 5
8539: PUSH
8540: EMPTY
8541: LIST
8542: LIST
8543: PUSH
8544: LD_INT 30
8546: PUSH
8547: LD_INT 1
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: PPUSH
8558: CALL_OW 69
8562: ST_TO_ADDR
// if not depot then
8563: LD_VAR 0 8
8567: NOT
8568: IFFALSE 8572
// exit ;
8570: GO 8844
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8572: LD_ADDR_VAR 0 7
8576: PUSH
8577: LD_VAR 0 8
8581: PUSH
8582: LD_INT 1
8584: ARRAY
8585: PPUSH
8586: LD_INT 3
8588: PPUSH
8589: LD_STRING theta3
8591: PPUSH
8592: LD_INT 8
8594: PUSH
8595: LD_INT 7
8597: PUSH
8598: LD_INT 6
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: LIST
8605: PUSH
8606: LD_OWVAR 67
8610: ARRAY
8611: PPUSH
8612: LD_INT 2500
8614: PUSH
8615: LD_INT 2000
8617: PUSH
8618: LD_INT 1750
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: PUSH
8626: LD_OWVAR 67
8630: ARRAY
8631: PUSH
8632: LD_INT 300
8634: PUSH
8635: LD_INT 250
8637: PUSH
8638: LD_INT 200
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: LIST
8645: PUSH
8646: LD_OWVAR 67
8650: ARRAY
8651: PUSH
8652: LD_INT 80
8654: PUSH
8655: LD_INT 60
8657: PUSH
8658: LD_INT 50
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: LIST
8665: PUSH
8666: LD_OWVAR 67
8670: ARRAY
8671: PUSH
8672: EMPTY
8673: LIST
8674: LIST
8675: LIST
8676: PPUSH
8677: LD_INT 7
8679: PUSH
8680: LD_INT 6
8682: PUSH
8683: LD_INT 5
8685: PUSH
8686: LD_INT 5
8688: PUSH
8689: EMPTY
8690: LIST
8691: LIST
8692: LIST
8693: LIST
8694: PPUSH
8695: CALL 28182 0 6
8699: ST_TO_ADDR
// if not base then
8700: LD_VAR 0 7
8704: NOT
8705: IFFALSE 8709
// exit ;
8707: GO 8844
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8709: LD_ADDR_EXP 50
8713: PUSH
8714: LD_EXP 50
8718: PPUSH
8719: LD_EXP 5
8723: PPUSH
8724: LD_VAR 0 7
8728: PPUSH
8729: CALL_OW 1
8733: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 1
8739: PPUSH
8740: LD_INT 7
8742: PPUSH
8743: CALL_OW 380
// allyCommander := CreateHuman ;
8747: LD_ADDR_EXP 11
8751: PUSH
8752: CALL_OW 44
8756: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8757: LD_EXP 11
8761: PPUSH
8762: LD_INT 139
8764: PPUSH
8765: LD_INT 15
8767: PPUSH
8768: LD_INT 0
8770: PPUSH
8771: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8775: LD_EXP 11
8779: PPUSH
8780: LD_INT 137
8782: PPUSH
8783: LD_INT 15
8785: PPUSH
8786: CALL_OW 118
// hc_gallery := us ;
8790: LD_ADDR_OWVAR 33
8794: PUSH
8795: LD_STRING us
8797: ST_TO_ADDR
// hc_face_number := 7 ;
8798: LD_ADDR_OWVAR 34
8802: PUSH
8803: LD_INT 7
8805: ST_TO_ADDR
// hc_name := Arthur Powell ;
8806: LD_ADDR_OWVAR 26
8810: PUSH
8811: LD_STRING Arthur Powell
8813: ST_TO_ADDR
// hc_sex := sex_male ;
8814: LD_ADDR_OWVAR 27
8818: PUSH
8819: LD_INT 1
8821: ST_TO_ADDR
// hc_class := 1 ;
8822: LD_ADDR_OWVAR 28
8826: PUSH
8827: LD_INT 1
8829: ST_TO_ADDR
// Powell := CreateHuman ;
8830: LD_ADDR_EXP 12
8834: PUSH
8835: CALL_OW 44
8839: ST_TO_ADDR
// InitHc ;
8840: CALL_OW 19
// end ;
8844: LD_VAR 0 1
8848: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8849: LD_INT 0
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
8859: PPUSH
// side := 1 ;
8860: LD_ADDR_VAR 0 3
8864: PUSH
8865: LD_INT 1
8867: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8868: LD_ADDR_VAR 0 1
8872: PUSH
8873: EMPTY
8874: PUSH
8875: EMPTY
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: ST_TO_ADDR
// uc_side := side ;
8881: LD_ADDR_OWVAR 20
8885: PUSH
8886: LD_VAR 0 3
8890: ST_TO_ADDR
// uc_nation := nation_american ;
8891: LD_ADDR_OWVAR 21
8895: PUSH
8896: LD_INT 1
8898: ST_TO_ADDR
// InitHc ;
8899: CALL_OW 19
// InitVc ;
8903: CALL_OW 20
// hc_importance := 0 ;
8907: LD_ADDR_OWVAR 32
8911: PUSH
8912: LD_INT 0
8914: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8915: LD_ADDR_VAR 0 7
8919: PUSH
8920: LD_INT 2
8922: PUSH
8923: LD_INT 3
8925: PUSH
8926: LD_INT 3
8928: PUSH
8929: EMPTY
8930: LIST
8931: LIST
8932: LIST
8933: ST_TO_ADDR
// if commander = 2 then
8934: LD_EXP 25
8938: PUSH
8939: LD_INT 2
8941: EQUAL
8942: IFFALSE 8963
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8944: LD_ADDR_VAR 0 7
8948: PUSH
8949: LD_INT 3
8951: PUSH
8952: LD_INT 4
8954: PUSH
8955: LD_INT 4
8957: PUSH
8958: EMPTY
8959: LIST
8960: LIST
8961: LIST
8962: ST_TO_ADDR
// if commander = 3 then
8963: LD_EXP 25
8967: PUSH
8968: LD_INT 3
8970: EQUAL
8971: IFFALSE 8992
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8973: LD_ADDR_VAR 0 7
8977: PUSH
8978: LD_INT 2
8980: PUSH
8981: LD_INT 5
8983: PUSH
8984: LD_INT 5
8986: PUSH
8987: EMPTY
8988: LIST
8989: LIST
8990: LIST
8991: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8992: LD_ADDR_VAR 0 8
8996: PUSH
8997: LD_INT 2
8999: PUSH
9000: LD_INT 2
9002: PUSH
9003: LD_INT 1
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: LIST
9010: ST_TO_ADDR
// if commander = 2 then
9011: LD_EXP 25
9015: PUSH
9016: LD_INT 2
9018: EQUAL
9019: IFFALSE 9040
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
9021: LD_ADDR_VAR 0 8
9025: PUSH
9026: LD_INT 1
9028: PUSH
9029: LD_INT 1
9031: PUSH
9032: LD_INT 3
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: LIST
9039: ST_TO_ADDR
// if commander = 3 then
9040: LD_EXP 25
9044: PUSH
9045: LD_INT 3
9047: EQUAL
9048: IFFALSE 9069
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9050: LD_ADDR_VAR 0 8
9054: PUSH
9055: LD_INT 3
9057: PUSH
9058: LD_INT 3
9060: PUSH
9061: LD_INT 1
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: LIST
9068: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9069: LD_ADDR_VAR 0 9
9073: PUSH
9074: LD_INT 5
9076: PUSH
9077: LD_INT 3
9079: PUSH
9080: LD_INT 4
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: ST_TO_ADDR
// if commander = 2 then
9088: LD_EXP 25
9092: PUSH
9093: LD_INT 2
9095: EQUAL
9096: IFFALSE 9117
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9098: LD_ADDR_VAR 0 9
9102: PUSH
9103: LD_INT 7
9105: PUSH
9106: LD_INT 5
9108: PUSH
9109: LD_INT 6
9111: PUSH
9112: EMPTY
9113: LIST
9114: LIST
9115: LIST
9116: ST_TO_ADDR
// if commander = 3 then
9117: LD_EXP 25
9121: PUSH
9122: LD_INT 3
9124: EQUAL
9125: IFFALSE 9146
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9127: LD_ADDR_VAR 0 9
9131: PUSH
9132: LD_INT 9
9134: PUSH
9135: LD_INT 10
9137: PUSH
9138: LD_INT 7
9140: PUSH
9141: EMPTY
9142: LIST
9143: LIST
9144: LIST
9145: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9146: LD_ADDR_VAR 0 5
9150: PUSH
9151: LD_INT 5
9153: PUSH
9154: LD_INT 5
9156: PUSH
9157: LD_INT 4
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: LIST
9164: PUSH
9165: LD_OWVAR 67
9169: ARRAY
9170: ST_TO_ADDR
// if commander = 2 then
9171: LD_EXP 25
9175: PUSH
9176: LD_INT 2
9178: EQUAL
9179: IFFALSE 9195
// tanks := tanks + 3 ;
9181: LD_ADDR_VAR 0 5
9185: PUSH
9186: LD_VAR 0 5
9190: PUSH
9191: LD_INT 3
9193: PLUS
9194: ST_TO_ADDR
// for i = 1 to tanks do
9195: LD_ADDR_VAR 0 2
9199: PUSH
9200: DOUBLE
9201: LD_INT 1
9203: DEC
9204: ST_TO_ADDR
9205: LD_VAR 0 5
9209: PUSH
9210: FOR_TO
9211: IFFALSE 9321
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9213: LD_VAR 0 7
9217: PUSH
9218: LD_VAR 0 2
9222: PUSH
9223: LD_INT 3
9225: MOD
9226: PUSH
9227: LD_INT 1
9229: PLUS
9230: ARRAY
9231: PPUSH
9232: LD_VAR 0 8
9236: PUSH
9237: LD_INT 1
9239: PPUSH
9240: LD_INT 3
9242: PPUSH
9243: CALL_OW 12
9247: ARRAY
9248: PPUSH
9249: LD_INT 1
9251: PPUSH
9252: LD_VAR 0 9
9256: PUSH
9257: LD_VAR 0 2
9261: PUSH
9262: LD_INT 3
9264: MOD
9265: PUSH
9266: LD_INT 1
9268: PLUS
9269: ARRAY
9270: PPUSH
9271: LD_INT 60
9273: PPUSH
9274: LD_INT 70
9276: PPUSH
9277: CALL_OW 12
9281: PPUSH
9282: CALL 24736 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9286: LD_ADDR_VAR 0 1
9290: PUSH
9291: LD_VAR 0 1
9295: PPUSH
9296: LD_INT 1
9298: PPUSH
9299: LD_VAR 0 1
9303: PUSH
9304: LD_INT 1
9306: ARRAY
9307: PUSH
9308: CALL_OW 45
9312: ADD
9313: PPUSH
9314: CALL_OW 1
9318: ST_TO_ADDR
// end ;
9319: GO 9210
9321: POP
9322: POP
// cl := 1 ;
9323: LD_ADDR_VAR 0 6
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
// for i = 1 to 10 do
9331: LD_ADDR_VAR 0 2
9335: PUSH
9336: DOUBLE
9337: LD_INT 1
9339: DEC
9340: ST_TO_ADDR
9341: LD_INT 10
9343: PUSH
9344: FOR_TO
9345: IFFALSE 9460
// begin if i mod 4 = 0 then
9347: LD_VAR 0 2
9351: PUSH
9352: LD_INT 4
9354: MOD
9355: PUSH
9356: LD_INT 0
9358: EQUAL
9359: IFFALSE 9375
// cl := cl + 1 ;
9361: LD_ADDR_VAR 0 6
9365: PUSH
9366: LD_VAR 0 6
9370: PUSH
9371: LD_INT 1
9373: PLUS
9374: ST_TO_ADDR
// if cl = 2 then
9375: LD_VAR 0 6
9379: PUSH
9380: LD_INT 2
9382: EQUAL
9383: IFFALSE 9393
// cl := 3 ;
9385: LD_ADDR_VAR 0 6
9389: PUSH
9390: LD_INT 3
9392: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9393: LD_INT 0
9395: PPUSH
9396: LD_VAR 0 6
9400: PPUSH
9401: LD_INT 6
9403: PUSH
9404: LD_INT 6
9406: PUSH
9407: LD_INT 5
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: LIST
9414: PUSH
9415: LD_OWVAR 67
9419: ARRAY
9420: PPUSH
9421: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9425: LD_ADDR_VAR 0 1
9429: PUSH
9430: LD_VAR 0 1
9434: PPUSH
9435: LD_INT 2
9437: PPUSH
9438: LD_VAR 0 1
9442: PUSH
9443: LD_INT 2
9445: ARRAY
9446: PUSH
9447: CALL_OW 44
9451: ADD
9452: PPUSH
9453: CALL_OW 1
9457: ST_TO_ADDR
// end ;
9458: GO 9344
9460: POP
9461: POP
// if commander = 1 then
9462: LD_EXP 25
9466: PUSH
9467: LD_INT 1
9469: EQUAL
9470: IFFALSE 9538
// for i = 1 to 4 do
9472: LD_ADDR_VAR 0 2
9476: PUSH
9477: DOUBLE
9478: LD_INT 1
9480: DEC
9481: ST_TO_ADDR
9482: LD_INT 4
9484: PUSH
9485: FOR_TO
9486: IFFALSE 9536
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9488: LD_INT 0
9490: PPUSH
9491: LD_INT 1
9493: PPUSH
9494: LD_INT 8
9496: PPUSH
9497: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9501: LD_ADDR_VAR 0 1
9505: PUSH
9506: LD_VAR 0 1
9510: PPUSH
9511: LD_INT 2
9513: PPUSH
9514: LD_VAR 0 1
9518: PUSH
9519: LD_INT 2
9521: ARRAY
9522: PUSH
9523: CALL_OW 44
9527: ADD
9528: PPUSH
9529: CALL_OW 1
9533: ST_TO_ADDR
// end ;
9534: GO 9485
9536: POP
9537: POP
// techs := [ ] ;
9538: LD_ADDR_VAR 0 4
9542: PUSH
9543: EMPTY
9544: ST_TO_ADDR
// if commander = 1 then
9545: LD_EXP 25
9549: PUSH
9550: LD_INT 1
9552: EQUAL
9553: IFFALSE 9578
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9555: LD_ADDR_VAR 0 4
9559: PUSH
9560: LD_INT 51
9562: PUSH
9563: LD_INT 52
9565: PUSH
9566: LD_INT 53
9568: PUSH
9569: LD_INT 12
9571: PUSH
9572: EMPTY
9573: LIST
9574: LIST
9575: LIST
9576: LIST
9577: ST_TO_ADDR
// if commander = 2 then
9578: LD_EXP 25
9582: PUSH
9583: LD_INT 2
9585: EQUAL
9586: IFFALSE 9623
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9588: LD_ADDR_VAR 0 4
9592: PUSH
9593: LD_INT 48
9595: PUSH
9596: LD_INT 47
9598: PUSH
9599: LD_INT 46
9601: PUSH
9602: LD_INT 45
9604: PUSH
9605: LD_INT 35
9607: PUSH
9608: LD_INT 60
9610: PUSH
9611: LD_INT 6
9613: PUSH
9614: EMPTY
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: LIST
9622: ST_TO_ADDR
// if commander = 3 then
9623: LD_EXP 25
9627: PUSH
9628: LD_INT 3
9630: EQUAL
9631: IFFALSE 9680
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9633: LD_ADDR_VAR 0 4
9637: PUSH
9638: LD_INT 27
9640: PUSH
9641: LD_INT 36
9643: PUSH
9644: LD_INT 32
9646: PUSH
9647: LD_INT 57
9649: PUSH
9650: LD_INT 58
9652: PUSH
9653: LD_INT 47
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: LD_INT 51
9661: PUSH
9662: LD_INT 69
9664: PUSH
9665: LD_INT 39
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: LIST
9678: LIST
9679: ST_TO_ADDR
// if techs then
9680: LD_VAR 0 4
9684: IFFALSE 9718
// for i in techs do
9686: LD_ADDR_VAR 0 2
9690: PUSH
9691: LD_VAR 0 4
9695: PUSH
9696: FOR_IN
9697: IFFALSE 9716
// SetTech ( i , 1 , state_researched ) ;
9699: LD_VAR 0 2
9703: PPUSH
9704: LD_INT 1
9706: PPUSH
9707: LD_INT 2
9709: PPUSH
9710: CALL_OW 322
9714: GO 9696
9716: POP
9717: POP
// hc_gallery := skirmish ;
9718: LD_ADDR_OWVAR 33
9722: PUSH
9723: LD_STRING skirmish
9725: ST_TO_ADDR
// hc_face_number := commander ;
9726: LD_ADDR_OWVAR 34
9730: PUSH
9731: LD_EXP 25
9735: ST_TO_ADDR
// hc_importance := 100 ;
9736: LD_ADDR_OWVAR 32
9740: PUSH
9741: LD_INT 100
9743: ST_TO_ADDR
// case commander of 1 :
9744: LD_EXP 25
9748: PUSH
9749: LD_INT 1
9751: DOUBLE
9752: EQUAL
9753: IFTRUE 9757
9755: GO 9781
9757: POP
// begin hc_name := Jeff Ironside ;
9758: LD_ADDR_OWVAR 26
9762: PUSH
9763: LD_STRING Jeff Ironside
9765: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9766: LD_INT 1
9768: PPUSH
9769: LD_INT 1
9771: PPUSH
9772: LD_INT 7
9774: PPUSH
9775: CALL_OW 380
// end ; 2 :
9779: GO 9846
9781: LD_INT 2
9783: DOUBLE
9784: EQUAL
9785: IFTRUE 9789
9787: GO 9813
9789: POP
// begin hc_name := Paul Johnson ;
9790: LD_ADDR_OWVAR 26
9794: PUSH
9795: LD_STRING Paul Johnson
9797: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9798: LD_INT 1
9800: PPUSH
9801: LD_INT 3
9803: PPUSH
9804: LD_INT 7
9806: PPUSH
9807: CALL_OW 380
// end ; 3 :
9811: GO 9846
9813: LD_INT 3
9815: DOUBLE
9816: EQUAL
9817: IFTRUE 9821
9819: GO 9845
9821: POP
// begin hc_name := Lisa Stuart ;
9822: LD_ADDR_OWVAR 26
9826: PUSH
9827: LD_STRING Lisa Stuart
9829: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9830: LD_INT 2
9832: PPUSH
9833: LD_INT 4
9835: PPUSH
9836: LD_INT 7
9838: PPUSH
9839: CALL_OW 380
// end ; end ;
9843: GO 9846
9845: POP
// playerCommander := CreateHuman ;
9846: LD_ADDR_EXP 9
9850: PUSH
9851: CALL_OW 44
9855: ST_TO_ADDR
// hc_importance := 0 ;
9856: LD_ADDR_OWVAR 32
9860: PUSH
9861: LD_INT 0
9863: ST_TO_ADDR
// hc_gallery :=  ;
9864: LD_ADDR_OWVAR 33
9868: PUSH
9869: LD_STRING 
9871: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9872: LD_ADDR_VAR 0 1
9876: PUSH
9877: LD_VAR 0 1
9881: PPUSH
9882: LD_INT 2
9884: PPUSH
9885: LD_VAR 0 1
9889: PUSH
9890: LD_INT 2
9892: ARRAY
9893: PUSH
9894: LD_EXP 9
9898: ADD
9899: PPUSH
9900: CALL_OW 1
9904: ST_TO_ADDR
// end ;
9905: LD_VAR 0 1
9909: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9910: LD_INT 0
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
9916: PPUSH
9917: PPUSH
// uc_side := 1 ;
9918: LD_ADDR_OWVAR 20
9922: PUSH
9923: LD_INT 1
9925: ST_TO_ADDR
// uc_nation := 1 ;
9926: LD_ADDR_OWVAR 21
9930: PUSH
9931: LD_INT 1
9933: ST_TO_ADDR
// InitHc ;
9934: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9938: LD_ADDR_VAR 0 3
9942: PUSH
9943: LD_INT 3
9945: PUSH
9946: LD_INT 3
9948: PUSH
9949: LD_INT 2
9951: PUSH
9952: EMPTY
9953: LIST
9954: LIST
9955: LIST
9956: PUSH
9957: LD_OWVAR 67
9961: ARRAY
9962: ST_TO_ADDR
// for i = 1 to peopleAmount do
9963: LD_ADDR_VAR 0 2
9967: PUSH
9968: DOUBLE
9969: LD_INT 1
9971: DEC
9972: ST_TO_ADDR
9973: LD_VAR 0 3
9977: PUSH
9978: FOR_TO
9979: IFFALSE 10028
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9981: LD_INT 0
9983: PPUSH
9984: LD_INT 2
9986: PPUSH
9987: LD_INT 7
9989: PUSH
9990: LD_INT 6
9992: PUSH
9993: LD_INT 5
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: LIST
10000: PUSH
10001: LD_OWVAR 67
10005: ARRAY
10006: PPUSH
10007: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
10011: CALL_OW 44
10015: PPUSH
10016: LD_INT 19
10018: PPUSH
10019: LD_INT 0
10021: PPUSH
10022: CALL 55523 0 3
// end ;
10026: GO 9978
10028: POP
10029: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
10030: LD_INT 2
10032: PPUSH
10033: LD_INT 1
10035: PPUSH
10036: LD_INT 3
10038: PPUSH
10039: LD_INT 13
10041: PPUSH
10042: LD_INT 58
10044: PPUSH
10045: CALL 24736 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10049: CALL_OW 45
10053: PPUSH
10054: LD_INT 19
10056: PPUSH
10057: LD_INT 0
10059: PPUSH
10060: CALL 55523 0 3
// if commander = 1 then
10064: LD_EXP 25
10068: PUSH
10069: LD_INT 1
10071: EQUAL
10072: IFFALSE 10083
// wait ( 6 6$00 ) else
10074: LD_INT 12600
10076: PPUSH
10077: CALL_OW 67
10081: GO 10090
// wait ( 8 8$00 ) ;
10083: LD_INT 16800
10085: PPUSH
10086: CALL_OW 67
// uc_side := 1 ;
10090: LD_ADDR_OWVAR 20
10094: PUSH
10095: LD_INT 1
10097: ST_TO_ADDR
// uc_nation := 1 ;
10098: LD_ADDR_OWVAR 21
10102: PUSH
10103: LD_INT 1
10105: ST_TO_ADDR
// InitVc ;
10106: CALL_OW 20
// InitHc ;
10110: CALL_OW 19
// for i = 1 to 5 do
10114: LD_ADDR_VAR 0 2
10118: PUSH
10119: DOUBLE
10120: LD_INT 1
10122: DEC
10123: ST_TO_ADDR
10124: LD_INT 5
10126: PUSH
10127: FOR_TO
10128: IFFALSE 10372
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10130: LD_INT 4
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: LD_INT 1
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: LIST
10143: PUSH
10144: LD_VAR 0 2
10148: PUSH
10149: LD_INT 3
10151: MOD
10152: PUSH
10153: LD_INT 1
10155: PLUS
10156: ARRAY
10157: PPUSH
10158: LD_INT 1
10160: PPUSH
10161: LD_INT 1
10163: PUSH
10164: LD_INT 3
10166: PUSH
10167: LD_INT 3
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: LIST
10174: PUSH
10175: LD_VAR 0 2
10179: PUSH
10180: LD_INT 3
10182: MOD
10183: PUSH
10184: LD_INT 1
10186: PLUS
10187: ARRAY
10188: PPUSH
10189: LD_INT 6
10191: PUSH
10192: LD_INT 12
10194: PUSH
10195: LD_INT 11
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: LIST
10202: PUSH
10203: LD_VAR 0 2
10207: PUSH
10208: LD_INT 3
10210: MOD
10211: PUSH
10212: LD_INT 1
10214: PLUS
10215: ARRAY
10216: PPUSH
10217: LD_INT 40
10219: PPUSH
10220: LD_INT 55
10222: PPUSH
10223: CALL_OW 12
10227: PPUSH
10228: CALL 24736 0 5
// veh := CreateVehicle ;
10232: LD_ADDR_VAR 0 6
10236: PUSH
10237: CALL_OW 45
10241: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10242: LD_VAR 0 6
10246: PPUSH
10247: LD_INT 19
10249: PPUSH
10250: LD_INT 0
10252: PPUSH
10253: CALL 55523 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10257: LD_VAR 0 6
10261: PPUSH
10262: CALL_OW 264
10266: PUSH
10267: LD_INT 12
10269: EQUAL
10270: IFFALSE 10302
// begin AddCargo ( veh , mat_cans , 70 ) ;
10272: LD_VAR 0 6
10276: PPUSH
10277: LD_INT 1
10279: PPUSH
10280: LD_INT 70
10282: PPUSH
10283: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10287: LD_VAR 0 6
10291: PPUSH
10292: LD_INT 3
10294: PPUSH
10295: LD_INT 30
10297: PPUSH
10298: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10302: LD_VAR 0 6
10306: PPUSH
10307: CALL_OW 263
10311: PUSH
10312: LD_INT 1
10314: EQUAL
10315: IFFALSE 10370
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10317: LD_INT 1
10319: PPUSH
10320: LD_INT 3
10322: PPUSH
10323: LD_INT 6
10325: PPUSH
10326: CALL_OW 380
// un := CreateHuman ;
10330: LD_ADDR_VAR 0 5
10334: PUSH
10335: CALL_OW 44
10339: ST_TO_ADDR
// tmp := tmp ^ un ;
10340: LD_ADDR_VAR 0 4
10344: PUSH
10345: LD_VAR 0 4
10349: PUSH
10350: LD_VAR 0 5
10354: ADD
10355: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10356: LD_VAR 0 5
10360: PPUSH
10361: LD_VAR 0 6
10365: PPUSH
10366: CALL_OW 52
// end ; end ;
10370: GO 10127
10372: POP
10373: POP
// if tmp then
10374: LD_VAR 0 4
10378: IFFALSE 10442
// begin CenterNowOnUnits ( tmp ) ;
10380: LD_VAR 0 4
10384: PPUSH
10385: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10389: LD_VAR 0 4
10393: PUSH
10394: LD_INT 1
10396: ARRAY
10397: PPUSH
10398: LD_STRING DAR-1
10400: PPUSH
10401: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10405: LD_EXP 9
10409: PPUSH
10410: LD_STRING D
10412: PUSH
10413: LD_STRING I
10415: PUSH
10416: LD_STRING J
10418: PUSH
10419: LD_STRING S
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: LIST
10426: PUSH
10427: LD_EXP 25
10431: ARRAY
10432: STR
10433: PUSH
10434: LD_STRING -1-DAR
10436: STR
10437: PPUSH
10438: CALL_OW 88
// end ; if not reinforceAllowed then
10442: LD_EXP 24
10446: NOT
10447: IFFALSE 10451
// exit ;
10449: GO 10605
// wait ( 25 25$00 ) ;
10451: LD_INT 52500
10453: PPUSH
10454: CALL_OW 67
// uc_side := 1 ;
10458: LD_ADDR_OWVAR 20
10462: PUSH
10463: LD_INT 1
10465: ST_TO_ADDR
// uc_nation := 1 ;
10466: LD_ADDR_OWVAR 21
10470: PUSH
10471: LD_INT 1
10473: ST_TO_ADDR
// InitVc ;
10474: CALL_OW 20
// InitHc ;
10478: CALL_OW 19
// for i = 1 to 4 do
10482: LD_ADDR_VAR 0 2
10486: PUSH
10487: DOUBLE
10488: LD_INT 1
10490: DEC
10491: ST_TO_ADDR
10492: LD_INT 4
10494: PUSH
10495: FOR_TO
10496: IFFALSE 10603
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10498: LD_INT 5
10500: PPUSH
10501: LD_INT 3
10503: PPUSH
10504: LD_INT 1
10506: PPUSH
10507: LD_INT 6
10509: PPUSH
10510: LD_INT 1
10512: PPUSH
10513: CALL 24736 0 5
// veh := CreateVehicle ;
10517: LD_ADDR_VAR 0 6
10521: PUSH
10522: CALL_OW 45
10526: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10527: LD_VAR 0 6
10531: PPUSH
10532: LD_INT 19
10534: PPUSH
10535: LD_INT 0
10537: PPUSH
10538: CALL 55523 0 3
// if GetControl ( veh ) = control_manual then
10542: LD_VAR 0 6
10546: PPUSH
10547: CALL_OW 263
10551: PUSH
10552: LD_INT 1
10554: EQUAL
10555: IFFALSE 10601
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10557: LD_INT 0
10559: PPUSH
10560: LD_INT 3
10562: PPUSH
10563: LD_INT 7
10565: PUSH
10566: LD_INT 6
10568: PUSH
10569: LD_INT 5
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: LIST
10576: PUSH
10577: LD_OWVAR 67
10581: ARRAY
10582: PPUSH
10583: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10587: CALL_OW 44
10591: PPUSH
10592: LD_VAR 0 6
10596: PPUSH
10597: CALL_OW 52
// end ; end ;
10601: GO 10495
10603: POP
10604: POP
// end ;
10605: LD_VAR 0 1
10609: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10610: LD_INT 0
10612: PPUSH
10613: PPUSH
10614: PPUSH
10615: PPUSH
10616: PPUSH
// uc_side := 8 ;
10617: LD_ADDR_OWVAR 20
10621: PUSH
10622: LD_INT 8
10624: ST_TO_ADDR
// uc_nation := nation_arabian ;
10625: LD_ADDR_OWVAR 21
10629: PUSH
10630: LD_INT 2
10632: ST_TO_ADDR
// for i = 1 to 2 do
10633: LD_ADDR_VAR 0 2
10637: PUSH
10638: DOUBLE
10639: LD_INT 1
10641: DEC
10642: ST_TO_ADDR
10643: LD_INT 2
10645: PUSH
10646: FOR_TO
10647: IFFALSE 10727
// for j = 1 to 4 do
10649: LD_ADDR_VAR 0 4
10653: PUSH
10654: DOUBLE
10655: LD_INT 1
10657: DEC
10658: ST_TO_ADDR
10659: LD_INT 4
10661: PUSH
10662: FOR_TO
10663: IFFALSE 10723
// begin PrepareHuman ( false , j , 8 ) ;
10665: LD_INT 0
10667: PPUSH
10668: LD_VAR 0 4
10672: PPUSH
10673: LD_INT 8
10675: PPUSH
10676: CALL_OW 380
// un := CreateHuman ;
10680: LD_ADDR_VAR 0 3
10684: PUSH
10685: CALL_OW 44
10689: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10690: LD_VAR 0 3
10694: PPUSH
10695: LD_INT 23
10697: PPUSH
10698: LD_INT 0
10700: PPUSH
10701: CALL_OW 49
// tmp := tmp union un ;
10705: LD_ADDR_VAR 0 5
10709: PUSH
10710: LD_VAR 0 5
10714: PUSH
10715: LD_VAR 0 3
10719: UNION
10720: ST_TO_ADDR
// end ;
10721: GO 10662
10723: POP
10724: POP
10725: GO 10646
10727: POP
10728: POP
// for i in tmp do
10729: LD_ADDR_VAR 0 2
10733: PUSH
10734: LD_VAR 0 5
10738: PUSH
10739: FOR_IN
10740: IFFALSE 10759
// ComMoveXY ( i , 150 , 136 ) ;
10742: LD_VAR 0 2
10746: PPUSH
10747: LD_INT 150
10749: PPUSH
10750: LD_INT 136
10752: PPUSH
10753: CALL_OW 111
10757: GO 10739
10759: POP
10760: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10761: LD_ADDR_EXP 50
10765: PUSH
10766: LD_EXP 50
10770: PPUSH
10771: LD_EXP 6
10775: PPUSH
10776: LD_EXP 50
10780: PUSH
10781: LD_EXP 6
10785: ARRAY
10786: PUSH
10787: LD_VAR 0 5
10791: UNION
10792: PPUSH
10793: CALL_OW 1
10797: ST_TO_ADDR
// end ;
10798: LD_VAR 0 1
10802: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10803: LD_OWVAR 67
10807: PUSH
10808: LD_INT 1
10810: GREATER
10811: PUSH
10812: LD_INT 31
10814: PPUSH
10815: LD_INT 3
10817: PPUSH
10818: CALL_OW 321
10822: PUSH
10823: LD_INT 2
10825: EQUAL
10826: AND
10827: IFFALSE 11044
10829: GO 10831
10831: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10832: LD_EXP 7
10836: PPUSH
10837: LD_INT 33
10839: PUSH
10840: LD_INT 101
10842: PUSH
10843: LD_INT 159
10845: PUSH
10846: LD_INT 5
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: PUSH
10855: LD_INT 33
10857: PUSH
10858: LD_INT 105
10860: PUSH
10861: LD_INT 158
10863: PUSH
10864: LD_INT 5
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: LIST
10871: LIST
10872: PUSH
10873: LD_INT 33
10875: PUSH
10876: LD_INT 96
10878: PUSH
10879: LD_INT 136
10881: PUSH
10882: LD_INT 5
10884: PUSH
10885: EMPTY
10886: LIST
10887: LIST
10888: LIST
10889: LIST
10890: PUSH
10891: LD_INT 33
10893: PUSH
10894: LD_INT 94
10896: PUSH
10897: LD_INT 133
10899: PUSH
10900: LD_INT 4
10902: PUSH
10903: EMPTY
10904: LIST
10905: LIST
10906: LIST
10907: LIST
10908: PUSH
10909: LD_INT 33
10911: PUSH
10912: LD_INT 84
10914: PUSH
10915: LD_INT 102
10917: PUSH
10918: LD_INT 4
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: PUSH
10927: EMPTY
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: LIST
10933: PPUSH
10934: CALL 84243 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10938: LD_EXP 8
10942: PPUSH
10943: LD_INT 33
10945: PUSH
10946: LD_INT 50
10948: PUSH
10949: LD_INT 17
10951: PUSH
10952: LD_INT 4
10954: PUSH
10955: EMPTY
10956: LIST
10957: LIST
10958: LIST
10959: LIST
10960: PUSH
10961: LD_INT 33
10963: PUSH
10964: LD_INT 52
10966: PUSH
10967: LD_INT 20
10969: PUSH
10970: LD_INT 4
10972: PUSH
10973: EMPTY
10974: LIST
10975: LIST
10976: LIST
10977: LIST
10978: PUSH
10979: LD_INT 33
10981: PUSH
10982: LD_INT 53
10984: PUSH
10985: LD_INT 23
10987: PUSH
10988: LD_INT 4
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: LIST
10995: LIST
10996: PUSH
10997: LD_INT 33
10999: PUSH
11000: LD_INT 45
11002: PUSH
11003: LD_INT 32
11005: PUSH
11006: LD_INT 4
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: LIST
11013: LIST
11014: PUSH
11015: LD_INT 33
11017: PUSH
11018: LD_INT 45
11020: PUSH
11021: LD_INT 39
11023: PUSH
11024: LD_INT 4
11026: PUSH
11027: EMPTY
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: PUSH
11033: EMPTY
11034: LIST
11035: LIST
11036: LIST
11037: LIST
11038: LIST
11039: PPUSH
11040: CALL 84243 0 2
// end ;
11044: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11045: LD_INT 3
11047: PUSH
11048: LD_INT 22
11050: PUSH
11051: LD_OWVAR 2
11055: PUSH
11056: EMPTY
11057: LIST
11058: LIST
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: LD_INT 33
11066: PUSH
11067: LD_INT 2
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 50
11076: PUSH
11077: EMPTY
11078: LIST
11079: PUSH
11080: LD_INT 3
11082: PUSH
11083: LD_INT 61
11085: PUSH
11086: EMPTY
11087: LIST
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PPUSH
11099: CALL_OW 69
11103: IFFALSE 11203
11105: GO 11107
11107: DISABLE
11108: LD_INT 0
11110: PPUSH
11111: PPUSH
// begin enable ;
11112: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11113: LD_ADDR_VAR 0 2
11117: PUSH
11118: LD_INT 3
11120: PUSH
11121: LD_INT 22
11123: PUSH
11124: LD_OWVAR 2
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PUSH
11137: LD_INT 33
11139: PUSH
11140: LD_INT 2
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: PUSH
11147: LD_INT 50
11149: PUSH
11150: EMPTY
11151: LIST
11152: PUSH
11153: LD_INT 3
11155: PUSH
11156: LD_INT 61
11158: PUSH
11159: EMPTY
11160: LIST
11161: PUSH
11162: EMPTY
11163: LIST
11164: LIST
11165: PUSH
11166: EMPTY
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: PPUSH
11172: CALL_OW 69
11176: ST_TO_ADDR
// for i in tmp do
11177: LD_ADDR_VAR 0 1
11181: PUSH
11182: LD_VAR 0 2
11186: PUSH
11187: FOR_IN
11188: IFFALSE 11201
// Connect ( i ) ;
11190: LD_VAR 0 1
11194: PPUSH
11195: CALL 27829 0 1
11199: GO 11187
11201: POP
11202: POP
// end ; end_of_file
11203: PPOPN 2
11205: END
// export function Action ; var i , tmp ; begin
11206: LD_INT 0
11208: PPUSH
11209: PPUSH
11210: PPUSH
// InGameOn ;
11211: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11215: LD_INT 225
11217: PPUSH
11218: LD_INT 217
11220: PPUSH
11221: CALL_OW 86
// for i in playerForces [ 2 ] do
11225: LD_ADDR_VAR 0 2
11229: PUSH
11230: LD_EXP 10
11234: PUSH
11235: LD_INT 2
11237: ARRAY
11238: PUSH
11239: FOR_IN
11240: IFFALSE 11373
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11242: LD_EXP 10
11246: PUSH
11247: LD_INT 1
11249: ARRAY
11250: PUSH
11251: LD_VAR 0 2
11255: PPUSH
11256: CALL_OW 257
11260: PUSH
11261: LD_INT 3
11263: PUSH
11264: LD_INT 4
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: IN
11271: AND
11272: IFFALSE 11356
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11274: LD_EXP 10
11278: PUSH
11279: LD_INT 1
11281: ARRAY
11282: PUSH
11283: LD_INT 1
11285: ARRAY
11286: PPUSH
11287: LD_INT 19
11289: PPUSH
11290: LD_INT 0
11292: PPUSH
11293: CALL 55523 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11297: LD_VAR 0 2
11301: PPUSH
11302: LD_EXP 10
11306: PUSH
11307: LD_INT 1
11309: ARRAY
11310: PUSH
11311: LD_INT 1
11313: ARRAY
11314: PPUSH
11315: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11319: LD_ADDR_EXP 10
11323: PUSH
11324: LD_EXP 10
11328: PPUSH
11329: LD_INT 1
11331: PPUSH
11332: LD_EXP 10
11336: PUSH
11337: LD_INT 1
11339: ARRAY
11340: PPUSH
11341: LD_INT 1
11343: PPUSH
11344: CALL_OW 3
11348: PPUSH
11349: CALL_OW 1
11353: ST_TO_ADDR
// end else
11354: GO 11371
// PlaceUnitInArea ( i , startArea , false ) ;
11356: LD_VAR 0 2
11360: PPUSH
11361: LD_INT 19
11363: PPUSH
11364: LD_INT 0
11366: PPUSH
11367: CALL 55523 0 3
// end ;
11371: GO 11239
11373: POP
11374: POP
// wait ( 0 0$2 ) ;
11375: LD_INT 70
11377: PPUSH
11378: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11382: LD_EXP 9
11386: PPUSH
11387: LD_STRING D
11389: PUSH
11390: LD_STRING I
11392: PUSH
11393: LD_STRING J
11395: PUSH
11396: LD_STRING S
11398: PUSH
11399: EMPTY
11400: LIST
11401: LIST
11402: LIST
11403: PUSH
11404: LD_EXP 25
11408: ARRAY
11409: STR
11410: PUSH
11411: LD_STRING -1
11413: STR
11414: PPUSH
11415: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11419: LD_EXP 12
11423: PPUSH
11424: LD_STRING DP-1
11426: PPUSH
11427: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11431: LD_EXP 12
11435: PPUSH
11436: LD_STRING DP-2
11438: PPUSH
11439: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11443: LD_EXP 9
11447: PPUSH
11448: LD_STRING D
11450: PUSH
11451: LD_STRING I
11453: PUSH
11454: LD_STRING J
11456: PUSH
11457: LD_STRING S
11459: PUSH
11460: EMPTY
11461: LIST
11462: LIST
11463: LIST
11464: PUSH
11465: LD_EXP 25
11469: ARRAY
11470: STR
11471: PUSH
11472: LD_STRING -2
11474: STR
11475: PPUSH
11476: CALL_OW 88
// InGameOff ;
11480: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11484: LD_STRING O1
11486: PPUSH
11487: CALL_OW 337
// game := true ;
11491: LD_ADDR_EXP 3
11495: PUSH
11496: LD_INT 1
11498: ST_TO_ADDR
// SaveForQuickRestart ;
11499: CALL_OW 22
// wait ( 0 0$5 ) ;
11503: LD_INT 175
11505: PPUSH
11506: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11510: LD_EXP 9
11514: PPUSH
11515: LD_STRING D
11517: PUSH
11518: LD_STRING I
11520: PUSH
11521: LD_STRING J
11523: PUSH
11524: LD_STRING S
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: LIST
11531: PUSH
11532: LD_EXP 25
11536: ARRAY
11537: STR
11538: PUSH
11539: LD_STRING -3
11541: STR
11542: PPUSH
11543: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11547: LD_INT 35
11549: PPUSH
11550: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11554: LD_EXP 15
11558: PUSH
11559: LD_INT 1
11561: ARRAY
11562: PUSH
11563: LD_EXP 15
11567: PUSH
11568: LD_INT 2
11570: ARRAY
11571: GREATEREQUAL
11572: IFFALSE 11547
// outpostEscape := true ;
11574: LD_ADDR_EXP 27
11578: PUSH
11579: LD_INT 1
11581: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11582: LD_ADDR_VAR 0 3
11586: PUSH
11587: LD_EXP 14
11591: PPUSH
11592: LD_INT 26
11594: PUSH
11595: LD_INT 1
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PPUSH
11602: CALL_OW 72
11606: ST_TO_ADDR
// if tmp then
11607: LD_VAR 0 3
11611: IFFALSE 11629
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11613: LD_VAR 0 3
11617: PUSH
11618: LD_INT 1
11620: ARRAY
11621: PPUSH
11622: LD_STRING DR-1-Escape
11624: PPUSH
11625: CALL_OW 88
// wait ( 0 0$1 ) ;
11629: LD_INT 35
11631: PPUSH
11632: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11636: LD_EXP 9
11640: PPUSH
11641: LD_STRING D
11643: PUSH
11644: LD_STRING I
11646: PUSH
11647: LD_STRING J
11649: PUSH
11650: LD_STRING S
11652: PUSH
11653: EMPTY
11654: LIST
11655: LIST
11656: LIST
11657: PUSH
11658: LD_EXP 25
11662: ARRAY
11663: STR
11664: PUSH
11665: LD_STRING -1-Escape
11667: STR
11668: PPUSH
11669: CALL_OW 88
// for i in ruOutpost do
11673: LD_ADDR_VAR 0 2
11677: PUSH
11678: LD_EXP 14
11682: PUSH
11683: FOR_IN
11684: IFFALSE 11738
// begin if IsInUnit ( i ) then
11686: LD_VAR 0 2
11690: PPUSH
11691: CALL_OW 310
11695: IFFALSE 11706
// ComExitBuilding ( i ) ;
11697: LD_VAR 0 2
11701: PPUSH
11702: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11706: LD_VAR 0 2
11710: PPUSH
11711: LD_INT 179
11713: PPUSH
11714: LD_INT 102
11716: PPUSH
11717: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11721: LD_VAR 0 2
11725: PPUSH
11726: LD_INT 28
11728: PPUSH
11729: LD_INT 20
11731: PPUSH
11732: CALL_OW 171
// end ;
11736: GO 11683
11738: POP
11739: POP
// tmp := [ ] ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: EMPTY
11746: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11747: LD_INT 35
11749: PPUSH
11750: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11754: LD_ADDR_VAR 0 3
11758: PUSH
11759: LD_EXP 14
11763: PPUSH
11764: LD_INT 95
11766: PUSH
11767: LD_INT 11
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: PPUSH
11774: CALL_OW 72
11778: ST_TO_ADDR
// if tmp then
11779: LD_VAR 0 3
11783: IFFALSE 11862
// for i in tmp do
11785: LD_ADDR_VAR 0 2
11789: PUSH
11790: LD_VAR 0 3
11794: PUSH
11795: FOR_IN
11796: IFFALSE 11860
// begin ruOutpost := ruOutpost diff i ;
11798: LD_ADDR_EXP 14
11802: PUSH
11803: LD_EXP 14
11807: PUSH
11808: LD_VAR 0 2
11812: DIFF
11813: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11814: LD_ADDR_EXP 50
11818: PUSH
11819: LD_EXP 50
11823: PPUSH
11824: LD_EXP 8
11828: PUSH
11829: LD_EXP 50
11833: PUSH
11834: LD_EXP 8
11838: ARRAY
11839: PUSH
11840: LD_INT 1
11842: PLUS
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PPUSH
11848: LD_VAR 0 2
11852: PPUSH
11853: CALL 24858 0 3
11857: ST_TO_ADDR
// end ;
11858: GO 11795
11860: POP
11861: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11862: LD_EXP 14
11866: PPUSH
11867: LD_INT 21
11869: PUSH
11870: LD_INT 1
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PPUSH
11877: CALL_OW 72
11881: NOT
11882: IFFALSE 11747
// ruOutpost := [ ] ;
11884: LD_ADDR_EXP 14
11888: PUSH
11889: EMPTY
11890: ST_TO_ADDR
// end ;
11891: LD_VAR 0 1
11895: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11896: LD_EXP 27
11900: IFFALSE 12089
11902: GO 11904
11904: DISABLE
11905: LD_INT 0
11907: PPUSH
11908: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11909: LD_INT 875
11911: PPUSH
11912: LD_INT 1225
11914: PPUSH
11915: CALL_OW 12
11919: PPUSH
11920: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11924: LD_ADDR_VAR 0 2
11928: PUSH
11929: LD_INT 208
11931: PUSH
11932: LD_INT 166
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: PUSH
11939: LD_INT 218
11941: PUSH
11942: LD_INT 174
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: PUSH
11949: LD_INT 201
11951: PUSH
11952: LD_INT 173
11954: PUSH
11955: EMPTY
11956: LIST
11957: LIST
11958: PUSH
11959: LD_INT 189
11961: PUSH
11962: LD_INT 167
11964: PUSH
11965: EMPTY
11966: LIST
11967: LIST
11968: PUSH
11969: LD_INT 191
11971: PUSH
11972: LD_INT 160
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: PUSH
11979: LD_INT 209
11981: PUSH
11982: LD_INT 181
11984: PUSH
11985: EMPTY
11986: LIST
11987: LIST
11988: PUSH
11989: LD_INT 192
11991: PUSH
11992: LD_INT 162
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: LD_INT 197
12001: PUSH
12002: LD_INT 166
12004: PUSH
12005: EMPTY
12006: LIST
12007: LIST
12008: PUSH
12009: EMPTY
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: LIST
12017: LIST
12018: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
12019: LD_ADDR_VAR 0 1
12023: PUSH
12024: DOUBLE
12025: LD_INT 1
12027: DEC
12028: ST_TO_ADDR
12029: LD_INT 5
12031: PUSH
12032: LD_OWVAR 67
12036: PLUS
12037: PUSH
12038: FOR_TO
12039: IFFALSE 12087
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12041: LD_VAR 0 2
12045: PUSH
12046: LD_VAR 0 1
12050: ARRAY
12051: PUSH
12052: LD_INT 1
12054: ARRAY
12055: PPUSH
12056: LD_VAR 0 2
12060: PUSH
12061: LD_VAR 0 1
12065: ARRAY
12066: PUSH
12067: LD_INT 2
12069: ARRAY
12070: PPUSH
12071: LD_INT 1
12073: PPUSH
12074: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12078: LD_INT 28
12080: PPUSH
12081: CALL_OW 67
// end ;
12085: GO 12038
12087: POP
12088: POP
// end ;
12089: PPOPN 2
12091: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12092: LD_EXP 27
12096: NOT
12097: IFFALSE 12751
12099: GO 12101
12101: DISABLE
12102: LD_INT 0
12104: PPUSH
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
12109: PPUSH
12110: PPUSH
// begin enable ;
12111: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12112: LD_ADDR_VAR 0 1
12116: PUSH
12117: LD_EXP 14
12121: PPUSH
12122: LD_INT 22
12124: PUSH
12125: LD_INT 3
12127: PUSH
12128: EMPTY
12129: LIST
12130: LIST
12131: PUSH
12132: LD_INT 25
12134: PUSH
12135: LD_INT 1
12137: PUSH
12138: EMPTY
12139: LIST
12140: LIST
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: PPUSH
12146: CALL_OW 72
12150: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12151: LD_ADDR_VAR 0 2
12155: PUSH
12156: LD_EXP 14
12160: PPUSH
12161: LD_INT 22
12163: PUSH
12164: LD_INT 3
12166: PUSH
12167: EMPTY
12168: LIST
12169: LIST
12170: PUSH
12171: LD_INT 25
12173: PUSH
12174: LD_INT 2
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: PUSH
12181: EMPTY
12182: LIST
12183: LIST
12184: PPUSH
12185: CALL_OW 72
12189: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12190: LD_ADDR_VAR 0 3
12194: PUSH
12195: LD_EXP 14
12199: PPUSH
12200: LD_INT 22
12202: PUSH
12203: LD_INT 3
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: LD_INT 21
12212: PUSH
12213: LD_INT 3
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: LD_INT 3
12222: PUSH
12223: LD_INT 24
12225: PUSH
12226: LD_INT 1000
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: LIST
12241: PPUSH
12242: CALL_OW 72
12246: ST_TO_ADDR
// if engs and buildings then
12247: LD_VAR 0 2
12251: PUSH
12252: LD_VAR 0 3
12256: AND
12257: IFFALSE 12330
// begin for i in engs do
12259: LD_ADDR_VAR 0 5
12263: PUSH
12264: LD_VAR 0 2
12268: PUSH
12269: FOR_IN
12270: IFFALSE 12326
// if IsInUnit ( i ) then
12272: LD_VAR 0 5
12276: PPUSH
12277: CALL_OW 310
12281: IFFALSE 12294
// ComExitBuilding ( i ) else
12283: LD_VAR 0 5
12287: PPUSH
12288: CALL_OW 122
12292: GO 12324
// if not HasTask ( i ) then
12294: LD_VAR 0 5
12298: PPUSH
12299: CALL_OW 314
12303: NOT
12304: IFFALSE 12324
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12306: LD_VAR 0 5
12310: PPUSH
12311: LD_VAR 0 3
12315: PUSH
12316: LD_INT 1
12318: ARRAY
12319: PPUSH
12320: CALL_OW 130
12324: GO 12269
12326: POP
12327: POP
// end else
12328: GO 12433
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12330: LD_VAR 0 3
12334: NOT
12335: PUSH
12336: LD_EXP 14
12340: PPUSH
12341: LD_INT 30
12343: PUSH
12344: LD_INT 0
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PPUSH
12351: CALL_OW 72
12355: AND
12356: PUSH
12357: LD_VAR 0 2
12361: PPUSH
12362: LD_INT 3
12364: PUSH
12365: LD_INT 54
12367: PUSH
12368: EMPTY
12369: LIST
12370: PUSH
12371: EMPTY
12372: LIST
12373: LIST
12374: PPUSH
12375: CALL_OW 72
12379: AND
12380: IFFALSE 12433
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12382: LD_VAR 0 2
12386: PPUSH
12387: LD_INT 3
12389: PUSH
12390: LD_INT 54
12392: PUSH
12393: EMPTY
12394: LIST
12395: PUSH
12396: EMPTY
12397: LIST
12398: LIST
12399: PPUSH
12400: CALL_OW 72
12404: PPUSH
12405: LD_EXP 14
12409: PPUSH
12410: LD_INT 30
12412: PUSH
12413: LD_INT 0
12415: PUSH
12416: EMPTY
12417: LIST
12418: LIST
12419: PPUSH
12420: CALL_OW 72
12424: PUSH
12425: LD_INT 1
12427: ARRAY
12428: PPUSH
12429: CALL_OW 120
// if not tmp then
12433: LD_VAR 0 1
12437: NOT
12438: IFFALSE 12442
// exit ;
12440: GO 12751
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12442: LD_INT 26
12444: PPUSH
12445: LD_INT 81
12447: PUSH
12448: LD_INT 3
12450: PUSH
12451: EMPTY
12452: LIST
12453: LIST
12454: PPUSH
12455: CALL_OW 70
12459: PUSH
12460: LD_INT 1
12462: GREATER
12463: IFFALSE 12519
// begin for i in tmp do
12465: LD_ADDR_VAR 0 5
12469: PUSH
12470: LD_VAR 0 1
12474: PUSH
12475: FOR_IN
12476: IFFALSE 12515
// begin if IsInUnit ( i ) then
12478: LD_VAR 0 5
12482: PPUSH
12483: CALL_OW 310
12487: IFFALSE 12498
// ComExitBuilding ( i ) ;
12489: LD_VAR 0 5
12493: PPUSH
12494: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12498: LD_VAR 0 5
12502: PPUSH
12503: LD_INT 204
12505: PPUSH
12506: LD_INT 164
12508: PPUSH
12509: CALL_OW 174
// end ;
12513: GO 12475
12515: POP
12516: POP
// end else
12517: GO 12751
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12519: LD_VAR 0 1
12523: PPUSH
12524: LD_INT 3
12526: PUSH
12527: LD_INT 54
12529: PUSH
12530: EMPTY
12531: LIST
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: PPUSH
12537: CALL_OW 72
12541: IFFALSE 12751
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12543: LD_ADDR_VAR 0 4
12547: PUSH
12548: LD_EXP 14
12552: PPUSH
12553: LD_INT 30
12555: PUSH
12556: LD_INT 32
12558: PUSH
12559: EMPTY
12560: LIST
12561: LIST
12562: PUSH
12563: LD_INT 58
12565: PUSH
12566: EMPTY
12567: LIST
12568: PUSH
12569: EMPTY
12570: LIST
12571: LIST
12572: PPUSH
12573: CALL_OW 72
12577: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12578: LD_VAR 0 4
12582: NOT
12583: PUSH
12584: LD_EXP 14
12588: PPUSH
12589: LD_INT 30
12591: PUSH
12592: LD_INT 5
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PPUSH
12599: CALL_OW 72
12603: AND
12604: IFFALSE 12641
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12606: LD_VAR 0 1
12610: PPUSH
12611: LD_EXP 14
12615: PPUSH
12616: LD_INT 30
12618: PUSH
12619: LD_INT 5
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PPUSH
12626: CALL_OW 72
12630: PUSH
12631: LD_INT 1
12633: ARRAY
12634: PPUSH
12635: CALL_OW 120
// exit ;
12639: GO 12751
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12641: LD_ADDR_VAR 0 6
12645: PUSH
12646: LD_VAR 0 1
12650: PPUSH
12651: LD_INT 3
12653: PUSH
12654: LD_INT 54
12656: PUSH
12657: EMPTY
12658: LIST
12659: PUSH
12660: EMPTY
12661: LIST
12662: LIST
12663: PPUSH
12664: CALL_OW 72
12668: ST_TO_ADDR
// if j < empty then
12669: LD_VAR 0 6
12673: PUSH
12674: LD_VAR 0 4
12678: LESS
12679: IFFALSE 12693
// k := j else
12681: LD_ADDR_VAR 0 7
12685: PUSH
12686: LD_VAR 0 6
12690: ST_TO_ADDR
12691: GO 12703
// k := empty ;
12693: LD_ADDR_VAR 0 7
12697: PUSH
12698: LD_VAR 0 4
12702: ST_TO_ADDR
// for i = 1 to k do
12703: LD_ADDR_VAR 0 5
12707: PUSH
12708: DOUBLE
12709: LD_INT 1
12711: DEC
12712: ST_TO_ADDR
12713: LD_VAR 0 7
12717: PUSH
12718: FOR_TO
12719: IFFALSE 12749
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12721: LD_VAR 0 6
12725: PUSH
12726: LD_VAR 0 5
12730: ARRAY
12731: PPUSH
12732: LD_VAR 0 4
12736: PUSH
12737: LD_VAR 0 5
12741: ARRAY
12742: PPUSH
12743: CALL_OW 120
12747: GO 12718
12749: POP
12750: POP
// end ; end ;
12751: PPOPN 7
12753: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12754: LD_EXP 2
12758: PUSH
12759: LD_INT 1
12761: EQUAL
12762: PUSH
12763: LD_EXP 27
12767: AND
12768: PUSH
12769: LD_INT 22
12771: PUSH
12772: LD_INT 1
12774: PUSH
12775: EMPTY
12776: LIST
12777: LIST
12778: PUSH
12779: LD_INT 92
12781: PUSH
12782: LD_INT 208
12784: PUSH
12785: LD_INT 163
12787: PUSH
12788: LD_INT 8
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PPUSH
12801: CALL_OW 69
12805: AND
12806: PUSH
12807: LD_INT 22
12809: PUSH
12810: LD_INT 3
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: LD_INT 21
12819: PUSH
12820: LD_INT 1
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PUSH
12827: LD_INT 92
12829: PUSH
12830: LD_INT 208
12832: PUSH
12833: LD_INT 163
12835: PUSH
12836: LD_INT 14
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: LIST
12843: LIST
12844: PUSH
12845: EMPTY
12846: LIST
12847: LIST
12848: LIST
12849: PPUSH
12850: CALL_OW 69
12854: NOT
12855: AND
12856: IFFALSE 13161
12858: GO 12860
12860: DISABLE
12861: LD_INT 0
12863: PPUSH
// begin InGameOn ;
12864: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12868: LD_EXP 9
12872: PPUSH
12873: CALL_OW 87
// wait ( 0 0$1 ) ;
12877: LD_INT 35
12879: PPUSH
12880: CALL_OW 67
// DialogueOn ;
12884: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12888: LD_EXP 9
12892: PPUSH
12893: LD_STRING D
12895: PUSH
12896: LD_STRING I
12898: PUSH
12899: LD_STRING J
12901: PUSH
12902: LD_STRING S
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: PUSH
12910: LD_EXP 25
12914: ARRAY
12915: STR
12916: PUSH
12917: LD_STRING -1-BaseCaptured
12919: STR
12920: PPUSH
12921: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12925: LD_EXP 12
12929: PPUSH
12930: LD_STRING DP-1-BaseCaptured
12932: PPUSH
12933: CALL_OW 94
// if sibBombAllowed then
12937: LD_EXP 23
12941: IFFALSE 13083
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12943: LD_EXP 9
12947: PPUSH
12948: LD_STRING D
12950: PUSH
12951: LD_STRING I
12953: PUSH
12954: LD_STRING J
12956: PUSH
12957: LD_STRING S
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: LIST
12964: PUSH
12965: LD_EXP 25
12969: ARRAY
12970: STR
12971: PUSH
12972: LD_STRING -2-BaseCaptured
12974: STR
12975: PPUSH
12976: CALL_OW 88
// if commander = 1 then
12980: LD_EXP 25
12984: PUSH
12985: LD_INT 1
12987: EQUAL
12988: IFFALSE 13002
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12990: LD_EXP 12
12994: PPUSH
12995: LD_STRING DP-2b-BaseCaptured
12997: PPUSH
12998: CALL_OW 94
// if commander = 2 then
13002: LD_EXP 25
13006: PUSH
13007: LD_INT 2
13009: EQUAL
13010: IFFALSE 13024
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
13012: LD_EXP 12
13016: PPUSH
13017: LD_STRING DP-2-BaseCaptured
13019: PPUSH
13020: CALL_OW 94
// if commander = 3 then
13024: LD_EXP 25
13028: PUSH
13029: LD_INT 3
13031: EQUAL
13032: IFFALSE 13046
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13034: LD_EXP 12
13038: PPUSH
13039: LD_STRING DP-2a-BaseCaptured
13041: PPUSH
13042: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13046: LD_EXP 9
13050: PPUSH
13051: LD_STRING D
13053: PUSH
13054: LD_STRING I
13056: PUSH
13057: LD_STRING J
13059: PUSH
13060: LD_STRING S
13062: PUSH
13063: EMPTY
13064: LIST
13065: LIST
13066: LIST
13067: PUSH
13068: LD_EXP 25
13072: ARRAY
13073: STR
13074: PUSH
13075: LD_STRING -3-BaseCaptured
13077: STR
13078: PPUSH
13079: CALL_OW 88
// end ; DialogueOff ;
13083: CALL_OW 7
// InGameOff ;
13087: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13091: LD_STRING O2
13093: PPUSH
13094: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13098: LD_ADDR_VAR 0 1
13102: PUSH
13103: LD_EXP 14
13107: PPUSH
13108: LD_INT 21
13110: PUSH
13111: LD_INT 3
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PPUSH
13118: CALL_OW 72
13122: PUSH
13123: FOR_IN
13124: IFFALSE 13140
// SetSide ( i , 1 ) ;
13126: LD_VAR 0 1
13130: PPUSH
13131: LD_INT 1
13133: PPUSH
13134: CALL_OW 235
13138: GO 13123
13140: POP
13141: POP
// baseCaptured := true ;
13142: LD_ADDR_EXP 17
13146: PUSH
13147: LD_INT 1
13149: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13150: LD_INT 1225
13152: PPUSH
13153: CALL_OW 67
// PrepareReinforcements ;
13157: CALL 9910 0 0
// end ;
13161: PPOPN 1
13163: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13164: LD_INT 22
13166: PUSH
13167: LD_INT 3
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PUSH
13174: LD_INT 92
13176: PUSH
13177: LD_INT 167
13179: PUSH
13180: LD_INT 197
13182: PUSH
13183: LD_INT 20
13185: PUSH
13186: EMPTY
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PPUSH
13196: CALL_OW 69
13200: PUSH
13201: LD_INT 3
13203: GREATER
13204: IFFALSE 13221
13206: GO 13208
13208: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13209: LD_EXP 12
13213: PPUSH
13214: LD_STRING DP-RuAttack
13216: PPUSH
13217: CALL_OW 94
13221: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13222: LD_EXP 1
13226: NOT
13227: PUSH
13228: LD_INT 1
13230: PPUSH
13231: LD_INT 168
13233: PPUSH
13234: LD_INT 74
13236: PPUSH
13237: CALL_OW 293
13241: AND
13242: PUSH
13243: LD_INT 168
13245: PPUSH
13246: LD_INT 72
13248: PPUSH
13249: CALL_OW 553
13253: AND
13254: IFFALSE 13306
13256: GO 13258
13258: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13259: LD_INT 168
13261: PPUSH
13262: LD_INT 72
13264: PPUSH
13265: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13269: LD_EXP 9
13273: PPUSH
13274: LD_STRING D
13276: PUSH
13277: LD_STRING I
13279: PUSH
13280: LD_STRING J
13282: PUSH
13283: LD_STRING S
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: LIST
13290: PUSH
13291: LD_EXP 25
13295: ARRAY
13296: STR
13297: PUSH
13298: LD_STRING -1-Blockade
13300: STR
13301: PPUSH
13302: CALL_OW 88
// end ;
13306: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13307: LD_EXP 2
13311: PUSH
13312: LD_INT 1
13314: EQUAL
13315: PUSH
13316: LD_INT 22
13318: PUSH
13319: LD_INT 1
13321: PUSH
13322: EMPTY
13323: LIST
13324: LIST
13325: PUSH
13326: LD_INT 101
13328: PUSH
13329: LD_INT 4
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PPUSH
13340: CALL_OW 69
13344: AND
13345: IFFALSE 13877
13347: GO 13349
13349: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13350: LD_INT 4
13352: PPUSH
13353: LD_INT 1
13355: PPUSH
13356: CALL_OW 343
// DialogueOn ;
13360: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13364: LD_EXP 11
13368: PPUSH
13369: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13373: LD_EXP 11
13377: PPUSH
13378: LD_STRING DM-1-Contact
13380: PPUSH
13381: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13385: LD_EXP 9
13389: PPUSH
13390: LD_STRING D
13392: PUSH
13393: LD_STRING I
13395: PUSH
13396: LD_STRING J
13398: PUSH
13399: LD_STRING S
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: LIST
13406: PUSH
13407: LD_EXP 25
13411: ARRAY
13412: STR
13413: PUSH
13414: LD_STRING -1-Contact
13416: STR
13417: PPUSH
13418: CALL_OW 88
// if commander = 1 then
13422: LD_EXP 25
13426: PUSH
13427: LD_INT 1
13429: EQUAL
13430: IFFALSE 13562
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13432: LD_EXP 11
13436: PPUSH
13437: LD_STRING DM-2-Contact
13439: PPUSH
13440: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13444: LD_EXP 9
13448: PPUSH
13449: LD_STRING DI-2-Contact
13451: PPUSH
13452: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13456: LD_INT 22
13458: PUSH
13459: LD_INT 8
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: LD_INT 21
13468: PUSH
13469: LD_INT 1
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PPUSH
13480: CALL_OW 69
13484: PUSH
13485: LD_INT 8
13487: PPUSH
13488: LD_INT 1
13490: PPUSH
13491: CALL_OW 81
13495: PUSH
13496: LD_INT 2
13498: EQUAL
13499: AND
13500: IFFALSE 13526
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13502: LD_EXP 11
13506: PPUSH
13507: LD_STRING DM-3-Contact
13509: PPUSH
13510: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13514: LD_EXP 9
13518: PPUSH
13519: LD_STRING DI-3-Contact
13521: PPUSH
13522: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13526: LD_EXP 11
13530: PPUSH
13531: LD_STRING DM-4-Contact
13533: PPUSH
13534: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13538: LD_EXP 9
13542: PPUSH
13543: LD_STRING DI-4-Contact
13545: PPUSH
13546: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13550: LD_EXP 11
13554: PPUSH
13555: LD_STRING DM-5-Contact
13557: PPUSH
13558: CALL_OW 94
// end ; if commander = 2 then
13562: LD_EXP 25
13566: PUSH
13567: LD_INT 2
13569: EQUAL
13570: IFFALSE 13702
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13572: LD_EXP 11
13576: PPUSH
13577: LD_STRING DM-2c-Contact
13579: PPUSH
13580: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13584: LD_EXP 9
13588: PPUSH
13589: LD_STRING DJ-2-Contact
13591: PPUSH
13592: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13596: LD_INT 22
13598: PUSH
13599: LD_INT 8
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: LD_INT 21
13608: PUSH
13609: LD_INT 1
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: PUSH
13616: EMPTY
13617: LIST
13618: LIST
13619: PPUSH
13620: CALL_OW 69
13624: PUSH
13625: LD_INT 8
13627: PPUSH
13628: LD_INT 1
13630: PPUSH
13631: CALL_OW 81
13635: PUSH
13636: LD_INT 2
13638: EQUAL
13639: AND
13640: IFFALSE 13666
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13642: LD_EXP 11
13646: PPUSH
13647: LD_STRING DM-3-Contact
13649: PPUSH
13650: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13654: LD_EXP 9
13658: PPUSH
13659: LD_STRING DJ-3-Contact
13661: PPUSH
13662: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13666: LD_EXP 11
13670: PPUSH
13671: LD_STRING DM-4-Contact
13673: PPUSH
13674: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13678: LD_EXP 9
13682: PPUSH
13683: LD_STRING DJ-4-Contact
13685: PPUSH
13686: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13690: LD_EXP 11
13694: PPUSH
13695: LD_STRING DM-5a-Contact
13697: PPUSH
13698: CALL_OW 94
// end ; if commander = 3 then
13702: LD_EXP 25
13706: PUSH
13707: LD_INT 3
13709: EQUAL
13710: IFFALSE 13866
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13712: LD_EXP 11
13716: PPUSH
13717: LD_STRING DM-2a-Contact
13719: PPUSH
13720: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13724: LD_EXP 9
13728: PPUSH
13729: LD_STRING DS-2a-Contact
13731: PPUSH
13732: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13736: LD_EXP 11
13740: PPUSH
13741: LD_STRING DM-2b-Contact
13743: PPUSH
13744: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13748: LD_EXP 9
13752: PPUSH
13753: LD_STRING DS-2b-Contact
13755: PPUSH
13756: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13760: LD_INT 22
13762: PUSH
13763: LD_INT 8
13765: PUSH
13766: EMPTY
13767: LIST
13768: LIST
13769: PUSH
13770: LD_INT 21
13772: PUSH
13773: LD_INT 1
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: PUSH
13780: EMPTY
13781: LIST
13782: LIST
13783: PPUSH
13784: CALL_OW 69
13788: PUSH
13789: LD_INT 8
13791: PPUSH
13792: LD_INT 1
13794: PPUSH
13795: CALL_OW 81
13799: PUSH
13800: LD_INT 2
13802: EQUAL
13803: AND
13804: IFFALSE 13830
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13806: LD_EXP 11
13810: PPUSH
13811: LD_STRING DM-3-Contact
13813: PPUSH
13814: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13818: LD_EXP 9
13822: PPUSH
13823: LD_STRING DS-3-Contact
13825: PPUSH
13826: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13830: LD_EXP 11
13834: PPUSH
13835: LD_STRING DM-4-Contact
13837: PPUSH
13838: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13842: LD_EXP 9
13846: PPUSH
13847: LD_STRING DS-4-Contact
13849: PPUSH
13850: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13854: LD_EXP 11
13858: PPUSH
13859: LD_STRING DM-5-Contact
13861: PPUSH
13862: CALL_OW 94
// end ; DialogueOff ;
13866: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13870: LD_STRING O3
13872: PPUSH
13873: CALL_OW 337
// end ;
13877: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13878: LD_EXP 2
13882: PUSH
13883: LD_INT 1
13885: EQUAL
13886: PUSH
13887: LD_EXP 18
13891: PUSH
13892: LD_INT 15
13894: PUSH
13895: LD_INT 20
13897: PUSH
13898: LD_INT 25
13900: PUSH
13901: EMPTY
13902: LIST
13903: LIST
13904: LIST
13905: PUSH
13906: LD_OWVAR 67
13910: ARRAY
13911: GREATEREQUAL
13912: AND
13913: PUSH
13914: LD_INT 22
13916: PUSH
13917: LD_INT 8
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: PUSH
13924: LD_INT 30
13926: PUSH
13927: LD_INT 1
13929: PUSH
13930: EMPTY
13931: LIST
13932: LIST
13933: PUSH
13934: EMPTY
13935: LIST
13936: LIST
13937: PPUSH
13938: CALL_OW 69
13942: AND
13943: PUSH
13944: LD_INT 22
13946: PUSH
13947: LD_INT 8
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: PUSH
13954: LD_INT 21
13956: PUSH
13957: LD_INT 3
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: EMPTY
13965: LIST
13966: LIST
13967: PPUSH
13968: CALL_OW 69
13972: PUSH
13973: LD_INT 5
13975: GREATEREQUAL
13976: AND
13977: IFFALSE 14500
13979: GO 13981
13981: DISABLE
13982: LD_INT 0
13984: PPUSH
13985: PPUSH
13986: PPUSH
13987: PPUSH
// begin DialogueOn ;
13988: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13992: LD_EXP 13
13996: PPUSH
13997: LD_STRING DF-1-Leg
13999: PPUSH
14000: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14004: LD_EXP 9
14008: PPUSH
14009: LD_STRING D
14011: PUSH
14012: LD_STRING I
14014: PUSH
14015: LD_STRING J
14017: PUSH
14018: LD_STRING S
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: LIST
14025: PUSH
14026: LD_EXP 25
14030: ARRAY
14031: STR
14032: PUSH
14033: LD_STRING -1-Leg
14035: STR
14036: PPUSH
14037: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14041: LD_EXP 13
14045: PPUSH
14046: LD_STRING DF-2-Leg
14048: PPUSH
14049: CALL_OW 94
// DialogueOff ;
14053: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14057: LD_STRING QLegionOffer
14059: PPUSH
14060: CALL_OW 97
14064: PUSH
14065: LD_INT 1
14067: DOUBLE
14068: EQUAL
14069: IFTRUE 14073
14071: GO 14076
14073: POP
// ; 2 :
14074: GO 14090
14076: LD_INT 2
14078: DOUBLE
14079: EQUAL
14080: IFTRUE 14084
14082: GO 14089
14084: POP
// exit ; end ;
14085: GO 14500
14087: GO 14090
14089: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14090: LD_EXP 9
14094: PPUSH
14095: LD_STRING D
14097: PUSH
14098: LD_STRING I
14100: PUSH
14101: LD_STRING J
14103: PUSH
14104: LD_STRING S
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: LIST
14111: PUSH
14112: LD_EXP 25
14116: ARRAY
14117: STR
14118: PUSH
14119: LD_STRING -2-Leg
14121: STR
14122: PPUSH
14123: CALL_OW 88
// legOfferAccepted := true ;
14127: LD_ADDR_EXP 20
14131: PUSH
14132: LD_INT 1
14134: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14135: LD_INT 21
14137: PPUSH
14138: LD_INT 1
14140: PPUSH
14141: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14145: LD_INT 190
14147: PPUSH
14148: LD_INT 227
14150: PPUSH
14151: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14155: LD_ADDR_VAR 0 1
14159: PUSH
14160: LD_INT 16800
14162: PUSH
14163: LD_INT 14700
14165: PUSH
14166: LD_INT 12600
14168: PUSH
14169: EMPTY
14170: LIST
14171: LIST
14172: LIST
14173: PUSH
14174: LD_OWVAR 67
14178: ARRAY
14179: ST_TO_ADDR
// sib := 100 ;
14180: LD_ADDR_VAR 0 2
14184: PUSH
14185: LD_INT 100
14187: ST_TO_ADDR
// disableGlobalTimer := true ;
14188: LD_ADDR_EXP 4
14192: PUSH
14193: LD_INT 1
14195: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14196: LD_INT 35
14198: PPUSH
14199: CALL_OW 67
// time := time - 0 0$1 ;
14203: LD_ADDR_VAR 0 1
14207: PUSH
14208: LD_VAR 0 1
14212: PUSH
14213: LD_INT 35
14215: MINUS
14216: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14217: LD_ADDR_VAR 0 3
14221: PUSH
14222: LD_INT 21
14224: PPUSH
14225: LD_INT 3
14227: PPUSH
14228: CALL_OW 287
14232: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14233: LD_ADDR_OWVAR 47
14237: PUSH
14238: LD_STRING #SkrTime
14240: PUSH
14241: LD_OWVAR 1
14245: PUSH
14246: LD_STRING #Skr-LegOffer
14248: PUSH
14249: LD_VAR 0 2
14253: PUSH
14254: LD_VAR 0 1
14258: PUSH
14259: EMPTY
14260: LIST
14261: LIST
14262: LIST
14263: LIST
14264: LIST
14265: ST_TO_ADDR
// if sources then
14266: LD_VAR 0 3
14270: IFFALSE 14302
// begin sib := sib - sources * 10 ;
14272: LD_ADDR_VAR 0 2
14276: PUSH
14277: LD_VAR 0 2
14281: PUSH
14282: LD_VAR 0 3
14286: PUSH
14287: LD_INT 10
14289: MUL
14290: MINUS
14291: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14292: LD_INT 21
14294: PPUSH
14295: LD_INT 3
14297: PPUSH
14298: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14302: LD_VAR 0 1
14306: PUSH
14307: LD_INT 0
14309: EQUAL
14310: PUSH
14311: LD_VAR 0 2
14315: PUSH
14316: LD_INT 0
14318: LESSEQUAL
14319: OR
14320: PUSH
14321: LD_INT 22
14323: PUSH
14324: LD_INT 8
14326: PUSH
14327: EMPTY
14328: LIST
14329: LIST
14330: PPUSH
14331: CALL_OW 69
14335: NOT
14336: OR
14337: IFFALSE 14196
// SetAreaMapShow ( legOfferArea , 0 ) ;
14339: LD_INT 21
14341: PPUSH
14342: LD_INT 0
14344: PPUSH
14345: CALL_OW 424
// disableGlobalTimer := false ;
14349: LD_ADDR_EXP 4
14353: PUSH
14354: LD_INT 0
14356: ST_TO_ADDR
// if sib <= 0 then
14357: LD_VAR 0 2
14361: PUSH
14362: LD_INT 0
14364: LESSEQUAL
14365: IFFALSE 14481
// begin legChangeSide := true ;
14367: LD_ADDR_EXP 21
14371: PUSH
14372: LD_INT 1
14374: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14375: LD_EXP 13
14379: PPUSH
14380: LD_STRING DF-4y-Leg
14382: PPUSH
14383: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14387: LD_STRING O3a
14389: PPUSH
14390: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14394: LD_INT 8
14396: PPUSH
14397: LD_INT 1
14399: PPUSH
14400: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14404: LD_INT 8
14406: PPUSH
14407: LD_INT 1
14409: PPUSH
14410: LD_INT 1
14412: PPUSH
14413: LD_INT 1
14415: PPUSH
14416: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14420: LD_INT 8
14422: PPUSH
14423: LD_INT 4
14425: PPUSH
14426: LD_INT 1
14428: PPUSH
14429: LD_INT 1
14431: PPUSH
14432: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14436: LD_INT 8
14438: PPUSH
14439: LD_INT 6
14441: PPUSH
14442: LD_INT 2
14444: PPUSH
14445: LD_INT 1
14447: PPUSH
14448: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14452: LD_INT 8
14454: PPUSH
14455: LD_INT 3
14457: PPUSH
14458: LD_INT 2
14460: PPUSH
14461: LD_INT 1
14463: PPUSH
14464: CALL_OW 80
// wait ( 0 0$30 ) ;
14468: LD_INT 1050
14470: PPUSH
14471: CALL_OW 67
// PrepareLegionReinforcements ;
14475: CALL 10610 0 0
// end else
14479: GO 14500
// begin ChangeMissionObjectives ( O3a ) ;
14481: LD_STRING O3a
14483: PPUSH
14484: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14488: LD_EXP 13
14492: PPUSH
14493: LD_STRING DF-4n-Leg
14495: PPUSH
14496: CALL_OW 94
// end ; end ;
14500: PPOPN 4
14502: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14503: LD_INT 22
14505: PUSH
14506: LD_INT 8
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: PUSH
14513: LD_INT 21
14515: PUSH
14516: LD_INT 1
14518: PUSH
14519: EMPTY
14520: LIST
14521: LIST
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: PPUSH
14527: CALL_OW 69
14531: PUSH
14532: LD_INT 0
14534: EQUAL
14535: PUSH
14536: LD_INT 8
14538: PPUSH
14539: LD_INT 1
14541: PPUSH
14542: CALL_OW 81
14546: PUSH
14547: LD_INT 2
14549: EQUAL
14550: AND
14551: IFFALSE 14563
14553: GO 14555
14555: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14556: LD_STRING O3a
14558: PPUSH
14559: CALL_OW 337
14563: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14564: LD_EXP 2
14568: PUSH
14569: LD_INT 1
14571: EQUAL
14572: PUSH
14573: LD_EXP 3
14577: AND
14578: PUSH
14579: LD_INT 22
14581: PUSH
14582: LD_INT 3
14584: PUSH
14585: EMPTY
14586: LIST
14587: LIST
14588: PUSH
14589: LD_INT 21
14591: PUSH
14592: LD_INT 1
14594: PUSH
14595: EMPTY
14596: LIST
14597: LIST
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PPUSH
14603: CALL_OW 69
14607: PUSH
14608: LD_INT 0
14610: EQUAL
14611: AND
14612: PUSH
14613: LD_INT 22
14615: PUSH
14616: LD_INT 3
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: PUSH
14623: LD_INT 30
14625: PUSH
14626: LD_INT 1
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PPUSH
14637: CALL_OW 69
14641: PUSH
14642: LD_INT 0
14644: EQUAL
14645: AND
14646: IFFALSE 14884
14648: GO 14650
14650: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14651: LD_EXP 9
14655: PPUSH
14656: LD_STRING D
14658: PUSH
14659: LD_STRING I
14661: PUSH
14662: LD_STRING J
14664: PUSH
14665: LD_STRING S
14667: PUSH
14668: EMPTY
14669: LIST
14670: LIST
14671: LIST
14672: PUSH
14673: LD_EXP 25
14677: ARRAY
14678: STR
14679: PUSH
14680: LD_STRING -1-Win
14682: STR
14683: PPUSH
14684: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14688: LD_OWVAR 1
14692: PUSH
14693: LD_INT 315000
14695: PUSH
14696: LD_INT 273000
14698: PUSH
14699: LD_INT 231000
14701: PUSH
14702: EMPTY
14703: LIST
14704: LIST
14705: LIST
14706: PUSH
14707: LD_OWVAR 67
14711: ARRAY
14712: GREATEREQUAL
14713: IFFALSE 14728
// AddMedal ( med1 , - 1 ) else
14715: LD_STRING med1
14717: PPUSH
14718: LD_INT 1
14720: NEG
14721: PPUSH
14722: CALL_OW 101
14726: GO 14738
// AddMedal ( med1 , 1 ) ;
14728: LD_STRING med1
14730: PPUSH
14731: LD_INT 1
14733: PPUSH
14734: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14738: LD_EXP 22
14742: PUSH
14743: LD_INT 20
14745: PUSH
14746: LD_INT 15
14748: PUSH
14749: LD_INT 10
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: LIST
14756: PUSH
14757: LD_OWVAR 67
14761: ARRAY
14762: GREATEREQUAL
14763: IFFALSE 14778
// AddMedal ( med2 , - 1 ) else
14765: LD_STRING med2
14767: PPUSH
14768: LD_INT 1
14770: NEG
14771: PPUSH
14772: CALL_OW 101
14776: GO 14788
// AddMedal ( med2 , 1 ) ;
14778: LD_STRING med2
14780: PPUSH
14781: LD_INT 1
14783: PPUSH
14784: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14788: LD_INT 8
14790: PPUSH
14791: LD_INT 1
14793: PPUSH
14794: CALL_OW 81
14798: PUSH
14799: LD_INT 1
14801: EQUAL
14802: IFFALSE 14816
// AddMedal ( med3 , 1 ) else
14804: LD_STRING med3
14806: PPUSH
14807: LD_INT 1
14809: PPUSH
14810: CALL_OW 101
14814: GO 14873
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14816: LD_INT 22
14818: PUSH
14819: LD_INT 8
14821: PUSH
14822: EMPTY
14823: LIST
14824: LIST
14825: PUSH
14826: LD_INT 21
14828: PUSH
14829: LD_INT 1
14831: PUSH
14832: EMPTY
14833: LIST
14834: LIST
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: PPUSH
14840: CALL_OW 69
14844: PUSH
14845: LD_INT 0
14847: EQUAL
14848: IFFALSE 14862
// AddMedal ( med3 , 2 ) else
14850: LD_STRING med3
14852: PPUSH
14853: LD_INT 2
14855: PPUSH
14856: CALL_OW 101
14860: GO 14873
// AddMedal ( med3 , - 1 ) ;
14862: LD_STRING med3
14864: PPUSH
14865: LD_INT 1
14867: NEG
14868: PPUSH
14869: CALL_OW 101
// GiveMedals ( MAIN ) ;
14873: LD_STRING MAIN
14875: PPUSH
14876: CALL_OW 102
// YouWin ;
14880: CALL_OW 103
// end ;
14884: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14885: LD_EXP 2
14889: PUSH
14890: LD_INT 1
14892: EQUAL
14893: PUSH
14894: LD_EXP 16
14898: AND
14899: PUSH
14900: LD_INT 20
14902: PPUSH
14903: LD_INT 81
14905: PUSH
14906: LD_INT 8
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PPUSH
14913: CALL_OW 70
14917: AND
14918: IFFALSE 15197
14920: GO 14922
14922: DISABLE
14923: LD_INT 0
14925: PPUSH
14926: PPUSH
14927: PPUSH
14928: PPUSH
14929: PPUSH
// begin enable ;
14930: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14931: LD_ADDR_VAR 0 3
14935: PUSH
14936: LD_INT 20
14938: PPUSH
14939: LD_INT 81
14941: PUSH
14942: LD_INT 8
14944: PUSH
14945: EMPTY
14946: LIST
14947: LIST
14948: PPUSH
14949: CALL_OW 70
14953: ST_TO_ADDR
// if not tmp then
14954: LD_VAR 0 3
14958: NOT
14959: IFFALSE 14963
// exit ;
14961: GO 15197
// for i in tmp do
14963: LD_ADDR_VAR 0 1
14967: PUSH
14968: LD_VAR 0 3
14972: PUSH
14973: FOR_IN
14974: IFFALSE 15195
// begin x := GetX ( i ) ;
14976: LD_ADDR_VAR 0 4
14980: PUSH
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 250
14990: ST_TO_ADDR
// y := GetY ( i ) ;
14991: LD_ADDR_VAR 0 5
14995: PUSH
14996: LD_VAR 0 1
15000: PPUSH
15001: CALL_OW 251
15005: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15006: LD_VAR 0 4
15010: PPUSH
15011: LD_VAR 0 5
15015: PPUSH
15016: CALL_OW 458
15020: IFFALSE 15193
// begin LaunchMineAtPos ( x , y , 8 ) ;
15022: LD_VAR 0 4
15026: PPUSH
15027: LD_VAR 0 5
15031: PPUSH
15032: LD_INT 8
15034: PPUSH
15035: CALL_OW 456
// if not dialogueMineDetected then
15039: LD_EXP 28
15043: NOT
15044: IFFALSE 15105
// begin CenterNowOnXY ( x , y ) ;
15046: LD_VAR 0 4
15050: PPUSH
15051: LD_VAR 0 5
15055: PPUSH
15056: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15060: LD_EXP 9
15064: PPUSH
15065: LD_STRING D
15067: PUSH
15068: LD_STRING I
15070: PUSH
15071: LD_STRING J
15073: PUSH
15074: LD_STRING S
15076: PUSH
15077: EMPTY
15078: LIST
15079: LIST
15080: LIST
15081: PUSH
15082: LD_EXP 25
15086: ARRAY
15087: STR
15088: PUSH
15089: LD_STRING -1-Mine
15091: STR
15092: PPUSH
15093: CALL_OW 88
// dialogueMineDetected := true ;
15097: LD_ADDR_EXP 28
15101: PUSH
15102: LD_INT 1
15104: ST_TO_ADDR
// end ; for j = 1 to staticMines do
15105: LD_ADDR_VAR 0 2
15109: PUSH
15110: DOUBLE
15111: LD_INT 1
15113: DEC
15114: ST_TO_ADDR
15115: LD_EXP 16
15119: PUSH
15120: FOR_TO
15121: IFFALSE 15191
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15123: LD_EXP 16
15127: PUSH
15128: LD_VAR 0 2
15132: ARRAY
15133: PUSH
15134: LD_INT 1
15136: ARRAY
15137: PUSH
15138: LD_VAR 0 4
15142: EQUAL
15143: PUSH
15144: LD_EXP 16
15148: PUSH
15149: LD_VAR 0 2
15153: ARRAY
15154: PUSH
15155: LD_INT 2
15157: ARRAY
15158: PUSH
15159: LD_VAR 0 5
15163: EQUAL
15164: AND
15165: IFFALSE 15189
// begin staticMines := Delete ( staticMines , j ) ;
15167: LD_ADDR_EXP 16
15171: PUSH
15172: LD_EXP 16
15176: PPUSH
15177: LD_VAR 0 2
15181: PPUSH
15182: CALL_OW 3
15186: ST_TO_ADDR
// break ;
15187: GO 15191
// end ;
15189: GO 15120
15191: POP
15192: POP
// end ; end ;
15193: GO 14973
15195: POP
15196: POP
// end ;
15197: PPOPN 5
15199: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15200: LD_EXP 2
15204: PUSH
15205: LD_INT 1
15207: EQUAL
15208: PUSH
15209: LD_EXP 3
15213: AND
15214: PUSH
15215: LD_EXP 23
15219: AND
15220: PUSH
15221: LD_EXP 50
15225: PUSH
15226: LD_EXP 7
15230: ARRAY
15231: PPUSH
15232: LD_INT 30
15234: PUSH
15235: LD_INT 3
15237: PUSH
15238: EMPTY
15239: LIST
15240: LIST
15241: PPUSH
15242: CALL_OW 72
15246: AND
15247: IFFALSE 15451
15249: GO 15251
15251: DISABLE
15252: LD_INT 0
15254: PPUSH
15255: PPUSH
// begin enable ;
15256: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15257: LD_EXP 7
15261: PPUSH
15262: LD_INT 23
15264: PUSH
15265: LD_INT 3
15267: PUSH
15268: LD_INT 3
15270: PUSH
15271: LD_INT 48
15273: PUSH
15274: EMPTY
15275: LIST
15276: LIST
15277: LIST
15278: LIST
15279: PUSH
15280: EMPTY
15281: LIST
15282: PPUSH
15283: CALL 84351 0 2
// repeat wait ( 0 0$1 ) ;
15287: LD_INT 35
15289: PPUSH
15290: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15294: LD_INT 22
15296: PUSH
15297: LD_INT 3
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: PUSH
15304: LD_INT 34
15306: PUSH
15307: LD_INT 48
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PPUSH
15318: CALL_OW 69
15322: IFFALSE 15287
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15324: LD_ADDR_VAR 0 1
15328: PUSH
15329: LD_INT 22
15331: PUSH
15332: LD_INT 3
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: PUSH
15339: LD_INT 34
15341: PUSH
15342: LD_INT 48
15344: PUSH
15345: EMPTY
15346: LIST
15347: LIST
15348: PUSH
15349: EMPTY
15350: LIST
15351: LIST
15352: PPUSH
15353: CALL_OW 69
15357: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15358: LD_ADDR_VAR 0 2
15362: PUSH
15363: LD_INT 81
15365: PUSH
15366: LD_INT 3
15368: PUSH
15369: EMPTY
15370: LIST
15371: LIST
15372: PUSH
15373: LD_INT 21
15375: PUSH
15376: LD_INT 3
15378: PUSH
15379: EMPTY
15380: LIST
15381: LIST
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PPUSH
15387: CALL_OW 69
15391: ST_TO_ADDR
// if e then
15392: LD_VAR 0 2
15396: IFFALSE 15422
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15398: LD_ADDR_VAR 0 2
15402: PUSH
15403: LD_VAR 0 2
15407: PPUSH
15408: LD_VAR 0 1
15412: PUSH
15413: LD_INT 1
15415: ARRAY
15416: PPUSH
15417: CALL_OW 74
15421: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15422: LD_VAR 0 1
15426: PPUSH
15427: LD_VAR 0 2
15431: PPUSH
15432: CALL_OW 250
15436: PPUSH
15437: LD_VAR 0 2
15441: PPUSH
15442: CALL_OW 251
15446: PPUSH
15447: CALL_OW 116
// end ;
15451: PPOPN 2
15453: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15454: LD_OWVAR 67
15458: PUSH
15459: LD_INT 1
15461: GREATER
15462: PUSH
15463: LD_EXP 50
15467: PUSH
15468: LD_EXP 7
15472: ARRAY
15473: PPUSH
15474: LD_INT 25
15476: PUSH
15477: LD_INT 3
15479: PUSH
15480: EMPTY
15481: LIST
15482: LIST
15483: PPUSH
15484: CALL_OW 72
15488: AND
15489: PUSH
15490: LD_EXP 2
15494: PUSH
15495: LD_INT 1
15497: EQUAL
15498: AND
15499: PUSH
15500: LD_EXP 3
15504: AND
15505: PUSH
15506: LD_INT 23
15508: PPUSH
15509: LD_INT 3
15511: PPUSH
15512: CALL_OW 321
15516: PUSH
15517: LD_INT 2
15519: EQUAL
15520: AND
15521: IFFALSE 15648
15523: GO 15525
15525: DISABLE
15526: LD_INT 0
15528: PPUSH
15529: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15530: LD_ADDR_VAR 0 1
15534: PUSH
15535: LD_EXP 50
15539: PUSH
15540: LD_EXP 7
15544: ARRAY
15545: PPUSH
15546: LD_INT 25
15548: PUSH
15549: LD_INT 3
15551: PUSH
15552: EMPTY
15553: LIST
15554: LIST
15555: PPUSH
15556: CALL_OW 72
15560: ST_TO_ADDR
// if not tmp then
15561: LD_VAR 0 1
15565: NOT
15566: IFFALSE 15570
// exit ;
15568: GO 15648
// for i in tmp do
15570: LD_ADDR_VAR 0 2
15574: PUSH
15575: LD_VAR 0 1
15579: PUSH
15580: FOR_IN
15581: IFFALSE 15627
// begin SetTag ( i , 29 ) ;
15583: LD_VAR 0 2
15587: PPUSH
15588: LD_INT 29
15590: PPUSH
15591: CALL_OW 109
// ComExitBuilding ( i ) ;
15595: LD_VAR 0 2
15599: PPUSH
15600: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15604: LD_VAR 0 2
15608: PPUSH
15609: LD_INT 37
15611: PPUSH
15612: LD_INT 97
15614: PPUSH
15615: LD_INT 133
15617: PPUSH
15618: LD_INT 0
15620: PPUSH
15621: CALL_OW 230
// end ;
15625: GO 15580
15627: POP
15628: POP
// wait ( 1 1$00 ) ;
15629: LD_INT 2100
15631: PPUSH
15632: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15636: LD_EXP 7
15640: PPUSH
15641: LD_INT 29
15643: PPUSH
15644: CALL 64285 0 2
// end ;
15648: PPOPN 2
15650: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15651: LD_EXP 2
15655: PUSH
15656: LD_INT 1
15658: EQUAL
15659: PUSH
15660: LD_INT 84
15662: PPUSH
15663: LD_INT 128
15665: PPUSH
15666: CALL_OW 428
15670: PPUSH
15671: CALL_OW 266
15675: PUSH
15676: LD_INT 1
15678: EQUAL
15679: AND
15680: PUSH
15681: LD_INT 84
15683: PPUSH
15684: LD_INT 128
15686: PPUSH
15687: CALL_OW 428
15691: PPUSH
15692: CALL_OW 255
15696: PUSH
15697: LD_INT 3
15699: EQUAL
15700: AND
15701: IFFALSE 15874
15703: GO 15705
15705: DISABLE
15706: LD_INT 0
15708: PPUSH
15709: PPUSH
// begin enable ;
15710: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15711: LD_ADDR_VAR 0 2
15715: PUSH
15716: LD_INT 84
15718: PPUSH
15719: LD_INT 128
15721: PPUSH
15722: CALL_OW 428
15726: ST_TO_ADDR
// uc_side := 3 ;
15727: LD_ADDR_OWVAR 20
15731: PUSH
15732: LD_INT 3
15734: ST_TO_ADDR
// uc_nation := 3 ;
15735: LD_ADDR_OWVAR 21
15739: PUSH
15740: LD_INT 3
15742: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15743: LD_INT 21
15745: PPUSH
15746: LD_INT 3
15748: PPUSH
15749: LD_INT 3
15751: PPUSH
15752: LD_INT 51
15754: PPUSH
15755: LD_INT 0
15757: PPUSH
15758: CALL 24736 0 5
// veh := CreateVehicle ;
15762: LD_ADDR_VAR 0 1
15766: PUSH
15767: CALL_OW 45
15771: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15772: LD_VAR 0 1
15776: PPUSH
15777: LD_INT 126
15779: PPUSH
15780: LD_INT 227
15782: PPUSH
15783: LD_INT 0
15785: PPUSH
15786: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15790: LD_VAR 0 1
15794: PPUSH
15795: LD_INT 2
15797: PPUSH
15798: LD_INT 100
15800: PPUSH
15801: CALL_OW 290
// ComGive ( veh , depot ) ;
15805: LD_VAR 0 1
15809: PPUSH
15810: LD_VAR 0 2
15814: PPUSH
15815: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_INT 126
15826: PPUSH
15827: LD_INT 227
15829: PPUSH
15830: CALL_OW 171
// wait ( 0 0$10 ) ;
15834: LD_INT 350
15836: PPUSH
15837: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15841: LD_INT 35
15843: PPUSH
15844: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15848: LD_VAR 0 1
15852: PPUSH
15853: LD_INT 126
15855: PPUSH
15856: LD_INT 227
15858: PPUSH
15859: CALL_OW 307
15863: IFFALSE 15841
// RemoveUnit ( veh ) ;
15865: LD_VAR 0 1
15869: PPUSH
15870: CALL_OW 64
// end ;
15874: PPOPN 2
15876: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15877: LD_EXP 2
15881: PUSH
15882: LD_INT 1
15884: EQUAL
15885: PUSH
15886: LD_EXP 27
15890: AND
15891: PUSH
15892: LD_EXP 25
15896: PUSH
15897: LD_INT 2
15899: EQUAL
15900: AND
15901: IFFALSE 16093
15903: GO 15905
15905: DISABLE
15906: LD_INT 0
15908: PPUSH
15909: PPUSH
// begin enable ;
15910: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15911: LD_OWVAR 1
15915: PUSH
15916: LD_INT 105000
15918: PUSH
15919: LD_INT 84000
15921: PUSH
15922: LD_INT 63000
15924: PUSH
15925: EMPTY
15926: LIST
15927: LIST
15928: LIST
15929: PUSH
15930: LD_OWVAR 67
15934: ARRAY
15935: GREATEREQUAL
15936: IFFALSE 15939
// disable ;
15938: DISABLE
// uc_side := 4 ;
15939: LD_ADDR_OWVAR 20
15943: PUSH
15944: LD_INT 4
15946: ST_TO_ADDR
// uc_nation := 1 ;
15947: LD_ADDR_OWVAR 21
15951: PUSH
15952: LD_INT 1
15954: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15955: LD_INT 2
15957: PPUSH
15958: LD_INT 3
15960: PPUSH
15961: LD_INT 3
15963: PPUSH
15964: LD_INT 12
15966: PPUSH
15967: LD_INT 0
15969: PPUSH
15970: CALL 24736 0 5
// veh := CreateVehicle ;
15974: LD_ADDR_VAR 0 1
15978: PUSH
15979: CALL_OW 45
15983: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15984: LD_VAR 0 1
15988: PPUSH
15989: LD_INT 229
15991: PPUSH
15992: LD_INT 226
15994: PPUSH
15995: LD_INT 0
15997: PPUSH
15998: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16002: LD_VAR 0 1
16006: PPUSH
16007: LD_INT 1
16009: PPUSH
16010: LD_INT 100
16012: PPUSH
16013: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16017: LD_VAR 0 1
16021: PPUSH
16022: LD_INT 25
16024: PPUSH
16025: CALL_OW 173
// AddComUnload ( veh ) ;
16029: LD_VAR 0 1
16033: PPUSH
16034: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16038: LD_VAR 0 1
16042: PPUSH
16043: LD_INT 229
16045: PPUSH
16046: LD_INT 226
16048: PPUSH
16049: CALL_OW 171
// wait ( 0 0$10 ) ;
16053: LD_INT 350
16055: PPUSH
16056: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16060: LD_INT 35
16062: PPUSH
16063: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16067: LD_VAR 0 1
16071: PPUSH
16072: LD_INT 229
16074: PPUSH
16075: LD_INT 226
16077: PPUSH
16078: CALL_OW 307
16082: IFFALSE 16060
// RemoveUnit ( veh ) ;
16084: LD_VAR 0 1
16088: PPUSH
16089: CALL_OW 64
// end ;
16093: PPOPN 2
16095: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16096: LD_EXP 2
16100: PUSH
16101: LD_INT 1
16103: EQUAL
16104: PUSH
16105: LD_EXP 3
16109: AND
16110: PUSH
16111: LD_EXP 24
16115: AND
16116: IFFALSE 16449
16118: GO 16120
16120: DISABLE
16121: LD_INT 0
16123: PPUSH
16124: PPUSH
16125: PPUSH
16126: PPUSH
16127: PPUSH
// begin enable ;
16128: ENABLE
// tmp := [ ] ;
16129: LD_ADDR_VAR 0 4
16133: PUSH
16134: EMPTY
16135: ST_TO_ADDR
// if commander = 1 then
16136: LD_EXP 25
16140: PUSH
16141: LD_INT 1
16143: EQUAL
16144: IFFALSE 16156
// amount := 3 else
16146: LD_ADDR_VAR 0 5
16150: PUSH
16151: LD_INT 3
16153: ST_TO_ADDR
16154: GO 16164
// amount := 2 ;
16156: LD_ADDR_VAR 0 5
16160: PUSH
16161: LD_INT 2
16163: ST_TO_ADDR
// for i = 1 to amount do
16164: LD_ADDR_VAR 0 1
16168: PUSH
16169: DOUBLE
16170: LD_INT 1
16172: DEC
16173: ST_TO_ADDR
16174: LD_VAR 0 5
16178: PUSH
16179: FOR_TO
16180: IFFALSE 16344
// begin wait ( 0 0$5 ) ;
16182: LD_INT 175
16184: PPUSH
16185: CALL_OW 67
// for j = 1 to 3 do
16189: LD_ADDR_VAR 0 2
16193: PUSH
16194: DOUBLE
16195: LD_INT 1
16197: DEC
16198: ST_TO_ADDR
16199: LD_INT 3
16201: PUSH
16202: FOR_TO
16203: IFFALSE 16340
// begin uc_side := 4 ;
16205: LD_ADDR_OWVAR 20
16209: PUSH
16210: LD_INT 4
16212: ST_TO_ADDR
// uc_nation := 1 ;
16213: LD_ADDR_OWVAR 21
16217: PUSH
16218: LD_INT 1
16220: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16221: LD_INT 3
16223: PUSH
16224: LD_INT 5
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: PUSH
16231: LD_INT 1
16233: PPUSH
16234: LD_INT 2
16236: PPUSH
16237: CALL_OW 12
16241: ARRAY
16242: PPUSH
16243: LD_INT 3
16245: PPUSH
16246: LD_INT 3
16248: PPUSH
16249: LD_INT 9
16251: PUSH
16252: LD_INT 5
16254: PUSH
16255: LD_INT 7
16257: PUSH
16258: EMPTY
16259: LIST
16260: LIST
16261: LIST
16262: PUSH
16263: LD_INT 1
16265: PPUSH
16266: LD_INT 3
16268: PPUSH
16269: CALL_OW 12
16273: ARRAY
16274: PPUSH
16275: LD_INT 100
16277: PPUSH
16278: CALL 24736 0 5
// veh := CreateVehicle ;
16282: LD_ADDR_VAR 0 3
16286: PUSH
16287: CALL_OW 45
16291: ST_TO_ADDR
// tmp := tmp ^ veh ;
16292: LD_ADDR_VAR 0 4
16296: PUSH
16297: LD_VAR 0 4
16301: PUSH
16302: LD_VAR 0 3
16306: ADD
16307: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16308: LD_VAR 0 3
16312: PPUSH
16313: LD_INT 22
16315: PPUSH
16316: LD_INT 0
16318: PPUSH
16319: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16323: LD_VAR 0 3
16327: PPUSH
16328: LD_INT 119
16330: PPUSH
16331: LD_INT 215
16333: PPUSH
16334: CALL_OW 111
// end ;
16338: GO 16202
16340: POP
16341: POP
// end ;
16342: GO 16179
16344: POP
16345: POP
// wait ( 0 0$3 ) ;
16346: LD_INT 105
16348: PPUSH
16349: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16353: LD_INT 35
16355: PPUSH
16356: CALL_OW 67
// for i in tmp do
16360: LD_ADDR_VAR 0 1
16364: PUSH
16365: LD_VAR 0 4
16369: PUSH
16370: FOR_IN
16371: IFFALSE 16438
// if IsDead ( i ) then
16373: LD_VAR 0 1
16377: PPUSH
16378: CALL_OW 301
16382: IFFALSE 16402
// tmp := tmp diff i else
16384: LD_ADDR_VAR 0 4
16388: PUSH
16389: LD_VAR 0 4
16393: PUSH
16394: LD_VAR 0 1
16398: DIFF
16399: ST_TO_ADDR
16400: GO 16436
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16402: LD_VAR 0 1
16406: PPUSH
16407: LD_INT 81
16409: PUSH
16410: LD_INT 4
16412: PUSH
16413: EMPTY
16414: LIST
16415: LIST
16416: PPUSH
16417: CALL_OW 69
16421: PPUSH
16422: LD_VAR 0 1
16426: PPUSH
16427: CALL_OW 74
16431: PPUSH
16432: CALL_OW 115
16436: GO 16370
16438: POP
16439: POP
// until tmp = [ ] ;
16440: LD_VAR 0 4
16444: PUSH
16445: EMPTY
16446: EQUAL
16447: IFFALSE 16353
// end ;
16449: PPOPN 5
16451: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16452: LD_EXP 2
16456: PUSH
16457: LD_INT 1
16459: EQUAL
16460: PUSH
16461: LD_EXP 3
16465: AND
16466: IFFALSE 16567
16468: GO 16470
16470: DISABLE
16471: LD_INT 0
16473: PPUSH
16474: PPUSH
// begin enable ;
16475: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16476: LD_ADDR_VAR 0 2
16480: PUSH
16481: LD_INT 3
16483: PUSH
16484: LD_INT 22
16486: PUSH
16487: LD_INT 1
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: PUSH
16494: EMPTY
16495: LIST
16496: LIST
16497: PUSH
16498: LD_INT 32
16500: PUSH
16501: LD_INT 1
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PPUSH
16512: CALL_OW 69
16516: ST_TO_ADDR
// if tmp then
16517: LD_VAR 0 2
16521: IFFALSE 16567
// for i in tmp do
16523: LD_ADDR_VAR 0 1
16527: PUSH
16528: LD_VAR 0 2
16532: PUSH
16533: FOR_IN
16534: IFFALSE 16565
// if GetFuel ( i ) < 3 then
16536: LD_VAR 0 1
16540: PPUSH
16541: CALL_OW 261
16545: PUSH
16546: LD_INT 3
16548: LESS
16549: IFFALSE 16563
// SetFuel ( i , 3 ) ;
16551: LD_VAR 0 1
16555: PPUSH
16556: LD_INT 3
16558: PPUSH
16559: CALL_OW 240
16563: GO 16533
16565: POP
16566: POP
// end ;
16567: PPOPN 2
16569: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16570: LD_EXP 3
16574: PUSH
16575: LD_INT 8
16577: PPUSH
16578: LD_INT 4
16580: PPUSH
16581: CALL_OW 81
16585: PUSH
16586: LD_INT 2
16588: EQUAL
16589: AND
16590: IFFALSE 16800
16592: GO 16594
16594: DISABLE
16595: LD_INT 0
16597: PPUSH
16598: PPUSH
16599: PPUSH
// begin enable ;
16600: ENABLE
// tmp := [ ] ;
16601: LD_ADDR_VAR 0 3
16605: PUSH
16606: EMPTY
16607: ST_TO_ADDR
// for i = 1 to 4 do
16608: LD_ADDR_VAR 0 1
16612: PUSH
16613: DOUBLE
16614: LD_INT 1
16616: DEC
16617: ST_TO_ADDR
16618: LD_INT 4
16620: PUSH
16621: FOR_TO
16622: IFFALSE 16766
// begin uc_side := 8 ;
16624: LD_ADDR_OWVAR 20
16628: PUSH
16629: LD_INT 8
16631: ST_TO_ADDR
// uc_nation := nation_arabian ;
16632: LD_ADDR_OWVAR 21
16636: PUSH
16637: LD_INT 2
16639: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16640: LD_INT 11
16642: PPUSH
16643: LD_INT 1
16645: PPUSH
16646: LD_INT 5
16648: PPUSH
16649: LD_INT 24
16651: PUSH
16652: LD_INT 23
16654: PUSH
16655: EMPTY
16656: LIST
16657: LIST
16658: PUSH
16659: LD_INT 1
16661: PPUSH
16662: LD_INT 2
16664: PPUSH
16665: CALL_OW 12
16669: ARRAY
16670: PPUSH
16671: LD_INT 60
16673: PPUSH
16674: LD_INT 80
16676: PPUSH
16677: CALL_OW 12
16681: PPUSH
16682: CALL 24736 0 5
// un := CreateVehicle ;
16686: LD_ADDR_VAR 0 2
16690: PUSH
16691: CALL_OW 45
16695: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16696: LD_VAR 0 2
16700: PPUSH
16701: LD_INT 2
16703: PPUSH
16704: CALL_OW 233
// tmp := tmp ^ un ;
16708: LD_ADDR_VAR 0 3
16712: PUSH
16713: LD_VAR 0 3
16717: PUSH
16718: LD_VAR 0 2
16722: ADD
16723: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16724: LD_VAR 0 2
16728: PPUSH
16729: LD_INT 88
16731: PPUSH
16732: LD_INT 2
16734: PPUSH
16735: LD_INT 0
16737: PPUSH
16738: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16742: LD_VAR 0 2
16746: PPUSH
16747: LD_INT 93
16749: PPUSH
16750: LD_INT 13
16752: PPUSH
16753: CALL_OW 111
// wait ( 0 0$2 ) ;
16757: LD_INT 70
16759: PPUSH
16760: CALL_OW 67
// end ;
16764: GO 16621
16766: POP
16767: POP
// for i in tmp do
16768: LD_ADDR_VAR 0 1
16772: PUSH
16773: LD_VAR 0 3
16777: PUSH
16778: FOR_IN
16779: IFFALSE 16798
// AddComMoveXY ( i , 136 , 19 ) ;
16781: LD_VAR 0 1
16785: PPUSH
16786: LD_INT 136
16788: PPUSH
16789: LD_INT 19
16791: PPUSH
16792: CALL_OW 171
16796: GO 16778
16798: POP
16799: POP
// end ;
16800: PPOPN 3
16802: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16803: LD_EXP 3
16807: IFFALSE 17726
16809: GO 16811
16811: DISABLE
16812: LD_INT 0
16814: PPUSH
16815: PPUSH
16816: PPUSH
16817: PPUSH
// begin enable ;
16818: ENABLE
// base := mc_leg ;
16819: LD_ADDR_VAR 0 2
16823: PUSH
16824: LD_EXP 6
16828: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16829: LD_INT 22
16831: PUSH
16832: LD_INT 8
16834: PUSH
16835: EMPTY
16836: LIST
16837: LIST
16838: PUSH
16839: LD_INT 23
16841: PUSH
16842: LD_INT 2
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: PUSH
16849: LD_INT 30
16851: PUSH
16852: LD_INT 3
16854: PUSH
16855: EMPTY
16856: LIST
16857: LIST
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: LIST
16863: PPUSH
16864: CALL_OW 69
16868: NOT
16869: IFFALSE 16873
// exit ;
16871: GO 17726
// if Prob ( 40 ) then
16873: LD_INT 40
16875: PPUSH
16876: CALL_OW 13
16880: IFFALSE 17009
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16882: LD_VAR 0 2
16886: PPUSH
16887: LD_INT 13
16889: PUSH
16890: LD_INT 1
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: LD_INT 28
16898: PUSH
16899: EMPTY
16900: LIST
16901: LIST
16902: LIST
16903: LIST
16904: PUSH
16905: LD_INT 13
16907: PUSH
16908: LD_INT 1
16910: PUSH
16911: LD_INT 2
16913: PUSH
16914: LD_INT 28
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: PUSH
16923: LD_INT 13
16925: PUSH
16926: LD_INT 1
16928: PUSH
16929: LD_INT 2
16931: PUSH
16932: LD_INT 28
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: PUSH
16941: LD_INT 13
16943: PUSH
16944: LD_INT 1
16946: PUSH
16947: LD_INT 2
16949: PUSH
16950: LD_INT 28
16952: PUSH
16953: EMPTY
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: PUSH
16959: LD_INT 13
16961: PUSH
16962: LD_INT 1
16964: PUSH
16965: LD_INT 2
16967: PUSH
16968: LD_INT 28
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: PUSH
16977: LD_INT 13
16979: PUSH
16980: LD_INT 1
16982: PUSH
16983: LD_INT 2
16985: PUSH
16986: LD_INT 26
16988: PUSH
16989: EMPTY
16990: LIST
16991: LIST
16992: LIST
16993: LIST
16994: PUSH
16995: EMPTY
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: LIST
17001: LIST
17002: PPUSH
17003: CALL 84351 0 2
// end else
17007: GO 17226
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17009: LD_VAR 0 2
17013: PPUSH
17014: LD_INT 13
17016: PUSH
17017: LD_INT 1
17019: PUSH
17020: LD_INT 2
17022: PUSH
17023: LD_INT 27
17025: PUSH
17026: LD_INT 26
17028: PUSH
17029: LD_INT 26
17031: PUSH
17032: EMPTY
17033: LIST
17034: LIST
17035: LIST
17036: PUSH
17037: LD_INT 1
17039: PPUSH
17040: LD_INT 3
17042: PPUSH
17043: CALL_OW 12
17047: ARRAY
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: PUSH
17055: LD_INT 13
17057: PUSH
17058: LD_INT 1
17060: PUSH
17061: LD_INT 2
17063: PUSH
17064: LD_INT 27
17066: PUSH
17067: LD_INT 26
17069: PUSH
17070: LD_INT 26
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: PUSH
17078: LD_INT 1
17080: PPUSH
17081: LD_INT 3
17083: PPUSH
17084: CALL_OW 12
17088: ARRAY
17089: PUSH
17090: EMPTY
17091: LIST
17092: LIST
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 13
17098: PUSH
17099: LD_INT 1
17101: PUSH
17102: LD_INT 2
17104: PUSH
17105: LD_INT 26
17107: PUSH
17108: LD_INT 26
17110: PUSH
17111: LD_INT 29
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: PUSH
17119: LD_INT 1
17121: PPUSH
17122: LD_INT 3
17124: PPUSH
17125: CALL_OW 12
17129: ARRAY
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: LIST
17135: LIST
17136: PUSH
17137: LD_INT 13
17139: PUSH
17140: LD_INT 1
17142: PUSH
17143: LD_INT 2
17145: PUSH
17146: LD_INT 26
17148: PUSH
17149: LD_INT 29
17151: PUSH
17152: LD_INT 29
17154: PUSH
17155: EMPTY
17156: LIST
17157: LIST
17158: LIST
17159: PUSH
17160: LD_INT 1
17162: PPUSH
17163: LD_INT 3
17165: PPUSH
17166: CALL_OW 12
17170: ARRAY
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: PUSH
17178: LD_INT 13
17180: PUSH
17181: LD_INT 1
17183: PUSH
17184: LD_INT 2
17186: PUSH
17187: LD_INT 29
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: PUSH
17196: LD_INT 13
17198: PUSH
17199: LD_INT 1
17201: PUSH
17202: LD_INT 2
17204: PUSH
17205: LD_INT 26
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: PPUSH
17222: CALL 84351 0 2
// end ; repeat wait ( 0 0$1 ) ;
17226: LD_INT 35
17228: PPUSH
17229: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17233: LD_VAR 0 2
17237: PPUSH
17238: LD_INT 1
17240: PPUSH
17241: CALL 85769 0 2
17245: PUSH
17246: LD_INT 6
17248: GREATEREQUAL
17249: PUSH
17250: LD_OWVAR 1
17254: PUSH
17255: LD_INT 21000
17257: MOD
17258: PUSH
17259: LD_INT 0
17261: EQUAL
17262: OR
17263: IFFALSE 17226
// wait ( 0 0$30 ) ;
17265: LD_INT 1050
17267: PPUSH
17268: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17272: LD_ADDR_VAR 0 3
17276: PUSH
17277: LD_VAR 0 2
17281: PPUSH
17282: LD_INT 1
17284: PPUSH
17285: CALL 85769 0 2
17289: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17290: LD_ADDR_EXP 69
17294: PUSH
17295: LD_EXP 69
17299: PPUSH
17300: LD_VAR 0 2
17304: PPUSH
17305: LD_EXP 69
17309: PUSH
17310: LD_VAR 0 2
17314: ARRAY
17315: PUSH
17316: LD_VAR 0 3
17320: DIFF
17321: PPUSH
17322: CALL_OW 1
17326: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17327: LD_ADDR_VAR 0 4
17331: PUSH
17332: LD_INT 0
17334: PPUSH
17335: LD_INT 2
17337: PPUSH
17338: CALL_OW 12
17342: ST_TO_ADDR
// if legChangeSide then
17343: LD_EXP 21
17347: IFFALSE 17357
// target := 2 ;
17349: LD_ADDR_VAR 0 4
17353: PUSH
17354: LD_INT 2
17356: ST_TO_ADDR
// if target = 2 then
17357: LD_VAR 0 4
17361: PUSH
17362: LD_INT 2
17364: EQUAL
17365: IFFALSE 17493
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17367: LD_ADDR_VAR 0 3
17371: PUSH
17372: LD_VAR 0 3
17376: PPUSH
17377: LD_INT 24
17379: PUSH
17380: LD_INT 250
17382: PUSH
17383: EMPTY
17384: LIST
17385: LIST
17386: PPUSH
17387: CALL_OW 72
17391: ST_TO_ADDR
// for i in tmp do
17392: LD_ADDR_VAR 0 1
17396: PUSH
17397: LD_VAR 0 3
17401: PUSH
17402: FOR_IN
17403: IFFALSE 17443
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17405: LD_VAR 0 1
17409: PPUSH
17410: LD_INT 112
17412: PPUSH
17413: LD_INT 64
17415: PPUSH
17416: CALL_OW 297
17420: PUSH
17421: LD_INT 9
17423: GREATER
17424: IFFALSE 17441
// ComMoveXY ( i , 112 , 64 ) ;
17426: LD_VAR 0 1
17430: PPUSH
17431: LD_INT 112
17433: PPUSH
17434: LD_INT 64
17436: PPUSH
17437: CALL_OW 111
17441: GO 17402
17443: POP
17444: POP
// wait ( 0 0$1 ) ;
17445: LD_INT 35
17447: PPUSH
17448: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17452: LD_VAR 0 3
17456: PPUSH
17457: LD_INT 92
17459: PUSH
17460: LD_INT 112
17462: PUSH
17463: LD_INT 64
17465: PUSH
17466: LD_INT 9
17468: PUSH
17469: EMPTY
17470: LIST
17471: LIST
17472: LIST
17473: LIST
17474: PPUSH
17475: CALL_OW 72
17479: PUSH
17480: LD_VAR 0 3
17484: PUSH
17485: LD_INT 1
17487: MINUS
17488: GREATEREQUAL
17489: IFFALSE 17367
// end else
17491: GO 17617
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17493: LD_ADDR_VAR 0 3
17497: PUSH
17498: LD_VAR 0 3
17502: PPUSH
17503: LD_INT 24
17505: PUSH
17506: LD_INT 250
17508: PUSH
17509: EMPTY
17510: LIST
17511: LIST
17512: PPUSH
17513: CALL_OW 72
17517: ST_TO_ADDR
// for i in tmp do
17518: LD_ADDR_VAR 0 1
17522: PUSH
17523: LD_VAR 0 3
17527: PUSH
17528: FOR_IN
17529: IFFALSE 17569
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17531: LD_VAR 0 1
17535: PPUSH
17536: LD_INT 174
17538: PPUSH
17539: LD_INT 94
17541: PPUSH
17542: CALL_OW 297
17546: PUSH
17547: LD_INT 9
17549: GREATER
17550: IFFALSE 17567
// ComMoveXY ( i , 174 , 94 ) ;
17552: LD_VAR 0 1
17556: PPUSH
17557: LD_INT 174
17559: PPUSH
17560: LD_INT 94
17562: PPUSH
17563: CALL_OW 111
17567: GO 17528
17569: POP
17570: POP
// wait ( 0 0$1 ) ;
17571: LD_INT 35
17573: PPUSH
17574: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17578: LD_VAR 0 3
17582: PPUSH
17583: LD_INT 92
17585: PUSH
17586: LD_INT 174
17588: PUSH
17589: LD_INT 94
17591: PUSH
17592: LD_INT 9
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: LIST
17599: LIST
17600: PPUSH
17601: CALL_OW 72
17605: PUSH
17606: LD_VAR 0 3
17610: PUSH
17611: LD_INT 1
17613: MINUS
17614: GREATEREQUAL
17615: IFFALSE 17493
// end ; repeat wait ( 0 0$1 ) ;
17617: LD_INT 35
17619: PPUSH
17620: CALL_OW 67
// for i in tmp do
17624: LD_ADDR_VAR 0 1
17628: PUSH
17629: LD_VAR 0 3
17633: PUSH
17634: FOR_IN
17635: IFFALSE 17717
// begin if GetLives ( i ) > 251 then
17637: LD_VAR 0 1
17641: PPUSH
17642: CALL_OW 256
17646: PUSH
17647: LD_INT 251
17649: GREATER
17650: IFFALSE 17688
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17652: LD_VAR 0 1
17656: PPUSH
17657: LD_INT 81
17659: PUSH
17660: LD_INT 8
17662: PUSH
17663: EMPTY
17664: LIST
17665: LIST
17666: PPUSH
17667: CALL_OW 69
17671: PPUSH
17672: LD_VAR 0 1
17676: PPUSH
17677: CALL_OW 74
17681: PPUSH
17682: CALL_OW 115
17686: GO 17715
// if IsDead ( i ) then
17688: LD_VAR 0 1
17692: PPUSH
17693: CALL_OW 301
17697: IFFALSE 17715
// tmp := tmp diff i ;
17699: LD_ADDR_VAR 0 3
17703: PUSH
17704: LD_VAR 0 3
17708: PUSH
17709: LD_VAR 0 1
17713: DIFF
17714: ST_TO_ADDR
// end ;
17715: GO 17634
17717: POP
17718: POP
// until not tmp ;
17719: LD_VAR 0 3
17723: NOT
17724: IFFALSE 17617
// end ;
17726: PPOPN 4
17728: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17729: LD_EXP 3
17733: IFFALSE 18721
17735: GO 17737
17737: DISABLE
17738: LD_INT 0
17740: PPUSH
17741: PPUSH
17742: PPUSH
17743: PPUSH
17744: PPUSH
// begin enable ;
17745: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17746: LD_EXP 50
17750: PUSH
17751: LD_EXP 8
17755: ARRAY
17756: PPUSH
17757: LD_INT 22
17759: PUSH
17760: LD_INT 3
17762: PUSH
17763: EMPTY
17764: LIST
17765: LIST
17766: PUSH
17767: LD_INT 30
17769: PUSH
17770: LD_INT 3
17772: PUSH
17773: EMPTY
17774: LIST
17775: LIST
17776: PUSH
17777: EMPTY
17778: LIST
17779: LIST
17780: PPUSH
17781: CALL_OW 72
17785: NOT
17786: IFFALSE 17790
// exit ;
17788: GO 18721
// base := mc_rus_2 ;
17790: LD_ADDR_VAR 0 2
17794: PUSH
17795: LD_EXP 8
17799: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17800: LD_ADDR_VAR 0 5
17804: PUSH
17805: LD_INT 22
17807: PUSH
17808: LD_INT 3
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: PUSH
17815: LD_INT 30
17817: PUSH
17818: LD_INT 34
17820: PUSH
17821: EMPTY
17822: LIST
17823: LIST
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PPUSH
17829: CALL_OW 69
17833: ST_TO_ADDR
// if Prob ( 40 ) then
17834: LD_INT 40
17836: PPUSH
17837: CALL_OW 13
17841: IFFALSE 17970
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17843: LD_VAR 0 2
17847: PPUSH
17848: LD_INT 22
17850: PUSH
17851: LD_INT 3
17853: PUSH
17854: LD_INT 3
17856: PUSH
17857: LD_INT 49
17859: PUSH
17860: EMPTY
17861: LIST
17862: LIST
17863: LIST
17864: LIST
17865: PUSH
17866: LD_INT 22
17868: PUSH
17869: LD_INT 3
17871: PUSH
17872: LD_INT 3
17874: PUSH
17875: LD_INT 49
17877: PUSH
17878: EMPTY
17879: LIST
17880: LIST
17881: LIST
17882: LIST
17883: PUSH
17884: LD_INT 22
17886: PUSH
17887: LD_INT 3
17889: PUSH
17890: LD_INT 3
17892: PUSH
17893: LD_INT 49
17895: PUSH
17896: EMPTY
17897: LIST
17898: LIST
17899: LIST
17900: LIST
17901: PUSH
17902: LD_INT 24
17904: PUSH
17905: LD_INT 3
17907: PUSH
17908: LD_INT 3
17910: PUSH
17911: LD_INT 46
17913: PUSH
17914: EMPTY
17915: LIST
17916: LIST
17917: LIST
17918: LIST
17919: PUSH
17920: LD_INT 24
17922: PUSH
17923: LD_INT 3
17925: PUSH
17926: LD_INT 3
17928: PUSH
17929: LD_INT 46
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: PUSH
17938: LD_INT 24
17940: PUSH
17941: LD_INT 3
17943: PUSH
17944: LD_INT 3
17946: PUSH
17947: LD_INT 46
17949: PUSH
17950: EMPTY
17951: LIST
17952: LIST
17953: LIST
17954: LIST
17955: PUSH
17956: EMPTY
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: LIST
17962: LIST
17963: PPUSH
17964: CALL 84351 0 2
// end else
17968: GO 18095
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17970: LD_VAR 0 2
17974: PPUSH
17975: LD_INT 24
17977: PUSH
17978: LD_INT 3
17980: PUSH
17981: LD_INT 3
17983: PUSH
17984: LD_INT 47
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 24
17995: PUSH
17996: LD_INT 3
17998: PUSH
17999: LD_INT 3
18001: PUSH
18002: LD_INT 47
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: PUSH
18011: LD_INT 24
18013: PUSH
18014: LD_INT 3
18016: PUSH
18017: LD_INT 3
18019: PUSH
18020: LD_INT 47
18022: PUSH
18023: EMPTY
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: PUSH
18029: LD_INT 24
18031: PUSH
18032: LD_INT 3
18034: PUSH
18035: LD_INT 3
18037: PUSH
18038: LD_INT 46
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: PUSH
18047: LD_INT 24
18049: PUSH
18050: LD_INT 3
18052: PUSH
18053: LD_INT 3
18055: PUSH
18056: LD_INT 46
18058: PUSH
18059: EMPTY
18060: LIST
18061: LIST
18062: LIST
18063: LIST
18064: PUSH
18065: LD_INT 24
18067: PUSH
18068: LD_INT 3
18070: PUSH
18071: LD_INT 3
18073: PUSH
18074: LD_INT 46
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: LIST
18081: LIST
18082: PUSH
18083: EMPTY
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: LIST
18089: LIST
18090: PPUSH
18091: CALL 84351 0 2
// end ; if Difficulty > 1 then
18095: LD_OWVAR 67
18099: PUSH
18100: LD_INT 1
18102: GREATER
18103: IFFALSE 18135
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18105: LD_VAR 0 2
18109: PPUSH
18110: LD_INT 24
18112: PUSH
18113: LD_INT 3
18115: PUSH
18116: LD_INT 3
18118: PUSH
18119: LD_INT 47
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: LIST
18126: LIST
18127: PUSH
18128: EMPTY
18129: LIST
18130: PPUSH
18131: CALL 84351 0 2
// repeat wait ( 0 0$1 ) ;
18135: LD_INT 35
18137: PPUSH
18138: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18142: LD_VAR 0 2
18146: PPUSH
18147: LD_INT 1
18149: PPUSH
18150: CALL 85769 0 2
18154: PUSH
18155: LD_INT 6
18157: PUSH
18158: LD_INT 7
18160: PUSH
18161: LD_INT 7
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: LIST
18168: PUSH
18169: LD_OWVAR 67
18173: ARRAY
18174: GREATEREQUAL
18175: PUSH
18176: LD_OWVAR 1
18180: PUSH
18181: LD_INT 21000
18183: MOD
18184: PUSH
18185: LD_INT 0
18187: EQUAL
18188: OR
18189: IFFALSE 18135
// wait ( 0 0$45 ) ;
18191: LD_INT 1575
18193: PPUSH
18194: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18198: LD_ADDR_VAR 0 3
18202: PUSH
18203: LD_VAR 0 2
18207: PPUSH
18208: LD_INT 1
18210: PPUSH
18211: CALL 85769 0 2
18215: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18216: LD_ADDR_EXP 69
18220: PUSH
18221: LD_EXP 69
18225: PPUSH
18226: LD_VAR 0 2
18230: PPUSH
18231: LD_EXP 69
18235: PUSH
18236: LD_VAR 0 2
18240: ARRAY
18241: PUSH
18242: LD_VAR 0 3
18246: DIFF
18247: PPUSH
18248: CALL_OW 1
18252: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18253: LD_ADDR_VAR 0 4
18257: PUSH
18258: LD_INT 0
18260: PPUSH
18261: LD_INT 1
18263: PPUSH
18264: CALL_OW 12
18268: ST_TO_ADDR
// if target then
18269: LD_VAR 0 4
18273: IFFALSE 18401
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18275: LD_ADDR_VAR 0 3
18279: PUSH
18280: LD_VAR 0 3
18284: PPUSH
18285: LD_INT 24
18287: PUSH
18288: LD_INT 250
18290: PUSH
18291: EMPTY
18292: LIST
18293: LIST
18294: PPUSH
18295: CALL_OW 72
18299: ST_TO_ADDR
// for i in tmp do
18300: LD_ADDR_VAR 0 1
18304: PUSH
18305: LD_VAR 0 3
18309: PUSH
18310: FOR_IN
18311: IFFALSE 18351
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18313: LD_VAR 0 1
18317: PPUSH
18318: LD_INT 84
18320: PPUSH
18321: LD_INT 32
18323: PPUSH
18324: CALL_OW 297
18328: PUSH
18329: LD_INT 9
18331: GREATER
18332: IFFALSE 18349
// ComMoveXY ( i , 84 , 32 ) ;
18334: LD_VAR 0 1
18338: PPUSH
18339: LD_INT 84
18341: PPUSH
18342: LD_INT 32
18344: PPUSH
18345: CALL_OW 111
18349: GO 18310
18351: POP
18352: POP
// wait ( 0 0$1 ) ;
18353: LD_INT 35
18355: PPUSH
18356: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18360: LD_VAR 0 3
18364: PPUSH
18365: LD_INT 92
18367: PUSH
18368: LD_INT 84
18370: PUSH
18371: LD_INT 32
18373: PUSH
18374: LD_INT 9
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: LIST
18381: LIST
18382: PPUSH
18383: CALL_OW 72
18387: PUSH
18388: LD_VAR 0 3
18392: PUSH
18393: LD_INT 1
18395: MINUS
18396: GREATEREQUAL
18397: IFFALSE 18275
// end else
18399: GO 18561
// begin if teleport then
18401: LD_VAR 0 5
18405: IFFALSE 18425
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18407: LD_VAR 0 3
18411: PPUSH
18412: LD_VAR 0 5
18416: PUSH
18417: LD_INT 1
18419: ARRAY
18420: PPUSH
18421: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18425: LD_ADDR_VAR 0 3
18429: PUSH
18430: LD_VAR 0 3
18434: PPUSH
18435: LD_INT 24
18437: PUSH
18438: LD_INT 250
18440: PUSH
18441: EMPTY
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL_OW 72
18449: ST_TO_ADDR
// for i in tmp do
18450: LD_ADDR_VAR 0 1
18454: PUSH
18455: LD_VAR 0 3
18459: PUSH
18460: FOR_IN
18461: IFFALSE 18513
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18463: LD_VAR 0 1
18467: PPUSH
18468: LD_INT 140
18470: PPUSH
18471: LD_INT 219
18473: PPUSH
18474: CALL_OW 297
18478: PUSH
18479: LD_INT 9
18481: GREATER
18482: PUSH
18483: LD_VAR 0 1
18487: PPUSH
18488: CALL_OW 314
18492: NOT
18493: AND
18494: IFFALSE 18511
// AddComMoveXY ( i , 140 , 219 ) ;
18496: LD_VAR 0 1
18500: PPUSH
18501: LD_INT 140
18503: PPUSH
18504: LD_INT 219
18506: PPUSH
18507: CALL_OW 171
18511: GO 18460
18513: POP
18514: POP
// wait ( 0 0$1 ) ;
18515: LD_INT 35
18517: PPUSH
18518: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18522: LD_VAR 0 3
18526: PPUSH
18527: LD_INT 92
18529: PUSH
18530: LD_INT 140
18532: PUSH
18533: LD_INT 219
18535: PUSH
18536: LD_INT 9
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: LIST
18543: LIST
18544: PPUSH
18545: CALL_OW 72
18549: PUSH
18550: LD_VAR 0 3
18554: PUSH
18555: LD_INT 1
18557: MINUS
18558: GREATEREQUAL
18559: IFFALSE 18425
// end ; repeat wait ( 0 0$1 ) ;
18561: LD_INT 35
18563: PPUSH
18564: CALL_OW 67
// for i in tmp do
18568: LD_ADDR_VAR 0 1
18572: PUSH
18573: LD_VAR 0 3
18577: PUSH
18578: FOR_IN
18579: IFFALSE 18712
// begin if GetLives ( i ) > 251 then
18581: LD_VAR 0 1
18585: PPUSH
18586: CALL_OW 256
18590: PUSH
18591: LD_INT 251
18593: GREATER
18594: IFFALSE 18683
// begin if GetWeapon ( i ) = ru_time_lapser then
18596: LD_VAR 0 1
18600: PPUSH
18601: CALL_OW 264
18605: PUSH
18606: LD_INT 49
18608: EQUAL
18609: IFFALSE 18647
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18611: LD_VAR 0 1
18615: PPUSH
18616: LD_INT 81
18618: PUSH
18619: LD_INT 3
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PPUSH
18626: CALL_OW 69
18630: PPUSH
18631: LD_VAR 0 1
18635: PPUSH
18636: CALL_OW 74
18640: PPUSH
18641: CALL_OW 112
18645: GO 18681
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18647: LD_VAR 0 1
18651: PPUSH
18652: LD_INT 81
18654: PUSH
18655: LD_INT 3
18657: PUSH
18658: EMPTY
18659: LIST
18660: LIST
18661: PPUSH
18662: CALL_OW 69
18666: PPUSH
18667: LD_VAR 0 1
18671: PPUSH
18672: CALL_OW 74
18676: PPUSH
18677: CALL_OW 115
// end else
18681: GO 18710
// if IsDead ( i ) then
18683: LD_VAR 0 1
18687: PPUSH
18688: CALL_OW 301
18692: IFFALSE 18710
// tmp := tmp diff i ;
18694: LD_ADDR_VAR 0 3
18698: PUSH
18699: LD_VAR 0 3
18703: PUSH
18704: LD_VAR 0 1
18708: DIFF
18709: ST_TO_ADDR
// end ;
18710: GO 18578
18712: POP
18713: POP
// until not tmp ;
18714: LD_VAR 0 3
18718: NOT
18719: IFFALSE 18561
// end ;
18721: PPOPN 5
18723: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18724: LD_EXP 3
18728: IFFALSE 19110
18730: GO 18732
18732: DISABLE
18733: LD_INT 0
18735: PPUSH
18736: PPUSH
18737: PPUSH
18738: PPUSH
// begin enable ;
18739: ENABLE
// base := mc_amer ;
18740: LD_ADDR_VAR 0 2
18744: PUSH
18745: LD_EXP 5
18749: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18750: LD_INT 22
18752: PUSH
18753: LD_INT 4
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PUSH
18760: LD_INT 23
18762: PUSH
18763: LD_INT 1
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PUSH
18770: LD_INT 30
18772: PUSH
18773: LD_INT 3
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: LIST
18784: PPUSH
18785: CALL_OW 69
18789: NOT
18790: IFFALSE 18794
// exit ;
18792: GO 19110
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18794: LD_VAR 0 2
18798: PPUSH
18799: LD_INT 3
18801: PUSH
18802: LD_INT 1
18804: PUSH
18805: LD_INT 2
18807: PUSH
18808: LD_INT 5
18810: PUSH
18811: EMPTY
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 3
18819: PUSH
18820: LD_INT 1
18822: PUSH
18823: LD_INT 2
18825: PUSH
18826: LD_INT 9
18828: PUSH
18829: EMPTY
18830: LIST
18831: LIST
18832: LIST
18833: LIST
18834: PUSH
18835: LD_INT 3
18837: PUSH
18838: LD_INT 1
18840: PUSH
18841: LD_INT 2
18843: PUSH
18844: LD_INT 7
18846: PUSH
18847: EMPTY
18848: LIST
18849: LIST
18850: LIST
18851: LIST
18852: PUSH
18853: LD_INT 3
18855: PUSH
18856: LD_INT 1
18858: PUSH
18859: LD_INT 2
18861: PUSH
18862: LD_INT 7
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: LIST
18869: LIST
18870: PUSH
18871: LD_INT 3
18873: PUSH
18874: LD_INT 1
18876: PUSH
18877: LD_INT 2
18879: PUSH
18880: LD_INT 7
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: LIST
18887: LIST
18888: PUSH
18889: EMPTY
18890: LIST
18891: LIST
18892: LIST
18893: LIST
18894: LIST
18895: PPUSH
18896: CALL 84351 0 2
// repeat wait ( 0 0$1 ) ;
18900: LD_INT 35
18902: PPUSH
18903: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18907: LD_VAR 0 2
18911: PPUSH
18912: LD_INT 1
18914: PPUSH
18915: CALL 85769 0 2
18919: PUSH
18920: LD_INT 5
18922: GREATEREQUAL
18923: PUSH
18924: LD_OWVAR 1
18928: PUSH
18929: LD_INT 21000
18931: MOD
18932: PUSH
18933: LD_INT 0
18935: EQUAL
18936: OR
18937: IFFALSE 18900
// wait ( 0 0$30 ) ;
18939: LD_INT 1050
18941: PPUSH
18942: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18946: LD_ADDR_VAR 0 3
18950: PUSH
18951: LD_VAR 0 2
18955: PPUSH
18956: LD_INT 1
18958: PPUSH
18959: CALL 85769 0 2
18963: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18964: LD_ADDR_EXP 69
18968: PUSH
18969: LD_EXP 69
18973: PPUSH
18974: LD_VAR 0 2
18978: PPUSH
18979: LD_EXP 69
18983: PUSH
18984: LD_VAR 0 2
18988: ARRAY
18989: PUSH
18990: LD_VAR 0 3
18994: DIFF
18995: PPUSH
18996: CALL_OW 1
19000: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19001: LD_INT 35
19003: PPUSH
19004: CALL_OW 67
// for i in tmp do
19008: LD_ADDR_VAR 0 1
19012: PUSH
19013: LD_VAR 0 3
19017: PUSH
19018: FOR_IN
19019: IFFALSE 19101
// begin if GetLives ( i ) > 251 then
19021: LD_VAR 0 1
19025: PPUSH
19026: CALL_OW 256
19030: PUSH
19031: LD_INT 251
19033: GREATER
19034: IFFALSE 19072
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19036: LD_VAR 0 1
19040: PPUSH
19041: LD_INT 81
19043: PUSH
19044: LD_INT 4
19046: PUSH
19047: EMPTY
19048: LIST
19049: LIST
19050: PPUSH
19051: CALL_OW 69
19055: PPUSH
19056: LD_VAR 0 1
19060: PPUSH
19061: CALL_OW 74
19065: PPUSH
19066: CALL_OW 115
19070: GO 19099
// if IsDead ( i ) then
19072: LD_VAR 0 1
19076: PPUSH
19077: CALL_OW 301
19081: IFFALSE 19099
// tmp := tmp diff i ;
19083: LD_ADDR_VAR 0 3
19087: PUSH
19088: LD_VAR 0 3
19092: PUSH
19093: LD_VAR 0 1
19097: DIFF
19098: ST_TO_ADDR
// end ;
19099: GO 19018
19101: POP
19102: POP
// until not tmp ;
19103: LD_VAR 0 3
19107: NOT
19108: IFFALSE 19001
// end ; end_of_file
19110: PPOPN 4
19112: END
// export function CustomEvent ( event ) ; begin
19113: LD_INT 0
19115: PPUSH
// end ;
19116: LD_VAR 0 2
19120: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19121: LD_VAR 0 1
19125: PUSH
19126: LD_INT 1
19128: EQUAL
19129: PUSH
19130: LD_VAR 0 2
19134: PUSH
19135: LD_INT 4
19137: EQUAL
19138: AND
19139: IFFALSE 19167
// begin SayRadio ( Powell , DP-Lost ) ;
19141: LD_EXP 12
19145: PPUSH
19146: LD_STRING DP-Lost
19148: PPUSH
19149: CALL_OW 94
// wait ( 0 0$2 ) ;
19153: LD_INT 70
19155: PPUSH
19156: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19160: LD_STRING FriendlyFire
19162: PPUSH
19163: CALL_OW 104
// end ; end ;
19167: PPOPN 2
19169: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19170: LD_VAR 0 1
19174: PPUSH
19175: CALL 105086 0 1
// if GameType = 1 then
19179: LD_EXP 2
19183: PUSH
19184: LD_INT 1
19186: EQUAL
19187: IFFALSE 19422
// begin if un = playerCommander then
19189: LD_VAR 0 1
19193: PUSH
19194: LD_EXP 9
19198: EQUAL
19199: IFFALSE 19208
// YouLost ( commanderDied ) ;
19201: LD_STRING commanderDied
19203: PPUSH
19204: CALL_OW 104
// if un = allyCommander then
19208: LD_VAR 0 1
19212: PUSH
19213: LD_EXP 11
19217: EQUAL
19218: IFFALSE 19227
// YouLost ( Theta ) ;
19220: LD_STRING Theta
19222: PPUSH
19223: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19227: LD_VAR 0 1
19231: PUSH
19232: LD_INT 22
19234: PUSH
19235: LD_INT 8
19237: PUSH
19238: EMPTY
19239: LIST
19240: LIST
19241: PUSH
19242: LD_INT 2
19244: PUSH
19245: LD_INT 21
19247: PUSH
19248: LD_INT 1
19250: PUSH
19251: EMPTY
19252: LIST
19253: LIST
19254: PUSH
19255: LD_INT 21
19257: PUSH
19258: LD_INT 3
19260: PUSH
19261: EMPTY
19262: LIST
19263: LIST
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: LIST
19269: PUSH
19270: EMPTY
19271: LIST
19272: LIST
19273: PPUSH
19274: CALL_OW 69
19278: IN
19279: IFFALSE 19295
// legDestCounter := legDestCounter + 1 ;
19281: LD_ADDR_EXP 18
19285: PUSH
19286: LD_EXP 18
19290: PUSH
19291: LD_INT 1
19293: PLUS
19294: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19295: LD_VAR 0 1
19299: PUSH
19300: LD_INT 22
19302: PUSH
19303: LD_INT 4
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: PUSH
19310: LD_INT 2
19312: PUSH
19313: LD_INT 21
19315: PUSH
19316: LD_INT 1
19318: PUSH
19319: EMPTY
19320: LIST
19321: LIST
19322: PUSH
19323: LD_INT 21
19325: PUSH
19326: LD_INT 3
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: LIST
19337: PUSH
19338: EMPTY
19339: LIST
19340: LIST
19341: PPUSH
19342: CALL_OW 69
19346: IN
19347: IFFALSE 19363
// allyDestCounter := allyDestCounter + 1 ;
19349: LD_ADDR_EXP 22
19353: PUSH
19354: LD_EXP 22
19358: PUSH
19359: LD_INT 1
19361: PLUS
19362: ST_TO_ADDR
// if un in ruOutpost then
19363: LD_VAR 0 1
19367: PUSH
19368: LD_EXP 14
19372: IN
19373: IFFALSE 19422
// begin ruOutpost := ruOutpost diff un ;
19375: LD_ADDR_EXP 14
19379: PUSH
19380: LD_EXP 14
19384: PUSH
19385: LD_VAR 0 1
19389: DIFF
19390: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19391: LD_ADDR_EXP 15
19395: PUSH
19396: LD_EXP 15
19400: PPUSH
19401: LD_INT 1
19403: PPUSH
19404: LD_EXP 15
19408: PUSH
19409: LD_INT 1
19411: ARRAY
19412: PUSH
19413: LD_INT 1
19415: PLUS
19416: PPUSH
19417: CALL_OW 1
19421: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19422: LD_VAR 0 1
19426: PPUSH
19427: CALL 87771 0 1
// end ;
19431: PPOPN 1
19433: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19434: LD_VAR 0 1
19438: PPUSH
19439: LD_VAR 0 2
19443: PPUSH
19444: CALL 90105 0 2
// end ;
19448: PPOPN 2
19450: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19451: LD_VAR 0 1
19455: PPUSH
19456: CALL 89173 0 1
// end ;
19460: PPOPN 1
19462: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19463: LD_VAR 0 1
19467: PPUSH
19468: CALL 89414 0 1
// end ;
19472: PPOPN 1
19474: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19475: LD_VAR 0 1
19479: PUSH
19480: LD_INT 14
19482: EQUAL
19483: PUSH
19484: LD_VAR 0 2
19488: PPUSH
19489: CALL_OW 255
19493: PUSH
19494: LD_INT 1
19496: EQUAL
19497: AND
19498: IFFALSE 19539
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19500: LD_EXP 9
19504: PPUSH
19505: LD_STRING D
19507: PUSH
19508: LD_STRING I
19510: PUSH
19511: LD_STRING J
19513: PUSH
19514: LD_STRING S
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: LIST
19521: PUSH
19522: LD_EXP 25
19526: ARRAY
19527: STR
19528: PUSH
19529: LD_STRING -1-Laser
19531: STR
19532: PPUSH
19533: CALL_OW 88
// exit ;
19537: GO 19681
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19539: LD_VAR 0 1
19543: PUSH
19544: LD_INT 7
19546: EQUAL
19547: PUSH
19548: LD_VAR 0 2
19552: PPUSH
19553: CALL_OW 255
19557: PUSH
19558: LD_INT 1
19560: EQUAL
19561: AND
19562: IFFALSE 19603
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19564: LD_EXP 9
19568: PPUSH
19569: LD_STRING D
19571: PUSH
19572: LD_STRING I
19574: PUSH
19575: LD_STRING J
19577: PUSH
19578: LD_STRING S
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: PUSH
19586: LD_EXP 25
19590: ARRAY
19591: STR
19592: PUSH
19593: LD_STRING -1-Materialization
19595: STR
19596: PPUSH
19597: CALL_OW 88
// exit ;
19601: GO 19681
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19603: LD_VAR 0 1
19607: PUSH
19608: LD_INT 25
19610: EQUAL
19611: PUSH
19612: LD_VAR 0 2
19616: PPUSH
19617: CALL_OW 255
19621: PUSH
19622: LD_INT 1
19624: EQUAL
19625: AND
19626: IFFALSE 19667
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19628: LD_EXP 9
19632: PPUSH
19633: LD_STRING D
19635: PUSH
19636: LD_STRING I
19638: PUSH
19639: LD_STRING J
19641: PUSH
19642: LD_STRING S
19644: PUSH
19645: EMPTY
19646: LIST
19647: LIST
19648: LIST
19649: PUSH
19650: LD_EXP 25
19654: ARRAY
19655: STR
19656: PUSH
19657: LD_STRING -1-Rocket
19659: STR
19660: PPUSH
19661: CALL_OW 88
// exit ;
19665: GO 19681
// end ; MCE_ResearchComplete ( tech , lab ) ;
19667: LD_VAR 0 1
19671: PPUSH
19672: LD_VAR 0 2
19676: PPUSH
19677: CALL 87467 0 2
// end ;
19681: PPOPN 2
19683: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19684: LD_VAR 0 1
19688: PPUSH
19689: LD_VAR 0 2
19693: PPUSH
19694: LD_VAR 0 3
19698: PPUSH
19699: LD_VAR 0 4
19703: PPUSH
19704: LD_VAR 0 5
19708: PPUSH
19709: CALL 87087 0 5
// end ;
19713: PPOPN 5
19715: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
19716: LD_VAR 0 1
19720: PPUSH
19721: LD_VAR 0 2
19725: PPUSH
19726: CALL 86668 0 2
// end ;
19730: PPOPN 2
19732: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19733: LD_VAR 0 1
19737: PPUSH
19738: LD_VAR 0 2
19742: PPUSH
19743: LD_VAR 0 3
19747: PPUSH
19748: LD_VAR 0 4
19752: PPUSH
19753: CALL 86506 0 4
// end ;
19757: PPOPN 4
19759: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19760: LD_VAR 0 1
19764: PPUSH
19765: LD_VAR 0 2
19769: PPUSH
19770: LD_VAR 0 3
19774: PPUSH
19775: CALL 86281 0 3
// end ;
19779: PPOPN 3
19781: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19782: LD_VAR 0 1
19786: PPUSH
19787: LD_VAR 0 2
19791: PPUSH
19792: CALL 86166 0 2
// end ;
19796: PPOPN 2
19798: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19799: LD_VAR 0 1
19803: PPUSH
19804: LD_VAR 0 2
19808: PPUSH
19809: CALL 90400 0 2
// end ;
19813: PPOPN 2
19815: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19816: LD_VAR 0 1
19820: PPUSH
19821: LD_VAR 0 2
19825: PPUSH
19826: LD_VAR 0 3
19830: PPUSH
19831: LD_VAR 0 4
19835: PPUSH
19836: CALL 90616 0 4
// end ;
19840: PPOPN 4
19842: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19843: LD_VAR 0 1
19847: PPUSH
19848: LD_VAR 0 2
19852: PPUSH
19853: CALL 85975 0 2
// end ;
19857: PPOPN 2
19859: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19860: LD_VAR 0 1
19864: PPUSH
19865: CALL 105192 0 1
// end ; end_of_file
19869: PPOPN 1
19871: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19872: LD_INT 0
19874: PPUSH
19875: PPUSH
// if exist_mode then
19876: LD_VAR 0 2
19880: IFFALSE 19905
// unit := CreateCharacter ( prefix & ident ) else
19882: LD_ADDR_VAR 0 5
19886: PUSH
19887: LD_VAR 0 3
19891: PUSH
19892: LD_VAR 0 1
19896: STR
19897: PPUSH
19898: CALL_OW 34
19902: ST_TO_ADDR
19903: GO 19920
// unit := NewCharacter ( ident ) ;
19905: LD_ADDR_VAR 0 5
19909: PUSH
19910: LD_VAR 0 1
19914: PPUSH
19915: CALL_OW 25
19919: ST_TO_ADDR
// result := unit ;
19920: LD_ADDR_VAR 0 4
19924: PUSH
19925: LD_VAR 0 5
19929: ST_TO_ADDR
// end ;
19930: LD_VAR 0 4
19934: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19935: LD_INT 0
19937: PPUSH
19938: PPUSH
// if not side or not nation then
19939: LD_VAR 0 1
19943: NOT
19944: PUSH
19945: LD_VAR 0 2
19949: NOT
19950: OR
19951: IFFALSE 19955
// exit ;
19953: GO 20723
// case nation of nation_american :
19955: LD_VAR 0 2
19959: PUSH
19960: LD_INT 1
19962: DOUBLE
19963: EQUAL
19964: IFTRUE 19968
19966: GO 20182
19968: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19969: LD_ADDR_VAR 0 4
19973: PUSH
19974: LD_INT 35
19976: PUSH
19977: LD_INT 45
19979: PUSH
19980: LD_INT 46
19982: PUSH
19983: LD_INT 47
19985: PUSH
19986: LD_INT 82
19988: PUSH
19989: LD_INT 83
19991: PUSH
19992: LD_INT 84
19994: PUSH
19995: LD_INT 85
19997: PUSH
19998: LD_INT 86
20000: PUSH
20001: LD_INT 1
20003: PUSH
20004: LD_INT 2
20006: PUSH
20007: LD_INT 6
20009: PUSH
20010: LD_INT 15
20012: PUSH
20013: LD_INT 16
20015: PUSH
20016: LD_INT 7
20018: PUSH
20019: LD_INT 12
20021: PUSH
20022: LD_INT 13
20024: PUSH
20025: LD_INT 10
20027: PUSH
20028: LD_INT 14
20030: PUSH
20031: LD_INT 20
20033: PUSH
20034: LD_INT 21
20036: PUSH
20037: LD_INT 22
20039: PUSH
20040: LD_INT 25
20042: PUSH
20043: LD_INT 32
20045: PUSH
20046: LD_INT 27
20048: PUSH
20049: LD_INT 36
20051: PUSH
20052: LD_INT 69
20054: PUSH
20055: LD_INT 39
20057: PUSH
20058: LD_INT 34
20060: PUSH
20061: LD_INT 40
20063: PUSH
20064: LD_INT 48
20066: PUSH
20067: LD_INT 49
20069: PUSH
20070: LD_INT 50
20072: PUSH
20073: LD_INT 51
20075: PUSH
20076: LD_INT 52
20078: PUSH
20079: LD_INT 53
20081: PUSH
20082: LD_INT 54
20084: PUSH
20085: LD_INT 55
20087: PUSH
20088: LD_INT 56
20090: PUSH
20091: LD_INT 57
20093: PUSH
20094: LD_INT 58
20096: PUSH
20097: LD_INT 59
20099: PUSH
20100: LD_INT 60
20102: PUSH
20103: LD_INT 61
20105: PUSH
20106: LD_INT 62
20108: PUSH
20109: LD_INT 80
20111: PUSH
20112: LD_INT 82
20114: PUSH
20115: LD_INT 83
20117: PUSH
20118: LD_INT 84
20120: PUSH
20121: LD_INT 85
20123: PUSH
20124: LD_INT 86
20126: PUSH
20127: EMPTY
20128: LIST
20129: LIST
20130: LIST
20131: LIST
20132: LIST
20133: LIST
20134: LIST
20135: LIST
20136: LIST
20137: LIST
20138: LIST
20139: LIST
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: ST_TO_ADDR
20180: GO 20647
20182: LD_INT 2
20184: DOUBLE
20185: EQUAL
20186: IFTRUE 20190
20188: GO 20416
20190: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20191: LD_ADDR_VAR 0 4
20195: PUSH
20196: LD_INT 35
20198: PUSH
20199: LD_INT 45
20201: PUSH
20202: LD_INT 46
20204: PUSH
20205: LD_INT 47
20207: PUSH
20208: LD_INT 82
20210: PUSH
20211: LD_INT 83
20213: PUSH
20214: LD_INT 84
20216: PUSH
20217: LD_INT 85
20219: PUSH
20220: LD_INT 87
20222: PUSH
20223: LD_INT 70
20225: PUSH
20226: LD_INT 1
20228: PUSH
20229: LD_INT 11
20231: PUSH
20232: LD_INT 3
20234: PUSH
20235: LD_INT 4
20237: PUSH
20238: LD_INT 5
20240: PUSH
20241: LD_INT 6
20243: PUSH
20244: LD_INT 15
20246: PUSH
20247: LD_INT 18
20249: PUSH
20250: LD_INT 7
20252: PUSH
20253: LD_INT 17
20255: PUSH
20256: LD_INT 8
20258: PUSH
20259: LD_INT 20
20261: PUSH
20262: LD_INT 21
20264: PUSH
20265: LD_INT 22
20267: PUSH
20268: LD_INT 72
20270: PUSH
20271: LD_INT 26
20273: PUSH
20274: LD_INT 69
20276: PUSH
20277: LD_INT 39
20279: PUSH
20280: LD_INT 40
20282: PUSH
20283: LD_INT 41
20285: PUSH
20286: LD_INT 42
20288: PUSH
20289: LD_INT 43
20291: PUSH
20292: LD_INT 48
20294: PUSH
20295: LD_INT 49
20297: PUSH
20298: LD_INT 50
20300: PUSH
20301: LD_INT 51
20303: PUSH
20304: LD_INT 52
20306: PUSH
20307: LD_INT 53
20309: PUSH
20310: LD_INT 54
20312: PUSH
20313: LD_INT 55
20315: PUSH
20316: LD_INT 56
20318: PUSH
20319: LD_INT 60
20321: PUSH
20322: LD_INT 61
20324: PUSH
20325: LD_INT 62
20327: PUSH
20328: LD_INT 66
20330: PUSH
20331: LD_INT 67
20333: PUSH
20334: LD_INT 68
20336: PUSH
20337: LD_INT 81
20339: PUSH
20340: LD_INT 82
20342: PUSH
20343: LD_INT 83
20345: PUSH
20346: LD_INT 84
20348: PUSH
20349: LD_INT 85
20351: PUSH
20352: LD_INT 87
20354: PUSH
20355: LD_INT 88
20357: PUSH
20358: EMPTY
20359: LIST
20360: LIST
20361: LIST
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: LIST
20368: LIST
20369: LIST
20370: LIST
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: ST_TO_ADDR
20414: GO 20647
20416: LD_INT 3
20418: DOUBLE
20419: EQUAL
20420: IFTRUE 20424
20422: GO 20646
20424: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20425: LD_ADDR_VAR 0 4
20429: PUSH
20430: LD_INT 46
20432: PUSH
20433: LD_INT 47
20435: PUSH
20436: LD_INT 1
20438: PUSH
20439: LD_INT 2
20441: PUSH
20442: LD_INT 82
20444: PUSH
20445: LD_INT 83
20447: PUSH
20448: LD_INT 84
20450: PUSH
20451: LD_INT 85
20453: PUSH
20454: LD_INT 86
20456: PUSH
20457: LD_INT 11
20459: PUSH
20460: LD_INT 9
20462: PUSH
20463: LD_INT 20
20465: PUSH
20466: LD_INT 19
20468: PUSH
20469: LD_INT 21
20471: PUSH
20472: LD_INT 24
20474: PUSH
20475: LD_INT 22
20477: PUSH
20478: LD_INT 25
20480: PUSH
20481: LD_INT 28
20483: PUSH
20484: LD_INT 29
20486: PUSH
20487: LD_INT 30
20489: PUSH
20490: LD_INT 31
20492: PUSH
20493: LD_INT 37
20495: PUSH
20496: LD_INT 38
20498: PUSH
20499: LD_INT 32
20501: PUSH
20502: LD_INT 27
20504: PUSH
20505: LD_INT 33
20507: PUSH
20508: LD_INT 69
20510: PUSH
20511: LD_INT 39
20513: PUSH
20514: LD_INT 34
20516: PUSH
20517: LD_INT 40
20519: PUSH
20520: LD_INT 71
20522: PUSH
20523: LD_INT 23
20525: PUSH
20526: LD_INT 44
20528: PUSH
20529: LD_INT 48
20531: PUSH
20532: LD_INT 49
20534: PUSH
20535: LD_INT 50
20537: PUSH
20538: LD_INT 51
20540: PUSH
20541: LD_INT 52
20543: PUSH
20544: LD_INT 53
20546: PUSH
20547: LD_INT 54
20549: PUSH
20550: LD_INT 55
20552: PUSH
20553: LD_INT 56
20555: PUSH
20556: LD_INT 57
20558: PUSH
20559: LD_INT 58
20561: PUSH
20562: LD_INT 59
20564: PUSH
20565: LD_INT 63
20567: PUSH
20568: LD_INT 64
20570: PUSH
20571: LD_INT 65
20573: PUSH
20574: LD_INT 82
20576: PUSH
20577: LD_INT 83
20579: PUSH
20580: LD_INT 84
20582: PUSH
20583: LD_INT 85
20585: PUSH
20586: LD_INT 86
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: LIST
20596: LIST
20597: LIST
20598: LIST
20599: LIST
20600: LIST
20601: LIST
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: ST_TO_ADDR
20644: GO 20647
20646: POP
// if state > - 1 and state < 3 then
20647: LD_VAR 0 3
20651: PUSH
20652: LD_INT 1
20654: NEG
20655: GREATER
20656: PUSH
20657: LD_VAR 0 3
20661: PUSH
20662: LD_INT 3
20664: LESS
20665: AND
20666: IFFALSE 20723
// for i in result do
20668: LD_ADDR_VAR 0 5
20672: PUSH
20673: LD_VAR 0 4
20677: PUSH
20678: FOR_IN
20679: IFFALSE 20721
// if GetTech ( i , side ) <> state then
20681: LD_VAR 0 5
20685: PPUSH
20686: LD_VAR 0 1
20690: PPUSH
20691: CALL_OW 321
20695: PUSH
20696: LD_VAR 0 3
20700: NONEQUAL
20701: IFFALSE 20719
// result := result diff i ;
20703: LD_ADDR_VAR 0 4
20707: PUSH
20708: LD_VAR 0 4
20712: PUSH
20713: LD_VAR 0 5
20717: DIFF
20718: ST_TO_ADDR
20719: GO 20678
20721: POP
20722: POP
// end ;
20723: LD_VAR 0 4
20727: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20728: LD_INT 0
20730: PPUSH
20731: PPUSH
20732: PPUSH
// result := true ;
20733: LD_ADDR_VAR 0 3
20737: PUSH
20738: LD_INT 1
20740: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20741: LD_ADDR_VAR 0 5
20745: PUSH
20746: LD_VAR 0 2
20750: PPUSH
20751: CALL_OW 480
20755: ST_TO_ADDR
// if not tmp then
20756: LD_VAR 0 5
20760: NOT
20761: IFFALSE 20765
// exit ;
20763: GO 20814
// for i in tmp do
20765: LD_ADDR_VAR 0 4
20769: PUSH
20770: LD_VAR 0 5
20774: PUSH
20775: FOR_IN
20776: IFFALSE 20812
// if GetTech ( i , side ) <> state_researched then
20778: LD_VAR 0 4
20782: PPUSH
20783: LD_VAR 0 1
20787: PPUSH
20788: CALL_OW 321
20792: PUSH
20793: LD_INT 2
20795: NONEQUAL
20796: IFFALSE 20810
// begin result := false ;
20798: LD_ADDR_VAR 0 3
20802: PUSH
20803: LD_INT 0
20805: ST_TO_ADDR
// exit ;
20806: POP
20807: POP
20808: GO 20814
// end ;
20810: GO 20775
20812: POP
20813: POP
// end ;
20814: LD_VAR 0 3
20818: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20819: LD_INT 0
20821: PPUSH
20822: PPUSH
20823: PPUSH
20824: PPUSH
20825: PPUSH
20826: PPUSH
20827: PPUSH
20828: PPUSH
20829: PPUSH
20830: PPUSH
20831: PPUSH
20832: PPUSH
20833: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20834: LD_VAR 0 1
20838: NOT
20839: PUSH
20840: LD_VAR 0 1
20844: PPUSH
20845: CALL_OW 257
20849: PUSH
20850: LD_INT 9
20852: NONEQUAL
20853: OR
20854: IFFALSE 20858
// exit ;
20856: GO 21431
// side := GetSide ( unit ) ;
20858: LD_ADDR_VAR 0 9
20862: PUSH
20863: LD_VAR 0 1
20867: PPUSH
20868: CALL_OW 255
20872: ST_TO_ADDR
// tech_space := tech_spacanom ;
20873: LD_ADDR_VAR 0 12
20877: PUSH
20878: LD_INT 29
20880: ST_TO_ADDR
// tech_time := tech_taurad ;
20881: LD_ADDR_VAR 0 13
20885: PUSH
20886: LD_INT 28
20888: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20889: LD_ADDR_VAR 0 11
20893: PUSH
20894: LD_VAR 0 1
20898: PPUSH
20899: CALL_OW 310
20903: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20904: LD_VAR 0 11
20908: PPUSH
20909: CALL_OW 247
20913: PUSH
20914: LD_INT 2
20916: EQUAL
20917: IFFALSE 20921
// exit ;
20919: GO 21431
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20921: LD_ADDR_VAR 0 8
20925: PUSH
20926: LD_INT 81
20928: PUSH
20929: LD_VAR 0 9
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: PUSH
20938: LD_INT 3
20940: PUSH
20941: LD_INT 21
20943: PUSH
20944: LD_INT 3
20946: PUSH
20947: EMPTY
20948: LIST
20949: LIST
20950: PUSH
20951: EMPTY
20952: LIST
20953: LIST
20954: PUSH
20955: EMPTY
20956: LIST
20957: LIST
20958: PPUSH
20959: CALL_OW 69
20963: ST_TO_ADDR
// if not tmp then
20964: LD_VAR 0 8
20968: NOT
20969: IFFALSE 20973
// exit ;
20971: GO 21431
// if in_unit then
20973: LD_VAR 0 11
20977: IFFALSE 21001
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20979: LD_ADDR_VAR 0 10
20983: PUSH
20984: LD_VAR 0 8
20988: PPUSH
20989: LD_VAR 0 11
20993: PPUSH
20994: CALL_OW 74
20998: ST_TO_ADDR
20999: GO 21021
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21001: LD_ADDR_VAR 0 10
21005: PUSH
21006: LD_VAR 0 8
21010: PPUSH
21011: LD_VAR 0 1
21015: PPUSH
21016: CALL_OW 74
21020: ST_TO_ADDR
// if not enemy then
21021: LD_VAR 0 10
21025: NOT
21026: IFFALSE 21030
// exit ;
21028: GO 21431
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21030: LD_VAR 0 11
21034: PUSH
21035: LD_VAR 0 11
21039: PPUSH
21040: LD_VAR 0 10
21044: PPUSH
21045: CALL_OW 296
21049: PUSH
21050: LD_INT 13
21052: GREATER
21053: AND
21054: PUSH
21055: LD_VAR 0 1
21059: PPUSH
21060: LD_VAR 0 10
21064: PPUSH
21065: CALL_OW 296
21069: PUSH
21070: LD_INT 12
21072: GREATER
21073: OR
21074: IFFALSE 21078
// exit ;
21076: GO 21431
// missile := [ 1 ] ;
21078: LD_ADDR_VAR 0 14
21082: PUSH
21083: LD_INT 1
21085: PUSH
21086: EMPTY
21087: LIST
21088: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21089: LD_VAR 0 9
21093: PPUSH
21094: LD_VAR 0 12
21098: PPUSH
21099: CALL_OW 325
21103: IFFALSE 21132
// missile := Insert ( missile , missile + 1 , 2 ) ;
21105: LD_ADDR_VAR 0 14
21109: PUSH
21110: LD_VAR 0 14
21114: PPUSH
21115: LD_VAR 0 14
21119: PUSH
21120: LD_INT 1
21122: PLUS
21123: PPUSH
21124: LD_INT 2
21126: PPUSH
21127: CALL_OW 2
21131: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21132: LD_VAR 0 9
21136: PPUSH
21137: LD_VAR 0 13
21141: PPUSH
21142: CALL_OW 325
21146: PUSH
21147: LD_VAR 0 10
21151: PPUSH
21152: CALL_OW 255
21156: PPUSH
21157: LD_VAR 0 13
21161: PPUSH
21162: CALL_OW 325
21166: NOT
21167: AND
21168: IFFALSE 21197
// missile := Insert ( missile , missile + 1 , 3 ) ;
21170: LD_ADDR_VAR 0 14
21174: PUSH
21175: LD_VAR 0 14
21179: PPUSH
21180: LD_VAR 0 14
21184: PUSH
21185: LD_INT 1
21187: PLUS
21188: PPUSH
21189: LD_INT 3
21191: PPUSH
21192: CALL_OW 2
21196: ST_TO_ADDR
// if missile < 2 then
21197: LD_VAR 0 14
21201: PUSH
21202: LD_INT 2
21204: LESS
21205: IFFALSE 21209
// exit ;
21207: GO 21431
// x := GetX ( enemy ) ;
21209: LD_ADDR_VAR 0 4
21213: PUSH
21214: LD_VAR 0 10
21218: PPUSH
21219: CALL_OW 250
21223: ST_TO_ADDR
// y := GetY ( enemy ) ;
21224: LD_ADDR_VAR 0 5
21228: PUSH
21229: LD_VAR 0 10
21233: PPUSH
21234: CALL_OW 251
21238: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21239: LD_ADDR_VAR 0 6
21243: PUSH
21244: LD_VAR 0 4
21248: PUSH
21249: LD_INT 1
21251: NEG
21252: PPUSH
21253: LD_INT 1
21255: PPUSH
21256: CALL_OW 12
21260: PLUS
21261: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21262: LD_ADDR_VAR 0 7
21266: PUSH
21267: LD_VAR 0 5
21271: PUSH
21272: LD_INT 1
21274: NEG
21275: PPUSH
21276: LD_INT 1
21278: PPUSH
21279: CALL_OW 12
21283: PLUS
21284: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21285: LD_VAR 0 6
21289: PPUSH
21290: LD_VAR 0 7
21294: PPUSH
21295: CALL_OW 488
21299: NOT
21300: IFFALSE 21322
// begin _x := x ;
21302: LD_ADDR_VAR 0 6
21306: PUSH
21307: LD_VAR 0 4
21311: ST_TO_ADDR
// _y := y ;
21312: LD_ADDR_VAR 0 7
21316: PUSH
21317: LD_VAR 0 5
21321: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21322: LD_ADDR_VAR 0 3
21326: PUSH
21327: LD_INT 1
21329: PPUSH
21330: LD_VAR 0 14
21334: PPUSH
21335: CALL_OW 12
21339: ST_TO_ADDR
// case i of 1 :
21340: LD_VAR 0 3
21344: PUSH
21345: LD_INT 1
21347: DOUBLE
21348: EQUAL
21349: IFTRUE 21353
21351: GO 21370
21353: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21354: LD_VAR 0 1
21358: PPUSH
21359: LD_VAR 0 10
21363: PPUSH
21364: CALL_OW 115
21368: GO 21431
21370: LD_INT 2
21372: DOUBLE
21373: EQUAL
21374: IFTRUE 21378
21376: GO 21400
21378: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21379: LD_VAR 0 1
21383: PPUSH
21384: LD_VAR 0 6
21388: PPUSH
21389: LD_VAR 0 7
21393: PPUSH
21394: CALL_OW 153
21398: GO 21431
21400: LD_INT 3
21402: DOUBLE
21403: EQUAL
21404: IFTRUE 21408
21406: GO 21430
21408: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21409: LD_VAR 0 1
21413: PPUSH
21414: LD_VAR 0 6
21418: PPUSH
21419: LD_VAR 0 7
21423: PPUSH
21424: CALL_OW 154
21428: GO 21431
21430: POP
// end ;
21431: LD_VAR 0 2
21435: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21436: LD_INT 0
21438: PPUSH
21439: PPUSH
21440: PPUSH
21441: PPUSH
21442: PPUSH
21443: PPUSH
// if not unit or not building then
21444: LD_VAR 0 1
21448: NOT
21449: PUSH
21450: LD_VAR 0 2
21454: NOT
21455: OR
21456: IFFALSE 21460
// exit ;
21458: GO 21618
// x := GetX ( building ) ;
21460: LD_ADDR_VAR 0 5
21464: PUSH
21465: LD_VAR 0 2
21469: PPUSH
21470: CALL_OW 250
21474: ST_TO_ADDR
// y := GetY ( building ) ;
21475: LD_ADDR_VAR 0 6
21479: PUSH
21480: LD_VAR 0 2
21484: PPUSH
21485: CALL_OW 251
21489: ST_TO_ADDR
// for i = 0 to 5 do
21490: LD_ADDR_VAR 0 4
21494: PUSH
21495: DOUBLE
21496: LD_INT 0
21498: DEC
21499: ST_TO_ADDR
21500: LD_INT 5
21502: PUSH
21503: FOR_TO
21504: IFFALSE 21616
// begin _x := ShiftX ( x , i , 3 ) ;
21506: LD_ADDR_VAR 0 7
21510: PUSH
21511: LD_VAR 0 5
21515: PPUSH
21516: LD_VAR 0 4
21520: PPUSH
21521: LD_INT 3
21523: PPUSH
21524: CALL_OW 272
21528: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21529: LD_ADDR_VAR 0 8
21533: PUSH
21534: LD_VAR 0 6
21538: PPUSH
21539: LD_VAR 0 4
21543: PPUSH
21544: LD_INT 3
21546: PPUSH
21547: CALL_OW 273
21551: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21552: LD_VAR 0 7
21556: PPUSH
21557: LD_VAR 0 8
21561: PPUSH
21562: CALL_OW 488
21566: NOT
21567: IFFALSE 21571
// continue ;
21569: GO 21503
// if HexInfo ( _x , _y ) = 0 then
21571: LD_VAR 0 7
21575: PPUSH
21576: LD_VAR 0 8
21580: PPUSH
21581: CALL_OW 428
21585: PUSH
21586: LD_INT 0
21588: EQUAL
21589: IFFALSE 21614
// begin ComMoveXY ( unit , _x , _y ) ;
21591: LD_VAR 0 1
21595: PPUSH
21596: LD_VAR 0 7
21600: PPUSH
21601: LD_VAR 0 8
21605: PPUSH
21606: CALL_OW 111
// exit ;
21610: POP
21611: POP
21612: GO 21618
// end ; end ;
21614: GO 21503
21616: POP
21617: POP
// end ;
21618: LD_VAR 0 3
21622: RET
// export function ScanBase ( side , base_area ) ; begin
21623: LD_INT 0
21625: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21626: LD_ADDR_VAR 0 3
21630: PUSH
21631: LD_VAR 0 2
21635: PPUSH
21636: LD_INT 81
21638: PUSH
21639: LD_VAR 0 1
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: PPUSH
21648: CALL_OW 70
21652: ST_TO_ADDR
// end ;
21653: LD_VAR 0 3
21657: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21658: LD_INT 0
21660: PPUSH
21661: PPUSH
21662: PPUSH
21663: PPUSH
// result := false ;
21664: LD_ADDR_VAR 0 2
21668: PUSH
21669: LD_INT 0
21671: ST_TO_ADDR
// side := GetSide ( unit ) ;
21672: LD_ADDR_VAR 0 3
21676: PUSH
21677: LD_VAR 0 1
21681: PPUSH
21682: CALL_OW 255
21686: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21687: LD_ADDR_VAR 0 4
21691: PUSH
21692: LD_VAR 0 1
21696: PPUSH
21697: CALL_OW 248
21701: ST_TO_ADDR
// case nat of 1 :
21702: LD_VAR 0 4
21706: PUSH
21707: LD_INT 1
21709: DOUBLE
21710: EQUAL
21711: IFTRUE 21715
21713: GO 21726
21715: POP
// tech := tech_lassight ; 2 :
21716: LD_ADDR_VAR 0 5
21720: PUSH
21721: LD_INT 12
21723: ST_TO_ADDR
21724: GO 21765
21726: LD_INT 2
21728: DOUBLE
21729: EQUAL
21730: IFTRUE 21734
21732: GO 21745
21734: POP
// tech := tech_mortar ; 3 :
21735: LD_ADDR_VAR 0 5
21739: PUSH
21740: LD_INT 41
21742: ST_TO_ADDR
21743: GO 21765
21745: LD_INT 3
21747: DOUBLE
21748: EQUAL
21749: IFTRUE 21753
21751: GO 21764
21753: POP
// tech := tech_bazooka ; end ;
21754: LD_ADDR_VAR 0 5
21758: PUSH
21759: LD_INT 44
21761: ST_TO_ADDR
21762: GO 21765
21764: POP
// if Researched ( side , tech ) then
21765: LD_VAR 0 3
21769: PPUSH
21770: LD_VAR 0 5
21774: PPUSH
21775: CALL_OW 325
21779: IFFALSE 21806
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21781: LD_ADDR_VAR 0 2
21785: PUSH
21786: LD_INT 5
21788: PUSH
21789: LD_INT 8
21791: PUSH
21792: LD_INT 9
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: LIST
21799: PUSH
21800: LD_VAR 0 4
21804: ARRAY
21805: ST_TO_ADDR
// end ;
21806: LD_VAR 0 2
21810: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21811: LD_INT 0
21813: PPUSH
21814: PPUSH
21815: PPUSH
// if not mines then
21816: LD_VAR 0 2
21820: NOT
21821: IFFALSE 21825
// exit ;
21823: GO 21969
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21825: LD_ADDR_VAR 0 5
21829: PUSH
21830: LD_INT 81
21832: PUSH
21833: LD_VAR 0 1
21837: PUSH
21838: EMPTY
21839: LIST
21840: LIST
21841: PUSH
21842: LD_INT 3
21844: PUSH
21845: LD_INT 21
21847: PUSH
21848: LD_INT 3
21850: PUSH
21851: EMPTY
21852: LIST
21853: LIST
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: PPUSH
21863: CALL_OW 69
21867: ST_TO_ADDR
// for i in mines do
21868: LD_ADDR_VAR 0 4
21872: PUSH
21873: LD_VAR 0 2
21877: PUSH
21878: FOR_IN
21879: IFFALSE 21967
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21881: LD_VAR 0 4
21885: PUSH
21886: LD_INT 1
21888: ARRAY
21889: PPUSH
21890: LD_VAR 0 4
21894: PUSH
21895: LD_INT 2
21897: ARRAY
21898: PPUSH
21899: CALL_OW 458
21903: NOT
21904: IFFALSE 21908
// continue ;
21906: GO 21878
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21908: LD_VAR 0 4
21912: PUSH
21913: LD_INT 1
21915: ARRAY
21916: PPUSH
21917: LD_VAR 0 4
21921: PUSH
21922: LD_INT 2
21924: ARRAY
21925: PPUSH
21926: CALL_OW 428
21930: PUSH
21931: LD_VAR 0 5
21935: IN
21936: IFFALSE 21965
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21938: LD_VAR 0 4
21942: PUSH
21943: LD_INT 1
21945: ARRAY
21946: PPUSH
21947: LD_VAR 0 4
21951: PUSH
21952: LD_INT 2
21954: ARRAY
21955: PPUSH
21956: LD_VAR 0 1
21960: PPUSH
21961: CALL_OW 456
// end ;
21965: GO 21878
21967: POP
21968: POP
// end ;
21969: LD_VAR 0 3
21973: RET
// export function Count ( array ) ; var i ; begin
21974: LD_INT 0
21976: PPUSH
21977: PPUSH
// result := 0 ;
21978: LD_ADDR_VAR 0 2
21982: PUSH
21983: LD_INT 0
21985: ST_TO_ADDR
// for i in array do
21986: LD_ADDR_VAR 0 3
21990: PUSH
21991: LD_VAR 0 1
21995: PUSH
21996: FOR_IN
21997: IFFALSE 22021
// if i then
21999: LD_VAR 0 3
22003: IFFALSE 22019
// result := result + 1 ;
22005: LD_ADDR_VAR 0 2
22009: PUSH
22010: LD_VAR 0 2
22014: PUSH
22015: LD_INT 1
22017: PLUS
22018: ST_TO_ADDR
22019: GO 21996
22021: POP
22022: POP
// end ;
22023: LD_VAR 0 2
22027: RET
// export function IsEmpty ( building ) ; begin
22028: LD_INT 0
22030: PPUSH
// if not building then
22031: LD_VAR 0 1
22035: NOT
22036: IFFALSE 22040
// exit ;
22038: GO 22083
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22040: LD_ADDR_VAR 0 2
22044: PUSH
22045: LD_VAR 0 1
22049: PUSH
22050: LD_INT 22
22052: PUSH
22053: LD_VAR 0 1
22057: PPUSH
22058: CALL_OW 255
22062: PUSH
22063: EMPTY
22064: LIST
22065: LIST
22066: PUSH
22067: LD_INT 58
22069: PUSH
22070: EMPTY
22071: LIST
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PPUSH
22077: CALL_OW 69
22081: IN
22082: ST_TO_ADDR
// end ;
22083: LD_VAR 0 2
22087: RET
// export function IsNotFull ( building ) ; begin
22088: LD_INT 0
22090: PPUSH
// if not building then
22091: LD_VAR 0 1
22095: NOT
22096: IFFALSE 22100
// exit ;
22098: GO 22119
// result := UnitsInside ( building ) < 6 ;
22100: LD_ADDR_VAR 0 2
22104: PUSH
22105: LD_VAR 0 1
22109: PPUSH
22110: CALL_OW 313
22114: PUSH
22115: LD_INT 6
22117: LESS
22118: ST_TO_ADDR
// end ;
22119: LD_VAR 0 2
22123: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22124: LD_INT 0
22126: PPUSH
22127: PPUSH
22128: PPUSH
22129: PPUSH
// tmp := [ ] ;
22130: LD_ADDR_VAR 0 3
22134: PUSH
22135: EMPTY
22136: ST_TO_ADDR
// list := [ ] ;
22137: LD_ADDR_VAR 0 5
22141: PUSH
22142: EMPTY
22143: ST_TO_ADDR
// for i = 16 to 25 do
22144: LD_ADDR_VAR 0 4
22148: PUSH
22149: DOUBLE
22150: LD_INT 16
22152: DEC
22153: ST_TO_ADDR
22154: LD_INT 25
22156: PUSH
22157: FOR_TO
22158: IFFALSE 22231
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22160: LD_ADDR_VAR 0 3
22164: PUSH
22165: LD_VAR 0 3
22169: PUSH
22170: LD_INT 22
22172: PUSH
22173: LD_VAR 0 1
22177: PPUSH
22178: CALL_OW 255
22182: PUSH
22183: EMPTY
22184: LIST
22185: LIST
22186: PUSH
22187: LD_INT 91
22189: PUSH
22190: LD_VAR 0 1
22194: PUSH
22195: LD_INT 6
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: LIST
22202: PUSH
22203: LD_INT 30
22205: PUSH
22206: LD_VAR 0 4
22210: PUSH
22211: EMPTY
22212: LIST
22213: LIST
22214: PUSH
22215: EMPTY
22216: LIST
22217: LIST
22218: LIST
22219: PUSH
22220: EMPTY
22221: LIST
22222: PPUSH
22223: CALL_OW 69
22227: ADD
22228: ST_TO_ADDR
22229: GO 22157
22231: POP
22232: POP
// for i = 1 to tmp do
22233: LD_ADDR_VAR 0 4
22237: PUSH
22238: DOUBLE
22239: LD_INT 1
22241: DEC
22242: ST_TO_ADDR
22243: LD_VAR 0 3
22247: PUSH
22248: FOR_TO
22249: IFFALSE 22337
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22251: LD_ADDR_VAR 0 5
22255: PUSH
22256: LD_VAR 0 5
22260: PUSH
22261: LD_VAR 0 3
22265: PUSH
22266: LD_VAR 0 4
22270: ARRAY
22271: PPUSH
22272: CALL_OW 266
22276: PUSH
22277: LD_VAR 0 3
22281: PUSH
22282: LD_VAR 0 4
22286: ARRAY
22287: PPUSH
22288: CALL_OW 250
22292: PUSH
22293: LD_VAR 0 3
22297: PUSH
22298: LD_VAR 0 4
22302: ARRAY
22303: PPUSH
22304: CALL_OW 251
22308: PUSH
22309: LD_VAR 0 3
22313: PUSH
22314: LD_VAR 0 4
22318: ARRAY
22319: PPUSH
22320: CALL_OW 254
22324: PUSH
22325: EMPTY
22326: LIST
22327: LIST
22328: LIST
22329: LIST
22330: PUSH
22331: EMPTY
22332: LIST
22333: ADD
22334: ST_TO_ADDR
22335: GO 22248
22337: POP
22338: POP
// result := list ;
22339: LD_ADDR_VAR 0 2
22343: PUSH
22344: LD_VAR 0 5
22348: ST_TO_ADDR
// end ;
22349: LD_VAR 0 2
22353: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22354: LD_INT 0
22356: PPUSH
22357: PPUSH
22358: PPUSH
22359: PPUSH
22360: PPUSH
22361: PPUSH
22362: PPUSH
// if not factory then
22363: LD_VAR 0 1
22367: NOT
22368: IFFALSE 22372
// exit ;
22370: GO 22965
// if control = control_apeman then
22372: LD_VAR 0 4
22376: PUSH
22377: LD_INT 5
22379: EQUAL
22380: IFFALSE 22489
// begin tmp := UnitsInside ( factory ) ;
22382: LD_ADDR_VAR 0 8
22386: PUSH
22387: LD_VAR 0 1
22391: PPUSH
22392: CALL_OW 313
22396: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22397: LD_VAR 0 8
22401: PPUSH
22402: LD_INT 25
22404: PUSH
22405: LD_INT 12
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: PPUSH
22412: CALL_OW 72
22416: NOT
22417: IFFALSE 22427
// control := control_manual ;
22419: LD_ADDR_VAR 0 4
22423: PUSH
22424: LD_INT 1
22426: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22427: LD_ADDR_VAR 0 8
22431: PUSH
22432: LD_VAR 0 1
22436: PPUSH
22437: CALL 22124 0 1
22441: ST_TO_ADDR
// if tmp then
22442: LD_VAR 0 8
22446: IFFALSE 22489
// begin for i in tmp do
22448: LD_ADDR_VAR 0 7
22452: PUSH
22453: LD_VAR 0 8
22457: PUSH
22458: FOR_IN
22459: IFFALSE 22487
// if i [ 1 ] = b_ext_radio then
22461: LD_VAR 0 7
22465: PUSH
22466: LD_INT 1
22468: ARRAY
22469: PUSH
22470: LD_INT 22
22472: EQUAL
22473: IFFALSE 22485
// begin control := control_remote ;
22475: LD_ADDR_VAR 0 4
22479: PUSH
22480: LD_INT 2
22482: ST_TO_ADDR
// break ;
22483: GO 22487
// end ;
22485: GO 22458
22487: POP
22488: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22489: LD_VAR 0 1
22493: PPUSH
22494: LD_VAR 0 2
22498: PPUSH
22499: LD_VAR 0 3
22503: PPUSH
22504: LD_VAR 0 4
22508: PPUSH
22509: LD_VAR 0 5
22513: PPUSH
22514: CALL_OW 448
22518: IFFALSE 22553
// begin result := [ chassis , engine , control , weapon ] ;
22520: LD_ADDR_VAR 0 6
22524: PUSH
22525: LD_VAR 0 2
22529: PUSH
22530: LD_VAR 0 3
22534: PUSH
22535: LD_VAR 0 4
22539: PUSH
22540: LD_VAR 0 5
22544: PUSH
22545: EMPTY
22546: LIST
22547: LIST
22548: LIST
22549: LIST
22550: ST_TO_ADDR
// exit ;
22551: GO 22965
// end ; _chassis := AvailableChassisList ( factory ) ;
22553: LD_ADDR_VAR 0 9
22557: PUSH
22558: LD_VAR 0 1
22562: PPUSH
22563: CALL_OW 475
22567: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22568: LD_ADDR_VAR 0 11
22572: PUSH
22573: LD_VAR 0 1
22577: PPUSH
22578: CALL_OW 476
22582: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22583: LD_ADDR_VAR 0 12
22587: PUSH
22588: LD_VAR 0 1
22592: PPUSH
22593: CALL_OW 477
22597: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22598: LD_ADDR_VAR 0 10
22602: PUSH
22603: LD_VAR 0 1
22607: PPUSH
22608: CALL_OW 478
22612: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22613: LD_VAR 0 9
22617: NOT
22618: PUSH
22619: LD_VAR 0 11
22623: NOT
22624: OR
22625: PUSH
22626: LD_VAR 0 12
22630: NOT
22631: OR
22632: PUSH
22633: LD_VAR 0 10
22637: NOT
22638: OR
22639: IFFALSE 22674
// begin result := [ chassis , engine , control , weapon ] ;
22641: LD_ADDR_VAR 0 6
22645: PUSH
22646: LD_VAR 0 2
22650: PUSH
22651: LD_VAR 0 3
22655: PUSH
22656: LD_VAR 0 4
22660: PUSH
22661: LD_VAR 0 5
22665: PUSH
22666: EMPTY
22667: LIST
22668: LIST
22669: LIST
22670: LIST
22671: ST_TO_ADDR
// exit ;
22672: GO 22965
// end ; if not chassis in _chassis then
22674: LD_VAR 0 2
22678: PUSH
22679: LD_VAR 0 9
22683: IN
22684: NOT
22685: IFFALSE 22711
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22687: LD_ADDR_VAR 0 2
22691: PUSH
22692: LD_VAR 0 9
22696: PUSH
22697: LD_INT 1
22699: PPUSH
22700: LD_VAR 0 9
22704: PPUSH
22705: CALL_OW 12
22709: ARRAY
22710: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22711: LD_VAR 0 2
22715: PPUSH
22716: LD_VAR 0 3
22720: PPUSH
22721: CALL 22970 0 2
22725: NOT
22726: IFFALSE 22785
// repeat engine := _engine [ 1 ] ;
22728: LD_ADDR_VAR 0 3
22732: PUSH
22733: LD_VAR 0 11
22737: PUSH
22738: LD_INT 1
22740: ARRAY
22741: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22742: LD_ADDR_VAR 0 11
22746: PUSH
22747: LD_VAR 0 11
22751: PPUSH
22752: LD_INT 1
22754: PPUSH
22755: CALL_OW 3
22759: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22760: LD_VAR 0 2
22764: PPUSH
22765: LD_VAR 0 3
22769: PPUSH
22770: CALL 22970 0 2
22774: PUSH
22775: LD_VAR 0 11
22779: PUSH
22780: EMPTY
22781: EQUAL
22782: OR
22783: IFFALSE 22728
// if not control in _control then
22785: LD_VAR 0 4
22789: PUSH
22790: LD_VAR 0 12
22794: IN
22795: NOT
22796: IFFALSE 22822
// control := _control [ rand ( 1 , _control ) ] ;
22798: LD_ADDR_VAR 0 4
22802: PUSH
22803: LD_VAR 0 12
22807: PUSH
22808: LD_INT 1
22810: PPUSH
22811: LD_VAR 0 12
22815: PPUSH
22816: CALL_OW 12
22820: ARRAY
22821: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22822: LD_VAR 0 2
22826: PPUSH
22827: LD_VAR 0 5
22831: PPUSH
22832: CALL 23190 0 2
22836: NOT
22837: IFFALSE 22896
// repeat weapon := _weapon [ 1 ] ;
22839: LD_ADDR_VAR 0 5
22843: PUSH
22844: LD_VAR 0 10
22848: PUSH
22849: LD_INT 1
22851: ARRAY
22852: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22853: LD_ADDR_VAR 0 10
22857: PUSH
22858: LD_VAR 0 10
22862: PPUSH
22863: LD_INT 1
22865: PPUSH
22866: CALL_OW 3
22870: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22871: LD_VAR 0 2
22875: PPUSH
22876: LD_VAR 0 5
22880: PPUSH
22881: CALL 23190 0 2
22885: PUSH
22886: LD_VAR 0 10
22890: PUSH
22891: EMPTY
22892: EQUAL
22893: OR
22894: IFFALSE 22839
// result := [ ] ;
22896: LD_ADDR_VAR 0 6
22900: PUSH
22901: EMPTY
22902: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22903: LD_VAR 0 1
22907: PPUSH
22908: LD_VAR 0 2
22912: PPUSH
22913: LD_VAR 0 3
22917: PPUSH
22918: LD_VAR 0 4
22922: PPUSH
22923: LD_VAR 0 5
22927: PPUSH
22928: CALL_OW 448
22932: IFFALSE 22965
// result := [ chassis , engine , control , weapon ] ;
22934: LD_ADDR_VAR 0 6
22938: PUSH
22939: LD_VAR 0 2
22943: PUSH
22944: LD_VAR 0 3
22948: PUSH
22949: LD_VAR 0 4
22953: PUSH
22954: LD_VAR 0 5
22958: PUSH
22959: EMPTY
22960: LIST
22961: LIST
22962: LIST
22963: LIST
22964: ST_TO_ADDR
// end ;
22965: LD_VAR 0 6
22969: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22970: LD_INT 0
22972: PPUSH
// if not chassis or not engine then
22973: LD_VAR 0 1
22977: NOT
22978: PUSH
22979: LD_VAR 0 2
22983: NOT
22984: OR
22985: IFFALSE 22989
// exit ;
22987: GO 23185
// case engine of engine_solar :
22989: LD_VAR 0 2
22993: PUSH
22994: LD_INT 2
22996: DOUBLE
22997: EQUAL
22998: IFTRUE 23002
23000: GO 23040
23002: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
23003: LD_ADDR_VAR 0 3
23007: PUSH
23008: LD_INT 11
23010: PUSH
23011: LD_INT 12
23013: PUSH
23014: LD_INT 13
23016: PUSH
23017: LD_INT 14
23019: PUSH
23020: LD_INT 1
23022: PUSH
23023: LD_INT 2
23025: PUSH
23026: LD_INT 3
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: LIST
23033: LIST
23034: LIST
23035: LIST
23036: LIST
23037: ST_TO_ADDR
23038: GO 23169
23040: LD_INT 1
23042: DOUBLE
23043: EQUAL
23044: IFTRUE 23048
23046: GO 23110
23048: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23049: LD_ADDR_VAR 0 3
23053: PUSH
23054: LD_INT 11
23056: PUSH
23057: LD_INT 12
23059: PUSH
23060: LD_INT 13
23062: PUSH
23063: LD_INT 14
23065: PUSH
23066: LD_INT 1
23068: PUSH
23069: LD_INT 2
23071: PUSH
23072: LD_INT 3
23074: PUSH
23075: LD_INT 4
23077: PUSH
23078: LD_INT 5
23080: PUSH
23081: LD_INT 21
23083: PUSH
23084: LD_INT 23
23086: PUSH
23087: LD_INT 22
23089: PUSH
23090: LD_INT 24
23092: PUSH
23093: EMPTY
23094: LIST
23095: LIST
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: LIST
23107: ST_TO_ADDR
23108: GO 23169
23110: LD_INT 3
23112: DOUBLE
23113: EQUAL
23114: IFTRUE 23118
23116: GO 23168
23118: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23119: LD_ADDR_VAR 0 3
23123: PUSH
23124: LD_INT 13
23126: PUSH
23127: LD_INT 14
23129: PUSH
23130: LD_INT 2
23132: PUSH
23133: LD_INT 3
23135: PUSH
23136: LD_INT 4
23138: PUSH
23139: LD_INT 5
23141: PUSH
23142: LD_INT 21
23144: PUSH
23145: LD_INT 22
23147: PUSH
23148: LD_INT 23
23150: PUSH
23151: LD_INT 24
23153: PUSH
23154: EMPTY
23155: LIST
23156: LIST
23157: LIST
23158: LIST
23159: LIST
23160: LIST
23161: LIST
23162: LIST
23163: LIST
23164: LIST
23165: ST_TO_ADDR
23166: GO 23169
23168: POP
// result := ( chassis in result ) ;
23169: LD_ADDR_VAR 0 3
23173: PUSH
23174: LD_VAR 0 1
23178: PUSH
23179: LD_VAR 0 3
23183: IN
23184: ST_TO_ADDR
// end ;
23185: LD_VAR 0 3
23189: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23190: LD_INT 0
23192: PPUSH
// if not chassis or not weapon then
23193: LD_VAR 0 1
23197: NOT
23198: PUSH
23199: LD_VAR 0 2
23203: NOT
23204: OR
23205: IFFALSE 23209
// exit ;
23207: GO 24271
// case weapon of us_machine_gun :
23209: LD_VAR 0 2
23213: PUSH
23214: LD_INT 2
23216: DOUBLE
23217: EQUAL
23218: IFTRUE 23222
23220: GO 23252
23222: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23223: LD_ADDR_VAR 0 3
23227: PUSH
23228: LD_INT 1
23230: PUSH
23231: LD_INT 2
23233: PUSH
23234: LD_INT 3
23236: PUSH
23237: LD_INT 4
23239: PUSH
23240: LD_INT 5
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: LIST
23247: LIST
23248: LIST
23249: ST_TO_ADDR
23250: GO 24255
23252: LD_INT 3
23254: DOUBLE
23255: EQUAL
23256: IFTRUE 23260
23258: GO 23290
23260: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23261: LD_ADDR_VAR 0 3
23265: PUSH
23266: LD_INT 1
23268: PUSH
23269: LD_INT 2
23271: PUSH
23272: LD_INT 3
23274: PUSH
23275: LD_INT 4
23277: PUSH
23278: LD_INT 5
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: LIST
23285: LIST
23286: LIST
23287: ST_TO_ADDR
23288: GO 24255
23290: LD_INT 11
23292: DOUBLE
23293: EQUAL
23294: IFTRUE 23298
23296: GO 23328
23298: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23299: LD_ADDR_VAR 0 3
23303: PUSH
23304: LD_INT 1
23306: PUSH
23307: LD_INT 2
23309: PUSH
23310: LD_INT 3
23312: PUSH
23313: LD_INT 4
23315: PUSH
23316: LD_INT 5
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: ST_TO_ADDR
23326: GO 24255
23328: LD_INT 4
23330: DOUBLE
23331: EQUAL
23332: IFTRUE 23336
23334: GO 23362
23336: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23337: LD_ADDR_VAR 0 3
23341: PUSH
23342: LD_INT 2
23344: PUSH
23345: LD_INT 3
23347: PUSH
23348: LD_INT 4
23350: PUSH
23351: LD_INT 5
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: LIST
23358: LIST
23359: ST_TO_ADDR
23360: GO 24255
23362: LD_INT 5
23364: DOUBLE
23365: EQUAL
23366: IFTRUE 23370
23368: GO 23396
23370: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23371: LD_ADDR_VAR 0 3
23375: PUSH
23376: LD_INT 2
23378: PUSH
23379: LD_INT 3
23381: PUSH
23382: LD_INT 4
23384: PUSH
23385: LD_INT 5
23387: PUSH
23388: EMPTY
23389: LIST
23390: LIST
23391: LIST
23392: LIST
23393: ST_TO_ADDR
23394: GO 24255
23396: LD_INT 9
23398: DOUBLE
23399: EQUAL
23400: IFTRUE 23404
23402: GO 23430
23404: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23405: LD_ADDR_VAR 0 3
23409: PUSH
23410: LD_INT 2
23412: PUSH
23413: LD_INT 3
23415: PUSH
23416: LD_INT 4
23418: PUSH
23419: LD_INT 5
23421: PUSH
23422: EMPTY
23423: LIST
23424: LIST
23425: LIST
23426: LIST
23427: ST_TO_ADDR
23428: GO 24255
23430: LD_INT 7
23432: DOUBLE
23433: EQUAL
23434: IFTRUE 23438
23436: GO 23464
23438: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23439: LD_ADDR_VAR 0 3
23443: PUSH
23444: LD_INT 2
23446: PUSH
23447: LD_INT 3
23449: PUSH
23450: LD_INT 4
23452: PUSH
23453: LD_INT 5
23455: PUSH
23456: EMPTY
23457: LIST
23458: LIST
23459: LIST
23460: LIST
23461: ST_TO_ADDR
23462: GO 24255
23464: LD_INT 12
23466: DOUBLE
23467: EQUAL
23468: IFTRUE 23472
23470: GO 23498
23472: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23473: LD_ADDR_VAR 0 3
23477: PUSH
23478: LD_INT 2
23480: PUSH
23481: LD_INT 3
23483: PUSH
23484: LD_INT 4
23486: PUSH
23487: LD_INT 5
23489: PUSH
23490: EMPTY
23491: LIST
23492: LIST
23493: LIST
23494: LIST
23495: ST_TO_ADDR
23496: GO 24255
23498: LD_INT 13
23500: DOUBLE
23501: EQUAL
23502: IFTRUE 23506
23504: GO 23532
23506: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23507: LD_ADDR_VAR 0 3
23511: PUSH
23512: LD_INT 2
23514: PUSH
23515: LD_INT 3
23517: PUSH
23518: LD_INT 4
23520: PUSH
23521: LD_INT 5
23523: PUSH
23524: EMPTY
23525: LIST
23526: LIST
23527: LIST
23528: LIST
23529: ST_TO_ADDR
23530: GO 24255
23532: LD_INT 14
23534: DOUBLE
23535: EQUAL
23536: IFTRUE 23540
23538: GO 23558
23540: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23541: LD_ADDR_VAR 0 3
23545: PUSH
23546: LD_INT 4
23548: PUSH
23549: LD_INT 5
23551: PUSH
23552: EMPTY
23553: LIST
23554: LIST
23555: ST_TO_ADDR
23556: GO 24255
23558: LD_INT 6
23560: DOUBLE
23561: EQUAL
23562: IFTRUE 23566
23564: GO 23584
23566: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23567: LD_ADDR_VAR 0 3
23571: PUSH
23572: LD_INT 4
23574: PUSH
23575: LD_INT 5
23577: PUSH
23578: EMPTY
23579: LIST
23580: LIST
23581: ST_TO_ADDR
23582: GO 24255
23584: LD_INT 10
23586: DOUBLE
23587: EQUAL
23588: IFTRUE 23592
23590: GO 23610
23592: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23593: LD_ADDR_VAR 0 3
23597: PUSH
23598: LD_INT 4
23600: PUSH
23601: LD_INT 5
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: ST_TO_ADDR
23608: GO 24255
23610: LD_INT 22
23612: DOUBLE
23613: EQUAL
23614: IFTRUE 23618
23616: GO 23644
23618: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23619: LD_ADDR_VAR 0 3
23623: PUSH
23624: LD_INT 11
23626: PUSH
23627: LD_INT 12
23629: PUSH
23630: LD_INT 13
23632: PUSH
23633: LD_INT 14
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: LIST
23640: LIST
23641: ST_TO_ADDR
23642: GO 24255
23644: LD_INT 23
23646: DOUBLE
23647: EQUAL
23648: IFTRUE 23652
23650: GO 23678
23652: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23653: LD_ADDR_VAR 0 3
23657: PUSH
23658: LD_INT 11
23660: PUSH
23661: LD_INT 12
23663: PUSH
23664: LD_INT 13
23666: PUSH
23667: LD_INT 14
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: ST_TO_ADDR
23676: GO 24255
23678: LD_INT 24
23680: DOUBLE
23681: EQUAL
23682: IFTRUE 23686
23684: GO 23712
23686: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23687: LD_ADDR_VAR 0 3
23691: PUSH
23692: LD_INT 11
23694: PUSH
23695: LD_INT 12
23697: PUSH
23698: LD_INT 13
23700: PUSH
23701: LD_INT 14
23703: PUSH
23704: EMPTY
23705: LIST
23706: LIST
23707: LIST
23708: LIST
23709: ST_TO_ADDR
23710: GO 24255
23712: LD_INT 30
23714: DOUBLE
23715: EQUAL
23716: IFTRUE 23720
23718: GO 23746
23720: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23721: LD_ADDR_VAR 0 3
23725: PUSH
23726: LD_INT 11
23728: PUSH
23729: LD_INT 12
23731: PUSH
23732: LD_INT 13
23734: PUSH
23735: LD_INT 14
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: LIST
23742: LIST
23743: ST_TO_ADDR
23744: GO 24255
23746: LD_INT 25
23748: DOUBLE
23749: EQUAL
23750: IFTRUE 23754
23752: GO 23772
23754: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23755: LD_ADDR_VAR 0 3
23759: PUSH
23760: LD_INT 13
23762: PUSH
23763: LD_INT 14
23765: PUSH
23766: EMPTY
23767: LIST
23768: LIST
23769: ST_TO_ADDR
23770: GO 24255
23772: LD_INT 27
23774: DOUBLE
23775: EQUAL
23776: IFTRUE 23780
23778: GO 23798
23780: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23781: LD_ADDR_VAR 0 3
23785: PUSH
23786: LD_INT 13
23788: PUSH
23789: LD_INT 14
23791: PUSH
23792: EMPTY
23793: LIST
23794: LIST
23795: ST_TO_ADDR
23796: GO 24255
23798: LD_EXP 34
23802: DOUBLE
23803: EQUAL
23804: IFTRUE 23808
23806: GO 23834
23808: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23809: LD_ADDR_VAR 0 3
23813: PUSH
23814: LD_INT 11
23816: PUSH
23817: LD_INT 12
23819: PUSH
23820: LD_INT 13
23822: PUSH
23823: LD_INT 14
23825: PUSH
23826: EMPTY
23827: LIST
23828: LIST
23829: LIST
23830: LIST
23831: ST_TO_ADDR
23832: GO 24255
23834: LD_INT 28
23836: DOUBLE
23837: EQUAL
23838: IFTRUE 23842
23840: GO 23860
23842: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23843: LD_ADDR_VAR 0 3
23847: PUSH
23848: LD_INT 13
23850: PUSH
23851: LD_INT 14
23853: PUSH
23854: EMPTY
23855: LIST
23856: LIST
23857: ST_TO_ADDR
23858: GO 24255
23860: LD_INT 29
23862: DOUBLE
23863: EQUAL
23864: IFTRUE 23868
23866: GO 23886
23868: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23869: LD_ADDR_VAR 0 3
23873: PUSH
23874: LD_INT 13
23876: PUSH
23877: LD_INT 14
23879: PUSH
23880: EMPTY
23881: LIST
23882: LIST
23883: ST_TO_ADDR
23884: GO 24255
23886: LD_INT 31
23888: DOUBLE
23889: EQUAL
23890: IFTRUE 23894
23892: GO 23912
23894: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23895: LD_ADDR_VAR 0 3
23899: PUSH
23900: LD_INT 13
23902: PUSH
23903: LD_INT 14
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: ST_TO_ADDR
23910: GO 24255
23912: LD_INT 26
23914: DOUBLE
23915: EQUAL
23916: IFTRUE 23920
23918: GO 23938
23920: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23921: LD_ADDR_VAR 0 3
23925: PUSH
23926: LD_INT 13
23928: PUSH
23929: LD_INT 14
23931: PUSH
23932: EMPTY
23933: LIST
23934: LIST
23935: ST_TO_ADDR
23936: GO 24255
23938: LD_INT 42
23940: DOUBLE
23941: EQUAL
23942: IFTRUE 23946
23944: GO 23972
23946: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23947: LD_ADDR_VAR 0 3
23951: PUSH
23952: LD_INT 21
23954: PUSH
23955: LD_INT 22
23957: PUSH
23958: LD_INT 23
23960: PUSH
23961: LD_INT 24
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: LIST
23968: LIST
23969: ST_TO_ADDR
23970: GO 24255
23972: LD_INT 43
23974: DOUBLE
23975: EQUAL
23976: IFTRUE 23980
23978: GO 24006
23980: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23981: LD_ADDR_VAR 0 3
23985: PUSH
23986: LD_INT 21
23988: PUSH
23989: LD_INT 22
23991: PUSH
23992: LD_INT 23
23994: PUSH
23995: LD_INT 24
23997: PUSH
23998: EMPTY
23999: LIST
24000: LIST
24001: LIST
24002: LIST
24003: ST_TO_ADDR
24004: GO 24255
24006: LD_INT 44
24008: DOUBLE
24009: EQUAL
24010: IFTRUE 24014
24012: GO 24040
24014: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24015: LD_ADDR_VAR 0 3
24019: PUSH
24020: LD_INT 21
24022: PUSH
24023: LD_INT 22
24025: PUSH
24026: LD_INT 23
24028: PUSH
24029: LD_INT 24
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: LIST
24036: LIST
24037: ST_TO_ADDR
24038: GO 24255
24040: LD_INT 45
24042: DOUBLE
24043: EQUAL
24044: IFTRUE 24048
24046: GO 24074
24048: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24049: LD_ADDR_VAR 0 3
24053: PUSH
24054: LD_INT 21
24056: PUSH
24057: LD_INT 22
24059: PUSH
24060: LD_INT 23
24062: PUSH
24063: LD_INT 24
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: LIST
24070: LIST
24071: ST_TO_ADDR
24072: GO 24255
24074: LD_INT 49
24076: DOUBLE
24077: EQUAL
24078: IFTRUE 24082
24080: GO 24108
24082: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24083: LD_ADDR_VAR 0 3
24087: PUSH
24088: LD_INT 21
24090: PUSH
24091: LD_INT 22
24093: PUSH
24094: LD_INT 23
24096: PUSH
24097: LD_INT 24
24099: PUSH
24100: EMPTY
24101: LIST
24102: LIST
24103: LIST
24104: LIST
24105: ST_TO_ADDR
24106: GO 24255
24108: LD_INT 51
24110: DOUBLE
24111: EQUAL
24112: IFTRUE 24116
24114: GO 24142
24116: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24117: LD_ADDR_VAR 0 3
24121: PUSH
24122: LD_INT 21
24124: PUSH
24125: LD_INT 22
24127: PUSH
24128: LD_INT 23
24130: PUSH
24131: LD_INT 24
24133: PUSH
24134: EMPTY
24135: LIST
24136: LIST
24137: LIST
24138: LIST
24139: ST_TO_ADDR
24140: GO 24255
24142: LD_INT 52
24144: DOUBLE
24145: EQUAL
24146: IFTRUE 24150
24148: GO 24176
24150: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24151: LD_ADDR_VAR 0 3
24155: PUSH
24156: LD_INT 21
24158: PUSH
24159: LD_INT 22
24161: PUSH
24162: LD_INT 23
24164: PUSH
24165: LD_INT 24
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: LIST
24172: LIST
24173: ST_TO_ADDR
24174: GO 24255
24176: LD_INT 53
24178: DOUBLE
24179: EQUAL
24180: IFTRUE 24184
24182: GO 24202
24184: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24185: LD_ADDR_VAR 0 3
24189: PUSH
24190: LD_INT 23
24192: PUSH
24193: LD_INT 24
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: ST_TO_ADDR
24200: GO 24255
24202: LD_INT 46
24204: DOUBLE
24205: EQUAL
24206: IFTRUE 24210
24208: GO 24228
24210: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24211: LD_ADDR_VAR 0 3
24215: PUSH
24216: LD_INT 23
24218: PUSH
24219: LD_INT 24
24221: PUSH
24222: EMPTY
24223: LIST
24224: LIST
24225: ST_TO_ADDR
24226: GO 24255
24228: LD_INT 47
24230: DOUBLE
24231: EQUAL
24232: IFTRUE 24236
24234: GO 24254
24236: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24237: LD_ADDR_VAR 0 3
24241: PUSH
24242: LD_INT 23
24244: PUSH
24245: LD_INT 24
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: ST_TO_ADDR
24252: GO 24255
24254: POP
// result := ( chassis in result ) ;
24255: LD_ADDR_VAR 0 3
24259: PUSH
24260: LD_VAR 0 1
24264: PUSH
24265: LD_VAR 0 3
24269: IN
24270: ST_TO_ADDR
// end ;
24271: LD_VAR 0 3
24275: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24276: LD_INT 0
24278: PPUSH
24279: PPUSH
24280: PPUSH
24281: PPUSH
24282: PPUSH
24283: PPUSH
24284: PPUSH
// result := array ;
24285: LD_ADDR_VAR 0 5
24289: PUSH
24290: LD_VAR 0 1
24294: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24295: LD_VAR 0 1
24299: NOT
24300: PUSH
24301: LD_VAR 0 2
24305: NOT
24306: OR
24307: PUSH
24308: LD_VAR 0 3
24312: NOT
24313: OR
24314: PUSH
24315: LD_VAR 0 2
24319: PUSH
24320: LD_VAR 0 1
24324: GREATER
24325: OR
24326: PUSH
24327: LD_VAR 0 3
24331: PUSH
24332: LD_VAR 0 1
24336: GREATER
24337: OR
24338: IFFALSE 24342
// exit ;
24340: GO 24638
// if direction then
24342: LD_VAR 0 4
24346: IFFALSE 24410
// begin d := 1 ;
24348: LD_ADDR_VAR 0 9
24352: PUSH
24353: LD_INT 1
24355: ST_TO_ADDR
// if i_from > i_to then
24356: LD_VAR 0 2
24360: PUSH
24361: LD_VAR 0 3
24365: GREATER
24366: IFFALSE 24392
// length := ( array - i_from ) + i_to else
24368: LD_ADDR_VAR 0 11
24372: PUSH
24373: LD_VAR 0 1
24377: PUSH
24378: LD_VAR 0 2
24382: MINUS
24383: PUSH
24384: LD_VAR 0 3
24388: PLUS
24389: ST_TO_ADDR
24390: GO 24408
// length := i_to - i_from ;
24392: LD_ADDR_VAR 0 11
24396: PUSH
24397: LD_VAR 0 3
24401: PUSH
24402: LD_VAR 0 2
24406: MINUS
24407: ST_TO_ADDR
// end else
24408: GO 24471
// begin d := - 1 ;
24410: LD_ADDR_VAR 0 9
24414: PUSH
24415: LD_INT 1
24417: NEG
24418: ST_TO_ADDR
// if i_from > i_to then
24419: LD_VAR 0 2
24423: PUSH
24424: LD_VAR 0 3
24428: GREATER
24429: IFFALSE 24449
// length := i_from - i_to else
24431: LD_ADDR_VAR 0 11
24435: PUSH
24436: LD_VAR 0 2
24440: PUSH
24441: LD_VAR 0 3
24445: MINUS
24446: ST_TO_ADDR
24447: GO 24471
// length := ( array - i_to ) + i_from ;
24449: LD_ADDR_VAR 0 11
24453: PUSH
24454: LD_VAR 0 1
24458: PUSH
24459: LD_VAR 0 3
24463: MINUS
24464: PUSH
24465: LD_VAR 0 2
24469: PLUS
24470: ST_TO_ADDR
// end ; if not length then
24471: LD_VAR 0 11
24475: NOT
24476: IFFALSE 24480
// exit ;
24478: GO 24638
// tmp := array ;
24480: LD_ADDR_VAR 0 10
24484: PUSH
24485: LD_VAR 0 1
24489: ST_TO_ADDR
// for i = 1 to length do
24490: LD_ADDR_VAR 0 6
24494: PUSH
24495: DOUBLE
24496: LD_INT 1
24498: DEC
24499: ST_TO_ADDR
24500: LD_VAR 0 11
24504: PUSH
24505: FOR_TO
24506: IFFALSE 24626
// begin for j = 1 to array do
24508: LD_ADDR_VAR 0 7
24512: PUSH
24513: DOUBLE
24514: LD_INT 1
24516: DEC
24517: ST_TO_ADDR
24518: LD_VAR 0 1
24522: PUSH
24523: FOR_TO
24524: IFFALSE 24612
// begin k := j + d ;
24526: LD_ADDR_VAR 0 8
24530: PUSH
24531: LD_VAR 0 7
24535: PUSH
24536: LD_VAR 0 9
24540: PLUS
24541: ST_TO_ADDR
// if k > array then
24542: LD_VAR 0 8
24546: PUSH
24547: LD_VAR 0 1
24551: GREATER
24552: IFFALSE 24562
// k := 1 ;
24554: LD_ADDR_VAR 0 8
24558: PUSH
24559: LD_INT 1
24561: ST_TO_ADDR
// if not k then
24562: LD_VAR 0 8
24566: NOT
24567: IFFALSE 24579
// k := array ;
24569: LD_ADDR_VAR 0 8
24573: PUSH
24574: LD_VAR 0 1
24578: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24579: LD_ADDR_VAR 0 10
24583: PUSH
24584: LD_VAR 0 10
24588: PPUSH
24589: LD_VAR 0 8
24593: PPUSH
24594: LD_VAR 0 1
24598: PUSH
24599: LD_VAR 0 7
24603: ARRAY
24604: PPUSH
24605: CALL_OW 1
24609: ST_TO_ADDR
// end ;
24610: GO 24523
24612: POP
24613: POP
// array := tmp ;
24614: LD_ADDR_VAR 0 1
24618: PUSH
24619: LD_VAR 0 10
24623: ST_TO_ADDR
// end ;
24624: GO 24505
24626: POP
24627: POP
// result := array ;
24628: LD_ADDR_VAR 0 5
24632: PUSH
24633: LD_VAR 0 1
24637: ST_TO_ADDR
// end ;
24638: LD_VAR 0 5
24642: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24643: LD_INT 0
24645: PPUSH
24646: PPUSH
// result := 0 ;
24647: LD_ADDR_VAR 0 3
24651: PUSH
24652: LD_INT 0
24654: ST_TO_ADDR
// if not array or not value in array then
24655: LD_VAR 0 1
24659: NOT
24660: PUSH
24661: LD_VAR 0 2
24665: PUSH
24666: LD_VAR 0 1
24670: IN
24671: NOT
24672: OR
24673: IFFALSE 24677
// exit ;
24675: GO 24731
// for i = 1 to array do
24677: LD_ADDR_VAR 0 4
24681: PUSH
24682: DOUBLE
24683: LD_INT 1
24685: DEC
24686: ST_TO_ADDR
24687: LD_VAR 0 1
24691: PUSH
24692: FOR_TO
24693: IFFALSE 24729
// if value = array [ i ] then
24695: LD_VAR 0 2
24699: PUSH
24700: LD_VAR 0 1
24704: PUSH
24705: LD_VAR 0 4
24709: ARRAY
24710: EQUAL
24711: IFFALSE 24727
// begin result := i ;
24713: LD_ADDR_VAR 0 3
24717: PUSH
24718: LD_VAR 0 4
24722: ST_TO_ADDR
// exit ;
24723: POP
24724: POP
24725: GO 24731
// end ;
24727: GO 24692
24729: POP
24730: POP
// end ;
24731: LD_VAR 0 3
24735: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24736: LD_INT 0
24738: PPUSH
// vc_chassis := chassis ;
24739: LD_ADDR_OWVAR 37
24743: PUSH
24744: LD_VAR 0 1
24748: ST_TO_ADDR
// vc_engine := engine ;
24749: LD_ADDR_OWVAR 39
24753: PUSH
24754: LD_VAR 0 2
24758: ST_TO_ADDR
// vc_control := control ;
24759: LD_ADDR_OWVAR 38
24763: PUSH
24764: LD_VAR 0 3
24768: ST_TO_ADDR
// vc_weapon := weapon ;
24769: LD_ADDR_OWVAR 40
24773: PUSH
24774: LD_VAR 0 4
24778: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24779: LD_ADDR_OWVAR 41
24783: PUSH
24784: LD_VAR 0 5
24788: ST_TO_ADDR
// end ;
24789: LD_VAR 0 6
24793: RET
// export function WantPlant ( unit ) ; var task ; begin
24794: LD_INT 0
24796: PPUSH
24797: PPUSH
// result := false ;
24798: LD_ADDR_VAR 0 2
24802: PUSH
24803: LD_INT 0
24805: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24806: LD_ADDR_VAR 0 3
24810: PUSH
24811: LD_VAR 0 1
24815: PPUSH
24816: CALL_OW 437
24820: ST_TO_ADDR
// if task then
24821: LD_VAR 0 3
24825: IFFALSE 24853
// if task [ 1 ] [ 1 ] = p then
24827: LD_VAR 0 3
24831: PUSH
24832: LD_INT 1
24834: ARRAY
24835: PUSH
24836: LD_INT 1
24838: ARRAY
24839: PUSH
24840: LD_STRING p
24842: EQUAL
24843: IFFALSE 24853
// result := true ;
24845: LD_ADDR_VAR 0 2
24849: PUSH
24850: LD_INT 1
24852: ST_TO_ADDR
// end ;
24853: LD_VAR 0 2
24857: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24858: LD_INT 0
24860: PPUSH
24861: PPUSH
24862: PPUSH
24863: PPUSH
// if pos < 1 then
24864: LD_VAR 0 2
24868: PUSH
24869: LD_INT 1
24871: LESS
24872: IFFALSE 24876
// exit ;
24874: GO 25179
// if pos = 1 then
24876: LD_VAR 0 2
24880: PUSH
24881: LD_INT 1
24883: EQUAL
24884: IFFALSE 24917
// result := Replace ( arr , pos [ 1 ] , value ) else
24886: LD_ADDR_VAR 0 4
24890: PUSH
24891: LD_VAR 0 1
24895: PPUSH
24896: LD_VAR 0 2
24900: PUSH
24901: LD_INT 1
24903: ARRAY
24904: PPUSH
24905: LD_VAR 0 3
24909: PPUSH
24910: CALL_OW 1
24914: ST_TO_ADDR
24915: GO 25179
// begin tmp := arr ;
24917: LD_ADDR_VAR 0 6
24921: PUSH
24922: LD_VAR 0 1
24926: ST_TO_ADDR
// s_arr := [ tmp ] ;
24927: LD_ADDR_VAR 0 7
24931: PUSH
24932: LD_VAR 0 6
24936: PUSH
24937: EMPTY
24938: LIST
24939: ST_TO_ADDR
// for i = 1 to pos - 1 do
24940: LD_ADDR_VAR 0 5
24944: PUSH
24945: DOUBLE
24946: LD_INT 1
24948: DEC
24949: ST_TO_ADDR
24950: LD_VAR 0 2
24954: PUSH
24955: LD_INT 1
24957: MINUS
24958: PUSH
24959: FOR_TO
24960: IFFALSE 25005
// begin tmp := tmp [ pos [ i ] ] ;
24962: LD_ADDR_VAR 0 6
24966: PUSH
24967: LD_VAR 0 6
24971: PUSH
24972: LD_VAR 0 2
24976: PUSH
24977: LD_VAR 0 5
24981: ARRAY
24982: ARRAY
24983: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24984: LD_ADDR_VAR 0 7
24988: PUSH
24989: LD_VAR 0 7
24993: PUSH
24994: LD_VAR 0 6
24998: PUSH
24999: EMPTY
25000: LIST
25001: ADD
25002: ST_TO_ADDR
// end ;
25003: GO 24959
25005: POP
25006: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
25007: LD_ADDR_VAR 0 6
25011: PUSH
25012: LD_VAR 0 6
25016: PPUSH
25017: LD_VAR 0 2
25021: PUSH
25022: LD_VAR 0 2
25026: ARRAY
25027: PPUSH
25028: LD_VAR 0 3
25032: PPUSH
25033: CALL_OW 1
25037: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25038: LD_ADDR_VAR 0 7
25042: PUSH
25043: LD_VAR 0 7
25047: PPUSH
25048: LD_VAR 0 7
25052: PPUSH
25053: LD_VAR 0 6
25057: PPUSH
25058: CALL_OW 1
25062: ST_TO_ADDR
// for i = s_arr downto 2 do
25063: LD_ADDR_VAR 0 5
25067: PUSH
25068: DOUBLE
25069: LD_VAR 0 7
25073: INC
25074: ST_TO_ADDR
25075: LD_INT 2
25077: PUSH
25078: FOR_DOWNTO
25079: IFFALSE 25163
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25081: LD_ADDR_VAR 0 6
25085: PUSH
25086: LD_VAR 0 7
25090: PUSH
25091: LD_VAR 0 5
25095: PUSH
25096: LD_INT 1
25098: MINUS
25099: ARRAY
25100: PPUSH
25101: LD_VAR 0 2
25105: PUSH
25106: LD_VAR 0 5
25110: PUSH
25111: LD_INT 1
25113: MINUS
25114: ARRAY
25115: PPUSH
25116: LD_VAR 0 7
25120: PUSH
25121: LD_VAR 0 5
25125: ARRAY
25126: PPUSH
25127: CALL_OW 1
25131: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25132: LD_ADDR_VAR 0 7
25136: PUSH
25137: LD_VAR 0 7
25141: PPUSH
25142: LD_VAR 0 5
25146: PUSH
25147: LD_INT 1
25149: MINUS
25150: PPUSH
25151: LD_VAR 0 6
25155: PPUSH
25156: CALL_OW 1
25160: ST_TO_ADDR
// end ;
25161: GO 25078
25163: POP
25164: POP
// result := s_arr [ 1 ] ;
25165: LD_ADDR_VAR 0 4
25169: PUSH
25170: LD_VAR 0 7
25174: PUSH
25175: LD_INT 1
25177: ARRAY
25178: ST_TO_ADDR
// end ; end ;
25179: LD_VAR 0 4
25183: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25184: LD_INT 0
25186: PPUSH
25187: PPUSH
// if not list then
25188: LD_VAR 0 1
25192: NOT
25193: IFFALSE 25197
// exit ;
25195: GO 25288
// i := list [ pos1 ] ;
25197: LD_ADDR_VAR 0 5
25201: PUSH
25202: LD_VAR 0 1
25206: PUSH
25207: LD_VAR 0 2
25211: ARRAY
25212: ST_TO_ADDR
// if not i then
25213: LD_VAR 0 5
25217: NOT
25218: IFFALSE 25222
// exit ;
25220: GO 25288
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25222: LD_ADDR_VAR 0 1
25226: PUSH
25227: LD_VAR 0 1
25231: PPUSH
25232: LD_VAR 0 2
25236: PPUSH
25237: LD_VAR 0 1
25241: PUSH
25242: LD_VAR 0 3
25246: ARRAY
25247: PPUSH
25248: CALL_OW 1
25252: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25253: LD_ADDR_VAR 0 1
25257: PUSH
25258: LD_VAR 0 1
25262: PPUSH
25263: LD_VAR 0 3
25267: PPUSH
25268: LD_VAR 0 5
25272: PPUSH
25273: CALL_OW 1
25277: ST_TO_ADDR
// result := list ;
25278: LD_ADDR_VAR 0 4
25282: PUSH
25283: LD_VAR 0 1
25287: ST_TO_ADDR
// end ;
25288: LD_VAR 0 4
25292: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25293: LD_INT 0
25295: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25296: LD_ADDR_VAR 0 5
25300: PUSH
25301: LD_VAR 0 1
25305: PPUSH
25306: CALL_OW 250
25310: PPUSH
25311: LD_VAR 0 1
25315: PPUSH
25316: CALL_OW 251
25320: PPUSH
25321: LD_VAR 0 2
25325: PPUSH
25326: LD_VAR 0 3
25330: PPUSH
25331: LD_VAR 0 4
25335: PPUSH
25336: CALL 25346 0 5
25340: ST_TO_ADDR
// end ;
25341: LD_VAR 0 5
25345: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25346: LD_INT 0
25348: PPUSH
25349: PPUSH
25350: PPUSH
25351: PPUSH
// if not list then
25352: LD_VAR 0 3
25356: NOT
25357: IFFALSE 25361
// exit ;
25359: GO 25749
// result := [ ] ;
25361: LD_ADDR_VAR 0 6
25365: PUSH
25366: EMPTY
25367: ST_TO_ADDR
// for i in list do
25368: LD_ADDR_VAR 0 7
25372: PUSH
25373: LD_VAR 0 3
25377: PUSH
25378: FOR_IN
25379: IFFALSE 25581
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25381: LD_ADDR_VAR 0 9
25385: PUSH
25386: LD_VAR 0 7
25390: PPUSH
25391: LD_VAR 0 1
25395: PPUSH
25396: LD_VAR 0 2
25400: PPUSH
25401: CALL_OW 297
25405: ST_TO_ADDR
// if not result then
25406: LD_VAR 0 6
25410: NOT
25411: IFFALSE 25437
// result := [ [ i , tmp ] ] else
25413: LD_ADDR_VAR 0 6
25417: PUSH
25418: LD_VAR 0 7
25422: PUSH
25423: LD_VAR 0 9
25427: PUSH
25428: EMPTY
25429: LIST
25430: LIST
25431: PUSH
25432: EMPTY
25433: LIST
25434: ST_TO_ADDR
25435: GO 25579
// begin if result [ result ] [ 2 ] < tmp then
25437: LD_VAR 0 6
25441: PUSH
25442: LD_VAR 0 6
25446: ARRAY
25447: PUSH
25448: LD_INT 2
25450: ARRAY
25451: PUSH
25452: LD_VAR 0 9
25456: LESS
25457: IFFALSE 25499
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25459: LD_ADDR_VAR 0 6
25463: PUSH
25464: LD_VAR 0 6
25468: PPUSH
25469: LD_VAR 0 6
25473: PUSH
25474: LD_INT 1
25476: PLUS
25477: PPUSH
25478: LD_VAR 0 7
25482: PUSH
25483: LD_VAR 0 9
25487: PUSH
25488: EMPTY
25489: LIST
25490: LIST
25491: PPUSH
25492: CALL_OW 2
25496: ST_TO_ADDR
25497: GO 25579
// for j = 1 to result do
25499: LD_ADDR_VAR 0 8
25503: PUSH
25504: DOUBLE
25505: LD_INT 1
25507: DEC
25508: ST_TO_ADDR
25509: LD_VAR 0 6
25513: PUSH
25514: FOR_TO
25515: IFFALSE 25577
// begin if tmp < result [ j ] [ 2 ] then
25517: LD_VAR 0 9
25521: PUSH
25522: LD_VAR 0 6
25526: PUSH
25527: LD_VAR 0 8
25531: ARRAY
25532: PUSH
25533: LD_INT 2
25535: ARRAY
25536: LESS
25537: IFFALSE 25575
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25539: LD_ADDR_VAR 0 6
25543: PUSH
25544: LD_VAR 0 6
25548: PPUSH
25549: LD_VAR 0 8
25553: PPUSH
25554: LD_VAR 0 7
25558: PUSH
25559: LD_VAR 0 9
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PPUSH
25568: CALL_OW 2
25572: ST_TO_ADDR
// break ;
25573: GO 25577
// end ; end ;
25575: GO 25514
25577: POP
25578: POP
// end ; end ;
25579: GO 25378
25581: POP
25582: POP
// if result and not asc then
25583: LD_VAR 0 6
25587: PUSH
25588: LD_VAR 0 4
25592: NOT
25593: AND
25594: IFFALSE 25669
// begin tmp := result ;
25596: LD_ADDR_VAR 0 9
25600: PUSH
25601: LD_VAR 0 6
25605: ST_TO_ADDR
// for i = tmp downto 1 do
25606: LD_ADDR_VAR 0 7
25610: PUSH
25611: DOUBLE
25612: LD_VAR 0 9
25616: INC
25617: ST_TO_ADDR
25618: LD_INT 1
25620: PUSH
25621: FOR_DOWNTO
25622: IFFALSE 25667
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25624: LD_ADDR_VAR 0 6
25628: PUSH
25629: LD_VAR 0 6
25633: PPUSH
25634: LD_VAR 0 9
25638: PUSH
25639: LD_VAR 0 7
25643: MINUS
25644: PUSH
25645: LD_INT 1
25647: PLUS
25648: PPUSH
25649: LD_VAR 0 9
25653: PUSH
25654: LD_VAR 0 7
25658: ARRAY
25659: PPUSH
25660: CALL_OW 1
25664: ST_TO_ADDR
25665: GO 25621
25667: POP
25668: POP
// end ; tmp := [ ] ;
25669: LD_ADDR_VAR 0 9
25673: PUSH
25674: EMPTY
25675: ST_TO_ADDR
// if mode then
25676: LD_VAR 0 5
25680: IFFALSE 25749
// begin for i = 1 to result do
25682: LD_ADDR_VAR 0 7
25686: PUSH
25687: DOUBLE
25688: LD_INT 1
25690: DEC
25691: ST_TO_ADDR
25692: LD_VAR 0 6
25696: PUSH
25697: FOR_TO
25698: IFFALSE 25737
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25700: LD_ADDR_VAR 0 9
25704: PUSH
25705: LD_VAR 0 9
25709: PPUSH
25710: LD_VAR 0 7
25714: PPUSH
25715: LD_VAR 0 6
25719: PUSH
25720: LD_VAR 0 7
25724: ARRAY
25725: PUSH
25726: LD_INT 1
25728: ARRAY
25729: PPUSH
25730: CALL_OW 1
25734: ST_TO_ADDR
25735: GO 25697
25737: POP
25738: POP
// result := tmp ;
25739: LD_ADDR_VAR 0 6
25743: PUSH
25744: LD_VAR 0 9
25748: ST_TO_ADDR
// end ; end ;
25749: LD_VAR 0 6
25753: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25754: LD_INT 0
25756: PPUSH
25757: PPUSH
25758: PPUSH
25759: PPUSH
25760: PPUSH
25761: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25762: LD_ADDR_VAR 0 5
25766: PUSH
25767: LD_INT 0
25769: PUSH
25770: LD_INT 0
25772: PUSH
25773: LD_INT 0
25775: PUSH
25776: EMPTY
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: LIST
25782: LIST
25783: ST_TO_ADDR
// if not x or not y then
25784: LD_VAR 0 2
25788: NOT
25789: PUSH
25790: LD_VAR 0 3
25794: NOT
25795: OR
25796: IFFALSE 25800
// exit ;
25798: GO 27452
// if not range then
25800: LD_VAR 0 4
25804: NOT
25805: IFFALSE 25815
// range := 10 ;
25807: LD_ADDR_VAR 0 4
25811: PUSH
25812: LD_INT 10
25814: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25815: LD_ADDR_VAR 0 8
25819: PUSH
25820: LD_INT 81
25822: PUSH
25823: LD_VAR 0 1
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PUSH
25832: LD_INT 92
25834: PUSH
25835: LD_VAR 0 2
25839: PUSH
25840: LD_VAR 0 3
25844: PUSH
25845: LD_VAR 0 4
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: LIST
25854: LIST
25855: PUSH
25856: LD_INT 3
25858: PUSH
25859: LD_INT 21
25861: PUSH
25862: LD_INT 3
25864: PUSH
25865: EMPTY
25866: LIST
25867: LIST
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: LIST
25877: PPUSH
25878: CALL_OW 69
25882: ST_TO_ADDR
// if not tmp then
25883: LD_VAR 0 8
25887: NOT
25888: IFFALSE 25892
// exit ;
25890: GO 27452
// for i in tmp do
25892: LD_ADDR_VAR 0 6
25896: PUSH
25897: LD_VAR 0 8
25901: PUSH
25902: FOR_IN
25903: IFFALSE 27427
// begin points := [ 0 , 0 , 0 ] ;
25905: LD_ADDR_VAR 0 9
25909: PUSH
25910: LD_INT 0
25912: PUSH
25913: LD_INT 0
25915: PUSH
25916: LD_INT 0
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: LIST
25923: ST_TO_ADDR
// bpoints := 1 ;
25924: LD_ADDR_VAR 0 10
25928: PUSH
25929: LD_INT 1
25931: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25932: LD_VAR 0 6
25936: PPUSH
25937: CALL_OW 247
25941: PUSH
25942: LD_INT 1
25944: DOUBLE
25945: EQUAL
25946: IFTRUE 25950
25948: GO 26528
25950: POP
// begin if GetClass ( i ) = 1 then
25951: LD_VAR 0 6
25955: PPUSH
25956: CALL_OW 257
25960: PUSH
25961: LD_INT 1
25963: EQUAL
25964: IFFALSE 25985
// points := [ 10 , 5 , 3 ] ;
25966: LD_ADDR_VAR 0 9
25970: PUSH
25971: LD_INT 10
25973: PUSH
25974: LD_INT 5
25976: PUSH
25977: LD_INT 3
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: LIST
25984: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25985: LD_VAR 0 6
25989: PPUSH
25990: CALL_OW 257
25994: PUSH
25995: LD_INT 2
25997: PUSH
25998: LD_INT 3
26000: PUSH
26001: LD_INT 4
26003: PUSH
26004: EMPTY
26005: LIST
26006: LIST
26007: LIST
26008: IN
26009: IFFALSE 26030
// points := [ 3 , 2 , 1 ] ;
26011: LD_ADDR_VAR 0 9
26015: PUSH
26016: LD_INT 3
26018: PUSH
26019: LD_INT 2
26021: PUSH
26022: LD_INT 1
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: LIST
26029: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26030: LD_VAR 0 6
26034: PPUSH
26035: CALL_OW 257
26039: PUSH
26040: LD_INT 5
26042: EQUAL
26043: IFFALSE 26064
// points := [ 130 , 5 , 2 ] ;
26045: LD_ADDR_VAR 0 9
26049: PUSH
26050: LD_INT 130
26052: PUSH
26053: LD_INT 5
26055: PUSH
26056: LD_INT 2
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: LIST
26063: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26064: LD_VAR 0 6
26068: PPUSH
26069: CALL_OW 257
26073: PUSH
26074: LD_INT 8
26076: EQUAL
26077: IFFALSE 26098
// points := [ 35 , 35 , 30 ] ;
26079: LD_ADDR_VAR 0 9
26083: PUSH
26084: LD_INT 35
26086: PUSH
26087: LD_INT 35
26089: PUSH
26090: LD_INT 30
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: LIST
26097: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26098: LD_VAR 0 6
26102: PPUSH
26103: CALL_OW 257
26107: PUSH
26108: LD_INT 9
26110: EQUAL
26111: IFFALSE 26132
// points := [ 20 , 55 , 40 ] ;
26113: LD_ADDR_VAR 0 9
26117: PUSH
26118: LD_INT 20
26120: PUSH
26121: LD_INT 55
26123: PUSH
26124: LD_INT 40
26126: PUSH
26127: EMPTY
26128: LIST
26129: LIST
26130: LIST
26131: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26132: LD_VAR 0 6
26136: PPUSH
26137: CALL_OW 257
26141: PUSH
26142: LD_INT 12
26144: PUSH
26145: LD_INT 16
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: IN
26152: IFFALSE 26173
// points := [ 5 , 3 , 2 ] ;
26154: LD_ADDR_VAR 0 9
26158: PUSH
26159: LD_INT 5
26161: PUSH
26162: LD_INT 3
26164: PUSH
26165: LD_INT 2
26167: PUSH
26168: EMPTY
26169: LIST
26170: LIST
26171: LIST
26172: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26173: LD_VAR 0 6
26177: PPUSH
26178: CALL_OW 257
26182: PUSH
26183: LD_INT 17
26185: EQUAL
26186: IFFALSE 26207
// points := [ 100 , 50 , 75 ] ;
26188: LD_ADDR_VAR 0 9
26192: PUSH
26193: LD_INT 100
26195: PUSH
26196: LD_INT 50
26198: PUSH
26199: LD_INT 75
26201: PUSH
26202: EMPTY
26203: LIST
26204: LIST
26205: LIST
26206: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26207: LD_VAR 0 6
26211: PPUSH
26212: CALL_OW 257
26216: PUSH
26217: LD_INT 15
26219: EQUAL
26220: IFFALSE 26241
// points := [ 10 , 5 , 3 ] ;
26222: LD_ADDR_VAR 0 9
26226: PUSH
26227: LD_INT 10
26229: PUSH
26230: LD_INT 5
26232: PUSH
26233: LD_INT 3
26235: PUSH
26236: EMPTY
26237: LIST
26238: LIST
26239: LIST
26240: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26241: LD_VAR 0 6
26245: PPUSH
26246: CALL_OW 257
26250: PUSH
26251: LD_INT 14
26253: EQUAL
26254: IFFALSE 26275
// points := [ 10 , 0 , 0 ] ;
26256: LD_ADDR_VAR 0 9
26260: PUSH
26261: LD_INT 10
26263: PUSH
26264: LD_INT 0
26266: PUSH
26267: LD_INT 0
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: LIST
26274: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26275: LD_VAR 0 6
26279: PPUSH
26280: CALL_OW 257
26284: PUSH
26285: LD_INT 11
26287: EQUAL
26288: IFFALSE 26309
// points := [ 30 , 10 , 5 ] ;
26290: LD_ADDR_VAR 0 9
26294: PUSH
26295: LD_INT 30
26297: PUSH
26298: LD_INT 10
26300: PUSH
26301: LD_INT 5
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: LIST
26308: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26309: LD_VAR 0 1
26313: PPUSH
26314: LD_INT 5
26316: PPUSH
26317: CALL_OW 321
26321: PUSH
26322: LD_INT 2
26324: EQUAL
26325: IFFALSE 26342
// bpoints := bpoints * 1.8 ;
26327: LD_ADDR_VAR 0 10
26331: PUSH
26332: LD_VAR 0 10
26336: PUSH
26337: LD_REAL  1.80000000000000E+0000
26340: MUL
26341: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26342: LD_VAR 0 6
26346: PPUSH
26347: CALL_OW 257
26351: PUSH
26352: LD_INT 1
26354: PUSH
26355: LD_INT 2
26357: PUSH
26358: LD_INT 3
26360: PUSH
26361: LD_INT 4
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: LIST
26368: LIST
26369: IN
26370: PUSH
26371: LD_VAR 0 1
26375: PPUSH
26376: LD_INT 51
26378: PPUSH
26379: CALL_OW 321
26383: PUSH
26384: LD_INT 2
26386: EQUAL
26387: AND
26388: IFFALSE 26405
// bpoints := bpoints * 1.2 ;
26390: LD_ADDR_VAR 0 10
26394: PUSH
26395: LD_VAR 0 10
26399: PUSH
26400: LD_REAL  1.20000000000000E+0000
26403: MUL
26404: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26405: LD_VAR 0 6
26409: PPUSH
26410: CALL_OW 257
26414: PUSH
26415: LD_INT 5
26417: PUSH
26418: LD_INT 7
26420: PUSH
26421: LD_INT 9
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: LIST
26428: IN
26429: PUSH
26430: LD_VAR 0 1
26434: PPUSH
26435: LD_INT 52
26437: PPUSH
26438: CALL_OW 321
26442: PUSH
26443: LD_INT 2
26445: EQUAL
26446: AND
26447: IFFALSE 26464
// bpoints := bpoints * 1.5 ;
26449: LD_ADDR_VAR 0 10
26453: PUSH
26454: LD_VAR 0 10
26458: PUSH
26459: LD_REAL  1.50000000000000E+0000
26462: MUL
26463: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26464: LD_VAR 0 1
26468: PPUSH
26469: LD_INT 66
26471: PPUSH
26472: CALL_OW 321
26476: PUSH
26477: LD_INT 2
26479: EQUAL
26480: IFFALSE 26497
// bpoints := bpoints * 1.1 ;
26482: LD_ADDR_VAR 0 10
26486: PUSH
26487: LD_VAR 0 10
26491: PUSH
26492: LD_REAL  1.10000000000000E+0000
26495: MUL
26496: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26497: LD_ADDR_VAR 0 10
26501: PUSH
26502: LD_VAR 0 10
26506: PUSH
26507: LD_VAR 0 6
26511: PPUSH
26512: LD_INT 1
26514: PPUSH
26515: CALL_OW 259
26519: PUSH
26520: LD_REAL  1.15000000000000E+0000
26523: MUL
26524: MUL
26525: ST_TO_ADDR
// end ; unit_vehicle :
26526: GO 27356
26528: LD_INT 2
26530: DOUBLE
26531: EQUAL
26532: IFTRUE 26536
26534: GO 27344
26536: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26537: LD_VAR 0 6
26541: PPUSH
26542: CALL_OW 264
26546: PUSH
26547: LD_INT 2
26549: PUSH
26550: LD_INT 42
26552: PUSH
26553: LD_INT 24
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: LIST
26560: IN
26561: IFFALSE 26582
// points := [ 25 , 5 , 3 ] ;
26563: LD_ADDR_VAR 0 9
26567: PUSH
26568: LD_INT 25
26570: PUSH
26571: LD_INT 5
26573: PUSH
26574: LD_INT 3
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: LIST
26581: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26582: LD_VAR 0 6
26586: PPUSH
26587: CALL_OW 264
26591: PUSH
26592: LD_INT 4
26594: PUSH
26595: LD_INT 43
26597: PUSH
26598: LD_INT 25
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: LIST
26605: IN
26606: IFFALSE 26627
// points := [ 40 , 15 , 5 ] ;
26608: LD_ADDR_VAR 0 9
26612: PUSH
26613: LD_INT 40
26615: PUSH
26616: LD_INT 15
26618: PUSH
26619: LD_INT 5
26621: PUSH
26622: EMPTY
26623: LIST
26624: LIST
26625: LIST
26626: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26627: LD_VAR 0 6
26631: PPUSH
26632: CALL_OW 264
26636: PUSH
26637: LD_INT 3
26639: PUSH
26640: LD_INT 23
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: IN
26647: IFFALSE 26668
// points := [ 7 , 25 , 8 ] ;
26649: LD_ADDR_VAR 0 9
26653: PUSH
26654: LD_INT 7
26656: PUSH
26657: LD_INT 25
26659: PUSH
26660: LD_INT 8
26662: PUSH
26663: EMPTY
26664: LIST
26665: LIST
26666: LIST
26667: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26668: LD_VAR 0 6
26672: PPUSH
26673: CALL_OW 264
26677: PUSH
26678: LD_INT 5
26680: PUSH
26681: LD_INT 27
26683: PUSH
26684: LD_INT 44
26686: PUSH
26687: EMPTY
26688: LIST
26689: LIST
26690: LIST
26691: IN
26692: IFFALSE 26713
// points := [ 14 , 50 , 16 ] ;
26694: LD_ADDR_VAR 0 9
26698: PUSH
26699: LD_INT 14
26701: PUSH
26702: LD_INT 50
26704: PUSH
26705: LD_INT 16
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: LIST
26712: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26713: LD_VAR 0 6
26717: PPUSH
26718: CALL_OW 264
26722: PUSH
26723: LD_INT 6
26725: PUSH
26726: LD_INT 46
26728: PUSH
26729: EMPTY
26730: LIST
26731: LIST
26732: IN
26733: IFFALSE 26754
// points := [ 32 , 120 , 70 ] ;
26735: LD_ADDR_VAR 0 9
26739: PUSH
26740: LD_INT 32
26742: PUSH
26743: LD_INT 120
26745: PUSH
26746: LD_INT 70
26748: PUSH
26749: EMPTY
26750: LIST
26751: LIST
26752: LIST
26753: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26754: LD_VAR 0 6
26758: PPUSH
26759: CALL_OW 264
26763: PUSH
26764: LD_INT 7
26766: PUSH
26767: LD_INT 28
26769: PUSH
26770: LD_INT 45
26772: PUSH
26773: LD_EXP 34
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: LIST
26783: IN
26784: IFFALSE 26805
// points := [ 35 , 20 , 45 ] ;
26786: LD_ADDR_VAR 0 9
26790: PUSH
26791: LD_INT 35
26793: PUSH
26794: LD_INT 20
26796: PUSH
26797: LD_INT 45
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: LIST
26804: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26805: LD_VAR 0 6
26809: PPUSH
26810: CALL_OW 264
26814: PUSH
26815: LD_INT 47
26817: PUSH
26818: EMPTY
26819: LIST
26820: IN
26821: IFFALSE 26842
// points := [ 67 , 45 , 75 ] ;
26823: LD_ADDR_VAR 0 9
26827: PUSH
26828: LD_INT 67
26830: PUSH
26831: LD_INT 45
26833: PUSH
26834: LD_INT 75
26836: PUSH
26837: EMPTY
26838: LIST
26839: LIST
26840: LIST
26841: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26842: LD_VAR 0 6
26846: PPUSH
26847: CALL_OW 264
26851: PUSH
26852: LD_INT 26
26854: PUSH
26855: EMPTY
26856: LIST
26857: IN
26858: IFFALSE 26879
// points := [ 120 , 30 , 80 ] ;
26860: LD_ADDR_VAR 0 9
26864: PUSH
26865: LD_INT 120
26867: PUSH
26868: LD_INT 30
26870: PUSH
26871: LD_INT 80
26873: PUSH
26874: EMPTY
26875: LIST
26876: LIST
26877: LIST
26878: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26879: LD_VAR 0 6
26883: PPUSH
26884: CALL_OW 264
26888: PUSH
26889: LD_INT 22
26891: PUSH
26892: EMPTY
26893: LIST
26894: IN
26895: IFFALSE 26916
// points := [ 40 , 1 , 1 ] ;
26897: LD_ADDR_VAR 0 9
26901: PUSH
26902: LD_INT 40
26904: PUSH
26905: LD_INT 1
26907: PUSH
26908: LD_INT 1
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: LIST
26915: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26916: LD_VAR 0 6
26920: PPUSH
26921: CALL_OW 264
26925: PUSH
26926: LD_INT 29
26928: PUSH
26929: EMPTY
26930: LIST
26931: IN
26932: IFFALSE 26953
// points := [ 70 , 200 , 400 ] ;
26934: LD_ADDR_VAR 0 9
26938: PUSH
26939: LD_INT 70
26941: PUSH
26942: LD_INT 200
26944: PUSH
26945: LD_INT 400
26947: PUSH
26948: EMPTY
26949: LIST
26950: LIST
26951: LIST
26952: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26953: LD_VAR 0 6
26957: PPUSH
26958: CALL_OW 264
26962: PUSH
26963: LD_INT 14
26965: PUSH
26966: LD_INT 53
26968: PUSH
26969: EMPTY
26970: LIST
26971: LIST
26972: IN
26973: IFFALSE 26994
// points := [ 40 , 10 , 20 ] ;
26975: LD_ADDR_VAR 0 9
26979: PUSH
26980: LD_INT 40
26982: PUSH
26983: LD_INT 10
26985: PUSH
26986: LD_INT 20
26988: PUSH
26989: EMPTY
26990: LIST
26991: LIST
26992: LIST
26993: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26994: LD_VAR 0 6
26998: PPUSH
26999: CALL_OW 264
27003: PUSH
27004: LD_INT 9
27006: PUSH
27007: EMPTY
27008: LIST
27009: IN
27010: IFFALSE 27031
// points := [ 5 , 70 , 20 ] ;
27012: LD_ADDR_VAR 0 9
27016: PUSH
27017: LD_INT 5
27019: PUSH
27020: LD_INT 70
27022: PUSH
27023: LD_INT 20
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: LIST
27030: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27031: LD_VAR 0 6
27035: PPUSH
27036: CALL_OW 264
27040: PUSH
27041: LD_INT 10
27043: PUSH
27044: EMPTY
27045: LIST
27046: IN
27047: IFFALSE 27068
// points := [ 35 , 110 , 70 ] ;
27049: LD_ADDR_VAR 0 9
27053: PUSH
27054: LD_INT 35
27056: PUSH
27057: LD_INT 110
27059: PUSH
27060: LD_INT 70
27062: PUSH
27063: EMPTY
27064: LIST
27065: LIST
27066: LIST
27067: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27068: LD_VAR 0 6
27072: PPUSH
27073: CALL_OW 265
27077: PUSH
27078: LD_INT 25
27080: EQUAL
27081: IFFALSE 27102
// points := [ 80 , 65 , 100 ] ;
27083: LD_ADDR_VAR 0 9
27087: PUSH
27088: LD_INT 80
27090: PUSH
27091: LD_INT 65
27093: PUSH
27094: LD_INT 100
27096: PUSH
27097: EMPTY
27098: LIST
27099: LIST
27100: LIST
27101: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27102: LD_VAR 0 6
27106: PPUSH
27107: CALL_OW 263
27111: PUSH
27112: LD_INT 1
27114: EQUAL
27115: IFFALSE 27150
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27117: LD_ADDR_VAR 0 10
27121: PUSH
27122: LD_VAR 0 10
27126: PUSH
27127: LD_VAR 0 6
27131: PPUSH
27132: CALL_OW 311
27136: PPUSH
27137: LD_INT 3
27139: PPUSH
27140: CALL_OW 259
27144: PUSH
27145: LD_INT 4
27147: MUL
27148: MUL
27149: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27150: LD_VAR 0 6
27154: PPUSH
27155: CALL_OW 263
27159: PUSH
27160: LD_INT 2
27162: EQUAL
27163: IFFALSE 27214
// begin j := IsControledBy ( i ) ;
27165: LD_ADDR_VAR 0 7
27169: PUSH
27170: LD_VAR 0 6
27174: PPUSH
27175: CALL_OW 312
27179: ST_TO_ADDR
// if j then
27180: LD_VAR 0 7
27184: IFFALSE 27214
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27186: LD_ADDR_VAR 0 10
27190: PUSH
27191: LD_VAR 0 10
27195: PUSH
27196: LD_VAR 0 7
27200: PPUSH
27201: LD_INT 3
27203: PPUSH
27204: CALL_OW 259
27208: PUSH
27209: LD_INT 3
27211: MUL
27212: MUL
27213: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27214: LD_VAR 0 6
27218: PPUSH
27219: CALL_OW 264
27223: PUSH
27224: LD_INT 5
27226: PUSH
27227: LD_INT 6
27229: PUSH
27230: LD_INT 46
27232: PUSH
27233: LD_INT 44
27235: PUSH
27236: LD_INT 47
27238: PUSH
27239: LD_INT 45
27241: PUSH
27242: LD_INT 28
27244: PUSH
27245: LD_INT 7
27247: PUSH
27248: LD_INT 27
27250: PUSH
27251: LD_INT 29
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: LIST
27258: LIST
27259: LIST
27260: LIST
27261: LIST
27262: LIST
27263: LIST
27264: LIST
27265: IN
27266: PUSH
27267: LD_VAR 0 1
27271: PPUSH
27272: LD_INT 52
27274: PPUSH
27275: CALL_OW 321
27279: PUSH
27280: LD_INT 2
27282: EQUAL
27283: AND
27284: IFFALSE 27301
// bpoints := bpoints * 1.2 ;
27286: LD_ADDR_VAR 0 10
27290: PUSH
27291: LD_VAR 0 10
27295: PUSH
27296: LD_REAL  1.20000000000000E+0000
27299: MUL
27300: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27301: LD_VAR 0 6
27305: PPUSH
27306: CALL_OW 264
27310: PUSH
27311: LD_INT 6
27313: PUSH
27314: LD_INT 46
27316: PUSH
27317: LD_INT 47
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: LIST
27324: IN
27325: IFFALSE 27342
// bpoints := bpoints * 1.2 ;
27327: LD_ADDR_VAR 0 10
27331: PUSH
27332: LD_VAR 0 10
27336: PUSH
27337: LD_REAL  1.20000000000000E+0000
27340: MUL
27341: ST_TO_ADDR
// end ; unit_building :
27342: GO 27356
27344: LD_INT 3
27346: DOUBLE
27347: EQUAL
27348: IFTRUE 27352
27350: GO 27355
27352: POP
// ; end ;
27353: GO 27356
27355: POP
// for j = 1 to 3 do
27356: LD_ADDR_VAR 0 7
27360: PUSH
27361: DOUBLE
27362: LD_INT 1
27364: DEC
27365: ST_TO_ADDR
27366: LD_INT 3
27368: PUSH
27369: FOR_TO
27370: IFFALSE 27423
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27372: LD_ADDR_VAR 0 5
27376: PUSH
27377: LD_VAR 0 5
27381: PPUSH
27382: LD_VAR 0 7
27386: PPUSH
27387: LD_VAR 0 5
27391: PUSH
27392: LD_VAR 0 7
27396: ARRAY
27397: PUSH
27398: LD_VAR 0 9
27402: PUSH
27403: LD_VAR 0 7
27407: ARRAY
27408: PUSH
27409: LD_VAR 0 10
27413: MUL
27414: PLUS
27415: PPUSH
27416: CALL_OW 1
27420: ST_TO_ADDR
27421: GO 27369
27423: POP
27424: POP
// end ;
27425: GO 25902
27427: POP
27428: POP
// result := Replace ( result , 4 , tmp ) ;
27429: LD_ADDR_VAR 0 5
27433: PUSH
27434: LD_VAR 0 5
27438: PPUSH
27439: LD_INT 4
27441: PPUSH
27442: LD_VAR 0 8
27446: PPUSH
27447: CALL_OW 1
27451: ST_TO_ADDR
// end ;
27452: LD_VAR 0 5
27456: RET
// export function DangerAtRange ( unit , range ) ; begin
27457: LD_INT 0
27459: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27460: LD_ADDR_VAR 0 3
27464: PUSH
27465: LD_VAR 0 1
27469: PPUSH
27470: CALL_OW 255
27474: PPUSH
27475: LD_VAR 0 1
27479: PPUSH
27480: CALL_OW 250
27484: PPUSH
27485: LD_VAR 0 1
27489: PPUSH
27490: CALL_OW 251
27494: PPUSH
27495: LD_VAR 0 2
27499: PPUSH
27500: CALL 25754 0 4
27504: ST_TO_ADDR
// end ;
27505: LD_VAR 0 3
27509: RET
// export function DangerInArea ( side , area ) ; begin
27510: LD_INT 0
27512: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27513: LD_ADDR_VAR 0 3
27517: PUSH
27518: LD_VAR 0 2
27522: PPUSH
27523: LD_INT 81
27525: PUSH
27526: LD_VAR 0 1
27530: PUSH
27531: EMPTY
27532: LIST
27533: LIST
27534: PPUSH
27535: CALL_OW 70
27539: ST_TO_ADDR
// end ;
27540: LD_VAR 0 3
27544: RET
// export function IsExtension ( b ) ; begin
27545: LD_INT 0
27547: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27548: LD_ADDR_VAR 0 2
27552: PUSH
27553: LD_VAR 0 1
27557: PUSH
27558: LD_INT 23
27560: PUSH
27561: LD_INT 20
27563: PUSH
27564: LD_INT 22
27566: PUSH
27567: LD_INT 17
27569: PUSH
27570: LD_INT 24
27572: PUSH
27573: LD_INT 21
27575: PUSH
27576: LD_INT 19
27578: PUSH
27579: LD_INT 16
27581: PUSH
27582: LD_INT 25
27584: PUSH
27585: LD_INT 18
27587: PUSH
27588: EMPTY
27589: LIST
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: IN
27600: ST_TO_ADDR
// end ;
27601: LD_VAR 0 2
27605: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27606: LD_INT 0
27608: PPUSH
27609: PPUSH
27610: PPUSH
// result := [ ] ;
27611: LD_ADDR_VAR 0 4
27615: PUSH
27616: EMPTY
27617: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27618: LD_ADDR_VAR 0 5
27622: PUSH
27623: LD_VAR 0 2
27627: PPUSH
27628: LD_INT 21
27630: PUSH
27631: LD_INT 3
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PPUSH
27638: CALL_OW 70
27642: ST_TO_ADDR
// if not tmp then
27643: LD_VAR 0 5
27647: NOT
27648: IFFALSE 27652
// exit ;
27650: GO 27716
// if checkLink then
27652: LD_VAR 0 3
27656: IFFALSE 27706
// begin for i in tmp do
27658: LD_ADDR_VAR 0 6
27662: PUSH
27663: LD_VAR 0 5
27667: PUSH
27668: FOR_IN
27669: IFFALSE 27704
// if GetBase ( i ) <> base then
27671: LD_VAR 0 6
27675: PPUSH
27676: CALL_OW 274
27680: PUSH
27681: LD_VAR 0 1
27685: NONEQUAL
27686: IFFALSE 27702
// ComLinkToBase ( base , i ) ;
27688: LD_VAR 0 1
27692: PPUSH
27693: LD_VAR 0 6
27697: PPUSH
27698: CALL_OW 169
27702: GO 27668
27704: POP
27705: POP
// end ; result := tmp ;
27706: LD_ADDR_VAR 0 4
27710: PUSH
27711: LD_VAR 0 5
27715: ST_TO_ADDR
// end ;
27716: LD_VAR 0 4
27720: RET
// export function ComComplete ( units , b ) ; var i ; begin
27721: LD_INT 0
27723: PPUSH
27724: PPUSH
// if not units then
27725: LD_VAR 0 1
27729: NOT
27730: IFFALSE 27734
// exit ;
27732: GO 27824
// for i in units do
27734: LD_ADDR_VAR 0 4
27738: PUSH
27739: LD_VAR 0 1
27743: PUSH
27744: FOR_IN
27745: IFFALSE 27822
// if BuildingStatus ( b ) = bs_build then
27747: LD_VAR 0 2
27751: PPUSH
27752: CALL_OW 461
27756: PUSH
27757: LD_INT 1
27759: EQUAL
27760: IFFALSE 27820
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27762: LD_VAR 0 4
27766: PPUSH
27767: LD_STRING h
27769: PUSH
27770: LD_VAR 0 2
27774: PPUSH
27775: CALL_OW 250
27779: PUSH
27780: LD_VAR 0 2
27784: PPUSH
27785: CALL_OW 251
27789: PUSH
27790: LD_VAR 0 2
27794: PUSH
27795: LD_INT 0
27797: PUSH
27798: LD_INT 0
27800: PUSH
27801: LD_INT 0
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: LIST
27808: LIST
27809: LIST
27810: LIST
27811: LIST
27812: PUSH
27813: EMPTY
27814: LIST
27815: PPUSH
27816: CALL_OW 446
27820: GO 27744
27822: POP
27823: POP
// end ;
27824: LD_VAR 0 3
27828: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27829: LD_INT 0
27831: PPUSH
27832: PPUSH
27833: PPUSH
27834: PPUSH
27835: PPUSH
27836: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27837: LD_VAR 0 1
27841: NOT
27842: PUSH
27843: LD_VAR 0 1
27847: PPUSH
27848: CALL_OW 263
27852: PUSH
27853: LD_INT 2
27855: NONEQUAL
27856: OR
27857: IFFALSE 27861
// exit ;
27859: GO 28177
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27861: LD_ADDR_VAR 0 6
27865: PUSH
27866: LD_INT 22
27868: PUSH
27869: LD_VAR 0 1
27873: PPUSH
27874: CALL_OW 255
27878: PUSH
27879: EMPTY
27880: LIST
27881: LIST
27882: PUSH
27883: LD_INT 2
27885: PUSH
27886: LD_INT 30
27888: PUSH
27889: LD_INT 36
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 34
27898: PUSH
27899: LD_INT 31
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: LIST
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: PPUSH
27915: CALL_OW 69
27919: ST_TO_ADDR
// if not tmp then
27920: LD_VAR 0 6
27924: NOT
27925: IFFALSE 27929
// exit ;
27927: GO 28177
// result := [ ] ;
27929: LD_ADDR_VAR 0 2
27933: PUSH
27934: EMPTY
27935: ST_TO_ADDR
// for i in tmp do
27936: LD_ADDR_VAR 0 3
27940: PUSH
27941: LD_VAR 0 6
27945: PUSH
27946: FOR_IN
27947: IFFALSE 28018
// begin t := UnitsInside ( i ) ;
27949: LD_ADDR_VAR 0 4
27953: PUSH
27954: LD_VAR 0 3
27958: PPUSH
27959: CALL_OW 313
27963: ST_TO_ADDR
// if t then
27964: LD_VAR 0 4
27968: IFFALSE 28016
// for j in t do
27970: LD_ADDR_VAR 0 7
27974: PUSH
27975: LD_VAR 0 4
27979: PUSH
27980: FOR_IN
27981: IFFALSE 28014
// result := Replace ( result , result + 1 , j ) ;
27983: LD_ADDR_VAR 0 2
27987: PUSH
27988: LD_VAR 0 2
27992: PPUSH
27993: LD_VAR 0 2
27997: PUSH
27998: LD_INT 1
28000: PLUS
28001: PPUSH
28002: LD_VAR 0 7
28006: PPUSH
28007: CALL_OW 1
28011: ST_TO_ADDR
28012: GO 27980
28014: POP
28015: POP
// end ;
28016: GO 27946
28018: POP
28019: POP
// if not result then
28020: LD_VAR 0 2
28024: NOT
28025: IFFALSE 28029
// exit ;
28027: GO 28177
// mech := result [ 1 ] ;
28029: LD_ADDR_VAR 0 5
28033: PUSH
28034: LD_VAR 0 2
28038: PUSH
28039: LD_INT 1
28041: ARRAY
28042: ST_TO_ADDR
// if result > 1 then
28043: LD_VAR 0 2
28047: PUSH
28048: LD_INT 1
28050: GREATER
28051: IFFALSE 28163
// begin for i = 2 to result do
28053: LD_ADDR_VAR 0 3
28057: PUSH
28058: DOUBLE
28059: LD_INT 2
28061: DEC
28062: ST_TO_ADDR
28063: LD_VAR 0 2
28067: PUSH
28068: FOR_TO
28069: IFFALSE 28161
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28071: LD_ADDR_VAR 0 4
28075: PUSH
28076: LD_VAR 0 2
28080: PUSH
28081: LD_VAR 0 3
28085: ARRAY
28086: PPUSH
28087: LD_INT 3
28089: PPUSH
28090: CALL_OW 259
28094: PUSH
28095: LD_VAR 0 2
28099: PUSH
28100: LD_VAR 0 3
28104: ARRAY
28105: PPUSH
28106: CALL_OW 432
28110: MINUS
28111: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28112: LD_VAR 0 4
28116: PUSH
28117: LD_VAR 0 5
28121: PPUSH
28122: LD_INT 3
28124: PPUSH
28125: CALL_OW 259
28129: PUSH
28130: LD_VAR 0 5
28134: PPUSH
28135: CALL_OW 432
28139: MINUS
28140: GREATEREQUAL
28141: IFFALSE 28159
// mech := result [ i ] ;
28143: LD_ADDR_VAR 0 5
28147: PUSH
28148: LD_VAR 0 2
28152: PUSH
28153: LD_VAR 0 3
28157: ARRAY
28158: ST_TO_ADDR
// end ;
28159: GO 28068
28161: POP
28162: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28163: LD_VAR 0 1
28167: PPUSH
28168: LD_VAR 0 5
28172: PPUSH
28173: CALL_OW 135
// end ;
28177: LD_VAR 0 2
28181: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28182: LD_INT 0
28184: PPUSH
28185: PPUSH
28186: PPUSH
28187: PPUSH
28188: PPUSH
28189: PPUSH
28190: PPUSH
28191: PPUSH
28192: PPUSH
28193: PPUSH
28194: PPUSH
28195: PPUSH
28196: PPUSH
// result := [ ] ;
28197: LD_ADDR_VAR 0 7
28201: PUSH
28202: EMPTY
28203: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28204: LD_VAR 0 1
28208: PPUSH
28209: CALL_OW 266
28213: PUSH
28214: LD_INT 0
28216: PUSH
28217: LD_INT 1
28219: PUSH
28220: EMPTY
28221: LIST
28222: LIST
28223: IN
28224: NOT
28225: IFFALSE 28229
// exit ;
28227: GO 29863
// if name then
28229: LD_VAR 0 3
28233: IFFALSE 28249
// SetBName ( base_dep , name ) ;
28235: LD_VAR 0 1
28239: PPUSH
28240: LD_VAR 0 3
28244: PPUSH
28245: CALL_OW 500
// base := GetBase ( base_dep ) ;
28249: LD_ADDR_VAR 0 15
28253: PUSH
28254: LD_VAR 0 1
28258: PPUSH
28259: CALL_OW 274
28263: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28264: LD_ADDR_VAR 0 16
28268: PUSH
28269: LD_VAR 0 1
28273: PPUSH
28274: CALL_OW 255
28278: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28279: LD_ADDR_VAR 0 17
28283: PUSH
28284: LD_VAR 0 1
28288: PPUSH
28289: CALL_OW 248
28293: ST_TO_ADDR
// if sources then
28294: LD_VAR 0 5
28298: IFFALSE 28345
// for i = 1 to 3 do
28300: LD_ADDR_VAR 0 8
28304: PUSH
28305: DOUBLE
28306: LD_INT 1
28308: DEC
28309: ST_TO_ADDR
28310: LD_INT 3
28312: PUSH
28313: FOR_TO
28314: IFFALSE 28343
// AddResourceType ( base , i , sources [ i ] ) ;
28316: LD_VAR 0 15
28320: PPUSH
28321: LD_VAR 0 8
28325: PPUSH
28326: LD_VAR 0 5
28330: PUSH
28331: LD_VAR 0 8
28335: ARRAY
28336: PPUSH
28337: CALL_OW 276
28341: GO 28313
28343: POP
28344: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28345: LD_ADDR_VAR 0 18
28349: PUSH
28350: LD_VAR 0 15
28354: PPUSH
28355: LD_VAR 0 2
28359: PPUSH
28360: LD_INT 1
28362: PPUSH
28363: CALL 27606 0 3
28367: ST_TO_ADDR
// InitHc ;
28368: CALL_OW 19
// InitUc ;
28372: CALL_OW 18
// uc_side := side ;
28376: LD_ADDR_OWVAR 20
28380: PUSH
28381: LD_VAR 0 16
28385: ST_TO_ADDR
// uc_nation := nation ;
28386: LD_ADDR_OWVAR 21
28390: PUSH
28391: LD_VAR 0 17
28395: ST_TO_ADDR
// if buildings then
28396: LD_VAR 0 18
28400: IFFALSE 29722
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28402: LD_ADDR_VAR 0 19
28406: PUSH
28407: LD_VAR 0 18
28411: PPUSH
28412: LD_INT 2
28414: PUSH
28415: LD_INT 30
28417: PUSH
28418: LD_INT 29
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: LD_INT 30
28427: PUSH
28428: LD_INT 30
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: LIST
28439: PPUSH
28440: CALL_OW 72
28444: ST_TO_ADDR
// if tmp then
28445: LD_VAR 0 19
28449: IFFALSE 28497
// for i in tmp do
28451: LD_ADDR_VAR 0 8
28455: PUSH
28456: LD_VAR 0 19
28460: PUSH
28461: FOR_IN
28462: IFFALSE 28495
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28464: LD_VAR 0 8
28468: PPUSH
28469: CALL_OW 250
28473: PPUSH
28474: LD_VAR 0 8
28478: PPUSH
28479: CALL_OW 251
28483: PPUSH
28484: LD_VAR 0 16
28488: PPUSH
28489: CALL_OW 441
28493: GO 28461
28495: POP
28496: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28497: LD_VAR 0 18
28501: PPUSH
28502: LD_INT 2
28504: PUSH
28505: LD_INT 30
28507: PUSH
28508: LD_INT 32
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 30
28517: PUSH
28518: LD_INT 33
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PUSH
28525: EMPTY
28526: LIST
28527: LIST
28528: LIST
28529: PPUSH
28530: CALL_OW 72
28534: IFFALSE 28622
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28536: LD_ADDR_VAR 0 8
28540: PUSH
28541: LD_VAR 0 18
28545: PPUSH
28546: LD_INT 2
28548: PUSH
28549: LD_INT 30
28551: PUSH
28552: LD_INT 32
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 30
28561: PUSH
28562: LD_INT 33
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: EMPTY
28570: LIST
28571: LIST
28572: LIST
28573: PPUSH
28574: CALL_OW 72
28578: PUSH
28579: FOR_IN
28580: IFFALSE 28620
// begin if not GetBWeapon ( i ) then
28582: LD_VAR 0 8
28586: PPUSH
28587: CALL_OW 269
28591: NOT
28592: IFFALSE 28618
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28594: LD_VAR 0 8
28598: PPUSH
28599: LD_VAR 0 8
28603: PPUSH
28604: LD_VAR 0 2
28608: PPUSH
28609: CALL 29868 0 2
28613: PPUSH
28614: CALL_OW 431
// end ;
28618: GO 28579
28620: POP
28621: POP
// end ; for i = 1 to personel do
28622: LD_ADDR_VAR 0 8
28626: PUSH
28627: DOUBLE
28628: LD_INT 1
28630: DEC
28631: ST_TO_ADDR
28632: LD_VAR 0 6
28636: PUSH
28637: FOR_TO
28638: IFFALSE 29702
// begin if i > 4 then
28640: LD_VAR 0 8
28644: PUSH
28645: LD_INT 4
28647: GREATER
28648: IFFALSE 28652
// break ;
28650: GO 29702
// case i of 1 :
28652: LD_VAR 0 8
28656: PUSH
28657: LD_INT 1
28659: DOUBLE
28660: EQUAL
28661: IFTRUE 28665
28663: GO 28745
28665: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28666: LD_ADDR_VAR 0 12
28670: PUSH
28671: LD_VAR 0 18
28675: PPUSH
28676: LD_INT 22
28678: PUSH
28679: LD_VAR 0 16
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 58
28690: PUSH
28691: EMPTY
28692: LIST
28693: PUSH
28694: LD_INT 2
28696: PUSH
28697: LD_INT 30
28699: PUSH
28700: LD_INT 32
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: PUSH
28707: LD_INT 30
28709: PUSH
28710: LD_INT 4
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: PUSH
28717: LD_INT 30
28719: PUSH
28720: LD_INT 5
28722: PUSH
28723: EMPTY
28724: LIST
28725: LIST
28726: PUSH
28727: EMPTY
28728: LIST
28729: LIST
28730: LIST
28731: LIST
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: LIST
28737: PPUSH
28738: CALL_OW 72
28742: ST_TO_ADDR
28743: GO 28967
28745: LD_INT 2
28747: DOUBLE
28748: EQUAL
28749: IFTRUE 28753
28751: GO 28815
28753: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28754: LD_ADDR_VAR 0 12
28758: PUSH
28759: LD_VAR 0 18
28763: PPUSH
28764: LD_INT 22
28766: PUSH
28767: LD_VAR 0 16
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: LD_INT 30
28781: PUSH
28782: LD_INT 0
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 30
28791: PUSH
28792: LD_INT 1
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: LIST
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PPUSH
28808: CALL_OW 72
28812: ST_TO_ADDR
28813: GO 28967
28815: LD_INT 3
28817: DOUBLE
28818: EQUAL
28819: IFTRUE 28823
28821: GO 28885
28823: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28824: LD_ADDR_VAR 0 12
28828: PUSH
28829: LD_VAR 0 18
28833: PPUSH
28834: LD_INT 22
28836: PUSH
28837: LD_VAR 0 16
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: PUSH
28846: LD_INT 2
28848: PUSH
28849: LD_INT 30
28851: PUSH
28852: LD_INT 2
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: PUSH
28859: LD_INT 30
28861: PUSH
28862: LD_INT 3
28864: PUSH
28865: EMPTY
28866: LIST
28867: LIST
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: LIST
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PPUSH
28878: CALL_OW 72
28882: ST_TO_ADDR
28883: GO 28967
28885: LD_INT 4
28887: DOUBLE
28888: EQUAL
28889: IFTRUE 28893
28891: GO 28966
28893: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28894: LD_ADDR_VAR 0 12
28898: PUSH
28899: LD_VAR 0 18
28903: PPUSH
28904: LD_INT 22
28906: PUSH
28907: LD_VAR 0 16
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 2
28918: PUSH
28919: LD_INT 30
28921: PUSH
28922: LD_INT 6
28924: PUSH
28925: EMPTY
28926: LIST
28927: LIST
28928: PUSH
28929: LD_INT 30
28931: PUSH
28932: LD_INT 7
28934: PUSH
28935: EMPTY
28936: LIST
28937: LIST
28938: PUSH
28939: LD_INT 30
28941: PUSH
28942: LD_INT 8
28944: PUSH
28945: EMPTY
28946: LIST
28947: LIST
28948: PUSH
28949: EMPTY
28950: LIST
28951: LIST
28952: LIST
28953: LIST
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PPUSH
28959: CALL_OW 72
28963: ST_TO_ADDR
28964: GO 28967
28966: POP
// if i = 1 then
28967: LD_VAR 0 8
28971: PUSH
28972: LD_INT 1
28974: EQUAL
28975: IFFALSE 29086
// begin tmp := [ ] ;
28977: LD_ADDR_VAR 0 19
28981: PUSH
28982: EMPTY
28983: ST_TO_ADDR
// for j in f do
28984: LD_ADDR_VAR 0 9
28988: PUSH
28989: LD_VAR 0 12
28993: PUSH
28994: FOR_IN
28995: IFFALSE 29068
// if GetBType ( j ) = b_bunker then
28997: LD_VAR 0 9
29001: PPUSH
29002: CALL_OW 266
29006: PUSH
29007: LD_INT 32
29009: EQUAL
29010: IFFALSE 29037
// tmp := Insert ( tmp , 1 , j ) else
29012: LD_ADDR_VAR 0 19
29016: PUSH
29017: LD_VAR 0 19
29021: PPUSH
29022: LD_INT 1
29024: PPUSH
29025: LD_VAR 0 9
29029: PPUSH
29030: CALL_OW 2
29034: ST_TO_ADDR
29035: GO 29066
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29037: LD_ADDR_VAR 0 19
29041: PUSH
29042: LD_VAR 0 19
29046: PPUSH
29047: LD_VAR 0 19
29051: PUSH
29052: LD_INT 1
29054: PLUS
29055: PPUSH
29056: LD_VAR 0 9
29060: PPUSH
29061: CALL_OW 2
29065: ST_TO_ADDR
29066: GO 28994
29068: POP
29069: POP
// if tmp then
29070: LD_VAR 0 19
29074: IFFALSE 29086
// f := tmp ;
29076: LD_ADDR_VAR 0 12
29080: PUSH
29081: LD_VAR 0 19
29085: ST_TO_ADDR
// end ; x := personel [ i ] ;
29086: LD_ADDR_VAR 0 13
29090: PUSH
29091: LD_VAR 0 6
29095: PUSH
29096: LD_VAR 0 8
29100: ARRAY
29101: ST_TO_ADDR
// if x = - 1 then
29102: LD_VAR 0 13
29106: PUSH
29107: LD_INT 1
29109: NEG
29110: EQUAL
29111: IFFALSE 29320
// begin for j in f do
29113: LD_ADDR_VAR 0 9
29117: PUSH
29118: LD_VAR 0 12
29122: PUSH
29123: FOR_IN
29124: IFFALSE 29316
// repeat InitHc ;
29126: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29130: LD_VAR 0 9
29134: PPUSH
29135: CALL_OW 266
29139: PUSH
29140: LD_INT 5
29142: EQUAL
29143: IFFALSE 29213
// begin if UnitsInside ( j ) < 3 then
29145: LD_VAR 0 9
29149: PPUSH
29150: CALL_OW 313
29154: PUSH
29155: LD_INT 3
29157: LESS
29158: IFFALSE 29194
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29160: LD_INT 0
29162: PPUSH
29163: LD_INT 5
29165: PUSH
29166: LD_INT 8
29168: PUSH
29169: LD_INT 9
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: LIST
29176: PUSH
29177: LD_VAR 0 17
29181: ARRAY
29182: PPUSH
29183: LD_VAR 0 4
29187: PPUSH
29188: CALL_OW 380
29192: GO 29211
// PrepareHuman ( false , i , skill ) ;
29194: LD_INT 0
29196: PPUSH
29197: LD_VAR 0 8
29201: PPUSH
29202: LD_VAR 0 4
29206: PPUSH
29207: CALL_OW 380
// end else
29211: GO 29230
// PrepareHuman ( false , i , skill ) ;
29213: LD_INT 0
29215: PPUSH
29216: LD_VAR 0 8
29220: PPUSH
29221: LD_VAR 0 4
29225: PPUSH
29226: CALL_OW 380
// un := CreateHuman ;
29230: LD_ADDR_VAR 0 14
29234: PUSH
29235: CALL_OW 44
29239: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29240: LD_ADDR_VAR 0 7
29244: PUSH
29245: LD_VAR 0 7
29249: PPUSH
29250: LD_INT 1
29252: PPUSH
29253: LD_VAR 0 14
29257: PPUSH
29258: CALL_OW 2
29262: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29263: LD_VAR 0 14
29267: PPUSH
29268: LD_VAR 0 9
29272: PPUSH
29273: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29277: LD_VAR 0 9
29281: PPUSH
29282: CALL_OW 313
29286: PUSH
29287: LD_INT 6
29289: EQUAL
29290: PUSH
29291: LD_VAR 0 9
29295: PPUSH
29296: CALL_OW 266
29300: PUSH
29301: LD_INT 32
29303: PUSH
29304: LD_INT 31
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: IN
29311: OR
29312: IFFALSE 29126
29314: GO 29123
29316: POP
29317: POP
// end else
29318: GO 29700
// for j = 1 to x do
29320: LD_ADDR_VAR 0 9
29324: PUSH
29325: DOUBLE
29326: LD_INT 1
29328: DEC
29329: ST_TO_ADDR
29330: LD_VAR 0 13
29334: PUSH
29335: FOR_TO
29336: IFFALSE 29698
// begin InitHc ;
29338: CALL_OW 19
// if not f then
29342: LD_VAR 0 12
29346: NOT
29347: IFFALSE 29436
// begin PrepareHuman ( false , i , skill ) ;
29349: LD_INT 0
29351: PPUSH
29352: LD_VAR 0 8
29356: PPUSH
29357: LD_VAR 0 4
29361: PPUSH
29362: CALL_OW 380
// un := CreateHuman ;
29366: LD_ADDR_VAR 0 14
29370: PUSH
29371: CALL_OW 44
29375: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29376: LD_ADDR_VAR 0 7
29380: PUSH
29381: LD_VAR 0 7
29385: PPUSH
29386: LD_INT 1
29388: PPUSH
29389: LD_VAR 0 14
29393: PPUSH
29394: CALL_OW 2
29398: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29399: LD_VAR 0 14
29403: PPUSH
29404: LD_VAR 0 1
29408: PPUSH
29409: CALL_OW 250
29413: PPUSH
29414: LD_VAR 0 1
29418: PPUSH
29419: CALL_OW 251
29423: PPUSH
29424: LD_INT 10
29426: PPUSH
29427: LD_INT 0
29429: PPUSH
29430: CALL_OW 50
// continue ;
29434: GO 29335
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29436: LD_VAR 0 12
29440: PUSH
29441: LD_INT 1
29443: ARRAY
29444: PPUSH
29445: CALL_OW 313
29449: PUSH
29450: LD_VAR 0 12
29454: PUSH
29455: LD_INT 1
29457: ARRAY
29458: PPUSH
29459: CALL_OW 266
29463: PUSH
29464: LD_INT 32
29466: PUSH
29467: LD_INT 31
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: IN
29474: AND
29475: PUSH
29476: LD_VAR 0 12
29480: PUSH
29481: LD_INT 1
29483: ARRAY
29484: PPUSH
29485: CALL_OW 313
29489: PUSH
29490: LD_INT 6
29492: EQUAL
29493: OR
29494: IFFALSE 29514
// f := Delete ( f , 1 ) ;
29496: LD_ADDR_VAR 0 12
29500: PUSH
29501: LD_VAR 0 12
29505: PPUSH
29506: LD_INT 1
29508: PPUSH
29509: CALL_OW 3
29513: ST_TO_ADDR
// if not f then
29514: LD_VAR 0 12
29518: NOT
29519: IFFALSE 29537
// begin x := x + 2 ;
29521: LD_ADDR_VAR 0 13
29525: PUSH
29526: LD_VAR 0 13
29530: PUSH
29531: LD_INT 2
29533: PLUS
29534: ST_TO_ADDR
// continue ;
29535: GO 29335
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29537: LD_VAR 0 12
29541: PUSH
29542: LD_INT 1
29544: ARRAY
29545: PPUSH
29546: CALL_OW 266
29550: PUSH
29551: LD_INT 5
29553: EQUAL
29554: IFFALSE 29628
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29556: LD_VAR 0 12
29560: PUSH
29561: LD_INT 1
29563: ARRAY
29564: PPUSH
29565: CALL_OW 313
29569: PUSH
29570: LD_INT 3
29572: LESS
29573: IFFALSE 29609
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29575: LD_INT 0
29577: PPUSH
29578: LD_INT 5
29580: PUSH
29581: LD_INT 8
29583: PUSH
29584: LD_INT 9
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: LIST
29591: PUSH
29592: LD_VAR 0 17
29596: ARRAY
29597: PPUSH
29598: LD_VAR 0 4
29602: PPUSH
29603: CALL_OW 380
29607: GO 29626
// PrepareHuman ( false , i , skill ) ;
29609: LD_INT 0
29611: PPUSH
29612: LD_VAR 0 8
29616: PPUSH
29617: LD_VAR 0 4
29621: PPUSH
29622: CALL_OW 380
// end else
29626: GO 29645
// PrepareHuman ( false , i , skill ) ;
29628: LD_INT 0
29630: PPUSH
29631: LD_VAR 0 8
29635: PPUSH
29636: LD_VAR 0 4
29640: PPUSH
29641: CALL_OW 380
// un := CreateHuman ;
29645: LD_ADDR_VAR 0 14
29649: PUSH
29650: CALL_OW 44
29654: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29655: LD_ADDR_VAR 0 7
29659: PUSH
29660: LD_VAR 0 7
29664: PPUSH
29665: LD_INT 1
29667: PPUSH
29668: LD_VAR 0 14
29672: PPUSH
29673: CALL_OW 2
29677: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29678: LD_VAR 0 14
29682: PPUSH
29683: LD_VAR 0 12
29687: PUSH
29688: LD_INT 1
29690: ARRAY
29691: PPUSH
29692: CALL_OW 52
// end ;
29696: GO 29335
29698: POP
29699: POP
// end ;
29700: GO 28637
29702: POP
29703: POP
// result := result ^ buildings ;
29704: LD_ADDR_VAR 0 7
29708: PUSH
29709: LD_VAR 0 7
29713: PUSH
29714: LD_VAR 0 18
29718: ADD
29719: ST_TO_ADDR
// end else
29720: GO 29863
// begin for i = 1 to personel do
29722: LD_ADDR_VAR 0 8
29726: PUSH
29727: DOUBLE
29728: LD_INT 1
29730: DEC
29731: ST_TO_ADDR
29732: LD_VAR 0 6
29736: PUSH
29737: FOR_TO
29738: IFFALSE 29861
// begin if i > 4 then
29740: LD_VAR 0 8
29744: PUSH
29745: LD_INT 4
29747: GREATER
29748: IFFALSE 29752
// break ;
29750: GO 29861
// x := personel [ i ] ;
29752: LD_ADDR_VAR 0 13
29756: PUSH
29757: LD_VAR 0 6
29761: PUSH
29762: LD_VAR 0 8
29766: ARRAY
29767: ST_TO_ADDR
// if x = - 1 then
29768: LD_VAR 0 13
29772: PUSH
29773: LD_INT 1
29775: NEG
29776: EQUAL
29777: IFFALSE 29781
// continue ;
29779: GO 29737
// PrepareHuman ( false , i , skill ) ;
29781: LD_INT 0
29783: PPUSH
29784: LD_VAR 0 8
29788: PPUSH
29789: LD_VAR 0 4
29793: PPUSH
29794: CALL_OW 380
// un := CreateHuman ;
29798: LD_ADDR_VAR 0 14
29802: PUSH
29803: CALL_OW 44
29807: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29808: LD_VAR 0 14
29812: PPUSH
29813: LD_VAR 0 1
29817: PPUSH
29818: CALL_OW 250
29822: PPUSH
29823: LD_VAR 0 1
29827: PPUSH
29828: CALL_OW 251
29832: PPUSH
29833: LD_INT 10
29835: PPUSH
29836: LD_INT 0
29838: PPUSH
29839: CALL_OW 50
// result := result ^ un ;
29843: LD_ADDR_VAR 0 7
29847: PUSH
29848: LD_VAR 0 7
29852: PUSH
29853: LD_VAR 0 14
29857: ADD
29858: ST_TO_ADDR
// end ;
29859: GO 29737
29861: POP
29862: POP
// end ; end ;
29863: LD_VAR 0 7
29867: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29868: LD_INT 0
29870: PPUSH
29871: PPUSH
29872: PPUSH
29873: PPUSH
29874: PPUSH
29875: PPUSH
29876: PPUSH
29877: PPUSH
29878: PPUSH
29879: PPUSH
29880: PPUSH
29881: PPUSH
29882: PPUSH
29883: PPUSH
29884: PPUSH
29885: PPUSH
// result := false ;
29886: LD_ADDR_VAR 0 3
29890: PUSH
29891: LD_INT 0
29893: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29894: LD_VAR 0 1
29898: NOT
29899: PUSH
29900: LD_VAR 0 1
29904: PPUSH
29905: CALL_OW 266
29909: PUSH
29910: LD_INT 32
29912: PUSH
29913: LD_INT 33
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: IN
29920: NOT
29921: OR
29922: IFFALSE 29926
// exit ;
29924: GO 31035
// nat := GetNation ( tower ) ;
29926: LD_ADDR_VAR 0 12
29930: PUSH
29931: LD_VAR 0 1
29935: PPUSH
29936: CALL_OW 248
29940: ST_TO_ADDR
// side := GetSide ( tower ) ;
29941: LD_ADDR_VAR 0 16
29945: PUSH
29946: LD_VAR 0 1
29950: PPUSH
29951: CALL_OW 255
29955: ST_TO_ADDR
// x := GetX ( tower ) ;
29956: LD_ADDR_VAR 0 10
29960: PUSH
29961: LD_VAR 0 1
29965: PPUSH
29966: CALL_OW 250
29970: ST_TO_ADDR
// y := GetY ( tower ) ;
29971: LD_ADDR_VAR 0 11
29975: PUSH
29976: LD_VAR 0 1
29980: PPUSH
29981: CALL_OW 251
29985: ST_TO_ADDR
// if not x or not y then
29986: LD_VAR 0 10
29990: NOT
29991: PUSH
29992: LD_VAR 0 11
29996: NOT
29997: OR
29998: IFFALSE 30002
// exit ;
30000: GO 31035
// weapon := 0 ;
30002: LD_ADDR_VAR 0 18
30006: PUSH
30007: LD_INT 0
30009: ST_TO_ADDR
// fac_list := [ ] ;
30010: LD_ADDR_VAR 0 17
30014: PUSH
30015: EMPTY
30016: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30017: LD_ADDR_VAR 0 6
30021: PUSH
30022: LD_VAR 0 1
30026: PPUSH
30027: CALL_OW 274
30031: PPUSH
30032: LD_VAR 0 2
30036: PPUSH
30037: LD_INT 0
30039: PPUSH
30040: CALL 27606 0 3
30044: PPUSH
30045: LD_INT 30
30047: PUSH
30048: LD_INT 3
30050: PUSH
30051: EMPTY
30052: LIST
30053: LIST
30054: PPUSH
30055: CALL_OW 72
30059: ST_TO_ADDR
// if not factories then
30060: LD_VAR 0 6
30064: NOT
30065: IFFALSE 30069
// exit ;
30067: GO 31035
// for i in factories do
30069: LD_ADDR_VAR 0 8
30073: PUSH
30074: LD_VAR 0 6
30078: PUSH
30079: FOR_IN
30080: IFFALSE 30105
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30082: LD_ADDR_VAR 0 17
30086: PUSH
30087: LD_VAR 0 17
30091: PUSH
30092: LD_VAR 0 8
30096: PPUSH
30097: CALL_OW 478
30101: UNION
30102: ST_TO_ADDR
30103: GO 30079
30105: POP
30106: POP
// if not fac_list then
30107: LD_VAR 0 17
30111: NOT
30112: IFFALSE 30116
// exit ;
30114: GO 31035
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30116: LD_ADDR_VAR 0 5
30120: PUSH
30121: LD_INT 4
30123: PUSH
30124: LD_INT 5
30126: PUSH
30127: LD_INT 9
30129: PUSH
30130: LD_INT 10
30132: PUSH
30133: LD_INT 6
30135: PUSH
30136: LD_INT 7
30138: PUSH
30139: LD_INT 11
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: LIST
30146: LIST
30147: LIST
30148: LIST
30149: LIST
30150: PUSH
30151: LD_INT 27
30153: PUSH
30154: LD_INT 28
30156: PUSH
30157: LD_INT 26
30159: PUSH
30160: LD_INT 30
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 43
30171: PUSH
30172: LD_INT 44
30174: PUSH
30175: LD_INT 46
30177: PUSH
30178: LD_INT 45
30180: PUSH
30181: LD_INT 47
30183: PUSH
30184: LD_INT 49
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: LIST
30199: PUSH
30200: LD_VAR 0 12
30204: ARRAY
30205: ST_TO_ADDR
// list := list isect fac_list ;
30206: LD_ADDR_VAR 0 5
30210: PUSH
30211: LD_VAR 0 5
30215: PUSH
30216: LD_VAR 0 17
30220: ISECT
30221: ST_TO_ADDR
// if not list then
30222: LD_VAR 0 5
30226: NOT
30227: IFFALSE 30231
// exit ;
30229: GO 31035
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30231: LD_VAR 0 12
30235: PUSH
30236: LD_INT 3
30238: EQUAL
30239: PUSH
30240: LD_INT 49
30242: PUSH
30243: LD_VAR 0 5
30247: IN
30248: AND
30249: PUSH
30250: LD_INT 31
30252: PPUSH
30253: LD_VAR 0 16
30257: PPUSH
30258: CALL_OW 321
30262: PUSH
30263: LD_INT 2
30265: EQUAL
30266: AND
30267: IFFALSE 30327
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30269: LD_INT 22
30271: PUSH
30272: LD_VAR 0 16
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 35
30283: PUSH
30284: LD_INT 49
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PUSH
30291: LD_INT 91
30293: PUSH
30294: LD_VAR 0 1
30298: PUSH
30299: LD_INT 10
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: LIST
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: LIST
30311: PPUSH
30312: CALL_OW 69
30316: NOT
30317: IFFALSE 30327
// weapon := ru_time_lapser ;
30319: LD_ADDR_VAR 0 18
30323: PUSH
30324: LD_INT 49
30326: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30327: LD_VAR 0 12
30331: PUSH
30332: LD_INT 1
30334: PUSH
30335: LD_INT 2
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: IN
30342: PUSH
30343: LD_INT 11
30345: PUSH
30346: LD_VAR 0 5
30350: IN
30351: PUSH
30352: LD_INT 30
30354: PUSH
30355: LD_VAR 0 5
30359: IN
30360: OR
30361: AND
30362: PUSH
30363: LD_INT 6
30365: PPUSH
30366: LD_VAR 0 16
30370: PPUSH
30371: CALL_OW 321
30375: PUSH
30376: LD_INT 2
30378: EQUAL
30379: AND
30380: IFFALSE 30545
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30382: LD_INT 22
30384: PUSH
30385: LD_VAR 0 16
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: PUSH
30394: LD_INT 2
30396: PUSH
30397: LD_INT 35
30399: PUSH
30400: LD_INT 11
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 35
30409: PUSH
30410: LD_INT 30
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: EMPTY
30418: LIST
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 91
30424: PUSH
30425: LD_VAR 0 1
30429: PUSH
30430: LD_INT 18
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: LIST
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: LIST
30442: PPUSH
30443: CALL_OW 69
30447: NOT
30448: PUSH
30449: LD_INT 22
30451: PUSH
30452: LD_VAR 0 16
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 2
30463: PUSH
30464: LD_INT 30
30466: PUSH
30467: LD_INT 32
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: PUSH
30474: LD_INT 30
30476: PUSH
30477: LD_INT 33
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 91
30491: PUSH
30492: LD_VAR 0 1
30496: PUSH
30497: LD_INT 12
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: LIST
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: LIST
30509: PUSH
30510: EMPTY
30511: LIST
30512: PPUSH
30513: CALL_OW 69
30517: PUSH
30518: LD_INT 2
30520: GREATER
30521: AND
30522: IFFALSE 30545
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30524: LD_ADDR_VAR 0 18
30528: PUSH
30529: LD_INT 11
30531: PUSH
30532: LD_INT 30
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_VAR 0 12
30543: ARRAY
30544: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30545: LD_VAR 0 18
30549: NOT
30550: PUSH
30551: LD_INT 40
30553: PPUSH
30554: LD_VAR 0 16
30558: PPUSH
30559: CALL_OW 321
30563: PUSH
30564: LD_INT 2
30566: EQUAL
30567: AND
30568: PUSH
30569: LD_INT 7
30571: PUSH
30572: LD_VAR 0 5
30576: IN
30577: PUSH
30578: LD_INT 28
30580: PUSH
30581: LD_VAR 0 5
30585: IN
30586: OR
30587: PUSH
30588: LD_INT 45
30590: PUSH
30591: LD_VAR 0 5
30595: IN
30596: OR
30597: AND
30598: IFFALSE 30852
// begin hex := GetHexInfo ( x , y ) ;
30600: LD_ADDR_VAR 0 4
30604: PUSH
30605: LD_VAR 0 10
30609: PPUSH
30610: LD_VAR 0 11
30614: PPUSH
30615: CALL_OW 546
30619: ST_TO_ADDR
// if hex [ 1 ] then
30620: LD_VAR 0 4
30624: PUSH
30625: LD_INT 1
30627: ARRAY
30628: IFFALSE 30632
// exit ;
30630: GO 31035
// height := hex [ 2 ] ;
30632: LD_ADDR_VAR 0 15
30636: PUSH
30637: LD_VAR 0 4
30641: PUSH
30642: LD_INT 2
30644: ARRAY
30645: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30646: LD_ADDR_VAR 0 14
30650: PUSH
30651: LD_INT 0
30653: PUSH
30654: LD_INT 2
30656: PUSH
30657: LD_INT 3
30659: PUSH
30660: LD_INT 5
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: LIST
30667: LIST
30668: ST_TO_ADDR
// for i in tmp do
30669: LD_ADDR_VAR 0 8
30673: PUSH
30674: LD_VAR 0 14
30678: PUSH
30679: FOR_IN
30680: IFFALSE 30850
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30682: LD_ADDR_VAR 0 9
30686: PUSH
30687: LD_VAR 0 10
30691: PPUSH
30692: LD_VAR 0 8
30696: PPUSH
30697: LD_INT 5
30699: PPUSH
30700: CALL_OW 272
30704: PUSH
30705: LD_VAR 0 11
30709: PPUSH
30710: LD_VAR 0 8
30714: PPUSH
30715: LD_INT 5
30717: PPUSH
30718: CALL_OW 273
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30727: LD_VAR 0 9
30731: PUSH
30732: LD_INT 1
30734: ARRAY
30735: PPUSH
30736: LD_VAR 0 9
30740: PUSH
30741: LD_INT 2
30743: ARRAY
30744: PPUSH
30745: CALL_OW 488
30749: IFFALSE 30848
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30751: LD_ADDR_VAR 0 4
30755: PUSH
30756: LD_VAR 0 9
30760: PUSH
30761: LD_INT 1
30763: ARRAY
30764: PPUSH
30765: LD_VAR 0 9
30769: PUSH
30770: LD_INT 2
30772: ARRAY
30773: PPUSH
30774: CALL_OW 546
30778: ST_TO_ADDR
// if hex [ 1 ] then
30779: LD_VAR 0 4
30783: PUSH
30784: LD_INT 1
30786: ARRAY
30787: IFFALSE 30791
// continue ;
30789: GO 30679
// h := hex [ 2 ] ;
30791: LD_ADDR_VAR 0 13
30795: PUSH
30796: LD_VAR 0 4
30800: PUSH
30801: LD_INT 2
30803: ARRAY
30804: ST_TO_ADDR
// if h + 7 < height then
30805: LD_VAR 0 13
30809: PUSH
30810: LD_INT 7
30812: PLUS
30813: PUSH
30814: LD_VAR 0 15
30818: LESS
30819: IFFALSE 30848
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30821: LD_ADDR_VAR 0 18
30825: PUSH
30826: LD_INT 7
30828: PUSH
30829: LD_INT 28
30831: PUSH
30832: LD_INT 45
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: LIST
30839: PUSH
30840: LD_VAR 0 12
30844: ARRAY
30845: ST_TO_ADDR
// break ;
30846: GO 30850
// end ; end ; end ;
30848: GO 30679
30850: POP
30851: POP
// end ; if not weapon then
30852: LD_VAR 0 18
30856: NOT
30857: IFFALSE 30917
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30859: LD_ADDR_VAR 0 5
30863: PUSH
30864: LD_VAR 0 5
30868: PUSH
30869: LD_INT 11
30871: PUSH
30872: LD_INT 30
30874: PUSH
30875: LD_INT 49
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: LIST
30882: DIFF
30883: ST_TO_ADDR
// if not list then
30884: LD_VAR 0 5
30888: NOT
30889: IFFALSE 30893
// exit ;
30891: GO 31035
// weapon := list [ rand ( 1 , list ) ] ;
30893: LD_ADDR_VAR 0 18
30897: PUSH
30898: LD_VAR 0 5
30902: PUSH
30903: LD_INT 1
30905: PPUSH
30906: LD_VAR 0 5
30910: PPUSH
30911: CALL_OW 12
30915: ARRAY
30916: ST_TO_ADDR
// end ; if weapon then
30917: LD_VAR 0 18
30921: IFFALSE 31035
// begin tmp := CostOfWeapon ( weapon ) ;
30923: LD_ADDR_VAR 0 14
30927: PUSH
30928: LD_VAR 0 18
30932: PPUSH
30933: CALL_OW 451
30937: ST_TO_ADDR
// j := GetBase ( tower ) ;
30938: LD_ADDR_VAR 0 9
30942: PUSH
30943: LD_VAR 0 1
30947: PPUSH
30948: CALL_OW 274
30952: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30953: LD_VAR 0 9
30957: PPUSH
30958: LD_INT 1
30960: PPUSH
30961: CALL_OW 275
30965: PUSH
30966: LD_VAR 0 14
30970: PUSH
30971: LD_INT 1
30973: ARRAY
30974: GREATEREQUAL
30975: PUSH
30976: LD_VAR 0 9
30980: PPUSH
30981: LD_INT 2
30983: PPUSH
30984: CALL_OW 275
30988: PUSH
30989: LD_VAR 0 14
30993: PUSH
30994: LD_INT 2
30996: ARRAY
30997: GREATEREQUAL
30998: AND
30999: PUSH
31000: LD_VAR 0 9
31004: PPUSH
31005: LD_INT 3
31007: PPUSH
31008: CALL_OW 275
31012: PUSH
31013: LD_VAR 0 14
31017: PUSH
31018: LD_INT 3
31020: ARRAY
31021: GREATEREQUAL
31022: AND
31023: IFFALSE 31035
// result := weapon ;
31025: LD_ADDR_VAR 0 3
31029: PUSH
31030: LD_VAR 0 18
31034: ST_TO_ADDR
// end ; end ;
31035: LD_VAR 0 3
31039: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31040: LD_INT 0
31042: PPUSH
31043: PPUSH
// result := true ;
31044: LD_ADDR_VAR 0 3
31048: PUSH
31049: LD_INT 1
31051: ST_TO_ADDR
// if array1 = array2 then
31052: LD_VAR 0 1
31056: PUSH
31057: LD_VAR 0 2
31061: EQUAL
31062: IFFALSE 31122
// begin for i = 1 to array1 do
31064: LD_ADDR_VAR 0 4
31068: PUSH
31069: DOUBLE
31070: LD_INT 1
31072: DEC
31073: ST_TO_ADDR
31074: LD_VAR 0 1
31078: PUSH
31079: FOR_TO
31080: IFFALSE 31118
// if array1 [ i ] <> array2 [ i ] then
31082: LD_VAR 0 1
31086: PUSH
31087: LD_VAR 0 4
31091: ARRAY
31092: PUSH
31093: LD_VAR 0 2
31097: PUSH
31098: LD_VAR 0 4
31102: ARRAY
31103: NONEQUAL
31104: IFFALSE 31116
// begin result := false ;
31106: LD_ADDR_VAR 0 3
31110: PUSH
31111: LD_INT 0
31113: ST_TO_ADDR
// break ;
31114: GO 31118
// end ;
31116: GO 31079
31118: POP
31119: POP
// end else
31120: GO 31130
// result := false ;
31122: LD_ADDR_VAR 0 3
31126: PUSH
31127: LD_INT 0
31129: ST_TO_ADDR
// end ;
31130: LD_VAR 0 3
31134: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31135: LD_INT 0
31137: PPUSH
31138: PPUSH
// if not array1 or not array2 then
31139: LD_VAR 0 1
31143: NOT
31144: PUSH
31145: LD_VAR 0 2
31149: NOT
31150: OR
31151: IFFALSE 31155
// exit ;
31153: GO 31219
// result := true ;
31155: LD_ADDR_VAR 0 3
31159: PUSH
31160: LD_INT 1
31162: ST_TO_ADDR
// for i = 1 to array1 do
31163: LD_ADDR_VAR 0 4
31167: PUSH
31168: DOUBLE
31169: LD_INT 1
31171: DEC
31172: ST_TO_ADDR
31173: LD_VAR 0 1
31177: PUSH
31178: FOR_TO
31179: IFFALSE 31217
// if array1 [ i ] <> array2 [ i ] then
31181: LD_VAR 0 1
31185: PUSH
31186: LD_VAR 0 4
31190: ARRAY
31191: PUSH
31192: LD_VAR 0 2
31196: PUSH
31197: LD_VAR 0 4
31201: ARRAY
31202: NONEQUAL
31203: IFFALSE 31215
// begin result := false ;
31205: LD_ADDR_VAR 0 3
31209: PUSH
31210: LD_INT 0
31212: ST_TO_ADDR
// break ;
31213: GO 31217
// end ;
31215: GO 31178
31217: POP
31218: POP
// end ;
31219: LD_VAR 0 3
31223: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31224: LD_INT 0
31226: PPUSH
31227: PPUSH
31228: PPUSH
// pom := GetBase ( fac ) ;
31229: LD_ADDR_VAR 0 5
31233: PUSH
31234: LD_VAR 0 1
31238: PPUSH
31239: CALL_OW 274
31243: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31244: LD_ADDR_VAR 0 4
31248: PUSH
31249: LD_VAR 0 2
31253: PUSH
31254: LD_INT 1
31256: ARRAY
31257: PPUSH
31258: LD_VAR 0 2
31262: PUSH
31263: LD_INT 2
31265: ARRAY
31266: PPUSH
31267: LD_VAR 0 2
31271: PUSH
31272: LD_INT 3
31274: ARRAY
31275: PPUSH
31276: LD_VAR 0 2
31280: PUSH
31281: LD_INT 4
31283: ARRAY
31284: PPUSH
31285: CALL_OW 449
31289: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31290: LD_ADDR_VAR 0 3
31294: PUSH
31295: LD_VAR 0 5
31299: PPUSH
31300: LD_INT 1
31302: PPUSH
31303: CALL_OW 275
31307: PUSH
31308: LD_VAR 0 4
31312: PUSH
31313: LD_INT 1
31315: ARRAY
31316: GREATEREQUAL
31317: PUSH
31318: LD_VAR 0 5
31322: PPUSH
31323: LD_INT 2
31325: PPUSH
31326: CALL_OW 275
31330: PUSH
31331: LD_VAR 0 4
31335: PUSH
31336: LD_INT 2
31338: ARRAY
31339: GREATEREQUAL
31340: AND
31341: PUSH
31342: LD_VAR 0 5
31346: PPUSH
31347: LD_INT 3
31349: PPUSH
31350: CALL_OW 275
31354: PUSH
31355: LD_VAR 0 4
31359: PUSH
31360: LD_INT 3
31362: ARRAY
31363: GREATEREQUAL
31364: AND
31365: ST_TO_ADDR
// end ;
31366: LD_VAR 0 3
31370: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31371: LD_INT 0
31373: PPUSH
31374: PPUSH
31375: PPUSH
31376: PPUSH
// pom := GetBase ( building ) ;
31377: LD_ADDR_VAR 0 3
31381: PUSH
31382: LD_VAR 0 1
31386: PPUSH
31387: CALL_OW 274
31391: ST_TO_ADDR
// if not pom then
31392: LD_VAR 0 3
31396: NOT
31397: IFFALSE 31401
// exit ;
31399: GO 31571
// btype := GetBType ( building ) ;
31401: LD_ADDR_VAR 0 5
31405: PUSH
31406: LD_VAR 0 1
31410: PPUSH
31411: CALL_OW 266
31415: ST_TO_ADDR
// if btype = b_armoury then
31416: LD_VAR 0 5
31420: PUSH
31421: LD_INT 4
31423: EQUAL
31424: IFFALSE 31434
// btype := b_barracks ;
31426: LD_ADDR_VAR 0 5
31430: PUSH
31431: LD_INT 5
31433: ST_TO_ADDR
// if btype = b_depot then
31434: LD_VAR 0 5
31438: PUSH
31439: LD_INT 0
31441: EQUAL
31442: IFFALSE 31452
// btype := b_warehouse ;
31444: LD_ADDR_VAR 0 5
31448: PUSH
31449: LD_INT 1
31451: ST_TO_ADDR
// if btype = b_workshop then
31452: LD_VAR 0 5
31456: PUSH
31457: LD_INT 2
31459: EQUAL
31460: IFFALSE 31470
// btype := b_factory ;
31462: LD_ADDR_VAR 0 5
31466: PUSH
31467: LD_INT 3
31469: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31470: LD_ADDR_VAR 0 4
31474: PUSH
31475: LD_VAR 0 5
31479: PPUSH
31480: LD_VAR 0 1
31484: PPUSH
31485: CALL_OW 248
31489: PPUSH
31490: CALL_OW 450
31494: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31495: LD_ADDR_VAR 0 2
31499: PUSH
31500: LD_VAR 0 3
31504: PPUSH
31505: LD_INT 1
31507: PPUSH
31508: CALL_OW 275
31512: PUSH
31513: LD_VAR 0 4
31517: PUSH
31518: LD_INT 1
31520: ARRAY
31521: GREATEREQUAL
31522: PUSH
31523: LD_VAR 0 3
31527: PPUSH
31528: LD_INT 2
31530: PPUSH
31531: CALL_OW 275
31535: PUSH
31536: LD_VAR 0 4
31540: PUSH
31541: LD_INT 2
31543: ARRAY
31544: GREATEREQUAL
31545: AND
31546: PUSH
31547: LD_VAR 0 3
31551: PPUSH
31552: LD_INT 3
31554: PPUSH
31555: CALL_OW 275
31559: PUSH
31560: LD_VAR 0 4
31564: PUSH
31565: LD_INT 3
31567: ARRAY
31568: GREATEREQUAL
31569: AND
31570: ST_TO_ADDR
// end ;
31571: LD_VAR 0 2
31575: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31576: LD_INT 0
31578: PPUSH
31579: PPUSH
31580: PPUSH
// pom := GetBase ( building ) ;
31581: LD_ADDR_VAR 0 4
31585: PUSH
31586: LD_VAR 0 1
31590: PPUSH
31591: CALL_OW 274
31595: ST_TO_ADDR
// if not pom then
31596: LD_VAR 0 4
31600: NOT
31601: IFFALSE 31605
// exit ;
31603: GO 31706
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31605: LD_ADDR_VAR 0 5
31609: PUSH
31610: LD_VAR 0 2
31614: PPUSH
31615: LD_VAR 0 1
31619: PPUSH
31620: CALL_OW 248
31624: PPUSH
31625: CALL_OW 450
31629: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31630: LD_ADDR_VAR 0 3
31634: PUSH
31635: LD_VAR 0 4
31639: PPUSH
31640: LD_INT 1
31642: PPUSH
31643: CALL_OW 275
31647: PUSH
31648: LD_VAR 0 5
31652: PUSH
31653: LD_INT 1
31655: ARRAY
31656: GREATEREQUAL
31657: PUSH
31658: LD_VAR 0 4
31662: PPUSH
31663: LD_INT 2
31665: PPUSH
31666: CALL_OW 275
31670: PUSH
31671: LD_VAR 0 5
31675: PUSH
31676: LD_INT 2
31678: ARRAY
31679: GREATEREQUAL
31680: AND
31681: PUSH
31682: LD_VAR 0 4
31686: PPUSH
31687: LD_INT 3
31689: PPUSH
31690: CALL_OW 275
31694: PUSH
31695: LD_VAR 0 5
31699: PUSH
31700: LD_INT 3
31702: ARRAY
31703: GREATEREQUAL
31704: AND
31705: ST_TO_ADDR
// end ;
31706: LD_VAR 0 3
31710: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31711: LD_INT 0
31713: PPUSH
31714: PPUSH
31715: PPUSH
31716: PPUSH
31717: PPUSH
31718: PPUSH
31719: PPUSH
31720: PPUSH
31721: PPUSH
31722: PPUSH
31723: PPUSH
// result := false ;
31724: LD_ADDR_VAR 0 8
31728: PUSH
31729: LD_INT 0
31731: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31732: LD_VAR 0 5
31736: NOT
31737: PUSH
31738: LD_VAR 0 1
31742: NOT
31743: OR
31744: PUSH
31745: LD_VAR 0 2
31749: NOT
31750: OR
31751: PUSH
31752: LD_VAR 0 3
31756: NOT
31757: OR
31758: IFFALSE 31762
// exit ;
31760: GO 32576
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31762: LD_ADDR_VAR 0 14
31766: PUSH
31767: LD_VAR 0 1
31771: PPUSH
31772: LD_VAR 0 2
31776: PPUSH
31777: LD_VAR 0 3
31781: PPUSH
31782: LD_VAR 0 4
31786: PPUSH
31787: LD_VAR 0 5
31791: PUSH
31792: LD_INT 1
31794: ARRAY
31795: PPUSH
31796: CALL_OW 248
31800: PPUSH
31801: LD_INT 0
31803: PPUSH
31804: CALL 33813 0 6
31808: ST_TO_ADDR
// if not hexes then
31809: LD_VAR 0 14
31813: NOT
31814: IFFALSE 31818
// exit ;
31816: GO 32576
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31818: LD_ADDR_VAR 0 17
31822: PUSH
31823: LD_VAR 0 5
31827: PPUSH
31828: LD_INT 22
31830: PUSH
31831: LD_VAR 0 13
31835: PPUSH
31836: CALL_OW 255
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 2
31847: PUSH
31848: LD_INT 30
31850: PUSH
31851: LD_INT 0
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: LD_INT 30
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: LIST
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PPUSH
31877: CALL_OW 72
31881: ST_TO_ADDR
// for i = 1 to hexes do
31882: LD_ADDR_VAR 0 9
31886: PUSH
31887: DOUBLE
31888: LD_INT 1
31890: DEC
31891: ST_TO_ADDR
31892: LD_VAR 0 14
31896: PUSH
31897: FOR_TO
31898: IFFALSE 32574
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31900: LD_ADDR_VAR 0 13
31904: PUSH
31905: LD_VAR 0 14
31909: PUSH
31910: LD_VAR 0 9
31914: ARRAY
31915: PUSH
31916: LD_INT 1
31918: ARRAY
31919: PPUSH
31920: LD_VAR 0 14
31924: PUSH
31925: LD_VAR 0 9
31929: ARRAY
31930: PUSH
31931: LD_INT 2
31933: ARRAY
31934: PPUSH
31935: CALL_OW 428
31939: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31940: LD_VAR 0 14
31944: PUSH
31945: LD_VAR 0 9
31949: ARRAY
31950: PUSH
31951: LD_INT 1
31953: ARRAY
31954: PPUSH
31955: LD_VAR 0 14
31959: PUSH
31960: LD_VAR 0 9
31964: ARRAY
31965: PUSH
31966: LD_INT 2
31968: ARRAY
31969: PPUSH
31970: CALL_OW 351
31974: PUSH
31975: LD_VAR 0 14
31979: PUSH
31980: LD_VAR 0 9
31984: ARRAY
31985: PUSH
31986: LD_INT 1
31988: ARRAY
31989: PPUSH
31990: LD_VAR 0 14
31994: PUSH
31995: LD_VAR 0 9
31999: ARRAY
32000: PUSH
32001: LD_INT 2
32003: ARRAY
32004: PPUSH
32005: CALL_OW 488
32009: NOT
32010: OR
32011: PUSH
32012: LD_VAR 0 13
32016: PPUSH
32017: CALL_OW 247
32021: PUSH
32022: LD_INT 3
32024: EQUAL
32025: OR
32026: IFFALSE 32032
// exit ;
32028: POP
32029: POP
32030: GO 32576
// if not tmp then
32032: LD_VAR 0 13
32036: NOT
32037: IFFALSE 32041
// continue ;
32039: GO 31897
// result := true ;
32041: LD_ADDR_VAR 0 8
32045: PUSH
32046: LD_INT 1
32048: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32049: LD_VAR 0 6
32053: PUSH
32054: LD_VAR 0 13
32058: PPUSH
32059: CALL_OW 247
32063: PUSH
32064: LD_INT 2
32066: EQUAL
32067: AND
32068: PUSH
32069: LD_VAR 0 13
32073: PPUSH
32074: CALL_OW 263
32078: PUSH
32079: LD_INT 1
32081: EQUAL
32082: AND
32083: IFFALSE 32247
// begin if IsDrivenBy ( tmp ) then
32085: LD_VAR 0 13
32089: PPUSH
32090: CALL_OW 311
32094: IFFALSE 32098
// continue ;
32096: GO 31897
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32098: LD_VAR 0 6
32102: PPUSH
32103: LD_INT 3
32105: PUSH
32106: LD_INT 60
32108: PUSH
32109: EMPTY
32110: LIST
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 3
32118: PUSH
32119: LD_INT 55
32121: PUSH
32122: EMPTY
32123: LIST
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PPUSH
32133: CALL_OW 72
32137: IFFALSE 32245
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32139: LD_ADDR_VAR 0 18
32143: PUSH
32144: LD_VAR 0 6
32148: PPUSH
32149: LD_INT 3
32151: PUSH
32152: LD_INT 60
32154: PUSH
32155: EMPTY
32156: LIST
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 3
32164: PUSH
32165: LD_INT 55
32167: PUSH
32168: EMPTY
32169: LIST
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PPUSH
32179: CALL_OW 72
32183: PUSH
32184: LD_INT 1
32186: ARRAY
32187: ST_TO_ADDR
// if IsInUnit ( driver ) then
32188: LD_VAR 0 18
32192: PPUSH
32193: CALL_OW 310
32197: IFFALSE 32208
// ComExit ( driver ) ;
32199: LD_VAR 0 18
32203: PPUSH
32204: CALL 56997 0 1
// AddComEnterUnit ( driver , tmp ) ;
32208: LD_VAR 0 18
32212: PPUSH
32213: LD_VAR 0 13
32217: PPUSH
32218: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32222: LD_VAR 0 18
32226: PPUSH
32227: LD_VAR 0 7
32231: PPUSH
32232: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32236: LD_VAR 0 18
32240: PPUSH
32241: CALL_OW 181
// end ; continue ;
32245: GO 31897
// end ; if not cleaners or not tmp in cleaners then
32247: LD_VAR 0 6
32251: NOT
32252: PUSH
32253: LD_VAR 0 13
32257: PUSH
32258: LD_VAR 0 6
32262: IN
32263: NOT
32264: OR
32265: IFFALSE 32572
// begin if dep then
32267: LD_VAR 0 17
32271: IFFALSE 32407
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32273: LD_ADDR_VAR 0 16
32277: PUSH
32278: LD_VAR 0 17
32282: PUSH
32283: LD_INT 1
32285: ARRAY
32286: PPUSH
32287: CALL_OW 250
32291: PPUSH
32292: LD_VAR 0 17
32296: PUSH
32297: LD_INT 1
32299: ARRAY
32300: PPUSH
32301: CALL_OW 254
32305: PPUSH
32306: LD_INT 5
32308: PPUSH
32309: CALL_OW 272
32313: PUSH
32314: LD_VAR 0 17
32318: PUSH
32319: LD_INT 1
32321: ARRAY
32322: PPUSH
32323: CALL_OW 251
32327: PPUSH
32328: LD_VAR 0 17
32332: PUSH
32333: LD_INT 1
32335: ARRAY
32336: PPUSH
32337: CALL_OW 254
32341: PPUSH
32342: LD_INT 5
32344: PPUSH
32345: CALL_OW 273
32349: PUSH
32350: EMPTY
32351: LIST
32352: LIST
32353: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32354: LD_VAR 0 16
32358: PUSH
32359: LD_INT 1
32361: ARRAY
32362: PPUSH
32363: LD_VAR 0 16
32367: PUSH
32368: LD_INT 2
32370: ARRAY
32371: PPUSH
32372: CALL_OW 488
32376: IFFALSE 32407
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32378: LD_VAR 0 13
32382: PPUSH
32383: LD_VAR 0 16
32387: PUSH
32388: LD_INT 1
32390: ARRAY
32391: PPUSH
32392: LD_VAR 0 16
32396: PUSH
32397: LD_INT 2
32399: ARRAY
32400: PPUSH
32401: CALL_OW 111
// continue ;
32405: GO 31897
// end ; end ; r := GetDir ( tmp ) ;
32407: LD_ADDR_VAR 0 15
32411: PUSH
32412: LD_VAR 0 13
32416: PPUSH
32417: CALL_OW 254
32421: ST_TO_ADDR
// if r = 5 then
32422: LD_VAR 0 15
32426: PUSH
32427: LD_INT 5
32429: EQUAL
32430: IFFALSE 32440
// r := 0 ;
32432: LD_ADDR_VAR 0 15
32436: PUSH
32437: LD_INT 0
32439: ST_TO_ADDR
// for j = r to 5 do
32440: LD_ADDR_VAR 0 10
32444: PUSH
32445: DOUBLE
32446: LD_VAR 0 15
32450: DEC
32451: ST_TO_ADDR
32452: LD_INT 5
32454: PUSH
32455: FOR_TO
32456: IFFALSE 32570
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32458: LD_ADDR_VAR 0 11
32462: PUSH
32463: LD_VAR 0 13
32467: PPUSH
32468: CALL_OW 250
32472: PPUSH
32473: LD_VAR 0 10
32477: PPUSH
32478: LD_INT 2
32480: PPUSH
32481: CALL_OW 272
32485: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32486: LD_ADDR_VAR 0 12
32490: PUSH
32491: LD_VAR 0 13
32495: PPUSH
32496: CALL_OW 251
32500: PPUSH
32501: LD_VAR 0 10
32505: PPUSH
32506: LD_INT 2
32508: PPUSH
32509: CALL_OW 273
32513: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32514: LD_VAR 0 11
32518: PPUSH
32519: LD_VAR 0 12
32523: PPUSH
32524: CALL_OW 488
32528: PUSH
32529: LD_VAR 0 11
32533: PPUSH
32534: LD_VAR 0 12
32538: PPUSH
32539: CALL_OW 428
32543: NOT
32544: AND
32545: IFFALSE 32568
// begin ComMoveXY ( tmp , _x , _y ) ;
32547: LD_VAR 0 13
32551: PPUSH
32552: LD_VAR 0 11
32556: PPUSH
32557: LD_VAR 0 12
32561: PPUSH
32562: CALL_OW 111
// break ;
32566: GO 32570
// end ; end ;
32568: GO 32455
32570: POP
32571: POP
// end ; end ;
32572: GO 31897
32574: POP
32575: POP
// end ;
32576: LD_VAR 0 8
32580: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32581: LD_INT 0
32583: PPUSH
// result := true ;
32584: LD_ADDR_VAR 0 3
32588: PUSH
32589: LD_INT 1
32591: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32592: LD_VAR 0 2
32596: PUSH
32597: LD_INT 24
32599: DOUBLE
32600: EQUAL
32601: IFTRUE 32611
32603: LD_INT 33
32605: DOUBLE
32606: EQUAL
32607: IFTRUE 32611
32609: GO 32636
32611: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32612: LD_ADDR_VAR 0 3
32616: PUSH
32617: LD_INT 32
32619: PPUSH
32620: LD_VAR 0 1
32624: PPUSH
32625: CALL_OW 321
32629: PUSH
32630: LD_INT 2
32632: EQUAL
32633: ST_TO_ADDR
32634: GO 32956
32636: LD_INT 20
32638: DOUBLE
32639: EQUAL
32640: IFTRUE 32644
32642: GO 32669
32644: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32645: LD_ADDR_VAR 0 3
32649: PUSH
32650: LD_INT 6
32652: PPUSH
32653: LD_VAR 0 1
32657: PPUSH
32658: CALL_OW 321
32662: PUSH
32663: LD_INT 2
32665: EQUAL
32666: ST_TO_ADDR
32667: GO 32956
32669: LD_INT 22
32671: DOUBLE
32672: EQUAL
32673: IFTRUE 32683
32675: LD_INT 36
32677: DOUBLE
32678: EQUAL
32679: IFTRUE 32683
32681: GO 32708
32683: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32684: LD_ADDR_VAR 0 3
32688: PUSH
32689: LD_INT 15
32691: PPUSH
32692: LD_VAR 0 1
32696: PPUSH
32697: CALL_OW 321
32701: PUSH
32702: LD_INT 2
32704: EQUAL
32705: ST_TO_ADDR
32706: GO 32956
32708: LD_INT 30
32710: DOUBLE
32711: EQUAL
32712: IFTRUE 32716
32714: GO 32741
32716: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32717: LD_ADDR_VAR 0 3
32721: PUSH
32722: LD_INT 20
32724: PPUSH
32725: LD_VAR 0 1
32729: PPUSH
32730: CALL_OW 321
32734: PUSH
32735: LD_INT 2
32737: EQUAL
32738: ST_TO_ADDR
32739: GO 32956
32741: LD_INT 28
32743: DOUBLE
32744: EQUAL
32745: IFTRUE 32755
32747: LD_INT 21
32749: DOUBLE
32750: EQUAL
32751: IFTRUE 32755
32753: GO 32780
32755: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32756: LD_ADDR_VAR 0 3
32760: PUSH
32761: LD_INT 21
32763: PPUSH
32764: LD_VAR 0 1
32768: PPUSH
32769: CALL_OW 321
32773: PUSH
32774: LD_INT 2
32776: EQUAL
32777: ST_TO_ADDR
32778: GO 32956
32780: LD_INT 16
32782: DOUBLE
32783: EQUAL
32784: IFTRUE 32788
32786: GO 32815
32788: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32789: LD_ADDR_VAR 0 3
32793: PUSH
32794: LD_EXP 41
32798: PPUSH
32799: LD_VAR 0 1
32803: PPUSH
32804: CALL_OW 321
32808: PUSH
32809: LD_INT 2
32811: EQUAL
32812: ST_TO_ADDR
32813: GO 32956
32815: LD_INT 19
32817: DOUBLE
32818: EQUAL
32819: IFTRUE 32829
32821: LD_INT 23
32823: DOUBLE
32824: EQUAL
32825: IFTRUE 32829
32827: GO 32856
32829: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32830: LD_ADDR_VAR 0 3
32834: PUSH
32835: LD_EXP 40
32839: PPUSH
32840: LD_VAR 0 1
32844: PPUSH
32845: CALL_OW 321
32849: PUSH
32850: LD_INT 2
32852: EQUAL
32853: ST_TO_ADDR
32854: GO 32956
32856: LD_INT 17
32858: DOUBLE
32859: EQUAL
32860: IFTRUE 32864
32862: GO 32889
32864: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32865: LD_ADDR_VAR 0 3
32869: PUSH
32870: LD_INT 39
32872: PPUSH
32873: LD_VAR 0 1
32877: PPUSH
32878: CALL_OW 321
32882: PUSH
32883: LD_INT 2
32885: EQUAL
32886: ST_TO_ADDR
32887: GO 32956
32889: LD_INT 18
32891: DOUBLE
32892: EQUAL
32893: IFTRUE 32897
32895: GO 32922
32897: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32898: LD_ADDR_VAR 0 3
32902: PUSH
32903: LD_INT 40
32905: PPUSH
32906: LD_VAR 0 1
32910: PPUSH
32911: CALL_OW 321
32915: PUSH
32916: LD_INT 2
32918: EQUAL
32919: ST_TO_ADDR
32920: GO 32956
32922: LD_INT 27
32924: DOUBLE
32925: EQUAL
32926: IFTRUE 32930
32928: GO 32955
32930: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32931: LD_ADDR_VAR 0 3
32935: PUSH
32936: LD_INT 35
32938: PPUSH
32939: LD_VAR 0 1
32943: PPUSH
32944: CALL_OW 321
32948: PUSH
32949: LD_INT 2
32951: EQUAL
32952: ST_TO_ADDR
32953: GO 32956
32955: POP
// end ;
32956: LD_VAR 0 3
32960: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32961: LD_INT 0
32963: PPUSH
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
32969: PPUSH
32970: PPUSH
32971: PPUSH
32972: PPUSH
32973: PPUSH
// result := false ;
32974: LD_ADDR_VAR 0 6
32978: PUSH
32979: LD_INT 0
32981: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32982: LD_VAR 0 1
32986: NOT
32987: PUSH
32988: LD_VAR 0 1
32992: PPUSH
32993: CALL_OW 266
32997: PUSH
32998: LD_INT 0
33000: PUSH
33001: LD_INT 1
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: IN
33008: NOT
33009: OR
33010: PUSH
33011: LD_VAR 0 2
33015: NOT
33016: OR
33017: PUSH
33018: LD_VAR 0 5
33022: PUSH
33023: LD_INT 0
33025: PUSH
33026: LD_INT 1
33028: PUSH
33029: LD_INT 2
33031: PUSH
33032: LD_INT 3
33034: PUSH
33035: LD_INT 4
33037: PUSH
33038: LD_INT 5
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: IN
33049: NOT
33050: OR
33051: PUSH
33052: LD_VAR 0 3
33056: PPUSH
33057: LD_VAR 0 4
33061: PPUSH
33062: CALL_OW 488
33066: NOT
33067: OR
33068: IFFALSE 33072
// exit ;
33070: GO 33808
// side := GetSide ( depot ) ;
33072: LD_ADDR_VAR 0 9
33076: PUSH
33077: LD_VAR 0 1
33081: PPUSH
33082: CALL_OW 255
33086: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33087: LD_VAR 0 9
33091: PPUSH
33092: LD_VAR 0 2
33096: PPUSH
33097: CALL 32581 0 2
33101: NOT
33102: IFFALSE 33106
// exit ;
33104: GO 33808
// pom := GetBase ( depot ) ;
33106: LD_ADDR_VAR 0 10
33110: PUSH
33111: LD_VAR 0 1
33115: PPUSH
33116: CALL_OW 274
33120: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33121: LD_ADDR_VAR 0 11
33125: PUSH
33126: LD_VAR 0 2
33130: PPUSH
33131: LD_VAR 0 1
33135: PPUSH
33136: CALL_OW 248
33140: PPUSH
33141: CALL_OW 450
33145: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33146: LD_VAR 0 10
33150: PPUSH
33151: LD_INT 1
33153: PPUSH
33154: CALL_OW 275
33158: PUSH
33159: LD_VAR 0 11
33163: PUSH
33164: LD_INT 1
33166: ARRAY
33167: GREATEREQUAL
33168: PUSH
33169: LD_VAR 0 10
33173: PPUSH
33174: LD_INT 2
33176: PPUSH
33177: CALL_OW 275
33181: PUSH
33182: LD_VAR 0 11
33186: PUSH
33187: LD_INT 2
33189: ARRAY
33190: GREATEREQUAL
33191: AND
33192: PUSH
33193: LD_VAR 0 10
33197: PPUSH
33198: LD_INT 3
33200: PPUSH
33201: CALL_OW 275
33205: PUSH
33206: LD_VAR 0 11
33210: PUSH
33211: LD_INT 3
33213: ARRAY
33214: GREATEREQUAL
33215: AND
33216: NOT
33217: IFFALSE 33221
// exit ;
33219: GO 33808
// if GetBType ( depot ) = b_depot then
33221: LD_VAR 0 1
33225: PPUSH
33226: CALL_OW 266
33230: PUSH
33231: LD_INT 0
33233: EQUAL
33234: IFFALSE 33246
// dist := 28 else
33236: LD_ADDR_VAR 0 14
33240: PUSH
33241: LD_INT 28
33243: ST_TO_ADDR
33244: GO 33254
// dist := 36 ;
33246: LD_ADDR_VAR 0 14
33250: PUSH
33251: LD_INT 36
33253: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33254: LD_VAR 0 1
33258: PPUSH
33259: LD_VAR 0 3
33263: PPUSH
33264: LD_VAR 0 4
33268: PPUSH
33269: CALL_OW 297
33273: PUSH
33274: LD_VAR 0 14
33278: GREATER
33279: IFFALSE 33283
// exit ;
33281: GO 33808
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33283: LD_ADDR_VAR 0 12
33287: PUSH
33288: LD_VAR 0 2
33292: PPUSH
33293: LD_VAR 0 3
33297: PPUSH
33298: LD_VAR 0 4
33302: PPUSH
33303: LD_VAR 0 5
33307: PPUSH
33308: LD_VAR 0 1
33312: PPUSH
33313: CALL_OW 248
33317: PPUSH
33318: LD_INT 0
33320: PPUSH
33321: CALL 33813 0 6
33325: ST_TO_ADDR
// if not hexes then
33326: LD_VAR 0 12
33330: NOT
33331: IFFALSE 33335
// exit ;
33333: GO 33808
// hex := GetHexInfo ( x , y ) ;
33335: LD_ADDR_VAR 0 15
33339: PUSH
33340: LD_VAR 0 3
33344: PPUSH
33345: LD_VAR 0 4
33349: PPUSH
33350: CALL_OW 546
33354: ST_TO_ADDR
// if hex [ 1 ] then
33355: LD_VAR 0 15
33359: PUSH
33360: LD_INT 1
33362: ARRAY
33363: IFFALSE 33367
// exit ;
33365: GO 33808
// height := hex [ 2 ] ;
33367: LD_ADDR_VAR 0 13
33371: PUSH
33372: LD_VAR 0 15
33376: PUSH
33377: LD_INT 2
33379: ARRAY
33380: ST_TO_ADDR
// for i = 1 to hexes do
33381: LD_ADDR_VAR 0 7
33385: PUSH
33386: DOUBLE
33387: LD_INT 1
33389: DEC
33390: ST_TO_ADDR
33391: LD_VAR 0 12
33395: PUSH
33396: FOR_TO
33397: IFFALSE 33727
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33399: LD_VAR 0 12
33403: PUSH
33404: LD_VAR 0 7
33408: ARRAY
33409: PUSH
33410: LD_INT 1
33412: ARRAY
33413: PPUSH
33414: LD_VAR 0 12
33418: PUSH
33419: LD_VAR 0 7
33423: ARRAY
33424: PUSH
33425: LD_INT 2
33427: ARRAY
33428: PPUSH
33429: CALL_OW 488
33433: NOT
33434: PUSH
33435: LD_VAR 0 12
33439: PUSH
33440: LD_VAR 0 7
33444: ARRAY
33445: PUSH
33446: LD_INT 1
33448: ARRAY
33449: PPUSH
33450: LD_VAR 0 12
33454: PUSH
33455: LD_VAR 0 7
33459: ARRAY
33460: PUSH
33461: LD_INT 2
33463: ARRAY
33464: PPUSH
33465: CALL_OW 428
33469: PUSH
33470: LD_INT 0
33472: GREATER
33473: OR
33474: PUSH
33475: LD_VAR 0 12
33479: PUSH
33480: LD_VAR 0 7
33484: ARRAY
33485: PUSH
33486: LD_INT 1
33488: ARRAY
33489: PPUSH
33490: LD_VAR 0 12
33494: PUSH
33495: LD_VAR 0 7
33499: ARRAY
33500: PUSH
33501: LD_INT 2
33503: ARRAY
33504: PPUSH
33505: CALL_OW 351
33509: OR
33510: IFFALSE 33516
// exit ;
33512: POP
33513: POP
33514: GO 33808
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33516: LD_ADDR_VAR 0 8
33520: PUSH
33521: LD_VAR 0 12
33525: PUSH
33526: LD_VAR 0 7
33530: ARRAY
33531: PUSH
33532: LD_INT 1
33534: ARRAY
33535: PPUSH
33536: LD_VAR 0 12
33540: PUSH
33541: LD_VAR 0 7
33545: ARRAY
33546: PUSH
33547: LD_INT 2
33549: ARRAY
33550: PPUSH
33551: CALL_OW 546
33555: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33556: LD_VAR 0 8
33560: PUSH
33561: LD_INT 1
33563: ARRAY
33564: PUSH
33565: LD_VAR 0 8
33569: PUSH
33570: LD_INT 2
33572: ARRAY
33573: PUSH
33574: LD_VAR 0 13
33578: PUSH
33579: LD_INT 2
33581: PLUS
33582: GREATER
33583: OR
33584: PUSH
33585: LD_VAR 0 8
33589: PUSH
33590: LD_INT 2
33592: ARRAY
33593: PUSH
33594: LD_VAR 0 13
33598: PUSH
33599: LD_INT 2
33601: MINUS
33602: LESS
33603: OR
33604: PUSH
33605: LD_VAR 0 8
33609: PUSH
33610: LD_INT 3
33612: ARRAY
33613: PUSH
33614: LD_INT 0
33616: PUSH
33617: LD_INT 8
33619: PUSH
33620: LD_INT 9
33622: PUSH
33623: LD_INT 10
33625: PUSH
33626: LD_INT 11
33628: PUSH
33629: LD_INT 12
33631: PUSH
33632: LD_INT 13
33634: PUSH
33635: LD_INT 16
33637: PUSH
33638: LD_INT 17
33640: PUSH
33641: LD_INT 18
33643: PUSH
33644: LD_INT 19
33646: PUSH
33647: LD_INT 20
33649: PUSH
33650: LD_INT 21
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: LIST
33666: LIST
33667: IN
33668: NOT
33669: OR
33670: PUSH
33671: LD_VAR 0 8
33675: PUSH
33676: LD_INT 5
33678: ARRAY
33679: NOT
33680: OR
33681: PUSH
33682: LD_VAR 0 8
33686: PUSH
33687: LD_INT 6
33689: ARRAY
33690: PUSH
33691: LD_INT 1
33693: PUSH
33694: LD_INT 2
33696: PUSH
33697: LD_INT 7
33699: PUSH
33700: LD_INT 9
33702: PUSH
33703: LD_INT 10
33705: PUSH
33706: LD_INT 11
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: IN
33717: NOT
33718: OR
33719: IFFALSE 33725
// exit ;
33721: POP
33722: POP
33723: GO 33808
// end ;
33725: GO 33396
33727: POP
33728: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33729: LD_VAR 0 9
33733: PPUSH
33734: LD_VAR 0 3
33738: PPUSH
33739: LD_VAR 0 4
33743: PPUSH
33744: LD_INT 20
33746: PPUSH
33747: CALL 25754 0 4
33751: PUSH
33752: LD_INT 4
33754: ARRAY
33755: IFFALSE 33759
// exit ;
33757: GO 33808
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33759: LD_VAR 0 2
33763: PUSH
33764: LD_INT 29
33766: PUSH
33767: LD_INT 30
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: IN
33774: PUSH
33775: LD_VAR 0 3
33779: PPUSH
33780: LD_VAR 0 4
33784: PPUSH
33785: LD_VAR 0 9
33789: PPUSH
33790: CALL_OW 440
33794: NOT
33795: AND
33796: IFFALSE 33800
// exit ;
33798: GO 33808
// result := true ;
33800: LD_ADDR_VAR 0 6
33804: PUSH
33805: LD_INT 1
33807: ST_TO_ADDR
// end ;
33808: LD_VAR 0 6
33812: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33813: LD_INT 0
33815: PPUSH
33816: PPUSH
33817: PPUSH
33818: PPUSH
33819: PPUSH
33820: PPUSH
33821: PPUSH
33822: PPUSH
33823: PPUSH
33824: PPUSH
33825: PPUSH
33826: PPUSH
33827: PPUSH
33828: PPUSH
33829: PPUSH
33830: PPUSH
33831: PPUSH
33832: PPUSH
33833: PPUSH
33834: PPUSH
33835: PPUSH
33836: PPUSH
33837: PPUSH
33838: PPUSH
33839: PPUSH
33840: PPUSH
33841: PPUSH
33842: PPUSH
33843: PPUSH
33844: PPUSH
33845: PPUSH
33846: PPUSH
33847: PPUSH
33848: PPUSH
33849: PPUSH
33850: PPUSH
33851: PPUSH
33852: PPUSH
33853: PPUSH
33854: PPUSH
33855: PPUSH
33856: PPUSH
33857: PPUSH
33858: PPUSH
33859: PPUSH
33860: PPUSH
33861: PPUSH
33862: PPUSH
33863: PPUSH
33864: PPUSH
33865: PPUSH
33866: PPUSH
33867: PPUSH
33868: PPUSH
33869: PPUSH
33870: PPUSH
33871: PPUSH
33872: PPUSH
// result = [ ] ;
33873: LD_ADDR_VAR 0 7
33877: PUSH
33878: EMPTY
33879: ST_TO_ADDR
// temp_list = [ ] ;
33880: LD_ADDR_VAR 0 9
33884: PUSH
33885: EMPTY
33886: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33887: LD_VAR 0 4
33891: PUSH
33892: LD_INT 0
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: LD_INT 2
33900: PUSH
33901: LD_INT 3
33903: PUSH
33904: LD_INT 4
33906: PUSH
33907: LD_INT 5
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: IN
33918: NOT
33919: PUSH
33920: LD_VAR 0 1
33924: PUSH
33925: LD_INT 0
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: EMPTY
33932: LIST
33933: LIST
33934: IN
33935: PUSH
33936: LD_VAR 0 5
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: LD_INT 2
33946: PUSH
33947: LD_INT 3
33949: PUSH
33950: EMPTY
33951: LIST
33952: LIST
33953: LIST
33954: IN
33955: NOT
33956: AND
33957: OR
33958: IFFALSE 33962
// exit ;
33960: GO 52353
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33962: LD_VAR 0 1
33966: PUSH
33967: LD_INT 6
33969: PUSH
33970: LD_INT 7
33972: PUSH
33973: LD_INT 8
33975: PUSH
33976: LD_INT 13
33978: PUSH
33979: LD_INT 12
33981: PUSH
33982: LD_INT 15
33984: PUSH
33985: LD_INT 11
33987: PUSH
33988: LD_INT 14
33990: PUSH
33991: LD_INT 10
33993: PUSH
33994: EMPTY
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: IN
34005: IFFALSE 34015
// btype = b_lab ;
34007: LD_ADDR_VAR 0 1
34011: PUSH
34012: LD_INT 6
34014: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34015: LD_VAR 0 6
34019: PUSH
34020: LD_INT 0
34022: PUSH
34023: LD_INT 1
34025: PUSH
34026: LD_INT 2
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: LIST
34033: IN
34034: NOT
34035: PUSH
34036: LD_VAR 0 1
34040: PUSH
34041: LD_INT 0
34043: PUSH
34044: LD_INT 1
34046: PUSH
34047: LD_INT 2
34049: PUSH
34050: LD_INT 3
34052: PUSH
34053: LD_INT 6
34055: PUSH
34056: LD_INT 36
34058: PUSH
34059: LD_INT 4
34061: PUSH
34062: LD_INT 5
34064: PUSH
34065: LD_INT 31
34067: PUSH
34068: LD_INT 32
34070: PUSH
34071: LD_INT 33
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: IN
34087: NOT
34088: PUSH
34089: LD_VAR 0 6
34093: PUSH
34094: LD_INT 1
34096: EQUAL
34097: AND
34098: OR
34099: PUSH
34100: LD_VAR 0 1
34104: PUSH
34105: LD_INT 2
34107: PUSH
34108: LD_INT 3
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: IN
34115: NOT
34116: PUSH
34117: LD_VAR 0 6
34121: PUSH
34122: LD_INT 2
34124: EQUAL
34125: AND
34126: OR
34127: IFFALSE 34137
// mode = 0 ;
34129: LD_ADDR_VAR 0 6
34133: PUSH
34134: LD_INT 0
34136: ST_TO_ADDR
// case mode of 0 :
34137: LD_VAR 0 6
34141: PUSH
34142: LD_INT 0
34144: DOUBLE
34145: EQUAL
34146: IFTRUE 34150
34148: GO 45603
34150: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34151: LD_ADDR_VAR 0 11
34155: PUSH
34156: LD_INT 0
34158: PUSH
34159: LD_INT 0
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 0
34168: PUSH
34169: LD_INT 1
34171: NEG
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 1
34179: PUSH
34180: LD_INT 0
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 1
34189: PUSH
34190: LD_INT 1
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 0
34199: PUSH
34200: LD_INT 1
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 1
34209: NEG
34210: PUSH
34211: LD_INT 0
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: LD_INT 1
34220: NEG
34221: PUSH
34222: LD_INT 1
34224: NEG
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: PUSH
34230: LD_INT 1
34232: NEG
34233: PUSH
34234: LD_INT 2
34236: NEG
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 0
34244: PUSH
34245: LD_INT 2
34247: NEG
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 1
34255: PUSH
34256: LD_INT 1
34258: NEG
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: LD_INT 2
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: LD_INT 2
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 1
34286: NEG
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: PUSH
34298: LD_INT 3
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: LD_INT 0
34307: PUSH
34308: LD_INT 3
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: LD_INT 2
34321: PUSH
34322: EMPTY
34323: LIST
34324: LIST
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: LIST
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34344: LD_ADDR_VAR 0 12
34348: PUSH
34349: LD_INT 0
34351: PUSH
34352: LD_INT 0
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 0
34361: PUSH
34362: LD_INT 1
34364: NEG
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: LD_INT 1
34372: PUSH
34373: LD_INT 0
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 1
34382: PUSH
34383: LD_INT 1
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 0
34392: PUSH
34393: LD_INT 1
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 1
34402: NEG
34403: PUSH
34404: LD_INT 0
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: NEG
34414: PUSH
34415: LD_INT 1
34417: NEG
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: PUSH
34423: LD_INT 1
34425: PUSH
34426: LD_INT 1
34428: NEG
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 2
34436: PUSH
34437: LD_INT 0
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: PUSH
34444: LD_INT 2
34446: PUSH
34447: LD_INT 1
34449: PUSH
34450: EMPTY
34451: LIST
34452: LIST
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: LD_INT 1
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PUSH
34465: LD_INT 2
34467: NEG
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 2
34478: NEG
34479: PUSH
34480: LD_INT 1
34482: NEG
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 2
34490: NEG
34491: PUSH
34492: LD_INT 1
34494: PUSH
34495: EMPTY
34496: LIST
34497: LIST
34498: PUSH
34499: LD_INT 3
34501: NEG
34502: PUSH
34503: LD_INT 0
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 3
34512: NEG
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: LIST
34526: LIST
34527: LIST
34528: LIST
34529: LIST
34530: LIST
34531: LIST
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34540: LD_ADDR_VAR 0 13
34544: PUSH
34545: LD_INT 0
34547: PUSH
34548: LD_INT 0
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 0
34557: PUSH
34558: LD_INT 1
34560: NEG
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: LD_INT 0
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 1
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 0
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 1
34598: NEG
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 1
34609: NEG
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: LD_INT 2
34625: NEG
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 2
34633: PUSH
34634: LD_INT 1
34636: PUSH
34637: EMPTY
34638: LIST
34639: LIST
34640: PUSH
34641: LD_INT 2
34643: PUSH
34644: LD_INT 2
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 1
34653: PUSH
34654: LD_INT 2
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 2
34663: NEG
34664: PUSH
34665: LD_INT 1
34667: NEG
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 2
34675: NEG
34676: PUSH
34677: LD_INT 2
34679: NEG
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 2
34687: NEG
34688: PUSH
34689: LD_INT 3
34691: NEG
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 3
34699: NEG
34700: PUSH
34701: LD_INT 2
34703: NEG
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 3
34711: NEG
34712: PUSH
34713: LD_INT 3
34715: NEG
34716: PUSH
34717: EMPTY
34718: LIST
34719: LIST
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34739: LD_ADDR_VAR 0 14
34743: PUSH
34744: LD_INT 0
34746: PUSH
34747: LD_INT 0
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 0
34756: PUSH
34757: LD_INT 1
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: PUSH
34768: LD_INT 0
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: LD_INT 1
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 0
34787: PUSH
34788: LD_INT 1
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 1
34797: NEG
34798: PUSH
34799: LD_INT 0
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: LD_INT 1
34812: NEG
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 1
34820: NEG
34821: PUSH
34822: LD_INT 2
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: LD_INT 2
34835: NEG
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: LD_INT 1
34846: NEG
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 1
34854: PUSH
34855: LD_INT 2
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 0
34864: PUSH
34865: LD_INT 2
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 1
34874: NEG
34875: PUSH
34876: LD_INT 1
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 1
34885: NEG
34886: PUSH
34887: LD_INT 3
34889: NEG
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 0
34897: PUSH
34898: LD_INT 3
34900: NEG
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 1
34908: PUSH
34909: LD_INT 2
34911: NEG
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: LIST
34921: LIST
34922: LIST
34923: LIST
34924: LIST
34925: LIST
34926: LIST
34927: LIST
34928: LIST
34929: LIST
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34935: LD_ADDR_VAR 0 15
34939: PUSH
34940: LD_INT 0
34942: PUSH
34943: LD_INT 0
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 0
34952: PUSH
34953: LD_INT 1
34955: NEG
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: LD_INT 0
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 1
34973: PUSH
34974: LD_INT 1
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 0
34983: PUSH
34984: LD_INT 1
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 1
34993: NEG
34994: PUSH
34995: LD_INT 0
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: LD_INT 1
35008: NEG
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 1
35016: PUSH
35017: LD_INT 1
35019: NEG
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 2
35027: PUSH
35028: LD_INT 0
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 2
35037: PUSH
35038: LD_INT 1
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 1
35047: NEG
35048: PUSH
35049: LD_INT 1
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 2
35058: NEG
35059: PUSH
35060: LD_INT 0
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 2
35069: NEG
35070: PUSH
35071: LD_INT 1
35073: NEG
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: PUSH
35079: LD_INT 2
35081: PUSH
35082: LD_INT 1
35084: NEG
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 3
35092: PUSH
35093: LD_INT 0
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 3
35102: PUSH
35103: LD_INT 1
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35128: LD_ADDR_VAR 0 16
35132: PUSH
35133: LD_INT 0
35135: PUSH
35136: LD_INT 0
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: LD_INT 0
35145: PUSH
35146: LD_INT 1
35148: NEG
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 1
35156: PUSH
35157: LD_INT 0
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: PUSH
35167: LD_INT 1
35169: PUSH
35170: EMPTY
35171: LIST
35172: LIST
35173: PUSH
35174: LD_INT 0
35176: PUSH
35177: LD_INT 1
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 1
35186: NEG
35187: PUSH
35188: LD_INT 0
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: NEG
35198: PUSH
35199: LD_INT 1
35201: NEG
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 1
35209: NEG
35210: PUSH
35211: LD_INT 2
35213: NEG
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 2
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 2
35231: PUSH
35232: LD_INT 2
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 1
35241: PUSH
35242: LD_INT 2
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 2
35251: NEG
35252: PUSH
35253: LD_INT 1
35255: NEG
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 2
35263: NEG
35264: PUSH
35265: LD_INT 2
35267: NEG
35268: PUSH
35269: EMPTY
35270: LIST
35271: LIST
35272: PUSH
35273: LD_INT 3
35275: PUSH
35276: LD_INT 2
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: LD_INT 3
35285: PUSH
35286: LD_INT 3
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 2
35295: PUSH
35296: LD_INT 3
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: LIST
35307: LIST
35308: LIST
35309: LIST
35310: LIST
35311: LIST
35312: LIST
35313: LIST
35314: LIST
35315: LIST
35316: LIST
35317: LIST
35318: LIST
35319: LIST
35320: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35321: LD_ADDR_VAR 0 17
35325: PUSH
35326: LD_INT 0
35328: PUSH
35329: LD_INT 0
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 0
35338: PUSH
35339: LD_INT 1
35341: NEG
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 1
35349: PUSH
35350: LD_INT 0
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: PUSH
35360: LD_INT 1
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 0
35369: PUSH
35370: LD_INT 1
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: LD_INT 0
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 1
35390: NEG
35391: PUSH
35392: LD_INT 1
35394: NEG
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 1
35402: NEG
35403: PUSH
35404: LD_INT 2
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: LD_INT 0
35414: PUSH
35415: LD_INT 2
35417: NEG
35418: PUSH
35419: EMPTY
35420: LIST
35421: LIST
35422: PUSH
35423: LD_INT 1
35425: PUSH
35426: LD_INT 1
35428: NEG
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: PUSH
35434: LD_INT 2
35436: PUSH
35437: LD_INT 0
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: LD_INT 2
35446: PUSH
35447: LD_INT 1
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: LD_INT 2
35456: PUSH
35457: LD_INT 2
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: PUSH
35464: LD_INT 1
35466: PUSH
35467: LD_INT 2
35469: PUSH
35470: EMPTY
35471: LIST
35472: LIST
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: LD_INT 2
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 1
35486: NEG
35487: PUSH
35488: LD_INT 1
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 2
35497: NEG
35498: PUSH
35499: LD_INT 0
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 2
35508: NEG
35509: PUSH
35510: LD_INT 1
35512: NEG
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: LD_INT 2
35520: NEG
35521: PUSH
35522: LD_INT 2
35524: NEG
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: LIST
35534: LIST
35535: LIST
35536: LIST
35537: LIST
35538: LIST
35539: LIST
35540: LIST
35541: LIST
35542: LIST
35543: LIST
35544: LIST
35545: LIST
35546: LIST
35547: LIST
35548: LIST
35549: LIST
35550: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35551: LD_ADDR_VAR 0 18
35555: PUSH
35556: LD_INT 0
35558: PUSH
35559: LD_INT 0
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 0
35568: PUSH
35569: LD_INT 1
35571: NEG
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 1
35579: PUSH
35580: LD_INT 0
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 1
35589: PUSH
35590: LD_INT 1
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 0
35599: PUSH
35600: LD_INT 1
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 1
35609: NEG
35610: PUSH
35611: LD_INT 0
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 1
35620: NEG
35621: PUSH
35622: LD_INT 1
35624: NEG
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: LD_INT 1
35632: NEG
35633: PUSH
35634: LD_INT 2
35636: NEG
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: LD_INT 2
35647: NEG
35648: PUSH
35649: EMPTY
35650: LIST
35651: LIST
35652: PUSH
35653: LD_INT 1
35655: PUSH
35656: LD_INT 1
35658: NEG
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: LD_INT 0
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 2
35676: PUSH
35677: LD_INT 1
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: LD_INT 2
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: LD_INT 2
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 0
35706: PUSH
35707: LD_INT 2
35709: PUSH
35710: EMPTY
35711: LIST
35712: LIST
35713: PUSH
35714: LD_INT 1
35716: NEG
35717: PUSH
35718: LD_INT 1
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 2
35727: NEG
35728: PUSH
35729: LD_INT 0
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 2
35738: NEG
35739: PUSH
35740: LD_INT 1
35742: NEG
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: LD_INT 2
35750: NEG
35751: PUSH
35752: LD_INT 2
35754: NEG
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35781: LD_ADDR_VAR 0 19
35785: PUSH
35786: LD_INT 0
35788: PUSH
35789: LD_INT 0
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: LD_INT 0
35798: PUSH
35799: LD_INT 1
35801: NEG
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 1
35809: PUSH
35810: LD_INT 0
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 1
35819: PUSH
35820: LD_INT 1
35822: PUSH
35823: EMPTY
35824: LIST
35825: LIST
35826: PUSH
35827: LD_INT 0
35829: PUSH
35830: LD_INT 1
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 1
35839: NEG
35840: PUSH
35841: LD_INT 0
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 1
35850: NEG
35851: PUSH
35852: LD_INT 1
35854: NEG
35855: PUSH
35856: EMPTY
35857: LIST
35858: LIST
35859: PUSH
35860: LD_INT 1
35862: NEG
35863: PUSH
35864: LD_INT 2
35866: NEG
35867: PUSH
35868: EMPTY
35869: LIST
35870: LIST
35871: PUSH
35872: LD_INT 0
35874: PUSH
35875: LD_INT 2
35877: NEG
35878: PUSH
35879: EMPTY
35880: LIST
35881: LIST
35882: PUSH
35883: LD_INT 1
35885: PUSH
35886: LD_INT 1
35888: NEG
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 2
35896: PUSH
35897: LD_INT 0
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 2
35906: PUSH
35907: LD_INT 1
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 2
35916: PUSH
35917: LD_INT 2
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: PUSH
35924: LD_INT 1
35926: PUSH
35927: LD_INT 2
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 0
35936: PUSH
35937: LD_INT 2
35939: PUSH
35940: EMPTY
35941: LIST
35942: LIST
35943: PUSH
35944: LD_INT 1
35946: NEG
35947: PUSH
35948: LD_INT 1
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: PUSH
35955: LD_INT 2
35957: NEG
35958: PUSH
35959: LD_INT 0
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 2
35968: NEG
35969: PUSH
35970: LD_INT 1
35972: NEG
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 2
35980: NEG
35981: PUSH
35982: LD_INT 2
35984: NEG
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: LIST
36001: LIST
36002: LIST
36003: LIST
36004: LIST
36005: LIST
36006: LIST
36007: LIST
36008: LIST
36009: LIST
36010: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36011: LD_ADDR_VAR 0 20
36015: PUSH
36016: LD_INT 0
36018: PUSH
36019: LD_INT 0
36021: PUSH
36022: EMPTY
36023: LIST
36024: LIST
36025: PUSH
36026: LD_INT 0
36028: PUSH
36029: LD_INT 1
36031: NEG
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 1
36039: PUSH
36040: LD_INT 0
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: PUSH
36050: LD_INT 1
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 0
36059: PUSH
36060: LD_INT 1
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: LD_INT 0
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 1
36080: NEG
36081: PUSH
36082: LD_INT 1
36084: NEG
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: LD_INT 1
36092: NEG
36093: PUSH
36094: LD_INT 2
36096: NEG
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: LD_INT 0
36104: PUSH
36105: LD_INT 2
36107: NEG
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: PUSH
36113: LD_INT 1
36115: PUSH
36116: LD_INT 1
36118: NEG
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 2
36126: PUSH
36127: LD_INT 0
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PUSH
36134: LD_INT 2
36136: PUSH
36137: LD_INT 1
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 2
36146: PUSH
36147: LD_INT 2
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: LD_INT 1
36156: PUSH
36157: LD_INT 2
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 0
36166: PUSH
36167: LD_INT 2
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: PUSH
36174: LD_INT 1
36176: NEG
36177: PUSH
36178: LD_INT 1
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: LD_INT 2
36187: NEG
36188: PUSH
36189: LD_INT 0
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 2
36198: NEG
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 2
36210: NEG
36211: PUSH
36212: LD_INT 2
36214: NEG
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: LIST
36227: LIST
36228: LIST
36229: LIST
36230: LIST
36231: LIST
36232: LIST
36233: LIST
36234: LIST
36235: LIST
36236: LIST
36237: LIST
36238: LIST
36239: LIST
36240: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36241: LD_ADDR_VAR 0 21
36245: PUSH
36246: LD_INT 0
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 0
36258: PUSH
36259: LD_INT 1
36261: NEG
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: LD_INT 0
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: LD_INT 1
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 0
36289: PUSH
36290: LD_INT 1
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 1
36299: NEG
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 1
36310: NEG
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 1
36322: NEG
36323: PUSH
36324: LD_INT 2
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 0
36334: PUSH
36335: LD_INT 2
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 1
36345: PUSH
36346: LD_INT 1
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: LD_INT 0
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 2
36366: PUSH
36367: LD_INT 1
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 2
36376: PUSH
36377: LD_INT 2
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 1
36386: PUSH
36387: LD_INT 2
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 0
36396: PUSH
36397: LD_INT 2
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 1
36406: NEG
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 2
36417: NEG
36418: PUSH
36419: LD_INT 0
36421: PUSH
36422: EMPTY
36423: LIST
36424: LIST
36425: PUSH
36426: LD_INT 2
36428: NEG
36429: PUSH
36430: LD_INT 1
36432: NEG
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 2
36440: NEG
36441: PUSH
36442: LD_INT 2
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: LIST
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36471: LD_ADDR_VAR 0 22
36475: PUSH
36476: LD_INT 0
36478: PUSH
36479: LD_INT 0
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 1
36491: NEG
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 1
36499: PUSH
36500: LD_INT 0
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 1
36509: PUSH
36510: LD_INT 1
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 0
36519: PUSH
36520: LD_INT 1
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 1
36529: NEG
36530: PUSH
36531: LD_INT 0
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 1
36540: NEG
36541: PUSH
36542: LD_INT 1
36544: NEG
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 1
36552: NEG
36553: PUSH
36554: LD_INT 2
36556: NEG
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 0
36564: PUSH
36565: LD_INT 2
36567: NEG
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: PUSH
36576: LD_INT 1
36578: NEG
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: LD_INT 2
36586: PUSH
36587: LD_INT 0
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 2
36596: PUSH
36597: LD_INT 1
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 2
36606: PUSH
36607: LD_INT 2
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 1
36616: PUSH
36617: LD_INT 2
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: LD_INT 2
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 1
36636: NEG
36637: PUSH
36638: LD_INT 1
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 2
36647: NEG
36648: PUSH
36649: LD_INT 0
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: LD_INT 2
36658: NEG
36659: PUSH
36660: LD_INT 1
36662: NEG
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 2
36670: NEG
36671: PUSH
36672: LD_INT 2
36674: NEG
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36701: LD_ADDR_VAR 0 23
36705: PUSH
36706: LD_INT 0
36708: PUSH
36709: LD_INT 0
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 0
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: LD_INT 0
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 1
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 0
36749: PUSH
36750: LD_INT 1
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 1
36759: NEG
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 1
36770: NEG
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: LD_INT 2
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 0
36794: PUSH
36795: LD_INT 2
36797: NEG
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: LD_INT 1
36808: NEG
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: PUSH
36817: LD_INT 0
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 2
36826: PUSH
36827: LD_INT 1
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: LD_INT 2
36836: PUSH
36837: LD_INT 2
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 1
36846: PUSH
36847: LD_INT 2
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 0
36856: PUSH
36857: LD_INT 2
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: LD_INT 1
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 2
36877: NEG
36878: PUSH
36879: LD_INT 0
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 2
36888: NEG
36889: PUSH
36890: LD_INT 1
36892: NEG
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 2
36900: NEG
36901: PUSH
36902: LD_INT 2
36904: NEG
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 2
36912: NEG
36913: PUSH
36914: LD_INT 3
36916: NEG
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: LD_INT 1
36924: NEG
36925: PUSH
36926: LD_INT 3
36928: NEG
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: LD_INT 1
36936: PUSH
36937: LD_INT 2
36939: NEG
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PUSH
36945: LD_INT 2
36947: PUSH
36948: LD_INT 1
36950: NEG
36951: PUSH
36952: EMPTY
36953: LIST
36954: LIST
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36981: LD_ADDR_VAR 0 24
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: LD_INT 0
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: LD_INT 1
37001: NEG
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 0
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 1
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 1
37039: NEG
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: NEG
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 1
37062: NEG
37063: PUSH
37064: LD_INT 2
37066: NEG
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: LD_INT 2
37077: NEG
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 1
37085: PUSH
37086: LD_INT 1
37088: NEG
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PUSH
37094: LD_INT 2
37096: PUSH
37097: LD_INT 0
37099: PUSH
37100: EMPTY
37101: LIST
37102: LIST
37103: PUSH
37104: LD_INT 2
37106: PUSH
37107: LD_INT 1
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: LD_INT 2
37116: PUSH
37117: LD_INT 2
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: PUSH
37124: LD_INT 1
37126: PUSH
37127: LD_INT 2
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 0
37136: PUSH
37137: LD_INT 2
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 1
37146: NEG
37147: PUSH
37148: LD_INT 1
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: LD_INT 2
37157: NEG
37158: PUSH
37159: LD_INT 0
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 2
37168: NEG
37169: PUSH
37170: LD_INT 1
37172: NEG
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 2
37180: NEG
37181: PUSH
37182: LD_INT 2
37184: NEG
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 1
37192: PUSH
37193: LD_INT 2
37195: NEG
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: LD_INT 2
37203: PUSH
37204: LD_INT 1
37206: NEG
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 3
37214: PUSH
37215: LD_INT 1
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 3
37224: PUSH
37225: LD_INT 2
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: LIST
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: LIST
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37257: LD_ADDR_VAR 0 25
37261: PUSH
37262: LD_INT 0
37264: PUSH
37265: LD_INT 0
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 0
37274: PUSH
37275: LD_INT 1
37277: NEG
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 1
37285: PUSH
37286: LD_INT 0
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 1
37295: PUSH
37296: LD_INT 1
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 0
37305: PUSH
37306: LD_INT 1
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 1
37315: NEG
37316: PUSH
37317: LD_INT 0
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 1
37326: NEG
37327: PUSH
37328: LD_INT 1
37330: NEG
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: LD_INT 1
37338: NEG
37339: PUSH
37340: LD_INT 2
37342: NEG
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: PUSH
37348: LD_INT 0
37350: PUSH
37351: LD_INT 2
37353: NEG
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 1
37361: PUSH
37362: LD_INT 1
37364: NEG
37365: PUSH
37366: EMPTY
37367: LIST
37368: LIST
37369: PUSH
37370: LD_INT 2
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 2
37382: PUSH
37383: LD_INT 1
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 2
37392: PUSH
37393: LD_INT 2
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 1
37402: PUSH
37403: LD_INT 2
37405: PUSH
37406: EMPTY
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 0
37412: PUSH
37413: LD_INT 2
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 1
37422: NEG
37423: PUSH
37424: LD_INT 1
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: LD_INT 2
37433: NEG
37434: PUSH
37435: LD_INT 0
37437: PUSH
37438: EMPTY
37439: LIST
37440: LIST
37441: PUSH
37442: LD_INT 2
37444: NEG
37445: PUSH
37446: LD_INT 1
37448: NEG
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PUSH
37454: LD_INT 2
37456: NEG
37457: PUSH
37458: LD_INT 2
37460: NEG
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: PUSH
37466: LD_INT 3
37468: PUSH
37469: LD_INT 1
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 3
37478: PUSH
37479: LD_INT 2
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 2
37488: PUSH
37489: LD_INT 3
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 1
37498: PUSH
37499: LD_INT 3
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: LIST
37510: LIST
37511: LIST
37512: LIST
37513: LIST
37514: LIST
37515: LIST
37516: LIST
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37531: LD_ADDR_VAR 0 26
37535: PUSH
37536: LD_INT 0
37538: PUSH
37539: LD_INT 0
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 0
37548: PUSH
37549: LD_INT 1
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: LD_INT 0
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 1
37569: PUSH
37570: LD_INT 1
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 0
37579: PUSH
37580: LD_INT 1
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 1
37589: NEG
37590: PUSH
37591: LD_INT 0
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: NEG
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 1
37612: NEG
37613: PUSH
37614: LD_INT 2
37616: NEG
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: PUSH
37622: LD_INT 0
37624: PUSH
37625: LD_INT 2
37627: NEG
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 1
37635: PUSH
37636: LD_INT 1
37638: NEG
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: LD_INT 0
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: LD_INT 2
37656: PUSH
37657: LD_INT 1
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PUSH
37664: LD_INT 2
37666: PUSH
37667: LD_INT 2
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 1
37676: PUSH
37677: LD_INT 2
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 0
37686: PUSH
37687: LD_INT 2
37689: PUSH
37690: EMPTY
37691: LIST
37692: LIST
37693: PUSH
37694: LD_INT 1
37696: NEG
37697: PUSH
37698: LD_INT 1
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 2
37707: NEG
37708: PUSH
37709: LD_INT 0
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: PUSH
37716: LD_INT 2
37718: NEG
37719: PUSH
37720: LD_INT 1
37722: NEG
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 2
37730: NEG
37731: PUSH
37732: LD_INT 2
37734: NEG
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: PUSH
37740: LD_INT 2
37742: PUSH
37743: LD_INT 3
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PUSH
37750: LD_INT 1
37752: PUSH
37753: LD_INT 3
37755: PUSH
37756: EMPTY
37757: LIST
37758: LIST
37759: PUSH
37760: LD_INT 1
37762: NEG
37763: PUSH
37764: LD_INT 2
37766: PUSH
37767: EMPTY
37768: LIST
37769: LIST
37770: PUSH
37771: LD_INT 2
37773: NEG
37774: PUSH
37775: LD_INT 1
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: LIST
37786: LIST
37787: LIST
37788: LIST
37789: LIST
37790: LIST
37791: LIST
37792: LIST
37793: LIST
37794: LIST
37795: LIST
37796: LIST
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37807: LD_ADDR_VAR 0 27
37811: PUSH
37812: LD_INT 0
37814: PUSH
37815: LD_INT 0
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 0
37824: PUSH
37825: LD_INT 1
37827: NEG
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 1
37835: PUSH
37836: LD_INT 0
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 1
37845: PUSH
37846: LD_INT 1
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 0
37855: PUSH
37856: LD_INT 1
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 1
37865: NEG
37866: PUSH
37867: LD_INT 0
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: LD_INT 1
37880: NEG
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 1
37888: NEG
37889: PUSH
37890: LD_INT 2
37892: NEG
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 0
37900: PUSH
37901: LD_INT 2
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 1
37911: PUSH
37912: LD_INT 1
37914: NEG
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 2
37922: PUSH
37923: LD_INT 0
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 2
37932: PUSH
37933: LD_INT 1
37935: PUSH
37936: EMPTY
37937: LIST
37938: LIST
37939: PUSH
37940: LD_INT 2
37942: PUSH
37943: LD_INT 2
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 1
37952: PUSH
37953: LD_INT 2
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 0
37962: PUSH
37963: LD_INT 2
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: PUSH
37970: LD_INT 1
37972: NEG
37973: PUSH
37974: LD_INT 1
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 2
37983: NEG
37984: PUSH
37985: LD_INT 0
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 2
37994: NEG
37995: PUSH
37996: LD_INT 1
37998: NEG
37999: PUSH
38000: EMPTY
38001: LIST
38002: LIST
38003: PUSH
38004: LD_INT 2
38006: NEG
38007: PUSH
38008: LD_INT 2
38010: NEG
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 1
38018: NEG
38019: PUSH
38020: LD_INT 2
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 2
38029: NEG
38030: PUSH
38031: LD_INT 1
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: PUSH
38038: LD_INT 3
38040: NEG
38041: PUSH
38042: LD_INT 1
38044: NEG
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 3
38052: NEG
38053: PUSH
38054: LD_INT 2
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38087: LD_ADDR_VAR 0 28
38091: PUSH
38092: LD_INT 0
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 0
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 1
38115: PUSH
38116: LD_INT 0
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 1
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 0
38135: PUSH
38136: LD_INT 1
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: NEG
38146: PUSH
38147: LD_INT 0
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 1
38156: NEG
38157: PUSH
38158: LD_INT 1
38160: NEG
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: LD_INT 1
38168: NEG
38169: PUSH
38170: LD_INT 2
38172: NEG
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 0
38180: PUSH
38181: LD_INT 2
38183: NEG
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 1
38191: PUSH
38192: LD_INT 1
38194: NEG
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 2
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 2
38212: PUSH
38213: LD_INT 1
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 2
38222: PUSH
38223: LD_INT 2
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 1
38232: PUSH
38233: LD_INT 2
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 0
38242: PUSH
38243: LD_INT 2
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: LD_INT 1
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 2
38263: NEG
38264: PUSH
38265: LD_INT 0
38267: PUSH
38268: EMPTY
38269: LIST
38270: LIST
38271: PUSH
38272: LD_INT 2
38274: NEG
38275: PUSH
38276: LD_INT 1
38278: NEG
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 2
38286: NEG
38287: PUSH
38288: LD_INT 2
38290: NEG
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 2
38298: NEG
38299: PUSH
38300: LD_INT 3
38302: NEG
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 1
38310: NEG
38311: PUSH
38312: LD_INT 3
38314: NEG
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 3
38322: NEG
38323: PUSH
38324: LD_INT 1
38326: NEG
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 3
38334: NEG
38335: PUSH
38336: LD_INT 2
38338: NEG
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: LIST
38348: LIST
38349: LIST
38350: LIST
38351: LIST
38352: LIST
38353: LIST
38354: LIST
38355: LIST
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: LIST
38361: LIST
38362: LIST
38363: LIST
38364: LIST
38365: LIST
38366: LIST
38367: LIST
38368: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38369: LD_ADDR_VAR 0 29
38373: PUSH
38374: LD_INT 0
38376: PUSH
38377: LD_INT 0
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 0
38386: PUSH
38387: LD_INT 1
38389: NEG
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PUSH
38395: LD_INT 1
38397: PUSH
38398: LD_INT 0
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 1
38407: PUSH
38408: LD_INT 1
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: LD_INT 1
38420: PUSH
38421: EMPTY
38422: LIST
38423: LIST
38424: PUSH
38425: LD_INT 1
38427: NEG
38428: PUSH
38429: LD_INT 0
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 1
38438: NEG
38439: PUSH
38440: LD_INT 1
38442: NEG
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: LD_INT 2
38454: NEG
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 0
38462: PUSH
38463: LD_INT 2
38465: NEG
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: LD_INT 1
38473: PUSH
38474: LD_INT 1
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: PUSH
38485: LD_INT 0
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: PUSH
38495: LD_INT 1
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: PUSH
38505: LD_INT 2
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 0
38514: PUSH
38515: LD_INT 2
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: NEG
38525: PUSH
38526: LD_INT 1
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 2
38535: NEG
38536: PUSH
38537: LD_INT 1
38539: NEG
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 2
38547: NEG
38548: PUSH
38549: LD_INT 2
38551: NEG
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 2
38559: NEG
38560: PUSH
38561: LD_INT 3
38563: NEG
38564: PUSH
38565: EMPTY
38566: LIST
38567: LIST
38568: PUSH
38569: LD_INT 2
38571: PUSH
38572: LD_INT 1
38574: NEG
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 3
38582: PUSH
38583: LD_INT 1
38585: PUSH
38586: EMPTY
38587: LIST
38588: LIST
38589: PUSH
38590: LD_INT 1
38592: PUSH
38593: LD_INT 3
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 1
38602: NEG
38603: PUSH
38604: LD_INT 2
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 3
38613: NEG
38614: PUSH
38615: LD_INT 2
38617: NEG
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: LIST
38630: LIST
38631: LIST
38632: LIST
38633: LIST
38634: LIST
38635: LIST
38636: LIST
38637: LIST
38638: LIST
38639: LIST
38640: LIST
38641: LIST
38642: LIST
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38648: LD_ADDR_VAR 0 30
38652: PUSH
38653: LD_INT 0
38655: PUSH
38656: LD_INT 0
38658: PUSH
38659: EMPTY
38660: LIST
38661: LIST
38662: PUSH
38663: LD_INT 0
38665: PUSH
38666: LD_INT 1
38668: NEG
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 1
38676: PUSH
38677: LD_INT 0
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 1
38686: PUSH
38687: LD_INT 1
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 0
38696: PUSH
38697: LD_INT 1
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 1
38706: NEG
38707: PUSH
38708: LD_INT 0
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 1
38717: NEG
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: NEG
38730: PUSH
38731: LD_INT 2
38733: NEG
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 0
38741: PUSH
38742: LD_INT 2
38744: NEG
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 1
38752: PUSH
38753: LD_INT 1
38755: NEG
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PUSH
38761: LD_INT 2
38763: PUSH
38764: LD_INT 0
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 2
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PUSH
38781: LD_INT 2
38783: PUSH
38784: LD_INT 2
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 1
38793: PUSH
38794: LD_INT 2
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: LD_INT 1
38803: NEG
38804: PUSH
38805: LD_INT 1
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 2
38814: NEG
38815: PUSH
38816: LD_INT 0
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 2
38825: NEG
38826: PUSH
38827: LD_INT 1
38829: NEG
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 1
38837: NEG
38838: PUSH
38839: LD_INT 3
38841: NEG
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: PUSH
38847: LD_INT 1
38849: PUSH
38850: LD_INT 2
38852: NEG
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 3
38860: PUSH
38861: LD_INT 2
38863: PUSH
38864: EMPTY
38865: LIST
38866: LIST
38867: PUSH
38868: LD_INT 2
38870: PUSH
38871: LD_INT 3
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 2
38880: NEG
38881: PUSH
38882: LD_INT 1
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 3
38891: NEG
38892: PUSH
38893: LD_INT 1
38895: NEG
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: LIST
38907: LIST
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: LIST
38921: LIST
38922: LIST
38923: LIST
38924: LIST
38925: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38926: LD_ADDR_VAR 0 31
38930: PUSH
38931: LD_INT 0
38933: PUSH
38934: LD_INT 0
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 0
38943: PUSH
38944: LD_INT 1
38946: NEG
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 1
38954: PUSH
38955: LD_INT 0
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: LD_INT 1
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 0
38974: PUSH
38975: LD_INT 1
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: NEG
38985: PUSH
38986: LD_INT 0
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 1
38995: NEG
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 1
39007: NEG
39008: PUSH
39009: LD_INT 2
39011: NEG
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 1
39019: PUSH
39020: LD_INT 1
39022: NEG
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 2
39030: PUSH
39031: LD_INT 0
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 2
39040: PUSH
39041: LD_INT 1
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: LD_INT 2
39050: PUSH
39051: LD_INT 2
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: LD_INT 2
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 0
39070: PUSH
39071: LD_INT 2
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: NEG
39081: PUSH
39082: LD_INT 1
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 2
39091: NEG
39092: PUSH
39093: LD_INT 1
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 2
39103: NEG
39104: PUSH
39105: LD_INT 2
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 2
39115: NEG
39116: PUSH
39117: LD_INT 3
39119: NEG
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 2
39127: PUSH
39128: LD_INT 1
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 3
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 1
39148: PUSH
39149: LD_INT 3
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: LD_INT 1
39158: NEG
39159: PUSH
39160: LD_INT 2
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 3
39169: NEG
39170: PUSH
39171: LD_INT 2
39173: NEG
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: EMPTY
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: LIST
39190: LIST
39191: LIST
39192: LIST
39193: LIST
39194: LIST
39195: LIST
39196: LIST
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: LIST
39202: LIST
39203: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39204: LD_ADDR_VAR 0 32
39208: PUSH
39209: LD_INT 0
39211: PUSH
39212: LD_INT 0
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 0
39221: PUSH
39222: LD_INT 1
39224: NEG
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: LD_INT 1
39232: PUSH
39233: LD_INT 0
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 1
39242: PUSH
39243: LD_INT 1
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 0
39252: PUSH
39253: LD_INT 1
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 1
39262: NEG
39263: PUSH
39264: LD_INT 0
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: PUSH
39271: LD_INT 1
39273: NEG
39274: PUSH
39275: LD_INT 1
39277: NEG
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: LD_INT 1
39285: NEG
39286: PUSH
39287: LD_INT 2
39289: NEG
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 0
39297: PUSH
39298: LD_INT 2
39300: NEG
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 1
39308: PUSH
39309: LD_INT 1
39311: NEG
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: PUSH
39317: LD_INT 2
39319: PUSH
39320: LD_INT 1
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: PUSH
39327: LD_INT 2
39329: PUSH
39330: LD_INT 2
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: LD_INT 2
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: LD_INT 2
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 1
39359: NEG
39360: PUSH
39361: LD_INT 1
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 2
39370: NEG
39371: PUSH
39372: LD_INT 0
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 2
39381: NEG
39382: PUSH
39383: LD_INT 1
39385: NEG
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 1
39393: NEG
39394: PUSH
39395: LD_INT 3
39397: NEG
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: LD_INT 1
39405: PUSH
39406: LD_INT 2
39408: NEG
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 3
39416: PUSH
39417: LD_INT 2
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 2
39426: PUSH
39427: LD_INT 3
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 2
39436: NEG
39437: PUSH
39438: LD_INT 1
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: LD_INT 3
39447: NEG
39448: PUSH
39449: LD_INT 1
39451: NEG
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: LIST
39461: LIST
39462: LIST
39463: LIST
39464: LIST
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: LIST
39474: LIST
39475: LIST
39476: LIST
39477: LIST
39478: LIST
39479: LIST
39480: LIST
39481: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39482: LD_ADDR_VAR 0 33
39486: PUSH
39487: LD_INT 0
39489: PUSH
39490: LD_INT 0
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: PUSH
39497: LD_INT 0
39499: PUSH
39500: LD_INT 1
39502: NEG
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 1
39510: PUSH
39511: LD_INT 0
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: LD_INT 1
39520: PUSH
39521: LD_INT 1
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: PUSH
39528: LD_INT 0
39530: PUSH
39531: LD_INT 1
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: LD_INT 1
39540: NEG
39541: PUSH
39542: LD_INT 0
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 1
39551: NEG
39552: PUSH
39553: LD_INT 1
39555: NEG
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: LD_INT 2
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 1
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 2
39586: PUSH
39587: LD_INT 0
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 2
39596: PUSH
39597: LD_INT 1
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 1
39606: PUSH
39607: LD_INT 2
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 0
39616: PUSH
39617: LD_INT 2
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: LD_INT 1
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 2
39637: NEG
39638: PUSH
39639: LD_INT 0
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 2
39648: NEG
39649: PUSH
39650: LD_INT 1
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 2
39660: NEG
39661: PUSH
39662: LD_INT 2
39664: NEG
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 2
39672: NEG
39673: PUSH
39674: LD_INT 3
39676: NEG
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 2
39684: PUSH
39685: LD_INT 1
39687: NEG
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 3
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 1
39705: PUSH
39706: LD_INT 3
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 1
39715: NEG
39716: PUSH
39717: LD_INT 2
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 3
39726: NEG
39727: PUSH
39728: LD_INT 2
39730: NEG
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: LIST
39740: LIST
39741: LIST
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: LIST
39759: LIST
39760: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39761: LD_ADDR_VAR 0 34
39765: PUSH
39766: LD_INT 0
39768: PUSH
39769: LD_INT 0
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 0
39778: PUSH
39779: LD_INT 1
39781: NEG
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PUSH
39787: LD_INT 1
39789: PUSH
39790: LD_INT 0
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PUSH
39797: LD_INT 1
39799: PUSH
39800: LD_INT 1
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 0
39809: PUSH
39810: LD_INT 1
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 1
39819: NEG
39820: PUSH
39821: LD_INT 0
39823: PUSH
39824: EMPTY
39825: LIST
39826: LIST
39827: PUSH
39828: LD_INT 1
39830: NEG
39831: PUSH
39832: LD_INT 1
39834: NEG
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: LD_INT 1
39842: NEG
39843: PUSH
39844: LD_INT 2
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 0
39854: PUSH
39855: LD_INT 2
39857: NEG
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 1
39865: PUSH
39866: LD_INT 1
39868: NEG
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 2
39876: PUSH
39877: LD_INT 1
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 2
39886: PUSH
39887: LD_INT 2
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PUSH
39894: LD_INT 1
39896: PUSH
39897: LD_INT 2
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 1
39906: NEG
39907: PUSH
39908: LD_INT 1
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: LD_INT 2
39917: NEG
39918: PUSH
39919: LD_INT 0
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: LD_INT 2
39928: NEG
39929: PUSH
39930: LD_INT 1
39932: NEG
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 2
39940: NEG
39941: PUSH
39942: LD_INT 2
39944: NEG
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 1
39952: NEG
39953: PUSH
39954: LD_INT 3
39956: NEG
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 1
39964: PUSH
39965: LD_INT 2
39967: NEG
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 3
39975: PUSH
39976: LD_INT 2
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: LD_INT 2
39985: PUSH
39986: LD_INT 3
39988: PUSH
39989: EMPTY
39990: LIST
39991: LIST
39992: PUSH
39993: LD_INT 2
39995: NEG
39996: PUSH
39997: LD_INT 1
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 3
40006: NEG
40007: PUSH
40008: LD_INT 1
40010: NEG
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: LIST
40023: LIST
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: LIST
40040: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40041: LD_ADDR_VAR 0 35
40045: PUSH
40046: LD_INT 0
40048: PUSH
40049: LD_INT 0
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 0
40058: PUSH
40059: LD_INT 1
40061: NEG
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 1
40069: PUSH
40070: LD_INT 0
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: LD_INT 1
40079: PUSH
40080: LD_INT 1
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 0
40089: PUSH
40090: LD_INT 1
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PUSH
40097: LD_INT 1
40099: NEG
40100: PUSH
40101: LD_INT 0
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 1
40110: NEG
40111: PUSH
40112: LD_INT 1
40114: NEG
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: PUSH
40120: LD_INT 2
40122: PUSH
40123: LD_INT 1
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 2
40132: NEG
40133: PUSH
40134: LD_INT 1
40136: NEG
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40153: LD_ADDR_VAR 0 36
40157: PUSH
40158: LD_INT 0
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 0
40170: PUSH
40171: LD_INT 1
40173: NEG
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 1
40181: PUSH
40182: LD_INT 0
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 1
40191: PUSH
40192: LD_INT 1
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 0
40201: PUSH
40202: LD_INT 1
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 1
40211: NEG
40212: PUSH
40213: LD_INT 0
40215: PUSH
40216: EMPTY
40217: LIST
40218: LIST
40219: PUSH
40220: LD_INT 1
40222: NEG
40223: PUSH
40224: LD_INT 1
40226: NEG
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PUSH
40232: LD_INT 1
40234: NEG
40235: PUSH
40236: LD_INT 2
40238: NEG
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 2
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: LIST
40258: LIST
40259: LIST
40260: LIST
40261: LIST
40262: LIST
40263: LIST
40264: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40265: LD_ADDR_VAR 0 37
40269: PUSH
40270: LD_INT 0
40272: PUSH
40273: LD_INT 0
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 0
40282: PUSH
40283: LD_INT 1
40285: NEG
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 1
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 1
40303: PUSH
40304: LD_INT 1
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 1
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 1
40323: NEG
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 1
40334: NEG
40335: PUSH
40336: LD_INT 1
40338: NEG
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 1
40346: PUSH
40347: LD_INT 1
40349: NEG
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 1
40357: NEG
40358: PUSH
40359: LD_INT 1
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: LIST
40375: LIST
40376: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40377: LD_ADDR_VAR 0 38
40381: PUSH
40382: LD_INT 0
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 0
40394: PUSH
40395: LD_INT 1
40397: NEG
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_INT 1
40405: PUSH
40406: LD_INT 0
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 1
40415: PUSH
40416: LD_INT 1
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: LD_INT 1
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 1
40435: NEG
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 1
40446: NEG
40447: PUSH
40448: LD_INT 1
40450: NEG
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 2
40458: PUSH
40459: LD_INT 1
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 2
40468: NEG
40469: PUSH
40470: LD_INT 1
40472: NEG
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40489: LD_ADDR_VAR 0 39
40493: PUSH
40494: LD_INT 0
40496: PUSH
40497: LD_INT 0
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 0
40506: PUSH
40507: LD_INT 1
40509: NEG
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 1
40517: PUSH
40518: LD_INT 0
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 1
40527: PUSH
40528: LD_INT 1
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 0
40537: PUSH
40538: LD_INT 1
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: LD_INT 1
40547: NEG
40548: PUSH
40549: LD_INT 0
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 1
40558: NEG
40559: PUSH
40560: LD_INT 1
40562: NEG
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: NEG
40571: PUSH
40572: LD_INT 2
40574: NEG
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 1
40582: PUSH
40583: LD_INT 2
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40601: LD_ADDR_VAR 0 40
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 0
40618: PUSH
40619: LD_INT 1
40621: NEG
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 1
40629: PUSH
40630: LD_INT 0
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 1
40639: PUSH
40640: LD_INT 1
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 0
40649: PUSH
40650: LD_INT 1
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 1
40659: NEG
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 1
40670: NEG
40671: PUSH
40672: LD_INT 1
40674: NEG
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 1
40682: PUSH
40683: LD_INT 1
40685: NEG
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 1
40693: NEG
40694: PUSH
40695: LD_INT 1
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: LIST
40711: LIST
40712: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40713: LD_ADDR_VAR 0 41
40717: PUSH
40718: LD_INT 0
40720: PUSH
40721: LD_INT 0
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 0
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 1
40741: PUSH
40742: LD_INT 0
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: LD_INT 1
40751: PUSH
40752: LD_INT 1
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: LD_INT 0
40761: PUSH
40762: LD_INT 1
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PUSH
40769: LD_INT 1
40771: NEG
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 1
40782: NEG
40783: PUSH
40784: LD_INT 1
40786: NEG
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: PUSH
40792: LD_INT 1
40794: NEG
40795: PUSH
40796: LD_INT 2
40798: NEG
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 1
40806: PUSH
40807: LD_INT 1
40809: NEG
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: LD_INT 2
40817: PUSH
40818: LD_INT 0
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 2
40827: PUSH
40828: LD_INT 1
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 2
40837: PUSH
40838: LD_INT 2
40840: PUSH
40841: EMPTY
40842: LIST
40843: LIST
40844: PUSH
40845: LD_INT 1
40847: PUSH
40848: LD_INT 2
40850: PUSH
40851: EMPTY
40852: LIST
40853: LIST
40854: PUSH
40855: LD_INT 1
40857: NEG
40858: PUSH
40859: LD_INT 1
40861: PUSH
40862: EMPTY
40863: LIST
40864: LIST
40865: PUSH
40866: LD_INT 2
40868: NEG
40869: PUSH
40870: LD_INT 0
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 2
40879: NEG
40880: PUSH
40881: LD_INT 1
40883: NEG
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 2
40891: NEG
40892: PUSH
40893: LD_INT 2
40895: NEG
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 2
40903: NEG
40904: PUSH
40905: LD_INT 3
40907: NEG
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 2
40915: PUSH
40916: LD_INT 1
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 3
40926: PUSH
40927: LD_INT 0
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: PUSH
40934: LD_INT 3
40936: PUSH
40937: LD_INT 1
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 3
40946: PUSH
40947: LD_INT 2
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: LD_INT 3
40956: PUSH
40957: LD_INT 3
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 2
40966: PUSH
40967: LD_INT 3
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 2
40976: NEG
40977: PUSH
40978: LD_INT 1
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 3
40987: NEG
40988: PUSH
40989: LD_INT 0
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 3
40998: NEG
40999: PUSH
41000: LD_INT 1
41002: NEG
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 3
41010: NEG
41011: PUSH
41012: LD_INT 2
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 3
41022: NEG
41023: PUSH
41024: LD_INT 3
41026: NEG
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: LIST
41036: LIST
41037: LIST
41038: LIST
41039: LIST
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41063: LD_ADDR_VAR 0 42
41067: PUSH
41068: LD_INT 0
41070: PUSH
41071: LD_INT 0
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: PUSH
41078: LD_INT 0
41080: PUSH
41081: LD_INT 1
41083: NEG
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 1
41091: PUSH
41092: LD_INT 0
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 1
41101: PUSH
41102: LD_INT 1
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 0
41111: PUSH
41112: LD_INT 1
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: LD_INT 1
41121: NEG
41122: PUSH
41123: LD_INT 0
41125: PUSH
41126: EMPTY
41127: LIST
41128: LIST
41129: PUSH
41130: LD_INT 1
41132: NEG
41133: PUSH
41134: LD_INT 1
41136: NEG
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 1
41144: NEG
41145: PUSH
41146: LD_INT 2
41148: NEG
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: LD_INT 0
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 1
41167: PUSH
41168: LD_INT 1
41170: NEG
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 2
41178: PUSH
41179: LD_INT 1
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 2
41188: PUSH
41189: LD_INT 2
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 1
41198: PUSH
41199: LD_INT 2
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 0
41208: PUSH
41209: LD_INT 2
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 1
41218: NEG
41219: PUSH
41220: LD_INT 1
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 2
41229: NEG
41230: PUSH
41231: LD_INT 1
41233: NEG
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: PUSH
41239: LD_INT 2
41241: NEG
41242: PUSH
41243: LD_INT 2
41245: NEG
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 2
41253: NEG
41254: PUSH
41255: LD_INT 3
41257: NEG
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: LD_INT 1
41265: NEG
41266: PUSH
41267: LD_INT 3
41269: NEG
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PUSH
41275: LD_INT 0
41277: PUSH
41278: LD_INT 3
41280: NEG
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 1
41288: PUSH
41289: LD_INT 2
41291: NEG
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 3
41299: PUSH
41300: LD_INT 2
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: LD_INT 3
41309: PUSH
41310: LD_INT 3
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 2
41319: PUSH
41320: LD_INT 3
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 1
41329: PUSH
41330: LD_INT 3
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 0
41339: PUSH
41340: LD_INT 3
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PUSH
41347: LD_INT 1
41349: NEG
41350: PUSH
41351: LD_INT 2
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 3
41360: NEG
41361: PUSH
41362: LD_INT 2
41364: NEG
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 3
41372: NEG
41373: PUSH
41374: LD_INT 3
41376: NEG
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: LIST
41386: LIST
41387: LIST
41388: LIST
41389: LIST
41390: LIST
41391: LIST
41392: LIST
41393: LIST
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: LIST
41399: LIST
41400: LIST
41401: LIST
41402: LIST
41403: LIST
41404: LIST
41405: LIST
41406: LIST
41407: LIST
41408: LIST
41409: LIST
41410: LIST
41411: LIST
41412: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41413: LD_ADDR_VAR 0 43
41417: PUSH
41418: LD_INT 0
41420: PUSH
41421: LD_INT 0
41423: PUSH
41424: EMPTY
41425: LIST
41426: LIST
41427: PUSH
41428: LD_INT 0
41430: PUSH
41431: LD_INT 1
41433: NEG
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 1
41441: PUSH
41442: LD_INT 0
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 1
41451: PUSH
41452: LD_INT 1
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 0
41461: PUSH
41462: LD_INT 1
41464: PUSH
41465: EMPTY
41466: LIST
41467: LIST
41468: PUSH
41469: LD_INT 1
41471: NEG
41472: PUSH
41473: LD_INT 0
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 1
41482: NEG
41483: PUSH
41484: LD_INT 1
41486: NEG
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 1
41494: NEG
41495: PUSH
41496: LD_INT 2
41498: NEG
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 0
41506: PUSH
41507: LD_INT 2
41509: NEG
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 1
41517: PUSH
41518: LD_INT 1
41520: NEG
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: PUSH
41526: LD_INT 2
41528: PUSH
41529: LD_INT 0
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: PUSH
41536: LD_INT 2
41538: PUSH
41539: LD_INT 1
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 1
41548: PUSH
41549: LD_INT 2
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 0
41558: PUSH
41559: LD_INT 2
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: LD_INT 1
41568: NEG
41569: PUSH
41570: LD_INT 1
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: PUSH
41577: LD_INT 2
41579: NEG
41580: PUSH
41581: LD_INT 0
41583: PUSH
41584: EMPTY
41585: LIST
41586: LIST
41587: PUSH
41588: LD_INT 2
41590: NEG
41591: PUSH
41592: LD_INT 1
41594: NEG
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PUSH
41600: LD_INT 1
41602: NEG
41603: PUSH
41604: LD_INT 3
41606: NEG
41607: PUSH
41608: EMPTY
41609: LIST
41610: LIST
41611: PUSH
41612: LD_INT 0
41614: PUSH
41615: LD_INT 3
41617: NEG
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 1
41625: PUSH
41626: LD_INT 2
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 2
41636: PUSH
41637: LD_INT 1
41639: NEG
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 3
41647: PUSH
41648: LD_INT 0
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 3
41657: PUSH
41658: LD_INT 1
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 1
41667: PUSH
41668: LD_INT 3
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 0
41677: PUSH
41678: LD_INT 3
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 1
41687: NEG
41688: PUSH
41689: LD_INT 2
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 2
41698: NEG
41699: PUSH
41700: LD_INT 1
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 3
41709: NEG
41710: PUSH
41711: LD_INT 0
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 3
41720: NEG
41721: PUSH
41722: LD_INT 1
41724: NEG
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: LIST
41734: LIST
41735: LIST
41736: LIST
41737: LIST
41738: LIST
41739: LIST
41740: LIST
41741: LIST
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41761: LD_ADDR_VAR 0 44
41765: PUSH
41766: LD_INT 0
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: LD_INT 0
41778: PUSH
41779: LD_INT 1
41781: NEG
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: LD_INT 1
41789: PUSH
41790: LD_INT 0
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: LD_INT 1
41799: PUSH
41800: LD_INT 1
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: LD_INT 0
41809: PUSH
41810: LD_INT 1
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: LD_INT 1
41819: NEG
41820: PUSH
41821: LD_INT 0
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 1
41830: NEG
41831: PUSH
41832: LD_INT 1
41834: NEG
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: LD_INT 1
41842: NEG
41843: PUSH
41844: LD_INT 2
41846: NEG
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: LD_INT 1
41854: PUSH
41855: LD_INT 1
41857: NEG
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 2
41865: PUSH
41866: LD_INT 0
41868: PUSH
41869: EMPTY
41870: LIST
41871: LIST
41872: PUSH
41873: LD_INT 2
41875: PUSH
41876: LD_INT 1
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: PUSH
41883: LD_INT 2
41885: PUSH
41886: LD_INT 2
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: LD_INT 1
41895: PUSH
41896: LD_INT 2
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: LD_INT 1
41905: NEG
41906: PUSH
41907: LD_INT 1
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 2
41916: NEG
41917: PUSH
41918: LD_INT 0
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 2
41927: NEG
41928: PUSH
41929: LD_INT 1
41931: NEG
41932: PUSH
41933: EMPTY
41934: LIST
41935: LIST
41936: PUSH
41937: LD_INT 2
41939: NEG
41940: PUSH
41941: LD_INT 2
41943: NEG
41944: PUSH
41945: EMPTY
41946: LIST
41947: LIST
41948: PUSH
41949: LD_INT 2
41951: NEG
41952: PUSH
41953: LD_INT 3
41955: NEG
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 2
41963: PUSH
41964: LD_INT 1
41966: NEG
41967: PUSH
41968: EMPTY
41969: LIST
41970: LIST
41971: PUSH
41972: LD_INT 3
41974: PUSH
41975: LD_INT 0
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: LD_INT 3
41984: PUSH
41985: LD_INT 1
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 3
41994: PUSH
41995: LD_INT 2
41997: PUSH
41998: EMPTY
41999: LIST
42000: LIST
42001: PUSH
42002: LD_INT 3
42004: PUSH
42005: LD_INT 3
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 2
42014: PUSH
42015: LD_INT 3
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: LD_INT 2
42024: NEG
42025: PUSH
42026: LD_INT 1
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 3
42035: NEG
42036: PUSH
42037: LD_INT 0
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: LD_INT 3
42046: NEG
42047: PUSH
42048: LD_INT 1
42050: NEG
42051: PUSH
42052: EMPTY
42053: LIST
42054: LIST
42055: PUSH
42056: LD_INT 3
42058: NEG
42059: PUSH
42060: LD_INT 2
42062: NEG
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 3
42070: NEG
42071: PUSH
42072: LD_INT 3
42074: NEG
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: LIST
42095: LIST
42096: LIST
42097: LIST
42098: LIST
42099: LIST
42100: LIST
42101: LIST
42102: LIST
42103: LIST
42104: LIST
42105: LIST
42106: LIST
42107: LIST
42108: LIST
42109: LIST
42110: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42111: LD_ADDR_VAR 0 45
42115: PUSH
42116: LD_INT 0
42118: PUSH
42119: LD_INT 0
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: LD_INT 0
42128: PUSH
42129: LD_INT 1
42131: NEG
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 1
42139: PUSH
42140: LD_INT 0
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 1
42149: PUSH
42150: LD_INT 1
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 0
42159: PUSH
42160: LD_INT 1
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 1
42169: NEG
42170: PUSH
42171: LD_INT 0
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 1
42180: NEG
42181: PUSH
42182: LD_INT 1
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 1
42192: NEG
42193: PUSH
42194: LD_INT 2
42196: NEG
42197: PUSH
42198: EMPTY
42199: LIST
42200: LIST
42201: PUSH
42202: LD_INT 0
42204: PUSH
42205: LD_INT 2
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 1
42215: PUSH
42216: LD_INT 1
42218: NEG
42219: PUSH
42220: EMPTY
42221: LIST
42222: LIST
42223: PUSH
42224: LD_INT 2
42226: PUSH
42227: LD_INT 1
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: PUSH
42234: LD_INT 2
42236: PUSH
42237: LD_INT 2
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: LD_INT 1
42246: PUSH
42247: LD_INT 2
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PUSH
42254: LD_INT 0
42256: PUSH
42257: LD_INT 2
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: PUSH
42264: LD_INT 1
42266: NEG
42267: PUSH
42268: LD_INT 1
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 2
42277: NEG
42278: PUSH
42279: LD_INT 1
42281: NEG
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 2
42289: NEG
42290: PUSH
42291: LD_INT 2
42293: NEG
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 2
42301: NEG
42302: PUSH
42303: LD_INT 3
42305: NEG
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: LD_INT 1
42313: NEG
42314: PUSH
42315: LD_INT 3
42317: NEG
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 0
42325: PUSH
42326: LD_INT 3
42328: NEG
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 1
42336: PUSH
42337: LD_INT 2
42339: NEG
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 3
42347: PUSH
42348: LD_INT 2
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 3
42357: PUSH
42358: LD_INT 3
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 2
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 1
42377: PUSH
42378: LD_INT 3
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 0
42387: PUSH
42388: LD_INT 3
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 1
42397: NEG
42398: PUSH
42399: LD_INT 2
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: LD_INT 3
42408: NEG
42409: PUSH
42410: LD_INT 2
42412: NEG
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 3
42420: NEG
42421: PUSH
42422: LD_INT 3
42424: NEG
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42461: LD_ADDR_VAR 0 46
42465: PUSH
42466: LD_INT 0
42468: PUSH
42469: LD_INT 0
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 0
42478: PUSH
42479: LD_INT 1
42481: NEG
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 1
42489: PUSH
42490: LD_INT 0
42492: PUSH
42493: EMPTY
42494: LIST
42495: LIST
42496: PUSH
42497: LD_INT 1
42499: PUSH
42500: LD_INT 1
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: LD_INT 0
42509: PUSH
42510: LD_INT 1
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PUSH
42517: LD_INT 1
42519: NEG
42520: PUSH
42521: LD_INT 0
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 1
42530: NEG
42531: PUSH
42532: LD_INT 1
42534: NEG
42535: PUSH
42536: EMPTY
42537: LIST
42538: LIST
42539: PUSH
42540: LD_INT 1
42542: NEG
42543: PUSH
42544: LD_INT 2
42546: NEG
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: LD_INT 2
42557: NEG
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 1
42565: PUSH
42566: LD_INT 1
42568: NEG
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 2
42576: PUSH
42577: LD_INT 0
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 2
42586: PUSH
42587: LD_INT 1
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 1
42596: PUSH
42597: LD_INT 2
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: LD_INT 0
42606: PUSH
42607: LD_INT 2
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: PUSH
42614: LD_INT 1
42616: NEG
42617: PUSH
42618: LD_INT 1
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PUSH
42625: LD_INT 2
42627: NEG
42628: PUSH
42629: LD_INT 0
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 2
42638: NEG
42639: PUSH
42640: LD_INT 1
42642: NEG
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 1
42650: NEG
42651: PUSH
42652: LD_INT 3
42654: NEG
42655: PUSH
42656: EMPTY
42657: LIST
42658: LIST
42659: PUSH
42660: LD_INT 0
42662: PUSH
42663: LD_INT 3
42665: NEG
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 1
42673: PUSH
42674: LD_INT 2
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 2
42684: PUSH
42685: LD_INT 1
42687: NEG
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: PUSH
42693: LD_INT 3
42695: PUSH
42696: LD_INT 0
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: LD_INT 3
42705: PUSH
42706: LD_INT 1
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 1
42715: PUSH
42716: LD_INT 3
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 0
42725: PUSH
42726: LD_INT 3
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 1
42735: NEG
42736: PUSH
42737: LD_INT 2
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 2
42746: NEG
42747: PUSH
42748: LD_INT 1
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 3
42757: NEG
42758: PUSH
42759: LD_INT 0
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: LD_INT 3
42768: NEG
42769: PUSH
42770: LD_INT 1
42772: NEG
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: LIST
42787: LIST
42788: LIST
42789: LIST
42790: LIST
42791: LIST
42792: LIST
42793: LIST
42794: LIST
42795: LIST
42796: LIST
42797: LIST
42798: LIST
42799: LIST
42800: LIST
42801: LIST
42802: LIST
42803: LIST
42804: LIST
42805: LIST
42806: LIST
42807: LIST
42808: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42809: LD_ADDR_VAR 0 47
42813: PUSH
42814: LD_INT 0
42816: PUSH
42817: LD_INT 0
42819: PUSH
42820: EMPTY
42821: LIST
42822: LIST
42823: PUSH
42824: LD_INT 0
42826: PUSH
42827: LD_INT 1
42829: NEG
42830: PUSH
42831: EMPTY
42832: LIST
42833: LIST
42834: PUSH
42835: LD_INT 1
42837: PUSH
42838: LD_INT 0
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 1
42847: PUSH
42848: LD_INT 1
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 0
42857: PUSH
42858: LD_INT 1
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 1
42867: NEG
42868: PUSH
42869: LD_INT 0
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 1
42878: NEG
42879: PUSH
42880: LD_INT 1
42882: NEG
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: LD_INT 1
42890: NEG
42891: PUSH
42892: LD_INT 2
42894: NEG
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: PUSH
42900: LD_INT 0
42902: PUSH
42903: LD_INT 2
42905: NEG
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 1
42913: PUSH
42914: LD_INT 1
42916: NEG
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: LD_INT 2
42924: NEG
42925: PUSH
42926: LD_INT 1
42928: NEG
42929: PUSH
42930: EMPTY
42931: LIST
42932: LIST
42933: PUSH
42934: LD_INT 2
42936: NEG
42937: PUSH
42938: LD_INT 2
42940: NEG
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: LIST
42953: LIST
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42960: LD_ADDR_VAR 0 48
42964: PUSH
42965: LD_INT 0
42967: PUSH
42968: LD_INT 0
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: LD_INT 1
42980: NEG
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: LD_INT 1
42988: PUSH
42989: LD_INT 0
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 1
42998: PUSH
42999: LD_INT 1
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 0
43008: PUSH
43009: LD_INT 1
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 1
43018: NEG
43019: PUSH
43020: LD_INT 0
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 1
43029: NEG
43030: PUSH
43031: LD_INT 1
43033: NEG
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 1
43041: NEG
43042: PUSH
43043: LD_INT 2
43045: NEG
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: PUSH
43051: LD_INT 0
43053: PUSH
43054: LD_INT 2
43056: NEG
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: PUSH
43062: LD_INT 1
43064: PUSH
43065: LD_INT 1
43067: NEG
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 2
43075: PUSH
43076: LD_INT 0
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 2
43085: PUSH
43086: LD_INT 1
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: LIST
43097: LIST
43098: LIST
43099: LIST
43100: LIST
43101: LIST
43102: LIST
43103: LIST
43104: LIST
43105: LIST
43106: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43107: LD_ADDR_VAR 0 49
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: LD_INT 0
43117: PUSH
43118: EMPTY
43119: LIST
43120: LIST
43121: PUSH
43122: LD_INT 0
43124: PUSH
43125: LD_INT 1
43127: NEG
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 1
43135: PUSH
43136: LD_INT 0
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 1
43145: PUSH
43146: LD_INT 1
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 0
43155: PUSH
43156: LD_INT 1
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 1
43165: NEG
43166: PUSH
43167: LD_INT 0
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: LD_INT 1
43176: NEG
43177: PUSH
43178: LD_INT 1
43180: NEG
43181: PUSH
43182: EMPTY
43183: LIST
43184: LIST
43185: PUSH
43186: LD_INT 1
43188: PUSH
43189: LD_INT 1
43191: NEG
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: PUSH
43197: LD_INT 2
43199: PUSH
43200: LD_INT 0
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 2
43209: PUSH
43210: LD_INT 1
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: PUSH
43217: LD_INT 2
43219: PUSH
43220: LD_INT 2
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 1
43229: PUSH
43230: LD_INT 2
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: LIST
43241: LIST
43242: LIST
43243: LIST
43244: LIST
43245: LIST
43246: LIST
43247: LIST
43248: LIST
43249: LIST
43250: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43251: LD_ADDR_VAR 0 50
43255: PUSH
43256: LD_INT 0
43258: PUSH
43259: LD_INT 0
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: LD_INT 0
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 1
43279: PUSH
43280: LD_INT 0
43282: PUSH
43283: EMPTY
43284: LIST
43285: LIST
43286: PUSH
43287: LD_INT 1
43289: PUSH
43290: LD_INT 1
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 0
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: PUSH
43307: LD_INT 1
43309: NEG
43310: PUSH
43311: LD_INT 0
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PUSH
43318: LD_INT 1
43320: NEG
43321: PUSH
43322: LD_INT 1
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 2
43332: PUSH
43333: LD_INT 1
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 2
43342: PUSH
43343: LD_INT 2
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 1
43352: PUSH
43353: LD_INT 2
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 0
43362: PUSH
43363: LD_INT 2
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: LD_INT 1
43372: NEG
43373: PUSH
43374: LD_INT 1
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: LIST
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: LIST
43393: LIST
43394: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43395: LD_ADDR_VAR 0 51
43399: PUSH
43400: LD_INT 0
43402: PUSH
43403: LD_INT 0
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 0
43412: PUSH
43413: LD_INT 1
43415: NEG
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 1
43423: PUSH
43424: LD_INT 0
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 1
43433: PUSH
43434: LD_INT 1
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 0
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: LD_INT 1
43453: NEG
43454: PUSH
43455: LD_INT 0
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 1
43464: NEG
43465: PUSH
43466: LD_INT 1
43468: NEG
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: PUSH
43474: LD_INT 1
43476: PUSH
43477: LD_INT 2
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 0
43486: PUSH
43487: LD_INT 2
43489: PUSH
43490: EMPTY
43491: LIST
43492: LIST
43493: PUSH
43494: LD_INT 1
43496: NEG
43497: PUSH
43498: LD_INT 1
43500: PUSH
43501: EMPTY
43502: LIST
43503: LIST
43504: PUSH
43505: LD_INT 2
43507: NEG
43508: PUSH
43509: LD_INT 0
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 2
43518: NEG
43519: PUSH
43520: LD_INT 1
43522: NEG
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43542: LD_ADDR_VAR 0 52
43546: PUSH
43547: LD_INT 0
43549: PUSH
43550: LD_INT 0
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: LD_INT 0
43559: PUSH
43560: LD_INT 1
43562: NEG
43563: PUSH
43564: EMPTY
43565: LIST
43566: LIST
43567: PUSH
43568: LD_INT 1
43570: PUSH
43571: LD_INT 0
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 1
43580: PUSH
43581: LD_INT 1
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 0
43590: PUSH
43591: LD_INT 1
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: LD_INT 1
43600: NEG
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: PUSH
43609: LD_INT 1
43611: NEG
43612: PUSH
43613: LD_INT 1
43615: NEG
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: PUSH
43621: LD_INT 1
43623: NEG
43624: PUSH
43625: LD_INT 2
43627: NEG
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PUSH
43633: LD_INT 1
43635: NEG
43636: PUSH
43637: LD_INT 1
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 2
43646: NEG
43647: PUSH
43648: LD_INT 0
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: LD_INT 2
43657: NEG
43658: PUSH
43659: LD_INT 1
43661: NEG
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 2
43669: NEG
43670: PUSH
43671: LD_INT 2
43673: NEG
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: LIST
43683: LIST
43684: LIST
43685: LIST
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43693: LD_ADDR_VAR 0 53
43697: PUSH
43698: LD_INT 0
43700: PUSH
43701: LD_INT 0
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: PUSH
43708: LD_INT 0
43710: PUSH
43711: LD_INT 1
43713: NEG
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 1
43721: PUSH
43722: LD_INT 0
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: LD_INT 1
43731: PUSH
43732: LD_INT 1
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 0
43741: PUSH
43742: LD_INT 1
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 1
43751: NEG
43752: PUSH
43753: LD_INT 0
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 1
43762: NEG
43763: PUSH
43764: LD_INT 1
43766: NEG
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: LD_INT 1
43774: NEG
43775: PUSH
43776: LD_INT 2
43778: NEG
43779: PUSH
43780: EMPTY
43781: LIST
43782: LIST
43783: PUSH
43784: LD_INT 0
43786: PUSH
43787: LD_INT 2
43789: NEG
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 1
43797: PUSH
43798: LD_INT 1
43800: NEG
43801: PUSH
43802: EMPTY
43803: LIST
43804: LIST
43805: PUSH
43806: LD_INT 2
43808: PUSH
43809: LD_INT 0
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: PUSH
43816: LD_INT 2
43818: PUSH
43819: LD_INT 1
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 2
43828: PUSH
43829: LD_INT 2
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: LD_INT 1
43838: PUSH
43839: LD_INT 2
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: LD_INT 0
43848: PUSH
43849: LD_INT 2
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: LD_INT 1
43858: NEG
43859: PUSH
43860: LD_INT 1
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 2
43869: NEG
43870: PUSH
43871: LD_INT 0
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 2
43880: NEG
43881: PUSH
43882: LD_INT 1
43884: NEG
43885: PUSH
43886: EMPTY
43887: LIST
43888: LIST
43889: PUSH
43890: LD_INT 2
43892: NEG
43893: PUSH
43894: LD_INT 2
43896: NEG
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43923: LD_ADDR_VAR 0 54
43927: PUSH
43928: LD_INT 0
43930: PUSH
43931: LD_INT 0
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: PUSH
43938: LD_INT 0
43940: PUSH
43941: LD_INT 1
43943: NEG
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 1
43951: PUSH
43952: LD_INT 0
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 1
43961: PUSH
43962: LD_INT 1
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PUSH
43969: LD_INT 0
43971: PUSH
43972: LD_INT 1
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 1
43981: NEG
43982: PUSH
43983: LD_INT 0
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 1
43992: NEG
43993: PUSH
43994: LD_INT 1
43996: NEG
43997: PUSH
43998: EMPTY
43999: LIST
44000: LIST
44001: PUSH
44002: LD_INT 1
44004: NEG
44005: PUSH
44006: LD_INT 2
44008: NEG
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: LD_INT 0
44016: PUSH
44017: LD_INT 2
44019: NEG
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: LD_INT 1
44027: PUSH
44028: LD_INT 1
44030: NEG
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: LD_INT 0
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 2
44048: PUSH
44049: LD_INT 1
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 2
44058: PUSH
44059: LD_INT 2
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: PUSH
44066: LD_INT 1
44068: PUSH
44069: LD_INT 2
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: PUSH
44076: LD_INT 0
44078: PUSH
44079: LD_INT 2
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 1
44088: NEG
44089: PUSH
44090: LD_INT 1
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: LD_INT 2
44099: NEG
44100: PUSH
44101: LD_INT 0
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 2
44110: NEG
44111: PUSH
44112: LD_INT 1
44114: NEG
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: LD_INT 2
44122: NEG
44123: PUSH
44124: LD_INT 2
44126: NEG
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: LIST
44136: LIST
44137: LIST
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: LIST
44144: LIST
44145: LIST
44146: LIST
44147: LIST
44148: LIST
44149: LIST
44150: LIST
44151: LIST
44152: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44153: LD_ADDR_VAR 0 55
44157: PUSH
44158: LD_INT 0
44160: PUSH
44161: LD_INT 0
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 0
44170: PUSH
44171: LD_INT 1
44173: NEG
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 1
44181: PUSH
44182: LD_INT 0
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 1
44191: PUSH
44192: LD_INT 1
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 0
44201: PUSH
44202: LD_INT 1
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: PUSH
44209: LD_INT 1
44211: NEG
44212: PUSH
44213: LD_INT 0
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 1
44222: NEG
44223: PUSH
44224: LD_INT 1
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 1
44234: NEG
44235: PUSH
44236: LD_INT 2
44238: NEG
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 0
44246: PUSH
44247: LD_INT 2
44249: NEG
44250: PUSH
44251: EMPTY
44252: LIST
44253: LIST
44254: PUSH
44255: LD_INT 1
44257: PUSH
44258: LD_INT 1
44260: NEG
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 2
44268: PUSH
44269: LD_INT 0
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_INT 2
44278: PUSH
44279: LD_INT 1
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 2
44288: PUSH
44289: LD_INT 2
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: LD_INT 2
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 0
44308: PUSH
44309: LD_INT 2
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 1
44318: NEG
44319: PUSH
44320: LD_INT 1
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 2
44329: NEG
44330: PUSH
44331: LD_INT 0
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 2
44340: NEG
44341: PUSH
44342: LD_INT 1
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 2
44352: NEG
44353: PUSH
44354: LD_INT 2
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44383: LD_ADDR_VAR 0 56
44387: PUSH
44388: LD_INT 0
44390: PUSH
44391: LD_INT 0
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: PUSH
44398: LD_INT 0
44400: PUSH
44401: LD_INT 1
44403: NEG
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: LD_INT 1
44411: PUSH
44412: LD_INT 0
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PUSH
44419: LD_INT 1
44421: PUSH
44422: LD_INT 1
44424: PUSH
44425: EMPTY
44426: LIST
44427: LIST
44428: PUSH
44429: LD_INT 0
44431: PUSH
44432: LD_INT 1
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: PUSH
44439: LD_INT 1
44441: NEG
44442: PUSH
44443: LD_INT 0
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 1
44452: NEG
44453: PUSH
44454: LD_INT 1
44456: NEG
44457: PUSH
44458: EMPTY
44459: LIST
44460: LIST
44461: PUSH
44462: LD_INT 1
44464: NEG
44465: PUSH
44466: LD_INT 2
44468: NEG
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 0
44476: PUSH
44477: LD_INT 2
44479: NEG
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 1
44487: PUSH
44488: LD_INT 1
44490: NEG
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 2
44498: PUSH
44499: LD_INT 0
44501: PUSH
44502: EMPTY
44503: LIST
44504: LIST
44505: PUSH
44506: LD_INT 2
44508: PUSH
44509: LD_INT 1
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: PUSH
44516: LD_INT 2
44518: PUSH
44519: LD_INT 2
44521: PUSH
44522: EMPTY
44523: LIST
44524: LIST
44525: PUSH
44526: LD_INT 1
44528: PUSH
44529: LD_INT 2
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: PUSH
44536: LD_INT 0
44538: PUSH
44539: LD_INT 2
44541: PUSH
44542: EMPTY
44543: LIST
44544: LIST
44545: PUSH
44546: LD_INT 1
44548: NEG
44549: PUSH
44550: LD_INT 1
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: LD_INT 2
44559: NEG
44560: PUSH
44561: LD_INT 0
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 2
44570: NEG
44571: PUSH
44572: LD_INT 1
44574: NEG
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 2
44582: NEG
44583: PUSH
44584: LD_INT 2
44586: NEG
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: LIST
44601: LIST
44602: LIST
44603: LIST
44604: LIST
44605: LIST
44606: LIST
44607: LIST
44608: LIST
44609: LIST
44610: LIST
44611: LIST
44612: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44613: LD_ADDR_VAR 0 57
44617: PUSH
44618: LD_INT 0
44620: PUSH
44621: LD_INT 0
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 0
44630: PUSH
44631: LD_INT 1
44633: NEG
44634: PUSH
44635: EMPTY
44636: LIST
44637: LIST
44638: PUSH
44639: LD_INT 1
44641: PUSH
44642: LD_INT 0
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: LD_INT 1
44651: PUSH
44652: LD_INT 1
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: PUSH
44659: LD_INT 0
44661: PUSH
44662: LD_INT 1
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 1
44671: NEG
44672: PUSH
44673: LD_INT 0
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: LD_INT 1
44682: NEG
44683: PUSH
44684: LD_INT 1
44686: NEG
44687: PUSH
44688: EMPTY
44689: LIST
44690: LIST
44691: PUSH
44692: LD_INT 1
44694: NEG
44695: PUSH
44696: LD_INT 2
44698: NEG
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 0
44706: PUSH
44707: LD_INT 2
44709: NEG
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 1
44717: PUSH
44718: LD_INT 1
44720: NEG
44721: PUSH
44722: EMPTY
44723: LIST
44724: LIST
44725: PUSH
44726: LD_INT 2
44728: PUSH
44729: LD_INT 0
44731: PUSH
44732: EMPTY
44733: LIST
44734: LIST
44735: PUSH
44736: LD_INT 2
44738: PUSH
44739: LD_INT 1
44741: PUSH
44742: EMPTY
44743: LIST
44744: LIST
44745: PUSH
44746: LD_INT 2
44748: PUSH
44749: LD_INT 2
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 1
44758: PUSH
44759: LD_INT 2
44761: PUSH
44762: EMPTY
44763: LIST
44764: LIST
44765: PUSH
44766: LD_INT 0
44768: PUSH
44769: LD_INT 2
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: PUSH
44776: LD_INT 1
44778: NEG
44779: PUSH
44780: LD_INT 1
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: PUSH
44787: LD_INT 2
44789: NEG
44790: PUSH
44791: LD_INT 0
44793: PUSH
44794: EMPTY
44795: LIST
44796: LIST
44797: PUSH
44798: LD_INT 2
44800: NEG
44801: PUSH
44802: LD_INT 1
44804: NEG
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PUSH
44810: LD_INT 2
44812: NEG
44813: PUSH
44814: LD_INT 2
44816: NEG
44817: PUSH
44818: EMPTY
44819: LIST
44820: LIST
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44843: LD_ADDR_VAR 0 58
44847: PUSH
44848: LD_INT 0
44850: PUSH
44851: LD_INT 0
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: PUSH
44858: LD_INT 0
44860: PUSH
44861: LD_INT 1
44863: NEG
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 1
44871: PUSH
44872: LD_INT 0
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 1
44881: PUSH
44882: LD_INT 1
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 0
44891: PUSH
44892: LD_INT 1
44894: PUSH
44895: EMPTY
44896: LIST
44897: LIST
44898: PUSH
44899: LD_INT 1
44901: NEG
44902: PUSH
44903: LD_INT 0
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 1
44912: NEG
44913: PUSH
44914: LD_INT 1
44916: NEG
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 1
44924: NEG
44925: PUSH
44926: LD_INT 2
44928: NEG
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 0
44936: PUSH
44937: LD_INT 2
44939: NEG
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 1
44947: PUSH
44948: LD_INT 1
44950: NEG
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: PUSH
44956: LD_INT 2
44958: PUSH
44959: LD_INT 0
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 2
44968: PUSH
44969: LD_INT 1
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 2
44978: PUSH
44979: LD_INT 2
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 1
44988: PUSH
44989: LD_INT 2
44991: PUSH
44992: EMPTY
44993: LIST
44994: LIST
44995: PUSH
44996: LD_INT 0
44998: PUSH
44999: LD_INT 2
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: PUSH
45006: LD_INT 1
45008: NEG
45009: PUSH
45010: LD_INT 1
45012: PUSH
45013: EMPTY
45014: LIST
45015: LIST
45016: PUSH
45017: LD_INT 2
45019: NEG
45020: PUSH
45021: LD_INT 0
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: LD_INT 2
45030: NEG
45031: PUSH
45032: LD_INT 1
45034: NEG
45035: PUSH
45036: EMPTY
45037: LIST
45038: LIST
45039: PUSH
45040: LD_INT 2
45042: NEG
45043: PUSH
45044: LD_INT 2
45046: NEG
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: LIST
45056: LIST
45057: LIST
45058: LIST
45059: LIST
45060: LIST
45061: LIST
45062: LIST
45063: LIST
45064: LIST
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45073: LD_ADDR_VAR 0 59
45077: PUSH
45078: LD_INT 0
45080: PUSH
45081: LD_INT 0
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: LD_INT 0
45090: PUSH
45091: LD_INT 1
45093: NEG
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 1
45101: PUSH
45102: LD_INT 0
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 1
45111: PUSH
45112: LD_INT 1
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PUSH
45119: LD_INT 0
45121: PUSH
45122: LD_INT 1
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 1
45131: NEG
45132: PUSH
45133: LD_INT 0
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: PUSH
45140: LD_INT 1
45142: NEG
45143: PUSH
45144: LD_INT 1
45146: NEG
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45161: LD_ADDR_VAR 0 60
45165: PUSH
45166: LD_INT 0
45168: PUSH
45169: LD_INT 0
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 0
45178: PUSH
45179: LD_INT 1
45181: NEG
45182: PUSH
45183: EMPTY
45184: LIST
45185: LIST
45186: PUSH
45187: LD_INT 1
45189: PUSH
45190: LD_INT 0
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 1
45199: PUSH
45200: LD_INT 1
45202: PUSH
45203: EMPTY
45204: LIST
45205: LIST
45206: PUSH
45207: LD_INT 0
45209: PUSH
45210: LD_INT 1
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PUSH
45217: LD_INT 1
45219: NEG
45220: PUSH
45221: LD_INT 0
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 1
45230: NEG
45231: PUSH
45232: LD_INT 1
45234: NEG
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: LIST
45247: LIST
45248: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45249: LD_ADDR_VAR 0 61
45253: PUSH
45254: LD_INT 0
45256: PUSH
45257: LD_INT 0
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 0
45266: PUSH
45267: LD_INT 1
45269: NEG
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: LD_INT 1
45277: PUSH
45278: LD_INT 0
45280: PUSH
45281: EMPTY
45282: LIST
45283: LIST
45284: PUSH
45285: LD_INT 1
45287: PUSH
45288: LD_INT 1
45290: PUSH
45291: EMPTY
45292: LIST
45293: LIST
45294: PUSH
45295: LD_INT 0
45297: PUSH
45298: LD_INT 1
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: LD_INT 1
45307: NEG
45308: PUSH
45309: LD_INT 0
45311: PUSH
45312: EMPTY
45313: LIST
45314: LIST
45315: PUSH
45316: LD_INT 1
45318: NEG
45319: PUSH
45320: LD_INT 1
45322: NEG
45323: PUSH
45324: EMPTY
45325: LIST
45326: LIST
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45337: LD_ADDR_VAR 0 62
45341: PUSH
45342: LD_INT 0
45344: PUSH
45345: LD_INT 0
45347: PUSH
45348: EMPTY
45349: LIST
45350: LIST
45351: PUSH
45352: LD_INT 0
45354: PUSH
45355: LD_INT 1
45357: NEG
45358: PUSH
45359: EMPTY
45360: LIST
45361: LIST
45362: PUSH
45363: LD_INT 1
45365: PUSH
45366: LD_INT 0
45368: PUSH
45369: EMPTY
45370: LIST
45371: LIST
45372: PUSH
45373: LD_INT 1
45375: PUSH
45376: LD_INT 1
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: PUSH
45383: LD_INT 0
45385: PUSH
45386: LD_INT 1
45388: PUSH
45389: EMPTY
45390: LIST
45391: LIST
45392: PUSH
45393: LD_INT 1
45395: NEG
45396: PUSH
45397: LD_INT 0
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: LD_INT 1
45406: NEG
45407: PUSH
45408: LD_INT 1
45410: NEG
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: PUSH
45416: EMPTY
45417: LIST
45418: LIST
45419: LIST
45420: LIST
45421: LIST
45422: LIST
45423: LIST
45424: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45425: LD_ADDR_VAR 0 63
45429: PUSH
45430: LD_INT 0
45432: PUSH
45433: LD_INT 0
45435: PUSH
45436: EMPTY
45437: LIST
45438: LIST
45439: PUSH
45440: LD_INT 0
45442: PUSH
45443: LD_INT 1
45445: NEG
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 1
45453: PUSH
45454: LD_INT 0
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: LD_INT 1
45463: PUSH
45464: LD_INT 1
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: LD_INT 0
45473: PUSH
45474: LD_INT 1
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: PUSH
45481: LD_INT 1
45483: NEG
45484: PUSH
45485: LD_INT 0
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 1
45494: NEG
45495: PUSH
45496: LD_INT 1
45498: NEG
45499: PUSH
45500: EMPTY
45501: LIST
45502: LIST
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: LIST
45508: LIST
45509: LIST
45510: LIST
45511: LIST
45512: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45513: LD_ADDR_VAR 0 64
45517: PUSH
45518: LD_INT 0
45520: PUSH
45521: LD_INT 0
45523: PUSH
45524: EMPTY
45525: LIST
45526: LIST
45527: PUSH
45528: LD_INT 0
45530: PUSH
45531: LD_INT 1
45533: NEG
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 1
45541: PUSH
45542: LD_INT 0
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 1
45551: PUSH
45552: LD_INT 1
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 0
45561: PUSH
45562: LD_INT 1
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: PUSH
45569: LD_INT 1
45571: NEG
45572: PUSH
45573: LD_INT 0
45575: PUSH
45576: EMPTY
45577: LIST
45578: LIST
45579: PUSH
45580: LD_INT 1
45582: NEG
45583: PUSH
45584: LD_INT 1
45586: NEG
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: LIST
45596: LIST
45597: LIST
45598: LIST
45599: LIST
45600: ST_TO_ADDR
// end ; 1 :
45601: GO 51498
45603: LD_INT 1
45605: DOUBLE
45606: EQUAL
45607: IFTRUE 45611
45609: GO 48234
45611: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45612: LD_ADDR_VAR 0 11
45616: PUSH
45617: LD_INT 1
45619: NEG
45620: PUSH
45621: LD_INT 3
45623: NEG
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: PUSH
45629: LD_INT 0
45631: PUSH
45632: LD_INT 3
45634: NEG
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: PUSH
45640: LD_INT 1
45642: PUSH
45643: LD_INT 2
45645: NEG
45646: PUSH
45647: EMPTY
45648: LIST
45649: LIST
45650: PUSH
45651: EMPTY
45652: LIST
45653: LIST
45654: LIST
45655: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45656: LD_ADDR_VAR 0 12
45660: PUSH
45661: LD_INT 2
45663: PUSH
45664: LD_INT 1
45666: NEG
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: PUSH
45672: LD_INT 3
45674: PUSH
45675: LD_INT 0
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: PUSH
45682: LD_INT 3
45684: PUSH
45685: LD_INT 1
45687: PUSH
45688: EMPTY
45689: LIST
45690: LIST
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: LIST
45696: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45697: LD_ADDR_VAR 0 13
45701: PUSH
45702: LD_INT 3
45704: PUSH
45705: LD_INT 2
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: PUSH
45712: LD_INT 3
45714: PUSH
45715: LD_INT 3
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PUSH
45722: LD_INT 2
45724: PUSH
45725: LD_INT 3
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: LIST
45736: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45737: LD_ADDR_VAR 0 14
45741: PUSH
45742: LD_INT 1
45744: PUSH
45745: LD_INT 3
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 0
45754: PUSH
45755: LD_INT 3
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 1
45764: NEG
45765: PUSH
45766: LD_INT 2
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: LIST
45777: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45778: LD_ADDR_VAR 0 15
45782: PUSH
45783: LD_INT 2
45785: NEG
45786: PUSH
45787: LD_INT 1
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PUSH
45794: LD_INT 3
45796: NEG
45797: PUSH
45798: LD_INT 0
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 3
45807: NEG
45808: PUSH
45809: LD_INT 1
45811: NEG
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: LIST
45821: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45822: LD_ADDR_VAR 0 16
45826: PUSH
45827: LD_INT 2
45829: NEG
45830: PUSH
45831: LD_INT 3
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 3
45841: NEG
45842: PUSH
45843: LD_INT 2
45845: NEG
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 3
45853: NEG
45854: PUSH
45855: LD_INT 3
45857: NEG
45858: PUSH
45859: EMPTY
45860: LIST
45861: LIST
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: LIST
45867: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45868: LD_ADDR_VAR 0 17
45872: PUSH
45873: LD_INT 1
45875: NEG
45876: PUSH
45877: LD_INT 3
45879: NEG
45880: PUSH
45881: EMPTY
45882: LIST
45883: LIST
45884: PUSH
45885: LD_INT 0
45887: PUSH
45888: LD_INT 3
45890: NEG
45891: PUSH
45892: EMPTY
45893: LIST
45894: LIST
45895: PUSH
45896: LD_INT 1
45898: PUSH
45899: LD_INT 2
45901: NEG
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: PUSH
45907: EMPTY
45908: LIST
45909: LIST
45910: LIST
45911: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45912: LD_ADDR_VAR 0 18
45916: PUSH
45917: LD_INT 2
45919: PUSH
45920: LD_INT 1
45922: NEG
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: LD_INT 3
45930: PUSH
45931: LD_INT 0
45933: PUSH
45934: EMPTY
45935: LIST
45936: LIST
45937: PUSH
45938: LD_INT 3
45940: PUSH
45941: LD_INT 1
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: EMPTY
45949: LIST
45950: LIST
45951: LIST
45952: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45953: LD_ADDR_VAR 0 19
45957: PUSH
45958: LD_INT 3
45960: PUSH
45961: LD_INT 2
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: PUSH
45968: LD_INT 3
45970: PUSH
45971: LD_INT 3
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 2
45980: PUSH
45981: LD_INT 3
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: LIST
45992: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45993: LD_ADDR_VAR 0 20
45997: PUSH
45998: LD_INT 1
46000: PUSH
46001: LD_INT 3
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 0
46010: PUSH
46011: LD_INT 3
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: LD_INT 1
46020: NEG
46021: PUSH
46022: LD_INT 2
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: EMPTY
46030: LIST
46031: LIST
46032: LIST
46033: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46034: LD_ADDR_VAR 0 21
46038: PUSH
46039: LD_INT 2
46041: NEG
46042: PUSH
46043: LD_INT 1
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 3
46052: NEG
46053: PUSH
46054: LD_INT 0
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 3
46063: NEG
46064: PUSH
46065: LD_INT 1
46067: NEG
46068: PUSH
46069: EMPTY
46070: LIST
46071: LIST
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: LIST
46077: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46078: LD_ADDR_VAR 0 22
46082: PUSH
46083: LD_INT 2
46085: NEG
46086: PUSH
46087: LD_INT 3
46089: NEG
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 3
46097: NEG
46098: PUSH
46099: LD_INT 2
46101: NEG
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: PUSH
46107: LD_INT 3
46109: NEG
46110: PUSH
46111: LD_INT 3
46113: NEG
46114: PUSH
46115: EMPTY
46116: LIST
46117: LIST
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: LIST
46123: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46124: LD_ADDR_VAR 0 23
46128: PUSH
46129: LD_INT 0
46131: PUSH
46132: LD_INT 3
46134: NEG
46135: PUSH
46136: EMPTY
46137: LIST
46138: LIST
46139: PUSH
46140: LD_INT 1
46142: NEG
46143: PUSH
46144: LD_INT 4
46146: NEG
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: PUSH
46152: LD_INT 1
46154: PUSH
46155: LD_INT 3
46157: NEG
46158: PUSH
46159: EMPTY
46160: LIST
46161: LIST
46162: PUSH
46163: EMPTY
46164: LIST
46165: LIST
46166: LIST
46167: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46168: LD_ADDR_VAR 0 24
46172: PUSH
46173: LD_INT 3
46175: PUSH
46176: LD_INT 0
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PUSH
46183: LD_INT 3
46185: PUSH
46186: LD_INT 1
46188: NEG
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 4
46196: PUSH
46197: LD_INT 1
46199: PUSH
46200: EMPTY
46201: LIST
46202: LIST
46203: PUSH
46204: EMPTY
46205: LIST
46206: LIST
46207: LIST
46208: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46209: LD_ADDR_VAR 0 25
46213: PUSH
46214: LD_INT 3
46216: PUSH
46217: LD_INT 3
46219: PUSH
46220: EMPTY
46221: LIST
46222: LIST
46223: PUSH
46224: LD_INT 4
46226: PUSH
46227: LD_INT 3
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PUSH
46234: LD_INT 3
46236: PUSH
46237: LD_INT 4
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: LIST
46248: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46249: LD_ADDR_VAR 0 26
46253: PUSH
46254: LD_INT 0
46256: PUSH
46257: LD_INT 3
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 1
46266: PUSH
46267: LD_INT 4
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 1
46276: NEG
46277: PUSH
46278: LD_INT 3
46280: PUSH
46281: EMPTY
46282: LIST
46283: LIST
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: LIST
46289: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46290: LD_ADDR_VAR 0 27
46294: PUSH
46295: LD_INT 3
46297: NEG
46298: PUSH
46299: LD_INT 0
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: PUSH
46306: LD_INT 3
46308: NEG
46309: PUSH
46310: LD_INT 1
46312: PUSH
46313: EMPTY
46314: LIST
46315: LIST
46316: PUSH
46317: LD_INT 4
46319: NEG
46320: PUSH
46321: LD_INT 1
46323: NEG
46324: PUSH
46325: EMPTY
46326: LIST
46327: LIST
46328: PUSH
46329: EMPTY
46330: LIST
46331: LIST
46332: LIST
46333: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46334: LD_ADDR_VAR 0 28
46338: PUSH
46339: LD_INT 3
46341: NEG
46342: PUSH
46343: LD_INT 3
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 3
46353: NEG
46354: PUSH
46355: LD_INT 4
46357: NEG
46358: PUSH
46359: EMPTY
46360: LIST
46361: LIST
46362: PUSH
46363: LD_INT 4
46365: NEG
46366: PUSH
46367: LD_INT 3
46369: NEG
46370: PUSH
46371: EMPTY
46372: LIST
46373: LIST
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: LIST
46379: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46380: LD_ADDR_VAR 0 29
46384: PUSH
46385: LD_INT 1
46387: NEG
46388: PUSH
46389: LD_INT 3
46391: NEG
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: PUSH
46397: LD_INT 0
46399: PUSH
46400: LD_INT 3
46402: NEG
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 1
46410: PUSH
46411: LD_INT 2
46413: NEG
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 1
46421: NEG
46422: PUSH
46423: LD_INT 4
46425: NEG
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 0
46433: PUSH
46434: LD_INT 4
46436: NEG
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: PUSH
46442: LD_INT 1
46444: PUSH
46445: LD_INT 3
46447: NEG
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: LD_INT 1
46455: NEG
46456: PUSH
46457: LD_INT 5
46459: NEG
46460: PUSH
46461: EMPTY
46462: LIST
46463: LIST
46464: PUSH
46465: LD_INT 0
46467: PUSH
46468: LD_INT 5
46470: NEG
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: PUSH
46476: LD_INT 1
46478: PUSH
46479: LD_INT 4
46481: NEG
46482: PUSH
46483: EMPTY
46484: LIST
46485: LIST
46486: PUSH
46487: LD_INT 1
46489: NEG
46490: PUSH
46491: LD_INT 6
46493: NEG
46494: PUSH
46495: EMPTY
46496: LIST
46497: LIST
46498: PUSH
46499: LD_INT 0
46501: PUSH
46502: LD_INT 6
46504: NEG
46505: PUSH
46506: EMPTY
46507: LIST
46508: LIST
46509: PUSH
46510: LD_INT 1
46512: PUSH
46513: LD_INT 5
46515: NEG
46516: PUSH
46517: EMPTY
46518: LIST
46519: LIST
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46535: LD_ADDR_VAR 0 30
46539: PUSH
46540: LD_INT 2
46542: PUSH
46543: LD_INT 1
46545: NEG
46546: PUSH
46547: EMPTY
46548: LIST
46549: LIST
46550: PUSH
46551: LD_INT 3
46553: PUSH
46554: LD_INT 0
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: PUSH
46561: LD_INT 3
46563: PUSH
46564: LD_INT 1
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: PUSH
46571: LD_INT 3
46573: PUSH
46574: LD_INT 1
46576: NEG
46577: PUSH
46578: EMPTY
46579: LIST
46580: LIST
46581: PUSH
46582: LD_INT 4
46584: PUSH
46585: LD_INT 0
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: PUSH
46592: LD_INT 4
46594: PUSH
46595: LD_INT 1
46597: PUSH
46598: EMPTY
46599: LIST
46600: LIST
46601: PUSH
46602: LD_INT 4
46604: PUSH
46605: LD_INT 1
46607: NEG
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 5
46615: PUSH
46616: LD_INT 0
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: PUSH
46623: LD_INT 5
46625: PUSH
46626: LD_INT 1
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 5
46635: PUSH
46636: LD_INT 1
46638: NEG
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 6
46646: PUSH
46647: LD_INT 0
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: PUSH
46654: LD_INT 6
46656: PUSH
46657: LD_INT 1
46659: PUSH
46660: EMPTY
46661: LIST
46662: LIST
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: LIST
46668: LIST
46669: LIST
46670: LIST
46671: LIST
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: LIST
46677: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46678: LD_ADDR_VAR 0 31
46682: PUSH
46683: LD_INT 3
46685: PUSH
46686: LD_INT 2
46688: PUSH
46689: EMPTY
46690: LIST
46691: LIST
46692: PUSH
46693: LD_INT 3
46695: PUSH
46696: LD_INT 3
46698: PUSH
46699: EMPTY
46700: LIST
46701: LIST
46702: PUSH
46703: LD_INT 2
46705: PUSH
46706: LD_INT 3
46708: PUSH
46709: EMPTY
46710: LIST
46711: LIST
46712: PUSH
46713: LD_INT 4
46715: PUSH
46716: LD_INT 3
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: PUSH
46723: LD_INT 4
46725: PUSH
46726: LD_INT 4
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: PUSH
46733: LD_INT 3
46735: PUSH
46736: LD_INT 4
46738: PUSH
46739: EMPTY
46740: LIST
46741: LIST
46742: PUSH
46743: LD_INT 5
46745: PUSH
46746: LD_INT 4
46748: PUSH
46749: EMPTY
46750: LIST
46751: LIST
46752: PUSH
46753: LD_INT 5
46755: PUSH
46756: LD_INT 5
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: PUSH
46763: LD_INT 4
46765: PUSH
46766: LD_INT 5
46768: PUSH
46769: EMPTY
46770: LIST
46771: LIST
46772: PUSH
46773: LD_INT 6
46775: PUSH
46776: LD_INT 5
46778: PUSH
46779: EMPTY
46780: LIST
46781: LIST
46782: PUSH
46783: LD_INT 6
46785: PUSH
46786: LD_INT 6
46788: PUSH
46789: EMPTY
46790: LIST
46791: LIST
46792: PUSH
46793: LD_INT 5
46795: PUSH
46796: LD_INT 6
46798: PUSH
46799: EMPTY
46800: LIST
46801: LIST
46802: PUSH
46803: EMPTY
46804: LIST
46805: LIST
46806: LIST
46807: LIST
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46817: LD_ADDR_VAR 0 32
46821: PUSH
46822: LD_INT 1
46824: PUSH
46825: LD_INT 3
46827: PUSH
46828: EMPTY
46829: LIST
46830: LIST
46831: PUSH
46832: LD_INT 0
46834: PUSH
46835: LD_INT 3
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: PUSH
46842: LD_INT 1
46844: NEG
46845: PUSH
46846: LD_INT 2
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PUSH
46853: LD_INT 1
46855: PUSH
46856: LD_INT 4
46858: PUSH
46859: EMPTY
46860: LIST
46861: LIST
46862: PUSH
46863: LD_INT 0
46865: PUSH
46866: LD_INT 4
46868: PUSH
46869: EMPTY
46870: LIST
46871: LIST
46872: PUSH
46873: LD_INT 1
46875: NEG
46876: PUSH
46877: LD_INT 3
46879: PUSH
46880: EMPTY
46881: LIST
46882: LIST
46883: PUSH
46884: LD_INT 1
46886: PUSH
46887: LD_INT 5
46889: PUSH
46890: EMPTY
46891: LIST
46892: LIST
46893: PUSH
46894: LD_INT 0
46896: PUSH
46897: LD_INT 5
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: PUSH
46904: LD_INT 1
46906: NEG
46907: PUSH
46908: LD_INT 4
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: LD_INT 1
46917: PUSH
46918: LD_INT 6
46920: PUSH
46921: EMPTY
46922: LIST
46923: LIST
46924: PUSH
46925: LD_INT 0
46927: PUSH
46928: LD_INT 6
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: PUSH
46935: LD_INT 1
46937: NEG
46938: PUSH
46939: LD_INT 5
46941: PUSH
46942: EMPTY
46943: LIST
46944: LIST
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46960: LD_ADDR_VAR 0 33
46964: PUSH
46965: LD_INT 2
46967: NEG
46968: PUSH
46969: LD_INT 1
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 3
46978: NEG
46979: PUSH
46980: LD_INT 0
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: LD_INT 3
46989: NEG
46990: PUSH
46991: LD_INT 1
46993: NEG
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 3
47001: NEG
47002: PUSH
47003: LD_INT 1
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 4
47012: NEG
47013: PUSH
47014: LD_INT 0
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 4
47023: NEG
47024: PUSH
47025: LD_INT 1
47027: NEG
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 4
47035: NEG
47036: PUSH
47037: LD_INT 1
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: PUSH
47044: LD_INT 5
47046: NEG
47047: PUSH
47048: LD_INT 0
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: PUSH
47055: LD_INT 5
47057: NEG
47058: PUSH
47059: LD_INT 1
47061: NEG
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PUSH
47067: LD_INT 5
47069: NEG
47070: PUSH
47071: LD_INT 1
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: LD_INT 6
47080: NEG
47081: PUSH
47082: LD_INT 0
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: LD_INT 6
47091: NEG
47092: PUSH
47093: LD_INT 1
47095: NEG
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: EMPTY
47102: LIST
47103: LIST
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47115: LD_ADDR_VAR 0 34
47119: PUSH
47120: LD_INT 2
47122: NEG
47123: PUSH
47124: LD_INT 3
47126: NEG
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 3
47134: NEG
47135: PUSH
47136: LD_INT 2
47138: NEG
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PUSH
47144: LD_INT 3
47146: NEG
47147: PUSH
47148: LD_INT 3
47150: NEG
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 3
47158: NEG
47159: PUSH
47160: LD_INT 4
47162: NEG
47163: PUSH
47164: EMPTY
47165: LIST
47166: LIST
47167: PUSH
47168: LD_INT 4
47170: NEG
47171: PUSH
47172: LD_INT 3
47174: NEG
47175: PUSH
47176: EMPTY
47177: LIST
47178: LIST
47179: PUSH
47180: LD_INT 4
47182: NEG
47183: PUSH
47184: LD_INT 4
47186: NEG
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: LD_INT 4
47194: NEG
47195: PUSH
47196: LD_INT 5
47198: NEG
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PUSH
47204: LD_INT 5
47206: NEG
47207: PUSH
47208: LD_INT 4
47210: NEG
47211: PUSH
47212: EMPTY
47213: LIST
47214: LIST
47215: PUSH
47216: LD_INT 5
47218: NEG
47219: PUSH
47220: LD_INT 5
47222: NEG
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 5
47230: NEG
47231: PUSH
47232: LD_INT 6
47234: NEG
47235: PUSH
47236: EMPTY
47237: LIST
47238: LIST
47239: PUSH
47240: LD_INT 6
47242: NEG
47243: PUSH
47244: LD_INT 5
47246: NEG
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: PUSH
47252: LD_INT 6
47254: NEG
47255: PUSH
47256: LD_INT 6
47258: NEG
47259: PUSH
47260: EMPTY
47261: LIST
47262: LIST
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47278: LD_ADDR_VAR 0 41
47282: PUSH
47283: LD_INT 0
47285: PUSH
47286: LD_INT 2
47288: NEG
47289: PUSH
47290: EMPTY
47291: LIST
47292: LIST
47293: PUSH
47294: LD_INT 1
47296: NEG
47297: PUSH
47298: LD_INT 3
47300: NEG
47301: PUSH
47302: EMPTY
47303: LIST
47304: LIST
47305: PUSH
47306: LD_INT 1
47308: PUSH
47309: LD_INT 2
47311: NEG
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: LIST
47321: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47322: LD_ADDR_VAR 0 42
47326: PUSH
47327: LD_INT 2
47329: PUSH
47330: LD_INT 0
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 2
47339: PUSH
47340: LD_INT 1
47342: NEG
47343: PUSH
47344: EMPTY
47345: LIST
47346: LIST
47347: PUSH
47348: LD_INT 3
47350: PUSH
47351: LD_INT 1
47353: PUSH
47354: EMPTY
47355: LIST
47356: LIST
47357: PUSH
47358: EMPTY
47359: LIST
47360: LIST
47361: LIST
47362: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47363: LD_ADDR_VAR 0 43
47367: PUSH
47368: LD_INT 2
47370: PUSH
47371: LD_INT 2
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: PUSH
47378: LD_INT 3
47380: PUSH
47381: LD_INT 2
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: PUSH
47388: LD_INT 2
47390: PUSH
47391: LD_INT 3
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PUSH
47398: EMPTY
47399: LIST
47400: LIST
47401: LIST
47402: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47403: LD_ADDR_VAR 0 44
47407: PUSH
47408: LD_INT 0
47410: PUSH
47411: LD_INT 2
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: PUSH
47418: LD_INT 1
47420: PUSH
47421: LD_INT 3
47423: PUSH
47424: EMPTY
47425: LIST
47426: LIST
47427: PUSH
47428: LD_INT 1
47430: NEG
47431: PUSH
47432: LD_INT 2
47434: PUSH
47435: EMPTY
47436: LIST
47437: LIST
47438: PUSH
47439: EMPTY
47440: LIST
47441: LIST
47442: LIST
47443: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47444: LD_ADDR_VAR 0 45
47448: PUSH
47449: LD_INT 2
47451: NEG
47452: PUSH
47453: LD_INT 0
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: PUSH
47460: LD_INT 2
47462: NEG
47463: PUSH
47464: LD_INT 1
47466: PUSH
47467: EMPTY
47468: LIST
47469: LIST
47470: PUSH
47471: LD_INT 3
47473: NEG
47474: PUSH
47475: LD_INT 1
47477: NEG
47478: PUSH
47479: EMPTY
47480: LIST
47481: LIST
47482: PUSH
47483: EMPTY
47484: LIST
47485: LIST
47486: LIST
47487: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47488: LD_ADDR_VAR 0 46
47492: PUSH
47493: LD_INT 2
47495: NEG
47496: PUSH
47497: LD_INT 2
47499: NEG
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: PUSH
47505: LD_INT 2
47507: NEG
47508: PUSH
47509: LD_INT 3
47511: NEG
47512: PUSH
47513: EMPTY
47514: LIST
47515: LIST
47516: PUSH
47517: LD_INT 3
47519: NEG
47520: PUSH
47521: LD_INT 2
47523: NEG
47524: PUSH
47525: EMPTY
47526: LIST
47527: LIST
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: LIST
47533: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47534: LD_ADDR_VAR 0 47
47538: PUSH
47539: LD_INT 2
47541: NEG
47542: PUSH
47543: LD_INT 3
47545: NEG
47546: PUSH
47547: EMPTY
47548: LIST
47549: LIST
47550: PUSH
47551: LD_INT 1
47553: NEG
47554: PUSH
47555: LD_INT 3
47557: NEG
47558: PUSH
47559: EMPTY
47560: LIST
47561: LIST
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47567: LD_ADDR_VAR 0 48
47571: PUSH
47572: LD_INT 1
47574: PUSH
47575: LD_INT 2
47577: NEG
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: PUSH
47583: LD_INT 2
47585: PUSH
47586: LD_INT 1
47588: NEG
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: PUSH
47594: EMPTY
47595: LIST
47596: LIST
47597: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47598: LD_ADDR_VAR 0 49
47602: PUSH
47603: LD_INT 3
47605: PUSH
47606: LD_INT 1
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 3
47615: PUSH
47616: LD_INT 2
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47627: LD_ADDR_VAR 0 50
47631: PUSH
47632: LD_INT 2
47634: PUSH
47635: LD_INT 3
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: LD_INT 1
47644: PUSH
47645: LD_INT 3
47647: PUSH
47648: EMPTY
47649: LIST
47650: LIST
47651: PUSH
47652: EMPTY
47653: LIST
47654: LIST
47655: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47656: LD_ADDR_VAR 0 51
47660: PUSH
47661: LD_INT 1
47663: NEG
47664: PUSH
47665: LD_INT 2
47667: PUSH
47668: EMPTY
47669: LIST
47670: LIST
47671: PUSH
47672: LD_INT 2
47674: NEG
47675: PUSH
47676: LD_INT 1
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: EMPTY
47684: LIST
47685: LIST
47686: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47687: LD_ADDR_VAR 0 52
47691: PUSH
47692: LD_INT 3
47694: NEG
47695: PUSH
47696: LD_INT 1
47698: NEG
47699: PUSH
47700: EMPTY
47701: LIST
47702: LIST
47703: PUSH
47704: LD_INT 3
47706: NEG
47707: PUSH
47708: LD_INT 2
47710: NEG
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47720: LD_ADDR_VAR 0 53
47724: PUSH
47725: LD_INT 1
47727: NEG
47728: PUSH
47729: LD_INT 3
47731: NEG
47732: PUSH
47733: EMPTY
47734: LIST
47735: LIST
47736: PUSH
47737: LD_INT 0
47739: PUSH
47740: LD_INT 3
47742: NEG
47743: PUSH
47744: EMPTY
47745: LIST
47746: LIST
47747: PUSH
47748: LD_INT 1
47750: PUSH
47751: LD_INT 2
47753: NEG
47754: PUSH
47755: EMPTY
47756: LIST
47757: LIST
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: LIST
47763: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47764: LD_ADDR_VAR 0 54
47768: PUSH
47769: LD_INT 2
47771: PUSH
47772: LD_INT 1
47774: NEG
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: LD_INT 3
47782: PUSH
47783: LD_INT 0
47785: PUSH
47786: EMPTY
47787: LIST
47788: LIST
47789: PUSH
47790: LD_INT 3
47792: PUSH
47793: LD_INT 1
47795: PUSH
47796: EMPTY
47797: LIST
47798: LIST
47799: PUSH
47800: EMPTY
47801: LIST
47802: LIST
47803: LIST
47804: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47805: LD_ADDR_VAR 0 55
47809: PUSH
47810: LD_INT 3
47812: PUSH
47813: LD_INT 2
47815: PUSH
47816: EMPTY
47817: LIST
47818: LIST
47819: PUSH
47820: LD_INT 3
47822: PUSH
47823: LD_INT 3
47825: PUSH
47826: EMPTY
47827: LIST
47828: LIST
47829: PUSH
47830: LD_INT 2
47832: PUSH
47833: LD_INT 3
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: LIST
47844: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47845: LD_ADDR_VAR 0 56
47849: PUSH
47850: LD_INT 1
47852: PUSH
47853: LD_INT 3
47855: PUSH
47856: EMPTY
47857: LIST
47858: LIST
47859: PUSH
47860: LD_INT 0
47862: PUSH
47863: LD_INT 3
47865: PUSH
47866: EMPTY
47867: LIST
47868: LIST
47869: PUSH
47870: LD_INT 1
47872: NEG
47873: PUSH
47874: LD_INT 2
47876: PUSH
47877: EMPTY
47878: LIST
47879: LIST
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: LIST
47885: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47886: LD_ADDR_VAR 0 57
47890: PUSH
47891: LD_INT 2
47893: NEG
47894: PUSH
47895: LD_INT 1
47897: PUSH
47898: EMPTY
47899: LIST
47900: LIST
47901: PUSH
47902: LD_INT 3
47904: NEG
47905: PUSH
47906: LD_INT 0
47908: PUSH
47909: EMPTY
47910: LIST
47911: LIST
47912: PUSH
47913: LD_INT 3
47915: NEG
47916: PUSH
47917: LD_INT 1
47919: NEG
47920: PUSH
47921: EMPTY
47922: LIST
47923: LIST
47924: PUSH
47925: EMPTY
47926: LIST
47927: LIST
47928: LIST
47929: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47930: LD_ADDR_VAR 0 58
47934: PUSH
47935: LD_INT 2
47937: NEG
47938: PUSH
47939: LD_INT 3
47941: NEG
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 3
47949: NEG
47950: PUSH
47951: LD_INT 2
47953: NEG
47954: PUSH
47955: EMPTY
47956: LIST
47957: LIST
47958: PUSH
47959: LD_INT 3
47961: NEG
47962: PUSH
47963: LD_INT 3
47965: NEG
47966: PUSH
47967: EMPTY
47968: LIST
47969: LIST
47970: PUSH
47971: EMPTY
47972: LIST
47973: LIST
47974: LIST
47975: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47976: LD_ADDR_VAR 0 59
47980: PUSH
47981: LD_INT 1
47983: NEG
47984: PUSH
47985: LD_INT 2
47987: NEG
47988: PUSH
47989: EMPTY
47990: LIST
47991: LIST
47992: PUSH
47993: LD_INT 0
47995: PUSH
47996: LD_INT 2
47998: NEG
47999: PUSH
48000: EMPTY
48001: LIST
48002: LIST
48003: PUSH
48004: LD_INT 1
48006: PUSH
48007: LD_INT 1
48009: NEG
48010: PUSH
48011: EMPTY
48012: LIST
48013: LIST
48014: PUSH
48015: EMPTY
48016: LIST
48017: LIST
48018: LIST
48019: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48020: LD_ADDR_VAR 0 60
48024: PUSH
48025: LD_INT 1
48027: PUSH
48028: LD_INT 1
48030: NEG
48031: PUSH
48032: EMPTY
48033: LIST
48034: LIST
48035: PUSH
48036: LD_INT 2
48038: PUSH
48039: LD_INT 0
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: PUSH
48046: LD_INT 2
48048: PUSH
48049: LD_INT 1
48051: PUSH
48052: EMPTY
48053: LIST
48054: LIST
48055: PUSH
48056: EMPTY
48057: LIST
48058: LIST
48059: LIST
48060: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48061: LD_ADDR_VAR 0 61
48065: PUSH
48066: LD_INT 2
48068: PUSH
48069: LD_INT 1
48071: PUSH
48072: EMPTY
48073: LIST
48074: LIST
48075: PUSH
48076: LD_INT 2
48078: PUSH
48079: LD_INT 2
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PUSH
48086: LD_INT 1
48088: PUSH
48089: LD_INT 2
48091: PUSH
48092: EMPTY
48093: LIST
48094: LIST
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: LIST
48100: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48101: LD_ADDR_VAR 0 62
48105: PUSH
48106: LD_INT 1
48108: PUSH
48109: LD_INT 2
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: PUSH
48116: LD_INT 0
48118: PUSH
48119: LD_INT 2
48121: PUSH
48122: EMPTY
48123: LIST
48124: LIST
48125: PUSH
48126: LD_INT 1
48128: NEG
48129: PUSH
48130: LD_INT 1
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: PUSH
48137: EMPTY
48138: LIST
48139: LIST
48140: LIST
48141: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48142: LD_ADDR_VAR 0 63
48146: PUSH
48147: LD_INT 1
48149: NEG
48150: PUSH
48151: LD_INT 1
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PUSH
48158: LD_INT 2
48160: NEG
48161: PUSH
48162: LD_INT 0
48164: PUSH
48165: EMPTY
48166: LIST
48167: LIST
48168: PUSH
48169: LD_INT 2
48171: NEG
48172: PUSH
48173: LD_INT 1
48175: NEG
48176: PUSH
48177: EMPTY
48178: LIST
48179: LIST
48180: PUSH
48181: EMPTY
48182: LIST
48183: LIST
48184: LIST
48185: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48186: LD_ADDR_VAR 0 64
48190: PUSH
48191: LD_INT 1
48193: NEG
48194: PUSH
48195: LD_INT 2
48197: NEG
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 2
48205: NEG
48206: PUSH
48207: LD_INT 1
48209: NEG
48210: PUSH
48211: EMPTY
48212: LIST
48213: LIST
48214: PUSH
48215: LD_INT 2
48217: NEG
48218: PUSH
48219: LD_INT 2
48221: NEG
48222: PUSH
48223: EMPTY
48224: LIST
48225: LIST
48226: PUSH
48227: EMPTY
48228: LIST
48229: LIST
48230: LIST
48231: ST_TO_ADDR
// end ; 2 :
48232: GO 51498
48234: LD_INT 2
48236: DOUBLE
48237: EQUAL
48238: IFTRUE 48242
48240: GO 51497
48242: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48243: LD_ADDR_VAR 0 29
48247: PUSH
48248: LD_INT 4
48250: PUSH
48251: LD_INT 0
48253: PUSH
48254: EMPTY
48255: LIST
48256: LIST
48257: PUSH
48258: LD_INT 4
48260: PUSH
48261: LD_INT 1
48263: NEG
48264: PUSH
48265: EMPTY
48266: LIST
48267: LIST
48268: PUSH
48269: LD_INT 5
48271: PUSH
48272: LD_INT 0
48274: PUSH
48275: EMPTY
48276: LIST
48277: LIST
48278: PUSH
48279: LD_INT 5
48281: PUSH
48282: LD_INT 1
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_INT 4
48291: PUSH
48292: LD_INT 1
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: PUSH
48299: LD_INT 3
48301: PUSH
48302: LD_INT 0
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 3
48311: PUSH
48312: LD_INT 1
48314: NEG
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: LD_INT 3
48322: PUSH
48323: LD_INT 2
48325: NEG
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 5
48333: PUSH
48334: LD_INT 2
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: PUSH
48341: LD_INT 3
48343: PUSH
48344: LD_INT 3
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: PUSH
48351: LD_INT 3
48353: PUSH
48354: LD_INT 2
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: PUSH
48361: LD_INT 4
48363: PUSH
48364: LD_INT 3
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: PUSH
48371: LD_INT 4
48373: PUSH
48374: LD_INT 4
48376: PUSH
48377: EMPTY
48378: LIST
48379: LIST
48380: PUSH
48381: LD_INT 3
48383: PUSH
48384: LD_INT 4
48386: PUSH
48387: EMPTY
48388: LIST
48389: LIST
48390: PUSH
48391: LD_INT 2
48393: PUSH
48394: LD_INT 3
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: PUSH
48401: LD_INT 2
48403: PUSH
48404: LD_INT 2
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PUSH
48411: LD_INT 4
48413: PUSH
48414: LD_INT 2
48416: PUSH
48417: EMPTY
48418: LIST
48419: LIST
48420: PUSH
48421: LD_INT 2
48423: PUSH
48424: LD_INT 4
48426: PUSH
48427: EMPTY
48428: LIST
48429: LIST
48430: PUSH
48431: LD_INT 0
48433: PUSH
48434: LD_INT 4
48436: PUSH
48437: EMPTY
48438: LIST
48439: LIST
48440: PUSH
48441: LD_INT 0
48443: PUSH
48444: LD_INT 3
48446: PUSH
48447: EMPTY
48448: LIST
48449: LIST
48450: PUSH
48451: LD_INT 1
48453: PUSH
48454: LD_INT 4
48456: PUSH
48457: EMPTY
48458: LIST
48459: LIST
48460: PUSH
48461: LD_INT 1
48463: PUSH
48464: LD_INT 5
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: PUSH
48471: LD_INT 0
48473: PUSH
48474: LD_INT 5
48476: PUSH
48477: EMPTY
48478: LIST
48479: LIST
48480: PUSH
48481: LD_INT 1
48483: NEG
48484: PUSH
48485: LD_INT 4
48487: PUSH
48488: EMPTY
48489: LIST
48490: LIST
48491: PUSH
48492: LD_INT 1
48494: NEG
48495: PUSH
48496: LD_INT 3
48498: PUSH
48499: EMPTY
48500: LIST
48501: LIST
48502: PUSH
48503: LD_INT 2
48505: PUSH
48506: LD_INT 5
48508: PUSH
48509: EMPTY
48510: LIST
48511: LIST
48512: PUSH
48513: LD_INT 2
48515: NEG
48516: PUSH
48517: LD_INT 3
48519: PUSH
48520: EMPTY
48521: LIST
48522: LIST
48523: PUSH
48524: LD_INT 3
48526: NEG
48527: PUSH
48528: LD_INT 0
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: PUSH
48535: LD_INT 3
48537: NEG
48538: PUSH
48539: LD_INT 1
48541: NEG
48542: PUSH
48543: EMPTY
48544: LIST
48545: LIST
48546: PUSH
48547: LD_INT 2
48549: NEG
48550: PUSH
48551: LD_INT 0
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PUSH
48558: LD_INT 2
48560: NEG
48561: PUSH
48562: LD_INT 1
48564: PUSH
48565: EMPTY
48566: LIST
48567: LIST
48568: PUSH
48569: LD_INT 3
48571: NEG
48572: PUSH
48573: LD_INT 1
48575: PUSH
48576: EMPTY
48577: LIST
48578: LIST
48579: PUSH
48580: LD_INT 4
48582: NEG
48583: PUSH
48584: LD_INT 0
48586: PUSH
48587: EMPTY
48588: LIST
48589: LIST
48590: PUSH
48591: LD_INT 4
48593: NEG
48594: PUSH
48595: LD_INT 1
48597: NEG
48598: PUSH
48599: EMPTY
48600: LIST
48601: LIST
48602: PUSH
48603: LD_INT 4
48605: NEG
48606: PUSH
48607: LD_INT 2
48609: NEG
48610: PUSH
48611: EMPTY
48612: LIST
48613: LIST
48614: PUSH
48615: LD_INT 2
48617: NEG
48618: PUSH
48619: LD_INT 2
48621: PUSH
48622: EMPTY
48623: LIST
48624: LIST
48625: PUSH
48626: LD_INT 4
48628: NEG
48629: PUSH
48630: LD_INT 4
48632: NEG
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: PUSH
48638: LD_INT 4
48640: NEG
48641: PUSH
48642: LD_INT 5
48644: NEG
48645: PUSH
48646: EMPTY
48647: LIST
48648: LIST
48649: PUSH
48650: LD_INT 3
48652: NEG
48653: PUSH
48654: LD_INT 4
48656: NEG
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: PUSH
48662: LD_INT 3
48664: NEG
48665: PUSH
48666: LD_INT 3
48668: NEG
48669: PUSH
48670: EMPTY
48671: LIST
48672: LIST
48673: PUSH
48674: LD_INT 4
48676: NEG
48677: PUSH
48678: LD_INT 3
48680: NEG
48681: PUSH
48682: EMPTY
48683: LIST
48684: LIST
48685: PUSH
48686: LD_INT 5
48688: NEG
48689: PUSH
48690: LD_INT 4
48692: NEG
48693: PUSH
48694: EMPTY
48695: LIST
48696: LIST
48697: PUSH
48698: LD_INT 5
48700: NEG
48701: PUSH
48702: LD_INT 5
48704: NEG
48705: PUSH
48706: EMPTY
48707: LIST
48708: LIST
48709: PUSH
48710: LD_INT 3
48712: NEG
48713: PUSH
48714: LD_INT 5
48716: NEG
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: PUSH
48722: LD_INT 5
48724: NEG
48725: PUSH
48726: LD_INT 3
48728: NEG
48729: PUSH
48730: EMPTY
48731: LIST
48732: LIST
48733: PUSH
48734: EMPTY
48735: LIST
48736: LIST
48737: LIST
48738: LIST
48739: LIST
48740: LIST
48741: LIST
48742: LIST
48743: LIST
48744: LIST
48745: LIST
48746: LIST
48747: LIST
48748: LIST
48749: LIST
48750: LIST
48751: LIST
48752: LIST
48753: LIST
48754: LIST
48755: LIST
48756: LIST
48757: LIST
48758: LIST
48759: LIST
48760: LIST
48761: LIST
48762: LIST
48763: LIST
48764: LIST
48765: LIST
48766: LIST
48767: LIST
48768: LIST
48769: LIST
48770: LIST
48771: LIST
48772: LIST
48773: LIST
48774: LIST
48775: LIST
48776: LIST
48777: LIST
48778: LIST
48779: LIST
48780: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48781: LD_ADDR_VAR 0 30
48785: PUSH
48786: LD_INT 4
48788: PUSH
48789: LD_INT 4
48791: PUSH
48792: EMPTY
48793: LIST
48794: LIST
48795: PUSH
48796: LD_INT 4
48798: PUSH
48799: LD_INT 3
48801: PUSH
48802: EMPTY
48803: LIST
48804: LIST
48805: PUSH
48806: LD_INT 5
48808: PUSH
48809: LD_INT 4
48811: PUSH
48812: EMPTY
48813: LIST
48814: LIST
48815: PUSH
48816: LD_INT 5
48818: PUSH
48819: LD_INT 5
48821: PUSH
48822: EMPTY
48823: LIST
48824: LIST
48825: PUSH
48826: LD_INT 4
48828: PUSH
48829: LD_INT 5
48831: PUSH
48832: EMPTY
48833: LIST
48834: LIST
48835: PUSH
48836: LD_INT 3
48838: PUSH
48839: LD_INT 4
48841: PUSH
48842: EMPTY
48843: LIST
48844: LIST
48845: PUSH
48846: LD_INT 3
48848: PUSH
48849: LD_INT 3
48851: PUSH
48852: EMPTY
48853: LIST
48854: LIST
48855: PUSH
48856: LD_INT 5
48858: PUSH
48859: LD_INT 3
48861: PUSH
48862: EMPTY
48863: LIST
48864: LIST
48865: PUSH
48866: LD_INT 3
48868: PUSH
48869: LD_INT 5
48871: PUSH
48872: EMPTY
48873: LIST
48874: LIST
48875: PUSH
48876: LD_INT 0
48878: PUSH
48879: LD_INT 3
48881: PUSH
48882: EMPTY
48883: LIST
48884: LIST
48885: PUSH
48886: LD_INT 0
48888: PUSH
48889: LD_INT 2
48891: PUSH
48892: EMPTY
48893: LIST
48894: LIST
48895: PUSH
48896: LD_INT 1
48898: PUSH
48899: LD_INT 3
48901: PUSH
48902: EMPTY
48903: LIST
48904: LIST
48905: PUSH
48906: LD_INT 1
48908: PUSH
48909: LD_INT 4
48911: PUSH
48912: EMPTY
48913: LIST
48914: LIST
48915: PUSH
48916: LD_INT 0
48918: PUSH
48919: LD_INT 4
48921: PUSH
48922: EMPTY
48923: LIST
48924: LIST
48925: PUSH
48926: LD_INT 1
48928: NEG
48929: PUSH
48930: LD_INT 3
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PUSH
48937: LD_INT 1
48939: NEG
48940: PUSH
48941: LD_INT 2
48943: PUSH
48944: EMPTY
48945: LIST
48946: LIST
48947: PUSH
48948: LD_INT 2
48950: PUSH
48951: LD_INT 4
48953: PUSH
48954: EMPTY
48955: LIST
48956: LIST
48957: PUSH
48958: LD_INT 2
48960: NEG
48961: PUSH
48962: LD_INT 2
48964: PUSH
48965: EMPTY
48966: LIST
48967: LIST
48968: PUSH
48969: LD_INT 4
48971: NEG
48972: PUSH
48973: LD_INT 0
48975: PUSH
48976: EMPTY
48977: LIST
48978: LIST
48979: PUSH
48980: LD_INT 4
48982: NEG
48983: PUSH
48984: LD_INT 1
48986: NEG
48987: PUSH
48988: EMPTY
48989: LIST
48990: LIST
48991: PUSH
48992: LD_INT 3
48994: NEG
48995: PUSH
48996: LD_INT 0
48998: PUSH
48999: EMPTY
49000: LIST
49001: LIST
49002: PUSH
49003: LD_INT 3
49005: NEG
49006: PUSH
49007: LD_INT 1
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: PUSH
49014: LD_INT 4
49016: NEG
49017: PUSH
49018: LD_INT 1
49020: PUSH
49021: EMPTY
49022: LIST
49023: LIST
49024: PUSH
49025: LD_INT 5
49027: NEG
49028: PUSH
49029: LD_INT 0
49031: PUSH
49032: EMPTY
49033: LIST
49034: LIST
49035: PUSH
49036: LD_INT 5
49038: NEG
49039: PUSH
49040: LD_INT 1
49042: NEG
49043: PUSH
49044: EMPTY
49045: LIST
49046: LIST
49047: PUSH
49048: LD_INT 5
49050: NEG
49051: PUSH
49052: LD_INT 2
49054: NEG
49055: PUSH
49056: EMPTY
49057: LIST
49058: LIST
49059: PUSH
49060: LD_INT 3
49062: NEG
49063: PUSH
49064: LD_INT 2
49066: PUSH
49067: EMPTY
49068: LIST
49069: LIST
49070: PUSH
49071: LD_INT 3
49073: NEG
49074: PUSH
49075: LD_INT 3
49077: NEG
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: LD_INT 3
49085: NEG
49086: PUSH
49087: LD_INT 4
49089: NEG
49090: PUSH
49091: EMPTY
49092: LIST
49093: LIST
49094: PUSH
49095: LD_INT 2
49097: NEG
49098: PUSH
49099: LD_INT 3
49101: NEG
49102: PUSH
49103: EMPTY
49104: LIST
49105: LIST
49106: PUSH
49107: LD_INT 2
49109: NEG
49110: PUSH
49111: LD_INT 2
49113: NEG
49114: PUSH
49115: EMPTY
49116: LIST
49117: LIST
49118: PUSH
49119: LD_INT 3
49121: NEG
49122: PUSH
49123: LD_INT 2
49125: NEG
49126: PUSH
49127: EMPTY
49128: LIST
49129: LIST
49130: PUSH
49131: LD_INT 4
49133: NEG
49134: PUSH
49135: LD_INT 3
49137: NEG
49138: PUSH
49139: EMPTY
49140: LIST
49141: LIST
49142: PUSH
49143: LD_INT 4
49145: NEG
49146: PUSH
49147: LD_INT 4
49149: NEG
49150: PUSH
49151: EMPTY
49152: LIST
49153: LIST
49154: PUSH
49155: LD_INT 2
49157: NEG
49158: PUSH
49159: LD_INT 4
49161: NEG
49162: PUSH
49163: EMPTY
49164: LIST
49165: LIST
49166: PUSH
49167: LD_INT 4
49169: NEG
49170: PUSH
49171: LD_INT 2
49173: NEG
49174: PUSH
49175: EMPTY
49176: LIST
49177: LIST
49178: PUSH
49179: LD_INT 0
49181: PUSH
49182: LD_INT 4
49184: NEG
49185: PUSH
49186: EMPTY
49187: LIST
49188: LIST
49189: PUSH
49190: LD_INT 0
49192: PUSH
49193: LD_INT 5
49195: NEG
49196: PUSH
49197: EMPTY
49198: LIST
49199: LIST
49200: PUSH
49201: LD_INT 1
49203: PUSH
49204: LD_INT 4
49206: NEG
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: PUSH
49212: LD_INT 1
49214: PUSH
49215: LD_INT 3
49217: NEG
49218: PUSH
49219: EMPTY
49220: LIST
49221: LIST
49222: PUSH
49223: LD_INT 0
49225: PUSH
49226: LD_INT 3
49228: NEG
49229: PUSH
49230: EMPTY
49231: LIST
49232: LIST
49233: PUSH
49234: LD_INT 1
49236: NEG
49237: PUSH
49238: LD_INT 4
49240: NEG
49241: PUSH
49242: EMPTY
49243: LIST
49244: LIST
49245: PUSH
49246: LD_INT 1
49248: NEG
49249: PUSH
49250: LD_INT 5
49252: NEG
49253: PUSH
49254: EMPTY
49255: LIST
49256: LIST
49257: PUSH
49258: LD_INT 2
49260: PUSH
49261: LD_INT 3
49263: NEG
49264: PUSH
49265: EMPTY
49266: LIST
49267: LIST
49268: PUSH
49269: LD_INT 2
49271: NEG
49272: PUSH
49273: LD_INT 5
49275: NEG
49276: PUSH
49277: EMPTY
49278: LIST
49279: LIST
49280: PUSH
49281: EMPTY
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: LIST
49288: LIST
49289: LIST
49290: LIST
49291: LIST
49292: LIST
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: LIST
49327: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49328: LD_ADDR_VAR 0 31
49332: PUSH
49333: LD_INT 0
49335: PUSH
49336: LD_INT 4
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: PUSH
49343: LD_INT 0
49345: PUSH
49346: LD_INT 3
49348: PUSH
49349: EMPTY
49350: LIST
49351: LIST
49352: PUSH
49353: LD_INT 1
49355: PUSH
49356: LD_INT 4
49358: PUSH
49359: EMPTY
49360: LIST
49361: LIST
49362: PUSH
49363: LD_INT 1
49365: PUSH
49366: LD_INT 5
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: PUSH
49373: LD_INT 0
49375: PUSH
49376: LD_INT 5
49378: PUSH
49379: EMPTY
49380: LIST
49381: LIST
49382: PUSH
49383: LD_INT 1
49385: NEG
49386: PUSH
49387: LD_INT 4
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PUSH
49394: LD_INT 1
49396: NEG
49397: PUSH
49398: LD_INT 3
49400: PUSH
49401: EMPTY
49402: LIST
49403: LIST
49404: PUSH
49405: LD_INT 2
49407: PUSH
49408: LD_INT 5
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PUSH
49415: LD_INT 2
49417: NEG
49418: PUSH
49419: LD_INT 3
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: PUSH
49426: LD_INT 3
49428: NEG
49429: PUSH
49430: LD_INT 0
49432: PUSH
49433: EMPTY
49434: LIST
49435: LIST
49436: PUSH
49437: LD_INT 3
49439: NEG
49440: PUSH
49441: LD_INT 1
49443: NEG
49444: PUSH
49445: EMPTY
49446: LIST
49447: LIST
49448: PUSH
49449: LD_INT 2
49451: NEG
49452: PUSH
49453: LD_INT 0
49455: PUSH
49456: EMPTY
49457: LIST
49458: LIST
49459: PUSH
49460: LD_INT 2
49462: NEG
49463: PUSH
49464: LD_INT 1
49466: PUSH
49467: EMPTY
49468: LIST
49469: LIST
49470: PUSH
49471: LD_INT 3
49473: NEG
49474: PUSH
49475: LD_INT 1
49477: PUSH
49478: EMPTY
49479: LIST
49480: LIST
49481: PUSH
49482: LD_INT 4
49484: NEG
49485: PUSH
49486: LD_INT 0
49488: PUSH
49489: EMPTY
49490: LIST
49491: LIST
49492: PUSH
49493: LD_INT 4
49495: NEG
49496: PUSH
49497: LD_INT 1
49499: NEG
49500: PUSH
49501: EMPTY
49502: LIST
49503: LIST
49504: PUSH
49505: LD_INT 4
49507: NEG
49508: PUSH
49509: LD_INT 2
49511: NEG
49512: PUSH
49513: EMPTY
49514: LIST
49515: LIST
49516: PUSH
49517: LD_INT 2
49519: NEG
49520: PUSH
49521: LD_INT 2
49523: PUSH
49524: EMPTY
49525: LIST
49526: LIST
49527: PUSH
49528: LD_INT 4
49530: NEG
49531: PUSH
49532: LD_INT 4
49534: NEG
49535: PUSH
49536: EMPTY
49537: LIST
49538: LIST
49539: PUSH
49540: LD_INT 4
49542: NEG
49543: PUSH
49544: LD_INT 5
49546: NEG
49547: PUSH
49548: EMPTY
49549: LIST
49550: LIST
49551: PUSH
49552: LD_INT 3
49554: NEG
49555: PUSH
49556: LD_INT 4
49558: NEG
49559: PUSH
49560: EMPTY
49561: LIST
49562: LIST
49563: PUSH
49564: LD_INT 3
49566: NEG
49567: PUSH
49568: LD_INT 3
49570: NEG
49571: PUSH
49572: EMPTY
49573: LIST
49574: LIST
49575: PUSH
49576: LD_INT 4
49578: NEG
49579: PUSH
49580: LD_INT 3
49582: NEG
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PUSH
49588: LD_INT 5
49590: NEG
49591: PUSH
49592: LD_INT 4
49594: NEG
49595: PUSH
49596: EMPTY
49597: LIST
49598: LIST
49599: PUSH
49600: LD_INT 5
49602: NEG
49603: PUSH
49604: LD_INT 5
49606: NEG
49607: PUSH
49608: EMPTY
49609: LIST
49610: LIST
49611: PUSH
49612: LD_INT 3
49614: NEG
49615: PUSH
49616: LD_INT 5
49618: NEG
49619: PUSH
49620: EMPTY
49621: LIST
49622: LIST
49623: PUSH
49624: LD_INT 5
49626: NEG
49627: PUSH
49628: LD_INT 3
49630: NEG
49631: PUSH
49632: EMPTY
49633: LIST
49634: LIST
49635: PUSH
49636: LD_INT 0
49638: PUSH
49639: LD_INT 3
49641: NEG
49642: PUSH
49643: EMPTY
49644: LIST
49645: LIST
49646: PUSH
49647: LD_INT 0
49649: PUSH
49650: LD_INT 4
49652: NEG
49653: PUSH
49654: EMPTY
49655: LIST
49656: LIST
49657: PUSH
49658: LD_INT 1
49660: PUSH
49661: LD_INT 3
49663: NEG
49664: PUSH
49665: EMPTY
49666: LIST
49667: LIST
49668: PUSH
49669: LD_INT 1
49671: PUSH
49672: LD_INT 2
49674: NEG
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: LD_INT 0
49682: PUSH
49683: LD_INT 2
49685: NEG
49686: PUSH
49687: EMPTY
49688: LIST
49689: LIST
49690: PUSH
49691: LD_INT 1
49693: NEG
49694: PUSH
49695: LD_INT 3
49697: NEG
49698: PUSH
49699: EMPTY
49700: LIST
49701: LIST
49702: PUSH
49703: LD_INT 1
49705: NEG
49706: PUSH
49707: LD_INT 4
49709: NEG
49710: PUSH
49711: EMPTY
49712: LIST
49713: LIST
49714: PUSH
49715: LD_INT 2
49717: PUSH
49718: LD_INT 2
49720: NEG
49721: PUSH
49722: EMPTY
49723: LIST
49724: LIST
49725: PUSH
49726: LD_INT 2
49728: NEG
49729: PUSH
49730: LD_INT 4
49732: NEG
49733: PUSH
49734: EMPTY
49735: LIST
49736: LIST
49737: PUSH
49738: LD_INT 4
49740: PUSH
49741: LD_INT 0
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: PUSH
49748: LD_INT 4
49750: PUSH
49751: LD_INT 1
49753: NEG
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: PUSH
49759: LD_INT 5
49761: PUSH
49762: LD_INT 0
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: PUSH
49769: LD_INT 5
49771: PUSH
49772: LD_INT 1
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PUSH
49779: LD_INT 4
49781: PUSH
49782: LD_INT 1
49784: PUSH
49785: EMPTY
49786: LIST
49787: LIST
49788: PUSH
49789: LD_INT 3
49791: PUSH
49792: LD_INT 0
49794: PUSH
49795: EMPTY
49796: LIST
49797: LIST
49798: PUSH
49799: LD_INT 3
49801: PUSH
49802: LD_INT 1
49804: NEG
49805: PUSH
49806: EMPTY
49807: LIST
49808: LIST
49809: PUSH
49810: LD_INT 3
49812: PUSH
49813: LD_INT 2
49815: NEG
49816: PUSH
49817: EMPTY
49818: LIST
49819: LIST
49820: PUSH
49821: LD_INT 5
49823: PUSH
49824: LD_INT 2
49826: PUSH
49827: EMPTY
49828: LIST
49829: LIST
49830: PUSH
49831: EMPTY
49832: LIST
49833: LIST
49834: LIST
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: LIST
49840: LIST
49841: LIST
49842: LIST
49843: LIST
49844: LIST
49845: LIST
49846: LIST
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: LIST
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: LIST
49860: LIST
49861: LIST
49862: LIST
49863: LIST
49864: LIST
49865: LIST
49866: LIST
49867: LIST
49868: LIST
49869: LIST
49870: LIST
49871: LIST
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: LIST
49877: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49878: LD_ADDR_VAR 0 32
49882: PUSH
49883: LD_INT 4
49885: NEG
49886: PUSH
49887: LD_INT 0
49889: PUSH
49890: EMPTY
49891: LIST
49892: LIST
49893: PUSH
49894: LD_INT 4
49896: NEG
49897: PUSH
49898: LD_INT 1
49900: NEG
49901: PUSH
49902: EMPTY
49903: LIST
49904: LIST
49905: PUSH
49906: LD_INT 3
49908: NEG
49909: PUSH
49910: LD_INT 0
49912: PUSH
49913: EMPTY
49914: LIST
49915: LIST
49916: PUSH
49917: LD_INT 3
49919: NEG
49920: PUSH
49921: LD_INT 1
49923: PUSH
49924: EMPTY
49925: LIST
49926: LIST
49927: PUSH
49928: LD_INT 4
49930: NEG
49931: PUSH
49932: LD_INT 1
49934: PUSH
49935: EMPTY
49936: LIST
49937: LIST
49938: PUSH
49939: LD_INT 5
49941: NEG
49942: PUSH
49943: LD_INT 0
49945: PUSH
49946: EMPTY
49947: LIST
49948: LIST
49949: PUSH
49950: LD_INT 5
49952: NEG
49953: PUSH
49954: LD_INT 1
49956: NEG
49957: PUSH
49958: EMPTY
49959: LIST
49960: LIST
49961: PUSH
49962: LD_INT 5
49964: NEG
49965: PUSH
49966: LD_INT 2
49968: NEG
49969: PUSH
49970: EMPTY
49971: LIST
49972: LIST
49973: PUSH
49974: LD_INT 3
49976: NEG
49977: PUSH
49978: LD_INT 2
49980: PUSH
49981: EMPTY
49982: LIST
49983: LIST
49984: PUSH
49985: LD_INT 3
49987: NEG
49988: PUSH
49989: LD_INT 3
49991: NEG
49992: PUSH
49993: EMPTY
49994: LIST
49995: LIST
49996: PUSH
49997: LD_INT 3
49999: NEG
50000: PUSH
50001: LD_INT 4
50003: NEG
50004: PUSH
50005: EMPTY
50006: LIST
50007: LIST
50008: PUSH
50009: LD_INT 2
50011: NEG
50012: PUSH
50013: LD_INT 3
50015: NEG
50016: PUSH
50017: EMPTY
50018: LIST
50019: LIST
50020: PUSH
50021: LD_INT 2
50023: NEG
50024: PUSH
50025: LD_INT 2
50027: NEG
50028: PUSH
50029: EMPTY
50030: LIST
50031: LIST
50032: PUSH
50033: LD_INT 3
50035: NEG
50036: PUSH
50037: LD_INT 2
50039: NEG
50040: PUSH
50041: EMPTY
50042: LIST
50043: LIST
50044: PUSH
50045: LD_INT 4
50047: NEG
50048: PUSH
50049: LD_INT 3
50051: NEG
50052: PUSH
50053: EMPTY
50054: LIST
50055: LIST
50056: PUSH
50057: LD_INT 4
50059: NEG
50060: PUSH
50061: LD_INT 4
50063: NEG
50064: PUSH
50065: EMPTY
50066: LIST
50067: LIST
50068: PUSH
50069: LD_INT 2
50071: NEG
50072: PUSH
50073: LD_INT 4
50075: NEG
50076: PUSH
50077: EMPTY
50078: LIST
50079: LIST
50080: PUSH
50081: LD_INT 4
50083: NEG
50084: PUSH
50085: LD_INT 2
50087: NEG
50088: PUSH
50089: EMPTY
50090: LIST
50091: LIST
50092: PUSH
50093: LD_INT 0
50095: PUSH
50096: LD_INT 4
50098: NEG
50099: PUSH
50100: EMPTY
50101: LIST
50102: LIST
50103: PUSH
50104: LD_INT 0
50106: PUSH
50107: LD_INT 5
50109: NEG
50110: PUSH
50111: EMPTY
50112: LIST
50113: LIST
50114: PUSH
50115: LD_INT 1
50117: PUSH
50118: LD_INT 4
50120: NEG
50121: PUSH
50122: EMPTY
50123: LIST
50124: LIST
50125: PUSH
50126: LD_INT 1
50128: PUSH
50129: LD_INT 3
50131: NEG
50132: PUSH
50133: EMPTY
50134: LIST
50135: LIST
50136: PUSH
50137: LD_INT 0
50139: PUSH
50140: LD_INT 3
50142: NEG
50143: PUSH
50144: EMPTY
50145: LIST
50146: LIST
50147: PUSH
50148: LD_INT 1
50150: NEG
50151: PUSH
50152: LD_INT 4
50154: NEG
50155: PUSH
50156: EMPTY
50157: LIST
50158: LIST
50159: PUSH
50160: LD_INT 1
50162: NEG
50163: PUSH
50164: LD_INT 5
50166: NEG
50167: PUSH
50168: EMPTY
50169: LIST
50170: LIST
50171: PUSH
50172: LD_INT 2
50174: PUSH
50175: LD_INT 3
50177: NEG
50178: PUSH
50179: EMPTY
50180: LIST
50181: LIST
50182: PUSH
50183: LD_INT 2
50185: NEG
50186: PUSH
50187: LD_INT 5
50189: NEG
50190: PUSH
50191: EMPTY
50192: LIST
50193: LIST
50194: PUSH
50195: LD_INT 3
50197: PUSH
50198: LD_INT 0
50200: PUSH
50201: EMPTY
50202: LIST
50203: LIST
50204: PUSH
50205: LD_INT 3
50207: PUSH
50208: LD_INT 1
50210: NEG
50211: PUSH
50212: EMPTY
50213: LIST
50214: LIST
50215: PUSH
50216: LD_INT 4
50218: PUSH
50219: LD_INT 0
50221: PUSH
50222: EMPTY
50223: LIST
50224: LIST
50225: PUSH
50226: LD_INT 4
50228: PUSH
50229: LD_INT 1
50231: PUSH
50232: EMPTY
50233: LIST
50234: LIST
50235: PUSH
50236: LD_INT 3
50238: PUSH
50239: LD_INT 1
50241: PUSH
50242: EMPTY
50243: LIST
50244: LIST
50245: PUSH
50246: LD_INT 2
50248: PUSH
50249: LD_INT 0
50251: PUSH
50252: EMPTY
50253: LIST
50254: LIST
50255: PUSH
50256: LD_INT 2
50258: PUSH
50259: LD_INT 1
50261: NEG
50262: PUSH
50263: EMPTY
50264: LIST
50265: LIST
50266: PUSH
50267: LD_INT 2
50269: PUSH
50270: LD_INT 2
50272: NEG
50273: PUSH
50274: EMPTY
50275: LIST
50276: LIST
50277: PUSH
50278: LD_INT 4
50280: PUSH
50281: LD_INT 2
50283: PUSH
50284: EMPTY
50285: LIST
50286: LIST
50287: PUSH
50288: LD_INT 4
50290: PUSH
50291: LD_INT 4
50293: PUSH
50294: EMPTY
50295: LIST
50296: LIST
50297: PUSH
50298: LD_INT 4
50300: PUSH
50301: LD_INT 3
50303: PUSH
50304: EMPTY
50305: LIST
50306: LIST
50307: PUSH
50308: LD_INT 5
50310: PUSH
50311: LD_INT 4
50313: PUSH
50314: EMPTY
50315: LIST
50316: LIST
50317: PUSH
50318: LD_INT 5
50320: PUSH
50321: LD_INT 5
50323: PUSH
50324: EMPTY
50325: LIST
50326: LIST
50327: PUSH
50328: LD_INT 4
50330: PUSH
50331: LD_INT 5
50333: PUSH
50334: EMPTY
50335: LIST
50336: LIST
50337: PUSH
50338: LD_INT 3
50340: PUSH
50341: LD_INT 4
50343: PUSH
50344: EMPTY
50345: LIST
50346: LIST
50347: PUSH
50348: LD_INT 3
50350: PUSH
50351: LD_INT 3
50353: PUSH
50354: EMPTY
50355: LIST
50356: LIST
50357: PUSH
50358: LD_INT 5
50360: PUSH
50361: LD_INT 3
50363: PUSH
50364: EMPTY
50365: LIST
50366: LIST
50367: PUSH
50368: LD_INT 3
50370: PUSH
50371: LD_INT 5
50373: PUSH
50374: EMPTY
50375: LIST
50376: LIST
50377: PUSH
50378: EMPTY
50379: LIST
50380: LIST
50381: LIST
50382: LIST
50383: LIST
50384: LIST
50385: LIST
50386: LIST
50387: LIST
50388: LIST
50389: LIST
50390: LIST
50391: LIST
50392: LIST
50393: LIST
50394: LIST
50395: LIST
50396: LIST
50397: LIST
50398: LIST
50399: LIST
50400: LIST
50401: LIST
50402: LIST
50403: LIST
50404: LIST
50405: LIST
50406: LIST
50407: LIST
50408: LIST
50409: LIST
50410: LIST
50411: LIST
50412: LIST
50413: LIST
50414: LIST
50415: LIST
50416: LIST
50417: LIST
50418: LIST
50419: LIST
50420: LIST
50421: LIST
50422: LIST
50423: LIST
50424: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50425: LD_ADDR_VAR 0 33
50429: PUSH
50430: LD_INT 4
50432: NEG
50433: PUSH
50434: LD_INT 4
50436: NEG
50437: PUSH
50438: EMPTY
50439: LIST
50440: LIST
50441: PUSH
50442: LD_INT 4
50444: NEG
50445: PUSH
50446: LD_INT 5
50448: NEG
50449: PUSH
50450: EMPTY
50451: LIST
50452: LIST
50453: PUSH
50454: LD_INT 3
50456: NEG
50457: PUSH
50458: LD_INT 4
50460: NEG
50461: PUSH
50462: EMPTY
50463: LIST
50464: LIST
50465: PUSH
50466: LD_INT 3
50468: NEG
50469: PUSH
50470: LD_INT 3
50472: NEG
50473: PUSH
50474: EMPTY
50475: LIST
50476: LIST
50477: PUSH
50478: LD_INT 4
50480: NEG
50481: PUSH
50482: LD_INT 3
50484: NEG
50485: PUSH
50486: EMPTY
50487: LIST
50488: LIST
50489: PUSH
50490: LD_INT 5
50492: NEG
50493: PUSH
50494: LD_INT 4
50496: NEG
50497: PUSH
50498: EMPTY
50499: LIST
50500: LIST
50501: PUSH
50502: LD_INT 5
50504: NEG
50505: PUSH
50506: LD_INT 5
50508: NEG
50509: PUSH
50510: EMPTY
50511: LIST
50512: LIST
50513: PUSH
50514: LD_INT 3
50516: NEG
50517: PUSH
50518: LD_INT 5
50520: NEG
50521: PUSH
50522: EMPTY
50523: LIST
50524: LIST
50525: PUSH
50526: LD_INT 5
50528: NEG
50529: PUSH
50530: LD_INT 3
50532: NEG
50533: PUSH
50534: EMPTY
50535: LIST
50536: LIST
50537: PUSH
50538: LD_INT 0
50540: PUSH
50541: LD_INT 3
50543: NEG
50544: PUSH
50545: EMPTY
50546: LIST
50547: LIST
50548: PUSH
50549: LD_INT 0
50551: PUSH
50552: LD_INT 4
50554: NEG
50555: PUSH
50556: EMPTY
50557: LIST
50558: LIST
50559: PUSH
50560: LD_INT 1
50562: PUSH
50563: LD_INT 3
50565: NEG
50566: PUSH
50567: EMPTY
50568: LIST
50569: LIST
50570: PUSH
50571: LD_INT 1
50573: PUSH
50574: LD_INT 2
50576: NEG
50577: PUSH
50578: EMPTY
50579: LIST
50580: LIST
50581: PUSH
50582: LD_INT 0
50584: PUSH
50585: LD_INT 2
50587: NEG
50588: PUSH
50589: EMPTY
50590: LIST
50591: LIST
50592: PUSH
50593: LD_INT 1
50595: NEG
50596: PUSH
50597: LD_INT 3
50599: NEG
50600: PUSH
50601: EMPTY
50602: LIST
50603: LIST
50604: PUSH
50605: LD_INT 1
50607: NEG
50608: PUSH
50609: LD_INT 4
50611: NEG
50612: PUSH
50613: EMPTY
50614: LIST
50615: LIST
50616: PUSH
50617: LD_INT 2
50619: PUSH
50620: LD_INT 2
50622: NEG
50623: PUSH
50624: EMPTY
50625: LIST
50626: LIST
50627: PUSH
50628: LD_INT 2
50630: NEG
50631: PUSH
50632: LD_INT 4
50634: NEG
50635: PUSH
50636: EMPTY
50637: LIST
50638: LIST
50639: PUSH
50640: LD_INT 4
50642: PUSH
50643: LD_INT 0
50645: PUSH
50646: EMPTY
50647: LIST
50648: LIST
50649: PUSH
50650: LD_INT 4
50652: PUSH
50653: LD_INT 1
50655: NEG
50656: PUSH
50657: EMPTY
50658: LIST
50659: LIST
50660: PUSH
50661: LD_INT 5
50663: PUSH
50664: LD_INT 0
50666: PUSH
50667: EMPTY
50668: LIST
50669: LIST
50670: PUSH
50671: LD_INT 5
50673: PUSH
50674: LD_INT 1
50676: PUSH
50677: EMPTY
50678: LIST
50679: LIST
50680: PUSH
50681: LD_INT 4
50683: PUSH
50684: LD_INT 1
50686: PUSH
50687: EMPTY
50688: LIST
50689: LIST
50690: PUSH
50691: LD_INT 3
50693: PUSH
50694: LD_INT 0
50696: PUSH
50697: EMPTY
50698: LIST
50699: LIST
50700: PUSH
50701: LD_INT 3
50703: PUSH
50704: LD_INT 1
50706: NEG
50707: PUSH
50708: EMPTY
50709: LIST
50710: LIST
50711: PUSH
50712: LD_INT 3
50714: PUSH
50715: LD_INT 2
50717: NEG
50718: PUSH
50719: EMPTY
50720: LIST
50721: LIST
50722: PUSH
50723: LD_INT 5
50725: PUSH
50726: LD_INT 2
50728: PUSH
50729: EMPTY
50730: LIST
50731: LIST
50732: PUSH
50733: LD_INT 3
50735: PUSH
50736: LD_INT 3
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: PUSH
50743: LD_INT 3
50745: PUSH
50746: LD_INT 2
50748: PUSH
50749: EMPTY
50750: LIST
50751: LIST
50752: PUSH
50753: LD_INT 4
50755: PUSH
50756: LD_INT 3
50758: PUSH
50759: EMPTY
50760: LIST
50761: LIST
50762: PUSH
50763: LD_INT 4
50765: PUSH
50766: LD_INT 4
50768: PUSH
50769: EMPTY
50770: LIST
50771: LIST
50772: PUSH
50773: LD_INT 3
50775: PUSH
50776: LD_INT 4
50778: PUSH
50779: EMPTY
50780: LIST
50781: LIST
50782: PUSH
50783: LD_INT 2
50785: PUSH
50786: LD_INT 3
50788: PUSH
50789: EMPTY
50790: LIST
50791: LIST
50792: PUSH
50793: LD_INT 2
50795: PUSH
50796: LD_INT 2
50798: PUSH
50799: EMPTY
50800: LIST
50801: LIST
50802: PUSH
50803: LD_INT 4
50805: PUSH
50806: LD_INT 2
50808: PUSH
50809: EMPTY
50810: LIST
50811: LIST
50812: PUSH
50813: LD_INT 2
50815: PUSH
50816: LD_INT 4
50818: PUSH
50819: EMPTY
50820: LIST
50821: LIST
50822: PUSH
50823: LD_INT 0
50825: PUSH
50826: LD_INT 4
50828: PUSH
50829: EMPTY
50830: LIST
50831: LIST
50832: PUSH
50833: LD_INT 0
50835: PUSH
50836: LD_INT 3
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: PUSH
50843: LD_INT 1
50845: PUSH
50846: LD_INT 4
50848: PUSH
50849: EMPTY
50850: LIST
50851: LIST
50852: PUSH
50853: LD_INT 1
50855: PUSH
50856: LD_INT 5
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PUSH
50863: LD_INT 0
50865: PUSH
50866: LD_INT 5
50868: PUSH
50869: EMPTY
50870: LIST
50871: LIST
50872: PUSH
50873: LD_INT 1
50875: NEG
50876: PUSH
50877: LD_INT 4
50879: PUSH
50880: EMPTY
50881: LIST
50882: LIST
50883: PUSH
50884: LD_INT 1
50886: NEG
50887: PUSH
50888: LD_INT 3
50890: PUSH
50891: EMPTY
50892: LIST
50893: LIST
50894: PUSH
50895: LD_INT 2
50897: PUSH
50898: LD_INT 5
50900: PUSH
50901: EMPTY
50902: LIST
50903: LIST
50904: PUSH
50905: LD_INT 2
50907: NEG
50908: PUSH
50909: LD_INT 3
50911: PUSH
50912: EMPTY
50913: LIST
50914: LIST
50915: PUSH
50916: EMPTY
50917: LIST
50918: LIST
50919: LIST
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: LIST
50927: LIST
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: LIST
50933: LIST
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: LIST
50942: LIST
50943: LIST
50944: LIST
50945: LIST
50946: LIST
50947: LIST
50948: LIST
50949: LIST
50950: LIST
50951: LIST
50952: LIST
50953: LIST
50954: LIST
50955: LIST
50956: LIST
50957: LIST
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50963: LD_ADDR_VAR 0 34
50967: PUSH
50968: LD_INT 0
50970: PUSH
50971: LD_INT 4
50973: NEG
50974: PUSH
50975: EMPTY
50976: LIST
50977: LIST
50978: PUSH
50979: LD_INT 0
50981: PUSH
50982: LD_INT 5
50984: NEG
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: PUSH
50990: LD_INT 1
50992: PUSH
50993: LD_INT 4
50995: NEG
50996: PUSH
50997: EMPTY
50998: LIST
50999: LIST
51000: PUSH
51001: LD_INT 1
51003: PUSH
51004: LD_INT 3
51006: NEG
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: PUSH
51012: LD_INT 0
51014: PUSH
51015: LD_INT 3
51017: NEG
51018: PUSH
51019: EMPTY
51020: LIST
51021: LIST
51022: PUSH
51023: LD_INT 1
51025: NEG
51026: PUSH
51027: LD_INT 4
51029: NEG
51030: PUSH
51031: EMPTY
51032: LIST
51033: LIST
51034: PUSH
51035: LD_INT 1
51037: NEG
51038: PUSH
51039: LD_INT 5
51041: NEG
51042: PUSH
51043: EMPTY
51044: LIST
51045: LIST
51046: PUSH
51047: LD_INT 2
51049: PUSH
51050: LD_INT 3
51052: NEG
51053: PUSH
51054: EMPTY
51055: LIST
51056: LIST
51057: PUSH
51058: LD_INT 2
51060: NEG
51061: PUSH
51062: LD_INT 5
51064: NEG
51065: PUSH
51066: EMPTY
51067: LIST
51068: LIST
51069: PUSH
51070: LD_INT 3
51072: PUSH
51073: LD_INT 0
51075: PUSH
51076: EMPTY
51077: LIST
51078: LIST
51079: PUSH
51080: LD_INT 3
51082: PUSH
51083: LD_INT 1
51085: NEG
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PUSH
51091: LD_INT 4
51093: PUSH
51094: LD_INT 0
51096: PUSH
51097: EMPTY
51098: LIST
51099: LIST
51100: PUSH
51101: LD_INT 4
51103: PUSH
51104: LD_INT 1
51106: PUSH
51107: EMPTY
51108: LIST
51109: LIST
51110: PUSH
51111: LD_INT 3
51113: PUSH
51114: LD_INT 1
51116: PUSH
51117: EMPTY
51118: LIST
51119: LIST
51120: PUSH
51121: LD_INT 2
51123: PUSH
51124: LD_INT 0
51126: PUSH
51127: EMPTY
51128: LIST
51129: LIST
51130: PUSH
51131: LD_INT 2
51133: PUSH
51134: LD_INT 1
51136: NEG
51137: PUSH
51138: EMPTY
51139: LIST
51140: LIST
51141: PUSH
51142: LD_INT 2
51144: PUSH
51145: LD_INT 2
51147: NEG
51148: PUSH
51149: EMPTY
51150: LIST
51151: LIST
51152: PUSH
51153: LD_INT 4
51155: PUSH
51156: LD_INT 2
51158: PUSH
51159: EMPTY
51160: LIST
51161: LIST
51162: PUSH
51163: LD_INT 4
51165: PUSH
51166: LD_INT 4
51168: PUSH
51169: EMPTY
51170: LIST
51171: LIST
51172: PUSH
51173: LD_INT 4
51175: PUSH
51176: LD_INT 3
51178: PUSH
51179: EMPTY
51180: LIST
51181: LIST
51182: PUSH
51183: LD_INT 5
51185: PUSH
51186: LD_INT 4
51188: PUSH
51189: EMPTY
51190: LIST
51191: LIST
51192: PUSH
51193: LD_INT 5
51195: PUSH
51196: LD_INT 5
51198: PUSH
51199: EMPTY
51200: LIST
51201: LIST
51202: PUSH
51203: LD_INT 4
51205: PUSH
51206: LD_INT 5
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: PUSH
51213: LD_INT 3
51215: PUSH
51216: LD_INT 4
51218: PUSH
51219: EMPTY
51220: LIST
51221: LIST
51222: PUSH
51223: LD_INT 3
51225: PUSH
51226: LD_INT 3
51228: PUSH
51229: EMPTY
51230: LIST
51231: LIST
51232: PUSH
51233: LD_INT 5
51235: PUSH
51236: LD_INT 3
51238: PUSH
51239: EMPTY
51240: LIST
51241: LIST
51242: PUSH
51243: LD_INT 3
51245: PUSH
51246: LD_INT 5
51248: PUSH
51249: EMPTY
51250: LIST
51251: LIST
51252: PUSH
51253: LD_INT 0
51255: PUSH
51256: LD_INT 3
51258: PUSH
51259: EMPTY
51260: LIST
51261: LIST
51262: PUSH
51263: LD_INT 0
51265: PUSH
51266: LD_INT 2
51268: PUSH
51269: EMPTY
51270: LIST
51271: LIST
51272: PUSH
51273: LD_INT 1
51275: PUSH
51276: LD_INT 3
51278: PUSH
51279: EMPTY
51280: LIST
51281: LIST
51282: PUSH
51283: LD_INT 1
51285: PUSH
51286: LD_INT 4
51288: PUSH
51289: EMPTY
51290: LIST
51291: LIST
51292: PUSH
51293: LD_INT 0
51295: PUSH
51296: LD_INT 4
51298: PUSH
51299: EMPTY
51300: LIST
51301: LIST
51302: PUSH
51303: LD_INT 1
51305: NEG
51306: PUSH
51307: LD_INT 3
51309: PUSH
51310: EMPTY
51311: LIST
51312: LIST
51313: PUSH
51314: LD_INT 1
51316: NEG
51317: PUSH
51318: LD_INT 2
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: PUSH
51325: LD_INT 2
51327: PUSH
51328: LD_INT 4
51330: PUSH
51331: EMPTY
51332: LIST
51333: LIST
51334: PUSH
51335: LD_INT 2
51337: NEG
51338: PUSH
51339: LD_INT 2
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: PUSH
51346: LD_INT 4
51348: NEG
51349: PUSH
51350: LD_INT 0
51352: PUSH
51353: EMPTY
51354: LIST
51355: LIST
51356: PUSH
51357: LD_INT 4
51359: NEG
51360: PUSH
51361: LD_INT 1
51363: NEG
51364: PUSH
51365: EMPTY
51366: LIST
51367: LIST
51368: PUSH
51369: LD_INT 3
51371: NEG
51372: PUSH
51373: LD_INT 0
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 3
51382: NEG
51383: PUSH
51384: LD_INT 1
51386: PUSH
51387: EMPTY
51388: LIST
51389: LIST
51390: PUSH
51391: LD_INT 4
51393: NEG
51394: PUSH
51395: LD_INT 1
51397: PUSH
51398: EMPTY
51399: LIST
51400: LIST
51401: PUSH
51402: LD_INT 5
51404: NEG
51405: PUSH
51406: LD_INT 0
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: PUSH
51413: LD_INT 5
51415: NEG
51416: PUSH
51417: LD_INT 1
51419: NEG
51420: PUSH
51421: EMPTY
51422: LIST
51423: LIST
51424: PUSH
51425: LD_INT 5
51427: NEG
51428: PUSH
51429: LD_INT 2
51431: NEG
51432: PUSH
51433: EMPTY
51434: LIST
51435: LIST
51436: PUSH
51437: LD_INT 3
51439: NEG
51440: PUSH
51441: LD_INT 2
51443: PUSH
51444: EMPTY
51445: LIST
51446: LIST
51447: PUSH
51448: EMPTY
51449: LIST
51450: LIST
51451: LIST
51452: LIST
51453: LIST
51454: LIST
51455: LIST
51456: LIST
51457: LIST
51458: LIST
51459: LIST
51460: LIST
51461: LIST
51462: LIST
51463: LIST
51464: LIST
51465: LIST
51466: LIST
51467: LIST
51468: LIST
51469: LIST
51470: LIST
51471: LIST
51472: LIST
51473: LIST
51474: LIST
51475: LIST
51476: LIST
51477: LIST
51478: LIST
51479: LIST
51480: LIST
51481: LIST
51482: LIST
51483: LIST
51484: LIST
51485: LIST
51486: LIST
51487: LIST
51488: LIST
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: LIST
51494: ST_TO_ADDR
// end ; end ;
51495: GO 51498
51497: POP
// case btype of b_depot , b_warehouse :
51498: LD_VAR 0 1
51502: PUSH
51503: LD_INT 0
51505: DOUBLE
51506: EQUAL
51507: IFTRUE 51517
51509: LD_INT 1
51511: DOUBLE
51512: EQUAL
51513: IFTRUE 51517
51515: GO 51718
51517: POP
// case nation of nation_american :
51518: LD_VAR 0 5
51522: PUSH
51523: LD_INT 1
51525: DOUBLE
51526: EQUAL
51527: IFTRUE 51531
51529: GO 51587
51531: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51532: LD_ADDR_VAR 0 9
51536: PUSH
51537: LD_VAR 0 11
51541: PUSH
51542: LD_VAR 0 12
51546: PUSH
51547: LD_VAR 0 13
51551: PUSH
51552: LD_VAR 0 14
51556: PUSH
51557: LD_VAR 0 15
51561: PUSH
51562: LD_VAR 0 16
51566: PUSH
51567: EMPTY
51568: LIST
51569: LIST
51570: LIST
51571: LIST
51572: LIST
51573: LIST
51574: PUSH
51575: LD_VAR 0 4
51579: PUSH
51580: LD_INT 1
51582: PLUS
51583: ARRAY
51584: ST_TO_ADDR
51585: GO 51716
51587: LD_INT 2
51589: DOUBLE
51590: EQUAL
51591: IFTRUE 51595
51593: GO 51651
51595: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51596: LD_ADDR_VAR 0 9
51600: PUSH
51601: LD_VAR 0 17
51605: PUSH
51606: LD_VAR 0 18
51610: PUSH
51611: LD_VAR 0 19
51615: PUSH
51616: LD_VAR 0 20
51620: PUSH
51621: LD_VAR 0 21
51625: PUSH
51626: LD_VAR 0 22
51630: PUSH
51631: EMPTY
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: PUSH
51639: LD_VAR 0 4
51643: PUSH
51644: LD_INT 1
51646: PLUS
51647: ARRAY
51648: ST_TO_ADDR
51649: GO 51716
51651: LD_INT 3
51653: DOUBLE
51654: EQUAL
51655: IFTRUE 51659
51657: GO 51715
51659: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51660: LD_ADDR_VAR 0 9
51664: PUSH
51665: LD_VAR 0 23
51669: PUSH
51670: LD_VAR 0 24
51674: PUSH
51675: LD_VAR 0 25
51679: PUSH
51680: LD_VAR 0 26
51684: PUSH
51685: LD_VAR 0 27
51689: PUSH
51690: LD_VAR 0 28
51694: PUSH
51695: EMPTY
51696: LIST
51697: LIST
51698: LIST
51699: LIST
51700: LIST
51701: LIST
51702: PUSH
51703: LD_VAR 0 4
51707: PUSH
51708: LD_INT 1
51710: PLUS
51711: ARRAY
51712: ST_TO_ADDR
51713: GO 51716
51715: POP
51716: GO 52271
51718: LD_INT 2
51720: DOUBLE
51721: EQUAL
51722: IFTRUE 51732
51724: LD_INT 3
51726: DOUBLE
51727: EQUAL
51728: IFTRUE 51732
51730: GO 51788
51732: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51733: LD_ADDR_VAR 0 9
51737: PUSH
51738: LD_VAR 0 29
51742: PUSH
51743: LD_VAR 0 30
51747: PUSH
51748: LD_VAR 0 31
51752: PUSH
51753: LD_VAR 0 32
51757: PUSH
51758: LD_VAR 0 33
51762: PUSH
51763: LD_VAR 0 34
51767: PUSH
51768: EMPTY
51769: LIST
51770: LIST
51771: LIST
51772: LIST
51773: LIST
51774: LIST
51775: PUSH
51776: LD_VAR 0 4
51780: PUSH
51781: LD_INT 1
51783: PLUS
51784: ARRAY
51785: ST_TO_ADDR
51786: GO 52271
51788: LD_INT 16
51790: DOUBLE
51791: EQUAL
51792: IFTRUE 51850
51794: LD_INT 17
51796: DOUBLE
51797: EQUAL
51798: IFTRUE 51850
51800: LD_INT 18
51802: DOUBLE
51803: EQUAL
51804: IFTRUE 51850
51806: LD_INT 19
51808: DOUBLE
51809: EQUAL
51810: IFTRUE 51850
51812: LD_INT 22
51814: DOUBLE
51815: EQUAL
51816: IFTRUE 51850
51818: LD_INT 20
51820: DOUBLE
51821: EQUAL
51822: IFTRUE 51850
51824: LD_INT 21
51826: DOUBLE
51827: EQUAL
51828: IFTRUE 51850
51830: LD_INT 23
51832: DOUBLE
51833: EQUAL
51834: IFTRUE 51850
51836: LD_INT 24
51838: DOUBLE
51839: EQUAL
51840: IFTRUE 51850
51842: LD_INT 25
51844: DOUBLE
51845: EQUAL
51846: IFTRUE 51850
51848: GO 51906
51850: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51851: LD_ADDR_VAR 0 9
51855: PUSH
51856: LD_VAR 0 35
51860: PUSH
51861: LD_VAR 0 36
51865: PUSH
51866: LD_VAR 0 37
51870: PUSH
51871: LD_VAR 0 38
51875: PUSH
51876: LD_VAR 0 39
51880: PUSH
51881: LD_VAR 0 40
51885: PUSH
51886: EMPTY
51887: LIST
51888: LIST
51889: LIST
51890: LIST
51891: LIST
51892: LIST
51893: PUSH
51894: LD_VAR 0 4
51898: PUSH
51899: LD_INT 1
51901: PLUS
51902: ARRAY
51903: ST_TO_ADDR
51904: GO 52271
51906: LD_INT 6
51908: DOUBLE
51909: EQUAL
51910: IFTRUE 51962
51912: LD_INT 7
51914: DOUBLE
51915: EQUAL
51916: IFTRUE 51962
51918: LD_INT 8
51920: DOUBLE
51921: EQUAL
51922: IFTRUE 51962
51924: LD_INT 13
51926: DOUBLE
51927: EQUAL
51928: IFTRUE 51962
51930: LD_INT 12
51932: DOUBLE
51933: EQUAL
51934: IFTRUE 51962
51936: LD_INT 15
51938: DOUBLE
51939: EQUAL
51940: IFTRUE 51962
51942: LD_INT 11
51944: DOUBLE
51945: EQUAL
51946: IFTRUE 51962
51948: LD_INT 14
51950: DOUBLE
51951: EQUAL
51952: IFTRUE 51962
51954: LD_INT 10
51956: DOUBLE
51957: EQUAL
51958: IFTRUE 51962
51960: GO 52018
51962: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51963: LD_ADDR_VAR 0 9
51967: PUSH
51968: LD_VAR 0 41
51972: PUSH
51973: LD_VAR 0 42
51977: PUSH
51978: LD_VAR 0 43
51982: PUSH
51983: LD_VAR 0 44
51987: PUSH
51988: LD_VAR 0 45
51992: PUSH
51993: LD_VAR 0 46
51997: PUSH
51998: EMPTY
51999: LIST
52000: LIST
52001: LIST
52002: LIST
52003: LIST
52004: LIST
52005: PUSH
52006: LD_VAR 0 4
52010: PUSH
52011: LD_INT 1
52013: PLUS
52014: ARRAY
52015: ST_TO_ADDR
52016: GO 52271
52018: LD_INT 36
52020: DOUBLE
52021: EQUAL
52022: IFTRUE 52026
52024: GO 52082
52026: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52027: LD_ADDR_VAR 0 9
52031: PUSH
52032: LD_VAR 0 47
52036: PUSH
52037: LD_VAR 0 48
52041: PUSH
52042: LD_VAR 0 49
52046: PUSH
52047: LD_VAR 0 50
52051: PUSH
52052: LD_VAR 0 51
52056: PUSH
52057: LD_VAR 0 52
52061: PUSH
52062: EMPTY
52063: LIST
52064: LIST
52065: LIST
52066: LIST
52067: LIST
52068: LIST
52069: PUSH
52070: LD_VAR 0 4
52074: PUSH
52075: LD_INT 1
52077: PLUS
52078: ARRAY
52079: ST_TO_ADDR
52080: GO 52271
52082: LD_INT 4
52084: DOUBLE
52085: EQUAL
52086: IFTRUE 52108
52088: LD_INT 5
52090: DOUBLE
52091: EQUAL
52092: IFTRUE 52108
52094: LD_INT 34
52096: DOUBLE
52097: EQUAL
52098: IFTRUE 52108
52100: LD_INT 37
52102: DOUBLE
52103: EQUAL
52104: IFTRUE 52108
52106: GO 52164
52108: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52109: LD_ADDR_VAR 0 9
52113: PUSH
52114: LD_VAR 0 53
52118: PUSH
52119: LD_VAR 0 54
52123: PUSH
52124: LD_VAR 0 55
52128: PUSH
52129: LD_VAR 0 56
52133: PUSH
52134: LD_VAR 0 57
52138: PUSH
52139: LD_VAR 0 58
52143: PUSH
52144: EMPTY
52145: LIST
52146: LIST
52147: LIST
52148: LIST
52149: LIST
52150: LIST
52151: PUSH
52152: LD_VAR 0 4
52156: PUSH
52157: LD_INT 1
52159: PLUS
52160: ARRAY
52161: ST_TO_ADDR
52162: GO 52271
52164: LD_INT 31
52166: DOUBLE
52167: EQUAL
52168: IFTRUE 52214
52170: LD_INT 32
52172: DOUBLE
52173: EQUAL
52174: IFTRUE 52214
52176: LD_INT 33
52178: DOUBLE
52179: EQUAL
52180: IFTRUE 52214
52182: LD_INT 27
52184: DOUBLE
52185: EQUAL
52186: IFTRUE 52214
52188: LD_INT 26
52190: DOUBLE
52191: EQUAL
52192: IFTRUE 52214
52194: LD_INT 28
52196: DOUBLE
52197: EQUAL
52198: IFTRUE 52214
52200: LD_INT 29
52202: DOUBLE
52203: EQUAL
52204: IFTRUE 52214
52206: LD_INT 30
52208: DOUBLE
52209: EQUAL
52210: IFTRUE 52214
52212: GO 52270
52214: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52215: LD_ADDR_VAR 0 9
52219: PUSH
52220: LD_VAR 0 59
52224: PUSH
52225: LD_VAR 0 60
52229: PUSH
52230: LD_VAR 0 61
52234: PUSH
52235: LD_VAR 0 62
52239: PUSH
52240: LD_VAR 0 63
52244: PUSH
52245: LD_VAR 0 64
52249: PUSH
52250: EMPTY
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: PUSH
52258: LD_VAR 0 4
52262: PUSH
52263: LD_INT 1
52265: PLUS
52266: ARRAY
52267: ST_TO_ADDR
52268: GO 52271
52270: POP
// temp_list2 = [ ] ;
52271: LD_ADDR_VAR 0 10
52275: PUSH
52276: EMPTY
52277: ST_TO_ADDR
// for i in temp_list do
52278: LD_ADDR_VAR 0 8
52282: PUSH
52283: LD_VAR 0 9
52287: PUSH
52288: FOR_IN
52289: IFFALSE 52341
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52291: LD_ADDR_VAR 0 10
52295: PUSH
52296: LD_VAR 0 10
52300: PUSH
52301: LD_VAR 0 8
52305: PUSH
52306: LD_INT 1
52308: ARRAY
52309: PUSH
52310: LD_VAR 0 2
52314: PLUS
52315: PUSH
52316: LD_VAR 0 8
52320: PUSH
52321: LD_INT 2
52323: ARRAY
52324: PUSH
52325: LD_VAR 0 3
52329: PLUS
52330: PUSH
52331: EMPTY
52332: LIST
52333: LIST
52334: PUSH
52335: EMPTY
52336: LIST
52337: ADD
52338: ST_TO_ADDR
52339: GO 52288
52341: POP
52342: POP
// result = temp_list2 ;
52343: LD_ADDR_VAR 0 7
52347: PUSH
52348: LD_VAR 0 10
52352: ST_TO_ADDR
// end ;
52353: LD_VAR 0 7
52357: RET
// export function EnemyInRange ( unit , dist ) ; begin
52358: LD_INT 0
52360: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52361: LD_ADDR_VAR 0 3
52365: PUSH
52366: LD_VAR 0 1
52370: PPUSH
52371: CALL_OW 255
52375: PPUSH
52376: LD_VAR 0 1
52380: PPUSH
52381: CALL_OW 250
52385: PPUSH
52386: LD_VAR 0 1
52390: PPUSH
52391: CALL_OW 251
52395: PPUSH
52396: LD_VAR 0 2
52400: PPUSH
52401: CALL 25754 0 4
52405: PUSH
52406: LD_INT 4
52408: ARRAY
52409: ST_TO_ADDR
// end ;
52410: LD_VAR 0 3
52414: RET
// export function PlayerSeeMe ( unit ) ; begin
52415: LD_INT 0
52417: PPUSH
// result := See ( your_side , unit ) ;
52418: LD_ADDR_VAR 0 2
52422: PUSH
52423: LD_OWVAR 2
52427: PPUSH
52428: LD_VAR 0 1
52432: PPUSH
52433: CALL_OW 292
52437: ST_TO_ADDR
// end ;
52438: LD_VAR 0 2
52442: RET
// export function ReverseDir ( unit ) ; begin
52443: LD_INT 0
52445: PPUSH
// if not unit then
52446: LD_VAR 0 1
52450: NOT
52451: IFFALSE 52455
// exit ;
52453: GO 52478
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52455: LD_ADDR_VAR 0 2
52459: PUSH
52460: LD_VAR 0 1
52464: PPUSH
52465: CALL_OW 254
52469: PUSH
52470: LD_INT 3
52472: PLUS
52473: PUSH
52474: LD_INT 6
52476: MOD
52477: ST_TO_ADDR
// end ;
52478: LD_VAR 0 2
52482: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
52483: LD_INT 0
52485: PPUSH
52486: PPUSH
52487: PPUSH
52488: PPUSH
52489: PPUSH
// if not hexes then
52490: LD_VAR 0 2
52494: NOT
52495: IFFALSE 52499
// exit ;
52497: GO 52647
// dist := 9999 ;
52499: LD_ADDR_VAR 0 5
52503: PUSH
52504: LD_INT 9999
52506: ST_TO_ADDR
// for i = 1 to hexes do
52507: LD_ADDR_VAR 0 4
52511: PUSH
52512: DOUBLE
52513: LD_INT 1
52515: DEC
52516: ST_TO_ADDR
52517: LD_VAR 0 2
52521: PUSH
52522: FOR_TO
52523: IFFALSE 52635
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
52525: LD_VAR 0 1
52529: PPUSH
52530: LD_VAR 0 2
52534: PUSH
52535: LD_VAR 0 4
52539: ARRAY
52540: PUSH
52541: LD_INT 1
52543: ARRAY
52544: PPUSH
52545: LD_VAR 0 2
52549: PUSH
52550: LD_VAR 0 4
52554: ARRAY
52555: PUSH
52556: LD_INT 2
52558: ARRAY
52559: PPUSH
52560: CALL_OW 297
52564: PUSH
52565: LD_VAR 0 5
52569: LESS
52570: IFFALSE 52633
// begin hex := hexes [ i ] ;
52572: LD_ADDR_VAR 0 7
52576: PUSH
52577: LD_VAR 0 2
52581: PUSH
52582: LD_VAR 0 4
52586: ARRAY
52587: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52588: LD_ADDR_VAR 0 5
52592: PUSH
52593: LD_VAR 0 1
52597: PPUSH
52598: LD_VAR 0 2
52602: PUSH
52603: LD_VAR 0 4
52607: ARRAY
52608: PUSH
52609: LD_INT 1
52611: ARRAY
52612: PPUSH
52613: LD_VAR 0 2
52617: PUSH
52618: LD_VAR 0 4
52622: ARRAY
52623: PUSH
52624: LD_INT 2
52626: ARRAY
52627: PPUSH
52628: CALL_OW 297
52632: ST_TO_ADDR
// end ; end ;
52633: GO 52522
52635: POP
52636: POP
// result := hex ;
52637: LD_ADDR_VAR 0 3
52641: PUSH
52642: LD_VAR 0 7
52646: ST_TO_ADDR
// end ;
52647: LD_VAR 0 3
52651: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52652: LD_INT 0
52654: PPUSH
52655: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52656: LD_VAR 0 1
52660: NOT
52661: PUSH
52662: LD_VAR 0 1
52666: PUSH
52667: LD_INT 21
52669: PUSH
52670: LD_INT 2
52672: PUSH
52673: EMPTY
52674: LIST
52675: LIST
52676: PUSH
52677: LD_INT 23
52679: PUSH
52680: LD_INT 2
52682: PUSH
52683: EMPTY
52684: LIST
52685: LIST
52686: PUSH
52687: EMPTY
52688: LIST
52689: LIST
52690: PPUSH
52691: CALL_OW 69
52695: IN
52696: NOT
52697: OR
52698: IFFALSE 52702
// exit ;
52700: GO 52749
// for i = 1 to 3 do
52702: LD_ADDR_VAR 0 3
52706: PUSH
52707: DOUBLE
52708: LD_INT 1
52710: DEC
52711: ST_TO_ADDR
52712: LD_INT 3
52714: PUSH
52715: FOR_TO
52716: IFFALSE 52747
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52718: LD_VAR 0 1
52722: PPUSH
52723: CALL_OW 250
52727: PPUSH
52728: LD_VAR 0 1
52732: PPUSH
52733: CALL_OW 251
52737: PPUSH
52738: LD_INT 1
52740: PPUSH
52741: CALL_OW 453
52745: GO 52715
52747: POP
52748: POP
// end ;
52749: LD_VAR 0 2
52753: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52754: LD_INT 0
52756: PPUSH
52757: PPUSH
52758: PPUSH
52759: PPUSH
52760: PPUSH
52761: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52762: LD_VAR 0 1
52766: NOT
52767: PUSH
52768: LD_VAR 0 2
52772: NOT
52773: OR
52774: PUSH
52775: LD_VAR 0 1
52779: PPUSH
52780: CALL_OW 314
52784: OR
52785: IFFALSE 52789
// exit ;
52787: GO 53230
// x := GetX ( enemy_unit ) ;
52789: LD_ADDR_VAR 0 7
52793: PUSH
52794: LD_VAR 0 2
52798: PPUSH
52799: CALL_OW 250
52803: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52804: LD_ADDR_VAR 0 8
52808: PUSH
52809: LD_VAR 0 2
52813: PPUSH
52814: CALL_OW 251
52818: ST_TO_ADDR
// if not x or not y then
52819: LD_VAR 0 7
52823: NOT
52824: PUSH
52825: LD_VAR 0 8
52829: NOT
52830: OR
52831: IFFALSE 52835
// exit ;
52833: GO 53230
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52835: LD_ADDR_VAR 0 6
52839: PUSH
52840: LD_VAR 0 7
52844: PPUSH
52845: LD_INT 0
52847: PPUSH
52848: LD_INT 4
52850: PPUSH
52851: CALL_OW 272
52855: PUSH
52856: LD_VAR 0 8
52860: PPUSH
52861: LD_INT 0
52863: PPUSH
52864: LD_INT 4
52866: PPUSH
52867: CALL_OW 273
52871: PUSH
52872: EMPTY
52873: LIST
52874: LIST
52875: PUSH
52876: LD_VAR 0 7
52880: PPUSH
52881: LD_INT 1
52883: PPUSH
52884: LD_INT 4
52886: PPUSH
52887: CALL_OW 272
52891: PUSH
52892: LD_VAR 0 8
52896: PPUSH
52897: LD_INT 1
52899: PPUSH
52900: LD_INT 4
52902: PPUSH
52903: CALL_OW 273
52907: PUSH
52908: EMPTY
52909: LIST
52910: LIST
52911: PUSH
52912: LD_VAR 0 7
52916: PPUSH
52917: LD_INT 2
52919: PPUSH
52920: LD_INT 4
52922: PPUSH
52923: CALL_OW 272
52927: PUSH
52928: LD_VAR 0 8
52932: PPUSH
52933: LD_INT 2
52935: PPUSH
52936: LD_INT 4
52938: PPUSH
52939: CALL_OW 273
52943: PUSH
52944: EMPTY
52945: LIST
52946: LIST
52947: PUSH
52948: LD_VAR 0 7
52952: PPUSH
52953: LD_INT 3
52955: PPUSH
52956: LD_INT 4
52958: PPUSH
52959: CALL_OW 272
52963: PUSH
52964: LD_VAR 0 8
52968: PPUSH
52969: LD_INT 3
52971: PPUSH
52972: LD_INT 4
52974: PPUSH
52975: CALL_OW 273
52979: PUSH
52980: EMPTY
52981: LIST
52982: LIST
52983: PUSH
52984: LD_VAR 0 7
52988: PPUSH
52989: LD_INT 4
52991: PPUSH
52992: LD_INT 4
52994: PPUSH
52995: CALL_OW 272
52999: PUSH
53000: LD_VAR 0 8
53004: PPUSH
53005: LD_INT 4
53007: PPUSH
53008: LD_INT 4
53010: PPUSH
53011: CALL_OW 273
53015: PUSH
53016: EMPTY
53017: LIST
53018: LIST
53019: PUSH
53020: LD_VAR 0 7
53024: PPUSH
53025: LD_INT 5
53027: PPUSH
53028: LD_INT 4
53030: PPUSH
53031: CALL_OW 272
53035: PUSH
53036: LD_VAR 0 8
53040: PPUSH
53041: LD_INT 5
53043: PPUSH
53044: LD_INT 4
53046: PPUSH
53047: CALL_OW 273
53051: PUSH
53052: EMPTY
53053: LIST
53054: LIST
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: LIST
53060: LIST
53061: LIST
53062: LIST
53063: ST_TO_ADDR
// for i = tmp downto 1 do
53064: LD_ADDR_VAR 0 4
53068: PUSH
53069: DOUBLE
53070: LD_VAR 0 6
53074: INC
53075: ST_TO_ADDR
53076: LD_INT 1
53078: PUSH
53079: FOR_DOWNTO
53080: IFFALSE 53181
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53082: LD_VAR 0 6
53086: PUSH
53087: LD_VAR 0 4
53091: ARRAY
53092: PUSH
53093: LD_INT 1
53095: ARRAY
53096: PPUSH
53097: LD_VAR 0 6
53101: PUSH
53102: LD_VAR 0 4
53106: ARRAY
53107: PUSH
53108: LD_INT 2
53110: ARRAY
53111: PPUSH
53112: CALL_OW 488
53116: NOT
53117: PUSH
53118: LD_VAR 0 6
53122: PUSH
53123: LD_VAR 0 4
53127: ARRAY
53128: PUSH
53129: LD_INT 1
53131: ARRAY
53132: PPUSH
53133: LD_VAR 0 6
53137: PUSH
53138: LD_VAR 0 4
53142: ARRAY
53143: PUSH
53144: LD_INT 2
53146: ARRAY
53147: PPUSH
53148: CALL_OW 428
53152: PUSH
53153: LD_INT 0
53155: NONEQUAL
53156: OR
53157: IFFALSE 53179
// tmp := Delete ( tmp , i ) ;
53159: LD_ADDR_VAR 0 6
53163: PUSH
53164: LD_VAR 0 6
53168: PPUSH
53169: LD_VAR 0 4
53173: PPUSH
53174: CALL_OW 3
53178: ST_TO_ADDR
53179: GO 53079
53181: POP
53182: POP
// j := GetClosestHex ( unit , tmp ) ;
53183: LD_ADDR_VAR 0 5
53187: PUSH
53188: LD_VAR 0 1
53192: PPUSH
53193: LD_VAR 0 6
53197: PPUSH
53198: CALL 52483 0 2
53202: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53203: LD_VAR 0 1
53207: PPUSH
53208: LD_VAR 0 5
53212: PUSH
53213: LD_INT 1
53215: ARRAY
53216: PPUSH
53217: LD_VAR 0 5
53221: PUSH
53222: LD_INT 2
53224: ARRAY
53225: PPUSH
53226: CALL_OW 111
// end ;
53230: LD_VAR 0 3
53234: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53235: LD_INT 0
53237: PPUSH
53238: PPUSH
53239: PPUSH
// uc_side = 0 ;
53240: LD_ADDR_OWVAR 20
53244: PUSH
53245: LD_INT 0
53247: ST_TO_ADDR
// uc_nation = 0 ;
53248: LD_ADDR_OWVAR 21
53252: PUSH
53253: LD_INT 0
53255: ST_TO_ADDR
// InitHc_All ( ) ;
53256: CALL_OW 584
// InitVc ;
53260: CALL_OW 20
// if mastodonts then
53264: LD_VAR 0 6
53268: IFFALSE 53335
// for i = 1 to mastodonts do
53270: LD_ADDR_VAR 0 11
53274: PUSH
53275: DOUBLE
53276: LD_INT 1
53278: DEC
53279: ST_TO_ADDR
53280: LD_VAR 0 6
53284: PUSH
53285: FOR_TO
53286: IFFALSE 53333
// begin vc_chassis := 31 ;
53288: LD_ADDR_OWVAR 37
53292: PUSH
53293: LD_INT 31
53295: ST_TO_ADDR
// vc_control := control_rider ;
53296: LD_ADDR_OWVAR 38
53300: PUSH
53301: LD_INT 4
53303: ST_TO_ADDR
// animal := CreateVehicle ;
53304: LD_ADDR_VAR 0 12
53308: PUSH
53309: CALL_OW 45
53313: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53314: LD_VAR 0 12
53318: PPUSH
53319: LD_VAR 0 8
53323: PPUSH
53324: LD_INT 0
53326: PPUSH
53327: CALL 55523 0 3
// end ;
53331: GO 53285
53333: POP
53334: POP
// if horses then
53335: LD_VAR 0 5
53339: IFFALSE 53406
// for i = 1 to horses do
53341: LD_ADDR_VAR 0 11
53345: PUSH
53346: DOUBLE
53347: LD_INT 1
53349: DEC
53350: ST_TO_ADDR
53351: LD_VAR 0 5
53355: PUSH
53356: FOR_TO
53357: IFFALSE 53404
// begin hc_class := 21 ;
53359: LD_ADDR_OWVAR 28
53363: PUSH
53364: LD_INT 21
53366: ST_TO_ADDR
// hc_gallery :=  ;
53367: LD_ADDR_OWVAR 33
53371: PUSH
53372: LD_STRING 
53374: ST_TO_ADDR
// animal := CreateHuman ;
53375: LD_ADDR_VAR 0 12
53379: PUSH
53380: CALL_OW 44
53384: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53385: LD_VAR 0 12
53389: PPUSH
53390: LD_VAR 0 8
53394: PPUSH
53395: LD_INT 0
53397: PPUSH
53398: CALL 55523 0 3
// end ;
53402: GO 53356
53404: POP
53405: POP
// if birds then
53406: LD_VAR 0 1
53410: IFFALSE 53477
// for i = 1 to birds do
53412: LD_ADDR_VAR 0 11
53416: PUSH
53417: DOUBLE
53418: LD_INT 1
53420: DEC
53421: ST_TO_ADDR
53422: LD_VAR 0 1
53426: PUSH
53427: FOR_TO
53428: IFFALSE 53475
// begin hc_class = 18 ;
53430: LD_ADDR_OWVAR 28
53434: PUSH
53435: LD_INT 18
53437: ST_TO_ADDR
// hc_gallery =  ;
53438: LD_ADDR_OWVAR 33
53442: PUSH
53443: LD_STRING 
53445: ST_TO_ADDR
// animal := CreateHuman ;
53446: LD_ADDR_VAR 0 12
53450: PUSH
53451: CALL_OW 44
53455: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53456: LD_VAR 0 12
53460: PPUSH
53461: LD_VAR 0 8
53465: PPUSH
53466: LD_INT 0
53468: PPUSH
53469: CALL 55523 0 3
// end ;
53473: GO 53427
53475: POP
53476: POP
// if tigers then
53477: LD_VAR 0 2
53481: IFFALSE 53565
// for i = 1 to tigers do
53483: LD_ADDR_VAR 0 11
53487: PUSH
53488: DOUBLE
53489: LD_INT 1
53491: DEC
53492: ST_TO_ADDR
53493: LD_VAR 0 2
53497: PUSH
53498: FOR_TO
53499: IFFALSE 53563
// begin hc_class = class_tiger ;
53501: LD_ADDR_OWVAR 28
53505: PUSH
53506: LD_INT 14
53508: ST_TO_ADDR
// hc_gallery =  ;
53509: LD_ADDR_OWVAR 33
53513: PUSH
53514: LD_STRING 
53516: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
53517: LD_ADDR_OWVAR 35
53521: PUSH
53522: LD_INT 7
53524: NEG
53525: PPUSH
53526: LD_INT 7
53528: PPUSH
53529: CALL_OW 12
53533: ST_TO_ADDR
// animal := CreateHuman ;
53534: LD_ADDR_VAR 0 12
53538: PUSH
53539: CALL_OW 44
53543: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53544: LD_VAR 0 12
53548: PPUSH
53549: LD_VAR 0 8
53553: PPUSH
53554: LD_INT 0
53556: PPUSH
53557: CALL 55523 0 3
// end ;
53561: GO 53498
53563: POP
53564: POP
// if apemans then
53565: LD_VAR 0 3
53569: IFFALSE 53692
// for i = 1 to apemans do
53571: LD_ADDR_VAR 0 11
53575: PUSH
53576: DOUBLE
53577: LD_INT 1
53579: DEC
53580: ST_TO_ADDR
53581: LD_VAR 0 3
53585: PUSH
53586: FOR_TO
53587: IFFALSE 53690
// begin hc_class = class_apeman ;
53589: LD_ADDR_OWVAR 28
53593: PUSH
53594: LD_INT 12
53596: ST_TO_ADDR
// hc_gallery =  ;
53597: LD_ADDR_OWVAR 33
53601: PUSH
53602: LD_STRING 
53604: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
53605: LD_ADDR_OWVAR 35
53609: PUSH
53610: LD_INT 2
53612: NEG
53613: PPUSH
53614: LD_INT 2
53616: PPUSH
53617: CALL_OW 12
53621: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
53622: LD_ADDR_OWVAR 31
53626: PUSH
53627: LD_INT 1
53629: PPUSH
53630: LD_INT 3
53632: PPUSH
53633: CALL_OW 12
53637: PUSH
53638: LD_INT 1
53640: PPUSH
53641: LD_INT 3
53643: PPUSH
53644: CALL_OW 12
53648: PUSH
53649: LD_INT 0
53651: PUSH
53652: LD_INT 0
53654: PUSH
53655: EMPTY
53656: LIST
53657: LIST
53658: LIST
53659: LIST
53660: ST_TO_ADDR
// animal := CreateHuman ;
53661: LD_ADDR_VAR 0 12
53665: PUSH
53666: CALL_OW 44
53670: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53671: LD_VAR 0 12
53675: PPUSH
53676: LD_VAR 0 8
53680: PPUSH
53681: LD_INT 0
53683: PPUSH
53684: CALL 55523 0 3
// end ;
53688: GO 53586
53690: POP
53691: POP
// if enchidnas then
53692: LD_VAR 0 4
53696: IFFALSE 53763
// for i = 1 to enchidnas do
53698: LD_ADDR_VAR 0 11
53702: PUSH
53703: DOUBLE
53704: LD_INT 1
53706: DEC
53707: ST_TO_ADDR
53708: LD_VAR 0 4
53712: PUSH
53713: FOR_TO
53714: IFFALSE 53761
// begin hc_class = 13 ;
53716: LD_ADDR_OWVAR 28
53720: PUSH
53721: LD_INT 13
53723: ST_TO_ADDR
// hc_gallery =  ;
53724: LD_ADDR_OWVAR 33
53728: PUSH
53729: LD_STRING 
53731: ST_TO_ADDR
// animal := CreateHuman ;
53732: LD_ADDR_VAR 0 12
53736: PUSH
53737: CALL_OW 44
53741: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53742: LD_VAR 0 12
53746: PPUSH
53747: LD_VAR 0 8
53751: PPUSH
53752: LD_INT 0
53754: PPUSH
53755: CALL 55523 0 3
// end ;
53759: GO 53713
53761: POP
53762: POP
// if fishes then
53763: LD_VAR 0 7
53767: IFFALSE 53834
// for i = 1 to fishes do
53769: LD_ADDR_VAR 0 11
53773: PUSH
53774: DOUBLE
53775: LD_INT 1
53777: DEC
53778: ST_TO_ADDR
53779: LD_VAR 0 7
53783: PUSH
53784: FOR_TO
53785: IFFALSE 53832
// begin hc_class = 20 ;
53787: LD_ADDR_OWVAR 28
53791: PUSH
53792: LD_INT 20
53794: ST_TO_ADDR
// hc_gallery =  ;
53795: LD_ADDR_OWVAR 33
53799: PUSH
53800: LD_STRING 
53802: ST_TO_ADDR
// animal := CreateHuman ;
53803: LD_ADDR_VAR 0 12
53807: PUSH
53808: CALL_OW 44
53812: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53813: LD_VAR 0 12
53817: PPUSH
53818: LD_VAR 0 9
53822: PPUSH
53823: LD_INT 0
53825: PPUSH
53826: CALL 55523 0 3
// end ;
53830: GO 53784
53832: POP
53833: POP
// end ;
53834: LD_VAR 0 10
53838: RET
// export function WantHeal ( sci , unit ) ; begin
53839: LD_INT 0
53841: PPUSH
// if GetTaskList ( sci ) > 0 then
53842: LD_VAR 0 1
53846: PPUSH
53847: CALL_OW 437
53851: PUSH
53852: LD_INT 0
53854: GREATER
53855: IFFALSE 53925
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
53857: LD_VAR 0 1
53861: PPUSH
53862: CALL_OW 437
53866: PUSH
53867: LD_INT 1
53869: ARRAY
53870: PUSH
53871: LD_INT 1
53873: ARRAY
53874: PUSH
53875: LD_STRING l
53877: EQUAL
53878: PUSH
53879: LD_VAR 0 1
53883: PPUSH
53884: CALL_OW 437
53888: PUSH
53889: LD_INT 1
53891: ARRAY
53892: PUSH
53893: LD_INT 4
53895: ARRAY
53896: PUSH
53897: LD_VAR 0 2
53901: EQUAL
53902: AND
53903: IFFALSE 53915
// result := true else
53905: LD_ADDR_VAR 0 3
53909: PUSH
53910: LD_INT 1
53912: ST_TO_ADDR
53913: GO 53923
// result := false ;
53915: LD_ADDR_VAR 0 3
53919: PUSH
53920: LD_INT 0
53922: ST_TO_ADDR
// end else
53923: GO 53933
// result := false ;
53925: LD_ADDR_VAR 0 3
53929: PUSH
53930: LD_INT 0
53932: ST_TO_ADDR
// end ;
53933: LD_VAR 0 3
53937: RET
// export function HealTarget ( sci ) ; begin
53938: LD_INT 0
53940: PPUSH
// if not sci then
53941: LD_VAR 0 1
53945: NOT
53946: IFFALSE 53950
// exit ;
53948: GO 54015
// result := 0 ;
53950: LD_ADDR_VAR 0 2
53954: PUSH
53955: LD_INT 0
53957: ST_TO_ADDR
// if GetTaskList ( sci ) then
53958: LD_VAR 0 1
53962: PPUSH
53963: CALL_OW 437
53967: IFFALSE 54015
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
53969: LD_VAR 0 1
53973: PPUSH
53974: CALL_OW 437
53978: PUSH
53979: LD_INT 1
53981: ARRAY
53982: PUSH
53983: LD_INT 1
53985: ARRAY
53986: PUSH
53987: LD_STRING l
53989: EQUAL
53990: IFFALSE 54015
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
53992: LD_ADDR_VAR 0 2
53996: PUSH
53997: LD_VAR 0 1
54001: PPUSH
54002: CALL_OW 437
54006: PUSH
54007: LD_INT 1
54009: ARRAY
54010: PUSH
54011: LD_INT 4
54013: ARRAY
54014: ST_TO_ADDR
// end ;
54015: LD_VAR 0 2
54019: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54020: LD_INT 0
54022: PPUSH
54023: PPUSH
54024: PPUSH
54025: PPUSH
// if not base_units then
54026: LD_VAR 0 1
54030: NOT
54031: IFFALSE 54035
// exit ;
54033: GO 54122
// result := false ;
54035: LD_ADDR_VAR 0 2
54039: PUSH
54040: LD_INT 0
54042: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54043: LD_ADDR_VAR 0 5
54047: PUSH
54048: LD_VAR 0 1
54052: PPUSH
54053: LD_INT 21
54055: PUSH
54056: LD_INT 3
54058: PUSH
54059: EMPTY
54060: LIST
54061: LIST
54062: PPUSH
54063: CALL_OW 72
54067: ST_TO_ADDR
// if not tmp then
54068: LD_VAR 0 5
54072: NOT
54073: IFFALSE 54077
// exit ;
54075: GO 54122
// for i in tmp do
54077: LD_ADDR_VAR 0 3
54081: PUSH
54082: LD_VAR 0 5
54086: PUSH
54087: FOR_IN
54088: IFFALSE 54120
// begin result := EnemyInRange ( i , 22 ) ;
54090: LD_ADDR_VAR 0 2
54094: PUSH
54095: LD_VAR 0 3
54099: PPUSH
54100: LD_INT 22
54102: PPUSH
54103: CALL 52358 0 2
54107: ST_TO_ADDR
// if result then
54108: LD_VAR 0 2
54112: IFFALSE 54118
// exit ;
54114: POP
54115: POP
54116: GO 54122
// end ;
54118: GO 54087
54120: POP
54121: POP
// end ;
54122: LD_VAR 0 2
54126: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54127: LD_INT 0
54129: PPUSH
54130: PPUSH
// if not units then
54131: LD_VAR 0 1
54135: NOT
54136: IFFALSE 54140
// exit ;
54138: GO 54210
// result := [ ] ;
54140: LD_ADDR_VAR 0 3
54144: PUSH
54145: EMPTY
54146: ST_TO_ADDR
// for i in units do
54147: LD_ADDR_VAR 0 4
54151: PUSH
54152: LD_VAR 0 1
54156: PUSH
54157: FOR_IN
54158: IFFALSE 54208
// if GetTag ( i ) = tag then
54160: LD_VAR 0 4
54164: PPUSH
54165: CALL_OW 110
54169: PUSH
54170: LD_VAR 0 2
54174: EQUAL
54175: IFFALSE 54206
// result := Replace ( result , result + 1 , i ) ;
54177: LD_ADDR_VAR 0 3
54181: PUSH
54182: LD_VAR 0 3
54186: PPUSH
54187: LD_VAR 0 3
54191: PUSH
54192: LD_INT 1
54194: PLUS
54195: PPUSH
54196: LD_VAR 0 4
54200: PPUSH
54201: CALL_OW 1
54205: ST_TO_ADDR
54206: GO 54157
54208: POP
54209: POP
// end ;
54210: LD_VAR 0 3
54214: RET
// export function IsDriver ( un ) ; begin
54215: LD_INT 0
54217: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54218: LD_ADDR_VAR 0 2
54222: PUSH
54223: LD_VAR 0 1
54227: PUSH
54228: LD_INT 55
54230: PUSH
54231: EMPTY
54232: LIST
54233: PPUSH
54234: CALL_OW 69
54238: IN
54239: ST_TO_ADDR
// end ;
54240: LD_VAR 0 2
54244: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54245: LD_INT 0
54247: PPUSH
54248: PPUSH
// list := [ ] ;
54249: LD_ADDR_VAR 0 5
54253: PUSH
54254: EMPTY
54255: ST_TO_ADDR
// case d of 0 :
54256: LD_VAR 0 3
54260: PUSH
54261: LD_INT 0
54263: DOUBLE
54264: EQUAL
54265: IFTRUE 54269
54267: GO 54402
54269: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54270: LD_ADDR_VAR 0 5
54274: PUSH
54275: LD_VAR 0 1
54279: PUSH
54280: LD_INT 4
54282: MINUS
54283: PUSH
54284: LD_VAR 0 2
54288: PUSH
54289: LD_INT 4
54291: MINUS
54292: PUSH
54293: LD_INT 2
54295: PUSH
54296: EMPTY
54297: LIST
54298: LIST
54299: LIST
54300: PUSH
54301: LD_VAR 0 1
54305: PUSH
54306: LD_INT 3
54308: MINUS
54309: PUSH
54310: LD_VAR 0 2
54314: PUSH
54315: LD_INT 1
54317: PUSH
54318: EMPTY
54319: LIST
54320: LIST
54321: LIST
54322: PUSH
54323: LD_VAR 0 1
54327: PUSH
54328: LD_INT 4
54330: PLUS
54331: PUSH
54332: LD_VAR 0 2
54336: PUSH
54337: LD_INT 4
54339: PUSH
54340: EMPTY
54341: LIST
54342: LIST
54343: LIST
54344: PUSH
54345: LD_VAR 0 1
54349: PUSH
54350: LD_INT 3
54352: PLUS
54353: PUSH
54354: LD_VAR 0 2
54358: PUSH
54359: LD_INT 3
54361: PLUS
54362: PUSH
54363: LD_INT 5
54365: PUSH
54366: EMPTY
54367: LIST
54368: LIST
54369: LIST
54370: PUSH
54371: LD_VAR 0 1
54375: PUSH
54376: LD_VAR 0 2
54380: PUSH
54381: LD_INT 4
54383: PLUS
54384: PUSH
54385: LD_INT 0
54387: PUSH
54388: EMPTY
54389: LIST
54390: LIST
54391: LIST
54392: PUSH
54393: EMPTY
54394: LIST
54395: LIST
54396: LIST
54397: LIST
54398: LIST
54399: ST_TO_ADDR
// end ; 1 :
54400: GO 55100
54402: LD_INT 1
54404: DOUBLE
54405: EQUAL
54406: IFTRUE 54410
54408: GO 54543
54410: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54411: LD_ADDR_VAR 0 5
54415: PUSH
54416: LD_VAR 0 1
54420: PUSH
54421: LD_VAR 0 2
54425: PUSH
54426: LD_INT 4
54428: MINUS
54429: PUSH
54430: LD_INT 3
54432: PUSH
54433: EMPTY
54434: LIST
54435: LIST
54436: LIST
54437: PUSH
54438: LD_VAR 0 1
54442: PUSH
54443: LD_INT 3
54445: MINUS
54446: PUSH
54447: LD_VAR 0 2
54451: PUSH
54452: LD_INT 3
54454: MINUS
54455: PUSH
54456: LD_INT 2
54458: PUSH
54459: EMPTY
54460: LIST
54461: LIST
54462: LIST
54463: PUSH
54464: LD_VAR 0 1
54468: PUSH
54469: LD_INT 4
54471: MINUS
54472: PUSH
54473: LD_VAR 0 2
54477: PUSH
54478: LD_INT 1
54480: PUSH
54481: EMPTY
54482: LIST
54483: LIST
54484: LIST
54485: PUSH
54486: LD_VAR 0 1
54490: PUSH
54491: LD_VAR 0 2
54495: PUSH
54496: LD_INT 3
54498: PLUS
54499: PUSH
54500: LD_INT 0
54502: PUSH
54503: EMPTY
54504: LIST
54505: LIST
54506: LIST
54507: PUSH
54508: LD_VAR 0 1
54512: PUSH
54513: LD_INT 4
54515: PLUS
54516: PUSH
54517: LD_VAR 0 2
54521: PUSH
54522: LD_INT 4
54524: PLUS
54525: PUSH
54526: LD_INT 5
54528: PUSH
54529: EMPTY
54530: LIST
54531: LIST
54532: LIST
54533: PUSH
54534: EMPTY
54535: LIST
54536: LIST
54537: LIST
54538: LIST
54539: LIST
54540: ST_TO_ADDR
// end ; 2 :
54541: GO 55100
54543: LD_INT 2
54545: DOUBLE
54546: EQUAL
54547: IFTRUE 54551
54549: GO 54680
54551: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54552: LD_ADDR_VAR 0 5
54556: PUSH
54557: LD_VAR 0 1
54561: PUSH
54562: LD_VAR 0 2
54566: PUSH
54567: LD_INT 3
54569: MINUS
54570: PUSH
54571: LD_INT 3
54573: PUSH
54574: EMPTY
54575: LIST
54576: LIST
54577: LIST
54578: PUSH
54579: LD_VAR 0 1
54583: PUSH
54584: LD_INT 4
54586: PLUS
54587: PUSH
54588: LD_VAR 0 2
54592: PUSH
54593: LD_INT 4
54595: PUSH
54596: EMPTY
54597: LIST
54598: LIST
54599: LIST
54600: PUSH
54601: LD_VAR 0 1
54605: PUSH
54606: LD_VAR 0 2
54610: PUSH
54611: LD_INT 4
54613: PLUS
54614: PUSH
54615: LD_INT 0
54617: PUSH
54618: EMPTY
54619: LIST
54620: LIST
54621: LIST
54622: PUSH
54623: LD_VAR 0 1
54627: PUSH
54628: LD_INT 3
54630: MINUS
54631: PUSH
54632: LD_VAR 0 2
54636: PUSH
54637: LD_INT 1
54639: PUSH
54640: EMPTY
54641: LIST
54642: LIST
54643: LIST
54644: PUSH
54645: LD_VAR 0 1
54649: PUSH
54650: LD_INT 4
54652: MINUS
54653: PUSH
54654: LD_VAR 0 2
54658: PUSH
54659: LD_INT 4
54661: MINUS
54662: PUSH
54663: LD_INT 2
54665: PUSH
54666: EMPTY
54667: LIST
54668: LIST
54669: LIST
54670: PUSH
54671: EMPTY
54672: LIST
54673: LIST
54674: LIST
54675: LIST
54676: LIST
54677: ST_TO_ADDR
// end ; 3 :
54678: GO 55100
54680: LD_INT 3
54682: DOUBLE
54683: EQUAL
54684: IFTRUE 54688
54686: GO 54821
54688: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54689: LD_ADDR_VAR 0 5
54693: PUSH
54694: LD_VAR 0 1
54698: PUSH
54699: LD_INT 3
54701: PLUS
54702: PUSH
54703: LD_VAR 0 2
54707: PUSH
54708: LD_INT 4
54710: PUSH
54711: EMPTY
54712: LIST
54713: LIST
54714: LIST
54715: PUSH
54716: LD_VAR 0 1
54720: PUSH
54721: LD_INT 4
54723: PLUS
54724: PUSH
54725: LD_VAR 0 2
54729: PUSH
54730: LD_INT 4
54732: PLUS
54733: PUSH
54734: LD_INT 5
54736: PUSH
54737: EMPTY
54738: LIST
54739: LIST
54740: LIST
54741: PUSH
54742: LD_VAR 0 1
54746: PUSH
54747: LD_INT 4
54749: MINUS
54750: PUSH
54751: LD_VAR 0 2
54755: PUSH
54756: LD_INT 1
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: LIST
54763: PUSH
54764: LD_VAR 0 1
54768: PUSH
54769: LD_VAR 0 2
54773: PUSH
54774: LD_INT 4
54776: MINUS
54777: PUSH
54778: LD_INT 3
54780: PUSH
54781: EMPTY
54782: LIST
54783: LIST
54784: LIST
54785: PUSH
54786: LD_VAR 0 1
54790: PUSH
54791: LD_INT 3
54793: MINUS
54794: PUSH
54795: LD_VAR 0 2
54799: PUSH
54800: LD_INT 3
54802: MINUS
54803: PUSH
54804: LD_INT 2
54806: PUSH
54807: EMPTY
54808: LIST
54809: LIST
54810: LIST
54811: PUSH
54812: EMPTY
54813: LIST
54814: LIST
54815: LIST
54816: LIST
54817: LIST
54818: ST_TO_ADDR
// end ; 4 :
54819: GO 55100
54821: LD_INT 4
54823: DOUBLE
54824: EQUAL
54825: IFTRUE 54829
54827: GO 54962
54829: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54830: LD_ADDR_VAR 0 5
54834: PUSH
54835: LD_VAR 0 1
54839: PUSH
54840: LD_VAR 0 2
54844: PUSH
54845: LD_INT 4
54847: PLUS
54848: PUSH
54849: LD_INT 0
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: LIST
54856: PUSH
54857: LD_VAR 0 1
54861: PUSH
54862: LD_INT 3
54864: PLUS
54865: PUSH
54866: LD_VAR 0 2
54870: PUSH
54871: LD_INT 3
54873: PLUS
54874: PUSH
54875: LD_INT 5
54877: PUSH
54878: EMPTY
54879: LIST
54880: LIST
54881: LIST
54882: PUSH
54883: LD_VAR 0 1
54887: PUSH
54888: LD_INT 4
54890: PLUS
54891: PUSH
54892: LD_VAR 0 2
54896: PUSH
54897: LD_INT 4
54899: PUSH
54900: EMPTY
54901: LIST
54902: LIST
54903: LIST
54904: PUSH
54905: LD_VAR 0 1
54909: PUSH
54910: LD_VAR 0 2
54914: PUSH
54915: LD_INT 3
54917: MINUS
54918: PUSH
54919: LD_INT 3
54921: PUSH
54922: EMPTY
54923: LIST
54924: LIST
54925: LIST
54926: PUSH
54927: LD_VAR 0 1
54931: PUSH
54932: LD_INT 4
54934: MINUS
54935: PUSH
54936: LD_VAR 0 2
54940: PUSH
54941: LD_INT 4
54943: MINUS
54944: PUSH
54945: LD_INT 2
54947: PUSH
54948: EMPTY
54949: LIST
54950: LIST
54951: LIST
54952: PUSH
54953: EMPTY
54954: LIST
54955: LIST
54956: LIST
54957: LIST
54958: LIST
54959: ST_TO_ADDR
// end ; 5 :
54960: GO 55100
54962: LD_INT 5
54964: DOUBLE
54965: EQUAL
54966: IFTRUE 54970
54968: GO 55099
54970: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54971: LD_ADDR_VAR 0 5
54975: PUSH
54976: LD_VAR 0 1
54980: PUSH
54981: LD_INT 4
54983: MINUS
54984: PUSH
54985: LD_VAR 0 2
54989: PUSH
54990: LD_INT 1
54992: PUSH
54993: EMPTY
54994: LIST
54995: LIST
54996: LIST
54997: PUSH
54998: LD_VAR 0 1
55002: PUSH
55003: LD_VAR 0 2
55007: PUSH
55008: LD_INT 4
55010: MINUS
55011: PUSH
55012: LD_INT 3
55014: PUSH
55015: EMPTY
55016: LIST
55017: LIST
55018: LIST
55019: PUSH
55020: LD_VAR 0 1
55024: PUSH
55025: LD_INT 4
55027: PLUS
55028: PUSH
55029: LD_VAR 0 2
55033: PUSH
55034: LD_INT 4
55036: PLUS
55037: PUSH
55038: LD_INT 5
55040: PUSH
55041: EMPTY
55042: LIST
55043: LIST
55044: LIST
55045: PUSH
55046: LD_VAR 0 1
55050: PUSH
55051: LD_INT 3
55053: PLUS
55054: PUSH
55055: LD_VAR 0 2
55059: PUSH
55060: LD_INT 4
55062: PUSH
55063: EMPTY
55064: LIST
55065: LIST
55066: LIST
55067: PUSH
55068: LD_VAR 0 1
55072: PUSH
55073: LD_VAR 0 2
55077: PUSH
55078: LD_INT 3
55080: PLUS
55081: PUSH
55082: LD_INT 0
55084: PUSH
55085: EMPTY
55086: LIST
55087: LIST
55088: LIST
55089: PUSH
55090: EMPTY
55091: LIST
55092: LIST
55093: LIST
55094: LIST
55095: LIST
55096: ST_TO_ADDR
// end ; end ;
55097: GO 55100
55099: POP
// result := list ;
55100: LD_ADDR_VAR 0 4
55104: PUSH
55105: LD_VAR 0 5
55109: ST_TO_ADDR
// end ;
55110: LD_VAR 0 4
55114: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55115: LD_INT 0
55117: PPUSH
55118: PPUSH
55119: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55120: LD_VAR 0 1
55124: NOT
55125: PUSH
55126: LD_VAR 0 2
55130: PUSH
55131: LD_INT 1
55133: PUSH
55134: LD_INT 2
55136: PUSH
55137: LD_INT 3
55139: PUSH
55140: LD_INT 4
55142: PUSH
55143: EMPTY
55144: LIST
55145: LIST
55146: LIST
55147: LIST
55148: IN
55149: NOT
55150: OR
55151: IFFALSE 55155
// exit ;
55153: GO 55247
// tmp := [ ] ;
55155: LD_ADDR_VAR 0 5
55159: PUSH
55160: EMPTY
55161: ST_TO_ADDR
// for i in units do
55162: LD_ADDR_VAR 0 4
55166: PUSH
55167: LD_VAR 0 1
55171: PUSH
55172: FOR_IN
55173: IFFALSE 55216
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55175: LD_ADDR_VAR 0 5
55179: PUSH
55180: LD_VAR 0 5
55184: PPUSH
55185: LD_VAR 0 5
55189: PUSH
55190: LD_INT 1
55192: PLUS
55193: PPUSH
55194: LD_VAR 0 4
55198: PPUSH
55199: LD_VAR 0 2
55203: PPUSH
55204: CALL_OW 259
55208: PPUSH
55209: CALL_OW 2
55213: ST_TO_ADDR
55214: GO 55172
55216: POP
55217: POP
// if not tmp then
55218: LD_VAR 0 5
55222: NOT
55223: IFFALSE 55227
// exit ;
55225: GO 55247
// result := SortListByListDesc ( units , tmp ) ;
55227: LD_ADDR_VAR 0 3
55231: PUSH
55232: LD_VAR 0 1
55236: PPUSH
55237: LD_VAR 0 5
55241: PPUSH
55242: CALL_OW 77
55246: ST_TO_ADDR
// end ;
55247: LD_VAR 0 3
55251: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55252: LD_INT 0
55254: PPUSH
55255: PPUSH
55256: PPUSH
// result := false ;
55257: LD_ADDR_VAR 0 3
55261: PUSH
55262: LD_INT 0
55264: ST_TO_ADDR
// x := GetX ( building ) ;
55265: LD_ADDR_VAR 0 4
55269: PUSH
55270: LD_VAR 0 2
55274: PPUSH
55275: CALL_OW 250
55279: ST_TO_ADDR
// y := GetY ( building ) ;
55280: LD_ADDR_VAR 0 5
55284: PUSH
55285: LD_VAR 0 2
55289: PPUSH
55290: CALL_OW 251
55294: ST_TO_ADDR
// if not building or not x or not y then
55295: LD_VAR 0 2
55299: NOT
55300: PUSH
55301: LD_VAR 0 4
55305: NOT
55306: OR
55307: PUSH
55308: LD_VAR 0 5
55312: NOT
55313: OR
55314: IFFALSE 55318
// exit ;
55316: GO 55410
// if GetTaskList ( unit ) then
55318: LD_VAR 0 1
55322: PPUSH
55323: CALL_OW 437
55327: IFFALSE 55410
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55329: LD_STRING e
55331: PUSH
55332: LD_VAR 0 1
55336: PPUSH
55337: CALL_OW 437
55341: PUSH
55342: LD_INT 1
55344: ARRAY
55345: PUSH
55346: LD_INT 1
55348: ARRAY
55349: EQUAL
55350: PUSH
55351: LD_VAR 0 4
55355: PUSH
55356: LD_VAR 0 1
55360: PPUSH
55361: CALL_OW 437
55365: PUSH
55366: LD_INT 1
55368: ARRAY
55369: PUSH
55370: LD_INT 2
55372: ARRAY
55373: EQUAL
55374: AND
55375: PUSH
55376: LD_VAR 0 5
55380: PUSH
55381: LD_VAR 0 1
55385: PPUSH
55386: CALL_OW 437
55390: PUSH
55391: LD_INT 1
55393: ARRAY
55394: PUSH
55395: LD_INT 3
55397: ARRAY
55398: EQUAL
55399: AND
55400: IFFALSE 55410
// result := true end ;
55402: LD_ADDR_VAR 0 3
55406: PUSH
55407: LD_INT 1
55409: ST_TO_ADDR
// end ;
55410: LD_VAR 0 3
55414: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
55415: LD_INT 0
55417: PPUSH
// result := false ;
55418: LD_ADDR_VAR 0 4
55422: PUSH
55423: LD_INT 0
55425: ST_TO_ADDR
// if GetTaskList ( unit ) then
55426: LD_VAR 0 1
55430: PPUSH
55431: CALL_OW 437
55435: IFFALSE 55518
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55437: LD_STRING M
55439: PUSH
55440: LD_VAR 0 1
55444: PPUSH
55445: CALL_OW 437
55449: PUSH
55450: LD_INT 1
55452: ARRAY
55453: PUSH
55454: LD_INT 1
55456: ARRAY
55457: EQUAL
55458: PUSH
55459: LD_VAR 0 2
55463: PUSH
55464: LD_VAR 0 1
55468: PPUSH
55469: CALL_OW 437
55473: PUSH
55474: LD_INT 1
55476: ARRAY
55477: PUSH
55478: LD_INT 2
55480: ARRAY
55481: EQUAL
55482: AND
55483: PUSH
55484: LD_VAR 0 3
55488: PUSH
55489: LD_VAR 0 1
55493: PPUSH
55494: CALL_OW 437
55498: PUSH
55499: LD_INT 1
55501: ARRAY
55502: PUSH
55503: LD_INT 3
55505: ARRAY
55506: EQUAL
55507: AND
55508: IFFALSE 55518
// result := true ;
55510: LD_ADDR_VAR 0 4
55514: PUSH
55515: LD_INT 1
55517: ST_TO_ADDR
// end ; end ;
55518: LD_VAR 0 4
55522: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55523: LD_INT 0
55525: PPUSH
55526: PPUSH
55527: PPUSH
55528: PPUSH
// if not unit or not area then
55529: LD_VAR 0 1
55533: NOT
55534: PUSH
55535: LD_VAR 0 2
55539: NOT
55540: OR
55541: IFFALSE 55545
// exit ;
55543: GO 55709
// tmp := AreaToList ( area , i ) ;
55545: LD_ADDR_VAR 0 6
55549: PUSH
55550: LD_VAR 0 2
55554: PPUSH
55555: LD_VAR 0 5
55559: PPUSH
55560: CALL_OW 517
55564: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55565: LD_ADDR_VAR 0 5
55569: PUSH
55570: DOUBLE
55571: LD_INT 1
55573: DEC
55574: ST_TO_ADDR
55575: LD_VAR 0 6
55579: PUSH
55580: LD_INT 1
55582: ARRAY
55583: PUSH
55584: FOR_TO
55585: IFFALSE 55707
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55587: LD_ADDR_VAR 0 7
55591: PUSH
55592: LD_VAR 0 6
55596: PUSH
55597: LD_INT 1
55599: ARRAY
55600: PUSH
55601: LD_VAR 0 5
55605: ARRAY
55606: PUSH
55607: LD_VAR 0 6
55611: PUSH
55612: LD_INT 2
55614: ARRAY
55615: PUSH
55616: LD_VAR 0 5
55620: ARRAY
55621: PUSH
55622: EMPTY
55623: LIST
55624: LIST
55625: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55626: LD_VAR 0 7
55630: PUSH
55631: LD_INT 1
55633: ARRAY
55634: PPUSH
55635: LD_VAR 0 7
55639: PUSH
55640: LD_INT 2
55642: ARRAY
55643: PPUSH
55644: CALL_OW 428
55648: PUSH
55649: LD_INT 0
55651: EQUAL
55652: IFFALSE 55705
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55654: LD_VAR 0 1
55658: PPUSH
55659: LD_VAR 0 7
55663: PUSH
55664: LD_INT 1
55666: ARRAY
55667: PPUSH
55668: LD_VAR 0 7
55672: PUSH
55673: LD_INT 2
55675: ARRAY
55676: PPUSH
55677: LD_VAR 0 3
55681: PPUSH
55682: CALL_OW 48
// result := IsPlaced ( unit ) ;
55686: LD_ADDR_VAR 0 4
55690: PUSH
55691: LD_VAR 0 1
55695: PPUSH
55696: CALL_OW 305
55700: ST_TO_ADDR
// exit ;
55701: POP
55702: POP
55703: GO 55709
// end ; end ;
55705: GO 55584
55707: POP
55708: POP
// end ;
55709: LD_VAR 0 4
55713: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55714: LD_INT 0
55716: PPUSH
55717: PPUSH
55718: PPUSH
// if not side or side > 8 then
55719: LD_VAR 0 1
55723: NOT
55724: PUSH
55725: LD_VAR 0 1
55729: PUSH
55730: LD_INT 8
55732: GREATER
55733: OR
55734: IFFALSE 55738
// exit ;
55736: GO 55925
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55738: LD_ADDR_VAR 0 4
55742: PUSH
55743: LD_INT 22
55745: PUSH
55746: LD_VAR 0 1
55750: PUSH
55751: EMPTY
55752: LIST
55753: LIST
55754: PUSH
55755: LD_INT 21
55757: PUSH
55758: LD_INT 3
55760: PUSH
55761: EMPTY
55762: LIST
55763: LIST
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: PPUSH
55769: CALL_OW 69
55773: ST_TO_ADDR
// if not tmp then
55774: LD_VAR 0 4
55778: NOT
55779: IFFALSE 55783
// exit ;
55781: GO 55925
// enable_addtolog := true ;
55783: LD_ADDR_OWVAR 81
55787: PUSH
55788: LD_INT 1
55790: ST_TO_ADDR
// AddToLog ( [ ) ;
55791: LD_STRING [
55793: PPUSH
55794: CALL_OW 561
// for i in tmp do
55798: LD_ADDR_VAR 0 3
55802: PUSH
55803: LD_VAR 0 4
55807: PUSH
55808: FOR_IN
55809: IFFALSE 55916
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55811: LD_STRING [
55813: PUSH
55814: LD_VAR 0 3
55818: PPUSH
55819: CALL_OW 266
55823: STR
55824: PUSH
55825: LD_STRING , 
55827: STR
55828: PUSH
55829: LD_VAR 0 3
55833: PPUSH
55834: CALL_OW 250
55838: STR
55839: PUSH
55840: LD_STRING , 
55842: STR
55843: PUSH
55844: LD_VAR 0 3
55848: PPUSH
55849: CALL_OW 251
55853: STR
55854: PUSH
55855: LD_STRING , 
55857: STR
55858: PUSH
55859: LD_VAR 0 3
55863: PPUSH
55864: CALL_OW 254
55868: STR
55869: PUSH
55870: LD_STRING , 
55872: STR
55873: PUSH
55874: LD_VAR 0 3
55878: PPUSH
55879: LD_INT 1
55881: PPUSH
55882: CALL_OW 268
55886: STR
55887: PUSH
55888: LD_STRING , 
55890: STR
55891: PUSH
55892: LD_VAR 0 3
55896: PPUSH
55897: LD_INT 2
55899: PPUSH
55900: CALL_OW 268
55904: STR
55905: PUSH
55906: LD_STRING ],
55908: STR
55909: PPUSH
55910: CALL_OW 561
// end ;
55914: GO 55808
55916: POP
55917: POP
// AddToLog ( ]; ) ;
55918: LD_STRING ];
55920: PPUSH
55921: CALL_OW 561
// end ;
55925: LD_VAR 0 2
55929: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55930: LD_INT 0
55932: PPUSH
55933: PPUSH
55934: PPUSH
55935: PPUSH
55936: PPUSH
// if not area or not rate or not max then
55937: LD_VAR 0 1
55941: NOT
55942: PUSH
55943: LD_VAR 0 2
55947: NOT
55948: OR
55949: PUSH
55950: LD_VAR 0 4
55954: NOT
55955: OR
55956: IFFALSE 55960
// exit ;
55958: GO 56152
// while 1 do
55960: LD_INT 1
55962: IFFALSE 56152
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55964: LD_ADDR_VAR 0 9
55968: PUSH
55969: LD_VAR 0 1
55973: PPUSH
55974: LD_INT 1
55976: PPUSH
55977: CALL_OW 287
55981: PUSH
55982: LD_INT 10
55984: MUL
55985: ST_TO_ADDR
// r := rate / 10 ;
55986: LD_ADDR_VAR 0 7
55990: PUSH
55991: LD_VAR 0 2
55995: PUSH
55996: LD_INT 10
55998: DIVREAL
55999: ST_TO_ADDR
// time := 1 1$00 ;
56000: LD_ADDR_VAR 0 8
56004: PUSH
56005: LD_INT 2100
56007: ST_TO_ADDR
// if amount < min then
56008: LD_VAR 0 9
56012: PUSH
56013: LD_VAR 0 3
56017: LESS
56018: IFFALSE 56036
// r := r * 2 else
56020: LD_ADDR_VAR 0 7
56024: PUSH
56025: LD_VAR 0 7
56029: PUSH
56030: LD_INT 2
56032: MUL
56033: ST_TO_ADDR
56034: GO 56062
// if amount > max then
56036: LD_VAR 0 9
56040: PUSH
56041: LD_VAR 0 4
56045: GREATER
56046: IFFALSE 56062
// r := r / 2 ;
56048: LD_ADDR_VAR 0 7
56052: PUSH
56053: LD_VAR 0 7
56057: PUSH
56058: LD_INT 2
56060: DIVREAL
56061: ST_TO_ADDR
// time := time / r ;
56062: LD_ADDR_VAR 0 8
56066: PUSH
56067: LD_VAR 0 8
56071: PUSH
56072: LD_VAR 0 7
56076: DIVREAL
56077: ST_TO_ADDR
// if time < 0 then
56078: LD_VAR 0 8
56082: PUSH
56083: LD_INT 0
56085: LESS
56086: IFFALSE 56103
// time := time * - 1 ;
56088: LD_ADDR_VAR 0 8
56092: PUSH
56093: LD_VAR 0 8
56097: PUSH
56098: LD_INT 1
56100: NEG
56101: MUL
56102: ST_TO_ADDR
// wait ( time ) ;
56103: LD_VAR 0 8
56107: PPUSH
56108: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56112: LD_INT 35
56114: PPUSH
56115: LD_INT 875
56117: PPUSH
56118: CALL_OW 12
56122: PPUSH
56123: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56127: LD_INT 1
56129: PPUSH
56130: LD_INT 5
56132: PPUSH
56133: CALL_OW 12
56137: PPUSH
56138: LD_VAR 0 1
56142: PPUSH
56143: LD_INT 1
56145: PPUSH
56146: CALL_OW 55
// end ;
56150: GO 55960
// end ;
56152: LD_VAR 0 5
56156: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56157: LD_INT 0
56159: PPUSH
56160: PPUSH
56161: PPUSH
56162: PPUSH
56163: PPUSH
56164: PPUSH
56165: PPUSH
56166: PPUSH
// if not turrets or not factories then
56167: LD_VAR 0 1
56171: NOT
56172: PUSH
56173: LD_VAR 0 2
56177: NOT
56178: OR
56179: IFFALSE 56183
// exit ;
56181: GO 56490
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56183: LD_ADDR_VAR 0 10
56187: PUSH
56188: LD_INT 5
56190: PUSH
56191: LD_INT 6
56193: PUSH
56194: EMPTY
56195: LIST
56196: LIST
56197: PUSH
56198: LD_INT 2
56200: PUSH
56201: LD_INT 4
56203: PUSH
56204: EMPTY
56205: LIST
56206: LIST
56207: PUSH
56208: LD_INT 3
56210: PUSH
56211: LD_INT 5
56213: PUSH
56214: EMPTY
56215: LIST
56216: LIST
56217: PUSH
56218: EMPTY
56219: LIST
56220: LIST
56221: LIST
56222: PUSH
56223: LD_INT 24
56225: PUSH
56226: LD_INT 25
56228: PUSH
56229: EMPTY
56230: LIST
56231: LIST
56232: PUSH
56233: LD_INT 23
56235: PUSH
56236: LD_INT 27
56238: PUSH
56239: EMPTY
56240: LIST
56241: LIST
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: PUSH
56247: LD_INT 42
56249: PUSH
56250: LD_INT 43
56252: PUSH
56253: EMPTY
56254: LIST
56255: LIST
56256: PUSH
56257: LD_INT 44
56259: PUSH
56260: LD_INT 46
56262: PUSH
56263: EMPTY
56264: LIST
56265: LIST
56266: PUSH
56267: LD_INT 45
56269: PUSH
56270: LD_INT 47
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: PUSH
56277: EMPTY
56278: LIST
56279: LIST
56280: LIST
56281: PUSH
56282: EMPTY
56283: LIST
56284: LIST
56285: LIST
56286: ST_TO_ADDR
// result := [ ] ;
56287: LD_ADDR_VAR 0 3
56291: PUSH
56292: EMPTY
56293: ST_TO_ADDR
// for i in turrets do
56294: LD_ADDR_VAR 0 4
56298: PUSH
56299: LD_VAR 0 1
56303: PUSH
56304: FOR_IN
56305: IFFALSE 56488
// begin nat := GetNation ( i ) ;
56307: LD_ADDR_VAR 0 7
56311: PUSH
56312: LD_VAR 0 4
56316: PPUSH
56317: CALL_OW 248
56321: ST_TO_ADDR
// weapon := 0 ;
56322: LD_ADDR_VAR 0 8
56326: PUSH
56327: LD_INT 0
56329: ST_TO_ADDR
// if not nat then
56330: LD_VAR 0 7
56334: NOT
56335: IFFALSE 56339
// continue ;
56337: GO 56304
// for j in list [ nat ] do
56339: LD_ADDR_VAR 0 5
56343: PUSH
56344: LD_VAR 0 10
56348: PUSH
56349: LD_VAR 0 7
56353: ARRAY
56354: PUSH
56355: FOR_IN
56356: IFFALSE 56397
// if GetBWeapon ( i ) = j [ 1 ] then
56358: LD_VAR 0 4
56362: PPUSH
56363: CALL_OW 269
56367: PUSH
56368: LD_VAR 0 5
56372: PUSH
56373: LD_INT 1
56375: ARRAY
56376: EQUAL
56377: IFFALSE 56395
// begin weapon := j [ 2 ] ;
56379: LD_ADDR_VAR 0 8
56383: PUSH
56384: LD_VAR 0 5
56388: PUSH
56389: LD_INT 2
56391: ARRAY
56392: ST_TO_ADDR
// break ;
56393: GO 56397
// end ;
56395: GO 56355
56397: POP
56398: POP
// if not weapon then
56399: LD_VAR 0 8
56403: NOT
56404: IFFALSE 56408
// continue ;
56406: GO 56304
// for k in factories do
56408: LD_ADDR_VAR 0 6
56412: PUSH
56413: LD_VAR 0 2
56417: PUSH
56418: FOR_IN
56419: IFFALSE 56484
// begin weapons := AvailableWeaponList ( k ) ;
56421: LD_ADDR_VAR 0 9
56425: PUSH
56426: LD_VAR 0 6
56430: PPUSH
56431: CALL_OW 478
56435: ST_TO_ADDR
// if not weapons then
56436: LD_VAR 0 9
56440: NOT
56441: IFFALSE 56445
// continue ;
56443: GO 56418
// if weapon in weapons then
56445: LD_VAR 0 8
56449: PUSH
56450: LD_VAR 0 9
56454: IN
56455: IFFALSE 56482
// begin result := [ i , weapon ] ;
56457: LD_ADDR_VAR 0 3
56461: PUSH
56462: LD_VAR 0 4
56466: PUSH
56467: LD_VAR 0 8
56471: PUSH
56472: EMPTY
56473: LIST
56474: LIST
56475: ST_TO_ADDR
// exit ;
56476: POP
56477: POP
56478: POP
56479: POP
56480: GO 56490
// end ; end ;
56482: GO 56418
56484: POP
56485: POP
// end ;
56486: GO 56304
56488: POP
56489: POP
// end ;
56490: LD_VAR 0 3
56494: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56495: LD_INT 0
56497: PPUSH
// if not side or side > 8 then
56498: LD_VAR 0 3
56502: NOT
56503: PUSH
56504: LD_VAR 0 3
56508: PUSH
56509: LD_INT 8
56511: GREATER
56512: OR
56513: IFFALSE 56517
// exit ;
56515: GO 56576
// if not range then
56517: LD_VAR 0 4
56521: NOT
56522: IFFALSE 56533
// range := - 12 ;
56524: LD_ADDR_VAR 0 4
56528: PUSH
56529: LD_INT 12
56531: NEG
56532: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56533: LD_VAR 0 1
56537: PPUSH
56538: LD_VAR 0 2
56542: PPUSH
56543: LD_VAR 0 3
56547: PPUSH
56548: LD_VAR 0 4
56552: PPUSH
56553: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56557: LD_VAR 0 1
56561: PPUSH
56562: LD_VAR 0 2
56566: PPUSH
56567: LD_VAR 0 3
56571: PPUSH
56572: CALL_OW 331
// end ;
56576: LD_VAR 0 5
56580: RET
// export function Video ( mode ) ; begin
56581: LD_INT 0
56583: PPUSH
// ingame_video = mode ;
56584: LD_ADDR_OWVAR 52
56588: PUSH
56589: LD_VAR 0 1
56593: ST_TO_ADDR
// interface_hidden = mode ;
56594: LD_ADDR_OWVAR 54
56598: PUSH
56599: LD_VAR 0 1
56603: ST_TO_ADDR
// end ;
56604: LD_VAR 0 2
56608: RET
// export function Join ( array , element ) ; begin
56609: LD_INT 0
56611: PPUSH
// result := Replace ( array , array + 1 , element ) ;
56612: LD_ADDR_VAR 0 3
56616: PUSH
56617: LD_VAR 0 1
56621: PPUSH
56622: LD_VAR 0 1
56626: PUSH
56627: LD_INT 1
56629: PLUS
56630: PPUSH
56631: LD_VAR 0 2
56635: PPUSH
56636: CALL_OW 1
56640: ST_TO_ADDR
// end ;
56641: LD_VAR 0 3
56645: RET
// export function JoinUnion ( array , element ) ; begin
56646: LD_INT 0
56648: PPUSH
// result := array union element ;
56649: LD_ADDR_VAR 0 3
56653: PUSH
56654: LD_VAR 0 1
56658: PUSH
56659: LD_VAR 0 2
56663: UNION
56664: ST_TO_ADDR
// end ;
56665: LD_VAR 0 3
56669: RET
// export function GetBehemoths ( side ) ; begin
56670: LD_INT 0
56672: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56673: LD_ADDR_VAR 0 2
56677: PUSH
56678: LD_INT 22
56680: PUSH
56681: LD_VAR 0 1
56685: PUSH
56686: EMPTY
56687: LIST
56688: LIST
56689: PUSH
56690: LD_INT 31
56692: PUSH
56693: LD_INT 25
56695: PUSH
56696: EMPTY
56697: LIST
56698: LIST
56699: PUSH
56700: EMPTY
56701: LIST
56702: LIST
56703: PPUSH
56704: CALL_OW 69
56708: ST_TO_ADDR
// end ;
56709: LD_VAR 0 2
56713: RET
// export function Shuffle ( array ) ; var i , index ; begin
56714: LD_INT 0
56716: PPUSH
56717: PPUSH
56718: PPUSH
// result := [ ] ;
56719: LD_ADDR_VAR 0 2
56723: PUSH
56724: EMPTY
56725: ST_TO_ADDR
// if not array then
56726: LD_VAR 0 1
56730: NOT
56731: IFFALSE 56735
// exit ;
56733: GO 56834
// Randomize ;
56735: CALL_OW 10
// for i = array downto 1 do
56739: LD_ADDR_VAR 0 3
56743: PUSH
56744: DOUBLE
56745: LD_VAR 0 1
56749: INC
56750: ST_TO_ADDR
56751: LD_INT 1
56753: PUSH
56754: FOR_DOWNTO
56755: IFFALSE 56832
// begin index := rand ( 1 , array ) ;
56757: LD_ADDR_VAR 0 4
56761: PUSH
56762: LD_INT 1
56764: PPUSH
56765: LD_VAR 0 1
56769: PPUSH
56770: CALL_OW 12
56774: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56775: LD_ADDR_VAR 0 2
56779: PUSH
56780: LD_VAR 0 2
56784: PPUSH
56785: LD_VAR 0 2
56789: PUSH
56790: LD_INT 1
56792: PLUS
56793: PPUSH
56794: LD_VAR 0 1
56798: PUSH
56799: LD_VAR 0 4
56803: ARRAY
56804: PPUSH
56805: CALL_OW 2
56809: ST_TO_ADDR
// array := Delete ( array , index ) ;
56810: LD_ADDR_VAR 0 1
56814: PUSH
56815: LD_VAR 0 1
56819: PPUSH
56820: LD_VAR 0 4
56824: PPUSH
56825: CALL_OW 3
56829: ST_TO_ADDR
// end ;
56830: GO 56754
56832: POP
56833: POP
// end ;
56834: LD_VAR 0 2
56838: RET
// export function GetBaseMaterials ( base ) ; begin
56839: LD_INT 0
56841: PPUSH
// result := [ 0 , 0 , 0 ] ;
56842: LD_ADDR_VAR 0 2
56846: PUSH
56847: LD_INT 0
56849: PUSH
56850: LD_INT 0
56852: PUSH
56853: LD_INT 0
56855: PUSH
56856: EMPTY
56857: LIST
56858: LIST
56859: LIST
56860: ST_TO_ADDR
// if not base then
56861: LD_VAR 0 1
56865: NOT
56866: IFFALSE 56870
// exit ;
56868: GO 56919
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56870: LD_ADDR_VAR 0 2
56874: PUSH
56875: LD_VAR 0 1
56879: PPUSH
56880: LD_INT 1
56882: PPUSH
56883: CALL_OW 275
56887: PUSH
56888: LD_VAR 0 1
56892: PPUSH
56893: LD_INT 2
56895: PPUSH
56896: CALL_OW 275
56900: PUSH
56901: LD_VAR 0 1
56905: PPUSH
56906: LD_INT 3
56908: PPUSH
56909: CALL_OW 275
56913: PUSH
56914: EMPTY
56915: LIST
56916: LIST
56917: LIST
56918: ST_TO_ADDR
// end ;
56919: LD_VAR 0 2
56923: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
56924: LD_INT 0
56926: PPUSH
56927: PPUSH
// result := array ;
56928: LD_ADDR_VAR 0 3
56932: PUSH
56933: LD_VAR 0 1
56937: ST_TO_ADDR
// if size > 0 then
56938: LD_VAR 0 2
56942: PUSH
56943: LD_INT 0
56945: GREATER
56946: IFFALSE 56992
// for i := array downto size do
56948: LD_ADDR_VAR 0 4
56952: PUSH
56953: DOUBLE
56954: LD_VAR 0 1
56958: INC
56959: ST_TO_ADDR
56960: LD_VAR 0 2
56964: PUSH
56965: FOR_DOWNTO
56966: IFFALSE 56990
// result := Delete ( result , result ) ;
56968: LD_ADDR_VAR 0 3
56972: PUSH
56973: LD_VAR 0 3
56977: PPUSH
56978: LD_VAR 0 3
56982: PPUSH
56983: CALL_OW 3
56987: ST_TO_ADDR
56988: GO 56965
56990: POP
56991: POP
// end ;
56992: LD_VAR 0 3
56996: RET
// export function ComExit ( unit ) ; var tmp ; begin
56997: LD_INT 0
56999: PPUSH
57000: PPUSH
// if not IsInUnit ( unit ) then
57001: LD_VAR 0 1
57005: PPUSH
57006: CALL_OW 310
57010: NOT
57011: IFFALSE 57015
// exit ;
57013: GO 57075
// tmp := IsInUnit ( unit ) ;
57015: LD_ADDR_VAR 0 3
57019: PUSH
57020: LD_VAR 0 1
57024: PPUSH
57025: CALL_OW 310
57029: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57030: LD_VAR 0 3
57034: PPUSH
57035: CALL_OW 247
57039: PUSH
57040: LD_INT 2
57042: EQUAL
57043: IFFALSE 57056
// ComExitVehicle ( unit ) else
57045: LD_VAR 0 1
57049: PPUSH
57050: CALL_OW 121
57054: GO 57065
// ComExitBuilding ( unit ) ;
57056: LD_VAR 0 1
57060: PPUSH
57061: CALL_OW 122
// result := tmp ;
57065: LD_ADDR_VAR 0 2
57069: PUSH
57070: LD_VAR 0 3
57074: ST_TO_ADDR
// end ;
57075: LD_VAR 0 2
57079: RET
// export function ComExitAll ( units ) ; var i ; begin
57080: LD_INT 0
57082: PPUSH
57083: PPUSH
// if not units then
57084: LD_VAR 0 1
57088: NOT
57089: IFFALSE 57093
// exit ;
57091: GO 57119
// for i in units do
57093: LD_ADDR_VAR 0 3
57097: PUSH
57098: LD_VAR 0 1
57102: PUSH
57103: FOR_IN
57104: IFFALSE 57117
// ComExit ( i ) ;
57106: LD_VAR 0 3
57110: PPUSH
57111: CALL 56997 0 1
57115: GO 57103
57117: POP
57118: POP
// end ;
57119: LD_VAR 0 2
57123: RET
// export function ResetHc ; begin
57124: LD_INT 0
57126: PPUSH
// InitHc ;
57127: CALL_OW 19
// hc_importance := 0 ;
57131: LD_ADDR_OWVAR 32
57135: PUSH
57136: LD_INT 0
57138: ST_TO_ADDR
// end ;
57139: LD_VAR 0 1
57143: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57144: LD_INT 0
57146: PPUSH
57147: PPUSH
57148: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57149: LD_ADDR_VAR 0 6
57153: PUSH
57154: LD_VAR 0 1
57158: PUSH
57159: LD_VAR 0 3
57163: PLUS
57164: PUSH
57165: LD_INT 2
57167: DIV
57168: ST_TO_ADDR
// if _x < 0 then
57169: LD_VAR 0 6
57173: PUSH
57174: LD_INT 0
57176: LESS
57177: IFFALSE 57194
// _x := _x * - 1 ;
57179: LD_ADDR_VAR 0 6
57183: PUSH
57184: LD_VAR 0 6
57188: PUSH
57189: LD_INT 1
57191: NEG
57192: MUL
57193: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57194: LD_ADDR_VAR 0 7
57198: PUSH
57199: LD_VAR 0 2
57203: PUSH
57204: LD_VAR 0 4
57208: PLUS
57209: PUSH
57210: LD_INT 2
57212: DIV
57213: ST_TO_ADDR
// if _y < 0 then
57214: LD_VAR 0 7
57218: PUSH
57219: LD_INT 0
57221: LESS
57222: IFFALSE 57239
// _y := _y * - 1 ;
57224: LD_ADDR_VAR 0 7
57228: PUSH
57229: LD_VAR 0 7
57233: PUSH
57234: LD_INT 1
57236: NEG
57237: MUL
57238: ST_TO_ADDR
// result := [ _x , _y ] ;
57239: LD_ADDR_VAR 0 5
57243: PUSH
57244: LD_VAR 0 6
57248: PUSH
57249: LD_VAR 0 7
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: ST_TO_ADDR
// end ;
57258: LD_VAR 0 5
57262: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57263: LD_INT 0
57265: PPUSH
57266: PPUSH
57267: PPUSH
57268: PPUSH
// task := GetTaskList ( unit ) ;
57269: LD_ADDR_VAR 0 7
57273: PUSH
57274: LD_VAR 0 1
57278: PPUSH
57279: CALL_OW 437
57283: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57284: LD_VAR 0 7
57288: NOT
57289: PUSH
57290: LD_VAR 0 1
57294: PPUSH
57295: LD_VAR 0 2
57299: PPUSH
57300: CALL_OW 308
57304: NOT
57305: AND
57306: IFFALSE 57310
// exit ;
57308: GO 57428
// if IsInArea ( unit , area ) then
57310: LD_VAR 0 1
57314: PPUSH
57315: LD_VAR 0 2
57319: PPUSH
57320: CALL_OW 308
57324: IFFALSE 57342
// begin ComMoveToArea ( unit , goAway ) ;
57326: LD_VAR 0 1
57330: PPUSH
57331: LD_VAR 0 3
57335: PPUSH
57336: CALL_OW 113
// exit ;
57340: GO 57428
// end ; if task [ 1 ] [ 1 ] <> M then
57342: LD_VAR 0 7
57346: PUSH
57347: LD_INT 1
57349: ARRAY
57350: PUSH
57351: LD_INT 1
57353: ARRAY
57354: PUSH
57355: LD_STRING M
57357: NONEQUAL
57358: IFFALSE 57362
// exit ;
57360: GO 57428
// x := task [ 1 ] [ 2 ] ;
57362: LD_ADDR_VAR 0 5
57366: PUSH
57367: LD_VAR 0 7
57371: PUSH
57372: LD_INT 1
57374: ARRAY
57375: PUSH
57376: LD_INT 2
57378: ARRAY
57379: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
57380: LD_ADDR_VAR 0 6
57384: PUSH
57385: LD_VAR 0 7
57389: PUSH
57390: LD_INT 1
57392: ARRAY
57393: PUSH
57394: LD_INT 3
57396: ARRAY
57397: ST_TO_ADDR
// if InArea ( x , y , area ) then
57398: LD_VAR 0 5
57402: PPUSH
57403: LD_VAR 0 6
57407: PPUSH
57408: LD_VAR 0 2
57412: PPUSH
57413: CALL_OW 309
57417: IFFALSE 57428
// ComStop ( unit ) ;
57419: LD_VAR 0 1
57423: PPUSH
57424: CALL_OW 141
// end ;
57428: LD_VAR 0 4
57432: RET
// export function Abs ( value ) ; begin
57433: LD_INT 0
57435: PPUSH
// result := value ;
57436: LD_ADDR_VAR 0 2
57440: PUSH
57441: LD_VAR 0 1
57445: ST_TO_ADDR
// if value < 0 then
57446: LD_VAR 0 1
57450: PUSH
57451: LD_INT 0
57453: LESS
57454: IFFALSE 57471
// result := value * - 1 ;
57456: LD_ADDR_VAR 0 2
57460: PUSH
57461: LD_VAR 0 1
57465: PUSH
57466: LD_INT 1
57468: NEG
57469: MUL
57470: ST_TO_ADDR
// end ;
57471: LD_VAR 0 2
57475: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
57476: LD_INT 0
57478: PPUSH
57479: PPUSH
57480: PPUSH
57481: PPUSH
57482: PPUSH
57483: PPUSH
57484: PPUSH
57485: PPUSH
// if not unit or not building then
57486: LD_VAR 0 1
57490: NOT
57491: PUSH
57492: LD_VAR 0 2
57496: NOT
57497: OR
57498: IFFALSE 57502
// exit ;
57500: GO 57728
// x := GetX ( building ) ;
57502: LD_ADDR_VAR 0 4
57506: PUSH
57507: LD_VAR 0 2
57511: PPUSH
57512: CALL_OW 250
57516: ST_TO_ADDR
// y := GetY ( building ) ;
57517: LD_ADDR_VAR 0 6
57521: PUSH
57522: LD_VAR 0 2
57526: PPUSH
57527: CALL_OW 251
57531: ST_TO_ADDR
// d := GetDir ( building ) ;
57532: LD_ADDR_VAR 0 8
57536: PUSH
57537: LD_VAR 0 2
57541: PPUSH
57542: CALL_OW 254
57546: ST_TO_ADDR
// r := 4 ;
57547: LD_ADDR_VAR 0 9
57551: PUSH
57552: LD_INT 4
57554: ST_TO_ADDR
// for i := 1 to 5 do
57555: LD_ADDR_VAR 0 10
57559: PUSH
57560: DOUBLE
57561: LD_INT 1
57563: DEC
57564: ST_TO_ADDR
57565: LD_INT 5
57567: PUSH
57568: FOR_TO
57569: IFFALSE 57726
// begin _x := ShiftX ( x , d , r + i ) ;
57571: LD_ADDR_VAR 0 5
57575: PUSH
57576: LD_VAR 0 4
57580: PPUSH
57581: LD_VAR 0 8
57585: PPUSH
57586: LD_VAR 0 9
57590: PUSH
57591: LD_VAR 0 10
57595: PLUS
57596: PPUSH
57597: CALL_OW 272
57601: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
57602: LD_ADDR_VAR 0 7
57606: PUSH
57607: LD_VAR 0 6
57611: PPUSH
57612: LD_VAR 0 8
57616: PPUSH
57617: LD_VAR 0 9
57621: PUSH
57622: LD_VAR 0 10
57626: PLUS
57627: PPUSH
57628: CALL_OW 273
57632: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
57633: LD_VAR 0 5
57637: PPUSH
57638: LD_VAR 0 7
57642: PPUSH
57643: CALL_OW 488
57647: PUSH
57648: LD_VAR 0 5
57652: PPUSH
57653: LD_VAR 0 7
57657: PPUSH
57658: CALL_OW 428
57662: PPUSH
57663: CALL_OW 247
57667: PUSH
57668: LD_INT 3
57670: PUSH
57671: LD_INT 2
57673: PUSH
57674: EMPTY
57675: LIST
57676: LIST
57677: IN
57678: NOT
57679: AND
57680: IFFALSE 57724
// begin ComMoveXY ( unit , _x , _y ) ;
57682: LD_VAR 0 1
57686: PPUSH
57687: LD_VAR 0 5
57691: PPUSH
57692: LD_VAR 0 7
57696: PPUSH
57697: CALL_OW 111
// result := [ _x , _y ] ;
57701: LD_ADDR_VAR 0 3
57705: PUSH
57706: LD_VAR 0 5
57710: PUSH
57711: LD_VAR 0 7
57715: PUSH
57716: EMPTY
57717: LIST
57718: LIST
57719: ST_TO_ADDR
// exit ;
57720: POP
57721: POP
57722: GO 57728
// end ; end ;
57724: GO 57568
57726: POP
57727: POP
// end ;
57728: LD_VAR 0 3
57732: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57733: LD_INT 0
57735: PPUSH
57736: PPUSH
57737: PPUSH
// result := 0 ;
57738: LD_ADDR_VAR 0 3
57742: PUSH
57743: LD_INT 0
57745: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57746: LD_VAR 0 1
57750: PUSH
57751: LD_INT 0
57753: LESS
57754: PUSH
57755: LD_VAR 0 1
57759: PUSH
57760: LD_INT 8
57762: GREATER
57763: OR
57764: PUSH
57765: LD_VAR 0 2
57769: PUSH
57770: LD_INT 0
57772: LESS
57773: OR
57774: PUSH
57775: LD_VAR 0 2
57779: PUSH
57780: LD_INT 8
57782: GREATER
57783: OR
57784: IFFALSE 57788
// exit ;
57786: GO 57863
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57788: LD_ADDR_VAR 0 4
57792: PUSH
57793: LD_INT 22
57795: PUSH
57796: LD_VAR 0 2
57800: PUSH
57801: EMPTY
57802: LIST
57803: LIST
57804: PPUSH
57805: CALL_OW 69
57809: PUSH
57810: FOR_IN
57811: IFFALSE 57861
// begin un := UnitShoot ( i ) ;
57813: LD_ADDR_VAR 0 5
57817: PUSH
57818: LD_VAR 0 4
57822: PPUSH
57823: CALL_OW 504
57827: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57828: LD_VAR 0 5
57832: PPUSH
57833: CALL_OW 255
57837: PUSH
57838: LD_VAR 0 1
57842: EQUAL
57843: IFFALSE 57859
// begin result := un ;
57845: LD_ADDR_VAR 0 3
57849: PUSH
57850: LD_VAR 0 5
57854: ST_TO_ADDR
// exit ;
57855: POP
57856: POP
57857: GO 57863
// end ; end ;
57859: GO 57810
57861: POP
57862: POP
// end ;
57863: LD_VAR 0 3
57867: RET
// export function GetCargoBay ( units ) ; begin
57868: LD_INT 0
57870: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57871: LD_ADDR_VAR 0 2
57875: PUSH
57876: LD_VAR 0 1
57880: PPUSH
57881: LD_INT 2
57883: PUSH
57884: LD_INT 34
57886: PUSH
57887: LD_INT 12
57889: PUSH
57890: EMPTY
57891: LIST
57892: LIST
57893: PUSH
57894: LD_INT 34
57896: PUSH
57897: LD_INT 51
57899: PUSH
57900: EMPTY
57901: LIST
57902: LIST
57903: PUSH
57904: LD_INT 34
57906: PUSH
57907: LD_INT 32
57909: PUSH
57910: EMPTY
57911: LIST
57912: LIST
57913: PUSH
57914: LD_INT 34
57916: PUSH
57917: LD_EXP 30
57921: PUSH
57922: EMPTY
57923: LIST
57924: LIST
57925: PUSH
57926: EMPTY
57927: LIST
57928: LIST
57929: LIST
57930: LIST
57931: LIST
57932: PPUSH
57933: CALL_OW 72
57937: ST_TO_ADDR
// end ;
57938: LD_VAR 0 2
57942: RET
// export function Negate ( value ) ; begin
57943: LD_INT 0
57945: PPUSH
// result := not value ;
57946: LD_ADDR_VAR 0 2
57950: PUSH
57951: LD_VAR 0 1
57955: NOT
57956: ST_TO_ADDR
// end ;
57957: LD_VAR 0 2
57961: RET
// export function Inc ( value ) ; begin
57962: LD_INT 0
57964: PPUSH
// result := value + 1 ;
57965: LD_ADDR_VAR 0 2
57969: PUSH
57970: LD_VAR 0 1
57974: PUSH
57975: LD_INT 1
57977: PLUS
57978: ST_TO_ADDR
// end ;
57979: LD_VAR 0 2
57983: RET
// export function Dec ( value ) ; begin
57984: LD_INT 0
57986: PPUSH
// result := value - 1 ;
57987: LD_ADDR_VAR 0 2
57991: PUSH
57992: LD_VAR 0 1
57996: PUSH
57997: LD_INT 1
57999: MINUS
58000: ST_TO_ADDR
// end ;
58001: LD_VAR 0 2
58005: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58006: LD_INT 0
58008: PPUSH
58009: PPUSH
58010: PPUSH
58011: PPUSH
58012: PPUSH
58013: PPUSH
58014: PPUSH
58015: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58016: LD_VAR 0 1
58020: PPUSH
58021: LD_VAR 0 2
58025: PPUSH
58026: CALL_OW 488
58030: NOT
58031: PUSH
58032: LD_VAR 0 3
58036: PPUSH
58037: LD_VAR 0 4
58041: PPUSH
58042: CALL_OW 488
58046: NOT
58047: OR
58048: IFFALSE 58061
// begin result := - 1 ;
58050: LD_ADDR_VAR 0 5
58054: PUSH
58055: LD_INT 1
58057: NEG
58058: ST_TO_ADDR
// exit ;
58059: GO 58296
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58061: LD_ADDR_VAR 0 12
58065: PUSH
58066: LD_VAR 0 1
58070: PPUSH
58071: LD_VAR 0 2
58075: PPUSH
58076: LD_VAR 0 3
58080: PPUSH
58081: LD_VAR 0 4
58085: PPUSH
58086: CALL 57144 0 4
58090: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58091: LD_ADDR_VAR 0 11
58095: PUSH
58096: LD_VAR 0 1
58100: PPUSH
58101: LD_VAR 0 2
58105: PPUSH
58106: LD_VAR 0 12
58110: PUSH
58111: LD_INT 1
58113: ARRAY
58114: PPUSH
58115: LD_VAR 0 12
58119: PUSH
58120: LD_INT 2
58122: ARRAY
58123: PPUSH
58124: CALL_OW 298
58128: ST_TO_ADDR
// distance := 9999 ;
58129: LD_ADDR_VAR 0 10
58133: PUSH
58134: LD_INT 9999
58136: ST_TO_ADDR
// for i := 0 to 5 do
58137: LD_ADDR_VAR 0 6
58141: PUSH
58142: DOUBLE
58143: LD_INT 0
58145: DEC
58146: ST_TO_ADDR
58147: LD_INT 5
58149: PUSH
58150: FOR_TO
58151: IFFALSE 58294
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58153: LD_ADDR_VAR 0 7
58157: PUSH
58158: LD_VAR 0 1
58162: PPUSH
58163: LD_VAR 0 6
58167: PPUSH
58168: LD_VAR 0 11
58172: PPUSH
58173: CALL_OW 272
58177: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58178: LD_ADDR_VAR 0 8
58182: PUSH
58183: LD_VAR 0 2
58187: PPUSH
58188: LD_VAR 0 6
58192: PPUSH
58193: LD_VAR 0 11
58197: PPUSH
58198: CALL_OW 273
58202: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58203: LD_VAR 0 7
58207: PPUSH
58208: LD_VAR 0 8
58212: PPUSH
58213: CALL_OW 488
58217: NOT
58218: IFFALSE 58222
// continue ;
58220: GO 58150
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58222: LD_ADDR_VAR 0 9
58226: PUSH
58227: LD_VAR 0 12
58231: PUSH
58232: LD_INT 1
58234: ARRAY
58235: PPUSH
58236: LD_VAR 0 12
58240: PUSH
58241: LD_INT 2
58243: ARRAY
58244: PPUSH
58245: LD_VAR 0 7
58249: PPUSH
58250: LD_VAR 0 8
58254: PPUSH
58255: CALL_OW 298
58259: ST_TO_ADDR
// if tmp < distance then
58260: LD_VAR 0 9
58264: PUSH
58265: LD_VAR 0 10
58269: LESS
58270: IFFALSE 58292
// begin result := i ;
58272: LD_ADDR_VAR 0 5
58276: PUSH
58277: LD_VAR 0 6
58281: ST_TO_ADDR
// distance := tmp ;
58282: LD_ADDR_VAR 0 10
58286: PUSH
58287: LD_VAR 0 9
58291: ST_TO_ADDR
// end ; end ;
58292: GO 58150
58294: POP
58295: POP
// end ;
58296: LD_VAR 0 5
58300: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58301: LD_INT 0
58303: PPUSH
58304: PPUSH
// if not driver or not IsInUnit ( driver ) then
58305: LD_VAR 0 1
58309: NOT
58310: PUSH
58311: LD_VAR 0 1
58315: PPUSH
58316: CALL_OW 310
58320: NOT
58321: OR
58322: IFFALSE 58326
// exit ;
58324: GO 58416
// vehicle := IsInUnit ( driver ) ;
58326: LD_ADDR_VAR 0 3
58330: PUSH
58331: LD_VAR 0 1
58335: PPUSH
58336: CALL_OW 310
58340: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58341: LD_VAR 0 1
58345: PPUSH
58346: LD_STRING \
58348: PUSH
58349: LD_INT 0
58351: PUSH
58352: LD_INT 0
58354: PUSH
58355: LD_INT 0
58357: PUSH
58358: LD_INT 0
58360: PUSH
58361: LD_INT 0
58363: PUSH
58364: LD_INT 0
58366: PUSH
58367: EMPTY
58368: LIST
58369: LIST
58370: LIST
58371: LIST
58372: LIST
58373: LIST
58374: LIST
58375: PUSH
58376: LD_STRING E
58378: PUSH
58379: LD_INT 0
58381: PUSH
58382: LD_INT 0
58384: PUSH
58385: LD_VAR 0 3
58389: PUSH
58390: LD_INT 0
58392: PUSH
58393: LD_INT 0
58395: PUSH
58396: LD_INT 0
58398: PUSH
58399: EMPTY
58400: LIST
58401: LIST
58402: LIST
58403: LIST
58404: LIST
58405: LIST
58406: LIST
58407: PUSH
58408: EMPTY
58409: LIST
58410: LIST
58411: PPUSH
58412: CALL_OW 446
// end ;
58416: LD_VAR 0 2
58420: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58421: LD_INT 0
58423: PPUSH
58424: PPUSH
// if not driver or not IsInUnit ( driver ) then
58425: LD_VAR 0 1
58429: NOT
58430: PUSH
58431: LD_VAR 0 1
58435: PPUSH
58436: CALL_OW 310
58440: NOT
58441: OR
58442: IFFALSE 58446
// exit ;
58444: GO 58536
// vehicle := IsInUnit ( driver ) ;
58446: LD_ADDR_VAR 0 3
58450: PUSH
58451: LD_VAR 0 1
58455: PPUSH
58456: CALL_OW 310
58460: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58461: LD_VAR 0 1
58465: PPUSH
58466: LD_STRING \
58468: PUSH
58469: LD_INT 0
58471: PUSH
58472: LD_INT 0
58474: PUSH
58475: LD_INT 0
58477: PUSH
58478: LD_INT 0
58480: PUSH
58481: LD_INT 0
58483: PUSH
58484: LD_INT 0
58486: PUSH
58487: EMPTY
58488: LIST
58489: LIST
58490: LIST
58491: LIST
58492: LIST
58493: LIST
58494: LIST
58495: PUSH
58496: LD_STRING E
58498: PUSH
58499: LD_INT 0
58501: PUSH
58502: LD_INT 0
58504: PUSH
58505: LD_VAR 0 3
58509: PUSH
58510: LD_INT 0
58512: PUSH
58513: LD_INT 0
58515: PUSH
58516: LD_INT 0
58518: PUSH
58519: EMPTY
58520: LIST
58521: LIST
58522: LIST
58523: LIST
58524: LIST
58525: LIST
58526: LIST
58527: PUSH
58528: EMPTY
58529: LIST
58530: LIST
58531: PPUSH
58532: CALL_OW 447
// end ;
58536: LD_VAR 0 2
58540: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
58541: LD_INT 0
58543: PPUSH
58544: PPUSH
58545: PPUSH
// tmp := [ ] ;
58546: LD_ADDR_VAR 0 5
58550: PUSH
58551: EMPTY
58552: ST_TO_ADDR
// for i in units do
58553: LD_ADDR_VAR 0 4
58557: PUSH
58558: LD_VAR 0 1
58562: PUSH
58563: FOR_IN
58564: IFFALSE 58602
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
58566: LD_ADDR_VAR 0 5
58570: PUSH
58571: LD_VAR 0 5
58575: PPUSH
58576: LD_VAR 0 5
58580: PUSH
58581: LD_INT 1
58583: PLUS
58584: PPUSH
58585: LD_VAR 0 4
58589: PPUSH
58590: CALL_OW 256
58594: PPUSH
58595: CALL_OW 2
58599: ST_TO_ADDR
58600: GO 58563
58602: POP
58603: POP
// if not tmp then
58604: LD_VAR 0 5
58608: NOT
58609: IFFALSE 58613
// exit ;
58611: GO 58661
// if asc then
58613: LD_VAR 0 2
58617: IFFALSE 58641
// result := SortListByListAsc ( units , tmp ) else
58619: LD_ADDR_VAR 0 3
58623: PUSH
58624: LD_VAR 0 1
58628: PPUSH
58629: LD_VAR 0 5
58633: PPUSH
58634: CALL_OW 76
58638: ST_TO_ADDR
58639: GO 58661
// result := SortListByListDesc ( units , tmp ) ;
58641: LD_ADDR_VAR 0 3
58645: PUSH
58646: LD_VAR 0 1
58650: PPUSH
58651: LD_VAR 0 5
58655: PPUSH
58656: CALL_OW 77
58660: ST_TO_ADDR
// end ;
58661: LD_VAR 0 3
58665: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
58666: LD_INT 0
58668: PPUSH
58669: PPUSH
// task := GetTaskList ( mech ) ;
58670: LD_ADDR_VAR 0 4
58674: PUSH
58675: LD_VAR 0 1
58679: PPUSH
58680: CALL_OW 437
58684: ST_TO_ADDR
// if not task then
58685: LD_VAR 0 4
58689: NOT
58690: IFFALSE 58694
// exit ;
58692: GO 58736
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
58694: LD_ADDR_VAR 0 3
58698: PUSH
58699: LD_VAR 0 4
58703: PUSH
58704: LD_INT 1
58706: ARRAY
58707: PUSH
58708: LD_INT 1
58710: ARRAY
58711: PUSH
58712: LD_STRING r
58714: EQUAL
58715: PUSH
58716: LD_VAR 0 4
58720: PUSH
58721: LD_INT 1
58723: ARRAY
58724: PUSH
58725: LD_INT 4
58727: ARRAY
58728: PUSH
58729: LD_VAR 0 2
58733: EQUAL
58734: AND
58735: ST_TO_ADDR
// end ;
58736: LD_VAR 0 3
58740: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
58741: LD_INT 0
58743: PPUSH
// SetDir ( unit , d ) ;
58744: LD_VAR 0 1
58748: PPUSH
58749: LD_VAR 0 4
58753: PPUSH
58754: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
58758: LD_VAR 0 1
58762: PPUSH
58763: LD_VAR 0 2
58767: PPUSH
58768: LD_VAR 0 3
58772: PPUSH
58773: LD_VAR 0 5
58777: PPUSH
58778: CALL_OW 48
// end ;
58782: LD_VAR 0 6
58786: RET
// export function ToNaturalNumber ( number ) ; begin
58787: LD_INT 0
58789: PPUSH
// result := number div 1 ;
58790: LD_ADDR_VAR 0 2
58794: PUSH
58795: LD_VAR 0 1
58799: PUSH
58800: LD_INT 1
58802: DIV
58803: ST_TO_ADDR
// if number < 0 then
58804: LD_VAR 0 1
58808: PUSH
58809: LD_INT 0
58811: LESS
58812: IFFALSE 58822
// result := 0 ;
58814: LD_ADDR_VAR 0 2
58818: PUSH
58819: LD_INT 0
58821: ST_TO_ADDR
// end ;
58822: LD_VAR 0 2
58826: RET
// export function SortByClass ( units , class ) ; var un ; begin
58827: LD_INT 0
58829: PPUSH
58830: PPUSH
// if not units or not class then
58831: LD_VAR 0 1
58835: NOT
58836: PUSH
58837: LD_VAR 0 2
58841: NOT
58842: OR
58843: IFFALSE 58847
// exit ;
58845: GO 58942
// result := [ ] ;
58847: LD_ADDR_VAR 0 3
58851: PUSH
58852: EMPTY
58853: ST_TO_ADDR
// for un in units do
58854: LD_ADDR_VAR 0 4
58858: PUSH
58859: LD_VAR 0 1
58863: PUSH
58864: FOR_IN
58865: IFFALSE 58940
// if GetClass ( un ) = class then
58867: LD_VAR 0 4
58871: PPUSH
58872: CALL_OW 257
58876: PUSH
58877: LD_VAR 0 2
58881: EQUAL
58882: IFFALSE 58909
// result := Insert ( result , 1 , un ) else
58884: LD_ADDR_VAR 0 3
58888: PUSH
58889: LD_VAR 0 3
58893: PPUSH
58894: LD_INT 1
58896: PPUSH
58897: LD_VAR 0 4
58901: PPUSH
58902: CALL_OW 2
58906: ST_TO_ADDR
58907: GO 58938
// result := Replace ( result , result + 1 , un ) ;
58909: LD_ADDR_VAR 0 3
58913: PUSH
58914: LD_VAR 0 3
58918: PPUSH
58919: LD_VAR 0 3
58923: PUSH
58924: LD_INT 1
58926: PLUS
58927: PPUSH
58928: LD_VAR 0 4
58932: PPUSH
58933: CALL_OW 1
58937: ST_TO_ADDR
58938: GO 58864
58940: POP
58941: POP
// end ;
58942: LD_VAR 0 3
58946: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58947: LD_INT 0
58949: PPUSH
58950: PPUSH
58951: PPUSH
58952: PPUSH
58953: PPUSH
58954: PPUSH
58955: PPUSH
// result := [ ] ;
58956: LD_ADDR_VAR 0 4
58960: PUSH
58961: EMPTY
58962: ST_TO_ADDR
// if x - r < 0 then
58963: LD_VAR 0 1
58967: PUSH
58968: LD_VAR 0 3
58972: MINUS
58973: PUSH
58974: LD_INT 0
58976: LESS
58977: IFFALSE 58989
// min_x := 0 else
58979: LD_ADDR_VAR 0 8
58983: PUSH
58984: LD_INT 0
58986: ST_TO_ADDR
58987: GO 59005
// min_x := x - r ;
58989: LD_ADDR_VAR 0 8
58993: PUSH
58994: LD_VAR 0 1
58998: PUSH
58999: LD_VAR 0 3
59003: MINUS
59004: ST_TO_ADDR
// if y - r < 0 then
59005: LD_VAR 0 2
59009: PUSH
59010: LD_VAR 0 3
59014: MINUS
59015: PUSH
59016: LD_INT 0
59018: LESS
59019: IFFALSE 59031
// min_y := 0 else
59021: LD_ADDR_VAR 0 7
59025: PUSH
59026: LD_INT 0
59028: ST_TO_ADDR
59029: GO 59047
// min_y := y - r ;
59031: LD_ADDR_VAR 0 7
59035: PUSH
59036: LD_VAR 0 2
59040: PUSH
59041: LD_VAR 0 3
59045: MINUS
59046: ST_TO_ADDR
// max_x := x + r ;
59047: LD_ADDR_VAR 0 9
59051: PUSH
59052: LD_VAR 0 1
59056: PUSH
59057: LD_VAR 0 3
59061: PLUS
59062: ST_TO_ADDR
// max_y := y + r ;
59063: LD_ADDR_VAR 0 10
59067: PUSH
59068: LD_VAR 0 2
59072: PUSH
59073: LD_VAR 0 3
59077: PLUS
59078: ST_TO_ADDR
// for _x = min_x to max_x do
59079: LD_ADDR_VAR 0 5
59083: PUSH
59084: DOUBLE
59085: LD_VAR 0 8
59089: DEC
59090: ST_TO_ADDR
59091: LD_VAR 0 9
59095: PUSH
59096: FOR_TO
59097: IFFALSE 59198
// for _y = min_y to max_y do
59099: LD_ADDR_VAR 0 6
59103: PUSH
59104: DOUBLE
59105: LD_VAR 0 7
59109: DEC
59110: ST_TO_ADDR
59111: LD_VAR 0 10
59115: PUSH
59116: FOR_TO
59117: IFFALSE 59194
// begin if not ValidHex ( _x , _y ) then
59119: LD_VAR 0 5
59123: PPUSH
59124: LD_VAR 0 6
59128: PPUSH
59129: CALL_OW 488
59133: NOT
59134: IFFALSE 59138
// continue ;
59136: GO 59116
// if GetResourceTypeXY ( _x , _y ) then
59138: LD_VAR 0 5
59142: PPUSH
59143: LD_VAR 0 6
59147: PPUSH
59148: CALL_OW 283
59152: IFFALSE 59192
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59154: LD_ADDR_VAR 0 4
59158: PUSH
59159: LD_VAR 0 4
59163: PPUSH
59164: LD_VAR 0 4
59168: PUSH
59169: LD_INT 1
59171: PLUS
59172: PPUSH
59173: LD_VAR 0 5
59177: PUSH
59178: LD_VAR 0 6
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: PPUSH
59187: CALL_OW 1
59191: ST_TO_ADDR
// end ;
59192: GO 59116
59194: POP
59195: POP
59196: GO 59096
59198: POP
59199: POP
// end ;
59200: LD_VAR 0 4
59204: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59205: LD_INT 0
59207: PPUSH
59208: PPUSH
59209: PPUSH
59210: PPUSH
59211: PPUSH
59212: PPUSH
59213: PPUSH
59214: PPUSH
// if not units then
59215: LD_VAR 0 1
59219: NOT
59220: IFFALSE 59224
// exit ;
59222: GO 59649
// result := UnitFilter ( units , [ f_ok ] ) ;
59224: LD_ADDR_VAR 0 3
59228: PUSH
59229: LD_VAR 0 1
59233: PPUSH
59234: LD_INT 50
59236: PUSH
59237: EMPTY
59238: LIST
59239: PPUSH
59240: CALL_OW 72
59244: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59245: LD_ADDR_VAR 0 8
59249: PUSH
59250: LD_VAR 0 1
59254: PUSH
59255: LD_INT 1
59257: ARRAY
59258: PPUSH
59259: CALL_OW 255
59263: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
59264: LD_ADDR_VAR 0 10
59268: PUSH
59269: LD_INT 29
59271: PUSH
59272: LD_EXP 33
59276: PUSH
59277: EMPTY
59278: LIST
59279: LIST
59280: ST_TO_ADDR
// if not result then
59281: LD_VAR 0 3
59285: NOT
59286: IFFALSE 59290
// exit ;
59288: GO 59649
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59290: LD_ADDR_VAR 0 5
59294: PUSH
59295: LD_INT 81
59297: PUSH
59298: LD_VAR 0 8
59302: PUSH
59303: EMPTY
59304: LIST
59305: LIST
59306: PPUSH
59307: CALL_OW 69
59311: ST_TO_ADDR
// for i in result do
59312: LD_ADDR_VAR 0 4
59316: PUSH
59317: LD_VAR 0 3
59321: PUSH
59322: FOR_IN
59323: IFFALSE 59647
// begin tag := GetTag ( i ) + 1 ;
59325: LD_ADDR_VAR 0 9
59329: PUSH
59330: LD_VAR 0 4
59334: PPUSH
59335: CALL_OW 110
59339: PUSH
59340: LD_INT 1
59342: PLUS
59343: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
59344: LD_ADDR_VAR 0 7
59348: PUSH
59349: LD_VAR 0 4
59353: PPUSH
59354: CALL_OW 250
59358: PPUSH
59359: LD_VAR 0 4
59363: PPUSH
59364: CALL_OW 251
59368: PPUSH
59369: LD_INT 6
59371: PPUSH
59372: CALL 58947 0 3
59376: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
59377: LD_VAR 0 7
59381: PUSH
59382: LD_VAR 0 4
59386: PPUSH
59387: CALL_OW 264
59391: PUSH
59392: LD_VAR 0 10
59396: IN
59397: NOT
59398: AND
59399: IFFALSE 59438
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
59401: LD_VAR 0 4
59405: PPUSH
59406: LD_VAR 0 7
59410: PUSH
59411: LD_INT 1
59413: ARRAY
59414: PUSH
59415: LD_INT 1
59417: ARRAY
59418: PPUSH
59419: LD_VAR 0 7
59423: PUSH
59424: LD_INT 1
59426: ARRAY
59427: PUSH
59428: LD_INT 2
59430: ARRAY
59431: PPUSH
59432: CALL_OW 116
59436: GO 59645
// if path > tag then
59438: LD_VAR 0 2
59442: PUSH
59443: LD_VAR 0 9
59447: GREATER
59448: IFFALSE 59615
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
59450: LD_ADDR_VAR 0 6
59454: PUSH
59455: LD_VAR 0 5
59459: PPUSH
59460: LD_INT 91
59462: PUSH
59463: LD_VAR 0 4
59467: PUSH
59468: LD_INT 12
59470: PUSH
59471: EMPTY
59472: LIST
59473: LIST
59474: LIST
59475: PPUSH
59476: CALL_OW 72
59480: ST_TO_ADDR
// if nearEnemy then
59481: LD_VAR 0 6
59485: IFFALSE 59513
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
59487: LD_VAR 0 4
59491: PPUSH
59492: LD_VAR 0 6
59496: PPUSH
59497: LD_VAR 0 4
59501: PPUSH
59502: CALL_OW 74
59506: PPUSH
59507: CALL_OW 115
59511: GO 59613
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
59513: LD_VAR 0 4
59517: PPUSH
59518: LD_VAR 0 2
59522: PUSH
59523: LD_VAR 0 9
59527: ARRAY
59528: PUSH
59529: LD_INT 1
59531: ARRAY
59532: PPUSH
59533: LD_VAR 0 2
59537: PUSH
59538: LD_VAR 0 9
59542: ARRAY
59543: PUSH
59544: LD_INT 2
59546: ARRAY
59547: PPUSH
59548: CALL_OW 297
59552: PUSH
59553: LD_INT 6
59555: GREATER
59556: IFFALSE 59599
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
59558: LD_VAR 0 4
59562: PPUSH
59563: LD_VAR 0 2
59567: PUSH
59568: LD_VAR 0 9
59572: ARRAY
59573: PUSH
59574: LD_INT 1
59576: ARRAY
59577: PPUSH
59578: LD_VAR 0 2
59582: PUSH
59583: LD_VAR 0 9
59587: ARRAY
59588: PUSH
59589: LD_INT 2
59591: ARRAY
59592: PPUSH
59593: CALL_OW 114
59597: GO 59613
// SetTag ( i , tag ) ;
59599: LD_VAR 0 4
59603: PPUSH
59604: LD_VAR 0 9
59608: PPUSH
59609: CALL_OW 109
// end else
59613: GO 59645
// if enemy then
59615: LD_VAR 0 5
59619: IFFALSE 59645
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
59621: LD_VAR 0 4
59625: PPUSH
59626: LD_VAR 0 5
59630: PPUSH
59631: LD_VAR 0 4
59635: PPUSH
59636: CALL_OW 74
59640: PPUSH
59641: CALL_OW 115
// end ;
59645: GO 59322
59647: POP
59648: POP
// end ;
59649: LD_VAR 0 3
59653: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
59654: LD_INT 0
59656: PPUSH
59657: PPUSH
59658: PPUSH
// if not unit or IsInUnit ( unit ) then
59659: LD_VAR 0 1
59663: NOT
59664: PUSH
59665: LD_VAR 0 1
59669: PPUSH
59670: CALL_OW 310
59674: OR
59675: IFFALSE 59679
// exit ;
59677: GO 59770
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
59679: LD_ADDR_VAR 0 4
59683: PUSH
59684: LD_VAR 0 1
59688: PPUSH
59689: CALL_OW 250
59693: PPUSH
59694: LD_VAR 0 2
59698: PPUSH
59699: LD_INT 1
59701: PPUSH
59702: CALL_OW 272
59706: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
59707: LD_ADDR_VAR 0 5
59711: PUSH
59712: LD_VAR 0 1
59716: PPUSH
59717: CALL_OW 251
59721: PPUSH
59722: LD_VAR 0 2
59726: PPUSH
59727: LD_INT 1
59729: PPUSH
59730: CALL_OW 273
59734: ST_TO_ADDR
// if ValidHex ( x , y ) then
59735: LD_VAR 0 4
59739: PPUSH
59740: LD_VAR 0 5
59744: PPUSH
59745: CALL_OW 488
59749: IFFALSE 59770
// ComTurnXY ( unit , x , y ) ;
59751: LD_VAR 0 1
59755: PPUSH
59756: LD_VAR 0 4
59760: PPUSH
59761: LD_VAR 0 5
59765: PPUSH
59766: CALL_OW 118
// end ;
59770: LD_VAR 0 3
59774: RET
// export function SeeUnits ( side , units ) ; var i ; begin
59775: LD_INT 0
59777: PPUSH
59778: PPUSH
// result := false ;
59779: LD_ADDR_VAR 0 3
59783: PUSH
59784: LD_INT 0
59786: ST_TO_ADDR
// if not units then
59787: LD_VAR 0 2
59791: NOT
59792: IFFALSE 59796
// exit ;
59794: GO 59841
// for i in units do
59796: LD_ADDR_VAR 0 4
59800: PUSH
59801: LD_VAR 0 2
59805: PUSH
59806: FOR_IN
59807: IFFALSE 59839
// if See ( side , i ) then
59809: LD_VAR 0 1
59813: PPUSH
59814: LD_VAR 0 4
59818: PPUSH
59819: CALL_OW 292
59823: IFFALSE 59837
// begin result := true ;
59825: LD_ADDR_VAR 0 3
59829: PUSH
59830: LD_INT 1
59832: ST_TO_ADDR
// exit ;
59833: POP
59834: POP
59835: GO 59841
// end ;
59837: GO 59806
59839: POP
59840: POP
// end ;
59841: LD_VAR 0 3
59845: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
59846: LD_INT 0
59848: PPUSH
59849: PPUSH
59850: PPUSH
59851: PPUSH
// if not unit or not points then
59852: LD_VAR 0 1
59856: NOT
59857: PUSH
59858: LD_VAR 0 2
59862: NOT
59863: OR
59864: IFFALSE 59868
// exit ;
59866: GO 59958
// dist := 99999 ;
59868: LD_ADDR_VAR 0 5
59872: PUSH
59873: LD_INT 99999
59875: ST_TO_ADDR
// for i in points do
59876: LD_ADDR_VAR 0 4
59880: PUSH
59881: LD_VAR 0 2
59885: PUSH
59886: FOR_IN
59887: IFFALSE 59956
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59889: LD_ADDR_VAR 0 6
59893: PUSH
59894: LD_VAR 0 1
59898: PPUSH
59899: LD_VAR 0 4
59903: PUSH
59904: LD_INT 1
59906: ARRAY
59907: PPUSH
59908: LD_VAR 0 4
59912: PUSH
59913: LD_INT 2
59915: ARRAY
59916: PPUSH
59917: CALL_OW 297
59921: ST_TO_ADDR
// if tmpDist < dist then
59922: LD_VAR 0 6
59926: PUSH
59927: LD_VAR 0 5
59931: LESS
59932: IFFALSE 59954
// begin result := i ;
59934: LD_ADDR_VAR 0 3
59938: PUSH
59939: LD_VAR 0 4
59943: ST_TO_ADDR
// dist := tmpDist ;
59944: LD_ADDR_VAR 0 5
59948: PUSH
59949: LD_VAR 0 6
59953: ST_TO_ADDR
// end ; end ;
59954: GO 59886
59956: POP
59957: POP
// end ; end_of_file
59958: LD_VAR 0 3
59962: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
59963: LD_INT 0
59965: PPUSH
// ar_miner := 81 ;
59966: LD_ADDR_EXP 36
59970: PUSH
59971: LD_INT 81
59973: ST_TO_ADDR
// ar_crane := 88 ;
59974: LD_ADDR_EXP 35
59978: PUSH
59979: LD_INT 88
59981: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
59982: LD_ADDR_EXP 30
59986: PUSH
59987: LD_INT 89
59989: ST_TO_ADDR
// us_hack := 99 ;
59990: LD_ADDR_EXP 31
59994: PUSH
59995: LD_INT 99
59997: ST_TO_ADDR
// us_artillery := 97 ;
59998: LD_ADDR_EXP 32
60002: PUSH
60003: LD_INT 97
60005: ST_TO_ADDR
// ar_bio_bomb := 91 ;
60006: LD_ADDR_EXP 33
60010: PUSH
60011: LD_INT 91
60013: ST_TO_ADDR
// ar_mortar := 92 ;
60014: LD_ADDR_EXP 34
60018: PUSH
60019: LD_INT 92
60021: ST_TO_ADDR
// ru_radar := 98 ;
60022: LD_ADDR_EXP 29
60026: PUSH
60027: LD_INT 98
60029: ST_TO_ADDR
// tech_Artillery := 80 ;
60030: LD_ADDR_EXP 37
60034: PUSH
60035: LD_INT 80
60037: ST_TO_ADDR
// tech_RadMat := 81 ;
60038: LD_ADDR_EXP 38
60042: PUSH
60043: LD_INT 81
60045: ST_TO_ADDR
// tech_BasicTools := 82 ;
60046: LD_ADDR_EXP 39
60050: PUSH
60051: LD_INT 82
60053: ST_TO_ADDR
// tech_Cargo := 83 ;
60054: LD_ADDR_EXP 40
60058: PUSH
60059: LD_INT 83
60061: ST_TO_ADDR
// tech_Track := 84 ;
60062: LD_ADDR_EXP 41
60066: PUSH
60067: LD_INT 84
60069: ST_TO_ADDR
// tech_Crane := 85 ;
60070: LD_ADDR_EXP 42
60074: PUSH
60075: LD_INT 85
60077: ST_TO_ADDR
// tech_Bulldozer := 86 ;
60078: LD_ADDR_EXP 43
60082: PUSH
60083: LD_INT 86
60085: ST_TO_ADDR
// tech_Hovercraft := 87 ;
60086: LD_ADDR_EXP 44
60090: PUSH
60091: LD_INT 87
60093: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
60094: LD_ADDR_EXP 45
60098: PUSH
60099: LD_INT 88
60101: ST_TO_ADDR
// class_mastodont := 31 ;
60102: LD_ADDR_EXP 46
60106: PUSH
60107: LD_INT 31
60109: ST_TO_ADDR
// class_horse := 21 ;
60110: LD_ADDR_EXP 47
60114: PUSH
60115: LD_INT 21
60117: ST_TO_ADDR
// end ;
60118: LD_VAR 0 1
60122: RET
// every 1 do
60123: GO 60125
60125: DISABLE
// InitGlobalVariables ; end_of_file
60126: CALL 59963 0 0
60130: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
60131: LD_INT 0
60133: PPUSH
60134: PPUSH
// skirmish := false ;
60135: LD_ADDR_EXP 48
60139: PUSH
60140: LD_INT 0
60142: ST_TO_ADDR
// debug_mc := false ;
60143: LD_ADDR_EXP 49
60147: PUSH
60148: LD_INT 0
60150: ST_TO_ADDR
// mc_bases := [ ] ;
60151: LD_ADDR_EXP 50
60155: PUSH
60156: EMPTY
60157: ST_TO_ADDR
// mc_sides := [ ] ;
60158: LD_ADDR_EXP 76
60162: PUSH
60163: EMPTY
60164: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
60165: LD_ADDR_EXP 51
60169: PUSH
60170: EMPTY
60171: ST_TO_ADDR
// mc_building_repairs := [ ] ;
60172: LD_ADDR_EXP 52
60176: PUSH
60177: EMPTY
60178: ST_TO_ADDR
// mc_need_heal := [ ] ;
60179: LD_ADDR_EXP 53
60183: PUSH
60184: EMPTY
60185: ST_TO_ADDR
// mc_healers := [ ] ;
60186: LD_ADDR_EXP 54
60190: PUSH
60191: EMPTY
60192: ST_TO_ADDR
// mc_build_list := [ ] ;
60193: LD_ADDR_EXP 55
60197: PUSH
60198: EMPTY
60199: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
60200: LD_ADDR_EXP 82
60204: PUSH
60205: EMPTY
60206: ST_TO_ADDR
// mc_builders := [ ] ;
60207: LD_ADDR_EXP 56
60211: PUSH
60212: EMPTY
60213: ST_TO_ADDR
// mc_construct_list := [ ] ;
60214: LD_ADDR_EXP 57
60218: PUSH
60219: EMPTY
60220: ST_TO_ADDR
// mc_turret_list := [ ] ;
60221: LD_ADDR_EXP 58
60225: PUSH
60226: EMPTY
60227: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
60228: LD_ADDR_EXP 59
60232: PUSH
60233: EMPTY
60234: ST_TO_ADDR
// mc_miners := [ ] ;
60235: LD_ADDR_EXP 64
60239: PUSH
60240: EMPTY
60241: ST_TO_ADDR
// mc_mines := [ ] ;
60242: LD_ADDR_EXP 63
60246: PUSH
60247: EMPTY
60248: ST_TO_ADDR
// mc_minefields := [ ] ;
60249: LD_ADDR_EXP 65
60253: PUSH
60254: EMPTY
60255: ST_TO_ADDR
// mc_crates := [ ] ;
60256: LD_ADDR_EXP 66
60260: PUSH
60261: EMPTY
60262: ST_TO_ADDR
// mc_crates_collector := [ ] ;
60263: LD_ADDR_EXP 67
60267: PUSH
60268: EMPTY
60269: ST_TO_ADDR
// mc_crates_area := [ ] ;
60270: LD_ADDR_EXP 68
60274: PUSH
60275: EMPTY
60276: ST_TO_ADDR
// mc_vehicles := [ ] ;
60277: LD_ADDR_EXP 69
60281: PUSH
60282: EMPTY
60283: ST_TO_ADDR
// mc_attack := [ ] ;
60284: LD_ADDR_EXP 70
60288: PUSH
60289: EMPTY
60290: ST_TO_ADDR
// mc_produce := [ ] ;
60291: LD_ADDR_EXP 71
60295: PUSH
60296: EMPTY
60297: ST_TO_ADDR
// mc_defender := [ ] ;
60298: LD_ADDR_EXP 72
60302: PUSH
60303: EMPTY
60304: ST_TO_ADDR
// mc_parking := [ ] ;
60305: LD_ADDR_EXP 74
60309: PUSH
60310: EMPTY
60311: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
60312: LD_ADDR_EXP 60
60316: PUSH
60317: EMPTY
60318: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
60319: LD_ADDR_EXP 62
60323: PUSH
60324: EMPTY
60325: ST_TO_ADDR
// mc_scan := [ ] ;
60326: LD_ADDR_EXP 73
60330: PUSH
60331: EMPTY
60332: ST_TO_ADDR
// mc_scan_area := [ ] ;
60333: LD_ADDR_EXP 75
60337: PUSH
60338: EMPTY
60339: ST_TO_ADDR
// mc_tech := [ ] ;
60340: LD_ADDR_EXP 77
60344: PUSH
60345: EMPTY
60346: ST_TO_ADDR
// mc_class := [ ] ;
60347: LD_ADDR_EXP 91
60351: PUSH
60352: EMPTY
60353: ST_TO_ADDR
// mc_class_case_use := [ ] ;
60354: LD_ADDR_EXP 92
60358: PUSH
60359: EMPTY
60360: ST_TO_ADDR
// mc_is_defending := [ ] ;
60361: LD_ADDR_EXP 93
60365: PUSH
60366: EMPTY
60367: ST_TO_ADDR
// end ;
60368: LD_VAR 0 1
60372: RET
// export function MC_Kill ( base ) ; begin
60373: LD_INT 0
60375: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
60376: LD_ADDR_EXP 50
60380: PUSH
60381: LD_EXP 50
60385: PPUSH
60386: LD_VAR 0 1
60390: PPUSH
60391: EMPTY
60392: PPUSH
60393: CALL_OW 1
60397: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
60398: LD_ADDR_EXP 51
60402: PUSH
60403: LD_EXP 51
60407: PPUSH
60408: LD_VAR 0 1
60412: PPUSH
60413: EMPTY
60414: PPUSH
60415: CALL_OW 1
60419: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
60420: LD_ADDR_EXP 52
60424: PUSH
60425: LD_EXP 52
60429: PPUSH
60430: LD_VAR 0 1
60434: PPUSH
60435: EMPTY
60436: PPUSH
60437: CALL_OW 1
60441: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
60442: LD_ADDR_EXP 53
60446: PUSH
60447: LD_EXP 53
60451: PPUSH
60452: LD_VAR 0 1
60456: PPUSH
60457: EMPTY
60458: PPUSH
60459: CALL_OW 1
60463: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
60464: LD_ADDR_EXP 54
60468: PUSH
60469: LD_EXP 54
60473: PPUSH
60474: LD_VAR 0 1
60478: PPUSH
60479: EMPTY
60480: PPUSH
60481: CALL_OW 1
60485: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
60486: LD_ADDR_EXP 55
60490: PUSH
60491: LD_EXP 55
60495: PPUSH
60496: LD_VAR 0 1
60500: PPUSH
60501: EMPTY
60502: PPUSH
60503: CALL_OW 1
60507: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
60508: LD_ADDR_EXP 56
60512: PUSH
60513: LD_EXP 56
60517: PPUSH
60518: LD_VAR 0 1
60522: PPUSH
60523: EMPTY
60524: PPUSH
60525: CALL_OW 1
60529: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
60530: LD_ADDR_EXP 57
60534: PUSH
60535: LD_EXP 57
60539: PPUSH
60540: LD_VAR 0 1
60544: PPUSH
60545: EMPTY
60546: PPUSH
60547: CALL_OW 1
60551: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
60552: LD_ADDR_EXP 58
60556: PUSH
60557: LD_EXP 58
60561: PPUSH
60562: LD_VAR 0 1
60566: PPUSH
60567: EMPTY
60568: PPUSH
60569: CALL_OW 1
60573: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
60574: LD_ADDR_EXP 59
60578: PUSH
60579: LD_EXP 59
60583: PPUSH
60584: LD_VAR 0 1
60588: PPUSH
60589: EMPTY
60590: PPUSH
60591: CALL_OW 1
60595: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
60596: LD_ADDR_EXP 60
60600: PUSH
60601: LD_EXP 60
60605: PPUSH
60606: LD_VAR 0 1
60610: PPUSH
60611: EMPTY
60612: PPUSH
60613: CALL_OW 1
60617: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
60618: LD_ADDR_EXP 61
60622: PUSH
60623: LD_EXP 61
60627: PPUSH
60628: LD_VAR 0 1
60632: PPUSH
60633: LD_INT 0
60635: PPUSH
60636: CALL_OW 1
60640: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
60641: LD_ADDR_EXP 62
60645: PUSH
60646: LD_EXP 62
60650: PPUSH
60651: LD_VAR 0 1
60655: PPUSH
60656: EMPTY
60657: PPUSH
60658: CALL_OW 1
60662: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
60663: LD_ADDR_EXP 63
60667: PUSH
60668: LD_EXP 63
60672: PPUSH
60673: LD_VAR 0 1
60677: PPUSH
60678: EMPTY
60679: PPUSH
60680: CALL_OW 1
60684: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
60685: LD_ADDR_EXP 64
60689: PUSH
60690: LD_EXP 64
60694: PPUSH
60695: LD_VAR 0 1
60699: PPUSH
60700: EMPTY
60701: PPUSH
60702: CALL_OW 1
60706: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
60707: LD_ADDR_EXP 65
60711: PUSH
60712: LD_EXP 65
60716: PPUSH
60717: LD_VAR 0 1
60721: PPUSH
60722: EMPTY
60723: PPUSH
60724: CALL_OW 1
60728: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
60729: LD_ADDR_EXP 66
60733: PUSH
60734: LD_EXP 66
60738: PPUSH
60739: LD_VAR 0 1
60743: PPUSH
60744: EMPTY
60745: PPUSH
60746: CALL_OW 1
60750: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
60751: LD_ADDR_EXP 67
60755: PUSH
60756: LD_EXP 67
60760: PPUSH
60761: LD_VAR 0 1
60765: PPUSH
60766: EMPTY
60767: PPUSH
60768: CALL_OW 1
60772: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
60773: LD_ADDR_EXP 68
60777: PUSH
60778: LD_EXP 68
60782: PPUSH
60783: LD_VAR 0 1
60787: PPUSH
60788: EMPTY
60789: PPUSH
60790: CALL_OW 1
60794: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
60795: LD_ADDR_EXP 69
60799: PUSH
60800: LD_EXP 69
60804: PPUSH
60805: LD_VAR 0 1
60809: PPUSH
60810: EMPTY
60811: PPUSH
60812: CALL_OW 1
60816: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
60817: LD_ADDR_EXP 70
60821: PUSH
60822: LD_EXP 70
60826: PPUSH
60827: LD_VAR 0 1
60831: PPUSH
60832: EMPTY
60833: PPUSH
60834: CALL_OW 1
60838: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
60839: LD_ADDR_EXP 71
60843: PUSH
60844: LD_EXP 71
60848: PPUSH
60849: LD_VAR 0 1
60853: PPUSH
60854: EMPTY
60855: PPUSH
60856: CALL_OW 1
60860: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60861: LD_ADDR_EXP 72
60865: PUSH
60866: LD_EXP 72
60870: PPUSH
60871: LD_VAR 0 1
60875: PPUSH
60876: EMPTY
60877: PPUSH
60878: CALL_OW 1
60882: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
60883: LD_ADDR_EXP 73
60887: PUSH
60888: LD_EXP 73
60892: PPUSH
60893: LD_VAR 0 1
60897: PPUSH
60898: EMPTY
60899: PPUSH
60900: CALL_OW 1
60904: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60905: LD_ADDR_EXP 74
60909: PUSH
60910: LD_EXP 74
60914: PPUSH
60915: LD_VAR 0 1
60919: PPUSH
60920: EMPTY
60921: PPUSH
60922: CALL_OW 1
60926: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60927: LD_ADDR_EXP 75
60931: PUSH
60932: LD_EXP 75
60936: PPUSH
60937: LD_VAR 0 1
60941: PPUSH
60942: EMPTY
60943: PPUSH
60944: CALL_OW 1
60948: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
60949: LD_ADDR_EXP 77
60953: PUSH
60954: LD_EXP 77
60958: PPUSH
60959: LD_VAR 0 1
60963: PPUSH
60964: EMPTY
60965: PPUSH
60966: CALL_OW 1
60970: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
60971: LD_ADDR_EXP 79
60975: PUSH
60976: LD_EXP 79
60980: PPUSH
60981: LD_VAR 0 1
60985: PPUSH
60986: EMPTY
60987: PPUSH
60988: CALL_OW 1
60992: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
60993: LD_ADDR_EXP 80
60997: PUSH
60998: LD_EXP 80
61002: PPUSH
61003: LD_VAR 0 1
61007: PPUSH
61008: EMPTY
61009: PPUSH
61010: CALL_OW 1
61014: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61015: LD_ADDR_EXP 81
61019: PUSH
61020: LD_EXP 81
61024: PPUSH
61025: LD_VAR 0 1
61029: PPUSH
61030: EMPTY
61031: PPUSH
61032: CALL_OW 1
61036: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61037: LD_ADDR_EXP 82
61041: PUSH
61042: LD_EXP 82
61046: PPUSH
61047: LD_VAR 0 1
61051: PPUSH
61052: EMPTY
61053: PPUSH
61054: CALL_OW 1
61058: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61059: LD_ADDR_EXP 83
61063: PUSH
61064: LD_EXP 83
61068: PPUSH
61069: LD_VAR 0 1
61073: PPUSH
61074: EMPTY
61075: PPUSH
61076: CALL_OW 1
61080: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61081: LD_ADDR_EXP 84
61085: PUSH
61086: LD_EXP 84
61090: PPUSH
61091: LD_VAR 0 1
61095: PPUSH
61096: EMPTY
61097: PPUSH
61098: CALL_OW 1
61102: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61103: LD_ADDR_EXP 85
61107: PUSH
61108: LD_EXP 85
61112: PPUSH
61113: LD_VAR 0 1
61117: PPUSH
61118: EMPTY
61119: PPUSH
61120: CALL_OW 1
61124: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61125: LD_ADDR_EXP 86
61129: PUSH
61130: LD_EXP 86
61134: PPUSH
61135: LD_VAR 0 1
61139: PPUSH
61140: EMPTY
61141: PPUSH
61142: CALL_OW 1
61146: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61147: LD_ADDR_EXP 87
61151: PUSH
61152: LD_EXP 87
61156: PPUSH
61157: LD_VAR 0 1
61161: PPUSH
61162: EMPTY
61163: PPUSH
61164: CALL_OW 1
61168: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61169: LD_ADDR_EXP 88
61173: PUSH
61174: LD_EXP 88
61178: PPUSH
61179: LD_VAR 0 1
61183: PPUSH
61184: EMPTY
61185: PPUSH
61186: CALL_OW 1
61190: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61191: LD_ADDR_EXP 89
61195: PUSH
61196: LD_EXP 89
61200: PPUSH
61201: LD_VAR 0 1
61205: PPUSH
61206: EMPTY
61207: PPUSH
61208: CALL_OW 1
61212: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
61213: LD_ADDR_EXP 90
61217: PUSH
61218: LD_EXP 90
61222: PPUSH
61223: LD_VAR 0 1
61227: PPUSH
61228: EMPTY
61229: PPUSH
61230: CALL_OW 1
61234: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
61235: LD_ADDR_EXP 91
61239: PUSH
61240: LD_EXP 91
61244: PPUSH
61245: LD_VAR 0 1
61249: PPUSH
61250: EMPTY
61251: PPUSH
61252: CALL_OW 1
61256: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
61257: LD_ADDR_EXP 92
61261: PUSH
61262: LD_EXP 92
61266: PPUSH
61267: LD_VAR 0 1
61271: PPUSH
61272: LD_INT 0
61274: PPUSH
61275: CALL_OW 1
61279: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
61280: LD_ADDR_EXP 93
61284: PUSH
61285: LD_EXP 93
61289: PPUSH
61290: LD_VAR 0 1
61294: PPUSH
61295: LD_INT 0
61297: PPUSH
61298: CALL_OW 1
61302: ST_TO_ADDR
// end ;
61303: LD_VAR 0 2
61307: RET
// export function MC_Add ( side , units ) ; var base ; begin
61308: LD_INT 0
61310: PPUSH
61311: PPUSH
// base := mc_bases + 1 ;
61312: LD_ADDR_VAR 0 4
61316: PUSH
61317: LD_EXP 50
61321: PUSH
61322: LD_INT 1
61324: PLUS
61325: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
61326: LD_ADDR_EXP 76
61330: PUSH
61331: LD_EXP 76
61335: PPUSH
61336: LD_VAR 0 4
61340: PPUSH
61341: LD_VAR 0 1
61345: PPUSH
61346: CALL_OW 1
61350: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
61351: LD_ADDR_EXP 50
61355: PUSH
61356: LD_EXP 50
61360: PPUSH
61361: LD_VAR 0 4
61365: PPUSH
61366: LD_VAR 0 2
61370: PPUSH
61371: CALL_OW 1
61375: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61376: LD_ADDR_EXP 51
61380: PUSH
61381: LD_EXP 51
61385: PPUSH
61386: LD_VAR 0 4
61390: PPUSH
61391: EMPTY
61392: PPUSH
61393: CALL_OW 1
61397: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61398: LD_ADDR_EXP 52
61402: PUSH
61403: LD_EXP 52
61407: PPUSH
61408: LD_VAR 0 4
61412: PPUSH
61413: EMPTY
61414: PPUSH
61415: CALL_OW 1
61419: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61420: LD_ADDR_EXP 53
61424: PUSH
61425: LD_EXP 53
61429: PPUSH
61430: LD_VAR 0 4
61434: PPUSH
61435: EMPTY
61436: PPUSH
61437: CALL_OW 1
61441: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61442: LD_ADDR_EXP 54
61446: PUSH
61447: LD_EXP 54
61451: PPUSH
61452: LD_VAR 0 4
61456: PPUSH
61457: EMPTY
61458: PPUSH
61459: CALL_OW 1
61463: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61464: LD_ADDR_EXP 55
61468: PUSH
61469: LD_EXP 55
61473: PPUSH
61474: LD_VAR 0 4
61478: PPUSH
61479: EMPTY
61480: PPUSH
61481: CALL_OW 1
61485: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61486: LD_ADDR_EXP 56
61490: PUSH
61491: LD_EXP 56
61495: PPUSH
61496: LD_VAR 0 4
61500: PPUSH
61501: EMPTY
61502: PPUSH
61503: CALL_OW 1
61507: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61508: LD_ADDR_EXP 57
61512: PUSH
61513: LD_EXP 57
61517: PPUSH
61518: LD_VAR 0 4
61522: PPUSH
61523: EMPTY
61524: PPUSH
61525: CALL_OW 1
61529: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61530: LD_ADDR_EXP 58
61534: PUSH
61535: LD_EXP 58
61539: PPUSH
61540: LD_VAR 0 4
61544: PPUSH
61545: EMPTY
61546: PPUSH
61547: CALL_OW 1
61551: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61552: LD_ADDR_EXP 59
61556: PUSH
61557: LD_EXP 59
61561: PPUSH
61562: LD_VAR 0 4
61566: PPUSH
61567: EMPTY
61568: PPUSH
61569: CALL_OW 1
61573: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61574: LD_ADDR_EXP 60
61578: PUSH
61579: LD_EXP 60
61583: PPUSH
61584: LD_VAR 0 4
61588: PPUSH
61589: EMPTY
61590: PPUSH
61591: CALL_OW 1
61595: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61596: LD_ADDR_EXP 61
61600: PUSH
61601: LD_EXP 61
61605: PPUSH
61606: LD_VAR 0 4
61610: PPUSH
61611: LD_INT 0
61613: PPUSH
61614: CALL_OW 1
61618: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61619: LD_ADDR_EXP 62
61623: PUSH
61624: LD_EXP 62
61628: PPUSH
61629: LD_VAR 0 4
61633: PPUSH
61634: EMPTY
61635: PPUSH
61636: CALL_OW 1
61640: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61641: LD_ADDR_EXP 63
61645: PUSH
61646: LD_EXP 63
61650: PPUSH
61651: LD_VAR 0 4
61655: PPUSH
61656: EMPTY
61657: PPUSH
61658: CALL_OW 1
61662: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61663: LD_ADDR_EXP 64
61667: PUSH
61668: LD_EXP 64
61672: PPUSH
61673: LD_VAR 0 4
61677: PPUSH
61678: EMPTY
61679: PPUSH
61680: CALL_OW 1
61684: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61685: LD_ADDR_EXP 65
61689: PUSH
61690: LD_EXP 65
61694: PPUSH
61695: LD_VAR 0 4
61699: PPUSH
61700: EMPTY
61701: PPUSH
61702: CALL_OW 1
61706: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61707: LD_ADDR_EXP 66
61711: PUSH
61712: LD_EXP 66
61716: PPUSH
61717: LD_VAR 0 4
61721: PPUSH
61722: EMPTY
61723: PPUSH
61724: CALL_OW 1
61728: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61729: LD_ADDR_EXP 67
61733: PUSH
61734: LD_EXP 67
61738: PPUSH
61739: LD_VAR 0 4
61743: PPUSH
61744: EMPTY
61745: PPUSH
61746: CALL_OW 1
61750: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61751: LD_ADDR_EXP 68
61755: PUSH
61756: LD_EXP 68
61760: PPUSH
61761: LD_VAR 0 4
61765: PPUSH
61766: EMPTY
61767: PPUSH
61768: CALL_OW 1
61772: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61773: LD_ADDR_EXP 69
61777: PUSH
61778: LD_EXP 69
61782: PPUSH
61783: LD_VAR 0 4
61787: PPUSH
61788: EMPTY
61789: PPUSH
61790: CALL_OW 1
61794: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61795: LD_ADDR_EXP 70
61799: PUSH
61800: LD_EXP 70
61804: PPUSH
61805: LD_VAR 0 4
61809: PPUSH
61810: EMPTY
61811: PPUSH
61812: CALL_OW 1
61816: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61817: LD_ADDR_EXP 71
61821: PUSH
61822: LD_EXP 71
61826: PPUSH
61827: LD_VAR 0 4
61831: PPUSH
61832: EMPTY
61833: PPUSH
61834: CALL_OW 1
61838: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61839: LD_ADDR_EXP 72
61843: PUSH
61844: LD_EXP 72
61848: PPUSH
61849: LD_VAR 0 4
61853: PPUSH
61854: EMPTY
61855: PPUSH
61856: CALL_OW 1
61860: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
61861: LD_ADDR_EXP 73
61865: PUSH
61866: LD_EXP 73
61870: PPUSH
61871: LD_VAR 0 4
61875: PPUSH
61876: EMPTY
61877: PPUSH
61878: CALL_OW 1
61882: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
61883: LD_ADDR_EXP 74
61887: PUSH
61888: LD_EXP 74
61892: PPUSH
61893: LD_VAR 0 4
61897: PPUSH
61898: EMPTY
61899: PPUSH
61900: CALL_OW 1
61904: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61905: LD_ADDR_EXP 75
61909: PUSH
61910: LD_EXP 75
61914: PPUSH
61915: LD_VAR 0 4
61919: PPUSH
61920: EMPTY
61921: PPUSH
61922: CALL_OW 1
61926: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61927: LD_ADDR_EXP 77
61931: PUSH
61932: LD_EXP 77
61936: PPUSH
61937: LD_VAR 0 4
61941: PPUSH
61942: EMPTY
61943: PPUSH
61944: CALL_OW 1
61948: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61949: LD_ADDR_EXP 79
61953: PUSH
61954: LD_EXP 79
61958: PPUSH
61959: LD_VAR 0 4
61963: PPUSH
61964: EMPTY
61965: PPUSH
61966: CALL_OW 1
61970: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61971: LD_ADDR_EXP 80
61975: PUSH
61976: LD_EXP 80
61980: PPUSH
61981: LD_VAR 0 4
61985: PPUSH
61986: EMPTY
61987: PPUSH
61988: CALL_OW 1
61992: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61993: LD_ADDR_EXP 81
61997: PUSH
61998: LD_EXP 81
62002: PPUSH
62003: LD_VAR 0 4
62007: PPUSH
62008: EMPTY
62009: PPUSH
62010: CALL_OW 1
62014: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62015: LD_ADDR_EXP 82
62019: PUSH
62020: LD_EXP 82
62024: PPUSH
62025: LD_VAR 0 4
62029: PPUSH
62030: EMPTY
62031: PPUSH
62032: CALL_OW 1
62036: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62037: LD_ADDR_EXP 83
62041: PUSH
62042: LD_EXP 83
62046: PPUSH
62047: LD_VAR 0 4
62051: PPUSH
62052: EMPTY
62053: PPUSH
62054: CALL_OW 1
62058: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62059: LD_ADDR_EXP 84
62063: PUSH
62064: LD_EXP 84
62068: PPUSH
62069: LD_VAR 0 4
62073: PPUSH
62074: EMPTY
62075: PPUSH
62076: CALL_OW 1
62080: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62081: LD_ADDR_EXP 85
62085: PUSH
62086: LD_EXP 85
62090: PPUSH
62091: LD_VAR 0 4
62095: PPUSH
62096: EMPTY
62097: PPUSH
62098: CALL_OW 1
62102: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62103: LD_ADDR_EXP 86
62107: PUSH
62108: LD_EXP 86
62112: PPUSH
62113: LD_VAR 0 4
62117: PPUSH
62118: EMPTY
62119: PPUSH
62120: CALL_OW 1
62124: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62125: LD_ADDR_EXP 87
62129: PUSH
62130: LD_EXP 87
62134: PPUSH
62135: LD_VAR 0 4
62139: PPUSH
62140: EMPTY
62141: PPUSH
62142: CALL_OW 1
62146: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62147: LD_ADDR_EXP 88
62151: PUSH
62152: LD_EXP 88
62156: PPUSH
62157: LD_VAR 0 4
62161: PPUSH
62162: EMPTY
62163: PPUSH
62164: CALL_OW 1
62168: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62169: LD_ADDR_EXP 89
62173: PUSH
62174: LD_EXP 89
62178: PPUSH
62179: LD_VAR 0 4
62183: PPUSH
62184: EMPTY
62185: PPUSH
62186: CALL_OW 1
62190: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62191: LD_ADDR_EXP 90
62195: PUSH
62196: LD_EXP 90
62200: PPUSH
62201: LD_VAR 0 4
62205: PPUSH
62206: EMPTY
62207: PPUSH
62208: CALL_OW 1
62212: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62213: LD_ADDR_EXP 91
62217: PUSH
62218: LD_EXP 91
62222: PPUSH
62223: LD_VAR 0 4
62227: PPUSH
62228: EMPTY
62229: PPUSH
62230: CALL_OW 1
62234: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62235: LD_ADDR_EXP 92
62239: PUSH
62240: LD_EXP 92
62244: PPUSH
62245: LD_VAR 0 4
62249: PPUSH
62250: LD_INT 0
62252: PPUSH
62253: CALL_OW 1
62257: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62258: LD_ADDR_EXP 93
62262: PUSH
62263: LD_EXP 93
62267: PPUSH
62268: LD_VAR 0 4
62272: PPUSH
62273: LD_INT 0
62275: PPUSH
62276: CALL_OW 1
62280: ST_TO_ADDR
// result := base ;
62281: LD_ADDR_VAR 0 3
62285: PUSH
62286: LD_VAR 0 4
62290: ST_TO_ADDR
// end ;
62291: LD_VAR 0 3
62295: RET
// export function MC_Start ( ) ; var i ; begin
62296: LD_INT 0
62298: PPUSH
62299: PPUSH
// for i = 1 to mc_bases do
62300: LD_ADDR_VAR 0 2
62304: PUSH
62305: DOUBLE
62306: LD_INT 1
62308: DEC
62309: ST_TO_ADDR
62310: LD_EXP 50
62314: PUSH
62315: FOR_TO
62316: IFFALSE 63416
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
62318: LD_ADDR_EXP 50
62322: PUSH
62323: LD_EXP 50
62327: PPUSH
62328: LD_VAR 0 2
62332: PPUSH
62333: LD_EXP 50
62337: PUSH
62338: LD_VAR 0 2
62342: ARRAY
62343: PUSH
62344: LD_INT 0
62346: DIFF
62347: PPUSH
62348: CALL_OW 1
62352: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
62353: LD_ADDR_EXP 51
62357: PUSH
62358: LD_EXP 51
62362: PPUSH
62363: LD_VAR 0 2
62367: PPUSH
62368: EMPTY
62369: PPUSH
62370: CALL_OW 1
62374: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
62375: LD_ADDR_EXP 52
62379: PUSH
62380: LD_EXP 52
62384: PPUSH
62385: LD_VAR 0 2
62389: PPUSH
62390: EMPTY
62391: PPUSH
62392: CALL_OW 1
62396: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
62397: LD_ADDR_EXP 53
62401: PUSH
62402: LD_EXP 53
62406: PPUSH
62407: LD_VAR 0 2
62411: PPUSH
62412: EMPTY
62413: PPUSH
62414: CALL_OW 1
62418: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
62419: LD_ADDR_EXP 54
62423: PUSH
62424: LD_EXP 54
62428: PPUSH
62429: LD_VAR 0 2
62433: PPUSH
62434: EMPTY
62435: PUSH
62436: EMPTY
62437: PUSH
62438: EMPTY
62439: LIST
62440: LIST
62441: PPUSH
62442: CALL_OW 1
62446: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
62447: LD_ADDR_EXP 55
62451: PUSH
62452: LD_EXP 55
62456: PPUSH
62457: LD_VAR 0 2
62461: PPUSH
62462: EMPTY
62463: PPUSH
62464: CALL_OW 1
62468: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
62469: LD_ADDR_EXP 82
62473: PUSH
62474: LD_EXP 82
62478: PPUSH
62479: LD_VAR 0 2
62483: PPUSH
62484: EMPTY
62485: PPUSH
62486: CALL_OW 1
62490: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
62491: LD_ADDR_EXP 56
62495: PUSH
62496: LD_EXP 56
62500: PPUSH
62501: LD_VAR 0 2
62505: PPUSH
62506: EMPTY
62507: PPUSH
62508: CALL_OW 1
62512: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
62513: LD_ADDR_EXP 57
62517: PUSH
62518: LD_EXP 57
62522: PPUSH
62523: LD_VAR 0 2
62527: PPUSH
62528: EMPTY
62529: PPUSH
62530: CALL_OW 1
62534: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
62535: LD_ADDR_EXP 58
62539: PUSH
62540: LD_EXP 58
62544: PPUSH
62545: LD_VAR 0 2
62549: PPUSH
62550: LD_EXP 50
62554: PUSH
62555: LD_VAR 0 2
62559: ARRAY
62560: PPUSH
62561: LD_INT 2
62563: PUSH
62564: LD_INT 30
62566: PUSH
62567: LD_INT 32
62569: PUSH
62570: EMPTY
62571: LIST
62572: LIST
62573: PUSH
62574: LD_INT 30
62576: PUSH
62577: LD_INT 33
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: PUSH
62584: EMPTY
62585: LIST
62586: LIST
62587: LIST
62588: PPUSH
62589: CALL_OW 72
62593: PPUSH
62594: CALL_OW 1
62598: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
62599: LD_ADDR_EXP 59
62603: PUSH
62604: LD_EXP 59
62608: PPUSH
62609: LD_VAR 0 2
62613: PPUSH
62614: LD_EXP 50
62618: PUSH
62619: LD_VAR 0 2
62623: ARRAY
62624: PPUSH
62625: LD_INT 2
62627: PUSH
62628: LD_INT 30
62630: PUSH
62631: LD_INT 32
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: PUSH
62638: LD_INT 30
62640: PUSH
62641: LD_INT 31
62643: PUSH
62644: EMPTY
62645: LIST
62646: LIST
62647: PUSH
62648: EMPTY
62649: LIST
62650: LIST
62651: LIST
62652: PUSH
62653: LD_INT 58
62655: PUSH
62656: EMPTY
62657: LIST
62658: PUSH
62659: EMPTY
62660: LIST
62661: LIST
62662: PPUSH
62663: CALL_OW 72
62667: PPUSH
62668: CALL_OW 1
62672: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
62673: LD_ADDR_EXP 60
62677: PUSH
62678: LD_EXP 60
62682: PPUSH
62683: LD_VAR 0 2
62687: PPUSH
62688: EMPTY
62689: PPUSH
62690: CALL_OW 1
62694: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
62695: LD_ADDR_EXP 64
62699: PUSH
62700: LD_EXP 64
62704: PPUSH
62705: LD_VAR 0 2
62709: PPUSH
62710: EMPTY
62711: PPUSH
62712: CALL_OW 1
62716: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
62717: LD_ADDR_EXP 63
62721: PUSH
62722: LD_EXP 63
62726: PPUSH
62727: LD_VAR 0 2
62731: PPUSH
62732: EMPTY
62733: PPUSH
62734: CALL_OW 1
62738: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
62739: LD_ADDR_EXP 65
62743: PUSH
62744: LD_EXP 65
62748: PPUSH
62749: LD_VAR 0 2
62753: PPUSH
62754: EMPTY
62755: PPUSH
62756: CALL_OW 1
62760: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
62761: LD_ADDR_EXP 66
62765: PUSH
62766: LD_EXP 66
62770: PPUSH
62771: LD_VAR 0 2
62775: PPUSH
62776: EMPTY
62777: PPUSH
62778: CALL_OW 1
62782: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
62783: LD_ADDR_EXP 67
62787: PUSH
62788: LD_EXP 67
62792: PPUSH
62793: LD_VAR 0 2
62797: PPUSH
62798: EMPTY
62799: PPUSH
62800: CALL_OW 1
62804: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
62805: LD_ADDR_EXP 68
62809: PUSH
62810: LD_EXP 68
62814: PPUSH
62815: LD_VAR 0 2
62819: PPUSH
62820: EMPTY
62821: PPUSH
62822: CALL_OW 1
62826: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
62827: LD_ADDR_EXP 69
62831: PUSH
62832: LD_EXP 69
62836: PPUSH
62837: LD_VAR 0 2
62841: PPUSH
62842: EMPTY
62843: PPUSH
62844: CALL_OW 1
62848: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62849: LD_ADDR_EXP 70
62853: PUSH
62854: LD_EXP 70
62858: PPUSH
62859: LD_VAR 0 2
62863: PPUSH
62864: EMPTY
62865: PPUSH
62866: CALL_OW 1
62870: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
62871: LD_ADDR_EXP 71
62875: PUSH
62876: LD_EXP 71
62880: PPUSH
62881: LD_VAR 0 2
62885: PPUSH
62886: EMPTY
62887: PPUSH
62888: CALL_OW 1
62892: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
62893: LD_ADDR_EXP 72
62897: PUSH
62898: LD_EXP 72
62902: PPUSH
62903: LD_VAR 0 2
62907: PPUSH
62908: EMPTY
62909: PPUSH
62910: CALL_OW 1
62914: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
62915: LD_ADDR_EXP 61
62919: PUSH
62920: LD_EXP 61
62924: PPUSH
62925: LD_VAR 0 2
62929: PPUSH
62930: LD_INT 0
62932: PPUSH
62933: CALL_OW 1
62937: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
62938: LD_ADDR_EXP 74
62942: PUSH
62943: LD_EXP 74
62947: PPUSH
62948: LD_VAR 0 2
62952: PPUSH
62953: LD_INT 0
62955: PPUSH
62956: CALL_OW 1
62960: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
62961: LD_ADDR_EXP 62
62965: PUSH
62966: LD_EXP 62
62970: PPUSH
62971: LD_VAR 0 2
62975: PPUSH
62976: EMPTY
62977: PPUSH
62978: CALL_OW 1
62982: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
62983: LD_ADDR_EXP 73
62987: PUSH
62988: LD_EXP 73
62992: PPUSH
62993: LD_VAR 0 2
62997: PPUSH
62998: LD_INT 0
63000: PPUSH
63001: CALL_OW 1
63005: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
63006: LD_ADDR_EXP 75
63010: PUSH
63011: LD_EXP 75
63015: PPUSH
63016: LD_VAR 0 2
63020: PPUSH
63021: EMPTY
63022: PPUSH
63023: CALL_OW 1
63027: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
63028: LD_ADDR_EXP 78
63032: PUSH
63033: LD_EXP 78
63037: PPUSH
63038: LD_VAR 0 2
63042: PPUSH
63043: LD_INT 0
63045: PPUSH
63046: CALL_OW 1
63050: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
63051: LD_ADDR_EXP 79
63055: PUSH
63056: LD_EXP 79
63060: PPUSH
63061: LD_VAR 0 2
63065: PPUSH
63066: EMPTY
63067: PPUSH
63068: CALL_OW 1
63072: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63073: LD_ADDR_EXP 80
63077: PUSH
63078: LD_EXP 80
63082: PPUSH
63083: LD_VAR 0 2
63087: PPUSH
63088: EMPTY
63089: PPUSH
63090: CALL_OW 1
63094: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63095: LD_ADDR_EXP 81
63099: PUSH
63100: LD_EXP 81
63104: PPUSH
63105: LD_VAR 0 2
63109: PPUSH
63110: EMPTY
63111: PPUSH
63112: CALL_OW 1
63116: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
63117: LD_ADDR_EXP 83
63121: PUSH
63122: LD_EXP 83
63126: PPUSH
63127: LD_VAR 0 2
63131: PPUSH
63132: LD_EXP 50
63136: PUSH
63137: LD_VAR 0 2
63141: ARRAY
63142: PPUSH
63143: LD_INT 2
63145: PUSH
63146: LD_INT 30
63148: PUSH
63149: LD_INT 6
63151: PUSH
63152: EMPTY
63153: LIST
63154: LIST
63155: PUSH
63156: LD_INT 30
63158: PUSH
63159: LD_INT 7
63161: PUSH
63162: EMPTY
63163: LIST
63164: LIST
63165: PUSH
63166: LD_INT 30
63168: PUSH
63169: LD_INT 8
63171: PUSH
63172: EMPTY
63173: LIST
63174: LIST
63175: PUSH
63176: EMPTY
63177: LIST
63178: LIST
63179: LIST
63180: LIST
63181: PPUSH
63182: CALL_OW 72
63186: PPUSH
63187: CALL_OW 1
63191: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
63192: LD_ADDR_EXP 84
63196: PUSH
63197: LD_EXP 84
63201: PPUSH
63202: LD_VAR 0 2
63206: PPUSH
63207: EMPTY
63208: PPUSH
63209: CALL_OW 1
63213: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
63214: LD_ADDR_EXP 85
63218: PUSH
63219: LD_EXP 85
63223: PPUSH
63224: LD_VAR 0 2
63228: PPUSH
63229: EMPTY
63230: PPUSH
63231: CALL_OW 1
63235: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
63236: LD_ADDR_EXP 86
63240: PUSH
63241: LD_EXP 86
63245: PPUSH
63246: LD_VAR 0 2
63250: PPUSH
63251: EMPTY
63252: PPUSH
63253: CALL_OW 1
63257: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
63258: LD_ADDR_EXP 87
63262: PUSH
63263: LD_EXP 87
63267: PPUSH
63268: LD_VAR 0 2
63272: PPUSH
63273: EMPTY
63274: PPUSH
63275: CALL_OW 1
63279: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
63280: LD_ADDR_EXP 88
63284: PUSH
63285: LD_EXP 88
63289: PPUSH
63290: LD_VAR 0 2
63294: PPUSH
63295: EMPTY
63296: PPUSH
63297: CALL_OW 1
63301: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
63302: LD_ADDR_EXP 89
63306: PUSH
63307: LD_EXP 89
63311: PPUSH
63312: LD_VAR 0 2
63316: PPUSH
63317: EMPTY
63318: PPUSH
63319: CALL_OW 1
63323: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
63324: LD_ADDR_EXP 90
63328: PUSH
63329: LD_EXP 90
63333: PPUSH
63334: LD_VAR 0 2
63338: PPUSH
63339: EMPTY
63340: PPUSH
63341: CALL_OW 1
63345: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
63346: LD_ADDR_EXP 91
63350: PUSH
63351: LD_EXP 91
63355: PPUSH
63356: LD_VAR 0 2
63360: PPUSH
63361: EMPTY
63362: PPUSH
63363: CALL_OW 1
63367: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
63368: LD_ADDR_EXP 92
63372: PUSH
63373: LD_EXP 92
63377: PPUSH
63378: LD_VAR 0 2
63382: PPUSH
63383: LD_INT 0
63385: PPUSH
63386: CALL_OW 1
63390: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
63391: LD_ADDR_EXP 93
63395: PUSH
63396: LD_EXP 93
63400: PPUSH
63401: LD_VAR 0 2
63405: PPUSH
63406: LD_INT 0
63408: PPUSH
63409: CALL_OW 1
63413: ST_TO_ADDR
// end ;
63414: GO 62315
63416: POP
63417: POP
// MC_InitSides ( ) ;
63418: CALL 63704 0 0
// MC_InitResearch ( ) ;
63422: CALL 63443 0 0
// CustomInitMacro ( ) ;
63426: CALL 1411 0 0
// skirmish := true ;
63430: LD_ADDR_EXP 48
63434: PUSH
63435: LD_INT 1
63437: ST_TO_ADDR
// end ;
63438: LD_VAR 0 1
63442: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
63443: LD_INT 0
63445: PPUSH
63446: PPUSH
63447: PPUSH
63448: PPUSH
63449: PPUSH
63450: PPUSH
// if not mc_bases then
63451: LD_EXP 50
63455: NOT
63456: IFFALSE 63460
// exit ;
63458: GO 63699
// for i = 1 to 8 do
63460: LD_ADDR_VAR 0 2
63464: PUSH
63465: DOUBLE
63466: LD_INT 1
63468: DEC
63469: ST_TO_ADDR
63470: LD_INT 8
63472: PUSH
63473: FOR_TO
63474: IFFALSE 63500
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
63476: LD_ADDR_EXP 77
63480: PUSH
63481: LD_EXP 77
63485: PPUSH
63486: LD_VAR 0 2
63490: PPUSH
63491: EMPTY
63492: PPUSH
63493: CALL_OW 1
63497: ST_TO_ADDR
63498: GO 63473
63500: POP
63501: POP
// tmp := [ ] ;
63502: LD_ADDR_VAR 0 5
63506: PUSH
63507: EMPTY
63508: ST_TO_ADDR
// for i = 1 to mc_sides do
63509: LD_ADDR_VAR 0 2
63513: PUSH
63514: DOUBLE
63515: LD_INT 1
63517: DEC
63518: ST_TO_ADDR
63519: LD_EXP 76
63523: PUSH
63524: FOR_TO
63525: IFFALSE 63583
// if not mc_sides [ i ] in tmp then
63527: LD_EXP 76
63531: PUSH
63532: LD_VAR 0 2
63536: ARRAY
63537: PUSH
63538: LD_VAR 0 5
63542: IN
63543: NOT
63544: IFFALSE 63581
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
63546: LD_ADDR_VAR 0 5
63550: PUSH
63551: LD_VAR 0 5
63555: PPUSH
63556: LD_VAR 0 5
63560: PUSH
63561: LD_INT 1
63563: PLUS
63564: PPUSH
63565: LD_EXP 76
63569: PUSH
63570: LD_VAR 0 2
63574: ARRAY
63575: PPUSH
63576: CALL_OW 2
63580: ST_TO_ADDR
63581: GO 63524
63583: POP
63584: POP
// if not tmp then
63585: LD_VAR 0 5
63589: NOT
63590: IFFALSE 63594
// exit ;
63592: GO 63699
// for j in tmp do
63594: LD_ADDR_VAR 0 3
63598: PUSH
63599: LD_VAR 0 5
63603: PUSH
63604: FOR_IN
63605: IFFALSE 63697
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
63607: LD_ADDR_VAR 0 6
63611: PUSH
63612: LD_INT 22
63614: PUSH
63615: LD_VAR 0 3
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: PPUSH
63624: CALL_OW 69
63628: ST_TO_ADDR
// if not un then
63629: LD_VAR 0 6
63633: NOT
63634: IFFALSE 63638
// continue ;
63636: GO 63604
// nation := GetNation ( un [ 1 ] ) ;
63638: LD_ADDR_VAR 0 4
63642: PUSH
63643: LD_VAR 0 6
63647: PUSH
63648: LD_INT 1
63650: ARRAY
63651: PPUSH
63652: CALL_OW 248
63656: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
63657: LD_ADDR_EXP 77
63661: PUSH
63662: LD_EXP 77
63666: PPUSH
63667: LD_VAR 0 3
63671: PPUSH
63672: LD_VAR 0 3
63676: PPUSH
63677: LD_VAR 0 4
63681: PPUSH
63682: LD_INT 1
63684: PPUSH
63685: CALL 19935 0 3
63689: PPUSH
63690: CALL_OW 1
63694: ST_TO_ADDR
// end ;
63695: GO 63604
63697: POP
63698: POP
// end ;
63699: LD_VAR 0 1
63703: RET
// export function MC_InitSides ( ) ; var i ; begin
63704: LD_INT 0
63706: PPUSH
63707: PPUSH
// if not mc_bases then
63708: LD_EXP 50
63712: NOT
63713: IFFALSE 63717
// exit ;
63715: GO 63791
// for i = 1 to mc_bases do
63717: LD_ADDR_VAR 0 2
63721: PUSH
63722: DOUBLE
63723: LD_INT 1
63725: DEC
63726: ST_TO_ADDR
63727: LD_EXP 50
63731: PUSH
63732: FOR_TO
63733: IFFALSE 63789
// if mc_bases [ i ] then
63735: LD_EXP 50
63739: PUSH
63740: LD_VAR 0 2
63744: ARRAY
63745: IFFALSE 63787
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
63747: LD_ADDR_EXP 76
63751: PUSH
63752: LD_EXP 76
63756: PPUSH
63757: LD_VAR 0 2
63761: PPUSH
63762: LD_EXP 50
63766: PUSH
63767: LD_VAR 0 2
63771: ARRAY
63772: PUSH
63773: LD_INT 1
63775: ARRAY
63776: PPUSH
63777: CALL_OW 255
63781: PPUSH
63782: CALL_OW 1
63786: ST_TO_ADDR
63787: GO 63732
63789: POP
63790: POP
// end ;
63791: LD_VAR 0 1
63795: RET
// every 0 0$03 trigger skirmish do
63796: LD_EXP 48
63800: IFFALSE 63954
63802: GO 63804
63804: DISABLE
// begin enable ;
63805: ENABLE
// MC_CheckBuildings ( ) ;
63806: CALL 68452 0 0
// MC_CheckPeopleLife ( ) ;
63810: CALL 68613 0 0
// RaiseSailEvent ( 100 ) ;
63814: LD_INT 100
63816: PPUSH
63817: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
63821: LD_INT 103
63823: PPUSH
63824: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
63828: LD_INT 104
63830: PPUSH
63831: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
63835: LD_INT 105
63837: PPUSH
63838: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
63842: LD_INT 106
63844: PPUSH
63845: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
63849: LD_INT 107
63851: PPUSH
63852: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
63856: LD_INT 108
63858: PPUSH
63859: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
63863: LD_INT 109
63865: PPUSH
63866: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
63870: LD_INT 110
63872: PPUSH
63873: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
63877: LD_INT 111
63879: PPUSH
63880: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
63884: LD_INT 112
63886: PPUSH
63887: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
63891: LD_INT 113
63893: PPUSH
63894: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
63898: LD_INT 120
63900: PPUSH
63901: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
63905: LD_INT 121
63907: PPUSH
63908: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
63912: LD_INT 122
63914: PPUSH
63915: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
63919: LD_INT 123
63921: PPUSH
63922: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
63926: LD_INT 124
63928: PPUSH
63929: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
63933: LD_INT 125
63935: PPUSH
63936: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
63940: LD_INT 126
63942: PPUSH
63943: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
63947: LD_INT 200
63949: PPUSH
63950: CALL_OW 427
// end ;
63954: END
// on SailEvent ( event ) do begin if event < 100 then
63955: LD_VAR 0 1
63959: PUSH
63960: LD_INT 100
63962: LESS
63963: IFFALSE 63974
// CustomEvent ( event ) ;
63965: LD_VAR 0 1
63969: PPUSH
63970: CALL 19113 0 1
// if event = 100 then
63974: LD_VAR 0 1
63978: PUSH
63979: LD_INT 100
63981: EQUAL
63982: IFFALSE 63988
// MC_ClassManager ( ) ;
63984: CALL 64380 0 0
// if event = 101 then
63988: LD_VAR 0 1
63992: PUSH
63993: LD_INT 101
63995: EQUAL
63996: IFFALSE 64002
// MC_RepairBuildings ( ) ;
63998: CALL 69198 0 0
// if event = 102 then
64002: LD_VAR 0 1
64006: PUSH
64007: LD_INT 102
64009: EQUAL
64010: IFFALSE 64016
// MC_Heal ( ) ;
64012: CALL 70105 0 0
// if event = 103 then
64016: LD_VAR 0 1
64020: PUSH
64021: LD_INT 103
64023: EQUAL
64024: IFFALSE 64030
// MC_Build ( ) ;
64026: CALL 70527 0 0
// if event = 104 then
64030: LD_VAR 0 1
64034: PUSH
64035: LD_INT 104
64037: EQUAL
64038: IFFALSE 64044
// MC_TurretWeapon ( ) ;
64040: CALL 72168 0 0
// if event = 105 then
64044: LD_VAR 0 1
64048: PUSH
64049: LD_INT 105
64051: EQUAL
64052: IFFALSE 64058
// MC_BuildUpgrade ( ) ;
64054: CALL 71719 0 0
// if event = 106 then
64058: LD_VAR 0 1
64062: PUSH
64063: LD_INT 106
64065: EQUAL
64066: IFFALSE 64072
// MC_PlantMines ( ) ;
64068: CALL 72598 0 0
// if event = 107 then
64072: LD_VAR 0 1
64076: PUSH
64077: LD_INT 107
64079: EQUAL
64080: IFFALSE 64086
// MC_CollectCrates ( ) ;
64082: CALL 73389 0 0
// if event = 108 then
64086: LD_VAR 0 1
64090: PUSH
64091: LD_INT 108
64093: EQUAL
64094: IFFALSE 64100
// MC_LinkRemoteControl ( ) ;
64096: CALL 75239 0 0
// if event = 109 then
64100: LD_VAR 0 1
64104: PUSH
64105: LD_INT 109
64107: EQUAL
64108: IFFALSE 64114
// MC_ProduceVehicle ( ) ;
64110: CALL 75420 0 0
// if event = 110 then
64114: LD_VAR 0 1
64118: PUSH
64119: LD_INT 110
64121: EQUAL
64122: IFFALSE 64128
// MC_SendAttack ( ) ;
64124: CALL 75886 0 0
// if event = 111 then
64128: LD_VAR 0 1
64132: PUSH
64133: LD_INT 111
64135: EQUAL
64136: IFFALSE 64142
// MC_Defend ( ) ;
64138: CALL 75994 0 0
// if event = 112 then
64142: LD_VAR 0 1
64146: PUSH
64147: LD_INT 112
64149: EQUAL
64150: IFFALSE 64156
// MC_Research ( ) ;
64152: CALL 76874 0 0
// if event = 113 then
64156: LD_VAR 0 1
64160: PUSH
64161: LD_INT 113
64163: EQUAL
64164: IFFALSE 64170
// MC_MinesTrigger ( ) ;
64166: CALL 77988 0 0
// if event = 120 then
64170: LD_VAR 0 1
64174: PUSH
64175: LD_INT 120
64177: EQUAL
64178: IFFALSE 64184
// MC_RepairVehicle ( ) ;
64180: CALL 78087 0 0
// if event = 121 then
64184: LD_VAR 0 1
64188: PUSH
64189: LD_INT 121
64191: EQUAL
64192: IFFALSE 64198
// MC_TameApe ( ) ;
64194: CALL 78828 0 0
// if event = 122 then
64198: LD_VAR 0 1
64202: PUSH
64203: LD_INT 122
64205: EQUAL
64206: IFFALSE 64212
// MC_ChangeApeClass ( ) ;
64208: CALL 79657 0 0
// if event = 123 then
64212: LD_VAR 0 1
64216: PUSH
64217: LD_INT 123
64219: EQUAL
64220: IFFALSE 64226
// MC_Bazooka ( ) ;
64222: CALL 80307 0 0
// if event = 124 then
64226: LD_VAR 0 1
64230: PUSH
64231: LD_INT 124
64233: EQUAL
64234: IFFALSE 64240
// MC_TeleportExit ( ) ;
64236: CALL 80505 0 0
// if event = 125 then
64240: LD_VAR 0 1
64244: PUSH
64245: LD_INT 125
64247: EQUAL
64248: IFFALSE 64254
// MC_Deposits ( ) ;
64250: CALL 81152 0 0
// if event = 126 then
64254: LD_VAR 0 1
64258: PUSH
64259: LD_INT 126
64261: EQUAL
64262: IFFALSE 64268
// MC_RemoteDriver ( ) ;
64264: CALL 81777 0 0
// if event = 200 then
64268: LD_VAR 0 1
64272: PUSH
64273: LD_INT 200
64275: EQUAL
64276: IFFALSE 64282
// MC_Idle ( ) ;
64278: CALL 83726 0 0
// end ;
64282: PPOPN 1
64284: END
// export function MC_Reset ( base , tag ) ; var i ; begin
64285: LD_INT 0
64287: PPUSH
64288: PPUSH
// if not mc_bases [ base ] or not tag then
64289: LD_EXP 50
64293: PUSH
64294: LD_VAR 0 1
64298: ARRAY
64299: NOT
64300: PUSH
64301: LD_VAR 0 2
64305: NOT
64306: OR
64307: IFFALSE 64311
// exit ;
64309: GO 64375
// for i in mc_bases [ base ] union mc_ape [ base ] do
64311: LD_ADDR_VAR 0 4
64315: PUSH
64316: LD_EXP 50
64320: PUSH
64321: LD_VAR 0 1
64325: ARRAY
64326: PUSH
64327: LD_EXP 79
64331: PUSH
64332: LD_VAR 0 1
64336: ARRAY
64337: UNION
64338: PUSH
64339: FOR_IN
64340: IFFALSE 64373
// if GetTag ( i ) = tag then
64342: LD_VAR 0 4
64346: PPUSH
64347: CALL_OW 110
64351: PUSH
64352: LD_VAR 0 2
64356: EQUAL
64357: IFFALSE 64371
// SetTag ( i , 0 ) ;
64359: LD_VAR 0 4
64363: PPUSH
64364: LD_INT 0
64366: PPUSH
64367: CALL_OW 109
64371: GO 64339
64373: POP
64374: POP
// end ;
64375: LD_VAR 0 3
64379: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
64380: LD_INT 0
64382: PPUSH
64383: PPUSH
64384: PPUSH
64385: PPUSH
64386: PPUSH
64387: PPUSH
64388: PPUSH
64389: PPUSH
// if not mc_bases then
64390: LD_EXP 50
64394: NOT
64395: IFFALSE 64399
// exit ;
64397: GO 64857
// for i = 1 to mc_bases do
64399: LD_ADDR_VAR 0 2
64403: PUSH
64404: DOUBLE
64405: LD_INT 1
64407: DEC
64408: ST_TO_ADDR
64409: LD_EXP 50
64413: PUSH
64414: FOR_TO
64415: IFFALSE 64855
// begin tmp := MC_ClassCheckReq ( i ) ;
64417: LD_ADDR_VAR 0 4
64421: PUSH
64422: LD_VAR 0 2
64426: PPUSH
64427: CALL 64862 0 1
64431: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
64432: LD_ADDR_EXP 91
64436: PUSH
64437: LD_EXP 91
64441: PPUSH
64442: LD_VAR 0 2
64446: PPUSH
64447: LD_VAR 0 4
64451: PPUSH
64452: CALL_OW 1
64456: ST_TO_ADDR
// if not tmp then
64457: LD_VAR 0 4
64461: NOT
64462: IFFALSE 64466
// continue ;
64464: GO 64414
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
64466: LD_ADDR_VAR 0 6
64470: PUSH
64471: LD_EXP 50
64475: PUSH
64476: LD_VAR 0 2
64480: ARRAY
64481: PPUSH
64482: LD_INT 2
64484: PUSH
64485: LD_INT 30
64487: PUSH
64488: LD_INT 4
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: PUSH
64495: LD_INT 30
64497: PUSH
64498: LD_INT 5
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: EMPTY
64506: LIST
64507: LIST
64508: LIST
64509: PPUSH
64510: CALL_OW 72
64514: PUSH
64515: LD_EXP 50
64519: PUSH
64520: LD_VAR 0 2
64524: ARRAY
64525: PPUSH
64526: LD_INT 2
64528: PUSH
64529: LD_INT 30
64531: PUSH
64532: LD_INT 0
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: PUSH
64539: LD_INT 30
64541: PUSH
64542: LD_INT 1
64544: PUSH
64545: EMPTY
64546: LIST
64547: LIST
64548: PUSH
64549: EMPTY
64550: LIST
64551: LIST
64552: LIST
64553: PPUSH
64554: CALL_OW 72
64558: PUSH
64559: LD_EXP 50
64563: PUSH
64564: LD_VAR 0 2
64568: ARRAY
64569: PPUSH
64570: LD_INT 30
64572: PUSH
64573: LD_INT 3
64575: PUSH
64576: EMPTY
64577: LIST
64578: LIST
64579: PPUSH
64580: CALL_OW 72
64584: PUSH
64585: LD_EXP 50
64589: PUSH
64590: LD_VAR 0 2
64594: ARRAY
64595: PPUSH
64596: LD_INT 2
64598: PUSH
64599: LD_INT 30
64601: PUSH
64602: LD_INT 6
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 30
64611: PUSH
64612: LD_INT 7
64614: PUSH
64615: EMPTY
64616: LIST
64617: LIST
64618: PUSH
64619: LD_INT 30
64621: PUSH
64622: LD_INT 8
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PUSH
64629: EMPTY
64630: LIST
64631: LIST
64632: LIST
64633: LIST
64634: PPUSH
64635: CALL_OW 72
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: LIST
64644: LIST
64645: ST_TO_ADDR
// for j = 1 to 4 do
64646: LD_ADDR_VAR 0 3
64650: PUSH
64651: DOUBLE
64652: LD_INT 1
64654: DEC
64655: ST_TO_ADDR
64656: LD_INT 4
64658: PUSH
64659: FOR_TO
64660: IFFALSE 64851
// begin if not tmp [ j ] then
64662: LD_VAR 0 4
64666: PUSH
64667: LD_VAR 0 3
64671: ARRAY
64672: NOT
64673: IFFALSE 64677
// continue ;
64675: GO 64659
// for p in tmp [ j ] do
64677: LD_ADDR_VAR 0 5
64681: PUSH
64682: LD_VAR 0 4
64686: PUSH
64687: LD_VAR 0 3
64691: ARRAY
64692: PUSH
64693: FOR_IN
64694: IFFALSE 64847
// begin if not b [ j ] then
64696: LD_VAR 0 6
64700: PUSH
64701: LD_VAR 0 3
64705: ARRAY
64706: NOT
64707: IFFALSE 64711
// break ;
64709: GO 64847
// e := 0 ;
64711: LD_ADDR_VAR 0 7
64715: PUSH
64716: LD_INT 0
64718: ST_TO_ADDR
// for k in b [ j ] do
64719: LD_ADDR_VAR 0 8
64723: PUSH
64724: LD_VAR 0 6
64728: PUSH
64729: LD_VAR 0 3
64733: ARRAY
64734: PUSH
64735: FOR_IN
64736: IFFALSE 64763
// if IsNotFull ( k ) then
64738: LD_VAR 0 8
64742: PPUSH
64743: CALL 22088 0 1
64747: IFFALSE 64761
// begin e := k ;
64749: LD_ADDR_VAR 0 7
64753: PUSH
64754: LD_VAR 0 8
64758: ST_TO_ADDR
// break ;
64759: GO 64763
// end ;
64761: GO 64735
64763: POP
64764: POP
// if e and not UnitGoingToBuilding ( p , e ) then
64765: LD_VAR 0 7
64769: PUSH
64770: LD_VAR 0 5
64774: PPUSH
64775: LD_VAR 0 7
64779: PPUSH
64780: CALL 55252 0 2
64784: NOT
64785: AND
64786: IFFALSE 64845
// begin if IsInUnit ( p ) then
64788: LD_VAR 0 5
64792: PPUSH
64793: CALL_OW 310
64797: IFFALSE 64808
// ComExitBuilding ( p ) ;
64799: LD_VAR 0 5
64803: PPUSH
64804: CALL_OW 122
// ComEnterUnit ( p , e ) ;
64808: LD_VAR 0 5
64812: PPUSH
64813: LD_VAR 0 7
64817: PPUSH
64818: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
64822: LD_VAR 0 5
64826: PPUSH
64827: LD_VAR 0 3
64831: PPUSH
64832: CALL_OW 183
// AddComExitBuilding ( p ) ;
64836: LD_VAR 0 5
64840: PPUSH
64841: CALL_OW 182
// end ; end ;
64845: GO 64693
64847: POP
64848: POP
// end ;
64849: GO 64659
64851: POP
64852: POP
// end ;
64853: GO 64414
64855: POP
64856: POP
// end ;
64857: LD_VAR 0 1
64861: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
64862: LD_INT 0
64864: PPUSH
64865: PPUSH
64866: PPUSH
64867: PPUSH
64868: PPUSH
64869: PPUSH
64870: PPUSH
64871: PPUSH
64872: PPUSH
64873: PPUSH
64874: PPUSH
64875: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
64876: LD_VAR 0 1
64880: NOT
64881: PUSH
64882: LD_EXP 50
64886: PUSH
64887: LD_VAR 0 1
64891: ARRAY
64892: NOT
64893: OR
64894: PUSH
64895: LD_EXP 50
64899: PUSH
64900: LD_VAR 0 1
64904: ARRAY
64905: PPUSH
64906: LD_INT 2
64908: PUSH
64909: LD_INT 30
64911: PUSH
64912: LD_INT 0
64914: PUSH
64915: EMPTY
64916: LIST
64917: LIST
64918: PUSH
64919: LD_INT 30
64921: PUSH
64922: LD_INT 1
64924: PUSH
64925: EMPTY
64926: LIST
64927: LIST
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: LIST
64933: PPUSH
64934: CALL_OW 72
64938: NOT
64939: OR
64940: IFFALSE 64944
// exit ;
64942: GO 68447
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64944: LD_ADDR_VAR 0 4
64948: PUSH
64949: LD_EXP 50
64953: PUSH
64954: LD_VAR 0 1
64958: ARRAY
64959: PPUSH
64960: LD_INT 2
64962: PUSH
64963: LD_INT 25
64965: PUSH
64966: LD_INT 1
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: PUSH
64973: LD_INT 25
64975: PUSH
64976: LD_INT 2
64978: PUSH
64979: EMPTY
64980: LIST
64981: LIST
64982: PUSH
64983: LD_INT 25
64985: PUSH
64986: LD_INT 3
64988: PUSH
64989: EMPTY
64990: LIST
64991: LIST
64992: PUSH
64993: LD_INT 25
64995: PUSH
64996: LD_INT 4
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PUSH
65003: LD_INT 25
65005: PUSH
65006: LD_INT 5
65008: PUSH
65009: EMPTY
65010: LIST
65011: LIST
65012: PUSH
65013: LD_INT 25
65015: PUSH
65016: LD_INT 8
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: LD_INT 25
65025: PUSH
65026: LD_INT 9
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: LIST
65037: LIST
65038: LIST
65039: LIST
65040: LIST
65041: LIST
65042: PPUSH
65043: CALL_OW 72
65047: ST_TO_ADDR
// if not tmp then
65048: LD_VAR 0 4
65052: NOT
65053: IFFALSE 65057
// exit ;
65055: GO 68447
// for i in tmp do
65057: LD_ADDR_VAR 0 3
65061: PUSH
65062: LD_VAR 0 4
65066: PUSH
65067: FOR_IN
65068: IFFALSE 65099
// if GetTag ( i ) then
65070: LD_VAR 0 3
65074: PPUSH
65075: CALL_OW 110
65079: IFFALSE 65097
// tmp := tmp diff i ;
65081: LD_ADDR_VAR 0 4
65085: PUSH
65086: LD_VAR 0 4
65090: PUSH
65091: LD_VAR 0 3
65095: DIFF
65096: ST_TO_ADDR
65097: GO 65067
65099: POP
65100: POP
// if not tmp then
65101: LD_VAR 0 4
65105: NOT
65106: IFFALSE 65110
// exit ;
65108: GO 68447
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65110: LD_ADDR_VAR 0 5
65114: PUSH
65115: LD_EXP 50
65119: PUSH
65120: LD_VAR 0 1
65124: ARRAY
65125: PPUSH
65126: LD_INT 2
65128: PUSH
65129: LD_INT 25
65131: PUSH
65132: LD_INT 1
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PUSH
65139: LD_INT 25
65141: PUSH
65142: LD_INT 5
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: PUSH
65149: LD_INT 25
65151: PUSH
65152: LD_INT 8
65154: PUSH
65155: EMPTY
65156: LIST
65157: LIST
65158: PUSH
65159: LD_INT 25
65161: PUSH
65162: LD_INT 9
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: EMPTY
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: PPUSH
65176: CALL_OW 72
65180: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
65181: LD_ADDR_VAR 0 6
65185: PUSH
65186: LD_EXP 50
65190: PUSH
65191: LD_VAR 0 1
65195: ARRAY
65196: PPUSH
65197: LD_INT 25
65199: PUSH
65200: LD_INT 2
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PPUSH
65207: CALL_OW 72
65211: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65212: LD_ADDR_VAR 0 7
65216: PUSH
65217: LD_EXP 50
65221: PUSH
65222: LD_VAR 0 1
65226: ARRAY
65227: PPUSH
65228: LD_INT 25
65230: PUSH
65231: LD_INT 3
65233: PUSH
65234: EMPTY
65235: LIST
65236: LIST
65237: PPUSH
65238: CALL_OW 72
65242: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
65243: LD_ADDR_VAR 0 8
65247: PUSH
65248: LD_EXP 50
65252: PUSH
65253: LD_VAR 0 1
65257: ARRAY
65258: PPUSH
65259: LD_INT 25
65261: PUSH
65262: LD_INT 4
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: PUSH
65269: LD_INT 24
65271: PUSH
65272: LD_INT 251
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: EMPTY
65280: LIST
65281: LIST
65282: PPUSH
65283: CALL_OW 72
65287: ST_TO_ADDR
// if mc_is_defending [ base ] then
65288: LD_EXP 93
65292: PUSH
65293: LD_VAR 0 1
65297: ARRAY
65298: IFFALSE 65759
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
65300: LD_ADDR_EXP 92
65304: PUSH
65305: LD_EXP 92
65309: PPUSH
65310: LD_VAR 0 1
65314: PPUSH
65315: LD_INT 4
65317: PPUSH
65318: CALL_OW 1
65322: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65323: LD_ADDR_VAR 0 12
65327: PUSH
65328: LD_EXP 50
65332: PUSH
65333: LD_VAR 0 1
65337: ARRAY
65338: PPUSH
65339: LD_INT 2
65341: PUSH
65342: LD_INT 30
65344: PUSH
65345: LD_INT 4
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: PUSH
65352: LD_INT 30
65354: PUSH
65355: LD_INT 5
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: LIST
65366: PPUSH
65367: CALL_OW 72
65371: ST_TO_ADDR
// if not b then
65372: LD_VAR 0 12
65376: NOT
65377: IFFALSE 65381
// exit ;
65379: GO 68447
// p := [ ] ;
65381: LD_ADDR_VAR 0 11
65385: PUSH
65386: EMPTY
65387: ST_TO_ADDR
// if sci >= 2 then
65388: LD_VAR 0 8
65392: PUSH
65393: LD_INT 2
65395: GREATEREQUAL
65396: IFFALSE 65427
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
65398: LD_ADDR_VAR 0 8
65402: PUSH
65403: LD_VAR 0 8
65407: PUSH
65408: LD_INT 1
65410: ARRAY
65411: PUSH
65412: LD_VAR 0 8
65416: PUSH
65417: LD_INT 2
65419: ARRAY
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: ST_TO_ADDR
65425: GO 65488
// if sci = 1 then
65427: LD_VAR 0 8
65431: PUSH
65432: LD_INT 1
65434: EQUAL
65435: IFFALSE 65456
// sci := [ sci [ 1 ] ] else
65437: LD_ADDR_VAR 0 8
65441: PUSH
65442: LD_VAR 0 8
65446: PUSH
65447: LD_INT 1
65449: ARRAY
65450: PUSH
65451: EMPTY
65452: LIST
65453: ST_TO_ADDR
65454: GO 65488
// if sci = 0 then
65456: LD_VAR 0 8
65460: PUSH
65461: LD_INT 0
65463: EQUAL
65464: IFFALSE 65488
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
65466: LD_ADDR_VAR 0 11
65470: PUSH
65471: LD_VAR 0 4
65475: PPUSH
65476: LD_INT 4
65478: PPUSH
65479: CALL 55115 0 2
65483: PUSH
65484: LD_INT 1
65486: ARRAY
65487: ST_TO_ADDR
// if eng > 4 then
65488: LD_VAR 0 6
65492: PUSH
65493: LD_INT 4
65495: GREATER
65496: IFFALSE 65542
// for i = eng downto 4 do
65498: LD_ADDR_VAR 0 3
65502: PUSH
65503: DOUBLE
65504: LD_VAR 0 6
65508: INC
65509: ST_TO_ADDR
65510: LD_INT 4
65512: PUSH
65513: FOR_DOWNTO
65514: IFFALSE 65540
// eng := eng diff eng [ i ] ;
65516: LD_ADDR_VAR 0 6
65520: PUSH
65521: LD_VAR 0 6
65525: PUSH
65526: LD_VAR 0 6
65530: PUSH
65531: LD_VAR 0 3
65535: ARRAY
65536: DIFF
65537: ST_TO_ADDR
65538: GO 65513
65540: POP
65541: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
65542: LD_ADDR_VAR 0 4
65546: PUSH
65547: LD_VAR 0 4
65551: PUSH
65552: LD_VAR 0 5
65556: PUSH
65557: LD_VAR 0 6
65561: UNION
65562: PUSH
65563: LD_VAR 0 7
65567: UNION
65568: PUSH
65569: LD_VAR 0 8
65573: UNION
65574: DIFF
65575: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
65576: LD_ADDR_VAR 0 13
65580: PUSH
65581: LD_EXP 50
65585: PUSH
65586: LD_VAR 0 1
65590: ARRAY
65591: PPUSH
65592: LD_INT 2
65594: PUSH
65595: LD_INT 30
65597: PUSH
65598: LD_INT 32
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 30
65607: PUSH
65608: LD_INT 31
65610: PUSH
65611: EMPTY
65612: LIST
65613: LIST
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: LIST
65619: PPUSH
65620: CALL_OW 72
65624: PUSH
65625: LD_EXP 50
65629: PUSH
65630: LD_VAR 0 1
65634: ARRAY
65635: PPUSH
65636: LD_INT 2
65638: PUSH
65639: LD_INT 30
65641: PUSH
65642: LD_INT 4
65644: PUSH
65645: EMPTY
65646: LIST
65647: LIST
65648: PUSH
65649: LD_INT 30
65651: PUSH
65652: LD_INT 5
65654: PUSH
65655: EMPTY
65656: LIST
65657: LIST
65658: PUSH
65659: EMPTY
65660: LIST
65661: LIST
65662: LIST
65663: PPUSH
65664: CALL_OW 72
65668: PUSH
65669: LD_INT 6
65671: MUL
65672: PLUS
65673: ST_TO_ADDR
// if bcount < tmp then
65674: LD_VAR 0 13
65678: PUSH
65679: LD_VAR 0 4
65683: LESS
65684: IFFALSE 65730
// for i = tmp downto bcount do
65686: LD_ADDR_VAR 0 3
65690: PUSH
65691: DOUBLE
65692: LD_VAR 0 4
65696: INC
65697: ST_TO_ADDR
65698: LD_VAR 0 13
65702: PUSH
65703: FOR_DOWNTO
65704: IFFALSE 65728
// tmp := Delete ( tmp , tmp ) ;
65706: LD_ADDR_VAR 0 4
65710: PUSH
65711: LD_VAR 0 4
65715: PPUSH
65716: LD_VAR 0 4
65720: PPUSH
65721: CALL_OW 3
65725: ST_TO_ADDR
65726: GO 65703
65728: POP
65729: POP
// result := [ tmp , 0 , 0 , p ] ;
65730: LD_ADDR_VAR 0 2
65734: PUSH
65735: LD_VAR 0 4
65739: PUSH
65740: LD_INT 0
65742: PUSH
65743: LD_INT 0
65745: PUSH
65746: LD_VAR 0 11
65750: PUSH
65751: EMPTY
65752: LIST
65753: LIST
65754: LIST
65755: LIST
65756: ST_TO_ADDR
// exit ;
65757: GO 68447
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65759: LD_EXP 50
65763: PUSH
65764: LD_VAR 0 1
65768: ARRAY
65769: PPUSH
65770: LD_INT 2
65772: PUSH
65773: LD_INT 30
65775: PUSH
65776: LD_INT 6
65778: PUSH
65779: EMPTY
65780: LIST
65781: LIST
65782: PUSH
65783: LD_INT 30
65785: PUSH
65786: LD_INT 7
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: PUSH
65793: LD_INT 30
65795: PUSH
65796: LD_INT 8
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: LIST
65807: LIST
65808: PPUSH
65809: CALL_OW 72
65813: NOT
65814: PUSH
65815: LD_EXP 50
65819: PUSH
65820: LD_VAR 0 1
65824: ARRAY
65825: PPUSH
65826: LD_INT 30
65828: PUSH
65829: LD_INT 3
65831: PUSH
65832: EMPTY
65833: LIST
65834: LIST
65835: PPUSH
65836: CALL_OW 72
65840: NOT
65841: AND
65842: IFFALSE 65914
// begin if eng = tmp then
65844: LD_VAR 0 6
65848: PUSH
65849: LD_VAR 0 4
65853: EQUAL
65854: IFFALSE 65858
// exit ;
65856: GO 68447
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
65858: LD_ADDR_EXP 92
65862: PUSH
65863: LD_EXP 92
65867: PPUSH
65868: LD_VAR 0 1
65872: PPUSH
65873: LD_INT 1
65875: PPUSH
65876: CALL_OW 1
65880: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
65881: LD_ADDR_VAR 0 2
65885: PUSH
65886: LD_INT 0
65888: PUSH
65889: LD_VAR 0 4
65893: PUSH
65894: LD_VAR 0 6
65898: DIFF
65899: PUSH
65900: LD_INT 0
65902: PUSH
65903: LD_INT 0
65905: PUSH
65906: EMPTY
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: ST_TO_ADDR
// exit ;
65912: GO 68447
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65914: LD_EXP 77
65918: PUSH
65919: LD_EXP 76
65923: PUSH
65924: LD_VAR 0 1
65928: ARRAY
65929: ARRAY
65930: PUSH
65931: LD_EXP 50
65935: PUSH
65936: LD_VAR 0 1
65940: ARRAY
65941: PPUSH
65942: LD_INT 2
65944: PUSH
65945: LD_INT 30
65947: PUSH
65948: LD_INT 6
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 30
65957: PUSH
65958: LD_INT 7
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: LD_INT 30
65967: PUSH
65968: LD_INT 8
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: EMPTY
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: PPUSH
65981: CALL_OW 72
65985: AND
65986: PUSH
65987: LD_EXP 50
65991: PUSH
65992: LD_VAR 0 1
65996: ARRAY
65997: PPUSH
65998: LD_INT 30
66000: PUSH
66001: LD_INT 3
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PPUSH
66008: CALL_OW 72
66012: NOT
66013: AND
66014: IFFALSE 66228
// begin if sci >= 6 then
66016: LD_VAR 0 8
66020: PUSH
66021: LD_INT 6
66023: GREATEREQUAL
66024: IFFALSE 66028
// exit ;
66026: GO 68447
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
66028: LD_ADDR_EXP 92
66032: PUSH
66033: LD_EXP 92
66037: PPUSH
66038: LD_VAR 0 1
66042: PPUSH
66043: LD_INT 2
66045: PPUSH
66046: CALL_OW 1
66050: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
66051: LD_ADDR_VAR 0 9
66055: PUSH
66056: LD_VAR 0 4
66060: PUSH
66061: LD_VAR 0 8
66065: DIFF
66066: PPUSH
66067: LD_INT 4
66069: PPUSH
66070: CALL 55115 0 2
66074: ST_TO_ADDR
// p := [ ] ;
66075: LD_ADDR_VAR 0 11
66079: PUSH
66080: EMPTY
66081: ST_TO_ADDR
// if sci < 6 and sort > 6 then
66082: LD_VAR 0 8
66086: PUSH
66087: LD_INT 6
66089: LESS
66090: PUSH
66091: LD_VAR 0 9
66095: PUSH
66096: LD_INT 6
66098: GREATER
66099: AND
66100: IFFALSE 66181
// begin for i = 1 to 6 - sci do
66102: LD_ADDR_VAR 0 3
66106: PUSH
66107: DOUBLE
66108: LD_INT 1
66110: DEC
66111: ST_TO_ADDR
66112: LD_INT 6
66114: PUSH
66115: LD_VAR 0 8
66119: MINUS
66120: PUSH
66121: FOR_TO
66122: IFFALSE 66177
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
66124: LD_ADDR_VAR 0 11
66128: PUSH
66129: LD_VAR 0 11
66133: PPUSH
66134: LD_VAR 0 11
66138: PUSH
66139: LD_INT 1
66141: PLUS
66142: PPUSH
66143: LD_VAR 0 9
66147: PUSH
66148: LD_INT 1
66150: ARRAY
66151: PPUSH
66152: CALL_OW 2
66156: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
66157: LD_ADDR_VAR 0 9
66161: PUSH
66162: LD_VAR 0 9
66166: PPUSH
66167: LD_INT 1
66169: PPUSH
66170: CALL_OW 3
66174: ST_TO_ADDR
// end ;
66175: GO 66121
66177: POP
66178: POP
// end else
66179: GO 66201
// if sort then
66181: LD_VAR 0 9
66185: IFFALSE 66201
// p := sort [ 1 ] ;
66187: LD_ADDR_VAR 0 11
66191: PUSH
66192: LD_VAR 0 9
66196: PUSH
66197: LD_INT 1
66199: ARRAY
66200: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
66201: LD_ADDR_VAR 0 2
66205: PUSH
66206: LD_INT 0
66208: PUSH
66209: LD_INT 0
66211: PUSH
66212: LD_INT 0
66214: PUSH
66215: LD_VAR 0 11
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: ST_TO_ADDR
// exit ;
66226: GO 68447
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66228: LD_EXP 77
66232: PUSH
66233: LD_EXP 76
66237: PUSH
66238: LD_VAR 0 1
66242: ARRAY
66243: ARRAY
66244: PUSH
66245: LD_EXP 50
66249: PUSH
66250: LD_VAR 0 1
66254: ARRAY
66255: PPUSH
66256: LD_INT 2
66258: PUSH
66259: LD_INT 30
66261: PUSH
66262: LD_INT 6
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 30
66271: PUSH
66272: LD_INT 7
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: LD_INT 30
66281: PUSH
66282: LD_INT 8
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: PPUSH
66295: CALL_OW 72
66299: AND
66300: PUSH
66301: LD_EXP 50
66305: PUSH
66306: LD_VAR 0 1
66310: ARRAY
66311: PPUSH
66312: LD_INT 30
66314: PUSH
66315: LD_INT 3
66317: PUSH
66318: EMPTY
66319: LIST
66320: LIST
66321: PPUSH
66322: CALL_OW 72
66326: AND
66327: IFFALSE 67061
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
66329: LD_ADDR_EXP 92
66333: PUSH
66334: LD_EXP 92
66338: PPUSH
66339: LD_VAR 0 1
66343: PPUSH
66344: LD_INT 3
66346: PPUSH
66347: CALL_OW 1
66351: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66352: LD_ADDR_VAR 0 2
66356: PUSH
66357: LD_INT 0
66359: PUSH
66360: LD_INT 0
66362: PUSH
66363: LD_INT 0
66365: PUSH
66366: LD_INT 0
66368: PUSH
66369: EMPTY
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: ST_TO_ADDR
// if not eng then
66375: LD_VAR 0 6
66379: NOT
66380: IFFALSE 66443
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
66382: LD_ADDR_VAR 0 11
66386: PUSH
66387: LD_VAR 0 4
66391: PPUSH
66392: LD_INT 2
66394: PPUSH
66395: CALL 55115 0 2
66399: PUSH
66400: LD_INT 1
66402: ARRAY
66403: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
66404: LD_ADDR_VAR 0 2
66408: PUSH
66409: LD_VAR 0 2
66413: PPUSH
66414: LD_INT 2
66416: PPUSH
66417: LD_VAR 0 11
66421: PPUSH
66422: CALL_OW 1
66426: ST_TO_ADDR
// tmp := tmp diff p ;
66427: LD_ADDR_VAR 0 4
66431: PUSH
66432: LD_VAR 0 4
66436: PUSH
66437: LD_VAR 0 11
66441: DIFF
66442: ST_TO_ADDR
// end ; if tmp and sci < 6 then
66443: LD_VAR 0 4
66447: PUSH
66448: LD_VAR 0 8
66452: PUSH
66453: LD_INT 6
66455: LESS
66456: AND
66457: IFFALSE 66645
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
66459: LD_ADDR_VAR 0 9
66463: PUSH
66464: LD_VAR 0 4
66468: PUSH
66469: LD_VAR 0 8
66473: PUSH
66474: LD_VAR 0 7
66478: UNION
66479: DIFF
66480: PPUSH
66481: LD_INT 4
66483: PPUSH
66484: CALL 55115 0 2
66488: ST_TO_ADDR
// p := [ ] ;
66489: LD_ADDR_VAR 0 11
66493: PUSH
66494: EMPTY
66495: ST_TO_ADDR
// if sort then
66496: LD_VAR 0 9
66500: IFFALSE 66616
// for i = 1 to 6 - sci do
66502: LD_ADDR_VAR 0 3
66506: PUSH
66507: DOUBLE
66508: LD_INT 1
66510: DEC
66511: ST_TO_ADDR
66512: LD_INT 6
66514: PUSH
66515: LD_VAR 0 8
66519: MINUS
66520: PUSH
66521: FOR_TO
66522: IFFALSE 66614
// begin if i = sort then
66524: LD_VAR 0 3
66528: PUSH
66529: LD_VAR 0 9
66533: EQUAL
66534: IFFALSE 66538
// break ;
66536: GO 66614
// if GetClass ( i ) = 4 then
66538: LD_VAR 0 3
66542: PPUSH
66543: CALL_OW 257
66547: PUSH
66548: LD_INT 4
66550: EQUAL
66551: IFFALSE 66555
// continue ;
66553: GO 66521
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66555: LD_ADDR_VAR 0 11
66559: PUSH
66560: LD_VAR 0 11
66564: PPUSH
66565: LD_VAR 0 11
66569: PUSH
66570: LD_INT 1
66572: PLUS
66573: PPUSH
66574: LD_VAR 0 9
66578: PUSH
66579: LD_VAR 0 3
66583: ARRAY
66584: PPUSH
66585: CALL_OW 2
66589: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66590: LD_ADDR_VAR 0 4
66594: PUSH
66595: LD_VAR 0 4
66599: PUSH
66600: LD_VAR 0 9
66604: PUSH
66605: LD_VAR 0 3
66609: ARRAY
66610: DIFF
66611: ST_TO_ADDR
// end ;
66612: GO 66521
66614: POP
66615: POP
// if p then
66616: LD_VAR 0 11
66620: IFFALSE 66645
// result := Replace ( result , 4 , p ) ;
66622: LD_ADDR_VAR 0 2
66626: PUSH
66627: LD_VAR 0 2
66631: PPUSH
66632: LD_INT 4
66634: PPUSH
66635: LD_VAR 0 11
66639: PPUSH
66640: CALL_OW 1
66644: ST_TO_ADDR
// end ; if tmp and mech < 6 then
66645: LD_VAR 0 4
66649: PUSH
66650: LD_VAR 0 7
66654: PUSH
66655: LD_INT 6
66657: LESS
66658: AND
66659: IFFALSE 66847
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
66661: LD_ADDR_VAR 0 9
66665: PUSH
66666: LD_VAR 0 4
66670: PUSH
66671: LD_VAR 0 8
66675: PUSH
66676: LD_VAR 0 7
66680: UNION
66681: DIFF
66682: PPUSH
66683: LD_INT 3
66685: PPUSH
66686: CALL 55115 0 2
66690: ST_TO_ADDR
// p := [ ] ;
66691: LD_ADDR_VAR 0 11
66695: PUSH
66696: EMPTY
66697: ST_TO_ADDR
// if sort then
66698: LD_VAR 0 9
66702: IFFALSE 66818
// for i = 1 to 6 - mech do
66704: LD_ADDR_VAR 0 3
66708: PUSH
66709: DOUBLE
66710: LD_INT 1
66712: DEC
66713: ST_TO_ADDR
66714: LD_INT 6
66716: PUSH
66717: LD_VAR 0 7
66721: MINUS
66722: PUSH
66723: FOR_TO
66724: IFFALSE 66816
// begin if i = sort then
66726: LD_VAR 0 3
66730: PUSH
66731: LD_VAR 0 9
66735: EQUAL
66736: IFFALSE 66740
// break ;
66738: GO 66816
// if GetClass ( i ) = 3 then
66740: LD_VAR 0 3
66744: PPUSH
66745: CALL_OW 257
66749: PUSH
66750: LD_INT 3
66752: EQUAL
66753: IFFALSE 66757
// continue ;
66755: GO 66723
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66757: LD_ADDR_VAR 0 11
66761: PUSH
66762: LD_VAR 0 11
66766: PPUSH
66767: LD_VAR 0 11
66771: PUSH
66772: LD_INT 1
66774: PLUS
66775: PPUSH
66776: LD_VAR 0 9
66780: PUSH
66781: LD_VAR 0 3
66785: ARRAY
66786: PPUSH
66787: CALL_OW 2
66791: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66792: LD_ADDR_VAR 0 4
66796: PUSH
66797: LD_VAR 0 4
66801: PUSH
66802: LD_VAR 0 9
66806: PUSH
66807: LD_VAR 0 3
66811: ARRAY
66812: DIFF
66813: ST_TO_ADDR
// end ;
66814: GO 66723
66816: POP
66817: POP
// if p then
66818: LD_VAR 0 11
66822: IFFALSE 66847
// result := Replace ( result , 3 , p ) ;
66824: LD_ADDR_VAR 0 2
66828: PUSH
66829: LD_VAR 0 2
66833: PPUSH
66834: LD_INT 3
66836: PPUSH
66837: LD_VAR 0 11
66841: PPUSH
66842: CALL_OW 1
66846: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
66847: LD_VAR 0 4
66851: PUSH
66852: LD_INT 6
66854: GREATER
66855: PUSH
66856: LD_VAR 0 6
66860: PUSH
66861: LD_INT 6
66863: LESS
66864: AND
66865: IFFALSE 67059
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66867: LD_ADDR_VAR 0 9
66871: PUSH
66872: LD_VAR 0 4
66876: PUSH
66877: LD_VAR 0 8
66881: PUSH
66882: LD_VAR 0 7
66886: UNION
66887: PUSH
66888: LD_VAR 0 6
66892: UNION
66893: DIFF
66894: PPUSH
66895: LD_INT 2
66897: PPUSH
66898: CALL 55115 0 2
66902: ST_TO_ADDR
// p := [ ] ;
66903: LD_ADDR_VAR 0 11
66907: PUSH
66908: EMPTY
66909: ST_TO_ADDR
// if sort then
66910: LD_VAR 0 9
66914: IFFALSE 67030
// for i = 1 to 6 - eng do
66916: LD_ADDR_VAR 0 3
66920: PUSH
66921: DOUBLE
66922: LD_INT 1
66924: DEC
66925: ST_TO_ADDR
66926: LD_INT 6
66928: PUSH
66929: LD_VAR 0 6
66933: MINUS
66934: PUSH
66935: FOR_TO
66936: IFFALSE 67028
// begin if i = sort then
66938: LD_VAR 0 3
66942: PUSH
66943: LD_VAR 0 9
66947: EQUAL
66948: IFFALSE 66952
// break ;
66950: GO 67028
// if GetClass ( i ) = 2 then
66952: LD_VAR 0 3
66956: PPUSH
66957: CALL_OW 257
66961: PUSH
66962: LD_INT 2
66964: EQUAL
66965: IFFALSE 66969
// continue ;
66967: GO 66935
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66969: LD_ADDR_VAR 0 11
66973: PUSH
66974: LD_VAR 0 11
66978: PPUSH
66979: LD_VAR 0 11
66983: PUSH
66984: LD_INT 1
66986: PLUS
66987: PPUSH
66988: LD_VAR 0 9
66992: PUSH
66993: LD_VAR 0 3
66997: ARRAY
66998: PPUSH
66999: CALL_OW 2
67003: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67004: LD_ADDR_VAR 0 4
67008: PUSH
67009: LD_VAR 0 4
67013: PUSH
67014: LD_VAR 0 9
67018: PUSH
67019: LD_VAR 0 3
67023: ARRAY
67024: DIFF
67025: ST_TO_ADDR
// end ;
67026: GO 66935
67028: POP
67029: POP
// if p then
67030: LD_VAR 0 11
67034: IFFALSE 67059
// result := Replace ( result , 2 , p ) ;
67036: LD_ADDR_VAR 0 2
67040: PUSH
67041: LD_VAR 0 2
67045: PPUSH
67046: LD_INT 2
67048: PPUSH
67049: LD_VAR 0 11
67053: PPUSH
67054: CALL_OW 1
67058: ST_TO_ADDR
// end ; exit ;
67059: GO 68447
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
67061: LD_EXP 77
67065: PUSH
67066: LD_EXP 76
67070: PUSH
67071: LD_VAR 0 1
67075: ARRAY
67076: ARRAY
67077: NOT
67078: PUSH
67079: LD_EXP 50
67083: PUSH
67084: LD_VAR 0 1
67088: ARRAY
67089: PPUSH
67090: LD_INT 30
67092: PUSH
67093: LD_INT 3
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PPUSH
67100: CALL_OW 72
67104: AND
67105: PUSH
67106: LD_EXP 55
67110: PUSH
67111: LD_VAR 0 1
67115: ARRAY
67116: AND
67117: IFFALSE 67725
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
67119: LD_ADDR_EXP 92
67123: PUSH
67124: LD_EXP 92
67128: PPUSH
67129: LD_VAR 0 1
67133: PPUSH
67134: LD_INT 5
67136: PPUSH
67137: CALL_OW 1
67141: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67142: LD_ADDR_VAR 0 2
67146: PUSH
67147: LD_INT 0
67149: PUSH
67150: LD_INT 0
67152: PUSH
67153: LD_INT 0
67155: PUSH
67156: LD_INT 0
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: LIST
67163: LIST
67164: ST_TO_ADDR
// if sci > 1 then
67165: LD_VAR 0 8
67169: PUSH
67170: LD_INT 1
67172: GREATER
67173: IFFALSE 67201
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
67175: LD_ADDR_VAR 0 4
67179: PUSH
67180: LD_VAR 0 4
67184: PUSH
67185: LD_VAR 0 8
67189: PUSH
67190: LD_VAR 0 8
67194: PUSH
67195: LD_INT 1
67197: ARRAY
67198: DIFF
67199: DIFF
67200: ST_TO_ADDR
// if tmp and not sci then
67201: LD_VAR 0 4
67205: PUSH
67206: LD_VAR 0 8
67210: NOT
67211: AND
67212: IFFALSE 67281
// begin sort := SortBySkill ( tmp , 4 ) ;
67214: LD_ADDR_VAR 0 9
67218: PUSH
67219: LD_VAR 0 4
67223: PPUSH
67224: LD_INT 4
67226: PPUSH
67227: CALL 55115 0 2
67231: ST_TO_ADDR
// if sort then
67232: LD_VAR 0 9
67236: IFFALSE 67252
// p := sort [ 1 ] ;
67238: LD_ADDR_VAR 0 11
67242: PUSH
67243: LD_VAR 0 9
67247: PUSH
67248: LD_INT 1
67250: ARRAY
67251: ST_TO_ADDR
// if p then
67252: LD_VAR 0 11
67256: IFFALSE 67281
// result := Replace ( result , 4 , p ) ;
67258: LD_ADDR_VAR 0 2
67262: PUSH
67263: LD_VAR 0 2
67267: PPUSH
67268: LD_INT 4
67270: PPUSH
67271: LD_VAR 0 11
67275: PPUSH
67276: CALL_OW 1
67280: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67281: LD_ADDR_VAR 0 4
67285: PUSH
67286: LD_VAR 0 4
67290: PUSH
67291: LD_VAR 0 7
67295: DIFF
67296: ST_TO_ADDR
// if tmp and mech < 6 then
67297: LD_VAR 0 4
67301: PUSH
67302: LD_VAR 0 7
67306: PUSH
67307: LD_INT 6
67309: LESS
67310: AND
67311: IFFALSE 67499
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67313: LD_ADDR_VAR 0 9
67317: PUSH
67318: LD_VAR 0 4
67322: PUSH
67323: LD_VAR 0 8
67327: PUSH
67328: LD_VAR 0 7
67332: UNION
67333: DIFF
67334: PPUSH
67335: LD_INT 3
67337: PPUSH
67338: CALL 55115 0 2
67342: ST_TO_ADDR
// p := [ ] ;
67343: LD_ADDR_VAR 0 11
67347: PUSH
67348: EMPTY
67349: ST_TO_ADDR
// if sort then
67350: LD_VAR 0 9
67354: IFFALSE 67470
// for i = 1 to 6 - mech do
67356: LD_ADDR_VAR 0 3
67360: PUSH
67361: DOUBLE
67362: LD_INT 1
67364: DEC
67365: ST_TO_ADDR
67366: LD_INT 6
67368: PUSH
67369: LD_VAR 0 7
67373: MINUS
67374: PUSH
67375: FOR_TO
67376: IFFALSE 67468
// begin if i = sort then
67378: LD_VAR 0 3
67382: PUSH
67383: LD_VAR 0 9
67387: EQUAL
67388: IFFALSE 67392
// break ;
67390: GO 67468
// if GetClass ( i ) = 3 then
67392: LD_VAR 0 3
67396: PPUSH
67397: CALL_OW 257
67401: PUSH
67402: LD_INT 3
67404: EQUAL
67405: IFFALSE 67409
// continue ;
67407: GO 67375
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67409: LD_ADDR_VAR 0 11
67413: PUSH
67414: LD_VAR 0 11
67418: PPUSH
67419: LD_VAR 0 11
67423: PUSH
67424: LD_INT 1
67426: PLUS
67427: PPUSH
67428: LD_VAR 0 9
67432: PUSH
67433: LD_VAR 0 3
67437: ARRAY
67438: PPUSH
67439: CALL_OW 2
67443: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67444: LD_ADDR_VAR 0 4
67448: PUSH
67449: LD_VAR 0 4
67453: PUSH
67454: LD_VAR 0 9
67458: PUSH
67459: LD_VAR 0 3
67463: ARRAY
67464: DIFF
67465: ST_TO_ADDR
// end ;
67466: GO 67375
67468: POP
67469: POP
// if p then
67470: LD_VAR 0 11
67474: IFFALSE 67499
// result := Replace ( result , 3 , p ) ;
67476: LD_ADDR_VAR 0 2
67480: PUSH
67481: LD_VAR 0 2
67485: PPUSH
67486: LD_INT 3
67488: PPUSH
67489: LD_VAR 0 11
67493: PPUSH
67494: CALL_OW 1
67498: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
67499: LD_ADDR_VAR 0 4
67503: PUSH
67504: LD_VAR 0 4
67508: PUSH
67509: LD_VAR 0 6
67513: DIFF
67514: ST_TO_ADDR
// if tmp and eng < 6 then
67515: LD_VAR 0 4
67519: PUSH
67520: LD_VAR 0 6
67524: PUSH
67525: LD_INT 6
67527: LESS
67528: AND
67529: IFFALSE 67723
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67531: LD_ADDR_VAR 0 9
67535: PUSH
67536: LD_VAR 0 4
67540: PUSH
67541: LD_VAR 0 8
67545: PUSH
67546: LD_VAR 0 7
67550: UNION
67551: PUSH
67552: LD_VAR 0 6
67556: UNION
67557: DIFF
67558: PPUSH
67559: LD_INT 2
67561: PPUSH
67562: CALL 55115 0 2
67566: ST_TO_ADDR
// p := [ ] ;
67567: LD_ADDR_VAR 0 11
67571: PUSH
67572: EMPTY
67573: ST_TO_ADDR
// if sort then
67574: LD_VAR 0 9
67578: IFFALSE 67694
// for i = 1 to 6 - eng do
67580: LD_ADDR_VAR 0 3
67584: PUSH
67585: DOUBLE
67586: LD_INT 1
67588: DEC
67589: ST_TO_ADDR
67590: LD_INT 6
67592: PUSH
67593: LD_VAR 0 6
67597: MINUS
67598: PUSH
67599: FOR_TO
67600: IFFALSE 67692
// begin if i = sort then
67602: LD_VAR 0 3
67606: PUSH
67607: LD_VAR 0 9
67611: EQUAL
67612: IFFALSE 67616
// break ;
67614: GO 67692
// if GetClass ( i ) = 2 then
67616: LD_VAR 0 3
67620: PPUSH
67621: CALL_OW 257
67625: PUSH
67626: LD_INT 2
67628: EQUAL
67629: IFFALSE 67633
// continue ;
67631: GO 67599
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67633: LD_ADDR_VAR 0 11
67637: PUSH
67638: LD_VAR 0 11
67642: PPUSH
67643: LD_VAR 0 11
67647: PUSH
67648: LD_INT 1
67650: PLUS
67651: PPUSH
67652: LD_VAR 0 9
67656: PUSH
67657: LD_VAR 0 3
67661: ARRAY
67662: PPUSH
67663: CALL_OW 2
67667: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67668: LD_ADDR_VAR 0 4
67672: PUSH
67673: LD_VAR 0 4
67677: PUSH
67678: LD_VAR 0 9
67682: PUSH
67683: LD_VAR 0 3
67687: ARRAY
67688: DIFF
67689: ST_TO_ADDR
// end ;
67690: GO 67599
67692: POP
67693: POP
// if p then
67694: LD_VAR 0 11
67698: IFFALSE 67723
// result := Replace ( result , 2 , p ) ;
67700: LD_ADDR_VAR 0 2
67704: PUSH
67705: LD_VAR 0 2
67709: PPUSH
67710: LD_INT 2
67712: PPUSH
67713: LD_VAR 0 11
67717: PPUSH
67718: CALL_OW 1
67722: ST_TO_ADDR
// end ; exit ;
67723: GO 68447
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
67725: LD_EXP 77
67729: PUSH
67730: LD_EXP 76
67734: PUSH
67735: LD_VAR 0 1
67739: ARRAY
67740: ARRAY
67741: NOT
67742: PUSH
67743: LD_EXP 50
67747: PUSH
67748: LD_VAR 0 1
67752: ARRAY
67753: PPUSH
67754: LD_INT 30
67756: PUSH
67757: LD_INT 3
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PPUSH
67764: CALL_OW 72
67768: AND
67769: PUSH
67770: LD_EXP 55
67774: PUSH
67775: LD_VAR 0 1
67779: ARRAY
67780: NOT
67781: AND
67782: IFFALSE 68447
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
67784: LD_ADDR_EXP 92
67788: PUSH
67789: LD_EXP 92
67793: PPUSH
67794: LD_VAR 0 1
67798: PPUSH
67799: LD_INT 6
67801: PPUSH
67802: CALL_OW 1
67806: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67807: LD_ADDR_VAR 0 2
67811: PUSH
67812: LD_INT 0
67814: PUSH
67815: LD_INT 0
67817: PUSH
67818: LD_INT 0
67820: PUSH
67821: LD_INT 0
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: ST_TO_ADDR
// if sci >= 1 then
67830: LD_VAR 0 8
67834: PUSH
67835: LD_INT 1
67837: GREATEREQUAL
67838: IFFALSE 67860
// tmp := tmp diff sci [ 1 ] ;
67840: LD_ADDR_VAR 0 4
67844: PUSH
67845: LD_VAR 0 4
67849: PUSH
67850: LD_VAR 0 8
67854: PUSH
67855: LD_INT 1
67857: ARRAY
67858: DIFF
67859: ST_TO_ADDR
// if tmp and not sci then
67860: LD_VAR 0 4
67864: PUSH
67865: LD_VAR 0 8
67869: NOT
67870: AND
67871: IFFALSE 67940
// begin sort := SortBySkill ( tmp , 4 ) ;
67873: LD_ADDR_VAR 0 9
67877: PUSH
67878: LD_VAR 0 4
67882: PPUSH
67883: LD_INT 4
67885: PPUSH
67886: CALL 55115 0 2
67890: ST_TO_ADDR
// if sort then
67891: LD_VAR 0 9
67895: IFFALSE 67911
// p := sort [ 1 ] ;
67897: LD_ADDR_VAR 0 11
67901: PUSH
67902: LD_VAR 0 9
67906: PUSH
67907: LD_INT 1
67909: ARRAY
67910: ST_TO_ADDR
// if p then
67911: LD_VAR 0 11
67915: IFFALSE 67940
// result := Replace ( result , 4 , p ) ;
67917: LD_ADDR_VAR 0 2
67921: PUSH
67922: LD_VAR 0 2
67926: PPUSH
67927: LD_INT 4
67929: PPUSH
67930: LD_VAR 0 11
67934: PPUSH
67935: CALL_OW 1
67939: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67940: LD_ADDR_VAR 0 4
67944: PUSH
67945: LD_VAR 0 4
67949: PUSH
67950: LD_VAR 0 7
67954: DIFF
67955: ST_TO_ADDR
// if tmp and mech < 6 then
67956: LD_VAR 0 4
67960: PUSH
67961: LD_VAR 0 7
67965: PUSH
67966: LD_INT 6
67968: LESS
67969: AND
67970: IFFALSE 68152
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
67972: LD_ADDR_VAR 0 9
67976: PUSH
67977: LD_VAR 0 4
67981: PUSH
67982: LD_VAR 0 7
67986: DIFF
67987: PPUSH
67988: LD_INT 3
67990: PPUSH
67991: CALL 55115 0 2
67995: ST_TO_ADDR
// p := [ ] ;
67996: LD_ADDR_VAR 0 11
68000: PUSH
68001: EMPTY
68002: ST_TO_ADDR
// if sort then
68003: LD_VAR 0 9
68007: IFFALSE 68123
// for i = 1 to 6 - mech do
68009: LD_ADDR_VAR 0 3
68013: PUSH
68014: DOUBLE
68015: LD_INT 1
68017: DEC
68018: ST_TO_ADDR
68019: LD_INT 6
68021: PUSH
68022: LD_VAR 0 7
68026: MINUS
68027: PUSH
68028: FOR_TO
68029: IFFALSE 68121
// begin if i = sort then
68031: LD_VAR 0 3
68035: PUSH
68036: LD_VAR 0 9
68040: EQUAL
68041: IFFALSE 68045
// break ;
68043: GO 68121
// if GetClass ( i ) = 3 then
68045: LD_VAR 0 3
68049: PPUSH
68050: CALL_OW 257
68054: PUSH
68055: LD_INT 3
68057: EQUAL
68058: IFFALSE 68062
// continue ;
68060: GO 68028
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68062: LD_ADDR_VAR 0 11
68066: PUSH
68067: LD_VAR 0 11
68071: PPUSH
68072: LD_VAR 0 11
68076: PUSH
68077: LD_INT 1
68079: PLUS
68080: PPUSH
68081: LD_VAR 0 9
68085: PUSH
68086: LD_VAR 0 3
68090: ARRAY
68091: PPUSH
68092: CALL_OW 2
68096: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68097: LD_ADDR_VAR 0 4
68101: PUSH
68102: LD_VAR 0 4
68106: PUSH
68107: LD_VAR 0 9
68111: PUSH
68112: LD_VAR 0 3
68116: ARRAY
68117: DIFF
68118: ST_TO_ADDR
// end ;
68119: GO 68028
68121: POP
68122: POP
// if p then
68123: LD_VAR 0 11
68127: IFFALSE 68152
// result := Replace ( result , 3 , p ) ;
68129: LD_ADDR_VAR 0 2
68133: PUSH
68134: LD_VAR 0 2
68138: PPUSH
68139: LD_INT 3
68141: PPUSH
68142: LD_VAR 0 11
68146: PPUSH
68147: CALL_OW 1
68151: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68152: LD_ADDR_VAR 0 4
68156: PUSH
68157: LD_VAR 0 4
68161: PUSH
68162: LD_VAR 0 6
68166: DIFF
68167: ST_TO_ADDR
// if tmp and eng < 4 then
68168: LD_VAR 0 4
68172: PUSH
68173: LD_VAR 0 6
68177: PUSH
68178: LD_INT 4
68180: LESS
68181: AND
68182: IFFALSE 68372
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
68184: LD_ADDR_VAR 0 9
68188: PUSH
68189: LD_VAR 0 4
68193: PUSH
68194: LD_VAR 0 7
68198: PUSH
68199: LD_VAR 0 6
68203: UNION
68204: DIFF
68205: PPUSH
68206: LD_INT 2
68208: PPUSH
68209: CALL 55115 0 2
68213: ST_TO_ADDR
// p := [ ] ;
68214: LD_ADDR_VAR 0 11
68218: PUSH
68219: EMPTY
68220: ST_TO_ADDR
// if sort then
68221: LD_VAR 0 9
68225: IFFALSE 68341
// for i = 1 to 4 - eng do
68227: LD_ADDR_VAR 0 3
68231: PUSH
68232: DOUBLE
68233: LD_INT 1
68235: DEC
68236: ST_TO_ADDR
68237: LD_INT 4
68239: PUSH
68240: LD_VAR 0 6
68244: MINUS
68245: PUSH
68246: FOR_TO
68247: IFFALSE 68339
// begin if i = sort then
68249: LD_VAR 0 3
68253: PUSH
68254: LD_VAR 0 9
68258: EQUAL
68259: IFFALSE 68263
// break ;
68261: GO 68339
// if GetClass ( i ) = 2 then
68263: LD_VAR 0 3
68267: PPUSH
68268: CALL_OW 257
68272: PUSH
68273: LD_INT 2
68275: EQUAL
68276: IFFALSE 68280
// continue ;
68278: GO 68246
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68280: LD_ADDR_VAR 0 11
68284: PUSH
68285: LD_VAR 0 11
68289: PPUSH
68290: LD_VAR 0 11
68294: PUSH
68295: LD_INT 1
68297: PLUS
68298: PPUSH
68299: LD_VAR 0 9
68303: PUSH
68304: LD_VAR 0 3
68308: ARRAY
68309: PPUSH
68310: CALL_OW 2
68314: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68315: LD_ADDR_VAR 0 4
68319: PUSH
68320: LD_VAR 0 4
68324: PUSH
68325: LD_VAR 0 9
68329: PUSH
68330: LD_VAR 0 3
68334: ARRAY
68335: DIFF
68336: ST_TO_ADDR
// end ;
68337: GO 68246
68339: POP
68340: POP
// if p then
68341: LD_VAR 0 11
68345: IFFALSE 68370
// result := Replace ( result , 2 , p ) ;
68347: LD_ADDR_VAR 0 2
68351: PUSH
68352: LD_VAR 0 2
68356: PPUSH
68357: LD_INT 2
68359: PPUSH
68360: LD_VAR 0 11
68364: PPUSH
68365: CALL_OW 1
68369: ST_TO_ADDR
// end else
68370: GO 68416
// for i = eng downto 5 do
68372: LD_ADDR_VAR 0 3
68376: PUSH
68377: DOUBLE
68378: LD_VAR 0 6
68382: INC
68383: ST_TO_ADDR
68384: LD_INT 5
68386: PUSH
68387: FOR_DOWNTO
68388: IFFALSE 68414
// tmp := tmp union eng [ i ] ;
68390: LD_ADDR_VAR 0 4
68394: PUSH
68395: LD_VAR 0 4
68399: PUSH
68400: LD_VAR 0 6
68404: PUSH
68405: LD_VAR 0 3
68409: ARRAY
68410: UNION
68411: ST_TO_ADDR
68412: GO 68387
68414: POP
68415: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
68416: LD_ADDR_VAR 0 2
68420: PUSH
68421: LD_VAR 0 2
68425: PPUSH
68426: LD_INT 1
68428: PPUSH
68429: LD_VAR 0 4
68433: PUSH
68434: LD_VAR 0 5
68438: DIFF
68439: PPUSH
68440: CALL_OW 1
68444: ST_TO_ADDR
// exit ;
68445: GO 68447
// end ; end ;
68447: LD_VAR 0 2
68451: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
68452: LD_INT 0
68454: PPUSH
68455: PPUSH
68456: PPUSH
// if not mc_bases then
68457: LD_EXP 50
68461: NOT
68462: IFFALSE 68466
// exit ;
68464: GO 68608
// for i = 1 to mc_bases do
68466: LD_ADDR_VAR 0 2
68470: PUSH
68471: DOUBLE
68472: LD_INT 1
68474: DEC
68475: ST_TO_ADDR
68476: LD_EXP 50
68480: PUSH
68481: FOR_TO
68482: IFFALSE 68599
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68484: LD_ADDR_VAR 0 3
68488: PUSH
68489: LD_EXP 50
68493: PUSH
68494: LD_VAR 0 2
68498: ARRAY
68499: PPUSH
68500: LD_INT 21
68502: PUSH
68503: LD_INT 3
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 3
68512: PUSH
68513: LD_INT 2
68515: PUSH
68516: LD_INT 30
68518: PUSH
68519: LD_INT 29
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: LD_INT 30
68528: PUSH
68529: LD_INT 30
68531: PUSH
68532: EMPTY
68533: LIST
68534: LIST
68535: PUSH
68536: EMPTY
68537: LIST
68538: LIST
68539: LIST
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 3
68547: PUSH
68548: LD_INT 24
68550: PUSH
68551: LD_INT 1000
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: LIST
68566: PPUSH
68567: CALL_OW 72
68571: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
68572: LD_ADDR_EXP 51
68576: PUSH
68577: LD_EXP 51
68581: PPUSH
68582: LD_VAR 0 2
68586: PPUSH
68587: LD_VAR 0 3
68591: PPUSH
68592: CALL_OW 1
68596: ST_TO_ADDR
// end ;
68597: GO 68481
68599: POP
68600: POP
// RaiseSailEvent ( 101 ) ;
68601: LD_INT 101
68603: PPUSH
68604: CALL_OW 427
// end ;
68608: LD_VAR 0 1
68612: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
68613: LD_INT 0
68615: PPUSH
68616: PPUSH
68617: PPUSH
68618: PPUSH
68619: PPUSH
68620: PPUSH
68621: PPUSH
// if not mc_bases then
68622: LD_EXP 50
68626: NOT
68627: IFFALSE 68631
// exit ;
68629: GO 69193
// for i = 1 to mc_bases do
68631: LD_ADDR_VAR 0 2
68635: PUSH
68636: DOUBLE
68637: LD_INT 1
68639: DEC
68640: ST_TO_ADDR
68641: LD_EXP 50
68645: PUSH
68646: FOR_TO
68647: IFFALSE 69184
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
68649: LD_ADDR_VAR 0 5
68653: PUSH
68654: LD_EXP 50
68658: PUSH
68659: LD_VAR 0 2
68663: ARRAY
68664: PUSH
68665: LD_EXP 79
68669: PUSH
68670: LD_VAR 0 2
68674: ARRAY
68675: UNION
68676: PPUSH
68677: LD_INT 21
68679: PUSH
68680: LD_INT 1
68682: PUSH
68683: EMPTY
68684: LIST
68685: LIST
68686: PUSH
68687: LD_INT 1
68689: PUSH
68690: LD_INT 3
68692: PUSH
68693: LD_INT 54
68695: PUSH
68696: EMPTY
68697: LIST
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 3
68705: PUSH
68706: LD_INT 24
68708: PUSH
68709: LD_INT 1000
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: PUSH
68720: EMPTY
68721: LIST
68722: LIST
68723: LIST
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PPUSH
68729: CALL_OW 72
68733: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
68734: LD_ADDR_VAR 0 6
68738: PUSH
68739: LD_EXP 50
68743: PUSH
68744: LD_VAR 0 2
68748: ARRAY
68749: PPUSH
68750: LD_INT 21
68752: PUSH
68753: LD_INT 1
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 1
68762: PUSH
68763: LD_INT 3
68765: PUSH
68766: LD_INT 54
68768: PUSH
68769: EMPTY
68770: LIST
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: PUSH
68776: LD_INT 3
68778: PUSH
68779: LD_INT 24
68781: PUSH
68782: LD_INT 250
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: LIST
68797: PUSH
68798: EMPTY
68799: LIST
68800: LIST
68801: PPUSH
68802: CALL_OW 72
68806: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
68807: LD_ADDR_VAR 0 7
68811: PUSH
68812: LD_VAR 0 5
68816: PUSH
68817: LD_VAR 0 6
68821: DIFF
68822: ST_TO_ADDR
// if not need_heal_1 then
68823: LD_VAR 0 6
68827: NOT
68828: IFFALSE 68861
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
68830: LD_ADDR_EXP 53
68834: PUSH
68835: LD_EXP 53
68839: PPUSH
68840: LD_VAR 0 2
68844: PUSH
68845: LD_INT 1
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PPUSH
68852: EMPTY
68853: PPUSH
68854: CALL 24858 0 3
68858: ST_TO_ADDR
68859: GO 68931
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
68861: LD_ADDR_EXP 53
68865: PUSH
68866: LD_EXP 53
68870: PPUSH
68871: LD_VAR 0 2
68875: PUSH
68876: LD_INT 1
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PPUSH
68883: LD_EXP 53
68887: PUSH
68888: LD_VAR 0 2
68892: ARRAY
68893: PUSH
68894: LD_INT 1
68896: ARRAY
68897: PPUSH
68898: LD_INT 3
68900: PUSH
68901: LD_INT 24
68903: PUSH
68904: LD_INT 1000
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PPUSH
68915: CALL_OW 72
68919: PUSH
68920: LD_VAR 0 6
68924: UNION
68925: PPUSH
68926: CALL 24858 0 3
68930: ST_TO_ADDR
// if not need_heal_2 then
68931: LD_VAR 0 7
68935: NOT
68936: IFFALSE 68969
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
68938: LD_ADDR_EXP 53
68942: PUSH
68943: LD_EXP 53
68947: PPUSH
68948: LD_VAR 0 2
68952: PUSH
68953: LD_INT 2
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PPUSH
68960: EMPTY
68961: PPUSH
68962: CALL 24858 0 3
68966: ST_TO_ADDR
68967: GO 69001
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
68969: LD_ADDR_EXP 53
68973: PUSH
68974: LD_EXP 53
68978: PPUSH
68979: LD_VAR 0 2
68983: PUSH
68984: LD_INT 2
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PPUSH
68991: LD_VAR 0 7
68995: PPUSH
68996: CALL 24858 0 3
69000: ST_TO_ADDR
// if need_heal_2 then
69001: LD_VAR 0 7
69005: IFFALSE 69166
// for j in need_heal_2 do
69007: LD_ADDR_VAR 0 3
69011: PUSH
69012: LD_VAR 0 7
69016: PUSH
69017: FOR_IN
69018: IFFALSE 69164
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69020: LD_ADDR_VAR 0 5
69024: PUSH
69025: LD_EXP 50
69029: PUSH
69030: LD_VAR 0 2
69034: ARRAY
69035: PPUSH
69036: LD_INT 2
69038: PUSH
69039: LD_INT 30
69041: PUSH
69042: LD_INT 6
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 30
69051: PUSH
69052: LD_INT 7
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 30
69061: PUSH
69062: LD_INT 8
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 30
69071: PUSH
69072: LD_INT 0
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: LD_INT 30
69081: PUSH
69082: LD_INT 1
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: PPUSH
69097: CALL_OW 72
69101: ST_TO_ADDR
// if tmp then
69102: LD_VAR 0 5
69106: IFFALSE 69162
// begin k := NearestUnitToUnit ( tmp , j ) ;
69108: LD_ADDR_VAR 0 4
69112: PUSH
69113: LD_VAR 0 5
69117: PPUSH
69118: LD_VAR 0 3
69122: PPUSH
69123: CALL_OW 74
69127: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
69128: LD_VAR 0 3
69132: PPUSH
69133: LD_VAR 0 4
69137: PPUSH
69138: CALL_OW 296
69142: PUSH
69143: LD_INT 5
69145: GREATER
69146: IFFALSE 69162
// ComMoveToNearbyEntrance ( j , k ) ;
69148: LD_VAR 0 3
69152: PPUSH
69153: LD_VAR 0 4
69157: PPUSH
69158: CALL 57476 0 2
// end ; end ;
69162: GO 69017
69164: POP
69165: POP
// if not need_heal_1 and not need_heal_2 then
69166: LD_VAR 0 6
69170: NOT
69171: PUSH
69172: LD_VAR 0 7
69176: NOT
69177: AND
69178: IFFALSE 69182
// continue ;
69180: GO 68646
// end ;
69182: GO 68646
69184: POP
69185: POP
// RaiseSailEvent ( 102 ) ;
69186: LD_INT 102
69188: PPUSH
69189: CALL_OW 427
// end ;
69193: LD_VAR 0 1
69197: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
69198: LD_INT 0
69200: PPUSH
69201: PPUSH
69202: PPUSH
69203: PPUSH
69204: PPUSH
69205: PPUSH
69206: PPUSH
69207: PPUSH
// if not mc_bases then
69208: LD_EXP 50
69212: NOT
69213: IFFALSE 69217
// exit ;
69215: GO 70100
// for i = 1 to mc_bases do
69217: LD_ADDR_VAR 0 2
69221: PUSH
69222: DOUBLE
69223: LD_INT 1
69225: DEC
69226: ST_TO_ADDR
69227: LD_EXP 50
69231: PUSH
69232: FOR_TO
69233: IFFALSE 70098
// begin if not mc_building_need_repair [ i ] then
69235: LD_EXP 51
69239: PUSH
69240: LD_VAR 0 2
69244: ARRAY
69245: NOT
69246: IFFALSE 69433
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
69248: LD_ADDR_VAR 0 6
69252: PUSH
69253: LD_EXP 69
69257: PUSH
69258: LD_VAR 0 2
69262: ARRAY
69263: PPUSH
69264: LD_INT 3
69266: PUSH
69267: LD_INT 24
69269: PUSH
69270: LD_INT 1000
69272: PUSH
69273: EMPTY
69274: LIST
69275: LIST
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: LD_INT 34
69286: PUSH
69287: LD_INT 13
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: PUSH
69294: LD_INT 34
69296: PUSH
69297: LD_INT 52
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PUSH
69304: LD_INT 34
69306: PUSH
69307: LD_EXP 35
69311: PUSH
69312: EMPTY
69313: LIST
69314: LIST
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PPUSH
69326: CALL_OW 72
69330: ST_TO_ADDR
// if cranes then
69331: LD_VAR 0 6
69335: IFFALSE 69397
// for j in cranes do
69337: LD_ADDR_VAR 0 3
69341: PUSH
69342: LD_VAR 0 6
69346: PUSH
69347: FOR_IN
69348: IFFALSE 69395
// if not IsInArea ( j , mc_parking [ i ] ) then
69350: LD_VAR 0 3
69354: PPUSH
69355: LD_EXP 74
69359: PUSH
69360: LD_VAR 0 2
69364: ARRAY
69365: PPUSH
69366: CALL_OW 308
69370: NOT
69371: IFFALSE 69393
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69373: LD_VAR 0 3
69377: PPUSH
69378: LD_EXP 74
69382: PUSH
69383: LD_VAR 0 2
69387: ARRAY
69388: PPUSH
69389: CALL_OW 113
69393: GO 69347
69395: POP
69396: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
69397: LD_ADDR_EXP 52
69401: PUSH
69402: LD_EXP 52
69406: PPUSH
69407: LD_VAR 0 2
69411: PPUSH
69412: EMPTY
69413: PPUSH
69414: CALL_OW 1
69418: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
69419: LD_VAR 0 2
69423: PPUSH
69424: LD_INT 101
69426: PPUSH
69427: CALL 64285 0 2
// continue ;
69431: GO 69232
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
69433: LD_ADDR_EXP 56
69437: PUSH
69438: LD_EXP 56
69442: PPUSH
69443: LD_VAR 0 2
69447: PPUSH
69448: EMPTY
69449: PPUSH
69450: CALL_OW 1
69454: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
69455: LD_VAR 0 2
69459: PPUSH
69460: LD_INT 103
69462: PPUSH
69463: CALL 64285 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
69467: LD_ADDR_VAR 0 5
69471: PUSH
69472: LD_EXP 50
69476: PUSH
69477: LD_VAR 0 2
69481: ARRAY
69482: PUSH
69483: LD_EXP 79
69487: PUSH
69488: LD_VAR 0 2
69492: ARRAY
69493: UNION
69494: PPUSH
69495: LD_INT 2
69497: PUSH
69498: LD_INT 25
69500: PUSH
69501: LD_INT 2
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 25
69510: PUSH
69511: LD_INT 16
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: LIST
69522: PUSH
69523: EMPTY
69524: LIST
69525: PPUSH
69526: CALL_OW 72
69530: ST_TO_ADDR
// if mc_need_heal [ i ] then
69531: LD_EXP 53
69535: PUSH
69536: LD_VAR 0 2
69540: ARRAY
69541: IFFALSE 69585
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
69543: LD_ADDR_VAR 0 5
69547: PUSH
69548: LD_VAR 0 5
69552: PUSH
69553: LD_EXP 53
69557: PUSH
69558: LD_VAR 0 2
69562: ARRAY
69563: PUSH
69564: LD_INT 1
69566: ARRAY
69567: PUSH
69568: LD_EXP 53
69572: PUSH
69573: LD_VAR 0 2
69577: ARRAY
69578: PUSH
69579: LD_INT 2
69581: ARRAY
69582: UNION
69583: DIFF
69584: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
69585: LD_ADDR_VAR 0 6
69589: PUSH
69590: LD_EXP 69
69594: PUSH
69595: LD_VAR 0 2
69599: ARRAY
69600: PPUSH
69601: LD_INT 2
69603: PUSH
69604: LD_INT 34
69606: PUSH
69607: LD_INT 13
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: LD_INT 34
69616: PUSH
69617: LD_INT 52
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 34
69626: PUSH
69627: LD_EXP 35
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: PPUSH
69642: CALL_OW 72
69646: ST_TO_ADDR
// if cranes then
69647: LD_VAR 0 6
69651: IFFALSE 69787
// begin for j in cranes do
69653: LD_ADDR_VAR 0 3
69657: PUSH
69658: LD_VAR 0 6
69662: PUSH
69663: FOR_IN
69664: IFFALSE 69785
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
69666: LD_VAR 0 3
69670: PPUSH
69671: CALL_OW 256
69675: PUSH
69676: LD_INT 1000
69678: EQUAL
69679: PUSH
69680: LD_VAR 0 3
69684: PPUSH
69685: CALL_OW 314
69689: NOT
69690: AND
69691: IFFALSE 69725
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
69693: LD_VAR 0 3
69697: PPUSH
69698: LD_EXP 51
69702: PUSH
69703: LD_VAR 0 2
69707: ARRAY
69708: PPUSH
69709: LD_VAR 0 3
69713: PPUSH
69714: CALL_OW 74
69718: PPUSH
69719: CALL_OW 130
69723: GO 69783
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
69725: LD_VAR 0 3
69729: PPUSH
69730: CALL_OW 256
69734: PUSH
69735: LD_INT 500
69737: LESS
69738: PUSH
69739: LD_VAR 0 3
69743: PPUSH
69744: LD_EXP 74
69748: PUSH
69749: LD_VAR 0 2
69753: ARRAY
69754: PPUSH
69755: CALL_OW 308
69759: NOT
69760: AND
69761: IFFALSE 69783
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69763: LD_VAR 0 3
69767: PPUSH
69768: LD_EXP 74
69772: PUSH
69773: LD_VAR 0 2
69777: ARRAY
69778: PPUSH
69779: CALL_OW 113
// end ;
69783: GO 69663
69785: POP
69786: POP
// end ; if tmp > 3 then
69787: LD_VAR 0 5
69791: PUSH
69792: LD_INT 3
69794: GREATER
69795: IFFALSE 69815
// tmp := ShrinkArray ( tmp , 4 ) ;
69797: LD_ADDR_VAR 0 5
69801: PUSH
69802: LD_VAR 0 5
69806: PPUSH
69807: LD_INT 4
69809: PPUSH
69810: CALL 56924 0 2
69814: ST_TO_ADDR
// if not tmp then
69815: LD_VAR 0 5
69819: NOT
69820: IFFALSE 69824
// continue ;
69822: GO 69232
// for j in tmp do
69824: LD_ADDR_VAR 0 3
69828: PUSH
69829: LD_VAR 0 5
69833: PUSH
69834: FOR_IN
69835: IFFALSE 70094
// begin if IsInUnit ( j ) then
69837: LD_VAR 0 3
69841: PPUSH
69842: CALL_OW 310
69846: IFFALSE 69857
// ComExitBuilding ( j ) ;
69848: LD_VAR 0 3
69852: PPUSH
69853: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
69857: LD_VAR 0 3
69861: PUSH
69862: LD_EXP 52
69866: PUSH
69867: LD_VAR 0 2
69871: ARRAY
69872: IN
69873: NOT
69874: IFFALSE 69932
// begin SetTag ( j , 101 ) ;
69876: LD_VAR 0 3
69880: PPUSH
69881: LD_INT 101
69883: PPUSH
69884: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
69888: LD_ADDR_EXP 52
69892: PUSH
69893: LD_EXP 52
69897: PPUSH
69898: LD_VAR 0 2
69902: PUSH
69903: LD_EXP 52
69907: PUSH
69908: LD_VAR 0 2
69912: ARRAY
69913: PUSH
69914: LD_INT 1
69916: PLUS
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PPUSH
69922: LD_VAR 0 3
69926: PPUSH
69927: CALL 24858 0 3
69931: ST_TO_ADDR
// end ; wait ( 1 ) ;
69932: LD_INT 1
69934: PPUSH
69935: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
69939: LD_ADDR_VAR 0 7
69943: PUSH
69944: LD_EXP 51
69948: PUSH
69949: LD_VAR 0 2
69953: ARRAY
69954: ST_TO_ADDR
// if mc_scan [ i ] then
69955: LD_EXP 73
69959: PUSH
69960: LD_VAR 0 2
69964: ARRAY
69965: IFFALSE 70027
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
69967: LD_ADDR_VAR 0 7
69971: PUSH
69972: LD_EXP 51
69976: PUSH
69977: LD_VAR 0 2
69981: ARRAY
69982: PPUSH
69983: LD_INT 3
69985: PUSH
69986: LD_INT 30
69988: PUSH
69989: LD_INT 32
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: LD_INT 30
69998: PUSH
69999: LD_INT 33
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: LD_INT 30
70008: PUSH
70009: LD_INT 31
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: PPUSH
70022: CALL_OW 72
70026: ST_TO_ADDR
// if not to_repair_tmp then
70027: LD_VAR 0 7
70031: NOT
70032: IFFALSE 70036
// continue ;
70034: GO 69834
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
70036: LD_ADDR_VAR 0 8
70040: PUSH
70041: LD_VAR 0 7
70045: PPUSH
70046: LD_VAR 0 3
70050: PPUSH
70051: CALL_OW 74
70055: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
70056: LD_VAR 0 8
70060: PPUSH
70061: LD_INT 16
70063: PPUSH
70064: CALL 27457 0 2
70068: PUSH
70069: LD_INT 4
70071: ARRAY
70072: PUSH
70073: LD_INT 10
70075: LESS
70076: IFFALSE 70092
// ComRepairBuilding ( j , to_repair ) ;
70078: LD_VAR 0 3
70082: PPUSH
70083: LD_VAR 0 8
70087: PPUSH
70088: CALL_OW 130
// end ;
70092: GO 69834
70094: POP
70095: POP
// end ;
70096: GO 69232
70098: POP
70099: POP
// end ;
70100: LD_VAR 0 1
70104: RET
// export function MC_Heal ; var i , j , tmp ; begin
70105: LD_INT 0
70107: PPUSH
70108: PPUSH
70109: PPUSH
70110: PPUSH
// if not mc_bases then
70111: LD_EXP 50
70115: NOT
70116: IFFALSE 70120
// exit ;
70118: GO 70522
// for i = 1 to mc_bases do
70120: LD_ADDR_VAR 0 2
70124: PUSH
70125: DOUBLE
70126: LD_INT 1
70128: DEC
70129: ST_TO_ADDR
70130: LD_EXP 50
70134: PUSH
70135: FOR_TO
70136: IFFALSE 70520
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
70138: LD_EXP 53
70142: PUSH
70143: LD_VAR 0 2
70147: ARRAY
70148: PUSH
70149: LD_INT 1
70151: ARRAY
70152: NOT
70153: PUSH
70154: LD_EXP 53
70158: PUSH
70159: LD_VAR 0 2
70163: ARRAY
70164: PUSH
70165: LD_INT 2
70167: ARRAY
70168: NOT
70169: AND
70170: IFFALSE 70208
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
70172: LD_ADDR_EXP 54
70176: PUSH
70177: LD_EXP 54
70181: PPUSH
70182: LD_VAR 0 2
70186: PPUSH
70187: EMPTY
70188: PPUSH
70189: CALL_OW 1
70193: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
70194: LD_VAR 0 2
70198: PPUSH
70199: LD_INT 102
70201: PPUSH
70202: CALL 64285 0 2
// continue ;
70206: GO 70135
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70208: LD_ADDR_VAR 0 4
70212: PUSH
70213: LD_EXP 50
70217: PUSH
70218: LD_VAR 0 2
70222: ARRAY
70223: PPUSH
70224: LD_INT 25
70226: PUSH
70227: LD_INT 4
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PPUSH
70234: CALL_OW 72
70238: ST_TO_ADDR
// if not tmp then
70239: LD_VAR 0 4
70243: NOT
70244: IFFALSE 70248
// continue ;
70246: GO 70135
// if mc_taming [ i ] then
70248: LD_EXP 81
70252: PUSH
70253: LD_VAR 0 2
70257: ARRAY
70258: IFFALSE 70282
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70260: LD_ADDR_EXP 81
70264: PUSH
70265: LD_EXP 81
70269: PPUSH
70270: LD_VAR 0 2
70274: PPUSH
70275: EMPTY
70276: PPUSH
70277: CALL_OW 1
70281: ST_TO_ADDR
// for j in tmp do
70282: LD_ADDR_VAR 0 3
70286: PUSH
70287: LD_VAR 0 4
70291: PUSH
70292: FOR_IN
70293: IFFALSE 70516
// begin if IsInUnit ( j ) then
70295: LD_VAR 0 3
70299: PPUSH
70300: CALL_OW 310
70304: IFFALSE 70315
// ComExitBuilding ( j ) ;
70306: LD_VAR 0 3
70310: PPUSH
70311: CALL_OW 122
// if not j in mc_healers [ i ] then
70315: LD_VAR 0 3
70319: PUSH
70320: LD_EXP 54
70324: PUSH
70325: LD_VAR 0 2
70329: ARRAY
70330: IN
70331: NOT
70332: IFFALSE 70378
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
70334: LD_ADDR_EXP 54
70338: PUSH
70339: LD_EXP 54
70343: PPUSH
70344: LD_VAR 0 2
70348: PUSH
70349: LD_EXP 54
70353: PUSH
70354: LD_VAR 0 2
70358: ARRAY
70359: PUSH
70360: LD_INT 1
70362: PLUS
70363: PUSH
70364: EMPTY
70365: LIST
70366: LIST
70367: PPUSH
70368: LD_VAR 0 3
70372: PPUSH
70373: CALL 24858 0 3
70377: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
70378: LD_VAR 0 3
70382: PPUSH
70383: CALL_OW 110
70387: PUSH
70388: LD_INT 102
70390: NONEQUAL
70391: IFFALSE 70405
// SetTag ( j , 102 ) ;
70393: LD_VAR 0 3
70397: PPUSH
70398: LD_INT 102
70400: PPUSH
70401: CALL_OW 109
// Wait ( 3 ) ;
70405: LD_INT 3
70407: PPUSH
70408: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
70412: LD_EXP 53
70416: PUSH
70417: LD_VAR 0 2
70421: ARRAY
70422: PUSH
70423: LD_INT 1
70425: ARRAY
70426: IFFALSE 70458
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
70428: LD_VAR 0 3
70432: PPUSH
70433: LD_EXP 53
70437: PUSH
70438: LD_VAR 0 2
70442: ARRAY
70443: PUSH
70444: LD_INT 1
70446: ARRAY
70447: PUSH
70448: LD_INT 1
70450: ARRAY
70451: PPUSH
70452: CALL_OW 128
70456: GO 70514
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
70458: LD_VAR 0 3
70462: PPUSH
70463: CALL_OW 314
70467: NOT
70468: PUSH
70469: LD_EXP 53
70473: PUSH
70474: LD_VAR 0 2
70478: ARRAY
70479: PUSH
70480: LD_INT 2
70482: ARRAY
70483: AND
70484: IFFALSE 70514
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
70486: LD_VAR 0 3
70490: PPUSH
70491: LD_EXP 53
70495: PUSH
70496: LD_VAR 0 2
70500: ARRAY
70501: PUSH
70502: LD_INT 2
70504: ARRAY
70505: PUSH
70506: LD_INT 1
70508: ARRAY
70509: PPUSH
70510: CALL_OW 128
// end ;
70514: GO 70292
70516: POP
70517: POP
// end ;
70518: GO 70135
70520: POP
70521: POP
// end ;
70522: LD_VAR 0 1
70526: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
70527: LD_INT 0
70529: PPUSH
70530: PPUSH
70531: PPUSH
70532: PPUSH
70533: PPUSH
// if not mc_bases then
70534: LD_EXP 50
70538: NOT
70539: IFFALSE 70543
// exit ;
70541: GO 71714
// for i = 1 to mc_bases do
70543: LD_ADDR_VAR 0 2
70547: PUSH
70548: DOUBLE
70549: LD_INT 1
70551: DEC
70552: ST_TO_ADDR
70553: LD_EXP 50
70557: PUSH
70558: FOR_TO
70559: IFFALSE 71712
// begin if mc_scan [ i ] then
70561: LD_EXP 73
70565: PUSH
70566: LD_VAR 0 2
70570: ARRAY
70571: IFFALSE 70575
// continue ;
70573: GO 70558
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
70575: LD_EXP 55
70579: PUSH
70580: LD_VAR 0 2
70584: ARRAY
70585: NOT
70586: PUSH
70587: LD_EXP 57
70591: PUSH
70592: LD_VAR 0 2
70596: ARRAY
70597: NOT
70598: AND
70599: PUSH
70600: LD_EXP 56
70604: PUSH
70605: LD_VAR 0 2
70609: ARRAY
70610: AND
70611: IFFALSE 70649
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
70613: LD_ADDR_EXP 56
70617: PUSH
70618: LD_EXP 56
70622: PPUSH
70623: LD_VAR 0 2
70627: PPUSH
70628: EMPTY
70629: PPUSH
70630: CALL_OW 1
70634: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70635: LD_VAR 0 2
70639: PPUSH
70640: LD_INT 103
70642: PPUSH
70643: CALL 64285 0 2
// continue ;
70647: GO 70558
// end ; if mc_construct_list [ i ] then
70649: LD_EXP 57
70653: PUSH
70654: LD_VAR 0 2
70658: ARRAY
70659: IFFALSE 70879
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
70661: LD_ADDR_VAR 0 4
70665: PUSH
70666: LD_EXP 50
70670: PUSH
70671: LD_VAR 0 2
70675: ARRAY
70676: PPUSH
70677: LD_INT 25
70679: PUSH
70680: LD_INT 2
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PPUSH
70687: CALL_OW 72
70691: PUSH
70692: LD_EXP 52
70696: PUSH
70697: LD_VAR 0 2
70701: ARRAY
70702: DIFF
70703: ST_TO_ADDR
// if not tmp then
70704: LD_VAR 0 4
70708: NOT
70709: IFFALSE 70713
// continue ;
70711: GO 70558
// for j in tmp do
70713: LD_ADDR_VAR 0 3
70717: PUSH
70718: LD_VAR 0 4
70722: PUSH
70723: FOR_IN
70724: IFFALSE 70875
// begin if not mc_builders [ i ] then
70726: LD_EXP 56
70730: PUSH
70731: LD_VAR 0 2
70735: ARRAY
70736: NOT
70737: IFFALSE 70795
// begin SetTag ( j , 103 ) ;
70739: LD_VAR 0 3
70743: PPUSH
70744: LD_INT 103
70746: PPUSH
70747: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
70751: LD_ADDR_EXP 56
70755: PUSH
70756: LD_EXP 56
70760: PPUSH
70761: LD_VAR 0 2
70765: PUSH
70766: LD_EXP 56
70770: PUSH
70771: LD_VAR 0 2
70775: ARRAY
70776: PUSH
70777: LD_INT 1
70779: PLUS
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PPUSH
70785: LD_VAR 0 3
70789: PPUSH
70790: CALL 24858 0 3
70794: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
70795: LD_VAR 0 3
70799: PPUSH
70800: CALL_OW 310
70804: IFFALSE 70815
// ComExitBuilding ( j ) ;
70806: LD_VAR 0 3
70810: PPUSH
70811: CALL_OW 122
// wait ( 3 ) ;
70815: LD_INT 3
70817: PPUSH
70818: CALL_OW 67
// if not mc_construct_list [ i ] then
70822: LD_EXP 57
70826: PUSH
70827: LD_VAR 0 2
70831: ARRAY
70832: NOT
70833: IFFALSE 70837
// break ;
70835: GO 70875
// if not HasTask ( j ) then
70837: LD_VAR 0 3
70841: PPUSH
70842: CALL_OW 314
70846: NOT
70847: IFFALSE 70873
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
70849: LD_VAR 0 3
70853: PPUSH
70854: LD_EXP 57
70858: PUSH
70859: LD_VAR 0 2
70863: ARRAY
70864: PUSH
70865: LD_INT 1
70867: ARRAY
70868: PPUSH
70869: CALL 27721 0 2
// end ;
70873: GO 70723
70875: POP
70876: POP
// end else
70877: GO 71710
// if mc_build_list [ i ] then
70879: LD_EXP 55
70883: PUSH
70884: LD_VAR 0 2
70888: ARRAY
70889: IFFALSE 71710
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70891: LD_ADDR_VAR 0 5
70895: PUSH
70896: LD_EXP 50
70900: PUSH
70901: LD_VAR 0 2
70905: ARRAY
70906: PPUSH
70907: LD_INT 2
70909: PUSH
70910: LD_INT 30
70912: PUSH
70913: LD_INT 0
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PUSH
70920: LD_INT 30
70922: PUSH
70923: LD_INT 1
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: LIST
70934: PPUSH
70935: CALL_OW 72
70939: ST_TO_ADDR
// if depot then
70940: LD_VAR 0 5
70944: IFFALSE 70962
// depot := depot [ 1 ] else
70946: LD_ADDR_VAR 0 5
70950: PUSH
70951: LD_VAR 0 5
70955: PUSH
70956: LD_INT 1
70958: ARRAY
70959: ST_TO_ADDR
70960: GO 70970
// depot := 0 ;
70962: LD_ADDR_VAR 0 5
70966: PUSH
70967: LD_INT 0
70969: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
70970: LD_EXP 55
70974: PUSH
70975: LD_VAR 0 2
70979: ARRAY
70980: PUSH
70981: LD_INT 1
70983: ARRAY
70984: PUSH
70985: LD_INT 1
70987: ARRAY
70988: PPUSH
70989: CALL 27545 0 1
70993: PUSH
70994: LD_EXP 50
70998: PUSH
70999: LD_VAR 0 2
71003: ARRAY
71004: PPUSH
71005: LD_INT 2
71007: PUSH
71008: LD_INT 30
71010: PUSH
71011: LD_INT 2
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 30
71020: PUSH
71021: LD_INT 3
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: LIST
71032: PPUSH
71033: CALL_OW 72
71037: NOT
71038: AND
71039: IFFALSE 71144
// begin for j = 1 to mc_build_list [ i ] do
71041: LD_ADDR_VAR 0 3
71045: PUSH
71046: DOUBLE
71047: LD_INT 1
71049: DEC
71050: ST_TO_ADDR
71051: LD_EXP 55
71055: PUSH
71056: LD_VAR 0 2
71060: ARRAY
71061: PUSH
71062: FOR_TO
71063: IFFALSE 71142
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
71065: LD_EXP 55
71069: PUSH
71070: LD_VAR 0 2
71074: ARRAY
71075: PUSH
71076: LD_VAR 0 3
71080: ARRAY
71081: PUSH
71082: LD_INT 1
71084: ARRAY
71085: PUSH
71086: LD_INT 2
71088: EQUAL
71089: IFFALSE 71140
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
71091: LD_ADDR_EXP 55
71095: PUSH
71096: LD_EXP 55
71100: PPUSH
71101: LD_VAR 0 2
71105: PPUSH
71106: LD_EXP 55
71110: PUSH
71111: LD_VAR 0 2
71115: ARRAY
71116: PPUSH
71117: LD_VAR 0 3
71121: PPUSH
71122: LD_INT 1
71124: PPUSH
71125: LD_INT 0
71127: PPUSH
71128: CALL 24276 0 4
71132: PPUSH
71133: CALL_OW 1
71137: ST_TO_ADDR
// break ;
71138: GO 71142
// end ;
71140: GO 71062
71142: POP
71143: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
71144: LD_EXP 55
71148: PUSH
71149: LD_VAR 0 2
71153: ARRAY
71154: PUSH
71155: LD_INT 1
71157: ARRAY
71158: PUSH
71159: LD_INT 1
71161: ARRAY
71162: PUSH
71163: LD_INT 0
71165: EQUAL
71166: PUSH
71167: LD_VAR 0 5
71171: PUSH
71172: LD_VAR 0 5
71176: PPUSH
71177: LD_EXP 55
71181: PUSH
71182: LD_VAR 0 2
71186: ARRAY
71187: PUSH
71188: LD_INT 1
71190: ARRAY
71191: PUSH
71192: LD_INT 1
71194: ARRAY
71195: PPUSH
71196: LD_EXP 55
71200: PUSH
71201: LD_VAR 0 2
71205: ARRAY
71206: PUSH
71207: LD_INT 1
71209: ARRAY
71210: PUSH
71211: LD_INT 2
71213: ARRAY
71214: PPUSH
71215: LD_EXP 55
71219: PUSH
71220: LD_VAR 0 2
71224: ARRAY
71225: PUSH
71226: LD_INT 1
71228: ARRAY
71229: PUSH
71230: LD_INT 3
71232: ARRAY
71233: PPUSH
71234: LD_EXP 55
71238: PUSH
71239: LD_VAR 0 2
71243: ARRAY
71244: PUSH
71245: LD_INT 1
71247: ARRAY
71248: PUSH
71249: LD_INT 4
71251: ARRAY
71252: PPUSH
71253: CALL 32961 0 5
71257: AND
71258: OR
71259: IFFALSE 71540
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71261: LD_ADDR_VAR 0 4
71265: PUSH
71266: LD_EXP 50
71270: PUSH
71271: LD_VAR 0 2
71275: ARRAY
71276: PPUSH
71277: LD_INT 25
71279: PUSH
71280: LD_INT 2
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PPUSH
71287: CALL_OW 72
71291: PUSH
71292: LD_EXP 52
71296: PUSH
71297: LD_VAR 0 2
71301: ARRAY
71302: DIFF
71303: ST_TO_ADDR
// if not tmp then
71304: LD_VAR 0 4
71308: NOT
71309: IFFALSE 71313
// continue ;
71311: GO 70558
// for j in tmp do
71313: LD_ADDR_VAR 0 3
71317: PUSH
71318: LD_VAR 0 4
71322: PUSH
71323: FOR_IN
71324: IFFALSE 71536
// begin if not mc_builders [ i ] then
71326: LD_EXP 56
71330: PUSH
71331: LD_VAR 0 2
71335: ARRAY
71336: NOT
71337: IFFALSE 71395
// begin SetTag ( j , 103 ) ;
71339: LD_VAR 0 3
71343: PPUSH
71344: LD_INT 103
71346: PPUSH
71347: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71351: LD_ADDR_EXP 56
71355: PUSH
71356: LD_EXP 56
71360: PPUSH
71361: LD_VAR 0 2
71365: PUSH
71366: LD_EXP 56
71370: PUSH
71371: LD_VAR 0 2
71375: ARRAY
71376: PUSH
71377: LD_INT 1
71379: PLUS
71380: PUSH
71381: EMPTY
71382: LIST
71383: LIST
71384: PPUSH
71385: LD_VAR 0 3
71389: PPUSH
71390: CALL 24858 0 3
71394: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71395: LD_VAR 0 3
71399: PPUSH
71400: CALL_OW 310
71404: IFFALSE 71415
// ComExitBuilding ( j ) ;
71406: LD_VAR 0 3
71410: PPUSH
71411: CALL_OW 122
// wait ( 3 ) ;
71415: LD_INT 3
71417: PPUSH
71418: CALL_OW 67
// if not mc_build_list [ i ] then
71422: LD_EXP 55
71426: PUSH
71427: LD_VAR 0 2
71431: ARRAY
71432: NOT
71433: IFFALSE 71437
// break ;
71435: GO 71536
// if not HasTask ( j ) then
71437: LD_VAR 0 3
71441: PPUSH
71442: CALL_OW 314
71446: NOT
71447: IFFALSE 71534
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
71449: LD_VAR 0 3
71453: PPUSH
71454: LD_EXP 55
71458: PUSH
71459: LD_VAR 0 2
71463: ARRAY
71464: PUSH
71465: LD_INT 1
71467: ARRAY
71468: PUSH
71469: LD_INT 1
71471: ARRAY
71472: PPUSH
71473: LD_EXP 55
71477: PUSH
71478: LD_VAR 0 2
71482: ARRAY
71483: PUSH
71484: LD_INT 1
71486: ARRAY
71487: PUSH
71488: LD_INT 2
71490: ARRAY
71491: PPUSH
71492: LD_EXP 55
71496: PUSH
71497: LD_VAR 0 2
71501: ARRAY
71502: PUSH
71503: LD_INT 1
71505: ARRAY
71506: PUSH
71507: LD_INT 3
71509: ARRAY
71510: PPUSH
71511: LD_EXP 55
71515: PUSH
71516: LD_VAR 0 2
71520: ARRAY
71521: PUSH
71522: LD_INT 1
71524: ARRAY
71525: PUSH
71526: LD_INT 4
71528: ARRAY
71529: PPUSH
71530: CALL_OW 145
// end ;
71534: GO 71323
71536: POP
71537: POP
// end else
71538: GO 71710
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
71540: LD_EXP 50
71544: PUSH
71545: LD_VAR 0 2
71549: ARRAY
71550: PPUSH
71551: LD_EXP 55
71555: PUSH
71556: LD_VAR 0 2
71560: ARRAY
71561: PUSH
71562: LD_INT 1
71564: ARRAY
71565: PUSH
71566: LD_INT 1
71568: ARRAY
71569: PPUSH
71570: LD_EXP 55
71574: PUSH
71575: LD_VAR 0 2
71579: ARRAY
71580: PUSH
71581: LD_INT 1
71583: ARRAY
71584: PUSH
71585: LD_INT 2
71587: ARRAY
71588: PPUSH
71589: LD_EXP 55
71593: PUSH
71594: LD_VAR 0 2
71598: ARRAY
71599: PUSH
71600: LD_INT 1
71602: ARRAY
71603: PUSH
71604: LD_INT 3
71606: ARRAY
71607: PPUSH
71608: LD_EXP 55
71612: PUSH
71613: LD_VAR 0 2
71617: ARRAY
71618: PUSH
71619: LD_INT 1
71621: ARRAY
71622: PUSH
71623: LD_INT 4
71625: ARRAY
71626: PPUSH
71627: LD_EXP 50
71631: PUSH
71632: LD_VAR 0 2
71636: ARRAY
71637: PPUSH
71638: LD_INT 21
71640: PUSH
71641: LD_INT 3
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PPUSH
71648: CALL_OW 72
71652: PPUSH
71653: EMPTY
71654: PPUSH
71655: CALL 31711 0 7
71659: NOT
71660: IFFALSE 71710
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
71662: LD_ADDR_EXP 55
71666: PUSH
71667: LD_EXP 55
71671: PPUSH
71672: LD_VAR 0 2
71676: PPUSH
71677: LD_EXP 55
71681: PUSH
71682: LD_VAR 0 2
71686: ARRAY
71687: PPUSH
71688: LD_INT 1
71690: PPUSH
71691: LD_INT 1
71693: NEG
71694: PPUSH
71695: LD_INT 0
71697: PPUSH
71698: CALL 24276 0 4
71702: PPUSH
71703: CALL_OW 1
71707: ST_TO_ADDR
// continue ;
71708: GO 70558
// end ; end ; end ;
71710: GO 70558
71712: POP
71713: POP
// end ;
71714: LD_VAR 0 1
71718: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
71719: LD_INT 0
71721: PPUSH
71722: PPUSH
71723: PPUSH
71724: PPUSH
71725: PPUSH
71726: PPUSH
// if not mc_bases then
71727: LD_EXP 50
71731: NOT
71732: IFFALSE 71736
// exit ;
71734: GO 72163
// for i = 1 to mc_bases do
71736: LD_ADDR_VAR 0 2
71740: PUSH
71741: DOUBLE
71742: LD_INT 1
71744: DEC
71745: ST_TO_ADDR
71746: LD_EXP 50
71750: PUSH
71751: FOR_TO
71752: IFFALSE 72161
// begin tmp := mc_build_upgrade [ i ] ;
71754: LD_ADDR_VAR 0 4
71758: PUSH
71759: LD_EXP 82
71763: PUSH
71764: LD_VAR 0 2
71768: ARRAY
71769: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
71770: LD_ADDR_VAR 0 6
71774: PUSH
71775: LD_EXP 83
71779: PUSH
71780: LD_VAR 0 2
71784: ARRAY
71785: PPUSH
71786: LD_INT 2
71788: PUSH
71789: LD_INT 30
71791: PUSH
71792: LD_INT 6
71794: PUSH
71795: EMPTY
71796: LIST
71797: LIST
71798: PUSH
71799: LD_INT 30
71801: PUSH
71802: LD_INT 7
71804: PUSH
71805: EMPTY
71806: LIST
71807: LIST
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: LIST
71813: PPUSH
71814: CALL_OW 72
71818: ST_TO_ADDR
// if not tmp and not lab then
71819: LD_VAR 0 4
71823: NOT
71824: PUSH
71825: LD_VAR 0 6
71829: NOT
71830: AND
71831: IFFALSE 71835
// continue ;
71833: GO 71751
// if tmp then
71835: LD_VAR 0 4
71839: IFFALSE 71959
// for j in tmp do
71841: LD_ADDR_VAR 0 3
71845: PUSH
71846: LD_VAR 0 4
71850: PUSH
71851: FOR_IN
71852: IFFALSE 71957
// begin if UpgradeCost ( j ) then
71854: LD_VAR 0 3
71858: PPUSH
71859: CALL 31371 0 1
71863: IFFALSE 71955
// begin ComUpgrade ( j ) ;
71865: LD_VAR 0 3
71869: PPUSH
71870: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
71874: LD_ADDR_EXP 82
71878: PUSH
71879: LD_EXP 82
71883: PPUSH
71884: LD_VAR 0 2
71888: PPUSH
71889: LD_EXP 82
71893: PUSH
71894: LD_VAR 0 2
71898: ARRAY
71899: PUSH
71900: LD_VAR 0 3
71904: DIFF
71905: PPUSH
71906: CALL_OW 1
71910: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71911: LD_ADDR_EXP 57
71915: PUSH
71916: LD_EXP 57
71920: PPUSH
71921: LD_VAR 0 2
71925: PUSH
71926: LD_EXP 57
71930: PUSH
71931: LD_VAR 0 2
71935: ARRAY
71936: PUSH
71937: LD_INT 1
71939: PLUS
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PPUSH
71945: LD_VAR 0 3
71949: PPUSH
71950: CALL 24858 0 3
71954: ST_TO_ADDR
// end ; end ;
71955: GO 71851
71957: POP
71958: POP
// if not lab or not mc_lab_upgrade [ i ] then
71959: LD_VAR 0 6
71963: NOT
71964: PUSH
71965: LD_EXP 84
71969: PUSH
71970: LD_VAR 0 2
71974: ARRAY
71975: NOT
71976: OR
71977: IFFALSE 71981
// continue ;
71979: GO 71751
// for j in lab do
71981: LD_ADDR_VAR 0 3
71985: PUSH
71986: LD_VAR 0 6
71990: PUSH
71991: FOR_IN
71992: IFFALSE 72157
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
71994: LD_VAR 0 3
71998: PPUSH
71999: CALL_OW 266
72003: PUSH
72004: LD_INT 6
72006: PUSH
72007: LD_INT 7
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: IN
72014: PUSH
72015: LD_VAR 0 3
72019: PPUSH
72020: CALL_OW 461
72024: PUSH
72025: LD_INT 1
72027: NONEQUAL
72028: AND
72029: IFFALSE 72155
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
72031: LD_VAR 0 3
72035: PPUSH
72036: LD_EXP 84
72040: PUSH
72041: LD_VAR 0 2
72045: ARRAY
72046: PUSH
72047: LD_INT 1
72049: ARRAY
72050: PPUSH
72051: CALL 31576 0 2
72055: IFFALSE 72155
// begin ComCancel ( j ) ;
72057: LD_VAR 0 3
72061: PPUSH
72062: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
72066: LD_VAR 0 3
72070: PPUSH
72071: LD_EXP 84
72075: PUSH
72076: LD_VAR 0 2
72080: ARRAY
72081: PUSH
72082: LD_INT 1
72084: ARRAY
72085: PPUSH
72086: CALL_OW 207
// if not j in mc_construct_list [ i ] then
72090: LD_VAR 0 3
72094: PUSH
72095: LD_EXP 57
72099: PUSH
72100: LD_VAR 0 2
72104: ARRAY
72105: IN
72106: NOT
72107: IFFALSE 72153
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
72109: LD_ADDR_EXP 57
72113: PUSH
72114: LD_EXP 57
72118: PPUSH
72119: LD_VAR 0 2
72123: PUSH
72124: LD_EXP 57
72128: PUSH
72129: LD_VAR 0 2
72133: ARRAY
72134: PUSH
72135: LD_INT 1
72137: PLUS
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PPUSH
72143: LD_VAR 0 3
72147: PPUSH
72148: CALL 24858 0 3
72152: ST_TO_ADDR
// break ;
72153: GO 72157
// end ; end ; end ;
72155: GO 71991
72157: POP
72158: POP
// end ;
72159: GO 71751
72161: POP
72162: POP
// end ;
72163: LD_VAR 0 1
72167: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
72168: LD_INT 0
72170: PPUSH
72171: PPUSH
72172: PPUSH
72173: PPUSH
72174: PPUSH
72175: PPUSH
72176: PPUSH
72177: PPUSH
72178: PPUSH
// if not mc_bases then
72179: LD_EXP 50
72183: NOT
72184: IFFALSE 72188
// exit ;
72186: GO 72593
// for i = 1 to mc_bases do
72188: LD_ADDR_VAR 0 2
72192: PUSH
72193: DOUBLE
72194: LD_INT 1
72196: DEC
72197: ST_TO_ADDR
72198: LD_EXP 50
72202: PUSH
72203: FOR_TO
72204: IFFALSE 72591
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
72206: LD_EXP 58
72210: PUSH
72211: LD_VAR 0 2
72215: ARRAY
72216: NOT
72217: PUSH
72218: LD_EXP 50
72222: PUSH
72223: LD_VAR 0 2
72227: ARRAY
72228: PPUSH
72229: LD_INT 30
72231: PUSH
72232: LD_INT 3
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: PPUSH
72239: CALL_OW 72
72243: NOT
72244: OR
72245: IFFALSE 72249
// continue ;
72247: GO 72203
// busy := false ;
72249: LD_ADDR_VAR 0 8
72253: PUSH
72254: LD_INT 0
72256: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72257: LD_ADDR_VAR 0 4
72261: PUSH
72262: LD_EXP 50
72266: PUSH
72267: LD_VAR 0 2
72271: ARRAY
72272: PPUSH
72273: LD_INT 30
72275: PUSH
72276: LD_INT 3
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PPUSH
72283: CALL_OW 72
72287: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
72288: LD_ADDR_VAR 0 6
72292: PUSH
72293: LD_EXP 58
72297: PUSH
72298: LD_VAR 0 2
72302: ARRAY
72303: PPUSH
72304: LD_INT 2
72306: PUSH
72307: LD_INT 30
72309: PUSH
72310: LD_INT 32
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 30
72319: PUSH
72320: LD_INT 33
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: LIST
72331: PPUSH
72332: CALL_OW 72
72336: ST_TO_ADDR
// if not t then
72337: LD_VAR 0 6
72341: NOT
72342: IFFALSE 72346
// continue ;
72344: GO 72203
// for j in tmp do
72346: LD_ADDR_VAR 0 3
72350: PUSH
72351: LD_VAR 0 4
72355: PUSH
72356: FOR_IN
72357: IFFALSE 72387
// if not BuildingStatus ( j ) = bs_idle then
72359: LD_VAR 0 3
72363: PPUSH
72364: CALL_OW 461
72368: PUSH
72369: LD_INT 2
72371: EQUAL
72372: NOT
72373: IFFALSE 72385
// begin busy := true ;
72375: LD_ADDR_VAR 0 8
72379: PUSH
72380: LD_INT 1
72382: ST_TO_ADDR
// break ;
72383: GO 72387
// end ;
72385: GO 72356
72387: POP
72388: POP
// if busy then
72389: LD_VAR 0 8
72393: IFFALSE 72397
// continue ;
72395: GO 72203
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
72397: LD_ADDR_VAR 0 7
72401: PUSH
72402: LD_VAR 0 6
72406: PPUSH
72407: LD_INT 35
72409: PUSH
72410: LD_INT 0
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PPUSH
72417: CALL_OW 72
72421: ST_TO_ADDR
// if tw then
72422: LD_VAR 0 7
72426: IFFALSE 72503
// begin tw := tw [ 1 ] ;
72428: LD_ADDR_VAR 0 7
72432: PUSH
72433: LD_VAR 0 7
72437: PUSH
72438: LD_INT 1
72440: ARRAY
72441: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
72442: LD_ADDR_VAR 0 9
72446: PUSH
72447: LD_VAR 0 7
72451: PPUSH
72452: LD_EXP 75
72456: PUSH
72457: LD_VAR 0 2
72461: ARRAY
72462: PPUSH
72463: CALL 29868 0 2
72467: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
72468: LD_EXP 89
72472: PUSH
72473: LD_VAR 0 2
72477: ARRAY
72478: IFFALSE 72501
// if not weapon in mc_allowed_tower_weapons [ i ] then
72480: LD_VAR 0 9
72484: PUSH
72485: LD_EXP 89
72489: PUSH
72490: LD_VAR 0 2
72494: ARRAY
72495: IN
72496: NOT
72497: IFFALSE 72501
// continue ;
72499: GO 72203
// end else
72501: GO 72566
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
72503: LD_ADDR_VAR 0 5
72507: PUSH
72508: LD_EXP 58
72512: PUSH
72513: LD_VAR 0 2
72517: ARRAY
72518: PPUSH
72519: LD_VAR 0 4
72523: PPUSH
72524: CALL 56157 0 2
72528: ST_TO_ADDR
// if not tmp2 then
72529: LD_VAR 0 5
72533: NOT
72534: IFFALSE 72538
// continue ;
72536: GO 72203
// tw := tmp2 [ 1 ] ;
72538: LD_ADDR_VAR 0 7
72542: PUSH
72543: LD_VAR 0 5
72547: PUSH
72548: LD_INT 1
72550: ARRAY
72551: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
72552: LD_ADDR_VAR 0 9
72556: PUSH
72557: LD_VAR 0 5
72561: PUSH
72562: LD_INT 2
72564: ARRAY
72565: ST_TO_ADDR
// end ; if not weapon then
72566: LD_VAR 0 9
72570: NOT
72571: IFFALSE 72575
// continue ;
72573: GO 72203
// ComPlaceWeapon ( tw , weapon ) ;
72575: LD_VAR 0 7
72579: PPUSH
72580: LD_VAR 0 9
72584: PPUSH
72585: CALL_OW 148
// end ;
72589: GO 72203
72591: POP
72592: POP
// end ;
72593: LD_VAR 0 1
72597: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
72598: LD_INT 0
72600: PPUSH
72601: PPUSH
72602: PPUSH
72603: PPUSH
72604: PPUSH
72605: PPUSH
72606: PPUSH
// if not mc_bases then
72607: LD_EXP 50
72611: NOT
72612: IFFALSE 72616
// exit ;
72614: GO 73384
// for i = 1 to mc_bases do
72616: LD_ADDR_VAR 0 2
72620: PUSH
72621: DOUBLE
72622: LD_INT 1
72624: DEC
72625: ST_TO_ADDR
72626: LD_EXP 50
72630: PUSH
72631: FOR_TO
72632: IFFALSE 73382
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
72634: LD_EXP 63
72638: PUSH
72639: LD_VAR 0 2
72643: ARRAY
72644: NOT
72645: PUSH
72646: LD_EXP 63
72650: PUSH
72651: LD_VAR 0 2
72655: ARRAY
72656: PUSH
72657: LD_EXP 64
72661: PUSH
72662: LD_VAR 0 2
72666: ARRAY
72667: EQUAL
72668: OR
72669: PUSH
72670: LD_EXP 73
72674: PUSH
72675: LD_VAR 0 2
72679: ARRAY
72680: OR
72681: IFFALSE 72685
// continue ;
72683: GO 72631
// if mc_miners [ i ] then
72685: LD_EXP 64
72689: PUSH
72690: LD_VAR 0 2
72694: ARRAY
72695: IFFALSE 73069
// begin for j = mc_miners [ i ] downto 1 do
72697: LD_ADDR_VAR 0 3
72701: PUSH
72702: DOUBLE
72703: LD_EXP 64
72707: PUSH
72708: LD_VAR 0 2
72712: ARRAY
72713: INC
72714: ST_TO_ADDR
72715: LD_INT 1
72717: PUSH
72718: FOR_DOWNTO
72719: IFFALSE 73067
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
72721: LD_EXP 64
72725: PUSH
72726: LD_VAR 0 2
72730: ARRAY
72731: PUSH
72732: LD_VAR 0 3
72736: ARRAY
72737: PPUSH
72738: CALL_OW 301
72742: PUSH
72743: LD_EXP 64
72747: PUSH
72748: LD_VAR 0 2
72752: ARRAY
72753: PUSH
72754: LD_VAR 0 3
72758: ARRAY
72759: PPUSH
72760: CALL_OW 257
72764: PUSH
72765: LD_INT 1
72767: NONEQUAL
72768: OR
72769: IFFALSE 72832
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
72771: LD_ADDR_VAR 0 5
72775: PUSH
72776: LD_EXP 64
72780: PUSH
72781: LD_VAR 0 2
72785: ARRAY
72786: PUSH
72787: LD_EXP 64
72791: PUSH
72792: LD_VAR 0 2
72796: ARRAY
72797: PUSH
72798: LD_VAR 0 3
72802: ARRAY
72803: DIFF
72804: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
72805: LD_ADDR_EXP 64
72809: PUSH
72810: LD_EXP 64
72814: PPUSH
72815: LD_VAR 0 2
72819: PPUSH
72820: LD_VAR 0 5
72824: PPUSH
72825: CALL_OW 1
72829: ST_TO_ADDR
// continue ;
72830: GO 72718
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
72832: LD_EXP 64
72836: PUSH
72837: LD_VAR 0 2
72841: ARRAY
72842: PUSH
72843: LD_VAR 0 3
72847: ARRAY
72848: PPUSH
72849: CALL_OW 257
72853: PUSH
72854: LD_INT 1
72856: EQUAL
72857: PUSH
72858: LD_EXP 64
72862: PUSH
72863: LD_VAR 0 2
72867: ARRAY
72868: PUSH
72869: LD_VAR 0 3
72873: ARRAY
72874: PPUSH
72875: CALL_OW 459
72879: NOT
72880: AND
72881: PUSH
72882: LD_EXP 64
72886: PUSH
72887: LD_VAR 0 2
72891: ARRAY
72892: PUSH
72893: LD_VAR 0 3
72897: ARRAY
72898: PPUSH
72899: CALL_OW 314
72903: NOT
72904: AND
72905: IFFALSE 73065
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
72907: LD_EXP 64
72911: PUSH
72912: LD_VAR 0 2
72916: ARRAY
72917: PUSH
72918: LD_VAR 0 3
72922: ARRAY
72923: PPUSH
72924: CALL_OW 310
72928: IFFALSE 72951
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
72930: LD_EXP 64
72934: PUSH
72935: LD_VAR 0 2
72939: ARRAY
72940: PUSH
72941: LD_VAR 0 3
72945: ARRAY
72946: PPUSH
72947: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
72951: LD_EXP 64
72955: PUSH
72956: LD_VAR 0 2
72960: ARRAY
72961: PUSH
72962: LD_VAR 0 3
72966: ARRAY
72967: PPUSH
72968: CALL_OW 314
72972: NOT
72973: IFFALSE 73065
// begin r := rand ( 1 , mc_mines [ i ] ) ;
72975: LD_ADDR_VAR 0 7
72979: PUSH
72980: LD_INT 1
72982: PPUSH
72983: LD_EXP 63
72987: PUSH
72988: LD_VAR 0 2
72992: ARRAY
72993: PPUSH
72994: CALL_OW 12
72998: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
72999: LD_EXP 64
73003: PUSH
73004: LD_VAR 0 2
73008: ARRAY
73009: PUSH
73010: LD_VAR 0 3
73014: ARRAY
73015: PPUSH
73016: LD_EXP 63
73020: PUSH
73021: LD_VAR 0 2
73025: ARRAY
73026: PUSH
73027: LD_VAR 0 7
73031: ARRAY
73032: PUSH
73033: LD_INT 1
73035: ARRAY
73036: PPUSH
73037: LD_EXP 63
73041: PUSH
73042: LD_VAR 0 2
73046: ARRAY
73047: PUSH
73048: LD_VAR 0 7
73052: ARRAY
73053: PUSH
73054: LD_INT 2
73056: ARRAY
73057: PPUSH
73058: LD_INT 0
73060: PPUSH
73061: CALL_OW 193
// end ; end ; end ;
73065: GO 72718
73067: POP
73068: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
73069: LD_ADDR_VAR 0 5
73073: PUSH
73074: LD_EXP 50
73078: PUSH
73079: LD_VAR 0 2
73083: ARRAY
73084: PPUSH
73085: LD_INT 2
73087: PUSH
73088: LD_INT 30
73090: PUSH
73091: LD_INT 4
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 30
73100: PUSH
73101: LD_INT 5
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 30
73110: PUSH
73111: LD_INT 32
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: LIST
73122: LIST
73123: PPUSH
73124: CALL_OW 72
73128: ST_TO_ADDR
// if not tmp then
73129: LD_VAR 0 5
73133: NOT
73134: IFFALSE 73138
// continue ;
73136: GO 72631
// list := [ ] ;
73138: LD_ADDR_VAR 0 6
73142: PUSH
73143: EMPTY
73144: ST_TO_ADDR
// for j in tmp do
73145: LD_ADDR_VAR 0 3
73149: PUSH
73150: LD_VAR 0 5
73154: PUSH
73155: FOR_IN
73156: IFFALSE 73225
// begin for k in UnitsInside ( j ) do
73158: LD_ADDR_VAR 0 4
73162: PUSH
73163: LD_VAR 0 3
73167: PPUSH
73168: CALL_OW 313
73172: PUSH
73173: FOR_IN
73174: IFFALSE 73221
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
73176: LD_VAR 0 4
73180: PPUSH
73181: CALL_OW 257
73185: PUSH
73186: LD_INT 1
73188: EQUAL
73189: PUSH
73190: LD_VAR 0 4
73194: PPUSH
73195: CALL_OW 459
73199: NOT
73200: AND
73201: IFFALSE 73219
// list := list ^ k ;
73203: LD_ADDR_VAR 0 6
73207: PUSH
73208: LD_VAR 0 6
73212: PUSH
73213: LD_VAR 0 4
73217: ADD
73218: ST_TO_ADDR
73219: GO 73173
73221: POP
73222: POP
// end ;
73223: GO 73155
73225: POP
73226: POP
// list := list diff mc_miners [ i ] ;
73227: LD_ADDR_VAR 0 6
73231: PUSH
73232: LD_VAR 0 6
73236: PUSH
73237: LD_EXP 64
73241: PUSH
73242: LD_VAR 0 2
73246: ARRAY
73247: DIFF
73248: ST_TO_ADDR
// if not list then
73249: LD_VAR 0 6
73253: NOT
73254: IFFALSE 73258
// continue ;
73256: GO 72631
// k := mc_mines [ i ] - mc_miners [ i ] ;
73258: LD_ADDR_VAR 0 4
73262: PUSH
73263: LD_EXP 63
73267: PUSH
73268: LD_VAR 0 2
73272: ARRAY
73273: PUSH
73274: LD_EXP 64
73278: PUSH
73279: LD_VAR 0 2
73283: ARRAY
73284: MINUS
73285: ST_TO_ADDR
// if k > list then
73286: LD_VAR 0 4
73290: PUSH
73291: LD_VAR 0 6
73295: GREATER
73296: IFFALSE 73308
// k := list ;
73298: LD_ADDR_VAR 0 4
73302: PUSH
73303: LD_VAR 0 6
73307: ST_TO_ADDR
// for j = 1 to k do
73308: LD_ADDR_VAR 0 3
73312: PUSH
73313: DOUBLE
73314: LD_INT 1
73316: DEC
73317: ST_TO_ADDR
73318: LD_VAR 0 4
73322: PUSH
73323: FOR_TO
73324: IFFALSE 73378
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
73326: LD_ADDR_EXP 64
73330: PUSH
73331: LD_EXP 64
73335: PPUSH
73336: LD_VAR 0 2
73340: PUSH
73341: LD_EXP 64
73345: PUSH
73346: LD_VAR 0 2
73350: ARRAY
73351: PUSH
73352: LD_INT 1
73354: PLUS
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PPUSH
73360: LD_VAR 0 6
73364: PUSH
73365: LD_VAR 0 3
73369: ARRAY
73370: PPUSH
73371: CALL 24858 0 3
73375: ST_TO_ADDR
73376: GO 73323
73378: POP
73379: POP
// end ;
73380: GO 72631
73382: POP
73383: POP
// end ;
73384: LD_VAR 0 1
73388: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
73389: LD_INT 0
73391: PPUSH
73392: PPUSH
73393: PPUSH
73394: PPUSH
73395: PPUSH
73396: PPUSH
73397: PPUSH
73398: PPUSH
73399: PPUSH
73400: PPUSH
73401: PPUSH
// if not mc_bases then
73402: LD_EXP 50
73406: NOT
73407: IFFALSE 73411
// exit ;
73409: GO 75234
// for i = 1 to mc_bases do
73411: LD_ADDR_VAR 0 2
73415: PUSH
73416: DOUBLE
73417: LD_INT 1
73419: DEC
73420: ST_TO_ADDR
73421: LD_EXP 50
73425: PUSH
73426: FOR_TO
73427: IFFALSE 75232
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
73429: LD_EXP 50
73433: PUSH
73434: LD_VAR 0 2
73438: ARRAY
73439: NOT
73440: PUSH
73441: LD_EXP 57
73445: PUSH
73446: LD_VAR 0 2
73450: ARRAY
73451: OR
73452: IFFALSE 73456
// continue ;
73454: GO 73426
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
73456: LD_EXP 66
73460: PUSH
73461: LD_VAR 0 2
73465: ARRAY
73466: NOT
73467: PUSH
73468: LD_EXP 67
73472: PUSH
73473: LD_VAR 0 2
73477: ARRAY
73478: AND
73479: IFFALSE 73517
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
73481: LD_ADDR_EXP 67
73485: PUSH
73486: LD_EXP 67
73490: PPUSH
73491: LD_VAR 0 2
73495: PPUSH
73496: EMPTY
73497: PPUSH
73498: CALL_OW 1
73502: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
73503: LD_VAR 0 2
73507: PPUSH
73508: LD_INT 107
73510: PPUSH
73511: CALL 64285 0 2
// continue ;
73515: GO 73426
// end ; target := [ ] ;
73517: LD_ADDR_VAR 0 7
73521: PUSH
73522: EMPTY
73523: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73524: LD_ADDR_VAR 0 6
73528: PUSH
73529: LD_EXP 50
73533: PUSH
73534: LD_VAR 0 2
73538: ARRAY
73539: PUSH
73540: LD_INT 1
73542: ARRAY
73543: PPUSH
73544: CALL_OW 255
73548: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73549: LD_ADDR_VAR 0 9
73553: PUSH
73554: LD_EXP 50
73558: PUSH
73559: LD_VAR 0 2
73563: ARRAY
73564: PPUSH
73565: LD_INT 2
73567: PUSH
73568: LD_INT 30
73570: PUSH
73571: LD_INT 0
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 30
73580: PUSH
73581: LD_INT 1
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: LIST
73592: PPUSH
73593: CALL_OW 72
73597: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
73598: LD_ADDR_VAR 0 3
73602: PUSH
73603: DOUBLE
73604: LD_EXP 66
73608: PUSH
73609: LD_VAR 0 2
73613: ARRAY
73614: INC
73615: ST_TO_ADDR
73616: LD_INT 1
73618: PUSH
73619: FOR_DOWNTO
73620: IFFALSE 73865
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
73622: LD_EXP 66
73626: PUSH
73627: LD_VAR 0 2
73631: ARRAY
73632: PUSH
73633: LD_VAR 0 3
73637: ARRAY
73638: PUSH
73639: LD_INT 2
73641: ARRAY
73642: PPUSH
73643: LD_EXP 66
73647: PUSH
73648: LD_VAR 0 2
73652: ARRAY
73653: PUSH
73654: LD_VAR 0 3
73658: ARRAY
73659: PUSH
73660: LD_INT 3
73662: ARRAY
73663: PPUSH
73664: CALL_OW 488
73668: PUSH
73669: LD_EXP 66
73673: PUSH
73674: LD_VAR 0 2
73678: ARRAY
73679: PUSH
73680: LD_VAR 0 3
73684: ARRAY
73685: PUSH
73686: LD_INT 2
73688: ARRAY
73689: PPUSH
73690: LD_EXP 66
73694: PUSH
73695: LD_VAR 0 2
73699: ARRAY
73700: PUSH
73701: LD_VAR 0 3
73705: ARRAY
73706: PUSH
73707: LD_INT 3
73709: ARRAY
73710: PPUSH
73711: CALL_OW 284
73715: PUSH
73716: LD_INT 0
73718: EQUAL
73719: AND
73720: IFFALSE 73775
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
73722: LD_ADDR_VAR 0 5
73726: PUSH
73727: LD_EXP 66
73731: PUSH
73732: LD_VAR 0 2
73736: ARRAY
73737: PPUSH
73738: LD_VAR 0 3
73742: PPUSH
73743: CALL_OW 3
73747: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
73748: LD_ADDR_EXP 66
73752: PUSH
73753: LD_EXP 66
73757: PPUSH
73758: LD_VAR 0 2
73762: PPUSH
73763: LD_VAR 0 5
73767: PPUSH
73768: CALL_OW 1
73772: ST_TO_ADDR
// continue ;
73773: GO 73619
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
73775: LD_VAR 0 6
73779: PPUSH
73780: LD_EXP 66
73784: PUSH
73785: LD_VAR 0 2
73789: ARRAY
73790: PUSH
73791: LD_VAR 0 3
73795: ARRAY
73796: PUSH
73797: LD_INT 2
73799: ARRAY
73800: PPUSH
73801: LD_EXP 66
73805: PUSH
73806: LD_VAR 0 2
73810: ARRAY
73811: PUSH
73812: LD_VAR 0 3
73816: ARRAY
73817: PUSH
73818: LD_INT 3
73820: ARRAY
73821: PPUSH
73822: LD_INT 30
73824: PPUSH
73825: CALL 25754 0 4
73829: PUSH
73830: LD_INT 4
73832: ARRAY
73833: PUSH
73834: LD_INT 0
73836: EQUAL
73837: IFFALSE 73863
// begin target := mc_crates [ i ] [ j ] ;
73839: LD_ADDR_VAR 0 7
73843: PUSH
73844: LD_EXP 66
73848: PUSH
73849: LD_VAR 0 2
73853: ARRAY
73854: PUSH
73855: LD_VAR 0 3
73859: ARRAY
73860: ST_TO_ADDR
// break ;
73861: GO 73865
// end ; end ;
73863: GO 73619
73865: POP
73866: POP
// if not target then
73867: LD_VAR 0 7
73871: NOT
73872: IFFALSE 73876
// continue ;
73874: GO 73426
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
73876: LD_ADDR_VAR 0 8
73880: PUSH
73881: LD_EXP 69
73885: PUSH
73886: LD_VAR 0 2
73890: ARRAY
73891: PPUSH
73892: LD_INT 2
73894: PUSH
73895: LD_INT 3
73897: PUSH
73898: LD_INT 58
73900: PUSH
73901: EMPTY
73902: LIST
73903: PUSH
73904: EMPTY
73905: LIST
73906: LIST
73907: PUSH
73908: LD_INT 61
73910: PUSH
73911: EMPTY
73912: LIST
73913: PUSH
73914: LD_INT 33
73916: PUSH
73917: LD_INT 5
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: LD_INT 33
73926: PUSH
73927: LD_INT 3
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: LIST
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 2
73943: PUSH
73944: LD_INT 34
73946: PUSH
73947: LD_INT 32
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: PUSH
73954: LD_INT 34
73956: PUSH
73957: LD_INT 51
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: PUSH
73964: LD_INT 34
73966: PUSH
73967: LD_INT 12
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: LIST
73978: LIST
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PPUSH
73984: CALL_OW 72
73988: ST_TO_ADDR
// if not cargo then
73989: LD_VAR 0 8
73993: NOT
73994: IFFALSE 74700
// begin if mc_crates_collector [ i ] < 5 then
73996: LD_EXP 67
74000: PUSH
74001: LD_VAR 0 2
74005: ARRAY
74006: PUSH
74007: LD_INT 5
74009: LESS
74010: IFFALSE 74376
// begin if mc_ape [ i ] then
74012: LD_EXP 79
74016: PUSH
74017: LD_VAR 0 2
74021: ARRAY
74022: IFFALSE 74069
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
74024: LD_ADDR_VAR 0 5
74028: PUSH
74029: LD_EXP 79
74033: PUSH
74034: LD_VAR 0 2
74038: ARRAY
74039: PPUSH
74040: LD_INT 25
74042: PUSH
74043: LD_INT 16
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 24
74052: PUSH
74053: LD_INT 750
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PPUSH
74064: CALL_OW 72
74068: ST_TO_ADDR
// if not tmp then
74069: LD_VAR 0 5
74073: NOT
74074: IFFALSE 74121
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
74076: LD_ADDR_VAR 0 5
74080: PUSH
74081: LD_EXP 50
74085: PUSH
74086: LD_VAR 0 2
74090: ARRAY
74091: PPUSH
74092: LD_INT 25
74094: PUSH
74095: LD_INT 2
74097: PUSH
74098: EMPTY
74099: LIST
74100: LIST
74101: PUSH
74102: LD_INT 24
74104: PUSH
74105: LD_INT 750
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PPUSH
74116: CALL_OW 72
74120: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
74121: LD_EXP 79
74125: PUSH
74126: LD_VAR 0 2
74130: ARRAY
74131: PUSH
74132: LD_EXP 50
74136: PUSH
74137: LD_VAR 0 2
74141: ARRAY
74142: PPUSH
74143: LD_INT 25
74145: PUSH
74146: LD_INT 2
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PUSH
74153: LD_INT 24
74155: PUSH
74156: LD_INT 750
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: EMPTY
74164: LIST
74165: LIST
74166: PPUSH
74167: CALL_OW 72
74171: AND
74172: PUSH
74173: LD_VAR 0 5
74177: PUSH
74178: LD_INT 5
74180: LESS
74181: AND
74182: IFFALSE 74264
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
74184: LD_ADDR_VAR 0 3
74188: PUSH
74189: LD_EXP 50
74193: PUSH
74194: LD_VAR 0 2
74198: ARRAY
74199: PPUSH
74200: LD_INT 25
74202: PUSH
74203: LD_INT 2
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 24
74212: PUSH
74213: LD_INT 750
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PPUSH
74224: CALL_OW 72
74228: PUSH
74229: FOR_IN
74230: IFFALSE 74262
// begin tmp := tmp union j ;
74232: LD_ADDR_VAR 0 5
74236: PUSH
74237: LD_VAR 0 5
74241: PUSH
74242: LD_VAR 0 3
74246: UNION
74247: ST_TO_ADDR
// if tmp >= 5 then
74248: LD_VAR 0 5
74252: PUSH
74253: LD_INT 5
74255: GREATEREQUAL
74256: IFFALSE 74260
// break ;
74258: GO 74262
// end ;
74260: GO 74229
74262: POP
74263: POP
// end ; if not tmp then
74264: LD_VAR 0 5
74268: NOT
74269: IFFALSE 74273
// continue ;
74271: GO 73426
// for j in tmp do
74273: LD_ADDR_VAR 0 3
74277: PUSH
74278: LD_VAR 0 5
74282: PUSH
74283: FOR_IN
74284: IFFALSE 74374
// if not GetTag ( j ) then
74286: LD_VAR 0 3
74290: PPUSH
74291: CALL_OW 110
74295: NOT
74296: IFFALSE 74372
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
74298: LD_ADDR_EXP 67
74302: PUSH
74303: LD_EXP 67
74307: PPUSH
74308: LD_VAR 0 2
74312: PUSH
74313: LD_EXP 67
74317: PUSH
74318: LD_VAR 0 2
74322: ARRAY
74323: PUSH
74324: LD_INT 1
74326: PLUS
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: PPUSH
74332: LD_VAR 0 3
74336: PPUSH
74337: CALL 24858 0 3
74341: ST_TO_ADDR
// SetTag ( j , 107 ) ;
74342: LD_VAR 0 3
74346: PPUSH
74347: LD_INT 107
74349: PPUSH
74350: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
74354: LD_EXP 67
74358: PUSH
74359: LD_VAR 0 2
74363: ARRAY
74364: PUSH
74365: LD_INT 5
74367: GREATEREQUAL
74368: IFFALSE 74372
// break ;
74370: GO 74374
// end ;
74372: GO 74283
74374: POP
74375: POP
// end ; if mc_crates_collector [ i ] and target then
74376: LD_EXP 67
74380: PUSH
74381: LD_VAR 0 2
74385: ARRAY
74386: PUSH
74387: LD_VAR 0 7
74391: AND
74392: IFFALSE 74698
// begin if mc_crates_collector [ i ] < target [ 1 ] then
74394: LD_EXP 67
74398: PUSH
74399: LD_VAR 0 2
74403: ARRAY
74404: PUSH
74405: LD_VAR 0 7
74409: PUSH
74410: LD_INT 1
74412: ARRAY
74413: LESS
74414: IFFALSE 74434
// tmp := mc_crates_collector [ i ] else
74416: LD_ADDR_VAR 0 5
74420: PUSH
74421: LD_EXP 67
74425: PUSH
74426: LD_VAR 0 2
74430: ARRAY
74431: ST_TO_ADDR
74432: GO 74448
// tmp := target [ 1 ] ;
74434: LD_ADDR_VAR 0 5
74438: PUSH
74439: LD_VAR 0 7
74443: PUSH
74444: LD_INT 1
74446: ARRAY
74447: ST_TO_ADDR
// k := 0 ;
74448: LD_ADDR_VAR 0 4
74452: PUSH
74453: LD_INT 0
74455: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
74456: LD_ADDR_VAR 0 3
74460: PUSH
74461: LD_EXP 67
74465: PUSH
74466: LD_VAR 0 2
74470: ARRAY
74471: PUSH
74472: FOR_IN
74473: IFFALSE 74696
// begin k := k + 1 ;
74475: LD_ADDR_VAR 0 4
74479: PUSH
74480: LD_VAR 0 4
74484: PUSH
74485: LD_INT 1
74487: PLUS
74488: ST_TO_ADDR
// if k > tmp then
74489: LD_VAR 0 4
74493: PUSH
74494: LD_VAR 0 5
74498: GREATER
74499: IFFALSE 74503
// break ;
74501: GO 74696
// if not GetClass ( j ) in [ 2 , 16 ] then
74503: LD_VAR 0 3
74507: PPUSH
74508: CALL_OW 257
74512: PUSH
74513: LD_INT 2
74515: PUSH
74516: LD_INT 16
74518: PUSH
74519: EMPTY
74520: LIST
74521: LIST
74522: IN
74523: NOT
74524: IFFALSE 74577
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
74526: LD_ADDR_EXP 67
74530: PUSH
74531: LD_EXP 67
74535: PPUSH
74536: LD_VAR 0 2
74540: PPUSH
74541: LD_EXP 67
74545: PUSH
74546: LD_VAR 0 2
74550: ARRAY
74551: PUSH
74552: LD_VAR 0 3
74556: DIFF
74557: PPUSH
74558: CALL_OW 1
74562: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74563: LD_VAR 0 3
74567: PPUSH
74568: LD_INT 0
74570: PPUSH
74571: CALL_OW 109
// continue ;
74575: GO 74472
// end ; if IsInUnit ( j ) then
74577: LD_VAR 0 3
74581: PPUSH
74582: CALL_OW 310
74586: IFFALSE 74597
// ComExitBuilding ( j ) ;
74588: LD_VAR 0 3
74592: PPUSH
74593: CALL_OW 122
// wait ( 3 ) ;
74597: LD_INT 3
74599: PPUSH
74600: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
74604: LD_VAR 0 3
74608: PPUSH
74609: CALL_OW 314
74613: PUSH
74614: LD_VAR 0 6
74618: PPUSH
74619: LD_VAR 0 7
74623: PUSH
74624: LD_INT 2
74626: ARRAY
74627: PPUSH
74628: LD_VAR 0 7
74632: PUSH
74633: LD_INT 3
74635: ARRAY
74636: PPUSH
74637: LD_INT 30
74639: PPUSH
74640: CALL 25754 0 4
74644: PUSH
74645: LD_INT 4
74647: ARRAY
74648: AND
74649: IFFALSE 74667
// ComStandNearbyBuilding ( j , depot ) else
74651: LD_VAR 0 3
74655: PPUSH
74656: LD_VAR 0 9
74660: PPUSH
74661: CALL 21436 0 2
74665: GO 74694
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
74667: LD_VAR 0 3
74671: PPUSH
74672: LD_VAR 0 7
74676: PUSH
74677: LD_INT 2
74679: ARRAY
74680: PPUSH
74681: LD_VAR 0 7
74685: PUSH
74686: LD_INT 3
74688: ARRAY
74689: PPUSH
74690: CALL_OW 117
// end ;
74694: GO 74472
74696: POP
74697: POP
// end ; end else
74698: GO 75230
// begin for j in cargo do
74700: LD_ADDR_VAR 0 3
74704: PUSH
74705: LD_VAR 0 8
74709: PUSH
74710: FOR_IN
74711: IFFALSE 75228
// begin if GetTag ( j ) <> 0 then
74713: LD_VAR 0 3
74717: PPUSH
74718: CALL_OW 110
74722: PUSH
74723: LD_INT 0
74725: NONEQUAL
74726: IFFALSE 74730
// continue ;
74728: GO 74710
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
74730: LD_VAR 0 3
74734: PPUSH
74735: CALL_OW 256
74739: PUSH
74740: LD_INT 1000
74742: LESS
74743: PUSH
74744: LD_VAR 0 3
74748: PPUSH
74749: LD_EXP 74
74753: PUSH
74754: LD_VAR 0 2
74758: ARRAY
74759: PPUSH
74760: CALL_OW 308
74764: NOT
74765: AND
74766: IFFALSE 74788
// ComMoveToArea ( j , mc_parking [ i ] ) ;
74768: LD_VAR 0 3
74772: PPUSH
74773: LD_EXP 74
74777: PUSH
74778: LD_VAR 0 2
74782: ARRAY
74783: PPUSH
74784: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
74788: LD_VAR 0 3
74792: PPUSH
74793: CALL_OW 256
74797: PUSH
74798: LD_INT 1000
74800: LESS
74801: PUSH
74802: LD_VAR 0 3
74806: PPUSH
74807: LD_EXP 74
74811: PUSH
74812: LD_VAR 0 2
74816: ARRAY
74817: PPUSH
74818: CALL_OW 308
74822: AND
74823: IFFALSE 74827
// continue ;
74825: GO 74710
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
74827: LD_VAR 0 3
74831: PPUSH
74832: CALL_OW 262
74836: PUSH
74837: LD_INT 2
74839: EQUAL
74840: PUSH
74841: LD_VAR 0 3
74845: PPUSH
74846: CALL_OW 261
74850: PUSH
74851: LD_INT 15
74853: LESS
74854: AND
74855: IFFALSE 74859
// continue ;
74857: GO 74710
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
74859: LD_VAR 0 3
74863: PPUSH
74864: CALL_OW 262
74868: PUSH
74869: LD_INT 1
74871: EQUAL
74872: PUSH
74873: LD_VAR 0 3
74877: PPUSH
74878: CALL_OW 261
74882: PUSH
74883: LD_INT 10
74885: LESS
74886: AND
74887: IFFALSE 75167
// begin if not depot then
74889: LD_VAR 0 9
74893: NOT
74894: IFFALSE 74898
// continue ;
74896: GO 74710
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
74898: LD_VAR 0 3
74902: PPUSH
74903: LD_VAR 0 9
74907: PPUSH
74908: LD_VAR 0 3
74912: PPUSH
74913: CALL_OW 74
74917: PPUSH
74918: CALL_OW 296
74922: PUSH
74923: LD_INT 6
74925: LESS
74926: IFFALSE 74942
// SetFuel ( j , 100 ) else
74928: LD_VAR 0 3
74932: PPUSH
74933: LD_INT 100
74935: PPUSH
74936: CALL_OW 240
74940: GO 75167
// if GetFuel ( j ) = 0 then
74942: LD_VAR 0 3
74946: PPUSH
74947: CALL_OW 261
74951: PUSH
74952: LD_INT 0
74954: EQUAL
74955: IFFALSE 75167
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
74957: LD_ADDR_EXP 69
74961: PUSH
74962: LD_EXP 69
74966: PPUSH
74967: LD_VAR 0 2
74971: PPUSH
74972: LD_EXP 69
74976: PUSH
74977: LD_VAR 0 2
74981: ARRAY
74982: PUSH
74983: LD_VAR 0 3
74987: DIFF
74988: PPUSH
74989: CALL_OW 1
74993: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
74994: LD_VAR 0 3
74998: PPUSH
74999: CALL_OW 263
75003: PUSH
75004: LD_INT 1
75006: EQUAL
75007: IFFALSE 75023
// ComExitVehicle ( IsInUnit ( j ) ) ;
75009: LD_VAR 0 3
75013: PPUSH
75014: CALL_OW 310
75018: PPUSH
75019: CALL_OW 121
// if GetControl ( j ) = control_remote then
75023: LD_VAR 0 3
75027: PPUSH
75028: CALL_OW 263
75032: PUSH
75033: LD_INT 2
75035: EQUAL
75036: IFFALSE 75047
// ComUnlink ( j ) ;
75038: LD_VAR 0 3
75042: PPUSH
75043: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
75047: LD_ADDR_VAR 0 10
75051: PUSH
75052: LD_VAR 0 2
75056: PPUSH
75057: LD_INT 3
75059: PPUSH
75060: CALL 84806 0 2
75064: ST_TO_ADDR
// if fac then
75065: LD_VAR 0 10
75069: IFFALSE 75165
// begin for k in fac do
75071: LD_ADDR_VAR 0 4
75075: PUSH
75076: LD_VAR 0 10
75080: PUSH
75081: FOR_IN
75082: IFFALSE 75163
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
75084: LD_ADDR_VAR 0 11
75088: PUSH
75089: LD_VAR 0 10
75093: PPUSH
75094: LD_VAR 0 3
75098: PPUSH
75099: CALL_OW 265
75103: PPUSH
75104: LD_VAR 0 3
75108: PPUSH
75109: CALL_OW 262
75113: PPUSH
75114: LD_VAR 0 3
75118: PPUSH
75119: CALL_OW 263
75123: PPUSH
75124: LD_VAR 0 3
75128: PPUSH
75129: CALL_OW 264
75133: PPUSH
75134: CALL 22354 0 5
75138: ST_TO_ADDR
// if components then
75139: LD_VAR 0 11
75143: IFFALSE 75161
// begin MC_InsertProduceList ( i , components ) ;
75145: LD_VAR 0 2
75149: PPUSH
75150: LD_VAR 0 11
75154: PPUSH
75155: CALL 84351 0 2
// break ;
75159: GO 75163
// end ; end ;
75161: GO 75081
75163: POP
75164: POP
// end ; continue ;
75165: GO 74710
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
75167: LD_VAR 0 3
75171: PPUSH
75172: LD_INT 1
75174: PPUSH
75175: CALL_OW 289
75179: PUSH
75180: LD_INT 100
75182: LESS
75183: PUSH
75184: LD_VAR 0 3
75188: PPUSH
75189: CALL_OW 314
75193: NOT
75194: AND
75195: IFFALSE 75224
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75197: LD_VAR 0 3
75201: PPUSH
75202: LD_VAR 0 7
75206: PUSH
75207: LD_INT 2
75209: ARRAY
75210: PPUSH
75211: LD_VAR 0 7
75215: PUSH
75216: LD_INT 3
75218: ARRAY
75219: PPUSH
75220: CALL_OW 117
// break ;
75224: GO 75228
// end ;
75226: GO 74710
75228: POP
75229: POP
// end ; end ;
75230: GO 73426
75232: POP
75233: POP
// end ;
75234: LD_VAR 0 1
75238: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
75239: LD_INT 0
75241: PPUSH
75242: PPUSH
75243: PPUSH
75244: PPUSH
// if not mc_bases then
75245: LD_EXP 50
75249: NOT
75250: IFFALSE 75254
// exit ;
75252: GO 75415
// for i = 1 to mc_bases do
75254: LD_ADDR_VAR 0 2
75258: PUSH
75259: DOUBLE
75260: LD_INT 1
75262: DEC
75263: ST_TO_ADDR
75264: LD_EXP 50
75268: PUSH
75269: FOR_TO
75270: IFFALSE 75413
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
75272: LD_ADDR_VAR 0 4
75276: PUSH
75277: LD_EXP 69
75281: PUSH
75282: LD_VAR 0 2
75286: ARRAY
75287: PUSH
75288: LD_EXP 72
75292: PUSH
75293: LD_VAR 0 2
75297: ARRAY
75298: UNION
75299: PPUSH
75300: LD_INT 33
75302: PUSH
75303: LD_INT 2
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PPUSH
75310: CALL_OW 72
75314: ST_TO_ADDR
// if tmp then
75315: LD_VAR 0 4
75319: IFFALSE 75411
// for j in tmp do
75321: LD_ADDR_VAR 0 3
75325: PUSH
75326: LD_VAR 0 4
75330: PUSH
75331: FOR_IN
75332: IFFALSE 75409
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
75334: LD_VAR 0 3
75338: PPUSH
75339: CALL_OW 312
75343: NOT
75344: PUSH
75345: LD_VAR 0 3
75349: PPUSH
75350: CALL_OW 256
75354: PUSH
75355: LD_INT 250
75357: GREATEREQUAL
75358: AND
75359: IFFALSE 75372
// Connect ( j ) else
75361: LD_VAR 0 3
75365: PPUSH
75366: CALL 27829 0 1
75370: GO 75407
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
75372: LD_VAR 0 3
75376: PPUSH
75377: CALL_OW 256
75381: PUSH
75382: LD_INT 250
75384: LESS
75385: PUSH
75386: LD_VAR 0 3
75390: PPUSH
75391: CALL_OW 312
75395: AND
75396: IFFALSE 75407
// ComUnlink ( j ) ;
75398: LD_VAR 0 3
75402: PPUSH
75403: CALL_OW 136
75407: GO 75331
75409: POP
75410: POP
// end ;
75411: GO 75269
75413: POP
75414: POP
// end ;
75415: LD_VAR 0 1
75419: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
75420: LD_INT 0
75422: PPUSH
75423: PPUSH
75424: PPUSH
75425: PPUSH
75426: PPUSH
// if not mc_bases then
75427: LD_EXP 50
75431: NOT
75432: IFFALSE 75436
// exit ;
75434: GO 75881
// for i = 1 to mc_bases do
75436: LD_ADDR_VAR 0 2
75440: PUSH
75441: DOUBLE
75442: LD_INT 1
75444: DEC
75445: ST_TO_ADDR
75446: LD_EXP 50
75450: PUSH
75451: FOR_TO
75452: IFFALSE 75879
// begin if not mc_produce [ i ] then
75454: LD_EXP 71
75458: PUSH
75459: LD_VAR 0 2
75463: ARRAY
75464: NOT
75465: IFFALSE 75469
// continue ;
75467: GO 75451
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75469: LD_ADDR_VAR 0 5
75473: PUSH
75474: LD_EXP 50
75478: PUSH
75479: LD_VAR 0 2
75483: ARRAY
75484: PPUSH
75485: LD_INT 30
75487: PUSH
75488: LD_INT 3
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PPUSH
75495: CALL_OW 72
75499: ST_TO_ADDR
// if not fac then
75500: LD_VAR 0 5
75504: NOT
75505: IFFALSE 75509
// continue ;
75507: GO 75451
// for j in fac do
75509: LD_ADDR_VAR 0 3
75513: PUSH
75514: LD_VAR 0 5
75518: PUSH
75519: FOR_IN
75520: IFFALSE 75875
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
75522: LD_VAR 0 3
75526: PPUSH
75527: CALL_OW 461
75531: PUSH
75532: LD_INT 2
75534: NONEQUAL
75535: PUSH
75536: LD_VAR 0 3
75540: PPUSH
75541: LD_INT 15
75543: PPUSH
75544: CALL 27457 0 2
75548: PUSH
75549: LD_INT 4
75551: ARRAY
75552: OR
75553: IFFALSE 75557
// continue ;
75555: GO 75519
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
75557: LD_VAR 0 3
75561: PPUSH
75562: LD_EXP 71
75566: PUSH
75567: LD_VAR 0 2
75571: ARRAY
75572: PUSH
75573: LD_INT 1
75575: ARRAY
75576: PUSH
75577: LD_INT 1
75579: ARRAY
75580: PPUSH
75581: LD_EXP 71
75585: PUSH
75586: LD_VAR 0 2
75590: ARRAY
75591: PUSH
75592: LD_INT 1
75594: ARRAY
75595: PUSH
75596: LD_INT 2
75598: ARRAY
75599: PPUSH
75600: LD_EXP 71
75604: PUSH
75605: LD_VAR 0 2
75609: ARRAY
75610: PUSH
75611: LD_INT 1
75613: ARRAY
75614: PUSH
75615: LD_INT 3
75617: ARRAY
75618: PPUSH
75619: LD_EXP 71
75623: PUSH
75624: LD_VAR 0 2
75628: ARRAY
75629: PUSH
75630: LD_INT 1
75632: ARRAY
75633: PUSH
75634: LD_INT 4
75636: ARRAY
75637: PPUSH
75638: CALL_OW 448
75642: PUSH
75643: LD_VAR 0 3
75647: PPUSH
75648: LD_EXP 71
75652: PUSH
75653: LD_VAR 0 2
75657: ARRAY
75658: PUSH
75659: LD_INT 1
75661: ARRAY
75662: PUSH
75663: LD_INT 1
75665: ARRAY
75666: PUSH
75667: LD_EXP 71
75671: PUSH
75672: LD_VAR 0 2
75676: ARRAY
75677: PUSH
75678: LD_INT 1
75680: ARRAY
75681: PUSH
75682: LD_INT 2
75684: ARRAY
75685: PUSH
75686: LD_EXP 71
75690: PUSH
75691: LD_VAR 0 2
75695: ARRAY
75696: PUSH
75697: LD_INT 1
75699: ARRAY
75700: PUSH
75701: LD_INT 3
75703: ARRAY
75704: PUSH
75705: LD_EXP 71
75709: PUSH
75710: LD_VAR 0 2
75714: ARRAY
75715: PUSH
75716: LD_INT 1
75718: ARRAY
75719: PUSH
75720: LD_INT 4
75722: ARRAY
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: PPUSH
75730: CALL 31224 0 2
75734: AND
75735: IFFALSE 75873
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
75737: LD_VAR 0 3
75741: PPUSH
75742: LD_EXP 71
75746: PUSH
75747: LD_VAR 0 2
75751: ARRAY
75752: PUSH
75753: LD_INT 1
75755: ARRAY
75756: PUSH
75757: LD_INT 1
75759: ARRAY
75760: PPUSH
75761: LD_EXP 71
75765: PUSH
75766: LD_VAR 0 2
75770: ARRAY
75771: PUSH
75772: LD_INT 1
75774: ARRAY
75775: PUSH
75776: LD_INT 2
75778: ARRAY
75779: PPUSH
75780: LD_EXP 71
75784: PUSH
75785: LD_VAR 0 2
75789: ARRAY
75790: PUSH
75791: LD_INT 1
75793: ARRAY
75794: PUSH
75795: LD_INT 3
75797: ARRAY
75798: PPUSH
75799: LD_EXP 71
75803: PUSH
75804: LD_VAR 0 2
75808: ARRAY
75809: PUSH
75810: LD_INT 1
75812: ARRAY
75813: PUSH
75814: LD_INT 4
75816: ARRAY
75817: PPUSH
75818: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
75822: LD_ADDR_VAR 0 4
75826: PUSH
75827: LD_EXP 71
75831: PUSH
75832: LD_VAR 0 2
75836: ARRAY
75837: PPUSH
75838: LD_INT 1
75840: PPUSH
75841: CALL_OW 3
75845: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
75846: LD_ADDR_EXP 71
75850: PUSH
75851: LD_EXP 71
75855: PPUSH
75856: LD_VAR 0 2
75860: PPUSH
75861: LD_VAR 0 4
75865: PPUSH
75866: CALL_OW 1
75870: ST_TO_ADDR
// break ;
75871: GO 75875
// end ; end ;
75873: GO 75519
75875: POP
75876: POP
// end ;
75877: GO 75451
75879: POP
75880: POP
// end ;
75881: LD_VAR 0 1
75885: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
75886: LD_INT 0
75888: PPUSH
75889: PPUSH
75890: PPUSH
// if not mc_bases then
75891: LD_EXP 50
75895: NOT
75896: IFFALSE 75900
// exit ;
75898: GO 75989
// for i = 1 to mc_bases do
75900: LD_ADDR_VAR 0 2
75904: PUSH
75905: DOUBLE
75906: LD_INT 1
75908: DEC
75909: ST_TO_ADDR
75910: LD_EXP 50
75914: PUSH
75915: FOR_TO
75916: IFFALSE 75987
// begin if mc_attack [ i ] then
75918: LD_EXP 70
75922: PUSH
75923: LD_VAR 0 2
75927: ARRAY
75928: IFFALSE 75985
// begin tmp := mc_attack [ i ] [ 1 ] ;
75930: LD_ADDR_VAR 0 3
75934: PUSH
75935: LD_EXP 70
75939: PUSH
75940: LD_VAR 0 2
75944: ARRAY
75945: PUSH
75946: LD_INT 1
75948: ARRAY
75949: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
75950: LD_ADDR_EXP 70
75954: PUSH
75955: LD_EXP 70
75959: PPUSH
75960: LD_VAR 0 2
75964: PPUSH
75965: EMPTY
75966: PPUSH
75967: CALL_OW 1
75971: ST_TO_ADDR
// Attack ( tmp ) ;
75972: LD_VAR 0 3
75976: PPUSH
75977: CALL 109726 0 1
// exit ;
75981: POP
75982: POP
75983: GO 75989
// end ; end ;
75985: GO 75915
75987: POP
75988: POP
// end ;
75989: LD_VAR 0 1
75993: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
75994: LD_INT 0
75996: PPUSH
75997: PPUSH
75998: PPUSH
75999: PPUSH
76000: PPUSH
76001: PPUSH
76002: PPUSH
// if not mc_bases then
76003: LD_EXP 50
76007: NOT
76008: IFFALSE 76012
// exit ;
76010: GO 76869
// for i = 1 to mc_bases do
76012: LD_ADDR_VAR 0 2
76016: PUSH
76017: DOUBLE
76018: LD_INT 1
76020: DEC
76021: ST_TO_ADDR
76022: LD_EXP 50
76026: PUSH
76027: FOR_TO
76028: IFFALSE 76867
// begin if not mc_bases [ i ] then
76030: LD_EXP 50
76034: PUSH
76035: LD_VAR 0 2
76039: ARRAY
76040: NOT
76041: IFFALSE 76045
// continue ;
76043: GO 76027
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
76045: LD_ADDR_VAR 0 7
76049: PUSH
76050: LD_EXP 50
76054: PUSH
76055: LD_VAR 0 2
76059: ARRAY
76060: PUSH
76061: LD_INT 1
76063: ARRAY
76064: PPUSH
76065: CALL 21658 0 1
76069: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
76070: LD_ADDR_EXP 73
76074: PUSH
76075: LD_EXP 73
76079: PPUSH
76080: LD_VAR 0 2
76084: PPUSH
76085: LD_EXP 50
76089: PUSH
76090: LD_VAR 0 2
76094: ARRAY
76095: PUSH
76096: LD_INT 1
76098: ARRAY
76099: PPUSH
76100: CALL_OW 255
76104: PPUSH
76105: LD_EXP 75
76109: PUSH
76110: LD_VAR 0 2
76114: ARRAY
76115: PPUSH
76116: CALL 21623 0 2
76120: PPUSH
76121: CALL_OW 1
76125: ST_TO_ADDR
// if not mc_scan [ i ] then
76126: LD_EXP 73
76130: PUSH
76131: LD_VAR 0 2
76135: ARRAY
76136: NOT
76137: IFFALSE 76315
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
76139: LD_ADDR_EXP 93
76143: PUSH
76144: LD_EXP 93
76148: PPUSH
76149: LD_VAR 0 2
76153: PPUSH
76154: LD_INT 0
76156: PPUSH
76157: CALL_OW 1
76161: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76162: LD_ADDR_VAR 0 4
76166: PUSH
76167: LD_EXP 50
76171: PUSH
76172: LD_VAR 0 2
76176: ARRAY
76177: PPUSH
76178: LD_INT 2
76180: PUSH
76181: LD_INT 25
76183: PUSH
76184: LD_INT 5
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PUSH
76191: LD_INT 25
76193: PUSH
76194: LD_INT 8
76196: PUSH
76197: EMPTY
76198: LIST
76199: LIST
76200: PUSH
76201: LD_INT 25
76203: PUSH
76204: LD_INT 9
76206: PUSH
76207: EMPTY
76208: LIST
76209: LIST
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: PPUSH
76217: CALL_OW 72
76221: ST_TO_ADDR
// if not tmp then
76222: LD_VAR 0 4
76226: NOT
76227: IFFALSE 76231
// continue ;
76229: GO 76027
// for j in tmp do
76231: LD_ADDR_VAR 0 3
76235: PUSH
76236: LD_VAR 0 4
76240: PUSH
76241: FOR_IN
76242: IFFALSE 76313
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
76244: LD_VAR 0 3
76248: PPUSH
76249: CALL_OW 310
76253: PPUSH
76254: CALL_OW 266
76258: PUSH
76259: LD_INT 5
76261: EQUAL
76262: PUSH
76263: LD_VAR 0 3
76267: PPUSH
76268: CALL_OW 257
76272: PUSH
76273: LD_INT 1
76275: EQUAL
76276: AND
76277: PUSH
76278: LD_VAR 0 3
76282: PPUSH
76283: CALL_OW 459
76287: NOT
76288: AND
76289: PUSH
76290: LD_VAR 0 7
76294: AND
76295: IFFALSE 76311
// ComChangeProfession ( j , class ) ;
76297: LD_VAR 0 3
76301: PPUSH
76302: LD_VAR 0 7
76306: PPUSH
76307: CALL_OW 123
76311: GO 76241
76313: POP
76314: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
76315: LD_EXP 73
76319: PUSH
76320: LD_VAR 0 2
76324: ARRAY
76325: PUSH
76326: LD_EXP 93
76330: PUSH
76331: LD_VAR 0 2
76335: ARRAY
76336: NOT
76337: AND
76338: PUSH
76339: LD_EXP 72
76343: PUSH
76344: LD_VAR 0 2
76348: ARRAY
76349: NOT
76350: AND
76351: PUSH
76352: LD_EXP 50
76356: PUSH
76357: LD_VAR 0 2
76361: ARRAY
76362: PPUSH
76363: LD_INT 50
76365: PUSH
76366: EMPTY
76367: LIST
76368: PUSH
76369: LD_INT 2
76371: PUSH
76372: LD_INT 30
76374: PUSH
76375: LD_INT 32
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: PUSH
76382: LD_INT 30
76384: PUSH
76385: LD_INT 33
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 30
76394: PUSH
76395: LD_INT 4
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: PUSH
76402: LD_INT 30
76404: PUSH
76405: LD_INT 5
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: LIST
76416: LIST
76417: LIST
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PPUSH
76423: CALL_OW 72
76427: PUSH
76428: LD_INT 4
76430: LESS
76431: PUSH
76432: LD_EXP 50
76436: PUSH
76437: LD_VAR 0 2
76441: ARRAY
76442: PPUSH
76443: LD_INT 3
76445: PUSH
76446: LD_INT 24
76448: PUSH
76449: LD_INT 1000
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 2
76462: PUSH
76463: LD_INT 30
76465: PUSH
76466: LD_INT 0
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 30
76475: PUSH
76476: LD_INT 1
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: LIST
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PPUSH
76492: CALL_OW 72
76496: OR
76497: AND
76498: IFFALSE 76749
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
76500: LD_ADDR_EXP 93
76504: PUSH
76505: LD_EXP 93
76509: PPUSH
76510: LD_VAR 0 2
76514: PPUSH
76515: LD_INT 1
76517: PPUSH
76518: CALL_OW 1
76522: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76523: LD_ADDR_VAR 0 4
76527: PUSH
76528: LD_EXP 50
76532: PUSH
76533: LD_VAR 0 2
76537: ARRAY
76538: PPUSH
76539: LD_INT 2
76541: PUSH
76542: LD_INT 25
76544: PUSH
76545: LD_INT 1
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 25
76554: PUSH
76555: LD_INT 5
76557: PUSH
76558: EMPTY
76559: LIST
76560: LIST
76561: PUSH
76562: LD_INT 25
76564: PUSH
76565: LD_INT 8
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 25
76574: PUSH
76575: LD_INT 9
76577: PUSH
76578: EMPTY
76579: LIST
76580: LIST
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: LIST
76586: LIST
76587: LIST
76588: PPUSH
76589: CALL_OW 72
76593: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
76594: LD_ADDR_VAR 0 4
76598: PUSH
76599: LD_VAR 0 4
76603: PUSH
76604: LD_VAR 0 4
76608: PPUSH
76609: LD_INT 18
76611: PPUSH
76612: CALL 54127 0 2
76616: DIFF
76617: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
76618: LD_VAR 0 4
76622: NOT
76623: PUSH
76624: LD_EXP 50
76628: PUSH
76629: LD_VAR 0 2
76633: ARRAY
76634: PPUSH
76635: LD_INT 2
76637: PUSH
76638: LD_INT 30
76640: PUSH
76641: LD_INT 4
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: PUSH
76648: LD_INT 30
76650: PUSH
76651: LD_INT 5
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: LIST
76662: PPUSH
76663: CALL_OW 72
76667: NOT
76668: AND
76669: IFFALSE 76731
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
76671: LD_ADDR_VAR 0 4
76675: PUSH
76676: LD_EXP 50
76680: PUSH
76681: LD_VAR 0 2
76685: ARRAY
76686: PPUSH
76687: LD_INT 2
76689: PUSH
76690: LD_INT 25
76692: PUSH
76693: LD_INT 2
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 25
76702: PUSH
76703: LD_INT 3
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: PUSH
76710: LD_INT 25
76712: PUSH
76713: LD_INT 4
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: LIST
76724: LIST
76725: PPUSH
76726: CALL_OW 72
76730: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
76731: LD_VAR 0 2
76735: PPUSH
76736: LD_VAR 0 4
76740: PPUSH
76741: CALL 114435 0 2
// exit ;
76745: POP
76746: POP
76747: GO 76869
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
76749: LD_EXP 73
76753: PUSH
76754: LD_VAR 0 2
76758: ARRAY
76759: PUSH
76760: LD_EXP 93
76764: PUSH
76765: LD_VAR 0 2
76769: ARRAY
76770: NOT
76771: AND
76772: PUSH
76773: LD_EXP 72
76777: PUSH
76778: LD_VAR 0 2
76782: ARRAY
76783: AND
76784: IFFALSE 76865
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
76786: LD_ADDR_EXP 93
76790: PUSH
76791: LD_EXP 93
76795: PPUSH
76796: LD_VAR 0 2
76800: PPUSH
76801: LD_INT 1
76803: PPUSH
76804: CALL_OW 1
76808: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
76809: LD_ADDR_VAR 0 4
76813: PUSH
76814: LD_EXP 72
76818: PUSH
76819: LD_VAR 0 2
76823: ARRAY
76824: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
76825: LD_ADDR_EXP 72
76829: PUSH
76830: LD_EXP 72
76834: PPUSH
76835: LD_VAR 0 2
76839: PPUSH
76840: EMPTY
76841: PPUSH
76842: CALL_OW 1
76846: ST_TO_ADDR
// Defend ( i , tmp ) ;
76847: LD_VAR 0 2
76851: PPUSH
76852: LD_VAR 0 4
76856: PPUSH
76857: CALL 115031 0 2
// exit ;
76861: POP
76862: POP
76863: GO 76869
// end ; end ;
76865: GO 76027
76867: POP
76868: POP
// end ;
76869: LD_VAR 0 1
76873: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
76874: LD_INT 0
76876: PPUSH
76877: PPUSH
76878: PPUSH
76879: PPUSH
76880: PPUSH
76881: PPUSH
76882: PPUSH
76883: PPUSH
76884: PPUSH
76885: PPUSH
76886: PPUSH
// if not mc_bases then
76887: LD_EXP 50
76891: NOT
76892: IFFALSE 76896
// exit ;
76894: GO 77983
// for i = 1 to mc_bases do
76896: LD_ADDR_VAR 0 2
76900: PUSH
76901: DOUBLE
76902: LD_INT 1
76904: DEC
76905: ST_TO_ADDR
76906: LD_EXP 50
76910: PUSH
76911: FOR_TO
76912: IFFALSE 77981
// begin tmp := mc_lab [ i ] ;
76914: LD_ADDR_VAR 0 6
76918: PUSH
76919: LD_EXP 83
76923: PUSH
76924: LD_VAR 0 2
76928: ARRAY
76929: ST_TO_ADDR
// if not tmp then
76930: LD_VAR 0 6
76934: NOT
76935: IFFALSE 76939
// continue ;
76937: GO 76911
// idle_lab := 0 ;
76939: LD_ADDR_VAR 0 11
76943: PUSH
76944: LD_INT 0
76946: ST_TO_ADDR
// for j in tmp do
76947: LD_ADDR_VAR 0 3
76951: PUSH
76952: LD_VAR 0 6
76956: PUSH
76957: FOR_IN
76958: IFFALSE 77977
// begin researching := false ;
76960: LD_ADDR_VAR 0 10
76964: PUSH
76965: LD_INT 0
76967: ST_TO_ADDR
// side := GetSide ( j ) ;
76968: LD_ADDR_VAR 0 4
76972: PUSH
76973: LD_VAR 0 3
76977: PPUSH
76978: CALL_OW 255
76982: ST_TO_ADDR
// if not mc_tech [ side ] then
76983: LD_EXP 77
76987: PUSH
76988: LD_VAR 0 4
76992: ARRAY
76993: NOT
76994: IFFALSE 76998
// continue ;
76996: GO 76957
// if BuildingStatus ( j ) = bs_idle then
76998: LD_VAR 0 3
77002: PPUSH
77003: CALL_OW 461
77007: PUSH
77008: LD_INT 2
77010: EQUAL
77011: IFFALSE 77199
// begin if idle_lab and UnitsInside ( j ) < 6 then
77013: LD_VAR 0 11
77017: PUSH
77018: LD_VAR 0 3
77022: PPUSH
77023: CALL_OW 313
77027: PUSH
77028: LD_INT 6
77030: LESS
77031: AND
77032: IFFALSE 77103
// begin tmp2 := UnitsInside ( idle_lab ) ;
77034: LD_ADDR_VAR 0 9
77038: PUSH
77039: LD_VAR 0 11
77043: PPUSH
77044: CALL_OW 313
77048: ST_TO_ADDR
// if tmp2 then
77049: LD_VAR 0 9
77053: IFFALSE 77095
// for x in tmp2 do
77055: LD_ADDR_VAR 0 7
77059: PUSH
77060: LD_VAR 0 9
77064: PUSH
77065: FOR_IN
77066: IFFALSE 77093
// begin ComExitBuilding ( x ) ;
77068: LD_VAR 0 7
77072: PPUSH
77073: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77077: LD_VAR 0 7
77081: PPUSH
77082: LD_VAR 0 3
77086: PPUSH
77087: CALL_OW 180
// end ;
77091: GO 77065
77093: POP
77094: POP
// idle_lab := 0 ;
77095: LD_ADDR_VAR 0 11
77099: PUSH
77100: LD_INT 0
77102: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
77103: LD_ADDR_VAR 0 5
77107: PUSH
77108: LD_EXP 77
77112: PUSH
77113: LD_VAR 0 4
77117: ARRAY
77118: PUSH
77119: FOR_IN
77120: IFFALSE 77180
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
77122: LD_VAR 0 3
77126: PPUSH
77127: LD_VAR 0 5
77131: PPUSH
77132: CALL_OW 430
77136: PUSH
77137: LD_VAR 0 4
77141: PPUSH
77142: LD_VAR 0 5
77146: PPUSH
77147: CALL 20728 0 2
77151: AND
77152: IFFALSE 77178
// begin researching := true ;
77154: LD_ADDR_VAR 0 10
77158: PUSH
77159: LD_INT 1
77161: ST_TO_ADDR
// ComResearch ( j , t ) ;
77162: LD_VAR 0 3
77166: PPUSH
77167: LD_VAR 0 5
77171: PPUSH
77172: CALL_OW 124
// break ;
77176: GO 77180
// end ;
77178: GO 77119
77180: POP
77181: POP
// if not researching then
77182: LD_VAR 0 10
77186: NOT
77187: IFFALSE 77199
// idle_lab := j ;
77189: LD_ADDR_VAR 0 11
77193: PUSH
77194: LD_VAR 0 3
77198: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
77199: LD_VAR 0 3
77203: PPUSH
77204: CALL_OW 461
77208: PUSH
77209: LD_INT 10
77211: EQUAL
77212: IFFALSE 77800
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
77214: LD_EXP 79
77218: PUSH
77219: LD_VAR 0 2
77223: ARRAY
77224: NOT
77225: PUSH
77226: LD_EXP 80
77230: PUSH
77231: LD_VAR 0 2
77235: ARRAY
77236: NOT
77237: AND
77238: PUSH
77239: LD_EXP 77
77243: PUSH
77244: LD_VAR 0 4
77248: ARRAY
77249: PUSH
77250: LD_INT 1
77252: GREATER
77253: AND
77254: IFFALSE 77385
// begin ComCancel ( j ) ;
77256: LD_VAR 0 3
77260: PPUSH
77261: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
77265: LD_ADDR_EXP 77
77269: PUSH
77270: LD_EXP 77
77274: PPUSH
77275: LD_VAR 0 4
77279: PPUSH
77280: LD_EXP 77
77284: PUSH
77285: LD_VAR 0 4
77289: ARRAY
77290: PPUSH
77291: LD_EXP 77
77295: PUSH
77296: LD_VAR 0 4
77300: ARRAY
77301: PUSH
77302: LD_INT 1
77304: MINUS
77305: PPUSH
77306: LD_EXP 77
77310: PUSH
77311: LD_VAR 0 4
77315: ARRAY
77316: PPUSH
77317: LD_INT 0
77319: PPUSH
77320: CALL 24276 0 4
77324: PPUSH
77325: CALL_OW 1
77329: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
77330: LD_ADDR_EXP 77
77334: PUSH
77335: LD_EXP 77
77339: PPUSH
77340: LD_VAR 0 4
77344: PPUSH
77345: LD_EXP 77
77349: PUSH
77350: LD_VAR 0 4
77354: ARRAY
77355: PPUSH
77356: LD_EXP 77
77360: PUSH
77361: LD_VAR 0 4
77365: ARRAY
77366: PPUSH
77367: LD_INT 1
77369: PPUSH
77370: LD_INT 0
77372: PPUSH
77373: CALL 24276 0 4
77377: PPUSH
77378: CALL_OW 1
77382: ST_TO_ADDR
// continue ;
77383: GO 76957
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
77385: LD_EXP 79
77389: PUSH
77390: LD_VAR 0 2
77394: ARRAY
77395: PUSH
77396: LD_EXP 80
77400: PUSH
77401: LD_VAR 0 2
77405: ARRAY
77406: NOT
77407: AND
77408: IFFALSE 77535
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
77410: LD_ADDR_EXP 80
77414: PUSH
77415: LD_EXP 80
77419: PPUSH
77420: LD_VAR 0 2
77424: PUSH
77425: LD_EXP 80
77429: PUSH
77430: LD_VAR 0 2
77434: ARRAY
77435: PUSH
77436: LD_INT 1
77438: PLUS
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PPUSH
77444: LD_EXP 79
77448: PUSH
77449: LD_VAR 0 2
77453: ARRAY
77454: PUSH
77455: LD_INT 1
77457: ARRAY
77458: PPUSH
77459: CALL 24858 0 3
77463: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
77464: LD_EXP 79
77468: PUSH
77469: LD_VAR 0 2
77473: ARRAY
77474: PUSH
77475: LD_INT 1
77477: ARRAY
77478: PPUSH
77479: LD_INT 112
77481: PPUSH
77482: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
77486: LD_ADDR_VAR 0 9
77490: PUSH
77491: LD_EXP 79
77495: PUSH
77496: LD_VAR 0 2
77500: ARRAY
77501: PPUSH
77502: LD_INT 1
77504: PPUSH
77505: CALL_OW 3
77509: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
77510: LD_ADDR_EXP 79
77514: PUSH
77515: LD_EXP 79
77519: PPUSH
77520: LD_VAR 0 2
77524: PPUSH
77525: LD_VAR 0 9
77529: PPUSH
77530: CALL_OW 1
77534: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
77535: LD_EXP 79
77539: PUSH
77540: LD_VAR 0 2
77544: ARRAY
77545: PUSH
77546: LD_EXP 80
77550: PUSH
77551: LD_VAR 0 2
77555: ARRAY
77556: AND
77557: PUSH
77558: LD_EXP 80
77562: PUSH
77563: LD_VAR 0 2
77567: ARRAY
77568: PUSH
77569: LD_INT 1
77571: ARRAY
77572: PPUSH
77573: CALL_OW 310
77577: NOT
77578: AND
77579: PUSH
77580: LD_VAR 0 3
77584: PPUSH
77585: CALL_OW 313
77589: PUSH
77590: LD_INT 6
77592: EQUAL
77593: AND
77594: IFFALSE 77650
// begin tmp2 := UnitsInside ( j ) ;
77596: LD_ADDR_VAR 0 9
77600: PUSH
77601: LD_VAR 0 3
77605: PPUSH
77606: CALL_OW 313
77610: ST_TO_ADDR
// if tmp2 = 6 then
77611: LD_VAR 0 9
77615: PUSH
77616: LD_INT 6
77618: EQUAL
77619: IFFALSE 77650
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
77621: LD_VAR 0 9
77625: PUSH
77626: LD_INT 1
77628: ARRAY
77629: PPUSH
77630: LD_INT 112
77632: PPUSH
77633: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
77637: LD_VAR 0 9
77641: PUSH
77642: LD_INT 1
77644: ARRAY
77645: PPUSH
77646: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
77650: LD_EXP 80
77654: PUSH
77655: LD_VAR 0 2
77659: ARRAY
77660: PUSH
77661: LD_EXP 80
77665: PUSH
77666: LD_VAR 0 2
77670: ARRAY
77671: PUSH
77672: LD_INT 1
77674: ARRAY
77675: PPUSH
77676: CALL_OW 314
77680: NOT
77681: AND
77682: PUSH
77683: LD_EXP 80
77687: PUSH
77688: LD_VAR 0 2
77692: ARRAY
77693: PUSH
77694: LD_INT 1
77696: ARRAY
77697: PPUSH
77698: CALL_OW 310
77702: NOT
77703: AND
77704: IFFALSE 77730
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
77706: LD_EXP 80
77710: PUSH
77711: LD_VAR 0 2
77715: ARRAY
77716: PUSH
77717: LD_INT 1
77719: ARRAY
77720: PPUSH
77721: LD_VAR 0 3
77725: PPUSH
77726: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
77730: LD_EXP 80
77734: PUSH
77735: LD_VAR 0 2
77739: ARRAY
77740: PUSH
77741: LD_INT 1
77743: ARRAY
77744: PPUSH
77745: CALL_OW 310
77749: PUSH
77750: LD_EXP 80
77754: PUSH
77755: LD_VAR 0 2
77759: ARRAY
77760: PUSH
77761: LD_INT 1
77763: ARRAY
77764: PPUSH
77765: CALL_OW 310
77769: PPUSH
77770: CALL_OW 461
77774: PUSH
77775: LD_INT 3
77777: NONEQUAL
77778: AND
77779: IFFALSE 77800
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
77781: LD_EXP 80
77785: PUSH
77786: LD_VAR 0 2
77790: ARRAY
77791: PUSH
77792: LD_INT 1
77794: ARRAY
77795: PPUSH
77796: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
77800: LD_VAR 0 3
77804: PPUSH
77805: CALL_OW 461
77809: PUSH
77810: LD_INT 6
77812: EQUAL
77813: PUSH
77814: LD_VAR 0 6
77818: PUSH
77819: LD_INT 1
77821: GREATER
77822: AND
77823: IFFALSE 77975
// begin sci := [ ] ;
77825: LD_ADDR_VAR 0 8
77829: PUSH
77830: EMPTY
77831: ST_TO_ADDR
// for x in ( tmp diff j ) do
77832: LD_ADDR_VAR 0 7
77836: PUSH
77837: LD_VAR 0 6
77841: PUSH
77842: LD_VAR 0 3
77846: DIFF
77847: PUSH
77848: FOR_IN
77849: IFFALSE 77901
// begin if sci = 6 then
77851: LD_VAR 0 8
77855: PUSH
77856: LD_INT 6
77858: EQUAL
77859: IFFALSE 77863
// break ;
77861: GO 77901
// if BuildingStatus ( x ) = bs_idle then
77863: LD_VAR 0 7
77867: PPUSH
77868: CALL_OW 461
77872: PUSH
77873: LD_INT 2
77875: EQUAL
77876: IFFALSE 77899
// sci := sci ^ UnitsInside ( x ) ;
77878: LD_ADDR_VAR 0 8
77882: PUSH
77883: LD_VAR 0 8
77887: PUSH
77888: LD_VAR 0 7
77892: PPUSH
77893: CALL_OW 313
77897: ADD
77898: ST_TO_ADDR
// end ;
77899: GO 77848
77901: POP
77902: POP
// if not sci then
77903: LD_VAR 0 8
77907: NOT
77908: IFFALSE 77912
// continue ;
77910: GO 76957
// for x in sci do
77912: LD_ADDR_VAR 0 7
77916: PUSH
77917: LD_VAR 0 8
77921: PUSH
77922: FOR_IN
77923: IFFALSE 77973
// if IsInUnit ( x ) and not HasTask ( x ) then
77925: LD_VAR 0 7
77929: PPUSH
77930: CALL_OW 310
77934: PUSH
77935: LD_VAR 0 7
77939: PPUSH
77940: CALL_OW 314
77944: NOT
77945: AND
77946: IFFALSE 77971
// begin ComExitBuilding ( x ) ;
77948: LD_VAR 0 7
77952: PPUSH
77953: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77957: LD_VAR 0 7
77961: PPUSH
77962: LD_VAR 0 3
77966: PPUSH
77967: CALL_OW 180
// end ;
77971: GO 77922
77973: POP
77974: POP
// end ; end ;
77975: GO 76957
77977: POP
77978: POP
// end ;
77979: GO 76911
77981: POP
77982: POP
// end ;
77983: LD_VAR 0 1
77987: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
77988: LD_INT 0
77990: PPUSH
77991: PPUSH
// if not mc_bases then
77992: LD_EXP 50
77996: NOT
77997: IFFALSE 78001
// exit ;
77999: GO 78082
// for i = 1 to mc_bases do
78001: LD_ADDR_VAR 0 2
78005: PUSH
78006: DOUBLE
78007: LD_INT 1
78009: DEC
78010: ST_TO_ADDR
78011: LD_EXP 50
78015: PUSH
78016: FOR_TO
78017: IFFALSE 78080
// if mc_mines [ i ] and mc_miners [ i ] then
78019: LD_EXP 63
78023: PUSH
78024: LD_VAR 0 2
78028: ARRAY
78029: PUSH
78030: LD_EXP 64
78034: PUSH
78035: LD_VAR 0 2
78039: ARRAY
78040: AND
78041: IFFALSE 78078
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
78043: LD_EXP 64
78047: PUSH
78048: LD_VAR 0 2
78052: ARRAY
78053: PUSH
78054: LD_INT 1
78056: ARRAY
78057: PPUSH
78058: CALL_OW 255
78062: PPUSH
78063: LD_EXP 63
78067: PUSH
78068: LD_VAR 0 2
78072: ARRAY
78073: PPUSH
78074: CALL 21811 0 2
78078: GO 78016
78080: POP
78081: POP
// end ;
78082: LD_VAR 0 1
78086: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
78087: LD_INT 0
78089: PPUSH
78090: PPUSH
78091: PPUSH
78092: PPUSH
78093: PPUSH
78094: PPUSH
78095: PPUSH
78096: PPUSH
// if not mc_bases or not mc_parking then
78097: LD_EXP 50
78101: NOT
78102: PUSH
78103: LD_EXP 74
78107: NOT
78108: OR
78109: IFFALSE 78113
// exit ;
78111: GO 78823
// for i = 1 to mc_bases do
78113: LD_ADDR_VAR 0 2
78117: PUSH
78118: DOUBLE
78119: LD_INT 1
78121: DEC
78122: ST_TO_ADDR
78123: LD_EXP 50
78127: PUSH
78128: FOR_TO
78129: IFFALSE 78821
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
78131: LD_EXP 50
78135: PUSH
78136: LD_VAR 0 2
78140: ARRAY
78141: NOT
78142: PUSH
78143: LD_EXP 74
78147: PUSH
78148: LD_VAR 0 2
78152: ARRAY
78153: NOT
78154: OR
78155: IFFALSE 78159
// continue ;
78157: GO 78128
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
78159: LD_ADDR_VAR 0 5
78163: PUSH
78164: LD_EXP 50
78168: PUSH
78169: LD_VAR 0 2
78173: ARRAY
78174: PUSH
78175: LD_INT 1
78177: ARRAY
78178: PPUSH
78179: CALL_OW 255
78183: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78184: LD_ADDR_VAR 0 6
78188: PUSH
78189: LD_EXP 50
78193: PUSH
78194: LD_VAR 0 2
78198: ARRAY
78199: PPUSH
78200: LD_INT 30
78202: PUSH
78203: LD_INT 3
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: PPUSH
78210: CALL_OW 72
78214: ST_TO_ADDR
// if not fac then
78215: LD_VAR 0 6
78219: NOT
78220: IFFALSE 78271
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78222: LD_ADDR_VAR 0 6
78226: PUSH
78227: LD_EXP 50
78231: PUSH
78232: LD_VAR 0 2
78236: ARRAY
78237: PPUSH
78238: LD_INT 2
78240: PUSH
78241: LD_INT 30
78243: PUSH
78244: LD_INT 0
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 30
78253: PUSH
78254: LD_INT 1
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: EMPTY
78262: LIST
78263: LIST
78264: LIST
78265: PPUSH
78266: CALL_OW 72
78270: ST_TO_ADDR
// if not fac then
78271: LD_VAR 0 6
78275: NOT
78276: IFFALSE 78280
// continue ;
78278: GO 78128
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
78280: LD_ADDR_VAR 0 7
78284: PUSH
78285: LD_EXP 74
78289: PUSH
78290: LD_VAR 0 2
78294: ARRAY
78295: PPUSH
78296: LD_INT 22
78298: PUSH
78299: LD_VAR 0 5
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 21
78310: PUSH
78311: LD_INT 2
78313: PUSH
78314: EMPTY
78315: LIST
78316: LIST
78317: PUSH
78318: LD_INT 3
78320: PUSH
78321: LD_INT 24
78323: PUSH
78324: LD_INT 1000
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: EMPTY
78332: LIST
78333: LIST
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: LIST
78339: PPUSH
78340: CALL_OW 70
78344: ST_TO_ADDR
// for j in fac do
78345: LD_ADDR_VAR 0 3
78349: PUSH
78350: LD_VAR 0 6
78354: PUSH
78355: FOR_IN
78356: IFFALSE 78437
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
78358: LD_ADDR_VAR 0 7
78362: PUSH
78363: LD_VAR 0 7
78367: PUSH
78368: LD_INT 22
78370: PUSH
78371: LD_VAR 0 5
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: PUSH
78380: LD_INT 91
78382: PUSH
78383: LD_VAR 0 3
78387: PUSH
78388: LD_INT 15
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 21
78398: PUSH
78399: LD_INT 2
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 3
78408: PUSH
78409: LD_INT 24
78411: PUSH
78412: LD_INT 1000
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: PPUSH
78429: CALL_OW 69
78433: UNION
78434: ST_TO_ADDR
78435: GO 78355
78437: POP
78438: POP
// if not vehs then
78439: LD_VAR 0 7
78443: NOT
78444: IFFALSE 78470
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
78446: LD_ADDR_EXP 62
78450: PUSH
78451: LD_EXP 62
78455: PPUSH
78456: LD_VAR 0 2
78460: PPUSH
78461: EMPTY
78462: PPUSH
78463: CALL_OW 1
78467: ST_TO_ADDR
// continue ;
78468: GO 78128
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78470: LD_ADDR_VAR 0 8
78474: PUSH
78475: LD_EXP 50
78479: PUSH
78480: LD_VAR 0 2
78484: ARRAY
78485: PPUSH
78486: LD_INT 30
78488: PUSH
78489: LD_INT 3
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PPUSH
78496: CALL_OW 72
78500: ST_TO_ADDR
// if tmp then
78501: LD_VAR 0 8
78505: IFFALSE 78608
// begin for j in tmp do
78507: LD_ADDR_VAR 0 3
78511: PUSH
78512: LD_VAR 0 8
78516: PUSH
78517: FOR_IN
78518: IFFALSE 78606
// for k in UnitsInside ( j ) do
78520: LD_ADDR_VAR 0 4
78524: PUSH
78525: LD_VAR 0 3
78529: PPUSH
78530: CALL_OW 313
78534: PUSH
78535: FOR_IN
78536: IFFALSE 78602
// if k then
78538: LD_VAR 0 4
78542: IFFALSE 78600
// if not k in mc_repair_vehicle [ i ] then
78544: LD_VAR 0 4
78548: PUSH
78549: LD_EXP 62
78553: PUSH
78554: LD_VAR 0 2
78558: ARRAY
78559: IN
78560: NOT
78561: IFFALSE 78600
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
78563: LD_ADDR_EXP 62
78567: PUSH
78568: LD_EXP 62
78572: PPUSH
78573: LD_VAR 0 2
78577: PPUSH
78578: LD_EXP 62
78582: PUSH
78583: LD_VAR 0 2
78587: ARRAY
78588: PUSH
78589: LD_VAR 0 4
78593: UNION
78594: PPUSH
78595: CALL_OW 1
78599: ST_TO_ADDR
78600: GO 78535
78602: POP
78603: POP
78604: GO 78517
78606: POP
78607: POP
// end ; if not mc_repair_vehicle [ i ] then
78608: LD_EXP 62
78612: PUSH
78613: LD_VAR 0 2
78617: ARRAY
78618: NOT
78619: IFFALSE 78623
// continue ;
78621: GO 78128
// for j in mc_repair_vehicle [ i ] do
78623: LD_ADDR_VAR 0 3
78627: PUSH
78628: LD_EXP 62
78632: PUSH
78633: LD_VAR 0 2
78637: ARRAY
78638: PUSH
78639: FOR_IN
78640: IFFALSE 78817
// begin if GetClass ( j ) <> 3 then
78642: LD_VAR 0 3
78646: PPUSH
78647: CALL_OW 257
78651: PUSH
78652: LD_INT 3
78654: NONEQUAL
78655: IFFALSE 78696
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
78657: LD_ADDR_EXP 62
78661: PUSH
78662: LD_EXP 62
78666: PPUSH
78667: LD_VAR 0 2
78671: PPUSH
78672: LD_EXP 62
78676: PUSH
78677: LD_VAR 0 2
78681: ARRAY
78682: PUSH
78683: LD_VAR 0 3
78687: DIFF
78688: PPUSH
78689: CALL_OW 1
78693: ST_TO_ADDR
// continue ;
78694: GO 78639
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
78696: LD_VAR 0 3
78700: PPUSH
78701: CALL_OW 311
78705: NOT
78706: PUSH
78707: LD_VAR 0 3
78711: PUSH
78712: LD_EXP 53
78716: PUSH
78717: LD_VAR 0 2
78721: ARRAY
78722: PUSH
78723: LD_INT 1
78725: ARRAY
78726: IN
78727: NOT
78728: AND
78729: PUSH
78730: LD_VAR 0 3
78734: PUSH
78735: LD_EXP 53
78739: PUSH
78740: LD_VAR 0 2
78744: ARRAY
78745: PUSH
78746: LD_INT 2
78748: ARRAY
78749: IN
78750: NOT
78751: AND
78752: IFFALSE 78815
// begin if IsInUnit ( j ) then
78754: LD_VAR 0 3
78758: PPUSH
78759: CALL_OW 310
78763: IFFALSE 78776
// ComExitBuilding ( j ) else
78765: LD_VAR 0 3
78769: PPUSH
78770: CALL_OW 122
78774: GO 78815
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
78776: LD_VAR 0 3
78780: PPUSH
78781: LD_VAR 0 7
78785: PUSH
78786: LD_INT 1
78788: ARRAY
78789: PPUSH
78790: CALL 58666 0 2
78794: NOT
78795: IFFALSE 78815
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
78797: LD_VAR 0 3
78801: PPUSH
78802: LD_VAR 0 7
78806: PUSH
78807: LD_INT 1
78809: ARRAY
78810: PPUSH
78811: CALL_OW 129
// end ; end ;
78815: GO 78639
78817: POP
78818: POP
// end ;
78819: GO 78128
78821: POP
78822: POP
// end ;
78823: LD_VAR 0 1
78827: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
78828: LD_INT 0
78830: PPUSH
78831: PPUSH
78832: PPUSH
78833: PPUSH
78834: PPUSH
78835: PPUSH
78836: PPUSH
78837: PPUSH
78838: PPUSH
78839: PPUSH
78840: PPUSH
// if not mc_bases then
78841: LD_EXP 50
78845: NOT
78846: IFFALSE 78850
// exit ;
78848: GO 79652
// for i = 1 to mc_bases do
78850: LD_ADDR_VAR 0 2
78854: PUSH
78855: DOUBLE
78856: LD_INT 1
78858: DEC
78859: ST_TO_ADDR
78860: LD_EXP 50
78864: PUSH
78865: FOR_TO
78866: IFFALSE 79650
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
78868: LD_EXP 78
78872: PUSH
78873: LD_VAR 0 2
78877: ARRAY
78878: NOT
78879: PUSH
78880: LD_EXP 53
78884: PUSH
78885: LD_VAR 0 2
78889: ARRAY
78890: PUSH
78891: LD_INT 1
78893: ARRAY
78894: OR
78895: PUSH
78896: LD_EXP 53
78900: PUSH
78901: LD_VAR 0 2
78905: ARRAY
78906: PUSH
78907: LD_INT 2
78909: ARRAY
78910: OR
78911: PUSH
78912: LD_EXP 76
78916: PUSH
78917: LD_VAR 0 2
78921: ARRAY
78922: PPUSH
78923: LD_INT 1
78925: PPUSH
78926: CALL_OW 325
78930: NOT
78931: OR
78932: PUSH
78933: LD_EXP 73
78937: PUSH
78938: LD_VAR 0 2
78942: ARRAY
78943: OR
78944: IFFALSE 78948
// continue ;
78946: GO 78865
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
78948: LD_ADDR_VAR 0 8
78952: PUSH
78953: LD_EXP 50
78957: PUSH
78958: LD_VAR 0 2
78962: ARRAY
78963: PPUSH
78964: LD_INT 25
78966: PUSH
78967: LD_INT 4
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 50
78976: PUSH
78977: EMPTY
78978: LIST
78979: PUSH
78980: LD_INT 3
78982: PUSH
78983: LD_INT 60
78985: PUSH
78986: EMPTY
78987: LIST
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: LIST
78997: PPUSH
78998: CALL_OW 72
79002: PUSH
79003: LD_EXP 54
79007: PUSH
79008: LD_VAR 0 2
79012: ARRAY
79013: DIFF
79014: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79015: LD_ADDR_VAR 0 9
79019: PUSH
79020: LD_EXP 50
79024: PUSH
79025: LD_VAR 0 2
79029: ARRAY
79030: PPUSH
79031: LD_INT 2
79033: PUSH
79034: LD_INT 30
79036: PUSH
79037: LD_INT 0
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 30
79046: PUSH
79047: LD_INT 1
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: LIST
79058: PPUSH
79059: CALL_OW 72
79063: ST_TO_ADDR
// if not tmp or not dep then
79064: LD_VAR 0 8
79068: NOT
79069: PUSH
79070: LD_VAR 0 9
79074: NOT
79075: OR
79076: IFFALSE 79080
// continue ;
79078: GO 78865
// side := GetSide ( tmp [ 1 ] ) ;
79080: LD_ADDR_VAR 0 11
79084: PUSH
79085: LD_VAR 0 8
79089: PUSH
79090: LD_INT 1
79092: ARRAY
79093: PPUSH
79094: CALL_OW 255
79098: ST_TO_ADDR
// dep := dep [ 1 ] ;
79099: LD_ADDR_VAR 0 9
79103: PUSH
79104: LD_VAR 0 9
79108: PUSH
79109: LD_INT 1
79111: ARRAY
79112: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
79113: LD_ADDR_VAR 0 7
79117: PUSH
79118: LD_EXP 78
79122: PUSH
79123: LD_VAR 0 2
79127: ARRAY
79128: PPUSH
79129: LD_INT 22
79131: PUSH
79132: LD_INT 0
79134: PUSH
79135: EMPTY
79136: LIST
79137: LIST
79138: PUSH
79139: LD_INT 25
79141: PUSH
79142: LD_INT 12
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: PPUSH
79153: CALL_OW 70
79157: PUSH
79158: LD_INT 22
79160: PUSH
79161: LD_INT 0
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: PUSH
79168: LD_INT 25
79170: PUSH
79171: LD_INT 12
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PUSH
79178: LD_INT 91
79180: PUSH
79181: LD_VAR 0 9
79185: PUSH
79186: LD_INT 20
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: LIST
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: LIST
79198: PPUSH
79199: CALL_OW 69
79203: UNION
79204: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
79205: LD_ADDR_VAR 0 10
79209: PUSH
79210: LD_EXP 78
79214: PUSH
79215: LD_VAR 0 2
79219: ARRAY
79220: PPUSH
79221: LD_INT 81
79223: PUSH
79224: LD_VAR 0 11
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PPUSH
79233: CALL_OW 70
79237: ST_TO_ADDR
// if not apes or danger_at_area then
79238: LD_VAR 0 7
79242: NOT
79243: PUSH
79244: LD_VAR 0 10
79248: OR
79249: IFFALSE 79299
// begin if mc_taming [ i ] then
79251: LD_EXP 81
79255: PUSH
79256: LD_VAR 0 2
79260: ARRAY
79261: IFFALSE 79297
// begin MC_Reset ( i , 121 ) ;
79263: LD_VAR 0 2
79267: PPUSH
79268: LD_INT 121
79270: PPUSH
79271: CALL 64285 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
79275: LD_ADDR_EXP 81
79279: PUSH
79280: LD_EXP 81
79284: PPUSH
79285: LD_VAR 0 2
79289: PPUSH
79290: EMPTY
79291: PPUSH
79292: CALL_OW 1
79296: ST_TO_ADDR
// end ; continue ;
79297: GO 78865
// end ; for j in tmp do
79299: LD_ADDR_VAR 0 3
79303: PUSH
79304: LD_VAR 0 8
79308: PUSH
79309: FOR_IN
79310: IFFALSE 79646
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
79312: LD_VAR 0 3
79316: PUSH
79317: LD_EXP 81
79321: PUSH
79322: LD_VAR 0 2
79326: ARRAY
79327: IN
79328: NOT
79329: PUSH
79330: LD_EXP 81
79334: PUSH
79335: LD_VAR 0 2
79339: ARRAY
79340: PUSH
79341: LD_INT 3
79343: LESS
79344: AND
79345: IFFALSE 79403
// begin SetTag ( j , 121 ) ;
79347: LD_VAR 0 3
79351: PPUSH
79352: LD_INT 121
79354: PPUSH
79355: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
79359: LD_ADDR_EXP 81
79363: PUSH
79364: LD_EXP 81
79368: PPUSH
79369: LD_VAR 0 2
79373: PUSH
79374: LD_EXP 81
79378: PUSH
79379: LD_VAR 0 2
79383: ARRAY
79384: PUSH
79385: LD_INT 1
79387: PLUS
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: PPUSH
79393: LD_VAR 0 3
79397: PPUSH
79398: CALL 24858 0 3
79402: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
79403: LD_VAR 0 3
79407: PUSH
79408: LD_EXP 81
79412: PUSH
79413: LD_VAR 0 2
79417: ARRAY
79418: IN
79419: IFFALSE 79644
// begin if GetClass ( j ) <> 4 then
79421: LD_VAR 0 3
79425: PPUSH
79426: CALL_OW 257
79430: PUSH
79431: LD_INT 4
79433: NONEQUAL
79434: IFFALSE 79487
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
79436: LD_ADDR_EXP 81
79440: PUSH
79441: LD_EXP 81
79445: PPUSH
79446: LD_VAR 0 2
79450: PPUSH
79451: LD_EXP 81
79455: PUSH
79456: LD_VAR 0 2
79460: ARRAY
79461: PUSH
79462: LD_VAR 0 3
79466: DIFF
79467: PPUSH
79468: CALL_OW 1
79472: ST_TO_ADDR
// SetTag ( j , 0 ) ;
79473: LD_VAR 0 3
79477: PPUSH
79478: LD_INT 0
79480: PPUSH
79481: CALL_OW 109
// continue ;
79485: GO 79309
// end ; if IsInUnit ( j ) then
79487: LD_VAR 0 3
79491: PPUSH
79492: CALL_OW 310
79496: IFFALSE 79507
// ComExitBuilding ( j ) ;
79498: LD_VAR 0 3
79502: PPUSH
79503: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
79507: LD_ADDR_VAR 0 6
79511: PUSH
79512: LD_VAR 0 7
79516: PPUSH
79517: LD_VAR 0 3
79521: PPUSH
79522: CALL_OW 74
79526: ST_TO_ADDR
// if not ape then
79527: LD_VAR 0 6
79531: NOT
79532: IFFALSE 79536
// break ;
79534: GO 79646
// x := GetX ( ape ) ;
79536: LD_ADDR_VAR 0 4
79540: PUSH
79541: LD_VAR 0 6
79545: PPUSH
79546: CALL_OW 250
79550: ST_TO_ADDR
// y := GetY ( ape ) ;
79551: LD_ADDR_VAR 0 5
79555: PUSH
79556: LD_VAR 0 6
79560: PPUSH
79561: CALL_OW 251
79565: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79566: LD_VAR 0 4
79570: PPUSH
79571: LD_VAR 0 5
79575: PPUSH
79576: CALL_OW 488
79580: NOT
79581: PUSH
79582: LD_VAR 0 11
79586: PPUSH
79587: LD_VAR 0 4
79591: PPUSH
79592: LD_VAR 0 5
79596: PPUSH
79597: LD_INT 20
79599: PPUSH
79600: CALL 25754 0 4
79604: PUSH
79605: LD_INT 4
79607: ARRAY
79608: OR
79609: IFFALSE 79613
// break ;
79611: GO 79646
// if not HasTask ( j ) then
79613: LD_VAR 0 3
79617: PPUSH
79618: CALL_OW 314
79622: NOT
79623: IFFALSE 79644
// ComTameXY ( j , x , y ) ;
79625: LD_VAR 0 3
79629: PPUSH
79630: LD_VAR 0 4
79634: PPUSH
79635: LD_VAR 0 5
79639: PPUSH
79640: CALL_OW 131
// end ; end ;
79644: GO 79309
79646: POP
79647: POP
// end ;
79648: GO 78865
79650: POP
79651: POP
// end ;
79652: LD_VAR 0 1
79656: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
79657: LD_INT 0
79659: PPUSH
79660: PPUSH
79661: PPUSH
79662: PPUSH
79663: PPUSH
79664: PPUSH
79665: PPUSH
79666: PPUSH
// if not mc_bases then
79667: LD_EXP 50
79671: NOT
79672: IFFALSE 79676
// exit ;
79674: GO 80302
// for i = 1 to mc_bases do
79676: LD_ADDR_VAR 0 2
79680: PUSH
79681: DOUBLE
79682: LD_INT 1
79684: DEC
79685: ST_TO_ADDR
79686: LD_EXP 50
79690: PUSH
79691: FOR_TO
79692: IFFALSE 80300
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
79694: LD_EXP 79
79698: PUSH
79699: LD_VAR 0 2
79703: ARRAY
79704: NOT
79705: PUSH
79706: LD_EXP 79
79710: PUSH
79711: LD_VAR 0 2
79715: ARRAY
79716: PPUSH
79717: LD_INT 25
79719: PUSH
79720: LD_INT 12
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PPUSH
79727: CALL_OW 72
79731: NOT
79732: OR
79733: IFFALSE 79737
// continue ;
79735: GO 79691
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
79737: LD_ADDR_VAR 0 5
79741: PUSH
79742: LD_EXP 79
79746: PUSH
79747: LD_VAR 0 2
79751: ARRAY
79752: PUSH
79753: LD_INT 1
79755: ARRAY
79756: PPUSH
79757: CALL_OW 255
79761: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
79762: LD_VAR 0 5
79766: PPUSH
79767: LD_INT 2
79769: PPUSH
79770: CALL_OW 325
79774: IFFALSE 80027
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
79776: LD_ADDR_VAR 0 4
79780: PUSH
79781: LD_EXP 79
79785: PUSH
79786: LD_VAR 0 2
79790: ARRAY
79791: PPUSH
79792: LD_INT 25
79794: PUSH
79795: LD_INT 16
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PPUSH
79802: CALL_OW 72
79806: ST_TO_ADDR
// if tmp < 6 then
79807: LD_VAR 0 4
79811: PUSH
79812: LD_INT 6
79814: LESS
79815: IFFALSE 80027
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79817: LD_ADDR_VAR 0 6
79821: PUSH
79822: LD_EXP 50
79826: PUSH
79827: LD_VAR 0 2
79831: ARRAY
79832: PPUSH
79833: LD_INT 2
79835: PUSH
79836: LD_INT 30
79838: PUSH
79839: LD_INT 0
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: LD_INT 30
79848: PUSH
79849: LD_INT 1
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: LIST
79860: PPUSH
79861: CALL_OW 72
79865: ST_TO_ADDR
// if depot then
79866: LD_VAR 0 6
79870: IFFALSE 80027
// begin selected := 0 ;
79872: LD_ADDR_VAR 0 7
79876: PUSH
79877: LD_INT 0
79879: ST_TO_ADDR
// for j in depot do
79880: LD_ADDR_VAR 0 3
79884: PUSH
79885: LD_VAR 0 6
79889: PUSH
79890: FOR_IN
79891: IFFALSE 79922
// begin if UnitsInside ( j ) < 6 then
79893: LD_VAR 0 3
79897: PPUSH
79898: CALL_OW 313
79902: PUSH
79903: LD_INT 6
79905: LESS
79906: IFFALSE 79920
// begin selected := j ;
79908: LD_ADDR_VAR 0 7
79912: PUSH
79913: LD_VAR 0 3
79917: ST_TO_ADDR
// break ;
79918: GO 79922
// end ; end ;
79920: GO 79890
79922: POP
79923: POP
// if selected then
79924: LD_VAR 0 7
79928: IFFALSE 80027
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79930: LD_ADDR_VAR 0 3
79934: PUSH
79935: LD_EXP 79
79939: PUSH
79940: LD_VAR 0 2
79944: ARRAY
79945: PPUSH
79946: LD_INT 25
79948: PUSH
79949: LD_INT 12
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PPUSH
79956: CALL_OW 72
79960: PUSH
79961: FOR_IN
79962: IFFALSE 80025
// if not HasTask ( j ) then
79964: LD_VAR 0 3
79968: PPUSH
79969: CALL_OW 314
79973: NOT
79974: IFFALSE 80023
// begin if not IsInUnit ( j ) then
79976: LD_VAR 0 3
79980: PPUSH
79981: CALL_OW 310
79985: NOT
79986: IFFALSE 80002
// ComEnterUnit ( j , selected ) ;
79988: LD_VAR 0 3
79992: PPUSH
79993: LD_VAR 0 7
79997: PPUSH
79998: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
80002: LD_VAR 0 3
80006: PPUSH
80007: LD_INT 16
80009: PPUSH
80010: CALL_OW 183
// AddComExitBuilding ( j ) ;
80014: LD_VAR 0 3
80018: PPUSH
80019: CALL_OW 182
// end ;
80023: GO 79961
80025: POP
80026: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
80027: LD_VAR 0 5
80031: PPUSH
80032: LD_INT 11
80034: PPUSH
80035: CALL_OW 325
80039: IFFALSE 80298
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80041: LD_ADDR_VAR 0 4
80045: PUSH
80046: LD_EXP 79
80050: PUSH
80051: LD_VAR 0 2
80055: ARRAY
80056: PPUSH
80057: LD_INT 25
80059: PUSH
80060: LD_INT 16
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PPUSH
80067: CALL_OW 72
80071: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
80072: LD_VAR 0 4
80076: PUSH
80077: LD_INT 6
80079: GREATEREQUAL
80080: PUSH
80081: LD_VAR 0 5
80085: PPUSH
80086: LD_INT 2
80088: PPUSH
80089: CALL_OW 325
80093: NOT
80094: OR
80095: IFFALSE 80298
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80097: LD_ADDR_VAR 0 8
80101: PUSH
80102: LD_EXP 50
80106: PUSH
80107: LD_VAR 0 2
80111: ARRAY
80112: PPUSH
80113: LD_INT 2
80115: PUSH
80116: LD_INT 30
80118: PUSH
80119: LD_INT 4
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 30
80128: PUSH
80129: LD_INT 5
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: LIST
80140: PPUSH
80141: CALL_OW 72
80145: ST_TO_ADDR
// if barracks then
80146: LD_VAR 0 8
80150: IFFALSE 80298
// begin selected := 0 ;
80152: LD_ADDR_VAR 0 7
80156: PUSH
80157: LD_INT 0
80159: ST_TO_ADDR
// for j in barracks do
80160: LD_ADDR_VAR 0 3
80164: PUSH
80165: LD_VAR 0 8
80169: PUSH
80170: FOR_IN
80171: IFFALSE 80202
// begin if UnitsInside ( j ) < 6 then
80173: LD_VAR 0 3
80177: PPUSH
80178: CALL_OW 313
80182: PUSH
80183: LD_INT 6
80185: LESS
80186: IFFALSE 80200
// begin selected := j ;
80188: LD_ADDR_VAR 0 7
80192: PUSH
80193: LD_VAR 0 3
80197: ST_TO_ADDR
// break ;
80198: GO 80202
// end ; end ;
80200: GO 80170
80202: POP
80203: POP
// if selected then
80204: LD_VAR 0 7
80208: IFFALSE 80298
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
80210: LD_ADDR_VAR 0 3
80214: PUSH
80215: LD_EXP 79
80219: PUSH
80220: LD_VAR 0 2
80224: ARRAY
80225: PPUSH
80226: LD_INT 25
80228: PUSH
80229: LD_INT 12
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PPUSH
80236: CALL_OW 72
80240: PUSH
80241: FOR_IN
80242: IFFALSE 80296
// if not IsInUnit ( j ) and not HasTask ( j ) then
80244: LD_VAR 0 3
80248: PPUSH
80249: CALL_OW 310
80253: NOT
80254: PUSH
80255: LD_VAR 0 3
80259: PPUSH
80260: CALL_OW 314
80264: NOT
80265: AND
80266: IFFALSE 80294
// begin ComEnterUnit ( j , selected ) ;
80268: LD_VAR 0 3
80272: PPUSH
80273: LD_VAR 0 7
80277: PPUSH
80278: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
80282: LD_VAR 0 3
80286: PPUSH
80287: LD_INT 15
80289: PPUSH
80290: CALL_OW 183
// end ;
80294: GO 80241
80296: POP
80297: POP
// end ; end ; end ; end ; end ;
80298: GO 79691
80300: POP
80301: POP
// end ;
80302: LD_VAR 0 1
80306: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
80307: LD_INT 0
80309: PPUSH
80310: PPUSH
80311: PPUSH
80312: PPUSH
// if not mc_bases then
80313: LD_EXP 50
80317: NOT
80318: IFFALSE 80322
// exit ;
80320: GO 80500
// for i = 1 to mc_bases do
80322: LD_ADDR_VAR 0 2
80326: PUSH
80327: DOUBLE
80328: LD_INT 1
80330: DEC
80331: ST_TO_ADDR
80332: LD_EXP 50
80336: PUSH
80337: FOR_TO
80338: IFFALSE 80498
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
80340: LD_ADDR_VAR 0 4
80344: PUSH
80345: LD_EXP 50
80349: PUSH
80350: LD_VAR 0 2
80354: ARRAY
80355: PPUSH
80356: LD_INT 25
80358: PUSH
80359: LD_INT 9
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PPUSH
80366: CALL_OW 72
80370: ST_TO_ADDR
// if not tmp then
80371: LD_VAR 0 4
80375: NOT
80376: IFFALSE 80380
// continue ;
80378: GO 80337
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
80380: LD_EXP 76
80384: PUSH
80385: LD_VAR 0 2
80389: ARRAY
80390: PPUSH
80391: LD_INT 29
80393: PPUSH
80394: CALL_OW 325
80398: NOT
80399: PUSH
80400: LD_EXP 76
80404: PUSH
80405: LD_VAR 0 2
80409: ARRAY
80410: PPUSH
80411: LD_INT 28
80413: PPUSH
80414: CALL_OW 325
80418: NOT
80419: AND
80420: IFFALSE 80424
// continue ;
80422: GO 80337
// for j in tmp do
80424: LD_ADDR_VAR 0 3
80428: PUSH
80429: LD_VAR 0 4
80433: PUSH
80434: FOR_IN
80435: IFFALSE 80494
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
80437: LD_VAR 0 3
80441: PUSH
80442: LD_EXP 53
80446: PUSH
80447: LD_VAR 0 2
80451: ARRAY
80452: PUSH
80453: LD_INT 1
80455: ARRAY
80456: IN
80457: NOT
80458: PUSH
80459: LD_VAR 0 3
80463: PUSH
80464: LD_EXP 53
80468: PUSH
80469: LD_VAR 0 2
80473: ARRAY
80474: PUSH
80475: LD_INT 2
80477: ARRAY
80478: IN
80479: NOT
80480: AND
80481: IFFALSE 80492
// ComSpaceTimeShoot ( j ) ;
80483: LD_VAR 0 3
80487: PPUSH
80488: CALL 20819 0 1
80492: GO 80434
80494: POP
80495: POP
// end ;
80496: GO 80337
80498: POP
80499: POP
// end ;
80500: LD_VAR 0 1
80504: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
80505: LD_INT 0
80507: PPUSH
80508: PPUSH
80509: PPUSH
80510: PPUSH
80511: PPUSH
80512: PPUSH
80513: PPUSH
80514: PPUSH
80515: PPUSH
// if not mc_bases then
80516: LD_EXP 50
80520: NOT
80521: IFFALSE 80525
// exit ;
80523: GO 81147
// for i = 1 to mc_bases do
80525: LD_ADDR_VAR 0 2
80529: PUSH
80530: DOUBLE
80531: LD_INT 1
80533: DEC
80534: ST_TO_ADDR
80535: LD_EXP 50
80539: PUSH
80540: FOR_TO
80541: IFFALSE 81145
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
80543: LD_EXP 85
80547: PUSH
80548: LD_VAR 0 2
80552: ARRAY
80553: NOT
80554: PUSH
80555: LD_INT 38
80557: PPUSH
80558: LD_EXP 76
80562: PUSH
80563: LD_VAR 0 2
80567: ARRAY
80568: PPUSH
80569: CALL_OW 321
80573: PUSH
80574: LD_INT 2
80576: NONEQUAL
80577: OR
80578: IFFALSE 80582
// continue ;
80580: GO 80540
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
80582: LD_ADDR_VAR 0 8
80586: PUSH
80587: LD_EXP 50
80591: PUSH
80592: LD_VAR 0 2
80596: ARRAY
80597: PPUSH
80598: LD_INT 30
80600: PUSH
80601: LD_INT 34
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PPUSH
80608: CALL_OW 72
80612: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
80613: LD_ADDR_VAR 0 9
80617: PUSH
80618: LD_EXP 50
80622: PUSH
80623: LD_VAR 0 2
80627: ARRAY
80628: PPUSH
80629: LD_INT 25
80631: PUSH
80632: LD_INT 4
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PPUSH
80639: CALL_OW 72
80643: PPUSH
80644: LD_INT 0
80646: PPUSH
80647: CALL 54127 0 2
80651: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
80652: LD_VAR 0 9
80656: NOT
80657: PUSH
80658: LD_VAR 0 8
80662: NOT
80663: OR
80664: PUSH
80665: LD_EXP 50
80669: PUSH
80670: LD_VAR 0 2
80674: ARRAY
80675: PPUSH
80676: LD_INT 124
80678: PPUSH
80679: CALL 54127 0 2
80683: OR
80684: IFFALSE 80688
// continue ;
80686: GO 80540
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
80688: LD_EXP 86
80692: PUSH
80693: LD_VAR 0 2
80697: ARRAY
80698: PUSH
80699: LD_EXP 85
80703: PUSH
80704: LD_VAR 0 2
80708: ARRAY
80709: LESS
80710: PUSH
80711: LD_EXP 86
80715: PUSH
80716: LD_VAR 0 2
80720: ARRAY
80721: PUSH
80722: LD_VAR 0 8
80726: LESS
80727: AND
80728: IFFALSE 81143
// begin tmp := sci [ 1 ] ;
80730: LD_ADDR_VAR 0 7
80734: PUSH
80735: LD_VAR 0 9
80739: PUSH
80740: LD_INT 1
80742: ARRAY
80743: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
80744: LD_VAR 0 7
80748: PPUSH
80749: LD_INT 124
80751: PPUSH
80752: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
80756: LD_ADDR_VAR 0 3
80760: PUSH
80761: DOUBLE
80762: LD_EXP 85
80766: PUSH
80767: LD_VAR 0 2
80771: ARRAY
80772: INC
80773: ST_TO_ADDR
80774: LD_EXP 85
80778: PUSH
80779: LD_VAR 0 2
80783: ARRAY
80784: PUSH
80785: FOR_DOWNTO
80786: IFFALSE 81129
// begin if IsInUnit ( tmp ) then
80788: LD_VAR 0 7
80792: PPUSH
80793: CALL_OW 310
80797: IFFALSE 80808
// ComExitBuilding ( tmp ) ;
80799: LD_VAR 0 7
80803: PPUSH
80804: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
80808: LD_INT 35
80810: PPUSH
80811: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
80815: LD_VAR 0 7
80819: PPUSH
80820: CALL_OW 310
80824: NOT
80825: PUSH
80826: LD_VAR 0 7
80830: PPUSH
80831: CALL_OW 314
80835: NOT
80836: AND
80837: IFFALSE 80808
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
80839: LD_ADDR_VAR 0 6
80843: PUSH
80844: LD_VAR 0 7
80848: PPUSH
80849: CALL_OW 250
80853: PUSH
80854: LD_VAR 0 7
80858: PPUSH
80859: CALL_OW 251
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
80868: LD_INT 35
80870: PPUSH
80871: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
80875: LD_ADDR_VAR 0 4
80879: PUSH
80880: LD_EXP 85
80884: PUSH
80885: LD_VAR 0 2
80889: ARRAY
80890: PUSH
80891: LD_VAR 0 3
80895: ARRAY
80896: PUSH
80897: LD_INT 1
80899: ARRAY
80900: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
80901: LD_ADDR_VAR 0 5
80905: PUSH
80906: LD_EXP 85
80910: PUSH
80911: LD_VAR 0 2
80915: ARRAY
80916: PUSH
80917: LD_VAR 0 3
80921: ARRAY
80922: PUSH
80923: LD_INT 2
80925: ARRAY
80926: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
80927: LD_VAR 0 7
80931: PPUSH
80932: LD_INT 10
80934: PPUSH
80935: CALL 27457 0 2
80939: PUSH
80940: LD_INT 4
80942: ARRAY
80943: IFFALSE 80981
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
80945: LD_VAR 0 7
80949: PPUSH
80950: LD_VAR 0 6
80954: PUSH
80955: LD_INT 1
80957: ARRAY
80958: PPUSH
80959: LD_VAR 0 6
80963: PUSH
80964: LD_INT 2
80966: ARRAY
80967: PPUSH
80968: CALL_OW 111
// wait ( 0 0$10 ) ;
80972: LD_INT 350
80974: PPUSH
80975: CALL_OW 67
// end else
80979: GO 81007
// begin ComMoveXY ( tmp , x , y ) ;
80981: LD_VAR 0 7
80985: PPUSH
80986: LD_VAR 0 4
80990: PPUSH
80991: LD_VAR 0 5
80995: PPUSH
80996: CALL_OW 111
// wait ( 0 0$3 ) ;
81000: LD_INT 105
81002: PPUSH
81003: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
81007: LD_VAR 0 7
81011: PPUSH
81012: LD_VAR 0 4
81016: PPUSH
81017: LD_VAR 0 5
81021: PPUSH
81022: CALL_OW 307
81026: IFFALSE 80868
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
81028: LD_VAR 0 7
81032: PPUSH
81033: LD_VAR 0 4
81037: PPUSH
81038: LD_VAR 0 5
81042: PPUSH
81043: LD_VAR 0 8
81047: PUSH
81048: LD_VAR 0 3
81052: ARRAY
81053: PPUSH
81054: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
81058: LD_INT 35
81060: PPUSH
81061: CALL_OW 67
// until not HasTask ( tmp ) ;
81065: LD_VAR 0 7
81069: PPUSH
81070: CALL_OW 314
81074: NOT
81075: IFFALSE 81058
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
81077: LD_ADDR_EXP 86
81081: PUSH
81082: LD_EXP 86
81086: PPUSH
81087: LD_VAR 0 2
81091: PUSH
81092: LD_EXP 86
81096: PUSH
81097: LD_VAR 0 2
81101: ARRAY
81102: PUSH
81103: LD_INT 1
81105: PLUS
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PPUSH
81111: LD_VAR 0 8
81115: PUSH
81116: LD_VAR 0 3
81120: ARRAY
81121: PPUSH
81122: CALL 24858 0 3
81126: ST_TO_ADDR
// end ;
81127: GO 80785
81129: POP
81130: POP
// MC_Reset ( i , 124 ) ;
81131: LD_VAR 0 2
81135: PPUSH
81136: LD_INT 124
81138: PPUSH
81139: CALL 64285 0 2
// end ; end ;
81143: GO 80540
81145: POP
81146: POP
// end ;
81147: LD_VAR 0 1
81151: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
81152: LD_INT 0
81154: PPUSH
81155: PPUSH
81156: PPUSH
// if not mc_bases then
81157: LD_EXP 50
81161: NOT
81162: IFFALSE 81166
// exit ;
81164: GO 81772
// for i = 1 to mc_bases do
81166: LD_ADDR_VAR 0 2
81170: PUSH
81171: DOUBLE
81172: LD_INT 1
81174: DEC
81175: ST_TO_ADDR
81176: LD_EXP 50
81180: PUSH
81181: FOR_TO
81182: IFFALSE 81770
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
81184: LD_ADDR_VAR 0 3
81188: PUSH
81189: LD_EXP 50
81193: PUSH
81194: LD_VAR 0 2
81198: ARRAY
81199: PPUSH
81200: LD_INT 25
81202: PUSH
81203: LD_INT 4
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PPUSH
81210: CALL_OW 72
81214: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81215: LD_VAR 0 3
81219: NOT
81220: PUSH
81221: LD_EXP 87
81225: PUSH
81226: LD_VAR 0 2
81230: ARRAY
81231: NOT
81232: OR
81233: PUSH
81234: LD_EXP 50
81238: PUSH
81239: LD_VAR 0 2
81243: ARRAY
81244: PPUSH
81245: LD_INT 2
81247: PUSH
81248: LD_INT 30
81250: PUSH
81251: LD_INT 0
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 30
81260: PUSH
81261: LD_INT 1
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: LIST
81272: PPUSH
81273: CALL_OW 72
81277: NOT
81278: OR
81279: IFFALSE 81329
// begin if mc_deposits_finder [ i ] then
81281: LD_EXP 88
81285: PUSH
81286: LD_VAR 0 2
81290: ARRAY
81291: IFFALSE 81327
// begin MC_Reset ( i , 125 ) ;
81293: LD_VAR 0 2
81297: PPUSH
81298: LD_INT 125
81300: PPUSH
81301: CALL 64285 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
81305: LD_ADDR_EXP 88
81309: PUSH
81310: LD_EXP 88
81314: PPUSH
81315: LD_VAR 0 2
81319: PPUSH
81320: EMPTY
81321: PPUSH
81322: CALL_OW 1
81326: ST_TO_ADDR
// end ; continue ;
81327: GO 81181
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
81329: LD_EXP 87
81333: PUSH
81334: LD_VAR 0 2
81338: ARRAY
81339: PUSH
81340: LD_INT 1
81342: ARRAY
81343: PUSH
81344: LD_INT 3
81346: ARRAY
81347: PUSH
81348: LD_INT 1
81350: EQUAL
81351: PUSH
81352: LD_INT 20
81354: PPUSH
81355: LD_EXP 76
81359: PUSH
81360: LD_VAR 0 2
81364: ARRAY
81365: PPUSH
81366: CALL_OW 321
81370: PUSH
81371: LD_INT 2
81373: NONEQUAL
81374: AND
81375: IFFALSE 81425
// begin if mc_deposits_finder [ i ] then
81377: LD_EXP 88
81381: PUSH
81382: LD_VAR 0 2
81386: ARRAY
81387: IFFALSE 81423
// begin MC_Reset ( i , 125 ) ;
81389: LD_VAR 0 2
81393: PPUSH
81394: LD_INT 125
81396: PPUSH
81397: CALL 64285 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
81401: LD_ADDR_EXP 88
81405: PUSH
81406: LD_EXP 88
81410: PPUSH
81411: LD_VAR 0 2
81415: PPUSH
81416: EMPTY
81417: PPUSH
81418: CALL_OW 1
81422: ST_TO_ADDR
// end ; continue ;
81423: GO 81181
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
81425: LD_EXP 87
81429: PUSH
81430: LD_VAR 0 2
81434: ARRAY
81435: PUSH
81436: LD_INT 1
81438: ARRAY
81439: PUSH
81440: LD_INT 1
81442: ARRAY
81443: PPUSH
81444: LD_EXP 87
81448: PUSH
81449: LD_VAR 0 2
81453: ARRAY
81454: PUSH
81455: LD_INT 1
81457: ARRAY
81458: PUSH
81459: LD_INT 2
81461: ARRAY
81462: PPUSH
81463: LD_EXP 76
81467: PUSH
81468: LD_VAR 0 2
81472: ARRAY
81473: PPUSH
81474: CALL_OW 440
81478: IFFALSE 81521
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
81480: LD_ADDR_EXP 87
81484: PUSH
81485: LD_EXP 87
81489: PPUSH
81490: LD_VAR 0 2
81494: PPUSH
81495: LD_EXP 87
81499: PUSH
81500: LD_VAR 0 2
81504: ARRAY
81505: PPUSH
81506: LD_INT 1
81508: PPUSH
81509: CALL_OW 3
81513: PPUSH
81514: CALL_OW 1
81518: ST_TO_ADDR
81519: GO 81768
// begin if not mc_deposits_finder [ i ] then
81521: LD_EXP 88
81525: PUSH
81526: LD_VAR 0 2
81530: ARRAY
81531: NOT
81532: IFFALSE 81584
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
81534: LD_ADDR_EXP 88
81538: PUSH
81539: LD_EXP 88
81543: PPUSH
81544: LD_VAR 0 2
81548: PPUSH
81549: LD_VAR 0 3
81553: PUSH
81554: LD_INT 1
81556: ARRAY
81557: PUSH
81558: EMPTY
81559: LIST
81560: PPUSH
81561: CALL_OW 1
81565: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
81566: LD_VAR 0 3
81570: PUSH
81571: LD_INT 1
81573: ARRAY
81574: PPUSH
81575: LD_INT 125
81577: PPUSH
81578: CALL_OW 109
// end else
81582: GO 81768
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
81584: LD_EXP 88
81588: PUSH
81589: LD_VAR 0 2
81593: ARRAY
81594: PUSH
81595: LD_INT 1
81597: ARRAY
81598: PPUSH
81599: CALL_OW 310
81603: IFFALSE 81626
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
81605: LD_EXP 88
81609: PUSH
81610: LD_VAR 0 2
81614: ARRAY
81615: PUSH
81616: LD_INT 1
81618: ARRAY
81619: PPUSH
81620: CALL_OW 122
81624: GO 81768
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
81626: LD_EXP 88
81630: PUSH
81631: LD_VAR 0 2
81635: ARRAY
81636: PUSH
81637: LD_INT 1
81639: ARRAY
81640: PPUSH
81641: CALL_OW 314
81645: NOT
81646: PUSH
81647: LD_EXP 88
81651: PUSH
81652: LD_VAR 0 2
81656: ARRAY
81657: PUSH
81658: LD_INT 1
81660: ARRAY
81661: PPUSH
81662: LD_EXP 87
81666: PUSH
81667: LD_VAR 0 2
81671: ARRAY
81672: PUSH
81673: LD_INT 1
81675: ARRAY
81676: PUSH
81677: LD_INT 1
81679: ARRAY
81680: PPUSH
81681: LD_EXP 87
81685: PUSH
81686: LD_VAR 0 2
81690: ARRAY
81691: PUSH
81692: LD_INT 1
81694: ARRAY
81695: PUSH
81696: LD_INT 2
81698: ARRAY
81699: PPUSH
81700: CALL_OW 297
81704: PUSH
81705: LD_INT 6
81707: GREATER
81708: AND
81709: IFFALSE 81768
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
81711: LD_EXP 88
81715: PUSH
81716: LD_VAR 0 2
81720: ARRAY
81721: PUSH
81722: LD_INT 1
81724: ARRAY
81725: PPUSH
81726: LD_EXP 87
81730: PUSH
81731: LD_VAR 0 2
81735: ARRAY
81736: PUSH
81737: LD_INT 1
81739: ARRAY
81740: PUSH
81741: LD_INT 1
81743: ARRAY
81744: PPUSH
81745: LD_EXP 87
81749: PUSH
81750: LD_VAR 0 2
81754: ARRAY
81755: PUSH
81756: LD_INT 1
81758: ARRAY
81759: PUSH
81760: LD_INT 2
81762: ARRAY
81763: PPUSH
81764: CALL_OW 111
// end ; end ; end ;
81768: GO 81181
81770: POP
81771: POP
// end ;
81772: LD_VAR 0 1
81776: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
81777: LD_INT 0
81779: PPUSH
81780: PPUSH
81781: PPUSH
81782: PPUSH
81783: PPUSH
81784: PPUSH
81785: PPUSH
81786: PPUSH
81787: PPUSH
81788: PPUSH
81789: PPUSH
// if not mc_bases then
81790: LD_EXP 50
81794: NOT
81795: IFFALSE 81799
// exit ;
81797: GO 82739
// for i = 1 to mc_bases do
81799: LD_ADDR_VAR 0 2
81803: PUSH
81804: DOUBLE
81805: LD_INT 1
81807: DEC
81808: ST_TO_ADDR
81809: LD_EXP 50
81813: PUSH
81814: FOR_TO
81815: IFFALSE 82737
// begin if not mc_bases [ i ] or mc_scan [ i ] then
81817: LD_EXP 50
81821: PUSH
81822: LD_VAR 0 2
81826: ARRAY
81827: NOT
81828: PUSH
81829: LD_EXP 73
81833: PUSH
81834: LD_VAR 0 2
81838: ARRAY
81839: OR
81840: IFFALSE 81844
// continue ;
81842: GO 81814
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
81844: LD_ADDR_VAR 0 7
81848: PUSH
81849: LD_EXP 50
81853: PUSH
81854: LD_VAR 0 2
81858: ARRAY
81859: PUSH
81860: LD_INT 1
81862: ARRAY
81863: PPUSH
81864: CALL_OW 248
81868: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
81869: LD_VAR 0 7
81873: PUSH
81874: LD_INT 3
81876: EQUAL
81877: PUSH
81878: LD_EXP 69
81882: PUSH
81883: LD_VAR 0 2
81887: ARRAY
81888: PUSH
81889: LD_EXP 72
81893: PUSH
81894: LD_VAR 0 2
81898: ARRAY
81899: UNION
81900: PPUSH
81901: LD_INT 33
81903: PUSH
81904: LD_INT 2
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PPUSH
81911: CALL_OW 72
81915: NOT
81916: OR
81917: IFFALSE 81921
// continue ;
81919: GO 81814
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
81921: LD_ADDR_VAR 0 9
81925: PUSH
81926: LD_EXP 50
81930: PUSH
81931: LD_VAR 0 2
81935: ARRAY
81936: PPUSH
81937: LD_INT 30
81939: PUSH
81940: LD_INT 36
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PPUSH
81947: CALL_OW 72
81951: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
81952: LD_ADDR_VAR 0 10
81956: PUSH
81957: LD_EXP 69
81961: PUSH
81962: LD_VAR 0 2
81966: ARRAY
81967: PPUSH
81968: LD_INT 34
81970: PUSH
81971: LD_INT 31
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PPUSH
81978: CALL_OW 72
81982: ST_TO_ADDR
// if not cts and not mcts then
81983: LD_VAR 0 9
81987: NOT
81988: PUSH
81989: LD_VAR 0 10
81993: NOT
81994: AND
81995: IFFALSE 81999
// continue ;
81997: GO 81814
// x := cts ;
81999: LD_ADDR_VAR 0 11
82003: PUSH
82004: LD_VAR 0 9
82008: ST_TO_ADDR
// if not x then
82009: LD_VAR 0 11
82013: NOT
82014: IFFALSE 82026
// x := mcts ;
82016: LD_ADDR_VAR 0 11
82020: PUSH
82021: LD_VAR 0 10
82025: ST_TO_ADDR
// if not x then
82026: LD_VAR 0 11
82030: NOT
82031: IFFALSE 82035
// continue ;
82033: GO 81814
// if mc_remote_driver [ i ] then
82035: LD_EXP 90
82039: PUSH
82040: LD_VAR 0 2
82044: ARRAY
82045: IFFALSE 82432
// for j in mc_remote_driver [ i ] do
82047: LD_ADDR_VAR 0 3
82051: PUSH
82052: LD_EXP 90
82056: PUSH
82057: LD_VAR 0 2
82061: ARRAY
82062: PUSH
82063: FOR_IN
82064: IFFALSE 82430
// begin if GetClass ( j ) <> 3 then
82066: LD_VAR 0 3
82070: PPUSH
82071: CALL_OW 257
82075: PUSH
82076: LD_INT 3
82078: NONEQUAL
82079: IFFALSE 82132
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
82081: LD_ADDR_EXP 90
82085: PUSH
82086: LD_EXP 90
82090: PPUSH
82091: LD_VAR 0 2
82095: PPUSH
82096: LD_EXP 90
82100: PUSH
82101: LD_VAR 0 2
82105: ARRAY
82106: PUSH
82107: LD_VAR 0 3
82111: DIFF
82112: PPUSH
82113: CALL_OW 1
82117: ST_TO_ADDR
// SetTag ( j , 0 ) ;
82118: LD_VAR 0 3
82122: PPUSH
82123: LD_INT 0
82125: PPUSH
82126: CALL_OW 109
// continue ;
82130: GO 82063
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
82132: LD_EXP 69
82136: PUSH
82137: LD_VAR 0 2
82141: ARRAY
82142: PPUSH
82143: LD_INT 34
82145: PUSH
82146: LD_INT 31
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 58
82155: PUSH
82156: EMPTY
82157: LIST
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PPUSH
82163: CALL_OW 72
82167: PUSH
82168: LD_VAR 0 3
82172: PPUSH
82173: CALL 54215 0 1
82177: NOT
82178: AND
82179: IFFALSE 82250
// begin if IsInUnit ( j ) then
82181: LD_VAR 0 3
82185: PPUSH
82186: CALL_OW 310
82190: IFFALSE 82201
// ComExitBuilding ( j ) ;
82192: LD_VAR 0 3
82196: PPUSH
82197: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
82201: LD_VAR 0 3
82205: PPUSH
82206: LD_EXP 69
82210: PUSH
82211: LD_VAR 0 2
82215: ARRAY
82216: PPUSH
82217: LD_INT 34
82219: PUSH
82220: LD_INT 31
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 58
82229: PUSH
82230: EMPTY
82231: LIST
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PPUSH
82237: CALL_OW 72
82241: PUSH
82242: LD_INT 1
82244: ARRAY
82245: PPUSH
82246: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
82250: LD_VAR 0 3
82254: PPUSH
82255: CALL_OW 310
82259: NOT
82260: PUSH
82261: LD_VAR 0 3
82265: PPUSH
82266: CALL_OW 310
82270: PPUSH
82271: CALL_OW 266
82275: PUSH
82276: LD_INT 36
82278: NONEQUAL
82279: PUSH
82280: LD_VAR 0 3
82284: PPUSH
82285: CALL 54215 0 1
82289: NOT
82290: AND
82291: OR
82292: IFFALSE 82428
// begin if IsInUnit ( j ) then
82294: LD_VAR 0 3
82298: PPUSH
82299: CALL_OW 310
82303: IFFALSE 82314
// ComExitBuilding ( j ) ;
82305: LD_VAR 0 3
82309: PPUSH
82310: CALL_OW 122
// ct := 0 ;
82314: LD_ADDR_VAR 0 8
82318: PUSH
82319: LD_INT 0
82321: ST_TO_ADDR
// for k in x do
82322: LD_ADDR_VAR 0 4
82326: PUSH
82327: LD_VAR 0 11
82331: PUSH
82332: FOR_IN
82333: IFFALSE 82406
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
82335: LD_VAR 0 4
82339: PPUSH
82340: CALL_OW 264
82344: PUSH
82345: LD_INT 31
82347: EQUAL
82348: PUSH
82349: LD_VAR 0 4
82353: PPUSH
82354: CALL_OW 311
82358: NOT
82359: AND
82360: PUSH
82361: LD_VAR 0 4
82365: PPUSH
82366: CALL_OW 266
82370: PUSH
82371: LD_INT 36
82373: EQUAL
82374: PUSH
82375: LD_VAR 0 4
82379: PPUSH
82380: CALL_OW 313
82384: PUSH
82385: LD_INT 3
82387: LESS
82388: AND
82389: OR
82390: IFFALSE 82404
// begin ct := k ;
82392: LD_ADDR_VAR 0 8
82396: PUSH
82397: LD_VAR 0 4
82401: ST_TO_ADDR
// break ;
82402: GO 82406
// end ;
82404: GO 82332
82406: POP
82407: POP
// if ct then
82408: LD_VAR 0 8
82412: IFFALSE 82428
// ComEnterUnit ( j , ct ) ;
82414: LD_VAR 0 3
82418: PPUSH
82419: LD_VAR 0 8
82423: PPUSH
82424: CALL_OW 120
// end ; end ;
82428: GO 82063
82430: POP
82431: POP
// places := 0 ;
82432: LD_ADDR_VAR 0 5
82436: PUSH
82437: LD_INT 0
82439: ST_TO_ADDR
// for j = 1 to x do
82440: LD_ADDR_VAR 0 3
82444: PUSH
82445: DOUBLE
82446: LD_INT 1
82448: DEC
82449: ST_TO_ADDR
82450: LD_VAR 0 11
82454: PUSH
82455: FOR_TO
82456: IFFALSE 82532
// if GetWeapon ( x [ j ] ) = ar_control_tower then
82458: LD_VAR 0 11
82462: PUSH
82463: LD_VAR 0 3
82467: ARRAY
82468: PPUSH
82469: CALL_OW 264
82473: PUSH
82474: LD_INT 31
82476: EQUAL
82477: IFFALSE 82495
// places := places + 1 else
82479: LD_ADDR_VAR 0 5
82483: PUSH
82484: LD_VAR 0 5
82488: PUSH
82489: LD_INT 1
82491: PLUS
82492: ST_TO_ADDR
82493: GO 82530
// if GetBType ( x [ j ] ) = b_control_tower then
82495: LD_VAR 0 11
82499: PUSH
82500: LD_VAR 0 3
82504: ARRAY
82505: PPUSH
82506: CALL_OW 266
82510: PUSH
82511: LD_INT 36
82513: EQUAL
82514: IFFALSE 82530
// places := places + 3 ;
82516: LD_ADDR_VAR 0 5
82520: PUSH
82521: LD_VAR 0 5
82525: PUSH
82526: LD_INT 3
82528: PLUS
82529: ST_TO_ADDR
82530: GO 82455
82532: POP
82533: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
82534: LD_VAR 0 5
82538: PUSH
82539: LD_INT 0
82541: EQUAL
82542: PUSH
82543: LD_VAR 0 5
82547: PUSH
82548: LD_EXP 90
82552: PUSH
82553: LD_VAR 0 2
82557: ARRAY
82558: LESSEQUAL
82559: OR
82560: IFFALSE 82564
// continue ;
82562: GO 81814
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
82564: LD_ADDR_VAR 0 6
82568: PUSH
82569: LD_EXP 50
82573: PUSH
82574: LD_VAR 0 2
82578: ARRAY
82579: PPUSH
82580: LD_INT 25
82582: PUSH
82583: LD_INT 3
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PPUSH
82590: CALL_OW 72
82594: PUSH
82595: LD_EXP 90
82599: PUSH
82600: LD_VAR 0 2
82604: ARRAY
82605: DIFF
82606: PPUSH
82607: LD_INT 3
82609: PPUSH
82610: CALL 55115 0 2
82614: ST_TO_ADDR
// for j in tmp do
82615: LD_ADDR_VAR 0 3
82619: PUSH
82620: LD_VAR 0 6
82624: PUSH
82625: FOR_IN
82626: IFFALSE 82661
// if GetTag ( j ) > 0 then
82628: LD_VAR 0 3
82632: PPUSH
82633: CALL_OW 110
82637: PUSH
82638: LD_INT 0
82640: GREATER
82641: IFFALSE 82659
// tmp := tmp diff j ;
82643: LD_ADDR_VAR 0 6
82647: PUSH
82648: LD_VAR 0 6
82652: PUSH
82653: LD_VAR 0 3
82657: DIFF
82658: ST_TO_ADDR
82659: GO 82625
82661: POP
82662: POP
// if not tmp then
82663: LD_VAR 0 6
82667: NOT
82668: IFFALSE 82672
// continue ;
82670: GO 81814
// if places then
82672: LD_VAR 0 5
82676: IFFALSE 82735
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
82678: LD_ADDR_EXP 90
82682: PUSH
82683: LD_EXP 90
82687: PPUSH
82688: LD_VAR 0 2
82692: PPUSH
82693: LD_EXP 90
82697: PUSH
82698: LD_VAR 0 2
82702: ARRAY
82703: PUSH
82704: LD_VAR 0 6
82708: PUSH
82709: LD_INT 1
82711: ARRAY
82712: UNION
82713: PPUSH
82714: CALL_OW 1
82718: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
82719: LD_VAR 0 6
82723: PUSH
82724: LD_INT 1
82726: ARRAY
82727: PPUSH
82728: LD_INT 126
82730: PPUSH
82731: CALL_OW 109
// end ; end ;
82735: GO 81814
82737: POP
82738: POP
// end ;
82739: LD_VAR 0 1
82743: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
82744: LD_INT 0
82746: PPUSH
82747: PPUSH
82748: PPUSH
82749: PPUSH
82750: PPUSH
82751: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
82752: LD_VAR 0 1
82756: NOT
82757: PUSH
82758: LD_VAR 0 2
82762: NOT
82763: OR
82764: PUSH
82765: LD_VAR 0 3
82769: NOT
82770: OR
82771: PUSH
82772: LD_VAR 0 4
82776: PUSH
82777: LD_INT 1
82779: PUSH
82780: LD_INT 2
82782: PUSH
82783: LD_INT 3
82785: PUSH
82786: LD_INT 4
82788: PUSH
82789: LD_INT 5
82791: PUSH
82792: LD_INT 8
82794: PUSH
82795: LD_INT 9
82797: PUSH
82798: LD_INT 15
82800: PUSH
82801: LD_INT 16
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: IN
82815: NOT
82816: OR
82817: IFFALSE 82821
// exit ;
82819: GO 83721
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
82821: LD_ADDR_VAR 0 2
82825: PUSH
82826: LD_VAR 0 2
82830: PPUSH
82831: LD_INT 21
82833: PUSH
82834: LD_INT 3
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: PUSH
82841: LD_INT 24
82843: PUSH
82844: LD_INT 250
82846: PUSH
82847: EMPTY
82848: LIST
82849: LIST
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PPUSH
82855: CALL_OW 72
82859: ST_TO_ADDR
// case class of 1 , 15 :
82860: LD_VAR 0 4
82864: PUSH
82865: LD_INT 1
82867: DOUBLE
82868: EQUAL
82869: IFTRUE 82879
82871: LD_INT 15
82873: DOUBLE
82874: EQUAL
82875: IFTRUE 82879
82877: GO 82964
82879: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
82880: LD_ADDR_VAR 0 8
82884: PUSH
82885: LD_VAR 0 2
82889: PPUSH
82890: LD_INT 2
82892: PUSH
82893: LD_INT 30
82895: PUSH
82896: LD_INT 32
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 30
82905: PUSH
82906: LD_INT 31
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: LIST
82917: PPUSH
82918: CALL_OW 72
82922: PUSH
82923: LD_VAR 0 2
82927: PPUSH
82928: LD_INT 2
82930: PUSH
82931: LD_INT 30
82933: PUSH
82934: LD_INT 4
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: PUSH
82941: LD_INT 30
82943: PUSH
82944: LD_INT 5
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: LIST
82955: PPUSH
82956: CALL_OW 72
82960: ADD
82961: ST_TO_ADDR
82962: GO 83210
82964: LD_INT 2
82966: DOUBLE
82967: EQUAL
82968: IFTRUE 82978
82970: LD_INT 16
82972: DOUBLE
82973: EQUAL
82974: IFTRUE 82978
82976: GO 83024
82978: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
82979: LD_ADDR_VAR 0 8
82983: PUSH
82984: LD_VAR 0 2
82988: PPUSH
82989: LD_INT 2
82991: PUSH
82992: LD_INT 30
82994: PUSH
82995: LD_INT 0
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: PUSH
83002: LD_INT 30
83004: PUSH
83005: LD_INT 1
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: LIST
83016: PPUSH
83017: CALL_OW 72
83021: ST_TO_ADDR
83022: GO 83210
83024: LD_INT 3
83026: DOUBLE
83027: EQUAL
83028: IFTRUE 83032
83030: GO 83078
83032: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
83033: LD_ADDR_VAR 0 8
83037: PUSH
83038: LD_VAR 0 2
83042: PPUSH
83043: LD_INT 2
83045: PUSH
83046: LD_INT 30
83048: PUSH
83049: LD_INT 2
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 30
83058: PUSH
83059: LD_INT 3
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: LIST
83070: PPUSH
83071: CALL_OW 72
83075: ST_TO_ADDR
83076: GO 83210
83078: LD_INT 4
83080: DOUBLE
83081: EQUAL
83082: IFTRUE 83086
83084: GO 83143
83086: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
83087: LD_ADDR_VAR 0 8
83091: PUSH
83092: LD_VAR 0 2
83096: PPUSH
83097: LD_INT 2
83099: PUSH
83100: LD_INT 30
83102: PUSH
83103: LD_INT 6
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 30
83112: PUSH
83113: LD_INT 7
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: PUSH
83120: LD_INT 30
83122: PUSH
83123: LD_INT 8
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: EMPTY
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: PPUSH
83136: CALL_OW 72
83140: ST_TO_ADDR
83141: GO 83210
83143: LD_INT 5
83145: DOUBLE
83146: EQUAL
83147: IFTRUE 83163
83149: LD_INT 8
83151: DOUBLE
83152: EQUAL
83153: IFTRUE 83163
83155: LD_INT 9
83157: DOUBLE
83158: EQUAL
83159: IFTRUE 83163
83161: GO 83209
83163: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
83164: LD_ADDR_VAR 0 8
83168: PUSH
83169: LD_VAR 0 2
83173: PPUSH
83174: LD_INT 2
83176: PUSH
83177: LD_INT 30
83179: PUSH
83180: LD_INT 4
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 30
83189: PUSH
83190: LD_INT 5
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: LIST
83201: PPUSH
83202: CALL_OW 72
83206: ST_TO_ADDR
83207: GO 83210
83209: POP
// if not tmp then
83210: LD_VAR 0 8
83214: NOT
83215: IFFALSE 83219
// exit ;
83217: GO 83721
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
83219: LD_VAR 0 4
83223: PUSH
83224: LD_INT 1
83226: PUSH
83227: LD_INT 15
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: IN
83234: PUSH
83235: LD_EXP 59
83239: PUSH
83240: LD_VAR 0 1
83244: ARRAY
83245: AND
83246: IFFALSE 83402
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
83248: LD_ADDR_VAR 0 9
83252: PUSH
83253: LD_EXP 59
83257: PUSH
83258: LD_VAR 0 1
83262: ARRAY
83263: PUSH
83264: LD_INT 1
83266: ARRAY
83267: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
83268: LD_VAR 0 9
83272: PUSH
83273: LD_EXP 60
83277: PUSH
83278: LD_VAR 0 1
83282: ARRAY
83283: IN
83284: NOT
83285: IFFALSE 83400
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
83287: LD_ADDR_EXP 60
83291: PUSH
83292: LD_EXP 60
83296: PPUSH
83297: LD_VAR 0 1
83301: PUSH
83302: LD_EXP 60
83306: PUSH
83307: LD_VAR 0 1
83311: ARRAY
83312: PUSH
83313: LD_INT 1
83315: PLUS
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: PPUSH
83321: LD_VAR 0 9
83325: PPUSH
83326: CALL 24858 0 3
83330: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
83331: LD_ADDR_EXP 59
83335: PUSH
83336: LD_EXP 59
83340: PPUSH
83341: LD_VAR 0 1
83345: PPUSH
83346: LD_EXP 59
83350: PUSH
83351: LD_VAR 0 1
83355: ARRAY
83356: PUSH
83357: LD_VAR 0 9
83361: DIFF
83362: PPUSH
83363: CALL_OW 1
83367: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
83368: LD_VAR 0 3
83372: PPUSH
83373: LD_EXP 60
83377: PUSH
83378: LD_VAR 0 1
83382: ARRAY
83383: PUSH
83384: LD_EXP 60
83388: PUSH
83389: LD_VAR 0 1
83393: ARRAY
83394: ARRAY
83395: PPUSH
83396: CALL_OW 120
// end ; exit ;
83400: GO 83721
// end ; if tmp > 1 then
83402: LD_VAR 0 8
83406: PUSH
83407: LD_INT 1
83409: GREATER
83410: IFFALSE 83514
// for i = 2 to tmp do
83412: LD_ADDR_VAR 0 6
83416: PUSH
83417: DOUBLE
83418: LD_INT 2
83420: DEC
83421: ST_TO_ADDR
83422: LD_VAR 0 8
83426: PUSH
83427: FOR_TO
83428: IFFALSE 83512
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
83430: LD_VAR 0 8
83434: PUSH
83435: LD_VAR 0 6
83439: ARRAY
83440: PPUSH
83441: CALL_OW 461
83445: PUSH
83446: LD_INT 6
83448: EQUAL
83449: IFFALSE 83510
// begin x := tmp [ i ] ;
83451: LD_ADDR_VAR 0 9
83455: PUSH
83456: LD_VAR 0 8
83460: PUSH
83461: LD_VAR 0 6
83465: ARRAY
83466: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
83467: LD_ADDR_VAR 0 8
83471: PUSH
83472: LD_VAR 0 8
83476: PPUSH
83477: LD_VAR 0 6
83481: PPUSH
83482: CALL_OW 3
83486: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
83487: LD_ADDR_VAR 0 8
83491: PUSH
83492: LD_VAR 0 8
83496: PPUSH
83497: LD_INT 1
83499: PPUSH
83500: LD_VAR 0 9
83504: PPUSH
83505: CALL_OW 2
83509: ST_TO_ADDR
// end ;
83510: GO 83427
83512: POP
83513: POP
// for i in tmp do
83514: LD_ADDR_VAR 0 6
83518: PUSH
83519: LD_VAR 0 8
83523: PUSH
83524: FOR_IN
83525: IFFALSE 83594
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
83527: LD_VAR 0 6
83531: PPUSH
83532: CALL_OW 313
83536: PUSH
83537: LD_INT 6
83539: LESS
83540: PUSH
83541: LD_VAR 0 6
83545: PPUSH
83546: CALL_OW 266
83550: PUSH
83551: LD_INT 31
83553: PUSH
83554: LD_INT 32
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: IN
83561: NOT
83562: AND
83563: PUSH
83564: LD_VAR 0 6
83568: PPUSH
83569: CALL_OW 313
83573: PUSH
83574: LD_INT 0
83576: EQUAL
83577: OR
83578: IFFALSE 83592
// begin j := i ;
83580: LD_ADDR_VAR 0 7
83584: PUSH
83585: LD_VAR 0 6
83589: ST_TO_ADDR
// break ;
83590: GO 83594
// end ; end ;
83592: GO 83524
83594: POP
83595: POP
// if j then
83596: LD_VAR 0 7
83600: IFFALSE 83618
// ComEnterUnit ( unit , j ) else
83602: LD_VAR 0 3
83606: PPUSH
83607: LD_VAR 0 7
83611: PPUSH
83612: CALL_OW 120
83616: GO 83721
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83618: LD_ADDR_VAR 0 10
83622: PUSH
83623: LD_VAR 0 2
83627: PPUSH
83628: LD_INT 2
83630: PUSH
83631: LD_INT 30
83633: PUSH
83634: LD_INT 0
83636: PUSH
83637: EMPTY
83638: LIST
83639: LIST
83640: PUSH
83641: LD_INT 30
83643: PUSH
83644: LD_INT 1
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: LIST
83655: PPUSH
83656: CALL_OW 72
83660: ST_TO_ADDR
// if depot then
83661: LD_VAR 0 10
83665: IFFALSE 83721
// begin depot := NearestUnitToUnit ( depot , unit ) ;
83667: LD_ADDR_VAR 0 10
83671: PUSH
83672: LD_VAR 0 10
83676: PPUSH
83677: LD_VAR 0 3
83681: PPUSH
83682: CALL_OW 74
83686: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
83687: LD_VAR 0 3
83691: PPUSH
83692: LD_VAR 0 10
83696: PPUSH
83697: CALL_OW 296
83701: PUSH
83702: LD_INT 10
83704: GREATER
83705: IFFALSE 83721
// ComStandNearbyBuilding ( unit , depot ) ;
83707: LD_VAR 0 3
83711: PPUSH
83712: LD_VAR 0 10
83716: PPUSH
83717: CALL 21436 0 2
// end ; end ; end ;
83721: LD_VAR 0 5
83725: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
83726: LD_INT 0
83728: PPUSH
83729: PPUSH
83730: PPUSH
83731: PPUSH
// if not mc_bases then
83732: LD_EXP 50
83736: NOT
83737: IFFALSE 83741
// exit ;
83739: GO 83980
// for i = 1 to mc_bases do
83741: LD_ADDR_VAR 0 2
83745: PUSH
83746: DOUBLE
83747: LD_INT 1
83749: DEC
83750: ST_TO_ADDR
83751: LD_EXP 50
83755: PUSH
83756: FOR_TO
83757: IFFALSE 83978
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
83759: LD_ADDR_VAR 0 4
83763: PUSH
83764: LD_EXP 50
83768: PUSH
83769: LD_VAR 0 2
83773: ARRAY
83774: PPUSH
83775: LD_INT 21
83777: PUSH
83778: LD_INT 1
83780: PUSH
83781: EMPTY
83782: LIST
83783: LIST
83784: PPUSH
83785: CALL_OW 72
83789: PUSH
83790: LD_EXP 79
83794: PUSH
83795: LD_VAR 0 2
83799: ARRAY
83800: UNION
83801: ST_TO_ADDR
// if not tmp then
83802: LD_VAR 0 4
83806: NOT
83807: IFFALSE 83811
// continue ;
83809: GO 83756
// for j in tmp do
83811: LD_ADDR_VAR 0 3
83815: PUSH
83816: LD_VAR 0 4
83820: PUSH
83821: FOR_IN
83822: IFFALSE 83974
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
83824: LD_VAR 0 3
83828: PPUSH
83829: CALL_OW 110
83833: NOT
83834: PUSH
83835: LD_VAR 0 3
83839: PPUSH
83840: CALL_OW 314
83844: NOT
83845: AND
83846: PUSH
83847: LD_VAR 0 3
83851: PPUSH
83852: CALL_OW 311
83856: NOT
83857: AND
83858: PUSH
83859: LD_VAR 0 3
83863: PPUSH
83864: CALL_OW 310
83868: NOT
83869: AND
83870: PUSH
83871: LD_VAR 0 3
83875: PUSH
83876: LD_EXP 53
83880: PUSH
83881: LD_VAR 0 2
83885: ARRAY
83886: PUSH
83887: LD_INT 1
83889: ARRAY
83890: IN
83891: NOT
83892: AND
83893: PUSH
83894: LD_VAR 0 3
83898: PUSH
83899: LD_EXP 53
83903: PUSH
83904: LD_VAR 0 2
83908: ARRAY
83909: PUSH
83910: LD_INT 2
83912: ARRAY
83913: IN
83914: NOT
83915: AND
83916: PUSH
83917: LD_VAR 0 3
83921: PUSH
83922: LD_EXP 62
83926: PUSH
83927: LD_VAR 0 2
83931: ARRAY
83932: IN
83933: NOT
83934: AND
83935: IFFALSE 83972
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
83937: LD_VAR 0 2
83941: PPUSH
83942: LD_EXP 50
83946: PUSH
83947: LD_VAR 0 2
83951: ARRAY
83952: PPUSH
83953: LD_VAR 0 3
83957: PPUSH
83958: LD_VAR 0 3
83962: PPUSH
83963: CALL_OW 257
83967: PPUSH
83968: CALL 82744 0 4
// end ;
83972: GO 83821
83974: POP
83975: POP
// end ;
83976: GO 83756
83978: POP
83979: POP
// end ;
83980: LD_VAR 0 1
83984: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
83985: LD_INT 0
83987: PPUSH
83988: PPUSH
83989: PPUSH
83990: PPUSH
83991: PPUSH
83992: PPUSH
// if not mc_bases [ base ] then
83993: LD_EXP 50
83997: PUSH
83998: LD_VAR 0 1
84002: ARRAY
84003: NOT
84004: IFFALSE 84008
// exit ;
84006: GO 84190
// tmp := [ ] ;
84008: LD_ADDR_VAR 0 6
84012: PUSH
84013: EMPTY
84014: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
84015: LD_ADDR_VAR 0 7
84019: PUSH
84020: LD_VAR 0 3
84024: PPUSH
84025: LD_INT 0
84027: PPUSH
84028: CALL_OW 517
84032: ST_TO_ADDR
// if not list then
84033: LD_VAR 0 7
84037: NOT
84038: IFFALSE 84042
// exit ;
84040: GO 84190
// for i = 1 to amount do
84042: LD_ADDR_VAR 0 5
84046: PUSH
84047: DOUBLE
84048: LD_INT 1
84050: DEC
84051: ST_TO_ADDR
84052: LD_VAR 0 2
84056: PUSH
84057: FOR_TO
84058: IFFALSE 84138
// begin x := rand ( 1 , list [ 1 ] ) ;
84060: LD_ADDR_VAR 0 8
84064: PUSH
84065: LD_INT 1
84067: PPUSH
84068: LD_VAR 0 7
84072: PUSH
84073: LD_INT 1
84075: ARRAY
84076: PPUSH
84077: CALL_OW 12
84081: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
84082: LD_ADDR_VAR 0 6
84086: PUSH
84087: LD_VAR 0 6
84091: PPUSH
84092: LD_VAR 0 5
84096: PPUSH
84097: LD_VAR 0 7
84101: PUSH
84102: LD_INT 1
84104: ARRAY
84105: PUSH
84106: LD_VAR 0 8
84110: ARRAY
84111: PUSH
84112: LD_VAR 0 7
84116: PUSH
84117: LD_INT 2
84119: ARRAY
84120: PUSH
84121: LD_VAR 0 8
84125: ARRAY
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PPUSH
84131: CALL_OW 1
84135: ST_TO_ADDR
// end ;
84136: GO 84057
84138: POP
84139: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
84140: LD_ADDR_EXP 63
84144: PUSH
84145: LD_EXP 63
84149: PPUSH
84150: LD_VAR 0 1
84154: PPUSH
84155: LD_VAR 0 6
84159: PPUSH
84160: CALL_OW 1
84164: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
84165: LD_ADDR_EXP 65
84169: PUSH
84170: LD_EXP 65
84174: PPUSH
84175: LD_VAR 0 1
84179: PPUSH
84180: LD_VAR 0 3
84184: PPUSH
84185: CALL_OW 1
84189: ST_TO_ADDR
// end ;
84190: LD_VAR 0 4
84194: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
84195: LD_INT 0
84197: PPUSH
// if not mc_bases [ base ] then
84198: LD_EXP 50
84202: PUSH
84203: LD_VAR 0 1
84207: ARRAY
84208: NOT
84209: IFFALSE 84213
// exit ;
84211: GO 84238
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
84213: LD_ADDR_EXP 55
84217: PUSH
84218: LD_EXP 55
84222: PPUSH
84223: LD_VAR 0 1
84227: PPUSH
84228: LD_VAR 0 2
84232: PPUSH
84233: CALL_OW 1
84237: ST_TO_ADDR
// end ;
84238: LD_VAR 0 3
84242: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
84243: LD_INT 0
84245: PPUSH
// if not mc_bases [ base ] then
84246: LD_EXP 50
84250: PUSH
84251: LD_VAR 0 1
84255: ARRAY
84256: NOT
84257: IFFALSE 84261
// exit ;
84259: GO 84298
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
84261: LD_ADDR_EXP 55
84265: PUSH
84266: LD_EXP 55
84270: PPUSH
84271: LD_VAR 0 1
84275: PPUSH
84276: LD_EXP 55
84280: PUSH
84281: LD_VAR 0 1
84285: ARRAY
84286: PUSH
84287: LD_VAR 0 2
84291: UNION
84292: PPUSH
84293: CALL_OW 1
84297: ST_TO_ADDR
// end ;
84298: LD_VAR 0 3
84302: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
84303: LD_INT 0
84305: PPUSH
// if not mc_bases [ base ] then
84306: LD_EXP 50
84310: PUSH
84311: LD_VAR 0 1
84315: ARRAY
84316: NOT
84317: IFFALSE 84321
// exit ;
84319: GO 84346
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
84321: LD_ADDR_EXP 71
84325: PUSH
84326: LD_EXP 71
84330: PPUSH
84331: LD_VAR 0 1
84335: PPUSH
84336: LD_VAR 0 2
84340: PPUSH
84341: CALL_OW 1
84345: ST_TO_ADDR
// end ;
84346: LD_VAR 0 3
84350: RET
// export function MC_InsertProduceList ( base , components ) ; begin
84351: LD_INT 0
84353: PPUSH
// if not mc_bases [ base ] then
84354: LD_EXP 50
84358: PUSH
84359: LD_VAR 0 1
84363: ARRAY
84364: NOT
84365: IFFALSE 84369
// exit ;
84367: GO 84406
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
84369: LD_ADDR_EXP 71
84373: PUSH
84374: LD_EXP 71
84378: PPUSH
84379: LD_VAR 0 1
84383: PPUSH
84384: LD_EXP 71
84388: PUSH
84389: LD_VAR 0 1
84393: ARRAY
84394: PUSH
84395: LD_VAR 0 2
84399: ADD
84400: PPUSH
84401: CALL_OW 1
84405: ST_TO_ADDR
// end ;
84406: LD_VAR 0 3
84410: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
84411: LD_INT 0
84413: PPUSH
// if not mc_bases [ base ] then
84414: LD_EXP 50
84418: PUSH
84419: LD_VAR 0 1
84423: ARRAY
84424: NOT
84425: IFFALSE 84429
// exit ;
84427: GO 84483
// mc_defender := Replace ( mc_defender , base , deflist ) ;
84429: LD_ADDR_EXP 72
84433: PUSH
84434: LD_EXP 72
84438: PPUSH
84439: LD_VAR 0 1
84443: PPUSH
84444: LD_VAR 0 2
84448: PPUSH
84449: CALL_OW 1
84453: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
84454: LD_ADDR_EXP 61
84458: PUSH
84459: LD_EXP 61
84463: PPUSH
84464: LD_VAR 0 1
84468: PPUSH
84469: LD_VAR 0 2
84473: PUSH
84474: LD_INT 0
84476: PLUS
84477: PPUSH
84478: CALL_OW 1
84482: ST_TO_ADDR
// end ;
84483: LD_VAR 0 3
84487: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
84488: LD_INT 0
84490: PPUSH
// if not mc_bases [ base ] then
84491: LD_EXP 50
84495: PUSH
84496: LD_VAR 0 1
84500: ARRAY
84501: NOT
84502: IFFALSE 84506
// exit ;
84504: GO 84531
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
84506: LD_ADDR_EXP 61
84510: PUSH
84511: LD_EXP 61
84515: PPUSH
84516: LD_VAR 0 1
84520: PPUSH
84521: LD_VAR 0 2
84525: PPUSH
84526: CALL_OW 1
84530: ST_TO_ADDR
// end ;
84531: LD_VAR 0 3
84535: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
84536: LD_INT 0
84538: PPUSH
84539: PPUSH
84540: PPUSH
84541: PPUSH
// if not mc_bases [ base ] then
84542: LD_EXP 50
84546: PUSH
84547: LD_VAR 0 1
84551: ARRAY
84552: NOT
84553: IFFALSE 84557
// exit ;
84555: GO 84622
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
84557: LD_ADDR_EXP 70
84561: PUSH
84562: LD_EXP 70
84566: PPUSH
84567: LD_VAR 0 1
84571: PUSH
84572: LD_EXP 70
84576: PUSH
84577: LD_VAR 0 1
84581: ARRAY
84582: PUSH
84583: LD_INT 1
84585: PLUS
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: PPUSH
84591: LD_VAR 0 1
84595: PUSH
84596: LD_VAR 0 2
84600: PUSH
84601: LD_VAR 0 3
84605: PUSH
84606: LD_VAR 0 4
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: PPUSH
84617: CALL 24858 0 3
84621: ST_TO_ADDR
// end ;
84622: LD_VAR 0 5
84626: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
84627: LD_INT 0
84629: PPUSH
// if not mc_bases [ base ] then
84630: LD_EXP 50
84634: PUSH
84635: LD_VAR 0 1
84639: ARRAY
84640: NOT
84641: IFFALSE 84645
// exit ;
84643: GO 84670
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
84645: LD_ADDR_EXP 87
84649: PUSH
84650: LD_EXP 87
84654: PPUSH
84655: LD_VAR 0 1
84659: PPUSH
84660: LD_VAR 0 2
84664: PPUSH
84665: CALL_OW 1
84669: ST_TO_ADDR
// end ;
84670: LD_VAR 0 3
84674: RET
// export function MC_GetMinesField ( base ) ; begin
84675: LD_INT 0
84677: PPUSH
// result := mc_mines [ base ] ;
84678: LD_ADDR_VAR 0 2
84682: PUSH
84683: LD_EXP 63
84687: PUSH
84688: LD_VAR 0 1
84692: ARRAY
84693: ST_TO_ADDR
// end ;
84694: LD_VAR 0 2
84698: RET
// export function MC_GetProduceList ( base ) ; begin
84699: LD_INT 0
84701: PPUSH
// result := mc_produce [ base ] ;
84702: LD_ADDR_VAR 0 2
84706: PUSH
84707: LD_EXP 71
84711: PUSH
84712: LD_VAR 0 1
84716: ARRAY
84717: ST_TO_ADDR
// end ;
84718: LD_VAR 0 2
84722: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
84723: LD_INT 0
84725: PPUSH
84726: PPUSH
// if not mc_bases then
84727: LD_EXP 50
84731: NOT
84732: IFFALSE 84736
// exit ;
84734: GO 84801
// if mc_bases [ base ] then
84736: LD_EXP 50
84740: PUSH
84741: LD_VAR 0 1
84745: ARRAY
84746: IFFALSE 84801
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84748: LD_ADDR_VAR 0 3
84752: PUSH
84753: LD_EXP 50
84757: PUSH
84758: LD_VAR 0 1
84762: ARRAY
84763: PPUSH
84764: LD_INT 30
84766: PUSH
84767: LD_VAR 0 2
84771: PUSH
84772: EMPTY
84773: LIST
84774: LIST
84775: PPUSH
84776: CALL_OW 72
84780: ST_TO_ADDR
// if result then
84781: LD_VAR 0 3
84785: IFFALSE 84801
// result := result [ 1 ] ;
84787: LD_ADDR_VAR 0 3
84791: PUSH
84792: LD_VAR 0 3
84796: PUSH
84797: LD_INT 1
84799: ARRAY
84800: ST_TO_ADDR
// end ; end ;
84801: LD_VAR 0 3
84805: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
84806: LD_INT 0
84808: PPUSH
84809: PPUSH
// if not mc_bases then
84810: LD_EXP 50
84814: NOT
84815: IFFALSE 84819
// exit ;
84817: GO 84864
// if mc_bases [ base ] then
84819: LD_EXP 50
84823: PUSH
84824: LD_VAR 0 1
84828: ARRAY
84829: IFFALSE 84864
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84831: LD_ADDR_VAR 0 3
84835: PUSH
84836: LD_EXP 50
84840: PUSH
84841: LD_VAR 0 1
84845: ARRAY
84846: PPUSH
84847: LD_INT 30
84849: PUSH
84850: LD_VAR 0 2
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PPUSH
84859: CALL_OW 72
84863: ST_TO_ADDR
// end ;
84864: LD_VAR 0 3
84868: RET
// export function MC_SetTame ( base , area ) ; begin
84869: LD_INT 0
84871: PPUSH
// if not mc_bases or not base then
84872: LD_EXP 50
84876: NOT
84877: PUSH
84878: LD_VAR 0 1
84882: NOT
84883: OR
84884: IFFALSE 84888
// exit ;
84886: GO 84913
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
84888: LD_ADDR_EXP 78
84892: PUSH
84893: LD_EXP 78
84897: PPUSH
84898: LD_VAR 0 1
84902: PPUSH
84903: LD_VAR 0 2
84907: PPUSH
84908: CALL_OW 1
84912: ST_TO_ADDR
// end ;
84913: LD_VAR 0 3
84917: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
84918: LD_INT 0
84920: PPUSH
84921: PPUSH
// if not mc_bases or not base then
84922: LD_EXP 50
84926: NOT
84927: PUSH
84928: LD_VAR 0 1
84932: NOT
84933: OR
84934: IFFALSE 84938
// exit ;
84936: GO 85040
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84938: LD_ADDR_VAR 0 4
84942: PUSH
84943: LD_EXP 50
84947: PUSH
84948: LD_VAR 0 1
84952: ARRAY
84953: PPUSH
84954: LD_INT 30
84956: PUSH
84957: LD_VAR 0 2
84961: PUSH
84962: EMPTY
84963: LIST
84964: LIST
84965: PPUSH
84966: CALL_OW 72
84970: ST_TO_ADDR
// if not tmp then
84971: LD_VAR 0 4
84975: NOT
84976: IFFALSE 84980
// exit ;
84978: GO 85040
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
84980: LD_ADDR_EXP 82
84984: PUSH
84985: LD_EXP 82
84989: PPUSH
84990: LD_VAR 0 1
84994: PPUSH
84995: LD_EXP 82
84999: PUSH
85000: LD_VAR 0 1
85004: ARRAY
85005: PPUSH
85006: LD_EXP 82
85010: PUSH
85011: LD_VAR 0 1
85015: ARRAY
85016: PUSH
85017: LD_INT 1
85019: PLUS
85020: PPUSH
85021: LD_VAR 0 4
85025: PUSH
85026: LD_INT 1
85028: ARRAY
85029: PPUSH
85030: CALL_OW 2
85034: PPUSH
85035: CALL_OW 1
85039: ST_TO_ADDR
// end ;
85040: LD_VAR 0 3
85044: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
85045: LD_INT 0
85047: PPUSH
85048: PPUSH
// if not mc_bases or not base or not kinds then
85049: LD_EXP 50
85053: NOT
85054: PUSH
85055: LD_VAR 0 1
85059: NOT
85060: OR
85061: PUSH
85062: LD_VAR 0 2
85066: NOT
85067: OR
85068: IFFALSE 85072
// exit ;
85070: GO 85133
// for i in kinds do
85072: LD_ADDR_VAR 0 4
85076: PUSH
85077: LD_VAR 0 2
85081: PUSH
85082: FOR_IN
85083: IFFALSE 85131
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
85085: LD_ADDR_EXP 84
85089: PUSH
85090: LD_EXP 84
85094: PPUSH
85095: LD_VAR 0 1
85099: PUSH
85100: LD_EXP 84
85104: PUSH
85105: LD_VAR 0 1
85109: ARRAY
85110: PUSH
85111: LD_INT 1
85113: PLUS
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PPUSH
85119: LD_VAR 0 4
85123: PPUSH
85124: CALL 24858 0 3
85128: ST_TO_ADDR
85129: GO 85082
85131: POP
85132: POP
// end ;
85133: LD_VAR 0 3
85137: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
85138: LD_INT 0
85140: PPUSH
// if not mc_bases or not base or not areas then
85141: LD_EXP 50
85145: NOT
85146: PUSH
85147: LD_VAR 0 1
85151: NOT
85152: OR
85153: PUSH
85154: LD_VAR 0 2
85158: NOT
85159: OR
85160: IFFALSE 85164
// exit ;
85162: GO 85189
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
85164: LD_ADDR_EXP 68
85168: PUSH
85169: LD_EXP 68
85173: PPUSH
85174: LD_VAR 0 1
85178: PPUSH
85179: LD_VAR 0 2
85183: PPUSH
85184: CALL_OW 1
85188: ST_TO_ADDR
// end ;
85189: LD_VAR 0 3
85193: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
85194: LD_INT 0
85196: PPUSH
// if not mc_bases or not base or not teleports_exit then
85197: LD_EXP 50
85201: NOT
85202: PUSH
85203: LD_VAR 0 1
85207: NOT
85208: OR
85209: PUSH
85210: LD_VAR 0 2
85214: NOT
85215: OR
85216: IFFALSE 85220
// exit ;
85218: GO 85245
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
85220: LD_ADDR_EXP 85
85224: PUSH
85225: LD_EXP 85
85229: PPUSH
85230: LD_VAR 0 1
85234: PPUSH
85235: LD_VAR 0 2
85239: PPUSH
85240: CALL_OW 1
85244: ST_TO_ADDR
// end ;
85245: LD_VAR 0 3
85249: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
85250: LD_INT 0
85252: PPUSH
85253: PPUSH
85254: PPUSH
// if not mc_bases or not base or not ext_list then
85255: LD_EXP 50
85259: NOT
85260: PUSH
85261: LD_VAR 0 1
85265: NOT
85266: OR
85267: PUSH
85268: LD_VAR 0 5
85272: NOT
85273: OR
85274: IFFALSE 85278
// exit ;
85276: GO 85451
// tmp := GetFacExtXYD ( x , y , d ) ;
85278: LD_ADDR_VAR 0 8
85282: PUSH
85283: LD_VAR 0 2
85287: PPUSH
85288: LD_VAR 0 3
85292: PPUSH
85293: LD_VAR 0 4
85297: PPUSH
85298: CALL 54245 0 3
85302: ST_TO_ADDR
// if not tmp then
85303: LD_VAR 0 8
85307: NOT
85308: IFFALSE 85312
// exit ;
85310: GO 85451
// for i in tmp do
85312: LD_ADDR_VAR 0 7
85316: PUSH
85317: LD_VAR 0 8
85321: PUSH
85322: FOR_IN
85323: IFFALSE 85449
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
85325: LD_ADDR_EXP 55
85329: PUSH
85330: LD_EXP 55
85334: PPUSH
85335: LD_VAR 0 1
85339: PPUSH
85340: LD_EXP 55
85344: PUSH
85345: LD_VAR 0 1
85349: ARRAY
85350: PPUSH
85351: LD_EXP 55
85355: PUSH
85356: LD_VAR 0 1
85360: ARRAY
85361: PUSH
85362: LD_INT 1
85364: PLUS
85365: PPUSH
85366: LD_VAR 0 5
85370: PUSH
85371: LD_INT 1
85373: ARRAY
85374: PUSH
85375: LD_VAR 0 7
85379: PUSH
85380: LD_INT 1
85382: ARRAY
85383: PUSH
85384: LD_VAR 0 7
85388: PUSH
85389: LD_INT 2
85391: ARRAY
85392: PUSH
85393: LD_VAR 0 7
85397: PUSH
85398: LD_INT 3
85400: ARRAY
85401: PUSH
85402: EMPTY
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: PPUSH
85408: CALL_OW 2
85412: PPUSH
85413: CALL_OW 1
85417: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
85418: LD_ADDR_VAR 0 5
85422: PUSH
85423: LD_VAR 0 5
85427: PPUSH
85428: LD_INT 1
85430: PPUSH
85431: CALL_OW 3
85435: ST_TO_ADDR
// if not ext_list then
85436: LD_VAR 0 5
85440: NOT
85441: IFFALSE 85447
// exit ;
85443: POP
85444: POP
85445: GO 85451
// end ;
85447: GO 85322
85449: POP
85450: POP
// end ;
85451: LD_VAR 0 6
85455: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
85456: LD_INT 0
85458: PPUSH
// if not mc_bases or not base or not weapon_list then
85459: LD_EXP 50
85463: NOT
85464: PUSH
85465: LD_VAR 0 1
85469: NOT
85470: OR
85471: PUSH
85472: LD_VAR 0 2
85476: NOT
85477: OR
85478: IFFALSE 85482
// exit ;
85480: GO 85507
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
85482: LD_ADDR_EXP 89
85486: PUSH
85487: LD_EXP 89
85491: PPUSH
85492: LD_VAR 0 1
85496: PPUSH
85497: LD_VAR 0 2
85501: PPUSH
85502: CALL_OW 1
85506: ST_TO_ADDR
// end ;
85507: LD_VAR 0 3
85511: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
85512: LD_INT 0
85514: PPUSH
// if not mc_bases or not base or not tech_list then
85515: LD_EXP 50
85519: NOT
85520: PUSH
85521: LD_VAR 0 1
85525: NOT
85526: OR
85527: PUSH
85528: LD_VAR 0 2
85532: NOT
85533: OR
85534: IFFALSE 85538
// exit ;
85536: GO 85563
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
85538: LD_ADDR_EXP 77
85542: PUSH
85543: LD_EXP 77
85547: PPUSH
85548: LD_VAR 0 1
85552: PPUSH
85553: LD_VAR 0 2
85557: PPUSH
85558: CALL_OW 1
85562: ST_TO_ADDR
// end ;
85563: LD_VAR 0 3
85567: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
85568: LD_INT 0
85570: PPUSH
// if not mc_bases or not parking_area or not base then
85571: LD_EXP 50
85575: NOT
85576: PUSH
85577: LD_VAR 0 2
85581: NOT
85582: OR
85583: PUSH
85584: LD_VAR 0 1
85588: NOT
85589: OR
85590: IFFALSE 85594
// exit ;
85592: GO 85619
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
85594: LD_ADDR_EXP 74
85598: PUSH
85599: LD_EXP 74
85603: PPUSH
85604: LD_VAR 0 1
85608: PPUSH
85609: LD_VAR 0 2
85613: PPUSH
85614: CALL_OW 1
85618: ST_TO_ADDR
// end ;
85619: LD_VAR 0 3
85623: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
85624: LD_INT 0
85626: PPUSH
// if not mc_bases or not base or not scan_area then
85627: LD_EXP 50
85631: NOT
85632: PUSH
85633: LD_VAR 0 1
85637: NOT
85638: OR
85639: PUSH
85640: LD_VAR 0 2
85644: NOT
85645: OR
85646: IFFALSE 85650
// exit ;
85648: GO 85675
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
85650: LD_ADDR_EXP 75
85654: PUSH
85655: LD_EXP 75
85659: PPUSH
85660: LD_VAR 0 1
85664: PPUSH
85665: LD_VAR 0 2
85669: PPUSH
85670: CALL_OW 1
85674: ST_TO_ADDR
// end ;
85675: LD_VAR 0 3
85679: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
85680: LD_INT 0
85682: PPUSH
85683: PPUSH
// if not mc_bases or not base then
85684: LD_EXP 50
85688: NOT
85689: PUSH
85690: LD_VAR 0 1
85694: NOT
85695: OR
85696: IFFALSE 85700
// exit ;
85698: GO 85764
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
85700: LD_ADDR_VAR 0 3
85704: PUSH
85705: LD_INT 1
85707: PUSH
85708: LD_INT 2
85710: PUSH
85711: LD_INT 3
85713: PUSH
85714: LD_INT 4
85716: PUSH
85717: LD_INT 11
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: LIST
85724: LIST
85725: LIST
85726: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
85727: LD_ADDR_EXP 77
85731: PUSH
85732: LD_EXP 77
85736: PPUSH
85737: LD_VAR 0 1
85741: PPUSH
85742: LD_EXP 77
85746: PUSH
85747: LD_VAR 0 1
85751: ARRAY
85752: PUSH
85753: LD_VAR 0 3
85757: DIFF
85758: PPUSH
85759: CALL_OW 1
85763: ST_TO_ADDR
// end ;
85764: LD_VAR 0 2
85768: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
85769: LD_INT 0
85771: PPUSH
// result := mc_vehicles [ base ] ;
85772: LD_ADDR_VAR 0 3
85776: PUSH
85777: LD_EXP 69
85781: PUSH
85782: LD_VAR 0 1
85786: ARRAY
85787: ST_TO_ADDR
// if onlyCombat then
85788: LD_VAR 0 2
85792: IFFALSE 85970
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
85794: LD_ADDR_VAR 0 3
85798: PUSH
85799: LD_VAR 0 3
85803: PUSH
85804: LD_VAR 0 3
85808: PPUSH
85809: LD_INT 2
85811: PUSH
85812: LD_INT 34
85814: PUSH
85815: LD_INT 12
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 34
85824: PUSH
85825: LD_INT 51
85827: PUSH
85828: EMPTY
85829: LIST
85830: LIST
85831: PUSH
85832: LD_INT 34
85834: PUSH
85835: LD_EXP 30
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 34
85846: PUSH
85847: LD_INT 32
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 34
85856: PUSH
85857: LD_INT 13
85859: PUSH
85860: EMPTY
85861: LIST
85862: LIST
85863: PUSH
85864: LD_INT 34
85866: PUSH
85867: LD_INT 52
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: PUSH
85874: LD_INT 34
85876: PUSH
85877: LD_EXP 35
85881: PUSH
85882: EMPTY
85883: LIST
85884: LIST
85885: PUSH
85886: LD_INT 34
85888: PUSH
85889: LD_INT 14
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PUSH
85896: LD_INT 34
85898: PUSH
85899: LD_INT 53
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: LD_INT 34
85908: PUSH
85909: LD_EXP 29
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 34
85920: PUSH
85921: LD_INT 31
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 34
85930: PUSH
85931: LD_INT 48
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: LD_INT 34
85940: PUSH
85941: LD_INT 8
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: PPUSH
85964: CALL_OW 72
85968: DIFF
85969: ST_TO_ADDR
// end ; end_of_file
85970: LD_VAR 0 3
85974: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
85975: LD_INT 0
85977: PPUSH
85978: PPUSH
85979: PPUSH
// if not mc_bases or not skirmish then
85980: LD_EXP 50
85984: NOT
85985: PUSH
85986: LD_EXP 48
85990: NOT
85991: OR
85992: IFFALSE 85996
// exit ;
85994: GO 86161
// for i = 1 to mc_bases do
85996: LD_ADDR_VAR 0 4
86000: PUSH
86001: DOUBLE
86002: LD_INT 1
86004: DEC
86005: ST_TO_ADDR
86006: LD_EXP 50
86010: PUSH
86011: FOR_TO
86012: IFFALSE 86159
// begin if sci in mc_bases [ i ] then
86014: LD_VAR 0 2
86018: PUSH
86019: LD_EXP 50
86023: PUSH
86024: LD_VAR 0 4
86028: ARRAY
86029: IN
86030: IFFALSE 86157
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
86032: LD_ADDR_EXP 79
86036: PUSH
86037: LD_EXP 79
86041: PPUSH
86042: LD_VAR 0 4
86046: PUSH
86047: LD_EXP 79
86051: PUSH
86052: LD_VAR 0 4
86056: ARRAY
86057: PUSH
86058: LD_INT 1
86060: PLUS
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PPUSH
86066: LD_VAR 0 1
86070: PPUSH
86071: CALL 24858 0 3
86075: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
86076: LD_ADDR_VAR 0 5
86080: PUSH
86081: LD_EXP 50
86085: PUSH
86086: LD_VAR 0 4
86090: ARRAY
86091: PPUSH
86092: LD_INT 2
86094: PUSH
86095: LD_INT 30
86097: PUSH
86098: LD_INT 0
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 30
86107: PUSH
86108: LD_INT 1
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: EMPTY
86116: LIST
86117: LIST
86118: LIST
86119: PPUSH
86120: CALL_OW 72
86124: PPUSH
86125: LD_VAR 0 1
86129: PPUSH
86130: CALL_OW 74
86134: ST_TO_ADDR
// if tmp then
86135: LD_VAR 0 5
86139: IFFALSE 86155
// ComStandNearbyBuilding ( ape , tmp ) ;
86141: LD_VAR 0 1
86145: PPUSH
86146: LD_VAR 0 5
86150: PPUSH
86151: CALL 21436 0 2
// break ;
86155: GO 86159
// end ; end ;
86157: GO 86011
86159: POP
86160: POP
// end ;
86161: LD_VAR 0 3
86165: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
86166: LD_INT 0
86168: PPUSH
86169: PPUSH
86170: PPUSH
// if not mc_bases or not skirmish then
86171: LD_EXP 50
86175: NOT
86176: PUSH
86177: LD_EXP 48
86181: NOT
86182: OR
86183: IFFALSE 86187
// exit ;
86185: GO 86276
// for i = 1 to mc_bases do
86187: LD_ADDR_VAR 0 4
86191: PUSH
86192: DOUBLE
86193: LD_INT 1
86195: DEC
86196: ST_TO_ADDR
86197: LD_EXP 50
86201: PUSH
86202: FOR_TO
86203: IFFALSE 86274
// begin if building in mc_busy_turret_list [ i ] then
86205: LD_VAR 0 1
86209: PUSH
86210: LD_EXP 60
86214: PUSH
86215: LD_VAR 0 4
86219: ARRAY
86220: IN
86221: IFFALSE 86272
// begin tmp := mc_busy_turret_list [ i ] diff building ;
86223: LD_ADDR_VAR 0 5
86227: PUSH
86228: LD_EXP 60
86232: PUSH
86233: LD_VAR 0 4
86237: ARRAY
86238: PUSH
86239: LD_VAR 0 1
86243: DIFF
86244: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
86245: LD_ADDR_EXP 60
86249: PUSH
86250: LD_EXP 60
86254: PPUSH
86255: LD_VAR 0 4
86259: PPUSH
86260: LD_VAR 0 5
86264: PPUSH
86265: CALL_OW 1
86269: ST_TO_ADDR
// break ;
86270: GO 86274
// end ; end ;
86272: GO 86202
86274: POP
86275: POP
// end ;
86276: LD_VAR 0 3
86280: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
86281: LD_INT 0
86283: PPUSH
86284: PPUSH
86285: PPUSH
// if not mc_bases or not skirmish then
86286: LD_EXP 50
86290: NOT
86291: PUSH
86292: LD_EXP 48
86296: NOT
86297: OR
86298: IFFALSE 86302
// exit ;
86300: GO 86501
// for i = 1 to mc_bases do
86302: LD_ADDR_VAR 0 5
86306: PUSH
86307: DOUBLE
86308: LD_INT 1
86310: DEC
86311: ST_TO_ADDR
86312: LD_EXP 50
86316: PUSH
86317: FOR_TO
86318: IFFALSE 86499
// if building in mc_bases [ i ] then
86320: LD_VAR 0 1
86324: PUSH
86325: LD_EXP 50
86329: PUSH
86330: LD_VAR 0 5
86334: ARRAY
86335: IN
86336: IFFALSE 86497
// begin tmp := mc_bases [ i ] diff building ;
86338: LD_ADDR_VAR 0 6
86342: PUSH
86343: LD_EXP 50
86347: PUSH
86348: LD_VAR 0 5
86352: ARRAY
86353: PUSH
86354: LD_VAR 0 1
86358: DIFF
86359: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
86360: LD_ADDR_EXP 50
86364: PUSH
86365: LD_EXP 50
86369: PPUSH
86370: LD_VAR 0 5
86374: PPUSH
86375: LD_VAR 0 6
86379: PPUSH
86380: CALL_OW 1
86384: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
86385: LD_VAR 0 1
86389: PUSH
86390: LD_EXP 58
86394: PUSH
86395: LD_VAR 0 5
86399: ARRAY
86400: IN
86401: IFFALSE 86440
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
86403: LD_ADDR_EXP 58
86407: PUSH
86408: LD_EXP 58
86412: PPUSH
86413: LD_VAR 0 5
86417: PPUSH
86418: LD_EXP 58
86422: PUSH
86423: LD_VAR 0 5
86427: ARRAY
86428: PUSH
86429: LD_VAR 0 1
86433: DIFF
86434: PPUSH
86435: CALL_OW 1
86439: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
86440: LD_VAR 0 1
86444: PUSH
86445: LD_EXP 59
86449: PUSH
86450: LD_VAR 0 5
86454: ARRAY
86455: IN
86456: IFFALSE 86495
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
86458: LD_ADDR_EXP 59
86462: PUSH
86463: LD_EXP 59
86467: PPUSH
86468: LD_VAR 0 5
86472: PPUSH
86473: LD_EXP 59
86477: PUSH
86478: LD_VAR 0 5
86482: ARRAY
86483: PUSH
86484: LD_VAR 0 1
86488: DIFF
86489: PPUSH
86490: CALL_OW 1
86494: ST_TO_ADDR
// break ;
86495: GO 86499
// end ;
86497: GO 86317
86499: POP
86500: POP
// end ;
86501: LD_VAR 0 4
86505: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
86506: LD_INT 0
86508: PPUSH
86509: PPUSH
86510: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
86511: LD_EXP 50
86515: NOT
86516: PUSH
86517: LD_EXP 48
86521: NOT
86522: OR
86523: PUSH
86524: LD_VAR 0 3
86528: PUSH
86529: LD_EXP 76
86533: IN
86534: NOT
86535: OR
86536: IFFALSE 86540
// exit ;
86538: GO 86663
// for i = 1 to mc_vehicles do
86540: LD_ADDR_VAR 0 6
86544: PUSH
86545: DOUBLE
86546: LD_INT 1
86548: DEC
86549: ST_TO_ADDR
86550: LD_EXP 69
86554: PUSH
86555: FOR_TO
86556: IFFALSE 86661
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
86558: LD_VAR 0 2
86562: PUSH
86563: LD_EXP 69
86567: PUSH
86568: LD_VAR 0 6
86572: ARRAY
86573: IN
86574: PUSH
86575: LD_VAR 0 1
86579: PUSH
86580: LD_EXP 69
86584: PUSH
86585: LD_VAR 0 6
86589: ARRAY
86590: IN
86591: OR
86592: IFFALSE 86659
// begin tmp := mc_vehicles [ i ] diff old ;
86594: LD_ADDR_VAR 0 7
86598: PUSH
86599: LD_EXP 69
86603: PUSH
86604: LD_VAR 0 6
86608: ARRAY
86609: PUSH
86610: LD_VAR 0 2
86614: DIFF
86615: ST_TO_ADDR
// tmp := tmp diff new ;
86616: LD_ADDR_VAR 0 7
86620: PUSH
86621: LD_VAR 0 7
86625: PUSH
86626: LD_VAR 0 1
86630: DIFF
86631: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
86632: LD_ADDR_EXP 69
86636: PUSH
86637: LD_EXP 69
86641: PPUSH
86642: LD_VAR 0 6
86646: PPUSH
86647: LD_VAR 0 7
86651: PPUSH
86652: CALL_OW 1
86656: ST_TO_ADDR
// break ;
86657: GO 86661
// end ;
86659: GO 86555
86661: POP
86662: POP
// end ;
86663: LD_VAR 0 5
86667: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
86668: LD_INT 0
86670: PPUSH
86671: PPUSH
86672: PPUSH
86673: PPUSH
// if not mc_bases or not skirmish then
86674: LD_EXP 50
86678: NOT
86679: PUSH
86680: LD_EXP 48
86684: NOT
86685: OR
86686: IFFALSE 86690
// exit ;
86688: GO 87082
// side := GetSide ( vehicle ) ;
86690: LD_ADDR_VAR 0 5
86694: PUSH
86695: LD_VAR 0 1
86699: PPUSH
86700: CALL_OW 255
86704: ST_TO_ADDR
// for i = 1 to mc_bases do
86705: LD_ADDR_VAR 0 4
86709: PUSH
86710: DOUBLE
86711: LD_INT 1
86713: DEC
86714: ST_TO_ADDR
86715: LD_EXP 50
86719: PUSH
86720: FOR_TO
86721: IFFALSE 87080
// begin if factory in mc_bases [ i ] then
86723: LD_VAR 0 2
86727: PUSH
86728: LD_EXP 50
86732: PUSH
86733: LD_VAR 0 4
86737: ARRAY
86738: IN
86739: IFFALSE 87078
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
86741: LD_EXP 72
86745: PUSH
86746: LD_VAR 0 4
86750: ARRAY
86751: PUSH
86752: LD_EXP 61
86756: PUSH
86757: LD_VAR 0 4
86761: ARRAY
86762: LESS
86763: PUSH
86764: LD_VAR 0 1
86768: PPUSH
86769: CALL_OW 264
86773: PUSH
86774: LD_INT 31
86776: PUSH
86777: LD_INT 32
86779: PUSH
86780: LD_INT 51
86782: PUSH
86783: LD_EXP 30
86787: PUSH
86788: LD_INT 12
86790: PUSH
86791: LD_INT 30
86793: PUSH
86794: LD_EXP 29
86798: PUSH
86799: LD_INT 11
86801: PUSH
86802: LD_INT 53
86804: PUSH
86805: LD_INT 14
86807: PUSH
86808: LD_EXP 33
86812: PUSH
86813: LD_INT 29
86815: PUSH
86816: LD_EXP 31
86820: PUSH
86821: LD_INT 13
86823: PUSH
86824: LD_INT 52
86826: PUSH
86827: LD_EXP 35
86831: PUSH
86832: LD_INT 48
86834: PUSH
86835: LD_INT 8
86837: PUSH
86838: EMPTY
86839: LIST
86840: LIST
86841: LIST
86842: LIST
86843: LIST
86844: LIST
86845: LIST
86846: LIST
86847: LIST
86848: LIST
86849: LIST
86850: LIST
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: IN
86858: NOT
86859: AND
86860: IFFALSE 86908
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
86862: LD_ADDR_EXP 72
86866: PUSH
86867: LD_EXP 72
86871: PPUSH
86872: LD_VAR 0 4
86876: PUSH
86877: LD_EXP 72
86881: PUSH
86882: LD_VAR 0 4
86886: ARRAY
86887: PUSH
86888: LD_INT 1
86890: PLUS
86891: PUSH
86892: EMPTY
86893: LIST
86894: LIST
86895: PPUSH
86896: LD_VAR 0 1
86900: PPUSH
86901: CALL 24858 0 3
86905: ST_TO_ADDR
86906: GO 86952
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
86908: LD_ADDR_EXP 69
86912: PUSH
86913: LD_EXP 69
86917: PPUSH
86918: LD_VAR 0 4
86922: PUSH
86923: LD_EXP 69
86927: PUSH
86928: LD_VAR 0 4
86932: ARRAY
86933: PUSH
86934: LD_INT 1
86936: PLUS
86937: PUSH
86938: EMPTY
86939: LIST
86940: LIST
86941: PPUSH
86942: LD_VAR 0 1
86946: PPUSH
86947: CALL 24858 0 3
86951: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
86952: LD_VAR 0 1
86956: PPUSH
86957: CALL_OW 263
86961: PUSH
86962: LD_INT 2
86964: EQUAL
86965: IFFALSE 86994
// begin repeat wait ( 0 0$3 ) ;
86967: LD_INT 105
86969: PPUSH
86970: CALL_OW 67
// Connect ( vehicle ) ;
86974: LD_VAR 0 1
86978: PPUSH
86979: CALL 27829 0 1
// until IsControledBy ( vehicle ) ;
86983: LD_VAR 0 1
86987: PPUSH
86988: CALL_OW 312
86992: IFFALSE 86967
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
86994: LD_VAR 0 1
86998: PPUSH
86999: LD_EXP 74
87003: PUSH
87004: LD_VAR 0 4
87008: ARRAY
87009: PPUSH
87010: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
87014: LD_VAR 0 1
87018: PPUSH
87019: CALL_OW 263
87023: PUSH
87024: LD_INT 1
87026: NONEQUAL
87027: IFFALSE 87031
// break ;
87029: GO 87080
// repeat wait ( 0 0$1 ) ;
87031: LD_INT 35
87033: PPUSH
87034: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
87038: LD_VAR 0 1
87042: PPUSH
87043: LD_EXP 74
87047: PUSH
87048: LD_VAR 0 4
87052: ARRAY
87053: PPUSH
87054: CALL_OW 308
87058: IFFALSE 87031
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
87060: LD_VAR 0 1
87064: PPUSH
87065: CALL_OW 311
87069: PPUSH
87070: CALL_OW 121
// exit ;
87074: POP
87075: POP
87076: GO 87082
// end ; end ;
87078: GO 86720
87080: POP
87081: POP
// end ;
87082: LD_VAR 0 3
87086: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
87087: LD_INT 0
87089: PPUSH
87090: PPUSH
87091: PPUSH
87092: PPUSH
// if not mc_bases or not skirmish then
87093: LD_EXP 50
87097: NOT
87098: PUSH
87099: LD_EXP 48
87103: NOT
87104: OR
87105: IFFALSE 87109
// exit ;
87107: GO 87462
// repeat wait ( 0 0$1 ) ;
87109: LD_INT 35
87111: PPUSH
87112: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
87116: LD_VAR 0 2
87120: PPUSH
87121: LD_VAR 0 3
87125: PPUSH
87126: CALL_OW 284
87130: IFFALSE 87109
// if GetResourceTypeXY ( x , y ) = mat_artefact then
87132: LD_VAR 0 2
87136: PPUSH
87137: LD_VAR 0 3
87141: PPUSH
87142: CALL_OW 283
87146: PUSH
87147: LD_INT 4
87149: EQUAL
87150: IFFALSE 87154
// exit ;
87152: GO 87462
// for i = 1 to mc_bases do
87154: LD_ADDR_VAR 0 7
87158: PUSH
87159: DOUBLE
87160: LD_INT 1
87162: DEC
87163: ST_TO_ADDR
87164: LD_EXP 50
87168: PUSH
87169: FOR_TO
87170: IFFALSE 87460
// begin if mc_crates_area [ i ] then
87172: LD_EXP 68
87176: PUSH
87177: LD_VAR 0 7
87181: ARRAY
87182: IFFALSE 87293
// for j in mc_crates_area [ i ] do
87184: LD_ADDR_VAR 0 8
87188: PUSH
87189: LD_EXP 68
87193: PUSH
87194: LD_VAR 0 7
87198: ARRAY
87199: PUSH
87200: FOR_IN
87201: IFFALSE 87291
// if InArea ( x , y , j ) then
87203: LD_VAR 0 2
87207: PPUSH
87208: LD_VAR 0 3
87212: PPUSH
87213: LD_VAR 0 8
87217: PPUSH
87218: CALL_OW 309
87222: IFFALSE 87289
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
87224: LD_ADDR_EXP 66
87228: PUSH
87229: LD_EXP 66
87233: PPUSH
87234: LD_VAR 0 7
87238: PUSH
87239: LD_EXP 66
87243: PUSH
87244: LD_VAR 0 7
87248: ARRAY
87249: PUSH
87250: LD_INT 1
87252: PLUS
87253: PUSH
87254: EMPTY
87255: LIST
87256: LIST
87257: PPUSH
87258: LD_VAR 0 4
87262: PUSH
87263: LD_VAR 0 2
87267: PUSH
87268: LD_VAR 0 3
87272: PUSH
87273: EMPTY
87274: LIST
87275: LIST
87276: LIST
87277: PPUSH
87278: CALL 24858 0 3
87282: ST_TO_ADDR
// exit ;
87283: POP
87284: POP
87285: POP
87286: POP
87287: GO 87462
// end ;
87289: GO 87200
87291: POP
87292: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87293: LD_ADDR_VAR 0 9
87297: PUSH
87298: LD_EXP 50
87302: PUSH
87303: LD_VAR 0 7
87307: ARRAY
87308: PPUSH
87309: LD_INT 2
87311: PUSH
87312: LD_INT 30
87314: PUSH
87315: LD_INT 0
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: LD_INT 30
87324: PUSH
87325: LD_INT 1
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: EMPTY
87333: LIST
87334: LIST
87335: LIST
87336: PPUSH
87337: CALL_OW 72
87341: ST_TO_ADDR
// if not depot then
87342: LD_VAR 0 9
87346: NOT
87347: IFFALSE 87351
// continue ;
87349: GO 87169
// for j in depot do
87351: LD_ADDR_VAR 0 8
87355: PUSH
87356: LD_VAR 0 9
87360: PUSH
87361: FOR_IN
87362: IFFALSE 87456
// if GetDistUnitXY ( j , x , y ) < 30 then
87364: LD_VAR 0 8
87368: PPUSH
87369: LD_VAR 0 2
87373: PPUSH
87374: LD_VAR 0 3
87378: PPUSH
87379: CALL_OW 297
87383: PUSH
87384: LD_INT 30
87386: LESS
87387: IFFALSE 87454
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
87389: LD_ADDR_EXP 66
87393: PUSH
87394: LD_EXP 66
87398: PPUSH
87399: LD_VAR 0 7
87403: PUSH
87404: LD_EXP 66
87408: PUSH
87409: LD_VAR 0 7
87413: ARRAY
87414: PUSH
87415: LD_INT 1
87417: PLUS
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PPUSH
87423: LD_VAR 0 4
87427: PUSH
87428: LD_VAR 0 2
87432: PUSH
87433: LD_VAR 0 3
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: LIST
87442: PPUSH
87443: CALL 24858 0 3
87447: ST_TO_ADDR
// exit ;
87448: POP
87449: POP
87450: POP
87451: POP
87452: GO 87462
// end ;
87454: GO 87361
87456: POP
87457: POP
// end ;
87458: GO 87169
87460: POP
87461: POP
// end ;
87462: LD_VAR 0 6
87466: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
87467: LD_INT 0
87469: PPUSH
87470: PPUSH
87471: PPUSH
87472: PPUSH
// if not mc_bases or not skirmish then
87473: LD_EXP 50
87477: NOT
87478: PUSH
87479: LD_EXP 48
87483: NOT
87484: OR
87485: IFFALSE 87489
// exit ;
87487: GO 87766
// side := GetSide ( lab ) ;
87489: LD_ADDR_VAR 0 4
87493: PUSH
87494: LD_VAR 0 2
87498: PPUSH
87499: CALL_OW 255
87503: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
87504: LD_VAR 0 4
87508: PUSH
87509: LD_EXP 76
87513: IN
87514: NOT
87515: PUSH
87516: LD_EXP 77
87520: NOT
87521: OR
87522: PUSH
87523: LD_EXP 50
87527: NOT
87528: OR
87529: IFFALSE 87533
// exit ;
87531: GO 87766
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
87533: LD_ADDR_EXP 77
87537: PUSH
87538: LD_EXP 77
87542: PPUSH
87543: LD_VAR 0 4
87547: PPUSH
87548: LD_EXP 77
87552: PUSH
87553: LD_VAR 0 4
87557: ARRAY
87558: PUSH
87559: LD_VAR 0 1
87563: DIFF
87564: PPUSH
87565: CALL_OW 1
87569: ST_TO_ADDR
// for i = 1 to mc_bases do
87570: LD_ADDR_VAR 0 5
87574: PUSH
87575: DOUBLE
87576: LD_INT 1
87578: DEC
87579: ST_TO_ADDR
87580: LD_EXP 50
87584: PUSH
87585: FOR_TO
87586: IFFALSE 87764
// begin if lab in mc_bases [ i ] then
87588: LD_VAR 0 2
87592: PUSH
87593: LD_EXP 50
87597: PUSH
87598: LD_VAR 0 5
87602: ARRAY
87603: IN
87604: IFFALSE 87762
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
87606: LD_VAR 0 1
87610: PUSH
87611: LD_INT 11
87613: PUSH
87614: LD_INT 4
87616: PUSH
87617: LD_INT 3
87619: PUSH
87620: LD_INT 2
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: LIST
87627: LIST
87628: IN
87629: PUSH
87630: LD_EXP 80
87634: PUSH
87635: LD_VAR 0 5
87639: ARRAY
87640: AND
87641: IFFALSE 87762
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
87643: LD_ADDR_VAR 0 6
87647: PUSH
87648: LD_EXP 80
87652: PUSH
87653: LD_VAR 0 5
87657: ARRAY
87658: PUSH
87659: LD_INT 1
87661: ARRAY
87662: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87663: LD_ADDR_EXP 80
87667: PUSH
87668: LD_EXP 80
87672: PPUSH
87673: LD_VAR 0 5
87677: PPUSH
87678: EMPTY
87679: PPUSH
87680: CALL_OW 1
87684: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
87685: LD_VAR 0 6
87689: PPUSH
87690: LD_INT 0
87692: PPUSH
87693: CALL_OW 109
// ComExitBuilding ( tmp ) ;
87697: LD_VAR 0 6
87701: PPUSH
87702: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
87706: LD_ADDR_EXP 79
87710: PUSH
87711: LD_EXP 79
87715: PPUSH
87716: LD_VAR 0 5
87720: PPUSH
87721: LD_EXP 79
87725: PUSH
87726: LD_VAR 0 5
87730: ARRAY
87731: PPUSH
87732: LD_INT 1
87734: PPUSH
87735: LD_VAR 0 6
87739: PPUSH
87740: CALL_OW 2
87744: PPUSH
87745: CALL_OW 1
87749: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
87750: LD_VAR 0 5
87754: PPUSH
87755: LD_INT 112
87757: PPUSH
87758: CALL 64285 0 2
// end ; end ; end ;
87762: GO 87585
87764: POP
87765: POP
// end ;
87766: LD_VAR 0 3
87770: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
87771: LD_INT 0
87773: PPUSH
87774: PPUSH
87775: PPUSH
87776: PPUSH
87777: PPUSH
87778: PPUSH
87779: PPUSH
87780: PPUSH
// if not mc_bases or not skirmish then
87781: LD_EXP 50
87785: NOT
87786: PUSH
87787: LD_EXP 48
87791: NOT
87792: OR
87793: IFFALSE 87797
// exit ;
87795: GO 89168
// for i = 1 to mc_bases do
87797: LD_ADDR_VAR 0 3
87801: PUSH
87802: DOUBLE
87803: LD_INT 1
87805: DEC
87806: ST_TO_ADDR
87807: LD_EXP 50
87811: PUSH
87812: FOR_TO
87813: IFFALSE 89166
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
87815: LD_VAR 0 1
87819: PUSH
87820: LD_EXP 50
87824: PUSH
87825: LD_VAR 0 3
87829: ARRAY
87830: IN
87831: PUSH
87832: LD_VAR 0 1
87836: PUSH
87837: LD_EXP 57
87841: PUSH
87842: LD_VAR 0 3
87846: ARRAY
87847: IN
87848: OR
87849: PUSH
87850: LD_VAR 0 1
87854: PUSH
87855: LD_EXP 72
87859: PUSH
87860: LD_VAR 0 3
87864: ARRAY
87865: IN
87866: OR
87867: PUSH
87868: LD_VAR 0 1
87872: PUSH
87873: LD_EXP 69
87877: PUSH
87878: LD_VAR 0 3
87882: ARRAY
87883: IN
87884: OR
87885: PUSH
87886: LD_VAR 0 1
87890: PUSH
87891: LD_EXP 79
87895: PUSH
87896: LD_VAR 0 3
87900: ARRAY
87901: IN
87902: OR
87903: PUSH
87904: LD_VAR 0 1
87908: PUSH
87909: LD_EXP 80
87913: PUSH
87914: LD_VAR 0 3
87918: ARRAY
87919: IN
87920: OR
87921: IFFALSE 89164
// begin if un in mc_ape [ i ] then
87923: LD_VAR 0 1
87927: PUSH
87928: LD_EXP 79
87932: PUSH
87933: LD_VAR 0 3
87937: ARRAY
87938: IN
87939: IFFALSE 87978
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
87941: LD_ADDR_EXP 79
87945: PUSH
87946: LD_EXP 79
87950: PPUSH
87951: LD_VAR 0 3
87955: PPUSH
87956: LD_EXP 79
87960: PUSH
87961: LD_VAR 0 3
87965: ARRAY
87966: PUSH
87967: LD_VAR 0 1
87971: DIFF
87972: PPUSH
87973: CALL_OW 1
87977: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
87978: LD_VAR 0 1
87982: PUSH
87983: LD_EXP 80
87987: PUSH
87988: LD_VAR 0 3
87992: ARRAY
87993: IN
87994: IFFALSE 88018
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87996: LD_ADDR_EXP 80
88000: PUSH
88001: LD_EXP 80
88005: PPUSH
88006: LD_VAR 0 3
88010: PPUSH
88011: EMPTY
88012: PPUSH
88013: CALL_OW 1
88017: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
88018: LD_VAR 0 1
88022: PPUSH
88023: CALL_OW 247
88027: PUSH
88028: LD_INT 2
88030: EQUAL
88031: PUSH
88032: LD_VAR 0 1
88036: PPUSH
88037: CALL_OW 110
88041: PUSH
88042: LD_INT 20
88044: EQUAL
88045: PUSH
88046: LD_VAR 0 1
88050: PUSH
88051: LD_EXP 72
88055: PUSH
88056: LD_VAR 0 3
88060: ARRAY
88061: IN
88062: OR
88063: PUSH
88064: LD_VAR 0 1
88068: PPUSH
88069: CALL_OW 264
88073: PUSH
88074: LD_INT 12
88076: PUSH
88077: LD_INT 51
88079: PUSH
88080: LD_EXP 30
88084: PUSH
88085: LD_INT 32
88087: PUSH
88088: LD_INT 13
88090: PUSH
88091: LD_INT 52
88093: PUSH
88094: LD_INT 31
88096: PUSH
88097: EMPTY
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: IN
88106: OR
88107: AND
88108: IFFALSE 88416
// begin if un in mc_defender [ i ] then
88110: LD_VAR 0 1
88114: PUSH
88115: LD_EXP 72
88119: PUSH
88120: LD_VAR 0 3
88124: ARRAY
88125: IN
88126: IFFALSE 88165
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
88128: LD_ADDR_EXP 72
88132: PUSH
88133: LD_EXP 72
88137: PPUSH
88138: LD_VAR 0 3
88142: PPUSH
88143: LD_EXP 72
88147: PUSH
88148: LD_VAR 0 3
88152: ARRAY
88153: PUSH
88154: LD_VAR 0 1
88158: DIFF
88159: PPUSH
88160: CALL_OW 1
88164: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
88165: LD_ADDR_VAR 0 8
88169: PUSH
88170: LD_VAR 0 3
88174: PPUSH
88175: LD_INT 3
88177: PPUSH
88178: CALL 84806 0 2
88182: ST_TO_ADDR
// if fac then
88183: LD_VAR 0 8
88187: IFFALSE 88416
// begin for j in fac do
88189: LD_ADDR_VAR 0 4
88193: PUSH
88194: LD_VAR 0 8
88198: PUSH
88199: FOR_IN
88200: IFFALSE 88414
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
88202: LD_ADDR_VAR 0 9
88206: PUSH
88207: LD_VAR 0 8
88211: PPUSH
88212: LD_VAR 0 1
88216: PPUSH
88217: CALL_OW 265
88221: PPUSH
88222: LD_VAR 0 1
88226: PPUSH
88227: CALL_OW 262
88231: PPUSH
88232: LD_VAR 0 1
88236: PPUSH
88237: CALL_OW 263
88241: PPUSH
88242: LD_VAR 0 1
88246: PPUSH
88247: CALL_OW 264
88251: PPUSH
88252: CALL 22354 0 5
88256: ST_TO_ADDR
// if components then
88257: LD_VAR 0 9
88261: IFFALSE 88412
// begin if GetWeapon ( un ) = ar_control_tower then
88263: LD_VAR 0 1
88267: PPUSH
88268: CALL_OW 264
88272: PUSH
88273: LD_INT 31
88275: EQUAL
88276: IFFALSE 88393
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
88278: LD_VAR 0 1
88282: PPUSH
88283: CALL_OW 311
88287: PPUSH
88288: LD_INT 0
88290: PPUSH
88291: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
88295: LD_ADDR_EXP 90
88299: PUSH
88300: LD_EXP 90
88304: PPUSH
88305: LD_VAR 0 3
88309: PPUSH
88310: LD_EXP 90
88314: PUSH
88315: LD_VAR 0 3
88319: ARRAY
88320: PUSH
88321: LD_VAR 0 1
88325: PPUSH
88326: CALL_OW 311
88330: DIFF
88331: PPUSH
88332: CALL_OW 1
88336: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
88337: LD_ADDR_VAR 0 7
88341: PUSH
88342: LD_EXP 71
88346: PUSH
88347: LD_VAR 0 3
88351: ARRAY
88352: PPUSH
88353: LD_INT 1
88355: PPUSH
88356: LD_VAR 0 9
88360: PPUSH
88361: CALL_OW 2
88365: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
88366: LD_ADDR_EXP 71
88370: PUSH
88371: LD_EXP 71
88375: PPUSH
88376: LD_VAR 0 3
88380: PPUSH
88381: LD_VAR 0 7
88385: PPUSH
88386: CALL_OW 1
88390: ST_TO_ADDR
// end else
88391: GO 88410
// MC_InsertProduceList ( i , [ components ] ) ;
88393: LD_VAR 0 3
88397: PPUSH
88398: LD_VAR 0 9
88402: PUSH
88403: EMPTY
88404: LIST
88405: PPUSH
88406: CALL 84351 0 2
// break ;
88410: GO 88414
// end ; end ;
88412: GO 88199
88414: POP
88415: POP
// end ; end ; if GetType ( un ) = unit_building then
88416: LD_VAR 0 1
88420: PPUSH
88421: CALL_OW 247
88425: PUSH
88426: LD_INT 3
88428: EQUAL
88429: IFFALSE 88832
// begin btype := GetBType ( un ) ;
88431: LD_ADDR_VAR 0 5
88435: PUSH
88436: LD_VAR 0 1
88440: PPUSH
88441: CALL_OW 266
88445: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
88446: LD_VAR 0 5
88450: PUSH
88451: LD_INT 29
88453: PUSH
88454: LD_INT 30
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: IN
88461: IFFALSE 88534
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
88463: LD_VAR 0 1
88467: PPUSH
88468: CALL_OW 250
88472: PPUSH
88473: LD_VAR 0 1
88477: PPUSH
88478: CALL_OW 251
88482: PPUSH
88483: LD_VAR 0 1
88487: PPUSH
88488: CALL_OW 255
88492: PPUSH
88493: CALL_OW 440
88497: NOT
88498: IFFALSE 88534
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
88500: LD_VAR 0 1
88504: PPUSH
88505: CALL_OW 250
88509: PPUSH
88510: LD_VAR 0 1
88514: PPUSH
88515: CALL_OW 251
88519: PPUSH
88520: LD_VAR 0 1
88524: PPUSH
88525: CALL_OW 255
88529: PPUSH
88530: CALL_OW 441
// end ; if btype = b_warehouse then
88534: LD_VAR 0 5
88538: PUSH
88539: LD_INT 1
88541: EQUAL
88542: IFFALSE 88560
// begin btype := b_depot ;
88544: LD_ADDR_VAR 0 5
88548: PUSH
88549: LD_INT 0
88551: ST_TO_ADDR
// pos := 1 ;
88552: LD_ADDR_VAR 0 6
88556: PUSH
88557: LD_INT 1
88559: ST_TO_ADDR
// end ; if btype = b_factory then
88560: LD_VAR 0 5
88564: PUSH
88565: LD_INT 3
88567: EQUAL
88568: IFFALSE 88586
// begin btype := b_workshop ;
88570: LD_ADDR_VAR 0 5
88574: PUSH
88575: LD_INT 2
88577: ST_TO_ADDR
// pos := 1 ;
88578: LD_ADDR_VAR 0 6
88582: PUSH
88583: LD_INT 1
88585: ST_TO_ADDR
// end ; if btype = b_barracks then
88586: LD_VAR 0 5
88590: PUSH
88591: LD_INT 5
88593: EQUAL
88594: IFFALSE 88604
// btype := b_armoury ;
88596: LD_ADDR_VAR 0 5
88600: PUSH
88601: LD_INT 4
88603: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
88604: LD_VAR 0 5
88608: PUSH
88609: LD_INT 7
88611: PUSH
88612: LD_INT 8
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: IN
88619: IFFALSE 88629
// btype := b_lab ;
88621: LD_ADDR_VAR 0 5
88625: PUSH
88626: LD_INT 6
88628: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
88629: LD_ADDR_EXP 55
88633: PUSH
88634: LD_EXP 55
88638: PPUSH
88639: LD_VAR 0 3
88643: PUSH
88644: LD_EXP 55
88648: PUSH
88649: LD_VAR 0 3
88653: ARRAY
88654: PUSH
88655: LD_INT 1
88657: PLUS
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PPUSH
88663: LD_VAR 0 5
88667: PUSH
88668: LD_VAR 0 1
88672: PPUSH
88673: CALL_OW 250
88677: PUSH
88678: LD_VAR 0 1
88682: PPUSH
88683: CALL_OW 251
88687: PUSH
88688: LD_VAR 0 1
88692: PPUSH
88693: CALL_OW 254
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: PPUSH
88704: CALL 24858 0 3
88708: ST_TO_ADDR
// if pos = 1 then
88709: LD_VAR 0 6
88713: PUSH
88714: LD_INT 1
88716: EQUAL
88717: IFFALSE 88832
// begin tmp := mc_build_list [ i ] ;
88719: LD_ADDR_VAR 0 7
88723: PUSH
88724: LD_EXP 55
88728: PUSH
88729: LD_VAR 0 3
88733: ARRAY
88734: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
88735: LD_VAR 0 7
88739: PPUSH
88740: LD_INT 2
88742: PUSH
88743: LD_INT 30
88745: PUSH
88746: LD_INT 0
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 30
88755: PUSH
88756: LD_INT 1
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: LIST
88767: PPUSH
88768: CALL_OW 72
88772: IFFALSE 88782
// pos := 2 ;
88774: LD_ADDR_VAR 0 6
88778: PUSH
88779: LD_INT 2
88781: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
88782: LD_ADDR_VAR 0 7
88786: PUSH
88787: LD_VAR 0 7
88791: PPUSH
88792: LD_VAR 0 6
88796: PPUSH
88797: LD_VAR 0 7
88801: PPUSH
88802: CALL 25184 0 3
88806: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
88807: LD_ADDR_EXP 55
88811: PUSH
88812: LD_EXP 55
88816: PPUSH
88817: LD_VAR 0 3
88821: PPUSH
88822: LD_VAR 0 7
88826: PPUSH
88827: CALL_OW 1
88831: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
88832: LD_VAR 0 1
88836: PUSH
88837: LD_EXP 50
88841: PUSH
88842: LD_VAR 0 3
88846: ARRAY
88847: IN
88848: IFFALSE 88887
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
88850: LD_ADDR_EXP 50
88854: PUSH
88855: LD_EXP 50
88859: PPUSH
88860: LD_VAR 0 3
88864: PPUSH
88865: LD_EXP 50
88869: PUSH
88870: LD_VAR 0 3
88874: ARRAY
88875: PUSH
88876: LD_VAR 0 1
88880: DIFF
88881: PPUSH
88882: CALL_OW 1
88886: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
88887: LD_VAR 0 1
88891: PUSH
88892: LD_EXP 57
88896: PUSH
88897: LD_VAR 0 3
88901: ARRAY
88902: IN
88903: IFFALSE 88942
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
88905: LD_ADDR_EXP 57
88909: PUSH
88910: LD_EXP 57
88914: PPUSH
88915: LD_VAR 0 3
88919: PPUSH
88920: LD_EXP 57
88924: PUSH
88925: LD_VAR 0 3
88929: ARRAY
88930: PUSH
88931: LD_VAR 0 1
88935: DIFF
88936: PPUSH
88937: CALL_OW 1
88941: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
88942: LD_VAR 0 1
88946: PUSH
88947: LD_EXP 69
88951: PUSH
88952: LD_VAR 0 3
88956: ARRAY
88957: IN
88958: IFFALSE 88997
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
88960: LD_ADDR_EXP 69
88964: PUSH
88965: LD_EXP 69
88969: PPUSH
88970: LD_VAR 0 3
88974: PPUSH
88975: LD_EXP 69
88979: PUSH
88980: LD_VAR 0 3
88984: ARRAY
88985: PUSH
88986: LD_VAR 0 1
88990: DIFF
88991: PPUSH
88992: CALL_OW 1
88996: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
88997: LD_VAR 0 1
89001: PUSH
89002: LD_EXP 72
89006: PUSH
89007: LD_VAR 0 3
89011: ARRAY
89012: IN
89013: IFFALSE 89052
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89015: LD_ADDR_EXP 72
89019: PUSH
89020: LD_EXP 72
89024: PPUSH
89025: LD_VAR 0 3
89029: PPUSH
89030: LD_EXP 72
89034: PUSH
89035: LD_VAR 0 3
89039: ARRAY
89040: PUSH
89041: LD_VAR 0 1
89045: DIFF
89046: PPUSH
89047: CALL_OW 1
89051: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
89052: LD_VAR 0 1
89056: PUSH
89057: LD_EXP 59
89061: PUSH
89062: LD_VAR 0 3
89066: ARRAY
89067: IN
89068: IFFALSE 89107
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
89070: LD_ADDR_EXP 59
89074: PUSH
89075: LD_EXP 59
89079: PPUSH
89080: LD_VAR 0 3
89084: PPUSH
89085: LD_EXP 59
89089: PUSH
89090: LD_VAR 0 3
89094: ARRAY
89095: PUSH
89096: LD_VAR 0 1
89100: DIFF
89101: PPUSH
89102: CALL_OW 1
89106: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
89107: LD_VAR 0 1
89111: PUSH
89112: LD_EXP 58
89116: PUSH
89117: LD_VAR 0 3
89121: ARRAY
89122: IN
89123: IFFALSE 89162
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
89125: LD_ADDR_EXP 58
89129: PUSH
89130: LD_EXP 58
89134: PPUSH
89135: LD_VAR 0 3
89139: PPUSH
89140: LD_EXP 58
89144: PUSH
89145: LD_VAR 0 3
89149: ARRAY
89150: PUSH
89151: LD_VAR 0 1
89155: DIFF
89156: PPUSH
89157: CALL_OW 1
89161: ST_TO_ADDR
// end ; break ;
89162: GO 89166
// end ;
89164: GO 87812
89166: POP
89167: POP
// end ;
89168: LD_VAR 0 2
89172: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
89173: LD_INT 0
89175: PPUSH
89176: PPUSH
89177: PPUSH
// if not mc_bases or not skirmish then
89178: LD_EXP 50
89182: NOT
89183: PUSH
89184: LD_EXP 48
89188: NOT
89189: OR
89190: IFFALSE 89194
// exit ;
89192: GO 89409
// for i = 1 to mc_bases do
89194: LD_ADDR_VAR 0 3
89198: PUSH
89199: DOUBLE
89200: LD_INT 1
89202: DEC
89203: ST_TO_ADDR
89204: LD_EXP 50
89208: PUSH
89209: FOR_TO
89210: IFFALSE 89407
// begin if building in mc_construct_list [ i ] then
89212: LD_VAR 0 1
89216: PUSH
89217: LD_EXP 57
89221: PUSH
89222: LD_VAR 0 3
89226: ARRAY
89227: IN
89228: IFFALSE 89405
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
89230: LD_ADDR_EXP 57
89234: PUSH
89235: LD_EXP 57
89239: PPUSH
89240: LD_VAR 0 3
89244: PPUSH
89245: LD_EXP 57
89249: PUSH
89250: LD_VAR 0 3
89254: ARRAY
89255: PUSH
89256: LD_VAR 0 1
89260: DIFF
89261: PPUSH
89262: CALL_OW 1
89266: ST_TO_ADDR
// if building in mc_lab [ i ] then
89267: LD_VAR 0 1
89271: PUSH
89272: LD_EXP 83
89276: PUSH
89277: LD_VAR 0 3
89281: ARRAY
89282: IN
89283: IFFALSE 89338
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
89285: LD_ADDR_EXP 84
89289: PUSH
89290: LD_EXP 84
89294: PPUSH
89295: LD_VAR 0 3
89299: PPUSH
89300: LD_EXP 84
89304: PUSH
89305: LD_VAR 0 3
89309: ARRAY
89310: PPUSH
89311: LD_INT 1
89313: PPUSH
89314: LD_EXP 84
89318: PUSH
89319: LD_VAR 0 3
89323: ARRAY
89324: PPUSH
89325: LD_INT 0
89327: PPUSH
89328: CALL 24276 0 4
89332: PPUSH
89333: CALL_OW 1
89337: ST_TO_ADDR
// if not building in mc_bases [ i ] then
89338: LD_VAR 0 1
89342: PUSH
89343: LD_EXP 50
89347: PUSH
89348: LD_VAR 0 3
89352: ARRAY
89353: IN
89354: NOT
89355: IFFALSE 89401
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
89357: LD_ADDR_EXP 50
89361: PUSH
89362: LD_EXP 50
89366: PPUSH
89367: LD_VAR 0 3
89371: PUSH
89372: LD_EXP 50
89376: PUSH
89377: LD_VAR 0 3
89381: ARRAY
89382: PUSH
89383: LD_INT 1
89385: PLUS
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PPUSH
89391: LD_VAR 0 1
89395: PPUSH
89396: CALL 24858 0 3
89400: ST_TO_ADDR
// exit ;
89401: POP
89402: POP
89403: GO 89409
// end ; end ;
89405: GO 89209
89407: POP
89408: POP
// end ;
89409: LD_VAR 0 2
89413: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
89414: LD_INT 0
89416: PPUSH
89417: PPUSH
89418: PPUSH
89419: PPUSH
89420: PPUSH
89421: PPUSH
89422: PPUSH
// if not mc_bases or not skirmish then
89423: LD_EXP 50
89427: NOT
89428: PUSH
89429: LD_EXP 48
89433: NOT
89434: OR
89435: IFFALSE 89439
// exit ;
89437: GO 90100
// for i = 1 to mc_bases do
89439: LD_ADDR_VAR 0 3
89443: PUSH
89444: DOUBLE
89445: LD_INT 1
89447: DEC
89448: ST_TO_ADDR
89449: LD_EXP 50
89453: PUSH
89454: FOR_TO
89455: IFFALSE 90098
// begin if building in mc_construct_list [ i ] then
89457: LD_VAR 0 1
89461: PUSH
89462: LD_EXP 57
89466: PUSH
89467: LD_VAR 0 3
89471: ARRAY
89472: IN
89473: IFFALSE 90096
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
89475: LD_ADDR_EXP 57
89479: PUSH
89480: LD_EXP 57
89484: PPUSH
89485: LD_VAR 0 3
89489: PPUSH
89490: LD_EXP 57
89494: PUSH
89495: LD_VAR 0 3
89499: ARRAY
89500: PUSH
89501: LD_VAR 0 1
89505: DIFF
89506: PPUSH
89507: CALL_OW 1
89511: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
89512: LD_ADDR_EXP 50
89516: PUSH
89517: LD_EXP 50
89521: PPUSH
89522: LD_VAR 0 3
89526: PUSH
89527: LD_EXP 50
89531: PUSH
89532: LD_VAR 0 3
89536: ARRAY
89537: PUSH
89538: LD_INT 1
89540: PLUS
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: PPUSH
89546: LD_VAR 0 1
89550: PPUSH
89551: CALL 24858 0 3
89555: ST_TO_ADDR
// btype := GetBType ( building ) ;
89556: LD_ADDR_VAR 0 5
89560: PUSH
89561: LD_VAR 0 1
89565: PPUSH
89566: CALL_OW 266
89570: ST_TO_ADDR
// side := GetSide ( building ) ;
89571: LD_ADDR_VAR 0 8
89575: PUSH
89576: LD_VAR 0 1
89580: PPUSH
89581: CALL_OW 255
89585: ST_TO_ADDR
// if btype = b_lab then
89586: LD_VAR 0 5
89590: PUSH
89591: LD_INT 6
89593: EQUAL
89594: IFFALSE 89644
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
89596: LD_ADDR_EXP 83
89600: PUSH
89601: LD_EXP 83
89605: PPUSH
89606: LD_VAR 0 3
89610: PUSH
89611: LD_EXP 83
89615: PUSH
89616: LD_VAR 0 3
89620: ARRAY
89621: PUSH
89622: LD_INT 1
89624: PLUS
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: PPUSH
89630: LD_VAR 0 1
89634: PPUSH
89635: CALL 24858 0 3
89639: ST_TO_ADDR
// exit ;
89640: POP
89641: POP
89642: GO 90100
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
89644: LD_VAR 0 5
89648: PUSH
89649: LD_INT 0
89651: PUSH
89652: LD_INT 2
89654: PUSH
89655: LD_INT 4
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: LIST
89662: IN
89663: IFFALSE 89787
// begin if btype = b_armoury then
89665: LD_VAR 0 5
89669: PUSH
89670: LD_INT 4
89672: EQUAL
89673: IFFALSE 89683
// btype := b_barracks ;
89675: LD_ADDR_VAR 0 5
89679: PUSH
89680: LD_INT 5
89682: ST_TO_ADDR
// if btype = b_depot then
89683: LD_VAR 0 5
89687: PUSH
89688: LD_INT 0
89690: EQUAL
89691: IFFALSE 89701
// btype := b_warehouse ;
89693: LD_ADDR_VAR 0 5
89697: PUSH
89698: LD_INT 1
89700: ST_TO_ADDR
// if btype = b_workshop then
89701: LD_VAR 0 5
89705: PUSH
89706: LD_INT 2
89708: EQUAL
89709: IFFALSE 89719
// btype := b_factory ;
89711: LD_ADDR_VAR 0 5
89715: PUSH
89716: LD_INT 3
89718: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
89719: LD_VAR 0 5
89723: PPUSH
89724: LD_VAR 0 8
89728: PPUSH
89729: CALL_OW 323
89733: PUSH
89734: LD_INT 1
89736: EQUAL
89737: IFFALSE 89783
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
89739: LD_ADDR_EXP 82
89743: PUSH
89744: LD_EXP 82
89748: PPUSH
89749: LD_VAR 0 3
89753: PUSH
89754: LD_EXP 82
89758: PUSH
89759: LD_VAR 0 3
89763: ARRAY
89764: PUSH
89765: LD_INT 1
89767: PLUS
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: PPUSH
89773: LD_VAR 0 1
89777: PPUSH
89778: CALL 24858 0 3
89782: ST_TO_ADDR
// exit ;
89783: POP
89784: POP
89785: GO 90100
// end ; if btype in [ b_bunker , b_turret ] then
89787: LD_VAR 0 5
89791: PUSH
89792: LD_INT 32
89794: PUSH
89795: LD_INT 33
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: IN
89802: IFFALSE 90092
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
89804: LD_ADDR_EXP 58
89808: PUSH
89809: LD_EXP 58
89813: PPUSH
89814: LD_VAR 0 3
89818: PUSH
89819: LD_EXP 58
89823: PUSH
89824: LD_VAR 0 3
89828: ARRAY
89829: PUSH
89830: LD_INT 1
89832: PLUS
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: PPUSH
89838: LD_VAR 0 1
89842: PPUSH
89843: CALL 24858 0 3
89847: ST_TO_ADDR
// if btype = b_bunker then
89848: LD_VAR 0 5
89852: PUSH
89853: LD_INT 32
89855: EQUAL
89856: IFFALSE 90092
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89858: LD_ADDR_EXP 59
89862: PUSH
89863: LD_EXP 59
89867: PPUSH
89868: LD_VAR 0 3
89872: PUSH
89873: LD_EXP 59
89877: PUSH
89878: LD_VAR 0 3
89882: ARRAY
89883: PUSH
89884: LD_INT 1
89886: PLUS
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PPUSH
89892: LD_VAR 0 1
89896: PPUSH
89897: CALL 24858 0 3
89901: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
89902: LD_ADDR_VAR 0 6
89906: PUSH
89907: LD_EXP 50
89911: PUSH
89912: LD_VAR 0 3
89916: ARRAY
89917: PPUSH
89918: LD_INT 25
89920: PUSH
89921: LD_INT 1
89923: PUSH
89924: EMPTY
89925: LIST
89926: LIST
89927: PUSH
89928: LD_INT 3
89930: PUSH
89931: LD_INT 54
89933: PUSH
89934: EMPTY
89935: LIST
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: PUSH
89941: EMPTY
89942: LIST
89943: LIST
89944: PPUSH
89945: CALL_OW 72
89949: ST_TO_ADDR
// if tmp then
89950: LD_VAR 0 6
89954: IFFALSE 89960
// exit ;
89956: POP
89957: POP
89958: GO 90100
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
89960: LD_ADDR_VAR 0 6
89964: PUSH
89965: LD_EXP 50
89969: PUSH
89970: LD_VAR 0 3
89974: ARRAY
89975: PPUSH
89976: LD_INT 2
89978: PUSH
89979: LD_INT 30
89981: PUSH
89982: LD_INT 4
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: PUSH
89989: LD_INT 30
89991: PUSH
89992: LD_INT 5
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: LIST
90003: PPUSH
90004: CALL_OW 72
90008: ST_TO_ADDR
// if not tmp then
90009: LD_VAR 0 6
90013: NOT
90014: IFFALSE 90020
// exit ;
90016: POP
90017: POP
90018: GO 90100
// for j in tmp do
90020: LD_ADDR_VAR 0 4
90024: PUSH
90025: LD_VAR 0 6
90029: PUSH
90030: FOR_IN
90031: IFFALSE 90090
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
90033: LD_ADDR_VAR 0 7
90037: PUSH
90038: LD_VAR 0 4
90042: PPUSH
90043: CALL_OW 313
90047: PPUSH
90048: LD_INT 25
90050: PUSH
90051: LD_INT 1
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: PPUSH
90058: CALL_OW 72
90062: ST_TO_ADDR
// if units then
90063: LD_VAR 0 7
90067: IFFALSE 90088
// begin ComExitBuilding ( units [ 1 ] ) ;
90069: LD_VAR 0 7
90073: PUSH
90074: LD_INT 1
90076: ARRAY
90077: PPUSH
90078: CALL_OW 122
// exit ;
90082: POP
90083: POP
90084: POP
90085: POP
90086: GO 90100
// end ; end ;
90088: GO 90030
90090: POP
90091: POP
// end ; end ; exit ;
90092: POP
90093: POP
90094: GO 90100
// end ; end ;
90096: GO 89454
90098: POP
90099: POP
// end ;
90100: LD_VAR 0 2
90104: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
90105: LD_INT 0
90107: PPUSH
90108: PPUSH
90109: PPUSH
90110: PPUSH
90111: PPUSH
90112: PPUSH
90113: PPUSH
// if not mc_bases or not skirmish then
90114: LD_EXP 50
90118: NOT
90119: PUSH
90120: LD_EXP 48
90124: NOT
90125: OR
90126: IFFALSE 90130
// exit ;
90128: GO 90395
// btype := GetBType ( building ) ;
90130: LD_ADDR_VAR 0 6
90134: PUSH
90135: LD_VAR 0 1
90139: PPUSH
90140: CALL_OW 266
90144: ST_TO_ADDR
// x := GetX ( building ) ;
90145: LD_ADDR_VAR 0 7
90149: PUSH
90150: LD_VAR 0 1
90154: PPUSH
90155: CALL_OW 250
90159: ST_TO_ADDR
// y := GetY ( building ) ;
90160: LD_ADDR_VAR 0 8
90164: PUSH
90165: LD_VAR 0 1
90169: PPUSH
90170: CALL_OW 251
90174: ST_TO_ADDR
// d := GetDir ( building ) ;
90175: LD_ADDR_VAR 0 9
90179: PUSH
90180: LD_VAR 0 1
90184: PPUSH
90185: CALL_OW 254
90189: ST_TO_ADDR
// for i = 1 to mc_bases do
90190: LD_ADDR_VAR 0 4
90194: PUSH
90195: DOUBLE
90196: LD_INT 1
90198: DEC
90199: ST_TO_ADDR
90200: LD_EXP 50
90204: PUSH
90205: FOR_TO
90206: IFFALSE 90393
// begin if not mc_build_list [ i ] then
90208: LD_EXP 55
90212: PUSH
90213: LD_VAR 0 4
90217: ARRAY
90218: NOT
90219: IFFALSE 90223
// continue ;
90221: GO 90205
// for j := 1 to mc_build_list [ i ] do
90223: LD_ADDR_VAR 0 5
90227: PUSH
90228: DOUBLE
90229: LD_INT 1
90231: DEC
90232: ST_TO_ADDR
90233: LD_EXP 55
90237: PUSH
90238: LD_VAR 0 4
90242: ARRAY
90243: PUSH
90244: FOR_TO
90245: IFFALSE 90389
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
90247: LD_VAR 0 6
90251: PUSH
90252: LD_VAR 0 7
90256: PUSH
90257: LD_VAR 0 8
90261: PUSH
90262: LD_VAR 0 9
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: PPUSH
90273: LD_EXP 55
90277: PUSH
90278: LD_VAR 0 4
90282: ARRAY
90283: PUSH
90284: LD_VAR 0 5
90288: ARRAY
90289: PPUSH
90290: CALL 31040 0 2
90294: IFFALSE 90387
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
90296: LD_ADDR_EXP 55
90300: PUSH
90301: LD_EXP 55
90305: PPUSH
90306: LD_VAR 0 4
90310: PPUSH
90311: LD_EXP 55
90315: PUSH
90316: LD_VAR 0 4
90320: ARRAY
90321: PPUSH
90322: LD_VAR 0 5
90326: PPUSH
90327: CALL_OW 3
90331: PPUSH
90332: CALL_OW 1
90336: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
90337: LD_ADDR_EXP 57
90341: PUSH
90342: LD_EXP 57
90346: PPUSH
90347: LD_VAR 0 4
90351: PUSH
90352: LD_EXP 57
90356: PUSH
90357: LD_VAR 0 4
90361: ARRAY
90362: PUSH
90363: LD_INT 1
90365: PLUS
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PPUSH
90371: LD_VAR 0 1
90375: PPUSH
90376: CALL 24858 0 3
90380: ST_TO_ADDR
// exit ;
90381: POP
90382: POP
90383: POP
90384: POP
90385: GO 90395
// end ;
90387: GO 90244
90389: POP
90390: POP
// end ;
90391: GO 90205
90393: POP
90394: POP
// end ;
90395: LD_VAR 0 3
90399: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
90400: LD_INT 0
90402: PPUSH
90403: PPUSH
90404: PPUSH
// if not mc_bases or not skirmish then
90405: LD_EXP 50
90409: NOT
90410: PUSH
90411: LD_EXP 48
90415: NOT
90416: OR
90417: IFFALSE 90421
// exit ;
90419: GO 90611
// for i = 1 to mc_bases do
90421: LD_ADDR_VAR 0 4
90425: PUSH
90426: DOUBLE
90427: LD_INT 1
90429: DEC
90430: ST_TO_ADDR
90431: LD_EXP 50
90435: PUSH
90436: FOR_TO
90437: IFFALSE 90524
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
90439: LD_VAR 0 1
90443: PUSH
90444: LD_EXP 58
90448: PUSH
90449: LD_VAR 0 4
90453: ARRAY
90454: IN
90455: PUSH
90456: LD_VAR 0 1
90460: PUSH
90461: LD_EXP 59
90465: PUSH
90466: LD_VAR 0 4
90470: ARRAY
90471: IN
90472: NOT
90473: AND
90474: IFFALSE 90522
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
90476: LD_ADDR_EXP 59
90480: PUSH
90481: LD_EXP 59
90485: PPUSH
90486: LD_VAR 0 4
90490: PUSH
90491: LD_EXP 59
90495: PUSH
90496: LD_VAR 0 4
90500: ARRAY
90501: PUSH
90502: LD_INT 1
90504: PLUS
90505: PUSH
90506: EMPTY
90507: LIST
90508: LIST
90509: PPUSH
90510: LD_VAR 0 1
90514: PPUSH
90515: CALL 24858 0 3
90519: ST_TO_ADDR
// break ;
90520: GO 90524
// end ; end ;
90522: GO 90436
90524: POP
90525: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
90526: LD_VAR 0 1
90530: PPUSH
90531: CALL_OW 257
90535: PUSH
90536: LD_EXP 76
90540: IN
90541: PUSH
90542: LD_VAR 0 1
90546: PPUSH
90547: CALL_OW 266
90551: PUSH
90552: LD_INT 5
90554: EQUAL
90555: AND
90556: PUSH
90557: LD_VAR 0 2
90561: PPUSH
90562: CALL_OW 110
90566: PUSH
90567: LD_INT 18
90569: NONEQUAL
90570: AND
90571: IFFALSE 90611
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
90573: LD_VAR 0 2
90577: PPUSH
90578: CALL_OW 257
90582: PUSH
90583: LD_INT 5
90585: PUSH
90586: LD_INT 8
90588: PUSH
90589: LD_INT 9
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: LIST
90596: IN
90597: IFFALSE 90611
// SetClass ( unit , 1 ) ;
90599: LD_VAR 0 2
90603: PPUSH
90604: LD_INT 1
90606: PPUSH
90607: CALL_OW 336
// end ;
90611: LD_VAR 0 3
90615: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
90616: LD_INT 0
90618: PPUSH
90619: PPUSH
// if not mc_bases or not skirmish then
90620: LD_EXP 50
90624: NOT
90625: PUSH
90626: LD_EXP 48
90630: NOT
90631: OR
90632: IFFALSE 90636
// exit ;
90634: GO 90752
// if GetLives ( abandoned_vehicle ) > 250 then
90636: LD_VAR 0 2
90640: PPUSH
90641: CALL_OW 256
90645: PUSH
90646: LD_INT 250
90648: GREATER
90649: IFFALSE 90653
// exit ;
90651: GO 90752
// for i = 1 to mc_bases do
90653: LD_ADDR_VAR 0 6
90657: PUSH
90658: DOUBLE
90659: LD_INT 1
90661: DEC
90662: ST_TO_ADDR
90663: LD_EXP 50
90667: PUSH
90668: FOR_TO
90669: IFFALSE 90750
// begin if driver in mc_bases [ i ] then
90671: LD_VAR 0 1
90675: PUSH
90676: LD_EXP 50
90680: PUSH
90681: LD_VAR 0 6
90685: ARRAY
90686: IN
90687: IFFALSE 90748
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
90689: LD_VAR 0 1
90693: PPUSH
90694: LD_EXP 50
90698: PUSH
90699: LD_VAR 0 6
90703: ARRAY
90704: PPUSH
90705: LD_INT 2
90707: PUSH
90708: LD_INT 30
90710: PUSH
90711: LD_INT 0
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: PUSH
90718: LD_INT 30
90720: PUSH
90721: LD_INT 1
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: EMPTY
90729: LIST
90730: LIST
90731: LIST
90732: PPUSH
90733: CALL_OW 72
90737: PUSH
90738: LD_INT 1
90740: ARRAY
90741: PPUSH
90742: CALL 57476 0 2
// break ;
90746: GO 90750
// end ; end ;
90748: GO 90668
90750: POP
90751: POP
// end ; end_of_file end_of_file
90752: LD_VAR 0 5
90756: RET
// every 0 0$1 do
90757: GO 90759
90759: DISABLE
// begin enable ;
90760: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90761: LD_STRING updateTimer(
90763: PUSH
90764: LD_OWVAR 1
90768: STR
90769: PUSH
90770: LD_STRING );
90772: STR
90773: PPUSH
90774: CALL_OW 559
// end ;
90778: END
// on MapStart ( p ) do begin if streamModeActive then
90779: LD_EXP 94
90783: IFFALSE 90792
// DefineStreamItems ( true ) ;
90785: LD_INT 1
90787: PPUSH
90788: CALL 92440 0 1
// UpdateFactoryWaypoints ( ) ;
90792: CALL 106024 0 0
// end ;
90796: PPOPN 1
90798: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90799: LD_INT 0
90801: PPUSH
// if p2 = 100 then
90802: LD_VAR 0 2
90806: PUSH
90807: LD_INT 100
90809: EQUAL
90810: IFFALSE 91813
// begin if not StreamModeActive then
90812: LD_EXP 94
90816: NOT
90817: IFFALSE 90827
// StreamModeActive := true ;
90819: LD_ADDR_EXP 94
90823: PUSH
90824: LD_INT 1
90826: ST_TO_ADDR
// if p3 = 0 then
90827: LD_VAR 0 3
90831: PUSH
90832: LD_INT 0
90834: EQUAL
90835: IFFALSE 90841
// InitStreamMode ;
90837: CALL 91976 0 0
// if p3 = 1 then
90841: LD_VAR 0 3
90845: PUSH
90846: LD_INT 1
90848: EQUAL
90849: IFFALSE 90859
// sRocket := true ;
90851: LD_ADDR_EXP 99
90855: PUSH
90856: LD_INT 1
90858: ST_TO_ADDR
// if p3 = 2 then
90859: LD_VAR 0 3
90863: PUSH
90864: LD_INT 2
90866: EQUAL
90867: IFFALSE 90877
// sSpeed := true ;
90869: LD_ADDR_EXP 98
90873: PUSH
90874: LD_INT 1
90876: ST_TO_ADDR
// if p3 = 3 then
90877: LD_VAR 0 3
90881: PUSH
90882: LD_INT 3
90884: EQUAL
90885: IFFALSE 90895
// sEngine := true ;
90887: LD_ADDR_EXP 100
90891: PUSH
90892: LD_INT 1
90894: ST_TO_ADDR
// if p3 = 4 then
90895: LD_VAR 0 3
90899: PUSH
90900: LD_INT 4
90902: EQUAL
90903: IFFALSE 90913
// sSpec := true ;
90905: LD_ADDR_EXP 97
90909: PUSH
90910: LD_INT 1
90912: ST_TO_ADDR
// if p3 = 5 then
90913: LD_VAR 0 3
90917: PUSH
90918: LD_INT 5
90920: EQUAL
90921: IFFALSE 90931
// sLevel := true ;
90923: LD_ADDR_EXP 101
90927: PUSH
90928: LD_INT 1
90930: ST_TO_ADDR
// if p3 = 6 then
90931: LD_VAR 0 3
90935: PUSH
90936: LD_INT 6
90938: EQUAL
90939: IFFALSE 90949
// sArmoury := true ;
90941: LD_ADDR_EXP 102
90945: PUSH
90946: LD_INT 1
90948: ST_TO_ADDR
// if p3 = 7 then
90949: LD_VAR 0 3
90953: PUSH
90954: LD_INT 7
90956: EQUAL
90957: IFFALSE 90967
// sRadar := true ;
90959: LD_ADDR_EXP 103
90963: PUSH
90964: LD_INT 1
90966: ST_TO_ADDR
// if p3 = 8 then
90967: LD_VAR 0 3
90971: PUSH
90972: LD_INT 8
90974: EQUAL
90975: IFFALSE 90985
// sBunker := true ;
90977: LD_ADDR_EXP 104
90981: PUSH
90982: LD_INT 1
90984: ST_TO_ADDR
// if p3 = 9 then
90985: LD_VAR 0 3
90989: PUSH
90990: LD_INT 9
90992: EQUAL
90993: IFFALSE 91003
// sHack := true ;
90995: LD_ADDR_EXP 105
90999: PUSH
91000: LD_INT 1
91002: ST_TO_ADDR
// if p3 = 10 then
91003: LD_VAR 0 3
91007: PUSH
91008: LD_INT 10
91010: EQUAL
91011: IFFALSE 91021
// sFire := true ;
91013: LD_ADDR_EXP 106
91017: PUSH
91018: LD_INT 1
91020: ST_TO_ADDR
// if p3 = 11 then
91021: LD_VAR 0 3
91025: PUSH
91026: LD_INT 11
91028: EQUAL
91029: IFFALSE 91039
// sRefresh := true ;
91031: LD_ADDR_EXP 107
91035: PUSH
91036: LD_INT 1
91038: ST_TO_ADDR
// if p3 = 12 then
91039: LD_VAR 0 3
91043: PUSH
91044: LD_INT 12
91046: EQUAL
91047: IFFALSE 91057
// sExp := true ;
91049: LD_ADDR_EXP 108
91053: PUSH
91054: LD_INT 1
91056: ST_TO_ADDR
// if p3 = 13 then
91057: LD_VAR 0 3
91061: PUSH
91062: LD_INT 13
91064: EQUAL
91065: IFFALSE 91075
// sDepot := true ;
91067: LD_ADDR_EXP 109
91071: PUSH
91072: LD_INT 1
91074: ST_TO_ADDR
// if p3 = 14 then
91075: LD_VAR 0 3
91079: PUSH
91080: LD_INT 14
91082: EQUAL
91083: IFFALSE 91093
// sFlag := true ;
91085: LD_ADDR_EXP 110
91089: PUSH
91090: LD_INT 1
91092: ST_TO_ADDR
// if p3 = 15 then
91093: LD_VAR 0 3
91097: PUSH
91098: LD_INT 15
91100: EQUAL
91101: IFFALSE 91111
// sKamikadze := true ;
91103: LD_ADDR_EXP 118
91107: PUSH
91108: LD_INT 1
91110: ST_TO_ADDR
// if p3 = 16 then
91111: LD_VAR 0 3
91115: PUSH
91116: LD_INT 16
91118: EQUAL
91119: IFFALSE 91129
// sTroll := true ;
91121: LD_ADDR_EXP 119
91125: PUSH
91126: LD_INT 1
91128: ST_TO_ADDR
// if p3 = 17 then
91129: LD_VAR 0 3
91133: PUSH
91134: LD_INT 17
91136: EQUAL
91137: IFFALSE 91147
// sSlow := true ;
91139: LD_ADDR_EXP 120
91143: PUSH
91144: LD_INT 1
91146: ST_TO_ADDR
// if p3 = 18 then
91147: LD_VAR 0 3
91151: PUSH
91152: LD_INT 18
91154: EQUAL
91155: IFFALSE 91165
// sLack := true ;
91157: LD_ADDR_EXP 121
91161: PUSH
91162: LD_INT 1
91164: ST_TO_ADDR
// if p3 = 19 then
91165: LD_VAR 0 3
91169: PUSH
91170: LD_INT 19
91172: EQUAL
91173: IFFALSE 91183
// sTank := true ;
91175: LD_ADDR_EXP 123
91179: PUSH
91180: LD_INT 1
91182: ST_TO_ADDR
// if p3 = 20 then
91183: LD_VAR 0 3
91187: PUSH
91188: LD_INT 20
91190: EQUAL
91191: IFFALSE 91201
// sRemote := true ;
91193: LD_ADDR_EXP 124
91197: PUSH
91198: LD_INT 1
91200: ST_TO_ADDR
// if p3 = 21 then
91201: LD_VAR 0 3
91205: PUSH
91206: LD_INT 21
91208: EQUAL
91209: IFFALSE 91219
// sPowell := true ;
91211: LD_ADDR_EXP 125
91215: PUSH
91216: LD_INT 1
91218: ST_TO_ADDR
// if p3 = 22 then
91219: LD_VAR 0 3
91223: PUSH
91224: LD_INT 22
91226: EQUAL
91227: IFFALSE 91237
// sTeleport := true ;
91229: LD_ADDR_EXP 128
91233: PUSH
91234: LD_INT 1
91236: ST_TO_ADDR
// if p3 = 23 then
91237: LD_VAR 0 3
91241: PUSH
91242: LD_INT 23
91244: EQUAL
91245: IFFALSE 91255
// sOilTower := true ;
91247: LD_ADDR_EXP 130
91251: PUSH
91252: LD_INT 1
91254: ST_TO_ADDR
// if p3 = 24 then
91255: LD_VAR 0 3
91259: PUSH
91260: LD_INT 24
91262: EQUAL
91263: IFFALSE 91273
// sShovel := true ;
91265: LD_ADDR_EXP 131
91269: PUSH
91270: LD_INT 1
91272: ST_TO_ADDR
// if p3 = 25 then
91273: LD_VAR 0 3
91277: PUSH
91278: LD_INT 25
91280: EQUAL
91281: IFFALSE 91291
// sSheik := true ;
91283: LD_ADDR_EXP 132
91287: PUSH
91288: LD_INT 1
91290: ST_TO_ADDR
// if p3 = 26 then
91291: LD_VAR 0 3
91295: PUSH
91296: LD_INT 26
91298: EQUAL
91299: IFFALSE 91309
// sEarthquake := true ;
91301: LD_ADDR_EXP 134
91305: PUSH
91306: LD_INT 1
91308: ST_TO_ADDR
// if p3 = 27 then
91309: LD_VAR 0 3
91313: PUSH
91314: LD_INT 27
91316: EQUAL
91317: IFFALSE 91327
// sAI := true ;
91319: LD_ADDR_EXP 135
91323: PUSH
91324: LD_INT 1
91326: ST_TO_ADDR
// if p3 = 28 then
91327: LD_VAR 0 3
91331: PUSH
91332: LD_INT 28
91334: EQUAL
91335: IFFALSE 91345
// sCargo := true ;
91337: LD_ADDR_EXP 138
91341: PUSH
91342: LD_INT 1
91344: ST_TO_ADDR
// if p3 = 29 then
91345: LD_VAR 0 3
91349: PUSH
91350: LD_INT 29
91352: EQUAL
91353: IFFALSE 91363
// sDLaser := true ;
91355: LD_ADDR_EXP 139
91359: PUSH
91360: LD_INT 1
91362: ST_TO_ADDR
// if p3 = 30 then
91363: LD_VAR 0 3
91367: PUSH
91368: LD_INT 30
91370: EQUAL
91371: IFFALSE 91381
// sExchange := true ;
91373: LD_ADDR_EXP 140
91377: PUSH
91378: LD_INT 1
91380: ST_TO_ADDR
// if p3 = 31 then
91381: LD_VAR 0 3
91385: PUSH
91386: LD_INT 31
91388: EQUAL
91389: IFFALSE 91399
// sFac := true ;
91391: LD_ADDR_EXP 141
91395: PUSH
91396: LD_INT 1
91398: ST_TO_ADDR
// if p3 = 32 then
91399: LD_VAR 0 3
91403: PUSH
91404: LD_INT 32
91406: EQUAL
91407: IFFALSE 91417
// sPower := true ;
91409: LD_ADDR_EXP 142
91413: PUSH
91414: LD_INT 1
91416: ST_TO_ADDR
// if p3 = 33 then
91417: LD_VAR 0 3
91421: PUSH
91422: LD_INT 33
91424: EQUAL
91425: IFFALSE 91435
// sRandom := true ;
91427: LD_ADDR_EXP 143
91431: PUSH
91432: LD_INT 1
91434: ST_TO_ADDR
// if p3 = 34 then
91435: LD_VAR 0 3
91439: PUSH
91440: LD_INT 34
91442: EQUAL
91443: IFFALSE 91453
// sShield := true ;
91445: LD_ADDR_EXP 144
91449: PUSH
91450: LD_INT 1
91452: ST_TO_ADDR
// if p3 = 35 then
91453: LD_VAR 0 3
91457: PUSH
91458: LD_INT 35
91460: EQUAL
91461: IFFALSE 91471
// sTime := true ;
91463: LD_ADDR_EXP 145
91467: PUSH
91468: LD_INT 1
91470: ST_TO_ADDR
// if p3 = 36 then
91471: LD_VAR 0 3
91475: PUSH
91476: LD_INT 36
91478: EQUAL
91479: IFFALSE 91489
// sTools := true ;
91481: LD_ADDR_EXP 146
91485: PUSH
91486: LD_INT 1
91488: ST_TO_ADDR
// if p3 = 101 then
91489: LD_VAR 0 3
91493: PUSH
91494: LD_INT 101
91496: EQUAL
91497: IFFALSE 91507
// sSold := true ;
91499: LD_ADDR_EXP 111
91503: PUSH
91504: LD_INT 1
91506: ST_TO_ADDR
// if p3 = 102 then
91507: LD_VAR 0 3
91511: PUSH
91512: LD_INT 102
91514: EQUAL
91515: IFFALSE 91525
// sDiff := true ;
91517: LD_ADDR_EXP 112
91521: PUSH
91522: LD_INT 1
91524: ST_TO_ADDR
// if p3 = 103 then
91525: LD_VAR 0 3
91529: PUSH
91530: LD_INT 103
91532: EQUAL
91533: IFFALSE 91543
// sFog := true ;
91535: LD_ADDR_EXP 115
91539: PUSH
91540: LD_INT 1
91542: ST_TO_ADDR
// if p3 = 104 then
91543: LD_VAR 0 3
91547: PUSH
91548: LD_INT 104
91550: EQUAL
91551: IFFALSE 91561
// sReset := true ;
91553: LD_ADDR_EXP 116
91557: PUSH
91558: LD_INT 1
91560: ST_TO_ADDR
// if p3 = 105 then
91561: LD_VAR 0 3
91565: PUSH
91566: LD_INT 105
91568: EQUAL
91569: IFFALSE 91579
// sSun := true ;
91571: LD_ADDR_EXP 117
91575: PUSH
91576: LD_INT 1
91578: ST_TO_ADDR
// if p3 = 106 then
91579: LD_VAR 0 3
91583: PUSH
91584: LD_INT 106
91586: EQUAL
91587: IFFALSE 91597
// sTiger := true ;
91589: LD_ADDR_EXP 113
91593: PUSH
91594: LD_INT 1
91596: ST_TO_ADDR
// if p3 = 107 then
91597: LD_VAR 0 3
91601: PUSH
91602: LD_INT 107
91604: EQUAL
91605: IFFALSE 91615
// sBomb := true ;
91607: LD_ADDR_EXP 114
91611: PUSH
91612: LD_INT 1
91614: ST_TO_ADDR
// if p3 = 108 then
91615: LD_VAR 0 3
91619: PUSH
91620: LD_INT 108
91622: EQUAL
91623: IFFALSE 91633
// sWound := true ;
91625: LD_ADDR_EXP 122
91629: PUSH
91630: LD_INT 1
91632: ST_TO_ADDR
// if p3 = 109 then
91633: LD_VAR 0 3
91637: PUSH
91638: LD_INT 109
91640: EQUAL
91641: IFFALSE 91651
// sBetray := true ;
91643: LD_ADDR_EXP 126
91647: PUSH
91648: LD_INT 1
91650: ST_TO_ADDR
// if p3 = 110 then
91651: LD_VAR 0 3
91655: PUSH
91656: LD_INT 110
91658: EQUAL
91659: IFFALSE 91669
// sContamin := true ;
91661: LD_ADDR_EXP 127
91665: PUSH
91666: LD_INT 1
91668: ST_TO_ADDR
// if p3 = 111 then
91669: LD_VAR 0 3
91673: PUSH
91674: LD_INT 111
91676: EQUAL
91677: IFFALSE 91687
// sOil := true ;
91679: LD_ADDR_EXP 129
91683: PUSH
91684: LD_INT 1
91686: ST_TO_ADDR
// if p3 = 112 then
91687: LD_VAR 0 3
91691: PUSH
91692: LD_INT 112
91694: EQUAL
91695: IFFALSE 91705
// sStu := true ;
91697: LD_ADDR_EXP 133
91701: PUSH
91702: LD_INT 1
91704: ST_TO_ADDR
// if p3 = 113 then
91705: LD_VAR 0 3
91709: PUSH
91710: LD_INT 113
91712: EQUAL
91713: IFFALSE 91723
// sBazooka := true ;
91715: LD_ADDR_EXP 136
91719: PUSH
91720: LD_INT 1
91722: ST_TO_ADDR
// if p3 = 114 then
91723: LD_VAR 0 3
91727: PUSH
91728: LD_INT 114
91730: EQUAL
91731: IFFALSE 91741
// sMortar := true ;
91733: LD_ADDR_EXP 137
91737: PUSH
91738: LD_INT 1
91740: ST_TO_ADDR
// if p3 = 115 then
91741: LD_VAR 0 3
91745: PUSH
91746: LD_INT 115
91748: EQUAL
91749: IFFALSE 91759
// sRanger := true ;
91751: LD_ADDR_EXP 147
91755: PUSH
91756: LD_INT 1
91758: ST_TO_ADDR
// if p3 = 116 then
91759: LD_VAR 0 3
91763: PUSH
91764: LD_INT 116
91766: EQUAL
91767: IFFALSE 91777
// sComputer := true ;
91769: LD_ADDR_EXP 148
91773: PUSH
91774: LD_INT 1
91776: ST_TO_ADDR
// if p3 = 117 then
91777: LD_VAR 0 3
91781: PUSH
91782: LD_INT 117
91784: EQUAL
91785: IFFALSE 91795
// s30 := true ;
91787: LD_ADDR_EXP 149
91791: PUSH
91792: LD_INT 1
91794: ST_TO_ADDR
// if p3 = 118 then
91795: LD_VAR 0 3
91799: PUSH
91800: LD_INT 118
91802: EQUAL
91803: IFFALSE 91813
// s60 := true ;
91805: LD_ADDR_EXP 150
91809: PUSH
91810: LD_INT 1
91812: ST_TO_ADDR
// end ; if p2 = 101 then
91813: LD_VAR 0 2
91817: PUSH
91818: LD_INT 101
91820: EQUAL
91821: IFFALSE 91949
// begin case p3 of 1 :
91823: LD_VAR 0 3
91827: PUSH
91828: LD_INT 1
91830: DOUBLE
91831: EQUAL
91832: IFTRUE 91836
91834: GO 91843
91836: POP
// hHackUnlimitedResources ; 2 :
91837: CALL 104047 0 0
91841: GO 91949
91843: LD_INT 2
91845: DOUBLE
91846: EQUAL
91847: IFTRUE 91851
91849: GO 91858
91851: POP
// hHackSetLevel10 ; 3 :
91852: CALL 104180 0 0
91856: GO 91949
91858: LD_INT 3
91860: DOUBLE
91861: EQUAL
91862: IFTRUE 91866
91864: GO 91873
91866: POP
// hHackSetLevel10YourUnits ; 4 :
91867: CALL 104265 0 0
91871: GO 91949
91873: LD_INT 4
91875: DOUBLE
91876: EQUAL
91877: IFTRUE 91881
91879: GO 91888
91881: POP
// hHackInvincible ; 5 :
91882: CALL 104713 0 0
91886: GO 91949
91888: LD_INT 5
91890: DOUBLE
91891: EQUAL
91892: IFTRUE 91896
91894: GO 91903
91896: POP
// hHackInvisible ; 6 :
91897: CALL 104824 0 0
91901: GO 91949
91903: LD_INT 6
91905: DOUBLE
91906: EQUAL
91907: IFTRUE 91911
91909: GO 91918
91911: POP
// hHackChangeYourSide ; 7 :
91912: CALL 104881 0 0
91916: GO 91949
91918: LD_INT 7
91920: DOUBLE
91921: EQUAL
91922: IFTRUE 91926
91924: GO 91933
91926: POP
// hHackChangeUnitSide ; 8 :
91927: CALL 104923 0 0
91931: GO 91949
91933: LD_INT 8
91935: DOUBLE
91936: EQUAL
91937: IFTRUE 91941
91939: GO 91948
91941: POP
// hHackFog ; end ;
91942: CALL 105024 0 0
91946: GO 91949
91948: POP
// end ; end ;
91949: LD_VAR 0 7
91953: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
91954: GO 91956
91956: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
91957: LD_STRING initStreamRollete();
91959: PPUSH
91960: CALL_OW 559
// InitStreamMode ;
91964: CALL 91976 0 0
// DefineStreamItems ( false ) ;
91968: LD_INT 0
91970: PPUSH
91971: CALL 92440 0 1
// end ;
91975: END
// function InitStreamMode ; begin
91976: LD_INT 0
91978: PPUSH
// streamModeActive := false ;
91979: LD_ADDR_EXP 94
91983: PUSH
91984: LD_INT 0
91986: ST_TO_ADDR
// normalCounter := 36 ;
91987: LD_ADDR_EXP 95
91991: PUSH
91992: LD_INT 36
91994: ST_TO_ADDR
// hardcoreCounter := 18 ;
91995: LD_ADDR_EXP 96
91999: PUSH
92000: LD_INT 18
92002: ST_TO_ADDR
// sRocket := false ;
92003: LD_ADDR_EXP 99
92007: PUSH
92008: LD_INT 0
92010: ST_TO_ADDR
// sSpeed := false ;
92011: LD_ADDR_EXP 98
92015: PUSH
92016: LD_INT 0
92018: ST_TO_ADDR
// sEngine := false ;
92019: LD_ADDR_EXP 100
92023: PUSH
92024: LD_INT 0
92026: ST_TO_ADDR
// sSpec := false ;
92027: LD_ADDR_EXP 97
92031: PUSH
92032: LD_INT 0
92034: ST_TO_ADDR
// sLevel := false ;
92035: LD_ADDR_EXP 101
92039: PUSH
92040: LD_INT 0
92042: ST_TO_ADDR
// sArmoury := false ;
92043: LD_ADDR_EXP 102
92047: PUSH
92048: LD_INT 0
92050: ST_TO_ADDR
// sRadar := false ;
92051: LD_ADDR_EXP 103
92055: PUSH
92056: LD_INT 0
92058: ST_TO_ADDR
// sBunker := false ;
92059: LD_ADDR_EXP 104
92063: PUSH
92064: LD_INT 0
92066: ST_TO_ADDR
// sHack := false ;
92067: LD_ADDR_EXP 105
92071: PUSH
92072: LD_INT 0
92074: ST_TO_ADDR
// sFire := false ;
92075: LD_ADDR_EXP 106
92079: PUSH
92080: LD_INT 0
92082: ST_TO_ADDR
// sRefresh := false ;
92083: LD_ADDR_EXP 107
92087: PUSH
92088: LD_INT 0
92090: ST_TO_ADDR
// sExp := false ;
92091: LD_ADDR_EXP 108
92095: PUSH
92096: LD_INT 0
92098: ST_TO_ADDR
// sDepot := false ;
92099: LD_ADDR_EXP 109
92103: PUSH
92104: LD_INT 0
92106: ST_TO_ADDR
// sFlag := false ;
92107: LD_ADDR_EXP 110
92111: PUSH
92112: LD_INT 0
92114: ST_TO_ADDR
// sKamikadze := false ;
92115: LD_ADDR_EXP 118
92119: PUSH
92120: LD_INT 0
92122: ST_TO_ADDR
// sTroll := false ;
92123: LD_ADDR_EXP 119
92127: PUSH
92128: LD_INT 0
92130: ST_TO_ADDR
// sSlow := false ;
92131: LD_ADDR_EXP 120
92135: PUSH
92136: LD_INT 0
92138: ST_TO_ADDR
// sLack := false ;
92139: LD_ADDR_EXP 121
92143: PUSH
92144: LD_INT 0
92146: ST_TO_ADDR
// sTank := false ;
92147: LD_ADDR_EXP 123
92151: PUSH
92152: LD_INT 0
92154: ST_TO_ADDR
// sRemote := false ;
92155: LD_ADDR_EXP 124
92159: PUSH
92160: LD_INT 0
92162: ST_TO_ADDR
// sPowell := false ;
92163: LD_ADDR_EXP 125
92167: PUSH
92168: LD_INT 0
92170: ST_TO_ADDR
// sTeleport := false ;
92171: LD_ADDR_EXP 128
92175: PUSH
92176: LD_INT 0
92178: ST_TO_ADDR
// sOilTower := false ;
92179: LD_ADDR_EXP 130
92183: PUSH
92184: LD_INT 0
92186: ST_TO_ADDR
// sShovel := false ;
92187: LD_ADDR_EXP 131
92191: PUSH
92192: LD_INT 0
92194: ST_TO_ADDR
// sSheik := false ;
92195: LD_ADDR_EXP 132
92199: PUSH
92200: LD_INT 0
92202: ST_TO_ADDR
// sEarthquake := false ;
92203: LD_ADDR_EXP 134
92207: PUSH
92208: LD_INT 0
92210: ST_TO_ADDR
// sAI := false ;
92211: LD_ADDR_EXP 135
92215: PUSH
92216: LD_INT 0
92218: ST_TO_ADDR
// sCargo := false ;
92219: LD_ADDR_EXP 138
92223: PUSH
92224: LD_INT 0
92226: ST_TO_ADDR
// sDLaser := false ;
92227: LD_ADDR_EXP 139
92231: PUSH
92232: LD_INT 0
92234: ST_TO_ADDR
// sExchange := false ;
92235: LD_ADDR_EXP 140
92239: PUSH
92240: LD_INT 0
92242: ST_TO_ADDR
// sFac := false ;
92243: LD_ADDR_EXP 141
92247: PUSH
92248: LD_INT 0
92250: ST_TO_ADDR
// sPower := false ;
92251: LD_ADDR_EXP 142
92255: PUSH
92256: LD_INT 0
92258: ST_TO_ADDR
// sRandom := false ;
92259: LD_ADDR_EXP 143
92263: PUSH
92264: LD_INT 0
92266: ST_TO_ADDR
// sShield := false ;
92267: LD_ADDR_EXP 144
92271: PUSH
92272: LD_INT 0
92274: ST_TO_ADDR
// sTime := false ;
92275: LD_ADDR_EXP 145
92279: PUSH
92280: LD_INT 0
92282: ST_TO_ADDR
// sTools := false ;
92283: LD_ADDR_EXP 146
92287: PUSH
92288: LD_INT 0
92290: ST_TO_ADDR
// sSold := false ;
92291: LD_ADDR_EXP 111
92295: PUSH
92296: LD_INT 0
92298: ST_TO_ADDR
// sDiff := false ;
92299: LD_ADDR_EXP 112
92303: PUSH
92304: LD_INT 0
92306: ST_TO_ADDR
// sFog := false ;
92307: LD_ADDR_EXP 115
92311: PUSH
92312: LD_INT 0
92314: ST_TO_ADDR
// sReset := false ;
92315: LD_ADDR_EXP 116
92319: PUSH
92320: LD_INT 0
92322: ST_TO_ADDR
// sSun := false ;
92323: LD_ADDR_EXP 117
92327: PUSH
92328: LD_INT 0
92330: ST_TO_ADDR
// sTiger := false ;
92331: LD_ADDR_EXP 113
92335: PUSH
92336: LD_INT 0
92338: ST_TO_ADDR
// sBomb := false ;
92339: LD_ADDR_EXP 114
92343: PUSH
92344: LD_INT 0
92346: ST_TO_ADDR
// sWound := false ;
92347: LD_ADDR_EXP 122
92351: PUSH
92352: LD_INT 0
92354: ST_TO_ADDR
// sBetray := false ;
92355: LD_ADDR_EXP 126
92359: PUSH
92360: LD_INT 0
92362: ST_TO_ADDR
// sContamin := false ;
92363: LD_ADDR_EXP 127
92367: PUSH
92368: LD_INT 0
92370: ST_TO_ADDR
// sOil := false ;
92371: LD_ADDR_EXP 129
92375: PUSH
92376: LD_INT 0
92378: ST_TO_ADDR
// sStu := false ;
92379: LD_ADDR_EXP 133
92383: PUSH
92384: LD_INT 0
92386: ST_TO_ADDR
// sBazooka := false ;
92387: LD_ADDR_EXP 136
92391: PUSH
92392: LD_INT 0
92394: ST_TO_ADDR
// sMortar := false ;
92395: LD_ADDR_EXP 137
92399: PUSH
92400: LD_INT 0
92402: ST_TO_ADDR
// sRanger := false ;
92403: LD_ADDR_EXP 147
92407: PUSH
92408: LD_INT 0
92410: ST_TO_ADDR
// sComputer := false ;
92411: LD_ADDR_EXP 148
92415: PUSH
92416: LD_INT 0
92418: ST_TO_ADDR
// s30 := false ;
92419: LD_ADDR_EXP 149
92423: PUSH
92424: LD_INT 0
92426: ST_TO_ADDR
// s60 := false ;
92427: LD_ADDR_EXP 150
92431: PUSH
92432: LD_INT 0
92434: ST_TO_ADDR
// end ;
92435: LD_VAR 0 1
92439: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
92440: LD_INT 0
92442: PPUSH
92443: PPUSH
92444: PPUSH
92445: PPUSH
92446: PPUSH
92447: PPUSH
92448: PPUSH
// result := [ ] ;
92449: LD_ADDR_VAR 0 2
92453: PUSH
92454: EMPTY
92455: ST_TO_ADDR
// if campaign_id = 1 then
92456: LD_OWVAR 69
92460: PUSH
92461: LD_INT 1
92463: EQUAL
92464: IFFALSE 95630
// begin case mission_number of 1 :
92466: LD_OWVAR 70
92470: PUSH
92471: LD_INT 1
92473: DOUBLE
92474: EQUAL
92475: IFTRUE 92479
92477: GO 92555
92479: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92480: LD_ADDR_VAR 0 2
92484: PUSH
92485: LD_INT 2
92487: PUSH
92488: LD_INT 4
92490: PUSH
92491: LD_INT 11
92493: PUSH
92494: LD_INT 12
92496: PUSH
92497: LD_INT 15
92499: PUSH
92500: LD_INT 16
92502: PUSH
92503: LD_INT 22
92505: PUSH
92506: LD_INT 23
92508: PUSH
92509: LD_INT 26
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 101
92525: PUSH
92526: LD_INT 102
92528: PUSH
92529: LD_INT 106
92531: PUSH
92532: LD_INT 116
92534: PUSH
92535: LD_INT 117
92537: PUSH
92538: LD_INT 118
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: ST_TO_ADDR
92553: GO 95628
92555: LD_INT 2
92557: DOUBLE
92558: EQUAL
92559: IFTRUE 92563
92561: GO 92647
92563: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92564: LD_ADDR_VAR 0 2
92568: PUSH
92569: LD_INT 2
92571: PUSH
92572: LD_INT 4
92574: PUSH
92575: LD_INT 11
92577: PUSH
92578: LD_INT 12
92580: PUSH
92581: LD_INT 15
92583: PUSH
92584: LD_INT 16
92586: PUSH
92587: LD_INT 22
92589: PUSH
92590: LD_INT 23
92592: PUSH
92593: LD_INT 26
92595: PUSH
92596: EMPTY
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: LIST
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 101
92609: PUSH
92610: LD_INT 102
92612: PUSH
92613: LD_INT 105
92615: PUSH
92616: LD_INT 106
92618: PUSH
92619: LD_INT 108
92621: PUSH
92622: LD_INT 116
92624: PUSH
92625: LD_INT 117
92627: PUSH
92628: LD_INT 118
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: ST_TO_ADDR
92645: GO 95628
92647: LD_INT 3
92649: DOUBLE
92650: EQUAL
92651: IFTRUE 92655
92653: GO 92743
92655: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92656: LD_ADDR_VAR 0 2
92660: PUSH
92661: LD_INT 2
92663: PUSH
92664: LD_INT 4
92666: PUSH
92667: LD_INT 5
92669: PUSH
92670: LD_INT 11
92672: PUSH
92673: LD_INT 12
92675: PUSH
92676: LD_INT 15
92678: PUSH
92679: LD_INT 16
92681: PUSH
92682: LD_INT 22
92684: PUSH
92685: LD_INT 26
92687: PUSH
92688: LD_INT 36
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: PUSH
92703: LD_INT 101
92705: PUSH
92706: LD_INT 102
92708: PUSH
92709: LD_INT 105
92711: PUSH
92712: LD_INT 106
92714: PUSH
92715: LD_INT 108
92717: PUSH
92718: LD_INT 116
92720: PUSH
92721: LD_INT 117
92723: PUSH
92724: LD_INT 118
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: PUSH
92737: EMPTY
92738: LIST
92739: LIST
92740: ST_TO_ADDR
92741: GO 95628
92743: LD_INT 4
92745: DOUBLE
92746: EQUAL
92747: IFTRUE 92751
92749: GO 92847
92751: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92752: LD_ADDR_VAR 0 2
92756: PUSH
92757: LD_INT 2
92759: PUSH
92760: LD_INT 4
92762: PUSH
92763: LD_INT 5
92765: PUSH
92766: LD_INT 8
92768: PUSH
92769: LD_INT 11
92771: PUSH
92772: LD_INT 12
92774: PUSH
92775: LD_INT 15
92777: PUSH
92778: LD_INT 16
92780: PUSH
92781: LD_INT 22
92783: PUSH
92784: LD_INT 23
92786: PUSH
92787: LD_INT 26
92789: PUSH
92790: LD_INT 36
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: PUSH
92807: LD_INT 101
92809: PUSH
92810: LD_INT 102
92812: PUSH
92813: LD_INT 105
92815: PUSH
92816: LD_INT 106
92818: PUSH
92819: LD_INT 108
92821: PUSH
92822: LD_INT 116
92824: PUSH
92825: LD_INT 117
92827: PUSH
92828: LD_INT 118
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: ST_TO_ADDR
92845: GO 95628
92847: LD_INT 5
92849: DOUBLE
92850: EQUAL
92851: IFTRUE 92855
92853: GO 92967
92855: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92856: LD_ADDR_VAR 0 2
92860: PUSH
92861: LD_INT 2
92863: PUSH
92864: LD_INT 4
92866: PUSH
92867: LD_INT 5
92869: PUSH
92870: LD_INT 6
92872: PUSH
92873: LD_INT 8
92875: PUSH
92876: LD_INT 11
92878: PUSH
92879: LD_INT 12
92881: PUSH
92882: LD_INT 15
92884: PUSH
92885: LD_INT 16
92887: PUSH
92888: LD_INT 22
92890: PUSH
92891: LD_INT 23
92893: PUSH
92894: LD_INT 25
92896: PUSH
92897: LD_INT 26
92899: PUSH
92900: LD_INT 36
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: PUSH
92919: LD_INT 101
92921: PUSH
92922: LD_INT 102
92924: PUSH
92925: LD_INT 105
92927: PUSH
92928: LD_INT 106
92930: PUSH
92931: LD_INT 108
92933: PUSH
92934: LD_INT 109
92936: PUSH
92937: LD_INT 112
92939: PUSH
92940: LD_INT 116
92942: PUSH
92943: LD_INT 117
92945: PUSH
92946: LD_INT 118
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: ST_TO_ADDR
92965: GO 95628
92967: LD_INT 6
92969: DOUBLE
92970: EQUAL
92971: IFTRUE 92975
92973: GO 93107
92975: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92976: LD_ADDR_VAR 0 2
92980: PUSH
92981: LD_INT 2
92983: PUSH
92984: LD_INT 4
92986: PUSH
92987: LD_INT 5
92989: PUSH
92990: LD_INT 6
92992: PUSH
92993: LD_INT 8
92995: PUSH
92996: LD_INT 11
92998: PUSH
92999: LD_INT 12
93001: PUSH
93002: LD_INT 15
93004: PUSH
93005: LD_INT 16
93007: PUSH
93008: LD_INT 20
93010: PUSH
93011: LD_INT 21
93013: PUSH
93014: LD_INT 22
93016: PUSH
93017: LD_INT 23
93019: PUSH
93020: LD_INT 25
93022: PUSH
93023: LD_INT 26
93025: PUSH
93026: LD_INT 30
93028: PUSH
93029: LD_INT 31
93031: PUSH
93032: LD_INT 32
93034: PUSH
93035: LD_INT 36
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: PUSH
93059: LD_INT 101
93061: PUSH
93062: LD_INT 102
93064: PUSH
93065: LD_INT 105
93067: PUSH
93068: LD_INT 106
93070: PUSH
93071: LD_INT 108
93073: PUSH
93074: LD_INT 109
93076: PUSH
93077: LD_INT 112
93079: PUSH
93080: LD_INT 116
93082: PUSH
93083: LD_INT 117
93085: PUSH
93086: LD_INT 118
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: LIST
93097: LIST
93098: LIST
93099: LIST
93100: PUSH
93101: EMPTY
93102: LIST
93103: LIST
93104: ST_TO_ADDR
93105: GO 95628
93107: LD_INT 7
93109: DOUBLE
93110: EQUAL
93111: IFTRUE 93115
93113: GO 93227
93115: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93116: LD_ADDR_VAR 0 2
93120: PUSH
93121: LD_INT 2
93123: PUSH
93124: LD_INT 4
93126: PUSH
93127: LD_INT 5
93129: PUSH
93130: LD_INT 7
93132: PUSH
93133: LD_INT 11
93135: PUSH
93136: LD_INT 12
93138: PUSH
93139: LD_INT 15
93141: PUSH
93142: LD_INT 16
93144: PUSH
93145: LD_INT 20
93147: PUSH
93148: LD_INT 21
93150: PUSH
93151: LD_INT 22
93153: PUSH
93154: LD_INT 23
93156: PUSH
93157: LD_INT 25
93159: PUSH
93160: LD_INT 26
93162: PUSH
93163: EMPTY
93164: LIST
93165: LIST
93166: LIST
93167: LIST
93168: LIST
93169: LIST
93170: LIST
93171: LIST
93172: LIST
93173: LIST
93174: LIST
93175: LIST
93176: LIST
93177: LIST
93178: PUSH
93179: LD_INT 101
93181: PUSH
93182: LD_INT 102
93184: PUSH
93185: LD_INT 103
93187: PUSH
93188: LD_INT 105
93190: PUSH
93191: LD_INT 106
93193: PUSH
93194: LD_INT 108
93196: PUSH
93197: LD_INT 112
93199: PUSH
93200: LD_INT 116
93202: PUSH
93203: LD_INT 117
93205: PUSH
93206: LD_INT 118
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: ST_TO_ADDR
93225: GO 95628
93227: LD_INT 8
93229: DOUBLE
93230: EQUAL
93231: IFTRUE 93235
93233: GO 93375
93235: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93236: LD_ADDR_VAR 0 2
93240: PUSH
93241: LD_INT 2
93243: PUSH
93244: LD_INT 4
93246: PUSH
93247: LD_INT 5
93249: PUSH
93250: LD_INT 6
93252: PUSH
93253: LD_INT 7
93255: PUSH
93256: LD_INT 8
93258: PUSH
93259: LD_INT 11
93261: PUSH
93262: LD_INT 12
93264: PUSH
93265: LD_INT 15
93267: PUSH
93268: LD_INT 16
93270: PUSH
93271: LD_INT 20
93273: PUSH
93274: LD_INT 21
93276: PUSH
93277: LD_INT 22
93279: PUSH
93280: LD_INT 23
93282: PUSH
93283: LD_INT 25
93285: PUSH
93286: LD_INT 26
93288: PUSH
93289: LD_INT 30
93291: PUSH
93292: LD_INT 31
93294: PUSH
93295: LD_INT 32
93297: PUSH
93298: LD_INT 36
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: PUSH
93323: LD_INT 101
93325: PUSH
93326: LD_INT 102
93328: PUSH
93329: LD_INT 103
93331: PUSH
93332: LD_INT 105
93334: PUSH
93335: LD_INT 106
93337: PUSH
93338: LD_INT 108
93340: PUSH
93341: LD_INT 109
93343: PUSH
93344: LD_INT 112
93346: PUSH
93347: LD_INT 116
93349: PUSH
93350: LD_INT 117
93352: PUSH
93353: LD_INT 118
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: ST_TO_ADDR
93373: GO 95628
93375: LD_INT 9
93377: DOUBLE
93378: EQUAL
93379: IFTRUE 93383
93381: GO 93531
93383: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93384: LD_ADDR_VAR 0 2
93388: PUSH
93389: LD_INT 2
93391: PUSH
93392: LD_INT 4
93394: PUSH
93395: LD_INT 5
93397: PUSH
93398: LD_INT 6
93400: PUSH
93401: LD_INT 7
93403: PUSH
93404: LD_INT 8
93406: PUSH
93407: LD_INT 11
93409: PUSH
93410: LD_INT 12
93412: PUSH
93413: LD_INT 15
93415: PUSH
93416: LD_INT 16
93418: PUSH
93419: LD_INT 20
93421: PUSH
93422: LD_INT 21
93424: PUSH
93425: LD_INT 22
93427: PUSH
93428: LD_INT 23
93430: PUSH
93431: LD_INT 25
93433: PUSH
93434: LD_INT 26
93436: PUSH
93437: LD_INT 28
93439: PUSH
93440: LD_INT 30
93442: PUSH
93443: LD_INT 31
93445: PUSH
93446: LD_INT 32
93448: PUSH
93449: LD_INT 36
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: PUSH
93475: LD_INT 101
93477: PUSH
93478: LD_INT 102
93480: PUSH
93481: LD_INT 103
93483: PUSH
93484: LD_INT 105
93486: PUSH
93487: LD_INT 106
93489: PUSH
93490: LD_INT 108
93492: PUSH
93493: LD_INT 109
93495: PUSH
93496: LD_INT 112
93498: PUSH
93499: LD_INT 114
93501: PUSH
93502: LD_INT 116
93504: PUSH
93505: LD_INT 117
93507: PUSH
93508: LD_INT 118
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: PUSH
93525: EMPTY
93526: LIST
93527: LIST
93528: ST_TO_ADDR
93529: GO 95628
93531: LD_INT 10
93533: DOUBLE
93534: EQUAL
93535: IFTRUE 93539
93537: GO 93735
93539: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93540: LD_ADDR_VAR 0 2
93544: PUSH
93545: LD_INT 2
93547: PUSH
93548: LD_INT 4
93550: PUSH
93551: LD_INT 5
93553: PUSH
93554: LD_INT 6
93556: PUSH
93557: LD_INT 7
93559: PUSH
93560: LD_INT 8
93562: PUSH
93563: LD_INT 9
93565: PUSH
93566: LD_INT 10
93568: PUSH
93569: LD_INT 11
93571: PUSH
93572: LD_INT 12
93574: PUSH
93575: LD_INT 13
93577: PUSH
93578: LD_INT 14
93580: PUSH
93581: LD_INT 15
93583: PUSH
93584: LD_INT 16
93586: PUSH
93587: LD_INT 17
93589: PUSH
93590: LD_INT 18
93592: PUSH
93593: LD_INT 19
93595: PUSH
93596: LD_INT 20
93598: PUSH
93599: LD_INT 21
93601: PUSH
93602: LD_INT 22
93604: PUSH
93605: LD_INT 23
93607: PUSH
93608: LD_INT 24
93610: PUSH
93611: LD_INT 25
93613: PUSH
93614: LD_INT 26
93616: PUSH
93617: LD_INT 28
93619: PUSH
93620: LD_INT 30
93622: PUSH
93623: LD_INT 31
93625: PUSH
93626: LD_INT 32
93628: PUSH
93629: LD_INT 36
93631: PUSH
93632: EMPTY
93633: LIST
93634: LIST
93635: LIST
93636: LIST
93637: LIST
93638: LIST
93639: LIST
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: LIST
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 101
93665: PUSH
93666: LD_INT 102
93668: PUSH
93669: LD_INT 103
93671: PUSH
93672: LD_INT 104
93674: PUSH
93675: LD_INT 105
93677: PUSH
93678: LD_INT 106
93680: PUSH
93681: LD_INT 107
93683: PUSH
93684: LD_INT 108
93686: PUSH
93687: LD_INT 109
93689: PUSH
93690: LD_INT 110
93692: PUSH
93693: LD_INT 111
93695: PUSH
93696: LD_INT 112
93698: PUSH
93699: LD_INT 114
93701: PUSH
93702: LD_INT 116
93704: PUSH
93705: LD_INT 117
93707: PUSH
93708: LD_INT 118
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: ST_TO_ADDR
93733: GO 95628
93735: LD_INT 11
93737: DOUBLE
93738: EQUAL
93739: IFTRUE 93743
93741: GO 93947
93743: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93744: LD_ADDR_VAR 0 2
93748: PUSH
93749: LD_INT 2
93751: PUSH
93752: LD_INT 3
93754: PUSH
93755: LD_INT 4
93757: PUSH
93758: LD_INT 5
93760: PUSH
93761: LD_INT 6
93763: PUSH
93764: LD_INT 7
93766: PUSH
93767: LD_INT 8
93769: PUSH
93770: LD_INT 9
93772: PUSH
93773: LD_INT 10
93775: PUSH
93776: LD_INT 11
93778: PUSH
93779: LD_INT 12
93781: PUSH
93782: LD_INT 13
93784: PUSH
93785: LD_INT 14
93787: PUSH
93788: LD_INT 15
93790: PUSH
93791: LD_INT 16
93793: PUSH
93794: LD_INT 17
93796: PUSH
93797: LD_INT 18
93799: PUSH
93800: LD_INT 19
93802: PUSH
93803: LD_INT 20
93805: PUSH
93806: LD_INT 21
93808: PUSH
93809: LD_INT 22
93811: PUSH
93812: LD_INT 23
93814: PUSH
93815: LD_INT 24
93817: PUSH
93818: LD_INT 25
93820: PUSH
93821: LD_INT 26
93823: PUSH
93824: LD_INT 28
93826: PUSH
93827: LD_INT 30
93829: PUSH
93830: LD_INT 31
93832: PUSH
93833: LD_INT 32
93835: PUSH
93836: LD_INT 34
93838: PUSH
93839: LD_INT 36
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 101
93877: PUSH
93878: LD_INT 102
93880: PUSH
93881: LD_INT 103
93883: PUSH
93884: LD_INT 104
93886: PUSH
93887: LD_INT 105
93889: PUSH
93890: LD_INT 106
93892: PUSH
93893: LD_INT 107
93895: PUSH
93896: LD_INT 108
93898: PUSH
93899: LD_INT 109
93901: PUSH
93902: LD_INT 110
93904: PUSH
93905: LD_INT 111
93907: PUSH
93908: LD_INT 112
93910: PUSH
93911: LD_INT 114
93913: PUSH
93914: LD_INT 116
93916: PUSH
93917: LD_INT 117
93919: PUSH
93920: LD_INT 118
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: ST_TO_ADDR
93945: GO 95628
93947: LD_INT 12
93949: DOUBLE
93950: EQUAL
93951: IFTRUE 93955
93953: GO 94175
93955: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93956: LD_ADDR_VAR 0 2
93960: PUSH
93961: LD_INT 1
93963: PUSH
93964: LD_INT 2
93966: PUSH
93967: LD_INT 3
93969: PUSH
93970: LD_INT 4
93972: PUSH
93973: LD_INT 5
93975: PUSH
93976: LD_INT 6
93978: PUSH
93979: LD_INT 7
93981: PUSH
93982: LD_INT 8
93984: PUSH
93985: LD_INT 9
93987: PUSH
93988: LD_INT 10
93990: PUSH
93991: LD_INT 11
93993: PUSH
93994: LD_INT 12
93996: PUSH
93997: LD_INT 13
93999: PUSH
94000: LD_INT 14
94002: PUSH
94003: LD_INT 15
94005: PUSH
94006: LD_INT 16
94008: PUSH
94009: LD_INT 17
94011: PUSH
94012: LD_INT 18
94014: PUSH
94015: LD_INT 19
94017: PUSH
94018: LD_INT 20
94020: PUSH
94021: LD_INT 21
94023: PUSH
94024: LD_INT 22
94026: PUSH
94027: LD_INT 23
94029: PUSH
94030: LD_INT 24
94032: PUSH
94033: LD_INT 25
94035: PUSH
94036: LD_INT 26
94038: PUSH
94039: LD_INT 27
94041: PUSH
94042: LD_INT 28
94044: PUSH
94045: LD_INT 30
94047: PUSH
94048: LD_INT 31
94050: PUSH
94051: LD_INT 32
94053: PUSH
94054: LD_INT 33
94056: PUSH
94057: LD_INT 34
94059: PUSH
94060: LD_INT 36
94062: PUSH
94063: EMPTY
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 101
94101: PUSH
94102: LD_INT 102
94104: PUSH
94105: LD_INT 103
94107: PUSH
94108: LD_INT 104
94110: PUSH
94111: LD_INT 105
94113: PUSH
94114: LD_INT 106
94116: PUSH
94117: LD_INT 107
94119: PUSH
94120: LD_INT 108
94122: PUSH
94123: LD_INT 109
94125: PUSH
94126: LD_INT 110
94128: PUSH
94129: LD_INT 111
94131: PUSH
94132: LD_INT 112
94134: PUSH
94135: LD_INT 113
94137: PUSH
94138: LD_INT 114
94140: PUSH
94141: LD_INT 116
94143: PUSH
94144: LD_INT 117
94146: PUSH
94147: LD_INT 118
94149: PUSH
94150: EMPTY
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: ST_TO_ADDR
94173: GO 95628
94175: LD_INT 13
94177: DOUBLE
94178: EQUAL
94179: IFTRUE 94183
94181: GO 94391
94183: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94184: LD_ADDR_VAR 0 2
94188: PUSH
94189: LD_INT 1
94191: PUSH
94192: LD_INT 2
94194: PUSH
94195: LD_INT 3
94197: PUSH
94198: LD_INT 4
94200: PUSH
94201: LD_INT 5
94203: PUSH
94204: LD_INT 8
94206: PUSH
94207: LD_INT 9
94209: PUSH
94210: LD_INT 10
94212: PUSH
94213: LD_INT 11
94215: PUSH
94216: LD_INT 12
94218: PUSH
94219: LD_INT 14
94221: PUSH
94222: LD_INT 15
94224: PUSH
94225: LD_INT 16
94227: PUSH
94228: LD_INT 17
94230: PUSH
94231: LD_INT 18
94233: PUSH
94234: LD_INT 19
94236: PUSH
94237: LD_INT 20
94239: PUSH
94240: LD_INT 21
94242: PUSH
94243: LD_INT 22
94245: PUSH
94246: LD_INT 23
94248: PUSH
94249: LD_INT 24
94251: PUSH
94252: LD_INT 25
94254: PUSH
94255: LD_INT 26
94257: PUSH
94258: LD_INT 27
94260: PUSH
94261: LD_INT 28
94263: PUSH
94264: LD_INT 30
94266: PUSH
94267: LD_INT 31
94269: PUSH
94270: LD_INT 32
94272: PUSH
94273: LD_INT 33
94275: PUSH
94276: LD_INT 34
94278: PUSH
94279: LD_INT 36
94281: PUSH
94282: EMPTY
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: PUSH
94315: LD_INT 101
94317: PUSH
94318: LD_INT 102
94320: PUSH
94321: LD_INT 103
94323: PUSH
94324: LD_INT 104
94326: PUSH
94327: LD_INT 105
94329: PUSH
94330: LD_INT 106
94332: PUSH
94333: LD_INT 107
94335: PUSH
94336: LD_INT 108
94338: PUSH
94339: LD_INT 109
94341: PUSH
94342: LD_INT 110
94344: PUSH
94345: LD_INT 111
94347: PUSH
94348: LD_INT 112
94350: PUSH
94351: LD_INT 113
94353: PUSH
94354: LD_INT 114
94356: PUSH
94357: LD_INT 116
94359: PUSH
94360: LD_INT 117
94362: PUSH
94363: LD_INT 118
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: ST_TO_ADDR
94389: GO 95628
94391: LD_INT 14
94393: DOUBLE
94394: EQUAL
94395: IFTRUE 94399
94397: GO 94623
94399: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94400: LD_ADDR_VAR 0 2
94404: PUSH
94405: LD_INT 1
94407: PUSH
94408: LD_INT 2
94410: PUSH
94411: LD_INT 3
94413: PUSH
94414: LD_INT 4
94416: PUSH
94417: LD_INT 5
94419: PUSH
94420: LD_INT 6
94422: PUSH
94423: LD_INT 7
94425: PUSH
94426: LD_INT 8
94428: PUSH
94429: LD_INT 9
94431: PUSH
94432: LD_INT 10
94434: PUSH
94435: LD_INT 11
94437: PUSH
94438: LD_INT 12
94440: PUSH
94441: LD_INT 13
94443: PUSH
94444: LD_INT 14
94446: PUSH
94447: LD_INT 15
94449: PUSH
94450: LD_INT 16
94452: PUSH
94453: LD_INT 17
94455: PUSH
94456: LD_INT 18
94458: PUSH
94459: LD_INT 19
94461: PUSH
94462: LD_INT 20
94464: PUSH
94465: LD_INT 21
94467: PUSH
94468: LD_INT 22
94470: PUSH
94471: LD_INT 23
94473: PUSH
94474: LD_INT 24
94476: PUSH
94477: LD_INT 25
94479: PUSH
94480: LD_INT 26
94482: PUSH
94483: LD_INT 27
94485: PUSH
94486: LD_INT 28
94488: PUSH
94489: LD_INT 29
94491: PUSH
94492: LD_INT 30
94494: PUSH
94495: LD_INT 31
94497: PUSH
94498: LD_INT 32
94500: PUSH
94501: LD_INT 33
94503: PUSH
94504: LD_INT 34
94506: PUSH
94507: LD_INT 36
94509: PUSH
94510: EMPTY
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: PUSH
94547: LD_INT 101
94549: PUSH
94550: LD_INT 102
94552: PUSH
94553: LD_INT 103
94555: PUSH
94556: LD_INT 104
94558: PUSH
94559: LD_INT 105
94561: PUSH
94562: LD_INT 106
94564: PUSH
94565: LD_INT 107
94567: PUSH
94568: LD_INT 108
94570: PUSH
94571: LD_INT 109
94573: PUSH
94574: LD_INT 110
94576: PUSH
94577: LD_INT 111
94579: PUSH
94580: LD_INT 112
94582: PUSH
94583: LD_INT 113
94585: PUSH
94586: LD_INT 114
94588: PUSH
94589: LD_INT 116
94591: PUSH
94592: LD_INT 117
94594: PUSH
94595: LD_INT 118
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: PUSH
94617: EMPTY
94618: LIST
94619: LIST
94620: ST_TO_ADDR
94621: GO 95628
94623: LD_INT 15
94625: DOUBLE
94626: EQUAL
94627: IFTRUE 94631
94629: GO 94855
94631: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94632: LD_ADDR_VAR 0 2
94636: PUSH
94637: LD_INT 1
94639: PUSH
94640: LD_INT 2
94642: PUSH
94643: LD_INT 3
94645: PUSH
94646: LD_INT 4
94648: PUSH
94649: LD_INT 5
94651: PUSH
94652: LD_INT 6
94654: PUSH
94655: LD_INT 7
94657: PUSH
94658: LD_INT 8
94660: PUSH
94661: LD_INT 9
94663: PUSH
94664: LD_INT 10
94666: PUSH
94667: LD_INT 11
94669: PUSH
94670: LD_INT 12
94672: PUSH
94673: LD_INT 13
94675: PUSH
94676: LD_INT 14
94678: PUSH
94679: LD_INT 15
94681: PUSH
94682: LD_INT 16
94684: PUSH
94685: LD_INT 17
94687: PUSH
94688: LD_INT 18
94690: PUSH
94691: LD_INT 19
94693: PUSH
94694: LD_INT 20
94696: PUSH
94697: LD_INT 21
94699: PUSH
94700: LD_INT 22
94702: PUSH
94703: LD_INT 23
94705: PUSH
94706: LD_INT 24
94708: PUSH
94709: LD_INT 25
94711: PUSH
94712: LD_INT 26
94714: PUSH
94715: LD_INT 27
94717: PUSH
94718: LD_INT 28
94720: PUSH
94721: LD_INT 29
94723: PUSH
94724: LD_INT 30
94726: PUSH
94727: LD_INT 31
94729: PUSH
94730: LD_INT 32
94732: PUSH
94733: LD_INT 33
94735: PUSH
94736: LD_INT 34
94738: PUSH
94739: LD_INT 36
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: PUSH
94779: LD_INT 101
94781: PUSH
94782: LD_INT 102
94784: PUSH
94785: LD_INT 103
94787: PUSH
94788: LD_INT 104
94790: PUSH
94791: LD_INT 105
94793: PUSH
94794: LD_INT 106
94796: PUSH
94797: LD_INT 107
94799: PUSH
94800: LD_INT 108
94802: PUSH
94803: LD_INT 109
94805: PUSH
94806: LD_INT 110
94808: PUSH
94809: LD_INT 111
94811: PUSH
94812: LD_INT 112
94814: PUSH
94815: LD_INT 113
94817: PUSH
94818: LD_INT 114
94820: PUSH
94821: LD_INT 116
94823: PUSH
94824: LD_INT 117
94826: PUSH
94827: LD_INT 118
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: ST_TO_ADDR
94853: GO 95628
94855: LD_INT 16
94857: DOUBLE
94858: EQUAL
94859: IFTRUE 94863
94861: GO 94999
94863: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94864: LD_ADDR_VAR 0 2
94868: PUSH
94869: LD_INT 2
94871: PUSH
94872: LD_INT 4
94874: PUSH
94875: LD_INT 5
94877: PUSH
94878: LD_INT 7
94880: PUSH
94881: LD_INT 11
94883: PUSH
94884: LD_INT 12
94886: PUSH
94887: LD_INT 15
94889: PUSH
94890: LD_INT 16
94892: PUSH
94893: LD_INT 20
94895: PUSH
94896: LD_INT 21
94898: PUSH
94899: LD_INT 22
94901: PUSH
94902: LD_INT 23
94904: PUSH
94905: LD_INT 25
94907: PUSH
94908: LD_INT 26
94910: PUSH
94911: LD_INT 30
94913: PUSH
94914: LD_INT 31
94916: PUSH
94917: LD_INT 32
94919: PUSH
94920: LD_INT 33
94922: PUSH
94923: LD_INT 34
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: PUSH
94947: LD_INT 101
94949: PUSH
94950: LD_INT 102
94952: PUSH
94953: LD_INT 103
94955: PUSH
94956: LD_INT 106
94958: PUSH
94959: LD_INT 108
94961: PUSH
94962: LD_INT 112
94964: PUSH
94965: LD_INT 113
94967: PUSH
94968: LD_INT 114
94970: PUSH
94971: LD_INT 116
94973: PUSH
94974: LD_INT 117
94976: PUSH
94977: LD_INT 118
94979: PUSH
94980: EMPTY
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: ST_TO_ADDR
94997: GO 95628
94999: LD_INT 17
95001: DOUBLE
95002: EQUAL
95003: IFTRUE 95007
95005: GO 95231
95007: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95008: LD_ADDR_VAR 0 2
95012: PUSH
95013: LD_INT 1
95015: PUSH
95016: LD_INT 2
95018: PUSH
95019: LD_INT 3
95021: PUSH
95022: LD_INT 4
95024: PUSH
95025: LD_INT 5
95027: PUSH
95028: LD_INT 6
95030: PUSH
95031: LD_INT 7
95033: PUSH
95034: LD_INT 8
95036: PUSH
95037: LD_INT 9
95039: PUSH
95040: LD_INT 10
95042: PUSH
95043: LD_INT 11
95045: PUSH
95046: LD_INT 12
95048: PUSH
95049: LD_INT 13
95051: PUSH
95052: LD_INT 14
95054: PUSH
95055: LD_INT 15
95057: PUSH
95058: LD_INT 16
95060: PUSH
95061: LD_INT 17
95063: PUSH
95064: LD_INT 18
95066: PUSH
95067: LD_INT 19
95069: PUSH
95070: LD_INT 20
95072: PUSH
95073: LD_INT 21
95075: PUSH
95076: LD_INT 22
95078: PUSH
95079: LD_INT 23
95081: PUSH
95082: LD_INT 24
95084: PUSH
95085: LD_INT 25
95087: PUSH
95088: LD_INT 26
95090: PUSH
95091: LD_INT 27
95093: PUSH
95094: LD_INT 28
95096: PUSH
95097: LD_INT 29
95099: PUSH
95100: LD_INT 30
95102: PUSH
95103: LD_INT 31
95105: PUSH
95106: LD_INT 32
95108: PUSH
95109: LD_INT 33
95111: PUSH
95112: LD_INT 34
95114: PUSH
95115: LD_INT 36
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: LIST
95133: LIST
95134: LIST
95135: LIST
95136: LIST
95137: LIST
95138: LIST
95139: LIST
95140: LIST
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: PUSH
95155: LD_INT 101
95157: PUSH
95158: LD_INT 102
95160: PUSH
95161: LD_INT 103
95163: PUSH
95164: LD_INT 104
95166: PUSH
95167: LD_INT 105
95169: PUSH
95170: LD_INT 106
95172: PUSH
95173: LD_INT 107
95175: PUSH
95176: LD_INT 108
95178: PUSH
95179: LD_INT 109
95181: PUSH
95182: LD_INT 110
95184: PUSH
95185: LD_INT 111
95187: PUSH
95188: LD_INT 112
95190: PUSH
95191: LD_INT 113
95193: PUSH
95194: LD_INT 114
95196: PUSH
95197: LD_INT 116
95199: PUSH
95200: LD_INT 117
95202: PUSH
95203: LD_INT 118
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: PUSH
95225: EMPTY
95226: LIST
95227: LIST
95228: ST_TO_ADDR
95229: GO 95628
95231: LD_INT 18
95233: DOUBLE
95234: EQUAL
95235: IFTRUE 95239
95237: GO 95387
95239: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95240: LD_ADDR_VAR 0 2
95244: PUSH
95245: LD_INT 2
95247: PUSH
95248: LD_INT 4
95250: PUSH
95251: LD_INT 5
95253: PUSH
95254: LD_INT 7
95256: PUSH
95257: LD_INT 11
95259: PUSH
95260: LD_INT 12
95262: PUSH
95263: LD_INT 15
95265: PUSH
95266: LD_INT 16
95268: PUSH
95269: LD_INT 20
95271: PUSH
95272: LD_INT 21
95274: PUSH
95275: LD_INT 22
95277: PUSH
95278: LD_INT 23
95280: PUSH
95281: LD_INT 25
95283: PUSH
95284: LD_INT 26
95286: PUSH
95287: LD_INT 30
95289: PUSH
95290: LD_INT 31
95292: PUSH
95293: LD_INT 32
95295: PUSH
95296: LD_INT 33
95298: PUSH
95299: LD_INT 34
95301: PUSH
95302: LD_INT 35
95304: PUSH
95305: LD_INT 36
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: PUSH
95331: LD_INT 101
95333: PUSH
95334: LD_INT 102
95336: PUSH
95337: LD_INT 103
95339: PUSH
95340: LD_INT 106
95342: PUSH
95343: LD_INT 108
95345: PUSH
95346: LD_INT 112
95348: PUSH
95349: LD_INT 113
95351: PUSH
95352: LD_INT 114
95354: PUSH
95355: LD_INT 115
95357: PUSH
95358: LD_INT 116
95360: PUSH
95361: LD_INT 117
95363: PUSH
95364: LD_INT 118
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: ST_TO_ADDR
95385: GO 95628
95387: LD_INT 19
95389: DOUBLE
95390: EQUAL
95391: IFTRUE 95395
95393: GO 95627
95395: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95396: LD_ADDR_VAR 0 2
95400: PUSH
95401: LD_INT 1
95403: PUSH
95404: LD_INT 2
95406: PUSH
95407: LD_INT 3
95409: PUSH
95410: LD_INT 4
95412: PUSH
95413: LD_INT 5
95415: PUSH
95416: LD_INT 6
95418: PUSH
95419: LD_INT 7
95421: PUSH
95422: LD_INT 8
95424: PUSH
95425: LD_INT 9
95427: PUSH
95428: LD_INT 10
95430: PUSH
95431: LD_INT 11
95433: PUSH
95434: LD_INT 12
95436: PUSH
95437: LD_INT 13
95439: PUSH
95440: LD_INT 14
95442: PUSH
95443: LD_INT 15
95445: PUSH
95446: LD_INT 16
95448: PUSH
95449: LD_INT 17
95451: PUSH
95452: LD_INT 18
95454: PUSH
95455: LD_INT 19
95457: PUSH
95458: LD_INT 20
95460: PUSH
95461: LD_INT 21
95463: PUSH
95464: LD_INT 22
95466: PUSH
95467: LD_INT 23
95469: PUSH
95470: LD_INT 24
95472: PUSH
95473: LD_INT 25
95475: PUSH
95476: LD_INT 26
95478: PUSH
95479: LD_INT 27
95481: PUSH
95482: LD_INT 28
95484: PUSH
95485: LD_INT 29
95487: PUSH
95488: LD_INT 30
95490: PUSH
95491: LD_INT 31
95493: PUSH
95494: LD_INT 32
95496: PUSH
95497: LD_INT 33
95499: PUSH
95500: LD_INT 34
95502: PUSH
95503: LD_INT 35
95505: PUSH
95506: LD_INT 36
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: PUSH
95547: LD_INT 101
95549: PUSH
95550: LD_INT 102
95552: PUSH
95553: LD_INT 103
95555: PUSH
95556: LD_INT 104
95558: PUSH
95559: LD_INT 105
95561: PUSH
95562: LD_INT 106
95564: PUSH
95565: LD_INT 107
95567: PUSH
95568: LD_INT 108
95570: PUSH
95571: LD_INT 109
95573: PUSH
95574: LD_INT 110
95576: PUSH
95577: LD_INT 111
95579: PUSH
95580: LD_INT 112
95582: PUSH
95583: LD_INT 113
95585: PUSH
95586: LD_INT 114
95588: PUSH
95589: LD_INT 115
95591: PUSH
95592: LD_INT 116
95594: PUSH
95595: LD_INT 117
95597: PUSH
95598: LD_INT 118
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: ST_TO_ADDR
95625: GO 95628
95627: POP
// end else
95628: GO 95859
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95630: LD_ADDR_VAR 0 2
95634: PUSH
95635: LD_INT 1
95637: PUSH
95638: LD_INT 2
95640: PUSH
95641: LD_INT 3
95643: PUSH
95644: LD_INT 4
95646: PUSH
95647: LD_INT 5
95649: PUSH
95650: LD_INT 6
95652: PUSH
95653: LD_INT 7
95655: PUSH
95656: LD_INT 8
95658: PUSH
95659: LD_INT 9
95661: PUSH
95662: LD_INT 10
95664: PUSH
95665: LD_INT 11
95667: PUSH
95668: LD_INT 12
95670: PUSH
95671: LD_INT 13
95673: PUSH
95674: LD_INT 14
95676: PUSH
95677: LD_INT 15
95679: PUSH
95680: LD_INT 16
95682: PUSH
95683: LD_INT 17
95685: PUSH
95686: LD_INT 18
95688: PUSH
95689: LD_INT 19
95691: PUSH
95692: LD_INT 20
95694: PUSH
95695: LD_INT 21
95697: PUSH
95698: LD_INT 22
95700: PUSH
95701: LD_INT 23
95703: PUSH
95704: LD_INT 24
95706: PUSH
95707: LD_INT 25
95709: PUSH
95710: LD_INT 26
95712: PUSH
95713: LD_INT 27
95715: PUSH
95716: LD_INT 28
95718: PUSH
95719: LD_INT 29
95721: PUSH
95722: LD_INT 30
95724: PUSH
95725: LD_INT 31
95727: PUSH
95728: LD_INT 32
95730: PUSH
95731: LD_INT 33
95733: PUSH
95734: LD_INT 34
95736: PUSH
95737: LD_INT 35
95739: PUSH
95740: LD_INT 36
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: PUSH
95781: LD_INT 101
95783: PUSH
95784: LD_INT 102
95786: PUSH
95787: LD_INT 103
95789: PUSH
95790: LD_INT 104
95792: PUSH
95793: LD_INT 105
95795: PUSH
95796: LD_INT 106
95798: PUSH
95799: LD_INT 107
95801: PUSH
95802: LD_INT 108
95804: PUSH
95805: LD_INT 109
95807: PUSH
95808: LD_INT 110
95810: PUSH
95811: LD_INT 111
95813: PUSH
95814: LD_INT 112
95816: PUSH
95817: LD_INT 113
95819: PUSH
95820: LD_INT 114
95822: PUSH
95823: LD_INT 115
95825: PUSH
95826: LD_INT 116
95828: PUSH
95829: LD_INT 117
95831: PUSH
95832: LD_INT 118
95834: PUSH
95835: EMPTY
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: ST_TO_ADDR
// if result then
95859: LD_VAR 0 2
95863: IFFALSE 96649
// begin normal :=  ;
95865: LD_ADDR_VAR 0 5
95869: PUSH
95870: LD_STRING 
95872: ST_TO_ADDR
// hardcore :=  ;
95873: LD_ADDR_VAR 0 6
95877: PUSH
95878: LD_STRING 
95880: ST_TO_ADDR
// active :=  ;
95881: LD_ADDR_VAR 0 7
95885: PUSH
95886: LD_STRING 
95888: ST_TO_ADDR
// for i = 1 to normalCounter do
95889: LD_ADDR_VAR 0 8
95893: PUSH
95894: DOUBLE
95895: LD_INT 1
95897: DEC
95898: ST_TO_ADDR
95899: LD_EXP 95
95903: PUSH
95904: FOR_TO
95905: IFFALSE 96006
// begin tmp := 0 ;
95907: LD_ADDR_VAR 0 3
95911: PUSH
95912: LD_STRING 0
95914: ST_TO_ADDR
// if result [ 1 ] then
95915: LD_VAR 0 2
95919: PUSH
95920: LD_INT 1
95922: ARRAY
95923: IFFALSE 95988
// if result [ 1 ] [ 1 ] = i then
95925: LD_VAR 0 2
95929: PUSH
95930: LD_INT 1
95932: ARRAY
95933: PUSH
95934: LD_INT 1
95936: ARRAY
95937: PUSH
95938: LD_VAR 0 8
95942: EQUAL
95943: IFFALSE 95988
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95945: LD_ADDR_VAR 0 2
95949: PUSH
95950: LD_VAR 0 2
95954: PPUSH
95955: LD_INT 1
95957: PPUSH
95958: LD_VAR 0 2
95962: PUSH
95963: LD_INT 1
95965: ARRAY
95966: PPUSH
95967: LD_INT 1
95969: PPUSH
95970: CALL_OW 3
95974: PPUSH
95975: CALL_OW 1
95979: ST_TO_ADDR
// tmp := 1 ;
95980: LD_ADDR_VAR 0 3
95984: PUSH
95985: LD_STRING 1
95987: ST_TO_ADDR
// end ; normal := normal & tmp ;
95988: LD_ADDR_VAR 0 5
95992: PUSH
95993: LD_VAR 0 5
95997: PUSH
95998: LD_VAR 0 3
96002: STR
96003: ST_TO_ADDR
// end ;
96004: GO 95904
96006: POP
96007: POP
// for i = 1 to hardcoreCounter do
96008: LD_ADDR_VAR 0 8
96012: PUSH
96013: DOUBLE
96014: LD_INT 1
96016: DEC
96017: ST_TO_ADDR
96018: LD_EXP 96
96022: PUSH
96023: FOR_TO
96024: IFFALSE 96129
// begin tmp := 0 ;
96026: LD_ADDR_VAR 0 3
96030: PUSH
96031: LD_STRING 0
96033: ST_TO_ADDR
// if result [ 2 ] then
96034: LD_VAR 0 2
96038: PUSH
96039: LD_INT 2
96041: ARRAY
96042: IFFALSE 96111
// if result [ 2 ] [ 1 ] = 100 + i then
96044: LD_VAR 0 2
96048: PUSH
96049: LD_INT 2
96051: ARRAY
96052: PUSH
96053: LD_INT 1
96055: ARRAY
96056: PUSH
96057: LD_INT 100
96059: PUSH
96060: LD_VAR 0 8
96064: PLUS
96065: EQUAL
96066: IFFALSE 96111
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96068: LD_ADDR_VAR 0 2
96072: PUSH
96073: LD_VAR 0 2
96077: PPUSH
96078: LD_INT 2
96080: PPUSH
96081: LD_VAR 0 2
96085: PUSH
96086: LD_INT 2
96088: ARRAY
96089: PPUSH
96090: LD_INT 1
96092: PPUSH
96093: CALL_OW 3
96097: PPUSH
96098: CALL_OW 1
96102: ST_TO_ADDR
// tmp := 1 ;
96103: LD_ADDR_VAR 0 3
96107: PUSH
96108: LD_STRING 1
96110: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96111: LD_ADDR_VAR 0 6
96115: PUSH
96116: LD_VAR 0 6
96120: PUSH
96121: LD_VAR 0 3
96125: STR
96126: ST_TO_ADDR
// end ;
96127: GO 96023
96129: POP
96130: POP
// if isGameLoad then
96131: LD_VAR 0 1
96135: IFFALSE 96610
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
96137: LD_ADDR_VAR 0 4
96141: PUSH
96142: LD_EXP 99
96146: PUSH
96147: LD_EXP 98
96151: PUSH
96152: LD_EXP 100
96156: PUSH
96157: LD_EXP 97
96161: PUSH
96162: LD_EXP 101
96166: PUSH
96167: LD_EXP 102
96171: PUSH
96172: LD_EXP 103
96176: PUSH
96177: LD_EXP 104
96181: PUSH
96182: LD_EXP 105
96186: PUSH
96187: LD_EXP 106
96191: PUSH
96192: LD_EXP 107
96196: PUSH
96197: LD_EXP 108
96201: PUSH
96202: LD_EXP 109
96206: PUSH
96207: LD_EXP 110
96211: PUSH
96212: LD_EXP 118
96216: PUSH
96217: LD_EXP 119
96221: PUSH
96222: LD_EXP 120
96226: PUSH
96227: LD_EXP 121
96231: PUSH
96232: LD_EXP 123
96236: PUSH
96237: LD_EXP 124
96241: PUSH
96242: LD_EXP 125
96246: PUSH
96247: LD_EXP 128
96251: PUSH
96252: LD_EXP 130
96256: PUSH
96257: LD_EXP 131
96261: PUSH
96262: LD_EXP 132
96266: PUSH
96267: LD_EXP 134
96271: PUSH
96272: LD_EXP 135
96276: PUSH
96277: LD_EXP 138
96281: PUSH
96282: LD_EXP 139
96286: PUSH
96287: LD_EXP 140
96291: PUSH
96292: LD_EXP 141
96296: PUSH
96297: LD_EXP 142
96301: PUSH
96302: LD_EXP 143
96306: PUSH
96307: LD_EXP 144
96311: PUSH
96312: LD_EXP 145
96316: PUSH
96317: LD_EXP 146
96321: PUSH
96322: LD_EXP 111
96326: PUSH
96327: LD_EXP 112
96331: PUSH
96332: LD_EXP 115
96336: PUSH
96337: LD_EXP 116
96341: PUSH
96342: LD_EXP 117
96346: PUSH
96347: LD_EXP 113
96351: PUSH
96352: LD_EXP 114
96356: PUSH
96357: LD_EXP 122
96361: PUSH
96362: LD_EXP 126
96366: PUSH
96367: LD_EXP 127
96371: PUSH
96372: LD_EXP 129
96376: PUSH
96377: LD_EXP 133
96381: PUSH
96382: LD_EXP 136
96386: PUSH
96387: LD_EXP 137
96391: PUSH
96392: LD_EXP 147
96396: PUSH
96397: LD_EXP 148
96401: PUSH
96402: LD_EXP 149
96406: PUSH
96407: LD_EXP 150
96411: PUSH
96412: EMPTY
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: ST_TO_ADDR
// tmp :=  ;
96468: LD_ADDR_VAR 0 3
96472: PUSH
96473: LD_STRING 
96475: ST_TO_ADDR
// for i = 1 to normalCounter do
96476: LD_ADDR_VAR 0 8
96480: PUSH
96481: DOUBLE
96482: LD_INT 1
96484: DEC
96485: ST_TO_ADDR
96486: LD_EXP 95
96490: PUSH
96491: FOR_TO
96492: IFFALSE 96528
// begin if flags [ i ] then
96494: LD_VAR 0 4
96498: PUSH
96499: LD_VAR 0 8
96503: ARRAY
96504: IFFALSE 96526
// tmp := tmp & i & ; ;
96506: LD_ADDR_VAR 0 3
96510: PUSH
96511: LD_VAR 0 3
96515: PUSH
96516: LD_VAR 0 8
96520: STR
96521: PUSH
96522: LD_STRING ;
96524: STR
96525: ST_TO_ADDR
// end ;
96526: GO 96491
96528: POP
96529: POP
// for i = 1 to hardcoreCounter do
96530: LD_ADDR_VAR 0 8
96534: PUSH
96535: DOUBLE
96536: LD_INT 1
96538: DEC
96539: ST_TO_ADDR
96540: LD_EXP 96
96544: PUSH
96545: FOR_TO
96546: IFFALSE 96592
// begin if flags [ normalCounter + i ] then
96548: LD_VAR 0 4
96552: PUSH
96553: LD_EXP 95
96557: PUSH
96558: LD_VAR 0 8
96562: PLUS
96563: ARRAY
96564: IFFALSE 96590
// tmp := tmp & ( 100 + i ) & ; ;
96566: LD_ADDR_VAR 0 3
96570: PUSH
96571: LD_VAR 0 3
96575: PUSH
96576: LD_INT 100
96578: PUSH
96579: LD_VAR 0 8
96583: PLUS
96584: STR
96585: PUSH
96586: LD_STRING ;
96588: STR
96589: ST_TO_ADDR
// end ;
96590: GO 96545
96592: POP
96593: POP
// if tmp then
96594: LD_VAR 0 3
96598: IFFALSE 96610
// active := tmp ;
96600: LD_ADDR_VAR 0 7
96604: PUSH
96605: LD_VAR 0 3
96609: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96610: LD_STRING getStreamItemsFromMission("
96612: PUSH
96613: LD_VAR 0 5
96617: STR
96618: PUSH
96619: LD_STRING ","
96621: STR
96622: PUSH
96623: LD_VAR 0 6
96627: STR
96628: PUSH
96629: LD_STRING ","
96631: STR
96632: PUSH
96633: LD_VAR 0 7
96637: STR
96638: PUSH
96639: LD_STRING ")
96641: STR
96642: PPUSH
96643: CALL_OW 559
// end else
96647: GO 96656
// ToLua ( getStreamItemsFromMission("","","") ) ;
96649: LD_STRING getStreamItemsFromMission("","","")
96651: PPUSH
96652: CALL_OW 559
// end ;
96656: LD_VAR 0 2
96660: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96661: LD_EXP 94
96665: PUSH
96666: LD_EXP 99
96670: AND
96671: IFFALSE 96795
96673: GO 96675
96675: DISABLE
96676: LD_INT 0
96678: PPUSH
96679: PPUSH
// begin enable ;
96680: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96681: LD_ADDR_VAR 0 2
96685: PUSH
96686: LD_INT 22
96688: PUSH
96689: LD_OWVAR 2
96693: PUSH
96694: EMPTY
96695: LIST
96696: LIST
96697: PUSH
96698: LD_INT 2
96700: PUSH
96701: LD_INT 34
96703: PUSH
96704: LD_INT 7
96706: PUSH
96707: EMPTY
96708: LIST
96709: LIST
96710: PUSH
96711: LD_INT 34
96713: PUSH
96714: LD_INT 45
96716: PUSH
96717: EMPTY
96718: LIST
96719: LIST
96720: PUSH
96721: LD_INT 34
96723: PUSH
96724: LD_INT 28
96726: PUSH
96727: EMPTY
96728: LIST
96729: LIST
96730: PUSH
96731: LD_INT 34
96733: PUSH
96734: LD_INT 47
96736: PUSH
96737: EMPTY
96738: LIST
96739: LIST
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: PUSH
96748: EMPTY
96749: LIST
96750: LIST
96751: PPUSH
96752: CALL_OW 69
96756: ST_TO_ADDR
// if not tmp then
96757: LD_VAR 0 2
96761: NOT
96762: IFFALSE 96766
// exit ;
96764: GO 96795
// for i in tmp do
96766: LD_ADDR_VAR 0 1
96770: PUSH
96771: LD_VAR 0 2
96775: PUSH
96776: FOR_IN
96777: IFFALSE 96793
// begin SetLives ( i , 0 ) ;
96779: LD_VAR 0 1
96783: PPUSH
96784: LD_INT 0
96786: PPUSH
96787: CALL_OW 234
// end ;
96791: GO 96776
96793: POP
96794: POP
// end ;
96795: PPOPN 2
96797: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96798: LD_EXP 94
96802: PUSH
96803: LD_EXP 100
96807: AND
96808: IFFALSE 96892
96810: GO 96812
96812: DISABLE
96813: LD_INT 0
96815: PPUSH
96816: PPUSH
// begin enable ;
96817: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96818: LD_ADDR_VAR 0 2
96822: PUSH
96823: LD_INT 22
96825: PUSH
96826: LD_OWVAR 2
96830: PUSH
96831: EMPTY
96832: LIST
96833: LIST
96834: PUSH
96835: LD_INT 32
96837: PUSH
96838: LD_INT 3
96840: PUSH
96841: EMPTY
96842: LIST
96843: LIST
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: PPUSH
96849: CALL_OW 69
96853: ST_TO_ADDR
// if not tmp then
96854: LD_VAR 0 2
96858: NOT
96859: IFFALSE 96863
// exit ;
96861: GO 96892
// for i in tmp do
96863: LD_ADDR_VAR 0 1
96867: PUSH
96868: LD_VAR 0 2
96872: PUSH
96873: FOR_IN
96874: IFFALSE 96890
// begin SetLives ( i , 0 ) ;
96876: LD_VAR 0 1
96880: PPUSH
96881: LD_INT 0
96883: PPUSH
96884: CALL_OW 234
// end ;
96888: GO 96873
96890: POP
96891: POP
// end ;
96892: PPOPN 2
96894: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96895: LD_EXP 94
96899: PUSH
96900: LD_EXP 97
96904: AND
96905: IFFALSE 96998
96907: GO 96909
96909: DISABLE
96910: LD_INT 0
96912: PPUSH
// begin enable ;
96913: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96914: LD_ADDR_VAR 0 1
96918: PUSH
96919: LD_INT 22
96921: PUSH
96922: LD_OWVAR 2
96926: PUSH
96927: EMPTY
96928: LIST
96929: LIST
96930: PUSH
96931: LD_INT 2
96933: PUSH
96934: LD_INT 25
96936: PUSH
96937: LD_INT 5
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: LD_INT 25
96946: PUSH
96947: LD_INT 9
96949: PUSH
96950: EMPTY
96951: LIST
96952: LIST
96953: PUSH
96954: LD_INT 25
96956: PUSH
96957: LD_INT 8
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: PUSH
96964: EMPTY
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: PUSH
96970: EMPTY
96971: LIST
96972: LIST
96973: PPUSH
96974: CALL_OW 69
96978: PUSH
96979: FOR_IN
96980: IFFALSE 96996
// begin SetClass ( i , 1 ) ;
96982: LD_VAR 0 1
96986: PPUSH
96987: LD_INT 1
96989: PPUSH
96990: CALL_OW 336
// end ;
96994: GO 96979
96996: POP
96997: POP
// end ;
96998: PPOPN 1
97000: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97001: LD_EXP 94
97005: PUSH
97006: LD_EXP 98
97010: AND
97011: PUSH
97012: LD_OWVAR 65
97016: PUSH
97017: LD_INT 7
97019: LESS
97020: AND
97021: IFFALSE 97035
97023: GO 97025
97025: DISABLE
// begin enable ;
97026: ENABLE
// game_speed := 7 ;
97027: LD_ADDR_OWVAR 65
97031: PUSH
97032: LD_INT 7
97034: ST_TO_ADDR
// end ;
97035: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97036: LD_EXP 94
97040: PUSH
97041: LD_EXP 101
97045: AND
97046: IFFALSE 97248
97048: GO 97050
97050: DISABLE
97051: LD_INT 0
97053: PPUSH
97054: PPUSH
97055: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97056: LD_ADDR_VAR 0 3
97060: PUSH
97061: LD_INT 81
97063: PUSH
97064: LD_OWVAR 2
97068: PUSH
97069: EMPTY
97070: LIST
97071: LIST
97072: PUSH
97073: LD_INT 21
97075: PUSH
97076: LD_INT 1
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: EMPTY
97084: LIST
97085: LIST
97086: PPUSH
97087: CALL_OW 69
97091: ST_TO_ADDR
// if not tmp then
97092: LD_VAR 0 3
97096: NOT
97097: IFFALSE 97101
// exit ;
97099: GO 97248
// if tmp > 5 then
97101: LD_VAR 0 3
97105: PUSH
97106: LD_INT 5
97108: GREATER
97109: IFFALSE 97121
// k := 5 else
97111: LD_ADDR_VAR 0 2
97115: PUSH
97116: LD_INT 5
97118: ST_TO_ADDR
97119: GO 97131
// k := tmp ;
97121: LD_ADDR_VAR 0 2
97125: PUSH
97126: LD_VAR 0 3
97130: ST_TO_ADDR
// for i := 1 to k do
97131: LD_ADDR_VAR 0 1
97135: PUSH
97136: DOUBLE
97137: LD_INT 1
97139: DEC
97140: ST_TO_ADDR
97141: LD_VAR 0 2
97145: PUSH
97146: FOR_TO
97147: IFFALSE 97246
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97149: LD_VAR 0 3
97153: PUSH
97154: LD_VAR 0 1
97158: ARRAY
97159: PPUSH
97160: LD_VAR 0 1
97164: PUSH
97165: LD_INT 4
97167: MOD
97168: PUSH
97169: LD_INT 1
97171: PLUS
97172: PPUSH
97173: CALL_OW 259
97177: PUSH
97178: LD_INT 10
97180: LESS
97181: IFFALSE 97244
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97183: LD_VAR 0 3
97187: PUSH
97188: LD_VAR 0 1
97192: ARRAY
97193: PPUSH
97194: LD_VAR 0 1
97198: PUSH
97199: LD_INT 4
97201: MOD
97202: PUSH
97203: LD_INT 1
97205: PLUS
97206: PPUSH
97207: LD_VAR 0 3
97211: PUSH
97212: LD_VAR 0 1
97216: ARRAY
97217: PPUSH
97218: LD_VAR 0 1
97222: PUSH
97223: LD_INT 4
97225: MOD
97226: PUSH
97227: LD_INT 1
97229: PLUS
97230: PPUSH
97231: CALL_OW 259
97235: PUSH
97236: LD_INT 1
97238: PLUS
97239: PPUSH
97240: CALL_OW 237
97244: GO 97146
97246: POP
97247: POP
// end ;
97248: PPOPN 3
97250: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97251: LD_EXP 94
97255: PUSH
97256: LD_EXP 102
97260: AND
97261: IFFALSE 97281
97263: GO 97265
97265: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97266: LD_INT 4
97268: PPUSH
97269: LD_OWVAR 2
97273: PPUSH
97274: LD_INT 0
97276: PPUSH
97277: CALL_OW 324
97281: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97282: LD_EXP 94
97286: PUSH
97287: LD_EXP 131
97291: AND
97292: IFFALSE 97312
97294: GO 97296
97296: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97297: LD_INT 19
97299: PPUSH
97300: LD_OWVAR 2
97304: PPUSH
97305: LD_INT 0
97307: PPUSH
97308: CALL_OW 324
97312: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97313: LD_EXP 94
97317: PUSH
97318: LD_EXP 103
97322: AND
97323: IFFALSE 97425
97325: GO 97327
97327: DISABLE
97328: LD_INT 0
97330: PPUSH
97331: PPUSH
// begin enable ;
97332: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97333: LD_ADDR_VAR 0 2
97337: PUSH
97338: LD_INT 22
97340: PUSH
97341: LD_OWVAR 2
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: PUSH
97350: LD_INT 2
97352: PUSH
97353: LD_INT 34
97355: PUSH
97356: LD_INT 11
97358: PUSH
97359: EMPTY
97360: LIST
97361: LIST
97362: PUSH
97363: LD_INT 34
97365: PUSH
97366: LD_INT 30
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PUSH
97373: EMPTY
97374: LIST
97375: LIST
97376: LIST
97377: PUSH
97378: EMPTY
97379: LIST
97380: LIST
97381: PPUSH
97382: CALL_OW 69
97386: ST_TO_ADDR
// if not tmp then
97387: LD_VAR 0 2
97391: NOT
97392: IFFALSE 97396
// exit ;
97394: GO 97425
// for i in tmp do
97396: LD_ADDR_VAR 0 1
97400: PUSH
97401: LD_VAR 0 2
97405: PUSH
97406: FOR_IN
97407: IFFALSE 97423
// begin SetLives ( i , 0 ) ;
97409: LD_VAR 0 1
97413: PPUSH
97414: LD_INT 0
97416: PPUSH
97417: CALL_OW 234
// end ;
97421: GO 97406
97423: POP
97424: POP
// end ;
97425: PPOPN 2
97427: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97428: LD_EXP 94
97432: PUSH
97433: LD_EXP 104
97437: AND
97438: IFFALSE 97458
97440: GO 97442
97442: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97443: LD_INT 32
97445: PPUSH
97446: LD_OWVAR 2
97450: PPUSH
97451: LD_INT 0
97453: PPUSH
97454: CALL_OW 324
97458: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97459: LD_EXP 94
97463: PUSH
97464: LD_EXP 105
97468: AND
97469: IFFALSE 97650
97471: GO 97473
97473: DISABLE
97474: LD_INT 0
97476: PPUSH
97477: PPUSH
97478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97479: LD_ADDR_VAR 0 2
97483: PUSH
97484: LD_INT 22
97486: PUSH
97487: LD_OWVAR 2
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: PUSH
97496: LD_INT 33
97498: PUSH
97499: LD_INT 3
97501: PUSH
97502: EMPTY
97503: LIST
97504: LIST
97505: PUSH
97506: EMPTY
97507: LIST
97508: LIST
97509: PPUSH
97510: CALL_OW 69
97514: ST_TO_ADDR
// if not tmp then
97515: LD_VAR 0 2
97519: NOT
97520: IFFALSE 97524
// exit ;
97522: GO 97650
// side := 0 ;
97524: LD_ADDR_VAR 0 3
97528: PUSH
97529: LD_INT 0
97531: ST_TO_ADDR
// for i := 1 to 8 do
97532: LD_ADDR_VAR 0 1
97536: PUSH
97537: DOUBLE
97538: LD_INT 1
97540: DEC
97541: ST_TO_ADDR
97542: LD_INT 8
97544: PUSH
97545: FOR_TO
97546: IFFALSE 97594
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97548: LD_OWVAR 2
97552: PUSH
97553: LD_VAR 0 1
97557: NONEQUAL
97558: PUSH
97559: LD_OWVAR 2
97563: PPUSH
97564: LD_VAR 0 1
97568: PPUSH
97569: CALL_OW 81
97573: PUSH
97574: LD_INT 2
97576: EQUAL
97577: AND
97578: IFFALSE 97592
// begin side := i ;
97580: LD_ADDR_VAR 0 3
97584: PUSH
97585: LD_VAR 0 1
97589: ST_TO_ADDR
// break ;
97590: GO 97594
// end ;
97592: GO 97545
97594: POP
97595: POP
// if not side then
97596: LD_VAR 0 3
97600: NOT
97601: IFFALSE 97605
// exit ;
97603: GO 97650
// for i := 1 to tmp do
97605: LD_ADDR_VAR 0 1
97609: PUSH
97610: DOUBLE
97611: LD_INT 1
97613: DEC
97614: ST_TO_ADDR
97615: LD_VAR 0 2
97619: PUSH
97620: FOR_TO
97621: IFFALSE 97648
// if Prob ( 60 ) then
97623: LD_INT 60
97625: PPUSH
97626: CALL_OW 13
97630: IFFALSE 97646
// SetSide ( i , side ) ;
97632: LD_VAR 0 1
97636: PPUSH
97637: LD_VAR 0 3
97641: PPUSH
97642: CALL_OW 235
97646: GO 97620
97648: POP
97649: POP
// end ;
97650: PPOPN 3
97652: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97653: LD_EXP 94
97657: PUSH
97658: LD_EXP 107
97662: AND
97663: IFFALSE 97782
97665: GO 97667
97667: DISABLE
97668: LD_INT 0
97670: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97671: LD_ADDR_VAR 0 1
97675: PUSH
97676: LD_INT 22
97678: PUSH
97679: LD_OWVAR 2
97683: PUSH
97684: EMPTY
97685: LIST
97686: LIST
97687: PUSH
97688: LD_INT 21
97690: PUSH
97691: LD_INT 1
97693: PUSH
97694: EMPTY
97695: LIST
97696: LIST
97697: PUSH
97698: LD_INT 3
97700: PUSH
97701: LD_INT 23
97703: PUSH
97704: LD_INT 0
97706: PUSH
97707: EMPTY
97708: LIST
97709: LIST
97710: PUSH
97711: EMPTY
97712: LIST
97713: LIST
97714: PUSH
97715: EMPTY
97716: LIST
97717: LIST
97718: LIST
97719: PPUSH
97720: CALL_OW 69
97724: PUSH
97725: FOR_IN
97726: IFFALSE 97780
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97728: LD_VAR 0 1
97732: PPUSH
97733: CALL_OW 257
97737: PUSH
97738: LD_INT 1
97740: PUSH
97741: LD_INT 2
97743: PUSH
97744: LD_INT 3
97746: PUSH
97747: LD_INT 4
97749: PUSH
97750: EMPTY
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: IN
97756: IFFALSE 97778
// SetClass ( un , rand ( 1 , 4 ) ) ;
97758: LD_VAR 0 1
97762: PPUSH
97763: LD_INT 1
97765: PPUSH
97766: LD_INT 4
97768: PPUSH
97769: CALL_OW 12
97773: PPUSH
97774: CALL_OW 336
97778: GO 97725
97780: POP
97781: POP
// end ;
97782: PPOPN 1
97784: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97785: LD_EXP 94
97789: PUSH
97790: LD_EXP 106
97794: AND
97795: IFFALSE 97874
97797: GO 97799
97799: DISABLE
97800: LD_INT 0
97802: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97803: LD_ADDR_VAR 0 1
97807: PUSH
97808: LD_INT 22
97810: PUSH
97811: LD_OWVAR 2
97815: PUSH
97816: EMPTY
97817: LIST
97818: LIST
97819: PUSH
97820: LD_INT 21
97822: PUSH
97823: LD_INT 3
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: PUSH
97830: EMPTY
97831: LIST
97832: LIST
97833: PPUSH
97834: CALL_OW 69
97838: ST_TO_ADDR
// if not tmp then
97839: LD_VAR 0 1
97843: NOT
97844: IFFALSE 97848
// exit ;
97846: GO 97874
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97848: LD_VAR 0 1
97852: PUSH
97853: LD_INT 1
97855: PPUSH
97856: LD_VAR 0 1
97860: PPUSH
97861: CALL_OW 12
97865: ARRAY
97866: PPUSH
97867: LD_INT 100
97869: PPUSH
97870: CALL_OW 234
// end ;
97874: PPOPN 1
97876: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97877: LD_EXP 94
97881: PUSH
97882: LD_EXP 108
97886: AND
97887: IFFALSE 97985
97889: GO 97891
97891: DISABLE
97892: LD_INT 0
97894: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97895: LD_ADDR_VAR 0 1
97899: PUSH
97900: LD_INT 22
97902: PUSH
97903: LD_OWVAR 2
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PUSH
97912: LD_INT 21
97914: PUSH
97915: LD_INT 1
97917: PUSH
97918: EMPTY
97919: LIST
97920: LIST
97921: PUSH
97922: EMPTY
97923: LIST
97924: LIST
97925: PPUSH
97926: CALL_OW 69
97930: ST_TO_ADDR
// if not tmp then
97931: LD_VAR 0 1
97935: NOT
97936: IFFALSE 97940
// exit ;
97938: GO 97985
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97940: LD_VAR 0 1
97944: PUSH
97945: LD_INT 1
97947: PPUSH
97948: LD_VAR 0 1
97952: PPUSH
97953: CALL_OW 12
97957: ARRAY
97958: PPUSH
97959: LD_INT 1
97961: PPUSH
97962: LD_INT 4
97964: PPUSH
97965: CALL_OW 12
97969: PPUSH
97970: LD_INT 3000
97972: PPUSH
97973: LD_INT 9000
97975: PPUSH
97976: CALL_OW 12
97980: PPUSH
97981: CALL_OW 492
// end ;
97985: PPOPN 1
97987: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97988: LD_EXP 94
97992: PUSH
97993: LD_EXP 109
97997: AND
97998: IFFALSE 98018
98000: GO 98002
98002: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98003: LD_INT 1
98005: PPUSH
98006: LD_OWVAR 2
98010: PPUSH
98011: LD_INT 0
98013: PPUSH
98014: CALL_OW 324
98018: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98019: LD_EXP 94
98023: PUSH
98024: LD_EXP 110
98028: AND
98029: IFFALSE 98112
98031: GO 98033
98033: DISABLE
98034: LD_INT 0
98036: PPUSH
98037: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98038: LD_ADDR_VAR 0 2
98042: PUSH
98043: LD_INT 22
98045: PUSH
98046: LD_OWVAR 2
98050: PUSH
98051: EMPTY
98052: LIST
98053: LIST
98054: PUSH
98055: LD_INT 21
98057: PUSH
98058: LD_INT 3
98060: PUSH
98061: EMPTY
98062: LIST
98063: LIST
98064: PUSH
98065: EMPTY
98066: LIST
98067: LIST
98068: PPUSH
98069: CALL_OW 69
98073: ST_TO_ADDR
// if not tmp then
98074: LD_VAR 0 2
98078: NOT
98079: IFFALSE 98083
// exit ;
98081: GO 98112
// for i in tmp do
98083: LD_ADDR_VAR 0 1
98087: PUSH
98088: LD_VAR 0 2
98092: PUSH
98093: FOR_IN
98094: IFFALSE 98110
// SetBLevel ( i , 10 ) ;
98096: LD_VAR 0 1
98100: PPUSH
98101: LD_INT 10
98103: PPUSH
98104: CALL_OW 241
98108: GO 98093
98110: POP
98111: POP
// end ;
98112: PPOPN 2
98114: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98115: LD_EXP 94
98119: PUSH
98120: LD_EXP 111
98124: AND
98125: IFFALSE 98236
98127: GO 98129
98129: DISABLE
98130: LD_INT 0
98132: PPUSH
98133: PPUSH
98134: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98135: LD_ADDR_VAR 0 3
98139: PUSH
98140: LD_INT 22
98142: PUSH
98143: LD_OWVAR 2
98147: PUSH
98148: EMPTY
98149: LIST
98150: LIST
98151: PUSH
98152: LD_INT 25
98154: PUSH
98155: LD_INT 1
98157: PUSH
98158: EMPTY
98159: LIST
98160: LIST
98161: PUSH
98162: EMPTY
98163: LIST
98164: LIST
98165: PPUSH
98166: CALL_OW 69
98170: ST_TO_ADDR
// if not tmp then
98171: LD_VAR 0 3
98175: NOT
98176: IFFALSE 98180
// exit ;
98178: GO 98236
// un := tmp [ rand ( 1 , tmp ) ] ;
98180: LD_ADDR_VAR 0 2
98184: PUSH
98185: LD_VAR 0 3
98189: PUSH
98190: LD_INT 1
98192: PPUSH
98193: LD_VAR 0 3
98197: PPUSH
98198: CALL_OW 12
98202: ARRAY
98203: ST_TO_ADDR
// if Crawls ( un ) then
98204: LD_VAR 0 2
98208: PPUSH
98209: CALL_OW 318
98213: IFFALSE 98224
// ComWalk ( un ) ;
98215: LD_VAR 0 2
98219: PPUSH
98220: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98224: LD_VAR 0 2
98228: PPUSH
98229: LD_INT 5
98231: PPUSH
98232: CALL_OW 336
// end ;
98236: PPOPN 3
98238: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98239: LD_EXP 94
98243: PUSH
98244: LD_EXP 112
98248: AND
98249: PUSH
98250: LD_OWVAR 67
98254: PUSH
98255: LD_INT 4
98257: LESS
98258: AND
98259: IFFALSE 98278
98261: GO 98263
98263: DISABLE
// begin Difficulty := Difficulty + 1 ;
98264: LD_ADDR_OWVAR 67
98268: PUSH
98269: LD_OWVAR 67
98273: PUSH
98274: LD_INT 1
98276: PLUS
98277: ST_TO_ADDR
// end ;
98278: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98279: LD_EXP 94
98283: PUSH
98284: LD_EXP 113
98288: AND
98289: IFFALSE 98392
98291: GO 98293
98293: DISABLE
98294: LD_INT 0
98296: PPUSH
// begin for i := 1 to 5 do
98297: LD_ADDR_VAR 0 1
98301: PUSH
98302: DOUBLE
98303: LD_INT 1
98305: DEC
98306: ST_TO_ADDR
98307: LD_INT 5
98309: PUSH
98310: FOR_TO
98311: IFFALSE 98390
// begin uc_nation := nation_nature ;
98313: LD_ADDR_OWVAR 21
98317: PUSH
98318: LD_INT 0
98320: ST_TO_ADDR
// uc_side := 0 ;
98321: LD_ADDR_OWVAR 20
98325: PUSH
98326: LD_INT 0
98328: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98329: LD_ADDR_OWVAR 29
98333: PUSH
98334: LD_INT 12
98336: PUSH
98337: LD_INT 12
98339: PUSH
98340: EMPTY
98341: LIST
98342: LIST
98343: ST_TO_ADDR
// hc_agressivity := 20 ;
98344: LD_ADDR_OWVAR 35
98348: PUSH
98349: LD_INT 20
98351: ST_TO_ADDR
// hc_class := class_tiger ;
98352: LD_ADDR_OWVAR 28
98356: PUSH
98357: LD_INT 14
98359: ST_TO_ADDR
// hc_gallery :=  ;
98360: LD_ADDR_OWVAR 33
98364: PUSH
98365: LD_STRING 
98367: ST_TO_ADDR
// hc_name :=  ;
98368: LD_ADDR_OWVAR 26
98372: PUSH
98373: LD_STRING 
98375: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98376: CALL_OW 44
98380: PPUSH
98381: LD_INT 0
98383: PPUSH
98384: CALL_OW 51
// end ;
98388: GO 98310
98390: POP
98391: POP
// end ;
98392: PPOPN 1
98394: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98395: LD_EXP 94
98399: PUSH
98400: LD_EXP 114
98404: AND
98405: IFFALSE 98414
98407: GO 98409
98409: DISABLE
// StreamSibBomb ;
98410: CALL 98415 0 0
98414: END
// export function StreamSibBomb ; var i , x , y ; begin
98415: LD_INT 0
98417: PPUSH
98418: PPUSH
98419: PPUSH
98420: PPUSH
// result := false ;
98421: LD_ADDR_VAR 0 1
98425: PUSH
98426: LD_INT 0
98428: ST_TO_ADDR
// for i := 1 to 16 do
98429: LD_ADDR_VAR 0 2
98433: PUSH
98434: DOUBLE
98435: LD_INT 1
98437: DEC
98438: ST_TO_ADDR
98439: LD_INT 16
98441: PUSH
98442: FOR_TO
98443: IFFALSE 98642
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98445: LD_ADDR_VAR 0 3
98449: PUSH
98450: LD_INT 10
98452: PUSH
98453: LD_INT 20
98455: PUSH
98456: LD_INT 30
98458: PUSH
98459: LD_INT 40
98461: PUSH
98462: LD_INT 50
98464: PUSH
98465: LD_INT 60
98467: PUSH
98468: LD_INT 70
98470: PUSH
98471: LD_INT 80
98473: PUSH
98474: LD_INT 90
98476: PUSH
98477: LD_INT 100
98479: PUSH
98480: LD_INT 110
98482: PUSH
98483: LD_INT 120
98485: PUSH
98486: LD_INT 130
98488: PUSH
98489: LD_INT 140
98491: PUSH
98492: LD_INT 150
98494: PUSH
98495: EMPTY
98496: LIST
98497: LIST
98498: LIST
98499: LIST
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: PUSH
98512: LD_INT 1
98514: PPUSH
98515: LD_INT 15
98517: PPUSH
98518: CALL_OW 12
98522: ARRAY
98523: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98524: LD_ADDR_VAR 0 4
98528: PUSH
98529: LD_INT 10
98531: PUSH
98532: LD_INT 20
98534: PUSH
98535: LD_INT 30
98537: PUSH
98538: LD_INT 40
98540: PUSH
98541: LD_INT 50
98543: PUSH
98544: LD_INT 60
98546: PUSH
98547: LD_INT 70
98549: PUSH
98550: LD_INT 80
98552: PUSH
98553: LD_INT 90
98555: PUSH
98556: LD_INT 100
98558: PUSH
98559: LD_INT 110
98561: PUSH
98562: LD_INT 120
98564: PUSH
98565: LD_INT 130
98567: PUSH
98568: LD_INT 140
98570: PUSH
98571: LD_INT 150
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: LIST
98587: LIST
98588: LIST
98589: LIST
98590: PUSH
98591: LD_INT 1
98593: PPUSH
98594: LD_INT 15
98596: PPUSH
98597: CALL_OW 12
98601: ARRAY
98602: ST_TO_ADDR
// if ValidHex ( x , y ) then
98603: LD_VAR 0 3
98607: PPUSH
98608: LD_VAR 0 4
98612: PPUSH
98613: CALL_OW 488
98617: IFFALSE 98640
// begin result := [ x , y ] ;
98619: LD_ADDR_VAR 0 1
98623: PUSH
98624: LD_VAR 0 3
98628: PUSH
98629: LD_VAR 0 4
98633: PUSH
98634: EMPTY
98635: LIST
98636: LIST
98637: ST_TO_ADDR
// break ;
98638: GO 98642
// end ; end ;
98640: GO 98442
98642: POP
98643: POP
// if result then
98644: LD_VAR 0 1
98648: IFFALSE 98708
// begin ToLua ( playSibBomb() ) ;
98650: LD_STRING playSibBomb()
98652: PPUSH
98653: CALL_OW 559
// wait ( 0 0$14 ) ;
98657: LD_INT 490
98659: PPUSH
98660: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98664: LD_VAR 0 1
98668: PUSH
98669: LD_INT 1
98671: ARRAY
98672: PPUSH
98673: LD_VAR 0 1
98677: PUSH
98678: LD_INT 2
98680: ARRAY
98681: PPUSH
98682: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98686: LD_VAR 0 1
98690: PUSH
98691: LD_INT 1
98693: ARRAY
98694: PPUSH
98695: LD_VAR 0 1
98699: PUSH
98700: LD_INT 2
98702: ARRAY
98703: PPUSH
98704: CALL_OW 429
// end ; end ;
98708: LD_VAR 0 1
98712: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98713: LD_EXP 94
98717: PUSH
98718: LD_EXP 116
98722: AND
98723: IFFALSE 98735
98725: GO 98727
98727: DISABLE
// YouLost (  ) ;
98728: LD_STRING 
98730: PPUSH
98731: CALL_OW 104
98735: END
// every 0 0$1 trigger StreamModeActive and sFog do
98736: LD_EXP 94
98740: PUSH
98741: LD_EXP 115
98745: AND
98746: IFFALSE 98760
98748: GO 98750
98750: DISABLE
// FogOff ( your_side ) ;
98751: LD_OWVAR 2
98755: PPUSH
98756: CALL_OW 344
98760: END
// every 0 0$1 trigger StreamModeActive and sSun do
98761: LD_EXP 94
98765: PUSH
98766: LD_EXP 117
98770: AND
98771: IFFALSE 98799
98773: GO 98775
98775: DISABLE
// begin solar_recharge_percent := 0 ;
98776: LD_ADDR_OWVAR 79
98780: PUSH
98781: LD_INT 0
98783: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98784: LD_INT 10500
98786: PPUSH
98787: CALL_OW 67
// solar_recharge_percent := 100 ;
98791: LD_ADDR_OWVAR 79
98795: PUSH
98796: LD_INT 100
98798: ST_TO_ADDR
// end ;
98799: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98800: LD_EXP 94
98804: PUSH
98805: LD_EXP 118
98809: AND
98810: IFFALSE 99049
98812: GO 98814
98814: DISABLE
98815: LD_INT 0
98817: PPUSH
98818: PPUSH
98819: PPUSH
// begin tmp := [ ] ;
98820: LD_ADDR_VAR 0 3
98824: PUSH
98825: EMPTY
98826: ST_TO_ADDR
// for i := 1 to 6 do
98827: LD_ADDR_VAR 0 1
98831: PUSH
98832: DOUBLE
98833: LD_INT 1
98835: DEC
98836: ST_TO_ADDR
98837: LD_INT 6
98839: PUSH
98840: FOR_TO
98841: IFFALSE 98946
// begin uc_nation := nation_nature ;
98843: LD_ADDR_OWVAR 21
98847: PUSH
98848: LD_INT 0
98850: ST_TO_ADDR
// uc_side := 0 ;
98851: LD_ADDR_OWVAR 20
98855: PUSH
98856: LD_INT 0
98858: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98859: LD_ADDR_OWVAR 29
98863: PUSH
98864: LD_INT 12
98866: PUSH
98867: LD_INT 12
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: ST_TO_ADDR
// hc_agressivity := 20 ;
98874: LD_ADDR_OWVAR 35
98878: PUSH
98879: LD_INT 20
98881: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98882: LD_ADDR_OWVAR 28
98886: PUSH
98887: LD_INT 17
98889: ST_TO_ADDR
// hc_gallery :=  ;
98890: LD_ADDR_OWVAR 33
98894: PUSH
98895: LD_STRING 
98897: ST_TO_ADDR
// hc_name :=  ;
98898: LD_ADDR_OWVAR 26
98902: PUSH
98903: LD_STRING 
98905: ST_TO_ADDR
// un := CreateHuman ;
98906: LD_ADDR_VAR 0 2
98910: PUSH
98911: CALL_OW 44
98915: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98916: LD_VAR 0 2
98920: PPUSH
98921: LD_INT 1
98923: PPUSH
98924: CALL_OW 51
// tmp := tmp ^ un ;
98928: LD_ADDR_VAR 0 3
98932: PUSH
98933: LD_VAR 0 3
98937: PUSH
98938: LD_VAR 0 2
98942: ADD
98943: ST_TO_ADDR
// end ;
98944: GO 98840
98946: POP
98947: POP
// repeat wait ( 0 0$1 ) ;
98948: LD_INT 35
98950: PPUSH
98951: CALL_OW 67
// for un in tmp do
98955: LD_ADDR_VAR 0 2
98959: PUSH
98960: LD_VAR 0 3
98964: PUSH
98965: FOR_IN
98966: IFFALSE 99040
// begin if IsDead ( un ) then
98968: LD_VAR 0 2
98972: PPUSH
98973: CALL_OW 301
98977: IFFALSE 98997
// begin tmp := tmp diff un ;
98979: LD_ADDR_VAR 0 3
98983: PUSH
98984: LD_VAR 0 3
98988: PUSH
98989: LD_VAR 0 2
98993: DIFF
98994: ST_TO_ADDR
// continue ;
98995: GO 98965
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98997: LD_VAR 0 2
99001: PPUSH
99002: LD_INT 3
99004: PUSH
99005: LD_INT 22
99007: PUSH
99008: LD_INT 0
99010: PUSH
99011: EMPTY
99012: LIST
99013: LIST
99014: PUSH
99015: EMPTY
99016: LIST
99017: LIST
99018: PPUSH
99019: CALL_OW 69
99023: PPUSH
99024: LD_VAR 0 2
99028: PPUSH
99029: CALL_OW 74
99033: PPUSH
99034: CALL_OW 115
// end ;
99038: GO 98965
99040: POP
99041: POP
// until not tmp ;
99042: LD_VAR 0 3
99046: NOT
99047: IFFALSE 98948
// end ;
99049: PPOPN 3
99051: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99052: LD_EXP 94
99056: PUSH
99057: LD_EXP 119
99061: AND
99062: IFFALSE 99116
99064: GO 99066
99066: DISABLE
// begin ToLua ( displayTroll(); ) ;
99067: LD_STRING displayTroll();
99069: PPUSH
99070: CALL_OW 559
// wait ( 3 3$00 ) ;
99074: LD_INT 6300
99076: PPUSH
99077: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99081: LD_STRING hideTroll();
99083: PPUSH
99084: CALL_OW 559
// wait ( 1 1$00 ) ;
99088: LD_INT 2100
99090: PPUSH
99091: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99095: LD_STRING displayTroll();
99097: PPUSH
99098: CALL_OW 559
// wait ( 1 1$00 ) ;
99102: LD_INT 2100
99104: PPUSH
99105: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99109: LD_STRING hideTroll();
99111: PPUSH
99112: CALL_OW 559
// end ;
99116: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99117: LD_EXP 94
99121: PUSH
99122: LD_EXP 120
99126: AND
99127: IFFALSE 99190
99129: GO 99131
99131: DISABLE
99132: LD_INT 0
99134: PPUSH
// begin p := 0 ;
99135: LD_ADDR_VAR 0 1
99139: PUSH
99140: LD_INT 0
99142: ST_TO_ADDR
// repeat game_speed := 1 ;
99143: LD_ADDR_OWVAR 65
99147: PUSH
99148: LD_INT 1
99150: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99151: LD_INT 35
99153: PPUSH
99154: CALL_OW 67
// p := p + 1 ;
99158: LD_ADDR_VAR 0 1
99162: PUSH
99163: LD_VAR 0 1
99167: PUSH
99168: LD_INT 1
99170: PLUS
99171: ST_TO_ADDR
// until p >= 60 ;
99172: LD_VAR 0 1
99176: PUSH
99177: LD_INT 60
99179: GREATEREQUAL
99180: IFFALSE 99143
// game_speed := 4 ;
99182: LD_ADDR_OWVAR 65
99186: PUSH
99187: LD_INT 4
99189: ST_TO_ADDR
// end ;
99190: PPOPN 1
99192: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99193: LD_EXP 94
99197: PUSH
99198: LD_EXP 121
99202: AND
99203: IFFALSE 99349
99205: GO 99207
99207: DISABLE
99208: LD_INT 0
99210: PPUSH
99211: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99212: LD_ADDR_VAR 0 1
99216: PUSH
99217: LD_INT 22
99219: PUSH
99220: LD_OWVAR 2
99224: PUSH
99225: EMPTY
99226: LIST
99227: LIST
99228: PUSH
99229: LD_INT 2
99231: PUSH
99232: LD_INT 30
99234: PUSH
99235: LD_INT 0
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: PUSH
99242: LD_INT 30
99244: PUSH
99245: LD_INT 1
99247: PUSH
99248: EMPTY
99249: LIST
99250: LIST
99251: PUSH
99252: EMPTY
99253: LIST
99254: LIST
99255: LIST
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: PPUSH
99261: CALL_OW 69
99265: ST_TO_ADDR
// if not depot then
99266: LD_VAR 0 1
99270: NOT
99271: IFFALSE 99275
// exit ;
99273: GO 99349
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99275: LD_ADDR_VAR 0 2
99279: PUSH
99280: LD_VAR 0 1
99284: PUSH
99285: LD_INT 1
99287: PPUSH
99288: LD_VAR 0 1
99292: PPUSH
99293: CALL_OW 12
99297: ARRAY
99298: PPUSH
99299: CALL_OW 274
99303: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99304: LD_VAR 0 2
99308: PPUSH
99309: LD_INT 1
99311: PPUSH
99312: LD_INT 0
99314: PPUSH
99315: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99319: LD_VAR 0 2
99323: PPUSH
99324: LD_INT 2
99326: PPUSH
99327: LD_INT 0
99329: PPUSH
99330: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99334: LD_VAR 0 2
99338: PPUSH
99339: LD_INT 3
99341: PPUSH
99342: LD_INT 0
99344: PPUSH
99345: CALL_OW 277
// end ;
99349: PPOPN 2
99351: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99352: LD_EXP 94
99356: PUSH
99357: LD_EXP 122
99361: AND
99362: IFFALSE 99459
99364: GO 99366
99366: DISABLE
99367: LD_INT 0
99369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99370: LD_ADDR_VAR 0 1
99374: PUSH
99375: LD_INT 22
99377: PUSH
99378: LD_OWVAR 2
99382: PUSH
99383: EMPTY
99384: LIST
99385: LIST
99386: PUSH
99387: LD_INT 21
99389: PUSH
99390: LD_INT 1
99392: PUSH
99393: EMPTY
99394: LIST
99395: LIST
99396: PUSH
99397: LD_INT 3
99399: PUSH
99400: LD_INT 23
99402: PUSH
99403: LD_INT 0
99405: PUSH
99406: EMPTY
99407: LIST
99408: LIST
99409: PUSH
99410: EMPTY
99411: LIST
99412: LIST
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: LIST
99418: PPUSH
99419: CALL_OW 69
99423: ST_TO_ADDR
// if not tmp then
99424: LD_VAR 0 1
99428: NOT
99429: IFFALSE 99433
// exit ;
99431: GO 99459
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99433: LD_VAR 0 1
99437: PUSH
99438: LD_INT 1
99440: PPUSH
99441: LD_VAR 0 1
99445: PPUSH
99446: CALL_OW 12
99450: ARRAY
99451: PPUSH
99452: LD_INT 200
99454: PPUSH
99455: CALL_OW 234
// end ;
99459: PPOPN 1
99461: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99462: LD_EXP 94
99466: PUSH
99467: LD_EXP 123
99471: AND
99472: IFFALSE 99551
99474: GO 99476
99476: DISABLE
99477: LD_INT 0
99479: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99480: LD_ADDR_VAR 0 1
99484: PUSH
99485: LD_INT 22
99487: PUSH
99488: LD_OWVAR 2
99492: PUSH
99493: EMPTY
99494: LIST
99495: LIST
99496: PUSH
99497: LD_INT 21
99499: PUSH
99500: LD_INT 2
99502: PUSH
99503: EMPTY
99504: LIST
99505: LIST
99506: PUSH
99507: EMPTY
99508: LIST
99509: LIST
99510: PPUSH
99511: CALL_OW 69
99515: ST_TO_ADDR
// if not tmp then
99516: LD_VAR 0 1
99520: NOT
99521: IFFALSE 99525
// exit ;
99523: GO 99551
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99525: LD_VAR 0 1
99529: PUSH
99530: LD_INT 1
99532: PPUSH
99533: LD_VAR 0 1
99537: PPUSH
99538: CALL_OW 12
99542: ARRAY
99543: PPUSH
99544: LD_INT 60
99546: PPUSH
99547: CALL_OW 234
// end ;
99551: PPOPN 1
99553: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99554: LD_EXP 94
99558: PUSH
99559: LD_EXP 124
99563: AND
99564: IFFALSE 99663
99566: GO 99568
99568: DISABLE
99569: LD_INT 0
99571: PPUSH
99572: PPUSH
// begin enable ;
99573: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99574: LD_ADDR_VAR 0 1
99578: PUSH
99579: LD_INT 22
99581: PUSH
99582: LD_OWVAR 2
99586: PUSH
99587: EMPTY
99588: LIST
99589: LIST
99590: PUSH
99591: LD_INT 61
99593: PUSH
99594: EMPTY
99595: LIST
99596: PUSH
99597: LD_INT 33
99599: PUSH
99600: LD_INT 2
99602: PUSH
99603: EMPTY
99604: LIST
99605: LIST
99606: PUSH
99607: EMPTY
99608: LIST
99609: LIST
99610: LIST
99611: PPUSH
99612: CALL_OW 69
99616: ST_TO_ADDR
// if not tmp then
99617: LD_VAR 0 1
99621: NOT
99622: IFFALSE 99626
// exit ;
99624: GO 99663
// for i in tmp do
99626: LD_ADDR_VAR 0 2
99630: PUSH
99631: LD_VAR 0 1
99635: PUSH
99636: FOR_IN
99637: IFFALSE 99661
// if IsControledBy ( i ) then
99639: LD_VAR 0 2
99643: PPUSH
99644: CALL_OW 312
99648: IFFALSE 99659
// ComUnlink ( i ) ;
99650: LD_VAR 0 2
99654: PPUSH
99655: CALL_OW 136
99659: GO 99636
99661: POP
99662: POP
// end ;
99663: PPOPN 2
99665: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99666: LD_EXP 94
99670: PUSH
99671: LD_EXP 125
99675: AND
99676: IFFALSE 99816
99678: GO 99680
99680: DISABLE
99681: LD_INT 0
99683: PPUSH
99684: PPUSH
// begin ToLua ( displayPowell(); ) ;
99685: LD_STRING displayPowell();
99687: PPUSH
99688: CALL_OW 559
// uc_side := 0 ;
99692: LD_ADDR_OWVAR 20
99696: PUSH
99697: LD_INT 0
99699: ST_TO_ADDR
// uc_nation := 2 ;
99700: LD_ADDR_OWVAR 21
99704: PUSH
99705: LD_INT 2
99707: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99708: LD_ADDR_OWVAR 37
99712: PUSH
99713: LD_INT 14
99715: ST_TO_ADDR
// vc_engine := engine_siberite ;
99716: LD_ADDR_OWVAR 39
99720: PUSH
99721: LD_INT 3
99723: ST_TO_ADDR
// vc_control := control_apeman ;
99724: LD_ADDR_OWVAR 38
99728: PUSH
99729: LD_INT 5
99731: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99732: LD_ADDR_OWVAR 40
99736: PUSH
99737: LD_INT 29
99739: ST_TO_ADDR
// un := CreateVehicle ;
99740: LD_ADDR_VAR 0 2
99744: PUSH
99745: CALL_OW 45
99749: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99750: LD_VAR 0 2
99754: PPUSH
99755: LD_INT 1
99757: PPUSH
99758: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99762: LD_INT 35
99764: PPUSH
99765: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99769: LD_VAR 0 2
99773: PPUSH
99774: LD_INT 22
99776: PUSH
99777: LD_OWVAR 2
99781: PUSH
99782: EMPTY
99783: LIST
99784: LIST
99785: PPUSH
99786: CALL_OW 69
99790: PPUSH
99791: LD_VAR 0 2
99795: PPUSH
99796: CALL_OW 74
99800: PPUSH
99801: CALL_OW 115
// until IsDead ( un ) ;
99805: LD_VAR 0 2
99809: PPUSH
99810: CALL_OW 301
99814: IFFALSE 99762
// end ;
99816: PPOPN 2
99818: END
// every 0 0$1 trigger StreamModeActive and sStu do
99819: LD_EXP 94
99823: PUSH
99824: LD_EXP 133
99828: AND
99829: IFFALSE 99845
99831: GO 99833
99833: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99834: LD_STRING displayStucuk();
99836: PPUSH
99837: CALL_OW 559
// ResetFog ;
99841: CALL_OW 335
// end ;
99845: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99846: LD_EXP 94
99850: PUSH
99851: LD_EXP 126
99855: AND
99856: IFFALSE 99997
99858: GO 99860
99860: DISABLE
99861: LD_INT 0
99863: PPUSH
99864: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99865: LD_ADDR_VAR 0 2
99869: PUSH
99870: LD_INT 22
99872: PUSH
99873: LD_OWVAR 2
99877: PUSH
99878: EMPTY
99879: LIST
99880: LIST
99881: PUSH
99882: LD_INT 21
99884: PUSH
99885: LD_INT 1
99887: PUSH
99888: EMPTY
99889: LIST
99890: LIST
99891: PUSH
99892: EMPTY
99893: LIST
99894: LIST
99895: PPUSH
99896: CALL_OW 69
99900: ST_TO_ADDR
// if not tmp then
99901: LD_VAR 0 2
99905: NOT
99906: IFFALSE 99910
// exit ;
99908: GO 99997
// un := tmp [ rand ( 1 , tmp ) ] ;
99910: LD_ADDR_VAR 0 1
99914: PUSH
99915: LD_VAR 0 2
99919: PUSH
99920: LD_INT 1
99922: PPUSH
99923: LD_VAR 0 2
99927: PPUSH
99928: CALL_OW 12
99932: ARRAY
99933: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99934: LD_VAR 0 1
99938: PPUSH
99939: LD_INT 0
99941: PPUSH
99942: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99946: LD_VAR 0 1
99950: PPUSH
99951: LD_OWVAR 3
99955: PUSH
99956: LD_VAR 0 1
99960: DIFF
99961: PPUSH
99962: LD_VAR 0 1
99966: PPUSH
99967: CALL_OW 74
99971: PPUSH
99972: CALL_OW 115
// wait ( 0 0$20 ) ;
99976: LD_INT 700
99978: PPUSH
99979: CALL_OW 67
// SetSide ( un , your_side ) ;
99983: LD_VAR 0 1
99987: PPUSH
99988: LD_OWVAR 2
99992: PPUSH
99993: CALL_OW 235
// end ;
99997: PPOPN 2
99999: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100000: LD_EXP 94
100004: PUSH
100005: LD_EXP 127
100009: AND
100010: IFFALSE 100116
100012: GO 100014
100014: DISABLE
100015: LD_INT 0
100017: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100018: LD_ADDR_VAR 0 1
100022: PUSH
100023: LD_INT 22
100025: PUSH
100026: LD_OWVAR 2
100030: PUSH
100031: EMPTY
100032: LIST
100033: LIST
100034: PUSH
100035: LD_INT 2
100037: PUSH
100038: LD_INT 30
100040: PUSH
100041: LD_INT 0
100043: PUSH
100044: EMPTY
100045: LIST
100046: LIST
100047: PUSH
100048: LD_INT 30
100050: PUSH
100051: LD_INT 1
100053: PUSH
100054: EMPTY
100055: LIST
100056: LIST
100057: PUSH
100058: EMPTY
100059: LIST
100060: LIST
100061: LIST
100062: PUSH
100063: EMPTY
100064: LIST
100065: LIST
100066: PPUSH
100067: CALL_OW 69
100071: ST_TO_ADDR
// if not depot then
100072: LD_VAR 0 1
100076: NOT
100077: IFFALSE 100081
// exit ;
100079: GO 100116
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100081: LD_VAR 0 1
100085: PUSH
100086: LD_INT 1
100088: ARRAY
100089: PPUSH
100090: CALL_OW 250
100094: PPUSH
100095: LD_VAR 0 1
100099: PUSH
100100: LD_INT 1
100102: ARRAY
100103: PPUSH
100104: CALL_OW 251
100108: PPUSH
100109: LD_INT 70
100111: PPUSH
100112: CALL_OW 495
// end ;
100116: PPOPN 1
100118: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100119: LD_EXP 94
100123: PUSH
100124: LD_EXP 128
100128: AND
100129: IFFALSE 100340
100131: GO 100133
100133: DISABLE
100134: LD_INT 0
100136: PPUSH
100137: PPUSH
100138: PPUSH
100139: PPUSH
100140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100141: LD_ADDR_VAR 0 5
100145: PUSH
100146: LD_INT 22
100148: PUSH
100149: LD_OWVAR 2
100153: PUSH
100154: EMPTY
100155: LIST
100156: LIST
100157: PUSH
100158: LD_INT 21
100160: PUSH
100161: LD_INT 1
100163: PUSH
100164: EMPTY
100165: LIST
100166: LIST
100167: PUSH
100168: EMPTY
100169: LIST
100170: LIST
100171: PPUSH
100172: CALL_OW 69
100176: ST_TO_ADDR
// if not tmp then
100177: LD_VAR 0 5
100181: NOT
100182: IFFALSE 100186
// exit ;
100184: GO 100340
// for i in tmp do
100186: LD_ADDR_VAR 0 1
100190: PUSH
100191: LD_VAR 0 5
100195: PUSH
100196: FOR_IN
100197: IFFALSE 100338
// begin d := rand ( 0 , 5 ) ;
100199: LD_ADDR_VAR 0 4
100203: PUSH
100204: LD_INT 0
100206: PPUSH
100207: LD_INT 5
100209: PPUSH
100210: CALL_OW 12
100214: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100215: LD_ADDR_VAR 0 2
100219: PUSH
100220: LD_VAR 0 1
100224: PPUSH
100225: CALL_OW 250
100229: PPUSH
100230: LD_VAR 0 4
100234: PPUSH
100235: LD_INT 3
100237: PPUSH
100238: LD_INT 12
100240: PPUSH
100241: CALL_OW 12
100245: PPUSH
100246: CALL_OW 272
100250: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100251: LD_ADDR_VAR 0 3
100255: PUSH
100256: LD_VAR 0 1
100260: PPUSH
100261: CALL_OW 251
100265: PPUSH
100266: LD_VAR 0 4
100270: PPUSH
100271: LD_INT 3
100273: PPUSH
100274: LD_INT 12
100276: PPUSH
100277: CALL_OW 12
100281: PPUSH
100282: CALL_OW 273
100286: ST_TO_ADDR
// if ValidHex ( x , y ) then
100287: LD_VAR 0 2
100291: PPUSH
100292: LD_VAR 0 3
100296: PPUSH
100297: CALL_OW 488
100301: IFFALSE 100336
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100303: LD_VAR 0 1
100307: PPUSH
100308: LD_VAR 0 2
100312: PPUSH
100313: LD_VAR 0 3
100317: PPUSH
100318: LD_INT 3
100320: PPUSH
100321: LD_INT 6
100323: PPUSH
100324: CALL_OW 12
100328: PPUSH
100329: LD_INT 1
100331: PPUSH
100332: CALL_OW 483
// end ;
100336: GO 100196
100338: POP
100339: POP
// end ;
100340: PPOPN 5
100342: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100343: LD_EXP 94
100347: PUSH
100348: LD_EXP 129
100352: AND
100353: IFFALSE 100447
100355: GO 100357
100357: DISABLE
100358: LD_INT 0
100360: PPUSH
100361: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100362: LD_ADDR_VAR 0 2
100366: PUSH
100367: LD_INT 22
100369: PUSH
100370: LD_OWVAR 2
100374: PUSH
100375: EMPTY
100376: LIST
100377: LIST
100378: PUSH
100379: LD_INT 32
100381: PUSH
100382: LD_INT 1
100384: PUSH
100385: EMPTY
100386: LIST
100387: LIST
100388: PUSH
100389: LD_INT 21
100391: PUSH
100392: LD_INT 2
100394: PUSH
100395: EMPTY
100396: LIST
100397: LIST
100398: PUSH
100399: EMPTY
100400: LIST
100401: LIST
100402: LIST
100403: PPUSH
100404: CALL_OW 69
100408: ST_TO_ADDR
// if not tmp then
100409: LD_VAR 0 2
100413: NOT
100414: IFFALSE 100418
// exit ;
100416: GO 100447
// for i in tmp do
100418: LD_ADDR_VAR 0 1
100422: PUSH
100423: LD_VAR 0 2
100427: PUSH
100428: FOR_IN
100429: IFFALSE 100445
// SetFuel ( i , 0 ) ;
100431: LD_VAR 0 1
100435: PPUSH
100436: LD_INT 0
100438: PPUSH
100439: CALL_OW 240
100443: GO 100428
100445: POP
100446: POP
// end ;
100447: PPOPN 2
100449: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100450: LD_EXP 94
100454: PUSH
100455: LD_EXP 130
100459: AND
100460: IFFALSE 100526
100462: GO 100464
100464: DISABLE
100465: LD_INT 0
100467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100468: LD_ADDR_VAR 0 1
100472: PUSH
100473: LD_INT 22
100475: PUSH
100476: LD_OWVAR 2
100480: PUSH
100481: EMPTY
100482: LIST
100483: LIST
100484: PUSH
100485: LD_INT 30
100487: PUSH
100488: LD_INT 29
100490: PUSH
100491: EMPTY
100492: LIST
100493: LIST
100494: PUSH
100495: EMPTY
100496: LIST
100497: LIST
100498: PPUSH
100499: CALL_OW 69
100503: ST_TO_ADDR
// if not tmp then
100504: LD_VAR 0 1
100508: NOT
100509: IFFALSE 100513
// exit ;
100511: GO 100526
// DestroyUnit ( tmp [ 1 ] ) ;
100513: LD_VAR 0 1
100517: PUSH
100518: LD_INT 1
100520: ARRAY
100521: PPUSH
100522: CALL_OW 65
// end ;
100526: PPOPN 1
100528: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100529: LD_EXP 94
100533: PUSH
100534: LD_EXP 132
100538: AND
100539: IFFALSE 100668
100541: GO 100543
100543: DISABLE
100544: LD_INT 0
100546: PPUSH
// begin uc_side := 0 ;
100547: LD_ADDR_OWVAR 20
100551: PUSH
100552: LD_INT 0
100554: ST_TO_ADDR
// uc_nation := nation_arabian ;
100555: LD_ADDR_OWVAR 21
100559: PUSH
100560: LD_INT 2
100562: ST_TO_ADDR
// hc_gallery :=  ;
100563: LD_ADDR_OWVAR 33
100567: PUSH
100568: LD_STRING 
100570: ST_TO_ADDR
// hc_name :=  ;
100571: LD_ADDR_OWVAR 26
100575: PUSH
100576: LD_STRING 
100578: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100579: LD_INT 1
100581: PPUSH
100582: LD_INT 11
100584: PPUSH
100585: LD_INT 10
100587: PPUSH
100588: CALL_OW 380
// un := CreateHuman ;
100592: LD_ADDR_VAR 0 1
100596: PUSH
100597: CALL_OW 44
100601: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100602: LD_VAR 0 1
100606: PPUSH
100607: LD_INT 1
100609: PPUSH
100610: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100614: LD_INT 35
100616: PPUSH
100617: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100621: LD_VAR 0 1
100625: PPUSH
100626: LD_INT 22
100628: PUSH
100629: LD_OWVAR 2
100633: PUSH
100634: EMPTY
100635: LIST
100636: LIST
100637: PPUSH
100638: CALL_OW 69
100642: PPUSH
100643: LD_VAR 0 1
100647: PPUSH
100648: CALL_OW 74
100652: PPUSH
100653: CALL_OW 115
// until IsDead ( un ) ;
100657: LD_VAR 0 1
100661: PPUSH
100662: CALL_OW 301
100666: IFFALSE 100614
// end ;
100668: PPOPN 1
100670: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100671: LD_EXP 94
100675: PUSH
100676: LD_EXP 134
100680: AND
100681: IFFALSE 100693
100683: GO 100685
100685: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100686: LD_STRING earthquake(getX(game), 0, 32)
100688: PPUSH
100689: CALL_OW 559
100693: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100694: LD_EXP 94
100698: PUSH
100699: LD_EXP 135
100703: AND
100704: IFFALSE 100795
100706: GO 100708
100708: DISABLE
100709: LD_INT 0
100711: PPUSH
// begin enable ;
100712: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100713: LD_ADDR_VAR 0 1
100717: PUSH
100718: LD_INT 22
100720: PUSH
100721: LD_OWVAR 2
100725: PUSH
100726: EMPTY
100727: LIST
100728: LIST
100729: PUSH
100730: LD_INT 21
100732: PUSH
100733: LD_INT 2
100735: PUSH
100736: EMPTY
100737: LIST
100738: LIST
100739: PUSH
100740: LD_INT 33
100742: PUSH
100743: LD_INT 3
100745: PUSH
100746: EMPTY
100747: LIST
100748: LIST
100749: PUSH
100750: EMPTY
100751: LIST
100752: LIST
100753: LIST
100754: PPUSH
100755: CALL_OW 69
100759: ST_TO_ADDR
// if not tmp then
100760: LD_VAR 0 1
100764: NOT
100765: IFFALSE 100769
// exit ;
100767: GO 100795
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100769: LD_VAR 0 1
100773: PUSH
100774: LD_INT 1
100776: PPUSH
100777: LD_VAR 0 1
100781: PPUSH
100782: CALL_OW 12
100786: ARRAY
100787: PPUSH
100788: LD_INT 1
100790: PPUSH
100791: CALL_OW 234
// end ;
100795: PPOPN 1
100797: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100798: LD_EXP 94
100802: PUSH
100803: LD_EXP 136
100807: AND
100808: IFFALSE 100949
100810: GO 100812
100812: DISABLE
100813: LD_INT 0
100815: PPUSH
100816: PPUSH
100817: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100818: LD_ADDR_VAR 0 3
100822: PUSH
100823: LD_INT 22
100825: PUSH
100826: LD_OWVAR 2
100830: PUSH
100831: EMPTY
100832: LIST
100833: LIST
100834: PUSH
100835: LD_INT 25
100837: PUSH
100838: LD_INT 1
100840: PUSH
100841: EMPTY
100842: LIST
100843: LIST
100844: PUSH
100845: EMPTY
100846: LIST
100847: LIST
100848: PPUSH
100849: CALL_OW 69
100853: ST_TO_ADDR
// if not tmp then
100854: LD_VAR 0 3
100858: NOT
100859: IFFALSE 100863
// exit ;
100861: GO 100949
// un := tmp [ rand ( 1 , tmp ) ] ;
100863: LD_ADDR_VAR 0 2
100867: PUSH
100868: LD_VAR 0 3
100872: PUSH
100873: LD_INT 1
100875: PPUSH
100876: LD_VAR 0 3
100880: PPUSH
100881: CALL_OW 12
100885: ARRAY
100886: ST_TO_ADDR
// if Crawls ( un ) then
100887: LD_VAR 0 2
100891: PPUSH
100892: CALL_OW 318
100896: IFFALSE 100907
// ComWalk ( un ) ;
100898: LD_VAR 0 2
100902: PPUSH
100903: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100907: LD_VAR 0 2
100911: PPUSH
100912: LD_INT 9
100914: PPUSH
100915: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100919: LD_INT 28
100921: PPUSH
100922: LD_OWVAR 2
100926: PPUSH
100927: LD_INT 2
100929: PPUSH
100930: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100934: LD_INT 29
100936: PPUSH
100937: LD_OWVAR 2
100941: PPUSH
100942: LD_INT 2
100944: PPUSH
100945: CALL_OW 322
// end ;
100949: PPOPN 3
100951: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100952: LD_EXP 94
100956: PUSH
100957: LD_EXP 137
100961: AND
100962: IFFALSE 101073
100964: GO 100966
100966: DISABLE
100967: LD_INT 0
100969: PPUSH
100970: PPUSH
100971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100972: LD_ADDR_VAR 0 3
100976: PUSH
100977: LD_INT 22
100979: PUSH
100980: LD_OWVAR 2
100984: PUSH
100985: EMPTY
100986: LIST
100987: LIST
100988: PUSH
100989: LD_INT 25
100991: PUSH
100992: LD_INT 1
100994: PUSH
100995: EMPTY
100996: LIST
100997: LIST
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: PPUSH
101003: CALL_OW 69
101007: ST_TO_ADDR
// if not tmp then
101008: LD_VAR 0 3
101012: NOT
101013: IFFALSE 101017
// exit ;
101015: GO 101073
// un := tmp [ rand ( 1 , tmp ) ] ;
101017: LD_ADDR_VAR 0 2
101021: PUSH
101022: LD_VAR 0 3
101026: PUSH
101027: LD_INT 1
101029: PPUSH
101030: LD_VAR 0 3
101034: PPUSH
101035: CALL_OW 12
101039: ARRAY
101040: ST_TO_ADDR
// if Crawls ( un ) then
101041: LD_VAR 0 2
101045: PPUSH
101046: CALL_OW 318
101050: IFFALSE 101061
// ComWalk ( un ) ;
101052: LD_VAR 0 2
101056: PPUSH
101057: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101061: LD_VAR 0 2
101065: PPUSH
101066: LD_INT 8
101068: PPUSH
101069: CALL_OW 336
// end ;
101073: PPOPN 3
101075: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101076: LD_EXP 94
101080: PUSH
101081: LD_EXP 138
101085: AND
101086: IFFALSE 101230
101088: GO 101090
101090: DISABLE
101091: LD_INT 0
101093: PPUSH
101094: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101095: LD_ADDR_VAR 0 2
101099: PUSH
101100: LD_INT 22
101102: PUSH
101103: LD_OWVAR 2
101107: PUSH
101108: EMPTY
101109: LIST
101110: LIST
101111: PUSH
101112: LD_INT 21
101114: PUSH
101115: LD_INT 2
101117: PUSH
101118: EMPTY
101119: LIST
101120: LIST
101121: PUSH
101122: LD_INT 2
101124: PUSH
101125: LD_INT 34
101127: PUSH
101128: LD_INT 12
101130: PUSH
101131: EMPTY
101132: LIST
101133: LIST
101134: PUSH
101135: LD_INT 34
101137: PUSH
101138: LD_INT 51
101140: PUSH
101141: EMPTY
101142: LIST
101143: LIST
101144: PUSH
101145: LD_INT 34
101147: PUSH
101148: LD_INT 32
101150: PUSH
101151: EMPTY
101152: LIST
101153: LIST
101154: PUSH
101155: EMPTY
101156: LIST
101157: LIST
101158: LIST
101159: LIST
101160: PUSH
101161: EMPTY
101162: LIST
101163: LIST
101164: LIST
101165: PPUSH
101166: CALL_OW 69
101170: ST_TO_ADDR
// if not tmp then
101171: LD_VAR 0 2
101175: NOT
101176: IFFALSE 101180
// exit ;
101178: GO 101230
// for i in tmp do
101180: LD_ADDR_VAR 0 1
101184: PUSH
101185: LD_VAR 0 2
101189: PUSH
101190: FOR_IN
101191: IFFALSE 101228
// if GetCargo ( i , mat_artifact ) = 0 then
101193: LD_VAR 0 1
101197: PPUSH
101198: LD_INT 4
101200: PPUSH
101201: CALL_OW 289
101205: PUSH
101206: LD_INT 0
101208: EQUAL
101209: IFFALSE 101226
// SetCargo ( i , mat_siberit , 100 ) ;
101211: LD_VAR 0 1
101215: PPUSH
101216: LD_INT 3
101218: PPUSH
101219: LD_INT 100
101221: PPUSH
101222: CALL_OW 290
101226: GO 101190
101228: POP
101229: POP
// end ;
101230: PPOPN 2
101232: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101233: LD_EXP 94
101237: PUSH
101238: LD_EXP 139
101242: AND
101243: IFFALSE 101426
101245: GO 101247
101247: DISABLE
101248: LD_INT 0
101250: PPUSH
101251: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101252: LD_ADDR_VAR 0 2
101256: PUSH
101257: LD_INT 22
101259: PUSH
101260: LD_OWVAR 2
101264: PUSH
101265: EMPTY
101266: LIST
101267: LIST
101268: PPUSH
101269: CALL_OW 69
101273: ST_TO_ADDR
// if not tmp then
101274: LD_VAR 0 2
101278: NOT
101279: IFFALSE 101283
// exit ;
101281: GO 101426
// for i := 1 to 2 do
101283: LD_ADDR_VAR 0 1
101287: PUSH
101288: DOUBLE
101289: LD_INT 1
101291: DEC
101292: ST_TO_ADDR
101293: LD_INT 2
101295: PUSH
101296: FOR_TO
101297: IFFALSE 101424
// begin uc_side := your_side ;
101299: LD_ADDR_OWVAR 20
101303: PUSH
101304: LD_OWVAR 2
101308: ST_TO_ADDR
// uc_nation := nation_american ;
101309: LD_ADDR_OWVAR 21
101313: PUSH
101314: LD_INT 1
101316: ST_TO_ADDR
// vc_chassis := us_morphling ;
101317: LD_ADDR_OWVAR 37
101321: PUSH
101322: LD_INT 5
101324: ST_TO_ADDR
// vc_engine := engine_siberite ;
101325: LD_ADDR_OWVAR 39
101329: PUSH
101330: LD_INT 3
101332: ST_TO_ADDR
// vc_control := control_computer ;
101333: LD_ADDR_OWVAR 38
101337: PUSH
101338: LD_INT 3
101340: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101341: LD_ADDR_OWVAR 40
101345: PUSH
101346: LD_INT 10
101348: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101349: LD_VAR 0 2
101353: PUSH
101354: LD_INT 1
101356: ARRAY
101357: PPUSH
101358: CALL_OW 310
101362: NOT
101363: IFFALSE 101410
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101365: CALL_OW 45
101369: PPUSH
101370: LD_VAR 0 2
101374: PUSH
101375: LD_INT 1
101377: ARRAY
101378: PPUSH
101379: CALL_OW 250
101383: PPUSH
101384: LD_VAR 0 2
101388: PUSH
101389: LD_INT 1
101391: ARRAY
101392: PPUSH
101393: CALL_OW 251
101397: PPUSH
101398: LD_INT 12
101400: PPUSH
101401: LD_INT 1
101403: PPUSH
101404: CALL_OW 50
101408: GO 101422
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101410: CALL_OW 45
101414: PPUSH
101415: LD_INT 1
101417: PPUSH
101418: CALL_OW 51
// end ;
101422: GO 101296
101424: POP
101425: POP
// end ;
101426: PPOPN 2
101428: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101429: LD_EXP 94
101433: PUSH
101434: LD_EXP 140
101438: AND
101439: IFFALSE 101661
101441: GO 101443
101443: DISABLE
101444: LD_INT 0
101446: PPUSH
101447: PPUSH
101448: PPUSH
101449: PPUSH
101450: PPUSH
101451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101452: LD_ADDR_VAR 0 6
101456: PUSH
101457: LD_INT 22
101459: PUSH
101460: LD_OWVAR 2
101464: PUSH
101465: EMPTY
101466: LIST
101467: LIST
101468: PUSH
101469: LD_INT 21
101471: PUSH
101472: LD_INT 1
101474: PUSH
101475: EMPTY
101476: LIST
101477: LIST
101478: PUSH
101479: LD_INT 3
101481: PUSH
101482: LD_INT 23
101484: PUSH
101485: LD_INT 0
101487: PUSH
101488: EMPTY
101489: LIST
101490: LIST
101491: PUSH
101492: EMPTY
101493: LIST
101494: LIST
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: LIST
101500: PPUSH
101501: CALL_OW 69
101505: ST_TO_ADDR
// if not tmp then
101506: LD_VAR 0 6
101510: NOT
101511: IFFALSE 101515
// exit ;
101513: GO 101661
// s1 := rand ( 1 , 4 ) ;
101515: LD_ADDR_VAR 0 2
101519: PUSH
101520: LD_INT 1
101522: PPUSH
101523: LD_INT 4
101525: PPUSH
101526: CALL_OW 12
101530: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101531: LD_ADDR_VAR 0 4
101535: PUSH
101536: LD_VAR 0 6
101540: PUSH
101541: LD_INT 1
101543: ARRAY
101544: PPUSH
101545: LD_VAR 0 2
101549: PPUSH
101550: CALL_OW 259
101554: ST_TO_ADDR
// if s1 = 1 then
101555: LD_VAR 0 2
101559: PUSH
101560: LD_INT 1
101562: EQUAL
101563: IFFALSE 101583
// s2 := rand ( 2 , 4 ) else
101565: LD_ADDR_VAR 0 3
101569: PUSH
101570: LD_INT 2
101572: PPUSH
101573: LD_INT 4
101575: PPUSH
101576: CALL_OW 12
101580: ST_TO_ADDR
101581: GO 101591
// s2 := 1 ;
101583: LD_ADDR_VAR 0 3
101587: PUSH
101588: LD_INT 1
101590: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101591: LD_ADDR_VAR 0 5
101595: PUSH
101596: LD_VAR 0 6
101600: PUSH
101601: LD_INT 1
101603: ARRAY
101604: PPUSH
101605: LD_VAR 0 3
101609: PPUSH
101610: CALL_OW 259
101614: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101615: LD_VAR 0 6
101619: PUSH
101620: LD_INT 1
101622: ARRAY
101623: PPUSH
101624: LD_VAR 0 2
101628: PPUSH
101629: LD_VAR 0 5
101633: PPUSH
101634: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101638: LD_VAR 0 6
101642: PUSH
101643: LD_INT 1
101645: ARRAY
101646: PPUSH
101647: LD_VAR 0 3
101651: PPUSH
101652: LD_VAR 0 4
101656: PPUSH
101657: CALL_OW 237
// end ;
101661: PPOPN 6
101663: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101664: LD_EXP 94
101668: PUSH
101669: LD_EXP 141
101673: AND
101674: IFFALSE 101753
101676: GO 101678
101678: DISABLE
101679: LD_INT 0
101681: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101682: LD_ADDR_VAR 0 1
101686: PUSH
101687: LD_INT 22
101689: PUSH
101690: LD_OWVAR 2
101694: PUSH
101695: EMPTY
101696: LIST
101697: LIST
101698: PUSH
101699: LD_INT 30
101701: PUSH
101702: LD_INT 3
101704: PUSH
101705: EMPTY
101706: LIST
101707: LIST
101708: PUSH
101709: EMPTY
101710: LIST
101711: LIST
101712: PPUSH
101713: CALL_OW 69
101717: ST_TO_ADDR
// if not tmp then
101718: LD_VAR 0 1
101722: NOT
101723: IFFALSE 101727
// exit ;
101725: GO 101753
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101727: LD_VAR 0 1
101731: PUSH
101732: LD_INT 1
101734: PPUSH
101735: LD_VAR 0 1
101739: PPUSH
101740: CALL_OW 12
101744: ARRAY
101745: PPUSH
101746: LD_INT 1
101748: PPUSH
101749: CALL_OW 234
// end ;
101753: PPOPN 1
101755: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101756: LD_EXP 94
101760: PUSH
101761: LD_EXP 142
101765: AND
101766: IFFALSE 101878
101768: GO 101770
101770: DISABLE
101771: LD_INT 0
101773: PPUSH
101774: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101775: LD_ADDR_VAR 0 2
101779: PUSH
101780: LD_INT 22
101782: PUSH
101783: LD_OWVAR 2
101787: PUSH
101788: EMPTY
101789: LIST
101790: LIST
101791: PUSH
101792: LD_INT 2
101794: PUSH
101795: LD_INT 30
101797: PUSH
101798: LD_INT 27
101800: PUSH
101801: EMPTY
101802: LIST
101803: LIST
101804: PUSH
101805: LD_INT 30
101807: PUSH
101808: LD_INT 26
101810: PUSH
101811: EMPTY
101812: LIST
101813: LIST
101814: PUSH
101815: LD_INT 30
101817: PUSH
101818: LD_INT 28
101820: PUSH
101821: EMPTY
101822: LIST
101823: LIST
101824: PUSH
101825: EMPTY
101826: LIST
101827: LIST
101828: LIST
101829: LIST
101830: PUSH
101831: EMPTY
101832: LIST
101833: LIST
101834: PPUSH
101835: CALL_OW 69
101839: ST_TO_ADDR
// if not tmp then
101840: LD_VAR 0 2
101844: NOT
101845: IFFALSE 101849
// exit ;
101847: GO 101878
// for i in tmp do
101849: LD_ADDR_VAR 0 1
101853: PUSH
101854: LD_VAR 0 2
101858: PUSH
101859: FOR_IN
101860: IFFALSE 101876
// SetLives ( i , 1 ) ;
101862: LD_VAR 0 1
101866: PPUSH
101867: LD_INT 1
101869: PPUSH
101870: CALL_OW 234
101874: GO 101859
101876: POP
101877: POP
// end ;
101878: PPOPN 2
101880: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101881: LD_EXP 94
101885: PUSH
101886: LD_EXP 143
101890: AND
101891: IFFALSE 102178
101893: GO 101895
101895: DISABLE
101896: LD_INT 0
101898: PPUSH
101899: PPUSH
101900: PPUSH
// begin i := rand ( 1 , 7 ) ;
101901: LD_ADDR_VAR 0 1
101905: PUSH
101906: LD_INT 1
101908: PPUSH
101909: LD_INT 7
101911: PPUSH
101912: CALL_OW 12
101916: ST_TO_ADDR
// case i of 1 :
101917: LD_VAR 0 1
101921: PUSH
101922: LD_INT 1
101924: DOUBLE
101925: EQUAL
101926: IFTRUE 101930
101928: GO 101940
101930: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101931: LD_STRING earthquake(getX(game), 0, 32)
101933: PPUSH
101934: CALL_OW 559
101938: GO 102178
101940: LD_INT 2
101942: DOUBLE
101943: EQUAL
101944: IFTRUE 101948
101946: GO 101962
101948: POP
// begin ToLua ( displayStucuk(); ) ;
101949: LD_STRING displayStucuk();
101951: PPUSH
101952: CALL_OW 559
// ResetFog ;
101956: CALL_OW 335
// end ; 3 :
101960: GO 102178
101962: LD_INT 3
101964: DOUBLE
101965: EQUAL
101966: IFTRUE 101970
101968: GO 102074
101970: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101971: LD_ADDR_VAR 0 2
101975: PUSH
101976: LD_INT 22
101978: PUSH
101979: LD_OWVAR 2
101983: PUSH
101984: EMPTY
101985: LIST
101986: LIST
101987: PUSH
101988: LD_INT 25
101990: PUSH
101991: LD_INT 1
101993: PUSH
101994: EMPTY
101995: LIST
101996: LIST
101997: PUSH
101998: EMPTY
101999: LIST
102000: LIST
102001: PPUSH
102002: CALL_OW 69
102006: ST_TO_ADDR
// if not tmp then
102007: LD_VAR 0 2
102011: NOT
102012: IFFALSE 102016
// exit ;
102014: GO 102178
// un := tmp [ rand ( 1 , tmp ) ] ;
102016: LD_ADDR_VAR 0 3
102020: PUSH
102021: LD_VAR 0 2
102025: PUSH
102026: LD_INT 1
102028: PPUSH
102029: LD_VAR 0 2
102033: PPUSH
102034: CALL_OW 12
102038: ARRAY
102039: ST_TO_ADDR
// if Crawls ( un ) then
102040: LD_VAR 0 3
102044: PPUSH
102045: CALL_OW 318
102049: IFFALSE 102060
// ComWalk ( un ) ;
102051: LD_VAR 0 3
102055: PPUSH
102056: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102060: LD_VAR 0 3
102064: PPUSH
102065: LD_INT 8
102067: PPUSH
102068: CALL_OW 336
// end ; 4 :
102072: GO 102178
102074: LD_INT 4
102076: DOUBLE
102077: EQUAL
102078: IFTRUE 102082
102080: GO 102156
102082: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102083: LD_ADDR_VAR 0 2
102087: PUSH
102088: LD_INT 22
102090: PUSH
102091: LD_OWVAR 2
102095: PUSH
102096: EMPTY
102097: LIST
102098: LIST
102099: PUSH
102100: LD_INT 30
102102: PUSH
102103: LD_INT 29
102105: PUSH
102106: EMPTY
102107: LIST
102108: LIST
102109: PUSH
102110: EMPTY
102111: LIST
102112: LIST
102113: PPUSH
102114: CALL_OW 69
102118: ST_TO_ADDR
// if not tmp then
102119: LD_VAR 0 2
102123: NOT
102124: IFFALSE 102128
// exit ;
102126: GO 102178
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102128: LD_VAR 0 2
102132: PUSH
102133: LD_INT 1
102135: ARRAY
102136: PPUSH
102137: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102141: LD_VAR 0 2
102145: PUSH
102146: LD_INT 1
102148: ARRAY
102149: PPUSH
102150: CALL_OW 65
// end ; 5 .. 7 :
102154: GO 102178
102156: LD_INT 5
102158: DOUBLE
102159: GREATEREQUAL
102160: IFFALSE 102168
102162: LD_INT 7
102164: DOUBLE
102165: LESSEQUAL
102166: IFTRUE 102170
102168: GO 102177
102170: POP
// StreamSibBomb ; end ;
102171: CALL 98415 0 0
102175: GO 102178
102177: POP
// end ;
102178: PPOPN 3
102180: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102181: LD_EXP 94
102185: PUSH
102186: LD_EXP 144
102190: AND
102191: IFFALSE 102347
102193: GO 102195
102195: DISABLE
102196: LD_INT 0
102198: PPUSH
102199: PPUSH
102200: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102201: LD_ADDR_VAR 0 2
102205: PUSH
102206: LD_INT 81
102208: PUSH
102209: LD_OWVAR 2
102213: PUSH
102214: EMPTY
102215: LIST
102216: LIST
102217: PUSH
102218: LD_INT 2
102220: PUSH
102221: LD_INT 21
102223: PUSH
102224: LD_INT 1
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: PUSH
102231: LD_INT 21
102233: PUSH
102234: LD_INT 2
102236: PUSH
102237: EMPTY
102238: LIST
102239: LIST
102240: PUSH
102241: EMPTY
102242: LIST
102243: LIST
102244: LIST
102245: PUSH
102246: EMPTY
102247: LIST
102248: LIST
102249: PPUSH
102250: CALL_OW 69
102254: ST_TO_ADDR
// if not tmp then
102255: LD_VAR 0 2
102259: NOT
102260: IFFALSE 102264
// exit ;
102262: GO 102347
// p := 0 ;
102264: LD_ADDR_VAR 0 3
102268: PUSH
102269: LD_INT 0
102271: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102272: LD_INT 35
102274: PPUSH
102275: CALL_OW 67
// p := p + 1 ;
102279: LD_ADDR_VAR 0 3
102283: PUSH
102284: LD_VAR 0 3
102288: PUSH
102289: LD_INT 1
102291: PLUS
102292: ST_TO_ADDR
// for i in tmp do
102293: LD_ADDR_VAR 0 1
102297: PUSH
102298: LD_VAR 0 2
102302: PUSH
102303: FOR_IN
102304: IFFALSE 102335
// if GetLives ( i ) < 1000 then
102306: LD_VAR 0 1
102310: PPUSH
102311: CALL_OW 256
102315: PUSH
102316: LD_INT 1000
102318: LESS
102319: IFFALSE 102333
// SetLives ( i , 1000 ) ;
102321: LD_VAR 0 1
102325: PPUSH
102326: LD_INT 1000
102328: PPUSH
102329: CALL_OW 234
102333: GO 102303
102335: POP
102336: POP
// until p > 20 ;
102337: LD_VAR 0 3
102341: PUSH
102342: LD_INT 20
102344: GREATER
102345: IFFALSE 102272
// end ;
102347: PPOPN 3
102349: END
// every 0 0$1 trigger StreamModeActive and sTime do
102350: LD_EXP 94
102354: PUSH
102355: LD_EXP 145
102359: AND
102360: IFFALSE 102395
102362: GO 102364
102364: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102365: LD_INT 28
102367: PPUSH
102368: LD_OWVAR 2
102372: PPUSH
102373: LD_INT 2
102375: PPUSH
102376: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102380: LD_INT 30
102382: PPUSH
102383: LD_OWVAR 2
102387: PPUSH
102388: LD_INT 2
102390: PPUSH
102391: CALL_OW 322
// end ;
102395: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102396: LD_EXP 94
102400: PUSH
102401: LD_EXP 146
102405: AND
102406: IFFALSE 102527
102408: GO 102410
102410: DISABLE
102411: LD_INT 0
102413: PPUSH
102414: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102415: LD_ADDR_VAR 0 2
102419: PUSH
102420: LD_INT 22
102422: PUSH
102423: LD_OWVAR 2
102427: PUSH
102428: EMPTY
102429: LIST
102430: LIST
102431: PUSH
102432: LD_INT 21
102434: PUSH
102435: LD_INT 1
102437: PUSH
102438: EMPTY
102439: LIST
102440: LIST
102441: PUSH
102442: LD_INT 3
102444: PUSH
102445: LD_INT 23
102447: PUSH
102448: LD_INT 0
102450: PUSH
102451: EMPTY
102452: LIST
102453: LIST
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: PUSH
102459: EMPTY
102460: LIST
102461: LIST
102462: LIST
102463: PPUSH
102464: CALL_OW 69
102468: ST_TO_ADDR
// if not tmp then
102469: LD_VAR 0 2
102473: NOT
102474: IFFALSE 102478
// exit ;
102476: GO 102527
// for i in tmp do
102478: LD_ADDR_VAR 0 1
102482: PUSH
102483: LD_VAR 0 2
102487: PUSH
102488: FOR_IN
102489: IFFALSE 102525
// begin if Crawls ( i ) then
102491: LD_VAR 0 1
102495: PPUSH
102496: CALL_OW 318
102500: IFFALSE 102511
// ComWalk ( i ) ;
102502: LD_VAR 0 1
102506: PPUSH
102507: CALL_OW 138
// SetClass ( i , 2 ) ;
102511: LD_VAR 0 1
102515: PPUSH
102516: LD_INT 2
102518: PPUSH
102519: CALL_OW 336
// end ;
102523: GO 102488
102525: POP
102526: POP
// end ;
102527: PPOPN 2
102529: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102530: LD_EXP 94
102534: PUSH
102535: LD_EXP 147
102539: AND
102540: IFFALSE 102828
102542: GO 102544
102544: DISABLE
102545: LD_INT 0
102547: PPUSH
102548: PPUSH
102549: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102550: LD_OWVAR 2
102554: PPUSH
102555: LD_INT 9
102557: PPUSH
102558: LD_INT 1
102560: PPUSH
102561: LD_INT 1
102563: PPUSH
102564: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102568: LD_INT 9
102570: PPUSH
102571: LD_OWVAR 2
102575: PPUSH
102576: CALL_OW 343
// uc_side := 9 ;
102580: LD_ADDR_OWVAR 20
102584: PUSH
102585: LD_INT 9
102587: ST_TO_ADDR
// uc_nation := 2 ;
102588: LD_ADDR_OWVAR 21
102592: PUSH
102593: LD_INT 2
102595: ST_TO_ADDR
// hc_name := Dark Warrior ;
102596: LD_ADDR_OWVAR 26
102600: PUSH
102601: LD_STRING Dark Warrior
102603: ST_TO_ADDR
// hc_gallery :=  ;
102604: LD_ADDR_OWVAR 33
102608: PUSH
102609: LD_STRING 
102611: ST_TO_ADDR
// hc_noskilllimit := true ;
102612: LD_ADDR_OWVAR 76
102616: PUSH
102617: LD_INT 1
102619: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102620: LD_ADDR_OWVAR 31
102624: PUSH
102625: LD_INT 30
102627: PUSH
102628: LD_INT 30
102630: PUSH
102631: LD_INT 30
102633: PUSH
102634: LD_INT 30
102636: PUSH
102637: EMPTY
102638: LIST
102639: LIST
102640: LIST
102641: LIST
102642: ST_TO_ADDR
// un := CreateHuman ;
102643: LD_ADDR_VAR 0 3
102647: PUSH
102648: CALL_OW 44
102652: ST_TO_ADDR
// hc_noskilllimit := false ;
102653: LD_ADDR_OWVAR 76
102657: PUSH
102658: LD_INT 0
102660: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102661: LD_VAR 0 3
102665: PPUSH
102666: LD_INT 1
102668: PPUSH
102669: CALL_OW 51
// ToLua ( playRanger() ) ;
102673: LD_STRING playRanger()
102675: PPUSH
102676: CALL_OW 559
// p := 0 ;
102680: LD_ADDR_VAR 0 2
102684: PUSH
102685: LD_INT 0
102687: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102688: LD_INT 35
102690: PPUSH
102691: CALL_OW 67
// p := p + 1 ;
102695: LD_ADDR_VAR 0 2
102699: PUSH
102700: LD_VAR 0 2
102704: PUSH
102705: LD_INT 1
102707: PLUS
102708: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102709: LD_VAR 0 3
102713: PPUSH
102714: CALL_OW 256
102718: PUSH
102719: LD_INT 1000
102721: LESS
102722: IFFALSE 102736
// SetLives ( un , 1000 ) ;
102724: LD_VAR 0 3
102728: PPUSH
102729: LD_INT 1000
102731: PPUSH
102732: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102736: LD_VAR 0 3
102740: PPUSH
102741: LD_INT 81
102743: PUSH
102744: LD_OWVAR 2
102748: PUSH
102749: EMPTY
102750: LIST
102751: LIST
102752: PUSH
102753: LD_INT 91
102755: PUSH
102756: LD_VAR 0 3
102760: PUSH
102761: LD_INT 30
102763: PUSH
102764: EMPTY
102765: LIST
102766: LIST
102767: LIST
102768: PUSH
102769: EMPTY
102770: LIST
102771: LIST
102772: PPUSH
102773: CALL_OW 69
102777: PPUSH
102778: LD_VAR 0 3
102782: PPUSH
102783: CALL_OW 74
102787: PPUSH
102788: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102792: LD_VAR 0 2
102796: PUSH
102797: LD_INT 80
102799: GREATER
102800: PUSH
102801: LD_VAR 0 3
102805: PPUSH
102806: CALL_OW 301
102810: OR
102811: IFFALSE 102688
// if un then
102813: LD_VAR 0 3
102817: IFFALSE 102828
// RemoveUnit ( un ) ;
102819: LD_VAR 0 3
102823: PPUSH
102824: CALL_OW 64
// end ;
102828: PPOPN 3
102830: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102831: LD_EXP 148
102835: IFFALSE 102951
102837: GO 102839
102839: DISABLE
102840: LD_INT 0
102842: PPUSH
102843: PPUSH
102844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102845: LD_ADDR_VAR 0 2
102849: PUSH
102850: LD_INT 81
102852: PUSH
102853: LD_OWVAR 2
102857: PUSH
102858: EMPTY
102859: LIST
102860: LIST
102861: PUSH
102862: LD_INT 21
102864: PUSH
102865: LD_INT 1
102867: PUSH
102868: EMPTY
102869: LIST
102870: LIST
102871: PUSH
102872: EMPTY
102873: LIST
102874: LIST
102875: PPUSH
102876: CALL_OW 69
102880: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102881: LD_STRING playComputer()
102883: PPUSH
102884: CALL_OW 559
// if not tmp then
102888: LD_VAR 0 2
102892: NOT
102893: IFFALSE 102897
// exit ;
102895: GO 102951
// for i in tmp do
102897: LD_ADDR_VAR 0 1
102901: PUSH
102902: LD_VAR 0 2
102906: PUSH
102907: FOR_IN
102908: IFFALSE 102949
// for j := 1 to 4 do
102910: LD_ADDR_VAR 0 3
102914: PUSH
102915: DOUBLE
102916: LD_INT 1
102918: DEC
102919: ST_TO_ADDR
102920: LD_INT 4
102922: PUSH
102923: FOR_TO
102924: IFFALSE 102945
// SetSkill ( i , j , 10 ) ;
102926: LD_VAR 0 1
102930: PPUSH
102931: LD_VAR 0 3
102935: PPUSH
102936: LD_INT 10
102938: PPUSH
102939: CALL_OW 237
102943: GO 102923
102945: POP
102946: POP
102947: GO 102907
102949: POP
102950: POP
// end ;
102951: PPOPN 3
102953: END
// every 0 0$1 trigger s30 do var i , tmp ;
102954: LD_EXP 149
102958: IFFALSE 103027
102960: GO 102962
102962: DISABLE
102963: LD_INT 0
102965: PPUSH
102966: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102967: LD_ADDR_VAR 0 2
102971: PUSH
102972: LD_INT 22
102974: PUSH
102975: LD_OWVAR 2
102979: PUSH
102980: EMPTY
102981: LIST
102982: LIST
102983: PPUSH
102984: CALL_OW 69
102988: ST_TO_ADDR
// if not tmp then
102989: LD_VAR 0 2
102993: NOT
102994: IFFALSE 102998
// exit ;
102996: GO 103027
// for i in tmp do
102998: LD_ADDR_VAR 0 1
103002: PUSH
103003: LD_VAR 0 2
103007: PUSH
103008: FOR_IN
103009: IFFALSE 103025
// SetLives ( i , 300 ) ;
103011: LD_VAR 0 1
103015: PPUSH
103016: LD_INT 300
103018: PPUSH
103019: CALL_OW 234
103023: GO 103008
103025: POP
103026: POP
// end ;
103027: PPOPN 2
103029: END
// every 0 0$1 trigger s60 do var i , tmp ;
103030: LD_EXP 150
103034: IFFALSE 103103
103036: GO 103038
103038: DISABLE
103039: LD_INT 0
103041: PPUSH
103042: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103043: LD_ADDR_VAR 0 2
103047: PUSH
103048: LD_INT 22
103050: PUSH
103051: LD_OWVAR 2
103055: PUSH
103056: EMPTY
103057: LIST
103058: LIST
103059: PPUSH
103060: CALL_OW 69
103064: ST_TO_ADDR
// if not tmp then
103065: LD_VAR 0 2
103069: NOT
103070: IFFALSE 103074
// exit ;
103072: GO 103103
// for i in tmp do
103074: LD_ADDR_VAR 0 1
103078: PUSH
103079: LD_VAR 0 2
103083: PUSH
103084: FOR_IN
103085: IFFALSE 103101
// SetLives ( i , 600 ) ;
103087: LD_VAR 0 1
103091: PPUSH
103092: LD_INT 600
103094: PPUSH
103095: CALL_OW 234
103099: GO 103084
103101: POP
103102: POP
// end ;
103103: PPOPN 2
103105: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103106: LD_INT 0
103108: PPUSH
// case cmd of 301 :
103109: LD_VAR 0 1
103113: PUSH
103114: LD_INT 301
103116: DOUBLE
103117: EQUAL
103118: IFTRUE 103122
103120: GO 103154
103122: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103123: LD_VAR 0 6
103127: PPUSH
103128: LD_VAR 0 7
103132: PPUSH
103133: LD_VAR 0 8
103137: PPUSH
103138: LD_VAR 0 4
103142: PPUSH
103143: LD_VAR 0 5
103147: PPUSH
103148: CALL 104355 0 5
103152: GO 103275
103154: LD_INT 302
103156: DOUBLE
103157: EQUAL
103158: IFTRUE 103162
103160: GO 103199
103162: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103163: LD_VAR 0 6
103167: PPUSH
103168: LD_VAR 0 7
103172: PPUSH
103173: LD_VAR 0 8
103177: PPUSH
103178: LD_VAR 0 9
103182: PPUSH
103183: LD_VAR 0 4
103187: PPUSH
103188: LD_VAR 0 5
103192: PPUSH
103193: CALL 104446 0 6
103197: GO 103275
103199: LD_INT 303
103201: DOUBLE
103202: EQUAL
103203: IFTRUE 103207
103205: GO 103244
103207: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103208: LD_VAR 0 6
103212: PPUSH
103213: LD_VAR 0 7
103217: PPUSH
103218: LD_VAR 0 8
103222: PPUSH
103223: LD_VAR 0 9
103227: PPUSH
103228: LD_VAR 0 4
103232: PPUSH
103233: LD_VAR 0 5
103237: PPUSH
103238: CALL 103280 0 6
103242: GO 103275
103244: LD_INT 304
103246: DOUBLE
103247: EQUAL
103248: IFTRUE 103252
103250: GO 103274
103252: POP
// hHackTeleport ( unit , x , y ) ; end ;
103253: LD_VAR 0 2
103257: PPUSH
103258: LD_VAR 0 4
103262: PPUSH
103263: LD_VAR 0 5
103267: PPUSH
103268: CALL 105039 0 3
103272: GO 103275
103274: POP
// end ;
103275: LD_VAR 0 12
103279: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103280: LD_INT 0
103282: PPUSH
103283: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103284: LD_VAR 0 1
103288: PUSH
103289: LD_INT 1
103291: LESS
103292: PUSH
103293: LD_VAR 0 1
103297: PUSH
103298: LD_INT 3
103300: GREATER
103301: OR
103302: PUSH
103303: LD_VAR 0 5
103307: PPUSH
103308: LD_VAR 0 6
103312: PPUSH
103313: CALL_OW 428
103317: OR
103318: IFFALSE 103322
// exit ;
103320: GO 104042
// uc_side := your_side ;
103322: LD_ADDR_OWVAR 20
103326: PUSH
103327: LD_OWVAR 2
103331: ST_TO_ADDR
// uc_nation := nation ;
103332: LD_ADDR_OWVAR 21
103336: PUSH
103337: LD_VAR 0 1
103341: ST_TO_ADDR
// bc_level = 1 ;
103342: LD_ADDR_OWVAR 43
103346: PUSH
103347: LD_INT 1
103349: ST_TO_ADDR
// case btype of 1 :
103350: LD_VAR 0 2
103354: PUSH
103355: LD_INT 1
103357: DOUBLE
103358: EQUAL
103359: IFTRUE 103363
103361: GO 103374
103363: POP
// bc_type := b_depot ; 2 :
103364: LD_ADDR_OWVAR 42
103368: PUSH
103369: LD_INT 0
103371: ST_TO_ADDR
103372: GO 103986
103374: LD_INT 2
103376: DOUBLE
103377: EQUAL
103378: IFTRUE 103382
103380: GO 103393
103382: POP
// bc_type := b_warehouse ; 3 :
103383: LD_ADDR_OWVAR 42
103387: PUSH
103388: LD_INT 1
103390: ST_TO_ADDR
103391: GO 103986
103393: LD_INT 3
103395: DOUBLE
103396: EQUAL
103397: IFTRUE 103401
103399: GO 103412
103401: POP
// bc_type := b_lab ; 4 .. 9 :
103402: LD_ADDR_OWVAR 42
103406: PUSH
103407: LD_INT 6
103409: ST_TO_ADDR
103410: GO 103986
103412: LD_INT 4
103414: DOUBLE
103415: GREATEREQUAL
103416: IFFALSE 103424
103418: LD_INT 9
103420: DOUBLE
103421: LESSEQUAL
103422: IFTRUE 103426
103424: GO 103478
103426: POP
// begin bc_type := b_lab_half ;
103427: LD_ADDR_OWVAR 42
103431: PUSH
103432: LD_INT 7
103434: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103435: LD_ADDR_OWVAR 44
103439: PUSH
103440: LD_INT 10
103442: PUSH
103443: LD_INT 11
103445: PUSH
103446: LD_INT 12
103448: PUSH
103449: LD_INT 15
103451: PUSH
103452: LD_INT 14
103454: PUSH
103455: LD_INT 13
103457: PUSH
103458: EMPTY
103459: LIST
103460: LIST
103461: LIST
103462: LIST
103463: LIST
103464: LIST
103465: PUSH
103466: LD_VAR 0 2
103470: PUSH
103471: LD_INT 3
103473: MINUS
103474: ARRAY
103475: ST_TO_ADDR
// end ; 10 .. 13 :
103476: GO 103986
103478: LD_INT 10
103480: DOUBLE
103481: GREATEREQUAL
103482: IFFALSE 103490
103484: LD_INT 13
103486: DOUBLE
103487: LESSEQUAL
103488: IFTRUE 103492
103490: GO 103569
103492: POP
// begin bc_type := b_lab_full ;
103493: LD_ADDR_OWVAR 42
103497: PUSH
103498: LD_INT 8
103500: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103501: LD_ADDR_OWVAR 44
103505: PUSH
103506: LD_INT 10
103508: PUSH
103509: LD_INT 12
103511: PUSH
103512: LD_INT 14
103514: PUSH
103515: LD_INT 13
103517: PUSH
103518: EMPTY
103519: LIST
103520: LIST
103521: LIST
103522: LIST
103523: PUSH
103524: LD_VAR 0 2
103528: PUSH
103529: LD_INT 9
103531: MINUS
103532: ARRAY
103533: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103534: LD_ADDR_OWVAR 45
103538: PUSH
103539: LD_INT 11
103541: PUSH
103542: LD_INT 15
103544: PUSH
103545: LD_INT 12
103547: PUSH
103548: LD_INT 15
103550: PUSH
103551: EMPTY
103552: LIST
103553: LIST
103554: LIST
103555: LIST
103556: PUSH
103557: LD_VAR 0 2
103561: PUSH
103562: LD_INT 9
103564: MINUS
103565: ARRAY
103566: ST_TO_ADDR
// end ; 14 :
103567: GO 103986
103569: LD_INT 14
103571: DOUBLE
103572: EQUAL
103573: IFTRUE 103577
103575: GO 103588
103577: POP
// bc_type := b_workshop ; 15 :
103578: LD_ADDR_OWVAR 42
103582: PUSH
103583: LD_INT 2
103585: ST_TO_ADDR
103586: GO 103986
103588: LD_INT 15
103590: DOUBLE
103591: EQUAL
103592: IFTRUE 103596
103594: GO 103607
103596: POP
// bc_type := b_factory ; 16 :
103597: LD_ADDR_OWVAR 42
103601: PUSH
103602: LD_INT 3
103604: ST_TO_ADDR
103605: GO 103986
103607: LD_INT 16
103609: DOUBLE
103610: EQUAL
103611: IFTRUE 103615
103613: GO 103626
103615: POP
// bc_type := b_ext_gun ; 17 :
103616: LD_ADDR_OWVAR 42
103620: PUSH
103621: LD_INT 17
103623: ST_TO_ADDR
103624: GO 103986
103626: LD_INT 17
103628: DOUBLE
103629: EQUAL
103630: IFTRUE 103634
103632: GO 103662
103634: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103635: LD_ADDR_OWVAR 42
103639: PUSH
103640: LD_INT 19
103642: PUSH
103643: LD_INT 23
103645: PUSH
103646: LD_INT 19
103648: PUSH
103649: EMPTY
103650: LIST
103651: LIST
103652: LIST
103653: PUSH
103654: LD_VAR 0 1
103658: ARRAY
103659: ST_TO_ADDR
103660: GO 103986
103662: LD_INT 18
103664: DOUBLE
103665: EQUAL
103666: IFTRUE 103670
103668: GO 103681
103670: POP
// bc_type := b_ext_radar ; 19 :
103671: LD_ADDR_OWVAR 42
103675: PUSH
103676: LD_INT 20
103678: ST_TO_ADDR
103679: GO 103986
103681: LD_INT 19
103683: DOUBLE
103684: EQUAL
103685: IFTRUE 103689
103687: GO 103700
103689: POP
// bc_type := b_ext_radio ; 20 :
103690: LD_ADDR_OWVAR 42
103694: PUSH
103695: LD_INT 22
103697: ST_TO_ADDR
103698: GO 103986
103700: LD_INT 20
103702: DOUBLE
103703: EQUAL
103704: IFTRUE 103708
103706: GO 103719
103708: POP
// bc_type := b_ext_siberium ; 21 :
103709: LD_ADDR_OWVAR 42
103713: PUSH
103714: LD_INT 21
103716: ST_TO_ADDR
103717: GO 103986
103719: LD_INT 21
103721: DOUBLE
103722: EQUAL
103723: IFTRUE 103727
103725: GO 103738
103727: POP
// bc_type := b_ext_computer ; 22 :
103728: LD_ADDR_OWVAR 42
103732: PUSH
103733: LD_INT 24
103735: ST_TO_ADDR
103736: GO 103986
103738: LD_INT 22
103740: DOUBLE
103741: EQUAL
103742: IFTRUE 103746
103744: GO 103757
103746: POP
// bc_type := b_ext_track ; 23 :
103747: LD_ADDR_OWVAR 42
103751: PUSH
103752: LD_INT 16
103754: ST_TO_ADDR
103755: GO 103986
103757: LD_INT 23
103759: DOUBLE
103760: EQUAL
103761: IFTRUE 103765
103763: GO 103776
103765: POP
// bc_type := b_ext_laser ; 24 :
103766: LD_ADDR_OWVAR 42
103770: PUSH
103771: LD_INT 25
103773: ST_TO_ADDR
103774: GO 103986
103776: LD_INT 24
103778: DOUBLE
103779: EQUAL
103780: IFTRUE 103784
103782: GO 103795
103784: POP
// bc_type := b_control_tower ; 25 :
103785: LD_ADDR_OWVAR 42
103789: PUSH
103790: LD_INT 36
103792: ST_TO_ADDR
103793: GO 103986
103795: LD_INT 25
103797: DOUBLE
103798: EQUAL
103799: IFTRUE 103803
103801: GO 103814
103803: POP
// bc_type := b_breastwork ; 26 :
103804: LD_ADDR_OWVAR 42
103808: PUSH
103809: LD_INT 31
103811: ST_TO_ADDR
103812: GO 103986
103814: LD_INT 26
103816: DOUBLE
103817: EQUAL
103818: IFTRUE 103822
103820: GO 103833
103822: POP
// bc_type := b_bunker ; 27 :
103823: LD_ADDR_OWVAR 42
103827: PUSH
103828: LD_INT 32
103830: ST_TO_ADDR
103831: GO 103986
103833: LD_INT 27
103835: DOUBLE
103836: EQUAL
103837: IFTRUE 103841
103839: GO 103852
103841: POP
// bc_type := b_turret ; 28 :
103842: LD_ADDR_OWVAR 42
103846: PUSH
103847: LD_INT 33
103849: ST_TO_ADDR
103850: GO 103986
103852: LD_INT 28
103854: DOUBLE
103855: EQUAL
103856: IFTRUE 103860
103858: GO 103871
103860: POP
// bc_type := b_armoury ; 29 :
103861: LD_ADDR_OWVAR 42
103865: PUSH
103866: LD_INT 4
103868: ST_TO_ADDR
103869: GO 103986
103871: LD_INT 29
103873: DOUBLE
103874: EQUAL
103875: IFTRUE 103879
103877: GO 103890
103879: POP
// bc_type := b_barracks ; 30 :
103880: LD_ADDR_OWVAR 42
103884: PUSH
103885: LD_INT 5
103887: ST_TO_ADDR
103888: GO 103986
103890: LD_INT 30
103892: DOUBLE
103893: EQUAL
103894: IFTRUE 103898
103896: GO 103909
103898: POP
// bc_type := b_solar_power ; 31 :
103899: LD_ADDR_OWVAR 42
103903: PUSH
103904: LD_INT 27
103906: ST_TO_ADDR
103907: GO 103986
103909: LD_INT 31
103911: DOUBLE
103912: EQUAL
103913: IFTRUE 103917
103915: GO 103928
103917: POP
// bc_type := b_oil_power ; 32 :
103918: LD_ADDR_OWVAR 42
103922: PUSH
103923: LD_INT 26
103925: ST_TO_ADDR
103926: GO 103986
103928: LD_INT 32
103930: DOUBLE
103931: EQUAL
103932: IFTRUE 103936
103934: GO 103947
103936: POP
// bc_type := b_siberite_power ; 33 :
103937: LD_ADDR_OWVAR 42
103941: PUSH
103942: LD_INT 28
103944: ST_TO_ADDR
103945: GO 103986
103947: LD_INT 33
103949: DOUBLE
103950: EQUAL
103951: IFTRUE 103955
103953: GO 103966
103955: POP
// bc_type := b_oil_mine ; 34 :
103956: LD_ADDR_OWVAR 42
103960: PUSH
103961: LD_INT 29
103963: ST_TO_ADDR
103964: GO 103986
103966: LD_INT 34
103968: DOUBLE
103969: EQUAL
103970: IFTRUE 103974
103972: GO 103985
103974: POP
// bc_type := b_siberite_mine ; end ;
103975: LD_ADDR_OWVAR 42
103979: PUSH
103980: LD_INT 30
103982: ST_TO_ADDR
103983: GO 103986
103985: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103986: LD_ADDR_VAR 0 8
103990: PUSH
103991: LD_VAR 0 5
103995: PPUSH
103996: LD_VAR 0 6
104000: PPUSH
104001: LD_VAR 0 3
104005: PPUSH
104006: CALL_OW 47
104010: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104011: LD_OWVAR 42
104015: PUSH
104016: LD_INT 32
104018: PUSH
104019: LD_INT 33
104021: PUSH
104022: EMPTY
104023: LIST
104024: LIST
104025: IN
104026: IFFALSE 104042
// PlaceWeaponTurret ( b , weapon ) ;
104028: LD_VAR 0 8
104032: PPUSH
104033: LD_VAR 0 4
104037: PPUSH
104038: CALL_OW 431
// end ;
104042: LD_VAR 0 7
104046: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104047: LD_INT 0
104049: PPUSH
104050: PPUSH
104051: PPUSH
104052: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104053: LD_ADDR_VAR 0 4
104057: PUSH
104058: LD_INT 22
104060: PUSH
104061: LD_OWVAR 2
104065: PUSH
104066: EMPTY
104067: LIST
104068: LIST
104069: PUSH
104070: LD_INT 2
104072: PUSH
104073: LD_INT 30
104075: PUSH
104076: LD_INT 0
104078: PUSH
104079: EMPTY
104080: LIST
104081: LIST
104082: PUSH
104083: LD_INT 30
104085: PUSH
104086: LD_INT 1
104088: PUSH
104089: EMPTY
104090: LIST
104091: LIST
104092: PUSH
104093: EMPTY
104094: LIST
104095: LIST
104096: LIST
104097: PUSH
104098: EMPTY
104099: LIST
104100: LIST
104101: PPUSH
104102: CALL_OW 69
104106: ST_TO_ADDR
// if not tmp then
104107: LD_VAR 0 4
104111: NOT
104112: IFFALSE 104116
// exit ;
104114: GO 104175
// for i in tmp do
104116: LD_ADDR_VAR 0 2
104120: PUSH
104121: LD_VAR 0 4
104125: PUSH
104126: FOR_IN
104127: IFFALSE 104173
// for j = 1 to 3 do
104129: LD_ADDR_VAR 0 3
104133: PUSH
104134: DOUBLE
104135: LD_INT 1
104137: DEC
104138: ST_TO_ADDR
104139: LD_INT 3
104141: PUSH
104142: FOR_TO
104143: IFFALSE 104169
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104145: LD_VAR 0 2
104149: PPUSH
104150: CALL_OW 274
104154: PPUSH
104155: LD_VAR 0 3
104159: PPUSH
104160: LD_INT 99999
104162: PPUSH
104163: CALL_OW 277
104167: GO 104142
104169: POP
104170: POP
104171: GO 104126
104173: POP
104174: POP
// end ;
104175: LD_VAR 0 1
104179: RET
// export function hHackSetLevel10 ; var i , j ; begin
104180: LD_INT 0
104182: PPUSH
104183: PPUSH
104184: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104185: LD_ADDR_VAR 0 2
104189: PUSH
104190: LD_INT 21
104192: PUSH
104193: LD_INT 1
104195: PUSH
104196: EMPTY
104197: LIST
104198: LIST
104199: PPUSH
104200: CALL_OW 69
104204: PUSH
104205: FOR_IN
104206: IFFALSE 104258
// if IsSelected ( i ) then
104208: LD_VAR 0 2
104212: PPUSH
104213: CALL_OW 306
104217: IFFALSE 104256
// begin for j := 1 to 4 do
104219: LD_ADDR_VAR 0 3
104223: PUSH
104224: DOUBLE
104225: LD_INT 1
104227: DEC
104228: ST_TO_ADDR
104229: LD_INT 4
104231: PUSH
104232: FOR_TO
104233: IFFALSE 104254
// SetSkill ( i , j , 10 ) ;
104235: LD_VAR 0 2
104239: PPUSH
104240: LD_VAR 0 3
104244: PPUSH
104245: LD_INT 10
104247: PPUSH
104248: CALL_OW 237
104252: GO 104232
104254: POP
104255: POP
// end ;
104256: GO 104205
104258: POP
104259: POP
// end ;
104260: LD_VAR 0 1
104264: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104265: LD_INT 0
104267: PPUSH
104268: PPUSH
104269: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104270: LD_ADDR_VAR 0 2
104274: PUSH
104275: LD_INT 22
104277: PUSH
104278: LD_OWVAR 2
104282: PUSH
104283: EMPTY
104284: LIST
104285: LIST
104286: PUSH
104287: LD_INT 21
104289: PUSH
104290: LD_INT 1
104292: PUSH
104293: EMPTY
104294: LIST
104295: LIST
104296: PUSH
104297: EMPTY
104298: LIST
104299: LIST
104300: PPUSH
104301: CALL_OW 69
104305: PUSH
104306: FOR_IN
104307: IFFALSE 104348
// begin for j := 1 to 4 do
104309: LD_ADDR_VAR 0 3
104313: PUSH
104314: DOUBLE
104315: LD_INT 1
104317: DEC
104318: ST_TO_ADDR
104319: LD_INT 4
104321: PUSH
104322: FOR_TO
104323: IFFALSE 104344
// SetSkill ( i , j , 10 ) ;
104325: LD_VAR 0 2
104329: PPUSH
104330: LD_VAR 0 3
104334: PPUSH
104335: LD_INT 10
104337: PPUSH
104338: CALL_OW 237
104342: GO 104322
104344: POP
104345: POP
// end ;
104346: GO 104306
104348: POP
104349: POP
// end ;
104350: LD_VAR 0 1
104354: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104355: LD_INT 0
104357: PPUSH
// uc_side := your_side ;
104358: LD_ADDR_OWVAR 20
104362: PUSH
104363: LD_OWVAR 2
104367: ST_TO_ADDR
// uc_nation := nation ;
104368: LD_ADDR_OWVAR 21
104372: PUSH
104373: LD_VAR 0 1
104377: ST_TO_ADDR
// InitHc ;
104378: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104382: LD_INT 0
104384: PPUSH
104385: LD_VAR 0 2
104389: PPUSH
104390: LD_VAR 0 3
104394: PPUSH
104395: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104399: LD_VAR 0 4
104403: PPUSH
104404: LD_VAR 0 5
104408: PPUSH
104409: CALL_OW 428
104413: PUSH
104414: LD_INT 0
104416: EQUAL
104417: IFFALSE 104441
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104419: CALL_OW 44
104423: PPUSH
104424: LD_VAR 0 4
104428: PPUSH
104429: LD_VAR 0 5
104433: PPUSH
104434: LD_INT 1
104436: PPUSH
104437: CALL_OW 48
// end ;
104441: LD_VAR 0 6
104445: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104446: LD_INT 0
104448: PPUSH
104449: PPUSH
// uc_side := your_side ;
104450: LD_ADDR_OWVAR 20
104454: PUSH
104455: LD_OWVAR 2
104459: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104460: LD_VAR 0 1
104464: PUSH
104465: LD_INT 1
104467: PUSH
104468: LD_INT 2
104470: PUSH
104471: LD_INT 3
104473: PUSH
104474: LD_INT 4
104476: PUSH
104477: LD_INT 5
104479: PUSH
104480: EMPTY
104481: LIST
104482: LIST
104483: LIST
104484: LIST
104485: LIST
104486: IN
104487: IFFALSE 104499
// uc_nation := nation_american else
104489: LD_ADDR_OWVAR 21
104493: PUSH
104494: LD_INT 1
104496: ST_TO_ADDR
104497: GO 104542
// if chassis in [ 11 , 12 , 13 , 14 ] then
104499: LD_VAR 0 1
104503: PUSH
104504: LD_INT 11
104506: PUSH
104507: LD_INT 12
104509: PUSH
104510: LD_INT 13
104512: PUSH
104513: LD_INT 14
104515: PUSH
104516: EMPTY
104517: LIST
104518: LIST
104519: LIST
104520: LIST
104521: IN
104522: IFFALSE 104534
// uc_nation := nation_arabian else
104524: LD_ADDR_OWVAR 21
104528: PUSH
104529: LD_INT 2
104531: ST_TO_ADDR
104532: GO 104542
// uc_nation := nation_russian ;
104534: LD_ADDR_OWVAR 21
104538: PUSH
104539: LD_INT 3
104541: ST_TO_ADDR
// vc_chassis := chassis ;
104542: LD_ADDR_OWVAR 37
104546: PUSH
104547: LD_VAR 0 1
104551: ST_TO_ADDR
// vc_engine := engine ;
104552: LD_ADDR_OWVAR 39
104556: PUSH
104557: LD_VAR 0 2
104561: ST_TO_ADDR
// vc_control := control ;
104562: LD_ADDR_OWVAR 38
104566: PUSH
104567: LD_VAR 0 3
104571: ST_TO_ADDR
// vc_weapon := weapon ;
104572: LD_ADDR_OWVAR 40
104576: PUSH
104577: LD_VAR 0 4
104581: ST_TO_ADDR
// un := CreateVehicle ;
104582: LD_ADDR_VAR 0 8
104586: PUSH
104587: CALL_OW 45
104591: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104592: LD_VAR 0 8
104596: PPUSH
104597: LD_INT 0
104599: PPUSH
104600: LD_INT 5
104602: PPUSH
104603: CALL_OW 12
104607: PPUSH
104608: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104612: LD_VAR 0 8
104616: PPUSH
104617: LD_VAR 0 5
104621: PPUSH
104622: LD_VAR 0 6
104626: PPUSH
104627: LD_INT 1
104629: PPUSH
104630: CALL_OW 48
// end ;
104634: LD_VAR 0 7
104638: RET
// export hInvincible ; every 1 do
104639: GO 104641
104641: DISABLE
// hInvincible := [ ] ;
104642: LD_ADDR_EXP 151
104646: PUSH
104647: EMPTY
104648: ST_TO_ADDR
104649: END
// every 10 do var i ;
104650: GO 104652
104652: DISABLE
104653: LD_INT 0
104655: PPUSH
// begin enable ;
104656: ENABLE
// if not hInvincible then
104657: LD_EXP 151
104661: NOT
104662: IFFALSE 104666
// exit ;
104664: GO 104710
// for i in hInvincible do
104666: LD_ADDR_VAR 0 1
104670: PUSH
104671: LD_EXP 151
104675: PUSH
104676: FOR_IN
104677: IFFALSE 104708
// if GetLives ( i ) < 1000 then
104679: LD_VAR 0 1
104683: PPUSH
104684: CALL_OW 256
104688: PUSH
104689: LD_INT 1000
104691: LESS
104692: IFFALSE 104706
// SetLives ( i , 1000 ) ;
104694: LD_VAR 0 1
104698: PPUSH
104699: LD_INT 1000
104701: PPUSH
104702: CALL_OW 234
104706: GO 104676
104708: POP
104709: POP
// end ;
104710: PPOPN 1
104712: END
// export function hHackInvincible ; var i ; begin
104713: LD_INT 0
104715: PPUSH
104716: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104717: LD_ADDR_VAR 0 2
104721: PUSH
104722: LD_INT 2
104724: PUSH
104725: LD_INT 21
104727: PUSH
104728: LD_INT 1
104730: PUSH
104731: EMPTY
104732: LIST
104733: LIST
104734: PUSH
104735: LD_INT 21
104737: PUSH
104738: LD_INT 2
104740: PUSH
104741: EMPTY
104742: LIST
104743: LIST
104744: PUSH
104745: EMPTY
104746: LIST
104747: LIST
104748: LIST
104749: PPUSH
104750: CALL_OW 69
104754: PUSH
104755: FOR_IN
104756: IFFALSE 104817
// if IsSelected ( i ) then
104758: LD_VAR 0 2
104762: PPUSH
104763: CALL_OW 306
104767: IFFALSE 104815
// begin if i in hInvincible then
104769: LD_VAR 0 2
104773: PUSH
104774: LD_EXP 151
104778: IN
104779: IFFALSE 104799
// hInvincible := hInvincible diff i else
104781: LD_ADDR_EXP 151
104785: PUSH
104786: LD_EXP 151
104790: PUSH
104791: LD_VAR 0 2
104795: DIFF
104796: ST_TO_ADDR
104797: GO 104815
// hInvincible := hInvincible union i ;
104799: LD_ADDR_EXP 151
104803: PUSH
104804: LD_EXP 151
104808: PUSH
104809: LD_VAR 0 2
104813: UNION
104814: ST_TO_ADDR
// end ;
104815: GO 104755
104817: POP
104818: POP
// end ;
104819: LD_VAR 0 1
104823: RET
// export function hHackInvisible ; var i , j ; begin
104824: LD_INT 0
104826: PPUSH
104827: PPUSH
104828: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104829: LD_ADDR_VAR 0 2
104833: PUSH
104834: LD_INT 21
104836: PUSH
104837: LD_INT 1
104839: PUSH
104840: EMPTY
104841: LIST
104842: LIST
104843: PPUSH
104844: CALL_OW 69
104848: PUSH
104849: FOR_IN
104850: IFFALSE 104874
// if IsSelected ( i ) then
104852: LD_VAR 0 2
104856: PPUSH
104857: CALL_OW 306
104861: IFFALSE 104872
// ComForceInvisible ( i ) ;
104863: LD_VAR 0 2
104867: PPUSH
104868: CALL_OW 496
104872: GO 104849
104874: POP
104875: POP
// end ;
104876: LD_VAR 0 1
104880: RET
// export function hHackChangeYourSide ; begin
104881: LD_INT 0
104883: PPUSH
// if your_side = 8 then
104884: LD_OWVAR 2
104888: PUSH
104889: LD_INT 8
104891: EQUAL
104892: IFFALSE 104904
// your_side := 0 else
104894: LD_ADDR_OWVAR 2
104898: PUSH
104899: LD_INT 0
104901: ST_TO_ADDR
104902: GO 104918
// your_side := your_side + 1 ;
104904: LD_ADDR_OWVAR 2
104908: PUSH
104909: LD_OWVAR 2
104913: PUSH
104914: LD_INT 1
104916: PLUS
104917: ST_TO_ADDR
// end ;
104918: LD_VAR 0 1
104922: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104923: LD_INT 0
104925: PPUSH
104926: PPUSH
104927: PPUSH
// for i in all_units do
104928: LD_ADDR_VAR 0 2
104932: PUSH
104933: LD_OWVAR 3
104937: PUSH
104938: FOR_IN
104939: IFFALSE 105017
// if IsSelected ( i ) then
104941: LD_VAR 0 2
104945: PPUSH
104946: CALL_OW 306
104950: IFFALSE 105015
// begin j := GetSide ( i ) ;
104952: LD_ADDR_VAR 0 3
104956: PUSH
104957: LD_VAR 0 2
104961: PPUSH
104962: CALL_OW 255
104966: ST_TO_ADDR
// if j = 8 then
104967: LD_VAR 0 3
104971: PUSH
104972: LD_INT 8
104974: EQUAL
104975: IFFALSE 104987
// j := 0 else
104977: LD_ADDR_VAR 0 3
104981: PUSH
104982: LD_INT 0
104984: ST_TO_ADDR
104985: GO 105001
// j := j + 1 ;
104987: LD_ADDR_VAR 0 3
104991: PUSH
104992: LD_VAR 0 3
104996: PUSH
104997: LD_INT 1
104999: PLUS
105000: ST_TO_ADDR
// SetSide ( i , j ) ;
105001: LD_VAR 0 2
105005: PPUSH
105006: LD_VAR 0 3
105010: PPUSH
105011: CALL_OW 235
// end ;
105015: GO 104938
105017: POP
105018: POP
// end ;
105019: LD_VAR 0 1
105023: RET
// export function hHackFog ; begin
105024: LD_INT 0
105026: PPUSH
// FogOff ( true ) ;
105027: LD_INT 1
105029: PPUSH
105030: CALL_OW 344
// end ;
105034: LD_VAR 0 1
105038: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105039: LD_INT 0
105041: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105042: LD_VAR 0 1
105046: PPUSH
105047: LD_VAR 0 2
105051: PPUSH
105052: LD_VAR 0 3
105056: PPUSH
105057: LD_INT 1
105059: PPUSH
105060: LD_INT 1
105062: PPUSH
105063: CALL_OW 483
// CenterOnXY ( x , y ) ;
105067: LD_VAR 0 2
105071: PPUSH
105072: LD_VAR 0 3
105076: PPUSH
105077: CALL_OW 84
// end ; end_of_file
105081: LD_VAR 0 4
105085: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105086: LD_INT 0
105088: PPUSH
105089: PPUSH
105090: PPUSH
105091: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105092: LD_VAR 0 1
105096: PPUSH
105097: CALL_OW 264
105101: PUSH
105102: LD_EXP 33
105106: EQUAL
105107: IFFALSE 105179
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105109: LD_INT 68
105111: PPUSH
105112: LD_VAR 0 1
105116: PPUSH
105117: CALL_OW 255
105121: PPUSH
105122: CALL_OW 321
105126: PUSH
105127: LD_INT 2
105129: EQUAL
105130: IFFALSE 105142
// eff := 70 else
105132: LD_ADDR_VAR 0 4
105136: PUSH
105137: LD_INT 70
105139: ST_TO_ADDR
105140: GO 105150
// eff := 30 ;
105142: LD_ADDR_VAR 0 4
105146: PUSH
105147: LD_INT 30
105149: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105150: LD_VAR 0 1
105154: PPUSH
105155: CALL_OW 250
105159: PPUSH
105160: LD_VAR 0 1
105164: PPUSH
105165: CALL_OW 251
105169: PPUSH
105170: LD_VAR 0 4
105174: PPUSH
105175: CALL_OW 495
// end ; end ;
105179: LD_VAR 0 2
105183: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105184: LD_INT 0
105186: PPUSH
// end ;
105187: LD_VAR 0 4
105191: RET
// export function SOS_Command ( cmd ) ; begin
105192: LD_INT 0
105194: PPUSH
// end ;
105195: LD_VAR 0 2
105199: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105200: LD_INT 0
105202: PPUSH
// end ;
105203: LD_VAR 0 6
105207: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105208: LD_INT 0
105210: PPUSH
105211: PPUSH
// if not vehicle or not factory then
105212: LD_VAR 0 1
105216: NOT
105217: PUSH
105218: LD_VAR 0 2
105222: NOT
105223: OR
105224: IFFALSE 105228
// exit ;
105226: GO 105459
// if factoryWaypoints >= factory then
105228: LD_EXP 152
105232: PUSH
105233: LD_VAR 0 2
105237: GREATEREQUAL
105238: IFFALSE 105459
// if factoryWaypoints [ factory ] then
105240: LD_EXP 152
105244: PUSH
105245: LD_VAR 0 2
105249: ARRAY
105250: IFFALSE 105459
// begin if GetControl ( vehicle ) = control_manual then
105252: LD_VAR 0 1
105256: PPUSH
105257: CALL_OW 263
105261: PUSH
105262: LD_INT 1
105264: EQUAL
105265: IFFALSE 105346
// begin driver := IsDrivenBy ( vehicle ) ;
105267: LD_ADDR_VAR 0 4
105271: PUSH
105272: LD_VAR 0 1
105276: PPUSH
105277: CALL_OW 311
105281: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
105282: LD_VAR 0 4
105286: PPUSH
105287: LD_EXP 152
105291: PUSH
105292: LD_VAR 0 2
105296: ARRAY
105297: PUSH
105298: LD_INT 1
105300: ARRAY
105301: PPUSH
105302: LD_EXP 152
105306: PUSH
105307: LD_VAR 0 2
105311: ARRAY
105312: PUSH
105313: LD_INT 2
105315: ARRAY
105316: PPUSH
105317: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105321: LD_VAR 0 4
105325: PPUSH
105326: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105330: LD_VAR 0 4
105334: PPUSH
105335: LD_VAR 0 2
105339: PPUSH
105340: CALL_OW 180
// end else
105344: GO 105459
// if GetControl ( vehicle ) = control_remote then
105346: LD_VAR 0 1
105350: PPUSH
105351: CALL_OW 263
105355: PUSH
105356: LD_INT 2
105358: EQUAL
105359: IFFALSE 105420
// begin wait ( 0 0$2 ) ;
105361: LD_INT 70
105363: PPUSH
105364: CALL_OW 67
// if Connect ( vehicle ) then
105368: LD_VAR 0 1
105372: PPUSH
105373: CALL 27829 0 1
105377: IFFALSE 105418
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
105379: LD_VAR 0 1
105383: PPUSH
105384: LD_EXP 152
105388: PUSH
105389: LD_VAR 0 2
105393: ARRAY
105394: PUSH
105395: LD_INT 1
105397: ARRAY
105398: PPUSH
105399: LD_EXP 152
105403: PUSH
105404: LD_VAR 0 2
105408: ARRAY
105409: PUSH
105410: LD_INT 2
105412: ARRAY
105413: PPUSH
105414: CALL_OW 171
// end else
105418: GO 105459
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
105420: LD_VAR 0 1
105424: PPUSH
105425: LD_EXP 152
105429: PUSH
105430: LD_VAR 0 2
105434: ARRAY
105435: PUSH
105436: LD_INT 1
105438: ARRAY
105439: PPUSH
105440: LD_EXP 152
105444: PUSH
105445: LD_VAR 0 2
105449: ARRAY
105450: PUSH
105451: LD_INT 2
105453: ARRAY
105454: PPUSH
105455: CALL_OW 171
// end ; end ;
105459: LD_VAR 0 3
105463: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
105464: LD_INT 0
105466: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
105467: LD_VAR 0 1
105471: PUSH
105472: LD_INT 250
105474: EQUAL
105475: PUSH
105476: LD_VAR 0 2
105480: PPUSH
105481: CALL_OW 264
105485: PUSH
105486: LD_EXP 36
105490: EQUAL
105491: AND
105492: IFFALSE 105513
// MinerPlaceMine ( unit , x , y ) ;
105494: LD_VAR 0 2
105498: PPUSH
105499: LD_VAR 0 4
105503: PPUSH
105504: LD_VAR 0 5
105508: PPUSH
105509: CALL 108241 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
105513: LD_VAR 0 1
105517: PUSH
105518: LD_INT 251
105520: EQUAL
105521: PUSH
105522: LD_VAR 0 2
105526: PPUSH
105527: CALL_OW 264
105531: PUSH
105532: LD_EXP 36
105536: EQUAL
105537: AND
105538: IFFALSE 105559
// MinerDetonateMine ( unit , x , y ) ;
105540: LD_VAR 0 2
105544: PPUSH
105545: LD_VAR 0 4
105549: PPUSH
105550: LD_VAR 0 5
105554: PPUSH
105555: CALL 108518 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
105559: LD_VAR 0 1
105563: PUSH
105564: LD_INT 252
105566: EQUAL
105567: PUSH
105568: LD_VAR 0 2
105572: PPUSH
105573: CALL_OW 264
105577: PUSH
105578: LD_EXP 36
105582: EQUAL
105583: AND
105584: IFFALSE 105605
// MinerCreateMinefield ( unit , x , y ) ;
105586: LD_VAR 0 2
105590: PPUSH
105591: LD_VAR 0 4
105595: PPUSH
105596: LD_VAR 0 5
105600: PPUSH
105601: CALL 108935 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
105605: LD_VAR 0 1
105609: PUSH
105610: LD_INT 253
105612: EQUAL
105613: PUSH
105614: LD_VAR 0 2
105618: PPUSH
105619: CALL_OW 257
105623: PUSH
105624: LD_INT 5
105626: EQUAL
105627: AND
105628: IFFALSE 105649
// ComBinocular ( unit , x , y ) ;
105630: LD_VAR 0 2
105634: PPUSH
105635: LD_VAR 0 4
105639: PPUSH
105640: LD_VAR 0 5
105644: PPUSH
105645: CALL 109306 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
105649: LD_VAR 0 1
105653: PUSH
105654: LD_INT 254
105656: EQUAL
105657: PUSH
105658: LD_VAR 0 2
105662: PPUSH
105663: CALL_OW 264
105667: PUSH
105668: LD_EXP 31
105672: EQUAL
105673: AND
105674: PUSH
105675: LD_VAR 0 3
105679: PPUSH
105680: CALL_OW 263
105684: PUSH
105685: LD_INT 3
105687: EQUAL
105688: AND
105689: IFFALSE 105705
// HackDestroyVehicle ( unit , selectedUnit ) ;
105691: LD_VAR 0 2
105695: PPUSH
105696: LD_VAR 0 3
105700: PPUSH
105701: CALL 107601 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
105705: LD_VAR 0 1
105709: PUSH
105710: LD_INT 255
105712: EQUAL
105713: PUSH
105714: LD_VAR 0 2
105718: PPUSH
105719: CALL_OW 264
105723: PUSH
105724: LD_INT 14
105726: PUSH
105727: LD_INT 53
105729: PUSH
105730: EMPTY
105731: LIST
105732: LIST
105733: IN
105734: AND
105735: PUSH
105736: LD_VAR 0 4
105740: PPUSH
105741: LD_VAR 0 5
105745: PPUSH
105746: CALL_OW 488
105750: AND
105751: IFFALSE 105775
// CutTreeXYR ( unit , x , y , 12 ) ;
105753: LD_VAR 0 2
105757: PPUSH
105758: LD_VAR 0 4
105762: PPUSH
105763: LD_VAR 0 5
105767: PPUSH
105768: LD_INT 12
105770: PPUSH
105771: CALL 106167 0 4
// if cmd = 256 then
105775: LD_VAR 0 1
105779: PUSH
105780: LD_INT 256
105782: EQUAL
105783: IFFALSE 105804
// SetFactoryWaypoint ( unit , x , y ) ;
105785: LD_VAR 0 2
105789: PPUSH
105790: LD_VAR 0 4
105794: PPUSH
105795: LD_VAR 0 5
105799: PPUSH
105800: CALL 105809 0 3
// end ;
105804: LD_VAR 0 6
105808: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
105809: LD_INT 0
105811: PPUSH
105812: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
105813: LD_VAR 0 1
105817: NOT
105818: PUSH
105819: LD_VAR 0 2
105823: PPUSH
105824: LD_VAR 0 3
105828: PPUSH
105829: CALL_OW 488
105833: NOT
105834: OR
105835: PUSH
105836: LD_VAR 0 1
105840: PPUSH
105841: CALL_OW 266
105845: PUSH
105846: LD_INT 3
105848: NONEQUAL
105849: PUSH
105850: LD_VAR 0 1
105854: PPUSH
105855: CALL_OW 247
105859: PUSH
105860: LD_INT 1
105862: EQUAL
105863: NOT
105864: AND
105865: OR
105866: IFFALSE 105870
// exit ;
105868: GO 106019
// if GetType ( factory ) = unit_human then
105870: LD_VAR 0 1
105874: PPUSH
105875: CALL_OW 247
105879: PUSH
105880: LD_INT 1
105882: EQUAL
105883: IFFALSE 105900
// factory := IsInUnit ( factory ) ;
105885: LD_ADDR_VAR 0 1
105889: PUSH
105890: LD_VAR 0 1
105894: PPUSH
105895: CALL_OW 310
105899: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105900: LD_VAR 0 1
105904: PPUSH
105905: CALL_OW 266
105909: PUSH
105910: LD_INT 3
105912: NONEQUAL
105913: IFFALSE 105917
// exit ;
105915: GO 106019
// if HexInfo ( x , y ) = factory then
105917: LD_VAR 0 2
105921: PPUSH
105922: LD_VAR 0 3
105926: PPUSH
105927: CALL_OW 428
105931: PUSH
105932: LD_VAR 0 1
105936: EQUAL
105937: IFFALSE 105964
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
105939: LD_ADDR_EXP 152
105943: PUSH
105944: LD_EXP 152
105948: PPUSH
105949: LD_VAR 0 1
105953: PPUSH
105954: LD_INT 0
105956: PPUSH
105957: CALL_OW 1
105961: ST_TO_ADDR
105962: GO 106015
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
105964: LD_ADDR_EXP 152
105968: PUSH
105969: LD_EXP 152
105973: PPUSH
105974: LD_VAR 0 1
105978: PPUSH
105979: LD_VAR 0 1
105983: PPUSH
105984: CALL_OW 255
105988: PUSH
105989: LD_VAR 0 1
105993: PUSH
105994: LD_VAR 0 2
105998: PUSH
105999: LD_VAR 0 3
106003: PUSH
106004: EMPTY
106005: LIST
106006: LIST
106007: LIST
106008: LIST
106009: PPUSH
106010: CALL_OW 1
106014: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106015: CALL 106024 0 0
// end ;
106019: LD_VAR 0 4
106023: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
106024: LD_INT 0
106026: PPUSH
106027: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106028: LD_STRING resetFactoryWaypoint();
106030: PPUSH
106031: CALL_OW 559
// if factoryWaypoints then
106035: LD_EXP 152
106039: IFFALSE 106162
// begin for i := 1 to factoryWaypoints do
106041: LD_ADDR_VAR 0 2
106045: PUSH
106046: DOUBLE
106047: LD_INT 1
106049: DEC
106050: ST_TO_ADDR
106051: LD_EXP 152
106055: PUSH
106056: FOR_TO
106057: IFFALSE 106160
// if factoryWaypoints [ i ] then
106059: LD_EXP 152
106063: PUSH
106064: LD_VAR 0 2
106068: ARRAY
106069: IFFALSE 106158
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
106071: LD_STRING setFactoryWaypointXY(
106073: PUSH
106074: LD_EXP 152
106078: PUSH
106079: LD_VAR 0 2
106083: ARRAY
106084: PUSH
106085: LD_INT 1
106087: ARRAY
106088: STR
106089: PUSH
106090: LD_STRING ,
106092: STR
106093: PUSH
106094: LD_EXP 152
106098: PUSH
106099: LD_VAR 0 2
106103: ARRAY
106104: PUSH
106105: LD_INT 2
106107: ARRAY
106108: STR
106109: PUSH
106110: LD_STRING ,
106112: STR
106113: PUSH
106114: LD_EXP 152
106118: PUSH
106119: LD_VAR 0 2
106123: ARRAY
106124: PUSH
106125: LD_INT 3
106127: ARRAY
106128: STR
106129: PUSH
106130: LD_STRING ,
106132: STR
106133: PUSH
106134: LD_EXP 152
106138: PUSH
106139: LD_VAR 0 2
106143: ARRAY
106144: PUSH
106145: LD_INT 4
106147: ARRAY
106148: STR
106149: PUSH
106150: LD_STRING )
106152: STR
106153: PPUSH
106154: CALL_OW 559
106158: GO 106056
106160: POP
106161: POP
// end ; end ;
106162: LD_VAR 0 1
106166: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106167: LD_INT 0
106169: PPUSH
106170: PPUSH
106171: PPUSH
106172: PPUSH
106173: PPUSH
106174: PPUSH
106175: PPUSH
106176: PPUSH
106177: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106178: LD_VAR 0 1
106182: NOT
106183: PUSH
106184: LD_VAR 0 2
106188: PPUSH
106189: LD_VAR 0 3
106193: PPUSH
106194: CALL_OW 488
106198: NOT
106199: OR
106200: PUSH
106201: LD_VAR 0 4
106205: NOT
106206: OR
106207: IFFALSE 106211
// exit ;
106209: GO 106551
// list := [ ] ;
106211: LD_ADDR_VAR 0 13
106215: PUSH
106216: EMPTY
106217: ST_TO_ADDR
// if x - r < 0 then
106218: LD_VAR 0 2
106222: PUSH
106223: LD_VAR 0 4
106227: MINUS
106228: PUSH
106229: LD_INT 0
106231: LESS
106232: IFFALSE 106244
// min_x := 0 else
106234: LD_ADDR_VAR 0 7
106238: PUSH
106239: LD_INT 0
106241: ST_TO_ADDR
106242: GO 106260
// min_x := x - r ;
106244: LD_ADDR_VAR 0 7
106248: PUSH
106249: LD_VAR 0 2
106253: PUSH
106254: LD_VAR 0 4
106258: MINUS
106259: ST_TO_ADDR
// if y - r < 0 then
106260: LD_VAR 0 3
106264: PUSH
106265: LD_VAR 0 4
106269: MINUS
106270: PUSH
106271: LD_INT 0
106273: LESS
106274: IFFALSE 106286
// min_y := 0 else
106276: LD_ADDR_VAR 0 8
106280: PUSH
106281: LD_INT 0
106283: ST_TO_ADDR
106284: GO 106302
// min_y := y - r ;
106286: LD_ADDR_VAR 0 8
106290: PUSH
106291: LD_VAR 0 3
106295: PUSH
106296: LD_VAR 0 4
106300: MINUS
106301: ST_TO_ADDR
// max_x := x + r ;
106302: LD_ADDR_VAR 0 9
106306: PUSH
106307: LD_VAR 0 2
106311: PUSH
106312: LD_VAR 0 4
106316: PLUS
106317: ST_TO_ADDR
// max_y := y + r ;
106318: LD_ADDR_VAR 0 10
106322: PUSH
106323: LD_VAR 0 3
106327: PUSH
106328: LD_VAR 0 4
106332: PLUS
106333: ST_TO_ADDR
// for _x = min_x to max_x do
106334: LD_ADDR_VAR 0 11
106338: PUSH
106339: DOUBLE
106340: LD_VAR 0 7
106344: DEC
106345: ST_TO_ADDR
106346: LD_VAR 0 9
106350: PUSH
106351: FOR_TO
106352: IFFALSE 106469
// for _y = min_y to max_y do
106354: LD_ADDR_VAR 0 12
106358: PUSH
106359: DOUBLE
106360: LD_VAR 0 8
106364: DEC
106365: ST_TO_ADDR
106366: LD_VAR 0 10
106370: PUSH
106371: FOR_TO
106372: IFFALSE 106465
// begin if not ValidHex ( _x , _y ) then
106374: LD_VAR 0 11
106378: PPUSH
106379: LD_VAR 0 12
106383: PPUSH
106384: CALL_OW 488
106388: NOT
106389: IFFALSE 106393
// continue ;
106391: GO 106371
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106393: LD_VAR 0 11
106397: PPUSH
106398: LD_VAR 0 12
106402: PPUSH
106403: CALL_OW 351
106407: PUSH
106408: LD_VAR 0 11
106412: PPUSH
106413: LD_VAR 0 12
106417: PPUSH
106418: CALL_OW 554
106422: AND
106423: IFFALSE 106463
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106425: LD_ADDR_VAR 0 13
106429: PUSH
106430: LD_VAR 0 13
106434: PPUSH
106435: LD_VAR 0 13
106439: PUSH
106440: LD_INT 1
106442: PLUS
106443: PPUSH
106444: LD_VAR 0 11
106448: PUSH
106449: LD_VAR 0 12
106453: PUSH
106454: EMPTY
106455: LIST
106456: LIST
106457: PPUSH
106458: CALL_OW 2
106462: ST_TO_ADDR
// end ;
106463: GO 106371
106465: POP
106466: POP
106467: GO 106351
106469: POP
106470: POP
// if not list then
106471: LD_VAR 0 13
106475: NOT
106476: IFFALSE 106480
// exit ;
106478: GO 106551
// for i in list do
106480: LD_ADDR_VAR 0 6
106484: PUSH
106485: LD_VAR 0 13
106489: PUSH
106490: FOR_IN
106491: IFFALSE 106549
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106493: LD_VAR 0 1
106497: PPUSH
106498: LD_STRING M
106500: PUSH
106501: LD_VAR 0 6
106505: PUSH
106506: LD_INT 1
106508: ARRAY
106509: PUSH
106510: LD_VAR 0 6
106514: PUSH
106515: LD_INT 2
106517: ARRAY
106518: PUSH
106519: LD_INT 0
106521: PUSH
106522: LD_INT 0
106524: PUSH
106525: LD_INT 0
106527: PUSH
106528: LD_INT 0
106530: PUSH
106531: EMPTY
106532: LIST
106533: LIST
106534: LIST
106535: LIST
106536: LIST
106537: LIST
106538: LIST
106539: PUSH
106540: EMPTY
106541: LIST
106542: PPUSH
106543: CALL_OW 447
106547: GO 106490
106549: POP
106550: POP
// end ;
106551: LD_VAR 0 5
106555: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106556: LD_EXP 153
106560: NOT
106561: IFFALSE 106611
106563: GO 106565
106565: DISABLE
// begin initHack := true ;
106566: LD_ADDR_EXP 153
106570: PUSH
106571: LD_INT 1
106573: ST_TO_ADDR
// hackTanks := [ ] ;
106574: LD_ADDR_EXP 154
106578: PUSH
106579: EMPTY
106580: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106581: LD_ADDR_EXP 155
106585: PUSH
106586: EMPTY
106587: ST_TO_ADDR
// hackLimit := 3 ;
106588: LD_ADDR_EXP 156
106592: PUSH
106593: LD_INT 3
106595: ST_TO_ADDR
// hackDist := 12 ;
106596: LD_ADDR_EXP 157
106600: PUSH
106601: LD_INT 12
106603: ST_TO_ADDR
// hackCounter := [ ] ;
106604: LD_ADDR_EXP 158
106608: PUSH
106609: EMPTY
106610: ST_TO_ADDR
// end ;
106611: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106612: LD_EXP 153
106616: PUSH
106617: LD_INT 34
106619: PUSH
106620: LD_EXP 31
106624: PUSH
106625: EMPTY
106626: LIST
106627: LIST
106628: PPUSH
106629: CALL_OW 69
106633: AND
106634: IFFALSE 106889
106636: GO 106638
106638: DISABLE
106639: LD_INT 0
106641: PPUSH
106642: PPUSH
// begin enable ;
106643: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106644: LD_ADDR_VAR 0 1
106648: PUSH
106649: LD_INT 34
106651: PUSH
106652: LD_EXP 31
106656: PUSH
106657: EMPTY
106658: LIST
106659: LIST
106660: PPUSH
106661: CALL_OW 69
106665: PUSH
106666: FOR_IN
106667: IFFALSE 106887
// begin if not i in hackTanks then
106669: LD_VAR 0 1
106673: PUSH
106674: LD_EXP 154
106678: IN
106679: NOT
106680: IFFALSE 106763
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
106682: LD_ADDR_EXP 154
106686: PUSH
106687: LD_EXP 154
106691: PPUSH
106692: LD_EXP 154
106696: PUSH
106697: LD_INT 1
106699: PLUS
106700: PPUSH
106701: LD_VAR 0 1
106705: PPUSH
106706: CALL_OW 1
106710: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
106711: LD_ADDR_EXP 155
106715: PUSH
106716: LD_EXP 155
106720: PPUSH
106721: LD_EXP 155
106725: PUSH
106726: LD_INT 1
106728: PLUS
106729: PPUSH
106730: EMPTY
106731: PPUSH
106732: CALL_OW 1
106736: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
106737: LD_ADDR_EXP 158
106741: PUSH
106742: LD_EXP 158
106746: PPUSH
106747: LD_EXP 158
106751: PUSH
106752: LD_INT 1
106754: PLUS
106755: PPUSH
106756: EMPTY
106757: PPUSH
106758: CALL_OW 1
106762: ST_TO_ADDR
// end ; if not IsOk ( i ) then
106763: LD_VAR 0 1
106767: PPUSH
106768: CALL_OW 302
106772: NOT
106773: IFFALSE 106786
// begin HackUnlinkAll ( i ) ;
106775: LD_VAR 0 1
106779: PPUSH
106780: CALL 106892 0 1
// continue ;
106784: GO 106666
// end ; HackCheckCapturedStatus ( i ) ;
106786: LD_VAR 0 1
106790: PPUSH
106791: CALL 107335 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
106795: LD_ADDR_VAR 0 2
106799: PUSH
106800: LD_INT 81
106802: PUSH
106803: LD_VAR 0 1
106807: PPUSH
106808: CALL_OW 255
106812: PUSH
106813: EMPTY
106814: LIST
106815: LIST
106816: PUSH
106817: LD_INT 33
106819: PUSH
106820: LD_INT 3
106822: PUSH
106823: EMPTY
106824: LIST
106825: LIST
106826: PUSH
106827: LD_INT 91
106829: PUSH
106830: LD_VAR 0 1
106834: PUSH
106835: LD_EXP 157
106839: PUSH
106840: EMPTY
106841: LIST
106842: LIST
106843: LIST
106844: PUSH
106845: LD_INT 50
106847: PUSH
106848: EMPTY
106849: LIST
106850: PUSH
106851: EMPTY
106852: LIST
106853: LIST
106854: LIST
106855: LIST
106856: PPUSH
106857: CALL_OW 69
106861: ST_TO_ADDR
// if not tmp then
106862: LD_VAR 0 2
106866: NOT
106867: IFFALSE 106871
// continue ;
106869: GO 106666
// HackLink ( i , tmp ) ;
106871: LD_VAR 0 1
106875: PPUSH
106876: LD_VAR 0 2
106880: PPUSH
106881: CALL 107028 0 2
// end ;
106885: GO 106666
106887: POP
106888: POP
// end ;
106889: PPOPN 2
106891: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
106892: LD_INT 0
106894: PPUSH
106895: PPUSH
106896: PPUSH
// if not hack in hackTanks then
106897: LD_VAR 0 1
106901: PUSH
106902: LD_EXP 154
106906: IN
106907: NOT
106908: IFFALSE 106912
// exit ;
106910: GO 107023
// index := GetElementIndex ( hackTanks , hack ) ;
106912: LD_ADDR_VAR 0 4
106916: PUSH
106917: LD_EXP 154
106921: PPUSH
106922: LD_VAR 0 1
106926: PPUSH
106927: CALL 24643 0 2
106931: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
106932: LD_EXP 155
106936: PUSH
106937: LD_VAR 0 4
106941: ARRAY
106942: IFFALSE 107023
// begin for i in hackTanksCaptured [ index ] do
106944: LD_ADDR_VAR 0 3
106948: PUSH
106949: LD_EXP 155
106953: PUSH
106954: LD_VAR 0 4
106958: ARRAY
106959: PUSH
106960: FOR_IN
106961: IFFALSE 106987
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
106963: LD_VAR 0 3
106967: PUSH
106968: LD_INT 1
106970: ARRAY
106971: PPUSH
106972: LD_VAR 0 3
106976: PUSH
106977: LD_INT 2
106979: ARRAY
106980: PPUSH
106981: CALL_OW 235
106985: GO 106960
106987: POP
106988: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
106989: LD_ADDR_EXP 155
106993: PUSH
106994: LD_EXP 155
106998: PPUSH
106999: LD_VAR 0 4
107003: PPUSH
107004: EMPTY
107005: PPUSH
107006: CALL_OW 1
107010: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107011: LD_VAR 0 1
107015: PPUSH
107016: LD_INT 0
107018: PPUSH
107019: CALL_OW 505
// end ; end ;
107023: LD_VAR 0 2
107027: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107028: LD_INT 0
107030: PPUSH
107031: PPUSH
107032: PPUSH
// if not hack in hackTanks or not vehicles then
107033: LD_VAR 0 1
107037: PUSH
107038: LD_EXP 154
107042: IN
107043: NOT
107044: PUSH
107045: LD_VAR 0 2
107049: NOT
107050: OR
107051: IFFALSE 107055
// exit ;
107053: GO 107330
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107055: LD_ADDR_VAR 0 2
107059: PUSH
107060: LD_VAR 0 1
107064: PPUSH
107065: LD_VAR 0 2
107069: PPUSH
107070: LD_INT 1
107072: PPUSH
107073: LD_INT 1
107075: PPUSH
107076: CALL 25293 0 4
107080: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107081: LD_ADDR_VAR 0 5
107085: PUSH
107086: LD_EXP 154
107090: PPUSH
107091: LD_VAR 0 1
107095: PPUSH
107096: CALL 24643 0 2
107100: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107101: LD_EXP 155
107105: PUSH
107106: LD_VAR 0 5
107110: ARRAY
107111: PUSH
107112: LD_EXP 156
107116: LESS
107117: IFFALSE 107306
// begin for i := 1 to vehicles do
107119: LD_ADDR_VAR 0 4
107123: PUSH
107124: DOUBLE
107125: LD_INT 1
107127: DEC
107128: ST_TO_ADDR
107129: LD_VAR 0 2
107133: PUSH
107134: FOR_TO
107135: IFFALSE 107304
// begin if hackTanksCaptured [ index ] = hackLimit then
107137: LD_EXP 155
107141: PUSH
107142: LD_VAR 0 5
107146: ARRAY
107147: PUSH
107148: LD_EXP 156
107152: EQUAL
107153: IFFALSE 107157
// break ;
107155: GO 107304
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107157: LD_ADDR_EXP 158
107161: PUSH
107162: LD_EXP 158
107166: PPUSH
107167: LD_VAR 0 5
107171: PPUSH
107172: LD_EXP 158
107176: PUSH
107177: LD_VAR 0 5
107181: ARRAY
107182: PUSH
107183: LD_INT 1
107185: PLUS
107186: PPUSH
107187: CALL_OW 1
107191: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107192: LD_ADDR_EXP 155
107196: PUSH
107197: LD_EXP 155
107201: PPUSH
107202: LD_VAR 0 5
107206: PUSH
107207: LD_EXP 155
107211: PUSH
107212: LD_VAR 0 5
107216: ARRAY
107217: PUSH
107218: LD_INT 1
107220: PLUS
107221: PUSH
107222: EMPTY
107223: LIST
107224: LIST
107225: PPUSH
107226: LD_VAR 0 2
107230: PUSH
107231: LD_VAR 0 4
107235: ARRAY
107236: PUSH
107237: LD_VAR 0 2
107241: PUSH
107242: LD_VAR 0 4
107246: ARRAY
107247: PPUSH
107248: CALL_OW 255
107252: PUSH
107253: EMPTY
107254: LIST
107255: LIST
107256: PPUSH
107257: CALL 24858 0 3
107261: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107262: LD_VAR 0 2
107266: PUSH
107267: LD_VAR 0 4
107271: ARRAY
107272: PPUSH
107273: LD_VAR 0 1
107277: PPUSH
107278: CALL_OW 255
107282: PPUSH
107283: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107287: LD_VAR 0 2
107291: PUSH
107292: LD_VAR 0 4
107296: ARRAY
107297: PPUSH
107298: CALL_OW 141
// end ;
107302: GO 107134
107304: POP
107305: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107306: LD_VAR 0 1
107310: PPUSH
107311: LD_EXP 155
107315: PUSH
107316: LD_VAR 0 5
107320: ARRAY
107321: PUSH
107322: LD_INT 0
107324: PLUS
107325: PPUSH
107326: CALL_OW 505
// end ;
107330: LD_VAR 0 3
107334: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107335: LD_INT 0
107337: PPUSH
107338: PPUSH
107339: PPUSH
107340: PPUSH
// if not hack in hackTanks then
107341: LD_VAR 0 1
107345: PUSH
107346: LD_EXP 154
107350: IN
107351: NOT
107352: IFFALSE 107356
// exit ;
107354: GO 107596
// index := GetElementIndex ( hackTanks , hack ) ;
107356: LD_ADDR_VAR 0 4
107360: PUSH
107361: LD_EXP 154
107365: PPUSH
107366: LD_VAR 0 1
107370: PPUSH
107371: CALL 24643 0 2
107375: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107376: LD_ADDR_VAR 0 3
107380: PUSH
107381: DOUBLE
107382: LD_EXP 155
107386: PUSH
107387: LD_VAR 0 4
107391: ARRAY
107392: INC
107393: ST_TO_ADDR
107394: LD_INT 1
107396: PUSH
107397: FOR_DOWNTO
107398: IFFALSE 107570
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107400: LD_ADDR_VAR 0 5
107404: PUSH
107405: LD_EXP 155
107409: PUSH
107410: LD_VAR 0 4
107414: ARRAY
107415: PUSH
107416: LD_VAR 0 3
107420: ARRAY
107421: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107422: LD_VAR 0 5
107426: PUSH
107427: LD_INT 1
107429: ARRAY
107430: PPUSH
107431: CALL_OW 302
107435: NOT
107436: PUSH
107437: LD_VAR 0 5
107441: PUSH
107442: LD_INT 1
107444: ARRAY
107445: PPUSH
107446: CALL_OW 255
107450: PUSH
107451: LD_VAR 0 1
107455: PPUSH
107456: CALL_OW 255
107460: NONEQUAL
107461: OR
107462: IFFALSE 107568
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107464: LD_VAR 0 5
107468: PUSH
107469: LD_INT 1
107471: ARRAY
107472: PPUSH
107473: CALL_OW 305
107477: PUSH
107478: LD_VAR 0 5
107482: PUSH
107483: LD_INT 1
107485: ARRAY
107486: PPUSH
107487: CALL_OW 255
107491: PUSH
107492: LD_VAR 0 1
107496: PPUSH
107497: CALL_OW 255
107501: EQUAL
107502: AND
107503: IFFALSE 107527
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107505: LD_VAR 0 5
107509: PUSH
107510: LD_INT 1
107512: ARRAY
107513: PPUSH
107514: LD_VAR 0 5
107518: PUSH
107519: LD_INT 2
107521: ARRAY
107522: PPUSH
107523: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107527: LD_ADDR_EXP 155
107531: PUSH
107532: LD_EXP 155
107536: PPUSH
107537: LD_VAR 0 4
107541: PPUSH
107542: LD_EXP 155
107546: PUSH
107547: LD_VAR 0 4
107551: ARRAY
107552: PPUSH
107553: LD_VAR 0 3
107557: PPUSH
107558: CALL_OW 3
107562: PPUSH
107563: CALL_OW 1
107567: ST_TO_ADDR
// end ; end ;
107568: GO 107397
107570: POP
107571: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107572: LD_VAR 0 1
107576: PPUSH
107577: LD_EXP 155
107581: PUSH
107582: LD_VAR 0 4
107586: ARRAY
107587: PUSH
107588: LD_INT 0
107590: PLUS
107591: PPUSH
107592: CALL_OW 505
// end ;
107596: LD_VAR 0 2
107600: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107601: LD_INT 0
107603: PPUSH
107604: PPUSH
107605: PPUSH
107606: PPUSH
// if not hack in hackTanks then
107607: LD_VAR 0 1
107611: PUSH
107612: LD_EXP 154
107616: IN
107617: NOT
107618: IFFALSE 107622
// exit ;
107620: GO 107707
// index := GetElementIndex ( hackTanks , hack ) ;
107622: LD_ADDR_VAR 0 5
107626: PUSH
107627: LD_EXP 154
107631: PPUSH
107632: LD_VAR 0 1
107636: PPUSH
107637: CALL 24643 0 2
107641: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107642: LD_ADDR_VAR 0 4
107646: PUSH
107647: DOUBLE
107648: LD_INT 1
107650: DEC
107651: ST_TO_ADDR
107652: LD_EXP 155
107656: PUSH
107657: LD_VAR 0 5
107661: ARRAY
107662: PUSH
107663: FOR_TO
107664: IFFALSE 107705
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
107666: LD_EXP 155
107670: PUSH
107671: LD_VAR 0 5
107675: ARRAY
107676: PUSH
107677: LD_VAR 0 4
107681: ARRAY
107682: PUSH
107683: LD_INT 1
107685: ARRAY
107686: PUSH
107687: LD_VAR 0 2
107691: EQUAL
107692: IFFALSE 107703
// KillUnit ( vehicle ) ;
107694: LD_VAR 0 2
107698: PPUSH
107699: CALL_OW 66
107703: GO 107663
107705: POP
107706: POP
// end ;
107707: LD_VAR 0 3
107711: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
107712: LD_EXP 159
107716: NOT
107717: IFFALSE 107752
107719: GO 107721
107721: DISABLE
// begin initMiner := true ;
107722: LD_ADDR_EXP 159
107726: PUSH
107727: LD_INT 1
107729: ST_TO_ADDR
// minersList := [ ] ;
107730: LD_ADDR_EXP 160
107734: PUSH
107735: EMPTY
107736: ST_TO_ADDR
// minerMinesList := [ ] ;
107737: LD_ADDR_EXP 161
107741: PUSH
107742: EMPTY
107743: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
107744: LD_ADDR_EXP 162
107748: PUSH
107749: LD_INT 5
107751: ST_TO_ADDR
// end ;
107752: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
107753: LD_EXP 159
107757: PUSH
107758: LD_INT 34
107760: PUSH
107761: LD_EXP 36
107765: PUSH
107766: EMPTY
107767: LIST
107768: LIST
107769: PPUSH
107770: CALL_OW 69
107774: AND
107775: IFFALSE 108238
107777: GO 107779
107779: DISABLE
107780: LD_INT 0
107782: PPUSH
107783: PPUSH
107784: PPUSH
107785: PPUSH
// begin enable ;
107786: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
107787: LD_ADDR_VAR 0 1
107791: PUSH
107792: LD_INT 34
107794: PUSH
107795: LD_EXP 36
107799: PUSH
107800: EMPTY
107801: LIST
107802: LIST
107803: PPUSH
107804: CALL_OW 69
107808: PUSH
107809: FOR_IN
107810: IFFALSE 107882
// begin if not i in minersList then
107812: LD_VAR 0 1
107816: PUSH
107817: LD_EXP 160
107821: IN
107822: NOT
107823: IFFALSE 107880
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
107825: LD_ADDR_EXP 160
107829: PUSH
107830: LD_EXP 160
107834: PPUSH
107835: LD_EXP 160
107839: PUSH
107840: LD_INT 1
107842: PLUS
107843: PPUSH
107844: LD_VAR 0 1
107848: PPUSH
107849: CALL_OW 1
107853: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
107854: LD_ADDR_EXP 161
107858: PUSH
107859: LD_EXP 161
107863: PPUSH
107864: LD_EXP 161
107868: PUSH
107869: LD_INT 1
107871: PLUS
107872: PPUSH
107873: EMPTY
107874: PPUSH
107875: CALL_OW 1
107879: ST_TO_ADDR
// end end ;
107880: GO 107809
107882: POP
107883: POP
// for i := minerMinesList downto 1 do
107884: LD_ADDR_VAR 0 1
107888: PUSH
107889: DOUBLE
107890: LD_EXP 161
107894: INC
107895: ST_TO_ADDR
107896: LD_INT 1
107898: PUSH
107899: FOR_DOWNTO
107900: IFFALSE 108236
// begin if IsLive ( minersList [ i ] ) then
107902: LD_EXP 160
107906: PUSH
107907: LD_VAR 0 1
107911: ARRAY
107912: PPUSH
107913: CALL_OW 300
107917: IFFALSE 107945
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
107919: LD_EXP 160
107923: PUSH
107924: LD_VAR 0 1
107928: ARRAY
107929: PPUSH
107930: LD_EXP 161
107934: PUSH
107935: LD_VAR 0 1
107939: ARRAY
107940: PPUSH
107941: CALL_OW 505
// if not minerMinesList [ i ] then
107945: LD_EXP 161
107949: PUSH
107950: LD_VAR 0 1
107954: ARRAY
107955: NOT
107956: IFFALSE 107960
// continue ;
107958: GO 107899
// for j := minerMinesList [ i ] downto 1 do
107960: LD_ADDR_VAR 0 2
107964: PUSH
107965: DOUBLE
107966: LD_EXP 161
107970: PUSH
107971: LD_VAR 0 1
107975: ARRAY
107976: INC
107977: ST_TO_ADDR
107978: LD_INT 1
107980: PUSH
107981: FOR_DOWNTO
107982: IFFALSE 108232
// begin side := GetSide ( minersList [ i ] ) ;
107984: LD_ADDR_VAR 0 3
107988: PUSH
107989: LD_EXP 160
107993: PUSH
107994: LD_VAR 0 1
107998: ARRAY
107999: PPUSH
108000: CALL_OW 255
108004: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108005: LD_ADDR_VAR 0 4
108009: PUSH
108010: LD_EXP 161
108014: PUSH
108015: LD_VAR 0 1
108019: ARRAY
108020: PUSH
108021: LD_VAR 0 2
108025: ARRAY
108026: PUSH
108027: LD_INT 1
108029: ARRAY
108030: PPUSH
108031: LD_EXP 161
108035: PUSH
108036: LD_VAR 0 1
108040: ARRAY
108041: PUSH
108042: LD_VAR 0 2
108046: ARRAY
108047: PUSH
108048: LD_INT 2
108050: ARRAY
108051: PPUSH
108052: CALL_OW 428
108056: ST_TO_ADDR
// if not tmp then
108057: LD_VAR 0 4
108061: NOT
108062: IFFALSE 108066
// continue ;
108064: GO 107981
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108066: LD_VAR 0 4
108070: PUSH
108071: LD_INT 81
108073: PUSH
108074: LD_VAR 0 3
108078: PUSH
108079: EMPTY
108080: LIST
108081: LIST
108082: PPUSH
108083: CALL_OW 69
108087: IN
108088: PUSH
108089: LD_EXP 161
108093: PUSH
108094: LD_VAR 0 1
108098: ARRAY
108099: PUSH
108100: LD_VAR 0 2
108104: ARRAY
108105: PUSH
108106: LD_INT 1
108108: ARRAY
108109: PPUSH
108110: LD_EXP 161
108114: PUSH
108115: LD_VAR 0 1
108119: ARRAY
108120: PUSH
108121: LD_VAR 0 2
108125: ARRAY
108126: PUSH
108127: LD_INT 2
108129: ARRAY
108130: PPUSH
108131: CALL_OW 458
108135: AND
108136: IFFALSE 108230
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108138: LD_EXP 161
108142: PUSH
108143: LD_VAR 0 1
108147: ARRAY
108148: PUSH
108149: LD_VAR 0 2
108153: ARRAY
108154: PUSH
108155: LD_INT 1
108157: ARRAY
108158: PPUSH
108159: LD_EXP 161
108163: PUSH
108164: LD_VAR 0 1
108168: ARRAY
108169: PUSH
108170: LD_VAR 0 2
108174: ARRAY
108175: PUSH
108176: LD_INT 2
108178: ARRAY
108179: PPUSH
108180: LD_VAR 0 3
108184: PPUSH
108185: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108189: LD_ADDR_EXP 161
108193: PUSH
108194: LD_EXP 161
108198: PPUSH
108199: LD_VAR 0 1
108203: PPUSH
108204: LD_EXP 161
108208: PUSH
108209: LD_VAR 0 1
108213: ARRAY
108214: PPUSH
108215: LD_VAR 0 2
108219: PPUSH
108220: CALL_OW 3
108224: PPUSH
108225: CALL_OW 1
108229: ST_TO_ADDR
// end ; end ;
108230: GO 107981
108232: POP
108233: POP
// end ;
108234: GO 107899
108236: POP
108237: POP
// end ;
108238: PPOPN 4
108240: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108241: LD_INT 0
108243: PPUSH
108244: PPUSH
// result := false ;
108245: LD_ADDR_VAR 0 4
108249: PUSH
108250: LD_INT 0
108252: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108253: LD_VAR 0 1
108257: PPUSH
108258: CALL_OW 264
108262: PUSH
108263: LD_EXP 36
108267: EQUAL
108268: NOT
108269: IFFALSE 108273
// exit ;
108271: GO 108513
// index := GetElementIndex ( minersList , unit ) ;
108273: LD_ADDR_VAR 0 5
108277: PUSH
108278: LD_EXP 160
108282: PPUSH
108283: LD_VAR 0 1
108287: PPUSH
108288: CALL 24643 0 2
108292: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108293: LD_EXP 161
108297: PUSH
108298: LD_VAR 0 5
108302: ARRAY
108303: PUSH
108304: LD_EXP 162
108308: GREATEREQUAL
108309: IFFALSE 108313
// exit ;
108311: GO 108513
// ComMoveXY ( unit , x , y ) ;
108313: LD_VAR 0 1
108317: PPUSH
108318: LD_VAR 0 2
108322: PPUSH
108323: LD_VAR 0 3
108327: PPUSH
108328: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108332: LD_INT 35
108334: PPUSH
108335: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108339: LD_VAR 0 1
108343: PPUSH
108344: LD_VAR 0 2
108348: PPUSH
108349: LD_VAR 0 3
108353: PPUSH
108354: CALL 55415 0 3
108358: NOT
108359: PUSH
108360: LD_VAR 0 1
108364: PPUSH
108365: CALL_OW 314
108369: AND
108370: IFFALSE 108374
// exit ;
108372: GO 108513
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108374: LD_VAR 0 2
108378: PPUSH
108379: LD_VAR 0 3
108383: PPUSH
108384: CALL_OW 428
108388: PUSH
108389: LD_VAR 0 1
108393: EQUAL
108394: PUSH
108395: LD_VAR 0 1
108399: PPUSH
108400: CALL_OW 314
108404: NOT
108405: AND
108406: IFFALSE 108332
// PlaySoundXY ( x , y , PlantMine ) ;
108408: LD_VAR 0 2
108412: PPUSH
108413: LD_VAR 0 3
108417: PPUSH
108418: LD_STRING PlantMine
108420: PPUSH
108421: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108425: LD_VAR 0 2
108429: PPUSH
108430: LD_VAR 0 3
108434: PPUSH
108435: LD_VAR 0 1
108439: PPUSH
108440: CALL_OW 255
108444: PPUSH
108445: LD_INT 0
108447: PPUSH
108448: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108452: LD_ADDR_EXP 161
108456: PUSH
108457: LD_EXP 161
108461: PPUSH
108462: LD_VAR 0 5
108466: PUSH
108467: LD_EXP 161
108471: PUSH
108472: LD_VAR 0 5
108476: ARRAY
108477: PUSH
108478: LD_INT 1
108480: PLUS
108481: PUSH
108482: EMPTY
108483: LIST
108484: LIST
108485: PPUSH
108486: LD_VAR 0 2
108490: PUSH
108491: LD_VAR 0 3
108495: PUSH
108496: EMPTY
108497: LIST
108498: LIST
108499: PPUSH
108500: CALL 24858 0 3
108504: ST_TO_ADDR
// result := true ;
108505: LD_ADDR_VAR 0 4
108509: PUSH
108510: LD_INT 1
108512: ST_TO_ADDR
// end ;
108513: LD_VAR 0 4
108517: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108518: LD_INT 0
108520: PPUSH
108521: PPUSH
108522: PPUSH
// if not unit in minersList then
108523: LD_VAR 0 1
108527: PUSH
108528: LD_EXP 160
108532: IN
108533: NOT
108534: IFFALSE 108538
// exit ;
108536: GO 108930
// index := GetElementIndex ( minersList , unit ) ;
108538: LD_ADDR_VAR 0 6
108542: PUSH
108543: LD_EXP 160
108547: PPUSH
108548: LD_VAR 0 1
108552: PPUSH
108553: CALL 24643 0 2
108557: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108558: LD_ADDR_VAR 0 5
108562: PUSH
108563: DOUBLE
108564: LD_EXP 161
108568: PUSH
108569: LD_VAR 0 6
108573: ARRAY
108574: INC
108575: ST_TO_ADDR
108576: LD_INT 1
108578: PUSH
108579: FOR_DOWNTO
108580: IFFALSE 108741
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108582: LD_EXP 161
108586: PUSH
108587: LD_VAR 0 6
108591: ARRAY
108592: PUSH
108593: LD_VAR 0 5
108597: ARRAY
108598: PUSH
108599: LD_INT 1
108601: ARRAY
108602: PUSH
108603: LD_VAR 0 2
108607: EQUAL
108608: PUSH
108609: LD_EXP 161
108613: PUSH
108614: LD_VAR 0 6
108618: ARRAY
108619: PUSH
108620: LD_VAR 0 5
108624: ARRAY
108625: PUSH
108626: LD_INT 2
108628: ARRAY
108629: PUSH
108630: LD_VAR 0 3
108634: EQUAL
108635: AND
108636: IFFALSE 108739
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108638: LD_EXP 161
108642: PUSH
108643: LD_VAR 0 6
108647: ARRAY
108648: PUSH
108649: LD_VAR 0 5
108653: ARRAY
108654: PUSH
108655: LD_INT 1
108657: ARRAY
108658: PPUSH
108659: LD_EXP 161
108663: PUSH
108664: LD_VAR 0 6
108668: ARRAY
108669: PUSH
108670: LD_VAR 0 5
108674: ARRAY
108675: PUSH
108676: LD_INT 2
108678: ARRAY
108679: PPUSH
108680: LD_VAR 0 1
108684: PPUSH
108685: CALL_OW 255
108689: PPUSH
108690: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108694: LD_ADDR_EXP 161
108698: PUSH
108699: LD_EXP 161
108703: PPUSH
108704: LD_VAR 0 6
108708: PPUSH
108709: LD_EXP 161
108713: PUSH
108714: LD_VAR 0 6
108718: ARRAY
108719: PPUSH
108720: LD_VAR 0 5
108724: PPUSH
108725: CALL_OW 3
108729: PPUSH
108730: CALL_OW 1
108734: ST_TO_ADDR
// exit ;
108735: POP
108736: POP
108737: GO 108930
// end ; end ;
108739: GO 108579
108741: POP
108742: POP
// for i := minerMinesList [ index ] downto 1 do
108743: LD_ADDR_VAR 0 5
108747: PUSH
108748: DOUBLE
108749: LD_EXP 161
108753: PUSH
108754: LD_VAR 0 6
108758: ARRAY
108759: INC
108760: ST_TO_ADDR
108761: LD_INT 1
108763: PUSH
108764: FOR_DOWNTO
108765: IFFALSE 108928
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
108767: LD_EXP 161
108771: PUSH
108772: LD_VAR 0 6
108776: ARRAY
108777: PUSH
108778: LD_VAR 0 5
108782: ARRAY
108783: PUSH
108784: LD_INT 1
108786: ARRAY
108787: PPUSH
108788: LD_EXP 161
108792: PUSH
108793: LD_VAR 0 6
108797: ARRAY
108798: PUSH
108799: LD_VAR 0 5
108803: ARRAY
108804: PUSH
108805: LD_INT 2
108807: ARRAY
108808: PPUSH
108809: LD_VAR 0 2
108813: PPUSH
108814: LD_VAR 0 3
108818: PPUSH
108819: CALL_OW 298
108823: PUSH
108824: LD_INT 6
108826: LESS
108827: IFFALSE 108926
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108829: LD_EXP 161
108833: PUSH
108834: LD_VAR 0 6
108838: ARRAY
108839: PUSH
108840: LD_VAR 0 5
108844: ARRAY
108845: PUSH
108846: LD_INT 1
108848: ARRAY
108849: PPUSH
108850: LD_EXP 161
108854: PUSH
108855: LD_VAR 0 6
108859: ARRAY
108860: PUSH
108861: LD_VAR 0 5
108865: ARRAY
108866: PUSH
108867: LD_INT 2
108869: ARRAY
108870: PPUSH
108871: LD_VAR 0 1
108875: PPUSH
108876: CALL_OW 255
108880: PPUSH
108881: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108885: LD_ADDR_EXP 161
108889: PUSH
108890: LD_EXP 161
108894: PPUSH
108895: LD_VAR 0 6
108899: PPUSH
108900: LD_EXP 161
108904: PUSH
108905: LD_VAR 0 6
108909: ARRAY
108910: PPUSH
108911: LD_VAR 0 5
108915: PPUSH
108916: CALL_OW 3
108920: PPUSH
108921: CALL_OW 1
108925: ST_TO_ADDR
// end ; end ;
108926: GO 108764
108928: POP
108929: POP
// end ;
108930: LD_VAR 0 4
108934: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
108935: LD_INT 0
108937: PPUSH
108938: PPUSH
108939: PPUSH
108940: PPUSH
108941: PPUSH
108942: PPUSH
108943: PPUSH
108944: PPUSH
108945: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
108946: LD_VAR 0 1
108950: PPUSH
108951: CALL_OW 264
108955: PUSH
108956: LD_EXP 36
108960: EQUAL
108961: NOT
108962: PUSH
108963: LD_VAR 0 1
108967: PUSH
108968: LD_EXP 160
108972: IN
108973: NOT
108974: OR
108975: IFFALSE 108979
// exit ;
108977: GO 109301
// index := GetElementIndex ( minersList , unit ) ;
108979: LD_ADDR_VAR 0 6
108983: PUSH
108984: LD_EXP 160
108988: PPUSH
108989: LD_VAR 0 1
108993: PPUSH
108994: CALL 24643 0 2
108998: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
108999: LD_ADDR_VAR 0 8
109003: PUSH
109004: LD_EXP 162
109008: PUSH
109009: LD_EXP 161
109013: PUSH
109014: LD_VAR 0 6
109018: ARRAY
109019: MINUS
109020: ST_TO_ADDR
// if not minesFreeAmount then
109021: LD_VAR 0 8
109025: NOT
109026: IFFALSE 109030
// exit ;
109028: GO 109301
// tmp := [ ] ;
109030: LD_ADDR_VAR 0 7
109034: PUSH
109035: EMPTY
109036: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109037: LD_ADDR_VAR 0 5
109041: PUSH
109042: DOUBLE
109043: LD_INT 1
109045: DEC
109046: ST_TO_ADDR
109047: LD_VAR 0 8
109051: PUSH
109052: FOR_TO
109053: IFFALSE 109248
// begin _d := rand ( 0 , 5 ) ;
109055: LD_ADDR_VAR 0 11
109059: PUSH
109060: LD_INT 0
109062: PPUSH
109063: LD_INT 5
109065: PPUSH
109066: CALL_OW 12
109070: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109071: LD_ADDR_VAR 0 12
109075: PUSH
109076: LD_INT 2
109078: PPUSH
109079: LD_INT 6
109081: PPUSH
109082: CALL_OW 12
109086: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109087: LD_ADDR_VAR 0 9
109091: PUSH
109092: LD_VAR 0 2
109096: PPUSH
109097: LD_VAR 0 11
109101: PPUSH
109102: LD_VAR 0 12
109106: PPUSH
109107: CALL_OW 272
109111: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109112: LD_ADDR_VAR 0 10
109116: PUSH
109117: LD_VAR 0 3
109121: PPUSH
109122: LD_VAR 0 11
109126: PPUSH
109127: LD_VAR 0 12
109131: PPUSH
109132: CALL_OW 273
109136: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109137: LD_VAR 0 9
109141: PPUSH
109142: LD_VAR 0 10
109146: PPUSH
109147: CALL_OW 488
109151: PUSH
109152: LD_VAR 0 9
109156: PUSH
109157: LD_VAR 0 10
109161: PUSH
109162: EMPTY
109163: LIST
109164: LIST
109165: PUSH
109166: LD_VAR 0 7
109170: IN
109171: NOT
109172: AND
109173: PUSH
109174: LD_VAR 0 9
109178: PPUSH
109179: LD_VAR 0 10
109183: PPUSH
109184: CALL_OW 458
109188: NOT
109189: AND
109190: IFFALSE 109232
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109192: LD_ADDR_VAR 0 7
109196: PUSH
109197: LD_VAR 0 7
109201: PPUSH
109202: LD_VAR 0 7
109206: PUSH
109207: LD_INT 1
109209: PLUS
109210: PPUSH
109211: LD_VAR 0 9
109215: PUSH
109216: LD_VAR 0 10
109220: PUSH
109221: EMPTY
109222: LIST
109223: LIST
109224: PPUSH
109225: CALL_OW 1
109229: ST_TO_ADDR
109230: GO 109246
// i := i - 1 ;
109232: LD_ADDR_VAR 0 5
109236: PUSH
109237: LD_VAR 0 5
109241: PUSH
109242: LD_INT 1
109244: MINUS
109245: ST_TO_ADDR
// end ;
109246: GO 109052
109248: POP
109249: POP
// for i in tmp do
109250: LD_ADDR_VAR 0 5
109254: PUSH
109255: LD_VAR 0 7
109259: PUSH
109260: FOR_IN
109261: IFFALSE 109299
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109263: LD_VAR 0 1
109267: PPUSH
109268: LD_VAR 0 5
109272: PUSH
109273: LD_INT 1
109275: ARRAY
109276: PPUSH
109277: LD_VAR 0 5
109281: PUSH
109282: LD_INT 2
109284: ARRAY
109285: PPUSH
109286: CALL 108241 0 3
109290: NOT
109291: IFFALSE 109297
// exit ;
109293: POP
109294: POP
109295: GO 109301
109297: GO 109260
109299: POP
109300: POP
// end ;
109301: LD_VAR 0 4
109305: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109306: LD_INT 0
109308: PPUSH
109309: PPUSH
109310: PPUSH
109311: PPUSH
109312: PPUSH
109313: PPUSH
109314: PPUSH
// if not GetClass ( unit ) = class_sniper then
109315: LD_VAR 0 1
109319: PPUSH
109320: CALL_OW 257
109324: PUSH
109325: LD_INT 5
109327: EQUAL
109328: NOT
109329: IFFALSE 109333
// exit ;
109331: GO 109721
// dist := 8 ;
109333: LD_ADDR_VAR 0 5
109337: PUSH
109338: LD_INT 8
109340: ST_TO_ADDR
// viewRange := 12 ;
109341: LD_ADDR_VAR 0 7
109345: PUSH
109346: LD_INT 12
109348: ST_TO_ADDR
// side := GetSide ( unit ) ;
109349: LD_ADDR_VAR 0 6
109353: PUSH
109354: LD_VAR 0 1
109358: PPUSH
109359: CALL_OW 255
109363: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109364: LD_INT 61
109366: PPUSH
109367: LD_VAR 0 6
109371: PPUSH
109372: CALL_OW 321
109376: PUSH
109377: LD_INT 2
109379: EQUAL
109380: IFFALSE 109390
// viewRange := 16 ;
109382: LD_ADDR_VAR 0 7
109386: PUSH
109387: LD_INT 16
109389: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109390: LD_VAR 0 1
109394: PPUSH
109395: LD_VAR 0 2
109399: PPUSH
109400: LD_VAR 0 3
109404: PPUSH
109405: CALL_OW 297
109409: PUSH
109410: LD_VAR 0 5
109414: GREATER
109415: IFFALSE 109494
// begin ComMoveXY ( unit , x , y ) ;
109417: LD_VAR 0 1
109421: PPUSH
109422: LD_VAR 0 2
109426: PPUSH
109427: LD_VAR 0 3
109431: PPUSH
109432: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109436: LD_INT 35
109438: PPUSH
109439: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109443: LD_VAR 0 1
109447: PPUSH
109448: LD_VAR 0 2
109452: PPUSH
109453: LD_VAR 0 3
109457: PPUSH
109458: CALL 55415 0 3
109462: NOT
109463: IFFALSE 109467
// exit ;
109465: GO 109721
// until GetDistUnitXY ( unit , x , y ) < dist ;
109467: LD_VAR 0 1
109471: PPUSH
109472: LD_VAR 0 2
109476: PPUSH
109477: LD_VAR 0 3
109481: PPUSH
109482: CALL_OW 297
109486: PUSH
109487: LD_VAR 0 5
109491: LESS
109492: IFFALSE 109436
// end ; ComTurnXY ( unit , x , y ) ;
109494: LD_VAR 0 1
109498: PPUSH
109499: LD_VAR 0 2
109503: PPUSH
109504: LD_VAR 0 3
109508: PPUSH
109509: CALL_OW 118
// wait ( 5 ) ;
109513: LD_INT 5
109515: PPUSH
109516: CALL_OW 67
// _d := GetDir ( unit ) ;
109520: LD_ADDR_VAR 0 10
109524: PUSH
109525: LD_VAR 0 1
109529: PPUSH
109530: CALL_OW 254
109534: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109535: LD_ADDR_VAR 0 8
109539: PUSH
109540: LD_VAR 0 1
109544: PPUSH
109545: CALL_OW 250
109549: PPUSH
109550: LD_VAR 0 10
109554: PPUSH
109555: LD_VAR 0 5
109559: PPUSH
109560: CALL_OW 272
109564: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109565: LD_ADDR_VAR 0 9
109569: PUSH
109570: LD_VAR 0 1
109574: PPUSH
109575: CALL_OW 251
109579: PPUSH
109580: LD_VAR 0 10
109584: PPUSH
109585: LD_VAR 0 5
109589: PPUSH
109590: CALL_OW 273
109594: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109595: LD_VAR 0 8
109599: PPUSH
109600: LD_VAR 0 9
109604: PPUSH
109605: CALL_OW 488
109609: NOT
109610: IFFALSE 109614
// exit ;
109612: GO 109721
// ComAnimCustom ( unit , 1 ) ;
109614: LD_VAR 0 1
109618: PPUSH
109619: LD_INT 1
109621: PPUSH
109622: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109626: LD_VAR 0 8
109630: PPUSH
109631: LD_VAR 0 9
109635: PPUSH
109636: LD_VAR 0 6
109640: PPUSH
109641: LD_VAR 0 7
109645: PPUSH
109646: CALL_OW 330
// repeat wait ( 1 ) ;
109650: LD_INT 1
109652: PPUSH
109653: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
109657: LD_VAR 0 1
109661: PPUSH
109662: CALL_OW 316
109666: PUSH
109667: LD_VAR 0 1
109671: PPUSH
109672: CALL_OW 314
109676: OR
109677: PUSH
109678: LD_VAR 0 1
109682: PPUSH
109683: CALL_OW 302
109687: NOT
109688: OR
109689: PUSH
109690: LD_VAR 0 1
109694: PPUSH
109695: CALL_OW 301
109699: OR
109700: IFFALSE 109650
// RemoveSeeing ( _x , _y , side ) ;
109702: LD_VAR 0 8
109706: PPUSH
109707: LD_VAR 0 9
109711: PPUSH
109712: LD_VAR 0 6
109716: PPUSH
109717: CALL_OW 331
// end ; end_of_file
109721: LD_VAR 0 4
109725: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
109726: LD_INT 0
109728: PPUSH
109729: PPUSH
109730: PPUSH
109731: PPUSH
109732: PPUSH
109733: PPUSH
109734: PPUSH
109735: PPUSH
109736: PPUSH
109737: PPUSH
109738: PPUSH
109739: PPUSH
109740: PPUSH
109741: PPUSH
109742: PPUSH
109743: PPUSH
109744: PPUSH
109745: PPUSH
109746: PPUSH
109747: PPUSH
109748: PPUSH
109749: PPUSH
109750: PPUSH
109751: PPUSH
109752: PPUSH
109753: PPUSH
109754: PPUSH
109755: PPUSH
109756: PPUSH
109757: PPUSH
109758: PPUSH
109759: PPUSH
109760: PPUSH
109761: PPUSH
// if not list then
109762: LD_VAR 0 1
109766: NOT
109767: IFFALSE 109771
// exit ;
109769: GO 114430
// base := list [ 1 ] ;
109771: LD_ADDR_VAR 0 3
109775: PUSH
109776: LD_VAR 0 1
109780: PUSH
109781: LD_INT 1
109783: ARRAY
109784: ST_TO_ADDR
// group := list [ 2 ] ;
109785: LD_ADDR_VAR 0 4
109789: PUSH
109790: LD_VAR 0 1
109794: PUSH
109795: LD_INT 2
109797: ARRAY
109798: ST_TO_ADDR
// path := list [ 3 ] ;
109799: LD_ADDR_VAR 0 5
109803: PUSH
109804: LD_VAR 0 1
109808: PUSH
109809: LD_INT 3
109811: ARRAY
109812: ST_TO_ADDR
// flags := list [ 4 ] ;
109813: LD_ADDR_VAR 0 6
109817: PUSH
109818: LD_VAR 0 1
109822: PUSH
109823: LD_INT 4
109825: ARRAY
109826: ST_TO_ADDR
// mined := [ ] ;
109827: LD_ADDR_VAR 0 27
109831: PUSH
109832: EMPTY
109833: ST_TO_ADDR
// bombed := [ ] ;
109834: LD_ADDR_VAR 0 28
109838: PUSH
109839: EMPTY
109840: ST_TO_ADDR
// healers := [ ] ;
109841: LD_ADDR_VAR 0 31
109845: PUSH
109846: EMPTY
109847: ST_TO_ADDR
// to_heal := [ ] ;
109848: LD_ADDR_VAR 0 30
109852: PUSH
109853: EMPTY
109854: ST_TO_ADDR
// repairs := [ ] ;
109855: LD_ADDR_VAR 0 33
109859: PUSH
109860: EMPTY
109861: ST_TO_ADDR
// to_repair := [ ] ;
109862: LD_ADDR_VAR 0 32
109866: PUSH
109867: EMPTY
109868: ST_TO_ADDR
// if not group or not path then
109869: LD_VAR 0 4
109873: NOT
109874: PUSH
109875: LD_VAR 0 5
109879: NOT
109880: OR
109881: IFFALSE 109885
// exit ;
109883: GO 114430
// side := GetSide ( group [ 1 ] ) ;
109885: LD_ADDR_VAR 0 35
109889: PUSH
109890: LD_VAR 0 4
109894: PUSH
109895: LD_INT 1
109897: ARRAY
109898: PPUSH
109899: CALL_OW 255
109903: ST_TO_ADDR
// if flags then
109904: LD_VAR 0 6
109908: IFFALSE 110052
// begin f_ignore_area := flags [ 1 ] ;
109910: LD_ADDR_VAR 0 17
109914: PUSH
109915: LD_VAR 0 6
109919: PUSH
109920: LD_INT 1
109922: ARRAY
109923: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
109924: LD_ADDR_VAR 0 18
109928: PUSH
109929: LD_VAR 0 6
109933: PUSH
109934: LD_INT 2
109936: ARRAY
109937: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
109938: LD_ADDR_VAR 0 19
109942: PUSH
109943: LD_VAR 0 6
109947: PUSH
109948: LD_INT 3
109950: ARRAY
109951: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
109952: LD_ADDR_VAR 0 20
109956: PUSH
109957: LD_VAR 0 6
109961: PUSH
109962: LD_INT 4
109964: ARRAY
109965: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
109966: LD_ADDR_VAR 0 21
109970: PUSH
109971: LD_VAR 0 6
109975: PUSH
109976: LD_INT 5
109978: ARRAY
109979: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
109980: LD_ADDR_VAR 0 22
109984: PUSH
109985: LD_VAR 0 6
109989: PUSH
109990: LD_INT 6
109992: ARRAY
109993: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
109994: LD_ADDR_VAR 0 23
109998: PUSH
109999: LD_VAR 0 6
110003: PUSH
110004: LD_INT 7
110006: ARRAY
110007: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110008: LD_ADDR_VAR 0 24
110012: PUSH
110013: LD_VAR 0 6
110017: PUSH
110018: LD_INT 8
110020: ARRAY
110021: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110022: LD_ADDR_VAR 0 25
110026: PUSH
110027: LD_VAR 0 6
110031: PUSH
110032: LD_INT 9
110034: ARRAY
110035: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110036: LD_ADDR_VAR 0 26
110040: PUSH
110041: LD_VAR 0 6
110045: PUSH
110046: LD_INT 10
110048: ARRAY
110049: ST_TO_ADDR
// end else
110050: GO 110132
// begin f_ignore_area := false ;
110052: LD_ADDR_VAR 0 17
110056: PUSH
110057: LD_INT 0
110059: ST_TO_ADDR
// f_capture := false ;
110060: LD_ADDR_VAR 0 18
110064: PUSH
110065: LD_INT 0
110067: ST_TO_ADDR
// f_ignore_civ := false ;
110068: LD_ADDR_VAR 0 19
110072: PUSH
110073: LD_INT 0
110075: ST_TO_ADDR
// f_murder := false ;
110076: LD_ADDR_VAR 0 20
110080: PUSH
110081: LD_INT 0
110083: ST_TO_ADDR
// f_mines := false ;
110084: LD_ADDR_VAR 0 21
110088: PUSH
110089: LD_INT 0
110091: ST_TO_ADDR
// f_repair := false ;
110092: LD_ADDR_VAR 0 22
110096: PUSH
110097: LD_INT 0
110099: ST_TO_ADDR
// f_heal := false ;
110100: LD_ADDR_VAR 0 23
110104: PUSH
110105: LD_INT 0
110107: ST_TO_ADDR
// f_spacetime := false ;
110108: LD_ADDR_VAR 0 24
110112: PUSH
110113: LD_INT 0
110115: ST_TO_ADDR
// f_attack_depot := false ;
110116: LD_ADDR_VAR 0 25
110120: PUSH
110121: LD_INT 0
110123: ST_TO_ADDR
// f_crawl := false ;
110124: LD_ADDR_VAR 0 26
110128: PUSH
110129: LD_INT 0
110131: ST_TO_ADDR
// end ; if f_heal then
110132: LD_VAR 0 23
110136: IFFALSE 110163
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110138: LD_ADDR_VAR 0 31
110142: PUSH
110143: LD_VAR 0 4
110147: PPUSH
110148: LD_INT 25
110150: PUSH
110151: LD_INT 4
110153: PUSH
110154: EMPTY
110155: LIST
110156: LIST
110157: PPUSH
110158: CALL_OW 72
110162: ST_TO_ADDR
// if f_repair then
110163: LD_VAR 0 22
110167: IFFALSE 110194
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110169: LD_ADDR_VAR 0 33
110173: PUSH
110174: LD_VAR 0 4
110178: PPUSH
110179: LD_INT 25
110181: PUSH
110182: LD_INT 3
110184: PUSH
110185: EMPTY
110186: LIST
110187: LIST
110188: PPUSH
110189: CALL_OW 72
110193: ST_TO_ADDR
// units_path := [ ] ;
110194: LD_ADDR_VAR 0 16
110198: PUSH
110199: EMPTY
110200: ST_TO_ADDR
// for i = 1 to group do
110201: LD_ADDR_VAR 0 7
110205: PUSH
110206: DOUBLE
110207: LD_INT 1
110209: DEC
110210: ST_TO_ADDR
110211: LD_VAR 0 4
110215: PUSH
110216: FOR_TO
110217: IFFALSE 110246
// units_path := Replace ( units_path , i , path ) ;
110219: LD_ADDR_VAR 0 16
110223: PUSH
110224: LD_VAR 0 16
110228: PPUSH
110229: LD_VAR 0 7
110233: PPUSH
110234: LD_VAR 0 5
110238: PPUSH
110239: CALL_OW 1
110243: ST_TO_ADDR
110244: GO 110216
110246: POP
110247: POP
// repeat for i = group downto 1 do
110248: LD_ADDR_VAR 0 7
110252: PUSH
110253: DOUBLE
110254: LD_VAR 0 4
110258: INC
110259: ST_TO_ADDR
110260: LD_INT 1
110262: PUSH
110263: FOR_DOWNTO
110264: IFFALSE 114386
// begin wait ( 5 ) ;
110266: LD_INT 5
110268: PPUSH
110269: CALL_OW 67
// tmp := [ ] ;
110273: LD_ADDR_VAR 0 14
110277: PUSH
110278: EMPTY
110279: ST_TO_ADDR
// attacking := false ;
110280: LD_ADDR_VAR 0 29
110284: PUSH
110285: LD_INT 0
110287: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110288: LD_VAR 0 4
110292: PUSH
110293: LD_VAR 0 7
110297: ARRAY
110298: PPUSH
110299: CALL_OW 301
110303: PUSH
110304: LD_VAR 0 4
110308: PUSH
110309: LD_VAR 0 7
110313: ARRAY
110314: NOT
110315: OR
110316: IFFALSE 110425
// begin if GetType ( group [ i ] ) = unit_human then
110318: LD_VAR 0 4
110322: PUSH
110323: LD_VAR 0 7
110327: ARRAY
110328: PPUSH
110329: CALL_OW 247
110333: PUSH
110334: LD_INT 1
110336: EQUAL
110337: IFFALSE 110383
// begin to_heal := to_heal diff group [ i ] ;
110339: LD_ADDR_VAR 0 30
110343: PUSH
110344: LD_VAR 0 30
110348: PUSH
110349: LD_VAR 0 4
110353: PUSH
110354: LD_VAR 0 7
110358: ARRAY
110359: DIFF
110360: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110361: LD_ADDR_VAR 0 31
110365: PUSH
110366: LD_VAR 0 31
110370: PUSH
110371: LD_VAR 0 4
110375: PUSH
110376: LD_VAR 0 7
110380: ARRAY
110381: DIFF
110382: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110383: LD_ADDR_VAR 0 4
110387: PUSH
110388: LD_VAR 0 4
110392: PPUSH
110393: LD_VAR 0 7
110397: PPUSH
110398: CALL_OW 3
110402: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110403: LD_ADDR_VAR 0 16
110407: PUSH
110408: LD_VAR 0 16
110412: PPUSH
110413: LD_VAR 0 7
110417: PPUSH
110418: CALL_OW 3
110422: ST_TO_ADDR
// continue ;
110423: GO 110263
// end ; if f_repair then
110425: LD_VAR 0 22
110429: IFFALSE 110918
// begin if GetType ( group [ i ] ) = unit_vehicle then
110431: LD_VAR 0 4
110435: PUSH
110436: LD_VAR 0 7
110440: ARRAY
110441: PPUSH
110442: CALL_OW 247
110446: PUSH
110447: LD_INT 2
110449: EQUAL
110450: IFFALSE 110640
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110452: LD_VAR 0 4
110456: PUSH
110457: LD_VAR 0 7
110461: ARRAY
110462: PPUSH
110463: CALL_OW 256
110467: PUSH
110468: LD_INT 700
110470: LESS
110471: PUSH
110472: LD_VAR 0 4
110476: PUSH
110477: LD_VAR 0 7
110481: ARRAY
110482: PUSH
110483: LD_VAR 0 32
110487: IN
110488: NOT
110489: AND
110490: IFFALSE 110514
// to_repair := to_repair union group [ i ] ;
110492: LD_ADDR_VAR 0 32
110496: PUSH
110497: LD_VAR 0 32
110501: PUSH
110502: LD_VAR 0 4
110506: PUSH
110507: LD_VAR 0 7
110511: ARRAY
110512: UNION
110513: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110514: LD_VAR 0 4
110518: PUSH
110519: LD_VAR 0 7
110523: ARRAY
110524: PPUSH
110525: CALL_OW 256
110529: PUSH
110530: LD_INT 1000
110532: EQUAL
110533: PUSH
110534: LD_VAR 0 4
110538: PUSH
110539: LD_VAR 0 7
110543: ARRAY
110544: PUSH
110545: LD_VAR 0 32
110549: IN
110550: AND
110551: IFFALSE 110575
// to_repair := to_repair diff group [ i ] ;
110553: LD_ADDR_VAR 0 32
110557: PUSH
110558: LD_VAR 0 32
110562: PUSH
110563: LD_VAR 0 4
110567: PUSH
110568: LD_VAR 0 7
110572: ARRAY
110573: DIFF
110574: ST_TO_ADDR
// if group [ i ] in to_repair then
110575: LD_VAR 0 4
110579: PUSH
110580: LD_VAR 0 7
110584: ARRAY
110585: PUSH
110586: LD_VAR 0 32
110590: IN
110591: IFFALSE 110638
// begin if not IsInArea ( group [ i ] , f_repair ) then
110593: LD_VAR 0 4
110597: PUSH
110598: LD_VAR 0 7
110602: ARRAY
110603: PPUSH
110604: LD_VAR 0 22
110608: PPUSH
110609: CALL_OW 308
110613: NOT
110614: IFFALSE 110636
// ComMoveToArea ( group [ i ] , f_repair ) ;
110616: LD_VAR 0 4
110620: PUSH
110621: LD_VAR 0 7
110625: ARRAY
110626: PPUSH
110627: LD_VAR 0 22
110631: PPUSH
110632: CALL_OW 113
// continue ;
110636: GO 110263
// end ; end else
110638: GO 110918
// if group [ i ] in repairs then
110640: LD_VAR 0 4
110644: PUSH
110645: LD_VAR 0 7
110649: ARRAY
110650: PUSH
110651: LD_VAR 0 33
110655: IN
110656: IFFALSE 110918
// begin if IsInUnit ( group [ i ] ) then
110658: LD_VAR 0 4
110662: PUSH
110663: LD_VAR 0 7
110667: ARRAY
110668: PPUSH
110669: CALL_OW 310
110673: IFFALSE 110741
// begin z := IsInUnit ( group [ i ] ) ;
110675: LD_ADDR_VAR 0 13
110679: PUSH
110680: LD_VAR 0 4
110684: PUSH
110685: LD_VAR 0 7
110689: ARRAY
110690: PPUSH
110691: CALL_OW 310
110695: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
110696: LD_VAR 0 13
110700: PUSH
110701: LD_VAR 0 32
110705: IN
110706: PUSH
110707: LD_VAR 0 13
110711: PPUSH
110712: LD_VAR 0 22
110716: PPUSH
110717: CALL_OW 308
110721: AND
110722: IFFALSE 110739
// ComExitVehicle ( group [ i ] ) ;
110724: LD_VAR 0 4
110728: PUSH
110729: LD_VAR 0 7
110733: ARRAY
110734: PPUSH
110735: CALL_OW 121
// end else
110739: GO 110918
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
110741: LD_ADDR_VAR 0 13
110745: PUSH
110746: LD_VAR 0 4
110750: PPUSH
110751: LD_INT 95
110753: PUSH
110754: LD_VAR 0 22
110758: PUSH
110759: EMPTY
110760: LIST
110761: LIST
110762: PUSH
110763: LD_INT 58
110765: PUSH
110766: EMPTY
110767: LIST
110768: PUSH
110769: EMPTY
110770: LIST
110771: LIST
110772: PPUSH
110773: CALL_OW 72
110777: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
110778: LD_VAR 0 4
110782: PUSH
110783: LD_VAR 0 7
110787: ARRAY
110788: PPUSH
110789: CALL_OW 314
110793: NOT
110794: IFFALSE 110916
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
110796: LD_ADDR_VAR 0 10
110800: PUSH
110801: LD_VAR 0 13
110805: PPUSH
110806: LD_VAR 0 4
110810: PUSH
110811: LD_VAR 0 7
110815: ARRAY
110816: PPUSH
110817: CALL_OW 74
110821: ST_TO_ADDR
// if not x then
110822: LD_VAR 0 10
110826: NOT
110827: IFFALSE 110831
// continue ;
110829: GO 110263
// if GetLives ( x ) < 1000 then
110831: LD_VAR 0 10
110835: PPUSH
110836: CALL_OW 256
110840: PUSH
110841: LD_INT 1000
110843: LESS
110844: IFFALSE 110868
// ComRepairVehicle ( group [ i ] , x ) else
110846: LD_VAR 0 4
110850: PUSH
110851: LD_VAR 0 7
110855: ARRAY
110856: PPUSH
110857: LD_VAR 0 10
110861: PPUSH
110862: CALL_OW 129
110866: GO 110916
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
110868: LD_VAR 0 23
110872: PUSH
110873: LD_VAR 0 4
110877: PUSH
110878: LD_VAR 0 7
110882: ARRAY
110883: PPUSH
110884: CALL_OW 256
110888: PUSH
110889: LD_INT 1000
110891: LESS
110892: AND
110893: NOT
110894: IFFALSE 110916
// ComEnterUnit ( group [ i ] , x ) ;
110896: LD_VAR 0 4
110900: PUSH
110901: LD_VAR 0 7
110905: ARRAY
110906: PPUSH
110907: LD_VAR 0 10
110911: PPUSH
110912: CALL_OW 120
// end ; continue ;
110916: GO 110263
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
110918: LD_VAR 0 23
110922: PUSH
110923: LD_VAR 0 4
110927: PUSH
110928: LD_VAR 0 7
110932: ARRAY
110933: PPUSH
110934: CALL_OW 247
110938: PUSH
110939: LD_INT 1
110941: EQUAL
110942: AND
110943: IFFALSE 111421
// begin if group [ i ] in healers then
110945: LD_VAR 0 4
110949: PUSH
110950: LD_VAR 0 7
110954: ARRAY
110955: PUSH
110956: LD_VAR 0 31
110960: IN
110961: IFFALSE 111234
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
110963: LD_VAR 0 4
110967: PUSH
110968: LD_VAR 0 7
110972: ARRAY
110973: PPUSH
110974: LD_VAR 0 23
110978: PPUSH
110979: CALL_OW 308
110983: NOT
110984: PUSH
110985: LD_VAR 0 4
110989: PUSH
110990: LD_VAR 0 7
110994: ARRAY
110995: PPUSH
110996: CALL_OW 314
111000: NOT
111001: AND
111002: IFFALSE 111026
// ComMoveToArea ( group [ i ] , f_heal ) else
111004: LD_VAR 0 4
111008: PUSH
111009: LD_VAR 0 7
111013: ARRAY
111014: PPUSH
111015: LD_VAR 0 23
111019: PPUSH
111020: CALL_OW 113
111024: GO 111232
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111026: LD_VAR 0 4
111030: PUSH
111031: LD_VAR 0 7
111035: ARRAY
111036: PPUSH
111037: CALL 53938 0 1
111041: PPUSH
111042: CALL_OW 256
111046: PUSH
111047: LD_INT 1000
111049: EQUAL
111050: IFFALSE 111069
// ComStop ( group [ i ] ) else
111052: LD_VAR 0 4
111056: PUSH
111057: LD_VAR 0 7
111061: ARRAY
111062: PPUSH
111063: CALL_OW 141
111067: GO 111232
// if not HasTask ( group [ i ] ) and to_heal then
111069: LD_VAR 0 4
111073: PUSH
111074: LD_VAR 0 7
111078: ARRAY
111079: PPUSH
111080: CALL_OW 314
111084: NOT
111085: PUSH
111086: LD_VAR 0 30
111090: AND
111091: IFFALSE 111232
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111093: LD_ADDR_VAR 0 13
111097: PUSH
111098: LD_VAR 0 30
111102: PPUSH
111103: LD_INT 3
111105: PUSH
111106: LD_INT 54
111108: PUSH
111109: EMPTY
111110: LIST
111111: PUSH
111112: EMPTY
111113: LIST
111114: LIST
111115: PPUSH
111116: CALL_OW 72
111120: PPUSH
111121: LD_VAR 0 4
111125: PUSH
111126: LD_VAR 0 7
111130: ARRAY
111131: PPUSH
111132: CALL_OW 74
111136: ST_TO_ADDR
// if z then
111137: LD_VAR 0 13
111141: IFFALSE 111232
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111143: LD_INT 91
111145: PUSH
111146: LD_VAR 0 13
111150: PUSH
111151: LD_INT 10
111153: PUSH
111154: EMPTY
111155: LIST
111156: LIST
111157: LIST
111158: PUSH
111159: LD_INT 81
111161: PUSH
111162: LD_VAR 0 13
111166: PPUSH
111167: CALL_OW 255
111171: PUSH
111172: EMPTY
111173: LIST
111174: LIST
111175: PUSH
111176: EMPTY
111177: LIST
111178: LIST
111179: PPUSH
111180: CALL_OW 69
111184: PUSH
111185: LD_INT 0
111187: EQUAL
111188: IFFALSE 111212
// ComHeal ( group [ i ] , z ) else
111190: LD_VAR 0 4
111194: PUSH
111195: LD_VAR 0 7
111199: ARRAY
111200: PPUSH
111201: LD_VAR 0 13
111205: PPUSH
111206: CALL_OW 128
111210: GO 111232
// ComMoveToArea ( group [ i ] , f_heal ) ;
111212: LD_VAR 0 4
111216: PUSH
111217: LD_VAR 0 7
111221: ARRAY
111222: PPUSH
111223: LD_VAR 0 23
111227: PPUSH
111228: CALL_OW 113
// end ; continue ;
111232: GO 110263
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111234: LD_VAR 0 4
111238: PUSH
111239: LD_VAR 0 7
111243: ARRAY
111244: PPUSH
111245: CALL_OW 256
111249: PUSH
111250: LD_INT 700
111252: LESS
111253: PUSH
111254: LD_VAR 0 4
111258: PUSH
111259: LD_VAR 0 7
111263: ARRAY
111264: PUSH
111265: LD_VAR 0 30
111269: IN
111270: NOT
111271: AND
111272: IFFALSE 111296
// to_heal := to_heal union group [ i ] ;
111274: LD_ADDR_VAR 0 30
111278: PUSH
111279: LD_VAR 0 30
111283: PUSH
111284: LD_VAR 0 4
111288: PUSH
111289: LD_VAR 0 7
111293: ARRAY
111294: UNION
111295: ST_TO_ADDR
// if group [ i ] in to_heal then
111296: LD_VAR 0 4
111300: PUSH
111301: LD_VAR 0 7
111305: ARRAY
111306: PUSH
111307: LD_VAR 0 30
111311: IN
111312: IFFALSE 111421
// begin if GetLives ( group [ i ] ) = 1000 then
111314: LD_VAR 0 4
111318: PUSH
111319: LD_VAR 0 7
111323: ARRAY
111324: PPUSH
111325: CALL_OW 256
111329: PUSH
111330: LD_INT 1000
111332: EQUAL
111333: IFFALSE 111359
// to_heal := to_heal diff group [ i ] else
111335: LD_ADDR_VAR 0 30
111339: PUSH
111340: LD_VAR 0 30
111344: PUSH
111345: LD_VAR 0 4
111349: PUSH
111350: LD_VAR 0 7
111354: ARRAY
111355: DIFF
111356: ST_TO_ADDR
111357: GO 111421
// begin if not IsInArea ( group [ i ] , to_heal ) then
111359: LD_VAR 0 4
111363: PUSH
111364: LD_VAR 0 7
111368: ARRAY
111369: PPUSH
111370: LD_VAR 0 30
111374: PPUSH
111375: CALL_OW 308
111379: NOT
111380: IFFALSE 111404
// ComMoveToArea ( group [ i ] , f_heal ) else
111382: LD_VAR 0 4
111386: PUSH
111387: LD_VAR 0 7
111391: ARRAY
111392: PPUSH
111393: LD_VAR 0 23
111397: PPUSH
111398: CALL_OW 113
111402: GO 111419
// ComHold ( group [ i ] ) ;
111404: LD_VAR 0 4
111408: PUSH
111409: LD_VAR 0 7
111413: ARRAY
111414: PPUSH
111415: CALL_OW 140
// continue ;
111419: GO 110263
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111421: LD_VAR 0 4
111425: PUSH
111426: LD_VAR 0 7
111430: ARRAY
111431: PPUSH
111432: LD_INT 10
111434: PPUSH
111435: CALL 52358 0 2
111439: NOT
111440: PUSH
111441: LD_VAR 0 16
111445: PUSH
111446: LD_VAR 0 7
111450: ARRAY
111451: PUSH
111452: EMPTY
111453: EQUAL
111454: NOT
111455: AND
111456: IFFALSE 111722
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111458: LD_VAR 0 4
111462: PUSH
111463: LD_VAR 0 7
111467: ARRAY
111468: PPUSH
111469: CALL_OW 262
111473: PUSH
111474: LD_INT 1
111476: PUSH
111477: LD_INT 2
111479: PUSH
111480: EMPTY
111481: LIST
111482: LIST
111483: IN
111484: IFFALSE 111525
// if GetFuel ( group [ i ] ) < 10 then
111486: LD_VAR 0 4
111490: PUSH
111491: LD_VAR 0 7
111495: ARRAY
111496: PPUSH
111497: CALL_OW 261
111501: PUSH
111502: LD_INT 10
111504: LESS
111505: IFFALSE 111525
// SetFuel ( group [ i ] , 12 ) ;
111507: LD_VAR 0 4
111511: PUSH
111512: LD_VAR 0 7
111516: ARRAY
111517: PPUSH
111518: LD_INT 12
111520: PPUSH
111521: CALL_OW 240
// if units_path [ i ] then
111525: LD_VAR 0 16
111529: PUSH
111530: LD_VAR 0 7
111534: ARRAY
111535: IFFALSE 111720
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111537: LD_VAR 0 4
111541: PUSH
111542: LD_VAR 0 7
111546: ARRAY
111547: PPUSH
111548: LD_VAR 0 16
111552: PUSH
111553: LD_VAR 0 7
111557: ARRAY
111558: PUSH
111559: LD_INT 1
111561: ARRAY
111562: PUSH
111563: LD_INT 1
111565: ARRAY
111566: PPUSH
111567: LD_VAR 0 16
111571: PUSH
111572: LD_VAR 0 7
111576: ARRAY
111577: PUSH
111578: LD_INT 1
111580: ARRAY
111581: PUSH
111582: LD_INT 2
111584: ARRAY
111585: PPUSH
111586: CALL_OW 297
111590: PUSH
111591: LD_INT 6
111593: GREATER
111594: IFFALSE 111669
// begin if not HasTask ( group [ i ] ) then
111596: LD_VAR 0 4
111600: PUSH
111601: LD_VAR 0 7
111605: ARRAY
111606: PPUSH
111607: CALL_OW 314
111611: NOT
111612: IFFALSE 111667
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111614: LD_VAR 0 4
111618: PUSH
111619: LD_VAR 0 7
111623: ARRAY
111624: PPUSH
111625: LD_VAR 0 16
111629: PUSH
111630: LD_VAR 0 7
111634: ARRAY
111635: PUSH
111636: LD_INT 1
111638: ARRAY
111639: PUSH
111640: LD_INT 1
111642: ARRAY
111643: PPUSH
111644: LD_VAR 0 16
111648: PUSH
111649: LD_VAR 0 7
111653: ARRAY
111654: PUSH
111655: LD_INT 1
111657: ARRAY
111658: PUSH
111659: LD_INT 2
111661: ARRAY
111662: PPUSH
111663: CALL_OW 114
// end else
111667: GO 111720
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
111669: LD_ADDR_VAR 0 15
111673: PUSH
111674: LD_VAR 0 16
111678: PUSH
111679: LD_VAR 0 7
111683: ARRAY
111684: PPUSH
111685: LD_INT 1
111687: PPUSH
111688: CALL_OW 3
111692: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
111693: LD_ADDR_VAR 0 16
111697: PUSH
111698: LD_VAR 0 16
111702: PPUSH
111703: LD_VAR 0 7
111707: PPUSH
111708: LD_VAR 0 15
111712: PPUSH
111713: CALL_OW 1
111717: ST_TO_ADDR
// continue ;
111718: GO 110263
// end ; end ; end else
111720: GO 114384
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
111722: LD_ADDR_VAR 0 14
111726: PUSH
111727: LD_INT 81
111729: PUSH
111730: LD_VAR 0 4
111734: PUSH
111735: LD_VAR 0 7
111739: ARRAY
111740: PPUSH
111741: CALL_OW 255
111745: PUSH
111746: EMPTY
111747: LIST
111748: LIST
111749: PPUSH
111750: CALL_OW 69
111754: ST_TO_ADDR
// if not tmp then
111755: LD_VAR 0 14
111759: NOT
111760: IFFALSE 111764
// continue ;
111762: GO 110263
// if f_ignore_area then
111764: LD_VAR 0 17
111768: IFFALSE 111856
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
111770: LD_ADDR_VAR 0 15
111774: PUSH
111775: LD_VAR 0 14
111779: PPUSH
111780: LD_INT 3
111782: PUSH
111783: LD_INT 92
111785: PUSH
111786: LD_VAR 0 17
111790: PUSH
111791: LD_INT 1
111793: ARRAY
111794: PUSH
111795: LD_VAR 0 17
111799: PUSH
111800: LD_INT 2
111802: ARRAY
111803: PUSH
111804: LD_VAR 0 17
111808: PUSH
111809: LD_INT 3
111811: ARRAY
111812: PUSH
111813: EMPTY
111814: LIST
111815: LIST
111816: LIST
111817: LIST
111818: PUSH
111819: EMPTY
111820: LIST
111821: LIST
111822: PPUSH
111823: CALL_OW 72
111827: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111828: LD_VAR 0 14
111832: PUSH
111833: LD_VAR 0 15
111837: DIFF
111838: IFFALSE 111856
// tmp := tmp diff tmp2 ;
111840: LD_ADDR_VAR 0 14
111844: PUSH
111845: LD_VAR 0 14
111849: PUSH
111850: LD_VAR 0 15
111854: DIFF
111855: ST_TO_ADDR
// end ; if not f_murder then
111856: LD_VAR 0 20
111860: NOT
111861: IFFALSE 111919
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
111863: LD_ADDR_VAR 0 15
111867: PUSH
111868: LD_VAR 0 14
111872: PPUSH
111873: LD_INT 3
111875: PUSH
111876: LD_INT 50
111878: PUSH
111879: EMPTY
111880: LIST
111881: PUSH
111882: EMPTY
111883: LIST
111884: LIST
111885: PPUSH
111886: CALL_OW 72
111890: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111891: LD_VAR 0 14
111895: PUSH
111896: LD_VAR 0 15
111900: DIFF
111901: IFFALSE 111919
// tmp := tmp diff tmp2 ;
111903: LD_ADDR_VAR 0 14
111907: PUSH
111908: LD_VAR 0 14
111912: PUSH
111913: LD_VAR 0 15
111917: DIFF
111918: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
111919: LD_ADDR_VAR 0 14
111923: PUSH
111924: LD_VAR 0 4
111928: PUSH
111929: LD_VAR 0 7
111933: ARRAY
111934: PPUSH
111935: LD_VAR 0 14
111939: PPUSH
111940: LD_INT 1
111942: PPUSH
111943: LD_INT 1
111945: PPUSH
111946: CALL 25293 0 4
111950: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
111951: LD_VAR 0 4
111955: PUSH
111956: LD_VAR 0 7
111960: ARRAY
111961: PPUSH
111962: CALL_OW 257
111966: PUSH
111967: LD_INT 1
111969: EQUAL
111970: IFFALSE 112418
// begin if WantPlant ( group [ i ] ) then
111972: LD_VAR 0 4
111976: PUSH
111977: LD_VAR 0 7
111981: ARRAY
111982: PPUSH
111983: CALL 24794 0 1
111987: IFFALSE 111991
// continue ;
111989: GO 110263
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
111991: LD_VAR 0 18
111995: PUSH
111996: LD_VAR 0 4
112000: PUSH
112001: LD_VAR 0 7
112005: ARRAY
112006: PPUSH
112007: CALL_OW 310
112011: NOT
112012: AND
112013: PUSH
112014: LD_VAR 0 14
112018: PUSH
112019: LD_INT 1
112021: ARRAY
112022: PUSH
112023: LD_VAR 0 14
112027: PPUSH
112028: LD_INT 21
112030: PUSH
112031: LD_INT 2
112033: PUSH
112034: EMPTY
112035: LIST
112036: LIST
112037: PUSH
112038: LD_INT 58
112040: PUSH
112041: EMPTY
112042: LIST
112043: PUSH
112044: EMPTY
112045: LIST
112046: LIST
112047: PPUSH
112048: CALL_OW 72
112052: IN
112053: AND
112054: IFFALSE 112090
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112056: LD_VAR 0 4
112060: PUSH
112061: LD_VAR 0 7
112065: ARRAY
112066: PPUSH
112067: LD_VAR 0 14
112071: PUSH
112072: LD_INT 1
112074: ARRAY
112075: PPUSH
112076: CALL_OW 120
// attacking := true ;
112080: LD_ADDR_VAR 0 29
112084: PUSH
112085: LD_INT 1
112087: ST_TO_ADDR
// continue ;
112088: GO 110263
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112090: LD_VAR 0 26
112094: PUSH
112095: LD_VAR 0 4
112099: PUSH
112100: LD_VAR 0 7
112104: ARRAY
112105: PPUSH
112106: CALL_OW 257
112110: PUSH
112111: LD_INT 1
112113: EQUAL
112114: AND
112115: PUSH
112116: LD_VAR 0 4
112120: PUSH
112121: LD_VAR 0 7
112125: ARRAY
112126: PPUSH
112127: CALL_OW 256
112131: PUSH
112132: LD_INT 800
112134: LESS
112135: AND
112136: PUSH
112137: LD_VAR 0 4
112141: PUSH
112142: LD_VAR 0 7
112146: ARRAY
112147: PPUSH
112148: CALL_OW 318
112152: NOT
112153: AND
112154: IFFALSE 112171
// ComCrawl ( group [ i ] ) ;
112156: LD_VAR 0 4
112160: PUSH
112161: LD_VAR 0 7
112165: ARRAY
112166: PPUSH
112167: CALL_OW 137
// if f_mines then
112171: LD_VAR 0 21
112175: IFFALSE 112418
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112177: LD_VAR 0 14
112181: PUSH
112182: LD_INT 1
112184: ARRAY
112185: PPUSH
112186: CALL_OW 247
112190: PUSH
112191: LD_INT 3
112193: EQUAL
112194: PUSH
112195: LD_VAR 0 14
112199: PUSH
112200: LD_INT 1
112202: ARRAY
112203: PUSH
112204: LD_VAR 0 27
112208: IN
112209: NOT
112210: AND
112211: IFFALSE 112418
// begin x := GetX ( tmp [ 1 ] ) ;
112213: LD_ADDR_VAR 0 10
112217: PUSH
112218: LD_VAR 0 14
112222: PUSH
112223: LD_INT 1
112225: ARRAY
112226: PPUSH
112227: CALL_OW 250
112231: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112232: LD_ADDR_VAR 0 11
112236: PUSH
112237: LD_VAR 0 14
112241: PUSH
112242: LD_INT 1
112244: ARRAY
112245: PPUSH
112246: CALL_OW 251
112250: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112251: LD_ADDR_VAR 0 12
112255: PUSH
112256: LD_VAR 0 4
112260: PUSH
112261: LD_VAR 0 7
112265: ARRAY
112266: PPUSH
112267: CALL 52443 0 1
112271: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112272: LD_VAR 0 4
112276: PUSH
112277: LD_VAR 0 7
112281: ARRAY
112282: PPUSH
112283: LD_VAR 0 10
112287: PPUSH
112288: LD_VAR 0 11
112292: PPUSH
112293: LD_VAR 0 14
112297: PUSH
112298: LD_INT 1
112300: ARRAY
112301: PPUSH
112302: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112306: LD_VAR 0 4
112310: PUSH
112311: LD_VAR 0 7
112315: ARRAY
112316: PPUSH
112317: LD_VAR 0 10
112321: PPUSH
112322: LD_VAR 0 12
112326: PPUSH
112327: LD_INT 7
112329: PPUSH
112330: CALL_OW 272
112334: PPUSH
112335: LD_VAR 0 11
112339: PPUSH
112340: LD_VAR 0 12
112344: PPUSH
112345: LD_INT 7
112347: PPUSH
112348: CALL_OW 273
112352: PPUSH
112353: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112357: LD_VAR 0 4
112361: PUSH
112362: LD_VAR 0 7
112366: ARRAY
112367: PPUSH
112368: LD_INT 71
112370: PPUSH
112371: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112375: LD_ADDR_VAR 0 27
112379: PUSH
112380: LD_VAR 0 27
112384: PPUSH
112385: LD_VAR 0 27
112389: PUSH
112390: LD_INT 1
112392: PLUS
112393: PPUSH
112394: LD_VAR 0 14
112398: PUSH
112399: LD_INT 1
112401: ARRAY
112402: PPUSH
112403: CALL_OW 1
112407: ST_TO_ADDR
// attacking := true ;
112408: LD_ADDR_VAR 0 29
112412: PUSH
112413: LD_INT 1
112415: ST_TO_ADDR
// continue ;
112416: GO 110263
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112418: LD_VAR 0 4
112422: PUSH
112423: LD_VAR 0 7
112427: ARRAY
112428: PPUSH
112429: CALL_OW 257
112433: PUSH
112434: LD_INT 17
112436: EQUAL
112437: PUSH
112438: LD_VAR 0 4
112442: PUSH
112443: LD_VAR 0 7
112447: ARRAY
112448: PPUSH
112449: CALL_OW 110
112453: PUSH
112454: LD_INT 71
112456: EQUAL
112457: NOT
112458: AND
112459: IFFALSE 112605
// begin attacking := false ;
112461: LD_ADDR_VAR 0 29
112465: PUSH
112466: LD_INT 0
112468: ST_TO_ADDR
// k := 5 ;
112469: LD_ADDR_VAR 0 9
112473: PUSH
112474: LD_INT 5
112476: ST_TO_ADDR
// if tmp < k then
112477: LD_VAR 0 14
112481: PUSH
112482: LD_VAR 0 9
112486: LESS
112487: IFFALSE 112499
// k := tmp ;
112489: LD_ADDR_VAR 0 9
112493: PUSH
112494: LD_VAR 0 14
112498: ST_TO_ADDR
// for j = 1 to k do
112499: LD_ADDR_VAR 0 8
112503: PUSH
112504: DOUBLE
112505: LD_INT 1
112507: DEC
112508: ST_TO_ADDR
112509: LD_VAR 0 9
112513: PUSH
112514: FOR_TO
112515: IFFALSE 112603
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112517: LD_VAR 0 14
112521: PUSH
112522: LD_VAR 0 8
112526: ARRAY
112527: PUSH
112528: LD_VAR 0 14
112532: PPUSH
112533: LD_INT 58
112535: PUSH
112536: EMPTY
112537: LIST
112538: PPUSH
112539: CALL_OW 72
112543: IN
112544: NOT
112545: IFFALSE 112601
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112547: LD_VAR 0 4
112551: PUSH
112552: LD_VAR 0 7
112556: ARRAY
112557: PPUSH
112558: LD_VAR 0 14
112562: PUSH
112563: LD_VAR 0 8
112567: ARRAY
112568: PPUSH
112569: CALL_OW 115
// attacking := true ;
112573: LD_ADDR_VAR 0 29
112577: PUSH
112578: LD_INT 1
112580: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112581: LD_VAR 0 4
112585: PUSH
112586: LD_VAR 0 7
112590: ARRAY
112591: PPUSH
112592: LD_INT 71
112594: PPUSH
112595: CALL_OW 109
// continue ;
112599: GO 112514
// end ; end ;
112601: GO 112514
112603: POP
112604: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112605: LD_VAR 0 4
112609: PUSH
112610: LD_VAR 0 7
112614: ARRAY
112615: PPUSH
112616: CALL_OW 257
112620: PUSH
112621: LD_INT 8
112623: EQUAL
112624: PUSH
112625: LD_VAR 0 4
112629: PUSH
112630: LD_VAR 0 7
112634: ARRAY
112635: PPUSH
112636: CALL_OW 264
112640: PUSH
112641: LD_INT 28
112643: PUSH
112644: LD_INT 45
112646: PUSH
112647: LD_INT 7
112649: PUSH
112650: LD_INT 47
112652: PUSH
112653: EMPTY
112654: LIST
112655: LIST
112656: LIST
112657: LIST
112658: IN
112659: OR
112660: IFFALSE 112916
// begin attacking := false ;
112662: LD_ADDR_VAR 0 29
112666: PUSH
112667: LD_INT 0
112669: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
112670: LD_VAR 0 14
112674: PUSH
112675: LD_INT 1
112677: ARRAY
112678: PPUSH
112679: CALL_OW 266
112683: PUSH
112684: LD_INT 32
112686: PUSH
112687: LD_INT 31
112689: PUSH
112690: LD_INT 33
112692: PUSH
112693: LD_INT 4
112695: PUSH
112696: LD_INT 5
112698: PUSH
112699: EMPTY
112700: LIST
112701: LIST
112702: LIST
112703: LIST
112704: LIST
112705: IN
112706: IFFALSE 112892
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
112708: LD_ADDR_VAR 0 9
112712: PUSH
112713: LD_VAR 0 14
112717: PUSH
112718: LD_INT 1
112720: ARRAY
112721: PPUSH
112722: CALL_OW 266
112726: PPUSH
112727: LD_VAR 0 14
112731: PUSH
112732: LD_INT 1
112734: ARRAY
112735: PPUSH
112736: CALL_OW 250
112740: PPUSH
112741: LD_VAR 0 14
112745: PUSH
112746: LD_INT 1
112748: ARRAY
112749: PPUSH
112750: CALL_OW 251
112754: PPUSH
112755: LD_VAR 0 14
112759: PUSH
112760: LD_INT 1
112762: ARRAY
112763: PPUSH
112764: CALL_OW 254
112768: PPUSH
112769: LD_VAR 0 14
112773: PUSH
112774: LD_INT 1
112776: ARRAY
112777: PPUSH
112778: CALL_OW 248
112782: PPUSH
112783: LD_INT 0
112785: PPUSH
112786: CALL 33813 0 6
112790: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
112791: LD_ADDR_VAR 0 8
112795: PUSH
112796: LD_VAR 0 4
112800: PUSH
112801: LD_VAR 0 7
112805: ARRAY
112806: PPUSH
112807: LD_VAR 0 9
112811: PPUSH
112812: CALL 52483 0 2
112816: ST_TO_ADDR
// if j then
112817: LD_VAR 0 8
112821: IFFALSE 112890
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
112823: LD_VAR 0 8
112827: PUSH
112828: LD_INT 1
112830: ARRAY
112831: PPUSH
112832: LD_VAR 0 8
112836: PUSH
112837: LD_INT 2
112839: ARRAY
112840: PPUSH
112841: CALL_OW 488
112845: IFFALSE 112890
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
112847: LD_VAR 0 4
112851: PUSH
112852: LD_VAR 0 7
112856: ARRAY
112857: PPUSH
112858: LD_VAR 0 8
112862: PUSH
112863: LD_INT 1
112865: ARRAY
112866: PPUSH
112867: LD_VAR 0 8
112871: PUSH
112872: LD_INT 2
112874: ARRAY
112875: PPUSH
112876: CALL_OW 116
// attacking := true ;
112880: LD_ADDR_VAR 0 29
112884: PUSH
112885: LD_INT 1
112887: ST_TO_ADDR
// continue ;
112888: GO 110263
// end ; end else
112890: GO 112916
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112892: LD_VAR 0 4
112896: PUSH
112897: LD_VAR 0 7
112901: ARRAY
112902: PPUSH
112903: LD_VAR 0 14
112907: PUSH
112908: LD_INT 1
112910: ARRAY
112911: PPUSH
112912: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
112916: LD_VAR 0 4
112920: PUSH
112921: LD_VAR 0 7
112925: ARRAY
112926: PPUSH
112927: CALL_OW 265
112931: PUSH
112932: LD_INT 11
112934: EQUAL
112935: IFFALSE 113213
// begin k := 10 ;
112937: LD_ADDR_VAR 0 9
112941: PUSH
112942: LD_INT 10
112944: ST_TO_ADDR
// x := 0 ;
112945: LD_ADDR_VAR 0 10
112949: PUSH
112950: LD_INT 0
112952: ST_TO_ADDR
// if tmp < k then
112953: LD_VAR 0 14
112957: PUSH
112958: LD_VAR 0 9
112962: LESS
112963: IFFALSE 112975
// k := tmp ;
112965: LD_ADDR_VAR 0 9
112969: PUSH
112970: LD_VAR 0 14
112974: ST_TO_ADDR
// for j = k downto 1 do
112975: LD_ADDR_VAR 0 8
112979: PUSH
112980: DOUBLE
112981: LD_VAR 0 9
112985: INC
112986: ST_TO_ADDR
112987: LD_INT 1
112989: PUSH
112990: FOR_DOWNTO
112991: IFFALSE 113066
// begin if GetType ( tmp [ j ] ) = unit_human then
112993: LD_VAR 0 14
112997: PUSH
112998: LD_VAR 0 8
113002: ARRAY
113003: PPUSH
113004: CALL_OW 247
113008: PUSH
113009: LD_INT 1
113011: EQUAL
113012: IFFALSE 113064
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113014: LD_VAR 0 4
113018: PUSH
113019: LD_VAR 0 7
113023: ARRAY
113024: PPUSH
113025: LD_VAR 0 14
113029: PUSH
113030: LD_VAR 0 8
113034: ARRAY
113035: PPUSH
113036: CALL 52754 0 2
// x := tmp [ j ] ;
113040: LD_ADDR_VAR 0 10
113044: PUSH
113045: LD_VAR 0 14
113049: PUSH
113050: LD_VAR 0 8
113054: ARRAY
113055: ST_TO_ADDR
// attacking := true ;
113056: LD_ADDR_VAR 0 29
113060: PUSH
113061: LD_INT 1
113063: ST_TO_ADDR
// end ; end ;
113064: GO 112990
113066: POP
113067: POP
// if not x then
113068: LD_VAR 0 10
113072: NOT
113073: IFFALSE 113213
// begin attacking := true ;
113075: LD_ADDR_VAR 0 29
113079: PUSH
113080: LD_INT 1
113082: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113083: LD_VAR 0 4
113087: PUSH
113088: LD_VAR 0 7
113092: ARRAY
113093: PPUSH
113094: CALL_OW 250
113098: PPUSH
113099: LD_VAR 0 4
113103: PUSH
113104: LD_VAR 0 7
113108: ARRAY
113109: PPUSH
113110: CALL_OW 251
113114: PPUSH
113115: CALL_OW 546
113119: PUSH
113120: LD_INT 2
113122: ARRAY
113123: PUSH
113124: LD_VAR 0 14
113128: PUSH
113129: LD_INT 1
113131: ARRAY
113132: PPUSH
113133: CALL_OW 250
113137: PPUSH
113138: LD_VAR 0 14
113142: PUSH
113143: LD_INT 1
113145: ARRAY
113146: PPUSH
113147: CALL_OW 251
113151: PPUSH
113152: CALL_OW 546
113156: PUSH
113157: LD_INT 2
113159: ARRAY
113160: EQUAL
113161: IFFALSE 113189
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113163: LD_VAR 0 4
113167: PUSH
113168: LD_VAR 0 7
113172: ARRAY
113173: PPUSH
113174: LD_VAR 0 14
113178: PUSH
113179: LD_INT 1
113181: ARRAY
113182: PPUSH
113183: CALL 52754 0 2
113187: GO 113213
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113189: LD_VAR 0 4
113193: PUSH
113194: LD_VAR 0 7
113198: ARRAY
113199: PPUSH
113200: LD_VAR 0 14
113204: PUSH
113205: LD_INT 1
113207: ARRAY
113208: PPUSH
113209: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113213: LD_VAR 0 4
113217: PUSH
113218: LD_VAR 0 7
113222: ARRAY
113223: PPUSH
113224: CALL_OW 264
113228: PUSH
113229: LD_INT 29
113231: EQUAL
113232: IFFALSE 113598
// begin if WantsToAttack ( group [ i ] ) in bombed then
113234: LD_VAR 0 4
113238: PUSH
113239: LD_VAR 0 7
113243: ARRAY
113244: PPUSH
113245: CALL_OW 319
113249: PUSH
113250: LD_VAR 0 28
113254: IN
113255: IFFALSE 113259
// continue ;
113257: GO 110263
// k := 8 ;
113259: LD_ADDR_VAR 0 9
113263: PUSH
113264: LD_INT 8
113266: ST_TO_ADDR
// x := 0 ;
113267: LD_ADDR_VAR 0 10
113271: PUSH
113272: LD_INT 0
113274: ST_TO_ADDR
// if tmp < k then
113275: LD_VAR 0 14
113279: PUSH
113280: LD_VAR 0 9
113284: LESS
113285: IFFALSE 113297
// k := tmp ;
113287: LD_ADDR_VAR 0 9
113291: PUSH
113292: LD_VAR 0 14
113296: ST_TO_ADDR
// for j = 1 to k do
113297: LD_ADDR_VAR 0 8
113301: PUSH
113302: DOUBLE
113303: LD_INT 1
113305: DEC
113306: ST_TO_ADDR
113307: LD_VAR 0 9
113311: PUSH
113312: FOR_TO
113313: IFFALSE 113445
// begin if GetType ( tmp [ j ] ) = unit_building then
113315: LD_VAR 0 14
113319: PUSH
113320: LD_VAR 0 8
113324: ARRAY
113325: PPUSH
113326: CALL_OW 247
113330: PUSH
113331: LD_INT 3
113333: EQUAL
113334: IFFALSE 113443
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113336: LD_VAR 0 14
113340: PUSH
113341: LD_VAR 0 8
113345: ARRAY
113346: PUSH
113347: LD_VAR 0 28
113351: IN
113352: NOT
113353: PUSH
113354: LD_VAR 0 14
113358: PUSH
113359: LD_VAR 0 8
113363: ARRAY
113364: PPUSH
113365: CALL_OW 313
113369: AND
113370: IFFALSE 113443
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113372: LD_VAR 0 4
113376: PUSH
113377: LD_VAR 0 7
113381: ARRAY
113382: PPUSH
113383: LD_VAR 0 14
113387: PUSH
113388: LD_VAR 0 8
113392: ARRAY
113393: PPUSH
113394: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113398: LD_ADDR_VAR 0 28
113402: PUSH
113403: LD_VAR 0 28
113407: PPUSH
113408: LD_VAR 0 28
113412: PUSH
113413: LD_INT 1
113415: PLUS
113416: PPUSH
113417: LD_VAR 0 14
113421: PUSH
113422: LD_VAR 0 8
113426: ARRAY
113427: PPUSH
113428: CALL_OW 1
113432: ST_TO_ADDR
// attacking := true ;
113433: LD_ADDR_VAR 0 29
113437: PUSH
113438: LD_INT 1
113440: ST_TO_ADDR
// break ;
113441: GO 113445
// end ; end ;
113443: GO 113312
113445: POP
113446: POP
// if not attacking and f_attack_depot then
113447: LD_VAR 0 29
113451: NOT
113452: PUSH
113453: LD_VAR 0 25
113457: AND
113458: IFFALSE 113553
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113460: LD_ADDR_VAR 0 13
113464: PUSH
113465: LD_VAR 0 14
113469: PPUSH
113470: LD_INT 2
113472: PUSH
113473: LD_INT 30
113475: PUSH
113476: LD_INT 0
113478: PUSH
113479: EMPTY
113480: LIST
113481: LIST
113482: PUSH
113483: LD_INT 30
113485: PUSH
113486: LD_INT 1
113488: PUSH
113489: EMPTY
113490: LIST
113491: LIST
113492: PUSH
113493: EMPTY
113494: LIST
113495: LIST
113496: LIST
113497: PPUSH
113498: CALL_OW 72
113502: ST_TO_ADDR
// if z then
113503: LD_VAR 0 13
113507: IFFALSE 113553
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113509: LD_VAR 0 4
113513: PUSH
113514: LD_VAR 0 7
113518: ARRAY
113519: PPUSH
113520: LD_VAR 0 13
113524: PPUSH
113525: LD_VAR 0 4
113529: PUSH
113530: LD_VAR 0 7
113534: ARRAY
113535: PPUSH
113536: CALL_OW 74
113540: PPUSH
113541: CALL_OW 115
// attacking := true ;
113545: LD_ADDR_VAR 0 29
113549: PUSH
113550: LD_INT 1
113552: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113553: LD_VAR 0 4
113557: PUSH
113558: LD_VAR 0 7
113562: ARRAY
113563: PPUSH
113564: CALL_OW 256
113568: PUSH
113569: LD_INT 500
113571: LESS
113572: IFFALSE 113598
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113574: LD_VAR 0 4
113578: PUSH
113579: LD_VAR 0 7
113583: ARRAY
113584: PPUSH
113585: LD_VAR 0 14
113589: PUSH
113590: LD_INT 1
113592: ARRAY
113593: PPUSH
113594: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113598: LD_VAR 0 4
113602: PUSH
113603: LD_VAR 0 7
113607: ARRAY
113608: PPUSH
113609: CALL_OW 264
113613: PUSH
113614: LD_INT 49
113616: EQUAL
113617: IFFALSE 113738
// begin if not HasTask ( group [ i ] ) then
113619: LD_VAR 0 4
113623: PUSH
113624: LD_VAR 0 7
113628: ARRAY
113629: PPUSH
113630: CALL_OW 314
113634: NOT
113635: IFFALSE 113738
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113637: LD_ADDR_VAR 0 9
113641: PUSH
113642: LD_INT 81
113644: PUSH
113645: LD_VAR 0 4
113649: PUSH
113650: LD_VAR 0 7
113654: ARRAY
113655: PPUSH
113656: CALL_OW 255
113660: PUSH
113661: EMPTY
113662: LIST
113663: LIST
113664: PPUSH
113665: CALL_OW 69
113669: PPUSH
113670: LD_VAR 0 4
113674: PUSH
113675: LD_VAR 0 7
113679: ARRAY
113680: PPUSH
113681: CALL_OW 74
113685: ST_TO_ADDR
// if k then
113686: LD_VAR 0 9
113690: IFFALSE 113738
// if GetDistUnits ( group [ i ] , k ) > 10 then
113692: LD_VAR 0 4
113696: PUSH
113697: LD_VAR 0 7
113701: ARRAY
113702: PPUSH
113703: LD_VAR 0 9
113707: PPUSH
113708: CALL_OW 296
113712: PUSH
113713: LD_INT 10
113715: GREATER
113716: IFFALSE 113738
// ComMoveUnit ( group [ i ] , k ) ;
113718: LD_VAR 0 4
113722: PUSH
113723: LD_VAR 0 7
113727: ARRAY
113728: PPUSH
113729: LD_VAR 0 9
113733: PPUSH
113734: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
113738: LD_VAR 0 4
113742: PUSH
113743: LD_VAR 0 7
113747: ARRAY
113748: PPUSH
113749: CALL_OW 256
113753: PUSH
113754: LD_INT 250
113756: LESS
113757: PUSH
113758: LD_VAR 0 4
113762: PUSH
113763: LD_VAR 0 7
113767: ARRAY
113768: PUSH
113769: LD_INT 21
113771: PUSH
113772: LD_INT 2
113774: PUSH
113775: EMPTY
113776: LIST
113777: LIST
113778: PUSH
113779: LD_INT 23
113781: PUSH
113782: LD_INT 2
113784: PUSH
113785: EMPTY
113786: LIST
113787: LIST
113788: PUSH
113789: EMPTY
113790: LIST
113791: LIST
113792: PPUSH
113793: CALL_OW 69
113797: IN
113798: AND
113799: IFFALSE 113924
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
113801: LD_ADDR_VAR 0 9
113805: PUSH
113806: LD_OWVAR 3
113810: PUSH
113811: LD_VAR 0 4
113815: PUSH
113816: LD_VAR 0 7
113820: ARRAY
113821: DIFF
113822: PPUSH
113823: LD_VAR 0 4
113827: PUSH
113828: LD_VAR 0 7
113832: ARRAY
113833: PPUSH
113834: CALL_OW 74
113838: ST_TO_ADDR
// if not k then
113839: LD_VAR 0 9
113843: NOT
113844: IFFALSE 113848
// continue ;
113846: GO 110263
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
113848: LD_VAR 0 9
113852: PUSH
113853: LD_INT 81
113855: PUSH
113856: LD_VAR 0 4
113860: PUSH
113861: LD_VAR 0 7
113865: ARRAY
113866: PPUSH
113867: CALL_OW 255
113871: PUSH
113872: EMPTY
113873: LIST
113874: LIST
113875: PPUSH
113876: CALL_OW 69
113880: IN
113881: PUSH
113882: LD_VAR 0 9
113886: PPUSH
113887: LD_VAR 0 4
113891: PUSH
113892: LD_VAR 0 7
113896: ARRAY
113897: PPUSH
113898: CALL_OW 296
113902: PUSH
113903: LD_INT 5
113905: LESS
113906: AND
113907: IFFALSE 113924
// ComAutodestruct ( group [ i ] ) ;
113909: LD_VAR 0 4
113913: PUSH
113914: LD_VAR 0 7
113918: ARRAY
113919: PPUSH
113920: CALL 52652 0 1
// end ; if f_attack_depot then
113924: LD_VAR 0 25
113928: IFFALSE 114040
// begin k := 6 ;
113930: LD_ADDR_VAR 0 9
113934: PUSH
113935: LD_INT 6
113937: ST_TO_ADDR
// if tmp < k then
113938: LD_VAR 0 14
113942: PUSH
113943: LD_VAR 0 9
113947: LESS
113948: IFFALSE 113960
// k := tmp ;
113950: LD_ADDR_VAR 0 9
113954: PUSH
113955: LD_VAR 0 14
113959: ST_TO_ADDR
// for j = 1 to k do
113960: LD_ADDR_VAR 0 8
113964: PUSH
113965: DOUBLE
113966: LD_INT 1
113968: DEC
113969: ST_TO_ADDR
113970: LD_VAR 0 9
113974: PUSH
113975: FOR_TO
113976: IFFALSE 114038
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
113978: LD_VAR 0 8
113982: PPUSH
113983: CALL_OW 266
113987: PUSH
113988: LD_INT 0
113990: PUSH
113991: LD_INT 1
113993: PUSH
113994: EMPTY
113995: LIST
113996: LIST
113997: IN
113998: IFFALSE 114036
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114000: LD_VAR 0 4
114004: PUSH
114005: LD_VAR 0 7
114009: ARRAY
114010: PPUSH
114011: LD_VAR 0 14
114015: PUSH
114016: LD_VAR 0 8
114020: ARRAY
114021: PPUSH
114022: CALL_OW 115
// attacking := true ;
114026: LD_ADDR_VAR 0 29
114030: PUSH
114031: LD_INT 1
114033: ST_TO_ADDR
// break ;
114034: GO 114038
// end ;
114036: GO 113975
114038: POP
114039: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114040: LD_VAR 0 4
114044: PUSH
114045: LD_VAR 0 7
114049: ARRAY
114050: PPUSH
114051: CALL_OW 302
114055: PUSH
114056: LD_VAR 0 29
114060: NOT
114061: AND
114062: IFFALSE 114384
// begin if GetTag ( group [ i ] ) = 71 then
114064: LD_VAR 0 4
114068: PUSH
114069: LD_VAR 0 7
114073: ARRAY
114074: PPUSH
114075: CALL_OW 110
114079: PUSH
114080: LD_INT 71
114082: EQUAL
114083: IFFALSE 114124
// begin if HasTask ( group [ i ] ) then
114085: LD_VAR 0 4
114089: PUSH
114090: LD_VAR 0 7
114094: ARRAY
114095: PPUSH
114096: CALL_OW 314
114100: IFFALSE 114106
// continue else
114102: GO 110263
114104: GO 114124
// SetTag ( group [ i ] , 0 ) ;
114106: LD_VAR 0 4
114110: PUSH
114111: LD_VAR 0 7
114115: ARRAY
114116: PPUSH
114117: LD_INT 0
114119: PPUSH
114120: CALL_OW 109
// end ; k := 8 ;
114124: LD_ADDR_VAR 0 9
114128: PUSH
114129: LD_INT 8
114131: ST_TO_ADDR
// x := 0 ;
114132: LD_ADDR_VAR 0 10
114136: PUSH
114137: LD_INT 0
114139: ST_TO_ADDR
// if tmp < k then
114140: LD_VAR 0 14
114144: PUSH
114145: LD_VAR 0 9
114149: LESS
114150: IFFALSE 114162
// k := tmp ;
114152: LD_ADDR_VAR 0 9
114156: PUSH
114157: LD_VAR 0 14
114161: ST_TO_ADDR
// for j = 1 to k do
114162: LD_ADDR_VAR 0 8
114166: PUSH
114167: DOUBLE
114168: LD_INT 1
114170: DEC
114171: ST_TO_ADDR
114172: LD_VAR 0 9
114176: PUSH
114177: FOR_TO
114178: IFFALSE 114276
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114180: LD_VAR 0 14
114184: PUSH
114185: LD_VAR 0 8
114189: ARRAY
114190: PPUSH
114191: CALL_OW 247
114195: PUSH
114196: LD_INT 1
114198: EQUAL
114199: PUSH
114200: LD_VAR 0 14
114204: PUSH
114205: LD_VAR 0 8
114209: ARRAY
114210: PPUSH
114211: CALL_OW 256
114215: PUSH
114216: LD_INT 250
114218: LESS
114219: PUSH
114220: LD_VAR 0 20
114224: AND
114225: PUSH
114226: LD_VAR 0 20
114230: NOT
114231: PUSH
114232: LD_VAR 0 14
114236: PUSH
114237: LD_VAR 0 8
114241: ARRAY
114242: PPUSH
114243: CALL_OW 256
114247: PUSH
114248: LD_INT 250
114250: GREATEREQUAL
114251: AND
114252: OR
114253: AND
114254: IFFALSE 114274
// begin x := tmp [ j ] ;
114256: LD_ADDR_VAR 0 10
114260: PUSH
114261: LD_VAR 0 14
114265: PUSH
114266: LD_VAR 0 8
114270: ARRAY
114271: ST_TO_ADDR
// break ;
114272: GO 114276
// end ;
114274: GO 114177
114276: POP
114277: POP
// if x then
114278: LD_VAR 0 10
114282: IFFALSE 114306
// ComAttackUnit ( group [ i ] , x ) else
114284: LD_VAR 0 4
114288: PUSH
114289: LD_VAR 0 7
114293: ARRAY
114294: PPUSH
114295: LD_VAR 0 10
114299: PPUSH
114300: CALL_OW 115
114304: GO 114330
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114306: LD_VAR 0 4
114310: PUSH
114311: LD_VAR 0 7
114315: ARRAY
114316: PPUSH
114317: LD_VAR 0 14
114321: PUSH
114322: LD_INT 1
114324: ARRAY
114325: PPUSH
114326: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114330: LD_VAR 0 4
114334: PUSH
114335: LD_VAR 0 7
114339: ARRAY
114340: PPUSH
114341: CALL_OW 314
114345: NOT
114346: IFFALSE 114384
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114348: LD_VAR 0 4
114352: PUSH
114353: LD_VAR 0 7
114357: ARRAY
114358: PPUSH
114359: LD_VAR 0 14
114363: PPUSH
114364: LD_VAR 0 4
114368: PUSH
114369: LD_VAR 0 7
114373: ARRAY
114374: PPUSH
114375: CALL_OW 74
114379: PPUSH
114380: CALL_OW 115
// end ; end ; end ;
114384: GO 110263
114386: POP
114387: POP
// wait ( 0 0$2 ) ;
114388: LD_INT 70
114390: PPUSH
114391: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114395: LD_VAR 0 4
114399: NOT
114400: PUSH
114401: LD_VAR 0 4
114405: PUSH
114406: EMPTY
114407: EQUAL
114408: OR
114409: PUSH
114410: LD_INT 81
114412: PUSH
114413: LD_VAR 0 35
114417: PUSH
114418: EMPTY
114419: LIST
114420: LIST
114421: PPUSH
114422: CALL_OW 69
114426: NOT
114427: OR
114428: IFFALSE 110248
// end ;
114430: LD_VAR 0 2
114434: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114435: LD_INT 0
114437: PPUSH
114438: PPUSH
114439: PPUSH
114440: PPUSH
114441: PPUSH
114442: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114443: LD_VAR 0 1
114447: NOT
114448: PUSH
114449: LD_EXP 50
114453: PUSH
114454: LD_VAR 0 1
114458: ARRAY
114459: NOT
114460: OR
114461: PUSH
114462: LD_VAR 0 2
114466: NOT
114467: OR
114468: IFFALSE 114472
// exit ;
114470: GO 115026
// side := mc_sides [ base ] ;
114472: LD_ADDR_VAR 0 6
114476: PUSH
114477: LD_EXP 76
114481: PUSH
114482: LD_VAR 0 1
114486: ARRAY
114487: ST_TO_ADDR
// if not side then
114488: LD_VAR 0 6
114492: NOT
114493: IFFALSE 114497
// exit ;
114495: GO 115026
// for i in solds do
114497: LD_ADDR_VAR 0 7
114501: PUSH
114502: LD_VAR 0 2
114506: PUSH
114507: FOR_IN
114508: IFFALSE 114569
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114510: LD_VAR 0 7
114514: PPUSH
114515: CALL_OW 310
114519: PPUSH
114520: CALL_OW 266
114524: PUSH
114525: LD_INT 32
114527: PUSH
114528: LD_INT 31
114530: PUSH
114531: EMPTY
114532: LIST
114533: LIST
114534: IN
114535: IFFALSE 114555
// solds := solds diff i else
114537: LD_ADDR_VAR 0 2
114541: PUSH
114542: LD_VAR 0 2
114546: PUSH
114547: LD_VAR 0 7
114551: DIFF
114552: ST_TO_ADDR
114553: GO 114567
// SetTag ( i , 18 ) ;
114555: LD_VAR 0 7
114559: PPUSH
114560: LD_INT 18
114562: PPUSH
114563: CALL_OW 109
114567: GO 114507
114569: POP
114570: POP
// if not solds then
114571: LD_VAR 0 2
114575: NOT
114576: IFFALSE 114580
// exit ;
114578: GO 115026
// repeat wait ( 0 0$2 ) ;
114580: LD_INT 70
114582: PPUSH
114583: CALL_OW 67
// enemy := mc_scan [ base ] ;
114587: LD_ADDR_VAR 0 4
114591: PUSH
114592: LD_EXP 73
114596: PUSH
114597: LD_VAR 0 1
114601: ARRAY
114602: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114603: LD_EXP 50
114607: PUSH
114608: LD_VAR 0 1
114612: ARRAY
114613: NOT
114614: PUSH
114615: LD_EXP 50
114619: PUSH
114620: LD_VAR 0 1
114624: ARRAY
114625: PUSH
114626: EMPTY
114627: EQUAL
114628: OR
114629: IFFALSE 114666
// begin for i in solds do
114631: LD_ADDR_VAR 0 7
114635: PUSH
114636: LD_VAR 0 2
114640: PUSH
114641: FOR_IN
114642: IFFALSE 114655
// ComStop ( i ) ;
114644: LD_VAR 0 7
114648: PPUSH
114649: CALL_OW 141
114653: GO 114641
114655: POP
114656: POP
// solds := [ ] ;
114657: LD_ADDR_VAR 0 2
114661: PUSH
114662: EMPTY
114663: ST_TO_ADDR
// exit ;
114664: GO 115026
// end ; for i in solds do
114666: LD_ADDR_VAR 0 7
114670: PUSH
114671: LD_VAR 0 2
114675: PUSH
114676: FOR_IN
114677: IFFALSE 114998
// begin if IsInUnit ( i ) then
114679: LD_VAR 0 7
114683: PPUSH
114684: CALL_OW 310
114688: IFFALSE 114699
// ComExitBuilding ( i ) ;
114690: LD_VAR 0 7
114694: PPUSH
114695: CALL_OW 122
// if GetLives ( i ) > 500 then
114699: LD_VAR 0 7
114703: PPUSH
114704: CALL_OW 256
114708: PUSH
114709: LD_INT 500
114711: GREATER
114712: IFFALSE 114765
// begin e := NearestUnitToUnit ( enemy , i ) ;
114714: LD_ADDR_VAR 0 5
114718: PUSH
114719: LD_VAR 0 4
114723: PPUSH
114724: LD_VAR 0 7
114728: PPUSH
114729: CALL_OW 74
114733: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
114734: LD_VAR 0 7
114738: PPUSH
114739: LD_VAR 0 5
114743: PPUSH
114744: CALL_OW 250
114748: PPUSH
114749: LD_VAR 0 5
114753: PPUSH
114754: CALL_OW 251
114758: PPUSH
114759: CALL_OW 114
// end else
114763: GO 114996
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
114765: LD_VAR 0 7
114769: PPUSH
114770: LD_EXP 50
114774: PUSH
114775: LD_VAR 0 1
114779: ARRAY
114780: PPUSH
114781: LD_INT 2
114783: PUSH
114784: LD_INT 30
114786: PUSH
114787: LD_INT 0
114789: PUSH
114790: EMPTY
114791: LIST
114792: LIST
114793: PUSH
114794: LD_INT 30
114796: PUSH
114797: LD_INT 1
114799: PUSH
114800: EMPTY
114801: LIST
114802: LIST
114803: PUSH
114804: LD_INT 30
114806: PUSH
114807: LD_INT 6
114809: PUSH
114810: EMPTY
114811: LIST
114812: LIST
114813: PUSH
114814: EMPTY
114815: LIST
114816: LIST
114817: LIST
114818: LIST
114819: PPUSH
114820: CALL_OW 72
114824: PPUSH
114825: LD_VAR 0 7
114829: PPUSH
114830: CALL_OW 74
114834: PPUSH
114835: CALL_OW 296
114839: PUSH
114840: LD_INT 10
114842: GREATER
114843: IFFALSE 114996
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
114845: LD_ADDR_VAR 0 8
114849: PUSH
114850: LD_EXP 50
114854: PUSH
114855: LD_VAR 0 1
114859: ARRAY
114860: PPUSH
114861: LD_INT 2
114863: PUSH
114864: LD_INT 30
114866: PUSH
114867: LD_INT 0
114869: PUSH
114870: EMPTY
114871: LIST
114872: LIST
114873: PUSH
114874: LD_INT 30
114876: PUSH
114877: LD_INT 1
114879: PUSH
114880: EMPTY
114881: LIST
114882: LIST
114883: PUSH
114884: LD_INT 30
114886: PUSH
114887: LD_INT 6
114889: PUSH
114890: EMPTY
114891: LIST
114892: LIST
114893: PUSH
114894: EMPTY
114895: LIST
114896: LIST
114897: LIST
114898: LIST
114899: PPUSH
114900: CALL_OW 72
114904: PPUSH
114905: LD_VAR 0 7
114909: PPUSH
114910: CALL_OW 74
114914: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
114915: LD_VAR 0 7
114919: PPUSH
114920: LD_VAR 0 8
114924: PPUSH
114925: CALL_OW 250
114929: PPUSH
114930: LD_INT 3
114932: PPUSH
114933: LD_INT 5
114935: PPUSH
114936: CALL_OW 272
114940: PPUSH
114941: LD_VAR 0 8
114945: PPUSH
114946: CALL_OW 251
114950: PPUSH
114951: LD_INT 3
114953: PPUSH
114954: LD_INT 5
114956: PPUSH
114957: CALL_OW 273
114961: PPUSH
114962: CALL_OW 111
// SetTag ( i , 0 ) ;
114966: LD_VAR 0 7
114970: PPUSH
114971: LD_INT 0
114973: PPUSH
114974: CALL_OW 109
// solds := solds diff i ;
114978: LD_ADDR_VAR 0 2
114982: PUSH
114983: LD_VAR 0 2
114987: PUSH
114988: LD_VAR 0 7
114992: DIFF
114993: ST_TO_ADDR
// continue ;
114994: GO 114676
// end ; end ;
114996: GO 114676
114998: POP
114999: POP
// until not solds or not enemy ;
115000: LD_VAR 0 2
115004: NOT
115005: PUSH
115006: LD_VAR 0 4
115010: NOT
115011: OR
115012: IFFALSE 114580
// MC_Reset ( base , 18 ) ;
115014: LD_VAR 0 1
115018: PPUSH
115019: LD_INT 18
115021: PPUSH
115022: CALL 64285 0 2
// end ;
115026: LD_VAR 0 3
115030: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115031: LD_INT 0
115033: PPUSH
115034: PPUSH
115035: PPUSH
115036: PPUSH
115037: PPUSH
115038: PPUSH
115039: PPUSH
115040: PPUSH
115041: PPUSH
115042: PPUSH
115043: PPUSH
115044: PPUSH
115045: PPUSH
115046: PPUSH
115047: PPUSH
115048: PPUSH
115049: PPUSH
115050: PPUSH
115051: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115052: LD_ADDR_VAR 0 12
115056: PUSH
115057: LD_EXP 50
115061: PUSH
115062: LD_VAR 0 1
115066: ARRAY
115067: PPUSH
115068: LD_INT 25
115070: PUSH
115071: LD_INT 3
115073: PUSH
115074: EMPTY
115075: LIST
115076: LIST
115077: PPUSH
115078: CALL_OW 72
115082: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115083: LD_EXP 90
115087: PUSH
115088: LD_VAR 0 1
115092: ARRAY
115093: IFFALSE 115117
// mechs := mechs diff mc_remote_driver [ base ] ;
115095: LD_ADDR_VAR 0 12
115099: PUSH
115100: LD_VAR 0 12
115104: PUSH
115105: LD_EXP 90
115109: PUSH
115110: LD_VAR 0 1
115114: ARRAY
115115: DIFF
115116: ST_TO_ADDR
// for i in mechs do
115117: LD_ADDR_VAR 0 4
115121: PUSH
115122: LD_VAR 0 12
115126: PUSH
115127: FOR_IN
115128: IFFALSE 115163
// if GetTag ( i ) > 0 then
115130: LD_VAR 0 4
115134: PPUSH
115135: CALL_OW 110
115139: PUSH
115140: LD_INT 0
115142: GREATER
115143: IFFALSE 115161
// mechs := mechs diff i ;
115145: LD_ADDR_VAR 0 12
115149: PUSH
115150: LD_VAR 0 12
115154: PUSH
115155: LD_VAR 0 4
115159: DIFF
115160: ST_TO_ADDR
115161: GO 115127
115163: POP
115164: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115165: LD_ADDR_VAR 0 8
115169: PUSH
115170: LD_EXP 50
115174: PUSH
115175: LD_VAR 0 1
115179: ARRAY
115180: PPUSH
115181: LD_INT 2
115183: PUSH
115184: LD_INT 25
115186: PUSH
115187: LD_INT 1
115189: PUSH
115190: EMPTY
115191: LIST
115192: LIST
115193: PUSH
115194: LD_INT 25
115196: PUSH
115197: LD_INT 5
115199: PUSH
115200: EMPTY
115201: LIST
115202: LIST
115203: PUSH
115204: LD_INT 25
115206: PUSH
115207: LD_INT 8
115209: PUSH
115210: EMPTY
115211: LIST
115212: LIST
115213: PUSH
115214: LD_INT 25
115216: PUSH
115217: LD_INT 9
115219: PUSH
115220: EMPTY
115221: LIST
115222: LIST
115223: PUSH
115224: EMPTY
115225: LIST
115226: LIST
115227: LIST
115228: LIST
115229: LIST
115230: PPUSH
115231: CALL_OW 72
115235: ST_TO_ADDR
// if not defenders and not solds then
115236: LD_VAR 0 2
115240: NOT
115241: PUSH
115242: LD_VAR 0 8
115246: NOT
115247: AND
115248: IFFALSE 115252
// exit ;
115250: GO 117022
// depot_under_attack := false ;
115252: LD_ADDR_VAR 0 16
115256: PUSH
115257: LD_INT 0
115259: ST_TO_ADDR
// sold_defenders := [ ] ;
115260: LD_ADDR_VAR 0 17
115264: PUSH
115265: EMPTY
115266: ST_TO_ADDR
// if mechs then
115267: LD_VAR 0 12
115271: IFFALSE 115424
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115273: LD_ADDR_VAR 0 4
115277: PUSH
115278: LD_VAR 0 2
115282: PPUSH
115283: LD_INT 21
115285: PUSH
115286: LD_INT 2
115288: PUSH
115289: EMPTY
115290: LIST
115291: LIST
115292: PPUSH
115293: CALL_OW 72
115297: PUSH
115298: FOR_IN
115299: IFFALSE 115422
// begin if GetTag ( i ) <> 20 then
115301: LD_VAR 0 4
115305: PPUSH
115306: CALL_OW 110
115310: PUSH
115311: LD_INT 20
115313: NONEQUAL
115314: IFFALSE 115328
// SetTag ( i , 20 ) ;
115316: LD_VAR 0 4
115320: PPUSH
115321: LD_INT 20
115323: PPUSH
115324: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115328: LD_VAR 0 4
115332: PPUSH
115333: CALL_OW 263
115337: PUSH
115338: LD_INT 1
115340: EQUAL
115341: PUSH
115342: LD_VAR 0 4
115346: PPUSH
115347: CALL_OW 311
115351: NOT
115352: AND
115353: IFFALSE 115420
// begin un := mechs [ 1 ] ;
115355: LD_ADDR_VAR 0 10
115359: PUSH
115360: LD_VAR 0 12
115364: PUSH
115365: LD_INT 1
115367: ARRAY
115368: ST_TO_ADDR
// ComExit ( un ) ;
115369: LD_VAR 0 10
115373: PPUSH
115374: CALL 56997 0 1
// AddComEnterUnit ( un , i ) ;
115378: LD_VAR 0 10
115382: PPUSH
115383: LD_VAR 0 4
115387: PPUSH
115388: CALL_OW 180
// SetTag ( un , 19 ) ;
115392: LD_VAR 0 10
115396: PPUSH
115397: LD_INT 19
115399: PPUSH
115400: CALL_OW 109
// mechs := mechs diff un ;
115404: LD_ADDR_VAR 0 12
115408: PUSH
115409: LD_VAR 0 12
115413: PUSH
115414: LD_VAR 0 10
115418: DIFF
115419: ST_TO_ADDR
// end ; end ;
115420: GO 115298
115422: POP
115423: POP
// if solds then
115424: LD_VAR 0 8
115428: IFFALSE 115487
// for i in solds do
115430: LD_ADDR_VAR 0 4
115434: PUSH
115435: LD_VAR 0 8
115439: PUSH
115440: FOR_IN
115441: IFFALSE 115485
// if not GetTag ( i ) then
115443: LD_VAR 0 4
115447: PPUSH
115448: CALL_OW 110
115452: NOT
115453: IFFALSE 115483
// begin defenders := defenders union i ;
115455: LD_ADDR_VAR 0 2
115459: PUSH
115460: LD_VAR 0 2
115464: PUSH
115465: LD_VAR 0 4
115469: UNION
115470: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115471: LD_VAR 0 4
115475: PPUSH
115476: LD_INT 18
115478: PPUSH
115479: CALL_OW 109
// end ;
115483: GO 115440
115485: POP
115486: POP
// repeat wait ( 0 0$2 ) ;
115487: LD_INT 70
115489: PPUSH
115490: CALL_OW 67
// enemy := mc_scan [ base ] ;
115494: LD_ADDR_VAR 0 21
115498: PUSH
115499: LD_EXP 73
115503: PUSH
115504: LD_VAR 0 1
115508: ARRAY
115509: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115510: LD_EXP 50
115514: PUSH
115515: LD_VAR 0 1
115519: ARRAY
115520: NOT
115521: PUSH
115522: LD_EXP 50
115526: PUSH
115527: LD_VAR 0 1
115531: ARRAY
115532: PUSH
115533: EMPTY
115534: EQUAL
115535: OR
115536: IFFALSE 115573
// begin for i in defenders do
115538: LD_ADDR_VAR 0 4
115542: PUSH
115543: LD_VAR 0 2
115547: PUSH
115548: FOR_IN
115549: IFFALSE 115562
// ComStop ( i ) ;
115551: LD_VAR 0 4
115555: PPUSH
115556: CALL_OW 141
115560: GO 115548
115562: POP
115563: POP
// defenders := [ ] ;
115564: LD_ADDR_VAR 0 2
115568: PUSH
115569: EMPTY
115570: ST_TO_ADDR
// exit ;
115571: GO 117022
// end ; for i in defenders do
115573: LD_ADDR_VAR 0 4
115577: PUSH
115578: LD_VAR 0 2
115582: PUSH
115583: FOR_IN
115584: IFFALSE 116482
// begin e := NearestUnitToUnit ( enemy , i ) ;
115586: LD_ADDR_VAR 0 13
115590: PUSH
115591: LD_VAR 0 21
115595: PPUSH
115596: LD_VAR 0 4
115600: PPUSH
115601: CALL_OW 74
115605: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115606: LD_ADDR_VAR 0 7
115610: PUSH
115611: LD_EXP 50
115615: PUSH
115616: LD_VAR 0 1
115620: ARRAY
115621: PPUSH
115622: LD_INT 2
115624: PUSH
115625: LD_INT 30
115627: PUSH
115628: LD_INT 0
115630: PUSH
115631: EMPTY
115632: LIST
115633: LIST
115634: PUSH
115635: LD_INT 30
115637: PUSH
115638: LD_INT 1
115640: PUSH
115641: EMPTY
115642: LIST
115643: LIST
115644: PUSH
115645: EMPTY
115646: LIST
115647: LIST
115648: LIST
115649: PPUSH
115650: CALL_OW 72
115654: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
115655: LD_ADDR_VAR 0 16
115659: PUSH
115660: LD_VAR 0 7
115664: NOT
115665: PUSH
115666: LD_VAR 0 7
115670: PPUSH
115671: LD_INT 3
115673: PUSH
115674: LD_INT 24
115676: PUSH
115677: LD_INT 600
115679: PUSH
115680: EMPTY
115681: LIST
115682: LIST
115683: PUSH
115684: EMPTY
115685: LIST
115686: LIST
115687: PPUSH
115688: CALL_OW 72
115692: OR
115693: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
115694: LD_VAR 0 4
115698: PPUSH
115699: CALL_OW 247
115703: PUSH
115704: LD_INT 2
115706: DOUBLE
115707: EQUAL
115708: IFTRUE 115712
115710: GO 116108
115712: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
115713: LD_VAR 0 4
115717: PPUSH
115718: CALL_OW 256
115722: PUSH
115723: LD_INT 1000
115725: EQUAL
115726: PUSH
115727: LD_VAR 0 4
115731: PPUSH
115732: LD_VAR 0 13
115736: PPUSH
115737: CALL_OW 296
115741: PUSH
115742: LD_INT 40
115744: LESS
115745: PUSH
115746: LD_VAR 0 13
115750: PPUSH
115751: LD_EXP 75
115755: PUSH
115756: LD_VAR 0 1
115760: ARRAY
115761: PPUSH
115762: CALL_OW 308
115766: OR
115767: AND
115768: IFFALSE 115890
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
115770: LD_VAR 0 4
115774: PPUSH
115775: CALL_OW 262
115779: PUSH
115780: LD_INT 1
115782: EQUAL
115783: PUSH
115784: LD_VAR 0 4
115788: PPUSH
115789: CALL_OW 261
115793: PUSH
115794: LD_INT 30
115796: LESS
115797: AND
115798: PUSH
115799: LD_VAR 0 7
115803: AND
115804: IFFALSE 115874
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
115806: LD_VAR 0 4
115810: PPUSH
115811: LD_VAR 0 7
115815: PPUSH
115816: LD_VAR 0 4
115820: PPUSH
115821: CALL_OW 74
115825: PPUSH
115826: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
115830: LD_VAR 0 4
115834: PPUSH
115835: LD_VAR 0 7
115839: PPUSH
115840: LD_VAR 0 4
115844: PPUSH
115845: CALL_OW 74
115849: PPUSH
115850: CALL_OW 296
115854: PUSH
115855: LD_INT 6
115857: LESS
115858: IFFALSE 115872
// SetFuel ( i , 100 ) ;
115860: LD_VAR 0 4
115864: PPUSH
115865: LD_INT 100
115867: PPUSH
115868: CALL_OW 240
// end else
115872: GO 115888
// ComAttackUnit ( i , e ) ;
115874: LD_VAR 0 4
115878: PPUSH
115879: LD_VAR 0 13
115883: PPUSH
115884: CALL_OW 115
// end else
115888: GO 115991
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
115890: LD_VAR 0 13
115894: PPUSH
115895: LD_EXP 75
115899: PUSH
115900: LD_VAR 0 1
115904: ARRAY
115905: PPUSH
115906: CALL_OW 308
115910: NOT
115911: PUSH
115912: LD_VAR 0 4
115916: PPUSH
115917: LD_VAR 0 13
115921: PPUSH
115922: CALL_OW 296
115926: PUSH
115927: LD_INT 40
115929: GREATEREQUAL
115930: AND
115931: PUSH
115932: LD_VAR 0 4
115936: PPUSH
115937: CALL_OW 256
115941: PUSH
115942: LD_INT 650
115944: LESSEQUAL
115945: OR
115946: PUSH
115947: LD_VAR 0 4
115951: PPUSH
115952: LD_EXP 74
115956: PUSH
115957: LD_VAR 0 1
115961: ARRAY
115962: PPUSH
115963: CALL_OW 308
115967: NOT
115968: AND
115969: IFFALSE 115991
// ComMoveToArea ( i , mc_parking [ base ] ) ;
115971: LD_VAR 0 4
115975: PPUSH
115976: LD_EXP 74
115980: PUSH
115981: LD_VAR 0 1
115985: ARRAY
115986: PPUSH
115987: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
115991: LD_VAR 0 4
115995: PPUSH
115996: CALL_OW 256
116000: PUSH
116001: LD_INT 1000
116003: LESS
116004: PUSH
116005: LD_VAR 0 4
116009: PPUSH
116010: CALL_OW 263
116014: PUSH
116015: LD_INT 1
116017: EQUAL
116018: AND
116019: PUSH
116020: LD_VAR 0 4
116024: PPUSH
116025: CALL_OW 311
116029: AND
116030: PUSH
116031: LD_VAR 0 4
116035: PPUSH
116036: LD_EXP 74
116040: PUSH
116041: LD_VAR 0 1
116045: ARRAY
116046: PPUSH
116047: CALL_OW 308
116051: AND
116052: IFFALSE 116106
// begin mech := IsDrivenBy ( i ) ;
116054: LD_ADDR_VAR 0 9
116058: PUSH
116059: LD_VAR 0 4
116063: PPUSH
116064: CALL_OW 311
116068: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116069: LD_VAR 0 9
116073: PPUSH
116074: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116078: LD_VAR 0 9
116082: PPUSH
116083: LD_VAR 0 4
116087: PPUSH
116088: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116092: LD_VAR 0 9
116096: PPUSH
116097: LD_VAR 0 4
116101: PPUSH
116102: CALL_OW 180
// end ; end ; unit_human :
116106: GO 116453
116108: LD_INT 1
116110: DOUBLE
116111: EQUAL
116112: IFTRUE 116116
116114: GO 116452
116116: POP
// begin b := IsInUnit ( i ) ;
116117: LD_ADDR_VAR 0 18
116121: PUSH
116122: LD_VAR 0 4
116126: PPUSH
116127: CALL_OW 310
116131: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116132: LD_ADDR_VAR 0 19
116136: PUSH
116137: LD_VAR 0 18
116141: NOT
116142: PUSH
116143: LD_VAR 0 18
116147: PPUSH
116148: CALL_OW 266
116152: PUSH
116153: LD_INT 32
116155: PUSH
116156: LD_INT 31
116158: PUSH
116159: EMPTY
116160: LIST
116161: LIST
116162: IN
116163: OR
116164: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116165: LD_VAR 0 18
116169: PPUSH
116170: CALL_OW 266
116174: PUSH
116175: LD_INT 5
116177: EQUAL
116178: PUSH
116179: LD_VAR 0 4
116183: PPUSH
116184: CALL_OW 257
116188: PUSH
116189: LD_INT 1
116191: PUSH
116192: LD_INT 2
116194: PUSH
116195: LD_INT 3
116197: PUSH
116198: LD_INT 4
116200: PUSH
116201: EMPTY
116202: LIST
116203: LIST
116204: LIST
116205: LIST
116206: IN
116207: AND
116208: IFFALSE 116245
// begin class := AllowSpecClass ( i ) ;
116210: LD_ADDR_VAR 0 20
116214: PUSH
116215: LD_VAR 0 4
116219: PPUSH
116220: CALL 21658 0 1
116224: ST_TO_ADDR
// if class then
116225: LD_VAR 0 20
116229: IFFALSE 116245
// ComChangeProfession ( i , class ) ;
116231: LD_VAR 0 4
116235: PPUSH
116236: LD_VAR 0 20
116240: PPUSH
116241: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116245: LD_VAR 0 16
116249: PUSH
116250: LD_VAR 0 2
116254: PPUSH
116255: LD_INT 21
116257: PUSH
116258: LD_INT 2
116260: PUSH
116261: EMPTY
116262: LIST
116263: LIST
116264: PPUSH
116265: CALL_OW 72
116269: PUSH
116270: LD_INT 1
116272: LESSEQUAL
116273: OR
116274: PUSH
116275: LD_VAR 0 19
116279: AND
116280: PUSH
116281: LD_VAR 0 4
116285: PUSH
116286: LD_VAR 0 17
116290: IN
116291: NOT
116292: AND
116293: IFFALSE 116386
// begin if b then
116295: LD_VAR 0 18
116299: IFFALSE 116348
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116301: LD_VAR 0 18
116305: PPUSH
116306: LD_VAR 0 21
116310: PPUSH
116311: LD_VAR 0 18
116315: PPUSH
116316: CALL_OW 74
116320: PPUSH
116321: CALL_OW 296
116325: PUSH
116326: LD_INT 10
116328: LESS
116329: PUSH
116330: LD_VAR 0 18
116334: PPUSH
116335: CALL_OW 461
116339: PUSH
116340: LD_INT 7
116342: NONEQUAL
116343: AND
116344: IFFALSE 116348
// continue ;
116346: GO 115583
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116348: LD_ADDR_VAR 0 17
116352: PUSH
116353: LD_VAR 0 17
116357: PPUSH
116358: LD_VAR 0 17
116362: PUSH
116363: LD_INT 1
116365: PLUS
116366: PPUSH
116367: LD_VAR 0 4
116371: PPUSH
116372: CALL_OW 1
116376: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116377: LD_VAR 0 4
116381: PPUSH
116382: CALL_OW 122
// end ; if sold_defenders then
116386: LD_VAR 0 17
116390: IFFALSE 116450
// if i in sold_defenders then
116392: LD_VAR 0 4
116396: PUSH
116397: LD_VAR 0 17
116401: IN
116402: IFFALSE 116450
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116404: LD_VAR 0 4
116408: PPUSH
116409: CALL_OW 314
116413: NOT
116414: PUSH
116415: LD_VAR 0 4
116419: PPUSH
116420: LD_VAR 0 13
116424: PPUSH
116425: CALL_OW 296
116429: PUSH
116430: LD_INT 30
116432: LESS
116433: AND
116434: IFFALSE 116450
// ComAttackUnit ( i , e ) ;
116436: LD_VAR 0 4
116440: PPUSH
116441: LD_VAR 0 13
116445: PPUSH
116446: CALL_OW 115
// end ; end ; end ;
116450: GO 116453
116452: POP
// if IsDead ( i ) then
116453: LD_VAR 0 4
116457: PPUSH
116458: CALL_OW 301
116462: IFFALSE 116480
// defenders := defenders diff i ;
116464: LD_ADDR_VAR 0 2
116468: PUSH
116469: LD_VAR 0 2
116473: PUSH
116474: LD_VAR 0 4
116478: DIFF
116479: ST_TO_ADDR
// end ;
116480: GO 115583
116482: POP
116483: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116484: LD_VAR 0 21
116488: NOT
116489: PUSH
116490: LD_VAR 0 2
116494: NOT
116495: OR
116496: PUSH
116497: LD_EXP 50
116501: PUSH
116502: LD_VAR 0 1
116506: ARRAY
116507: NOT
116508: OR
116509: IFFALSE 115487
// MC_Reset ( base , 18 ) ;
116511: LD_VAR 0 1
116515: PPUSH
116516: LD_INT 18
116518: PPUSH
116519: CALL 64285 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116523: LD_ADDR_VAR 0 2
116527: PUSH
116528: LD_VAR 0 2
116532: PUSH
116533: LD_VAR 0 2
116537: PPUSH
116538: LD_INT 2
116540: PUSH
116541: LD_INT 25
116543: PUSH
116544: LD_INT 1
116546: PUSH
116547: EMPTY
116548: LIST
116549: LIST
116550: PUSH
116551: LD_INT 25
116553: PUSH
116554: LD_INT 5
116556: PUSH
116557: EMPTY
116558: LIST
116559: LIST
116560: PUSH
116561: LD_INT 25
116563: PUSH
116564: LD_INT 8
116566: PUSH
116567: EMPTY
116568: LIST
116569: LIST
116570: PUSH
116571: LD_INT 25
116573: PUSH
116574: LD_INT 9
116576: PUSH
116577: EMPTY
116578: LIST
116579: LIST
116580: PUSH
116581: EMPTY
116582: LIST
116583: LIST
116584: LIST
116585: LIST
116586: LIST
116587: PPUSH
116588: CALL_OW 72
116592: DIFF
116593: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116594: LD_VAR 0 21
116598: NOT
116599: PUSH
116600: LD_VAR 0 2
116604: PPUSH
116605: LD_INT 21
116607: PUSH
116608: LD_INT 2
116610: PUSH
116611: EMPTY
116612: LIST
116613: LIST
116614: PPUSH
116615: CALL_OW 72
116619: AND
116620: IFFALSE 116958
// begin tmp := FilterByTag ( defenders , 19 ) ;
116622: LD_ADDR_VAR 0 11
116626: PUSH
116627: LD_VAR 0 2
116631: PPUSH
116632: LD_INT 19
116634: PPUSH
116635: CALL 54127 0 2
116639: ST_TO_ADDR
// if tmp then
116640: LD_VAR 0 11
116644: IFFALSE 116714
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116646: LD_ADDR_VAR 0 11
116650: PUSH
116651: LD_VAR 0 11
116655: PPUSH
116656: LD_INT 25
116658: PUSH
116659: LD_INT 3
116661: PUSH
116662: EMPTY
116663: LIST
116664: LIST
116665: PPUSH
116666: CALL_OW 72
116670: ST_TO_ADDR
// if tmp then
116671: LD_VAR 0 11
116675: IFFALSE 116714
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
116677: LD_ADDR_EXP 62
116681: PUSH
116682: LD_EXP 62
116686: PPUSH
116687: LD_VAR 0 1
116691: PPUSH
116692: LD_EXP 62
116696: PUSH
116697: LD_VAR 0 1
116701: ARRAY
116702: PUSH
116703: LD_VAR 0 11
116707: UNION
116708: PPUSH
116709: CALL_OW 1
116713: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
116714: LD_VAR 0 1
116718: PPUSH
116719: LD_INT 19
116721: PPUSH
116722: CALL 64285 0 2
// repeat wait ( 0 0$1 ) ;
116726: LD_INT 35
116728: PPUSH
116729: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116733: LD_EXP 50
116737: PUSH
116738: LD_VAR 0 1
116742: ARRAY
116743: NOT
116744: PUSH
116745: LD_EXP 50
116749: PUSH
116750: LD_VAR 0 1
116754: ARRAY
116755: PUSH
116756: EMPTY
116757: EQUAL
116758: OR
116759: IFFALSE 116796
// begin for i in defenders do
116761: LD_ADDR_VAR 0 4
116765: PUSH
116766: LD_VAR 0 2
116770: PUSH
116771: FOR_IN
116772: IFFALSE 116785
// ComStop ( i ) ;
116774: LD_VAR 0 4
116778: PPUSH
116779: CALL_OW 141
116783: GO 116771
116785: POP
116786: POP
// defenders := [ ] ;
116787: LD_ADDR_VAR 0 2
116791: PUSH
116792: EMPTY
116793: ST_TO_ADDR
// exit ;
116794: GO 117022
// end ; for i in defenders do
116796: LD_ADDR_VAR 0 4
116800: PUSH
116801: LD_VAR 0 2
116805: PUSH
116806: FOR_IN
116807: IFFALSE 116896
// begin if not IsInArea ( i , mc_parking [ base ] ) then
116809: LD_VAR 0 4
116813: PPUSH
116814: LD_EXP 74
116818: PUSH
116819: LD_VAR 0 1
116823: ARRAY
116824: PPUSH
116825: CALL_OW 308
116829: NOT
116830: IFFALSE 116854
// ComMoveToArea ( i , mc_parking [ base ] ) else
116832: LD_VAR 0 4
116836: PPUSH
116837: LD_EXP 74
116841: PUSH
116842: LD_VAR 0 1
116846: ARRAY
116847: PPUSH
116848: CALL_OW 113
116852: GO 116894
// if GetControl ( i ) = control_manual then
116854: LD_VAR 0 4
116858: PPUSH
116859: CALL_OW 263
116863: PUSH
116864: LD_INT 1
116866: EQUAL
116867: IFFALSE 116894
// if IsDrivenBy ( i ) then
116869: LD_VAR 0 4
116873: PPUSH
116874: CALL_OW 311
116878: IFFALSE 116894
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
116880: LD_VAR 0 4
116884: PPUSH
116885: CALL_OW 311
116889: PPUSH
116890: CALL_OW 121
// end ;
116894: GO 116806
116896: POP
116897: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
116898: LD_VAR 0 2
116902: PPUSH
116903: LD_INT 95
116905: PUSH
116906: LD_EXP 74
116910: PUSH
116911: LD_VAR 0 1
116915: ARRAY
116916: PUSH
116917: EMPTY
116918: LIST
116919: LIST
116920: PPUSH
116921: CALL_OW 72
116925: PUSH
116926: LD_VAR 0 2
116930: EQUAL
116931: PUSH
116932: LD_EXP 73
116936: PUSH
116937: LD_VAR 0 1
116941: ARRAY
116942: OR
116943: PUSH
116944: LD_EXP 50
116948: PUSH
116949: LD_VAR 0 1
116953: ARRAY
116954: NOT
116955: OR
116956: IFFALSE 116726
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
116958: LD_ADDR_EXP 72
116962: PUSH
116963: LD_EXP 72
116967: PPUSH
116968: LD_VAR 0 1
116972: PPUSH
116973: LD_VAR 0 2
116977: PPUSH
116978: LD_INT 21
116980: PUSH
116981: LD_INT 2
116983: PUSH
116984: EMPTY
116985: LIST
116986: LIST
116987: PPUSH
116988: CALL_OW 72
116992: PPUSH
116993: CALL_OW 1
116997: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
116998: LD_VAR 0 1
117002: PPUSH
117003: LD_INT 19
117005: PPUSH
117006: CALL 64285 0 2
// MC_Reset ( base , 20 ) ;
117010: LD_VAR 0 1
117014: PPUSH
117015: LD_INT 20
117017: PPUSH
117018: CALL 64285 0 2
// end ; end_of_file
117022: LD_VAR 0 3
117026: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117027: LD_VAR 0 1
117031: PUSH
117032: LD_INT 200
117034: DOUBLE
117035: GREATEREQUAL
117036: IFFALSE 117044
117038: LD_INT 299
117040: DOUBLE
117041: LESSEQUAL
117042: IFTRUE 117046
117044: GO 117078
117046: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117047: LD_VAR 0 1
117051: PPUSH
117052: LD_VAR 0 2
117056: PPUSH
117057: LD_VAR 0 3
117061: PPUSH
117062: LD_VAR 0 4
117066: PPUSH
117067: LD_VAR 0 5
117071: PPUSH
117072: CALL 105464 0 5
117076: GO 117155
117078: LD_INT 300
117080: DOUBLE
117081: GREATEREQUAL
117082: IFFALSE 117090
117084: LD_INT 399
117086: DOUBLE
117087: LESSEQUAL
117088: IFTRUE 117092
117090: GO 117154
117092: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117093: LD_VAR 0 1
117097: PPUSH
117098: LD_VAR 0 2
117102: PPUSH
117103: LD_VAR 0 3
117107: PPUSH
117108: LD_VAR 0 4
117112: PPUSH
117113: LD_VAR 0 5
117117: PPUSH
117118: LD_VAR 0 6
117122: PPUSH
117123: LD_VAR 0 7
117127: PPUSH
117128: LD_VAR 0 8
117132: PPUSH
117133: LD_VAR 0 9
117137: PPUSH
117138: LD_VAR 0 10
117142: PPUSH
117143: LD_VAR 0 11
117147: PPUSH
117148: CALL 103106 0 11
117152: GO 117155
117154: POP
// end ;
117155: PPOPN 11
117157: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117158: LD_VAR 0 1
117162: PPUSH
117163: LD_VAR 0 2
117167: PPUSH
117168: LD_VAR 0 3
117172: PPUSH
117173: LD_VAR 0 4
117177: PPUSH
117178: LD_VAR 0 5
117182: PPUSH
117183: CALL 105200 0 5
// end ; end_of_file
117187: PPOPN 5
117189: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117190: LD_VAR 0 1
117194: PPUSH
117195: LD_VAR 0 2
117199: PPUSH
117200: LD_VAR 0 3
117204: PPUSH
117205: LD_VAR 0 4
117209: PPUSH
117210: LD_VAR 0 5
117214: PPUSH
117215: LD_VAR 0 6
117219: PPUSH
117220: CALL 90799 0 6
// end ;
117224: PPOPN 6
117226: END
