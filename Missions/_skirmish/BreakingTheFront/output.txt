// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 602 0 0
// SetDiplomacy ;
  42: CALL 814 0 0
// PrepareGame ;
  46: CALL 896 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := 0 ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 0 0$1 trigger game and GameType = 1 and not disableGlobalTimer do
 229: LD_EXP 3
 233: PUSH
 234: LD_EXP 2
 238: PUSH
 239: LD_INT 1
 241: EQUAL
 242: AND
 243: PUSH
 244: LD_EXP 4
 248: NOT
 249: AND
 250: IFFALSE 273
 252: GO 254
 254: DISABLE
// begin enable ;
 255: ENABLE
// display_strings := [ #SkrTime , tick ] ;
 256: LD_ADDR_OWVAR 47
 260: PUSH
 261: LD_STRING #SkrTime
 263: PUSH
 264: LD_OWVAR 1
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: ST_TO_ADDR
// end ;
 273: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 274: LD_EXP 19
 278: PUSH
 279: LD_EXP 3
 283: AND
 284: PUSH
 285: LD_EXP 2
 289: PUSH
 290: LD_INT 1
 292: EQUAL
 293: AND
 294: IFFALSE 355
 296: GO 298
 298: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 299: LD_EXP 19
 303: PUSH
 304: LD_INT 1
 306: ARRAY
 307: PUSH
 308: LD_INT 1
 310: ARRAY
 311: PPUSH
 312: LD_EXP 19
 316: PUSH
 317: LD_INT 1
 319: ARRAY
 320: PUSH
 321: LD_INT 2
 323: ARRAY
 324: PPUSH
 325: LD_EXP 19
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 3
 336: ARRAY
 337: PPUSH
 338: LD_EXP 19
 342: PUSH
 343: LD_INT 1
 345: ARRAY
 346: PUSH
 347: LD_INT 4
 349: ARRAY
 350: PPUSH
 351: CALL 56676 0 4
 355: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 356: LD_EXP 19
 360: PUSH
 361: LD_EXP 3
 365: AND
 366: PUSH
 367: LD_EXP 2
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: IFFALSE 437
 378: GO 380
 380: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 381: LD_EXP 19
 385: PUSH
 386: LD_INT 2
 388: ARRAY
 389: PUSH
 390: LD_INT 1
 392: ARRAY
 393: PPUSH
 394: LD_EXP 19
 398: PUSH
 399: LD_INT 2
 401: ARRAY
 402: PUSH
 403: LD_INT 2
 405: ARRAY
 406: PPUSH
 407: LD_EXP 19
 411: PUSH
 412: LD_INT 2
 414: ARRAY
 415: PUSH
 416: LD_INT 3
 418: ARRAY
 419: PPUSH
 420: LD_EXP 19
 424: PUSH
 425: LD_INT 2
 427: ARRAY
 428: PUSH
 429: LD_INT 4
 431: ARRAY
 432: PPUSH
 433: CALL 56676 0 4
 437: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 438: LD_EXP 19
 442: PUSH
 443: LD_EXP 3
 447: AND
 448: PUSH
 449: LD_EXP 2
 453: PUSH
 454: LD_INT 1
 456: EQUAL
 457: AND
 458: IFFALSE 519
 460: GO 462
 462: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 463: LD_EXP 19
 467: PUSH
 468: LD_INT 3
 470: ARRAY
 471: PUSH
 472: LD_INT 1
 474: ARRAY
 475: PPUSH
 476: LD_EXP 19
 480: PUSH
 481: LD_INT 3
 483: ARRAY
 484: PUSH
 485: LD_INT 2
 487: ARRAY
 488: PPUSH
 489: LD_EXP 19
 493: PUSH
 494: LD_INT 3
 496: ARRAY
 497: PUSH
 498: LD_INT 3
 500: ARRAY
 501: PPUSH
 502: LD_EXP 19
 506: PUSH
 507: LD_INT 3
 509: ARRAY
 510: PUSH
 511: LD_INT 4
 513: ARRAY
 514: PPUSH
 515: CALL 56676 0 4
 519: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 520: LD_EXP 19
 524: PUSH
 525: LD_EXP 3
 529: AND
 530: PUSH
 531: LD_EXP 2
 535: PUSH
 536: LD_INT 1
 538: EQUAL
 539: AND
 540: IFFALSE 601
 542: GO 544
 544: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 545: LD_EXP 19
 549: PUSH
 550: LD_INT 4
 552: ARRAY
 553: PUSH
 554: LD_INT 1
 556: ARRAY
 557: PPUSH
 558: LD_EXP 19
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PPUSH
 571: LD_EXP 19
 575: PUSH
 576: LD_INT 4
 578: ARRAY
 579: PUSH
 580: LD_INT 3
 582: ARRAY
 583: PPUSH
 584: LD_EXP 19
 588: PUSH
 589: LD_INT 4
 591: ARRAY
 592: PUSH
 593: LD_INT 4
 595: ARRAY
 596: PPUSH
 597: CALL 56676 0 4
 601: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 602: LD_INT 0
 604: PPUSH
 605: PPUSH
 606: PPUSH
 607: PPUSH
 608: PPUSH
// if GameType = 1 then
 609: LD_EXP 2
 613: PUSH
 614: LD_INT 1
 616: EQUAL
 617: IFFALSE 686
// begin ban_techs := [ ] ;
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// if sibBombAllowed < 2 then
 626: LD_EXP 23
 630: PUSH
 631: LD_INT 2
 633: LESS
 634: IFFALSE 647
// ban_techs := [ tech_sibFiss ] ;
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: LD_INT 25
 643: PUSH
 644: EMPTY
 645: LIST
 646: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_INT 46
 654: PUSH
 655: LD_INT 47
 657: PUSH
 658: LD_INT 48
 660: PUSH
 661: LD_INT 49
 663: PUSH
 664: LD_INT 50
 666: PUSH
 667: LD_INT 39
 669: PUSH
 670: LD_INT 69
 672: PUSH
 673: LD_INT 40
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: ST_TO_ADDR
// end ; for i = 1 to 8 do
 686: LD_ADDR_VAR 0 2
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_INT 8
 698: PUSH
 699: FOR_TO
 700: IFFALSE 784
// begin if res_techs then
 702: LD_VAR 0 5
 706: IFFALSE 742
// for j in res_techs do
 708: LD_ADDR_VAR 0 3
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: FOR_IN
 719: IFFALSE 740
// SetTech ( j , i , state_researched ) ;
 721: LD_VAR 0 3
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: LD_INT 2
 733: PPUSH
 734: CALL_OW 322
 738: GO 718
 740: POP
 741: POP
// if ban_techs then
 742: LD_VAR 0 4
 746: IFFALSE 782
// for j in ban_techs do
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_VAR 0 4
 757: PUSH
 758: FOR_IN
 759: IFFALSE 780
// SetTech ( j , i , state_disabled ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 322
 778: GO 758
 780: POP
 781: POP
// end ;
 782: GO 699
 784: POP
 785: POP
// if sibBombAllowed = 1 then
 786: LD_EXP 23
 790: PUSH
 791: LD_INT 1
 793: EQUAL
 794: IFFALSE 809
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 796: LD_INT 25
 798: PPUSH
 799: LD_INT 3
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 322
// end ;
 809: LD_VAR 0 1
 813: RET
// export function SetDiplomacy ; begin
 814: LD_INT 0
 816: PPUSH
// if GameType = 1 then
 817: LD_EXP 2
 821: PUSH
 822: LD_INT 1
 824: EQUAL
 825: IFFALSE 891
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 827: LD_INT 1
 829: PPUSH
 830: LD_INT 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 843: LD_INT 3
 845: PPUSH
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 8
 864: PPUSH
 865: LD_INT 1
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 875: LD_INT 6
 877: PPUSH
 878: LD_INT 8
 880: PPUSH
 881: LD_INT 1
 883: PPUSH
 884: LD_INT 1
 886: PPUSH
 887: CALL_OW 80
// end ; end ;
 891: LD_VAR 0 1
 895: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 896: LD_INT 0
 898: PPUSH
 899: PPUSH
 900: PPUSH
 901: PPUSH
// if GameType = 1 then
 902: LD_EXP 2
 906: PUSH
 907: LD_INT 1
 909: EQUAL
 910: IFFALSE 1406
// begin game := false ;
 912: LD_ADDR_EXP 3
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// your_side := 1 ;
 920: LD_ADDR_OWVAR 2
 924: PUSH
 925: LD_INT 1
 927: ST_TO_ADDR
// mc_amer := 1 ;
 928: LD_ADDR_EXP 5
 932: PUSH
 933: LD_INT 1
 935: ST_TO_ADDR
// mc_leg := 2 ;
 936: LD_ADDR_EXP 6
 940: PUSH
 941: LD_INT 2
 943: ST_TO_ADDR
// mc_rus_1 := 3 ;
 944: LD_ADDR_EXP 7
 948: PUSH
 949: LD_INT 3
 951: ST_TO_ADDR
// mc_rus_2 := 4 ;
 952: LD_ADDR_EXP 8
 956: PUSH
 957: LD_INT 4
 959: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 960: LD_ADDR_EXP 19
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: LD_INT 200
 976: PUSH
 977: LD_INT 250
 979: PUSH
 980: LD_INT 300
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_EXP 26
 992: ARRAY
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 13
1002: PUSH
1003: LD_INT 8
1005: PUSH
1006: LD_INT 50
1008: PUSH
1009: LD_INT 500
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 17
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 50
1026: PUSH
1027: LD_INT 300
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 18
1038: PUSH
1039: LD_INT 4
1041: PUSH
1042: LD_INT 5
1044: PUSH
1045: LD_INT 6
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_EXP 26
1057: ARRAY
1058: PUSH
1059: LD_INT 30
1061: PUSH
1062: LD_INT 300
1064: PUSH
1065: LD_INT 450
1067: PUSH
1068: LD_INT 500
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_EXP 26
1080: ARRAY
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: LD_INT 190
1101: PUSH
1102: LD_INT 193
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 182
1115: PUSH
1116: LD_INT 117
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 114
1143: PUSH
1144: LD_INT 152
1146: PUSH
1147: LD_INT 2
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 85
1157: PUSH
1158: LD_INT 38
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i in sources do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: PUSH
1186: FOR_IN
1187: IFFALSE 1222
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1189: LD_VAR 0 2
1193: PUSH
1194: LD_INT 1
1196: ARRAY
1197: PPUSH
1198: LD_VAR 0 2
1202: PUSH
1203: LD_INT 2
1205: ARRAY
1206: PPUSH
1207: LD_VAR 0 2
1211: PUSH
1212: LD_INT 3
1214: ARRAY
1215: PPUSH
1216: CALL_OW 62
1220: GO 1186
1222: POP
1223: POP
// disableGlobalTimer := false ;
1224: LD_ADDR_EXP 4
1228: PUSH
1229: LD_INT 0
1231: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1232: LD_ADDR_EXP 15
1236: PUSH
1237: LD_INT 0
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_OWVAR 67
1258: ARRAY
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: ST_TO_ADDR
// ruOutpost := [ ] ;
1264: LD_ADDR_EXP 14
1268: PUSH
1269: EMPTY
1270: ST_TO_ADDR
// staticMines := [ ] ;
1271: LD_ADDR_EXP 16
1275: PUSH
1276: EMPTY
1277: ST_TO_ADDR
// baseCaptured := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// legDestCounter := 0 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 0
1293: ST_TO_ADDR
// legOfferAccepted := false ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_INT 0
1301: ST_TO_ADDR
// legChangeSide := false ;
1302: LD_ADDR_EXP 21
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// allyDestCounter := 0 ;
1310: LD_ADDR_EXP 22
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// outpostEscape := false ;
1318: LD_ADDR_EXP 27
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// dialogueMineDetected := false ;
1326: LD_ADDR_EXP 28
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// PrepareAmericans ;
1334: CALL 7604 0 0
// PrepareLegion ;
1338: CALL 5538 0 0
// PrepareRussians ;
1342: CALL 2504 0 0
// playerForces := PreparePlayer ;
1346: LD_ADDR_EXP 10
1350: PUSH
1351: CALL 8847 0 0
1355: ST_TO_ADDR
// AnimateTrees ( true ) ;
1356: LD_INT 1
1358: PPUSH
1359: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1363: LD_INT 4
1365: PPUSH
1366: LD_INT 3
1368: PPUSH
1369: LD_INT 8
1371: PPUSH
1372: LD_INT 5
1374: PPUSH
1375: LD_INT 3
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 8
1383: PPUSH
1384: LD_INT 2
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: CALL 54041 0 9
// MC_Start ;
1394: CALL 63485 0 0
// SetAdditionalRussianForces ;
1398: CALL 7273 0 0
// Action ;
1402: CALL 11204 0 0
// end ; end ;
1406: LD_VAR 0 1
1410: RET
// export function CustomInitMacro ; begin
1411: LD_INT 0
1413: PPUSH
// if GameType <> 1 then
1414: LD_EXP 2
1418: PUSH
1419: LD_INT 1
1421: NONEQUAL
1422: IFFALSE 1426
// exit ;
1424: GO 2499
// MC_SetScanArea ( mc_amer , amerBase ) ;
1426: LD_EXP 5
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: CALL 86862 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1438: LD_EXP 5
1442: PPUSH
1443: LD_INT 4
1445: PPUSH
1446: CALL 86806 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1450: LD_EXP 5
1454: PPUSH
1455: LD_INT 11
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 7
1463: PUSH
1464: LD_INT 9
1466: PUSH
1467: LD_INT 10
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: PPUSH
1477: CALL 86694 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1481: LD_EXP 5
1485: PPUSH
1486: LD_INT 5
1488: PPUSH
1489: CALL 86376 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1493: LD_EXP 5
1497: PPUSH
1498: LD_INT 3
1500: PPUSH
1501: CALL 86107 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1505: LD_EXP 5
1509: PPUSH
1510: LD_INT 4
1512: PPUSH
1513: CALL 85726 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1517: LD_EXP 5
1521: PPUSH
1522: LD_INT 3
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 2
1530: PUSH
1531: LD_INT 5
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: LD_INT 9
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 4
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: LD_INT 2
1566: PUSH
1567: LD_INT 7
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: PUSH
1576: LD_INT 4
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: LD_INT 2
1584: PUSH
1585: LD_INT 6
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL 85541 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1604: LD_EXP 5
1608: PPUSH
1609: LD_INT 33
1611: PUSH
1612: LD_INT 114
1614: PUSH
1615: LD_INT 16
1617: PUSH
1618: LD_INT 0
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 110
1632: PUSH
1633: LD_INT 12
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL 85433 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1653: LD_EXP 5
1657: PPUSH
1658: LD_INT 10
1660: PUSH
1661: LD_INT 15
1663: PUSH
1664: LD_INT 12
1666: PUSH
1667: LD_INT 11
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL 86283 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1680: LD_EXP 6
1684: PPUSH
1685: LD_INT 6
1687: PPUSH
1688: CALL 86862 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1692: LD_EXP 6
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL 86806 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1704: LD_EXP 6
1708: PPUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 27
1714: PUSH
1715: LD_INT 28
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL 86694 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1731: LD_EXP 6
1735: PPUSH
1736: LD_INT 17
1738: PPUSH
1739: CALL 86376 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1743: LD_EXP 6
1747: PPUSH
1748: LD_INT 6
1750: PPUSH
1751: CALL 86107 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1755: LD_EXP 6
1759: PPUSH
1760: LD_INT 5
1762: PPUSH
1763: CALL 85726 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1767: LD_EXP 6
1771: PPUSH
1772: LD_INT 10
1774: PPUSH
1775: LD_INT 9
1777: PPUSH
1778: CALL 85223 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1782: LD_EXP 6
1786: PPUSH
1787: LD_INT 4
1789: PUSH
1790: LD_INT 157
1792: PUSH
1793: LD_INT 144
1795: PUSH
1796: LD_INT 0
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 32
1807: PUSH
1808: LD_INT 151
1810: PUSH
1811: LD_INT 142
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 32
1825: PUSH
1826: LD_INT 161
1828: PUSH
1829: LD_INT 144
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 32
1843: PUSH
1844: LD_INT 140
1846: PUSH
1847: LD_INT 133
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL 85433 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1869: LD_EXP 6
1873: PPUSH
1874: LD_INT 13
1876: PUSH
1877: LD_INT 2
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 31
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 13
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 31
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 13
1912: PUSH
1913: LD_INT 1
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 27
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: LD_INT 13
1930: PUSH
1931: LD_INT 1
1933: PUSH
1934: LD_INT 2
1936: PUSH
1937: LD_INT 27
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: PUSH
1946: LD_INT 13
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 27
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 13
1966: PUSH
1967: LD_INT 1
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 28
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 13
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 28
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 13
2002: PUSH
2003: LD_INT 1
2005: PUSH
2006: LD_INT 2
2008: PUSH
2009: LD_INT 32
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_INT 13
2020: PUSH
2021: LD_INT 1
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 88
2029: PUSH
2030: EMPTY
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 85541 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2051: LD_INT 165
2053: PPUSH
2054: LD_INT 156
2056: PPUSH
2057: LD_INT 8
2059: PPUSH
2060: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2064: LD_EXP 7
2068: PPUSH
2069: LD_INT 15
2071: PPUSH
2072: CALL 86862 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2076: LD_EXP 7
2080: PPUSH
2081: LD_INT 16
2083: PPUSH
2084: CALL 86806 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2088: LD_EXP 7
2092: PPUSH
2093: LD_INT 43
2095: PUSH
2096: LD_INT 47
2098: PUSH
2099: LD_INT 45
2101: PUSH
2102: LD_INT 49
2104: PUSH
2105: LD_INT 46
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PPUSH
2115: CALL 86694 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2119: LD_EXP 7
2123: PPUSH
2124: LD_INT 13
2126: PPUSH
2127: CALL 86376 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2131: LD_EXP 7
2135: PPUSH
2136: LD_INT 15
2138: PPUSH
2139: CALL 86107 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2143: LD_EXP 7
2147: PPUSH
2148: LD_INT 5
2150: PPUSH
2151: CALL 85726 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2155: LD_EXP 7
2159: PPUSH
2160: LD_INT 23
2162: PUSH
2163: LD_INT 1
2165: PUSH
2166: LD_INT 3
2168: PUSH
2169: LD_INT 46
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: PUSH
2178: LD_INT 23
2180: PUSH
2181: LD_INT 1
2183: PUSH
2184: LD_INT 1
2186: PUSH
2187: LD_INT 46
2189: PUSH
2190: EMPTY
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_INT 23
2198: PUSH
2199: LD_INT 1
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 45
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 23
2216: PUSH
2217: LD_INT 1
2219: PUSH
2220: LD_INT 1
2222: PUSH
2223: LD_INT 47
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 23
2234: PUSH
2235: LD_INT 1
2237: PUSH
2238: LD_INT 3
2240: PUSH
2241: LD_INT 46
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 21
2252: PUSH
2253: LD_INT 1
2255: PUSH
2256: LD_INT 3
2258: PUSH
2259: LD_INT 51
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: LD_INT 21
2270: PUSH
2271: LD_INT 1
2273: PUSH
2274: LD_INT 3
2276: PUSH
2277: LD_INT 52
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: LIST
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: PPUSH
2295: CALL 85541 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2299: LD_EXP 8
2303: PPUSH
2304: LD_INT 11
2306: PPUSH
2307: CALL 86862 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2311: LD_EXP 8
2315: PPUSH
2316: LD_INT 12
2318: PPUSH
2319: CALL 86806 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2323: LD_EXP 8
2327: PPUSH
2328: LD_INT 43
2330: PUSH
2331: LD_INT 47
2333: PUSH
2334: LD_INT 45
2336: PUSH
2337: LD_INT 49
2339: PUSH
2340: LD_INT 46
2342: PUSH
2343: EMPTY
2344: LIST
2345: LIST
2346: LIST
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL 86694 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2354: LD_EXP 8
2358: PPUSH
2359: LD_INT 13
2361: PPUSH
2362: CALL 86376 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2366: LD_EXP 8
2370: PPUSH
2371: LD_INT 11
2373: PPUSH
2374: CALL 86107 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2378: LD_EXP 8
2382: PPUSH
2383: LD_INT 4
2385: PPUSH
2386: CALL 85726 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2390: LD_EXP 8
2394: PPUSH
2395: LD_INT 115
2397: PUSH
2398: LD_INT 201
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: EMPTY
2406: LIST
2407: PPUSH
2408: CALL 86432 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2412: LD_EXP 8
2416: PPUSH
2417: LD_INT 24
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 3
2425: PUSH
2426: LD_INT 46
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_INT 24
2437: PUSH
2438: LD_INT 3
2440: PUSH
2441: LD_INT 3
2443: PUSH
2444: LD_INT 46
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 24
2455: PUSH
2456: LD_INT 3
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 46
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 24
2473: PUSH
2474: LD_INT 3
2476: PUSH
2477: LD_INT 3
2479: PUSH
2480: LD_INT 46
2482: PUSH
2483: EMPTY
2484: LIST
2485: LIST
2486: LIST
2487: LIST
2488: PUSH
2489: EMPTY
2490: LIST
2491: LIST
2492: LIST
2493: LIST
2494: PPUSH
2495: CALL 85541 0 2
// end ;
2499: LD_VAR 0 1
2503: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2504: LD_INT 0
2506: PPUSH
2507: PPUSH
2508: PPUSH
2509: PPUSH
2510: PPUSH
2511: PPUSH
2512: PPUSH
2513: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2514: LD_INT 0
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: LD_INT 0
2525: PPUSH
2526: LD_INT 0
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 0
2534: PPUSH
2535: LD_INT 14
2537: PPUSH
2538: LD_INT 0
2540: PPUSH
2541: CALL 54041 0 9
// side := 3 ;
2545: LD_ADDR_VAR 0 5
2549: PUSH
2550: LD_INT 3
2552: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2553: LD_INT 38
2555: PPUSH
2556: LD_VAR 0 5
2560: PPUSH
2561: LD_INT 2
2563: PPUSH
2564: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2568: LD_INT 39
2570: PPUSH
2571: LD_VAR 0 5
2575: PPUSH
2576: LD_INT 2
2578: PPUSH
2579: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2583: LD_INT 34
2585: PPUSH
2586: LD_VAR 0 5
2590: PPUSH
2591: LD_INT 2
2593: PPUSH
2594: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2598: LD_ADDR_VAR 0 4
2602: PUSH
2603: LD_INT 0
2605: PUSH
2606: LD_INT 208
2608: PUSH
2609: LD_INT 163
2611: PUSH
2612: LD_INT 4
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: LD_INT 0
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 3
2631: PUSH
2632: LD_INT 194
2634: PUSH
2635: LD_INT 161
2637: PUSH
2638: LD_INT 1
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: LD_INT 0
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: PUSH
2655: LD_INT 17
2657: PUSH
2658: LD_INT 190
2660: PUSH
2661: LD_INT 161
2663: PUSH
2664: LD_INT 1
2666: PUSH
2667: LD_INT 0
2669: PUSH
2670: LD_INT 0
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: LIST
2680: PUSH
2681: LD_INT 5
2683: PUSH
2684: LD_INT 200
2686: PUSH
2687: LD_INT 145
2689: PUSH
2690: LD_INT 3
2692: PUSH
2693: LD_INT 0
2695: PUSH
2696: LD_INT 0
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 32
2709: PUSH
2710: LD_INT 192
2712: PUSH
2713: LD_INT 144
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: LD_INT 0
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PUSH
2733: LD_INT 26
2735: PUSH
2736: LD_INT 216
2738: PUSH
2739: LD_INT 172
2741: PUSH
2742: LD_INT 3
2744: PUSH
2745: LD_INT 0
2747: PUSH
2748: LD_INT 0
2750: PUSH
2751: EMPTY
2752: LIST
2753: LIST
2754: LIST
2755: LIST
2756: LIST
2757: LIST
2758: PUSH
2759: LD_INT 26
2761: PUSH
2762: LD_INT 218
2764: PUSH
2765: LD_INT 176
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: LD_INT 0
2773: PUSH
2774: LD_INT 0
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 29
2787: PUSH
2788: LD_INT 182
2790: PUSH
2791: LD_INT 149
2793: PUSH
2794: LD_INT 3
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: LD_INT 0
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: LD_INT 201
2816: PUSH
2817: LD_INT 171
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: LD_INT 11
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 32
2839: PUSH
2840: LD_INT 188
2842: PUSH
2843: LD_INT 167
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: LD_INT 0
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: PUSH
2863: LD_INT 32
2865: PUSH
2866: LD_INT 202
2868: PUSH
2869: LD_INT 179
2871: PUSH
2872: LD_INT 0
2874: PUSH
2875: LD_INT 0
2877: PUSH
2878: LD_INT 0
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: PUSH
2889: LD_INT 32
2891: PUSH
2892: LD_INT 209
2894: PUSH
2895: LD_INT 182
2897: PUSH
2898: LD_INT 0
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: LD_INT 0
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: PUSH
2915: LD_INT 32
2917: PUSH
2918: LD_INT 220
2920: PUSH
2921: LD_INT 183
2923: PUSH
2924: LD_INT 5
2926: PUSH
2927: LD_INT 0
2929: PUSH
2930: LD_INT 0
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: PUSH
2941: LD_INT 32
2943: PUSH
2944: LD_INT 225
2946: PUSH
2947: LD_INT 181
2949: PUSH
2950: LD_INT 5
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 0
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: PUSH
2967: LD_INT 26
2969: PUSH
2970: LD_INT 220
2972: PUSH
2973: LD_INT 174
2975: PUSH
2976: LD_INT 5
2978: PUSH
2979: LD_INT 0
2981: PUSH
2982: LD_INT 0
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 84
2998: PUSH
2999: LD_INT 128
3001: PUSH
3002: LD_INT 4
3004: PUSH
3005: LD_INT 0
3007: PUSH
3008: LD_INT 0
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 3
3021: PUSH
3022: LD_INT 68
3024: PUSH
3025: LD_INT 121
3027: PUSH
3028: LD_INT 1
3030: PUSH
3031: LD_INT 0
3033: PUSH
3034: LD_INT 0
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 19
3047: PUSH
3048: LD_INT 72
3050: PUSH
3051: LD_INT 125
3053: PUSH
3054: LD_INT 5
3056: PUSH
3057: LD_INT 0
3059: PUSH
3060: LD_INT 0
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: PUSH
3071: LD_INT 18
3073: PUSH
3074: LD_INT 68
3076: PUSH
3077: LD_INT 124
3079: PUSH
3080: LD_INT 0
3082: PUSH
3083: LD_INT 0
3085: PUSH
3086: LD_INT 0
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_INT 24
3099: PUSH
3100: LD_INT 64
3102: PUSH
3103: LD_INT 121
3105: PUSH
3106: LD_INT 1
3108: PUSH
3109: LD_INT 0
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 17
3125: PUSH
3126: LD_INT 65
3128: PUSH
3129: LD_INT 118
3131: PUSH
3132: LD_INT 2
3134: PUSH
3135: LD_INT 0
3137: PUSH
3138: LD_INT 0
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 21
3151: PUSH
3152: LD_INT 68
3154: PUSH
3155: LD_INT 117
3157: PUSH
3158: LD_INT 3
3160: PUSH
3161: LD_INT 0
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: PUSH
3175: LD_INT 8
3177: PUSH
3178: LD_INT 68
3180: PUSH
3181: LD_INT 130
3183: PUSH
3184: LD_INT 1
3186: PUSH
3187: LD_INT 14
3189: PUSH
3190: LD_INT 10
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: PUSH
3201: LD_INT 8
3203: PUSH
3204: LD_INT 67
3206: PUSH
3207: LD_INT 110
3209: PUSH
3210: LD_INT 2
3212: PUSH
3213: LD_INT 11
3215: PUSH
3216: LD_INT 12
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 28
3229: PUSH
3230: LD_INT 85
3232: PUSH
3233: LD_INT 108
3235: PUSH
3236: LD_INT 2
3238: PUSH
3239: LD_INT 0
3241: PUSH
3242: LD_INT 0
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 28
3255: PUSH
3256: LD_INT 85
3258: PUSH
3259: LD_INT 124
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: LD_INT 0
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 30
3281: PUSH
3282: LD_INT 97
3284: PUSH
3285: LD_INT 119
3287: PUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 0
3293: PUSH
3294: LD_INT 0
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: PUSH
3305: LD_INT 5
3307: PUSH
3308: LD_INT 111
3310: PUSH
3311: LD_INT 138
3313: PUSH
3314: LD_INT 4
3316: PUSH
3317: LD_INT 0
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 33
3333: PUSH
3334: LD_INT 104
3336: PUSH
3337: LD_INT 130
3339: PUSH
3340: LD_INT 3
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 33
3359: PUSH
3360: LD_INT 110
3362: PUSH
3363: LD_INT 142
3365: PUSH
3366: LD_INT 5
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 33
3385: PUSH
3386: LD_INT 91
3388: PUSH
3389: LD_INT 131
3391: PUSH
3392: LD_INT 5
3394: PUSH
3395: LD_INT 0
3397: PUSH
3398: LD_INT 0
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 33
3411: PUSH
3412: LD_INT 107
3414: PUSH
3415: LD_INT 157
3417: PUSH
3418: LD_INT 5
3420: PUSH
3421: LD_INT 0
3423: PUSH
3424: LD_INT 0
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 33
3437: PUSH
3438: LD_INT 104
3440: PUSH
3441: LD_INT 160
3443: PUSH
3444: LD_INT 5
3446: PUSH
3447: LD_INT 0
3449: PUSH
3450: LD_INT 0
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 33
3463: PUSH
3464: LD_INT 101
3466: PUSH
3467: LD_INT 162
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 0
3475: PUSH
3476: LD_INT 0
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 32
3489: PUSH
3490: LD_INT 87
3492: PUSH
3493: LD_INT 157
3495: PUSH
3496: LD_INT 5
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: LD_INT 0
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 32
3515: PUSH
3516: LD_INT 105
3518: PUSH
3519: LD_INT 158
3521: PUSH
3522: LD_INT 5
3524: PUSH
3525: LD_INT 0
3527: PUSH
3528: LD_INT 0
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 33
3541: PUSH
3542: LD_INT 91
3544: PUSH
3545: LD_INT 118
3547: PUSH
3548: LD_INT 4
3550: PUSH
3551: LD_INT 0
3553: PUSH
3554: LD_INT 0
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 33
3567: PUSH
3568: LD_INT 89
3570: PUSH
3571: LD_INT 107
3573: PUSH
3574: LD_INT 4
3576: PUSH
3577: LD_INT 0
3579: PUSH
3580: LD_INT 0
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 86
3596: PUSH
3597: LD_INT 96
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: LD_INT 0
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 33
3619: PUSH
3620: LD_INT 91
3622: PUSH
3623: LD_INT 102
3625: PUSH
3626: LD_INT 4
3628: PUSH
3629: LD_INT 0
3631: PUSH
3632: LD_INT 0
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 32
3645: PUSH
3646: LD_INT 80
3648: PUSH
3649: LD_INT 95
3651: PUSH
3652: LD_INT 3
3654: PUSH
3655: LD_INT 0
3657: PUSH
3658: LD_INT 0
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 28
3671: PUSH
3672: LD_INT 77
3674: PUSH
3675: LD_INT 105
3677: PUSH
3678: LD_INT 3
3680: PUSH
3681: LD_INT 0
3683: PUSH
3684: LD_INT 0
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: LIST
3692: LIST
3693: LIST
3694: PUSH
3695: LD_INT 28
3697: PUSH
3698: LD_INT 85
3700: PUSH
3701: LD_INT 113
3703: PUSH
3704: LD_INT 3
3706: PUSH
3707: LD_INT 0
3709: PUSH
3710: LD_INT 0
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 28
3723: PUSH
3724: LD_INT 55
3726: PUSH
3727: LD_INT 97
3729: PUSH
3730: LD_INT 3
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 0
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 28
3749: PUSH
3750: LD_INT 88
3752: PUSH
3753: LD_INT 128
3755: PUSH
3756: LD_INT 3
3758: PUSH
3759: LD_INT 0
3761: PUSH
3762: LD_INT 0
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 32
3775: PUSH
3776: LD_INT 69
3778: PUSH
3779: LD_INT 101
3781: PUSH
3782: LD_INT 2
3784: PUSH
3785: LD_INT 0
3787: PUSH
3788: LD_INT 0
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: PUSH
3799: LD_INT 1
3801: PUSH
3802: LD_INT 34
3804: PUSH
3805: LD_INT 23
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: LD_INT 0
3813: PUSH
3814: LD_INT 0
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 25
3830: PUSH
3831: LD_INT 4
3833: PUSH
3834: LD_INT 3
3836: PUSH
3837: LD_INT 11
3839: PUSH
3840: LD_INT 10
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 8
3853: PUSH
3854: LD_INT 15
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: LD_INT 2
3862: PUSH
3863: LD_INT 14
3865: PUSH
3866: LD_INT 12
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 29
3879: PUSH
3880: LD_INT 55
3882: PUSH
3883: LD_INT 35
3885: PUSH
3886: LD_INT 2
3888: PUSH
3889: LD_INT 0
3891: PUSH
3892: LD_INT 0
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 29
3905: PUSH
3906: LD_INT 24
3908: PUSH
3909: LD_INT 44
3911: PUSH
3912: LD_INT 2
3914: PUSH
3915: LD_INT 0
3917: PUSH
3918: LD_INT 0
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: PUSH
3929: LD_INT 34
3931: PUSH
3932: LD_INT 34
3934: PUSH
3935: LD_INT 32
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: LD_INT 0
3943: PUSH
3944: LD_INT 0
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: PUSH
3955: LD_INT 3
3957: PUSH
3958: LD_INT 14
3960: PUSH
3961: LD_INT 16
3963: PUSH
3964: LD_INT 1
3966: PUSH
3967: LD_INT 0
3969: PUSH
3970: LD_INT 0
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: PUSH
3981: LD_INT 24
3983: PUSH
3984: LD_INT 10
3986: PUSH
3987: LD_INT 16
3989: PUSH
3990: LD_INT 1
3992: PUSH
3993: LD_INT 0
3995: PUSH
3996: LD_INT 0
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_INT 21
4009: PUSH
4010: LD_INT 11
4012: PUSH
4013: LD_INT 13
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: LD_INT 0
4021: PUSH
4022: LD_INT 0
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: PUSH
4033: LD_INT 18
4035: PUSH
4036: LD_INT 14
4038: PUSH
4039: LD_INT 12
4041: PUSH
4042: LD_INT 3
4044: PUSH
4045: LD_INT 0
4047: PUSH
4048: LD_INT 0
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: PUSH
4059: LD_INT 16
4061: PUSH
4062: LD_INT 14
4064: PUSH
4065: LD_INT 19
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: LD_INT 0
4073: PUSH
4074: LD_INT 0
4076: PUSH
4077: EMPTY
4078: LIST
4079: LIST
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 17
4087: PUSH
4088: LD_INT 18
4090: PUSH
4091: LD_INT 20
4093: PUSH
4094: LD_INT 5
4096: PUSH
4097: LD_INT 0
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: PUSH
4111: LD_INT 28
4113: PUSH
4114: LD_INT 10
4116: PUSH
4117: LD_INT 5
4119: PUSH
4120: LD_INT 1
4122: PUSH
4123: LD_INT 0
4125: PUSH
4126: LD_INT 0
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: PUSH
4137: LD_INT 28
4139: PUSH
4140: LD_INT 8
4142: PUSH
4143: LD_INT 8
4145: PUSH
4146: LD_INT 1
4148: PUSH
4149: LD_INT 0
4151: PUSH
4152: LD_INT 0
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: PUSH
4163: LD_INT 26
4165: PUSH
4166: LD_INT 19
4168: PUSH
4169: LD_INT 2
4171: PUSH
4172: LD_INT 1
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: LD_INT 0
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: PUSH
4189: LD_INT 26
4191: PUSH
4192: LD_INT 30
4194: PUSH
4195: LD_INT 2
4197: PUSH
4198: LD_INT 1
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: LD_INT 0
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 5
4217: PUSH
4218: LD_INT 59
4220: PUSH
4221: LD_INT 20
4223: PUSH
4224: LD_INT 4
4226: PUSH
4227: LD_INT 0
4229: PUSH
4230: LD_INT 0
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 32
4243: PUSH
4244: LD_INT 60
4246: PUSH
4247: LD_INT 24
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: LD_INT 0
4255: PUSH
4256: LD_INT 0
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 32
4269: PUSH
4270: LD_INT 61
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 5
4278: PUSH
4279: LD_INT 0
4281: PUSH
4282: LD_INT 0
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 32
4295: PUSH
4296: LD_INT 52
4298: PUSH
4299: LD_INT 51
4301: PUSH
4302: LD_INT 5
4304: PUSH
4305: LD_INT 0
4307: PUSH
4308: LD_INT 0
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: LD_INT 56
4324: PUSH
4325: LD_INT 51
4327: PUSH
4328: LD_INT 5
4330: PUSH
4331: LD_INT 0
4333: PUSH
4334: LD_INT 0
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 33
4347: PUSH
4348: LD_INT 62
4350: PUSH
4351: LD_INT 49
4353: PUSH
4354: LD_INT 5
4356: PUSH
4357: LD_INT 0
4359: PUSH
4360: LD_INT 0
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 33
4373: PUSH
4374: LD_INT 41
4376: PUSH
4377: LD_INT 47
4379: PUSH
4380: LD_INT 5
4382: PUSH
4383: LD_INT 0
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 33
4399: PUSH
4400: LD_INT 33
4402: PUSH
4403: LD_INT 52
4405: PUSH
4406: LD_INT 5
4408: PUSH
4409: LD_INT 0
4411: PUSH
4412: LD_INT 0
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: LD_INT 31
4428: PUSH
4429: LD_INT 40
4431: PUSH
4432: LD_INT 0
4434: PUSH
4435: LD_INT 0
4437: PUSH
4438: LD_INT 0
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: PUSH
4449: LD_INT 33
4451: PUSH
4452: LD_INT 65
4454: PUSH
4455: LD_INT 37
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: LD_INT 0
4463: PUSH
4464: LD_INT 0
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 33
4477: PUSH
4478: LD_INT 63
4480: PUSH
4481: LD_INT 29
4483: PUSH
4484: LD_INT 4
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: LD_INT 0
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: PUSH
4501: LD_INT 33
4503: PUSH
4504: LD_INT 54
4506: PUSH
4507: LD_INT 11
4509: PUSH
4510: LD_INT 4
4512: PUSH
4513: LD_INT 0
4515: PUSH
4516: LD_INT 0
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 33
4529: PUSH
4530: LD_INT 56
4532: PUSH
4533: LD_INT 15
4535: PUSH
4536: LD_INT 4
4538: PUSH
4539: LD_INT 0
4541: PUSH
4542: LD_INT 0
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 33
4555: PUSH
4556: LD_INT 51
4558: PUSH
4559: LD_INT 6
4561: PUSH
4562: LD_INT 4
4564: PUSH
4565: LD_INT 0
4567: PUSH
4568: LD_INT 0
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 26
4581: PUSH
4582: LD_INT 39
4584: PUSH
4585: LD_INT 25
4587: PUSH
4588: LD_INT 0
4590: PUSH
4591: LD_INT 0
4593: PUSH
4594: LD_INT 0
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: PUSH
4605: LD_INT 26
4607: PUSH
4608: LD_INT 37
4610: PUSH
4611: LD_INT 21
4613: PUSH
4614: LD_INT 0
4616: PUSH
4617: LD_INT 0
4619: PUSH
4620: LD_INT 0
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: PUSH
4631: LD_INT 32
4633: PUSH
4634: LD_INT 35
4636: PUSH
4637: LD_INT 17
4639: PUSH
4640: LD_INT 4
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 0
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 33
4659: PUSH
4660: LD_INT 35
4662: PUSH
4663: LD_INT 28
4665: PUSH
4666: LD_INT 4
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: LD_INT 0
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 28
4688: PUSH
4689: LD_INT 46
4691: PUSH
4692: LD_INT 5
4694: PUSH
4695: LD_INT 0
4697: PUSH
4698: LD_INT 0
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: PUSH
4709: LD_INT 33
4711: PUSH
4712: LD_INT 31
4714: PUSH
4715: LD_INT 6
4717: PUSH
4718: LD_INT 4
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: LD_INT 0
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 26
4737: PUSH
4738: LD_INT 54
4740: PUSH
4741: LD_INT 38
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 0
4749: PUSH
4750: LD_INT 0
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_INT 33
4763: PUSH
4764: LD_INT 207
4766: PUSH
4767: LD_INT 167
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: LD_INT 0
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 30
4789: PUSH
4790: LD_INT 43
4792: PUSH
4793: LD_INT 2
4795: PUSH
4796: LD_INT 4
4798: PUSH
4799: LD_INT 0
4801: PUSH
4802: LD_INT 0
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: ST_TO_ADDR
// for i in tmp do
4900: LD_ADDR_VAR 0 2
4904: PUSH
4905: LD_VAR 0 4
4909: PUSH
4910: FOR_IN
4911: IFFALSE 5142
// begin uc_side := side ;
4913: LD_ADDR_OWVAR 20
4917: PUSH
4918: LD_VAR 0 5
4922: ST_TO_ADDR
// uc_nation := nation_russian ;
4923: LD_ADDR_OWVAR 21
4927: PUSH
4928: LD_INT 3
4930: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4931: LD_ADDR_OWVAR 42
4935: PUSH
4936: LD_VAR 0 2
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4945: LD_ADDR_OWVAR 43
4949: PUSH
4950: LD_INT 5
4952: PPUSH
4953: LD_INT 6
4955: PPUSH
4956: CALL_OW 12
4960: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4961: LD_ADDR_OWVAR 44
4965: PUSH
4966: LD_VAR 0 2
4970: PUSH
4971: LD_INT 5
4973: ARRAY
4974: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4975: LD_ADDR_OWVAR 45
4979: PUSH
4980: LD_VAR 0 2
4984: PUSH
4985: LD_INT 6
4987: ARRAY
4988: ST_TO_ADDR
// sr := 0 ;
4989: LD_ADDR_VAR 0 6
4993: PUSH
4994: LD_INT 0
4996: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4997: LD_VAR 0 2
5001: PUSH
5002: LD_INT 1
5004: ARRAY
5005: PUSH
5006: LD_INT 29
5008: EQUAL
5009: IFFALSE 5021
// sr := mat_oil else
5011: LD_ADDR_VAR 0 6
5015: PUSH
5016: LD_INT 2
5018: ST_TO_ADDR
5019: GO 5043
// if i [ 1 ] = b_siberite_mine then
5021: LD_VAR 0 2
5025: PUSH
5026: LD_INT 1
5028: ARRAY
5029: PUSH
5030: LD_INT 30
5032: EQUAL
5033: IFFALSE 5043
// sr := mat_siberit ;
5035: LD_ADDR_VAR 0 6
5039: PUSH
5040: LD_INT 3
5042: ST_TO_ADDR
// if sr then
5043: LD_VAR 0 6
5047: IFFALSE 5103
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5049: LD_VAR 0 2
5053: PUSH
5054: LD_INT 2
5056: ARRAY
5057: PPUSH
5058: LD_VAR 0 2
5062: PUSH
5063: LD_INT 3
5065: ARRAY
5066: PPUSH
5067: LD_VAR 0 6
5071: PPUSH
5072: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5076: LD_VAR 0 2
5080: PUSH
5081: LD_INT 2
5083: ARRAY
5084: PPUSH
5085: LD_VAR 0 2
5089: PUSH
5090: LD_INT 3
5092: ARRAY
5093: PPUSH
5094: LD_VAR 0 5
5098: PPUSH
5099: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5103: LD_ADDR_VAR 0 3
5107: PUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_INT 2
5115: ARRAY
5116: PPUSH
5117: LD_VAR 0 2
5121: PUSH
5122: LD_INT 3
5124: ARRAY
5125: PPUSH
5126: LD_VAR 0 2
5130: PUSH
5131: LD_INT 4
5133: ARRAY
5134: PPUSH
5135: CALL_OW 47
5139: ST_TO_ADDR
// end ;
5140: GO 4910
5142: POP
5143: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5144: LD_ADDR_VAR 0 7
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_VAR 0 5
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PUSH
5161: LD_INT 30
5163: PUSH
5164: LD_INT 1
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PPUSH
5175: CALL_OW 69
5179: ST_TO_ADDR
// if not depot then
5180: LD_VAR 0 7
5184: NOT
5185: IFFALSE 5189
// exit ;
5187: GO 5533
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5189: LD_ADDR_VAR 0 8
5193: PUSH
5194: LD_INT 84
5196: PPUSH
5197: LD_INT 128
5199: PPUSH
5200: CALL_OW 428
5204: PPUSH
5205: LD_INT 15
5207: PPUSH
5208: LD_INT 0
5210: PPUSH
5211: LD_INT 6
5213: PUSH
5214: LD_INT 7
5216: PUSH
5217: LD_INT 8
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: LIST
5224: PUSH
5225: LD_OWVAR 67
5229: ARRAY
5230: PPUSH
5231: LD_INT 3000
5233: PUSH
5234: LD_INT 300
5236: PUSH
5237: LD_INT 100
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: LD_INT 12
5247: PUSH
5248: LD_INT 6
5250: PUSH
5251: LD_INT 6
5253: PUSH
5254: LD_INT 4
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL 28343 0 6
5267: ST_TO_ADDR
// if not base then
5268: LD_VAR 0 8
5272: NOT
5273: IFFALSE 5277
// exit ;
5275: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5277: LD_ADDR_EXP 31
5281: PUSH
5282: LD_EXP 31
5286: PPUSH
5287: LD_EXP 7
5291: PPUSH
5292: LD_VAR 0 8
5296: PPUSH
5297: CALL_OW 1
5301: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5302: LD_ADDR_VAR 0 8
5306: PUSH
5307: LD_INT 34
5309: PPUSH
5310: LD_INT 23
5312: PPUSH
5313: CALL_OW 428
5317: PPUSH
5318: LD_INT 11
5320: PPUSH
5321: LD_INT 0
5323: PPUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 7
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PPUSH
5344: LD_INT 20000
5346: PUSH
5347: LD_INT 3000
5349: PUSH
5350: LD_INT 1000
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: PPUSH
5358: LD_INT 12
5360: PUSH
5361: LD_INT 6
5363: PUSH
5364: LD_INT 6
5366: PUSH
5367: LD_INT 4
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL 28343 0 6
5380: ST_TO_ADDR
// if not base then
5381: LD_VAR 0 8
5385: NOT
5386: IFFALSE 5390
// exit ;
5388: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5390: LD_ADDR_EXP 31
5394: PUSH
5395: LD_EXP 31
5399: PPUSH
5400: LD_EXP 8
5404: PPUSH
5405: LD_VAR 0 8
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5415: LD_ADDR_EXP 14
5419: PUSH
5420: LD_INT 22
5422: PUSH
5423: LD_INT 3
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 30
5432: PUSH
5433: LD_INT 0
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: PUSH
5449: LD_INT 1
5451: ARRAY
5452: PPUSH
5453: LD_INT 25
5455: PPUSH
5456: LD_INT 0
5458: PPUSH
5459: LD_INT 6
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: LD_INT 8
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_OWVAR 67
5477: ARRAY
5478: PPUSH
5479: LD_INT 500
5481: PUSH
5482: LD_INT 100
5484: PUSH
5485: LD_INT 10
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: PPUSH
5493: LD_INT 6
5495: PUSH
5496: LD_INT 7
5498: PUSH
5499: LD_INT 8
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: LIST
5506: PUSH
5507: LD_OWVAR 67
5511: ARRAY
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: LD_INT 0
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: PPUSH
5528: CALL 28343 0 6
5532: ST_TO_ADDR
// end ;
5533: LD_VAR 0 1
5537: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5538: LD_INT 0
5540: PPUSH
5541: PPUSH
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5551: LD_INT 0
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: LD_INT 6
5559: PPUSH
5560: LD_INT 0
5562: PPUSH
5563: LD_INT 0
5565: PPUSH
5566: LD_INT 0
5568: PPUSH
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 8
5574: PPUSH
5575: LD_INT 0
5577: PPUSH
5578: CALL 54041 0 9
// side := 8 ;
5582: LD_ADDR_VAR 0 8
5586: PUSH
5587: LD_INT 8
5589: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5590: LD_ADDR_VAR 0 5
5594: PUSH
5595: LD_INT 20
5597: PPUSH
5598: LD_INT 0
5600: PPUSH
5601: CALL_OW 517
5605: ST_TO_ADDR
// if Difficulty > 2 then
5606: LD_OWVAR 67
5610: PUSH
5611: LD_INT 2
5613: GREATER
5614: IFFALSE 5758
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5616: LD_ADDR_VAR 0 6
5620: PUSH
5621: LD_INT 27
5623: PPUSH
5624: LD_INT 0
5626: PPUSH
5627: CALL_OW 517
5631: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5632: LD_ADDR_VAR 0 2
5636: PUSH
5637: DOUBLE
5638: LD_INT 1
5640: DEC
5641: ST_TO_ADDR
5642: LD_VAR 0 6
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PUSH
5651: FOR_TO
5652: IFFALSE 5756
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5654: LD_ADDR_VAR 0 5
5658: PUSH
5659: LD_VAR 0 5
5663: PPUSH
5664: LD_INT 1
5666: PUSH
5667: LD_VAR 0 5
5671: PUSH
5672: LD_INT 1
5674: ARRAY
5675: PUSH
5676: LD_INT 1
5678: PLUS
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PPUSH
5684: LD_VAR 0 6
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: CALL 25021 0 3
5703: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5704: LD_ADDR_VAR 0 5
5708: PUSH
5709: LD_VAR 0 5
5713: PPUSH
5714: LD_INT 2
5716: PUSH
5717: LD_VAR 0 5
5721: PUSH
5722: LD_INT 2
5724: ARRAY
5725: PUSH
5726: LD_INT 1
5728: PLUS
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: PPUSH
5734: LD_VAR 0 6
5738: PUSH
5739: LD_INT 2
5741: ARRAY
5742: PUSH
5743: LD_VAR 0 2
5747: ARRAY
5748: PPUSH
5749: CALL 25021 0 3
5753: ST_TO_ADDR
// end ;
5754: GO 5651
5756: POP
5757: POP
// end ; if tmp then
5758: LD_VAR 0 5
5762: IFFALSE 5890
// begin for i = 1 to tmp [ 1 ] do
5764: LD_ADDR_VAR 0 2
5768: PUSH
5769: DOUBLE
5770: LD_INT 1
5772: DEC
5773: ST_TO_ADDR
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 1
5781: ARRAY
5782: PUSH
5783: FOR_TO
5784: IFFALSE 5888
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5786: LD_VAR 0 5
5790: PUSH
5791: LD_INT 1
5793: ARRAY
5794: PUSH
5795: LD_VAR 0 2
5799: ARRAY
5800: PPUSH
5801: LD_VAR 0 5
5805: PUSH
5806: LD_INT 2
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 2
5814: ARRAY
5815: PPUSH
5816: LD_VAR 0 8
5820: PPUSH
5821: LD_INT 0
5823: PPUSH
5824: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5828: LD_ADDR_EXP 16
5832: PUSH
5833: LD_EXP 16
5837: PPUSH
5838: LD_EXP 16
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PPUSH
5847: LD_VAR 0 5
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PUSH
5856: LD_VAR 0 2
5860: ARRAY
5861: PUSH
5862: LD_VAR 0 5
5866: PUSH
5867: LD_INT 2
5869: ARRAY
5870: PUSH
5871: LD_VAR 0 2
5875: ARRAY
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: PPUSH
5881: CALL_OW 2
5885: ST_TO_ADDR
// end ;
5886: GO 5783
5888: POP
5889: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5890: LD_ADDR_VAR 0 7
5894: PUSH
5895: LD_INT 165
5897: PUSH
5898: LD_INT 156
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 143
5907: PUSH
5908: LD_INT 145
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 152
5917: PUSH
5918: LD_INT 165
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 123
5927: PUSH
5928: LD_INT 153
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 161
5937: PUSH
5938: LD_INT 215
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PUSH
5945: LD_INT 172
5947: PUSH
5948: LD_INT 100
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PUSH
5955: LD_INT 148
5957: PUSH
5958: LD_INT 83
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: PUSH
5965: LD_INT 122
5967: PUSH
5968: LD_INT 68
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 105
5977: PUSH
5978: LD_INT 74
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 113
5987: PUSH
5988: LD_INT 97
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: ST_TO_ADDR
// for i in cameras do
6007: LD_ADDR_VAR 0 2
6011: PUSH
6012: LD_VAR 0 7
6016: PUSH
6017: FOR_IN
6018: IFFALSE 6049
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
6020: LD_VAR 0 2
6024: PUSH
6025: LD_INT 1
6027: ARRAY
6028: PPUSH
6029: LD_VAR 0 2
6033: PUSH
6034: LD_INT 2
6036: ARRAY
6037: PPUSH
6038: LD_VAR 0 8
6042: PPUSH
6043: CALL_OW 244
6047: GO 6017
6049: POP
6050: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6051: LD_ADDR_VAR 0 5
6055: PUSH
6056: LD_INT 1
6058: PUSH
6059: LD_INT 144
6061: PUSH
6062: LD_INT 110
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: LD_INT 0
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 3
6084: PUSH
6085: LD_INT 151
6087: PUSH
6088: LD_INT 118
6090: PUSH
6091: LD_INT 0
6093: PUSH
6094: LD_INT 0
6096: PUSH
6097: LD_INT 0
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: LD_INT 158
6113: PUSH
6114: LD_INT 110
6116: PUSH
6117: LD_INT 4
6119: PUSH
6120: LD_INT 10
6122: PUSH
6123: LD_INT 15
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: PUSH
6134: LD_INT 23
6136: PUSH
6137: LD_INT 154
6139: PUSH
6140: LD_INT 121
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 155
6165: PUSH
6166: LD_INT 118
6168: PUSH
6169: LD_INT 4
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: LD_INT 0
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_INT 21
6188: PUSH
6189: LD_INT 151
6191: PUSH
6192: LD_INT 122
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: LD_INT 0
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 18
6214: PUSH
6215: LD_INT 148
6217: PUSH
6218: LD_INT 118
6220: PUSH
6221: LD_INT 1
6223: PUSH
6224: LD_INT 0
6226: PUSH
6227: LD_INT 0
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 17
6240: PUSH
6241: LD_INT 147
6243: PUSH
6244: LD_INT 114
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 0
6252: PUSH
6253: LD_INT 0
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 29
6266: PUSH
6267: LD_INT 163
6269: PUSH
6270: LD_INT 120
6272: PUSH
6273: LD_INT 5
6275: PUSH
6276: LD_INT 0
6278: PUSH
6279: LD_INT 0
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 27
6292: PUSH
6293: LD_INT 137
6295: PUSH
6296: LD_INT 116
6298: PUSH
6299: LD_INT 3
6301: PUSH
6302: LD_INT 0
6304: PUSH
6305: LD_INT 0
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 27
6318: PUSH
6319: LD_INT 133
6321: PUSH
6322: LD_INT 111
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: LD_INT 0
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 27
6344: PUSH
6345: LD_INT 132
6347: PUSH
6348: LD_INT 106
6350: PUSH
6351: LD_INT 4
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 26
6370: PUSH
6371: LD_INT 137
6373: PUSH
6374: LD_INT 111
6376: PUSH
6377: LD_INT 0
6379: PUSH
6380: LD_INT 0
6382: PUSH
6383: LD_INT 0
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 141
6399: PUSH
6400: LD_INT 117
6402: PUSH
6403: LD_INT 1
6405: PUSH
6406: LD_INT 13
6408: PUSH
6409: LD_INT 11
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 30
6422: PUSH
6423: LD_INT 140
6425: PUSH
6426: LD_INT 128
6428: PUSH
6429: LD_INT 1
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: LD_INT 0
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 5
6448: PUSH
6449: LD_INT 146
6451: PUSH
6452: LD_INT 96
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 32
6474: PUSH
6475: LD_INT 150
6477: PUSH
6478: LD_INT 98
6480: PUSH
6481: LD_INT 3
6483: PUSH
6484: LD_INT 0
6486: PUSH
6487: LD_INT 0
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 32
6500: PUSH
6501: LD_INT 142
6503: PUSH
6504: LD_INT 95
6506: PUSH
6507: LD_INT 3
6509: PUSH
6510: LD_INT 0
6512: PUSH
6513: LD_INT 0
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 32
6526: PUSH
6527: LD_INT 159
6529: PUSH
6530: LD_INT 104
6532: PUSH
6533: LD_INT 3
6535: PUSH
6536: LD_INT 0
6538: PUSH
6539: LD_INT 0
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: LD_INT 32
6552: PUSH
6553: LD_INT 133
6555: PUSH
6556: LD_INT 95
6558: PUSH
6559: LD_INT 3
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: LD_INT 0
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 32
6578: PUSH
6579: LD_INT 131
6581: PUSH
6582: LD_INT 102
6584: PUSH
6585: LD_INT 2
6587: PUSH
6588: LD_INT 0
6590: PUSH
6591: LD_INT 0
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 32
6604: PUSH
6605: LD_INT 164
6607: PUSH
6608: LD_INT 144
6610: PUSH
6611: LD_INT 0
6613: PUSH
6614: LD_INT 0
6616: PUSH
6617: LD_INT 0
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: LD_INT 146
6633: PUSH
6634: LD_INT 139
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: LD_INT 0
6642: PUSH
6643: LD_INT 0
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 26
6656: PUSH
6657: LD_INT 143
6659: PUSH
6660: LD_INT 122
6662: PUSH
6663: LD_INT 4
6665: PUSH
6666: LD_INT 0
6668: PUSH
6669: LD_INT 0
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 164
6685: PUSH
6686: LD_INT 116
6688: PUSH
6689: LD_INT 2
6691: PUSH
6692: LD_INT 0
6694: PUSH
6695: LD_INT 0
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: ST_TO_ADDR
// for i in tmp do
6733: LD_ADDR_VAR 0 2
6737: PUSH
6738: LD_VAR 0 5
6742: PUSH
6743: FOR_IN
6744: IFFALSE 6975
// begin uc_side := side ;
6746: LD_ADDR_OWVAR 20
6750: PUSH
6751: LD_VAR 0 8
6755: ST_TO_ADDR
// uc_nation := nation_arabian ;
6756: LD_ADDR_OWVAR 21
6760: PUSH
6761: LD_INT 2
6763: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6764: LD_ADDR_OWVAR 42
6768: PUSH
6769: LD_VAR 0 2
6773: PUSH
6774: LD_INT 1
6776: ARRAY
6777: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6778: LD_ADDR_OWVAR 43
6782: PUSH
6783: LD_INT 5
6785: PPUSH
6786: LD_INT 6
6788: PPUSH
6789: CALL_OW 12
6793: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6794: LD_ADDR_OWVAR 44
6798: PUSH
6799: LD_VAR 0 2
6803: PUSH
6804: LD_INT 5
6806: ARRAY
6807: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6808: LD_ADDR_OWVAR 45
6812: PUSH
6813: LD_VAR 0 2
6817: PUSH
6818: LD_INT 6
6820: ARRAY
6821: ST_TO_ADDR
// sr := 0 ;
6822: LD_ADDR_VAR 0 9
6826: PUSH
6827: LD_INT 0
6829: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6830: LD_VAR 0 2
6834: PUSH
6835: LD_INT 1
6837: ARRAY
6838: PUSH
6839: LD_INT 29
6841: EQUAL
6842: IFFALSE 6854
// sr := mat_oil else
6844: LD_ADDR_VAR 0 9
6848: PUSH
6849: LD_INT 2
6851: ST_TO_ADDR
6852: GO 6876
// if i [ 1 ] = b_siberite_mine then
6854: LD_VAR 0 2
6858: PUSH
6859: LD_INT 1
6861: ARRAY
6862: PUSH
6863: LD_INT 30
6865: EQUAL
6866: IFFALSE 6876
// sr := mat_siberit ;
6868: LD_ADDR_VAR 0 9
6872: PUSH
6873: LD_INT 3
6875: ST_TO_ADDR
// if sr then
6876: LD_VAR 0 9
6880: IFFALSE 6936
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6882: LD_VAR 0 2
6886: PUSH
6887: LD_INT 2
6889: ARRAY
6890: PPUSH
6891: LD_VAR 0 2
6895: PUSH
6896: LD_INT 3
6898: ARRAY
6899: PPUSH
6900: LD_VAR 0 9
6904: PPUSH
6905: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6909: LD_VAR 0 2
6913: PUSH
6914: LD_INT 2
6916: ARRAY
6917: PPUSH
6918: LD_VAR 0 2
6922: PUSH
6923: LD_INT 3
6925: ARRAY
6926: PPUSH
6927: LD_VAR 0 8
6931: PPUSH
6932: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6936: LD_ADDR_VAR 0 3
6940: PUSH
6941: LD_VAR 0 2
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PPUSH
6950: LD_VAR 0 2
6954: PUSH
6955: LD_INT 3
6957: ARRAY
6958: PPUSH
6959: LD_VAR 0 2
6963: PUSH
6964: LD_INT 4
6966: ARRAY
6967: PPUSH
6968: CALL_OW 47
6972: ST_TO_ADDR
// end ;
6973: GO 6743
6975: POP
6976: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6977: LD_ADDR_VAR 0 10
6981: PUSH
6982: LD_INT 22
6984: PUSH
6985: LD_VAR 0 8
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PPUSH
7008: CALL_OW 69
7012: ST_TO_ADDR
// if not depot then
7013: LD_VAR 0 10
7017: NOT
7018: IFFALSE 7022
// exit ;
7020: GO 7268
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
7022: LD_ADDR_VAR 0 11
7026: PUSH
7027: LD_VAR 0 10
7031: PUSH
7032: LD_INT 1
7034: ARRAY
7035: PPUSH
7036: LD_INT 6
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: LD_INT 7
7044: PUSH
7045: LD_INT 8
7047: PUSH
7048: LD_INT 10
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: LIST
7055: PUSH
7056: LD_OWVAR 67
7060: ARRAY
7061: PPUSH
7062: LD_INT 3000
7064: PUSH
7065: LD_INT 300
7067: PUSH
7068: LD_INT 100
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: PPUSH
7076: LD_INT 14
7078: PUSH
7079: LD_INT 6
7081: PUSH
7082: LD_INT 6
7084: PUSH
7085: LD_INT 5
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL 28343 0 6
7098: ST_TO_ADDR
// if not base then
7099: LD_VAR 0 11
7103: NOT
7104: IFFALSE 7108
// exit ;
7106: GO 7268
// if Difficulty > 1 then
7108: LD_OWVAR 67
7112: PUSH
7113: LD_INT 1
7115: GREATER
7116: IFFALSE 7189
// begin InitHc ;
7118: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7122: LD_INT 1
7124: PPUSH
7125: LD_INT 5
7127: PPUSH
7128: LD_INT 5
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: PUSH
7143: LD_INT 1
7145: MINUS
7146: ARRAY
7147: PPUSH
7148: CALL_OW 380
// for i = 1 to Difficulty do
7152: LD_ADDR_VAR 0 2
7156: PUSH
7157: DOUBLE
7158: LD_INT 1
7160: DEC
7161: ST_TO_ADDR
7162: LD_OWVAR 67
7166: PUSH
7167: FOR_TO
7168: IFFALSE 7187
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7170: CALL_OW 44
7174: PPUSH
7175: LD_INT 24
7177: PPUSH
7178: LD_INT 0
7180: PPUSH
7181: CALL_OW 49
7185: GO 7167
7187: POP
7188: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7189: LD_ADDR_EXP 31
7193: PUSH
7194: LD_EXP 31
7198: PPUSH
7199: LD_EXP 6
7203: PPUSH
7204: LD_VAR 0 11
7208: PPUSH
7209: CALL_OW 1
7213: ST_TO_ADDR
// hc_gallery := ru ;
7214: LD_ADDR_OWVAR 33
7218: PUSH
7219: LD_STRING ru
7221: ST_TO_ADDR
// hc_face_number := 44 ;
7222: LD_ADDR_OWVAR 34
7226: PUSH
7227: LD_INT 44
7229: ST_TO_ADDR
// hc_name := Robert Farmer ;
7230: LD_ADDR_OWVAR 26
7234: PUSH
7235: LD_STRING Robert Farmer
7237: ST_TO_ADDR
// hc_sex := sex_male ;
7238: LD_ADDR_OWVAR 27
7242: PUSH
7243: LD_INT 1
7245: ST_TO_ADDR
// hc_class := 1 ;
7246: LD_ADDR_OWVAR 28
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// Farmer := CreateHuman ;
7254: LD_ADDR_EXP 13
7258: PUSH
7259: CALL_OW 44
7263: ST_TO_ADDR
// InitHc ;
7264: CALL_OW 19
// end ;
7268: LD_VAR 0 1
7272: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7273: LD_INT 0
7275: PPUSH
7276: PPUSH
7277: PPUSH
7278: PPUSH
// tmp := [ ] ;
7279: LD_ADDR_VAR 0 3
7283: PUSH
7284: EMPTY
7285: ST_TO_ADDR
// for i := 1 to 3 do
7286: LD_ADDR_VAR 0 2
7290: PUSH
7291: DOUBLE
7292: LD_INT 1
7294: DEC
7295: ST_TO_ADDR
7296: LD_INT 3
7298: PUSH
7299: FOR_TO
7300: IFFALSE 7412
// begin uc_side := 3 ;
7302: LD_ADDR_OWVAR 20
7306: PUSH
7307: LD_INT 3
7309: ST_TO_ADDR
// uc_nation := 3 ;
7310: LD_ADDR_OWVAR 21
7314: PUSH
7315: LD_INT 3
7317: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7318: LD_ADDR_OWVAR 37
7322: PUSH
7323: LD_INT 22
7325: ST_TO_ADDR
// vc_engine := engine_siberite ;
7326: LD_ADDR_OWVAR 39
7330: PUSH
7331: LD_INT 3
7333: ST_TO_ADDR
// vc_control := control_computer ;
7334: LD_ADDR_OWVAR 38
7338: PUSH
7339: LD_INT 3
7341: ST_TO_ADDR
// vc_weapon := ru_crane ;
7342: LD_ADDR_OWVAR 40
7346: PUSH
7347: LD_INT 52
7349: ST_TO_ADDR
// veh := CreateVehicle ;
7350: LD_ADDR_VAR 0 4
7354: PUSH
7355: CALL_OW 45
7359: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7360: LD_VAR 0 4
7364: PPUSH
7365: LD_INT 73
7367: PPUSH
7368: LD_INT 122
7370: PPUSH
7371: LD_INT 3
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7381: LD_ADDR_VAR 0 3
7385: PUSH
7386: LD_VAR 0 3
7390: PPUSH
7391: LD_VAR 0 3
7395: PUSH
7396: LD_INT 1
7398: PLUS
7399: PPUSH
7400: LD_VAR 0 4
7404: PPUSH
7405: CALL_OW 1
7409: ST_TO_ADDR
// end ;
7410: GO 7299
7412: POP
7413: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7414: LD_ADDR_EXP 50
7418: PUSH
7419: LD_EXP 50
7423: PPUSH
7424: LD_EXP 7
7428: PPUSH
7429: LD_VAR 0 3
7433: PPUSH
7434: CALL_OW 1
7438: ST_TO_ADDR
// tmp := [ ] ;
7439: LD_ADDR_VAR 0 3
7443: PUSH
7444: EMPTY
7445: ST_TO_ADDR
// for i := 1 to 3 do
7446: LD_ADDR_VAR 0 2
7450: PUSH
7451: DOUBLE
7452: LD_INT 1
7454: DEC
7455: ST_TO_ADDR
7456: LD_INT 3
7458: PUSH
7459: FOR_TO
7460: IFFALSE 7572
// begin uc_side := 3 ;
7462: LD_ADDR_OWVAR 20
7466: PUSH
7467: LD_INT 3
7469: ST_TO_ADDR
// uc_nation := 3 ;
7470: LD_ADDR_OWVAR 21
7474: PUSH
7475: LD_INT 3
7477: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7478: LD_ADDR_OWVAR 37
7482: PUSH
7483: LD_INT 22
7485: ST_TO_ADDR
// vc_engine := engine_siberite ;
7486: LD_ADDR_OWVAR 39
7490: PUSH
7491: LD_INT 3
7493: ST_TO_ADDR
// vc_control := control_computer ;
7494: LD_ADDR_OWVAR 38
7498: PUSH
7499: LD_INT 3
7501: ST_TO_ADDR
// vc_weapon := ru_crane ;
7502: LD_ADDR_OWVAR 40
7506: PUSH
7507: LD_INT 52
7509: ST_TO_ADDR
// veh := CreateVehicle ;
7510: LD_ADDR_VAR 0 4
7514: PUSH
7515: CALL_OW 45
7519: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7520: LD_VAR 0 4
7524: PPUSH
7525: LD_INT 22
7527: PPUSH
7528: LD_INT 28
7530: PPUSH
7531: LD_INT 3
7533: PPUSH
7534: LD_INT 0
7536: PPUSH
7537: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7541: LD_ADDR_VAR 0 3
7545: PUSH
7546: LD_VAR 0 3
7550: PPUSH
7551: LD_VAR 0 3
7555: PUSH
7556: LD_INT 1
7558: PLUS
7559: PPUSH
7560: LD_VAR 0 4
7564: PPUSH
7565: CALL_OW 1
7569: ST_TO_ADDR
// end ;
7570: GO 7459
7572: POP
7573: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7574: LD_ADDR_EXP 50
7578: PUSH
7579: LD_EXP 50
7583: PPUSH
7584: LD_EXP 8
7588: PPUSH
7589: LD_VAR 0 3
7593: PPUSH
7594: CALL_OW 1
7598: ST_TO_ADDR
// end ;
7599: LD_VAR 0 1
7603: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7604: LD_INT 0
7606: PPUSH
7607: PPUSH
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
7613: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7614: LD_INT 0
7616: PPUSH
7617: LD_INT 0
7619: PPUSH
7620: LD_INT 4
7622: PPUSH
7623: LD_INT 0
7625: PPUSH
7626: LD_INT 0
7628: PPUSH
7629: LD_INT 0
7631: PPUSH
7632: LD_INT 0
7634: PPUSH
7635: LD_INT 10
7637: PPUSH
7638: LD_INT 0
7640: PPUSH
7641: CALL 54041 0 9
// side := 4 ;
7645: LD_ADDR_VAR 0 5
7649: PUSH
7650: LD_INT 4
7652: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7653: LD_ADDR_VAR 0 4
7657: PUSH
7658: LD_INT 1
7660: PUSH
7661: LD_INT 144
7663: PUSH
7664: LD_INT 18
7666: PUSH
7667: LD_INT 4
7669: PUSH
7670: LD_INT 0
7672: PUSH
7673: LD_INT 0
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: PUSH
7684: LD_INT 3
7686: PUSH
7687: LD_INT 137
7689: PUSH
7690: LD_INT 8
7692: PUSH
7693: LD_INT 4
7695: PUSH
7696: LD_INT 0
7698: PUSH
7699: LD_INT 0
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_INT 141
7715: PUSH
7716: LD_INT 8
7718: PUSH
7719: LD_INT 4
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: LD_INT 0
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 25
7738: PUSH
7739: LD_INT 137
7741: PUSH
7742: LD_INT 5
7744: PUSH
7745: LD_INT 3
7747: PUSH
7748: LD_INT 0
7750: PUSH
7751: LD_INT 0
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 18
7764: PUSH
7765: LD_INT 137
7767: PUSH
7768: LD_INT 12
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: LD_INT 0
7776: PUSH
7777: LD_INT 0
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 17
7790: PUSH
7791: LD_INT 133
7793: PUSH
7794: LD_INT 4
7796: PUSH
7797: LD_INT 2
7799: PUSH
7800: LD_INT 0
7802: PUSH
7803: LD_INT 0
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 16
7816: PUSH
7817: LD_INT 140
7819: PUSH
7820: LD_INT 11
7822: PUSH
7823: LD_INT 5
7825: PUSH
7826: LD_INT 0
7828: PUSH
7829: LD_INT 0
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: PUSH
7840: LD_INT 8
7842: PUSH
7843: LD_INT 149
7845: PUSH
7846: LD_INT 26
7848: PUSH
7849: LD_INT 4
7851: PUSH
7852: LD_INT 10
7854: PUSH
7855: LD_INT 15
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 8
7868: PUSH
7869: LD_INT 142
7871: PUSH
7872: LD_INT 26
7874: PUSH
7875: LD_INT 1
7877: PUSH
7878: LD_INT 11
7880: PUSH
7881: LD_INT 12
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 27
7894: PUSH
7895: LD_INT 153
7897: PUSH
7898: LD_INT 32
7900: PUSH
7901: LD_INT 5
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: LD_INT 0
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 27
7920: PUSH
7921: LD_INT 145
7923: PUSH
7924: LD_INT 32
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 0
7932: PUSH
7933: LD_INT 0
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: LIST
7941: LIST
7942: LIST
7943: PUSH
7944: LD_INT 27
7946: PUSH
7947: LD_INT 138
7949: PUSH
7950: LD_INT 2
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: LD_INT 0
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: LIST
7968: LIST
7969: PUSH
7970: LD_INT 27
7972: PUSH
7973: LD_INT 144
7975: PUSH
7976: LD_INT 13
7978: PUSH
7979: LD_INT 0
7981: PUSH
7982: LD_INT 0
7984: PUSH
7985: LD_INT 0
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 26
7998: PUSH
7999: LD_INT 124
8001: PUSH
8002: LD_INT 2
8004: PUSH
8005: LD_INT 4
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: LD_INT 0
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 26
8024: PUSH
8025: LD_INT 121
8027: PUSH
8028: LD_INT 2
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: LD_INT 0
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 26
8050: PUSH
8051: LD_INT 118
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: LD_INT 1
8059: PUSH
8060: LD_INT 0
8062: PUSH
8063: LD_INT 0
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 29
8076: PUSH
8077: LD_INT 159
8079: PUSH
8080: LD_INT 47
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 0
8088: PUSH
8089: LD_INT 0
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: PUSH
8100: LD_INT 32
8102: PUSH
8103: LD_INT 146
8105: PUSH
8106: LD_INT 41
8108: PUSH
8109: LD_INT 0
8111: PUSH
8112: LD_INT 0
8114: PUSH
8115: LD_INT 0
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 33
8128: PUSH
8129: LD_INT 136
8131: PUSH
8132: LD_INT 37
8134: PUSH
8135: LD_INT 0
8137: PUSH
8138: LD_INT 0
8140: PUSH
8141: LD_INT 0
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 33
8154: PUSH
8155: LD_INT 132
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 0
8163: PUSH
8164: LD_INT 0
8166: PUSH
8167: LD_INT 0
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: PUSH
8178: LD_INT 36
8180: PUSH
8181: LD_INT 124
8183: PUSH
8184: LD_INT 7
8186: PUSH
8187: LD_INT 1
8189: PUSH
8190: LD_INT 0
8192: PUSH
8193: LD_INT 0
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 5
8206: PUSH
8207: LD_INT 124
8209: PUSH
8210: LD_INT 19
8212: PUSH
8213: LD_INT 0
8215: PUSH
8216: LD_INT 0
8218: PUSH
8219: LD_INT 0
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: PUSH
8230: LD_INT 32
8232: PUSH
8233: LD_INT 127
8235: PUSH
8236: LD_INT 23
8238: PUSH
8239: LD_INT 0
8241: PUSH
8242: LD_INT 0
8244: PUSH
8245: LD_INT 0
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
// for i in tmp do
8281: LD_ADDR_VAR 0 2
8285: PUSH
8286: LD_VAR 0 4
8290: PUSH
8291: FOR_IN
8292: IFFALSE 8523
// begin uc_side := side ;
8294: LD_ADDR_OWVAR 20
8298: PUSH
8299: LD_VAR 0 5
8303: ST_TO_ADDR
// uc_nation := nation_american ;
8304: LD_ADDR_OWVAR 21
8308: PUSH
8309: LD_INT 1
8311: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8312: LD_ADDR_OWVAR 42
8316: PUSH
8317: LD_VAR 0 2
8321: PUSH
8322: LD_INT 1
8324: ARRAY
8325: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8326: LD_ADDR_OWVAR 43
8330: PUSH
8331: LD_INT 5
8333: PPUSH
8334: LD_INT 6
8336: PPUSH
8337: CALL_OW 12
8341: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8342: LD_ADDR_OWVAR 44
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 5
8354: ARRAY
8355: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8356: LD_ADDR_OWVAR 45
8360: PUSH
8361: LD_VAR 0 2
8365: PUSH
8366: LD_INT 6
8368: ARRAY
8369: ST_TO_ADDR
// sr := 0 ;
8370: LD_ADDR_VAR 0 6
8374: PUSH
8375: LD_INT 0
8377: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8378: LD_VAR 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PUSH
8387: LD_INT 29
8389: EQUAL
8390: IFFALSE 8402
// sr := mat_oil else
8392: LD_ADDR_VAR 0 6
8396: PUSH
8397: LD_INT 2
8399: ST_TO_ADDR
8400: GO 8424
// if i [ 1 ] = b_siberite_mine then
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PUSH
8411: LD_INT 30
8413: EQUAL
8414: IFFALSE 8424
// sr := mat_siberit ;
8416: LD_ADDR_VAR 0 6
8420: PUSH
8421: LD_INT 3
8423: ST_TO_ADDR
// if sr then
8424: LD_VAR 0 6
8428: IFFALSE 8484
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8430: LD_VAR 0 2
8434: PUSH
8435: LD_INT 2
8437: ARRAY
8438: PPUSH
8439: LD_VAR 0 2
8443: PUSH
8444: LD_INT 3
8446: ARRAY
8447: PPUSH
8448: LD_VAR 0 6
8452: PPUSH
8453: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8457: LD_VAR 0 2
8461: PUSH
8462: LD_INT 2
8464: ARRAY
8465: PPUSH
8466: LD_VAR 0 2
8470: PUSH
8471: LD_INT 3
8473: ARRAY
8474: PPUSH
8475: LD_VAR 0 5
8479: PPUSH
8480: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8484: LD_ADDR_VAR 0 3
8488: PUSH
8489: LD_VAR 0 2
8493: PUSH
8494: LD_INT 2
8496: ARRAY
8497: PPUSH
8498: LD_VAR 0 2
8502: PUSH
8503: LD_INT 3
8505: ARRAY
8506: PPUSH
8507: LD_VAR 0 2
8511: PUSH
8512: LD_INT 4
8514: ARRAY
8515: PPUSH
8516: CALL_OW 47
8520: ST_TO_ADDR
// end ;
8521: GO 8291
8523: POP
8524: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8525: LD_ADDR_VAR 0 8
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 5
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 30
8544: PUSH
8545: LD_INT 1
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL_OW 69
8560: ST_TO_ADDR
// if not depot then
8561: LD_VAR 0 8
8565: NOT
8566: IFFALSE 8570
// exit ;
8568: GO 8842
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8570: LD_ADDR_VAR 0 7
8574: PUSH
8575: LD_VAR 0 8
8579: PUSH
8580: LD_INT 1
8582: ARRAY
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_STRING theta3
8589: PPUSH
8590: LD_INT 8
8592: PUSH
8593: LD_INT 7
8595: PUSH
8596: LD_INT 6
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: LD_OWVAR 67
8608: ARRAY
8609: PPUSH
8610: LD_INT 2500
8612: PUSH
8613: LD_INT 2000
8615: PUSH
8616: LD_INT 1750
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: LIST
8623: PUSH
8624: LD_OWVAR 67
8628: ARRAY
8629: PUSH
8630: LD_INT 300
8632: PUSH
8633: LD_INT 250
8635: PUSH
8636: LD_INT 200
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: LD_INT 80
8652: PUSH
8653: LD_INT 60
8655: PUSH
8656: LD_INT 50
8658: PUSH
8659: EMPTY
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_OWVAR 67
8668: ARRAY
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PPUSH
8675: LD_INT 7
8677: PUSH
8678: LD_INT 6
8680: PUSH
8681: LD_INT 5
8683: PUSH
8684: LD_INT 5
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: CALL 28343 0 6
8697: ST_TO_ADDR
// if not base then
8698: LD_VAR 0 7
8702: NOT
8703: IFFALSE 8707
// exit ;
8705: GO 8842
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8707: LD_ADDR_EXP 31
8711: PUSH
8712: LD_EXP 31
8716: PPUSH
8717: LD_EXP 5
8721: PPUSH
8722: LD_VAR 0 7
8726: PPUSH
8727: CALL_OW 1
8731: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8732: LD_INT 1
8734: PPUSH
8735: LD_INT 1
8737: PPUSH
8738: LD_INT 7
8740: PPUSH
8741: CALL_OW 380
// allyCommander := CreateHuman ;
8745: LD_ADDR_EXP 11
8749: PUSH
8750: CALL_OW 44
8754: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8755: LD_EXP 11
8759: PPUSH
8760: LD_INT 139
8762: PPUSH
8763: LD_INT 15
8765: PPUSH
8766: LD_INT 0
8768: PPUSH
8769: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8773: LD_EXP 11
8777: PPUSH
8778: LD_INT 137
8780: PPUSH
8781: LD_INT 15
8783: PPUSH
8784: CALL_OW 118
// hc_gallery := us ;
8788: LD_ADDR_OWVAR 33
8792: PUSH
8793: LD_STRING us
8795: ST_TO_ADDR
// hc_face_number := 7 ;
8796: LD_ADDR_OWVAR 34
8800: PUSH
8801: LD_INT 7
8803: ST_TO_ADDR
// hc_name := Arthur Powell ;
8804: LD_ADDR_OWVAR 26
8808: PUSH
8809: LD_STRING Arthur Powell
8811: ST_TO_ADDR
// hc_sex := sex_male ;
8812: LD_ADDR_OWVAR 27
8816: PUSH
8817: LD_INT 1
8819: ST_TO_ADDR
// hc_class := 1 ;
8820: LD_ADDR_OWVAR 28
8824: PUSH
8825: LD_INT 1
8827: ST_TO_ADDR
// Powell := CreateHuman ;
8828: LD_ADDR_EXP 12
8832: PUSH
8833: CALL_OW 44
8837: ST_TO_ADDR
// InitHc ;
8838: CALL_OW 19
// end ;
8842: LD_VAR 0 1
8846: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8847: LD_INT 0
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
// side := 1 ;
8858: LD_ADDR_VAR 0 3
8862: PUSH
8863: LD_INT 1
8865: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8866: LD_ADDR_VAR 0 1
8870: PUSH
8871: EMPTY
8872: PUSH
8873: EMPTY
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: ST_TO_ADDR
// uc_side := side ;
8879: LD_ADDR_OWVAR 20
8883: PUSH
8884: LD_VAR 0 3
8888: ST_TO_ADDR
// uc_nation := nation_american ;
8889: LD_ADDR_OWVAR 21
8893: PUSH
8894: LD_INT 1
8896: ST_TO_ADDR
// InitHc ;
8897: CALL_OW 19
// InitVc ;
8901: CALL_OW 20
// hc_importance := 0 ;
8905: LD_ADDR_OWVAR 32
8909: PUSH
8910: LD_INT 0
8912: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8913: LD_ADDR_VAR 0 7
8917: PUSH
8918: LD_INT 2
8920: PUSH
8921: LD_INT 3
8923: PUSH
8924: LD_INT 3
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// if commander = 2 then
8932: LD_EXP 25
8936: PUSH
8937: LD_INT 2
8939: EQUAL
8940: IFFALSE 8961
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8942: LD_ADDR_VAR 0 7
8946: PUSH
8947: LD_INT 3
8949: PUSH
8950: LD_INT 4
8952: PUSH
8953: LD_INT 4
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: LIST
8960: ST_TO_ADDR
// if commander = 3 then
8961: LD_EXP 25
8965: PUSH
8966: LD_INT 3
8968: EQUAL
8969: IFFALSE 8990
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8971: LD_ADDR_VAR 0 7
8975: PUSH
8976: LD_INT 2
8978: PUSH
8979: LD_INT 5
8981: PUSH
8982: LD_INT 5
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8990: LD_ADDR_VAR 0 8
8994: PUSH
8995: LD_INT 2
8997: PUSH
8998: LD_INT 2
9000: PUSH
9001: LD_INT 1
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: LIST
9008: ST_TO_ADDR
// if commander = 2 then
9009: LD_EXP 25
9013: PUSH
9014: LD_INT 2
9016: EQUAL
9017: IFFALSE 9038
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
9019: LD_ADDR_VAR 0 8
9023: PUSH
9024: LD_INT 1
9026: PUSH
9027: LD_INT 1
9029: PUSH
9030: LD_INT 3
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: ST_TO_ADDR
// if commander = 3 then
9038: LD_EXP 25
9042: PUSH
9043: LD_INT 3
9045: EQUAL
9046: IFFALSE 9067
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9048: LD_ADDR_VAR 0 8
9052: PUSH
9053: LD_INT 3
9055: PUSH
9056: LD_INT 3
9058: PUSH
9059: LD_INT 1
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: LIST
9066: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9067: LD_ADDR_VAR 0 9
9071: PUSH
9072: LD_INT 5
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: LD_INT 4
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// if commander = 2 then
9086: LD_EXP 25
9090: PUSH
9091: LD_INT 2
9093: EQUAL
9094: IFFALSE 9115
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9096: LD_ADDR_VAR 0 9
9100: PUSH
9101: LD_INT 7
9103: PUSH
9104: LD_INT 5
9106: PUSH
9107: LD_INT 6
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: ST_TO_ADDR
// if commander = 3 then
9115: LD_EXP 25
9119: PUSH
9120: LD_INT 3
9122: EQUAL
9123: IFFALSE 9144
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9125: LD_ADDR_VAR 0 9
9129: PUSH
9130: LD_INT 9
9132: PUSH
9133: LD_INT 10
9135: PUSH
9136: LD_INT 7
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: LIST
9143: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9144: LD_ADDR_VAR 0 5
9148: PUSH
9149: LD_INT 5
9151: PUSH
9152: LD_INT 5
9154: PUSH
9155: LD_INT 4
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_OWVAR 67
9167: ARRAY
9168: ST_TO_ADDR
// if commander = 2 then
9169: LD_EXP 25
9173: PUSH
9174: LD_INT 2
9176: EQUAL
9177: IFFALSE 9193
// tanks := tanks + 3 ;
9179: LD_ADDR_VAR 0 5
9183: PUSH
9184: LD_VAR 0 5
9188: PUSH
9189: LD_INT 3
9191: PLUS
9192: ST_TO_ADDR
// for i = 1 to tanks do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_VAR 0 5
9207: PUSH
9208: FOR_TO
9209: IFFALSE 9319
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9211: LD_VAR 0 7
9215: PUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 3
9223: MOD
9224: PUSH
9225: LD_INT 1
9227: PLUS
9228: ARRAY
9229: PPUSH
9230: LD_VAR 0 8
9234: PUSH
9235: LD_INT 1
9237: PPUSH
9238: LD_INT 3
9240: PPUSH
9241: CALL_OW 12
9245: ARRAY
9246: PPUSH
9247: LD_INT 1
9249: PPUSH
9250: LD_VAR 0 9
9254: PUSH
9255: LD_VAR 0 2
9259: PUSH
9260: LD_INT 3
9262: MOD
9263: PUSH
9264: LD_INT 1
9266: PLUS
9267: ARRAY
9268: PPUSH
9269: LD_INT 60
9271: PPUSH
9272: LD_INT 70
9274: PPUSH
9275: CALL_OW 12
9279: PPUSH
9280: CALL 24899 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9284: LD_ADDR_VAR 0 1
9288: PUSH
9289: LD_VAR 0 1
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: LD_VAR 0 1
9301: PUSH
9302: LD_INT 1
9304: ARRAY
9305: PUSH
9306: CALL_OW 45
9310: ADD
9311: PPUSH
9312: CALL_OW 1
9316: ST_TO_ADDR
// end ;
9317: GO 9208
9319: POP
9320: POP
// cl := 1 ;
9321: LD_ADDR_VAR 0 6
9325: PUSH
9326: LD_INT 1
9328: ST_TO_ADDR
// for i = 1 to 10 do
9329: LD_ADDR_VAR 0 2
9333: PUSH
9334: DOUBLE
9335: LD_INT 1
9337: DEC
9338: ST_TO_ADDR
9339: LD_INT 10
9341: PUSH
9342: FOR_TO
9343: IFFALSE 9458
// begin if i mod 4 = 0 then
9345: LD_VAR 0 2
9349: PUSH
9350: LD_INT 4
9352: MOD
9353: PUSH
9354: LD_INT 0
9356: EQUAL
9357: IFFALSE 9373
// cl := cl + 1 ;
9359: LD_ADDR_VAR 0 6
9363: PUSH
9364: LD_VAR 0 6
9368: PUSH
9369: LD_INT 1
9371: PLUS
9372: ST_TO_ADDR
// if cl = 2 then
9373: LD_VAR 0 6
9377: PUSH
9378: LD_INT 2
9380: EQUAL
9381: IFFALSE 9391
// cl := 3 ;
9383: LD_ADDR_VAR 0 6
9387: PUSH
9388: LD_INT 3
9390: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9391: LD_INT 0
9393: PPUSH
9394: LD_VAR 0 6
9398: PPUSH
9399: LD_INT 6
9401: PUSH
9402: LD_INT 6
9404: PUSH
9405: LD_INT 5
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PPUSH
9419: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: LD_VAR 0 1
9432: PPUSH
9433: LD_INT 2
9435: PPUSH
9436: LD_VAR 0 1
9440: PUSH
9441: LD_INT 2
9443: ARRAY
9444: PUSH
9445: CALL_OW 44
9449: ADD
9450: PPUSH
9451: CALL_OW 1
9455: ST_TO_ADDR
// end ;
9456: GO 9342
9458: POP
9459: POP
// if commander = 1 then
9460: LD_EXP 25
9464: PUSH
9465: LD_INT 1
9467: EQUAL
9468: IFFALSE 9536
// for i = 1 to 4 do
9470: LD_ADDR_VAR 0 2
9474: PUSH
9475: DOUBLE
9476: LD_INT 1
9478: DEC
9479: ST_TO_ADDR
9480: LD_INT 4
9482: PUSH
9483: FOR_TO
9484: IFFALSE 9534
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9486: LD_INT 0
9488: PPUSH
9489: LD_INT 1
9491: PPUSH
9492: LD_INT 8
9494: PPUSH
9495: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9499: LD_ADDR_VAR 0 1
9503: PUSH
9504: LD_VAR 0 1
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: LD_VAR 0 1
9516: PUSH
9517: LD_INT 2
9519: ARRAY
9520: PUSH
9521: CALL_OW 44
9525: ADD
9526: PPUSH
9527: CALL_OW 1
9531: ST_TO_ADDR
// end ;
9532: GO 9483
9534: POP
9535: POP
// techs := [ ] ;
9536: LD_ADDR_VAR 0 4
9540: PUSH
9541: EMPTY
9542: ST_TO_ADDR
// if commander = 1 then
9543: LD_EXP 25
9547: PUSH
9548: LD_INT 1
9550: EQUAL
9551: IFFALSE 9576
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9553: LD_ADDR_VAR 0 4
9557: PUSH
9558: LD_INT 51
9560: PUSH
9561: LD_INT 52
9563: PUSH
9564: LD_INT 53
9566: PUSH
9567: LD_INT 12
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: ST_TO_ADDR
// if commander = 2 then
9576: LD_EXP 25
9580: PUSH
9581: LD_INT 2
9583: EQUAL
9584: IFFALSE 9621
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9586: LD_ADDR_VAR 0 4
9590: PUSH
9591: LD_INT 48
9593: PUSH
9594: LD_INT 47
9596: PUSH
9597: LD_INT 46
9599: PUSH
9600: LD_INT 45
9602: PUSH
9603: LD_INT 35
9605: PUSH
9606: LD_INT 60
9608: PUSH
9609: LD_INT 6
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: ST_TO_ADDR
// if commander = 3 then
9621: LD_EXP 25
9625: PUSH
9626: LD_INT 3
9628: EQUAL
9629: IFFALSE 9678
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9631: LD_ADDR_VAR 0 4
9635: PUSH
9636: LD_INT 27
9638: PUSH
9639: LD_INT 36
9641: PUSH
9642: LD_INT 32
9644: PUSH
9645: LD_INT 57
9647: PUSH
9648: LD_INT 58
9650: PUSH
9651: LD_INT 47
9653: PUSH
9654: LD_INT 46
9656: PUSH
9657: LD_INT 51
9659: PUSH
9660: LD_INT 69
9662: PUSH
9663: LD_INT 39
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// if techs then
9678: LD_VAR 0 4
9682: IFFALSE 9716
// for i in techs do
9684: LD_ADDR_VAR 0 2
9688: PUSH
9689: LD_VAR 0 4
9693: PUSH
9694: FOR_IN
9695: IFFALSE 9714
// SetTech ( i , 1 , state_researched ) ;
9697: LD_VAR 0 2
9701: PPUSH
9702: LD_INT 1
9704: PPUSH
9705: LD_INT 2
9707: PPUSH
9708: CALL_OW 322
9712: GO 9694
9714: POP
9715: POP
// hc_gallery := skirmish ;
9716: LD_ADDR_OWVAR 33
9720: PUSH
9721: LD_STRING skirmish
9723: ST_TO_ADDR
// hc_face_number := commander ;
9724: LD_ADDR_OWVAR 34
9728: PUSH
9729: LD_EXP 25
9733: ST_TO_ADDR
// hc_importance := 100 ;
9734: LD_ADDR_OWVAR 32
9738: PUSH
9739: LD_INT 100
9741: ST_TO_ADDR
// case commander of 1 :
9742: LD_EXP 25
9746: PUSH
9747: LD_INT 1
9749: DOUBLE
9750: EQUAL
9751: IFTRUE 9755
9753: GO 9779
9755: POP
// begin hc_name := Jeff Ironside ;
9756: LD_ADDR_OWVAR 26
9760: PUSH
9761: LD_STRING Jeff Ironside
9763: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9764: LD_INT 1
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 7
9772: PPUSH
9773: CALL_OW 380
// end ; 2 :
9777: GO 9844
9779: LD_INT 2
9781: DOUBLE
9782: EQUAL
9783: IFTRUE 9787
9785: GO 9811
9787: POP
// begin hc_name := Paul Johnson ;
9788: LD_ADDR_OWVAR 26
9792: PUSH
9793: LD_STRING Paul Johnson
9795: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9796: LD_INT 1
9798: PPUSH
9799: LD_INT 3
9801: PPUSH
9802: LD_INT 7
9804: PPUSH
9805: CALL_OW 380
// end ; 3 :
9809: GO 9844
9811: LD_INT 3
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9843
9819: POP
// begin hc_name := Lisa Stuart ;
9820: LD_ADDR_OWVAR 26
9824: PUSH
9825: LD_STRING Lisa Stuart
9827: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9828: LD_INT 2
9830: PPUSH
9831: LD_INT 4
9833: PPUSH
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 380
// end ; end ;
9841: GO 9844
9843: POP
// playerCommander := CreateHuman ;
9844: LD_ADDR_EXP 9
9848: PUSH
9849: CALL_OW 44
9853: ST_TO_ADDR
// hc_importance := 0 ;
9854: LD_ADDR_OWVAR 32
9858: PUSH
9859: LD_INT 0
9861: ST_TO_ADDR
// hc_gallery :=  ;
9862: LD_ADDR_OWVAR 33
9866: PUSH
9867: LD_STRING 
9869: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9870: LD_ADDR_VAR 0 1
9874: PUSH
9875: LD_VAR 0 1
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_INT 2
9890: ARRAY
9891: PUSH
9892: LD_EXP 9
9896: ADD
9897: PPUSH
9898: CALL_OW 1
9902: ST_TO_ADDR
// end ;
9903: LD_VAR 0 1
9907: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9908: LD_INT 0
9910: PPUSH
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// uc_side := 1 ;
9916: LD_ADDR_OWVAR 20
9920: PUSH
9921: LD_INT 1
9923: ST_TO_ADDR
// uc_nation := 1 ;
9924: LD_ADDR_OWVAR 21
9928: PUSH
9929: LD_INT 1
9931: ST_TO_ADDR
// InitHc ;
9932: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9936: LD_ADDR_VAR 0 3
9940: PUSH
9941: LD_INT 3
9943: PUSH
9944: LD_INT 3
9946: PUSH
9947: LD_INT 2
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: LIST
9954: PUSH
9955: LD_OWVAR 67
9959: ARRAY
9960: ST_TO_ADDR
// for i = 1 to peopleAmount do
9961: LD_ADDR_VAR 0 2
9965: PUSH
9966: DOUBLE
9967: LD_INT 1
9969: DEC
9970: ST_TO_ADDR
9971: LD_VAR 0 3
9975: PUSH
9976: FOR_TO
9977: IFFALSE 10026
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9979: LD_INT 0
9981: PPUSH
9982: LD_INT 2
9984: PPUSH
9985: LD_INT 7
9987: PUSH
9988: LD_INT 6
9990: PUSH
9991: LD_INT 5
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: PUSH
9999: LD_OWVAR 67
10003: ARRAY
10004: PPUSH
10005: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
10009: CALL_OW 44
10013: PPUSH
10014: LD_INT 19
10016: PPUSH
10017: LD_INT 0
10019: PPUSH
10020: CALL 56269 0 3
// end ;
10024: GO 9976
10026: POP
10027: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
10028: LD_INT 2
10030: PPUSH
10031: LD_INT 1
10033: PPUSH
10034: LD_INT 3
10036: PPUSH
10037: LD_INT 13
10039: PPUSH
10040: LD_INT 58
10042: PPUSH
10043: CALL 24899 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10047: CALL_OW 45
10051: PPUSH
10052: LD_INT 19
10054: PPUSH
10055: LD_INT 0
10057: PPUSH
10058: CALL 56269 0 3
// if commander = 1 then
10062: LD_EXP 25
10066: PUSH
10067: LD_INT 1
10069: EQUAL
10070: IFFALSE 10081
// wait ( 6 6$00 ) else
10072: LD_INT 12600
10074: PPUSH
10075: CALL_OW 67
10079: GO 10088
// wait ( 8 8$00 ) ;
10081: LD_INT 16800
10083: PPUSH
10084: CALL_OW 67
// uc_side := 1 ;
10088: LD_ADDR_OWVAR 20
10092: PUSH
10093: LD_INT 1
10095: ST_TO_ADDR
// uc_nation := 1 ;
10096: LD_ADDR_OWVAR 21
10100: PUSH
10101: LD_INT 1
10103: ST_TO_ADDR
// InitVc ;
10104: CALL_OW 20
// InitHc ;
10108: CALL_OW 19
// for i = 1 to 5 do
10112: LD_ADDR_VAR 0 2
10116: PUSH
10117: DOUBLE
10118: LD_INT 1
10120: DEC
10121: ST_TO_ADDR
10122: LD_INT 5
10124: PUSH
10125: FOR_TO
10126: IFFALSE 10370
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10128: LD_INT 4
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 1
10136: PUSH
10137: EMPTY
10138: LIST
10139: LIST
10140: LIST
10141: PUSH
10142: LD_VAR 0 2
10146: PUSH
10147: LD_INT 3
10149: MOD
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 1
10158: PPUSH
10159: LD_INT 1
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 2
10177: PUSH
10178: LD_INT 3
10180: MOD
10181: PUSH
10182: LD_INT 1
10184: PLUS
10185: ARRAY
10186: PPUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 12
10192: PUSH
10193: LD_INT 11
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: PUSH
10201: LD_VAR 0 2
10205: PUSH
10206: LD_INT 3
10208: MOD
10209: PUSH
10210: LD_INT 1
10212: PLUS
10213: ARRAY
10214: PPUSH
10215: LD_INT 40
10217: PPUSH
10218: LD_INT 55
10220: PPUSH
10221: CALL_OW 12
10225: PPUSH
10226: CALL 24899 0 5
// veh := CreateVehicle ;
10230: LD_ADDR_VAR 0 6
10234: PUSH
10235: CALL_OW 45
10239: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10240: LD_VAR 0 6
10244: PPUSH
10245: LD_INT 19
10247: PPUSH
10248: LD_INT 0
10250: PPUSH
10251: CALL 56269 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10255: LD_VAR 0 6
10259: PPUSH
10260: CALL_OW 264
10264: PUSH
10265: LD_INT 12
10267: EQUAL
10268: IFFALSE 10300
// begin AddCargo ( veh , mat_cans , 70 ) ;
10270: LD_VAR 0 6
10274: PPUSH
10275: LD_INT 1
10277: PPUSH
10278: LD_INT 70
10280: PPUSH
10281: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10285: LD_VAR 0 6
10289: PPUSH
10290: LD_INT 3
10292: PPUSH
10293: LD_INT 30
10295: PPUSH
10296: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10300: LD_VAR 0 6
10304: PPUSH
10305: CALL_OW 263
10309: PUSH
10310: LD_INT 1
10312: EQUAL
10313: IFFALSE 10368
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10315: LD_INT 1
10317: PPUSH
10318: LD_INT 3
10320: PPUSH
10321: LD_INT 6
10323: PPUSH
10324: CALL_OW 380
// un := CreateHuman ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: CALL_OW 44
10337: ST_TO_ADDR
// tmp := tmp ^ un ;
10338: LD_ADDR_VAR 0 4
10342: PUSH
10343: LD_VAR 0 4
10347: PUSH
10348: LD_VAR 0 5
10352: ADD
10353: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10354: LD_VAR 0 5
10358: PPUSH
10359: LD_VAR 0 6
10363: PPUSH
10364: CALL_OW 52
// end ; end ;
10368: GO 10125
10370: POP
10371: POP
// if tmp then
10372: LD_VAR 0 4
10376: IFFALSE 10440
// begin CenterNowOnUnits ( tmp ) ;
10378: LD_VAR 0 4
10382: PPUSH
10383: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10387: LD_VAR 0 4
10391: PUSH
10392: LD_INT 1
10394: ARRAY
10395: PPUSH
10396: LD_STRING DAR-1
10398: PPUSH
10399: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10403: LD_EXP 9
10407: PPUSH
10408: LD_STRING D
10410: PUSH
10411: LD_STRING I
10413: PUSH
10414: LD_STRING J
10416: PUSH
10417: LD_STRING S
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_EXP 25
10429: ARRAY
10430: STR
10431: PUSH
10432: LD_STRING -1-DAR
10434: STR
10435: PPUSH
10436: CALL_OW 88
// end ; if not reinforceAllowed then
10440: LD_EXP 24
10444: NOT
10445: IFFALSE 10449
// exit ;
10447: GO 10603
// wait ( 25 25$00 ) ;
10449: LD_INT 52500
10451: PPUSH
10452: CALL_OW 67
// uc_side := 1 ;
10456: LD_ADDR_OWVAR 20
10460: PUSH
10461: LD_INT 1
10463: ST_TO_ADDR
// uc_nation := 1 ;
10464: LD_ADDR_OWVAR 21
10468: PUSH
10469: LD_INT 1
10471: ST_TO_ADDR
// InitVc ;
10472: CALL_OW 20
// InitHc ;
10476: CALL_OW 19
// for i = 1 to 4 do
10480: LD_ADDR_VAR 0 2
10484: PUSH
10485: DOUBLE
10486: LD_INT 1
10488: DEC
10489: ST_TO_ADDR
10490: LD_INT 4
10492: PUSH
10493: FOR_TO
10494: IFFALSE 10601
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10496: LD_INT 5
10498: PPUSH
10499: LD_INT 3
10501: PPUSH
10502: LD_INT 1
10504: PPUSH
10505: LD_INT 6
10507: PPUSH
10508: LD_INT 1
10510: PPUSH
10511: CALL 24899 0 5
// veh := CreateVehicle ;
10515: LD_ADDR_VAR 0 6
10519: PUSH
10520: CALL_OW 45
10524: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10525: LD_VAR 0 6
10529: PPUSH
10530: LD_INT 19
10532: PPUSH
10533: LD_INT 0
10535: PPUSH
10536: CALL 56269 0 3
// if GetControl ( veh ) = control_manual then
10540: LD_VAR 0 6
10544: PPUSH
10545: CALL_OW 263
10549: PUSH
10550: LD_INT 1
10552: EQUAL
10553: IFFALSE 10599
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10555: LD_INT 0
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_INT 7
10563: PUSH
10564: LD_INT 6
10566: PUSH
10567: LD_INT 5
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: LIST
10574: PUSH
10575: LD_OWVAR 67
10579: ARRAY
10580: PPUSH
10581: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10585: CALL_OW 44
10589: PPUSH
10590: LD_VAR 0 6
10594: PPUSH
10595: CALL_OW 52
// end ; end ;
10599: GO 10493
10601: POP
10602: POP
// end ;
10603: LD_VAR 0 1
10607: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10608: LD_INT 0
10610: PPUSH
10611: PPUSH
10612: PPUSH
10613: PPUSH
10614: PPUSH
// uc_side := 8 ;
10615: LD_ADDR_OWVAR 20
10619: PUSH
10620: LD_INT 8
10622: ST_TO_ADDR
// uc_nation := nation_arabian ;
10623: LD_ADDR_OWVAR 21
10627: PUSH
10628: LD_INT 2
10630: ST_TO_ADDR
// for i = 1 to 2 do
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: DOUBLE
10637: LD_INT 1
10639: DEC
10640: ST_TO_ADDR
10641: LD_INT 2
10643: PUSH
10644: FOR_TO
10645: IFFALSE 10725
// for j = 1 to 4 do
10647: LD_ADDR_VAR 0 4
10651: PUSH
10652: DOUBLE
10653: LD_INT 1
10655: DEC
10656: ST_TO_ADDR
10657: LD_INT 4
10659: PUSH
10660: FOR_TO
10661: IFFALSE 10721
// begin PrepareHuman ( false , j , 8 ) ;
10663: LD_INT 0
10665: PPUSH
10666: LD_VAR 0 4
10670: PPUSH
10671: LD_INT 8
10673: PPUSH
10674: CALL_OW 380
// un := CreateHuman ;
10678: LD_ADDR_VAR 0 3
10682: PUSH
10683: CALL_OW 44
10687: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10688: LD_VAR 0 3
10692: PPUSH
10693: LD_INT 23
10695: PPUSH
10696: LD_INT 0
10698: PPUSH
10699: CALL_OW 49
// tmp := tmp union un ;
10703: LD_ADDR_VAR 0 5
10707: PUSH
10708: LD_VAR 0 5
10712: PUSH
10713: LD_VAR 0 3
10717: UNION
10718: ST_TO_ADDR
// end ;
10719: GO 10660
10721: POP
10722: POP
10723: GO 10644
10725: POP
10726: POP
// for i in tmp do
10727: LD_ADDR_VAR 0 2
10731: PUSH
10732: LD_VAR 0 5
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10757
// ComMoveXY ( i , 150 , 136 ) ;
10740: LD_VAR 0 2
10744: PPUSH
10745: LD_INT 150
10747: PPUSH
10748: LD_INT 136
10750: PPUSH
10751: CALL_OW 111
10755: GO 10737
10757: POP
10758: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10759: LD_ADDR_EXP 31
10763: PUSH
10764: LD_EXP 31
10768: PPUSH
10769: LD_EXP 6
10773: PPUSH
10774: LD_EXP 31
10778: PUSH
10779: LD_EXP 6
10783: ARRAY
10784: PUSH
10785: LD_VAR 0 5
10789: UNION
10790: PPUSH
10791: CALL_OW 1
10795: ST_TO_ADDR
// end ;
10796: LD_VAR 0 1
10800: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10801: LD_OWVAR 67
10805: PUSH
10806: LD_INT 1
10808: GREATER
10809: PUSH
10810: LD_INT 31
10812: PPUSH
10813: LD_INT 3
10815: PPUSH
10816: CALL_OW 321
10820: PUSH
10821: LD_INT 2
10823: EQUAL
10824: AND
10825: IFFALSE 11042
10827: GO 10829
10829: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10830: LD_EXP 7
10834: PPUSH
10835: LD_INT 33
10837: PUSH
10838: LD_INT 101
10840: PUSH
10841: LD_INT 159
10843: PUSH
10844: LD_INT 5
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 33
10855: PUSH
10856: LD_INT 105
10858: PUSH
10859: LD_INT 158
10861: PUSH
10862: LD_INT 5
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 33
10873: PUSH
10874: LD_INT 96
10876: PUSH
10877: LD_INT 136
10879: PUSH
10880: LD_INT 5
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PUSH
10889: LD_INT 33
10891: PUSH
10892: LD_INT 94
10894: PUSH
10895: LD_INT 133
10897: PUSH
10898: LD_INT 4
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: LD_INT 33
10909: PUSH
10910: LD_INT 84
10912: PUSH
10913: LD_INT 102
10915: PUSH
10916: LD_INT 4
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PPUSH
10932: CALL 85481 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10936: LD_EXP 8
10940: PPUSH
10941: LD_INT 33
10943: PUSH
10944: LD_INT 50
10946: PUSH
10947: LD_INT 17
10949: PUSH
10950: LD_INT 4
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: PUSH
10959: LD_INT 33
10961: PUSH
10962: LD_INT 52
10964: PUSH
10965: LD_INT 20
10967: PUSH
10968: LD_INT 4
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 33
10979: PUSH
10980: LD_INT 53
10982: PUSH
10983: LD_INT 23
10985: PUSH
10986: LD_INT 4
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 33
10997: PUSH
10998: LD_INT 45
11000: PUSH
11001: LD_INT 32
11003: PUSH
11004: LD_INT 4
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: LIST
11011: LIST
11012: PUSH
11013: LD_INT 33
11015: PUSH
11016: LD_INT 45
11018: PUSH
11019: LD_INT 39
11021: PUSH
11022: LD_INT 4
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL 85481 0 2
// end ;
11042: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11043: LD_INT 3
11045: PUSH
11046: LD_INT 22
11048: PUSH
11049: LD_OWVAR 2
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PUSH
11062: LD_INT 33
11064: PUSH
11065: LD_INT 2
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: LD_INT 50
11074: PUSH
11075: EMPTY
11076: LIST
11077: PUSH
11078: LD_INT 3
11080: PUSH
11081: LD_INT 61
11083: PUSH
11084: EMPTY
11085: LIST
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PUSH
11091: EMPTY
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: PPUSH
11097: CALL_OW 69
11101: IFFALSE 11201
11103: GO 11105
11105: DISABLE
11106: LD_INT 0
11108: PPUSH
11109: PPUSH
// begin enable ;
11110: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11111: LD_ADDR_VAR 0 2
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 22
11121: PUSH
11122: LD_OWVAR 2
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 33
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 50
11147: PUSH
11148: EMPTY
11149: LIST
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: LD_INT 61
11156: PUSH
11157: EMPTY
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: PPUSH
11170: CALL_OW 69
11174: ST_TO_ADDR
// for i in tmp do
11175: LD_ADDR_VAR 0 1
11179: PUSH
11180: LD_VAR 0 2
11184: PUSH
11185: FOR_IN
11186: IFFALSE 11199
// Connect ( i ) ;
11188: LD_VAR 0 1
11192: PPUSH
11193: CALL 27990 0 1
11197: GO 11185
11199: POP
11200: POP
// end ; end_of_file
11201: PPOPN 2
11203: END
// export function Action ; var i , tmp ; begin
11204: LD_INT 0
11206: PPUSH
11207: PPUSH
11208: PPUSH
// InGameOn ;
11209: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11213: LD_INT 225
11215: PPUSH
11216: LD_INT 217
11218: PPUSH
11219: CALL_OW 86
// for i in playerForces [ 2 ] do
11223: LD_ADDR_VAR 0 2
11227: PUSH
11228: LD_EXP 10
11232: PUSH
11233: LD_INT 2
11235: ARRAY
11236: PUSH
11237: FOR_IN
11238: IFFALSE 11371
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11240: LD_EXP 10
11244: PUSH
11245: LD_INT 1
11247: ARRAY
11248: PUSH
11249: LD_VAR 0 2
11253: PPUSH
11254: CALL_OW 257
11258: PUSH
11259: LD_INT 3
11261: PUSH
11262: LD_INT 4
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: IN
11269: AND
11270: IFFALSE 11354
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11272: LD_EXP 10
11276: PUSH
11277: LD_INT 1
11279: ARRAY
11280: PUSH
11281: LD_INT 1
11283: ARRAY
11284: PPUSH
11285: LD_INT 19
11287: PPUSH
11288: LD_INT 0
11290: PPUSH
11291: CALL 56269 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11295: LD_VAR 0 2
11299: PPUSH
11300: LD_EXP 10
11304: PUSH
11305: LD_INT 1
11307: ARRAY
11308: PUSH
11309: LD_INT 1
11311: ARRAY
11312: PPUSH
11313: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11317: LD_ADDR_EXP 10
11321: PUSH
11322: LD_EXP 10
11326: PPUSH
11327: LD_INT 1
11329: PPUSH
11330: LD_EXP 10
11334: PUSH
11335: LD_INT 1
11337: ARRAY
11338: PPUSH
11339: LD_INT 1
11341: PPUSH
11342: CALL_OW 3
11346: PPUSH
11347: CALL_OW 1
11351: ST_TO_ADDR
// end else
11352: GO 11369
// PlaceUnitInArea ( i , startArea , false ) ;
11354: LD_VAR 0 2
11358: PPUSH
11359: LD_INT 19
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL 56269 0 3
// end ;
11369: GO 11237
11371: POP
11372: POP
// wait ( 0 0$2 ) ;
11373: LD_INT 70
11375: PPUSH
11376: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11380: LD_EXP 9
11384: PPUSH
11385: LD_STRING D
11387: PUSH
11388: LD_STRING I
11390: PUSH
11391: LD_STRING J
11393: PUSH
11394: LD_STRING S
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: LIST
11401: PUSH
11402: LD_EXP 25
11406: ARRAY
11407: STR
11408: PUSH
11409: LD_STRING -1
11411: STR
11412: PPUSH
11413: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11417: LD_EXP 12
11421: PPUSH
11422: LD_STRING DP-1
11424: PPUSH
11425: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11429: LD_EXP 12
11433: PPUSH
11434: LD_STRING DP-2
11436: PPUSH
11437: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11441: LD_EXP 9
11445: PPUSH
11446: LD_STRING D
11448: PUSH
11449: LD_STRING I
11451: PUSH
11452: LD_STRING J
11454: PUSH
11455: LD_STRING S
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: PUSH
11463: LD_EXP 25
11467: ARRAY
11468: STR
11469: PUSH
11470: LD_STRING -2
11472: STR
11473: PPUSH
11474: CALL_OW 88
// InGameOff ;
11478: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11482: LD_STRING O1
11484: PPUSH
11485: CALL_OW 337
// game := true ;
11489: LD_ADDR_EXP 3
11493: PUSH
11494: LD_INT 1
11496: ST_TO_ADDR
// SaveForQuickRestart ;
11497: CALL_OW 22
// wait ( 0 0$5 ) ;
11501: LD_INT 175
11503: PPUSH
11504: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11508: LD_EXP 9
11512: PPUSH
11513: LD_STRING D
11515: PUSH
11516: LD_STRING I
11518: PUSH
11519: LD_STRING J
11521: PUSH
11522: LD_STRING S
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: LIST
11529: PUSH
11530: LD_EXP 25
11534: ARRAY
11535: STR
11536: PUSH
11537: LD_STRING -3
11539: STR
11540: PPUSH
11541: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11545: LD_INT 35
11547: PPUSH
11548: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11552: LD_EXP 15
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PUSH
11561: LD_EXP 15
11565: PUSH
11566: LD_INT 2
11568: ARRAY
11569: GREATEREQUAL
11570: IFFALSE 11545
// outpostEscape := true ;
11572: LD_ADDR_EXP 27
11576: PUSH
11577: LD_INT 1
11579: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11580: LD_ADDR_VAR 0 3
11584: PUSH
11585: LD_EXP 14
11589: PPUSH
11590: LD_INT 26
11592: PUSH
11593: LD_INT 1
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PPUSH
11600: CALL_OW 72
11604: ST_TO_ADDR
// if tmp then
11605: LD_VAR 0 3
11609: IFFALSE 11627
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11611: LD_VAR 0 3
11615: PUSH
11616: LD_INT 1
11618: ARRAY
11619: PPUSH
11620: LD_STRING DR-1-Escape
11622: PPUSH
11623: CALL_OW 88
// wait ( 0 0$1 ) ;
11627: LD_INT 35
11629: PPUSH
11630: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11634: LD_EXP 9
11638: PPUSH
11639: LD_STRING D
11641: PUSH
11642: LD_STRING I
11644: PUSH
11645: LD_STRING J
11647: PUSH
11648: LD_STRING S
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: LIST
11655: PUSH
11656: LD_EXP 25
11660: ARRAY
11661: STR
11662: PUSH
11663: LD_STRING -1-Escape
11665: STR
11666: PPUSH
11667: CALL_OW 88
// for i in ruOutpost do
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_EXP 14
11680: PUSH
11681: FOR_IN
11682: IFFALSE 11736
// begin if IsInUnit ( i ) then
11684: LD_VAR 0 2
11688: PPUSH
11689: CALL_OW 310
11693: IFFALSE 11704
// ComExitBuilding ( i ) ;
11695: LD_VAR 0 2
11699: PPUSH
11700: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11704: LD_VAR 0 2
11708: PPUSH
11709: LD_INT 179
11711: PPUSH
11712: LD_INT 102
11714: PPUSH
11715: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11719: LD_VAR 0 2
11723: PPUSH
11724: LD_INT 28
11726: PPUSH
11727: LD_INT 20
11729: PPUSH
11730: CALL_OW 171
// end ;
11734: GO 11681
11736: POP
11737: POP
// tmp := [ ] ;
11738: LD_ADDR_VAR 0 3
11742: PUSH
11743: EMPTY
11744: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11745: LD_INT 35
11747: PPUSH
11748: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11752: LD_ADDR_VAR 0 3
11756: PUSH
11757: LD_EXP 14
11761: PPUSH
11762: LD_INT 95
11764: PUSH
11765: LD_INT 11
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PPUSH
11772: CALL_OW 72
11776: ST_TO_ADDR
// if tmp then
11777: LD_VAR 0 3
11781: IFFALSE 11860
// for i in tmp do
11783: LD_ADDR_VAR 0 2
11787: PUSH
11788: LD_VAR 0 3
11792: PUSH
11793: FOR_IN
11794: IFFALSE 11858
// begin ruOutpost := ruOutpost diff i ;
11796: LD_ADDR_EXP 14
11800: PUSH
11801: LD_EXP 14
11805: PUSH
11806: LD_VAR 0 2
11810: DIFF
11811: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11812: LD_ADDR_EXP 31
11816: PUSH
11817: LD_EXP 31
11821: PPUSH
11822: LD_EXP 8
11826: PUSH
11827: LD_EXP 31
11831: PUSH
11832: LD_EXP 8
11836: ARRAY
11837: PUSH
11838: LD_INT 1
11840: PLUS
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: PPUSH
11846: LD_VAR 0 2
11850: PPUSH
11851: CALL 25021 0 3
11855: ST_TO_ADDR
// end ;
11856: GO 11793
11858: POP
11859: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11860: LD_EXP 14
11864: PPUSH
11865: LD_INT 21
11867: PUSH
11868: LD_INT 1
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: PPUSH
11875: CALL_OW 72
11879: NOT
11880: IFFALSE 11745
// ruOutpost := [ ] ;
11882: LD_ADDR_EXP 14
11886: PUSH
11887: EMPTY
11888: ST_TO_ADDR
// end ;
11889: LD_VAR 0 1
11893: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11894: LD_EXP 27
11898: IFFALSE 12087
11900: GO 11902
11902: DISABLE
11903: LD_INT 0
11905: PPUSH
11906: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11907: LD_INT 875
11909: PPUSH
11910: LD_INT 1225
11912: PPUSH
11913: CALL_OW 12
11917: PPUSH
11918: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11922: LD_ADDR_VAR 0 2
11926: PUSH
11927: LD_INT 208
11929: PUSH
11930: LD_INT 166
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: PUSH
11937: LD_INT 218
11939: PUSH
11940: LD_INT 174
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 201
11949: PUSH
11950: LD_INT 173
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 189
11959: PUSH
11960: LD_INT 167
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 191
11969: PUSH
11970: LD_INT 160
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 209
11979: PUSH
11980: LD_INT 181
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 192
11989: PUSH
11990: LD_INT 162
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: LD_INT 197
11999: PUSH
12000: LD_INT 166
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
12017: LD_ADDR_VAR 0 1
12021: PUSH
12022: DOUBLE
12023: LD_INT 1
12025: DEC
12026: ST_TO_ADDR
12027: LD_INT 5
12029: PUSH
12030: LD_OWVAR 67
12034: PLUS
12035: PUSH
12036: FOR_TO
12037: IFFALSE 12085
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12039: LD_VAR 0 2
12043: PUSH
12044: LD_VAR 0 1
12048: ARRAY
12049: PUSH
12050: LD_INT 1
12052: ARRAY
12053: PPUSH
12054: LD_VAR 0 2
12058: PUSH
12059: LD_VAR 0 1
12063: ARRAY
12064: PUSH
12065: LD_INT 2
12067: ARRAY
12068: PPUSH
12069: LD_INT 1
12071: PPUSH
12072: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12076: LD_INT 28
12078: PPUSH
12079: CALL_OW 67
// end ;
12083: GO 12036
12085: POP
12086: POP
// end ;
12087: PPOPN 2
12089: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12090: LD_EXP 27
12094: NOT
12095: IFFALSE 12749
12097: GO 12099
12099: DISABLE
12100: LD_INT 0
12102: PPUSH
12103: PPUSH
12104: PPUSH
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// begin enable ;
12109: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12110: LD_ADDR_VAR 0 1
12114: PUSH
12115: LD_EXP 14
12119: PPUSH
12120: LD_INT 22
12122: PUSH
12123: LD_INT 3
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 25
12132: PUSH
12133: LD_INT 1
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PPUSH
12144: CALL_OW 72
12148: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12149: LD_ADDR_VAR 0 2
12153: PUSH
12154: LD_EXP 14
12158: PPUSH
12159: LD_INT 22
12161: PUSH
12162: LD_INT 3
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 25
12171: PUSH
12172: LD_INT 2
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 72
12187: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12188: LD_ADDR_VAR 0 3
12192: PUSH
12193: LD_EXP 14
12197: PPUSH
12198: LD_INT 22
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 21
12210: PUSH
12211: LD_INT 3
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 3
12220: PUSH
12221: LD_INT 24
12223: PUSH
12224: LD_INT 1000
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: LIST
12239: PPUSH
12240: CALL_OW 72
12244: ST_TO_ADDR
// if engs and buildings then
12245: LD_VAR 0 2
12249: PUSH
12250: LD_VAR 0 3
12254: AND
12255: IFFALSE 12328
// begin for i in engs do
12257: LD_ADDR_VAR 0 5
12261: PUSH
12262: LD_VAR 0 2
12266: PUSH
12267: FOR_IN
12268: IFFALSE 12324
// if IsInUnit ( i ) then
12270: LD_VAR 0 5
12274: PPUSH
12275: CALL_OW 310
12279: IFFALSE 12292
// ComExitBuilding ( i ) else
12281: LD_VAR 0 5
12285: PPUSH
12286: CALL_OW 122
12290: GO 12322
// if not HasTask ( i ) then
12292: LD_VAR 0 5
12296: PPUSH
12297: CALL_OW 314
12301: NOT
12302: IFFALSE 12322
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12304: LD_VAR 0 5
12308: PPUSH
12309: LD_VAR 0 3
12313: PUSH
12314: LD_INT 1
12316: ARRAY
12317: PPUSH
12318: CALL_OW 130
12322: GO 12267
12324: POP
12325: POP
// end else
12326: GO 12431
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12328: LD_VAR 0 3
12332: NOT
12333: PUSH
12334: LD_EXP 14
12338: PPUSH
12339: LD_INT 30
12341: PUSH
12342: LD_INT 0
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL_OW 72
12353: AND
12354: PUSH
12355: LD_VAR 0 2
12359: PPUSH
12360: LD_INT 3
12362: PUSH
12363: LD_INT 54
12365: PUSH
12366: EMPTY
12367: LIST
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 72
12377: AND
12378: IFFALSE 12431
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12380: LD_VAR 0 2
12384: PPUSH
12385: LD_INT 3
12387: PUSH
12388: LD_INT 54
12390: PUSH
12391: EMPTY
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 72
12402: PPUSH
12403: LD_EXP 14
12407: PPUSH
12408: LD_INT 30
12410: PUSH
12411: LD_INT 0
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PPUSH
12418: CALL_OW 72
12422: PUSH
12423: LD_INT 1
12425: ARRAY
12426: PPUSH
12427: CALL_OW 120
// if not tmp then
12431: LD_VAR 0 1
12435: NOT
12436: IFFALSE 12440
// exit ;
12438: GO 12749
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12440: LD_INT 26
12442: PPUSH
12443: LD_INT 81
12445: PUSH
12446: LD_INT 3
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PPUSH
12453: CALL_OW 70
12457: PUSH
12458: LD_INT 1
12460: GREATER
12461: IFFALSE 12517
// begin for i in tmp do
12463: LD_ADDR_VAR 0 5
12467: PUSH
12468: LD_VAR 0 1
12472: PUSH
12473: FOR_IN
12474: IFFALSE 12513
// begin if IsInUnit ( i ) then
12476: LD_VAR 0 5
12480: PPUSH
12481: CALL_OW 310
12485: IFFALSE 12496
// ComExitBuilding ( i ) ;
12487: LD_VAR 0 5
12491: PPUSH
12492: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12496: LD_VAR 0 5
12500: PPUSH
12501: LD_INT 204
12503: PPUSH
12504: LD_INT 164
12506: PPUSH
12507: CALL_OW 174
// end ;
12511: GO 12473
12513: POP
12514: POP
// end else
12515: GO 12749
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 3
12524: PUSH
12525: LD_INT 54
12527: PUSH
12528: EMPTY
12529: LIST
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL_OW 72
12539: IFFALSE 12749
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12541: LD_ADDR_VAR 0 4
12545: PUSH
12546: LD_EXP 14
12550: PPUSH
12551: LD_INT 30
12553: PUSH
12554: LD_INT 32
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 58
12563: PUSH
12564: EMPTY
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PPUSH
12571: CALL_OW 72
12575: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12576: LD_VAR 0 4
12580: NOT
12581: PUSH
12582: LD_EXP 14
12586: PPUSH
12587: LD_INT 30
12589: PUSH
12590: LD_INT 5
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: PPUSH
12597: CALL_OW 72
12601: AND
12602: IFFALSE 12639
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: LD_EXP 14
12613: PPUSH
12614: LD_INT 30
12616: PUSH
12617: LD_INT 5
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PPUSH
12624: CALL_OW 72
12628: PUSH
12629: LD_INT 1
12631: ARRAY
12632: PPUSH
12633: CALL_OW 120
// exit ;
12637: GO 12749
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12639: LD_ADDR_VAR 0 6
12643: PUSH
12644: LD_VAR 0 1
12648: PPUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 54
12654: PUSH
12655: EMPTY
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 72
12666: ST_TO_ADDR
// if j < empty then
12667: LD_VAR 0 6
12671: PUSH
12672: LD_VAR 0 4
12676: LESS
12677: IFFALSE 12691
// k := j else
12679: LD_ADDR_VAR 0 7
12683: PUSH
12684: LD_VAR 0 6
12688: ST_TO_ADDR
12689: GO 12701
// k := empty ;
12691: LD_ADDR_VAR 0 7
12695: PUSH
12696: LD_VAR 0 4
12700: ST_TO_ADDR
// for i = 1 to k do
12701: LD_ADDR_VAR 0 5
12705: PUSH
12706: DOUBLE
12707: LD_INT 1
12709: DEC
12710: ST_TO_ADDR
12711: LD_VAR 0 7
12715: PUSH
12716: FOR_TO
12717: IFFALSE 12747
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12719: LD_VAR 0 6
12723: PUSH
12724: LD_VAR 0 5
12728: ARRAY
12729: PPUSH
12730: LD_VAR 0 4
12734: PUSH
12735: LD_VAR 0 5
12739: ARRAY
12740: PPUSH
12741: CALL_OW 120
12745: GO 12716
12747: POP
12748: POP
// end ; end ;
12749: PPOPN 7
12751: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12752: LD_EXP 2
12756: PUSH
12757: LD_INT 1
12759: EQUAL
12760: PUSH
12761: LD_EXP 27
12765: AND
12766: PUSH
12767: LD_INT 22
12769: PUSH
12770: LD_INT 1
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 92
12779: PUSH
12780: LD_INT 208
12782: PUSH
12783: LD_INT 163
12785: PUSH
12786: LD_INT 8
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: AND
12804: PUSH
12805: LD_INT 22
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: LD_INT 21
12817: PUSH
12818: LD_INT 1
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 92
12827: PUSH
12828: LD_INT 208
12830: PUSH
12831: LD_INT 163
12833: PUSH
12834: LD_INT 14
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL_OW 69
12852: NOT
12853: AND
12854: IFFALSE 13159
12856: GO 12858
12858: DISABLE
12859: LD_INT 0
12861: PPUSH
// begin InGameOn ;
12862: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12866: LD_EXP 9
12870: PPUSH
12871: CALL_OW 87
// wait ( 0 0$1 ) ;
12875: LD_INT 35
12877: PPUSH
12878: CALL_OW 67
// DialogueOn ;
12882: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12886: LD_EXP 9
12890: PPUSH
12891: LD_STRING D
12893: PUSH
12894: LD_STRING I
12896: PUSH
12897: LD_STRING J
12899: PUSH
12900: LD_STRING S
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: LIST
12907: PUSH
12908: LD_EXP 25
12912: ARRAY
12913: STR
12914: PUSH
12915: LD_STRING -1-BaseCaptured
12917: STR
12918: PPUSH
12919: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12923: LD_EXP 12
12927: PPUSH
12928: LD_STRING DP-1-BaseCaptured
12930: PPUSH
12931: CALL_OW 94
// if sibBombAllowed then
12935: LD_EXP 23
12939: IFFALSE 13081
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12941: LD_EXP 9
12945: PPUSH
12946: LD_STRING D
12948: PUSH
12949: LD_STRING I
12951: PUSH
12952: LD_STRING J
12954: PUSH
12955: LD_STRING S
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: PUSH
12963: LD_EXP 25
12967: ARRAY
12968: STR
12969: PUSH
12970: LD_STRING -2-BaseCaptured
12972: STR
12973: PPUSH
12974: CALL_OW 88
// if commander = 1 then
12978: LD_EXP 25
12982: PUSH
12983: LD_INT 1
12985: EQUAL
12986: IFFALSE 13000
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12988: LD_EXP 12
12992: PPUSH
12993: LD_STRING DP-2b-BaseCaptured
12995: PPUSH
12996: CALL_OW 94
// if commander = 2 then
13000: LD_EXP 25
13004: PUSH
13005: LD_INT 2
13007: EQUAL
13008: IFFALSE 13022
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
13010: LD_EXP 12
13014: PPUSH
13015: LD_STRING DP-2-BaseCaptured
13017: PPUSH
13018: CALL_OW 94
// if commander = 3 then
13022: LD_EXP 25
13026: PUSH
13027: LD_INT 3
13029: EQUAL
13030: IFFALSE 13044
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13032: LD_EXP 12
13036: PPUSH
13037: LD_STRING DP-2a-BaseCaptured
13039: PPUSH
13040: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13044: LD_EXP 9
13048: PPUSH
13049: LD_STRING D
13051: PUSH
13052: LD_STRING I
13054: PUSH
13055: LD_STRING J
13057: PUSH
13058: LD_STRING S
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: LIST
13065: PUSH
13066: LD_EXP 25
13070: ARRAY
13071: STR
13072: PUSH
13073: LD_STRING -3-BaseCaptured
13075: STR
13076: PPUSH
13077: CALL_OW 88
// end ; DialogueOff ;
13081: CALL_OW 7
// InGameOff ;
13085: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13089: LD_STRING O2
13091: PPUSH
13092: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13096: LD_ADDR_VAR 0 1
13100: PUSH
13101: LD_EXP 14
13105: PPUSH
13106: LD_INT 21
13108: PUSH
13109: LD_INT 3
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PPUSH
13116: CALL_OW 72
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13138
// SetSide ( i , 1 ) ;
13124: LD_VAR 0 1
13128: PPUSH
13129: LD_INT 1
13131: PPUSH
13132: CALL_OW 235
13136: GO 13121
13138: POP
13139: POP
// baseCaptured := true ;
13140: LD_ADDR_EXP 17
13144: PUSH
13145: LD_INT 1
13147: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13148: LD_INT 1225
13150: PPUSH
13151: CALL_OW 67
// PrepareReinforcements ;
13155: CALL 9908 0 0
// end ;
13159: PPOPN 1
13161: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13162: LD_INT 22
13164: PUSH
13165: LD_INT 3
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 92
13174: PUSH
13175: LD_INT 167
13177: PUSH
13178: LD_INT 197
13180: PUSH
13181: LD_INT 20
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 69
13198: PUSH
13199: LD_INT 3
13201: GREATER
13202: IFFALSE 13219
13204: GO 13206
13206: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13207: LD_EXP 12
13211: PPUSH
13212: LD_STRING DP-RuAttack
13214: PPUSH
13215: CALL_OW 94
13219: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13220: LD_EXP 1
13224: NOT
13225: PUSH
13226: LD_INT 1
13228: PPUSH
13229: LD_INT 168
13231: PPUSH
13232: LD_INT 74
13234: PPUSH
13235: CALL_OW 293
13239: AND
13240: PUSH
13241: LD_INT 168
13243: PPUSH
13244: LD_INT 72
13246: PPUSH
13247: CALL_OW 553
13251: AND
13252: IFFALSE 13304
13254: GO 13256
13256: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13257: LD_INT 168
13259: PPUSH
13260: LD_INT 72
13262: PPUSH
13263: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13267: LD_EXP 9
13271: PPUSH
13272: LD_STRING D
13274: PUSH
13275: LD_STRING I
13277: PUSH
13278: LD_STRING J
13280: PUSH
13281: LD_STRING S
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_EXP 25
13293: ARRAY
13294: STR
13295: PUSH
13296: LD_STRING -1-Blockade
13298: STR
13299: PPUSH
13300: CALL_OW 88
// end ;
13304: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13305: LD_EXP 2
13309: PUSH
13310: LD_INT 1
13312: EQUAL
13313: PUSH
13314: LD_INT 22
13316: PUSH
13317: LD_INT 1
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: LD_INT 101
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: AND
13343: IFFALSE 13875
13345: GO 13347
13347: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13348: LD_INT 4
13350: PPUSH
13351: LD_INT 1
13353: PPUSH
13354: CALL_OW 343
// DialogueOn ;
13358: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13362: LD_EXP 11
13366: PPUSH
13367: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13371: LD_EXP 11
13375: PPUSH
13376: LD_STRING DM-1-Contact
13378: PPUSH
13379: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13383: LD_EXP 9
13387: PPUSH
13388: LD_STRING D
13390: PUSH
13391: LD_STRING I
13393: PUSH
13394: LD_STRING J
13396: PUSH
13397: LD_STRING S
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: LIST
13404: PUSH
13405: LD_EXP 25
13409: ARRAY
13410: STR
13411: PUSH
13412: LD_STRING -1-Contact
13414: STR
13415: PPUSH
13416: CALL_OW 88
// if commander = 1 then
13420: LD_EXP 25
13424: PUSH
13425: LD_INT 1
13427: EQUAL
13428: IFFALSE 13560
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13430: LD_EXP 11
13434: PPUSH
13435: LD_STRING DM-2-Contact
13437: PPUSH
13438: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13442: LD_EXP 9
13446: PPUSH
13447: LD_STRING DI-2-Contact
13449: PPUSH
13450: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13454: LD_INT 22
13456: PUSH
13457: LD_INT 8
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 21
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PPUSH
13478: CALL_OW 69
13482: PUSH
13483: LD_INT 8
13485: PPUSH
13486: LD_INT 1
13488: PPUSH
13489: CALL_OW 81
13493: PUSH
13494: LD_INT 2
13496: EQUAL
13497: AND
13498: IFFALSE 13524
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13500: LD_EXP 11
13504: PPUSH
13505: LD_STRING DM-3-Contact
13507: PPUSH
13508: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13512: LD_EXP 9
13516: PPUSH
13517: LD_STRING DI-3-Contact
13519: PPUSH
13520: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13524: LD_EXP 11
13528: PPUSH
13529: LD_STRING DM-4-Contact
13531: PPUSH
13532: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13536: LD_EXP 9
13540: PPUSH
13541: LD_STRING DI-4-Contact
13543: PPUSH
13544: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13548: LD_EXP 11
13552: PPUSH
13553: LD_STRING DM-5-Contact
13555: PPUSH
13556: CALL_OW 94
// end ; if commander = 2 then
13560: LD_EXP 25
13564: PUSH
13565: LD_INT 2
13567: EQUAL
13568: IFFALSE 13700
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13570: LD_EXP 11
13574: PPUSH
13575: LD_STRING DM-2c-Contact
13577: PPUSH
13578: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13582: LD_EXP 9
13586: PPUSH
13587: LD_STRING DJ-2-Contact
13589: PPUSH
13590: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13594: LD_INT 22
13596: PUSH
13597: LD_INT 8
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: LD_INT 21
13606: PUSH
13607: LD_INT 1
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PPUSH
13618: CALL_OW 69
13622: PUSH
13623: LD_INT 8
13625: PPUSH
13626: LD_INT 1
13628: PPUSH
13629: CALL_OW 81
13633: PUSH
13634: LD_INT 2
13636: EQUAL
13637: AND
13638: IFFALSE 13664
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13640: LD_EXP 11
13644: PPUSH
13645: LD_STRING DM-3-Contact
13647: PPUSH
13648: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13652: LD_EXP 9
13656: PPUSH
13657: LD_STRING DJ-3-Contact
13659: PPUSH
13660: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13664: LD_EXP 11
13668: PPUSH
13669: LD_STRING DM-4-Contact
13671: PPUSH
13672: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13676: LD_EXP 9
13680: PPUSH
13681: LD_STRING DJ-4-Contact
13683: PPUSH
13684: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13688: LD_EXP 11
13692: PPUSH
13693: LD_STRING DM-5a-Contact
13695: PPUSH
13696: CALL_OW 94
// end ; if commander = 3 then
13700: LD_EXP 25
13704: PUSH
13705: LD_INT 3
13707: EQUAL
13708: IFFALSE 13864
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13710: LD_EXP 11
13714: PPUSH
13715: LD_STRING DM-2a-Contact
13717: PPUSH
13718: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13722: LD_EXP 9
13726: PPUSH
13727: LD_STRING DS-2a-Contact
13729: PPUSH
13730: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13734: LD_EXP 11
13738: PPUSH
13739: LD_STRING DM-2b-Contact
13741: PPUSH
13742: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13746: LD_EXP 9
13750: PPUSH
13751: LD_STRING DS-2b-Contact
13753: PPUSH
13754: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13758: LD_INT 22
13760: PUSH
13761: LD_INT 8
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PUSH
13768: LD_INT 21
13770: PUSH
13771: LD_INT 1
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_INT 8
13789: PPUSH
13790: LD_INT 1
13792: PPUSH
13793: CALL_OW 81
13797: PUSH
13798: LD_INT 2
13800: EQUAL
13801: AND
13802: IFFALSE 13828
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13804: LD_EXP 11
13808: PPUSH
13809: LD_STRING DM-3-Contact
13811: PPUSH
13812: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13816: LD_EXP 9
13820: PPUSH
13821: LD_STRING DS-3-Contact
13823: PPUSH
13824: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13828: LD_EXP 11
13832: PPUSH
13833: LD_STRING DM-4-Contact
13835: PPUSH
13836: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13840: LD_EXP 9
13844: PPUSH
13845: LD_STRING DS-4-Contact
13847: PPUSH
13848: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13852: LD_EXP 11
13856: PPUSH
13857: LD_STRING DM-5-Contact
13859: PPUSH
13860: CALL_OW 94
// end ; DialogueOff ;
13864: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13868: LD_STRING O3
13870: PPUSH
13871: CALL_OW 337
// end ;
13875: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13876: LD_EXP 2
13880: PUSH
13881: LD_INT 1
13883: EQUAL
13884: PUSH
13885: LD_EXP 18
13889: PUSH
13890: LD_INT 15
13892: PUSH
13893: LD_INT 20
13895: PUSH
13896: LD_INT 25
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: LIST
13903: PUSH
13904: LD_OWVAR 67
13908: ARRAY
13909: GREATEREQUAL
13910: AND
13911: PUSH
13912: LD_INT 22
13914: PUSH
13915: LD_INT 8
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: LD_INT 30
13924: PUSH
13925: LD_INT 1
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PPUSH
13936: CALL_OW 69
13940: AND
13941: PUSH
13942: LD_INT 22
13944: PUSH
13945: LD_INT 8
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 21
13954: PUSH
13955: LD_INT 3
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PPUSH
13966: CALL_OW 69
13970: PUSH
13971: LD_INT 5
13973: GREATEREQUAL
13974: AND
13975: IFFALSE 14498
13977: GO 13979
13979: DISABLE
13980: LD_INT 0
13982: PPUSH
13983: PPUSH
13984: PPUSH
13985: PPUSH
// begin DialogueOn ;
13986: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13990: LD_EXP 13
13994: PPUSH
13995: LD_STRING DF-1-Leg
13997: PPUSH
13998: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14002: LD_EXP 9
14006: PPUSH
14007: LD_STRING D
14009: PUSH
14010: LD_STRING I
14012: PUSH
14013: LD_STRING J
14015: PUSH
14016: LD_STRING S
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: LIST
14023: PUSH
14024: LD_EXP 25
14028: ARRAY
14029: STR
14030: PUSH
14031: LD_STRING -1-Leg
14033: STR
14034: PPUSH
14035: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14039: LD_EXP 13
14043: PPUSH
14044: LD_STRING DF-2-Leg
14046: PPUSH
14047: CALL_OW 94
// DialogueOff ;
14051: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14055: LD_STRING QLegionOffer
14057: PPUSH
14058: CALL_OW 97
14062: PUSH
14063: LD_INT 1
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14074
14071: POP
// ; 2 :
14072: GO 14088
14074: LD_INT 2
14076: DOUBLE
14077: EQUAL
14078: IFTRUE 14082
14080: GO 14087
14082: POP
// exit ; end ;
14083: GO 14498
14085: GO 14088
14087: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14088: LD_EXP 9
14092: PPUSH
14093: LD_STRING D
14095: PUSH
14096: LD_STRING I
14098: PUSH
14099: LD_STRING J
14101: PUSH
14102: LD_STRING S
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PUSH
14110: LD_EXP 25
14114: ARRAY
14115: STR
14116: PUSH
14117: LD_STRING -2-Leg
14119: STR
14120: PPUSH
14121: CALL_OW 88
// legOfferAccepted := true ;
14125: LD_ADDR_EXP 20
14129: PUSH
14130: LD_INT 1
14132: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14133: LD_INT 21
14135: PPUSH
14136: LD_INT 1
14138: PPUSH
14139: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14143: LD_INT 190
14145: PPUSH
14146: LD_INT 227
14148: PPUSH
14149: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14153: LD_ADDR_VAR 0 1
14157: PUSH
14158: LD_INT 16800
14160: PUSH
14161: LD_INT 14700
14163: PUSH
14164: LD_INT 12600
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: LIST
14171: PUSH
14172: LD_OWVAR 67
14176: ARRAY
14177: ST_TO_ADDR
// sib := 100 ;
14178: LD_ADDR_VAR 0 2
14182: PUSH
14183: LD_INT 100
14185: ST_TO_ADDR
// disableGlobalTimer := true ;
14186: LD_ADDR_EXP 4
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14194: LD_INT 35
14196: PPUSH
14197: CALL_OW 67
// time := time - 0 0$1 ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_VAR 0 1
14210: PUSH
14211: LD_INT 35
14213: MINUS
14214: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14215: LD_ADDR_VAR 0 3
14219: PUSH
14220: LD_INT 21
14222: PPUSH
14223: LD_INT 3
14225: PPUSH
14226: CALL_OW 287
14230: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14231: LD_ADDR_OWVAR 47
14235: PUSH
14236: LD_STRING #SkrTime
14238: PUSH
14239: LD_OWVAR 1
14243: PUSH
14244: LD_STRING #Skr-LegOffer
14246: PUSH
14247: LD_VAR 0 2
14251: PUSH
14252: LD_VAR 0 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: ST_TO_ADDR
// if sources then
14264: LD_VAR 0 3
14268: IFFALSE 14300
// begin sib := sib - sources * 10 ;
14270: LD_ADDR_VAR 0 2
14274: PUSH
14275: LD_VAR 0 2
14279: PUSH
14280: LD_VAR 0 3
14284: PUSH
14285: LD_INT 10
14287: MUL
14288: MINUS
14289: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14290: LD_INT 21
14292: PPUSH
14293: LD_INT 3
14295: PPUSH
14296: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14300: LD_VAR 0 1
14304: PUSH
14305: LD_INT 0
14307: EQUAL
14308: PUSH
14309: LD_VAR 0 2
14313: PUSH
14314: LD_INT 0
14316: LESSEQUAL
14317: OR
14318: PUSH
14319: LD_INT 22
14321: PUSH
14322: LD_INT 8
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PPUSH
14329: CALL_OW 69
14333: NOT
14334: OR
14335: IFFALSE 14194
// SetAreaMapShow ( legOfferArea , 0 ) ;
14337: LD_INT 21
14339: PPUSH
14340: LD_INT 0
14342: PPUSH
14343: CALL_OW 424
// disableGlobalTimer := false ;
14347: LD_ADDR_EXP 4
14351: PUSH
14352: LD_INT 0
14354: ST_TO_ADDR
// if sib <= 0 then
14355: LD_VAR 0 2
14359: PUSH
14360: LD_INT 0
14362: LESSEQUAL
14363: IFFALSE 14479
// begin legChangeSide := true ;
14365: LD_ADDR_EXP 21
14369: PUSH
14370: LD_INT 1
14372: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14373: LD_EXP 13
14377: PPUSH
14378: LD_STRING DF-4y-Leg
14380: PPUSH
14381: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14385: LD_STRING O3a
14387: PPUSH
14388: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14392: LD_INT 8
14394: PPUSH
14395: LD_INT 1
14397: PPUSH
14398: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14402: LD_INT 8
14404: PPUSH
14405: LD_INT 1
14407: PPUSH
14408: LD_INT 1
14410: PPUSH
14411: LD_INT 1
14413: PPUSH
14414: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14418: LD_INT 8
14420: PPUSH
14421: LD_INT 4
14423: PPUSH
14424: LD_INT 1
14426: PPUSH
14427: LD_INT 1
14429: PPUSH
14430: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14434: LD_INT 8
14436: PPUSH
14437: LD_INT 6
14439: PPUSH
14440: LD_INT 2
14442: PPUSH
14443: LD_INT 1
14445: PPUSH
14446: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14450: LD_INT 8
14452: PPUSH
14453: LD_INT 3
14455: PPUSH
14456: LD_INT 2
14458: PPUSH
14459: LD_INT 1
14461: PPUSH
14462: CALL_OW 80
// wait ( 0 0$30 ) ;
14466: LD_INT 1050
14468: PPUSH
14469: CALL_OW 67
// PrepareLegionReinforcements ;
14473: CALL 10608 0 0
// end else
14477: GO 14498
// begin ChangeMissionObjectives ( O3a ) ;
14479: LD_STRING O3a
14481: PPUSH
14482: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14486: LD_EXP 13
14490: PPUSH
14491: LD_STRING DF-4n-Leg
14493: PPUSH
14494: CALL_OW 94
// end ; end ;
14498: PPOPN 4
14500: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14501: LD_INT 22
14503: PUSH
14504: LD_INT 8
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PPUSH
14525: CALL_OW 69
14529: PUSH
14530: LD_INT 0
14532: EQUAL
14533: PUSH
14534: LD_INT 8
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: CALL_OW 81
14544: PUSH
14545: LD_INT 2
14547: EQUAL
14548: AND
14549: IFFALSE 14561
14551: GO 14553
14553: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14554: LD_STRING O3a
14556: PPUSH
14557: CALL_OW 337
14561: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14562: LD_EXP 2
14566: PUSH
14567: LD_INT 1
14569: EQUAL
14570: PUSH
14571: LD_EXP 3
14575: AND
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 1
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_INT 0
14608: EQUAL
14609: AND
14610: PUSH
14611: LD_INT 22
14613: PUSH
14614: LD_INT 3
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 30
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: PUSH
14640: LD_INT 0
14642: EQUAL
14643: AND
14644: IFFALSE 14882
14646: GO 14648
14648: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14649: LD_EXP 9
14653: PPUSH
14654: LD_STRING D
14656: PUSH
14657: LD_STRING I
14659: PUSH
14660: LD_STRING J
14662: PUSH
14663: LD_STRING S
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: PUSH
14671: LD_EXP 25
14675: ARRAY
14676: STR
14677: PUSH
14678: LD_STRING -1-Win
14680: STR
14681: PPUSH
14682: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14686: LD_OWVAR 1
14690: PUSH
14691: LD_INT 315000
14693: PUSH
14694: LD_INT 273000
14696: PUSH
14697: LD_INT 231000
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: LIST
14704: PUSH
14705: LD_OWVAR 67
14709: ARRAY
14710: GREATEREQUAL
14711: IFFALSE 14726
// AddMedal ( med1 , - 1 ) else
14713: LD_STRING med1
14715: PPUSH
14716: LD_INT 1
14718: NEG
14719: PPUSH
14720: CALL_OW 101
14724: GO 14736
// AddMedal ( med1 , 1 ) ;
14726: LD_STRING med1
14728: PPUSH
14729: LD_INT 1
14731: PPUSH
14732: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14736: LD_EXP 22
14740: PUSH
14741: LD_INT 20
14743: PUSH
14744: LD_INT 15
14746: PUSH
14747: LD_INT 10
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: LIST
14754: PUSH
14755: LD_OWVAR 67
14759: ARRAY
14760: GREATEREQUAL
14761: IFFALSE 14776
// AddMedal ( med2 , - 1 ) else
14763: LD_STRING med2
14765: PPUSH
14766: LD_INT 1
14768: NEG
14769: PPUSH
14770: CALL_OW 101
14774: GO 14786
// AddMedal ( med2 , 1 ) ;
14776: LD_STRING med2
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14786: LD_INT 8
14788: PPUSH
14789: LD_INT 1
14791: PPUSH
14792: CALL_OW 81
14796: PUSH
14797: LD_INT 1
14799: EQUAL
14800: IFFALSE 14814
// AddMedal ( med3 , 1 ) else
14802: LD_STRING med3
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL_OW 101
14812: GO 14871
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14814: LD_INT 22
14816: PUSH
14817: LD_INT 8
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: PUSH
14824: LD_INT 21
14826: PUSH
14827: LD_INT 1
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: PPUSH
14838: CALL_OW 69
14842: PUSH
14843: LD_INT 0
14845: EQUAL
14846: IFFALSE 14860
// AddMedal ( med3 , 2 ) else
14848: LD_STRING med3
14850: PPUSH
14851: LD_INT 2
14853: PPUSH
14854: CALL_OW 101
14858: GO 14871
// AddMedal ( med3 , - 1 ) ;
14860: LD_STRING med3
14862: PPUSH
14863: LD_INT 1
14865: NEG
14866: PPUSH
14867: CALL_OW 101
// GiveMedals ( MAIN ) ;
14871: LD_STRING MAIN
14873: PPUSH
14874: CALL_OW 102
// YouWin ;
14878: CALL_OW 103
// end ;
14882: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14883: LD_EXP 2
14887: PUSH
14888: LD_INT 1
14890: EQUAL
14891: PUSH
14892: LD_EXP 16
14896: AND
14897: PUSH
14898: LD_INT 20
14900: PPUSH
14901: LD_INT 81
14903: PUSH
14904: LD_INT 8
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PPUSH
14911: CALL_OW 70
14915: AND
14916: IFFALSE 15195
14918: GO 14920
14920: DISABLE
14921: LD_INT 0
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
14927: PPUSH
// begin enable ;
14928: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14929: LD_ADDR_VAR 0 3
14933: PUSH
14934: LD_INT 20
14936: PPUSH
14937: LD_INT 81
14939: PUSH
14940: LD_INT 8
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL_OW 70
14951: ST_TO_ADDR
// if not tmp then
14952: LD_VAR 0 3
14956: NOT
14957: IFFALSE 14961
// exit ;
14959: GO 15195
// for i in tmp do
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_VAR 0 3
14970: PUSH
14971: FOR_IN
14972: IFFALSE 15193
// begin x := GetX ( i ) ;
14974: LD_ADDR_VAR 0 4
14978: PUSH
14979: LD_VAR 0 1
14983: PPUSH
14984: CALL_OW 250
14988: ST_TO_ADDR
// y := GetY ( i ) ;
14989: LD_ADDR_VAR 0 5
14993: PUSH
14994: LD_VAR 0 1
14998: PPUSH
14999: CALL_OW 251
15003: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15004: LD_VAR 0 4
15008: PPUSH
15009: LD_VAR 0 5
15013: PPUSH
15014: CALL_OW 458
15018: IFFALSE 15191
// begin LaunchMineAtPos ( x , y , 8 ) ;
15020: LD_VAR 0 4
15024: PPUSH
15025: LD_VAR 0 5
15029: PPUSH
15030: LD_INT 8
15032: PPUSH
15033: CALL_OW 456
// if not dialogueMineDetected then
15037: LD_EXP 28
15041: NOT
15042: IFFALSE 15103
// begin dialogueMineDetected := true ;
15044: LD_ADDR_EXP 28
15048: PUSH
15049: LD_INT 1
15051: ST_TO_ADDR
// CenterNowOnXY ( x , y ) ;
15052: LD_VAR 0 4
15056: PPUSH
15057: LD_VAR 0 5
15061: PPUSH
15062: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15066: LD_EXP 9
15070: PPUSH
15071: LD_STRING D
15073: PUSH
15074: LD_STRING I
15076: PUSH
15077: LD_STRING J
15079: PUSH
15080: LD_STRING S
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: LIST
15087: PUSH
15088: LD_EXP 25
15092: ARRAY
15093: STR
15094: PUSH
15095: LD_STRING -1-Mine
15097: STR
15098: PPUSH
15099: CALL_OW 88
// end ; for j = 1 to staticMines do
15103: LD_ADDR_VAR 0 2
15107: PUSH
15108: DOUBLE
15109: LD_INT 1
15111: DEC
15112: ST_TO_ADDR
15113: LD_EXP 16
15117: PUSH
15118: FOR_TO
15119: IFFALSE 15189
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15121: LD_EXP 16
15125: PUSH
15126: LD_VAR 0 2
15130: ARRAY
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 4
15140: EQUAL
15141: PUSH
15142: LD_EXP 16
15146: PUSH
15147: LD_VAR 0 2
15151: ARRAY
15152: PUSH
15153: LD_INT 2
15155: ARRAY
15156: PUSH
15157: LD_VAR 0 5
15161: EQUAL
15162: AND
15163: IFFALSE 15187
// begin staticMines := Delete ( staticMines , j ) ;
15165: LD_ADDR_EXP 16
15169: PUSH
15170: LD_EXP 16
15174: PPUSH
15175: LD_VAR 0 2
15179: PPUSH
15180: CALL_OW 3
15184: ST_TO_ADDR
// break ;
15185: GO 15189
// end ;
15187: GO 15118
15189: POP
15190: POP
// end ; end ;
15191: GO 14971
15193: POP
15194: POP
// end ;
15195: PPOPN 5
15197: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15198: LD_EXP 2
15202: PUSH
15203: LD_INT 1
15205: EQUAL
15206: PUSH
15207: LD_EXP 3
15211: AND
15212: PUSH
15213: LD_EXP 23
15217: AND
15218: PUSH
15219: LD_EXP 31
15223: PUSH
15224: LD_EXP 7
15228: ARRAY
15229: PPUSH
15230: LD_INT 30
15232: PUSH
15233: LD_INT 3
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 72
15244: AND
15245: IFFALSE 15449
15247: GO 15249
15249: DISABLE
15250: LD_INT 0
15252: PPUSH
15253: PPUSH
// begin enable ;
15254: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15255: LD_EXP 7
15259: PPUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 3
15265: PUSH
15266: LD_INT 3
15268: PUSH
15269: LD_INT 48
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: PUSH
15278: EMPTY
15279: LIST
15280: PPUSH
15281: CALL 85589 0 2
// repeat wait ( 0 0$1 ) ;
15285: LD_INT 35
15287: PPUSH
15288: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15292: LD_INT 22
15294: PUSH
15295: LD_INT 3
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: LD_INT 34
15304: PUSH
15305: LD_INT 48
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PPUSH
15316: CALL_OW 69
15320: IFFALSE 15285
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: LD_INT 22
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 34
15339: PUSH
15340: LD_INT 48
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: PPUSH
15351: CALL_OW 69
15355: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15356: LD_ADDR_VAR 0 2
15360: PUSH
15361: LD_INT 81
15363: PUSH
15364: LD_INT 3
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: LD_INT 21
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PPUSH
15385: CALL_OW 69
15389: ST_TO_ADDR
// if e then
15390: LD_VAR 0 2
15394: IFFALSE 15420
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15396: LD_ADDR_VAR 0 2
15400: PUSH
15401: LD_VAR 0 2
15405: PPUSH
15406: LD_VAR 0 1
15410: PUSH
15411: LD_INT 1
15413: ARRAY
15414: PPUSH
15415: CALL_OW 74
15419: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15420: LD_VAR 0 1
15424: PPUSH
15425: LD_VAR 0 2
15429: PPUSH
15430: CALL_OW 250
15434: PPUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: CALL_OW 251
15444: PPUSH
15445: CALL_OW 116
// end ;
15449: PPOPN 2
15451: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15452: LD_OWVAR 67
15456: PUSH
15457: LD_INT 1
15459: GREATER
15460: PUSH
15461: LD_EXP 31
15465: PUSH
15466: LD_EXP 7
15470: ARRAY
15471: PPUSH
15472: LD_INT 25
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 72
15486: AND
15487: PUSH
15488: LD_EXP 2
15492: PUSH
15493: LD_INT 1
15495: EQUAL
15496: AND
15497: PUSH
15498: LD_EXP 3
15502: AND
15503: PUSH
15504: LD_INT 23
15506: PPUSH
15507: LD_INT 3
15509: PPUSH
15510: CALL_OW 321
15514: PUSH
15515: LD_INT 2
15517: EQUAL
15518: AND
15519: IFFALSE 15646
15521: GO 15523
15523: DISABLE
15524: LD_INT 0
15526: PPUSH
15527: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15528: LD_ADDR_VAR 0 1
15532: PUSH
15533: LD_EXP 31
15537: PUSH
15538: LD_EXP 7
15542: ARRAY
15543: PPUSH
15544: LD_INT 25
15546: PUSH
15547: LD_INT 3
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 72
15558: ST_TO_ADDR
// if not tmp then
15559: LD_VAR 0 1
15563: NOT
15564: IFFALSE 15568
// exit ;
15566: GO 15646
// for i in tmp do
15568: LD_ADDR_VAR 0 2
15572: PUSH
15573: LD_VAR 0 1
15577: PUSH
15578: FOR_IN
15579: IFFALSE 15625
// begin SetTag ( i , 29 ) ;
15581: LD_VAR 0 2
15585: PPUSH
15586: LD_INT 29
15588: PPUSH
15589: CALL_OW 109
// ComExitBuilding ( i ) ;
15593: LD_VAR 0 2
15597: PPUSH
15598: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15602: LD_VAR 0 2
15606: PPUSH
15607: LD_INT 37
15609: PPUSH
15610: LD_INT 97
15612: PPUSH
15613: LD_INT 133
15615: PPUSH
15616: LD_INT 0
15618: PPUSH
15619: CALL_OW 230
// end ;
15623: GO 15578
15625: POP
15626: POP
// wait ( 1 1$00 ) ;
15627: LD_INT 2100
15629: PPUSH
15630: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15634: LD_EXP 7
15638: PPUSH
15639: LD_INT 29
15641: PPUSH
15642: CALL 65474 0 2
// end ;
15646: PPOPN 2
15648: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15649: LD_EXP 2
15653: PUSH
15654: LD_INT 1
15656: EQUAL
15657: PUSH
15658: LD_INT 84
15660: PPUSH
15661: LD_INT 128
15663: PPUSH
15664: CALL_OW 428
15668: PPUSH
15669: CALL_OW 266
15673: PUSH
15674: LD_INT 1
15676: EQUAL
15677: AND
15678: PUSH
15679: LD_INT 84
15681: PPUSH
15682: LD_INT 128
15684: PPUSH
15685: CALL_OW 428
15689: PPUSH
15690: CALL_OW 255
15694: PUSH
15695: LD_INT 3
15697: EQUAL
15698: AND
15699: IFFALSE 15872
15701: GO 15703
15703: DISABLE
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// begin enable ;
15708: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15709: LD_ADDR_VAR 0 2
15713: PUSH
15714: LD_INT 84
15716: PPUSH
15717: LD_INT 128
15719: PPUSH
15720: CALL_OW 428
15724: ST_TO_ADDR
// uc_side := 3 ;
15725: LD_ADDR_OWVAR 20
15729: PUSH
15730: LD_INT 3
15732: ST_TO_ADDR
// uc_nation := 3 ;
15733: LD_ADDR_OWVAR 21
15737: PUSH
15738: LD_INT 3
15740: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15741: LD_INT 21
15743: PPUSH
15744: LD_INT 3
15746: PPUSH
15747: LD_INT 3
15749: PPUSH
15750: LD_INT 51
15752: PPUSH
15753: LD_INT 0
15755: PPUSH
15756: CALL 24899 0 5
// veh := CreateVehicle ;
15760: LD_ADDR_VAR 0 1
15764: PUSH
15765: CALL_OW 45
15769: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_INT 126
15777: PPUSH
15778: LD_INT 227
15780: PPUSH
15781: LD_INT 0
15783: PPUSH
15784: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15788: LD_VAR 0 1
15792: PPUSH
15793: LD_INT 2
15795: PPUSH
15796: LD_INT 100
15798: PPUSH
15799: CALL_OW 290
// ComGive ( veh , depot ) ;
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_VAR 0 2
15812: PPUSH
15813: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15817: LD_VAR 0 1
15821: PPUSH
15822: LD_INT 126
15824: PPUSH
15825: LD_INT 227
15827: PPUSH
15828: CALL_OW 171
// wait ( 0 0$10 ) ;
15832: LD_INT 350
15834: PPUSH
15835: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15839: LD_INT 35
15841: PPUSH
15842: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15846: LD_VAR 0 1
15850: PPUSH
15851: LD_INT 126
15853: PPUSH
15854: LD_INT 227
15856: PPUSH
15857: CALL_OW 307
15861: IFFALSE 15839
// RemoveUnit ( veh ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 64
// end ;
15872: PPOPN 2
15874: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15875: LD_EXP 2
15879: PUSH
15880: LD_INT 1
15882: EQUAL
15883: PUSH
15884: LD_EXP 27
15888: AND
15889: PUSH
15890: LD_EXP 25
15894: PUSH
15895: LD_INT 2
15897: EQUAL
15898: AND
15899: IFFALSE 16091
15901: GO 15903
15903: DISABLE
15904: LD_INT 0
15906: PPUSH
15907: PPUSH
// begin enable ;
15908: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15909: LD_OWVAR 1
15913: PUSH
15914: LD_INT 105000
15916: PUSH
15917: LD_INT 84000
15919: PUSH
15920: LD_INT 63000
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: LIST
15927: PUSH
15928: LD_OWVAR 67
15932: ARRAY
15933: GREATEREQUAL
15934: IFFALSE 15937
// disable ;
15936: DISABLE
// uc_side := 4 ;
15937: LD_ADDR_OWVAR 20
15941: PUSH
15942: LD_INT 4
15944: ST_TO_ADDR
// uc_nation := 1 ;
15945: LD_ADDR_OWVAR 21
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15953: LD_INT 2
15955: PPUSH
15956: LD_INT 3
15958: PPUSH
15959: LD_INT 3
15961: PPUSH
15962: LD_INT 12
15964: PPUSH
15965: LD_INT 0
15967: PPUSH
15968: CALL 24899 0 5
// veh := CreateVehicle ;
15972: LD_ADDR_VAR 0 1
15976: PUSH
15977: CALL_OW 45
15981: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 229
15989: PPUSH
15990: LD_INT 226
15992: PPUSH
15993: LD_INT 0
15995: PPUSH
15996: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16000: LD_VAR 0 1
16004: PPUSH
16005: LD_INT 1
16007: PPUSH
16008: LD_INT 100
16010: PPUSH
16011: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16015: LD_VAR 0 1
16019: PPUSH
16020: LD_INT 25
16022: PPUSH
16023: CALL_OW 173
// AddComUnload ( veh ) ;
16027: LD_VAR 0 1
16031: PPUSH
16032: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_INT 229
16043: PPUSH
16044: LD_INT 226
16046: PPUSH
16047: CALL_OW 171
// wait ( 0 0$10 ) ;
16051: LD_INT 350
16053: PPUSH
16054: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16058: LD_INT 35
16060: PPUSH
16061: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16065: LD_VAR 0 1
16069: PPUSH
16070: LD_INT 229
16072: PPUSH
16073: LD_INT 226
16075: PPUSH
16076: CALL_OW 307
16080: IFFALSE 16058
// RemoveUnit ( veh ) ;
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 64
// end ;
16091: PPOPN 2
16093: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16094: LD_EXP 2
16098: PUSH
16099: LD_INT 1
16101: EQUAL
16102: PUSH
16103: LD_EXP 3
16107: AND
16108: PUSH
16109: LD_EXP 24
16113: AND
16114: IFFALSE 16447
16116: GO 16118
16118: DISABLE
16119: LD_INT 0
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
16125: PPUSH
// begin enable ;
16126: ENABLE
// tmp := [ ] ;
16127: LD_ADDR_VAR 0 4
16131: PUSH
16132: EMPTY
16133: ST_TO_ADDR
// if commander = 1 then
16134: LD_EXP 25
16138: PUSH
16139: LD_INT 1
16141: EQUAL
16142: IFFALSE 16154
// amount := 3 else
16144: LD_ADDR_VAR 0 5
16148: PUSH
16149: LD_INT 3
16151: ST_TO_ADDR
16152: GO 16162
// amount := 2 ;
16154: LD_ADDR_VAR 0 5
16158: PUSH
16159: LD_INT 2
16161: ST_TO_ADDR
// for i = 1 to amount do
16162: LD_ADDR_VAR 0 1
16166: PUSH
16167: DOUBLE
16168: LD_INT 1
16170: DEC
16171: ST_TO_ADDR
16172: LD_VAR 0 5
16176: PUSH
16177: FOR_TO
16178: IFFALSE 16342
// begin wait ( 0 0$5 ) ;
16180: LD_INT 175
16182: PPUSH
16183: CALL_OW 67
// for j = 1 to 3 do
16187: LD_ADDR_VAR 0 2
16191: PUSH
16192: DOUBLE
16193: LD_INT 1
16195: DEC
16196: ST_TO_ADDR
16197: LD_INT 3
16199: PUSH
16200: FOR_TO
16201: IFFALSE 16338
// begin uc_side := 4 ;
16203: LD_ADDR_OWVAR 20
16207: PUSH
16208: LD_INT 4
16210: ST_TO_ADDR
// uc_nation := 1 ;
16211: LD_ADDR_OWVAR 21
16215: PUSH
16216: LD_INT 1
16218: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16219: LD_INT 3
16221: PUSH
16222: LD_INT 5
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PUSH
16229: LD_INT 1
16231: PPUSH
16232: LD_INT 2
16234: PPUSH
16235: CALL_OW 12
16239: ARRAY
16240: PPUSH
16241: LD_INT 3
16243: PPUSH
16244: LD_INT 3
16246: PPUSH
16247: LD_INT 9
16249: PUSH
16250: LD_INT 5
16252: PUSH
16253: LD_INT 7
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: PUSH
16261: LD_INT 1
16263: PPUSH
16264: LD_INT 3
16266: PPUSH
16267: CALL_OW 12
16271: ARRAY
16272: PPUSH
16273: LD_INT 100
16275: PPUSH
16276: CALL 24899 0 5
// veh := CreateVehicle ;
16280: LD_ADDR_VAR 0 3
16284: PUSH
16285: CALL_OW 45
16289: ST_TO_ADDR
// tmp := tmp ^ veh ;
16290: LD_ADDR_VAR 0 4
16294: PUSH
16295: LD_VAR 0 4
16299: PUSH
16300: LD_VAR 0 3
16304: ADD
16305: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16306: LD_VAR 0 3
16310: PPUSH
16311: LD_INT 22
16313: PPUSH
16314: LD_INT 0
16316: PPUSH
16317: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16321: LD_VAR 0 3
16325: PPUSH
16326: LD_INT 119
16328: PPUSH
16329: LD_INT 215
16331: PPUSH
16332: CALL_OW 111
// end ;
16336: GO 16200
16338: POP
16339: POP
// end ;
16340: GO 16177
16342: POP
16343: POP
// wait ( 0 0$3 ) ;
16344: LD_INT 105
16346: PPUSH
16347: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16351: LD_INT 35
16353: PPUSH
16354: CALL_OW 67
// for i in tmp do
16358: LD_ADDR_VAR 0 1
16362: PUSH
16363: LD_VAR 0 4
16367: PUSH
16368: FOR_IN
16369: IFFALSE 16436
// if IsDead ( i ) then
16371: LD_VAR 0 1
16375: PPUSH
16376: CALL_OW 301
16380: IFFALSE 16400
// tmp := tmp diff i else
16382: LD_ADDR_VAR 0 4
16386: PUSH
16387: LD_VAR 0 4
16391: PUSH
16392: LD_VAR 0 1
16396: DIFF
16397: ST_TO_ADDR
16398: GO 16434
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_INT 81
16407: PUSH
16408: LD_INT 4
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL_OW 69
16419: PPUSH
16420: LD_VAR 0 1
16424: PPUSH
16425: CALL_OW 74
16429: PPUSH
16430: CALL_OW 115
16434: GO 16368
16436: POP
16437: POP
// until tmp = [ ] ;
16438: LD_VAR 0 4
16442: PUSH
16443: EMPTY
16444: EQUAL
16445: IFFALSE 16351
// end ;
16447: PPOPN 5
16449: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16450: LD_EXP 2
16454: PUSH
16455: LD_INT 1
16457: EQUAL
16458: PUSH
16459: LD_EXP 3
16463: AND
16464: IFFALSE 16565
16466: GO 16468
16468: DISABLE
16469: LD_INT 0
16471: PPUSH
16472: PPUSH
// begin enable ;
16473: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16474: LD_ADDR_VAR 0 2
16478: PUSH
16479: LD_INT 3
16481: PUSH
16482: LD_INT 22
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 32
16498: PUSH
16499: LD_INT 1
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PPUSH
16510: CALL_OW 69
16514: ST_TO_ADDR
// if tmp then
16515: LD_VAR 0 2
16519: IFFALSE 16565
// for i in tmp do
16521: LD_ADDR_VAR 0 1
16525: PUSH
16526: LD_VAR 0 2
16530: PUSH
16531: FOR_IN
16532: IFFALSE 16563
// if GetFuel ( i ) < 3 then
16534: LD_VAR 0 1
16538: PPUSH
16539: CALL_OW 261
16543: PUSH
16544: LD_INT 3
16546: LESS
16547: IFFALSE 16561
// SetFuel ( i , 3 ) ;
16549: LD_VAR 0 1
16553: PPUSH
16554: LD_INT 3
16556: PPUSH
16557: CALL_OW 240
16561: GO 16531
16563: POP
16564: POP
// end ;
16565: PPOPN 2
16567: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16568: LD_EXP 3
16572: PUSH
16573: LD_INT 8
16575: PPUSH
16576: LD_INT 4
16578: PPUSH
16579: CALL_OW 81
16583: PUSH
16584: LD_INT 2
16586: EQUAL
16587: AND
16588: IFFALSE 16798
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin enable ;
16598: ENABLE
// tmp := [ ] ;
16599: LD_ADDR_VAR 0 3
16603: PUSH
16604: EMPTY
16605: ST_TO_ADDR
// for i = 1 to 4 do
16606: LD_ADDR_VAR 0 1
16610: PUSH
16611: DOUBLE
16612: LD_INT 1
16614: DEC
16615: ST_TO_ADDR
16616: LD_INT 4
16618: PUSH
16619: FOR_TO
16620: IFFALSE 16764
// begin uc_side := 8 ;
16622: LD_ADDR_OWVAR 20
16626: PUSH
16627: LD_INT 8
16629: ST_TO_ADDR
// uc_nation := nation_arabian ;
16630: LD_ADDR_OWVAR 21
16634: PUSH
16635: LD_INT 2
16637: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16638: LD_INT 11
16640: PPUSH
16641: LD_INT 1
16643: PPUSH
16644: LD_INT 5
16646: PPUSH
16647: LD_INT 24
16649: PUSH
16650: LD_INT 23
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PUSH
16657: LD_INT 1
16659: PPUSH
16660: LD_INT 2
16662: PPUSH
16663: CALL_OW 12
16667: ARRAY
16668: PPUSH
16669: LD_INT 60
16671: PPUSH
16672: LD_INT 80
16674: PPUSH
16675: CALL_OW 12
16679: PPUSH
16680: CALL 24899 0 5
// un := CreateVehicle ;
16684: LD_ADDR_VAR 0 2
16688: PUSH
16689: CALL_OW 45
16693: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16694: LD_VAR 0 2
16698: PPUSH
16699: LD_INT 2
16701: PPUSH
16702: CALL_OW 233
// tmp := tmp ^ un ;
16706: LD_ADDR_VAR 0 3
16710: PUSH
16711: LD_VAR 0 3
16715: PUSH
16716: LD_VAR 0 2
16720: ADD
16721: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16722: LD_VAR 0 2
16726: PPUSH
16727: LD_INT 88
16729: PPUSH
16730: LD_INT 2
16732: PPUSH
16733: LD_INT 0
16735: PPUSH
16736: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16740: LD_VAR 0 2
16744: PPUSH
16745: LD_INT 93
16747: PPUSH
16748: LD_INT 13
16750: PPUSH
16751: CALL_OW 111
// wait ( 0 0$2 ) ;
16755: LD_INT 70
16757: PPUSH
16758: CALL_OW 67
// end ;
16762: GO 16619
16764: POP
16765: POP
// for i in tmp do
16766: LD_ADDR_VAR 0 1
16770: PUSH
16771: LD_VAR 0 3
16775: PUSH
16776: FOR_IN
16777: IFFALSE 16796
// AddComMoveXY ( i , 136 , 19 ) ;
16779: LD_VAR 0 1
16783: PPUSH
16784: LD_INT 136
16786: PPUSH
16787: LD_INT 19
16789: PPUSH
16790: CALL_OW 171
16794: GO 16776
16796: POP
16797: POP
// end ;
16798: PPOPN 3
16800: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16801: LD_EXP 3
16805: IFFALSE 17724
16807: GO 16809
16809: DISABLE
16810: LD_INT 0
16812: PPUSH
16813: PPUSH
16814: PPUSH
16815: PPUSH
// begin enable ;
16816: ENABLE
// base := mc_leg ;
16817: LD_ADDR_VAR 0 2
16821: PUSH
16822: LD_EXP 6
16826: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16827: LD_INT 22
16829: PUSH
16830: LD_INT 8
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 23
16839: PUSH
16840: LD_INT 2
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 3
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 69
16866: NOT
16867: IFFALSE 16871
// exit ;
16869: GO 17724
// if Prob ( 40 ) then
16871: LD_INT 40
16873: PPUSH
16874: CALL_OW 13
16878: IFFALSE 17007
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16880: LD_VAR 0 2
16884: PPUSH
16885: LD_INT 13
16887: PUSH
16888: LD_INT 1
16890: PUSH
16891: LD_INT 2
16893: PUSH
16894: LD_INT 28
16896: PUSH
16897: EMPTY
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 13
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 28
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: PUSH
16921: LD_INT 13
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: LD_INT 2
16929: PUSH
16930: LD_INT 28
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 13
16941: PUSH
16942: LD_INT 1
16944: PUSH
16945: LD_INT 2
16947: PUSH
16948: LD_INT 28
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 13
16959: PUSH
16960: LD_INT 1
16962: PUSH
16963: LD_INT 2
16965: PUSH
16966: LD_INT 28
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: PUSH
16975: LD_INT 13
16977: PUSH
16978: LD_INT 1
16980: PUSH
16981: LD_INT 2
16983: PUSH
16984: LD_INT 26
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: PPUSH
17001: CALL 85589 0 2
// end else
17005: GO 17224
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17007: LD_VAR 0 2
17011: PPUSH
17012: LD_INT 13
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: LD_INT 2
17020: PUSH
17021: LD_INT 27
17023: PUSH
17024: LD_INT 26
17026: PUSH
17027: LD_INT 26
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 1
17037: PPUSH
17038: LD_INT 3
17040: PPUSH
17041: CALL_OW 12
17045: ARRAY
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: PUSH
17053: LD_INT 13
17055: PUSH
17056: LD_INT 1
17058: PUSH
17059: LD_INT 2
17061: PUSH
17062: LD_INT 27
17064: PUSH
17065: LD_INT 26
17067: PUSH
17068: LD_INT 26
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 3
17081: PPUSH
17082: CALL_OW 12
17086: ARRAY
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 13
17096: PUSH
17097: LD_INT 1
17099: PUSH
17100: LD_INT 2
17102: PUSH
17103: LD_INT 26
17105: PUSH
17106: LD_INT 26
17108: PUSH
17109: LD_INT 29
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 1
17119: PPUSH
17120: LD_INT 3
17122: PPUSH
17123: CALL_OW 12
17127: ARRAY
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 13
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: LD_INT 2
17143: PUSH
17144: LD_INT 26
17146: PUSH
17147: LD_INT 29
17149: PUSH
17150: LD_INT 29
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: LIST
17157: PUSH
17158: LD_INT 1
17160: PPUSH
17161: LD_INT 3
17163: PPUSH
17164: CALL_OW 12
17168: ARRAY
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: PUSH
17176: LD_INT 13
17178: PUSH
17179: LD_INT 1
17181: PUSH
17182: LD_INT 2
17184: PUSH
17185: LD_INT 29
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 13
17196: PUSH
17197: LD_INT 1
17199: PUSH
17200: LD_INT 2
17202: PUSH
17203: LD_INT 26
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: PPUSH
17220: CALL 85589 0 2
// end ; repeat wait ( 0 0$1 ) ;
17224: LD_INT 35
17226: PPUSH
17227: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17231: LD_VAR 0 2
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: CALL 87007 0 2
17243: PUSH
17244: LD_INT 6
17246: GREATEREQUAL
17247: PUSH
17248: LD_OWVAR 1
17252: PUSH
17253: LD_INT 21000
17255: MOD
17256: PUSH
17257: LD_INT 0
17259: EQUAL
17260: OR
17261: IFFALSE 17224
// wait ( 0 0$30 ) ;
17263: LD_INT 1050
17265: PPUSH
17266: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17270: LD_ADDR_VAR 0 3
17274: PUSH
17275: LD_VAR 0 2
17279: PPUSH
17280: LD_INT 1
17282: PPUSH
17283: CALL 87007 0 2
17287: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17288: LD_ADDR_EXP 50
17292: PUSH
17293: LD_EXP 50
17297: PPUSH
17298: LD_VAR 0 2
17302: PPUSH
17303: LD_EXP 50
17307: PUSH
17308: LD_VAR 0 2
17312: ARRAY
17313: PUSH
17314: LD_VAR 0 3
17318: DIFF
17319: PPUSH
17320: CALL_OW 1
17324: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17325: LD_ADDR_VAR 0 4
17329: PUSH
17330: LD_INT 0
17332: PPUSH
17333: LD_INT 2
17335: PPUSH
17336: CALL_OW 12
17340: ST_TO_ADDR
// if legChangeSide then
17341: LD_EXP 21
17345: IFFALSE 17355
// target := 2 ;
17347: LD_ADDR_VAR 0 4
17351: PUSH
17352: LD_INT 2
17354: ST_TO_ADDR
// if target = 2 then
17355: LD_VAR 0 4
17359: PUSH
17360: LD_INT 2
17362: EQUAL
17363: IFFALSE 17491
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_VAR 0 3
17374: PPUSH
17375: LD_INT 24
17377: PUSH
17378: LD_INT 250
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: PPUSH
17385: CALL_OW 72
17389: ST_TO_ADDR
// for i in tmp do
17390: LD_ADDR_VAR 0 1
17394: PUSH
17395: LD_VAR 0 3
17399: PUSH
17400: FOR_IN
17401: IFFALSE 17441
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17403: LD_VAR 0 1
17407: PPUSH
17408: LD_INT 112
17410: PPUSH
17411: LD_INT 64
17413: PPUSH
17414: CALL_OW 297
17418: PUSH
17419: LD_INT 9
17421: GREATER
17422: IFFALSE 17439
// ComMoveXY ( i , 112 , 64 ) ;
17424: LD_VAR 0 1
17428: PPUSH
17429: LD_INT 112
17431: PPUSH
17432: LD_INT 64
17434: PPUSH
17435: CALL_OW 111
17439: GO 17400
17441: POP
17442: POP
// wait ( 0 0$1 ) ;
17443: LD_INT 35
17445: PPUSH
17446: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17450: LD_VAR 0 3
17454: PPUSH
17455: LD_INT 92
17457: PUSH
17458: LD_INT 112
17460: PUSH
17461: LD_INT 64
17463: PUSH
17464: LD_INT 9
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: LIST
17472: PPUSH
17473: CALL_OW 72
17477: PUSH
17478: LD_VAR 0 3
17482: PUSH
17483: LD_INT 1
17485: MINUS
17486: GREATEREQUAL
17487: IFFALSE 17365
// end else
17489: GO 17615
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17491: LD_ADDR_VAR 0 3
17495: PUSH
17496: LD_VAR 0 3
17500: PPUSH
17501: LD_INT 24
17503: PUSH
17504: LD_INT 250
17506: PUSH
17507: EMPTY
17508: LIST
17509: LIST
17510: PPUSH
17511: CALL_OW 72
17515: ST_TO_ADDR
// for i in tmp do
17516: LD_ADDR_VAR 0 1
17520: PUSH
17521: LD_VAR 0 3
17525: PUSH
17526: FOR_IN
17527: IFFALSE 17567
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17529: LD_VAR 0 1
17533: PPUSH
17534: LD_INT 174
17536: PPUSH
17537: LD_INT 94
17539: PPUSH
17540: CALL_OW 297
17544: PUSH
17545: LD_INT 9
17547: GREATER
17548: IFFALSE 17565
// ComMoveXY ( i , 174 , 94 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 174
17557: PPUSH
17558: LD_INT 94
17560: PPUSH
17561: CALL_OW 111
17565: GO 17526
17567: POP
17568: POP
// wait ( 0 0$1 ) ;
17569: LD_INT 35
17571: PPUSH
17572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17576: LD_VAR 0 3
17580: PPUSH
17581: LD_INT 92
17583: PUSH
17584: LD_INT 174
17586: PUSH
17587: LD_INT 94
17589: PUSH
17590: LD_INT 9
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: PPUSH
17599: CALL_OW 72
17603: PUSH
17604: LD_VAR 0 3
17608: PUSH
17609: LD_INT 1
17611: MINUS
17612: GREATEREQUAL
17613: IFFALSE 17491
// end ; repeat wait ( 0 0$1 ) ;
17615: LD_INT 35
17617: PPUSH
17618: CALL_OW 67
// for i in tmp do
17622: LD_ADDR_VAR 0 1
17626: PUSH
17627: LD_VAR 0 3
17631: PUSH
17632: FOR_IN
17633: IFFALSE 17715
// begin if GetLives ( i ) > 251 then
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL_OW 256
17644: PUSH
17645: LD_INT 251
17647: GREATER
17648: IFFALSE 17686
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17650: LD_VAR 0 1
17654: PPUSH
17655: LD_INT 81
17657: PUSH
17658: LD_INT 8
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: PPUSH
17665: CALL_OW 69
17669: PPUSH
17670: LD_VAR 0 1
17674: PPUSH
17675: CALL_OW 74
17679: PPUSH
17680: CALL_OW 115
17684: GO 17713
// if IsDead ( i ) then
17686: LD_VAR 0 1
17690: PPUSH
17691: CALL_OW 301
17695: IFFALSE 17713
// tmp := tmp diff i ;
17697: LD_ADDR_VAR 0 3
17701: PUSH
17702: LD_VAR 0 3
17706: PUSH
17707: LD_VAR 0 1
17711: DIFF
17712: ST_TO_ADDR
// end ;
17713: GO 17632
17715: POP
17716: POP
// until not tmp ;
17717: LD_VAR 0 3
17721: NOT
17722: IFFALSE 17615
// end ;
17724: PPOPN 4
17726: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17727: LD_EXP 3
17731: IFFALSE 18719
17733: GO 17735
17735: DISABLE
17736: LD_INT 0
17738: PPUSH
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
// begin enable ;
17743: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17744: LD_EXP 31
17748: PUSH
17749: LD_EXP 8
17753: ARRAY
17754: PPUSH
17755: LD_INT 22
17757: PUSH
17758: LD_INT 3
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 3
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: PPUSH
17779: CALL_OW 72
17783: NOT
17784: IFFALSE 17788
// exit ;
17786: GO 18719
// base := mc_rus_2 ;
17788: LD_ADDR_VAR 0 2
17792: PUSH
17793: LD_EXP 8
17797: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17798: LD_ADDR_VAR 0 5
17802: PUSH
17803: LD_INT 22
17805: PUSH
17806: LD_INT 3
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: PUSH
17813: LD_INT 30
17815: PUSH
17816: LD_INT 34
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: PPUSH
17827: CALL_OW 69
17831: ST_TO_ADDR
// if Prob ( 40 ) then
17832: LD_INT 40
17834: PPUSH
17835: CALL_OW 13
17839: IFFALSE 17968
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17841: LD_VAR 0 2
17845: PPUSH
17846: LD_INT 22
17848: PUSH
17849: LD_INT 3
17851: PUSH
17852: LD_INT 3
17854: PUSH
17855: LD_INT 49
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: PUSH
17864: LD_INT 22
17866: PUSH
17867: LD_INT 3
17869: PUSH
17870: LD_INT 3
17872: PUSH
17873: LD_INT 49
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: PUSH
17882: LD_INT 22
17884: PUSH
17885: LD_INT 3
17887: PUSH
17888: LD_INT 3
17890: PUSH
17891: LD_INT 49
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 24
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: LD_INT 46
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: LIST
17916: LIST
17917: PUSH
17918: LD_INT 24
17920: PUSH
17921: LD_INT 3
17923: PUSH
17924: LD_INT 3
17926: PUSH
17927: LD_INT 46
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: LIST
17934: LIST
17935: PUSH
17936: LD_INT 24
17938: PUSH
17939: LD_INT 3
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 46
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: PPUSH
17962: CALL 85589 0 2
// end else
17966: GO 18093
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17968: LD_VAR 0 2
17972: PPUSH
17973: LD_INT 24
17975: PUSH
17976: LD_INT 3
17978: PUSH
17979: LD_INT 3
17981: PUSH
17982: LD_INT 47
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: PUSH
17991: LD_INT 24
17993: PUSH
17994: LD_INT 3
17996: PUSH
17997: LD_INT 3
17999: PUSH
18000: LD_INT 47
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 24
18011: PUSH
18012: LD_INT 3
18014: PUSH
18015: LD_INT 3
18017: PUSH
18018: LD_INT 47
18020: PUSH
18021: EMPTY
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 24
18029: PUSH
18030: LD_INT 3
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: LD_INT 46
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 24
18047: PUSH
18048: LD_INT 3
18050: PUSH
18051: LD_INT 3
18053: PUSH
18054: LD_INT 46
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: PUSH
18063: LD_INT 24
18065: PUSH
18066: LD_INT 3
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 46
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: PPUSH
18089: CALL 85589 0 2
// end ; if Difficulty > 1 then
18093: LD_OWVAR 67
18097: PUSH
18098: LD_INT 1
18100: GREATER
18101: IFFALSE 18133
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18103: LD_VAR 0 2
18107: PPUSH
18108: LD_INT 24
18110: PUSH
18111: LD_INT 3
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 47
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: PPUSH
18129: CALL 85589 0 2
// repeat wait ( 0 0$1 ) ;
18133: LD_INT 35
18135: PPUSH
18136: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18140: LD_VAR 0 2
18144: PPUSH
18145: LD_INT 1
18147: PPUSH
18148: CALL 87007 0 2
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 7
18158: PUSH
18159: LD_INT 7
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: PUSH
18167: LD_OWVAR 67
18171: ARRAY
18172: GREATEREQUAL
18173: PUSH
18174: LD_OWVAR 1
18178: PUSH
18179: LD_INT 21000
18181: MOD
18182: PUSH
18183: LD_INT 0
18185: EQUAL
18186: OR
18187: IFFALSE 18133
// wait ( 0 0$45 ) ;
18189: LD_INT 1575
18191: PPUSH
18192: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_VAR 0 2
18205: PPUSH
18206: LD_INT 1
18208: PPUSH
18209: CALL 87007 0 2
18213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18214: LD_ADDR_EXP 50
18218: PUSH
18219: LD_EXP 50
18223: PPUSH
18224: LD_VAR 0 2
18228: PPUSH
18229: LD_EXP 50
18233: PUSH
18234: LD_VAR 0 2
18238: ARRAY
18239: PUSH
18240: LD_VAR 0 3
18244: DIFF
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18251: LD_ADDR_VAR 0 4
18255: PUSH
18256: LD_INT 0
18258: PPUSH
18259: LD_INT 1
18261: PPUSH
18262: CALL_OW 12
18266: ST_TO_ADDR
// if target then
18267: LD_VAR 0 4
18271: IFFALSE 18399
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18273: LD_ADDR_VAR 0 3
18277: PUSH
18278: LD_VAR 0 3
18282: PPUSH
18283: LD_INT 24
18285: PUSH
18286: LD_INT 250
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 72
18297: ST_TO_ADDR
// for i in tmp do
18298: LD_ADDR_VAR 0 1
18302: PUSH
18303: LD_VAR 0 3
18307: PUSH
18308: FOR_IN
18309: IFFALSE 18349
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18311: LD_VAR 0 1
18315: PPUSH
18316: LD_INT 84
18318: PPUSH
18319: LD_INT 32
18321: PPUSH
18322: CALL_OW 297
18326: PUSH
18327: LD_INT 9
18329: GREATER
18330: IFFALSE 18347
// ComMoveXY ( i , 84 , 32 ) ;
18332: LD_VAR 0 1
18336: PPUSH
18337: LD_INT 84
18339: PPUSH
18340: LD_INT 32
18342: PPUSH
18343: CALL_OW 111
18347: GO 18308
18349: POP
18350: POP
// wait ( 0 0$1 ) ;
18351: LD_INT 35
18353: PPUSH
18354: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18358: LD_VAR 0 3
18362: PPUSH
18363: LD_INT 92
18365: PUSH
18366: LD_INT 84
18368: PUSH
18369: LD_INT 32
18371: PUSH
18372: LD_INT 9
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: PPUSH
18381: CALL_OW 72
18385: PUSH
18386: LD_VAR 0 3
18390: PUSH
18391: LD_INT 1
18393: MINUS
18394: GREATEREQUAL
18395: IFFALSE 18273
// end else
18397: GO 18559
// begin if teleport then
18399: LD_VAR 0 5
18403: IFFALSE 18423
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18405: LD_VAR 0 3
18409: PPUSH
18410: LD_VAR 0 5
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18423: LD_ADDR_VAR 0 3
18427: PUSH
18428: LD_VAR 0 3
18432: PPUSH
18433: LD_INT 24
18435: PUSH
18436: LD_INT 250
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: PPUSH
18443: CALL_OW 72
18447: ST_TO_ADDR
// for i in tmp do
18448: LD_ADDR_VAR 0 1
18452: PUSH
18453: LD_VAR 0 3
18457: PUSH
18458: FOR_IN
18459: IFFALSE 18511
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 140
18468: PPUSH
18469: LD_INT 219
18471: PPUSH
18472: CALL_OW 297
18476: PUSH
18477: LD_INT 9
18479: GREATER
18480: PUSH
18481: LD_VAR 0 1
18485: PPUSH
18486: CALL_OW 314
18490: NOT
18491: AND
18492: IFFALSE 18509
// AddComMoveXY ( i , 140 , 219 ) ;
18494: LD_VAR 0 1
18498: PPUSH
18499: LD_INT 140
18501: PPUSH
18502: LD_INT 219
18504: PPUSH
18505: CALL_OW 171
18509: GO 18458
18511: POP
18512: POP
// wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_INT 92
18527: PUSH
18528: LD_INT 140
18530: PUSH
18531: LD_INT 219
18533: PUSH
18534: LD_INT 9
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 72
18547: PUSH
18548: LD_VAR 0 3
18552: PUSH
18553: LD_INT 1
18555: MINUS
18556: GREATEREQUAL
18557: IFFALSE 18423
// end ; repeat wait ( 0 0$1 ) ;
18559: LD_INT 35
18561: PPUSH
18562: CALL_OW 67
// for i in tmp do
18566: LD_ADDR_VAR 0 1
18570: PUSH
18571: LD_VAR 0 3
18575: PUSH
18576: FOR_IN
18577: IFFALSE 18710
// begin if GetLives ( i ) > 251 then
18579: LD_VAR 0 1
18583: PPUSH
18584: CALL_OW 256
18588: PUSH
18589: LD_INT 251
18591: GREATER
18592: IFFALSE 18681
// begin if GetWeapon ( i ) = ru_time_lapser then
18594: LD_VAR 0 1
18598: PPUSH
18599: CALL_OW 264
18603: PUSH
18604: LD_INT 49
18606: EQUAL
18607: IFFALSE 18645
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18609: LD_VAR 0 1
18613: PPUSH
18614: LD_INT 81
18616: PUSH
18617: LD_INT 3
18619: PUSH
18620: EMPTY
18621: LIST
18622: LIST
18623: PPUSH
18624: CALL_OW 69
18628: PPUSH
18629: LD_VAR 0 1
18633: PPUSH
18634: CALL_OW 74
18638: PPUSH
18639: CALL_OW 112
18643: GO 18679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18645: LD_VAR 0 1
18649: PPUSH
18650: LD_INT 81
18652: PUSH
18653: LD_INT 3
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL_OW 69
18664: PPUSH
18665: LD_VAR 0 1
18669: PPUSH
18670: CALL_OW 74
18674: PPUSH
18675: CALL_OW 115
// end else
18679: GO 18708
// if IsDead ( i ) then
18681: LD_VAR 0 1
18685: PPUSH
18686: CALL_OW 301
18690: IFFALSE 18708
// tmp := tmp diff i ;
18692: LD_ADDR_VAR 0 3
18696: PUSH
18697: LD_VAR 0 3
18701: PUSH
18702: LD_VAR 0 1
18706: DIFF
18707: ST_TO_ADDR
// end ;
18708: GO 18576
18710: POP
18711: POP
// until not tmp ;
18712: LD_VAR 0 3
18716: NOT
18717: IFFALSE 18559
// end ;
18719: PPOPN 5
18721: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18722: LD_EXP 3
18726: IFFALSE 19108
18728: GO 18730
18730: DISABLE
18731: LD_INT 0
18733: PPUSH
18734: PPUSH
18735: PPUSH
18736: PPUSH
// begin enable ;
18737: ENABLE
// base := mc_amer ;
18738: LD_ADDR_VAR 0 2
18742: PUSH
18743: LD_EXP 5
18747: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18748: LD_INT 22
18750: PUSH
18751: LD_INT 4
18753: PUSH
18754: EMPTY
18755: LIST
18756: LIST
18757: PUSH
18758: LD_INT 23
18760: PUSH
18761: LD_INT 1
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 3
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL_OW 69
18787: NOT
18788: IFFALSE 18792
// exit ;
18790: GO 19108
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18792: LD_VAR 0 2
18796: PPUSH
18797: LD_INT 3
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 5
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 3
18817: PUSH
18818: LD_INT 1
18820: PUSH
18821: LD_INT 2
18823: PUSH
18824: LD_INT 9
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: LIST
18831: LIST
18832: PUSH
18833: LD_INT 3
18835: PUSH
18836: LD_INT 1
18838: PUSH
18839: LD_INT 2
18841: PUSH
18842: LD_INT 7
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: PUSH
18851: LD_INT 3
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: LD_INT 2
18859: PUSH
18860: LD_INT 7
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: LD_INT 1
18874: PUSH
18875: LD_INT 2
18877: PUSH
18878: LD_INT 7
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: PPUSH
18894: CALL 85589 0 2
// repeat wait ( 0 0$1 ) ;
18898: LD_INT 35
18900: PPUSH
18901: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18905: LD_VAR 0 2
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 87007 0 2
18917: PUSH
18918: LD_INT 5
18920: GREATEREQUAL
18921: PUSH
18922: LD_OWVAR 1
18926: PUSH
18927: LD_INT 21000
18929: MOD
18930: PUSH
18931: LD_INT 0
18933: EQUAL
18934: OR
18935: IFFALSE 18898
// wait ( 0 0$30 ) ;
18937: LD_INT 1050
18939: PPUSH
18940: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_VAR 0 2
18953: PPUSH
18954: LD_INT 1
18956: PPUSH
18957: CALL 87007 0 2
18961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18962: LD_ADDR_EXP 50
18966: PUSH
18967: LD_EXP 50
18971: PPUSH
18972: LD_VAR 0 2
18976: PPUSH
18977: LD_EXP 50
18981: PUSH
18982: LD_VAR 0 2
18986: ARRAY
18987: PUSH
18988: LD_VAR 0 3
18992: DIFF
18993: PPUSH
18994: CALL_OW 1
18998: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18999: LD_INT 35
19001: PPUSH
19002: CALL_OW 67
// for i in tmp do
19006: LD_ADDR_VAR 0 1
19010: PUSH
19011: LD_VAR 0 3
19015: PUSH
19016: FOR_IN
19017: IFFALSE 19099
// begin if GetLives ( i ) > 251 then
19019: LD_VAR 0 1
19023: PPUSH
19024: CALL_OW 256
19028: PUSH
19029: LD_INT 251
19031: GREATER
19032: IFFALSE 19070
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19034: LD_VAR 0 1
19038: PPUSH
19039: LD_INT 81
19041: PUSH
19042: LD_INT 4
19044: PUSH
19045: EMPTY
19046: LIST
19047: LIST
19048: PPUSH
19049: CALL_OW 69
19053: PPUSH
19054: LD_VAR 0 1
19058: PPUSH
19059: CALL_OW 74
19063: PPUSH
19064: CALL_OW 115
19068: GO 19097
// if IsDead ( i ) then
19070: LD_VAR 0 1
19074: PPUSH
19075: CALL_OW 301
19079: IFFALSE 19097
// tmp := tmp diff i ;
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_VAR 0 3
19090: PUSH
19091: LD_VAR 0 1
19095: DIFF
19096: ST_TO_ADDR
// end ;
19097: GO 19016
19099: POP
19100: POP
// until not tmp ;
19101: LD_VAR 0 3
19105: NOT
19106: IFFALSE 18999
// end ; end_of_file
19108: PPOPN 4
19110: END
// export function CustomEvent ( event ) ; begin
19111: LD_INT 0
19113: PPUSH
// end ;
19114: LD_VAR 0 2
19118: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19119: LD_VAR 0 1
19123: PUSH
19124: LD_INT 1
19126: EQUAL
19127: PUSH
19128: LD_VAR 0 2
19132: PUSH
19133: LD_INT 4
19135: EQUAL
19136: AND
19137: IFFALSE 19165
// begin SayRadio ( Powell , DP-Lost ) ;
19139: LD_EXP 12
19143: PPUSH
19144: LD_STRING DP-Lost
19146: PPUSH
19147: CALL_OW 94
// wait ( 0 0$2 ) ;
19151: LD_INT 70
19153: PPUSH
19154: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19158: LD_STRING FriendlyFire
19160: PPUSH
19161: CALL_OW 104
// end ; end ;
19165: PPOPN 2
19167: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19168: LD_VAR 0 1
19172: PPUSH
19173: CALL 107809 0 1
// if GameType = 1 then
19177: LD_EXP 2
19181: PUSH
19182: LD_INT 1
19184: EQUAL
19185: IFFALSE 19420
// begin if un = playerCommander then
19187: LD_VAR 0 1
19191: PUSH
19192: LD_EXP 9
19196: EQUAL
19197: IFFALSE 19206
// YouLost ( commanderDied ) ;
19199: LD_STRING commanderDied
19201: PPUSH
19202: CALL_OW 104
// if un = allyCommander then
19206: LD_VAR 0 1
19210: PUSH
19211: LD_EXP 11
19215: EQUAL
19216: IFFALSE 19225
// YouLost ( Theta ) ;
19218: LD_STRING Theta
19220: PPUSH
19221: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19225: LD_VAR 0 1
19229: PUSH
19230: LD_INT 22
19232: PUSH
19233: LD_INT 8
19235: PUSH
19236: EMPTY
19237: LIST
19238: LIST
19239: PUSH
19240: LD_INT 2
19242: PUSH
19243: LD_INT 21
19245: PUSH
19246: LD_INT 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 69
19276: IN
19277: IFFALSE 19293
// legDestCounter := legDestCounter + 1 ;
19279: LD_ADDR_EXP 18
19283: PUSH
19284: LD_EXP 18
19288: PUSH
19289: LD_INT 1
19291: PLUS
19292: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19293: LD_VAR 0 1
19297: PUSH
19298: LD_INT 22
19300: PUSH
19301: LD_INT 4
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: PUSH
19308: LD_INT 2
19310: PUSH
19311: LD_INT 21
19313: PUSH
19314: LD_INT 1
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PUSH
19321: LD_INT 21
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PPUSH
19340: CALL_OW 69
19344: IN
19345: IFFALSE 19361
// allyDestCounter := allyDestCounter + 1 ;
19347: LD_ADDR_EXP 22
19351: PUSH
19352: LD_EXP 22
19356: PUSH
19357: LD_INT 1
19359: PLUS
19360: ST_TO_ADDR
// if un in ruOutpost then
19361: LD_VAR 0 1
19365: PUSH
19366: LD_EXP 14
19370: IN
19371: IFFALSE 19420
// begin ruOutpost := ruOutpost diff un ;
19373: LD_ADDR_EXP 14
19377: PUSH
19378: LD_EXP 14
19382: PUSH
19383: LD_VAR 0 1
19387: DIFF
19388: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19389: LD_ADDR_EXP 15
19393: PUSH
19394: LD_EXP 15
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: LD_EXP 15
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_INT 1
19413: PLUS
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19420: LD_VAR 0 1
19424: PPUSH
19425: CALL 89031 0 1
// end ;
19429: PPOPN 1
19431: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: LD_VAR 0 2
19441: PPUSH
19442: CALL 91363 0 2
// end ;
19446: PPOPN 2
19448: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19449: LD_VAR 0 1
19453: PPUSH
19454: CALL 90431 0 1
// end ;
19458: PPOPN 1
19460: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19461: LD_VAR 0 1
19465: PPUSH
19466: CALL 90672 0 1
// end ;
19470: PPOPN 1
19472: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19473: LD_VAR 0 1
19477: PUSH
19478: LD_INT 14
19480: EQUAL
19481: PUSH
19482: LD_VAR 0 2
19486: PPUSH
19487: CALL_OW 255
19491: PUSH
19492: LD_INT 1
19494: EQUAL
19495: AND
19496: IFFALSE 19537
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19498: LD_EXP 9
19502: PPUSH
19503: LD_STRING D
19505: PUSH
19506: LD_STRING I
19508: PUSH
19509: LD_STRING J
19511: PUSH
19512: LD_STRING S
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: LIST
19519: PUSH
19520: LD_EXP 25
19524: ARRAY
19525: STR
19526: PUSH
19527: LD_STRING -1-Laser
19529: STR
19530: PPUSH
19531: CALL_OW 88
// exit ;
19535: GO 19679
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19537: LD_VAR 0 1
19541: PUSH
19542: LD_INT 7
19544: EQUAL
19545: PUSH
19546: LD_VAR 0 2
19550: PPUSH
19551: CALL_OW 255
19555: PUSH
19556: LD_INT 1
19558: EQUAL
19559: AND
19560: IFFALSE 19601
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19562: LD_EXP 9
19566: PPUSH
19567: LD_STRING D
19569: PUSH
19570: LD_STRING I
19572: PUSH
19573: LD_STRING J
19575: PUSH
19576: LD_STRING S
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_EXP 25
19588: ARRAY
19589: STR
19590: PUSH
19591: LD_STRING -1-Materialization
19593: STR
19594: PPUSH
19595: CALL_OW 88
// exit ;
19599: GO 19679
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19601: LD_VAR 0 1
19605: PUSH
19606: LD_INT 25
19608: EQUAL
19609: PUSH
19610: LD_VAR 0 2
19614: PPUSH
19615: CALL_OW 255
19619: PUSH
19620: LD_INT 1
19622: EQUAL
19623: AND
19624: IFFALSE 19665
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19626: LD_EXP 9
19630: PPUSH
19631: LD_STRING D
19633: PUSH
19634: LD_STRING I
19636: PUSH
19637: LD_STRING J
19639: PUSH
19640: LD_STRING S
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: LIST
19647: PUSH
19648: LD_EXP 25
19652: ARRAY
19653: STR
19654: PUSH
19655: LD_STRING -1-Rocket
19657: STR
19658: PPUSH
19659: CALL_OW 88
// exit ;
19663: GO 19679
// end ; MCE_ResearchComplete ( tech , lab ) ;
19665: LD_VAR 0 1
19669: PPUSH
19670: LD_VAR 0 2
19674: PPUSH
19675: CALL 88727 0 2
// end ;
19679: PPOPN 2
19681: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19682: LD_VAR 0 1
19686: PPUSH
19687: LD_VAR 0 2
19691: PPUSH
19692: LD_VAR 0 3
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: LD_VAR 0 5
19706: PPUSH
19707: CALL 88347 0 5
// end ;
19711: PPOPN 5
19713: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19714: LD_VAR 0 1
19718: PPUSH
19719: LD_VAR 0 2
19723: PPUSH
19724: CALL 107929 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19728: LD_VAR 0 1
19732: PPUSH
19733: LD_VAR 0 2
19737: PPUSH
19738: CALL 87900 0 2
// end ;
19742: PPOPN 2
19744: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19745: LD_VAR 0 1
19749: PPUSH
19750: LD_VAR 0 2
19754: PPUSH
19755: LD_VAR 0 3
19759: PPUSH
19760: LD_VAR 0 4
19764: PPUSH
19765: CALL 87738 0 4
// end ;
19769: PPOPN 4
19771: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19772: LD_VAR 0 1
19776: PPUSH
19777: LD_VAR 0 2
19781: PPUSH
19782: LD_VAR 0 3
19786: PPUSH
19787: CALL 87513 0 3
// end ;
19791: PPOPN 3
19793: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19794: LD_VAR 0 1
19798: PPUSH
19799: LD_VAR 0 2
19803: PPUSH
19804: CALL 87398 0 2
// end ;
19808: PPOPN 2
19810: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19811: LD_VAR 0 1
19815: PPUSH
19816: LD_VAR 0 2
19820: PPUSH
19821: CALL 91658 0 2
// end ;
19825: PPOPN 2
19827: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19828: LD_VAR 0 1
19832: PPUSH
19833: LD_VAR 0 2
19837: PPUSH
19838: LD_VAR 0 3
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: CALL 91874 0 4
// end ;
19852: PPOPN 4
19854: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19855: LD_VAR 0 1
19859: PPUSH
19860: LD_VAR 0 2
19864: PPUSH
19865: CALL 87207 0 2
// end ;
19869: PPOPN 2
19871: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19872: LD_VAR 0 1
19876: PPUSH
19877: CALL 107913 0 1
// end ; end_of_file
19881: PPOPN 1
19883: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19884: LD_INT 0
19886: PPUSH
19887: PPUSH
// if exist_mode then
19888: LD_VAR 0 2
19892: IFFALSE 19917
// unit := CreateCharacter ( prefix & ident ) else
19894: LD_ADDR_VAR 0 5
19898: PUSH
19899: LD_VAR 0 3
19903: PUSH
19904: LD_VAR 0 1
19908: STR
19909: PPUSH
19910: CALL_OW 34
19914: ST_TO_ADDR
19915: GO 19932
// unit := NewCharacter ( ident ) ;
19917: LD_ADDR_VAR 0 5
19921: PUSH
19922: LD_VAR 0 1
19926: PPUSH
19927: CALL_OW 25
19931: ST_TO_ADDR
// result := unit ;
19932: LD_ADDR_VAR 0 4
19936: PUSH
19937: LD_VAR 0 5
19941: ST_TO_ADDR
// end ;
19942: LD_VAR 0 4
19946: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19947: LD_INT 0
19949: PPUSH
19950: PPUSH
// if not side or not nation then
19951: LD_VAR 0 1
19955: NOT
19956: PUSH
19957: LD_VAR 0 2
19961: NOT
19962: OR
19963: IFFALSE 19967
// exit ;
19965: GO 20735
// case nation of nation_american :
19967: LD_VAR 0 2
19971: PUSH
19972: LD_INT 1
19974: DOUBLE
19975: EQUAL
19976: IFTRUE 19980
19978: GO 20194
19980: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19981: LD_ADDR_VAR 0 4
19985: PUSH
19986: LD_INT 35
19988: PUSH
19989: LD_INT 45
19991: PUSH
19992: LD_INT 46
19994: PUSH
19995: LD_INT 47
19997: PUSH
19998: LD_INT 82
20000: PUSH
20001: LD_INT 83
20003: PUSH
20004: LD_INT 84
20006: PUSH
20007: LD_INT 85
20009: PUSH
20010: LD_INT 86
20012: PUSH
20013: LD_INT 1
20015: PUSH
20016: LD_INT 2
20018: PUSH
20019: LD_INT 6
20021: PUSH
20022: LD_INT 15
20024: PUSH
20025: LD_INT 16
20027: PUSH
20028: LD_INT 7
20030: PUSH
20031: LD_INT 12
20033: PUSH
20034: LD_INT 13
20036: PUSH
20037: LD_INT 10
20039: PUSH
20040: LD_INT 14
20042: PUSH
20043: LD_INT 20
20045: PUSH
20046: LD_INT 21
20048: PUSH
20049: LD_INT 22
20051: PUSH
20052: LD_INT 25
20054: PUSH
20055: LD_INT 32
20057: PUSH
20058: LD_INT 27
20060: PUSH
20061: LD_INT 36
20063: PUSH
20064: LD_INT 69
20066: PUSH
20067: LD_INT 39
20069: PUSH
20070: LD_INT 34
20072: PUSH
20073: LD_INT 40
20075: PUSH
20076: LD_INT 48
20078: PUSH
20079: LD_INT 49
20081: PUSH
20082: LD_INT 50
20084: PUSH
20085: LD_INT 51
20087: PUSH
20088: LD_INT 52
20090: PUSH
20091: LD_INT 53
20093: PUSH
20094: LD_INT 54
20096: PUSH
20097: LD_INT 55
20099: PUSH
20100: LD_INT 56
20102: PUSH
20103: LD_INT 57
20105: PUSH
20106: LD_INT 58
20108: PUSH
20109: LD_INT 59
20111: PUSH
20112: LD_INT 60
20114: PUSH
20115: LD_INT 61
20117: PUSH
20118: LD_INT 62
20120: PUSH
20121: LD_INT 80
20123: PUSH
20124: LD_INT 82
20126: PUSH
20127: LD_INT 83
20129: PUSH
20130: LD_INT 84
20132: PUSH
20133: LD_INT 85
20135: PUSH
20136: LD_INT 86
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: ST_TO_ADDR
20192: GO 20659
20194: LD_INT 2
20196: DOUBLE
20197: EQUAL
20198: IFTRUE 20202
20200: GO 20428
20202: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20203: LD_ADDR_VAR 0 4
20207: PUSH
20208: LD_INT 35
20210: PUSH
20211: LD_INT 45
20213: PUSH
20214: LD_INT 46
20216: PUSH
20217: LD_INT 47
20219: PUSH
20220: LD_INT 82
20222: PUSH
20223: LD_INT 83
20225: PUSH
20226: LD_INT 84
20228: PUSH
20229: LD_INT 85
20231: PUSH
20232: LD_INT 87
20234: PUSH
20235: LD_INT 70
20237: PUSH
20238: LD_INT 1
20240: PUSH
20241: LD_INT 11
20243: PUSH
20244: LD_INT 3
20246: PUSH
20247: LD_INT 4
20249: PUSH
20250: LD_INT 5
20252: PUSH
20253: LD_INT 6
20255: PUSH
20256: LD_INT 15
20258: PUSH
20259: LD_INT 18
20261: PUSH
20262: LD_INT 7
20264: PUSH
20265: LD_INT 17
20267: PUSH
20268: LD_INT 8
20270: PUSH
20271: LD_INT 20
20273: PUSH
20274: LD_INT 21
20276: PUSH
20277: LD_INT 22
20279: PUSH
20280: LD_INT 72
20282: PUSH
20283: LD_INT 26
20285: PUSH
20286: LD_INT 69
20288: PUSH
20289: LD_INT 39
20291: PUSH
20292: LD_INT 40
20294: PUSH
20295: LD_INT 41
20297: PUSH
20298: LD_INT 42
20300: PUSH
20301: LD_INT 43
20303: PUSH
20304: LD_INT 48
20306: PUSH
20307: LD_INT 49
20309: PUSH
20310: LD_INT 50
20312: PUSH
20313: LD_INT 51
20315: PUSH
20316: LD_INT 52
20318: PUSH
20319: LD_INT 53
20321: PUSH
20322: LD_INT 54
20324: PUSH
20325: LD_INT 55
20327: PUSH
20328: LD_INT 56
20330: PUSH
20331: LD_INT 60
20333: PUSH
20334: LD_INT 61
20336: PUSH
20337: LD_INT 62
20339: PUSH
20340: LD_INT 66
20342: PUSH
20343: LD_INT 67
20345: PUSH
20346: LD_INT 68
20348: PUSH
20349: LD_INT 81
20351: PUSH
20352: LD_INT 82
20354: PUSH
20355: LD_INT 83
20357: PUSH
20358: LD_INT 84
20360: PUSH
20361: LD_INT 85
20363: PUSH
20364: LD_INT 87
20366: PUSH
20367: LD_INT 88
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: ST_TO_ADDR
20426: GO 20659
20428: LD_INT 3
20430: DOUBLE
20431: EQUAL
20432: IFTRUE 20436
20434: GO 20658
20436: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20437: LD_ADDR_VAR 0 4
20441: PUSH
20442: LD_INT 46
20444: PUSH
20445: LD_INT 47
20447: PUSH
20448: LD_INT 1
20450: PUSH
20451: LD_INT 2
20453: PUSH
20454: LD_INT 82
20456: PUSH
20457: LD_INT 83
20459: PUSH
20460: LD_INT 84
20462: PUSH
20463: LD_INT 85
20465: PUSH
20466: LD_INT 86
20468: PUSH
20469: LD_INT 11
20471: PUSH
20472: LD_INT 9
20474: PUSH
20475: LD_INT 20
20477: PUSH
20478: LD_INT 19
20480: PUSH
20481: LD_INT 21
20483: PUSH
20484: LD_INT 24
20486: PUSH
20487: LD_INT 22
20489: PUSH
20490: LD_INT 25
20492: PUSH
20493: LD_INT 28
20495: PUSH
20496: LD_INT 29
20498: PUSH
20499: LD_INT 30
20501: PUSH
20502: LD_INT 31
20504: PUSH
20505: LD_INT 37
20507: PUSH
20508: LD_INT 38
20510: PUSH
20511: LD_INT 32
20513: PUSH
20514: LD_INT 27
20516: PUSH
20517: LD_INT 33
20519: PUSH
20520: LD_INT 69
20522: PUSH
20523: LD_INT 39
20525: PUSH
20526: LD_INT 34
20528: PUSH
20529: LD_INT 40
20531: PUSH
20532: LD_INT 71
20534: PUSH
20535: LD_INT 23
20537: PUSH
20538: LD_INT 44
20540: PUSH
20541: LD_INT 48
20543: PUSH
20544: LD_INT 49
20546: PUSH
20547: LD_INT 50
20549: PUSH
20550: LD_INT 51
20552: PUSH
20553: LD_INT 52
20555: PUSH
20556: LD_INT 53
20558: PUSH
20559: LD_INT 54
20561: PUSH
20562: LD_INT 55
20564: PUSH
20565: LD_INT 56
20567: PUSH
20568: LD_INT 57
20570: PUSH
20571: LD_INT 58
20573: PUSH
20574: LD_INT 59
20576: PUSH
20577: LD_INT 63
20579: PUSH
20580: LD_INT 64
20582: PUSH
20583: LD_INT 65
20585: PUSH
20586: LD_INT 82
20588: PUSH
20589: LD_INT 83
20591: PUSH
20592: LD_INT 84
20594: PUSH
20595: LD_INT 85
20597: PUSH
20598: LD_INT 86
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: ST_TO_ADDR
20656: GO 20659
20658: POP
// if state > - 1 and state < 3 then
20659: LD_VAR 0 3
20663: PUSH
20664: LD_INT 1
20666: NEG
20667: GREATER
20668: PUSH
20669: LD_VAR 0 3
20673: PUSH
20674: LD_INT 3
20676: LESS
20677: AND
20678: IFFALSE 20735
// for i in result do
20680: LD_ADDR_VAR 0 5
20684: PUSH
20685: LD_VAR 0 4
20689: PUSH
20690: FOR_IN
20691: IFFALSE 20733
// if GetTech ( i , side ) <> state then
20693: LD_VAR 0 5
20697: PPUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: CALL_OW 321
20707: PUSH
20708: LD_VAR 0 3
20712: NONEQUAL
20713: IFFALSE 20731
// result := result diff i ;
20715: LD_ADDR_VAR 0 4
20719: PUSH
20720: LD_VAR 0 4
20724: PUSH
20725: LD_VAR 0 5
20729: DIFF
20730: ST_TO_ADDR
20731: GO 20690
20733: POP
20734: POP
// end ;
20735: LD_VAR 0 4
20739: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20740: LD_INT 0
20742: PPUSH
20743: PPUSH
20744: PPUSH
// result := true ;
20745: LD_ADDR_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20753: LD_ADDR_VAR 0 5
20757: PUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: CALL_OW 480
20767: ST_TO_ADDR
// if not tmp then
20768: LD_VAR 0 5
20772: NOT
20773: IFFALSE 20777
// exit ;
20775: GO 20826
// for i in tmp do
20777: LD_ADDR_VAR 0 4
20781: PUSH
20782: LD_VAR 0 5
20786: PUSH
20787: FOR_IN
20788: IFFALSE 20824
// if GetTech ( i , side ) <> state_researched then
20790: LD_VAR 0 4
20794: PPUSH
20795: LD_VAR 0 1
20799: PPUSH
20800: CALL_OW 321
20804: PUSH
20805: LD_INT 2
20807: NONEQUAL
20808: IFFALSE 20822
// begin result := false ;
20810: LD_ADDR_VAR 0 3
20814: PUSH
20815: LD_INT 0
20817: ST_TO_ADDR
// exit ;
20818: POP
20819: POP
20820: GO 20826
// end ;
20822: GO 20787
20824: POP
20825: POP
// end ;
20826: LD_VAR 0 3
20830: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20831: LD_INT 0
20833: PPUSH
20834: PPUSH
20835: PPUSH
20836: PPUSH
20837: PPUSH
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
20845: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20846: LD_VAR 0 1
20850: NOT
20851: PUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: CALL_OW 257
20861: PUSH
20862: LD_INT 9
20864: NONEQUAL
20865: OR
20866: IFFALSE 20870
// exit ;
20868: GO 21443
// side := GetSide ( unit ) ;
20870: LD_ADDR_VAR 0 9
20874: PUSH
20875: LD_VAR 0 1
20879: PPUSH
20880: CALL_OW 255
20884: ST_TO_ADDR
// tech_space := tech_spacanom ;
20885: LD_ADDR_VAR 0 12
20889: PUSH
20890: LD_INT 29
20892: ST_TO_ADDR
// tech_time := tech_taurad ;
20893: LD_ADDR_VAR 0 13
20897: PUSH
20898: LD_INT 28
20900: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20901: LD_ADDR_VAR 0 11
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 310
20915: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20916: LD_VAR 0 11
20920: PPUSH
20921: CALL_OW 247
20925: PUSH
20926: LD_INT 2
20928: EQUAL
20929: IFFALSE 20933
// exit ;
20931: GO 21443
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20933: LD_ADDR_VAR 0 8
20937: PUSH
20938: LD_INT 81
20940: PUSH
20941: LD_VAR 0 9
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: PUSH
20950: LD_INT 3
20952: PUSH
20953: LD_INT 21
20955: PUSH
20956: LD_INT 3
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PPUSH
20971: CALL_OW 69
20975: ST_TO_ADDR
// if not tmp then
20976: LD_VAR 0 8
20980: NOT
20981: IFFALSE 20985
// exit ;
20983: GO 21443
// if in_unit then
20985: LD_VAR 0 11
20989: IFFALSE 21013
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20991: LD_ADDR_VAR 0 10
20995: PUSH
20996: LD_VAR 0 8
21000: PPUSH
21001: LD_VAR 0 11
21005: PPUSH
21006: CALL_OW 74
21010: ST_TO_ADDR
21011: GO 21033
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21013: LD_ADDR_VAR 0 10
21017: PUSH
21018: LD_VAR 0 8
21022: PPUSH
21023: LD_VAR 0 1
21027: PPUSH
21028: CALL_OW 74
21032: ST_TO_ADDR
// if not enemy then
21033: LD_VAR 0 10
21037: NOT
21038: IFFALSE 21042
// exit ;
21040: GO 21443
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21042: LD_VAR 0 11
21046: PUSH
21047: LD_VAR 0 11
21051: PPUSH
21052: LD_VAR 0 10
21056: PPUSH
21057: CALL_OW 296
21061: PUSH
21062: LD_INT 13
21064: GREATER
21065: AND
21066: PUSH
21067: LD_VAR 0 1
21071: PPUSH
21072: LD_VAR 0 10
21076: PPUSH
21077: CALL_OW 296
21081: PUSH
21082: LD_INT 12
21084: GREATER
21085: OR
21086: IFFALSE 21090
// exit ;
21088: GO 21443
// missile := [ 1 ] ;
21090: LD_ADDR_VAR 0 14
21094: PUSH
21095: LD_INT 1
21097: PUSH
21098: EMPTY
21099: LIST
21100: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21101: LD_VAR 0 9
21105: PPUSH
21106: LD_VAR 0 12
21110: PPUSH
21111: CALL_OW 325
21115: IFFALSE 21144
// missile := Replace ( missile , missile + 1 , 2 ) ;
21117: LD_ADDR_VAR 0 14
21121: PUSH
21122: LD_VAR 0 14
21126: PPUSH
21127: LD_VAR 0 14
21131: PUSH
21132: LD_INT 1
21134: PLUS
21135: PPUSH
21136: LD_INT 2
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21144: LD_VAR 0 9
21148: PPUSH
21149: LD_VAR 0 13
21153: PPUSH
21154: CALL_OW 325
21158: PUSH
21159: LD_VAR 0 10
21163: PPUSH
21164: CALL_OW 255
21168: PPUSH
21169: LD_VAR 0 13
21173: PPUSH
21174: CALL_OW 325
21178: NOT
21179: AND
21180: IFFALSE 21209
// missile := Replace ( missile , missile + 1 , 3 ) ;
21182: LD_ADDR_VAR 0 14
21186: PUSH
21187: LD_VAR 0 14
21191: PPUSH
21192: LD_VAR 0 14
21196: PUSH
21197: LD_INT 1
21199: PLUS
21200: PPUSH
21201: LD_INT 3
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// if missile < 2 then
21209: LD_VAR 0 14
21213: PUSH
21214: LD_INT 2
21216: LESS
21217: IFFALSE 21221
// exit ;
21219: GO 21443
// x := GetX ( enemy ) ;
21221: LD_ADDR_VAR 0 4
21225: PUSH
21226: LD_VAR 0 10
21230: PPUSH
21231: CALL_OW 250
21235: ST_TO_ADDR
// y := GetY ( enemy ) ;
21236: LD_ADDR_VAR 0 5
21240: PUSH
21241: LD_VAR 0 10
21245: PPUSH
21246: CALL_OW 251
21250: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21251: LD_ADDR_VAR 0 6
21255: PUSH
21256: LD_VAR 0 4
21260: PUSH
21261: LD_INT 1
21263: NEG
21264: PPUSH
21265: LD_INT 1
21267: PPUSH
21268: CALL_OW 12
21272: PLUS
21273: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21274: LD_ADDR_VAR 0 7
21278: PUSH
21279: LD_VAR 0 5
21283: PUSH
21284: LD_INT 1
21286: NEG
21287: PPUSH
21288: LD_INT 1
21290: PPUSH
21291: CALL_OW 12
21295: PLUS
21296: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21297: LD_VAR 0 6
21301: PPUSH
21302: LD_VAR 0 7
21306: PPUSH
21307: CALL_OW 488
21311: NOT
21312: IFFALSE 21334
// begin _x := x ;
21314: LD_ADDR_VAR 0 6
21318: PUSH
21319: LD_VAR 0 4
21323: ST_TO_ADDR
// _y := y ;
21324: LD_ADDR_VAR 0 7
21328: PUSH
21329: LD_VAR 0 5
21333: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21334: LD_ADDR_VAR 0 3
21338: PUSH
21339: LD_INT 1
21341: PPUSH
21342: LD_VAR 0 14
21346: PPUSH
21347: CALL_OW 12
21351: ST_TO_ADDR
// case i of 1 :
21352: LD_VAR 0 3
21356: PUSH
21357: LD_INT 1
21359: DOUBLE
21360: EQUAL
21361: IFTRUE 21365
21363: GO 21382
21365: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21366: LD_VAR 0 1
21370: PPUSH
21371: LD_VAR 0 10
21375: PPUSH
21376: CALL_OW 115
21380: GO 21443
21382: LD_INT 2
21384: DOUBLE
21385: EQUAL
21386: IFTRUE 21390
21388: GO 21412
21390: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21391: LD_VAR 0 1
21395: PPUSH
21396: LD_VAR 0 6
21400: PPUSH
21401: LD_VAR 0 7
21405: PPUSH
21406: CALL_OW 153
21410: GO 21443
21412: LD_INT 3
21414: DOUBLE
21415: EQUAL
21416: IFTRUE 21420
21418: GO 21442
21420: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21421: LD_VAR 0 1
21425: PPUSH
21426: LD_VAR 0 6
21430: PPUSH
21431: LD_VAR 0 7
21435: PPUSH
21436: CALL_OW 154
21440: GO 21443
21442: POP
// end ;
21443: LD_VAR 0 2
21447: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
21453: PPUSH
21454: PPUSH
21455: PPUSH
// if not unit or not building then
21456: LD_VAR 0 1
21460: NOT
21461: PUSH
21462: LD_VAR 0 2
21466: NOT
21467: OR
21468: IFFALSE 21472
// exit ;
21470: GO 21630
// x := GetX ( building ) ;
21472: LD_ADDR_VAR 0 5
21476: PUSH
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 250
21486: ST_TO_ADDR
// y := GetY ( building ) ;
21487: LD_ADDR_VAR 0 6
21491: PUSH
21492: LD_VAR 0 2
21496: PPUSH
21497: CALL_OW 251
21501: ST_TO_ADDR
// for i = 0 to 5 do
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: DOUBLE
21508: LD_INT 0
21510: DEC
21511: ST_TO_ADDR
21512: LD_INT 5
21514: PUSH
21515: FOR_TO
21516: IFFALSE 21628
// begin _x := ShiftX ( x , i , 3 ) ;
21518: LD_ADDR_VAR 0 7
21522: PUSH
21523: LD_VAR 0 5
21527: PPUSH
21528: LD_VAR 0 4
21532: PPUSH
21533: LD_INT 3
21535: PPUSH
21536: CALL_OW 272
21540: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21541: LD_ADDR_VAR 0 8
21545: PUSH
21546: LD_VAR 0 6
21550: PPUSH
21551: LD_VAR 0 4
21555: PPUSH
21556: LD_INT 3
21558: PPUSH
21559: CALL_OW 273
21563: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21564: LD_VAR 0 7
21568: PPUSH
21569: LD_VAR 0 8
21573: PPUSH
21574: CALL_OW 488
21578: NOT
21579: IFFALSE 21583
// continue ;
21581: GO 21515
// if HexInfo ( _x , _y ) = 0 then
21583: LD_VAR 0 7
21587: PPUSH
21588: LD_VAR 0 8
21592: PPUSH
21593: CALL_OW 428
21597: PUSH
21598: LD_INT 0
21600: EQUAL
21601: IFFALSE 21626
// begin ComMoveXY ( unit , _x , _y ) ;
21603: LD_VAR 0 1
21607: PPUSH
21608: LD_VAR 0 7
21612: PPUSH
21613: LD_VAR 0 8
21617: PPUSH
21618: CALL_OW 111
// exit ;
21622: POP
21623: POP
21624: GO 21630
// end ; end ;
21626: GO 21515
21628: POP
21629: POP
// end ;
21630: LD_VAR 0 3
21634: RET
// export function ScanBase ( side , base_area ) ; begin
21635: LD_INT 0
21637: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21638: LD_ADDR_VAR 0 3
21642: PUSH
21643: LD_VAR 0 2
21647: PPUSH
21648: LD_INT 81
21650: PUSH
21651: LD_VAR 0 1
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PPUSH
21660: CALL_OW 70
21664: ST_TO_ADDR
// end ;
21665: LD_VAR 0 3
21669: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21670: LD_INT 0
21672: PPUSH
21673: PPUSH
21674: PPUSH
21675: PPUSH
// result := false ;
21676: LD_ADDR_VAR 0 2
21680: PUSH
21681: LD_INT 0
21683: ST_TO_ADDR
// side := GetSide ( unit ) ;
21684: LD_ADDR_VAR 0 3
21688: PUSH
21689: LD_VAR 0 1
21693: PPUSH
21694: CALL_OW 255
21698: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21699: LD_ADDR_VAR 0 4
21703: PUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 248
21713: ST_TO_ADDR
// case nat of 1 :
21714: LD_VAR 0 4
21718: PUSH
21719: LD_INT 1
21721: DOUBLE
21722: EQUAL
21723: IFTRUE 21727
21725: GO 21738
21727: POP
// tech := tech_lassight ; 2 :
21728: LD_ADDR_VAR 0 5
21732: PUSH
21733: LD_INT 12
21735: ST_TO_ADDR
21736: GO 21777
21738: LD_INT 2
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 21757
21746: POP
// tech := tech_mortar ; 3 :
21747: LD_ADDR_VAR 0 5
21751: PUSH
21752: LD_INT 41
21754: ST_TO_ADDR
21755: GO 21777
21757: LD_INT 3
21759: DOUBLE
21760: EQUAL
21761: IFTRUE 21765
21763: GO 21776
21765: POP
// tech := tech_bazooka ; end ;
21766: LD_ADDR_VAR 0 5
21770: PUSH
21771: LD_INT 44
21773: ST_TO_ADDR
21774: GO 21777
21776: POP
// if Researched ( side , tech ) then
21777: LD_VAR 0 3
21781: PPUSH
21782: LD_VAR 0 5
21786: PPUSH
21787: CALL_OW 325
21791: IFFALSE 21818
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21793: LD_ADDR_VAR 0 2
21797: PUSH
21798: LD_INT 5
21800: PUSH
21801: LD_INT 8
21803: PUSH
21804: LD_INT 9
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: PUSH
21812: LD_VAR 0 4
21816: ARRAY
21817: ST_TO_ADDR
// end ;
21818: LD_VAR 0 2
21822: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21823: LD_INT 0
21825: PPUSH
21826: PPUSH
21827: PPUSH
// if not mines then
21828: LD_VAR 0 2
21832: NOT
21833: IFFALSE 21837
// exit ;
21835: GO 21981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21837: LD_ADDR_VAR 0 5
21841: PUSH
21842: LD_INT 81
21844: PUSH
21845: LD_VAR 0 1
21849: PUSH
21850: EMPTY
21851: LIST
21852: LIST
21853: PUSH
21854: LD_INT 3
21856: PUSH
21857: LD_INT 21
21859: PUSH
21860: LD_INT 3
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PPUSH
21875: CALL_OW 69
21879: ST_TO_ADDR
// for i in mines do
21880: LD_ADDR_VAR 0 4
21884: PUSH
21885: LD_VAR 0 2
21889: PUSH
21890: FOR_IN
21891: IFFALSE 21979
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21893: LD_VAR 0 4
21897: PUSH
21898: LD_INT 1
21900: ARRAY
21901: PPUSH
21902: LD_VAR 0 4
21906: PUSH
21907: LD_INT 2
21909: ARRAY
21910: PPUSH
21911: CALL_OW 458
21915: NOT
21916: IFFALSE 21920
// continue ;
21918: GO 21890
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21920: LD_VAR 0 4
21924: PUSH
21925: LD_INT 1
21927: ARRAY
21928: PPUSH
21929: LD_VAR 0 4
21933: PUSH
21934: LD_INT 2
21936: ARRAY
21937: PPUSH
21938: CALL_OW 428
21942: PUSH
21943: LD_VAR 0 5
21947: IN
21948: IFFALSE 21977
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21950: LD_VAR 0 4
21954: PUSH
21955: LD_INT 1
21957: ARRAY
21958: PPUSH
21959: LD_VAR 0 4
21963: PUSH
21964: LD_INT 2
21966: ARRAY
21967: PPUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: CALL_OW 456
// end ;
21977: GO 21890
21979: POP
21980: POP
// end ;
21981: LD_VAR 0 3
21985: RET
// export function Count ( array ) ; var i ; begin
21986: LD_INT 0
21988: PPUSH
21989: PPUSH
// result := 0 ;
21990: LD_ADDR_VAR 0 2
21994: PUSH
21995: LD_INT 0
21997: ST_TO_ADDR
// for i in array do
21998: LD_ADDR_VAR 0 3
22002: PUSH
22003: LD_VAR 0 1
22007: PUSH
22008: FOR_IN
22009: IFFALSE 22033
// if i then
22011: LD_VAR 0 3
22015: IFFALSE 22031
// result := result + 1 ;
22017: LD_ADDR_VAR 0 2
22021: PUSH
22022: LD_VAR 0 2
22026: PUSH
22027: LD_INT 1
22029: PLUS
22030: ST_TO_ADDR
22031: GO 22008
22033: POP
22034: POP
// end ;
22035: LD_VAR 0 2
22039: RET
// export function IsEmpty ( building ) ; begin
22040: LD_INT 0
22042: PPUSH
// if not building then
22043: LD_VAR 0 1
22047: NOT
22048: IFFALSE 22052
// exit ;
22050: GO 22095
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22052: LD_ADDR_VAR 0 2
22056: PUSH
22057: LD_VAR 0 1
22061: PUSH
22062: LD_INT 22
22064: PUSH
22065: LD_VAR 0 1
22069: PPUSH
22070: CALL_OW 255
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: PUSH
22079: LD_INT 58
22081: PUSH
22082: EMPTY
22083: LIST
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: PPUSH
22089: CALL_OW 69
22093: IN
22094: ST_TO_ADDR
// end ;
22095: LD_VAR 0 2
22099: RET
// export function IsNotFull ( building ) ; var places ; begin
22100: LD_INT 0
22102: PPUSH
22103: PPUSH
// if not building then
22104: LD_VAR 0 1
22108: NOT
22109: IFFALSE 22113
// exit ;
22111: GO 22284
// result := false ;
22113: LD_ADDR_VAR 0 2
22117: PUSH
22118: LD_INT 0
22120: ST_TO_ADDR
// places := 0 ;
22121: LD_ADDR_VAR 0 3
22125: PUSH
22126: LD_INT 0
22128: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
22129: LD_VAR 0 1
22133: PPUSH
22134: CALL_OW 266
22138: PUSH
22139: LD_INT 0
22141: DOUBLE
22142: EQUAL
22143: IFTRUE 22201
22145: LD_INT 1
22147: DOUBLE
22148: EQUAL
22149: IFTRUE 22201
22151: LD_INT 6
22153: DOUBLE
22154: EQUAL
22155: IFTRUE 22201
22157: LD_INT 7
22159: DOUBLE
22160: EQUAL
22161: IFTRUE 22201
22163: LD_INT 8
22165: DOUBLE
22166: EQUAL
22167: IFTRUE 22201
22169: LD_INT 4
22171: DOUBLE
22172: EQUAL
22173: IFTRUE 22201
22175: LD_INT 5
22177: DOUBLE
22178: EQUAL
22179: IFTRUE 22201
22181: LD_INT 2
22183: DOUBLE
22184: EQUAL
22185: IFTRUE 22201
22187: LD_INT 3
22189: DOUBLE
22190: EQUAL
22191: IFTRUE 22201
22193: LD_INT 35
22195: DOUBLE
22196: EQUAL
22197: IFTRUE 22201
22199: GO 22212
22201: POP
// places := 6 ; b_bunker , b_breastwork :
22202: LD_ADDR_VAR 0 3
22206: PUSH
22207: LD_INT 6
22209: ST_TO_ADDR
22210: GO 22257
22212: LD_INT 32
22214: DOUBLE
22215: EQUAL
22216: IFTRUE 22226
22218: LD_INT 31
22220: DOUBLE
22221: EQUAL
22222: IFTRUE 22226
22224: GO 22237
22226: POP
// places := 1 ; b_control_tower :
22227: LD_ADDR_VAR 0 3
22231: PUSH
22232: LD_INT 1
22234: ST_TO_ADDR
22235: GO 22257
22237: LD_INT 36
22239: DOUBLE
22240: EQUAL
22241: IFTRUE 22245
22243: GO 22256
22245: POP
// places := 3 ; end ;
22246: LD_ADDR_VAR 0 3
22250: PUSH
22251: LD_INT 3
22253: ST_TO_ADDR
22254: GO 22257
22256: POP
// if places then
22257: LD_VAR 0 3
22261: IFFALSE 22284
// result := UnitsInside ( building ) < places ;
22263: LD_ADDR_VAR 0 2
22267: PUSH
22268: LD_VAR 0 1
22272: PPUSH
22273: CALL_OW 313
22277: PUSH
22278: LD_VAR 0 3
22282: LESS
22283: ST_TO_ADDR
// end ;
22284: LD_VAR 0 2
22288: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22289: LD_INT 0
22291: PPUSH
22292: PPUSH
22293: PPUSH
22294: PPUSH
// tmp := [ ] ;
22295: LD_ADDR_VAR 0 3
22299: PUSH
22300: EMPTY
22301: ST_TO_ADDR
// list := [ ] ;
22302: LD_ADDR_VAR 0 5
22306: PUSH
22307: EMPTY
22308: ST_TO_ADDR
// for i = 16 to 25 do
22309: LD_ADDR_VAR 0 4
22313: PUSH
22314: DOUBLE
22315: LD_INT 16
22317: DEC
22318: ST_TO_ADDR
22319: LD_INT 25
22321: PUSH
22322: FOR_TO
22323: IFFALSE 22396
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22325: LD_ADDR_VAR 0 3
22329: PUSH
22330: LD_VAR 0 3
22334: PUSH
22335: LD_INT 22
22337: PUSH
22338: LD_VAR 0 1
22342: PPUSH
22343: CALL_OW 255
22347: PUSH
22348: EMPTY
22349: LIST
22350: LIST
22351: PUSH
22352: LD_INT 91
22354: PUSH
22355: LD_VAR 0 1
22359: PUSH
22360: LD_INT 6
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: LIST
22367: PUSH
22368: LD_INT 30
22370: PUSH
22371: LD_VAR 0 4
22375: PUSH
22376: EMPTY
22377: LIST
22378: LIST
22379: PUSH
22380: EMPTY
22381: LIST
22382: LIST
22383: LIST
22384: PUSH
22385: EMPTY
22386: LIST
22387: PPUSH
22388: CALL_OW 69
22392: ADD
22393: ST_TO_ADDR
22394: GO 22322
22396: POP
22397: POP
// for i = 1 to tmp do
22398: LD_ADDR_VAR 0 4
22402: PUSH
22403: DOUBLE
22404: LD_INT 1
22406: DEC
22407: ST_TO_ADDR
22408: LD_VAR 0 3
22412: PUSH
22413: FOR_TO
22414: IFFALSE 22502
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22416: LD_ADDR_VAR 0 5
22420: PUSH
22421: LD_VAR 0 5
22425: PUSH
22426: LD_VAR 0 3
22430: PUSH
22431: LD_VAR 0 4
22435: ARRAY
22436: PPUSH
22437: CALL_OW 266
22441: PUSH
22442: LD_VAR 0 3
22446: PUSH
22447: LD_VAR 0 4
22451: ARRAY
22452: PPUSH
22453: CALL_OW 250
22457: PUSH
22458: LD_VAR 0 3
22462: PUSH
22463: LD_VAR 0 4
22467: ARRAY
22468: PPUSH
22469: CALL_OW 251
22473: PUSH
22474: LD_VAR 0 3
22478: PUSH
22479: LD_VAR 0 4
22483: ARRAY
22484: PPUSH
22485: CALL_OW 254
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: LIST
22494: LIST
22495: PUSH
22496: EMPTY
22497: LIST
22498: ADD
22499: ST_TO_ADDR
22500: GO 22413
22502: POP
22503: POP
// result := list ;
22504: LD_ADDR_VAR 0 2
22508: PUSH
22509: LD_VAR 0 5
22513: ST_TO_ADDR
// end ;
22514: LD_VAR 0 2
22518: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22519: LD_INT 0
22521: PPUSH
22522: PPUSH
22523: PPUSH
22524: PPUSH
22525: PPUSH
22526: PPUSH
22527: PPUSH
// if not factory then
22528: LD_VAR 0 1
22532: NOT
22533: IFFALSE 22537
// exit ;
22535: GO 23130
// if control = control_apeman then
22537: LD_VAR 0 4
22541: PUSH
22542: LD_INT 5
22544: EQUAL
22545: IFFALSE 22654
// begin tmp := UnitsInside ( factory ) ;
22547: LD_ADDR_VAR 0 8
22551: PUSH
22552: LD_VAR 0 1
22556: PPUSH
22557: CALL_OW 313
22561: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22562: LD_VAR 0 8
22566: PPUSH
22567: LD_INT 25
22569: PUSH
22570: LD_INT 12
22572: PUSH
22573: EMPTY
22574: LIST
22575: LIST
22576: PPUSH
22577: CALL_OW 72
22581: NOT
22582: IFFALSE 22592
// control := control_manual ;
22584: LD_ADDR_VAR 0 4
22588: PUSH
22589: LD_INT 1
22591: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22592: LD_ADDR_VAR 0 8
22596: PUSH
22597: LD_VAR 0 1
22601: PPUSH
22602: CALL 22289 0 1
22606: ST_TO_ADDR
// if tmp then
22607: LD_VAR 0 8
22611: IFFALSE 22654
// begin for i in tmp do
22613: LD_ADDR_VAR 0 7
22617: PUSH
22618: LD_VAR 0 8
22622: PUSH
22623: FOR_IN
22624: IFFALSE 22652
// if i [ 1 ] = b_ext_radio then
22626: LD_VAR 0 7
22630: PUSH
22631: LD_INT 1
22633: ARRAY
22634: PUSH
22635: LD_INT 22
22637: EQUAL
22638: IFFALSE 22650
// begin control := control_remote ;
22640: LD_ADDR_VAR 0 4
22644: PUSH
22645: LD_INT 2
22647: ST_TO_ADDR
// break ;
22648: GO 22652
// end ;
22650: GO 22623
22652: POP
22653: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 2
22663: PPUSH
22664: LD_VAR 0 3
22668: PPUSH
22669: LD_VAR 0 4
22673: PPUSH
22674: LD_VAR 0 5
22678: PPUSH
22679: CALL_OW 448
22683: IFFALSE 22718
// begin result := [ chassis , engine , control , weapon ] ;
22685: LD_ADDR_VAR 0 6
22689: PUSH
22690: LD_VAR 0 2
22694: PUSH
22695: LD_VAR 0 3
22699: PUSH
22700: LD_VAR 0 4
22704: PUSH
22705: LD_VAR 0 5
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: LIST
22714: LIST
22715: ST_TO_ADDR
// exit ;
22716: GO 23130
// end ; _chassis := AvailableChassisList ( factory ) ;
22718: LD_ADDR_VAR 0 9
22722: PUSH
22723: LD_VAR 0 1
22727: PPUSH
22728: CALL_OW 475
22732: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22733: LD_ADDR_VAR 0 11
22737: PUSH
22738: LD_VAR 0 1
22742: PPUSH
22743: CALL_OW 476
22747: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22748: LD_ADDR_VAR 0 12
22752: PUSH
22753: LD_VAR 0 1
22757: PPUSH
22758: CALL_OW 477
22762: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22763: LD_ADDR_VAR 0 10
22767: PUSH
22768: LD_VAR 0 1
22772: PPUSH
22773: CALL_OW 478
22777: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22778: LD_VAR 0 9
22782: NOT
22783: PUSH
22784: LD_VAR 0 11
22788: NOT
22789: OR
22790: PUSH
22791: LD_VAR 0 12
22795: NOT
22796: OR
22797: PUSH
22798: LD_VAR 0 10
22802: NOT
22803: OR
22804: IFFALSE 22839
// begin result := [ chassis , engine , control , weapon ] ;
22806: LD_ADDR_VAR 0 6
22810: PUSH
22811: LD_VAR 0 2
22815: PUSH
22816: LD_VAR 0 3
22820: PUSH
22821: LD_VAR 0 4
22825: PUSH
22826: LD_VAR 0 5
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: ST_TO_ADDR
// exit ;
22837: GO 23130
// end ; if not chassis in _chassis then
22839: LD_VAR 0 2
22843: PUSH
22844: LD_VAR 0 9
22848: IN
22849: NOT
22850: IFFALSE 22876
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22852: LD_ADDR_VAR 0 2
22856: PUSH
22857: LD_VAR 0 9
22861: PUSH
22862: LD_INT 1
22864: PPUSH
22865: LD_VAR 0 9
22869: PPUSH
22870: CALL_OW 12
22874: ARRAY
22875: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22876: LD_VAR 0 2
22880: PPUSH
22881: LD_VAR 0 3
22885: PPUSH
22886: CALL 23135 0 2
22890: NOT
22891: IFFALSE 22950
// repeat engine := _engine [ 1 ] ;
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_VAR 0 11
22902: PUSH
22903: LD_INT 1
22905: ARRAY
22906: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22907: LD_ADDR_VAR 0 11
22911: PUSH
22912: LD_VAR 0 11
22916: PPUSH
22917: LD_INT 1
22919: PPUSH
22920: CALL_OW 3
22924: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22925: LD_VAR 0 2
22929: PPUSH
22930: LD_VAR 0 3
22934: PPUSH
22935: CALL 23135 0 2
22939: PUSH
22940: LD_VAR 0 11
22944: PUSH
22945: EMPTY
22946: EQUAL
22947: OR
22948: IFFALSE 22893
// if not control in _control then
22950: LD_VAR 0 4
22954: PUSH
22955: LD_VAR 0 12
22959: IN
22960: NOT
22961: IFFALSE 22987
// control := _control [ rand ( 1 , _control ) ] ;
22963: LD_ADDR_VAR 0 4
22967: PUSH
22968: LD_VAR 0 12
22972: PUSH
22973: LD_INT 1
22975: PPUSH
22976: LD_VAR 0 12
22980: PPUSH
22981: CALL_OW 12
22985: ARRAY
22986: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22987: LD_VAR 0 2
22991: PPUSH
22992: LD_VAR 0 5
22996: PPUSH
22997: CALL 23355 0 2
23001: NOT
23002: IFFALSE 23061
// repeat weapon := _weapon [ 1 ] ;
23004: LD_ADDR_VAR 0 5
23008: PUSH
23009: LD_VAR 0 10
23013: PUSH
23014: LD_INT 1
23016: ARRAY
23017: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
23018: LD_ADDR_VAR 0 10
23022: PUSH
23023: LD_VAR 0 10
23027: PPUSH
23028: LD_INT 1
23030: PPUSH
23031: CALL_OW 3
23035: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
23036: LD_VAR 0 2
23040: PPUSH
23041: LD_VAR 0 5
23045: PPUSH
23046: CALL 23355 0 2
23050: PUSH
23051: LD_VAR 0 10
23055: PUSH
23056: EMPTY
23057: EQUAL
23058: OR
23059: IFFALSE 23004
// result := [ ] ;
23061: LD_ADDR_VAR 0 6
23065: PUSH
23066: EMPTY
23067: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
23068: LD_VAR 0 1
23072: PPUSH
23073: LD_VAR 0 2
23077: PPUSH
23078: LD_VAR 0 3
23082: PPUSH
23083: LD_VAR 0 4
23087: PPUSH
23088: LD_VAR 0 5
23092: PPUSH
23093: CALL_OW 448
23097: IFFALSE 23130
// result := [ chassis , engine , control , weapon ] ;
23099: LD_ADDR_VAR 0 6
23103: PUSH
23104: LD_VAR 0 2
23108: PUSH
23109: LD_VAR 0 3
23113: PUSH
23114: LD_VAR 0 4
23118: PUSH
23119: LD_VAR 0 5
23123: PUSH
23124: EMPTY
23125: LIST
23126: LIST
23127: LIST
23128: LIST
23129: ST_TO_ADDR
// end ;
23130: LD_VAR 0 6
23134: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
23135: LD_INT 0
23137: PPUSH
// if not chassis or not engine then
23138: LD_VAR 0 1
23142: NOT
23143: PUSH
23144: LD_VAR 0 2
23148: NOT
23149: OR
23150: IFFALSE 23154
// exit ;
23152: GO 23350
// case engine of engine_solar :
23154: LD_VAR 0 2
23158: PUSH
23159: LD_INT 2
23161: DOUBLE
23162: EQUAL
23163: IFTRUE 23167
23165: GO 23205
23167: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
23168: LD_ADDR_VAR 0 3
23172: PUSH
23173: LD_INT 11
23175: PUSH
23176: LD_INT 12
23178: PUSH
23179: LD_INT 13
23181: PUSH
23182: LD_INT 14
23184: PUSH
23185: LD_INT 1
23187: PUSH
23188: LD_INT 2
23190: PUSH
23191: LD_INT 3
23193: PUSH
23194: EMPTY
23195: LIST
23196: LIST
23197: LIST
23198: LIST
23199: LIST
23200: LIST
23201: LIST
23202: ST_TO_ADDR
23203: GO 23334
23205: LD_INT 1
23207: DOUBLE
23208: EQUAL
23209: IFTRUE 23213
23211: GO 23275
23213: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23214: LD_ADDR_VAR 0 3
23218: PUSH
23219: LD_INT 11
23221: PUSH
23222: LD_INT 12
23224: PUSH
23225: LD_INT 13
23227: PUSH
23228: LD_INT 14
23230: PUSH
23231: LD_INT 1
23233: PUSH
23234: LD_INT 2
23236: PUSH
23237: LD_INT 3
23239: PUSH
23240: LD_INT 4
23242: PUSH
23243: LD_INT 5
23245: PUSH
23246: LD_INT 21
23248: PUSH
23249: LD_INT 23
23251: PUSH
23252: LD_INT 22
23254: PUSH
23255: LD_INT 24
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: LIST
23266: LIST
23267: LIST
23268: LIST
23269: LIST
23270: LIST
23271: LIST
23272: ST_TO_ADDR
23273: GO 23334
23275: LD_INT 3
23277: DOUBLE
23278: EQUAL
23279: IFTRUE 23283
23281: GO 23333
23283: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23284: LD_ADDR_VAR 0 3
23288: PUSH
23289: LD_INT 13
23291: PUSH
23292: LD_INT 14
23294: PUSH
23295: LD_INT 2
23297: PUSH
23298: LD_INT 3
23300: PUSH
23301: LD_INT 4
23303: PUSH
23304: LD_INT 5
23306: PUSH
23307: LD_INT 21
23309: PUSH
23310: LD_INT 22
23312: PUSH
23313: LD_INT 23
23315: PUSH
23316: LD_INT 24
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: ST_TO_ADDR
23331: GO 23334
23333: POP
// result := ( chassis in result ) ;
23334: LD_ADDR_VAR 0 3
23338: PUSH
23339: LD_VAR 0 1
23343: PUSH
23344: LD_VAR 0 3
23348: IN
23349: ST_TO_ADDR
// end ;
23350: LD_VAR 0 3
23354: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23355: LD_INT 0
23357: PPUSH
// if not chassis or not weapon then
23358: LD_VAR 0 1
23362: NOT
23363: PUSH
23364: LD_VAR 0 2
23368: NOT
23369: OR
23370: IFFALSE 23374
// exit ;
23372: GO 24434
// case weapon of us_machine_gun :
23374: LD_VAR 0 2
23378: PUSH
23379: LD_INT 2
23381: DOUBLE
23382: EQUAL
23383: IFTRUE 23387
23385: GO 23417
23387: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23388: LD_ADDR_VAR 0 3
23392: PUSH
23393: LD_INT 1
23395: PUSH
23396: LD_INT 2
23398: PUSH
23399: LD_INT 3
23401: PUSH
23402: LD_INT 4
23404: PUSH
23405: LD_INT 5
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: ST_TO_ADDR
23415: GO 24418
23417: LD_INT 3
23419: DOUBLE
23420: EQUAL
23421: IFTRUE 23425
23423: GO 23455
23425: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23426: LD_ADDR_VAR 0 3
23430: PUSH
23431: LD_INT 1
23433: PUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 3
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: LD_INT 5
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: LIST
23452: ST_TO_ADDR
23453: GO 24418
23455: LD_INT 11
23457: DOUBLE
23458: EQUAL
23459: IFTRUE 23463
23461: GO 23493
23463: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23464: LD_ADDR_VAR 0 3
23468: PUSH
23469: LD_INT 1
23471: PUSH
23472: LD_INT 2
23474: PUSH
23475: LD_INT 3
23477: PUSH
23478: LD_INT 4
23480: PUSH
23481: LD_INT 5
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: LIST
23488: LIST
23489: LIST
23490: ST_TO_ADDR
23491: GO 24418
23493: LD_INT 4
23495: DOUBLE
23496: EQUAL
23497: IFTRUE 23501
23499: GO 23527
23501: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23502: LD_ADDR_VAR 0 3
23506: PUSH
23507: LD_INT 2
23509: PUSH
23510: LD_INT 3
23512: PUSH
23513: LD_INT 4
23515: PUSH
23516: LD_INT 5
23518: PUSH
23519: EMPTY
23520: LIST
23521: LIST
23522: LIST
23523: LIST
23524: ST_TO_ADDR
23525: GO 24418
23527: LD_INT 5
23529: DOUBLE
23530: EQUAL
23531: IFTRUE 23535
23533: GO 23561
23535: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23536: LD_ADDR_VAR 0 3
23540: PUSH
23541: LD_INT 2
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 4
23549: PUSH
23550: LD_INT 5
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: LIST
23557: LIST
23558: ST_TO_ADDR
23559: GO 24418
23561: LD_INT 9
23563: DOUBLE
23564: EQUAL
23565: IFTRUE 23569
23567: GO 23595
23569: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23570: LD_ADDR_VAR 0 3
23574: PUSH
23575: LD_INT 2
23577: PUSH
23578: LD_INT 3
23580: PUSH
23581: LD_INT 4
23583: PUSH
23584: LD_INT 5
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: LIST
23591: LIST
23592: ST_TO_ADDR
23593: GO 24418
23595: LD_INT 7
23597: DOUBLE
23598: EQUAL
23599: IFTRUE 23603
23601: GO 23629
23603: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23604: LD_ADDR_VAR 0 3
23608: PUSH
23609: LD_INT 2
23611: PUSH
23612: LD_INT 3
23614: PUSH
23615: LD_INT 4
23617: PUSH
23618: LD_INT 5
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: LIST
23625: LIST
23626: ST_TO_ADDR
23627: GO 24418
23629: LD_INT 12
23631: DOUBLE
23632: EQUAL
23633: IFTRUE 23637
23635: GO 23663
23637: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23638: LD_ADDR_VAR 0 3
23642: PUSH
23643: LD_INT 2
23645: PUSH
23646: LD_INT 3
23648: PUSH
23649: LD_INT 4
23651: PUSH
23652: LD_INT 5
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: LIST
23659: LIST
23660: ST_TO_ADDR
23661: GO 24418
23663: LD_INT 13
23665: DOUBLE
23666: EQUAL
23667: IFTRUE 23671
23669: GO 23697
23671: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23672: LD_ADDR_VAR 0 3
23676: PUSH
23677: LD_INT 2
23679: PUSH
23680: LD_INT 3
23682: PUSH
23683: LD_INT 4
23685: PUSH
23686: LD_INT 5
23688: PUSH
23689: EMPTY
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: ST_TO_ADDR
23695: GO 24418
23697: LD_INT 14
23699: DOUBLE
23700: EQUAL
23701: IFTRUE 23705
23703: GO 23723
23705: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23706: LD_ADDR_VAR 0 3
23710: PUSH
23711: LD_INT 4
23713: PUSH
23714: LD_INT 5
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: ST_TO_ADDR
23721: GO 24418
23723: LD_INT 6
23725: DOUBLE
23726: EQUAL
23727: IFTRUE 23731
23729: GO 23749
23731: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23732: LD_ADDR_VAR 0 3
23736: PUSH
23737: LD_INT 4
23739: PUSH
23740: LD_INT 5
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: ST_TO_ADDR
23747: GO 24418
23749: LD_INT 10
23751: DOUBLE
23752: EQUAL
23753: IFTRUE 23757
23755: GO 23775
23757: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23758: LD_ADDR_VAR 0 3
23762: PUSH
23763: LD_INT 4
23765: PUSH
23766: LD_INT 5
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: ST_TO_ADDR
23773: GO 24418
23775: LD_INT 22
23777: DOUBLE
23778: EQUAL
23779: IFTRUE 23783
23781: GO 23809
23783: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23784: LD_ADDR_VAR 0 3
23788: PUSH
23789: LD_INT 11
23791: PUSH
23792: LD_INT 12
23794: PUSH
23795: LD_INT 13
23797: PUSH
23798: LD_INT 14
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: LIST
23805: LIST
23806: ST_TO_ADDR
23807: GO 24418
23809: LD_INT 23
23811: DOUBLE
23812: EQUAL
23813: IFTRUE 23817
23815: GO 23843
23817: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23818: LD_ADDR_VAR 0 3
23822: PUSH
23823: LD_INT 11
23825: PUSH
23826: LD_INT 12
23828: PUSH
23829: LD_INT 13
23831: PUSH
23832: LD_INT 14
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: ST_TO_ADDR
23841: GO 24418
23843: LD_INT 24
23845: DOUBLE
23846: EQUAL
23847: IFTRUE 23851
23849: GO 23877
23851: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23852: LD_ADDR_VAR 0 3
23856: PUSH
23857: LD_INT 11
23859: PUSH
23860: LD_INT 12
23862: PUSH
23863: LD_INT 13
23865: PUSH
23866: LD_INT 14
23868: PUSH
23869: EMPTY
23870: LIST
23871: LIST
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 24418
23877: LD_INT 30
23879: DOUBLE
23880: EQUAL
23881: IFTRUE 23885
23883: GO 23911
23885: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23886: LD_ADDR_VAR 0 3
23890: PUSH
23891: LD_INT 11
23893: PUSH
23894: LD_INT 12
23896: PUSH
23897: LD_INT 13
23899: PUSH
23900: LD_INT 14
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: LIST
23907: LIST
23908: ST_TO_ADDR
23909: GO 24418
23911: LD_INT 25
23913: DOUBLE
23914: EQUAL
23915: IFTRUE 23919
23917: GO 23937
23919: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23920: LD_ADDR_VAR 0 3
23924: PUSH
23925: LD_INT 13
23927: PUSH
23928: LD_INT 14
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: ST_TO_ADDR
23935: GO 24418
23937: LD_INT 27
23939: DOUBLE
23940: EQUAL
23941: IFTRUE 23945
23943: GO 23963
23945: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23946: LD_ADDR_VAR 0 3
23950: PUSH
23951: LD_INT 13
23953: PUSH
23954: LD_INT 14
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: ST_TO_ADDR
23961: GO 24418
23963: LD_INT 92
23965: DOUBLE
23966: EQUAL
23967: IFTRUE 23971
23969: GO 23997
23971: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23972: LD_ADDR_VAR 0 3
23976: PUSH
23977: LD_INT 11
23979: PUSH
23980: LD_INT 12
23982: PUSH
23983: LD_INT 13
23985: PUSH
23986: LD_INT 14
23988: PUSH
23989: EMPTY
23990: LIST
23991: LIST
23992: LIST
23993: LIST
23994: ST_TO_ADDR
23995: GO 24418
23997: LD_INT 28
23999: DOUBLE
24000: EQUAL
24001: IFTRUE 24005
24003: GO 24023
24005: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
24006: LD_ADDR_VAR 0 3
24010: PUSH
24011: LD_INT 13
24013: PUSH
24014: LD_INT 14
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: ST_TO_ADDR
24021: GO 24418
24023: LD_INT 29
24025: DOUBLE
24026: EQUAL
24027: IFTRUE 24031
24029: GO 24049
24031: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
24032: LD_ADDR_VAR 0 3
24036: PUSH
24037: LD_INT 13
24039: PUSH
24040: LD_INT 14
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: ST_TO_ADDR
24047: GO 24418
24049: LD_INT 31
24051: DOUBLE
24052: EQUAL
24053: IFTRUE 24057
24055: GO 24075
24057: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
24058: LD_ADDR_VAR 0 3
24062: PUSH
24063: LD_INT 13
24065: PUSH
24066: LD_INT 14
24068: PUSH
24069: EMPTY
24070: LIST
24071: LIST
24072: ST_TO_ADDR
24073: GO 24418
24075: LD_INT 26
24077: DOUBLE
24078: EQUAL
24079: IFTRUE 24083
24081: GO 24101
24083: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
24084: LD_ADDR_VAR 0 3
24088: PUSH
24089: LD_INT 13
24091: PUSH
24092: LD_INT 14
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: ST_TO_ADDR
24099: GO 24418
24101: LD_INT 42
24103: DOUBLE
24104: EQUAL
24105: IFTRUE 24109
24107: GO 24135
24109: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
24110: LD_ADDR_VAR 0 3
24114: PUSH
24115: LD_INT 21
24117: PUSH
24118: LD_INT 22
24120: PUSH
24121: LD_INT 23
24123: PUSH
24124: LD_INT 24
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: ST_TO_ADDR
24133: GO 24418
24135: LD_INT 43
24137: DOUBLE
24138: EQUAL
24139: IFTRUE 24143
24141: GO 24169
24143: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
24144: LD_ADDR_VAR 0 3
24148: PUSH
24149: LD_INT 21
24151: PUSH
24152: LD_INT 22
24154: PUSH
24155: LD_INT 23
24157: PUSH
24158: LD_INT 24
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: ST_TO_ADDR
24167: GO 24418
24169: LD_INT 44
24171: DOUBLE
24172: EQUAL
24173: IFTRUE 24177
24175: GO 24203
24177: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24178: LD_ADDR_VAR 0 3
24182: PUSH
24183: LD_INT 21
24185: PUSH
24186: LD_INT 22
24188: PUSH
24189: LD_INT 23
24191: PUSH
24192: LD_INT 24
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: LIST
24199: LIST
24200: ST_TO_ADDR
24201: GO 24418
24203: LD_INT 45
24205: DOUBLE
24206: EQUAL
24207: IFTRUE 24211
24209: GO 24237
24211: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24212: LD_ADDR_VAR 0 3
24216: PUSH
24217: LD_INT 21
24219: PUSH
24220: LD_INT 22
24222: PUSH
24223: LD_INT 23
24225: PUSH
24226: LD_INT 24
24228: PUSH
24229: EMPTY
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: ST_TO_ADDR
24235: GO 24418
24237: LD_INT 49
24239: DOUBLE
24240: EQUAL
24241: IFTRUE 24245
24243: GO 24271
24245: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24246: LD_ADDR_VAR 0 3
24250: PUSH
24251: LD_INT 21
24253: PUSH
24254: LD_INT 22
24256: PUSH
24257: LD_INT 23
24259: PUSH
24260: LD_INT 24
24262: PUSH
24263: EMPTY
24264: LIST
24265: LIST
24266: LIST
24267: LIST
24268: ST_TO_ADDR
24269: GO 24418
24271: LD_INT 51
24273: DOUBLE
24274: EQUAL
24275: IFTRUE 24279
24277: GO 24305
24279: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24280: LD_ADDR_VAR 0 3
24284: PUSH
24285: LD_INT 21
24287: PUSH
24288: LD_INT 22
24290: PUSH
24291: LD_INT 23
24293: PUSH
24294: LD_INT 24
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: ST_TO_ADDR
24303: GO 24418
24305: LD_INT 52
24307: DOUBLE
24308: EQUAL
24309: IFTRUE 24313
24311: GO 24339
24313: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24314: LD_ADDR_VAR 0 3
24318: PUSH
24319: LD_INT 21
24321: PUSH
24322: LD_INT 22
24324: PUSH
24325: LD_INT 23
24327: PUSH
24328: LD_INT 24
24330: PUSH
24331: EMPTY
24332: LIST
24333: LIST
24334: LIST
24335: LIST
24336: ST_TO_ADDR
24337: GO 24418
24339: LD_INT 53
24341: DOUBLE
24342: EQUAL
24343: IFTRUE 24347
24345: GO 24365
24347: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24348: LD_ADDR_VAR 0 3
24352: PUSH
24353: LD_INT 23
24355: PUSH
24356: LD_INT 24
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: ST_TO_ADDR
24363: GO 24418
24365: LD_INT 46
24367: DOUBLE
24368: EQUAL
24369: IFTRUE 24373
24371: GO 24391
24373: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24374: LD_ADDR_VAR 0 3
24378: PUSH
24379: LD_INT 23
24381: PUSH
24382: LD_INT 24
24384: PUSH
24385: EMPTY
24386: LIST
24387: LIST
24388: ST_TO_ADDR
24389: GO 24418
24391: LD_INT 47
24393: DOUBLE
24394: EQUAL
24395: IFTRUE 24399
24397: GO 24417
24399: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24400: LD_ADDR_VAR 0 3
24404: PUSH
24405: LD_INT 23
24407: PUSH
24408: LD_INT 24
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: ST_TO_ADDR
24415: GO 24418
24417: POP
// result := ( chassis in result ) ;
24418: LD_ADDR_VAR 0 3
24422: PUSH
24423: LD_VAR 0 1
24427: PUSH
24428: LD_VAR 0 3
24432: IN
24433: ST_TO_ADDR
// end ;
24434: LD_VAR 0 3
24438: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24439: LD_INT 0
24441: PPUSH
24442: PPUSH
24443: PPUSH
24444: PPUSH
24445: PPUSH
24446: PPUSH
24447: PPUSH
// result := array ;
24448: LD_ADDR_VAR 0 5
24452: PUSH
24453: LD_VAR 0 1
24457: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24458: LD_VAR 0 1
24462: NOT
24463: PUSH
24464: LD_VAR 0 2
24468: NOT
24469: OR
24470: PUSH
24471: LD_VAR 0 3
24475: NOT
24476: OR
24477: PUSH
24478: LD_VAR 0 2
24482: PUSH
24483: LD_VAR 0 1
24487: GREATER
24488: OR
24489: PUSH
24490: LD_VAR 0 3
24494: PUSH
24495: LD_VAR 0 1
24499: GREATER
24500: OR
24501: IFFALSE 24505
// exit ;
24503: GO 24801
// if direction then
24505: LD_VAR 0 4
24509: IFFALSE 24573
// begin d := 1 ;
24511: LD_ADDR_VAR 0 9
24515: PUSH
24516: LD_INT 1
24518: ST_TO_ADDR
// if i_from > i_to then
24519: LD_VAR 0 2
24523: PUSH
24524: LD_VAR 0 3
24528: GREATER
24529: IFFALSE 24555
// length := ( array - i_from ) + i_to else
24531: LD_ADDR_VAR 0 11
24535: PUSH
24536: LD_VAR 0 1
24540: PUSH
24541: LD_VAR 0 2
24545: MINUS
24546: PUSH
24547: LD_VAR 0 3
24551: PLUS
24552: ST_TO_ADDR
24553: GO 24571
// length := i_to - i_from ;
24555: LD_ADDR_VAR 0 11
24559: PUSH
24560: LD_VAR 0 3
24564: PUSH
24565: LD_VAR 0 2
24569: MINUS
24570: ST_TO_ADDR
// end else
24571: GO 24634
// begin d := - 1 ;
24573: LD_ADDR_VAR 0 9
24577: PUSH
24578: LD_INT 1
24580: NEG
24581: ST_TO_ADDR
// if i_from > i_to then
24582: LD_VAR 0 2
24586: PUSH
24587: LD_VAR 0 3
24591: GREATER
24592: IFFALSE 24612
// length := i_from - i_to else
24594: LD_ADDR_VAR 0 11
24598: PUSH
24599: LD_VAR 0 2
24603: PUSH
24604: LD_VAR 0 3
24608: MINUS
24609: ST_TO_ADDR
24610: GO 24634
// length := ( array - i_to ) + i_from ;
24612: LD_ADDR_VAR 0 11
24616: PUSH
24617: LD_VAR 0 1
24621: PUSH
24622: LD_VAR 0 3
24626: MINUS
24627: PUSH
24628: LD_VAR 0 2
24632: PLUS
24633: ST_TO_ADDR
// end ; if not length then
24634: LD_VAR 0 11
24638: NOT
24639: IFFALSE 24643
// exit ;
24641: GO 24801
// tmp := array ;
24643: LD_ADDR_VAR 0 10
24647: PUSH
24648: LD_VAR 0 1
24652: ST_TO_ADDR
// for i = 1 to length do
24653: LD_ADDR_VAR 0 6
24657: PUSH
24658: DOUBLE
24659: LD_INT 1
24661: DEC
24662: ST_TO_ADDR
24663: LD_VAR 0 11
24667: PUSH
24668: FOR_TO
24669: IFFALSE 24789
// begin for j = 1 to array do
24671: LD_ADDR_VAR 0 7
24675: PUSH
24676: DOUBLE
24677: LD_INT 1
24679: DEC
24680: ST_TO_ADDR
24681: LD_VAR 0 1
24685: PUSH
24686: FOR_TO
24687: IFFALSE 24775
// begin k := j + d ;
24689: LD_ADDR_VAR 0 8
24693: PUSH
24694: LD_VAR 0 7
24698: PUSH
24699: LD_VAR 0 9
24703: PLUS
24704: ST_TO_ADDR
// if k > array then
24705: LD_VAR 0 8
24709: PUSH
24710: LD_VAR 0 1
24714: GREATER
24715: IFFALSE 24725
// k := 1 ;
24717: LD_ADDR_VAR 0 8
24721: PUSH
24722: LD_INT 1
24724: ST_TO_ADDR
// if not k then
24725: LD_VAR 0 8
24729: NOT
24730: IFFALSE 24742
// k := array ;
24732: LD_ADDR_VAR 0 8
24736: PUSH
24737: LD_VAR 0 1
24741: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24742: LD_ADDR_VAR 0 10
24746: PUSH
24747: LD_VAR 0 10
24751: PPUSH
24752: LD_VAR 0 8
24756: PPUSH
24757: LD_VAR 0 1
24761: PUSH
24762: LD_VAR 0 7
24766: ARRAY
24767: PPUSH
24768: CALL_OW 1
24772: ST_TO_ADDR
// end ;
24773: GO 24686
24775: POP
24776: POP
// array := tmp ;
24777: LD_ADDR_VAR 0 1
24781: PUSH
24782: LD_VAR 0 10
24786: ST_TO_ADDR
// end ;
24787: GO 24668
24789: POP
24790: POP
// result := array ;
24791: LD_ADDR_VAR 0 5
24795: PUSH
24796: LD_VAR 0 1
24800: ST_TO_ADDR
// end ;
24801: LD_VAR 0 5
24805: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24806: LD_INT 0
24808: PPUSH
24809: PPUSH
// result := 0 ;
24810: LD_ADDR_VAR 0 3
24814: PUSH
24815: LD_INT 0
24817: ST_TO_ADDR
// if not array or not value in array then
24818: LD_VAR 0 1
24822: NOT
24823: PUSH
24824: LD_VAR 0 2
24828: PUSH
24829: LD_VAR 0 1
24833: IN
24834: NOT
24835: OR
24836: IFFALSE 24840
// exit ;
24838: GO 24894
// for i = 1 to array do
24840: LD_ADDR_VAR 0 4
24844: PUSH
24845: DOUBLE
24846: LD_INT 1
24848: DEC
24849: ST_TO_ADDR
24850: LD_VAR 0 1
24854: PUSH
24855: FOR_TO
24856: IFFALSE 24892
// if value = array [ i ] then
24858: LD_VAR 0 2
24862: PUSH
24863: LD_VAR 0 1
24867: PUSH
24868: LD_VAR 0 4
24872: ARRAY
24873: EQUAL
24874: IFFALSE 24890
// begin result := i ;
24876: LD_ADDR_VAR 0 3
24880: PUSH
24881: LD_VAR 0 4
24885: ST_TO_ADDR
// exit ;
24886: POP
24887: POP
24888: GO 24894
// end ;
24890: GO 24855
24892: POP
24893: POP
// end ;
24894: LD_VAR 0 3
24898: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24899: LD_INT 0
24901: PPUSH
// vc_chassis := chassis ;
24902: LD_ADDR_OWVAR 37
24906: PUSH
24907: LD_VAR 0 1
24911: ST_TO_ADDR
// vc_engine := engine ;
24912: LD_ADDR_OWVAR 39
24916: PUSH
24917: LD_VAR 0 2
24921: ST_TO_ADDR
// vc_control := control ;
24922: LD_ADDR_OWVAR 38
24926: PUSH
24927: LD_VAR 0 3
24931: ST_TO_ADDR
// vc_weapon := weapon ;
24932: LD_ADDR_OWVAR 40
24936: PUSH
24937: LD_VAR 0 4
24941: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24942: LD_ADDR_OWVAR 41
24946: PUSH
24947: LD_VAR 0 5
24951: ST_TO_ADDR
// end ;
24952: LD_VAR 0 6
24956: RET
// export function WantPlant ( unit ) ; var task ; begin
24957: LD_INT 0
24959: PPUSH
24960: PPUSH
// result := false ;
24961: LD_ADDR_VAR 0 2
24965: PUSH
24966: LD_INT 0
24968: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24969: LD_ADDR_VAR 0 3
24973: PUSH
24974: LD_VAR 0 1
24978: PPUSH
24979: CALL_OW 437
24983: ST_TO_ADDR
// if task then
24984: LD_VAR 0 3
24988: IFFALSE 25016
// if task [ 1 ] [ 1 ] = p then
24990: LD_VAR 0 3
24994: PUSH
24995: LD_INT 1
24997: ARRAY
24998: PUSH
24999: LD_INT 1
25001: ARRAY
25002: PUSH
25003: LD_STRING p
25005: EQUAL
25006: IFFALSE 25016
// result := true ;
25008: LD_ADDR_VAR 0 2
25012: PUSH
25013: LD_INT 1
25015: ST_TO_ADDR
// end ;
25016: LD_VAR 0 2
25020: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
25021: LD_INT 0
25023: PPUSH
25024: PPUSH
25025: PPUSH
25026: PPUSH
// if pos < 1 then
25027: LD_VAR 0 2
25031: PUSH
25032: LD_INT 1
25034: LESS
25035: IFFALSE 25039
// exit ;
25037: GO 25342
// if pos = 1 then
25039: LD_VAR 0 2
25043: PUSH
25044: LD_INT 1
25046: EQUAL
25047: IFFALSE 25080
// result := Replace ( arr , pos [ 1 ] , value ) else
25049: LD_ADDR_VAR 0 4
25053: PUSH
25054: LD_VAR 0 1
25058: PPUSH
25059: LD_VAR 0 2
25063: PUSH
25064: LD_INT 1
25066: ARRAY
25067: PPUSH
25068: LD_VAR 0 3
25072: PPUSH
25073: CALL_OW 1
25077: ST_TO_ADDR
25078: GO 25342
// begin tmp := arr ;
25080: LD_ADDR_VAR 0 6
25084: PUSH
25085: LD_VAR 0 1
25089: ST_TO_ADDR
// s_arr := [ tmp ] ;
25090: LD_ADDR_VAR 0 7
25094: PUSH
25095: LD_VAR 0 6
25099: PUSH
25100: EMPTY
25101: LIST
25102: ST_TO_ADDR
// for i = 1 to pos - 1 do
25103: LD_ADDR_VAR 0 5
25107: PUSH
25108: DOUBLE
25109: LD_INT 1
25111: DEC
25112: ST_TO_ADDR
25113: LD_VAR 0 2
25117: PUSH
25118: LD_INT 1
25120: MINUS
25121: PUSH
25122: FOR_TO
25123: IFFALSE 25168
// begin tmp := tmp [ pos [ i ] ] ;
25125: LD_ADDR_VAR 0 6
25129: PUSH
25130: LD_VAR 0 6
25134: PUSH
25135: LD_VAR 0 2
25139: PUSH
25140: LD_VAR 0 5
25144: ARRAY
25145: ARRAY
25146: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
25147: LD_ADDR_VAR 0 7
25151: PUSH
25152: LD_VAR 0 7
25156: PUSH
25157: LD_VAR 0 6
25161: PUSH
25162: EMPTY
25163: LIST
25164: ADD
25165: ST_TO_ADDR
// end ;
25166: GO 25122
25168: POP
25169: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
25170: LD_ADDR_VAR 0 6
25174: PUSH
25175: LD_VAR 0 6
25179: PPUSH
25180: LD_VAR 0 2
25184: PUSH
25185: LD_VAR 0 2
25189: ARRAY
25190: PPUSH
25191: LD_VAR 0 3
25195: PPUSH
25196: CALL_OW 1
25200: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25201: LD_ADDR_VAR 0 7
25205: PUSH
25206: LD_VAR 0 7
25210: PPUSH
25211: LD_VAR 0 7
25215: PPUSH
25216: LD_VAR 0 6
25220: PPUSH
25221: CALL_OW 1
25225: ST_TO_ADDR
// for i = s_arr downto 2 do
25226: LD_ADDR_VAR 0 5
25230: PUSH
25231: DOUBLE
25232: LD_VAR 0 7
25236: INC
25237: ST_TO_ADDR
25238: LD_INT 2
25240: PUSH
25241: FOR_DOWNTO
25242: IFFALSE 25326
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 7
25253: PUSH
25254: LD_VAR 0 5
25258: PUSH
25259: LD_INT 1
25261: MINUS
25262: ARRAY
25263: PPUSH
25264: LD_VAR 0 2
25268: PUSH
25269: LD_VAR 0 5
25273: PUSH
25274: LD_INT 1
25276: MINUS
25277: ARRAY
25278: PPUSH
25279: LD_VAR 0 7
25283: PUSH
25284: LD_VAR 0 5
25288: ARRAY
25289: PPUSH
25290: CALL_OW 1
25294: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25295: LD_ADDR_VAR 0 7
25299: PUSH
25300: LD_VAR 0 7
25304: PPUSH
25305: LD_VAR 0 5
25309: PUSH
25310: LD_INT 1
25312: MINUS
25313: PPUSH
25314: LD_VAR 0 6
25318: PPUSH
25319: CALL_OW 1
25323: ST_TO_ADDR
// end ;
25324: GO 25241
25326: POP
25327: POP
// result := s_arr [ 1 ] ;
25328: LD_ADDR_VAR 0 4
25332: PUSH
25333: LD_VAR 0 7
25337: PUSH
25338: LD_INT 1
25340: ARRAY
25341: ST_TO_ADDR
// end ; end ;
25342: LD_VAR 0 4
25346: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25347: LD_INT 0
25349: PPUSH
25350: PPUSH
// if not list then
25351: LD_VAR 0 1
25355: NOT
25356: IFFALSE 25360
// exit ;
25358: GO 25451
// i := list [ pos1 ] ;
25360: LD_ADDR_VAR 0 5
25364: PUSH
25365: LD_VAR 0 1
25369: PUSH
25370: LD_VAR 0 2
25374: ARRAY
25375: ST_TO_ADDR
// if not i then
25376: LD_VAR 0 5
25380: NOT
25381: IFFALSE 25385
// exit ;
25383: GO 25451
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25385: LD_ADDR_VAR 0 1
25389: PUSH
25390: LD_VAR 0 1
25394: PPUSH
25395: LD_VAR 0 2
25399: PPUSH
25400: LD_VAR 0 1
25404: PUSH
25405: LD_VAR 0 3
25409: ARRAY
25410: PPUSH
25411: CALL_OW 1
25415: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25416: LD_ADDR_VAR 0 1
25420: PUSH
25421: LD_VAR 0 1
25425: PPUSH
25426: LD_VAR 0 3
25430: PPUSH
25431: LD_VAR 0 5
25435: PPUSH
25436: CALL_OW 1
25440: ST_TO_ADDR
// result := list ;
25441: LD_ADDR_VAR 0 4
25445: PUSH
25446: LD_VAR 0 1
25450: ST_TO_ADDR
// end ;
25451: LD_VAR 0 4
25455: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25456: LD_INT 0
25458: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25459: LD_ADDR_VAR 0 5
25463: PUSH
25464: LD_VAR 0 1
25468: PPUSH
25469: CALL_OW 250
25473: PPUSH
25474: LD_VAR 0 1
25478: PPUSH
25479: CALL_OW 251
25483: PPUSH
25484: LD_VAR 0 2
25488: PPUSH
25489: LD_VAR 0 3
25493: PPUSH
25494: LD_VAR 0 4
25498: PPUSH
25499: CALL 25509 0 5
25503: ST_TO_ADDR
// end ;
25504: LD_VAR 0 5
25508: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25509: LD_INT 0
25511: PPUSH
25512: PPUSH
25513: PPUSH
25514: PPUSH
// if not list then
25515: LD_VAR 0 3
25519: NOT
25520: IFFALSE 25524
// exit ;
25522: GO 25912
// result := [ ] ;
25524: LD_ADDR_VAR 0 6
25528: PUSH
25529: EMPTY
25530: ST_TO_ADDR
// for i in list do
25531: LD_ADDR_VAR 0 7
25535: PUSH
25536: LD_VAR 0 3
25540: PUSH
25541: FOR_IN
25542: IFFALSE 25744
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25544: LD_ADDR_VAR 0 9
25548: PUSH
25549: LD_VAR 0 7
25553: PPUSH
25554: LD_VAR 0 1
25558: PPUSH
25559: LD_VAR 0 2
25563: PPUSH
25564: CALL_OW 297
25568: ST_TO_ADDR
// if not result then
25569: LD_VAR 0 6
25573: NOT
25574: IFFALSE 25600
// result := [ [ i , tmp ] ] else
25576: LD_ADDR_VAR 0 6
25580: PUSH
25581: LD_VAR 0 7
25585: PUSH
25586: LD_VAR 0 9
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: PUSH
25595: EMPTY
25596: LIST
25597: ST_TO_ADDR
25598: GO 25742
// begin if result [ result ] [ 2 ] < tmp then
25600: LD_VAR 0 6
25604: PUSH
25605: LD_VAR 0 6
25609: ARRAY
25610: PUSH
25611: LD_INT 2
25613: ARRAY
25614: PUSH
25615: LD_VAR 0 9
25619: LESS
25620: IFFALSE 25662
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25622: LD_ADDR_VAR 0 6
25626: PUSH
25627: LD_VAR 0 6
25631: PPUSH
25632: LD_VAR 0 6
25636: PUSH
25637: LD_INT 1
25639: PLUS
25640: PPUSH
25641: LD_VAR 0 7
25645: PUSH
25646: LD_VAR 0 9
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PPUSH
25655: CALL_OW 2
25659: ST_TO_ADDR
25660: GO 25742
// for j = 1 to result do
25662: LD_ADDR_VAR 0 8
25666: PUSH
25667: DOUBLE
25668: LD_INT 1
25670: DEC
25671: ST_TO_ADDR
25672: LD_VAR 0 6
25676: PUSH
25677: FOR_TO
25678: IFFALSE 25740
// begin if tmp < result [ j ] [ 2 ] then
25680: LD_VAR 0 9
25684: PUSH
25685: LD_VAR 0 6
25689: PUSH
25690: LD_VAR 0 8
25694: ARRAY
25695: PUSH
25696: LD_INT 2
25698: ARRAY
25699: LESS
25700: IFFALSE 25738
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25702: LD_ADDR_VAR 0 6
25706: PUSH
25707: LD_VAR 0 6
25711: PPUSH
25712: LD_VAR 0 8
25716: PPUSH
25717: LD_VAR 0 7
25721: PUSH
25722: LD_VAR 0 9
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PPUSH
25731: CALL_OW 2
25735: ST_TO_ADDR
// break ;
25736: GO 25740
// end ; end ;
25738: GO 25677
25740: POP
25741: POP
// end ; end ;
25742: GO 25541
25744: POP
25745: POP
// if result and not asc then
25746: LD_VAR 0 6
25750: PUSH
25751: LD_VAR 0 4
25755: NOT
25756: AND
25757: IFFALSE 25832
// begin tmp := result ;
25759: LD_ADDR_VAR 0 9
25763: PUSH
25764: LD_VAR 0 6
25768: ST_TO_ADDR
// for i = tmp downto 1 do
25769: LD_ADDR_VAR 0 7
25773: PUSH
25774: DOUBLE
25775: LD_VAR 0 9
25779: INC
25780: ST_TO_ADDR
25781: LD_INT 1
25783: PUSH
25784: FOR_DOWNTO
25785: IFFALSE 25830
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25787: LD_ADDR_VAR 0 6
25791: PUSH
25792: LD_VAR 0 6
25796: PPUSH
25797: LD_VAR 0 9
25801: PUSH
25802: LD_VAR 0 7
25806: MINUS
25807: PUSH
25808: LD_INT 1
25810: PLUS
25811: PPUSH
25812: LD_VAR 0 9
25816: PUSH
25817: LD_VAR 0 7
25821: ARRAY
25822: PPUSH
25823: CALL_OW 1
25827: ST_TO_ADDR
25828: GO 25784
25830: POP
25831: POP
// end ; tmp := [ ] ;
25832: LD_ADDR_VAR 0 9
25836: PUSH
25837: EMPTY
25838: ST_TO_ADDR
// if mode then
25839: LD_VAR 0 5
25843: IFFALSE 25912
// begin for i = 1 to result do
25845: LD_ADDR_VAR 0 7
25849: PUSH
25850: DOUBLE
25851: LD_INT 1
25853: DEC
25854: ST_TO_ADDR
25855: LD_VAR 0 6
25859: PUSH
25860: FOR_TO
25861: IFFALSE 25900
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25863: LD_ADDR_VAR 0 9
25867: PUSH
25868: LD_VAR 0 9
25872: PPUSH
25873: LD_VAR 0 7
25877: PPUSH
25878: LD_VAR 0 6
25882: PUSH
25883: LD_VAR 0 7
25887: ARRAY
25888: PUSH
25889: LD_INT 1
25891: ARRAY
25892: PPUSH
25893: CALL_OW 1
25897: ST_TO_ADDR
25898: GO 25860
25900: POP
25901: POP
// result := tmp ;
25902: LD_ADDR_VAR 0 6
25906: PUSH
25907: LD_VAR 0 9
25911: ST_TO_ADDR
// end ; end ;
25912: LD_VAR 0 6
25916: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25917: LD_INT 0
25919: PPUSH
25920: PPUSH
25921: PPUSH
25922: PPUSH
25923: PPUSH
25924: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25925: LD_ADDR_VAR 0 5
25929: PUSH
25930: LD_INT 0
25932: PUSH
25933: LD_INT 0
25935: PUSH
25936: LD_INT 0
25938: PUSH
25939: EMPTY
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: ST_TO_ADDR
// if not x or not y then
25947: LD_VAR 0 2
25951: NOT
25952: PUSH
25953: LD_VAR 0 3
25957: NOT
25958: OR
25959: IFFALSE 25963
// exit ;
25961: GO 27613
// if not range then
25963: LD_VAR 0 4
25967: NOT
25968: IFFALSE 25978
// range := 10 ;
25970: LD_ADDR_VAR 0 4
25974: PUSH
25975: LD_INT 10
25977: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25978: LD_ADDR_VAR 0 8
25982: PUSH
25983: LD_INT 81
25985: PUSH
25986: LD_VAR 0 1
25990: PUSH
25991: EMPTY
25992: LIST
25993: LIST
25994: PUSH
25995: LD_INT 92
25997: PUSH
25998: LD_VAR 0 2
26002: PUSH
26003: LD_VAR 0 3
26007: PUSH
26008: LD_VAR 0 4
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 3
26021: PUSH
26022: LD_INT 21
26024: PUSH
26025: LD_INT 3
26027: PUSH
26028: EMPTY
26029: LIST
26030: LIST
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: LIST
26040: PPUSH
26041: CALL_OW 69
26045: ST_TO_ADDR
// if not tmp then
26046: LD_VAR 0 8
26050: NOT
26051: IFFALSE 26055
// exit ;
26053: GO 27613
// for i in tmp do
26055: LD_ADDR_VAR 0 6
26059: PUSH
26060: LD_VAR 0 8
26064: PUSH
26065: FOR_IN
26066: IFFALSE 27588
// begin points := [ 0 , 0 , 0 ] ;
26068: LD_ADDR_VAR 0 9
26072: PUSH
26073: LD_INT 0
26075: PUSH
26076: LD_INT 0
26078: PUSH
26079: LD_INT 0
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: LIST
26086: ST_TO_ADDR
// bpoints := 1 ;
26087: LD_ADDR_VAR 0 10
26091: PUSH
26092: LD_INT 1
26094: ST_TO_ADDR
// case GetType ( i ) of unit_human :
26095: LD_VAR 0 6
26099: PPUSH
26100: CALL_OW 247
26104: PUSH
26105: LD_INT 1
26107: DOUBLE
26108: EQUAL
26109: IFTRUE 26113
26111: GO 26691
26113: POP
// begin if GetClass ( i ) = 1 then
26114: LD_VAR 0 6
26118: PPUSH
26119: CALL_OW 257
26123: PUSH
26124: LD_INT 1
26126: EQUAL
26127: IFFALSE 26148
// points := [ 10 , 5 , 3 ] ;
26129: LD_ADDR_VAR 0 9
26133: PUSH
26134: LD_INT 10
26136: PUSH
26137: LD_INT 5
26139: PUSH
26140: LD_INT 3
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: LIST
26147: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
26148: LD_VAR 0 6
26152: PPUSH
26153: CALL_OW 257
26157: PUSH
26158: LD_INT 2
26160: PUSH
26161: LD_INT 3
26163: PUSH
26164: LD_INT 4
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: LIST
26171: IN
26172: IFFALSE 26193
// points := [ 3 , 2 , 1 ] ;
26174: LD_ADDR_VAR 0 9
26178: PUSH
26179: LD_INT 3
26181: PUSH
26182: LD_INT 2
26184: PUSH
26185: LD_INT 1
26187: PUSH
26188: EMPTY
26189: LIST
26190: LIST
26191: LIST
26192: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26193: LD_VAR 0 6
26197: PPUSH
26198: CALL_OW 257
26202: PUSH
26203: LD_INT 5
26205: EQUAL
26206: IFFALSE 26227
// points := [ 130 , 5 , 2 ] ;
26208: LD_ADDR_VAR 0 9
26212: PUSH
26213: LD_INT 130
26215: PUSH
26216: LD_INT 5
26218: PUSH
26219: LD_INT 2
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: LIST
26226: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26227: LD_VAR 0 6
26231: PPUSH
26232: CALL_OW 257
26236: PUSH
26237: LD_INT 8
26239: EQUAL
26240: IFFALSE 26261
// points := [ 35 , 35 , 30 ] ;
26242: LD_ADDR_VAR 0 9
26246: PUSH
26247: LD_INT 35
26249: PUSH
26250: LD_INT 35
26252: PUSH
26253: LD_INT 30
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: LIST
26260: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26261: LD_VAR 0 6
26265: PPUSH
26266: CALL_OW 257
26270: PUSH
26271: LD_INT 9
26273: EQUAL
26274: IFFALSE 26295
// points := [ 20 , 55 , 40 ] ;
26276: LD_ADDR_VAR 0 9
26280: PUSH
26281: LD_INT 20
26283: PUSH
26284: LD_INT 55
26286: PUSH
26287: LD_INT 40
26289: PUSH
26290: EMPTY
26291: LIST
26292: LIST
26293: LIST
26294: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26295: LD_VAR 0 6
26299: PPUSH
26300: CALL_OW 257
26304: PUSH
26305: LD_INT 12
26307: PUSH
26308: LD_INT 16
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: IN
26315: IFFALSE 26336
// points := [ 5 , 3 , 2 ] ;
26317: LD_ADDR_VAR 0 9
26321: PUSH
26322: LD_INT 5
26324: PUSH
26325: LD_INT 3
26327: PUSH
26328: LD_INT 2
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26336: LD_VAR 0 6
26340: PPUSH
26341: CALL_OW 257
26345: PUSH
26346: LD_INT 17
26348: EQUAL
26349: IFFALSE 26370
// points := [ 100 , 50 , 75 ] ;
26351: LD_ADDR_VAR 0 9
26355: PUSH
26356: LD_INT 100
26358: PUSH
26359: LD_INT 50
26361: PUSH
26362: LD_INT 75
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: LIST
26369: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26370: LD_VAR 0 6
26374: PPUSH
26375: CALL_OW 257
26379: PUSH
26380: LD_INT 15
26382: EQUAL
26383: IFFALSE 26404
// points := [ 10 , 5 , 3 ] ;
26385: LD_ADDR_VAR 0 9
26389: PUSH
26390: LD_INT 10
26392: PUSH
26393: LD_INT 5
26395: PUSH
26396: LD_INT 3
26398: PUSH
26399: EMPTY
26400: LIST
26401: LIST
26402: LIST
26403: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26404: LD_VAR 0 6
26408: PPUSH
26409: CALL_OW 257
26413: PUSH
26414: LD_INT 14
26416: EQUAL
26417: IFFALSE 26438
// points := [ 10 , 0 , 0 ] ;
26419: LD_ADDR_VAR 0 9
26423: PUSH
26424: LD_INT 10
26426: PUSH
26427: LD_INT 0
26429: PUSH
26430: LD_INT 0
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: LIST
26437: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 257
26447: PUSH
26448: LD_INT 11
26450: EQUAL
26451: IFFALSE 26472
// points := [ 30 , 10 , 5 ] ;
26453: LD_ADDR_VAR 0 9
26457: PUSH
26458: LD_INT 30
26460: PUSH
26461: LD_INT 10
26463: PUSH
26464: LD_INT 5
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: LIST
26471: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26472: LD_VAR 0 1
26476: PPUSH
26477: LD_INT 5
26479: PPUSH
26480: CALL_OW 321
26484: PUSH
26485: LD_INT 2
26487: EQUAL
26488: IFFALSE 26505
// bpoints := bpoints * 1.8 ;
26490: LD_ADDR_VAR 0 10
26494: PUSH
26495: LD_VAR 0 10
26499: PUSH
26500: LD_REAL  1.80000000000000E+0000
26503: MUL
26504: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26505: LD_VAR 0 6
26509: PPUSH
26510: CALL_OW 257
26514: PUSH
26515: LD_INT 1
26517: PUSH
26518: LD_INT 2
26520: PUSH
26521: LD_INT 3
26523: PUSH
26524: LD_INT 4
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: LIST
26531: LIST
26532: IN
26533: PUSH
26534: LD_VAR 0 1
26538: PPUSH
26539: LD_INT 51
26541: PPUSH
26542: CALL_OW 321
26546: PUSH
26547: LD_INT 2
26549: EQUAL
26550: AND
26551: IFFALSE 26568
// bpoints := bpoints * 1.2 ;
26553: LD_ADDR_VAR 0 10
26557: PUSH
26558: LD_VAR 0 10
26562: PUSH
26563: LD_REAL  1.20000000000000E+0000
26566: MUL
26567: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26568: LD_VAR 0 6
26572: PPUSH
26573: CALL_OW 257
26577: PUSH
26578: LD_INT 5
26580: PUSH
26581: LD_INT 7
26583: PUSH
26584: LD_INT 9
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: LIST
26591: IN
26592: PUSH
26593: LD_VAR 0 1
26597: PPUSH
26598: LD_INT 52
26600: PPUSH
26601: CALL_OW 321
26605: PUSH
26606: LD_INT 2
26608: EQUAL
26609: AND
26610: IFFALSE 26627
// bpoints := bpoints * 1.5 ;
26612: LD_ADDR_VAR 0 10
26616: PUSH
26617: LD_VAR 0 10
26621: PUSH
26622: LD_REAL  1.50000000000000E+0000
26625: MUL
26626: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26627: LD_VAR 0 1
26631: PPUSH
26632: LD_INT 66
26634: PPUSH
26635: CALL_OW 321
26639: PUSH
26640: LD_INT 2
26642: EQUAL
26643: IFFALSE 26660
// bpoints := bpoints * 1.1 ;
26645: LD_ADDR_VAR 0 10
26649: PUSH
26650: LD_VAR 0 10
26654: PUSH
26655: LD_REAL  1.10000000000000E+0000
26658: MUL
26659: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26660: LD_ADDR_VAR 0 10
26664: PUSH
26665: LD_VAR 0 10
26669: PUSH
26670: LD_VAR 0 6
26674: PPUSH
26675: LD_INT 1
26677: PPUSH
26678: CALL_OW 259
26682: PUSH
26683: LD_REAL  1.15000000000000E+0000
26686: MUL
26687: MUL
26688: ST_TO_ADDR
// end ; unit_vehicle :
26689: GO 27517
26691: LD_INT 2
26693: DOUBLE
26694: EQUAL
26695: IFTRUE 26699
26697: GO 27505
26699: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26700: LD_VAR 0 6
26704: PPUSH
26705: CALL_OW 264
26709: PUSH
26710: LD_INT 2
26712: PUSH
26713: LD_INT 42
26715: PUSH
26716: LD_INT 24
26718: PUSH
26719: EMPTY
26720: LIST
26721: LIST
26722: LIST
26723: IN
26724: IFFALSE 26745
// points := [ 25 , 5 , 3 ] ;
26726: LD_ADDR_VAR 0 9
26730: PUSH
26731: LD_INT 25
26733: PUSH
26734: LD_INT 5
26736: PUSH
26737: LD_INT 3
26739: PUSH
26740: EMPTY
26741: LIST
26742: LIST
26743: LIST
26744: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26745: LD_VAR 0 6
26749: PPUSH
26750: CALL_OW 264
26754: PUSH
26755: LD_INT 4
26757: PUSH
26758: LD_INT 43
26760: PUSH
26761: LD_INT 25
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: IN
26769: IFFALSE 26790
// points := [ 40 , 15 , 5 ] ;
26771: LD_ADDR_VAR 0 9
26775: PUSH
26776: LD_INT 40
26778: PUSH
26779: LD_INT 15
26781: PUSH
26782: LD_INT 5
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: LIST
26789: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26790: LD_VAR 0 6
26794: PPUSH
26795: CALL_OW 264
26799: PUSH
26800: LD_INT 3
26802: PUSH
26803: LD_INT 23
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: IN
26810: IFFALSE 26831
// points := [ 7 , 25 , 8 ] ;
26812: LD_ADDR_VAR 0 9
26816: PUSH
26817: LD_INT 7
26819: PUSH
26820: LD_INT 25
26822: PUSH
26823: LD_INT 8
26825: PUSH
26826: EMPTY
26827: LIST
26828: LIST
26829: LIST
26830: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26831: LD_VAR 0 6
26835: PPUSH
26836: CALL_OW 264
26840: PUSH
26841: LD_INT 5
26843: PUSH
26844: LD_INT 27
26846: PUSH
26847: LD_INT 44
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: LIST
26854: IN
26855: IFFALSE 26876
// points := [ 14 , 50 , 16 ] ;
26857: LD_ADDR_VAR 0 9
26861: PUSH
26862: LD_INT 14
26864: PUSH
26865: LD_INT 50
26867: PUSH
26868: LD_INT 16
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: LIST
26875: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26876: LD_VAR 0 6
26880: PPUSH
26881: CALL_OW 264
26885: PUSH
26886: LD_INT 6
26888: PUSH
26889: LD_INT 46
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: IN
26896: IFFALSE 26917
// points := [ 32 , 120 , 70 ] ;
26898: LD_ADDR_VAR 0 9
26902: PUSH
26903: LD_INT 32
26905: PUSH
26906: LD_INT 120
26908: PUSH
26909: LD_INT 70
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: LIST
26916: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26917: LD_VAR 0 6
26921: PPUSH
26922: CALL_OW 264
26926: PUSH
26927: LD_INT 7
26929: PUSH
26930: LD_INT 28
26932: PUSH
26933: LD_INT 45
26935: PUSH
26936: LD_INT 92
26938: PUSH
26939: EMPTY
26940: LIST
26941: LIST
26942: LIST
26943: LIST
26944: IN
26945: IFFALSE 26966
// points := [ 35 , 20 , 45 ] ;
26947: LD_ADDR_VAR 0 9
26951: PUSH
26952: LD_INT 35
26954: PUSH
26955: LD_INT 20
26957: PUSH
26958: LD_INT 45
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: LIST
26965: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26966: LD_VAR 0 6
26970: PPUSH
26971: CALL_OW 264
26975: PUSH
26976: LD_INT 47
26978: PUSH
26979: EMPTY
26980: LIST
26981: IN
26982: IFFALSE 27003
// points := [ 67 , 45 , 75 ] ;
26984: LD_ADDR_VAR 0 9
26988: PUSH
26989: LD_INT 67
26991: PUSH
26992: LD_INT 45
26994: PUSH
26995: LD_INT 75
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: LIST
27002: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
27003: LD_VAR 0 6
27007: PPUSH
27008: CALL_OW 264
27012: PUSH
27013: LD_INT 26
27015: PUSH
27016: EMPTY
27017: LIST
27018: IN
27019: IFFALSE 27040
// points := [ 120 , 30 , 80 ] ;
27021: LD_ADDR_VAR 0 9
27025: PUSH
27026: LD_INT 120
27028: PUSH
27029: LD_INT 30
27031: PUSH
27032: LD_INT 80
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: LIST
27039: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
27040: LD_VAR 0 6
27044: PPUSH
27045: CALL_OW 264
27049: PUSH
27050: LD_INT 22
27052: PUSH
27053: EMPTY
27054: LIST
27055: IN
27056: IFFALSE 27077
// points := [ 40 , 1 , 1 ] ;
27058: LD_ADDR_VAR 0 9
27062: PUSH
27063: LD_INT 40
27065: PUSH
27066: LD_INT 1
27068: PUSH
27069: LD_INT 1
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: LIST
27076: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
27077: LD_VAR 0 6
27081: PPUSH
27082: CALL_OW 264
27086: PUSH
27087: LD_INT 29
27089: PUSH
27090: EMPTY
27091: LIST
27092: IN
27093: IFFALSE 27114
// points := [ 70 , 200 , 400 ] ;
27095: LD_ADDR_VAR 0 9
27099: PUSH
27100: LD_INT 70
27102: PUSH
27103: LD_INT 200
27105: PUSH
27106: LD_INT 400
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: LIST
27113: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
27114: LD_VAR 0 6
27118: PPUSH
27119: CALL_OW 264
27123: PUSH
27124: LD_INT 14
27126: PUSH
27127: LD_INT 53
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: IN
27134: IFFALSE 27155
// points := [ 40 , 10 , 20 ] ;
27136: LD_ADDR_VAR 0 9
27140: PUSH
27141: LD_INT 40
27143: PUSH
27144: LD_INT 10
27146: PUSH
27147: LD_INT 20
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: LIST
27154: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
27155: LD_VAR 0 6
27159: PPUSH
27160: CALL_OW 264
27164: PUSH
27165: LD_INT 9
27167: PUSH
27168: EMPTY
27169: LIST
27170: IN
27171: IFFALSE 27192
// points := [ 5 , 70 , 20 ] ;
27173: LD_ADDR_VAR 0 9
27177: PUSH
27178: LD_INT 5
27180: PUSH
27181: LD_INT 70
27183: PUSH
27184: LD_INT 20
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: LIST
27191: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27192: LD_VAR 0 6
27196: PPUSH
27197: CALL_OW 264
27201: PUSH
27202: LD_INT 10
27204: PUSH
27205: EMPTY
27206: LIST
27207: IN
27208: IFFALSE 27229
// points := [ 35 , 110 , 70 ] ;
27210: LD_ADDR_VAR 0 9
27214: PUSH
27215: LD_INT 35
27217: PUSH
27218: LD_INT 110
27220: PUSH
27221: LD_INT 70
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: LIST
27228: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27229: LD_VAR 0 6
27233: PPUSH
27234: CALL_OW 265
27238: PUSH
27239: LD_INT 25
27241: EQUAL
27242: IFFALSE 27263
// points := [ 80 , 65 , 100 ] ;
27244: LD_ADDR_VAR 0 9
27248: PUSH
27249: LD_INT 80
27251: PUSH
27252: LD_INT 65
27254: PUSH
27255: LD_INT 100
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: LIST
27262: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27263: LD_VAR 0 6
27267: PPUSH
27268: CALL_OW 263
27272: PUSH
27273: LD_INT 1
27275: EQUAL
27276: IFFALSE 27311
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27278: LD_ADDR_VAR 0 10
27282: PUSH
27283: LD_VAR 0 10
27287: PUSH
27288: LD_VAR 0 6
27292: PPUSH
27293: CALL_OW 311
27297: PPUSH
27298: LD_INT 3
27300: PPUSH
27301: CALL_OW 259
27305: PUSH
27306: LD_INT 4
27308: MUL
27309: MUL
27310: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27311: LD_VAR 0 6
27315: PPUSH
27316: CALL_OW 263
27320: PUSH
27321: LD_INT 2
27323: EQUAL
27324: IFFALSE 27375
// begin j := IsControledBy ( i ) ;
27326: LD_ADDR_VAR 0 7
27330: PUSH
27331: LD_VAR 0 6
27335: PPUSH
27336: CALL_OW 312
27340: ST_TO_ADDR
// if j then
27341: LD_VAR 0 7
27345: IFFALSE 27375
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27347: LD_ADDR_VAR 0 10
27351: PUSH
27352: LD_VAR 0 10
27356: PUSH
27357: LD_VAR 0 7
27361: PPUSH
27362: LD_INT 3
27364: PPUSH
27365: CALL_OW 259
27369: PUSH
27370: LD_INT 3
27372: MUL
27373: MUL
27374: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27375: LD_VAR 0 6
27379: PPUSH
27380: CALL_OW 264
27384: PUSH
27385: LD_INT 5
27387: PUSH
27388: LD_INT 6
27390: PUSH
27391: LD_INT 46
27393: PUSH
27394: LD_INT 44
27396: PUSH
27397: LD_INT 47
27399: PUSH
27400: LD_INT 45
27402: PUSH
27403: LD_INT 28
27405: PUSH
27406: LD_INT 7
27408: PUSH
27409: LD_INT 27
27411: PUSH
27412: LD_INT 29
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: LIST
27419: LIST
27420: LIST
27421: LIST
27422: LIST
27423: LIST
27424: LIST
27425: LIST
27426: IN
27427: PUSH
27428: LD_VAR 0 1
27432: PPUSH
27433: LD_INT 52
27435: PPUSH
27436: CALL_OW 321
27440: PUSH
27441: LD_INT 2
27443: EQUAL
27444: AND
27445: IFFALSE 27462
// bpoints := bpoints * 1.2 ;
27447: LD_ADDR_VAR 0 10
27451: PUSH
27452: LD_VAR 0 10
27456: PUSH
27457: LD_REAL  1.20000000000000E+0000
27460: MUL
27461: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27462: LD_VAR 0 6
27466: PPUSH
27467: CALL_OW 264
27471: PUSH
27472: LD_INT 6
27474: PUSH
27475: LD_INT 46
27477: PUSH
27478: LD_INT 47
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: LIST
27485: IN
27486: IFFALSE 27503
// bpoints := bpoints * 1.2 ;
27488: LD_ADDR_VAR 0 10
27492: PUSH
27493: LD_VAR 0 10
27497: PUSH
27498: LD_REAL  1.20000000000000E+0000
27501: MUL
27502: ST_TO_ADDR
// end ; unit_building :
27503: GO 27517
27505: LD_INT 3
27507: DOUBLE
27508: EQUAL
27509: IFTRUE 27513
27511: GO 27516
27513: POP
// ; end ;
27514: GO 27517
27516: POP
// for j = 1 to 3 do
27517: LD_ADDR_VAR 0 7
27521: PUSH
27522: DOUBLE
27523: LD_INT 1
27525: DEC
27526: ST_TO_ADDR
27527: LD_INT 3
27529: PUSH
27530: FOR_TO
27531: IFFALSE 27584
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27533: LD_ADDR_VAR 0 5
27537: PUSH
27538: LD_VAR 0 5
27542: PPUSH
27543: LD_VAR 0 7
27547: PPUSH
27548: LD_VAR 0 5
27552: PUSH
27553: LD_VAR 0 7
27557: ARRAY
27558: PUSH
27559: LD_VAR 0 9
27563: PUSH
27564: LD_VAR 0 7
27568: ARRAY
27569: PUSH
27570: LD_VAR 0 10
27574: MUL
27575: PLUS
27576: PPUSH
27577: CALL_OW 1
27581: ST_TO_ADDR
27582: GO 27530
27584: POP
27585: POP
// end ;
27586: GO 26065
27588: POP
27589: POP
// result := Replace ( result , 4 , tmp ) ;
27590: LD_ADDR_VAR 0 5
27594: PUSH
27595: LD_VAR 0 5
27599: PPUSH
27600: LD_INT 4
27602: PPUSH
27603: LD_VAR 0 8
27607: PPUSH
27608: CALL_OW 1
27612: ST_TO_ADDR
// end ;
27613: LD_VAR 0 5
27617: RET
// export function DangerAtRange ( unit , range ) ; begin
27618: LD_INT 0
27620: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27621: LD_ADDR_VAR 0 3
27625: PUSH
27626: LD_VAR 0 1
27630: PPUSH
27631: CALL_OW 255
27635: PPUSH
27636: LD_VAR 0 1
27640: PPUSH
27641: CALL_OW 250
27645: PPUSH
27646: LD_VAR 0 1
27650: PPUSH
27651: CALL_OW 251
27655: PPUSH
27656: LD_VAR 0 2
27660: PPUSH
27661: CALL 25917 0 4
27665: ST_TO_ADDR
// end ;
27666: LD_VAR 0 3
27670: RET
// export function DangerInArea ( side , area ) ; begin
27671: LD_INT 0
27673: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27674: LD_ADDR_VAR 0 3
27678: PUSH
27679: LD_VAR 0 2
27683: PPUSH
27684: LD_INT 81
27686: PUSH
27687: LD_VAR 0 1
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PPUSH
27696: CALL_OW 70
27700: ST_TO_ADDR
// end ;
27701: LD_VAR 0 3
27705: RET
// export function IsExtension ( b ) ; begin
27706: LD_INT 0
27708: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27709: LD_ADDR_VAR 0 2
27713: PUSH
27714: LD_VAR 0 1
27718: PUSH
27719: LD_INT 23
27721: PUSH
27722: LD_INT 20
27724: PUSH
27725: LD_INT 22
27727: PUSH
27728: LD_INT 17
27730: PUSH
27731: LD_INT 24
27733: PUSH
27734: LD_INT 21
27736: PUSH
27737: LD_INT 19
27739: PUSH
27740: LD_INT 16
27742: PUSH
27743: LD_INT 25
27745: PUSH
27746: LD_INT 18
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: LIST
27759: LIST
27760: IN
27761: ST_TO_ADDR
// end ;
27762: LD_VAR 0 2
27766: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27767: LD_INT 0
27769: PPUSH
27770: PPUSH
27771: PPUSH
// result := [ ] ;
27772: LD_ADDR_VAR 0 4
27776: PUSH
27777: EMPTY
27778: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27779: LD_ADDR_VAR 0 5
27783: PUSH
27784: LD_VAR 0 2
27788: PPUSH
27789: LD_INT 21
27791: PUSH
27792: LD_INT 3
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PPUSH
27799: CALL_OW 70
27803: ST_TO_ADDR
// if not tmp then
27804: LD_VAR 0 5
27808: NOT
27809: IFFALSE 27813
// exit ;
27811: GO 27877
// if checkLink then
27813: LD_VAR 0 3
27817: IFFALSE 27867
// begin for i in tmp do
27819: LD_ADDR_VAR 0 6
27823: PUSH
27824: LD_VAR 0 5
27828: PUSH
27829: FOR_IN
27830: IFFALSE 27865
// if GetBase ( i ) <> base then
27832: LD_VAR 0 6
27836: PPUSH
27837: CALL_OW 274
27841: PUSH
27842: LD_VAR 0 1
27846: NONEQUAL
27847: IFFALSE 27863
// ComLinkToBase ( base , i ) ;
27849: LD_VAR 0 1
27853: PPUSH
27854: LD_VAR 0 6
27858: PPUSH
27859: CALL_OW 169
27863: GO 27829
27865: POP
27866: POP
// end ; result := tmp ;
27867: LD_ADDR_VAR 0 4
27871: PUSH
27872: LD_VAR 0 5
27876: ST_TO_ADDR
// end ;
27877: LD_VAR 0 4
27881: RET
// export function ComComplete ( units , b ) ; var i ; begin
27882: LD_INT 0
27884: PPUSH
27885: PPUSH
// if not units then
27886: LD_VAR 0 1
27890: NOT
27891: IFFALSE 27895
// exit ;
27893: GO 27985
// for i in units do
27895: LD_ADDR_VAR 0 4
27899: PUSH
27900: LD_VAR 0 1
27904: PUSH
27905: FOR_IN
27906: IFFALSE 27983
// if BuildingStatus ( b ) = bs_build then
27908: LD_VAR 0 2
27912: PPUSH
27913: CALL_OW 461
27917: PUSH
27918: LD_INT 1
27920: EQUAL
27921: IFFALSE 27981
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27923: LD_VAR 0 4
27927: PPUSH
27928: LD_STRING h
27930: PUSH
27931: LD_VAR 0 2
27935: PPUSH
27936: CALL_OW 250
27940: PUSH
27941: LD_VAR 0 2
27945: PPUSH
27946: CALL_OW 251
27950: PUSH
27951: LD_VAR 0 2
27955: PUSH
27956: LD_INT 0
27958: PUSH
27959: LD_INT 0
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: LIST
27969: LIST
27970: LIST
27971: LIST
27972: LIST
27973: PUSH
27974: EMPTY
27975: LIST
27976: PPUSH
27977: CALL_OW 446
27981: GO 27905
27983: POP
27984: POP
// end ;
27985: LD_VAR 0 3
27989: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27990: LD_INT 0
27992: PPUSH
27993: PPUSH
27994: PPUSH
27995: PPUSH
27996: PPUSH
27997: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27998: LD_VAR 0 1
28002: NOT
28003: PUSH
28004: LD_VAR 0 1
28008: PPUSH
28009: CALL_OW 263
28013: PUSH
28014: LD_INT 2
28016: NONEQUAL
28017: OR
28018: IFFALSE 28022
// exit ;
28020: GO 28338
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
28022: LD_ADDR_VAR 0 6
28026: PUSH
28027: LD_INT 22
28029: PUSH
28030: LD_VAR 0 1
28034: PPUSH
28035: CALL_OW 255
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 2
28046: PUSH
28047: LD_INT 30
28049: PUSH
28050: LD_INT 36
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 34
28059: PUSH
28060: LD_INT 31
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: LIST
28070: LIST
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PPUSH
28076: CALL_OW 69
28080: ST_TO_ADDR
// if not tmp then
28081: LD_VAR 0 6
28085: NOT
28086: IFFALSE 28090
// exit ;
28088: GO 28338
// result := [ ] ;
28090: LD_ADDR_VAR 0 2
28094: PUSH
28095: EMPTY
28096: ST_TO_ADDR
// for i in tmp do
28097: LD_ADDR_VAR 0 3
28101: PUSH
28102: LD_VAR 0 6
28106: PUSH
28107: FOR_IN
28108: IFFALSE 28179
// begin t := UnitsInside ( i ) ;
28110: LD_ADDR_VAR 0 4
28114: PUSH
28115: LD_VAR 0 3
28119: PPUSH
28120: CALL_OW 313
28124: ST_TO_ADDR
// if t then
28125: LD_VAR 0 4
28129: IFFALSE 28177
// for j in t do
28131: LD_ADDR_VAR 0 7
28135: PUSH
28136: LD_VAR 0 4
28140: PUSH
28141: FOR_IN
28142: IFFALSE 28175
// result := Replace ( result , result + 1 , j ) ;
28144: LD_ADDR_VAR 0 2
28148: PUSH
28149: LD_VAR 0 2
28153: PPUSH
28154: LD_VAR 0 2
28158: PUSH
28159: LD_INT 1
28161: PLUS
28162: PPUSH
28163: LD_VAR 0 7
28167: PPUSH
28168: CALL_OW 1
28172: ST_TO_ADDR
28173: GO 28141
28175: POP
28176: POP
// end ;
28177: GO 28107
28179: POP
28180: POP
// if not result then
28181: LD_VAR 0 2
28185: NOT
28186: IFFALSE 28190
// exit ;
28188: GO 28338
// mech := result [ 1 ] ;
28190: LD_ADDR_VAR 0 5
28194: PUSH
28195: LD_VAR 0 2
28199: PUSH
28200: LD_INT 1
28202: ARRAY
28203: ST_TO_ADDR
// if result > 1 then
28204: LD_VAR 0 2
28208: PUSH
28209: LD_INT 1
28211: GREATER
28212: IFFALSE 28324
// begin for i = 2 to result do
28214: LD_ADDR_VAR 0 3
28218: PUSH
28219: DOUBLE
28220: LD_INT 2
28222: DEC
28223: ST_TO_ADDR
28224: LD_VAR 0 2
28228: PUSH
28229: FOR_TO
28230: IFFALSE 28322
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28232: LD_ADDR_VAR 0 4
28236: PUSH
28237: LD_VAR 0 2
28241: PUSH
28242: LD_VAR 0 3
28246: ARRAY
28247: PPUSH
28248: LD_INT 3
28250: PPUSH
28251: CALL_OW 259
28255: PUSH
28256: LD_VAR 0 2
28260: PUSH
28261: LD_VAR 0 3
28265: ARRAY
28266: PPUSH
28267: CALL_OW 432
28271: MINUS
28272: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28273: LD_VAR 0 4
28277: PUSH
28278: LD_VAR 0 5
28282: PPUSH
28283: LD_INT 3
28285: PPUSH
28286: CALL_OW 259
28290: PUSH
28291: LD_VAR 0 5
28295: PPUSH
28296: CALL_OW 432
28300: MINUS
28301: GREATEREQUAL
28302: IFFALSE 28320
// mech := result [ i ] ;
28304: LD_ADDR_VAR 0 5
28308: PUSH
28309: LD_VAR 0 2
28313: PUSH
28314: LD_VAR 0 3
28318: ARRAY
28319: ST_TO_ADDR
// end ;
28320: GO 28229
28322: POP
28323: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28324: LD_VAR 0 1
28328: PPUSH
28329: LD_VAR 0 5
28333: PPUSH
28334: CALL_OW 135
// end ;
28338: LD_VAR 0 2
28342: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28343: LD_INT 0
28345: PPUSH
28346: PPUSH
28347: PPUSH
28348: PPUSH
28349: PPUSH
28350: PPUSH
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
28356: PPUSH
28357: PPUSH
// result := [ ] ;
28358: LD_ADDR_VAR 0 7
28362: PUSH
28363: EMPTY
28364: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28365: LD_VAR 0 1
28369: PPUSH
28370: CALL_OW 266
28374: PUSH
28375: LD_INT 0
28377: PUSH
28378: LD_INT 1
28380: PUSH
28381: EMPTY
28382: LIST
28383: LIST
28384: IN
28385: NOT
28386: IFFALSE 28390
// exit ;
28388: GO 30024
// if name then
28390: LD_VAR 0 3
28394: IFFALSE 28410
// SetBName ( base_dep , name ) ;
28396: LD_VAR 0 1
28400: PPUSH
28401: LD_VAR 0 3
28405: PPUSH
28406: CALL_OW 500
// base := GetBase ( base_dep ) ;
28410: LD_ADDR_VAR 0 15
28414: PUSH
28415: LD_VAR 0 1
28419: PPUSH
28420: CALL_OW 274
28424: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28425: LD_ADDR_VAR 0 16
28429: PUSH
28430: LD_VAR 0 1
28434: PPUSH
28435: CALL_OW 255
28439: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28440: LD_ADDR_VAR 0 17
28444: PUSH
28445: LD_VAR 0 1
28449: PPUSH
28450: CALL_OW 248
28454: ST_TO_ADDR
// if sources then
28455: LD_VAR 0 5
28459: IFFALSE 28506
// for i = 1 to 3 do
28461: LD_ADDR_VAR 0 8
28465: PUSH
28466: DOUBLE
28467: LD_INT 1
28469: DEC
28470: ST_TO_ADDR
28471: LD_INT 3
28473: PUSH
28474: FOR_TO
28475: IFFALSE 28504
// AddResourceType ( base , i , sources [ i ] ) ;
28477: LD_VAR 0 15
28481: PPUSH
28482: LD_VAR 0 8
28486: PPUSH
28487: LD_VAR 0 5
28491: PUSH
28492: LD_VAR 0 8
28496: ARRAY
28497: PPUSH
28498: CALL_OW 276
28502: GO 28474
28504: POP
28505: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28506: LD_ADDR_VAR 0 18
28510: PUSH
28511: LD_VAR 0 15
28515: PPUSH
28516: LD_VAR 0 2
28520: PPUSH
28521: LD_INT 1
28523: PPUSH
28524: CALL 27767 0 3
28528: ST_TO_ADDR
// InitHc ;
28529: CALL_OW 19
// InitUc ;
28533: CALL_OW 18
// uc_side := side ;
28537: LD_ADDR_OWVAR 20
28541: PUSH
28542: LD_VAR 0 16
28546: ST_TO_ADDR
// uc_nation := nation ;
28547: LD_ADDR_OWVAR 21
28551: PUSH
28552: LD_VAR 0 17
28556: ST_TO_ADDR
// if buildings then
28557: LD_VAR 0 18
28561: IFFALSE 29883
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28563: LD_ADDR_VAR 0 19
28567: PUSH
28568: LD_VAR 0 18
28572: PPUSH
28573: LD_INT 2
28575: PUSH
28576: LD_INT 30
28578: PUSH
28579: LD_INT 29
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 30
28588: PUSH
28589: LD_INT 30
28591: PUSH
28592: EMPTY
28593: LIST
28594: LIST
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: PPUSH
28601: CALL_OW 72
28605: ST_TO_ADDR
// if tmp then
28606: LD_VAR 0 19
28610: IFFALSE 28658
// for i in tmp do
28612: LD_ADDR_VAR 0 8
28616: PUSH
28617: LD_VAR 0 19
28621: PUSH
28622: FOR_IN
28623: IFFALSE 28656
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28625: LD_VAR 0 8
28629: PPUSH
28630: CALL_OW 250
28634: PPUSH
28635: LD_VAR 0 8
28639: PPUSH
28640: CALL_OW 251
28644: PPUSH
28645: LD_VAR 0 16
28649: PPUSH
28650: CALL_OW 441
28654: GO 28622
28656: POP
28657: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28658: LD_VAR 0 18
28662: PPUSH
28663: LD_INT 2
28665: PUSH
28666: LD_INT 30
28668: PUSH
28669: LD_INT 32
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: LD_INT 30
28678: PUSH
28679: LD_INT 33
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: LIST
28690: PPUSH
28691: CALL_OW 72
28695: IFFALSE 28783
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28697: LD_ADDR_VAR 0 8
28701: PUSH
28702: LD_VAR 0 18
28706: PPUSH
28707: LD_INT 2
28709: PUSH
28710: LD_INT 30
28712: PUSH
28713: LD_INT 32
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 30
28722: PUSH
28723: LD_INT 33
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: LIST
28734: PPUSH
28735: CALL_OW 72
28739: PUSH
28740: FOR_IN
28741: IFFALSE 28781
// begin if not GetBWeapon ( i ) then
28743: LD_VAR 0 8
28747: PPUSH
28748: CALL_OW 269
28752: NOT
28753: IFFALSE 28779
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28755: LD_VAR 0 8
28759: PPUSH
28760: LD_VAR 0 8
28764: PPUSH
28765: LD_VAR 0 2
28769: PPUSH
28770: CALL 30029 0 2
28774: PPUSH
28775: CALL_OW 431
// end ;
28779: GO 28740
28781: POP
28782: POP
// end ; for i = 1 to personel do
28783: LD_ADDR_VAR 0 8
28787: PUSH
28788: DOUBLE
28789: LD_INT 1
28791: DEC
28792: ST_TO_ADDR
28793: LD_VAR 0 6
28797: PUSH
28798: FOR_TO
28799: IFFALSE 29863
// begin if i > 4 then
28801: LD_VAR 0 8
28805: PUSH
28806: LD_INT 4
28808: GREATER
28809: IFFALSE 28813
// break ;
28811: GO 29863
// case i of 1 :
28813: LD_VAR 0 8
28817: PUSH
28818: LD_INT 1
28820: DOUBLE
28821: EQUAL
28822: IFTRUE 28826
28824: GO 28906
28826: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28827: LD_ADDR_VAR 0 12
28831: PUSH
28832: LD_VAR 0 18
28836: PPUSH
28837: LD_INT 22
28839: PUSH
28840: LD_VAR 0 16
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 58
28851: PUSH
28852: EMPTY
28853: LIST
28854: PUSH
28855: LD_INT 2
28857: PUSH
28858: LD_INT 30
28860: PUSH
28861: LD_INT 32
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 30
28870: PUSH
28871: LD_INT 4
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 30
28880: PUSH
28881: LD_INT 5
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: LIST
28898: PPUSH
28899: CALL_OW 72
28903: ST_TO_ADDR
28904: GO 29128
28906: LD_INT 2
28908: DOUBLE
28909: EQUAL
28910: IFTRUE 28914
28912: GO 28976
28914: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28915: LD_ADDR_VAR 0 12
28919: PUSH
28920: LD_VAR 0 18
28924: PPUSH
28925: LD_INT 22
28927: PUSH
28928: LD_VAR 0 16
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 2
28939: PUSH
28940: LD_INT 30
28942: PUSH
28943: LD_INT 0
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 30
28952: PUSH
28953: LD_INT 1
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: LIST
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PPUSH
28969: CALL_OW 72
28973: ST_TO_ADDR
28974: GO 29128
28976: LD_INT 3
28978: DOUBLE
28979: EQUAL
28980: IFTRUE 28984
28982: GO 29046
28984: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28985: LD_ADDR_VAR 0 12
28989: PUSH
28990: LD_VAR 0 18
28994: PPUSH
28995: LD_INT 22
28997: PUSH
28998: LD_VAR 0 16
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 2
29009: PUSH
29010: LD_INT 30
29012: PUSH
29013: LD_INT 2
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: LD_INT 30
29022: PUSH
29023: LD_INT 3
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: LIST
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PPUSH
29039: CALL_OW 72
29043: ST_TO_ADDR
29044: GO 29128
29046: LD_INT 4
29048: DOUBLE
29049: EQUAL
29050: IFTRUE 29054
29052: GO 29127
29054: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
29055: LD_ADDR_VAR 0 12
29059: PUSH
29060: LD_VAR 0 18
29064: PPUSH
29065: LD_INT 22
29067: PUSH
29068: LD_VAR 0 16
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 2
29079: PUSH
29080: LD_INT 30
29082: PUSH
29083: LD_INT 6
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 30
29092: PUSH
29093: LD_INT 7
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: LD_INT 30
29102: PUSH
29103: LD_INT 8
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: LIST
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PPUSH
29120: CALL_OW 72
29124: ST_TO_ADDR
29125: GO 29128
29127: POP
// if i = 1 then
29128: LD_VAR 0 8
29132: PUSH
29133: LD_INT 1
29135: EQUAL
29136: IFFALSE 29247
// begin tmp := [ ] ;
29138: LD_ADDR_VAR 0 19
29142: PUSH
29143: EMPTY
29144: ST_TO_ADDR
// for j in f do
29145: LD_ADDR_VAR 0 9
29149: PUSH
29150: LD_VAR 0 12
29154: PUSH
29155: FOR_IN
29156: IFFALSE 29229
// if GetBType ( j ) = b_bunker then
29158: LD_VAR 0 9
29162: PPUSH
29163: CALL_OW 266
29167: PUSH
29168: LD_INT 32
29170: EQUAL
29171: IFFALSE 29198
// tmp := Insert ( tmp , 1 , j ) else
29173: LD_ADDR_VAR 0 19
29177: PUSH
29178: LD_VAR 0 19
29182: PPUSH
29183: LD_INT 1
29185: PPUSH
29186: LD_VAR 0 9
29190: PPUSH
29191: CALL_OW 2
29195: ST_TO_ADDR
29196: GO 29227
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29198: LD_ADDR_VAR 0 19
29202: PUSH
29203: LD_VAR 0 19
29207: PPUSH
29208: LD_VAR 0 19
29212: PUSH
29213: LD_INT 1
29215: PLUS
29216: PPUSH
29217: LD_VAR 0 9
29221: PPUSH
29222: CALL_OW 2
29226: ST_TO_ADDR
29227: GO 29155
29229: POP
29230: POP
// if tmp then
29231: LD_VAR 0 19
29235: IFFALSE 29247
// f := tmp ;
29237: LD_ADDR_VAR 0 12
29241: PUSH
29242: LD_VAR 0 19
29246: ST_TO_ADDR
// end ; x := personel [ i ] ;
29247: LD_ADDR_VAR 0 13
29251: PUSH
29252: LD_VAR 0 6
29256: PUSH
29257: LD_VAR 0 8
29261: ARRAY
29262: ST_TO_ADDR
// if x = - 1 then
29263: LD_VAR 0 13
29267: PUSH
29268: LD_INT 1
29270: NEG
29271: EQUAL
29272: IFFALSE 29481
// begin for j in f do
29274: LD_ADDR_VAR 0 9
29278: PUSH
29279: LD_VAR 0 12
29283: PUSH
29284: FOR_IN
29285: IFFALSE 29477
// repeat InitHc ;
29287: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29291: LD_VAR 0 9
29295: PPUSH
29296: CALL_OW 266
29300: PUSH
29301: LD_INT 5
29303: EQUAL
29304: IFFALSE 29374
// begin if UnitsInside ( j ) < 3 then
29306: LD_VAR 0 9
29310: PPUSH
29311: CALL_OW 313
29315: PUSH
29316: LD_INT 3
29318: LESS
29319: IFFALSE 29355
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29321: LD_INT 0
29323: PPUSH
29324: LD_INT 5
29326: PUSH
29327: LD_INT 8
29329: PUSH
29330: LD_INT 9
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: LIST
29337: PUSH
29338: LD_VAR 0 17
29342: ARRAY
29343: PPUSH
29344: LD_VAR 0 4
29348: PPUSH
29349: CALL_OW 380
29353: GO 29372
// PrepareHuman ( false , i , skill ) ;
29355: LD_INT 0
29357: PPUSH
29358: LD_VAR 0 8
29362: PPUSH
29363: LD_VAR 0 4
29367: PPUSH
29368: CALL_OW 380
// end else
29372: GO 29391
// PrepareHuman ( false , i , skill ) ;
29374: LD_INT 0
29376: PPUSH
29377: LD_VAR 0 8
29381: PPUSH
29382: LD_VAR 0 4
29386: PPUSH
29387: CALL_OW 380
// un := CreateHuman ;
29391: LD_ADDR_VAR 0 14
29395: PUSH
29396: CALL_OW 44
29400: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29401: LD_ADDR_VAR 0 7
29405: PUSH
29406: LD_VAR 0 7
29410: PPUSH
29411: LD_INT 1
29413: PPUSH
29414: LD_VAR 0 14
29418: PPUSH
29419: CALL_OW 2
29423: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29424: LD_VAR 0 14
29428: PPUSH
29429: LD_VAR 0 9
29433: PPUSH
29434: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29438: LD_VAR 0 9
29442: PPUSH
29443: CALL_OW 313
29447: PUSH
29448: LD_INT 6
29450: EQUAL
29451: PUSH
29452: LD_VAR 0 9
29456: PPUSH
29457: CALL_OW 266
29461: PUSH
29462: LD_INT 32
29464: PUSH
29465: LD_INT 31
29467: PUSH
29468: EMPTY
29469: LIST
29470: LIST
29471: IN
29472: OR
29473: IFFALSE 29287
29475: GO 29284
29477: POP
29478: POP
// end else
29479: GO 29861
// for j = 1 to x do
29481: LD_ADDR_VAR 0 9
29485: PUSH
29486: DOUBLE
29487: LD_INT 1
29489: DEC
29490: ST_TO_ADDR
29491: LD_VAR 0 13
29495: PUSH
29496: FOR_TO
29497: IFFALSE 29859
// begin InitHc ;
29499: CALL_OW 19
// if not f then
29503: LD_VAR 0 12
29507: NOT
29508: IFFALSE 29597
// begin PrepareHuman ( false , i , skill ) ;
29510: LD_INT 0
29512: PPUSH
29513: LD_VAR 0 8
29517: PPUSH
29518: LD_VAR 0 4
29522: PPUSH
29523: CALL_OW 380
// un := CreateHuman ;
29527: LD_ADDR_VAR 0 14
29531: PUSH
29532: CALL_OW 44
29536: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29537: LD_ADDR_VAR 0 7
29541: PUSH
29542: LD_VAR 0 7
29546: PPUSH
29547: LD_INT 1
29549: PPUSH
29550: LD_VAR 0 14
29554: PPUSH
29555: CALL_OW 2
29559: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29560: LD_VAR 0 14
29564: PPUSH
29565: LD_VAR 0 1
29569: PPUSH
29570: CALL_OW 250
29574: PPUSH
29575: LD_VAR 0 1
29579: PPUSH
29580: CALL_OW 251
29584: PPUSH
29585: LD_INT 10
29587: PPUSH
29588: LD_INT 0
29590: PPUSH
29591: CALL_OW 50
// continue ;
29595: GO 29496
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29597: LD_VAR 0 12
29601: PUSH
29602: LD_INT 1
29604: ARRAY
29605: PPUSH
29606: CALL_OW 313
29610: PUSH
29611: LD_VAR 0 12
29615: PUSH
29616: LD_INT 1
29618: ARRAY
29619: PPUSH
29620: CALL_OW 266
29624: PUSH
29625: LD_INT 32
29627: PUSH
29628: LD_INT 31
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: IN
29635: AND
29636: PUSH
29637: LD_VAR 0 12
29641: PUSH
29642: LD_INT 1
29644: ARRAY
29645: PPUSH
29646: CALL_OW 313
29650: PUSH
29651: LD_INT 6
29653: EQUAL
29654: OR
29655: IFFALSE 29675
// f := Delete ( f , 1 ) ;
29657: LD_ADDR_VAR 0 12
29661: PUSH
29662: LD_VAR 0 12
29666: PPUSH
29667: LD_INT 1
29669: PPUSH
29670: CALL_OW 3
29674: ST_TO_ADDR
// if not f then
29675: LD_VAR 0 12
29679: NOT
29680: IFFALSE 29698
// begin x := x + 2 ;
29682: LD_ADDR_VAR 0 13
29686: PUSH
29687: LD_VAR 0 13
29691: PUSH
29692: LD_INT 2
29694: PLUS
29695: ST_TO_ADDR
// continue ;
29696: GO 29496
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29698: LD_VAR 0 12
29702: PUSH
29703: LD_INT 1
29705: ARRAY
29706: PPUSH
29707: CALL_OW 266
29711: PUSH
29712: LD_INT 5
29714: EQUAL
29715: IFFALSE 29789
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29717: LD_VAR 0 12
29721: PUSH
29722: LD_INT 1
29724: ARRAY
29725: PPUSH
29726: CALL_OW 313
29730: PUSH
29731: LD_INT 3
29733: LESS
29734: IFFALSE 29770
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29736: LD_INT 0
29738: PPUSH
29739: LD_INT 5
29741: PUSH
29742: LD_INT 8
29744: PUSH
29745: LD_INT 9
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: LIST
29752: PUSH
29753: LD_VAR 0 17
29757: ARRAY
29758: PPUSH
29759: LD_VAR 0 4
29763: PPUSH
29764: CALL_OW 380
29768: GO 29787
// PrepareHuman ( false , i , skill ) ;
29770: LD_INT 0
29772: PPUSH
29773: LD_VAR 0 8
29777: PPUSH
29778: LD_VAR 0 4
29782: PPUSH
29783: CALL_OW 380
// end else
29787: GO 29806
// PrepareHuman ( false , i , skill ) ;
29789: LD_INT 0
29791: PPUSH
29792: LD_VAR 0 8
29796: PPUSH
29797: LD_VAR 0 4
29801: PPUSH
29802: CALL_OW 380
// un := CreateHuman ;
29806: LD_ADDR_VAR 0 14
29810: PUSH
29811: CALL_OW 44
29815: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29816: LD_ADDR_VAR 0 7
29820: PUSH
29821: LD_VAR 0 7
29825: PPUSH
29826: LD_INT 1
29828: PPUSH
29829: LD_VAR 0 14
29833: PPUSH
29834: CALL_OW 2
29838: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29839: LD_VAR 0 14
29843: PPUSH
29844: LD_VAR 0 12
29848: PUSH
29849: LD_INT 1
29851: ARRAY
29852: PPUSH
29853: CALL_OW 52
// end ;
29857: GO 29496
29859: POP
29860: POP
// end ;
29861: GO 28798
29863: POP
29864: POP
// result := result ^ buildings ;
29865: LD_ADDR_VAR 0 7
29869: PUSH
29870: LD_VAR 0 7
29874: PUSH
29875: LD_VAR 0 18
29879: ADD
29880: ST_TO_ADDR
// end else
29881: GO 30024
// begin for i = 1 to personel do
29883: LD_ADDR_VAR 0 8
29887: PUSH
29888: DOUBLE
29889: LD_INT 1
29891: DEC
29892: ST_TO_ADDR
29893: LD_VAR 0 6
29897: PUSH
29898: FOR_TO
29899: IFFALSE 30022
// begin if i > 4 then
29901: LD_VAR 0 8
29905: PUSH
29906: LD_INT 4
29908: GREATER
29909: IFFALSE 29913
// break ;
29911: GO 30022
// x := personel [ i ] ;
29913: LD_ADDR_VAR 0 13
29917: PUSH
29918: LD_VAR 0 6
29922: PUSH
29923: LD_VAR 0 8
29927: ARRAY
29928: ST_TO_ADDR
// if x = - 1 then
29929: LD_VAR 0 13
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: EQUAL
29938: IFFALSE 29942
// continue ;
29940: GO 29898
// PrepareHuman ( false , i , skill ) ;
29942: LD_INT 0
29944: PPUSH
29945: LD_VAR 0 8
29949: PPUSH
29950: LD_VAR 0 4
29954: PPUSH
29955: CALL_OW 380
// un := CreateHuman ;
29959: LD_ADDR_VAR 0 14
29963: PUSH
29964: CALL_OW 44
29968: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29969: LD_VAR 0 14
29973: PPUSH
29974: LD_VAR 0 1
29978: PPUSH
29979: CALL_OW 250
29983: PPUSH
29984: LD_VAR 0 1
29988: PPUSH
29989: CALL_OW 251
29993: PPUSH
29994: LD_INT 10
29996: PPUSH
29997: LD_INT 0
29999: PPUSH
30000: CALL_OW 50
// result := result ^ un ;
30004: LD_ADDR_VAR 0 7
30008: PUSH
30009: LD_VAR 0 7
30013: PUSH
30014: LD_VAR 0 14
30018: ADD
30019: ST_TO_ADDR
// end ;
30020: GO 29898
30022: POP
30023: POP
// end ; end ;
30024: LD_VAR 0 7
30028: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
30029: LD_INT 0
30031: PPUSH
30032: PPUSH
30033: PPUSH
30034: PPUSH
30035: PPUSH
30036: PPUSH
30037: PPUSH
30038: PPUSH
30039: PPUSH
30040: PPUSH
30041: PPUSH
30042: PPUSH
30043: PPUSH
30044: PPUSH
30045: PPUSH
30046: PPUSH
// result := false ;
30047: LD_ADDR_VAR 0 3
30051: PUSH
30052: LD_INT 0
30054: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
30055: LD_VAR 0 1
30059: NOT
30060: PUSH
30061: LD_VAR 0 1
30065: PPUSH
30066: CALL_OW 266
30070: PUSH
30071: LD_INT 32
30073: PUSH
30074: LD_INT 33
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: IN
30081: NOT
30082: OR
30083: IFFALSE 30087
// exit ;
30085: GO 31196
// nat := GetNation ( tower ) ;
30087: LD_ADDR_VAR 0 12
30091: PUSH
30092: LD_VAR 0 1
30096: PPUSH
30097: CALL_OW 248
30101: ST_TO_ADDR
// side := GetSide ( tower ) ;
30102: LD_ADDR_VAR 0 16
30106: PUSH
30107: LD_VAR 0 1
30111: PPUSH
30112: CALL_OW 255
30116: ST_TO_ADDR
// x := GetX ( tower ) ;
30117: LD_ADDR_VAR 0 10
30121: PUSH
30122: LD_VAR 0 1
30126: PPUSH
30127: CALL_OW 250
30131: ST_TO_ADDR
// y := GetY ( tower ) ;
30132: LD_ADDR_VAR 0 11
30136: PUSH
30137: LD_VAR 0 1
30141: PPUSH
30142: CALL_OW 251
30146: ST_TO_ADDR
// if not x or not y then
30147: LD_VAR 0 10
30151: NOT
30152: PUSH
30153: LD_VAR 0 11
30157: NOT
30158: OR
30159: IFFALSE 30163
// exit ;
30161: GO 31196
// weapon := 0 ;
30163: LD_ADDR_VAR 0 18
30167: PUSH
30168: LD_INT 0
30170: ST_TO_ADDR
// fac_list := [ ] ;
30171: LD_ADDR_VAR 0 17
30175: PUSH
30176: EMPTY
30177: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30178: LD_ADDR_VAR 0 6
30182: PUSH
30183: LD_VAR 0 1
30187: PPUSH
30188: CALL_OW 274
30192: PPUSH
30193: LD_VAR 0 2
30197: PPUSH
30198: LD_INT 0
30200: PPUSH
30201: CALL 27767 0 3
30205: PPUSH
30206: LD_INT 30
30208: PUSH
30209: LD_INT 3
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PPUSH
30216: CALL_OW 72
30220: ST_TO_ADDR
// if not factories then
30221: LD_VAR 0 6
30225: NOT
30226: IFFALSE 30230
// exit ;
30228: GO 31196
// for i in factories do
30230: LD_ADDR_VAR 0 8
30234: PUSH
30235: LD_VAR 0 6
30239: PUSH
30240: FOR_IN
30241: IFFALSE 30266
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30243: LD_ADDR_VAR 0 17
30247: PUSH
30248: LD_VAR 0 17
30252: PUSH
30253: LD_VAR 0 8
30257: PPUSH
30258: CALL_OW 478
30262: UNION
30263: ST_TO_ADDR
30264: GO 30240
30266: POP
30267: POP
// if not fac_list then
30268: LD_VAR 0 17
30272: NOT
30273: IFFALSE 30277
// exit ;
30275: GO 31196
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30277: LD_ADDR_VAR 0 5
30281: PUSH
30282: LD_INT 4
30284: PUSH
30285: LD_INT 5
30287: PUSH
30288: LD_INT 9
30290: PUSH
30291: LD_INT 10
30293: PUSH
30294: LD_INT 6
30296: PUSH
30297: LD_INT 7
30299: PUSH
30300: LD_INT 11
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: PUSH
30312: LD_INT 27
30314: PUSH
30315: LD_INT 28
30317: PUSH
30318: LD_INT 26
30320: PUSH
30321: LD_INT 30
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 43
30332: PUSH
30333: LD_INT 44
30335: PUSH
30336: LD_INT 46
30338: PUSH
30339: LD_INT 45
30341: PUSH
30342: LD_INT 47
30344: PUSH
30345: LD_INT 49
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: LIST
30360: PUSH
30361: LD_VAR 0 12
30365: ARRAY
30366: ST_TO_ADDR
// list := list isect fac_list ;
30367: LD_ADDR_VAR 0 5
30371: PUSH
30372: LD_VAR 0 5
30376: PUSH
30377: LD_VAR 0 17
30381: ISECT
30382: ST_TO_ADDR
// if not list then
30383: LD_VAR 0 5
30387: NOT
30388: IFFALSE 30392
// exit ;
30390: GO 31196
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30392: LD_VAR 0 12
30396: PUSH
30397: LD_INT 3
30399: EQUAL
30400: PUSH
30401: LD_INT 49
30403: PUSH
30404: LD_VAR 0 5
30408: IN
30409: AND
30410: PUSH
30411: LD_INT 31
30413: PPUSH
30414: LD_VAR 0 16
30418: PPUSH
30419: CALL_OW 321
30423: PUSH
30424: LD_INT 2
30426: EQUAL
30427: AND
30428: IFFALSE 30488
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30430: LD_INT 22
30432: PUSH
30433: LD_VAR 0 16
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 35
30444: PUSH
30445: LD_INT 49
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 91
30454: PUSH
30455: LD_VAR 0 1
30459: PUSH
30460: LD_INT 10
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: LIST
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: LIST
30472: PPUSH
30473: CALL_OW 69
30477: NOT
30478: IFFALSE 30488
// weapon := ru_time_lapser ;
30480: LD_ADDR_VAR 0 18
30484: PUSH
30485: LD_INT 49
30487: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30488: LD_VAR 0 12
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: IN
30503: PUSH
30504: LD_INT 11
30506: PUSH
30507: LD_VAR 0 5
30511: IN
30512: PUSH
30513: LD_INT 30
30515: PUSH
30516: LD_VAR 0 5
30520: IN
30521: OR
30522: AND
30523: PUSH
30524: LD_INT 6
30526: PPUSH
30527: LD_VAR 0 16
30531: PPUSH
30532: CALL_OW 321
30536: PUSH
30537: LD_INT 2
30539: EQUAL
30540: AND
30541: IFFALSE 30706
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30543: LD_INT 22
30545: PUSH
30546: LD_VAR 0 16
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 2
30557: PUSH
30558: LD_INT 35
30560: PUSH
30561: LD_INT 11
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 35
30570: PUSH
30571: LD_INT 30
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 91
30585: PUSH
30586: LD_VAR 0 1
30590: PUSH
30591: LD_INT 18
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: LIST
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: LIST
30603: PPUSH
30604: CALL_OW 69
30608: NOT
30609: PUSH
30610: LD_INT 22
30612: PUSH
30613: LD_VAR 0 16
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 2
30624: PUSH
30625: LD_INT 30
30627: PUSH
30628: LD_INT 32
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 30
30637: PUSH
30638: LD_INT 33
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 91
30652: PUSH
30653: LD_VAR 0 1
30657: PUSH
30658: LD_INT 12
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: LIST
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: LIST
30670: PUSH
30671: EMPTY
30672: LIST
30673: PPUSH
30674: CALL_OW 69
30678: PUSH
30679: LD_INT 2
30681: GREATER
30682: AND
30683: IFFALSE 30706
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30685: LD_ADDR_VAR 0 18
30689: PUSH
30690: LD_INT 11
30692: PUSH
30693: LD_INT 30
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_VAR 0 12
30704: ARRAY
30705: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30706: LD_VAR 0 18
30710: NOT
30711: PUSH
30712: LD_INT 40
30714: PPUSH
30715: LD_VAR 0 16
30719: PPUSH
30720: CALL_OW 321
30724: PUSH
30725: LD_INT 2
30727: EQUAL
30728: AND
30729: PUSH
30730: LD_INT 7
30732: PUSH
30733: LD_VAR 0 5
30737: IN
30738: PUSH
30739: LD_INT 28
30741: PUSH
30742: LD_VAR 0 5
30746: IN
30747: OR
30748: PUSH
30749: LD_INT 45
30751: PUSH
30752: LD_VAR 0 5
30756: IN
30757: OR
30758: AND
30759: IFFALSE 31013
// begin hex := GetHexInfo ( x , y ) ;
30761: LD_ADDR_VAR 0 4
30765: PUSH
30766: LD_VAR 0 10
30770: PPUSH
30771: LD_VAR 0 11
30775: PPUSH
30776: CALL_OW 546
30780: ST_TO_ADDR
// if hex [ 1 ] then
30781: LD_VAR 0 4
30785: PUSH
30786: LD_INT 1
30788: ARRAY
30789: IFFALSE 30793
// exit ;
30791: GO 31196
// height := hex [ 2 ] ;
30793: LD_ADDR_VAR 0 15
30797: PUSH
30798: LD_VAR 0 4
30802: PUSH
30803: LD_INT 2
30805: ARRAY
30806: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30807: LD_ADDR_VAR 0 14
30811: PUSH
30812: LD_INT 0
30814: PUSH
30815: LD_INT 2
30817: PUSH
30818: LD_INT 3
30820: PUSH
30821: LD_INT 5
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: LIST
30828: LIST
30829: ST_TO_ADDR
// for i in tmp do
30830: LD_ADDR_VAR 0 8
30834: PUSH
30835: LD_VAR 0 14
30839: PUSH
30840: FOR_IN
30841: IFFALSE 31011
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30843: LD_ADDR_VAR 0 9
30847: PUSH
30848: LD_VAR 0 10
30852: PPUSH
30853: LD_VAR 0 8
30857: PPUSH
30858: LD_INT 5
30860: PPUSH
30861: CALL_OW 272
30865: PUSH
30866: LD_VAR 0 11
30870: PPUSH
30871: LD_VAR 0 8
30875: PPUSH
30876: LD_INT 5
30878: PPUSH
30879: CALL_OW 273
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30888: LD_VAR 0 9
30892: PUSH
30893: LD_INT 1
30895: ARRAY
30896: PPUSH
30897: LD_VAR 0 9
30901: PUSH
30902: LD_INT 2
30904: ARRAY
30905: PPUSH
30906: CALL_OW 488
30910: IFFALSE 31009
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30912: LD_ADDR_VAR 0 4
30916: PUSH
30917: LD_VAR 0 9
30921: PUSH
30922: LD_INT 1
30924: ARRAY
30925: PPUSH
30926: LD_VAR 0 9
30930: PUSH
30931: LD_INT 2
30933: ARRAY
30934: PPUSH
30935: CALL_OW 546
30939: ST_TO_ADDR
// if hex [ 1 ] then
30940: LD_VAR 0 4
30944: PUSH
30945: LD_INT 1
30947: ARRAY
30948: IFFALSE 30952
// continue ;
30950: GO 30840
// h := hex [ 2 ] ;
30952: LD_ADDR_VAR 0 13
30956: PUSH
30957: LD_VAR 0 4
30961: PUSH
30962: LD_INT 2
30964: ARRAY
30965: ST_TO_ADDR
// if h + 7 < height then
30966: LD_VAR 0 13
30970: PUSH
30971: LD_INT 7
30973: PLUS
30974: PUSH
30975: LD_VAR 0 15
30979: LESS
30980: IFFALSE 31009
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30982: LD_ADDR_VAR 0 18
30986: PUSH
30987: LD_INT 7
30989: PUSH
30990: LD_INT 28
30992: PUSH
30993: LD_INT 45
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: LIST
31000: PUSH
31001: LD_VAR 0 12
31005: ARRAY
31006: ST_TO_ADDR
// break ;
31007: GO 31011
// end ; end ; end ;
31009: GO 30840
31011: POP
31012: POP
// end ; if not weapon then
31013: LD_VAR 0 18
31017: NOT
31018: IFFALSE 31078
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
31020: LD_ADDR_VAR 0 5
31024: PUSH
31025: LD_VAR 0 5
31029: PUSH
31030: LD_INT 11
31032: PUSH
31033: LD_INT 30
31035: PUSH
31036: LD_INT 49
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: LIST
31043: DIFF
31044: ST_TO_ADDR
// if not list then
31045: LD_VAR 0 5
31049: NOT
31050: IFFALSE 31054
// exit ;
31052: GO 31196
// weapon := list [ rand ( 1 , list ) ] ;
31054: LD_ADDR_VAR 0 18
31058: PUSH
31059: LD_VAR 0 5
31063: PUSH
31064: LD_INT 1
31066: PPUSH
31067: LD_VAR 0 5
31071: PPUSH
31072: CALL_OW 12
31076: ARRAY
31077: ST_TO_ADDR
// end ; if weapon then
31078: LD_VAR 0 18
31082: IFFALSE 31196
// begin tmp := CostOfWeapon ( weapon ) ;
31084: LD_ADDR_VAR 0 14
31088: PUSH
31089: LD_VAR 0 18
31093: PPUSH
31094: CALL_OW 451
31098: ST_TO_ADDR
// j := GetBase ( tower ) ;
31099: LD_ADDR_VAR 0 9
31103: PUSH
31104: LD_VAR 0 1
31108: PPUSH
31109: CALL_OW 274
31113: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
31114: LD_VAR 0 9
31118: PPUSH
31119: LD_INT 1
31121: PPUSH
31122: CALL_OW 275
31126: PUSH
31127: LD_VAR 0 14
31131: PUSH
31132: LD_INT 1
31134: ARRAY
31135: GREATEREQUAL
31136: PUSH
31137: LD_VAR 0 9
31141: PPUSH
31142: LD_INT 2
31144: PPUSH
31145: CALL_OW 275
31149: PUSH
31150: LD_VAR 0 14
31154: PUSH
31155: LD_INT 2
31157: ARRAY
31158: GREATEREQUAL
31159: AND
31160: PUSH
31161: LD_VAR 0 9
31165: PPUSH
31166: LD_INT 3
31168: PPUSH
31169: CALL_OW 275
31173: PUSH
31174: LD_VAR 0 14
31178: PUSH
31179: LD_INT 3
31181: ARRAY
31182: GREATEREQUAL
31183: AND
31184: IFFALSE 31196
// result := weapon ;
31186: LD_ADDR_VAR 0 3
31190: PUSH
31191: LD_VAR 0 18
31195: ST_TO_ADDR
// end ; end ;
31196: LD_VAR 0 3
31200: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31201: LD_INT 0
31203: PPUSH
31204: PPUSH
// result := true ;
31205: LD_ADDR_VAR 0 3
31209: PUSH
31210: LD_INT 1
31212: ST_TO_ADDR
// if array1 = array2 then
31213: LD_VAR 0 1
31217: PUSH
31218: LD_VAR 0 2
31222: EQUAL
31223: IFFALSE 31283
// begin for i = 1 to array1 do
31225: LD_ADDR_VAR 0 4
31229: PUSH
31230: DOUBLE
31231: LD_INT 1
31233: DEC
31234: ST_TO_ADDR
31235: LD_VAR 0 1
31239: PUSH
31240: FOR_TO
31241: IFFALSE 31279
// if array1 [ i ] <> array2 [ i ] then
31243: LD_VAR 0 1
31247: PUSH
31248: LD_VAR 0 4
31252: ARRAY
31253: PUSH
31254: LD_VAR 0 2
31258: PUSH
31259: LD_VAR 0 4
31263: ARRAY
31264: NONEQUAL
31265: IFFALSE 31277
// begin result := false ;
31267: LD_ADDR_VAR 0 3
31271: PUSH
31272: LD_INT 0
31274: ST_TO_ADDR
// break ;
31275: GO 31279
// end ;
31277: GO 31240
31279: POP
31280: POP
// end else
31281: GO 31291
// result := false ;
31283: LD_ADDR_VAR 0 3
31287: PUSH
31288: LD_INT 0
31290: ST_TO_ADDR
// end ;
31291: LD_VAR 0 3
31295: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31296: LD_INT 0
31298: PPUSH
31299: PPUSH
// if not array1 or not array2 then
31300: LD_VAR 0 1
31304: NOT
31305: PUSH
31306: LD_VAR 0 2
31310: NOT
31311: OR
31312: IFFALSE 31316
// exit ;
31314: GO 31380
// result := true ;
31316: LD_ADDR_VAR 0 3
31320: PUSH
31321: LD_INT 1
31323: ST_TO_ADDR
// for i = 1 to array1 do
31324: LD_ADDR_VAR 0 4
31328: PUSH
31329: DOUBLE
31330: LD_INT 1
31332: DEC
31333: ST_TO_ADDR
31334: LD_VAR 0 1
31338: PUSH
31339: FOR_TO
31340: IFFALSE 31378
// if array1 [ i ] <> array2 [ i ] then
31342: LD_VAR 0 1
31346: PUSH
31347: LD_VAR 0 4
31351: ARRAY
31352: PUSH
31353: LD_VAR 0 2
31357: PUSH
31358: LD_VAR 0 4
31362: ARRAY
31363: NONEQUAL
31364: IFFALSE 31376
// begin result := false ;
31366: LD_ADDR_VAR 0 3
31370: PUSH
31371: LD_INT 0
31373: ST_TO_ADDR
// break ;
31374: GO 31378
// end ;
31376: GO 31339
31378: POP
31379: POP
// end ;
31380: LD_VAR 0 3
31384: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31385: LD_INT 0
31387: PPUSH
31388: PPUSH
31389: PPUSH
// pom := GetBase ( fac ) ;
31390: LD_ADDR_VAR 0 5
31394: PUSH
31395: LD_VAR 0 1
31399: PPUSH
31400: CALL_OW 274
31404: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31405: LD_ADDR_VAR 0 4
31409: PUSH
31410: LD_VAR 0 2
31414: PUSH
31415: LD_INT 1
31417: ARRAY
31418: PPUSH
31419: LD_VAR 0 2
31423: PUSH
31424: LD_INT 2
31426: ARRAY
31427: PPUSH
31428: LD_VAR 0 2
31432: PUSH
31433: LD_INT 3
31435: ARRAY
31436: PPUSH
31437: LD_VAR 0 2
31441: PUSH
31442: LD_INT 4
31444: ARRAY
31445: PPUSH
31446: CALL_OW 449
31450: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31451: LD_ADDR_VAR 0 3
31455: PUSH
31456: LD_VAR 0 5
31460: PPUSH
31461: LD_INT 1
31463: PPUSH
31464: CALL_OW 275
31468: PUSH
31469: LD_VAR 0 4
31473: PUSH
31474: LD_INT 1
31476: ARRAY
31477: GREATEREQUAL
31478: PUSH
31479: LD_VAR 0 5
31483: PPUSH
31484: LD_INT 2
31486: PPUSH
31487: CALL_OW 275
31491: PUSH
31492: LD_VAR 0 4
31496: PUSH
31497: LD_INT 2
31499: ARRAY
31500: GREATEREQUAL
31501: AND
31502: PUSH
31503: LD_VAR 0 5
31507: PPUSH
31508: LD_INT 3
31510: PPUSH
31511: CALL_OW 275
31515: PUSH
31516: LD_VAR 0 4
31520: PUSH
31521: LD_INT 3
31523: ARRAY
31524: GREATEREQUAL
31525: AND
31526: ST_TO_ADDR
// end ;
31527: LD_VAR 0 3
31531: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31532: LD_INT 0
31534: PPUSH
31535: PPUSH
31536: PPUSH
31537: PPUSH
// pom := GetBase ( building ) ;
31538: LD_ADDR_VAR 0 3
31542: PUSH
31543: LD_VAR 0 1
31547: PPUSH
31548: CALL_OW 274
31552: ST_TO_ADDR
// if not pom then
31553: LD_VAR 0 3
31557: NOT
31558: IFFALSE 31562
// exit ;
31560: GO 31732
// btype := GetBType ( building ) ;
31562: LD_ADDR_VAR 0 5
31566: PUSH
31567: LD_VAR 0 1
31571: PPUSH
31572: CALL_OW 266
31576: ST_TO_ADDR
// if btype = b_armoury then
31577: LD_VAR 0 5
31581: PUSH
31582: LD_INT 4
31584: EQUAL
31585: IFFALSE 31595
// btype := b_barracks ;
31587: LD_ADDR_VAR 0 5
31591: PUSH
31592: LD_INT 5
31594: ST_TO_ADDR
// if btype = b_depot then
31595: LD_VAR 0 5
31599: PUSH
31600: LD_INT 0
31602: EQUAL
31603: IFFALSE 31613
// btype := b_warehouse ;
31605: LD_ADDR_VAR 0 5
31609: PUSH
31610: LD_INT 1
31612: ST_TO_ADDR
// if btype = b_workshop then
31613: LD_VAR 0 5
31617: PUSH
31618: LD_INT 2
31620: EQUAL
31621: IFFALSE 31631
// btype := b_factory ;
31623: LD_ADDR_VAR 0 5
31627: PUSH
31628: LD_INT 3
31630: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31631: LD_ADDR_VAR 0 4
31635: PUSH
31636: LD_VAR 0 5
31640: PPUSH
31641: LD_VAR 0 1
31645: PPUSH
31646: CALL_OW 248
31650: PPUSH
31651: CALL_OW 450
31655: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31656: LD_ADDR_VAR 0 2
31660: PUSH
31661: LD_VAR 0 3
31665: PPUSH
31666: LD_INT 1
31668: PPUSH
31669: CALL_OW 275
31673: PUSH
31674: LD_VAR 0 4
31678: PUSH
31679: LD_INT 1
31681: ARRAY
31682: GREATEREQUAL
31683: PUSH
31684: LD_VAR 0 3
31688: PPUSH
31689: LD_INT 2
31691: PPUSH
31692: CALL_OW 275
31696: PUSH
31697: LD_VAR 0 4
31701: PUSH
31702: LD_INT 2
31704: ARRAY
31705: GREATEREQUAL
31706: AND
31707: PUSH
31708: LD_VAR 0 3
31712: PPUSH
31713: LD_INT 3
31715: PPUSH
31716: CALL_OW 275
31720: PUSH
31721: LD_VAR 0 4
31725: PUSH
31726: LD_INT 3
31728: ARRAY
31729: GREATEREQUAL
31730: AND
31731: ST_TO_ADDR
// end ;
31732: LD_VAR 0 2
31736: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31737: LD_INT 0
31739: PPUSH
31740: PPUSH
31741: PPUSH
// pom := GetBase ( building ) ;
31742: LD_ADDR_VAR 0 4
31746: PUSH
31747: LD_VAR 0 1
31751: PPUSH
31752: CALL_OW 274
31756: ST_TO_ADDR
// if not pom then
31757: LD_VAR 0 4
31761: NOT
31762: IFFALSE 31766
// exit ;
31764: GO 31867
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31766: LD_ADDR_VAR 0 5
31770: PUSH
31771: LD_VAR 0 2
31775: PPUSH
31776: LD_VAR 0 1
31780: PPUSH
31781: CALL_OW 248
31785: PPUSH
31786: CALL_OW 450
31790: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31791: LD_ADDR_VAR 0 3
31795: PUSH
31796: LD_VAR 0 4
31800: PPUSH
31801: LD_INT 1
31803: PPUSH
31804: CALL_OW 275
31808: PUSH
31809: LD_VAR 0 5
31813: PUSH
31814: LD_INT 1
31816: ARRAY
31817: GREATEREQUAL
31818: PUSH
31819: LD_VAR 0 4
31823: PPUSH
31824: LD_INT 2
31826: PPUSH
31827: CALL_OW 275
31831: PUSH
31832: LD_VAR 0 5
31836: PUSH
31837: LD_INT 2
31839: ARRAY
31840: GREATEREQUAL
31841: AND
31842: PUSH
31843: LD_VAR 0 4
31847: PPUSH
31848: LD_INT 3
31850: PPUSH
31851: CALL_OW 275
31855: PUSH
31856: LD_VAR 0 5
31860: PUSH
31861: LD_INT 3
31863: ARRAY
31864: GREATEREQUAL
31865: AND
31866: ST_TO_ADDR
// end ;
31867: LD_VAR 0 3
31871: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31872: LD_INT 0
31874: PPUSH
31875: PPUSH
31876: PPUSH
31877: PPUSH
31878: PPUSH
31879: PPUSH
31880: PPUSH
31881: PPUSH
31882: PPUSH
31883: PPUSH
31884: PPUSH
// result := false ;
31885: LD_ADDR_VAR 0 8
31889: PUSH
31890: LD_INT 0
31892: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31893: LD_VAR 0 5
31897: NOT
31898: PUSH
31899: LD_VAR 0 1
31903: NOT
31904: OR
31905: PUSH
31906: LD_VAR 0 2
31910: NOT
31911: OR
31912: PUSH
31913: LD_VAR 0 3
31917: NOT
31918: OR
31919: IFFALSE 31923
// exit ;
31921: GO 32737
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31923: LD_ADDR_VAR 0 14
31927: PUSH
31928: LD_VAR 0 1
31932: PPUSH
31933: LD_VAR 0 2
31937: PPUSH
31938: LD_VAR 0 3
31942: PPUSH
31943: LD_VAR 0 4
31947: PPUSH
31948: LD_VAR 0 5
31952: PUSH
31953: LD_INT 1
31955: ARRAY
31956: PPUSH
31957: CALL_OW 248
31961: PPUSH
31962: LD_INT 0
31964: PPUSH
31965: CALL 33970 0 6
31969: ST_TO_ADDR
// if not hexes then
31970: LD_VAR 0 14
31974: NOT
31975: IFFALSE 31979
// exit ;
31977: GO 32737
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31979: LD_ADDR_VAR 0 17
31983: PUSH
31984: LD_VAR 0 5
31988: PPUSH
31989: LD_INT 22
31991: PUSH
31992: LD_VAR 0 13
31996: PPUSH
31997: CALL_OW 255
32001: PUSH
32002: EMPTY
32003: LIST
32004: LIST
32005: PUSH
32006: LD_INT 2
32008: PUSH
32009: LD_INT 30
32011: PUSH
32012: LD_INT 0
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 30
32021: PUSH
32022: LD_INT 1
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: LIST
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PPUSH
32038: CALL_OW 72
32042: ST_TO_ADDR
// for i = 1 to hexes do
32043: LD_ADDR_VAR 0 9
32047: PUSH
32048: DOUBLE
32049: LD_INT 1
32051: DEC
32052: ST_TO_ADDR
32053: LD_VAR 0 14
32057: PUSH
32058: FOR_TO
32059: IFFALSE 32735
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32061: LD_ADDR_VAR 0 13
32065: PUSH
32066: LD_VAR 0 14
32070: PUSH
32071: LD_VAR 0 9
32075: ARRAY
32076: PUSH
32077: LD_INT 1
32079: ARRAY
32080: PPUSH
32081: LD_VAR 0 14
32085: PUSH
32086: LD_VAR 0 9
32090: ARRAY
32091: PUSH
32092: LD_INT 2
32094: ARRAY
32095: PPUSH
32096: CALL_OW 428
32100: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
32101: LD_VAR 0 14
32105: PUSH
32106: LD_VAR 0 9
32110: ARRAY
32111: PUSH
32112: LD_INT 1
32114: ARRAY
32115: PPUSH
32116: LD_VAR 0 14
32120: PUSH
32121: LD_VAR 0 9
32125: ARRAY
32126: PUSH
32127: LD_INT 2
32129: ARRAY
32130: PPUSH
32131: CALL_OW 351
32135: PUSH
32136: LD_VAR 0 14
32140: PUSH
32141: LD_VAR 0 9
32145: ARRAY
32146: PUSH
32147: LD_INT 1
32149: ARRAY
32150: PPUSH
32151: LD_VAR 0 14
32155: PUSH
32156: LD_VAR 0 9
32160: ARRAY
32161: PUSH
32162: LD_INT 2
32164: ARRAY
32165: PPUSH
32166: CALL_OW 488
32170: NOT
32171: OR
32172: PUSH
32173: LD_VAR 0 13
32177: PPUSH
32178: CALL_OW 247
32182: PUSH
32183: LD_INT 3
32185: EQUAL
32186: OR
32187: IFFALSE 32193
// exit ;
32189: POP
32190: POP
32191: GO 32737
// if not tmp then
32193: LD_VAR 0 13
32197: NOT
32198: IFFALSE 32202
// continue ;
32200: GO 32058
// result := true ;
32202: LD_ADDR_VAR 0 8
32206: PUSH
32207: LD_INT 1
32209: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32210: LD_VAR 0 6
32214: PUSH
32215: LD_VAR 0 13
32219: PPUSH
32220: CALL_OW 247
32224: PUSH
32225: LD_INT 2
32227: EQUAL
32228: AND
32229: PUSH
32230: LD_VAR 0 13
32234: PPUSH
32235: CALL_OW 263
32239: PUSH
32240: LD_INT 1
32242: EQUAL
32243: AND
32244: IFFALSE 32408
// begin if IsDrivenBy ( tmp ) then
32246: LD_VAR 0 13
32250: PPUSH
32251: CALL_OW 311
32255: IFFALSE 32259
// continue ;
32257: GO 32058
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32259: LD_VAR 0 6
32263: PPUSH
32264: LD_INT 3
32266: PUSH
32267: LD_INT 60
32269: PUSH
32270: EMPTY
32271: LIST
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 3
32279: PUSH
32280: LD_INT 55
32282: PUSH
32283: EMPTY
32284: LIST
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PPUSH
32294: CALL_OW 72
32298: IFFALSE 32406
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32300: LD_ADDR_VAR 0 18
32304: PUSH
32305: LD_VAR 0 6
32309: PPUSH
32310: LD_INT 3
32312: PUSH
32313: LD_INT 60
32315: PUSH
32316: EMPTY
32317: LIST
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 3
32325: PUSH
32326: LD_INT 55
32328: PUSH
32329: EMPTY
32330: LIST
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PPUSH
32340: CALL_OW 72
32344: PUSH
32345: LD_INT 1
32347: ARRAY
32348: ST_TO_ADDR
// if IsInUnit ( driver ) then
32349: LD_VAR 0 18
32353: PPUSH
32354: CALL_OW 310
32358: IFFALSE 32369
// ComExit ( driver ) ;
32360: LD_VAR 0 18
32364: PPUSH
32365: CALL 57750 0 1
// AddComEnterUnit ( driver , tmp ) ;
32369: LD_VAR 0 18
32373: PPUSH
32374: LD_VAR 0 13
32378: PPUSH
32379: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32383: LD_VAR 0 18
32387: PPUSH
32388: LD_VAR 0 7
32392: PPUSH
32393: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32397: LD_VAR 0 18
32401: PPUSH
32402: CALL_OW 181
// end ; continue ;
32406: GO 32058
// end ; if not cleaners or not tmp in cleaners then
32408: LD_VAR 0 6
32412: NOT
32413: PUSH
32414: LD_VAR 0 13
32418: PUSH
32419: LD_VAR 0 6
32423: IN
32424: NOT
32425: OR
32426: IFFALSE 32733
// begin if dep then
32428: LD_VAR 0 17
32432: IFFALSE 32568
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32434: LD_ADDR_VAR 0 16
32438: PUSH
32439: LD_VAR 0 17
32443: PUSH
32444: LD_INT 1
32446: ARRAY
32447: PPUSH
32448: CALL_OW 250
32452: PPUSH
32453: LD_VAR 0 17
32457: PUSH
32458: LD_INT 1
32460: ARRAY
32461: PPUSH
32462: CALL_OW 254
32466: PPUSH
32467: LD_INT 5
32469: PPUSH
32470: CALL_OW 272
32474: PUSH
32475: LD_VAR 0 17
32479: PUSH
32480: LD_INT 1
32482: ARRAY
32483: PPUSH
32484: CALL_OW 251
32488: PPUSH
32489: LD_VAR 0 17
32493: PUSH
32494: LD_INT 1
32496: ARRAY
32497: PPUSH
32498: CALL_OW 254
32502: PPUSH
32503: LD_INT 5
32505: PPUSH
32506: CALL_OW 273
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32515: LD_VAR 0 16
32519: PUSH
32520: LD_INT 1
32522: ARRAY
32523: PPUSH
32524: LD_VAR 0 16
32528: PUSH
32529: LD_INT 2
32531: ARRAY
32532: PPUSH
32533: CALL_OW 488
32537: IFFALSE 32568
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32539: LD_VAR 0 13
32543: PPUSH
32544: LD_VAR 0 16
32548: PUSH
32549: LD_INT 1
32551: ARRAY
32552: PPUSH
32553: LD_VAR 0 16
32557: PUSH
32558: LD_INT 2
32560: ARRAY
32561: PPUSH
32562: CALL_OW 111
// continue ;
32566: GO 32058
// end ; end ; r := GetDir ( tmp ) ;
32568: LD_ADDR_VAR 0 15
32572: PUSH
32573: LD_VAR 0 13
32577: PPUSH
32578: CALL_OW 254
32582: ST_TO_ADDR
// if r = 5 then
32583: LD_VAR 0 15
32587: PUSH
32588: LD_INT 5
32590: EQUAL
32591: IFFALSE 32601
// r := 0 ;
32593: LD_ADDR_VAR 0 15
32597: PUSH
32598: LD_INT 0
32600: ST_TO_ADDR
// for j = r to 5 do
32601: LD_ADDR_VAR 0 10
32605: PUSH
32606: DOUBLE
32607: LD_VAR 0 15
32611: DEC
32612: ST_TO_ADDR
32613: LD_INT 5
32615: PUSH
32616: FOR_TO
32617: IFFALSE 32731
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32619: LD_ADDR_VAR 0 11
32623: PUSH
32624: LD_VAR 0 13
32628: PPUSH
32629: CALL_OW 250
32633: PPUSH
32634: LD_VAR 0 10
32638: PPUSH
32639: LD_INT 2
32641: PPUSH
32642: CALL_OW 272
32646: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32647: LD_ADDR_VAR 0 12
32651: PUSH
32652: LD_VAR 0 13
32656: PPUSH
32657: CALL_OW 251
32661: PPUSH
32662: LD_VAR 0 10
32666: PPUSH
32667: LD_INT 2
32669: PPUSH
32670: CALL_OW 273
32674: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32675: LD_VAR 0 11
32679: PPUSH
32680: LD_VAR 0 12
32684: PPUSH
32685: CALL_OW 488
32689: PUSH
32690: LD_VAR 0 11
32694: PPUSH
32695: LD_VAR 0 12
32699: PPUSH
32700: CALL_OW 428
32704: NOT
32705: AND
32706: IFFALSE 32729
// begin ComMoveXY ( tmp , _x , _y ) ;
32708: LD_VAR 0 13
32712: PPUSH
32713: LD_VAR 0 11
32717: PPUSH
32718: LD_VAR 0 12
32722: PPUSH
32723: CALL_OW 111
// break ;
32727: GO 32731
// end ; end ;
32729: GO 32616
32731: POP
32732: POP
// end ; end ;
32733: GO 32058
32735: POP
32736: POP
// end ;
32737: LD_VAR 0 8
32741: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32742: LD_INT 0
32744: PPUSH
// result := true ;
32745: LD_ADDR_VAR 0 3
32749: PUSH
32750: LD_INT 1
32752: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32753: LD_VAR 0 2
32757: PUSH
32758: LD_INT 24
32760: DOUBLE
32761: EQUAL
32762: IFTRUE 32772
32764: LD_INT 33
32766: DOUBLE
32767: EQUAL
32768: IFTRUE 32772
32770: GO 32797
32772: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32773: LD_ADDR_VAR 0 3
32777: PUSH
32778: LD_INT 32
32780: PPUSH
32781: LD_VAR 0 1
32785: PPUSH
32786: CALL_OW 321
32790: PUSH
32791: LD_INT 2
32793: EQUAL
32794: ST_TO_ADDR
32795: GO 33113
32797: LD_INT 20
32799: DOUBLE
32800: EQUAL
32801: IFTRUE 32805
32803: GO 32830
32805: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32806: LD_ADDR_VAR 0 3
32810: PUSH
32811: LD_INT 6
32813: PPUSH
32814: LD_VAR 0 1
32818: PPUSH
32819: CALL_OW 321
32823: PUSH
32824: LD_INT 2
32826: EQUAL
32827: ST_TO_ADDR
32828: GO 33113
32830: LD_INT 22
32832: DOUBLE
32833: EQUAL
32834: IFTRUE 32844
32836: LD_INT 36
32838: DOUBLE
32839: EQUAL
32840: IFTRUE 32844
32842: GO 32869
32844: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32845: LD_ADDR_VAR 0 3
32849: PUSH
32850: LD_INT 15
32852: PPUSH
32853: LD_VAR 0 1
32857: PPUSH
32858: CALL_OW 321
32862: PUSH
32863: LD_INT 2
32865: EQUAL
32866: ST_TO_ADDR
32867: GO 33113
32869: LD_INT 30
32871: DOUBLE
32872: EQUAL
32873: IFTRUE 32877
32875: GO 32902
32877: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32878: LD_ADDR_VAR 0 3
32882: PUSH
32883: LD_INT 20
32885: PPUSH
32886: LD_VAR 0 1
32890: PPUSH
32891: CALL_OW 321
32895: PUSH
32896: LD_INT 2
32898: EQUAL
32899: ST_TO_ADDR
32900: GO 33113
32902: LD_INT 28
32904: DOUBLE
32905: EQUAL
32906: IFTRUE 32916
32908: LD_INT 21
32910: DOUBLE
32911: EQUAL
32912: IFTRUE 32916
32914: GO 32941
32916: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32917: LD_ADDR_VAR 0 3
32921: PUSH
32922: LD_INT 21
32924: PPUSH
32925: LD_VAR 0 1
32929: PPUSH
32930: CALL_OW 321
32934: PUSH
32935: LD_INT 2
32937: EQUAL
32938: ST_TO_ADDR
32939: GO 33113
32941: LD_INT 16
32943: DOUBLE
32944: EQUAL
32945: IFTRUE 32949
32947: GO 32974
32949: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32950: LD_ADDR_VAR 0 3
32954: PUSH
32955: LD_INT 84
32957: PPUSH
32958: LD_VAR 0 1
32962: PPUSH
32963: CALL_OW 321
32967: PUSH
32968: LD_INT 2
32970: EQUAL
32971: ST_TO_ADDR
32972: GO 33113
32974: LD_INT 19
32976: DOUBLE
32977: EQUAL
32978: IFTRUE 32988
32980: LD_INT 23
32982: DOUBLE
32983: EQUAL
32984: IFTRUE 32988
32986: GO 33013
32988: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32989: LD_ADDR_VAR 0 3
32993: PUSH
32994: LD_INT 83
32996: PPUSH
32997: LD_VAR 0 1
33001: PPUSH
33002: CALL_OW 321
33006: PUSH
33007: LD_INT 2
33009: EQUAL
33010: ST_TO_ADDR
33011: GO 33113
33013: LD_INT 17
33015: DOUBLE
33016: EQUAL
33017: IFTRUE 33021
33019: GO 33046
33021: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
33022: LD_ADDR_VAR 0 3
33026: PUSH
33027: LD_INT 39
33029: PPUSH
33030: LD_VAR 0 1
33034: PPUSH
33035: CALL_OW 321
33039: PUSH
33040: LD_INT 2
33042: EQUAL
33043: ST_TO_ADDR
33044: GO 33113
33046: LD_INT 18
33048: DOUBLE
33049: EQUAL
33050: IFTRUE 33054
33052: GO 33079
33054: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
33055: LD_ADDR_VAR 0 3
33059: PUSH
33060: LD_INT 40
33062: PPUSH
33063: LD_VAR 0 1
33067: PPUSH
33068: CALL_OW 321
33072: PUSH
33073: LD_INT 2
33075: EQUAL
33076: ST_TO_ADDR
33077: GO 33113
33079: LD_INT 27
33081: DOUBLE
33082: EQUAL
33083: IFTRUE 33087
33085: GO 33112
33087: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
33088: LD_ADDR_VAR 0 3
33092: PUSH
33093: LD_INT 35
33095: PPUSH
33096: LD_VAR 0 1
33100: PPUSH
33101: CALL_OW 321
33105: PUSH
33106: LD_INT 2
33108: EQUAL
33109: ST_TO_ADDR
33110: GO 33113
33112: POP
// end ;
33113: LD_VAR 0 3
33117: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
33118: LD_INT 0
33120: PPUSH
33121: PPUSH
33122: PPUSH
33123: PPUSH
33124: PPUSH
33125: PPUSH
33126: PPUSH
33127: PPUSH
33128: PPUSH
33129: PPUSH
33130: PPUSH
// result := false ;
33131: LD_ADDR_VAR 0 6
33135: PUSH
33136: LD_INT 0
33138: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
33139: LD_VAR 0 1
33143: NOT
33144: PUSH
33145: LD_VAR 0 1
33149: PPUSH
33150: CALL_OW 266
33154: PUSH
33155: LD_INT 0
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: IN
33165: NOT
33166: OR
33167: PUSH
33168: LD_VAR 0 2
33172: NOT
33173: OR
33174: PUSH
33175: LD_VAR 0 5
33179: PUSH
33180: LD_INT 0
33182: PUSH
33183: LD_INT 1
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: LD_INT 3
33191: PUSH
33192: LD_INT 4
33194: PUSH
33195: LD_INT 5
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: IN
33206: NOT
33207: OR
33208: PUSH
33209: LD_VAR 0 3
33213: PPUSH
33214: LD_VAR 0 4
33218: PPUSH
33219: CALL_OW 488
33223: NOT
33224: OR
33225: IFFALSE 33229
// exit ;
33227: GO 33965
// side := GetSide ( depot ) ;
33229: LD_ADDR_VAR 0 9
33233: PUSH
33234: LD_VAR 0 1
33238: PPUSH
33239: CALL_OW 255
33243: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33244: LD_VAR 0 9
33248: PPUSH
33249: LD_VAR 0 2
33253: PPUSH
33254: CALL 32742 0 2
33258: NOT
33259: IFFALSE 33263
// exit ;
33261: GO 33965
// pom := GetBase ( depot ) ;
33263: LD_ADDR_VAR 0 10
33267: PUSH
33268: LD_VAR 0 1
33272: PPUSH
33273: CALL_OW 274
33277: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33278: LD_ADDR_VAR 0 11
33282: PUSH
33283: LD_VAR 0 2
33287: PPUSH
33288: LD_VAR 0 1
33292: PPUSH
33293: CALL_OW 248
33297: PPUSH
33298: CALL_OW 450
33302: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33303: LD_VAR 0 10
33307: PPUSH
33308: LD_INT 1
33310: PPUSH
33311: CALL_OW 275
33315: PUSH
33316: LD_VAR 0 11
33320: PUSH
33321: LD_INT 1
33323: ARRAY
33324: GREATEREQUAL
33325: PUSH
33326: LD_VAR 0 10
33330: PPUSH
33331: LD_INT 2
33333: PPUSH
33334: CALL_OW 275
33338: PUSH
33339: LD_VAR 0 11
33343: PUSH
33344: LD_INT 2
33346: ARRAY
33347: GREATEREQUAL
33348: AND
33349: PUSH
33350: LD_VAR 0 10
33354: PPUSH
33355: LD_INT 3
33357: PPUSH
33358: CALL_OW 275
33362: PUSH
33363: LD_VAR 0 11
33367: PUSH
33368: LD_INT 3
33370: ARRAY
33371: GREATEREQUAL
33372: AND
33373: NOT
33374: IFFALSE 33378
// exit ;
33376: GO 33965
// if GetBType ( depot ) = b_depot then
33378: LD_VAR 0 1
33382: PPUSH
33383: CALL_OW 266
33387: PUSH
33388: LD_INT 0
33390: EQUAL
33391: IFFALSE 33403
// dist := 28 else
33393: LD_ADDR_VAR 0 14
33397: PUSH
33398: LD_INT 28
33400: ST_TO_ADDR
33401: GO 33411
// dist := 36 ;
33403: LD_ADDR_VAR 0 14
33407: PUSH
33408: LD_INT 36
33410: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33411: LD_VAR 0 1
33415: PPUSH
33416: LD_VAR 0 3
33420: PPUSH
33421: LD_VAR 0 4
33425: PPUSH
33426: CALL_OW 297
33430: PUSH
33431: LD_VAR 0 14
33435: GREATER
33436: IFFALSE 33440
// exit ;
33438: GO 33965
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33440: LD_ADDR_VAR 0 12
33444: PUSH
33445: LD_VAR 0 2
33449: PPUSH
33450: LD_VAR 0 3
33454: PPUSH
33455: LD_VAR 0 4
33459: PPUSH
33460: LD_VAR 0 5
33464: PPUSH
33465: LD_VAR 0 1
33469: PPUSH
33470: CALL_OW 248
33474: PPUSH
33475: LD_INT 0
33477: PPUSH
33478: CALL 33970 0 6
33482: ST_TO_ADDR
// if not hexes then
33483: LD_VAR 0 12
33487: NOT
33488: IFFALSE 33492
// exit ;
33490: GO 33965
// hex := GetHexInfo ( x , y ) ;
33492: LD_ADDR_VAR 0 15
33496: PUSH
33497: LD_VAR 0 3
33501: PPUSH
33502: LD_VAR 0 4
33506: PPUSH
33507: CALL_OW 546
33511: ST_TO_ADDR
// if hex [ 1 ] then
33512: LD_VAR 0 15
33516: PUSH
33517: LD_INT 1
33519: ARRAY
33520: IFFALSE 33524
// exit ;
33522: GO 33965
// height := hex [ 2 ] ;
33524: LD_ADDR_VAR 0 13
33528: PUSH
33529: LD_VAR 0 15
33533: PUSH
33534: LD_INT 2
33536: ARRAY
33537: ST_TO_ADDR
// for i = 1 to hexes do
33538: LD_ADDR_VAR 0 7
33542: PUSH
33543: DOUBLE
33544: LD_INT 1
33546: DEC
33547: ST_TO_ADDR
33548: LD_VAR 0 12
33552: PUSH
33553: FOR_TO
33554: IFFALSE 33884
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33556: LD_VAR 0 12
33560: PUSH
33561: LD_VAR 0 7
33565: ARRAY
33566: PUSH
33567: LD_INT 1
33569: ARRAY
33570: PPUSH
33571: LD_VAR 0 12
33575: PUSH
33576: LD_VAR 0 7
33580: ARRAY
33581: PUSH
33582: LD_INT 2
33584: ARRAY
33585: PPUSH
33586: CALL_OW 488
33590: NOT
33591: PUSH
33592: LD_VAR 0 12
33596: PUSH
33597: LD_VAR 0 7
33601: ARRAY
33602: PUSH
33603: LD_INT 1
33605: ARRAY
33606: PPUSH
33607: LD_VAR 0 12
33611: PUSH
33612: LD_VAR 0 7
33616: ARRAY
33617: PUSH
33618: LD_INT 2
33620: ARRAY
33621: PPUSH
33622: CALL_OW 428
33626: PUSH
33627: LD_INT 0
33629: GREATER
33630: OR
33631: PUSH
33632: LD_VAR 0 12
33636: PUSH
33637: LD_VAR 0 7
33641: ARRAY
33642: PUSH
33643: LD_INT 1
33645: ARRAY
33646: PPUSH
33647: LD_VAR 0 12
33651: PUSH
33652: LD_VAR 0 7
33656: ARRAY
33657: PUSH
33658: LD_INT 2
33660: ARRAY
33661: PPUSH
33662: CALL_OW 351
33666: OR
33667: IFFALSE 33673
// exit ;
33669: POP
33670: POP
33671: GO 33965
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33673: LD_ADDR_VAR 0 8
33677: PUSH
33678: LD_VAR 0 12
33682: PUSH
33683: LD_VAR 0 7
33687: ARRAY
33688: PUSH
33689: LD_INT 1
33691: ARRAY
33692: PPUSH
33693: LD_VAR 0 12
33697: PUSH
33698: LD_VAR 0 7
33702: ARRAY
33703: PUSH
33704: LD_INT 2
33706: ARRAY
33707: PPUSH
33708: CALL_OW 546
33712: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33713: LD_VAR 0 8
33717: PUSH
33718: LD_INT 1
33720: ARRAY
33721: PUSH
33722: LD_VAR 0 8
33726: PUSH
33727: LD_INT 2
33729: ARRAY
33730: PUSH
33731: LD_VAR 0 13
33735: PUSH
33736: LD_INT 2
33738: PLUS
33739: GREATER
33740: OR
33741: PUSH
33742: LD_VAR 0 8
33746: PUSH
33747: LD_INT 2
33749: ARRAY
33750: PUSH
33751: LD_VAR 0 13
33755: PUSH
33756: LD_INT 2
33758: MINUS
33759: LESS
33760: OR
33761: PUSH
33762: LD_VAR 0 8
33766: PUSH
33767: LD_INT 3
33769: ARRAY
33770: PUSH
33771: LD_INT 0
33773: PUSH
33774: LD_INT 8
33776: PUSH
33777: LD_INT 9
33779: PUSH
33780: LD_INT 10
33782: PUSH
33783: LD_INT 11
33785: PUSH
33786: LD_INT 12
33788: PUSH
33789: LD_INT 13
33791: PUSH
33792: LD_INT 16
33794: PUSH
33795: LD_INT 17
33797: PUSH
33798: LD_INT 18
33800: PUSH
33801: LD_INT 19
33803: PUSH
33804: LD_INT 20
33806: PUSH
33807: LD_INT 21
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: IN
33825: NOT
33826: OR
33827: PUSH
33828: LD_VAR 0 8
33832: PUSH
33833: LD_INT 5
33835: ARRAY
33836: NOT
33837: OR
33838: PUSH
33839: LD_VAR 0 8
33843: PUSH
33844: LD_INT 6
33846: ARRAY
33847: PUSH
33848: LD_INT 1
33850: PUSH
33851: LD_INT 2
33853: PUSH
33854: LD_INT 7
33856: PUSH
33857: LD_INT 9
33859: PUSH
33860: LD_INT 10
33862: PUSH
33863: LD_INT 11
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: IN
33874: NOT
33875: OR
33876: IFFALSE 33882
// exit ;
33878: POP
33879: POP
33880: GO 33965
// end ;
33882: GO 33553
33884: POP
33885: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33886: LD_VAR 0 9
33890: PPUSH
33891: LD_VAR 0 3
33895: PPUSH
33896: LD_VAR 0 4
33900: PPUSH
33901: LD_INT 20
33903: PPUSH
33904: CALL 25917 0 4
33908: PUSH
33909: LD_INT 4
33911: ARRAY
33912: IFFALSE 33916
// exit ;
33914: GO 33965
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33916: LD_VAR 0 2
33920: PUSH
33921: LD_INT 29
33923: PUSH
33924: LD_INT 30
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: IN
33931: PUSH
33932: LD_VAR 0 3
33936: PPUSH
33937: LD_VAR 0 4
33941: PPUSH
33942: LD_VAR 0 9
33946: PPUSH
33947: CALL_OW 440
33951: NOT
33952: AND
33953: IFFALSE 33957
// exit ;
33955: GO 33965
// result := true ;
33957: LD_ADDR_VAR 0 6
33961: PUSH
33962: LD_INT 1
33964: ST_TO_ADDR
// end ;
33965: LD_VAR 0 6
33969: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33970: LD_INT 0
33972: PPUSH
33973: PPUSH
33974: PPUSH
33975: PPUSH
33976: PPUSH
33977: PPUSH
33978: PPUSH
33979: PPUSH
33980: PPUSH
33981: PPUSH
33982: PPUSH
33983: PPUSH
33984: PPUSH
33985: PPUSH
33986: PPUSH
33987: PPUSH
33988: PPUSH
33989: PPUSH
33990: PPUSH
33991: PPUSH
33992: PPUSH
33993: PPUSH
33994: PPUSH
33995: PPUSH
33996: PPUSH
33997: PPUSH
33998: PPUSH
33999: PPUSH
34000: PPUSH
34001: PPUSH
34002: PPUSH
34003: PPUSH
34004: PPUSH
34005: PPUSH
34006: PPUSH
34007: PPUSH
34008: PPUSH
34009: PPUSH
34010: PPUSH
34011: PPUSH
34012: PPUSH
34013: PPUSH
34014: PPUSH
34015: PPUSH
34016: PPUSH
34017: PPUSH
34018: PPUSH
34019: PPUSH
34020: PPUSH
34021: PPUSH
34022: PPUSH
34023: PPUSH
34024: PPUSH
34025: PPUSH
34026: PPUSH
34027: PPUSH
34028: PPUSH
34029: PPUSH
// result = [ ] ;
34030: LD_ADDR_VAR 0 7
34034: PUSH
34035: EMPTY
34036: ST_TO_ADDR
// temp_list = [ ] ;
34037: LD_ADDR_VAR 0 9
34041: PUSH
34042: EMPTY
34043: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
34044: LD_VAR 0 4
34048: PUSH
34049: LD_INT 0
34051: PUSH
34052: LD_INT 1
34054: PUSH
34055: LD_INT 2
34057: PUSH
34058: LD_INT 3
34060: PUSH
34061: LD_INT 4
34063: PUSH
34064: LD_INT 5
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: IN
34075: NOT
34076: PUSH
34077: LD_VAR 0 1
34081: PUSH
34082: LD_INT 0
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: IN
34092: PUSH
34093: LD_VAR 0 5
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: LD_INT 2
34103: PUSH
34104: LD_INT 3
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: LIST
34111: IN
34112: NOT
34113: AND
34114: OR
34115: IFFALSE 34119
// exit ;
34117: GO 52510
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
34119: LD_VAR 0 1
34123: PUSH
34124: LD_INT 6
34126: PUSH
34127: LD_INT 7
34129: PUSH
34130: LD_INT 8
34132: PUSH
34133: LD_INT 13
34135: PUSH
34136: LD_INT 12
34138: PUSH
34139: LD_INT 15
34141: PUSH
34142: LD_INT 11
34144: PUSH
34145: LD_INT 14
34147: PUSH
34148: LD_INT 10
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: IN
34162: IFFALSE 34172
// btype = b_lab ;
34164: LD_ADDR_VAR 0 1
34168: PUSH
34169: LD_INT 6
34171: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34172: LD_VAR 0 6
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: LD_INT 1
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: LIST
34190: IN
34191: NOT
34192: PUSH
34193: LD_VAR 0 1
34197: PUSH
34198: LD_INT 0
34200: PUSH
34201: LD_INT 1
34203: PUSH
34204: LD_INT 2
34206: PUSH
34207: LD_INT 3
34209: PUSH
34210: LD_INT 6
34212: PUSH
34213: LD_INT 36
34215: PUSH
34216: LD_INT 4
34218: PUSH
34219: LD_INT 5
34221: PUSH
34222: LD_INT 31
34224: PUSH
34225: LD_INT 32
34227: PUSH
34228: LD_INT 33
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: IN
34244: NOT
34245: PUSH
34246: LD_VAR 0 6
34250: PUSH
34251: LD_INT 1
34253: EQUAL
34254: AND
34255: OR
34256: PUSH
34257: LD_VAR 0 1
34261: PUSH
34262: LD_INT 2
34264: PUSH
34265: LD_INT 3
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: IN
34272: NOT
34273: PUSH
34274: LD_VAR 0 6
34278: PUSH
34279: LD_INT 2
34281: EQUAL
34282: AND
34283: OR
34284: IFFALSE 34294
// mode = 0 ;
34286: LD_ADDR_VAR 0 6
34290: PUSH
34291: LD_INT 0
34293: ST_TO_ADDR
// case mode of 0 :
34294: LD_VAR 0 6
34298: PUSH
34299: LD_INT 0
34301: DOUBLE
34302: EQUAL
34303: IFTRUE 34307
34305: GO 45760
34307: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34308: LD_ADDR_VAR 0 11
34312: PUSH
34313: LD_INT 0
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: LD_INT 1
34328: NEG
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 1
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 1
34377: NEG
34378: PUSH
34379: LD_INT 1
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: NEG
34390: PUSH
34391: LD_INT 2
34393: NEG
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: LD_INT 2
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 1
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 2
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: LD_INT 2
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 1
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: PUSH
34455: LD_INT 3
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: LD_INT 3
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: LD_INT 2
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34501: LD_ADDR_VAR 0 12
34505: PUSH
34506: LD_INT 0
34508: PUSH
34509: LD_INT 0
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 0
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 1
34539: PUSH
34540: LD_INT 1
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 0
34549: PUSH
34550: LD_INT 1
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: LD_INT 0
34563: PUSH
34564: EMPTY
34565: LIST
34566: LIST
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: LD_INT 1
34574: NEG
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 1
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 2
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: PUSH
34604: LD_INT 1
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: LD_INT 1
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 2
34624: NEG
34625: PUSH
34626: LD_INT 0
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 2
34635: NEG
34636: PUSH
34637: LD_INT 1
34639: NEG
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: NEG
34648: PUSH
34649: LD_INT 1
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 3
34658: NEG
34659: PUSH
34660: LD_INT 0
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 3
34669: NEG
34670: PUSH
34671: LD_INT 1
34673: NEG
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34697: LD_ADDR_VAR 0 13
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 0
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 1
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 1
34778: NEG
34779: PUSH
34780: LD_INT 2
34782: NEG
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 2
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: LD_INT 2
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 1
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 2
34820: NEG
34821: PUSH
34822: LD_INT 1
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 2
34832: NEG
34833: PUSH
34834: LD_INT 2
34836: NEG
34837: PUSH
34838: EMPTY
34839: LIST
34840: LIST
34841: PUSH
34842: LD_INT 2
34844: NEG
34845: PUSH
34846: LD_INT 3
34848: NEG
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 3
34856: NEG
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 3
34868: NEG
34869: PUSH
34870: LD_INT 3
34872: NEG
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: LIST
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34896: LD_ADDR_VAR 0 14
34900: PUSH
34901: LD_INT 0
34903: PUSH
34904: LD_INT 0
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: LD_INT 1
34916: NEG
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 1
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 1
34934: PUSH
34935: LD_INT 1
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 0
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 1
34965: NEG
34966: PUSH
34967: LD_INT 1
34969: NEG
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: LD_INT 2
34981: NEG
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 0
34989: PUSH
34990: LD_INT 2
34992: NEG
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: LD_INT 1
35000: PUSH
35001: LD_INT 1
35003: NEG
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 1
35011: PUSH
35012: LD_INT 2
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: LD_INT 2
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 1
35031: NEG
35032: PUSH
35033: LD_INT 1
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 3
35046: NEG
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 0
35054: PUSH
35055: LD_INT 3
35057: NEG
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 1
35065: PUSH
35066: LD_INT 2
35068: NEG
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35092: LD_ADDR_VAR 0 15
35096: PUSH
35097: LD_INT 0
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 0
35109: PUSH
35110: LD_INT 1
35112: NEG
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: PUSH
35121: LD_INT 0
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 1
35130: PUSH
35131: LD_INT 1
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 1
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: NEG
35151: PUSH
35152: LD_INT 0
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: NEG
35162: PUSH
35163: LD_INT 1
35165: NEG
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: LD_INT 1
35176: NEG
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 2
35184: PUSH
35185: LD_INT 0
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 1
35204: NEG
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 2
35215: NEG
35216: PUSH
35217: LD_INT 0
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 2
35226: NEG
35227: PUSH
35228: LD_INT 1
35230: NEG
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 2
35238: PUSH
35239: LD_INT 1
35241: NEG
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 3
35249: PUSH
35250: LD_INT 0
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 3
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35285: LD_ADDR_VAR 0 16
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 2
35378: PUSH
35379: LD_INT 1
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PUSH
35386: LD_INT 2
35388: PUSH
35389: LD_INT 2
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: LD_INT 2
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: PUSH
35406: LD_INT 2
35408: NEG
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: NEG
35421: PUSH
35422: LD_INT 2
35424: NEG
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 3
35432: PUSH
35433: LD_INT 2
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 3
35442: PUSH
35443: LD_INT 3
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 2
35452: PUSH
35453: LD_INT 3
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35478: LD_ADDR_VAR 0 17
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: LD_INT 1
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 0
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 1
35547: NEG
35548: PUSH
35549: LD_INT 1
35551: NEG
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: LD_INT 2
35563: NEG
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: LD_INT 2
35574: NEG
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 1
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 2
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: PUSH
35614: LD_INT 2
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 1
35623: PUSH
35624: LD_INT 2
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: LD_INT 2
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: LD_INT 1
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 2
35654: NEG
35655: PUSH
35656: LD_INT 0
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 2
35665: NEG
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 2
35677: NEG
35678: PUSH
35679: LD_INT 2
35681: NEG
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: LIST
35691: LIST
35692: LIST
35693: LIST
35694: LIST
35695: LIST
35696: LIST
35697: LIST
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35708: LD_ADDR_VAR 0 18
35712: PUSH
35713: LD_INT 0
35715: PUSH
35716: LD_INT 0
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 0
35725: PUSH
35726: LD_INT 1
35728: NEG
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 1
35736: PUSH
35737: LD_INT 0
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: LD_INT 1
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: LD_INT 1
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: LD_INT 0
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 1
35777: NEG
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: LD_INT 2
35793: NEG
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 2
35804: NEG
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 2
35823: PUSH
35824: LD_INT 0
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: PUSH
35844: LD_INT 2
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: PUSH
35854: LD_INT 2
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 2
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: NEG
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 2
35884: NEG
35885: PUSH
35886: LD_INT 0
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 2
35895: NEG
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 2
35907: NEG
35908: PUSH
35909: LD_INT 2
35911: NEG
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35938: LD_ADDR_VAR 0 19
35942: PUSH
35943: LD_INT 0
35945: PUSH
35946: LD_INT 0
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PUSH
35953: LD_INT 0
35955: PUSH
35956: LD_INT 1
35958: NEG
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 1
35966: PUSH
35967: LD_INT 0
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 1
35976: PUSH
35977: LD_INT 1
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: LD_INT 1
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 1
36007: NEG
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 1
36019: NEG
36020: PUSH
36021: LD_INT 2
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 0
36031: PUSH
36032: LD_INT 2
36034: NEG
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 1
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 2
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 2
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: LD_INT 2
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 1
36083: PUSH
36084: LD_INT 2
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: LD_INT 2
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 1
36103: NEG
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 2
36114: NEG
36115: PUSH
36116: LD_INT 0
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 2
36125: NEG
36126: PUSH
36127: LD_INT 1
36129: NEG
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 2
36137: NEG
36138: PUSH
36139: LD_INT 2
36141: NEG
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36168: LD_ADDR_VAR 0 20
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 0
36185: PUSH
36186: LD_INT 1
36188: NEG
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 1
36196: PUSH
36197: LD_INT 0
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 1
36206: PUSH
36207: LD_INT 1
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 1
36226: NEG
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: NEG
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 1
36249: NEG
36250: PUSH
36251: LD_INT 2
36253: NEG
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 0
36261: PUSH
36262: LD_INT 2
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 1
36272: PUSH
36273: LD_INT 1
36275: NEG
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 2
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: LD_INT 1
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 2
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: PUSH
36314: LD_INT 2
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: LD_INT 2
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 1
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 2
36344: NEG
36345: PUSH
36346: LD_INT 0
36348: PUSH
36349: EMPTY
36350: LIST
36351: LIST
36352: PUSH
36353: LD_INT 2
36355: NEG
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 2
36367: NEG
36368: PUSH
36369: LD_INT 2
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: LIST
36381: LIST
36382: LIST
36383: LIST
36384: LIST
36385: LIST
36386: LIST
36387: LIST
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36398: LD_ADDR_VAR 0 21
36402: PUSH
36403: LD_INT 0
36405: PUSH
36406: LD_INT 0
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 0
36415: PUSH
36416: LD_INT 1
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 1
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: LD_INT 1
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 0
36446: PUSH
36447: LD_INT 1
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 1
36456: NEG
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: PUSH
36465: LD_INT 1
36467: NEG
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: EMPTY
36474: LIST
36475: LIST
36476: PUSH
36477: LD_INT 1
36479: NEG
36480: PUSH
36481: LD_INT 2
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: LD_INT 2
36494: NEG
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: LD_INT 1
36505: NEG
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 2
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 2
36523: PUSH
36524: LD_INT 1
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 2
36533: PUSH
36534: LD_INT 2
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 1
36543: PUSH
36544: LD_INT 2
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 0
36553: PUSH
36554: LD_INT 2
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: LD_INT 1
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 2
36574: NEG
36575: PUSH
36576: LD_INT 0
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 2
36585: NEG
36586: PUSH
36587: LD_INT 1
36589: NEG
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 2
36597: NEG
36598: PUSH
36599: LD_INT 2
36601: NEG
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36628: LD_ADDR_VAR 0 22
36632: PUSH
36633: LD_INT 0
36635: PUSH
36636: LD_INT 0
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: PUSH
36657: LD_INT 0
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 1
36666: PUSH
36667: LD_INT 1
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: LD_INT 1
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 1
36686: NEG
36687: PUSH
36688: LD_INT 0
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 1
36697: NEG
36698: PUSH
36699: LD_INT 1
36701: NEG
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 1
36709: NEG
36710: PUSH
36711: LD_INT 2
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 0
36721: PUSH
36722: LD_INT 2
36724: NEG
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: LD_INT 1
36735: NEG
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: PUSH
36741: LD_INT 2
36743: PUSH
36744: LD_INT 0
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 2
36753: PUSH
36754: LD_INT 1
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: LD_INT 2
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 1
36773: PUSH
36774: LD_INT 2
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: LD_INT 2
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 1
36793: NEG
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 2
36804: NEG
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 2
36815: NEG
36816: PUSH
36817: LD_INT 1
36819: NEG
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 2
36827: NEG
36828: PUSH
36829: LD_INT 2
36831: NEG
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36858: LD_ADDR_VAR 0 23
36862: PUSH
36863: LD_INT 0
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 1
36886: PUSH
36887: LD_INT 0
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: LD_INT 1
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 0
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 1
36916: NEG
36917: PUSH
36918: LD_INT 0
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 1
36927: NEG
36928: PUSH
36929: LD_INT 1
36931: NEG
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 1
36939: NEG
36940: PUSH
36941: LD_INT 2
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 0
36951: PUSH
36952: LD_INT 2
36954: NEG
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 1
36962: PUSH
36963: LD_INT 1
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 2
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 2
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 2
36993: PUSH
36994: LD_INT 2
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: LD_INT 2
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: LD_INT 2
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 1
37023: NEG
37024: PUSH
37025: LD_INT 1
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 2
37034: NEG
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 2
37045: NEG
37046: PUSH
37047: LD_INT 1
37049: NEG
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: LD_INT 2
37057: NEG
37058: PUSH
37059: LD_INT 2
37061: NEG
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 2
37069: NEG
37070: PUSH
37071: LD_INT 3
37073: NEG
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 1
37081: NEG
37082: PUSH
37083: LD_INT 3
37085: NEG
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 1
37093: PUSH
37094: LD_INT 2
37096: NEG
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 2
37104: PUSH
37105: LD_INT 1
37107: NEG
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
37138: LD_ADDR_VAR 0 24
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: LD_INT 0
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: LD_INT 1
37158: NEG
37159: PUSH
37160: EMPTY
37161: LIST
37162: LIST
37163: PUSH
37164: LD_INT 1
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 1
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: LD_INT 0
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 1
37207: NEG
37208: PUSH
37209: LD_INT 1
37211: NEG
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: LD_INT 2
37223: NEG
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 2
37234: NEG
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: LD_INT 1
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 2
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 2
37263: PUSH
37264: LD_INT 1
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 2
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 1
37283: PUSH
37284: LD_INT 2
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 0
37293: PUSH
37294: LD_INT 2
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 1
37303: NEG
37304: PUSH
37305: LD_INT 1
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 2
37314: NEG
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 2
37325: NEG
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 2
37337: NEG
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 1
37349: PUSH
37350: LD_INT 2
37352: NEG
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 2
37360: PUSH
37361: LD_INT 1
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 3
37371: PUSH
37372: LD_INT 1
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 3
37381: PUSH
37382: LD_INT 2
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37414: LD_ADDR_VAR 0 25
37418: PUSH
37419: LD_INT 0
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 0
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 1
37442: PUSH
37443: LD_INT 0
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 1
37452: PUSH
37453: LD_INT 1
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 0
37462: PUSH
37463: LD_INT 1
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 1
37483: NEG
37484: PUSH
37485: LD_INT 1
37487: NEG
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 1
37495: NEG
37496: PUSH
37497: LD_INT 2
37499: NEG
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 0
37507: PUSH
37508: LD_INT 2
37510: NEG
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 1
37518: PUSH
37519: LD_INT 1
37521: NEG
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 2
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 2
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 2
37549: PUSH
37550: LD_INT 2
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: LD_INT 2
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 0
37569: PUSH
37570: LD_INT 2
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 1
37579: NEG
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 2
37590: NEG
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 2
37601: NEG
37602: PUSH
37603: LD_INT 1
37605: NEG
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 2
37613: NEG
37614: PUSH
37615: LD_INT 2
37617: NEG
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 3
37625: PUSH
37626: LD_INT 1
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 3
37635: PUSH
37636: LD_INT 2
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 2
37645: PUSH
37646: LD_INT 3
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: LD_INT 1
37655: PUSH
37656: LD_INT 3
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37688: LD_ADDR_VAR 0 26
37692: PUSH
37693: LD_INT 0
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 1
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 0
37736: PUSH
37737: LD_INT 1
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 1
37746: NEG
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: LD_INT 2
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: LD_INT 2
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 1
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 2
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 2
37813: PUSH
37814: LD_INT 1
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 2
37823: PUSH
37824: LD_INT 2
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 1
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: LD_INT 1
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 2
37864: NEG
37865: PUSH
37866: LD_INT 0
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 2
37875: NEG
37876: PUSH
37877: LD_INT 1
37879: NEG
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: LD_INT 2
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 2
37899: PUSH
37900: LD_INT 3
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 1
37909: PUSH
37910: LD_INT 3
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: NEG
37920: PUSH
37921: LD_INT 2
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 2
37930: NEG
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37964: LD_ADDR_VAR 0 27
37968: PUSH
37969: LD_INT 0
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 0
37981: PUSH
37982: LD_INT 1
37984: NEG
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 1
37992: PUSH
37993: LD_INT 0
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 1
38002: PUSH
38003: LD_INT 1
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 0
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 1
38022: NEG
38023: PUSH
38024: LD_INT 0
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 1
38033: NEG
38034: PUSH
38035: LD_INT 1
38037: NEG
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 1
38045: NEG
38046: PUSH
38047: LD_INT 2
38049: NEG
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 0
38057: PUSH
38058: LD_INT 2
38060: NEG
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 1
38068: PUSH
38069: LD_INT 1
38071: NEG
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 2
38079: PUSH
38080: LD_INT 0
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 2
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 2
38099: PUSH
38100: LD_INT 2
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: LD_INT 2
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 1
38129: NEG
38130: PUSH
38131: LD_INT 1
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 2
38140: NEG
38141: PUSH
38142: LD_INT 0
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 2
38163: NEG
38164: PUSH
38165: LD_INT 2
38167: NEG
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 1
38175: NEG
38176: PUSH
38177: LD_INT 2
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 2
38186: NEG
38187: PUSH
38188: LD_INT 1
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 3
38197: NEG
38198: PUSH
38199: LD_INT 1
38201: NEG
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 3
38209: NEG
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: LIST
38233: LIST
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38244: LD_ADDR_VAR 0 28
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: LD_INT 0
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 0
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 1
38272: PUSH
38273: LD_INT 0
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 1
38302: NEG
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: NEG
38314: PUSH
38315: LD_INT 1
38317: NEG
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: LD_INT 2
38329: NEG
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: LD_INT 2
38340: NEG
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 1
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 2
38359: PUSH
38360: LD_INT 0
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: LD_INT 2
38369: PUSH
38370: LD_INT 1
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 2
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 0
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 1
38409: NEG
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 2
38431: NEG
38432: PUSH
38433: LD_INT 1
38435: NEG
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 2
38455: NEG
38456: PUSH
38457: LD_INT 3
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 1
38467: NEG
38468: PUSH
38469: LD_INT 3
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 3
38479: NEG
38480: PUSH
38481: LD_INT 1
38483: NEG
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 3
38491: NEG
38492: PUSH
38493: LD_INT 2
38495: NEG
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38526: LD_ADDR_VAR 0 29
38530: PUSH
38531: LD_INT 0
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 0
38543: PUSH
38544: LD_INT 1
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: PUSH
38565: LD_INT 1
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 1
38595: NEG
38596: PUSH
38597: LD_INT 1
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 1
38607: NEG
38608: PUSH
38609: LD_INT 2
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: LD_INT 2
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 1
38630: PUSH
38631: LD_INT 1
38633: NEG
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: LD_INT 2
38641: PUSH
38642: LD_INT 0
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 2
38651: PUSH
38652: LD_INT 1
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: LD_INT 2
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: LD_INT 2
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 1
38681: NEG
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 2
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: NEG
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 2
38704: NEG
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 2
38716: NEG
38717: PUSH
38718: LD_INT 3
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 2
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 3
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 1
38749: PUSH
38750: LD_INT 3
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 1
38759: NEG
38760: PUSH
38761: LD_INT 2
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 3
38770: NEG
38771: PUSH
38772: LD_INT 2
38774: NEG
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38805: LD_ADDR_VAR 0 30
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: LD_INT 0
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 1
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: LD_INT 0
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 1
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 1
38863: NEG
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: NEG
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: LD_INT 2
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 2
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: PUSH
38921: LD_INT 0
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 2
38930: PUSH
38931: LD_INT 1
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: LD_INT 2
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: LD_INT 2
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 2
38971: NEG
38972: PUSH
38973: LD_INT 0
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 2
38982: NEG
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 1
38994: NEG
38995: PUSH
38996: LD_INT 3
38998: NEG
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 1
39006: PUSH
39007: LD_INT 2
39009: NEG
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 3
39017: PUSH
39018: LD_INT 2
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 2
39027: PUSH
39028: LD_INT 3
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 2
39037: NEG
39038: PUSH
39039: LD_INT 1
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 3
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39083: LD_ADDR_VAR 0 31
39087: PUSH
39088: LD_INT 0
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 1
39121: PUSH
39122: LD_INT 1
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 1
39152: NEG
39153: PUSH
39154: LD_INT 1
39156: NEG
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: LD_INT 2
39168: NEG
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: LD_INT 1
39179: NEG
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 2
39187: PUSH
39188: LD_INT 0
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 2
39197: PUSH
39198: LD_INT 1
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 2
39207: PUSH
39208: LD_INT 2
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 1
39217: PUSH
39218: LD_INT 2
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: LD_INT 2
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 1
39237: NEG
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 2
39248: NEG
39249: PUSH
39250: LD_INT 1
39252: NEG
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 2
39260: NEG
39261: PUSH
39262: LD_INT 2
39264: NEG
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: LD_INT 3
39276: NEG
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 3
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 1
39305: PUSH
39306: LD_INT 3
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: NEG
39316: PUSH
39317: LD_INT 2
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 3
39326: NEG
39327: PUSH
39328: LD_INT 2
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39361: LD_ADDR_VAR 0 32
39365: PUSH
39366: LD_INT 0
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 0
39378: PUSH
39379: LD_INT 1
39381: NEG
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: LD_INT 1
39389: PUSH
39390: LD_INT 0
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: LD_INT 1
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: LD_INT 0
39409: PUSH
39410: LD_INT 1
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: NEG
39420: PUSH
39421: LD_INT 0
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 1
39430: NEG
39431: PUSH
39432: LD_INT 1
39434: NEG
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 1
39442: NEG
39443: PUSH
39444: LD_INT 2
39446: NEG
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 0
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 1
39465: PUSH
39466: LD_INT 1
39468: NEG
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 2
39476: PUSH
39477: LD_INT 1
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: LD_INT 2
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 1
39496: PUSH
39497: LD_INT 2
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: LD_INT 2
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 1
39516: NEG
39517: PUSH
39518: LD_INT 1
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 2
39527: NEG
39528: PUSH
39529: LD_INT 0
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 2
39538: NEG
39539: PUSH
39540: LD_INT 1
39542: NEG
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 1
39550: NEG
39551: PUSH
39552: LD_INT 3
39554: NEG
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: LD_INT 1
39562: PUSH
39563: LD_INT 2
39565: NEG
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 3
39573: PUSH
39574: LD_INT 2
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 2
39583: PUSH
39584: LD_INT 3
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 2
39593: NEG
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 3
39604: NEG
39605: PUSH
39606: LD_INT 1
39608: NEG
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: EMPTY
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39639: LD_ADDR_VAR 0 33
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 0
39656: PUSH
39657: LD_INT 1
39659: NEG
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 1
39667: PUSH
39668: LD_INT 0
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 1
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: LD_INT 1
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: NEG
39698: PUSH
39699: LD_INT 0
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 1
39708: NEG
39709: PUSH
39710: LD_INT 1
39712: NEG
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: LD_INT 1
39720: NEG
39721: PUSH
39722: LD_INT 2
39724: NEG
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 1
39732: PUSH
39733: LD_INT 1
39735: NEG
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 2
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: LD_INT 1
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: LD_INT 2
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 1
39783: NEG
39784: PUSH
39785: LD_INT 1
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 2
39794: NEG
39795: PUSH
39796: LD_INT 0
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 2
39805: NEG
39806: PUSH
39807: LD_INT 1
39809: NEG
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 2
39817: NEG
39818: PUSH
39819: LD_INT 2
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 2
39829: NEG
39830: PUSH
39831: LD_INT 3
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 2
39841: PUSH
39842: LD_INT 1
39844: NEG
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 3
39852: PUSH
39853: LD_INT 1
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: PUSH
39863: LD_INT 3
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 1
39872: NEG
39873: PUSH
39874: LD_INT 2
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PUSH
39881: LD_INT 3
39883: NEG
39884: PUSH
39885: LD_INT 2
39887: NEG
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39918: LD_ADDR_VAR 0 34
39922: PUSH
39923: LD_INT 0
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: EMPTY
39930: LIST
39931: LIST
39932: PUSH
39933: LD_INT 0
39935: PUSH
39936: LD_INT 1
39938: NEG
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 1
39946: PUSH
39947: LD_INT 0
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 1
39956: PUSH
39957: LD_INT 1
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: LD_INT 1
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 1
39976: NEG
39977: PUSH
39978: LD_INT 0
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 1
39987: NEG
39988: PUSH
39989: LD_INT 1
39991: NEG
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 1
39999: NEG
40000: PUSH
40001: LD_INT 2
40003: NEG
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 0
40011: PUSH
40012: LD_INT 2
40014: NEG
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: PUSH
40023: LD_INT 1
40025: NEG
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 2
40033: PUSH
40034: LD_INT 1
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 2
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 1
40053: PUSH
40054: LD_INT 2
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: NEG
40064: PUSH
40065: LD_INT 1
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 2
40074: NEG
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: LD_INT 2
40097: NEG
40098: PUSH
40099: LD_INT 2
40101: NEG
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: PUSH
40107: LD_INT 1
40109: NEG
40110: PUSH
40111: LD_INT 3
40113: NEG
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 1
40121: PUSH
40122: LD_INT 2
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 3
40132: PUSH
40133: LD_INT 2
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 2
40142: PUSH
40143: LD_INT 3
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 2
40152: NEG
40153: PUSH
40154: LD_INT 1
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 3
40163: NEG
40164: PUSH
40165: LD_INT 1
40167: NEG
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40198: LD_ADDR_VAR 0 35
40202: PUSH
40203: LD_INT 0
40205: PUSH
40206: LD_INT 0
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 0
40215: PUSH
40216: LD_INT 1
40218: NEG
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 1
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 1
40236: PUSH
40237: LD_INT 1
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 0
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: NEG
40257: PUSH
40258: LD_INT 0
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 1
40267: NEG
40268: PUSH
40269: LD_INT 1
40271: NEG
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 2
40279: PUSH
40280: LD_INT 1
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 2
40289: NEG
40290: PUSH
40291: LD_INT 1
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40310: LD_ADDR_VAR 0 36
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: LD_INT 0
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: LD_INT 1
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 1
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 1
40348: PUSH
40349: LD_INT 1
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 0
40358: PUSH
40359: LD_INT 1
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 0
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 1
40391: NEG
40392: PUSH
40393: LD_INT 2
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 1
40403: PUSH
40404: LD_INT 2
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40422: LD_ADDR_VAR 0 37
40426: PUSH
40427: LD_INT 0
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: LD_INT 1
40442: NEG
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: PUSH
40451: LD_INT 0
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: PUSH
40461: LD_INT 1
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: LD_INT 0
40470: PUSH
40471: LD_INT 1
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: PUSH
40478: LD_INT 1
40480: NEG
40481: PUSH
40482: LD_INT 0
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: LD_INT 1
40495: NEG
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 1
40503: PUSH
40504: LD_INT 1
40506: NEG
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 1
40514: NEG
40515: PUSH
40516: LD_INT 1
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40534: LD_ADDR_VAR 0 38
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 0
40551: PUSH
40552: LD_INT 1
40554: NEG
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 1
40562: PUSH
40563: LD_INT 0
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 1
40572: PUSH
40573: LD_INT 1
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 0
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 1
40592: NEG
40593: PUSH
40594: LD_INT 0
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 1
40603: NEG
40604: PUSH
40605: LD_INT 1
40607: NEG
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 2
40615: PUSH
40616: LD_INT 1
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 2
40625: NEG
40626: PUSH
40627: LD_INT 1
40629: NEG
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40646: LD_ADDR_VAR 0 39
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: LD_INT 1
40666: NEG
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 1
40674: PUSH
40675: LD_INT 0
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 1
40684: PUSH
40685: LD_INT 1
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 0
40694: PUSH
40695: LD_INT 1
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 0
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 1
40715: NEG
40716: PUSH
40717: LD_INT 1
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 2
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: LD_INT 2
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40758: LD_ADDR_VAR 0 40
40762: PUSH
40763: LD_INT 0
40765: PUSH
40766: LD_INT 0
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: LD_INT 1
40778: NEG
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: LD_INT 1
40786: PUSH
40787: LD_INT 0
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 1
40796: PUSH
40797: LD_INT 1
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 0
40806: PUSH
40807: LD_INT 1
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 1
40816: NEG
40817: PUSH
40818: LD_INT 0
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 1
40827: NEG
40828: PUSH
40829: LD_INT 1
40831: NEG
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 1
40839: PUSH
40840: LD_INT 1
40842: NEG
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 1
40850: NEG
40851: PUSH
40852: LD_INT 1
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40870: LD_ADDR_VAR 0 41
40874: PUSH
40875: LD_INT 0
40877: PUSH
40878: LD_INT 0
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 0
40887: PUSH
40888: LD_INT 1
40890: NEG
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PUSH
40896: LD_INT 1
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 1
40908: PUSH
40909: LD_INT 1
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 0
40918: PUSH
40919: LD_INT 1
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 1
40928: NEG
40929: PUSH
40930: LD_INT 0
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: LD_INT 1
40943: NEG
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 1
40951: NEG
40952: PUSH
40953: LD_INT 2
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: PUSH
40964: LD_INT 1
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 2
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 2
40984: PUSH
40985: LD_INT 1
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 2
40994: PUSH
40995: LD_INT 2
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: PUSH
41005: LD_INT 2
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 1
41014: NEG
41015: PUSH
41016: LD_INT 1
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 2
41025: NEG
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: LD_INT 2
41036: NEG
41037: PUSH
41038: LD_INT 1
41040: NEG
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 2
41048: NEG
41049: PUSH
41050: LD_INT 2
41052: NEG
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 2
41060: NEG
41061: PUSH
41062: LD_INT 3
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 2
41072: PUSH
41073: LD_INT 1
41075: NEG
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 3
41083: PUSH
41084: LD_INT 0
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 3
41093: PUSH
41094: LD_INT 1
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: LD_INT 3
41103: PUSH
41104: LD_INT 2
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 3
41113: PUSH
41114: LD_INT 3
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 2
41123: PUSH
41124: LD_INT 3
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 2
41133: NEG
41134: PUSH
41135: LD_INT 1
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 3
41144: NEG
41145: PUSH
41146: LD_INT 0
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 3
41155: NEG
41156: PUSH
41157: LD_INT 1
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 3
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 3
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: LIST
41193: LIST
41194: LIST
41195: LIST
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41220: LD_ADDR_VAR 0 42
41224: PUSH
41225: LD_INT 0
41227: PUSH
41228: LD_INT 0
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 0
41237: PUSH
41238: LD_INT 1
41240: NEG
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 1
41248: PUSH
41249: LD_INT 0
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 1
41258: PUSH
41259: LD_INT 1
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 0
41268: PUSH
41269: LD_INT 1
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 1
41278: NEG
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 1
41289: NEG
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 1
41301: NEG
41302: PUSH
41303: LD_INT 2
41305: NEG
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 0
41313: PUSH
41314: LD_INT 2
41316: NEG
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 1
41324: PUSH
41325: LD_INT 1
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 2
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 2
41345: PUSH
41346: LD_INT 2
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 1
41355: PUSH
41356: LD_INT 2
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: LD_INT 2
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 1
41375: NEG
41376: PUSH
41377: LD_INT 1
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PUSH
41384: LD_INT 2
41386: NEG
41387: PUSH
41388: LD_INT 1
41390: NEG
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 2
41398: NEG
41399: PUSH
41400: LD_INT 2
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 2
41410: NEG
41411: PUSH
41412: LD_INT 3
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: LD_INT 0
41434: PUSH
41435: LD_INT 3
41437: NEG
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 1
41445: PUSH
41446: LD_INT 2
41448: NEG
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: LD_INT 3
41456: PUSH
41457: LD_INT 2
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 3
41466: PUSH
41467: LD_INT 3
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 2
41476: PUSH
41477: LD_INT 3
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 1
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: LD_INT 3
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 1
41506: NEG
41507: PUSH
41508: LD_INT 2
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 3
41517: NEG
41518: PUSH
41519: LD_INT 2
41521: NEG
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 3
41529: NEG
41530: PUSH
41531: LD_INT 3
41533: NEG
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41570: LD_ADDR_VAR 0 43
41574: PUSH
41575: LD_INT 0
41577: PUSH
41578: LD_INT 0
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 0
41587: PUSH
41588: LD_INT 1
41590: NEG
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 1
41598: PUSH
41599: LD_INT 0
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 1
41608: PUSH
41609: LD_INT 1
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: LD_INT 1
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 1
41628: NEG
41629: PUSH
41630: LD_INT 0
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 1
41639: NEG
41640: PUSH
41641: LD_INT 1
41643: NEG
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 1
41651: NEG
41652: PUSH
41653: LD_INT 2
41655: NEG
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: PUSH
41661: LD_INT 0
41663: PUSH
41664: LD_INT 2
41666: NEG
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 1
41674: PUSH
41675: LD_INT 1
41677: NEG
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 2
41685: PUSH
41686: LD_INT 0
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 2
41695: PUSH
41696: LD_INT 1
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: PUSH
41706: LD_INT 2
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: LD_INT 0
41715: PUSH
41716: LD_INT 2
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 1
41725: NEG
41726: PUSH
41727: LD_INT 1
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 2
41736: NEG
41737: PUSH
41738: LD_INT 0
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: LD_INT 2
41747: NEG
41748: PUSH
41749: LD_INT 1
41751: NEG
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 1
41759: NEG
41760: PUSH
41761: LD_INT 3
41763: NEG
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: LD_INT 3
41774: NEG
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 1
41782: PUSH
41783: LD_INT 2
41785: NEG
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: LD_INT 1
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 3
41804: PUSH
41805: LD_INT 0
41807: PUSH
41808: EMPTY
41809: LIST
41810: LIST
41811: PUSH
41812: LD_INT 3
41814: PUSH
41815: LD_INT 1
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: LD_INT 3
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: LD_INT 0
41834: PUSH
41835: LD_INT 3
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 1
41844: NEG
41845: PUSH
41846: LD_INT 2
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: LD_INT 2
41855: NEG
41856: PUSH
41857: LD_INT 1
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 3
41866: NEG
41867: PUSH
41868: LD_INT 0
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 3
41877: NEG
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: LIST
41903: LIST
41904: LIST
41905: LIST
41906: LIST
41907: LIST
41908: LIST
41909: LIST
41910: LIST
41911: LIST
41912: LIST
41913: LIST
41914: LIST
41915: LIST
41916: LIST
41917: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41918: LD_ADDR_VAR 0 44
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: LD_INT 0
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 0
41935: PUSH
41936: LD_INT 1
41938: NEG
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 1
41946: PUSH
41947: LD_INT 0
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 1
41956: PUSH
41957: LD_INT 1
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 0
41966: PUSH
41967: LD_INT 1
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 1
41976: NEG
41977: PUSH
41978: LD_INT 0
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: NEG
41988: PUSH
41989: LD_INT 1
41991: NEG
41992: PUSH
41993: EMPTY
41994: LIST
41995: LIST
41996: PUSH
41997: LD_INT 1
41999: NEG
42000: PUSH
42001: LD_INT 2
42003: NEG
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 1
42011: PUSH
42012: LD_INT 1
42014: NEG
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: LD_INT 2
42022: PUSH
42023: LD_INT 0
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 2
42032: PUSH
42033: LD_INT 1
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: LD_INT 2
42042: PUSH
42043: LD_INT 2
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 1
42052: PUSH
42053: LD_INT 2
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 1
42062: NEG
42063: PUSH
42064: LD_INT 1
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 2
42073: NEG
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: LD_INT 2
42084: NEG
42085: PUSH
42086: LD_INT 1
42088: NEG
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PUSH
42094: LD_INT 2
42096: NEG
42097: PUSH
42098: LD_INT 2
42100: NEG
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 2
42108: NEG
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 2
42120: PUSH
42121: LD_INT 1
42123: NEG
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 3
42131: PUSH
42132: LD_INT 0
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 3
42141: PUSH
42142: LD_INT 1
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 3
42151: PUSH
42152: LD_INT 2
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 3
42161: PUSH
42162: LD_INT 3
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: LD_INT 2
42171: PUSH
42172: LD_INT 3
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: NEG
42182: PUSH
42183: LD_INT 1
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 3
42192: NEG
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 3
42203: NEG
42204: PUSH
42205: LD_INT 1
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: NEG
42216: PUSH
42217: LD_INT 2
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: LIST
42267: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42268: LD_ADDR_VAR 0 45
42272: PUSH
42273: LD_INT 0
42275: PUSH
42276: LD_INT 0
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 0
42285: PUSH
42286: LD_INT 1
42288: NEG
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: LD_INT 0
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 1
42306: PUSH
42307: LD_INT 1
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: LD_INT 1
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: LD_INT 1
42326: NEG
42327: PUSH
42328: LD_INT 0
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 1
42337: NEG
42338: PUSH
42339: LD_INT 1
42341: NEG
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 1
42349: NEG
42350: PUSH
42351: LD_INT 2
42353: NEG
42354: PUSH
42355: EMPTY
42356: LIST
42357: LIST
42358: PUSH
42359: LD_INT 0
42361: PUSH
42362: LD_INT 2
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 1
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 2
42383: PUSH
42384: LD_INT 1
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 2
42393: PUSH
42394: LD_INT 2
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 1
42403: PUSH
42404: LD_INT 2
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 0
42413: PUSH
42414: LD_INT 2
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 1
42423: NEG
42424: PUSH
42425: LD_INT 1
42427: PUSH
42428: EMPTY
42429: LIST
42430: LIST
42431: PUSH
42432: LD_INT 2
42434: NEG
42435: PUSH
42436: LD_INT 1
42438: NEG
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: LD_INT 2
42446: NEG
42447: PUSH
42448: LD_INT 2
42450: NEG
42451: PUSH
42452: EMPTY
42453: LIST
42454: LIST
42455: PUSH
42456: LD_INT 2
42458: NEG
42459: PUSH
42460: LD_INT 3
42462: NEG
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 1
42470: NEG
42471: PUSH
42472: LD_INT 3
42474: NEG
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 0
42482: PUSH
42483: LD_INT 3
42485: NEG
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 1
42493: PUSH
42494: LD_INT 2
42496: NEG
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: LD_INT 3
42504: PUSH
42505: LD_INT 2
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 3
42514: PUSH
42515: LD_INT 3
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 2
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: PUSH
42535: LD_INT 3
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 0
42544: PUSH
42545: LD_INT 3
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 1
42554: NEG
42555: PUSH
42556: LD_INT 2
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 3
42565: NEG
42566: PUSH
42567: LD_INT 2
42569: NEG
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: PUSH
42575: LD_INT 3
42577: NEG
42578: PUSH
42579: LD_INT 3
42581: NEG
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42618: LD_ADDR_VAR 0 46
42622: PUSH
42623: LD_INT 0
42625: PUSH
42626: LD_INT 0
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: LD_INT 1
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 1
42646: PUSH
42647: LD_INT 0
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 1
42656: PUSH
42657: LD_INT 1
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: LD_INT 1
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: LD_INT 0
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 1
42687: NEG
42688: PUSH
42689: LD_INT 1
42691: NEG
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 1
42699: NEG
42700: PUSH
42701: LD_INT 2
42703: NEG
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 0
42711: PUSH
42712: LD_INT 2
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 1
42722: PUSH
42723: LD_INT 1
42725: NEG
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: LD_INT 2
42733: PUSH
42734: LD_INT 0
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 2
42743: PUSH
42744: LD_INT 1
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 1
42753: PUSH
42754: LD_INT 2
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PUSH
42761: LD_INT 0
42763: PUSH
42764: LD_INT 2
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 1
42773: NEG
42774: PUSH
42775: LD_INT 1
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 2
42784: NEG
42785: PUSH
42786: LD_INT 0
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 2
42795: NEG
42796: PUSH
42797: LD_INT 1
42799: NEG
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PUSH
42805: LD_INT 1
42807: NEG
42808: PUSH
42809: LD_INT 3
42811: NEG
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 0
42819: PUSH
42820: LD_INT 3
42822: NEG
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 1
42830: PUSH
42831: LD_INT 2
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: LD_INT 1
42844: NEG
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: PUSH
42850: LD_INT 3
42852: PUSH
42853: LD_INT 0
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: LD_INT 3
42862: PUSH
42863: LD_INT 1
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 1
42872: PUSH
42873: LD_INT 3
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: LD_INT 3
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 1
42892: NEG
42893: PUSH
42894: LD_INT 2
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: LD_INT 1
42907: PUSH
42908: EMPTY
42909: LIST
42910: LIST
42911: PUSH
42912: LD_INT 3
42914: NEG
42915: PUSH
42916: LD_INT 0
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: PUSH
42923: LD_INT 3
42925: NEG
42926: PUSH
42927: LD_INT 1
42929: NEG
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: LIST
42939: LIST
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: LIST
42945: LIST
42946: LIST
42947: LIST
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: LIST
42953: LIST
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42966: LD_ADDR_VAR 0 47
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: LD_INT 0
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: LD_INT 1
42986: NEG
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: LD_INT 0
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_INT 1
43004: PUSH
43005: LD_INT 1
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: PUSH
43012: LD_INT 0
43014: PUSH
43015: LD_INT 1
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 1
43024: NEG
43025: PUSH
43026: LD_INT 0
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 1
43035: NEG
43036: PUSH
43037: LD_INT 1
43039: NEG
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 1
43047: NEG
43048: PUSH
43049: LD_INT 2
43051: NEG
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 0
43059: PUSH
43060: LD_INT 2
43062: NEG
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: LD_INT 1
43070: PUSH
43071: LD_INT 1
43073: NEG
43074: PUSH
43075: EMPTY
43076: LIST
43077: LIST
43078: PUSH
43079: LD_INT 2
43081: NEG
43082: PUSH
43083: LD_INT 1
43085: NEG
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 2
43093: NEG
43094: PUSH
43095: LD_INT 2
43097: NEG
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: LIST
43108: LIST
43109: LIST
43110: LIST
43111: LIST
43112: LIST
43113: LIST
43114: LIST
43115: LIST
43116: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43117: LD_ADDR_VAR 0 48
43121: PUSH
43122: LD_INT 0
43124: PUSH
43125: LD_INT 0
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 0
43134: PUSH
43135: LD_INT 1
43137: NEG
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 1
43145: PUSH
43146: LD_INT 0
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 1
43155: PUSH
43156: LD_INT 1
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 0
43165: PUSH
43166: LD_INT 1
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: LD_INT 1
43175: NEG
43176: PUSH
43177: LD_INT 0
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: LD_INT 1
43186: NEG
43187: PUSH
43188: LD_INT 1
43190: NEG
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 1
43198: NEG
43199: PUSH
43200: LD_INT 2
43202: NEG
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 0
43210: PUSH
43211: LD_INT 2
43213: NEG
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 1
43221: PUSH
43222: LD_INT 1
43224: NEG
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 2
43232: PUSH
43233: LD_INT 0
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: LD_INT 2
43242: PUSH
43243: LD_INT 1
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: LIST
43254: LIST
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43264: LD_ADDR_VAR 0 49
43268: PUSH
43269: LD_INT 0
43271: PUSH
43272: LD_INT 0
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 0
43281: PUSH
43282: LD_INT 1
43284: NEG
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 1
43292: PUSH
43293: LD_INT 0
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: LD_INT 1
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 0
43312: PUSH
43313: LD_INT 1
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 1
43322: NEG
43323: PUSH
43324: LD_INT 0
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 1
43333: NEG
43334: PUSH
43335: LD_INT 1
43337: NEG
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 1
43345: PUSH
43346: LD_INT 1
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: LD_INT 0
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: LD_INT 1
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 2
43376: PUSH
43377: LD_INT 2
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 1
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43408: LD_ADDR_VAR 0 50
43412: PUSH
43413: LD_INT 0
43415: PUSH
43416: LD_INT 0
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 0
43425: PUSH
43426: LD_INT 1
43428: NEG
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 1
43436: PUSH
43437: LD_INT 0
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: LD_INT 1
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 0
43456: PUSH
43457: LD_INT 1
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: LD_INT 0
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 1
43477: NEG
43478: PUSH
43479: LD_INT 1
43481: NEG
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 2
43489: PUSH
43490: LD_INT 1
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 2
43499: PUSH
43500: LD_INT 2
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 1
43509: PUSH
43510: LD_INT 2
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: LD_INT 0
43519: PUSH
43520: LD_INT 2
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 1
43529: NEG
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43552: LD_ADDR_VAR 0 51
43556: PUSH
43557: LD_INT 0
43559: PUSH
43560: LD_INT 0
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 0
43569: PUSH
43570: LD_INT 1
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 1
43580: PUSH
43581: LD_INT 0
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 1
43590: PUSH
43591: LD_INT 1
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: LD_INT 0
43600: PUSH
43601: LD_INT 1
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: PUSH
43608: LD_INT 1
43610: NEG
43611: PUSH
43612: LD_INT 0
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 1
43621: NEG
43622: PUSH
43623: LD_INT 1
43625: NEG
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: LD_INT 2
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 0
43643: PUSH
43644: LD_INT 2
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 1
43653: NEG
43654: PUSH
43655: LD_INT 1
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: LD_INT 2
43664: NEG
43665: PUSH
43666: LD_INT 0
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 2
43675: NEG
43676: PUSH
43677: LD_INT 1
43679: NEG
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43699: LD_ADDR_VAR 0 52
43703: PUSH
43704: LD_INT 0
43706: PUSH
43707: LD_INT 0
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 0
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 1
43727: PUSH
43728: LD_INT 0
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 1
43737: PUSH
43738: LD_INT 1
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 0
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 1
43757: NEG
43758: PUSH
43759: LD_INT 0
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 1
43768: NEG
43769: PUSH
43770: LD_INT 1
43772: NEG
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 1
43780: NEG
43781: PUSH
43782: LD_INT 2
43784: NEG
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 1
43792: NEG
43793: PUSH
43794: LD_INT 1
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 2
43803: NEG
43804: PUSH
43805: LD_INT 0
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 2
43814: NEG
43815: PUSH
43816: LD_INT 1
43818: NEG
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 2
43826: NEG
43827: PUSH
43828: LD_INT 2
43830: NEG
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43850: LD_ADDR_VAR 0 53
43854: PUSH
43855: LD_INT 0
43857: PUSH
43858: LD_INT 0
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 1
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 1
43878: PUSH
43879: LD_INT 0
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: LD_INT 1
43891: PUSH
43892: EMPTY
43893: LIST
43894: LIST
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: LD_INT 1
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 1
43908: NEG
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 1
43919: NEG
43920: PUSH
43921: LD_INT 1
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 1
43931: NEG
43932: PUSH
43933: LD_INT 2
43935: NEG
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 0
43943: PUSH
43944: LD_INT 2
43946: NEG
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: LD_INT 1
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 2
43965: PUSH
43966: LD_INT 0
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 2
43975: PUSH
43976: LD_INT 1
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 2
43985: PUSH
43986: LD_INT 2
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PUSH
43993: LD_INT 1
43995: PUSH
43996: LD_INT 2
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 0
44005: PUSH
44006: LD_INT 2
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 1
44015: NEG
44016: PUSH
44017: LD_INT 1
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 2
44026: NEG
44027: PUSH
44028: LD_INT 0
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 2
44037: NEG
44038: PUSH
44039: LD_INT 1
44041: NEG
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 2
44049: NEG
44050: PUSH
44051: LD_INT 2
44053: NEG
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44080: LD_ADDR_VAR 0 54
44084: PUSH
44085: LD_INT 0
44087: PUSH
44088: LD_INT 0
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 0
44097: PUSH
44098: LD_INT 1
44100: NEG
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 1
44108: PUSH
44109: LD_INT 0
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_INT 1
44118: PUSH
44119: LD_INT 1
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 0
44128: PUSH
44129: LD_INT 1
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 1
44138: NEG
44139: PUSH
44140: LD_INT 0
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: PUSH
44147: LD_INT 1
44149: NEG
44150: PUSH
44151: LD_INT 1
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 1
44161: NEG
44162: PUSH
44163: LD_INT 2
44165: NEG
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 0
44173: PUSH
44174: LD_INT 2
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 1
44184: PUSH
44185: LD_INT 1
44187: NEG
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 2
44195: PUSH
44196: LD_INT 0
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: PUSH
44206: LD_INT 1
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 2
44215: PUSH
44216: LD_INT 2
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 1
44225: PUSH
44226: LD_INT 2
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 0
44235: PUSH
44236: LD_INT 2
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 1
44245: NEG
44246: PUSH
44247: LD_INT 1
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 2
44256: NEG
44257: PUSH
44258: LD_INT 0
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 2
44267: NEG
44268: PUSH
44269: LD_INT 1
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 2
44279: NEG
44280: PUSH
44281: LD_INT 2
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: LIST
44309: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44310: LD_ADDR_VAR 0 55
44314: PUSH
44315: LD_INT 0
44317: PUSH
44318: LD_INT 0
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 0
44327: PUSH
44328: LD_INT 1
44330: NEG
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: PUSH
44336: LD_INT 1
44338: PUSH
44339: LD_INT 0
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: LD_INT 1
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 0
44358: PUSH
44359: LD_INT 1
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 1
44368: NEG
44369: PUSH
44370: LD_INT 0
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: LD_INT 1
44379: NEG
44380: PUSH
44381: LD_INT 1
44383: NEG
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 1
44391: NEG
44392: PUSH
44393: LD_INT 2
44395: NEG
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 0
44403: PUSH
44404: LD_INT 2
44406: NEG
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 1
44414: PUSH
44415: LD_INT 1
44417: NEG
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PUSH
44423: LD_INT 2
44425: PUSH
44426: LD_INT 0
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 2
44435: PUSH
44436: LD_INT 1
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 2
44445: PUSH
44446: LD_INT 2
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 1
44455: PUSH
44456: LD_INT 2
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 0
44465: PUSH
44466: LD_INT 2
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 1
44475: NEG
44476: PUSH
44477: LD_INT 1
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 2
44486: NEG
44487: PUSH
44488: LD_INT 0
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 2
44497: NEG
44498: PUSH
44499: LD_INT 1
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 2
44509: NEG
44510: PUSH
44511: LD_INT 2
44513: NEG
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44540: LD_ADDR_VAR 0 56
44544: PUSH
44545: LD_INT 0
44547: PUSH
44548: LD_INT 0
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: LD_INT 0
44557: PUSH
44558: LD_INT 1
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 1
44568: PUSH
44569: LD_INT 0
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 1
44578: PUSH
44579: LD_INT 1
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 0
44588: PUSH
44589: LD_INT 1
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 1
44598: NEG
44599: PUSH
44600: LD_INT 0
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: LD_INT 1
44609: NEG
44610: PUSH
44611: LD_INT 1
44613: NEG
44614: PUSH
44615: EMPTY
44616: LIST
44617: LIST
44618: PUSH
44619: LD_INT 1
44621: NEG
44622: PUSH
44623: LD_INT 2
44625: NEG
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: LD_INT 0
44633: PUSH
44634: LD_INT 2
44636: NEG
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: PUSH
44642: LD_INT 1
44644: PUSH
44645: LD_INT 1
44647: NEG
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: PUSH
44653: LD_INT 2
44655: PUSH
44656: LD_INT 0
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: PUSH
44663: LD_INT 2
44665: PUSH
44666: LD_INT 1
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 2
44675: PUSH
44676: LD_INT 2
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 1
44685: PUSH
44686: LD_INT 2
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: LD_INT 0
44695: PUSH
44696: LD_INT 2
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 1
44705: NEG
44706: PUSH
44707: LD_INT 1
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 2
44716: NEG
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 2
44727: NEG
44728: PUSH
44729: LD_INT 1
44731: NEG
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: LD_INT 2
44739: NEG
44740: PUSH
44741: LD_INT 2
44743: NEG
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: LIST
44758: LIST
44759: LIST
44760: LIST
44761: LIST
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44770: LD_ADDR_VAR 0 57
44774: PUSH
44775: LD_INT 0
44777: PUSH
44778: LD_INT 0
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: LD_INT 1
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 1
44798: PUSH
44799: LD_INT 0
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 1
44808: PUSH
44809: LD_INT 1
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: PUSH
44816: LD_INT 0
44818: PUSH
44819: LD_INT 1
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 1
44828: NEG
44829: PUSH
44830: LD_INT 0
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: PUSH
44837: LD_INT 1
44839: NEG
44840: PUSH
44841: LD_INT 1
44843: NEG
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 1
44851: NEG
44852: PUSH
44853: LD_INT 2
44855: NEG
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 0
44863: PUSH
44864: LD_INT 2
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 1
44874: PUSH
44875: LD_INT 1
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 2
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 2
44895: PUSH
44896: LD_INT 1
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 2
44905: PUSH
44906: LD_INT 2
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 1
44915: PUSH
44916: LD_INT 2
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 0
44925: PUSH
44926: LD_INT 2
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 1
44935: NEG
44936: PUSH
44937: LD_INT 1
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 2
44946: NEG
44947: PUSH
44948: LD_INT 0
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 2
44957: NEG
44958: PUSH
44959: LD_INT 1
44961: NEG
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: PUSH
44967: LD_INT 2
44969: NEG
44970: PUSH
44971: LD_INT 2
44973: NEG
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: LIST
44990: LIST
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45000: LD_ADDR_VAR 0 58
45004: PUSH
45005: LD_INT 0
45007: PUSH
45008: LD_INT 0
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 0
45017: PUSH
45018: LD_INT 1
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 1
45028: PUSH
45029: LD_INT 0
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 1
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 0
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 1
45058: NEG
45059: PUSH
45060: LD_INT 0
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 1
45069: NEG
45070: PUSH
45071: LD_INT 1
45073: NEG
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: PUSH
45079: LD_INT 1
45081: NEG
45082: PUSH
45083: LD_INT 2
45085: NEG
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 0
45093: PUSH
45094: LD_INT 2
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 1
45104: PUSH
45105: LD_INT 1
45107: NEG
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: LD_INT 0
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: PUSH
45123: LD_INT 2
45125: PUSH
45126: LD_INT 1
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 2
45135: PUSH
45136: LD_INT 2
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 1
45145: PUSH
45146: LD_INT 2
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 0
45155: PUSH
45156: LD_INT 2
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 1
45165: NEG
45166: PUSH
45167: LD_INT 1
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 2
45176: NEG
45177: PUSH
45178: LD_INT 0
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 2
45187: NEG
45188: PUSH
45189: LD_INT 1
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 2
45199: NEG
45200: PUSH
45201: LD_INT 2
45203: NEG
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45230: LD_ADDR_VAR 0 59
45234: PUSH
45235: LD_INT 0
45237: PUSH
45238: LD_INT 0
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PUSH
45245: LD_INT 0
45247: PUSH
45248: LD_INT 1
45250: NEG
45251: PUSH
45252: EMPTY
45253: LIST
45254: LIST
45255: PUSH
45256: LD_INT 1
45258: PUSH
45259: LD_INT 0
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: PUSH
45266: LD_INT 1
45268: PUSH
45269: LD_INT 1
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 0
45278: PUSH
45279: LD_INT 1
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 1
45288: NEG
45289: PUSH
45290: LD_INT 0
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 1
45299: NEG
45300: PUSH
45301: LD_INT 1
45303: NEG
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45318: LD_ADDR_VAR 0 60
45322: PUSH
45323: LD_INT 0
45325: PUSH
45326: LD_INT 0
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: PUSH
45333: LD_INT 0
45335: PUSH
45336: LD_INT 1
45338: NEG
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 1
45346: PUSH
45347: LD_INT 0
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 1
45356: PUSH
45357: LD_INT 1
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 0
45366: PUSH
45367: LD_INT 1
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 1
45376: NEG
45377: PUSH
45378: LD_INT 0
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 1
45387: NEG
45388: PUSH
45389: LD_INT 1
45391: NEG
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45406: LD_ADDR_VAR 0 61
45410: PUSH
45411: LD_INT 0
45413: PUSH
45414: LD_INT 0
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 0
45423: PUSH
45424: LD_INT 1
45426: NEG
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 1
45434: PUSH
45435: LD_INT 0
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: LD_INT 1
45444: PUSH
45445: LD_INT 1
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 0
45454: PUSH
45455: LD_INT 1
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 1
45464: NEG
45465: PUSH
45466: LD_INT 0
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 1
45475: NEG
45476: PUSH
45477: LD_INT 1
45479: NEG
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45494: LD_ADDR_VAR 0 62
45498: PUSH
45499: LD_INT 0
45501: PUSH
45502: LD_INT 0
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: LD_INT 1
45514: NEG
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: PUSH
45520: LD_INT 1
45522: PUSH
45523: LD_INT 0
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 1
45532: PUSH
45533: LD_INT 1
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 0
45542: PUSH
45543: LD_INT 1
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 1
45552: NEG
45553: PUSH
45554: LD_INT 0
45556: PUSH
45557: EMPTY
45558: LIST
45559: LIST
45560: PUSH
45561: LD_INT 1
45563: NEG
45564: PUSH
45565: LD_INT 1
45567: NEG
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: PUSH
45573: EMPTY
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45582: LD_ADDR_VAR 0 63
45586: PUSH
45587: LD_INT 0
45589: PUSH
45590: LD_INT 0
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 0
45599: PUSH
45600: LD_INT 1
45602: NEG
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: LD_INT 1
45610: PUSH
45611: LD_INT 0
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: PUSH
45618: LD_INT 1
45620: PUSH
45621: LD_INT 1
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 0
45630: PUSH
45631: LD_INT 1
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: PUSH
45638: LD_INT 1
45640: NEG
45641: PUSH
45642: LD_INT 0
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 1
45651: NEG
45652: PUSH
45653: LD_INT 1
45655: NEG
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45670: LD_ADDR_VAR 0 64
45674: PUSH
45675: LD_INT 0
45677: PUSH
45678: LD_INT 0
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 0
45687: PUSH
45688: LD_INT 1
45690: NEG
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 1
45698: PUSH
45699: LD_INT 0
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 1
45708: PUSH
45709: LD_INT 1
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 0
45718: PUSH
45719: LD_INT 1
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 1
45728: NEG
45729: PUSH
45730: LD_INT 0
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 1
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: ST_TO_ADDR
// end ; 1 :
45758: GO 51655
45760: LD_INT 1
45762: DOUBLE
45763: EQUAL
45764: IFTRUE 45768
45766: GO 48391
45768: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45769: LD_ADDR_VAR 0 11
45773: PUSH
45774: LD_INT 1
45776: NEG
45777: PUSH
45778: LD_INT 3
45780: NEG
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 0
45788: PUSH
45789: LD_INT 3
45791: NEG
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 1
45799: PUSH
45800: LD_INT 2
45802: NEG
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: LIST
45812: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45813: LD_ADDR_VAR 0 12
45817: PUSH
45818: LD_INT 2
45820: PUSH
45821: LD_INT 1
45823: NEG
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: PUSH
45829: LD_INT 3
45831: PUSH
45832: LD_INT 0
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 3
45841: PUSH
45842: LD_INT 1
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: LIST
45853: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45854: LD_ADDR_VAR 0 13
45858: PUSH
45859: LD_INT 3
45861: PUSH
45862: LD_INT 2
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 3
45871: PUSH
45872: LD_INT 3
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 2
45881: PUSH
45882: LD_INT 3
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: LIST
45893: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45894: LD_ADDR_VAR 0 14
45898: PUSH
45899: LD_INT 1
45901: PUSH
45902: LD_INT 3
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 0
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 1
45921: NEG
45922: PUSH
45923: LD_INT 2
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: LIST
45934: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45935: LD_ADDR_VAR 0 15
45939: PUSH
45940: LD_INT 2
45942: NEG
45943: PUSH
45944: LD_INT 1
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 3
45953: NEG
45954: PUSH
45955: LD_INT 0
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: LD_INT 3
45964: NEG
45965: PUSH
45966: LD_INT 1
45968: NEG
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: LIST
45978: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45979: LD_ADDR_VAR 0 16
45983: PUSH
45984: LD_INT 2
45986: NEG
45987: PUSH
45988: LD_INT 3
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 3
45998: NEG
45999: PUSH
46000: LD_INT 2
46002: NEG
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 3
46010: NEG
46011: PUSH
46012: LD_INT 3
46014: NEG
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: LIST
46024: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46025: LD_ADDR_VAR 0 17
46029: PUSH
46030: LD_INT 1
46032: NEG
46033: PUSH
46034: LD_INT 3
46036: NEG
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 0
46044: PUSH
46045: LD_INT 3
46047: NEG
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: PUSH
46053: LD_INT 1
46055: PUSH
46056: LD_INT 2
46058: NEG
46059: PUSH
46060: EMPTY
46061: LIST
46062: LIST
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: LIST
46068: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46069: LD_ADDR_VAR 0 18
46073: PUSH
46074: LD_INT 2
46076: PUSH
46077: LD_INT 1
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 3
46087: PUSH
46088: LD_INT 0
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 3
46097: PUSH
46098: LD_INT 1
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: EMPTY
46106: LIST
46107: LIST
46108: LIST
46109: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46110: LD_ADDR_VAR 0 19
46114: PUSH
46115: LD_INT 3
46117: PUSH
46118: LD_INT 2
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 3
46127: PUSH
46128: LD_INT 3
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: LD_INT 3
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: LIST
46149: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46150: LD_ADDR_VAR 0 20
46154: PUSH
46155: LD_INT 1
46157: PUSH
46158: LD_INT 3
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: PUSH
46165: LD_INT 0
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: PUSH
46175: LD_INT 1
46177: NEG
46178: PUSH
46179: LD_INT 2
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: LIST
46190: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46191: LD_ADDR_VAR 0 21
46195: PUSH
46196: LD_INT 2
46198: NEG
46199: PUSH
46200: LD_INT 1
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 3
46209: NEG
46210: PUSH
46211: LD_INT 0
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 3
46220: NEG
46221: PUSH
46222: LD_INT 1
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: LIST
46234: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46235: LD_ADDR_VAR 0 22
46239: PUSH
46240: LD_INT 2
46242: NEG
46243: PUSH
46244: LD_INT 3
46246: NEG
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: PUSH
46252: LD_INT 3
46254: NEG
46255: PUSH
46256: LD_INT 2
46258: NEG
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 3
46266: NEG
46267: PUSH
46268: LD_INT 3
46270: NEG
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: LIST
46280: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46281: LD_ADDR_VAR 0 23
46285: PUSH
46286: LD_INT 0
46288: PUSH
46289: LD_INT 3
46291: NEG
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PUSH
46297: LD_INT 1
46299: NEG
46300: PUSH
46301: LD_INT 4
46303: NEG
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: LD_INT 1
46311: PUSH
46312: LD_INT 3
46314: NEG
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: LIST
46324: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46325: LD_ADDR_VAR 0 24
46329: PUSH
46330: LD_INT 3
46332: PUSH
46333: LD_INT 0
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: LD_INT 1
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 4
46353: PUSH
46354: LD_INT 1
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: LIST
46365: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46366: LD_ADDR_VAR 0 25
46370: PUSH
46371: LD_INT 3
46373: PUSH
46374: LD_INT 3
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 4
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 3
46393: PUSH
46394: LD_INT 4
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: LIST
46405: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46406: LD_ADDR_VAR 0 26
46410: PUSH
46411: LD_INT 0
46413: PUSH
46414: LD_INT 3
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 1
46423: PUSH
46424: LD_INT 4
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 1
46433: NEG
46434: PUSH
46435: LD_INT 3
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: LIST
46446: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46447: LD_ADDR_VAR 0 27
46451: PUSH
46452: LD_INT 3
46454: NEG
46455: PUSH
46456: LD_INT 0
46458: PUSH
46459: EMPTY
46460: LIST
46461: LIST
46462: PUSH
46463: LD_INT 3
46465: NEG
46466: PUSH
46467: LD_INT 1
46469: PUSH
46470: EMPTY
46471: LIST
46472: LIST
46473: PUSH
46474: LD_INT 4
46476: NEG
46477: PUSH
46478: LD_INT 1
46480: NEG
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: LIST
46490: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46491: LD_ADDR_VAR 0 28
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 3
46502: NEG
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 3
46510: NEG
46511: PUSH
46512: LD_INT 4
46514: NEG
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 4
46522: NEG
46523: PUSH
46524: LD_INT 3
46526: NEG
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46537: LD_ADDR_VAR 0 29
46541: PUSH
46542: LD_INT 1
46544: NEG
46545: PUSH
46546: LD_INT 3
46548: NEG
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PUSH
46554: LD_INT 0
46556: PUSH
46557: LD_INT 3
46559: NEG
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: PUSH
46565: LD_INT 1
46567: PUSH
46568: LD_INT 2
46570: NEG
46571: PUSH
46572: EMPTY
46573: LIST
46574: LIST
46575: PUSH
46576: LD_INT 1
46578: NEG
46579: PUSH
46580: LD_INT 4
46582: NEG
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: PUSH
46588: LD_INT 0
46590: PUSH
46591: LD_INT 4
46593: NEG
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 1
46601: PUSH
46602: LD_INT 3
46604: NEG
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: PUSH
46610: LD_INT 1
46612: NEG
46613: PUSH
46614: LD_INT 5
46616: NEG
46617: PUSH
46618: EMPTY
46619: LIST
46620: LIST
46621: PUSH
46622: LD_INT 0
46624: PUSH
46625: LD_INT 5
46627: NEG
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 1
46635: PUSH
46636: LD_INT 4
46638: NEG
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 1
46646: NEG
46647: PUSH
46648: LD_INT 6
46650: NEG
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 0
46658: PUSH
46659: LD_INT 6
46661: NEG
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: LD_INT 1
46669: PUSH
46670: LD_INT 5
46672: NEG
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: EMPTY
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46692: LD_ADDR_VAR 0 30
46696: PUSH
46697: LD_INT 2
46699: PUSH
46700: LD_INT 1
46702: NEG
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 3
46710: PUSH
46711: LD_INT 0
46713: PUSH
46714: EMPTY
46715: LIST
46716: LIST
46717: PUSH
46718: LD_INT 3
46720: PUSH
46721: LD_INT 1
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: LD_INT 3
46730: PUSH
46731: LD_INT 1
46733: NEG
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PUSH
46739: LD_INT 4
46741: PUSH
46742: LD_INT 0
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: LD_INT 4
46751: PUSH
46752: LD_INT 1
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: PUSH
46759: LD_INT 4
46761: PUSH
46762: LD_INT 1
46764: NEG
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 5
46772: PUSH
46773: LD_INT 0
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 5
46782: PUSH
46783: LD_INT 1
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: LD_INT 5
46792: PUSH
46793: LD_INT 1
46795: NEG
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: PUSH
46801: LD_INT 6
46803: PUSH
46804: LD_INT 0
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 6
46813: PUSH
46814: LD_INT 1
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: EMPTY
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46835: LD_ADDR_VAR 0 31
46839: PUSH
46840: LD_INT 3
46842: PUSH
46843: LD_INT 2
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: LD_INT 3
46852: PUSH
46853: LD_INT 3
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: PUSH
46860: LD_INT 2
46862: PUSH
46863: LD_INT 3
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: PUSH
46870: LD_INT 4
46872: PUSH
46873: LD_INT 3
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 4
46882: PUSH
46883: LD_INT 4
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PUSH
46890: LD_INT 3
46892: PUSH
46893: LD_INT 4
46895: PUSH
46896: EMPTY
46897: LIST
46898: LIST
46899: PUSH
46900: LD_INT 5
46902: PUSH
46903: LD_INT 4
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: PUSH
46910: LD_INT 5
46912: PUSH
46913: LD_INT 5
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: PUSH
46920: LD_INT 4
46922: PUSH
46923: LD_INT 5
46925: PUSH
46926: EMPTY
46927: LIST
46928: LIST
46929: PUSH
46930: LD_INT 6
46932: PUSH
46933: LD_INT 5
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: PUSH
46940: LD_INT 6
46942: PUSH
46943: LD_INT 6
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_INT 5
46952: PUSH
46953: LD_INT 6
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46974: LD_ADDR_VAR 0 32
46978: PUSH
46979: LD_INT 1
46981: PUSH
46982: LD_INT 3
46984: PUSH
46985: EMPTY
46986: LIST
46987: LIST
46988: PUSH
46989: LD_INT 0
46991: PUSH
46992: LD_INT 3
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 1
47001: NEG
47002: PUSH
47003: LD_INT 2
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 1
47012: PUSH
47013: LD_INT 4
47015: PUSH
47016: EMPTY
47017: LIST
47018: LIST
47019: PUSH
47020: LD_INT 0
47022: PUSH
47023: LD_INT 4
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: PUSH
47030: LD_INT 1
47032: NEG
47033: PUSH
47034: LD_INT 3
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: LD_INT 1
47043: PUSH
47044: LD_INT 5
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 0
47053: PUSH
47054: LD_INT 5
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: LD_INT 1
47063: NEG
47064: PUSH
47065: LD_INT 4
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: PUSH
47072: LD_INT 1
47074: PUSH
47075: LD_INT 6
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: PUSH
47082: LD_INT 0
47084: PUSH
47085: LD_INT 6
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: PUSH
47092: LD_INT 1
47094: NEG
47095: PUSH
47096: LD_INT 5
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
47117: LD_ADDR_VAR 0 33
47121: PUSH
47122: LD_INT 2
47124: NEG
47125: PUSH
47126: LD_INT 1
47128: PUSH
47129: EMPTY
47130: LIST
47131: LIST
47132: PUSH
47133: LD_INT 3
47135: NEG
47136: PUSH
47137: LD_INT 0
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PUSH
47144: LD_INT 3
47146: NEG
47147: PUSH
47148: LD_INT 1
47150: NEG
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 3
47158: NEG
47159: PUSH
47160: LD_INT 1
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 4
47169: NEG
47170: PUSH
47171: LD_INT 0
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 4
47180: NEG
47181: PUSH
47182: LD_INT 1
47184: NEG
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PUSH
47190: LD_INT 4
47192: NEG
47193: PUSH
47194: LD_INT 1
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: PUSH
47201: LD_INT 5
47203: NEG
47204: PUSH
47205: LD_INT 0
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 5
47214: NEG
47215: PUSH
47216: LD_INT 1
47218: NEG
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: PUSH
47224: LD_INT 5
47226: NEG
47227: PUSH
47228: LD_INT 1
47230: PUSH
47231: EMPTY
47232: LIST
47233: LIST
47234: PUSH
47235: LD_INT 6
47237: NEG
47238: PUSH
47239: LD_INT 0
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PUSH
47246: LD_INT 6
47248: NEG
47249: PUSH
47250: LD_INT 1
47252: NEG
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47272: LD_ADDR_VAR 0 34
47276: PUSH
47277: LD_INT 2
47279: NEG
47280: PUSH
47281: LD_INT 3
47283: NEG
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: LD_INT 3
47291: NEG
47292: PUSH
47293: LD_INT 2
47295: NEG
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: PUSH
47301: LD_INT 3
47303: NEG
47304: PUSH
47305: LD_INT 3
47307: NEG
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: PUSH
47313: LD_INT 3
47315: NEG
47316: PUSH
47317: LD_INT 4
47319: NEG
47320: PUSH
47321: EMPTY
47322: LIST
47323: LIST
47324: PUSH
47325: LD_INT 4
47327: NEG
47328: PUSH
47329: LD_INT 3
47331: NEG
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 4
47339: NEG
47340: PUSH
47341: LD_INT 4
47343: NEG
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: PUSH
47349: LD_INT 4
47351: NEG
47352: PUSH
47353: LD_INT 5
47355: NEG
47356: PUSH
47357: EMPTY
47358: LIST
47359: LIST
47360: PUSH
47361: LD_INT 5
47363: NEG
47364: PUSH
47365: LD_INT 4
47367: NEG
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: PUSH
47373: LD_INT 5
47375: NEG
47376: PUSH
47377: LD_INT 5
47379: NEG
47380: PUSH
47381: EMPTY
47382: LIST
47383: LIST
47384: PUSH
47385: LD_INT 5
47387: NEG
47388: PUSH
47389: LD_INT 6
47391: NEG
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PUSH
47397: LD_INT 6
47399: NEG
47400: PUSH
47401: LD_INT 5
47403: NEG
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: LD_INT 6
47411: NEG
47412: PUSH
47413: LD_INT 6
47415: NEG
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: EMPTY
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47435: LD_ADDR_VAR 0 41
47439: PUSH
47440: LD_INT 0
47442: PUSH
47443: LD_INT 2
47445: NEG
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: PUSH
47451: LD_INT 1
47453: NEG
47454: PUSH
47455: LD_INT 3
47457: NEG
47458: PUSH
47459: EMPTY
47460: LIST
47461: LIST
47462: PUSH
47463: LD_INT 1
47465: PUSH
47466: LD_INT 2
47468: NEG
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: LIST
47478: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47479: LD_ADDR_VAR 0 42
47483: PUSH
47484: LD_INT 2
47486: PUSH
47487: LD_INT 0
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: PUSH
47494: LD_INT 2
47496: PUSH
47497: LD_INT 1
47499: NEG
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: PUSH
47505: LD_INT 3
47507: PUSH
47508: LD_INT 1
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PUSH
47515: EMPTY
47516: LIST
47517: LIST
47518: LIST
47519: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47520: LD_ADDR_VAR 0 43
47524: PUSH
47525: LD_INT 2
47527: PUSH
47528: LD_INT 2
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 3
47537: PUSH
47538: LD_INT 2
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: LD_INT 2
47547: PUSH
47548: LD_INT 3
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: EMPTY
47556: LIST
47557: LIST
47558: LIST
47559: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47560: LD_ADDR_VAR 0 44
47564: PUSH
47565: LD_INT 0
47567: PUSH
47568: LD_INT 2
47570: PUSH
47571: EMPTY
47572: LIST
47573: LIST
47574: PUSH
47575: LD_INT 1
47577: PUSH
47578: LD_INT 3
47580: PUSH
47581: EMPTY
47582: LIST
47583: LIST
47584: PUSH
47585: LD_INT 1
47587: NEG
47588: PUSH
47589: LD_INT 2
47591: PUSH
47592: EMPTY
47593: LIST
47594: LIST
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: LIST
47600: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47601: LD_ADDR_VAR 0 45
47605: PUSH
47606: LD_INT 2
47608: NEG
47609: PUSH
47610: LD_INT 0
47612: PUSH
47613: EMPTY
47614: LIST
47615: LIST
47616: PUSH
47617: LD_INT 2
47619: NEG
47620: PUSH
47621: LD_INT 1
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: PUSH
47628: LD_INT 3
47630: NEG
47631: PUSH
47632: LD_INT 1
47634: NEG
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PUSH
47640: EMPTY
47641: LIST
47642: LIST
47643: LIST
47644: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47645: LD_ADDR_VAR 0 46
47649: PUSH
47650: LD_INT 2
47652: NEG
47653: PUSH
47654: LD_INT 2
47656: NEG
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: PUSH
47662: LD_INT 2
47664: NEG
47665: PUSH
47666: LD_INT 3
47668: NEG
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: PUSH
47674: LD_INT 3
47676: NEG
47677: PUSH
47678: LD_INT 2
47680: NEG
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: LIST
47690: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47691: LD_ADDR_VAR 0 47
47695: PUSH
47696: LD_INT 2
47698: NEG
47699: PUSH
47700: LD_INT 3
47702: NEG
47703: PUSH
47704: EMPTY
47705: LIST
47706: LIST
47707: PUSH
47708: LD_INT 1
47710: NEG
47711: PUSH
47712: LD_INT 3
47714: NEG
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47724: LD_ADDR_VAR 0 48
47728: PUSH
47729: LD_INT 1
47731: PUSH
47732: LD_INT 2
47734: NEG
47735: PUSH
47736: EMPTY
47737: LIST
47738: LIST
47739: PUSH
47740: LD_INT 2
47742: PUSH
47743: LD_INT 1
47745: NEG
47746: PUSH
47747: EMPTY
47748: LIST
47749: LIST
47750: PUSH
47751: EMPTY
47752: LIST
47753: LIST
47754: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47755: LD_ADDR_VAR 0 49
47759: PUSH
47760: LD_INT 3
47762: PUSH
47763: LD_INT 1
47765: PUSH
47766: EMPTY
47767: LIST
47768: LIST
47769: PUSH
47770: LD_INT 3
47772: PUSH
47773: LD_INT 2
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47784: LD_ADDR_VAR 0 50
47788: PUSH
47789: LD_INT 2
47791: PUSH
47792: LD_INT 3
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: PUSH
47799: LD_INT 1
47801: PUSH
47802: LD_INT 3
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47813: LD_ADDR_VAR 0 51
47817: PUSH
47818: LD_INT 1
47820: NEG
47821: PUSH
47822: LD_INT 2
47824: PUSH
47825: EMPTY
47826: LIST
47827: LIST
47828: PUSH
47829: LD_INT 2
47831: NEG
47832: PUSH
47833: LD_INT 1
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47844: LD_ADDR_VAR 0 52
47848: PUSH
47849: LD_INT 3
47851: NEG
47852: PUSH
47853: LD_INT 1
47855: NEG
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: PUSH
47861: LD_INT 3
47863: NEG
47864: PUSH
47865: LD_INT 2
47867: NEG
47868: PUSH
47869: EMPTY
47870: LIST
47871: LIST
47872: PUSH
47873: EMPTY
47874: LIST
47875: LIST
47876: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47877: LD_ADDR_VAR 0 53
47881: PUSH
47882: LD_INT 1
47884: NEG
47885: PUSH
47886: LD_INT 3
47888: NEG
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PUSH
47894: LD_INT 0
47896: PUSH
47897: LD_INT 3
47899: NEG
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: LD_INT 1
47907: PUSH
47908: LD_INT 2
47910: NEG
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: LIST
47920: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47921: LD_ADDR_VAR 0 54
47925: PUSH
47926: LD_INT 2
47928: PUSH
47929: LD_INT 1
47931: NEG
47932: PUSH
47933: EMPTY
47934: LIST
47935: LIST
47936: PUSH
47937: LD_INT 3
47939: PUSH
47940: LD_INT 0
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 3
47949: PUSH
47950: LD_INT 1
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: LIST
47961: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47962: LD_ADDR_VAR 0 55
47966: PUSH
47967: LD_INT 3
47969: PUSH
47970: LD_INT 2
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 3
47979: PUSH
47980: LD_INT 3
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 2
47989: PUSH
47990: LD_INT 3
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
48002: LD_ADDR_VAR 0 56
48006: PUSH
48007: LD_INT 1
48009: PUSH
48010: LD_INT 3
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 0
48019: PUSH
48020: LD_INT 3
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 1
48029: NEG
48030: PUSH
48031: LD_INT 2
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: LIST
48042: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
48043: LD_ADDR_VAR 0 57
48047: PUSH
48048: LD_INT 2
48050: NEG
48051: PUSH
48052: LD_INT 1
48054: PUSH
48055: EMPTY
48056: LIST
48057: LIST
48058: PUSH
48059: LD_INT 3
48061: NEG
48062: PUSH
48063: LD_INT 0
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: PUSH
48070: LD_INT 3
48072: NEG
48073: PUSH
48074: LD_INT 1
48076: NEG
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: LIST
48086: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
48087: LD_ADDR_VAR 0 58
48091: PUSH
48092: LD_INT 2
48094: NEG
48095: PUSH
48096: LD_INT 3
48098: NEG
48099: PUSH
48100: EMPTY
48101: LIST
48102: LIST
48103: PUSH
48104: LD_INT 3
48106: NEG
48107: PUSH
48108: LD_INT 2
48110: NEG
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: PUSH
48116: LD_INT 3
48118: NEG
48119: PUSH
48120: LD_INT 3
48122: NEG
48123: PUSH
48124: EMPTY
48125: LIST
48126: LIST
48127: PUSH
48128: EMPTY
48129: LIST
48130: LIST
48131: LIST
48132: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
48133: LD_ADDR_VAR 0 59
48137: PUSH
48138: LD_INT 1
48140: NEG
48141: PUSH
48142: LD_INT 2
48144: NEG
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PUSH
48150: LD_INT 0
48152: PUSH
48153: LD_INT 2
48155: NEG
48156: PUSH
48157: EMPTY
48158: LIST
48159: LIST
48160: PUSH
48161: LD_INT 1
48163: PUSH
48164: LD_INT 1
48166: NEG
48167: PUSH
48168: EMPTY
48169: LIST
48170: LIST
48171: PUSH
48172: EMPTY
48173: LIST
48174: LIST
48175: LIST
48176: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48177: LD_ADDR_VAR 0 60
48181: PUSH
48182: LD_INT 1
48184: PUSH
48185: LD_INT 1
48187: NEG
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 2
48195: PUSH
48196: LD_INT 0
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 2
48205: PUSH
48206: LD_INT 1
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: LIST
48217: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48218: LD_ADDR_VAR 0 61
48222: PUSH
48223: LD_INT 2
48225: PUSH
48226: LD_INT 1
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: LD_INT 2
48235: PUSH
48236: LD_INT 2
48238: PUSH
48239: EMPTY
48240: LIST
48241: LIST
48242: PUSH
48243: LD_INT 1
48245: PUSH
48246: LD_INT 2
48248: PUSH
48249: EMPTY
48250: LIST
48251: LIST
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: LIST
48257: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48258: LD_ADDR_VAR 0 62
48262: PUSH
48263: LD_INT 1
48265: PUSH
48266: LD_INT 2
48268: PUSH
48269: EMPTY
48270: LIST
48271: LIST
48272: PUSH
48273: LD_INT 0
48275: PUSH
48276: LD_INT 2
48278: PUSH
48279: EMPTY
48280: LIST
48281: LIST
48282: PUSH
48283: LD_INT 1
48285: NEG
48286: PUSH
48287: LD_INT 1
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: LIST
48298: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48299: LD_ADDR_VAR 0 63
48303: PUSH
48304: LD_INT 1
48306: NEG
48307: PUSH
48308: LD_INT 1
48310: PUSH
48311: EMPTY
48312: LIST
48313: LIST
48314: PUSH
48315: LD_INT 2
48317: NEG
48318: PUSH
48319: LD_INT 0
48321: PUSH
48322: EMPTY
48323: LIST
48324: LIST
48325: PUSH
48326: LD_INT 2
48328: NEG
48329: PUSH
48330: LD_INT 1
48332: NEG
48333: PUSH
48334: EMPTY
48335: LIST
48336: LIST
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: LIST
48342: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48343: LD_ADDR_VAR 0 64
48347: PUSH
48348: LD_INT 1
48350: NEG
48351: PUSH
48352: LD_INT 2
48354: NEG
48355: PUSH
48356: EMPTY
48357: LIST
48358: LIST
48359: PUSH
48360: LD_INT 2
48362: NEG
48363: PUSH
48364: LD_INT 1
48366: NEG
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: PUSH
48372: LD_INT 2
48374: NEG
48375: PUSH
48376: LD_INT 2
48378: NEG
48379: PUSH
48380: EMPTY
48381: LIST
48382: LIST
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: LIST
48388: ST_TO_ADDR
// end ; 2 :
48389: GO 51655
48391: LD_INT 2
48393: DOUBLE
48394: EQUAL
48395: IFTRUE 48399
48397: GO 51654
48399: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48400: LD_ADDR_VAR 0 29
48404: PUSH
48405: LD_INT 4
48407: PUSH
48408: LD_INT 0
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 4
48417: PUSH
48418: LD_INT 1
48420: NEG
48421: PUSH
48422: EMPTY
48423: LIST
48424: LIST
48425: PUSH
48426: LD_INT 5
48428: PUSH
48429: LD_INT 0
48431: PUSH
48432: EMPTY
48433: LIST
48434: LIST
48435: PUSH
48436: LD_INT 5
48438: PUSH
48439: LD_INT 1
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PUSH
48446: LD_INT 4
48448: PUSH
48449: LD_INT 1
48451: PUSH
48452: EMPTY
48453: LIST
48454: LIST
48455: PUSH
48456: LD_INT 3
48458: PUSH
48459: LD_INT 0
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: PUSH
48466: LD_INT 3
48468: PUSH
48469: LD_INT 1
48471: NEG
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: PUSH
48477: LD_INT 3
48479: PUSH
48480: LD_INT 2
48482: NEG
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: PUSH
48488: LD_INT 5
48490: PUSH
48491: LD_INT 2
48493: PUSH
48494: EMPTY
48495: LIST
48496: LIST
48497: PUSH
48498: LD_INT 3
48500: PUSH
48501: LD_INT 3
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 3
48510: PUSH
48511: LD_INT 2
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PUSH
48518: LD_INT 4
48520: PUSH
48521: LD_INT 3
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: PUSH
48528: LD_INT 4
48530: PUSH
48531: LD_INT 4
48533: PUSH
48534: EMPTY
48535: LIST
48536: LIST
48537: PUSH
48538: LD_INT 3
48540: PUSH
48541: LD_INT 4
48543: PUSH
48544: EMPTY
48545: LIST
48546: LIST
48547: PUSH
48548: LD_INT 2
48550: PUSH
48551: LD_INT 3
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PUSH
48558: LD_INT 2
48560: PUSH
48561: LD_INT 2
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 4
48570: PUSH
48571: LD_INT 2
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 2
48580: PUSH
48581: LD_INT 4
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: LD_INT 0
48590: PUSH
48591: LD_INT 4
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 0
48600: PUSH
48601: LD_INT 3
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: PUSH
48608: LD_INT 1
48610: PUSH
48611: LD_INT 4
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: PUSH
48618: LD_INT 1
48620: PUSH
48621: LD_INT 5
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: PUSH
48628: LD_INT 0
48630: PUSH
48631: LD_INT 5
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: PUSH
48638: LD_INT 1
48640: NEG
48641: PUSH
48642: LD_INT 4
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: PUSH
48649: LD_INT 1
48651: NEG
48652: PUSH
48653: LD_INT 3
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: PUSH
48660: LD_INT 2
48662: PUSH
48663: LD_INT 5
48665: PUSH
48666: EMPTY
48667: LIST
48668: LIST
48669: PUSH
48670: LD_INT 2
48672: NEG
48673: PUSH
48674: LD_INT 3
48676: PUSH
48677: EMPTY
48678: LIST
48679: LIST
48680: PUSH
48681: LD_INT 3
48683: NEG
48684: PUSH
48685: LD_INT 0
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 3
48694: NEG
48695: PUSH
48696: LD_INT 1
48698: NEG
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PUSH
48704: LD_INT 2
48706: NEG
48707: PUSH
48708: LD_INT 0
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 2
48717: NEG
48718: PUSH
48719: LD_INT 1
48721: PUSH
48722: EMPTY
48723: LIST
48724: LIST
48725: PUSH
48726: LD_INT 3
48728: NEG
48729: PUSH
48730: LD_INT 1
48732: PUSH
48733: EMPTY
48734: LIST
48735: LIST
48736: PUSH
48737: LD_INT 4
48739: NEG
48740: PUSH
48741: LD_INT 0
48743: PUSH
48744: EMPTY
48745: LIST
48746: LIST
48747: PUSH
48748: LD_INT 4
48750: NEG
48751: PUSH
48752: LD_INT 1
48754: NEG
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: PUSH
48760: LD_INT 4
48762: NEG
48763: PUSH
48764: LD_INT 2
48766: NEG
48767: PUSH
48768: EMPTY
48769: LIST
48770: LIST
48771: PUSH
48772: LD_INT 2
48774: NEG
48775: PUSH
48776: LD_INT 2
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: PUSH
48783: LD_INT 4
48785: NEG
48786: PUSH
48787: LD_INT 4
48789: NEG
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PUSH
48795: LD_INT 4
48797: NEG
48798: PUSH
48799: LD_INT 5
48801: NEG
48802: PUSH
48803: EMPTY
48804: LIST
48805: LIST
48806: PUSH
48807: LD_INT 3
48809: NEG
48810: PUSH
48811: LD_INT 4
48813: NEG
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: PUSH
48819: LD_INT 3
48821: NEG
48822: PUSH
48823: LD_INT 3
48825: NEG
48826: PUSH
48827: EMPTY
48828: LIST
48829: LIST
48830: PUSH
48831: LD_INT 4
48833: NEG
48834: PUSH
48835: LD_INT 3
48837: NEG
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: PUSH
48843: LD_INT 5
48845: NEG
48846: PUSH
48847: LD_INT 4
48849: NEG
48850: PUSH
48851: EMPTY
48852: LIST
48853: LIST
48854: PUSH
48855: LD_INT 5
48857: NEG
48858: PUSH
48859: LD_INT 5
48861: NEG
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: PUSH
48867: LD_INT 3
48869: NEG
48870: PUSH
48871: LD_INT 5
48873: NEG
48874: PUSH
48875: EMPTY
48876: LIST
48877: LIST
48878: PUSH
48879: LD_INT 5
48881: NEG
48882: PUSH
48883: LD_INT 3
48885: NEG
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PUSH
48891: EMPTY
48892: LIST
48893: LIST
48894: LIST
48895: LIST
48896: LIST
48897: LIST
48898: LIST
48899: LIST
48900: LIST
48901: LIST
48902: LIST
48903: LIST
48904: LIST
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48938: LD_ADDR_VAR 0 30
48942: PUSH
48943: LD_INT 4
48945: PUSH
48946: LD_INT 4
48948: PUSH
48949: EMPTY
48950: LIST
48951: LIST
48952: PUSH
48953: LD_INT 4
48955: PUSH
48956: LD_INT 3
48958: PUSH
48959: EMPTY
48960: LIST
48961: LIST
48962: PUSH
48963: LD_INT 5
48965: PUSH
48966: LD_INT 4
48968: PUSH
48969: EMPTY
48970: LIST
48971: LIST
48972: PUSH
48973: LD_INT 5
48975: PUSH
48976: LD_INT 5
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: PUSH
48983: LD_INT 4
48985: PUSH
48986: LD_INT 5
48988: PUSH
48989: EMPTY
48990: LIST
48991: LIST
48992: PUSH
48993: LD_INT 3
48995: PUSH
48996: LD_INT 4
48998: PUSH
48999: EMPTY
49000: LIST
49001: LIST
49002: PUSH
49003: LD_INT 3
49005: PUSH
49006: LD_INT 3
49008: PUSH
49009: EMPTY
49010: LIST
49011: LIST
49012: PUSH
49013: LD_INT 5
49015: PUSH
49016: LD_INT 3
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: PUSH
49023: LD_INT 3
49025: PUSH
49026: LD_INT 5
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PUSH
49033: LD_INT 0
49035: PUSH
49036: LD_INT 3
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 0
49045: PUSH
49046: LD_INT 2
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PUSH
49053: LD_INT 1
49055: PUSH
49056: LD_INT 3
49058: PUSH
49059: EMPTY
49060: LIST
49061: LIST
49062: PUSH
49063: LD_INT 1
49065: PUSH
49066: LD_INT 4
49068: PUSH
49069: EMPTY
49070: LIST
49071: LIST
49072: PUSH
49073: LD_INT 0
49075: PUSH
49076: LD_INT 4
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: LD_INT 1
49085: NEG
49086: PUSH
49087: LD_INT 3
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: LD_INT 1
49096: NEG
49097: PUSH
49098: LD_INT 2
49100: PUSH
49101: EMPTY
49102: LIST
49103: LIST
49104: PUSH
49105: LD_INT 2
49107: PUSH
49108: LD_INT 4
49110: PUSH
49111: EMPTY
49112: LIST
49113: LIST
49114: PUSH
49115: LD_INT 2
49117: NEG
49118: PUSH
49119: LD_INT 2
49121: PUSH
49122: EMPTY
49123: LIST
49124: LIST
49125: PUSH
49126: LD_INT 4
49128: NEG
49129: PUSH
49130: LD_INT 0
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: LD_INT 4
49139: NEG
49140: PUSH
49141: LD_INT 1
49143: NEG
49144: PUSH
49145: EMPTY
49146: LIST
49147: LIST
49148: PUSH
49149: LD_INT 3
49151: NEG
49152: PUSH
49153: LD_INT 0
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: PUSH
49160: LD_INT 3
49162: NEG
49163: PUSH
49164: LD_INT 1
49166: PUSH
49167: EMPTY
49168: LIST
49169: LIST
49170: PUSH
49171: LD_INT 4
49173: NEG
49174: PUSH
49175: LD_INT 1
49177: PUSH
49178: EMPTY
49179: LIST
49180: LIST
49181: PUSH
49182: LD_INT 5
49184: NEG
49185: PUSH
49186: LD_INT 0
49188: PUSH
49189: EMPTY
49190: LIST
49191: LIST
49192: PUSH
49193: LD_INT 5
49195: NEG
49196: PUSH
49197: LD_INT 1
49199: NEG
49200: PUSH
49201: EMPTY
49202: LIST
49203: LIST
49204: PUSH
49205: LD_INT 5
49207: NEG
49208: PUSH
49209: LD_INT 2
49211: NEG
49212: PUSH
49213: EMPTY
49214: LIST
49215: LIST
49216: PUSH
49217: LD_INT 3
49219: NEG
49220: PUSH
49221: LD_INT 2
49223: PUSH
49224: EMPTY
49225: LIST
49226: LIST
49227: PUSH
49228: LD_INT 3
49230: NEG
49231: PUSH
49232: LD_INT 3
49234: NEG
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: LD_INT 3
49242: NEG
49243: PUSH
49244: LD_INT 4
49246: NEG
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PUSH
49252: LD_INT 2
49254: NEG
49255: PUSH
49256: LD_INT 3
49258: NEG
49259: PUSH
49260: EMPTY
49261: LIST
49262: LIST
49263: PUSH
49264: LD_INT 2
49266: NEG
49267: PUSH
49268: LD_INT 2
49270: NEG
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: PUSH
49276: LD_INT 3
49278: NEG
49279: PUSH
49280: LD_INT 2
49282: NEG
49283: PUSH
49284: EMPTY
49285: LIST
49286: LIST
49287: PUSH
49288: LD_INT 4
49290: NEG
49291: PUSH
49292: LD_INT 3
49294: NEG
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: PUSH
49300: LD_INT 4
49302: NEG
49303: PUSH
49304: LD_INT 4
49306: NEG
49307: PUSH
49308: EMPTY
49309: LIST
49310: LIST
49311: PUSH
49312: LD_INT 2
49314: NEG
49315: PUSH
49316: LD_INT 4
49318: NEG
49319: PUSH
49320: EMPTY
49321: LIST
49322: LIST
49323: PUSH
49324: LD_INT 4
49326: NEG
49327: PUSH
49328: LD_INT 2
49330: NEG
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: LD_INT 0
49338: PUSH
49339: LD_INT 4
49341: NEG
49342: PUSH
49343: EMPTY
49344: LIST
49345: LIST
49346: PUSH
49347: LD_INT 0
49349: PUSH
49350: LD_INT 5
49352: NEG
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: PUSH
49358: LD_INT 1
49360: PUSH
49361: LD_INT 4
49363: NEG
49364: PUSH
49365: EMPTY
49366: LIST
49367: LIST
49368: PUSH
49369: LD_INT 1
49371: PUSH
49372: LD_INT 3
49374: NEG
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: PUSH
49380: LD_INT 0
49382: PUSH
49383: LD_INT 3
49385: NEG
49386: PUSH
49387: EMPTY
49388: LIST
49389: LIST
49390: PUSH
49391: LD_INT 1
49393: NEG
49394: PUSH
49395: LD_INT 4
49397: NEG
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PUSH
49403: LD_INT 1
49405: NEG
49406: PUSH
49407: LD_INT 5
49409: NEG
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PUSH
49415: LD_INT 2
49417: PUSH
49418: LD_INT 3
49420: NEG
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: PUSH
49426: LD_INT 2
49428: NEG
49429: PUSH
49430: LD_INT 5
49432: NEG
49433: PUSH
49434: EMPTY
49435: LIST
49436: LIST
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: LIST
49442: LIST
49443: LIST
49444: LIST
49445: LIST
49446: LIST
49447: LIST
49448: LIST
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49485: LD_ADDR_VAR 0 31
49489: PUSH
49490: LD_INT 0
49492: PUSH
49493: LD_INT 4
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 0
49502: PUSH
49503: LD_INT 3
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 1
49512: PUSH
49513: LD_INT 4
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: PUSH
49520: LD_INT 1
49522: PUSH
49523: LD_INT 5
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: LD_INT 0
49532: PUSH
49533: LD_INT 5
49535: PUSH
49536: EMPTY
49537: LIST
49538: LIST
49539: PUSH
49540: LD_INT 1
49542: NEG
49543: PUSH
49544: LD_INT 4
49546: PUSH
49547: EMPTY
49548: LIST
49549: LIST
49550: PUSH
49551: LD_INT 1
49553: NEG
49554: PUSH
49555: LD_INT 3
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 2
49564: PUSH
49565: LD_INT 5
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: PUSH
49572: LD_INT 2
49574: NEG
49575: PUSH
49576: LD_INT 3
49578: PUSH
49579: EMPTY
49580: LIST
49581: LIST
49582: PUSH
49583: LD_INT 3
49585: NEG
49586: PUSH
49587: LD_INT 0
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: PUSH
49594: LD_INT 3
49596: NEG
49597: PUSH
49598: LD_INT 1
49600: NEG
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PUSH
49606: LD_INT 2
49608: NEG
49609: PUSH
49610: LD_INT 0
49612: PUSH
49613: EMPTY
49614: LIST
49615: LIST
49616: PUSH
49617: LD_INT 2
49619: NEG
49620: PUSH
49621: LD_INT 1
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: PUSH
49628: LD_INT 3
49630: NEG
49631: PUSH
49632: LD_INT 1
49634: PUSH
49635: EMPTY
49636: LIST
49637: LIST
49638: PUSH
49639: LD_INT 4
49641: NEG
49642: PUSH
49643: LD_INT 0
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 4
49652: NEG
49653: PUSH
49654: LD_INT 1
49656: NEG
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: LD_INT 4
49664: NEG
49665: PUSH
49666: LD_INT 2
49668: NEG
49669: PUSH
49670: EMPTY
49671: LIST
49672: LIST
49673: PUSH
49674: LD_INT 2
49676: NEG
49677: PUSH
49678: LD_INT 2
49680: PUSH
49681: EMPTY
49682: LIST
49683: LIST
49684: PUSH
49685: LD_INT 4
49687: NEG
49688: PUSH
49689: LD_INT 4
49691: NEG
49692: PUSH
49693: EMPTY
49694: LIST
49695: LIST
49696: PUSH
49697: LD_INT 4
49699: NEG
49700: PUSH
49701: LD_INT 5
49703: NEG
49704: PUSH
49705: EMPTY
49706: LIST
49707: LIST
49708: PUSH
49709: LD_INT 3
49711: NEG
49712: PUSH
49713: LD_INT 4
49715: NEG
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PUSH
49721: LD_INT 3
49723: NEG
49724: PUSH
49725: LD_INT 3
49727: NEG
49728: PUSH
49729: EMPTY
49730: LIST
49731: LIST
49732: PUSH
49733: LD_INT 4
49735: NEG
49736: PUSH
49737: LD_INT 3
49739: NEG
49740: PUSH
49741: EMPTY
49742: LIST
49743: LIST
49744: PUSH
49745: LD_INT 5
49747: NEG
49748: PUSH
49749: LD_INT 4
49751: NEG
49752: PUSH
49753: EMPTY
49754: LIST
49755: LIST
49756: PUSH
49757: LD_INT 5
49759: NEG
49760: PUSH
49761: LD_INT 5
49763: NEG
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: PUSH
49769: LD_INT 3
49771: NEG
49772: PUSH
49773: LD_INT 5
49775: NEG
49776: PUSH
49777: EMPTY
49778: LIST
49779: LIST
49780: PUSH
49781: LD_INT 5
49783: NEG
49784: PUSH
49785: LD_INT 3
49787: NEG
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: PUSH
49793: LD_INT 0
49795: PUSH
49796: LD_INT 3
49798: NEG
49799: PUSH
49800: EMPTY
49801: LIST
49802: LIST
49803: PUSH
49804: LD_INT 0
49806: PUSH
49807: LD_INT 4
49809: NEG
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: LD_INT 1
49817: PUSH
49818: LD_INT 3
49820: NEG
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: PUSH
49826: LD_INT 1
49828: PUSH
49829: LD_INT 2
49831: NEG
49832: PUSH
49833: EMPTY
49834: LIST
49835: LIST
49836: PUSH
49837: LD_INT 0
49839: PUSH
49840: LD_INT 2
49842: NEG
49843: PUSH
49844: EMPTY
49845: LIST
49846: LIST
49847: PUSH
49848: LD_INT 1
49850: NEG
49851: PUSH
49852: LD_INT 3
49854: NEG
49855: PUSH
49856: EMPTY
49857: LIST
49858: LIST
49859: PUSH
49860: LD_INT 1
49862: NEG
49863: PUSH
49864: LD_INT 4
49866: NEG
49867: PUSH
49868: EMPTY
49869: LIST
49870: LIST
49871: PUSH
49872: LD_INT 2
49874: PUSH
49875: LD_INT 2
49877: NEG
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: PUSH
49883: LD_INT 2
49885: NEG
49886: PUSH
49887: LD_INT 4
49889: NEG
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 4
49897: PUSH
49898: LD_INT 0
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: LD_INT 4
49907: PUSH
49908: LD_INT 1
49910: NEG
49911: PUSH
49912: EMPTY
49913: LIST
49914: LIST
49915: PUSH
49916: LD_INT 5
49918: PUSH
49919: LD_INT 0
49921: PUSH
49922: EMPTY
49923: LIST
49924: LIST
49925: PUSH
49926: LD_INT 5
49928: PUSH
49929: LD_INT 1
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: PUSH
49936: LD_INT 4
49938: PUSH
49939: LD_INT 1
49941: PUSH
49942: EMPTY
49943: LIST
49944: LIST
49945: PUSH
49946: LD_INT 3
49948: PUSH
49949: LD_INT 0
49951: PUSH
49952: EMPTY
49953: LIST
49954: LIST
49955: PUSH
49956: LD_INT 3
49958: PUSH
49959: LD_INT 1
49961: NEG
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: LD_INT 3
49969: PUSH
49970: LD_INT 2
49972: NEG
49973: PUSH
49974: EMPTY
49975: LIST
49976: LIST
49977: PUSH
49978: LD_INT 5
49980: PUSH
49981: LD_INT 2
49983: PUSH
49984: EMPTY
49985: LIST
49986: LIST
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: LIST
49992: LIST
49993: LIST
49994: LIST
49995: LIST
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: LIST
50009: LIST
50010: LIST
50011: LIST
50012: LIST
50013: LIST
50014: LIST
50015: LIST
50016: LIST
50017: LIST
50018: LIST
50019: LIST
50020: LIST
50021: LIST
50022: LIST
50023: LIST
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: LIST
50029: LIST
50030: LIST
50031: LIST
50032: LIST
50033: LIST
50034: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
50035: LD_ADDR_VAR 0 32
50039: PUSH
50040: LD_INT 4
50042: NEG
50043: PUSH
50044: LD_INT 0
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: PUSH
50051: LD_INT 4
50053: NEG
50054: PUSH
50055: LD_INT 1
50057: NEG
50058: PUSH
50059: EMPTY
50060: LIST
50061: LIST
50062: PUSH
50063: LD_INT 3
50065: NEG
50066: PUSH
50067: LD_INT 0
50069: PUSH
50070: EMPTY
50071: LIST
50072: LIST
50073: PUSH
50074: LD_INT 3
50076: NEG
50077: PUSH
50078: LD_INT 1
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PUSH
50085: LD_INT 4
50087: NEG
50088: PUSH
50089: LD_INT 1
50091: PUSH
50092: EMPTY
50093: LIST
50094: LIST
50095: PUSH
50096: LD_INT 5
50098: NEG
50099: PUSH
50100: LD_INT 0
50102: PUSH
50103: EMPTY
50104: LIST
50105: LIST
50106: PUSH
50107: LD_INT 5
50109: NEG
50110: PUSH
50111: LD_INT 1
50113: NEG
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: PUSH
50119: LD_INT 5
50121: NEG
50122: PUSH
50123: LD_INT 2
50125: NEG
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: PUSH
50131: LD_INT 3
50133: NEG
50134: PUSH
50135: LD_INT 2
50137: PUSH
50138: EMPTY
50139: LIST
50140: LIST
50141: PUSH
50142: LD_INT 3
50144: NEG
50145: PUSH
50146: LD_INT 3
50148: NEG
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: LD_INT 3
50156: NEG
50157: PUSH
50158: LD_INT 4
50160: NEG
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PUSH
50166: LD_INT 2
50168: NEG
50169: PUSH
50170: LD_INT 3
50172: NEG
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 2
50180: NEG
50181: PUSH
50182: LD_INT 2
50184: NEG
50185: PUSH
50186: EMPTY
50187: LIST
50188: LIST
50189: PUSH
50190: LD_INT 3
50192: NEG
50193: PUSH
50194: LD_INT 2
50196: NEG
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PUSH
50202: LD_INT 4
50204: NEG
50205: PUSH
50206: LD_INT 3
50208: NEG
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PUSH
50214: LD_INT 4
50216: NEG
50217: PUSH
50218: LD_INT 4
50220: NEG
50221: PUSH
50222: EMPTY
50223: LIST
50224: LIST
50225: PUSH
50226: LD_INT 2
50228: NEG
50229: PUSH
50230: LD_INT 4
50232: NEG
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: LD_INT 4
50240: NEG
50241: PUSH
50242: LD_INT 2
50244: NEG
50245: PUSH
50246: EMPTY
50247: LIST
50248: LIST
50249: PUSH
50250: LD_INT 0
50252: PUSH
50253: LD_INT 4
50255: NEG
50256: PUSH
50257: EMPTY
50258: LIST
50259: LIST
50260: PUSH
50261: LD_INT 0
50263: PUSH
50264: LD_INT 5
50266: NEG
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: PUSH
50272: LD_INT 1
50274: PUSH
50275: LD_INT 4
50277: NEG
50278: PUSH
50279: EMPTY
50280: LIST
50281: LIST
50282: PUSH
50283: LD_INT 1
50285: PUSH
50286: LD_INT 3
50288: NEG
50289: PUSH
50290: EMPTY
50291: LIST
50292: LIST
50293: PUSH
50294: LD_INT 0
50296: PUSH
50297: LD_INT 3
50299: NEG
50300: PUSH
50301: EMPTY
50302: LIST
50303: LIST
50304: PUSH
50305: LD_INT 1
50307: NEG
50308: PUSH
50309: LD_INT 4
50311: NEG
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: PUSH
50317: LD_INT 1
50319: NEG
50320: PUSH
50321: LD_INT 5
50323: NEG
50324: PUSH
50325: EMPTY
50326: LIST
50327: LIST
50328: PUSH
50329: LD_INT 2
50331: PUSH
50332: LD_INT 3
50334: NEG
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: PUSH
50340: LD_INT 2
50342: NEG
50343: PUSH
50344: LD_INT 5
50346: NEG
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 3
50354: PUSH
50355: LD_INT 0
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: LD_INT 3
50364: PUSH
50365: LD_INT 1
50367: NEG
50368: PUSH
50369: EMPTY
50370: LIST
50371: LIST
50372: PUSH
50373: LD_INT 4
50375: PUSH
50376: LD_INT 0
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: LD_INT 4
50385: PUSH
50386: LD_INT 1
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: PUSH
50393: LD_INT 3
50395: PUSH
50396: LD_INT 1
50398: PUSH
50399: EMPTY
50400: LIST
50401: LIST
50402: PUSH
50403: LD_INT 2
50405: PUSH
50406: LD_INT 0
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: PUSH
50413: LD_INT 2
50415: PUSH
50416: LD_INT 1
50418: NEG
50419: PUSH
50420: EMPTY
50421: LIST
50422: LIST
50423: PUSH
50424: LD_INT 2
50426: PUSH
50427: LD_INT 2
50429: NEG
50430: PUSH
50431: EMPTY
50432: LIST
50433: LIST
50434: PUSH
50435: LD_INT 4
50437: PUSH
50438: LD_INT 2
50440: PUSH
50441: EMPTY
50442: LIST
50443: LIST
50444: PUSH
50445: LD_INT 4
50447: PUSH
50448: LD_INT 4
50450: PUSH
50451: EMPTY
50452: LIST
50453: LIST
50454: PUSH
50455: LD_INT 4
50457: PUSH
50458: LD_INT 3
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: PUSH
50465: LD_INT 5
50467: PUSH
50468: LD_INT 4
50470: PUSH
50471: EMPTY
50472: LIST
50473: LIST
50474: PUSH
50475: LD_INT 5
50477: PUSH
50478: LD_INT 5
50480: PUSH
50481: EMPTY
50482: LIST
50483: LIST
50484: PUSH
50485: LD_INT 4
50487: PUSH
50488: LD_INT 5
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PUSH
50495: LD_INT 3
50497: PUSH
50498: LD_INT 4
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 3
50507: PUSH
50508: LD_INT 3
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 5
50517: PUSH
50518: LD_INT 3
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 3
50527: PUSH
50528: LD_INT 5
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: LIST
50539: LIST
50540: LIST
50541: LIST
50542: LIST
50543: LIST
50544: LIST
50545: LIST
50546: LIST
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: LIST
50552: LIST
50553: LIST
50554: LIST
50555: LIST
50556: LIST
50557: LIST
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: LIST
50563: LIST
50564: LIST
50565: LIST
50566: LIST
50567: LIST
50568: LIST
50569: LIST
50570: LIST
50571: LIST
50572: LIST
50573: LIST
50574: LIST
50575: LIST
50576: LIST
50577: LIST
50578: LIST
50579: LIST
50580: LIST
50581: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50582: LD_ADDR_VAR 0 33
50586: PUSH
50587: LD_INT 4
50589: NEG
50590: PUSH
50591: LD_INT 4
50593: NEG
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: PUSH
50599: LD_INT 4
50601: NEG
50602: PUSH
50603: LD_INT 5
50605: NEG
50606: PUSH
50607: EMPTY
50608: LIST
50609: LIST
50610: PUSH
50611: LD_INT 3
50613: NEG
50614: PUSH
50615: LD_INT 4
50617: NEG
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PUSH
50623: LD_INT 3
50625: NEG
50626: PUSH
50627: LD_INT 3
50629: NEG
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 4
50637: NEG
50638: PUSH
50639: LD_INT 3
50641: NEG
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: PUSH
50647: LD_INT 5
50649: NEG
50650: PUSH
50651: LD_INT 4
50653: NEG
50654: PUSH
50655: EMPTY
50656: LIST
50657: LIST
50658: PUSH
50659: LD_INT 5
50661: NEG
50662: PUSH
50663: LD_INT 5
50665: NEG
50666: PUSH
50667: EMPTY
50668: LIST
50669: LIST
50670: PUSH
50671: LD_INT 3
50673: NEG
50674: PUSH
50675: LD_INT 5
50677: NEG
50678: PUSH
50679: EMPTY
50680: LIST
50681: LIST
50682: PUSH
50683: LD_INT 5
50685: NEG
50686: PUSH
50687: LD_INT 3
50689: NEG
50690: PUSH
50691: EMPTY
50692: LIST
50693: LIST
50694: PUSH
50695: LD_INT 0
50697: PUSH
50698: LD_INT 3
50700: NEG
50701: PUSH
50702: EMPTY
50703: LIST
50704: LIST
50705: PUSH
50706: LD_INT 0
50708: PUSH
50709: LD_INT 4
50711: NEG
50712: PUSH
50713: EMPTY
50714: LIST
50715: LIST
50716: PUSH
50717: LD_INT 1
50719: PUSH
50720: LD_INT 3
50722: NEG
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: PUSH
50728: LD_INT 1
50730: PUSH
50731: LD_INT 2
50733: NEG
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 0
50741: PUSH
50742: LD_INT 2
50744: NEG
50745: PUSH
50746: EMPTY
50747: LIST
50748: LIST
50749: PUSH
50750: LD_INT 1
50752: NEG
50753: PUSH
50754: LD_INT 3
50756: NEG
50757: PUSH
50758: EMPTY
50759: LIST
50760: LIST
50761: PUSH
50762: LD_INT 1
50764: NEG
50765: PUSH
50766: LD_INT 4
50768: NEG
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: PUSH
50774: LD_INT 2
50776: PUSH
50777: LD_INT 2
50779: NEG
50780: PUSH
50781: EMPTY
50782: LIST
50783: LIST
50784: PUSH
50785: LD_INT 2
50787: NEG
50788: PUSH
50789: LD_INT 4
50791: NEG
50792: PUSH
50793: EMPTY
50794: LIST
50795: LIST
50796: PUSH
50797: LD_INT 4
50799: PUSH
50800: LD_INT 0
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: PUSH
50807: LD_INT 4
50809: PUSH
50810: LD_INT 1
50812: NEG
50813: PUSH
50814: EMPTY
50815: LIST
50816: LIST
50817: PUSH
50818: LD_INT 5
50820: PUSH
50821: LD_INT 0
50823: PUSH
50824: EMPTY
50825: LIST
50826: LIST
50827: PUSH
50828: LD_INT 5
50830: PUSH
50831: LD_INT 1
50833: PUSH
50834: EMPTY
50835: LIST
50836: LIST
50837: PUSH
50838: LD_INT 4
50840: PUSH
50841: LD_INT 1
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: PUSH
50848: LD_INT 3
50850: PUSH
50851: LD_INT 0
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PUSH
50858: LD_INT 3
50860: PUSH
50861: LD_INT 1
50863: NEG
50864: PUSH
50865: EMPTY
50866: LIST
50867: LIST
50868: PUSH
50869: LD_INT 3
50871: PUSH
50872: LD_INT 2
50874: NEG
50875: PUSH
50876: EMPTY
50877: LIST
50878: LIST
50879: PUSH
50880: LD_INT 5
50882: PUSH
50883: LD_INT 2
50885: PUSH
50886: EMPTY
50887: LIST
50888: LIST
50889: PUSH
50890: LD_INT 3
50892: PUSH
50893: LD_INT 3
50895: PUSH
50896: EMPTY
50897: LIST
50898: LIST
50899: PUSH
50900: LD_INT 3
50902: PUSH
50903: LD_INT 2
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 4
50912: PUSH
50913: LD_INT 3
50915: PUSH
50916: EMPTY
50917: LIST
50918: LIST
50919: PUSH
50920: LD_INT 4
50922: PUSH
50923: LD_INT 4
50925: PUSH
50926: EMPTY
50927: LIST
50928: LIST
50929: PUSH
50930: LD_INT 3
50932: PUSH
50933: LD_INT 4
50935: PUSH
50936: EMPTY
50937: LIST
50938: LIST
50939: PUSH
50940: LD_INT 2
50942: PUSH
50943: LD_INT 3
50945: PUSH
50946: EMPTY
50947: LIST
50948: LIST
50949: PUSH
50950: LD_INT 2
50952: PUSH
50953: LD_INT 2
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PUSH
50960: LD_INT 4
50962: PUSH
50963: LD_INT 2
50965: PUSH
50966: EMPTY
50967: LIST
50968: LIST
50969: PUSH
50970: LD_INT 2
50972: PUSH
50973: LD_INT 4
50975: PUSH
50976: EMPTY
50977: LIST
50978: LIST
50979: PUSH
50980: LD_INT 0
50982: PUSH
50983: LD_INT 4
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: PUSH
50990: LD_INT 0
50992: PUSH
50993: LD_INT 3
50995: PUSH
50996: EMPTY
50997: LIST
50998: LIST
50999: PUSH
51000: LD_INT 1
51002: PUSH
51003: LD_INT 4
51005: PUSH
51006: EMPTY
51007: LIST
51008: LIST
51009: PUSH
51010: LD_INT 1
51012: PUSH
51013: LD_INT 5
51015: PUSH
51016: EMPTY
51017: LIST
51018: LIST
51019: PUSH
51020: LD_INT 0
51022: PUSH
51023: LD_INT 5
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PUSH
51030: LD_INT 1
51032: NEG
51033: PUSH
51034: LD_INT 4
51036: PUSH
51037: EMPTY
51038: LIST
51039: LIST
51040: PUSH
51041: LD_INT 1
51043: NEG
51044: PUSH
51045: LD_INT 3
51047: PUSH
51048: EMPTY
51049: LIST
51050: LIST
51051: PUSH
51052: LD_INT 2
51054: PUSH
51055: LD_INT 5
51057: PUSH
51058: EMPTY
51059: LIST
51060: LIST
51061: PUSH
51062: LD_INT 2
51064: NEG
51065: PUSH
51066: LD_INT 3
51068: PUSH
51069: EMPTY
51070: LIST
51071: LIST
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: LIST
51077: LIST
51078: LIST
51079: LIST
51080: LIST
51081: LIST
51082: LIST
51083: LIST
51084: LIST
51085: LIST
51086: LIST
51087: LIST
51088: LIST
51089: LIST
51090: LIST
51091: LIST
51092: LIST
51093: LIST
51094: LIST
51095: LIST
51096: LIST
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
51120: LD_ADDR_VAR 0 34
51124: PUSH
51125: LD_INT 0
51127: PUSH
51128: LD_INT 4
51130: NEG
51131: PUSH
51132: EMPTY
51133: LIST
51134: LIST
51135: PUSH
51136: LD_INT 0
51138: PUSH
51139: LD_INT 5
51141: NEG
51142: PUSH
51143: EMPTY
51144: LIST
51145: LIST
51146: PUSH
51147: LD_INT 1
51149: PUSH
51150: LD_INT 4
51152: NEG
51153: PUSH
51154: EMPTY
51155: LIST
51156: LIST
51157: PUSH
51158: LD_INT 1
51160: PUSH
51161: LD_INT 3
51163: NEG
51164: PUSH
51165: EMPTY
51166: LIST
51167: LIST
51168: PUSH
51169: LD_INT 0
51171: PUSH
51172: LD_INT 3
51174: NEG
51175: PUSH
51176: EMPTY
51177: LIST
51178: LIST
51179: PUSH
51180: LD_INT 1
51182: NEG
51183: PUSH
51184: LD_INT 4
51186: NEG
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: PUSH
51192: LD_INT 1
51194: NEG
51195: PUSH
51196: LD_INT 5
51198: NEG
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: LD_INT 2
51206: PUSH
51207: LD_INT 3
51209: NEG
51210: PUSH
51211: EMPTY
51212: LIST
51213: LIST
51214: PUSH
51215: LD_INT 2
51217: NEG
51218: PUSH
51219: LD_INT 5
51221: NEG
51222: PUSH
51223: EMPTY
51224: LIST
51225: LIST
51226: PUSH
51227: LD_INT 3
51229: PUSH
51230: LD_INT 0
51232: PUSH
51233: EMPTY
51234: LIST
51235: LIST
51236: PUSH
51237: LD_INT 3
51239: PUSH
51240: LD_INT 1
51242: NEG
51243: PUSH
51244: EMPTY
51245: LIST
51246: LIST
51247: PUSH
51248: LD_INT 4
51250: PUSH
51251: LD_INT 0
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PUSH
51258: LD_INT 4
51260: PUSH
51261: LD_INT 1
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 3
51270: PUSH
51271: LD_INT 1
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PUSH
51278: LD_INT 2
51280: PUSH
51281: LD_INT 0
51283: PUSH
51284: EMPTY
51285: LIST
51286: LIST
51287: PUSH
51288: LD_INT 2
51290: PUSH
51291: LD_INT 1
51293: NEG
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: PUSH
51299: LD_INT 2
51301: PUSH
51302: LD_INT 2
51304: NEG
51305: PUSH
51306: EMPTY
51307: LIST
51308: LIST
51309: PUSH
51310: LD_INT 4
51312: PUSH
51313: LD_INT 2
51315: PUSH
51316: EMPTY
51317: LIST
51318: LIST
51319: PUSH
51320: LD_INT 4
51322: PUSH
51323: LD_INT 4
51325: PUSH
51326: EMPTY
51327: LIST
51328: LIST
51329: PUSH
51330: LD_INT 4
51332: PUSH
51333: LD_INT 3
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: PUSH
51340: LD_INT 5
51342: PUSH
51343: LD_INT 4
51345: PUSH
51346: EMPTY
51347: LIST
51348: LIST
51349: PUSH
51350: LD_INT 5
51352: PUSH
51353: LD_INT 5
51355: PUSH
51356: EMPTY
51357: LIST
51358: LIST
51359: PUSH
51360: LD_INT 4
51362: PUSH
51363: LD_INT 5
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: PUSH
51370: LD_INT 3
51372: PUSH
51373: LD_INT 4
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 3
51382: PUSH
51383: LD_INT 3
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: PUSH
51390: LD_INT 5
51392: PUSH
51393: LD_INT 3
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PUSH
51400: LD_INT 3
51402: PUSH
51403: LD_INT 5
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 0
51412: PUSH
51413: LD_INT 3
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PUSH
51420: LD_INT 0
51422: PUSH
51423: LD_INT 2
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 1
51432: PUSH
51433: LD_INT 3
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: PUSH
51440: LD_INT 1
51442: PUSH
51443: LD_INT 4
51445: PUSH
51446: EMPTY
51447: LIST
51448: LIST
51449: PUSH
51450: LD_INT 0
51452: PUSH
51453: LD_INT 4
51455: PUSH
51456: EMPTY
51457: LIST
51458: LIST
51459: PUSH
51460: LD_INT 1
51462: NEG
51463: PUSH
51464: LD_INT 3
51466: PUSH
51467: EMPTY
51468: LIST
51469: LIST
51470: PUSH
51471: LD_INT 1
51473: NEG
51474: PUSH
51475: LD_INT 2
51477: PUSH
51478: EMPTY
51479: LIST
51480: LIST
51481: PUSH
51482: LD_INT 2
51484: PUSH
51485: LD_INT 4
51487: PUSH
51488: EMPTY
51489: LIST
51490: LIST
51491: PUSH
51492: LD_INT 2
51494: NEG
51495: PUSH
51496: LD_INT 2
51498: PUSH
51499: EMPTY
51500: LIST
51501: LIST
51502: PUSH
51503: LD_INT 4
51505: NEG
51506: PUSH
51507: LD_INT 0
51509: PUSH
51510: EMPTY
51511: LIST
51512: LIST
51513: PUSH
51514: LD_INT 4
51516: NEG
51517: PUSH
51518: LD_INT 1
51520: NEG
51521: PUSH
51522: EMPTY
51523: LIST
51524: LIST
51525: PUSH
51526: LD_INT 3
51528: NEG
51529: PUSH
51530: LD_INT 0
51532: PUSH
51533: EMPTY
51534: LIST
51535: LIST
51536: PUSH
51537: LD_INT 3
51539: NEG
51540: PUSH
51541: LD_INT 1
51543: PUSH
51544: EMPTY
51545: LIST
51546: LIST
51547: PUSH
51548: LD_INT 4
51550: NEG
51551: PUSH
51552: LD_INT 1
51554: PUSH
51555: EMPTY
51556: LIST
51557: LIST
51558: PUSH
51559: LD_INT 5
51561: NEG
51562: PUSH
51563: LD_INT 0
51565: PUSH
51566: EMPTY
51567: LIST
51568: LIST
51569: PUSH
51570: LD_INT 5
51572: NEG
51573: PUSH
51574: LD_INT 1
51576: NEG
51577: PUSH
51578: EMPTY
51579: LIST
51580: LIST
51581: PUSH
51582: LD_INT 5
51584: NEG
51585: PUSH
51586: LD_INT 2
51588: NEG
51589: PUSH
51590: EMPTY
51591: LIST
51592: LIST
51593: PUSH
51594: LD_INT 3
51596: NEG
51597: PUSH
51598: LD_INT 2
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: LIST
51627: LIST
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: LIST
51650: LIST
51651: ST_TO_ADDR
// end ; end ;
51652: GO 51655
51654: POP
// case btype of b_depot , b_warehouse :
51655: LD_VAR 0 1
51659: PUSH
51660: LD_INT 0
51662: DOUBLE
51663: EQUAL
51664: IFTRUE 51674
51666: LD_INT 1
51668: DOUBLE
51669: EQUAL
51670: IFTRUE 51674
51672: GO 51875
51674: POP
// case nation of nation_american :
51675: LD_VAR 0 5
51679: PUSH
51680: LD_INT 1
51682: DOUBLE
51683: EQUAL
51684: IFTRUE 51688
51686: GO 51744
51688: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51689: LD_ADDR_VAR 0 9
51693: PUSH
51694: LD_VAR 0 11
51698: PUSH
51699: LD_VAR 0 12
51703: PUSH
51704: LD_VAR 0 13
51708: PUSH
51709: LD_VAR 0 14
51713: PUSH
51714: LD_VAR 0 15
51718: PUSH
51719: LD_VAR 0 16
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: LIST
51728: LIST
51729: LIST
51730: LIST
51731: PUSH
51732: LD_VAR 0 4
51736: PUSH
51737: LD_INT 1
51739: PLUS
51740: ARRAY
51741: ST_TO_ADDR
51742: GO 51873
51744: LD_INT 2
51746: DOUBLE
51747: EQUAL
51748: IFTRUE 51752
51750: GO 51808
51752: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51753: LD_ADDR_VAR 0 9
51757: PUSH
51758: LD_VAR 0 17
51762: PUSH
51763: LD_VAR 0 18
51767: PUSH
51768: LD_VAR 0 19
51772: PUSH
51773: LD_VAR 0 20
51777: PUSH
51778: LD_VAR 0 21
51782: PUSH
51783: LD_VAR 0 22
51787: PUSH
51788: EMPTY
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: PUSH
51796: LD_VAR 0 4
51800: PUSH
51801: LD_INT 1
51803: PLUS
51804: ARRAY
51805: ST_TO_ADDR
51806: GO 51873
51808: LD_INT 3
51810: DOUBLE
51811: EQUAL
51812: IFTRUE 51816
51814: GO 51872
51816: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51817: LD_ADDR_VAR 0 9
51821: PUSH
51822: LD_VAR 0 23
51826: PUSH
51827: LD_VAR 0 24
51831: PUSH
51832: LD_VAR 0 25
51836: PUSH
51837: LD_VAR 0 26
51841: PUSH
51842: LD_VAR 0 27
51846: PUSH
51847: LD_VAR 0 28
51851: PUSH
51852: EMPTY
51853: LIST
51854: LIST
51855: LIST
51856: LIST
51857: LIST
51858: LIST
51859: PUSH
51860: LD_VAR 0 4
51864: PUSH
51865: LD_INT 1
51867: PLUS
51868: ARRAY
51869: ST_TO_ADDR
51870: GO 51873
51872: POP
51873: GO 52428
51875: LD_INT 2
51877: DOUBLE
51878: EQUAL
51879: IFTRUE 51889
51881: LD_INT 3
51883: DOUBLE
51884: EQUAL
51885: IFTRUE 51889
51887: GO 51945
51889: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51890: LD_ADDR_VAR 0 9
51894: PUSH
51895: LD_VAR 0 29
51899: PUSH
51900: LD_VAR 0 30
51904: PUSH
51905: LD_VAR 0 31
51909: PUSH
51910: LD_VAR 0 32
51914: PUSH
51915: LD_VAR 0 33
51919: PUSH
51920: LD_VAR 0 34
51924: PUSH
51925: EMPTY
51926: LIST
51927: LIST
51928: LIST
51929: LIST
51930: LIST
51931: LIST
51932: PUSH
51933: LD_VAR 0 4
51937: PUSH
51938: LD_INT 1
51940: PLUS
51941: ARRAY
51942: ST_TO_ADDR
51943: GO 52428
51945: LD_INT 16
51947: DOUBLE
51948: EQUAL
51949: IFTRUE 52007
51951: LD_INT 17
51953: DOUBLE
51954: EQUAL
51955: IFTRUE 52007
51957: LD_INT 18
51959: DOUBLE
51960: EQUAL
51961: IFTRUE 52007
51963: LD_INT 19
51965: DOUBLE
51966: EQUAL
51967: IFTRUE 52007
51969: LD_INT 22
51971: DOUBLE
51972: EQUAL
51973: IFTRUE 52007
51975: LD_INT 20
51977: DOUBLE
51978: EQUAL
51979: IFTRUE 52007
51981: LD_INT 21
51983: DOUBLE
51984: EQUAL
51985: IFTRUE 52007
51987: LD_INT 23
51989: DOUBLE
51990: EQUAL
51991: IFTRUE 52007
51993: LD_INT 24
51995: DOUBLE
51996: EQUAL
51997: IFTRUE 52007
51999: LD_INT 25
52001: DOUBLE
52002: EQUAL
52003: IFTRUE 52007
52005: GO 52063
52007: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
52008: LD_ADDR_VAR 0 9
52012: PUSH
52013: LD_VAR 0 35
52017: PUSH
52018: LD_VAR 0 36
52022: PUSH
52023: LD_VAR 0 37
52027: PUSH
52028: LD_VAR 0 38
52032: PUSH
52033: LD_VAR 0 39
52037: PUSH
52038: LD_VAR 0 40
52042: PUSH
52043: EMPTY
52044: LIST
52045: LIST
52046: LIST
52047: LIST
52048: LIST
52049: LIST
52050: PUSH
52051: LD_VAR 0 4
52055: PUSH
52056: LD_INT 1
52058: PLUS
52059: ARRAY
52060: ST_TO_ADDR
52061: GO 52428
52063: LD_INT 6
52065: DOUBLE
52066: EQUAL
52067: IFTRUE 52119
52069: LD_INT 7
52071: DOUBLE
52072: EQUAL
52073: IFTRUE 52119
52075: LD_INT 8
52077: DOUBLE
52078: EQUAL
52079: IFTRUE 52119
52081: LD_INT 13
52083: DOUBLE
52084: EQUAL
52085: IFTRUE 52119
52087: LD_INT 12
52089: DOUBLE
52090: EQUAL
52091: IFTRUE 52119
52093: LD_INT 15
52095: DOUBLE
52096: EQUAL
52097: IFTRUE 52119
52099: LD_INT 11
52101: DOUBLE
52102: EQUAL
52103: IFTRUE 52119
52105: LD_INT 14
52107: DOUBLE
52108: EQUAL
52109: IFTRUE 52119
52111: LD_INT 10
52113: DOUBLE
52114: EQUAL
52115: IFTRUE 52119
52117: GO 52175
52119: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
52120: LD_ADDR_VAR 0 9
52124: PUSH
52125: LD_VAR 0 41
52129: PUSH
52130: LD_VAR 0 42
52134: PUSH
52135: LD_VAR 0 43
52139: PUSH
52140: LD_VAR 0 44
52144: PUSH
52145: LD_VAR 0 45
52149: PUSH
52150: LD_VAR 0 46
52154: PUSH
52155: EMPTY
52156: LIST
52157: LIST
52158: LIST
52159: LIST
52160: LIST
52161: LIST
52162: PUSH
52163: LD_VAR 0 4
52167: PUSH
52168: LD_INT 1
52170: PLUS
52171: ARRAY
52172: ST_TO_ADDR
52173: GO 52428
52175: LD_INT 36
52177: DOUBLE
52178: EQUAL
52179: IFTRUE 52183
52181: GO 52239
52183: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52184: LD_ADDR_VAR 0 9
52188: PUSH
52189: LD_VAR 0 47
52193: PUSH
52194: LD_VAR 0 48
52198: PUSH
52199: LD_VAR 0 49
52203: PUSH
52204: LD_VAR 0 50
52208: PUSH
52209: LD_VAR 0 51
52213: PUSH
52214: LD_VAR 0 52
52218: PUSH
52219: EMPTY
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: LIST
52226: PUSH
52227: LD_VAR 0 4
52231: PUSH
52232: LD_INT 1
52234: PLUS
52235: ARRAY
52236: ST_TO_ADDR
52237: GO 52428
52239: LD_INT 4
52241: DOUBLE
52242: EQUAL
52243: IFTRUE 52265
52245: LD_INT 5
52247: DOUBLE
52248: EQUAL
52249: IFTRUE 52265
52251: LD_INT 34
52253: DOUBLE
52254: EQUAL
52255: IFTRUE 52265
52257: LD_INT 37
52259: DOUBLE
52260: EQUAL
52261: IFTRUE 52265
52263: GO 52321
52265: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52266: LD_ADDR_VAR 0 9
52270: PUSH
52271: LD_VAR 0 53
52275: PUSH
52276: LD_VAR 0 54
52280: PUSH
52281: LD_VAR 0 55
52285: PUSH
52286: LD_VAR 0 56
52290: PUSH
52291: LD_VAR 0 57
52295: PUSH
52296: LD_VAR 0 58
52300: PUSH
52301: EMPTY
52302: LIST
52303: LIST
52304: LIST
52305: LIST
52306: LIST
52307: LIST
52308: PUSH
52309: LD_VAR 0 4
52313: PUSH
52314: LD_INT 1
52316: PLUS
52317: ARRAY
52318: ST_TO_ADDR
52319: GO 52428
52321: LD_INT 31
52323: DOUBLE
52324: EQUAL
52325: IFTRUE 52371
52327: LD_INT 32
52329: DOUBLE
52330: EQUAL
52331: IFTRUE 52371
52333: LD_INT 33
52335: DOUBLE
52336: EQUAL
52337: IFTRUE 52371
52339: LD_INT 27
52341: DOUBLE
52342: EQUAL
52343: IFTRUE 52371
52345: LD_INT 26
52347: DOUBLE
52348: EQUAL
52349: IFTRUE 52371
52351: LD_INT 28
52353: DOUBLE
52354: EQUAL
52355: IFTRUE 52371
52357: LD_INT 29
52359: DOUBLE
52360: EQUAL
52361: IFTRUE 52371
52363: LD_INT 30
52365: DOUBLE
52366: EQUAL
52367: IFTRUE 52371
52369: GO 52427
52371: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52372: LD_ADDR_VAR 0 9
52376: PUSH
52377: LD_VAR 0 59
52381: PUSH
52382: LD_VAR 0 60
52386: PUSH
52387: LD_VAR 0 61
52391: PUSH
52392: LD_VAR 0 62
52396: PUSH
52397: LD_VAR 0 63
52401: PUSH
52402: LD_VAR 0 64
52406: PUSH
52407: EMPTY
52408: LIST
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: PUSH
52415: LD_VAR 0 4
52419: PUSH
52420: LD_INT 1
52422: PLUS
52423: ARRAY
52424: ST_TO_ADDR
52425: GO 52428
52427: POP
// temp_list2 = [ ] ;
52428: LD_ADDR_VAR 0 10
52432: PUSH
52433: EMPTY
52434: ST_TO_ADDR
// for i in temp_list do
52435: LD_ADDR_VAR 0 8
52439: PUSH
52440: LD_VAR 0 9
52444: PUSH
52445: FOR_IN
52446: IFFALSE 52498
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52448: LD_ADDR_VAR 0 10
52452: PUSH
52453: LD_VAR 0 10
52457: PUSH
52458: LD_VAR 0 8
52462: PUSH
52463: LD_INT 1
52465: ARRAY
52466: PUSH
52467: LD_VAR 0 2
52471: PLUS
52472: PUSH
52473: LD_VAR 0 8
52477: PUSH
52478: LD_INT 2
52480: ARRAY
52481: PUSH
52482: LD_VAR 0 3
52486: PLUS
52487: PUSH
52488: EMPTY
52489: LIST
52490: LIST
52491: PUSH
52492: EMPTY
52493: LIST
52494: ADD
52495: ST_TO_ADDR
52496: GO 52445
52498: POP
52499: POP
// result = temp_list2 ;
52500: LD_ADDR_VAR 0 7
52504: PUSH
52505: LD_VAR 0 10
52509: ST_TO_ADDR
// end ;
52510: LD_VAR 0 7
52514: RET
// export function EnemyInRange ( unit , dist ) ; begin
52515: LD_INT 0
52517: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52518: LD_ADDR_VAR 0 3
52522: PUSH
52523: LD_VAR 0 1
52527: PPUSH
52528: CALL_OW 255
52532: PPUSH
52533: LD_VAR 0 1
52537: PPUSH
52538: CALL_OW 250
52542: PPUSH
52543: LD_VAR 0 1
52547: PPUSH
52548: CALL_OW 251
52552: PPUSH
52553: LD_VAR 0 2
52557: PPUSH
52558: CALL 25917 0 4
52562: PUSH
52563: LD_INT 4
52565: ARRAY
52566: ST_TO_ADDR
// end ;
52567: LD_VAR 0 3
52571: RET
// export function PlayerSeeMe ( unit ) ; begin
52572: LD_INT 0
52574: PPUSH
// result := See ( your_side , unit ) ;
52575: LD_ADDR_VAR 0 2
52579: PUSH
52580: LD_OWVAR 2
52584: PPUSH
52585: LD_VAR 0 1
52589: PPUSH
52590: CALL_OW 292
52594: ST_TO_ADDR
// end ;
52595: LD_VAR 0 2
52599: RET
// export function ReverseDir ( unit ) ; begin
52600: LD_INT 0
52602: PPUSH
// if not unit then
52603: LD_VAR 0 1
52607: NOT
52608: IFFALSE 52612
// exit ;
52610: GO 52635
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52612: LD_ADDR_VAR 0 2
52616: PUSH
52617: LD_VAR 0 1
52621: PPUSH
52622: CALL_OW 254
52626: PUSH
52627: LD_INT 3
52629: PLUS
52630: PUSH
52631: LD_INT 6
52633: MOD
52634: ST_TO_ADDR
// end ;
52635: LD_VAR 0 2
52639: RET
// export function ReverseArray ( array ) ; var i ; begin
52640: LD_INT 0
52642: PPUSH
52643: PPUSH
// if not array then
52644: LD_VAR 0 1
52648: NOT
52649: IFFALSE 52653
// exit ;
52651: GO 52708
// result := [ ] ;
52653: LD_ADDR_VAR 0 2
52657: PUSH
52658: EMPTY
52659: ST_TO_ADDR
// for i := array downto 1 do
52660: LD_ADDR_VAR 0 3
52664: PUSH
52665: DOUBLE
52666: LD_VAR 0 1
52670: INC
52671: ST_TO_ADDR
52672: LD_INT 1
52674: PUSH
52675: FOR_DOWNTO
52676: IFFALSE 52706
// result := Join ( result , array [ i ] ) ;
52678: LD_ADDR_VAR 0 2
52682: PUSH
52683: LD_VAR 0 2
52687: PPUSH
52688: LD_VAR 0 1
52692: PUSH
52693: LD_VAR 0 3
52697: ARRAY
52698: PPUSH
52699: CALL 57352 0 2
52703: ST_TO_ADDR
52704: GO 52675
52706: POP
52707: POP
// end ;
52708: LD_VAR 0 2
52712: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52713: LD_INT 0
52715: PPUSH
52716: PPUSH
52717: PPUSH
52718: PPUSH
52719: PPUSH
52720: PPUSH
// if not unit or not hexes then
52721: LD_VAR 0 1
52725: NOT
52726: PUSH
52727: LD_VAR 0 2
52731: NOT
52732: OR
52733: IFFALSE 52737
// exit ;
52735: GO 52860
// dist := 9999 ;
52737: LD_ADDR_VAR 0 5
52741: PUSH
52742: LD_INT 9999
52744: ST_TO_ADDR
// for i = 1 to hexes do
52745: LD_ADDR_VAR 0 4
52749: PUSH
52750: DOUBLE
52751: LD_INT 1
52753: DEC
52754: ST_TO_ADDR
52755: LD_VAR 0 2
52759: PUSH
52760: FOR_TO
52761: IFFALSE 52848
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52763: LD_ADDR_VAR 0 6
52767: PUSH
52768: LD_VAR 0 1
52772: PPUSH
52773: LD_VAR 0 2
52777: PUSH
52778: LD_VAR 0 4
52782: ARRAY
52783: PUSH
52784: LD_INT 1
52786: ARRAY
52787: PPUSH
52788: LD_VAR 0 2
52792: PUSH
52793: LD_VAR 0 4
52797: ARRAY
52798: PUSH
52799: LD_INT 2
52801: ARRAY
52802: PPUSH
52803: CALL_OW 297
52807: ST_TO_ADDR
// if tdist < dist then
52808: LD_VAR 0 6
52812: PUSH
52813: LD_VAR 0 5
52817: LESS
52818: IFFALSE 52846
// begin hex := hexes [ i ] ;
52820: LD_ADDR_VAR 0 8
52824: PUSH
52825: LD_VAR 0 2
52829: PUSH
52830: LD_VAR 0 4
52834: ARRAY
52835: ST_TO_ADDR
// dist := tdist ;
52836: LD_ADDR_VAR 0 5
52840: PUSH
52841: LD_VAR 0 6
52845: ST_TO_ADDR
// end ; end ;
52846: GO 52760
52848: POP
52849: POP
// result := hex ;
52850: LD_ADDR_VAR 0 3
52854: PUSH
52855: LD_VAR 0 8
52859: ST_TO_ADDR
// end ;
52860: LD_VAR 0 3
52864: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52865: LD_INT 0
52867: PPUSH
52868: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52869: LD_VAR 0 1
52873: NOT
52874: PUSH
52875: LD_VAR 0 1
52879: PUSH
52880: LD_INT 21
52882: PUSH
52883: LD_INT 2
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PUSH
52890: LD_INT 23
52892: PUSH
52893: LD_INT 2
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: PUSH
52900: EMPTY
52901: LIST
52902: LIST
52903: PPUSH
52904: CALL_OW 69
52908: IN
52909: NOT
52910: OR
52911: IFFALSE 52915
// exit ;
52913: GO 52962
// for i = 1 to 3 do
52915: LD_ADDR_VAR 0 3
52919: PUSH
52920: DOUBLE
52921: LD_INT 1
52923: DEC
52924: ST_TO_ADDR
52925: LD_INT 3
52927: PUSH
52928: FOR_TO
52929: IFFALSE 52960
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52931: LD_VAR 0 1
52935: PPUSH
52936: CALL_OW 250
52940: PPUSH
52941: LD_VAR 0 1
52945: PPUSH
52946: CALL_OW 251
52950: PPUSH
52951: LD_INT 1
52953: PPUSH
52954: CALL_OW 453
52958: GO 52928
52960: POP
52961: POP
// end ;
52962: LD_VAR 0 2
52966: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52967: LD_INT 0
52969: PPUSH
52970: PPUSH
52971: PPUSH
52972: PPUSH
52973: PPUSH
52974: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52975: LD_VAR 0 1
52979: NOT
52980: PUSH
52981: LD_VAR 0 2
52985: NOT
52986: OR
52987: PUSH
52988: LD_VAR 0 1
52992: PPUSH
52993: CALL_OW 314
52997: OR
52998: IFFALSE 53002
// exit ;
53000: GO 53469
// if GetLives ( i ) < 250 then
53002: LD_VAR 0 4
53006: PPUSH
53007: CALL_OW 256
53011: PUSH
53012: LD_INT 250
53014: LESS
53015: IFFALSE 53028
// begin ComAutodestruct ( i ) ;
53017: LD_VAR 0 4
53021: PPUSH
53022: CALL 52865 0 1
// exit ;
53026: GO 53469
// end ; x := GetX ( enemy_unit ) ;
53028: LD_ADDR_VAR 0 7
53032: PUSH
53033: LD_VAR 0 2
53037: PPUSH
53038: CALL_OW 250
53042: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
53043: LD_ADDR_VAR 0 8
53047: PUSH
53048: LD_VAR 0 2
53052: PPUSH
53053: CALL_OW 251
53057: ST_TO_ADDR
// if not x or not y then
53058: LD_VAR 0 7
53062: NOT
53063: PUSH
53064: LD_VAR 0 8
53068: NOT
53069: OR
53070: IFFALSE 53074
// exit ;
53072: GO 53469
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
53074: LD_ADDR_VAR 0 6
53078: PUSH
53079: LD_VAR 0 7
53083: PPUSH
53084: LD_INT 0
53086: PPUSH
53087: LD_INT 4
53089: PPUSH
53090: CALL_OW 272
53094: PUSH
53095: LD_VAR 0 8
53099: PPUSH
53100: LD_INT 0
53102: PPUSH
53103: LD_INT 4
53105: PPUSH
53106: CALL_OW 273
53110: PUSH
53111: EMPTY
53112: LIST
53113: LIST
53114: PUSH
53115: LD_VAR 0 7
53119: PPUSH
53120: LD_INT 1
53122: PPUSH
53123: LD_INT 4
53125: PPUSH
53126: CALL_OW 272
53130: PUSH
53131: LD_VAR 0 8
53135: PPUSH
53136: LD_INT 1
53138: PPUSH
53139: LD_INT 4
53141: PPUSH
53142: CALL_OW 273
53146: PUSH
53147: EMPTY
53148: LIST
53149: LIST
53150: PUSH
53151: LD_VAR 0 7
53155: PPUSH
53156: LD_INT 2
53158: PPUSH
53159: LD_INT 4
53161: PPUSH
53162: CALL_OW 272
53166: PUSH
53167: LD_VAR 0 8
53171: PPUSH
53172: LD_INT 2
53174: PPUSH
53175: LD_INT 4
53177: PPUSH
53178: CALL_OW 273
53182: PUSH
53183: EMPTY
53184: LIST
53185: LIST
53186: PUSH
53187: LD_VAR 0 7
53191: PPUSH
53192: LD_INT 3
53194: PPUSH
53195: LD_INT 4
53197: PPUSH
53198: CALL_OW 272
53202: PUSH
53203: LD_VAR 0 8
53207: PPUSH
53208: LD_INT 3
53210: PPUSH
53211: LD_INT 4
53213: PPUSH
53214: CALL_OW 273
53218: PUSH
53219: EMPTY
53220: LIST
53221: LIST
53222: PUSH
53223: LD_VAR 0 7
53227: PPUSH
53228: LD_INT 4
53230: PPUSH
53231: LD_INT 4
53233: PPUSH
53234: CALL_OW 272
53238: PUSH
53239: LD_VAR 0 8
53243: PPUSH
53244: LD_INT 4
53246: PPUSH
53247: LD_INT 4
53249: PPUSH
53250: CALL_OW 273
53254: PUSH
53255: EMPTY
53256: LIST
53257: LIST
53258: PUSH
53259: LD_VAR 0 7
53263: PPUSH
53264: LD_INT 5
53266: PPUSH
53267: LD_INT 4
53269: PPUSH
53270: CALL_OW 272
53274: PUSH
53275: LD_VAR 0 8
53279: PPUSH
53280: LD_INT 5
53282: PPUSH
53283: LD_INT 4
53285: PPUSH
53286: CALL_OW 273
53290: PUSH
53291: EMPTY
53292: LIST
53293: LIST
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: LIST
53299: LIST
53300: LIST
53301: LIST
53302: ST_TO_ADDR
// for i = tmp downto 1 do
53303: LD_ADDR_VAR 0 4
53307: PUSH
53308: DOUBLE
53309: LD_VAR 0 6
53313: INC
53314: ST_TO_ADDR
53315: LD_INT 1
53317: PUSH
53318: FOR_DOWNTO
53319: IFFALSE 53420
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53321: LD_VAR 0 6
53325: PUSH
53326: LD_VAR 0 4
53330: ARRAY
53331: PUSH
53332: LD_INT 1
53334: ARRAY
53335: PPUSH
53336: LD_VAR 0 6
53340: PUSH
53341: LD_VAR 0 4
53345: ARRAY
53346: PUSH
53347: LD_INT 2
53349: ARRAY
53350: PPUSH
53351: CALL_OW 488
53355: NOT
53356: PUSH
53357: LD_VAR 0 6
53361: PUSH
53362: LD_VAR 0 4
53366: ARRAY
53367: PUSH
53368: LD_INT 1
53370: ARRAY
53371: PPUSH
53372: LD_VAR 0 6
53376: PUSH
53377: LD_VAR 0 4
53381: ARRAY
53382: PUSH
53383: LD_INT 2
53385: ARRAY
53386: PPUSH
53387: CALL_OW 428
53391: PUSH
53392: LD_INT 0
53394: NONEQUAL
53395: OR
53396: IFFALSE 53418
// tmp := Delete ( tmp , i ) ;
53398: LD_ADDR_VAR 0 6
53402: PUSH
53403: LD_VAR 0 6
53407: PPUSH
53408: LD_VAR 0 4
53412: PPUSH
53413: CALL_OW 3
53417: ST_TO_ADDR
53418: GO 53318
53420: POP
53421: POP
// j := GetClosestHex ( unit , tmp ) ;
53422: LD_ADDR_VAR 0 5
53426: PUSH
53427: LD_VAR 0 1
53431: PPUSH
53432: LD_VAR 0 6
53436: PPUSH
53437: CALL 52713 0 2
53441: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53442: LD_VAR 0 1
53446: PPUSH
53447: LD_VAR 0 5
53451: PUSH
53452: LD_INT 1
53454: ARRAY
53455: PPUSH
53456: LD_VAR 0 5
53460: PUSH
53461: LD_INT 2
53463: ARRAY
53464: PPUSH
53465: CALL_OW 111
// end ;
53469: LD_VAR 0 3
53473: RET
// export function PrepareApemanSoldier ( ) ; begin
53474: LD_INT 0
53476: PPUSH
// uc_nation := 0 ;
53477: LD_ADDR_OWVAR 21
53481: PUSH
53482: LD_INT 0
53484: ST_TO_ADDR
// hc_sex := sex_male ;
53485: LD_ADDR_OWVAR 27
53489: PUSH
53490: LD_INT 1
53492: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
53493: LD_ADDR_OWVAR 28
53497: PUSH
53498: LD_INT 15
53500: ST_TO_ADDR
// hc_gallery :=  ;
53501: LD_ADDR_OWVAR 33
53505: PUSH
53506: LD_STRING 
53508: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53509: LD_ADDR_OWVAR 31
53513: PUSH
53514: LD_INT 0
53516: PPUSH
53517: LD_INT 3
53519: PPUSH
53520: CALL_OW 12
53524: PUSH
53525: LD_INT 0
53527: PPUSH
53528: LD_INT 3
53530: PPUSH
53531: CALL_OW 12
53535: PUSH
53536: LD_INT 0
53538: PUSH
53539: LD_INT 0
53541: PUSH
53542: EMPTY
53543: LIST
53544: LIST
53545: LIST
53546: LIST
53547: ST_TO_ADDR
// end ;
53548: LD_VAR 0 1
53552: RET
// export function PrepareApemanEngineer ( ) ; begin
53553: LD_INT 0
53555: PPUSH
// uc_nation := 0 ;
53556: LD_ADDR_OWVAR 21
53560: PUSH
53561: LD_INT 0
53563: ST_TO_ADDR
// hc_sex := sex_male ;
53564: LD_ADDR_OWVAR 27
53568: PUSH
53569: LD_INT 1
53571: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
53572: LD_ADDR_OWVAR 28
53576: PUSH
53577: LD_INT 16
53579: ST_TO_ADDR
// hc_gallery :=  ;
53580: LD_ADDR_OWVAR 33
53584: PUSH
53585: LD_STRING 
53587: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53588: LD_ADDR_OWVAR 31
53592: PUSH
53593: LD_INT 0
53595: PPUSH
53596: LD_INT 3
53598: PPUSH
53599: CALL_OW 12
53603: PUSH
53604: LD_INT 0
53606: PPUSH
53607: LD_INT 3
53609: PPUSH
53610: CALL_OW 12
53614: PUSH
53615: LD_INT 0
53617: PUSH
53618: LD_INT 0
53620: PUSH
53621: EMPTY
53622: LIST
53623: LIST
53624: LIST
53625: LIST
53626: ST_TO_ADDR
// end ;
53627: LD_VAR 0 1
53631: RET
// export function PrepareApeman ( agressivity ) ; begin
53632: LD_INT 0
53634: PPUSH
// uc_side := 0 ;
53635: LD_ADDR_OWVAR 20
53639: PUSH
53640: LD_INT 0
53642: ST_TO_ADDR
// uc_nation := 0 ;
53643: LD_ADDR_OWVAR 21
53647: PUSH
53648: LD_INT 0
53650: ST_TO_ADDR
// hc_sex := sex_male ;
53651: LD_ADDR_OWVAR 27
53655: PUSH
53656: LD_INT 1
53658: ST_TO_ADDR
// hc_class := class_apeman ;
53659: LD_ADDR_OWVAR 28
53663: PUSH
53664: LD_INT 12
53666: ST_TO_ADDR
// hc_gallery :=  ;
53667: LD_ADDR_OWVAR 33
53671: PUSH
53672: LD_STRING 
53674: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53675: LD_ADDR_OWVAR 35
53679: PUSH
53680: LD_VAR 0 1
53684: NEG
53685: PPUSH
53686: LD_VAR 0 1
53690: PPUSH
53691: CALL_OW 12
53695: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53696: LD_ADDR_OWVAR 31
53700: PUSH
53701: LD_INT 0
53703: PPUSH
53704: LD_INT 3
53706: PPUSH
53707: CALL_OW 12
53711: PUSH
53712: LD_INT 0
53714: PPUSH
53715: LD_INT 3
53717: PPUSH
53718: CALL_OW 12
53722: PUSH
53723: LD_INT 0
53725: PUSH
53726: LD_INT 0
53728: PUSH
53729: EMPTY
53730: LIST
53731: LIST
53732: LIST
53733: LIST
53734: ST_TO_ADDR
// end ;
53735: LD_VAR 0 2
53739: RET
// export function PrepareTiger ( agressivity ) ; begin
53740: LD_INT 0
53742: PPUSH
// uc_side := 0 ;
53743: LD_ADDR_OWVAR 20
53747: PUSH
53748: LD_INT 0
53750: ST_TO_ADDR
// uc_nation := 0 ;
53751: LD_ADDR_OWVAR 21
53755: PUSH
53756: LD_INT 0
53758: ST_TO_ADDR
// hc_class := class_tiger ;
53759: LD_ADDR_OWVAR 28
53763: PUSH
53764: LD_INT 14
53766: ST_TO_ADDR
// hc_gallery :=  ;
53767: LD_ADDR_OWVAR 33
53771: PUSH
53772: LD_STRING 
53774: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53775: LD_ADDR_OWVAR 35
53779: PUSH
53780: LD_VAR 0 1
53784: NEG
53785: PPUSH
53786: LD_VAR 0 1
53790: PPUSH
53791: CALL_OW 12
53795: ST_TO_ADDR
// end ;
53796: LD_VAR 0 2
53800: RET
// export function PrepareEnchidna ( ) ; begin
53801: LD_INT 0
53803: PPUSH
// uc_side := 0 ;
53804: LD_ADDR_OWVAR 20
53808: PUSH
53809: LD_INT 0
53811: ST_TO_ADDR
// uc_nation := 0 ;
53812: LD_ADDR_OWVAR 21
53816: PUSH
53817: LD_INT 0
53819: ST_TO_ADDR
// hc_class := class_baggie ;
53820: LD_ADDR_OWVAR 28
53824: PUSH
53825: LD_INT 13
53827: ST_TO_ADDR
// hc_gallery :=  ;
53828: LD_ADDR_OWVAR 33
53832: PUSH
53833: LD_STRING 
53835: ST_TO_ADDR
// end ;
53836: LD_VAR 0 1
53840: RET
// export function PrepareFrog ( ) ; begin
53841: LD_INT 0
53843: PPUSH
// uc_side := 0 ;
53844: LD_ADDR_OWVAR 20
53848: PUSH
53849: LD_INT 0
53851: ST_TO_ADDR
// uc_nation := 0 ;
53852: LD_ADDR_OWVAR 21
53856: PUSH
53857: LD_INT 0
53859: ST_TO_ADDR
// hc_class := class_frog ;
53860: LD_ADDR_OWVAR 28
53864: PUSH
53865: LD_INT 19
53867: ST_TO_ADDR
// hc_gallery :=  ;
53868: LD_ADDR_OWVAR 33
53872: PUSH
53873: LD_STRING 
53875: ST_TO_ADDR
// end ;
53876: LD_VAR 0 1
53880: RET
// export function PrepareFish ( ) ; begin
53881: LD_INT 0
53883: PPUSH
// uc_side := 0 ;
53884: LD_ADDR_OWVAR 20
53888: PUSH
53889: LD_INT 0
53891: ST_TO_ADDR
// uc_nation := 0 ;
53892: LD_ADDR_OWVAR 21
53896: PUSH
53897: LD_INT 0
53899: ST_TO_ADDR
// hc_class := class_fish ;
53900: LD_ADDR_OWVAR 28
53904: PUSH
53905: LD_INT 20
53907: ST_TO_ADDR
// hc_gallery :=  ;
53908: LD_ADDR_OWVAR 33
53912: PUSH
53913: LD_STRING 
53915: ST_TO_ADDR
// end ;
53916: LD_VAR 0 1
53920: RET
// export function PrepareBird ( ) ; begin
53921: LD_INT 0
53923: PPUSH
// uc_side := 0 ;
53924: LD_ADDR_OWVAR 20
53928: PUSH
53929: LD_INT 0
53931: ST_TO_ADDR
// uc_nation := 0 ;
53932: LD_ADDR_OWVAR 21
53936: PUSH
53937: LD_INT 0
53939: ST_TO_ADDR
// hc_class := class_phororhacos ;
53940: LD_ADDR_OWVAR 28
53944: PUSH
53945: LD_INT 18
53947: ST_TO_ADDR
// hc_gallery :=  ;
53948: LD_ADDR_OWVAR 33
53952: PUSH
53953: LD_STRING 
53955: ST_TO_ADDR
// end ;
53956: LD_VAR 0 1
53960: RET
// export function PrepareHorse ( ) ; begin
53961: LD_INT 0
53963: PPUSH
// uc_side := 0 ;
53964: LD_ADDR_OWVAR 20
53968: PUSH
53969: LD_INT 0
53971: ST_TO_ADDR
// uc_nation := 0 ;
53972: LD_ADDR_OWVAR 21
53976: PUSH
53977: LD_INT 0
53979: ST_TO_ADDR
// hc_class := class_horse ;
53980: LD_ADDR_OWVAR 28
53984: PUSH
53985: LD_INT 21
53987: ST_TO_ADDR
// hc_gallery :=  ;
53988: LD_ADDR_OWVAR 33
53992: PUSH
53993: LD_STRING 
53995: ST_TO_ADDR
// end ;
53996: LD_VAR 0 1
54000: RET
// export function PrepareMastodont ( ) ; begin
54001: LD_INT 0
54003: PPUSH
// uc_side := 0 ;
54004: LD_ADDR_OWVAR 20
54008: PUSH
54009: LD_INT 0
54011: ST_TO_ADDR
// uc_nation := 0 ;
54012: LD_ADDR_OWVAR 21
54016: PUSH
54017: LD_INT 0
54019: ST_TO_ADDR
// vc_chassis := class_mastodont ;
54020: LD_ADDR_OWVAR 37
54024: PUSH
54025: LD_INT 31
54027: ST_TO_ADDR
// vc_control := control_rider ;
54028: LD_ADDR_OWVAR 38
54032: PUSH
54033: LD_INT 4
54035: ST_TO_ADDR
// end ;
54036: LD_VAR 0 1
54040: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
54041: LD_INT 0
54043: PPUSH
54044: PPUSH
54045: PPUSH
// uc_side = 0 ;
54046: LD_ADDR_OWVAR 20
54050: PUSH
54051: LD_INT 0
54053: ST_TO_ADDR
// uc_nation = 0 ;
54054: LD_ADDR_OWVAR 21
54058: PUSH
54059: LD_INT 0
54061: ST_TO_ADDR
// InitHc_All ( ) ;
54062: CALL_OW 584
// InitVc ;
54066: CALL_OW 20
// if mastodonts then
54070: LD_VAR 0 6
54074: IFFALSE 54141
// for i = 1 to mastodonts do
54076: LD_ADDR_VAR 0 11
54080: PUSH
54081: DOUBLE
54082: LD_INT 1
54084: DEC
54085: ST_TO_ADDR
54086: LD_VAR 0 6
54090: PUSH
54091: FOR_TO
54092: IFFALSE 54139
// begin vc_chassis := 31 ;
54094: LD_ADDR_OWVAR 37
54098: PUSH
54099: LD_INT 31
54101: ST_TO_ADDR
// vc_control := control_rider ;
54102: LD_ADDR_OWVAR 38
54106: PUSH
54107: LD_INT 4
54109: ST_TO_ADDR
// animal := CreateVehicle ;
54110: LD_ADDR_VAR 0 12
54114: PUSH
54115: CALL_OW 45
54119: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54120: LD_VAR 0 12
54124: PPUSH
54125: LD_VAR 0 8
54129: PPUSH
54130: LD_INT 0
54132: PPUSH
54133: CALL 56269 0 3
// end ;
54137: GO 54091
54139: POP
54140: POP
// if horses then
54141: LD_VAR 0 5
54145: IFFALSE 54212
// for i = 1 to horses do
54147: LD_ADDR_VAR 0 11
54151: PUSH
54152: DOUBLE
54153: LD_INT 1
54155: DEC
54156: ST_TO_ADDR
54157: LD_VAR 0 5
54161: PUSH
54162: FOR_TO
54163: IFFALSE 54210
// begin hc_class := 21 ;
54165: LD_ADDR_OWVAR 28
54169: PUSH
54170: LD_INT 21
54172: ST_TO_ADDR
// hc_gallery :=  ;
54173: LD_ADDR_OWVAR 33
54177: PUSH
54178: LD_STRING 
54180: ST_TO_ADDR
// animal := CreateHuman ;
54181: LD_ADDR_VAR 0 12
54185: PUSH
54186: CALL_OW 44
54190: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54191: LD_VAR 0 12
54195: PPUSH
54196: LD_VAR 0 8
54200: PPUSH
54201: LD_INT 0
54203: PPUSH
54204: CALL 56269 0 3
// end ;
54208: GO 54162
54210: POP
54211: POP
// if birds then
54212: LD_VAR 0 1
54216: IFFALSE 54283
// for i = 1 to birds do
54218: LD_ADDR_VAR 0 11
54222: PUSH
54223: DOUBLE
54224: LD_INT 1
54226: DEC
54227: ST_TO_ADDR
54228: LD_VAR 0 1
54232: PUSH
54233: FOR_TO
54234: IFFALSE 54281
// begin hc_class = 18 ;
54236: LD_ADDR_OWVAR 28
54240: PUSH
54241: LD_INT 18
54243: ST_TO_ADDR
// hc_gallery =  ;
54244: LD_ADDR_OWVAR 33
54248: PUSH
54249: LD_STRING 
54251: ST_TO_ADDR
// animal := CreateHuman ;
54252: LD_ADDR_VAR 0 12
54256: PUSH
54257: CALL_OW 44
54261: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54262: LD_VAR 0 12
54266: PPUSH
54267: LD_VAR 0 8
54271: PPUSH
54272: LD_INT 0
54274: PPUSH
54275: CALL 56269 0 3
// end ;
54279: GO 54233
54281: POP
54282: POP
// if tigers then
54283: LD_VAR 0 2
54287: IFFALSE 54371
// for i = 1 to tigers do
54289: LD_ADDR_VAR 0 11
54293: PUSH
54294: DOUBLE
54295: LD_INT 1
54297: DEC
54298: ST_TO_ADDR
54299: LD_VAR 0 2
54303: PUSH
54304: FOR_TO
54305: IFFALSE 54369
// begin hc_class = class_tiger ;
54307: LD_ADDR_OWVAR 28
54311: PUSH
54312: LD_INT 14
54314: ST_TO_ADDR
// hc_gallery =  ;
54315: LD_ADDR_OWVAR 33
54319: PUSH
54320: LD_STRING 
54322: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
54323: LD_ADDR_OWVAR 35
54327: PUSH
54328: LD_INT 7
54330: NEG
54331: PPUSH
54332: LD_INT 7
54334: PPUSH
54335: CALL_OW 12
54339: ST_TO_ADDR
// animal := CreateHuman ;
54340: LD_ADDR_VAR 0 12
54344: PUSH
54345: CALL_OW 44
54349: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54350: LD_VAR 0 12
54354: PPUSH
54355: LD_VAR 0 8
54359: PPUSH
54360: LD_INT 0
54362: PPUSH
54363: CALL 56269 0 3
// end ;
54367: GO 54304
54369: POP
54370: POP
// if apemans then
54371: LD_VAR 0 3
54375: IFFALSE 54498
// for i = 1 to apemans do
54377: LD_ADDR_VAR 0 11
54381: PUSH
54382: DOUBLE
54383: LD_INT 1
54385: DEC
54386: ST_TO_ADDR
54387: LD_VAR 0 3
54391: PUSH
54392: FOR_TO
54393: IFFALSE 54496
// begin hc_class = class_apeman ;
54395: LD_ADDR_OWVAR 28
54399: PUSH
54400: LD_INT 12
54402: ST_TO_ADDR
// hc_gallery =  ;
54403: LD_ADDR_OWVAR 33
54407: PUSH
54408: LD_STRING 
54410: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
54411: LD_ADDR_OWVAR 35
54415: PUSH
54416: LD_INT 2
54418: NEG
54419: PPUSH
54420: LD_INT 2
54422: PPUSH
54423: CALL_OW 12
54427: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
54428: LD_ADDR_OWVAR 31
54432: PUSH
54433: LD_INT 1
54435: PPUSH
54436: LD_INT 3
54438: PPUSH
54439: CALL_OW 12
54443: PUSH
54444: LD_INT 1
54446: PPUSH
54447: LD_INT 3
54449: PPUSH
54450: CALL_OW 12
54454: PUSH
54455: LD_INT 0
54457: PUSH
54458: LD_INT 0
54460: PUSH
54461: EMPTY
54462: LIST
54463: LIST
54464: LIST
54465: LIST
54466: ST_TO_ADDR
// animal := CreateHuman ;
54467: LD_ADDR_VAR 0 12
54471: PUSH
54472: CALL_OW 44
54476: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54477: LD_VAR 0 12
54481: PPUSH
54482: LD_VAR 0 8
54486: PPUSH
54487: LD_INT 0
54489: PPUSH
54490: CALL 56269 0 3
// end ;
54494: GO 54392
54496: POP
54497: POP
// if enchidnas then
54498: LD_VAR 0 4
54502: IFFALSE 54569
// for i = 1 to enchidnas do
54504: LD_ADDR_VAR 0 11
54508: PUSH
54509: DOUBLE
54510: LD_INT 1
54512: DEC
54513: ST_TO_ADDR
54514: LD_VAR 0 4
54518: PUSH
54519: FOR_TO
54520: IFFALSE 54567
// begin hc_class = 13 ;
54522: LD_ADDR_OWVAR 28
54526: PUSH
54527: LD_INT 13
54529: ST_TO_ADDR
// hc_gallery =  ;
54530: LD_ADDR_OWVAR 33
54534: PUSH
54535: LD_STRING 
54537: ST_TO_ADDR
// animal := CreateHuman ;
54538: LD_ADDR_VAR 0 12
54542: PUSH
54543: CALL_OW 44
54547: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54548: LD_VAR 0 12
54552: PPUSH
54553: LD_VAR 0 8
54557: PPUSH
54558: LD_INT 0
54560: PPUSH
54561: CALL 56269 0 3
// end ;
54565: GO 54519
54567: POP
54568: POP
// if fishes then
54569: LD_VAR 0 7
54573: IFFALSE 54640
// for i = 1 to fishes do
54575: LD_ADDR_VAR 0 11
54579: PUSH
54580: DOUBLE
54581: LD_INT 1
54583: DEC
54584: ST_TO_ADDR
54585: LD_VAR 0 7
54589: PUSH
54590: FOR_TO
54591: IFFALSE 54638
// begin hc_class = 20 ;
54593: LD_ADDR_OWVAR 28
54597: PUSH
54598: LD_INT 20
54600: ST_TO_ADDR
// hc_gallery =  ;
54601: LD_ADDR_OWVAR 33
54605: PUSH
54606: LD_STRING 
54608: ST_TO_ADDR
// animal := CreateHuman ;
54609: LD_ADDR_VAR 0 12
54613: PUSH
54614: CALL_OW 44
54618: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
54619: LD_VAR 0 12
54623: PPUSH
54624: LD_VAR 0 9
54628: PPUSH
54629: LD_INT 0
54631: PPUSH
54632: CALL 56269 0 3
// end ;
54636: GO 54590
54638: POP
54639: POP
// end ;
54640: LD_VAR 0 10
54644: RET
// export function WantHeal ( sci , unit ) ; begin
54645: LD_INT 0
54647: PPUSH
// if GetTaskList ( sci ) > 0 then
54648: LD_VAR 0 1
54652: PPUSH
54653: CALL_OW 437
54657: PUSH
54658: LD_INT 0
54660: GREATER
54661: IFFALSE 54731
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54663: LD_VAR 0 1
54667: PPUSH
54668: CALL_OW 437
54672: PUSH
54673: LD_INT 1
54675: ARRAY
54676: PUSH
54677: LD_INT 1
54679: ARRAY
54680: PUSH
54681: LD_STRING l
54683: EQUAL
54684: PUSH
54685: LD_VAR 0 1
54689: PPUSH
54690: CALL_OW 437
54694: PUSH
54695: LD_INT 1
54697: ARRAY
54698: PUSH
54699: LD_INT 4
54701: ARRAY
54702: PUSH
54703: LD_VAR 0 2
54707: EQUAL
54708: AND
54709: IFFALSE 54721
// result := true else
54711: LD_ADDR_VAR 0 3
54715: PUSH
54716: LD_INT 1
54718: ST_TO_ADDR
54719: GO 54729
// result := false ;
54721: LD_ADDR_VAR 0 3
54725: PUSH
54726: LD_INT 0
54728: ST_TO_ADDR
// end else
54729: GO 54739
// result := false ;
54731: LD_ADDR_VAR 0 3
54735: PUSH
54736: LD_INT 0
54738: ST_TO_ADDR
// end ;
54739: LD_VAR 0 3
54743: RET
// export function HealTarget ( sci ) ; begin
54744: LD_INT 0
54746: PPUSH
// if not sci then
54747: LD_VAR 0 1
54751: NOT
54752: IFFALSE 54756
// exit ;
54754: GO 54821
// result := 0 ;
54756: LD_ADDR_VAR 0 2
54760: PUSH
54761: LD_INT 0
54763: ST_TO_ADDR
// if GetTaskList ( sci ) then
54764: LD_VAR 0 1
54768: PPUSH
54769: CALL_OW 437
54773: IFFALSE 54821
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54775: LD_VAR 0 1
54779: PPUSH
54780: CALL_OW 437
54784: PUSH
54785: LD_INT 1
54787: ARRAY
54788: PUSH
54789: LD_INT 1
54791: ARRAY
54792: PUSH
54793: LD_STRING l
54795: EQUAL
54796: IFFALSE 54821
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54798: LD_ADDR_VAR 0 2
54802: PUSH
54803: LD_VAR 0 1
54807: PPUSH
54808: CALL_OW 437
54812: PUSH
54813: LD_INT 1
54815: ARRAY
54816: PUSH
54817: LD_INT 4
54819: ARRAY
54820: ST_TO_ADDR
// end ;
54821: LD_VAR 0 2
54825: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54826: LD_INT 0
54828: PPUSH
54829: PPUSH
54830: PPUSH
54831: PPUSH
// if not base_units then
54832: LD_VAR 0 1
54836: NOT
54837: IFFALSE 54841
// exit ;
54839: GO 54928
// result := false ;
54841: LD_ADDR_VAR 0 2
54845: PUSH
54846: LD_INT 0
54848: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54849: LD_ADDR_VAR 0 5
54853: PUSH
54854: LD_VAR 0 1
54858: PPUSH
54859: LD_INT 21
54861: PUSH
54862: LD_INT 3
54864: PUSH
54865: EMPTY
54866: LIST
54867: LIST
54868: PPUSH
54869: CALL_OW 72
54873: ST_TO_ADDR
// if not tmp then
54874: LD_VAR 0 5
54878: NOT
54879: IFFALSE 54883
// exit ;
54881: GO 54928
// for i in tmp do
54883: LD_ADDR_VAR 0 3
54887: PUSH
54888: LD_VAR 0 5
54892: PUSH
54893: FOR_IN
54894: IFFALSE 54926
// begin result := EnemyInRange ( i , 22 ) ;
54896: LD_ADDR_VAR 0 2
54900: PUSH
54901: LD_VAR 0 3
54905: PPUSH
54906: LD_INT 22
54908: PPUSH
54909: CALL 52515 0 2
54913: ST_TO_ADDR
// if result then
54914: LD_VAR 0 2
54918: IFFALSE 54924
// exit ;
54920: POP
54921: POP
54922: GO 54928
// end ;
54924: GO 54893
54926: POP
54927: POP
// end ;
54928: LD_VAR 0 2
54932: RET
// export function FilterByTag ( units , tag ) ; begin
54933: LD_INT 0
54935: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54936: LD_ADDR_VAR 0 3
54940: PUSH
54941: LD_VAR 0 1
54945: PPUSH
54946: LD_INT 120
54948: PUSH
54949: LD_VAR 0 2
54953: PUSH
54954: EMPTY
54955: LIST
54956: LIST
54957: PPUSH
54958: CALL_OW 72
54962: ST_TO_ADDR
// end ;
54963: LD_VAR 0 3
54967: RET
// export function IsDriver ( un ) ; begin
54968: LD_INT 0
54970: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54971: LD_ADDR_VAR 0 2
54975: PUSH
54976: LD_VAR 0 1
54980: PUSH
54981: LD_INT 55
54983: PUSH
54984: EMPTY
54985: LIST
54986: PPUSH
54987: CALL_OW 69
54991: IN
54992: ST_TO_ADDR
// end ;
54993: LD_VAR 0 2
54997: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54998: LD_INT 0
55000: PPUSH
55001: PPUSH
// list := [ ] ;
55002: LD_ADDR_VAR 0 5
55006: PUSH
55007: EMPTY
55008: ST_TO_ADDR
// case d of 0 :
55009: LD_VAR 0 3
55013: PUSH
55014: LD_INT 0
55016: DOUBLE
55017: EQUAL
55018: IFTRUE 55022
55020: GO 55155
55022: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
55023: LD_ADDR_VAR 0 5
55027: PUSH
55028: LD_VAR 0 1
55032: PUSH
55033: LD_INT 4
55035: MINUS
55036: PUSH
55037: LD_VAR 0 2
55041: PUSH
55042: LD_INT 4
55044: MINUS
55045: PUSH
55046: LD_INT 2
55048: PUSH
55049: EMPTY
55050: LIST
55051: LIST
55052: LIST
55053: PUSH
55054: LD_VAR 0 1
55058: PUSH
55059: LD_INT 3
55061: MINUS
55062: PUSH
55063: LD_VAR 0 2
55067: PUSH
55068: LD_INT 1
55070: PUSH
55071: EMPTY
55072: LIST
55073: LIST
55074: LIST
55075: PUSH
55076: LD_VAR 0 1
55080: PUSH
55081: LD_INT 4
55083: PLUS
55084: PUSH
55085: LD_VAR 0 2
55089: PUSH
55090: LD_INT 4
55092: PUSH
55093: EMPTY
55094: LIST
55095: LIST
55096: LIST
55097: PUSH
55098: LD_VAR 0 1
55102: PUSH
55103: LD_INT 3
55105: PLUS
55106: PUSH
55107: LD_VAR 0 2
55111: PUSH
55112: LD_INT 3
55114: PLUS
55115: PUSH
55116: LD_INT 5
55118: PUSH
55119: EMPTY
55120: LIST
55121: LIST
55122: LIST
55123: PUSH
55124: LD_VAR 0 1
55128: PUSH
55129: LD_VAR 0 2
55133: PUSH
55134: LD_INT 4
55136: PLUS
55137: PUSH
55138: LD_INT 0
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: LIST
55145: PUSH
55146: EMPTY
55147: LIST
55148: LIST
55149: LIST
55150: LIST
55151: LIST
55152: ST_TO_ADDR
// end ; 1 :
55153: GO 55853
55155: LD_INT 1
55157: DOUBLE
55158: EQUAL
55159: IFTRUE 55163
55161: GO 55296
55163: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55164: LD_ADDR_VAR 0 5
55168: PUSH
55169: LD_VAR 0 1
55173: PUSH
55174: LD_VAR 0 2
55178: PUSH
55179: LD_INT 4
55181: MINUS
55182: PUSH
55183: LD_INT 3
55185: PUSH
55186: EMPTY
55187: LIST
55188: LIST
55189: LIST
55190: PUSH
55191: LD_VAR 0 1
55195: PUSH
55196: LD_INT 3
55198: MINUS
55199: PUSH
55200: LD_VAR 0 2
55204: PUSH
55205: LD_INT 3
55207: MINUS
55208: PUSH
55209: LD_INT 2
55211: PUSH
55212: EMPTY
55213: LIST
55214: LIST
55215: LIST
55216: PUSH
55217: LD_VAR 0 1
55221: PUSH
55222: LD_INT 4
55224: MINUS
55225: PUSH
55226: LD_VAR 0 2
55230: PUSH
55231: LD_INT 1
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: LIST
55238: PUSH
55239: LD_VAR 0 1
55243: PUSH
55244: LD_VAR 0 2
55248: PUSH
55249: LD_INT 3
55251: PLUS
55252: PUSH
55253: LD_INT 0
55255: PUSH
55256: EMPTY
55257: LIST
55258: LIST
55259: LIST
55260: PUSH
55261: LD_VAR 0 1
55265: PUSH
55266: LD_INT 4
55268: PLUS
55269: PUSH
55270: LD_VAR 0 2
55274: PUSH
55275: LD_INT 4
55277: PLUS
55278: PUSH
55279: LD_INT 5
55281: PUSH
55282: EMPTY
55283: LIST
55284: LIST
55285: LIST
55286: PUSH
55287: EMPTY
55288: LIST
55289: LIST
55290: LIST
55291: LIST
55292: LIST
55293: ST_TO_ADDR
// end ; 2 :
55294: GO 55853
55296: LD_INT 2
55298: DOUBLE
55299: EQUAL
55300: IFTRUE 55304
55302: GO 55433
55304: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55305: LD_ADDR_VAR 0 5
55309: PUSH
55310: LD_VAR 0 1
55314: PUSH
55315: LD_VAR 0 2
55319: PUSH
55320: LD_INT 3
55322: MINUS
55323: PUSH
55324: LD_INT 3
55326: PUSH
55327: EMPTY
55328: LIST
55329: LIST
55330: LIST
55331: PUSH
55332: LD_VAR 0 1
55336: PUSH
55337: LD_INT 4
55339: PLUS
55340: PUSH
55341: LD_VAR 0 2
55345: PUSH
55346: LD_INT 4
55348: PUSH
55349: EMPTY
55350: LIST
55351: LIST
55352: LIST
55353: PUSH
55354: LD_VAR 0 1
55358: PUSH
55359: LD_VAR 0 2
55363: PUSH
55364: LD_INT 4
55366: PLUS
55367: PUSH
55368: LD_INT 0
55370: PUSH
55371: EMPTY
55372: LIST
55373: LIST
55374: LIST
55375: PUSH
55376: LD_VAR 0 1
55380: PUSH
55381: LD_INT 3
55383: MINUS
55384: PUSH
55385: LD_VAR 0 2
55389: PUSH
55390: LD_INT 1
55392: PUSH
55393: EMPTY
55394: LIST
55395: LIST
55396: LIST
55397: PUSH
55398: LD_VAR 0 1
55402: PUSH
55403: LD_INT 4
55405: MINUS
55406: PUSH
55407: LD_VAR 0 2
55411: PUSH
55412: LD_INT 4
55414: MINUS
55415: PUSH
55416: LD_INT 2
55418: PUSH
55419: EMPTY
55420: LIST
55421: LIST
55422: LIST
55423: PUSH
55424: EMPTY
55425: LIST
55426: LIST
55427: LIST
55428: LIST
55429: LIST
55430: ST_TO_ADDR
// end ; 3 :
55431: GO 55853
55433: LD_INT 3
55435: DOUBLE
55436: EQUAL
55437: IFTRUE 55441
55439: GO 55574
55441: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55442: LD_ADDR_VAR 0 5
55446: PUSH
55447: LD_VAR 0 1
55451: PUSH
55452: LD_INT 3
55454: PLUS
55455: PUSH
55456: LD_VAR 0 2
55460: PUSH
55461: LD_INT 4
55463: PUSH
55464: EMPTY
55465: LIST
55466: LIST
55467: LIST
55468: PUSH
55469: LD_VAR 0 1
55473: PUSH
55474: LD_INT 4
55476: PLUS
55477: PUSH
55478: LD_VAR 0 2
55482: PUSH
55483: LD_INT 4
55485: PLUS
55486: PUSH
55487: LD_INT 5
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: LIST
55494: PUSH
55495: LD_VAR 0 1
55499: PUSH
55500: LD_INT 4
55502: MINUS
55503: PUSH
55504: LD_VAR 0 2
55508: PUSH
55509: LD_INT 1
55511: PUSH
55512: EMPTY
55513: LIST
55514: LIST
55515: LIST
55516: PUSH
55517: LD_VAR 0 1
55521: PUSH
55522: LD_VAR 0 2
55526: PUSH
55527: LD_INT 4
55529: MINUS
55530: PUSH
55531: LD_INT 3
55533: PUSH
55534: EMPTY
55535: LIST
55536: LIST
55537: LIST
55538: PUSH
55539: LD_VAR 0 1
55543: PUSH
55544: LD_INT 3
55546: MINUS
55547: PUSH
55548: LD_VAR 0 2
55552: PUSH
55553: LD_INT 3
55555: MINUS
55556: PUSH
55557: LD_INT 2
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: LIST
55564: PUSH
55565: EMPTY
55566: LIST
55567: LIST
55568: LIST
55569: LIST
55570: LIST
55571: ST_TO_ADDR
// end ; 4 :
55572: GO 55853
55574: LD_INT 4
55576: DOUBLE
55577: EQUAL
55578: IFTRUE 55582
55580: GO 55715
55582: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55583: LD_ADDR_VAR 0 5
55587: PUSH
55588: LD_VAR 0 1
55592: PUSH
55593: LD_VAR 0 2
55597: PUSH
55598: LD_INT 4
55600: PLUS
55601: PUSH
55602: LD_INT 0
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: LIST
55609: PUSH
55610: LD_VAR 0 1
55614: PUSH
55615: LD_INT 3
55617: PLUS
55618: PUSH
55619: LD_VAR 0 2
55623: PUSH
55624: LD_INT 3
55626: PLUS
55627: PUSH
55628: LD_INT 5
55630: PUSH
55631: EMPTY
55632: LIST
55633: LIST
55634: LIST
55635: PUSH
55636: LD_VAR 0 1
55640: PUSH
55641: LD_INT 4
55643: PLUS
55644: PUSH
55645: LD_VAR 0 2
55649: PUSH
55650: LD_INT 4
55652: PUSH
55653: EMPTY
55654: LIST
55655: LIST
55656: LIST
55657: PUSH
55658: LD_VAR 0 1
55662: PUSH
55663: LD_VAR 0 2
55667: PUSH
55668: LD_INT 3
55670: MINUS
55671: PUSH
55672: LD_INT 3
55674: PUSH
55675: EMPTY
55676: LIST
55677: LIST
55678: LIST
55679: PUSH
55680: LD_VAR 0 1
55684: PUSH
55685: LD_INT 4
55687: MINUS
55688: PUSH
55689: LD_VAR 0 2
55693: PUSH
55694: LD_INT 4
55696: MINUS
55697: PUSH
55698: LD_INT 2
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: LIST
55705: PUSH
55706: EMPTY
55707: LIST
55708: LIST
55709: LIST
55710: LIST
55711: LIST
55712: ST_TO_ADDR
// end ; 5 :
55713: GO 55853
55715: LD_INT 5
55717: DOUBLE
55718: EQUAL
55719: IFTRUE 55723
55721: GO 55852
55723: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55724: LD_ADDR_VAR 0 5
55728: PUSH
55729: LD_VAR 0 1
55733: PUSH
55734: LD_INT 4
55736: MINUS
55737: PUSH
55738: LD_VAR 0 2
55742: PUSH
55743: LD_INT 1
55745: PUSH
55746: EMPTY
55747: LIST
55748: LIST
55749: LIST
55750: PUSH
55751: LD_VAR 0 1
55755: PUSH
55756: LD_VAR 0 2
55760: PUSH
55761: LD_INT 4
55763: MINUS
55764: PUSH
55765: LD_INT 3
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: LIST
55772: PUSH
55773: LD_VAR 0 1
55777: PUSH
55778: LD_INT 4
55780: PLUS
55781: PUSH
55782: LD_VAR 0 2
55786: PUSH
55787: LD_INT 4
55789: PLUS
55790: PUSH
55791: LD_INT 5
55793: PUSH
55794: EMPTY
55795: LIST
55796: LIST
55797: LIST
55798: PUSH
55799: LD_VAR 0 1
55803: PUSH
55804: LD_INT 3
55806: PLUS
55807: PUSH
55808: LD_VAR 0 2
55812: PUSH
55813: LD_INT 4
55815: PUSH
55816: EMPTY
55817: LIST
55818: LIST
55819: LIST
55820: PUSH
55821: LD_VAR 0 1
55825: PUSH
55826: LD_VAR 0 2
55830: PUSH
55831: LD_INT 3
55833: PLUS
55834: PUSH
55835: LD_INT 0
55837: PUSH
55838: EMPTY
55839: LIST
55840: LIST
55841: LIST
55842: PUSH
55843: EMPTY
55844: LIST
55845: LIST
55846: LIST
55847: LIST
55848: LIST
55849: ST_TO_ADDR
// end ; end ;
55850: GO 55853
55852: POP
// result := list ;
55853: LD_ADDR_VAR 0 4
55857: PUSH
55858: LD_VAR 0 5
55862: ST_TO_ADDR
// end ;
55863: LD_VAR 0 4
55867: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55868: LD_INT 0
55870: PPUSH
55871: PPUSH
55872: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55873: LD_VAR 0 1
55877: NOT
55878: PUSH
55879: LD_VAR 0 2
55883: PUSH
55884: LD_INT 1
55886: PUSH
55887: LD_INT 2
55889: PUSH
55890: LD_INT 3
55892: PUSH
55893: LD_INT 4
55895: PUSH
55896: EMPTY
55897: LIST
55898: LIST
55899: LIST
55900: LIST
55901: IN
55902: NOT
55903: OR
55904: IFFALSE 55908
// exit ;
55906: GO 55991
// tmp := [ ] ;
55908: LD_ADDR_VAR 0 5
55912: PUSH
55913: EMPTY
55914: ST_TO_ADDR
// for i in units do
55915: LD_ADDR_VAR 0 4
55919: PUSH
55920: LD_VAR 0 1
55924: PUSH
55925: FOR_IN
55926: IFFALSE 55960
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
55928: LD_ADDR_VAR 0 5
55932: PUSH
55933: LD_VAR 0 5
55937: PPUSH
55938: LD_VAR 0 4
55942: PPUSH
55943: LD_VAR 0 2
55947: PPUSH
55948: CALL_OW 259
55952: PPUSH
55953: CALL 57352 0 2
55957: ST_TO_ADDR
55958: GO 55925
55960: POP
55961: POP
// if not tmp then
55962: LD_VAR 0 5
55966: NOT
55967: IFFALSE 55971
// exit ;
55969: GO 55991
// result := SortListByListDesc ( units , tmp ) ;
55971: LD_ADDR_VAR 0 3
55975: PUSH
55976: LD_VAR 0 1
55980: PPUSH
55981: LD_VAR 0 5
55985: PPUSH
55986: CALL_OW 77
55990: ST_TO_ADDR
// end ;
55991: LD_VAR 0 3
55995: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55996: LD_INT 0
55998: PPUSH
55999: PPUSH
56000: PPUSH
// result := false ;
56001: LD_ADDR_VAR 0 3
56005: PUSH
56006: LD_INT 0
56008: ST_TO_ADDR
// if not building then
56009: LD_VAR 0 2
56013: NOT
56014: IFFALSE 56018
// exit ;
56016: GO 56156
// x := GetX ( building ) ;
56018: LD_ADDR_VAR 0 4
56022: PUSH
56023: LD_VAR 0 2
56027: PPUSH
56028: CALL_OW 250
56032: ST_TO_ADDR
// y := GetY ( building ) ;
56033: LD_ADDR_VAR 0 5
56037: PUSH
56038: LD_VAR 0 2
56042: PPUSH
56043: CALL_OW 251
56047: ST_TO_ADDR
// if not x or not y then
56048: LD_VAR 0 4
56052: NOT
56053: PUSH
56054: LD_VAR 0 5
56058: NOT
56059: OR
56060: IFFALSE 56064
// exit ;
56062: GO 56156
// if GetTaskList ( unit ) then
56064: LD_VAR 0 1
56068: PPUSH
56069: CALL_OW 437
56073: IFFALSE 56156
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56075: LD_STRING e
56077: PUSH
56078: LD_VAR 0 1
56082: PPUSH
56083: CALL_OW 437
56087: PUSH
56088: LD_INT 1
56090: ARRAY
56091: PUSH
56092: LD_INT 1
56094: ARRAY
56095: EQUAL
56096: PUSH
56097: LD_VAR 0 4
56101: PUSH
56102: LD_VAR 0 1
56106: PPUSH
56107: CALL_OW 437
56111: PUSH
56112: LD_INT 1
56114: ARRAY
56115: PUSH
56116: LD_INT 2
56118: ARRAY
56119: EQUAL
56120: AND
56121: PUSH
56122: LD_VAR 0 5
56126: PUSH
56127: LD_VAR 0 1
56131: PPUSH
56132: CALL_OW 437
56136: PUSH
56137: LD_INT 1
56139: ARRAY
56140: PUSH
56141: LD_INT 3
56143: ARRAY
56144: EQUAL
56145: AND
56146: IFFALSE 56156
// result := true end ;
56148: LD_ADDR_VAR 0 3
56152: PUSH
56153: LD_INT 1
56155: ST_TO_ADDR
// end ;
56156: LD_VAR 0 3
56160: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56161: LD_INT 0
56163: PPUSH
// result := false ;
56164: LD_ADDR_VAR 0 4
56168: PUSH
56169: LD_INT 0
56171: ST_TO_ADDR
// if GetTaskList ( unit ) then
56172: LD_VAR 0 1
56176: PPUSH
56177: CALL_OW 437
56181: IFFALSE 56264
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56183: LD_STRING M
56185: PUSH
56186: LD_VAR 0 1
56190: PPUSH
56191: CALL_OW 437
56195: PUSH
56196: LD_INT 1
56198: ARRAY
56199: PUSH
56200: LD_INT 1
56202: ARRAY
56203: EQUAL
56204: PUSH
56205: LD_VAR 0 2
56209: PUSH
56210: LD_VAR 0 1
56214: PPUSH
56215: CALL_OW 437
56219: PUSH
56220: LD_INT 1
56222: ARRAY
56223: PUSH
56224: LD_INT 2
56226: ARRAY
56227: EQUAL
56228: AND
56229: PUSH
56230: LD_VAR 0 3
56234: PUSH
56235: LD_VAR 0 1
56239: PPUSH
56240: CALL_OW 437
56244: PUSH
56245: LD_INT 1
56247: ARRAY
56248: PUSH
56249: LD_INT 3
56251: ARRAY
56252: EQUAL
56253: AND
56254: IFFALSE 56264
// result := true ;
56256: LD_ADDR_VAR 0 4
56260: PUSH
56261: LD_INT 1
56263: ST_TO_ADDR
// end ; end ;
56264: LD_VAR 0 4
56268: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56269: LD_INT 0
56271: PPUSH
56272: PPUSH
56273: PPUSH
56274: PPUSH
// if not unit or not area then
56275: LD_VAR 0 1
56279: NOT
56280: PUSH
56281: LD_VAR 0 2
56285: NOT
56286: OR
56287: IFFALSE 56291
// exit ;
56289: GO 56455
// tmp := AreaToList ( area , i ) ;
56291: LD_ADDR_VAR 0 6
56295: PUSH
56296: LD_VAR 0 2
56300: PPUSH
56301: LD_VAR 0 5
56305: PPUSH
56306: CALL_OW 517
56310: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56311: LD_ADDR_VAR 0 5
56315: PUSH
56316: DOUBLE
56317: LD_INT 1
56319: DEC
56320: ST_TO_ADDR
56321: LD_VAR 0 6
56325: PUSH
56326: LD_INT 1
56328: ARRAY
56329: PUSH
56330: FOR_TO
56331: IFFALSE 56453
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56333: LD_ADDR_VAR 0 7
56337: PUSH
56338: LD_VAR 0 6
56342: PUSH
56343: LD_INT 1
56345: ARRAY
56346: PUSH
56347: LD_VAR 0 5
56351: ARRAY
56352: PUSH
56353: LD_VAR 0 6
56357: PUSH
56358: LD_INT 2
56360: ARRAY
56361: PUSH
56362: LD_VAR 0 5
56366: ARRAY
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56372: LD_VAR 0 7
56376: PUSH
56377: LD_INT 1
56379: ARRAY
56380: PPUSH
56381: LD_VAR 0 7
56385: PUSH
56386: LD_INT 2
56388: ARRAY
56389: PPUSH
56390: CALL_OW 428
56394: PUSH
56395: LD_INT 0
56397: EQUAL
56398: IFFALSE 56451
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56400: LD_VAR 0 1
56404: PPUSH
56405: LD_VAR 0 7
56409: PUSH
56410: LD_INT 1
56412: ARRAY
56413: PPUSH
56414: LD_VAR 0 7
56418: PUSH
56419: LD_INT 2
56421: ARRAY
56422: PPUSH
56423: LD_VAR 0 3
56427: PPUSH
56428: CALL_OW 48
// result := IsPlaced ( unit ) ;
56432: LD_ADDR_VAR 0 4
56436: PUSH
56437: LD_VAR 0 1
56441: PPUSH
56442: CALL_OW 305
56446: ST_TO_ADDR
// exit ;
56447: POP
56448: POP
56449: GO 56455
// end ; end ;
56451: GO 56330
56453: POP
56454: POP
// end ;
56455: LD_VAR 0 4
56459: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56460: LD_INT 0
56462: PPUSH
56463: PPUSH
56464: PPUSH
// if not side or side > 8 then
56465: LD_VAR 0 1
56469: NOT
56470: PUSH
56471: LD_VAR 0 1
56475: PUSH
56476: LD_INT 8
56478: GREATER
56479: OR
56480: IFFALSE 56484
// exit ;
56482: GO 56671
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56484: LD_ADDR_VAR 0 4
56488: PUSH
56489: LD_INT 22
56491: PUSH
56492: LD_VAR 0 1
56496: PUSH
56497: EMPTY
56498: LIST
56499: LIST
56500: PUSH
56501: LD_INT 21
56503: PUSH
56504: LD_INT 3
56506: PUSH
56507: EMPTY
56508: LIST
56509: LIST
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: PPUSH
56515: CALL_OW 69
56519: ST_TO_ADDR
// if not tmp then
56520: LD_VAR 0 4
56524: NOT
56525: IFFALSE 56529
// exit ;
56527: GO 56671
// enable_addtolog := true ;
56529: LD_ADDR_OWVAR 81
56533: PUSH
56534: LD_INT 1
56536: ST_TO_ADDR
// AddToLog ( [ ) ;
56537: LD_STRING [
56539: PPUSH
56540: CALL_OW 561
// for i in tmp do
56544: LD_ADDR_VAR 0 3
56548: PUSH
56549: LD_VAR 0 4
56553: PUSH
56554: FOR_IN
56555: IFFALSE 56662
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56557: LD_STRING [
56559: PUSH
56560: LD_VAR 0 3
56564: PPUSH
56565: CALL_OW 266
56569: STR
56570: PUSH
56571: LD_STRING , 
56573: STR
56574: PUSH
56575: LD_VAR 0 3
56579: PPUSH
56580: CALL_OW 250
56584: STR
56585: PUSH
56586: LD_STRING , 
56588: STR
56589: PUSH
56590: LD_VAR 0 3
56594: PPUSH
56595: CALL_OW 251
56599: STR
56600: PUSH
56601: LD_STRING , 
56603: STR
56604: PUSH
56605: LD_VAR 0 3
56609: PPUSH
56610: CALL_OW 254
56614: STR
56615: PUSH
56616: LD_STRING , 
56618: STR
56619: PUSH
56620: LD_VAR 0 3
56624: PPUSH
56625: LD_INT 1
56627: PPUSH
56628: CALL_OW 268
56632: STR
56633: PUSH
56634: LD_STRING , 
56636: STR
56637: PUSH
56638: LD_VAR 0 3
56642: PPUSH
56643: LD_INT 2
56645: PPUSH
56646: CALL_OW 268
56650: STR
56651: PUSH
56652: LD_STRING ],
56654: STR
56655: PPUSH
56656: CALL_OW 561
// end ;
56660: GO 56554
56662: POP
56663: POP
// AddToLog ( ]; ) ;
56664: LD_STRING ];
56666: PPUSH
56667: CALL_OW 561
// end ;
56671: LD_VAR 0 2
56675: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56676: LD_INT 0
56678: PPUSH
56679: PPUSH
56680: PPUSH
56681: PPUSH
56682: PPUSH
// if not area or not rate or not max then
56683: LD_VAR 0 1
56687: NOT
56688: PUSH
56689: LD_VAR 0 2
56693: NOT
56694: OR
56695: PUSH
56696: LD_VAR 0 4
56700: NOT
56701: OR
56702: IFFALSE 56706
// exit ;
56704: GO 56895
// while 1 do
56706: LD_INT 1
56708: IFFALSE 56895
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56710: LD_ADDR_VAR 0 9
56714: PUSH
56715: LD_VAR 0 1
56719: PPUSH
56720: LD_INT 1
56722: PPUSH
56723: CALL_OW 287
56727: PUSH
56728: LD_INT 10
56730: MUL
56731: ST_TO_ADDR
// r := rate / 10 ;
56732: LD_ADDR_VAR 0 7
56736: PUSH
56737: LD_VAR 0 2
56741: PUSH
56742: LD_INT 10
56744: DIVREAL
56745: ST_TO_ADDR
// time := 1 1$00 ;
56746: LD_ADDR_VAR 0 8
56750: PUSH
56751: LD_INT 2100
56753: ST_TO_ADDR
// if amount < min then
56754: LD_VAR 0 9
56758: PUSH
56759: LD_VAR 0 3
56763: LESS
56764: IFFALSE 56782
// r := r * 2 else
56766: LD_ADDR_VAR 0 7
56770: PUSH
56771: LD_VAR 0 7
56775: PUSH
56776: LD_INT 2
56778: MUL
56779: ST_TO_ADDR
56780: GO 56808
// if amount > max then
56782: LD_VAR 0 9
56786: PUSH
56787: LD_VAR 0 4
56791: GREATER
56792: IFFALSE 56808
// r := r / 2 ;
56794: LD_ADDR_VAR 0 7
56798: PUSH
56799: LD_VAR 0 7
56803: PUSH
56804: LD_INT 2
56806: DIVREAL
56807: ST_TO_ADDR
// time := time / r ;
56808: LD_ADDR_VAR 0 8
56812: PUSH
56813: LD_VAR 0 8
56817: PUSH
56818: LD_VAR 0 7
56822: DIVREAL
56823: ST_TO_ADDR
// if time < 0 then
56824: LD_VAR 0 8
56828: PUSH
56829: LD_INT 0
56831: LESS
56832: IFFALSE 56849
// time := time * - 1 ;
56834: LD_ADDR_VAR 0 8
56838: PUSH
56839: LD_VAR 0 8
56843: PUSH
56844: LD_INT 1
56846: NEG
56847: MUL
56848: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56849: LD_VAR 0 8
56853: PUSH
56854: LD_INT 35
56856: PPUSH
56857: LD_INT 875
56859: PPUSH
56860: CALL_OW 12
56864: PLUS
56865: PPUSH
56866: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56870: LD_INT 1
56872: PPUSH
56873: LD_INT 5
56875: PPUSH
56876: CALL_OW 12
56880: PPUSH
56881: LD_VAR 0 1
56885: PPUSH
56886: LD_INT 1
56888: PPUSH
56889: CALL_OW 55
// end ;
56893: GO 56706
// end ;
56895: LD_VAR 0 5
56899: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56900: LD_INT 0
56902: PPUSH
56903: PPUSH
56904: PPUSH
56905: PPUSH
56906: PPUSH
56907: PPUSH
56908: PPUSH
56909: PPUSH
// if not turrets or not factories then
56910: LD_VAR 0 1
56914: NOT
56915: PUSH
56916: LD_VAR 0 2
56920: NOT
56921: OR
56922: IFFALSE 56926
// exit ;
56924: GO 57233
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56926: LD_ADDR_VAR 0 10
56930: PUSH
56931: LD_INT 5
56933: PUSH
56934: LD_INT 6
56936: PUSH
56937: EMPTY
56938: LIST
56939: LIST
56940: PUSH
56941: LD_INT 2
56943: PUSH
56944: LD_INT 4
56946: PUSH
56947: EMPTY
56948: LIST
56949: LIST
56950: PUSH
56951: LD_INT 3
56953: PUSH
56954: LD_INT 5
56956: PUSH
56957: EMPTY
56958: LIST
56959: LIST
56960: PUSH
56961: EMPTY
56962: LIST
56963: LIST
56964: LIST
56965: PUSH
56966: LD_INT 24
56968: PUSH
56969: LD_INT 25
56971: PUSH
56972: EMPTY
56973: LIST
56974: LIST
56975: PUSH
56976: LD_INT 23
56978: PUSH
56979: LD_INT 27
56981: PUSH
56982: EMPTY
56983: LIST
56984: LIST
56985: PUSH
56986: EMPTY
56987: LIST
56988: LIST
56989: PUSH
56990: LD_INT 42
56992: PUSH
56993: LD_INT 43
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: PUSH
57000: LD_INT 44
57002: PUSH
57003: LD_INT 46
57005: PUSH
57006: EMPTY
57007: LIST
57008: LIST
57009: PUSH
57010: LD_INT 45
57012: PUSH
57013: LD_INT 47
57015: PUSH
57016: EMPTY
57017: LIST
57018: LIST
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: LIST
57024: PUSH
57025: EMPTY
57026: LIST
57027: LIST
57028: LIST
57029: ST_TO_ADDR
// result := [ ] ;
57030: LD_ADDR_VAR 0 3
57034: PUSH
57035: EMPTY
57036: ST_TO_ADDR
// for i in turrets do
57037: LD_ADDR_VAR 0 4
57041: PUSH
57042: LD_VAR 0 1
57046: PUSH
57047: FOR_IN
57048: IFFALSE 57231
// begin nat := GetNation ( i ) ;
57050: LD_ADDR_VAR 0 7
57054: PUSH
57055: LD_VAR 0 4
57059: PPUSH
57060: CALL_OW 248
57064: ST_TO_ADDR
// weapon := 0 ;
57065: LD_ADDR_VAR 0 8
57069: PUSH
57070: LD_INT 0
57072: ST_TO_ADDR
// if not nat then
57073: LD_VAR 0 7
57077: NOT
57078: IFFALSE 57082
// continue ;
57080: GO 57047
// for j in list [ nat ] do
57082: LD_ADDR_VAR 0 5
57086: PUSH
57087: LD_VAR 0 10
57091: PUSH
57092: LD_VAR 0 7
57096: ARRAY
57097: PUSH
57098: FOR_IN
57099: IFFALSE 57140
// if GetBWeapon ( i ) = j [ 1 ] then
57101: LD_VAR 0 4
57105: PPUSH
57106: CALL_OW 269
57110: PUSH
57111: LD_VAR 0 5
57115: PUSH
57116: LD_INT 1
57118: ARRAY
57119: EQUAL
57120: IFFALSE 57138
// begin weapon := j [ 2 ] ;
57122: LD_ADDR_VAR 0 8
57126: PUSH
57127: LD_VAR 0 5
57131: PUSH
57132: LD_INT 2
57134: ARRAY
57135: ST_TO_ADDR
// break ;
57136: GO 57140
// end ;
57138: GO 57098
57140: POP
57141: POP
// if not weapon then
57142: LD_VAR 0 8
57146: NOT
57147: IFFALSE 57151
// continue ;
57149: GO 57047
// for k in factories do
57151: LD_ADDR_VAR 0 6
57155: PUSH
57156: LD_VAR 0 2
57160: PUSH
57161: FOR_IN
57162: IFFALSE 57227
// begin weapons := AvailableWeaponList ( k ) ;
57164: LD_ADDR_VAR 0 9
57168: PUSH
57169: LD_VAR 0 6
57173: PPUSH
57174: CALL_OW 478
57178: ST_TO_ADDR
// if not weapons then
57179: LD_VAR 0 9
57183: NOT
57184: IFFALSE 57188
// continue ;
57186: GO 57161
// if weapon in weapons then
57188: LD_VAR 0 8
57192: PUSH
57193: LD_VAR 0 9
57197: IN
57198: IFFALSE 57225
// begin result := [ i , weapon ] ;
57200: LD_ADDR_VAR 0 3
57204: PUSH
57205: LD_VAR 0 4
57209: PUSH
57210: LD_VAR 0 8
57214: PUSH
57215: EMPTY
57216: LIST
57217: LIST
57218: ST_TO_ADDR
// exit ;
57219: POP
57220: POP
57221: POP
57222: POP
57223: GO 57233
// end ; end ;
57225: GO 57161
57227: POP
57228: POP
// end ;
57229: GO 57047
57231: POP
57232: POP
// end ;
57233: LD_VAR 0 3
57237: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57238: LD_INT 0
57240: PPUSH
// if not side or side > 8 then
57241: LD_VAR 0 3
57245: NOT
57246: PUSH
57247: LD_VAR 0 3
57251: PUSH
57252: LD_INT 8
57254: GREATER
57255: OR
57256: IFFALSE 57260
// exit ;
57258: GO 57319
// if not range then
57260: LD_VAR 0 4
57264: NOT
57265: IFFALSE 57276
// range := - 12 ;
57267: LD_ADDR_VAR 0 4
57271: PUSH
57272: LD_INT 12
57274: NEG
57275: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57276: LD_VAR 0 1
57280: PPUSH
57281: LD_VAR 0 2
57285: PPUSH
57286: LD_VAR 0 3
57290: PPUSH
57291: LD_VAR 0 4
57295: PPUSH
57296: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57300: LD_VAR 0 1
57304: PPUSH
57305: LD_VAR 0 2
57309: PPUSH
57310: LD_VAR 0 3
57314: PPUSH
57315: CALL_OW 331
// end ;
57319: LD_VAR 0 5
57323: RET
// export function Video ( mode ) ; begin
57324: LD_INT 0
57326: PPUSH
// ingame_video = mode ;
57327: LD_ADDR_OWVAR 52
57331: PUSH
57332: LD_VAR 0 1
57336: ST_TO_ADDR
// interface_hidden = mode ;
57337: LD_ADDR_OWVAR 54
57341: PUSH
57342: LD_VAR 0 1
57346: ST_TO_ADDR
// end ;
57347: LD_VAR 0 2
57351: RET
// export function Join ( array , element ) ; begin
57352: LD_INT 0
57354: PPUSH
// result := Replace ( array , array + 1 , element ) ;
57355: LD_ADDR_VAR 0 3
57359: PUSH
57360: LD_VAR 0 1
57364: PPUSH
57365: LD_VAR 0 1
57369: PUSH
57370: LD_INT 1
57372: PLUS
57373: PPUSH
57374: LD_VAR 0 2
57378: PPUSH
57379: CALL_OW 1
57383: ST_TO_ADDR
// end ;
57384: LD_VAR 0 3
57388: RET
// export function JoinUnion ( array , element ) ; begin
57389: LD_INT 0
57391: PPUSH
// result := array union element ;
57392: LD_ADDR_VAR 0 3
57396: PUSH
57397: LD_VAR 0 1
57401: PUSH
57402: LD_VAR 0 2
57406: UNION
57407: ST_TO_ADDR
// end ;
57408: LD_VAR 0 3
57412: RET
// export function GetBehemoths ( side ) ; begin
57413: LD_INT 0
57415: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
57416: LD_ADDR_VAR 0 2
57420: PUSH
57421: LD_INT 22
57423: PUSH
57424: LD_VAR 0 1
57428: PUSH
57429: EMPTY
57430: LIST
57431: LIST
57432: PUSH
57433: LD_INT 31
57435: PUSH
57436: LD_INT 25
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: PUSH
57443: EMPTY
57444: LIST
57445: LIST
57446: PPUSH
57447: CALL_OW 69
57451: ST_TO_ADDR
// end ;
57452: LD_VAR 0 2
57456: RET
// export function Shuffle ( array ) ; var i , index ; begin
57457: LD_INT 0
57459: PPUSH
57460: PPUSH
57461: PPUSH
// result := [ ] ;
57462: LD_ADDR_VAR 0 2
57466: PUSH
57467: EMPTY
57468: ST_TO_ADDR
// if not array then
57469: LD_VAR 0 1
57473: NOT
57474: IFFALSE 57478
// exit ;
57476: GO 57577
// Randomize ;
57478: CALL_OW 10
// for i = array downto 1 do
57482: LD_ADDR_VAR 0 3
57486: PUSH
57487: DOUBLE
57488: LD_VAR 0 1
57492: INC
57493: ST_TO_ADDR
57494: LD_INT 1
57496: PUSH
57497: FOR_DOWNTO
57498: IFFALSE 57575
// begin index := rand ( 1 , array ) ;
57500: LD_ADDR_VAR 0 4
57504: PUSH
57505: LD_INT 1
57507: PPUSH
57508: LD_VAR 0 1
57512: PPUSH
57513: CALL_OW 12
57517: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57518: LD_ADDR_VAR 0 2
57522: PUSH
57523: LD_VAR 0 2
57527: PPUSH
57528: LD_VAR 0 2
57532: PUSH
57533: LD_INT 1
57535: PLUS
57536: PPUSH
57537: LD_VAR 0 1
57541: PUSH
57542: LD_VAR 0 4
57546: ARRAY
57547: PPUSH
57548: CALL_OW 2
57552: ST_TO_ADDR
// array := Delete ( array , index ) ;
57553: LD_ADDR_VAR 0 1
57557: PUSH
57558: LD_VAR 0 1
57562: PPUSH
57563: LD_VAR 0 4
57567: PPUSH
57568: CALL_OW 3
57572: ST_TO_ADDR
// end ;
57573: GO 57497
57575: POP
57576: POP
// end ;
57577: LD_VAR 0 2
57581: RET
// export function GetBaseMaterials ( base ) ; begin
57582: LD_INT 0
57584: PPUSH
// result := [ 0 , 0 , 0 ] ;
57585: LD_ADDR_VAR 0 2
57589: PUSH
57590: LD_INT 0
57592: PUSH
57593: LD_INT 0
57595: PUSH
57596: LD_INT 0
57598: PUSH
57599: EMPTY
57600: LIST
57601: LIST
57602: LIST
57603: ST_TO_ADDR
// if not base then
57604: LD_VAR 0 1
57608: NOT
57609: IFFALSE 57613
// exit ;
57611: GO 57662
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57613: LD_ADDR_VAR 0 2
57617: PUSH
57618: LD_VAR 0 1
57622: PPUSH
57623: LD_INT 1
57625: PPUSH
57626: CALL_OW 275
57630: PUSH
57631: LD_VAR 0 1
57635: PPUSH
57636: LD_INT 2
57638: PPUSH
57639: CALL_OW 275
57643: PUSH
57644: LD_VAR 0 1
57648: PPUSH
57649: LD_INT 3
57651: PPUSH
57652: CALL_OW 275
57656: PUSH
57657: EMPTY
57658: LIST
57659: LIST
57660: LIST
57661: ST_TO_ADDR
// end ;
57662: LD_VAR 0 2
57666: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57667: LD_INT 0
57669: PPUSH
57670: PPUSH
// result := array ;
57671: LD_ADDR_VAR 0 3
57675: PUSH
57676: LD_VAR 0 1
57680: ST_TO_ADDR
// if size >= result then
57681: LD_VAR 0 2
57685: PUSH
57686: LD_VAR 0 3
57690: GREATEREQUAL
57691: IFFALSE 57695
// exit ;
57693: GO 57745
// if size then
57695: LD_VAR 0 2
57699: IFFALSE 57745
// for i := array downto size do
57701: LD_ADDR_VAR 0 4
57705: PUSH
57706: DOUBLE
57707: LD_VAR 0 1
57711: INC
57712: ST_TO_ADDR
57713: LD_VAR 0 2
57717: PUSH
57718: FOR_DOWNTO
57719: IFFALSE 57743
// result := Delete ( result , result ) ;
57721: LD_ADDR_VAR 0 3
57725: PUSH
57726: LD_VAR 0 3
57730: PPUSH
57731: LD_VAR 0 3
57735: PPUSH
57736: CALL_OW 3
57740: ST_TO_ADDR
57741: GO 57718
57743: POP
57744: POP
// end ;
57745: LD_VAR 0 3
57749: RET
// export function ComExit ( unit ) ; var tmp ; begin
57750: LD_INT 0
57752: PPUSH
57753: PPUSH
// if not IsInUnit ( unit ) then
57754: LD_VAR 0 1
57758: PPUSH
57759: CALL_OW 310
57763: NOT
57764: IFFALSE 57768
// exit ;
57766: GO 57828
// tmp := IsInUnit ( unit ) ;
57768: LD_ADDR_VAR 0 3
57772: PUSH
57773: LD_VAR 0 1
57777: PPUSH
57778: CALL_OW 310
57782: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57783: LD_VAR 0 3
57787: PPUSH
57788: CALL_OW 247
57792: PUSH
57793: LD_INT 2
57795: EQUAL
57796: IFFALSE 57809
// ComExitVehicle ( unit ) else
57798: LD_VAR 0 1
57802: PPUSH
57803: CALL_OW 121
57807: GO 57818
// ComExitBuilding ( unit ) ;
57809: LD_VAR 0 1
57813: PPUSH
57814: CALL_OW 122
// result := tmp ;
57818: LD_ADDR_VAR 0 2
57822: PUSH
57823: LD_VAR 0 3
57827: ST_TO_ADDR
// end ;
57828: LD_VAR 0 2
57832: RET
// export function ComExitAll ( units ) ; var i ; begin
57833: LD_INT 0
57835: PPUSH
57836: PPUSH
// if not units then
57837: LD_VAR 0 1
57841: NOT
57842: IFFALSE 57846
// exit ;
57844: GO 57872
// for i in units do
57846: LD_ADDR_VAR 0 3
57850: PUSH
57851: LD_VAR 0 1
57855: PUSH
57856: FOR_IN
57857: IFFALSE 57870
// ComExit ( i ) ;
57859: LD_VAR 0 3
57863: PPUSH
57864: CALL 57750 0 1
57868: GO 57856
57870: POP
57871: POP
// end ;
57872: LD_VAR 0 2
57876: RET
// export function ResetHc ; begin
57877: LD_INT 0
57879: PPUSH
// InitHc ;
57880: CALL_OW 19
// hc_importance := 0 ;
57884: LD_ADDR_OWVAR 32
57888: PUSH
57889: LD_INT 0
57891: ST_TO_ADDR
// end ;
57892: LD_VAR 0 1
57896: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57897: LD_INT 0
57899: PPUSH
57900: PPUSH
57901: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57902: LD_ADDR_VAR 0 6
57906: PUSH
57907: LD_VAR 0 1
57911: PUSH
57912: LD_VAR 0 3
57916: PLUS
57917: PUSH
57918: LD_INT 2
57920: DIV
57921: ST_TO_ADDR
// if _x < 0 then
57922: LD_VAR 0 6
57926: PUSH
57927: LD_INT 0
57929: LESS
57930: IFFALSE 57947
// _x := _x * - 1 ;
57932: LD_ADDR_VAR 0 6
57936: PUSH
57937: LD_VAR 0 6
57941: PUSH
57942: LD_INT 1
57944: NEG
57945: MUL
57946: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57947: LD_ADDR_VAR 0 7
57951: PUSH
57952: LD_VAR 0 2
57956: PUSH
57957: LD_VAR 0 4
57961: PLUS
57962: PUSH
57963: LD_INT 2
57965: DIV
57966: ST_TO_ADDR
// if _y < 0 then
57967: LD_VAR 0 7
57971: PUSH
57972: LD_INT 0
57974: LESS
57975: IFFALSE 57992
// _y := _y * - 1 ;
57977: LD_ADDR_VAR 0 7
57981: PUSH
57982: LD_VAR 0 7
57986: PUSH
57987: LD_INT 1
57989: NEG
57990: MUL
57991: ST_TO_ADDR
// result := [ _x , _y ] ;
57992: LD_ADDR_VAR 0 5
57996: PUSH
57997: LD_VAR 0 6
58001: PUSH
58002: LD_VAR 0 7
58006: PUSH
58007: EMPTY
58008: LIST
58009: LIST
58010: ST_TO_ADDR
// end ;
58011: LD_VAR 0 5
58015: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
58016: LD_INT 0
58018: PPUSH
58019: PPUSH
58020: PPUSH
58021: PPUSH
// task := GetTaskList ( unit ) ;
58022: LD_ADDR_VAR 0 7
58026: PUSH
58027: LD_VAR 0 1
58031: PPUSH
58032: CALL_OW 437
58036: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
58037: LD_VAR 0 7
58041: NOT
58042: PUSH
58043: LD_VAR 0 1
58047: PPUSH
58048: LD_VAR 0 2
58052: PPUSH
58053: CALL_OW 308
58057: NOT
58058: AND
58059: IFFALSE 58063
// exit ;
58061: GO 58181
// if IsInArea ( unit , area ) then
58063: LD_VAR 0 1
58067: PPUSH
58068: LD_VAR 0 2
58072: PPUSH
58073: CALL_OW 308
58077: IFFALSE 58095
// begin ComMoveToArea ( unit , goAway ) ;
58079: LD_VAR 0 1
58083: PPUSH
58084: LD_VAR 0 3
58088: PPUSH
58089: CALL_OW 113
// exit ;
58093: GO 58181
// end ; if task [ 1 ] [ 1 ] <> M then
58095: LD_VAR 0 7
58099: PUSH
58100: LD_INT 1
58102: ARRAY
58103: PUSH
58104: LD_INT 1
58106: ARRAY
58107: PUSH
58108: LD_STRING M
58110: NONEQUAL
58111: IFFALSE 58115
// exit ;
58113: GO 58181
// x := task [ 1 ] [ 2 ] ;
58115: LD_ADDR_VAR 0 5
58119: PUSH
58120: LD_VAR 0 7
58124: PUSH
58125: LD_INT 1
58127: ARRAY
58128: PUSH
58129: LD_INT 2
58131: ARRAY
58132: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
58133: LD_ADDR_VAR 0 6
58137: PUSH
58138: LD_VAR 0 7
58142: PUSH
58143: LD_INT 1
58145: ARRAY
58146: PUSH
58147: LD_INT 3
58149: ARRAY
58150: ST_TO_ADDR
// if InArea ( x , y , area ) then
58151: LD_VAR 0 5
58155: PPUSH
58156: LD_VAR 0 6
58160: PPUSH
58161: LD_VAR 0 2
58165: PPUSH
58166: CALL_OW 309
58170: IFFALSE 58181
// ComStop ( unit ) ;
58172: LD_VAR 0 1
58176: PPUSH
58177: CALL_OW 141
// end ;
58181: LD_VAR 0 4
58185: RET
// export function Abs ( value ) ; begin
58186: LD_INT 0
58188: PPUSH
// result := value ;
58189: LD_ADDR_VAR 0 2
58193: PUSH
58194: LD_VAR 0 1
58198: ST_TO_ADDR
// if value < 0 then
58199: LD_VAR 0 1
58203: PUSH
58204: LD_INT 0
58206: LESS
58207: IFFALSE 58224
// result := value * - 1 ;
58209: LD_ADDR_VAR 0 2
58213: PUSH
58214: LD_VAR 0 1
58218: PUSH
58219: LD_INT 1
58221: NEG
58222: MUL
58223: ST_TO_ADDR
// end ;
58224: LD_VAR 0 2
58228: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58229: LD_INT 0
58231: PPUSH
58232: PPUSH
58233: PPUSH
58234: PPUSH
58235: PPUSH
58236: PPUSH
58237: PPUSH
58238: PPUSH
// if not unit or not building then
58239: LD_VAR 0 1
58243: NOT
58244: PUSH
58245: LD_VAR 0 2
58249: NOT
58250: OR
58251: IFFALSE 58255
// exit ;
58253: GO 58481
// x := GetX ( building ) ;
58255: LD_ADDR_VAR 0 4
58259: PUSH
58260: LD_VAR 0 2
58264: PPUSH
58265: CALL_OW 250
58269: ST_TO_ADDR
// y := GetY ( building ) ;
58270: LD_ADDR_VAR 0 6
58274: PUSH
58275: LD_VAR 0 2
58279: PPUSH
58280: CALL_OW 251
58284: ST_TO_ADDR
// d := GetDir ( building ) ;
58285: LD_ADDR_VAR 0 8
58289: PUSH
58290: LD_VAR 0 2
58294: PPUSH
58295: CALL_OW 254
58299: ST_TO_ADDR
// r := 4 ;
58300: LD_ADDR_VAR 0 9
58304: PUSH
58305: LD_INT 4
58307: ST_TO_ADDR
// for i := 1 to 5 do
58308: LD_ADDR_VAR 0 10
58312: PUSH
58313: DOUBLE
58314: LD_INT 1
58316: DEC
58317: ST_TO_ADDR
58318: LD_INT 5
58320: PUSH
58321: FOR_TO
58322: IFFALSE 58479
// begin _x := ShiftX ( x , d , r + i ) ;
58324: LD_ADDR_VAR 0 5
58328: PUSH
58329: LD_VAR 0 4
58333: PPUSH
58334: LD_VAR 0 8
58338: PPUSH
58339: LD_VAR 0 9
58343: PUSH
58344: LD_VAR 0 10
58348: PLUS
58349: PPUSH
58350: CALL_OW 272
58354: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
58355: LD_ADDR_VAR 0 7
58359: PUSH
58360: LD_VAR 0 6
58364: PPUSH
58365: LD_VAR 0 8
58369: PPUSH
58370: LD_VAR 0 9
58374: PUSH
58375: LD_VAR 0 10
58379: PLUS
58380: PPUSH
58381: CALL_OW 273
58385: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
58386: LD_VAR 0 5
58390: PPUSH
58391: LD_VAR 0 7
58395: PPUSH
58396: CALL_OW 488
58400: PUSH
58401: LD_VAR 0 5
58405: PPUSH
58406: LD_VAR 0 7
58410: PPUSH
58411: CALL_OW 428
58415: PPUSH
58416: CALL_OW 247
58420: PUSH
58421: LD_INT 3
58423: PUSH
58424: LD_INT 2
58426: PUSH
58427: EMPTY
58428: LIST
58429: LIST
58430: IN
58431: NOT
58432: AND
58433: IFFALSE 58477
// begin ComMoveXY ( unit , _x , _y ) ;
58435: LD_VAR 0 1
58439: PPUSH
58440: LD_VAR 0 5
58444: PPUSH
58445: LD_VAR 0 7
58449: PPUSH
58450: CALL_OW 111
// result := [ _x , _y ] ;
58454: LD_ADDR_VAR 0 3
58458: PUSH
58459: LD_VAR 0 5
58463: PUSH
58464: LD_VAR 0 7
58468: PUSH
58469: EMPTY
58470: LIST
58471: LIST
58472: ST_TO_ADDR
// exit ;
58473: POP
58474: POP
58475: GO 58481
// end ; end ;
58477: GO 58321
58479: POP
58480: POP
// end ;
58481: LD_VAR 0 3
58485: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
58486: LD_INT 0
58488: PPUSH
58489: PPUSH
58490: PPUSH
// result := 0 ;
58491: LD_ADDR_VAR 0 3
58495: PUSH
58496: LD_INT 0
58498: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
58499: LD_VAR 0 1
58503: PUSH
58504: LD_INT 0
58506: LESS
58507: PUSH
58508: LD_VAR 0 1
58512: PUSH
58513: LD_INT 8
58515: GREATER
58516: OR
58517: PUSH
58518: LD_VAR 0 2
58522: PUSH
58523: LD_INT 0
58525: LESS
58526: OR
58527: PUSH
58528: LD_VAR 0 2
58532: PUSH
58533: LD_INT 8
58535: GREATER
58536: OR
58537: IFFALSE 58541
// exit ;
58539: GO 58616
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
58541: LD_ADDR_VAR 0 4
58545: PUSH
58546: LD_INT 22
58548: PUSH
58549: LD_VAR 0 2
58553: PUSH
58554: EMPTY
58555: LIST
58556: LIST
58557: PPUSH
58558: CALL_OW 69
58562: PUSH
58563: FOR_IN
58564: IFFALSE 58614
// begin un := UnitShoot ( i ) ;
58566: LD_ADDR_VAR 0 5
58570: PUSH
58571: LD_VAR 0 4
58575: PPUSH
58576: CALL_OW 504
58580: ST_TO_ADDR
// if GetSide ( un ) = side1 then
58581: LD_VAR 0 5
58585: PPUSH
58586: CALL_OW 255
58590: PUSH
58591: LD_VAR 0 1
58595: EQUAL
58596: IFFALSE 58612
// begin result := un ;
58598: LD_ADDR_VAR 0 3
58602: PUSH
58603: LD_VAR 0 5
58607: ST_TO_ADDR
// exit ;
58608: POP
58609: POP
58610: GO 58616
// end ; end ;
58612: GO 58563
58614: POP
58615: POP
// end ;
58616: LD_VAR 0 3
58620: RET
// export function GetCargoBay ( units ) ; begin
58621: LD_INT 0
58623: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
58624: LD_ADDR_VAR 0 2
58628: PUSH
58629: LD_VAR 0 1
58633: PPUSH
58634: LD_INT 2
58636: PUSH
58637: LD_INT 34
58639: PUSH
58640: LD_INT 12
58642: PUSH
58643: EMPTY
58644: LIST
58645: LIST
58646: PUSH
58647: LD_INT 34
58649: PUSH
58650: LD_INT 51
58652: PUSH
58653: EMPTY
58654: LIST
58655: LIST
58656: PUSH
58657: LD_INT 34
58659: PUSH
58660: LD_INT 32
58662: PUSH
58663: EMPTY
58664: LIST
58665: LIST
58666: PUSH
58667: LD_INT 34
58669: PUSH
58670: LD_INT 89
58672: PUSH
58673: EMPTY
58674: LIST
58675: LIST
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: LIST
58681: LIST
58682: LIST
58683: PPUSH
58684: CALL_OW 72
58688: ST_TO_ADDR
// end ;
58689: LD_VAR 0 2
58693: RET
// export function Negate ( value ) ; begin
58694: LD_INT 0
58696: PPUSH
// result := not value ;
58697: LD_ADDR_VAR 0 2
58701: PUSH
58702: LD_VAR 0 1
58706: NOT
58707: ST_TO_ADDR
// end ;
58708: LD_VAR 0 2
58712: RET
// export function Inc ( value ) ; begin
58713: LD_INT 0
58715: PPUSH
// result := value + 1 ;
58716: LD_ADDR_VAR 0 2
58720: PUSH
58721: LD_VAR 0 1
58725: PUSH
58726: LD_INT 1
58728: PLUS
58729: ST_TO_ADDR
// end ;
58730: LD_VAR 0 2
58734: RET
// export function Dec ( value ) ; begin
58735: LD_INT 0
58737: PPUSH
// result := value - 1 ;
58738: LD_ADDR_VAR 0 2
58742: PUSH
58743: LD_VAR 0 1
58747: PUSH
58748: LD_INT 1
58750: MINUS
58751: ST_TO_ADDR
// end ;
58752: LD_VAR 0 2
58756: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58757: LD_INT 0
58759: PPUSH
58760: PPUSH
58761: PPUSH
58762: PPUSH
58763: PPUSH
58764: PPUSH
58765: PPUSH
58766: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58767: LD_VAR 0 1
58771: PPUSH
58772: LD_VAR 0 2
58776: PPUSH
58777: CALL_OW 488
58781: NOT
58782: PUSH
58783: LD_VAR 0 3
58787: PPUSH
58788: LD_VAR 0 4
58792: PPUSH
58793: CALL_OW 488
58797: NOT
58798: OR
58799: IFFALSE 58812
// begin result := - 1 ;
58801: LD_ADDR_VAR 0 5
58805: PUSH
58806: LD_INT 1
58808: NEG
58809: ST_TO_ADDR
// exit ;
58810: GO 59047
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58812: LD_ADDR_VAR 0 12
58816: PUSH
58817: LD_VAR 0 1
58821: PPUSH
58822: LD_VAR 0 2
58826: PPUSH
58827: LD_VAR 0 3
58831: PPUSH
58832: LD_VAR 0 4
58836: PPUSH
58837: CALL 57897 0 4
58841: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58842: LD_ADDR_VAR 0 11
58846: PUSH
58847: LD_VAR 0 1
58851: PPUSH
58852: LD_VAR 0 2
58856: PPUSH
58857: LD_VAR 0 12
58861: PUSH
58862: LD_INT 1
58864: ARRAY
58865: PPUSH
58866: LD_VAR 0 12
58870: PUSH
58871: LD_INT 2
58873: ARRAY
58874: PPUSH
58875: CALL_OW 298
58879: ST_TO_ADDR
// distance := 9999 ;
58880: LD_ADDR_VAR 0 10
58884: PUSH
58885: LD_INT 9999
58887: ST_TO_ADDR
// for i := 0 to 5 do
58888: LD_ADDR_VAR 0 6
58892: PUSH
58893: DOUBLE
58894: LD_INT 0
58896: DEC
58897: ST_TO_ADDR
58898: LD_INT 5
58900: PUSH
58901: FOR_TO
58902: IFFALSE 59045
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58904: LD_ADDR_VAR 0 7
58908: PUSH
58909: LD_VAR 0 1
58913: PPUSH
58914: LD_VAR 0 6
58918: PPUSH
58919: LD_VAR 0 11
58923: PPUSH
58924: CALL_OW 272
58928: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58929: LD_ADDR_VAR 0 8
58933: PUSH
58934: LD_VAR 0 2
58938: PPUSH
58939: LD_VAR 0 6
58943: PPUSH
58944: LD_VAR 0 11
58948: PPUSH
58949: CALL_OW 273
58953: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58954: LD_VAR 0 7
58958: PPUSH
58959: LD_VAR 0 8
58963: PPUSH
58964: CALL_OW 488
58968: NOT
58969: IFFALSE 58973
// continue ;
58971: GO 58901
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58973: LD_ADDR_VAR 0 9
58977: PUSH
58978: LD_VAR 0 12
58982: PUSH
58983: LD_INT 1
58985: ARRAY
58986: PPUSH
58987: LD_VAR 0 12
58991: PUSH
58992: LD_INT 2
58994: ARRAY
58995: PPUSH
58996: LD_VAR 0 7
59000: PPUSH
59001: LD_VAR 0 8
59005: PPUSH
59006: CALL_OW 298
59010: ST_TO_ADDR
// if tmp < distance then
59011: LD_VAR 0 9
59015: PUSH
59016: LD_VAR 0 10
59020: LESS
59021: IFFALSE 59043
// begin result := i ;
59023: LD_ADDR_VAR 0 5
59027: PUSH
59028: LD_VAR 0 6
59032: ST_TO_ADDR
// distance := tmp ;
59033: LD_ADDR_VAR 0 10
59037: PUSH
59038: LD_VAR 0 9
59042: ST_TO_ADDR
// end ; end ;
59043: GO 58901
59045: POP
59046: POP
// end ;
59047: LD_VAR 0 5
59051: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59052: LD_INT 0
59054: PPUSH
59055: PPUSH
// if not driver or not IsInUnit ( driver ) then
59056: LD_VAR 0 1
59060: NOT
59061: PUSH
59062: LD_VAR 0 1
59066: PPUSH
59067: CALL_OW 310
59071: NOT
59072: OR
59073: IFFALSE 59077
// exit ;
59075: GO 59167
// vehicle := IsInUnit ( driver ) ;
59077: LD_ADDR_VAR 0 3
59081: PUSH
59082: LD_VAR 0 1
59086: PPUSH
59087: CALL_OW 310
59091: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59092: LD_VAR 0 1
59096: PPUSH
59097: LD_STRING \
59099: PUSH
59100: LD_INT 0
59102: PUSH
59103: LD_INT 0
59105: PUSH
59106: LD_INT 0
59108: PUSH
59109: LD_INT 0
59111: PUSH
59112: LD_INT 0
59114: PUSH
59115: LD_INT 0
59117: PUSH
59118: EMPTY
59119: LIST
59120: LIST
59121: LIST
59122: LIST
59123: LIST
59124: LIST
59125: LIST
59126: PUSH
59127: LD_STRING E
59129: PUSH
59130: LD_INT 0
59132: PUSH
59133: LD_INT 0
59135: PUSH
59136: LD_VAR 0 3
59140: PUSH
59141: LD_INT 0
59143: PUSH
59144: LD_INT 0
59146: PUSH
59147: LD_INT 0
59149: PUSH
59150: EMPTY
59151: LIST
59152: LIST
59153: LIST
59154: LIST
59155: LIST
59156: LIST
59157: LIST
59158: PUSH
59159: EMPTY
59160: LIST
59161: LIST
59162: PPUSH
59163: CALL_OW 446
// end ;
59167: LD_VAR 0 2
59171: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59172: LD_INT 0
59174: PPUSH
59175: PPUSH
// if not driver or not IsInUnit ( driver ) then
59176: LD_VAR 0 1
59180: NOT
59181: PUSH
59182: LD_VAR 0 1
59186: PPUSH
59187: CALL_OW 310
59191: NOT
59192: OR
59193: IFFALSE 59197
// exit ;
59195: GO 59287
// vehicle := IsInUnit ( driver ) ;
59197: LD_ADDR_VAR 0 3
59201: PUSH
59202: LD_VAR 0 1
59206: PPUSH
59207: CALL_OW 310
59211: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59212: LD_VAR 0 1
59216: PPUSH
59217: LD_STRING \
59219: PUSH
59220: LD_INT 0
59222: PUSH
59223: LD_INT 0
59225: PUSH
59226: LD_INT 0
59228: PUSH
59229: LD_INT 0
59231: PUSH
59232: LD_INT 0
59234: PUSH
59235: LD_INT 0
59237: PUSH
59238: EMPTY
59239: LIST
59240: LIST
59241: LIST
59242: LIST
59243: LIST
59244: LIST
59245: LIST
59246: PUSH
59247: LD_STRING E
59249: PUSH
59250: LD_INT 0
59252: PUSH
59253: LD_INT 0
59255: PUSH
59256: LD_VAR 0 3
59260: PUSH
59261: LD_INT 0
59263: PUSH
59264: LD_INT 0
59266: PUSH
59267: LD_INT 0
59269: PUSH
59270: EMPTY
59271: LIST
59272: LIST
59273: LIST
59274: LIST
59275: LIST
59276: LIST
59277: LIST
59278: PUSH
59279: EMPTY
59280: LIST
59281: LIST
59282: PPUSH
59283: CALL_OW 447
// end ;
59287: LD_VAR 0 2
59291: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
59292: LD_INT 0
59294: PPUSH
59295: PPUSH
59296: PPUSH
// tmp := [ ] ;
59297: LD_ADDR_VAR 0 5
59301: PUSH
59302: EMPTY
59303: ST_TO_ADDR
// for i in units do
59304: LD_ADDR_VAR 0 4
59308: PUSH
59309: LD_VAR 0 1
59313: PUSH
59314: FOR_IN
59315: IFFALSE 59353
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
59317: LD_ADDR_VAR 0 5
59321: PUSH
59322: LD_VAR 0 5
59326: PPUSH
59327: LD_VAR 0 5
59331: PUSH
59332: LD_INT 1
59334: PLUS
59335: PPUSH
59336: LD_VAR 0 4
59340: PPUSH
59341: CALL_OW 256
59345: PPUSH
59346: CALL_OW 2
59350: ST_TO_ADDR
59351: GO 59314
59353: POP
59354: POP
// if not tmp then
59355: LD_VAR 0 5
59359: NOT
59360: IFFALSE 59364
// exit ;
59362: GO 59412
// if asc then
59364: LD_VAR 0 2
59368: IFFALSE 59392
// result := SortListByListAsc ( units , tmp ) else
59370: LD_ADDR_VAR 0 3
59374: PUSH
59375: LD_VAR 0 1
59379: PPUSH
59380: LD_VAR 0 5
59384: PPUSH
59385: CALL_OW 76
59389: ST_TO_ADDR
59390: GO 59412
// result := SortListByListDesc ( units , tmp ) ;
59392: LD_ADDR_VAR 0 3
59396: PUSH
59397: LD_VAR 0 1
59401: PPUSH
59402: LD_VAR 0 5
59406: PPUSH
59407: CALL_OW 77
59411: ST_TO_ADDR
// end ;
59412: LD_VAR 0 3
59416: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
59417: LD_INT 0
59419: PPUSH
59420: PPUSH
// task := GetTaskList ( mech ) ;
59421: LD_ADDR_VAR 0 4
59425: PUSH
59426: LD_VAR 0 1
59430: PPUSH
59431: CALL_OW 437
59435: ST_TO_ADDR
// if not task then
59436: LD_VAR 0 4
59440: NOT
59441: IFFALSE 59445
// exit ;
59443: GO 59487
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
59445: LD_ADDR_VAR 0 3
59449: PUSH
59450: LD_VAR 0 4
59454: PUSH
59455: LD_INT 1
59457: ARRAY
59458: PUSH
59459: LD_INT 1
59461: ARRAY
59462: PUSH
59463: LD_STRING r
59465: EQUAL
59466: PUSH
59467: LD_VAR 0 4
59471: PUSH
59472: LD_INT 1
59474: ARRAY
59475: PUSH
59476: LD_INT 4
59478: ARRAY
59479: PUSH
59480: LD_VAR 0 2
59484: EQUAL
59485: AND
59486: ST_TO_ADDR
// end ;
59487: LD_VAR 0 3
59491: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
59492: LD_INT 0
59494: PPUSH
// SetDir ( unit , d ) ;
59495: LD_VAR 0 1
59499: PPUSH
59500: LD_VAR 0 4
59504: PPUSH
59505: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
59509: LD_VAR 0 1
59513: PPUSH
59514: LD_VAR 0 2
59518: PPUSH
59519: LD_VAR 0 3
59523: PPUSH
59524: LD_VAR 0 5
59528: PPUSH
59529: CALL_OW 48
// end ;
59533: LD_VAR 0 6
59537: RET
// export function ToNaturalNumber ( number ) ; begin
59538: LD_INT 0
59540: PPUSH
// result := number div 1 ;
59541: LD_ADDR_VAR 0 2
59545: PUSH
59546: LD_VAR 0 1
59550: PUSH
59551: LD_INT 1
59553: DIV
59554: ST_TO_ADDR
// if number < 0 then
59555: LD_VAR 0 1
59559: PUSH
59560: LD_INT 0
59562: LESS
59563: IFFALSE 59573
// result := 0 ;
59565: LD_ADDR_VAR 0 2
59569: PUSH
59570: LD_INT 0
59572: ST_TO_ADDR
// end ;
59573: LD_VAR 0 2
59577: RET
// export function SortByClass ( units , class ) ; var un ; begin
59578: LD_INT 0
59580: PPUSH
59581: PPUSH
// if not units or not class then
59582: LD_VAR 0 1
59586: NOT
59587: PUSH
59588: LD_VAR 0 2
59592: NOT
59593: OR
59594: IFFALSE 59598
// exit ;
59596: GO 59693
// result := [ ] ;
59598: LD_ADDR_VAR 0 3
59602: PUSH
59603: EMPTY
59604: ST_TO_ADDR
// for un in units do
59605: LD_ADDR_VAR 0 4
59609: PUSH
59610: LD_VAR 0 1
59614: PUSH
59615: FOR_IN
59616: IFFALSE 59691
// if GetClass ( un ) = class then
59618: LD_VAR 0 4
59622: PPUSH
59623: CALL_OW 257
59627: PUSH
59628: LD_VAR 0 2
59632: EQUAL
59633: IFFALSE 59660
// result := Insert ( result , 1 , un ) else
59635: LD_ADDR_VAR 0 3
59639: PUSH
59640: LD_VAR 0 3
59644: PPUSH
59645: LD_INT 1
59647: PPUSH
59648: LD_VAR 0 4
59652: PPUSH
59653: CALL_OW 2
59657: ST_TO_ADDR
59658: GO 59689
// result := Replace ( result , result + 1 , un ) ;
59660: LD_ADDR_VAR 0 3
59664: PUSH
59665: LD_VAR 0 3
59669: PPUSH
59670: LD_VAR 0 3
59674: PUSH
59675: LD_INT 1
59677: PLUS
59678: PPUSH
59679: LD_VAR 0 4
59683: PPUSH
59684: CALL_OW 1
59688: ST_TO_ADDR
59689: GO 59615
59691: POP
59692: POP
// end ;
59693: LD_VAR 0 3
59697: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59698: LD_INT 0
59700: PPUSH
59701: PPUSH
59702: PPUSH
59703: PPUSH
59704: PPUSH
59705: PPUSH
59706: PPUSH
// result := [ ] ;
59707: LD_ADDR_VAR 0 4
59711: PUSH
59712: EMPTY
59713: ST_TO_ADDR
// if x - r < 0 then
59714: LD_VAR 0 1
59718: PUSH
59719: LD_VAR 0 3
59723: MINUS
59724: PUSH
59725: LD_INT 0
59727: LESS
59728: IFFALSE 59740
// min_x := 0 else
59730: LD_ADDR_VAR 0 8
59734: PUSH
59735: LD_INT 0
59737: ST_TO_ADDR
59738: GO 59756
// min_x := x - r ;
59740: LD_ADDR_VAR 0 8
59744: PUSH
59745: LD_VAR 0 1
59749: PUSH
59750: LD_VAR 0 3
59754: MINUS
59755: ST_TO_ADDR
// if y - r < 0 then
59756: LD_VAR 0 2
59760: PUSH
59761: LD_VAR 0 3
59765: MINUS
59766: PUSH
59767: LD_INT 0
59769: LESS
59770: IFFALSE 59782
// min_y := 0 else
59772: LD_ADDR_VAR 0 7
59776: PUSH
59777: LD_INT 0
59779: ST_TO_ADDR
59780: GO 59798
// min_y := y - r ;
59782: LD_ADDR_VAR 0 7
59786: PUSH
59787: LD_VAR 0 2
59791: PUSH
59792: LD_VAR 0 3
59796: MINUS
59797: ST_TO_ADDR
// max_x := x + r ;
59798: LD_ADDR_VAR 0 9
59802: PUSH
59803: LD_VAR 0 1
59807: PUSH
59808: LD_VAR 0 3
59812: PLUS
59813: ST_TO_ADDR
// max_y := y + r ;
59814: LD_ADDR_VAR 0 10
59818: PUSH
59819: LD_VAR 0 2
59823: PUSH
59824: LD_VAR 0 3
59828: PLUS
59829: ST_TO_ADDR
// for _x = min_x to max_x do
59830: LD_ADDR_VAR 0 5
59834: PUSH
59835: DOUBLE
59836: LD_VAR 0 8
59840: DEC
59841: ST_TO_ADDR
59842: LD_VAR 0 9
59846: PUSH
59847: FOR_TO
59848: IFFALSE 59949
// for _y = min_y to max_y do
59850: LD_ADDR_VAR 0 6
59854: PUSH
59855: DOUBLE
59856: LD_VAR 0 7
59860: DEC
59861: ST_TO_ADDR
59862: LD_VAR 0 10
59866: PUSH
59867: FOR_TO
59868: IFFALSE 59945
// begin if not ValidHex ( _x , _y ) then
59870: LD_VAR 0 5
59874: PPUSH
59875: LD_VAR 0 6
59879: PPUSH
59880: CALL_OW 488
59884: NOT
59885: IFFALSE 59889
// continue ;
59887: GO 59867
// if GetResourceTypeXY ( _x , _y ) then
59889: LD_VAR 0 5
59893: PPUSH
59894: LD_VAR 0 6
59898: PPUSH
59899: CALL_OW 283
59903: IFFALSE 59943
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59905: LD_ADDR_VAR 0 4
59909: PUSH
59910: LD_VAR 0 4
59914: PPUSH
59915: LD_VAR 0 4
59919: PUSH
59920: LD_INT 1
59922: PLUS
59923: PPUSH
59924: LD_VAR 0 5
59928: PUSH
59929: LD_VAR 0 6
59933: PUSH
59934: EMPTY
59935: LIST
59936: LIST
59937: PPUSH
59938: CALL_OW 1
59942: ST_TO_ADDR
// end ;
59943: GO 59867
59945: POP
59946: POP
59947: GO 59847
59949: POP
59950: POP
// end ;
59951: LD_VAR 0 4
59955: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59956: LD_INT 0
59958: PPUSH
59959: PPUSH
59960: PPUSH
59961: PPUSH
59962: PPUSH
59963: PPUSH
59964: PPUSH
59965: PPUSH
// if not units then
59966: LD_VAR 0 1
59970: NOT
59971: IFFALSE 59975
// exit ;
59973: GO 60499
// result := UnitFilter ( units , [ f_ok ] ) ;
59975: LD_ADDR_VAR 0 3
59979: PUSH
59980: LD_VAR 0 1
59984: PPUSH
59985: LD_INT 50
59987: PUSH
59988: EMPTY
59989: LIST
59990: PPUSH
59991: CALL_OW 72
59995: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59996: LD_ADDR_VAR 0 8
60000: PUSH
60001: LD_VAR 0 1
60005: PUSH
60006: LD_INT 1
60008: ARRAY
60009: PPUSH
60010: CALL_OW 255
60014: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
60015: LD_ADDR_VAR 0 10
60019: PUSH
60020: LD_INT 29
60022: PUSH
60023: LD_INT 91
60025: PUSH
60026: LD_INT 49
60028: PUSH
60029: EMPTY
60030: LIST
60031: LIST
60032: LIST
60033: ST_TO_ADDR
// if not result then
60034: LD_VAR 0 3
60038: NOT
60039: IFFALSE 60043
// exit ;
60041: GO 60499
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
60043: LD_ADDR_VAR 0 5
60047: PUSH
60048: LD_INT 81
60050: PUSH
60051: LD_VAR 0 8
60055: PUSH
60056: EMPTY
60057: LIST
60058: LIST
60059: PPUSH
60060: CALL_OW 69
60064: ST_TO_ADDR
// for i in result do
60065: LD_ADDR_VAR 0 4
60069: PUSH
60070: LD_VAR 0 3
60074: PUSH
60075: FOR_IN
60076: IFFALSE 60497
// begin tag := GetTag ( i ) + 1 ;
60078: LD_ADDR_VAR 0 9
60082: PUSH
60083: LD_VAR 0 4
60087: PPUSH
60088: CALL_OW 110
60092: PUSH
60093: LD_INT 1
60095: PLUS
60096: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
60097: LD_ADDR_VAR 0 7
60101: PUSH
60102: LD_VAR 0 4
60106: PPUSH
60107: CALL_OW 250
60111: PPUSH
60112: LD_VAR 0 4
60116: PPUSH
60117: CALL_OW 251
60121: PPUSH
60122: LD_INT 6
60124: PPUSH
60125: CALL 59698 0 3
60129: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
60130: LD_VAR 0 4
60134: PPUSH
60135: CALL_OW 247
60139: PUSH
60140: LD_INT 2
60142: EQUAL
60143: PUSH
60144: LD_VAR 0 7
60148: AND
60149: PUSH
60150: LD_VAR 0 4
60154: PPUSH
60155: CALL_OW 264
60159: PUSH
60160: LD_VAR 0 10
60164: IN
60165: NOT
60166: AND
60167: IFFALSE 60206
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
60169: LD_VAR 0 4
60173: PPUSH
60174: LD_VAR 0 7
60178: PUSH
60179: LD_INT 1
60181: ARRAY
60182: PUSH
60183: LD_INT 1
60185: ARRAY
60186: PPUSH
60187: LD_VAR 0 7
60191: PUSH
60192: LD_INT 1
60194: ARRAY
60195: PUSH
60196: LD_INT 2
60198: ARRAY
60199: PPUSH
60200: CALL_OW 116
60204: GO 60495
// if path > tag then
60206: LD_VAR 0 2
60210: PUSH
60211: LD_VAR 0 9
60215: GREATER
60216: IFFALSE 60424
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
60218: LD_ADDR_VAR 0 6
60222: PUSH
60223: LD_VAR 0 5
60227: PPUSH
60228: LD_INT 91
60230: PUSH
60231: LD_VAR 0 4
60235: PUSH
60236: LD_INT 8
60238: PUSH
60239: EMPTY
60240: LIST
60241: LIST
60242: LIST
60243: PPUSH
60244: CALL_OW 72
60248: ST_TO_ADDR
// if nearEnemy then
60249: LD_VAR 0 6
60253: IFFALSE 60322
// begin if GetWeapon ( i ) = ru_time_lapser then
60255: LD_VAR 0 4
60259: PPUSH
60260: CALL_OW 264
60264: PUSH
60265: LD_INT 49
60267: EQUAL
60268: IFFALSE 60296
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
60270: LD_VAR 0 4
60274: PPUSH
60275: LD_VAR 0 6
60279: PPUSH
60280: LD_VAR 0 4
60284: PPUSH
60285: CALL_OW 74
60289: PPUSH
60290: CALL_OW 112
60294: GO 60320
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
60296: LD_VAR 0 4
60300: PPUSH
60301: LD_VAR 0 6
60305: PPUSH
60306: LD_VAR 0 4
60310: PPUSH
60311: CALL_OW 74
60315: PPUSH
60316: CALL_OW 115
// end else
60320: GO 60422
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
60322: LD_VAR 0 4
60326: PPUSH
60327: LD_VAR 0 2
60331: PUSH
60332: LD_VAR 0 9
60336: ARRAY
60337: PUSH
60338: LD_INT 1
60340: ARRAY
60341: PPUSH
60342: LD_VAR 0 2
60346: PUSH
60347: LD_VAR 0 9
60351: ARRAY
60352: PUSH
60353: LD_INT 2
60355: ARRAY
60356: PPUSH
60357: CALL_OW 297
60361: PUSH
60362: LD_INT 6
60364: GREATER
60365: IFFALSE 60408
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
60367: LD_VAR 0 4
60371: PPUSH
60372: LD_VAR 0 2
60376: PUSH
60377: LD_VAR 0 9
60381: ARRAY
60382: PUSH
60383: LD_INT 1
60385: ARRAY
60386: PPUSH
60387: LD_VAR 0 2
60391: PUSH
60392: LD_VAR 0 9
60396: ARRAY
60397: PUSH
60398: LD_INT 2
60400: ARRAY
60401: PPUSH
60402: CALL_OW 114
60406: GO 60422
// SetTag ( i , tag ) ;
60408: LD_VAR 0 4
60412: PPUSH
60413: LD_VAR 0 9
60417: PPUSH
60418: CALL_OW 109
// end else
60422: GO 60495
// if enemy then
60424: LD_VAR 0 5
60428: IFFALSE 60495
// begin if GetWeapon ( i ) = ru_time_lapser then
60430: LD_VAR 0 4
60434: PPUSH
60435: CALL_OW 264
60439: PUSH
60440: LD_INT 49
60442: EQUAL
60443: IFFALSE 60471
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60445: LD_VAR 0 4
60449: PPUSH
60450: LD_VAR 0 5
60454: PPUSH
60455: LD_VAR 0 4
60459: PPUSH
60460: CALL_OW 74
60464: PPUSH
60465: CALL_OW 112
60469: GO 60495
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
60471: LD_VAR 0 4
60475: PPUSH
60476: LD_VAR 0 5
60480: PPUSH
60481: LD_VAR 0 4
60485: PPUSH
60486: CALL_OW 74
60490: PPUSH
60491: CALL_OW 115
// end ; end ;
60495: GO 60075
60497: POP
60498: POP
// end ;
60499: LD_VAR 0 3
60503: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
60504: LD_INT 0
60506: PPUSH
60507: PPUSH
60508: PPUSH
// if not unit or IsInUnit ( unit ) then
60509: LD_VAR 0 1
60513: NOT
60514: PUSH
60515: LD_VAR 0 1
60519: PPUSH
60520: CALL_OW 310
60524: OR
60525: IFFALSE 60529
// exit ;
60527: GO 60620
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
60529: LD_ADDR_VAR 0 4
60533: PUSH
60534: LD_VAR 0 1
60538: PPUSH
60539: CALL_OW 250
60543: PPUSH
60544: LD_VAR 0 2
60548: PPUSH
60549: LD_INT 1
60551: PPUSH
60552: CALL_OW 272
60556: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
60557: LD_ADDR_VAR 0 5
60561: PUSH
60562: LD_VAR 0 1
60566: PPUSH
60567: CALL_OW 251
60571: PPUSH
60572: LD_VAR 0 2
60576: PPUSH
60577: LD_INT 1
60579: PPUSH
60580: CALL_OW 273
60584: ST_TO_ADDR
// if ValidHex ( x , y ) then
60585: LD_VAR 0 4
60589: PPUSH
60590: LD_VAR 0 5
60594: PPUSH
60595: CALL_OW 488
60599: IFFALSE 60620
// ComTurnXY ( unit , x , y ) ;
60601: LD_VAR 0 1
60605: PPUSH
60606: LD_VAR 0 4
60610: PPUSH
60611: LD_VAR 0 5
60615: PPUSH
60616: CALL_OW 118
// end ;
60620: LD_VAR 0 3
60624: RET
// export function SeeUnits ( side , units ) ; var i ; begin
60625: LD_INT 0
60627: PPUSH
60628: PPUSH
// result := false ;
60629: LD_ADDR_VAR 0 3
60633: PUSH
60634: LD_INT 0
60636: ST_TO_ADDR
// if not units then
60637: LD_VAR 0 2
60641: NOT
60642: IFFALSE 60646
// exit ;
60644: GO 60691
// for i in units do
60646: LD_ADDR_VAR 0 4
60650: PUSH
60651: LD_VAR 0 2
60655: PUSH
60656: FOR_IN
60657: IFFALSE 60689
// if See ( side , i ) then
60659: LD_VAR 0 1
60663: PPUSH
60664: LD_VAR 0 4
60668: PPUSH
60669: CALL_OW 292
60673: IFFALSE 60687
// begin result := true ;
60675: LD_ADDR_VAR 0 3
60679: PUSH
60680: LD_INT 1
60682: ST_TO_ADDR
// exit ;
60683: POP
60684: POP
60685: GO 60691
// end ;
60687: GO 60656
60689: POP
60690: POP
// end ;
60691: LD_VAR 0 3
60695: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60696: LD_INT 0
60698: PPUSH
60699: PPUSH
60700: PPUSH
60701: PPUSH
// if not unit or not points then
60702: LD_VAR 0 1
60706: NOT
60707: PUSH
60708: LD_VAR 0 2
60712: NOT
60713: OR
60714: IFFALSE 60718
// exit ;
60716: GO 60808
// dist := 99999 ;
60718: LD_ADDR_VAR 0 5
60722: PUSH
60723: LD_INT 99999
60725: ST_TO_ADDR
// for i in points do
60726: LD_ADDR_VAR 0 4
60730: PUSH
60731: LD_VAR 0 2
60735: PUSH
60736: FOR_IN
60737: IFFALSE 60806
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60739: LD_ADDR_VAR 0 6
60743: PUSH
60744: LD_VAR 0 1
60748: PPUSH
60749: LD_VAR 0 4
60753: PUSH
60754: LD_INT 1
60756: ARRAY
60757: PPUSH
60758: LD_VAR 0 4
60762: PUSH
60763: LD_INT 2
60765: ARRAY
60766: PPUSH
60767: CALL_OW 297
60771: ST_TO_ADDR
// if tmpDist < dist then
60772: LD_VAR 0 6
60776: PUSH
60777: LD_VAR 0 5
60781: LESS
60782: IFFALSE 60804
// begin result := i ;
60784: LD_ADDR_VAR 0 3
60788: PUSH
60789: LD_VAR 0 4
60793: ST_TO_ADDR
// dist := tmpDist ;
60794: LD_ADDR_VAR 0 5
60798: PUSH
60799: LD_VAR 0 6
60803: ST_TO_ADDR
// end ; end ;
60804: GO 60736
60806: POP
60807: POP
// end ;
60808: LD_VAR 0 3
60812: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60813: LD_INT 0
60815: PPUSH
// uc_side := side ;
60816: LD_ADDR_OWVAR 20
60820: PUSH
60821: LD_VAR 0 1
60825: ST_TO_ADDR
// uc_nation := 3 ;
60826: LD_ADDR_OWVAR 21
60830: PUSH
60831: LD_INT 3
60833: ST_TO_ADDR
// vc_chassis := 25 ;
60834: LD_ADDR_OWVAR 37
60838: PUSH
60839: LD_INT 25
60841: ST_TO_ADDR
// vc_engine := engine_siberite ;
60842: LD_ADDR_OWVAR 39
60846: PUSH
60847: LD_INT 3
60849: ST_TO_ADDR
// vc_control := control_computer ;
60850: LD_ADDR_OWVAR 38
60854: PUSH
60855: LD_INT 3
60857: ST_TO_ADDR
// vc_weapon := 59 ;
60858: LD_ADDR_OWVAR 40
60862: PUSH
60863: LD_INT 59
60865: ST_TO_ADDR
// result := CreateVehicle ;
60866: LD_ADDR_VAR 0 5
60870: PUSH
60871: CALL_OW 45
60875: ST_TO_ADDR
// SetDir ( result , d ) ;
60876: LD_VAR 0 5
60880: PPUSH
60881: LD_VAR 0 4
60885: PPUSH
60886: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60890: LD_VAR 0 5
60894: PPUSH
60895: LD_VAR 0 2
60899: PPUSH
60900: LD_VAR 0 3
60904: PPUSH
60905: LD_INT 0
60907: PPUSH
60908: CALL_OW 48
// end ;
60912: LD_VAR 0 5
60916: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60917: LD_INT 0
60919: PPUSH
60920: PPUSH
60921: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60922: LD_ADDR_VAR 0 2
60926: PUSH
60927: LD_INT 0
60929: PUSH
60930: LD_INT 0
60932: PUSH
60933: LD_INT 0
60935: PUSH
60936: LD_INT 0
60938: PUSH
60939: EMPTY
60940: LIST
60941: LIST
60942: LIST
60943: LIST
60944: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60945: LD_VAR 0 1
60949: NOT
60950: PUSH
60951: LD_VAR 0 1
60955: PPUSH
60956: CALL_OW 264
60960: PUSH
60961: LD_INT 12
60963: PUSH
60964: LD_INT 51
60966: PUSH
60967: LD_INT 32
60969: PUSH
60970: LD_INT 89
60972: PUSH
60973: EMPTY
60974: LIST
60975: LIST
60976: LIST
60977: LIST
60978: IN
60979: NOT
60980: OR
60981: IFFALSE 60985
// exit ;
60983: GO 61083
// for i := 1 to 3 do
60985: LD_ADDR_VAR 0 3
60989: PUSH
60990: DOUBLE
60991: LD_INT 1
60993: DEC
60994: ST_TO_ADDR
60995: LD_INT 3
60997: PUSH
60998: FOR_TO
60999: IFFALSE 61081
// begin tmp := GetCargo ( cargo , i ) ;
61001: LD_ADDR_VAR 0 4
61005: PUSH
61006: LD_VAR 0 1
61010: PPUSH
61011: LD_VAR 0 3
61015: PPUSH
61016: CALL_OW 289
61020: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
61021: LD_ADDR_VAR 0 2
61025: PUSH
61026: LD_VAR 0 2
61030: PPUSH
61031: LD_VAR 0 3
61035: PPUSH
61036: LD_VAR 0 4
61040: PPUSH
61041: CALL_OW 1
61045: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
61046: LD_ADDR_VAR 0 2
61050: PUSH
61051: LD_VAR 0 2
61055: PPUSH
61056: LD_INT 4
61058: PPUSH
61059: LD_VAR 0 2
61063: PUSH
61064: LD_INT 4
61066: ARRAY
61067: PUSH
61068: LD_VAR 0 4
61072: PLUS
61073: PPUSH
61074: CALL_OW 1
61078: ST_TO_ADDR
// end ;
61079: GO 60998
61081: POP
61082: POP
// end ;
61083: LD_VAR 0 2
61087: RET
// export function Length ( array ) ; begin
61088: LD_INT 0
61090: PPUSH
// result := array + 0 ;
61091: LD_ADDR_VAR 0 2
61095: PUSH
61096: LD_VAR 0 1
61100: PUSH
61101: LD_INT 0
61103: PLUS
61104: ST_TO_ADDR
// end ;
61105: LD_VAR 0 2
61109: RET
// export function PrepareArray ( array ) ; begin
61110: LD_INT 0
61112: PPUSH
// result := array diff 0 ;
61113: LD_ADDR_VAR 0 2
61117: PUSH
61118: LD_VAR 0 1
61122: PUSH
61123: LD_INT 0
61125: DIFF
61126: ST_TO_ADDR
// if not result [ 1 ] then
61127: LD_VAR 0 2
61131: PUSH
61132: LD_INT 1
61134: ARRAY
61135: NOT
61136: IFFALSE 61156
// result := Delete ( result , 1 ) ;
61138: LD_ADDR_VAR 0 2
61142: PUSH
61143: LD_VAR 0 2
61147: PPUSH
61148: LD_INT 1
61150: PPUSH
61151: CALL_OW 3
61155: ST_TO_ADDR
// end ;
61156: LD_VAR 0 2
61160: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
61161: LD_INT 0
61163: PPUSH
61164: PPUSH
61165: PPUSH
61166: PPUSH
// sibRocketRange := 25 ;
61167: LD_ADDR_VAR 0 6
61171: PUSH
61172: LD_INT 25
61174: ST_TO_ADDR
// result := false ;
61175: LD_ADDR_VAR 0 4
61179: PUSH
61180: LD_INT 0
61182: ST_TO_ADDR
// for i := 0 to 5 do
61183: LD_ADDR_VAR 0 5
61187: PUSH
61188: DOUBLE
61189: LD_INT 0
61191: DEC
61192: ST_TO_ADDR
61193: LD_INT 5
61195: PUSH
61196: FOR_TO
61197: IFFALSE 61264
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
61199: LD_VAR 0 1
61203: PPUSH
61204: LD_VAR 0 5
61208: PPUSH
61209: LD_VAR 0 6
61213: PPUSH
61214: CALL_OW 272
61218: PPUSH
61219: LD_VAR 0 2
61223: PPUSH
61224: LD_VAR 0 5
61228: PPUSH
61229: LD_VAR 0 6
61233: PPUSH
61234: CALL_OW 273
61238: PPUSH
61239: LD_VAR 0 3
61243: PPUSH
61244: CALL_OW 309
61248: IFFALSE 61262
// begin result := true ;
61250: LD_ADDR_VAR 0 4
61254: PUSH
61255: LD_INT 1
61257: ST_TO_ADDR
// exit ;
61258: POP
61259: POP
61260: GO 61266
// end ;
61262: GO 61196
61264: POP
61265: POP
// end ;
61266: LD_VAR 0 4
61270: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
61271: LD_INT 0
61273: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
61274: LD_VAR 0 1
61278: PPUSH
61279: LD_VAR 0 2
61283: PPUSH
61284: LD_INT 0
61286: PPUSH
61287: LD_INT 0
61289: PPUSH
61290: LD_INT 1
61292: PPUSH
61293: LD_INT 0
61295: PPUSH
61296: CALL_OW 587
// end ; end_of_file
61300: LD_VAR 0 3
61304: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
61305: LD_INT 0
61307: PPUSH
61308: PPUSH
// skirmish := false ;
61309: LD_ADDR_EXP 29
61313: PUSH
61314: LD_INT 0
61316: ST_TO_ADDR
// debug_mc := false ;
61317: LD_ADDR_EXP 30
61321: PUSH
61322: LD_INT 0
61324: ST_TO_ADDR
// mc_bases := [ ] ;
61325: LD_ADDR_EXP 31
61329: PUSH
61330: EMPTY
61331: ST_TO_ADDR
// mc_sides := [ ] ;
61332: LD_ADDR_EXP 57
61336: PUSH
61337: EMPTY
61338: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61339: LD_ADDR_EXP 32
61343: PUSH
61344: EMPTY
61345: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61346: LD_ADDR_EXP 33
61350: PUSH
61351: EMPTY
61352: ST_TO_ADDR
// mc_need_heal := [ ] ;
61353: LD_ADDR_EXP 34
61357: PUSH
61358: EMPTY
61359: ST_TO_ADDR
// mc_healers := [ ] ;
61360: LD_ADDR_EXP 35
61364: PUSH
61365: EMPTY
61366: ST_TO_ADDR
// mc_build_list := [ ] ;
61367: LD_ADDR_EXP 36
61371: PUSH
61372: EMPTY
61373: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61374: LD_ADDR_EXP 63
61378: PUSH
61379: EMPTY
61380: ST_TO_ADDR
// mc_builders := [ ] ;
61381: LD_ADDR_EXP 37
61385: PUSH
61386: EMPTY
61387: ST_TO_ADDR
// mc_construct_list := [ ] ;
61388: LD_ADDR_EXP 38
61392: PUSH
61393: EMPTY
61394: ST_TO_ADDR
// mc_turret_list := [ ] ;
61395: LD_ADDR_EXP 39
61399: PUSH
61400: EMPTY
61401: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61402: LD_ADDR_EXP 40
61406: PUSH
61407: EMPTY
61408: ST_TO_ADDR
// mc_miners := [ ] ;
61409: LD_ADDR_EXP 45
61413: PUSH
61414: EMPTY
61415: ST_TO_ADDR
// mc_mines := [ ] ;
61416: LD_ADDR_EXP 44
61420: PUSH
61421: EMPTY
61422: ST_TO_ADDR
// mc_minefields := [ ] ;
61423: LD_ADDR_EXP 46
61427: PUSH
61428: EMPTY
61429: ST_TO_ADDR
// mc_crates := [ ] ;
61430: LD_ADDR_EXP 47
61434: PUSH
61435: EMPTY
61436: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61437: LD_ADDR_EXP 48
61441: PUSH
61442: EMPTY
61443: ST_TO_ADDR
// mc_crates_area := [ ] ;
61444: LD_ADDR_EXP 49
61448: PUSH
61449: EMPTY
61450: ST_TO_ADDR
// mc_vehicles := [ ] ;
61451: LD_ADDR_EXP 50
61455: PUSH
61456: EMPTY
61457: ST_TO_ADDR
// mc_attack := [ ] ;
61458: LD_ADDR_EXP 51
61462: PUSH
61463: EMPTY
61464: ST_TO_ADDR
// mc_produce := [ ] ;
61465: LD_ADDR_EXP 52
61469: PUSH
61470: EMPTY
61471: ST_TO_ADDR
// mc_defender := [ ] ;
61472: LD_ADDR_EXP 53
61476: PUSH
61477: EMPTY
61478: ST_TO_ADDR
// mc_parking := [ ] ;
61479: LD_ADDR_EXP 55
61483: PUSH
61484: EMPTY
61485: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61486: LD_ADDR_EXP 41
61490: PUSH
61491: EMPTY
61492: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61493: LD_ADDR_EXP 43
61497: PUSH
61498: EMPTY
61499: ST_TO_ADDR
// mc_scan := [ ] ;
61500: LD_ADDR_EXP 54
61504: PUSH
61505: EMPTY
61506: ST_TO_ADDR
// mc_scan_area := [ ] ;
61507: LD_ADDR_EXP 56
61511: PUSH
61512: EMPTY
61513: ST_TO_ADDR
// mc_tech := [ ] ;
61514: LD_ADDR_EXP 58
61518: PUSH
61519: EMPTY
61520: ST_TO_ADDR
// mc_class := [ ] ;
61521: LD_ADDR_EXP 72
61525: PUSH
61526: EMPTY
61527: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61528: LD_ADDR_EXP 73
61532: PUSH
61533: EMPTY
61534: ST_TO_ADDR
// mc_is_defending := [ ] ;
61535: LD_ADDR_EXP 74
61539: PUSH
61540: EMPTY
61541: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
61542: LD_ADDR_EXP 65
61546: PUSH
61547: EMPTY
61548: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
61549: LD_ADDR_EXP 75
61553: PUSH
61554: LD_INT 0
61556: ST_TO_ADDR
// end ;
61557: LD_VAR 0 1
61561: RET
// export function MC_Kill ( base ) ; begin
61562: LD_INT 0
61564: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61565: LD_ADDR_EXP 31
61569: PUSH
61570: LD_EXP 31
61574: PPUSH
61575: LD_VAR 0 1
61579: PPUSH
61580: EMPTY
61581: PPUSH
61582: CALL_OW 1
61586: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61587: LD_ADDR_EXP 32
61591: PUSH
61592: LD_EXP 32
61596: PPUSH
61597: LD_VAR 0 1
61601: PPUSH
61602: EMPTY
61603: PPUSH
61604: CALL_OW 1
61608: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61609: LD_ADDR_EXP 33
61613: PUSH
61614: LD_EXP 33
61618: PPUSH
61619: LD_VAR 0 1
61623: PPUSH
61624: EMPTY
61625: PPUSH
61626: CALL_OW 1
61630: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61631: LD_ADDR_EXP 34
61635: PUSH
61636: LD_EXP 34
61640: PPUSH
61641: LD_VAR 0 1
61645: PPUSH
61646: EMPTY
61647: PPUSH
61648: CALL_OW 1
61652: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61653: LD_ADDR_EXP 35
61657: PUSH
61658: LD_EXP 35
61662: PPUSH
61663: LD_VAR 0 1
61667: PPUSH
61668: EMPTY
61669: PPUSH
61670: CALL_OW 1
61674: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61675: LD_ADDR_EXP 36
61679: PUSH
61680: LD_EXP 36
61684: PPUSH
61685: LD_VAR 0 1
61689: PPUSH
61690: EMPTY
61691: PPUSH
61692: CALL_OW 1
61696: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61697: LD_ADDR_EXP 37
61701: PUSH
61702: LD_EXP 37
61706: PPUSH
61707: LD_VAR 0 1
61711: PPUSH
61712: EMPTY
61713: PPUSH
61714: CALL_OW 1
61718: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61719: LD_ADDR_EXP 38
61723: PUSH
61724: LD_EXP 38
61728: PPUSH
61729: LD_VAR 0 1
61733: PPUSH
61734: EMPTY
61735: PPUSH
61736: CALL_OW 1
61740: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61741: LD_ADDR_EXP 39
61745: PUSH
61746: LD_EXP 39
61750: PPUSH
61751: LD_VAR 0 1
61755: PPUSH
61756: EMPTY
61757: PPUSH
61758: CALL_OW 1
61762: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61763: LD_ADDR_EXP 40
61767: PUSH
61768: LD_EXP 40
61772: PPUSH
61773: LD_VAR 0 1
61777: PPUSH
61778: EMPTY
61779: PPUSH
61780: CALL_OW 1
61784: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61785: LD_ADDR_EXP 41
61789: PUSH
61790: LD_EXP 41
61794: PPUSH
61795: LD_VAR 0 1
61799: PPUSH
61800: EMPTY
61801: PPUSH
61802: CALL_OW 1
61806: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61807: LD_ADDR_EXP 42
61811: PUSH
61812: LD_EXP 42
61816: PPUSH
61817: LD_VAR 0 1
61821: PPUSH
61822: LD_INT 0
61824: PPUSH
61825: CALL_OW 1
61829: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61830: LD_ADDR_EXP 43
61834: PUSH
61835: LD_EXP 43
61839: PPUSH
61840: LD_VAR 0 1
61844: PPUSH
61845: EMPTY
61846: PPUSH
61847: CALL_OW 1
61851: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61852: LD_ADDR_EXP 44
61856: PUSH
61857: LD_EXP 44
61861: PPUSH
61862: LD_VAR 0 1
61866: PPUSH
61867: EMPTY
61868: PPUSH
61869: CALL_OW 1
61873: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61874: LD_ADDR_EXP 45
61878: PUSH
61879: LD_EXP 45
61883: PPUSH
61884: LD_VAR 0 1
61888: PPUSH
61889: EMPTY
61890: PPUSH
61891: CALL_OW 1
61895: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61896: LD_ADDR_EXP 46
61900: PUSH
61901: LD_EXP 46
61905: PPUSH
61906: LD_VAR 0 1
61910: PPUSH
61911: EMPTY
61912: PPUSH
61913: CALL_OW 1
61917: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61918: LD_ADDR_EXP 47
61922: PUSH
61923: LD_EXP 47
61927: PPUSH
61928: LD_VAR 0 1
61932: PPUSH
61933: EMPTY
61934: PPUSH
61935: CALL_OW 1
61939: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61940: LD_ADDR_EXP 48
61944: PUSH
61945: LD_EXP 48
61949: PPUSH
61950: LD_VAR 0 1
61954: PPUSH
61955: EMPTY
61956: PPUSH
61957: CALL_OW 1
61961: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61962: LD_ADDR_EXP 49
61966: PUSH
61967: LD_EXP 49
61971: PPUSH
61972: LD_VAR 0 1
61976: PPUSH
61977: EMPTY
61978: PPUSH
61979: CALL_OW 1
61983: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61984: LD_ADDR_EXP 50
61988: PUSH
61989: LD_EXP 50
61993: PPUSH
61994: LD_VAR 0 1
61998: PPUSH
61999: EMPTY
62000: PPUSH
62001: CALL_OW 1
62005: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62006: LD_ADDR_EXP 51
62010: PUSH
62011: LD_EXP 51
62015: PPUSH
62016: LD_VAR 0 1
62020: PPUSH
62021: EMPTY
62022: PPUSH
62023: CALL_OW 1
62027: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62028: LD_ADDR_EXP 52
62032: PUSH
62033: LD_EXP 52
62037: PPUSH
62038: LD_VAR 0 1
62042: PPUSH
62043: EMPTY
62044: PPUSH
62045: CALL_OW 1
62049: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62050: LD_ADDR_EXP 53
62054: PUSH
62055: LD_EXP 53
62059: PPUSH
62060: LD_VAR 0 1
62064: PPUSH
62065: EMPTY
62066: PPUSH
62067: CALL_OW 1
62071: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62072: LD_ADDR_EXP 54
62076: PUSH
62077: LD_EXP 54
62081: PPUSH
62082: LD_VAR 0 1
62086: PPUSH
62087: EMPTY
62088: PPUSH
62089: CALL_OW 1
62093: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62094: LD_ADDR_EXP 55
62098: PUSH
62099: LD_EXP 55
62103: PPUSH
62104: LD_VAR 0 1
62108: PPUSH
62109: EMPTY
62110: PPUSH
62111: CALL_OW 1
62115: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62116: LD_ADDR_EXP 56
62120: PUSH
62121: LD_EXP 56
62125: PPUSH
62126: LD_VAR 0 1
62130: PPUSH
62131: EMPTY
62132: PPUSH
62133: CALL_OW 1
62137: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62138: LD_ADDR_EXP 58
62142: PUSH
62143: LD_EXP 58
62147: PPUSH
62148: LD_VAR 0 1
62152: PPUSH
62153: EMPTY
62154: PPUSH
62155: CALL_OW 1
62159: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62160: LD_ADDR_EXP 60
62164: PUSH
62165: LD_EXP 60
62169: PPUSH
62170: LD_VAR 0 1
62174: PPUSH
62175: EMPTY
62176: PPUSH
62177: CALL_OW 1
62181: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62182: LD_ADDR_EXP 61
62186: PUSH
62187: LD_EXP 61
62191: PPUSH
62192: LD_VAR 0 1
62196: PPUSH
62197: EMPTY
62198: PPUSH
62199: CALL_OW 1
62203: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62204: LD_ADDR_EXP 62
62208: PUSH
62209: LD_EXP 62
62213: PPUSH
62214: LD_VAR 0 1
62218: PPUSH
62219: EMPTY
62220: PPUSH
62221: CALL_OW 1
62225: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62226: LD_ADDR_EXP 63
62230: PUSH
62231: LD_EXP 63
62235: PPUSH
62236: LD_VAR 0 1
62240: PPUSH
62241: EMPTY
62242: PPUSH
62243: CALL_OW 1
62247: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62248: LD_ADDR_EXP 64
62252: PUSH
62253: LD_EXP 64
62257: PPUSH
62258: LD_VAR 0 1
62262: PPUSH
62263: EMPTY
62264: PPUSH
62265: CALL_OW 1
62269: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62270: LD_ADDR_EXP 65
62274: PUSH
62275: LD_EXP 65
62279: PPUSH
62280: LD_VAR 0 1
62284: PPUSH
62285: EMPTY
62286: PPUSH
62287: CALL_OW 1
62291: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62292: LD_ADDR_EXP 66
62296: PUSH
62297: LD_EXP 66
62301: PPUSH
62302: LD_VAR 0 1
62306: PPUSH
62307: EMPTY
62308: PPUSH
62309: CALL_OW 1
62313: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62314: LD_ADDR_EXP 67
62318: PUSH
62319: LD_EXP 67
62323: PPUSH
62324: LD_VAR 0 1
62328: PPUSH
62329: EMPTY
62330: PPUSH
62331: CALL_OW 1
62335: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62336: LD_ADDR_EXP 68
62340: PUSH
62341: LD_EXP 68
62345: PPUSH
62346: LD_VAR 0 1
62350: PPUSH
62351: EMPTY
62352: PPUSH
62353: CALL_OW 1
62357: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62358: LD_ADDR_EXP 69
62362: PUSH
62363: LD_EXP 69
62367: PPUSH
62368: LD_VAR 0 1
62372: PPUSH
62373: EMPTY
62374: PPUSH
62375: CALL_OW 1
62379: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62380: LD_ADDR_EXP 70
62384: PUSH
62385: LD_EXP 70
62389: PPUSH
62390: LD_VAR 0 1
62394: PPUSH
62395: EMPTY
62396: PPUSH
62397: CALL_OW 1
62401: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62402: LD_ADDR_EXP 71
62406: PUSH
62407: LD_EXP 71
62411: PPUSH
62412: LD_VAR 0 1
62416: PPUSH
62417: EMPTY
62418: PPUSH
62419: CALL_OW 1
62423: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62424: LD_ADDR_EXP 72
62428: PUSH
62429: LD_EXP 72
62433: PPUSH
62434: LD_VAR 0 1
62438: PPUSH
62439: EMPTY
62440: PPUSH
62441: CALL_OW 1
62445: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62446: LD_ADDR_EXP 73
62450: PUSH
62451: LD_EXP 73
62455: PPUSH
62456: LD_VAR 0 1
62460: PPUSH
62461: LD_INT 0
62463: PPUSH
62464: CALL_OW 1
62468: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62469: LD_ADDR_EXP 74
62473: PUSH
62474: LD_EXP 74
62478: PPUSH
62479: LD_VAR 0 1
62483: PPUSH
62484: LD_INT 0
62486: PPUSH
62487: CALL_OW 1
62491: ST_TO_ADDR
// end ;
62492: LD_VAR 0 2
62496: RET
// export function MC_Add ( side , units ) ; var base ; begin
62497: LD_INT 0
62499: PPUSH
62500: PPUSH
// base := mc_bases + 1 ;
62501: LD_ADDR_VAR 0 4
62505: PUSH
62506: LD_EXP 31
62510: PUSH
62511: LD_INT 1
62513: PLUS
62514: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62515: LD_ADDR_EXP 57
62519: PUSH
62520: LD_EXP 57
62524: PPUSH
62525: LD_VAR 0 4
62529: PPUSH
62530: LD_VAR 0 1
62534: PPUSH
62535: CALL_OW 1
62539: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62540: LD_ADDR_EXP 31
62544: PUSH
62545: LD_EXP 31
62549: PPUSH
62550: LD_VAR 0 4
62554: PPUSH
62555: LD_VAR 0 2
62559: PPUSH
62560: CALL_OW 1
62564: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62565: LD_ADDR_EXP 32
62569: PUSH
62570: LD_EXP 32
62574: PPUSH
62575: LD_VAR 0 4
62579: PPUSH
62580: EMPTY
62581: PPUSH
62582: CALL_OW 1
62586: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62587: LD_ADDR_EXP 33
62591: PUSH
62592: LD_EXP 33
62596: PPUSH
62597: LD_VAR 0 4
62601: PPUSH
62602: EMPTY
62603: PPUSH
62604: CALL_OW 1
62608: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62609: LD_ADDR_EXP 34
62613: PUSH
62614: LD_EXP 34
62618: PPUSH
62619: LD_VAR 0 4
62623: PPUSH
62624: EMPTY
62625: PPUSH
62626: CALL_OW 1
62630: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62631: LD_ADDR_EXP 35
62635: PUSH
62636: LD_EXP 35
62640: PPUSH
62641: LD_VAR 0 4
62645: PPUSH
62646: EMPTY
62647: PPUSH
62648: CALL_OW 1
62652: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62653: LD_ADDR_EXP 36
62657: PUSH
62658: LD_EXP 36
62662: PPUSH
62663: LD_VAR 0 4
62667: PPUSH
62668: EMPTY
62669: PPUSH
62670: CALL_OW 1
62674: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62675: LD_ADDR_EXP 37
62679: PUSH
62680: LD_EXP 37
62684: PPUSH
62685: LD_VAR 0 4
62689: PPUSH
62690: EMPTY
62691: PPUSH
62692: CALL_OW 1
62696: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62697: LD_ADDR_EXP 38
62701: PUSH
62702: LD_EXP 38
62706: PPUSH
62707: LD_VAR 0 4
62711: PPUSH
62712: EMPTY
62713: PPUSH
62714: CALL_OW 1
62718: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62719: LD_ADDR_EXP 39
62723: PUSH
62724: LD_EXP 39
62728: PPUSH
62729: LD_VAR 0 4
62733: PPUSH
62734: EMPTY
62735: PPUSH
62736: CALL_OW 1
62740: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62741: LD_ADDR_EXP 40
62745: PUSH
62746: LD_EXP 40
62750: PPUSH
62751: LD_VAR 0 4
62755: PPUSH
62756: EMPTY
62757: PPUSH
62758: CALL_OW 1
62762: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62763: LD_ADDR_EXP 41
62767: PUSH
62768: LD_EXP 41
62772: PPUSH
62773: LD_VAR 0 4
62777: PPUSH
62778: EMPTY
62779: PPUSH
62780: CALL_OW 1
62784: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62785: LD_ADDR_EXP 42
62789: PUSH
62790: LD_EXP 42
62794: PPUSH
62795: LD_VAR 0 4
62799: PPUSH
62800: LD_INT 0
62802: PPUSH
62803: CALL_OW 1
62807: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62808: LD_ADDR_EXP 43
62812: PUSH
62813: LD_EXP 43
62817: PPUSH
62818: LD_VAR 0 4
62822: PPUSH
62823: EMPTY
62824: PPUSH
62825: CALL_OW 1
62829: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62830: LD_ADDR_EXP 44
62834: PUSH
62835: LD_EXP 44
62839: PPUSH
62840: LD_VAR 0 4
62844: PPUSH
62845: EMPTY
62846: PPUSH
62847: CALL_OW 1
62851: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62852: LD_ADDR_EXP 45
62856: PUSH
62857: LD_EXP 45
62861: PPUSH
62862: LD_VAR 0 4
62866: PPUSH
62867: EMPTY
62868: PPUSH
62869: CALL_OW 1
62873: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62874: LD_ADDR_EXP 46
62878: PUSH
62879: LD_EXP 46
62883: PPUSH
62884: LD_VAR 0 4
62888: PPUSH
62889: EMPTY
62890: PPUSH
62891: CALL_OW 1
62895: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62896: LD_ADDR_EXP 47
62900: PUSH
62901: LD_EXP 47
62905: PPUSH
62906: LD_VAR 0 4
62910: PPUSH
62911: EMPTY
62912: PPUSH
62913: CALL_OW 1
62917: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62918: LD_ADDR_EXP 48
62922: PUSH
62923: LD_EXP 48
62927: PPUSH
62928: LD_VAR 0 4
62932: PPUSH
62933: EMPTY
62934: PPUSH
62935: CALL_OW 1
62939: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62940: LD_ADDR_EXP 49
62944: PUSH
62945: LD_EXP 49
62949: PPUSH
62950: LD_VAR 0 4
62954: PPUSH
62955: EMPTY
62956: PPUSH
62957: CALL_OW 1
62961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62962: LD_ADDR_EXP 50
62966: PUSH
62967: LD_EXP 50
62971: PPUSH
62972: LD_VAR 0 4
62976: PPUSH
62977: EMPTY
62978: PPUSH
62979: CALL_OW 1
62983: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62984: LD_ADDR_EXP 51
62988: PUSH
62989: LD_EXP 51
62993: PPUSH
62994: LD_VAR 0 4
62998: PPUSH
62999: EMPTY
63000: PPUSH
63001: CALL_OW 1
63005: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
63006: LD_ADDR_EXP 52
63010: PUSH
63011: LD_EXP 52
63015: PPUSH
63016: LD_VAR 0 4
63020: PPUSH
63021: EMPTY
63022: PPUSH
63023: CALL_OW 1
63027: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
63028: LD_ADDR_EXP 53
63032: PUSH
63033: LD_EXP 53
63037: PPUSH
63038: LD_VAR 0 4
63042: PPUSH
63043: EMPTY
63044: PPUSH
63045: CALL_OW 1
63049: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
63050: LD_ADDR_EXP 54
63054: PUSH
63055: LD_EXP 54
63059: PPUSH
63060: LD_VAR 0 4
63064: PPUSH
63065: EMPTY
63066: PPUSH
63067: CALL_OW 1
63071: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63072: LD_ADDR_EXP 55
63076: PUSH
63077: LD_EXP 55
63081: PPUSH
63082: LD_VAR 0 4
63086: PPUSH
63087: EMPTY
63088: PPUSH
63089: CALL_OW 1
63093: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63094: LD_ADDR_EXP 56
63098: PUSH
63099: LD_EXP 56
63103: PPUSH
63104: LD_VAR 0 4
63108: PPUSH
63109: EMPTY
63110: PPUSH
63111: CALL_OW 1
63115: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63116: LD_ADDR_EXP 58
63120: PUSH
63121: LD_EXP 58
63125: PPUSH
63126: LD_VAR 0 4
63130: PPUSH
63131: EMPTY
63132: PPUSH
63133: CALL_OW 1
63137: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63138: LD_ADDR_EXP 60
63142: PUSH
63143: LD_EXP 60
63147: PPUSH
63148: LD_VAR 0 4
63152: PPUSH
63153: EMPTY
63154: PPUSH
63155: CALL_OW 1
63159: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63160: LD_ADDR_EXP 61
63164: PUSH
63165: LD_EXP 61
63169: PPUSH
63170: LD_VAR 0 4
63174: PPUSH
63175: EMPTY
63176: PPUSH
63177: CALL_OW 1
63181: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63182: LD_ADDR_EXP 62
63186: PUSH
63187: LD_EXP 62
63191: PPUSH
63192: LD_VAR 0 4
63196: PPUSH
63197: EMPTY
63198: PPUSH
63199: CALL_OW 1
63203: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63204: LD_ADDR_EXP 63
63208: PUSH
63209: LD_EXP 63
63213: PPUSH
63214: LD_VAR 0 4
63218: PPUSH
63219: EMPTY
63220: PPUSH
63221: CALL_OW 1
63225: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63226: LD_ADDR_EXP 64
63230: PUSH
63231: LD_EXP 64
63235: PPUSH
63236: LD_VAR 0 4
63240: PPUSH
63241: EMPTY
63242: PPUSH
63243: CALL_OW 1
63247: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63248: LD_ADDR_EXP 65
63252: PUSH
63253: LD_EXP 65
63257: PPUSH
63258: LD_VAR 0 4
63262: PPUSH
63263: EMPTY
63264: PPUSH
63265: CALL_OW 1
63269: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63270: LD_ADDR_EXP 66
63274: PUSH
63275: LD_EXP 66
63279: PPUSH
63280: LD_VAR 0 4
63284: PPUSH
63285: EMPTY
63286: PPUSH
63287: CALL_OW 1
63291: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63292: LD_ADDR_EXP 67
63296: PUSH
63297: LD_EXP 67
63301: PPUSH
63302: LD_VAR 0 4
63306: PPUSH
63307: EMPTY
63308: PPUSH
63309: CALL_OW 1
63313: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63314: LD_ADDR_EXP 68
63318: PUSH
63319: LD_EXP 68
63323: PPUSH
63324: LD_VAR 0 4
63328: PPUSH
63329: EMPTY
63330: PPUSH
63331: CALL_OW 1
63335: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63336: LD_ADDR_EXP 69
63340: PUSH
63341: LD_EXP 69
63345: PPUSH
63346: LD_VAR 0 4
63350: PPUSH
63351: EMPTY
63352: PPUSH
63353: CALL_OW 1
63357: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63358: LD_ADDR_EXP 70
63362: PUSH
63363: LD_EXP 70
63367: PPUSH
63368: LD_VAR 0 4
63372: PPUSH
63373: EMPTY
63374: PPUSH
63375: CALL_OW 1
63379: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63380: LD_ADDR_EXP 71
63384: PUSH
63385: LD_EXP 71
63389: PPUSH
63390: LD_VAR 0 4
63394: PPUSH
63395: EMPTY
63396: PPUSH
63397: CALL_OW 1
63401: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63402: LD_ADDR_EXP 72
63406: PUSH
63407: LD_EXP 72
63411: PPUSH
63412: LD_VAR 0 4
63416: PPUSH
63417: EMPTY
63418: PPUSH
63419: CALL_OW 1
63423: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63424: LD_ADDR_EXP 73
63428: PUSH
63429: LD_EXP 73
63433: PPUSH
63434: LD_VAR 0 4
63438: PPUSH
63439: LD_INT 0
63441: PPUSH
63442: CALL_OW 1
63446: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63447: LD_ADDR_EXP 74
63451: PUSH
63452: LD_EXP 74
63456: PPUSH
63457: LD_VAR 0 4
63461: PPUSH
63462: LD_INT 0
63464: PPUSH
63465: CALL_OW 1
63469: ST_TO_ADDR
// result := base ;
63470: LD_ADDR_VAR 0 3
63474: PUSH
63475: LD_VAR 0 4
63479: ST_TO_ADDR
// end ;
63480: LD_VAR 0 3
63484: RET
// export function MC_Start ( ) ; var i ; begin
63485: LD_INT 0
63487: PPUSH
63488: PPUSH
// for i = 1 to mc_bases do
63489: LD_ADDR_VAR 0 2
63493: PUSH
63494: DOUBLE
63495: LD_INT 1
63497: DEC
63498: ST_TO_ADDR
63499: LD_EXP 31
63503: PUSH
63504: FOR_TO
63505: IFFALSE 64605
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63507: LD_ADDR_EXP 31
63511: PUSH
63512: LD_EXP 31
63516: PPUSH
63517: LD_VAR 0 2
63521: PPUSH
63522: LD_EXP 31
63526: PUSH
63527: LD_VAR 0 2
63531: ARRAY
63532: PUSH
63533: LD_INT 0
63535: DIFF
63536: PPUSH
63537: CALL_OW 1
63541: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63542: LD_ADDR_EXP 32
63546: PUSH
63547: LD_EXP 32
63551: PPUSH
63552: LD_VAR 0 2
63556: PPUSH
63557: EMPTY
63558: PPUSH
63559: CALL_OW 1
63563: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63564: LD_ADDR_EXP 33
63568: PUSH
63569: LD_EXP 33
63573: PPUSH
63574: LD_VAR 0 2
63578: PPUSH
63579: EMPTY
63580: PPUSH
63581: CALL_OW 1
63585: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63586: LD_ADDR_EXP 34
63590: PUSH
63591: LD_EXP 34
63595: PPUSH
63596: LD_VAR 0 2
63600: PPUSH
63601: EMPTY
63602: PPUSH
63603: CALL_OW 1
63607: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63608: LD_ADDR_EXP 35
63612: PUSH
63613: LD_EXP 35
63617: PPUSH
63618: LD_VAR 0 2
63622: PPUSH
63623: EMPTY
63624: PUSH
63625: EMPTY
63626: PUSH
63627: EMPTY
63628: LIST
63629: LIST
63630: PPUSH
63631: CALL_OW 1
63635: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63636: LD_ADDR_EXP 36
63640: PUSH
63641: LD_EXP 36
63645: PPUSH
63646: LD_VAR 0 2
63650: PPUSH
63651: EMPTY
63652: PPUSH
63653: CALL_OW 1
63657: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63658: LD_ADDR_EXP 63
63662: PUSH
63663: LD_EXP 63
63667: PPUSH
63668: LD_VAR 0 2
63672: PPUSH
63673: EMPTY
63674: PPUSH
63675: CALL_OW 1
63679: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63680: LD_ADDR_EXP 37
63684: PUSH
63685: LD_EXP 37
63689: PPUSH
63690: LD_VAR 0 2
63694: PPUSH
63695: EMPTY
63696: PPUSH
63697: CALL_OW 1
63701: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63702: LD_ADDR_EXP 38
63706: PUSH
63707: LD_EXP 38
63711: PPUSH
63712: LD_VAR 0 2
63716: PPUSH
63717: EMPTY
63718: PPUSH
63719: CALL_OW 1
63723: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63724: LD_ADDR_EXP 39
63728: PUSH
63729: LD_EXP 39
63733: PPUSH
63734: LD_VAR 0 2
63738: PPUSH
63739: LD_EXP 31
63743: PUSH
63744: LD_VAR 0 2
63748: ARRAY
63749: PPUSH
63750: LD_INT 2
63752: PUSH
63753: LD_INT 30
63755: PUSH
63756: LD_INT 32
63758: PUSH
63759: EMPTY
63760: LIST
63761: LIST
63762: PUSH
63763: LD_INT 30
63765: PUSH
63766: LD_INT 33
63768: PUSH
63769: EMPTY
63770: LIST
63771: LIST
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: LIST
63777: PPUSH
63778: CALL_OW 72
63782: PPUSH
63783: CALL_OW 1
63787: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63788: LD_ADDR_EXP 40
63792: PUSH
63793: LD_EXP 40
63797: PPUSH
63798: LD_VAR 0 2
63802: PPUSH
63803: LD_EXP 31
63807: PUSH
63808: LD_VAR 0 2
63812: ARRAY
63813: PPUSH
63814: LD_INT 2
63816: PUSH
63817: LD_INT 30
63819: PUSH
63820: LD_INT 32
63822: PUSH
63823: EMPTY
63824: LIST
63825: LIST
63826: PUSH
63827: LD_INT 30
63829: PUSH
63830: LD_INT 31
63832: PUSH
63833: EMPTY
63834: LIST
63835: LIST
63836: PUSH
63837: EMPTY
63838: LIST
63839: LIST
63840: LIST
63841: PUSH
63842: LD_INT 58
63844: PUSH
63845: EMPTY
63846: LIST
63847: PUSH
63848: EMPTY
63849: LIST
63850: LIST
63851: PPUSH
63852: CALL_OW 72
63856: PPUSH
63857: CALL_OW 1
63861: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63862: LD_ADDR_EXP 41
63866: PUSH
63867: LD_EXP 41
63871: PPUSH
63872: LD_VAR 0 2
63876: PPUSH
63877: EMPTY
63878: PPUSH
63879: CALL_OW 1
63883: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
63884: LD_ADDR_EXP 45
63888: PUSH
63889: LD_EXP 45
63893: PPUSH
63894: LD_VAR 0 2
63898: PPUSH
63899: EMPTY
63900: PPUSH
63901: CALL_OW 1
63905: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
63906: LD_ADDR_EXP 44
63910: PUSH
63911: LD_EXP 44
63915: PPUSH
63916: LD_VAR 0 2
63920: PPUSH
63921: EMPTY
63922: PPUSH
63923: CALL_OW 1
63927: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
63928: LD_ADDR_EXP 46
63932: PUSH
63933: LD_EXP 46
63937: PPUSH
63938: LD_VAR 0 2
63942: PPUSH
63943: EMPTY
63944: PPUSH
63945: CALL_OW 1
63949: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
63950: LD_ADDR_EXP 47
63954: PUSH
63955: LD_EXP 47
63959: PPUSH
63960: LD_VAR 0 2
63964: PPUSH
63965: EMPTY
63966: PPUSH
63967: CALL_OW 1
63971: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63972: LD_ADDR_EXP 48
63976: PUSH
63977: LD_EXP 48
63981: PPUSH
63982: LD_VAR 0 2
63986: PPUSH
63987: EMPTY
63988: PPUSH
63989: CALL_OW 1
63993: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
63994: LD_ADDR_EXP 49
63998: PUSH
63999: LD_EXP 49
64003: PPUSH
64004: LD_VAR 0 2
64008: PPUSH
64009: EMPTY
64010: PPUSH
64011: CALL_OW 1
64015: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
64016: LD_ADDR_EXP 50
64020: PUSH
64021: LD_EXP 50
64025: PPUSH
64026: LD_VAR 0 2
64030: PPUSH
64031: EMPTY
64032: PPUSH
64033: CALL_OW 1
64037: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
64038: LD_ADDR_EXP 51
64042: PUSH
64043: LD_EXP 51
64047: PPUSH
64048: LD_VAR 0 2
64052: PPUSH
64053: EMPTY
64054: PPUSH
64055: CALL_OW 1
64059: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
64060: LD_ADDR_EXP 52
64064: PUSH
64065: LD_EXP 52
64069: PPUSH
64070: LD_VAR 0 2
64074: PPUSH
64075: EMPTY
64076: PPUSH
64077: CALL_OW 1
64081: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64082: LD_ADDR_EXP 53
64086: PUSH
64087: LD_EXP 53
64091: PPUSH
64092: LD_VAR 0 2
64096: PPUSH
64097: EMPTY
64098: PPUSH
64099: CALL_OW 1
64103: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
64104: LD_ADDR_EXP 42
64108: PUSH
64109: LD_EXP 42
64113: PPUSH
64114: LD_VAR 0 2
64118: PPUSH
64119: LD_INT 0
64121: PPUSH
64122: CALL_OW 1
64126: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
64127: LD_ADDR_EXP 55
64131: PUSH
64132: LD_EXP 55
64136: PPUSH
64137: LD_VAR 0 2
64141: PPUSH
64142: LD_INT 0
64144: PPUSH
64145: CALL_OW 1
64149: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64150: LD_ADDR_EXP 43
64154: PUSH
64155: LD_EXP 43
64159: PPUSH
64160: LD_VAR 0 2
64164: PPUSH
64165: EMPTY
64166: PPUSH
64167: CALL_OW 1
64171: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
64172: LD_ADDR_EXP 54
64176: PUSH
64177: LD_EXP 54
64181: PPUSH
64182: LD_VAR 0 2
64186: PPUSH
64187: LD_INT 0
64189: PPUSH
64190: CALL_OW 1
64194: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
64195: LD_ADDR_EXP 56
64199: PUSH
64200: LD_EXP 56
64204: PPUSH
64205: LD_VAR 0 2
64209: PPUSH
64210: EMPTY
64211: PPUSH
64212: CALL_OW 1
64216: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
64217: LD_ADDR_EXP 59
64221: PUSH
64222: LD_EXP 59
64226: PPUSH
64227: LD_VAR 0 2
64231: PPUSH
64232: LD_INT 0
64234: PPUSH
64235: CALL_OW 1
64239: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
64240: LD_ADDR_EXP 60
64244: PUSH
64245: LD_EXP 60
64249: PPUSH
64250: LD_VAR 0 2
64254: PPUSH
64255: EMPTY
64256: PPUSH
64257: CALL_OW 1
64261: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64262: LD_ADDR_EXP 61
64266: PUSH
64267: LD_EXP 61
64271: PPUSH
64272: LD_VAR 0 2
64276: PPUSH
64277: EMPTY
64278: PPUSH
64279: CALL_OW 1
64283: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64284: LD_ADDR_EXP 62
64288: PUSH
64289: LD_EXP 62
64293: PPUSH
64294: LD_VAR 0 2
64298: PPUSH
64299: EMPTY
64300: PPUSH
64301: CALL_OW 1
64305: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64306: LD_ADDR_EXP 64
64310: PUSH
64311: LD_EXP 64
64315: PPUSH
64316: LD_VAR 0 2
64320: PPUSH
64321: LD_EXP 31
64325: PUSH
64326: LD_VAR 0 2
64330: ARRAY
64331: PPUSH
64332: LD_INT 2
64334: PUSH
64335: LD_INT 30
64337: PUSH
64338: LD_INT 6
64340: PUSH
64341: EMPTY
64342: LIST
64343: LIST
64344: PUSH
64345: LD_INT 30
64347: PUSH
64348: LD_INT 7
64350: PUSH
64351: EMPTY
64352: LIST
64353: LIST
64354: PUSH
64355: LD_INT 30
64357: PUSH
64358: LD_INT 8
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PUSH
64365: EMPTY
64366: LIST
64367: LIST
64368: LIST
64369: LIST
64370: PPUSH
64371: CALL_OW 72
64375: PPUSH
64376: CALL_OW 1
64380: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64381: LD_ADDR_EXP 65
64385: PUSH
64386: LD_EXP 65
64390: PPUSH
64391: LD_VAR 0 2
64395: PPUSH
64396: EMPTY
64397: PPUSH
64398: CALL_OW 1
64402: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64403: LD_ADDR_EXP 66
64407: PUSH
64408: LD_EXP 66
64412: PPUSH
64413: LD_VAR 0 2
64417: PPUSH
64418: EMPTY
64419: PPUSH
64420: CALL_OW 1
64424: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64425: LD_ADDR_EXP 67
64429: PUSH
64430: LD_EXP 67
64434: PPUSH
64435: LD_VAR 0 2
64439: PPUSH
64440: EMPTY
64441: PPUSH
64442: CALL_OW 1
64446: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64447: LD_ADDR_EXP 68
64451: PUSH
64452: LD_EXP 68
64456: PPUSH
64457: LD_VAR 0 2
64461: PPUSH
64462: EMPTY
64463: PPUSH
64464: CALL_OW 1
64468: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64469: LD_ADDR_EXP 69
64473: PUSH
64474: LD_EXP 69
64478: PPUSH
64479: LD_VAR 0 2
64483: PPUSH
64484: EMPTY
64485: PPUSH
64486: CALL_OW 1
64490: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64491: LD_ADDR_EXP 70
64495: PUSH
64496: LD_EXP 70
64500: PPUSH
64501: LD_VAR 0 2
64505: PPUSH
64506: EMPTY
64507: PPUSH
64508: CALL_OW 1
64512: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64513: LD_ADDR_EXP 71
64517: PUSH
64518: LD_EXP 71
64522: PPUSH
64523: LD_VAR 0 2
64527: PPUSH
64528: EMPTY
64529: PPUSH
64530: CALL_OW 1
64534: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64535: LD_ADDR_EXP 72
64539: PUSH
64540: LD_EXP 72
64544: PPUSH
64545: LD_VAR 0 2
64549: PPUSH
64550: EMPTY
64551: PPUSH
64552: CALL_OW 1
64556: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64557: LD_ADDR_EXP 73
64561: PUSH
64562: LD_EXP 73
64566: PPUSH
64567: LD_VAR 0 2
64571: PPUSH
64572: LD_INT 0
64574: PPUSH
64575: CALL_OW 1
64579: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64580: LD_ADDR_EXP 74
64584: PUSH
64585: LD_EXP 74
64589: PPUSH
64590: LD_VAR 0 2
64594: PPUSH
64595: LD_INT 0
64597: PPUSH
64598: CALL_OW 1
64602: ST_TO_ADDR
// end ;
64603: GO 63504
64605: POP
64606: POP
// MC_InitSides ( ) ;
64607: CALL 64893 0 0
// MC_InitResearch ( ) ;
64611: CALL 64632 0 0
// CustomInitMacro ( ) ;
64615: CALL 1411 0 0
// skirmish := true ;
64619: LD_ADDR_EXP 29
64623: PUSH
64624: LD_INT 1
64626: ST_TO_ADDR
// end ;
64627: LD_VAR 0 1
64631: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64632: LD_INT 0
64634: PPUSH
64635: PPUSH
64636: PPUSH
64637: PPUSH
64638: PPUSH
64639: PPUSH
// if not mc_bases then
64640: LD_EXP 31
64644: NOT
64645: IFFALSE 64649
// exit ;
64647: GO 64888
// for i = 1 to 8 do
64649: LD_ADDR_VAR 0 2
64653: PUSH
64654: DOUBLE
64655: LD_INT 1
64657: DEC
64658: ST_TO_ADDR
64659: LD_INT 8
64661: PUSH
64662: FOR_TO
64663: IFFALSE 64689
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64665: LD_ADDR_EXP 58
64669: PUSH
64670: LD_EXP 58
64674: PPUSH
64675: LD_VAR 0 2
64679: PPUSH
64680: EMPTY
64681: PPUSH
64682: CALL_OW 1
64686: ST_TO_ADDR
64687: GO 64662
64689: POP
64690: POP
// tmp := [ ] ;
64691: LD_ADDR_VAR 0 5
64695: PUSH
64696: EMPTY
64697: ST_TO_ADDR
// for i = 1 to mc_sides do
64698: LD_ADDR_VAR 0 2
64702: PUSH
64703: DOUBLE
64704: LD_INT 1
64706: DEC
64707: ST_TO_ADDR
64708: LD_EXP 57
64712: PUSH
64713: FOR_TO
64714: IFFALSE 64772
// if not mc_sides [ i ] in tmp then
64716: LD_EXP 57
64720: PUSH
64721: LD_VAR 0 2
64725: ARRAY
64726: PUSH
64727: LD_VAR 0 5
64731: IN
64732: NOT
64733: IFFALSE 64770
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64735: LD_ADDR_VAR 0 5
64739: PUSH
64740: LD_VAR 0 5
64744: PPUSH
64745: LD_VAR 0 5
64749: PUSH
64750: LD_INT 1
64752: PLUS
64753: PPUSH
64754: LD_EXP 57
64758: PUSH
64759: LD_VAR 0 2
64763: ARRAY
64764: PPUSH
64765: CALL_OW 2
64769: ST_TO_ADDR
64770: GO 64713
64772: POP
64773: POP
// if not tmp then
64774: LD_VAR 0 5
64778: NOT
64779: IFFALSE 64783
// exit ;
64781: GO 64888
// for j in tmp do
64783: LD_ADDR_VAR 0 3
64787: PUSH
64788: LD_VAR 0 5
64792: PUSH
64793: FOR_IN
64794: IFFALSE 64886
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64796: LD_ADDR_VAR 0 6
64800: PUSH
64801: LD_INT 22
64803: PUSH
64804: LD_VAR 0 3
64808: PUSH
64809: EMPTY
64810: LIST
64811: LIST
64812: PPUSH
64813: CALL_OW 69
64817: ST_TO_ADDR
// if not un then
64818: LD_VAR 0 6
64822: NOT
64823: IFFALSE 64827
// continue ;
64825: GO 64793
// nation := GetNation ( un [ 1 ] ) ;
64827: LD_ADDR_VAR 0 4
64831: PUSH
64832: LD_VAR 0 6
64836: PUSH
64837: LD_INT 1
64839: ARRAY
64840: PPUSH
64841: CALL_OW 248
64845: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64846: LD_ADDR_EXP 58
64850: PUSH
64851: LD_EXP 58
64855: PPUSH
64856: LD_VAR 0 3
64860: PPUSH
64861: LD_VAR 0 3
64865: PPUSH
64866: LD_VAR 0 4
64870: PPUSH
64871: LD_INT 1
64873: PPUSH
64874: CALL 19947 0 3
64878: PPUSH
64879: CALL_OW 1
64883: ST_TO_ADDR
// end ;
64884: GO 64793
64886: POP
64887: POP
// end ;
64888: LD_VAR 0 1
64892: RET
// export function MC_InitSides ( ) ; var i ; begin
64893: LD_INT 0
64895: PPUSH
64896: PPUSH
// if not mc_bases then
64897: LD_EXP 31
64901: NOT
64902: IFFALSE 64906
// exit ;
64904: GO 64980
// for i = 1 to mc_bases do
64906: LD_ADDR_VAR 0 2
64910: PUSH
64911: DOUBLE
64912: LD_INT 1
64914: DEC
64915: ST_TO_ADDR
64916: LD_EXP 31
64920: PUSH
64921: FOR_TO
64922: IFFALSE 64978
// if mc_bases [ i ] then
64924: LD_EXP 31
64928: PUSH
64929: LD_VAR 0 2
64933: ARRAY
64934: IFFALSE 64976
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
64936: LD_ADDR_EXP 57
64940: PUSH
64941: LD_EXP 57
64945: PPUSH
64946: LD_VAR 0 2
64950: PPUSH
64951: LD_EXP 31
64955: PUSH
64956: LD_VAR 0 2
64960: ARRAY
64961: PUSH
64962: LD_INT 1
64964: ARRAY
64965: PPUSH
64966: CALL_OW 255
64970: PPUSH
64971: CALL_OW 1
64975: ST_TO_ADDR
64976: GO 64921
64978: POP
64979: POP
// end ;
64980: LD_VAR 0 1
64984: RET
// every 0 0$03 trigger skirmish do
64985: LD_EXP 29
64989: IFFALSE 65143
64991: GO 64993
64993: DISABLE
// begin enable ;
64994: ENABLE
// MC_CheckBuildings ( ) ;
64995: CALL 69641 0 0
// MC_CheckPeopleLife ( ) ;
64999: CALL 69802 0 0
// RaiseSailEvent ( 100 ) ;
65003: LD_INT 100
65005: PPUSH
65006: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
65010: LD_INT 103
65012: PPUSH
65013: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
65017: LD_INT 104
65019: PPUSH
65020: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
65024: LD_INT 105
65026: PPUSH
65027: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
65031: LD_INT 106
65033: PPUSH
65034: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
65038: LD_INT 107
65040: PPUSH
65041: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
65045: LD_INT 108
65047: PPUSH
65048: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
65052: LD_INT 109
65054: PPUSH
65055: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
65059: LD_INT 110
65061: PPUSH
65062: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
65066: LD_INT 111
65068: PPUSH
65069: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
65073: LD_INT 112
65075: PPUSH
65076: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
65080: LD_INT 113
65082: PPUSH
65083: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
65087: LD_INT 120
65089: PPUSH
65090: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
65094: LD_INT 121
65096: PPUSH
65097: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
65101: LD_INT 122
65103: PPUSH
65104: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
65108: LD_INT 123
65110: PPUSH
65111: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
65115: LD_INT 124
65117: PPUSH
65118: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
65122: LD_INT 125
65124: PPUSH
65125: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
65129: LD_INT 126
65131: PPUSH
65132: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
65136: LD_INT 200
65138: PPUSH
65139: CALL_OW 427
// end ;
65143: END
// on SailEvent ( event ) do begin if event < 100 then
65144: LD_VAR 0 1
65148: PUSH
65149: LD_INT 100
65151: LESS
65152: IFFALSE 65163
// CustomEvent ( event ) ;
65154: LD_VAR 0 1
65158: PPUSH
65159: CALL 19111 0 1
// if event = 100 then
65163: LD_VAR 0 1
65167: PUSH
65168: LD_INT 100
65170: EQUAL
65171: IFFALSE 65177
// MC_ClassManager ( ) ;
65173: CALL 65569 0 0
// if event = 101 then
65177: LD_VAR 0 1
65181: PUSH
65182: LD_INT 101
65184: EQUAL
65185: IFFALSE 65191
// MC_RepairBuildings ( ) ;
65187: CALL 70387 0 0
// if event = 102 then
65191: LD_VAR 0 1
65195: PUSH
65196: LD_INT 102
65198: EQUAL
65199: IFFALSE 65205
// MC_Heal ( ) ;
65201: CALL 71322 0 0
// if event = 103 then
65205: LD_VAR 0 1
65209: PUSH
65210: LD_INT 103
65212: EQUAL
65213: IFFALSE 65219
// MC_Build ( ) ;
65215: CALL 71744 0 0
// if event = 104 then
65219: LD_VAR 0 1
65223: PUSH
65224: LD_INT 104
65226: EQUAL
65227: IFFALSE 65233
// MC_TurretWeapon ( ) ;
65229: CALL 73378 0 0
// if event = 105 then
65233: LD_VAR 0 1
65237: PUSH
65238: LD_INT 105
65240: EQUAL
65241: IFFALSE 65247
// MC_BuildUpgrade ( ) ;
65243: CALL 72929 0 0
// if event = 106 then
65247: LD_VAR 0 1
65251: PUSH
65252: LD_INT 106
65254: EQUAL
65255: IFFALSE 65261
// MC_PlantMines ( ) ;
65257: CALL 73808 0 0
// if event = 107 then
65261: LD_VAR 0 1
65265: PUSH
65266: LD_INT 107
65268: EQUAL
65269: IFFALSE 65275
// MC_CollectCrates ( ) ;
65271: CALL 74599 0 0
// if event = 108 then
65275: LD_VAR 0 1
65279: PUSH
65280: LD_INT 108
65282: EQUAL
65283: IFFALSE 65289
// MC_LinkRemoteControl ( ) ;
65285: CALL 76449 0 0
// if event = 109 then
65289: LD_VAR 0 1
65293: PUSH
65294: LD_INT 109
65296: EQUAL
65297: IFFALSE 65303
// MC_ProduceVehicle ( ) ;
65299: CALL 76630 0 0
// if event = 110 then
65303: LD_VAR 0 1
65307: PUSH
65308: LD_INT 110
65310: EQUAL
65311: IFFALSE 65317
// MC_SendAttack ( ) ;
65313: CALL 77096 0 0
// if event = 111 then
65317: LD_VAR 0 1
65321: PUSH
65322: LD_INT 111
65324: EQUAL
65325: IFFALSE 65331
// MC_Defend ( ) ;
65327: CALL 77204 0 0
// if event = 112 then
65331: LD_VAR 0 1
65335: PUSH
65336: LD_INT 112
65338: EQUAL
65339: IFFALSE 65345
// MC_Research ( ) ;
65341: CALL 78084 0 0
// if event = 113 then
65345: LD_VAR 0 1
65349: PUSH
65350: LD_INT 113
65352: EQUAL
65353: IFFALSE 65359
// MC_MinesTrigger ( ) ;
65355: CALL 79198 0 0
// if event = 120 then
65359: LD_VAR 0 1
65363: PUSH
65364: LD_INT 120
65366: EQUAL
65367: IFFALSE 65373
// MC_RepairVehicle ( ) ;
65369: CALL 79297 0 0
// if event = 121 then
65373: LD_VAR 0 1
65377: PUSH
65378: LD_INT 121
65380: EQUAL
65381: IFFALSE 65387
// MC_TameApe ( ) ;
65383: CALL 80066 0 0
// if event = 122 then
65387: LD_VAR 0 1
65391: PUSH
65392: LD_INT 122
65394: EQUAL
65395: IFFALSE 65401
// MC_ChangeApeClass ( ) ;
65397: CALL 80895 0 0
// if event = 123 then
65401: LD_VAR 0 1
65405: PUSH
65406: LD_INT 123
65408: EQUAL
65409: IFFALSE 65415
// MC_Bazooka ( ) ;
65411: CALL 81545 0 0
// if event = 124 then
65415: LD_VAR 0 1
65419: PUSH
65420: LD_INT 124
65422: EQUAL
65423: IFFALSE 65429
// MC_TeleportExit ( ) ;
65425: CALL 81743 0 0
// if event = 125 then
65429: LD_VAR 0 1
65433: PUSH
65434: LD_INT 125
65436: EQUAL
65437: IFFALSE 65443
// MC_Deposits ( ) ;
65439: CALL 82390 0 0
// if event = 126 then
65443: LD_VAR 0 1
65447: PUSH
65448: LD_INT 126
65450: EQUAL
65451: IFFALSE 65457
// MC_RemoteDriver ( ) ;
65453: CALL 83015 0 0
// if event = 200 then
65457: LD_VAR 0 1
65461: PUSH
65462: LD_INT 200
65464: EQUAL
65465: IFFALSE 65471
// MC_Idle ( ) ;
65467: CALL 84964 0 0
// end ;
65471: PPOPN 1
65473: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65474: LD_INT 0
65476: PPUSH
65477: PPUSH
// if not mc_bases [ base ] or not tag then
65478: LD_EXP 31
65482: PUSH
65483: LD_VAR 0 1
65487: ARRAY
65488: NOT
65489: PUSH
65490: LD_VAR 0 2
65494: NOT
65495: OR
65496: IFFALSE 65500
// exit ;
65498: GO 65564
// for i in mc_bases [ base ] union mc_ape [ base ] do
65500: LD_ADDR_VAR 0 4
65504: PUSH
65505: LD_EXP 31
65509: PUSH
65510: LD_VAR 0 1
65514: ARRAY
65515: PUSH
65516: LD_EXP 60
65520: PUSH
65521: LD_VAR 0 1
65525: ARRAY
65526: UNION
65527: PUSH
65528: FOR_IN
65529: IFFALSE 65562
// if GetTag ( i ) = tag then
65531: LD_VAR 0 4
65535: PPUSH
65536: CALL_OW 110
65540: PUSH
65541: LD_VAR 0 2
65545: EQUAL
65546: IFFALSE 65560
// SetTag ( i , 0 ) ;
65548: LD_VAR 0 4
65552: PPUSH
65553: LD_INT 0
65555: PPUSH
65556: CALL_OW 109
65560: GO 65528
65562: POP
65563: POP
// end ;
65564: LD_VAR 0 3
65568: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65569: LD_INT 0
65571: PPUSH
65572: PPUSH
65573: PPUSH
65574: PPUSH
65575: PPUSH
65576: PPUSH
65577: PPUSH
65578: PPUSH
// if not mc_bases then
65579: LD_EXP 31
65583: NOT
65584: IFFALSE 65588
// exit ;
65586: GO 66046
// for i = 1 to mc_bases do
65588: LD_ADDR_VAR 0 2
65592: PUSH
65593: DOUBLE
65594: LD_INT 1
65596: DEC
65597: ST_TO_ADDR
65598: LD_EXP 31
65602: PUSH
65603: FOR_TO
65604: IFFALSE 66044
// begin tmp := MC_ClassCheckReq ( i ) ;
65606: LD_ADDR_VAR 0 4
65610: PUSH
65611: LD_VAR 0 2
65615: PPUSH
65616: CALL 66051 0 1
65620: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65621: LD_ADDR_EXP 72
65625: PUSH
65626: LD_EXP 72
65630: PPUSH
65631: LD_VAR 0 2
65635: PPUSH
65636: LD_VAR 0 4
65640: PPUSH
65641: CALL_OW 1
65645: ST_TO_ADDR
// if not tmp then
65646: LD_VAR 0 4
65650: NOT
65651: IFFALSE 65655
// continue ;
65653: GO 65603
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65655: LD_ADDR_VAR 0 6
65659: PUSH
65660: LD_EXP 31
65664: PUSH
65665: LD_VAR 0 2
65669: ARRAY
65670: PPUSH
65671: LD_INT 2
65673: PUSH
65674: LD_INT 30
65676: PUSH
65677: LD_INT 4
65679: PUSH
65680: EMPTY
65681: LIST
65682: LIST
65683: PUSH
65684: LD_INT 30
65686: PUSH
65687: LD_INT 5
65689: PUSH
65690: EMPTY
65691: LIST
65692: LIST
65693: PUSH
65694: EMPTY
65695: LIST
65696: LIST
65697: LIST
65698: PPUSH
65699: CALL_OW 72
65703: PUSH
65704: LD_EXP 31
65708: PUSH
65709: LD_VAR 0 2
65713: ARRAY
65714: PPUSH
65715: LD_INT 2
65717: PUSH
65718: LD_INT 30
65720: PUSH
65721: LD_INT 0
65723: PUSH
65724: EMPTY
65725: LIST
65726: LIST
65727: PUSH
65728: LD_INT 30
65730: PUSH
65731: LD_INT 1
65733: PUSH
65734: EMPTY
65735: LIST
65736: LIST
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: LIST
65742: PPUSH
65743: CALL_OW 72
65747: PUSH
65748: LD_EXP 31
65752: PUSH
65753: LD_VAR 0 2
65757: ARRAY
65758: PPUSH
65759: LD_INT 30
65761: PUSH
65762: LD_INT 3
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PPUSH
65769: CALL_OW 72
65773: PUSH
65774: LD_EXP 31
65778: PUSH
65779: LD_VAR 0 2
65783: ARRAY
65784: PPUSH
65785: LD_INT 2
65787: PUSH
65788: LD_INT 30
65790: PUSH
65791: LD_INT 6
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: PUSH
65798: LD_INT 30
65800: PUSH
65801: LD_INT 7
65803: PUSH
65804: EMPTY
65805: LIST
65806: LIST
65807: PUSH
65808: LD_INT 30
65810: PUSH
65811: LD_INT 8
65813: PUSH
65814: EMPTY
65815: LIST
65816: LIST
65817: PUSH
65818: EMPTY
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: PPUSH
65824: CALL_OW 72
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: ST_TO_ADDR
// for j = 1 to 4 do
65835: LD_ADDR_VAR 0 3
65839: PUSH
65840: DOUBLE
65841: LD_INT 1
65843: DEC
65844: ST_TO_ADDR
65845: LD_INT 4
65847: PUSH
65848: FOR_TO
65849: IFFALSE 66040
// begin if not tmp [ j ] then
65851: LD_VAR 0 4
65855: PUSH
65856: LD_VAR 0 3
65860: ARRAY
65861: NOT
65862: IFFALSE 65866
// continue ;
65864: GO 65848
// for p in tmp [ j ] do
65866: LD_ADDR_VAR 0 5
65870: PUSH
65871: LD_VAR 0 4
65875: PUSH
65876: LD_VAR 0 3
65880: ARRAY
65881: PUSH
65882: FOR_IN
65883: IFFALSE 66036
// begin if not b [ j ] then
65885: LD_VAR 0 6
65889: PUSH
65890: LD_VAR 0 3
65894: ARRAY
65895: NOT
65896: IFFALSE 65900
// break ;
65898: GO 66036
// e := 0 ;
65900: LD_ADDR_VAR 0 7
65904: PUSH
65905: LD_INT 0
65907: ST_TO_ADDR
// for k in b [ j ] do
65908: LD_ADDR_VAR 0 8
65912: PUSH
65913: LD_VAR 0 6
65917: PUSH
65918: LD_VAR 0 3
65922: ARRAY
65923: PUSH
65924: FOR_IN
65925: IFFALSE 65952
// if IsNotFull ( k ) then
65927: LD_VAR 0 8
65931: PPUSH
65932: CALL 22100 0 1
65936: IFFALSE 65950
// begin e := k ;
65938: LD_ADDR_VAR 0 7
65942: PUSH
65943: LD_VAR 0 8
65947: ST_TO_ADDR
// break ;
65948: GO 65952
// end ;
65950: GO 65924
65952: POP
65953: POP
// if e and not UnitGoingToBuilding ( p , e ) then
65954: LD_VAR 0 7
65958: PUSH
65959: LD_VAR 0 5
65963: PPUSH
65964: LD_VAR 0 7
65968: PPUSH
65969: CALL 55996 0 2
65973: NOT
65974: AND
65975: IFFALSE 66034
// begin if IsInUnit ( p ) then
65977: LD_VAR 0 5
65981: PPUSH
65982: CALL_OW 310
65986: IFFALSE 65997
// ComExitBuilding ( p ) ;
65988: LD_VAR 0 5
65992: PPUSH
65993: CALL_OW 122
// ComEnterUnit ( p , e ) ;
65997: LD_VAR 0 5
66001: PPUSH
66002: LD_VAR 0 7
66006: PPUSH
66007: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
66011: LD_VAR 0 5
66015: PPUSH
66016: LD_VAR 0 3
66020: PPUSH
66021: CALL_OW 183
// AddComExitBuilding ( p ) ;
66025: LD_VAR 0 5
66029: PPUSH
66030: CALL_OW 182
// end ; end ;
66034: GO 65882
66036: POP
66037: POP
// end ;
66038: GO 65848
66040: POP
66041: POP
// end ;
66042: GO 65603
66044: POP
66045: POP
// end ;
66046: LD_VAR 0 1
66050: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
66051: LD_INT 0
66053: PPUSH
66054: PPUSH
66055: PPUSH
66056: PPUSH
66057: PPUSH
66058: PPUSH
66059: PPUSH
66060: PPUSH
66061: PPUSH
66062: PPUSH
66063: PPUSH
66064: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66065: LD_VAR 0 1
66069: NOT
66070: PUSH
66071: LD_EXP 31
66075: PUSH
66076: LD_VAR 0 1
66080: ARRAY
66081: NOT
66082: OR
66083: PUSH
66084: LD_EXP 31
66088: PUSH
66089: LD_VAR 0 1
66093: ARRAY
66094: PPUSH
66095: LD_INT 2
66097: PUSH
66098: LD_INT 30
66100: PUSH
66101: LD_INT 0
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: PUSH
66108: LD_INT 30
66110: PUSH
66111: LD_INT 1
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: LIST
66122: PPUSH
66123: CALL_OW 72
66127: NOT
66128: OR
66129: IFFALSE 66133
// exit ;
66131: GO 69636
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66133: LD_ADDR_VAR 0 4
66137: PUSH
66138: LD_EXP 31
66142: PUSH
66143: LD_VAR 0 1
66147: ARRAY
66148: PPUSH
66149: LD_INT 2
66151: PUSH
66152: LD_INT 25
66154: PUSH
66155: LD_INT 1
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 25
66164: PUSH
66165: LD_INT 2
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 25
66174: PUSH
66175: LD_INT 3
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 25
66184: PUSH
66185: LD_INT 4
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 25
66194: PUSH
66195: LD_INT 5
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PUSH
66202: LD_INT 25
66204: PUSH
66205: LD_INT 8
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PUSH
66212: LD_INT 25
66214: PUSH
66215: LD_INT 9
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PUSH
66222: EMPTY
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: PPUSH
66232: CALL_OW 72
66236: ST_TO_ADDR
// if not tmp then
66237: LD_VAR 0 4
66241: NOT
66242: IFFALSE 66246
// exit ;
66244: GO 69636
// for i in tmp do
66246: LD_ADDR_VAR 0 3
66250: PUSH
66251: LD_VAR 0 4
66255: PUSH
66256: FOR_IN
66257: IFFALSE 66288
// if GetTag ( i ) then
66259: LD_VAR 0 3
66263: PPUSH
66264: CALL_OW 110
66268: IFFALSE 66286
// tmp := tmp diff i ;
66270: LD_ADDR_VAR 0 4
66274: PUSH
66275: LD_VAR 0 4
66279: PUSH
66280: LD_VAR 0 3
66284: DIFF
66285: ST_TO_ADDR
66286: GO 66256
66288: POP
66289: POP
// if not tmp then
66290: LD_VAR 0 4
66294: NOT
66295: IFFALSE 66299
// exit ;
66297: GO 69636
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66299: LD_ADDR_VAR 0 5
66303: PUSH
66304: LD_EXP 31
66308: PUSH
66309: LD_VAR 0 1
66313: ARRAY
66314: PPUSH
66315: LD_INT 2
66317: PUSH
66318: LD_INT 25
66320: PUSH
66321: LD_INT 1
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: LD_INT 25
66330: PUSH
66331: LD_INT 5
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 25
66340: PUSH
66341: LD_INT 8
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 25
66350: PUSH
66351: LD_INT 9
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: EMPTY
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: PPUSH
66365: CALL_OW 72
66369: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66370: LD_ADDR_VAR 0 6
66374: PUSH
66375: LD_EXP 31
66379: PUSH
66380: LD_VAR 0 1
66384: ARRAY
66385: PPUSH
66386: LD_INT 25
66388: PUSH
66389: LD_INT 2
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PPUSH
66396: CALL_OW 72
66400: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66401: LD_ADDR_VAR 0 7
66405: PUSH
66406: LD_EXP 31
66410: PUSH
66411: LD_VAR 0 1
66415: ARRAY
66416: PPUSH
66417: LD_INT 25
66419: PUSH
66420: LD_INT 3
66422: PUSH
66423: EMPTY
66424: LIST
66425: LIST
66426: PPUSH
66427: CALL_OW 72
66431: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66432: LD_ADDR_VAR 0 8
66436: PUSH
66437: LD_EXP 31
66441: PUSH
66442: LD_VAR 0 1
66446: ARRAY
66447: PPUSH
66448: LD_INT 25
66450: PUSH
66451: LD_INT 4
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: LD_INT 24
66460: PUSH
66461: LD_INT 251
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: PPUSH
66472: CALL_OW 72
66476: ST_TO_ADDR
// if mc_is_defending [ base ] then
66477: LD_EXP 74
66481: PUSH
66482: LD_VAR 0 1
66486: ARRAY
66487: IFFALSE 66948
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66489: LD_ADDR_EXP 73
66493: PUSH
66494: LD_EXP 73
66498: PPUSH
66499: LD_VAR 0 1
66503: PPUSH
66504: LD_INT 4
66506: PPUSH
66507: CALL_OW 1
66511: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66512: LD_ADDR_VAR 0 12
66516: PUSH
66517: LD_EXP 31
66521: PUSH
66522: LD_VAR 0 1
66526: ARRAY
66527: PPUSH
66528: LD_INT 2
66530: PUSH
66531: LD_INT 30
66533: PUSH
66534: LD_INT 4
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PUSH
66541: LD_INT 30
66543: PUSH
66544: LD_INT 5
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: LIST
66555: PPUSH
66556: CALL_OW 72
66560: ST_TO_ADDR
// if not b then
66561: LD_VAR 0 12
66565: NOT
66566: IFFALSE 66570
// exit ;
66568: GO 69636
// p := [ ] ;
66570: LD_ADDR_VAR 0 11
66574: PUSH
66575: EMPTY
66576: ST_TO_ADDR
// if sci >= 2 then
66577: LD_VAR 0 8
66581: PUSH
66582: LD_INT 2
66584: GREATEREQUAL
66585: IFFALSE 66616
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66587: LD_ADDR_VAR 0 8
66591: PUSH
66592: LD_VAR 0 8
66596: PUSH
66597: LD_INT 1
66599: ARRAY
66600: PUSH
66601: LD_VAR 0 8
66605: PUSH
66606: LD_INT 2
66608: ARRAY
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: ST_TO_ADDR
66614: GO 66677
// if sci = 1 then
66616: LD_VAR 0 8
66620: PUSH
66621: LD_INT 1
66623: EQUAL
66624: IFFALSE 66645
// sci := [ sci [ 1 ] ] else
66626: LD_ADDR_VAR 0 8
66630: PUSH
66631: LD_VAR 0 8
66635: PUSH
66636: LD_INT 1
66638: ARRAY
66639: PUSH
66640: EMPTY
66641: LIST
66642: ST_TO_ADDR
66643: GO 66677
// if sci = 0 then
66645: LD_VAR 0 8
66649: PUSH
66650: LD_INT 0
66652: EQUAL
66653: IFFALSE 66677
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66655: LD_ADDR_VAR 0 11
66659: PUSH
66660: LD_VAR 0 4
66664: PPUSH
66665: LD_INT 4
66667: PPUSH
66668: CALL 55868 0 2
66672: PUSH
66673: LD_INT 1
66675: ARRAY
66676: ST_TO_ADDR
// if eng > 4 then
66677: LD_VAR 0 6
66681: PUSH
66682: LD_INT 4
66684: GREATER
66685: IFFALSE 66731
// for i = eng downto 4 do
66687: LD_ADDR_VAR 0 3
66691: PUSH
66692: DOUBLE
66693: LD_VAR 0 6
66697: INC
66698: ST_TO_ADDR
66699: LD_INT 4
66701: PUSH
66702: FOR_DOWNTO
66703: IFFALSE 66729
// eng := eng diff eng [ i ] ;
66705: LD_ADDR_VAR 0 6
66709: PUSH
66710: LD_VAR 0 6
66714: PUSH
66715: LD_VAR 0 6
66719: PUSH
66720: LD_VAR 0 3
66724: ARRAY
66725: DIFF
66726: ST_TO_ADDR
66727: GO 66702
66729: POP
66730: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66731: LD_ADDR_VAR 0 4
66735: PUSH
66736: LD_VAR 0 4
66740: PUSH
66741: LD_VAR 0 5
66745: PUSH
66746: LD_VAR 0 6
66750: UNION
66751: PUSH
66752: LD_VAR 0 7
66756: UNION
66757: PUSH
66758: LD_VAR 0 8
66762: UNION
66763: DIFF
66764: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66765: LD_ADDR_VAR 0 13
66769: PUSH
66770: LD_EXP 31
66774: PUSH
66775: LD_VAR 0 1
66779: ARRAY
66780: PPUSH
66781: LD_INT 2
66783: PUSH
66784: LD_INT 30
66786: PUSH
66787: LD_INT 32
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: PUSH
66794: LD_INT 30
66796: PUSH
66797: LD_INT 31
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: LIST
66808: PPUSH
66809: CALL_OW 72
66813: PUSH
66814: LD_EXP 31
66818: PUSH
66819: LD_VAR 0 1
66823: ARRAY
66824: PPUSH
66825: LD_INT 2
66827: PUSH
66828: LD_INT 30
66830: PUSH
66831: LD_INT 4
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: PUSH
66838: LD_INT 30
66840: PUSH
66841: LD_INT 5
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: LIST
66852: PPUSH
66853: CALL_OW 72
66857: PUSH
66858: LD_INT 6
66860: MUL
66861: PLUS
66862: ST_TO_ADDR
// if bcount < tmp then
66863: LD_VAR 0 13
66867: PUSH
66868: LD_VAR 0 4
66872: LESS
66873: IFFALSE 66919
// for i = tmp downto bcount do
66875: LD_ADDR_VAR 0 3
66879: PUSH
66880: DOUBLE
66881: LD_VAR 0 4
66885: INC
66886: ST_TO_ADDR
66887: LD_VAR 0 13
66891: PUSH
66892: FOR_DOWNTO
66893: IFFALSE 66917
// tmp := Delete ( tmp , tmp ) ;
66895: LD_ADDR_VAR 0 4
66899: PUSH
66900: LD_VAR 0 4
66904: PPUSH
66905: LD_VAR 0 4
66909: PPUSH
66910: CALL_OW 3
66914: ST_TO_ADDR
66915: GO 66892
66917: POP
66918: POP
// result := [ tmp , 0 , 0 , p ] ;
66919: LD_ADDR_VAR 0 2
66923: PUSH
66924: LD_VAR 0 4
66928: PUSH
66929: LD_INT 0
66931: PUSH
66932: LD_INT 0
66934: PUSH
66935: LD_VAR 0 11
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: LIST
66944: LIST
66945: ST_TO_ADDR
// exit ;
66946: GO 69636
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66948: LD_EXP 31
66952: PUSH
66953: LD_VAR 0 1
66957: ARRAY
66958: PPUSH
66959: LD_INT 2
66961: PUSH
66962: LD_INT 30
66964: PUSH
66965: LD_INT 6
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 30
66974: PUSH
66975: LD_INT 7
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: PUSH
66982: LD_INT 30
66984: PUSH
66985: LD_INT 8
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: LIST
66996: LIST
66997: PPUSH
66998: CALL_OW 72
67002: NOT
67003: PUSH
67004: LD_EXP 31
67008: PUSH
67009: LD_VAR 0 1
67013: ARRAY
67014: PPUSH
67015: LD_INT 30
67017: PUSH
67018: LD_INT 3
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PPUSH
67025: CALL_OW 72
67029: NOT
67030: AND
67031: IFFALSE 67103
// begin if eng = tmp then
67033: LD_VAR 0 6
67037: PUSH
67038: LD_VAR 0 4
67042: EQUAL
67043: IFFALSE 67047
// exit ;
67045: GO 69636
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
67047: LD_ADDR_EXP 73
67051: PUSH
67052: LD_EXP 73
67056: PPUSH
67057: LD_VAR 0 1
67061: PPUSH
67062: LD_INT 1
67064: PPUSH
67065: CALL_OW 1
67069: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
67070: LD_ADDR_VAR 0 2
67074: PUSH
67075: LD_INT 0
67077: PUSH
67078: LD_VAR 0 4
67082: PUSH
67083: LD_VAR 0 6
67087: DIFF
67088: PUSH
67089: LD_INT 0
67091: PUSH
67092: LD_INT 0
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: LIST
67099: LIST
67100: ST_TO_ADDR
// exit ;
67101: GO 69636
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67103: LD_EXP 58
67107: PUSH
67108: LD_EXP 57
67112: PUSH
67113: LD_VAR 0 1
67117: ARRAY
67118: ARRAY
67119: PUSH
67120: LD_EXP 31
67124: PUSH
67125: LD_VAR 0 1
67129: ARRAY
67130: PPUSH
67131: LD_INT 2
67133: PUSH
67134: LD_INT 30
67136: PUSH
67137: LD_INT 6
67139: PUSH
67140: EMPTY
67141: LIST
67142: LIST
67143: PUSH
67144: LD_INT 30
67146: PUSH
67147: LD_INT 7
67149: PUSH
67150: EMPTY
67151: LIST
67152: LIST
67153: PUSH
67154: LD_INT 30
67156: PUSH
67157: LD_INT 8
67159: PUSH
67160: EMPTY
67161: LIST
67162: LIST
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: LIST
67168: LIST
67169: PPUSH
67170: CALL_OW 72
67174: AND
67175: PUSH
67176: LD_EXP 31
67180: PUSH
67181: LD_VAR 0 1
67185: ARRAY
67186: PPUSH
67187: LD_INT 30
67189: PUSH
67190: LD_INT 3
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PPUSH
67197: CALL_OW 72
67201: NOT
67202: AND
67203: IFFALSE 67417
// begin if sci >= 6 then
67205: LD_VAR 0 8
67209: PUSH
67210: LD_INT 6
67212: GREATEREQUAL
67213: IFFALSE 67217
// exit ;
67215: GO 69636
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
67217: LD_ADDR_EXP 73
67221: PUSH
67222: LD_EXP 73
67226: PPUSH
67227: LD_VAR 0 1
67231: PPUSH
67232: LD_INT 2
67234: PPUSH
67235: CALL_OW 1
67239: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
67240: LD_ADDR_VAR 0 9
67244: PUSH
67245: LD_VAR 0 4
67249: PUSH
67250: LD_VAR 0 8
67254: DIFF
67255: PPUSH
67256: LD_INT 4
67258: PPUSH
67259: CALL 55868 0 2
67263: ST_TO_ADDR
// p := [ ] ;
67264: LD_ADDR_VAR 0 11
67268: PUSH
67269: EMPTY
67270: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67271: LD_VAR 0 8
67275: PUSH
67276: LD_INT 6
67278: LESS
67279: PUSH
67280: LD_VAR 0 9
67284: PUSH
67285: LD_INT 6
67287: GREATER
67288: AND
67289: IFFALSE 67370
// begin for i = 1 to 6 - sci do
67291: LD_ADDR_VAR 0 3
67295: PUSH
67296: DOUBLE
67297: LD_INT 1
67299: DEC
67300: ST_TO_ADDR
67301: LD_INT 6
67303: PUSH
67304: LD_VAR 0 8
67308: MINUS
67309: PUSH
67310: FOR_TO
67311: IFFALSE 67366
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67313: LD_ADDR_VAR 0 11
67317: PUSH
67318: LD_VAR 0 11
67322: PPUSH
67323: LD_VAR 0 11
67327: PUSH
67328: LD_INT 1
67330: PLUS
67331: PPUSH
67332: LD_VAR 0 9
67336: PUSH
67337: LD_INT 1
67339: ARRAY
67340: PPUSH
67341: CALL_OW 2
67345: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67346: LD_ADDR_VAR 0 9
67350: PUSH
67351: LD_VAR 0 9
67355: PPUSH
67356: LD_INT 1
67358: PPUSH
67359: CALL_OW 3
67363: ST_TO_ADDR
// end ;
67364: GO 67310
67366: POP
67367: POP
// end else
67368: GO 67390
// if sort then
67370: LD_VAR 0 9
67374: IFFALSE 67390
// p := sort [ 1 ] ;
67376: LD_ADDR_VAR 0 11
67380: PUSH
67381: LD_VAR 0 9
67385: PUSH
67386: LD_INT 1
67388: ARRAY
67389: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67390: LD_ADDR_VAR 0 2
67394: PUSH
67395: LD_INT 0
67397: PUSH
67398: LD_INT 0
67400: PUSH
67401: LD_INT 0
67403: PUSH
67404: LD_VAR 0 11
67408: PUSH
67409: EMPTY
67410: LIST
67411: LIST
67412: LIST
67413: LIST
67414: ST_TO_ADDR
// exit ;
67415: GO 69636
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67417: LD_EXP 58
67421: PUSH
67422: LD_EXP 57
67426: PUSH
67427: LD_VAR 0 1
67431: ARRAY
67432: ARRAY
67433: PUSH
67434: LD_EXP 31
67438: PUSH
67439: LD_VAR 0 1
67443: ARRAY
67444: PPUSH
67445: LD_INT 2
67447: PUSH
67448: LD_INT 30
67450: PUSH
67451: LD_INT 6
67453: PUSH
67454: EMPTY
67455: LIST
67456: LIST
67457: PUSH
67458: LD_INT 30
67460: PUSH
67461: LD_INT 7
67463: PUSH
67464: EMPTY
67465: LIST
67466: LIST
67467: PUSH
67468: LD_INT 30
67470: PUSH
67471: LD_INT 8
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: PPUSH
67484: CALL_OW 72
67488: AND
67489: PUSH
67490: LD_EXP 31
67494: PUSH
67495: LD_VAR 0 1
67499: ARRAY
67500: PPUSH
67501: LD_INT 30
67503: PUSH
67504: LD_INT 3
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PPUSH
67511: CALL_OW 72
67515: AND
67516: IFFALSE 68250
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67518: LD_ADDR_EXP 73
67522: PUSH
67523: LD_EXP 73
67527: PPUSH
67528: LD_VAR 0 1
67532: PPUSH
67533: LD_INT 3
67535: PPUSH
67536: CALL_OW 1
67540: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67541: LD_ADDR_VAR 0 2
67545: PUSH
67546: LD_INT 0
67548: PUSH
67549: LD_INT 0
67551: PUSH
67552: LD_INT 0
67554: PUSH
67555: LD_INT 0
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: ST_TO_ADDR
// if not eng then
67564: LD_VAR 0 6
67568: NOT
67569: IFFALSE 67632
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67571: LD_ADDR_VAR 0 11
67575: PUSH
67576: LD_VAR 0 4
67580: PPUSH
67581: LD_INT 2
67583: PPUSH
67584: CALL 55868 0 2
67588: PUSH
67589: LD_INT 1
67591: ARRAY
67592: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67593: LD_ADDR_VAR 0 2
67597: PUSH
67598: LD_VAR 0 2
67602: PPUSH
67603: LD_INT 2
67605: PPUSH
67606: LD_VAR 0 11
67610: PPUSH
67611: CALL_OW 1
67615: ST_TO_ADDR
// tmp := tmp diff p ;
67616: LD_ADDR_VAR 0 4
67620: PUSH
67621: LD_VAR 0 4
67625: PUSH
67626: LD_VAR 0 11
67630: DIFF
67631: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67632: LD_VAR 0 4
67636: PUSH
67637: LD_VAR 0 8
67641: PUSH
67642: LD_INT 6
67644: LESS
67645: AND
67646: IFFALSE 67834
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67648: LD_ADDR_VAR 0 9
67652: PUSH
67653: LD_VAR 0 4
67657: PUSH
67658: LD_VAR 0 8
67662: PUSH
67663: LD_VAR 0 7
67667: UNION
67668: DIFF
67669: PPUSH
67670: LD_INT 4
67672: PPUSH
67673: CALL 55868 0 2
67677: ST_TO_ADDR
// p := [ ] ;
67678: LD_ADDR_VAR 0 11
67682: PUSH
67683: EMPTY
67684: ST_TO_ADDR
// if sort then
67685: LD_VAR 0 9
67689: IFFALSE 67805
// for i = 1 to 6 - sci do
67691: LD_ADDR_VAR 0 3
67695: PUSH
67696: DOUBLE
67697: LD_INT 1
67699: DEC
67700: ST_TO_ADDR
67701: LD_INT 6
67703: PUSH
67704: LD_VAR 0 8
67708: MINUS
67709: PUSH
67710: FOR_TO
67711: IFFALSE 67803
// begin if i = sort then
67713: LD_VAR 0 3
67717: PUSH
67718: LD_VAR 0 9
67722: EQUAL
67723: IFFALSE 67727
// break ;
67725: GO 67803
// if GetClass ( i ) = 4 then
67727: LD_VAR 0 3
67731: PPUSH
67732: CALL_OW 257
67736: PUSH
67737: LD_INT 4
67739: EQUAL
67740: IFFALSE 67744
// continue ;
67742: GO 67710
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67744: LD_ADDR_VAR 0 11
67748: PUSH
67749: LD_VAR 0 11
67753: PPUSH
67754: LD_VAR 0 11
67758: PUSH
67759: LD_INT 1
67761: PLUS
67762: PPUSH
67763: LD_VAR 0 9
67767: PUSH
67768: LD_VAR 0 3
67772: ARRAY
67773: PPUSH
67774: CALL_OW 2
67778: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67779: LD_ADDR_VAR 0 4
67783: PUSH
67784: LD_VAR 0 4
67788: PUSH
67789: LD_VAR 0 9
67793: PUSH
67794: LD_VAR 0 3
67798: ARRAY
67799: DIFF
67800: ST_TO_ADDR
// end ;
67801: GO 67710
67803: POP
67804: POP
// if p then
67805: LD_VAR 0 11
67809: IFFALSE 67834
// result := Replace ( result , 4 , p ) ;
67811: LD_ADDR_VAR 0 2
67815: PUSH
67816: LD_VAR 0 2
67820: PPUSH
67821: LD_INT 4
67823: PPUSH
67824: LD_VAR 0 11
67828: PPUSH
67829: CALL_OW 1
67833: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67834: LD_VAR 0 4
67838: PUSH
67839: LD_VAR 0 7
67843: PUSH
67844: LD_INT 6
67846: LESS
67847: AND
67848: IFFALSE 68036
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67850: LD_ADDR_VAR 0 9
67854: PUSH
67855: LD_VAR 0 4
67859: PUSH
67860: LD_VAR 0 8
67864: PUSH
67865: LD_VAR 0 7
67869: UNION
67870: DIFF
67871: PPUSH
67872: LD_INT 3
67874: PPUSH
67875: CALL 55868 0 2
67879: ST_TO_ADDR
// p := [ ] ;
67880: LD_ADDR_VAR 0 11
67884: PUSH
67885: EMPTY
67886: ST_TO_ADDR
// if sort then
67887: LD_VAR 0 9
67891: IFFALSE 68007
// for i = 1 to 6 - mech do
67893: LD_ADDR_VAR 0 3
67897: PUSH
67898: DOUBLE
67899: LD_INT 1
67901: DEC
67902: ST_TO_ADDR
67903: LD_INT 6
67905: PUSH
67906: LD_VAR 0 7
67910: MINUS
67911: PUSH
67912: FOR_TO
67913: IFFALSE 68005
// begin if i = sort then
67915: LD_VAR 0 3
67919: PUSH
67920: LD_VAR 0 9
67924: EQUAL
67925: IFFALSE 67929
// break ;
67927: GO 68005
// if GetClass ( i ) = 3 then
67929: LD_VAR 0 3
67933: PPUSH
67934: CALL_OW 257
67938: PUSH
67939: LD_INT 3
67941: EQUAL
67942: IFFALSE 67946
// continue ;
67944: GO 67912
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67946: LD_ADDR_VAR 0 11
67950: PUSH
67951: LD_VAR 0 11
67955: PPUSH
67956: LD_VAR 0 11
67960: PUSH
67961: LD_INT 1
67963: PLUS
67964: PPUSH
67965: LD_VAR 0 9
67969: PUSH
67970: LD_VAR 0 3
67974: ARRAY
67975: PPUSH
67976: CALL_OW 2
67980: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67981: LD_ADDR_VAR 0 4
67985: PUSH
67986: LD_VAR 0 4
67990: PUSH
67991: LD_VAR 0 9
67995: PUSH
67996: LD_VAR 0 3
68000: ARRAY
68001: DIFF
68002: ST_TO_ADDR
// end ;
68003: GO 67912
68005: POP
68006: POP
// if p then
68007: LD_VAR 0 11
68011: IFFALSE 68036
// result := Replace ( result , 3 , p ) ;
68013: LD_ADDR_VAR 0 2
68017: PUSH
68018: LD_VAR 0 2
68022: PPUSH
68023: LD_INT 3
68025: PPUSH
68026: LD_VAR 0 11
68030: PPUSH
68031: CALL_OW 1
68035: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
68036: LD_VAR 0 4
68040: PUSH
68041: LD_INT 6
68043: GREATER
68044: PUSH
68045: LD_VAR 0 6
68049: PUSH
68050: LD_INT 6
68052: LESS
68053: AND
68054: IFFALSE 68248
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68056: LD_ADDR_VAR 0 9
68060: PUSH
68061: LD_VAR 0 4
68065: PUSH
68066: LD_VAR 0 8
68070: PUSH
68071: LD_VAR 0 7
68075: UNION
68076: PUSH
68077: LD_VAR 0 6
68081: UNION
68082: DIFF
68083: PPUSH
68084: LD_INT 2
68086: PPUSH
68087: CALL 55868 0 2
68091: ST_TO_ADDR
// p := [ ] ;
68092: LD_ADDR_VAR 0 11
68096: PUSH
68097: EMPTY
68098: ST_TO_ADDR
// if sort then
68099: LD_VAR 0 9
68103: IFFALSE 68219
// for i = 1 to 6 - eng do
68105: LD_ADDR_VAR 0 3
68109: PUSH
68110: DOUBLE
68111: LD_INT 1
68113: DEC
68114: ST_TO_ADDR
68115: LD_INT 6
68117: PUSH
68118: LD_VAR 0 6
68122: MINUS
68123: PUSH
68124: FOR_TO
68125: IFFALSE 68217
// begin if i = sort then
68127: LD_VAR 0 3
68131: PUSH
68132: LD_VAR 0 9
68136: EQUAL
68137: IFFALSE 68141
// break ;
68139: GO 68217
// if GetClass ( i ) = 2 then
68141: LD_VAR 0 3
68145: PPUSH
68146: CALL_OW 257
68150: PUSH
68151: LD_INT 2
68153: EQUAL
68154: IFFALSE 68158
// continue ;
68156: GO 68124
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68158: LD_ADDR_VAR 0 11
68162: PUSH
68163: LD_VAR 0 11
68167: PPUSH
68168: LD_VAR 0 11
68172: PUSH
68173: LD_INT 1
68175: PLUS
68176: PPUSH
68177: LD_VAR 0 9
68181: PUSH
68182: LD_VAR 0 3
68186: ARRAY
68187: PPUSH
68188: CALL_OW 2
68192: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68193: LD_ADDR_VAR 0 4
68197: PUSH
68198: LD_VAR 0 4
68202: PUSH
68203: LD_VAR 0 9
68207: PUSH
68208: LD_VAR 0 3
68212: ARRAY
68213: DIFF
68214: ST_TO_ADDR
// end ;
68215: GO 68124
68217: POP
68218: POP
// if p then
68219: LD_VAR 0 11
68223: IFFALSE 68248
// result := Replace ( result , 2 , p ) ;
68225: LD_ADDR_VAR 0 2
68229: PUSH
68230: LD_VAR 0 2
68234: PPUSH
68235: LD_INT 2
68237: PPUSH
68238: LD_VAR 0 11
68242: PPUSH
68243: CALL_OW 1
68247: ST_TO_ADDR
// end ; exit ;
68248: GO 69636
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
68250: LD_EXP 58
68254: PUSH
68255: LD_EXP 57
68259: PUSH
68260: LD_VAR 0 1
68264: ARRAY
68265: ARRAY
68266: NOT
68267: PUSH
68268: LD_EXP 31
68272: PUSH
68273: LD_VAR 0 1
68277: ARRAY
68278: PPUSH
68279: LD_INT 30
68281: PUSH
68282: LD_INT 3
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PPUSH
68289: CALL_OW 72
68293: AND
68294: PUSH
68295: LD_EXP 36
68299: PUSH
68300: LD_VAR 0 1
68304: ARRAY
68305: AND
68306: IFFALSE 68914
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68308: LD_ADDR_EXP 73
68312: PUSH
68313: LD_EXP 73
68317: PPUSH
68318: LD_VAR 0 1
68322: PPUSH
68323: LD_INT 5
68325: PPUSH
68326: CALL_OW 1
68330: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68331: LD_ADDR_VAR 0 2
68335: PUSH
68336: LD_INT 0
68338: PUSH
68339: LD_INT 0
68341: PUSH
68342: LD_INT 0
68344: PUSH
68345: LD_INT 0
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: LIST
68352: LIST
68353: ST_TO_ADDR
// if sci > 1 then
68354: LD_VAR 0 8
68358: PUSH
68359: LD_INT 1
68361: GREATER
68362: IFFALSE 68390
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68364: LD_ADDR_VAR 0 4
68368: PUSH
68369: LD_VAR 0 4
68373: PUSH
68374: LD_VAR 0 8
68378: PUSH
68379: LD_VAR 0 8
68383: PUSH
68384: LD_INT 1
68386: ARRAY
68387: DIFF
68388: DIFF
68389: ST_TO_ADDR
// if tmp and not sci then
68390: LD_VAR 0 4
68394: PUSH
68395: LD_VAR 0 8
68399: NOT
68400: AND
68401: IFFALSE 68470
// begin sort := SortBySkill ( tmp , 4 ) ;
68403: LD_ADDR_VAR 0 9
68407: PUSH
68408: LD_VAR 0 4
68412: PPUSH
68413: LD_INT 4
68415: PPUSH
68416: CALL 55868 0 2
68420: ST_TO_ADDR
// if sort then
68421: LD_VAR 0 9
68425: IFFALSE 68441
// p := sort [ 1 ] ;
68427: LD_ADDR_VAR 0 11
68431: PUSH
68432: LD_VAR 0 9
68436: PUSH
68437: LD_INT 1
68439: ARRAY
68440: ST_TO_ADDR
// if p then
68441: LD_VAR 0 11
68445: IFFALSE 68470
// result := Replace ( result , 4 , p ) ;
68447: LD_ADDR_VAR 0 2
68451: PUSH
68452: LD_VAR 0 2
68456: PPUSH
68457: LD_INT 4
68459: PPUSH
68460: LD_VAR 0 11
68464: PPUSH
68465: CALL_OW 1
68469: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68470: LD_ADDR_VAR 0 4
68474: PUSH
68475: LD_VAR 0 4
68479: PUSH
68480: LD_VAR 0 7
68484: DIFF
68485: ST_TO_ADDR
// if tmp and mech < 6 then
68486: LD_VAR 0 4
68490: PUSH
68491: LD_VAR 0 7
68495: PUSH
68496: LD_INT 6
68498: LESS
68499: AND
68500: IFFALSE 68688
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68502: LD_ADDR_VAR 0 9
68506: PUSH
68507: LD_VAR 0 4
68511: PUSH
68512: LD_VAR 0 8
68516: PUSH
68517: LD_VAR 0 7
68521: UNION
68522: DIFF
68523: PPUSH
68524: LD_INT 3
68526: PPUSH
68527: CALL 55868 0 2
68531: ST_TO_ADDR
// p := [ ] ;
68532: LD_ADDR_VAR 0 11
68536: PUSH
68537: EMPTY
68538: ST_TO_ADDR
// if sort then
68539: LD_VAR 0 9
68543: IFFALSE 68659
// for i = 1 to 6 - mech do
68545: LD_ADDR_VAR 0 3
68549: PUSH
68550: DOUBLE
68551: LD_INT 1
68553: DEC
68554: ST_TO_ADDR
68555: LD_INT 6
68557: PUSH
68558: LD_VAR 0 7
68562: MINUS
68563: PUSH
68564: FOR_TO
68565: IFFALSE 68657
// begin if i = sort then
68567: LD_VAR 0 3
68571: PUSH
68572: LD_VAR 0 9
68576: EQUAL
68577: IFFALSE 68581
// break ;
68579: GO 68657
// if GetClass ( i ) = 3 then
68581: LD_VAR 0 3
68585: PPUSH
68586: CALL_OW 257
68590: PUSH
68591: LD_INT 3
68593: EQUAL
68594: IFFALSE 68598
// continue ;
68596: GO 68564
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68598: LD_ADDR_VAR 0 11
68602: PUSH
68603: LD_VAR 0 11
68607: PPUSH
68608: LD_VAR 0 11
68612: PUSH
68613: LD_INT 1
68615: PLUS
68616: PPUSH
68617: LD_VAR 0 9
68621: PUSH
68622: LD_VAR 0 3
68626: ARRAY
68627: PPUSH
68628: CALL_OW 2
68632: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68633: LD_ADDR_VAR 0 4
68637: PUSH
68638: LD_VAR 0 4
68642: PUSH
68643: LD_VAR 0 9
68647: PUSH
68648: LD_VAR 0 3
68652: ARRAY
68653: DIFF
68654: ST_TO_ADDR
// end ;
68655: GO 68564
68657: POP
68658: POP
// if p then
68659: LD_VAR 0 11
68663: IFFALSE 68688
// result := Replace ( result , 3 , p ) ;
68665: LD_ADDR_VAR 0 2
68669: PUSH
68670: LD_VAR 0 2
68674: PPUSH
68675: LD_INT 3
68677: PPUSH
68678: LD_VAR 0 11
68682: PPUSH
68683: CALL_OW 1
68687: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68688: LD_ADDR_VAR 0 4
68692: PUSH
68693: LD_VAR 0 4
68697: PUSH
68698: LD_VAR 0 6
68702: DIFF
68703: ST_TO_ADDR
// if tmp and eng < 6 then
68704: LD_VAR 0 4
68708: PUSH
68709: LD_VAR 0 6
68713: PUSH
68714: LD_INT 6
68716: LESS
68717: AND
68718: IFFALSE 68912
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68720: LD_ADDR_VAR 0 9
68724: PUSH
68725: LD_VAR 0 4
68729: PUSH
68730: LD_VAR 0 8
68734: PUSH
68735: LD_VAR 0 7
68739: UNION
68740: PUSH
68741: LD_VAR 0 6
68745: UNION
68746: DIFF
68747: PPUSH
68748: LD_INT 2
68750: PPUSH
68751: CALL 55868 0 2
68755: ST_TO_ADDR
// p := [ ] ;
68756: LD_ADDR_VAR 0 11
68760: PUSH
68761: EMPTY
68762: ST_TO_ADDR
// if sort then
68763: LD_VAR 0 9
68767: IFFALSE 68883
// for i = 1 to 6 - eng do
68769: LD_ADDR_VAR 0 3
68773: PUSH
68774: DOUBLE
68775: LD_INT 1
68777: DEC
68778: ST_TO_ADDR
68779: LD_INT 6
68781: PUSH
68782: LD_VAR 0 6
68786: MINUS
68787: PUSH
68788: FOR_TO
68789: IFFALSE 68881
// begin if i = sort then
68791: LD_VAR 0 3
68795: PUSH
68796: LD_VAR 0 9
68800: EQUAL
68801: IFFALSE 68805
// break ;
68803: GO 68881
// if GetClass ( i ) = 2 then
68805: LD_VAR 0 3
68809: PPUSH
68810: CALL_OW 257
68814: PUSH
68815: LD_INT 2
68817: EQUAL
68818: IFFALSE 68822
// continue ;
68820: GO 68788
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68822: LD_ADDR_VAR 0 11
68826: PUSH
68827: LD_VAR 0 11
68831: PPUSH
68832: LD_VAR 0 11
68836: PUSH
68837: LD_INT 1
68839: PLUS
68840: PPUSH
68841: LD_VAR 0 9
68845: PUSH
68846: LD_VAR 0 3
68850: ARRAY
68851: PPUSH
68852: CALL_OW 2
68856: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68857: LD_ADDR_VAR 0 4
68861: PUSH
68862: LD_VAR 0 4
68866: PUSH
68867: LD_VAR 0 9
68871: PUSH
68872: LD_VAR 0 3
68876: ARRAY
68877: DIFF
68878: ST_TO_ADDR
// end ;
68879: GO 68788
68881: POP
68882: POP
// if p then
68883: LD_VAR 0 11
68887: IFFALSE 68912
// result := Replace ( result , 2 , p ) ;
68889: LD_ADDR_VAR 0 2
68893: PUSH
68894: LD_VAR 0 2
68898: PPUSH
68899: LD_INT 2
68901: PPUSH
68902: LD_VAR 0 11
68906: PPUSH
68907: CALL_OW 1
68911: ST_TO_ADDR
// end ; exit ;
68912: GO 69636
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
68914: LD_EXP 58
68918: PUSH
68919: LD_EXP 57
68923: PUSH
68924: LD_VAR 0 1
68928: ARRAY
68929: ARRAY
68930: NOT
68931: PUSH
68932: LD_EXP 31
68936: PUSH
68937: LD_VAR 0 1
68941: ARRAY
68942: PPUSH
68943: LD_INT 30
68945: PUSH
68946: LD_INT 3
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: PPUSH
68953: CALL_OW 72
68957: AND
68958: PUSH
68959: LD_EXP 36
68963: PUSH
68964: LD_VAR 0 1
68968: ARRAY
68969: NOT
68970: AND
68971: IFFALSE 69636
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
68973: LD_ADDR_EXP 73
68977: PUSH
68978: LD_EXP 73
68982: PPUSH
68983: LD_VAR 0 1
68987: PPUSH
68988: LD_INT 6
68990: PPUSH
68991: CALL_OW 1
68995: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68996: LD_ADDR_VAR 0 2
69000: PUSH
69001: LD_INT 0
69003: PUSH
69004: LD_INT 0
69006: PUSH
69007: LD_INT 0
69009: PUSH
69010: LD_INT 0
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: ST_TO_ADDR
// if sci >= 1 then
69019: LD_VAR 0 8
69023: PUSH
69024: LD_INT 1
69026: GREATEREQUAL
69027: IFFALSE 69049
// tmp := tmp diff sci [ 1 ] ;
69029: LD_ADDR_VAR 0 4
69033: PUSH
69034: LD_VAR 0 4
69038: PUSH
69039: LD_VAR 0 8
69043: PUSH
69044: LD_INT 1
69046: ARRAY
69047: DIFF
69048: ST_TO_ADDR
// if tmp and not sci then
69049: LD_VAR 0 4
69053: PUSH
69054: LD_VAR 0 8
69058: NOT
69059: AND
69060: IFFALSE 69129
// begin sort := SortBySkill ( tmp , 4 ) ;
69062: LD_ADDR_VAR 0 9
69066: PUSH
69067: LD_VAR 0 4
69071: PPUSH
69072: LD_INT 4
69074: PPUSH
69075: CALL 55868 0 2
69079: ST_TO_ADDR
// if sort then
69080: LD_VAR 0 9
69084: IFFALSE 69100
// p := sort [ 1 ] ;
69086: LD_ADDR_VAR 0 11
69090: PUSH
69091: LD_VAR 0 9
69095: PUSH
69096: LD_INT 1
69098: ARRAY
69099: ST_TO_ADDR
// if p then
69100: LD_VAR 0 11
69104: IFFALSE 69129
// result := Replace ( result , 4 , p ) ;
69106: LD_ADDR_VAR 0 2
69110: PUSH
69111: LD_VAR 0 2
69115: PPUSH
69116: LD_INT 4
69118: PPUSH
69119: LD_VAR 0 11
69123: PPUSH
69124: CALL_OW 1
69128: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69129: LD_ADDR_VAR 0 4
69133: PUSH
69134: LD_VAR 0 4
69138: PUSH
69139: LD_VAR 0 7
69143: DIFF
69144: ST_TO_ADDR
// if tmp and mech < 6 then
69145: LD_VAR 0 4
69149: PUSH
69150: LD_VAR 0 7
69154: PUSH
69155: LD_INT 6
69157: LESS
69158: AND
69159: IFFALSE 69341
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
69161: LD_ADDR_VAR 0 9
69165: PUSH
69166: LD_VAR 0 4
69170: PUSH
69171: LD_VAR 0 7
69175: DIFF
69176: PPUSH
69177: LD_INT 3
69179: PPUSH
69180: CALL 55868 0 2
69184: ST_TO_ADDR
// p := [ ] ;
69185: LD_ADDR_VAR 0 11
69189: PUSH
69190: EMPTY
69191: ST_TO_ADDR
// if sort then
69192: LD_VAR 0 9
69196: IFFALSE 69312
// for i = 1 to 6 - mech do
69198: LD_ADDR_VAR 0 3
69202: PUSH
69203: DOUBLE
69204: LD_INT 1
69206: DEC
69207: ST_TO_ADDR
69208: LD_INT 6
69210: PUSH
69211: LD_VAR 0 7
69215: MINUS
69216: PUSH
69217: FOR_TO
69218: IFFALSE 69310
// begin if i = sort then
69220: LD_VAR 0 3
69224: PUSH
69225: LD_VAR 0 9
69229: EQUAL
69230: IFFALSE 69234
// break ;
69232: GO 69310
// if GetClass ( i ) = 3 then
69234: LD_VAR 0 3
69238: PPUSH
69239: CALL_OW 257
69243: PUSH
69244: LD_INT 3
69246: EQUAL
69247: IFFALSE 69251
// continue ;
69249: GO 69217
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69251: LD_ADDR_VAR 0 11
69255: PUSH
69256: LD_VAR 0 11
69260: PPUSH
69261: LD_VAR 0 11
69265: PUSH
69266: LD_INT 1
69268: PLUS
69269: PPUSH
69270: LD_VAR 0 9
69274: PUSH
69275: LD_VAR 0 3
69279: ARRAY
69280: PPUSH
69281: CALL_OW 2
69285: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69286: LD_ADDR_VAR 0 4
69290: PUSH
69291: LD_VAR 0 4
69295: PUSH
69296: LD_VAR 0 9
69300: PUSH
69301: LD_VAR 0 3
69305: ARRAY
69306: DIFF
69307: ST_TO_ADDR
// end ;
69308: GO 69217
69310: POP
69311: POP
// if p then
69312: LD_VAR 0 11
69316: IFFALSE 69341
// result := Replace ( result , 3 , p ) ;
69318: LD_ADDR_VAR 0 2
69322: PUSH
69323: LD_VAR 0 2
69327: PPUSH
69328: LD_INT 3
69330: PPUSH
69331: LD_VAR 0 11
69335: PPUSH
69336: CALL_OW 1
69340: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69341: LD_ADDR_VAR 0 4
69345: PUSH
69346: LD_VAR 0 4
69350: PUSH
69351: LD_VAR 0 6
69355: DIFF
69356: ST_TO_ADDR
// if tmp and eng < 4 then
69357: LD_VAR 0 4
69361: PUSH
69362: LD_VAR 0 6
69366: PUSH
69367: LD_INT 4
69369: LESS
69370: AND
69371: IFFALSE 69561
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69373: LD_ADDR_VAR 0 9
69377: PUSH
69378: LD_VAR 0 4
69382: PUSH
69383: LD_VAR 0 7
69387: PUSH
69388: LD_VAR 0 6
69392: UNION
69393: DIFF
69394: PPUSH
69395: LD_INT 2
69397: PPUSH
69398: CALL 55868 0 2
69402: ST_TO_ADDR
// p := [ ] ;
69403: LD_ADDR_VAR 0 11
69407: PUSH
69408: EMPTY
69409: ST_TO_ADDR
// if sort then
69410: LD_VAR 0 9
69414: IFFALSE 69530
// for i = 1 to 4 - eng do
69416: LD_ADDR_VAR 0 3
69420: PUSH
69421: DOUBLE
69422: LD_INT 1
69424: DEC
69425: ST_TO_ADDR
69426: LD_INT 4
69428: PUSH
69429: LD_VAR 0 6
69433: MINUS
69434: PUSH
69435: FOR_TO
69436: IFFALSE 69528
// begin if i = sort then
69438: LD_VAR 0 3
69442: PUSH
69443: LD_VAR 0 9
69447: EQUAL
69448: IFFALSE 69452
// break ;
69450: GO 69528
// if GetClass ( i ) = 2 then
69452: LD_VAR 0 3
69456: PPUSH
69457: CALL_OW 257
69461: PUSH
69462: LD_INT 2
69464: EQUAL
69465: IFFALSE 69469
// continue ;
69467: GO 69435
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69469: LD_ADDR_VAR 0 11
69473: PUSH
69474: LD_VAR 0 11
69478: PPUSH
69479: LD_VAR 0 11
69483: PUSH
69484: LD_INT 1
69486: PLUS
69487: PPUSH
69488: LD_VAR 0 9
69492: PUSH
69493: LD_VAR 0 3
69497: ARRAY
69498: PPUSH
69499: CALL_OW 2
69503: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69504: LD_ADDR_VAR 0 4
69508: PUSH
69509: LD_VAR 0 4
69513: PUSH
69514: LD_VAR 0 9
69518: PUSH
69519: LD_VAR 0 3
69523: ARRAY
69524: DIFF
69525: ST_TO_ADDR
// end ;
69526: GO 69435
69528: POP
69529: POP
// if p then
69530: LD_VAR 0 11
69534: IFFALSE 69559
// result := Replace ( result , 2 , p ) ;
69536: LD_ADDR_VAR 0 2
69540: PUSH
69541: LD_VAR 0 2
69545: PPUSH
69546: LD_INT 2
69548: PPUSH
69549: LD_VAR 0 11
69553: PPUSH
69554: CALL_OW 1
69558: ST_TO_ADDR
// end else
69559: GO 69605
// for i = eng downto 5 do
69561: LD_ADDR_VAR 0 3
69565: PUSH
69566: DOUBLE
69567: LD_VAR 0 6
69571: INC
69572: ST_TO_ADDR
69573: LD_INT 5
69575: PUSH
69576: FOR_DOWNTO
69577: IFFALSE 69603
// tmp := tmp union eng [ i ] ;
69579: LD_ADDR_VAR 0 4
69583: PUSH
69584: LD_VAR 0 4
69588: PUSH
69589: LD_VAR 0 6
69593: PUSH
69594: LD_VAR 0 3
69598: ARRAY
69599: UNION
69600: ST_TO_ADDR
69601: GO 69576
69603: POP
69604: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69605: LD_ADDR_VAR 0 2
69609: PUSH
69610: LD_VAR 0 2
69614: PPUSH
69615: LD_INT 1
69617: PPUSH
69618: LD_VAR 0 4
69622: PUSH
69623: LD_VAR 0 5
69627: DIFF
69628: PPUSH
69629: CALL_OW 1
69633: ST_TO_ADDR
// exit ;
69634: GO 69636
// end ; end ;
69636: LD_VAR 0 2
69640: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69641: LD_INT 0
69643: PPUSH
69644: PPUSH
69645: PPUSH
// if not mc_bases then
69646: LD_EXP 31
69650: NOT
69651: IFFALSE 69655
// exit ;
69653: GO 69797
// for i = 1 to mc_bases do
69655: LD_ADDR_VAR 0 2
69659: PUSH
69660: DOUBLE
69661: LD_INT 1
69663: DEC
69664: ST_TO_ADDR
69665: LD_EXP 31
69669: PUSH
69670: FOR_TO
69671: IFFALSE 69788
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69673: LD_ADDR_VAR 0 3
69677: PUSH
69678: LD_EXP 31
69682: PUSH
69683: LD_VAR 0 2
69687: ARRAY
69688: PPUSH
69689: LD_INT 21
69691: PUSH
69692: LD_INT 3
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: PUSH
69699: LD_INT 3
69701: PUSH
69702: LD_INT 2
69704: PUSH
69705: LD_INT 30
69707: PUSH
69708: LD_INT 29
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 30
69717: PUSH
69718: LD_INT 30
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: LIST
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 3
69736: PUSH
69737: LD_INT 24
69739: PUSH
69740: LD_INT 1000
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: PUSH
69747: EMPTY
69748: LIST
69749: LIST
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: LIST
69755: PPUSH
69756: CALL_OW 72
69760: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69761: LD_ADDR_EXP 32
69765: PUSH
69766: LD_EXP 32
69770: PPUSH
69771: LD_VAR 0 2
69775: PPUSH
69776: LD_VAR 0 3
69780: PPUSH
69781: CALL_OW 1
69785: ST_TO_ADDR
// end ;
69786: GO 69670
69788: POP
69789: POP
// RaiseSailEvent ( 101 ) ;
69790: LD_INT 101
69792: PPUSH
69793: CALL_OW 427
// end ;
69797: LD_VAR 0 1
69801: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69802: LD_INT 0
69804: PPUSH
69805: PPUSH
69806: PPUSH
69807: PPUSH
69808: PPUSH
69809: PPUSH
69810: PPUSH
// if not mc_bases then
69811: LD_EXP 31
69815: NOT
69816: IFFALSE 69820
// exit ;
69818: GO 70382
// for i = 1 to mc_bases do
69820: LD_ADDR_VAR 0 2
69824: PUSH
69825: DOUBLE
69826: LD_INT 1
69828: DEC
69829: ST_TO_ADDR
69830: LD_EXP 31
69834: PUSH
69835: FOR_TO
69836: IFFALSE 70373
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69838: LD_ADDR_VAR 0 5
69842: PUSH
69843: LD_EXP 31
69847: PUSH
69848: LD_VAR 0 2
69852: ARRAY
69853: PUSH
69854: LD_EXP 60
69858: PUSH
69859: LD_VAR 0 2
69863: ARRAY
69864: UNION
69865: PPUSH
69866: LD_INT 21
69868: PUSH
69869: LD_INT 1
69871: PUSH
69872: EMPTY
69873: LIST
69874: LIST
69875: PUSH
69876: LD_INT 1
69878: PUSH
69879: LD_INT 3
69881: PUSH
69882: LD_INT 54
69884: PUSH
69885: EMPTY
69886: LIST
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: LD_INT 3
69894: PUSH
69895: LD_INT 24
69897: PUSH
69898: LD_INT 1000
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: LIST
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PPUSH
69918: CALL_OW 72
69922: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
69923: LD_ADDR_VAR 0 6
69927: PUSH
69928: LD_EXP 31
69932: PUSH
69933: LD_VAR 0 2
69937: ARRAY
69938: PPUSH
69939: LD_INT 21
69941: PUSH
69942: LD_INT 1
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: LD_INT 1
69951: PUSH
69952: LD_INT 3
69954: PUSH
69955: LD_INT 54
69957: PUSH
69958: EMPTY
69959: LIST
69960: PUSH
69961: EMPTY
69962: LIST
69963: LIST
69964: PUSH
69965: LD_INT 3
69967: PUSH
69968: LD_INT 24
69970: PUSH
69971: LD_INT 250
69973: PUSH
69974: EMPTY
69975: LIST
69976: LIST
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: EMPTY
69983: LIST
69984: LIST
69985: LIST
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PPUSH
69991: CALL_OW 72
69995: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
69996: LD_ADDR_VAR 0 7
70000: PUSH
70001: LD_VAR 0 5
70005: PUSH
70006: LD_VAR 0 6
70010: DIFF
70011: ST_TO_ADDR
// if not need_heal_1 then
70012: LD_VAR 0 6
70016: NOT
70017: IFFALSE 70050
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
70019: LD_ADDR_EXP 34
70023: PUSH
70024: LD_EXP 34
70028: PPUSH
70029: LD_VAR 0 2
70033: PUSH
70034: LD_INT 1
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: PPUSH
70041: EMPTY
70042: PPUSH
70043: CALL 25021 0 3
70047: ST_TO_ADDR
70048: GO 70120
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
70050: LD_ADDR_EXP 34
70054: PUSH
70055: LD_EXP 34
70059: PPUSH
70060: LD_VAR 0 2
70064: PUSH
70065: LD_INT 1
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PPUSH
70072: LD_EXP 34
70076: PUSH
70077: LD_VAR 0 2
70081: ARRAY
70082: PUSH
70083: LD_INT 1
70085: ARRAY
70086: PPUSH
70087: LD_INT 3
70089: PUSH
70090: LD_INT 24
70092: PUSH
70093: LD_INT 1000
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PPUSH
70104: CALL_OW 72
70108: PUSH
70109: LD_VAR 0 6
70113: UNION
70114: PPUSH
70115: CALL 25021 0 3
70119: ST_TO_ADDR
// if not need_heal_2 then
70120: LD_VAR 0 7
70124: NOT
70125: IFFALSE 70158
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
70127: LD_ADDR_EXP 34
70131: PUSH
70132: LD_EXP 34
70136: PPUSH
70137: LD_VAR 0 2
70141: PUSH
70142: LD_INT 2
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: PPUSH
70149: EMPTY
70150: PPUSH
70151: CALL 25021 0 3
70155: ST_TO_ADDR
70156: GO 70190
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
70158: LD_ADDR_EXP 34
70162: PUSH
70163: LD_EXP 34
70167: PPUSH
70168: LD_VAR 0 2
70172: PUSH
70173: LD_INT 2
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PPUSH
70180: LD_VAR 0 7
70184: PPUSH
70185: CALL 25021 0 3
70189: ST_TO_ADDR
// if need_heal_2 then
70190: LD_VAR 0 7
70194: IFFALSE 70355
// for j in need_heal_2 do
70196: LD_ADDR_VAR 0 3
70200: PUSH
70201: LD_VAR 0 7
70205: PUSH
70206: FOR_IN
70207: IFFALSE 70353
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70209: LD_ADDR_VAR 0 5
70213: PUSH
70214: LD_EXP 31
70218: PUSH
70219: LD_VAR 0 2
70223: ARRAY
70224: PPUSH
70225: LD_INT 2
70227: PUSH
70228: LD_INT 30
70230: PUSH
70231: LD_INT 6
70233: PUSH
70234: EMPTY
70235: LIST
70236: LIST
70237: PUSH
70238: LD_INT 30
70240: PUSH
70241: LD_INT 7
70243: PUSH
70244: EMPTY
70245: LIST
70246: LIST
70247: PUSH
70248: LD_INT 30
70250: PUSH
70251: LD_INT 8
70253: PUSH
70254: EMPTY
70255: LIST
70256: LIST
70257: PUSH
70258: LD_INT 30
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: LD_INT 30
70270: PUSH
70271: LD_INT 1
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: PPUSH
70286: CALL_OW 72
70290: ST_TO_ADDR
// if tmp then
70291: LD_VAR 0 5
70295: IFFALSE 70351
// begin k := NearestUnitToUnit ( tmp , j ) ;
70297: LD_ADDR_VAR 0 4
70301: PUSH
70302: LD_VAR 0 5
70306: PPUSH
70307: LD_VAR 0 3
70311: PPUSH
70312: CALL_OW 74
70316: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70317: LD_VAR 0 3
70321: PPUSH
70322: LD_VAR 0 4
70326: PPUSH
70327: CALL_OW 296
70331: PUSH
70332: LD_INT 5
70334: GREATER
70335: IFFALSE 70351
// ComMoveToNearbyEntrance ( j , k ) ;
70337: LD_VAR 0 3
70341: PPUSH
70342: LD_VAR 0 4
70346: PPUSH
70347: CALL 58229 0 2
// end ; end ;
70351: GO 70206
70353: POP
70354: POP
// if not need_heal_1 and not need_heal_2 then
70355: LD_VAR 0 6
70359: NOT
70360: PUSH
70361: LD_VAR 0 7
70365: NOT
70366: AND
70367: IFFALSE 70371
// continue ;
70369: GO 69835
// end ;
70371: GO 69835
70373: POP
70374: POP
// RaiseSailEvent ( 102 ) ;
70375: LD_INT 102
70377: PPUSH
70378: CALL_OW 427
// end ;
70382: LD_VAR 0 1
70386: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70387: LD_INT 0
70389: PPUSH
70390: PPUSH
70391: PPUSH
70392: PPUSH
70393: PPUSH
70394: PPUSH
70395: PPUSH
70396: PPUSH
// if not mc_bases then
70397: LD_EXP 31
70401: NOT
70402: IFFALSE 70406
// exit ;
70404: GO 71317
// for i = 1 to mc_bases do
70406: LD_ADDR_VAR 0 2
70410: PUSH
70411: DOUBLE
70412: LD_INT 1
70414: DEC
70415: ST_TO_ADDR
70416: LD_EXP 31
70420: PUSH
70421: FOR_TO
70422: IFFALSE 71315
// begin if not mc_building_need_repair [ i ] then
70424: LD_EXP 32
70428: PUSH
70429: LD_VAR 0 2
70433: ARRAY
70434: NOT
70435: IFFALSE 70620
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70437: LD_ADDR_VAR 0 6
70441: PUSH
70442: LD_EXP 50
70446: PUSH
70447: LD_VAR 0 2
70451: ARRAY
70452: PPUSH
70453: LD_INT 3
70455: PUSH
70456: LD_INT 24
70458: PUSH
70459: LD_INT 1000
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 2
70472: PUSH
70473: LD_INT 34
70475: PUSH
70476: LD_INT 13
70478: PUSH
70479: EMPTY
70480: LIST
70481: LIST
70482: PUSH
70483: LD_INT 34
70485: PUSH
70486: LD_INT 52
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 34
70495: PUSH
70496: LD_INT 88
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PPUSH
70513: CALL_OW 72
70517: ST_TO_ADDR
// if cranes then
70518: LD_VAR 0 6
70522: IFFALSE 70584
// for j in cranes do
70524: LD_ADDR_VAR 0 3
70528: PUSH
70529: LD_VAR 0 6
70533: PUSH
70534: FOR_IN
70535: IFFALSE 70582
// if not IsInArea ( j , mc_parking [ i ] ) then
70537: LD_VAR 0 3
70541: PPUSH
70542: LD_EXP 55
70546: PUSH
70547: LD_VAR 0 2
70551: ARRAY
70552: PPUSH
70553: CALL_OW 308
70557: NOT
70558: IFFALSE 70580
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70560: LD_VAR 0 3
70564: PPUSH
70565: LD_EXP 55
70569: PUSH
70570: LD_VAR 0 2
70574: ARRAY
70575: PPUSH
70576: CALL_OW 113
70580: GO 70534
70582: POP
70583: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70584: LD_ADDR_EXP 33
70588: PUSH
70589: LD_EXP 33
70593: PPUSH
70594: LD_VAR 0 2
70598: PPUSH
70599: EMPTY
70600: PPUSH
70601: CALL_OW 1
70605: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70606: LD_VAR 0 2
70610: PPUSH
70611: LD_INT 101
70613: PPUSH
70614: CALL 65474 0 2
// continue ;
70618: GO 70421
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70620: LD_ADDR_EXP 37
70624: PUSH
70625: LD_EXP 37
70629: PPUSH
70630: LD_VAR 0 2
70634: PPUSH
70635: EMPTY
70636: PPUSH
70637: CALL_OW 1
70641: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70642: LD_VAR 0 2
70646: PPUSH
70647: LD_INT 103
70649: PPUSH
70650: CALL 65474 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70654: LD_ADDR_VAR 0 5
70658: PUSH
70659: LD_EXP 31
70663: PUSH
70664: LD_VAR 0 2
70668: ARRAY
70669: PUSH
70670: LD_EXP 60
70674: PUSH
70675: LD_VAR 0 2
70679: ARRAY
70680: UNION
70681: PPUSH
70682: LD_INT 2
70684: PUSH
70685: LD_INT 25
70687: PUSH
70688: LD_INT 2
70690: PUSH
70691: EMPTY
70692: LIST
70693: LIST
70694: PUSH
70695: LD_INT 25
70697: PUSH
70698: LD_INT 16
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: LIST
70709: PUSH
70710: EMPTY
70711: LIST
70712: PPUSH
70713: CALL_OW 72
70717: ST_TO_ADDR
// if mc_need_heal [ i ] then
70718: LD_EXP 34
70722: PUSH
70723: LD_VAR 0 2
70727: ARRAY
70728: IFFALSE 70772
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70730: LD_ADDR_VAR 0 5
70734: PUSH
70735: LD_VAR 0 5
70739: PUSH
70740: LD_EXP 34
70744: PUSH
70745: LD_VAR 0 2
70749: ARRAY
70750: PUSH
70751: LD_INT 1
70753: ARRAY
70754: PUSH
70755: LD_EXP 34
70759: PUSH
70760: LD_VAR 0 2
70764: ARRAY
70765: PUSH
70766: LD_INT 2
70768: ARRAY
70769: UNION
70770: DIFF
70771: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70772: LD_ADDR_VAR 0 6
70776: PUSH
70777: LD_EXP 50
70781: PUSH
70782: LD_VAR 0 2
70786: ARRAY
70787: PPUSH
70788: LD_INT 2
70790: PUSH
70791: LD_INT 34
70793: PUSH
70794: LD_INT 13
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 34
70803: PUSH
70804: LD_INT 52
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 34
70813: PUSH
70814: LD_INT 88
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: LIST
70825: LIST
70826: PPUSH
70827: CALL_OW 72
70831: ST_TO_ADDR
// if cranes then
70832: LD_VAR 0 6
70836: IFFALSE 71004
// begin for j in cranes do
70838: LD_ADDR_VAR 0 3
70842: PUSH
70843: LD_VAR 0 6
70847: PUSH
70848: FOR_IN
70849: IFFALSE 71002
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70851: LD_VAR 0 3
70855: PPUSH
70856: CALL_OW 256
70860: PUSH
70861: LD_INT 1000
70863: EQUAL
70864: PUSH
70865: LD_VAR 0 3
70869: PPUSH
70870: CALL_OW 314
70874: NOT
70875: AND
70876: IFFALSE 70942
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
70878: LD_ADDR_VAR 0 8
70882: PUSH
70883: LD_EXP 32
70887: PUSH
70888: LD_VAR 0 2
70892: ARRAY
70893: PPUSH
70894: LD_VAR 0 3
70898: PPUSH
70899: CALL_OW 74
70903: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
70904: LD_VAR 0 8
70908: PPUSH
70909: LD_INT 16
70911: PPUSH
70912: CALL 27618 0 2
70916: PUSH
70917: LD_INT 4
70919: ARRAY
70920: PUSH
70921: LD_INT 10
70923: LESS
70924: IFFALSE 70940
// ComRepairBuilding ( j , to_repair ) ;
70926: LD_VAR 0 3
70930: PPUSH
70931: LD_VAR 0 8
70935: PPUSH
70936: CALL_OW 130
// end else
70940: GO 71000
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
70942: LD_VAR 0 3
70946: PPUSH
70947: CALL_OW 256
70951: PUSH
70952: LD_INT 500
70954: LESS
70955: PUSH
70956: LD_VAR 0 3
70960: PPUSH
70961: LD_EXP 55
70965: PUSH
70966: LD_VAR 0 2
70970: ARRAY
70971: PPUSH
70972: CALL_OW 308
70976: NOT
70977: AND
70978: IFFALSE 71000
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70980: LD_VAR 0 3
70984: PPUSH
70985: LD_EXP 55
70989: PUSH
70990: LD_VAR 0 2
70994: ARRAY
70995: PPUSH
70996: CALL_OW 113
// end ;
71000: GO 70848
71002: POP
71003: POP
// end ; if tmp > 3 then
71004: LD_VAR 0 5
71008: PUSH
71009: LD_INT 3
71011: GREATER
71012: IFFALSE 71032
// tmp := ShrinkArray ( tmp , 4 ) ;
71014: LD_ADDR_VAR 0 5
71018: PUSH
71019: LD_VAR 0 5
71023: PPUSH
71024: LD_INT 4
71026: PPUSH
71027: CALL 57667 0 2
71031: ST_TO_ADDR
// if not tmp then
71032: LD_VAR 0 5
71036: NOT
71037: IFFALSE 71041
// continue ;
71039: GO 70421
// for j in tmp do
71041: LD_ADDR_VAR 0 3
71045: PUSH
71046: LD_VAR 0 5
71050: PUSH
71051: FOR_IN
71052: IFFALSE 71311
// begin if IsInUnit ( j ) then
71054: LD_VAR 0 3
71058: PPUSH
71059: CALL_OW 310
71063: IFFALSE 71074
// ComExitBuilding ( j ) ;
71065: LD_VAR 0 3
71069: PPUSH
71070: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
71074: LD_VAR 0 3
71078: PUSH
71079: LD_EXP 33
71083: PUSH
71084: LD_VAR 0 2
71088: ARRAY
71089: IN
71090: NOT
71091: IFFALSE 71149
// begin SetTag ( j , 101 ) ;
71093: LD_VAR 0 3
71097: PPUSH
71098: LD_INT 101
71100: PPUSH
71101: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
71105: LD_ADDR_EXP 33
71109: PUSH
71110: LD_EXP 33
71114: PPUSH
71115: LD_VAR 0 2
71119: PUSH
71120: LD_EXP 33
71124: PUSH
71125: LD_VAR 0 2
71129: ARRAY
71130: PUSH
71131: LD_INT 1
71133: PLUS
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PPUSH
71139: LD_VAR 0 3
71143: PPUSH
71144: CALL 25021 0 3
71148: ST_TO_ADDR
// end ; wait ( 1 ) ;
71149: LD_INT 1
71151: PPUSH
71152: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
71156: LD_ADDR_VAR 0 7
71160: PUSH
71161: LD_EXP 32
71165: PUSH
71166: LD_VAR 0 2
71170: ARRAY
71171: ST_TO_ADDR
// if mc_scan [ i ] then
71172: LD_EXP 54
71176: PUSH
71177: LD_VAR 0 2
71181: ARRAY
71182: IFFALSE 71244
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
71184: LD_ADDR_VAR 0 7
71188: PUSH
71189: LD_EXP 32
71193: PUSH
71194: LD_VAR 0 2
71198: ARRAY
71199: PPUSH
71200: LD_INT 3
71202: PUSH
71203: LD_INT 30
71205: PUSH
71206: LD_INT 32
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: LD_INT 30
71215: PUSH
71216: LD_INT 33
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 30
71225: PUSH
71226: LD_INT 31
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: LIST
71237: LIST
71238: PPUSH
71239: CALL_OW 72
71243: ST_TO_ADDR
// if not to_repair_tmp then
71244: LD_VAR 0 7
71248: NOT
71249: IFFALSE 71253
// continue ;
71251: GO 71051
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
71253: LD_ADDR_VAR 0 8
71257: PUSH
71258: LD_VAR 0 7
71262: PPUSH
71263: LD_VAR 0 3
71267: PPUSH
71268: CALL_OW 74
71272: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
71273: LD_VAR 0 8
71277: PPUSH
71278: LD_INT 16
71280: PPUSH
71281: CALL 27618 0 2
71285: PUSH
71286: LD_INT 4
71288: ARRAY
71289: PUSH
71290: LD_INT 14
71292: LESS
71293: IFFALSE 71309
// ComRepairBuilding ( j , to_repair ) ;
71295: LD_VAR 0 3
71299: PPUSH
71300: LD_VAR 0 8
71304: PPUSH
71305: CALL_OW 130
// end ;
71309: GO 71051
71311: POP
71312: POP
// end ;
71313: GO 70421
71315: POP
71316: POP
// end ;
71317: LD_VAR 0 1
71321: RET
// export function MC_Heal ; var i , j , tmp ; begin
71322: LD_INT 0
71324: PPUSH
71325: PPUSH
71326: PPUSH
71327: PPUSH
// if not mc_bases then
71328: LD_EXP 31
71332: NOT
71333: IFFALSE 71337
// exit ;
71335: GO 71739
// for i = 1 to mc_bases do
71337: LD_ADDR_VAR 0 2
71341: PUSH
71342: DOUBLE
71343: LD_INT 1
71345: DEC
71346: ST_TO_ADDR
71347: LD_EXP 31
71351: PUSH
71352: FOR_TO
71353: IFFALSE 71737
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71355: LD_EXP 34
71359: PUSH
71360: LD_VAR 0 2
71364: ARRAY
71365: PUSH
71366: LD_INT 1
71368: ARRAY
71369: NOT
71370: PUSH
71371: LD_EXP 34
71375: PUSH
71376: LD_VAR 0 2
71380: ARRAY
71381: PUSH
71382: LD_INT 2
71384: ARRAY
71385: NOT
71386: AND
71387: IFFALSE 71425
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71389: LD_ADDR_EXP 35
71393: PUSH
71394: LD_EXP 35
71398: PPUSH
71399: LD_VAR 0 2
71403: PPUSH
71404: EMPTY
71405: PPUSH
71406: CALL_OW 1
71410: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71411: LD_VAR 0 2
71415: PPUSH
71416: LD_INT 102
71418: PPUSH
71419: CALL 65474 0 2
// continue ;
71423: GO 71352
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71425: LD_ADDR_VAR 0 4
71429: PUSH
71430: LD_EXP 31
71434: PUSH
71435: LD_VAR 0 2
71439: ARRAY
71440: PPUSH
71441: LD_INT 25
71443: PUSH
71444: LD_INT 4
71446: PUSH
71447: EMPTY
71448: LIST
71449: LIST
71450: PPUSH
71451: CALL_OW 72
71455: ST_TO_ADDR
// if not tmp then
71456: LD_VAR 0 4
71460: NOT
71461: IFFALSE 71465
// continue ;
71463: GO 71352
// if mc_taming [ i ] then
71465: LD_EXP 62
71469: PUSH
71470: LD_VAR 0 2
71474: ARRAY
71475: IFFALSE 71499
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71477: LD_ADDR_EXP 62
71481: PUSH
71482: LD_EXP 62
71486: PPUSH
71487: LD_VAR 0 2
71491: PPUSH
71492: EMPTY
71493: PPUSH
71494: CALL_OW 1
71498: ST_TO_ADDR
// for j in tmp do
71499: LD_ADDR_VAR 0 3
71503: PUSH
71504: LD_VAR 0 4
71508: PUSH
71509: FOR_IN
71510: IFFALSE 71733
// begin if IsInUnit ( j ) then
71512: LD_VAR 0 3
71516: PPUSH
71517: CALL_OW 310
71521: IFFALSE 71532
// ComExitBuilding ( j ) ;
71523: LD_VAR 0 3
71527: PPUSH
71528: CALL_OW 122
// if not j in mc_healers [ i ] then
71532: LD_VAR 0 3
71536: PUSH
71537: LD_EXP 35
71541: PUSH
71542: LD_VAR 0 2
71546: ARRAY
71547: IN
71548: NOT
71549: IFFALSE 71595
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71551: LD_ADDR_EXP 35
71555: PUSH
71556: LD_EXP 35
71560: PPUSH
71561: LD_VAR 0 2
71565: PUSH
71566: LD_EXP 35
71570: PUSH
71571: LD_VAR 0 2
71575: ARRAY
71576: PUSH
71577: LD_INT 1
71579: PLUS
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PPUSH
71585: LD_VAR 0 3
71589: PPUSH
71590: CALL 25021 0 3
71594: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71595: LD_VAR 0 3
71599: PPUSH
71600: CALL_OW 110
71604: PUSH
71605: LD_INT 102
71607: NONEQUAL
71608: IFFALSE 71622
// SetTag ( j , 102 ) ;
71610: LD_VAR 0 3
71614: PPUSH
71615: LD_INT 102
71617: PPUSH
71618: CALL_OW 109
// Wait ( 3 ) ;
71622: LD_INT 3
71624: PPUSH
71625: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71629: LD_EXP 34
71633: PUSH
71634: LD_VAR 0 2
71638: ARRAY
71639: PUSH
71640: LD_INT 1
71642: ARRAY
71643: IFFALSE 71675
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71645: LD_VAR 0 3
71649: PPUSH
71650: LD_EXP 34
71654: PUSH
71655: LD_VAR 0 2
71659: ARRAY
71660: PUSH
71661: LD_INT 1
71663: ARRAY
71664: PUSH
71665: LD_INT 1
71667: ARRAY
71668: PPUSH
71669: CALL_OW 128
71673: GO 71731
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71675: LD_VAR 0 3
71679: PPUSH
71680: CALL_OW 314
71684: NOT
71685: PUSH
71686: LD_EXP 34
71690: PUSH
71691: LD_VAR 0 2
71695: ARRAY
71696: PUSH
71697: LD_INT 2
71699: ARRAY
71700: AND
71701: IFFALSE 71731
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71703: LD_VAR 0 3
71707: PPUSH
71708: LD_EXP 34
71712: PUSH
71713: LD_VAR 0 2
71717: ARRAY
71718: PUSH
71719: LD_INT 2
71721: ARRAY
71722: PUSH
71723: LD_INT 1
71725: ARRAY
71726: PPUSH
71727: CALL_OW 128
// end ;
71731: GO 71509
71733: POP
71734: POP
// end ;
71735: GO 71352
71737: POP
71738: POP
// end ;
71739: LD_VAR 0 1
71743: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
71744: LD_INT 0
71746: PPUSH
71747: PPUSH
71748: PPUSH
71749: PPUSH
71750: PPUSH
71751: PPUSH
// if not mc_bases then
71752: LD_EXP 31
71756: NOT
71757: IFFALSE 71761
// exit ;
71759: GO 72924
// for i = 1 to mc_bases do
71761: LD_ADDR_VAR 0 2
71765: PUSH
71766: DOUBLE
71767: LD_INT 1
71769: DEC
71770: ST_TO_ADDR
71771: LD_EXP 31
71775: PUSH
71776: FOR_TO
71777: IFFALSE 72922
// begin if mc_scan [ i ] then
71779: LD_EXP 54
71783: PUSH
71784: LD_VAR 0 2
71788: ARRAY
71789: IFFALSE 71793
// continue ;
71791: GO 71776
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71793: LD_EXP 36
71797: PUSH
71798: LD_VAR 0 2
71802: ARRAY
71803: NOT
71804: PUSH
71805: LD_EXP 38
71809: PUSH
71810: LD_VAR 0 2
71814: ARRAY
71815: NOT
71816: AND
71817: PUSH
71818: LD_EXP 37
71822: PUSH
71823: LD_VAR 0 2
71827: ARRAY
71828: AND
71829: IFFALSE 71867
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71831: LD_ADDR_EXP 37
71835: PUSH
71836: LD_EXP 37
71840: PPUSH
71841: LD_VAR 0 2
71845: PPUSH
71846: EMPTY
71847: PPUSH
71848: CALL_OW 1
71852: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71853: LD_VAR 0 2
71857: PPUSH
71858: LD_INT 103
71860: PPUSH
71861: CALL 65474 0 2
// continue ;
71865: GO 71776
// end ; if mc_construct_list [ i ] then
71867: LD_EXP 38
71871: PUSH
71872: LD_VAR 0 2
71876: ARRAY
71877: IFFALSE 72097
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71879: LD_ADDR_VAR 0 5
71883: PUSH
71884: LD_EXP 31
71888: PUSH
71889: LD_VAR 0 2
71893: ARRAY
71894: PPUSH
71895: LD_INT 25
71897: PUSH
71898: LD_INT 2
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: PPUSH
71905: CALL_OW 72
71909: PUSH
71910: LD_EXP 33
71914: PUSH
71915: LD_VAR 0 2
71919: ARRAY
71920: DIFF
71921: ST_TO_ADDR
// if not tmp then
71922: LD_VAR 0 5
71926: NOT
71927: IFFALSE 71931
// continue ;
71929: GO 71776
// for j in tmp do
71931: LD_ADDR_VAR 0 3
71935: PUSH
71936: LD_VAR 0 5
71940: PUSH
71941: FOR_IN
71942: IFFALSE 72093
// begin if not mc_builders [ i ] then
71944: LD_EXP 37
71948: PUSH
71949: LD_VAR 0 2
71953: ARRAY
71954: NOT
71955: IFFALSE 72013
// begin SetTag ( j , 103 ) ;
71957: LD_VAR 0 3
71961: PPUSH
71962: LD_INT 103
71964: PPUSH
71965: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71969: LD_ADDR_EXP 37
71973: PUSH
71974: LD_EXP 37
71978: PPUSH
71979: LD_VAR 0 2
71983: PUSH
71984: LD_EXP 37
71988: PUSH
71989: LD_VAR 0 2
71993: ARRAY
71994: PUSH
71995: LD_INT 1
71997: PLUS
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PPUSH
72003: LD_VAR 0 3
72007: PPUSH
72008: CALL 25021 0 3
72012: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72013: LD_VAR 0 3
72017: PPUSH
72018: CALL_OW 310
72022: IFFALSE 72033
// ComExitBuilding ( j ) ;
72024: LD_VAR 0 3
72028: PPUSH
72029: CALL_OW 122
// wait ( 3 ) ;
72033: LD_INT 3
72035: PPUSH
72036: CALL_OW 67
// if not mc_construct_list [ i ] then
72040: LD_EXP 38
72044: PUSH
72045: LD_VAR 0 2
72049: ARRAY
72050: NOT
72051: IFFALSE 72055
// break ;
72053: GO 72093
// if not HasTask ( j ) then
72055: LD_VAR 0 3
72059: PPUSH
72060: CALL_OW 314
72064: NOT
72065: IFFALSE 72091
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
72067: LD_VAR 0 3
72071: PPUSH
72072: LD_EXP 38
72076: PUSH
72077: LD_VAR 0 2
72081: ARRAY
72082: PUSH
72083: LD_INT 1
72085: ARRAY
72086: PPUSH
72087: CALL 27882 0 2
// end ;
72091: GO 71941
72093: POP
72094: POP
// end else
72095: GO 72920
// if mc_build_list [ i ] then
72097: LD_EXP 36
72101: PUSH
72102: LD_VAR 0 2
72106: ARRAY
72107: IFFALSE 72920
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
72109: LD_EXP 36
72113: PUSH
72114: LD_VAR 0 2
72118: ARRAY
72119: PUSH
72120: LD_INT 1
72122: ARRAY
72123: PUSH
72124: LD_INT 1
72126: ARRAY
72127: PPUSH
72128: CALL 27706 0 1
72132: PUSH
72133: LD_EXP 31
72137: PUSH
72138: LD_VAR 0 2
72142: ARRAY
72143: PPUSH
72144: LD_INT 2
72146: PUSH
72147: LD_INT 30
72149: PUSH
72150: LD_INT 2
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 30
72159: PUSH
72160: LD_INT 3
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: LIST
72171: PPUSH
72172: CALL_OW 72
72176: NOT
72177: AND
72178: IFFALSE 72283
// begin for j = 1 to mc_build_list [ i ] do
72180: LD_ADDR_VAR 0 3
72184: PUSH
72185: DOUBLE
72186: LD_INT 1
72188: DEC
72189: ST_TO_ADDR
72190: LD_EXP 36
72194: PUSH
72195: LD_VAR 0 2
72199: ARRAY
72200: PUSH
72201: FOR_TO
72202: IFFALSE 72281
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
72204: LD_EXP 36
72208: PUSH
72209: LD_VAR 0 2
72213: ARRAY
72214: PUSH
72215: LD_VAR 0 3
72219: ARRAY
72220: PUSH
72221: LD_INT 1
72223: ARRAY
72224: PUSH
72225: LD_INT 2
72227: EQUAL
72228: IFFALSE 72279
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72230: LD_ADDR_EXP 36
72234: PUSH
72235: LD_EXP 36
72239: PPUSH
72240: LD_VAR 0 2
72244: PPUSH
72245: LD_EXP 36
72249: PUSH
72250: LD_VAR 0 2
72254: ARRAY
72255: PPUSH
72256: LD_VAR 0 3
72260: PPUSH
72261: LD_INT 1
72263: PPUSH
72264: LD_INT 0
72266: PPUSH
72267: CALL 24439 0 4
72271: PPUSH
72272: CALL_OW 1
72276: ST_TO_ADDR
// break ;
72277: GO 72281
// end ;
72279: GO 72201
72281: POP
72282: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72283: LD_ADDR_VAR 0 6
72287: PUSH
72288: LD_EXP 31
72292: PUSH
72293: LD_VAR 0 2
72297: ARRAY
72298: PPUSH
72299: LD_INT 2
72301: PUSH
72302: LD_INT 30
72304: PUSH
72305: LD_INT 0
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 30
72314: PUSH
72315: LD_INT 1
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: LIST
72326: PPUSH
72327: CALL_OW 72
72331: ST_TO_ADDR
// for k := 1 to depot do
72332: LD_ADDR_VAR 0 4
72336: PUSH
72337: DOUBLE
72338: LD_INT 1
72340: DEC
72341: ST_TO_ADDR
72342: LD_VAR 0 6
72346: PUSH
72347: FOR_TO
72348: IFFALSE 72918
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
72350: LD_EXP 36
72354: PUSH
72355: LD_VAR 0 2
72359: ARRAY
72360: PUSH
72361: LD_INT 1
72363: ARRAY
72364: PUSH
72365: LD_INT 1
72367: ARRAY
72368: PUSH
72369: LD_INT 0
72371: EQUAL
72372: PUSH
72373: LD_VAR 0 6
72377: PUSH
72378: LD_VAR 0 4
72382: ARRAY
72383: PPUSH
72384: LD_EXP 36
72388: PUSH
72389: LD_VAR 0 2
72393: ARRAY
72394: PUSH
72395: LD_INT 1
72397: ARRAY
72398: PUSH
72399: LD_INT 1
72401: ARRAY
72402: PPUSH
72403: LD_EXP 36
72407: PUSH
72408: LD_VAR 0 2
72412: ARRAY
72413: PUSH
72414: LD_INT 1
72416: ARRAY
72417: PUSH
72418: LD_INT 2
72420: ARRAY
72421: PPUSH
72422: LD_EXP 36
72426: PUSH
72427: LD_VAR 0 2
72431: ARRAY
72432: PUSH
72433: LD_INT 1
72435: ARRAY
72436: PUSH
72437: LD_INT 3
72439: ARRAY
72440: PPUSH
72441: LD_EXP 36
72445: PUSH
72446: LD_VAR 0 2
72450: ARRAY
72451: PUSH
72452: LD_INT 1
72454: ARRAY
72455: PUSH
72456: LD_INT 4
72458: ARRAY
72459: PPUSH
72460: CALL 33118 0 5
72464: OR
72465: IFFALSE 72746
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72467: LD_ADDR_VAR 0 5
72471: PUSH
72472: LD_EXP 31
72476: PUSH
72477: LD_VAR 0 2
72481: ARRAY
72482: PPUSH
72483: LD_INT 25
72485: PUSH
72486: LD_INT 2
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PPUSH
72493: CALL_OW 72
72497: PUSH
72498: LD_EXP 33
72502: PUSH
72503: LD_VAR 0 2
72507: ARRAY
72508: DIFF
72509: ST_TO_ADDR
// if not tmp then
72510: LD_VAR 0 5
72514: NOT
72515: IFFALSE 72519
// continue ;
72517: GO 72347
// for j in tmp do
72519: LD_ADDR_VAR 0 3
72523: PUSH
72524: LD_VAR 0 5
72528: PUSH
72529: FOR_IN
72530: IFFALSE 72742
// begin if not mc_builders [ i ] then
72532: LD_EXP 37
72536: PUSH
72537: LD_VAR 0 2
72541: ARRAY
72542: NOT
72543: IFFALSE 72601
// begin SetTag ( j , 103 ) ;
72545: LD_VAR 0 3
72549: PPUSH
72550: LD_INT 103
72552: PPUSH
72553: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72557: LD_ADDR_EXP 37
72561: PUSH
72562: LD_EXP 37
72566: PPUSH
72567: LD_VAR 0 2
72571: PUSH
72572: LD_EXP 37
72576: PUSH
72577: LD_VAR 0 2
72581: ARRAY
72582: PUSH
72583: LD_INT 1
72585: PLUS
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: PPUSH
72591: LD_VAR 0 3
72595: PPUSH
72596: CALL 25021 0 3
72600: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72601: LD_VAR 0 3
72605: PPUSH
72606: CALL_OW 310
72610: IFFALSE 72621
// ComExitBuilding ( j ) ;
72612: LD_VAR 0 3
72616: PPUSH
72617: CALL_OW 122
// wait ( 3 ) ;
72621: LD_INT 3
72623: PPUSH
72624: CALL_OW 67
// if not mc_build_list [ i ] then
72628: LD_EXP 36
72632: PUSH
72633: LD_VAR 0 2
72637: ARRAY
72638: NOT
72639: IFFALSE 72643
// break ;
72641: GO 72742
// if not HasTask ( j ) then
72643: LD_VAR 0 3
72647: PPUSH
72648: CALL_OW 314
72652: NOT
72653: IFFALSE 72740
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72655: LD_VAR 0 3
72659: PPUSH
72660: LD_EXP 36
72664: PUSH
72665: LD_VAR 0 2
72669: ARRAY
72670: PUSH
72671: LD_INT 1
72673: ARRAY
72674: PUSH
72675: LD_INT 1
72677: ARRAY
72678: PPUSH
72679: LD_EXP 36
72683: PUSH
72684: LD_VAR 0 2
72688: ARRAY
72689: PUSH
72690: LD_INT 1
72692: ARRAY
72693: PUSH
72694: LD_INT 2
72696: ARRAY
72697: PPUSH
72698: LD_EXP 36
72702: PUSH
72703: LD_VAR 0 2
72707: ARRAY
72708: PUSH
72709: LD_INT 1
72711: ARRAY
72712: PUSH
72713: LD_INT 3
72715: ARRAY
72716: PPUSH
72717: LD_EXP 36
72721: PUSH
72722: LD_VAR 0 2
72726: ARRAY
72727: PUSH
72728: LD_INT 1
72730: ARRAY
72731: PUSH
72732: LD_INT 4
72734: ARRAY
72735: PPUSH
72736: CALL_OW 145
// end ;
72740: GO 72529
72742: POP
72743: POP
// end else
72744: GO 72916
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72746: LD_EXP 31
72750: PUSH
72751: LD_VAR 0 2
72755: ARRAY
72756: PPUSH
72757: LD_EXP 36
72761: PUSH
72762: LD_VAR 0 2
72766: ARRAY
72767: PUSH
72768: LD_INT 1
72770: ARRAY
72771: PUSH
72772: LD_INT 1
72774: ARRAY
72775: PPUSH
72776: LD_EXP 36
72780: PUSH
72781: LD_VAR 0 2
72785: ARRAY
72786: PUSH
72787: LD_INT 1
72789: ARRAY
72790: PUSH
72791: LD_INT 2
72793: ARRAY
72794: PPUSH
72795: LD_EXP 36
72799: PUSH
72800: LD_VAR 0 2
72804: ARRAY
72805: PUSH
72806: LD_INT 1
72808: ARRAY
72809: PUSH
72810: LD_INT 3
72812: ARRAY
72813: PPUSH
72814: LD_EXP 36
72818: PUSH
72819: LD_VAR 0 2
72823: ARRAY
72824: PUSH
72825: LD_INT 1
72827: ARRAY
72828: PUSH
72829: LD_INT 4
72831: ARRAY
72832: PPUSH
72833: LD_EXP 31
72837: PUSH
72838: LD_VAR 0 2
72842: ARRAY
72843: PPUSH
72844: LD_INT 21
72846: PUSH
72847: LD_INT 3
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PPUSH
72854: CALL_OW 72
72858: PPUSH
72859: EMPTY
72860: PPUSH
72861: CALL 31872 0 7
72865: NOT
72866: IFFALSE 72916
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
72868: LD_ADDR_EXP 36
72872: PUSH
72873: LD_EXP 36
72877: PPUSH
72878: LD_VAR 0 2
72882: PPUSH
72883: LD_EXP 36
72887: PUSH
72888: LD_VAR 0 2
72892: ARRAY
72893: PPUSH
72894: LD_INT 1
72896: PPUSH
72897: LD_INT 1
72899: NEG
72900: PPUSH
72901: LD_INT 0
72903: PPUSH
72904: CALL 24439 0 4
72908: PPUSH
72909: CALL_OW 1
72913: ST_TO_ADDR
// continue ;
72914: GO 72347
// end ; end ;
72916: GO 72347
72918: POP
72919: POP
// end ; end ;
72920: GO 71776
72922: POP
72923: POP
// end ;
72924: LD_VAR 0 1
72928: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
72929: LD_INT 0
72931: PPUSH
72932: PPUSH
72933: PPUSH
72934: PPUSH
72935: PPUSH
72936: PPUSH
// if not mc_bases then
72937: LD_EXP 31
72941: NOT
72942: IFFALSE 72946
// exit ;
72944: GO 73373
// for i = 1 to mc_bases do
72946: LD_ADDR_VAR 0 2
72950: PUSH
72951: DOUBLE
72952: LD_INT 1
72954: DEC
72955: ST_TO_ADDR
72956: LD_EXP 31
72960: PUSH
72961: FOR_TO
72962: IFFALSE 73371
// begin tmp := mc_build_upgrade [ i ] ;
72964: LD_ADDR_VAR 0 4
72968: PUSH
72969: LD_EXP 63
72973: PUSH
72974: LD_VAR 0 2
72978: ARRAY
72979: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
72980: LD_ADDR_VAR 0 6
72984: PUSH
72985: LD_EXP 64
72989: PUSH
72990: LD_VAR 0 2
72994: ARRAY
72995: PPUSH
72996: LD_INT 2
72998: PUSH
72999: LD_INT 30
73001: PUSH
73002: LD_INT 6
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 30
73011: PUSH
73012: LD_INT 7
73014: PUSH
73015: EMPTY
73016: LIST
73017: LIST
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: LIST
73023: PPUSH
73024: CALL_OW 72
73028: ST_TO_ADDR
// if not tmp and not lab then
73029: LD_VAR 0 4
73033: NOT
73034: PUSH
73035: LD_VAR 0 6
73039: NOT
73040: AND
73041: IFFALSE 73045
// continue ;
73043: GO 72961
// if tmp then
73045: LD_VAR 0 4
73049: IFFALSE 73169
// for j in tmp do
73051: LD_ADDR_VAR 0 3
73055: PUSH
73056: LD_VAR 0 4
73060: PUSH
73061: FOR_IN
73062: IFFALSE 73167
// begin if UpgradeCost ( j ) then
73064: LD_VAR 0 3
73068: PPUSH
73069: CALL 31532 0 1
73073: IFFALSE 73165
// begin ComUpgrade ( j ) ;
73075: LD_VAR 0 3
73079: PPUSH
73080: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
73084: LD_ADDR_EXP 63
73088: PUSH
73089: LD_EXP 63
73093: PPUSH
73094: LD_VAR 0 2
73098: PPUSH
73099: LD_EXP 63
73103: PUSH
73104: LD_VAR 0 2
73108: ARRAY
73109: PUSH
73110: LD_VAR 0 3
73114: DIFF
73115: PPUSH
73116: CALL_OW 1
73120: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73121: LD_ADDR_EXP 38
73125: PUSH
73126: LD_EXP 38
73130: PPUSH
73131: LD_VAR 0 2
73135: PUSH
73136: LD_EXP 38
73140: PUSH
73141: LD_VAR 0 2
73145: ARRAY
73146: PUSH
73147: LD_INT 1
73149: PLUS
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PPUSH
73155: LD_VAR 0 3
73159: PPUSH
73160: CALL 25021 0 3
73164: ST_TO_ADDR
// end ; end ;
73165: GO 73061
73167: POP
73168: POP
// if not lab or not mc_lab_upgrade [ i ] then
73169: LD_VAR 0 6
73173: NOT
73174: PUSH
73175: LD_EXP 65
73179: PUSH
73180: LD_VAR 0 2
73184: ARRAY
73185: NOT
73186: OR
73187: IFFALSE 73191
// continue ;
73189: GO 72961
// for j in lab do
73191: LD_ADDR_VAR 0 3
73195: PUSH
73196: LD_VAR 0 6
73200: PUSH
73201: FOR_IN
73202: IFFALSE 73367
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
73204: LD_VAR 0 3
73208: PPUSH
73209: CALL_OW 266
73213: PUSH
73214: LD_INT 6
73216: PUSH
73217: LD_INT 7
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: IN
73224: PUSH
73225: LD_VAR 0 3
73229: PPUSH
73230: CALL_OW 461
73234: PUSH
73235: LD_INT 1
73237: NONEQUAL
73238: AND
73239: IFFALSE 73365
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
73241: LD_VAR 0 3
73245: PPUSH
73246: LD_EXP 65
73250: PUSH
73251: LD_VAR 0 2
73255: ARRAY
73256: PUSH
73257: LD_INT 1
73259: ARRAY
73260: PPUSH
73261: CALL 31737 0 2
73265: IFFALSE 73365
// begin ComCancel ( j ) ;
73267: LD_VAR 0 3
73271: PPUSH
73272: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73276: LD_VAR 0 3
73280: PPUSH
73281: LD_EXP 65
73285: PUSH
73286: LD_VAR 0 2
73290: ARRAY
73291: PUSH
73292: LD_INT 1
73294: ARRAY
73295: PPUSH
73296: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73300: LD_VAR 0 3
73304: PUSH
73305: LD_EXP 38
73309: PUSH
73310: LD_VAR 0 2
73314: ARRAY
73315: IN
73316: NOT
73317: IFFALSE 73363
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73319: LD_ADDR_EXP 38
73323: PUSH
73324: LD_EXP 38
73328: PPUSH
73329: LD_VAR 0 2
73333: PUSH
73334: LD_EXP 38
73338: PUSH
73339: LD_VAR 0 2
73343: ARRAY
73344: PUSH
73345: LD_INT 1
73347: PLUS
73348: PUSH
73349: EMPTY
73350: LIST
73351: LIST
73352: PPUSH
73353: LD_VAR 0 3
73357: PPUSH
73358: CALL 25021 0 3
73362: ST_TO_ADDR
// break ;
73363: GO 73367
// end ; end ; end ;
73365: GO 73201
73367: POP
73368: POP
// end ;
73369: GO 72961
73371: POP
73372: POP
// end ;
73373: LD_VAR 0 1
73377: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73378: LD_INT 0
73380: PPUSH
73381: PPUSH
73382: PPUSH
73383: PPUSH
73384: PPUSH
73385: PPUSH
73386: PPUSH
73387: PPUSH
73388: PPUSH
// if not mc_bases then
73389: LD_EXP 31
73393: NOT
73394: IFFALSE 73398
// exit ;
73396: GO 73803
// for i = 1 to mc_bases do
73398: LD_ADDR_VAR 0 2
73402: PUSH
73403: DOUBLE
73404: LD_INT 1
73406: DEC
73407: ST_TO_ADDR
73408: LD_EXP 31
73412: PUSH
73413: FOR_TO
73414: IFFALSE 73801
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73416: LD_EXP 39
73420: PUSH
73421: LD_VAR 0 2
73425: ARRAY
73426: NOT
73427: PUSH
73428: LD_EXP 31
73432: PUSH
73433: LD_VAR 0 2
73437: ARRAY
73438: PPUSH
73439: LD_INT 30
73441: PUSH
73442: LD_INT 3
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PPUSH
73449: CALL_OW 72
73453: NOT
73454: OR
73455: IFFALSE 73459
// continue ;
73457: GO 73413
// busy := false ;
73459: LD_ADDR_VAR 0 8
73463: PUSH
73464: LD_INT 0
73466: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73467: LD_ADDR_VAR 0 4
73471: PUSH
73472: LD_EXP 31
73476: PUSH
73477: LD_VAR 0 2
73481: ARRAY
73482: PPUSH
73483: LD_INT 30
73485: PUSH
73486: LD_INT 3
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PPUSH
73493: CALL_OW 72
73497: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73498: LD_ADDR_VAR 0 6
73502: PUSH
73503: LD_EXP 39
73507: PUSH
73508: LD_VAR 0 2
73512: ARRAY
73513: PPUSH
73514: LD_INT 2
73516: PUSH
73517: LD_INT 30
73519: PUSH
73520: LD_INT 32
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 30
73529: PUSH
73530: LD_INT 33
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: LIST
73541: PPUSH
73542: CALL_OW 72
73546: ST_TO_ADDR
// if not t then
73547: LD_VAR 0 6
73551: NOT
73552: IFFALSE 73556
// continue ;
73554: GO 73413
// for j in tmp do
73556: LD_ADDR_VAR 0 3
73560: PUSH
73561: LD_VAR 0 4
73565: PUSH
73566: FOR_IN
73567: IFFALSE 73597
// if not BuildingStatus ( j ) = bs_idle then
73569: LD_VAR 0 3
73573: PPUSH
73574: CALL_OW 461
73578: PUSH
73579: LD_INT 2
73581: EQUAL
73582: NOT
73583: IFFALSE 73595
// begin busy := true ;
73585: LD_ADDR_VAR 0 8
73589: PUSH
73590: LD_INT 1
73592: ST_TO_ADDR
// break ;
73593: GO 73597
// end ;
73595: GO 73566
73597: POP
73598: POP
// if busy then
73599: LD_VAR 0 8
73603: IFFALSE 73607
// continue ;
73605: GO 73413
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73607: LD_ADDR_VAR 0 7
73611: PUSH
73612: LD_VAR 0 6
73616: PPUSH
73617: LD_INT 35
73619: PUSH
73620: LD_INT 0
73622: PUSH
73623: EMPTY
73624: LIST
73625: LIST
73626: PPUSH
73627: CALL_OW 72
73631: ST_TO_ADDR
// if tw then
73632: LD_VAR 0 7
73636: IFFALSE 73713
// begin tw := tw [ 1 ] ;
73638: LD_ADDR_VAR 0 7
73642: PUSH
73643: LD_VAR 0 7
73647: PUSH
73648: LD_INT 1
73650: ARRAY
73651: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73652: LD_ADDR_VAR 0 9
73656: PUSH
73657: LD_VAR 0 7
73661: PPUSH
73662: LD_EXP 56
73666: PUSH
73667: LD_VAR 0 2
73671: ARRAY
73672: PPUSH
73673: CALL 30029 0 2
73677: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73678: LD_EXP 70
73682: PUSH
73683: LD_VAR 0 2
73687: ARRAY
73688: IFFALSE 73711
// if not weapon in mc_allowed_tower_weapons [ i ] then
73690: LD_VAR 0 9
73694: PUSH
73695: LD_EXP 70
73699: PUSH
73700: LD_VAR 0 2
73704: ARRAY
73705: IN
73706: NOT
73707: IFFALSE 73711
// continue ;
73709: GO 73413
// end else
73711: GO 73776
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73713: LD_ADDR_VAR 0 5
73717: PUSH
73718: LD_EXP 39
73722: PUSH
73723: LD_VAR 0 2
73727: ARRAY
73728: PPUSH
73729: LD_VAR 0 4
73733: PPUSH
73734: CALL 56900 0 2
73738: ST_TO_ADDR
// if not tmp2 then
73739: LD_VAR 0 5
73743: NOT
73744: IFFALSE 73748
// continue ;
73746: GO 73413
// tw := tmp2 [ 1 ] ;
73748: LD_ADDR_VAR 0 7
73752: PUSH
73753: LD_VAR 0 5
73757: PUSH
73758: LD_INT 1
73760: ARRAY
73761: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73762: LD_ADDR_VAR 0 9
73766: PUSH
73767: LD_VAR 0 5
73771: PUSH
73772: LD_INT 2
73774: ARRAY
73775: ST_TO_ADDR
// end ; if not weapon then
73776: LD_VAR 0 9
73780: NOT
73781: IFFALSE 73785
// continue ;
73783: GO 73413
// ComPlaceWeapon ( tw , weapon ) ;
73785: LD_VAR 0 7
73789: PPUSH
73790: LD_VAR 0 9
73794: PPUSH
73795: CALL_OW 148
// end ;
73799: GO 73413
73801: POP
73802: POP
// end ;
73803: LD_VAR 0 1
73807: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73808: LD_INT 0
73810: PPUSH
73811: PPUSH
73812: PPUSH
73813: PPUSH
73814: PPUSH
73815: PPUSH
73816: PPUSH
// if not mc_bases then
73817: LD_EXP 31
73821: NOT
73822: IFFALSE 73826
// exit ;
73824: GO 74594
// for i = 1 to mc_bases do
73826: LD_ADDR_VAR 0 2
73830: PUSH
73831: DOUBLE
73832: LD_INT 1
73834: DEC
73835: ST_TO_ADDR
73836: LD_EXP 31
73840: PUSH
73841: FOR_TO
73842: IFFALSE 74592
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73844: LD_EXP 44
73848: PUSH
73849: LD_VAR 0 2
73853: ARRAY
73854: NOT
73855: PUSH
73856: LD_EXP 44
73860: PUSH
73861: LD_VAR 0 2
73865: ARRAY
73866: PUSH
73867: LD_EXP 45
73871: PUSH
73872: LD_VAR 0 2
73876: ARRAY
73877: EQUAL
73878: OR
73879: PUSH
73880: LD_EXP 54
73884: PUSH
73885: LD_VAR 0 2
73889: ARRAY
73890: OR
73891: IFFALSE 73895
// continue ;
73893: GO 73841
// if mc_miners [ i ] then
73895: LD_EXP 45
73899: PUSH
73900: LD_VAR 0 2
73904: ARRAY
73905: IFFALSE 74279
// begin for j = mc_miners [ i ] downto 1 do
73907: LD_ADDR_VAR 0 3
73911: PUSH
73912: DOUBLE
73913: LD_EXP 45
73917: PUSH
73918: LD_VAR 0 2
73922: ARRAY
73923: INC
73924: ST_TO_ADDR
73925: LD_INT 1
73927: PUSH
73928: FOR_DOWNTO
73929: IFFALSE 74277
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
73931: LD_EXP 45
73935: PUSH
73936: LD_VAR 0 2
73940: ARRAY
73941: PUSH
73942: LD_VAR 0 3
73946: ARRAY
73947: PPUSH
73948: CALL_OW 301
73952: PUSH
73953: LD_EXP 45
73957: PUSH
73958: LD_VAR 0 2
73962: ARRAY
73963: PUSH
73964: LD_VAR 0 3
73968: ARRAY
73969: PPUSH
73970: CALL_OW 257
73974: PUSH
73975: LD_INT 1
73977: NONEQUAL
73978: OR
73979: IFFALSE 74042
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
73981: LD_ADDR_VAR 0 5
73985: PUSH
73986: LD_EXP 45
73990: PUSH
73991: LD_VAR 0 2
73995: ARRAY
73996: PUSH
73997: LD_EXP 45
74001: PUSH
74002: LD_VAR 0 2
74006: ARRAY
74007: PUSH
74008: LD_VAR 0 3
74012: ARRAY
74013: DIFF
74014: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
74015: LD_ADDR_EXP 45
74019: PUSH
74020: LD_EXP 45
74024: PPUSH
74025: LD_VAR 0 2
74029: PPUSH
74030: LD_VAR 0 5
74034: PPUSH
74035: CALL_OW 1
74039: ST_TO_ADDR
// continue ;
74040: GO 73928
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
74042: LD_EXP 45
74046: PUSH
74047: LD_VAR 0 2
74051: ARRAY
74052: PUSH
74053: LD_VAR 0 3
74057: ARRAY
74058: PPUSH
74059: CALL_OW 257
74063: PUSH
74064: LD_INT 1
74066: EQUAL
74067: PUSH
74068: LD_EXP 45
74072: PUSH
74073: LD_VAR 0 2
74077: ARRAY
74078: PUSH
74079: LD_VAR 0 3
74083: ARRAY
74084: PPUSH
74085: CALL_OW 459
74089: NOT
74090: AND
74091: PUSH
74092: LD_EXP 45
74096: PUSH
74097: LD_VAR 0 2
74101: ARRAY
74102: PUSH
74103: LD_VAR 0 3
74107: ARRAY
74108: PPUSH
74109: CALL_OW 314
74113: NOT
74114: AND
74115: IFFALSE 74275
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
74117: LD_EXP 45
74121: PUSH
74122: LD_VAR 0 2
74126: ARRAY
74127: PUSH
74128: LD_VAR 0 3
74132: ARRAY
74133: PPUSH
74134: CALL_OW 310
74138: IFFALSE 74161
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
74140: LD_EXP 45
74144: PUSH
74145: LD_VAR 0 2
74149: ARRAY
74150: PUSH
74151: LD_VAR 0 3
74155: ARRAY
74156: PPUSH
74157: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
74161: LD_EXP 45
74165: PUSH
74166: LD_VAR 0 2
74170: ARRAY
74171: PUSH
74172: LD_VAR 0 3
74176: ARRAY
74177: PPUSH
74178: CALL_OW 314
74182: NOT
74183: IFFALSE 74275
// begin r := rand ( 1 , mc_mines [ i ] ) ;
74185: LD_ADDR_VAR 0 7
74189: PUSH
74190: LD_INT 1
74192: PPUSH
74193: LD_EXP 44
74197: PUSH
74198: LD_VAR 0 2
74202: ARRAY
74203: PPUSH
74204: CALL_OW 12
74208: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
74209: LD_EXP 45
74213: PUSH
74214: LD_VAR 0 2
74218: ARRAY
74219: PUSH
74220: LD_VAR 0 3
74224: ARRAY
74225: PPUSH
74226: LD_EXP 44
74230: PUSH
74231: LD_VAR 0 2
74235: ARRAY
74236: PUSH
74237: LD_VAR 0 7
74241: ARRAY
74242: PUSH
74243: LD_INT 1
74245: ARRAY
74246: PPUSH
74247: LD_EXP 44
74251: PUSH
74252: LD_VAR 0 2
74256: ARRAY
74257: PUSH
74258: LD_VAR 0 7
74262: ARRAY
74263: PUSH
74264: LD_INT 2
74266: ARRAY
74267: PPUSH
74268: LD_INT 0
74270: PPUSH
74271: CALL_OW 193
// end ; end ; end ;
74275: GO 73928
74277: POP
74278: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74279: LD_ADDR_VAR 0 5
74283: PUSH
74284: LD_EXP 31
74288: PUSH
74289: LD_VAR 0 2
74293: ARRAY
74294: PPUSH
74295: LD_INT 2
74297: PUSH
74298: LD_INT 30
74300: PUSH
74301: LD_INT 4
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: PUSH
74308: LD_INT 30
74310: PUSH
74311: LD_INT 5
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 30
74320: PUSH
74321: LD_INT 32
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: LIST
74332: LIST
74333: PPUSH
74334: CALL_OW 72
74338: ST_TO_ADDR
// if not tmp then
74339: LD_VAR 0 5
74343: NOT
74344: IFFALSE 74348
// continue ;
74346: GO 73841
// list := [ ] ;
74348: LD_ADDR_VAR 0 6
74352: PUSH
74353: EMPTY
74354: ST_TO_ADDR
// for j in tmp do
74355: LD_ADDR_VAR 0 3
74359: PUSH
74360: LD_VAR 0 5
74364: PUSH
74365: FOR_IN
74366: IFFALSE 74435
// begin for k in UnitsInside ( j ) do
74368: LD_ADDR_VAR 0 4
74372: PUSH
74373: LD_VAR 0 3
74377: PPUSH
74378: CALL_OW 313
74382: PUSH
74383: FOR_IN
74384: IFFALSE 74431
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74386: LD_VAR 0 4
74390: PPUSH
74391: CALL_OW 257
74395: PUSH
74396: LD_INT 1
74398: EQUAL
74399: PUSH
74400: LD_VAR 0 4
74404: PPUSH
74405: CALL_OW 459
74409: NOT
74410: AND
74411: IFFALSE 74429
// list := list ^ k ;
74413: LD_ADDR_VAR 0 6
74417: PUSH
74418: LD_VAR 0 6
74422: PUSH
74423: LD_VAR 0 4
74427: ADD
74428: ST_TO_ADDR
74429: GO 74383
74431: POP
74432: POP
// end ;
74433: GO 74365
74435: POP
74436: POP
// list := list diff mc_miners [ i ] ;
74437: LD_ADDR_VAR 0 6
74441: PUSH
74442: LD_VAR 0 6
74446: PUSH
74447: LD_EXP 45
74451: PUSH
74452: LD_VAR 0 2
74456: ARRAY
74457: DIFF
74458: ST_TO_ADDR
// if not list then
74459: LD_VAR 0 6
74463: NOT
74464: IFFALSE 74468
// continue ;
74466: GO 73841
// k := mc_mines [ i ] - mc_miners [ i ] ;
74468: LD_ADDR_VAR 0 4
74472: PUSH
74473: LD_EXP 44
74477: PUSH
74478: LD_VAR 0 2
74482: ARRAY
74483: PUSH
74484: LD_EXP 45
74488: PUSH
74489: LD_VAR 0 2
74493: ARRAY
74494: MINUS
74495: ST_TO_ADDR
// if k > list then
74496: LD_VAR 0 4
74500: PUSH
74501: LD_VAR 0 6
74505: GREATER
74506: IFFALSE 74518
// k := list ;
74508: LD_ADDR_VAR 0 4
74512: PUSH
74513: LD_VAR 0 6
74517: ST_TO_ADDR
// for j = 1 to k do
74518: LD_ADDR_VAR 0 3
74522: PUSH
74523: DOUBLE
74524: LD_INT 1
74526: DEC
74527: ST_TO_ADDR
74528: LD_VAR 0 4
74532: PUSH
74533: FOR_TO
74534: IFFALSE 74588
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74536: LD_ADDR_EXP 45
74540: PUSH
74541: LD_EXP 45
74545: PPUSH
74546: LD_VAR 0 2
74550: PUSH
74551: LD_EXP 45
74555: PUSH
74556: LD_VAR 0 2
74560: ARRAY
74561: PUSH
74562: LD_INT 1
74564: PLUS
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PPUSH
74570: LD_VAR 0 6
74574: PUSH
74575: LD_VAR 0 3
74579: ARRAY
74580: PPUSH
74581: CALL 25021 0 3
74585: ST_TO_ADDR
74586: GO 74533
74588: POP
74589: POP
// end ;
74590: GO 73841
74592: POP
74593: POP
// end ;
74594: LD_VAR 0 1
74598: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74599: LD_INT 0
74601: PPUSH
74602: PPUSH
74603: PPUSH
74604: PPUSH
74605: PPUSH
74606: PPUSH
74607: PPUSH
74608: PPUSH
74609: PPUSH
74610: PPUSH
74611: PPUSH
// if not mc_bases then
74612: LD_EXP 31
74616: NOT
74617: IFFALSE 74621
// exit ;
74619: GO 76444
// for i = 1 to mc_bases do
74621: LD_ADDR_VAR 0 2
74625: PUSH
74626: DOUBLE
74627: LD_INT 1
74629: DEC
74630: ST_TO_ADDR
74631: LD_EXP 31
74635: PUSH
74636: FOR_TO
74637: IFFALSE 76442
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74639: LD_EXP 31
74643: PUSH
74644: LD_VAR 0 2
74648: ARRAY
74649: NOT
74650: PUSH
74651: LD_EXP 38
74655: PUSH
74656: LD_VAR 0 2
74660: ARRAY
74661: OR
74662: IFFALSE 74666
// continue ;
74664: GO 74636
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74666: LD_EXP 47
74670: PUSH
74671: LD_VAR 0 2
74675: ARRAY
74676: NOT
74677: PUSH
74678: LD_EXP 48
74682: PUSH
74683: LD_VAR 0 2
74687: ARRAY
74688: AND
74689: IFFALSE 74727
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74691: LD_ADDR_EXP 48
74695: PUSH
74696: LD_EXP 48
74700: PPUSH
74701: LD_VAR 0 2
74705: PPUSH
74706: EMPTY
74707: PPUSH
74708: CALL_OW 1
74712: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74713: LD_VAR 0 2
74717: PPUSH
74718: LD_INT 107
74720: PPUSH
74721: CALL 65474 0 2
// continue ;
74725: GO 74636
// end ; target := [ ] ;
74727: LD_ADDR_VAR 0 7
74731: PUSH
74732: EMPTY
74733: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74734: LD_ADDR_VAR 0 6
74738: PUSH
74739: LD_EXP 31
74743: PUSH
74744: LD_VAR 0 2
74748: ARRAY
74749: PUSH
74750: LD_INT 1
74752: ARRAY
74753: PPUSH
74754: CALL_OW 255
74758: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74759: LD_ADDR_VAR 0 9
74763: PUSH
74764: LD_EXP 31
74768: PUSH
74769: LD_VAR 0 2
74773: ARRAY
74774: PPUSH
74775: LD_INT 2
74777: PUSH
74778: LD_INT 30
74780: PUSH
74781: LD_INT 0
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PUSH
74788: LD_INT 30
74790: PUSH
74791: LD_INT 1
74793: PUSH
74794: EMPTY
74795: LIST
74796: LIST
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: LIST
74802: PPUSH
74803: CALL_OW 72
74807: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74808: LD_ADDR_VAR 0 3
74812: PUSH
74813: DOUBLE
74814: LD_EXP 47
74818: PUSH
74819: LD_VAR 0 2
74823: ARRAY
74824: INC
74825: ST_TO_ADDR
74826: LD_INT 1
74828: PUSH
74829: FOR_DOWNTO
74830: IFFALSE 75075
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74832: LD_EXP 47
74836: PUSH
74837: LD_VAR 0 2
74841: ARRAY
74842: PUSH
74843: LD_VAR 0 3
74847: ARRAY
74848: PUSH
74849: LD_INT 2
74851: ARRAY
74852: PPUSH
74853: LD_EXP 47
74857: PUSH
74858: LD_VAR 0 2
74862: ARRAY
74863: PUSH
74864: LD_VAR 0 3
74868: ARRAY
74869: PUSH
74870: LD_INT 3
74872: ARRAY
74873: PPUSH
74874: CALL_OW 488
74878: PUSH
74879: LD_EXP 47
74883: PUSH
74884: LD_VAR 0 2
74888: ARRAY
74889: PUSH
74890: LD_VAR 0 3
74894: ARRAY
74895: PUSH
74896: LD_INT 2
74898: ARRAY
74899: PPUSH
74900: LD_EXP 47
74904: PUSH
74905: LD_VAR 0 2
74909: ARRAY
74910: PUSH
74911: LD_VAR 0 3
74915: ARRAY
74916: PUSH
74917: LD_INT 3
74919: ARRAY
74920: PPUSH
74921: CALL_OW 284
74925: PUSH
74926: LD_INT 0
74928: EQUAL
74929: AND
74930: IFFALSE 74985
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
74932: LD_ADDR_VAR 0 5
74936: PUSH
74937: LD_EXP 47
74941: PUSH
74942: LD_VAR 0 2
74946: ARRAY
74947: PPUSH
74948: LD_VAR 0 3
74952: PPUSH
74953: CALL_OW 3
74957: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
74958: LD_ADDR_EXP 47
74962: PUSH
74963: LD_EXP 47
74967: PPUSH
74968: LD_VAR 0 2
74972: PPUSH
74973: LD_VAR 0 5
74977: PPUSH
74978: CALL_OW 1
74982: ST_TO_ADDR
// continue ;
74983: GO 74829
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
74985: LD_VAR 0 6
74989: PPUSH
74990: LD_EXP 47
74994: PUSH
74995: LD_VAR 0 2
74999: ARRAY
75000: PUSH
75001: LD_VAR 0 3
75005: ARRAY
75006: PUSH
75007: LD_INT 2
75009: ARRAY
75010: PPUSH
75011: LD_EXP 47
75015: PUSH
75016: LD_VAR 0 2
75020: ARRAY
75021: PUSH
75022: LD_VAR 0 3
75026: ARRAY
75027: PUSH
75028: LD_INT 3
75030: ARRAY
75031: PPUSH
75032: LD_INT 30
75034: PPUSH
75035: CALL 25917 0 4
75039: PUSH
75040: LD_INT 4
75042: ARRAY
75043: PUSH
75044: LD_INT 0
75046: EQUAL
75047: IFFALSE 75073
// begin target := mc_crates [ i ] [ j ] ;
75049: LD_ADDR_VAR 0 7
75053: PUSH
75054: LD_EXP 47
75058: PUSH
75059: LD_VAR 0 2
75063: ARRAY
75064: PUSH
75065: LD_VAR 0 3
75069: ARRAY
75070: ST_TO_ADDR
// break ;
75071: GO 75075
// end ; end ;
75073: GO 74829
75075: POP
75076: POP
// if not target then
75077: LD_VAR 0 7
75081: NOT
75082: IFFALSE 75086
// continue ;
75084: GO 74636
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75086: LD_ADDR_VAR 0 8
75090: PUSH
75091: LD_EXP 50
75095: PUSH
75096: LD_VAR 0 2
75100: ARRAY
75101: PPUSH
75102: LD_INT 2
75104: PUSH
75105: LD_INT 3
75107: PUSH
75108: LD_INT 58
75110: PUSH
75111: EMPTY
75112: LIST
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: LD_INT 61
75120: PUSH
75121: EMPTY
75122: LIST
75123: PUSH
75124: LD_INT 33
75126: PUSH
75127: LD_INT 5
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 33
75136: PUSH
75137: LD_INT 3
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: LIST
75148: LIST
75149: LIST
75150: PUSH
75151: LD_INT 2
75153: PUSH
75154: LD_INT 34
75156: PUSH
75157: LD_INT 32
75159: PUSH
75160: EMPTY
75161: LIST
75162: LIST
75163: PUSH
75164: LD_INT 34
75166: PUSH
75167: LD_INT 51
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: PUSH
75174: LD_INT 34
75176: PUSH
75177: LD_INT 12
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: LIST
75188: LIST
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PPUSH
75194: CALL_OW 72
75198: ST_TO_ADDR
// if not cargo then
75199: LD_VAR 0 8
75203: NOT
75204: IFFALSE 75910
// begin if mc_crates_collector [ i ] < 5 then
75206: LD_EXP 48
75210: PUSH
75211: LD_VAR 0 2
75215: ARRAY
75216: PUSH
75217: LD_INT 5
75219: LESS
75220: IFFALSE 75586
// begin if mc_ape [ i ] then
75222: LD_EXP 60
75226: PUSH
75227: LD_VAR 0 2
75231: ARRAY
75232: IFFALSE 75279
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75234: LD_ADDR_VAR 0 5
75238: PUSH
75239: LD_EXP 60
75243: PUSH
75244: LD_VAR 0 2
75248: ARRAY
75249: PPUSH
75250: LD_INT 25
75252: PUSH
75253: LD_INT 16
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 24
75262: PUSH
75263: LD_INT 750
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PPUSH
75274: CALL_OW 72
75278: ST_TO_ADDR
// if not tmp then
75279: LD_VAR 0 5
75283: NOT
75284: IFFALSE 75331
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75286: LD_ADDR_VAR 0 5
75290: PUSH
75291: LD_EXP 31
75295: PUSH
75296: LD_VAR 0 2
75300: ARRAY
75301: PPUSH
75302: LD_INT 25
75304: PUSH
75305: LD_INT 2
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 24
75314: PUSH
75315: LD_INT 750
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PPUSH
75326: CALL_OW 72
75330: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75331: LD_EXP 60
75335: PUSH
75336: LD_VAR 0 2
75340: ARRAY
75341: PUSH
75342: LD_EXP 31
75346: PUSH
75347: LD_VAR 0 2
75351: ARRAY
75352: PPUSH
75353: LD_INT 25
75355: PUSH
75356: LD_INT 2
75358: PUSH
75359: EMPTY
75360: LIST
75361: LIST
75362: PUSH
75363: LD_INT 24
75365: PUSH
75366: LD_INT 750
75368: PUSH
75369: EMPTY
75370: LIST
75371: LIST
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: PPUSH
75377: CALL_OW 72
75381: AND
75382: PUSH
75383: LD_VAR 0 5
75387: PUSH
75388: LD_INT 5
75390: LESS
75391: AND
75392: IFFALSE 75474
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75394: LD_ADDR_VAR 0 3
75398: PUSH
75399: LD_EXP 31
75403: PUSH
75404: LD_VAR 0 2
75408: ARRAY
75409: PPUSH
75410: LD_INT 25
75412: PUSH
75413: LD_INT 2
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 24
75422: PUSH
75423: LD_INT 750
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PPUSH
75434: CALL_OW 72
75438: PUSH
75439: FOR_IN
75440: IFFALSE 75472
// begin tmp := tmp union j ;
75442: LD_ADDR_VAR 0 5
75446: PUSH
75447: LD_VAR 0 5
75451: PUSH
75452: LD_VAR 0 3
75456: UNION
75457: ST_TO_ADDR
// if tmp >= 5 then
75458: LD_VAR 0 5
75462: PUSH
75463: LD_INT 5
75465: GREATEREQUAL
75466: IFFALSE 75470
// break ;
75468: GO 75472
// end ;
75470: GO 75439
75472: POP
75473: POP
// end ; if not tmp then
75474: LD_VAR 0 5
75478: NOT
75479: IFFALSE 75483
// continue ;
75481: GO 74636
// for j in tmp do
75483: LD_ADDR_VAR 0 3
75487: PUSH
75488: LD_VAR 0 5
75492: PUSH
75493: FOR_IN
75494: IFFALSE 75584
// if not GetTag ( j ) then
75496: LD_VAR 0 3
75500: PPUSH
75501: CALL_OW 110
75505: NOT
75506: IFFALSE 75582
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75508: LD_ADDR_EXP 48
75512: PUSH
75513: LD_EXP 48
75517: PPUSH
75518: LD_VAR 0 2
75522: PUSH
75523: LD_EXP 48
75527: PUSH
75528: LD_VAR 0 2
75532: ARRAY
75533: PUSH
75534: LD_INT 1
75536: PLUS
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PPUSH
75542: LD_VAR 0 3
75546: PPUSH
75547: CALL 25021 0 3
75551: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75552: LD_VAR 0 3
75556: PPUSH
75557: LD_INT 107
75559: PPUSH
75560: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75564: LD_EXP 48
75568: PUSH
75569: LD_VAR 0 2
75573: ARRAY
75574: PUSH
75575: LD_INT 5
75577: GREATEREQUAL
75578: IFFALSE 75582
// break ;
75580: GO 75584
// end ;
75582: GO 75493
75584: POP
75585: POP
// end ; if mc_crates_collector [ i ] and target then
75586: LD_EXP 48
75590: PUSH
75591: LD_VAR 0 2
75595: ARRAY
75596: PUSH
75597: LD_VAR 0 7
75601: AND
75602: IFFALSE 75908
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75604: LD_EXP 48
75608: PUSH
75609: LD_VAR 0 2
75613: ARRAY
75614: PUSH
75615: LD_VAR 0 7
75619: PUSH
75620: LD_INT 1
75622: ARRAY
75623: LESS
75624: IFFALSE 75644
// tmp := mc_crates_collector [ i ] else
75626: LD_ADDR_VAR 0 5
75630: PUSH
75631: LD_EXP 48
75635: PUSH
75636: LD_VAR 0 2
75640: ARRAY
75641: ST_TO_ADDR
75642: GO 75658
// tmp := target [ 1 ] ;
75644: LD_ADDR_VAR 0 5
75648: PUSH
75649: LD_VAR 0 7
75653: PUSH
75654: LD_INT 1
75656: ARRAY
75657: ST_TO_ADDR
// k := 0 ;
75658: LD_ADDR_VAR 0 4
75662: PUSH
75663: LD_INT 0
75665: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75666: LD_ADDR_VAR 0 3
75670: PUSH
75671: LD_EXP 48
75675: PUSH
75676: LD_VAR 0 2
75680: ARRAY
75681: PUSH
75682: FOR_IN
75683: IFFALSE 75906
// begin k := k + 1 ;
75685: LD_ADDR_VAR 0 4
75689: PUSH
75690: LD_VAR 0 4
75694: PUSH
75695: LD_INT 1
75697: PLUS
75698: ST_TO_ADDR
// if k > tmp then
75699: LD_VAR 0 4
75703: PUSH
75704: LD_VAR 0 5
75708: GREATER
75709: IFFALSE 75713
// break ;
75711: GO 75906
// if not GetClass ( j ) in [ 2 , 16 ] then
75713: LD_VAR 0 3
75717: PPUSH
75718: CALL_OW 257
75722: PUSH
75723: LD_INT 2
75725: PUSH
75726: LD_INT 16
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: IN
75733: NOT
75734: IFFALSE 75787
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75736: LD_ADDR_EXP 48
75740: PUSH
75741: LD_EXP 48
75745: PPUSH
75746: LD_VAR 0 2
75750: PPUSH
75751: LD_EXP 48
75755: PUSH
75756: LD_VAR 0 2
75760: ARRAY
75761: PUSH
75762: LD_VAR 0 3
75766: DIFF
75767: PPUSH
75768: CALL_OW 1
75772: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75773: LD_VAR 0 3
75777: PPUSH
75778: LD_INT 0
75780: PPUSH
75781: CALL_OW 109
// continue ;
75785: GO 75682
// end ; if IsInUnit ( j ) then
75787: LD_VAR 0 3
75791: PPUSH
75792: CALL_OW 310
75796: IFFALSE 75807
// ComExitBuilding ( j ) ;
75798: LD_VAR 0 3
75802: PPUSH
75803: CALL_OW 122
// wait ( 3 ) ;
75807: LD_INT 3
75809: PPUSH
75810: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75814: LD_VAR 0 3
75818: PPUSH
75819: CALL_OW 314
75823: PUSH
75824: LD_VAR 0 6
75828: PPUSH
75829: LD_VAR 0 7
75833: PUSH
75834: LD_INT 2
75836: ARRAY
75837: PPUSH
75838: LD_VAR 0 7
75842: PUSH
75843: LD_INT 3
75845: ARRAY
75846: PPUSH
75847: LD_INT 30
75849: PPUSH
75850: CALL 25917 0 4
75854: PUSH
75855: LD_INT 4
75857: ARRAY
75858: AND
75859: IFFALSE 75877
// ComStandNearbyBuilding ( j , depot ) else
75861: LD_VAR 0 3
75865: PPUSH
75866: LD_VAR 0 9
75870: PPUSH
75871: CALL 21448 0 2
75875: GO 75904
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75877: LD_VAR 0 3
75881: PPUSH
75882: LD_VAR 0 7
75886: PUSH
75887: LD_INT 2
75889: ARRAY
75890: PPUSH
75891: LD_VAR 0 7
75895: PUSH
75896: LD_INT 3
75898: ARRAY
75899: PPUSH
75900: CALL_OW 117
// end ;
75904: GO 75682
75906: POP
75907: POP
// end ; end else
75908: GO 76440
// begin for j in cargo do
75910: LD_ADDR_VAR 0 3
75914: PUSH
75915: LD_VAR 0 8
75919: PUSH
75920: FOR_IN
75921: IFFALSE 76438
// begin if GetTag ( j ) <> 0 then
75923: LD_VAR 0 3
75927: PPUSH
75928: CALL_OW 110
75932: PUSH
75933: LD_INT 0
75935: NONEQUAL
75936: IFFALSE 75940
// continue ;
75938: GO 75920
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
75940: LD_VAR 0 3
75944: PPUSH
75945: CALL_OW 256
75949: PUSH
75950: LD_INT 1000
75952: LESS
75953: PUSH
75954: LD_VAR 0 3
75958: PPUSH
75959: LD_EXP 55
75963: PUSH
75964: LD_VAR 0 2
75968: ARRAY
75969: PPUSH
75970: CALL_OW 308
75974: NOT
75975: AND
75976: IFFALSE 75998
// ComMoveToArea ( j , mc_parking [ i ] ) ;
75978: LD_VAR 0 3
75982: PPUSH
75983: LD_EXP 55
75987: PUSH
75988: LD_VAR 0 2
75992: ARRAY
75993: PPUSH
75994: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
75998: LD_VAR 0 3
76002: PPUSH
76003: CALL_OW 256
76007: PUSH
76008: LD_INT 1000
76010: LESS
76011: PUSH
76012: LD_VAR 0 3
76016: PPUSH
76017: LD_EXP 55
76021: PUSH
76022: LD_VAR 0 2
76026: ARRAY
76027: PPUSH
76028: CALL_OW 308
76032: AND
76033: IFFALSE 76037
// continue ;
76035: GO 75920
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
76037: LD_VAR 0 3
76041: PPUSH
76042: CALL_OW 262
76046: PUSH
76047: LD_INT 2
76049: EQUAL
76050: PUSH
76051: LD_VAR 0 3
76055: PPUSH
76056: CALL_OW 261
76060: PUSH
76061: LD_INT 15
76063: LESS
76064: AND
76065: IFFALSE 76069
// continue ;
76067: GO 75920
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
76069: LD_VAR 0 3
76073: PPUSH
76074: CALL_OW 262
76078: PUSH
76079: LD_INT 1
76081: EQUAL
76082: PUSH
76083: LD_VAR 0 3
76087: PPUSH
76088: CALL_OW 261
76092: PUSH
76093: LD_INT 10
76095: LESS
76096: AND
76097: IFFALSE 76377
// begin if not depot then
76099: LD_VAR 0 9
76103: NOT
76104: IFFALSE 76108
// continue ;
76106: GO 75920
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76108: LD_VAR 0 3
76112: PPUSH
76113: LD_VAR 0 9
76117: PPUSH
76118: LD_VAR 0 3
76122: PPUSH
76123: CALL_OW 74
76127: PPUSH
76128: CALL_OW 296
76132: PUSH
76133: LD_INT 6
76135: LESS
76136: IFFALSE 76152
// SetFuel ( j , 100 ) else
76138: LD_VAR 0 3
76142: PPUSH
76143: LD_INT 100
76145: PPUSH
76146: CALL_OW 240
76150: GO 76377
// if GetFuel ( j ) = 0 then
76152: LD_VAR 0 3
76156: PPUSH
76157: CALL_OW 261
76161: PUSH
76162: LD_INT 0
76164: EQUAL
76165: IFFALSE 76377
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
76167: LD_ADDR_EXP 50
76171: PUSH
76172: LD_EXP 50
76176: PPUSH
76177: LD_VAR 0 2
76181: PPUSH
76182: LD_EXP 50
76186: PUSH
76187: LD_VAR 0 2
76191: ARRAY
76192: PUSH
76193: LD_VAR 0 3
76197: DIFF
76198: PPUSH
76199: CALL_OW 1
76203: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
76204: LD_VAR 0 3
76208: PPUSH
76209: CALL_OW 263
76213: PUSH
76214: LD_INT 1
76216: EQUAL
76217: IFFALSE 76233
// ComExitVehicle ( IsInUnit ( j ) ) ;
76219: LD_VAR 0 3
76223: PPUSH
76224: CALL_OW 310
76228: PPUSH
76229: CALL_OW 121
// if GetControl ( j ) = control_remote then
76233: LD_VAR 0 3
76237: PPUSH
76238: CALL_OW 263
76242: PUSH
76243: LD_INT 2
76245: EQUAL
76246: IFFALSE 76257
// ComUnlink ( j ) ;
76248: LD_VAR 0 3
76252: PPUSH
76253: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76257: LD_ADDR_VAR 0 10
76261: PUSH
76262: LD_VAR 0 2
76266: PPUSH
76267: LD_INT 3
76269: PPUSH
76270: CALL 86044 0 2
76274: ST_TO_ADDR
// if fac then
76275: LD_VAR 0 10
76279: IFFALSE 76375
// begin for k in fac do
76281: LD_ADDR_VAR 0 4
76285: PUSH
76286: LD_VAR 0 10
76290: PUSH
76291: FOR_IN
76292: IFFALSE 76373
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76294: LD_ADDR_VAR 0 11
76298: PUSH
76299: LD_VAR 0 10
76303: PPUSH
76304: LD_VAR 0 3
76308: PPUSH
76309: CALL_OW 265
76313: PPUSH
76314: LD_VAR 0 3
76318: PPUSH
76319: CALL_OW 262
76323: PPUSH
76324: LD_VAR 0 3
76328: PPUSH
76329: CALL_OW 263
76333: PPUSH
76334: LD_VAR 0 3
76338: PPUSH
76339: CALL_OW 264
76343: PPUSH
76344: CALL 22519 0 5
76348: ST_TO_ADDR
// if components then
76349: LD_VAR 0 11
76353: IFFALSE 76371
// begin MC_InsertProduceList ( i , components ) ;
76355: LD_VAR 0 2
76359: PPUSH
76360: LD_VAR 0 11
76364: PPUSH
76365: CALL 85589 0 2
// break ;
76369: GO 76373
// end ; end ;
76371: GO 76291
76373: POP
76374: POP
// end ; continue ;
76375: GO 75920
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76377: LD_VAR 0 3
76381: PPUSH
76382: LD_INT 1
76384: PPUSH
76385: CALL_OW 289
76389: PUSH
76390: LD_INT 100
76392: LESS
76393: PUSH
76394: LD_VAR 0 3
76398: PPUSH
76399: CALL_OW 314
76403: NOT
76404: AND
76405: IFFALSE 76434
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76407: LD_VAR 0 3
76411: PPUSH
76412: LD_VAR 0 7
76416: PUSH
76417: LD_INT 2
76419: ARRAY
76420: PPUSH
76421: LD_VAR 0 7
76425: PUSH
76426: LD_INT 3
76428: ARRAY
76429: PPUSH
76430: CALL_OW 117
// break ;
76434: GO 76438
// end ;
76436: GO 75920
76438: POP
76439: POP
// end ; end ;
76440: GO 74636
76442: POP
76443: POP
// end ;
76444: LD_VAR 0 1
76448: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76449: LD_INT 0
76451: PPUSH
76452: PPUSH
76453: PPUSH
76454: PPUSH
// if not mc_bases then
76455: LD_EXP 31
76459: NOT
76460: IFFALSE 76464
// exit ;
76462: GO 76625
// for i = 1 to mc_bases do
76464: LD_ADDR_VAR 0 2
76468: PUSH
76469: DOUBLE
76470: LD_INT 1
76472: DEC
76473: ST_TO_ADDR
76474: LD_EXP 31
76478: PUSH
76479: FOR_TO
76480: IFFALSE 76623
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76482: LD_ADDR_VAR 0 4
76486: PUSH
76487: LD_EXP 50
76491: PUSH
76492: LD_VAR 0 2
76496: ARRAY
76497: PUSH
76498: LD_EXP 53
76502: PUSH
76503: LD_VAR 0 2
76507: ARRAY
76508: UNION
76509: PPUSH
76510: LD_INT 33
76512: PUSH
76513: LD_INT 2
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PPUSH
76520: CALL_OW 72
76524: ST_TO_ADDR
// if tmp then
76525: LD_VAR 0 4
76529: IFFALSE 76621
// for j in tmp do
76531: LD_ADDR_VAR 0 3
76535: PUSH
76536: LD_VAR 0 4
76540: PUSH
76541: FOR_IN
76542: IFFALSE 76619
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76544: LD_VAR 0 3
76548: PPUSH
76549: CALL_OW 312
76553: NOT
76554: PUSH
76555: LD_VAR 0 3
76559: PPUSH
76560: CALL_OW 256
76564: PUSH
76565: LD_INT 250
76567: GREATEREQUAL
76568: AND
76569: IFFALSE 76582
// Connect ( j ) else
76571: LD_VAR 0 3
76575: PPUSH
76576: CALL 27990 0 1
76580: GO 76617
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76582: LD_VAR 0 3
76586: PPUSH
76587: CALL_OW 256
76591: PUSH
76592: LD_INT 250
76594: LESS
76595: PUSH
76596: LD_VAR 0 3
76600: PPUSH
76601: CALL_OW 312
76605: AND
76606: IFFALSE 76617
// ComUnlink ( j ) ;
76608: LD_VAR 0 3
76612: PPUSH
76613: CALL_OW 136
76617: GO 76541
76619: POP
76620: POP
// end ;
76621: GO 76479
76623: POP
76624: POP
// end ;
76625: LD_VAR 0 1
76629: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76630: LD_INT 0
76632: PPUSH
76633: PPUSH
76634: PPUSH
76635: PPUSH
76636: PPUSH
// if not mc_bases then
76637: LD_EXP 31
76641: NOT
76642: IFFALSE 76646
// exit ;
76644: GO 77091
// for i = 1 to mc_bases do
76646: LD_ADDR_VAR 0 2
76650: PUSH
76651: DOUBLE
76652: LD_INT 1
76654: DEC
76655: ST_TO_ADDR
76656: LD_EXP 31
76660: PUSH
76661: FOR_TO
76662: IFFALSE 77089
// begin if not mc_produce [ i ] then
76664: LD_EXP 52
76668: PUSH
76669: LD_VAR 0 2
76673: ARRAY
76674: NOT
76675: IFFALSE 76679
// continue ;
76677: GO 76661
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76679: LD_ADDR_VAR 0 5
76683: PUSH
76684: LD_EXP 31
76688: PUSH
76689: LD_VAR 0 2
76693: ARRAY
76694: PPUSH
76695: LD_INT 30
76697: PUSH
76698: LD_INT 3
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PPUSH
76705: CALL_OW 72
76709: ST_TO_ADDR
// if not fac then
76710: LD_VAR 0 5
76714: NOT
76715: IFFALSE 76719
// continue ;
76717: GO 76661
// for j in fac do
76719: LD_ADDR_VAR 0 3
76723: PUSH
76724: LD_VAR 0 5
76728: PUSH
76729: FOR_IN
76730: IFFALSE 77085
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76732: LD_VAR 0 3
76736: PPUSH
76737: CALL_OW 461
76741: PUSH
76742: LD_INT 2
76744: NONEQUAL
76745: PUSH
76746: LD_VAR 0 3
76750: PPUSH
76751: LD_INT 15
76753: PPUSH
76754: CALL 27618 0 2
76758: PUSH
76759: LD_INT 4
76761: ARRAY
76762: OR
76763: IFFALSE 76767
// continue ;
76765: GO 76729
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76767: LD_VAR 0 3
76771: PPUSH
76772: LD_EXP 52
76776: PUSH
76777: LD_VAR 0 2
76781: ARRAY
76782: PUSH
76783: LD_INT 1
76785: ARRAY
76786: PUSH
76787: LD_INT 1
76789: ARRAY
76790: PPUSH
76791: LD_EXP 52
76795: PUSH
76796: LD_VAR 0 2
76800: ARRAY
76801: PUSH
76802: LD_INT 1
76804: ARRAY
76805: PUSH
76806: LD_INT 2
76808: ARRAY
76809: PPUSH
76810: LD_EXP 52
76814: PUSH
76815: LD_VAR 0 2
76819: ARRAY
76820: PUSH
76821: LD_INT 1
76823: ARRAY
76824: PUSH
76825: LD_INT 3
76827: ARRAY
76828: PPUSH
76829: LD_EXP 52
76833: PUSH
76834: LD_VAR 0 2
76838: ARRAY
76839: PUSH
76840: LD_INT 1
76842: ARRAY
76843: PUSH
76844: LD_INT 4
76846: ARRAY
76847: PPUSH
76848: CALL_OW 448
76852: PUSH
76853: LD_VAR 0 3
76857: PPUSH
76858: LD_EXP 52
76862: PUSH
76863: LD_VAR 0 2
76867: ARRAY
76868: PUSH
76869: LD_INT 1
76871: ARRAY
76872: PUSH
76873: LD_INT 1
76875: ARRAY
76876: PUSH
76877: LD_EXP 52
76881: PUSH
76882: LD_VAR 0 2
76886: ARRAY
76887: PUSH
76888: LD_INT 1
76890: ARRAY
76891: PUSH
76892: LD_INT 2
76894: ARRAY
76895: PUSH
76896: LD_EXP 52
76900: PUSH
76901: LD_VAR 0 2
76905: ARRAY
76906: PUSH
76907: LD_INT 1
76909: ARRAY
76910: PUSH
76911: LD_INT 3
76913: ARRAY
76914: PUSH
76915: LD_EXP 52
76919: PUSH
76920: LD_VAR 0 2
76924: ARRAY
76925: PUSH
76926: LD_INT 1
76928: ARRAY
76929: PUSH
76930: LD_INT 4
76932: ARRAY
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: PPUSH
76940: CALL 31385 0 2
76944: AND
76945: IFFALSE 77083
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
76947: LD_VAR 0 3
76951: PPUSH
76952: LD_EXP 52
76956: PUSH
76957: LD_VAR 0 2
76961: ARRAY
76962: PUSH
76963: LD_INT 1
76965: ARRAY
76966: PUSH
76967: LD_INT 1
76969: ARRAY
76970: PPUSH
76971: LD_EXP 52
76975: PUSH
76976: LD_VAR 0 2
76980: ARRAY
76981: PUSH
76982: LD_INT 1
76984: ARRAY
76985: PUSH
76986: LD_INT 2
76988: ARRAY
76989: PPUSH
76990: LD_EXP 52
76994: PUSH
76995: LD_VAR 0 2
76999: ARRAY
77000: PUSH
77001: LD_INT 1
77003: ARRAY
77004: PUSH
77005: LD_INT 3
77007: ARRAY
77008: PPUSH
77009: LD_EXP 52
77013: PUSH
77014: LD_VAR 0 2
77018: ARRAY
77019: PUSH
77020: LD_INT 1
77022: ARRAY
77023: PUSH
77024: LD_INT 4
77026: ARRAY
77027: PPUSH
77028: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
77032: LD_ADDR_VAR 0 4
77036: PUSH
77037: LD_EXP 52
77041: PUSH
77042: LD_VAR 0 2
77046: ARRAY
77047: PPUSH
77048: LD_INT 1
77050: PPUSH
77051: CALL_OW 3
77055: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77056: LD_ADDR_EXP 52
77060: PUSH
77061: LD_EXP 52
77065: PPUSH
77066: LD_VAR 0 2
77070: PPUSH
77071: LD_VAR 0 4
77075: PPUSH
77076: CALL_OW 1
77080: ST_TO_ADDR
// break ;
77081: GO 77085
// end ; end ;
77083: GO 76729
77085: POP
77086: POP
// end ;
77087: GO 76661
77089: POP
77090: POP
// end ;
77091: LD_VAR 0 1
77095: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77096: LD_INT 0
77098: PPUSH
77099: PPUSH
77100: PPUSH
// if not mc_bases then
77101: LD_EXP 31
77105: NOT
77106: IFFALSE 77110
// exit ;
77108: GO 77199
// for i = 1 to mc_bases do
77110: LD_ADDR_VAR 0 2
77114: PUSH
77115: DOUBLE
77116: LD_INT 1
77118: DEC
77119: ST_TO_ADDR
77120: LD_EXP 31
77124: PUSH
77125: FOR_TO
77126: IFFALSE 77197
// begin if mc_attack [ i ] then
77128: LD_EXP 51
77132: PUSH
77133: LD_VAR 0 2
77137: ARRAY
77138: IFFALSE 77195
// begin tmp := mc_attack [ i ] [ 1 ] ;
77140: LD_ADDR_VAR 0 3
77144: PUSH
77145: LD_EXP 51
77149: PUSH
77150: LD_VAR 0 2
77154: ARRAY
77155: PUSH
77156: LD_INT 1
77158: ARRAY
77159: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
77160: LD_ADDR_EXP 51
77164: PUSH
77165: LD_EXP 51
77169: PPUSH
77170: LD_VAR 0 2
77174: PPUSH
77175: EMPTY
77176: PPUSH
77177: CALL_OW 1
77181: ST_TO_ADDR
// Attack ( tmp ) ;
77182: LD_VAR 0 3
77186: PPUSH
77187: CALL 112098 0 1
// exit ;
77191: POP
77192: POP
77193: GO 77199
// end ; end ;
77195: GO 77125
77197: POP
77198: POP
// end ;
77199: LD_VAR 0 1
77203: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77204: LD_INT 0
77206: PPUSH
77207: PPUSH
77208: PPUSH
77209: PPUSH
77210: PPUSH
77211: PPUSH
77212: PPUSH
// if not mc_bases then
77213: LD_EXP 31
77217: NOT
77218: IFFALSE 77222
// exit ;
77220: GO 78079
// for i = 1 to mc_bases do
77222: LD_ADDR_VAR 0 2
77226: PUSH
77227: DOUBLE
77228: LD_INT 1
77230: DEC
77231: ST_TO_ADDR
77232: LD_EXP 31
77236: PUSH
77237: FOR_TO
77238: IFFALSE 78077
// begin if not mc_bases [ i ] then
77240: LD_EXP 31
77244: PUSH
77245: LD_VAR 0 2
77249: ARRAY
77250: NOT
77251: IFFALSE 77255
// continue ;
77253: GO 77237
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77255: LD_ADDR_VAR 0 7
77259: PUSH
77260: LD_EXP 31
77264: PUSH
77265: LD_VAR 0 2
77269: ARRAY
77270: PUSH
77271: LD_INT 1
77273: ARRAY
77274: PPUSH
77275: CALL 21670 0 1
77279: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77280: LD_ADDR_EXP 54
77284: PUSH
77285: LD_EXP 54
77289: PPUSH
77290: LD_VAR 0 2
77294: PPUSH
77295: LD_EXP 31
77299: PUSH
77300: LD_VAR 0 2
77304: ARRAY
77305: PUSH
77306: LD_INT 1
77308: ARRAY
77309: PPUSH
77310: CALL_OW 255
77314: PPUSH
77315: LD_EXP 56
77319: PUSH
77320: LD_VAR 0 2
77324: ARRAY
77325: PPUSH
77326: CALL 21635 0 2
77330: PPUSH
77331: CALL_OW 1
77335: ST_TO_ADDR
// if not mc_scan [ i ] then
77336: LD_EXP 54
77340: PUSH
77341: LD_VAR 0 2
77345: ARRAY
77346: NOT
77347: IFFALSE 77525
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77349: LD_ADDR_EXP 74
77353: PUSH
77354: LD_EXP 74
77358: PPUSH
77359: LD_VAR 0 2
77363: PPUSH
77364: LD_INT 0
77366: PPUSH
77367: CALL_OW 1
77371: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77372: LD_ADDR_VAR 0 4
77376: PUSH
77377: LD_EXP 31
77381: PUSH
77382: LD_VAR 0 2
77386: ARRAY
77387: PPUSH
77388: LD_INT 2
77390: PUSH
77391: LD_INT 25
77393: PUSH
77394: LD_INT 5
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: LD_INT 25
77403: PUSH
77404: LD_INT 8
77406: PUSH
77407: EMPTY
77408: LIST
77409: LIST
77410: PUSH
77411: LD_INT 25
77413: PUSH
77414: LD_INT 9
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: LIST
77425: LIST
77426: PPUSH
77427: CALL_OW 72
77431: ST_TO_ADDR
// if not tmp then
77432: LD_VAR 0 4
77436: NOT
77437: IFFALSE 77441
// continue ;
77439: GO 77237
// for j in tmp do
77441: LD_ADDR_VAR 0 3
77445: PUSH
77446: LD_VAR 0 4
77450: PUSH
77451: FOR_IN
77452: IFFALSE 77523
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77454: LD_VAR 0 3
77458: PPUSH
77459: CALL_OW 310
77463: PPUSH
77464: CALL_OW 266
77468: PUSH
77469: LD_INT 5
77471: EQUAL
77472: PUSH
77473: LD_VAR 0 3
77477: PPUSH
77478: CALL_OW 257
77482: PUSH
77483: LD_INT 1
77485: EQUAL
77486: AND
77487: PUSH
77488: LD_VAR 0 3
77492: PPUSH
77493: CALL_OW 459
77497: NOT
77498: AND
77499: PUSH
77500: LD_VAR 0 7
77504: AND
77505: IFFALSE 77521
// ComChangeProfession ( j , class ) ;
77507: LD_VAR 0 3
77511: PPUSH
77512: LD_VAR 0 7
77516: PPUSH
77517: CALL_OW 123
77521: GO 77451
77523: POP
77524: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77525: LD_EXP 54
77529: PUSH
77530: LD_VAR 0 2
77534: ARRAY
77535: PUSH
77536: LD_EXP 74
77540: PUSH
77541: LD_VAR 0 2
77545: ARRAY
77546: NOT
77547: AND
77548: PUSH
77549: LD_EXP 53
77553: PUSH
77554: LD_VAR 0 2
77558: ARRAY
77559: NOT
77560: AND
77561: PUSH
77562: LD_EXP 31
77566: PUSH
77567: LD_VAR 0 2
77571: ARRAY
77572: PPUSH
77573: LD_INT 50
77575: PUSH
77576: EMPTY
77577: LIST
77578: PUSH
77579: LD_INT 2
77581: PUSH
77582: LD_INT 30
77584: PUSH
77585: LD_INT 32
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: LD_INT 30
77594: PUSH
77595: LD_INT 33
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: PUSH
77602: LD_INT 30
77604: PUSH
77605: LD_INT 4
77607: PUSH
77608: EMPTY
77609: LIST
77610: LIST
77611: PUSH
77612: LD_INT 30
77614: PUSH
77615: LD_INT 5
77617: PUSH
77618: EMPTY
77619: LIST
77620: LIST
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PPUSH
77633: CALL_OW 72
77637: PUSH
77638: LD_INT 4
77640: LESS
77641: PUSH
77642: LD_EXP 31
77646: PUSH
77647: LD_VAR 0 2
77651: ARRAY
77652: PPUSH
77653: LD_INT 3
77655: PUSH
77656: LD_INT 24
77658: PUSH
77659: LD_INT 1000
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 2
77672: PUSH
77673: LD_INT 30
77675: PUSH
77676: LD_INT 0
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 30
77685: PUSH
77686: LD_INT 1
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: LIST
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: PPUSH
77702: CALL_OW 72
77706: OR
77707: AND
77708: IFFALSE 77959
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77710: LD_ADDR_EXP 74
77714: PUSH
77715: LD_EXP 74
77719: PPUSH
77720: LD_VAR 0 2
77724: PPUSH
77725: LD_INT 1
77727: PPUSH
77728: CALL_OW 1
77732: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77733: LD_ADDR_VAR 0 4
77737: PUSH
77738: LD_EXP 31
77742: PUSH
77743: LD_VAR 0 2
77747: ARRAY
77748: PPUSH
77749: LD_INT 2
77751: PUSH
77752: LD_INT 25
77754: PUSH
77755: LD_INT 1
77757: PUSH
77758: EMPTY
77759: LIST
77760: LIST
77761: PUSH
77762: LD_INT 25
77764: PUSH
77765: LD_INT 5
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: LD_INT 25
77774: PUSH
77775: LD_INT 8
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: PUSH
77782: LD_INT 25
77784: PUSH
77785: LD_INT 9
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: LIST
77796: LIST
77797: LIST
77798: PPUSH
77799: CALL_OW 72
77803: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77804: LD_ADDR_VAR 0 4
77808: PUSH
77809: LD_VAR 0 4
77813: PUSH
77814: LD_VAR 0 4
77818: PPUSH
77819: LD_INT 18
77821: PPUSH
77822: CALL 54933 0 2
77826: DIFF
77827: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77828: LD_VAR 0 4
77832: NOT
77833: PUSH
77834: LD_EXP 31
77838: PUSH
77839: LD_VAR 0 2
77843: ARRAY
77844: PPUSH
77845: LD_INT 2
77847: PUSH
77848: LD_INT 30
77850: PUSH
77851: LD_INT 4
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 30
77860: PUSH
77861: LD_INT 5
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: LIST
77872: PPUSH
77873: CALL_OW 72
77877: NOT
77878: AND
77879: IFFALSE 77941
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
77881: LD_ADDR_VAR 0 4
77885: PUSH
77886: LD_EXP 31
77890: PUSH
77891: LD_VAR 0 2
77895: ARRAY
77896: PPUSH
77897: LD_INT 2
77899: PUSH
77900: LD_INT 25
77902: PUSH
77903: LD_INT 2
77905: PUSH
77906: EMPTY
77907: LIST
77908: LIST
77909: PUSH
77910: LD_INT 25
77912: PUSH
77913: LD_INT 3
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 25
77922: PUSH
77923: LD_INT 4
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: LIST
77934: LIST
77935: PPUSH
77936: CALL_OW 72
77940: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
77941: LD_VAR 0 2
77945: PPUSH
77946: LD_VAR 0 4
77950: PPUSH
77951: CALL 116807 0 2
// exit ;
77955: POP
77956: POP
77957: GO 78079
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
77959: LD_EXP 54
77963: PUSH
77964: LD_VAR 0 2
77968: ARRAY
77969: PUSH
77970: LD_EXP 74
77974: PUSH
77975: LD_VAR 0 2
77979: ARRAY
77980: NOT
77981: AND
77982: PUSH
77983: LD_EXP 53
77987: PUSH
77988: LD_VAR 0 2
77992: ARRAY
77993: AND
77994: IFFALSE 78075
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77996: LD_ADDR_EXP 74
78000: PUSH
78001: LD_EXP 74
78005: PPUSH
78006: LD_VAR 0 2
78010: PPUSH
78011: LD_INT 1
78013: PPUSH
78014: CALL_OW 1
78018: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
78019: LD_ADDR_VAR 0 4
78023: PUSH
78024: LD_EXP 53
78028: PUSH
78029: LD_VAR 0 2
78033: ARRAY
78034: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
78035: LD_ADDR_EXP 53
78039: PUSH
78040: LD_EXP 53
78044: PPUSH
78045: LD_VAR 0 2
78049: PPUSH
78050: EMPTY
78051: PPUSH
78052: CALL_OW 1
78056: ST_TO_ADDR
// Defend ( i , tmp ) ;
78057: LD_VAR 0 2
78061: PPUSH
78062: LD_VAR 0 4
78066: PPUSH
78067: CALL 117403 0 2
// exit ;
78071: POP
78072: POP
78073: GO 78079
// end ; end ;
78075: GO 77237
78077: POP
78078: POP
// end ;
78079: LD_VAR 0 1
78083: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78084: LD_INT 0
78086: PPUSH
78087: PPUSH
78088: PPUSH
78089: PPUSH
78090: PPUSH
78091: PPUSH
78092: PPUSH
78093: PPUSH
78094: PPUSH
78095: PPUSH
78096: PPUSH
// if not mc_bases then
78097: LD_EXP 31
78101: NOT
78102: IFFALSE 78106
// exit ;
78104: GO 79193
// for i = 1 to mc_bases do
78106: LD_ADDR_VAR 0 2
78110: PUSH
78111: DOUBLE
78112: LD_INT 1
78114: DEC
78115: ST_TO_ADDR
78116: LD_EXP 31
78120: PUSH
78121: FOR_TO
78122: IFFALSE 79191
// begin tmp := mc_lab [ i ] ;
78124: LD_ADDR_VAR 0 6
78128: PUSH
78129: LD_EXP 64
78133: PUSH
78134: LD_VAR 0 2
78138: ARRAY
78139: ST_TO_ADDR
// if not tmp then
78140: LD_VAR 0 6
78144: NOT
78145: IFFALSE 78149
// continue ;
78147: GO 78121
// idle_lab := 0 ;
78149: LD_ADDR_VAR 0 11
78153: PUSH
78154: LD_INT 0
78156: ST_TO_ADDR
// for j in tmp do
78157: LD_ADDR_VAR 0 3
78161: PUSH
78162: LD_VAR 0 6
78166: PUSH
78167: FOR_IN
78168: IFFALSE 79187
// begin researching := false ;
78170: LD_ADDR_VAR 0 10
78174: PUSH
78175: LD_INT 0
78177: ST_TO_ADDR
// side := GetSide ( j ) ;
78178: LD_ADDR_VAR 0 4
78182: PUSH
78183: LD_VAR 0 3
78187: PPUSH
78188: CALL_OW 255
78192: ST_TO_ADDR
// if not mc_tech [ side ] then
78193: LD_EXP 58
78197: PUSH
78198: LD_VAR 0 4
78202: ARRAY
78203: NOT
78204: IFFALSE 78208
// continue ;
78206: GO 78167
// if BuildingStatus ( j ) = bs_idle then
78208: LD_VAR 0 3
78212: PPUSH
78213: CALL_OW 461
78217: PUSH
78218: LD_INT 2
78220: EQUAL
78221: IFFALSE 78409
// begin if idle_lab and UnitsInside ( j ) < 6 then
78223: LD_VAR 0 11
78227: PUSH
78228: LD_VAR 0 3
78232: PPUSH
78233: CALL_OW 313
78237: PUSH
78238: LD_INT 6
78240: LESS
78241: AND
78242: IFFALSE 78313
// begin tmp2 := UnitsInside ( idle_lab ) ;
78244: LD_ADDR_VAR 0 9
78248: PUSH
78249: LD_VAR 0 11
78253: PPUSH
78254: CALL_OW 313
78258: ST_TO_ADDR
// if tmp2 then
78259: LD_VAR 0 9
78263: IFFALSE 78305
// for x in tmp2 do
78265: LD_ADDR_VAR 0 7
78269: PUSH
78270: LD_VAR 0 9
78274: PUSH
78275: FOR_IN
78276: IFFALSE 78303
// begin ComExitBuilding ( x ) ;
78278: LD_VAR 0 7
78282: PPUSH
78283: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78287: LD_VAR 0 7
78291: PPUSH
78292: LD_VAR 0 3
78296: PPUSH
78297: CALL_OW 180
// end ;
78301: GO 78275
78303: POP
78304: POP
// idle_lab := 0 ;
78305: LD_ADDR_VAR 0 11
78309: PUSH
78310: LD_INT 0
78312: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78313: LD_ADDR_VAR 0 5
78317: PUSH
78318: LD_EXP 58
78322: PUSH
78323: LD_VAR 0 4
78327: ARRAY
78328: PUSH
78329: FOR_IN
78330: IFFALSE 78390
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78332: LD_VAR 0 3
78336: PPUSH
78337: LD_VAR 0 5
78341: PPUSH
78342: CALL_OW 430
78346: PUSH
78347: LD_VAR 0 4
78351: PPUSH
78352: LD_VAR 0 5
78356: PPUSH
78357: CALL 20740 0 2
78361: AND
78362: IFFALSE 78388
// begin researching := true ;
78364: LD_ADDR_VAR 0 10
78368: PUSH
78369: LD_INT 1
78371: ST_TO_ADDR
// ComResearch ( j , t ) ;
78372: LD_VAR 0 3
78376: PPUSH
78377: LD_VAR 0 5
78381: PPUSH
78382: CALL_OW 124
// break ;
78386: GO 78390
// end ;
78388: GO 78329
78390: POP
78391: POP
// if not researching then
78392: LD_VAR 0 10
78396: NOT
78397: IFFALSE 78409
// idle_lab := j ;
78399: LD_ADDR_VAR 0 11
78403: PUSH
78404: LD_VAR 0 3
78408: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78409: LD_VAR 0 3
78413: PPUSH
78414: CALL_OW 461
78418: PUSH
78419: LD_INT 10
78421: EQUAL
78422: IFFALSE 79010
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78424: LD_EXP 60
78428: PUSH
78429: LD_VAR 0 2
78433: ARRAY
78434: NOT
78435: PUSH
78436: LD_EXP 61
78440: PUSH
78441: LD_VAR 0 2
78445: ARRAY
78446: NOT
78447: AND
78448: PUSH
78449: LD_EXP 58
78453: PUSH
78454: LD_VAR 0 4
78458: ARRAY
78459: PUSH
78460: LD_INT 1
78462: GREATER
78463: AND
78464: IFFALSE 78595
// begin ComCancel ( j ) ;
78466: LD_VAR 0 3
78470: PPUSH
78471: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78475: LD_ADDR_EXP 58
78479: PUSH
78480: LD_EXP 58
78484: PPUSH
78485: LD_VAR 0 4
78489: PPUSH
78490: LD_EXP 58
78494: PUSH
78495: LD_VAR 0 4
78499: ARRAY
78500: PPUSH
78501: LD_EXP 58
78505: PUSH
78506: LD_VAR 0 4
78510: ARRAY
78511: PUSH
78512: LD_INT 1
78514: MINUS
78515: PPUSH
78516: LD_EXP 58
78520: PUSH
78521: LD_VAR 0 4
78525: ARRAY
78526: PPUSH
78527: LD_INT 0
78529: PPUSH
78530: CALL 24439 0 4
78534: PPUSH
78535: CALL_OW 1
78539: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78540: LD_ADDR_EXP 58
78544: PUSH
78545: LD_EXP 58
78549: PPUSH
78550: LD_VAR 0 4
78554: PPUSH
78555: LD_EXP 58
78559: PUSH
78560: LD_VAR 0 4
78564: ARRAY
78565: PPUSH
78566: LD_EXP 58
78570: PUSH
78571: LD_VAR 0 4
78575: ARRAY
78576: PPUSH
78577: LD_INT 1
78579: PPUSH
78580: LD_INT 0
78582: PPUSH
78583: CALL 24439 0 4
78587: PPUSH
78588: CALL_OW 1
78592: ST_TO_ADDR
// continue ;
78593: GO 78167
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78595: LD_EXP 60
78599: PUSH
78600: LD_VAR 0 2
78604: ARRAY
78605: PUSH
78606: LD_EXP 61
78610: PUSH
78611: LD_VAR 0 2
78615: ARRAY
78616: NOT
78617: AND
78618: IFFALSE 78745
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78620: LD_ADDR_EXP 61
78624: PUSH
78625: LD_EXP 61
78629: PPUSH
78630: LD_VAR 0 2
78634: PUSH
78635: LD_EXP 61
78639: PUSH
78640: LD_VAR 0 2
78644: ARRAY
78645: PUSH
78646: LD_INT 1
78648: PLUS
78649: PUSH
78650: EMPTY
78651: LIST
78652: LIST
78653: PPUSH
78654: LD_EXP 60
78658: PUSH
78659: LD_VAR 0 2
78663: ARRAY
78664: PUSH
78665: LD_INT 1
78667: ARRAY
78668: PPUSH
78669: CALL 25021 0 3
78673: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78674: LD_EXP 60
78678: PUSH
78679: LD_VAR 0 2
78683: ARRAY
78684: PUSH
78685: LD_INT 1
78687: ARRAY
78688: PPUSH
78689: LD_INT 112
78691: PPUSH
78692: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78696: LD_ADDR_VAR 0 9
78700: PUSH
78701: LD_EXP 60
78705: PUSH
78706: LD_VAR 0 2
78710: ARRAY
78711: PPUSH
78712: LD_INT 1
78714: PPUSH
78715: CALL_OW 3
78719: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78720: LD_ADDR_EXP 60
78724: PUSH
78725: LD_EXP 60
78729: PPUSH
78730: LD_VAR 0 2
78734: PPUSH
78735: LD_VAR 0 9
78739: PPUSH
78740: CALL_OW 1
78744: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78745: LD_EXP 60
78749: PUSH
78750: LD_VAR 0 2
78754: ARRAY
78755: PUSH
78756: LD_EXP 61
78760: PUSH
78761: LD_VAR 0 2
78765: ARRAY
78766: AND
78767: PUSH
78768: LD_EXP 61
78772: PUSH
78773: LD_VAR 0 2
78777: ARRAY
78778: PUSH
78779: LD_INT 1
78781: ARRAY
78782: PPUSH
78783: CALL_OW 310
78787: NOT
78788: AND
78789: PUSH
78790: LD_VAR 0 3
78794: PPUSH
78795: CALL_OW 313
78799: PUSH
78800: LD_INT 6
78802: EQUAL
78803: AND
78804: IFFALSE 78860
// begin tmp2 := UnitsInside ( j ) ;
78806: LD_ADDR_VAR 0 9
78810: PUSH
78811: LD_VAR 0 3
78815: PPUSH
78816: CALL_OW 313
78820: ST_TO_ADDR
// if tmp2 = 6 then
78821: LD_VAR 0 9
78825: PUSH
78826: LD_INT 6
78828: EQUAL
78829: IFFALSE 78860
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78831: LD_VAR 0 9
78835: PUSH
78836: LD_INT 1
78838: ARRAY
78839: PPUSH
78840: LD_INT 112
78842: PPUSH
78843: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78847: LD_VAR 0 9
78851: PUSH
78852: LD_INT 1
78854: ARRAY
78855: PPUSH
78856: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78860: LD_EXP 61
78864: PUSH
78865: LD_VAR 0 2
78869: ARRAY
78870: PUSH
78871: LD_EXP 61
78875: PUSH
78876: LD_VAR 0 2
78880: ARRAY
78881: PUSH
78882: LD_INT 1
78884: ARRAY
78885: PPUSH
78886: CALL_OW 314
78890: NOT
78891: AND
78892: PUSH
78893: LD_EXP 61
78897: PUSH
78898: LD_VAR 0 2
78902: ARRAY
78903: PUSH
78904: LD_INT 1
78906: ARRAY
78907: PPUSH
78908: CALL_OW 310
78912: NOT
78913: AND
78914: IFFALSE 78940
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78916: LD_EXP 61
78920: PUSH
78921: LD_VAR 0 2
78925: ARRAY
78926: PUSH
78927: LD_INT 1
78929: ARRAY
78930: PPUSH
78931: LD_VAR 0 3
78935: PPUSH
78936: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78940: LD_EXP 61
78944: PUSH
78945: LD_VAR 0 2
78949: ARRAY
78950: PUSH
78951: LD_INT 1
78953: ARRAY
78954: PPUSH
78955: CALL_OW 310
78959: PUSH
78960: LD_EXP 61
78964: PUSH
78965: LD_VAR 0 2
78969: ARRAY
78970: PUSH
78971: LD_INT 1
78973: ARRAY
78974: PPUSH
78975: CALL_OW 310
78979: PPUSH
78980: CALL_OW 461
78984: PUSH
78985: LD_INT 3
78987: NONEQUAL
78988: AND
78989: IFFALSE 79010
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78991: LD_EXP 61
78995: PUSH
78996: LD_VAR 0 2
79000: ARRAY
79001: PUSH
79002: LD_INT 1
79004: ARRAY
79005: PPUSH
79006: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
79010: LD_VAR 0 3
79014: PPUSH
79015: CALL_OW 461
79019: PUSH
79020: LD_INT 6
79022: EQUAL
79023: PUSH
79024: LD_VAR 0 6
79028: PUSH
79029: LD_INT 1
79031: GREATER
79032: AND
79033: IFFALSE 79185
// begin sci := [ ] ;
79035: LD_ADDR_VAR 0 8
79039: PUSH
79040: EMPTY
79041: ST_TO_ADDR
// for x in ( tmp diff j ) do
79042: LD_ADDR_VAR 0 7
79046: PUSH
79047: LD_VAR 0 6
79051: PUSH
79052: LD_VAR 0 3
79056: DIFF
79057: PUSH
79058: FOR_IN
79059: IFFALSE 79111
// begin if sci = 6 then
79061: LD_VAR 0 8
79065: PUSH
79066: LD_INT 6
79068: EQUAL
79069: IFFALSE 79073
// break ;
79071: GO 79111
// if BuildingStatus ( x ) = bs_idle then
79073: LD_VAR 0 7
79077: PPUSH
79078: CALL_OW 461
79082: PUSH
79083: LD_INT 2
79085: EQUAL
79086: IFFALSE 79109
// sci := sci ^ UnitsInside ( x ) ;
79088: LD_ADDR_VAR 0 8
79092: PUSH
79093: LD_VAR 0 8
79097: PUSH
79098: LD_VAR 0 7
79102: PPUSH
79103: CALL_OW 313
79107: ADD
79108: ST_TO_ADDR
// end ;
79109: GO 79058
79111: POP
79112: POP
// if not sci then
79113: LD_VAR 0 8
79117: NOT
79118: IFFALSE 79122
// continue ;
79120: GO 78167
// for x in sci do
79122: LD_ADDR_VAR 0 7
79126: PUSH
79127: LD_VAR 0 8
79131: PUSH
79132: FOR_IN
79133: IFFALSE 79183
// if IsInUnit ( x ) and not HasTask ( x ) then
79135: LD_VAR 0 7
79139: PPUSH
79140: CALL_OW 310
79144: PUSH
79145: LD_VAR 0 7
79149: PPUSH
79150: CALL_OW 314
79154: NOT
79155: AND
79156: IFFALSE 79181
// begin ComExitBuilding ( x ) ;
79158: LD_VAR 0 7
79162: PPUSH
79163: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79167: LD_VAR 0 7
79171: PPUSH
79172: LD_VAR 0 3
79176: PPUSH
79177: CALL_OW 180
// end ;
79181: GO 79132
79183: POP
79184: POP
// end ; end ;
79185: GO 78167
79187: POP
79188: POP
// end ;
79189: GO 78121
79191: POP
79192: POP
// end ;
79193: LD_VAR 0 1
79197: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79198: LD_INT 0
79200: PPUSH
79201: PPUSH
// if not mc_bases then
79202: LD_EXP 31
79206: NOT
79207: IFFALSE 79211
// exit ;
79209: GO 79292
// for i = 1 to mc_bases do
79211: LD_ADDR_VAR 0 2
79215: PUSH
79216: DOUBLE
79217: LD_INT 1
79219: DEC
79220: ST_TO_ADDR
79221: LD_EXP 31
79225: PUSH
79226: FOR_TO
79227: IFFALSE 79290
// if mc_mines [ i ] and mc_miners [ i ] then
79229: LD_EXP 44
79233: PUSH
79234: LD_VAR 0 2
79238: ARRAY
79239: PUSH
79240: LD_EXP 45
79244: PUSH
79245: LD_VAR 0 2
79249: ARRAY
79250: AND
79251: IFFALSE 79288
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79253: LD_EXP 45
79257: PUSH
79258: LD_VAR 0 2
79262: ARRAY
79263: PUSH
79264: LD_INT 1
79266: ARRAY
79267: PPUSH
79268: CALL_OW 255
79272: PPUSH
79273: LD_EXP 44
79277: PUSH
79278: LD_VAR 0 2
79282: ARRAY
79283: PPUSH
79284: CALL 21823 0 2
79288: GO 79226
79290: POP
79291: POP
// end ;
79292: LD_VAR 0 1
79296: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79297: LD_INT 0
79299: PPUSH
79300: PPUSH
79301: PPUSH
79302: PPUSH
79303: PPUSH
79304: PPUSH
79305: PPUSH
79306: PPUSH
// if not mc_bases or not mc_parking then
79307: LD_EXP 31
79311: NOT
79312: PUSH
79313: LD_EXP 55
79317: NOT
79318: OR
79319: IFFALSE 79323
// exit ;
79321: GO 80061
// for i = 1 to mc_bases do
79323: LD_ADDR_VAR 0 2
79327: PUSH
79328: DOUBLE
79329: LD_INT 1
79331: DEC
79332: ST_TO_ADDR
79333: LD_EXP 31
79337: PUSH
79338: FOR_TO
79339: IFFALSE 80059
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79341: LD_EXP 31
79345: PUSH
79346: LD_VAR 0 2
79350: ARRAY
79351: NOT
79352: PUSH
79353: LD_EXP 55
79357: PUSH
79358: LD_VAR 0 2
79362: ARRAY
79363: NOT
79364: OR
79365: IFFALSE 79369
// continue ;
79367: GO 79338
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79369: LD_ADDR_VAR 0 5
79373: PUSH
79374: LD_EXP 31
79378: PUSH
79379: LD_VAR 0 2
79383: ARRAY
79384: PUSH
79385: LD_INT 1
79387: ARRAY
79388: PPUSH
79389: CALL_OW 255
79393: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79394: LD_ADDR_VAR 0 6
79398: PUSH
79399: LD_EXP 31
79403: PUSH
79404: LD_VAR 0 2
79408: ARRAY
79409: PPUSH
79410: LD_INT 30
79412: PUSH
79413: LD_INT 3
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PPUSH
79420: CALL_OW 72
79424: ST_TO_ADDR
// if not fac then
79425: LD_VAR 0 6
79429: NOT
79430: IFFALSE 79481
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79432: LD_ADDR_VAR 0 6
79436: PUSH
79437: LD_EXP 31
79441: PUSH
79442: LD_VAR 0 2
79446: ARRAY
79447: PPUSH
79448: LD_INT 2
79450: PUSH
79451: LD_INT 30
79453: PUSH
79454: LD_INT 0
79456: PUSH
79457: EMPTY
79458: LIST
79459: LIST
79460: PUSH
79461: LD_INT 30
79463: PUSH
79464: LD_INT 1
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: LIST
79475: PPUSH
79476: CALL_OW 72
79480: ST_TO_ADDR
// if not fac then
79481: LD_VAR 0 6
79485: NOT
79486: IFFALSE 79490
// continue ;
79488: GO 79338
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79490: LD_ADDR_VAR 0 7
79494: PUSH
79495: LD_EXP 55
79499: PUSH
79500: LD_VAR 0 2
79504: ARRAY
79505: PPUSH
79506: LD_INT 22
79508: PUSH
79509: LD_VAR 0 5
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 21
79520: PUSH
79521: LD_INT 2
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 3
79530: PUSH
79531: LD_INT 60
79533: PUSH
79534: EMPTY
79535: LIST
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 3
79543: PUSH
79544: LD_INT 24
79546: PUSH
79547: LD_INT 1000
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: EMPTY
79555: LIST
79556: LIST
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: LIST
79562: LIST
79563: PPUSH
79564: CALL_OW 70
79568: ST_TO_ADDR
// for j in fac do
79569: LD_ADDR_VAR 0 3
79573: PUSH
79574: LD_VAR 0 6
79578: PUSH
79579: FOR_IN
79580: IFFALSE 79675
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79582: LD_ADDR_VAR 0 7
79586: PUSH
79587: LD_VAR 0 7
79591: PUSH
79592: LD_INT 22
79594: PUSH
79595: LD_VAR 0 5
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 91
79606: PUSH
79607: LD_VAR 0 3
79611: PUSH
79612: LD_INT 15
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 21
79622: PUSH
79623: LD_INT 2
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: LD_INT 3
79632: PUSH
79633: LD_INT 60
79635: PUSH
79636: EMPTY
79637: LIST
79638: PUSH
79639: EMPTY
79640: LIST
79641: LIST
79642: PUSH
79643: LD_INT 3
79645: PUSH
79646: LD_INT 24
79648: PUSH
79649: LD_INT 1000
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: LIST
79664: LIST
79665: LIST
79666: PPUSH
79667: CALL_OW 69
79671: UNION
79672: ST_TO_ADDR
79673: GO 79579
79675: POP
79676: POP
// if not vehs then
79677: LD_VAR 0 7
79681: NOT
79682: IFFALSE 79708
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79684: LD_ADDR_EXP 43
79688: PUSH
79689: LD_EXP 43
79693: PPUSH
79694: LD_VAR 0 2
79698: PPUSH
79699: EMPTY
79700: PPUSH
79701: CALL_OW 1
79705: ST_TO_ADDR
// continue ;
79706: GO 79338
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79708: LD_ADDR_VAR 0 8
79712: PUSH
79713: LD_EXP 31
79717: PUSH
79718: LD_VAR 0 2
79722: ARRAY
79723: PPUSH
79724: LD_INT 30
79726: PUSH
79727: LD_INT 3
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PPUSH
79734: CALL_OW 72
79738: ST_TO_ADDR
// if tmp then
79739: LD_VAR 0 8
79743: IFFALSE 79846
// begin for j in tmp do
79745: LD_ADDR_VAR 0 3
79749: PUSH
79750: LD_VAR 0 8
79754: PUSH
79755: FOR_IN
79756: IFFALSE 79844
// for k in UnitsInside ( j ) do
79758: LD_ADDR_VAR 0 4
79762: PUSH
79763: LD_VAR 0 3
79767: PPUSH
79768: CALL_OW 313
79772: PUSH
79773: FOR_IN
79774: IFFALSE 79840
// if k then
79776: LD_VAR 0 4
79780: IFFALSE 79838
// if not k in mc_repair_vehicle [ i ] then
79782: LD_VAR 0 4
79786: PUSH
79787: LD_EXP 43
79791: PUSH
79792: LD_VAR 0 2
79796: ARRAY
79797: IN
79798: NOT
79799: IFFALSE 79838
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79801: LD_ADDR_EXP 43
79805: PUSH
79806: LD_EXP 43
79810: PPUSH
79811: LD_VAR 0 2
79815: PPUSH
79816: LD_EXP 43
79820: PUSH
79821: LD_VAR 0 2
79825: ARRAY
79826: PUSH
79827: LD_VAR 0 4
79831: UNION
79832: PPUSH
79833: CALL_OW 1
79837: ST_TO_ADDR
79838: GO 79773
79840: POP
79841: POP
79842: GO 79755
79844: POP
79845: POP
// end ; if not mc_repair_vehicle [ i ] then
79846: LD_EXP 43
79850: PUSH
79851: LD_VAR 0 2
79855: ARRAY
79856: NOT
79857: IFFALSE 79861
// continue ;
79859: GO 79338
// for j in mc_repair_vehicle [ i ] do
79861: LD_ADDR_VAR 0 3
79865: PUSH
79866: LD_EXP 43
79870: PUSH
79871: LD_VAR 0 2
79875: ARRAY
79876: PUSH
79877: FOR_IN
79878: IFFALSE 80055
// begin if GetClass ( j ) <> 3 then
79880: LD_VAR 0 3
79884: PPUSH
79885: CALL_OW 257
79889: PUSH
79890: LD_INT 3
79892: NONEQUAL
79893: IFFALSE 79934
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79895: LD_ADDR_EXP 43
79899: PUSH
79900: LD_EXP 43
79904: PPUSH
79905: LD_VAR 0 2
79909: PPUSH
79910: LD_EXP 43
79914: PUSH
79915: LD_VAR 0 2
79919: ARRAY
79920: PUSH
79921: LD_VAR 0 3
79925: DIFF
79926: PPUSH
79927: CALL_OW 1
79931: ST_TO_ADDR
// continue ;
79932: GO 79877
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79934: LD_VAR 0 3
79938: PPUSH
79939: CALL_OW 311
79943: NOT
79944: PUSH
79945: LD_VAR 0 3
79949: PUSH
79950: LD_EXP 34
79954: PUSH
79955: LD_VAR 0 2
79959: ARRAY
79960: PUSH
79961: LD_INT 1
79963: ARRAY
79964: IN
79965: NOT
79966: AND
79967: PUSH
79968: LD_VAR 0 3
79972: PUSH
79973: LD_EXP 34
79977: PUSH
79978: LD_VAR 0 2
79982: ARRAY
79983: PUSH
79984: LD_INT 2
79986: ARRAY
79987: IN
79988: NOT
79989: AND
79990: IFFALSE 80053
// begin if IsInUnit ( j ) then
79992: LD_VAR 0 3
79996: PPUSH
79997: CALL_OW 310
80001: IFFALSE 80014
// ComExitBuilding ( j ) else
80003: LD_VAR 0 3
80007: PPUSH
80008: CALL_OW 122
80012: GO 80053
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
80014: LD_VAR 0 3
80018: PPUSH
80019: LD_VAR 0 7
80023: PUSH
80024: LD_INT 1
80026: ARRAY
80027: PPUSH
80028: CALL 59417 0 2
80032: NOT
80033: IFFALSE 80053
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
80035: LD_VAR 0 3
80039: PPUSH
80040: LD_VAR 0 7
80044: PUSH
80045: LD_INT 1
80047: ARRAY
80048: PPUSH
80049: CALL_OW 129
// end ; end ;
80053: GO 79877
80055: POP
80056: POP
// end ;
80057: GO 79338
80059: POP
80060: POP
// end ;
80061: LD_VAR 0 1
80065: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
80066: LD_INT 0
80068: PPUSH
80069: PPUSH
80070: PPUSH
80071: PPUSH
80072: PPUSH
80073: PPUSH
80074: PPUSH
80075: PPUSH
80076: PPUSH
80077: PPUSH
80078: PPUSH
// if not mc_bases then
80079: LD_EXP 31
80083: NOT
80084: IFFALSE 80088
// exit ;
80086: GO 80890
// for i = 1 to mc_bases do
80088: LD_ADDR_VAR 0 2
80092: PUSH
80093: DOUBLE
80094: LD_INT 1
80096: DEC
80097: ST_TO_ADDR
80098: LD_EXP 31
80102: PUSH
80103: FOR_TO
80104: IFFALSE 80888
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
80106: LD_EXP 59
80110: PUSH
80111: LD_VAR 0 2
80115: ARRAY
80116: NOT
80117: PUSH
80118: LD_EXP 34
80122: PUSH
80123: LD_VAR 0 2
80127: ARRAY
80128: PUSH
80129: LD_INT 1
80131: ARRAY
80132: OR
80133: PUSH
80134: LD_EXP 34
80138: PUSH
80139: LD_VAR 0 2
80143: ARRAY
80144: PUSH
80145: LD_INT 2
80147: ARRAY
80148: OR
80149: PUSH
80150: LD_EXP 57
80154: PUSH
80155: LD_VAR 0 2
80159: ARRAY
80160: PPUSH
80161: LD_INT 1
80163: PPUSH
80164: CALL_OW 325
80168: NOT
80169: OR
80170: PUSH
80171: LD_EXP 54
80175: PUSH
80176: LD_VAR 0 2
80180: ARRAY
80181: OR
80182: IFFALSE 80186
// continue ;
80184: GO 80103
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80186: LD_ADDR_VAR 0 8
80190: PUSH
80191: LD_EXP 31
80195: PUSH
80196: LD_VAR 0 2
80200: ARRAY
80201: PPUSH
80202: LD_INT 25
80204: PUSH
80205: LD_INT 4
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 50
80214: PUSH
80215: EMPTY
80216: LIST
80217: PUSH
80218: LD_INT 3
80220: PUSH
80221: LD_INT 60
80223: PUSH
80224: EMPTY
80225: LIST
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: LIST
80235: PPUSH
80236: CALL_OW 72
80240: PUSH
80241: LD_EXP 35
80245: PUSH
80246: LD_VAR 0 2
80250: ARRAY
80251: DIFF
80252: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80253: LD_ADDR_VAR 0 9
80257: PUSH
80258: LD_EXP 31
80262: PUSH
80263: LD_VAR 0 2
80267: ARRAY
80268: PPUSH
80269: LD_INT 2
80271: PUSH
80272: LD_INT 30
80274: PUSH
80275: LD_INT 0
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 30
80284: PUSH
80285: LD_INT 1
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: LIST
80296: PPUSH
80297: CALL_OW 72
80301: ST_TO_ADDR
// if not tmp or not dep then
80302: LD_VAR 0 8
80306: NOT
80307: PUSH
80308: LD_VAR 0 9
80312: NOT
80313: OR
80314: IFFALSE 80318
// continue ;
80316: GO 80103
// side := GetSide ( tmp [ 1 ] ) ;
80318: LD_ADDR_VAR 0 11
80322: PUSH
80323: LD_VAR 0 8
80327: PUSH
80328: LD_INT 1
80330: ARRAY
80331: PPUSH
80332: CALL_OW 255
80336: ST_TO_ADDR
// dep := dep [ 1 ] ;
80337: LD_ADDR_VAR 0 9
80341: PUSH
80342: LD_VAR 0 9
80346: PUSH
80347: LD_INT 1
80349: ARRAY
80350: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80351: LD_ADDR_VAR 0 7
80355: PUSH
80356: LD_EXP 59
80360: PUSH
80361: LD_VAR 0 2
80365: ARRAY
80366: PPUSH
80367: LD_INT 22
80369: PUSH
80370: LD_INT 0
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 25
80379: PUSH
80380: LD_INT 12
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PPUSH
80391: CALL_OW 70
80395: PUSH
80396: LD_INT 22
80398: PUSH
80399: LD_INT 0
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: PUSH
80406: LD_INT 25
80408: PUSH
80409: LD_INT 12
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PUSH
80416: LD_INT 91
80418: PUSH
80419: LD_VAR 0 9
80423: PUSH
80424: LD_INT 20
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: LIST
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: LIST
80436: PPUSH
80437: CALL_OW 69
80441: UNION
80442: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80443: LD_ADDR_VAR 0 10
80447: PUSH
80448: LD_EXP 59
80452: PUSH
80453: LD_VAR 0 2
80457: ARRAY
80458: PPUSH
80459: LD_INT 81
80461: PUSH
80462: LD_VAR 0 11
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PPUSH
80471: CALL_OW 70
80475: ST_TO_ADDR
// if not apes or danger_at_area then
80476: LD_VAR 0 7
80480: NOT
80481: PUSH
80482: LD_VAR 0 10
80486: OR
80487: IFFALSE 80537
// begin if mc_taming [ i ] then
80489: LD_EXP 62
80493: PUSH
80494: LD_VAR 0 2
80498: ARRAY
80499: IFFALSE 80535
// begin MC_Reset ( i , 121 ) ;
80501: LD_VAR 0 2
80505: PPUSH
80506: LD_INT 121
80508: PPUSH
80509: CALL 65474 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80513: LD_ADDR_EXP 62
80517: PUSH
80518: LD_EXP 62
80522: PPUSH
80523: LD_VAR 0 2
80527: PPUSH
80528: EMPTY
80529: PPUSH
80530: CALL_OW 1
80534: ST_TO_ADDR
// end ; continue ;
80535: GO 80103
// end ; for j in tmp do
80537: LD_ADDR_VAR 0 3
80541: PUSH
80542: LD_VAR 0 8
80546: PUSH
80547: FOR_IN
80548: IFFALSE 80884
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80550: LD_VAR 0 3
80554: PUSH
80555: LD_EXP 62
80559: PUSH
80560: LD_VAR 0 2
80564: ARRAY
80565: IN
80566: NOT
80567: PUSH
80568: LD_EXP 62
80572: PUSH
80573: LD_VAR 0 2
80577: ARRAY
80578: PUSH
80579: LD_INT 3
80581: LESS
80582: AND
80583: IFFALSE 80641
// begin SetTag ( j , 121 ) ;
80585: LD_VAR 0 3
80589: PPUSH
80590: LD_INT 121
80592: PPUSH
80593: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80597: LD_ADDR_EXP 62
80601: PUSH
80602: LD_EXP 62
80606: PPUSH
80607: LD_VAR 0 2
80611: PUSH
80612: LD_EXP 62
80616: PUSH
80617: LD_VAR 0 2
80621: ARRAY
80622: PUSH
80623: LD_INT 1
80625: PLUS
80626: PUSH
80627: EMPTY
80628: LIST
80629: LIST
80630: PPUSH
80631: LD_VAR 0 3
80635: PPUSH
80636: CALL 25021 0 3
80640: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80641: LD_VAR 0 3
80645: PUSH
80646: LD_EXP 62
80650: PUSH
80651: LD_VAR 0 2
80655: ARRAY
80656: IN
80657: IFFALSE 80882
// begin if GetClass ( j ) <> 4 then
80659: LD_VAR 0 3
80663: PPUSH
80664: CALL_OW 257
80668: PUSH
80669: LD_INT 4
80671: NONEQUAL
80672: IFFALSE 80725
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80674: LD_ADDR_EXP 62
80678: PUSH
80679: LD_EXP 62
80683: PPUSH
80684: LD_VAR 0 2
80688: PPUSH
80689: LD_EXP 62
80693: PUSH
80694: LD_VAR 0 2
80698: ARRAY
80699: PUSH
80700: LD_VAR 0 3
80704: DIFF
80705: PPUSH
80706: CALL_OW 1
80710: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80711: LD_VAR 0 3
80715: PPUSH
80716: LD_INT 0
80718: PPUSH
80719: CALL_OW 109
// continue ;
80723: GO 80547
// end ; if IsInUnit ( j ) then
80725: LD_VAR 0 3
80729: PPUSH
80730: CALL_OW 310
80734: IFFALSE 80745
// ComExitBuilding ( j ) ;
80736: LD_VAR 0 3
80740: PPUSH
80741: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80745: LD_ADDR_VAR 0 6
80749: PUSH
80750: LD_VAR 0 7
80754: PPUSH
80755: LD_VAR 0 3
80759: PPUSH
80760: CALL_OW 74
80764: ST_TO_ADDR
// if not ape then
80765: LD_VAR 0 6
80769: NOT
80770: IFFALSE 80774
// break ;
80772: GO 80884
// x := GetX ( ape ) ;
80774: LD_ADDR_VAR 0 4
80778: PUSH
80779: LD_VAR 0 6
80783: PPUSH
80784: CALL_OW 250
80788: ST_TO_ADDR
// y := GetY ( ape ) ;
80789: LD_ADDR_VAR 0 5
80793: PUSH
80794: LD_VAR 0 6
80798: PPUSH
80799: CALL_OW 251
80803: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80804: LD_VAR 0 4
80808: PPUSH
80809: LD_VAR 0 5
80813: PPUSH
80814: CALL_OW 488
80818: NOT
80819: PUSH
80820: LD_VAR 0 11
80824: PPUSH
80825: LD_VAR 0 4
80829: PPUSH
80830: LD_VAR 0 5
80834: PPUSH
80835: LD_INT 20
80837: PPUSH
80838: CALL 25917 0 4
80842: PUSH
80843: LD_INT 4
80845: ARRAY
80846: OR
80847: IFFALSE 80851
// break ;
80849: GO 80884
// if not HasTask ( j ) then
80851: LD_VAR 0 3
80855: PPUSH
80856: CALL_OW 314
80860: NOT
80861: IFFALSE 80882
// ComTameXY ( j , x , y ) ;
80863: LD_VAR 0 3
80867: PPUSH
80868: LD_VAR 0 4
80872: PPUSH
80873: LD_VAR 0 5
80877: PPUSH
80878: CALL_OW 131
// end ; end ;
80882: GO 80547
80884: POP
80885: POP
// end ;
80886: GO 80103
80888: POP
80889: POP
// end ;
80890: LD_VAR 0 1
80894: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80895: LD_INT 0
80897: PPUSH
80898: PPUSH
80899: PPUSH
80900: PPUSH
80901: PPUSH
80902: PPUSH
80903: PPUSH
80904: PPUSH
// if not mc_bases then
80905: LD_EXP 31
80909: NOT
80910: IFFALSE 80914
// exit ;
80912: GO 81540
// for i = 1 to mc_bases do
80914: LD_ADDR_VAR 0 2
80918: PUSH
80919: DOUBLE
80920: LD_INT 1
80922: DEC
80923: ST_TO_ADDR
80924: LD_EXP 31
80928: PUSH
80929: FOR_TO
80930: IFFALSE 81538
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80932: LD_EXP 60
80936: PUSH
80937: LD_VAR 0 2
80941: ARRAY
80942: NOT
80943: PUSH
80944: LD_EXP 60
80948: PUSH
80949: LD_VAR 0 2
80953: ARRAY
80954: PPUSH
80955: LD_INT 25
80957: PUSH
80958: LD_INT 12
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PPUSH
80965: CALL_OW 72
80969: NOT
80970: OR
80971: IFFALSE 80975
// continue ;
80973: GO 80929
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80975: LD_ADDR_VAR 0 5
80979: PUSH
80980: LD_EXP 60
80984: PUSH
80985: LD_VAR 0 2
80989: ARRAY
80990: PUSH
80991: LD_INT 1
80993: ARRAY
80994: PPUSH
80995: CALL_OW 255
80999: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
81000: LD_VAR 0 5
81004: PPUSH
81005: LD_INT 2
81007: PPUSH
81008: CALL_OW 325
81012: IFFALSE 81265
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81014: LD_ADDR_VAR 0 4
81018: PUSH
81019: LD_EXP 60
81023: PUSH
81024: LD_VAR 0 2
81028: ARRAY
81029: PPUSH
81030: LD_INT 25
81032: PUSH
81033: LD_INT 16
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PPUSH
81040: CALL_OW 72
81044: ST_TO_ADDR
// if tmp < 6 then
81045: LD_VAR 0 4
81049: PUSH
81050: LD_INT 6
81052: LESS
81053: IFFALSE 81265
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81055: LD_ADDR_VAR 0 6
81059: PUSH
81060: LD_EXP 31
81064: PUSH
81065: LD_VAR 0 2
81069: ARRAY
81070: PPUSH
81071: LD_INT 2
81073: PUSH
81074: LD_INT 30
81076: PUSH
81077: LD_INT 0
81079: PUSH
81080: EMPTY
81081: LIST
81082: LIST
81083: PUSH
81084: LD_INT 30
81086: PUSH
81087: LD_INT 1
81089: PUSH
81090: EMPTY
81091: LIST
81092: LIST
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: LIST
81098: PPUSH
81099: CALL_OW 72
81103: ST_TO_ADDR
// if depot then
81104: LD_VAR 0 6
81108: IFFALSE 81265
// begin selected := 0 ;
81110: LD_ADDR_VAR 0 7
81114: PUSH
81115: LD_INT 0
81117: ST_TO_ADDR
// for j in depot do
81118: LD_ADDR_VAR 0 3
81122: PUSH
81123: LD_VAR 0 6
81127: PUSH
81128: FOR_IN
81129: IFFALSE 81160
// begin if UnitsInside ( j ) < 6 then
81131: LD_VAR 0 3
81135: PPUSH
81136: CALL_OW 313
81140: PUSH
81141: LD_INT 6
81143: LESS
81144: IFFALSE 81158
// begin selected := j ;
81146: LD_ADDR_VAR 0 7
81150: PUSH
81151: LD_VAR 0 3
81155: ST_TO_ADDR
// break ;
81156: GO 81160
// end ; end ;
81158: GO 81128
81160: POP
81161: POP
// if selected then
81162: LD_VAR 0 7
81166: IFFALSE 81265
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81168: LD_ADDR_VAR 0 3
81172: PUSH
81173: LD_EXP 60
81177: PUSH
81178: LD_VAR 0 2
81182: ARRAY
81183: PPUSH
81184: LD_INT 25
81186: PUSH
81187: LD_INT 12
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PPUSH
81194: CALL_OW 72
81198: PUSH
81199: FOR_IN
81200: IFFALSE 81263
// if not HasTask ( j ) then
81202: LD_VAR 0 3
81206: PPUSH
81207: CALL_OW 314
81211: NOT
81212: IFFALSE 81261
// begin if not IsInUnit ( j ) then
81214: LD_VAR 0 3
81218: PPUSH
81219: CALL_OW 310
81223: NOT
81224: IFFALSE 81240
// ComEnterUnit ( j , selected ) ;
81226: LD_VAR 0 3
81230: PPUSH
81231: LD_VAR 0 7
81235: PPUSH
81236: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81240: LD_VAR 0 3
81244: PPUSH
81245: LD_INT 16
81247: PPUSH
81248: CALL_OW 183
// AddComExitBuilding ( j ) ;
81252: LD_VAR 0 3
81256: PPUSH
81257: CALL_OW 182
// end ;
81261: GO 81199
81263: POP
81264: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81265: LD_VAR 0 5
81269: PPUSH
81270: LD_INT 11
81272: PPUSH
81273: CALL_OW 325
81277: IFFALSE 81536
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81279: LD_ADDR_VAR 0 4
81283: PUSH
81284: LD_EXP 60
81288: PUSH
81289: LD_VAR 0 2
81293: ARRAY
81294: PPUSH
81295: LD_INT 25
81297: PUSH
81298: LD_INT 16
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PPUSH
81305: CALL_OW 72
81309: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81310: LD_VAR 0 4
81314: PUSH
81315: LD_INT 6
81317: GREATEREQUAL
81318: PUSH
81319: LD_VAR 0 5
81323: PPUSH
81324: LD_INT 2
81326: PPUSH
81327: CALL_OW 325
81331: NOT
81332: OR
81333: IFFALSE 81536
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81335: LD_ADDR_VAR 0 8
81339: PUSH
81340: LD_EXP 31
81344: PUSH
81345: LD_VAR 0 2
81349: ARRAY
81350: PPUSH
81351: LD_INT 2
81353: PUSH
81354: LD_INT 30
81356: PUSH
81357: LD_INT 4
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 30
81366: PUSH
81367: LD_INT 5
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: LIST
81378: PPUSH
81379: CALL_OW 72
81383: ST_TO_ADDR
// if barracks then
81384: LD_VAR 0 8
81388: IFFALSE 81536
// begin selected := 0 ;
81390: LD_ADDR_VAR 0 7
81394: PUSH
81395: LD_INT 0
81397: ST_TO_ADDR
// for j in barracks do
81398: LD_ADDR_VAR 0 3
81402: PUSH
81403: LD_VAR 0 8
81407: PUSH
81408: FOR_IN
81409: IFFALSE 81440
// begin if UnitsInside ( j ) < 6 then
81411: LD_VAR 0 3
81415: PPUSH
81416: CALL_OW 313
81420: PUSH
81421: LD_INT 6
81423: LESS
81424: IFFALSE 81438
// begin selected := j ;
81426: LD_ADDR_VAR 0 7
81430: PUSH
81431: LD_VAR 0 3
81435: ST_TO_ADDR
// break ;
81436: GO 81440
// end ; end ;
81438: GO 81408
81440: POP
81441: POP
// if selected then
81442: LD_VAR 0 7
81446: IFFALSE 81536
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81448: LD_ADDR_VAR 0 3
81452: PUSH
81453: LD_EXP 60
81457: PUSH
81458: LD_VAR 0 2
81462: ARRAY
81463: PPUSH
81464: LD_INT 25
81466: PUSH
81467: LD_INT 12
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PPUSH
81474: CALL_OW 72
81478: PUSH
81479: FOR_IN
81480: IFFALSE 81534
// if not IsInUnit ( j ) and not HasTask ( j ) then
81482: LD_VAR 0 3
81486: PPUSH
81487: CALL_OW 310
81491: NOT
81492: PUSH
81493: LD_VAR 0 3
81497: PPUSH
81498: CALL_OW 314
81502: NOT
81503: AND
81504: IFFALSE 81532
// begin ComEnterUnit ( j , selected ) ;
81506: LD_VAR 0 3
81510: PPUSH
81511: LD_VAR 0 7
81515: PPUSH
81516: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81520: LD_VAR 0 3
81524: PPUSH
81525: LD_INT 15
81527: PPUSH
81528: CALL_OW 183
// end ;
81532: GO 81479
81534: POP
81535: POP
// end ; end ; end ; end ; end ;
81536: GO 80929
81538: POP
81539: POP
// end ;
81540: LD_VAR 0 1
81544: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81545: LD_INT 0
81547: PPUSH
81548: PPUSH
81549: PPUSH
81550: PPUSH
// if not mc_bases then
81551: LD_EXP 31
81555: NOT
81556: IFFALSE 81560
// exit ;
81558: GO 81738
// for i = 1 to mc_bases do
81560: LD_ADDR_VAR 0 2
81564: PUSH
81565: DOUBLE
81566: LD_INT 1
81568: DEC
81569: ST_TO_ADDR
81570: LD_EXP 31
81574: PUSH
81575: FOR_TO
81576: IFFALSE 81736
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81578: LD_ADDR_VAR 0 4
81582: PUSH
81583: LD_EXP 31
81587: PUSH
81588: LD_VAR 0 2
81592: ARRAY
81593: PPUSH
81594: LD_INT 25
81596: PUSH
81597: LD_INT 9
81599: PUSH
81600: EMPTY
81601: LIST
81602: LIST
81603: PPUSH
81604: CALL_OW 72
81608: ST_TO_ADDR
// if not tmp then
81609: LD_VAR 0 4
81613: NOT
81614: IFFALSE 81618
// continue ;
81616: GO 81575
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81618: LD_EXP 57
81622: PUSH
81623: LD_VAR 0 2
81627: ARRAY
81628: PPUSH
81629: LD_INT 29
81631: PPUSH
81632: CALL_OW 325
81636: NOT
81637: PUSH
81638: LD_EXP 57
81642: PUSH
81643: LD_VAR 0 2
81647: ARRAY
81648: PPUSH
81649: LD_INT 28
81651: PPUSH
81652: CALL_OW 325
81656: NOT
81657: AND
81658: IFFALSE 81662
// continue ;
81660: GO 81575
// for j in tmp do
81662: LD_ADDR_VAR 0 3
81666: PUSH
81667: LD_VAR 0 4
81671: PUSH
81672: FOR_IN
81673: IFFALSE 81732
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81675: LD_VAR 0 3
81679: PUSH
81680: LD_EXP 34
81684: PUSH
81685: LD_VAR 0 2
81689: ARRAY
81690: PUSH
81691: LD_INT 1
81693: ARRAY
81694: IN
81695: NOT
81696: PUSH
81697: LD_VAR 0 3
81701: PUSH
81702: LD_EXP 34
81706: PUSH
81707: LD_VAR 0 2
81711: ARRAY
81712: PUSH
81713: LD_INT 2
81715: ARRAY
81716: IN
81717: NOT
81718: AND
81719: IFFALSE 81730
// ComSpaceTimeShoot ( j ) ;
81721: LD_VAR 0 3
81725: PPUSH
81726: CALL 20831 0 1
81730: GO 81672
81732: POP
81733: POP
// end ;
81734: GO 81575
81736: POP
81737: POP
// end ;
81738: LD_VAR 0 1
81742: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81743: LD_INT 0
81745: PPUSH
81746: PPUSH
81747: PPUSH
81748: PPUSH
81749: PPUSH
81750: PPUSH
81751: PPUSH
81752: PPUSH
81753: PPUSH
// if not mc_bases then
81754: LD_EXP 31
81758: NOT
81759: IFFALSE 81763
// exit ;
81761: GO 82385
// for i = 1 to mc_bases do
81763: LD_ADDR_VAR 0 2
81767: PUSH
81768: DOUBLE
81769: LD_INT 1
81771: DEC
81772: ST_TO_ADDR
81773: LD_EXP 31
81777: PUSH
81778: FOR_TO
81779: IFFALSE 82383
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81781: LD_EXP 66
81785: PUSH
81786: LD_VAR 0 2
81790: ARRAY
81791: NOT
81792: PUSH
81793: LD_INT 38
81795: PPUSH
81796: LD_EXP 57
81800: PUSH
81801: LD_VAR 0 2
81805: ARRAY
81806: PPUSH
81807: CALL_OW 321
81811: PUSH
81812: LD_INT 2
81814: NONEQUAL
81815: OR
81816: IFFALSE 81820
// continue ;
81818: GO 81778
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81820: LD_ADDR_VAR 0 8
81824: PUSH
81825: LD_EXP 31
81829: PUSH
81830: LD_VAR 0 2
81834: ARRAY
81835: PPUSH
81836: LD_INT 30
81838: PUSH
81839: LD_INT 34
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PPUSH
81846: CALL_OW 72
81850: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81851: LD_ADDR_VAR 0 9
81855: PUSH
81856: LD_EXP 31
81860: PUSH
81861: LD_VAR 0 2
81865: ARRAY
81866: PPUSH
81867: LD_INT 25
81869: PUSH
81870: LD_INT 4
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PPUSH
81877: CALL_OW 72
81881: PPUSH
81882: LD_INT 0
81884: PPUSH
81885: CALL 54933 0 2
81889: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81890: LD_VAR 0 9
81894: NOT
81895: PUSH
81896: LD_VAR 0 8
81900: NOT
81901: OR
81902: PUSH
81903: LD_EXP 31
81907: PUSH
81908: LD_VAR 0 2
81912: ARRAY
81913: PPUSH
81914: LD_INT 124
81916: PPUSH
81917: CALL 54933 0 2
81921: OR
81922: IFFALSE 81926
// continue ;
81924: GO 81778
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81926: LD_EXP 67
81930: PUSH
81931: LD_VAR 0 2
81935: ARRAY
81936: PUSH
81937: LD_EXP 66
81941: PUSH
81942: LD_VAR 0 2
81946: ARRAY
81947: LESS
81948: PUSH
81949: LD_EXP 67
81953: PUSH
81954: LD_VAR 0 2
81958: ARRAY
81959: PUSH
81960: LD_VAR 0 8
81964: LESS
81965: AND
81966: IFFALSE 82381
// begin tmp := sci [ 1 ] ;
81968: LD_ADDR_VAR 0 7
81972: PUSH
81973: LD_VAR 0 9
81977: PUSH
81978: LD_INT 1
81980: ARRAY
81981: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81982: LD_VAR 0 7
81986: PPUSH
81987: LD_INT 124
81989: PPUSH
81990: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81994: LD_ADDR_VAR 0 3
81998: PUSH
81999: DOUBLE
82000: LD_EXP 66
82004: PUSH
82005: LD_VAR 0 2
82009: ARRAY
82010: INC
82011: ST_TO_ADDR
82012: LD_EXP 66
82016: PUSH
82017: LD_VAR 0 2
82021: ARRAY
82022: PUSH
82023: FOR_DOWNTO
82024: IFFALSE 82367
// begin if IsInUnit ( tmp ) then
82026: LD_VAR 0 7
82030: PPUSH
82031: CALL_OW 310
82035: IFFALSE 82046
// ComExitBuilding ( tmp ) ;
82037: LD_VAR 0 7
82041: PPUSH
82042: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
82046: LD_INT 35
82048: PPUSH
82049: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
82053: LD_VAR 0 7
82057: PPUSH
82058: CALL_OW 310
82062: NOT
82063: PUSH
82064: LD_VAR 0 7
82068: PPUSH
82069: CALL_OW 314
82073: NOT
82074: AND
82075: IFFALSE 82046
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
82077: LD_ADDR_VAR 0 6
82081: PUSH
82082: LD_VAR 0 7
82086: PPUSH
82087: CALL_OW 250
82091: PUSH
82092: LD_VAR 0 7
82096: PPUSH
82097: CALL_OW 251
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
82106: LD_INT 35
82108: PPUSH
82109: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82113: LD_ADDR_VAR 0 4
82117: PUSH
82118: LD_EXP 66
82122: PUSH
82123: LD_VAR 0 2
82127: ARRAY
82128: PUSH
82129: LD_VAR 0 3
82133: ARRAY
82134: PUSH
82135: LD_INT 1
82137: ARRAY
82138: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82139: LD_ADDR_VAR 0 5
82143: PUSH
82144: LD_EXP 66
82148: PUSH
82149: LD_VAR 0 2
82153: ARRAY
82154: PUSH
82155: LD_VAR 0 3
82159: ARRAY
82160: PUSH
82161: LD_INT 2
82163: ARRAY
82164: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82165: LD_VAR 0 7
82169: PPUSH
82170: LD_INT 10
82172: PPUSH
82173: CALL 27618 0 2
82177: PUSH
82178: LD_INT 4
82180: ARRAY
82181: IFFALSE 82219
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82183: LD_VAR 0 7
82187: PPUSH
82188: LD_VAR 0 6
82192: PUSH
82193: LD_INT 1
82195: ARRAY
82196: PPUSH
82197: LD_VAR 0 6
82201: PUSH
82202: LD_INT 2
82204: ARRAY
82205: PPUSH
82206: CALL_OW 111
// wait ( 0 0$10 ) ;
82210: LD_INT 350
82212: PPUSH
82213: CALL_OW 67
// end else
82217: GO 82245
// begin ComMoveXY ( tmp , x , y ) ;
82219: LD_VAR 0 7
82223: PPUSH
82224: LD_VAR 0 4
82228: PPUSH
82229: LD_VAR 0 5
82233: PPUSH
82234: CALL_OW 111
// wait ( 0 0$3 ) ;
82238: LD_INT 105
82240: PPUSH
82241: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82245: LD_VAR 0 7
82249: PPUSH
82250: LD_VAR 0 4
82254: PPUSH
82255: LD_VAR 0 5
82259: PPUSH
82260: CALL_OW 307
82264: IFFALSE 82106
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82266: LD_VAR 0 7
82270: PPUSH
82271: LD_VAR 0 4
82275: PPUSH
82276: LD_VAR 0 5
82280: PPUSH
82281: LD_VAR 0 8
82285: PUSH
82286: LD_VAR 0 3
82290: ARRAY
82291: PPUSH
82292: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82296: LD_INT 35
82298: PPUSH
82299: CALL_OW 67
// until not HasTask ( tmp ) ;
82303: LD_VAR 0 7
82307: PPUSH
82308: CALL_OW 314
82312: NOT
82313: IFFALSE 82296
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82315: LD_ADDR_EXP 67
82319: PUSH
82320: LD_EXP 67
82324: PPUSH
82325: LD_VAR 0 2
82329: PUSH
82330: LD_EXP 67
82334: PUSH
82335: LD_VAR 0 2
82339: ARRAY
82340: PUSH
82341: LD_INT 1
82343: PLUS
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PPUSH
82349: LD_VAR 0 8
82353: PUSH
82354: LD_VAR 0 3
82358: ARRAY
82359: PPUSH
82360: CALL 25021 0 3
82364: ST_TO_ADDR
// end ;
82365: GO 82023
82367: POP
82368: POP
// MC_Reset ( i , 124 ) ;
82369: LD_VAR 0 2
82373: PPUSH
82374: LD_INT 124
82376: PPUSH
82377: CALL 65474 0 2
// end ; end ;
82381: GO 81778
82383: POP
82384: POP
// end ;
82385: LD_VAR 0 1
82389: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82390: LD_INT 0
82392: PPUSH
82393: PPUSH
82394: PPUSH
// if not mc_bases then
82395: LD_EXP 31
82399: NOT
82400: IFFALSE 82404
// exit ;
82402: GO 83010
// for i = 1 to mc_bases do
82404: LD_ADDR_VAR 0 2
82408: PUSH
82409: DOUBLE
82410: LD_INT 1
82412: DEC
82413: ST_TO_ADDR
82414: LD_EXP 31
82418: PUSH
82419: FOR_TO
82420: IFFALSE 83008
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82422: LD_ADDR_VAR 0 3
82426: PUSH
82427: LD_EXP 31
82431: PUSH
82432: LD_VAR 0 2
82436: ARRAY
82437: PPUSH
82438: LD_INT 25
82440: PUSH
82441: LD_INT 4
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PPUSH
82448: CALL_OW 72
82452: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82453: LD_VAR 0 3
82457: NOT
82458: PUSH
82459: LD_EXP 68
82463: PUSH
82464: LD_VAR 0 2
82468: ARRAY
82469: NOT
82470: OR
82471: PUSH
82472: LD_EXP 31
82476: PUSH
82477: LD_VAR 0 2
82481: ARRAY
82482: PPUSH
82483: LD_INT 2
82485: PUSH
82486: LD_INT 30
82488: PUSH
82489: LD_INT 0
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 30
82498: PUSH
82499: LD_INT 1
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: LIST
82510: PPUSH
82511: CALL_OW 72
82515: NOT
82516: OR
82517: IFFALSE 82567
// begin if mc_deposits_finder [ i ] then
82519: LD_EXP 69
82523: PUSH
82524: LD_VAR 0 2
82528: ARRAY
82529: IFFALSE 82565
// begin MC_Reset ( i , 125 ) ;
82531: LD_VAR 0 2
82535: PPUSH
82536: LD_INT 125
82538: PPUSH
82539: CALL 65474 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82543: LD_ADDR_EXP 69
82547: PUSH
82548: LD_EXP 69
82552: PPUSH
82553: LD_VAR 0 2
82557: PPUSH
82558: EMPTY
82559: PPUSH
82560: CALL_OW 1
82564: ST_TO_ADDR
// end ; continue ;
82565: GO 82419
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82567: LD_EXP 68
82571: PUSH
82572: LD_VAR 0 2
82576: ARRAY
82577: PUSH
82578: LD_INT 1
82580: ARRAY
82581: PUSH
82582: LD_INT 3
82584: ARRAY
82585: PUSH
82586: LD_INT 1
82588: EQUAL
82589: PUSH
82590: LD_INT 20
82592: PPUSH
82593: LD_EXP 57
82597: PUSH
82598: LD_VAR 0 2
82602: ARRAY
82603: PPUSH
82604: CALL_OW 321
82608: PUSH
82609: LD_INT 2
82611: NONEQUAL
82612: AND
82613: IFFALSE 82663
// begin if mc_deposits_finder [ i ] then
82615: LD_EXP 69
82619: PUSH
82620: LD_VAR 0 2
82624: ARRAY
82625: IFFALSE 82661
// begin MC_Reset ( i , 125 ) ;
82627: LD_VAR 0 2
82631: PPUSH
82632: LD_INT 125
82634: PPUSH
82635: CALL 65474 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82639: LD_ADDR_EXP 69
82643: PUSH
82644: LD_EXP 69
82648: PPUSH
82649: LD_VAR 0 2
82653: PPUSH
82654: EMPTY
82655: PPUSH
82656: CALL_OW 1
82660: ST_TO_ADDR
// end ; continue ;
82661: GO 82419
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82663: LD_EXP 68
82667: PUSH
82668: LD_VAR 0 2
82672: ARRAY
82673: PUSH
82674: LD_INT 1
82676: ARRAY
82677: PUSH
82678: LD_INT 1
82680: ARRAY
82681: PPUSH
82682: LD_EXP 68
82686: PUSH
82687: LD_VAR 0 2
82691: ARRAY
82692: PUSH
82693: LD_INT 1
82695: ARRAY
82696: PUSH
82697: LD_INT 2
82699: ARRAY
82700: PPUSH
82701: LD_EXP 57
82705: PUSH
82706: LD_VAR 0 2
82710: ARRAY
82711: PPUSH
82712: CALL_OW 440
82716: IFFALSE 82759
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82718: LD_ADDR_EXP 68
82722: PUSH
82723: LD_EXP 68
82727: PPUSH
82728: LD_VAR 0 2
82732: PPUSH
82733: LD_EXP 68
82737: PUSH
82738: LD_VAR 0 2
82742: ARRAY
82743: PPUSH
82744: LD_INT 1
82746: PPUSH
82747: CALL_OW 3
82751: PPUSH
82752: CALL_OW 1
82756: ST_TO_ADDR
82757: GO 83006
// begin if not mc_deposits_finder [ i ] then
82759: LD_EXP 69
82763: PUSH
82764: LD_VAR 0 2
82768: ARRAY
82769: NOT
82770: IFFALSE 82822
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82772: LD_ADDR_EXP 69
82776: PUSH
82777: LD_EXP 69
82781: PPUSH
82782: LD_VAR 0 2
82786: PPUSH
82787: LD_VAR 0 3
82791: PUSH
82792: LD_INT 1
82794: ARRAY
82795: PUSH
82796: EMPTY
82797: LIST
82798: PPUSH
82799: CALL_OW 1
82803: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82804: LD_VAR 0 3
82808: PUSH
82809: LD_INT 1
82811: ARRAY
82812: PPUSH
82813: LD_INT 125
82815: PPUSH
82816: CALL_OW 109
// end else
82820: GO 83006
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82822: LD_EXP 69
82826: PUSH
82827: LD_VAR 0 2
82831: ARRAY
82832: PUSH
82833: LD_INT 1
82835: ARRAY
82836: PPUSH
82837: CALL_OW 310
82841: IFFALSE 82864
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82843: LD_EXP 69
82847: PUSH
82848: LD_VAR 0 2
82852: ARRAY
82853: PUSH
82854: LD_INT 1
82856: ARRAY
82857: PPUSH
82858: CALL_OW 122
82862: GO 83006
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82864: LD_EXP 69
82868: PUSH
82869: LD_VAR 0 2
82873: ARRAY
82874: PUSH
82875: LD_INT 1
82877: ARRAY
82878: PPUSH
82879: CALL_OW 314
82883: NOT
82884: PUSH
82885: LD_EXP 69
82889: PUSH
82890: LD_VAR 0 2
82894: ARRAY
82895: PUSH
82896: LD_INT 1
82898: ARRAY
82899: PPUSH
82900: LD_EXP 68
82904: PUSH
82905: LD_VAR 0 2
82909: ARRAY
82910: PUSH
82911: LD_INT 1
82913: ARRAY
82914: PUSH
82915: LD_INT 1
82917: ARRAY
82918: PPUSH
82919: LD_EXP 68
82923: PUSH
82924: LD_VAR 0 2
82928: ARRAY
82929: PUSH
82930: LD_INT 1
82932: ARRAY
82933: PUSH
82934: LD_INT 2
82936: ARRAY
82937: PPUSH
82938: CALL_OW 297
82942: PUSH
82943: LD_INT 6
82945: GREATER
82946: AND
82947: IFFALSE 83006
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82949: LD_EXP 69
82953: PUSH
82954: LD_VAR 0 2
82958: ARRAY
82959: PUSH
82960: LD_INT 1
82962: ARRAY
82963: PPUSH
82964: LD_EXP 68
82968: PUSH
82969: LD_VAR 0 2
82973: ARRAY
82974: PUSH
82975: LD_INT 1
82977: ARRAY
82978: PUSH
82979: LD_INT 1
82981: ARRAY
82982: PPUSH
82983: LD_EXP 68
82987: PUSH
82988: LD_VAR 0 2
82992: ARRAY
82993: PUSH
82994: LD_INT 1
82996: ARRAY
82997: PUSH
82998: LD_INT 2
83000: ARRAY
83001: PPUSH
83002: CALL_OW 111
// end ; end ; end ;
83006: GO 82419
83008: POP
83009: POP
// end ;
83010: LD_VAR 0 1
83014: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
83015: LD_INT 0
83017: PPUSH
83018: PPUSH
83019: PPUSH
83020: PPUSH
83021: PPUSH
83022: PPUSH
83023: PPUSH
83024: PPUSH
83025: PPUSH
83026: PPUSH
83027: PPUSH
// if not mc_bases then
83028: LD_EXP 31
83032: NOT
83033: IFFALSE 83037
// exit ;
83035: GO 83977
// for i = 1 to mc_bases do
83037: LD_ADDR_VAR 0 2
83041: PUSH
83042: DOUBLE
83043: LD_INT 1
83045: DEC
83046: ST_TO_ADDR
83047: LD_EXP 31
83051: PUSH
83052: FOR_TO
83053: IFFALSE 83975
// begin if not mc_bases [ i ] or mc_scan [ i ] then
83055: LD_EXP 31
83059: PUSH
83060: LD_VAR 0 2
83064: ARRAY
83065: NOT
83066: PUSH
83067: LD_EXP 54
83071: PUSH
83072: LD_VAR 0 2
83076: ARRAY
83077: OR
83078: IFFALSE 83082
// continue ;
83080: GO 83052
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
83082: LD_ADDR_VAR 0 7
83086: PUSH
83087: LD_EXP 31
83091: PUSH
83092: LD_VAR 0 2
83096: ARRAY
83097: PUSH
83098: LD_INT 1
83100: ARRAY
83101: PPUSH
83102: CALL_OW 248
83106: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83107: LD_VAR 0 7
83111: PUSH
83112: LD_INT 3
83114: EQUAL
83115: PUSH
83116: LD_EXP 50
83120: PUSH
83121: LD_VAR 0 2
83125: ARRAY
83126: PUSH
83127: LD_EXP 53
83131: PUSH
83132: LD_VAR 0 2
83136: ARRAY
83137: UNION
83138: PPUSH
83139: LD_INT 33
83141: PUSH
83142: LD_INT 2
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PPUSH
83149: CALL_OW 72
83153: NOT
83154: OR
83155: IFFALSE 83159
// continue ;
83157: GO 83052
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83159: LD_ADDR_VAR 0 9
83163: PUSH
83164: LD_EXP 31
83168: PUSH
83169: LD_VAR 0 2
83173: ARRAY
83174: PPUSH
83175: LD_INT 30
83177: PUSH
83178: LD_INT 36
83180: PUSH
83181: EMPTY
83182: LIST
83183: LIST
83184: PPUSH
83185: CALL_OW 72
83189: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83190: LD_ADDR_VAR 0 10
83194: PUSH
83195: LD_EXP 50
83199: PUSH
83200: LD_VAR 0 2
83204: ARRAY
83205: PPUSH
83206: LD_INT 34
83208: PUSH
83209: LD_INT 31
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: PPUSH
83216: CALL_OW 72
83220: ST_TO_ADDR
// if not cts and not mcts then
83221: LD_VAR 0 9
83225: NOT
83226: PUSH
83227: LD_VAR 0 10
83231: NOT
83232: AND
83233: IFFALSE 83237
// continue ;
83235: GO 83052
// x := cts ;
83237: LD_ADDR_VAR 0 11
83241: PUSH
83242: LD_VAR 0 9
83246: ST_TO_ADDR
// if not x then
83247: LD_VAR 0 11
83251: NOT
83252: IFFALSE 83264
// x := mcts ;
83254: LD_ADDR_VAR 0 11
83258: PUSH
83259: LD_VAR 0 10
83263: ST_TO_ADDR
// if not x then
83264: LD_VAR 0 11
83268: NOT
83269: IFFALSE 83273
// continue ;
83271: GO 83052
// if mc_remote_driver [ i ] then
83273: LD_EXP 71
83277: PUSH
83278: LD_VAR 0 2
83282: ARRAY
83283: IFFALSE 83670
// for j in mc_remote_driver [ i ] do
83285: LD_ADDR_VAR 0 3
83289: PUSH
83290: LD_EXP 71
83294: PUSH
83295: LD_VAR 0 2
83299: ARRAY
83300: PUSH
83301: FOR_IN
83302: IFFALSE 83668
// begin if GetClass ( j ) <> 3 then
83304: LD_VAR 0 3
83308: PPUSH
83309: CALL_OW 257
83313: PUSH
83314: LD_INT 3
83316: NONEQUAL
83317: IFFALSE 83370
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83319: LD_ADDR_EXP 71
83323: PUSH
83324: LD_EXP 71
83328: PPUSH
83329: LD_VAR 0 2
83333: PPUSH
83334: LD_EXP 71
83338: PUSH
83339: LD_VAR 0 2
83343: ARRAY
83344: PUSH
83345: LD_VAR 0 3
83349: DIFF
83350: PPUSH
83351: CALL_OW 1
83355: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83356: LD_VAR 0 3
83360: PPUSH
83361: LD_INT 0
83363: PPUSH
83364: CALL_OW 109
// continue ;
83368: GO 83301
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83370: LD_EXP 50
83374: PUSH
83375: LD_VAR 0 2
83379: ARRAY
83380: PPUSH
83381: LD_INT 34
83383: PUSH
83384: LD_INT 31
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: PUSH
83391: LD_INT 58
83393: PUSH
83394: EMPTY
83395: LIST
83396: PUSH
83397: EMPTY
83398: LIST
83399: LIST
83400: PPUSH
83401: CALL_OW 72
83405: PUSH
83406: LD_VAR 0 3
83410: PPUSH
83411: CALL 54968 0 1
83415: NOT
83416: AND
83417: IFFALSE 83488
// begin if IsInUnit ( j ) then
83419: LD_VAR 0 3
83423: PPUSH
83424: CALL_OW 310
83428: IFFALSE 83439
// ComExitBuilding ( j ) ;
83430: LD_VAR 0 3
83434: PPUSH
83435: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83439: LD_VAR 0 3
83443: PPUSH
83444: LD_EXP 50
83448: PUSH
83449: LD_VAR 0 2
83453: ARRAY
83454: PPUSH
83455: LD_INT 34
83457: PUSH
83458: LD_INT 31
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: LD_INT 58
83467: PUSH
83468: EMPTY
83469: LIST
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PPUSH
83475: CALL_OW 72
83479: PUSH
83480: LD_INT 1
83482: ARRAY
83483: PPUSH
83484: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83488: LD_VAR 0 3
83492: PPUSH
83493: CALL_OW 310
83497: NOT
83498: PUSH
83499: LD_VAR 0 3
83503: PPUSH
83504: CALL_OW 310
83508: PPUSH
83509: CALL_OW 266
83513: PUSH
83514: LD_INT 36
83516: NONEQUAL
83517: PUSH
83518: LD_VAR 0 3
83522: PPUSH
83523: CALL 54968 0 1
83527: NOT
83528: AND
83529: OR
83530: IFFALSE 83666
// begin if IsInUnit ( j ) then
83532: LD_VAR 0 3
83536: PPUSH
83537: CALL_OW 310
83541: IFFALSE 83552
// ComExitBuilding ( j ) ;
83543: LD_VAR 0 3
83547: PPUSH
83548: CALL_OW 122
// ct := 0 ;
83552: LD_ADDR_VAR 0 8
83556: PUSH
83557: LD_INT 0
83559: ST_TO_ADDR
// for k in x do
83560: LD_ADDR_VAR 0 4
83564: PUSH
83565: LD_VAR 0 11
83569: PUSH
83570: FOR_IN
83571: IFFALSE 83644
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83573: LD_VAR 0 4
83577: PPUSH
83578: CALL_OW 264
83582: PUSH
83583: LD_INT 31
83585: EQUAL
83586: PUSH
83587: LD_VAR 0 4
83591: PPUSH
83592: CALL_OW 311
83596: NOT
83597: AND
83598: PUSH
83599: LD_VAR 0 4
83603: PPUSH
83604: CALL_OW 266
83608: PUSH
83609: LD_INT 36
83611: EQUAL
83612: PUSH
83613: LD_VAR 0 4
83617: PPUSH
83618: CALL_OW 313
83622: PUSH
83623: LD_INT 3
83625: LESS
83626: AND
83627: OR
83628: IFFALSE 83642
// begin ct := k ;
83630: LD_ADDR_VAR 0 8
83634: PUSH
83635: LD_VAR 0 4
83639: ST_TO_ADDR
// break ;
83640: GO 83644
// end ;
83642: GO 83570
83644: POP
83645: POP
// if ct then
83646: LD_VAR 0 8
83650: IFFALSE 83666
// ComEnterUnit ( j , ct ) ;
83652: LD_VAR 0 3
83656: PPUSH
83657: LD_VAR 0 8
83661: PPUSH
83662: CALL_OW 120
// end ; end ;
83666: GO 83301
83668: POP
83669: POP
// places := 0 ;
83670: LD_ADDR_VAR 0 5
83674: PUSH
83675: LD_INT 0
83677: ST_TO_ADDR
// for j = 1 to x do
83678: LD_ADDR_VAR 0 3
83682: PUSH
83683: DOUBLE
83684: LD_INT 1
83686: DEC
83687: ST_TO_ADDR
83688: LD_VAR 0 11
83692: PUSH
83693: FOR_TO
83694: IFFALSE 83770
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83696: LD_VAR 0 11
83700: PUSH
83701: LD_VAR 0 3
83705: ARRAY
83706: PPUSH
83707: CALL_OW 264
83711: PUSH
83712: LD_INT 31
83714: EQUAL
83715: IFFALSE 83733
// places := places + 1 else
83717: LD_ADDR_VAR 0 5
83721: PUSH
83722: LD_VAR 0 5
83726: PUSH
83727: LD_INT 1
83729: PLUS
83730: ST_TO_ADDR
83731: GO 83768
// if GetBType ( x [ j ] ) = b_control_tower then
83733: LD_VAR 0 11
83737: PUSH
83738: LD_VAR 0 3
83742: ARRAY
83743: PPUSH
83744: CALL_OW 266
83748: PUSH
83749: LD_INT 36
83751: EQUAL
83752: IFFALSE 83768
// places := places + 3 ;
83754: LD_ADDR_VAR 0 5
83758: PUSH
83759: LD_VAR 0 5
83763: PUSH
83764: LD_INT 3
83766: PLUS
83767: ST_TO_ADDR
83768: GO 83693
83770: POP
83771: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83772: LD_VAR 0 5
83776: PUSH
83777: LD_INT 0
83779: EQUAL
83780: PUSH
83781: LD_VAR 0 5
83785: PUSH
83786: LD_EXP 71
83790: PUSH
83791: LD_VAR 0 2
83795: ARRAY
83796: LESSEQUAL
83797: OR
83798: IFFALSE 83802
// continue ;
83800: GO 83052
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83802: LD_ADDR_VAR 0 6
83806: PUSH
83807: LD_EXP 31
83811: PUSH
83812: LD_VAR 0 2
83816: ARRAY
83817: PPUSH
83818: LD_INT 25
83820: PUSH
83821: LD_INT 3
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: PPUSH
83828: CALL_OW 72
83832: PUSH
83833: LD_EXP 71
83837: PUSH
83838: LD_VAR 0 2
83842: ARRAY
83843: DIFF
83844: PPUSH
83845: LD_INT 3
83847: PPUSH
83848: CALL 55868 0 2
83852: ST_TO_ADDR
// for j in tmp do
83853: LD_ADDR_VAR 0 3
83857: PUSH
83858: LD_VAR 0 6
83862: PUSH
83863: FOR_IN
83864: IFFALSE 83899
// if GetTag ( j ) > 0 then
83866: LD_VAR 0 3
83870: PPUSH
83871: CALL_OW 110
83875: PUSH
83876: LD_INT 0
83878: GREATER
83879: IFFALSE 83897
// tmp := tmp diff j ;
83881: LD_ADDR_VAR 0 6
83885: PUSH
83886: LD_VAR 0 6
83890: PUSH
83891: LD_VAR 0 3
83895: DIFF
83896: ST_TO_ADDR
83897: GO 83863
83899: POP
83900: POP
// if not tmp then
83901: LD_VAR 0 6
83905: NOT
83906: IFFALSE 83910
// continue ;
83908: GO 83052
// if places then
83910: LD_VAR 0 5
83914: IFFALSE 83973
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83916: LD_ADDR_EXP 71
83920: PUSH
83921: LD_EXP 71
83925: PPUSH
83926: LD_VAR 0 2
83930: PPUSH
83931: LD_EXP 71
83935: PUSH
83936: LD_VAR 0 2
83940: ARRAY
83941: PUSH
83942: LD_VAR 0 6
83946: PUSH
83947: LD_INT 1
83949: ARRAY
83950: UNION
83951: PPUSH
83952: CALL_OW 1
83956: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83957: LD_VAR 0 6
83961: PUSH
83962: LD_INT 1
83964: ARRAY
83965: PPUSH
83966: LD_INT 126
83968: PPUSH
83969: CALL_OW 109
// end ; end ;
83973: GO 83052
83975: POP
83976: POP
// end ;
83977: LD_VAR 0 1
83981: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83982: LD_INT 0
83984: PPUSH
83985: PPUSH
83986: PPUSH
83987: PPUSH
83988: PPUSH
83989: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83990: LD_VAR 0 1
83994: NOT
83995: PUSH
83996: LD_VAR 0 2
84000: NOT
84001: OR
84002: PUSH
84003: LD_VAR 0 3
84007: NOT
84008: OR
84009: PUSH
84010: LD_VAR 0 4
84014: PUSH
84015: LD_INT 1
84017: PUSH
84018: LD_INT 2
84020: PUSH
84021: LD_INT 3
84023: PUSH
84024: LD_INT 4
84026: PUSH
84027: LD_INT 5
84029: PUSH
84030: LD_INT 8
84032: PUSH
84033: LD_INT 9
84035: PUSH
84036: LD_INT 15
84038: PUSH
84039: LD_INT 16
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: LIST
84048: LIST
84049: LIST
84050: LIST
84051: LIST
84052: IN
84053: NOT
84054: OR
84055: IFFALSE 84059
// exit ;
84057: GO 84959
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
84059: LD_ADDR_VAR 0 2
84063: PUSH
84064: LD_VAR 0 2
84068: PPUSH
84069: LD_INT 21
84071: PUSH
84072: LD_INT 3
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: PUSH
84079: LD_INT 24
84081: PUSH
84082: LD_INT 250
84084: PUSH
84085: EMPTY
84086: LIST
84087: LIST
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PPUSH
84093: CALL_OW 72
84097: ST_TO_ADDR
// case class of 1 , 15 :
84098: LD_VAR 0 4
84102: PUSH
84103: LD_INT 1
84105: DOUBLE
84106: EQUAL
84107: IFTRUE 84117
84109: LD_INT 15
84111: DOUBLE
84112: EQUAL
84113: IFTRUE 84117
84115: GO 84202
84117: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84118: LD_ADDR_VAR 0 8
84122: PUSH
84123: LD_VAR 0 2
84127: PPUSH
84128: LD_INT 2
84130: PUSH
84131: LD_INT 30
84133: PUSH
84134: LD_INT 32
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PUSH
84141: LD_INT 30
84143: PUSH
84144: LD_INT 31
84146: PUSH
84147: EMPTY
84148: LIST
84149: LIST
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: LIST
84155: PPUSH
84156: CALL_OW 72
84160: PUSH
84161: LD_VAR 0 2
84165: PPUSH
84166: LD_INT 2
84168: PUSH
84169: LD_INT 30
84171: PUSH
84172: LD_INT 4
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 30
84181: PUSH
84182: LD_INT 5
84184: PUSH
84185: EMPTY
84186: LIST
84187: LIST
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: LIST
84193: PPUSH
84194: CALL_OW 72
84198: ADD
84199: ST_TO_ADDR
84200: GO 84448
84202: LD_INT 2
84204: DOUBLE
84205: EQUAL
84206: IFTRUE 84216
84208: LD_INT 16
84210: DOUBLE
84211: EQUAL
84212: IFTRUE 84216
84214: GO 84262
84216: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84217: LD_ADDR_VAR 0 8
84221: PUSH
84222: LD_VAR 0 2
84226: PPUSH
84227: LD_INT 2
84229: PUSH
84230: LD_INT 30
84232: PUSH
84233: LD_INT 0
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 30
84242: PUSH
84243: LD_INT 1
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: LIST
84254: PPUSH
84255: CALL_OW 72
84259: ST_TO_ADDR
84260: GO 84448
84262: LD_INT 3
84264: DOUBLE
84265: EQUAL
84266: IFTRUE 84270
84268: GO 84316
84270: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84271: LD_ADDR_VAR 0 8
84275: PUSH
84276: LD_VAR 0 2
84280: PPUSH
84281: LD_INT 2
84283: PUSH
84284: LD_INT 30
84286: PUSH
84287: LD_INT 2
84289: PUSH
84290: EMPTY
84291: LIST
84292: LIST
84293: PUSH
84294: LD_INT 30
84296: PUSH
84297: LD_INT 3
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: LIST
84308: PPUSH
84309: CALL_OW 72
84313: ST_TO_ADDR
84314: GO 84448
84316: LD_INT 4
84318: DOUBLE
84319: EQUAL
84320: IFTRUE 84324
84322: GO 84381
84324: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84325: LD_ADDR_VAR 0 8
84329: PUSH
84330: LD_VAR 0 2
84334: PPUSH
84335: LD_INT 2
84337: PUSH
84338: LD_INT 30
84340: PUSH
84341: LD_INT 6
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 30
84350: PUSH
84351: LD_INT 7
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 30
84360: PUSH
84361: LD_INT 8
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: PPUSH
84374: CALL_OW 72
84378: ST_TO_ADDR
84379: GO 84448
84381: LD_INT 5
84383: DOUBLE
84384: EQUAL
84385: IFTRUE 84401
84387: LD_INT 8
84389: DOUBLE
84390: EQUAL
84391: IFTRUE 84401
84393: LD_INT 9
84395: DOUBLE
84396: EQUAL
84397: IFTRUE 84401
84399: GO 84447
84401: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84402: LD_ADDR_VAR 0 8
84406: PUSH
84407: LD_VAR 0 2
84411: PPUSH
84412: LD_INT 2
84414: PUSH
84415: LD_INT 30
84417: PUSH
84418: LD_INT 4
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 30
84427: PUSH
84428: LD_INT 5
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: LIST
84439: PPUSH
84440: CALL_OW 72
84444: ST_TO_ADDR
84445: GO 84448
84447: POP
// if not tmp then
84448: LD_VAR 0 8
84452: NOT
84453: IFFALSE 84457
// exit ;
84455: GO 84959
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84457: LD_VAR 0 4
84461: PUSH
84462: LD_INT 1
84464: PUSH
84465: LD_INT 15
84467: PUSH
84468: EMPTY
84469: LIST
84470: LIST
84471: IN
84472: PUSH
84473: LD_EXP 40
84477: PUSH
84478: LD_VAR 0 1
84482: ARRAY
84483: AND
84484: IFFALSE 84640
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84486: LD_ADDR_VAR 0 9
84490: PUSH
84491: LD_EXP 40
84495: PUSH
84496: LD_VAR 0 1
84500: ARRAY
84501: PUSH
84502: LD_INT 1
84504: ARRAY
84505: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84506: LD_VAR 0 9
84510: PUSH
84511: LD_EXP 41
84515: PUSH
84516: LD_VAR 0 1
84520: ARRAY
84521: IN
84522: NOT
84523: IFFALSE 84638
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84525: LD_ADDR_EXP 41
84529: PUSH
84530: LD_EXP 41
84534: PPUSH
84535: LD_VAR 0 1
84539: PUSH
84540: LD_EXP 41
84544: PUSH
84545: LD_VAR 0 1
84549: ARRAY
84550: PUSH
84551: LD_INT 1
84553: PLUS
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PPUSH
84559: LD_VAR 0 9
84563: PPUSH
84564: CALL 25021 0 3
84568: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84569: LD_ADDR_EXP 40
84573: PUSH
84574: LD_EXP 40
84578: PPUSH
84579: LD_VAR 0 1
84583: PPUSH
84584: LD_EXP 40
84588: PUSH
84589: LD_VAR 0 1
84593: ARRAY
84594: PUSH
84595: LD_VAR 0 9
84599: DIFF
84600: PPUSH
84601: CALL_OW 1
84605: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84606: LD_VAR 0 3
84610: PPUSH
84611: LD_EXP 41
84615: PUSH
84616: LD_VAR 0 1
84620: ARRAY
84621: PUSH
84622: LD_EXP 41
84626: PUSH
84627: LD_VAR 0 1
84631: ARRAY
84632: ARRAY
84633: PPUSH
84634: CALL_OW 120
// end ; exit ;
84638: GO 84959
// end ; if tmp > 1 then
84640: LD_VAR 0 8
84644: PUSH
84645: LD_INT 1
84647: GREATER
84648: IFFALSE 84752
// for i = 2 to tmp do
84650: LD_ADDR_VAR 0 6
84654: PUSH
84655: DOUBLE
84656: LD_INT 2
84658: DEC
84659: ST_TO_ADDR
84660: LD_VAR 0 8
84664: PUSH
84665: FOR_TO
84666: IFFALSE 84750
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84668: LD_VAR 0 8
84672: PUSH
84673: LD_VAR 0 6
84677: ARRAY
84678: PPUSH
84679: CALL_OW 461
84683: PUSH
84684: LD_INT 6
84686: EQUAL
84687: IFFALSE 84748
// begin x := tmp [ i ] ;
84689: LD_ADDR_VAR 0 9
84693: PUSH
84694: LD_VAR 0 8
84698: PUSH
84699: LD_VAR 0 6
84703: ARRAY
84704: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84705: LD_ADDR_VAR 0 8
84709: PUSH
84710: LD_VAR 0 8
84714: PPUSH
84715: LD_VAR 0 6
84719: PPUSH
84720: CALL_OW 3
84724: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84725: LD_ADDR_VAR 0 8
84729: PUSH
84730: LD_VAR 0 8
84734: PPUSH
84735: LD_INT 1
84737: PPUSH
84738: LD_VAR 0 9
84742: PPUSH
84743: CALL_OW 2
84747: ST_TO_ADDR
// end ;
84748: GO 84665
84750: POP
84751: POP
// for i in tmp do
84752: LD_ADDR_VAR 0 6
84756: PUSH
84757: LD_VAR 0 8
84761: PUSH
84762: FOR_IN
84763: IFFALSE 84832
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
84765: LD_VAR 0 6
84769: PPUSH
84770: CALL_OW 313
84774: PUSH
84775: LD_INT 6
84777: LESS
84778: PUSH
84779: LD_VAR 0 6
84783: PPUSH
84784: CALL_OW 266
84788: PUSH
84789: LD_INT 31
84791: PUSH
84792: LD_INT 32
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: IN
84799: NOT
84800: AND
84801: PUSH
84802: LD_VAR 0 6
84806: PPUSH
84807: CALL_OW 313
84811: PUSH
84812: LD_INT 0
84814: EQUAL
84815: OR
84816: IFFALSE 84830
// begin j := i ;
84818: LD_ADDR_VAR 0 7
84822: PUSH
84823: LD_VAR 0 6
84827: ST_TO_ADDR
// break ;
84828: GO 84832
// end ; end ;
84830: GO 84762
84832: POP
84833: POP
// if j then
84834: LD_VAR 0 7
84838: IFFALSE 84856
// ComEnterUnit ( unit , j ) else
84840: LD_VAR 0 3
84844: PPUSH
84845: LD_VAR 0 7
84849: PPUSH
84850: CALL_OW 120
84854: GO 84959
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84856: LD_ADDR_VAR 0 10
84860: PUSH
84861: LD_VAR 0 2
84865: PPUSH
84866: LD_INT 2
84868: PUSH
84869: LD_INT 30
84871: PUSH
84872: LD_INT 0
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: LD_INT 30
84881: PUSH
84882: LD_INT 1
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: EMPTY
84890: LIST
84891: LIST
84892: LIST
84893: PPUSH
84894: CALL_OW 72
84898: ST_TO_ADDR
// if depot then
84899: LD_VAR 0 10
84903: IFFALSE 84959
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84905: LD_ADDR_VAR 0 10
84909: PUSH
84910: LD_VAR 0 10
84914: PPUSH
84915: LD_VAR 0 3
84919: PPUSH
84920: CALL_OW 74
84924: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84925: LD_VAR 0 3
84929: PPUSH
84930: LD_VAR 0 10
84934: PPUSH
84935: CALL_OW 296
84939: PUSH
84940: LD_INT 10
84942: GREATER
84943: IFFALSE 84959
// ComStandNearbyBuilding ( unit , depot ) ;
84945: LD_VAR 0 3
84949: PPUSH
84950: LD_VAR 0 10
84954: PPUSH
84955: CALL 21448 0 2
// end ; end ; end ;
84959: LD_VAR 0 5
84963: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84964: LD_INT 0
84966: PPUSH
84967: PPUSH
84968: PPUSH
84969: PPUSH
// if not mc_bases then
84970: LD_EXP 31
84974: NOT
84975: IFFALSE 84979
// exit ;
84977: GO 85218
// for i = 1 to mc_bases do
84979: LD_ADDR_VAR 0 2
84983: PUSH
84984: DOUBLE
84985: LD_INT 1
84987: DEC
84988: ST_TO_ADDR
84989: LD_EXP 31
84993: PUSH
84994: FOR_TO
84995: IFFALSE 85216
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84997: LD_ADDR_VAR 0 4
85001: PUSH
85002: LD_EXP 31
85006: PUSH
85007: LD_VAR 0 2
85011: ARRAY
85012: PPUSH
85013: LD_INT 21
85015: PUSH
85016: LD_INT 1
85018: PUSH
85019: EMPTY
85020: LIST
85021: LIST
85022: PPUSH
85023: CALL_OW 72
85027: PUSH
85028: LD_EXP 60
85032: PUSH
85033: LD_VAR 0 2
85037: ARRAY
85038: UNION
85039: ST_TO_ADDR
// if not tmp then
85040: LD_VAR 0 4
85044: NOT
85045: IFFALSE 85049
// continue ;
85047: GO 84994
// for j in tmp do
85049: LD_ADDR_VAR 0 3
85053: PUSH
85054: LD_VAR 0 4
85058: PUSH
85059: FOR_IN
85060: IFFALSE 85212
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
85062: LD_VAR 0 3
85066: PPUSH
85067: CALL_OW 110
85071: NOT
85072: PUSH
85073: LD_VAR 0 3
85077: PPUSH
85078: CALL_OW 314
85082: NOT
85083: AND
85084: PUSH
85085: LD_VAR 0 3
85089: PPUSH
85090: CALL_OW 311
85094: NOT
85095: AND
85096: PUSH
85097: LD_VAR 0 3
85101: PPUSH
85102: CALL_OW 310
85106: NOT
85107: AND
85108: PUSH
85109: LD_VAR 0 3
85113: PUSH
85114: LD_EXP 34
85118: PUSH
85119: LD_VAR 0 2
85123: ARRAY
85124: PUSH
85125: LD_INT 1
85127: ARRAY
85128: IN
85129: NOT
85130: AND
85131: PUSH
85132: LD_VAR 0 3
85136: PUSH
85137: LD_EXP 34
85141: PUSH
85142: LD_VAR 0 2
85146: ARRAY
85147: PUSH
85148: LD_INT 2
85150: ARRAY
85151: IN
85152: NOT
85153: AND
85154: PUSH
85155: LD_VAR 0 3
85159: PUSH
85160: LD_EXP 43
85164: PUSH
85165: LD_VAR 0 2
85169: ARRAY
85170: IN
85171: NOT
85172: AND
85173: IFFALSE 85210
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85175: LD_VAR 0 2
85179: PPUSH
85180: LD_EXP 31
85184: PUSH
85185: LD_VAR 0 2
85189: ARRAY
85190: PPUSH
85191: LD_VAR 0 3
85195: PPUSH
85196: LD_VAR 0 3
85200: PPUSH
85201: CALL_OW 257
85205: PPUSH
85206: CALL 83982 0 4
// end ;
85210: GO 85059
85212: POP
85213: POP
// end ;
85214: GO 84994
85216: POP
85217: POP
// end ;
85218: LD_VAR 0 1
85222: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
85223: LD_INT 0
85225: PPUSH
85226: PPUSH
85227: PPUSH
85228: PPUSH
85229: PPUSH
85230: PPUSH
// if not mc_bases [ base ] then
85231: LD_EXP 31
85235: PUSH
85236: LD_VAR 0 1
85240: ARRAY
85241: NOT
85242: IFFALSE 85246
// exit ;
85244: GO 85428
// tmp := [ ] ;
85246: LD_ADDR_VAR 0 6
85250: PUSH
85251: EMPTY
85252: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85253: LD_ADDR_VAR 0 7
85257: PUSH
85258: LD_VAR 0 3
85262: PPUSH
85263: LD_INT 0
85265: PPUSH
85266: CALL_OW 517
85270: ST_TO_ADDR
// if not list then
85271: LD_VAR 0 7
85275: NOT
85276: IFFALSE 85280
// exit ;
85278: GO 85428
// for i = 1 to amount do
85280: LD_ADDR_VAR 0 5
85284: PUSH
85285: DOUBLE
85286: LD_INT 1
85288: DEC
85289: ST_TO_ADDR
85290: LD_VAR 0 2
85294: PUSH
85295: FOR_TO
85296: IFFALSE 85376
// begin x := rand ( 1 , list [ 1 ] ) ;
85298: LD_ADDR_VAR 0 8
85302: PUSH
85303: LD_INT 1
85305: PPUSH
85306: LD_VAR 0 7
85310: PUSH
85311: LD_INT 1
85313: ARRAY
85314: PPUSH
85315: CALL_OW 12
85319: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
85320: LD_ADDR_VAR 0 6
85324: PUSH
85325: LD_VAR 0 6
85329: PPUSH
85330: LD_VAR 0 5
85334: PPUSH
85335: LD_VAR 0 7
85339: PUSH
85340: LD_INT 1
85342: ARRAY
85343: PUSH
85344: LD_VAR 0 8
85348: ARRAY
85349: PUSH
85350: LD_VAR 0 7
85354: PUSH
85355: LD_INT 2
85357: ARRAY
85358: PUSH
85359: LD_VAR 0 8
85363: ARRAY
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PPUSH
85369: CALL_OW 1
85373: ST_TO_ADDR
// end ;
85374: GO 85295
85376: POP
85377: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85378: LD_ADDR_EXP 44
85382: PUSH
85383: LD_EXP 44
85387: PPUSH
85388: LD_VAR 0 1
85392: PPUSH
85393: LD_VAR 0 6
85397: PPUSH
85398: CALL_OW 1
85402: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85403: LD_ADDR_EXP 46
85407: PUSH
85408: LD_EXP 46
85412: PPUSH
85413: LD_VAR 0 1
85417: PPUSH
85418: LD_VAR 0 3
85422: PPUSH
85423: CALL_OW 1
85427: ST_TO_ADDR
// end ;
85428: LD_VAR 0 4
85432: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85433: LD_INT 0
85435: PPUSH
// if not mc_bases [ base ] then
85436: LD_EXP 31
85440: PUSH
85441: LD_VAR 0 1
85445: ARRAY
85446: NOT
85447: IFFALSE 85451
// exit ;
85449: GO 85476
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85451: LD_ADDR_EXP 36
85455: PUSH
85456: LD_EXP 36
85460: PPUSH
85461: LD_VAR 0 1
85465: PPUSH
85466: LD_VAR 0 2
85470: PPUSH
85471: CALL_OW 1
85475: ST_TO_ADDR
// end ;
85476: LD_VAR 0 3
85480: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85481: LD_INT 0
85483: PPUSH
// if not mc_bases [ base ] then
85484: LD_EXP 31
85488: PUSH
85489: LD_VAR 0 1
85493: ARRAY
85494: NOT
85495: IFFALSE 85499
// exit ;
85497: GO 85536
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85499: LD_ADDR_EXP 36
85503: PUSH
85504: LD_EXP 36
85508: PPUSH
85509: LD_VAR 0 1
85513: PPUSH
85514: LD_EXP 36
85518: PUSH
85519: LD_VAR 0 1
85523: ARRAY
85524: PUSH
85525: LD_VAR 0 2
85529: UNION
85530: PPUSH
85531: CALL_OW 1
85535: ST_TO_ADDR
// end ;
85536: LD_VAR 0 3
85540: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85541: LD_INT 0
85543: PPUSH
// if not mc_bases [ base ] then
85544: LD_EXP 31
85548: PUSH
85549: LD_VAR 0 1
85553: ARRAY
85554: NOT
85555: IFFALSE 85559
// exit ;
85557: GO 85584
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85559: LD_ADDR_EXP 52
85563: PUSH
85564: LD_EXP 52
85568: PPUSH
85569: LD_VAR 0 1
85573: PPUSH
85574: LD_VAR 0 2
85578: PPUSH
85579: CALL_OW 1
85583: ST_TO_ADDR
// end ;
85584: LD_VAR 0 3
85588: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85589: LD_INT 0
85591: PPUSH
// if not mc_bases [ base ] then
85592: LD_EXP 31
85596: PUSH
85597: LD_VAR 0 1
85601: ARRAY
85602: NOT
85603: IFFALSE 85607
// exit ;
85605: GO 85644
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85607: LD_ADDR_EXP 52
85611: PUSH
85612: LD_EXP 52
85616: PPUSH
85617: LD_VAR 0 1
85621: PPUSH
85622: LD_EXP 52
85626: PUSH
85627: LD_VAR 0 1
85631: ARRAY
85632: PUSH
85633: LD_VAR 0 2
85637: ADD
85638: PPUSH
85639: CALL_OW 1
85643: ST_TO_ADDR
// end ;
85644: LD_VAR 0 3
85648: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85649: LD_INT 0
85651: PPUSH
// if not mc_bases [ base ] then
85652: LD_EXP 31
85656: PUSH
85657: LD_VAR 0 1
85661: ARRAY
85662: NOT
85663: IFFALSE 85667
// exit ;
85665: GO 85721
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85667: LD_ADDR_EXP 53
85671: PUSH
85672: LD_EXP 53
85676: PPUSH
85677: LD_VAR 0 1
85681: PPUSH
85682: LD_VAR 0 2
85686: PPUSH
85687: CALL_OW 1
85691: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85692: LD_ADDR_EXP 42
85696: PUSH
85697: LD_EXP 42
85701: PPUSH
85702: LD_VAR 0 1
85706: PPUSH
85707: LD_VAR 0 2
85711: PUSH
85712: LD_INT 0
85714: PLUS
85715: PPUSH
85716: CALL_OW 1
85720: ST_TO_ADDR
// end ;
85721: LD_VAR 0 3
85725: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85726: LD_INT 0
85728: PPUSH
// if not mc_bases [ base ] then
85729: LD_EXP 31
85733: PUSH
85734: LD_VAR 0 1
85738: ARRAY
85739: NOT
85740: IFFALSE 85744
// exit ;
85742: GO 85769
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85744: LD_ADDR_EXP 42
85748: PUSH
85749: LD_EXP 42
85753: PPUSH
85754: LD_VAR 0 1
85758: PPUSH
85759: LD_VAR 0 2
85763: PPUSH
85764: CALL_OW 1
85768: ST_TO_ADDR
// end ;
85769: LD_VAR 0 3
85773: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85774: LD_INT 0
85776: PPUSH
85777: PPUSH
85778: PPUSH
85779: PPUSH
// if not mc_bases [ base ] then
85780: LD_EXP 31
85784: PUSH
85785: LD_VAR 0 1
85789: ARRAY
85790: NOT
85791: IFFALSE 85795
// exit ;
85793: GO 85860
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85795: LD_ADDR_EXP 51
85799: PUSH
85800: LD_EXP 51
85804: PPUSH
85805: LD_VAR 0 1
85809: PUSH
85810: LD_EXP 51
85814: PUSH
85815: LD_VAR 0 1
85819: ARRAY
85820: PUSH
85821: LD_INT 1
85823: PLUS
85824: PUSH
85825: EMPTY
85826: LIST
85827: LIST
85828: PPUSH
85829: LD_VAR 0 1
85833: PUSH
85834: LD_VAR 0 2
85838: PUSH
85839: LD_VAR 0 3
85843: PUSH
85844: LD_VAR 0 4
85848: PUSH
85849: EMPTY
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: PPUSH
85855: CALL 25021 0 3
85859: ST_TO_ADDR
// end ;
85860: LD_VAR 0 5
85864: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85865: LD_INT 0
85867: PPUSH
// if not mc_bases [ base ] then
85868: LD_EXP 31
85872: PUSH
85873: LD_VAR 0 1
85877: ARRAY
85878: NOT
85879: IFFALSE 85883
// exit ;
85881: GO 85908
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85883: LD_ADDR_EXP 68
85887: PUSH
85888: LD_EXP 68
85892: PPUSH
85893: LD_VAR 0 1
85897: PPUSH
85898: LD_VAR 0 2
85902: PPUSH
85903: CALL_OW 1
85907: ST_TO_ADDR
// end ;
85908: LD_VAR 0 3
85912: RET
// export function MC_GetMinesField ( base ) ; begin
85913: LD_INT 0
85915: PPUSH
// result := mc_mines [ base ] ;
85916: LD_ADDR_VAR 0 2
85920: PUSH
85921: LD_EXP 44
85925: PUSH
85926: LD_VAR 0 1
85930: ARRAY
85931: ST_TO_ADDR
// end ;
85932: LD_VAR 0 2
85936: RET
// export function MC_GetProduceList ( base ) ; begin
85937: LD_INT 0
85939: PPUSH
// result := mc_produce [ base ] ;
85940: LD_ADDR_VAR 0 2
85944: PUSH
85945: LD_EXP 52
85949: PUSH
85950: LD_VAR 0 1
85954: ARRAY
85955: ST_TO_ADDR
// end ;
85956: LD_VAR 0 2
85960: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85961: LD_INT 0
85963: PPUSH
85964: PPUSH
// if not mc_bases then
85965: LD_EXP 31
85969: NOT
85970: IFFALSE 85974
// exit ;
85972: GO 86039
// if mc_bases [ base ] then
85974: LD_EXP 31
85978: PUSH
85979: LD_VAR 0 1
85983: ARRAY
85984: IFFALSE 86039
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85986: LD_ADDR_VAR 0 3
85990: PUSH
85991: LD_EXP 31
85995: PUSH
85996: LD_VAR 0 1
86000: ARRAY
86001: PPUSH
86002: LD_INT 30
86004: PUSH
86005: LD_VAR 0 2
86009: PUSH
86010: EMPTY
86011: LIST
86012: LIST
86013: PPUSH
86014: CALL_OW 72
86018: ST_TO_ADDR
// if result then
86019: LD_VAR 0 3
86023: IFFALSE 86039
// result := result [ 1 ] ;
86025: LD_ADDR_VAR 0 3
86029: PUSH
86030: LD_VAR 0 3
86034: PUSH
86035: LD_INT 1
86037: ARRAY
86038: ST_TO_ADDR
// end ; end ;
86039: LD_VAR 0 3
86043: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
86044: LD_INT 0
86046: PPUSH
86047: PPUSH
// if not mc_bases then
86048: LD_EXP 31
86052: NOT
86053: IFFALSE 86057
// exit ;
86055: GO 86102
// if mc_bases [ base ] then
86057: LD_EXP 31
86061: PUSH
86062: LD_VAR 0 1
86066: ARRAY
86067: IFFALSE 86102
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86069: LD_ADDR_VAR 0 3
86073: PUSH
86074: LD_EXP 31
86078: PUSH
86079: LD_VAR 0 1
86083: ARRAY
86084: PPUSH
86085: LD_INT 30
86087: PUSH
86088: LD_VAR 0 2
86092: PUSH
86093: EMPTY
86094: LIST
86095: LIST
86096: PPUSH
86097: CALL_OW 72
86101: ST_TO_ADDR
// end ;
86102: LD_VAR 0 3
86106: RET
// export function MC_SetTame ( base , area ) ; begin
86107: LD_INT 0
86109: PPUSH
// if not mc_bases or not base then
86110: LD_EXP 31
86114: NOT
86115: PUSH
86116: LD_VAR 0 1
86120: NOT
86121: OR
86122: IFFALSE 86126
// exit ;
86124: GO 86151
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86126: LD_ADDR_EXP 59
86130: PUSH
86131: LD_EXP 59
86135: PPUSH
86136: LD_VAR 0 1
86140: PPUSH
86141: LD_VAR 0 2
86145: PPUSH
86146: CALL_OW 1
86150: ST_TO_ADDR
// end ;
86151: LD_VAR 0 3
86155: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86156: LD_INT 0
86158: PPUSH
86159: PPUSH
// if not mc_bases or not base then
86160: LD_EXP 31
86164: NOT
86165: PUSH
86166: LD_VAR 0 1
86170: NOT
86171: OR
86172: IFFALSE 86176
// exit ;
86174: GO 86278
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86176: LD_ADDR_VAR 0 4
86180: PUSH
86181: LD_EXP 31
86185: PUSH
86186: LD_VAR 0 1
86190: ARRAY
86191: PPUSH
86192: LD_INT 30
86194: PUSH
86195: LD_VAR 0 2
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PPUSH
86204: CALL_OW 72
86208: ST_TO_ADDR
// if not tmp then
86209: LD_VAR 0 4
86213: NOT
86214: IFFALSE 86218
// exit ;
86216: GO 86278
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86218: LD_ADDR_EXP 63
86222: PUSH
86223: LD_EXP 63
86227: PPUSH
86228: LD_VAR 0 1
86232: PPUSH
86233: LD_EXP 63
86237: PUSH
86238: LD_VAR 0 1
86242: ARRAY
86243: PPUSH
86244: LD_EXP 63
86248: PUSH
86249: LD_VAR 0 1
86253: ARRAY
86254: PUSH
86255: LD_INT 1
86257: PLUS
86258: PPUSH
86259: LD_VAR 0 4
86263: PUSH
86264: LD_INT 1
86266: ARRAY
86267: PPUSH
86268: CALL_OW 2
86272: PPUSH
86273: CALL_OW 1
86277: ST_TO_ADDR
// end ;
86278: LD_VAR 0 3
86282: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86283: LD_INT 0
86285: PPUSH
86286: PPUSH
// if not mc_bases or not base or not kinds then
86287: LD_EXP 31
86291: NOT
86292: PUSH
86293: LD_VAR 0 1
86297: NOT
86298: OR
86299: PUSH
86300: LD_VAR 0 2
86304: NOT
86305: OR
86306: IFFALSE 86310
// exit ;
86308: GO 86371
// for i in kinds do
86310: LD_ADDR_VAR 0 4
86314: PUSH
86315: LD_VAR 0 2
86319: PUSH
86320: FOR_IN
86321: IFFALSE 86369
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86323: LD_ADDR_EXP 65
86327: PUSH
86328: LD_EXP 65
86332: PPUSH
86333: LD_VAR 0 1
86337: PUSH
86338: LD_EXP 65
86342: PUSH
86343: LD_VAR 0 1
86347: ARRAY
86348: PUSH
86349: LD_INT 1
86351: PLUS
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PPUSH
86357: LD_VAR 0 4
86361: PPUSH
86362: CALL 25021 0 3
86366: ST_TO_ADDR
86367: GO 86320
86369: POP
86370: POP
// end ;
86371: LD_VAR 0 3
86375: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86376: LD_INT 0
86378: PPUSH
// if not mc_bases or not base or not areas then
86379: LD_EXP 31
86383: NOT
86384: PUSH
86385: LD_VAR 0 1
86389: NOT
86390: OR
86391: PUSH
86392: LD_VAR 0 2
86396: NOT
86397: OR
86398: IFFALSE 86402
// exit ;
86400: GO 86427
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86402: LD_ADDR_EXP 49
86406: PUSH
86407: LD_EXP 49
86411: PPUSH
86412: LD_VAR 0 1
86416: PPUSH
86417: LD_VAR 0 2
86421: PPUSH
86422: CALL_OW 1
86426: ST_TO_ADDR
// end ;
86427: LD_VAR 0 3
86431: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86432: LD_INT 0
86434: PPUSH
// if not mc_bases or not base or not teleports_exit then
86435: LD_EXP 31
86439: NOT
86440: PUSH
86441: LD_VAR 0 1
86445: NOT
86446: OR
86447: PUSH
86448: LD_VAR 0 2
86452: NOT
86453: OR
86454: IFFALSE 86458
// exit ;
86456: GO 86483
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86458: LD_ADDR_EXP 66
86462: PUSH
86463: LD_EXP 66
86467: PPUSH
86468: LD_VAR 0 1
86472: PPUSH
86473: LD_VAR 0 2
86477: PPUSH
86478: CALL_OW 1
86482: ST_TO_ADDR
// end ;
86483: LD_VAR 0 3
86487: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86488: LD_INT 0
86490: PPUSH
86491: PPUSH
86492: PPUSH
// if not mc_bases or not base or not ext_list then
86493: LD_EXP 31
86497: NOT
86498: PUSH
86499: LD_VAR 0 1
86503: NOT
86504: OR
86505: PUSH
86506: LD_VAR 0 5
86510: NOT
86511: OR
86512: IFFALSE 86516
// exit ;
86514: GO 86689
// tmp := GetFacExtXYD ( x , y , d ) ;
86516: LD_ADDR_VAR 0 8
86520: PUSH
86521: LD_VAR 0 2
86525: PPUSH
86526: LD_VAR 0 3
86530: PPUSH
86531: LD_VAR 0 4
86535: PPUSH
86536: CALL 54998 0 3
86540: ST_TO_ADDR
// if not tmp then
86541: LD_VAR 0 8
86545: NOT
86546: IFFALSE 86550
// exit ;
86548: GO 86689
// for i in tmp do
86550: LD_ADDR_VAR 0 7
86554: PUSH
86555: LD_VAR 0 8
86559: PUSH
86560: FOR_IN
86561: IFFALSE 86687
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86563: LD_ADDR_EXP 36
86567: PUSH
86568: LD_EXP 36
86572: PPUSH
86573: LD_VAR 0 1
86577: PPUSH
86578: LD_EXP 36
86582: PUSH
86583: LD_VAR 0 1
86587: ARRAY
86588: PPUSH
86589: LD_EXP 36
86593: PUSH
86594: LD_VAR 0 1
86598: ARRAY
86599: PUSH
86600: LD_INT 1
86602: PLUS
86603: PPUSH
86604: LD_VAR 0 5
86608: PUSH
86609: LD_INT 1
86611: ARRAY
86612: PUSH
86613: LD_VAR 0 7
86617: PUSH
86618: LD_INT 1
86620: ARRAY
86621: PUSH
86622: LD_VAR 0 7
86626: PUSH
86627: LD_INT 2
86629: ARRAY
86630: PUSH
86631: LD_VAR 0 7
86635: PUSH
86636: LD_INT 3
86638: ARRAY
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: LIST
86644: LIST
86645: PPUSH
86646: CALL_OW 2
86650: PPUSH
86651: CALL_OW 1
86655: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86656: LD_ADDR_VAR 0 5
86660: PUSH
86661: LD_VAR 0 5
86665: PPUSH
86666: LD_INT 1
86668: PPUSH
86669: CALL_OW 3
86673: ST_TO_ADDR
// if not ext_list then
86674: LD_VAR 0 5
86678: NOT
86679: IFFALSE 86685
// exit ;
86681: POP
86682: POP
86683: GO 86689
// end ;
86685: GO 86560
86687: POP
86688: POP
// end ;
86689: LD_VAR 0 6
86693: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86694: LD_INT 0
86696: PPUSH
// if not mc_bases or not base or not weapon_list then
86697: LD_EXP 31
86701: NOT
86702: PUSH
86703: LD_VAR 0 1
86707: NOT
86708: OR
86709: PUSH
86710: LD_VAR 0 2
86714: NOT
86715: OR
86716: IFFALSE 86720
// exit ;
86718: GO 86745
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86720: LD_ADDR_EXP 70
86724: PUSH
86725: LD_EXP 70
86729: PPUSH
86730: LD_VAR 0 1
86734: PPUSH
86735: LD_VAR 0 2
86739: PPUSH
86740: CALL_OW 1
86744: ST_TO_ADDR
// end ;
86745: LD_VAR 0 3
86749: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86750: LD_INT 0
86752: PPUSH
// if not mc_bases or not base or not tech_list then
86753: LD_EXP 31
86757: NOT
86758: PUSH
86759: LD_VAR 0 1
86763: NOT
86764: OR
86765: PUSH
86766: LD_VAR 0 2
86770: NOT
86771: OR
86772: IFFALSE 86776
// exit ;
86774: GO 86801
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86776: LD_ADDR_EXP 58
86780: PUSH
86781: LD_EXP 58
86785: PPUSH
86786: LD_VAR 0 1
86790: PPUSH
86791: LD_VAR 0 2
86795: PPUSH
86796: CALL_OW 1
86800: ST_TO_ADDR
// end ;
86801: LD_VAR 0 3
86805: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86806: LD_INT 0
86808: PPUSH
// if not mc_bases or not parking_area or not base then
86809: LD_EXP 31
86813: NOT
86814: PUSH
86815: LD_VAR 0 2
86819: NOT
86820: OR
86821: PUSH
86822: LD_VAR 0 1
86826: NOT
86827: OR
86828: IFFALSE 86832
// exit ;
86830: GO 86857
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86832: LD_ADDR_EXP 55
86836: PUSH
86837: LD_EXP 55
86841: PPUSH
86842: LD_VAR 0 1
86846: PPUSH
86847: LD_VAR 0 2
86851: PPUSH
86852: CALL_OW 1
86856: ST_TO_ADDR
// end ;
86857: LD_VAR 0 3
86861: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86862: LD_INT 0
86864: PPUSH
// if not mc_bases or not base or not scan_area then
86865: LD_EXP 31
86869: NOT
86870: PUSH
86871: LD_VAR 0 1
86875: NOT
86876: OR
86877: PUSH
86878: LD_VAR 0 2
86882: NOT
86883: OR
86884: IFFALSE 86888
// exit ;
86886: GO 86913
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86888: LD_ADDR_EXP 56
86892: PUSH
86893: LD_EXP 56
86897: PPUSH
86898: LD_VAR 0 1
86902: PPUSH
86903: LD_VAR 0 2
86907: PPUSH
86908: CALL_OW 1
86912: ST_TO_ADDR
// end ;
86913: LD_VAR 0 3
86917: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86918: LD_INT 0
86920: PPUSH
86921: PPUSH
// if not mc_bases or not base then
86922: LD_EXP 31
86926: NOT
86927: PUSH
86928: LD_VAR 0 1
86932: NOT
86933: OR
86934: IFFALSE 86938
// exit ;
86936: GO 87002
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86938: LD_ADDR_VAR 0 3
86942: PUSH
86943: LD_INT 1
86945: PUSH
86946: LD_INT 2
86948: PUSH
86949: LD_INT 3
86951: PUSH
86952: LD_INT 4
86954: PUSH
86955: LD_INT 11
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86965: LD_ADDR_EXP 58
86969: PUSH
86970: LD_EXP 58
86974: PPUSH
86975: LD_VAR 0 1
86979: PPUSH
86980: LD_EXP 58
86984: PUSH
86985: LD_VAR 0 1
86989: ARRAY
86990: PUSH
86991: LD_VAR 0 3
86995: DIFF
86996: PPUSH
86997: CALL_OW 1
87001: ST_TO_ADDR
// end ;
87002: LD_VAR 0 2
87006: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
87007: LD_INT 0
87009: PPUSH
// result := mc_vehicles [ base ] ;
87010: LD_ADDR_VAR 0 3
87014: PUSH
87015: LD_EXP 50
87019: PUSH
87020: LD_VAR 0 1
87024: ARRAY
87025: ST_TO_ADDR
// if onlyCombat then
87026: LD_VAR 0 2
87030: IFFALSE 87202
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
87032: LD_ADDR_VAR 0 3
87036: PUSH
87037: LD_VAR 0 3
87041: PUSH
87042: LD_VAR 0 3
87046: PPUSH
87047: LD_INT 2
87049: PUSH
87050: LD_INT 34
87052: PUSH
87053: LD_INT 12
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 34
87062: PUSH
87063: LD_INT 51
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 34
87072: PUSH
87073: LD_INT 89
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 34
87082: PUSH
87083: LD_INT 32
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: PUSH
87090: LD_INT 34
87092: PUSH
87093: LD_INT 13
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 34
87102: PUSH
87103: LD_INT 52
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 34
87112: PUSH
87113: LD_INT 88
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 34
87122: PUSH
87123: LD_INT 14
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 34
87132: PUSH
87133: LD_INT 53
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 34
87142: PUSH
87143: LD_INT 98
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 34
87152: PUSH
87153: LD_INT 31
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: PUSH
87160: LD_INT 34
87162: PUSH
87163: LD_INT 48
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 34
87172: PUSH
87173: LD_INT 8
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: PUSH
87180: EMPTY
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: PPUSH
87196: CALL_OW 72
87200: DIFF
87201: ST_TO_ADDR
// end ; end_of_file
87202: LD_VAR 0 3
87206: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87207: LD_INT 0
87209: PPUSH
87210: PPUSH
87211: PPUSH
// if not mc_bases or not skirmish then
87212: LD_EXP 31
87216: NOT
87217: PUSH
87218: LD_EXP 29
87222: NOT
87223: OR
87224: IFFALSE 87228
// exit ;
87226: GO 87393
// for i = 1 to mc_bases do
87228: LD_ADDR_VAR 0 4
87232: PUSH
87233: DOUBLE
87234: LD_INT 1
87236: DEC
87237: ST_TO_ADDR
87238: LD_EXP 31
87242: PUSH
87243: FOR_TO
87244: IFFALSE 87391
// begin if sci in mc_bases [ i ] then
87246: LD_VAR 0 2
87250: PUSH
87251: LD_EXP 31
87255: PUSH
87256: LD_VAR 0 4
87260: ARRAY
87261: IN
87262: IFFALSE 87389
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87264: LD_ADDR_EXP 60
87268: PUSH
87269: LD_EXP 60
87273: PPUSH
87274: LD_VAR 0 4
87278: PUSH
87279: LD_EXP 60
87283: PUSH
87284: LD_VAR 0 4
87288: ARRAY
87289: PUSH
87290: LD_INT 1
87292: PLUS
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PPUSH
87298: LD_VAR 0 1
87302: PPUSH
87303: CALL 25021 0 3
87307: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87308: LD_ADDR_VAR 0 5
87312: PUSH
87313: LD_EXP 31
87317: PUSH
87318: LD_VAR 0 4
87322: ARRAY
87323: PPUSH
87324: LD_INT 2
87326: PUSH
87327: LD_INT 30
87329: PUSH
87330: LD_INT 0
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 30
87339: PUSH
87340: LD_INT 1
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: LIST
87351: PPUSH
87352: CALL_OW 72
87356: PPUSH
87357: LD_VAR 0 1
87361: PPUSH
87362: CALL_OW 74
87366: ST_TO_ADDR
// if tmp then
87367: LD_VAR 0 5
87371: IFFALSE 87387
// ComStandNearbyBuilding ( ape , tmp ) ;
87373: LD_VAR 0 1
87377: PPUSH
87378: LD_VAR 0 5
87382: PPUSH
87383: CALL 21448 0 2
// break ;
87387: GO 87391
// end ; end ;
87389: GO 87243
87391: POP
87392: POP
// end ;
87393: LD_VAR 0 3
87397: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87398: LD_INT 0
87400: PPUSH
87401: PPUSH
87402: PPUSH
// if not mc_bases or not skirmish then
87403: LD_EXP 31
87407: NOT
87408: PUSH
87409: LD_EXP 29
87413: NOT
87414: OR
87415: IFFALSE 87419
// exit ;
87417: GO 87508
// for i = 1 to mc_bases do
87419: LD_ADDR_VAR 0 4
87423: PUSH
87424: DOUBLE
87425: LD_INT 1
87427: DEC
87428: ST_TO_ADDR
87429: LD_EXP 31
87433: PUSH
87434: FOR_TO
87435: IFFALSE 87506
// begin if building in mc_busy_turret_list [ i ] then
87437: LD_VAR 0 1
87441: PUSH
87442: LD_EXP 41
87446: PUSH
87447: LD_VAR 0 4
87451: ARRAY
87452: IN
87453: IFFALSE 87504
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87455: LD_ADDR_VAR 0 5
87459: PUSH
87460: LD_EXP 41
87464: PUSH
87465: LD_VAR 0 4
87469: ARRAY
87470: PUSH
87471: LD_VAR 0 1
87475: DIFF
87476: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87477: LD_ADDR_EXP 41
87481: PUSH
87482: LD_EXP 41
87486: PPUSH
87487: LD_VAR 0 4
87491: PPUSH
87492: LD_VAR 0 5
87496: PPUSH
87497: CALL_OW 1
87501: ST_TO_ADDR
// break ;
87502: GO 87506
// end ; end ;
87504: GO 87434
87506: POP
87507: POP
// end ;
87508: LD_VAR 0 3
87512: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87513: LD_INT 0
87515: PPUSH
87516: PPUSH
87517: PPUSH
// if not mc_bases or not skirmish then
87518: LD_EXP 31
87522: NOT
87523: PUSH
87524: LD_EXP 29
87528: NOT
87529: OR
87530: IFFALSE 87534
// exit ;
87532: GO 87733
// for i = 1 to mc_bases do
87534: LD_ADDR_VAR 0 5
87538: PUSH
87539: DOUBLE
87540: LD_INT 1
87542: DEC
87543: ST_TO_ADDR
87544: LD_EXP 31
87548: PUSH
87549: FOR_TO
87550: IFFALSE 87731
// if building in mc_bases [ i ] then
87552: LD_VAR 0 1
87556: PUSH
87557: LD_EXP 31
87561: PUSH
87562: LD_VAR 0 5
87566: ARRAY
87567: IN
87568: IFFALSE 87729
// begin tmp := mc_bases [ i ] diff building ;
87570: LD_ADDR_VAR 0 6
87574: PUSH
87575: LD_EXP 31
87579: PUSH
87580: LD_VAR 0 5
87584: ARRAY
87585: PUSH
87586: LD_VAR 0 1
87590: DIFF
87591: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87592: LD_ADDR_EXP 31
87596: PUSH
87597: LD_EXP 31
87601: PPUSH
87602: LD_VAR 0 5
87606: PPUSH
87607: LD_VAR 0 6
87611: PPUSH
87612: CALL_OW 1
87616: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87617: LD_VAR 0 1
87621: PUSH
87622: LD_EXP 39
87626: PUSH
87627: LD_VAR 0 5
87631: ARRAY
87632: IN
87633: IFFALSE 87672
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87635: LD_ADDR_EXP 39
87639: PUSH
87640: LD_EXP 39
87644: PPUSH
87645: LD_VAR 0 5
87649: PPUSH
87650: LD_EXP 39
87654: PUSH
87655: LD_VAR 0 5
87659: ARRAY
87660: PUSH
87661: LD_VAR 0 1
87665: DIFF
87666: PPUSH
87667: CALL_OW 1
87671: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87672: LD_VAR 0 1
87676: PUSH
87677: LD_EXP 40
87681: PUSH
87682: LD_VAR 0 5
87686: ARRAY
87687: IN
87688: IFFALSE 87727
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87690: LD_ADDR_EXP 40
87694: PUSH
87695: LD_EXP 40
87699: PPUSH
87700: LD_VAR 0 5
87704: PPUSH
87705: LD_EXP 40
87709: PUSH
87710: LD_VAR 0 5
87714: ARRAY
87715: PUSH
87716: LD_VAR 0 1
87720: DIFF
87721: PPUSH
87722: CALL_OW 1
87726: ST_TO_ADDR
// break ;
87727: GO 87731
// end ;
87729: GO 87549
87731: POP
87732: POP
// end ;
87733: LD_VAR 0 4
87737: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87738: LD_INT 0
87740: PPUSH
87741: PPUSH
87742: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87743: LD_EXP 31
87747: NOT
87748: PUSH
87749: LD_EXP 29
87753: NOT
87754: OR
87755: PUSH
87756: LD_VAR 0 3
87760: PUSH
87761: LD_EXP 57
87765: IN
87766: NOT
87767: OR
87768: IFFALSE 87772
// exit ;
87770: GO 87895
// for i = 1 to mc_vehicles do
87772: LD_ADDR_VAR 0 6
87776: PUSH
87777: DOUBLE
87778: LD_INT 1
87780: DEC
87781: ST_TO_ADDR
87782: LD_EXP 50
87786: PUSH
87787: FOR_TO
87788: IFFALSE 87893
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87790: LD_VAR 0 2
87794: PUSH
87795: LD_EXP 50
87799: PUSH
87800: LD_VAR 0 6
87804: ARRAY
87805: IN
87806: PUSH
87807: LD_VAR 0 1
87811: PUSH
87812: LD_EXP 50
87816: PUSH
87817: LD_VAR 0 6
87821: ARRAY
87822: IN
87823: OR
87824: IFFALSE 87891
// begin tmp := mc_vehicles [ i ] diff old ;
87826: LD_ADDR_VAR 0 7
87830: PUSH
87831: LD_EXP 50
87835: PUSH
87836: LD_VAR 0 6
87840: ARRAY
87841: PUSH
87842: LD_VAR 0 2
87846: DIFF
87847: ST_TO_ADDR
// tmp := tmp diff new ;
87848: LD_ADDR_VAR 0 7
87852: PUSH
87853: LD_VAR 0 7
87857: PUSH
87858: LD_VAR 0 1
87862: DIFF
87863: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87864: LD_ADDR_EXP 50
87868: PUSH
87869: LD_EXP 50
87873: PPUSH
87874: LD_VAR 0 6
87878: PPUSH
87879: LD_VAR 0 7
87883: PPUSH
87884: CALL_OW 1
87888: ST_TO_ADDR
// break ;
87889: GO 87893
// end ;
87891: GO 87787
87893: POP
87894: POP
// end ;
87895: LD_VAR 0 5
87899: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87900: LD_INT 0
87902: PPUSH
87903: PPUSH
87904: PPUSH
87905: PPUSH
// if not mc_bases or not skirmish then
87906: LD_EXP 31
87910: NOT
87911: PUSH
87912: LD_EXP 29
87916: NOT
87917: OR
87918: IFFALSE 87922
// exit ;
87920: GO 88342
// repeat wait ( 0 0$1 ) ;
87922: LD_INT 35
87924: PPUSH
87925: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
87929: LD_EXP 75
87933: NOT
87934: IFFALSE 87922
// mc_block_vehicle_constructed_thread := true ;
87936: LD_ADDR_EXP 75
87940: PUSH
87941: LD_INT 1
87943: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
87944: LD_ADDR_VAR 0 5
87948: PUSH
87949: LD_VAR 0 1
87953: PPUSH
87954: CALL_OW 255
87958: ST_TO_ADDR
// for i = 1 to mc_bases do
87959: LD_ADDR_VAR 0 4
87963: PUSH
87964: DOUBLE
87965: LD_INT 1
87967: DEC
87968: ST_TO_ADDR
87969: LD_EXP 31
87973: PUSH
87974: FOR_TO
87975: IFFALSE 88332
// begin if factory in mc_bases [ i ] then
87977: LD_VAR 0 2
87981: PUSH
87982: LD_EXP 31
87986: PUSH
87987: LD_VAR 0 4
87991: ARRAY
87992: IN
87993: IFFALSE 88330
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87995: LD_EXP 53
87999: PUSH
88000: LD_VAR 0 4
88004: ARRAY
88005: PUSH
88006: LD_EXP 42
88010: PUSH
88011: LD_VAR 0 4
88015: ARRAY
88016: LESS
88017: PUSH
88018: LD_VAR 0 1
88022: PPUSH
88023: CALL_OW 264
88027: PUSH
88028: LD_INT 31
88030: PUSH
88031: LD_INT 32
88033: PUSH
88034: LD_INT 51
88036: PUSH
88037: LD_INT 89
88039: PUSH
88040: LD_INT 12
88042: PUSH
88043: LD_INT 30
88045: PUSH
88046: LD_INT 98
88048: PUSH
88049: LD_INT 11
88051: PUSH
88052: LD_INT 53
88054: PUSH
88055: LD_INT 14
88057: PUSH
88058: LD_INT 91
88060: PUSH
88061: LD_INT 29
88063: PUSH
88064: LD_INT 99
88066: PUSH
88067: LD_INT 13
88069: PUSH
88070: LD_INT 52
88072: PUSH
88073: LD_INT 88
88075: PUSH
88076: LD_INT 48
88078: PUSH
88079: LD_INT 8
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: IN
88102: NOT
88103: AND
88104: IFFALSE 88152
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88106: LD_ADDR_EXP 53
88110: PUSH
88111: LD_EXP 53
88115: PPUSH
88116: LD_VAR 0 4
88120: PUSH
88121: LD_EXP 53
88125: PUSH
88126: LD_VAR 0 4
88130: ARRAY
88131: PUSH
88132: LD_INT 1
88134: PLUS
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PPUSH
88140: LD_VAR 0 1
88144: PPUSH
88145: CALL 25021 0 3
88149: ST_TO_ADDR
88150: GO 88196
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88152: LD_ADDR_EXP 50
88156: PUSH
88157: LD_EXP 50
88161: PPUSH
88162: LD_VAR 0 4
88166: PUSH
88167: LD_EXP 50
88171: PUSH
88172: LD_VAR 0 4
88176: ARRAY
88177: PUSH
88178: LD_INT 1
88180: PLUS
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PPUSH
88186: LD_VAR 0 1
88190: PPUSH
88191: CALL 25021 0 3
88195: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
88196: LD_ADDR_EXP 75
88200: PUSH
88201: LD_INT 0
88203: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88204: LD_VAR 0 1
88208: PPUSH
88209: CALL_OW 263
88213: PUSH
88214: LD_INT 2
88216: EQUAL
88217: IFFALSE 88246
// begin repeat wait ( 0 0$3 ) ;
88219: LD_INT 105
88221: PPUSH
88222: CALL_OW 67
// Connect ( vehicle ) ;
88226: LD_VAR 0 1
88230: PPUSH
88231: CALL 27990 0 1
// until IsControledBy ( vehicle ) ;
88235: LD_VAR 0 1
88239: PPUSH
88240: CALL_OW 312
88244: IFFALSE 88219
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88246: LD_VAR 0 1
88250: PPUSH
88251: LD_EXP 55
88255: PUSH
88256: LD_VAR 0 4
88260: ARRAY
88261: PPUSH
88262: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88266: LD_VAR 0 1
88270: PPUSH
88271: CALL_OW 263
88275: PUSH
88276: LD_INT 1
88278: NONEQUAL
88279: IFFALSE 88283
// break ;
88281: GO 88332
// repeat wait ( 0 0$1 ) ;
88283: LD_INT 35
88285: PPUSH
88286: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88290: LD_VAR 0 1
88294: PPUSH
88295: LD_EXP 55
88299: PUSH
88300: LD_VAR 0 4
88304: ARRAY
88305: PPUSH
88306: CALL_OW 308
88310: IFFALSE 88283
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88312: LD_VAR 0 1
88316: PPUSH
88317: CALL_OW 311
88321: PPUSH
88322: CALL_OW 121
// exit ;
88326: POP
88327: POP
88328: GO 88342
// end ; end ;
88330: GO 87974
88332: POP
88333: POP
// mc_block_vehicle_constructed_thread := false ;
88334: LD_ADDR_EXP 75
88338: PUSH
88339: LD_INT 0
88341: ST_TO_ADDR
// end ;
88342: LD_VAR 0 3
88346: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88347: LD_INT 0
88349: PPUSH
88350: PPUSH
88351: PPUSH
88352: PPUSH
// if not mc_bases or not skirmish then
88353: LD_EXP 31
88357: NOT
88358: PUSH
88359: LD_EXP 29
88363: NOT
88364: OR
88365: IFFALSE 88369
// exit ;
88367: GO 88722
// repeat wait ( 0 0$1 ) ;
88369: LD_INT 35
88371: PPUSH
88372: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88376: LD_VAR 0 2
88380: PPUSH
88381: LD_VAR 0 3
88385: PPUSH
88386: CALL_OW 284
88390: IFFALSE 88369
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88392: LD_VAR 0 2
88396: PPUSH
88397: LD_VAR 0 3
88401: PPUSH
88402: CALL_OW 283
88406: PUSH
88407: LD_INT 4
88409: EQUAL
88410: IFFALSE 88414
// exit ;
88412: GO 88722
// for i = 1 to mc_bases do
88414: LD_ADDR_VAR 0 7
88418: PUSH
88419: DOUBLE
88420: LD_INT 1
88422: DEC
88423: ST_TO_ADDR
88424: LD_EXP 31
88428: PUSH
88429: FOR_TO
88430: IFFALSE 88720
// begin if mc_crates_area [ i ] then
88432: LD_EXP 49
88436: PUSH
88437: LD_VAR 0 7
88441: ARRAY
88442: IFFALSE 88553
// for j in mc_crates_area [ i ] do
88444: LD_ADDR_VAR 0 8
88448: PUSH
88449: LD_EXP 49
88453: PUSH
88454: LD_VAR 0 7
88458: ARRAY
88459: PUSH
88460: FOR_IN
88461: IFFALSE 88551
// if InArea ( x , y , j ) then
88463: LD_VAR 0 2
88467: PPUSH
88468: LD_VAR 0 3
88472: PPUSH
88473: LD_VAR 0 8
88477: PPUSH
88478: CALL_OW 309
88482: IFFALSE 88549
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88484: LD_ADDR_EXP 47
88488: PUSH
88489: LD_EXP 47
88493: PPUSH
88494: LD_VAR 0 7
88498: PUSH
88499: LD_EXP 47
88503: PUSH
88504: LD_VAR 0 7
88508: ARRAY
88509: PUSH
88510: LD_INT 1
88512: PLUS
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PPUSH
88518: LD_VAR 0 4
88522: PUSH
88523: LD_VAR 0 2
88527: PUSH
88528: LD_VAR 0 3
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: LIST
88537: PPUSH
88538: CALL 25021 0 3
88542: ST_TO_ADDR
// exit ;
88543: POP
88544: POP
88545: POP
88546: POP
88547: GO 88722
// end ;
88549: GO 88460
88551: POP
88552: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88553: LD_ADDR_VAR 0 9
88557: PUSH
88558: LD_EXP 31
88562: PUSH
88563: LD_VAR 0 7
88567: ARRAY
88568: PPUSH
88569: LD_INT 2
88571: PUSH
88572: LD_INT 30
88574: PUSH
88575: LD_INT 0
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: PUSH
88582: LD_INT 30
88584: PUSH
88585: LD_INT 1
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: LIST
88596: PPUSH
88597: CALL_OW 72
88601: ST_TO_ADDR
// if not depot then
88602: LD_VAR 0 9
88606: NOT
88607: IFFALSE 88611
// continue ;
88609: GO 88429
// for j in depot do
88611: LD_ADDR_VAR 0 8
88615: PUSH
88616: LD_VAR 0 9
88620: PUSH
88621: FOR_IN
88622: IFFALSE 88716
// if GetDistUnitXY ( j , x , y ) < 30 then
88624: LD_VAR 0 8
88628: PPUSH
88629: LD_VAR 0 2
88633: PPUSH
88634: LD_VAR 0 3
88638: PPUSH
88639: CALL_OW 297
88643: PUSH
88644: LD_INT 30
88646: LESS
88647: IFFALSE 88714
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88649: LD_ADDR_EXP 47
88653: PUSH
88654: LD_EXP 47
88658: PPUSH
88659: LD_VAR 0 7
88663: PUSH
88664: LD_EXP 47
88668: PUSH
88669: LD_VAR 0 7
88673: ARRAY
88674: PUSH
88675: LD_INT 1
88677: PLUS
88678: PUSH
88679: EMPTY
88680: LIST
88681: LIST
88682: PPUSH
88683: LD_VAR 0 4
88687: PUSH
88688: LD_VAR 0 2
88692: PUSH
88693: LD_VAR 0 3
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: LIST
88702: PPUSH
88703: CALL 25021 0 3
88707: ST_TO_ADDR
// exit ;
88708: POP
88709: POP
88710: POP
88711: POP
88712: GO 88722
// end ;
88714: GO 88621
88716: POP
88717: POP
// end ;
88718: GO 88429
88720: POP
88721: POP
// end ;
88722: LD_VAR 0 6
88726: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88727: LD_INT 0
88729: PPUSH
88730: PPUSH
88731: PPUSH
88732: PPUSH
// if not mc_bases or not skirmish then
88733: LD_EXP 31
88737: NOT
88738: PUSH
88739: LD_EXP 29
88743: NOT
88744: OR
88745: IFFALSE 88749
// exit ;
88747: GO 89026
// side := GetSide ( lab ) ;
88749: LD_ADDR_VAR 0 4
88753: PUSH
88754: LD_VAR 0 2
88758: PPUSH
88759: CALL_OW 255
88763: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88764: LD_VAR 0 4
88768: PUSH
88769: LD_EXP 57
88773: IN
88774: NOT
88775: PUSH
88776: LD_EXP 58
88780: NOT
88781: OR
88782: PUSH
88783: LD_EXP 31
88787: NOT
88788: OR
88789: IFFALSE 88793
// exit ;
88791: GO 89026
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88793: LD_ADDR_EXP 58
88797: PUSH
88798: LD_EXP 58
88802: PPUSH
88803: LD_VAR 0 4
88807: PPUSH
88808: LD_EXP 58
88812: PUSH
88813: LD_VAR 0 4
88817: ARRAY
88818: PUSH
88819: LD_VAR 0 1
88823: DIFF
88824: PPUSH
88825: CALL_OW 1
88829: ST_TO_ADDR
// for i = 1 to mc_bases do
88830: LD_ADDR_VAR 0 5
88834: PUSH
88835: DOUBLE
88836: LD_INT 1
88838: DEC
88839: ST_TO_ADDR
88840: LD_EXP 31
88844: PUSH
88845: FOR_TO
88846: IFFALSE 89024
// begin if lab in mc_bases [ i ] then
88848: LD_VAR 0 2
88852: PUSH
88853: LD_EXP 31
88857: PUSH
88858: LD_VAR 0 5
88862: ARRAY
88863: IN
88864: IFFALSE 89022
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88866: LD_VAR 0 1
88870: PUSH
88871: LD_INT 11
88873: PUSH
88874: LD_INT 4
88876: PUSH
88877: LD_INT 3
88879: PUSH
88880: LD_INT 2
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: IN
88889: PUSH
88890: LD_EXP 61
88894: PUSH
88895: LD_VAR 0 5
88899: ARRAY
88900: AND
88901: IFFALSE 89022
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88903: LD_ADDR_VAR 0 6
88907: PUSH
88908: LD_EXP 61
88912: PUSH
88913: LD_VAR 0 5
88917: ARRAY
88918: PUSH
88919: LD_INT 1
88921: ARRAY
88922: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88923: LD_ADDR_EXP 61
88927: PUSH
88928: LD_EXP 61
88932: PPUSH
88933: LD_VAR 0 5
88937: PPUSH
88938: EMPTY
88939: PPUSH
88940: CALL_OW 1
88944: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88945: LD_VAR 0 6
88949: PPUSH
88950: LD_INT 0
88952: PPUSH
88953: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88957: LD_VAR 0 6
88961: PPUSH
88962: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88966: LD_ADDR_EXP 60
88970: PUSH
88971: LD_EXP 60
88975: PPUSH
88976: LD_VAR 0 5
88980: PPUSH
88981: LD_EXP 60
88985: PUSH
88986: LD_VAR 0 5
88990: ARRAY
88991: PPUSH
88992: LD_INT 1
88994: PPUSH
88995: LD_VAR 0 6
88999: PPUSH
89000: CALL_OW 2
89004: PPUSH
89005: CALL_OW 1
89009: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
89010: LD_VAR 0 5
89014: PPUSH
89015: LD_INT 112
89017: PPUSH
89018: CALL 65474 0 2
// end ; end ; end ;
89022: GO 88845
89024: POP
89025: POP
// end ;
89026: LD_VAR 0 3
89030: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
89031: LD_INT 0
89033: PPUSH
89034: PPUSH
89035: PPUSH
89036: PPUSH
89037: PPUSH
89038: PPUSH
89039: PPUSH
89040: PPUSH
// if not mc_bases or not skirmish then
89041: LD_EXP 31
89045: NOT
89046: PUSH
89047: LD_EXP 29
89051: NOT
89052: OR
89053: IFFALSE 89057
// exit ;
89055: GO 90426
// for i = 1 to mc_bases do
89057: LD_ADDR_VAR 0 3
89061: PUSH
89062: DOUBLE
89063: LD_INT 1
89065: DEC
89066: ST_TO_ADDR
89067: LD_EXP 31
89071: PUSH
89072: FOR_TO
89073: IFFALSE 90424
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
89075: LD_VAR 0 1
89079: PUSH
89080: LD_EXP 31
89084: PUSH
89085: LD_VAR 0 3
89089: ARRAY
89090: IN
89091: PUSH
89092: LD_VAR 0 1
89096: PUSH
89097: LD_EXP 38
89101: PUSH
89102: LD_VAR 0 3
89106: ARRAY
89107: IN
89108: OR
89109: PUSH
89110: LD_VAR 0 1
89114: PUSH
89115: LD_EXP 53
89119: PUSH
89120: LD_VAR 0 3
89124: ARRAY
89125: IN
89126: OR
89127: PUSH
89128: LD_VAR 0 1
89132: PUSH
89133: LD_EXP 50
89137: PUSH
89138: LD_VAR 0 3
89142: ARRAY
89143: IN
89144: OR
89145: PUSH
89146: LD_VAR 0 1
89150: PUSH
89151: LD_EXP 60
89155: PUSH
89156: LD_VAR 0 3
89160: ARRAY
89161: IN
89162: OR
89163: PUSH
89164: LD_VAR 0 1
89168: PUSH
89169: LD_EXP 61
89173: PUSH
89174: LD_VAR 0 3
89178: ARRAY
89179: IN
89180: OR
89181: IFFALSE 90422
// begin if un in mc_ape [ i ] then
89183: LD_VAR 0 1
89187: PUSH
89188: LD_EXP 60
89192: PUSH
89193: LD_VAR 0 3
89197: ARRAY
89198: IN
89199: IFFALSE 89238
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89201: LD_ADDR_EXP 60
89205: PUSH
89206: LD_EXP 60
89210: PPUSH
89211: LD_VAR 0 3
89215: PPUSH
89216: LD_EXP 60
89220: PUSH
89221: LD_VAR 0 3
89225: ARRAY
89226: PUSH
89227: LD_VAR 0 1
89231: DIFF
89232: PPUSH
89233: CALL_OW 1
89237: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89238: LD_VAR 0 1
89242: PUSH
89243: LD_EXP 61
89247: PUSH
89248: LD_VAR 0 3
89252: ARRAY
89253: IN
89254: IFFALSE 89278
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89256: LD_ADDR_EXP 61
89260: PUSH
89261: LD_EXP 61
89265: PPUSH
89266: LD_VAR 0 3
89270: PPUSH
89271: EMPTY
89272: PPUSH
89273: CALL_OW 1
89277: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89278: LD_VAR 0 1
89282: PPUSH
89283: CALL_OW 247
89287: PUSH
89288: LD_INT 2
89290: EQUAL
89291: PUSH
89292: LD_VAR 0 1
89296: PPUSH
89297: CALL_OW 110
89301: PUSH
89302: LD_INT 20
89304: EQUAL
89305: PUSH
89306: LD_VAR 0 1
89310: PUSH
89311: LD_EXP 53
89315: PUSH
89316: LD_VAR 0 3
89320: ARRAY
89321: IN
89322: OR
89323: PUSH
89324: LD_VAR 0 1
89328: PPUSH
89329: CALL_OW 264
89333: PUSH
89334: LD_INT 12
89336: PUSH
89337: LD_INT 51
89339: PUSH
89340: LD_INT 89
89342: PUSH
89343: LD_INT 32
89345: PUSH
89346: LD_INT 13
89348: PUSH
89349: LD_INT 52
89351: PUSH
89352: LD_INT 31
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: IN
89364: OR
89365: AND
89366: IFFALSE 89674
// begin if un in mc_defender [ i ] then
89368: LD_VAR 0 1
89372: PUSH
89373: LD_EXP 53
89377: PUSH
89378: LD_VAR 0 3
89382: ARRAY
89383: IN
89384: IFFALSE 89423
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89386: LD_ADDR_EXP 53
89390: PUSH
89391: LD_EXP 53
89395: PPUSH
89396: LD_VAR 0 3
89400: PPUSH
89401: LD_EXP 53
89405: PUSH
89406: LD_VAR 0 3
89410: ARRAY
89411: PUSH
89412: LD_VAR 0 1
89416: DIFF
89417: PPUSH
89418: CALL_OW 1
89422: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89423: LD_ADDR_VAR 0 8
89427: PUSH
89428: LD_VAR 0 3
89432: PPUSH
89433: LD_INT 3
89435: PPUSH
89436: CALL 86044 0 2
89440: ST_TO_ADDR
// if fac then
89441: LD_VAR 0 8
89445: IFFALSE 89674
// begin for j in fac do
89447: LD_ADDR_VAR 0 4
89451: PUSH
89452: LD_VAR 0 8
89456: PUSH
89457: FOR_IN
89458: IFFALSE 89672
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89460: LD_ADDR_VAR 0 9
89464: PUSH
89465: LD_VAR 0 8
89469: PPUSH
89470: LD_VAR 0 1
89474: PPUSH
89475: CALL_OW 265
89479: PPUSH
89480: LD_VAR 0 1
89484: PPUSH
89485: CALL_OW 262
89489: PPUSH
89490: LD_VAR 0 1
89494: PPUSH
89495: CALL_OW 263
89499: PPUSH
89500: LD_VAR 0 1
89504: PPUSH
89505: CALL_OW 264
89509: PPUSH
89510: CALL 22519 0 5
89514: ST_TO_ADDR
// if components then
89515: LD_VAR 0 9
89519: IFFALSE 89670
// begin if GetWeapon ( un ) = ar_control_tower then
89521: LD_VAR 0 1
89525: PPUSH
89526: CALL_OW 264
89530: PUSH
89531: LD_INT 31
89533: EQUAL
89534: IFFALSE 89651
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89536: LD_VAR 0 1
89540: PPUSH
89541: CALL_OW 311
89545: PPUSH
89546: LD_INT 0
89548: PPUSH
89549: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89553: LD_ADDR_EXP 71
89557: PUSH
89558: LD_EXP 71
89562: PPUSH
89563: LD_VAR 0 3
89567: PPUSH
89568: LD_EXP 71
89572: PUSH
89573: LD_VAR 0 3
89577: ARRAY
89578: PUSH
89579: LD_VAR 0 1
89583: PPUSH
89584: CALL_OW 311
89588: DIFF
89589: PPUSH
89590: CALL_OW 1
89594: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89595: LD_ADDR_VAR 0 7
89599: PUSH
89600: LD_EXP 52
89604: PUSH
89605: LD_VAR 0 3
89609: ARRAY
89610: PPUSH
89611: LD_INT 1
89613: PPUSH
89614: LD_VAR 0 9
89618: PPUSH
89619: CALL_OW 2
89623: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89624: LD_ADDR_EXP 52
89628: PUSH
89629: LD_EXP 52
89633: PPUSH
89634: LD_VAR 0 3
89638: PPUSH
89639: LD_VAR 0 7
89643: PPUSH
89644: CALL_OW 1
89648: ST_TO_ADDR
// end else
89649: GO 89668
// MC_InsertProduceList ( i , [ components ] ) ;
89651: LD_VAR 0 3
89655: PPUSH
89656: LD_VAR 0 9
89660: PUSH
89661: EMPTY
89662: LIST
89663: PPUSH
89664: CALL 85589 0 2
// break ;
89668: GO 89672
// end ; end ;
89670: GO 89457
89672: POP
89673: POP
// end ; end ; if GetType ( un ) = unit_building then
89674: LD_VAR 0 1
89678: PPUSH
89679: CALL_OW 247
89683: PUSH
89684: LD_INT 3
89686: EQUAL
89687: IFFALSE 90090
// begin btype := GetBType ( un ) ;
89689: LD_ADDR_VAR 0 5
89693: PUSH
89694: LD_VAR 0 1
89698: PPUSH
89699: CALL_OW 266
89703: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89704: LD_VAR 0 5
89708: PUSH
89709: LD_INT 29
89711: PUSH
89712: LD_INT 30
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: IN
89719: IFFALSE 89792
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89721: LD_VAR 0 1
89725: PPUSH
89726: CALL_OW 250
89730: PPUSH
89731: LD_VAR 0 1
89735: PPUSH
89736: CALL_OW 251
89740: PPUSH
89741: LD_VAR 0 1
89745: PPUSH
89746: CALL_OW 255
89750: PPUSH
89751: CALL_OW 440
89755: NOT
89756: IFFALSE 89792
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89758: LD_VAR 0 1
89762: PPUSH
89763: CALL_OW 250
89767: PPUSH
89768: LD_VAR 0 1
89772: PPUSH
89773: CALL_OW 251
89777: PPUSH
89778: LD_VAR 0 1
89782: PPUSH
89783: CALL_OW 255
89787: PPUSH
89788: CALL_OW 441
// end ; if btype = b_warehouse then
89792: LD_VAR 0 5
89796: PUSH
89797: LD_INT 1
89799: EQUAL
89800: IFFALSE 89818
// begin btype := b_depot ;
89802: LD_ADDR_VAR 0 5
89806: PUSH
89807: LD_INT 0
89809: ST_TO_ADDR
// pos := 1 ;
89810: LD_ADDR_VAR 0 6
89814: PUSH
89815: LD_INT 1
89817: ST_TO_ADDR
// end ; if btype = b_factory then
89818: LD_VAR 0 5
89822: PUSH
89823: LD_INT 3
89825: EQUAL
89826: IFFALSE 89844
// begin btype := b_workshop ;
89828: LD_ADDR_VAR 0 5
89832: PUSH
89833: LD_INT 2
89835: ST_TO_ADDR
// pos := 1 ;
89836: LD_ADDR_VAR 0 6
89840: PUSH
89841: LD_INT 1
89843: ST_TO_ADDR
// end ; if btype = b_barracks then
89844: LD_VAR 0 5
89848: PUSH
89849: LD_INT 5
89851: EQUAL
89852: IFFALSE 89862
// btype := b_armoury ;
89854: LD_ADDR_VAR 0 5
89858: PUSH
89859: LD_INT 4
89861: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89862: LD_VAR 0 5
89866: PUSH
89867: LD_INT 7
89869: PUSH
89870: LD_INT 8
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: IN
89877: IFFALSE 89887
// btype := b_lab ;
89879: LD_ADDR_VAR 0 5
89883: PUSH
89884: LD_INT 6
89886: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89887: LD_ADDR_EXP 36
89891: PUSH
89892: LD_EXP 36
89896: PPUSH
89897: LD_VAR 0 3
89901: PUSH
89902: LD_EXP 36
89906: PUSH
89907: LD_VAR 0 3
89911: ARRAY
89912: PUSH
89913: LD_INT 1
89915: PLUS
89916: PUSH
89917: EMPTY
89918: LIST
89919: LIST
89920: PPUSH
89921: LD_VAR 0 5
89925: PUSH
89926: LD_VAR 0 1
89930: PPUSH
89931: CALL_OW 250
89935: PUSH
89936: LD_VAR 0 1
89940: PPUSH
89941: CALL_OW 251
89945: PUSH
89946: LD_VAR 0 1
89950: PPUSH
89951: CALL_OW 254
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: PPUSH
89962: CALL 25021 0 3
89966: ST_TO_ADDR
// if pos = 1 then
89967: LD_VAR 0 6
89971: PUSH
89972: LD_INT 1
89974: EQUAL
89975: IFFALSE 90090
// begin tmp := mc_build_list [ i ] ;
89977: LD_ADDR_VAR 0 7
89981: PUSH
89982: LD_EXP 36
89986: PUSH
89987: LD_VAR 0 3
89991: ARRAY
89992: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89993: LD_VAR 0 7
89997: PPUSH
89998: LD_INT 2
90000: PUSH
90001: LD_INT 30
90003: PUSH
90004: LD_INT 0
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: LD_INT 30
90013: PUSH
90014: LD_INT 1
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: EMPTY
90022: LIST
90023: LIST
90024: LIST
90025: PPUSH
90026: CALL_OW 72
90030: IFFALSE 90040
// pos := 2 ;
90032: LD_ADDR_VAR 0 6
90036: PUSH
90037: LD_INT 2
90039: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
90040: LD_ADDR_VAR 0 7
90044: PUSH
90045: LD_VAR 0 7
90049: PPUSH
90050: LD_VAR 0 6
90054: PPUSH
90055: LD_VAR 0 7
90059: PPUSH
90060: CALL 25347 0 3
90064: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
90065: LD_ADDR_EXP 36
90069: PUSH
90070: LD_EXP 36
90074: PPUSH
90075: LD_VAR 0 3
90079: PPUSH
90080: LD_VAR 0 7
90084: PPUSH
90085: CALL_OW 1
90089: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
90090: LD_VAR 0 1
90094: PUSH
90095: LD_EXP 31
90099: PUSH
90100: LD_VAR 0 3
90104: ARRAY
90105: IN
90106: IFFALSE 90145
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90108: LD_ADDR_EXP 31
90112: PUSH
90113: LD_EXP 31
90117: PPUSH
90118: LD_VAR 0 3
90122: PPUSH
90123: LD_EXP 31
90127: PUSH
90128: LD_VAR 0 3
90132: ARRAY
90133: PUSH
90134: LD_VAR 0 1
90138: DIFF
90139: PPUSH
90140: CALL_OW 1
90144: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90145: LD_VAR 0 1
90149: PUSH
90150: LD_EXP 38
90154: PUSH
90155: LD_VAR 0 3
90159: ARRAY
90160: IN
90161: IFFALSE 90200
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90163: LD_ADDR_EXP 38
90167: PUSH
90168: LD_EXP 38
90172: PPUSH
90173: LD_VAR 0 3
90177: PPUSH
90178: LD_EXP 38
90182: PUSH
90183: LD_VAR 0 3
90187: ARRAY
90188: PUSH
90189: LD_VAR 0 1
90193: DIFF
90194: PPUSH
90195: CALL_OW 1
90199: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90200: LD_VAR 0 1
90204: PUSH
90205: LD_EXP 50
90209: PUSH
90210: LD_VAR 0 3
90214: ARRAY
90215: IN
90216: IFFALSE 90255
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90218: LD_ADDR_EXP 50
90222: PUSH
90223: LD_EXP 50
90227: PPUSH
90228: LD_VAR 0 3
90232: PPUSH
90233: LD_EXP 50
90237: PUSH
90238: LD_VAR 0 3
90242: ARRAY
90243: PUSH
90244: LD_VAR 0 1
90248: DIFF
90249: PPUSH
90250: CALL_OW 1
90254: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90255: LD_VAR 0 1
90259: PUSH
90260: LD_EXP 53
90264: PUSH
90265: LD_VAR 0 3
90269: ARRAY
90270: IN
90271: IFFALSE 90310
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90273: LD_ADDR_EXP 53
90277: PUSH
90278: LD_EXP 53
90282: PPUSH
90283: LD_VAR 0 3
90287: PPUSH
90288: LD_EXP 53
90292: PUSH
90293: LD_VAR 0 3
90297: ARRAY
90298: PUSH
90299: LD_VAR 0 1
90303: DIFF
90304: PPUSH
90305: CALL_OW 1
90309: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90310: LD_VAR 0 1
90314: PUSH
90315: LD_EXP 40
90319: PUSH
90320: LD_VAR 0 3
90324: ARRAY
90325: IN
90326: IFFALSE 90365
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90328: LD_ADDR_EXP 40
90332: PUSH
90333: LD_EXP 40
90337: PPUSH
90338: LD_VAR 0 3
90342: PPUSH
90343: LD_EXP 40
90347: PUSH
90348: LD_VAR 0 3
90352: ARRAY
90353: PUSH
90354: LD_VAR 0 1
90358: DIFF
90359: PPUSH
90360: CALL_OW 1
90364: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90365: LD_VAR 0 1
90369: PUSH
90370: LD_EXP 39
90374: PUSH
90375: LD_VAR 0 3
90379: ARRAY
90380: IN
90381: IFFALSE 90420
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90383: LD_ADDR_EXP 39
90387: PUSH
90388: LD_EXP 39
90392: PPUSH
90393: LD_VAR 0 3
90397: PPUSH
90398: LD_EXP 39
90402: PUSH
90403: LD_VAR 0 3
90407: ARRAY
90408: PUSH
90409: LD_VAR 0 1
90413: DIFF
90414: PPUSH
90415: CALL_OW 1
90419: ST_TO_ADDR
// end ; break ;
90420: GO 90424
// end ;
90422: GO 89072
90424: POP
90425: POP
// end ;
90426: LD_VAR 0 2
90430: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90431: LD_INT 0
90433: PPUSH
90434: PPUSH
90435: PPUSH
// if not mc_bases or not skirmish then
90436: LD_EXP 31
90440: NOT
90441: PUSH
90442: LD_EXP 29
90446: NOT
90447: OR
90448: IFFALSE 90452
// exit ;
90450: GO 90667
// for i = 1 to mc_bases do
90452: LD_ADDR_VAR 0 3
90456: PUSH
90457: DOUBLE
90458: LD_INT 1
90460: DEC
90461: ST_TO_ADDR
90462: LD_EXP 31
90466: PUSH
90467: FOR_TO
90468: IFFALSE 90665
// begin if building in mc_construct_list [ i ] then
90470: LD_VAR 0 1
90474: PUSH
90475: LD_EXP 38
90479: PUSH
90480: LD_VAR 0 3
90484: ARRAY
90485: IN
90486: IFFALSE 90663
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90488: LD_ADDR_EXP 38
90492: PUSH
90493: LD_EXP 38
90497: PPUSH
90498: LD_VAR 0 3
90502: PPUSH
90503: LD_EXP 38
90507: PUSH
90508: LD_VAR 0 3
90512: ARRAY
90513: PUSH
90514: LD_VAR 0 1
90518: DIFF
90519: PPUSH
90520: CALL_OW 1
90524: ST_TO_ADDR
// if building in mc_lab [ i ] then
90525: LD_VAR 0 1
90529: PUSH
90530: LD_EXP 64
90534: PUSH
90535: LD_VAR 0 3
90539: ARRAY
90540: IN
90541: IFFALSE 90596
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90543: LD_ADDR_EXP 65
90547: PUSH
90548: LD_EXP 65
90552: PPUSH
90553: LD_VAR 0 3
90557: PPUSH
90558: LD_EXP 65
90562: PUSH
90563: LD_VAR 0 3
90567: ARRAY
90568: PPUSH
90569: LD_INT 1
90571: PPUSH
90572: LD_EXP 65
90576: PUSH
90577: LD_VAR 0 3
90581: ARRAY
90582: PPUSH
90583: LD_INT 0
90585: PPUSH
90586: CALL 24439 0 4
90590: PPUSH
90591: CALL_OW 1
90595: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90596: LD_VAR 0 1
90600: PUSH
90601: LD_EXP 31
90605: PUSH
90606: LD_VAR 0 3
90610: ARRAY
90611: IN
90612: NOT
90613: IFFALSE 90659
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90615: LD_ADDR_EXP 31
90619: PUSH
90620: LD_EXP 31
90624: PPUSH
90625: LD_VAR 0 3
90629: PUSH
90630: LD_EXP 31
90634: PUSH
90635: LD_VAR 0 3
90639: ARRAY
90640: PUSH
90641: LD_INT 1
90643: PLUS
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PPUSH
90649: LD_VAR 0 1
90653: PPUSH
90654: CALL 25021 0 3
90658: ST_TO_ADDR
// exit ;
90659: POP
90660: POP
90661: GO 90667
// end ; end ;
90663: GO 90467
90665: POP
90666: POP
// end ;
90667: LD_VAR 0 2
90671: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90672: LD_INT 0
90674: PPUSH
90675: PPUSH
90676: PPUSH
90677: PPUSH
90678: PPUSH
90679: PPUSH
90680: PPUSH
// if not mc_bases or not skirmish then
90681: LD_EXP 31
90685: NOT
90686: PUSH
90687: LD_EXP 29
90691: NOT
90692: OR
90693: IFFALSE 90697
// exit ;
90695: GO 91358
// for i = 1 to mc_bases do
90697: LD_ADDR_VAR 0 3
90701: PUSH
90702: DOUBLE
90703: LD_INT 1
90705: DEC
90706: ST_TO_ADDR
90707: LD_EXP 31
90711: PUSH
90712: FOR_TO
90713: IFFALSE 91356
// begin if building in mc_construct_list [ i ] then
90715: LD_VAR 0 1
90719: PUSH
90720: LD_EXP 38
90724: PUSH
90725: LD_VAR 0 3
90729: ARRAY
90730: IN
90731: IFFALSE 91354
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90733: LD_ADDR_EXP 38
90737: PUSH
90738: LD_EXP 38
90742: PPUSH
90743: LD_VAR 0 3
90747: PPUSH
90748: LD_EXP 38
90752: PUSH
90753: LD_VAR 0 3
90757: ARRAY
90758: PUSH
90759: LD_VAR 0 1
90763: DIFF
90764: PPUSH
90765: CALL_OW 1
90769: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90770: LD_ADDR_EXP 31
90774: PUSH
90775: LD_EXP 31
90779: PPUSH
90780: LD_VAR 0 3
90784: PUSH
90785: LD_EXP 31
90789: PUSH
90790: LD_VAR 0 3
90794: ARRAY
90795: PUSH
90796: LD_INT 1
90798: PLUS
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PPUSH
90804: LD_VAR 0 1
90808: PPUSH
90809: CALL 25021 0 3
90813: ST_TO_ADDR
// btype := GetBType ( building ) ;
90814: LD_ADDR_VAR 0 5
90818: PUSH
90819: LD_VAR 0 1
90823: PPUSH
90824: CALL_OW 266
90828: ST_TO_ADDR
// side := GetSide ( building ) ;
90829: LD_ADDR_VAR 0 8
90833: PUSH
90834: LD_VAR 0 1
90838: PPUSH
90839: CALL_OW 255
90843: ST_TO_ADDR
// if btype = b_lab then
90844: LD_VAR 0 5
90848: PUSH
90849: LD_INT 6
90851: EQUAL
90852: IFFALSE 90902
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90854: LD_ADDR_EXP 64
90858: PUSH
90859: LD_EXP 64
90863: PPUSH
90864: LD_VAR 0 3
90868: PUSH
90869: LD_EXP 64
90873: PUSH
90874: LD_VAR 0 3
90878: ARRAY
90879: PUSH
90880: LD_INT 1
90882: PLUS
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PPUSH
90888: LD_VAR 0 1
90892: PPUSH
90893: CALL 25021 0 3
90897: ST_TO_ADDR
// exit ;
90898: POP
90899: POP
90900: GO 91358
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90902: LD_VAR 0 5
90906: PUSH
90907: LD_INT 0
90909: PUSH
90910: LD_INT 2
90912: PUSH
90913: LD_INT 4
90915: PUSH
90916: EMPTY
90917: LIST
90918: LIST
90919: LIST
90920: IN
90921: IFFALSE 91045
// begin if btype = b_armoury then
90923: LD_VAR 0 5
90927: PUSH
90928: LD_INT 4
90930: EQUAL
90931: IFFALSE 90941
// btype := b_barracks ;
90933: LD_ADDR_VAR 0 5
90937: PUSH
90938: LD_INT 5
90940: ST_TO_ADDR
// if btype = b_depot then
90941: LD_VAR 0 5
90945: PUSH
90946: LD_INT 0
90948: EQUAL
90949: IFFALSE 90959
// btype := b_warehouse ;
90951: LD_ADDR_VAR 0 5
90955: PUSH
90956: LD_INT 1
90958: ST_TO_ADDR
// if btype = b_workshop then
90959: LD_VAR 0 5
90963: PUSH
90964: LD_INT 2
90966: EQUAL
90967: IFFALSE 90977
// btype := b_factory ;
90969: LD_ADDR_VAR 0 5
90973: PUSH
90974: LD_INT 3
90976: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90977: LD_VAR 0 5
90981: PPUSH
90982: LD_VAR 0 8
90986: PPUSH
90987: CALL_OW 323
90991: PUSH
90992: LD_INT 1
90994: EQUAL
90995: IFFALSE 91041
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90997: LD_ADDR_EXP 63
91001: PUSH
91002: LD_EXP 63
91006: PPUSH
91007: LD_VAR 0 3
91011: PUSH
91012: LD_EXP 63
91016: PUSH
91017: LD_VAR 0 3
91021: ARRAY
91022: PUSH
91023: LD_INT 1
91025: PLUS
91026: PUSH
91027: EMPTY
91028: LIST
91029: LIST
91030: PPUSH
91031: LD_VAR 0 1
91035: PPUSH
91036: CALL 25021 0 3
91040: ST_TO_ADDR
// exit ;
91041: POP
91042: POP
91043: GO 91358
// end ; if btype in [ b_bunker , b_turret ] then
91045: LD_VAR 0 5
91049: PUSH
91050: LD_INT 32
91052: PUSH
91053: LD_INT 33
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: IN
91060: IFFALSE 91350
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
91062: LD_ADDR_EXP 39
91066: PUSH
91067: LD_EXP 39
91071: PPUSH
91072: LD_VAR 0 3
91076: PUSH
91077: LD_EXP 39
91081: PUSH
91082: LD_VAR 0 3
91086: ARRAY
91087: PUSH
91088: LD_INT 1
91090: PLUS
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PPUSH
91096: LD_VAR 0 1
91100: PPUSH
91101: CALL 25021 0 3
91105: ST_TO_ADDR
// if btype = b_bunker then
91106: LD_VAR 0 5
91110: PUSH
91111: LD_INT 32
91113: EQUAL
91114: IFFALSE 91350
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91116: LD_ADDR_EXP 40
91120: PUSH
91121: LD_EXP 40
91125: PPUSH
91126: LD_VAR 0 3
91130: PUSH
91131: LD_EXP 40
91135: PUSH
91136: LD_VAR 0 3
91140: ARRAY
91141: PUSH
91142: LD_INT 1
91144: PLUS
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PPUSH
91150: LD_VAR 0 1
91154: PPUSH
91155: CALL 25021 0 3
91159: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91160: LD_ADDR_VAR 0 6
91164: PUSH
91165: LD_EXP 31
91169: PUSH
91170: LD_VAR 0 3
91174: ARRAY
91175: PPUSH
91176: LD_INT 25
91178: PUSH
91179: LD_INT 1
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 3
91188: PUSH
91189: LD_INT 54
91191: PUSH
91192: EMPTY
91193: LIST
91194: PUSH
91195: EMPTY
91196: LIST
91197: LIST
91198: PUSH
91199: EMPTY
91200: LIST
91201: LIST
91202: PPUSH
91203: CALL_OW 72
91207: ST_TO_ADDR
// if tmp then
91208: LD_VAR 0 6
91212: IFFALSE 91218
// exit ;
91214: POP
91215: POP
91216: GO 91358
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91218: LD_ADDR_VAR 0 6
91222: PUSH
91223: LD_EXP 31
91227: PUSH
91228: LD_VAR 0 3
91232: ARRAY
91233: PPUSH
91234: LD_INT 2
91236: PUSH
91237: LD_INT 30
91239: PUSH
91240: LD_INT 4
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: LD_INT 30
91249: PUSH
91250: LD_INT 5
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: EMPTY
91258: LIST
91259: LIST
91260: LIST
91261: PPUSH
91262: CALL_OW 72
91266: ST_TO_ADDR
// if not tmp then
91267: LD_VAR 0 6
91271: NOT
91272: IFFALSE 91278
// exit ;
91274: POP
91275: POP
91276: GO 91358
// for j in tmp do
91278: LD_ADDR_VAR 0 4
91282: PUSH
91283: LD_VAR 0 6
91287: PUSH
91288: FOR_IN
91289: IFFALSE 91348
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91291: LD_ADDR_VAR 0 7
91295: PUSH
91296: LD_VAR 0 4
91300: PPUSH
91301: CALL_OW 313
91305: PPUSH
91306: LD_INT 25
91308: PUSH
91309: LD_INT 1
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PPUSH
91316: CALL_OW 72
91320: ST_TO_ADDR
// if units then
91321: LD_VAR 0 7
91325: IFFALSE 91346
// begin ComExitBuilding ( units [ 1 ] ) ;
91327: LD_VAR 0 7
91331: PUSH
91332: LD_INT 1
91334: ARRAY
91335: PPUSH
91336: CALL_OW 122
// exit ;
91340: POP
91341: POP
91342: POP
91343: POP
91344: GO 91358
// end ; end ;
91346: GO 91288
91348: POP
91349: POP
// end ; end ; exit ;
91350: POP
91351: POP
91352: GO 91358
// end ; end ;
91354: GO 90712
91356: POP
91357: POP
// end ;
91358: LD_VAR 0 2
91362: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91363: LD_INT 0
91365: PPUSH
91366: PPUSH
91367: PPUSH
91368: PPUSH
91369: PPUSH
91370: PPUSH
91371: PPUSH
// if not mc_bases or not skirmish then
91372: LD_EXP 31
91376: NOT
91377: PUSH
91378: LD_EXP 29
91382: NOT
91383: OR
91384: IFFALSE 91388
// exit ;
91386: GO 91653
// btype := GetBType ( building ) ;
91388: LD_ADDR_VAR 0 6
91392: PUSH
91393: LD_VAR 0 1
91397: PPUSH
91398: CALL_OW 266
91402: ST_TO_ADDR
// x := GetX ( building ) ;
91403: LD_ADDR_VAR 0 7
91407: PUSH
91408: LD_VAR 0 1
91412: PPUSH
91413: CALL_OW 250
91417: ST_TO_ADDR
// y := GetY ( building ) ;
91418: LD_ADDR_VAR 0 8
91422: PUSH
91423: LD_VAR 0 1
91427: PPUSH
91428: CALL_OW 251
91432: ST_TO_ADDR
// d := GetDir ( building ) ;
91433: LD_ADDR_VAR 0 9
91437: PUSH
91438: LD_VAR 0 1
91442: PPUSH
91443: CALL_OW 254
91447: ST_TO_ADDR
// for i = 1 to mc_bases do
91448: LD_ADDR_VAR 0 4
91452: PUSH
91453: DOUBLE
91454: LD_INT 1
91456: DEC
91457: ST_TO_ADDR
91458: LD_EXP 31
91462: PUSH
91463: FOR_TO
91464: IFFALSE 91651
// begin if not mc_build_list [ i ] then
91466: LD_EXP 36
91470: PUSH
91471: LD_VAR 0 4
91475: ARRAY
91476: NOT
91477: IFFALSE 91481
// continue ;
91479: GO 91463
// for j := 1 to mc_build_list [ i ] do
91481: LD_ADDR_VAR 0 5
91485: PUSH
91486: DOUBLE
91487: LD_INT 1
91489: DEC
91490: ST_TO_ADDR
91491: LD_EXP 36
91495: PUSH
91496: LD_VAR 0 4
91500: ARRAY
91501: PUSH
91502: FOR_TO
91503: IFFALSE 91647
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91505: LD_VAR 0 6
91509: PUSH
91510: LD_VAR 0 7
91514: PUSH
91515: LD_VAR 0 8
91519: PUSH
91520: LD_VAR 0 9
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: PPUSH
91531: LD_EXP 36
91535: PUSH
91536: LD_VAR 0 4
91540: ARRAY
91541: PUSH
91542: LD_VAR 0 5
91546: ARRAY
91547: PPUSH
91548: CALL 31201 0 2
91552: IFFALSE 91645
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91554: LD_ADDR_EXP 36
91558: PUSH
91559: LD_EXP 36
91563: PPUSH
91564: LD_VAR 0 4
91568: PPUSH
91569: LD_EXP 36
91573: PUSH
91574: LD_VAR 0 4
91578: ARRAY
91579: PPUSH
91580: LD_VAR 0 5
91584: PPUSH
91585: CALL_OW 3
91589: PPUSH
91590: CALL_OW 1
91594: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91595: LD_ADDR_EXP 38
91599: PUSH
91600: LD_EXP 38
91604: PPUSH
91605: LD_VAR 0 4
91609: PUSH
91610: LD_EXP 38
91614: PUSH
91615: LD_VAR 0 4
91619: ARRAY
91620: PUSH
91621: LD_INT 1
91623: PLUS
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PPUSH
91629: LD_VAR 0 1
91633: PPUSH
91634: CALL 25021 0 3
91638: ST_TO_ADDR
// exit ;
91639: POP
91640: POP
91641: POP
91642: POP
91643: GO 91653
// end ;
91645: GO 91502
91647: POP
91648: POP
// end ;
91649: GO 91463
91651: POP
91652: POP
// end ;
91653: LD_VAR 0 3
91657: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91658: LD_INT 0
91660: PPUSH
91661: PPUSH
91662: PPUSH
// if not mc_bases or not skirmish then
91663: LD_EXP 31
91667: NOT
91668: PUSH
91669: LD_EXP 29
91673: NOT
91674: OR
91675: IFFALSE 91679
// exit ;
91677: GO 91869
// for i = 1 to mc_bases do
91679: LD_ADDR_VAR 0 4
91683: PUSH
91684: DOUBLE
91685: LD_INT 1
91687: DEC
91688: ST_TO_ADDR
91689: LD_EXP 31
91693: PUSH
91694: FOR_TO
91695: IFFALSE 91782
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91697: LD_VAR 0 1
91701: PUSH
91702: LD_EXP 39
91706: PUSH
91707: LD_VAR 0 4
91711: ARRAY
91712: IN
91713: PUSH
91714: LD_VAR 0 1
91718: PUSH
91719: LD_EXP 40
91723: PUSH
91724: LD_VAR 0 4
91728: ARRAY
91729: IN
91730: NOT
91731: AND
91732: IFFALSE 91780
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91734: LD_ADDR_EXP 40
91738: PUSH
91739: LD_EXP 40
91743: PPUSH
91744: LD_VAR 0 4
91748: PUSH
91749: LD_EXP 40
91753: PUSH
91754: LD_VAR 0 4
91758: ARRAY
91759: PUSH
91760: LD_INT 1
91762: PLUS
91763: PUSH
91764: EMPTY
91765: LIST
91766: LIST
91767: PPUSH
91768: LD_VAR 0 1
91772: PPUSH
91773: CALL 25021 0 3
91777: ST_TO_ADDR
// break ;
91778: GO 91782
// end ; end ;
91780: GO 91694
91782: POP
91783: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91784: LD_VAR 0 1
91788: PPUSH
91789: CALL_OW 257
91793: PUSH
91794: LD_EXP 57
91798: IN
91799: PUSH
91800: LD_VAR 0 1
91804: PPUSH
91805: CALL_OW 266
91809: PUSH
91810: LD_INT 5
91812: EQUAL
91813: AND
91814: PUSH
91815: LD_VAR 0 2
91819: PPUSH
91820: CALL_OW 110
91824: PUSH
91825: LD_INT 18
91827: NONEQUAL
91828: AND
91829: IFFALSE 91869
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91831: LD_VAR 0 2
91835: PPUSH
91836: CALL_OW 257
91840: PUSH
91841: LD_INT 5
91843: PUSH
91844: LD_INT 8
91846: PUSH
91847: LD_INT 9
91849: PUSH
91850: EMPTY
91851: LIST
91852: LIST
91853: LIST
91854: IN
91855: IFFALSE 91869
// SetClass ( unit , 1 ) ;
91857: LD_VAR 0 2
91861: PPUSH
91862: LD_INT 1
91864: PPUSH
91865: CALL_OW 336
// end ;
91869: LD_VAR 0 3
91873: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91874: LD_INT 0
91876: PPUSH
91877: PPUSH
// if not mc_bases or not skirmish then
91878: LD_EXP 31
91882: NOT
91883: PUSH
91884: LD_EXP 29
91888: NOT
91889: OR
91890: IFFALSE 91894
// exit ;
91892: GO 92010
// if GetLives ( abandoned_vehicle ) > 250 then
91894: LD_VAR 0 2
91898: PPUSH
91899: CALL_OW 256
91903: PUSH
91904: LD_INT 250
91906: GREATER
91907: IFFALSE 91911
// exit ;
91909: GO 92010
// for i = 1 to mc_bases do
91911: LD_ADDR_VAR 0 6
91915: PUSH
91916: DOUBLE
91917: LD_INT 1
91919: DEC
91920: ST_TO_ADDR
91921: LD_EXP 31
91925: PUSH
91926: FOR_TO
91927: IFFALSE 92008
// begin if driver in mc_bases [ i ] then
91929: LD_VAR 0 1
91933: PUSH
91934: LD_EXP 31
91938: PUSH
91939: LD_VAR 0 6
91943: ARRAY
91944: IN
91945: IFFALSE 92006
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91947: LD_VAR 0 1
91951: PPUSH
91952: LD_EXP 31
91956: PUSH
91957: LD_VAR 0 6
91961: ARRAY
91962: PPUSH
91963: LD_INT 2
91965: PUSH
91966: LD_INT 30
91968: PUSH
91969: LD_INT 0
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: PUSH
91976: LD_INT 30
91978: PUSH
91979: LD_INT 1
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: PUSH
91986: EMPTY
91987: LIST
91988: LIST
91989: LIST
91990: PPUSH
91991: CALL_OW 72
91995: PUSH
91996: LD_INT 1
91998: ARRAY
91999: PPUSH
92000: CALL 58229 0 2
// break ;
92004: GO 92008
// end ; end ;
92006: GO 91926
92008: POP
92009: POP
// end ; end_of_file end_of_file
92010: LD_VAR 0 5
92014: RET
// export globalGameSaveCounter ; every 0 0$1 do
92015: GO 92017
92017: DISABLE
// begin enable ;
92018: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
92019: LD_STRING updateTimer(
92021: PUSH
92022: LD_OWVAR 1
92026: STR
92027: PUSH
92028: LD_STRING );
92030: STR
92031: PPUSH
92032: CALL_OW 559
// end ;
92036: END
// every 0 0$1 do
92037: GO 92039
92039: DISABLE
// begin globalGameSaveCounter := 0 ;
92040: LD_ADDR_EXP 76
92044: PUSH
92045: LD_INT 0
92047: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
92048: LD_STRING setGameSaveCounter(0)
92050: PPUSH
92051: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
92055: LD_STRING initStreamRollete();
92057: PPUSH
92058: CALL_OW 559
// InitStreamMode ;
92062: CALL 93388 0 0
// DefineStreamItems ( false ) ;
92066: LD_INT 0
92068: PPUSH
92069: CALL 93852 0 1
// end ;
92073: END
// export function SOS_MapStart ( ) ; begin
92074: LD_INT 0
92076: PPUSH
// if streamModeActive then
92077: LD_EXP 77
92081: IFFALSE 92090
// DefineStreamItems ( true ) ;
92083: LD_INT 1
92085: PPUSH
92086: CALL 93852 0 1
// UpdateLuaVariables ( ) ;
92090: CALL 92107 0 0
// UpdateFactoryWaypoints ( ) ;
92094: CALL 106713 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92098: CALL 106970 0 0
// end ;
92102: LD_VAR 0 1
92106: RET
// function UpdateLuaVariables ( ) ; begin
92107: LD_INT 0
92109: PPUSH
// if globalGameSaveCounter then
92110: LD_EXP 76
92114: IFFALSE 92148
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92116: LD_ADDR_EXP 76
92120: PUSH
92121: LD_EXP 76
92125: PPUSH
92126: CALL 58713 0 1
92130: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92131: LD_STRING setGameSaveCounter(
92133: PUSH
92134: LD_EXP 76
92138: STR
92139: PUSH
92140: LD_STRING )
92142: STR
92143: PPUSH
92144: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92148: LD_STRING setGameDifficulty(
92150: PUSH
92151: LD_OWVAR 67
92155: STR
92156: PUSH
92157: LD_STRING )
92159: STR
92160: PPUSH
92161: CALL_OW 559
// end ;
92165: LD_VAR 0 1
92169: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92170: LD_INT 0
92172: PPUSH
// if p2 = stream_mode then
92173: LD_VAR 0 2
92177: PUSH
92178: LD_INT 100
92180: EQUAL
92181: IFFALSE 93184
// begin if not StreamModeActive then
92183: LD_EXP 77
92187: NOT
92188: IFFALSE 92198
// StreamModeActive := true ;
92190: LD_ADDR_EXP 77
92194: PUSH
92195: LD_INT 1
92197: ST_TO_ADDR
// if p3 = 0 then
92198: LD_VAR 0 3
92202: PUSH
92203: LD_INT 0
92205: EQUAL
92206: IFFALSE 92212
// InitStreamMode ;
92208: CALL 93388 0 0
// if p3 = 1 then
92212: LD_VAR 0 3
92216: PUSH
92217: LD_INT 1
92219: EQUAL
92220: IFFALSE 92230
// sRocket := true ;
92222: LD_ADDR_EXP 82
92226: PUSH
92227: LD_INT 1
92229: ST_TO_ADDR
// if p3 = 2 then
92230: LD_VAR 0 3
92234: PUSH
92235: LD_INT 2
92237: EQUAL
92238: IFFALSE 92248
// sSpeed := true ;
92240: LD_ADDR_EXP 81
92244: PUSH
92245: LD_INT 1
92247: ST_TO_ADDR
// if p3 = 3 then
92248: LD_VAR 0 3
92252: PUSH
92253: LD_INT 3
92255: EQUAL
92256: IFFALSE 92266
// sEngine := true ;
92258: LD_ADDR_EXP 83
92262: PUSH
92263: LD_INT 1
92265: ST_TO_ADDR
// if p3 = 4 then
92266: LD_VAR 0 3
92270: PUSH
92271: LD_INT 4
92273: EQUAL
92274: IFFALSE 92284
// sSpec := true ;
92276: LD_ADDR_EXP 80
92280: PUSH
92281: LD_INT 1
92283: ST_TO_ADDR
// if p3 = 5 then
92284: LD_VAR 0 3
92288: PUSH
92289: LD_INT 5
92291: EQUAL
92292: IFFALSE 92302
// sLevel := true ;
92294: LD_ADDR_EXP 84
92298: PUSH
92299: LD_INT 1
92301: ST_TO_ADDR
// if p3 = 6 then
92302: LD_VAR 0 3
92306: PUSH
92307: LD_INT 6
92309: EQUAL
92310: IFFALSE 92320
// sArmoury := true ;
92312: LD_ADDR_EXP 85
92316: PUSH
92317: LD_INT 1
92319: ST_TO_ADDR
// if p3 = 7 then
92320: LD_VAR 0 3
92324: PUSH
92325: LD_INT 7
92327: EQUAL
92328: IFFALSE 92338
// sRadar := true ;
92330: LD_ADDR_EXP 86
92334: PUSH
92335: LD_INT 1
92337: ST_TO_ADDR
// if p3 = 8 then
92338: LD_VAR 0 3
92342: PUSH
92343: LD_INT 8
92345: EQUAL
92346: IFFALSE 92356
// sBunker := true ;
92348: LD_ADDR_EXP 87
92352: PUSH
92353: LD_INT 1
92355: ST_TO_ADDR
// if p3 = 9 then
92356: LD_VAR 0 3
92360: PUSH
92361: LD_INT 9
92363: EQUAL
92364: IFFALSE 92374
// sHack := true ;
92366: LD_ADDR_EXP 88
92370: PUSH
92371: LD_INT 1
92373: ST_TO_ADDR
// if p3 = 10 then
92374: LD_VAR 0 3
92378: PUSH
92379: LD_INT 10
92381: EQUAL
92382: IFFALSE 92392
// sFire := true ;
92384: LD_ADDR_EXP 89
92388: PUSH
92389: LD_INT 1
92391: ST_TO_ADDR
// if p3 = 11 then
92392: LD_VAR 0 3
92396: PUSH
92397: LD_INT 11
92399: EQUAL
92400: IFFALSE 92410
// sRefresh := true ;
92402: LD_ADDR_EXP 90
92406: PUSH
92407: LD_INT 1
92409: ST_TO_ADDR
// if p3 = 12 then
92410: LD_VAR 0 3
92414: PUSH
92415: LD_INT 12
92417: EQUAL
92418: IFFALSE 92428
// sExp := true ;
92420: LD_ADDR_EXP 91
92424: PUSH
92425: LD_INT 1
92427: ST_TO_ADDR
// if p3 = 13 then
92428: LD_VAR 0 3
92432: PUSH
92433: LD_INT 13
92435: EQUAL
92436: IFFALSE 92446
// sDepot := true ;
92438: LD_ADDR_EXP 92
92442: PUSH
92443: LD_INT 1
92445: ST_TO_ADDR
// if p3 = 14 then
92446: LD_VAR 0 3
92450: PUSH
92451: LD_INT 14
92453: EQUAL
92454: IFFALSE 92464
// sFlag := true ;
92456: LD_ADDR_EXP 93
92460: PUSH
92461: LD_INT 1
92463: ST_TO_ADDR
// if p3 = 15 then
92464: LD_VAR 0 3
92468: PUSH
92469: LD_INT 15
92471: EQUAL
92472: IFFALSE 92482
// sKamikadze := true ;
92474: LD_ADDR_EXP 101
92478: PUSH
92479: LD_INT 1
92481: ST_TO_ADDR
// if p3 = 16 then
92482: LD_VAR 0 3
92486: PUSH
92487: LD_INT 16
92489: EQUAL
92490: IFFALSE 92500
// sTroll := true ;
92492: LD_ADDR_EXP 102
92496: PUSH
92497: LD_INT 1
92499: ST_TO_ADDR
// if p3 = 17 then
92500: LD_VAR 0 3
92504: PUSH
92505: LD_INT 17
92507: EQUAL
92508: IFFALSE 92518
// sSlow := true ;
92510: LD_ADDR_EXP 103
92514: PUSH
92515: LD_INT 1
92517: ST_TO_ADDR
// if p3 = 18 then
92518: LD_VAR 0 3
92522: PUSH
92523: LD_INT 18
92525: EQUAL
92526: IFFALSE 92536
// sLack := true ;
92528: LD_ADDR_EXP 104
92532: PUSH
92533: LD_INT 1
92535: ST_TO_ADDR
// if p3 = 19 then
92536: LD_VAR 0 3
92540: PUSH
92541: LD_INT 19
92543: EQUAL
92544: IFFALSE 92554
// sTank := true ;
92546: LD_ADDR_EXP 106
92550: PUSH
92551: LD_INT 1
92553: ST_TO_ADDR
// if p3 = 20 then
92554: LD_VAR 0 3
92558: PUSH
92559: LD_INT 20
92561: EQUAL
92562: IFFALSE 92572
// sRemote := true ;
92564: LD_ADDR_EXP 107
92568: PUSH
92569: LD_INT 1
92571: ST_TO_ADDR
// if p3 = 21 then
92572: LD_VAR 0 3
92576: PUSH
92577: LD_INT 21
92579: EQUAL
92580: IFFALSE 92590
// sPowell := true ;
92582: LD_ADDR_EXP 108
92586: PUSH
92587: LD_INT 1
92589: ST_TO_ADDR
// if p3 = 22 then
92590: LD_VAR 0 3
92594: PUSH
92595: LD_INT 22
92597: EQUAL
92598: IFFALSE 92608
// sTeleport := true ;
92600: LD_ADDR_EXP 111
92604: PUSH
92605: LD_INT 1
92607: ST_TO_ADDR
// if p3 = 23 then
92608: LD_VAR 0 3
92612: PUSH
92613: LD_INT 23
92615: EQUAL
92616: IFFALSE 92626
// sOilTower := true ;
92618: LD_ADDR_EXP 113
92622: PUSH
92623: LD_INT 1
92625: ST_TO_ADDR
// if p3 = 24 then
92626: LD_VAR 0 3
92630: PUSH
92631: LD_INT 24
92633: EQUAL
92634: IFFALSE 92644
// sShovel := true ;
92636: LD_ADDR_EXP 114
92640: PUSH
92641: LD_INT 1
92643: ST_TO_ADDR
// if p3 = 25 then
92644: LD_VAR 0 3
92648: PUSH
92649: LD_INT 25
92651: EQUAL
92652: IFFALSE 92662
// sSheik := true ;
92654: LD_ADDR_EXP 115
92658: PUSH
92659: LD_INT 1
92661: ST_TO_ADDR
// if p3 = 26 then
92662: LD_VAR 0 3
92666: PUSH
92667: LD_INT 26
92669: EQUAL
92670: IFFALSE 92680
// sEarthquake := true ;
92672: LD_ADDR_EXP 117
92676: PUSH
92677: LD_INT 1
92679: ST_TO_ADDR
// if p3 = 27 then
92680: LD_VAR 0 3
92684: PUSH
92685: LD_INT 27
92687: EQUAL
92688: IFFALSE 92698
// sAI := true ;
92690: LD_ADDR_EXP 118
92694: PUSH
92695: LD_INT 1
92697: ST_TO_ADDR
// if p3 = 28 then
92698: LD_VAR 0 3
92702: PUSH
92703: LD_INT 28
92705: EQUAL
92706: IFFALSE 92716
// sCargo := true ;
92708: LD_ADDR_EXP 121
92712: PUSH
92713: LD_INT 1
92715: ST_TO_ADDR
// if p3 = 29 then
92716: LD_VAR 0 3
92720: PUSH
92721: LD_INT 29
92723: EQUAL
92724: IFFALSE 92734
// sDLaser := true ;
92726: LD_ADDR_EXP 122
92730: PUSH
92731: LD_INT 1
92733: ST_TO_ADDR
// if p3 = 30 then
92734: LD_VAR 0 3
92738: PUSH
92739: LD_INT 30
92741: EQUAL
92742: IFFALSE 92752
// sExchange := true ;
92744: LD_ADDR_EXP 123
92748: PUSH
92749: LD_INT 1
92751: ST_TO_ADDR
// if p3 = 31 then
92752: LD_VAR 0 3
92756: PUSH
92757: LD_INT 31
92759: EQUAL
92760: IFFALSE 92770
// sFac := true ;
92762: LD_ADDR_EXP 124
92766: PUSH
92767: LD_INT 1
92769: ST_TO_ADDR
// if p3 = 32 then
92770: LD_VAR 0 3
92774: PUSH
92775: LD_INT 32
92777: EQUAL
92778: IFFALSE 92788
// sPower := true ;
92780: LD_ADDR_EXP 125
92784: PUSH
92785: LD_INT 1
92787: ST_TO_ADDR
// if p3 = 33 then
92788: LD_VAR 0 3
92792: PUSH
92793: LD_INT 33
92795: EQUAL
92796: IFFALSE 92806
// sRandom := true ;
92798: LD_ADDR_EXP 126
92802: PUSH
92803: LD_INT 1
92805: ST_TO_ADDR
// if p3 = 34 then
92806: LD_VAR 0 3
92810: PUSH
92811: LD_INT 34
92813: EQUAL
92814: IFFALSE 92824
// sShield := true ;
92816: LD_ADDR_EXP 127
92820: PUSH
92821: LD_INT 1
92823: ST_TO_ADDR
// if p3 = 35 then
92824: LD_VAR 0 3
92828: PUSH
92829: LD_INT 35
92831: EQUAL
92832: IFFALSE 92842
// sTime := true ;
92834: LD_ADDR_EXP 128
92838: PUSH
92839: LD_INT 1
92841: ST_TO_ADDR
// if p3 = 36 then
92842: LD_VAR 0 3
92846: PUSH
92847: LD_INT 36
92849: EQUAL
92850: IFFALSE 92860
// sTools := true ;
92852: LD_ADDR_EXP 129
92856: PUSH
92857: LD_INT 1
92859: ST_TO_ADDR
// if p3 = 101 then
92860: LD_VAR 0 3
92864: PUSH
92865: LD_INT 101
92867: EQUAL
92868: IFFALSE 92878
// sSold := true ;
92870: LD_ADDR_EXP 94
92874: PUSH
92875: LD_INT 1
92877: ST_TO_ADDR
// if p3 = 102 then
92878: LD_VAR 0 3
92882: PUSH
92883: LD_INT 102
92885: EQUAL
92886: IFFALSE 92896
// sDiff := true ;
92888: LD_ADDR_EXP 95
92892: PUSH
92893: LD_INT 1
92895: ST_TO_ADDR
// if p3 = 103 then
92896: LD_VAR 0 3
92900: PUSH
92901: LD_INT 103
92903: EQUAL
92904: IFFALSE 92914
// sFog := true ;
92906: LD_ADDR_EXP 98
92910: PUSH
92911: LD_INT 1
92913: ST_TO_ADDR
// if p3 = 104 then
92914: LD_VAR 0 3
92918: PUSH
92919: LD_INT 104
92921: EQUAL
92922: IFFALSE 92932
// sReset := true ;
92924: LD_ADDR_EXP 99
92928: PUSH
92929: LD_INT 1
92931: ST_TO_ADDR
// if p3 = 105 then
92932: LD_VAR 0 3
92936: PUSH
92937: LD_INT 105
92939: EQUAL
92940: IFFALSE 92950
// sSun := true ;
92942: LD_ADDR_EXP 100
92946: PUSH
92947: LD_INT 1
92949: ST_TO_ADDR
// if p3 = 106 then
92950: LD_VAR 0 3
92954: PUSH
92955: LD_INT 106
92957: EQUAL
92958: IFFALSE 92968
// sTiger := true ;
92960: LD_ADDR_EXP 96
92964: PUSH
92965: LD_INT 1
92967: ST_TO_ADDR
// if p3 = 107 then
92968: LD_VAR 0 3
92972: PUSH
92973: LD_INT 107
92975: EQUAL
92976: IFFALSE 92986
// sBomb := true ;
92978: LD_ADDR_EXP 97
92982: PUSH
92983: LD_INT 1
92985: ST_TO_ADDR
// if p3 = 108 then
92986: LD_VAR 0 3
92990: PUSH
92991: LD_INT 108
92993: EQUAL
92994: IFFALSE 93004
// sWound := true ;
92996: LD_ADDR_EXP 105
93000: PUSH
93001: LD_INT 1
93003: ST_TO_ADDR
// if p3 = 109 then
93004: LD_VAR 0 3
93008: PUSH
93009: LD_INT 109
93011: EQUAL
93012: IFFALSE 93022
// sBetray := true ;
93014: LD_ADDR_EXP 109
93018: PUSH
93019: LD_INT 1
93021: ST_TO_ADDR
// if p3 = 110 then
93022: LD_VAR 0 3
93026: PUSH
93027: LD_INT 110
93029: EQUAL
93030: IFFALSE 93040
// sContamin := true ;
93032: LD_ADDR_EXP 110
93036: PUSH
93037: LD_INT 1
93039: ST_TO_ADDR
// if p3 = 111 then
93040: LD_VAR 0 3
93044: PUSH
93045: LD_INT 111
93047: EQUAL
93048: IFFALSE 93058
// sOil := true ;
93050: LD_ADDR_EXP 112
93054: PUSH
93055: LD_INT 1
93057: ST_TO_ADDR
// if p3 = 112 then
93058: LD_VAR 0 3
93062: PUSH
93063: LD_INT 112
93065: EQUAL
93066: IFFALSE 93076
// sStu := true ;
93068: LD_ADDR_EXP 116
93072: PUSH
93073: LD_INT 1
93075: ST_TO_ADDR
// if p3 = 113 then
93076: LD_VAR 0 3
93080: PUSH
93081: LD_INT 113
93083: EQUAL
93084: IFFALSE 93094
// sBazooka := true ;
93086: LD_ADDR_EXP 119
93090: PUSH
93091: LD_INT 1
93093: ST_TO_ADDR
// if p3 = 114 then
93094: LD_VAR 0 3
93098: PUSH
93099: LD_INT 114
93101: EQUAL
93102: IFFALSE 93112
// sMortar := true ;
93104: LD_ADDR_EXP 120
93108: PUSH
93109: LD_INT 1
93111: ST_TO_ADDR
// if p3 = 115 then
93112: LD_VAR 0 3
93116: PUSH
93117: LD_INT 115
93119: EQUAL
93120: IFFALSE 93130
// sRanger := true ;
93122: LD_ADDR_EXP 130
93126: PUSH
93127: LD_INT 1
93129: ST_TO_ADDR
// if p3 = 116 then
93130: LD_VAR 0 3
93134: PUSH
93135: LD_INT 116
93137: EQUAL
93138: IFFALSE 93148
// sComputer := true ;
93140: LD_ADDR_EXP 131
93144: PUSH
93145: LD_INT 1
93147: ST_TO_ADDR
// if p3 = 117 then
93148: LD_VAR 0 3
93152: PUSH
93153: LD_INT 117
93155: EQUAL
93156: IFFALSE 93166
// s30 := true ;
93158: LD_ADDR_EXP 132
93162: PUSH
93163: LD_INT 1
93165: ST_TO_ADDR
// if p3 = 118 then
93166: LD_VAR 0 3
93170: PUSH
93171: LD_INT 118
93173: EQUAL
93174: IFFALSE 93184
// s60 := true ;
93176: LD_ADDR_EXP 133
93180: PUSH
93181: LD_INT 1
93183: ST_TO_ADDR
// end ; if p2 = hack_mode then
93184: LD_VAR 0 2
93188: PUSH
93189: LD_INT 101
93191: EQUAL
93192: IFFALSE 93320
// begin case p3 of 1 :
93194: LD_VAR 0 3
93198: PUSH
93199: LD_INT 1
93201: DOUBLE
93202: EQUAL
93203: IFTRUE 93207
93205: GO 93214
93207: POP
// hHackUnlimitedResources ; 2 :
93208: CALL 105459 0 0
93212: GO 93320
93214: LD_INT 2
93216: DOUBLE
93217: EQUAL
93218: IFTRUE 93222
93220: GO 93229
93222: POP
// hHackSetLevel10 ; 3 :
93223: CALL 105592 0 0
93227: GO 93320
93229: LD_INT 3
93231: DOUBLE
93232: EQUAL
93233: IFTRUE 93237
93235: GO 93244
93237: POP
// hHackSetLevel10YourUnits ; 4 :
93238: CALL 105677 0 0
93242: GO 93320
93244: LD_INT 4
93246: DOUBLE
93247: EQUAL
93248: IFTRUE 93252
93250: GO 93259
93252: POP
// hHackInvincible ; 5 :
93253: CALL 106125 0 0
93257: GO 93320
93259: LD_INT 5
93261: DOUBLE
93262: EQUAL
93263: IFTRUE 93267
93265: GO 93274
93267: POP
// hHackInvisible ; 6 :
93268: CALL 106236 0 0
93272: GO 93320
93274: LD_INT 6
93276: DOUBLE
93277: EQUAL
93278: IFTRUE 93282
93280: GO 93289
93282: POP
// hHackChangeYourSide ; 7 :
93283: CALL 106293 0 0
93287: GO 93320
93289: LD_INT 7
93291: DOUBLE
93292: EQUAL
93293: IFTRUE 93297
93295: GO 93304
93297: POP
// hHackChangeUnitSide ; 8 :
93298: CALL 106335 0 0
93302: GO 93320
93304: LD_INT 8
93306: DOUBLE
93307: EQUAL
93308: IFTRUE 93312
93310: GO 93319
93312: POP
// hHackFog ; end ;
93313: CALL 106436 0 0
93317: GO 93320
93319: POP
// end ; if p2 = game_save_mode then
93320: LD_VAR 0 2
93324: PUSH
93325: LD_INT 102
93327: EQUAL
93328: IFFALSE 93383
// begin if p3 = 1 then
93330: LD_VAR 0 3
93334: PUSH
93335: LD_INT 1
93337: EQUAL
93338: IFFALSE 93350
// globalGameSaveCounter := p4 ;
93340: LD_ADDR_EXP 76
93344: PUSH
93345: LD_VAR 0 4
93349: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93350: LD_VAR 0 3
93354: PUSH
93355: LD_INT 2
93357: EQUAL
93358: PUSH
93359: LD_EXP 76
93363: AND
93364: IFFALSE 93383
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93366: LD_STRING setGameSaveCounter(
93368: PUSH
93369: LD_EXP 76
93373: STR
93374: PUSH
93375: LD_STRING )
93377: STR
93378: PPUSH
93379: CALL_OW 559
// end ; end ;
93383: LD_VAR 0 7
93387: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93388: LD_INT 0
93390: PPUSH
// streamModeActive := false ;
93391: LD_ADDR_EXP 77
93395: PUSH
93396: LD_INT 0
93398: ST_TO_ADDR
// normalCounter := 36 ;
93399: LD_ADDR_EXP 78
93403: PUSH
93404: LD_INT 36
93406: ST_TO_ADDR
// hardcoreCounter := 18 ;
93407: LD_ADDR_EXP 79
93411: PUSH
93412: LD_INT 18
93414: ST_TO_ADDR
// sRocket := false ;
93415: LD_ADDR_EXP 82
93419: PUSH
93420: LD_INT 0
93422: ST_TO_ADDR
// sSpeed := false ;
93423: LD_ADDR_EXP 81
93427: PUSH
93428: LD_INT 0
93430: ST_TO_ADDR
// sEngine := false ;
93431: LD_ADDR_EXP 83
93435: PUSH
93436: LD_INT 0
93438: ST_TO_ADDR
// sSpec := false ;
93439: LD_ADDR_EXP 80
93443: PUSH
93444: LD_INT 0
93446: ST_TO_ADDR
// sLevel := false ;
93447: LD_ADDR_EXP 84
93451: PUSH
93452: LD_INT 0
93454: ST_TO_ADDR
// sArmoury := false ;
93455: LD_ADDR_EXP 85
93459: PUSH
93460: LD_INT 0
93462: ST_TO_ADDR
// sRadar := false ;
93463: LD_ADDR_EXP 86
93467: PUSH
93468: LD_INT 0
93470: ST_TO_ADDR
// sBunker := false ;
93471: LD_ADDR_EXP 87
93475: PUSH
93476: LD_INT 0
93478: ST_TO_ADDR
// sHack := false ;
93479: LD_ADDR_EXP 88
93483: PUSH
93484: LD_INT 0
93486: ST_TO_ADDR
// sFire := false ;
93487: LD_ADDR_EXP 89
93491: PUSH
93492: LD_INT 0
93494: ST_TO_ADDR
// sRefresh := false ;
93495: LD_ADDR_EXP 90
93499: PUSH
93500: LD_INT 0
93502: ST_TO_ADDR
// sExp := false ;
93503: LD_ADDR_EXP 91
93507: PUSH
93508: LD_INT 0
93510: ST_TO_ADDR
// sDepot := false ;
93511: LD_ADDR_EXP 92
93515: PUSH
93516: LD_INT 0
93518: ST_TO_ADDR
// sFlag := false ;
93519: LD_ADDR_EXP 93
93523: PUSH
93524: LD_INT 0
93526: ST_TO_ADDR
// sKamikadze := false ;
93527: LD_ADDR_EXP 101
93531: PUSH
93532: LD_INT 0
93534: ST_TO_ADDR
// sTroll := false ;
93535: LD_ADDR_EXP 102
93539: PUSH
93540: LD_INT 0
93542: ST_TO_ADDR
// sSlow := false ;
93543: LD_ADDR_EXP 103
93547: PUSH
93548: LD_INT 0
93550: ST_TO_ADDR
// sLack := false ;
93551: LD_ADDR_EXP 104
93555: PUSH
93556: LD_INT 0
93558: ST_TO_ADDR
// sTank := false ;
93559: LD_ADDR_EXP 106
93563: PUSH
93564: LD_INT 0
93566: ST_TO_ADDR
// sRemote := false ;
93567: LD_ADDR_EXP 107
93571: PUSH
93572: LD_INT 0
93574: ST_TO_ADDR
// sPowell := false ;
93575: LD_ADDR_EXP 108
93579: PUSH
93580: LD_INT 0
93582: ST_TO_ADDR
// sTeleport := false ;
93583: LD_ADDR_EXP 111
93587: PUSH
93588: LD_INT 0
93590: ST_TO_ADDR
// sOilTower := false ;
93591: LD_ADDR_EXP 113
93595: PUSH
93596: LD_INT 0
93598: ST_TO_ADDR
// sShovel := false ;
93599: LD_ADDR_EXP 114
93603: PUSH
93604: LD_INT 0
93606: ST_TO_ADDR
// sSheik := false ;
93607: LD_ADDR_EXP 115
93611: PUSH
93612: LD_INT 0
93614: ST_TO_ADDR
// sEarthquake := false ;
93615: LD_ADDR_EXP 117
93619: PUSH
93620: LD_INT 0
93622: ST_TO_ADDR
// sAI := false ;
93623: LD_ADDR_EXP 118
93627: PUSH
93628: LD_INT 0
93630: ST_TO_ADDR
// sCargo := false ;
93631: LD_ADDR_EXP 121
93635: PUSH
93636: LD_INT 0
93638: ST_TO_ADDR
// sDLaser := false ;
93639: LD_ADDR_EXP 122
93643: PUSH
93644: LD_INT 0
93646: ST_TO_ADDR
// sExchange := false ;
93647: LD_ADDR_EXP 123
93651: PUSH
93652: LD_INT 0
93654: ST_TO_ADDR
// sFac := false ;
93655: LD_ADDR_EXP 124
93659: PUSH
93660: LD_INT 0
93662: ST_TO_ADDR
// sPower := false ;
93663: LD_ADDR_EXP 125
93667: PUSH
93668: LD_INT 0
93670: ST_TO_ADDR
// sRandom := false ;
93671: LD_ADDR_EXP 126
93675: PUSH
93676: LD_INT 0
93678: ST_TO_ADDR
// sShield := false ;
93679: LD_ADDR_EXP 127
93683: PUSH
93684: LD_INT 0
93686: ST_TO_ADDR
// sTime := false ;
93687: LD_ADDR_EXP 128
93691: PUSH
93692: LD_INT 0
93694: ST_TO_ADDR
// sTools := false ;
93695: LD_ADDR_EXP 129
93699: PUSH
93700: LD_INT 0
93702: ST_TO_ADDR
// sSold := false ;
93703: LD_ADDR_EXP 94
93707: PUSH
93708: LD_INT 0
93710: ST_TO_ADDR
// sDiff := false ;
93711: LD_ADDR_EXP 95
93715: PUSH
93716: LD_INT 0
93718: ST_TO_ADDR
// sFog := false ;
93719: LD_ADDR_EXP 98
93723: PUSH
93724: LD_INT 0
93726: ST_TO_ADDR
// sReset := false ;
93727: LD_ADDR_EXP 99
93731: PUSH
93732: LD_INT 0
93734: ST_TO_ADDR
// sSun := false ;
93735: LD_ADDR_EXP 100
93739: PUSH
93740: LD_INT 0
93742: ST_TO_ADDR
// sTiger := false ;
93743: LD_ADDR_EXP 96
93747: PUSH
93748: LD_INT 0
93750: ST_TO_ADDR
// sBomb := false ;
93751: LD_ADDR_EXP 97
93755: PUSH
93756: LD_INT 0
93758: ST_TO_ADDR
// sWound := false ;
93759: LD_ADDR_EXP 105
93763: PUSH
93764: LD_INT 0
93766: ST_TO_ADDR
// sBetray := false ;
93767: LD_ADDR_EXP 109
93771: PUSH
93772: LD_INT 0
93774: ST_TO_ADDR
// sContamin := false ;
93775: LD_ADDR_EXP 110
93779: PUSH
93780: LD_INT 0
93782: ST_TO_ADDR
// sOil := false ;
93783: LD_ADDR_EXP 112
93787: PUSH
93788: LD_INT 0
93790: ST_TO_ADDR
// sStu := false ;
93791: LD_ADDR_EXP 116
93795: PUSH
93796: LD_INT 0
93798: ST_TO_ADDR
// sBazooka := false ;
93799: LD_ADDR_EXP 119
93803: PUSH
93804: LD_INT 0
93806: ST_TO_ADDR
// sMortar := false ;
93807: LD_ADDR_EXP 120
93811: PUSH
93812: LD_INT 0
93814: ST_TO_ADDR
// sRanger := false ;
93815: LD_ADDR_EXP 130
93819: PUSH
93820: LD_INT 0
93822: ST_TO_ADDR
// sComputer := false ;
93823: LD_ADDR_EXP 131
93827: PUSH
93828: LD_INT 0
93830: ST_TO_ADDR
// s30 := false ;
93831: LD_ADDR_EXP 132
93835: PUSH
93836: LD_INT 0
93838: ST_TO_ADDR
// s60 := false ;
93839: LD_ADDR_EXP 133
93843: PUSH
93844: LD_INT 0
93846: ST_TO_ADDR
// end ;
93847: LD_VAR 0 1
93851: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93852: LD_INT 0
93854: PPUSH
93855: PPUSH
93856: PPUSH
93857: PPUSH
93858: PPUSH
93859: PPUSH
93860: PPUSH
// result := [ ] ;
93861: LD_ADDR_VAR 0 2
93865: PUSH
93866: EMPTY
93867: ST_TO_ADDR
// if campaign_id = 1 then
93868: LD_OWVAR 69
93872: PUSH
93873: LD_INT 1
93875: EQUAL
93876: IFFALSE 97042
// begin case mission_number of 1 :
93878: LD_OWVAR 70
93882: PUSH
93883: LD_INT 1
93885: DOUBLE
93886: EQUAL
93887: IFTRUE 93891
93889: GO 93967
93891: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93892: LD_ADDR_VAR 0 2
93896: PUSH
93897: LD_INT 2
93899: PUSH
93900: LD_INT 4
93902: PUSH
93903: LD_INT 11
93905: PUSH
93906: LD_INT 12
93908: PUSH
93909: LD_INT 15
93911: PUSH
93912: LD_INT 16
93914: PUSH
93915: LD_INT 22
93917: PUSH
93918: LD_INT 23
93920: PUSH
93921: LD_INT 26
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: PUSH
93935: LD_INT 101
93937: PUSH
93938: LD_INT 102
93940: PUSH
93941: LD_INT 106
93943: PUSH
93944: LD_INT 116
93946: PUSH
93947: LD_INT 117
93949: PUSH
93950: LD_INT 118
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: ST_TO_ADDR
93965: GO 97040
93967: LD_INT 2
93969: DOUBLE
93970: EQUAL
93971: IFTRUE 93975
93973: GO 94059
93975: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93976: LD_ADDR_VAR 0 2
93980: PUSH
93981: LD_INT 2
93983: PUSH
93984: LD_INT 4
93986: PUSH
93987: LD_INT 11
93989: PUSH
93990: LD_INT 12
93992: PUSH
93993: LD_INT 15
93995: PUSH
93996: LD_INT 16
93998: PUSH
93999: LD_INT 22
94001: PUSH
94002: LD_INT 23
94004: PUSH
94005: LD_INT 26
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: PUSH
94019: LD_INT 101
94021: PUSH
94022: LD_INT 102
94024: PUSH
94025: LD_INT 105
94027: PUSH
94028: LD_INT 106
94030: PUSH
94031: LD_INT 108
94033: PUSH
94034: LD_INT 116
94036: PUSH
94037: LD_INT 117
94039: PUSH
94040: LD_INT 118
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: ST_TO_ADDR
94057: GO 97040
94059: LD_INT 3
94061: DOUBLE
94062: EQUAL
94063: IFTRUE 94067
94065: GO 94155
94067: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94068: LD_ADDR_VAR 0 2
94072: PUSH
94073: LD_INT 2
94075: PUSH
94076: LD_INT 4
94078: PUSH
94079: LD_INT 5
94081: PUSH
94082: LD_INT 11
94084: PUSH
94085: LD_INT 12
94087: PUSH
94088: LD_INT 15
94090: PUSH
94091: LD_INT 16
94093: PUSH
94094: LD_INT 22
94096: PUSH
94097: LD_INT 26
94099: PUSH
94100: LD_INT 36
94102: PUSH
94103: EMPTY
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 101
94117: PUSH
94118: LD_INT 102
94120: PUSH
94121: LD_INT 105
94123: PUSH
94124: LD_INT 106
94126: PUSH
94127: LD_INT 108
94129: PUSH
94130: LD_INT 116
94132: PUSH
94133: LD_INT 117
94135: PUSH
94136: LD_INT 118
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: ST_TO_ADDR
94153: GO 97040
94155: LD_INT 4
94157: DOUBLE
94158: EQUAL
94159: IFTRUE 94163
94161: GO 94259
94163: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94164: LD_ADDR_VAR 0 2
94168: PUSH
94169: LD_INT 2
94171: PUSH
94172: LD_INT 4
94174: PUSH
94175: LD_INT 5
94177: PUSH
94178: LD_INT 8
94180: PUSH
94181: LD_INT 11
94183: PUSH
94184: LD_INT 12
94186: PUSH
94187: LD_INT 15
94189: PUSH
94190: LD_INT 16
94192: PUSH
94193: LD_INT 22
94195: PUSH
94196: LD_INT 23
94198: PUSH
94199: LD_INT 26
94201: PUSH
94202: LD_INT 36
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: PUSH
94219: LD_INT 101
94221: PUSH
94222: LD_INT 102
94224: PUSH
94225: LD_INT 105
94227: PUSH
94228: LD_INT 106
94230: PUSH
94231: LD_INT 108
94233: PUSH
94234: LD_INT 116
94236: PUSH
94237: LD_INT 117
94239: PUSH
94240: LD_INT 118
94242: PUSH
94243: EMPTY
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: PUSH
94253: EMPTY
94254: LIST
94255: LIST
94256: ST_TO_ADDR
94257: GO 97040
94259: LD_INT 5
94261: DOUBLE
94262: EQUAL
94263: IFTRUE 94267
94265: GO 94379
94267: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94268: LD_ADDR_VAR 0 2
94272: PUSH
94273: LD_INT 2
94275: PUSH
94276: LD_INT 4
94278: PUSH
94279: LD_INT 5
94281: PUSH
94282: LD_INT 6
94284: PUSH
94285: LD_INT 8
94287: PUSH
94288: LD_INT 11
94290: PUSH
94291: LD_INT 12
94293: PUSH
94294: LD_INT 15
94296: PUSH
94297: LD_INT 16
94299: PUSH
94300: LD_INT 22
94302: PUSH
94303: LD_INT 23
94305: PUSH
94306: LD_INT 25
94308: PUSH
94309: LD_INT 26
94311: PUSH
94312: LD_INT 36
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: PUSH
94331: LD_INT 101
94333: PUSH
94334: LD_INT 102
94336: PUSH
94337: LD_INT 105
94339: PUSH
94340: LD_INT 106
94342: PUSH
94343: LD_INT 108
94345: PUSH
94346: LD_INT 109
94348: PUSH
94349: LD_INT 112
94351: PUSH
94352: LD_INT 116
94354: PUSH
94355: LD_INT 117
94357: PUSH
94358: LD_INT 118
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: ST_TO_ADDR
94377: GO 97040
94379: LD_INT 6
94381: DOUBLE
94382: EQUAL
94383: IFTRUE 94387
94385: GO 94519
94387: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94388: LD_ADDR_VAR 0 2
94392: PUSH
94393: LD_INT 2
94395: PUSH
94396: LD_INT 4
94398: PUSH
94399: LD_INT 5
94401: PUSH
94402: LD_INT 6
94404: PUSH
94405: LD_INT 8
94407: PUSH
94408: LD_INT 11
94410: PUSH
94411: LD_INT 12
94413: PUSH
94414: LD_INT 15
94416: PUSH
94417: LD_INT 16
94419: PUSH
94420: LD_INT 20
94422: PUSH
94423: LD_INT 21
94425: PUSH
94426: LD_INT 22
94428: PUSH
94429: LD_INT 23
94431: PUSH
94432: LD_INT 25
94434: PUSH
94435: LD_INT 26
94437: PUSH
94438: LD_INT 30
94440: PUSH
94441: LD_INT 31
94443: PUSH
94444: LD_INT 32
94446: PUSH
94447: LD_INT 36
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: PUSH
94471: LD_INT 101
94473: PUSH
94474: LD_INT 102
94476: PUSH
94477: LD_INT 105
94479: PUSH
94480: LD_INT 106
94482: PUSH
94483: LD_INT 108
94485: PUSH
94486: LD_INT 109
94488: PUSH
94489: LD_INT 112
94491: PUSH
94492: LD_INT 116
94494: PUSH
94495: LD_INT 117
94497: PUSH
94498: LD_INT 118
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: ST_TO_ADDR
94517: GO 97040
94519: LD_INT 7
94521: DOUBLE
94522: EQUAL
94523: IFTRUE 94527
94525: GO 94639
94527: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94528: LD_ADDR_VAR 0 2
94532: PUSH
94533: LD_INT 2
94535: PUSH
94536: LD_INT 4
94538: PUSH
94539: LD_INT 5
94541: PUSH
94542: LD_INT 7
94544: PUSH
94545: LD_INT 11
94547: PUSH
94548: LD_INT 12
94550: PUSH
94551: LD_INT 15
94553: PUSH
94554: LD_INT 16
94556: PUSH
94557: LD_INT 20
94559: PUSH
94560: LD_INT 21
94562: PUSH
94563: LD_INT 22
94565: PUSH
94566: LD_INT 23
94568: PUSH
94569: LD_INT 25
94571: PUSH
94572: LD_INT 26
94574: PUSH
94575: EMPTY
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: PUSH
94591: LD_INT 101
94593: PUSH
94594: LD_INT 102
94596: PUSH
94597: LD_INT 103
94599: PUSH
94600: LD_INT 105
94602: PUSH
94603: LD_INT 106
94605: PUSH
94606: LD_INT 108
94608: PUSH
94609: LD_INT 112
94611: PUSH
94612: LD_INT 116
94614: PUSH
94615: LD_INT 117
94617: PUSH
94618: LD_INT 118
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: ST_TO_ADDR
94637: GO 97040
94639: LD_INT 8
94641: DOUBLE
94642: EQUAL
94643: IFTRUE 94647
94645: GO 94787
94647: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94648: LD_ADDR_VAR 0 2
94652: PUSH
94653: LD_INT 2
94655: PUSH
94656: LD_INT 4
94658: PUSH
94659: LD_INT 5
94661: PUSH
94662: LD_INT 6
94664: PUSH
94665: LD_INT 7
94667: PUSH
94668: LD_INT 8
94670: PUSH
94671: LD_INT 11
94673: PUSH
94674: LD_INT 12
94676: PUSH
94677: LD_INT 15
94679: PUSH
94680: LD_INT 16
94682: PUSH
94683: LD_INT 20
94685: PUSH
94686: LD_INT 21
94688: PUSH
94689: LD_INT 22
94691: PUSH
94692: LD_INT 23
94694: PUSH
94695: LD_INT 25
94697: PUSH
94698: LD_INT 26
94700: PUSH
94701: LD_INT 30
94703: PUSH
94704: LD_INT 31
94706: PUSH
94707: LD_INT 32
94709: PUSH
94710: LD_INT 36
94712: PUSH
94713: EMPTY
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: PUSH
94735: LD_INT 101
94737: PUSH
94738: LD_INT 102
94740: PUSH
94741: LD_INT 103
94743: PUSH
94744: LD_INT 105
94746: PUSH
94747: LD_INT 106
94749: PUSH
94750: LD_INT 108
94752: PUSH
94753: LD_INT 109
94755: PUSH
94756: LD_INT 112
94758: PUSH
94759: LD_INT 116
94761: PUSH
94762: LD_INT 117
94764: PUSH
94765: LD_INT 118
94767: PUSH
94768: EMPTY
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: ST_TO_ADDR
94785: GO 97040
94787: LD_INT 9
94789: DOUBLE
94790: EQUAL
94791: IFTRUE 94795
94793: GO 94943
94795: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94796: LD_ADDR_VAR 0 2
94800: PUSH
94801: LD_INT 2
94803: PUSH
94804: LD_INT 4
94806: PUSH
94807: LD_INT 5
94809: PUSH
94810: LD_INT 6
94812: PUSH
94813: LD_INT 7
94815: PUSH
94816: LD_INT 8
94818: PUSH
94819: LD_INT 11
94821: PUSH
94822: LD_INT 12
94824: PUSH
94825: LD_INT 15
94827: PUSH
94828: LD_INT 16
94830: PUSH
94831: LD_INT 20
94833: PUSH
94834: LD_INT 21
94836: PUSH
94837: LD_INT 22
94839: PUSH
94840: LD_INT 23
94842: PUSH
94843: LD_INT 25
94845: PUSH
94846: LD_INT 26
94848: PUSH
94849: LD_INT 28
94851: PUSH
94852: LD_INT 30
94854: PUSH
94855: LD_INT 31
94857: PUSH
94858: LD_INT 32
94860: PUSH
94861: LD_INT 36
94863: PUSH
94864: EMPTY
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: PUSH
94887: LD_INT 101
94889: PUSH
94890: LD_INT 102
94892: PUSH
94893: LD_INT 103
94895: PUSH
94896: LD_INT 105
94898: PUSH
94899: LD_INT 106
94901: PUSH
94902: LD_INT 108
94904: PUSH
94905: LD_INT 109
94907: PUSH
94908: LD_INT 112
94910: PUSH
94911: LD_INT 114
94913: PUSH
94914: LD_INT 116
94916: PUSH
94917: LD_INT 117
94919: PUSH
94920: LD_INT 118
94922: PUSH
94923: EMPTY
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: ST_TO_ADDR
94941: GO 97040
94943: LD_INT 10
94945: DOUBLE
94946: EQUAL
94947: IFTRUE 94951
94949: GO 95147
94951: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94952: LD_ADDR_VAR 0 2
94956: PUSH
94957: LD_INT 2
94959: PUSH
94960: LD_INT 4
94962: PUSH
94963: LD_INT 5
94965: PUSH
94966: LD_INT 6
94968: PUSH
94969: LD_INT 7
94971: PUSH
94972: LD_INT 8
94974: PUSH
94975: LD_INT 9
94977: PUSH
94978: LD_INT 10
94980: PUSH
94981: LD_INT 11
94983: PUSH
94984: LD_INT 12
94986: PUSH
94987: LD_INT 13
94989: PUSH
94990: LD_INT 14
94992: PUSH
94993: LD_INT 15
94995: PUSH
94996: LD_INT 16
94998: PUSH
94999: LD_INT 17
95001: PUSH
95002: LD_INT 18
95004: PUSH
95005: LD_INT 19
95007: PUSH
95008: LD_INT 20
95010: PUSH
95011: LD_INT 21
95013: PUSH
95014: LD_INT 22
95016: PUSH
95017: LD_INT 23
95019: PUSH
95020: LD_INT 24
95022: PUSH
95023: LD_INT 25
95025: PUSH
95026: LD_INT 26
95028: PUSH
95029: LD_INT 28
95031: PUSH
95032: LD_INT 30
95034: PUSH
95035: LD_INT 31
95037: PUSH
95038: LD_INT 32
95040: PUSH
95041: LD_INT 36
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: PUSH
95075: LD_INT 101
95077: PUSH
95078: LD_INT 102
95080: PUSH
95081: LD_INT 103
95083: PUSH
95084: LD_INT 104
95086: PUSH
95087: LD_INT 105
95089: PUSH
95090: LD_INT 106
95092: PUSH
95093: LD_INT 107
95095: PUSH
95096: LD_INT 108
95098: PUSH
95099: LD_INT 109
95101: PUSH
95102: LD_INT 110
95104: PUSH
95105: LD_INT 111
95107: PUSH
95108: LD_INT 112
95110: PUSH
95111: LD_INT 114
95113: PUSH
95114: LD_INT 116
95116: PUSH
95117: LD_INT 117
95119: PUSH
95120: LD_INT 118
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: LIST
95133: LIST
95134: LIST
95135: LIST
95136: LIST
95137: LIST
95138: LIST
95139: LIST
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: ST_TO_ADDR
95145: GO 97040
95147: LD_INT 11
95149: DOUBLE
95150: EQUAL
95151: IFTRUE 95155
95153: GO 95359
95155: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95156: LD_ADDR_VAR 0 2
95160: PUSH
95161: LD_INT 2
95163: PUSH
95164: LD_INT 3
95166: PUSH
95167: LD_INT 4
95169: PUSH
95170: LD_INT 5
95172: PUSH
95173: LD_INT 6
95175: PUSH
95176: LD_INT 7
95178: PUSH
95179: LD_INT 8
95181: PUSH
95182: LD_INT 9
95184: PUSH
95185: LD_INT 10
95187: PUSH
95188: LD_INT 11
95190: PUSH
95191: LD_INT 12
95193: PUSH
95194: LD_INT 13
95196: PUSH
95197: LD_INT 14
95199: PUSH
95200: LD_INT 15
95202: PUSH
95203: LD_INT 16
95205: PUSH
95206: LD_INT 17
95208: PUSH
95209: LD_INT 18
95211: PUSH
95212: LD_INT 19
95214: PUSH
95215: LD_INT 20
95217: PUSH
95218: LD_INT 21
95220: PUSH
95221: LD_INT 22
95223: PUSH
95224: LD_INT 23
95226: PUSH
95227: LD_INT 24
95229: PUSH
95230: LD_INT 25
95232: PUSH
95233: LD_INT 26
95235: PUSH
95236: LD_INT 28
95238: PUSH
95239: LD_INT 30
95241: PUSH
95242: LD_INT 31
95244: PUSH
95245: LD_INT 32
95247: PUSH
95248: LD_INT 34
95250: PUSH
95251: LD_INT 36
95253: PUSH
95254: EMPTY
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: LIST
95286: PUSH
95287: LD_INT 101
95289: PUSH
95290: LD_INT 102
95292: PUSH
95293: LD_INT 103
95295: PUSH
95296: LD_INT 104
95298: PUSH
95299: LD_INT 105
95301: PUSH
95302: LD_INT 106
95304: PUSH
95305: LD_INT 107
95307: PUSH
95308: LD_INT 108
95310: PUSH
95311: LD_INT 109
95313: PUSH
95314: LD_INT 110
95316: PUSH
95317: LD_INT 111
95319: PUSH
95320: LD_INT 112
95322: PUSH
95323: LD_INT 114
95325: PUSH
95326: LD_INT 116
95328: PUSH
95329: LD_INT 117
95331: PUSH
95332: LD_INT 118
95334: PUSH
95335: EMPTY
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: ST_TO_ADDR
95357: GO 97040
95359: LD_INT 12
95361: DOUBLE
95362: EQUAL
95363: IFTRUE 95367
95365: GO 95587
95367: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95368: LD_ADDR_VAR 0 2
95372: PUSH
95373: LD_INT 1
95375: PUSH
95376: LD_INT 2
95378: PUSH
95379: LD_INT 3
95381: PUSH
95382: LD_INT 4
95384: PUSH
95385: LD_INT 5
95387: PUSH
95388: LD_INT 6
95390: PUSH
95391: LD_INT 7
95393: PUSH
95394: LD_INT 8
95396: PUSH
95397: LD_INT 9
95399: PUSH
95400: LD_INT 10
95402: PUSH
95403: LD_INT 11
95405: PUSH
95406: LD_INT 12
95408: PUSH
95409: LD_INT 13
95411: PUSH
95412: LD_INT 14
95414: PUSH
95415: LD_INT 15
95417: PUSH
95418: LD_INT 16
95420: PUSH
95421: LD_INT 17
95423: PUSH
95424: LD_INT 18
95426: PUSH
95427: LD_INT 19
95429: PUSH
95430: LD_INT 20
95432: PUSH
95433: LD_INT 21
95435: PUSH
95436: LD_INT 22
95438: PUSH
95439: LD_INT 23
95441: PUSH
95442: LD_INT 24
95444: PUSH
95445: LD_INT 25
95447: PUSH
95448: LD_INT 26
95450: PUSH
95451: LD_INT 27
95453: PUSH
95454: LD_INT 28
95456: PUSH
95457: LD_INT 30
95459: PUSH
95460: LD_INT 31
95462: PUSH
95463: LD_INT 32
95465: PUSH
95466: LD_INT 33
95468: PUSH
95469: LD_INT 34
95471: PUSH
95472: LD_INT 36
95474: PUSH
95475: EMPTY
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: PUSH
95511: LD_INT 101
95513: PUSH
95514: LD_INT 102
95516: PUSH
95517: LD_INT 103
95519: PUSH
95520: LD_INT 104
95522: PUSH
95523: LD_INT 105
95525: PUSH
95526: LD_INT 106
95528: PUSH
95529: LD_INT 107
95531: PUSH
95532: LD_INT 108
95534: PUSH
95535: LD_INT 109
95537: PUSH
95538: LD_INT 110
95540: PUSH
95541: LD_INT 111
95543: PUSH
95544: LD_INT 112
95546: PUSH
95547: LD_INT 113
95549: PUSH
95550: LD_INT 114
95552: PUSH
95553: LD_INT 116
95555: PUSH
95556: LD_INT 117
95558: PUSH
95559: LD_INT 118
95561: PUSH
95562: EMPTY
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: LIST
95579: LIST
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: ST_TO_ADDR
95585: GO 97040
95587: LD_INT 13
95589: DOUBLE
95590: EQUAL
95591: IFTRUE 95595
95593: GO 95803
95595: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95596: LD_ADDR_VAR 0 2
95600: PUSH
95601: LD_INT 1
95603: PUSH
95604: LD_INT 2
95606: PUSH
95607: LD_INT 3
95609: PUSH
95610: LD_INT 4
95612: PUSH
95613: LD_INT 5
95615: PUSH
95616: LD_INT 8
95618: PUSH
95619: LD_INT 9
95621: PUSH
95622: LD_INT 10
95624: PUSH
95625: LD_INT 11
95627: PUSH
95628: LD_INT 12
95630: PUSH
95631: LD_INT 14
95633: PUSH
95634: LD_INT 15
95636: PUSH
95637: LD_INT 16
95639: PUSH
95640: LD_INT 17
95642: PUSH
95643: LD_INT 18
95645: PUSH
95646: LD_INT 19
95648: PUSH
95649: LD_INT 20
95651: PUSH
95652: LD_INT 21
95654: PUSH
95655: LD_INT 22
95657: PUSH
95658: LD_INT 23
95660: PUSH
95661: LD_INT 24
95663: PUSH
95664: LD_INT 25
95666: PUSH
95667: LD_INT 26
95669: PUSH
95670: LD_INT 27
95672: PUSH
95673: LD_INT 28
95675: PUSH
95676: LD_INT 30
95678: PUSH
95679: LD_INT 31
95681: PUSH
95682: LD_INT 32
95684: PUSH
95685: LD_INT 33
95687: PUSH
95688: LD_INT 34
95690: PUSH
95691: LD_INT 36
95693: PUSH
95694: EMPTY
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: PUSH
95727: LD_INT 101
95729: PUSH
95730: LD_INT 102
95732: PUSH
95733: LD_INT 103
95735: PUSH
95736: LD_INT 104
95738: PUSH
95739: LD_INT 105
95741: PUSH
95742: LD_INT 106
95744: PUSH
95745: LD_INT 107
95747: PUSH
95748: LD_INT 108
95750: PUSH
95751: LD_INT 109
95753: PUSH
95754: LD_INT 110
95756: PUSH
95757: LD_INT 111
95759: PUSH
95760: LD_INT 112
95762: PUSH
95763: LD_INT 113
95765: PUSH
95766: LD_INT 114
95768: PUSH
95769: LD_INT 116
95771: PUSH
95772: LD_INT 117
95774: PUSH
95775: LD_INT 118
95777: PUSH
95778: EMPTY
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: ST_TO_ADDR
95801: GO 97040
95803: LD_INT 14
95805: DOUBLE
95806: EQUAL
95807: IFTRUE 95811
95809: GO 96035
95811: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95812: LD_ADDR_VAR 0 2
95816: PUSH
95817: LD_INT 1
95819: PUSH
95820: LD_INT 2
95822: PUSH
95823: LD_INT 3
95825: PUSH
95826: LD_INT 4
95828: PUSH
95829: LD_INT 5
95831: PUSH
95832: LD_INT 6
95834: PUSH
95835: LD_INT 7
95837: PUSH
95838: LD_INT 8
95840: PUSH
95841: LD_INT 9
95843: PUSH
95844: LD_INT 10
95846: PUSH
95847: LD_INT 11
95849: PUSH
95850: LD_INT 12
95852: PUSH
95853: LD_INT 13
95855: PUSH
95856: LD_INT 14
95858: PUSH
95859: LD_INT 15
95861: PUSH
95862: LD_INT 16
95864: PUSH
95865: LD_INT 17
95867: PUSH
95868: LD_INT 18
95870: PUSH
95871: LD_INT 19
95873: PUSH
95874: LD_INT 20
95876: PUSH
95877: LD_INT 21
95879: PUSH
95880: LD_INT 22
95882: PUSH
95883: LD_INT 23
95885: PUSH
95886: LD_INT 24
95888: PUSH
95889: LD_INT 25
95891: PUSH
95892: LD_INT 26
95894: PUSH
95895: LD_INT 27
95897: PUSH
95898: LD_INT 28
95900: PUSH
95901: LD_INT 29
95903: PUSH
95904: LD_INT 30
95906: PUSH
95907: LD_INT 31
95909: PUSH
95910: LD_INT 32
95912: PUSH
95913: LD_INT 33
95915: PUSH
95916: LD_INT 34
95918: PUSH
95919: LD_INT 36
95921: PUSH
95922: EMPTY
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: PUSH
95959: LD_INT 101
95961: PUSH
95962: LD_INT 102
95964: PUSH
95965: LD_INT 103
95967: PUSH
95968: LD_INT 104
95970: PUSH
95971: LD_INT 105
95973: PUSH
95974: LD_INT 106
95976: PUSH
95977: LD_INT 107
95979: PUSH
95980: LD_INT 108
95982: PUSH
95983: LD_INT 109
95985: PUSH
95986: LD_INT 110
95988: PUSH
95989: LD_INT 111
95991: PUSH
95992: LD_INT 112
95994: PUSH
95995: LD_INT 113
95997: PUSH
95998: LD_INT 114
96000: PUSH
96001: LD_INT 116
96003: PUSH
96004: LD_INT 117
96006: PUSH
96007: LD_INT 118
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: PUSH
96029: EMPTY
96030: LIST
96031: LIST
96032: ST_TO_ADDR
96033: GO 97040
96035: LD_INT 15
96037: DOUBLE
96038: EQUAL
96039: IFTRUE 96043
96041: GO 96267
96043: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96044: LD_ADDR_VAR 0 2
96048: PUSH
96049: LD_INT 1
96051: PUSH
96052: LD_INT 2
96054: PUSH
96055: LD_INT 3
96057: PUSH
96058: LD_INT 4
96060: PUSH
96061: LD_INT 5
96063: PUSH
96064: LD_INT 6
96066: PUSH
96067: LD_INT 7
96069: PUSH
96070: LD_INT 8
96072: PUSH
96073: LD_INT 9
96075: PUSH
96076: LD_INT 10
96078: PUSH
96079: LD_INT 11
96081: PUSH
96082: LD_INT 12
96084: PUSH
96085: LD_INT 13
96087: PUSH
96088: LD_INT 14
96090: PUSH
96091: LD_INT 15
96093: PUSH
96094: LD_INT 16
96096: PUSH
96097: LD_INT 17
96099: PUSH
96100: LD_INT 18
96102: PUSH
96103: LD_INT 19
96105: PUSH
96106: LD_INT 20
96108: PUSH
96109: LD_INT 21
96111: PUSH
96112: LD_INT 22
96114: PUSH
96115: LD_INT 23
96117: PUSH
96118: LD_INT 24
96120: PUSH
96121: LD_INT 25
96123: PUSH
96124: LD_INT 26
96126: PUSH
96127: LD_INT 27
96129: PUSH
96130: LD_INT 28
96132: PUSH
96133: LD_INT 29
96135: PUSH
96136: LD_INT 30
96138: PUSH
96139: LD_INT 31
96141: PUSH
96142: LD_INT 32
96144: PUSH
96145: LD_INT 33
96147: PUSH
96148: LD_INT 34
96150: PUSH
96151: LD_INT 36
96153: PUSH
96154: EMPTY
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: PUSH
96191: LD_INT 101
96193: PUSH
96194: LD_INT 102
96196: PUSH
96197: LD_INT 103
96199: PUSH
96200: LD_INT 104
96202: PUSH
96203: LD_INT 105
96205: PUSH
96206: LD_INT 106
96208: PUSH
96209: LD_INT 107
96211: PUSH
96212: LD_INT 108
96214: PUSH
96215: LD_INT 109
96217: PUSH
96218: LD_INT 110
96220: PUSH
96221: LD_INT 111
96223: PUSH
96224: LD_INT 112
96226: PUSH
96227: LD_INT 113
96229: PUSH
96230: LD_INT 114
96232: PUSH
96233: LD_INT 116
96235: PUSH
96236: LD_INT 117
96238: PUSH
96239: LD_INT 118
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: PUSH
96261: EMPTY
96262: LIST
96263: LIST
96264: ST_TO_ADDR
96265: GO 97040
96267: LD_INT 16
96269: DOUBLE
96270: EQUAL
96271: IFTRUE 96275
96273: GO 96411
96275: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96276: LD_ADDR_VAR 0 2
96280: PUSH
96281: LD_INT 2
96283: PUSH
96284: LD_INT 4
96286: PUSH
96287: LD_INT 5
96289: PUSH
96290: LD_INT 7
96292: PUSH
96293: LD_INT 11
96295: PUSH
96296: LD_INT 12
96298: PUSH
96299: LD_INT 15
96301: PUSH
96302: LD_INT 16
96304: PUSH
96305: LD_INT 20
96307: PUSH
96308: LD_INT 21
96310: PUSH
96311: LD_INT 22
96313: PUSH
96314: LD_INT 23
96316: PUSH
96317: LD_INT 25
96319: PUSH
96320: LD_INT 26
96322: PUSH
96323: LD_INT 30
96325: PUSH
96326: LD_INT 31
96328: PUSH
96329: LD_INT 32
96331: PUSH
96332: LD_INT 33
96334: PUSH
96335: LD_INT 34
96337: PUSH
96338: EMPTY
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: PUSH
96359: LD_INT 101
96361: PUSH
96362: LD_INT 102
96364: PUSH
96365: LD_INT 103
96367: PUSH
96368: LD_INT 106
96370: PUSH
96371: LD_INT 108
96373: PUSH
96374: LD_INT 112
96376: PUSH
96377: LD_INT 113
96379: PUSH
96380: LD_INT 114
96382: PUSH
96383: LD_INT 116
96385: PUSH
96386: LD_INT 117
96388: PUSH
96389: LD_INT 118
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: PUSH
96405: EMPTY
96406: LIST
96407: LIST
96408: ST_TO_ADDR
96409: GO 97040
96411: LD_INT 17
96413: DOUBLE
96414: EQUAL
96415: IFTRUE 96419
96417: GO 96643
96419: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96420: LD_ADDR_VAR 0 2
96424: PUSH
96425: LD_INT 1
96427: PUSH
96428: LD_INT 2
96430: PUSH
96431: LD_INT 3
96433: PUSH
96434: LD_INT 4
96436: PUSH
96437: LD_INT 5
96439: PUSH
96440: LD_INT 6
96442: PUSH
96443: LD_INT 7
96445: PUSH
96446: LD_INT 8
96448: PUSH
96449: LD_INT 9
96451: PUSH
96452: LD_INT 10
96454: PUSH
96455: LD_INT 11
96457: PUSH
96458: LD_INT 12
96460: PUSH
96461: LD_INT 13
96463: PUSH
96464: LD_INT 14
96466: PUSH
96467: LD_INT 15
96469: PUSH
96470: LD_INT 16
96472: PUSH
96473: LD_INT 17
96475: PUSH
96476: LD_INT 18
96478: PUSH
96479: LD_INT 19
96481: PUSH
96482: LD_INT 20
96484: PUSH
96485: LD_INT 21
96487: PUSH
96488: LD_INT 22
96490: PUSH
96491: LD_INT 23
96493: PUSH
96494: LD_INT 24
96496: PUSH
96497: LD_INT 25
96499: PUSH
96500: LD_INT 26
96502: PUSH
96503: LD_INT 27
96505: PUSH
96506: LD_INT 28
96508: PUSH
96509: LD_INT 29
96511: PUSH
96512: LD_INT 30
96514: PUSH
96515: LD_INT 31
96517: PUSH
96518: LD_INT 32
96520: PUSH
96521: LD_INT 33
96523: PUSH
96524: LD_INT 34
96526: PUSH
96527: LD_INT 36
96529: PUSH
96530: EMPTY
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: PUSH
96567: LD_INT 101
96569: PUSH
96570: LD_INT 102
96572: PUSH
96573: LD_INT 103
96575: PUSH
96576: LD_INT 104
96578: PUSH
96579: LD_INT 105
96581: PUSH
96582: LD_INT 106
96584: PUSH
96585: LD_INT 107
96587: PUSH
96588: LD_INT 108
96590: PUSH
96591: LD_INT 109
96593: PUSH
96594: LD_INT 110
96596: PUSH
96597: LD_INT 111
96599: PUSH
96600: LD_INT 112
96602: PUSH
96603: LD_INT 113
96605: PUSH
96606: LD_INT 114
96608: PUSH
96609: LD_INT 116
96611: PUSH
96612: LD_INT 117
96614: PUSH
96615: LD_INT 118
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: PUSH
96637: EMPTY
96638: LIST
96639: LIST
96640: ST_TO_ADDR
96641: GO 97040
96643: LD_INT 18
96645: DOUBLE
96646: EQUAL
96647: IFTRUE 96651
96649: GO 96799
96651: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96652: LD_ADDR_VAR 0 2
96656: PUSH
96657: LD_INT 2
96659: PUSH
96660: LD_INT 4
96662: PUSH
96663: LD_INT 5
96665: PUSH
96666: LD_INT 7
96668: PUSH
96669: LD_INT 11
96671: PUSH
96672: LD_INT 12
96674: PUSH
96675: LD_INT 15
96677: PUSH
96678: LD_INT 16
96680: PUSH
96681: LD_INT 20
96683: PUSH
96684: LD_INT 21
96686: PUSH
96687: LD_INT 22
96689: PUSH
96690: LD_INT 23
96692: PUSH
96693: LD_INT 25
96695: PUSH
96696: LD_INT 26
96698: PUSH
96699: LD_INT 30
96701: PUSH
96702: LD_INT 31
96704: PUSH
96705: LD_INT 32
96707: PUSH
96708: LD_INT 33
96710: PUSH
96711: LD_INT 34
96713: PUSH
96714: LD_INT 35
96716: PUSH
96717: LD_INT 36
96719: PUSH
96720: EMPTY
96721: LIST
96722: LIST
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: PUSH
96743: LD_INT 101
96745: PUSH
96746: LD_INT 102
96748: PUSH
96749: LD_INT 103
96751: PUSH
96752: LD_INT 106
96754: PUSH
96755: LD_INT 108
96757: PUSH
96758: LD_INT 112
96760: PUSH
96761: LD_INT 113
96763: PUSH
96764: LD_INT 114
96766: PUSH
96767: LD_INT 115
96769: PUSH
96770: LD_INT 116
96772: PUSH
96773: LD_INT 117
96775: PUSH
96776: LD_INT 118
96778: PUSH
96779: EMPTY
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: ST_TO_ADDR
96797: GO 97040
96799: LD_INT 19
96801: DOUBLE
96802: EQUAL
96803: IFTRUE 96807
96805: GO 97039
96807: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96808: LD_ADDR_VAR 0 2
96812: PUSH
96813: LD_INT 1
96815: PUSH
96816: LD_INT 2
96818: PUSH
96819: LD_INT 3
96821: PUSH
96822: LD_INT 4
96824: PUSH
96825: LD_INT 5
96827: PUSH
96828: LD_INT 6
96830: PUSH
96831: LD_INT 7
96833: PUSH
96834: LD_INT 8
96836: PUSH
96837: LD_INT 9
96839: PUSH
96840: LD_INT 10
96842: PUSH
96843: LD_INT 11
96845: PUSH
96846: LD_INT 12
96848: PUSH
96849: LD_INT 13
96851: PUSH
96852: LD_INT 14
96854: PUSH
96855: LD_INT 15
96857: PUSH
96858: LD_INT 16
96860: PUSH
96861: LD_INT 17
96863: PUSH
96864: LD_INT 18
96866: PUSH
96867: LD_INT 19
96869: PUSH
96870: LD_INT 20
96872: PUSH
96873: LD_INT 21
96875: PUSH
96876: LD_INT 22
96878: PUSH
96879: LD_INT 23
96881: PUSH
96882: LD_INT 24
96884: PUSH
96885: LD_INT 25
96887: PUSH
96888: LD_INT 26
96890: PUSH
96891: LD_INT 27
96893: PUSH
96894: LD_INT 28
96896: PUSH
96897: LD_INT 29
96899: PUSH
96900: LD_INT 30
96902: PUSH
96903: LD_INT 31
96905: PUSH
96906: LD_INT 32
96908: PUSH
96909: LD_INT 33
96911: PUSH
96912: LD_INT 34
96914: PUSH
96915: LD_INT 35
96917: PUSH
96918: LD_INT 36
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: PUSH
96959: LD_INT 101
96961: PUSH
96962: LD_INT 102
96964: PUSH
96965: LD_INT 103
96967: PUSH
96968: LD_INT 104
96970: PUSH
96971: LD_INT 105
96973: PUSH
96974: LD_INT 106
96976: PUSH
96977: LD_INT 107
96979: PUSH
96980: LD_INT 108
96982: PUSH
96983: LD_INT 109
96985: PUSH
96986: LD_INT 110
96988: PUSH
96989: LD_INT 111
96991: PUSH
96992: LD_INT 112
96994: PUSH
96995: LD_INT 113
96997: PUSH
96998: LD_INT 114
97000: PUSH
97001: LD_INT 115
97003: PUSH
97004: LD_INT 116
97006: PUSH
97007: LD_INT 117
97009: PUSH
97010: LD_INT 118
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: PUSH
97033: EMPTY
97034: LIST
97035: LIST
97036: ST_TO_ADDR
97037: GO 97040
97039: POP
// end else
97040: GO 97271
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97042: LD_ADDR_VAR 0 2
97046: PUSH
97047: LD_INT 1
97049: PUSH
97050: LD_INT 2
97052: PUSH
97053: LD_INT 3
97055: PUSH
97056: LD_INT 4
97058: PUSH
97059: LD_INT 5
97061: PUSH
97062: LD_INT 6
97064: PUSH
97065: LD_INT 7
97067: PUSH
97068: LD_INT 8
97070: PUSH
97071: LD_INT 9
97073: PUSH
97074: LD_INT 10
97076: PUSH
97077: LD_INT 11
97079: PUSH
97080: LD_INT 12
97082: PUSH
97083: LD_INT 13
97085: PUSH
97086: LD_INT 14
97088: PUSH
97089: LD_INT 15
97091: PUSH
97092: LD_INT 16
97094: PUSH
97095: LD_INT 17
97097: PUSH
97098: LD_INT 18
97100: PUSH
97101: LD_INT 19
97103: PUSH
97104: LD_INT 20
97106: PUSH
97107: LD_INT 21
97109: PUSH
97110: LD_INT 22
97112: PUSH
97113: LD_INT 23
97115: PUSH
97116: LD_INT 24
97118: PUSH
97119: LD_INT 25
97121: PUSH
97122: LD_INT 26
97124: PUSH
97125: LD_INT 27
97127: PUSH
97128: LD_INT 28
97130: PUSH
97131: LD_INT 29
97133: PUSH
97134: LD_INT 30
97136: PUSH
97137: LD_INT 31
97139: PUSH
97140: LD_INT 32
97142: PUSH
97143: LD_INT 33
97145: PUSH
97146: LD_INT 34
97148: PUSH
97149: LD_INT 35
97151: PUSH
97152: LD_INT 36
97154: PUSH
97155: EMPTY
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: PUSH
97193: LD_INT 101
97195: PUSH
97196: LD_INT 102
97198: PUSH
97199: LD_INT 103
97201: PUSH
97202: LD_INT 104
97204: PUSH
97205: LD_INT 105
97207: PUSH
97208: LD_INT 106
97210: PUSH
97211: LD_INT 107
97213: PUSH
97214: LD_INT 108
97216: PUSH
97217: LD_INT 109
97219: PUSH
97220: LD_INT 110
97222: PUSH
97223: LD_INT 111
97225: PUSH
97226: LD_INT 112
97228: PUSH
97229: LD_INT 113
97231: PUSH
97232: LD_INT 114
97234: PUSH
97235: LD_INT 115
97237: PUSH
97238: LD_INT 116
97240: PUSH
97241: LD_INT 117
97243: PUSH
97244: LD_INT 118
97246: PUSH
97247: EMPTY
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: ST_TO_ADDR
// if result then
97271: LD_VAR 0 2
97275: IFFALSE 98061
// begin normal :=  ;
97277: LD_ADDR_VAR 0 5
97281: PUSH
97282: LD_STRING 
97284: ST_TO_ADDR
// hardcore :=  ;
97285: LD_ADDR_VAR 0 6
97289: PUSH
97290: LD_STRING 
97292: ST_TO_ADDR
// active :=  ;
97293: LD_ADDR_VAR 0 7
97297: PUSH
97298: LD_STRING 
97300: ST_TO_ADDR
// for i = 1 to normalCounter do
97301: LD_ADDR_VAR 0 8
97305: PUSH
97306: DOUBLE
97307: LD_INT 1
97309: DEC
97310: ST_TO_ADDR
97311: LD_EXP 78
97315: PUSH
97316: FOR_TO
97317: IFFALSE 97418
// begin tmp := 0 ;
97319: LD_ADDR_VAR 0 3
97323: PUSH
97324: LD_STRING 0
97326: ST_TO_ADDR
// if result [ 1 ] then
97327: LD_VAR 0 2
97331: PUSH
97332: LD_INT 1
97334: ARRAY
97335: IFFALSE 97400
// if result [ 1 ] [ 1 ] = i then
97337: LD_VAR 0 2
97341: PUSH
97342: LD_INT 1
97344: ARRAY
97345: PUSH
97346: LD_INT 1
97348: ARRAY
97349: PUSH
97350: LD_VAR 0 8
97354: EQUAL
97355: IFFALSE 97400
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97357: LD_ADDR_VAR 0 2
97361: PUSH
97362: LD_VAR 0 2
97366: PPUSH
97367: LD_INT 1
97369: PPUSH
97370: LD_VAR 0 2
97374: PUSH
97375: LD_INT 1
97377: ARRAY
97378: PPUSH
97379: LD_INT 1
97381: PPUSH
97382: CALL_OW 3
97386: PPUSH
97387: CALL_OW 1
97391: ST_TO_ADDR
// tmp := 1 ;
97392: LD_ADDR_VAR 0 3
97396: PUSH
97397: LD_STRING 1
97399: ST_TO_ADDR
// end ; normal := normal & tmp ;
97400: LD_ADDR_VAR 0 5
97404: PUSH
97405: LD_VAR 0 5
97409: PUSH
97410: LD_VAR 0 3
97414: STR
97415: ST_TO_ADDR
// end ;
97416: GO 97316
97418: POP
97419: POP
// for i = 1 to hardcoreCounter do
97420: LD_ADDR_VAR 0 8
97424: PUSH
97425: DOUBLE
97426: LD_INT 1
97428: DEC
97429: ST_TO_ADDR
97430: LD_EXP 79
97434: PUSH
97435: FOR_TO
97436: IFFALSE 97541
// begin tmp := 0 ;
97438: LD_ADDR_VAR 0 3
97442: PUSH
97443: LD_STRING 0
97445: ST_TO_ADDR
// if result [ 2 ] then
97446: LD_VAR 0 2
97450: PUSH
97451: LD_INT 2
97453: ARRAY
97454: IFFALSE 97523
// if result [ 2 ] [ 1 ] = 100 + i then
97456: LD_VAR 0 2
97460: PUSH
97461: LD_INT 2
97463: ARRAY
97464: PUSH
97465: LD_INT 1
97467: ARRAY
97468: PUSH
97469: LD_INT 100
97471: PUSH
97472: LD_VAR 0 8
97476: PLUS
97477: EQUAL
97478: IFFALSE 97523
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97480: LD_ADDR_VAR 0 2
97484: PUSH
97485: LD_VAR 0 2
97489: PPUSH
97490: LD_INT 2
97492: PPUSH
97493: LD_VAR 0 2
97497: PUSH
97498: LD_INT 2
97500: ARRAY
97501: PPUSH
97502: LD_INT 1
97504: PPUSH
97505: CALL_OW 3
97509: PPUSH
97510: CALL_OW 1
97514: ST_TO_ADDR
// tmp := 1 ;
97515: LD_ADDR_VAR 0 3
97519: PUSH
97520: LD_STRING 1
97522: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97523: LD_ADDR_VAR 0 6
97527: PUSH
97528: LD_VAR 0 6
97532: PUSH
97533: LD_VAR 0 3
97537: STR
97538: ST_TO_ADDR
// end ;
97539: GO 97435
97541: POP
97542: POP
// if isGameLoad then
97543: LD_VAR 0 1
97547: IFFALSE 98022
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97549: LD_ADDR_VAR 0 4
97553: PUSH
97554: LD_EXP 82
97558: PUSH
97559: LD_EXP 81
97563: PUSH
97564: LD_EXP 83
97568: PUSH
97569: LD_EXP 80
97573: PUSH
97574: LD_EXP 84
97578: PUSH
97579: LD_EXP 85
97583: PUSH
97584: LD_EXP 86
97588: PUSH
97589: LD_EXP 87
97593: PUSH
97594: LD_EXP 88
97598: PUSH
97599: LD_EXP 89
97603: PUSH
97604: LD_EXP 90
97608: PUSH
97609: LD_EXP 91
97613: PUSH
97614: LD_EXP 92
97618: PUSH
97619: LD_EXP 93
97623: PUSH
97624: LD_EXP 101
97628: PUSH
97629: LD_EXP 102
97633: PUSH
97634: LD_EXP 103
97638: PUSH
97639: LD_EXP 104
97643: PUSH
97644: LD_EXP 106
97648: PUSH
97649: LD_EXP 107
97653: PUSH
97654: LD_EXP 108
97658: PUSH
97659: LD_EXP 111
97663: PUSH
97664: LD_EXP 113
97668: PUSH
97669: LD_EXP 114
97673: PUSH
97674: LD_EXP 115
97678: PUSH
97679: LD_EXP 117
97683: PUSH
97684: LD_EXP 118
97688: PUSH
97689: LD_EXP 121
97693: PUSH
97694: LD_EXP 122
97698: PUSH
97699: LD_EXP 123
97703: PUSH
97704: LD_EXP 124
97708: PUSH
97709: LD_EXP 125
97713: PUSH
97714: LD_EXP 126
97718: PUSH
97719: LD_EXP 127
97723: PUSH
97724: LD_EXP 128
97728: PUSH
97729: LD_EXP 129
97733: PUSH
97734: LD_EXP 94
97738: PUSH
97739: LD_EXP 95
97743: PUSH
97744: LD_EXP 98
97748: PUSH
97749: LD_EXP 99
97753: PUSH
97754: LD_EXP 100
97758: PUSH
97759: LD_EXP 96
97763: PUSH
97764: LD_EXP 97
97768: PUSH
97769: LD_EXP 105
97773: PUSH
97774: LD_EXP 109
97778: PUSH
97779: LD_EXP 110
97783: PUSH
97784: LD_EXP 112
97788: PUSH
97789: LD_EXP 116
97793: PUSH
97794: LD_EXP 119
97798: PUSH
97799: LD_EXP 120
97803: PUSH
97804: LD_EXP 130
97808: PUSH
97809: LD_EXP 131
97813: PUSH
97814: LD_EXP 132
97818: PUSH
97819: LD_EXP 133
97823: PUSH
97824: EMPTY
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: ST_TO_ADDR
// tmp :=  ;
97880: LD_ADDR_VAR 0 3
97884: PUSH
97885: LD_STRING 
97887: ST_TO_ADDR
// for i = 1 to normalCounter do
97888: LD_ADDR_VAR 0 8
97892: PUSH
97893: DOUBLE
97894: LD_INT 1
97896: DEC
97897: ST_TO_ADDR
97898: LD_EXP 78
97902: PUSH
97903: FOR_TO
97904: IFFALSE 97940
// begin if flags [ i ] then
97906: LD_VAR 0 4
97910: PUSH
97911: LD_VAR 0 8
97915: ARRAY
97916: IFFALSE 97938
// tmp := tmp & i & ; ;
97918: LD_ADDR_VAR 0 3
97922: PUSH
97923: LD_VAR 0 3
97927: PUSH
97928: LD_VAR 0 8
97932: STR
97933: PUSH
97934: LD_STRING ;
97936: STR
97937: ST_TO_ADDR
// end ;
97938: GO 97903
97940: POP
97941: POP
// for i = 1 to hardcoreCounter do
97942: LD_ADDR_VAR 0 8
97946: PUSH
97947: DOUBLE
97948: LD_INT 1
97950: DEC
97951: ST_TO_ADDR
97952: LD_EXP 79
97956: PUSH
97957: FOR_TO
97958: IFFALSE 98004
// begin if flags [ normalCounter + i ] then
97960: LD_VAR 0 4
97964: PUSH
97965: LD_EXP 78
97969: PUSH
97970: LD_VAR 0 8
97974: PLUS
97975: ARRAY
97976: IFFALSE 98002
// tmp := tmp & ( 100 + i ) & ; ;
97978: LD_ADDR_VAR 0 3
97982: PUSH
97983: LD_VAR 0 3
97987: PUSH
97988: LD_INT 100
97990: PUSH
97991: LD_VAR 0 8
97995: PLUS
97996: STR
97997: PUSH
97998: LD_STRING ;
98000: STR
98001: ST_TO_ADDR
// end ;
98002: GO 97957
98004: POP
98005: POP
// if tmp then
98006: LD_VAR 0 3
98010: IFFALSE 98022
// active := tmp ;
98012: LD_ADDR_VAR 0 7
98016: PUSH
98017: LD_VAR 0 3
98021: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
98022: LD_STRING getStreamItemsFromMission("
98024: PUSH
98025: LD_VAR 0 5
98029: STR
98030: PUSH
98031: LD_STRING ","
98033: STR
98034: PUSH
98035: LD_VAR 0 6
98039: STR
98040: PUSH
98041: LD_STRING ","
98043: STR
98044: PUSH
98045: LD_VAR 0 7
98049: STR
98050: PUSH
98051: LD_STRING ")
98053: STR
98054: PPUSH
98055: CALL_OW 559
// end else
98059: GO 98068
// ToLua ( getStreamItemsFromMission("","","") ) ;
98061: LD_STRING getStreamItemsFromMission("","","")
98063: PPUSH
98064: CALL_OW 559
// end ;
98068: LD_VAR 0 2
98072: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98073: LD_EXP 77
98077: PUSH
98078: LD_EXP 82
98082: AND
98083: IFFALSE 98207
98085: GO 98087
98087: DISABLE
98088: LD_INT 0
98090: PPUSH
98091: PPUSH
// begin enable ;
98092: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98093: LD_ADDR_VAR 0 2
98097: PUSH
98098: LD_INT 22
98100: PUSH
98101: LD_OWVAR 2
98105: PUSH
98106: EMPTY
98107: LIST
98108: LIST
98109: PUSH
98110: LD_INT 2
98112: PUSH
98113: LD_INT 34
98115: PUSH
98116: LD_INT 7
98118: PUSH
98119: EMPTY
98120: LIST
98121: LIST
98122: PUSH
98123: LD_INT 34
98125: PUSH
98126: LD_INT 45
98128: PUSH
98129: EMPTY
98130: LIST
98131: LIST
98132: PUSH
98133: LD_INT 34
98135: PUSH
98136: LD_INT 28
98138: PUSH
98139: EMPTY
98140: LIST
98141: LIST
98142: PUSH
98143: LD_INT 34
98145: PUSH
98146: LD_INT 47
98148: PUSH
98149: EMPTY
98150: LIST
98151: LIST
98152: PUSH
98153: EMPTY
98154: LIST
98155: LIST
98156: LIST
98157: LIST
98158: LIST
98159: PUSH
98160: EMPTY
98161: LIST
98162: LIST
98163: PPUSH
98164: CALL_OW 69
98168: ST_TO_ADDR
// if not tmp then
98169: LD_VAR 0 2
98173: NOT
98174: IFFALSE 98178
// exit ;
98176: GO 98207
// for i in tmp do
98178: LD_ADDR_VAR 0 1
98182: PUSH
98183: LD_VAR 0 2
98187: PUSH
98188: FOR_IN
98189: IFFALSE 98205
// begin SetLives ( i , 0 ) ;
98191: LD_VAR 0 1
98195: PPUSH
98196: LD_INT 0
98198: PPUSH
98199: CALL_OW 234
// end ;
98203: GO 98188
98205: POP
98206: POP
// end ;
98207: PPOPN 2
98209: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98210: LD_EXP 77
98214: PUSH
98215: LD_EXP 83
98219: AND
98220: IFFALSE 98304
98222: GO 98224
98224: DISABLE
98225: LD_INT 0
98227: PPUSH
98228: PPUSH
// begin enable ;
98229: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98230: LD_ADDR_VAR 0 2
98234: PUSH
98235: LD_INT 22
98237: PUSH
98238: LD_OWVAR 2
98242: PUSH
98243: EMPTY
98244: LIST
98245: LIST
98246: PUSH
98247: LD_INT 32
98249: PUSH
98250: LD_INT 3
98252: PUSH
98253: EMPTY
98254: LIST
98255: LIST
98256: PUSH
98257: EMPTY
98258: LIST
98259: LIST
98260: PPUSH
98261: CALL_OW 69
98265: ST_TO_ADDR
// if not tmp then
98266: LD_VAR 0 2
98270: NOT
98271: IFFALSE 98275
// exit ;
98273: GO 98304
// for i in tmp do
98275: LD_ADDR_VAR 0 1
98279: PUSH
98280: LD_VAR 0 2
98284: PUSH
98285: FOR_IN
98286: IFFALSE 98302
// begin SetLives ( i , 0 ) ;
98288: LD_VAR 0 1
98292: PPUSH
98293: LD_INT 0
98295: PPUSH
98296: CALL_OW 234
// end ;
98300: GO 98285
98302: POP
98303: POP
// end ;
98304: PPOPN 2
98306: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98307: LD_EXP 77
98311: PUSH
98312: LD_EXP 80
98316: AND
98317: IFFALSE 98410
98319: GO 98321
98321: DISABLE
98322: LD_INT 0
98324: PPUSH
// begin enable ;
98325: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98326: LD_ADDR_VAR 0 1
98330: PUSH
98331: LD_INT 22
98333: PUSH
98334: LD_OWVAR 2
98338: PUSH
98339: EMPTY
98340: LIST
98341: LIST
98342: PUSH
98343: LD_INT 2
98345: PUSH
98346: LD_INT 25
98348: PUSH
98349: LD_INT 5
98351: PUSH
98352: EMPTY
98353: LIST
98354: LIST
98355: PUSH
98356: LD_INT 25
98358: PUSH
98359: LD_INT 9
98361: PUSH
98362: EMPTY
98363: LIST
98364: LIST
98365: PUSH
98366: LD_INT 25
98368: PUSH
98369: LD_INT 8
98371: PUSH
98372: EMPTY
98373: LIST
98374: LIST
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: LIST
98380: LIST
98381: PUSH
98382: EMPTY
98383: LIST
98384: LIST
98385: PPUSH
98386: CALL_OW 69
98390: PUSH
98391: FOR_IN
98392: IFFALSE 98408
// begin SetClass ( i , 1 ) ;
98394: LD_VAR 0 1
98398: PPUSH
98399: LD_INT 1
98401: PPUSH
98402: CALL_OW 336
// end ;
98406: GO 98391
98408: POP
98409: POP
// end ;
98410: PPOPN 1
98412: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98413: LD_EXP 77
98417: PUSH
98418: LD_EXP 81
98422: AND
98423: PUSH
98424: LD_OWVAR 65
98428: PUSH
98429: LD_INT 7
98431: LESS
98432: AND
98433: IFFALSE 98447
98435: GO 98437
98437: DISABLE
// begin enable ;
98438: ENABLE
// game_speed := 7 ;
98439: LD_ADDR_OWVAR 65
98443: PUSH
98444: LD_INT 7
98446: ST_TO_ADDR
// end ;
98447: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98448: LD_EXP 77
98452: PUSH
98453: LD_EXP 84
98457: AND
98458: IFFALSE 98660
98460: GO 98462
98462: DISABLE
98463: LD_INT 0
98465: PPUSH
98466: PPUSH
98467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98468: LD_ADDR_VAR 0 3
98472: PUSH
98473: LD_INT 81
98475: PUSH
98476: LD_OWVAR 2
98480: PUSH
98481: EMPTY
98482: LIST
98483: LIST
98484: PUSH
98485: LD_INT 21
98487: PUSH
98488: LD_INT 1
98490: PUSH
98491: EMPTY
98492: LIST
98493: LIST
98494: PUSH
98495: EMPTY
98496: LIST
98497: LIST
98498: PPUSH
98499: CALL_OW 69
98503: ST_TO_ADDR
// if not tmp then
98504: LD_VAR 0 3
98508: NOT
98509: IFFALSE 98513
// exit ;
98511: GO 98660
// if tmp > 5 then
98513: LD_VAR 0 3
98517: PUSH
98518: LD_INT 5
98520: GREATER
98521: IFFALSE 98533
// k := 5 else
98523: LD_ADDR_VAR 0 2
98527: PUSH
98528: LD_INT 5
98530: ST_TO_ADDR
98531: GO 98543
// k := tmp ;
98533: LD_ADDR_VAR 0 2
98537: PUSH
98538: LD_VAR 0 3
98542: ST_TO_ADDR
// for i := 1 to k do
98543: LD_ADDR_VAR 0 1
98547: PUSH
98548: DOUBLE
98549: LD_INT 1
98551: DEC
98552: ST_TO_ADDR
98553: LD_VAR 0 2
98557: PUSH
98558: FOR_TO
98559: IFFALSE 98658
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98561: LD_VAR 0 3
98565: PUSH
98566: LD_VAR 0 1
98570: ARRAY
98571: PPUSH
98572: LD_VAR 0 1
98576: PUSH
98577: LD_INT 4
98579: MOD
98580: PUSH
98581: LD_INT 1
98583: PLUS
98584: PPUSH
98585: CALL_OW 259
98589: PUSH
98590: LD_INT 10
98592: LESS
98593: IFFALSE 98656
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98595: LD_VAR 0 3
98599: PUSH
98600: LD_VAR 0 1
98604: ARRAY
98605: PPUSH
98606: LD_VAR 0 1
98610: PUSH
98611: LD_INT 4
98613: MOD
98614: PUSH
98615: LD_INT 1
98617: PLUS
98618: PPUSH
98619: LD_VAR 0 3
98623: PUSH
98624: LD_VAR 0 1
98628: ARRAY
98629: PPUSH
98630: LD_VAR 0 1
98634: PUSH
98635: LD_INT 4
98637: MOD
98638: PUSH
98639: LD_INT 1
98641: PLUS
98642: PPUSH
98643: CALL_OW 259
98647: PUSH
98648: LD_INT 1
98650: PLUS
98651: PPUSH
98652: CALL_OW 237
98656: GO 98558
98658: POP
98659: POP
// end ;
98660: PPOPN 3
98662: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98663: LD_EXP 77
98667: PUSH
98668: LD_EXP 85
98672: AND
98673: IFFALSE 98693
98675: GO 98677
98677: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98678: LD_INT 4
98680: PPUSH
98681: LD_OWVAR 2
98685: PPUSH
98686: LD_INT 0
98688: PPUSH
98689: CALL_OW 324
98693: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98694: LD_EXP 77
98698: PUSH
98699: LD_EXP 114
98703: AND
98704: IFFALSE 98724
98706: GO 98708
98708: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98709: LD_INT 19
98711: PPUSH
98712: LD_OWVAR 2
98716: PPUSH
98717: LD_INT 0
98719: PPUSH
98720: CALL_OW 324
98724: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98725: LD_EXP 77
98729: PUSH
98730: LD_EXP 86
98734: AND
98735: IFFALSE 98837
98737: GO 98739
98739: DISABLE
98740: LD_INT 0
98742: PPUSH
98743: PPUSH
// begin enable ;
98744: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98745: LD_ADDR_VAR 0 2
98749: PUSH
98750: LD_INT 22
98752: PUSH
98753: LD_OWVAR 2
98757: PUSH
98758: EMPTY
98759: LIST
98760: LIST
98761: PUSH
98762: LD_INT 2
98764: PUSH
98765: LD_INT 34
98767: PUSH
98768: LD_INT 11
98770: PUSH
98771: EMPTY
98772: LIST
98773: LIST
98774: PUSH
98775: LD_INT 34
98777: PUSH
98778: LD_INT 30
98780: PUSH
98781: EMPTY
98782: LIST
98783: LIST
98784: PUSH
98785: EMPTY
98786: LIST
98787: LIST
98788: LIST
98789: PUSH
98790: EMPTY
98791: LIST
98792: LIST
98793: PPUSH
98794: CALL_OW 69
98798: ST_TO_ADDR
// if not tmp then
98799: LD_VAR 0 2
98803: NOT
98804: IFFALSE 98808
// exit ;
98806: GO 98837
// for i in tmp do
98808: LD_ADDR_VAR 0 1
98812: PUSH
98813: LD_VAR 0 2
98817: PUSH
98818: FOR_IN
98819: IFFALSE 98835
// begin SetLives ( i , 0 ) ;
98821: LD_VAR 0 1
98825: PPUSH
98826: LD_INT 0
98828: PPUSH
98829: CALL_OW 234
// end ;
98833: GO 98818
98835: POP
98836: POP
// end ;
98837: PPOPN 2
98839: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98840: LD_EXP 77
98844: PUSH
98845: LD_EXP 87
98849: AND
98850: IFFALSE 98870
98852: GO 98854
98854: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98855: LD_INT 32
98857: PPUSH
98858: LD_OWVAR 2
98862: PPUSH
98863: LD_INT 0
98865: PPUSH
98866: CALL_OW 324
98870: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98871: LD_EXP 77
98875: PUSH
98876: LD_EXP 88
98880: AND
98881: IFFALSE 99062
98883: GO 98885
98885: DISABLE
98886: LD_INT 0
98888: PPUSH
98889: PPUSH
98890: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98891: LD_ADDR_VAR 0 2
98895: PUSH
98896: LD_INT 22
98898: PUSH
98899: LD_OWVAR 2
98903: PUSH
98904: EMPTY
98905: LIST
98906: LIST
98907: PUSH
98908: LD_INT 33
98910: PUSH
98911: LD_INT 3
98913: PUSH
98914: EMPTY
98915: LIST
98916: LIST
98917: PUSH
98918: EMPTY
98919: LIST
98920: LIST
98921: PPUSH
98922: CALL_OW 69
98926: ST_TO_ADDR
// if not tmp then
98927: LD_VAR 0 2
98931: NOT
98932: IFFALSE 98936
// exit ;
98934: GO 99062
// side := 0 ;
98936: LD_ADDR_VAR 0 3
98940: PUSH
98941: LD_INT 0
98943: ST_TO_ADDR
// for i := 1 to 8 do
98944: LD_ADDR_VAR 0 1
98948: PUSH
98949: DOUBLE
98950: LD_INT 1
98952: DEC
98953: ST_TO_ADDR
98954: LD_INT 8
98956: PUSH
98957: FOR_TO
98958: IFFALSE 99006
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98960: LD_OWVAR 2
98964: PUSH
98965: LD_VAR 0 1
98969: NONEQUAL
98970: PUSH
98971: LD_OWVAR 2
98975: PPUSH
98976: LD_VAR 0 1
98980: PPUSH
98981: CALL_OW 81
98985: PUSH
98986: LD_INT 2
98988: EQUAL
98989: AND
98990: IFFALSE 99004
// begin side := i ;
98992: LD_ADDR_VAR 0 3
98996: PUSH
98997: LD_VAR 0 1
99001: ST_TO_ADDR
// break ;
99002: GO 99006
// end ;
99004: GO 98957
99006: POP
99007: POP
// if not side then
99008: LD_VAR 0 3
99012: NOT
99013: IFFALSE 99017
// exit ;
99015: GO 99062
// for i := 1 to tmp do
99017: LD_ADDR_VAR 0 1
99021: PUSH
99022: DOUBLE
99023: LD_INT 1
99025: DEC
99026: ST_TO_ADDR
99027: LD_VAR 0 2
99031: PUSH
99032: FOR_TO
99033: IFFALSE 99060
// if Prob ( 60 ) then
99035: LD_INT 60
99037: PPUSH
99038: CALL_OW 13
99042: IFFALSE 99058
// SetSide ( i , side ) ;
99044: LD_VAR 0 1
99048: PPUSH
99049: LD_VAR 0 3
99053: PPUSH
99054: CALL_OW 235
99058: GO 99032
99060: POP
99061: POP
// end ;
99062: PPOPN 3
99064: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99065: LD_EXP 77
99069: PUSH
99070: LD_EXP 90
99074: AND
99075: IFFALSE 99194
99077: GO 99079
99079: DISABLE
99080: LD_INT 0
99082: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99083: LD_ADDR_VAR 0 1
99087: PUSH
99088: LD_INT 22
99090: PUSH
99091: LD_OWVAR 2
99095: PUSH
99096: EMPTY
99097: LIST
99098: LIST
99099: PUSH
99100: LD_INT 21
99102: PUSH
99103: LD_INT 1
99105: PUSH
99106: EMPTY
99107: LIST
99108: LIST
99109: PUSH
99110: LD_INT 3
99112: PUSH
99113: LD_INT 23
99115: PUSH
99116: LD_INT 0
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: PUSH
99123: EMPTY
99124: LIST
99125: LIST
99126: PUSH
99127: EMPTY
99128: LIST
99129: LIST
99130: LIST
99131: PPUSH
99132: CALL_OW 69
99136: PUSH
99137: FOR_IN
99138: IFFALSE 99192
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99140: LD_VAR 0 1
99144: PPUSH
99145: CALL_OW 257
99149: PUSH
99150: LD_INT 1
99152: PUSH
99153: LD_INT 2
99155: PUSH
99156: LD_INT 3
99158: PUSH
99159: LD_INT 4
99161: PUSH
99162: EMPTY
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: IN
99168: IFFALSE 99190
// SetClass ( un , rand ( 1 , 4 ) ) ;
99170: LD_VAR 0 1
99174: PPUSH
99175: LD_INT 1
99177: PPUSH
99178: LD_INT 4
99180: PPUSH
99181: CALL_OW 12
99185: PPUSH
99186: CALL_OW 336
99190: GO 99137
99192: POP
99193: POP
// end ;
99194: PPOPN 1
99196: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99197: LD_EXP 77
99201: PUSH
99202: LD_EXP 89
99206: AND
99207: IFFALSE 99286
99209: GO 99211
99211: DISABLE
99212: LD_INT 0
99214: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99215: LD_ADDR_VAR 0 1
99219: PUSH
99220: LD_INT 22
99222: PUSH
99223: LD_OWVAR 2
99227: PUSH
99228: EMPTY
99229: LIST
99230: LIST
99231: PUSH
99232: LD_INT 21
99234: PUSH
99235: LD_INT 3
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: PUSH
99242: EMPTY
99243: LIST
99244: LIST
99245: PPUSH
99246: CALL_OW 69
99250: ST_TO_ADDR
// if not tmp then
99251: LD_VAR 0 1
99255: NOT
99256: IFFALSE 99260
// exit ;
99258: GO 99286
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99260: LD_VAR 0 1
99264: PUSH
99265: LD_INT 1
99267: PPUSH
99268: LD_VAR 0 1
99272: PPUSH
99273: CALL_OW 12
99277: ARRAY
99278: PPUSH
99279: LD_INT 100
99281: PPUSH
99282: CALL_OW 234
// end ;
99286: PPOPN 1
99288: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99289: LD_EXP 77
99293: PUSH
99294: LD_EXP 91
99298: AND
99299: IFFALSE 99397
99301: GO 99303
99303: DISABLE
99304: LD_INT 0
99306: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99307: LD_ADDR_VAR 0 1
99311: PUSH
99312: LD_INT 22
99314: PUSH
99315: LD_OWVAR 2
99319: PUSH
99320: EMPTY
99321: LIST
99322: LIST
99323: PUSH
99324: LD_INT 21
99326: PUSH
99327: LD_INT 1
99329: PUSH
99330: EMPTY
99331: LIST
99332: LIST
99333: PUSH
99334: EMPTY
99335: LIST
99336: LIST
99337: PPUSH
99338: CALL_OW 69
99342: ST_TO_ADDR
// if not tmp then
99343: LD_VAR 0 1
99347: NOT
99348: IFFALSE 99352
// exit ;
99350: GO 99397
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99352: LD_VAR 0 1
99356: PUSH
99357: LD_INT 1
99359: PPUSH
99360: LD_VAR 0 1
99364: PPUSH
99365: CALL_OW 12
99369: ARRAY
99370: PPUSH
99371: LD_INT 1
99373: PPUSH
99374: LD_INT 4
99376: PPUSH
99377: CALL_OW 12
99381: PPUSH
99382: LD_INT 3000
99384: PPUSH
99385: LD_INT 9000
99387: PPUSH
99388: CALL_OW 12
99392: PPUSH
99393: CALL_OW 492
// end ;
99397: PPOPN 1
99399: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99400: LD_EXP 77
99404: PUSH
99405: LD_EXP 92
99409: AND
99410: IFFALSE 99430
99412: GO 99414
99414: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99415: LD_INT 1
99417: PPUSH
99418: LD_OWVAR 2
99422: PPUSH
99423: LD_INT 0
99425: PPUSH
99426: CALL_OW 324
99430: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99431: LD_EXP 77
99435: PUSH
99436: LD_EXP 93
99440: AND
99441: IFFALSE 99524
99443: GO 99445
99445: DISABLE
99446: LD_INT 0
99448: PPUSH
99449: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99450: LD_ADDR_VAR 0 2
99454: PUSH
99455: LD_INT 22
99457: PUSH
99458: LD_OWVAR 2
99462: PUSH
99463: EMPTY
99464: LIST
99465: LIST
99466: PUSH
99467: LD_INT 21
99469: PUSH
99470: LD_INT 3
99472: PUSH
99473: EMPTY
99474: LIST
99475: LIST
99476: PUSH
99477: EMPTY
99478: LIST
99479: LIST
99480: PPUSH
99481: CALL_OW 69
99485: ST_TO_ADDR
// if not tmp then
99486: LD_VAR 0 2
99490: NOT
99491: IFFALSE 99495
// exit ;
99493: GO 99524
// for i in tmp do
99495: LD_ADDR_VAR 0 1
99499: PUSH
99500: LD_VAR 0 2
99504: PUSH
99505: FOR_IN
99506: IFFALSE 99522
// SetBLevel ( i , 10 ) ;
99508: LD_VAR 0 1
99512: PPUSH
99513: LD_INT 10
99515: PPUSH
99516: CALL_OW 241
99520: GO 99505
99522: POP
99523: POP
// end ;
99524: PPOPN 2
99526: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99527: LD_EXP 77
99531: PUSH
99532: LD_EXP 94
99536: AND
99537: IFFALSE 99648
99539: GO 99541
99541: DISABLE
99542: LD_INT 0
99544: PPUSH
99545: PPUSH
99546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99547: LD_ADDR_VAR 0 3
99551: PUSH
99552: LD_INT 22
99554: PUSH
99555: LD_OWVAR 2
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: PUSH
99564: LD_INT 25
99566: PUSH
99567: LD_INT 1
99569: PUSH
99570: EMPTY
99571: LIST
99572: LIST
99573: PUSH
99574: EMPTY
99575: LIST
99576: LIST
99577: PPUSH
99578: CALL_OW 69
99582: ST_TO_ADDR
// if not tmp then
99583: LD_VAR 0 3
99587: NOT
99588: IFFALSE 99592
// exit ;
99590: GO 99648
// un := tmp [ rand ( 1 , tmp ) ] ;
99592: LD_ADDR_VAR 0 2
99596: PUSH
99597: LD_VAR 0 3
99601: PUSH
99602: LD_INT 1
99604: PPUSH
99605: LD_VAR 0 3
99609: PPUSH
99610: CALL_OW 12
99614: ARRAY
99615: ST_TO_ADDR
// if Crawls ( un ) then
99616: LD_VAR 0 2
99620: PPUSH
99621: CALL_OW 318
99625: IFFALSE 99636
// ComWalk ( un ) ;
99627: LD_VAR 0 2
99631: PPUSH
99632: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99636: LD_VAR 0 2
99640: PPUSH
99641: LD_INT 5
99643: PPUSH
99644: CALL_OW 336
// end ;
99648: PPOPN 3
99650: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99651: LD_EXP 77
99655: PUSH
99656: LD_EXP 95
99660: AND
99661: PUSH
99662: LD_OWVAR 67
99666: PUSH
99667: LD_INT 4
99669: LESS
99670: AND
99671: IFFALSE 99690
99673: GO 99675
99675: DISABLE
// begin Difficulty := Difficulty + 1 ;
99676: LD_ADDR_OWVAR 67
99680: PUSH
99681: LD_OWVAR 67
99685: PUSH
99686: LD_INT 1
99688: PLUS
99689: ST_TO_ADDR
// end ;
99690: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99691: LD_EXP 77
99695: PUSH
99696: LD_EXP 96
99700: AND
99701: IFFALSE 99804
99703: GO 99705
99705: DISABLE
99706: LD_INT 0
99708: PPUSH
// begin for i := 1 to 5 do
99709: LD_ADDR_VAR 0 1
99713: PUSH
99714: DOUBLE
99715: LD_INT 1
99717: DEC
99718: ST_TO_ADDR
99719: LD_INT 5
99721: PUSH
99722: FOR_TO
99723: IFFALSE 99802
// begin uc_nation := nation_nature ;
99725: LD_ADDR_OWVAR 21
99729: PUSH
99730: LD_INT 0
99732: ST_TO_ADDR
// uc_side := 0 ;
99733: LD_ADDR_OWVAR 20
99737: PUSH
99738: LD_INT 0
99740: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99741: LD_ADDR_OWVAR 29
99745: PUSH
99746: LD_INT 12
99748: PUSH
99749: LD_INT 12
99751: PUSH
99752: EMPTY
99753: LIST
99754: LIST
99755: ST_TO_ADDR
// hc_agressivity := 20 ;
99756: LD_ADDR_OWVAR 35
99760: PUSH
99761: LD_INT 20
99763: ST_TO_ADDR
// hc_class := class_tiger ;
99764: LD_ADDR_OWVAR 28
99768: PUSH
99769: LD_INT 14
99771: ST_TO_ADDR
// hc_gallery :=  ;
99772: LD_ADDR_OWVAR 33
99776: PUSH
99777: LD_STRING 
99779: ST_TO_ADDR
// hc_name :=  ;
99780: LD_ADDR_OWVAR 26
99784: PUSH
99785: LD_STRING 
99787: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99788: CALL_OW 44
99792: PPUSH
99793: LD_INT 0
99795: PPUSH
99796: CALL_OW 51
// end ;
99800: GO 99722
99802: POP
99803: POP
// end ;
99804: PPOPN 1
99806: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99807: LD_EXP 77
99811: PUSH
99812: LD_EXP 97
99816: AND
99817: IFFALSE 99826
99819: GO 99821
99821: DISABLE
// StreamSibBomb ;
99822: CALL 99827 0 0
99826: END
// export function StreamSibBomb ; var i , x , y ; begin
99827: LD_INT 0
99829: PPUSH
99830: PPUSH
99831: PPUSH
99832: PPUSH
// result := false ;
99833: LD_ADDR_VAR 0 1
99837: PUSH
99838: LD_INT 0
99840: ST_TO_ADDR
// for i := 1 to 16 do
99841: LD_ADDR_VAR 0 2
99845: PUSH
99846: DOUBLE
99847: LD_INT 1
99849: DEC
99850: ST_TO_ADDR
99851: LD_INT 16
99853: PUSH
99854: FOR_TO
99855: IFFALSE 100054
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99857: LD_ADDR_VAR 0 3
99861: PUSH
99862: LD_INT 10
99864: PUSH
99865: LD_INT 20
99867: PUSH
99868: LD_INT 30
99870: PUSH
99871: LD_INT 40
99873: PUSH
99874: LD_INT 50
99876: PUSH
99877: LD_INT 60
99879: PUSH
99880: LD_INT 70
99882: PUSH
99883: LD_INT 80
99885: PUSH
99886: LD_INT 90
99888: PUSH
99889: LD_INT 100
99891: PUSH
99892: LD_INT 110
99894: PUSH
99895: LD_INT 120
99897: PUSH
99898: LD_INT 130
99900: PUSH
99901: LD_INT 140
99903: PUSH
99904: LD_INT 150
99906: PUSH
99907: EMPTY
99908: LIST
99909: LIST
99910: LIST
99911: LIST
99912: LIST
99913: LIST
99914: LIST
99915: LIST
99916: LIST
99917: LIST
99918: LIST
99919: LIST
99920: LIST
99921: LIST
99922: LIST
99923: PUSH
99924: LD_INT 1
99926: PPUSH
99927: LD_INT 15
99929: PPUSH
99930: CALL_OW 12
99934: ARRAY
99935: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99936: LD_ADDR_VAR 0 4
99940: PUSH
99941: LD_INT 10
99943: PUSH
99944: LD_INT 20
99946: PUSH
99947: LD_INT 30
99949: PUSH
99950: LD_INT 40
99952: PUSH
99953: LD_INT 50
99955: PUSH
99956: LD_INT 60
99958: PUSH
99959: LD_INT 70
99961: PUSH
99962: LD_INT 80
99964: PUSH
99965: LD_INT 90
99967: PUSH
99968: LD_INT 100
99970: PUSH
99971: LD_INT 110
99973: PUSH
99974: LD_INT 120
99976: PUSH
99977: LD_INT 130
99979: PUSH
99980: LD_INT 140
99982: PUSH
99983: LD_INT 150
99985: PUSH
99986: EMPTY
99987: LIST
99988: LIST
99989: LIST
99990: LIST
99991: LIST
99992: LIST
99993: LIST
99994: LIST
99995: LIST
99996: LIST
99997: LIST
99998: LIST
99999: LIST
100000: LIST
100001: LIST
100002: PUSH
100003: LD_INT 1
100005: PPUSH
100006: LD_INT 15
100008: PPUSH
100009: CALL_OW 12
100013: ARRAY
100014: ST_TO_ADDR
// if ValidHex ( x , y ) then
100015: LD_VAR 0 3
100019: PPUSH
100020: LD_VAR 0 4
100024: PPUSH
100025: CALL_OW 488
100029: IFFALSE 100052
// begin result := [ x , y ] ;
100031: LD_ADDR_VAR 0 1
100035: PUSH
100036: LD_VAR 0 3
100040: PUSH
100041: LD_VAR 0 4
100045: PUSH
100046: EMPTY
100047: LIST
100048: LIST
100049: ST_TO_ADDR
// break ;
100050: GO 100054
// end ; end ;
100052: GO 99854
100054: POP
100055: POP
// if result then
100056: LD_VAR 0 1
100060: IFFALSE 100120
// begin ToLua ( playSibBomb() ) ;
100062: LD_STRING playSibBomb()
100064: PPUSH
100065: CALL_OW 559
// wait ( 0 0$14 ) ;
100069: LD_INT 490
100071: PPUSH
100072: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100076: LD_VAR 0 1
100080: PUSH
100081: LD_INT 1
100083: ARRAY
100084: PPUSH
100085: LD_VAR 0 1
100089: PUSH
100090: LD_INT 2
100092: ARRAY
100093: PPUSH
100094: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100098: LD_VAR 0 1
100102: PUSH
100103: LD_INT 1
100105: ARRAY
100106: PPUSH
100107: LD_VAR 0 1
100111: PUSH
100112: LD_INT 2
100114: ARRAY
100115: PPUSH
100116: CALL_OW 429
// end ; end ;
100120: LD_VAR 0 1
100124: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100125: LD_EXP 77
100129: PUSH
100130: LD_EXP 99
100134: AND
100135: IFFALSE 100147
100137: GO 100139
100139: DISABLE
// YouLost (  ) ;
100140: LD_STRING 
100142: PPUSH
100143: CALL_OW 104
100147: END
// every 0 0$1 trigger StreamModeActive and sFog do
100148: LD_EXP 77
100152: PUSH
100153: LD_EXP 98
100157: AND
100158: IFFALSE 100172
100160: GO 100162
100162: DISABLE
// FogOff ( your_side ) ;
100163: LD_OWVAR 2
100167: PPUSH
100168: CALL_OW 344
100172: END
// every 0 0$1 trigger StreamModeActive and sSun do
100173: LD_EXP 77
100177: PUSH
100178: LD_EXP 100
100182: AND
100183: IFFALSE 100211
100185: GO 100187
100187: DISABLE
// begin solar_recharge_percent := 0 ;
100188: LD_ADDR_OWVAR 79
100192: PUSH
100193: LD_INT 0
100195: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100196: LD_INT 10500
100198: PPUSH
100199: CALL_OW 67
// solar_recharge_percent := 100 ;
100203: LD_ADDR_OWVAR 79
100207: PUSH
100208: LD_INT 100
100210: ST_TO_ADDR
// end ;
100211: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100212: LD_EXP 77
100216: PUSH
100217: LD_EXP 101
100221: AND
100222: IFFALSE 100461
100224: GO 100226
100226: DISABLE
100227: LD_INT 0
100229: PPUSH
100230: PPUSH
100231: PPUSH
// begin tmp := [ ] ;
100232: LD_ADDR_VAR 0 3
100236: PUSH
100237: EMPTY
100238: ST_TO_ADDR
// for i := 1 to 6 do
100239: LD_ADDR_VAR 0 1
100243: PUSH
100244: DOUBLE
100245: LD_INT 1
100247: DEC
100248: ST_TO_ADDR
100249: LD_INT 6
100251: PUSH
100252: FOR_TO
100253: IFFALSE 100358
// begin uc_nation := nation_nature ;
100255: LD_ADDR_OWVAR 21
100259: PUSH
100260: LD_INT 0
100262: ST_TO_ADDR
// uc_side := 0 ;
100263: LD_ADDR_OWVAR 20
100267: PUSH
100268: LD_INT 0
100270: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100271: LD_ADDR_OWVAR 29
100275: PUSH
100276: LD_INT 12
100278: PUSH
100279: LD_INT 12
100281: PUSH
100282: EMPTY
100283: LIST
100284: LIST
100285: ST_TO_ADDR
// hc_agressivity := 20 ;
100286: LD_ADDR_OWVAR 35
100290: PUSH
100291: LD_INT 20
100293: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100294: LD_ADDR_OWVAR 28
100298: PUSH
100299: LD_INT 17
100301: ST_TO_ADDR
// hc_gallery :=  ;
100302: LD_ADDR_OWVAR 33
100306: PUSH
100307: LD_STRING 
100309: ST_TO_ADDR
// hc_name :=  ;
100310: LD_ADDR_OWVAR 26
100314: PUSH
100315: LD_STRING 
100317: ST_TO_ADDR
// un := CreateHuman ;
100318: LD_ADDR_VAR 0 2
100322: PUSH
100323: CALL_OW 44
100327: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100328: LD_VAR 0 2
100332: PPUSH
100333: LD_INT 1
100335: PPUSH
100336: CALL_OW 51
// tmp := tmp ^ un ;
100340: LD_ADDR_VAR 0 3
100344: PUSH
100345: LD_VAR 0 3
100349: PUSH
100350: LD_VAR 0 2
100354: ADD
100355: ST_TO_ADDR
// end ;
100356: GO 100252
100358: POP
100359: POP
// repeat wait ( 0 0$1 ) ;
100360: LD_INT 35
100362: PPUSH
100363: CALL_OW 67
// for un in tmp do
100367: LD_ADDR_VAR 0 2
100371: PUSH
100372: LD_VAR 0 3
100376: PUSH
100377: FOR_IN
100378: IFFALSE 100452
// begin if IsDead ( un ) then
100380: LD_VAR 0 2
100384: PPUSH
100385: CALL_OW 301
100389: IFFALSE 100409
// begin tmp := tmp diff un ;
100391: LD_ADDR_VAR 0 3
100395: PUSH
100396: LD_VAR 0 3
100400: PUSH
100401: LD_VAR 0 2
100405: DIFF
100406: ST_TO_ADDR
// continue ;
100407: GO 100377
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100409: LD_VAR 0 2
100413: PPUSH
100414: LD_INT 3
100416: PUSH
100417: LD_INT 22
100419: PUSH
100420: LD_INT 0
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: PUSH
100427: EMPTY
100428: LIST
100429: LIST
100430: PPUSH
100431: CALL_OW 69
100435: PPUSH
100436: LD_VAR 0 2
100440: PPUSH
100441: CALL_OW 74
100445: PPUSH
100446: CALL_OW 115
// end ;
100450: GO 100377
100452: POP
100453: POP
// until not tmp ;
100454: LD_VAR 0 3
100458: NOT
100459: IFFALSE 100360
// end ;
100461: PPOPN 3
100463: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100464: LD_EXP 77
100468: PUSH
100469: LD_EXP 102
100473: AND
100474: IFFALSE 100528
100476: GO 100478
100478: DISABLE
// begin ToLua ( displayTroll(); ) ;
100479: LD_STRING displayTroll();
100481: PPUSH
100482: CALL_OW 559
// wait ( 3 3$00 ) ;
100486: LD_INT 6300
100488: PPUSH
100489: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100493: LD_STRING hideTroll();
100495: PPUSH
100496: CALL_OW 559
// wait ( 1 1$00 ) ;
100500: LD_INT 2100
100502: PPUSH
100503: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100507: LD_STRING displayTroll();
100509: PPUSH
100510: CALL_OW 559
// wait ( 1 1$00 ) ;
100514: LD_INT 2100
100516: PPUSH
100517: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100521: LD_STRING hideTroll();
100523: PPUSH
100524: CALL_OW 559
// end ;
100528: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100529: LD_EXP 77
100533: PUSH
100534: LD_EXP 103
100538: AND
100539: IFFALSE 100602
100541: GO 100543
100543: DISABLE
100544: LD_INT 0
100546: PPUSH
// begin p := 0 ;
100547: LD_ADDR_VAR 0 1
100551: PUSH
100552: LD_INT 0
100554: ST_TO_ADDR
// repeat game_speed := 1 ;
100555: LD_ADDR_OWVAR 65
100559: PUSH
100560: LD_INT 1
100562: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100563: LD_INT 35
100565: PPUSH
100566: CALL_OW 67
// p := p + 1 ;
100570: LD_ADDR_VAR 0 1
100574: PUSH
100575: LD_VAR 0 1
100579: PUSH
100580: LD_INT 1
100582: PLUS
100583: ST_TO_ADDR
// until p >= 60 ;
100584: LD_VAR 0 1
100588: PUSH
100589: LD_INT 60
100591: GREATEREQUAL
100592: IFFALSE 100555
// game_speed := 4 ;
100594: LD_ADDR_OWVAR 65
100598: PUSH
100599: LD_INT 4
100601: ST_TO_ADDR
// end ;
100602: PPOPN 1
100604: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100605: LD_EXP 77
100609: PUSH
100610: LD_EXP 104
100614: AND
100615: IFFALSE 100761
100617: GO 100619
100619: DISABLE
100620: LD_INT 0
100622: PPUSH
100623: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100624: LD_ADDR_VAR 0 1
100628: PUSH
100629: LD_INT 22
100631: PUSH
100632: LD_OWVAR 2
100636: PUSH
100637: EMPTY
100638: LIST
100639: LIST
100640: PUSH
100641: LD_INT 2
100643: PUSH
100644: LD_INT 30
100646: PUSH
100647: LD_INT 0
100649: PUSH
100650: EMPTY
100651: LIST
100652: LIST
100653: PUSH
100654: LD_INT 30
100656: PUSH
100657: LD_INT 1
100659: PUSH
100660: EMPTY
100661: LIST
100662: LIST
100663: PUSH
100664: EMPTY
100665: LIST
100666: LIST
100667: LIST
100668: PUSH
100669: EMPTY
100670: LIST
100671: LIST
100672: PPUSH
100673: CALL_OW 69
100677: ST_TO_ADDR
// if not depot then
100678: LD_VAR 0 1
100682: NOT
100683: IFFALSE 100687
// exit ;
100685: GO 100761
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100687: LD_ADDR_VAR 0 2
100691: PUSH
100692: LD_VAR 0 1
100696: PUSH
100697: LD_INT 1
100699: PPUSH
100700: LD_VAR 0 1
100704: PPUSH
100705: CALL_OW 12
100709: ARRAY
100710: PPUSH
100711: CALL_OW 274
100715: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100716: LD_VAR 0 2
100720: PPUSH
100721: LD_INT 1
100723: PPUSH
100724: LD_INT 0
100726: PPUSH
100727: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100731: LD_VAR 0 2
100735: PPUSH
100736: LD_INT 2
100738: PPUSH
100739: LD_INT 0
100741: PPUSH
100742: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100746: LD_VAR 0 2
100750: PPUSH
100751: LD_INT 3
100753: PPUSH
100754: LD_INT 0
100756: PPUSH
100757: CALL_OW 277
// end ;
100761: PPOPN 2
100763: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100764: LD_EXP 77
100768: PUSH
100769: LD_EXP 105
100773: AND
100774: IFFALSE 100871
100776: GO 100778
100778: DISABLE
100779: LD_INT 0
100781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100782: LD_ADDR_VAR 0 1
100786: PUSH
100787: LD_INT 22
100789: PUSH
100790: LD_OWVAR 2
100794: PUSH
100795: EMPTY
100796: LIST
100797: LIST
100798: PUSH
100799: LD_INT 21
100801: PUSH
100802: LD_INT 1
100804: PUSH
100805: EMPTY
100806: LIST
100807: LIST
100808: PUSH
100809: LD_INT 3
100811: PUSH
100812: LD_INT 23
100814: PUSH
100815: LD_INT 0
100817: PUSH
100818: EMPTY
100819: LIST
100820: LIST
100821: PUSH
100822: EMPTY
100823: LIST
100824: LIST
100825: PUSH
100826: EMPTY
100827: LIST
100828: LIST
100829: LIST
100830: PPUSH
100831: CALL_OW 69
100835: ST_TO_ADDR
// if not tmp then
100836: LD_VAR 0 1
100840: NOT
100841: IFFALSE 100845
// exit ;
100843: GO 100871
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100845: LD_VAR 0 1
100849: PUSH
100850: LD_INT 1
100852: PPUSH
100853: LD_VAR 0 1
100857: PPUSH
100858: CALL_OW 12
100862: ARRAY
100863: PPUSH
100864: LD_INT 200
100866: PPUSH
100867: CALL_OW 234
// end ;
100871: PPOPN 1
100873: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100874: LD_EXP 77
100878: PUSH
100879: LD_EXP 106
100883: AND
100884: IFFALSE 100963
100886: GO 100888
100888: DISABLE
100889: LD_INT 0
100891: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100892: LD_ADDR_VAR 0 1
100896: PUSH
100897: LD_INT 22
100899: PUSH
100900: LD_OWVAR 2
100904: PUSH
100905: EMPTY
100906: LIST
100907: LIST
100908: PUSH
100909: LD_INT 21
100911: PUSH
100912: LD_INT 2
100914: PUSH
100915: EMPTY
100916: LIST
100917: LIST
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: PPUSH
100923: CALL_OW 69
100927: ST_TO_ADDR
// if not tmp then
100928: LD_VAR 0 1
100932: NOT
100933: IFFALSE 100937
// exit ;
100935: GO 100963
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100937: LD_VAR 0 1
100941: PUSH
100942: LD_INT 1
100944: PPUSH
100945: LD_VAR 0 1
100949: PPUSH
100950: CALL_OW 12
100954: ARRAY
100955: PPUSH
100956: LD_INT 60
100958: PPUSH
100959: CALL_OW 234
// end ;
100963: PPOPN 1
100965: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100966: LD_EXP 77
100970: PUSH
100971: LD_EXP 107
100975: AND
100976: IFFALSE 101075
100978: GO 100980
100980: DISABLE
100981: LD_INT 0
100983: PPUSH
100984: PPUSH
// begin enable ;
100985: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100986: LD_ADDR_VAR 0 1
100990: PUSH
100991: LD_INT 22
100993: PUSH
100994: LD_OWVAR 2
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: PUSH
101003: LD_INT 61
101005: PUSH
101006: EMPTY
101007: LIST
101008: PUSH
101009: LD_INT 33
101011: PUSH
101012: LD_INT 2
101014: PUSH
101015: EMPTY
101016: LIST
101017: LIST
101018: PUSH
101019: EMPTY
101020: LIST
101021: LIST
101022: LIST
101023: PPUSH
101024: CALL_OW 69
101028: ST_TO_ADDR
// if not tmp then
101029: LD_VAR 0 1
101033: NOT
101034: IFFALSE 101038
// exit ;
101036: GO 101075
// for i in tmp do
101038: LD_ADDR_VAR 0 2
101042: PUSH
101043: LD_VAR 0 1
101047: PUSH
101048: FOR_IN
101049: IFFALSE 101073
// if IsControledBy ( i ) then
101051: LD_VAR 0 2
101055: PPUSH
101056: CALL_OW 312
101060: IFFALSE 101071
// ComUnlink ( i ) ;
101062: LD_VAR 0 2
101066: PPUSH
101067: CALL_OW 136
101071: GO 101048
101073: POP
101074: POP
// end ;
101075: PPOPN 2
101077: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101078: LD_EXP 77
101082: PUSH
101083: LD_EXP 108
101087: AND
101088: IFFALSE 101228
101090: GO 101092
101092: DISABLE
101093: LD_INT 0
101095: PPUSH
101096: PPUSH
// begin ToLua ( displayPowell(); ) ;
101097: LD_STRING displayPowell();
101099: PPUSH
101100: CALL_OW 559
// uc_side := 0 ;
101104: LD_ADDR_OWVAR 20
101108: PUSH
101109: LD_INT 0
101111: ST_TO_ADDR
// uc_nation := 2 ;
101112: LD_ADDR_OWVAR 21
101116: PUSH
101117: LD_INT 2
101119: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101120: LD_ADDR_OWVAR 37
101124: PUSH
101125: LD_INT 14
101127: ST_TO_ADDR
// vc_engine := engine_siberite ;
101128: LD_ADDR_OWVAR 39
101132: PUSH
101133: LD_INT 3
101135: ST_TO_ADDR
// vc_control := control_apeman ;
101136: LD_ADDR_OWVAR 38
101140: PUSH
101141: LD_INT 5
101143: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101144: LD_ADDR_OWVAR 40
101148: PUSH
101149: LD_INT 29
101151: ST_TO_ADDR
// un := CreateVehicle ;
101152: LD_ADDR_VAR 0 2
101156: PUSH
101157: CALL_OW 45
101161: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101162: LD_VAR 0 2
101166: PPUSH
101167: LD_INT 1
101169: PPUSH
101170: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101174: LD_INT 35
101176: PPUSH
101177: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101181: LD_VAR 0 2
101185: PPUSH
101186: LD_INT 22
101188: PUSH
101189: LD_OWVAR 2
101193: PUSH
101194: EMPTY
101195: LIST
101196: LIST
101197: PPUSH
101198: CALL_OW 69
101202: PPUSH
101203: LD_VAR 0 2
101207: PPUSH
101208: CALL_OW 74
101212: PPUSH
101213: CALL_OW 115
// until IsDead ( un ) ;
101217: LD_VAR 0 2
101221: PPUSH
101222: CALL_OW 301
101226: IFFALSE 101174
// end ;
101228: PPOPN 2
101230: END
// every 0 0$1 trigger StreamModeActive and sStu do
101231: LD_EXP 77
101235: PUSH
101236: LD_EXP 116
101240: AND
101241: IFFALSE 101257
101243: GO 101245
101245: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101246: LD_STRING displayStucuk();
101248: PPUSH
101249: CALL_OW 559
// ResetFog ;
101253: CALL_OW 335
// end ;
101257: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101258: LD_EXP 77
101262: PUSH
101263: LD_EXP 109
101267: AND
101268: IFFALSE 101409
101270: GO 101272
101272: DISABLE
101273: LD_INT 0
101275: PPUSH
101276: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101277: LD_ADDR_VAR 0 2
101281: PUSH
101282: LD_INT 22
101284: PUSH
101285: LD_OWVAR 2
101289: PUSH
101290: EMPTY
101291: LIST
101292: LIST
101293: PUSH
101294: LD_INT 21
101296: PUSH
101297: LD_INT 1
101299: PUSH
101300: EMPTY
101301: LIST
101302: LIST
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: PPUSH
101308: CALL_OW 69
101312: ST_TO_ADDR
// if not tmp then
101313: LD_VAR 0 2
101317: NOT
101318: IFFALSE 101322
// exit ;
101320: GO 101409
// un := tmp [ rand ( 1 , tmp ) ] ;
101322: LD_ADDR_VAR 0 1
101326: PUSH
101327: LD_VAR 0 2
101331: PUSH
101332: LD_INT 1
101334: PPUSH
101335: LD_VAR 0 2
101339: PPUSH
101340: CALL_OW 12
101344: ARRAY
101345: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101346: LD_VAR 0 1
101350: PPUSH
101351: LD_INT 0
101353: PPUSH
101354: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101358: LD_VAR 0 1
101362: PPUSH
101363: LD_OWVAR 3
101367: PUSH
101368: LD_VAR 0 1
101372: DIFF
101373: PPUSH
101374: LD_VAR 0 1
101378: PPUSH
101379: CALL_OW 74
101383: PPUSH
101384: CALL_OW 115
// wait ( 0 0$20 ) ;
101388: LD_INT 700
101390: PPUSH
101391: CALL_OW 67
// SetSide ( un , your_side ) ;
101395: LD_VAR 0 1
101399: PPUSH
101400: LD_OWVAR 2
101404: PPUSH
101405: CALL_OW 235
// end ;
101409: PPOPN 2
101411: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101412: LD_EXP 77
101416: PUSH
101417: LD_EXP 110
101421: AND
101422: IFFALSE 101528
101424: GO 101426
101426: DISABLE
101427: LD_INT 0
101429: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101430: LD_ADDR_VAR 0 1
101434: PUSH
101435: LD_INT 22
101437: PUSH
101438: LD_OWVAR 2
101442: PUSH
101443: EMPTY
101444: LIST
101445: LIST
101446: PUSH
101447: LD_INT 2
101449: PUSH
101450: LD_INT 30
101452: PUSH
101453: LD_INT 0
101455: PUSH
101456: EMPTY
101457: LIST
101458: LIST
101459: PUSH
101460: LD_INT 30
101462: PUSH
101463: LD_INT 1
101465: PUSH
101466: EMPTY
101467: LIST
101468: LIST
101469: PUSH
101470: EMPTY
101471: LIST
101472: LIST
101473: LIST
101474: PUSH
101475: EMPTY
101476: LIST
101477: LIST
101478: PPUSH
101479: CALL_OW 69
101483: ST_TO_ADDR
// if not depot then
101484: LD_VAR 0 1
101488: NOT
101489: IFFALSE 101493
// exit ;
101491: GO 101528
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101493: LD_VAR 0 1
101497: PUSH
101498: LD_INT 1
101500: ARRAY
101501: PPUSH
101502: CALL_OW 250
101506: PPUSH
101507: LD_VAR 0 1
101511: PUSH
101512: LD_INT 1
101514: ARRAY
101515: PPUSH
101516: CALL_OW 251
101520: PPUSH
101521: LD_INT 70
101523: PPUSH
101524: CALL_OW 495
// end ;
101528: PPOPN 1
101530: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101531: LD_EXP 77
101535: PUSH
101536: LD_EXP 111
101540: AND
101541: IFFALSE 101752
101543: GO 101545
101545: DISABLE
101546: LD_INT 0
101548: PPUSH
101549: PPUSH
101550: PPUSH
101551: PPUSH
101552: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101553: LD_ADDR_VAR 0 5
101557: PUSH
101558: LD_INT 22
101560: PUSH
101561: LD_OWVAR 2
101565: PUSH
101566: EMPTY
101567: LIST
101568: LIST
101569: PUSH
101570: LD_INT 21
101572: PUSH
101573: LD_INT 1
101575: PUSH
101576: EMPTY
101577: LIST
101578: LIST
101579: PUSH
101580: EMPTY
101581: LIST
101582: LIST
101583: PPUSH
101584: CALL_OW 69
101588: ST_TO_ADDR
// if not tmp then
101589: LD_VAR 0 5
101593: NOT
101594: IFFALSE 101598
// exit ;
101596: GO 101752
// for i in tmp do
101598: LD_ADDR_VAR 0 1
101602: PUSH
101603: LD_VAR 0 5
101607: PUSH
101608: FOR_IN
101609: IFFALSE 101750
// begin d := rand ( 0 , 5 ) ;
101611: LD_ADDR_VAR 0 4
101615: PUSH
101616: LD_INT 0
101618: PPUSH
101619: LD_INT 5
101621: PPUSH
101622: CALL_OW 12
101626: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101627: LD_ADDR_VAR 0 2
101631: PUSH
101632: LD_VAR 0 1
101636: PPUSH
101637: CALL_OW 250
101641: PPUSH
101642: LD_VAR 0 4
101646: PPUSH
101647: LD_INT 3
101649: PPUSH
101650: LD_INT 12
101652: PPUSH
101653: CALL_OW 12
101657: PPUSH
101658: CALL_OW 272
101662: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101663: LD_ADDR_VAR 0 3
101667: PUSH
101668: LD_VAR 0 1
101672: PPUSH
101673: CALL_OW 251
101677: PPUSH
101678: LD_VAR 0 4
101682: PPUSH
101683: LD_INT 3
101685: PPUSH
101686: LD_INT 12
101688: PPUSH
101689: CALL_OW 12
101693: PPUSH
101694: CALL_OW 273
101698: ST_TO_ADDR
// if ValidHex ( x , y ) then
101699: LD_VAR 0 2
101703: PPUSH
101704: LD_VAR 0 3
101708: PPUSH
101709: CALL_OW 488
101713: IFFALSE 101748
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101715: LD_VAR 0 1
101719: PPUSH
101720: LD_VAR 0 2
101724: PPUSH
101725: LD_VAR 0 3
101729: PPUSH
101730: LD_INT 3
101732: PPUSH
101733: LD_INT 6
101735: PPUSH
101736: CALL_OW 12
101740: PPUSH
101741: LD_INT 1
101743: PPUSH
101744: CALL_OW 483
// end ;
101748: GO 101608
101750: POP
101751: POP
// end ;
101752: PPOPN 5
101754: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101755: LD_EXP 77
101759: PUSH
101760: LD_EXP 112
101764: AND
101765: IFFALSE 101859
101767: GO 101769
101769: DISABLE
101770: LD_INT 0
101772: PPUSH
101773: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101774: LD_ADDR_VAR 0 2
101778: PUSH
101779: LD_INT 22
101781: PUSH
101782: LD_OWVAR 2
101786: PUSH
101787: EMPTY
101788: LIST
101789: LIST
101790: PUSH
101791: LD_INT 32
101793: PUSH
101794: LD_INT 1
101796: PUSH
101797: EMPTY
101798: LIST
101799: LIST
101800: PUSH
101801: LD_INT 21
101803: PUSH
101804: LD_INT 2
101806: PUSH
101807: EMPTY
101808: LIST
101809: LIST
101810: PUSH
101811: EMPTY
101812: LIST
101813: LIST
101814: LIST
101815: PPUSH
101816: CALL_OW 69
101820: ST_TO_ADDR
// if not tmp then
101821: LD_VAR 0 2
101825: NOT
101826: IFFALSE 101830
// exit ;
101828: GO 101859
// for i in tmp do
101830: LD_ADDR_VAR 0 1
101834: PUSH
101835: LD_VAR 0 2
101839: PUSH
101840: FOR_IN
101841: IFFALSE 101857
// SetFuel ( i , 0 ) ;
101843: LD_VAR 0 1
101847: PPUSH
101848: LD_INT 0
101850: PPUSH
101851: CALL_OW 240
101855: GO 101840
101857: POP
101858: POP
// end ;
101859: PPOPN 2
101861: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101862: LD_EXP 77
101866: PUSH
101867: LD_EXP 113
101871: AND
101872: IFFALSE 101938
101874: GO 101876
101876: DISABLE
101877: LD_INT 0
101879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101880: LD_ADDR_VAR 0 1
101884: PUSH
101885: LD_INT 22
101887: PUSH
101888: LD_OWVAR 2
101892: PUSH
101893: EMPTY
101894: LIST
101895: LIST
101896: PUSH
101897: LD_INT 30
101899: PUSH
101900: LD_INT 29
101902: PUSH
101903: EMPTY
101904: LIST
101905: LIST
101906: PUSH
101907: EMPTY
101908: LIST
101909: LIST
101910: PPUSH
101911: CALL_OW 69
101915: ST_TO_ADDR
// if not tmp then
101916: LD_VAR 0 1
101920: NOT
101921: IFFALSE 101925
// exit ;
101923: GO 101938
// DestroyUnit ( tmp [ 1 ] ) ;
101925: LD_VAR 0 1
101929: PUSH
101930: LD_INT 1
101932: ARRAY
101933: PPUSH
101934: CALL_OW 65
// end ;
101938: PPOPN 1
101940: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101941: LD_EXP 77
101945: PUSH
101946: LD_EXP 115
101950: AND
101951: IFFALSE 102080
101953: GO 101955
101955: DISABLE
101956: LD_INT 0
101958: PPUSH
// begin uc_side := 0 ;
101959: LD_ADDR_OWVAR 20
101963: PUSH
101964: LD_INT 0
101966: ST_TO_ADDR
// uc_nation := nation_arabian ;
101967: LD_ADDR_OWVAR 21
101971: PUSH
101972: LD_INT 2
101974: ST_TO_ADDR
// hc_gallery :=  ;
101975: LD_ADDR_OWVAR 33
101979: PUSH
101980: LD_STRING 
101982: ST_TO_ADDR
// hc_name :=  ;
101983: LD_ADDR_OWVAR 26
101987: PUSH
101988: LD_STRING 
101990: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101991: LD_INT 1
101993: PPUSH
101994: LD_INT 11
101996: PPUSH
101997: LD_INT 10
101999: PPUSH
102000: CALL_OW 380
// un := CreateHuman ;
102004: LD_ADDR_VAR 0 1
102008: PUSH
102009: CALL_OW 44
102013: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102014: LD_VAR 0 1
102018: PPUSH
102019: LD_INT 1
102021: PPUSH
102022: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102026: LD_INT 35
102028: PPUSH
102029: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102033: LD_VAR 0 1
102037: PPUSH
102038: LD_INT 22
102040: PUSH
102041: LD_OWVAR 2
102045: PUSH
102046: EMPTY
102047: LIST
102048: LIST
102049: PPUSH
102050: CALL_OW 69
102054: PPUSH
102055: LD_VAR 0 1
102059: PPUSH
102060: CALL_OW 74
102064: PPUSH
102065: CALL_OW 115
// until IsDead ( un ) ;
102069: LD_VAR 0 1
102073: PPUSH
102074: CALL_OW 301
102078: IFFALSE 102026
// end ;
102080: PPOPN 1
102082: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102083: LD_EXP 77
102087: PUSH
102088: LD_EXP 117
102092: AND
102093: IFFALSE 102105
102095: GO 102097
102097: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102098: LD_STRING earthquake(getX(game), 0, 32)
102100: PPUSH
102101: CALL_OW 559
102105: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102106: LD_EXP 77
102110: PUSH
102111: LD_EXP 118
102115: AND
102116: IFFALSE 102207
102118: GO 102120
102120: DISABLE
102121: LD_INT 0
102123: PPUSH
// begin enable ;
102124: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102125: LD_ADDR_VAR 0 1
102129: PUSH
102130: LD_INT 22
102132: PUSH
102133: LD_OWVAR 2
102137: PUSH
102138: EMPTY
102139: LIST
102140: LIST
102141: PUSH
102142: LD_INT 21
102144: PUSH
102145: LD_INT 2
102147: PUSH
102148: EMPTY
102149: LIST
102150: LIST
102151: PUSH
102152: LD_INT 33
102154: PUSH
102155: LD_INT 3
102157: PUSH
102158: EMPTY
102159: LIST
102160: LIST
102161: PUSH
102162: EMPTY
102163: LIST
102164: LIST
102165: LIST
102166: PPUSH
102167: CALL_OW 69
102171: ST_TO_ADDR
// if not tmp then
102172: LD_VAR 0 1
102176: NOT
102177: IFFALSE 102181
// exit ;
102179: GO 102207
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102181: LD_VAR 0 1
102185: PUSH
102186: LD_INT 1
102188: PPUSH
102189: LD_VAR 0 1
102193: PPUSH
102194: CALL_OW 12
102198: ARRAY
102199: PPUSH
102200: LD_INT 1
102202: PPUSH
102203: CALL_OW 234
// end ;
102207: PPOPN 1
102209: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102210: LD_EXP 77
102214: PUSH
102215: LD_EXP 119
102219: AND
102220: IFFALSE 102361
102222: GO 102224
102224: DISABLE
102225: LD_INT 0
102227: PPUSH
102228: PPUSH
102229: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102230: LD_ADDR_VAR 0 3
102234: PUSH
102235: LD_INT 22
102237: PUSH
102238: LD_OWVAR 2
102242: PUSH
102243: EMPTY
102244: LIST
102245: LIST
102246: PUSH
102247: LD_INT 25
102249: PUSH
102250: LD_INT 1
102252: PUSH
102253: EMPTY
102254: LIST
102255: LIST
102256: PUSH
102257: EMPTY
102258: LIST
102259: LIST
102260: PPUSH
102261: CALL_OW 69
102265: ST_TO_ADDR
// if not tmp then
102266: LD_VAR 0 3
102270: NOT
102271: IFFALSE 102275
// exit ;
102273: GO 102361
// un := tmp [ rand ( 1 , tmp ) ] ;
102275: LD_ADDR_VAR 0 2
102279: PUSH
102280: LD_VAR 0 3
102284: PUSH
102285: LD_INT 1
102287: PPUSH
102288: LD_VAR 0 3
102292: PPUSH
102293: CALL_OW 12
102297: ARRAY
102298: ST_TO_ADDR
// if Crawls ( un ) then
102299: LD_VAR 0 2
102303: PPUSH
102304: CALL_OW 318
102308: IFFALSE 102319
// ComWalk ( un ) ;
102310: LD_VAR 0 2
102314: PPUSH
102315: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102319: LD_VAR 0 2
102323: PPUSH
102324: LD_INT 9
102326: PPUSH
102327: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102331: LD_INT 28
102333: PPUSH
102334: LD_OWVAR 2
102338: PPUSH
102339: LD_INT 2
102341: PPUSH
102342: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102346: LD_INT 29
102348: PPUSH
102349: LD_OWVAR 2
102353: PPUSH
102354: LD_INT 2
102356: PPUSH
102357: CALL_OW 322
// end ;
102361: PPOPN 3
102363: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102364: LD_EXP 77
102368: PUSH
102369: LD_EXP 120
102373: AND
102374: IFFALSE 102485
102376: GO 102378
102378: DISABLE
102379: LD_INT 0
102381: PPUSH
102382: PPUSH
102383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102384: LD_ADDR_VAR 0 3
102388: PUSH
102389: LD_INT 22
102391: PUSH
102392: LD_OWVAR 2
102396: PUSH
102397: EMPTY
102398: LIST
102399: LIST
102400: PUSH
102401: LD_INT 25
102403: PUSH
102404: LD_INT 1
102406: PUSH
102407: EMPTY
102408: LIST
102409: LIST
102410: PUSH
102411: EMPTY
102412: LIST
102413: LIST
102414: PPUSH
102415: CALL_OW 69
102419: ST_TO_ADDR
// if not tmp then
102420: LD_VAR 0 3
102424: NOT
102425: IFFALSE 102429
// exit ;
102427: GO 102485
// un := tmp [ rand ( 1 , tmp ) ] ;
102429: LD_ADDR_VAR 0 2
102433: PUSH
102434: LD_VAR 0 3
102438: PUSH
102439: LD_INT 1
102441: PPUSH
102442: LD_VAR 0 3
102446: PPUSH
102447: CALL_OW 12
102451: ARRAY
102452: ST_TO_ADDR
// if Crawls ( un ) then
102453: LD_VAR 0 2
102457: PPUSH
102458: CALL_OW 318
102462: IFFALSE 102473
// ComWalk ( un ) ;
102464: LD_VAR 0 2
102468: PPUSH
102469: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102473: LD_VAR 0 2
102477: PPUSH
102478: LD_INT 8
102480: PPUSH
102481: CALL_OW 336
// end ;
102485: PPOPN 3
102487: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102488: LD_EXP 77
102492: PUSH
102493: LD_EXP 121
102497: AND
102498: IFFALSE 102642
102500: GO 102502
102502: DISABLE
102503: LD_INT 0
102505: PPUSH
102506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102507: LD_ADDR_VAR 0 2
102511: PUSH
102512: LD_INT 22
102514: PUSH
102515: LD_OWVAR 2
102519: PUSH
102520: EMPTY
102521: LIST
102522: LIST
102523: PUSH
102524: LD_INT 21
102526: PUSH
102527: LD_INT 2
102529: PUSH
102530: EMPTY
102531: LIST
102532: LIST
102533: PUSH
102534: LD_INT 2
102536: PUSH
102537: LD_INT 34
102539: PUSH
102540: LD_INT 12
102542: PUSH
102543: EMPTY
102544: LIST
102545: LIST
102546: PUSH
102547: LD_INT 34
102549: PUSH
102550: LD_INT 51
102552: PUSH
102553: EMPTY
102554: LIST
102555: LIST
102556: PUSH
102557: LD_INT 34
102559: PUSH
102560: LD_INT 32
102562: PUSH
102563: EMPTY
102564: LIST
102565: LIST
102566: PUSH
102567: EMPTY
102568: LIST
102569: LIST
102570: LIST
102571: LIST
102572: PUSH
102573: EMPTY
102574: LIST
102575: LIST
102576: LIST
102577: PPUSH
102578: CALL_OW 69
102582: ST_TO_ADDR
// if not tmp then
102583: LD_VAR 0 2
102587: NOT
102588: IFFALSE 102592
// exit ;
102590: GO 102642
// for i in tmp do
102592: LD_ADDR_VAR 0 1
102596: PUSH
102597: LD_VAR 0 2
102601: PUSH
102602: FOR_IN
102603: IFFALSE 102640
// if GetCargo ( i , mat_artifact ) = 0 then
102605: LD_VAR 0 1
102609: PPUSH
102610: LD_INT 4
102612: PPUSH
102613: CALL_OW 289
102617: PUSH
102618: LD_INT 0
102620: EQUAL
102621: IFFALSE 102638
// SetCargo ( i , mat_siberit , 100 ) ;
102623: LD_VAR 0 1
102627: PPUSH
102628: LD_INT 3
102630: PPUSH
102631: LD_INT 100
102633: PPUSH
102634: CALL_OW 290
102638: GO 102602
102640: POP
102641: POP
// end ;
102642: PPOPN 2
102644: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102645: LD_EXP 77
102649: PUSH
102650: LD_EXP 122
102654: AND
102655: IFFALSE 102838
102657: GO 102659
102659: DISABLE
102660: LD_INT 0
102662: PPUSH
102663: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102664: LD_ADDR_VAR 0 2
102668: PUSH
102669: LD_INT 22
102671: PUSH
102672: LD_OWVAR 2
102676: PUSH
102677: EMPTY
102678: LIST
102679: LIST
102680: PPUSH
102681: CALL_OW 69
102685: ST_TO_ADDR
// if not tmp then
102686: LD_VAR 0 2
102690: NOT
102691: IFFALSE 102695
// exit ;
102693: GO 102838
// for i := 1 to 2 do
102695: LD_ADDR_VAR 0 1
102699: PUSH
102700: DOUBLE
102701: LD_INT 1
102703: DEC
102704: ST_TO_ADDR
102705: LD_INT 2
102707: PUSH
102708: FOR_TO
102709: IFFALSE 102836
// begin uc_side := your_side ;
102711: LD_ADDR_OWVAR 20
102715: PUSH
102716: LD_OWVAR 2
102720: ST_TO_ADDR
// uc_nation := nation_american ;
102721: LD_ADDR_OWVAR 21
102725: PUSH
102726: LD_INT 1
102728: ST_TO_ADDR
// vc_chassis := us_morphling ;
102729: LD_ADDR_OWVAR 37
102733: PUSH
102734: LD_INT 5
102736: ST_TO_ADDR
// vc_engine := engine_siberite ;
102737: LD_ADDR_OWVAR 39
102741: PUSH
102742: LD_INT 3
102744: ST_TO_ADDR
// vc_control := control_computer ;
102745: LD_ADDR_OWVAR 38
102749: PUSH
102750: LD_INT 3
102752: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102753: LD_ADDR_OWVAR 40
102757: PUSH
102758: LD_INT 10
102760: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102761: LD_VAR 0 2
102765: PUSH
102766: LD_INT 1
102768: ARRAY
102769: PPUSH
102770: CALL_OW 310
102774: NOT
102775: IFFALSE 102822
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102777: CALL_OW 45
102781: PPUSH
102782: LD_VAR 0 2
102786: PUSH
102787: LD_INT 1
102789: ARRAY
102790: PPUSH
102791: CALL_OW 250
102795: PPUSH
102796: LD_VAR 0 2
102800: PUSH
102801: LD_INT 1
102803: ARRAY
102804: PPUSH
102805: CALL_OW 251
102809: PPUSH
102810: LD_INT 12
102812: PPUSH
102813: LD_INT 1
102815: PPUSH
102816: CALL_OW 50
102820: GO 102834
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102822: CALL_OW 45
102826: PPUSH
102827: LD_INT 1
102829: PPUSH
102830: CALL_OW 51
// end ;
102834: GO 102708
102836: POP
102837: POP
// end ;
102838: PPOPN 2
102840: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102841: LD_EXP 77
102845: PUSH
102846: LD_EXP 123
102850: AND
102851: IFFALSE 103073
102853: GO 102855
102855: DISABLE
102856: LD_INT 0
102858: PPUSH
102859: PPUSH
102860: PPUSH
102861: PPUSH
102862: PPUSH
102863: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102864: LD_ADDR_VAR 0 6
102868: PUSH
102869: LD_INT 22
102871: PUSH
102872: LD_OWVAR 2
102876: PUSH
102877: EMPTY
102878: LIST
102879: LIST
102880: PUSH
102881: LD_INT 21
102883: PUSH
102884: LD_INT 1
102886: PUSH
102887: EMPTY
102888: LIST
102889: LIST
102890: PUSH
102891: LD_INT 3
102893: PUSH
102894: LD_INT 23
102896: PUSH
102897: LD_INT 0
102899: PUSH
102900: EMPTY
102901: LIST
102902: LIST
102903: PUSH
102904: EMPTY
102905: LIST
102906: LIST
102907: PUSH
102908: EMPTY
102909: LIST
102910: LIST
102911: LIST
102912: PPUSH
102913: CALL_OW 69
102917: ST_TO_ADDR
// if not tmp then
102918: LD_VAR 0 6
102922: NOT
102923: IFFALSE 102927
// exit ;
102925: GO 103073
// s1 := rand ( 1 , 4 ) ;
102927: LD_ADDR_VAR 0 2
102931: PUSH
102932: LD_INT 1
102934: PPUSH
102935: LD_INT 4
102937: PPUSH
102938: CALL_OW 12
102942: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102943: LD_ADDR_VAR 0 4
102947: PUSH
102948: LD_VAR 0 6
102952: PUSH
102953: LD_INT 1
102955: ARRAY
102956: PPUSH
102957: LD_VAR 0 2
102961: PPUSH
102962: CALL_OW 259
102966: ST_TO_ADDR
// if s1 = 1 then
102967: LD_VAR 0 2
102971: PUSH
102972: LD_INT 1
102974: EQUAL
102975: IFFALSE 102995
// s2 := rand ( 2 , 4 ) else
102977: LD_ADDR_VAR 0 3
102981: PUSH
102982: LD_INT 2
102984: PPUSH
102985: LD_INT 4
102987: PPUSH
102988: CALL_OW 12
102992: ST_TO_ADDR
102993: GO 103003
// s2 := 1 ;
102995: LD_ADDR_VAR 0 3
102999: PUSH
103000: LD_INT 1
103002: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103003: LD_ADDR_VAR 0 5
103007: PUSH
103008: LD_VAR 0 6
103012: PUSH
103013: LD_INT 1
103015: ARRAY
103016: PPUSH
103017: LD_VAR 0 3
103021: PPUSH
103022: CALL_OW 259
103026: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103027: LD_VAR 0 6
103031: PUSH
103032: LD_INT 1
103034: ARRAY
103035: PPUSH
103036: LD_VAR 0 2
103040: PPUSH
103041: LD_VAR 0 5
103045: PPUSH
103046: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103050: LD_VAR 0 6
103054: PUSH
103055: LD_INT 1
103057: ARRAY
103058: PPUSH
103059: LD_VAR 0 3
103063: PPUSH
103064: LD_VAR 0 4
103068: PPUSH
103069: CALL_OW 237
// end ;
103073: PPOPN 6
103075: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103076: LD_EXP 77
103080: PUSH
103081: LD_EXP 124
103085: AND
103086: IFFALSE 103165
103088: GO 103090
103090: DISABLE
103091: LD_INT 0
103093: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103094: LD_ADDR_VAR 0 1
103098: PUSH
103099: LD_INT 22
103101: PUSH
103102: LD_OWVAR 2
103106: PUSH
103107: EMPTY
103108: LIST
103109: LIST
103110: PUSH
103111: LD_INT 30
103113: PUSH
103114: LD_INT 3
103116: PUSH
103117: EMPTY
103118: LIST
103119: LIST
103120: PUSH
103121: EMPTY
103122: LIST
103123: LIST
103124: PPUSH
103125: CALL_OW 69
103129: ST_TO_ADDR
// if not tmp then
103130: LD_VAR 0 1
103134: NOT
103135: IFFALSE 103139
// exit ;
103137: GO 103165
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103139: LD_VAR 0 1
103143: PUSH
103144: LD_INT 1
103146: PPUSH
103147: LD_VAR 0 1
103151: PPUSH
103152: CALL_OW 12
103156: ARRAY
103157: PPUSH
103158: LD_INT 1
103160: PPUSH
103161: CALL_OW 234
// end ;
103165: PPOPN 1
103167: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103168: LD_EXP 77
103172: PUSH
103173: LD_EXP 125
103177: AND
103178: IFFALSE 103290
103180: GO 103182
103182: DISABLE
103183: LD_INT 0
103185: PPUSH
103186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103187: LD_ADDR_VAR 0 2
103191: PUSH
103192: LD_INT 22
103194: PUSH
103195: LD_OWVAR 2
103199: PUSH
103200: EMPTY
103201: LIST
103202: LIST
103203: PUSH
103204: LD_INT 2
103206: PUSH
103207: LD_INT 30
103209: PUSH
103210: LD_INT 27
103212: PUSH
103213: EMPTY
103214: LIST
103215: LIST
103216: PUSH
103217: LD_INT 30
103219: PUSH
103220: LD_INT 26
103222: PUSH
103223: EMPTY
103224: LIST
103225: LIST
103226: PUSH
103227: LD_INT 30
103229: PUSH
103230: LD_INT 28
103232: PUSH
103233: EMPTY
103234: LIST
103235: LIST
103236: PUSH
103237: EMPTY
103238: LIST
103239: LIST
103240: LIST
103241: LIST
103242: PUSH
103243: EMPTY
103244: LIST
103245: LIST
103246: PPUSH
103247: CALL_OW 69
103251: ST_TO_ADDR
// if not tmp then
103252: LD_VAR 0 2
103256: NOT
103257: IFFALSE 103261
// exit ;
103259: GO 103290
// for i in tmp do
103261: LD_ADDR_VAR 0 1
103265: PUSH
103266: LD_VAR 0 2
103270: PUSH
103271: FOR_IN
103272: IFFALSE 103288
// SetLives ( i , 1 ) ;
103274: LD_VAR 0 1
103278: PPUSH
103279: LD_INT 1
103281: PPUSH
103282: CALL_OW 234
103286: GO 103271
103288: POP
103289: POP
// end ;
103290: PPOPN 2
103292: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103293: LD_EXP 77
103297: PUSH
103298: LD_EXP 126
103302: AND
103303: IFFALSE 103590
103305: GO 103307
103307: DISABLE
103308: LD_INT 0
103310: PPUSH
103311: PPUSH
103312: PPUSH
// begin i := rand ( 1 , 7 ) ;
103313: LD_ADDR_VAR 0 1
103317: PUSH
103318: LD_INT 1
103320: PPUSH
103321: LD_INT 7
103323: PPUSH
103324: CALL_OW 12
103328: ST_TO_ADDR
// case i of 1 :
103329: LD_VAR 0 1
103333: PUSH
103334: LD_INT 1
103336: DOUBLE
103337: EQUAL
103338: IFTRUE 103342
103340: GO 103352
103342: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103343: LD_STRING earthquake(getX(game), 0, 32)
103345: PPUSH
103346: CALL_OW 559
103350: GO 103590
103352: LD_INT 2
103354: DOUBLE
103355: EQUAL
103356: IFTRUE 103360
103358: GO 103374
103360: POP
// begin ToLua ( displayStucuk(); ) ;
103361: LD_STRING displayStucuk();
103363: PPUSH
103364: CALL_OW 559
// ResetFog ;
103368: CALL_OW 335
// end ; 3 :
103372: GO 103590
103374: LD_INT 3
103376: DOUBLE
103377: EQUAL
103378: IFTRUE 103382
103380: GO 103486
103382: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103383: LD_ADDR_VAR 0 2
103387: PUSH
103388: LD_INT 22
103390: PUSH
103391: LD_OWVAR 2
103395: PUSH
103396: EMPTY
103397: LIST
103398: LIST
103399: PUSH
103400: LD_INT 25
103402: PUSH
103403: LD_INT 1
103405: PUSH
103406: EMPTY
103407: LIST
103408: LIST
103409: PUSH
103410: EMPTY
103411: LIST
103412: LIST
103413: PPUSH
103414: CALL_OW 69
103418: ST_TO_ADDR
// if not tmp then
103419: LD_VAR 0 2
103423: NOT
103424: IFFALSE 103428
// exit ;
103426: GO 103590
// un := tmp [ rand ( 1 , tmp ) ] ;
103428: LD_ADDR_VAR 0 3
103432: PUSH
103433: LD_VAR 0 2
103437: PUSH
103438: LD_INT 1
103440: PPUSH
103441: LD_VAR 0 2
103445: PPUSH
103446: CALL_OW 12
103450: ARRAY
103451: ST_TO_ADDR
// if Crawls ( un ) then
103452: LD_VAR 0 3
103456: PPUSH
103457: CALL_OW 318
103461: IFFALSE 103472
// ComWalk ( un ) ;
103463: LD_VAR 0 3
103467: PPUSH
103468: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103472: LD_VAR 0 3
103476: PPUSH
103477: LD_INT 8
103479: PPUSH
103480: CALL_OW 336
// end ; 4 :
103484: GO 103590
103486: LD_INT 4
103488: DOUBLE
103489: EQUAL
103490: IFTRUE 103494
103492: GO 103568
103494: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103495: LD_ADDR_VAR 0 2
103499: PUSH
103500: LD_INT 22
103502: PUSH
103503: LD_OWVAR 2
103507: PUSH
103508: EMPTY
103509: LIST
103510: LIST
103511: PUSH
103512: LD_INT 30
103514: PUSH
103515: LD_INT 29
103517: PUSH
103518: EMPTY
103519: LIST
103520: LIST
103521: PUSH
103522: EMPTY
103523: LIST
103524: LIST
103525: PPUSH
103526: CALL_OW 69
103530: ST_TO_ADDR
// if not tmp then
103531: LD_VAR 0 2
103535: NOT
103536: IFFALSE 103540
// exit ;
103538: GO 103590
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103540: LD_VAR 0 2
103544: PUSH
103545: LD_INT 1
103547: ARRAY
103548: PPUSH
103549: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103553: LD_VAR 0 2
103557: PUSH
103558: LD_INT 1
103560: ARRAY
103561: PPUSH
103562: CALL_OW 65
// end ; 5 .. 7 :
103566: GO 103590
103568: LD_INT 5
103570: DOUBLE
103571: GREATEREQUAL
103572: IFFALSE 103580
103574: LD_INT 7
103576: DOUBLE
103577: LESSEQUAL
103578: IFTRUE 103582
103580: GO 103589
103582: POP
// StreamSibBomb ; end ;
103583: CALL 99827 0 0
103587: GO 103590
103589: POP
// end ;
103590: PPOPN 3
103592: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103593: LD_EXP 77
103597: PUSH
103598: LD_EXP 127
103602: AND
103603: IFFALSE 103759
103605: GO 103607
103607: DISABLE
103608: LD_INT 0
103610: PPUSH
103611: PPUSH
103612: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103613: LD_ADDR_VAR 0 2
103617: PUSH
103618: LD_INT 81
103620: PUSH
103621: LD_OWVAR 2
103625: PUSH
103626: EMPTY
103627: LIST
103628: LIST
103629: PUSH
103630: LD_INT 2
103632: PUSH
103633: LD_INT 21
103635: PUSH
103636: LD_INT 1
103638: PUSH
103639: EMPTY
103640: LIST
103641: LIST
103642: PUSH
103643: LD_INT 21
103645: PUSH
103646: LD_INT 2
103648: PUSH
103649: EMPTY
103650: LIST
103651: LIST
103652: PUSH
103653: EMPTY
103654: LIST
103655: LIST
103656: LIST
103657: PUSH
103658: EMPTY
103659: LIST
103660: LIST
103661: PPUSH
103662: CALL_OW 69
103666: ST_TO_ADDR
// if not tmp then
103667: LD_VAR 0 2
103671: NOT
103672: IFFALSE 103676
// exit ;
103674: GO 103759
// p := 0 ;
103676: LD_ADDR_VAR 0 3
103680: PUSH
103681: LD_INT 0
103683: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103684: LD_INT 35
103686: PPUSH
103687: CALL_OW 67
// p := p + 1 ;
103691: LD_ADDR_VAR 0 3
103695: PUSH
103696: LD_VAR 0 3
103700: PUSH
103701: LD_INT 1
103703: PLUS
103704: ST_TO_ADDR
// for i in tmp do
103705: LD_ADDR_VAR 0 1
103709: PUSH
103710: LD_VAR 0 2
103714: PUSH
103715: FOR_IN
103716: IFFALSE 103747
// if GetLives ( i ) < 1000 then
103718: LD_VAR 0 1
103722: PPUSH
103723: CALL_OW 256
103727: PUSH
103728: LD_INT 1000
103730: LESS
103731: IFFALSE 103745
// SetLives ( i , 1000 ) ;
103733: LD_VAR 0 1
103737: PPUSH
103738: LD_INT 1000
103740: PPUSH
103741: CALL_OW 234
103745: GO 103715
103747: POP
103748: POP
// until p > 20 ;
103749: LD_VAR 0 3
103753: PUSH
103754: LD_INT 20
103756: GREATER
103757: IFFALSE 103684
// end ;
103759: PPOPN 3
103761: END
// every 0 0$1 trigger StreamModeActive and sTime do
103762: LD_EXP 77
103766: PUSH
103767: LD_EXP 128
103771: AND
103772: IFFALSE 103807
103774: GO 103776
103776: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103777: LD_INT 28
103779: PPUSH
103780: LD_OWVAR 2
103784: PPUSH
103785: LD_INT 2
103787: PPUSH
103788: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103792: LD_INT 30
103794: PPUSH
103795: LD_OWVAR 2
103799: PPUSH
103800: LD_INT 2
103802: PPUSH
103803: CALL_OW 322
// end ;
103807: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103808: LD_EXP 77
103812: PUSH
103813: LD_EXP 129
103817: AND
103818: IFFALSE 103939
103820: GO 103822
103822: DISABLE
103823: LD_INT 0
103825: PPUSH
103826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103827: LD_ADDR_VAR 0 2
103831: PUSH
103832: LD_INT 22
103834: PUSH
103835: LD_OWVAR 2
103839: PUSH
103840: EMPTY
103841: LIST
103842: LIST
103843: PUSH
103844: LD_INT 21
103846: PUSH
103847: LD_INT 1
103849: PUSH
103850: EMPTY
103851: LIST
103852: LIST
103853: PUSH
103854: LD_INT 3
103856: PUSH
103857: LD_INT 23
103859: PUSH
103860: LD_INT 0
103862: PUSH
103863: EMPTY
103864: LIST
103865: LIST
103866: PUSH
103867: EMPTY
103868: LIST
103869: LIST
103870: PUSH
103871: EMPTY
103872: LIST
103873: LIST
103874: LIST
103875: PPUSH
103876: CALL_OW 69
103880: ST_TO_ADDR
// if not tmp then
103881: LD_VAR 0 2
103885: NOT
103886: IFFALSE 103890
// exit ;
103888: GO 103939
// for i in tmp do
103890: LD_ADDR_VAR 0 1
103894: PUSH
103895: LD_VAR 0 2
103899: PUSH
103900: FOR_IN
103901: IFFALSE 103937
// begin if Crawls ( i ) then
103903: LD_VAR 0 1
103907: PPUSH
103908: CALL_OW 318
103912: IFFALSE 103923
// ComWalk ( i ) ;
103914: LD_VAR 0 1
103918: PPUSH
103919: CALL_OW 138
// SetClass ( i , 2 ) ;
103923: LD_VAR 0 1
103927: PPUSH
103928: LD_INT 2
103930: PPUSH
103931: CALL_OW 336
// end ;
103935: GO 103900
103937: POP
103938: POP
// end ;
103939: PPOPN 2
103941: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103942: LD_EXP 77
103946: PUSH
103947: LD_EXP 130
103951: AND
103952: IFFALSE 104240
103954: GO 103956
103956: DISABLE
103957: LD_INT 0
103959: PPUSH
103960: PPUSH
103961: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103962: LD_OWVAR 2
103966: PPUSH
103967: LD_INT 9
103969: PPUSH
103970: LD_INT 1
103972: PPUSH
103973: LD_INT 1
103975: PPUSH
103976: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103980: LD_INT 9
103982: PPUSH
103983: LD_OWVAR 2
103987: PPUSH
103988: CALL_OW 343
// uc_side := 9 ;
103992: LD_ADDR_OWVAR 20
103996: PUSH
103997: LD_INT 9
103999: ST_TO_ADDR
// uc_nation := 2 ;
104000: LD_ADDR_OWVAR 21
104004: PUSH
104005: LD_INT 2
104007: ST_TO_ADDR
// hc_name := Dark Warrior ;
104008: LD_ADDR_OWVAR 26
104012: PUSH
104013: LD_STRING Dark Warrior
104015: ST_TO_ADDR
// hc_gallery :=  ;
104016: LD_ADDR_OWVAR 33
104020: PUSH
104021: LD_STRING 
104023: ST_TO_ADDR
// hc_noskilllimit := true ;
104024: LD_ADDR_OWVAR 76
104028: PUSH
104029: LD_INT 1
104031: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104032: LD_ADDR_OWVAR 31
104036: PUSH
104037: LD_INT 30
104039: PUSH
104040: LD_INT 30
104042: PUSH
104043: LD_INT 30
104045: PUSH
104046: LD_INT 30
104048: PUSH
104049: EMPTY
104050: LIST
104051: LIST
104052: LIST
104053: LIST
104054: ST_TO_ADDR
// un := CreateHuman ;
104055: LD_ADDR_VAR 0 3
104059: PUSH
104060: CALL_OW 44
104064: ST_TO_ADDR
// hc_noskilllimit := false ;
104065: LD_ADDR_OWVAR 76
104069: PUSH
104070: LD_INT 0
104072: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104073: LD_VAR 0 3
104077: PPUSH
104078: LD_INT 1
104080: PPUSH
104081: CALL_OW 51
// ToLua ( playRanger() ) ;
104085: LD_STRING playRanger()
104087: PPUSH
104088: CALL_OW 559
// p := 0 ;
104092: LD_ADDR_VAR 0 2
104096: PUSH
104097: LD_INT 0
104099: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104100: LD_INT 35
104102: PPUSH
104103: CALL_OW 67
// p := p + 1 ;
104107: LD_ADDR_VAR 0 2
104111: PUSH
104112: LD_VAR 0 2
104116: PUSH
104117: LD_INT 1
104119: PLUS
104120: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104121: LD_VAR 0 3
104125: PPUSH
104126: CALL_OW 256
104130: PUSH
104131: LD_INT 1000
104133: LESS
104134: IFFALSE 104148
// SetLives ( un , 1000 ) ;
104136: LD_VAR 0 3
104140: PPUSH
104141: LD_INT 1000
104143: PPUSH
104144: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104148: LD_VAR 0 3
104152: PPUSH
104153: LD_INT 81
104155: PUSH
104156: LD_OWVAR 2
104160: PUSH
104161: EMPTY
104162: LIST
104163: LIST
104164: PUSH
104165: LD_INT 91
104167: PUSH
104168: LD_VAR 0 3
104172: PUSH
104173: LD_INT 30
104175: PUSH
104176: EMPTY
104177: LIST
104178: LIST
104179: LIST
104180: PUSH
104181: EMPTY
104182: LIST
104183: LIST
104184: PPUSH
104185: CALL_OW 69
104189: PPUSH
104190: LD_VAR 0 3
104194: PPUSH
104195: CALL_OW 74
104199: PPUSH
104200: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104204: LD_VAR 0 2
104208: PUSH
104209: LD_INT 80
104211: GREATER
104212: PUSH
104213: LD_VAR 0 3
104217: PPUSH
104218: CALL_OW 301
104222: OR
104223: IFFALSE 104100
// if un then
104225: LD_VAR 0 3
104229: IFFALSE 104240
// RemoveUnit ( un ) ;
104231: LD_VAR 0 3
104235: PPUSH
104236: CALL_OW 64
// end ;
104240: PPOPN 3
104242: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104243: LD_EXP 131
104247: IFFALSE 104363
104249: GO 104251
104251: DISABLE
104252: LD_INT 0
104254: PPUSH
104255: PPUSH
104256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104257: LD_ADDR_VAR 0 2
104261: PUSH
104262: LD_INT 81
104264: PUSH
104265: LD_OWVAR 2
104269: PUSH
104270: EMPTY
104271: LIST
104272: LIST
104273: PUSH
104274: LD_INT 21
104276: PUSH
104277: LD_INT 1
104279: PUSH
104280: EMPTY
104281: LIST
104282: LIST
104283: PUSH
104284: EMPTY
104285: LIST
104286: LIST
104287: PPUSH
104288: CALL_OW 69
104292: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104293: LD_STRING playComputer()
104295: PPUSH
104296: CALL_OW 559
// if not tmp then
104300: LD_VAR 0 2
104304: NOT
104305: IFFALSE 104309
// exit ;
104307: GO 104363
// for i in tmp do
104309: LD_ADDR_VAR 0 1
104313: PUSH
104314: LD_VAR 0 2
104318: PUSH
104319: FOR_IN
104320: IFFALSE 104361
// for j := 1 to 4 do
104322: LD_ADDR_VAR 0 3
104326: PUSH
104327: DOUBLE
104328: LD_INT 1
104330: DEC
104331: ST_TO_ADDR
104332: LD_INT 4
104334: PUSH
104335: FOR_TO
104336: IFFALSE 104357
// SetSkill ( i , j , 10 ) ;
104338: LD_VAR 0 1
104342: PPUSH
104343: LD_VAR 0 3
104347: PPUSH
104348: LD_INT 10
104350: PPUSH
104351: CALL_OW 237
104355: GO 104335
104357: POP
104358: POP
104359: GO 104319
104361: POP
104362: POP
// end ;
104363: PPOPN 3
104365: END
// every 0 0$1 trigger s30 do var i , tmp ;
104366: LD_EXP 132
104370: IFFALSE 104439
104372: GO 104374
104374: DISABLE
104375: LD_INT 0
104377: PPUSH
104378: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104379: LD_ADDR_VAR 0 2
104383: PUSH
104384: LD_INT 22
104386: PUSH
104387: LD_OWVAR 2
104391: PUSH
104392: EMPTY
104393: LIST
104394: LIST
104395: PPUSH
104396: CALL_OW 69
104400: ST_TO_ADDR
// if not tmp then
104401: LD_VAR 0 2
104405: NOT
104406: IFFALSE 104410
// exit ;
104408: GO 104439
// for i in tmp do
104410: LD_ADDR_VAR 0 1
104414: PUSH
104415: LD_VAR 0 2
104419: PUSH
104420: FOR_IN
104421: IFFALSE 104437
// SetLives ( i , 300 ) ;
104423: LD_VAR 0 1
104427: PPUSH
104428: LD_INT 300
104430: PPUSH
104431: CALL_OW 234
104435: GO 104420
104437: POP
104438: POP
// end ;
104439: PPOPN 2
104441: END
// every 0 0$1 trigger s60 do var i , tmp ;
104442: LD_EXP 133
104446: IFFALSE 104515
104448: GO 104450
104450: DISABLE
104451: LD_INT 0
104453: PPUSH
104454: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104455: LD_ADDR_VAR 0 2
104459: PUSH
104460: LD_INT 22
104462: PUSH
104463: LD_OWVAR 2
104467: PUSH
104468: EMPTY
104469: LIST
104470: LIST
104471: PPUSH
104472: CALL_OW 69
104476: ST_TO_ADDR
// if not tmp then
104477: LD_VAR 0 2
104481: NOT
104482: IFFALSE 104486
// exit ;
104484: GO 104515
// for i in tmp do
104486: LD_ADDR_VAR 0 1
104490: PUSH
104491: LD_VAR 0 2
104495: PUSH
104496: FOR_IN
104497: IFFALSE 104513
// SetLives ( i , 600 ) ;
104499: LD_VAR 0 1
104503: PPUSH
104504: LD_INT 600
104506: PPUSH
104507: CALL_OW 234
104511: GO 104496
104513: POP
104514: POP
// end ;
104515: PPOPN 2
104517: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104518: LD_INT 0
104520: PPUSH
// case cmd of 301 :
104521: LD_VAR 0 1
104525: PUSH
104526: LD_INT 301
104528: DOUBLE
104529: EQUAL
104530: IFTRUE 104534
104532: GO 104566
104534: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104535: LD_VAR 0 6
104539: PPUSH
104540: LD_VAR 0 7
104544: PPUSH
104545: LD_VAR 0 8
104549: PPUSH
104550: LD_VAR 0 4
104554: PPUSH
104555: LD_VAR 0 5
104559: PPUSH
104560: CALL 105767 0 5
104564: GO 104687
104566: LD_INT 302
104568: DOUBLE
104569: EQUAL
104570: IFTRUE 104574
104572: GO 104611
104574: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104575: LD_VAR 0 6
104579: PPUSH
104580: LD_VAR 0 7
104584: PPUSH
104585: LD_VAR 0 8
104589: PPUSH
104590: LD_VAR 0 9
104594: PPUSH
104595: LD_VAR 0 4
104599: PPUSH
104600: LD_VAR 0 5
104604: PPUSH
104605: CALL 105858 0 6
104609: GO 104687
104611: LD_INT 303
104613: DOUBLE
104614: EQUAL
104615: IFTRUE 104619
104617: GO 104656
104619: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104620: LD_VAR 0 6
104624: PPUSH
104625: LD_VAR 0 7
104629: PPUSH
104630: LD_VAR 0 8
104634: PPUSH
104635: LD_VAR 0 9
104639: PPUSH
104640: LD_VAR 0 4
104644: PPUSH
104645: LD_VAR 0 5
104649: PPUSH
104650: CALL 104692 0 6
104654: GO 104687
104656: LD_INT 304
104658: DOUBLE
104659: EQUAL
104660: IFTRUE 104664
104662: GO 104686
104664: POP
// hHackTeleport ( unit , x , y ) ; end ;
104665: LD_VAR 0 2
104669: PPUSH
104670: LD_VAR 0 4
104674: PPUSH
104675: LD_VAR 0 5
104679: PPUSH
104680: CALL 106451 0 3
104684: GO 104687
104686: POP
// end ;
104687: LD_VAR 0 12
104691: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104692: LD_INT 0
104694: PPUSH
104695: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104696: LD_VAR 0 1
104700: PUSH
104701: LD_INT 1
104703: LESS
104704: PUSH
104705: LD_VAR 0 1
104709: PUSH
104710: LD_INT 3
104712: GREATER
104713: OR
104714: PUSH
104715: LD_VAR 0 5
104719: PPUSH
104720: LD_VAR 0 6
104724: PPUSH
104725: CALL_OW 428
104729: OR
104730: IFFALSE 104734
// exit ;
104732: GO 105454
// uc_side := your_side ;
104734: LD_ADDR_OWVAR 20
104738: PUSH
104739: LD_OWVAR 2
104743: ST_TO_ADDR
// uc_nation := nation ;
104744: LD_ADDR_OWVAR 21
104748: PUSH
104749: LD_VAR 0 1
104753: ST_TO_ADDR
// bc_level = 1 ;
104754: LD_ADDR_OWVAR 43
104758: PUSH
104759: LD_INT 1
104761: ST_TO_ADDR
// case btype of 1 :
104762: LD_VAR 0 2
104766: PUSH
104767: LD_INT 1
104769: DOUBLE
104770: EQUAL
104771: IFTRUE 104775
104773: GO 104786
104775: POP
// bc_type := b_depot ; 2 :
104776: LD_ADDR_OWVAR 42
104780: PUSH
104781: LD_INT 0
104783: ST_TO_ADDR
104784: GO 105398
104786: LD_INT 2
104788: DOUBLE
104789: EQUAL
104790: IFTRUE 104794
104792: GO 104805
104794: POP
// bc_type := b_warehouse ; 3 :
104795: LD_ADDR_OWVAR 42
104799: PUSH
104800: LD_INT 1
104802: ST_TO_ADDR
104803: GO 105398
104805: LD_INT 3
104807: DOUBLE
104808: EQUAL
104809: IFTRUE 104813
104811: GO 104824
104813: POP
// bc_type := b_lab ; 4 .. 9 :
104814: LD_ADDR_OWVAR 42
104818: PUSH
104819: LD_INT 6
104821: ST_TO_ADDR
104822: GO 105398
104824: LD_INT 4
104826: DOUBLE
104827: GREATEREQUAL
104828: IFFALSE 104836
104830: LD_INT 9
104832: DOUBLE
104833: LESSEQUAL
104834: IFTRUE 104838
104836: GO 104890
104838: POP
// begin bc_type := b_lab_half ;
104839: LD_ADDR_OWVAR 42
104843: PUSH
104844: LD_INT 7
104846: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104847: LD_ADDR_OWVAR 44
104851: PUSH
104852: LD_INT 10
104854: PUSH
104855: LD_INT 11
104857: PUSH
104858: LD_INT 12
104860: PUSH
104861: LD_INT 15
104863: PUSH
104864: LD_INT 14
104866: PUSH
104867: LD_INT 13
104869: PUSH
104870: EMPTY
104871: LIST
104872: LIST
104873: LIST
104874: LIST
104875: LIST
104876: LIST
104877: PUSH
104878: LD_VAR 0 2
104882: PUSH
104883: LD_INT 3
104885: MINUS
104886: ARRAY
104887: ST_TO_ADDR
// end ; 10 .. 13 :
104888: GO 105398
104890: LD_INT 10
104892: DOUBLE
104893: GREATEREQUAL
104894: IFFALSE 104902
104896: LD_INT 13
104898: DOUBLE
104899: LESSEQUAL
104900: IFTRUE 104904
104902: GO 104981
104904: POP
// begin bc_type := b_lab_full ;
104905: LD_ADDR_OWVAR 42
104909: PUSH
104910: LD_INT 8
104912: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104913: LD_ADDR_OWVAR 44
104917: PUSH
104918: LD_INT 10
104920: PUSH
104921: LD_INT 12
104923: PUSH
104924: LD_INT 14
104926: PUSH
104927: LD_INT 13
104929: PUSH
104930: EMPTY
104931: LIST
104932: LIST
104933: LIST
104934: LIST
104935: PUSH
104936: LD_VAR 0 2
104940: PUSH
104941: LD_INT 9
104943: MINUS
104944: ARRAY
104945: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104946: LD_ADDR_OWVAR 45
104950: PUSH
104951: LD_INT 11
104953: PUSH
104954: LD_INT 15
104956: PUSH
104957: LD_INT 12
104959: PUSH
104960: LD_INT 15
104962: PUSH
104963: EMPTY
104964: LIST
104965: LIST
104966: LIST
104967: LIST
104968: PUSH
104969: LD_VAR 0 2
104973: PUSH
104974: LD_INT 9
104976: MINUS
104977: ARRAY
104978: ST_TO_ADDR
// end ; 14 :
104979: GO 105398
104981: LD_INT 14
104983: DOUBLE
104984: EQUAL
104985: IFTRUE 104989
104987: GO 105000
104989: POP
// bc_type := b_workshop ; 15 :
104990: LD_ADDR_OWVAR 42
104994: PUSH
104995: LD_INT 2
104997: ST_TO_ADDR
104998: GO 105398
105000: LD_INT 15
105002: DOUBLE
105003: EQUAL
105004: IFTRUE 105008
105006: GO 105019
105008: POP
// bc_type := b_factory ; 16 :
105009: LD_ADDR_OWVAR 42
105013: PUSH
105014: LD_INT 3
105016: ST_TO_ADDR
105017: GO 105398
105019: LD_INT 16
105021: DOUBLE
105022: EQUAL
105023: IFTRUE 105027
105025: GO 105038
105027: POP
// bc_type := b_ext_gun ; 17 :
105028: LD_ADDR_OWVAR 42
105032: PUSH
105033: LD_INT 17
105035: ST_TO_ADDR
105036: GO 105398
105038: LD_INT 17
105040: DOUBLE
105041: EQUAL
105042: IFTRUE 105046
105044: GO 105074
105046: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105047: LD_ADDR_OWVAR 42
105051: PUSH
105052: LD_INT 19
105054: PUSH
105055: LD_INT 23
105057: PUSH
105058: LD_INT 19
105060: PUSH
105061: EMPTY
105062: LIST
105063: LIST
105064: LIST
105065: PUSH
105066: LD_VAR 0 1
105070: ARRAY
105071: ST_TO_ADDR
105072: GO 105398
105074: LD_INT 18
105076: DOUBLE
105077: EQUAL
105078: IFTRUE 105082
105080: GO 105093
105082: POP
// bc_type := b_ext_radar ; 19 :
105083: LD_ADDR_OWVAR 42
105087: PUSH
105088: LD_INT 20
105090: ST_TO_ADDR
105091: GO 105398
105093: LD_INT 19
105095: DOUBLE
105096: EQUAL
105097: IFTRUE 105101
105099: GO 105112
105101: POP
// bc_type := b_ext_radio ; 20 :
105102: LD_ADDR_OWVAR 42
105106: PUSH
105107: LD_INT 22
105109: ST_TO_ADDR
105110: GO 105398
105112: LD_INT 20
105114: DOUBLE
105115: EQUAL
105116: IFTRUE 105120
105118: GO 105131
105120: POP
// bc_type := b_ext_siberium ; 21 :
105121: LD_ADDR_OWVAR 42
105125: PUSH
105126: LD_INT 21
105128: ST_TO_ADDR
105129: GO 105398
105131: LD_INT 21
105133: DOUBLE
105134: EQUAL
105135: IFTRUE 105139
105137: GO 105150
105139: POP
// bc_type := b_ext_computer ; 22 :
105140: LD_ADDR_OWVAR 42
105144: PUSH
105145: LD_INT 24
105147: ST_TO_ADDR
105148: GO 105398
105150: LD_INT 22
105152: DOUBLE
105153: EQUAL
105154: IFTRUE 105158
105156: GO 105169
105158: POP
// bc_type := b_ext_track ; 23 :
105159: LD_ADDR_OWVAR 42
105163: PUSH
105164: LD_INT 16
105166: ST_TO_ADDR
105167: GO 105398
105169: LD_INT 23
105171: DOUBLE
105172: EQUAL
105173: IFTRUE 105177
105175: GO 105188
105177: POP
// bc_type := b_ext_laser ; 24 :
105178: LD_ADDR_OWVAR 42
105182: PUSH
105183: LD_INT 25
105185: ST_TO_ADDR
105186: GO 105398
105188: LD_INT 24
105190: DOUBLE
105191: EQUAL
105192: IFTRUE 105196
105194: GO 105207
105196: POP
// bc_type := b_control_tower ; 25 :
105197: LD_ADDR_OWVAR 42
105201: PUSH
105202: LD_INT 36
105204: ST_TO_ADDR
105205: GO 105398
105207: LD_INT 25
105209: DOUBLE
105210: EQUAL
105211: IFTRUE 105215
105213: GO 105226
105215: POP
// bc_type := b_breastwork ; 26 :
105216: LD_ADDR_OWVAR 42
105220: PUSH
105221: LD_INT 31
105223: ST_TO_ADDR
105224: GO 105398
105226: LD_INT 26
105228: DOUBLE
105229: EQUAL
105230: IFTRUE 105234
105232: GO 105245
105234: POP
// bc_type := b_bunker ; 27 :
105235: LD_ADDR_OWVAR 42
105239: PUSH
105240: LD_INT 32
105242: ST_TO_ADDR
105243: GO 105398
105245: LD_INT 27
105247: DOUBLE
105248: EQUAL
105249: IFTRUE 105253
105251: GO 105264
105253: POP
// bc_type := b_turret ; 28 :
105254: LD_ADDR_OWVAR 42
105258: PUSH
105259: LD_INT 33
105261: ST_TO_ADDR
105262: GO 105398
105264: LD_INT 28
105266: DOUBLE
105267: EQUAL
105268: IFTRUE 105272
105270: GO 105283
105272: POP
// bc_type := b_armoury ; 29 :
105273: LD_ADDR_OWVAR 42
105277: PUSH
105278: LD_INT 4
105280: ST_TO_ADDR
105281: GO 105398
105283: LD_INT 29
105285: DOUBLE
105286: EQUAL
105287: IFTRUE 105291
105289: GO 105302
105291: POP
// bc_type := b_barracks ; 30 :
105292: LD_ADDR_OWVAR 42
105296: PUSH
105297: LD_INT 5
105299: ST_TO_ADDR
105300: GO 105398
105302: LD_INT 30
105304: DOUBLE
105305: EQUAL
105306: IFTRUE 105310
105308: GO 105321
105310: POP
// bc_type := b_solar_power ; 31 :
105311: LD_ADDR_OWVAR 42
105315: PUSH
105316: LD_INT 27
105318: ST_TO_ADDR
105319: GO 105398
105321: LD_INT 31
105323: DOUBLE
105324: EQUAL
105325: IFTRUE 105329
105327: GO 105340
105329: POP
// bc_type := b_oil_power ; 32 :
105330: LD_ADDR_OWVAR 42
105334: PUSH
105335: LD_INT 26
105337: ST_TO_ADDR
105338: GO 105398
105340: LD_INT 32
105342: DOUBLE
105343: EQUAL
105344: IFTRUE 105348
105346: GO 105359
105348: POP
// bc_type := b_siberite_power ; 33 :
105349: LD_ADDR_OWVAR 42
105353: PUSH
105354: LD_INT 28
105356: ST_TO_ADDR
105357: GO 105398
105359: LD_INT 33
105361: DOUBLE
105362: EQUAL
105363: IFTRUE 105367
105365: GO 105378
105367: POP
// bc_type := b_oil_mine ; 34 :
105368: LD_ADDR_OWVAR 42
105372: PUSH
105373: LD_INT 29
105375: ST_TO_ADDR
105376: GO 105398
105378: LD_INT 34
105380: DOUBLE
105381: EQUAL
105382: IFTRUE 105386
105384: GO 105397
105386: POP
// bc_type := b_siberite_mine ; end ;
105387: LD_ADDR_OWVAR 42
105391: PUSH
105392: LD_INT 30
105394: ST_TO_ADDR
105395: GO 105398
105397: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105398: LD_ADDR_VAR 0 8
105402: PUSH
105403: LD_VAR 0 5
105407: PPUSH
105408: LD_VAR 0 6
105412: PPUSH
105413: LD_VAR 0 3
105417: PPUSH
105418: CALL_OW 47
105422: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105423: LD_OWVAR 42
105427: PUSH
105428: LD_INT 32
105430: PUSH
105431: LD_INT 33
105433: PUSH
105434: EMPTY
105435: LIST
105436: LIST
105437: IN
105438: IFFALSE 105454
// PlaceWeaponTurret ( b , weapon ) ;
105440: LD_VAR 0 8
105444: PPUSH
105445: LD_VAR 0 4
105449: PPUSH
105450: CALL_OW 431
// end ;
105454: LD_VAR 0 7
105458: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105459: LD_INT 0
105461: PPUSH
105462: PPUSH
105463: PPUSH
105464: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105465: LD_ADDR_VAR 0 4
105469: PUSH
105470: LD_INT 22
105472: PUSH
105473: LD_OWVAR 2
105477: PUSH
105478: EMPTY
105479: LIST
105480: LIST
105481: PUSH
105482: LD_INT 2
105484: PUSH
105485: LD_INT 30
105487: PUSH
105488: LD_INT 0
105490: PUSH
105491: EMPTY
105492: LIST
105493: LIST
105494: PUSH
105495: LD_INT 30
105497: PUSH
105498: LD_INT 1
105500: PUSH
105501: EMPTY
105502: LIST
105503: LIST
105504: PUSH
105505: EMPTY
105506: LIST
105507: LIST
105508: LIST
105509: PUSH
105510: EMPTY
105511: LIST
105512: LIST
105513: PPUSH
105514: CALL_OW 69
105518: ST_TO_ADDR
// if not tmp then
105519: LD_VAR 0 4
105523: NOT
105524: IFFALSE 105528
// exit ;
105526: GO 105587
// for i in tmp do
105528: LD_ADDR_VAR 0 2
105532: PUSH
105533: LD_VAR 0 4
105537: PUSH
105538: FOR_IN
105539: IFFALSE 105585
// for j = 1 to 3 do
105541: LD_ADDR_VAR 0 3
105545: PUSH
105546: DOUBLE
105547: LD_INT 1
105549: DEC
105550: ST_TO_ADDR
105551: LD_INT 3
105553: PUSH
105554: FOR_TO
105555: IFFALSE 105581
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105557: LD_VAR 0 2
105561: PPUSH
105562: CALL_OW 274
105566: PPUSH
105567: LD_VAR 0 3
105571: PPUSH
105572: LD_INT 99999
105574: PPUSH
105575: CALL_OW 277
105579: GO 105554
105581: POP
105582: POP
105583: GO 105538
105585: POP
105586: POP
// end ;
105587: LD_VAR 0 1
105591: RET
// export function hHackSetLevel10 ; var i , j ; begin
105592: LD_INT 0
105594: PPUSH
105595: PPUSH
105596: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105597: LD_ADDR_VAR 0 2
105601: PUSH
105602: LD_INT 21
105604: PUSH
105605: LD_INT 1
105607: PUSH
105608: EMPTY
105609: LIST
105610: LIST
105611: PPUSH
105612: CALL_OW 69
105616: PUSH
105617: FOR_IN
105618: IFFALSE 105670
// if IsSelected ( i ) then
105620: LD_VAR 0 2
105624: PPUSH
105625: CALL_OW 306
105629: IFFALSE 105668
// begin for j := 1 to 4 do
105631: LD_ADDR_VAR 0 3
105635: PUSH
105636: DOUBLE
105637: LD_INT 1
105639: DEC
105640: ST_TO_ADDR
105641: LD_INT 4
105643: PUSH
105644: FOR_TO
105645: IFFALSE 105666
// SetSkill ( i , j , 10 ) ;
105647: LD_VAR 0 2
105651: PPUSH
105652: LD_VAR 0 3
105656: PPUSH
105657: LD_INT 10
105659: PPUSH
105660: CALL_OW 237
105664: GO 105644
105666: POP
105667: POP
// end ;
105668: GO 105617
105670: POP
105671: POP
// end ;
105672: LD_VAR 0 1
105676: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105677: LD_INT 0
105679: PPUSH
105680: PPUSH
105681: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105682: LD_ADDR_VAR 0 2
105686: PUSH
105687: LD_INT 22
105689: PUSH
105690: LD_OWVAR 2
105694: PUSH
105695: EMPTY
105696: LIST
105697: LIST
105698: PUSH
105699: LD_INT 21
105701: PUSH
105702: LD_INT 1
105704: PUSH
105705: EMPTY
105706: LIST
105707: LIST
105708: PUSH
105709: EMPTY
105710: LIST
105711: LIST
105712: PPUSH
105713: CALL_OW 69
105717: PUSH
105718: FOR_IN
105719: IFFALSE 105760
// begin for j := 1 to 4 do
105721: LD_ADDR_VAR 0 3
105725: PUSH
105726: DOUBLE
105727: LD_INT 1
105729: DEC
105730: ST_TO_ADDR
105731: LD_INT 4
105733: PUSH
105734: FOR_TO
105735: IFFALSE 105756
// SetSkill ( i , j , 10 ) ;
105737: LD_VAR 0 2
105741: PPUSH
105742: LD_VAR 0 3
105746: PPUSH
105747: LD_INT 10
105749: PPUSH
105750: CALL_OW 237
105754: GO 105734
105756: POP
105757: POP
// end ;
105758: GO 105718
105760: POP
105761: POP
// end ;
105762: LD_VAR 0 1
105766: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105767: LD_INT 0
105769: PPUSH
// uc_side := your_side ;
105770: LD_ADDR_OWVAR 20
105774: PUSH
105775: LD_OWVAR 2
105779: ST_TO_ADDR
// uc_nation := nation ;
105780: LD_ADDR_OWVAR 21
105784: PUSH
105785: LD_VAR 0 1
105789: ST_TO_ADDR
// InitHc ;
105790: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105794: LD_INT 0
105796: PPUSH
105797: LD_VAR 0 2
105801: PPUSH
105802: LD_VAR 0 3
105806: PPUSH
105807: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105811: LD_VAR 0 4
105815: PPUSH
105816: LD_VAR 0 5
105820: PPUSH
105821: CALL_OW 428
105825: PUSH
105826: LD_INT 0
105828: EQUAL
105829: IFFALSE 105853
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105831: CALL_OW 44
105835: PPUSH
105836: LD_VAR 0 4
105840: PPUSH
105841: LD_VAR 0 5
105845: PPUSH
105846: LD_INT 1
105848: PPUSH
105849: CALL_OW 48
// end ;
105853: LD_VAR 0 6
105857: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105858: LD_INT 0
105860: PPUSH
105861: PPUSH
// uc_side := your_side ;
105862: LD_ADDR_OWVAR 20
105866: PUSH
105867: LD_OWVAR 2
105871: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105872: LD_VAR 0 1
105876: PUSH
105877: LD_INT 1
105879: PUSH
105880: LD_INT 2
105882: PUSH
105883: LD_INT 3
105885: PUSH
105886: LD_INT 4
105888: PUSH
105889: LD_INT 5
105891: PUSH
105892: EMPTY
105893: LIST
105894: LIST
105895: LIST
105896: LIST
105897: LIST
105898: IN
105899: IFFALSE 105911
// uc_nation := nation_american else
105901: LD_ADDR_OWVAR 21
105905: PUSH
105906: LD_INT 1
105908: ST_TO_ADDR
105909: GO 105954
// if chassis in [ 11 , 12 , 13 , 14 ] then
105911: LD_VAR 0 1
105915: PUSH
105916: LD_INT 11
105918: PUSH
105919: LD_INT 12
105921: PUSH
105922: LD_INT 13
105924: PUSH
105925: LD_INT 14
105927: PUSH
105928: EMPTY
105929: LIST
105930: LIST
105931: LIST
105932: LIST
105933: IN
105934: IFFALSE 105946
// uc_nation := nation_arabian else
105936: LD_ADDR_OWVAR 21
105940: PUSH
105941: LD_INT 2
105943: ST_TO_ADDR
105944: GO 105954
// uc_nation := nation_russian ;
105946: LD_ADDR_OWVAR 21
105950: PUSH
105951: LD_INT 3
105953: ST_TO_ADDR
// vc_chassis := chassis ;
105954: LD_ADDR_OWVAR 37
105958: PUSH
105959: LD_VAR 0 1
105963: ST_TO_ADDR
// vc_engine := engine ;
105964: LD_ADDR_OWVAR 39
105968: PUSH
105969: LD_VAR 0 2
105973: ST_TO_ADDR
// vc_control := control ;
105974: LD_ADDR_OWVAR 38
105978: PUSH
105979: LD_VAR 0 3
105983: ST_TO_ADDR
// vc_weapon := weapon ;
105984: LD_ADDR_OWVAR 40
105988: PUSH
105989: LD_VAR 0 4
105993: ST_TO_ADDR
// un := CreateVehicle ;
105994: LD_ADDR_VAR 0 8
105998: PUSH
105999: CALL_OW 45
106003: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106004: LD_VAR 0 8
106008: PPUSH
106009: LD_INT 0
106011: PPUSH
106012: LD_INT 5
106014: PPUSH
106015: CALL_OW 12
106019: PPUSH
106020: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106024: LD_VAR 0 8
106028: PPUSH
106029: LD_VAR 0 5
106033: PPUSH
106034: LD_VAR 0 6
106038: PPUSH
106039: LD_INT 1
106041: PPUSH
106042: CALL_OW 48
// end ;
106046: LD_VAR 0 7
106050: RET
// export hInvincible ; every 1 do
106051: GO 106053
106053: DISABLE
// hInvincible := [ ] ;
106054: LD_ADDR_EXP 134
106058: PUSH
106059: EMPTY
106060: ST_TO_ADDR
106061: END
// every 10 do var i ;
106062: GO 106064
106064: DISABLE
106065: LD_INT 0
106067: PPUSH
// begin enable ;
106068: ENABLE
// if not hInvincible then
106069: LD_EXP 134
106073: NOT
106074: IFFALSE 106078
// exit ;
106076: GO 106122
// for i in hInvincible do
106078: LD_ADDR_VAR 0 1
106082: PUSH
106083: LD_EXP 134
106087: PUSH
106088: FOR_IN
106089: IFFALSE 106120
// if GetLives ( i ) < 1000 then
106091: LD_VAR 0 1
106095: PPUSH
106096: CALL_OW 256
106100: PUSH
106101: LD_INT 1000
106103: LESS
106104: IFFALSE 106118
// SetLives ( i , 1000 ) ;
106106: LD_VAR 0 1
106110: PPUSH
106111: LD_INT 1000
106113: PPUSH
106114: CALL_OW 234
106118: GO 106088
106120: POP
106121: POP
// end ;
106122: PPOPN 1
106124: END
// export function hHackInvincible ; var i ; begin
106125: LD_INT 0
106127: PPUSH
106128: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106129: LD_ADDR_VAR 0 2
106133: PUSH
106134: LD_INT 2
106136: PUSH
106137: LD_INT 21
106139: PUSH
106140: LD_INT 1
106142: PUSH
106143: EMPTY
106144: LIST
106145: LIST
106146: PUSH
106147: LD_INT 21
106149: PUSH
106150: LD_INT 2
106152: PUSH
106153: EMPTY
106154: LIST
106155: LIST
106156: PUSH
106157: EMPTY
106158: LIST
106159: LIST
106160: LIST
106161: PPUSH
106162: CALL_OW 69
106166: PUSH
106167: FOR_IN
106168: IFFALSE 106229
// if IsSelected ( i ) then
106170: LD_VAR 0 2
106174: PPUSH
106175: CALL_OW 306
106179: IFFALSE 106227
// begin if i in hInvincible then
106181: LD_VAR 0 2
106185: PUSH
106186: LD_EXP 134
106190: IN
106191: IFFALSE 106211
// hInvincible := hInvincible diff i else
106193: LD_ADDR_EXP 134
106197: PUSH
106198: LD_EXP 134
106202: PUSH
106203: LD_VAR 0 2
106207: DIFF
106208: ST_TO_ADDR
106209: GO 106227
// hInvincible := hInvincible union i ;
106211: LD_ADDR_EXP 134
106215: PUSH
106216: LD_EXP 134
106220: PUSH
106221: LD_VAR 0 2
106225: UNION
106226: ST_TO_ADDR
// end ;
106227: GO 106167
106229: POP
106230: POP
// end ;
106231: LD_VAR 0 1
106235: RET
// export function hHackInvisible ; var i , j ; begin
106236: LD_INT 0
106238: PPUSH
106239: PPUSH
106240: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106241: LD_ADDR_VAR 0 2
106245: PUSH
106246: LD_INT 21
106248: PUSH
106249: LD_INT 1
106251: PUSH
106252: EMPTY
106253: LIST
106254: LIST
106255: PPUSH
106256: CALL_OW 69
106260: PUSH
106261: FOR_IN
106262: IFFALSE 106286
// if IsSelected ( i ) then
106264: LD_VAR 0 2
106268: PPUSH
106269: CALL_OW 306
106273: IFFALSE 106284
// ComForceInvisible ( i ) ;
106275: LD_VAR 0 2
106279: PPUSH
106280: CALL_OW 496
106284: GO 106261
106286: POP
106287: POP
// end ;
106288: LD_VAR 0 1
106292: RET
// export function hHackChangeYourSide ; begin
106293: LD_INT 0
106295: PPUSH
// if your_side = 8 then
106296: LD_OWVAR 2
106300: PUSH
106301: LD_INT 8
106303: EQUAL
106304: IFFALSE 106316
// your_side := 0 else
106306: LD_ADDR_OWVAR 2
106310: PUSH
106311: LD_INT 0
106313: ST_TO_ADDR
106314: GO 106330
// your_side := your_side + 1 ;
106316: LD_ADDR_OWVAR 2
106320: PUSH
106321: LD_OWVAR 2
106325: PUSH
106326: LD_INT 1
106328: PLUS
106329: ST_TO_ADDR
// end ;
106330: LD_VAR 0 1
106334: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106335: LD_INT 0
106337: PPUSH
106338: PPUSH
106339: PPUSH
// for i in all_units do
106340: LD_ADDR_VAR 0 2
106344: PUSH
106345: LD_OWVAR 3
106349: PUSH
106350: FOR_IN
106351: IFFALSE 106429
// if IsSelected ( i ) then
106353: LD_VAR 0 2
106357: PPUSH
106358: CALL_OW 306
106362: IFFALSE 106427
// begin j := GetSide ( i ) ;
106364: LD_ADDR_VAR 0 3
106368: PUSH
106369: LD_VAR 0 2
106373: PPUSH
106374: CALL_OW 255
106378: ST_TO_ADDR
// if j = 8 then
106379: LD_VAR 0 3
106383: PUSH
106384: LD_INT 8
106386: EQUAL
106387: IFFALSE 106399
// j := 0 else
106389: LD_ADDR_VAR 0 3
106393: PUSH
106394: LD_INT 0
106396: ST_TO_ADDR
106397: GO 106413
// j := j + 1 ;
106399: LD_ADDR_VAR 0 3
106403: PUSH
106404: LD_VAR 0 3
106408: PUSH
106409: LD_INT 1
106411: PLUS
106412: ST_TO_ADDR
// SetSide ( i , j ) ;
106413: LD_VAR 0 2
106417: PPUSH
106418: LD_VAR 0 3
106422: PPUSH
106423: CALL_OW 235
// end ;
106427: GO 106350
106429: POP
106430: POP
// end ;
106431: LD_VAR 0 1
106435: RET
// export function hHackFog ; begin
106436: LD_INT 0
106438: PPUSH
// FogOff ( true ) ;
106439: LD_INT 1
106441: PPUSH
106442: CALL_OW 344
// end ;
106446: LD_VAR 0 1
106450: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106451: LD_INT 0
106453: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106454: LD_VAR 0 1
106458: PPUSH
106459: LD_VAR 0 2
106463: PPUSH
106464: LD_VAR 0 3
106468: PPUSH
106469: LD_INT 1
106471: PPUSH
106472: LD_INT 1
106474: PPUSH
106475: CALL_OW 483
// CenterOnXY ( x , y ) ;
106479: LD_VAR 0 2
106483: PPUSH
106484: LD_VAR 0 3
106488: PPUSH
106489: CALL_OW 84
// end ;
106493: LD_VAR 0 4
106497: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106498: LD_INT 0
106500: PPUSH
106501: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106502: LD_VAR 0 1
106506: NOT
106507: PUSH
106508: LD_VAR 0 2
106512: PPUSH
106513: LD_VAR 0 3
106517: PPUSH
106518: CALL_OW 488
106522: NOT
106523: OR
106524: PUSH
106525: LD_VAR 0 1
106529: PPUSH
106530: CALL_OW 266
106534: PUSH
106535: LD_INT 3
106537: NONEQUAL
106538: PUSH
106539: LD_VAR 0 1
106543: PPUSH
106544: CALL_OW 247
106548: PUSH
106549: LD_INT 1
106551: EQUAL
106552: NOT
106553: AND
106554: OR
106555: IFFALSE 106559
// exit ;
106557: GO 106708
// if GetType ( factory ) = unit_human then
106559: LD_VAR 0 1
106563: PPUSH
106564: CALL_OW 247
106568: PUSH
106569: LD_INT 1
106571: EQUAL
106572: IFFALSE 106589
// factory := IsInUnit ( factory ) ;
106574: LD_ADDR_VAR 0 1
106578: PUSH
106579: LD_VAR 0 1
106583: PPUSH
106584: CALL_OW 310
106588: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106589: LD_VAR 0 1
106593: PPUSH
106594: CALL_OW 266
106598: PUSH
106599: LD_INT 3
106601: NONEQUAL
106602: IFFALSE 106606
// exit ;
106604: GO 106708
// if HexInfo ( x , y ) = factory then
106606: LD_VAR 0 2
106610: PPUSH
106611: LD_VAR 0 3
106615: PPUSH
106616: CALL_OW 428
106620: PUSH
106621: LD_VAR 0 1
106625: EQUAL
106626: IFFALSE 106653
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
106628: LD_ADDR_EXP 135
106632: PUSH
106633: LD_EXP 135
106637: PPUSH
106638: LD_VAR 0 1
106642: PPUSH
106643: LD_INT 0
106645: PPUSH
106646: CALL_OW 1
106650: ST_TO_ADDR
106651: GO 106704
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
106653: LD_ADDR_EXP 135
106657: PUSH
106658: LD_EXP 135
106662: PPUSH
106663: LD_VAR 0 1
106667: PPUSH
106668: LD_VAR 0 1
106672: PPUSH
106673: CALL_OW 255
106677: PUSH
106678: LD_VAR 0 1
106682: PUSH
106683: LD_VAR 0 2
106687: PUSH
106688: LD_VAR 0 3
106692: PUSH
106693: EMPTY
106694: LIST
106695: LIST
106696: LIST
106697: LIST
106698: PPUSH
106699: CALL_OW 1
106703: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106704: CALL 106713 0 0
// end ;
106708: LD_VAR 0 4
106712: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106713: LD_INT 0
106715: PPUSH
106716: PPUSH
106717: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106718: LD_STRING resetFactoryWaypoint();
106720: PPUSH
106721: CALL_OW 559
// if factoryWaypoints then
106725: LD_EXP 135
106729: IFFALSE 106855
// begin list := PrepareArray ( factoryWaypoints ) ;
106731: LD_ADDR_VAR 0 3
106735: PUSH
106736: LD_EXP 135
106740: PPUSH
106741: CALL 61110 0 1
106745: ST_TO_ADDR
// for i := 1 to list do
106746: LD_ADDR_VAR 0 2
106750: PUSH
106751: DOUBLE
106752: LD_INT 1
106754: DEC
106755: ST_TO_ADDR
106756: LD_VAR 0 3
106760: PUSH
106761: FOR_TO
106762: IFFALSE 106853
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106764: LD_STRING setFactoryWaypointXY(
106766: PUSH
106767: LD_VAR 0 3
106771: PUSH
106772: LD_VAR 0 2
106776: ARRAY
106777: PUSH
106778: LD_INT 1
106780: ARRAY
106781: STR
106782: PUSH
106783: LD_STRING ,
106785: STR
106786: PUSH
106787: LD_VAR 0 3
106791: PUSH
106792: LD_VAR 0 2
106796: ARRAY
106797: PUSH
106798: LD_INT 2
106800: ARRAY
106801: STR
106802: PUSH
106803: LD_STRING ,
106805: STR
106806: PUSH
106807: LD_VAR 0 3
106811: PUSH
106812: LD_VAR 0 2
106816: ARRAY
106817: PUSH
106818: LD_INT 3
106820: ARRAY
106821: STR
106822: PUSH
106823: LD_STRING ,
106825: STR
106826: PUSH
106827: LD_VAR 0 3
106831: PUSH
106832: LD_VAR 0 2
106836: ARRAY
106837: PUSH
106838: LD_INT 4
106840: ARRAY
106841: STR
106842: PUSH
106843: LD_STRING )
106845: STR
106846: PPUSH
106847: CALL_OW 559
106851: GO 106761
106853: POP
106854: POP
// end ; end ;
106855: LD_VAR 0 1
106859: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106860: LD_INT 0
106862: PPUSH
// if HexInfo ( x , y ) = warehouse then
106863: LD_VAR 0 2
106867: PPUSH
106868: LD_VAR 0 3
106872: PPUSH
106873: CALL_OW 428
106877: PUSH
106878: LD_VAR 0 1
106882: EQUAL
106883: IFFALSE 106910
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106885: LD_ADDR_EXP 136
106889: PUSH
106890: LD_EXP 136
106894: PPUSH
106895: LD_VAR 0 1
106899: PPUSH
106900: LD_INT 0
106902: PPUSH
106903: CALL_OW 1
106907: ST_TO_ADDR
106908: GO 106961
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106910: LD_ADDR_EXP 136
106914: PUSH
106915: LD_EXP 136
106919: PPUSH
106920: LD_VAR 0 1
106924: PPUSH
106925: LD_VAR 0 1
106929: PPUSH
106930: CALL_OW 255
106934: PUSH
106935: LD_VAR 0 1
106939: PUSH
106940: LD_VAR 0 2
106944: PUSH
106945: LD_VAR 0 3
106949: PUSH
106950: EMPTY
106951: LIST
106952: LIST
106953: LIST
106954: LIST
106955: PPUSH
106956: CALL_OW 1
106960: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106961: CALL 106970 0 0
// end ;
106965: LD_VAR 0 4
106969: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106970: LD_INT 0
106972: PPUSH
106973: PPUSH
106974: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106975: LD_STRING resetWarehouseGatheringPoints();
106977: PPUSH
106978: CALL_OW 559
// if warehouseGatheringPoints then
106982: LD_EXP 136
106986: IFFALSE 107112
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106988: LD_ADDR_VAR 0 3
106992: PUSH
106993: LD_EXP 136
106997: PPUSH
106998: CALL 61110 0 1
107002: ST_TO_ADDR
// for i := 1 to list do
107003: LD_ADDR_VAR 0 2
107007: PUSH
107008: DOUBLE
107009: LD_INT 1
107011: DEC
107012: ST_TO_ADDR
107013: LD_VAR 0 3
107017: PUSH
107018: FOR_TO
107019: IFFALSE 107110
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107021: LD_STRING setWarehouseGatheringPointXY(
107023: PUSH
107024: LD_VAR 0 3
107028: PUSH
107029: LD_VAR 0 2
107033: ARRAY
107034: PUSH
107035: LD_INT 1
107037: ARRAY
107038: STR
107039: PUSH
107040: LD_STRING ,
107042: STR
107043: PUSH
107044: LD_VAR 0 3
107048: PUSH
107049: LD_VAR 0 2
107053: ARRAY
107054: PUSH
107055: LD_INT 2
107057: ARRAY
107058: STR
107059: PUSH
107060: LD_STRING ,
107062: STR
107063: PUSH
107064: LD_VAR 0 3
107068: PUSH
107069: LD_VAR 0 2
107073: ARRAY
107074: PUSH
107075: LD_INT 3
107077: ARRAY
107078: STR
107079: PUSH
107080: LD_STRING ,
107082: STR
107083: PUSH
107084: LD_VAR 0 3
107088: PUSH
107089: LD_VAR 0 2
107093: ARRAY
107094: PUSH
107095: LD_INT 4
107097: ARRAY
107098: STR
107099: PUSH
107100: LD_STRING )
107102: STR
107103: PPUSH
107104: CALL_OW 559
107108: GO 107018
107110: POP
107111: POP
// end ; end ;
107112: LD_VAR 0 1
107116: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107117: LD_EXP 136
107121: IFFALSE 107806
107123: GO 107125
107125: DISABLE
107126: LD_INT 0
107128: PPUSH
107129: PPUSH
107130: PPUSH
107131: PPUSH
107132: PPUSH
107133: PPUSH
107134: PPUSH
107135: PPUSH
107136: PPUSH
// begin enable ;
107137: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107138: LD_ADDR_VAR 0 3
107142: PUSH
107143: LD_EXP 136
107147: PPUSH
107148: CALL 61110 0 1
107152: ST_TO_ADDR
// if not list then
107153: LD_VAR 0 3
107157: NOT
107158: IFFALSE 107162
// exit ;
107160: GO 107806
// for i := 1 to list do
107162: LD_ADDR_VAR 0 1
107166: PUSH
107167: DOUBLE
107168: LD_INT 1
107170: DEC
107171: ST_TO_ADDR
107172: LD_VAR 0 3
107176: PUSH
107177: FOR_TO
107178: IFFALSE 107804
// begin depot := list [ i ] [ 2 ] ;
107180: LD_ADDR_VAR 0 8
107184: PUSH
107185: LD_VAR 0 3
107189: PUSH
107190: LD_VAR 0 1
107194: ARRAY
107195: PUSH
107196: LD_INT 2
107198: ARRAY
107199: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107200: LD_ADDR_VAR 0 5
107204: PUSH
107205: LD_VAR 0 3
107209: PUSH
107210: LD_VAR 0 1
107214: ARRAY
107215: PUSH
107216: LD_INT 1
107218: ARRAY
107219: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107220: LD_VAR 0 8
107224: PPUSH
107225: CALL_OW 301
107229: PUSH
107230: LD_VAR 0 5
107234: PUSH
107235: LD_VAR 0 8
107239: PPUSH
107240: CALL_OW 255
107244: NONEQUAL
107245: OR
107246: IFFALSE 107275
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107248: LD_ADDR_EXP 136
107252: PUSH
107253: LD_EXP 136
107257: PPUSH
107258: LD_VAR 0 8
107262: PPUSH
107263: LD_INT 0
107265: PPUSH
107266: CALL_OW 1
107270: ST_TO_ADDR
// exit ;
107271: POP
107272: POP
107273: GO 107806
// end ; x := list [ i ] [ 3 ] ;
107275: LD_ADDR_VAR 0 6
107279: PUSH
107280: LD_VAR 0 3
107284: PUSH
107285: LD_VAR 0 1
107289: ARRAY
107290: PUSH
107291: LD_INT 3
107293: ARRAY
107294: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107295: LD_ADDR_VAR 0 7
107299: PUSH
107300: LD_VAR 0 3
107304: PUSH
107305: LD_VAR 0 1
107309: ARRAY
107310: PUSH
107311: LD_INT 4
107313: ARRAY
107314: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107315: LD_ADDR_VAR 0 9
107319: PUSH
107320: LD_VAR 0 6
107324: PPUSH
107325: LD_VAR 0 7
107329: PPUSH
107330: LD_INT 16
107332: PPUSH
107333: CALL 59698 0 3
107337: ST_TO_ADDR
// if not cratesNearbyPoint then
107338: LD_VAR 0 9
107342: NOT
107343: IFFALSE 107349
// exit ;
107345: POP
107346: POP
107347: GO 107806
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107349: LD_ADDR_VAR 0 4
107353: PUSH
107354: LD_INT 22
107356: PUSH
107357: LD_VAR 0 5
107361: PUSH
107362: EMPTY
107363: LIST
107364: LIST
107365: PUSH
107366: LD_INT 3
107368: PUSH
107369: LD_INT 60
107371: PUSH
107372: EMPTY
107373: LIST
107374: PUSH
107375: EMPTY
107376: LIST
107377: LIST
107378: PUSH
107379: LD_INT 91
107381: PUSH
107382: LD_VAR 0 8
107386: PUSH
107387: LD_INT 6
107389: PUSH
107390: EMPTY
107391: LIST
107392: LIST
107393: LIST
107394: PUSH
107395: LD_INT 2
107397: PUSH
107398: LD_INT 25
107400: PUSH
107401: LD_INT 2
107403: PUSH
107404: EMPTY
107405: LIST
107406: LIST
107407: PUSH
107408: LD_INT 25
107410: PUSH
107411: LD_INT 16
107413: PUSH
107414: EMPTY
107415: LIST
107416: LIST
107417: PUSH
107418: EMPTY
107419: LIST
107420: LIST
107421: LIST
107422: PUSH
107423: EMPTY
107424: LIST
107425: LIST
107426: LIST
107427: LIST
107428: PPUSH
107429: CALL_OW 69
107433: PUSH
107434: LD_VAR 0 8
107438: PPUSH
107439: CALL_OW 313
107443: PPUSH
107444: LD_INT 3
107446: PUSH
107447: LD_INT 60
107449: PUSH
107450: EMPTY
107451: LIST
107452: PUSH
107453: EMPTY
107454: LIST
107455: LIST
107456: PUSH
107457: LD_INT 2
107459: PUSH
107460: LD_INT 25
107462: PUSH
107463: LD_INT 2
107465: PUSH
107466: EMPTY
107467: LIST
107468: LIST
107469: PUSH
107470: LD_INT 25
107472: PUSH
107473: LD_INT 16
107475: PUSH
107476: EMPTY
107477: LIST
107478: LIST
107479: PUSH
107480: EMPTY
107481: LIST
107482: LIST
107483: LIST
107484: PUSH
107485: EMPTY
107486: LIST
107487: LIST
107488: PPUSH
107489: CALL_OW 72
107493: UNION
107494: ST_TO_ADDR
// if tmp then
107495: LD_VAR 0 4
107499: IFFALSE 107579
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107501: LD_ADDR_VAR 0 4
107505: PUSH
107506: LD_VAR 0 4
107510: PPUSH
107511: LD_INT 3
107513: PPUSH
107514: CALL 57667 0 2
107518: ST_TO_ADDR
// for j in tmp do
107519: LD_ADDR_VAR 0 2
107523: PUSH
107524: LD_VAR 0 4
107528: PUSH
107529: FOR_IN
107530: IFFALSE 107573
// begin if IsInUnit ( j ) then
107532: LD_VAR 0 2
107536: PPUSH
107537: CALL_OW 310
107541: IFFALSE 107552
// ComExit ( j ) ;
107543: LD_VAR 0 2
107547: PPUSH
107548: CALL 57750 0 1
// AddComCollect ( j , x , y ) ;
107552: LD_VAR 0 2
107556: PPUSH
107557: LD_VAR 0 6
107561: PPUSH
107562: LD_VAR 0 7
107566: PPUSH
107567: CALL_OW 177
// end ;
107571: GO 107529
107573: POP
107574: POP
// exit ;
107575: POP
107576: POP
107577: GO 107806
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107579: LD_ADDR_VAR 0 4
107583: PUSH
107584: LD_INT 22
107586: PUSH
107587: LD_VAR 0 5
107591: PUSH
107592: EMPTY
107593: LIST
107594: LIST
107595: PUSH
107596: LD_INT 91
107598: PUSH
107599: LD_VAR 0 8
107603: PUSH
107604: LD_INT 8
107606: PUSH
107607: EMPTY
107608: LIST
107609: LIST
107610: LIST
107611: PUSH
107612: LD_INT 2
107614: PUSH
107615: LD_INT 34
107617: PUSH
107618: LD_INT 12
107620: PUSH
107621: EMPTY
107622: LIST
107623: LIST
107624: PUSH
107625: LD_INT 34
107627: PUSH
107628: LD_INT 51
107630: PUSH
107631: EMPTY
107632: LIST
107633: LIST
107634: PUSH
107635: LD_INT 34
107637: PUSH
107638: LD_INT 32
107640: PUSH
107641: EMPTY
107642: LIST
107643: LIST
107644: PUSH
107645: LD_INT 34
107647: PUSH
107648: LD_INT 89
107650: PUSH
107651: EMPTY
107652: LIST
107653: LIST
107654: PUSH
107655: EMPTY
107656: LIST
107657: LIST
107658: LIST
107659: LIST
107660: LIST
107661: PUSH
107662: EMPTY
107663: LIST
107664: LIST
107665: LIST
107666: PPUSH
107667: CALL_OW 69
107671: ST_TO_ADDR
// if tmp then
107672: LD_VAR 0 4
107676: IFFALSE 107802
// begin for j in tmp do
107678: LD_ADDR_VAR 0 2
107682: PUSH
107683: LD_VAR 0 4
107687: PUSH
107688: FOR_IN
107689: IFFALSE 107800
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107691: LD_VAR 0 2
107695: PPUSH
107696: CALL_OW 262
107700: PUSH
107701: LD_INT 3
107703: EQUAL
107704: PUSH
107705: LD_VAR 0 2
107709: PPUSH
107710: CALL_OW 261
107714: PUSH
107715: LD_INT 20
107717: GREATER
107718: OR
107719: PUSH
107720: LD_VAR 0 2
107724: PPUSH
107725: CALL_OW 314
107729: NOT
107730: AND
107731: PUSH
107732: LD_VAR 0 2
107736: PPUSH
107737: CALL_OW 263
107741: PUSH
107742: LD_INT 1
107744: NONEQUAL
107745: PUSH
107746: LD_VAR 0 2
107750: PPUSH
107751: CALL_OW 311
107755: OR
107756: AND
107757: IFFALSE 107798
// begin ComCollect ( j , x , y ) ;
107759: LD_VAR 0 2
107763: PPUSH
107764: LD_VAR 0 6
107768: PPUSH
107769: LD_VAR 0 7
107773: PPUSH
107774: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107778: LD_VAR 0 2
107782: PPUSH
107783: LD_VAR 0 8
107787: PPUSH
107788: CALL_OW 172
// exit ;
107792: POP
107793: POP
107794: POP
107795: POP
107796: GO 107806
// end ;
107798: GO 107688
107800: POP
107801: POP
// end ; end ;
107802: GO 107177
107804: POP
107805: POP
// end ; end_of_file
107806: PPOPN 9
107808: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107809: LD_INT 0
107811: PPUSH
107812: PPUSH
107813: PPUSH
107814: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107815: LD_VAR 0 1
107819: PPUSH
107820: CALL_OW 264
107824: PUSH
107825: LD_INT 91
107827: EQUAL
107828: IFFALSE 107900
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107830: LD_INT 68
107832: PPUSH
107833: LD_VAR 0 1
107837: PPUSH
107838: CALL_OW 255
107842: PPUSH
107843: CALL_OW 321
107847: PUSH
107848: LD_INT 2
107850: EQUAL
107851: IFFALSE 107863
// eff := 70 else
107853: LD_ADDR_VAR 0 4
107857: PUSH
107858: LD_INT 70
107860: ST_TO_ADDR
107861: GO 107871
// eff := 30 ;
107863: LD_ADDR_VAR 0 4
107867: PUSH
107868: LD_INT 30
107870: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107871: LD_VAR 0 1
107875: PPUSH
107876: CALL_OW 250
107880: PPUSH
107881: LD_VAR 0 1
107885: PPUSH
107886: CALL_OW 251
107890: PPUSH
107891: LD_VAR 0 4
107895: PPUSH
107896: CALL_OW 495
// end ; end ;
107900: LD_VAR 0 2
107904: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107905: LD_INT 0
107907: PPUSH
// end ;
107908: LD_VAR 0 4
107912: RET
// export function SOS_Command ( cmd ) ; begin
107913: LD_INT 0
107915: PPUSH
// end ;
107916: LD_VAR 0 2
107920: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107921: LD_INT 0
107923: PPUSH
// end ;
107924: LD_VAR 0 6
107928: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107929: LD_INT 0
107931: PPUSH
107932: PPUSH
// if not vehicle or not factory then
107933: LD_VAR 0 1
107937: NOT
107938: PUSH
107939: LD_VAR 0 2
107943: NOT
107944: OR
107945: IFFALSE 107949
// exit ;
107947: GO 108180
// if factoryWaypoints >= factory then
107949: LD_EXP 135
107953: PUSH
107954: LD_VAR 0 2
107958: GREATEREQUAL
107959: IFFALSE 108180
// if factoryWaypoints [ factory ] then
107961: LD_EXP 135
107965: PUSH
107966: LD_VAR 0 2
107970: ARRAY
107971: IFFALSE 108180
// begin if GetControl ( vehicle ) = control_manual then
107973: LD_VAR 0 1
107977: PPUSH
107978: CALL_OW 263
107982: PUSH
107983: LD_INT 1
107985: EQUAL
107986: IFFALSE 108067
// begin driver := IsDrivenBy ( vehicle ) ;
107988: LD_ADDR_VAR 0 4
107992: PUSH
107993: LD_VAR 0 1
107997: PPUSH
107998: CALL_OW 311
108002: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108003: LD_VAR 0 4
108007: PPUSH
108008: LD_EXP 135
108012: PUSH
108013: LD_VAR 0 2
108017: ARRAY
108018: PUSH
108019: LD_INT 3
108021: ARRAY
108022: PPUSH
108023: LD_EXP 135
108027: PUSH
108028: LD_VAR 0 2
108032: ARRAY
108033: PUSH
108034: LD_INT 4
108036: ARRAY
108037: PPUSH
108038: CALL_OW 171
// AddComExitVehicle ( driver ) ;
108042: LD_VAR 0 4
108046: PPUSH
108047: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
108051: LD_VAR 0 4
108055: PPUSH
108056: LD_VAR 0 2
108060: PPUSH
108061: CALL_OW 180
// end else
108065: GO 108180
// if GetControl ( vehicle ) = control_remote then
108067: LD_VAR 0 1
108071: PPUSH
108072: CALL_OW 263
108076: PUSH
108077: LD_INT 2
108079: EQUAL
108080: IFFALSE 108141
// begin wait ( 0 0$2 ) ;
108082: LD_INT 70
108084: PPUSH
108085: CALL_OW 67
// if Connect ( vehicle ) then
108089: LD_VAR 0 1
108093: PPUSH
108094: CALL 27990 0 1
108098: IFFALSE 108139
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108100: LD_VAR 0 1
108104: PPUSH
108105: LD_EXP 135
108109: PUSH
108110: LD_VAR 0 2
108114: ARRAY
108115: PUSH
108116: LD_INT 3
108118: ARRAY
108119: PPUSH
108120: LD_EXP 135
108124: PUSH
108125: LD_VAR 0 2
108129: ARRAY
108130: PUSH
108131: LD_INT 4
108133: ARRAY
108134: PPUSH
108135: CALL_OW 171
// end else
108139: GO 108180
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108141: LD_VAR 0 1
108145: PPUSH
108146: LD_EXP 135
108150: PUSH
108151: LD_VAR 0 2
108155: ARRAY
108156: PUSH
108157: LD_INT 3
108159: ARRAY
108160: PPUSH
108161: LD_EXP 135
108165: PUSH
108166: LD_VAR 0 2
108170: ARRAY
108171: PUSH
108172: LD_INT 4
108174: ARRAY
108175: PPUSH
108176: CALL_OW 171
// end ; end ;
108180: LD_VAR 0 3
108184: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108185: LD_INT 0
108187: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108188: LD_VAR 0 1
108192: PUSH
108193: LD_INT 250
108195: EQUAL
108196: PUSH
108197: LD_VAR 0 2
108201: PPUSH
108202: CALL_OW 264
108206: PUSH
108207: LD_INT 81
108209: EQUAL
108210: AND
108211: IFFALSE 108232
// MinerPlaceMine ( unit , x , y ) ;
108213: LD_VAR 0 2
108217: PPUSH
108218: LD_VAR 0 4
108222: PPUSH
108223: LD_VAR 0 5
108227: PPUSH
108228: CALL 110617 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108232: LD_VAR 0 1
108236: PUSH
108237: LD_INT 251
108239: EQUAL
108240: PUSH
108241: LD_VAR 0 2
108245: PPUSH
108246: CALL_OW 264
108250: PUSH
108251: LD_INT 81
108253: EQUAL
108254: AND
108255: IFFALSE 108276
// MinerDetonateMine ( unit , x , y ) ;
108257: LD_VAR 0 2
108261: PPUSH
108262: LD_VAR 0 4
108266: PPUSH
108267: LD_VAR 0 5
108271: PPUSH
108272: CALL 110892 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108276: LD_VAR 0 1
108280: PUSH
108281: LD_INT 252
108283: EQUAL
108284: PUSH
108285: LD_VAR 0 2
108289: PPUSH
108290: CALL_OW 264
108294: PUSH
108295: LD_INT 81
108297: EQUAL
108298: AND
108299: IFFALSE 108320
// MinerCreateMinefield ( unit , x , y ) ;
108301: LD_VAR 0 2
108305: PPUSH
108306: LD_VAR 0 4
108310: PPUSH
108311: LD_VAR 0 5
108315: PPUSH
108316: CALL 111309 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108320: LD_VAR 0 1
108324: PUSH
108325: LD_INT 253
108327: EQUAL
108328: PUSH
108329: LD_VAR 0 2
108333: PPUSH
108334: CALL_OW 257
108338: PUSH
108339: LD_INT 5
108341: EQUAL
108342: AND
108343: IFFALSE 108364
// ComBinocular ( unit , x , y ) ;
108345: LD_VAR 0 2
108349: PPUSH
108350: LD_VAR 0 4
108354: PPUSH
108355: LD_VAR 0 5
108359: PPUSH
108360: CALL 111678 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108364: LD_VAR 0 1
108368: PUSH
108369: LD_INT 254
108371: EQUAL
108372: PUSH
108373: LD_VAR 0 2
108377: PPUSH
108378: CALL_OW 264
108382: PUSH
108383: LD_INT 99
108385: EQUAL
108386: AND
108387: PUSH
108388: LD_VAR 0 3
108392: PPUSH
108393: CALL_OW 263
108397: PUSH
108398: LD_INT 3
108400: EQUAL
108401: AND
108402: IFFALSE 108418
// HackDestroyVehicle ( unit , selectedUnit ) ;
108404: LD_VAR 0 2
108408: PPUSH
108409: LD_VAR 0 3
108413: PPUSH
108414: CALL 109981 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108418: LD_VAR 0 1
108422: PUSH
108423: LD_INT 255
108425: EQUAL
108426: PUSH
108427: LD_VAR 0 2
108431: PPUSH
108432: CALL_OW 264
108436: PUSH
108437: LD_INT 14
108439: PUSH
108440: LD_INT 53
108442: PUSH
108443: EMPTY
108444: LIST
108445: LIST
108446: IN
108447: AND
108448: PUSH
108449: LD_VAR 0 4
108453: PPUSH
108454: LD_VAR 0 5
108458: PPUSH
108459: CALL_OW 488
108463: AND
108464: IFFALSE 108488
// CutTreeXYR ( unit , x , y , 12 ) ;
108466: LD_VAR 0 2
108470: PPUSH
108471: LD_VAR 0 4
108475: PPUSH
108476: LD_VAR 0 5
108480: PPUSH
108481: LD_INT 12
108483: PPUSH
108484: CALL 108551 0 4
// if cmd = 256 then
108488: LD_VAR 0 1
108492: PUSH
108493: LD_INT 256
108495: EQUAL
108496: IFFALSE 108517
// SetFactoryWaypoint ( unit , x , y ) ;
108498: LD_VAR 0 2
108502: PPUSH
108503: LD_VAR 0 4
108507: PPUSH
108508: LD_VAR 0 5
108512: PPUSH
108513: CALL 106498 0 3
// if cmd = 257 then
108517: LD_VAR 0 1
108521: PUSH
108522: LD_INT 257
108524: EQUAL
108525: IFFALSE 108546
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108527: LD_VAR 0 2
108531: PPUSH
108532: LD_VAR 0 4
108536: PPUSH
108537: LD_VAR 0 5
108541: PPUSH
108542: CALL 106860 0 3
// end ;
108546: LD_VAR 0 6
108550: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108551: LD_INT 0
108553: PPUSH
108554: PPUSH
108555: PPUSH
108556: PPUSH
108557: PPUSH
108558: PPUSH
108559: PPUSH
108560: PPUSH
108561: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108562: LD_VAR 0 1
108566: NOT
108567: PUSH
108568: LD_VAR 0 2
108572: PPUSH
108573: LD_VAR 0 3
108577: PPUSH
108578: CALL_OW 488
108582: NOT
108583: OR
108584: PUSH
108585: LD_VAR 0 4
108589: NOT
108590: OR
108591: IFFALSE 108595
// exit ;
108593: GO 108935
// list := [ ] ;
108595: LD_ADDR_VAR 0 13
108599: PUSH
108600: EMPTY
108601: ST_TO_ADDR
// if x - r < 0 then
108602: LD_VAR 0 2
108606: PUSH
108607: LD_VAR 0 4
108611: MINUS
108612: PUSH
108613: LD_INT 0
108615: LESS
108616: IFFALSE 108628
// min_x := 0 else
108618: LD_ADDR_VAR 0 7
108622: PUSH
108623: LD_INT 0
108625: ST_TO_ADDR
108626: GO 108644
// min_x := x - r ;
108628: LD_ADDR_VAR 0 7
108632: PUSH
108633: LD_VAR 0 2
108637: PUSH
108638: LD_VAR 0 4
108642: MINUS
108643: ST_TO_ADDR
// if y - r < 0 then
108644: LD_VAR 0 3
108648: PUSH
108649: LD_VAR 0 4
108653: MINUS
108654: PUSH
108655: LD_INT 0
108657: LESS
108658: IFFALSE 108670
// min_y := 0 else
108660: LD_ADDR_VAR 0 8
108664: PUSH
108665: LD_INT 0
108667: ST_TO_ADDR
108668: GO 108686
// min_y := y - r ;
108670: LD_ADDR_VAR 0 8
108674: PUSH
108675: LD_VAR 0 3
108679: PUSH
108680: LD_VAR 0 4
108684: MINUS
108685: ST_TO_ADDR
// max_x := x + r ;
108686: LD_ADDR_VAR 0 9
108690: PUSH
108691: LD_VAR 0 2
108695: PUSH
108696: LD_VAR 0 4
108700: PLUS
108701: ST_TO_ADDR
// max_y := y + r ;
108702: LD_ADDR_VAR 0 10
108706: PUSH
108707: LD_VAR 0 3
108711: PUSH
108712: LD_VAR 0 4
108716: PLUS
108717: ST_TO_ADDR
// for _x = min_x to max_x do
108718: LD_ADDR_VAR 0 11
108722: PUSH
108723: DOUBLE
108724: LD_VAR 0 7
108728: DEC
108729: ST_TO_ADDR
108730: LD_VAR 0 9
108734: PUSH
108735: FOR_TO
108736: IFFALSE 108853
// for _y = min_y to max_y do
108738: LD_ADDR_VAR 0 12
108742: PUSH
108743: DOUBLE
108744: LD_VAR 0 8
108748: DEC
108749: ST_TO_ADDR
108750: LD_VAR 0 10
108754: PUSH
108755: FOR_TO
108756: IFFALSE 108849
// begin if not ValidHex ( _x , _y ) then
108758: LD_VAR 0 11
108762: PPUSH
108763: LD_VAR 0 12
108767: PPUSH
108768: CALL_OW 488
108772: NOT
108773: IFFALSE 108777
// continue ;
108775: GO 108755
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108777: LD_VAR 0 11
108781: PPUSH
108782: LD_VAR 0 12
108786: PPUSH
108787: CALL_OW 351
108791: PUSH
108792: LD_VAR 0 11
108796: PPUSH
108797: LD_VAR 0 12
108801: PPUSH
108802: CALL_OW 554
108806: AND
108807: IFFALSE 108847
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108809: LD_ADDR_VAR 0 13
108813: PUSH
108814: LD_VAR 0 13
108818: PPUSH
108819: LD_VAR 0 13
108823: PUSH
108824: LD_INT 1
108826: PLUS
108827: PPUSH
108828: LD_VAR 0 11
108832: PUSH
108833: LD_VAR 0 12
108837: PUSH
108838: EMPTY
108839: LIST
108840: LIST
108841: PPUSH
108842: CALL_OW 2
108846: ST_TO_ADDR
// end ;
108847: GO 108755
108849: POP
108850: POP
108851: GO 108735
108853: POP
108854: POP
// if not list then
108855: LD_VAR 0 13
108859: NOT
108860: IFFALSE 108864
// exit ;
108862: GO 108935
// for i in list do
108864: LD_ADDR_VAR 0 6
108868: PUSH
108869: LD_VAR 0 13
108873: PUSH
108874: FOR_IN
108875: IFFALSE 108933
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108877: LD_VAR 0 1
108881: PPUSH
108882: LD_STRING M
108884: PUSH
108885: LD_VAR 0 6
108889: PUSH
108890: LD_INT 1
108892: ARRAY
108893: PUSH
108894: LD_VAR 0 6
108898: PUSH
108899: LD_INT 2
108901: ARRAY
108902: PUSH
108903: LD_INT 0
108905: PUSH
108906: LD_INT 0
108908: PUSH
108909: LD_INT 0
108911: PUSH
108912: LD_INT 0
108914: PUSH
108915: EMPTY
108916: LIST
108917: LIST
108918: LIST
108919: LIST
108920: LIST
108921: LIST
108922: LIST
108923: PUSH
108924: EMPTY
108925: LIST
108926: PPUSH
108927: CALL_OW 447
108931: GO 108874
108933: POP
108934: POP
// end ;
108935: LD_VAR 0 5
108939: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108940: LD_EXP 138
108944: NOT
108945: IFFALSE 108995
108947: GO 108949
108949: DISABLE
// begin initHack := true ;
108950: LD_ADDR_EXP 138
108954: PUSH
108955: LD_INT 1
108957: ST_TO_ADDR
// hackTanks := [ ] ;
108958: LD_ADDR_EXP 139
108962: PUSH
108963: EMPTY
108964: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108965: LD_ADDR_EXP 140
108969: PUSH
108970: EMPTY
108971: ST_TO_ADDR
// hackLimit := 3 ;
108972: LD_ADDR_EXP 141
108976: PUSH
108977: LD_INT 3
108979: ST_TO_ADDR
// hackDist := 12 ;
108980: LD_ADDR_EXP 142
108984: PUSH
108985: LD_INT 12
108987: ST_TO_ADDR
// hackCounter := [ ] ;
108988: LD_ADDR_EXP 143
108992: PUSH
108993: EMPTY
108994: ST_TO_ADDR
// end ;
108995: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108996: LD_EXP 138
109000: PUSH
109001: LD_INT 34
109003: PUSH
109004: LD_INT 99
109006: PUSH
109007: EMPTY
109008: LIST
109009: LIST
109010: PPUSH
109011: CALL_OW 69
109015: AND
109016: IFFALSE 109269
109018: GO 109020
109020: DISABLE
109021: LD_INT 0
109023: PPUSH
109024: PPUSH
// begin enable ;
109025: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
109026: LD_ADDR_VAR 0 1
109030: PUSH
109031: LD_INT 34
109033: PUSH
109034: LD_INT 99
109036: PUSH
109037: EMPTY
109038: LIST
109039: LIST
109040: PPUSH
109041: CALL_OW 69
109045: PUSH
109046: FOR_IN
109047: IFFALSE 109267
// begin if not i in hackTanks then
109049: LD_VAR 0 1
109053: PUSH
109054: LD_EXP 139
109058: IN
109059: NOT
109060: IFFALSE 109143
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
109062: LD_ADDR_EXP 139
109066: PUSH
109067: LD_EXP 139
109071: PPUSH
109072: LD_EXP 139
109076: PUSH
109077: LD_INT 1
109079: PLUS
109080: PPUSH
109081: LD_VAR 0 1
109085: PPUSH
109086: CALL_OW 1
109090: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109091: LD_ADDR_EXP 140
109095: PUSH
109096: LD_EXP 140
109100: PPUSH
109101: LD_EXP 140
109105: PUSH
109106: LD_INT 1
109108: PLUS
109109: PPUSH
109110: EMPTY
109111: PPUSH
109112: CALL_OW 1
109116: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
109117: LD_ADDR_EXP 143
109121: PUSH
109122: LD_EXP 143
109126: PPUSH
109127: LD_EXP 143
109131: PUSH
109132: LD_INT 1
109134: PLUS
109135: PPUSH
109136: EMPTY
109137: PPUSH
109138: CALL_OW 1
109142: ST_TO_ADDR
// end ; if not IsOk ( i ) then
109143: LD_VAR 0 1
109147: PPUSH
109148: CALL_OW 302
109152: NOT
109153: IFFALSE 109166
// begin HackUnlinkAll ( i ) ;
109155: LD_VAR 0 1
109159: PPUSH
109160: CALL 109272 0 1
// continue ;
109164: GO 109046
// end ; HackCheckCapturedStatus ( i ) ;
109166: LD_VAR 0 1
109170: PPUSH
109171: CALL 109715 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
109175: LD_ADDR_VAR 0 2
109179: PUSH
109180: LD_INT 81
109182: PUSH
109183: LD_VAR 0 1
109187: PPUSH
109188: CALL_OW 255
109192: PUSH
109193: EMPTY
109194: LIST
109195: LIST
109196: PUSH
109197: LD_INT 33
109199: PUSH
109200: LD_INT 3
109202: PUSH
109203: EMPTY
109204: LIST
109205: LIST
109206: PUSH
109207: LD_INT 91
109209: PUSH
109210: LD_VAR 0 1
109214: PUSH
109215: LD_EXP 142
109219: PUSH
109220: EMPTY
109221: LIST
109222: LIST
109223: LIST
109224: PUSH
109225: LD_INT 50
109227: PUSH
109228: EMPTY
109229: LIST
109230: PUSH
109231: EMPTY
109232: LIST
109233: LIST
109234: LIST
109235: LIST
109236: PPUSH
109237: CALL_OW 69
109241: ST_TO_ADDR
// if not tmp then
109242: LD_VAR 0 2
109246: NOT
109247: IFFALSE 109251
// continue ;
109249: GO 109046
// HackLink ( i , tmp ) ;
109251: LD_VAR 0 1
109255: PPUSH
109256: LD_VAR 0 2
109260: PPUSH
109261: CALL 109408 0 2
// end ;
109265: GO 109046
109267: POP
109268: POP
// end ;
109269: PPOPN 2
109271: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109272: LD_INT 0
109274: PPUSH
109275: PPUSH
109276: PPUSH
// if not hack in hackTanks then
109277: LD_VAR 0 1
109281: PUSH
109282: LD_EXP 139
109286: IN
109287: NOT
109288: IFFALSE 109292
// exit ;
109290: GO 109403
// index := GetElementIndex ( hackTanks , hack ) ;
109292: LD_ADDR_VAR 0 4
109296: PUSH
109297: LD_EXP 139
109301: PPUSH
109302: LD_VAR 0 1
109306: PPUSH
109307: CALL 24806 0 2
109311: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109312: LD_EXP 140
109316: PUSH
109317: LD_VAR 0 4
109321: ARRAY
109322: IFFALSE 109403
// begin for i in hackTanksCaptured [ index ] do
109324: LD_ADDR_VAR 0 3
109328: PUSH
109329: LD_EXP 140
109333: PUSH
109334: LD_VAR 0 4
109338: ARRAY
109339: PUSH
109340: FOR_IN
109341: IFFALSE 109367
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109343: LD_VAR 0 3
109347: PUSH
109348: LD_INT 1
109350: ARRAY
109351: PPUSH
109352: LD_VAR 0 3
109356: PUSH
109357: LD_INT 2
109359: ARRAY
109360: PPUSH
109361: CALL_OW 235
109365: GO 109340
109367: POP
109368: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109369: LD_ADDR_EXP 140
109373: PUSH
109374: LD_EXP 140
109378: PPUSH
109379: LD_VAR 0 4
109383: PPUSH
109384: EMPTY
109385: PPUSH
109386: CALL_OW 1
109390: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109391: LD_VAR 0 1
109395: PPUSH
109396: LD_INT 0
109398: PPUSH
109399: CALL_OW 505
// end ; end ;
109403: LD_VAR 0 2
109407: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109408: LD_INT 0
109410: PPUSH
109411: PPUSH
109412: PPUSH
// if not hack in hackTanks or not vehicles then
109413: LD_VAR 0 1
109417: PUSH
109418: LD_EXP 139
109422: IN
109423: NOT
109424: PUSH
109425: LD_VAR 0 2
109429: NOT
109430: OR
109431: IFFALSE 109435
// exit ;
109433: GO 109710
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109435: LD_ADDR_VAR 0 2
109439: PUSH
109440: LD_VAR 0 1
109444: PPUSH
109445: LD_VAR 0 2
109449: PPUSH
109450: LD_INT 1
109452: PPUSH
109453: LD_INT 1
109455: PPUSH
109456: CALL 25456 0 4
109460: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109461: LD_ADDR_VAR 0 5
109465: PUSH
109466: LD_EXP 139
109470: PPUSH
109471: LD_VAR 0 1
109475: PPUSH
109476: CALL 24806 0 2
109480: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109481: LD_EXP 140
109485: PUSH
109486: LD_VAR 0 5
109490: ARRAY
109491: PUSH
109492: LD_EXP 141
109496: LESS
109497: IFFALSE 109686
// begin for i := 1 to vehicles do
109499: LD_ADDR_VAR 0 4
109503: PUSH
109504: DOUBLE
109505: LD_INT 1
109507: DEC
109508: ST_TO_ADDR
109509: LD_VAR 0 2
109513: PUSH
109514: FOR_TO
109515: IFFALSE 109684
// begin if hackTanksCaptured [ index ] = hackLimit then
109517: LD_EXP 140
109521: PUSH
109522: LD_VAR 0 5
109526: ARRAY
109527: PUSH
109528: LD_EXP 141
109532: EQUAL
109533: IFFALSE 109537
// break ;
109535: GO 109684
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109537: LD_ADDR_EXP 143
109541: PUSH
109542: LD_EXP 143
109546: PPUSH
109547: LD_VAR 0 5
109551: PPUSH
109552: LD_EXP 143
109556: PUSH
109557: LD_VAR 0 5
109561: ARRAY
109562: PUSH
109563: LD_INT 1
109565: PLUS
109566: PPUSH
109567: CALL_OW 1
109571: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109572: LD_ADDR_EXP 140
109576: PUSH
109577: LD_EXP 140
109581: PPUSH
109582: LD_VAR 0 5
109586: PUSH
109587: LD_EXP 140
109591: PUSH
109592: LD_VAR 0 5
109596: ARRAY
109597: PUSH
109598: LD_INT 1
109600: PLUS
109601: PUSH
109602: EMPTY
109603: LIST
109604: LIST
109605: PPUSH
109606: LD_VAR 0 2
109610: PUSH
109611: LD_VAR 0 4
109615: ARRAY
109616: PUSH
109617: LD_VAR 0 2
109621: PUSH
109622: LD_VAR 0 4
109626: ARRAY
109627: PPUSH
109628: CALL_OW 255
109632: PUSH
109633: EMPTY
109634: LIST
109635: LIST
109636: PPUSH
109637: CALL 25021 0 3
109641: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109642: LD_VAR 0 2
109646: PUSH
109647: LD_VAR 0 4
109651: ARRAY
109652: PPUSH
109653: LD_VAR 0 1
109657: PPUSH
109658: CALL_OW 255
109662: PPUSH
109663: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109667: LD_VAR 0 2
109671: PUSH
109672: LD_VAR 0 4
109676: ARRAY
109677: PPUSH
109678: CALL_OW 141
// end ;
109682: GO 109514
109684: POP
109685: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109686: LD_VAR 0 1
109690: PPUSH
109691: LD_EXP 140
109695: PUSH
109696: LD_VAR 0 5
109700: ARRAY
109701: PUSH
109702: LD_INT 0
109704: PLUS
109705: PPUSH
109706: CALL_OW 505
// end ;
109710: LD_VAR 0 3
109714: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109715: LD_INT 0
109717: PPUSH
109718: PPUSH
109719: PPUSH
109720: PPUSH
// if not hack in hackTanks then
109721: LD_VAR 0 1
109725: PUSH
109726: LD_EXP 139
109730: IN
109731: NOT
109732: IFFALSE 109736
// exit ;
109734: GO 109976
// index := GetElementIndex ( hackTanks , hack ) ;
109736: LD_ADDR_VAR 0 4
109740: PUSH
109741: LD_EXP 139
109745: PPUSH
109746: LD_VAR 0 1
109750: PPUSH
109751: CALL 24806 0 2
109755: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109756: LD_ADDR_VAR 0 3
109760: PUSH
109761: DOUBLE
109762: LD_EXP 140
109766: PUSH
109767: LD_VAR 0 4
109771: ARRAY
109772: INC
109773: ST_TO_ADDR
109774: LD_INT 1
109776: PUSH
109777: FOR_DOWNTO
109778: IFFALSE 109950
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109780: LD_ADDR_VAR 0 5
109784: PUSH
109785: LD_EXP 140
109789: PUSH
109790: LD_VAR 0 4
109794: ARRAY
109795: PUSH
109796: LD_VAR 0 3
109800: ARRAY
109801: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109802: LD_VAR 0 5
109806: PUSH
109807: LD_INT 1
109809: ARRAY
109810: PPUSH
109811: CALL_OW 302
109815: NOT
109816: PUSH
109817: LD_VAR 0 5
109821: PUSH
109822: LD_INT 1
109824: ARRAY
109825: PPUSH
109826: CALL_OW 255
109830: PUSH
109831: LD_VAR 0 1
109835: PPUSH
109836: CALL_OW 255
109840: NONEQUAL
109841: OR
109842: IFFALSE 109948
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109844: LD_VAR 0 5
109848: PUSH
109849: LD_INT 1
109851: ARRAY
109852: PPUSH
109853: CALL_OW 305
109857: PUSH
109858: LD_VAR 0 5
109862: PUSH
109863: LD_INT 1
109865: ARRAY
109866: PPUSH
109867: CALL_OW 255
109871: PUSH
109872: LD_VAR 0 1
109876: PPUSH
109877: CALL_OW 255
109881: EQUAL
109882: AND
109883: IFFALSE 109907
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109885: LD_VAR 0 5
109889: PUSH
109890: LD_INT 1
109892: ARRAY
109893: PPUSH
109894: LD_VAR 0 5
109898: PUSH
109899: LD_INT 2
109901: ARRAY
109902: PPUSH
109903: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109907: LD_ADDR_EXP 140
109911: PUSH
109912: LD_EXP 140
109916: PPUSH
109917: LD_VAR 0 4
109921: PPUSH
109922: LD_EXP 140
109926: PUSH
109927: LD_VAR 0 4
109931: ARRAY
109932: PPUSH
109933: LD_VAR 0 3
109937: PPUSH
109938: CALL_OW 3
109942: PPUSH
109943: CALL_OW 1
109947: ST_TO_ADDR
// end ; end ;
109948: GO 109777
109950: POP
109951: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109952: LD_VAR 0 1
109956: PPUSH
109957: LD_EXP 140
109961: PUSH
109962: LD_VAR 0 4
109966: ARRAY
109967: PUSH
109968: LD_INT 0
109970: PLUS
109971: PPUSH
109972: CALL_OW 505
// end ;
109976: LD_VAR 0 2
109980: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109981: LD_INT 0
109983: PPUSH
109984: PPUSH
109985: PPUSH
109986: PPUSH
// if not hack in hackTanks then
109987: LD_VAR 0 1
109991: PUSH
109992: LD_EXP 139
109996: IN
109997: NOT
109998: IFFALSE 110002
// exit ;
110000: GO 110087
// index := GetElementIndex ( hackTanks , hack ) ;
110002: LD_ADDR_VAR 0 5
110006: PUSH
110007: LD_EXP 139
110011: PPUSH
110012: LD_VAR 0 1
110016: PPUSH
110017: CALL 24806 0 2
110021: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
110022: LD_ADDR_VAR 0 4
110026: PUSH
110027: DOUBLE
110028: LD_INT 1
110030: DEC
110031: ST_TO_ADDR
110032: LD_EXP 140
110036: PUSH
110037: LD_VAR 0 5
110041: ARRAY
110042: PUSH
110043: FOR_TO
110044: IFFALSE 110085
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
110046: LD_EXP 140
110050: PUSH
110051: LD_VAR 0 5
110055: ARRAY
110056: PUSH
110057: LD_VAR 0 4
110061: ARRAY
110062: PUSH
110063: LD_INT 1
110065: ARRAY
110066: PUSH
110067: LD_VAR 0 2
110071: EQUAL
110072: IFFALSE 110083
// KillUnit ( vehicle ) ;
110074: LD_VAR 0 2
110078: PPUSH
110079: CALL_OW 66
110083: GO 110043
110085: POP
110086: POP
// end ;
110087: LD_VAR 0 3
110091: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110092: LD_EXP 144
110096: NOT
110097: IFFALSE 110132
110099: GO 110101
110101: DISABLE
// begin initMiner := true ;
110102: LD_ADDR_EXP 144
110106: PUSH
110107: LD_INT 1
110109: ST_TO_ADDR
// minersList := [ ] ;
110110: LD_ADDR_EXP 145
110114: PUSH
110115: EMPTY
110116: ST_TO_ADDR
// minerMinesList := [ ] ;
110117: LD_ADDR_EXP 146
110121: PUSH
110122: EMPTY
110123: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
110124: LD_ADDR_EXP 147
110128: PUSH
110129: LD_INT 5
110131: ST_TO_ADDR
// end ;
110132: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
110133: LD_EXP 144
110137: PUSH
110138: LD_INT 34
110140: PUSH
110141: LD_INT 81
110143: PUSH
110144: EMPTY
110145: LIST
110146: LIST
110147: PPUSH
110148: CALL_OW 69
110152: AND
110153: IFFALSE 110614
110155: GO 110157
110157: DISABLE
110158: LD_INT 0
110160: PPUSH
110161: PPUSH
110162: PPUSH
110163: PPUSH
// begin enable ;
110164: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
110165: LD_ADDR_VAR 0 1
110169: PUSH
110170: LD_INT 34
110172: PUSH
110173: LD_INT 81
110175: PUSH
110176: EMPTY
110177: LIST
110178: LIST
110179: PPUSH
110180: CALL_OW 69
110184: PUSH
110185: FOR_IN
110186: IFFALSE 110258
// begin if not i in minersList then
110188: LD_VAR 0 1
110192: PUSH
110193: LD_EXP 145
110197: IN
110198: NOT
110199: IFFALSE 110256
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
110201: LD_ADDR_EXP 145
110205: PUSH
110206: LD_EXP 145
110210: PPUSH
110211: LD_EXP 145
110215: PUSH
110216: LD_INT 1
110218: PLUS
110219: PPUSH
110220: LD_VAR 0 1
110224: PPUSH
110225: CALL_OW 1
110229: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110230: LD_ADDR_EXP 146
110234: PUSH
110235: LD_EXP 146
110239: PPUSH
110240: LD_EXP 146
110244: PUSH
110245: LD_INT 1
110247: PLUS
110248: PPUSH
110249: EMPTY
110250: PPUSH
110251: CALL_OW 1
110255: ST_TO_ADDR
// end end ;
110256: GO 110185
110258: POP
110259: POP
// for i := minerMinesList downto 1 do
110260: LD_ADDR_VAR 0 1
110264: PUSH
110265: DOUBLE
110266: LD_EXP 146
110270: INC
110271: ST_TO_ADDR
110272: LD_INT 1
110274: PUSH
110275: FOR_DOWNTO
110276: IFFALSE 110612
// begin if IsLive ( minersList [ i ] ) then
110278: LD_EXP 145
110282: PUSH
110283: LD_VAR 0 1
110287: ARRAY
110288: PPUSH
110289: CALL_OW 300
110293: IFFALSE 110321
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110295: LD_EXP 145
110299: PUSH
110300: LD_VAR 0 1
110304: ARRAY
110305: PPUSH
110306: LD_EXP 146
110310: PUSH
110311: LD_VAR 0 1
110315: ARRAY
110316: PPUSH
110317: CALL_OW 505
// if not minerMinesList [ i ] then
110321: LD_EXP 146
110325: PUSH
110326: LD_VAR 0 1
110330: ARRAY
110331: NOT
110332: IFFALSE 110336
// continue ;
110334: GO 110275
// for j := minerMinesList [ i ] downto 1 do
110336: LD_ADDR_VAR 0 2
110340: PUSH
110341: DOUBLE
110342: LD_EXP 146
110346: PUSH
110347: LD_VAR 0 1
110351: ARRAY
110352: INC
110353: ST_TO_ADDR
110354: LD_INT 1
110356: PUSH
110357: FOR_DOWNTO
110358: IFFALSE 110608
// begin side := GetSide ( minersList [ i ] ) ;
110360: LD_ADDR_VAR 0 3
110364: PUSH
110365: LD_EXP 145
110369: PUSH
110370: LD_VAR 0 1
110374: ARRAY
110375: PPUSH
110376: CALL_OW 255
110380: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110381: LD_ADDR_VAR 0 4
110385: PUSH
110386: LD_EXP 146
110390: PUSH
110391: LD_VAR 0 1
110395: ARRAY
110396: PUSH
110397: LD_VAR 0 2
110401: ARRAY
110402: PUSH
110403: LD_INT 1
110405: ARRAY
110406: PPUSH
110407: LD_EXP 146
110411: PUSH
110412: LD_VAR 0 1
110416: ARRAY
110417: PUSH
110418: LD_VAR 0 2
110422: ARRAY
110423: PUSH
110424: LD_INT 2
110426: ARRAY
110427: PPUSH
110428: CALL_OW 428
110432: ST_TO_ADDR
// if not tmp then
110433: LD_VAR 0 4
110437: NOT
110438: IFFALSE 110442
// continue ;
110440: GO 110357
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110442: LD_VAR 0 4
110446: PUSH
110447: LD_INT 81
110449: PUSH
110450: LD_VAR 0 3
110454: PUSH
110455: EMPTY
110456: LIST
110457: LIST
110458: PPUSH
110459: CALL_OW 69
110463: IN
110464: PUSH
110465: LD_EXP 146
110469: PUSH
110470: LD_VAR 0 1
110474: ARRAY
110475: PUSH
110476: LD_VAR 0 2
110480: ARRAY
110481: PUSH
110482: LD_INT 1
110484: ARRAY
110485: PPUSH
110486: LD_EXP 146
110490: PUSH
110491: LD_VAR 0 1
110495: ARRAY
110496: PUSH
110497: LD_VAR 0 2
110501: ARRAY
110502: PUSH
110503: LD_INT 2
110505: ARRAY
110506: PPUSH
110507: CALL_OW 458
110511: AND
110512: IFFALSE 110606
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110514: LD_EXP 146
110518: PUSH
110519: LD_VAR 0 1
110523: ARRAY
110524: PUSH
110525: LD_VAR 0 2
110529: ARRAY
110530: PUSH
110531: LD_INT 1
110533: ARRAY
110534: PPUSH
110535: LD_EXP 146
110539: PUSH
110540: LD_VAR 0 1
110544: ARRAY
110545: PUSH
110546: LD_VAR 0 2
110550: ARRAY
110551: PUSH
110552: LD_INT 2
110554: ARRAY
110555: PPUSH
110556: LD_VAR 0 3
110560: PPUSH
110561: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110565: LD_ADDR_EXP 146
110569: PUSH
110570: LD_EXP 146
110574: PPUSH
110575: LD_VAR 0 1
110579: PPUSH
110580: LD_EXP 146
110584: PUSH
110585: LD_VAR 0 1
110589: ARRAY
110590: PPUSH
110591: LD_VAR 0 2
110595: PPUSH
110596: CALL_OW 3
110600: PPUSH
110601: CALL_OW 1
110605: ST_TO_ADDR
// end ; end ;
110606: GO 110357
110608: POP
110609: POP
// end ;
110610: GO 110275
110612: POP
110613: POP
// end ;
110614: PPOPN 4
110616: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110617: LD_INT 0
110619: PPUSH
110620: PPUSH
// result := false ;
110621: LD_ADDR_VAR 0 4
110625: PUSH
110626: LD_INT 0
110628: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110629: LD_VAR 0 1
110633: PPUSH
110634: CALL_OW 264
110638: PUSH
110639: LD_INT 81
110641: EQUAL
110642: NOT
110643: IFFALSE 110647
// exit ;
110645: GO 110887
// index := GetElementIndex ( minersList , unit ) ;
110647: LD_ADDR_VAR 0 5
110651: PUSH
110652: LD_EXP 145
110656: PPUSH
110657: LD_VAR 0 1
110661: PPUSH
110662: CALL 24806 0 2
110666: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110667: LD_EXP 146
110671: PUSH
110672: LD_VAR 0 5
110676: ARRAY
110677: PUSH
110678: LD_EXP 147
110682: GREATEREQUAL
110683: IFFALSE 110687
// exit ;
110685: GO 110887
// ComMoveXY ( unit , x , y ) ;
110687: LD_VAR 0 1
110691: PPUSH
110692: LD_VAR 0 2
110696: PPUSH
110697: LD_VAR 0 3
110701: PPUSH
110702: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110706: LD_INT 35
110708: PPUSH
110709: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110713: LD_VAR 0 1
110717: PPUSH
110718: LD_VAR 0 2
110722: PPUSH
110723: LD_VAR 0 3
110727: PPUSH
110728: CALL 56161 0 3
110732: NOT
110733: PUSH
110734: LD_VAR 0 1
110738: PPUSH
110739: CALL_OW 314
110743: AND
110744: IFFALSE 110748
// exit ;
110746: GO 110887
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110748: LD_VAR 0 2
110752: PPUSH
110753: LD_VAR 0 3
110757: PPUSH
110758: CALL_OW 428
110762: PUSH
110763: LD_VAR 0 1
110767: EQUAL
110768: PUSH
110769: LD_VAR 0 1
110773: PPUSH
110774: CALL_OW 314
110778: NOT
110779: AND
110780: IFFALSE 110706
// PlaySoundXY ( x , y , PlantMine ) ;
110782: LD_VAR 0 2
110786: PPUSH
110787: LD_VAR 0 3
110791: PPUSH
110792: LD_STRING PlantMine
110794: PPUSH
110795: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110799: LD_VAR 0 2
110803: PPUSH
110804: LD_VAR 0 3
110808: PPUSH
110809: LD_VAR 0 1
110813: PPUSH
110814: CALL_OW 255
110818: PPUSH
110819: LD_INT 0
110821: PPUSH
110822: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110826: LD_ADDR_EXP 146
110830: PUSH
110831: LD_EXP 146
110835: PPUSH
110836: LD_VAR 0 5
110840: PUSH
110841: LD_EXP 146
110845: PUSH
110846: LD_VAR 0 5
110850: ARRAY
110851: PUSH
110852: LD_INT 1
110854: PLUS
110855: PUSH
110856: EMPTY
110857: LIST
110858: LIST
110859: PPUSH
110860: LD_VAR 0 2
110864: PUSH
110865: LD_VAR 0 3
110869: PUSH
110870: EMPTY
110871: LIST
110872: LIST
110873: PPUSH
110874: CALL 25021 0 3
110878: ST_TO_ADDR
// result := true ;
110879: LD_ADDR_VAR 0 4
110883: PUSH
110884: LD_INT 1
110886: ST_TO_ADDR
// end ;
110887: LD_VAR 0 4
110891: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110892: LD_INT 0
110894: PPUSH
110895: PPUSH
110896: PPUSH
// if not unit in minersList then
110897: LD_VAR 0 1
110901: PUSH
110902: LD_EXP 145
110906: IN
110907: NOT
110908: IFFALSE 110912
// exit ;
110910: GO 111304
// index := GetElementIndex ( minersList , unit ) ;
110912: LD_ADDR_VAR 0 6
110916: PUSH
110917: LD_EXP 145
110921: PPUSH
110922: LD_VAR 0 1
110926: PPUSH
110927: CALL 24806 0 2
110931: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110932: LD_ADDR_VAR 0 5
110936: PUSH
110937: DOUBLE
110938: LD_EXP 146
110942: PUSH
110943: LD_VAR 0 6
110947: ARRAY
110948: INC
110949: ST_TO_ADDR
110950: LD_INT 1
110952: PUSH
110953: FOR_DOWNTO
110954: IFFALSE 111115
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110956: LD_EXP 146
110960: PUSH
110961: LD_VAR 0 6
110965: ARRAY
110966: PUSH
110967: LD_VAR 0 5
110971: ARRAY
110972: PUSH
110973: LD_INT 1
110975: ARRAY
110976: PUSH
110977: LD_VAR 0 2
110981: EQUAL
110982: PUSH
110983: LD_EXP 146
110987: PUSH
110988: LD_VAR 0 6
110992: ARRAY
110993: PUSH
110994: LD_VAR 0 5
110998: ARRAY
110999: PUSH
111000: LD_INT 2
111002: ARRAY
111003: PUSH
111004: LD_VAR 0 3
111008: EQUAL
111009: AND
111010: IFFALSE 111113
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111012: LD_EXP 146
111016: PUSH
111017: LD_VAR 0 6
111021: ARRAY
111022: PUSH
111023: LD_VAR 0 5
111027: ARRAY
111028: PUSH
111029: LD_INT 1
111031: ARRAY
111032: PPUSH
111033: LD_EXP 146
111037: PUSH
111038: LD_VAR 0 6
111042: ARRAY
111043: PUSH
111044: LD_VAR 0 5
111048: ARRAY
111049: PUSH
111050: LD_INT 2
111052: ARRAY
111053: PPUSH
111054: LD_VAR 0 1
111058: PPUSH
111059: CALL_OW 255
111063: PPUSH
111064: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111068: LD_ADDR_EXP 146
111072: PUSH
111073: LD_EXP 146
111077: PPUSH
111078: LD_VAR 0 6
111082: PPUSH
111083: LD_EXP 146
111087: PUSH
111088: LD_VAR 0 6
111092: ARRAY
111093: PPUSH
111094: LD_VAR 0 5
111098: PPUSH
111099: CALL_OW 3
111103: PPUSH
111104: CALL_OW 1
111108: ST_TO_ADDR
// exit ;
111109: POP
111110: POP
111111: GO 111304
// end ; end ;
111113: GO 110953
111115: POP
111116: POP
// for i := minerMinesList [ index ] downto 1 do
111117: LD_ADDR_VAR 0 5
111121: PUSH
111122: DOUBLE
111123: LD_EXP 146
111127: PUSH
111128: LD_VAR 0 6
111132: ARRAY
111133: INC
111134: ST_TO_ADDR
111135: LD_INT 1
111137: PUSH
111138: FOR_DOWNTO
111139: IFFALSE 111302
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
111141: LD_EXP 146
111145: PUSH
111146: LD_VAR 0 6
111150: ARRAY
111151: PUSH
111152: LD_VAR 0 5
111156: ARRAY
111157: PUSH
111158: LD_INT 1
111160: ARRAY
111161: PPUSH
111162: LD_EXP 146
111166: PUSH
111167: LD_VAR 0 6
111171: ARRAY
111172: PUSH
111173: LD_VAR 0 5
111177: ARRAY
111178: PUSH
111179: LD_INT 2
111181: ARRAY
111182: PPUSH
111183: LD_VAR 0 2
111187: PPUSH
111188: LD_VAR 0 3
111192: PPUSH
111193: CALL_OW 298
111197: PUSH
111198: LD_INT 6
111200: LESS
111201: IFFALSE 111300
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111203: LD_EXP 146
111207: PUSH
111208: LD_VAR 0 6
111212: ARRAY
111213: PUSH
111214: LD_VAR 0 5
111218: ARRAY
111219: PUSH
111220: LD_INT 1
111222: ARRAY
111223: PPUSH
111224: LD_EXP 146
111228: PUSH
111229: LD_VAR 0 6
111233: ARRAY
111234: PUSH
111235: LD_VAR 0 5
111239: ARRAY
111240: PUSH
111241: LD_INT 2
111243: ARRAY
111244: PPUSH
111245: LD_VAR 0 1
111249: PPUSH
111250: CALL_OW 255
111254: PPUSH
111255: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111259: LD_ADDR_EXP 146
111263: PUSH
111264: LD_EXP 146
111268: PPUSH
111269: LD_VAR 0 6
111273: PPUSH
111274: LD_EXP 146
111278: PUSH
111279: LD_VAR 0 6
111283: ARRAY
111284: PPUSH
111285: LD_VAR 0 5
111289: PPUSH
111290: CALL_OW 3
111294: PPUSH
111295: CALL_OW 1
111299: ST_TO_ADDR
// end ; end ;
111300: GO 111138
111302: POP
111303: POP
// end ;
111304: LD_VAR 0 4
111308: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111309: LD_INT 0
111311: PPUSH
111312: PPUSH
111313: PPUSH
111314: PPUSH
111315: PPUSH
111316: PPUSH
111317: PPUSH
111318: PPUSH
111319: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111320: LD_VAR 0 1
111324: PPUSH
111325: CALL_OW 264
111329: PUSH
111330: LD_INT 81
111332: EQUAL
111333: NOT
111334: PUSH
111335: LD_VAR 0 1
111339: PUSH
111340: LD_EXP 145
111344: IN
111345: NOT
111346: OR
111347: IFFALSE 111351
// exit ;
111349: GO 111673
// index := GetElementIndex ( minersList , unit ) ;
111351: LD_ADDR_VAR 0 6
111355: PUSH
111356: LD_EXP 145
111360: PPUSH
111361: LD_VAR 0 1
111365: PPUSH
111366: CALL 24806 0 2
111370: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111371: LD_ADDR_VAR 0 8
111375: PUSH
111376: LD_EXP 147
111380: PUSH
111381: LD_EXP 146
111385: PUSH
111386: LD_VAR 0 6
111390: ARRAY
111391: MINUS
111392: ST_TO_ADDR
// if not minesFreeAmount then
111393: LD_VAR 0 8
111397: NOT
111398: IFFALSE 111402
// exit ;
111400: GO 111673
// tmp := [ ] ;
111402: LD_ADDR_VAR 0 7
111406: PUSH
111407: EMPTY
111408: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111409: LD_ADDR_VAR 0 5
111413: PUSH
111414: DOUBLE
111415: LD_INT 1
111417: DEC
111418: ST_TO_ADDR
111419: LD_VAR 0 8
111423: PUSH
111424: FOR_TO
111425: IFFALSE 111620
// begin _d := rand ( 0 , 5 ) ;
111427: LD_ADDR_VAR 0 11
111431: PUSH
111432: LD_INT 0
111434: PPUSH
111435: LD_INT 5
111437: PPUSH
111438: CALL_OW 12
111442: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111443: LD_ADDR_VAR 0 12
111447: PUSH
111448: LD_INT 2
111450: PPUSH
111451: LD_INT 6
111453: PPUSH
111454: CALL_OW 12
111458: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111459: LD_ADDR_VAR 0 9
111463: PUSH
111464: LD_VAR 0 2
111468: PPUSH
111469: LD_VAR 0 11
111473: PPUSH
111474: LD_VAR 0 12
111478: PPUSH
111479: CALL_OW 272
111483: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111484: LD_ADDR_VAR 0 10
111488: PUSH
111489: LD_VAR 0 3
111493: PPUSH
111494: LD_VAR 0 11
111498: PPUSH
111499: LD_VAR 0 12
111503: PPUSH
111504: CALL_OW 273
111508: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111509: LD_VAR 0 9
111513: PPUSH
111514: LD_VAR 0 10
111518: PPUSH
111519: CALL_OW 488
111523: PUSH
111524: LD_VAR 0 9
111528: PUSH
111529: LD_VAR 0 10
111533: PUSH
111534: EMPTY
111535: LIST
111536: LIST
111537: PUSH
111538: LD_VAR 0 7
111542: IN
111543: NOT
111544: AND
111545: PUSH
111546: LD_VAR 0 9
111550: PPUSH
111551: LD_VAR 0 10
111555: PPUSH
111556: CALL_OW 458
111560: NOT
111561: AND
111562: IFFALSE 111604
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111564: LD_ADDR_VAR 0 7
111568: PUSH
111569: LD_VAR 0 7
111573: PPUSH
111574: LD_VAR 0 7
111578: PUSH
111579: LD_INT 1
111581: PLUS
111582: PPUSH
111583: LD_VAR 0 9
111587: PUSH
111588: LD_VAR 0 10
111592: PUSH
111593: EMPTY
111594: LIST
111595: LIST
111596: PPUSH
111597: CALL_OW 1
111601: ST_TO_ADDR
111602: GO 111618
// i := i - 1 ;
111604: LD_ADDR_VAR 0 5
111608: PUSH
111609: LD_VAR 0 5
111613: PUSH
111614: LD_INT 1
111616: MINUS
111617: ST_TO_ADDR
// end ;
111618: GO 111424
111620: POP
111621: POP
// for i in tmp do
111622: LD_ADDR_VAR 0 5
111626: PUSH
111627: LD_VAR 0 7
111631: PUSH
111632: FOR_IN
111633: IFFALSE 111671
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111635: LD_VAR 0 1
111639: PPUSH
111640: LD_VAR 0 5
111644: PUSH
111645: LD_INT 1
111647: ARRAY
111648: PPUSH
111649: LD_VAR 0 5
111653: PUSH
111654: LD_INT 2
111656: ARRAY
111657: PPUSH
111658: CALL 110617 0 3
111662: NOT
111663: IFFALSE 111669
// exit ;
111665: POP
111666: POP
111667: GO 111673
111669: GO 111632
111671: POP
111672: POP
// end ;
111673: LD_VAR 0 4
111677: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111678: LD_INT 0
111680: PPUSH
111681: PPUSH
111682: PPUSH
111683: PPUSH
111684: PPUSH
111685: PPUSH
111686: PPUSH
// if not GetClass ( unit ) = class_sniper then
111687: LD_VAR 0 1
111691: PPUSH
111692: CALL_OW 257
111696: PUSH
111697: LD_INT 5
111699: EQUAL
111700: NOT
111701: IFFALSE 111705
// exit ;
111703: GO 112093
// dist := 8 ;
111705: LD_ADDR_VAR 0 5
111709: PUSH
111710: LD_INT 8
111712: ST_TO_ADDR
// viewRange := 12 ;
111713: LD_ADDR_VAR 0 7
111717: PUSH
111718: LD_INT 12
111720: ST_TO_ADDR
// side := GetSide ( unit ) ;
111721: LD_ADDR_VAR 0 6
111725: PUSH
111726: LD_VAR 0 1
111730: PPUSH
111731: CALL_OW 255
111735: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111736: LD_INT 61
111738: PPUSH
111739: LD_VAR 0 6
111743: PPUSH
111744: CALL_OW 321
111748: PUSH
111749: LD_INT 2
111751: EQUAL
111752: IFFALSE 111762
// viewRange := 16 ;
111754: LD_ADDR_VAR 0 7
111758: PUSH
111759: LD_INT 16
111761: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111762: LD_VAR 0 1
111766: PPUSH
111767: LD_VAR 0 2
111771: PPUSH
111772: LD_VAR 0 3
111776: PPUSH
111777: CALL_OW 297
111781: PUSH
111782: LD_VAR 0 5
111786: GREATER
111787: IFFALSE 111866
// begin ComMoveXY ( unit , x , y ) ;
111789: LD_VAR 0 1
111793: PPUSH
111794: LD_VAR 0 2
111798: PPUSH
111799: LD_VAR 0 3
111803: PPUSH
111804: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111808: LD_INT 35
111810: PPUSH
111811: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111815: LD_VAR 0 1
111819: PPUSH
111820: LD_VAR 0 2
111824: PPUSH
111825: LD_VAR 0 3
111829: PPUSH
111830: CALL 56161 0 3
111834: NOT
111835: IFFALSE 111839
// exit ;
111837: GO 112093
// until GetDistUnitXY ( unit , x , y ) < dist ;
111839: LD_VAR 0 1
111843: PPUSH
111844: LD_VAR 0 2
111848: PPUSH
111849: LD_VAR 0 3
111853: PPUSH
111854: CALL_OW 297
111858: PUSH
111859: LD_VAR 0 5
111863: LESS
111864: IFFALSE 111808
// end ; ComTurnXY ( unit , x , y ) ;
111866: LD_VAR 0 1
111870: PPUSH
111871: LD_VAR 0 2
111875: PPUSH
111876: LD_VAR 0 3
111880: PPUSH
111881: CALL_OW 118
// wait ( 5 ) ;
111885: LD_INT 5
111887: PPUSH
111888: CALL_OW 67
// _d := GetDir ( unit ) ;
111892: LD_ADDR_VAR 0 10
111896: PUSH
111897: LD_VAR 0 1
111901: PPUSH
111902: CALL_OW 254
111906: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111907: LD_ADDR_VAR 0 8
111911: PUSH
111912: LD_VAR 0 1
111916: PPUSH
111917: CALL_OW 250
111921: PPUSH
111922: LD_VAR 0 10
111926: PPUSH
111927: LD_VAR 0 5
111931: PPUSH
111932: CALL_OW 272
111936: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111937: LD_ADDR_VAR 0 9
111941: PUSH
111942: LD_VAR 0 1
111946: PPUSH
111947: CALL_OW 251
111951: PPUSH
111952: LD_VAR 0 10
111956: PPUSH
111957: LD_VAR 0 5
111961: PPUSH
111962: CALL_OW 273
111966: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111967: LD_VAR 0 8
111971: PPUSH
111972: LD_VAR 0 9
111976: PPUSH
111977: CALL_OW 488
111981: NOT
111982: IFFALSE 111986
// exit ;
111984: GO 112093
// ComAnimCustom ( unit , 1 ) ;
111986: LD_VAR 0 1
111990: PPUSH
111991: LD_INT 1
111993: PPUSH
111994: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111998: LD_VAR 0 8
112002: PPUSH
112003: LD_VAR 0 9
112007: PPUSH
112008: LD_VAR 0 6
112012: PPUSH
112013: LD_VAR 0 7
112017: PPUSH
112018: CALL_OW 330
// repeat wait ( 1 ) ;
112022: LD_INT 1
112024: PPUSH
112025: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
112029: LD_VAR 0 1
112033: PPUSH
112034: CALL_OW 316
112038: PUSH
112039: LD_VAR 0 1
112043: PPUSH
112044: CALL_OW 314
112048: OR
112049: PUSH
112050: LD_VAR 0 1
112054: PPUSH
112055: CALL_OW 302
112059: NOT
112060: OR
112061: PUSH
112062: LD_VAR 0 1
112066: PPUSH
112067: CALL_OW 301
112071: OR
112072: IFFALSE 112022
// RemoveSeeing ( _x , _y , side ) ;
112074: LD_VAR 0 8
112078: PPUSH
112079: LD_VAR 0 9
112083: PPUSH
112084: LD_VAR 0 6
112088: PPUSH
112089: CALL_OW 331
// end ; end_of_file
112093: LD_VAR 0 4
112097: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112098: LD_INT 0
112100: PPUSH
112101: PPUSH
112102: PPUSH
112103: PPUSH
112104: PPUSH
112105: PPUSH
112106: PPUSH
112107: PPUSH
112108: PPUSH
112109: PPUSH
112110: PPUSH
112111: PPUSH
112112: PPUSH
112113: PPUSH
112114: PPUSH
112115: PPUSH
112116: PPUSH
112117: PPUSH
112118: PPUSH
112119: PPUSH
112120: PPUSH
112121: PPUSH
112122: PPUSH
112123: PPUSH
112124: PPUSH
112125: PPUSH
112126: PPUSH
112127: PPUSH
112128: PPUSH
112129: PPUSH
112130: PPUSH
112131: PPUSH
112132: PPUSH
112133: PPUSH
// if not list then
112134: LD_VAR 0 1
112138: NOT
112139: IFFALSE 112143
// exit ;
112141: GO 116802
// base := list [ 1 ] ;
112143: LD_ADDR_VAR 0 3
112147: PUSH
112148: LD_VAR 0 1
112152: PUSH
112153: LD_INT 1
112155: ARRAY
112156: ST_TO_ADDR
// group := list [ 2 ] ;
112157: LD_ADDR_VAR 0 4
112161: PUSH
112162: LD_VAR 0 1
112166: PUSH
112167: LD_INT 2
112169: ARRAY
112170: ST_TO_ADDR
// path := list [ 3 ] ;
112171: LD_ADDR_VAR 0 5
112175: PUSH
112176: LD_VAR 0 1
112180: PUSH
112181: LD_INT 3
112183: ARRAY
112184: ST_TO_ADDR
// flags := list [ 4 ] ;
112185: LD_ADDR_VAR 0 6
112189: PUSH
112190: LD_VAR 0 1
112194: PUSH
112195: LD_INT 4
112197: ARRAY
112198: ST_TO_ADDR
// mined := [ ] ;
112199: LD_ADDR_VAR 0 27
112203: PUSH
112204: EMPTY
112205: ST_TO_ADDR
// bombed := [ ] ;
112206: LD_ADDR_VAR 0 28
112210: PUSH
112211: EMPTY
112212: ST_TO_ADDR
// healers := [ ] ;
112213: LD_ADDR_VAR 0 31
112217: PUSH
112218: EMPTY
112219: ST_TO_ADDR
// to_heal := [ ] ;
112220: LD_ADDR_VAR 0 30
112224: PUSH
112225: EMPTY
112226: ST_TO_ADDR
// repairs := [ ] ;
112227: LD_ADDR_VAR 0 33
112231: PUSH
112232: EMPTY
112233: ST_TO_ADDR
// to_repair := [ ] ;
112234: LD_ADDR_VAR 0 32
112238: PUSH
112239: EMPTY
112240: ST_TO_ADDR
// if not group or not path then
112241: LD_VAR 0 4
112245: NOT
112246: PUSH
112247: LD_VAR 0 5
112251: NOT
112252: OR
112253: IFFALSE 112257
// exit ;
112255: GO 116802
// side := GetSide ( group [ 1 ] ) ;
112257: LD_ADDR_VAR 0 35
112261: PUSH
112262: LD_VAR 0 4
112266: PUSH
112267: LD_INT 1
112269: ARRAY
112270: PPUSH
112271: CALL_OW 255
112275: ST_TO_ADDR
// if flags then
112276: LD_VAR 0 6
112280: IFFALSE 112424
// begin f_ignore_area := flags [ 1 ] ;
112282: LD_ADDR_VAR 0 17
112286: PUSH
112287: LD_VAR 0 6
112291: PUSH
112292: LD_INT 1
112294: ARRAY
112295: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112296: LD_ADDR_VAR 0 18
112300: PUSH
112301: LD_VAR 0 6
112305: PUSH
112306: LD_INT 2
112308: ARRAY
112309: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112310: LD_ADDR_VAR 0 19
112314: PUSH
112315: LD_VAR 0 6
112319: PUSH
112320: LD_INT 3
112322: ARRAY
112323: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112324: LD_ADDR_VAR 0 20
112328: PUSH
112329: LD_VAR 0 6
112333: PUSH
112334: LD_INT 4
112336: ARRAY
112337: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112338: LD_ADDR_VAR 0 21
112342: PUSH
112343: LD_VAR 0 6
112347: PUSH
112348: LD_INT 5
112350: ARRAY
112351: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112352: LD_ADDR_VAR 0 22
112356: PUSH
112357: LD_VAR 0 6
112361: PUSH
112362: LD_INT 6
112364: ARRAY
112365: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112366: LD_ADDR_VAR 0 23
112370: PUSH
112371: LD_VAR 0 6
112375: PUSH
112376: LD_INT 7
112378: ARRAY
112379: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112380: LD_ADDR_VAR 0 24
112384: PUSH
112385: LD_VAR 0 6
112389: PUSH
112390: LD_INT 8
112392: ARRAY
112393: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112394: LD_ADDR_VAR 0 25
112398: PUSH
112399: LD_VAR 0 6
112403: PUSH
112404: LD_INT 9
112406: ARRAY
112407: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112408: LD_ADDR_VAR 0 26
112412: PUSH
112413: LD_VAR 0 6
112417: PUSH
112418: LD_INT 10
112420: ARRAY
112421: ST_TO_ADDR
// end else
112422: GO 112504
// begin f_ignore_area := false ;
112424: LD_ADDR_VAR 0 17
112428: PUSH
112429: LD_INT 0
112431: ST_TO_ADDR
// f_capture := false ;
112432: LD_ADDR_VAR 0 18
112436: PUSH
112437: LD_INT 0
112439: ST_TO_ADDR
// f_ignore_civ := false ;
112440: LD_ADDR_VAR 0 19
112444: PUSH
112445: LD_INT 0
112447: ST_TO_ADDR
// f_murder := false ;
112448: LD_ADDR_VAR 0 20
112452: PUSH
112453: LD_INT 0
112455: ST_TO_ADDR
// f_mines := false ;
112456: LD_ADDR_VAR 0 21
112460: PUSH
112461: LD_INT 0
112463: ST_TO_ADDR
// f_repair := false ;
112464: LD_ADDR_VAR 0 22
112468: PUSH
112469: LD_INT 0
112471: ST_TO_ADDR
// f_heal := false ;
112472: LD_ADDR_VAR 0 23
112476: PUSH
112477: LD_INT 0
112479: ST_TO_ADDR
// f_spacetime := false ;
112480: LD_ADDR_VAR 0 24
112484: PUSH
112485: LD_INT 0
112487: ST_TO_ADDR
// f_attack_depot := false ;
112488: LD_ADDR_VAR 0 25
112492: PUSH
112493: LD_INT 0
112495: ST_TO_ADDR
// f_crawl := false ;
112496: LD_ADDR_VAR 0 26
112500: PUSH
112501: LD_INT 0
112503: ST_TO_ADDR
// end ; if f_heal then
112504: LD_VAR 0 23
112508: IFFALSE 112535
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112510: LD_ADDR_VAR 0 31
112514: PUSH
112515: LD_VAR 0 4
112519: PPUSH
112520: LD_INT 25
112522: PUSH
112523: LD_INT 4
112525: PUSH
112526: EMPTY
112527: LIST
112528: LIST
112529: PPUSH
112530: CALL_OW 72
112534: ST_TO_ADDR
// if f_repair then
112535: LD_VAR 0 22
112539: IFFALSE 112566
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112541: LD_ADDR_VAR 0 33
112545: PUSH
112546: LD_VAR 0 4
112550: PPUSH
112551: LD_INT 25
112553: PUSH
112554: LD_INT 3
112556: PUSH
112557: EMPTY
112558: LIST
112559: LIST
112560: PPUSH
112561: CALL_OW 72
112565: ST_TO_ADDR
// units_path := [ ] ;
112566: LD_ADDR_VAR 0 16
112570: PUSH
112571: EMPTY
112572: ST_TO_ADDR
// for i = 1 to group do
112573: LD_ADDR_VAR 0 7
112577: PUSH
112578: DOUBLE
112579: LD_INT 1
112581: DEC
112582: ST_TO_ADDR
112583: LD_VAR 0 4
112587: PUSH
112588: FOR_TO
112589: IFFALSE 112618
// units_path := Replace ( units_path , i , path ) ;
112591: LD_ADDR_VAR 0 16
112595: PUSH
112596: LD_VAR 0 16
112600: PPUSH
112601: LD_VAR 0 7
112605: PPUSH
112606: LD_VAR 0 5
112610: PPUSH
112611: CALL_OW 1
112615: ST_TO_ADDR
112616: GO 112588
112618: POP
112619: POP
// repeat for i = group downto 1 do
112620: LD_ADDR_VAR 0 7
112624: PUSH
112625: DOUBLE
112626: LD_VAR 0 4
112630: INC
112631: ST_TO_ADDR
112632: LD_INT 1
112634: PUSH
112635: FOR_DOWNTO
112636: IFFALSE 116758
// begin wait ( 5 ) ;
112638: LD_INT 5
112640: PPUSH
112641: CALL_OW 67
// tmp := [ ] ;
112645: LD_ADDR_VAR 0 14
112649: PUSH
112650: EMPTY
112651: ST_TO_ADDR
// attacking := false ;
112652: LD_ADDR_VAR 0 29
112656: PUSH
112657: LD_INT 0
112659: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112660: LD_VAR 0 4
112664: PUSH
112665: LD_VAR 0 7
112669: ARRAY
112670: PPUSH
112671: CALL_OW 301
112675: PUSH
112676: LD_VAR 0 4
112680: PUSH
112681: LD_VAR 0 7
112685: ARRAY
112686: NOT
112687: OR
112688: IFFALSE 112797
// begin if GetType ( group [ i ] ) = unit_human then
112690: LD_VAR 0 4
112694: PUSH
112695: LD_VAR 0 7
112699: ARRAY
112700: PPUSH
112701: CALL_OW 247
112705: PUSH
112706: LD_INT 1
112708: EQUAL
112709: IFFALSE 112755
// begin to_heal := to_heal diff group [ i ] ;
112711: LD_ADDR_VAR 0 30
112715: PUSH
112716: LD_VAR 0 30
112720: PUSH
112721: LD_VAR 0 4
112725: PUSH
112726: LD_VAR 0 7
112730: ARRAY
112731: DIFF
112732: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112733: LD_ADDR_VAR 0 31
112737: PUSH
112738: LD_VAR 0 31
112742: PUSH
112743: LD_VAR 0 4
112747: PUSH
112748: LD_VAR 0 7
112752: ARRAY
112753: DIFF
112754: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112755: LD_ADDR_VAR 0 4
112759: PUSH
112760: LD_VAR 0 4
112764: PPUSH
112765: LD_VAR 0 7
112769: PPUSH
112770: CALL_OW 3
112774: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112775: LD_ADDR_VAR 0 16
112779: PUSH
112780: LD_VAR 0 16
112784: PPUSH
112785: LD_VAR 0 7
112789: PPUSH
112790: CALL_OW 3
112794: ST_TO_ADDR
// continue ;
112795: GO 112635
// end ; if f_repair then
112797: LD_VAR 0 22
112801: IFFALSE 113290
// begin if GetType ( group [ i ] ) = unit_vehicle then
112803: LD_VAR 0 4
112807: PUSH
112808: LD_VAR 0 7
112812: ARRAY
112813: PPUSH
112814: CALL_OW 247
112818: PUSH
112819: LD_INT 2
112821: EQUAL
112822: IFFALSE 113012
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112824: LD_VAR 0 4
112828: PUSH
112829: LD_VAR 0 7
112833: ARRAY
112834: PPUSH
112835: CALL_OW 256
112839: PUSH
112840: LD_INT 700
112842: LESS
112843: PUSH
112844: LD_VAR 0 4
112848: PUSH
112849: LD_VAR 0 7
112853: ARRAY
112854: PUSH
112855: LD_VAR 0 32
112859: IN
112860: NOT
112861: AND
112862: IFFALSE 112886
// to_repair := to_repair union group [ i ] ;
112864: LD_ADDR_VAR 0 32
112868: PUSH
112869: LD_VAR 0 32
112873: PUSH
112874: LD_VAR 0 4
112878: PUSH
112879: LD_VAR 0 7
112883: ARRAY
112884: UNION
112885: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112886: LD_VAR 0 4
112890: PUSH
112891: LD_VAR 0 7
112895: ARRAY
112896: PPUSH
112897: CALL_OW 256
112901: PUSH
112902: LD_INT 1000
112904: EQUAL
112905: PUSH
112906: LD_VAR 0 4
112910: PUSH
112911: LD_VAR 0 7
112915: ARRAY
112916: PUSH
112917: LD_VAR 0 32
112921: IN
112922: AND
112923: IFFALSE 112947
// to_repair := to_repair diff group [ i ] ;
112925: LD_ADDR_VAR 0 32
112929: PUSH
112930: LD_VAR 0 32
112934: PUSH
112935: LD_VAR 0 4
112939: PUSH
112940: LD_VAR 0 7
112944: ARRAY
112945: DIFF
112946: ST_TO_ADDR
// if group [ i ] in to_repair then
112947: LD_VAR 0 4
112951: PUSH
112952: LD_VAR 0 7
112956: ARRAY
112957: PUSH
112958: LD_VAR 0 32
112962: IN
112963: IFFALSE 113010
// begin if not IsInArea ( group [ i ] , f_repair ) then
112965: LD_VAR 0 4
112969: PUSH
112970: LD_VAR 0 7
112974: ARRAY
112975: PPUSH
112976: LD_VAR 0 22
112980: PPUSH
112981: CALL_OW 308
112985: NOT
112986: IFFALSE 113008
// ComMoveToArea ( group [ i ] , f_repair ) ;
112988: LD_VAR 0 4
112992: PUSH
112993: LD_VAR 0 7
112997: ARRAY
112998: PPUSH
112999: LD_VAR 0 22
113003: PPUSH
113004: CALL_OW 113
// continue ;
113008: GO 112635
// end ; end else
113010: GO 113290
// if group [ i ] in repairs then
113012: LD_VAR 0 4
113016: PUSH
113017: LD_VAR 0 7
113021: ARRAY
113022: PUSH
113023: LD_VAR 0 33
113027: IN
113028: IFFALSE 113290
// begin if IsInUnit ( group [ i ] ) then
113030: LD_VAR 0 4
113034: PUSH
113035: LD_VAR 0 7
113039: ARRAY
113040: PPUSH
113041: CALL_OW 310
113045: IFFALSE 113113
// begin z := IsInUnit ( group [ i ] ) ;
113047: LD_ADDR_VAR 0 13
113051: PUSH
113052: LD_VAR 0 4
113056: PUSH
113057: LD_VAR 0 7
113061: ARRAY
113062: PPUSH
113063: CALL_OW 310
113067: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113068: LD_VAR 0 13
113072: PUSH
113073: LD_VAR 0 32
113077: IN
113078: PUSH
113079: LD_VAR 0 13
113083: PPUSH
113084: LD_VAR 0 22
113088: PPUSH
113089: CALL_OW 308
113093: AND
113094: IFFALSE 113111
// ComExitVehicle ( group [ i ] ) ;
113096: LD_VAR 0 4
113100: PUSH
113101: LD_VAR 0 7
113105: ARRAY
113106: PPUSH
113107: CALL_OW 121
// end else
113111: GO 113290
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113113: LD_ADDR_VAR 0 13
113117: PUSH
113118: LD_VAR 0 4
113122: PPUSH
113123: LD_INT 95
113125: PUSH
113126: LD_VAR 0 22
113130: PUSH
113131: EMPTY
113132: LIST
113133: LIST
113134: PUSH
113135: LD_INT 58
113137: PUSH
113138: EMPTY
113139: LIST
113140: PUSH
113141: EMPTY
113142: LIST
113143: LIST
113144: PPUSH
113145: CALL_OW 72
113149: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113150: LD_VAR 0 4
113154: PUSH
113155: LD_VAR 0 7
113159: ARRAY
113160: PPUSH
113161: CALL_OW 314
113165: NOT
113166: IFFALSE 113288
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113168: LD_ADDR_VAR 0 10
113172: PUSH
113173: LD_VAR 0 13
113177: PPUSH
113178: LD_VAR 0 4
113182: PUSH
113183: LD_VAR 0 7
113187: ARRAY
113188: PPUSH
113189: CALL_OW 74
113193: ST_TO_ADDR
// if not x then
113194: LD_VAR 0 10
113198: NOT
113199: IFFALSE 113203
// continue ;
113201: GO 112635
// if GetLives ( x ) < 1000 then
113203: LD_VAR 0 10
113207: PPUSH
113208: CALL_OW 256
113212: PUSH
113213: LD_INT 1000
113215: LESS
113216: IFFALSE 113240
// ComRepairVehicle ( group [ i ] , x ) else
113218: LD_VAR 0 4
113222: PUSH
113223: LD_VAR 0 7
113227: ARRAY
113228: PPUSH
113229: LD_VAR 0 10
113233: PPUSH
113234: CALL_OW 129
113238: GO 113288
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113240: LD_VAR 0 23
113244: PUSH
113245: LD_VAR 0 4
113249: PUSH
113250: LD_VAR 0 7
113254: ARRAY
113255: PPUSH
113256: CALL_OW 256
113260: PUSH
113261: LD_INT 1000
113263: LESS
113264: AND
113265: NOT
113266: IFFALSE 113288
// ComEnterUnit ( group [ i ] , x ) ;
113268: LD_VAR 0 4
113272: PUSH
113273: LD_VAR 0 7
113277: ARRAY
113278: PPUSH
113279: LD_VAR 0 10
113283: PPUSH
113284: CALL_OW 120
// end ; continue ;
113288: GO 112635
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113290: LD_VAR 0 23
113294: PUSH
113295: LD_VAR 0 4
113299: PUSH
113300: LD_VAR 0 7
113304: ARRAY
113305: PPUSH
113306: CALL_OW 247
113310: PUSH
113311: LD_INT 1
113313: EQUAL
113314: AND
113315: IFFALSE 113793
// begin if group [ i ] in healers then
113317: LD_VAR 0 4
113321: PUSH
113322: LD_VAR 0 7
113326: ARRAY
113327: PUSH
113328: LD_VAR 0 31
113332: IN
113333: IFFALSE 113606
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113335: LD_VAR 0 4
113339: PUSH
113340: LD_VAR 0 7
113344: ARRAY
113345: PPUSH
113346: LD_VAR 0 23
113350: PPUSH
113351: CALL_OW 308
113355: NOT
113356: PUSH
113357: LD_VAR 0 4
113361: PUSH
113362: LD_VAR 0 7
113366: ARRAY
113367: PPUSH
113368: CALL_OW 314
113372: NOT
113373: AND
113374: IFFALSE 113398
// ComMoveToArea ( group [ i ] , f_heal ) else
113376: LD_VAR 0 4
113380: PUSH
113381: LD_VAR 0 7
113385: ARRAY
113386: PPUSH
113387: LD_VAR 0 23
113391: PPUSH
113392: CALL_OW 113
113396: GO 113604
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113398: LD_VAR 0 4
113402: PUSH
113403: LD_VAR 0 7
113407: ARRAY
113408: PPUSH
113409: CALL 54744 0 1
113413: PPUSH
113414: CALL_OW 256
113418: PUSH
113419: LD_INT 1000
113421: EQUAL
113422: IFFALSE 113441
// ComStop ( group [ i ] ) else
113424: LD_VAR 0 4
113428: PUSH
113429: LD_VAR 0 7
113433: ARRAY
113434: PPUSH
113435: CALL_OW 141
113439: GO 113604
// if not HasTask ( group [ i ] ) and to_heal then
113441: LD_VAR 0 4
113445: PUSH
113446: LD_VAR 0 7
113450: ARRAY
113451: PPUSH
113452: CALL_OW 314
113456: NOT
113457: PUSH
113458: LD_VAR 0 30
113462: AND
113463: IFFALSE 113604
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113465: LD_ADDR_VAR 0 13
113469: PUSH
113470: LD_VAR 0 30
113474: PPUSH
113475: LD_INT 3
113477: PUSH
113478: LD_INT 54
113480: PUSH
113481: EMPTY
113482: LIST
113483: PUSH
113484: EMPTY
113485: LIST
113486: LIST
113487: PPUSH
113488: CALL_OW 72
113492: PPUSH
113493: LD_VAR 0 4
113497: PUSH
113498: LD_VAR 0 7
113502: ARRAY
113503: PPUSH
113504: CALL_OW 74
113508: ST_TO_ADDR
// if z then
113509: LD_VAR 0 13
113513: IFFALSE 113604
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113515: LD_INT 91
113517: PUSH
113518: LD_VAR 0 13
113522: PUSH
113523: LD_INT 10
113525: PUSH
113526: EMPTY
113527: LIST
113528: LIST
113529: LIST
113530: PUSH
113531: LD_INT 81
113533: PUSH
113534: LD_VAR 0 13
113538: PPUSH
113539: CALL_OW 255
113543: PUSH
113544: EMPTY
113545: LIST
113546: LIST
113547: PUSH
113548: EMPTY
113549: LIST
113550: LIST
113551: PPUSH
113552: CALL_OW 69
113556: PUSH
113557: LD_INT 0
113559: EQUAL
113560: IFFALSE 113584
// ComHeal ( group [ i ] , z ) else
113562: LD_VAR 0 4
113566: PUSH
113567: LD_VAR 0 7
113571: ARRAY
113572: PPUSH
113573: LD_VAR 0 13
113577: PPUSH
113578: CALL_OW 128
113582: GO 113604
// ComMoveToArea ( group [ i ] , f_heal ) ;
113584: LD_VAR 0 4
113588: PUSH
113589: LD_VAR 0 7
113593: ARRAY
113594: PPUSH
113595: LD_VAR 0 23
113599: PPUSH
113600: CALL_OW 113
// end ; continue ;
113604: GO 112635
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113606: LD_VAR 0 4
113610: PUSH
113611: LD_VAR 0 7
113615: ARRAY
113616: PPUSH
113617: CALL_OW 256
113621: PUSH
113622: LD_INT 700
113624: LESS
113625: PUSH
113626: LD_VAR 0 4
113630: PUSH
113631: LD_VAR 0 7
113635: ARRAY
113636: PUSH
113637: LD_VAR 0 30
113641: IN
113642: NOT
113643: AND
113644: IFFALSE 113668
// to_heal := to_heal union group [ i ] ;
113646: LD_ADDR_VAR 0 30
113650: PUSH
113651: LD_VAR 0 30
113655: PUSH
113656: LD_VAR 0 4
113660: PUSH
113661: LD_VAR 0 7
113665: ARRAY
113666: UNION
113667: ST_TO_ADDR
// if group [ i ] in to_heal then
113668: LD_VAR 0 4
113672: PUSH
113673: LD_VAR 0 7
113677: ARRAY
113678: PUSH
113679: LD_VAR 0 30
113683: IN
113684: IFFALSE 113793
// begin if GetLives ( group [ i ] ) = 1000 then
113686: LD_VAR 0 4
113690: PUSH
113691: LD_VAR 0 7
113695: ARRAY
113696: PPUSH
113697: CALL_OW 256
113701: PUSH
113702: LD_INT 1000
113704: EQUAL
113705: IFFALSE 113731
// to_heal := to_heal diff group [ i ] else
113707: LD_ADDR_VAR 0 30
113711: PUSH
113712: LD_VAR 0 30
113716: PUSH
113717: LD_VAR 0 4
113721: PUSH
113722: LD_VAR 0 7
113726: ARRAY
113727: DIFF
113728: ST_TO_ADDR
113729: GO 113793
// begin if not IsInArea ( group [ i ] , to_heal ) then
113731: LD_VAR 0 4
113735: PUSH
113736: LD_VAR 0 7
113740: ARRAY
113741: PPUSH
113742: LD_VAR 0 30
113746: PPUSH
113747: CALL_OW 308
113751: NOT
113752: IFFALSE 113776
// ComMoveToArea ( group [ i ] , f_heal ) else
113754: LD_VAR 0 4
113758: PUSH
113759: LD_VAR 0 7
113763: ARRAY
113764: PPUSH
113765: LD_VAR 0 23
113769: PPUSH
113770: CALL_OW 113
113774: GO 113791
// ComHold ( group [ i ] ) ;
113776: LD_VAR 0 4
113780: PUSH
113781: LD_VAR 0 7
113785: ARRAY
113786: PPUSH
113787: CALL_OW 140
// continue ;
113791: GO 112635
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113793: LD_VAR 0 4
113797: PUSH
113798: LD_VAR 0 7
113802: ARRAY
113803: PPUSH
113804: LD_INT 10
113806: PPUSH
113807: CALL 52515 0 2
113811: NOT
113812: PUSH
113813: LD_VAR 0 16
113817: PUSH
113818: LD_VAR 0 7
113822: ARRAY
113823: PUSH
113824: EMPTY
113825: EQUAL
113826: NOT
113827: AND
113828: IFFALSE 114094
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113830: LD_VAR 0 4
113834: PUSH
113835: LD_VAR 0 7
113839: ARRAY
113840: PPUSH
113841: CALL_OW 262
113845: PUSH
113846: LD_INT 1
113848: PUSH
113849: LD_INT 2
113851: PUSH
113852: EMPTY
113853: LIST
113854: LIST
113855: IN
113856: IFFALSE 113897
// if GetFuel ( group [ i ] ) < 10 then
113858: LD_VAR 0 4
113862: PUSH
113863: LD_VAR 0 7
113867: ARRAY
113868: PPUSH
113869: CALL_OW 261
113873: PUSH
113874: LD_INT 10
113876: LESS
113877: IFFALSE 113897
// SetFuel ( group [ i ] , 12 ) ;
113879: LD_VAR 0 4
113883: PUSH
113884: LD_VAR 0 7
113888: ARRAY
113889: PPUSH
113890: LD_INT 12
113892: PPUSH
113893: CALL_OW 240
// if units_path [ i ] then
113897: LD_VAR 0 16
113901: PUSH
113902: LD_VAR 0 7
113906: ARRAY
113907: IFFALSE 114092
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113909: LD_VAR 0 4
113913: PUSH
113914: LD_VAR 0 7
113918: ARRAY
113919: PPUSH
113920: LD_VAR 0 16
113924: PUSH
113925: LD_VAR 0 7
113929: ARRAY
113930: PUSH
113931: LD_INT 1
113933: ARRAY
113934: PUSH
113935: LD_INT 1
113937: ARRAY
113938: PPUSH
113939: LD_VAR 0 16
113943: PUSH
113944: LD_VAR 0 7
113948: ARRAY
113949: PUSH
113950: LD_INT 1
113952: ARRAY
113953: PUSH
113954: LD_INT 2
113956: ARRAY
113957: PPUSH
113958: CALL_OW 297
113962: PUSH
113963: LD_INT 6
113965: GREATER
113966: IFFALSE 114041
// begin if not HasTask ( group [ i ] ) then
113968: LD_VAR 0 4
113972: PUSH
113973: LD_VAR 0 7
113977: ARRAY
113978: PPUSH
113979: CALL_OW 314
113983: NOT
113984: IFFALSE 114039
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113986: LD_VAR 0 4
113990: PUSH
113991: LD_VAR 0 7
113995: ARRAY
113996: PPUSH
113997: LD_VAR 0 16
114001: PUSH
114002: LD_VAR 0 7
114006: ARRAY
114007: PUSH
114008: LD_INT 1
114010: ARRAY
114011: PUSH
114012: LD_INT 1
114014: ARRAY
114015: PPUSH
114016: LD_VAR 0 16
114020: PUSH
114021: LD_VAR 0 7
114025: ARRAY
114026: PUSH
114027: LD_INT 1
114029: ARRAY
114030: PUSH
114031: LD_INT 2
114033: ARRAY
114034: PPUSH
114035: CALL_OW 114
// end else
114039: GO 114092
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114041: LD_ADDR_VAR 0 15
114045: PUSH
114046: LD_VAR 0 16
114050: PUSH
114051: LD_VAR 0 7
114055: ARRAY
114056: PPUSH
114057: LD_INT 1
114059: PPUSH
114060: CALL_OW 3
114064: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114065: LD_ADDR_VAR 0 16
114069: PUSH
114070: LD_VAR 0 16
114074: PPUSH
114075: LD_VAR 0 7
114079: PPUSH
114080: LD_VAR 0 15
114084: PPUSH
114085: CALL_OW 1
114089: ST_TO_ADDR
// continue ;
114090: GO 112635
// end ; end ; end else
114092: GO 116756
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114094: LD_ADDR_VAR 0 14
114098: PUSH
114099: LD_INT 81
114101: PUSH
114102: LD_VAR 0 4
114106: PUSH
114107: LD_VAR 0 7
114111: ARRAY
114112: PPUSH
114113: CALL_OW 255
114117: PUSH
114118: EMPTY
114119: LIST
114120: LIST
114121: PPUSH
114122: CALL_OW 69
114126: ST_TO_ADDR
// if not tmp then
114127: LD_VAR 0 14
114131: NOT
114132: IFFALSE 114136
// continue ;
114134: GO 112635
// if f_ignore_area then
114136: LD_VAR 0 17
114140: IFFALSE 114228
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114142: LD_ADDR_VAR 0 15
114146: PUSH
114147: LD_VAR 0 14
114151: PPUSH
114152: LD_INT 3
114154: PUSH
114155: LD_INT 92
114157: PUSH
114158: LD_VAR 0 17
114162: PUSH
114163: LD_INT 1
114165: ARRAY
114166: PUSH
114167: LD_VAR 0 17
114171: PUSH
114172: LD_INT 2
114174: ARRAY
114175: PUSH
114176: LD_VAR 0 17
114180: PUSH
114181: LD_INT 3
114183: ARRAY
114184: PUSH
114185: EMPTY
114186: LIST
114187: LIST
114188: LIST
114189: LIST
114190: PUSH
114191: EMPTY
114192: LIST
114193: LIST
114194: PPUSH
114195: CALL_OW 72
114199: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114200: LD_VAR 0 14
114204: PUSH
114205: LD_VAR 0 15
114209: DIFF
114210: IFFALSE 114228
// tmp := tmp diff tmp2 ;
114212: LD_ADDR_VAR 0 14
114216: PUSH
114217: LD_VAR 0 14
114221: PUSH
114222: LD_VAR 0 15
114226: DIFF
114227: ST_TO_ADDR
// end ; if not f_murder then
114228: LD_VAR 0 20
114232: NOT
114233: IFFALSE 114291
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114235: LD_ADDR_VAR 0 15
114239: PUSH
114240: LD_VAR 0 14
114244: PPUSH
114245: LD_INT 3
114247: PUSH
114248: LD_INT 50
114250: PUSH
114251: EMPTY
114252: LIST
114253: PUSH
114254: EMPTY
114255: LIST
114256: LIST
114257: PPUSH
114258: CALL_OW 72
114262: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114263: LD_VAR 0 14
114267: PUSH
114268: LD_VAR 0 15
114272: DIFF
114273: IFFALSE 114291
// tmp := tmp diff tmp2 ;
114275: LD_ADDR_VAR 0 14
114279: PUSH
114280: LD_VAR 0 14
114284: PUSH
114285: LD_VAR 0 15
114289: DIFF
114290: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114291: LD_ADDR_VAR 0 14
114295: PUSH
114296: LD_VAR 0 4
114300: PUSH
114301: LD_VAR 0 7
114305: ARRAY
114306: PPUSH
114307: LD_VAR 0 14
114311: PPUSH
114312: LD_INT 1
114314: PPUSH
114315: LD_INT 1
114317: PPUSH
114318: CALL 25456 0 4
114322: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114323: LD_VAR 0 4
114327: PUSH
114328: LD_VAR 0 7
114332: ARRAY
114333: PPUSH
114334: CALL_OW 257
114338: PUSH
114339: LD_INT 1
114341: EQUAL
114342: IFFALSE 114790
// begin if WantPlant ( group [ i ] ) then
114344: LD_VAR 0 4
114348: PUSH
114349: LD_VAR 0 7
114353: ARRAY
114354: PPUSH
114355: CALL 24957 0 1
114359: IFFALSE 114363
// continue ;
114361: GO 112635
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114363: LD_VAR 0 18
114367: PUSH
114368: LD_VAR 0 4
114372: PUSH
114373: LD_VAR 0 7
114377: ARRAY
114378: PPUSH
114379: CALL_OW 310
114383: NOT
114384: AND
114385: PUSH
114386: LD_VAR 0 14
114390: PUSH
114391: LD_INT 1
114393: ARRAY
114394: PUSH
114395: LD_VAR 0 14
114399: PPUSH
114400: LD_INT 21
114402: PUSH
114403: LD_INT 2
114405: PUSH
114406: EMPTY
114407: LIST
114408: LIST
114409: PUSH
114410: LD_INT 58
114412: PUSH
114413: EMPTY
114414: LIST
114415: PUSH
114416: EMPTY
114417: LIST
114418: LIST
114419: PPUSH
114420: CALL_OW 72
114424: IN
114425: AND
114426: IFFALSE 114462
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114428: LD_VAR 0 4
114432: PUSH
114433: LD_VAR 0 7
114437: ARRAY
114438: PPUSH
114439: LD_VAR 0 14
114443: PUSH
114444: LD_INT 1
114446: ARRAY
114447: PPUSH
114448: CALL_OW 120
// attacking := true ;
114452: LD_ADDR_VAR 0 29
114456: PUSH
114457: LD_INT 1
114459: ST_TO_ADDR
// continue ;
114460: GO 112635
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114462: LD_VAR 0 26
114466: PUSH
114467: LD_VAR 0 4
114471: PUSH
114472: LD_VAR 0 7
114476: ARRAY
114477: PPUSH
114478: CALL_OW 257
114482: PUSH
114483: LD_INT 1
114485: EQUAL
114486: AND
114487: PUSH
114488: LD_VAR 0 4
114492: PUSH
114493: LD_VAR 0 7
114497: ARRAY
114498: PPUSH
114499: CALL_OW 256
114503: PUSH
114504: LD_INT 800
114506: LESS
114507: AND
114508: PUSH
114509: LD_VAR 0 4
114513: PUSH
114514: LD_VAR 0 7
114518: ARRAY
114519: PPUSH
114520: CALL_OW 318
114524: NOT
114525: AND
114526: IFFALSE 114543
// ComCrawl ( group [ i ] ) ;
114528: LD_VAR 0 4
114532: PUSH
114533: LD_VAR 0 7
114537: ARRAY
114538: PPUSH
114539: CALL_OW 137
// if f_mines then
114543: LD_VAR 0 21
114547: IFFALSE 114790
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114549: LD_VAR 0 14
114553: PUSH
114554: LD_INT 1
114556: ARRAY
114557: PPUSH
114558: CALL_OW 247
114562: PUSH
114563: LD_INT 3
114565: EQUAL
114566: PUSH
114567: LD_VAR 0 14
114571: PUSH
114572: LD_INT 1
114574: ARRAY
114575: PUSH
114576: LD_VAR 0 27
114580: IN
114581: NOT
114582: AND
114583: IFFALSE 114790
// begin x := GetX ( tmp [ 1 ] ) ;
114585: LD_ADDR_VAR 0 10
114589: PUSH
114590: LD_VAR 0 14
114594: PUSH
114595: LD_INT 1
114597: ARRAY
114598: PPUSH
114599: CALL_OW 250
114603: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114604: LD_ADDR_VAR 0 11
114608: PUSH
114609: LD_VAR 0 14
114613: PUSH
114614: LD_INT 1
114616: ARRAY
114617: PPUSH
114618: CALL_OW 251
114622: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114623: LD_ADDR_VAR 0 12
114627: PUSH
114628: LD_VAR 0 4
114632: PUSH
114633: LD_VAR 0 7
114637: ARRAY
114638: PPUSH
114639: CALL 52600 0 1
114643: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114644: LD_VAR 0 4
114648: PUSH
114649: LD_VAR 0 7
114653: ARRAY
114654: PPUSH
114655: LD_VAR 0 10
114659: PPUSH
114660: LD_VAR 0 11
114664: PPUSH
114665: LD_VAR 0 14
114669: PUSH
114670: LD_INT 1
114672: ARRAY
114673: PPUSH
114674: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114678: LD_VAR 0 4
114682: PUSH
114683: LD_VAR 0 7
114687: ARRAY
114688: PPUSH
114689: LD_VAR 0 10
114693: PPUSH
114694: LD_VAR 0 12
114698: PPUSH
114699: LD_INT 7
114701: PPUSH
114702: CALL_OW 272
114706: PPUSH
114707: LD_VAR 0 11
114711: PPUSH
114712: LD_VAR 0 12
114716: PPUSH
114717: LD_INT 7
114719: PPUSH
114720: CALL_OW 273
114724: PPUSH
114725: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114729: LD_VAR 0 4
114733: PUSH
114734: LD_VAR 0 7
114738: ARRAY
114739: PPUSH
114740: LD_INT 71
114742: PPUSH
114743: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114747: LD_ADDR_VAR 0 27
114751: PUSH
114752: LD_VAR 0 27
114756: PPUSH
114757: LD_VAR 0 27
114761: PUSH
114762: LD_INT 1
114764: PLUS
114765: PPUSH
114766: LD_VAR 0 14
114770: PUSH
114771: LD_INT 1
114773: ARRAY
114774: PPUSH
114775: CALL_OW 1
114779: ST_TO_ADDR
// attacking := true ;
114780: LD_ADDR_VAR 0 29
114784: PUSH
114785: LD_INT 1
114787: ST_TO_ADDR
// continue ;
114788: GO 112635
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114790: LD_VAR 0 4
114794: PUSH
114795: LD_VAR 0 7
114799: ARRAY
114800: PPUSH
114801: CALL_OW 257
114805: PUSH
114806: LD_INT 17
114808: EQUAL
114809: PUSH
114810: LD_VAR 0 4
114814: PUSH
114815: LD_VAR 0 7
114819: ARRAY
114820: PPUSH
114821: CALL_OW 110
114825: PUSH
114826: LD_INT 71
114828: EQUAL
114829: NOT
114830: AND
114831: IFFALSE 114977
// begin attacking := false ;
114833: LD_ADDR_VAR 0 29
114837: PUSH
114838: LD_INT 0
114840: ST_TO_ADDR
// k := 5 ;
114841: LD_ADDR_VAR 0 9
114845: PUSH
114846: LD_INT 5
114848: ST_TO_ADDR
// if tmp < k then
114849: LD_VAR 0 14
114853: PUSH
114854: LD_VAR 0 9
114858: LESS
114859: IFFALSE 114871
// k := tmp ;
114861: LD_ADDR_VAR 0 9
114865: PUSH
114866: LD_VAR 0 14
114870: ST_TO_ADDR
// for j = 1 to k do
114871: LD_ADDR_VAR 0 8
114875: PUSH
114876: DOUBLE
114877: LD_INT 1
114879: DEC
114880: ST_TO_ADDR
114881: LD_VAR 0 9
114885: PUSH
114886: FOR_TO
114887: IFFALSE 114975
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114889: LD_VAR 0 14
114893: PUSH
114894: LD_VAR 0 8
114898: ARRAY
114899: PUSH
114900: LD_VAR 0 14
114904: PPUSH
114905: LD_INT 58
114907: PUSH
114908: EMPTY
114909: LIST
114910: PPUSH
114911: CALL_OW 72
114915: IN
114916: NOT
114917: IFFALSE 114973
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114919: LD_VAR 0 4
114923: PUSH
114924: LD_VAR 0 7
114928: ARRAY
114929: PPUSH
114930: LD_VAR 0 14
114934: PUSH
114935: LD_VAR 0 8
114939: ARRAY
114940: PPUSH
114941: CALL_OW 115
// attacking := true ;
114945: LD_ADDR_VAR 0 29
114949: PUSH
114950: LD_INT 1
114952: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114953: LD_VAR 0 4
114957: PUSH
114958: LD_VAR 0 7
114962: ARRAY
114963: PPUSH
114964: LD_INT 71
114966: PPUSH
114967: CALL_OW 109
// continue ;
114971: GO 114886
// end ; end ;
114973: GO 114886
114975: POP
114976: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114977: LD_VAR 0 4
114981: PUSH
114982: LD_VAR 0 7
114986: ARRAY
114987: PPUSH
114988: CALL_OW 257
114992: PUSH
114993: LD_INT 8
114995: EQUAL
114996: PUSH
114997: LD_VAR 0 4
115001: PUSH
115002: LD_VAR 0 7
115006: ARRAY
115007: PPUSH
115008: CALL_OW 264
115012: PUSH
115013: LD_INT 28
115015: PUSH
115016: LD_INT 45
115018: PUSH
115019: LD_INT 7
115021: PUSH
115022: LD_INT 47
115024: PUSH
115025: EMPTY
115026: LIST
115027: LIST
115028: LIST
115029: LIST
115030: IN
115031: OR
115032: IFFALSE 115288
// begin attacking := false ;
115034: LD_ADDR_VAR 0 29
115038: PUSH
115039: LD_INT 0
115041: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115042: LD_VAR 0 14
115046: PUSH
115047: LD_INT 1
115049: ARRAY
115050: PPUSH
115051: CALL_OW 266
115055: PUSH
115056: LD_INT 32
115058: PUSH
115059: LD_INT 31
115061: PUSH
115062: LD_INT 33
115064: PUSH
115065: LD_INT 4
115067: PUSH
115068: LD_INT 5
115070: PUSH
115071: EMPTY
115072: LIST
115073: LIST
115074: LIST
115075: LIST
115076: LIST
115077: IN
115078: IFFALSE 115264
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115080: LD_ADDR_VAR 0 9
115084: PUSH
115085: LD_VAR 0 14
115089: PUSH
115090: LD_INT 1
115092: ARRAY
115093: PPUSH
115094: CALL_OW 266
115098: PPUSH
115099: LD_VAR 0 14
115103: PUSH
115104: LD_INT 1
115106: ARRAY
115107: PPUSH
115108: CALL_OW 250
115112: PPUSH
115113: LD_VAR 0 14
115117: PUSH
115118: LD_INT 1
115120: ARRAY
115121: PPUSH
115122: CALL_OW 251
115126: PPUSH
115127: LD_VAR 0 14
115131: PUSH
115132: LD_INT 1
115134: ARRAY
115135: PPUSH
115136: CALL_OW 254
115140: PPUSH
115141: LD_VAR 0 14
115145: PUSH
115146: LD_INT 1
115148: ARRAY
115149: PPUSH
115150: CALL_OW 248
115154: PPUSH
115155: LD_INT 0
115157: PPUSH
115158: CALL 33970 0 6
115162: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115163: LD_ADDR_VAR 0 8
115167: PUSH
115168: LD_VAR 0 4
115172: PUSH
115173: LD_VAR 0 7
115177: ARRAY
115178: PPUSH
115179: LD_VAR 0 9
115183: PPUSH
115184: CALL 52713 0 2
115188: ST_TO_ADDR
// if j then
115189: LD_VAR 0 8
115193: IFFALSE 115262
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115195: LD_VAR 0 8
115199: PUSH
115200: LD_INT 1
115202: ARRAY
115203: PPUSH
115204: LD_VAR 0 8
115208: PUSH
115209: LD_INT 2
115211: ARRAY
115212: PPUSH
115213: CALL_OW 488
115217: IFFALSE 115262
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115219: LD_VAR 0 4
115223: PUSH
115224: LD_VAR 0 7
115228: ARRAY
115229: PPUSH
115230: LD_VAR 0 8
115234: PUSH
115235: LD_INT 1
115237: ARRAY
115238: PPUSH
115239: LD_VAR 0 8
115243: PUSH
115244: LD_INT 2
115246: ARRAY
115247: PPUSH
115248: CALL_OW 116
// attacking := true ;
115252: LD_ADDR_VAR 0 29
115256: PUSH
115257: LD_INT 1
115259: ST_TO_ADDR
// continue ;
115260: GO 112635
// end ; end else
115262: GO 115288
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115264: LD_VAR 0 4
115268: PUSH
115269: LD_VAR 0 7
115273: ARRAY
115274: PPUSH
115275: LD_VAR 0 14
115279: PUSH
115280: LD_INT 1
115282: ARRAY
115283: PPUSH
115284: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115288: LD_VAR 0 4
115292: PUSH
115293: LD_VAR 0 7
115297: ARRAY
115298: PPUSH
115299: CALL_OW 265
115303: PUSH
115304: LD_INT 11
115306: EQUAL
115307: IFFALSE 115585
// begin k := 10 ;
115309: LD_ADDR_VAR 0 9
115313: PUSH
115314: LD_INT 10
115316: ST_TO_ADDR
// x := 0 ;
115317: LD_ADDR_VAR 0 10
115321: PUSH
115322: LD_INT 0
115324: ST_TO_ADDR
// if tmp < k then
115325: LD_VAR 0 14
115329: PUSH
115330: LD_VAR 0 9
115334: LESS
115335: IFFALSE 115347
// k := tmp ;
115337: LD_ADDR_VAR 0 9
115341: PUSH
115342: LD_VAR 0 14
115346: ST_TO_ADDR
// for j = k downto 1 do
115347: LD_ADDR_VAR 0 8
115351: PUSH
115352: DOUBLE
115353: LD_VAR 0 9
115357: INC
115358: ST_TO_ADDR
115359: LD_INT 1
115361: PUSH
115362: FOR_DOWNTO
115363: IFFALSE 115438
// begin if GetType ( tmp [ j ] ) = unit_human then
115365: LD_VAR 0 14
115369: PUSH
115370: LD_VAR 0 8
115374: ARRAY
115375: PPUSH
115376: CALL_OW 247
115380: PUSH
115381: LD_INT 1
115383: EQUAL
115384: IFFALSE 115436
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115386: LD_VAR 0 4
115390: PUSH
115391: LD_VAR 0 7
115395: ARRAY
115396: PPUSH
115397: LD_VAR 0 14
115401: PUSH
115402: LD_VAR 0 8
115406: ARRAY
115407: PPUSH
115408: CALL 52967 0 2
// x := tmp [ j ] ;
115412: LD_ADDR_VAR 0 10
115416: PUSH
115417: LD_VAR 0 14
115421: PUSH
115422: LD_VAR 0 8
115426: ARRAY
115427: ST_TO_ADDR
// attacking := true ;
115428: LD_ADDR_VAR 0 29
115432: PUSH
115433: LD_INT 1
115435: ST_TO_ADDR
// end ; end ;
115436: GO 115362
115438: POP
115439: POP
// if not x then
115440: LD_VAR 0 10
115444: NOT
115445: IFFALSE 115585
// begin attacking := true ;
115447: LD_ADDR_VAR 0 29
115451: PUSH
115452: LD_INT 1
115454: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115455: LD_VAR 0 4
115459: PUSH
115460: LD_VAR 0 7
115464: ARRAY
115465: PPUSH
115466: CALL_OW 250
115470: PPUSH
115471: LD_VAR 0 4
115475: PUSH
115476: LD_VAR 0 7
115480: ARRAY
115481: PPUSH
115482: CALL_OW 251
115486: PPUSH
115487: CALL_OW 546
115491: PUSH
115492: LD_INT 2
115494: ARRAY
115495: PUSH
115496: LD_VAR 0 14
115500: PUSH
115501: LD_INT 1
115503: ARRAY
115504: PPUSH
115505: CALL_OW 250
115509: PPUSH
115510: LD_VAR 0 14
115514: PUSH
115515: LD_INT 1
115517: ARRAY
115518: PPUSH
115519: CALL_OW 251
115523: PPUSH
115524: CALL_OW 546
115528: PUSH
115529: LD_INT 2
115531: ARRAY
115532: EQUAL
115533: IFFALSE 115561
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115535: LD_VAR 0 4
115539: PUSH
115540: LD_VAR 0 7
115544: ARRAY
115545: PPUSH
115546: LD_VAR 0 14
115550: PUSH
115551: LD_INT 1
115553: ARRAY
115554: PPUSH
115555: CALL 52967 0 2
115559: GO 115585
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115561: LD_VAR 0 4
115565: PUSH
115566: LD_VAR 0 7
115570: ARRAY
115571: PPUSH
115572: LD_VAR 0 14
115576: PUSH
115577: LD_INT 1
115579: ARRAY
115580: PPUSH
115581: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115585: LD_VAR 0 4
115589: PUSH
115590: LD_VAR 0 7
115594: ARRAY
115595: PPUSH
115596: CALL_OW 264
115600: PUSH
115601: LD_INT 29
115603: EQUAL
115604: IFFALSE 115970
// begin if WantsToAttack ( group [ i ] ) in bombed then
115606: LD_VAR 0 4
115610: PUSH
115611: LD_VAR 0 7
115615: ARRAY
115616: PPUSH
115617: CALL_OW 319
115621: PUSH
115622: LD_VAR 0 28
115626: IN
115627: IFFALSE 115631
// continue ;
115629: GO 112635
// k := 8 ;
115631: LD_ADDR_VAR 0 9
115635: PUSH
115636: LD_INT 8
115638: ST_TO_ADDR
// x := 0 ;
115639: LD_ADDR_VAR 0 10
115643: PUSH
115644: LD_INT 0
115646: ST_TO_ADDR
// if tmp < k then
115647: LD_VAR 0 14
115651: PUSH
115652: LD_VAR 0 9
115656: LESS
115657: IFFALSE 115669
// k := tmp ;
115659: LD_ADDR_VAR 0 9
115663: PUSH
115664: LD_VAR 0 14
115668: ST_TO_ADDR
// for j = 1 to k do
115669: LD_ADDR_VAR 0 8
115673: PUSH
115674: DOUBLE
115675: LD_INT 1
115677: DEC
115678: ST_TO_ADDR
115679: LD_VAR 0 9
115683: PUSH
115684: FOR_TO
115685: IFFALSE 115817
// begin if GetType ( tmp [ j ] ) = unit_building then
115687: LD_VAR 0 14
115691: PUSH
115692: LD_VAR 0 8
115696: ARRAY
115697: PPUSH
115698: CALL_OW 247
115702: PUSH
115703: LD_INT 3
115705: EQUAL
115706: IFFALSE 115815
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115708: LD_VAR 0 14
115712: PUSH
115713: LD_VAR 0 8
115717: ARRAY
115718: PUSH
115719: LD_VAR 0 28
115723: IN
115724: NOT
115725: PUSH
115726: LD_VAR 0 14
115730: PUSH
115731: LD_VAR 0 8
115735: ARRAY
115736: PPUSH
115737: CALL_OW 313
115741: AND
115742: IFFALSE 115815
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115744: LD_VAR 0 4
115748: PUSH
115749: LD_VAR 0 7
115753: ARRAY
115754: PPUSH
115755: LD_VAR 0 14
115759: PUSH
115760: LD_VAR 0 8
115764: ARRAY
115765: PPUSH
115766: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115770: LD_ADDR_VAR 0 28
115774: PUSH
115775: LD_VAR 0 28
115779: PPUSH
115780: LD_VAR 0 28
115784: PUSH
115785: LD_INT 1
115787: PLUS
115788: PPUSH
115789: LD_VAR 0 14
115793: PUSH
115794: LD_VAR 0 8
115798: ARRAY
115799: PPUSH
115800: CALL_OW 1
115804: ST_TO_ADDR
// attacking := true ;
115805: LD_ADDR_VAR 0 29
115809: PUSH
115810: LD_INT 1
115812: ST_TO_ADDR
// break ;
115813: GO 115817
// end ; end ;
115815: GO 115684
115817: POP
115818: POP
// if not attacking and f_attack_depot then
115819: LD_VAR 0 29
115823: NOT
115824: PUSH
115825: LD_VAR 0 25
115829: AND
115830: IFFALSE 115925
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115832: LD_ADDR_VAR 0 13
115836: PUSH
115837: LD_VAR 0 14
115841: PPUSH
115842: LD_INT 2
115844: PUSH
115845: LD_INT 30
115847: PUSH
115848: LD_INT 0
115850: PUSH
115851: EMPTY
115852: LIST
115853: LIST
115854: PUSH
115855: LD_INT 30
115857: PUSH
115858: LD_INT 1
115860: PUSH
115861: EMPTY
115862: LIST
115863: LIST
115864: PUSH
115865: EMPTY
115866: LIST
115867: LIST
115868: LIST
115869: PPUSH
115870: CALL_OW 72
115874: ST_TO_ADDR
// if z then
115875: LD_VAR 0 13
115879: IFFALSE 115925
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115881: LD_VAR 0 4
115885: PUSH
115886: LD_VAR 0 7
115890: ARRAY
115891: PPUSH
115892: LD_VAR 0 13
115896: PPUSH
115897: LD_VAR 0 4
115901: PUSH
115902: LD_VAR 0 7
115906: ARRAY
115907: PPUSH
115908: CALL_OW 74
115912: PPUSH
115913: CALL_OW 115
// attacking := true ;
115917: LD_ADDR_VAR 0 29
115921: PUSH
115922: LD_INT 1
115924: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115925: LD_VAR 0 4
115929: PUSH
115930: LD_VAR 0 7
115934: ARRAY
115935: PPUSH
115936: CALL_OW 256
115940: PUSH
115941: LD_INT 500
115943: LESS
115944: IFFALSE 115970
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115946: LD_VAR 0 4
115950: PUSH
115951: LD_VAR 0 7
115955: ARRAY
115956: PPUSH
115957: LD_VAR 0 14
115961: PUSH
115962: LD_INT 1
115964: ARRAY
115965: PPUSH
115966: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115970: LD_VAR 0 4
115974: PUSH
115975: LD_VAR 0 7
115979: ARRAY
115980: PPUSH
115981: CALL_OW 264
115985: PUSH
115986: LD_INT 49
115988: EQUAL
115989: IFFALSE 116110
// begin if not HasTask ( group [ i ] ) then
115991: LD_VAR 0 4
115995: PUSH
115996: LD_VAR 0 7
116000: ARRAY
116001: PPUSH
116002: CALL_OW 314
116006: NOT
116007: IFFALSE 116110
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116009: LD_ADDR_VAR 0 9
116013: PUSH
116014: LD_INT 81
116016: PUSH
116017: LD_VAR 0 4
116021: PUSH
116022: LD_VAR 0 7
116026: ARRAY
116027: PPUSH
116028: CALL_OW 255
116032: PUSH
116033: EMPTY
116034: LIST
116035: LIST
116036: PPUSH
116037: CALL_OW 69
116041: PPUSH
116042: LD_VAR 0 4
116046: PUSH
116047: LD_VAR 0 7
116051: ARRAY
116052: PPUSH
116053: CALL_OW 74
116057: ST_TO_ADDR
// if k then
116058: LD_VAR 0 9
116062: IFFALSE 116110
// if GetDistUnits ( group [ i ] , k ) > 10 then
116064: LD_VAR 0 4
116068: PUSH
116069: LD_VAR 0 7
116073: ARRAY
116074: PPUSH
116075: LD_VAR 0 9
116079: PPUSH
116080: CALL_OW 296
116084: PUSH
116085: LD_INT 10
116087: GREATER
116088: IFFALSE 116110
// ComMoveUnit ( group [ i ] , k ) ;
116090: LD_VAR 0 4
116094: PUSH
116095: LD_VAR 0 7
116099: ARRAY
116100: PPUSH
116101: LD_VAR 0 9
116105: PPUSH
116106: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116110: LD_VAR 0 4
116114: PUSH
116115: LD_VAR 0 7
116119: ARRAY
116120: PPUSH
116121: CALL_OW 256
116125: PUSH
116126: LD_INT 250
116128: LESS
116129: PUSH
116130: LD_VAR 0 4
116134: PUSH
116135: LD_VAR 0 7
116139: ARRAY
116140: PUSH
116141: LD_INT 21
116143: PUSH
116144: LD_INT 2
116146: PUSH
116147: EMPTY
116148: LIST
116149: LIST
116150: PUSH
116151: LD_INT 23
116153: PUSH
116154: LD_INT 2
116156: PUSH
116157: EMPTY
116158: LIST
116159: LIST
116160: PUSH
116161: EMPTY
116162: LIST
116163: LIST
116164: PPUSH
116165: CALL_OW 69
116169: IN
116170: AND
116171: IFFALSE 116296
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116173: LD_ADDR_VAR 0 9
116177: PUSH
116178: LD_OWVAR 3
116182: PUSH
116183: LD_VAR 0 4
116187: PUSH
116188: LD_VAR 0 7
116192: ARRAY
116193: DIFF
116194: PPUSH
116195: LD_VAR 0 4
116199: PUSH
116200: LD_VAR 0 7
116204: ARRAY
116205: PPUSH
116206: CALL_OW 74
116210: ST_TO_ADDR
// if not k then
116211: LD_VAR 0 9
116215: NOT
116216: IFFALSE 116220
// continue ;
116218: GO 112635
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116220: LD_VAR 0 9
116224: PUSH
116225: LD_INT 81
116227: PUSH
116228: LD_VAR 0 4
116232: PUSH
116233: LD_VAR 0 7
116237: ARRAY
116238: PPUSH
116239: CALL_OW 255
116243: PUSH
116244: EMPTY
116245: LIST
116246: LIST
116247: PPUSH
116248: CALL_OW 69
116252: IN
116253: PUSH
116254: LD_VAR 0 9
116258: PPUSH
116259: LD_VAR 0 4
116263: PUSH
116264: LD_VAR 0 7
116268: ARRAY
116269: PPUSH
116270: CALL_OW 296
116274: PUSH
116275: LD_INT 5
116277: LESS
116278: AND
116279: IFFALSE 116296
// ComAutodestruct ( group [ i ] ) ;
116281: LD_VAR 0 4
116285: PUSH
116286: LD_VAR 0 7
116290: ARRAY
116291: PPUSH
116292: CALL 52865 0 1
// end ; if f_attack_depot then
116296: LD_VAR 0 25
116300: IFFALSE 116412
// begin k := 6 ;
116302: LD_ADDR_VAR 0 9
116306: PUSH
116307: LD_INT 6
116309: ST_TO_ADDR
// if tmp < k then
116310: LD_VAR 0 14
116314: PUSH
116315: LD_VAR 0 9
116319: LESS
116320: IFFALSE 116332
// k := tmp ;
116322: LD_ADDR_VAR 0 9
116326: PUSH
116327: LD_VAR 0 14
116331: ST_TO_ADDR
// for j = 1 to k do
116332: LD_ADDR_VAR 0 8
116336: PUSH
116337: DOUBLE
116338: LD_INT 1
116340: DEC
116341: ST_TO_ADDR
116342: LD_VAR 0 9
116346: PUSH
116347: FOR_TO
116348: IFFALSE 116410
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116350: LD_VAR 0 8
116354: PPUSH
116355: CALL_OW 266
116359: PUSH
116360: LD_INT 0
116362: PUSH
116363: LD_INT 1
116365: PUSH
116366: EMPTY
116367: LIST
116368: LIST
116369: IN
116370: IFFALSE 116408
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116372: LD_VAR 0 4
116376: PUSH
116377: LD_VAR 0 7
116381: ARRAY
116382: PPUSH
116383: LD_VAR 0 14
116387: PUSH
116388: LD_VAR 0 8
116392: ARRAY
116393: PPUSH
116394: CALL_OW 115
// attacking := true ;
116398: LD_ADDR_VAR 0 29
116402: PUSH
116403: LD_INT 1
116405: ST_TO_ADDR
// break ;
116406: GO 116410
// end ;
116408: GO 116347
116410: POP
116411: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116412: LD_VAR 0 4
116416: PUSH
116417: LD_VAR 0 7
116421: ARRAY
116422: PPUSH
116423: CALL_OW 302
116427: PUSH
116428: LD_VAR 0 29
116432: NOT
116433: AND
116434: IFFALSE 116756
// begin if GetTag ( group [ i ] ) = 71 then
116436: LD_VAR 0 4
116440: PUSH
116441: LD_VAR 0 7
116445: ARRAY
116446: PPUSH
116447: CALL_OW 110
116451: PUSH
116452: LD_INT 71
116454: EQUAL
116455: IFFALSE 116496
// begin if HasTask ( group [ i ] ) then
116457: LD_VAR 0 4
116461: PUSH
116462: LD_VAR 0 7
116466: ARRAY
116467: PPUSH
116468: CALL_OW 314
116472: IFFALSE 116478
// continue else
116474: GO 112635
116476: GO 116496
// SetTag ( group [ i ] , 0 ) ;
116478: LD_VAR 0 4
116482: PUSH
116483: LD_VAR 0 7
116487: ARRAY
116488: PPUSH
116489: LD_INT 0
116491: PPUSH
116492: CALL_OW 109
// end ; k := 8 ;
116496: LD_ADDR_VAR 0 9
116500: PUSH
116501: LD_INT 8
116503: ST_TO_ADDR
// x := 0 ;
116504: LD_ADDR_VAR 0 10
116508: PUSH
116509: LD_INT 0
116511: ST_TO_ADDR
// if tmp < k then
116512: LD_VAR 0 14
116516: PUSH
116517: LD_VAR 0 9
116521: LESS
116522: IFFALSE 116534
// k := tmp ;
116524: LD_ADDR_VAR 0 9
116528: PUSH
116529: LD_VAR 0 14
116533: ST_TO_ADDR
// for j = 1 to k do
116534: LD_ADDR_VAR 0 8
116538: PUSH
116539: DOUBLE
116540: LD_INT 1
116542: DEC
116543: ST_TO_ADDR
116544: LD_VAR 0 9
116548: PUSH
116549: FOR_TO
116550: IFFALSE 116648
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116552: LD_VAR 0 14
116556: PUSH
116557: LD_VAR 0 8
116561: ARRAY
116562: PPUSH
116563: CALL_OW 247
116567: PUSH
116568: LD_INT 1
116570: EQUAL
116571: PUSH
116572: LD_VAR 0 14
116576: PUSH
116577: LD_VAR 0 8
116581: ARRAY
116582: PPUSH
116583: CALL_OW 256
116587: PUSH
116588: LD_INT 250
116590: LESS
116591: PUSH
116592: LD_VAR 0 20
116596: AND
116597: PUSH
116598: LD_VAR 0 20
116602: NOT
116603: PUSH
116604: LD_VAR 0 14
116608: PUSH
116609: LD_VAR 0 8
116613: ARRAY
116614: PPUSH
116615: CALL_OW 256
116619: PUSH
116620: LD_INT 250
116622: GREATEREQUAL
116623: AND
116624: OR
116625: AND
116626: IFFALSE 116646
// begin x := tmp [ j ] ;
116628: LD_ADDR_VAR 0 10
116632: PUSH
116633: LD_VAR 0 14
116637: PUSH
116638: LD_VAR 0 8
116642: ARRAY
116643: ST_TO_ADDR
// break ;
116644: GO 116648
// end ;
116646: GO 116549
116648: POP
116649: POP
// if x then
116650: LD_VAR 0 10
116654: IFFALSE 116678
// ComAttackUnit ( group [ i ] , x ) else
116656: LD_VAR 0 4
116660: PUSH
116661: LD_VAR 0 7
116665: ARRAY
116666: PPUSH
116667: LD_VAR 0 10
116671: PPUSH
116672: CALL_OW 115
116676: GO 116702
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116678: LD_VAR 0 4
116682: PUSH
116683: LD_VAR 0 7
116687: ARRAY
116688: PPUSH
116689: LD_VAR 0 14
116693: PUSH
116694: LD_INT 1
116696: ARRAY
116697: PPUSH
116698: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116702: LD_VAR 0 4
116706: PUSH
116707: LD_VAR 0 7
116711: ARRAY
116712: PPUSH
116713: CALL_OW 314
116717: NOT
116718: IFFALSE 116756
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116720: LD_VAR 0 4
116724: PUSH
116725: LD_VAR 0 7
116729: ARRAY
116730: PPUSH
116731: LD_VAR 0 14
116735: PPUSH
116736: LD_VAR 0 4
116740: PUSH
116741: LD_VAR 0 7
116745: ARRAY
116746: PPUSH
116747: CALL_OW 74
116751: PPUSH
116752: CALL_OW 115
// end ; end ; end ;
116756: GO 112635
116758: POP
116759: POP
// wait ( 0 0$2 ) ;
116760: LD_INT 70
116762: PPUSH
116763: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116767: LD_VAR 0 4
116771: NOT
116772: PUSH
116773: LD_VAR 0 4
116777: PUSH
116778: EMPTY
116779: EQUAL
116780: OR
116781: PUSH
116782: LD_INT 81
116784: PUSH
116785: LD_VAR 0 35
116789: PUSH
116790: EMPTY
116791: LIST
116792: LIST
116793: PPUSH
116794: CALL_OW 69
116798: NOT
116799: OR
116800: IFFALSE 112620
// end ;
116802: LD_VAR 0 2
116806: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116807: LD_INT 0
116809: PPUSH
116810: PPUSH
116811: PPUSH
116812: PPUSH
116813: PPUSH
116814: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116815: LD_VAR 0 1
116819: NOT
116820: PUSH
116821: LD_EXP 31
116825: PUSH
116826: LD_VAR 0 1
116830: ARRAY
116831: NOT
116832: OR
116833: PUSH
116834: LD_VAR 0 2
116838: NOT
116839: OR
116840: IFFALSE 116844
// exit ;
116842: GO 117398
// side := mc_sides [ base ] ;
116844: LD_ADDR_VAR 0 6
116848: PUSH
116849: LD_EXP 57
116853: PUSH
116854: LD_VAR 0 1
116858: ARRAY
116859: ST_TO_ADDR
// if not side then
116860: LD_VAR 0 6
116864: NOT
116865: IFFALSE 116869
// exit ;
116867: GO 117398
// for i in solds do
116869: LD_ADDR_VAR 0 7
116873: PUSH
116874: LD_VAR 0 2
116878: PUSH
116879: FOR_IN
116880: IFFALSE 116941
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116882: LD_VAR 0 7
116886: PPUSH
116887: CALL_OW 310
116891: PPUSH
116892: CALL_OW 266
116896: PUSH
116897: LD_INT 32
116899: PUSH
116900: LD_INT 31
116902: PUSH
116903: EMPTY
116904: LIST
116905: LIST
116906: IN
116907: IFFALSE 116927
// solds := solds diff i else
116909: LD_ADDR_VAR 0 2
116913: PUSH
116914: LD_VAR 0 2
116918: PUSH
116919: LD_VAR 0 7
116923: DIFF
116924: ST_TO_ADDR
116925: GO 116939
// SetTag ( i , 18 ) ;
116927: LD_VAR 0 7
116931: PPUSH
116932: LD_INT 18
116934: PPUSH
116935: CALL_OW 109
116939: GO 116879
116941: POP
116942: POP
// if not solds then
116943: LD_VAR 0 2
116947: NOT
116948: IFFALSE 116952
// exit ;
116950: GO 117398
// repeat wait ( 0 0$2 ) ;
116952: LD_INT 70
116954: PPUSH
116955: CALL_OW 67
// enemy := mc_scan [ base ] ;
116959: LD_ADDR_VAR 0 4
116963: PUSH
116964: LD_EXP 54
116968: PUSH
116969: LD_VAR 0 1
116973: ARRAY
116974: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116975: LD_EXP 31
116979: PUSH
116980: LD_VAR 0 1
116984: ARRAY
116985: NOT
116986: PUSH
116987: LD_EXP 31
116991: PUSH
116992: LD_VAR 0 1
116996: ARRAY
116997: PUSH
116998: EMPTY
116999: EQUAL
117000: OR
117001: IFFALSE 117038
// begin for i in solds do
117003: LD_ADDR_VAR 0 7
117007: PUSH
117008: LD_VAR 0 2
117012: PUSH
117013: FOR_IN
117014: IFFALSE 117027
// ComStop ( i ) ;
117016: LD_VAR 0 7
117020: PPUSH
117021: CALL_OW 141
117025: GO 117013
117027: POP
117028: POP
// solds := [ ] ;
117029: LD_ADDR_VAR 0 2
117033: PUSH
117034: EMPTY
117035: ST_TO_ADDR
// exit ;
117036: GO 117398
// end ; for i in solds do
117038: LD_ADDR_VAR 0 7
117042: PUSH
117043: LD_VAR 0 2
117047: PUSH
117048: FOR_IN
117049: IFFALSE 117370
// begin if IsInUnit ( i ) then
117051: LD_VAR 0 7
117055: PPUSH
117056: CALL_OW 310
117060: IFFALSE 117071
// ComExitBuilding ( i ) ;
117062: LD_VAR 0 7
117066: PPUSH
117067: CALL_OW 122
// if GetLives ( i ) > 500 then
117071: LD_VAR 0 7
117075: PPUSH
117076: CALL_OW 256
117080: PUSH
117081: LD_INT 500
117083: GREATER
117084: IFFALSE 117137
// begin e := NearestUnitToUnit ( enemy , i ) ;
117086: LD_ADDR_VAR 0 5
117090: PUSH
117091: LD_VAR 0 4
117095: PPUSH
117096: LD_VAR 0 7
117100: PPUSH
117101: CALL_OW 74
117105: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117106: LD_VAR 0 7
117110: PPUSH
117111: LD_VAR 0 5
117115: PPUSH
117116: CALL_OW 250
117120: PPUSH
117121: LD_VAR 0 5
117125: PPUSH
117126: CALL_OW 251
117130: PPUSH
117131: CALL_OW 114
// end else
117135: GO 117368
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
117137: LD_VAR 0 7
117141: PPUSH
117142: LD_EXP 31
117146: PUSH
117147: LD_VAR 0 1
117151: ARRAY
117152: PPUSH
117153: LD_INT 2
117155: PUSH
117156: LD_INT 30
117158: PUSH
117159: LD_INT 0
117161: PUSH
117162: EMPTY
117163: LIST
117164: LIST
117165: PUSH
117166: LD_INT 30
117168: PUSH
117169: LD_INT 1
117171: PUSH
117172: EMPTY
117173: LIST
117174: LIST
117175: PUSH
117176: LD_INT 30
117178: PUSH
117179: LD_INT 6
117181: PUSH
117182: EMPTY
117183: LIST
117184: LIST
117185: PUSH
117186: EMPTY
117187: LIST
117188: LIST
117189: LIST
117190: LIST
117191: PPUSH
117192: CALL_OW 72
117196: PPUSH
117197: LD_VAR 0 7
117201: PPUSH
117202: CALL_OW 74
117206: PPUSH
117207: CALL_OW 296
117211: PUSH
117212: LD_INT 10
117214: GREATER
117215: IFFALSE 117368
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117217: LD_ADDR_VAR 0 8
117221: PUSH
117222: LD_EXP 31
117226: PUSH
117227: LD_VAR 0 1
117231: ARRAY
117232: PPUSH
117233: LD_INT 2
117235: PUSH
117236: LD_INT 30
117238: PUSH
117239: LD_INT 0
117241: PUSH
117242: EMPTY
117243: LIST
117244: LIST
117245: PUSH
117246: LD_INT 30
117248: PUSH
117249: LD_INT 1
117251: PUSH
117252: EMPTY
117253: LIST
117254: LIST
117255: PUSH
117256: LD_INT 30
117258: PUSH
117259: LD_INT 6
117261: PUSH
117262: EMPTY
117263: LIST
117264: LIST
117265: PUSH
117266: EMPTY
117267: LIST
117268: LIST
117269: LIST
117270: LIST
117271: PPUSH
117272: CALL_OW 72
117276: PPUSH
117277: LD_VAR 0 7
117281: PPUSH
117282: CALL_OW 74
117286: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117287: LD_VAR 0 7
117291: PPUSH
117292: LD_VAR 0 8
117296: PPUSH
117297: CALL_OW 250
117301: PPUSH
117302: LD_INT 3
117304: PPUSH
117305: LD_INT 5
117307: PPUSH
117308: CALL_OW 272
117312: PPUSH
117313: LD_VAR 0 8
117317: PPUSH
117318: CALL_OW 251
117322: PPUSH
117323: LD_INT 3
117325: PPUSH
117326: LD_INT 5
117328: PPUSH
117329: CALL_OW 273
117333: PPUSH
117334: CALL_OW 111
// SetTag ( i , 0 ) ;
117338: LD_VAR 0 7
117342: PPUSH
117343: LD_INT 0
117345: PPUSH
117346: CALL_OW 109
// solds := solds diff i ;
117350: LD_ADDR_VAR 0 2
117354: PUSH
117355: LD_VAR 0 2
117359: PUSH
117360: LD_VAR 0 7
117364: DIFF
117365: ST_TO_ADDR
// continue ;
117366: GO 117048
// end ; end ;
117368: GO 117048
117370: POP
117371: POP
// until not solds or not enemy ;
117372: LD_VAR 0 2
117376: NOT
117377: PUSH
117378: LD_VAR 0 4
117382: NOT
117383: OR
117384: IFFALSE 116952
// MC_Reset ( base , 18 ) ;
117386: LD_VAR 0 1
117390: PPUSH
117391: LD_INT 18
117393: PPUSH
117394: CALL 65474 0 2
// end ;
117398: LD_VAR 0 3
117402: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117403: LD_INT 0
117405: PPUSH
117406: PPUSH
117407: PPUSH
117408: PPUSH
117409: PPUSH
117410: PPUSH
117411: PPUSH
117412: PPUSH
117413: PPUSH
117414: PPUSH
117415: PPUSH
117416: PPUSH
117417: PPUSH
117418: PPUSH
117419: PPUSH
117420: PPUSH
117421: PPUSH
117422: PPUSH
117423: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117424: LD_ADDR_VAR 0 12
117428: PUSH
117429: LD_EXP 31
117433: PUSH
117434: LD_VAR 0 1
117438: ARRAY
117439: PPUSH
117440: LD_INT 25
117442: PUSH
117443: LD_INT 3
117445: PUSH
117446: EMPTY
117447: LIST
117448: LIST
117449: PPUSH
117450: CALL_OW 72
117454: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117455: LD_EXP 71
117459: PUSH
117460: LD_VAR 0 1
117464: ARRAY
117465: IFFALSE 117489
// mechs := mechs diff mc_remote_driver [ base ] ;
117467: LD_ADDR_VAR 0 12
117471: PUSH
117472: LD_VAR 0 12
117476: PUSH
117477: LD_EXP 71
117481: PUSH
117482: LD_VAR 0 1
117486: ARRAY
117487: DIFF
117488: ST_TO_ADDR
// for i in mechs do
117489: LD_ADDR_VAR 0 4
117493: PUSH
117494: LD_VAR 0 12
117498: PUSH
117499: FOR_IN
117500: IFFALSE 117535
// if GetTag ( i ) > 0 then
117502: LD_VAR 0 4
117506: PPUSH
117507: CALL_OW 110
117511: PUSH
117512: LD_INT 0
117514: GREATER
117515: IFFALSE 117533
// mechs := mechs diff i ;
117517: LD_ADDR_VAR 0 12
117521: PUSH
117522: LD_VAR 0 12
117526: PUSH
117527: LD_VAR 0 4
117531: DIFF
117532: ST_TO_ADDR
117533: GO 117499
117535: POP
117536: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117537: LD_ADDR_VAR 0 8
117541: PUSH
117542: LD_EXP 31
117546: PUSH
117547: LD_VAR 0 1
117551: ARRAY
117552: PPUSH
117553: LD_INT 2
117555: PUSH
117556: LD_INT 25
117558: PUSH
117559: LD_INT 1
117561: PUSH
117562: EMPTY
117563: LIST
117564: LIST
117565: PUSH
117566: LD_INT 25
117568: PUSH
117569: LD_INT 5
117571: PUSH
117572: EMPTY
117573: LIST
117574: LIST
117575: PUSH
117576: LD_INT 25
117578: PUSH
117579: LD_INT 8
117581: PUSH
117582: EMPTY
117583: LIST
117584: LIST
117585: PUSH
117586: LD_INT 25
117588: PUSH
117589: LD_INT 9
117591: PUSH
117592: EMPTY
117593: LIST
117594: LIST
117595: PUSH
117596: EMPTY
117597: LIST
117598: LIST
117599: LIST
117600: LIST
117601: LIST
117602: PPUSH
117603: CALL_OW 72
117607: ST_TO_ADDR
// if not defenders and not solds then
117608: LD_VAR 0 2
117612: NOT
117613: PUSH
117614: LD_VAR 0 8
117618: NOT
117619: AND
117620: IFFALSE 117624
// exit ;
117622: GO 119394
// depot_under_attack := false ;
117624: LD_ADDR_VAR 0 16
117628: PUSH
117629: LD_INT 0
117631: ST_TO_ADDR
// sold_defenders := [ ] ;
117632: LD_ADDR_VAR 0 17
117636: PUSH
117637: EMPTY
117638: ST_TO_ADDR
// if mechs then
117639: LD_VAR 0 12
117643: IFFALSE 117796
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117645: LD_ADDR_VAR 0 4
117649: PUSH
117650: LD_VAR 0 2
117654: PPUSH
117655: LD_INT 21
117657: PUSH
117658: LD_INT 2
117660: PUSH
117661: EMPTY
117662: LIST
117663: LIST
117664: PPUSH
117665: CALL_OW 72
117669: PUSH
117670: FOR_IN
117671: IFFALSE 117794
// begin if GetTag ( i ) <> 20 then
117673: LD_VAR 0 4
117677: PPUSH
117678: CALL_OW 110
117682: PUSH
117683: LD_INT 20
117685: NONEQUAL
117686: IFFALSE 117700
// SetTag ( i , 20 ) ;
117688: LD_VAR 0 4
117692: PPUSH
117693: LD_INT 20
117695: PPUSH
117696: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117700: LD_VAR 0 4
117704: PPUSH
117705: CALL_OW 263
117709: PUSH
117710: LD_INT 1
117712: EQUAL
117713: PUSH
117714: LD_VAR 0 4
117718: PPUSH
117719: CALL_OW 311
117723: NOT
117724: AND
117725: IFFALSE 117792
// begin un := mechs [ 1 ] ;
117727: LD_ADDR_VAR 0 10
117731: PUSH
117732: LD_VAR 0 12
117736: PUSH
117737: LD_INT 1
117739: ARRAY
117740: ST_TO_ADDR
// ComExit ( un ) ;
117741: LD_VAR 0 10
117745: PPUSH
117746: CALL 57750 0 1
// AddComEnterUnit ( un , i ) ;
117750: LD_VAR 0 10
117754: PPUSH
117755: LD_VAR 0 4
117759: PPUSH
117760: CALL_OW 180
// SetTag ( un , 19 ) ;
117764: LD_VAR 0 10
117768: PPUSH
117769: LD_INT 19
117771: PPUSH
117772: CALL_OW 109
// mechs := mechs diff un ;
117776: LD_ADDR_VAR 0 12
117780: PUSH
117781: LD_VAR 0 12
117785: PUSH
117786: LD_VAR 0 10
117790: DIFF
117791: ST_TO_ADDR
// end ; end ;
117792: GO 117670
117794: POP
117795: POP
// if solds then
117796: LD_VAR 0 8
117800: IFFALSE 117859
// for i in solds do
117802: LD_ADDR_VAR 0 4
117806: PUSH
117807: LD_VAR 0 8
117811: PUSH
117812: FOR_IN
117813: IFFALSE 117857
// if not GetTag ( i ) then
117815: LD_VAR 0 4
117819: PPUSH
117820: CALL_OW 110
117824: NOT
117825: IFFALSE 117855
// begin defenders := defenders union i ;
117827: LD_ADDR_VAR 0 2
117831: PUSH
117832: LD_VAR 0 2
117836: PUSH
117837: LD_VAR 0 4
117841: UNION
117842: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117843: LD_VAR 0 4
117847: PPUSH
117848: LD_INT 18
117850: PPUSH
117851: CALL_OW 109
// end ;
117855: GO 117812
117857: POP
117858: POP
// repeat wait ( 0 0$2 ) ;
117859: LD_INT 70
117861: PPUSH
117862: CALL_OW 67
// enemy := mc_scan [ base ] ;
117866: LD_ADDR_VAR 0 21
117870: PUSH
117871: LD_EXP 54
117875: PUSH
117876: LD_VAR 0 1
117880: ARRAY
117881: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117882: LD_EXP 31
117886: PUSH
117887: LD_VAR 0 1
117891: ARRAY
117892: NOT
117893: PUSH
117894: LD_EXP 31
117898: PUSH
117899: LD_VAR 0 1
117903: ARRAY
117904: PUSH
117905: EMPTY
117906: EQUAL
117907: OR
117908: IFFALSE 117945
// begin for i in defenders do
117910: LD_ADDR_VAR 0 4
117914: PUSH
117915: LD_VAR 0 2
117919: PUSH
117920: FOR_IN
117921: IFFALSE 117934
// ComStop ( i ) ;
117923: LD_VAR 0 4
117927: PPUSH
117928: CALL_OW 141
117932: GO 117920
117934: POP
117935: POP
// defenders := [ ] ;
117936: LD_ADDR_VAR 0 2
117940: PUSH
117941: EMPTY
117942: ST_TO_ADDR
// exit ;
117943: GO 119394
// end ; for i in defenders do
117945: LD_ADDR_VAR 0 4
117949: PUSH
117950: LD_VAR 0 2
117954: PUSH
117955: FOR_IN
117956: IFFALSE 118854
// begin e := NearestUnitToUnit ( enemy , i ) ;
117958: LD_ADDR_VAR 0 13
117962: PUSH
117963: LD_VAR 0 21
117967: PPUSH
117968: LD_VAR 0 4
117972: PPUSH
117973: CALL_OW 74
117977: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117978: LD_ADDR_VAR 0 7
117982: PUSH
117983: LD_EXP 31
117987: PUSH
117988: LD_VAR 0 1
117992: ARRAY
117993: PPUSH
117994: LD_INT 2
117996: PUSH
117997: LD_INT 30
117999: PUSH
118000: LD_INT 0
118002: PUSH
118003: EMPTY
118004: LIST
118005: LIST
118006: PUSH
118007: LD_INT 30
118009: PUSH
118010: LD_INT 1
118012: PUSH
118013: EMPTY
118014: LIST
118015: LIST
118016: PUSH
118017: EMPTY
118018: LIST
118019: LIST
118020: LIST
118021: PPUSH
118022: CALL_OW 72
118026: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118027: LD_ADDR_VAR 0 16
118031: PUSH
118032: LD_VAR 0 7
118036: NOT
118037: PUSH
118038: LD_VAR 0 7
118042: PPUSH
118043: LD_INT 3
118045: PUSH
118046: LD_INT 24
118048: PUSH
118049: LD_INT 600
118051: PUSH
118052: EMPTY
118053: LIST
118054: LIST
118055: PUSH
118056: EMPTY
118057: LIST
118058: LIST
118059: PPUSH
118060: CALL_OW 72
118064: OR
118065: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118066: LD_VAR 0 4
118070: PPUSH
118071: CALL_OW 247
118075: PUSH
118076: LD_INT 2
118078: DOUBLE
118079: EQUAL
118080: IFTRUE 118084
118082: GO 118480
118084: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118085: LD_VAR 0 4
118089: PPUSH
118090: CALL_OW 256
118094: PUSH
118095: LD_INT 1000
118097: EQUAL
118098: PUSH
118099: LD_VAR 0 4
118103: PPUSH
118104: LD_VAR 0 13
118108: PPUSH
118109: CALL_OW 296
118113: PUSH
118114: LD_INT 40
118116: LESS
118117: PUSH
118118: LD_VAR 0 13
118122: PPUSH
118123: LD_EXP 56
118127: PUSH
118128: LD_VAR 0 1
118132: ARRAY
118133: PPUSH
118134: CALL_OW 308
118138: OR
118139: AND
118140: IFFALSE 118262
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118142: LD_VAR 0 4
118146: PPUSH
118147: CALL_OW 262
118151: PUSH
118152: LD_INT 1
118154: EQUAL
118155: PUSH
118156: LD_VAR 0 4
118160: PPUSH
118161: CALL_OW 261
118165: PUSH
118166: LD_INT 30
118168: LESS
118169: AND
118170: PUSH
118171: LD_VAR 0 7
118175: AND
118176: IFFALSE 118246
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118178: LD_VAR 0 4
118182: PPUSH
118183: LD_VAR 0 7
118187: PPUSH
118188: LD_VAR 0 4
118192: PPUSH
118193: CALL_OW 74
118197: PPUSH
118198: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118202: LD_VAR 0 4
118206: PPUSH
118207: LD_VAR 0 7
118211: PPUSH
118212: LD_VAR 0 4
118216: PPUSH
118217: CALL_OW 74
118221: PPUSH
118222: CALL_OW 296
118226: PUSH
118227: LD_INT 6
118229: LESS
118230: IFFALSE 118244
// SetFuel ( i , 100 ) ;
118232: LD_VAR 0 4
118236: PPUSH
118237: LD_INT 100
118239: PPUSH
118240: CALL_OW 240
// end else
118244: GO 118260
// ComAttackUnit ( i , e ) ;
118246: LD_VAR 0 4
118250: PPUSH
118251: LD_VAR 0 13
118255: PPUSH
118256: CALL_OW 115
// end else
118260: GO 118363
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118262: LD_VAR 0 13
118266: PPUSH
118267: LD_EXP 56
118271: PUSH
118272: LD_VAR 0 1
118276: ARRAY
118277: PPUSH
118278: CALL_OW 308
118282: NOT
118283: PUSH
118284: LD_VAR 0 4
118288: PPUSH
118289: LD_VAR 0 13
118293: PPUSH
118294: CALL_OW 296
118298: PUSH
118299: LD_INT 40
118301: GREATEREQUAL
118302: AND
118303: PUSH
118304: LD_VAR 0 4
118308: PPUSH
118309: CALL_OW 256
118313: PUSH
118314: LD_INT 650
118316: LESSEQUAL
118317: OR
118318: PUSH
118319: LD_VAR 0 4
118323: PPUSH
118324: LD_EXP 55
118328: PUSH
118329: LD_VAR 0 1
118333: ARRAY
118334: PPUSH
118335: CALL_OW 308
118339: NOT
118340: AND
118341: IFFALSE 118363
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118343: LD_VAR 0 4
118347: PPUSH
118348: LD_EXP 55
118352: PUSH
118353: LD_VAR 0 1
118357: ARRAY
118358: PPUSH
118359: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118363: LD_VAR 0 4
118367: PPUSH
118368: CALL_OW 256
118372: PUSH
118373: LD_INT 1000
118375: LESS
118376: PUSH
118377: LD_VAR 0 4
118381: PPUSH
118382: CALL_OW 263
118386: PUSH
118387: LD_INT 1
118389: EQUAL
118390: AND
118391: PUSH
118392: LD_VAR 0 4
118396: PPUSH
118397: CALL_OW 311
118401: AND
118402: PUSH
118403: LD_VAR 0 4
118407: PPUSH
118408: LD_EXP 55
118412: PUSH
118413: LD_VAR 0 1
118417: ARRAY
118418: PPUSH
118419: CALL_OW 308
118423: AND
118424: IFFALSE 118478
// begin mech := IsDrivenBy ( i ) ;
118426: LD_ADDR_VAR 0 9
118430: PUSH
118431: LD_VAR 0 4
118435: PPUSH
118436: CALL_OW 311
118440: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118441: LD_VAR 0 9
118445: PPUSH
118446: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118450: LD_VAR 0 9
118454: PPUSH
118455: LD_VAR 0 4
118459: PPUSH
118460: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118464: LD_VAR 0 9
118468: PPUSH
118469: LD_VAR 0 4
118473: PPUSH
118474: CALL_OW 180
// end ; end ; unit_human :
118478: GO 118825
118480: LD_INT 1
118482: DOUBLE
118483: EQUAL
118484: IFTRUE 118488
118486: GO 118824
118488: POP
// begin b := IsInUnit ( i ) ;
118489: LD_ADDR_VAR 0 18
118493: PUSH
118494: LD_VAR 0 4
118498: PPUSH
118499: CALL_OW 310
118503: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118504: LD_ADDR_VAR 0 19
118508: PUSH
118509: LD_VAR 0 18
118513: NOT
118514: PUSH
118515: LD_VAR 0 18
118519: PPUSH
118520: CALL_OW 266
118524: PUSH
118525: LD_INT 32
118527: PUSH
118528: LD_INT 31
118530: PUSH
118531: EMPTY
118532: LIST
118533: LIST
118534: IN
118535: OR
118536: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118537: LD_VAR 0 18
118541: PPUSH
118542: CALL_OW 266
118546: PUSH
118547: LD_INT 5
118549: EQUAL
118550: PUSH
118551: LD_VAR 0 4
118555: PPUSH
118556: CALL_OW 257
118560: PUSH
118561: LD_INT 1
118563: PUSH
118564: LD_INT 2
118566: PUSH
118567: LD_INT 3
118569: PUSH
118570: LD_INT 4
118572: PUSH
118573: EMPTY
118574: LIST
118575: LIST
118576: LIST
118577: LIST
118578: IN
118579: AND
118580: IFFALSE 118617
// begin class := AllowSpecClass ( i ) ;
118582: LD_ADDR_VAR 0 20
118586: PUSH
118587: LD_VAR 0 4
118591: PPUSH
118592: CALL 21670 0 1
118596: ST_TO_ADDR
// if class then
118597: LD_VAR 0 20
118601: IFFALSE 118617
// ComChangeProfession ( i , class ) ;
118603: LD_VAR 0 4
118607: PPUSH
118608: LD_VAR 0 20
118612: PPUSH
118613: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118617: LD_VAR 0 16
118621: PUSH
118622: LD_VAR 0 2
118626: PPUSH
118627: LD_INT 21
118629: PUSH
118630: LD_INT 2
118632: PUSH
118633: EMPTY
118634: LIST
118635: LIST
118636: PPUSH
118637: CALL_OW 72
118641: PUSH
118642: LD_INT 1
118644: LESSEQUAL
118645: OR
118646: PUSH
118647: LD_VAR 0 19
118651: AND
118652: PUSH
118653: LD_VAR 0 4
118657: PUSH
118658: LD_VAR 0 17
118662: IN
118663: NOT
118664: AND
118665: IFFALSE 118758
// begin if b then
118667: LD_VAR 0 18
118671: IFFALSE 118720
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118673: LD_VAR 0 18
118677: PPUSH
118678: LD_VAR 0 21
118682: PPUSH
118683: LD_VAR 0 18
118687: PPUSH
118688: CALL_OW 74
118692: PPUSH
118693: CALL_OW 296
118697: PUSH
118698: LD_INT 10
118700: LESS
118701: PUSH
118702: LD_VAR 0 18
118706: PPUSH
118707: CALL_OW 461
118711: PUSH
118712: LD_INT 7
118714: NONEQUAL
118715: AND
118716: IFFALSE 118720
// continue ;
118718: GO 117955
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118720: LD_ADDR_VAR 0 17
118724: PUSH
118725: LD_VAR 0 17
118729: PPUSH
118730: LD_VAR 0 17
118734: PUSH
118735: LD_INT 1
118737: PLUS
118738: PPUSH
118739: LD_VAR 0 4
118743: PPUSH
118744: CALL_OW 1
118748: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118749: LD_VAR 0 4
118753: PPUSH
118754: CALL_OW 122
// end ; if sold_defenders then
118758: LD_VAR 0 17
118762: IFFALSE 118822
// if i in sold_defenders then
118764: LD_VAR 0 4
118768: PUSH
118769: LD_VAR 0 17
118773: IN
118774: IFFALSE 118822
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118776: LD_VAR 0 4
118780: PPUSH
118781: CALL_OW 314
118785: NOT
118786: PUSH
118787: LD_VAR 0 4
118791: PPUSH
118792: LD_VAR 0 13
118796: PPUSH
118797: CALL_OW 296
118801: PUSH
118802: LD_INT 30
118804: LESS
118805: AND
118806: IFFALSE 118822
// ComAttackUnit ( i , e ) ;
118808: LD_VAR 0 4
118812: PPUSH
118813: LD_VAR 0 13
118817: PPUSH
118818: CALL_OW 115
// end ; end ; end ;
118822: GO 118825
118824: POP
// if IsDead ( i ) then
118825: LD_VAR 0 4
118829: PPUSH
118830: CALL_OW 301
118834: IFFALSE 118852
// defenders := defenders diff i ;
118836: LD_ADDR_VAR 0 2
118840: PUSH
118841: LD_VAR 0 2
118845: PUSH
118846: LD_VAR 0 4
118850: DIFF
118851: ST_TO_ADDR
// end ;
118852: GO 117955
118854: POP
118855: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118856: LD_VAR 0 21
118860: NOT
118861: PUSH
118862: LD_VAR 0 2
118866: NOT
118867: OR
118868: PUSH
118869: LD_EXP 31
118873: PUSH
118874: LD_VAR 0 1
118878: ARRAY
118879: NOT
118880: OR
118881: IFFALSE 117859
// MC_Reset ( base , 18 ) ;
118883: LD_VAR 0 1
118887: PPUSH
118888: LD_INT 18
118890: PPUSH
118891: CALL 65474 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118895: LD_ADDR_VAR 0 2
118899: PUSH
118900: LD_VAR 0 2
118904: PUSH
118905: LD_VAR 0 2
118909: PPUSH
118910: LD_INT 2
118912: PUSH
118913: LD_INT 25
118915: PUSH
118916: LD_INT 1
118918: PUSH
118919: EMPTY
118920: LIST
118921: LIST
118922: PUSH
118923: LD_INT 25
118925: PUSH
118926: LD_INT 5
118928: PUSH
118929: EMPTY
118930: LIST
118931: LIST
118932: PUSH
118933: LD_INT 25
118935: PUSH
118936: LD_INT 8
118938: PUSH
118939: EMPTY
118940: LIST
118941: LIST
118942: PUSH
118943: LD_INT 25
118945: PUSH
118946: LD_INT 9
118948: PUSH
118949: EMPTY
118950: LIST
118951: LIST
118952: PUSH
118953: EMPTY
118954: LIST
118955: LIST
118956: LIST
118957: LIST
118958: LIST
118959: PPUSH
118960: CALL_OW 72
118964: DIFF
118965: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118966: LD_VAR 0 21
118970: NOT
118971: PUSH
118972: LD_VAR 0 2
118976: PPUSH
118977: LD_INT 21
118979: PUSH
118980: LD_INT 2
118982: PUSH
118983: EMPTY
118984: LIST
118985: LIST
118986: PPUSH
118987: CALL_OW 72
118991: AND
118992: IFFALSE 119330
// begin tmp := FilterByTag ( defenders , 19 ) ;
118994: LD_ADDR_VAR 0 11
118998: PUSH
118999: LD_VAR 0 2
119003: PPUSH
119004: LD_INT 19
119006: PPUSH
119007: CALL 54933 0 2
119011: ST_TO_ADDR
// if tmp then
119012: LD_VAR 0 11
119016: IFFALSE 119086
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119018: LD_ADDR_VAR 0 11
119022: PUSH
119023: LD_VAR 0 11
119027: PPUSH
119028: LD_INT 25
119030: PUSH
119031: LD_INT 3
119033: PUSH
119034: EMPTY
119035: LIST
119036: LIST
119037: PPUSH
119038: CALL_OW 72
119042: ST_TO_ADDR
// if tmp then
119043: LD_VAR 0 11
119047: IFFALSE 119086
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119049: LD_ADDR_EXP 43
119053: PUSH
119054: LD_EXP 43
119058: PPUSH
119059: LD_VAR 0 1
119063: PPUSH
119064: LD_EXP 43
119068: PUSH
119069: LD_VAR 0 1
119073: ARRAY
119074: PUSH
119075: LD_VAR 0 11
119079: UNION
119080: PPUSH
119081: CALL_OW 1
119085: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119086: LD_VAR 0 1
119090: PPUSH
119091: LD_INT 19
119093: PPUSH
119094: CALL 65474 0 2
// repeat wait ( 0 0$1 ) ;
119098: LD_INT 35
119100: PPUSH
119101: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119105: LD_EXP 31
119109: PUSH
119110: LD_VAR 0 1
119114: ARRAY
119115: NOT
119116: PUSH
119117: LD_EXP 31
119121: PUSH
119122: LD_VAR 0 1
119126: ARRAY
119127: PUSH
119128: EMPTY
119129: EQUAL
119130: OR
119131: IFFALSE 119168
// begin for i in defenders do
119133: LD_ADDR_VAR 0 4
119137: PUSH
119138: LD_VAR 0 2
119142: PUSH
119143: FOR_IN
119144: IFFALSE 119157
// ComStop ( i ) ;
119146: LD_VAR 0 4
119150: PPUSH
119151: CALL_OW 141
119155: GO 119143
119157: POP
119158: POP
// defenders := [ ] ;
119159: LD_ADDR_VAR 0 2
119163: PUSH
119164: EMPTY
119165: ST_TO_ADDR
// exit ;
119166: GO 119394
// end ; for i in defenders do
119168: LD_ADDR_VAR 0 4
119172: PUSH
119173: LD_VAR 0 2
119177: PUSH
119178: FOR_IN
119179: IFFALSE 119268
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119181: LD_VAR 0 4
119185: PPUSH
119186: LD_EXP 55
119190: PUSH
119191: LD_VAR 0 1
119195: ARRAY
119196: PPUSH
119197: CALL_OW 308
119201: NOT
119202: IFFALSE 119226
// ComMoveToArea ( i , mc_parking [ base ] ) else
119204: LD_VAR 0 4
119208: PPUSH
119209: LD_EXP 55
119213: PUSH
119214: LD_VAR 0 1
119218: ARRAY
119219: PPUSH
119220: CALL_OW 113
119224: GO 119266
// if GetControl ( i ) = control_manual then
119226: LD_VAR 0 4
119230: PPUSH
119231: CALL_OW 263
119235: PUSH
119236: LD_INT 1
119238: EQUAL
119239: IFFALSE 119266
// if IsDrivenBy ( i ) then
119241: LD_VAR 0 4
119245: PPUSH
119246: CALL_OW 311
119250: IFFALSE 119266
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119252: LD_VAR 0 4
119256: PPUSH
119257: CALL_OW 311
119261: PPUSH
119262: CALL_OW 121
// end ;
119266: GO 119178
119268: POP
119269: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119270: LD_VAR 0 2
119274: PPUSH
119275: LD_INT 95
119277: PUSH
119278: LD_EXP 55
119282: PUSH
119283: LD_VAR 0 1
119287: ARRAY
119288: PUSH
119289: EMPTY
119290: LIST
119291: LIST
119292: PPUSH
119293: CALL_OW 72
119297: PUSH
119298: LD_VAR 0 2
119302: EQUAL
119303: PUSH
119304: LD_EXP 54
119308: PUSH
119309: LD_VAR 0 1
119313: ARRAY
119314: OR
119315: PUSH
119316: LD_EXP 31
119320: PUSH
119321: LD_VAR 0 1
119325: ARRAY
119326: NOT
119327: OR
119328: IFFALSE 119098
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119330: LD_ADDR_EXP 53
119334: PUSH
119335: LD_EXP 53
119339: PPUSH
119340: LD_VAR 0 1
119344: PPUSH
119345: LD_VAR 0 2
119349: PPUSH
119350: LD_INT 21
119352: PUSH
119353: LD_INT 2
119355: PUSH
119356: EMPTY
119357: LIST
119358: LIST
119359: PPUSH
119360: CALL_OW 72
119364: PPUSH
119365: CALL_OW 1
119369: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119370: LD_VAR 0 1
119374: PPUSH
119375: LD_INT 19
119377: PPUSH
119378: CALL 65474 0 2
// MC_Reset ( base , 20 ) ;
119382: LD_VAR 0 1
119386: PPUSH
119387: LD_INT 20
119389: PPUSH
119390: CALL 65474 0 2
// end ; end_of_file
119394: LD_VAR 0 3
119398: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119399: LD_VAR 0 1
119403: PUSH
119404: LD_INT 200
119406: DOUBLE
119407: GREATEREQUAL
119408: IFFALSE 119416
119410: LD_INT 299
119412: DOUBLE
119413: LESSEQUAL
119414: IFTRUE 119418
119416: GO 119450
119418: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119419: LD_VAR 0 1
119423: PPUSH
119424: LD_VAR 0 2
119428: PPUSH
119429: LD_VAR 0 3
119433: PPUSH
119434: LD_VAR 0 4
119438: PPUSH
119439: LD_VAR 0 5
119443: PPUSH
119444: CALL 108185 0 5
119448: GO 119527
119450: LD_INT 300
119452: DOUBLE
119453: GREATEREQUAL
119454: IFFALSE 119462
119456: LD_INT 399
119458: DOUBLE
119459: LESSEQUAL
119460: IFTRUE 119464
119462: GO 119526
119464: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119465: LD_VAR 0 1
119469: PPUSH
119470: LD_VAR 0 2
119474: PPUSH
119475: LD_VAR 0 3
119479: PPUSH
119480: LD_VAR 0 4
119484: PPUSH
119485: LD_VAR 0 5
119489: PPUSH
119490: LD_VAR 0 6
119494: PPUSH
119495: LD_VAR 0 7
119499: PPUSH
119500: LD_VAR 0 8
119504: PPUSH
119505: LD_VAR 0 9
119509: PPUSH
119510: LD_VAR 0 10
119514: PPUSH
119515: LD_VAR 0 11
119519: PPUSH
119520: CALL 104518 0 11
119524: GO 119527
119526: POP
// end ;
119527: PPOPN 11
119529: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119530: LD_VAR 0 1
119534: PPUSH
119535: LD_VAR 0 2
119539: PPUSH
119540: LD_VAR 0 3
119544: PPUSH
119545: LD_VAR 0 4
119549: PPUSH
119550: LD_VAR 0 5
119554: PPUSH
119555: CALL 107921 0 5
// end ; end_of_file
119559: PPOPN 5
119561: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119562: LD_VAR 0 1
119566: PPUSH
119567: LD_VAR 0 2
119571: PPUSH
119572: LD_VAR 0 3
119576: PPUSH
119577: LD_VAR 0 4
119581: PPUSH
119582: LD_VAR 0 5
119586: PPUSH
119587: LD_VAR 0 6
119591: PPUSH
119592: CALL 92170 0 6
// end ;
119596: PPOPN 6
119598: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119599: LD_INT 0
119601: PPUSH
// begin if not units then
119602: LD_VAR 0 1
119606: NOT
119607: IFFALSE 119611
// exit ;
119609: GO 119611
// end ;
119611: PPOPN 7
119613: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119614: CALL 92074 0 0
// end ;
119618: PPOPN 1
119620: END
