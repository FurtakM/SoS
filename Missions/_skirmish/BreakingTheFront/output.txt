// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 602 0 0
// SetDiplomacy ;
  42: CALL 814 0 0
// PrepareGame ;
  46: CALL 896 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := 0 ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 0 0$1 trigger game and GameType = 1 and not disableGlobalTimer do
 229: LD_EXP 3
 233: PUSH
 234: LD_EXP 2
 238: PUSH
 239: LD_INT 1
 241: EQUAL
 242: AND
 243: PUSH
 244: LD_EXP 4
 248: NOT
 249: AND
 250: IFFALSE 273
 252: GO 254
 254: DISABLE
// begin enable ;
 255: ENABLE
// display_strings := [ #SkrTime , tick ] ;
 256: LD_ADDR_OWVAR 47
 260: PUSH
 261: LD_STRING #SkrTime
 263: PUSH
 264: LD_OWVAR 1
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: ST_TO_ADDR
// end ;
 273: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 274: LD_EXP 19
 278: PUSH
 279: LD_EXP 3
 283: AND
 284: PUSH
 285: LD_EXP 2
 289: PUSH
 290: LD_INT 1
 292: EQUAL
 293: AND
 294: IFFALSE 355
 296: GO 298
 298: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 299: LD_EXP 19
 303: PUSH
 304: LD_INT 1
 306: ARRAY
 307: PUSH
 308: LD_INT 1
 310: ARRAY
 311: PPUSH
 312: LD_EXP 19
 316: PUSH
 317: LD_INT 1
 319: ARRAY
 320: PUSH
 321: LD_INT 2
 323: ARRAY
 324: PPUSH
 325: LD_EXP 19
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 3
 336: ARRAY
 337: PPUSH
 338: LD_EXP 19
 342: PUSH
 343: LD_INT 1
 345: ARRAY
 346: PUSH
 347: LD_INT 4
 349: ARRAY
 350: PPUSH
 351: CALL 56611 0 4
 355: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 356: LD_EXP 19
 360: PUSH
 361: LD_EXP 3
 365: AND
 366: PUSH
 367: LD_EXP 2
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: IFFALSE 437
 378: GO 380
 380: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 381: LD_EXP 19
 385: PUSH
 386: LD_INT 2
 388: ARRAY
 389: PUSH
 390: LD_INT 1
 392: ARRAY
 393: PPUSH
 394: LD_EXP 19
 398: PUSH
 399: LD_INT 2
 401: ARRAY
 402: PUSH
 403: LD_INT 2
 405: ARRAY
 406: PPUSH
 407: LD_EXP 19
 411: PUSH
 412: LD_INT 2
 414: ARRAY
 415: PUSH
 416: LD_INT 3
 418: ARRAY
 419: PPUSH
 420: LD_EXP 19
 424: PUSH
 425: LD_INT 2
 427: ARRAY
 428: PUSH
 429: LD_INT 4
 431: ARRAY
 432: PPUSH
 433: CALL 56611 0 4
 437: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 438: LD_EXP 19
 442: PUSH
 443: LD_EXP 3
 447: AND
 448: PUSH
 449: LD_EXP 2
 453: PUSH
 454: LD_INT 1
 456: EQUAL
 457: AND
 458: IFFALSE 519
 460: GO 462
 462: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 463: LD_EXP 19
 467: PUSH
 468: LD_INT 3
 470: ARRAY
 471: PUSH
 472: LD_INT 1
 474: ARRAY
 475: PPUSH
 476: LD_EXP 19
 480: PUSH
 481: LD_INT 3
 483: ARRAY
 484: PUSH
 485: LD_INT 2
 487: ARRAY
 488: PPUSH
 489: LD_EXP 19
 493: PUSH
 494: LD_INT 3
 496: ARRAY
 497: PUSH
 498: LD_INT 3
 500: ARRAY
 501: PPUSH
 502: LD_EXP 19
 506: PUSH
 507: LD_INT 3
 509: ARRAY
 510: PUSH
 511: LD_INT 4
 513: ARRAY
 514: PPUSH
 515: CALL 56611 0 4
 519: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 520: LD_EXP 19
 524: PUSH
 525: LD_EXP 3
 529: AND
 530: PUSH
 531: LD_EXP 2
 535: PUSH
 536: LD_INT 1
 538: EQUAL
 539: AND
 540: IFFALSE 601
 542: GO 544
 544: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 545: LD_EXP 19
 549: PUSH
 550: LD_INT 4
 552: ARRAY
 553: PUSH
 554: LD_INT 1
 556: ARRAY
 557: PPUSH
 558: LD_EXP 19
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PPUSH
 571: LD_EXP 19
 575: PUSH
 576: LD_INT 4
 578: ARRAY
 579: PUSH
 580: LD_INT 3
 582: ARRAY
 583: PPUSH
 584: LD_EXP 19
 588: PUSH
 589: LD_INT 4
 591: ARRAY
 592: PUSH
 593: LD_INT 4
 595: ARRAY
 596: PPUSH
 597: CALL 56611 0 4
 601: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 602: LD_INT 0
 604: PPUSH
 605: PPUSH
 606: PPUSH
 607: PPUSH
 608: PPUSH
// if GameType = 1 then
 609: LD_EXP 2
 613: PUSH
 614: LD_INT 1
 616: EQUAL
 617: IFFALSE 686
// begin ban_techs := [ ] ;
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// if sibBombAllowed < 2 then
 626: LD_EXP 23
 630: PUSH
 631: LD_INT 2
 633: LESS
 634: IFFALSE 647
// ban_techs := [ tech_sibFiss ] ;
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: LD_INT 25
 643: PUSH
 644: EMPTY
 645: LIST
 646: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_INT 46
 654: PUSH
 655: LD_INT 47
 657: PUSH
 658: LD_INT 48
 660: PUSH
 661: LD_INT 49
 663: PUSH
 664: LD_INT 50
 666: PUSH
 667: LD_INT 39
 669: PUSH
 670: LD_INT 69
 672: PUSH
 673: LD_INT 40
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: ST_TO_ADDR
// end ; for i = 1 to 8 do
 686: LD_ADDR_VAR 0 2
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_INT 8
 698: PUSH
 699: FOR_TO
 700: IFFALSE 784
// begin if res_techs then
 702: LD_VAR 0 5
 706: IFFALSE 742
// for j in res_techs do
 708: LD_ADDR_VAR 0 3
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: FOR_IN
 719: IFFALSE 740
// SetTech ( j , i , state_researched ) ;
 721: LD_VAR 0 3
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: LD_INT 2
 733: PPUSH
 734: CALL_OW 322
 738: GO 718
 740: POP
 741: POP
// if ban_techs then
 742: LD_VAR 0 4
 746: IFFALSE 782
// for j in ban_techs do
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_VAR 0 4
 757: PUSH
 758: FOR_IN
 759: IFFALSE 780
// SetTech ( j , i , state_disabled ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 322
 778: GO 758
 780: POP
 781: POP
// end ;
 782: GO 699
 784: POP
 785: POP
// if sibBombAllowed = 1 then
 786: LD_EXP 23
 790: PUSH
 791: LD_INT 1
 793: EQUAL
 794: IFFALSE 809
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 796: LD_INT 25
 798: PPUSH
 799: LD_INT 3
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 322
// end ;
 809: LD_VAR 0 1
 813: RET
// export function SetDiplomacy ; begin
 814: LD_INT 0
 816: PPUSH
// if GameType = 1 then
 817: LD_EXP 2
 821: PUSH
 822: LD_INT 1
 824: EQUAL
 825: IFFALSE 891
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 827: LD_INT 1
 829: PPUSH
 830: LD_INT 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 843: LD_INT 3
 845: PPUSH
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 8
 864: PPUSH
 865: LD_INT 1
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 875: LD_INT 6
 877: PPUSH
 878: LD_INT 8
 880: PPUSH
 881: LD_INT 1
 883: PPUSH
 884: LD_INT 1
 886: PPUSH
 887: CALL_OW 80
// end ; end ;
 891: LD_VAR 0 1
 895: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 896: LD_INT 0
 898: PPUSH
 899: PPUSH
 900: PPUSH
 901: PPUSH
// if GameType = 1 then
 902: LD_EXP 2
 906: PUSH
 907: LD_INT 1
 909: EQUAL
 910: IFFALSE 1406
// begin game := false ;
 912: LD_ADDR_EXP 3
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// your_side := 1 ;
 920: LD_ADDR_OWVAR 2
 924: PUSH
 925: LD_INT 1
 927: ST_TO_ADDR
// mc_amer := 1 ;
 928: LD_ADDR_EXP 5
 932: PUSH
 933: LD_INT 1
 935: ST_TO_ADDR
// mc_leg := 2 ;
 936: LD_ADDR_EXP 6
 940: PUSH
 941: LD_INT 2
 943: ST_TO_ADDR
// mc_rus_1 := 3 ;
 944: LD_ADDR_EXP 7
 948: PUSH
 949: LD_INT 3
 951: ST_TO_ADDR
// mc_rus_2 := 4 ;
 952: LD_ADDR_EXP 8
 956: PUSH
 957: LD_INT 4
 959: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 960: LD_ADDR_EXP 19
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: LD_INT 200
 976: PUSH
 977: LD_INT 250
 979: PUSH
 980: LD_INT 300
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_EXP 26
 992: ARRAY
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 13
1002: PUSH
1003: LD_INT 8
1005: PUSH
1006: LD_INT 50
1008: PUSH
1009: LD_INT 500
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 17
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 50
1026: PUSH
1027: LD_INT 300
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 18
1038: PUSH
1039: LD_INT 4
1041: PUSH
1042: LD_INT 5
1044: PUSH
1045: LD_INT 6
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_EXP 26
1057: ARRAY
1058: PUSH
1059: LD_INT 30
1061: PUSH
1062: LD_INT 300
1064: PUSH
1065: LD_INT 450
1067: PUSH
1068: LD_INT 500
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_EXP 26
1080: ARRAY
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: LD_INT 190
1101: PUSH
1102: LD_INT 193
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 182
1115: PUSH
1116: LD_INT 117
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 114
1143: PUSH
1144: LD_INT 152
1146: PUSH
1147: LD_INT 2
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 85
1157: PUSH
1158: LD_INT 38
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i in sources do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: PUSH
1186: FOR_IN
1187: IFFALSE 1222
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1189: LD_VAR 0 2
1193: PUSH
1194: LD_INT 1
1196: ARRAY
1197: PPUSH
1198: LD_VAR 0 2
1202: PUSH
1203: LD_INT 2
1205: ARRAY
1206: PPUSH
1207: LD_VAR 0 2
1211: PUSH
1212: LD_INT 3
1214: ARRAY
1215: PPUSH
1216: CALL_OW 62
1220: GO 1186
1222: POP
1223: POP
// disableGlobalTimer := false ;
1224: LD_ADDR_EXP 4
1228: PUSH
1229: LD_INT 0
1231: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1232: LD_ADDR_EXP 15
1236: PUSH
1237: LD_INT 0
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_OWVAR 67
1258: ARRAY
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: ST_TO_ADDR
// ruOutpost := [ ] ;
1264: LD_ADDR_EXP 14
1268: PUSH
1269: EMPTY
1270: ST_TO_ADDR
// staticMines := [ ] ;
1271: LD_ADDR_EXP 16
1275: PUSH
1276: EMPTY
1277: ST_TO_ADDR
// baseCaptured := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// legDestCounter := 0 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 0
1293: ST_TO_ADDR
// legOfferAccepted := false ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_INT 0
1301: ST_TO_ADDR
// legChangeSide := false ;
1302: LD_ADDR_EXP 21
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// allyDestCounter := 0 ;
1310: LD_ADDR_EXP 22
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// outpostEscape := false ;
1318: LD_ADDR_EXP 27
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// dialogueMineDetected := false ;
1326: LD_ADDR_EXP 28
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// PrepareAmericans ;
1334: CALL 7606 0 0
// PrepareLegion ;
1338: CALL 5540 0 0
// PrepareRussians ;
1342: CALL 2506 0 0
// playerForces := PreparePlayer ;
1346: LD_ADDR_EXP 10
1350: PUSH
1351: CALL 8849 0 0
1355: ST_TO_ADDR
// AnimateTrees ( true ) ;
1356: LD_INT 1
1358: PPUSH
1359: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1363: LD_INT 4
1365: PPUSH
1366: LD_INT 3
1368: PPUSH
1369: LD_INT 8
1371: PPUSH
1372: LD_INT 5
1374: PPUSH
1375: LD_INT 3
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 8
1383: PPUSH
1384: LD_INT 2
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: CALL 53969 0 9
// MC_Start ;
1394: CALL 63427 0 0
// SetAdditionalRussianForces ;
1398: CALL 7275 0 0
// Action ;
1402: CALL 11206 0 0
// end ; end ;
1406: LD_VAR 0 1
1410: RET
// export function CustomInitMacro ; begin
1411: LD_INT 0
1413: PPUSH
// if GameType <> 1 then
1414: LD_EXP 2
1418: PUSH
1419: LD_INT 1
1421: NONEQUAL
1422: IFFALSE 1426
// exit ;
1424: GO 2501
// MC_SetScanArea ( mc_amer , amerBase ) ;
1426: LD_EXP 5
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: CALL 86755 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1438: LD_EXP 5
1442: PPUSH
1443: LD_INT 4
1445: PPUSH
1446: CALL 86699 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1450: LD_EXP 5
1454: PPUSH
1455: LD_INT 11
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 7
1463: PUSH
1464: LD_INT 9
1466: PUSH
1467: LD_INT 10
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: PPUSH
1477: CALL 86587 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1481: LD_EXP 5
1485: PPUSH
1486: LD_INT 5
1488: PPUSH
1489: CALL 86269 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1493: LD_EXP 5
1497: PPUSH
1498: LD_INT 3
1500: PPUSH
1501: CALL 86000 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1505: LD_EXP 5
1509: PPUSH
1510: LD_INT 4
1512: PPUSH
1513: CALL 85619 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1517: LD_EXP 5
1521: PPUSH
1522: LD_INT 3
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 2
1530: PUSH
1531: LD_INT 5
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: LD_INT 9
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 4
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: LD_INT 2
1566: PUSH
1567: LD_INT 7
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: PUSH
1576: LD_INT 4
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: LD_INT 2
1584: PUSH
1585: LD_INT 6
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL 85434 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1604: LD_EXP 5
1608: PPUSH
1609: LD_INT 33
1611: PUSH
1612: LD_INT 114
1614: PUSH
1615: LD_INT 16
1617: PUSH
1618: LD_INT 0
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 110
1632: PUSH
1633: LD_INT 12
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL 85326 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1653: LD_EXP 5
1657: PPUSH
1658: LD_INT 10
1660: PUSH
1661: LD_INT 15
1663: PUSH
1664: LD_INT 12
1666: PUSH
1667: LD_INT 11
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL 86176 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1680: LD_EXP 6
1684: PPUSH
1685: LD_INT 6
1687: PPUSH
1688: CALL 86755 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1692: LD_EXP 6
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL 86699 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1704: LD_EXP 6
1708: PPUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 27
1714: PUSH
1715: LD_INT 28
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL 86587 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1731: LD_EXP 6
1735: PPUSH
1736: LD_INT 17
1738: PPUSH
1739: CALL 86269 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1743: LD_EXP 6
1747: PPUSH
1748: LD_INT 6
1750: PPUSH
1751: CALL 86000 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1755: LD_EXP 6
1759: PPUSH
1760: LD_INT 5
1762: PPUSH
1763: CALL 85619 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1767: LD_EXP 6
1771: PPUSH
1772: LD_INT 10
1774: PPUSH
1775: LD_INT 9
1777: PPUSH
1778: CALL 85116 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1782: LD_EXP 6
1786: PPUSH
1787: LD_INT 4
1789: PUSH
1790: LD_INT 157
1792: PUSH
1793: LD_INT 144
1795: PUSH
1796: LD_INT 0
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 32
1807: PUSH
1808: LD_INT 151
1810: PUSH
1811: LD_INT 142
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 32
1825: PUSH
1826: LD_INT 161
1828: PUSH
1829: LD_INT 144
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 32
1843: PUSH
1844: LD_INT 140
1846: PUSH
1847: LD_INT 133
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL 85326 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1869: LD_EXP 6
1873: PPUSH
1874: LD_INT 13
1876: PUSH
1877: LD_INT 2
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 31
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 13
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 31
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 13
1912: PUSH
1913: LD_INT 1
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 27
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: LD_INT 13
1930: PUSH
1931: LD_INT 1
1933: PUSH
1934: LD_INT 2
1936: PUSH
1937: LD_INT 27
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: PUSH
1946: LD_INT 13
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 27
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 13
1966: PUSH
1967: LD_INT 1
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 28
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 13
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 28
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 13
2002: PUSH
2003: LD_INT 1
2005: PUSH
2006: LD_INT 2
2008: PUSH
2009: LD_INT 32
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_INT 13
2020: PUSH
2021: LD_INT 1
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_EXP 35
2031: PUSH
2032: EMPTY
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: PPUSH
2049: CALL 85434 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2053: LD_INT 165
2055: PPUSH
2056: LD_INT 156
2058: PPUSH
2059: LD_INT 8
2061: PPUSH
2062: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2066: LD_EXP 7
2070: PPUSH
2071: LD_INT 15
2073: PPUSH
2074: CALL 86755 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2078: LD_EXP 7
2082: PPUSH
2083: LD_INT 16
2085: PPUSH
2086: CALL 86699 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2090: LD_EXP 7
2094: PPUSH
2095: LD_INT 43
2097: PUSH
2098: LD_INT 47
2100: PUSH
2101: LD_INT 45
2103: PUSH
2104: LD_INT 49
2106: PUSH
2107: LD_INT 46
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: PPUSH
2117: CALL 86587 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2121: LD_EXP 7
2125: PPUSH
2126: LD_INT 13
2128: PPUSH
2129: CALL 86269 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2133: LD_EXP 7
2137: PPUSH
2138: LD_INT 15
2140: PPUSH
2141: CALL 86000 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2145: LD_EXP 7
2149: PPUSH
2150: LD_INT 5
2152: PPUSH
2153: CALL 85619 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2157: LD_EXP 7
2161: PPUSH
2162: LD_INT 23
2164: PUSH
2165: LD_INT 1
2167: PUSH
2168: LD_INT 3
2170: PUSH
2171: LD_INT 46
2173: PUSH
2174: EMPTY
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: PUSH
2180: LD_INT 23
2182: PUSH
2183: LD_INT 1
2185: PUSH
2186: LD_INT 1
2188: PUSH
2189: LD_INT 46
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: PUSH
2198: LD_INT 23
2200: PUSH
2201: LD_INT 1
2203: PUSH
2204: LD_INT 3
2206: PUSH
2207: LD_INT 45
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: LIST
2214: LIST
2215: PUSH
2216: LD_INT 23
2218: PUSH
2219: LD_INT 1
2221: PUSH
2222: LD_INT 1
2224: PUSH
2225: LD_INT 47
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 23
2236: PUSH
2237: LD_INT 1
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: LD_INT 46
2245: PUSH
2246: EMPTY
2247: LIST
2248: LIST
2249: LIST
2250: LIST
2251: PUSH
2252: LD_INT 21
2254: PUSH
2255: LD_INT 1
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 51
2263: PUSH
2264: EMPTY
2265: LIST
2266: LIST
2267: LIST
2268: LIST
2269: PUSH
2270: LD_INT 21
2272: PUSH
2273: LD_INT 1
2275: PUSH
2276: LD_INT 3
2278: PUSH
2279: LD_INT 52
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: LIST
2295: LIST
2296: PPUSH
2297: CALL 85434 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2301: LD_EXP 8
2305: PPUSH
2306: LD_INT 11
2308: PPUSH
2309: CALL 86755 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2313: LD_EXP 8
2317: PPUSH
2318: LD_INT 12
2320: PPUSH
2321: CALL 86699 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2325: LD_EXP 8
2329: PPUSH
2330: LD_INT 43
2332: PUSH
2333: LD_INT 47
2335: PUSH
2336: LD_INT 45
2338: PUSH
2339: LD_INT 49
2341: PUSH
2342: LD_INT 46
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: LIST
2349: LIST
2350: LIST
2351: PPUSH
2352: CALL 86587 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2356: LD_EXP 8
2360: PPUSH
2361: LD_INT 13
2363: PPUSH
2364: CALL 86269 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2368: LD_EXP 8
2372: PPUSH
2373: LD_INT 11
2375: PPUSH
2376: CALL 86000 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2380: LD_EXP 8
2384: PPUSH
2385: LD_INT 4
2387: PPUSH
2388: CALL 85619 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2392: LD_EXP 8
2396: PPUSH
2397: LD_INT 115
2399: PUSH
2400: LD_INT 201
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PUSH
2407: EMPTY
2408: LIST
2409: PPUSH
2410: CALL 86325 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2414: LD_EXP 8
2418: PPUSH
2419: LD_INT 24
2421: PUSH
2422: LD_INT 3
2424: PUSH
2425: LD_INT 3
2427: PUSH
2428: LD_INT 46
2430: PUSH
2431: EMPTY
2432: LIST
2433: LIST
2434: LIST
2435: LIST
2436: PUSH
2437: LD_INT 24
2439: PUSH
2440: LD_INT 3
2442: PUSH
2443: LD_INT 3
2445: PUSH
2446: LD_INT 46
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: LIST
2453: LIST
2454: PUSH
2455: LD_INT 24
2457: PUSH
2458: LD_INT 3
2460: PUSH
2461: LD_INT 3
2463: PUSH
2464: LD_INT 46
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: LIST
2471: LIST
2472: PUSH
2473: LD_INT 24
2475: PUSH
2476: LD_INT 3
2478: PUSH
2479: LD_INT 3
2481: PUSH
2482: LD_INT 46
2484: PUSH
2485: EMPTY
2486: LIST
2487: LIST
2488: LIST
2489: LIST
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: LIST
2495: LIST
2496: PPUSH
2497: CALL 85434 0 2
// end ;
2501: LD_VAR 0 1
2505: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2506: LD_INT 0
2508: PPUSH
2509: PPUSH
2510: PPUSH
2511: PPUSH
2512: PPUSH
2513: PPUSH
2514: PPUSH
2515: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2516: LD_INT 0
2518: PPUSH
2519: LD_INT 0
2521: PPUSH
2522: LD_INT 3
2524: PPUSH
2525: LD_INT 0
2527: PPUSH
2528: LD_INT 0
2530: PPUSH
2531: LD_INT 0
2533: PPUSH
2534: LD_INT 0
2536: PPUSH
2537: LD_INT 14
2539: PPUSH
2540: LD_INT 0
2542: PPUSH
2543: CALL 53969 0 9
// side := 3 ;
2547: LD_ADDR_VAR 0 5
2551: PUSH
2552: LD_INT 3
2554: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2555: LD_INT 38
2557: PPUSH
2558: LD_VAR 0 5
2562: PPUSH
2563: LD_INT 2
2565: PPUSH
2566: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2570: LD_INT 39
2572: PPUSH
2573: LD_VAR 0 5
2577: PPUSH
2578: LD_INT 2
2580: PPUSH
2581: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2585: LD_INT 34
2587: PPUSH
2588: LD_VAR 0 5
2592: PPUSH
2593: LD_INT 2
2595: PPUSH
2596: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2600: LD_ADDR_VAR 0 4
2604: PUSH
2605: LD_INT 0
2607: PUSH
2608: LD_INT 208
2610: PUSH
2611: LD_INT 163
2613: PUSH
2614: LD_INT 4
2616: PUSH
2617: LD_INT 0
2619: PUSH
2620: LD_INT 0
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 3
2633: PUSH
2634: LD_INT 194
2636: PUSH
2637: LD_INT 161
2639: PUSH
2640: LD_INT 1
2642: PUSH
2643: LD_INT 0
2645: PUSH
2646: LD_INT 0
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 17
2659: PUSH
2660: LD_INT 190
2662: PUSH
2663: LD_INT 161
2665: PUSH
2666: LD_INT 1
2668: PUSH
2669: LD_INT 0
2671: PUSH
2672: LD_INT 0
2674: PUSH
2675: EMPTY
2676: LIST
2677: LIST
2678: LIST
2679: LIST
2680: LIST
2681: LIST
2682: PUSH
2683: LD_INT 5
2685: PUSH
2686: LD_INT 200
2688: PUSH
2689: LD_INT 145
2691: PUSH
2692: LD_INT 3
2694: PUSH
2695: LD_INT 0
2697: PUSH
2698: LD_INT 0
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: LIST
2708: PUSH
2709: LD_INT 32
2711: PUSH
2712: LD_INT 192
2714: PUSH
2715: LD_INT 144
2717: PUSH
2718: LD_INT 3
2720: PUSH
2721: LD_INT 0
2723: PUSH
2724: LD_INT 0
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: LIST
2733: LIST
2734: PUSH
2735: LD_INT 26
2737: PUSH
2738: LD_INT 216
2740: PUSH
2741: LD_INT 172
2743: PUSH
2744: LD_INT 3
2746: PUSH
2747: LD_INT 0
2749: PUSH
2750: LD_INT 0
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: LIST
2757: LIST
2758: LIST
2759: LIST
2760: PUSH
2761: LD_INT 26
2763: PUSH
2764: LD_INT 218
2766: PUSH
2767: LD_INT 176
2769: PUSH
2770: LD_INT 3
2772: PUSH
2773: LD_INT 0
2775: PUSH
2776: LD_INT 0
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: LIST
2786: PUSH
2787: LD_INT 29
2789: PUSH
2790: LD_INT 182
2792: PUSH
2793: LD_INT 149
2795: PUSH
2796: LD_INT 3
2798: PUSH
2799: LD_INT 0
2801: PUSH
2802: LD_INT 0
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: LIST
2811: LIST
2812: PUSH
2813: LD_INT 8
2815: PUSH
2816: LD_INT 201
2818: PUSH
2819: LD_INT 171
2821: PUSH
2822: LD_INT 0
2824: PUSH
2825: LD_INT 10
2827: PUSH
2828: LD_INT 11
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: LIST
2837: LIST
2838: PUSH
2839: LD_INT 32
2841: PUSH
2842: LD_INT 188
2844: PUSH
2845: LD_INT 167
2847: PUSH
2848: LD_INT 0
2850: PUSH
2851: LD_INT 0
2853: PUSH
2854: LD_INT 0
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: LIST
2863: LIST
2864: PUSH
2865: LD_INT 32
2867: PUSH
2868: LD_INT 202
2870: PUSH
2871: LD_INT 179
2873: PUSH
2874: LD_INT 0
2876: PUSH
2877: LD_INT 0
2879: PUSH
2880: LD_INT 0
2882: PUSH
2883: EMPTY
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: LIST
2889: LIST
2890: PUSH
2891: LD_INT 32
2893: PUSH
2894: LD_INT 209
2896: PUSH
2897: LD_INT 182
2899: PUSH
2900: LD_INT 0
2902: PUSH
2903: LD_INT 0
2905: PUSH
2906: LD_INT 0
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: LIST
2915: LIST
2916: PUSH
2917: LD_INT 32
2919: PUSH
2920: LD_INT 220
2922: PUSH
2923: LD_INT 183
2925: PUSH
2926: LD_INT 5
2928: PUSH
2929: LD_INT 0
2931: PUSH
2932: LD_INT 0
2934: PUSH
2935: EMPTY
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: LIST
2942: PUSH
2943: LD_INT 32
2945: PUSH
2946: LD_INT 225
2948: PUSH
2949: LD_INT 181
2951: PUSH
2952: LD_INT 5
2954: PUSH
2955: LD_INT 0
2957: PUSH
2958: LD_INT 0
2960: PUSH
2961: EMPTY
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: LIST
2967: LIST
2968: PUSH
2969: LD_INT 26
2971: PUSH
2972: LD_INT 220
2974: PUSH
2975: LD_INT 174
2977: PUSH
2978: LD_INT 5
2980: PUSH
2981: LD_INT 0
2983: PUSH
2984: LD_INT 0
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: PUSH
2995: LD_INT 1
2997: PUSH
2998: LD_INT 84
3000: PUSH
3001: LD_INT 128
3003: PUSH
3004: LD_INT 4
3006: PUSH
3007: LD_INT 0
3009: PUSH
3010: LD_INT 0
3012: PUSH
3013: EMPTY
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: LIST
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 68
3026: PUSH
3027: LD_INT 121
3029: PUSH
3030: LD_INT 1
3032: PUSH
3033: LD_INT 0
3035: PUSH
3036: LD_INT 0
3038: PUSH
3039: EMPTY
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PUSH
3047: LD_INT 19
3049: PUSH
3050: LD_INT 72
3052: PUSH
3053: LD_INT 125
3055: PUSH
3056: LD_INT 5
3058: PUSH
3059: LD_INT 0
3061: PUSH
3062: LD_INT 0
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PUSH
3073: LD_INT 18
3075: PUSH
3076: LD_INT 68
3078: PUSH
3079: LD_INT 124
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: LD_INT 0
3087: PUSH
3088: LD_INT 0
3090: PUSH
3091: EMPTY
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_INT 24
3101: PUSH
3102: LD_INT 64
3104: PUSH
3105: LD_INT 121
3107: PUSH
3108: LD_INT 1
3110: PUSH
3111: LD_INT 0
3113: PUSH
3114: LD_INT 0
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: PUSH
3125: LD_INT 17
3127: PUSH
3128: LD_INT 65
3130: PUSH
3131: LD_INT 118
3133: PUSH
3134: LD_INT 2
3136: PUSH
3137: LD_INT 0
3139: PUSH
3140: LD_INT 0
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_INT 21
3153: PUSH
3154: LD_INT 68
3156: PUSH
3157: LD_INT 117
3159: PUSH
3160: LD_INT 3
3162: PUSH
3163: LD_INT 0
3165: PUSH
3166: LD_INT 0
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 8
3179: PUSH
3180: LD_INT 68
3182: PUSH
3183: LD_INT 130
3185: PUSH
3186: LD_INT 1
3188: PUSH
3189: LD_INT 14
3191: PUSH
3192: LD_INT 10
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: PUSH
3203: LD_INT 8
3205: PUSH
3206: LD_INT 67
3208: PUSH
3209: LD_INT 110
3211: PUSH
3212: LD_INT 2
3214: PUSH
3215: LD_INT 11
3217: PUSH
3218: LD_INT 12
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: PUSH
3229: LD_INT 28
3231: PUSH
3232: LD_INT 85
3234: PUSH
3235: LD_INT 108
3237: PUSH
3238: LD_INT 2
3240: PUSH
3241: LD_INT 0
3243: PUSH
3244: LD_INT 0
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: LIST
3253: LIST
3254: PUSH
3255: LD_INT 28
3257: PUSH
3258: LD_INT 85
3260: PUSH
3261: LD_INT 124
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 0
3269: PUSH
3270: LD_INT 0
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: LIST
3279: LIST
3280: PUSH
3281: LD_INT 30
3283: PUSH
3284: LD_INT 97
3286: PUSH
3287: LD_INT 119
3289: PUSH
3290: LD_INT 2
3292: PUSH
3293: LD_INT 0
3295: PUSH
3296: LD_INT 0
3298: PUSH
3299: EMPTY
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 5
3309: PUSH
3310: LD_INT 111
3312: PUSH
3313: LD_INT 138
3315: PUSH
3316: LD_INT 4
3318: PUSH
3319: LD_INT 0
3321: PUSH
3322: LD_INT 0
3324: PUSH
3325: EMPTY
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 33
3335: PUSH
3336: LD_INT 104
3338: PUSH
3339: LD_INT 130
3341: PUSH
3342: LD_INT 3
3344: PUSH
3345: LD_INT 0
3347: PUSH
3348: LD_INT 0
3350: PUSH
3351: EMPTY
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: LIST
3357: LIST
3358: PUSH
3359: LD_INT 33
3361: PUSH
3362: LD_INT 110
3364: PUSH
3365: LD_INT 142
3367: PUSH
3368: LD_INT 5
3370: PUSH
3371: LD_INT 0
3373: PUSH
3374: LD_INT 0
3376: PUSH
3377: EMPTY
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: LIST
3383: LIST
3384: PUSH
3385: LD_INT 33
3387: PUSH
3388: LD_INT 91
3390: PUSH
3391: LD_INT 131
3393: PUSH
3394: LD_INT 5
3396: PUSH
3397: LD_INT 0
3399: PUSH
3400: LD_INT 0
3402: PUSH
3403: EMPTY
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: LIST
3409: LIST
3410: PUSH
3411: LD_INT 33
3413: PUSH
3414: LD_INT 107
3416: PUSH
3417: LD_INT 157
3419: PUSH
3420: LD_INT 5
3422: PUSH
3423: LD_INT 0
3425: PUSH
3426: LD_INT 0
3428: PUSH
3429: EMPTY
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: PUSH
3437: LD_INT 33
3439: PUSH
3440: LD_INT 104
3442: PUSH
3443: LD_INT 160
3445: PUSH
3446: LD_INT 5
3448: PUSH
3449: LD_INT 0
3451: PUSH
3452: LD_INT 0
3454: PUSH
3455: EMPTY
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: LIST
3461: LIST
3462: PUSH
3463: LD_INT 33
3465: PUSH
3466: LD_INT 101
3468: PUSH
3469: LD_INT 162
3471: PUSH
3472: LD_INT 5
3474: PUSH
3475: LD_INT 0
3477: PUSH
3478: LD_INT 0
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: LIST
3488: PUSH
3489: LD_INT 32
3491: PUSH
3492: LD_INT 87
3494: PUSH
3495: LD_INT 157
3497: PUSH
3498: LD_INT 5
3500: PUSH
3501: LD_INT 0
3503: PUSH
3504: LD_INT 0
3506: PUSH
3507: EMPTY
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: LIST
3513: LIST
3514: PUSH
3515: LD_INT 32
3517: PUSH
3518: LD_INT 105
3520: PUSH
3521: LD_INT 158
3523: PUSH
3524: LD_INT 5
3526: PUSH
3527: LD_INT 0
3529: PUSH
3530: LD_INT 0
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: LD_INT 33
3543: PUSH
3544: LD_INT 91
3546: PUSH
3547: LD_INT 118
3549: PUSH
3550: LD_INT 4
3552: PUSH
3553: LD_INT 0
3555: PUSH
3556: LD_INT 0
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: LIST
3565: LIST
3566: PUSH
3567: LD_INT 33
3569: PUSH
3570: LD_INT 89
3572: PUSH
3573: LD_INT 107
3575: PUSH
3576: LD_INT 4
3578: PUSH
3579: LD_INT 0
3581: PUSH
3582: LD_INT 0
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: LIST
3592: PUSH
3593: LD_INT 5
3595: PUSH
3596: LD_INT 86
3598: PUSH
3599: LD_INT 96
3601: PUSH
3602: LD_INT 3
3604: PUSH
3605: LD_INT 0
3607: PUSH
3608: LD_INT 0
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: LIST
3617: LIST
3618: PUSH
3619: LD_INT 33
3621: PUSH
3622: LD_INT 91
3624: PUSH
3625: LD_INT 102
3627: PUSH
3628: LD_INT 4
3630: PUSH
3631: LD_INT 0
3633: PUSH
3634: LD_INT 0
3636: PUSH
3637: EMPTY
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: LIST
3643: LIST
3644: PUSH
3645: LD_INT 32
3647: PUSH
3648: LD_INT 80
3650: PUSH
3651: LD_INT 95
3653: PUSH
3654: LD_INT 3
3656: PUSH
3657: LD_INT 0
3659: PUSH
3660: LD_INT 0
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: LIST
3669: LIST
3670: PUSH
3671: LD_INT 28
3673: PUSH
3674: LD_INT 77
3676: PUSH
3677: LD_INT 105
3679: PUSH
3680: LD_INT 3
3682: PUSH
3683: LD_INT 0
3685: PUSH
3686: LD_INT 0
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: LIST
3693: LIST
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 28
3699: PUSH
3700: LD_INT 85
3702: PUSH
3703: LD_INT 113
3705: PUSH
3706: LD_INT 3
3708: PUSH
3709: LD_INT 0
3711: PUSH
3712: LD_INT 0
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: LIST
3721: LIST
3722: PUSH
3723: LD_INT 28
3725: PUSH
3726: LD_INT 55
3728: PUSH
3729: LD_INT 97
3731: PUSH
3732: LD_INT 3
3734: PUSH
3735: LD_INT 0
3737: PUSH
3738: LD_INT 0
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: LIST
3747: LIST
3748: PUSH
3749: LD_INT 28
3751: PUSH
3752: LD_INT 88
3754: PUSH
3755: LD_INT 128
3757: PUSH
3758: LD_INT 3
3760: PUSH
3761: LD_INT 0
3763: PUSH
3764: LD_INT 0
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: LIST
3773: LIST
3774: PUSH
3775: LD_INT 32
3777: PUSH
3778: LD_INT 69
3780: PUSH
3781: LD_INT 101
3783: PUSH
3784: LD_INT 2
3786: PUSH
3787: LD_INT 0
3789: PUSH
3790: LD_INT 0
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 1
3803: PUSH
3804: LD_INT 34
3806: PUSH
3807: LD_INT 23
3809: PUSH
3810: LD_INT 4
3812: PUSH
3813: LD_INT 0
3815: PUSH
3816: LD_INT 0
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 8
3829: PUSH
3830: LD_INT 25
3832: PUSH
3833: LD_INT 4
3835: PUSH
3836: LD_INT 3
3838: PUSH
3839: LD_INT 11
3841: PUSH
3842: LD_INT 10
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: LIST
3851: LIST
3852: PUSH
3853: LD_INT 8
3855: PUSH
3856: LD_INT 15
3858: PUSH
3859: LD_INT 4
3861: PUSH
3862: LD_INT 2
3864: PUSH
3865: LD_INT 14
3867: PUSH
3868: LD_INT 12
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: PUSH
3879: LD_INT 29
3881: PUSH
3882: LD_INT 55
3884: PUSH
3885: LD_INT 35
3887: PUSH
3888: LD_INT 2
3890: PUSH
3891: LD_INT 0
3893: PUSH
3894: LD_INT 0
3896: PUSH
3897: EMPTY
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: LIST
3903: LIST
3904: PUSH
3905: LD_INT 29
3907: PUSH
3908: LD_INT 24
3910: PUSH
3911: LD_INT 44
3913: PUSH
3914: LD_INT 2
3916: PUSH
3917: LD_INT 0
3919: PUSH
3920: LD_INT 0
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: PUSH
3931: LD_INT 34
3933: PUSH
3934: LD_INT 34
3936: PUSH
3937: LD_INT 32
3939: PUSH
3940: LD_INT 4
3942: PUSH
3943: LD_INT 0
3945: PUSH
3946: LD_INT 0
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: LIST
3955: LIST
3956: PUSH
3957: LD_INT 3
3959: PUSH
3960: LD_INT 14
3962: PUSH
3963: LD_INT 16
3965: PUSH
3966: LD_INT 1
3968: PUSH
3969: LD_INT 0
3971: PUSH
3972: LD_INT 0
3974: PUSH
3975: EMPTY
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: LIST
3981: LIST
3982: PUSH
3983: LD_INT 24
3985: PUSH
3986: LD_INT 10
3988: PUSH
3989: LD_INT 16
3991: PUSH
3992: LD_INT 1
3994: PUSH
3995: LD_INT 0
3997: PUSH
3998: LD_INT 0
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: LIST
4007: LIST
4008: PUSH
4009: LD_INT 21
4011: PUSH
4012: LD_INT 11
4014: PUSH
4015: LD_INT 13
4017: PUSH
4018: LD_INT 2
4020: PUSH
4021: LD_INT 0
4023: PUSH
4024: LD_INT 0
4026: PUSH
4027: EMPTY
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_INT 18
4037: PUSH
4038: LD_INT 14
4040: PUSH
4041: LD_INT 12
4043: PUSH
4044: LD_INT 3
4046: PUSH
4047: LD_INT 0
4049: PUSH
4050: LD_INT 0
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: LIST
4059: LIST
4060: PUSH
4061: LD_INT 16
4063: PUSH
4064: LD_INT 14
4066: PUSH
4067: LD_INT 19
4069: PUSH
4070: LD_INT 0
4072: PUSH
4073: LD_INT 0
4075: PUSH
4076: LD_INT 0
4078: PUSH
4079: EMPTY
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: LIST
4085: LIST
4086: PUSH
4087: LD_INT 17
4089: PUSH
4090: LD_INT 18
4092: PUSH
4093: LD_INT 20
4095: PUSH
4096: LD_INT 5
4098: PUSH
4099: LD_INT 0
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_INT 28
4115: PUSH
4116: LD_INT 10
4118: PUSH
4119: LD_INT 5
4121: PUSH
4122: LD_INT 1
4124: PUSH
4125: LD_INT 0
4127: PUSH
4128: LD_INT 0
4130: PUSH
4131: EMPTY
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: LIST
4137: LIST
4138: PUSH
4139: LD_INT 28
4141: PUSH
4142: LD_INT 8
4144: PUSH
4145: LD_INT 8
4147: PUSH
4148: LD_INT 1
4150: PUSH
4151: LD_INT 0
4153: PUSH
4154: LD_INT 0
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: LIST
4163: LIST
4164: PUSH
4165: LD_INT 26
4167: PUSH
4168: LD_INT 19
4170: PUSH
4171: LD_INT 2
4173: PUSH
4174: LD_INT 1
4176: PUSH
4177: LD_INT 0
4179: PUSH
4180: LD_INT 0
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 26
4193: PUSH
4194: LD_INT 30
4196: PUSH
4197: LD_INT 2
4199: PUSH
4200: LD_INT 1
4202: PUSH
4203: LD_INT 0
4205: PUSH
4206: LD_INT 0
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: LIST
4215: LIST
4216: PUSH
4217: LD_INT 5
4219: PUSH
4220: LD_INT 59
4222: PUSH
4223: LD_INT 20
4225: PUSH
4226: LD_INT 4
4228: PUSH
4229: LD_INT 0
4231: PUSH
4232: LD_INT 0
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: LIST
4241: LIST
4242: PUSH
4243: LD_INT 32
4245: PUSH
4246: LD_INT 60
4248: PUSH
4249: LD_INT 24
4251: PUSH
4252: LD_INT 4
4254: PUSH
4255: LD_INT 0
4257: PUSH
4258: LD_INT 0
4260: PUSH
4261: EMPTY
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: PUSH
4269: LD_INT 32
4271: PUSH
4272: LD_INT 61
4274: PUSH
4275: LD_INT 45
4277: PUSH
4278: LD_INT 5
4280: PUSH
4281: LD_INT 0
4283: PUSH
4284: LD_INT 0
4286: PUSH
4287: EMPTY
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: LIST
4294: PUSH
4295: LD_INT 32
4297: PUSH
4298: LD_INT 52
4300: PUSH
4301: LD_INT 51
4303: PUSH
4304: LD_INT 5
4306: PUSH
4307: LD_INT 0
4309: PUSH
4310: LD_INT 0
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: LIST
4319: LIST
4320: PUSH
4321: LD_INT 33
4323: PUSH
4324: LD_INT 56
4326: PUSH
4327: LD_INT 51
4329: PUSH
4330: LD_INT 5
4332: PUSH
4333: LD_INT 0
4335: PUSH
4336: LD_INT 0
4338: PUSH
4339: EMPTY
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 33
4349: PUSH
4350: LD_INT 62
4352: PUSH
4353: LD_INT 49
4355: PUSH
4356: LD_INT 5
4358: PUSH
4359: LD_INT 0
4361: PUSH
4362: LD_INT 0
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: LIST
4371: LIST
4372: PUSH
4373: LD_INT 33
4375: PUSH
4376: LD_INT 41
4378: PUSH
4379: LD_INT 47
4381: PUSH
4382: LD_INT 5
4384: PUSH
4385: LD_INT 0
4387: PUSH
4388: LD_INT 0
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: LIST
4397: LIST
4398: PUSH
4399: LD_INT 33
4401: PUSH
4402: LD_INT 33
4404: PUSH
4405: LD_INT 52
4407: PUSH
4408: LD_INT 5
4410: PUSH
4411: LD_INT 0
4413: PUSH
4414: LD_INT 0
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 5
4427: PUSH
4428: LD_INT 31
4430: PUSH
4431: LD_INT 40
4433: PUSH
4434: LD_INT 0
4436: PUSH
4437: LD_INT 0
4439: PUSH
4440: LD_INT 0
4442: PUSH
4443: EMPTY
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: PUSH
4451: LD_INT 33
4453: PUSH
4454: LD_INT 65
4456: PUSH
4457: LD_INT 37
4459: PUSH
4460: LD_INT 5
4462: PUSH
4463: LD_INT 0
4465: PUSH
4466: LD_INT 0
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: LIST
4475: LIST
4476: PUSH
4477: LD_INT 33
4479: PUSH
4480: LD_INT 63
4482: PUSH
4483: LD_INT 29
4485: PUSH
4486: LD_INT 4
4488: PUSH
4489: LD_INT 0
4491: PUSH
4492: LD_INT 0
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: LIST
4502: PUSH
4503: LD_INT 33
4505: PUSH
4506: LD_INT 54
4508: PUSH
4509: LD_INT 11
4511: PUSH
4512: LD_INT 4
4514: PUSH
4515: LD_INT 0
4517: PUSH
4518: LD_INT 0
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: LIST
4528: PUSH
4529: LD_INT 33
4531: PUSH
4532: LD_INT 56
4534: PUSH
4535: LD_INT 15
4537: PUSH
4538: LD_INT 4
4540: PUSH
4541: LD_INT 0
4543: PUSH
4544: LD_INT 0
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: LIST
4553: LIST
4554: PUSH
4555: LD_INT 33
4557: PUSH
4558: LD_INT 51
4560: PUSH
4561: LD_INT 6
4563: PUSH
4564: LD_INT 4
4566: PUSH
4567: LD_INT 0
4569: PUSH
4570: LD_INT 0
4572: PUSH
4573: EMPTY
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 26
4583: PUSH
4584: LD_INT 39
4586: PUSH
4587: LD_INT 25
4589: PUSH
4590: LD_INT 0
4592: PUSH
4593: LD_INT 0
4595: PUSH
4596: LD_INT 0
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: LIST
4605: LIST
4606: PUSH
4607: LD_INT 26
4609: PUSH
4610: LD_INT 37
4612: PUSH
4613: LD_INT 21
4615: PUSH
4616: LD_INT 0
4618: PUSH
4619: LD_INT 0
4621: PUSH
4622: LD_INT 0
4624: PUSH
4625: EMPTY
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: LIST
4631: LIST
4632: PUSH
4633: LD_INT 32
4635: PUSH
4636: LD_INT 35
4638: PUSH
4639: LD_INT 17
4641: PUSH
4642: LD_INT 4
4644: PUSH
4645: LD_INT 0
4647: PUSH
4648: LD_INT 0
4650: PUSH
4651: EMPTY
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 33
4661: PUSH
4662: LD_INT 35
4664: PUSH
4665: LD_INT 28
4667: PUSH
4668: LD_INT 4
4670: PUSH
4671: LD_INT 0
4673: PUSH
4674: LD_INT 0
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: LIST
4683: LIST
4684: PUSH
4685: LD_INT 33
4687: PUSH
4688: LD_INT 28
4690: PUSH
4691: LD_INT 46
4693: PUSH
4694: LD_INT 5
4696: PUSH
4697: LD_INT 0
4699: PUSH
4700: LD_INT 0
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: LIST
4709: LIST
4710: PUSH
4711: LD_INT 33
4713: PUSH
4714: LD_INT 31
4716: PUSH
4717: LD_INT 6
4719: PUSH
4720: LD_INT 4
4722: PUSH
4723: LD_INT 0
4725: PUSH
4726: LD_INT 0
4728: PUSH
4729: EMPTY
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: LIST
4735: LIST
4736: PUSH
4737: LD_INT 26
4739: PUSH
4740: LD_INT 54
4742: PUSH
4743: LD_INT 38
4745: PUSH
4746: LD_INT 4
4748: PUSH
4749: LD_INT 0
4751: PUSH
4752: LD_INT 0
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: PUSH
4763: LD_INT 33
4765: PUSH
4766: LD_INT 207
4768: PUSH
4769: LD_INT 167
4771: PUSH
4772: LD_INT 3
4774: PUSH
4775: LD_INT 0
4777: PUSH
4778: LD_INT 0
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: PUSH
4789: LD_INT 30
4791: PUSH
4792: LD_INT 43
4794: PUSH
4795: LD_INT 2
4797: PUSH
4798: LD_INT 4
4800: PUSH
4801: LD_INT 0
4803: PUSH
4804: LD_INT 0
4806: PUSH
4807: EMPTY
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: PUSH
4815: EMPTY
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: LIST
4900: LIST
4901: ST_TO_ADDR
// for i in tmp do
4902: LD_ADDR_VAR 0 2
4906: PUSH
4907: LD_VAR 0 4
4911: PUSH
4912: FOR_IN
4913: IFFALSE 5144
// begin uc_side := side ;
4915: LD_ADDR_OWVAR 20
4919: PUSH
4920: LD_VAR 0 5
4924: ST_TO_ADDR
// uc_nation := nation_russian ;
4925: LD_ADDR_OWVAR 21
4929: PUSH
4930: LD_INT 3
4932: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4933: LD_ADDR_OWVAR 42
4937: PUSH
4938: LD_VAR 0 2
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4947: LD_ADDR_OWVAR 43
4951: PUSH
4952: LD_INT 5
4954: PPUSH
4955: LD_INT 6
4957: PPUSH
4958: CALL_OW 12
4962: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4963: LD_ADDR_OWVAR 44
4967: PUSH
4968: LD_VAR 0 2
4972: PUSH
4973: LD_INT 5
4975: ARRAY
4976: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4977: LD_ADDR_OWVAR 45
4981: PUSH
4982: LD_VAR 0 2
4986: PUSH
4987: LD_INT 6
4989: ARRAY
4990: ST_TO_ADDR
// sr := 0 ;
4991: LD_ADDR_VAR 0 6
4995: PUSH
4996: LD_INT 0
4998: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4999: LD_VAR 0 2
5003: PUSH
5004: LD_INT 1
5006: ARRAY
5007: PUSH
5008: LD_INT 29
5010: EQUAL
5011: IFFALSE 5023
// sr := mat_oil else
5013: LD_ADDR_VAR 0 6
5017: PUSH
5018: LD_INT 2
5020: ST_TO_ADDR
5021: GO 5045
// if i [ 1 ] = b_siberite_mine then
5023: LD_VAR 0 2
5027: PUSH
5028: LD_INT 1
5030: ARRAY
5031: PUSH
5032: LD_INT 30
5034: EQUAL
5035: IFFALSE 5045
// sr := mat_siberit ;
5037: LD_ADDR_VAR 0 6
5041: PUSH
5042: LD_INT 3
5044: ST_TO_ADDR
// if sr then
5045: LD_VAR 0 6
5049: IFFALSE 5105
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5051: LD_VAR 0 2
5055: PUSH
5056: LD_INT 2
5058: ARRAY
5059: PPUSH
5060: LD_VAR 0 2
5064: PUSH
5065: LD_INT 3
5067: ARRAY
5068: PPUSH
5069: LD_VAR 0 6
5073: PPUSH
5074: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5078: LD_VAR 0 2
5082: PUSH
5083: LD_INT 2
5085: ARRAY
5086: PPUSH
5087: LD_VAR 0 2
5091: PUSH
5092: LD_INT 3
5094: ARRAY
5095: PPUSH
5096: LD_VAR 0 5
5100: PPUSH
5101: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5105: LD_ADDR_VAR 0 3
5109: PUSH
5110: LD_VAR 0 2
5114: PUSH
5115: LD_INT 2
5117: ARRAY
5118: PPUSH
5119: LD_VAR 0 2
5123: PUSH
5124: LD_INT 3
5126: ARRAY
5127: PPUSH
5128: LD_VAR 0 2
5132: PUSH
5133: LD_INT 4
5135: ARRAY
5136: PPUSH
5137: CALL_OW 47
5141: ST_TO_ADDR
// end ;
5142: GO 4912
5144: POP
5145: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5146: LD_ADDR_VAR 0 7
5150: PUSH
5151: LD_INT 22
5153: PUSH
5154: LD_VAR 0 5
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 30
5165: PUSH
5166: LD_INT 1
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PPUSH
5177: CALL_OW 69
5181: ST_TO_ADDR
// if not depot then
5182: LD_VAR 0 7
5186: NOT
5187: IFFALSE 5191
// exit ;
5189: GO 5535
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5191: LD_ADDR_VAR 0 8
5195: PUSH
5196: LD_INT 84
5198: PPUSH
5199: LD_INT 128
5201: PPUSH
5202: CALL_OW 428
5206: PPUSH
5207: LD_INT 15
5209: PPUSH
5210: LD_INT 0
5212: PPUSH
5213: LD_INT 6
5215: PUSH
5216: LD_INT 7
5218: PUSH
5219: LD_INT 8
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: LIST
5226: PUSH
5227: LD_OWVAR 67
5231: ARRAY
5232: PPUSH
5233: LD_INT 3000
5235: PUSH
5236: LD_INT 300
5238: PUSH
5239: LD_INT 100
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: PPUSH
5247: LD_INT 12
5249: PUSH
5250: LD_INT 6
5252: PUSH
5253: LD_INT 6
5255: PUSH
5256: LD_INT 4
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: LIST
5263: LIST
5264: PPUSH
5265: CALL 28349 0 6
5269: ST_TO_ADDR
// if not base then
5270: LD_VAR 0 8
5274: NOT
5275: IFFALSE 5279
// exit ;
5277: GO 5535
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5279: LD_ADDR_EXP 49
5283: PUSH
5284: LD_EXP 49
5288: PPUSH
5289: LD_EXP 7
5293: PPUSH
5294: LD_VAR 0 8
5298: PPUSH
5299: CALL_OW 1
5303: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5304: LD_ADDR_VAR 0 8
5308: PUSH
5309: LD_INT 34
5311: PPUSH
5312: LD_INT 23
5314: PPUSH
5315: CALL_OW 428
5319: PPUSH
5320: LD_INT 11
5322: PPUSH
5323: LD_INT 0
5325: PPUSH
5326: LD_INT 6
5328: PUSH
5329: LD_INT 7
5331: PUSH
5332: LD_INT 8
5334: PUSH
5335: EMPTY
5336: LIST
5337: LIST
5338: LIST
5339: PUSH
5340: LD_OWVAR 67
5344: ARRAY
5345: PPUSH
5346: LD_INT 20000
5348: PUSH
5349: LD_INT 3000
5351: PUSH
5352: LD_INT 1000
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: LIST
5359: PPUSH
5360: LD_INT 12
5362: PUSH
5363: LD_INT 6
5365: PUSH
5366: LD_INT 6
5368: PUSH
5369: LD_INT 4
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: LIST
5376: LIST
5377: PPUSH
5378: CALL 28349 0 6
5382: ST_TO_ADDR
// if not base then
5383: LD_VAR 0 8
5387: NOT
5388: IFFALSE 5392
// exit ;
5390: GO 5535
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5392: LD_ADDR_EXP 49
5396: PUSH
5397: LD_EXP 49
5401: PPUSH
5402: LD_EXP 8
5406: PPUSH
5407: LD_VAR 0 8
5411: PPUSH
5412: CALL_OW 1
5416: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5417: LD_ADDR_EXP 14
5421: PUSH
5422: LD_INT 22
5424: PUSH
5425: LD_INT 3
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: PUSH
5432: LD_INT 30
5434: PUSH
5435: LD_INT 0
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PPUSH
5446: CALL_OW 69
5450: PUSH
5451: LD_INT 1
5453: ARRAY
5454: PPUSH
5455: LD_INT 25
5457: PPUSH
5458: LD_INT 0
5460: PPUSH
5461: LD_INT 6
5463: PUSH
5464: LD_INT 7
5466: PUSH
5467: LD_INT 8
5469: PUSH
5470: EMPTY
5471: LIST
5472: LIST
5473: LIST
5474: PUSH
5475: LD_OWVAR 67
5479: ARRAY
5480: PPUSH
5481: LD_INT 500
5483: PUSH
5484: LD_INT 100
5486: PUSH
5487: LD_INT 10
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: LIST
5494: PPUSH
5495: LD_INT 6
5497: PUSH
5498: LD_INT 7
5500: PUSH
5501: LD_INT 8
5503: PUSH
5504: EMPTY
5505: LIST
5506: LIST
5507: LIST
5508: PUSH
5509: LD_OWVAR 67
5513: ARRAY
5514: PUSH
5515: LD_INT 2
5517: PUSH
5518: LD_INT 0
5520: PUSH
5521: LD_INT 1
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: PPUSH
5530: CALL 28349 0 6
5534: ST_TO_ADDR
// end ;
5535: LD_VAR 0 1
5539: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5540: LD_INT 0
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
5551: PPUSH
5552: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5553: LD_INT 0
5555: PPUSH
5556: LD_INT 0
5558: PPUSH
5559: LD_INT 6
5561: PPUSH
5562: LD_INT 0
5564: PPUSH
5565: LD_INT 0
5567: PPUSH
5568: LD_INT 0
5570: PPUSH
5571: LD_INT 0
5573: PPUSH
5574: LD_INT 8
5576: PPUSH
5577: LD_INT 0
5579: PPUSH
5580: CALL 53969 0 9
// side := 8 ;
5584: LD_ADDR_VAR 0 8
5588: PUSH
5589: LD_INT 8
5591: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5592: LD_ADDR_VAR 0 5
5596: PUSH
5597: LD_INT 20
5599: PPUSH
5600: LD_INT 0
5602: PPUSH
5603: CALL_OW 517
5607: ST_TO_ADDR
// if Difficulty > 2 then
5608: LD_OWVAR 67
5612: PUSH
5613: LD_INT 2
5615: GREATER
5616: IFFALSE 5760
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5618: LD_ADDR_VAR 0 6
5622: PUSH
5623: LD_INT 27
5625: PPUSH
5626: LD_INT 0
5628: PPUSH
5629: CALL_OW 517
5633: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5634: LD_ADDR_VAR 0 2
5638: PUSH
5639: DOUBLE
5640: LD_INT 1
5642: DEC
5643: ST_TO_ADDR
5644: LD_VAR 0 6
5648: PUSH
5649: LD_INT 1
5651: ARRAY
5652: PUSH
5653: FOR_TO
5654: IFFALSE 5758
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5656: LD_ADDR_VAR 0 5
5660: PUSH
5661: LD_VAR 0 5
5665: PPUSH
5666: LD_INT 1
5668: PUSH
5669: LD_VAR 0 5
5673: PUSH
5674: LD_INT 1
5676: ARRAY
5677: PUSH
5678: LD_INT 1
5680: PLUS
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: PPUSH
5686: LD_VAR 0 6
5690: PUSH
5691: LD_INT 1
5693: ARRAY
5694: PUSH
5695: LD_VAR 0 2
5699: ARRAY
5700: PPUSH
5701: CALL 25025 0 3
5705: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5706: LD_ADDR_VAR 0 5
5710: PUSH
5711: LD_VAR 0 5
5715: PPUSH
5716: LD_INT 2
5718: PUSH
5719: LD_VAR 0 5
5723: PUSH
5724: LD_INT 2
5726: ARRAY
5727: PUSH
5728: LD_INT 1
5730: PLUS
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: PPUSH
5736: LD_VAR 0 6
5740: PUSH
5741: LD_INT 2
5743: ARRAY
5744: PUSH
5745: LD_VAR 0 2
5749: ARRAY
5750: PPUSH
5751: CALL 25025 0 3
5755: ST_TO_ADDR
// end ;
5756: GO 5653
5758: POP
5759: POP
// end ; if tmp then
5760: LD_VAR 0 5
5764: IFFALSE 5892
// begin for i = 1 to tmp [ 1 ] do
5766: LD_ADDR_VAR 0 2
5770: PUSH
5771: DOUBLE
5772: LD_INT 1
5774: DEC
5775: ST_TO_ADDR
5776: LD_VAR 0 5
5780: PUSH
5781: LD_INT 1
5783: ARRAY
5784: PUSH
5785: FOR_TO
5786: IFFALSE 5890
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5788: LD_VAR 0 5
5792: PUSH
5793: LD_INT 1
5795: ARRAY
5796: PUSH
5797: LD_VAR 0 2
5801: ARRAY
5802: PPUSH
5803: LD_VAR 0 5
5807: PUSH
5808: LD_INT 2
5810: ARRAY
5811: PUSH
5812: LD_VAR 0 2
5816: ARRAY
5817: PPUSH
5818: LD_VAR 0 8
5822: PPUSH
5823: LD_INT 0
5825: PPUSH
5826: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5830: LD_ADDR_EXP 16
5834: PUSH
5835: LD_EXP 16
5839: PPUSH
5840: LD_EXP 16
5844: PUSH
5845: LD_INT 1
5847: PLUS
5848: PPUSH
5849: LD_VAR 0 5
5853: PUSH
5854: LD_INT 1
5856: ARRAY
5857: PUSH
5858: LD_VAR 0 2
5862: ARRAY
5863: PUSH
5864: LD_VAR 0 5
5868: PUSH
5869: LD_INT 2
5871: ARRAY
5872: PUSH
5873: LD_VAR 0 2
5877: ARRAY
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: PPUSH
5883: CALL_OW 2
5887: ST_TO_ADDR
// end ;
5888: GO 5785
5890: POP
5891: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5892: LD_ADDR_VAR 0 7
5896: PUSH
5897: LD_INT 165
5899: PUSH
5900: LD_INT 156
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: LD_INT 143
5909: PUSH
5910: LD_INT 145
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 152
5919: PUSH
5920: LD_INT 165
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: PUSH
5927: LD_INT 123
5929: PUSH
5930: LD_INT 153
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: PUSH
5937: LD_INT 161
5939: PUSH
5940: LD_INT 215
5942: PUSH
5943: EMPTY
5944: LIST
5945: LIST
5946: PUSH
5947: LD_INT 172
5949: PUSH
5950: LD_INT 100
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: PUSH
5957: LD_INT 148
5959: PUSH
5960: LD_INT 83
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: PUSH
5967: LD_INT 122
5969: PUSH
5970: LD_INT 68
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 105
5979: PUSH
5980: LD_INT 74
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PUSH
5987: LD_INT 113
5989: PUSH
5990: LD_INT 97
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: PUSH
5997: EMPTY
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: LIST
6007: LIST
6008: ST_TO_ADDR
// for i in cameras do
6009: LD_ADDR_VAR 0 2
6013: PUSH
6014: LD_VAR 0 7
6018: PUSH
6019: FOR_IN
6020: IFFALSE 6051
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
6022: LD_VAR 0 2
6026: PUSH
6027: LD_INT 1
6029: ARRAY
6030: PPUSH
6031: LD_VAR 0 2
6035: PUSH
6036: LD_INT 2
6038: ARRAY
6039: PPUSH
6040: LD_VAR 0 8
6044: PPUSH
6045: CALL_OW 244
6049: GO 6019
6051: POP
6052: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6053: LD_ADDR_VAR 0 5
6057: PUSH
6058: LD_INT 1
6060: PUSH
6061: LD_INT 144
6063: PUSH
6064: LD_INT 110
6066: PUSH
6067: LD_INT 1
6069: PUSH
6070: LD_INT 0
6072: PUSH
6073: LD_INT 0
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 3
6086: PUSH
6087: LD_INT 151
6089: PUSH
6090: LD_INT 118
6092: PUSH
6093: LD_INT 0
6095: PUSH
6096: LD_INT 0
6098: PUSH
6099: LD_INT 0
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: LIST
6108: LIST
6109: PUSH
6110: LD_INT 8
6112: PUSH
6113: LD_INT 158
6115: PUSH
6116: LD_INT 110
6118: PUSH
6119: LD_INT 4
6121: PUSH
6122: LD_INT 10
6124: PUSH
6125: LD_INT 15
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: LIST
6134: LIST
6135: PUSH
6136: LD_INT 23
6138: PUSH
6139: LD_INT 154
6141: PUSH
6142: LD_INT 121
6144: PUSH
6145: LD_INT 5
6147: PUSH
6148: LD_INT 0
6150: PUSH
6151: LD_INT 0
6153: PUSH
6154: EMPTY
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 22
6164: PUSH
6165: LD_INT 155
6167: PUSH
6168: LD_INT 118
6170: PUSH
6171: LD_INT 4
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: LD_INT 0
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: LIST
6186: LIST
6187: PUSH
6188: LD_INT 21
6190: PUSH
6191: LD_INT 151
6193: PUSH
6194: LD_INT 122
6196: PUSH
6197: LD_INT 0
6199: PUSH
6200: LD_INT 0
6202: PUSH
6203: LD_INT 0
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: LIST
6212: LIST
6213: PUSH
6214: LD_INT 18
6216: PUSH
6217: LD_INT 148
6219: PUSH
6220: LD_INT 118
6222: PUSH
6223: LD_INT 1
6225: PUSH
6226: LD_INT 0
6228: PUSH
6229: LD_INT 0
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: PUSH
6240: LD_INT 17
6242: PUSH
6243: LD_INT 147
6245: PUSH
6246: LD_INT 114
6248: PUSH
6249: LD_INT 2
6251: PUSH
6252: LD_INT 0
6254: PUSH
6255: LD_INT 0
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: LIST
6264: LIST
6265: PUSH
6266: LD_INT 29
6268: PUSH
6269: LD_INT 163
6271: PUSH
6272: LD_INT 120
6274: PUSH
6275: LD_INT 5
6277: PUSH
6278: LD_INT 0
6280: PUSH
6281: LD_INT 0
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: LIST
6290: LIST
6291: PUSH
6292: LD_INT 27
6294: PUSH
6295: LD_INT 137
6297: PUSH
6298: LD_INT 116
6300: PUSH
6301: LD_INT 3
6303: PUSH
6304: LD_INT 0
6306: PUSH
6307: LD_INT 0
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_INT 27
6320: PUSH
6321: LD_INT 133
6323: PUSH
6324: LD_INT 111
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 0
6332: PUSH
6333: LD_INT 0
6335: PUSH
6336: EMPTY
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: LIST
6342: LIST
6343: PUSH
6344: LD_INT 27
6346: PUSH
6347: LD_INT 132
6349: PUSH
6350: LD_INT 106
6352: PUSH
6353: LD_INT 4
6355: PUSH
6356: LD_INT 0
6358: PUSH
6359: LD_INT 0
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: PUSH
6370: LD_INT 26
6372: PUSH
6373: LD_INT 137
6375: PUSH
6376: LD_INT 111
6378: PUSH
6379: LD_INT 0
6381: PUSH
6382: LD_INT 0
6384: PUSH
6385: LD_INT 0
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_INT 8
6398: PUSH
6399: LD_INT 141
6401: PUSH
6402: LD_INT 117
6404: PUSH
6405: LD_INT 1
6407: PUSH
6408: LD_INT 13
6410: PUSH
6411: LD_INT 11
6413: PUSH
6414: EMPTY
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: LIST
6420: LIST
6421: PUSH
6422: LD_INT 30
6424: PUSH
6425: LD_INT 140
6427: PUSH
6428: LD_INT 128
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 0
6436: PUSH
6437: LD_INT 0
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: LIST
6446: LIST
6447: PUSH
6448: LD_INT 5
6450: PUSH
6451: LD_INT 146
6453: PUSH
6454: LD_INT 96
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 0
6462: PUSH
6463: LD_INT 0
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 32
6476: PUSH
6477: LD_INT 150
6479: PUSH
6480: LD_INT 98
6482: PUSH
6483: LD_INT 3
6485: PUSH
6486: LD_INT 0
6488: PUSH
6489: LD_INT 0
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 32
6502: PUSH
6503: LD_INT 142
6505: PUSH
6506: LD_INT 95
6508: PUSH
6509: LD_INT 3
6511: PUSH
6512: LD_INT 0
6514: PUSH
6515: LD_INT 0
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 32
6528: PUSH
6529: LD_INT 159
6531: PUSH
6532: LD_INT 104
6534: PUSH
6535: LD_INT 3
6537: PUSH
6538: LD_INT 0
6540: PUSH
6541: LD_INT 0
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: LIST
6550: LIST
6551: PUSH
6552: LD_INT 32
6554: PUSH
6555: LD_INT 133
6557: PUSH
6558: LD_INT 95
6560: PUSH
6561: LD_INT 3
6563: PUSH
6564: LD_INT 0
6566: PUSH
6567: LD_INT 0
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: LIST
6576: LIST
6577: PUSH
6578: LD_INT 32
6580: PUSH
6581: LD_INT 131
6583: PUSH
6584: LD_INT 102
6586: PUSH
6587: LD_INT 2
6589: PUSH
6590: LD_INT 0
6592: PUSH
6593: LD_INT 0
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: PUSH
6604: LD_INT 32
6606: PUSH
6607: LD_INT 164
6609: PUSH
6610: LD_INT 144
6612: PUSH
6613: LD_INT 0
6615: PUSH
6616: LD_INT 0
6618: PUSH
6619: LD_INT 0
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: LIST
6629: PUSH
6630: LD_INT 32
6632: PUSH
6633: LD_INT 146
6635: PUSH
6636: LD_INT 139
6638: PUSH
6639: LD_INT 0
6641: PUSH
6642: LD_INT 0
6644: PUSH
6645: LD_INT 0
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: LIST
6654: LIST
6655: PUSH
6656: LD_INT 26
6658: PUSH
6659: LD_INT 143
6661: PUSH
6662: LD_INT 122
6664: PUSH
6665: LD_INT 4
6667: PUSH
6668: LD_INT 0
6670: PUSH
6671: LD_INT 0
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: LIST
6680: LIST
6681: PUSH
6682: LD_INT 26
6684: PUSH
6685: LD_INT 164
6687: PUSH
6688: LD_INT 116
6690: PUSH
6691: LD_INT 2
6693: PUSH
6694: LD_INT 0
6696: PUSH
6697: LD_INT 0
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: LIST
6733: LIST
6734: ST_TO_ADDR
// for i in tmp do
6735: LD_ADDR_VAR 0 2
6739: PUSH
6740: LD_VAR 0 5
6744: PUSH
6745: FOR_IN
6746: IFFALSE 6977
// begin uc_side := side ;
6748: LD_ADDR_OWVAR 20
6752: PUSH
6753: LD_VAR 0 8
6757: ST_TO_ADDR
// uc_nation := nation_arabian ;
6758: LD_ADDR_OWVAR 21
6762: PUSH
6763: LD_INT 2
6765: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6766: LD_ADDR_OWVAR 42
6770: PUSH
6771: LD_VAR 0 2
6775: PUSH
6776: LD_INT 1
6778: ARRAY
6779: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6780: LD_ADDR_OWVAR 43
6784: PUSH
6785: LD_INT 5
6787: PPUSH
6788: LD_INT 6
6790: PPUSH
6791: CALL_OW 12
6795: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6796: LD_ADDR_OWVAR 44
6800: PUSH
6801: LD_VAR 0 2
6805: PUSH
6806: LD_INT 5
6808: ARRAY
6809: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6810: LD_ADDR_OWVAR 45
6814: PUSH
6815: LD_VAR 0 2
6819: PUSH
6820: LD_INT 6
6822: ARRAY
6823: ST_TO_ADDR
// sr := 0 ;
6824: LD_ADDR_VAR 0 9
6828: PUSH
6829: LD_INT 0
6831: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6832: LD_VAR 0 2
6836: PUSH
6837: LD_INT 1
6839: ARRAY
6840: PUSH
6841: LD_INT 29
6843: EQUAL
6844: IFFALSE 6856
// sr := mat_oil else
6846: LD_ADDR_VAR 0 9
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
6854: GO 6878
// if i [ 1 ] = b_siberite_mine then
6856: LD_VAR 0 2
6860: PUSH
6861: LD_INT 1
6863: ARRAY
6864: PUSH
6865: LD_INT 30
6867: EQUAL
6868: IFFALSE 6878
// sr := mat_siberit ;
6870: LD_ADDR_VAR 0 9
6874: PUSH
6875: LD_INT 3
6877: ST_TO_ADDR
// if sr then
6878: LD_VAR 0 9
6882: IFFALSE 6938
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6884: LD_VAR 0 2
6888: PUSH
6889: LD_INT 2
6891: ARRAY
6892: PPUSH
6893: LD_VAR 0 2
6897: PUSH
6898: LD_INT 3
6900: ARRAY
6901: PPUSH
6902: LD_VAR 0 9
6906: PPUSH
6907: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6911: LD_VAR 0 2
6915: PUSH
6916: LD_INT 2
6918: ARRAY
6919: PPUSH
6920: LD_VAR 0 2
6924: PUSH
6925: LD_INT 3
6927: ARRAY
6928: PPUSH
6929: LD_VAR 0 8
6933: PPUSH
6934: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6938: LD_ADDR_VAR 0 3
6942: PUSH
6943: LD_VAR 0 2
6947: PUSH
6948: LD_INT 2
6950: ARRAY
6951: PPUSH
6952: LD_VAR 0 2
6956: PUSH
6957: LD_INT 3
6959: ARRAY
6960: PPUSH
6961: LD_VAR 0 2
6965: PUSH
6966: LD_INT 4
6968: ARRAY
6969: PPUSH
6970: CALL_OW 47
6974: ST_TO_ADDR
// end ;
6975: GO 6745
6977: POP
6978: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6979: LD_ADDR_VAR 0 10
6983: PUSH
6984: LD_INT 22
6986: PUSH
6987: LD_VAR 0 8
6991: PUSH
6992: EMPTY
6993: LIST
6994: LIST
6995: PUSH
6996: LD_INT 30
6998: PUSH
6999: LD_INT 1
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PPUSH
7010: CALL_OW 69
7014: ST_TO_ADDR
// if not depot then
7015: LD_VAR 0 10
7019: NOT
7020: IFFALSE 7024
// exit ;
7022: GO 7270
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
7024: LD_ADDR_VAR 0 11
7028: PUSH
7029: LD_VAR 0 10
7033: PUSH
7034: LD_INT 1
7036: ARRAY
7037: PPUSH
7038: LD_INT 6
7040: PPUSH
7041: LD_INT 0
7043: PPUSH
7044: LD_INT 7
7046: PUSH
7047: LD_INT 8
7049: PUSH
7050: LD_INT 10
7052: PUSH
7053: EMPTY
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_OWVAR 67
7062: ARRAY
7063: PPUSH
7064: LD_INT 3000
7066: PUSH
7067: LD_INT 300
7069: PUSH
7070: LD_INT 100
7072: PUSH
7073: EMPTY
7074: LIST
7075: LIST
7076: LIST
7077: PPUSH
7078: LD_INT 14
7080: PUSH
7081: LD_INT 6
7083: PUSH
7084: LD_INT 6
7086: PUSH
7087: LD_INT 5
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: LIST
7094: LIST
7095: PPUSH
7096: CALL 28349 0 6
7100: ST_TO_ADDR
// if not base then
7101: LD_VAR 0 11
7105: NOT
7106: IFFALSE 7110
// exit ;
7108: GO 7270
// if Difficulty > 1 then
7110: LD_OWVAR 67
7114: PUSH
7115: LD_INT 1
7117: GREATER
7118: IFFALSE 7191
// begin InitHc ;
7120: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7124: LD_INT 1
7126: PPUSH
7127: LD_INT 5
7129: PPUSH
7130: LD_INT 5
7132: PUSH
7133: LD_INT 8
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: PUSH
7140: LD_OWVAR 67
7144: PUSH
7145: LD_INT 1
7147: MINUS
7148: ARRAY
7149: PPUSH
7150: CALL_OW 380
// for i = 1 to Difficulty do
7154: LD_ADDR_VAR 0 2
7158: PUSH
7159: DOUBLE
7160: LD_INT 1
7162: DEC
7163: ST_TO_ADDR
7164: LD_OWVAR 67
7168: PUSH
7169: FOR_TO
7170: IFFALSE 7189
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7172: CALL_OW 44
7176: PPUSH
7177: LD_INT 24
7179: PPUSH
7180: LD_INT 0
7182: PPUSH
7183: CALL_OW 49
7187: GO 7169
7189: POP
7190: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7191: LD_ADDR_EXP 49
7195: PUSH
7196: LD_EXP 49
7200: PPUSH
7201: LD_EXP 6
7205: PPUSH
7206: LD_VAR 0 11
7210: PPUSH
7211: CALL_OW 1
7215: ST_TO_ADDR
// hc_gallery := ru ;
7216: LD_ADDR_OWVAR 33
7220: PUSH
7221: LD_STRING ru
7223: ST_TO_ADDR
// hc_face_number := 44 ;
7224: LD_ADDR_OWVAR 34
7228: PUSH
7229: LD_INT 44
7231: ST_TO_ADDR
// hc_name := Robert Farmer ;
7232: LD_ADDR_OWVAR 26
7236: PUSH
7237: LD_STRING Robert Farmer
7239: ST_TO_ADDR
// hc_sex := sex_male ;
7240: LD_ADDR_OWVAR 27
7244: PUSH
7245: LD_INT 1
7247: ST_TO_ADDR
// hc_class := 1 ;
7248: LD_ADDR_OWVAR 28
7252: PUSH
7253: LD_INT 1
7255: ST_TO_ADDR
// Farmer := CreateHuman ;
7256: LD_ADDR_EXP 13
7260: PUSH
7261: CALL_OW 44
7265: ST_TO_ADDR
// InitHc ;
7266: CALL_OW 19
// end ;
7270: LD_VAR 0 1
7274: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7275: LD_INT 0
7277: PPUSH
7278: PPUSH
7279: PPUSH
7280: PPUSH
// tmp := [ ] ;
7281: LD_ADDR_VAR 0 3
7285: PUSH
7286: EMPTY
7287: ST_TO_ADDR
// for i := 1 to 3 do
7288: LD_ADDR_VAR 0 2
7292: PUSH
7293: DOUBLE
7294: LD_INT 1
7296: DEC
7297: ST_TO_ADDR
7298: LD_INT 3
7300: PUSH
7301: FOR_TO
7302: IFFALSE 7414
// begin uc_side := 3 ;
7304: LD_ADDR_OWVAR 20
7308: PUSH
7309: LD_INT 3
7311: ST_TO_ADDR
// uc_nation := 3 ;
7312: LD_ADDR_OWVAR 21
7316: PUSH
7317: LD_INT 3
7319: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7320: LD_ADDR_OWVAR 37
7324: PUSH
7325: LD_INT 22
7327: ST_TO_ADDR
// vc_engine := engine_siberite ;
7328: LD_ADDR_OWVAR 39
7332: PUSH
7333: LD_INT 3
7335: ST_TO_ADDR
// vc_control := control_computer ;
7336: LD_ADDR_OWVAR 38
7340: PUSH
7341: LD_INT 3
7343: ST_TO_ADDR
// vc_weapon := ru_crane ;
7344: LD_ADDR_OWVAR 40
7348: PUSH
7349: LD_INT 52
7351: ST_TO_ADDR
// veh := CreateVehicle ;
7352: LD_ADDR_VAR 0 4
7356: PUSH
7357: CALL_OW 45
7361: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7362: LD_VAR 0 4
7366: PPUSH
7367: LD_INT 73
7369: PPUSH
7370: LD_INT 122
7372: PPUSH
7373: LD_INT 3
7375: PPUSH
7376: LD_INT 0
7378: PPUSH
7379: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7383: LD_ADDR_VAR 0 3
7387: PUSH
7388: LD_VAR 0 3
7392: PPUSH
7393: LD_VAR 0 3
7397: PUSH
7398: LD_INT 1
7400: PLUS
7401: PPUSH
7402: LD_VAR 0 4
7406: PPUSH
7407: CALL_OW 1
7411: ST_TO_ADDR
// end ;
7412: GO 7301
7414: POP
7415: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7416: LD_ADDR_EXP 68
7420: PUSH
7421: LD_EXP 68
7425: PPUSH
7426: LD_EXP 7
7430: PPUSH
7431: LD_VAR 0 3
7435: PPUSH
7436: CALL_OW 1
7440: ST_TO_ADDR
// tmp := [ ] ;
7441: LD_ADDR_VAR 0 3
7445: PUSH
7446: EMPTY
7447: ST_TO_ADDR
// for i := 1 to 3 do
7448: LD_ADDR_VAR 0 2
7452: PUSH
7453: DOUBLE
7454: LD_INT 1
7456: DEC
7457: ST_TO_ADDR
7458: LD_INT 3
7460: PUSH
7461: FOR_TO
7462: IFFALSE 7574
// begin uc_side := 3 ;
7464: LD_ADDR_OWVAR 20
7468: PUSH
7469: LD_INT 3
7471: ST_TO_ADDR
// uc_nation := 3 ;
7472: LD_ADDR_OWVAR 21
7476: PUSH
7477: LD_INT 3
7479: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7480: LD_ADDR_OWVAR 37
7484: PUSH
7485: LD_INT 22
7487: ST_TO_ADDR
// vc_engine := engine_siberite ;
7488: LD_ADDR_OWVAR 39
7492: PUSH
7493: LD_INT 3
7495: ST_TO_ADDR
// vc_control := control_computer ;
7496: LD_ADDR_OWVAR 38
7500: PUSH
7501: LD_INT 3
7503: ST_TO_ADDR
// vc_weapon := ru_crane ;
7504: LD_ADDR_OWVAR 40
7508: PUSH
7509: LD_INT 52
7511: ST_TO_ADDR
// veh := CreateVehicle ;
7512: LD_ADDR_VAR 0 4
7516: PUSH
7517: CALL_OW 45
7521: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7522: LD_VAR 0 4
7526: PPUSH
7527: LD_INT 22
7529: PPUSH
7530: LD_INT 28
7532: PPUSH
7533: LD_INT 3
7535: PPUSH
7536: LD_INT 0
7538: PPUSH
7539: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7543: LD_ADDR_VAR 0 3
7547: PUSH
7548: LD_VAR 0 3
7552: PPUSH
7553: LD_VAR 0 3
7557: PUSH
7558: LD_INT 1
7560: PLUS
7561: PPUSH
7562: LD_VAR 0 4
7566: PPUSH
7567: CALL_OW 1
7571: ST_TO_ADDR
// end ;
7572: GO 7461
7574: POP
7575: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7576: LD_ADDR_EXP 68
7580: PUSH
7581: LD_EXP 68
7585: PPUSH
7586: LD_EXP 8
7590: PPUSH
7591: LD_VAR 0 3
7595: PPUSH
7596: CALL_OW 1
7600: ST_TO_ADDR
// end ;
7601: LD_VAR 0 1
7605: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7606: LD_INT 0
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
7613: PPUSH
7614: PPUSH
7615: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7616: LD_INT 0
7618: PPUSH
7619: LD_INT 0
7621: PPUSH
7622: LD_INT 4
7624: PPUSH
7625: LD_INT 0
7627: PPUSH
7628: LD_INT 0
7630: PPUSH
7631: LD_INT 0
7633: PPUSH
7634: LD_INT 0
7636: PPUSH
7637: LD_INT 10
7639: PPUSH
7640: LD_INT 0
7642: PPUSH
7643: CALL 53969 0 9
// side := 4 ;
7647: LD_ADDR_VAR 0 5
7651: PUSH
7652: LD_INT 4
7654: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7655: LD_ADDR_VAR 0 4
7659: PUSH
7660: LD_INT 1
7662: PUSH
7663: LD_INT 144
7665: PUSH
7666: LD_INT 18
7668: PUSH
7669: LD_INT 4
7671: PUSH
7672: LD_INT 0
7674: PUSH
7675: LD_INT 0
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 3
7688: PUSH
7689: LD_INT 137
7691: PUSH
7692: LD_INT 8
7694: PUSH
7695: LD_INT 4
7697: PUSH
7698: LD_INT 0
7700: PUSH
7701: LD_INT 0
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: LIST
7711: PUSH
7712: LD_INT 22
7714: PUSH
7715: LD_INT 141
7717: PUSH
7718: LD_INT 8
7720: PUSH
7721: LD_INT 4
7723: PUSH
7724: LD_INT 0
7726: PUSH
7727: LD_INT 0
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: LD_INT 25
7740: PUSH
7741: LD_INT 137
7743: PUSH
7744: LD_INT 5
7746: PUSH
7747: LD_INT 3
7749: PUSH
7750: LD_INT 0
7752: PUSH
7753: LD_INT 0
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 18
7766: PUSH
7767: LD_INT 137
7769: PUSH
7770: LD_INT 12
7772: PUSH
7773: LD_INT 0
7775: PUSH
7776: LD_INT 0
7778: PUSH
7779: LD_INT 0
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 17
7792: PUSH
7793: LD_INT 133
7795: PUSH
7796: LD_INT 4
7798: PUSH
7799: LD_INT 2
7801: PUSH
7802: LD_INT 0
7804: PUSH
7805: LD_INT 0
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 16
7818: PUSH
7819: LD_INT 140
7821: PUSH
7822: LD_INT 11
7824: PUSH
7825: LD_INT 5
7827: PUSH
7828: LD_INT 0
7830: PUSH
7831: LD_INT 0
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: LIST
7840: LIST
7841: PUSH
7842: LD_INT 8
7844: PUSH
7845: LD_INT 149
7847: PUSH
7848: LD_INT 26
7850: PUSH
7851: LD_INT 4
7853: PUSH
7854: LD_INT 10
7856: PUSH
7857: LD_INT 15
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: LIST
7866: LIST
7867: PUSH
7868: LD_INT 8
7870: PUSH
7871: LD_INT 142
7873: PUSH
7874: LD_INT 26
7876: PUSH
7877: LD_INT 1
7879: PUSH
7880: LD_INT 11
7882: PUSH
7883: LD_INT 12
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: LIST
7892: LIST
7893: PUSH
7894: LD_INT 27
7896: PUSH
7897: LD_INT 153
7899: PUSH
7900: LD_INT 32
7902: PUSH
7903: LD_INT 5
7905: PUSH
7906: LD_INT 0
7908: PUSH
7909: LD_INT 0
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 27
7922: PUSH
7923: LD_INT 145
7925: PUSH
7926: LD_INT 32
7928: PUSH
7929: LD_INT 3
7931: PUSH
7932: LD_INT 0
7934: PUSH
7935: LD_INT 0
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: LIST
7942: LIST
7943: LIST
7944: LIST
7945: PUSH
7946: LD_INT 27
7948: PUSH
7949: LD_INT 138
7951: PUSH
7952: LD_INT 2
7954: PUSH
7955: LD_INT 4
7957: PUSH
7958: LD_INT 0
7960: PUSH
7961: LD_INT 0
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: LIST
7968: LIST
7969: LIST
7970: LIST
7971: PUSH
7972: LD_INT 27
7974: PUSH
7975: LD_INT 144
7977: PUSH
7978: LD_INT 13
7980: PUSH
7981: LD_INT 0
7983: PUSH
7984: LD_INT 0
7986: PUSH
7987: LD_INT 0
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: LIST
7996: LIST
7997: PUSH
7998: LD_INT 26
8000: PUSH
8001: LD_INT 124
8003: PUSH
8004: LD_INT 2
8006: PUSH
8007: LD_INT 4
8009: PUSH
8010: LD_INT 0
8012: PUSH
8013: LD_INT 0
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: PUSH
8024: LD_INT 26
8026: PUSH
8027: LD_INT 121
8029: PUSH
8030: LD_INT 2
8032: PUSH
8033: LD_INT 2
8035: PUSH
8036: LD_INT 0
8038: PUSH
8039: LD_INT 0
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: LIST
8048: LIST
8049: PUSH
8050: LD_INT 26
8052: PUSH
8053: LD_INT 118
8055: PUSH
8056: LD_INT 2
8058: PUSH
8059: LD_INT 1
8061: PUSH
8062: LD_INT 0
8064: PUSH
8065: LD_INT 0
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: LIST
8074: LIST
8075: PUSH
8076: LD_INT 29
8078: PUSH
8079: LD_INT 159
8081: PUSH
8082: LD_INT 47
8084: PUSH
8085: LD_INT 2
8087: PUSH
8088: LD_INT 0
8090: PUSH
8091: LD_INT 0
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: LIST
8101: PUSH
8102: LD_INT 32
8104: PUSH
8105: LD_INT 146
8107: PUSH
8108: LD_INT 41
8110: PUSH
8111: LD_INT 0
8113: PUSH
8114: LD_INT 0
8116: PUSH
8117: LD_INT 0
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: LIST
8126: LIST
8127: PUSH
8128: LD_INT 33
8130: PUSH
8131: LD_INT 136
8133: PUSH
8134: LD_INT 37
8136: PUSH
8137: LD_INT 0
8139: PUSH
8140: LD_INT 0
8142: PUSH
8143: LD_INT 0
8145: PUSH
8146: EMPTY
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: LIST
8152: LIST
8153: PUSH
8154: LD_INT 33
8156: PUSH
8157: LD_INT 132
8159: PUSH
8160: LD_INT 34
8162: PUSH
8163: LD_INT 0
8165: PUSH
8166: LD_INT 0
8168: PUSH
8169: LD_INT 0
8171: PUSH
8172: EMPTY
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: LIST
8178: LIST
8179: PUSH
8180: LD_INT 36
8182: PUSH
8183: LD_INT 124
8185: PUSH
8186: LD_INT 7
8188: PUSH
8189: LD_INT 1
8191: PUSH
8192: LD_INT 0
8194: PUSH
8195: LD_INT 0
8197: PUSH
8198: EMPTY
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: LIST
8204: LIST
8205: PUSH
8206: LD_INT 5
8208: PUSH
8209: LD_INT 124
8211: PUSH
8212: LD_INT 19
8214: PUSH
8215: LD_INT 0
8217: PUSH
8218: LD_INT 0
8220: PUSH
8221: LD_INT 0
8223: PUSH
8224: EMPTY
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 32
8234: PUSH
8235: LD_INT 127
8237: PUSH
8238: LD_INT 23
8240: PUSH
8241: LD_INT 0
8243: PUSH
8244: LD_INT 0
8246: PUSH
8247: LD_INT 0
8249: PUSH
8250: EMPTY
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: LIST
8256: LIST
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: LIST
8281: LIST
8282: ST_TO_ADDR
// for i in tmp do
8283: LD_ADDR_VAR 0 2
8287: PUSH
8288: LD_VAR 0 4
8292: PUSH
8293: FOR_IN
8294: IFFALSE 8525
// begin uc_side := side ;
8296: LD_ADDR_OWVAR 20
8300: PUSH
8301: LD_VAR 0 5
8305: ST_TO_ADDR
// uc_nation := nation_american ;
8306: LD_ADDR_OWVAR 21
8310: PUSH
8311: LD_INT 1
8313: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8314: LD_ADDR_OWVAR 42
8318: PUSH
8319: LD_VAR 0 2
8323: PUSH
8324: LD_INT 1
8326: ARRAY
8327: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8328: LD_ADDR_OWVAR 43
8332: PUSH
8333: LD_INT 5
8335: PPUSH
8336: LD_INT 6
8338: PPUSH
8339: CALL_OW 12
8343: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8344: LD_ADDR_OWVAR 44
8348: PUSH
8349: LD_VAR 0 2
8353: PUSH
8354: LD_INT 5
8356: ARRAY
8357: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8358: LD_ADDR_OWVAR 45
8362: PUSH
8363: LD_VAR 0 2
8367: PUSH
8368: LD_INT 6
8370: ARRAY
8371: ST_TO_ADDR
// sr := 0 ;
8372: LD_ADDR_VAR 0 6
8376: PUSH
8377: LD_INT 0
8379: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8380: LD_VAR 0 2
8384: PUSH
8385: LD_INT 1
8387: ARRAY
8388: PUSH
8389: LD_INT 29
8391: EQUAL
8392: IFFALSE 8404
// sr := mat_oil else
8394: LD_ADDR_VAR 0 6
8398: PUSH
8399: LD_INT 2
8401: ST_TO_ADDR
8402: GO 8426
// if i [ 1 ] = b_siberite_mine then
8404: LD_VAR 0 2
8408: PUSH
8409: LD_INT 1
8411: ARRAY
8412: PUSH
8413: LD_INT 30
8415: EQUAL
8416: IFFALSE 8426
// sr := mat_siberit ;
8418: LD_ADDR_VAR 0 6
8422: PUSH
8423: LD_INT 3
8425: ST_TO_ADDR
// if sr then
8426: LD_VAR 0 6
8430: IFFALSE 8486
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8432: LD_VAR 0 2
8436: PUSH
8437: LD_INT 2
8439: ARRAY
8440: PPUSH
8441: LD_VAR 0 2
8445: PUSH
8446: LD_INT 3
8448: ARRAY
8449: PPUSH
8450: LD_VAR 0 6
8454: PPUSH
8455: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8459: LD_VAR 0 2
8463: PUSH
8464: LD_INT 2
8466: ARRAY
8467: PPUSH
8468: LD_VAR 0 2
8472: PUSH
8473: LD_INT 3
8475: ARRAY
8476: PPUSH
8477: LD_VAR 0 5
8481: PPUSH
8482: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8486: LD_ADDR_VAR 0 3
8490: PUSH
8491: LD_VAR 0 2
8495: PUSH
8496: LD_INT 2
8498: ARRAY
8499: PPUSH
8500: LD_VAR 0 2
8504: PUSH
8505: LD_INT 3
8507: ARRAY
8508: PPUSH
8509: LD_VAR 0 2
8513: PUSH
8514: LD_INT 4
8516: ARRAY
8517: PPUSH
8518: CALL_OW 47
8522: ST_TO_ADDR
// end ;
8523: GO 8293
8525: POP
8526: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8527: LD_ADDR_VAR 0 8
8531: PUSH
8532: LD_INT 22
8534: PUSH
8535: LD_VAR 0 5
8539: PUSH
8540: EMPTY
8541: LIST
8542: LIST
8543: PUSH
8544: LD_INT 30
8546: PUSH
8547: LD_INT 1
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: PPUSH
8558: CALL_OW 69
8562: ST_TO_ADDR
// if not depot then
8563: LD_VAR 0 8
8567: NOT
8568: IFFALSE 8572
// exit ;
8570: GO 8844
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8572: LD_ADDR_VAR 0 7
8576: PUSH
8577: LD_VAR 0 8
8581: PUSH
8582: LD_INT 1
8584: ARRAY
8585: PPUSH
8586: LD_INT 3
8588: PPUSH
8589: LD_STRING theta3
8591: PPUSH
8592: LD_INT 8
8594: PUSH
8595: LD_INT 7
8597: PUSH
8598: LD_INT 6
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: LIST
8605: PUSH
8606: LD_OWVAR 67
8610: ARRAY
8611: PPUSH
8612: LD_INT 2500
8614: PUSH
8615: LD_INT 2000
8617: PUSH
8618: LD_INT 1750
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: PUSH
8626: LD_OWVAR 67
8630: ARRAY
8631: PUSH
8632: LD_INT 300
8634: PUSH
8635: LD_INT 250
8637: PUSH
8638: LD_INT 200
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: LIST
8645: PUSH
8646: LD_OWVAR 67
8650: ARRAY
8651: PUSH
8652: LD_INT 80
8654: PUSH
8655: LD_INT 60
8657: PUSH
8658: LD_INT 50
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: LIST
8665: PUSH
8666: LD_OWVAR 67
8670: ARRAY
8671: PUSH
8672: EMPTY
8673: LIST
8674: LIST
8675: LIST
8676: PPUSH
8677: LD_INT 7
8679: PUSH
8680: LD_INT 6
8682: PUSH
8683: LD_INT 5
8685: PUSH
8686: LD_INT 5
8688: PUSH
8689: EMPTY
8690: LIST
8691: LIST
8692: LIST
8693: LIST
8694: PPUSH
8695: CALL 28349 0 6
8699: ST_TO_ADDR
// if not base then
8700: LD_VAR 0 7
8704: NOT
8705: IFFALSE 8709
// exit ;
8707: GO 8844
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8709: LD_ADDR_EXP 49
8713: PUSH
8714: LD_EXP 49
8718: PPUSH
8719: LD_EXP 5
8723: PPUSH
8724: LD_VAR 0 7
8728: PPUSH
8729: CALL_OW 1
8733: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 1
8739: PPUSH
8740: LD_INT 7
8742: PPUSH
8743: CALL_OW 380
// allyCommander := CreateHuman ;
8747: LD_ADDR_EXP 11
8751: PUSH
8752: CALL_OW 44
8756: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8757: LD_EXP 11
8761: PPUSH
8762: LD_INT 139
8764: PPUSH
8765: LD_INT 15
8767: PPUSH
8768: LD_INT 0
8770: PPUSH
8771: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8775: LD_EXP 11
8779: PPUSH
8780: LD_INT 137
8782: PPUSH
8783: LD_INT 15
8785: PPUSH
8786: CALL_OW 118
// hc_gallery := us ;
8790: LD_ADDR_OWVAR 33
8794: PUSH
8795: LD_STRING us
8797: ST_TO_ADDR
// hc_face_number := 7 ;
8798: LD_ADDR_OWVAR 34
8802: PUSH
8803: LD_INT 7
8805: ST_TO_ADDR
// hc_name := Arthur Powell ;
8806: LD_ADDR_OWVAR 26
8810: PUSH
8811: LD_STRING Arthur Powell
8813: ST_TO_ADDR
// hc_sex := sex_male ;
8814: LD_ADDR_OWVAR 27
8818: PUSH
8819: LD_INT 1
8821: ST_TO_ADDR
// hc_class := 1 ;
8822: LD_ADDR_OWVAR 28
8826: PUSH
8827: LD_INT 1
8829: ST_TO_ADDR
// Powell := CreateHuman ;
8830: LD_ADDR_EXP 12
8834: PUSH
8835: CALL_OW 44
8839: ST_TO_ADDR
// InitHc ;
8840: CALL_OW 19
// end ;
8844: LD_VAR 0 1
8848: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8849: LD_INT 0
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
8859: PPUSH
// side := 1 ;
8860: LD_ADDR_VAR 0 3
8864: PUSH
8865: LD_INT 1
8867: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8868: LD_ADDR_VAR 0 1
8872: PUSH
8873: EMPTY
8874: PUSH
8875: EMPTY
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: ST_TO_ADDR
// uc_side := side ;
8881: LD_ADDR_OWVAR 20
8885: PUSH
8886: LD_VAR 0 3
8890: ST_TO_ADDR
// uc_nation := nation_american ;
8891: LD_ADDR_OWVAR 21
8895: PUSH
8896: LD_INT 1
8898: ST_TO_ADDR
// InitHc ;
8899: CALL_OW 19
// InitVc ;
8903: CALL_OW 20
// hc_importance := 0 ;
8907: LD_ADDR_OWVAR 32
8911: PUSH
8912: LD_INT 0
8914: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8915: LD_ADDR_VAR 0 7
8919: PUSH
8920: LD_INT 2
8922: PUSH
8923: LD_INT 3
8925: PUSH
8926: LD_INT 3
8928: PUSH
8929: EMPTY
8930: LIST
8931: LIST
8932: LIST
8933: ST_TO_ADDR
// if commander = 2 then
8934: LD_EXP 25
8938: PUSH
8939: LD_INT 2
8941: EQUAL
8942: IFFALSE 8963
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8944: LD_ADDR_VAR 0 7
8948: PUSH
8949: LD_INT 3
8951: PUSH
8952: LD_INT 4
8954: PUSH
8955: LD_INT 4
8957: PUSH
8958: EMPTY
8959: LIST
8960: LIST
8961: LIST
8962: ST_TO_ADDR
// if commander = 3 then
8963: LD_EXP 25
8967: PUSH
8968: LD_INT 3
8970: EQUAL
8971: IFFALSE 8992
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8973: LD_ADDR_VAR 0 7
8977: PUSH
8978: LD_INT 2
8980: PUSH
8981: LD_INT 5
8983: PUSH
8984: LD_INT 5
8986: PUSH
8987: EMPTY
8988: LIST
8989: LIST
8990: LIST
8991: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8992: LD_ADDR_VAR 0 8
8996: PUSH
8997: LD_INT 2
8999: PUSH
9000: LD_INT 2
9002: PUSH
9003: LD_INT 1
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: LIST
9010: ST_TO_ADDR
// if commander = 2 then
9011: LD_EXP 25
9015: PUSH
9016: LD_INT 2
9018: EQUAL
9019: IFFALSE 9040
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
9021: LD_ADDR_VAR 0 8
9025: PUSH
9026: LD_INT 1
9028: PUSH
9029: LD_INT 1
9031: PUSH
9032: LD_INT 3
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: LIST
9039: ST_TO_ADDR
// if commander = 3 then
9040: LD_EXP 25
9044: PUSH
9045: LD_INT 3
9047: EQUAL
9048: IFFALSE 9069
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9050: LD_ADDR_VAR 0 8
9054: PUSH
9055: LD_INT 3
9057: PUSH
9058: LD_INT 3
9060: PUSH
9061: LD_INT 1
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: LIST
9068: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9069: LD_ADDR_VAR 0 9
9073: PUSH
9074: LD_INT 5
9076: PUSH
9077: LD_INT 3
9079: PUSH
9080: LD_INT 4
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: ST_TO_ADDR
// if commander = 2 then
9088: LD_EXP 25
9092: PUSH
9093: LD_INT 2
9095: EQUAL
9096: IFFALSE 9117
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9098: LD_ADDR_VAR 0 9
9102: PUSH
9103: LD_INT 7
9105: PUSH
9106: LD_INT 5
9108: PUSH
9109: LD_INT 6
9111: PUSH
9112: EMPTY
9113: LIST
9114: LIST
9115: LIST
9116: ST_TO_ADDR
// if commander = 3 then
9117: LD_EXP 25
9121: PUSH
9122: LD_INT 3
9124: EQUAL
9125: IFFALSE 9146
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9127: LD_ADDR_VAR 0 9
9131: PUSH
9132: LD_INT 9
9134: PUSH
9135: LD_INT 10
9137: PUSH
9138: LD_INT 7
9140: PUSH
9141: EMPTY
9142: LIST
9143: LIST
9144: LIST
9145: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9146: LD_ADDR_VAR 0 5
9150: PUSH
9151: LD_INT 5
9153: PUSH
9154: LD_INT 5
9156: PUSH
9157: LD_INT 4
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: LIST
9164: PUSH
9165: LD_OWVAR 67
9169: ARRAY
9170: ST_TO_ADDR
// if commander = 2 then
9171: LD_EXP 25
9175: PUSH
9176: LD_INT 2
9178: EQUAL
9179: IFFALSE 9195
// tanks := tanks + 3 ;
9181: LD_ADDR_VAR 0 5
9185: PUSH
9186: LD_VAR 0 5
9190: PUSH
9191: LD_INT 3
9193: PLUS
9194: ST_TO_ADDR
// for i = 1 to tanks do
9195: LD_ADDR_VAR 0 2
9199: PUSH
9200: DOUBLE
9201: LD_INT 1
9203: DEC
9204: ST_TO_ADDR
9205: LD_VAR 0 5
9209: PUSH
9210: FOR_TO
9211: IFFALSE 9321
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9213: LD_VAR 0 7
9217: PUSH
9218: LD_VAR 0 2
9222: PUSH
9223: LD_INT 3
9225: MOD
9226: PUSH
9227: LD_INT 1
9229: PLUS
9230: ARRAY
9231: PPUSH
9232: LD_VAR 0 8
9236: PUSH
9237: LD_INT 1
9239: PPUSH
9240: LD_INT 3
9242: PPUSH
9243: CALL_OW 12
9247: ARRAY
9248: PPUSH
9249: LD_INT 1
9251: PPUSH
9252: LD_VAR 0 9
9256: PUSH
9257: LD_VAR 0 2
9261: PUSH
9262: LD_INT 3
9264: MOD
9265: PUSH
9266: LD_INT 1
9268: PLUS
9269: ARRAY
9270: PPUSH
9271: LD_INT 60
9273: PPUSH
9274: LD_INT 70
9276: PPUSH
9277: CALL_OW 12
9281: PPUSH
9282: CALL 24903 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9286: LD_ADDR_VAR 0 1
9290: PUSH
9291: LD_VAR 0 1
9295: PPUSH
9296: LD_INT 1
9298: PPUSH
9299: LD_VAR 0 1
9303: PUSH
9304: LD_INT 1
9306: ARRAY
9307: PUSH
9308: CALL_OW 45
9312: ADD
9313: PPUSH
9314: CALL_OW 1
9318: ST_TO_ADDR
// end ;
9319: GO 9210
9321: POP
9322: POP
// cl := 1 ;
9323: LD_ADDR_VAR 0 6
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
// for i = 1 to 10 do
9331: LD_ADDR_VAR 0 2
9335: PUSH
9336: DOUBLE
9337: LD_INT 1
9339: DEC
9340: ST_TO_ADDR
9341: LD_INT 10
9343: PUSH
9344: FOR_TO
9345: IFFALSE 9460
// begin if i mod 4 = 0 then
9347: LD_VAR 0 2
9351: PUSH
9352: LD_INT 4
9354: MOD
9355: PUSH
9356: LD_INT 0
9358: EQUAL
9359: IFFALSE 9375
// cl := cl + 1 ;
9361: LD_ADDR_VAR 0 6
9365: PUSH
9366: LD_VAR 0 6
9370: PUSH
9371: LD_INT 1
9373: PLUS
9374: ST_TO_ADDR
// if cl = 2 then
9375: LD_VAR 0 6
9379: PUSH
9380: LD_INT 2
9382: EQUAL
9383: IFFALSE 9393
// cl := 3 ;
9385: LD_ADDR_VAR 0 6
9389: PUSH
9390: LD_INT 3
9392: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9393: LD_INT 0
9395: PPUSH
9396: LD_VAR 0 6
9400: PPUSH
9401: LD_INT 6
9403: PUSH
9404: LD_INT 6
9406: PUSH
9407: LD_INT 5
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: LIST
9414: PUSH
9415: LD_OWVAR 67
9419: ARRAY
9420: PPUSH
9421: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9425: LD_ADDR_VAR 0 1
9429: PUSH
9430: LD_VAR 0 1
9434: PPUSH
9435: LD_INT 2
9437: PPUSH
9438: LD_VAR 0 1
9442: PUSH
9443: LD_INT 2
9445: ARRAY
9446: PUSH
9447: CALL_OW 44
9451: ADD
9452: PPUSH
9453: CALL_OW 1
9457: ST_TO_ADDR
// end ;
9458: GO 9344
9460: POP
9461: POP
// if commander = 1 then
9462: LD_EXP 25
9466: PUSH
9467: LD_INT 1
9469: EQUAL
9470: IFFALSE 9538
// for i = 1 to 4 do
9472: LD_ADDR_VAR 0 2
9476: PUSH
9477: DOUBLE
9478: LD_INT 1
9480: DEC
9481: ST_TO_ADDR
9482: LD_INT 4
9484: PUSH
9485: FOR_TO
9486: IFFALSE 9536
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9488: LD_INT 0
9490: PPUSH
9491: LD_INT 1
9493: PPUSH
9494: LD_INT 8
9496: PPUSH
9497: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9501: LD_ADDR_VAR 0 1
9505: PUSH
9506: LD_VAR 0 1
9510: PPUSH
9511: LD_INT 2
9513: PPUSH
9514: LD_VAR 0 1
9518: PUSH
9519: LD_INT 2
9521: ARRAY
9522: PUSH
9523: CALL_OW 44
9527: ADD
9528: PPUSH
9529: CALL_OW 1
9533: ST_TO_ADDR
// end ;
9534: GO 9485
9536: POP
9537: POP
// techs := [ ] ;
9538: LD_ADDR_VAR 0 4
9542: PUSH
9543: EMPTY
9544: ST_TO_ADDR
// if commander = 1 then
9545: LD_EXP 25
9549: PUSH
9550: LD_INT 1
9552: EQUAL
9553: IFFALSE 9578
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9555: LD_ADDR_VAR 0 4
9559: PUSH
9560: LD_INT 51
9562: PUSH
9563: LD_INT 52
9565: PUSH
9566: LD_INT 53
9568: PUSH
9569: LD_INT 12
9571: PUSH
9572: EMPTY
9573: LIST
9574: LIST
9575: LIST
9576: LIST
9577: ST_TO_ADDR
// if commander = 2 then
9578: LD_EXP 25
9582: PUSH
9583: LD_INT 2
9585: EQUAL
9586: IFFALSE 9623
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9588: LD_ADDR_VAR 0 4
9592: PUSH
9593: LD_INT 48
9595: PUSH
9596: LD_INT 47
9598: PUSH
9599: LD_INT 46
9601: PUSH
9602: LD_INT 45
9604: PUSH
9605: LD_INT 35
9607: PUSH
9608: LD_INT 60
9610: PUSH
9611: LD_INT 6
9613: PUSH
9614: EMPTY
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: LIST
9622: ST_TO_ADDR
// if commander = 3 then
9623: LD_EXP 25
9627: PUSH
9628: LD_INT 3
9630: EQUAL
9631: IFFALSE 9680
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9633: LD_ADDR_VAR 0 4
9637: PUSH
9638: LD_INT 27
9640: PUSH
9641: LD_INT 36
9643: PUSH
9644: LD_INT 32
9646: PUSH
9647: LD_INT 57
9649: PUSH
9650: LD_INT 58
9652: PUSH
9653: LD_INT 47
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: LD_INT 51
9661: PUSH
9662: LD_INT 69
9664: PUSH
9665: LD_INT 39
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: LIST
9678: LIST
9679: ST_TO_ADDR
// if techs then
9680: LD_VAR 0 4
9684: IFFALSE 9718
// for i in techs do
9686: LD_ADDR_VAR 0 2
9690: PUSH
9691: LD_VAR 0 4
9695: PUSH
9696: FOR_IN
9697: IFFALSE 9716
// SetTech ( i , 1 , state_researched ) ;
9699: LD_VAR 0 2
9703: PPUSH
9704: LD_INT 1
9706: PPUSH
9707: LD_INT 2
9709: PPUSH
9710: CALL_OW 322
9714: GO 9696
9716: POP
9717: POP
// hc_gallery := skirmish ;
9718: LD_ADDR_OWVAR 33
9722: PUSH
9723: LD_STRING skirmish
9725: ST_TO_ADDR
// hc_face_number := commander ;
9726: LD_ADDR_OWVAR 34
9730: PUSH
9731: LD_EXP 25
9735: ST_TO_ADDR
// hc_importance := 100 ;
9736: LD_ADDR_OWVAR 32
9740: PUSH
9741: LD_INT 100
9743: ST_TO_ADDR
// case commander of 1 :
9744: LD_EXP 25
9748: PUSH
9749: LD_INT 1
9751: DOUBLE
9752: EQUAL
9753: IFTRUE 9757
9755: GO 9781
9757: POP
// begin hc_name := Jeff Ironside ;
9758: LD_ADDR_OWVAR 26
9762: PUSH
9763: LD_STRING Jeff Ironside
9765: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9766: LD_INT 1
9768: PPUSH
9769: LD_INT 1
9771: PPUSH
9772: LD_INT 7
9774: PPUSH
9775: CALL_OW 380
// end ; 2 :
9779: GO 9846
9781: LD_INT 2
9783: DOUBLE
9784: EQUAL
9785: IFTRUE 9789
9787: GO 9813
9789: POP
// begin hc_name := Paul Johnson ;
9790: LD_ADDR_OWVAR 26
9794: PUSH
9795: LD_STRING Paul Johnson
9797: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9798: LD_INT 1
9800: PPUSH
9801: LD_INT 3
9803: PPUSH
9804: LD_INT 7
9806: PPUSH
9807: CALL_OW 380
// end ; 3 :
9811: GO 9846
9813: LD_INT 3
9815: DOUBLE
9816: EQUAL
9817: IFTRUE 9821
9819: GO 9845
9821: POP
// begin hc_name := Lisa Stuart ;
9822: LD_ADDR_OWVAR 26
9826: PUSH
9827: LD_STRING Lisa Stuart
9829: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9830: LD_INT 2
9832: PPUSH
9833: LD_INT 4
9835: PPUSH
9836: LD_INT 7
9838: PPUSH
9839: CALL_OW 380
// end ; end ;
9843: GO 9846
9845: POP
// playerCommander := CreateHuman ;
9846: LD_ADDR_EXP 9
9850: PUSH
9851: CALL_OW 44
9855: ST_TO_ADDR
// hc_importance := 0 ;
9856: LD_ADDR_OWVAR 32
9860: PUSH
9861: LD_INT 0
9863: ST_TO_ADDR
// hc_gallery :=  ;
9864: LD_ADDR_OWVAR 33
9868: PUSH
9869: LD_STRING 
9871: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9872: LD_ADDR_VAR 0 1
9876: PUSH
9877: LD_VAR 0 1
9881: PPUSH
9882: LD_INT 2
9884: PPUSH
9885: LD_VAR 0 1
9889: PUSH
9890: LD_INT 2
9892: ARRAY
9893: PUSH
9894: LD_EXP 9
9898: ADD
9899: PPUSH
9900: CALL_OW 1
9904: ST_TO_ADDR
// end ;
9905: LD_VAR 0 1
9909: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9910: LD_INT 0
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
9916: PPUSH
9917: PPUSH
// uc_side := 1 ;
9918: LD_ADDR_OWVAR 20
9922: PUSH
9923: LD_INT 1
9925: ST_TO_ADDR
// uc_nation := 1 ;
9926: LD_ADDR_OWVAR 21
9930: PUSH
9931: LD_INT 1
9933: ST_TO_ADDR
// InitHc ;
9934: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9938: LD_ADDR_VAR 0 3
9942: PUSH
9943: LD_INT 3
9945: PUSH
9946: LD_INT 3
9948: PUSH
9949: LD_INT 2
9951: PUSH
9952: EMPTY
9953: LIST
9954: LIST
9955: LIST
9956: PUSH
9957: LD_OWVAR 67
9961: ARRAY
9962: ST_TO_ADDR
// for i = 1 to peopleAmount do
9963: LD_ADDR_VAR 0 2
9967: PUSH
9968: DOUBLE
9969: LD_INT 1
9971: DEC
9972: ST_TO_ADDR
9973: LD_VAR 0 3
9977: PUSH
9978: FOR_TO
9979: IFFALSE 10028
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9981: LD_INT 0
9983: PPUSH
9984: LD_INT 2
9986: PPUSH
9987: LD_INT 7
9989: PUSH
9990: LD_INT 6
9992: PUSH
9993: LD_INT 5
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: LIST
10000: PUSH
10001: LD_OWVAR 67
10005: ARRAY
10006: PPUSH
10007: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
10011: CALL_OW 44
10015: PPUSH
10016: LD_INT 19
10018: PPUSH
10019: LD_INT 0
10021: PPUSH
10022: CALL 56204 0 3
// end ;
10026: GO 9978
10028: POP
10029: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
10030: LD_INT 2
10032: PPUSH
10033: LD_INT 1
10035: PPUSH
10036: LD_INT 3
10038: PPUSH
10039: LD_INT 13
10041: PPUSH
10042: LD_INT 58
10044: PPUSH
10045: CALL 24903 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10049: CALL_OW 45
10053: PPUSH
10054: LD_INT 19
10056: PPUSH
10057: LD_INT 0
10059: PPUSH
10060: CALL 56204 0 3
// if commander = 1 then
10064: LD_EXP 25
10068: PUSH
10069: LD_INT 1
10071: EQUAL
10072: IFFALSE 10083
// wait ( 6 6$00 ) else
10074: LD_INT 12600
10076: PPUSH
10077: CALL_OW 67
10081: GO 10090
// wait ( 8 8$00 ) ;
10083: LD_INT 16800
10085: PPUSH
10086: CALL_OW 67
// uc_side := 1 ;
10090: LD_ADDR_OWVAR 20
10094: PUSH
10095: LD_INT 1
10097: ST_TO_ADDR
// uc_nation := 1 ;
10098: LD_ADDR_OWVAR 21
10102: PUSH
10103: LD_INT 1
10105: ST_TO_ADDR
// InitVc ;
10106: CALL_OW 20
// InitHc ;
10110: CALL_OW 19
// for i = 1 to 5 do
10114: LD_ADDR_VAR 0 2
10118: PUSH
10119: DOUBLE
10120: LD_INT 1
10122: DEC
10123: ST_TO_ADDR
10124: LD_INT 5
10126: PUSH
10127: FOR_TO
10128: IFFALSE 10372
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10130: LD_INT 4
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: LD_INT 1
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: LIST
10143: PUSH
10144: LD_VAR 0 2
10148: PUSH
10149: LD_INT 3
10151: MOD
10152: PUSH
10153: LD_INT 1
10155: PLUS
10156: ARRAY
10157: PPUSH
10158: LD_INT 1
10160: PPUSH
10161: LD_INT 1
10163: PUSH
10164: LD_INT 3
10166: PUSH
10167: LD_INT 3
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: LIST
10174: PUSH
10175: LD_VAR 0 2
10179: PUSH
10180: LD_INT 3
10182: MOD
10183: PUSH
10184: LD_INT 1
10186: PLUS
10187: ARRAY
10188: PPUSH
10189: LD_INT 6
10191: PUSH
10192: LD_INT 12
10194: PUSH
10195: LD_INT 11
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: LIST
10202: PUSH
10203: LD_VAR 0 2
10207: PUSH
10208: LD_INT 3
10210: MOD
10211: PUSH
10212: LD_INT 1
10214: PLUS
10215: ARRAY
10216: PPUSH
10217: LD_INT 40
10219: PPUSH
10220: LD_INT 55
10222: PPUSH
10223: CALL_OW 12
10227: PPUSH
10228: CALL 24903 0 5
// veh := CreateVehicle ;
10232: LD_ADDR_VAR 0 6
10236: PUSH
10237: CALL_OW 45
10241: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10242: LD_VAR 0 6
10246: PPUSH
10247: LD_INT 19
10249: PPUSH
10250: LD_INT 0
10252: PPUSH
10253: CALL 56204 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10257: LD_VAR 0 6
10261: PPUSH
10262: CALL_OW 264
10266: PUSH
10267: LD_INT 12
10269: EQUAL
10270: IFFALSE 10302
// begin AddCargo ( veh , mat_cans , 70 ) ;
10272: LD_VAR 0 6
10276: PPUSH
10277: LD_INT 1
10279: PPUSH
10280: LD_INT 70
10282: PPUSH
10283: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10287: LD_VAR 0 6
10291: PPUSH
10292: LD_INT 3
10294: PPUSH
10295: LD_INT 30
10297: PPUSH
10298: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10302: LD_VAR 0 6
10306: PPUSH
10307: CALL_OW 263
10311: PUSH
10312: LD_INT 1
10314: EQUAL
10315: IFFALSE 10370
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10317: LD_INT 1
10319: PPUSH
10320: LD_INT 3
10322: PPUSH
10323: LD_INT 6
10325: PPUSH
10326: CALL_OW 380
// un := CreateHuman ;
10330: LD_ADDR_VAR 0 5
10334: PUSH
10335: CALL_OW 44
10339: ST_TO_ADDR
// tmp := tmp ^ un ;
10340: LD_ADDR_VAR 0 4
10344: PUSH
10345: LD_VAR 0 4
10349: PUSH
10350: LD_VAR 0 5
10354: ADD
10355: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10356: LD_VAR 0 5
10360: PPUSH
10361: LD_VAR 0 6
10365: PPUSH
10366: CALL_OW 52
// end ; end ;
10370: GO 10127
10372: POP
10373: POP
// if tmp then
10374: LD_VAR 0 4
10378: IFFALSE 10442
// begin CenterNowOnUnits ( tmp ) ;
10380: LD_VAR 0 4
10384: PPUSH
10385: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10389: LD_VAR 0 4
10393: PUSH
10394: LD_INT 1
10396: ARRAY
10397: PPUSH
10398: LD_STRING DAR-1
10400: PPUSH
10401: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10405: LD_EXP 9
10409: PPUSH
10410: LD_STRING D
10412: PUSH
10413: LD_STRING I
10415: PUSH
10416: LD_STRING J
10418: PUSH
10419: LD_STRING S
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: LIST
10426: PUSH
10427: LD_EXP 25
10431: ARRAY
10432: STR
10433: PUSH
10434: LD_STRING -1-DAR
10436: STR
10437: PPUSH
10438: CALL_OW 88
// end ; if not reinforceAllowed then
10442: LD_EXP 24
10446: NOT
10447: IFFALSE 10451
// exit ;
10449: GO 10605
// wait ( 25 25$00 ) ;
10451: LD_INT 52500
10453: PPUSH
10454: CALL_OW 67
// uc_side := 1 ;
10458: LD_ADDR_OWVAR 20
10462: PUSH
10463: LD_INT 1
10465: ST_TO_ADDR
// uc_nation := 1 ;
10466: LD_ADDR_OWVAR 21
10470: PUSH
10471: LD_INT 1
10473: ST_TO_ADDR
// InitVc ;
10474: CALL_OW 20
// InitHc ;
10478: CALL_OW 19
// for i = 1 to 4 do
10482: LD_ADDR_VAR 0 2
10486: PUSH
10487: DOUBLE
10488: LD_INT 1
10490: DEC
10491: ST_TO_ADDR
10492: LD_INT 4
10494: PUSH
10495: FOR_TO
10496: IFFALSE 10603
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10498: LD_INT 5
10500: PPUSH
10501: LD_INT 3
10503: PPUSH
10504: LD_INT 1
10506: PPUSH
10507: LD_INT 6
10509: PPUSH
10510: LD_INT 1
10512: PPUSH
10513: CALL 24903 0 5
// veh := CreateVehicle ;
10517: LD_ADDR_VAR 0 6
10521: PUSH
10522: CALL_OW 45
10526: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10527: LD_VAR 0 6
10531: PPUSH
10532: LD_INT 19
10534: PPUSH
10535: LD_INT 0
10537: PPUSH
10538: CALL 56204 0 3
// if GetControl ( veh ) = control_manual then
10542: LD_VAR 0 6
10546: PPUSH
10547: CALL_OW 263
10551: PUSH
10552: LD_INT 1
10554: EQUAL
10555: IFFALSE 10601
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10557: LD_INT 0
10559: PPUSH
10560: LD_INT 3
10562: PPUSH
10563: LD_INT 7
10565: PUSH
10566: LD_INT 6
10568: PUSH
10569: LD_INT 5
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: LIST
10576: PUSH
10577: LD_OWVAR 67
10581: ARRAY
10582: PPUSH
10583: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10587: CALL_OW 44
10591: PPUSH
10592: LD_VAR 0 6
10596: PPUSH
10597: CALL_OW 52
// end ; end ;
10601: GO 10495
10603: POP
10604: POP
// end ;
10605: LD_VAR 0 1
10609: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10610: LD_INT 0
10612: PPUSH
10613: PPUSH
10614: PPUSH
10615: PPUSH
10616: PPUSH
// uc_side := 8 ;
10617: LD_ADDR_OWVAR 20
10621: PUSH
10622: LD_INT 8
10624: ST_TO_ADDR
// uc_nation := nation_arabian ;
10625: LD_ADDR_OWVAR 21
10629: PUSH
10630: LD_INT 2
10632: ST_TO_ADDR
// for i = 1 to 2 do
10633: LD_ADDR_VAR 0 2
10637: PUSH
10638: DOUBLE
10639: LD_INT 1
10641: DEC
10642: ST_TO_ADDR
10643: LD_INT 2
10645: PUSH
10646: FOR_TO
10647: IFFALSE 10727
// for j = 1 to 4 do
10649: LD_ADDR_VAR 0 4
10653: PUSH
10654: DOUBLE
10655: LD_INT 1
10657: DEC
10658: ST_TO_ADDR
10659: LD_INT 4
10661: PUSH
10662: FOR_TO
10663: IFFALSE 10723
// begin PrepareHuman ( false , j , 8 ) ;
10665: LD_INT 0
10667: PPUSH
10668: LD_VAR 0 4
10672: PPUSH
10673: LD_INT 8
10675: PPUSH
10676: CALL_OW 380
// un := CreateHuman ;
10680: LD_ADDR_VAR 0 3
10684: PUSH
10685: CALL_OW 44
10689: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10690: LD_VAR 0 3
10694: PPUSH
10695: LD_INT 23
10697: PPUSH
10698: LD_INT 0
10700: PPUSH
10701: CALL_OW 49
// tmp := tmp union un ;
10705: LD_ADDR_VAR 0 5
10709: PUSH
10710: LD_VAR 0 5
10714: PUSH
10715: LD_VAR 0 3
10719: UNION
10720: ST_TO_ADDR
// end ;
10721: GO 10662
10723: POP
10724: POP
10725: GO 10646
10727: POP
10728: POP
// for i in tmp do
10729: LD_ADDR_VAR 0 2
10733: PUSH
10734: LD_VAR 0 5
10738: PUSH
10739: FOR_IN
10740: IFFALSE 10759
// ComMoveXY ( i , 150 , 136 ) ;
10742: LD_VAR 0 2
10746: PPUSH
10747: LD_INT 150
10749: PPUSH
10750: LD_INT 136
10752: PPUSH
10753: CALL_OW 111
10757: GO 10739
10759: POP
10760: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10761: LD_ADDR_EXP 49
10765: PUSH
10766: LD_EXP 49
10770: PPUSH
10771: LD_EXP 6
10775: PPUSH
10776: LD_EXP 49
10780: PUSH
10781: LD_EXP 6
10785: ARRAY
10786: PUSH
10787: LD_VAR 0 5
10791: UNION
10792: PPUSH
10793: CALL_OW 1
10797: ST_TO_ADDR
// end ;
10798: LD_VAR 0 1
10802: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10803: LD_OWVAR 67
10807: PUSH
10808: LD_INT 1
10810: GREATER
10811: PUSH
10812: LD_INT 31
10814: PPUSH
10815: LD_INT 3
10817: PPUSH
10818: CALL_OW 321
10822: PUSH
10823: LD_INT 2
10825: EQUAL
10826: AND
10827: IFFALSE 11044
10829: GO 10831
10831: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10832: LD_EXP 7
10836: PPUSH
10837: LD_INT 33
10839: PUSH
10840: LD_INT 101
10842: PUSH
10843: LD_INT 159
10845: PUSH
10846: LD_INT 5
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: PUSH
10855: LD_INT 33
10857: PUSH
10858: LD_INT 105
10860: PUSH
10861: LD_INT 158
10863: PUSH
10864: LD_INT 5
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: LIST
10871: LIST
10872: PUSH
10873: LD_INT 33
10875: PUSH
10876: LD_INT 96
10878: PUSH
10879: LD_INT 136
10881: PUSH
10882: LD_INT 5
10884: PUSH
10885: EMPTY
10886: LIST
10887: LIST
10888: LIST
10889: LIST
10890: PUSH
10891: LD_INT 33
10893: PUSH
10894: LD_INT 94
10896: PUSH
10897: LD_INT 133
10899: PUSH
10900: LD_INT 4
10902: PUSH
10903: EMPTY
10904: LIST
10905: LIST
10906: LIST
10907: LIST
10908: PUSH
10909: LD_INT 33
10911: PUSH
10912: LD_INT 84
10914: PUSH
10915: LD_INT 102
10917: PUSH
10918: LD_INT 4
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: PUSH
10927: EMPTY
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: LIST
10933: PPUSH
10934: CALL 85374 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10938: LD_EXP 8
10942: PPUSH
10943: LD_INT 33
10945: PUSH
10946: LD_INT 50
10948: PUSH
10949: LD_INT 17
10951: PUSH
10952: LD_INT 4
10954: PUSH
10955: EMPTY
10956: LIST
10957: LIST
10958: LIST
10959: LIST
10960: PUSH
10961: LD_INT 33
10963: PUSH
10964: LD_INT 52
10966: PUSH
10967: LD_INT 20
10969: PUSH
10970: LD_INT 4
10972: PUSH
10973: EMPTY
10974: LIST
10975: LIST
10976: LIST
10977: LIST
10978: PUSH
10979: LD_INT 33
10981: PUSH
10982: LD_INT 53
10984: PUSH
10985: LD_INT 23
10987: PUSH
10988: LD_INT 4
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: LIST
10995: LIST
10996: PUSH
10997: LD_INT 33
10999: PUSH
11000: LD_INT 45
11002: PUSH
11003: LD_INT 32
11005: PUSH
11006: LD_INT 4
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: LIST
11013: LIST
11014: PUSH
11015: LD_INT 33
11017: PUSH
11018: LD_INT 45
11020: PUSH
11021: LD_INT 39
11023: PUSH
11024: LD_INT 4
11026: PUSH
11027: EMPTY
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: PUSH
11033: EMPTY
11034: LIST
11035: LIST
11036: LIST
11037: LIST
11038: LIST
11039: PPUSH
11040: CALL 85374 0 2
// end ;
11044: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11045: LD_INT 3
11047: PUSH
11048: LD_INT 22
11050: PUSH
11051: LD_OWVAR 2
11055: PUSH
11056: EMPTY
11057: LIST
11058: LIST
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: LD_INT 33
11066: PUSH
11067: LD_INT 2
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 50
11076: PUSH
11077: EMPTY
11078: LIST
11079: PUSH
11080: LD_INT 3
11082: PUSH
11083: LD_INT 61
11085: PUSH
11086: EMPTY
11087: LIST
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PPUSH
11099: CALL_OW 69
11103: IFFALSE 11203
11105: GO 11107
11107: DISABLE
11108: LD_INT 0
11110: PPUSH
11111: PPUSH
// begin enable ;
11112: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11113: LD_ADDR_VAR 0 2
11117: PUSH
11118: LD_INT 3
11120: PUSH
11121: LD_INT 22
11123: PUSH
11124: LD_OWVAR 2
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PUSH
11137: LD_INT 33
11139: PUSH
11140: LD_INT 2
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: PUSH
11147: LD_INT 50
11149: PUSH
11150: EMPTY
11151: LIST
11152: PUSH
11153: LD_INT 3
11155: PUSH
11156: LD_INT 61
11158: PUSH
11159: EMPTY
11160: LIST
11161: PUSH
11162: EMPTY
11163: LIST
11164: LIST
11165: PUSH
11166: EMPTY
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: PPUSH
11172: CALL_OW 69
11176: ST_TO_ADDR
// for i in tmp do
11177: LD_ADDR_VAR 0 1
11181: PUSH
11182: LD_VAR 0 2
11186: PUSH
11187: FOR_IN
11188: IFFALSE 11201
// Connect ( i ) ;
11190: LD_VAR 0 1
11194: PPUSH
11195: CALL 27996 0 1
11199: GO 11187
11201: POP
11202: POP
// end ; end_of_file
11203: PPOPN 2
11205: END
// export function Action ; var i , tmp ; begin
11206: LD_INT 0
11208: PPUSH
11209: PPUSH
11210: PPUSH
// InGameOn ;
11211: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11215: LD_INT 225
11217: PPUSH
11218: LD_INT 217
11220: PPUSH
11221: CALL_OW 86
// for i in playerForces [ 2 ] do
11225: LD_ADDR_VAR 0 2
11229: PUSH
11230: LD_EXP 10
11234: PUSH
11235: LD_INT 2
11237: ARRAY
11238: PUSH
11239: FOR_IN
11240: IFFALSE 11373
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11242: LD_EXP 10
11246: PUSH
11247: LD_INT 1
11249: ARRAY
11250: PUSH
11251: LD_VAR 0 2
11255: PPUSH
11256: CALL_OW 257
11260: PUSH
11261: LD_INT 3
11263: PUSH
11264: LD_INT 4
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: IN
11271: AND
11272: IFFALSE 11356
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11274: LD_EXP 10
11278: PUSH
11279: LD_INT 1
11281: ARRAY
11282: PUSH
11283: LD_INT 1
11285: ARRAY
11286: PPUSH
11287: LD_INT 19
11289: PPUSH
11290: LD_INT 0
11292: PPUSH
11293: CALL 56204 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11297: LD_VAR 0 2
11301: PPUSH
11302: LD_EXP 10
11306: PUSH
11307: LD_INT 1
11309: ARRAY
11310: PUSH
11311: LD_INT 1
11313: ARRAY
11314: PPUSH
11315: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11319: LD_ADDR_EXP 10
11323: PUSH
11324: LD_EXP 10
11328: PPUSH
11329: LD_INT 1
11331: PPUSH
11332: LD_EXP 10
11336: PUSH
11337: LD_INT 1
11339: ARRAY
11340: PPUSH
11341: LD_INT 1
11343: PPUSH
11344: CALL_OW 3
11348: PPUSH
11349: CALL_OW 1
11353: ST_TO_ADDR
// end else
11354: GO 11371
// PlaceUnitInArea ( i , startArea , false ) ;
11356: LD_VAR 0 2
11360: PPUSH
11361: LD_INT 19
11363: PPUSH
11364: LD_INT 0
11366: PPUSH
11367: CALL 56204 0 3
// end ;
11371: GO 11239
11373: POP
11374: POP
// wait ( 0 0$2 ) ;
11375: LD_INT 70
11377: PPUSH
11378: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11382: LD_EXP 9
11386: PPUSH
11387: LD_STRING D
11389: PUSH
11390: LD_STRING I
11392: PUSH
11393: LD_STRING J
11395: PUSH
11396: LD_STRING S
11398: PUSH
11399: EMPTY
11400: LIST
11401: LIST
11402: LIST
11403: PUSH
11404: LD_EXP 25
11408: ARRAY
11409: STR
11410: PUSH
11411: LD_STRING -1
11413: STR
11414: PPUSH
11415: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11419: LD_EXP 12
11423: PPUSH
11424: LD_STRING DP-1
11426: PPUSH
11427: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11431: LD_EXP 12
11435: PPUSH
11436: LD_STRING DP-2
11438: PPUSH
11439: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11443: LD_EXP 9
11447: PPUSH
11448: LD_STRING D
11450: PUSH
11451: LD_STRING I
11453: PUSH
11454: LD_STRING J
11456: PUSH
11457: LD_STRING S
11459: PUSH
11460: EMPTY
11461: LIST
11462: LIST
11463: LIST
11464: PUSH
11465: LD_EXP 25
11469: ARRAY
11470: STR
11471: PUSH
11472: LD_STRING -2
11474: STR
11475: PPUSH
11476: CALL_OW 88
// InGameOff ;
11480: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11484: LD_STRING O1
11486: PPUSH
11487: CALL_OW 337
// game := true ;
11491: LD_ADDR_EXP 3
11495: PUSH
11496: LD_INT 1
11498: ST_TO_ADDR
// SaveForQuickRestart ;
11499: CALL_OW 22
// wait ( 0 0$5 ) ;
11503: LD_INT 175
11505: PPUSH
11506: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11510: LD_EXP 9
11514: PPUSH
11515: LD_STRING D
11517: PUSH
11518: LD_STRING I
11520: PUSH
11521: LD_STRING J
11523: PUSH
11524: LD_STRING S
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: LIST
11531: PUSH
11532: LD_EXP 25
11536: ARRAY
11537: STR
11538: PUSH
11539: LD_STRING -3
11541: STR
11542: PPUSH
11543: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11547: LD_INT 35
11549: PPUSH
11550: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11554: LD_EXP 15
11558: PUSH
11559: LD_INT 1
11561: ARRAY
11562: PUSH
11563: LD_EXP 15
11567: PUSH
11568: LD_INT 2
11570: ARRAY
11571: GREATEREQUAL
11572: IFFALSE 11547
// outpostEscape := true ;
11574: LD_ADDR_EXP 27
11578: PUSH
11579: LD_INT 1
11581: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11582: LD_ADDR_VAR 0 3
11586: PUSH
11587: LD_EXP 14
11591: PPUSH
11592: LD_INT 26
11594: PUSH
11595: LD_INT 1
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PPUSH
11602: CALL_OW 72
11606: ST_TO_ADDR
// if tmp then
11607: LD_VAR 0 3
11611: IFFALSE 11629
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11613: LD_VAR 0 3
11617: PUSH
11618: LD_INT 1
11620: ARRAY
11621: PPUSH
11622: LD_STRING DR-1-Escape
11624: PPUSH
11625: CALL_OW 88
// wait ( 0 0$1 ) ;
11629: LD_INT 35
11631: PPUSH
11632: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11636: LD_EXP 9
11640: PPUSH
11641: LD_STRING D
11643: PUSH
11644: LD_STRING I
11646: PUSH
11647: LD_STRING J
11649: PUSH
11650: LD_STRING S
11652: PUSH
11653: EMPTY
11654: LIST
11655: LIST
11656: LIST
11657: PUSH
11658: LD_EXP 25
11662: ARRAY
11663: STR
11664: PUSH
11665: LD_STRING -1-Escape
11667: STR
11668: PPUSH
11669: CALL_OW 88
// for i in ruOutpost do
11673: LD_ADDR_VAR 0 2
11677: PUSH
11678: LD_EXP 14
11682: PUSH
11683: FOR_IN
11684: IFFALSE 11738
// begin if IsInUnit ( i ) then
11686: LD_VAR 0 2
11690: PPUSH
11691: CALL_OW 310
11695: IFFALSE 11706
// ComExitBuilding ( i ) ;
11697: LD_VAR 0 2
11701: PPUSH
11702: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11706: LD_VAR 0 2
11710: PPUSH
11711: LD_INT 179
11713: PPUSH
11714: LD_INT 102
11716: PPUSH
11717: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11721: LD_VAR 0 2
11725: PPUSH
11726: LD_INT 28
11728: PPUSH
11729: LD_INT 20
11731: PPUSH
11732: CALL_OW 171
// end ;
11736: GO 11683
11738: POP
11739: POP
// tmp := [ ] ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: EMPTY
11746: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11747: LD_INT 35
11749: PPUSH
11750: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11754: LD_ADDR_VAR 0 3
11758: PUSH
11759: LD_EXP 14
11763: PPUSH
11764: LD_INT 95
11766: PUSH
11767: LD_INT 11
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: PPUSH
11774: CALL_OW 72
11778: ST_TO_ADDR
// if tmp then
11779: LD_VAR 0 3
11783: IFFALSE 11862
// for i in tmp do
11785: LD_ADDR_VAR 0 2
11789: PUSH
11790: LD_VAR 0 3
11794: PUSH
11795: FOR_IN
11796: IFFALSE 11860
// begin ruOutpost := ruOutpost diff i ;
11798: LD_ADDR_EXP 14
11802: PUSH
11803: LD_EXP 14
11807: PUSH
11808: LD_VAR 0 2
11812: DIFF
11813: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11814: LD_ADDR_EXP 49
11818: PUSH
11819: LD_EXP 49
11823: PPUSH
11824: LD_EXP 8
11828: PUSH
11829: LD_EXP 49
11833: PUSH
11834: LD_EXP 8
11838: ARRAY
11839: PUSH
11840: LD_INT 1
11842: PLUS
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PPUSH
11848: LD_VAR 0 2
11852: PPUSH
11853: CALL 25025 0 3
11857: ST_TO_ADDR
// end ;
11858: GO 11795
11860: POP
11861: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11862: LD_EXP 14
11866: PPUSH
11867: LD_INT 21
11869: PUSH
11870: LD_INT 1
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PPUSH
11877: CALL_OW 72
11881: NOT
11882: IFFALSE 11747
// ruOutpost := [ ] ;
11884: LD_ADDR_EXP 14
11888: PUSH
11889: EMPTY
11890: ST_TO_ADDR
// end ;
11891: LD_VAR 0 1
11895: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11896: LD_EXP 27
11900: IFFALSE 12089
11902: GO 11904
11904: DISABLE
11905: LD_INT 0
11907: PPUSH
11908: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11909: LD_INT 875
11911: PPUSH
11912: LD_INT 1225
11914: PPUSH
11915: CALL_OW 12
11919: PPUSH
11920: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11924: LD_ADDR_VAR 0 2
11928: PUSH
11929: LD_INT 208
11931: PUSH
11932: LD_INT 166
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: PUSH
11939: LD_INT 218
11941: PUSH
11942: LD_INT 174
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: PUSH
11949: LD_INT 201
11951: PUSH
11952: LD_INT 173
11954: PUSH
11955: EMPTY
11956: LIST
11957: LIST
11958: PUSH
11959: LD_INT 189
11961: PUSH
11962: LD_INT 167
11964: PUSH
11965: EMPTY
11966: LIST
11967: LIST
11968: PUSH
11969: LD_INT 191
11971: PUSH
11972: LD_INT 160
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: PUSH
11979: LD_INT 209
11981: PUSH
11982: LD_INT 181
11984: PUSH
11985: EMPTY
11986: LIST
11987: LIST
11988: PUSH
11989: LD_INT 192
11991: PUSH
11992: LD_INT 162
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: LD_INT 197
12001: PUSH
12002: LD_INT 166
12004: PUSH
12005: EMPTY
12006: LIST
12007: LIST
12008: PUSH
12009: EMPTY
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: LIST
12017: LIST
12018: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
12019: LD_ADDR_VAR 0 1
12023: PUSH
12024: DOUBLE
12025: LD_INT 1
12027: DEC
12028: ST_TO_ADDR
12029: LD_INT 5
12031: PUSH
12032: LD_OWVAR 67
12036: PLUS
12037: PUSH
12038: FOR_TO
12039: IFFALSE 12087
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12041: LD_VAR 0 2
12045: PUSH
12046: LD_VAR 0 1
12050: ARRAY
12051: PUSH
12052: LD_INT 1
12054: ARRAY
12055: PPUSH
12056: LD_VAR 0 2
12060: PUSH
12061: LD_VAR 0 1
12065: ARRAY
12066: PUSH
12067: LD_INT 2
12069: ARRAY
12070: PPUSH
12071: LD_INT 1
12073: PPUSH
12074: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12078: LD_INT 28
12080: PPUSH
12081: CALL_OW 67
// end ;
12085: GO 12038
12087: POP
12088: POP
// end ;
12089: PPOPN 2
12091: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12092: LD_EXP 27
12096: NOT
12097: IFFALSE 12751
12099: GO 12101
12101: DISABLE
12102: LD_INT 0
12104: PPUSH
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
12109: PPUSH
12110: PPUSH
// begin enable ;
12111: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12112: LD_ADDR_VAR 0 1
12116: PUSH
12117: LD_EXP 14
12121: PPUSH
12122: LD_INT 22
12124: PUSH
12125: LD_INT 3
12127: PUSH
12128: EMPTY
12129: LIST
12130: LIST
12131: PUSH
12132: LD_INT 25
12134: PUSH
12135: LD_INT 1
12137: PUSH
12138: EMPTY
12139: LIST
12140: LIST
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: PPUSH
12146: CALL_OW 72
12150: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12151: LD_ADDR_VAR 0 2
12155: PUSH
12156: LD_EXP 14
12160: PPUSH
12161: LD_INT 22
12163: PUSH
12164: LD_INT 3
12166: PUSH
12167: EMPTY
12168: LIST
12169: LIST
12170: PUSH
12171: LD_INT 25
12173: PUSH
12174: LD_INT 2
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: PUSH
12181: EMPTY
12182: LIST
12183: LIST
12184: PPUSH
12185: CALL_OW 72
12189: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12190: LD_ADDR_VAR 0 3
12194: PUSH
12195: LD_EXP 14
12199: PPUSH
12200: LD_INT 22
12202: PUSH
12203: LD_INT 3
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: LD_INT 21
12212: PUSH
12213: LD_INT 3
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: LD_INT 3
12222: PUSH
12223: LD_INT 24
12225: PUSH
12226: LD_INT 1000
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: LIST
12241: PPUSH
12242: CALL_OW 72
12246: ST_TO_ADDR
// if engs and buildings then
12247: LD_VAR 0 2
12251: PUSH
12252: LD_VAR 0 3
12256: AND
12257: IFFALSE 12330
// begin for i in engs do
12259: LD_ADDR_VAR 0 5
12263: PUSH
12264: LD_VAR 0 2
12268: PUSH
12269: FOR_IN
12270: IFFALSE 12326
// if IsInUnit ( i ) then
12272: LD_VAR 0 5
12276: PPUSH
12277: CALL_OW 310
12281: IFFALSE 12294
// ComExitBuilding ( i ) else
12283: LD_VAR 0 5
12287: PPUSH
12288: CALL_OW 122
12292: GO 12324
// if not HasTask ( i ) then
12294: LD_VAR 0 5
12298: PPUSH
12299: CALL_OW 314
12303: NOT
12304: IFFALSE 12324
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12306: LD_VAR 0 5
12310: PPUSH
12311: LD_VAR 0 3
12315: PUSH
12316: LD_INT 1
12318: ARRAY
12319: PPUSH
12320: CALL_OW 130
12324: GO 12269
12326: POP
12327: POP
// end else
12328: GO 12433
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12330: LD_VAR 0 3
12334: NOT
12335: PUSH
12336: LD_EXP 14
12340: PPUSH
12341: LD_INT 30
12343: PUSH
12344: LD_INT 0
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PPUSH
12351: CALL_OW 72
12355: AND
12356: PUSH
12357: LD_VAR 0 2
12361: PPUSH
12362: LD_INT 3
12364: PUSH
12365: LD_INT 54
12367: PUSH
12368: EMPTY
12369: LIST
12370: PUSH
12371: EMPTY
12372: LIST
12373: LIST
12374: PPUSH
12375: CALL_OW 72
12379: AND
12380: IFFALSE 12433
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12382: LD_VAR 0 2
12386: PPUSH
12387: LD_INT 3
12389: PUSH
12390: LD_INT 54
12392: PUSH
12393: EMPTY
12394: LIST
12395: PUSH
12396: EMPTY
12397: LIST
12398: LIST
12399: PPUSH
12400: CALL_OW 72
12404: PPUSH
12405: LD_EXP 14
12409: PPUSH
12410: LD_INT 30
12412: PUSH
12413: LD_INT 0
12415: PUSH
12416: EMPTY
12417: LIST
12418: LIST
12419: PPUSH
12420: CALL_OW 72
12424: PUSH
12425: LD_INT 1
12427: ARRAY
12428: PPUSH
12429: CALL_OW 120
// if not tmp then
12433: LD_VAR 0 1
12437: NOT
12438: IFFALSE 12442
// exit ;
12440: GO 12751
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12442: LD_INT 26
12444: PPUSH
12445: LD_INT 81
12447: PUSH
12448: LD_INT 3
12450: PUSH
12451: EMPTY
12452: LIST
12453: LIST
12454: PPUSH
12455: CALL_OW 70
12459: PUSH
12460: LD_INT 1
12462: GREATER
12463: IFFALSE 12519
// begin for i in tmp do
12465: LD_ADDR_VAR 0 5
12469: PUSH
12470: LD_VAR 0 1
12474: PUSH
12475: FOR_IN
12476: IFFALSE 12515
// begin if IsInUnit ( i ) then
12478: LD_VAR 0 5
12482: PPUSH
12483: CALL_OW 310
12487: IFFALSE 12498
// ComExitBuilding ( i ) ;
12489: LD_VAR 0 5
12493: PPUSH
12494: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12498: LD_VAR 0 5
12502: PPUSH
12503: LD_INT 204
12505: PPUSH
12506: LD_INT 164
12508: PPUSH
12509: CALL_OW 174
// end ;
12513: GO 12475
12515: POP
12516: POP
// end else
12517: GO 12751
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12519: LD_VAR 0 1
12523: PPUSH
12524: LD_INT 3
12526: PUSH
12527: LD_INT 54
12529: PUSH
12530: EMPTY
12531: LIST
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: PPUSH
12537: CALL_OW 72
12541: IFFALSE 12751
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12543: LD_ADDR_VAR 0 4
12547: PUSH
12548: LD_EXP 14
12552: PPUSH
12553: LD_INT 30
12555: PUSH
12556: LD_INT 32
12558: PUSH
12559: EMPTY
12560: LIST
12561: LIST
12562: PUSH
12563: LD_INT 58
12565: PUSH
12566: EMPTY
12567: LIST
12568: PUSH
12569: EMPTY
12570: LIST
12571: LIST
12572: PPUSH
12573: CALL_OW 72
12577: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12578: LD_VAR 0 4
12582: NOT
12583: PUSH
12584: LD_EXP 14
12588: PPUSH
12589: LD_INT 30
12591: PUSH
12592: LD_INT 5
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PPUSH
12599: CALL_OW 72
12603: AND
12604: IFFALSE 12641
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12606: LD_VAR 0 1
12610: PPUSH
12611: LD_EXP 14
12615: PPUSH
12616: LD_INT 30
12618: PUSH
12619: LD_INT 5
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PPUSH
12626: CALL_OW 72
12630: PUSH
12631: LD_INT 1
12633: ARRAY
12634: PPUSH
12635: CALL_OW 120
// exit ;
12639: GO 12751
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12641: LD_ADDR_VAR 0 6
12645: PUSH
12646: LD_VAR 0 1
12650: PPUSH
12651: LD_INT 3
12653: PUSH
12654: LD_INT 54
12656: PUSH
12657: EMPTY
12658: LIST
12659: PUSH
12660: EMPTY
12661: LIST
12662: LIST
12663: PPUSH
12664: CALL_OW 72
12668: ST_TO_ADDR
// if j < empty then
12669: LD_VAR 0 6
12673: PUSH
12674: LD_VAR 0 4
12678: LESS
12679: IFFALSE 12693
// k := j else
12681: LD_ADDR_VAR 0 7
12685: PUSH
12686: LD_VAR 0 6
12690: ST_TO_ADDR
12691: GO 12703
// k := empty ;
12693: LD_ADDR_VAR 0 7
12697: PUSH
12698: LD_VAR 0 4
12702: ST_TO_ADDR
// for i = 1 to k do
12703: LD_ADDR_VAR 0 5
12707: PUSH
12708: DOUBLE
12709: LD_INT 1
12711: DEC
12712: ST_TO_ADDR
12713: LD_VAR 0 7
12717: PUSH
12718: FOR_TO
12719: IFFALSE 12749
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12721: LD_VAR 0 6
12725: PUSH
12726: LD_VAR 0 5
12730: ARRAY
12731: PPUSH
12732: LD_VAR 0 4
12736: PUSH
12737: LD_VAR 0 5
12741: ARRAY
12742: PPUSH
12743: CALL_OW 120
12747: GO 12718
12749: POP
12750: POP
// end ; end ;
12751: PPOPN 7
12753: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12754: LD_EXP 2
12758: PUSH
12759: LD_INT 1
12761: EQUAL
12762: PUSH
12763: LD_EXP 27
12767: AND
12768: PUSH
12769: LD_INT 22
12771: PUSH
12772: LD_INT 1
12774: PUSH
12775: EMPTY
12776: LIST
12777: LIST
12778: PUSH
12779: LD_INT 92
12781: PUSH
12782: LD_INT 208
12784: PUSH
12785: LD_INT 163
12787: PUSH
12788: LD_INT 8
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PPUSH
12801: CALL_OW 69
12805: AND
12806: PUSH
12807: LD_INT 22
12809: PUSH
12810: LD_INT 3
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: LD_INT 21
12819: PUSH
12820: LD_INT 1
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PUSH
12827: LD_INT 92
12829: PUSH
12830: LD_INT 208
12832: PUSH
12833: LD_INT 163
12835: PUSH
12836: LD_INT 14
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: LIST
12843: LIST
12844: PUSH
12845: EMPTY
12846: LIST
12847: LIST
12848: LIST
12849: PPUSH
12850: CALL_OW 69
12854: NOT
12855: AND
12856: IFFALSE 13161
12858: GO 12860
12860: DISABLE
12861: LD_INT 0
12863: PPUSH
// begin InGameOn ;
12864: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12868: LD_EXP 9
12872: PPUSH
12873: CALL_OW 87
// wait ( 0 0$1 ) ;
12877: LD_INT 35
12879: PPUSH
12880: CALL_OW 67
// DialogueOn ;
12884: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12888: LD_EXP 9
12892: PPUSH
12893: LD_STRING D
12895: PUSH
12896: LD_STRING I
12898: PUSH
12899: LD_STRING J
12901: PUSH
12902: LD_STRING S
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: PUSH
12910: LD_EXP 25
12914: ARRAY
12915: STR
12916: PUSH
12917: LD_STRING -1-BaseCaptured
12919: STR
12920: PPUSH
12921: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12925: LD_EXP 12
12929: PPUSH
12930: LD_STRING DP-1-BaseCaptured
12932: PPUSH
12933: CALL_OW 94
// if sibBombAllowed then
12937: LD_EXP 23
12941: IFFALSE 13083
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12943: LD_EXP 9
12947: PPUSH
12948: LD_STRING D
12950: PUSH
12951: LD_STRING I
12953: PUSH
12954: LD_STRING J
12956: PUSH
12957: LD_STRING S
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: LIST
12964: PUSH
12965: LD_EXP 25
12969: ARRAY
12970: STR
12971: PUSH
12972: LD_STRING -2-BaseCaptured
12974: STR
12975: PPUSH
12976: CALL_OW 88
// if commander = 1 then
12980: LD_EXP 25
12984: PUSH
12985: LD_INT 1
12987: EQUAL
12988: IFFALSE 13002
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12990: LD_EXP 12
12994: PPUSH
12995: LD_STRING DP-2b-BaseCaptured
12997: PPUSH
12998: CALL_OW 94
// if commander = 2 then
13002: LD_EXP 25
13006: PUSH
13007: LD_INT 2
13009: EQUAL
13010: IFFALSE 13024
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
13012: LD_EXP 12
13016: PPUSH
13017: LD_STRING DP-2-BaseCaptured
13019: PPUSH
13020: CALL_OW 94
// if commander = 3 then
13024: LD_EXP 25
13028: PUSH
13029: LD_INT 3
13031: EQUAL
13032: IFFALSE 13046
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13034: LD_EXP 12
13038: PPUSH
13039: LD_STRING DP-2a-BaseCaptured
13041: PPUSH
13042: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13046: LD_EXP 9
13050: PPUSH
13051: LD_STRING D
13053: PUSH
13054: LD_STRING I
13056: PUSH
13057: LD_STRING J
13059: PUSH
13060: LD_STRING S
13062: PUSH
13063: EMPTY
13064: LIST
13065: LIST
13066: LIST
13067: PUSH
13068: LD_EXP 25
13072: ARRAY
13073: STR
13074: PUSH
13075: LD_STRING -3-BaseCaptured
13077: STR
13078: PPUSH
13079: CALL_OW 88
// end ; DialogueOff ;
13083: CALL_OW 7
// InGameOff ;
13087: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13091: LD_STRING O2
13093: PPUSH
13094: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13098: LD_ADDR_VAR 0 1
13102: PUSH
13103: LD_EXP 14
13107: PPUSH
13108: LD_INT 21
13110: PUSH
13111: LD_INT 3
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PPUSH
13118: CALL_OW 72
13122: PUSH
13123: FOR_IN
13124: IFFALSE 13140
// SetSide ( i , 1 ) ;
13126: LD_VAR 0 1
13130: PPUSH
13131: LD_INT 1
13133: PPUSH
13134: CALL_OW 235
13138: GO 13123
13140: POP
13141: POP
// baseCaptured := true ;
13142: LD_ADDR_EXP 17
13146: PUSH
13147: LD_INT 1
13149: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13150: LD_INT 1225
13152: PPUSH
13153: CALL_OW 67
// PrepareReinforcements ;
13157: CALL 9910 0 0
// end ;
13161: PPOPN 1
13163: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13164: LD_INT 22
13166: PUSH
13167: LD_INT 3
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PUSH
13174: LD_INT 92
13176: PUSH
13177: LD_INT 167
13179: PUSH
13180: LD_INT 197
13182: PUSH
13183: LD_INT 20
13185: PUSH
13186: EMPTY
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PPUSH
13196: CALL_OW 69
13200: PUSH
13201: LD_INT 3
13203: GREATER
13204: IFFALSE 13221
13206: GO 13208
13208: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13209: LD_EXP 12
13213: PPUSH
13214: LD_STRING DP-RuAttack
13216: PPUSH
13217: CALL_OW 94
13221: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13222: LD_EXP 1
13226: NOT
13227: PUSH
13228: LD_INT 1
13230: PPUSH
13231: LD_INT 168
13233: PPUSH
13234: LD_INT 74
13236: PPUSH
13237: CALL_OW 293
13241: AND
13242: PUSH
13243: LD_INT 168
13245: PPUSH
13246: LD_INT 72
13248: PPUSH
13249: CALL_OW 553
13253: AND
13254: IFFALSE 13306
13256: GO 13258
13258: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13259: LD_INT 168
13261: PPUSH
13262: LD_INT 72
13264: PPUSH
13265: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13269: LD_EXP 9
13273: PPUSH
13274: LD_STRING D
13276: PUSH
13277: LD_STRING I
13279: PUSH
13280: LD_STRING J
13282: PUSH
13283: LD_STRING S
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: LIST
13290: PUSH
13291: LD_EXP 25
13295: ARRAY
13296: STR
13297: PUSH
13298: LD_STRING -1-Blockade
13300: STR
13301: PPUSH
13302: CALL_OW 88
// end ;
13306: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13307: LD_EXP 2
13311: PUSH
13312: LD_INT 1
13314: EQUAL
13315: PUSH
13316: LD_INT 22
13318: PUSH
13319: LD_INT 1
13321: PUSH
13322: EMPTY
13323: LIST
13324: LIST
13325: PUSH
13326: LD_INT 101
13328: PUSH
13329: LD_INT 4
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PPUSH
13340: CALL_OW 69
13344: AND
13345: IFFALSE 13877
13347: GO 13349
13349: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13350: LD_INT 4
13352: PPUSH
13353: LD_INT 1
13355: PPUSH
13356: CALL_OW 343
// DialogueOn ;
13360: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13364: LD_EXP 11
13368: PPUSH
13369: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13373: LD_EXP 11
13377: PPUSH
13378: LD_STRING DM-1-Contact
13380: PPUSH
13381: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13385: LD_EXP 9
13389: PPUSH
13390: LD_STRING D
13392: PUSH
13393: LD_STRING I
13395: PUSH
13396: LD_STRING J
13398: PUSH
13399: LD_STRING S
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: LIST
13406: PUSH
13407: LD_EXP 25
13411: ARRAY
13412: STR
13413: PUSH
13414: LD_STRING -1-Contact
13416: STR
13417: PPUSH
13418: CALL_OW 88
// if commander = 1 then
13422: LD_EXP 25
13426: PUSH
13427: LD_INT 1
13429: EQUAL
13430: IFFALSE 13562
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13432: LD_EXP 11
13436: PPUSH
13437: LD_STRING DM-2-Contact
13439: PPUSH
13440: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13444: LD_EXP 9
13448: PPUSH
13449: LD_STRING DI-2-Contact
13451: PPUSH
13452: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13456: LD_INT 22
13458: PUSH
13459: LD_INT 8
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: LD_INT 21
13468: PUSH
13469: LD_INT 1
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PPUSH
13480: CALL_OW 69
13484: PUSH
13485: LD_INT 8
13487: PPUSH
13488: LD_INT 1
13490: PPUSH
13491: CALL_OW 81
13495: PUSH
13496: LD_INT 2
13498: EQUAL
13499: AND
13500: IFFALSE 13526
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13502: LD_EXP 11
13506: PPUSH
13507: LD_STRING DM-3-Contact
13509: PPUSH
13510: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13514: LD_EXP 9
13518: PPUSH
13519: LD_STRING DI-3-Contact
13521: PPUSH
13522: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13526: LD_EXP 11
13530: PPUSH
13531: LD_STRING DM-4-Contact
13533: PPUSH
13534: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13538: LD_EXP 9
13542: PPUSH
13543: LD_STRING DI-4-Contact
13545: PPUSH
13546: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13550: LD_EXP 11
13554: PPUSH
13555: LD_STRING DM-5-Contact
13557: PPUSH
13558: CALL_OW 94
// end ; if commander = 2 then
13562: LD_EXP 25
13566: PUSH
13567: LD_INT 2
13569: EQUAL
13570: IFFALSE 13702
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13572: LD_EXP 11
13576: PPUSH
13577: LD_STRING DM-2c-Contact
13579: PPUSH
13580: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13584: LD_EXP 9
13588: PPUSH
13589: LD_STRING DJ-2-Contact
13591: PPUSH
13592: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13596: LD_INT 22
13598: PUSH
13599: LD_INT 8
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: LD_INT 21
13608: PUSH
13609: LD_INT 1
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: PUSH
13616: EMPTY
13617: LIST
13618: LIST
13619: PPUSH
13620: CALL_OW 69
13624: PUSH
13625: LD_INT 8
13627: PPUSH
13628: LD_INT 1
13630: PPUSH
13631: CALL_OW 81
13635: PUSH
13636: LD_INT 2
13638: EQUAL
13639: AND
13640: IFFALSE 13666
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13642: LD_EXP 11
13646: PPUSH
13647: LD_STRING DM-3-Contact
13649: PPUSH
13650: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13654: LD_EXP 9
13658: PPUSH
13659: LD_STRING DJ-3-Contact
13661: PPUSH
13662: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13666: LD_EXP 11
13670: PPUSH
13671: LD_STRING DM-4-Contact
13673: PPUSH
13674: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13678: LD_EXP 9
13682: PPUSH
13683: LD_STRING DJ-4-Contact
13685: PPUSH
13686: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13690: LD_EXP 11
13694: PPUSH
13695: LD_STRING DM-5a-Contact
13697: PPUSH
13698: CALL_OW 94
// end ; if commander = 3 then
13702: LD_EXP 25
13706: PUSH
13707: LD_INT 3
13709: EQUAL
13710: IFFALSE 13866
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13712: LD_EXP 11
13716: PPUSH
13717: LD_STRING DM-2a-Contact
13719: PPUSH
13720: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13724: LD_EXP 9
13728: PPUSH
13729: LD_STRING DS-2a-Contact
13731: PPUSH
13732: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13736: LD_EXP 11
13740: PPUSH
13741: LD_STRING DM-2b-Contact
13743: PPUSH
13744: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13748: LD_EXP 9
13752: PPUSH
13753: LD_STRING DS-2b-Contact
13755: PPUSH
13756: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13760: LD_INT 22
13762: PUSH
13763: LD_INT 8
13765: PUSH
13766: EMPTY
13767: LIST
13768: LIST
13769: PUSH
13770: LD_INT 21
13772: PUSH
13773: LD_INT 1
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: PUSH
13780: EMPTY
13781: LIST
13782: LIST
13783: PPUSH
13784: CALL_OW 69
13788: PUSH
13789: LD_INT 8
13791: PPUSH
13792: LD_INT 1
13794: PPUSH
13795: CALL_OW 81
13799: PUSH
13800: LD_INT 2
13802: EQUAL
13803: AND
13804: IFFALSE 13830
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13806: LD_EXP 11
13810: PPUSH
13811: LD_STRING DM-3-Contact
13813: PPUSH
13814: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13818: LD_EXP 9
13822: PPUSH
13823: LD_STRING DS-3-Contact
13825: PPUSH
13826: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13830: LD_EXP 11
13834: PPUSH
13835: LD_STRING DM-4-Contact
13837: PPUSH
13838: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13842: LD_EXP 9
13846: PPUSH
13847: LD_STRING DS-4-Contact
13849: PPUSH
13850: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13854: LD_EXP 11
13858: PPUSH
13859: LD_STRING DM-5-Contact
13861: PPUSH
13862: CALL_OW 94
// end ; DialogueOff ;
13866: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13870: LD_STRING O3
13872: PPUSH
13873: CALL_OW 337
// end ;
13877: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13878: LD_EXP 2
13882: PUSH
13883: LD_INT 1
13885: EQUAL
13886: PUSH
13887: LD_EXP 18
13891: PUSH
13892: LD_INT 15
13894: PUSH
13895: LD_INT 20
13897: PUSH
13898: LD_INT 25
13900: PUSH
13901: EMPTY
13902: LIST
13903: LIST
13904: LIST
13905: PUSH
13906: LD_OWVAR 67
13910: ARRAY
13911: GREATEREQUAL
13912: AND
13913: PUSH
13914: LD_INT 22
13916: PUSH
13917: LD_INT 8
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: PUSH
13924: LD_INT 30
13926: PUSH
13927: LD_INT 1
13929: PUSH
13930: EMPTY
13931: LIST
13932: LIST
13933: PUSH
13934: EMPTY
13935: LIST
13936: LIST
13937: PPUSH
13938: CALL_OW 69
13942: AND
13943: PUSH
13944: LD_INT 22
13946: PUSH
13947: LD_INT 8
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: PUSH
13954: LD_INT 21
13956: PUSH
13957: LD_INT 3
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: EMPTY
13965: LIST
13966: LIST
13967: PPUSH
13968: CALL_OW 69
13972: PUSH
13973: LD_INT 5
13975: GREATEREQUAL
13976: AND
13977: IFFALSE 14500
13979: GO 13981
13981: DISABLE
13982: LD_INT 0
13984: PPUSH
13985: PPUSH
13986: PPUSH
13987: PPUSH
// begin DialogueOn ;
13988: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13992: LD_EXP 13
13996: PPUSH
13997: LD_STRING DF-1-Leg
13999: PPUSH
14000: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14004: LD_EXP 9
14008: PPUSH
14009: LD_STRING D
14011: PUSH
14012: LD_STRING I
14014: PUSH
14015: LD_STRING J
14017: PUSH
14018: LD_STRING S
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: LIST
14025: PUSH
14026: LD_EXP 25
14030: ARRAY
14031: STR
14032: PUSH
14033: LD_STRING -1-Leg
14035: STR
14036: PPUSH
14037: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14041: LD_EXP 13
14045: PPUSH
14046: LD_STRING DF-2-Leg
14048: PPUSH
14049: CALL_OW 94
// DialogueOff ;
14053: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14057: LD_STRING QLegionOffer
14059: PPUSH
14060: CALL_OW 97
14064: PUSH
14065: LD_INT 1
14067: DOUBLE
14068: EQUAL
14069: IFTRUE 14073
14071: GO 14076
14073: POP
// ; 2 :
14074: GO 14090
14076: LD_INT 2
14078: DOUBLE
14079: EQUAL
14080: IFTRUE 14084
14082: GO 14089
14084: POP
// exit ; end ;
14085: GO 14500
14087: GO 14090
14089: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14090: LD_EXP 9
14094: PPUSH
14095: LD_STRING D
14097: PUSH
14098: LD_STRING I
14100: PUSH
14101: LD_STRING J
14103: PUSH
14104: LD_STRING S
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: LIST
14111: PUSH
14112: LD_EXP 25
14116: ARRAY
14117: STR
14118: PUSH
14119: LD_STRING -2-Leg
14121: STR
14122: PPUSH
14123: CALL_OW 88
// legOfferAccepted := true ;
14127: LD_ADDR_EXP 20
14131: PUSH
14132: LD_INT 1
14134: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14135: LD_INT 21
14137: PPUSH
14138: LD_INT 1
14140: PPUSH
14141: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14145: LD_INT 190
14147: PPUSH
14148: LD_INT 227
14150: PPUSH
14151: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14155: LD_ADDR_VAR 0 1
14159: PUSH
14160: LD_INT 16800
14162: PUSH
14163: LD_INT 14700
14165: PUSH
14166: LD_INT 12600
14168: PUSH
14169: EMPTY
14170: LIST
14171: LIST
14172: LIST
14173: PUSH
14174: LD_OWVAR 67
14178: ARRAY
14179: ST_TO_ADDR
// sib := 100 ;
14180: LD_ADDR_VAR 0 2
14184: PUSH
14185: LD_INT 100
14187: ST_TO_ADDR
// disableGlobalTimer := true ;
14188: LD_ADDR_EXP 4
14192: PUSH
14193: LD_INT 1
14195: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14196: LD_INT 35
14198: PPUSH
14199: CALL_OW 67
// time := time - 0 0$1 ;
14203: LD_ADDR_VAR 0 1
14207: PUSH
14208: LD_VAR 0 1
14212: PUSH
14213: LD_INT 35
14215: MINUS
14216: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14217: LD_ADDR_VAR 0 3
14221: PUSH
14222: LD_INT 21
14224: PPUSH
14225: LD_INT 3
14227: PPUSH
14228: CALL_OW 287
14232: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14233: LD_ADDR_OWVAR 47
14237: PUSH
14238: LD_STRING #SkrTime
14240: PUSH
14241: LD_OWVAR 1
14245: PUSH
14246: LD_STRING #Skr-LegOffer
14248: PUSH
14249: LD_VAR 0 2
14253: PUSH
14254: LD_VAR 0 1
14258: PUSH
14259: EMPTY
14260: LIST
14261: LIST
14262: LIST
14263: LIST
14264: LIST
14265: ST_TO_ADDR
// if sources then
14266: LD_VAR 0 3
14270: IFFALSE 14302
// begin sib := sib - sources * 10 ;
14272: LD_ADDR_VAR 0 2
14276: PUSH
14277: LD_VAR 0 2
14281: PUSH
14282: LD_VAR 0 3
14286: PUSH
14287: LD_INT 10
14289: MUL
14290: MINUS
14291: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14292: LD_INT 21
14294: PPUSH
14295: LD_INT 3
14297: PPUSH
14298: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14302: LD_VAR 0 1
14306: PUSH
14307: LD_INT 0
14309: EQUAL
14310: PUSH
14311: LD_VAR 0 2
14315: PUSH
14316: LD_INT 0
14318: LESSEQUAL
14319: OR
14320: PUSH
14321: LD_INT 22
14323: PUSH
14324: LD_INT 8
14326: PUSH
14327: EMPTY
14328: LIST
14329: LIST
14330: PPUSH
14331: CALL_OW 69
14335: NOT
14336: OR
14337: IFFALSE 14196
// SetAreaMapShow ( legOfferArea , 0 ) ;
14339: LD_INT 21
14341: PPUSH
14342: LD_INT 0
14344: PPUSH
14345: CALL_OW 424
// disableGlobalTimer := false ;
14349: LD_ADDR_EXP 4
14353: PUSH
14354: LD_INT 0
14356: ST_TO_ADDR
// if sib <= 0 then
14357: LD_VAR 0 2
14361: PUSH
14362: LD_INT 0
14364: LESSEQUAL
14365: IFFALSE 14481
// begin legChangeSide := true ;
14367: LD_ADDR_EXP 21
14371: PUSH
14372: LD_INT 1
14374: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14375: LD_EXP 13
14379: PPUSH
14380: LD_STRING DF-4y-Leg
14382: PPUSH
14383: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14387: LD_STRING O3a
14389: PPUSH
14390: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14394: LD_INT 8
14396: PPUSH
14397: LD_INT 1
14399: PPUSH
14400: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14404: LD_INT 8
14406: PPUSH
14407: LD_INT 1
14409: PPUSH
14410: LD_INT 1
14412: PPUSH
14413: LD_INT 1
14415: PPUSH
14416: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14420: LD_INT 8
14422: PPUSH
14423: LD_INT 4
14425: PPUSH
14426: LD_INT 1
14428: PPUSH
14429: LD_INT 1
14431: PPUSH
14432: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14436: LD_INT 8
14438: PPUSH
14439: LD_INT 6
14441: PPUSH
14442: LD_INT 2
14444: PPUSH
14445: LD_INT 1
14447: PPUSH
14448: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14452: LD_INT 8
14454: PPUSH
14455: LD_INT 3
14457: PPUSH
14458: LD_INT 2
14460: PPUSH
14461: LD_INT 1
14463: PPUSH
14464: CALL_OW 80
// wait ( 0 0$30 ) ;
14468: LD_INT 1050
14470: PPUSH
14471: CALL_OW 67
// PrepareLegionReinforcements ;
14475: CALL 10610 0 0
// end else
14479: GO 14500
// begin ChangeMissionObjectives ( O3a ) ;
14481: LD_STRING O3a
14483: PPUSH
14484: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14488: LD_EXP 13
14492: PPUSH
14493: LD_STRING DF-4n-Leg
14495: PPUSH
14496: CALL_OW 94
// end ; end ;
14500: PPOPN 4
14502: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14503: LD_INT 22
14505: PUSH
14506: LD_INT 8
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: PUSH
14513: LD_INT 21
14515: PUSH
14516: LD_INT 1
14518: PUSH
14519: EMPTY
14520: LIST
14521: LIST
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: PPUSH
14527: CALL_OW 69
14531: PUSH
14532: LD_INT 0
14534: EQUAL
14535: PUSH
14536: LD_INT 8
14538: PPUSH
14539: LD_INT 1
14541: PPUSH
14542: CALL_OW 81
14546: PUSH
14547: LD_INT 2
14549: EQUAL
14550: AND
14551: IFFALSE 14563
14553: GO 14555
14555: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14556: LD_STRING O3a
14558: PPUSH
14559: CALL_OW 337
14563: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14564: LD_EXP 2
14568: PUSH
14569: LD_INT 1
14571: EQUAL
14572: PUSH
14573: LD_EXP 3
14577: AND
14578: PUSH
14579: LD_INT 22
14581: PUSH
14582: LD_INT 3
14584: PUSH
14585: EMPTY
14586: LIST
14587: LIST
14588: PUSH
14589: LD_INT 21
14591: PUSH
14592: LD_INT 1
14594: PUSH
14595: EMPTY
14596: LIST
14597: LIST
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PPUSH
14603: CALL_OW 69
14607: PUSH
14608: LD_INT 0
14610: EQUAL
14611: AND
14612: PUSH
14613: LD_INT 22
14615: PUSH
14616: LD_INT 3
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: PUSH
14623: LD_INT 30
14625: PUSH
14626: LD_INT 1
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PPUSH
14637: CALL_OW 69
14641: PUSH
14642: LD_INT 0
14644: EQUAL
14645: AND
14646: IFFALSE 14884
14648: GO 14650
14650: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14651: LD_EXP 9
14655: PPUSH
14656: LD_STRING D
14658: PUSH
14659: LD_STRING I
14661: PUSH
14662: LD_STRING J
14664: PUSH
14665: LD_STRING S
14667: PUSH
14668: EMPTY
14669: LIST
14670: LIST
14671: LIST
14672: PUSH
14673: LD_EXP 25
14677: ARRAY
14678: STR
14679: PUSH
14680: LD_STRING -1-Win
14682: STR
14683: PPUSH
14684: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14688: LD_OWVAR 1
14692: PUSH
14693: LD_INT 315000
14695: PUSH
14696: LD_INT 273000
14698: PUSH
14699: LD_INT 231000
14701: PUSH
14702: EMPTY
14703: LIST
14704: LIST
14705: LIST
14706: PUSH
14707: LD_OWVAR 67
14711: ARRAY
14712: GREATEREQUAL
14713: IFFALSE 14728
// AddMedal ( med1 , - 1 ) else
14715: LD_STRING med1
14717: PPUSH
14718: LD_INT 1
14720: NEG
14721: PPUSH
14722: CALL_OW 101
14726: GO 14738
// AddMedal ( med1 , 1 ) ;
14728: LD_STRING med1
14730: PPUSH
14731: LD_INT 1
14733: PPUSH
14734: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14738: LD_EXP 22
14742: PUSH
14743: LD_INT 20
14745: PUSH
14746: LD_INT 15
14748: PUSH
14749: LD_INT 10
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: LIST
14756: PUSH
14757: LD_OWVAR 67
14761: ARRAY
14762: GREATEREQUAL
14763: IFFALSE 14778
// AddMedal ( med2 , - 1 ) else
14765: LD_STRING med2
14767: PPUSH
14768: LD_INT 1
14770: NEG
14771: PPUSH
14772: CALL_OW 101
14776: GO 14788
// AddMedal ( med2 , 1 ) ;
14778: LD_STRING med2
14780: PPUSH
14781: LD_INT 1
14783: PPUSH
14784: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14788: LD_INT 8
14790: PPUSH
14791: LD_INT 1
14793: PPUSH
14794: CALL_OW 81
14798: PUSH
14799: LD_INT 1
14801: EQUAL
14802: IFFALSE 14816
// AddMedal ( med3 , 1 ) else
14804: LD_STRING med3
14806: PPUSH
14807: LD_INT 1
14809: PPUSH
14810: CALL_OW 101
14814: GO 14873
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14816: LD_INT 22
14818: PUSH
14819: LD_INT 8
14821: PUSH
14822: EMPTY
14823: LIST
14824: LIST
14825: PUSH
14826: LD_INT 21
14828: PUSH
14829: LD_INT 1
14831: PUSH
14832: EMPTY
14833: LIST
14834: LIST
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: PPUSH
14840: CALL_OW 69
14844: PUSH
14845: LD_INT 0
14847: EQUAL
14848: IFFALSE 14862
// AddMedal ( med3 , 2 ) else
14850: LD_STRING med3
14852: PPUSH
14853: LD_INT 2
14855: PPUSH
14856: CALL_OW 101
14860: GO 14873
// AddMedal ( med3 , - 1 ) ;
14862: LD_STRING med3
14864: PPUSH
14865: LD_INT 1
14867: NEG
14868: PPUSH
14869: CALL_OW 101
// GiveMedals ( MAIN ) ;
14873: LD_STRING MAIN
14875: PPUSH
14876: CALL_OW 102
// YouWin ;
14880: CALL_OW 103
// end ;
14884: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14885: LD_EXP 2
14889: PUSH
14890: LD_INT 1
14892: EQUAL
14893: PUSH
14894: LD_EXP 16
14898: AND
14899: PUSH
14900: LD_INT 20
14902: PPUSH
14903: LD_INT 81
14905: PUSH
14906: LD_INT 8
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PPUSH
14913: CALL_OW 70
14917: AND
14918: IFFALSE 15197
14920: GO 14922
14922: DISABLE
14923: LD_INT 0
14925: PPUSH
14926: PPUSH
14927: PPUSH
14928: PPUSH
14929: PPUSH
// begin enable ;
14930: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14931: LD_ADDR_VAR 0 3
14935: PUSH
14936: LD_INT 20
14938: PPUSH
14939: LD_INT 81
14941: PUSH
14942: LD_INT 8
14944: PUSH
14945: EMPTY
14946: LIST
14947: LIST
14948: PPUSH
14949: CALL_OW 70
14953: ST_TO_ADDR
// if not tmp then
14954: LD_VAR 0 3
14958: NOT
14959: IFFALSE 14963
// exit ;
14961: GO 15197
// for i in tmp do
14963: LD_ADDR_VAR 0 1
14967: PUSH
14968: LD_VAR 0 3
14972: PUSH
14973: FOR_IN
14974: IFFALSE 15195
// begin x := GetX ( i ) ;
14976: LD_ADDR_VAR 0 4
14980: PUSH
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 250
14990: ST_TO_ADDR
// y := GetY ( i ) ;
14991: LD_ADDR_VAR 0 5
14995: PUSH
14996: LD_VAR 0 1
15000: PPUSH
15001: CALL_OW 251
15005: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15006: LD_VAR 0 4
15010: PPUSH
15011: LD_VAR 0 5
15015: PPUSH
15016: CALL_OW 458
15020: IFFALSE 15193
// begin LaunchMineAtPos ( x , y , 8 ) ;
15022: LD_VAR 0 4
15026: PPUSH
15027: LD_VAR 0 5
15031: PPUSH
15032: LD_INT 8
15034: PPUSH
15035: CALL_OW 456
// if not dialogueMineDetected then
15039: LD_EXP 28
15043: NOT
15044: IFFALSE 15105
// begin CenterNowOnXY ( x , y ) ;
15046: LD_VAR 0 4
15050: PPUSH
15051: LD_VAR 0 5
15055: PPUSH
15056: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15060: LD_EXP 9
15064: PPUSH
15065: LD_STRING D
15067: PUSH
15068: LD_STRING I
15070: PUSH
15071: LD_STRING J
15073: PUSH
15074: LD_STRING S
15076: PUSH
15077: EMPTY
15078: LIST
15079: LIST
15080: LIST
15081: PUSH
15082: LD_EXP 25
15086: ARRAY
15087: STR
15088: PUSH
15089: LD_STRING -1-Mine
15091: STR
15092: PPUSH
15093: CALL_OW 88
// dialogueMineDetected := true ;
15097: LD_ADDR_EXP 28
15101: PUSH
15102: LD_INT 1
15104: ST_TO_ADDR
// end ; for j = 1 to staticMines do
15105: LD_ADDR_VAR 0 2
15109: PUSH
15110: DOUBLE
15111: LD_INT 1
15113: DEC
15114: ST_TO_ADDR
15115: LD_EXP 16
15119: PUSH
15120: FOR_TO
15121: IFFALSE 15191
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15123: LD_EXP 16
15127: PUSH
15128: LD_VAR 0 2
15132: ARRAY
15133: PUSH
15134: LD_INT 1
15136: ARRAY
15137: PUSH
15138: LD_VAR 0 4
15142: EQUAL
15143: PUSH
15144: LD_EXP 16
15148: PUSH
15149: LD_VAR 0 2
15153: ARRAY
15154: PUSH
15155: LD_INT 2
15157: ARRAY
15158: PUSH
15159: LD_VAR 0 5
15163: EQUAL
15164: AND
15165: IFFALSE 15189
// begin staticMines := Delete ( staticMines , j ) ;
15167: LD_ADDR_EXP 16
15171: PUSH
15172: LD_EXP 16
15176: PPUSH
15177: LD_VAR 0 2
15181: PPUSH
15182: CALL_OW 3
15186: ST_TO_ADDR
// break ;
15187: GO 15191
// end ;
15189: GO 15120
15191: POP
15192: POP
// end ; end ;
15193: GO 14973
15195: POP
15196: POP
// end ;
15197: PPOPN 5
15199: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15200: LD_EXP 2
15204: PUSH
15205: LD_INT 1
15207: EQUAL
15208: PUSH
15209: LD_EXP 3
15213: AND
15214: PUSH
15215: LD_EXP 23
15219: AND
15220: PUSH
15221: LD_EXP 49
15225: PUSH
15226: LD_EXP 7
15230: ARRAY
15231: PPUSH
15232: LD_INT 30
15234: PUSH
15235: LD_INT 3
15237: PUSH
15238: EMPTY
15239: LIST
15240: LIST
15241: PPUSH
15242: CALL_OW 72
15246: AND
15247: IFFALSE 15451
15249: GO 15251
15251: DISABLE
15252: LD_INT 0
15254: PPUSH
15255: PPUSH
// begin enable ;
15256: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15257: LD_EXP 7
15261: PPUSH
15262: LD_INT 23
15264: PUSH
15265: LD_INT 3
15267: PUSH
15268: LD_INT 3
15270: PUSH
15271: LD_INT 48
15273: PUSH
15274: EMPTY
15275: LIST
15276: LIST
15277: LIST
15278: LIST
15279: PUSH
15280: EMPTY
15281: LIST
15282: PPUSH
15283: CALL 85482 0 2
// repeat wait ( 0 0$1 ) ;
15287: LD_INT 35
15289: PPUSH
15290: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15294: LD_INT 22
15296: PUSH
15297: LD_INT 3
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: PUSH
15304: LD_INT 34
15306: PUSH
15307: LD_INT 48
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PPUSH
15318: CALL_OW 69
15322: IFFALSE 15287
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15324: LD_ADDR_VAR 0 1
15328: PUSH
15329: LD_INT 22
15331: PUSH
15332: LD_INT 3
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: PUSH
15339: LD_INT 34
15341: PUSH
15342: LD_INT 48
15344: PUSH
15345: EMPTY
15346: LIST
15347: LIST
15348: PUSH
15349: EMPTY
15350: LIST
15351: LIST
15352: PPUSH
15353: CALL_OW 69
15357: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15358: LD_ADDR_VAR 0 2
15362: PUSH
15363: LD_INT 81
15365: PUSH
15366: LD_INT 3
15368: PUSH
15369: EMPTY
15370: LIST
15371: LIST
15372: PUSH
15373: LD_INT 21
15375: PUSH
15376: LD_INT 3
15378: PUSH
15379: EMPTY
15380: LIST
15381: LIST
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PPUSH
15387: CALL_OW 69
15391: ST_TO_ADDR
// if e then
15392: LD_VAR 0 2
15396: IFFALSE 15422
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15398: LD_ADDR_VAR 0 2
15402: PUSH
15403: LD_VAR 0 2
15407: PPUSH
15408: LD_VAR 0 1
15412: PUSH
15413: LD_INT 1
15415: ARRAY
15416: PPUSH
15417: CALL_OW 74
15421: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15422: LD_VAR 0 1
15426: PPUSH
15427: LD_VAR 0 2
15431: PPUSH
15432: CALL_OW 250
15436: PPUSH
15437: LD_VAR 0 2
15441: PPUSH
15442: CALL_OW 251
15446: PPUSH
15447: CALL_OW 116
// end ;
15451: PPOPN 2
15453: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15454: LD_OWVAR 67
15458: PUSH
15459: LD_INT 1
15461: GREATER
15462: PUSH
15463: LD_EXP 49
15467: PUSH
15468: LD_EXP 7
15472: ARRAY
15473: PPUSH
15474: LD_INT 25
15476: PUSH
15477: LD_INT 3
15479: PUSH
15480: EMPTY
15481: LIST
15482: LIST
15483: PPUSH
15484: CALL_OW 72
15488: AND
15489: PUSH
15490: LD_EXP 2
15494: PUSH
15495: LD_INT 1
15497: EQUAL
15498: AND
15499: PUSH
15500: LD_EXP 3
15504: AND
15505: PUSH
15506: LD_INT 23
15508: PPUSH
15509: LD_INT 3
15511: PPUSH
15512: CALL_OW 321
15516: PUSH
15517: LD_INT 2
15519: EQUAL
15520: AND
15521: IFFALSE 15648
15523: GO 15525
15525: DISABLE
15526: LD_INT 0
15528: PPUSH
15529: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15530: LD_ADDR_VAR 0 1
15534: PUSH
15535: LD_EXP 49
15539: PUSH
15540: LD_EXP 7
15544: ARRAY
15545: PPUSH
15546: LD_INT 25
15548: PUSH
15549: LD_INT 3
15551: PUSH
15552: EMPTY
15553: LIST
15554: LIST
15555: PPUSH
15556: CALL_OW 72
15560: ST_TO_ADDR
// if not tmp then
15561: LD_VAR 0 1
15565: NOT
15566: IFFALSE 15570
// exit ;
15568: GO 15648
// for i in tmp do
15570: LD_ADDR_VAR 0 2
15574: PUSH
15575: LD_VAR 0 1
15579: PUSH
15580: FOR_IN
15581: IFFALSE 15627
// begin SetTag ( i , 29 ) ;
15583: LD_VAR 0 2
15587: PPUSH
15588: LD_INT 29
15590: PPUSH
15591: CALL_OW 109
// ComExitBuilding ( i ) ;
15595: LD_VAR 0 2
15599: PPUSH
15600: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15604: LD_VAR 0 2
15608: PPUSH
15609: LD_INT 37
15611: PPUSH
15612: LD_INT 97
15614: PPUSH
15615: LD_INT 133
15617: PPUSH
15618: LD_INT 0
15620: PPUSH
15621: CALL_OW 230
// end ;
15625: GO 15580
15627: POP
15628: POP
// wait ( 1 1$00 ) ;
15629: LD_INT 2100
15631: PPUSH
15632: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15636: LD_EXP 7
15640: PPUSH
15641: LD_INT 29
15643: PPUSH
15644: CALL 65416 0 2
// end ;
15648: PPOPN 2
15650: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15651: LD_EXP 2
15655: PUSH
15656: LD_INT 1
15658: EQUAL
15659: PUSH
15660: LD_INT 84
15662: PPUSH
15663: LD_INT 128
15665: PPUSH
15666: CALL_OW 428
15670: PPUSH
15671: CALL_OW 266
15675: PUSH
15676: LD_INT 1
15678: EQUAL
15679: AND
15680: PUSH
15681: LD_INT 84
15683: PPUSH
15684: LD_INT 128
15686: PPUSH
15687: CALL_OW 428
15691: PPUSH
15692: CALL_OW 255
15696: PUSH
15697: LD_INT 3
15699: EQUAL
15700: AND
15701: IFFALSE 15874
15703: GO 15705
15705: DISABLE
15706: LD_INT 0
15708: PPUSH
15709: PPUSH
// begin enable ;
15710: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15711: LD_ADDR_VAR 0 2
15715: PUSH
15716: LD_INT 84
15718: PPUSH
15719: LD_INT 128
15721: PPUSH
15722: CALL_OW 428
15726: ST_TO_ADDR
// uc_side := 3 ;
15727: LD_ADDR_OWVAR 20
15731: PUSH
15732: LD_INT 3
15734: ST_TO_ADDR
// uc_nation := 3 ;
15735: LD_ADDR_OWVAR 21
15739: PUSH
15740: LD_INT 3
15742: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15743: LD_INT 21
15745: PPUSH
15746: LD_INT 3
15748: PPUSH
15749: LD_INT 3
15751: PPUSH
15752: LD_INT 51
15754: PPUSH
15755: LD_INT 0
15757: PPUSH
15758: CALL 24903 0 5
// veh := CreateVehicle ;
15762: LD_ADDR_VAR 0 1
15766: PUSH
15767: CALL_OW 45
15771: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15772: LD_VAR 0 1
15776: PPUSH
15777: LD_INT 126
15779: PPUSH
15780: LD_INT 227
15782: PPUSH
15783: LD_INT 0
15785: PPUSH
15786: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15790: LD_VAR 0 1
15794: PPUSH
15795: LD_INT 2
15797: PPUSH
15798: LD_INT 100
15800: PPUSH
15801: CALL_OW 290
// ComGive ( veh , depot ) ;
15805: LD_VAR 0 1
15809: PPUSH
15810: LD_VAR 0 2
15814: PPUSH
15815: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_INT 126
15826: PPUSH
15827: LD_INT 227
15829: PPUSH
15830: CALL_OW 171
// wait ( 0 0$10 ) ;
15834: LD_INT 350
15836: PPUSH
15837: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15841: LD_INT 35
15843: PPUSH
15844: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15848: LD_VAR 0 1
15852: PPUSH
15853: LD_INT 126
15855: PPUSH
15856: LD_INT 227
15858: PPUSH
15859: CALL_OW 307
15863: IFFALSE 15841
// RemoveUnit ( veh ) ;
15865: LD_VAR 0 1
15869: PPUSH
15870: CALL_OW 64
// end ;
15874: PPOPN 2
15876: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15877: LD_EXP 2
15881: PUSH
15882: LD_INT 1
15884: EQUAL
15885: PUSH
15886: LD_EXP 27
15890: AND
15891: PUSH
15892: LD_EXP 25
15896: PUSH
15897: LD_INT 2
15899: EQUAL
15900: AND
15901: IFFALSE 16093
15903: GO 15905
15905: DISABLE
15906: LD_INT 0
15908: PPUSH
15909: PPUSH
// begin enable ;
15910: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15911: LD_OWVAR 1
15915: PUSH
15916: LD_INT 105000
15918: PUSH
15919: LD_INT 84000
15921: PUSH
15922: LD_INT 63000
15924: PUSH
15925: EMPTY
15926: LIST
15927: LIST
15928: LIST
15929: PUSH
15930: LD_OWVAR 67
15934: ARRAY
15935: GREATEREQUAL
15936: IFFALSE 15939
// disable ;
15938: DISABLE
// uc_side := 4 ;
15939: LD_ADDR_OWVAR 20
15943: PUSH
15944: LD_INT 4
15946: ST_TO_ADDR
// uc_nation := 1 ;
15947: LD_ADDR_OWVAR 21
15951: PUSH
15952: LD_INT 1
15954: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15955: LD_INT 2
15957: PPUSH
15958: LD_INT 3
15960: PPUSH
15961: LD_INT 3
15963: PPUSH
15964: LD_INT 12
15966: PPUSH
15967: LD_INT 0
15969: PPUSH
15970: CALL 24903 0 5
// veh := CreateVehicle ;
15974: LD_ADDR_VAR 0 1
15978: PUSH
15979: CALL_OW 45
15983: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15984: LD_VAR 0 1
15988: PPUSH
15989: LD_INT 229
15991: PPUSH
15992: LD_INT 226
15994: PPUSH
15995: LD_INT 0
15997: PPUSH
15998: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16002: LD_VAR 0 1
16006: PPUSH
16007: LD_INT 1
16009: PPUSH
16010: LD_INT 100
16012: PPUSH
16013: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16017: LD_VAR 0 1
16021: PPUSH
16022: LD_INT 25
16024: PPUSH
16025: CALL_OW 173
// AddComUnload ( veh ) ;
16029: LD_VAR 0 1
16033: PPUSH
16034: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16038: LD_VAR 0 1
16042: PPUSH
16043: LD_INT 229
16045: PPUSH
16046: LD_INT 226
16048: PPUSH
16049: CALL_OW 171
// wait ( 0 0$10 ) ;
16053: LD_INT 350
16055: PPUSH
16056: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16060: LD_INT 35
16062: PPUSH
16063: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16067: LD_VAR 0 1
16071: PPUSH
16072: LD_INT 229
16074: PPUSH
16075: LD_INT 226
16077: PPUSH
16078: CALL_OW 307
16082: IFFALSE 16060
// RemoveUnit ( veh ) ;
16084: LD_VAR 0 1
16088: PPUSH
16089: CALL_OW 64
// end ;
16093: PPOPN 2
16095: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16096: LD_EXP 2
16100: PUSH
16101: LD_INT 1
16103: EQUAL
16104: PUSH
16105: LD_EXP 3
16109: AND
16110: PUSH
16111: LD_EXP 24
16115: AND
16116: IFFALSE 16449
16118: GO 16120
16120: DISABLE
16121: LD_INT 0
16123: PPUSH
16124: PPUSH
16125: PPUSH
16126: PPUSH
16127: PPUSH
// begin enable ;
16128: ENABLE
// tmp := [ ] ;
16129: LD_ADDR_VAR 0 4
16133: PUSH
16134: EMPTY
16135: ST_TO_ADDR
// if commander = 1 then
16136: LD_EXP 25
16140: PUSH
16141: LD_INT 1
16143: EQUAL
16144: IFFALSE 16156
// amount := 3 else
16146: LD_ADDR_VAR 0 5
16150: PUSH
16151: LD_INT 3
16153: ST_TO_ADDR
16154: GO 16164
// amount := 2 ;
16156: LD_ADDR_VAR 0 5
16160: PUSH
16161: LD_INT 2
16163: ST_TO_ADDR
// for i = 1 to amount do
16164: LD_ADDR_VAR 0 1
16168: PUSH
16169: DOUBLE
16170: LD_INT 1
16172: DEC
16173: ST_TO_ADDR
16174: LD_VAR 0 5
16178: PUSH
16179: FOR_TO
16180: IFFALSE 16344
// begin wait ( 0 0$5 ) ;
16182: LD_INT 175
16184: PPUSH
16185: CALL_OW 67
// for j = 1 to 3 do
16189: LD_ADDR_VAR 0 2
16193: PUSH
16194: DOUBLE
16195: LD_INT 1
16197: DEC
16198: ST_TO_ADDR
16199: LD_INT 3
16201: PUSH
16202: FOR_TO
16203: IFFALSE 16340
// begin uc_side := 4 ;
16205: LD_ADDR_OWVAR 20
16209: PUSH
16210: LD_INT 4
16212: ST_TO_ADDR
// uc_nation := 1 ;
16213: LD_ADDR_OWVAR 21
16217: PUSH
16218: LD_INT 1
16220: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16221: LD_INT 3
16223: PUSH
16224: LD_INT 5
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: PUSH
16231: LD_INT 1
16233: PPUSH
16234: LD_INT 2
16236: PPUSH
16237: CALL_OW 12
16241: ARRAY
16242: PPUSH
16243: LD_INT 3
16245: PPUSH
16246: LD_INT 3
16248: PPUSH
16249: LD_INT 9
16251: PUSH
16252: LD_INT 5
16254: PUSH
16255: LD_INT 7
16257: PUSH
16258: EMPTY
16259: LIST
16260: LIST
16261: LIST
16262: PUSH
16263: LD_INT 1
16265: PPUSH
16266: LD_INT 3
16268: PPUSH
16269: CALL_OW 12
16273: ARRAY
16274: PPUSH
16275: LD_INT 100
16277: PPUSH
16278: CALL 24903 0 5
// veh := CreateVehicle ;
16282: LD_ADDR_VAR 0 3
16286: PUSH
16287: CALL_OW 45
16291: ST_TO_ADDR
// tmp := tmp ^ veh ;
16292: LD_ADDR_VAR 0 4
16296: PUSH
16297: LD_VAR 0 4
16301: PUSH
16302: LD_VAR 0 3
16306: ADD
16307: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16308: LD_VAR 0 3
16312: PPUSH
16313: LD_INT 22
16315: PPUSH
16316: LD_INT 0
16318: PPUSH
16319: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16323: LD_VAR 0 3
16327: PPUSH
16328: LD_INT 119
16330: PPUSH
16331: LD_INT 215
16333: PPUSH
16334: CALL_OW 111
// end ;
16338: GO 16202
16340: POP
16341: POP
// end ;
16342: GO 16179
16344: POP
16345: POP
// wait ( 0 0$3 ) ;
16346: LD_INT 105
16348: PPUSH
16349: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16353: LD_INT 35
16355: PPUSH
16356: CALL_OW 67
// for i in tmp do
16360: LD_ADDR_VAR 0 1
16364: PUSH
16365: LD_VAR 0 4
16369: PUSH
16370: FOR_IN
16371: IFFALSE 16438
// if IsDead ( i ) then
16373: LD_VAR 0 1
16377: PPUSH
16378: CALL_OW 301
16382: IFFALSE 16402
// tmp := tmp diff i else
16384: LD_ADDR_VAR 0 4
16388: PUSH
16389: LD_VAR 0 4
16393: PUSH
16394: LD_VAR 0 1
16398: DIFF
16399: ST_TO_ADDR
16400: GO 16436
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16402: LD_VAR 0 1
16406: PPUSH
16407: LD_INT 81
16409: PUSH
16410: LD_INT 4
16412: PUSH
16413: EMPTY
16414: LIST
16415: LIST
16416: PPUSH
16417: CALL_OW 69
16421: PPUSH
16422: LD_VAR 0 1
16426: PPUSH
16427: CALL_OW 74
16431: PPUSH
16432: CALL_OW 115
16436: GO 16370
16438: POP
16439: POP
// until tmp = [ ] ;
16440: LD_VAR 0 4
16444: PUSH
16445: EMPTY
16446: EQUAL
16447: IFFALSE 16353
// end ;
16449: PPOPN 5
16451: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16452: LD_EXP 2
16456: PUSH
16457: LD_INT 1
16459: EQUAL
16460: PUSH
16461: LD_EXP 3
16465: AND
16466: IFFALSE 16567
16468: GO 16470
16470: DISABLE
16471: LD_INT 0
16473: PPUSH
16474: PPUSH
// begin enable ;
16475: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16476: LD_ADDR_VAR 0 2
16480: PUSH
16481: LD_INT 3
16483: PUSH
16484: LD_INT 22
16486: PUSH
16487: LD_INT 1
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: PUSH
16494: EMPTY
16495: LIST
16496: LIST
16497: PUSH
16498: LD_INT 32
16500: PUSH
16501: LD_INT 1
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PPUSH
16512: CALL_OW 69
16516: ST_TO_ADDR
// if tmp then
16517: LD_VAR 0 2
16521: IFFALSE 16567
// for i in tmp do
16523: LD_ADDR_VAR 0 1
16527: PUSH
16528: LD_VAR 0 2
16532: PUSH
16533: FOR_IN
16534: IFFALSE 16565
// if GetFuel ( i ) < 3 then
16536: LD_VAR 0 1
16540: PPUSH
16541: CALL_OW 261
16545: PUSH
16546: LD_INT 3
16548: LESS
16549: IFFALSE 16563
// SetFuel ( i , 3 ) ;
16551: LD_VAR 0 1
16555: PPUSH
16556: LD_INT 3
16558: PPUSH
16559: CALL_OW 240
16563: GO 16533
16565: POP
16566: POP
// end ;
16567: PPOPN 2
16569: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16570: LD_EXP 3
16574: PUSH
16575: LD_INT 8
16577: PPUSH
16578: LD_INT 4
16580: PPUSH
16581: CALL_OW 81
16585: PUSH
16586: LD_INT 2
16588: EQUAL
16589: AND
16590: IFFALSE 16800
16592: GO 16594
16594: DISABLE
16595: LD_INT 0
16597: PPUSH
16598: PPUSH
16599: PPUSH
// begin enable ;
16600: ENABLE
// tmp := [ ] ;
16601: LD_ADDR_VAR 0 3
16605: PUSH
16606: EMPTY
16607: ST_TO_ADDR
// for i = 1 to 4 do
16608: LD_ADDR_VAR 0 1
16612: PUSH
16613: DOUBLE
16614: LD_INT 1
16616: DEC
16617: ST_TO_ADDR
16618: LD_INT 4
16620: PUSH
16621: FOR_TO
16622: IFFALSE 16766
// begin uc_side := 8 ;
16624: LD_ADDR_OWVAR 20
16628: PUSH
16629: LD_INT 8
16631: ST_TO_ADDR
// uc_nation := nation_arabian ;
16632: LD_ADDR_OWVAR 21
16636: PUSH
16637: LD_INT 2
16639: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16640: LD_INT 11
16642: PPUSH
16643: LD_INT 1
16645: PPUSH
16646: LD_INT 5
16648: PPUSH
16649: LD_INT 24
16651: PUSH
16652: LD_INT 23
16654: PUSH
16655: EMPTY
16656: LIST
16657: LIST
16658: PUSH
16659: LD_INT 1
16661: PPUSH
16662: LD_INT 2
16664: PPUSH
16665: CALL_OW 12
16669: ARRAY
16670: PPUSH
16671: LD_INT 60
16673: PPUSH
16674: LD_INT 80
16676: PPUSH
16677: CALL_OW 12
16681: PPUSH
16682: CALL 24903 0 5
// un := CreateVehicle ;
16686: LD_ADDR_VAR 0 2
16690: PUSH
16691: CALL_OW 45
16695: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16696: LD_VAR 0 2
16700: PPUSH
16701: LD_INT 2
16703: PPUSH
16704: CALL_OW 233
// tmp := tmp ^ un ;
16708: LD_ADDR_VAR 0 3
16712: PUSH
16713: LD_VAR 0 3
16717: PUSH
16718: LD_VAR 0 2
16722: ADD
16723: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16724: LD_VAR 0 2
16728: PPUSH
16729: LD_INT 88
16731: PPUSH
16732: LD_INT 2
16734: PPUSH
16735: LD_INT 0
16737: PPUSH
16738: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16742: LD_VAR 0 2
16746: PPUSH
16747: LD_INT 93
16749: PPUSH
16750: LD_INT 13
16752: PPUSH
16753: CALL_OW 111
// wait ( 0 0$2 ) ;
16757: LD_INT 70
16759: PPUSH
16760: CALL_OW 67
// end ;
16764: GO 16621
16766: POP
16767: POP
// for i in tmp do
16768: LD_ADDR_VAR 0 1
16772: PUSH
16773: LD_VAR 0 3
16777: PUSH
16778: FOR_IN
16779: IFFALSE 16798
// AddComMoveXY ( i , 136 , 19 ) ;
16781: LD_VAR 0 1
16785: PPUSH
16786: LD_INT 136
16788: PPUSH
16789: LD_INT 19
16791: PPUSH
16792: CALL_OW 171
16796: GO 16778
16798: POP
16799: POP
// end ;
16800: PPOPN 3
16802: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16803: LD_EXP 3
16807: IFFALSE 17726
16809: GO 16811
16811: DISABLE
16812: LD_INT 0
16814: PPUSH
16815: PPUSH
16816: PPUSH
16817: PPUSH
// begin enable ;
16818: ENABLE
// base := mc_leg ;
16819: LD_ADDR_VAR 0 2
16823: PUSH
16824: LD_EXP 6
16828: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16829: LD_INT 22
16831: PUSH
16832: LD_INT 8
16834: PUSH
16835: EMPTY
16836: LIST
16837: LIST
16838: PUSH
16839: LD_INT 23
16841: PUSH
16842: LD_INT 2
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: PUSH
16849: LD_INT 30
16851: PUSH
16852: LD_INT 3
16854: PUSH
16855: EMPTY
16856: LIST
16857: LIST
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: LIST
16863: PPUSH
16864: CALL_OW 69
16868: NOT
16869: IFFALSE 16873
// exit ;
16871: GO 17726
// if Prob ( 40 ) then
16873: LD_INT 40
16875: PPUSH
16876: CALL_OW 13
16880: IFFALSE 17009
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16882: LD_VAR 0 2
16886: PPUSH
16887: LD_INT 13
16889: PUSH
16890: LD_INT 1
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: LD_INT 28
16898: PUSH
16899: EMPTY
16900: LIST
16901: LIST
16902: LIST
16903: LIST
16904: PUSH
16905: LD_INT 13
16907: PUSH
16908: LD_INT 1
16910: PUSH
16911: LD_INT 2
16913: PUSH
16914: LD_INT 28
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: PUSH
16923: LD_INT 13
16925: PUSH
16926: LD_INT 1
16928: PUSH
16929: LD_INT 2
16931: PUSH
16932: LD_INT 28
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: PUSH
16941: LD_INT 13
16943: PUSH
16944: LD_INT 1
16946: PUSH
16947: LD_INT 2
16949: PUSH
16950: LD_INT 28
16952: PUSH
16953: EMPTY
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: PUSH
16959: LD_INT 13
16961: PUSH
16962: LD_INT 1
16964: PUSH
16965: LD_INT 2
16967: PUSH
16968: LD_INT 28
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: PUSH
16977: LD_INT 13
16979: PUSH
16980: LD_INT 1
16982: PUSH
16983: LD_INT 2
16985: PUSH
16986: LD_INT 26
16988: PUSH
16989: EMPTY
16990: LIST
16991: LIST
16992: LIST
16993: LIST
16994: PUSH
16995: EMPTY
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: LIST
17001: LIST
17002: PPUSH
17003: CALL 85482 0 2
// end else
17007: GO 17226
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17009: LD_VAR 0 2
17013: PPUSH
17014: LD_INT 13
17016: PUSH
17017: LD_INT 1
17019: PUSH
17020: LD_INT 2
17022: PUSH
17023: LD_INT 27
17025: PUSH
17026: LD_INT 26
17028: PUSH
17029: LD_INT 26
17031: PUSH
17032: EMPTY
17033: LIST
17034: LIST
17035: LIST
17036: PUSH
17037: LD_INT 1
17039: PPUSH
17040: LD_INT 3
17042: PPUSH
17043: CALL_OW 12
17047: ARRAY
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: PUSH
17055: LD_INT 13
17057: PUSH
17058: LD_INT 1
17060: PUSH
17061: LD_INT 2
17063: PUSH
17064: LD_INT 27
17066: PUSH
17067: LD_INT 26
17069: PUSH
17070: LD_INT 26
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: PUSH
17078: LD_INT 1
17080: PPUSH
17081: LD_INT 3
17083: PPUSH
17084: CALL_OW 12
17088: ARRAY
17089: PUSH
17090: EMPTY
17091: LIST
17092: LIST
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 13
17098: PUSH
17099: LD_INT 1
17101: PUSH
17102: LD_INT 2
17104: PUSH
17105: LD_INT 26
17107: PUSH
17108: LD_INT 26
17110: PUSH
17111: LD_INT 29
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: PUSH
17119: LD_INT 1
17121: PPUSH
17122: LD_INT 3
17124: PPUSH
17125: CALL_OW 12
17129: ARRAY
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: LIST
17135: LIST
17136: PUSH
17137: LD_INT 13
17139: PUSH
17140: LD_INT 1
17142: PUSH
17143: LD_INT 2
17145: PUSH
17146: LD_INT 26
17148: PUSH
17149: LD_INT 29
17151: PUSH
17152: LD_INT 29
17154: PUSH
17155: EMPTY
17156: LIST
17157: LIST
17158: LIST
17159: PUSH
17160: LD_INT 1
17162: PPUSH
17163: LD_INT 3
17165: PPUSH
17166: CALL_OW 12
17170: ARRAY
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: PUSH
17178: LD_INT 13
17180: PUSH
17181: LD_INT 1
17183: PUSH
17184: LD_INT 2
17186: PUSH
17187: LD_INT 29
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: PUSH
17196: LD_INT 13
17198: PUSH
17199: LD_INT 1
17201: PUSH
17202: LD_INT 2
17204: PUSH
17205: LD_INT 26
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: PPUSH
17222: CALL 85482 0 2
// end ; repeat wait ( 0 0$1 ) ;
17226: LD_INT 35
17228: PPUSH
17229: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17233: LD_VAR 0 2
17237: PPUSH
17238: LD_INT 1
17240: PPUSH
17241: CALL 86900 0 2
17245: PUSH
17246: LD_INT 6
17248: GREATEREQUAL
17249: PUSH
17250: LD_OWVAR 1
17254: PUSH
17255: LD_INT 21000
17257: MOD
17258: PUSH
17259: LD_INT 0
17261: EQUAL
17262: OR
17263: IFFALSE 17226
// wait ( 0 0$30 ) ;
17265: LD_INT 1050
17267: PPUSH
17268: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17272: LD_ADDR_VAR 0 3
17276: PUSH
17277: LD_VAR 0 2
17281: PPUSH
17282: LD_INT 1
17284: PPUSH
17285: CALL 86900 0 2
17289: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17290: LD_ADDR_EXP 68
17294: PUSH
17295: LD_EXP 68
17299: PPUSH
17300: LD_VAR 0 2
17304: PPUSH
17305: LD_EXP 68
17309: PUSH
17310: LD_VAR 0 2
17314: ARRAY
17315: PUSH
17316: LD_VAR 0 3
17320: DIFF
17321: PPUSH
17322: CALL_OW 1
17326: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17327: LD_ADDR_VAR 0 4
17331: PUSH
17332: LD_INT 0
17334: PPUSH
17335: LD_INT 2
17337: PPUSH
17338: CALL_OW 12
17342: ST_TO_ADDR
// if legChangeSide then
17343: LD_EXP 21
17347: IFFALSE 17357
// target := 2 ;
17349: LD_ADDR_VAR 0 4
17353: PUSH
17354: LD_INT 2
17356: ST_TO_ADDR
// if target = 2 then
17357: LD_VAR 0 4
17361: PUSH
17362: LD_INT 2
17364: EQUAL
17365: IFFALSE 17493
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17367: LD_ADDR_VAR 0 3
17371: PUSH
17372: LD_VAR 0 3
17376: PPUSH
17377: LD_INT 24
17379: PUSH
17380: LD_INT 250
17382: PUSH
17383: EMPTY
17384: LIST
17385: LIST
17386: PPUSH
17387: CALL_OW 72
17391: ST_TO_ADDR
// for i in tmp do
17392: LD_ADDR_VAR 0 1
17396: PUSH
17397: LD_VAR 0 3
17401: PUSH
17402: FOR_IN
17403: IFFALSE 17443
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17405: LD_VAR 0 1
17409: PPUSH
17410: LD_INT 112
17412: PPUSH
17413: LD_INT 64
17415: PPUSH
17416: CALL_OW 297
17420: PUSH
17421: LD_INT 9
17423: GREATER
17424: IFFALSE 17441
// ComMoveXY ( i , 112 , 64 ) ;
17426: LD_VAR 0 1
17430: PPUSH
17431: LD_INT 112
17433: PPUSH
17434: LD_INT 64
17436: PPUSH
17437: CALL_OW 111
17441: GO 17402
17443: POP
17444: POP
// wait ( 0 0$1 ) ;
17445: LD_INT 35
17447: PPUSH
17448: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17452: LD_VAR 0 3
17456: PPUSH
17457: LD_INT 92
17459: PUSH
17460: LD_INT 112
17462: PUSH
17463: LD_INT 64
17465: PUSH
17466: LD_INT 9
17468: PUSH
17469: EMPTY
17470: LIST
17471: LIST
17472: LIST
17473: LIST
17474: PPUSH
17475: CALL_OW 72
17479: PUSH
17480: LD_VAR 0 3
17484: PUSH
17485: LD_INT 1
17487: MINUS
17488: GREATEREQUAL
17489: IFFALSE 17367
// end else
17491: GO 17617
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17493: LD_ADDR_VAR 0 3
17497: PUSH
17498: LD_VAR 0 3
17502: PPUSH
17503: LD_INT 24
17505: PUSH
17506: LD_INT 250
17508: PUSH
17509: EMPTY
17510: LIST
17511: LIST
17512: PPUSH
17513: CALL_OW 72
17517: ST_TO_ADDR
// for i in tmp do
17518: LD_ADDR_VAR 0 1
17522: PUSH
17523: LD_VAR 0 3
17527: PUSH
17528: FOR_IN
17529: IFFALSE 17569
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17531: LD_VAR 0 1
17535: PPUSH
17536: LD_INT 174
17538: PPUSH
17539: LD_INT 94
17541: PPUSH
17542: CALL_OW 297
17546: PUSH
17547: LD_INT 9
17549: GREATER
17550: IFFALSE 17567
// ComMoveXY ( i , 174 , 94 ) ;
17552: LD_VAR 0 1
17556: PPUSH
17557: LD_INT 174
17559: PPUSH
17560: LD_INT 94
17562: PPUSH
17563: CALL_OW 111
17567: GO 17528
17569: POP
17570: POP
// wait ( 0 0$1 ) ;
17571: LD_INT 35
17573: PPUSH
17574: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17578: LD_VAR 0 3
17582: PPUSH
17583: LD_INT 92
17585: PUSH
17586: LD_INT 174
17588: PUSH
17589: LD_INT 94
17591: PUSH
17592: LD_INT 9
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: LIST
17599: LIST
17600: PPUSH
17601: CALL_OW 72
17605: PUSH
17606: LD_VAR 0 3
17610: PUSH
17611: LD_INT 1
17613: MINUS
17614: GREATEREQUAL
17615: IFFALSE 17493
// end ; repeat wait ( 0 0$1 ) ;
17617: LD_INT 35
17619: PPUSH
17620: CALL_OW 67
// for i in tmp do
17624: LD_ADDR_VAR 0 1
17628: PUSH
17629: LD_VAR 0 3
17633: PUSH
17634: FOR_IN
17635: IFFALSE 17717
// begin if GetLives ( i ) > 251 then
17637: LD_VAR 0 1
17641: PPUSH
17642: CALL_OW 256
17646: PUSH
17647: LD_INT 251
17649: GREATER
17650: IFFALSE 17688
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17652: LD_VAR 0 1
17656: PPUSH
17657: LD_INT 81
17659: PUSH
17660: LD_INT 8
17662: PUSH
17663: EMPTY
17664: LIST
17665: LIST
17666: PPUSH
17667: CALL_OW 69
17671: PPUSH
17672: LD_VAR 0 1
17676: PPUSH
17677: CALL_OW 74
17681: PPUSH
17682: CALL_OW 115
17686: GO 17715
// if IsDead ( i ) then
17688: LD_VAR 0 1
17692: PPUSH
17693: CALL_OW 301
17697: IFFALSE 17715
// tmp := tmp diff i ;
17699: LD_ADDR_VAR 0 3
17703: PUSH
17704: LD_VAR 0 3
17708: PUSH
17709: LD_VAR 0 1
17713: DIFF
17714: ST_TO_ADDR
// end ;
17715: GO 17634
17717: POP
17718: POP
// until not tmp ;
17719: LD_VAR 0 3
17723: NOT
17724: IFFALSE 17617
// end ;
17726: PPOPN 4
17728: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17729: LD_EXP 3
17733: IFFALSE 18721
17735: GO 17737
17737: DISABLE
17738: LD_INT 0
17740: PPUSH
17741: PPUSH
17742: PPUSH
17743: PPUSH
17744: PPUSH
// begin enable ;
17745: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17746: LD_EXP 49
17750: PUSH
17751: LD_EXP 8
17755: ARRAY
17756: PPUSH
17757: LD_INT 22
17759: PUSH
17760: LD_INT 3
17762: PUSH
17763: EMPTY
17764: LIST
17765: LIST
17766: PUSH
17767: LD_INT 30
17769: PUSH
17770: LD_INT 3
17772: PUSH
17773: EMPTY
17774: LIST
17775: LIST
17776: PUSH
17777: EMPTY
17778: LIST
17779: LIST
17780: PPUSH
17781: CALL_OW 72
17785: NOT
17786: IFFALSE 17790
// exit ;
17788: GO 18721
// base := mc_rus_2 ;
17790: LD_ADDR_VAR 0 2
17794: PUSH
17795: LD_EXP 8
17799: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17800: LD_ADDR_VAR 0 5
17804: PUSH
17805: LD_INT 22
17807: PUSH
17808: LD_INT 3
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: PUSH
17815: LD_INT 30
17817: PUSH
17818: LD_INT 34
17820: PUSH
17821: EMPTY
17822: LIST
17823: LIST
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PPUSH
17829: CALL_OW 69
17833: ST_TO_ADDR
// if Prob ( 40 ) then
17834: LD_INT 40
17836: PPUSH
17837: CALL_OW 13
17841: IFFALSE 17970
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17843: LD_VAR 0 2
17847: PPUSH
17848: LD_INT 22
17850: PUSH
17851: LD_INT 3
17853: PUSH
17854: LD_INT 3
17856: PUSH
17857: LD_INT 49
17859: PUSH
17860: EMPTY
17861: LIST
17862: LIST
17863: LIST
17864: LIST
17865: PUSH
17866: LD_INT 22
17868: PUSH
17869: LD_INT 3
17871: PUSH
17872: LD_INT 3
17874: PUSH
17875: LD_INT 49
17877: PUSH
17878: EMPTY
17879: LIST
17880: LIST
17881: LIST
17882: LIST
17883: PUSH
17884: LD_INT 22
17886: PUSH
17887: LD_INT 3
17889: PUSH
17890: LD_INT 3
17892: PUSH
17893: LD_INT 49
17895: PUSH
17896: EMPTY
17897: LIST
17898: LIST
17899: LIST
17900: LIST
17901: PUSH
17902: LD_INT 24
17904: PUSH
17905: LD_INT 3
17907: PUSH
17908: LD_INT 3
17910: PUSH
17911: LD_INT 46
17913: PUSH
17914: EMPTY
17915: LIST
17916: LIST
17917: LIST
17918: LIST
17919: PUSH
17920: LD_INT 24
17922: PUSH
17923: LD_INT 3
17925: PUSH
17926: LD_INT 3
17928: PUSH
17929: LD_INT 46
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: PUSH
17938: LD_INT 24
17940: PUSH
17941: LD_INT 3
17943: PUSH
17944: LD_INT 3
17946: PUSH
17947: LD_INT 46
17949: PUSH
17950: EMPTY
17951: LIST
17952: LIST
17953: LIST
17954: LIST
17955: PUSH
17956: EMPTY
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: LIST
17962: LIST
17963: PPUSH
17964: CALL 85482 0 2
// end else
17968: GO 18095
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17970: LD_VAR 0 2
17974: PPUSH
17975: LD_INT 24
17977: PUSH
17978: LD_INT 3
17980: PUSH
17981: LD_INT 3
17983: PUSH
17984: LD_INT 47
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 24
17995: PUSH
17996: LD_INT 3
17998: PUSH
17999: LD_INT 3
18001: PUSH
18002: LD_INT 47
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: PUSH
18011: LD_INT 24
18013: PUSH
18014: LD_INT 3
18016: PUSH
18017: LD_INT 3
18019: PUSH
18020: LD_INT 47
18022: PUSH
18023: EMPTY
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: PUSH
18029: LD_INT 24
18031: PUSH
18032: LD_INT 3
18034: PUSH
18035: LD_INT 3
18037: PUSH
18038: LD_INT 46
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: PUSH
18047: LD_INT 24
18049: PUSH
18050: LD_INT 3
18052: PUSH
18053: LD_INT 3
18055: PUSH
18056: LD_INT 46
18058: PUSH
18059: EMPTY
18060: LIST
18061: LIST
18062: LIST
18063: LIST
18064: PUSH
18065: LD_INT 24
18067: PUSH
18068: LD_INT 3
18070: PUSH
18071: LD_INT 3
18073: PUSH
18074: LD_INT 46
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: LIST
18081: LIST
18082: PUSH
18083: EMPTY
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: LIST
18089: LIST
18090: PPUSH
18091: CALL 85482 0 2
// end ; if Difficulty > 1 then
18095: LD_OWVAR 67
18099: PUSH
18100: LD_INT 1
18102: GREATER
18103: IFFALSE 18135
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18105: LD_VAR 0 2
18109: PPUSH
18110: LD_INT 24
18112: PUSH
18113: LD_INT 3
18115: PUSH
18116: LD_INT 3
18118: PUSH
18119: LD_INT 47
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: LIST
18126: LIST
18127: PUSH
18128: EMPTY
18129: LIST
18130: PPUSH
18131: CALL 85482 0 2
// repeat wait ( 0 0$1 ) ;
18135: LD_INT 35
18137: PPUSH
18138: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18142: LD_VAR 0 2
18146: PPUSH
18147: LD_INT 1
18149: PPUSH
18150: CALL 86900 0 2
18154: PUSH
18155: LD_INT 6
18157: PUSH
18158: LD_INT 7
18160: PUSH
18161: LD_INT 7
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: LIST
18168: PUSH
18169: LD_OWVAR 67
18173: ARRAY
18174: GREATEREQUAL
18175: PUSH
18176: LD_OWVAR 1
18180: PUSH
18181: LD_INT 21000
18183: MOD
18184: PUSH
18185: LD_INT 0
18187: EQUAL
18188: OR
18189: IFFALSE 18135
// wait ( 0 0$45 ) ;
18191: LD_INT 1575
18193: PPUSH
18194: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18198: LD_ADDR_VAR 0 3
18202: PUSH
18203: LD_VAR 0 2
18207: PPUSH
18208: LD_INT 1
18210: PPUSH
18211: CALL 86900 0 2
18215: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18216: LD_ADDR_EXP 68
18220: PUSH
18221: LD_EXP 68
18225: PPUSH
18226: LD_VAR 0 2
18230: PPUSH
18231: LD_EXP 68
18235: PUSH
18236: LD_VAR 0 2
18240: ARRAY
18241: PUSH
18242: LD_VAR 0 3
18246: DIFF
18247: PPUSH
18248: CALL_OW 1
18252: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18253: LD_ADDR_VAR 0 4
18257: PUSH
18258: LD_INT 0
18260: PPUSH
18261: LD_INT 1
18263: PPUSH
18264: CALL_OW 12
18268: ST_TO_ADDR
// if target then
18269: LD_VAR 0 4
18273: IFFALSE 18401
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18275: LD_ADDR_VAR 0 3
18279: PUSH
18280: LD_VAR 0 3
18284: PPUSH
18285: LD_INT 24
18287: PUSH
18288: LD_INT 250
18290: PUSH
18291: EMPTY
18292: LIST
18293: LIST
18294: PPUSH
18295: CALL_OW 72
18299: ST_TO_ADDR
// for i in tmp do
18300: LD_ADDR_VAR 0 1
18304: PUSH
18305: LD_VAR 0 3
18309: PUSH
18310: FOR_IN
18311: IFFALSE 18351
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18313: LD_VAR 0 1
18317: PPUSH
18318: LD_INT 84
18320: PPUSH
18321: LD_INT 32
18323: PPUSH
18324: CALL_OW 297
18328: PUSH
18329: LD_INT 9
18331: GREATER
18332: IFFALSE 18349
// ComMoveXY ( i , 84 , 32 ) ;
18334: LD_VAR 0 1
18338: PPUSH
18339: LD_INT 84
18341: PPUSH
18342: LD_INT 32
18344: PPUSH
18345: CALL_OW 111
18349: GO 18310
18351: POP
18352: POP
// wait ( 0 0$1 ) ;
18353: LD_INT 35
18355: PPUSH
18356: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18360: LD_VAR 0 3
18364: PPUSH
18365: LD_INT 92
18367: PUSH
18368: LD_INT 84
18370: PUSH
18371: LD_INT 32
18373: PUSH
18374: LD_INT 9
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: LIST
18381: LIST
18382: PPUSH
18383: CALL_OW 72
18387: PUSH
18388: LD_VAR 0 3
18392: PUSH
18393: LD_INT 1
18395: MINUS
18396: GREATEREQUAL
18397: IFFALSE 18275
// end else
18399: GO 18561
// begin if teleport then
18401: LD_VAR 0 5
18405: IFFALSE 18425
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18407: LD_VAR 0 3
18411: PPUSH
18412: LD_VAR 0 5
18416: PUSH
18417: LD_INT 1
18419: ARRAY
18420: PPUSH
18421: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18425: LD_ADDR_VAR 0 3
18429: PUSH
18430: LD_VAR 0 3
18434: PPUSH
18435: LD_INT 24
18437: PUSH
18438: LD_INT 250
18440: PUSH
18441: EMPTY
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL_OW 72
18449: ST_TO_ADDR
// for i in tmp do
18450: LD_ADDR_VAR 0 1
18454: PUSH
18455: LD_VAR 0 3
18459: PUSH
18460: FOR_IN
18461: IFFALSE 18513
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18463: LD_VAR 0 1
18467: PPUSH
18468: LD_INT 140
18470: PPUSH
18471: LD_INT 219
18473: PPUSH
18474: CALL_OW 297
18478: PUSH
18479: LD_INT 9
18481: GREATER
18482: PUSH
18483: LD_VAR 0 1
18487: PPUSH
18488: CALL_OW 314
18492: NOT
18493: AND
18494: IFFALSE 18511
// AddComMoveXY ( i , 140 , 219 ) ;
18496: LD_VAR 0 1
18500: PPUSH
18501: LD_INT 140
18503: PPUSH
18504: LD_INT 219
18506: PPUSH
18507: CALL_OW 171
18511: GO 18460
18513: POP
18514: POP
// wait ( 0 0$1 ) ;
18515: LD_INT 35
18517: PPUSH
18518: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18522: LD_VAR 0 3
18526: PPUSH
18527: LD_INT 92
18529: PUSH
18530: LD_INT 140
18532: PUSH
18533: LD_INT 219
18535: PUSH
18536: LD_INT 9
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: LIST
18543: LIST
18544: PPUSH
18545: CALL_OW 72
18549: PUSH
18550: LD_VAR 0 3
18554: PUSH
18555: LD_INT 1
18557: MINUS
18558: GREATEREQUAL
18559: IFFALSE 18425
// end ; repeat wait ( 0 0$1 ) ;
18561: LD_INT 35
18563: PPUSH
18564: CALL_OW 67
// for i in tmp do
18568: LD_ADDR_VAR 0 1
18572: PUSH
18573: LD_VAR 0 3
18577: PUSH
18578: FOR_IN
18579: IFFALSE 18712
// begin if GetLives ( i ) > 251 then
18581: LD_VAR 0 1
18585: PPUSH
18586: CALL_OW 256
18590: PUSH
18591: LD_INT 251
18593: GREATER
18594: IFFALSE 18683
// begin if GetWeapon ( i ) = ru_time_lapser then
18596: LD_VAR 0 1
18600: PPUSH
18601: CALL_OW 264
18605: PUSH
18606: LD_INT 49
18608: EQUAL
18609: IFFALSE 18647
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18611: LD_VAR 0 1
18615: PPUSH
18616: LD_INT 81
18618: PUSH
18619: LD_INT 3
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PPUSH
18626: CALL_OW 69
18630: PPUSH
18631: LD_VAR 0 1
18635: PPUSH
18636: CALL_OW 74
18640: PPUSH
18641: CALL_OW 112
18645: GO 18681
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18647: LD_VAR 0 1
18651: PPUSH
18652: LD_INT 81
18654: PUSH
18655: LD_INT 3
18657: PUSH
18658: EMPTY
18659: LIST
18660: LIST
18661: PPUSH
18662: CALL_OW 69
18666: PPUSH
18667: LD_VAR 0 1
18671: PPUSH
18672: CALL_OW 74
18676: PPUSH
18677: CALL_OW 115
// end else
18681: GO 18710
// if IsDead ( i ) then
18683: LD_VAR 0 1
18687: PPUSH
18688: CALL_OW 301
18692: IFFALSE 18710
// tmp := tmp diff i ;
18694: LD_ADDR_VAR 0 3
18698: PUSH
18699: LD_VAR 0 3
18703: PUSH
18704: LD_VAR 0 1
18708: DIFF
18709: ST_TO_ADDR
// end ;
18710: GO 18578
18712: POP
18713: POP
// until not tmp ;
18714: LD_VAR 0 3
18718: NOT
18719: IFFALSE 18561
// end ;
18721: PPOPN 5
18723: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18724: LD_EXP 3
18728: IFFALSE 19110
18730: GO 18732
18732: DISABLE
18733: LD_INT 0
18735: PPUSH
18736: PPUSH
18737: PPUSH
18738: PPUSH
// begin enable ;
18739: ENABLE
// base := mc_amer ;
18740: LD_ADDR_VAR 0 2
18744: PUSH
18745: LD_EXP 5
18749: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18750: LD_INT 22
18752: PUSH
18753: LD_INT 4
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PUSH
18760: LD_INT 23
18762: PUSH
18763: LD_INT 1
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PUSH
18770: LD_INT 30
18772: PUSH
18773: LD_INT 3
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: LIST
18784: PPUSH
18785: CALL_OW 69
18789: NOT
18790: IFFALSE 18794
// exit ;
18792: GO 19110
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18794: LD_VAR 0 2
18798: PPUSH
18799: LD_INT 3
18801: PUSH
18802: LD_INT 1
18804: PUSH
18805: LD_INT 2
18807: PUSH
18808: LD_INT 5
18810: PUSH
18811: EMPTY
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 3
18819: PUSH
18820: LD_INT 1
18822: PUSH
18823: LD_INT 2
18825: PUSH
18826: LD_INT 9
18828: PUSH
18829: EMPTY
18830: LIST
18831: LIST
18832: LIST
18833: LIST
18834: PUSH
18835: LD_INT 3
18837: PUSH
18838: LD_INT 1
18840: PUSH
18841: LD_INT 2
18843: PUSH
18844: LD_INT 7
18846: PUSH
18847: EMPTY
18848: LIST
18849: LIST
18850: LIST
18851: LIST
18852: PUSH
18853: LD_INT 3
18855: PUSH
18856: LD_INT 1
18858: PUSH
18859: LD_INT 2
18861: PUSH
18862: LD_INT 7
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: LIST
18869: LIST
18870: PUSH
18871: LD_INT 3
18873: PUSH
18874: LD_INT 1
18876: PUSH
18877: LD_INT 2
18879: PUSH
18880: LD_INT 7
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: LIST
18887: LIST
18888: PUSH
18889: EMPTY
18890: LIST
18891: LIST
18892: LIST
18893: LIST
18894: LIST
18895: PPUSH
18896: CALL 85482 0 2
// repeat wait ( 0 0$1 ) ;
18900: LD_INT 35
18902: PPUSH
18903: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18907: LD_VAR 0 2
18911: PPUSH
18912: LD_INT 1
18914: PPUSH
18915: CALL 86900 0 2
18919: PUSH
18920: LD_INT 5
18922: GREATEREQUAL
18923: PUSH
18924: LD_OWVAR 1
18928: PUSH
18929: LD_INT 21000
18931: MOD
18932: PUSH
18933: LD_INT 0
18935: EQUAL
18936: OR
18937: IFFALSE 18900
// wait ( 0 0$30 ) ;
18939: LD_INT 1050
18941: PPUSH
18942: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18946: LD_ADDR_VAR 0 3
18950: PUSH
18951: LD_VAR 0 2
18955: PPUSH
18956: LD_INT 1
18958: PPUSH
18959: CALL 86900 0 2
18963: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18964: LD_ADDR_EXP 68
18968: PUSH
18969: LD_EXP 68
18973: PPUSH
18974: LD_VAR 0 2
18978: PPUSH
18979: LD_EXP 68
18983: PUSH
18984: LD_VAR 0 2
18988: ARRAY
18989: PUSH
18990: LD_VAR 0 3
18994: DIFF
18995: PPUSH
18996: CALL_OW 1
19000: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19001: LD_INT 35
19003: PPUSH
19004: CALL_OW 67
// for i in tmp do
19008: LD_ADDR_VAR 0 1
19012: PUSH
19013: LD_VAR 0 3
19017: PUSH
19018: FOR_IN
19019: IFFALSE 19101
// begin if GetLives ( i ) > 251 then
19021: LD_VAR 0 1
19025: PPUSH
19026: CALL_OW 256
19030: PUSH
19031: LD_INT 251
19033: GREATER
19034: IFFALSE 19072
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19036: LD_VAR 0 1
19040: PPUSH
19041: LD_INT 81
19043: PUSH
19044: LD_INT 4
19046: PUSH
19047: EMPTY
19048: LIST
19049: LIST
19050: PPUSH
19051: CALL_OW 69
19055: PPUSH
19056: LD_VAR 0 1
19060: PPUSH
19061: CALL_OW 74
19065: PPUSH
19066: CALL_OW 115
19070: GO 19099
// if IsDead ( i ) then
19072: LD_VAR 0 1
19076: PPUSH
19077: CALL_OW 301
19081: IFFALSE 19099
// tmp := tmp diff i ;
19083: LD_ADDR_VAR 0 3
19087: PUSH
19088: LD_VAR 0 3
19092: PUSH
19093: LD_VAR 0 1
19097: DIFF
19098: ST_TO_ADDR
// end ;
19099: GO 19018
19101: POP
19102: POP
// until not tmp ;
19103: LD_VAR 0 3
19107: NOT
19108: IFFALSE 19001
// end ; end_of_file
19110: PPOPN 4
19112: END
// export function CustomEvent ( event ) ; begin
19113: LD_INT 0
19115: PPUSH
// end ;
19116: LD_VAR 0 2
19120: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19121: LD_VAR 0 1
19125: PUSH
19126: LD_INT 1
19128: EQUAL
19129: PUSH
19130: LD_VAR 0 2
19134: PUSH
19135: LD_INT 4
19137: EQUAL
19138: AND
19139: IFFALSE 19167
// begin SayRadio ( Powell , DP-Lost ) ;
19141: LD_EXP 12
19145: PPUSH
19146: LD_STRING DP-Lost
19148: PPUSH
19149: CALL_OW 94
// wait ( 0 0$2 ) ;
19153: LD_INT 70
19155: PPUSH
19156: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19160: LD_STRING FriendlyFire
19162: PPUSH
19163: CALL_OW 104
// end ; end ;
19167: PPOPN 2
19169: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19170: LD_VAR 0 1
19174: PPUSH
19175: CALL 107539 0 1
// if GameType = 1 then
19179: LD_EXP 2
19183: PUSH
19184: LD_INT 1
19186: EQUAL
19187: IFFALSE 19422
// begin if un = playerCommander then
19189: LD_VAR 0 1
19193: PUSH
19194: LD_EXP 9
19198: EQUAL
19199: IFFALSE 19208
// YouLost ( commanderDied ) ;
19201: LD_STRING commanderDied
19203: PPUSH
19204: CALL_OW 104
// if un = allyCommander then
19208: LD_VAR 0 1
19212: PUSH
19213: LD_EXP 11
19217: EQUAL
19218: IFFALSE 19227
// YouLost ( Theta ) ;
19220: LD_STRING Theta
19222: PPUSH
19223: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19227: LD_VAR 0 1
19231: PUSH
19232: LD_INT 22
19234: PUSH
19235: LD_INT 8
19237: PUSH
19238: EMPTY
19239: LIST
19240: LIST
19241: PUSH
19242: LD_INT 2
19244: PUSH
19245: LD_INT 21
19247: PUSH
19248: LD_INT 1
19250: PUSH
19251: EMPTY
19252: LIST
19253: LIST
19254: PUSH
19255: LD_INT 21
19257: PUSH
19258: LD_INT 3
19260: PUSH
19261: EMPTY
19262: LIST
19263: LIST
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: LIST
19269: PUSH
19270: EMPTY
19271: LIST
19272: LIST
19273: PPUSH
19274: CALL_OW 69
19278: IN
19279: IFFALSE 19295
// legDestCounter := legDestCounter + 1 ;
19281: LD_ADDR_EXP 18
19285: PUSH
19286: LD_EXP 18
19290: PUSH
19291: LD_INT 1
19293: PLUS
19294: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19295: LD_VAR 0 1
19299: PUSH
19300: LD_INT 22
19302: PUSH
19303: LD_INT 4
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: PUSH
19310: LD_INT 2
19312: PUSH
19313: LD_INT 21
19315: PUSH
19316: LD_INT 1
19318: PUSH
19319: EMPTY
19320: LIST
19321: LIST
19322: PUSH
19323: LD_INT 21
19325: PUSH
19326: LD_INT 3
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: LIST
19337: PUSH
19338: EMPTY
19339: LIST
19340: LIST
19341: PPUSH
19342: CALL_OW 69
19346: IN
19347: IFFALSE 19363
// allyDestCounter := allyDestCounter + 1 ;
19349: LD_ADDR_EXP 22
19353: PUSH
19354: LD_EXP 22
19358: PUSH
19359: LD_INT 1
19361: PLUS
19362: ST_TO_ADDR
// if un in ruOutpost then
19363: LD_VAR 0 1
19367: PUSH
19368: LD_EXP 14
19372: IN
19373: IFFALSE 19422
// begin ruOutpost := ruOutpost diff un ;
19375: LD_ADDR_EXP 14
19379: PUSH
19380: LD_EXP 14
19384: PUSH
19385: LD_VAR 0 1
19389: DIFF
19390: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19391: LD_ADDR_EXP 15
19395: PUSH
19396: LD_EXP 15
19400: PPUSH
19401: LD_INT 1
19403: PPUSH
19404: LD_EXP 15
19408: PUSH
19409: LD_INT 1
19411: ARRAY
19412: PUSH
19413: LD_INT 1
19415: PLUS
19416: PPUSH
19417: CALL_OW 1
19421: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19422: LD_VAR 0 1
19426: PPUSH
19427: CALL 88902 0 1
// end ;
19431: PPOPN 1
19433: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19434: LD_VAR 0 1
19438: PPUSH
19439: LD_VAR 0 2
19443: PPUSH
19444: CALL 91236 0 2
// end ;
19448: PPOPN 2
19450: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19451: LD_VAR 0 1
19455: PPUSH
19456: CALL 90304 0 1
// end ;
19460: PPOPN 1
19462: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19463: LD_VAR 0 1
19467: PPUSH
19468: CALL 90545 0 1
// end ;
19472: PPOPN 1
19474: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19475: LD_VAR 0 1
19479: PUSH
19480: LD_INT 14
19482: EQUAL
19483: PUSH
19484: LD_VAR 0 2
19488: PPUSH
19489: CALL_OW 255
19493: PUSH
19494: LD_INT 1
19496: EQUAL
19497: AND
19498: IFFALSE 19539
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19500: LD_EXP 9
19504: PPUSH
19505: LD_STRING D
19507: PUSH
19508: LD_STRING I
19510: PUSH
19511: LD_STRING J
19513: PUSH
19514: LD_STRING S
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: LIST
19521: PUSH
19522: LD_EXP 25
19526: ARRAY
19527: STR
19528: PUSH
19529: LD_STRING -1-Laser
19531: STR
19532: PPUSH
19533: CALL_OW 88
// exit ;
19537: GO 19681
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19539: LD_VAR 0 1
19543: PUSH
19544: LD_INT 7
19546: EQUAL
19547: PUSH
19548: LD_VAR 0 2
19552: PPUSH
19553: CALL_OW 255
19557: PUSH
19558: LD_INT 1
19560: EQUAL
19561: AND
19562: IFFALSE 19603
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19564: LD_EXP 9
19568: PPUSH
19569: LD_STRING D
19571: PUSH
19572: LD_STRING I
19574: PUSH
19575: LD_STRING J
19577: PUSH
19578: LD_STRING S
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: PUSH
19586: LD_EXP 25
19590: ARRAY
19591: STR
19592: PUSH
19593: LD_STRING -1-Materialization
19595: STR
19596: PPUSH
19597: CALL_OW 88
// exit ;
19601: GO 19681
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19603: LD_VAR 0 1
19607: PUSH
19608: LD_INT 25
19610: EQUAL
19611: PUSH
19612: LD_VAR 0 2
19616: PPUSH
19617: CALL_OW 255
19621: PUSH
19622: LD_INT 1
19624: EQUAL
19625: AND
19626: IFFALSE 19667
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19628: LD_EXP 9
19632: PPUSH
19633: LD_STRING D
19635: PUSH
19636: LD_STRING I
19638: PUSH
19639: LD_STRING J
19641: PUSH
19642: LD_STRING S
19644: PUSH
19645: EMPTY
19646: LIST
19647: LIST
19648: LIST
19649: PUSH
19650: LD_EXP 25
19654: ARRAY
19655: STR
19656: PUSH
19657: LD_STRING -1-Rocket
19659: STR
19660: PPUSH
19661: CALL_OW 88
// exit ;
19665: GO 19681
// end ; MCE_ResearchComplete ( tech , lab ) ;
19667: LD_VAR 0 1
19671: PPUSH
19672: LD_VAR 0 2
19676: PPUSH
19677: CALL 88598 0 2
// end ;
19681: PPOPN 2
19683: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19684: LD_VAR 0 1
19688: PPUSH
19689: LD_VAR 0 2
19693: PPUSH
19694: LD_VAR 0 3
19698: PPUSH
19699: LD_VAR 0 4
19703: PPUSH
19704: LD_VAR 0 5
19708: PPUSH
19709: CALL 88218 0 5
// end ;
19713: PPOPN 5
19715: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19716: LD_VAR 0 1
19720: PPUSH
19721: LD_VAR 0 2
19725: PPUSH
19726: CALL 107661 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19730: LD_VAR 0 1
19734: PPUSH
19735: LD_VAR 0 2
19739: PPUSH
19740: CALL 87799 0 2
// end ;
19744: PPOPN 2
19746: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19747: LD_VAR 0 1
19751: PPUSH
19752: LD_VAR 0 2
19756: PPUSH
19757: LD_VAR 0 3
19761: PPUSH
19762: LD_VAR 0 4
19766: PPUSH
19767: CALL 87637 0 4
// end ;
19771: PPOPN 4
19773: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19774: LD_VAR 0 1
19778: PPUSH
19779: LD_VAR 0 2
19783: PPUSH
19784: LD_VAR 0 3
19788: PPUSH
19789: CALL 87412 0 3
// end ;
19793: PPOPN 3
19795: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19796: LD_VAR 0 1
19800: PPUSH
19801: LD_VAR 0 2
19805: PPUSH
19806: CALL 87297 0 2
// end ;
19810: PPOPN 2
19812: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19813: LD_VAR 0 1
19817: PPUSH
19818: LD_VAR 0 2
19822: PPUSH
19823: CALL 91531 0 2
// end ;
19827: PPOPN 2
19829: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19830: LD_VAR 0 1
19834: PPUSH
19835: LD_VAR 0 2
19839: PPUSH
19840: LD_VAR 0 3
19844: PPUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: CALL 91747 0 4
// end ;
19854: PPOPN 4
19856: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19857: LD_VAR 0 1
19861: PPUSH
19862: LD_VAR 0 2
19866: PPUSH
19867: CALL 87106 0 2
// end ;
19871: PPOPN 2
19873: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19874: LD_VAR 0 1
19878: PPUSH
19879: CALL 107645 0 1
// end ; end_of_file
19883: PPOPN 1
19885: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19886: LD_INT 0
19888: PPUSH
19889: PPUSH
// if exist_mode then
19890: LD_VAR 0 2
19894: IFFALSE 19919
// unit := CreateCharacter ( prefix & ident ) else
19896: LD_ADDR_VAR 0 5
19900: PUSH
19901: LD_VAR 0 3
19905: PUSH
19906: LD_VAR 0 1
19910: STR
19911: PPUSH
19912: CALL_OW 34
19916: ST_TO_ADDR
19917: GO 19934
// unit := NewCharacter ( ident ) ;
19919: LD_ADDR_VAR 0 5
19923: PUSH
19924: LD_VAR 0 1
19928: PPUSH
19929: CALL_OW 25
19933: ST_TO_ADDR
// result := unit ;
19934: LD_ADDR_VAR 0 4
19938: PUSH
19939: LD_VAR 0 5
19943: ST_TO_ADDR
// end ;
19944: LD_VAR 0 4
19948: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19949: LD_INT 0
19951: PPUSH
19952: PPUSH
// if not side or not nation then
19953: LD_VAR 0 1
19957: NOT
19958: PUSH
19959: LD_VAR 0 2
19963: NOT
19964: OR
19965: IFFALSE 19969
// exit ;
19967: GO 20737
// case nation of nation_american :
19969: LD_VAR 0 2
19973: PUSH
19974: LD_INT 1
19976: DOUBLE
19977: EQUAL
19978: IFTRUE 19982
19980: GO 20196
19982: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19983: LD_ADDR_VAR 0 4
19987: PUSH
19988: LD_INT 35
19990: PUSH
19991: LD_INT 45
19993: PUSH
19994: LD_INT 46
19996: PUSH
19997: LD_INT 47
19999: PUSH
20000: LD_INT 82
20002: PUSH
20003: LD_INT 83
20005: PUSH
20006: LD_INT 84
20008: PUSH
20009: LD_INT 85
20011: PUSH
20012: LD_INT 86
20014: PUSH
20015: LD_INT 1
20017: PUSH
20018: LD_INT 2
20020: PUSH
20021: LD_INT 6
20023: PUSH
20024: LD_INT 15
20026: PUSH
20027: LD_INT 16
20029: PUSH
20030: LD_INT 7
20032: PUSH
20033: LD_INT 12
20035: PUSH
20036: LD_INT 13
20038: PUSH
20039: LD_INT 10
20041: PUSH
20042: LD_INT 14
20044: PUSH
20045: LD_INT 20
20047: PUSH
20048: LD_INT 21
20050: PUSH
20051: LD_INT 22
20053: PUSH
20054: LD_INT 25
20056: PUSH
20057: LD_INT 32
20059: PUSH
20060: LD_INT 27
20062: PUSH
20063: LD_INT 36
20065: PUSH
20066: LD_INT 69
20068: PUSH
20069: LD_INT 39
20071: PUSH
20072: LD_INT 34
20074: PUSH
20075: LD_INT 40
20077: PUSH
20078: LD_INT 48
20080: PUSH
20081: LD_INT 49
20083: PUSH
20084: LD_INT 50
20086: PUSH
20087: LD_INT 51
20089: PUSH
20090: LD_INT 52
20092: PUSH
20093: LD_INT 53
20095: PUSH
20096: LD_INT 54
20098: PUSH
20099: LD_INT 55
20101: PUSH
20102: LD_INT 56
20104: PUSH
20105: LD_INT 57
20107: PUSH
20108: LD_INT 58
20110: PUSH
20111: LD_INT 59
20113: PUSH
20114: LD_INT 60
20116: PUSH
20117: LD_INT 61
20119: PUSH
20120: LD_INT 62
20122: PUSH
20123: LD_INT 80
20125: PUSH
20126: LD_INT 82
20128: PUSH
20129: LD_INT 83
20131: PUSH
20132: LD_INT 84
20134: PUSH
20135: LD_INT 85
20137: PUSH
20138: LD_INT 86
20140: PUSH
20141: EMPTY
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: LIST
20193: ST_TO_ADDR
20194: GO 20661
20196: LD_INT 2
20198: DOUBLE
20199: EQUAL
20200: IFTRUE 20204
20202: GO 20430
20204: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20205: LD_ADDR_VAR 0 4
20209: PUSH
20210: LD_INT 35
20212: PUSH
20213: LD_INT 45
20215: PUSH
20216: LD_INT 46
20218: PUSH
20219: LD_INT 47
20221: PUSH
20222: LD_INT 82
20224: PUSH
20225: LD_INT 83
20227: PUSH
20228: LD_INT 84
20230: PUSH
20231: LD_INT 85
20233: PUSH
20234: LD_INT 87
20236: PUSH
20237: LD_INT 70
20239: PUSH
20240: LD_INT 1
20242: PUSH
20243: LD_INT 11
20245: PUSH
20246: LD_INT 3
20248: PUSH
20249: LD_INT 4
20251: PUSH
20252: LD_INT 5
20254: PUSH
20255: LD_INT 6
20257: PUSH
20258: LD_INT 15
20260: PUSH
20261: LD_INT 18
20263: PUSH
20264: LD_INT 7
20266: PUSH
20267: LD_INT 17
20269: PUSH
20270: LD_INT 8
20272: PUSH
20273: LD_INT 20
20275: PUSH
20276: LD_INT 21
20278: PUSH
20279: LD_INT 22
20281: PUSH
20282: LD_INT 72
20284: PUSH
20285: LD_INT 26
20287: PUSH
20288: LD_INT 69
20290: PUSH
20291: LD_INT 39
20293: PUSH
20294: LD_INT 40
20296: PUSH
20297: LD_INT 41
20299: PUSH
20300: LD_INT 42
20302: PUSH
20303: LD_INT 43
20305: PUSH
20306: LD_INT 48
20308: PUSH
20309: LD_INT 49
20311: PUSH
20312: LD_INT 50
20314: PUSH
20315: LD_INT 51
20317: PUSH
20318: LD_INT 52
20320: PUSH
20321: LD_INT 53
20323: PUSH
20324: LD_INT 54
20326: PUSH
20327: LD_INT 55
20329: PUSH
20330: LD_INT 56
20332: PUSH
20333: LD_INT 60
20335: PUSH
20336: LD_INT 61
20338: PUSH
20339: LD_INT 62
20341: PUSH
20342: LD_INT 66
20344: PUSH
20345: LD_INT 67
20347: PUSH
20348: LD_INT 68
20350: PUSH
20351: LD_INT 81
20353: PUSH
20354: LD_INT 82
20356: PUSH
20357: LD_INT 83
20359: PUSH
20360: LD_INT 84
20362: PUSH
20363: LD_INT 85
20365: PUSH
20366: LD_INT 87
20368: PUSH
20369: LD_INT 88
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: LIST
20426: LIST
20427: ST_TO_ADDR
20428: GO 20661
20430: LD_INT 3
20432: DOUBLE
20433: EQUAL
20434: IFTRUE 20438
20436: GO 20660
20438: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20439: LD_ADDR_VAR 0 4
20443: PUSH
20444: LD_INT 46
20446: PUSH
20447: LD_INT 47
20449: PUSH
20450: LD_INT 1
20452: PUSH
20453: LD_INT 2
20455: PUSH
20456: LD_INT 82
20458: PUSH
20459: LD_INT 83
20461: PUSH
20462: LD_INT 84
20464: PUSH
20465: LD_INT 85
20467: PUSH
20468: LD_INT 86
20470: PUSH
20471: LD_INT 11
20473: PUSH
20474: LD_INT 9
20476: PUSH
20477: LD_INT 20
20479: PUSH
20480: LD_INT 19
20482: PUSH
20483: LD_INT 21
20485: PUSH
20486: LD_INT 24
20488: PUSH
20489: LD_INT 22
20491: PUSH
20492: LD_INT 25
20494: PUSH
20495: LD_INT 28
20497: PUSH
20498: LD_INT 29
20500: PUSH
20501: LD_INT 30
20503: PUSH
20504: LD_INT 31
20506: PUSH
20507: LD_INT 37
20509: PUSH
20510: LD_INT 38
20512: PUSH
20513: LD_INT 32
20515: PUSH
20516: LD_INT 27
20518: PUSH
20519: LD_INT 33
20521: PUSH
20522: LD_INT 69
20524: PUSH
20525: LD_INT 39
20527: PUSH
20528: LD_INT 34
20530: PUSH
20531: LD_INT 40
20533: PUSH
20534: LD_INT 71
20536: PUSH
20537: LD_INT 23
20539: PUSH
20540: LD_INT 44
20542: PUSH
20543: LD_INT 48
20545: PUSH
20546: LD_INT 49
20548: PUSH
20549: LD_INT 50
20551: PUSH
20552: LD_INT 51
20554: PUSH
20555: LD_INT 52
20557: PUSH
20558: LD_INT 53
20560: PUSH
20561: LD_INT 54
20563: PUSH
20564: LD_INT 55
20566: PUSH
20567: LD_INT 56
20569: PUSH
20570: LD_INT 57
20572: PUSH
20573: LD_INT 58
20575: PUSH
20576: LD_INT 59
20578: PUSH
20579: LD_INT 63
20581: PUSH
20582: LD_INT 64
20584: PUSH
20585: LD_INT 65
20587: PUSH
20588: LD_INT 82
20590: PUSH
20591: LD_INT 83
20593: PUSH
20594: LD_INT 84
20596: PUSH
20597: LD_INT 85
20599: PUSH
20600: LD_INT 86
20602: PUSH
20603: EMPTY
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: LIST
20656: LIST
20657: ST_TO_ADDR
20658: GO 20661
20660: POP
// if state > - 1 and state < 3 then
20661: LD_VAR 0 3
20665: PUSH
20666: LD_INT 1
20668: NEG
20669: GREATER
20670: PUSH
20671: LD_VAR 0 3
20675: PUSH
20676: LD_INT 3
20678: LESS
20679: AND
20680: IFFALSE 20737
// for i in result do
20682: LD_ADDR_VAR 0 5
20686: PUSH
20687: LD_VAR 0 4
20691: PUSH
20692: FOR_IN
20693: IFFALSE 20735
// if GetTech ( i , side ) <> state then
20695: LD_VAR 0 5
20699: PPUSH
20700: LD_VAR 0 1
20704: PPUSH
20705: CALL_OW 321
20709: PUSH
20710: LD_VAR 0 3
20714: NONEQUAL
20715: IFFALSE 20733
// result := result diff i ;
20717: LD_ADDR_VAR 0 4
20721: PUSH
20722: LD_VAR 0 4
20726: PUSH
20727: LD_VAR 0 5
20731: DIFF
20732: ST_TO_ADDR
20733: GO 20692
20735: POP
20736: POP
// end ;
20737: LD_VAR 0 4
20741: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20742: LD_INT 0
20744: PPUSH
20745: PPUSH
20746: PPUSH
// result := true ;
20747: LD_ADDR_VAR 0 3
20751: PUSH
20752: LD_INT 1
20754: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20755: LD_ADDR_VAR 0 5
20759: PUSH
20760: LD_VAR 0 2
20764: PPUSH
20765: CALL_OW 480
20769: ST_TO_ADDR
// if not tmp then
20770: LD_VAR 0 5
20774: NOT
20775: IFFALSE 20779
// exit ;
20777: GO 20828
// for i in tmp do
20779: LD_ADDR_VAR 0 4
20783: PUSH
20784: LD_VAR 0 5
20788: PUSH
20789: FOR_IN
20790: IFFALSE 20826
// if GetTech ( i , side ) <> state_researched then
20792: LD_VAR 0 4
20796: PPUSH
20797: LD_VAR 0 1
20801: PPUSH
20802: CALL_OW 321
20806: PUSH
20807: LD_INT 2
20809: NONEQUAL
20810: IFFALSE 20824
// begin result := false ;
20812: LD_ADDR_VAR 0 3
20816: PUSH
20817: LD_INT 0
20819: ST_TO_ADDR
// exit ;
20820: POP
20821: POP
20822: GO 20828
// end ;
20824: GO 20789
20826: POP
20827: POP
// end ;
20828: LD_VAR 0 3
20832: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20833: LD_INT 0
20835: PPUSH
20836: PPUSH
20837: PPUSH
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
20845: PPUSH
20846: PPUSH
20847: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20848: LD_VAR 0 1
20852: NOT
20853: PUSH
20854: LD_VAR 0 1
20858: PPUSH
20859: CALL_OW 257
20863: PUSH
20864: LD_INT 9
20866: NONEQUAL
20867: OR
20868: IFFALSE 20872
// exit ;
20870: GO 21445
// side := GetSide ( unit ) ;
20872: LD_ADDR_VAR 0 9
20876: PUSH
20877: LD_VAR 0 1
20881: PPUSH
20882: CALL_OW 255
20886: ST_TO_ADDR
// tech_space := tech_spacanom ;
20887: LD_ADDR_VAR 0 12
20891: PUSH
20892: LD_INT 29
20894: ST_TO_ADDR
// tech_time := tech_taurad ;
20895: LD_ADDR_VAR 0 13
20899: PUSH
20900: LD_INT 28
20902: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20903: LD_ADDR_VAR 0 11
20907: PUSH
20908: LD_VAR 0 1
20912: PPUSH
20913: CALL_OW 310
20917: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20918: LD_VAR 0 11
20922: PPUSH
20923: CALL_OW 247
20927: PUSH
20928: LD_INT 2
20930: EQUAL
20931: IFFALSE 20935
// exit ;
20933: GO 21445
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20935: LD_ADDR_VAR 0 8
20939: PUSH
20940: LD_INT 81
20942: PUSH
20943: LD_VAR 0 9
20947: PUSH
20948: EMPTY
20949: LIST
20950: LIST
20951: PUSH
20952: LD_INT 3
20954: PUSH
20955: LD_INT 21
20957: PUSH
20958: LD_INT 3
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: PUSH
20965: EMPTY
20966: LIST
20967: LIST
20968: PUSH
20969: EMPTY
20970: LIST
20971: LIST
20972: PPUSH
20973: CALL_OW 69
20977: ST_TO_ADDR
// if not tmp then
20978: LD_VAR 0 8
20982: NOT
20983: IFFALSE 20987
// exit ;
20985: GO 21445
// if in_unit then
20987: LD_VAR 0 11
20991: IFFALSE 21015
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20993: LD_ADDR_VAR 0 10
20997: PUSH
20998: LD_VAR 0 8
21002: PPUSH
21003: LD_VAR 0 11
21007: PPUSH
21008: CALL_OW 74
21012: ST_TO_ADDR
21013: GO 21035
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21015: LD_ADDR_VAR 0 10
21019: PUSH
21020: LD_VAR 0 8
21024: PPUSH
21025: LD_VAR 0 1
21029: PPUSH
21030: CALL_OW 74
21034: ST_TO_ADDR
// if not enemy then
21035: LD_VAR 0 10
21039: NOT
21040: IFFALSE 21044
// exit ;
21042: GO 21445
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21044: LD_VAR 0 11
21048: PUSH
21049: LD_VAR 0 11
21053: PPUSH
21054: LD_VAR 0 10
21058: PPUSH
21059: CALL_OW 296
21063: PUSH
21064: LD_INT 13
21066: GREATER
21067: AND
21068: PUSH
21069: LD_VAR 0 1
21073: PPUSH
21074: LD_VAR 0 10
21078: PPUSH
21079: CALL_OW 296
21083: PUSH
21084: LD_INT 12
21086: GREATER
21087: OR
21088: IFFALSE 21092
// exit ;
21090: GO 21445
// missile := [ 1 ] ;
21092: LD_ADDR_VAR 0 14
21096: PUSH
21097: LD_INT 1
21099: PUSH
21100: EMPTY
21101: LIST
21102: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21103: LD_VAR 0 9
21107: PPUSH
21108: LD_VAR 0 12
21112: PPUSH
21113: CALL_OW 325
21117: IFFALSE 21146
// missile := Replace ( missile , missile + 1 , 2 ) ;
21119: LD_ADDR_VAR 0 14
21123: PUSH
21124: LD_VAR 0 14
21128: PPUSH
21129: LD_VAR 0 14
21133: PUSH
21134: LD_INT 1
21136: PLUS
21137: PPUSH
21138: LD_INT 2
21140: PPUSH
21141: CALL_OW 1
21145: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21146: LD_VAR 0 9
21150: PPUSH
21151: LD_VAR 0 13
21155: PPUSH
21156: CALL_OW 325
21160: PUSH
21161: LD_VAR 0 10
21165: PPUSH
21166: CALL_OW 255
21170: PPUSH
21171: LD_VAR 0 13
21175: PPUSH
21176: CALL_OW 325
21180: NOT
21181: AND
21182: IFFALSE 21211
// missile := Replace ( missile , missile + 1 , 3 ) ;
21184: LD_ADDR_VAR 0 14
21188: PUSH
21189: LD_VAR 0 14
21193: PPUSH
21194: LD_VAR 0 14
21198: PUSH
21199: LD_INT 1
21201: PLUS
21202: PPUSH
21203: LD_INT 3
21205: PPUSH
21206: CALL_OW 1
21210: ST_TO_ADDR
// if missile < 2 then
21211: LD_VAR 0 14
21215: PUSH
21216: LD_INT 2
21218: LESS
21219: IFFALSE 21223
// exit ;
21221: GO 21445
// x := GetX ( enemy ) ;
21223: LD_ADDR_VAR 0 4
21227: PUSH
21228: LD_VAR 0 10
21232: PPUSH
21233: CALL_OW 250
21237: ST_TO_ADDR
// y := GetY ( enemy ) ;
21238: LD_ADDR_VAR 0 5
21242: PUSH
21243: LD_VAR 0 10
21247: PPUSH
21248: CALL_OW 251
21252: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21253: LD_ADDR_VAR 0 6
21257: PUSH
21258: LD_VAR 0 4
21262: PUSH
21263: LD_INT 1
21265: NEG
21266: PPUSH
21267: LD_INT 1
21269: PPUSH
21270: CALL_OW 12
21274: PLUS
21275: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21276: LD_ADDR_VAR 0 7
21280: PUSH
21281: LD_VAR 0 5
21285: PUSH
21286: LD_INT 1
21288: NEG
21289: PPUSH
21290: LD_INT 1
21292: PPUSH
21293: CALL_OW 12
21297: PLUS
21298: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21299: LD_VAR 0 6
21303: PPUSH
21304: LD_VAR 0 7
21308: PPUSH
21309: CALL_OW 488
21313: NOT
21314: IFFALSE 21336
// begin _x := x ;
21316: LD_ADDR_VAR 0 6
21320: PUSH
21321: LD_VAR 0 4
21325: ST_TO_ADDR
// _y := y ;
21326: LD_ADDR_VAR 0 7
21330: PUSH
21331: LD_VAR 0 5
21335: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21336: LD_ADDR_VAR 0 3
21340: PUSH
21341: LD_INT 1
21343: PPUSH
21344: LD_VAR 0 14
21348: PPUSH
21349: CALL_OW 12
21353: ST_TO_ADDR
// case i of 1 :
21354: LD_VAR 0 3
21358: PUSH
21359: LD_INT 1
21361: DOUBLE
21362: EQUAL
21363: IFTRUE 21367
21365: GO 21384
21367: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21368: LD_VAR 0 1
21372: PPUSH
21373: LD_VAR 0 10
21377: PPUSH
21378: CALL_OW 115
21382: GO 21445
21384: LD_INT 2
21386: DOUBLE
21387: EQUAL
21388: IFTRUE 21392
21390: GO 21414
21392: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21393: LD_VAR 0 1
21397: PPUSH
21398: LD_VAR 0 6
21402: PPUSH
21403: LD_VAR 0 7
21407: PPUSH
21408: CALL_OW 153
21412: GO 21445
21414: LD_INT 3
21416: DOUBLE
21417: EQUAL
21418: IFTRUE 21422
21420: GO 21444
21422: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21423: LD_VAR 0 1
21427: PPUSH
21428: LD_VAR 0 6
21432: PPUSH
21433: LD_VAR 0 7
21437: PPUSH
21438: CALL_OW 154
21442: GO 21445
21444: POP
// end ;
21445: LD_VAR 0 2
21449: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21450: LD_INT 0
21452: PPUSH
21453: PPUSH
21454: PPUSH
21455: PPUSH
21456: PPUSH
21457: PPUSH
// if not unit or not building then
21458: LD_VAR 0 1
21462: NOT
21463: PUSH
21464: LD_VAR 0 2
21468: NOT
21469: OR
21470: IFFALSE 21474
// exit ;
21472: GO 21632
// x := GetX ( building ) ;
21474: LD_ADDR_VAR 0 5
21478: PUSH
21479: LD_VAR 0 2
21483: PPUSH
21484: CALL_OW 250
21488: ST_TO_ADDR
// y := GetY ( building ) ;
21489: LD_ADDR_VAR 0 6
21493: PUSH
21494: LD_VAR 0 2
21498: PPUSH
21499: CALL_OW 251
21503: ST_TO_ADDR
// for i = 0 to 5 do
21504: LD_ADDR_VAR 0 4
21508: PUSH
21509: DOUBLE
21510: LD_INT 0
21512: DEC
21513: ST_TO_ADDR
21514: LD_INT 5
21516: PUSH
21517: FOR_TO
21518: IFFALSE 21630
// begin _x := ShiftX ( x , i , 3 ) ;
21520: LD_ADDR_VAR 0 7
21524: PUSH
21525: LD_VAR 0 5
21529: PPUSH
21530: LD_VAR 0 4
21534: PPUSH
21535: LD_INT 3
21537: PPUSH
21538: CALL_OW 272
21542: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21543: LD_ADDR_VAR 0 8
21547: PUSH
21548: LD_VAR 0 6
21552: PPUSH
21553: LD_VAR 0 4
21557: PPUSH
21558: LD_INT 3
21560: PPUSH
21561: CALL_OW 273
21565: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21566: LD_VAR 0 7
21570: PPUSH
21571: LD_VAR 0 8
21575: PPUSH
21576: CALL_OW 488
21580: NOT
21581: IFFALSE 21585
// continue ;
21583: GO 21517
// if HexInfo ( _x , _y ) = 0 then
21585: LD_VAR 0 7
21589: PPUSH
21590: LD_VAR 0 8
21594: PPUSH
21595: CALL_OW 428
21599: PUSH
21600: LD_INT 0
21602: EQUAL
21603: IFFALSE 21628
// begin ComMoveXY ( unit , _x , _y ) ;
21605: LD_VAR 0 1
21609: PPUSH
21610: LD_VAR 0 7
21614: PPUSH
21615: LD_VAR 0 8
21619: PPUSH
21620: CALL_OW 111
// exit ;
21624: POP
21625: POP
21626: GO 21632
// end ; end ;
21628: GO 21517
21630: POP
21631: POP
// end ;
21632: LD_VAR 0 3
21636: RET
// export function ScanBase ( side , base_area ) ; begin
21637: LD_INT 0
21639: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21640: LD_ADDR_VAR 0 3
21644: PUSH
21645: LD_VAR 0 2
21649: PPUSH
21650: LD_INT 81
21652: PUSH
21653: LD_VAR 0 1
21657: PUSH
21658: EMPTY
21659: LIST
21660: LIST
21661: PPUSH
21662: CALL_OW 70
21666: ST_TO_ADDR
// end ;
21667: LD_VAR 0 3
21671: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21672: LD_INT 0
21674: PPUSH
21675: PPUSH
21676: PPUSH
21677: PPUSH
// result := false ;
21678: LD_ADDR_VAR 0 2
21682: PUSH
21683: LD_INT 0
21685: ST_TO_ADDR
// side := GetSide ( unit ) ;
21686: LD_ADDR_VAR 0 3
21690: PUSH
21691: LD_VAR 0 1
21695: PPUSH
21696: CALL_OW 255
21700: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21701: LD_ADDR_VAR 0 4
21705: PUSH
21706: LD_VAR 0 1
21710: PPUSH
21711: CALL_OW 248
21715: ST_TO_ADDR
// case nat of 1 :
21716: LD_VAR 0 4
21720: PUSH
21721: LD_INT 1
21723: DOUBLE
21724: EQUAL
21725: IFTRUE 21729
21727: GO 21740
21729: POP
// tech := tech_lassight ; 2 :
21730: LD_ADDR_VAR 0 5
21734: PUSH
21735: LD_INT 12
21737: ST_TO_ADDR
21738: GO 21779
21740: LD_INT 2
21742: DOUBLE
21743: EQUAL
21744: IFTRUE 21748
21746: GO 21759
21748: POP
// tech := tech_mortar ; 3 :
21749: LD_ADDR_VAR 0 5
21753: PUSH
21754: LD_INT 41
21756: ST_TO_ADDR
21757: GO 21779
21759: LD_INT 3
21761: DOUBLE
21762: EQUAL
21763: IFTRUE 21767
21765: GO 21778
21767: POP
// tech := tech_bazooka ; end ;
21768: LD_ADDR_VAR 0 5
21772: PUSH
21773: LD_INT 44
21775: ST_TO_ADDR
21776: GO 21779
21778: POP
// if Researched ( side , tech ) then
21779: LD_VAR 0 3
21783: PPUSH
21784: LD_VAR 0 5
21788: PPUSH
21789: CALL_OW 325
21793: IFFALSE 21820
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21795: LD_ADDR_VAR 0 2
21799: PUSH
21800: LD_INT 5
21802: PUSH
21803: LD_INT 8
21805: PUSH
21806: LD_INT 9
21808: PUSH
21809: EMPTY
21810: LIST
21811: LIST
21812: LIST
21813: PUSH
21814: LD_VAR 0 4
21818: ARRAY
21819: ST_TO_ADDR
// end ;
21820: LD_VAR 0 2
21824: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21825: LD_INT 0
21827: PPUSH
21828: PPUSH
21829: PPUSH
// if not mines then
21830: LD_VAR 0 2
21834: NOT
21835: IFFALSE 21839
// exit ;
21837: GO 21983
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21839: LD_ADDR_VAR 0 5
21843: PUSH
21844: LD_INT 81
21846: PUSH
21847: LD_VAR 0 1
21851: PUSH
21852: EMPTY
21853: LIST
21854: LIST
21855: PUSH
21856: LD_INT 3
21858: PUSH
21859: LD_INT 21
21861: PUSH
21862: LD_INT 3
21864: PUSH
21865: EMPTY
21866: LIST
21867: LIST
21868: PUSH
21869: EMPTY
21870: LIST
21871: LIST
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: PPUSH
21877: CALL_OW 69
21881: ST_TO_ADDR
// for i in mines do
21882: LD_ADDR_VAR 0 4
21886: PUSH
21887: LD_VAR 0 2
21891: PUSH
21892: FOR_IN
21893: IFFALSE 21981
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21895: LD_VAR 0 4
21899: PUSH
21900: LD_INT 1
21902: ARRAY
21903: PPUSH
21904: LD_VAR 0 4
21908: PUSH
21909: LD_INT 2
21911: ARRAY
21912: PPUSH
21913: CALL_OW 458
21917: NOT
21918: IFFALSE 21922
// continue ;
21920: GO 21892
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21922: LD_VAR 0 4
21926: PUSH
21927: LD_INT 1
21929: ARRAY
21930: PPUSH
21931: LD_VAR 0 4
21935: PUSH
21936: LD_INT 2
21938: ARRAY
21939: PPUSH
21940: CALL_OW 428
21944: PUSH
21945: LD_VAR 0 5
21949: IN
21950: IFFALSE 21979
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21952: LD_VAR 0 4
21956: PUSH
21957: LD_INT 1
21959: ARRAY
21960: PPUSH
21961: LD_VAR 0 4
21965: PUSH
21966: LD_INT 2
21968: ARRAY
21969: PPUSH
21970: LD_VAR 0 1
21974: PPUSH
21975: CALL_OW 456
// end ;
21979: GO 21892
21981: POP
21982: POP
// end ;
21983: LD_VAR 0 3
21987: RET
// export function Count ( array ) ; var i ; begin
21988: LD_INT 0
21990: PPUSH
21991: PPUSH
// result := 0 ;
21992: LD_ADDR_VAR 0 2
21996: PUSH
21997: LD_INT 0
21999: ST_TO_ADDR
// for i in array do
22000: LD_ADDR_VAR 0 3
22004: PUSH
22005: LD_VAR 0 1
22009: PUSH
22010: FOR_IN
22011: IFFALSE 22035
// if i then
22013: LD_VAR 0 3
22017: IFFALSE 22033
// result := result + 1 ;
22019: LD_ADDR_VAR 0 2
22023: PUSH
22024: LD_VAR 0 2
22028: PUSH
22029: LD_INT 1
22031: PLUS
22032: ST_TO_ADDR
22033: GO 22010
22035: POP
22036: POP
// end ;
22037: LD_VAR 0 2
22041: RET
// export function IsEmpty ( building ) ; begin
22042: LD_INT 0
22044: PPUSH
// if not building then
22045: LD_VAR 0 1
22049: NOT
22050: IFFALSE 22054
// exit ;
22052: GO 22097
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22054: LD_ADDR_VAR 0 2
22058: PUSH
22059: LD_VAR 0 1
22063: PUSH
22064: LD_INT 22
22066: PUSH
22067: LD_VAR 0 1
22071: PPUSH
22072: CALL_OW 255
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: PUSH
22081: LD_INT 58
22083: PUSH
22084: EMPTY
22085: LIST
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PPUSH
22091: CALL_OW 69
22095: IN
22096: ST_TO_ADDR
// end ;
22097: LD_VAR 0 2
22101: RET
// export function IsNotFull ( building ) ; var places ; begin
22102: LD_INT 0
22104: PPUSH
22105: PPUSH
// if not building then
22106: LD_VAR 0 1
22110: NOT
22111: IFFALSE 22115
// exit ;
22113: GO 22286
// result := false ;
22115: LD_ADDR_VAR 0 2
22119: PUSH
22120: LD_INT 0
22122: ST_TO_ADDR
// places := 0 ;
22123: LD_ADDR_VAR 0 3
22127: PUSH
22128: LD_INT 0
22130: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
22131: LD_VAR 0 1
22135: PPUSH
22136: CALL_OW 266
22140: PUSH
22141: LD_INT 0
22143: DOUBLE
22144: EQUAL
22145: IFTRUE 22203
22147: LD_INT 1
22149: DOUBLE
22150: EQUAL
22151: IFTRUE 22203
22153: LD_INT 6
22155: DOUBLE
22156: EQUAL
22157: IFTRUE 22203
22159: LD_INT 7
22161: DOUBLE
22162: EQUAL
22163: IFTRUE 22203
22165: LD_INT 8
22167: DOUBLE
22168: EQUAL
22169: IFTRUE 22203
22171: LD_INT 4
22173: DOUBLE
22174: EQUAL
22175: IFTRUE 22203
22177: LD_INT 5
22179: DOUBLE
22180: EQUAL
22181: IFTRUE 22203
22183: LD_INT 2
22185: DOUBLE
22186: EQUAL
22187: IFTRUE 22203
22189: LD_INT 3
22191: DOUBLE
22192: EQUAL
22193: IFTRUE 22203
22195: LD_INT 35
22197: DOUBLE
22198: EQUAL
22199: IFTRUE 22203
22201: GO 22214
22203: POP
// places := 6 ; b_bunker , b_breastwork :
22204: LD_ADDR_VAR 0 3
22208: PUSH
22209: LD_INT 6
22211: ST_TO_ADDR
22212: GO 22259
22214: LD_INT 32
22216: DOUBLE
22217: EQUAL
22218: IFTRUE 22228
22220: LD_INT 31
22222: DOUBLE
22223: EQUAL
22224: IFTRUE 22228
22226: GO 22239
22228: POP
// places := 1 ; b_control_tower :
22229: LD_ADDR_VAR 0 3
22233: PUSH
22234: LD_INT 1
22236: ST_TO_ADDR
22237: GO 22259
22239: LD_INT 36
22241: DOUBLE
22242: EQUAL
22243: IFTRUE 22247
22245: GO 22258
22247: POP
// places := 3 ; end ;
22248: LD_ADDR_VAR 0 3
22252: PUSH
22253: LD_INT 3
22255: ST_TO_ADDR
22256: GO 22259
22258: POP
// if places then
22259: LD_VAR 0 3
22263: IFFALSE 22286
// result := UnitsInside ( building ) < places ;
22265: LD_ADDR_VAR 0 2
22269: PUSH
22270: LD_VAR 0 1
22274: PPUSH
22275: CALL_OW 313
22279: PUSH
22280: LD_VAR 0 3
22284: LESS
22285: ST_TO_ADDR
// end ;
22286: LD_VAR 0 2
22290: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22291: LD_INT 0
22293: PPUSH
22294: PPUSH
22295: PPUSH
22296: PPUSH
// tmp := [ ] ;
22297: LD_ADDR_VAR 0 3
22301: PUSH
22302: EMPTY
22303: ST_TO_ADDR
// list := [ ] ;
22304: LD_ADDR_VAR 0 5
22308: PUSH
22309: EMPTY
22310: ST_TO_ADDR
// for i = 16 to 25 do
22311: LD_ADDR_VAR 0 4
22315: PUSH
22316: DOUBLE
22317: LD_INT 16
22319: DEC
22320: ST_TO_ADDR
22321: LD_INT 25
22323: PUSH
22324: FOR_TO
22325: IFFALSE 22398
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22327: LD_ADDR_VAR 0 3
22331: PUSH
22332: LD_VAR 0 3
22336: PUSH
22337: LD_INT 22
22339: PUSH
22340: LD_VAR 0 1
22344: PPUSH
22345: CALL_OW 255
22349: PUSH
22350: EMPTY
22351: LIST
22352: LIST
22353: PUSH
22354: LD_INT 91
22356: PUSH
22357: LD_VAR 0 1
22361: PUSH
22362: LD_INT 6
22364: PUSH
22365: EMPTY
22366: LIST
22367: LIST
22368: LIST
22369: PUSH
22370: LD_INT 30
22372: PUSH
22373: LD_VAR 0 4
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: PUSH
22382: EMPTY
22383: LIST
22384: LIST
22385: LIST
22386: PUSH
22387: EMPTY
22388: LIST
22389: PPUSH
22390: CALL_OW 69
22394: ADD
22395: ST_TO_ADDR
22396: GO 22324
22398: POP
22399: POP
// for i = 1 to tmp do
22400: LD_ADDR_VAR 0 4
22404: PUSH
22405: DOUBLE
22406: LD_INT 1
22408: DEC
22409: ST_TO_ADDR
22410: LD_VAR 0 3
22414: PUSH
22415: FOR_TO
22416: IFFALSE 22504
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22418: LD_ADDR_VAR 0 5
22422: PUSH
22423: LD_VAR 0 5
22427: PUSH
22428: LD_VAR 0 3
22432: PUSH
22433: LD_VAR 0 4
22437: ARRAY
22438: PPUSH
22439: CALL_OW 266
22443: PUSH
22444: LD_VAR 0 3
22448: PUSH
22449: LD_VAR 0 4
22453: ARRAY
22454: PPUSH
22455: CALL_OW 250
22459: PUSH
22460: LD_VAR 0 3
22464: PUSH
22465: LD_VAR 0 4
22469: ARRAY
22470: PPUSH
22471: CALL_OW 251
22475: PUSH
22476: LD_VAR 0 3
22480: PUSH
22481: LD_VAR 0 4
22485: ARRAY
22486: PPUSH
22487: CALL_OW 254
22491: PUSH
22492: EMPTY
22493: LIST
22494: LIST
22495: LIST
22496: LIST
22497: PUSH
22498: EMPTY
22499: LIST
22500: ADD
22501: ST_TO_ADDR
22502: GO 22415
22504: POP
22505: POP
// result := list ;
22506: LD_ADDR_VAR 0 2
22510: PUSH
22511: LD_VAR 0 5
22515: ST_TO_ADDR
// end ;
22516: LD_VAR 0 2
22520: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22521: LD_INT 0
22523: PPUSH
22524: PPUSH
22525: PPUSH
22526: PPUSH
22527: PPUSH
22528: PPUSH
22529: PPUSH
// if not factory then
22530: LD_VAR 0 1
22534: NOT
22535: IFFALSE 22539
// exit ;
22537: GO 23132
// if control = control_apeman then
22539: LD_VAR 0 4
22543: PUSH
22544: LD_INT 5
22546: EQUAL
22547: IFFALSE 22656
// begin tmp := UnitsInside ( factory ) ;
22549: LD_ADDR_VAR 0 8
22553: PUSH
22554: LD_VAR 0 1
22558: PPUSH
22559: CALL_OW 313
22563: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22564: LD_VAR 0 8
22568: PPUSH
22569: LD_INT 25
22571: PUSH
22572: LD_INT 12
22574: PUSH
22575: EMPTY
22576: LIST
22577: LIST
22578: PPUSH
22579: CALL_OW 72
22583: NOT
22584: IFFALSE 22594
// control := control_manual ;
22586: LD_ADDR_VAR 0 4
22590: PUSH
22591: LD_INT 1
22593: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22594: LD_ADDR_VAR 0 8
22598: PUSH
22599: LD_VAR 0 1
22603: PPUSH
22604: CALL 22291 0 1
22608: ST_TO_ADDR
// if tmp then
22609: LD_VAR 0 8
22613: IFFALSE 22656
// begin for i in tmp do
22615: LD_ADDR_VAR 0 7
22619: PUSH
22620: LD_VAR 0 8
22624: PUSH
22625: FOR_IN
22626: IFFALSE 22654
// if i [ 1 ] = b_ext_radio then
22628: LD_VAR 0 7
22632: PUSH
22633: LD_INT 1
22635: ARRAY
22636: PUSH
22637: LD_INT 22
22639: EQUAL
22640: IFFALSE 22652
// begin control := control_remote ;
22642: LD_ADDR_VAR 0 4
22646: PUSH
22647: LD_INT 2
22649: ST_TO_ADDR
// break ;
22650: GO 22654
// end ;
22652: GO 22625
22654: POP
22655: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22656: LD_VAR 0 1
22660: PPUSH
22661: LD_VAR 0 2
22665: PPUSH
22666: LD_VAR 0 3
22670: PPUSH
22671: LD_VAR 0 4
22675: PPUSH
22676: LD_VAR 0 5
22680: PPUSH
22681: CALL_OW 448
22685: IFFALSE 22720
// begin result := [ chassis , engine , control , weapon ] ;
22687: LD_ADDR_VAR 0 6
22691: PUSH
22692: LD_VAR 0 2
22696: PUSH
22697: LD_VAR 0 3
22701: PUSH
22702: LD_VAR 0 4
22706: PUSH
22707: LD_VAR 0 5
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: LIST
22716: LIST
22717: ST_TO_ADDR
// exit ;
22718: GO 23132
// end ; _chassis := AvailableChassisList ( factory ) ;
22720: LD_ADDR_VAR 0 9
22724: PUSH
22725: LD_VAR 0 1
22729: PPUSH
22730: CALL_OW 475
22734: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22735: LD_ADDR_VAR 0 11
22739: PUSH
22740: LD_VAR 0 1
22744: PPUSH
22745: CALL_OW 476
22749: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22750: LD_ADDR_VAR 0 12
22754: PUSH
22755: LD_VAR 0 1
22759: PPUSH
22760: CALL_OW 477
22764: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22765: LD_ADDR_VAR 0 10
22769: PUSH
22770: LD_VAR 0 1
22774: PPUSH
22775: CALL_OW 478
22779: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22780: LD_VAR 0 9
22784: NOT
22785: PUSH
22786: LD_VAR 0 11
22790: NOT
22791: OR
22792: PUSH
22793: LD_VAR 0 12
22797: NOT
22798: OR
22799: PUSH
22800: LD_VAR 0 10
22804: NOT
22805: OR
22806: IFFALSE 22841
// begin result := [ chassis , engine , control , weapon ] ;
22808: LD_ADDR_VAR 0 6
22812: PUSH
22813: LD_VAR 0 2
22817: PUSH
22818: LD_VAR 0 3
22822: PUSH
22823: LD_VAR 0 4
22827: PUSH
22828: LD_VAR 0 5
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: LIST
22837: LIST
22838: ST_TO_ADDR
// exit ;
22839: GO 23132
// end ; if not chassis in _chassis then
22841: LD_VAR 0 2
22845: PUSH
22846: LD_VAR 0 9
22850: IN
22851: NOT
22852: IFFALSE 22878
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22854: LD_ADDR_VAR 0 2
22858: PUSH
22859: LD_VAR 0 9
22863: PUSH
22864: LD_INT 1
22866: PPUSH
22867: LD_VAR 0 9
22871: PPUSH
22872: CALL_OW 12
22876: ARRAY
22877: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22878: LD_VAR 0 2
22882: PPUSH
22883: LD_VAR 0 3
22887: PPUSH
22888: CALL 23137 0 2
22892: NOT
22893: IFFALSE 22952
// repeat engine := _engine [ 1 ] ;
22895: LD_ADDR_VAR 0 3
22899: PUSH
22900: LD_VAR 0 11
22904: PUSH
22905: LD_INT 1
22907: ARRAY
22908: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22909: LD_ADDR_VAR 0 11
22913: PUSH
22914: LD_VAR 0 11
22918: PPUSH
22919: LD_INT 1
22921: PPUSH
22922: CALL_OW 3
22926: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22927: LD_VAR 0 2
22931: PPUSH
22932: LD_VAR 0 3
22936: PPUSH
22937: CALL 23137 0 2
22941: PUSH
22942: LD_VAR 0 11
22946: PUSH
22947: EMPTY
22948: EQUAL
22949: OR
22950: IFFALSE 22895
// if not control in _control then
22952: LD_VAR 0 4
22956: PUSH
22957: LD_VAR 0 12
22961: IN
22962: NOT
22963: IFFALSE 22989
// control := _control [ rand ( 1 , _control ) ] ;
22965: LD_ADDR_VAR 0 4
22969: PUSH
22970: LD_VAR 0 12
22974: PUSH
22975: LD_INT 1
22977: PPUSH
22978: LD_VAR 0 12
22982: PPUSH
22983: CALL_OW 12
22987: ARRAY
22988: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22989: LD_VAR 0 2
22993: PPUSH
22994: LD_VAR 0 5
22998: PPUSH
22999: CALL 23357 0 2
23003: NOT
23004: IFFALSE 23063
// repeat weapon := _weapon [ 1 ] ;
23006: LD_ADDR_VAR 0 5
23010: PUSH
23011: LD_VAR 0 10
23015: PUSH
23016: LD_INT 1
23018: ARRAY
23019: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
23020: LD_ADDR_VAR 0 10
23024: PUSH
23025: LD_VAR 0 10
23029: PPUSH
23030: LD_INT 1
23032: PPUSH
23033: CALL_OW 3
23037: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
23038: LD_VAR 0 2
23042: PPUSH
23043: LD_VAR 0 5
23047: PPUSH
23048: CALL 23357 0 2
23052: PUSH
23053: LD_VAR 0 10
23057: PUSH
23058: EMPTY
23059: EQUAL
23060: OR
23061: IFFALSE 23006
// result := [ ] ;
23063: LD_ADDR_VAR 0 6
23067: PUSH
23068: EMPTY
23069: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
23070: LD_VAR 0 1
23074: PPUSH
23075: LD_VAR 0 2
23079: PPUSH
23080: LD_VAR 0 3
23084: PPUSH
23085: LD_VAR 0 4
23089: PPUSH
23090: LD_VAR 0 5
23094: PPUSH
23095: CALL_OW 448
23099: IFFALSE 23132
// result := [ chassis , engine , control , weapon ] ;
23101: LD_ADDR_VAR 0 6
23105: PUSH
23106: LD_VAR 0 2
23110: PUSH
23111: LD_VAR 0 3
23115: PUSH
23116: LD_VAR 0 4
23120: PUSH
23121: LD_VAR 0 5
23125: PUSH
23126: EMPTY
23127: LIST
23128: LIST
23129: LIST
23130: LIST
23131: ST_TO_ADDR
// end ;
23132: LD_VAR 0 6
23136: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
23137: LD_INT 0
23139: PPUSH
// if not chassis or not engine then
23140: LD_VAR 0 1
23144: NOT
23145: PUSH
23146: LD_VAR 0 2
23150: NOT
23151: OR
23152: IFFALSE 23156
// exit ;
23154: GO 23352
// case engine of engine_solar :
23156: LD_VAR 0 2
23160: PUSH
23161: LD_INT 2
23163: DOUBLE
23164: EQUAL
23165: IFTRUE 23169
23167: GO 23207
23169: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
23170: LD_ADDR_VAR 0 3
23174: PUSH
23175: LD_INT 11
23177: PUSH
23178: LD_INT 12
23180: PUSH
23181: LD_INT 13
23183: PUSH
23184: LD_INT 14
23186: PUSH
23187: LD_INT 1
23189: PUSH
23190: LD_INT 2
23192: PUSH
23193: LD_INT 3
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: LIST
23200: LIST
23201: LIST
23202: LIST
23203: LIST
23204: ST_TO_ADDR
23205: GO 23336
23207: LD_INT 1
23209: DOUBLE
23210: EQUAL
23211: IFTRUE 23215
23213: GO 23277
23215: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23216: LD_ADDR_VAR 0 3
23220: PUSH
23221: LD_INT 11
23223: PUSH
23224: LD_INT 12
23226: PUSH
23227: LD_INT 13
23229: PUSH
23230: LD_INT 14
23232: PUSH
23233: LD_INT 1
23235: PUSH
23236: LD_INT 2
23238: PUSH
23239: LD_INT 3
23241: PUSH
23242: LD_INT 4
23244: PUSH
23245: LD_INT 5
23247: PUSH
23248: LD_INT 21
23250: PUSH
23251: LD_INT 23
23253: PUSH
23254: LD_INT 22
23256: PUSH
23257: LD_INT 24
23259: PUSH
23260: EMPTY
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: LIST
23266: LIST
23267: LIST
23268: LIST
23269: LIST
23270: LIST
23271: LIST
23272: LIST
23273: LIST
23274: ST_TO_ADDR
23275: GO 23336
23277: LD_INT 3
23279: DOUBLE
23280: EQUAL
23281: IFTRUE 23285
23283: GO 23335
23285: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23286: LD_ADDR_VAR 0 3
23290: PUSH
23291: LD_INT 13
23293: PUSH
23294: LD_INT 14
23296: PUSH
23297: LD_INT 2
23299: PUSH
23300: LD_INT 3
23302: PUSH
23303: LD_INT 4
23305: PUSH
23306: LD_INT 5
23308: PUSH
23309: LD_INT 21
23311: PUSH
23312: LD_INT 22
23314: PUSH
23315: LD_INT 23
23317: PUSH
23318: LD_INT 24
23320: PUSH
23321: EMPTY
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: LIST
23331: LIST
23332: ST_TO_ADDR
23333: GO 23336
23335: POP
// result := ( chassis in result ) ;
23336: LD_ADDR_VAR 0 3
23340: PUSH
23341: LD_VAR 0 1
23345: PUSH
23346: LD_VAR 0 3
23350: IN
23351: ST_TO_ADDR
// end ;
23352: LD_VAR 0 3
23356: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23357: LD_INT 0
23359: PPUSH
// if not chassis or not weapon then
23360: LD_VAR 0 1
23364: NOT
23365: PUSH
23366: LD_VAR 0 2
23370: NOT
23371: OR
23372: IFFALSE 23376
// exit ;
23374: GO 24438
// case weapon of us_machine_gun :
23376: LD_VAR 0 2
23380: PUSH
23381: LD_INT 2
23383: DOUBLE
23384: EQUAL
23385: IFTRUE 23389
23387: GO 23419
23389: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23390: LD_ADDR_VAR 0 3
23394: PUSH
23395: LD_INT 1
23397: PUSH
23398: LD_INT 2
23400: PUSH
23401: LD_INT 3
23403: PUSH
23404: LD_INT 4
23406: PUSH
23407: LD_INT 5
23409: PUSH
23410: EMPTY
23411: LIST
23412: LIST
23413: LIST
23414: LIST
23415: LIST
23416: ST_TO_ADDR
23417: GO 24422
23419: LD_INT 3
23421: DOUBLE
23422: EQUAL
23423: IFTRUE 23427
23425: GO 23457
23427: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23428: LD_ADDR_VAR 0 3
23432: PUSH
23433: LD_INT 1
23435: PUSH
23436: LD_INT 2
23438: PUSH
23439: LD_INT 3
23441: PUSH
23442: LD_INT 4
23444: PUSH
23445: LD_INT 5
23447: PUSH
23448: EMPTY
23449: LIST
23450: LIST
23451: LIST
23452: LIST
23453: LIST
23454: ST_TO_ADDR
23455: GO 24422
23457: LD_INT 11
23459: DOUBLE
23460: EQUAL
23461: IFTRUE 23465
23463: GO 23495
23465: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23466: LD_ADDR_VAR 0 3
23470: PUSH
23471: LD_INT 1
23473: PUSH
23474: LD_INT 2
23476: PUSH
23477: LD_INT 3
23479: PUSH
23480: LD_INT 4
23482: PUSH
23483: LD_INT 5
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: LIST
23490: LIST
23491: LIST
23492: ST_TO_ADDR
23493: GO 24422
23495: LD_INT 4
23497: DOUBLE
23498: EQUAL
23499: IFTRUE 23503
23501: GO 23529
23503: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23504: LD_ADDR_VAR 0 3
23508: PUSH
23509: LD_INT 2
23511: PUSH
23512: LD_INT 3
23514: PUSH
23515: LD_INT 4
23517: PUSH
23518: LD_INT 5
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: LIST
23525: LIST
23526: ST_TO_ADDR
23527: GO 24422
23529: LD_INT 5
23531: DOUBLE
23532: EQUAL
23533: IFTRUE 23537
23535: GO 23563
23537: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23538: LD_ADDR_VAR 0 3
23542: PUSH
23543: LD_INT 2
23545: PUSH
23546: LD_INT 3
23548: PUSH
23549: LD_INT 4
23551: PUSH
23552: LD_INT 5
23554: PUSH
23555: EMPTY
23556: LIST
23557: LIST
23558: LIST
23559: LIST
23560: ST_TO_ADDR
23561: GO 24422
23563: LD_INT 9
23565: DOUBLE
23566: EQUAL
23567: IFTRUE 23571
23569: GO 23597
23571: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23572: LD_ADDR_VAR 0 3
23576: PUSH
23577: LD_INT 2
23579: PUSH
23580: LD_INT 3
23582: PUSH
23583: LD_INT 4
23585: PUSH
23586: LD_INT 5
23588: PUSH
23589: EMPTY
23590: LIST
23591: LIST
23592: LIST
23593: LIST
23594: ST_TO_ADDR
23595: GO 24422
23597: LD_INT 7
23599: DOUBLE
23600: EQUAL
23601: IFTRUE 23605
23603: GO 23631
23605: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23606: LD_ADDR_VAR 0 3
23610: PUSH
23611: LD_INT 2
23613: PUSH
23614: LD_INT 3
23616: PUSH
23617: LD_INT 4
23619: PUSH
23620: LD_INT 5
23622: PUSH
23623: EMPTY
23624: LIST
23625: LIST
23626: LIST
23627: LIST
23628: ST_TO_ADDR
23629: GO 24422
23631: LD_INT 12
23633: DOUBLE
23634: EQUAL
23635: IFTRUE 23639
23637: GO 23665
23639: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23640: LD_ADDR_VAR 0 3
23644: PUSH
23645: LD_INT 2
23647: PUSH
23648: LD_INT 3
23650: PUSH
23651: LD_INT 4
23653: PUSH
23654: LD_INT 5
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: LIST
23661: LIST
23662: ST_TO_ADDR
23663: GO 24422
23665: LD_INT 13
23667: DOUBLE
23668: EQUAL
23669: IFTRUE 23673
23671: GO 23699
23673: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23674: LD_ADDR_VAR 0 3
23678: PUSH
23679: LD_INT 2
23681: PUSH
23682: LD_INT 3
23684: PUSH
23685: LD_INT 4
23687: PUSH
23688: LD_INT 5
23690: PUSH
23691: EMPTY
23692: LIST
23693: LIST
23694: LIST
23695: LIST
23696: ST_TO_ADDR
23697: GO 24422
23699: LD_INT 14
23701: DOUBLE
23702: EQUAL
23703: IFTRUE 23707
23705: GO 23725
23707: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23708: LD_ADDR_VAR 0 3
23712: PUSH
23713: LD_INT 4
23715: PUSH
23716: LD_INT 5
23718: PUSH
23719: EMPTY
23720: LIST
23721: LIST
23722: ST_TO_ADDR
23723: GO 24422
23725: LD_INT 6
23727: DOUBLE
23728: EQUAL
23729: IFTRUE 23733
23731: GO 23751
23733: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23734: LD_ADDR_VAR 0 3
23738: PUSH
23739: LD_INT 4
23741: PUSH
23742: LD_INT 5
23744: PUSH
23745: EMPTY
23746: LIST
23747: LIST
23748: ST_TO_ADDR
23749: GO 24422
23751: LD_INT 10
23753: DOUBLE
23754: EQUAL
23755: IFTRUE 23759
23757: GO 23777
23759: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23760: LD_ADDR_VAR 0 3
23764: PUSH
23765: LD_INT 4
23767: PUSH
23768: LD_INT 5
23770: PUSH
23771: EMPTY
23772: LIST
23773: LIST
23774: ST_TO_ADDR
23775: GO 24422
23777: LD_INT 22
23779: DOUBLE
23780: EQUAL
23781: IFTRUE 23785
23783: GO 23811
23785: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23786: LD_ADDR_VAR 0 3
23790: PUSH
23791: LD_INT 11
23793: PUSH
23794: LD_INT 12
23796: PUSH
23797: LD_INT 13
23799: PUSH
23800: LD_INT 14
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: LIST
23807: LIST
23808: ST_TO_ADDR
23809: GO 24422
23811: LD_INT 23
23813: DOUBLE
23814: EQUAL
23815: IFTRUE 23819
23817: GO 23845
23819: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23820: LD_ADDR_VAR 0 3
23824: PUSH
23825: LD_INT 11
23827: PUSH
23828: LD_INT 12
23830: PUSH
23831: LD_INT 13
23833: PUSH
23834: LD_INT 14
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: LIST
23841: LIST
23842: ST_TO_ADDR
23843: GO 24422
23845: LD_INT 24
23847: DOUBLE
23848: EQUAL
23849: IFTRUE 23853
23851: GO 23879
23853: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23854: LD_ADDR_VAR 0 3
23858: PUSH
23859: LD_INT 11
23861: PUSH
23862: LD_INT 12
23864: PUSH
23865: LD_INT 13
23867: PUSH
23868: LD_INT 14
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: LIST
23875: LIST
23876: ST_TO_ADDR
23877: GO 24422
23879: LD_INT 30
23881: DOUBLE
23882: EQUAL
23883: IFTRUE 23887
23885: GO 23913
23887: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23888: LD_ADDR_VAR 0 3
23892: PUSH
23893: LD_INT 11
23895: PUSH
23896: LD_INT 12
23898: PUSH
23899: LD_INT 13
23901: PUSH
23902: LD_INT 14
23904: PUSH
23905: EMPTY
23906: LIST
23907: LIST
23908: LIST
23909: LIST
23910: ST_TO_ADDR
23911: GO 24422
23913: LD_INT 25
23915: DOUBLE
23916: EQUAL
23917: IFTRUE 23921
23919: GO 23939
23921: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23922: LD_ADDR_VAR 0 3
23926: PUSH
23927: LD_INT 13
23929: PUSH
23930: LD_INT 14
23932: PUSH
23933: EMPTY
23934: LIST
23935: LIST
23936: ST_TO_ADDR
23937: GO 24422
23939: LD_INT 27
23941: DOUBLE
23942: EQUAL
23943: IFTRUE 23947
23945: GO 23965
23947: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23948: LD_ADDR_VAR 0 3
23952: PUSH
23953: LD_INT 13
23955: PUSH
23956: LD_INT 14
23958: PUSH
23959: EMPTY
23960: LIST
23961: LIST
23962: ST_TO_ADDR
23963: GO 24422
23965: LD_EXP 34
23969: DOUBLE
23970: EQUAL
23971: IFTRUE 23975
23973: GO 24001
23975: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23976: LD_ADDR_VAR 0 3
23980: PUSH
23981: LD_INT 11
23983: PUSH
23984: LD_INT 12
23986: PUSH
23987: LD_INT 13
23989: PUSH
23990: LD_INT 14
23992: PUSH
23993: EMPTY
23994: LIST
23995: LIST
23996: LIST
23997: LIST
23998: ST_TO_ADDR
23999: GO 24422
24001: LD_INT 28
24003: DOUBLE
24004: EQUAL
24005: IFTRUE 24009
24007: GO 24027
24009: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
24010: LD_ADDR_VAR 0 3
24014: PUSH
24015: LD_INT 13
24017: PUSH
24018: LD_INT 14
24020: PUSH
24021: EMPTY
24022: LIST
24023: LIST
24024: ST_TO_ADDR
24025: GO 24422
24027: LD_INT 29
24029: DOUBLE
24030: EQUAL
24031: IFTRUE 24035
24033: GO 24053
24035: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
24036: LD_ADDR_VAR 0 3
24040: PUSH
24041: LD_INT 13
24043: PUSH
24044: LD_INT 14
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: ST_TO_ADDR
24051: GO 24422
24053: LD_INT 31
24055: DOUBLE
24056: EQUAL
24057: IFTRUE 24061
24059: GO 24079
24061: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
24062: LD_ADDR_VAR 0 3
24066: PUSH
24067: LD_INT 13
24069: PUSH
24070: LD_INT 14
24072: PUSH
24073: EMPTY
24074: LIST
24075: LIST
24076: ST_TO_ADDR
24077: GO 24422
24079: LD_INT 26
24081: DOUBLE
24082: EQUAL
24083: IFTRUE 24087
24085: GO 24105
24087: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
24088: LD_ADDR_VAR 0 3
24092: PUSH
24093: LD_INT 13
24095: PUSH
24096: LD_INT 14
24098: PUSH
24099: EMPTY
24100: LIST
24101: LIST
24102: ST_TO_ADDR
24103: GO 24422
24105: LD_INT 42
24107: DOUBLE
24108: EQUAL
24109: IFTRUE 24113
24111: GO 24139
24113: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
24114: LD_ADDR_VAR 0 3
24118: PUSH
24119: LD_INT 21
24121: PUSH
24122: LD_INT 22
24124: PUSH
24125: LD_INT 23
24127: PUSH
24128: LD_INT 24
24130: PUSH
24131: EMPTY
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: ST_TO_ADDR
24137: GO 24422
24139: LD_INT 43
24141: DOUBLE
24142: EQUAL
24143: IFTRUE 24147
24145: GO 24173
24147: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
24148: LD_ADDR_VAR 0 3
24152: PUSH
24153: LD_INT 21
24155: PUSH
24156: LD_INT 22
24158: PUSH
24159: LD_INT 23
24161: PUSH
24162: LD_INT 24
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: LIST
24169: LIST
24170: ST_TO_ADDR
24171: GO 24422
24173: LD_INT 44
24175: DOUBLE
24176: EQUAL
24177: IFTRUE 24181
24179: GO 24207
24181: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24182: LD_ADDR_VAR 0 3
24186: PUSH
24187: LD_INT 21
24189: PUSH
24190: LD_INT 22
24192: PUSH
24193: LD_INT 23
24195: PUSH
24196: LD_INT 24
24198: PUSH
24199: EMPTY
24200: LIST
24201: LIST
24202: LIST
24203: LIST
24204: ST_TO_ADDR
24205: GO 24422
24207: LD_INT 45
24209: DOUBLE
24210: EQUAL
24211: IFTRUE 24215
24213: GO 24241
24215: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24216: LD_ADDR_VAR 0 3
24220: PUSH
24221: LD_INT 21
24223: PUSH
24224: LD_INT 22
24226: PUSH
24227: LD_INT 23
24229: PUSH
24230: LD_INT 24
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: LIST
24237: LIST
24238: ST_TO_ADDR
24239: GO 24422
24241: LD_INT 49
24243: DOUBLE
24244: EQUAL
24245: IFTRUE 24249
24247: GO 24275
24249: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24250: LD_ADDR_VAR 0 3
24254: PUSH
24255: LD_INT 21
24257: PUSH
24258: LD_INT 22
24260: PUSH
24261: LD_INT 23
24263: PUSH
24264: LD_INT 24
24266: PUSH
24267: EMPTY
24268: LIST
24269: LIST
24270: LIST
24271: LIST
24272: ST_TO_ADDR
24273: GO 24422
24275: LD_INT 51
24277: DOUBLE
24278: EQUAL
24279: IFTRUE 24283
24281: GO 24309
24283: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24284: LD_ADDR_VAR 0 3
24288: PUSH
24289: LD_INT 21
24291: PUSH
24292: LD_INT 22
24294: PUSH
24295: LD_INT 23
24297: PUSH
24298: LD_INT 24
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: LIST
24305: LIST
24306: ST_TO_ADDR
24307: GO 24422
24309: LD_INT 52
24311: DOUBLE
24312: EQUAL
24313: IFTRUE 24317
24315: GO 24343
24317: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24318: LD_ADDR_VAR 0 3
24322: PUSH
24323: LD_INT 21
24325: PUSH
24326: LD_INT 22
24328: PUSH
24329: LD_INT 23
24331: PUSH
24332: LD_INT 24
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: LIST
24339: LIST
24340: ST_TO_ADDR
24341: GO 24422
24343: LD_INT 53
24345: DOUBLE
24346: EQUAL
24347: IFTRUE 24351
24349: GO 24369
24351: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24352: LD_ADDR_VAR 0 3
24356: PUSH
24357: LD_INT 23
24359: PUSH
24360: LD_INT 24
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: ST_TO_ADDR
24367: GO 24422
24369: LD_INT 46
24371: DOUBLE
24372: EQUAL
24373: IFTRUE 24377
24375: GO 24395
24377: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24378: LD_ADDR_VAR 0 3
24382: PUSH
24383: LD_INT 23
24385: PUSH
24386: LD_INT 24
24388: PUSH
24389: EMPTY
24390: LIST
24391: LIST
24392: ST_TO_ADDR
24393: GO 24422
24395: LD_INT 47
24397: DOUBLE
24398: EQUAL
24399: IFTRUE 24403
24401: GO 24421
24403: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24404: LD_ADDR_VAR 0 3
24408: PUSH
24409: LD_INT 23
24411: PUSH
24412: LD_INT 24
24414: PUSH
24415: EMPTY
24416: LIST
24417: LIST
24418: ST_TO_ADDR
24419: GO 24422
24421: POP
// result := ( chassis in result ) ;
24422: LD_ADDR_VAR 0 3
24426: PUSH
24427: LD_VAR 0 1
24431: PUSH
24432: LD_VAR 0 3
24436: IN
24437: ST_TO_ADDR
// end ;
24438: LD_VAR 0 3
24442: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24443: LD_INT 0
24445: PPUSH
24446: PPUSH
24447: PPUSH
24448: PPUSH
24449: PPUSH
24450: PPUSH
24451: PPUSH
// result := array ;
24452: LD_ADDR_VAR 0 5
24456: PUSH
24457: LD_VAR 0 1
24461: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24462: LD_VAR 0 1
24466: NOT
24467: PUSH
24468: LD_VAR 0 2
24472: NOT
24473: OR
24474: PUSH
24475: LD_VAR 0 3
24479: NOT
24480: OR
24481: PUSH
24482: LD_VAR 0 2
24486: PUSH
24487: LD_VAR 0 1
24491: GREATER
24492: OR
24493: PUSH
24494: LD_VAR 0 3
24498: PUSH
24499: LD_VAR 0 1
24503: GREATER
24504: OR
24505: IFFALSE 24509
// exit ;
24507: GO 24805
// if direction then
24509: LD_VAR 0 4
24513: IFFALSE 24577
// begin d := 1 ;
24515: LD_ADDR_VAR 0 9
24519: PUSH
24520: LD_INT 1
24522: ST_TO_ADDR
// if i_from > i_to then
24523: LD_VAR 0 2
24527: PUSH
24528: LD_VAR 0 3
24532: GREATER
24533: IFFALSE 24559
// length := ( array - i_from ) + i_to else
24535: LD_ADDR_VAR 0 11
24539: PUSH
24540: LD_VAR 0 1
24544: PUSH
24545: LD_VAR 0 2
24549: MINUS
24550: PUSH
24551: LD_VAR 0 3
24555: PLUS
24556: ST_TO_ADDR
24557: GO 24575
// length := i_to - i_from ;
24559: LD_ADDR_VAR 0 11
24563: PUSH
24564: LD_VAR 0 3
24568: PUSH
24569: LD_VAR 0 2
24573: MINUS
24574: ST_TO_ADDR
// end else
24575: GO 24638
// begin d := - 1 ;
24577: LD_ADDR_VAR 0 9
24581: PUSH
24582: LD_INT 1
24584: NEG
24585: ST_TO_ADDR
// if i_from > i_to then
24586: LD_VAR 0 2
24590: PUSH
24591: LD_VAR 0 3
24595: GREATER
24596: IFFALSE 24616
// length := i_from - i_to else
24598: LD_ADDR_VAR 0 11
24602: PUSH
24603: LD_VAR 0 2
24607: PUSH
24608: LD_VAR 0 3
24612: MINUS
24613: ST_TO_ADDR
24614: GO 24638
// length := ( array - i_to ) + i_from ;
24616: LD_ADDR_VAR 0 11
24620: PUSH
24621: LD_VAR 0 1
24625: PUSH
24626: LD_VAR 0 3
24630: MINUS
24631: PUSH
24632: LD_VAR 0 2
24636: PLUS
24637: ST_TO_ADDR
// end ; if not length then
24638: LD_VAR 0 11
24642: NOT
24643: IFFALSE 24647
// exit ;
24645: GO 24805
// tmp := array ;
24647: LD_ADDR_VAR 0 10
24651: PUSH
24652: LD_VAR 0 1
24656: ST_TO_ADDR
// for i = 1 to length do
24657: LD_ADDR_VAR 0 6
24661: PUSH
24662: DOUBLE
24663: LD_INT 1
24665: DEC
24666: ST_TO_ADDR
24667: LD_VAR 0 11
24671: PUSH
24672: FOR_TO
24673: IFFALSE 24793
// begin for j = 1 to array do
24675: LD_ADDR_VAR 0 7
24679: PUSH
24680: DOUBLE
24681: LD_INT 1
24683: DEC
24684: ST_TO_ADDR
24685: LD_VAR 0 1
24689: PUSH
24690: FOR_TO
24691: IFFALSE 24779
// begin k := j + d ;
24693: LD_ADDR_VAR 0 8
24697: PUSH
24698: LD_VAR 0 7
24702: PUSH
24703: LD_VAR 0 9
24707: PLUS
24708: ST_TO_ADDR
// if k > array then
24709: LD_VAR 0 8
24713: PUSH
24714: LD_VAR 0 1
24718: GREATER
24719: IFFALSE 24729
// k := 1 ;
24721: LD_ADDR_VAR 0 8
24725: PUSH
24726: LD_INT 1
24728: ST_TO_ADDR
// if not k then
24729: LD_VAR 0 8
24733: NOT
24734: IFFALSE 24746
// k := array ;
24736: LD_ADDR_VAR 0 8
24740: PUSH
24741: LD_VAR 0 1
24745: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24746: LD_ADDR_VAR 0 10
24750: PUSH
24751: LD_VAR 0 10
24755: PPUSH
24756: LD_VAR 0 8
24760: PPUSH
24761: LD_VAR 0 1
24765: PUSH
24766: LD_VAR 0 7
24770: ARRAY
24771: PPUSH
24772: CALL_OW 1
24776: ST_TO_ADDR
// end ;
24777: GO 24690
24779: POP
24780: POP
// array := tmp ;
24781: LD_ADDR_VAR 0 1
24785: PUSH
24786: LD_VAR 0 10
24790: ST_TO_ADDR
// end ;
24791: GO 24672
24793: POP
24794: POP
// result := array ;
24795: LD_ADDR_VAR 0 5
24799: PUSH
24800: LD_VAR 0 1
24804: ST_TO_ADDR
// end ;
24805: LD_VAR 0 5
24809: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24810: LD_INT 0
24812: PPUSH
24813: PPUSH
// result := 0 ;
24814: LD_ADDR_VAR 0 3
24818: PUSH
24819: LD_INT 0
24821: ST_TO_ADDR
// if not array or not value in array then
24822: LD_VAR 0 1
24826: NOT
24827: PUSH
24828: LD_VAR 0 2
24832: PUSH
24833: LD_VAR 0 1
24837: IN
24838: NOT
24839: OR
24840: IFFALSE 24844
// exit ;
24842: GO 24898
// for i = 1 to array do
24844: LD_ADDR_VAR 0 4
24848: PUSH
24849: DOUBLE
24850: LD_INT 1
24852: DEC
24853: ST_TO_ADDR
24854: LD_VAR 0 1
24858: PUSH
24859: FOR_TO
24860: IFFALSE 24896
// if value = array [ i ] then
24862: LD_VAR 0 2
24866: PUSH
24867: LD_VAR 0 1
24871: PUSH
24872: LD_VAR 0 4
24876: ARRAY
24877: EQUAL
24878: IFFALSE 24894
// begin result := i ;
24880: LD_ADDR_VAR 0 3
24884: PUSH
24885: LD_VAR 0 4
24889: ST_TO_ADDR
// exit ;
24890: POP
24891: POP
24892: GO 24898
// end ;
24894: GO 24859
24896: POP
24897: POP
// end ;
24898: LD_VAR 0 3
24902: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24903: LD_INT 0
24905: PPUSH
// vc_chassis := chassis ;
24906: LD_ADDR_OWVAR 37
24910: PUSH
24911: LD_VAR 0 1
24915: ST_TO_ADDR
// vc_engine := engine ;
24916: LD_ADDR_OWVAR 39
24920: PUSH
24921: LD_VAR 0 2
24925: ST_TO_ADDR
// vc_control := control ;
24926: LD_ADDR_OWVAR 38
24930: PUSH
24931: LD_VAR 0 3
24935: ST_TO_ADDR
// vc_weapon := weapon ;
24936: LD_ADDR_OWVAR 40
24940: PUSH
24941: LD_VAR 0 4
24945: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24946: LD_ADDR_OWVAR 41
24950: PUSH
24951: LD_VAR 0 5
24955: ST_TO_ADDR
// end ;
24956: LD_VAR 0 6
24960: RET
// export function WantPlant ( unit ) ; var task ; begin
24961: LD_INT 0
24963: PPUSH
24964: PPUSH
// result := false ;
24965: LD_ADDR_VAR 0 2
24969: PUSH
24970: LD_INT 0
24972: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24973: LD_ADDR_VAR 0 3
24977: PUSH
24978: LD_VAR 0 1
24982: PPUSH
24983: CALL_OW 437
24987: ST_TO_ADDR
// if task then
24988: LD_VAR 0 3
24992: IFFALSE 25020
// if task [ 1 ] [ 1 ] = p then
24994: LD_VAR 0 3
24998: PUSH
24999: LD_INT 1
25001: ARRAY
25002: PUSH
25003: LD_INT 1
25005: ARRAY
25006: PUSH
25007: LD_STRING p
25009: EQUAL
25010: IFFALSE 25020
// result := true ;
25012: LD_ADDR_VAR 0 2
25016: PUSH
25017: LD_INT 1
25019: ST_TO_ADDR
// end ;
25020: LD_VAR 0 2
25024: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
25025: LD_INT 0
25027: PPUSH
25028: PPUSH
25029: PPUSH
25030: PPUSH
// if pos < 1 then
25031: LD_VAR 0 2
25035: PUSH
25036: LD_INT 1
25038: LESS
25039: IFFALSE 25043
// exit ;
25041: GO 25346
// if pos = 1 then
25043: LD_VAR 0 2
25047: PUSH
25048: LD_INT 1
25050: EQUAL
25051: IFFALSE 25084
// result := Replace ( arr , pos [ 1 ] , value ) else
25053: LD_ADDR_VAR 0 4
25057: PUSH
25058: LD_VAR 0 1
25062: PPUSH
25063: LD_VAR 0 2
25067: PUSH
25068: LD_INT 1
25070: ARRAY
25071: PPUSH
25072: LD_VAR 0 3
25076: PPUSH
25077: CALL_OW 1
25081: ST_TO_ADDR
25082: GO 25346
// begin tmp := arr ;
25084: LD_ADDR_VAR 0 6
25088: PUSH
25089: LD_VAR 0 1
25093: ST_TO_ADDR
// s_arr := [ tmp ] ;
25094: LD_ADDR_VAR 0 7
25098: PUSH
25099: LD_VAR 0 6
25103: PUSH
25104: EMPTY
25105: LIST
25106: ST_TO_ADDR
// for i = 1 to pos - 1 do
25107: LD_ADDR_VAR 0 5
25111: PUSH
25112: DOUBLE
25113: LD_INT 1
25115: DEC
25116: ST_TO_ADDR
25117: LD_VAR 0 2
25121: PUSH
25122: LD_INT 1
25124: MINUS
25125: PUSH
25126: FOR_TO
25127: IFFALSE 25172
// begin tmp := tmp [ pos [ i ] ] ;
25129: LD_ADDR_VAR 0 6
25133: PUSH
25134: LD_VAR 0 6
25138: PUSH
25139: LD_VAR 0 2
25143: PUSH
25144: LD_VAR 0 5
25148: ARRAY
25149: ARRAY
25150: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
25151: LD_ADDR_VAR 0 7
25155: PUSH
25156: LD_VAR 0 7
25160: PUSH
25161: LD_VAR 0 6
25165: PUSH
25166: EMPTY
25167: LIST
25168: ADD
25169: ST_TO_ADDR
// end ;
25170: GO 25126
25172: POP
25173: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
25174: LD_ADDR_VAR 0 6
25178: PUSH
25179: LD_VAR 0 6
25183: PPUSH
25184: LD_VAR 0 2
25188: PUSH
25189: LD_VAR 0 2
25193: ARRAY
25194: PPUSH
25195: LD_VAR 0 3
25199: PPUSH
25200: CALL_OW 1
25204: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25205: LD_ADDR_VAR 0 7
25209: PUSH
25210: LD_VAR 0 7
25214: PPUSH
25215: LD_VAR 0 7
25219: PPUSH
25220: LD_VAR 0 6
25224: PPUSH
25225: CALL_OW 1
25229: ST_TO_ADDR
// for i = s_arr downto 2 do
25230: LD_ADDR_VAR 0 5
25234: PUSH
25235: DOUBLE
25236: LD_VAR 0 7
25240: INC
25241: ST_TO_ADDR
25242: LD_INT 2
25244: PUSH
25245: FOR_DOWNTO
25246: IFFALSE 25330
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25248: LD_ADDR_VAR 0 6
25252: PUSH
25253: LD_VAR 0 7
25257: PUSH
25258: LD_VAR 0 5
25262: PUSH
25263: LD_INT 1
25265: MINUS
25266: ARRAY
25267: PPUSH
25268: LD_VAR 0 2
25272: PUSH
25273: LD_VAR 0 5
25277: PUSH
25278: LD_INT 1
25280: MINUS
25281: ARRAY
25282: PPUSH
25283: LD_VAR 0 7
25287: PUSH
25288: LD_VAR 0 5
25292: ARRAY
25293: PPUSH
25294: CALL_OW 1
25298: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25299: LD_ADDR_VAR 0 7
25303: PUSH
25304: LD_VAR 0 7
25308: PPUSH
25309: LD_VAR 0 5
25313: PUSH
25314: LD_INT 1
25316: MINUS
25317: PPUSH
25318: LD_VAR 0 6
25322: PPUSH
25323: CALL_OW 1
25327: ST_TO_ADDR
// end ;
25328: GO 25245
25330: POP
25331: POP
// result := s_arr [ 1 ] ;
25332: LD_ADDR_VAR 0 4
25336: PUSH
25337: LD_VAR 0 7
25341: PUSH
25342: LD_INT 1
25344: ARRAY
25345: ST_TO_ADDR
// end ; end ;
25346: LD_VAR 0 4
25350: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25351: LD_INT 0
25353: PPUSH
25354: PPUSH
// if not list then
25355: LD_VAR 0 1
25359: NOT
25360: IFFALSE 25364
// exit ;
25362: GO 25455
// i := list [ pos1 ] ;
25364: LD_ADDR_VAR 0 5
25368: PUSH
25369: LD_VAR 0 1
25373: PUSH
25374: LD_VAR 0 2
25378: ARRAY
25379: ST_TO_ADDR
// if not i then
25380: LD_VAR 0 5
25384: NOT
25385: IFFALSE 25389
// exit ;
25387: GO 25455
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25389: LD_ADDR_VAR 0 1
25393: PUSH
25394: LD_VAR 0 1
25398: PPUSH
25399: LD_VAR 0 2
25403: PPUSH
25404: LD_VAR 0 1
25408: PUSH
25409: LD_VAR 0 3
25413: ARRAY
25414: PPUSH
25415: CALL_OW 1
25419: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25420: LD_ADDR_VAR 0 1
25424: PUSH
25425: LD_VAR 0 1
25429: PPUSH
25430: LD_VAR 0 3
25434: PPUSH
25435: LD_VAR 0 5
25439: PPUSH
25440: CALL_OW 1
25444: ST_TO_ADDR
// result := list ;
25445: LD_ADDR_VAR 0 4
25449: PUSH
25450: LD_VAR 0 1
25454: ST_TO_ADDR
// end ;
25455: LD_VAR 0 4
25459: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25460: LD_INT 0
25462: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25463: LD_ADDR_VAR 0 5
25467: PUSH
25468: LD_VAR 0 1
25472: PPUSH
25473: CALL_OW 250
25477: PPUSH
25478: LD_VAR 0 1
25482: PPUSH
25483: CALL_OW 251
25487: PPUSH
25488: LD_VAR 0 2
25492: PPUSH
25493: LD_VAR 0 3
25497: PPUSH
25498: LD_VAR 0 4
25502: PPUSH
25503: CALL 25513 0 5
25507: ST_TO_ADDR
// end ;
25508: LD_VAR 0 5
25512: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25513: LD_INT 0
25515: PPUSH
25516: PPUSH
25517: PPUSH
25518: PPUSH
// if not list then
25519: LD_VAR 0 3
25523: NOT
25524: IFFALSE 25528
// exit ;
25526: GO 25916
// result := [ ] ;
25528: LD_ADDR_VAR 0 6
25532: PUSH
25533: EMPTY
25534: ST_TO_ADDR
// for i in list do
25535: LD_ADDR_VAR 0 7
25539: PUSH
25540: LD_VAR 0 3
25544: PUSH
25545: FOR_IN
25546: IFFALSE 25748
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25548: LD_ADDR_VAR 0 9
25552: PUSH
25553: LD_VAR 0 7
25557: PPUSH
25558: LD_VAR 0 1
25562: PPUSH
25563: LD_VAR 0 2
25567: PPUSH
25568: CALL_OW 297
25572: ST_TO_ADDR
// if not result then
25573: LD_VAR 0 6
25577: NOT
25578: IFFALSE 25604
// result := [ [ i , tmp ] ] else
25580: LD_ADDR_VAR 0 6
25584: PUSH
25585: LD_VAR 0 7
25589: PUSH
25590: LD_VAR 0 9
25594: PUSH
25595: EMPTY
25596: LIST
25597: LIST
25598: PUSH
25599: EMPTY
25600: LIST
25601: ST_TO_ADDR
25602: GO 25746
// begin if result [ result ] [ 2 ] < tmp then
25604: LD_VAR 0 6
25608: PUSH
25609: LD_VAR 0 6
25613: ARRAY
25614: PUSH
25615: LD_INT 2
25617: ARRAY
25618: PUSH
25619: LD_VAR 0 9
25623: LESS
25624: IFFALSE 25666
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25626: LD_ADDR_VAR 0 6
25630: PUSH
25631: LD_VAR 0 6
25635: PPUSH
25636: LD_VAR 0 6
25640: PUSH
25641: LD_INT 1
25643: PLUS
25644: PPUSH
25645: LD_VAR 0 7
25649: PUSH
25650: LD_VAR 0 9
25654: PUSH
25655: EMPTY
25656: LIST
25657: LIST
25658: PPUSH
25659: CALL_OW 2
25663: ST_TO_ADDR
25664: GO 25746
// for j = 1 to result do
25666: LD_ADDR_VAR 0 8
25670: PUSH
25671: DOUBLE
25672: LD_INT 1
25674: DEC
25675: ST_TO_ADDR
25676: LD_VAR 0 6
25680: PUSH
25681: FOR_TO
25682: IFFALSE 25744
// begin if tmp < result [ j ] [ 2 ] then
25684: LD_VAR 0 9
25688: PUSH
25689: LD_VAR 0 6
25693: PUSH
25694: LD_VAR 0 8
25698: ARRAY
25699: PUSH
25700: LD_INT 2
25702: ARRAY
25703: LESS
25704: IFFALSE 25742
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25706: LD_ADDR_VAR 0 6
25710: PUSH
25711: LD_VAR 0 6
25715: PPUSH
25716: LD_VAR 0 8
25720: PPUSH
25721: LD_VAR 0 7
25725: PUSH
25726: LD_VAR 0 9
25730: PUSH
25731: EMPTY
25732: LIST
25733: LIST
25734: PPUSH
25735: CALL_OW 2
25739: ST_TO_ADDR
// break ;
25740: GO 25744
// end ; end ;
25742: GO 25681
25744: POP
25745: POP
// end ; end ;
25746: GO 25545
25748: POP
25749: POP
// if result and not asc then
25750: LD_VAR 0 6
25754: PUSH
25755: LD_VAR 0 4
25759: NOT
25760: AND
25761: IFFALSE 25836
// begin tmp := result ;
25763: LD_ADDR_VAR 0 9
25767: PUSH
25768: LD_VAR 0 6
25772: ST_TO_ADDR
// for i = tmp downto 1 do
25773: LD_ADDR_VAR 0 7
25777: PUSH
25778: DOUBLE
25779: LD_VAR 0 9
25783: INC
25784: ST_TO_ADDR
25785: LD_INT 1
25787: PUSH
25788: FOR_DOWNTO
25789: IFFALSE 25834
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25791: LD_ADDR_VAR 0 6
25795: PUSH
25796: LD_VAR 0 6
25800: PPUSH
25801: LD_VAR 0 9
25805: PUSH
25806: LD_VAR 0 7
25810: MINUS
25811: PUSH
25812: LD_INT 1
25814: PLUS
25815: PPUSH
25816: LD_VAR 0 9
25820: PUSH
25821: LD_VAR 0 7
25825: ARRAY
25826: PPUSH
25827: CALL_OW 1
25831: ST_TO_ADDR
25832: GO 25788
25834: POP
25835: POP
// end ; tmp := [ ] ;
25836: LD_ADDR_VAR 0 9
25840: PUSH
25841: EMPTY
25842: ST_TO_ADDR
// if mode then
25843: LD_VAR 0 5
25847: IFFALSE 25916
// begin for i = 1 to result do
25849: LD_ADDR_VAR 0 7
25853: PUSH
25854: DOUBLE
25855: LD_INT 1
25857: DEC
25858: ST_TO_ADDR
25859: LD_VAR 0 6
25863: PUSH
25864: FOR_TO
25865: IFFALSE 25904
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25867: LD_ADDR_VAR 0 9
25871: PUSH
25872: LD_VAR 0 9
25876: PPUSH
25877: LD_VAR 0 7
25881: PPUSH
25882: LD_VAR 0 6
25886: PUSH
25887: LD_VAR 0 7
25891: ARRAY
25892: PUSH
25893: LD_INT 1
25895: ARRAY
25896: PPUSH
25897: CALL_OW 1
25901: ST_TO_ADDR
25902: GO 25864
25904: POP
25905: POP
// result := tmp ;
25906: LD_ADDR_VAR 0 6
25910: PUSH
25911: LD_VAR 0 9
25915: ST_TO_ADDR
// end ; end ;
25916: LD_VAR 0 6
25920: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25921: LD_INT 0
25923: PPUSH
25924: PPUSH
25925: PPUSH
25926: PPUSH
25927: PPUSH
25928: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25929: LD_ADDR_VAR 0 5
25933: PUSH
25934: LD_INT 0
25936: PUSH
25937: LD_INT 0
25939: PUSH
25940: LD_INT 0
25942: PUSH
25943: EMPTY
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: LIST
25949: LIST
25950: ST_TO_ADDR
// if not x or not y then
25951: LD_VAR 0 2
25955: NOT
25956: PUSH
25957: LD_VAR 0 3
25961: NOT
25962: OR
25963: IFFALSE 25967
// exit ;
25965: GO 27619
// if not range then
25967: LD_VAR 0 4
25971: NOT
25972: IFFALSE 25982
// range := 10 ;
25974: LD_ADDR_VAR 0 4
25978: PUSH
25979: LD_INT 10
25981: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25982: LD_ADDR_VAR 0 8
25986: PUSH
25987: LD_INT 81
25989: PUSH
25990: LD_VAR 0 1
25994: PUSH
25995: EMPTY
25996: LIST
25997: LIST
25998: PUSH
25999: LD_INT 92
26001: PUSH
26002: LD_VAR 0 2
26006: PUSH
26007: LD_VAR 0 3
26011: PUSH
26012: LD_VAR 0 4
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: LIST
26021: LIST
26022: PUSH
26023: LD_INT 3
26025: PUSH
26026: LD_INT 21
26028: PUSH
26029: LD_INT 3
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: PUSH
26040: EMPTY
26041: LIST
26042: LIST
26043: LIST
26044: PPUSH
26045: CALL_OW 69
26049: ST_TO_ADDR
// if not tmp then
26050: LD_VAR 0 8
26054: NOT
26055: IFFALSE 26059
// exit ;
26057: GO 27619
// for i in tmp do
26059: LD_ADDR_VAR 0 6
26063: PUSH
26064: LD_VAR 0 8
26068: PUSH
26069: FOR_IN
26070: IFFALSE 27594
// begin points := [ 0 , 0 , 0 ] ;
26072: LD_ADDR_VAR 0 9
26076: PUSH
26077: LD_INT 0
26079: PUSH
26080: LD_INT 0
26082: PUSH
26083: LD_INT 0
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: LIST
26090: ST_TO_ADDR
// bpoints := 1 ;
26091: LD_ADDR_VAR 0 10
26095: PUSH
26096: LD_INT 1
26098: ST_TO_ADDR
// case GetType ( i ) of unit_human :
26099: LD_VAR 0 6
26103: PPUSH
26104: CALL_OW 247
26108: PUSH
26109: LD_INT 1
26111: DOUBLE
26112: EQUAL
26113: IFTRUE 26117
26115: GO 26695
26117: POP
// begin if GetClass ( i ) = 1 then
26118: LD_VAR 0 6
26122: PPUSH
26123: CALL_OW 257
26127: PUSH
26128: LD_INT 1
26130: EQUAL
26131: IFFALSE 26152
// points := [ 10 , 5 , 3 ] ;
26133: LD_ADDR_VAR 0 9
26137: PUSH
26138: LD_INT 10
26140: PUSH
26141: LD_INT 5
26143: PUSH
26144: LD_INT 3
26146: PUSH
26147: EMPTY
26148: LIST
26149: LIST
26150: LIST
26151: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
26152: LD_VAR 0 6
26156: PPUSH
26157: CALL_OW 257
26161: PUSH
26162: LD_INT 2
26164: PUSH
26165: LD_INT 3
26167: PUSH
26168: LD_INT 4
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: LIST
26175: IN
26176: IFFALSE 26197
// points := [ 3 , 2 , 1 ] ;
26178: LD_ADDR_VAR 0 9
26182: PUSH
26183: LD_INT 3
26185: PUSH
26186: LD_INT 2
26188: PUSH
26189: LD_INT 1
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: LIST
26196: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26197: LD_VAR 0 6
26201: PPUSH
26202: CALL_OW 257
26206: PUSH
26207: LD_INT 5
26209: EQUAL
26210: IFFALSE 26231
// points := [ 130 , 5 , 2 ] ;
26212: LD_ADDR_VAR 0 9
26216: PUSH
26217: LD_INT 130
26219: PUSH
26220: LD_INT 5
26222: PUSH
26223: LD_INT 2
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: LIST
26230: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26231: LD_VAR 0 6
26235: PPUSH
26236: CALL_OW 257
26240: PUSH
26241: LD_INT 8
26243: EQUAL
26244: IFFALSE 26265
// points := [ 35 , 35 , 30 ] ;
26246: LD_ADDR_VAR 0 9
26250: PUSH
26251: LD_INT 35
26253: PUSH
26254: LD_INT 35
26256: PUSH
26257: LD_INT 30
26259: PUSH
26260: EMPTY
26261: LIST
26262: LIST
26263: LIST
26264: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26265: LD_VAR 0 6
26269: PPUSH
26270: CALL_OW 257
26274: PUSH
26275: LD_INT 9
26277: EQUAL
26278: IFFALSE 26299
// points := [ 20 , 55 , 40 ] ;
26280: LD_ADDR_VAR 0 9
26284: PUSH
26285: LD_INT 20
26287: PUSH
26288: LD_INT 55
26290: PUSH
26291: LD_INT 40
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: LIST
26298: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26299: LD_VAR 0 6
26303: PPUSH
26304: CALL_OW 257
26308: PUSH
26309: LD_INT 12
26311: PUSH
26312: LD_INT 16
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: IN
26319: IFFALSE 26340
// points := [ 5 , 3 , 2 ] ;
26321: LD_ADDR_VAR 0 9
26325: PUSH
26326: LD_INT 5
26328: PUSH
26329: LD_INT 3
26331: PUSH
26332: LD_INT 2
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: LIST
26339: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26340: LD_VAR 0 6
26344: PPUSH
26345: CALL_OW 257
26349: PUSH
26350: LD_INT 17
26352: EQUAL
26353: IFFALSE 26374
// points := [ 100 , 50 , 75 ] ;
26355: LD_ADDR_VAR 0 9
26359: PUSH
26360: LD_INT 100
26362: PUSH
26363: LD_INT 50
26365: PUSH
26366: LD_INT 75
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: LIST
26373: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26374: LD_VAR 0 6
26378: PPUSH
26379: CALL_OW 257
26383: PUSH
26384: LD_INT 15
26386: EQUAL
26387: IFFALSE 26408
// points := [ 10 , 5 , 3 ] ;
26389: LD_ADDR_VAR 0 9
26393: PUSH
26394: LD_INT 10
26396: PUSH
26397: LD_INT 5
26399: PUSH
26400: LD_INT 3
26402: PUSH
26403: EMPTY
26404: LIST
26405: LIST
26406: LIST
26407: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26408: LD_VAR 0 6
26412: PPUSH
26413: CALL_OW 257
26417: PUSH
26418: LD_INT 14
26420: EQUAL
26421: IFFALSE 26442
// points := [ 10 , 0 , 0 ] ;
26423: LD_ADDR_VAR 0 9
26427: PUSH
26428: LD_INT 10
26430: PUSH
26431: LD_INT 0
26433: PUSH
26434: LD_INT 0
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: LIST
26441: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26442: LD_VAR 0 6
26446: PPUSH
26447: CALL_OW 257
26451: PUSH
26452: LD_INT 11
26454: EQUAL
26455: IFFALSE 26476
// points := [ 30 , 10 , 5 ] ;
26457: LD_ADDR_VAR 0 9
26461: PUSH
26462: LD_INT 30
26464: PUSH
26465: LD_INT 10
26467: PUSH
26468: LD_INT 5
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: LIST
26475: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26476: LD_VAR 0 1
26480: PPUSH
26481: LD_INT 5
26483: PPUSH
26484: CALL_OW 321
26488: PUSH
26489: LD_INT 2
26491: EQUAL
26492: IFFALSE 26509
// bpoints := bpoints * 1.8 ;
26494: LD_ADDR_VAR 0 10
26498: PUSH
26499: LD_VAR 0 10
26503: PUSH
26504: LD_REAL  1.80000000000000E+0000
26507: MUL
26508: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26509: LD_VAR 0 6
26513: PPUSH
26514: CALL_OW 257
26518: PUSH
26519: LD_INT 1
26521: PUSH
26522: LD_INT 2
26524: PUSH
26525: LD_INT 3
26527: PUSH
26528: LD_INT 4
26530: PUSH
26531: EMPTY
26532: LIST
26533: LIST
26534: LIST
26535: LIST
26536: IN
26537: PUSH
26538: LD_VAR 0 1
26542: PPUSH
26543: LD_INT 51
26545: PPUSH
26546: CALL_OW 321
26550: PUSH
26551: LD_INT 2
26553: EQUAL
26554: AND
26555: IFFALSE 26572
// bpoints := bpoints * 1.2 ;
26557: LD_ADDR_VAR 0 10
26561: PUSH
26562: LD_VAR 0 10
26566: PUSH
26567: LD_REAL  1.20000000000000E+0000
26570: MUL
26571: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26572: LD_VAR 0 6
26576: PPUSH
26577: CALL_OW 257
26581: PUSH
26582: LD_INT 5
26584: PUSH
26585: LD_INT 7
26587: PUSH
26588: LD_INT 9
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: LIST
26595: IN
26596: PUSH
26597: LD_VAR 0 1
26601: PPUSH
26602: LD_INT 52
26604: PPUSH
26605: CALL_OW 321
26609: PUSH
26610: LD_INT 2
26612: EQUAL
26613: AND
26614: IFFALSE 26631
// bpoints := bpoints * 1.5 ;
26616: LD_ADDR_VAR 0 10
26620: PUSH
26621: LD_VAR 0 10
26625: PUSH
26626: LD_REAL  1.50000000000000E+0000
26629: MUL
26630: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26631: LD_VAR 0 1
26635: PPUSH
26636: LD_INT 66
26638: PPUSH
26639: CALL_OW 321
26643: PUSH
26644: LD_INT 2
26646: EQUAL
26647: IFFALSE 26664
// bpoints := bpoints * 1.1 ;
26649: LD_ADDR_VAR 0 10
26653: PUSH
26654: LD_VAR 0 10
26658: PUSH
26659: LD_REAL  1.10000000000000E+0000
26662: MUL
26663: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26664: LD_ADDR_VAR 0 10
26668: PUSH
26669: LD_VAR 0 10
26673: PUSH
26674: LD_VAR 0 6
26678: PPUSH
26679: LD_INT 1
26681: PPUSH
26682: CALL_OW 259
26686: PUSH
26687: LD_REAL  1.15000000000000E+0000
26690: MUL
26691: MUL
26692: ST_TO_ADDR
// end ; unit_vehicle :
26693: GO 27523
26695: LD_INT 2
26697: DOUBLE
26698: EQUAL
26699: IFTRUE 26703
26701: GO 27511
26703: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26704: LD_VAR 0 6
26708: PPUSH
26709: CALL_OW 264
26713: PUSH
26714: LD_INT 2
26716: PUSH
26717: LD_INT 42
26719: PUSH
26720: LD_INT 24
26722: PUSH
26723: EMPTY
26724: LIST
26725: LIST
26726: LIST
26727: IN
26728: IFFALSE 26749
// points := [ 25 , 5 , 3 ] ;
26730: LD_ADDR_VAR 0 9
26734: PUSH
26735: LD_INT 25
26737: PUSH
26738: LD_INT 5
26740: PUSH
26741: LD_INT 3
26743: PUSH
26744: EMPTY
26745: LIST
26746: LIST
26747: LIST
26748: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26749: LD_VAR 0 6
26753: PPUSH
26754: CALL_OW 264
26758: PUSH
26759: LD_INT 4
26761: PUSH
26762: LD_INT 43
26764: PUSH
26765: LD_INT 25
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: LIST
26772: IN
26773: IFFALSE 26794
// points := [ 40 , 15 , 5 ] ;
26775: LD_ADDR_VAR 0 9
26779: PUSH
26780: LD_INT 40
26782: PUSH
26783: LD_INT 15
26785: PUSH
26786: LD_INT 5
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: LIST
26793: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26794: LD_VAR 0 6
26798: PPUSH
26799: CALL_OW 264
26803: PUSH
26804: LD_INT 3
26806: PUSH
26807: LD_INT 23
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: IN
26814: IFFALSE 26835
// points := [ 7 , 25 , 8 ] ;
26816: LD_ADDR_VAR 0 9
26820: PUSH
26821: LD_INT 7
26823: PUSH
26824: LD_INT 25
26826: PUSH
26827: LD_INT 8
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: LIST
26834: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26835: LD_VAR 0 6
26839: PPUSH
26840: CALL_OW 264
26844: PUSH
26845: LD_INT 5
26847: PUSH
26848: LD_INT 27
26850: PUSH
26851: LD_INT 44
26853: PUSH
26854: EMPTY
26855: LIST
26856: LIST
26857: LIST
26858: IN
26859: IFFALSE 26880
// points := [ 14 , 50 , 16 ] ;
26861: LD_ADDR_VAR 0 9
26865: PUSH
26866: LD_INT 14
26868: PUSH
26869: LD_INT 50
26871: PUSH
26872: LD_INT 16
26874: PUSH
26875: EMPTY
26876: LIST
26877: LIST
26878: LIST
26879: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26880: LD_VAR 0 6
26884: PPUSH
26885: CALL_OW 264
26889: PUSH
26890: LD_INT 6
26892: PUSH
26893: LD_INT 46
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: IN
26900: IFFALSE 26921
// points := [ 32 , 120 , 70 ] ;
26902: LD_ADDR_VAR 0 9
26906: PUSH
26907: LD_INT 32
26909: PUSH
26910: LD_INT 120
26912: PUSH
26913: LD_INT 70
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: LIST
26920: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26921: LD_VAR 0 6
26925: PPUSH
26926: CALL_OW 264
26930: PUSH
26931: LD_INT 7
26933: PUSH
26934: LD_INT 28
26936: PUSH
26937: LD_INT 45
26939: PUSH
26940: LD_EXP 34
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: LIST
26949: LIST
26950: IN
26951: IFFALSE 26972
// points := [ 35 , 20 , 45 ] ;
26953: LD_ADDR_VAR 0 9
26957: PUSH
26958: LD_INT 35
26960: PUSH
26961: LD_INT 20
26963: PUSH
26964: LD_INT 45
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: LIST
26971: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26972: LD_VAR 0 6
26976: PPUSH
26977: CALL_OW 264
26981: PUSH
26982: LD_INT 47
26984: PUSH
26985: EMPTY
26986: LIST
26987: IN
26988: IFFALSE 27009
// points := [ 67 , 45 , 75 ] ;
26990: LD_ADDR_VAR 0 9
26994: PUSH
26995: LD_INT 67
26997: PUSH
26998: LD_INT 45
27000: PUSH
27001: LD_INT 75
27003: PUSH
27004: EMPTY
27005: LIST
27006: LIST
27007: LIST
27008: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
27009: LD_VAR 0 6
27013: PPUSH
27014: CALL_OW 264
27018: PUSH
27019: LD_INT 26
27021: PUSH
27022: EMPTY
27023: LIST
27024: IN
27025: IFFALSE 27046
// points := [ 120 , 30 , 80 ] ;
27027: LD_ADDR_VAR 0 9
27031: PUSH
27032: LD_INT 120
27034: PUSH
27035: LD_INT 30
27037: PUSH
27038: LD_INT 80
27040: PUSH
27041: EMPTY
27042: LIST
27043: LIST
27044: LIST
27045: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
27046: LD_VAR 0 6
27050: PPUSH
27051: CALL_OW 264
27055: PUSH
27056: LD_INT 22
27058: PUSH
27059: EMPTY
27060: LIST
27061: IN
27062: IFFALSE 27083
// points := [ 40 , 1 , 1 ] ;
27064: LD_ADDR_VAR 0 9
27068: PUSH
27069: LD_INT 40
27071: PUSH
27072: LD_INT 1
27074: PUSH
27075: LD_INT 1
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: LIST
27082: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
27083: LD_VAR 0 6
27087: PPUSH
27088: CALL_OW 264
27092: PUSH
27093: LD_INT 29
27095: PUSH
27096: EMPTY
27097: LIST
27098: IN
27099: IFFALSE 27120
// points := [ 70 , 200 , 400 ] ;
27101: LD_ADDR_VAR 0 9
27105: PUSH
27106: LD_INT 70
27108: PUSH
27109: LD_INT 200
27111: PUSH
27112: LD_INT 400
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: LIST
27119: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
27120: LD_VAR 0 6
27124: PPUSH
27125: CALL_OW 264
27129: PUSH
27130: LD_INT 14
27132: PUSH
27133: LD_INT 53
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: IN
27140: IFFALSE 27161
// points := [ 40 , 10 , 20 ] ;
27142: LD_ADDR_VAR 0 9
27146: PUSH
27147: LD_INT 40
27149: PUSH
27150: LD_INT 10
27152: PUSH
27153: LD_INT 20
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: LIST
27160: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
27161: LD_VAR 0 6
27165: PPUSH
27166: CALL_OW 264
27170: PUSH
27171: LD_INT 9
27173: PUSH
27174: EMPTY
27175: LIST
27176: IN
27177: IFFALSE 27198
// points := [ 5 , 70 , 20 ] ;
27179: LD_ADDR_VAR 0 9
27183: PUSH
27184: LD_INT 5
27186: PUSH
27187: LD_INT 70
27189: PUSH
27190: LD_INT 20
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: LIST
27197: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27198: LD_VAR 0 6
27202: PPUSH
27203: CALL_OW 264
27207: PUSH
27208: LD_INT 10
27210: PUSH
27211: EMPTY
27212: LIST
27213: IN
27214: IFFALSE 27235
// points := [ 35 , 110 , 70 ] ;
27216: LD_ADDR_VAR 0 9
27220: PUSH
27221: LD_INT 35
27223: PUSH
27224: LD_INT 110
27226: PUSH
27227: LD_INT 70
27229: PUSH
27230: EMPTY
27231: LIST
27232: LIST
27233: LIST
27234: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27235: LD_VAR 0 6
27239: PPUSH
27240: CALL_OW 265
27244: PUSH
27245: LD_INT 25
27247: EQUAL
27248: IFFALSE 27269
// points := [ 80 , 65 , 100 ] ;
27250: LD_ADDR_VAR 0 9
27254: PUSH
27255: LD_INT 80
27257: PUSH
27258: LD_INT 65
27260: PUSH
27261: LD_INT 100
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: LIST
27268: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27269: LD_VAR 0 6
27273: PPUSH
27274: CALL_OW 263
27278: PUSH
27279: LD_INT 1
27281: EQUAL
27282: IFFALSE 27317
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27284: LD_ADDR_VAR 0 10
27288: PUSH
27289: LD_VAR 0 10
27293: PUSH
27294: LD_VAR 0 6
27298: PPUSH
27299: CALL_OW 311
27303: PPUSH
27304: LD_INT 3
27306: PPUSH
27307: CALL_OW 259
27311: PUSH
27312: LD_INT 4
27314: MUL
27315: MUL
27316: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27317: LD_VAR 0 6
27321: PPUSH
27322: CALL_OW 263
27326: PUSH
27327: LD_INT 2
27329: EQUAL
27330: IFFALSE 27381
// begin j := IsControledBy ( i ) ;
27332: LD_ADDR_VAR 0 7
27336: PUSH
27337: LD_VAR 0 6
27341: PPUSH
27342: CALL_OW 312
27346: ST_TO_ADDR
// if j then
27347: LD_VAR 0 7
27351: IFFALSE 27381
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27353: LD_ADDR_VAR 0 10
27357: PUSH
27358: LD_VAR 0 10
27362: PUSH
27363: LD_VAR 0 7
27367: PPUSH
27368: LD_INT 3
27370: PPUSH
27371: CALL_OW 259
27375: PUSH
27376: LD_INT 3
27378: MUL
27379: MUL
27380: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27381: LD_VAR 0 6
27385: PPUSH
27386: CALL_OW 264
27390: PUSH
27391: LD_INT 5
27393: PUSH
27394: LD_INT 6
27396: PUSH
27397: LD_INT 46
27399: PUSH
27400: LD_INT 44
27402: PUSH
27403: LD_INT 47
27405: PUSH
27406: LD_INT 45
27408: PUSH
27409: LD_INT 28
27411: PUSH
27412: LD_INT 7
27414: PUSH
27415: LD_INT 27
27417: PUSH
27418: LD_INT 29
27420: PUSH
27421: EMPTY
27422: LIST
27423: LIST
27424: LIST
27425: LIST
27426: LIST
27427: LIST
27428: LIST
27429: LIST
27430: LIST
27431: LIST
27432: IN
27433: PUSH
27434: LD_VAR 0 1
27438: PPUSH
27439: LD_INT 52
27441: PPUSH
27442: CALL_OW 321
27446: PUSH
27447: LD_INT 2
27449: EQUAL
27450: AND
27451: IFFALSE 27468
// bpoints := bpoints * 1.2 ;
27453: LD_ADDR_VAR 0 10
27457: PUSH
27458: LD_VAR 0 10
27462: PUSH
27463: LD_REAL  1.20000000000000E+0000
27466: MUL
27467: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27468: LD_VAR 0 6
27472: PPUSH
27473: CALL_OW 264
27477: PUSH
27478: LD_INT 6
27480: PUSH
27481: LD_INT 46
27483: PUSH
27484: LD_INT 47
27486: PUSH
27487: EMPTY
27488: LIST
27489: LIST
27490: LIST
27491: IN
27492: IFFALSE 27509
// bpoints := bpoints * 1.2 ;
27494: LD_ADDR_VAR 0 10
27498: PUSH
27499: LD_VAR 0 10
27503: PUSH
27504: LD_REAL  1.20000000000000E+0000
27507: MUL
27508: ST_TO_ADDR
// end ; unit_building :
27509: GO 27523
27511: LD_INT 3
27513: DOUBLE
27514: EQUAL
27515: IFTRUE 27519
27517: GO 27522
27519: POP
// ; end ;
27520: GO 27523
27522: POP
// for j = 1 to 3 do
27523: LD_ADDR_VAR 0 7
27527: PUSH
27528: DOUBLE
27529: LD_INT 1
27531: DEC
27532: ST_TO_ADDR
27533: LD_INT 3
27535: PUSH
27536: FOR_TO
27537: IFFALSE 27590
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27539: LD_ADDR_VAR 0 5
27543: PUSH
27544: LD_VAR 0 5
27548: PPUSH
27549: LD_VAR 0 7
27553: PPUSH
27554: LD_VAR 0 5
27558: PUSH
27559: LD_VAR 0 7
27563: ARRAY
27564: PUSH
27565: LD_VAR 0 9
27569: PUSH
27570: LD_VAR 0 7
27574: ARRAY
27575: PUSH
27576: LD_VAR 0 10
27580: MUL
27581: PLUS
27582: PPUSH
27583: CALL_OW 1
27587: ST_TO_ADDR
27588: GO 27536
27590: POP
27591: POP
// end ;
27592: GO 26069
27594: POP
27595: POP
// result := Replace ( result , 4 , tmp ) ;
27596: LD_ADDR_VAR 0 5
27600: PUSH
27601: LD_VAR 0 5
27605: PPUSH
27606: LD_INT 4
27608: PPUSH
27609: LD_VAR 0 8
27613: PPUSH
27614: CALL_OW 1
27618: ST_TO_ADDR
// end ;
27619: LD_VAR 0 5
27623: RET
// export function DangerAtRange ( unit , range ) ; begin
27624: LD_INT 0
27626: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27627: LD_ADDR_VAR 0 3
27631: PUSH
27632: LD_VAR 0 1
27636: PPUSH
27637: CALL_OW 255
27641: PPUSH
27642: LD_VAR 0 1
27646: PPUSH
27647: CALL_OW 250
27651: PPUSH
27652: LD_VAR 0 1
27656: PPUSH
27657: CALL_OW 251
27661: PPUSH
27662: LD_VAR 0 2
27666: PPUSH
27667: CALL 25921 0 4
27671: ST_TO_ADDR
// end ;
27672: LD_VAR 0 3
27676: RET
// export function DangerInArea ( side , area ) ; begin
27677: LD_INT 0
27679: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27680: LD_ADDR_VAR 0 3
27684: PUSH
27685: LD_VAR 0 2
27689: PPUSH
27690: LD_INT 81
27692: PUSH
27693: LD_VAR 0 1
27697: PUSH
27698: EMPTY
27699: LIST
27700: LIST
27701: PPUSH
27702: CALL_OW 70
27706: ST_TO_ADDR
// end ;
27707: LD_VAR 0 3
27711: RET
// export function IsExtension ( b ) ; begin
27712: LD_INT 0
27714: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27715: LD_ADDR_VAR 0 2
27719: PUSH
27720: LD_VAR 0 1
27724: PUSH
27725: LD_INT 23
27727: PUSH
27728: LD_INT 20
27730: PUSH
27731: LD_INT 22
27733: PUSH
27734: LD_INT 17
27736: PUSH
27737: LD_INT 24
27739: PUSH
27740: LD_INT 21
27742: PUSH
27743: LD_INT 19
27745: PUSH
27746: LD_INT 16
27748: PUSH
27749: LD_INT 25
27751: PUSH
27752: LD_INT 18
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: LIST
27759: LIST
27760: LIST
27761: LIST
27762: LIST
27763: LIST
27764: LIST
27765: LIST
27766: IN
27767: ST_TO_ADDR
// end ;
27768: LD_VAR 0 2
27772: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27773: LD_INT 0
27775: PPUSH
27776: PPUSH
27777: PPUSH
// result := [ ] ;
27778: LD_ADDR_VAR 0 4
27782: PUSH
27783: EMPTY
27784: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27785: LD_ADDR_VAR 0 5
27789: PUSH
27790: LD_VAR 0 2
27794: PPUSH
27795: LD_INT 21
27797: PUSH
27798: LD_INT 3
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: PPUSH
27805: CALL_OW 70
27809: ST_TO_ADDR
// if not tmp then
27810: LD_VAR 0 5
27814: NOT
27815: IFFALSE 27819
// exit ;
27817: GO 27883
// if checkLink then
27819: LD_VAR 0 3
27823: IFFALSE 27873
// begin for i in tmp do
27825: LD_ADDR_VAR 0 6
27829: PUSH
27830: LD_VAR 0 5
27834: PUSH
27835: FOR_IN
27836: IFFALSE 27871
// if GetBase ( i ) <> base then
27838: LD_VAR 0 6
27842: PPUSH
27843: CALL_OW 274
27847: PUSH
27848: LD_VAR 0 1
27852: NONEQUAL
27853: IFFALSE 27869
// ComLinkToBase ( base , i ) ;
27855: LD_VAR 0 1
27859: PPUSH
27860: LD_VAR 0 6
27864: PPUSH
27865: CALL_OW 169
27869: GO 27835
27871: POP
27872: POP
// end ; result := tmp ;
27873: LD_ADDR_VAR 0 4
27877: PUSH
27878: LD_VAR 0 5
27882: ST_TO_ADDR
// end ;
27883: LD_VAR 0 4
27887: RET
// export function ComComplete ( units , b ) ; var i ; begin
27888: LD_INT 0
27890: PPUSH
27891: PPUSH
// if not units then
27892: LD_VAR 0 1
27896: NOT
27897: IFFALSE 27901
// exit ;
27899: GO 27991
// for i in units do
27901: LD_ADDR_VAR 0 4
27905: PUSH
27906: LD_VAR 0 1
27910: PUSH
27911: FOR_IN
27912: IFFALSE 27989
// if BuildingStatus ( b ) = bs_build then
27914: LD_VAR 0 2
27918: PPUSH
27919: CALL_OW 461
27923: PUSH
27924: LD_INT 1
27926: EQUAL
27927: IFFALSE 27987
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27929: LD_VAR 0 4
27933: PPUSH
27934: LD_STRING h
27936: PUSH
27937: LD_VAR 0 2
27941: PPUSH
27942: CALL_OW 250
27946: PUSH
27947: LD_VAR 0 2
27951: PPUSH
27952: CALL_OW 251
27956: PUSH
27957: LD_VAR 0 2
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: LD_INT 0
27967: PUSH
27968: LD_INT 0
27970: PUSH
27971: EMPTY
27972: LIST
27973: LIST
27974: LIST
27975: LIST
27976: LIST
27977: LIST
27978: LIST
27979: PUSH
27980: EMPTY
27981: LIST
27982: PPUSH
27983: CALL_OW 446
27987: GO 27911
27989: POP
27990: POP
// end ;
27991: LD_VAR 0 3
27995: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27996: LD_INT 0
27998: PPUSH
27999: PPUSH
28000: PPUSH
28001: PPUSH
28002: PPUSH
28003: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
28004: LD_VAR 0 1
28008: NOT
28009: PUSH
28010: LD_VAR 0 1
28014: PPUSH
28015: CALL_OW 263
28019: PUSH
28020: LD_INT 2
28022: NONEQUAL
28023: OR
28024: IFFALSE 28028
// exit ;
28026: GO 28344
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
28028: LD_ADDR_VAR 0 6
28032: PUSH
28033: LD_INT 22
28035: PUSH
28036: LD_VAR 0 1
28040: PPUSH
28041: CALL_OW 255
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PUSH
28050: LD_INT 2
28052: PUSH
28053: LD_INT 30
28055: PUSH
28056: LD_INT 36
28058: PUSH
28059: EMPTY
28060: LIST
28061: LIST
28062: PUSH
28063: LD_INT 34
28065: PUSH
28066: LD_INT 31
28068: PUSH
28069: EMPTY
28070: LIST
28071: LIST
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: LIST
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: PPUSH
28082: CALL_OW 69
28086: ST_TO_ADDR
// if not tmp then
28087: LD_VAR 0 6
28091: NOT
28092: IFFALSE 28096
// exit ;
28094: GO 28344
// result := [ ] ;
28096: LD_ADDR_VAR 0 2
28100: PUSH
28101: EMPTY
28102: ST_TO_ADDR
// for i in tmp do
28103: LD_ADDR_VAR 0 3
28107: PUSH
28108: LD_VAR 0 6
28112: PUSH
28113: FOR_IN
28114: IFFALSE 28185
// begin t := UnitsInside ( i ) ;
28116: LD_ADDR_VAR 0 4
28120: PUSH
28121: LD_VAR 0 3
28125: PPUSH
28126: CALL_OW 313
28130: ST_TO_ADDR
// if t then
28131: LD_VAR 0 4
28135: IFFALSE 28183
// for j in t do
28137: LD_ADDR_VAR 0 7
28141: PUSH
28142: LD_VAR 0 4
28146: PUSH
28147: FOR_IN
28148: IFFALSE 28181
// result := Replace ( result , result + 1 , j ) ;
28150: LD_ADDR_VAR 0 2
28154: PUSH
28155: LD_VAR 0 2
28159: PPUSH
28160: LD_VAR 0 2
28164: PUSH
28165: LD_INT 1
28167: PLUS
28168: PPUSH
28169: LD_VAR 0 7
28173: PPUSH
28174: CALL_OW 1
28178: ST_TO_ADDR
28179: GO 28147
28181: POP
28182: POP
// end ;
28183: GO 28113
28185: POP
28186: POP
// if not result then
28187: LD_VAR 0 2
28191: NOT
28192: IFFALSE 28196
// exit ;
28194: GO 28344
// mech := result [ 1 ] ;
28196: LD_ADDR_VAR 0 5
28200: PUSH
28201: LD_VAR 0 2
28205: PUSH
28206: LD_INT 1
28208: ARRAY
28209: ST_TO_ADDR
// if result > 1 then
28210: LD_VAR 0 2
28214: PUSH
28215: LD_INT 1
28217: GREATER
28218: IFFALSE 28330
// begin for i = 2 to result do
28220: LD_ADDR_VAR 0 3
28224: PUSH
28225: DOUBLE
28226: LD_INT 2
28228: DEC
28229: ST_TO_ADDR
28230: LD_VAR 0 2
28234: PUSH
28235: FOR_TO
28236: IFFALSE 28328
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28238: LD_ADDR_VAR 0 4
28242: PUSH
28243: LD_VAR 0 2
28247: PUSH
28248: LD_VAR 0 3
28252: ARRAY
28253: PPUSH
28254: LD_INT 3
28256: PPUSH
28257: CALL_OW 259
28261: PUSH
28262: LD_VAR 0 2
28266: PUSH
28267: LD_VAR 0 3
28271: ARRAY
28272: PPUSH
28273: CALL_OW 432
28277: MINUS
28278: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28279: LD_VAR 0 4
28283: PUSH
28284: LD_VAR 0 5
28288: PPUSH
28289: LD_INT 3
28291: PPUSH
28292: CALL_OW 259
28296: PUSH
28297: LD_VAR 0 5
28301: PPUSH
28302: CALL_OW 432
28306: MINUS
28307: GREATEREQUAL
28308: IFFALSE 28326
// mech := result [ i ] ;
28310: LD_ADDR_VAR 0 5
28314: PUSH
28315: LD_VAR 0 2
28319: PUSH
28320: LD_VAR 0 3
28324: ARRAY
28325: ST_TO_ADDR
// end ;
28326: GO 28235
28328: POP
28329: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28330: LD_VAR 0 1
28334: PPUSH
28335: LD_VAR 0 5
28339: PPUSH
28340: CALL_OW 135
// end ;
28344: LD_VAR 0 2
28348: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28349: LD_INT 0
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
28356: PPUSH
28357: PPUSH
28358: PPUSH
28359: PPUSH
28360: PPUSH
28361: PPUSH
28362: PPUSH
28363: PPUSH
// result := [ ] ;
28364: LD_ADDR_VAR 0 7
28368: PUSH
28369: EMPTY
28370: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28371: LD_VAR 0 1
28375: PPUSH
28376: CALL_OW 266
28380: PUSH
28381: LD_INT 0
28383: PUSH
28384: LD_INT 1
28386: PUSH
28387: EMPTY
28388: LIST
28389: LIST
28390: IN
28391: NOT
28392: IFFALSE 28396
// exit ;
28394: GO 30030
// if name then
28396: LD_VAR 0 3
28400: IFFALSE 28416
// SetBName ( base_dep , name ) ;
28402: LD_VAR 0 1
28406: PPUSH
28407: LD_VAR 0 3
28411: PPUSH
28412: CALL_OW 500
// base := GetBase ( base_dep ) ;
28416: LD_ADDR_VAR 0 15
28420: PUSH
28421: LD_VAR 0 1
28425: PPUSH
28426: CALL_OW 274
28430: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28431: LD_ADDR_VAR 0 16
28435: PUSH
28436: LD_VAR 0 1
28440: PPUSH
28441: CALL_OW 255
28445: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28446: LD_ADDR_VAR 0 17
28450: PUSH
28451: LD_VAR 0 1
28455: PPUSH
28456: CALL_OW 248
28460: ST_TO_ADDR
// if sources then
28461: LD_VAR 0 5
28465: IFFALSE 28512
// for i = 1 to 3 do
28467: LD_ADDR_VAR 0 8
28471: PUSH
28472: DOUBLE
28473: LD_INT 1
28475: DEC
28476: ST_TO_ADDR
28477: LD_INT 3
28479: PUSH
28480: FOR_TO
28481: IFFALSE 28510
// AddResourceType ( base , i , sources [ i ] ) ;
28483: LD_VAR 0 15
28487: PPUSH
28488: LD_VAR 0 8
28492: PPUSH
28493: LD_VAR 0 5
28497: PUSH
28498: LD_VAR 0 8
28502: ARRAY
28503: PPUSH
28504: CALL_OW 276
28508: GO 28480
28510: POP
28511: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28512: LD_ADDR_VAR 0 18
28516: PUSH
28517: LD_VAR 0 15
28521: PPUSH
28522: LD_VAR 0 2
28526: PPUSH
28527: LD_INT 1
28529: PPUSH
28530: CALL 27773 0 3
28534: ST_TO_ADDR
// InitHc ;
28535: CALL_OW 19
// InitUc ;
28539: CALL_OW 18
// uc_side := side ;
28543: LD_ADDR_OWVAR 20
28547: PUSH
28548: LD_VAR 0 16
28552: ST_TO_ADDR
// uc_nation := nation ;
28553: LD_ADDR_OWVAR 21
28557: PUSH
28558: LD_VAR 0 17
28562: ST_TO_ADDR
// if buildings then
28563: LD_VAR 0 18
28567: IFFALSE 29889
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28569: LD_ADDR_VAR 0 19
28573: PUSH
28574: LD_VAR 0 18
28578: PPUSH
28579: LD_INT 2
28581: PUSH
28582: LD_INT 30
28584: PUSH
28585: LD_INT 29
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 30
28594: PUSH
28595: LD_INT 30
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: LIST
28606: PPUSH
28607: CALL_OW 72
28611: ST_TO_ADDR
// if tmp then
28612: LD_VAR 0 19
28616: IFFALSE 28664
// for i in tmp do
28618: LD_ADDR_VAR 0 8
28622: PUSH
28623: LD_VAR 0 19
28627: PUSH
28628: FOR_IN
28629: IFFALSE 28662
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28631: LD_VAR 0 8
28635: PPUSH
28636: CALL_OW 250
28640: PPUSH
28641: LD_VAR 0 8
28645: PPUSH
28646: CALL_OW 251
28650: PPUSH
28651: LD_VAR 0 16
28655: PPUSH
28656: CALL_OW 441
28660: GO 28628
28662: POP
28663: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28664: LD_VAR 0 18
28668: PPUSH
28669: LD_INT 2
28671: PUSH
28672: LD_INT 30
28674: PUSH
28675: LD_INT 32
28677: PUSH
28678: EMPTY
28679: LIST
28680: LIST
28681: PUSH
28682: LD_INT 30
28684: PUSH
28685: LD_INT 33
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: PUSH
28692: EMPTY
28693: LIST
28694: LIST
28695: LIST
28696: PPUSH
28697: CALL_OW 72
28701: IFFALSE 28789
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28703: LD_ADDR_VAR 0 8
28707: PUSH
28708: LD_VAR 0 18
28712: PPUSH
28713: LD_INT 2
28715: PUSH
28716: LD_INT 30
28718: PUSH
28719: LD_INT 32
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: PUSH
28726: LD_INT 30
28728: PUSH
28729: LD_INT 33
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: LIST
28740: PPUSH
28741: CALL_OW 72
28745: PUSH
28746: FOR_IN
28747: IFFALSE 28787
// begin if not GetBWeapon ( i ) then
28749: LD_VAR 0 8
28753: PPUSH
28754: CALL_OW 269
28758: NOT
28759: IFFALSE 28785
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28761: LD_VAR 0 8
28765: PPUSH
28766: LD_VAR 0 8
28770: PPUSH
28771: LD_VAR 0 2
28775: PPUSH
28776: CALL 30035 0 2
28780: PPUSH
28781: CALL_OW 431
// end ;
28785: GO 28746
28787: POP
28788: POP
// end ; for i = 1 to personel do
28789: LD_ADDR_VAR 0 8
28793: PUSH
28794: DOUBLE
28795: LD_INT 1
28797: DEC
28798: ST_TO_ADDR
28799: LD_VAR 0 6
28803: PUSH
28804: FOR_TO
28805: IFFALSE 29869
// begin if i > 4 then
28807: LD_VAR 0 8
28811: PUSH
28812: LD_INT 4
28814: GREATER
28815: IFFALSE 28819
// break ;
28817: GO 29869
// case i of 1 :
28819: LD_VAR 0 8
28823: PUSH
28824: LD_INT 1
28826: DOUBLE
28827: EQUAL
28828: IFTRUE 28832
28830: GO 28912
28832: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28833: LD_ADDR_VAR 0 12
28837: PUSH
28838: LD_VAR 0 18
28842: PPUSH
28843: LD_INT 22
28845: PUSH
28846: LD_VAR 0 16
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 58
28857: PUSH
28858: EMPTY
28859: LIST
28860: PUSH
28861: LD_INT 2
28863: PUSH
28864: LD_INT 30
28866: PUSH
28867: LD_INT 32
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 30
28876: PUSH
28877: LD_INT 4
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 30
28886: PUSH
28887: LD_INT 5
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: LIST
28904: PPUSH
28905: CALL_OW 72
28909: ST_TO_ADDR
28910: GO 29134
28912: LD_INT 2
28914: DOUBLE
28915: EQUAL
28916: IFTRUE 28920
28918: GO 28982
28920: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28921: LD_ADDR_VAR 0 12
28925: PUSH
28926: LD_VAR 0 18
28930: PPUSH
28931: LD_INT 22
28933: PUSH
28934: LD_VAR 0 16
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: PUSH
28943: LD_INT 2
28945: PUSH
28946: LD_INT 30
28948: PUSH
28949: LD_INT 0
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: LD_INT 30
28958: PUSH
28959: LD_INT 1
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: LIST
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PPUSH
28975: CALL_OW 72
28979: ST_TO_ADDR
28980: GO 29134
28982: LD_INT 3
28984: DOUBLE
28985: EQUAL
28986: IFTRUE 28990
28988: GO 29052
28990: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28991: LD_ADDR_VAR 0 12
28995: PUSH
28996: LD_VAR 0 18
29000: PPUSH
29001: LD_INT 22
29003: PUSH
29004: LD_VAR 0 16
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: LD_INT 2
29015: PUSH
29016: LD_INT 30
29018: PUSH
29019: LD_INT 2
29021: PUSH
29022: EMPTY
29023: LIST
29024: LIST
29025: PUSH
29026: LD_INT 30
29028: PUSH
29029: LD_INT 3
29031: PUSH
29032: EMPTY
29033: LIST
29034: LIST
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: LIST
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PPUSH
29045: CALL_OW 72
29049: ST_TO_ADDR
29050: GO 29134
29052: LD_INT 4
29054: DOUBLE
29055: EQUAL
29056: IFTRUE 29060
29058: GO 29133
29060: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
29061: LD_ADDR_VAR 0 12
29065: PUSH
29066: LD_VAR 0 18
29070: PPUSH
29071: LD_INT 22
29073: PUSH
29074: LD_VAR 0 16
29078: PUSH
29079: EMPTY
29080: LIST
29081: LIST
29082: PUSH
29083: LD_INT 2
29085: PUSH
29086: LD_INT 30
29088: PUSH
29089: LD_INT 6
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 30
29098: PUSH
29099: LD_INT 7
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 30
29108: PUSH
29109: LD_INT 8
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: LIST
29120: LIST
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PPUSH
29126: CALL_OW 72
29130: ST_TO_ADDR
29131: GO 29134
29133: POP
// if i = 1 then
29134: LD_VAR 0 8
29138: PUSH
29139: LD_INT 1
29141: EQUAL
29142: IFFALSE 29253
// begin tmp := [ ] ;
29144: LD_ADDR_VAR 0 19
29148: PUSH
29149: EMPTY
29150: ST_TO_ADDR
// for j in f do
29151: LD_ADDR_VAR 0 9
29155: PUSH
29156: LD_VAR 0 12
29160: PUSH
29161: FOR_IN
29162: IFFALSE 29235
// if GetBType ( j ) = b_bunker then
29164: LD_VAR 0 9
29168: PPUSH
29169: CALL_OW 266
29173: PUSH
29174: LD_INT 32
29176: EQUAL
29177: IFFALSE 29204
// tmp := Insert ( tmp , 1 , j ) else
29179: LD_ADDR_VAR 0 19
29183: PUSH
29184: LD_VAR 0 19
29188: PPUSH
29189: LD_INT 1
29191: PPUSH
29192: LD_VAR 0 9
29196: PPUSH
29197: CALL_OW 2
29201: ST_TO_ADDR
29202: GO 29233
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29204: LD_ADDR_VAR 0 19
29208: PUSH
29209: LD_VAR 0 19
29213: PPUSH
29214: LD_VAR 0 19
29218: PUSH
29219: LD_INT 1
29221: PLUS
29222: PPUSH
29223: LD_VAR 0 9
29227: PPUSH
29228: CALL_OW 2
29232: ST_TO_ADDR
29233: GO 29161
29235: POP
29236: POP
// if tmp then
29237: LD_VAR 0 19
29241: IFFALSE 29253
// f := tmp ;
29243: LD_ADDR_VAR 0 12
29247: PUSH
29248: LD_VAR 0 19
29252: ST_TO_ADDR
// end ; x := personel [ i ] ;
29253: LD_ADDR_VAR 0 13
29257: PUSH
29258: LD_VAR 0 6
29262: PUSH
29263: LD_VAR 0 8
29267: ARRAY
29268: ST_TO_ADDR
// if x = - 1 then
29269: LD_VAR 0 13
29273: PUSH
29274: LD_INT 1
29276: NEG
29277: EQUAL
29278: IFFALSE 29487
// begin for j in f do
29280: LD_ADDR_VAR 0 9
29284: PUSH
29285: LD_VAR 0 12
29289: PUSH
29290: FOR_IN
29291: IFFALSE 29483
// repeat InitHc ;
29293: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29297: LD_VAR 0 9
29301: PPUSH
29302: CALL_OW 266
29306: PUSH
29307: LD_INT 5
29309: EQUAL
29310: IFFALSE 29380
// begin if UnitsInside ( j ) < 3 then
29312: LD_VAR 0 9
29316: PPUSH
29317: CALL_OW 313
29321: PUSH
29322: LD_INT 3
29324: LESS
29325: IFFALSE 29361
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29327: LD_INT 0
29329: PPUSH
29330: LD_INT 5
29332: PUSH
29333: LD_INT 8
29335: PUSH
29336: LD_INT 9
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: LIST
29343: PUSH
29344: LD_VAR 0 17
29348: ARRAY
29349: PPUSH
29350: LD_VAR 0 4
29354: PPUSH
29355: CALL_OW 380
29359: GO 29378
// PrepareHuman ( false , i , skill ) ;
29361: LD_INT 0
29363: PPUSH
29364: LD_VAR 0 8
29368: PPUSH
29369: LD_VAR 0 4
29373: PPUSH
29374: CALL_OW 380
// end else
29378: GO 29397
// PrepareHuman ( false , i , skill ) ;
29380: LD_INT 0
29382: PPUSH
29383: LD_VAR 0 8
29387: PPUSH
29388: LD_VAR 0 4
29392: PPUSH
29393: CALL_OW 380
// un := CreateHuman ;
29397: LD_ADDR_VAR 0 14
29401: PUSH
29402: CALL_OW 44
29406: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29407: LD_ADDR_VAR 0 7
29411: PUSH
29412: LD_VAR 0 7
29416: PPUSH
29417: LD_INT 1
29419: PPUSH
29420: LD_VAR 0 14
29424: PPUSH
29425: CALL_OW 2
29429: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29430: LD_VAR 0 14
29434: PPUSH
29435: LD_VAR 0 9
29439: PPUSH
29440: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29444: LD_VAR 0 9
29448: PPUSH
29449: CALL_OW 313
29453: PUSH
29454: LD_INT 6
29456: EQUAL
29457: PUSH
29458: LD_VAR 0 9
29462: PPUSH
29463: CALL_OW 266
29467: PUSH
29468: LD_INT 32
29470: PUSH
29471: LD_INT 31
29473: PUSH
29474: EMPTY
29475: LIST
29476: LIST
29477: IN
29478: OR
29479: IFFALSE 29293
29481: GO 29290
29483: POP
29484: POP
// end else
29485: GO 29867
// for j = 1 to x do
29487: LD_ADDR_VAR 0 9
29491: PUSH
29492: DOUBLE
29493: LD_INT 1
29495: DEC
29496: ST_TO_ADDR
29497: LD_VAR 0 13
29501: PUSH
29502: FOR_TO
29503: IFFALSE 29865
// begin InitHc ;
29505: CALL_OW 19
// if not f then
29509: LD_VAR 0 12
29513: NOT
29514: IFFALSE 29603
// begin PrepareHuman ( false , i , skill ) ;
29516: LD_INT 0
29518: PPUSH
29519: LD_VAR 0 8
29523: PPUSH
29524: LD_VAR 0 4
29528: PPUSH
29529: CALL_OW 380
// un := CreateHuman ;
29533: LD_ADDR_VAR 0 14
29537: PUSH
29538: CALL_OW 44
29542: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29543: LD_ADDR_VAR 0 7
29547: PUSH
29548: LD_VAR 0 7
29552: PPUSH
29553: LD_INT 1
29555: PPUSH
29556: LD_VAR 0 14
29560: PPUSH
29561: CALL_OW 2
29565: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29566: LD_VAR 0 14
29570: PPUSH
29571: LD_VAR 0 1
29575: PPUSH
29576: CALL_OW 250
29580: PPUSH
29581: LD_VAR 0 1
29585: PPUSH
29586: CALL_OW 251
29590: PPUSH
29591: LD_INT 10
29593: PPUSH
29594: LD_INT 0
29596: PPUSH
29597: CALL_OW 50
// continue ;
29601: GO 29502
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29603: LD_VAR 0 12
29607: PUSH
29608: LD_INT 1
29610: ARRAY
29611: PPUSH
29612: CALL_OW 313
29616: PUSH
29617: LD_VAR 0 12
29621: PUSH
29622: LD_INT 1
29624: ARRAY
29625: PPUSH
29626: CALL_OW 266
29630: PUSH
29631: LD_INT 32
29633: PUSH
29634: LD_INT 31
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: IN
29641: AND
29642: PUSH
29643: LD_VAR 0 12
29647: PUSH
29648: LD_INT 1
29650: ARRAY
29651: PPUSH
29652: CALL_OW 313
29656: PUSH
29657: LD_INT 6
29659: EQUAL
29660: OR
29661: IFFALSE 29681
// f := Delete ( f , 1 ) ;
29663: LD_ADDR_VAR 0 12
29667: PUSH
29668: LD_VAR 0 12
29672: PPUSH
29673: LD_INT 1
29675: PPUSH
29676: CALL_OW 3
29680: ST_TO_ADDR
// if not f then
29681: LD_VAR 0 12
29685: NOT
29686: IFFALSE 29704
// begin x := x + 2 ;
29688: LD_ADDR_VAR 0 13
29692: PUSH
29693: LD_VAR 0 13
29697: PUSH
29698: LD_INT 2
29700: PLUS
29701: ST_TO_ADDR
// continue ;
29702: GO 29502
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29704: LD_VAR 0 12
29708: PUSH
29709: LD_INT 1
29711: ARRAY
29712: PPUSH
29713: CALL_OW 266
29717: PUSH
29718: LD_INT 5
29720: EQUAL
29721: IFFALSE 29795
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29723: LD_VAR 0 12
29727: PUSH
29728: LD_INT 1
29730: ARRAY
29731: PPUSH
29732: CALL_OW 313
29736: PUSH
29737: LD_INT 3
29739: LESS
29740: IFFALSE 29776
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29742: LD_INT 0
29744: PPUSH
29745: LD_INT 5
29747: PUSH
29748: LD_INT 8
29750: PUSH
29751: LD_INT 9
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: LIST
29758: PUSH
29759: LD_VAR 0 17
29763: ARRAY
29764: PPUSH
29765: LD_VAR 0 4
29769: PPUSH
29770: CALL_OW 380
29774: GO 29793
// PrepareHuman ( false , i , skill ) ;
29776: LD_INT 0
29778: PPUSH
29779: LD_VAR 0 8
29783: PPUSH
29784: LD_VAR 0 4
29788: PPUSH
29789: CALL_OW 380
// end else
29793: GO 29812
// PrepareHuman ( false , i , skill ) ;
29795: LD_INT 0
29797: PPUSH
29798: LD_VAR 0 8
29802: PPUSH
29803: LD_VAR 0 4
29807: PPUSH
29808: CALL_OW 380
// un := CreateHuman ;
29812: LD_ADDR_VAR 0 14
29816: PUSH
29817: CALL_OW 44
29821: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29822: LD_ADDR_VAR 0 7
29826: PUSH
29827: LD_VAR 0 7
29831: PPUSH
29832: LD_INT 1
29834: PPUSH
29835: LD_VAR 0 14
29839: PPUSH
29840: CALL_OW 2
29844: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29845: LD_VAR 0 14
29849: PPUSH
29850: LD_VAR 0 12
29854: PUSH
29855: LD_INT 1
29857: ARRAY
29858: PPUSH
29859: CALL_OW 52
// end ;
29863: GO 29502
29865: POP
29866: POP
// end ;
29867: GO 28804
29869: POP
29870: POP
// result := result ^ buildings ;
29871: LD_ADDR_VAR 0 7
29875: PUSH
29876: LD_VAR 0 7
29880: PUSH
29881: LD_VAR 0 18
29885: ADD
29886: ST_TO_ADDR
// end else
29887: GO 30030
// begin for i = 1 to personel do
29889: LD_ADDR_VAR 0 8
29893: PUSH
29894: DOUBLE
29895: LD_INT 1
29897: DEC
29898: ST_TO_ADDR
29899: LD_VAR 0 6
29903: PUSH
29904: FOR_TO
29905: IFFALSE 30028
// begin if i > 4 then
29907: LD_VAR 0 8
29911: PUSH
29912: LD_INT 4
29914: GREATER
29915: IFFALSE 29919
// break ;
29917: GO 30028
// x := personel [ i ] ;
29919: LD_ADDR_VAR 0 13
29923: PUSH
29924: LD_VAR 0 6
29928: PUSH
29929: LD_VAR 0 8
29933: ARRAY
29934: ST_TO_ADDR
// if x = - 1 then
29935: LD_VAR 0 13
29939: PUSH
29940: LD_INT 1
29942: NEG
29943: EQUAL
29944: IFFALSE 29948
// continue ;
29946: GO 29904
// PrepareHuman ( false , i , skill ) ;
29948: LD_INT 0
29950: PPUSH
29951: LD_VAR 0 8
29955: PPUSH
29956: LD_VAR 0 4
29960: PPUSH
29961: CALL_OW 380
// un := CreateHuman ;
29965: LD_ADDR_VAR 0 14
29969: PUSH
29970: CALL_OW 44
29974: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29975: LD_VAR 0 14
29979: PPUSH
29980: LD_VAR 0 1
29984: PPUSH
29985: CALL_OW 250
29989: PPUSH
29990: LD_VAR 0 1
29994: PPUSH
29995: CALL_OW 251
29999: PPUSH
30000: LD_INT 10
30002: PPUSH
30003: LD_INT 0
30005: PPUSH
30006: CALL_OW 50
// result := result ^ un ;
30010: LD_ADDR_VAR 0 7
30014: PUSH
30015: LD_VAR 0 7
30019: PUSH
30020: LD_VAR 0 14
30024: ADD
30025: ST_TO_ADDR
// end ;
30026: GO 29904
30028: POP
30029: POP
// end ; end ;
30030: LD_VAR 0 7
30034: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
30035: LD_INT 0
30037: PPUSH
30038: PPUSH
30039: PPUSH
30040: PPUSH
30041: PPUSH
30042: PPUSH
30043: PPUSH
30044: PPUSH
30045: PPUSH
30046: PPUSH
30047: PPUSH
30048: PPUSH
30049: PPUSH
30050: PPUSH
30051: PPUSH
30052: PPUSH
// result := false ;
30053: LD_ADDR_VAR 0 3
30057: PUSH
30058: LD_INT 0
30060: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
30061: LD_VAR 0 1
30065: NOT
30066: PUSH
30067: LD_VAR 0 1
30071: PPUSH
30072: CALL_OW 266
30076: PUSH
30077: LD_INT 32
30079: PUSH
30080: LD_INT 33
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: IN
30087: NOT
30088: OR
30089: IFFALSE 30093
// exit ;
30091: GO 31202
// nat := GetNation ( tower ) ;
30093: LD_ADDR_VAR 0 12
30097: PUSH
30098: LD_VAR 0 1
30102: PPUSH
30103: CALL_OW 248
30107: ST_TO_ADDR
// side := GetSide ( tower ) ;
30108: LD_ADDR_VAR 0 16
30112: PUSH
30113: LD_VAR 0 1
30117: PPUSH
30118: CALL_OW 255
30122: ST_TO_ADDR
// x := GetX ( tower ) ;
30123: LD_ADDR_VAR 0 10
30127: PUSH
30128: LD_VAR 0 1
30132: PPUSH
30133: CALL_OW 250
30137: ST_TO_ADDR
// y := GetY ( tower ) ;
30138: LD_ADDR_VAR 0 11
30142: PUSH
30143: LD_VAR 0 1
30147: PPUSH
30148: CALL_OW 251
30152: ST_TO_ADDR
// if not x or not y then
30153: LD_VAR 0 10
30157: NOT
30158: PUSH
30159: LD_VAR 0 11
30163: NOT
30164: OR
30165: IFFALSE 30169
// exit ;
30167: GO 31202
// weapon := 0 ;
30169: LD_ADDR_VAR 0 18
30173: PUSH
30174: LD_INT 0
30176: ST_TO_ADDR
// fac_list := [ ] ;
30177: LD_ADDR_VAR 0 17
30181: PUSH
30182: EMPTY
30183: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30184: LD_ADDR_VAR 0 6
30188: PUSH
30189: LD_VAR 0 1
30193: PPUSH
30194: CALL_OW 274
30198: PPUSH
30199: LD_VAR 0 2
30203: PPUSH
30204: LD_INT 0
30206: PPUSH
30207: CALL 27773 0 3
30211: PPUSH
30212: LD_INT 30
30214: PUSH
30215: LD_INT 3
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: PPUSH
30222: CALL_OW 72
30226: ST_TO_ADDR
// if not factories then
30227: LD_VAR 0 6
30231: NOT
30232: IFFALSE 30236
// exit ;
30234: GO 31202
// for i in factories do
30236: LD_ADDR_VAR 0 8
30240: PUSH
30241: LD_VAR 0 6
30245: PUSH
30246: FOR_IN
30247: IFFALSE 30272
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30249: LD_ADDR_VAR 0 17
30253: PUSH
30254: LD_VAR 0 17
30258: PUSH
30259: LD_VAR 0 8
30263: PPUSH
30264: CALL_OW 478
30268: UNION
30269: ST_TO_ADDR
30270: GO 30246
30272: POP
30273: POP
// if not fac_list then
30274: LD_VAR 0 17
30278: NOT
30279: IFFALSE 30283
// exit ;
30281: GO 31202
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30283: LD_ADDR_VAR 0 5
30287: PUSH
30288: LD_INT 4
30290: PUSH
30291: LD_INT 5
30293: PUSH
30294: LD_INT 9
30296: PUSH
30297: LD_INT 10
30299: PUSH
30300: LD_INT 6
30302: PUSH
30303: LD_INT 7
30305: PUSH
30306: LD_INT 11
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: LIST
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 27
30320: PUSH
30321: LD_INT 28
30323: PUSH
30324: LD_INT 26
30326: PUSH
30327: LD_INT 30
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: PUSH
30336: LD_INT 43
30338: PUSH
30339: LD_INT 44
30341: PUSH
30342: LD_INT 46
30344: PUSH
30345: LD_INT 45
30347: PUSH
30348: LD_INT 47
30350: PUSH
30351: LD_INT 49
30353: PUSH
30354: EMPTY
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: LIST
30366: PUSH
30367: LD_VAR 0 12
30371: ARRAY
30372: ST_TO_ADDR
// list := list isect fac_list ;
30373: LD_ADDR_VAR 0 5
30377: PUSH
30378: LD_VAR 0 5
30382: PUSH
30383: LD_VAR 0 17
30387: ISECT
30388: ST_TO_ADDR
// if not list then
30389: LD_VAR 0 5
30393: NOT
30394: IFFALSE 30398
// exit ;
30396: GO 31202
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30398: LD_VAR 0 12
30402: PUSH
30403: LD_INT 3
30405: EQUAL
30406: PUSH
30407: LD_INT 49
30409: PUSH
30410: LD_VAR 0 5
30414: IN
30415: AND
30416: PUSH
30417: LD_INT 31
30419: PPUSH
30420: LD_VAR 0 16
30424: PPUSH
30425: CALL_OW 321
30429: PUSH
30430: LD_INT 2
30432: EQUAL
30433: AND
30434: IFFALSE 30494
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30436: LD_INT 22
30438: PUSH
30439: LD_VAR 0 16
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 35
30450: PUSH
30451: LD_INT 49
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 91
30460: PUSH
30461: LD_VAR 0 1
30465: PUSH
30466: LD_INT 10
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: LIST
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: LIST
30478: PPUSH
30479: CALL_OW 69
30483: NOT
30484: IFFALSE 30494
// weapon := ru_time_lapser ;
30486: LD_ADDR_VAR 0 18
30490: PUSH
30491: LD_INT 49
30493: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30494: LD_VAR 0 12
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: LD_INT 2
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: IN
30509: PUSH
30510: LD_INT 11
30512: PUSH
30513: LD_VAR 0 5
30517: IN
30518: PUSH
30519: LD_INT 30
30521: PUSH
30522: LD_VAR 0 5
30526: IN
30527: OR
30528: AND
30529: PUSH
30530: LD_INT 6
30532: PPUSH
30533: LD_VAR 0 16
30537: PPUSH
30538: CALL_OW 321
30542: PUSH
30543: LD_INT 2
30545: EQUAL
30546: AND
30547: IFFALSE 30712
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30549: LD_INT 22
30551: PUSH
30552: LD_VAR 0 16
30556: PUSH
30557: EMPTY
30558: LIST
30559: LIST
30560: PUSH
30561: LD_INT 2
30563: PUSH
30564: LD_INT 35
30566: PUSH
30567: LD_INT 11
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 35
30576: PUSH
30577: LD_INT 30
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 91
30591: PUSH
30592: LD_VAR 0 1
30596: PUSH
30597: LD_INT 18
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: LIST
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: LIST
30609: PPUSH
30610: CALL_OW 69
30614: NOT
30615: PUSH
30616: LD_INT 22
30618: PUSH
30619: LD_VAR 0 16
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 2
30630: PUSH
30631: LD_INT 30
30633: PUSH
30634: LD_INT 32
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: LD_INT 30
30643: PUSH
30644: LD_INT 33
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: EMPTY
30652: LIST
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 91
30658: PUSH
30659: LD_VAR 0 1
30663: PUSH
30664: LD_INT 12
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: LIST
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: LIST
30676: PUSH
30677: EMPTY
30678: LIST
30679: PPUSH
30680: CALL_OW 69
30684: PUSH
30685: LD_INT 2
30687: GREATER
30688: AND
30689: IFFALSE 30712
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30691: LD_ADDR_VAR 0 18
30695: PUSH
30696: LD_INT 11
30698: PUSH
30699: LD_INT 30
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_VAR 0 12
30710: ARRAY
30711: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30712: LD_VAR 0 18
30716: NOT
30717: PUSH
30718: LD_INT 40
30720: PPUSH
30721: LD_VAR 0 16
30725: PPUSH
30726: CALL_OW 321
30730: PUSH
30731: LD_INT 2
30733: EQUAL
30734: AND
30735: PUSH
30736: LD_INT 7
30738: PUSH
30739: LD_VAR 0 5
30743: IN
30744: PUSH
30745: LD_INT 28
30747: PUSH
30748: LD_VAR 0 5
30752: IN
30753: OR
30754: PUSH
30755: LD_INT 45
30757: PUSH
30758: LD_VAR 0 5
30762: IN
30763: OR
30764: AND
30765: IFFALSE 31019
// begin hex := GetHexInfo ( x , y ) ;
30767: LD_ADDR_VAR 0 4
30771: PUSH
30772: LD_VAR 0 10
30776: PPUSH
30777: LD_VAR 0 11
30781: PPUSH
30782: CALL_OW 546
30786: ST_TO_ADDR
// if hex [ 1 ] then
30787: LD_VAR 0 4
30791: PUSH
30792: LD_INT 1
30794: ARRAY
30795: IFFALSE 30799
// exit ;
30797: GO 31202
// height := hex [ 2 ] ;
30799: LD_ADDR_VAR 0 15
30803: PUSH
30804: LD_VAR 0 4
30808: PUSH
30809: LD_INT 2
30811: ARRAY
30812: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30813: LD_ADDR_VAR 0 14
30817: PUSH
30818: LD_INT 0
30820: PUSH
30821: LD_INT 2
30823: PUSH
30824: LD_INT 3
30826: PUSH
30827: LD_INT 5
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: ST_TO_ADDR
// for i in tmp do
30836: LD_ADDR_VAR 0 8
30840: PUSH
30841: LD_VAR 0 14
30845: PUSH
30846: FOR_IN
30847: IFFALSE 31017
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30849: LD_ADDR_VAR 0 9
30853: PUSH
30854: LD_VAR 0 10
30858: PPUSH
30859: LD_VAR 0 8
30863: PPUSH
30864: LD_INT 5
30866: PPUSH
30867: CALL_OW 272
30871: PUSH
30872: LD_VAR 0 11
30876: PPUSH
30877: LD_VAR 0 8
30881: PPUSH
30882: LD_INT 5
30884: PPUSH
30885: CALL_OW 273
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30894: LD_VAR 0 9
30898: PUSH
30899: LD_INT 1
30901: ARRAY
30902: PPUSH
30903: LD_VAR 0 9
30907: PUSH
30908: LD_INT 2
30910: ARRAY
30911: PPUSH
30912: CALL_OW 488
30916: IFFALSE 31015
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30918: LD_ADDR_VAR 0 4
30922: PUSH
30923: LD_VAR 0 9
30927: PUSH
30928: LD_INT 1
30930: ARRAY
30931: PPUSH
30932: LD_VAR 0 9
30936: PUSH
30937: LD_INT 2
30939: ARRAY
30940: PPUSH
30941: CALL_OW 546
30945: ST_TO_ADDR
// if hex [ 1 ] then
30946: LD_VAR 0 4
30950: PUSH
30951: LD_INT 1
30953: ARRAY
30954: IFFALSE 30958
// continue ;
30956: GO 30846
// h := hex [ 2 ] ;
30958: LD_ADDR_VAR 0 13
30962: PUSH
30963: LD_VAR 0 4
30967: PUSH
30968: LD_INT 2
30970: ARRAY
30971: ST_TO_ADDR
// if h + 7 < height then
30972: LD_VAR 0 13
30976: PUSH
30977: LD_INT 7
30979: PLUS
30980: PUSH
30981: LD_VAR 0 15
30985: LESS
30986: IFFALSE 31015
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30988: LD_ADDR_VAR 0 18
30992: PUSH
30993: LD_INT 7
30995: PUSH
30996: LD_INT 28
30998: PUSH
30999: LD_INT 45
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: LIST
31006: PUSH
31007: LD_VAR 0 12
31011: ARRAY
31012: ST_TO_ADDR
// break ;
31013: GO 31017
// end ; end ; end ;
31015: GO 30846
31017: POP
31018: POP
// end ; if not weapon then
31019: LD_VAR 0 18
31023: NOT
31024: IFFALSE 31084
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
31026: LD_ADDR_VAR 0 5
31030: PUSH
31031: LD_VAR 0 5
31035: PUSH
31036: LD_INT 11
31038: PUSH
31039: LD_INT 30
31041: PUSH
31042: LD_INT 49
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: LIST
31049: DIFF
31050: ST_TO_ADDR
// if not list then
31051: LD_VAR 0 5
31055: NOT
31056: IFFALSE 31060
// exit ;
31058: GO 31202
// weapon := list [ rand ( 1 , list ) ] ;
31060: LD_ADDR_VAR 0 18
31064: PUSH
31065: LD_VAR 0 5
31069: PUSH
31070: LD_INT 1
31072: PPUSH
31073: LD_VAR 0 5
31077: PPUSH
31078: CALL_OW 12
31082: ARRAY
31083: ST_TO_ADDR
// end ; if weapon then
31084: LD_VAR 0 18
31088: IFFALSE 31202
// begin tmp := CostOfWeapon ( weapon ) ;
31090: LD_ADDR_VAR 0 14
31094: PUSH
31095: LD_VAR 0 18
31099: PPUSH
31100: CALL_OW 451
31104: ST_TO_ADDR
// j := GetBase ( tower ) ;
31105: LD_ADDR_VAR 0 9
31109: PUSH
31110: LD_VAR 0 1
31114: PPUSH
31115: CALL_OW 274
31119: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
31120: LD_VAR 0 9
31124: PPUSH
31125: LD_INT 1
31127: PPUSH
31128: CALL_OW 275
31132: PUSH
31133: LD_VAR 0 14
31137: PUSH
31138: LD_INT 1
31140: ARRAY
31141: GREATEREQUAL
31142: PUSH
31143: LD_VAR 0 9
31147: PPUSH
31148: LD_INT 2
31150: PPUSH
31151: CALL_OW 275
31155: PUSH
31156: LD_VAR 0 14
31160: PUSH
31161: LD_INT 2
31163: ARRAY
31164: GREATEREQUAL
31165: AND
31166: PUSH
31167: LD_VAR 0 9
31171: PPUSH
31172: LD_INT 3
31174: PPUSH
31175: CALL_OW 275
31179: PUSH
31180: LD_VAR 0 14
31184: PUSH
31185: LD_INT 3
31187: ARRAY
31188: GREATEREQUAL
31189: AND
31190: IFFALSE 31202
// result := weapon ;
31192: LD_ADDR_VAR 0 3
31196: PUSH
31197: LD_VAR 0 18
31201: ST_TO_ADDR
// end ; end ;
31202: LD_VAR 0 3
31206: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31207: LD_INT 0
31209: PPUSH
31210: PPUSH
// result := true ;
31211: LD_ADDR_VAR 0 3
31215: PUSH
31216: LD_INT 1
31218: ST_TO_ADDR
// if array1 = array2 then
31219: LD_VAR 0 1
31223: PUSH
31224: LD_VAR 0 2
31228: EQUAL
31229: IFFALSE 31289
// begin for i = 1 to array1 do
31231: LD_ADDR_VAR 0 4
31235: PUSH
31236: DOUBLE
31237: LD_INT 1
31239: DEC
31240: ST_TO_ADDR
31241: LD_VAR 0 1
31245: PUSH
31246: FOR_TO
31247: IFFALSE 31285
// if array1 [ i ] <> array2 [ i ] then
31249: LD_VAR 0 1
31253: PUSH
31254: LD_VAR 0 4
31258: ARRAY
31259: PUSH
31260: LD_VAR 0 2
31264: PUSH
31265: LD_VAR 0 4
31269: ARRAY
31270: NONEQUAL
31271: IFFALSE 31283
// begin result := false ;
31273: LD_ADDR_VAR 0 3
31277: PUSH
31278: LD_INT 0
31280: ST_TO_ADDR
// break ;
31281: GO 31285
// end ;
31283: GO 31246
31285: POP
31286: POP
// end else
31287: GO 31297
// result := false ;
31289: LD_ADDR_VAR 0 3
31293: PUSH
31294: LD_INT 0
31296: ST_TO_ADDR
// end ;
31297: LD_VAR 0 3
31301: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31302: LD_INT 0
31304: PPUSH
31305: PPUSH
// if not array1 or not array2 then
31306: LD_VAR 0 1
31310: NOT
31311: PUSH
31312: LD_VAR 0 2
31316: NOT
31317: OR
31318: IFFALSE 31322
// exit ;
31320: GO 31386
// result := true ;
31322: LD_ADDR_VAR 0 3
31326: PUSH
31327: LD_INT 1
31329: ST_TO_ADDR
// for i = 1 to array1 do
31330: LD_ADDR_VAR 0 4
31334: PUSH
31335: DOUBLE
31336: LD_INT 1
31338: DEC
31339: ST_TO_ADDR
31340: LD_VAR 0 1
31344: PUSH
31345: FOR_TO
31346: IFFALSE 31384
// if array1 [ i ] <> array2 [ i ] then
31348: LD_VAR 0 1
31352: PUSH
31353: LD_VAR 0 4
31357: ARRAY
31358: PUSH
31359: LD_VAR 0 2
31363: PUSH
31364: LD_VAR 0 4
31368: ARRAY
31369: NONEQUAL
31370: IFFALSE 31382
// begin result := false ;
31372: LD_ADDR_VAR 0 3
31376: PUSH
31377: LD_INT 0
31379: ST_TO_ADDR
// break ;
31380: GO 31384
// end ;
31382: GO 31345
31384: POP
31385: POP
// end ;
31386: LD_VAR 0 3
31390: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31391: LD_INT 0
31393: PPUSH
31394: PPUSH
31395: PPUSH
// pom := GetBase ( fac ) ;
31396: LD_ADDR_VAR 0 5
31400: PUSH
31401: LD_VAR 0 1
31405: PPUSH
31406: CALL_OW 274
31410: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31411: LD_ADDR_VAR 0 4
31415: PUSH
31416: LD_VAR 0 2
31420: PUSH
31421: LD_INT 1
31423: ARRAY
31424: PPUSH
31425: LD_VAR 0 2
31429: PUSH
31430: LD_INT 2
31432: ARRAY
31433: PPUSH
31434: LD_VAR 0 2
31438: PUSH
31439: LD_INT 3
31441: ARRAY
31442: PPUSH
31443: LD_VAR 0 2
31447: PUSH
31448: LD_INT 4
31450: ARRAY
31451: PPUSH
31452: CALL_OW 449
31456: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31457: LD_ADDR_VAR 0 3
31461: PUSH
31462: LD_VAR 0 5
31466: PPUSH
31467: LD_INT 1
31469: PPUSH
31470: CALL_OW 275
31474: PUSH
31475: LD_VAR 0 4
31479: PUSH
31480: LD_INT 1
31482: ARRAY
31483: GREATEREQUAL
31484: PUSH
31485: LD_VAR 0 5
31489: PPUSH
31490: LD_INT 2
31492: PPUSH
31493: CALL_OW 275
31497: PUSH
31498: LD_VAR 0 4
31502: PUSH
31503: LD_INT 2
31505: ARRAY
31506: GREATEREQUAL
31507: AND
31508: PUSH
31509: LD_VAR 0 5
31513: PPUSH
31514: LD_INT 3
31516: PPUSH
31517: CALL_OW 275
31521: PUSH
31522: LD_VAR 0 4
31526: PUSH
31527: LD_INT 3
31529: ARRAY
31530: GREATEREQUAL
31531: AND
31532: ST_TO_ADDR
// end ;
31533: LD_VAR 0 3
31537: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31538: LD_INT 0
31540: PPUSH
31541: PPUSH
31542: PPUSH
31543: PPUSH
// pom := GetBase ( building ) ;
31544: LD_ADDR_VAR 0 3
31548: PUSH
31549: LD_VAR 0 1
31553: PPUSH
31554: CALL_OW 274
31558: ST_TO_ADDR
// if not pom then
31559: LD_VAR 0 3
31563: NOT
31564: IFFALSE 31568
// exit ;
31566: GO 31738
// btype := GetBType ( building ) ;
31568: LD_ADDR_VAR 0 5
31572: PUSH
31573: LD_VAR 0 1
31577: PPUSH
31578: CALL_OW 266
31582: ST_TO_ADDR
// if btype = b_armoury then
31583: LD_VAR 0 5
31587: PUSH
31588: LD_INT 4
31590: EQUAL
31591: IFFALSE 31601
// btype := b_barracks ;
31593: LD_ADDR_VAR 0 5
31597: PUSH
31598: LD_INT 5
31600: ST_TO_ADDR
// if btype = b_depot then
31601: LD_VAR 0 5
31605: PUSH
31606: LD_INT 0
31608: EQUAL
31609: IFFALSE 31619
// btype := b_warehouse ;
31611: LD_ADDR_VAR 0 5
31615: PUSH
31616: LD_INT 1
31618: ST_TO_ADDR
// if btype = b_workshop then
31619: LD_VAR 0 5
31623: PUSH
31624: LD_INT 2
31626: EQUAL
31627: IFFALSE 31637
// btype := b_factory ;
31629: LD_ADDR_VAR 0 5
31633: PUSH
31634: LD_INT 3
31636: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31637: LD_ADDR_VAR 0 4
31641: PUSH
31642: LD_VAR 0 5
31646: PPUSH
31647: LD_VAR 0 1
31651: PPUSH
31652: CALL_OW 248
31656: PPUSH
31657: CALL_OW 450
31661: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31662: LD_ADDR_VAR 0 2
31666: PUSH
31667: LD_VAR 0 3
31671: PPUSH
31672: LD_INT 1
31674: PPUSH
31675: CALL_OW 275
31679: PUSH
31680: LD_VAR 0 4
31684: PUSH
31685: LD_INT 1
31687: ARRAY
31688: GREATEREQUAL
31689: PUSH
31690: LD_VAR 0 3
31694: PPUSH
31695: LD_INT 2
31697: PPUSH
31698: CALL_OW 275
31702: PUSH
31703: LD_VAR 0 4
31707: PUSH
31708: LD_INT 2
31710: ARRAY
31711: GREATEREQUAL
31712: AND
31713: PUSH
31714: LD_VAR 0 3
31718: PPUSH
31719: LD_INT 3
31721: PPUSH
31722: CALL_OW 275
31726: PUSH
31727: LD_VAR 0 4
31731: PUSH
31732: LD_INT 3
31734: ARRAY
31735: GREATEREQUAL
31736: AND
31737: ST_TO_ADDR
// end ;
31738: LD_VAR 0 2
31742: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31743: LD_INT 0
31745: PPUSH
31746: PPUSH
31747: PPUSH
// pom := GetBase ( building ) ;
31748: LD_ADDR_VAR 0 4
31752: PUSH
31753: LD_VAR 0 1
31757: PPUSH
31758: CALL_OW 274
31762: ST_TO_ADDR
// if not pom then
31763: LD_VAR 0 4
31767: NOT
31768: IFFALSE 31772
// exit ;
31770: GO 31873
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31772: LD_ADDR_VAR 0 5
31776: PUSH
31777: LD_VAR 0 2
31781: PPUSH
31782: LD_VAR 0 1
31786: PPUSH
31787: CALL_OW 248
31791: PPUSH
31792: CALL_OW 450
31796: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31797: LD_ADDR_VAR 0 3
31801: PUSH
31802: LD_VAR 0 4
31806: PPUSH
31807: LD_INT 1
31809: PPUSH
31810: CALL_OW 275
31814: PUSH
31815: LD_VAR 0 5
31819: PUSH
31820: LD_INT 1
31822: ARRAY
31823: GREATEREQUAL
31824: PUSH
31825: LD_VAR 0 4
31829: PPUSH
31830: LD_INT 2
31832: PPUSH
31833: CALL_OW 275
31837: PUSH
31838: LD_VAR 0 5
31842: PUSH
31843: LD_INT 2
31845: ARRAY
31846: GREATEREQUAL
31847: AND
31848: PUSH
31849: LD_VAR 0 4
31853: PPUSH
31854: LD_INT 3
31856: PPUSH
31857: CALL_OW 275
31861: PUSH
31862: LD_VAR 0 5
31866: PUSH
31867: LD_INT 3
31869: ARRAY
31870: GREATEREQUAL
31871: AND
31872: ST_TO_ADDR
// end ;
31873: LD_VAR 0 3
31877: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31878: LD_INT 0
31880: PPUSH
31881: PPUSH
31882: PPUSH
31883: PPUSH
31884: PPUSH
31885: PPUSH
31886: PPUSH
31887: PPUSH
31888: PPUSH
31889: PPUSH
31890: PPUSH
// result := false ;
31891: LD_ADDR_VAR 0 8
31895: PUSH
31896: LD_INT 0
31898: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31899: LD_VAR 0 5
31903: NOT
31904: PUSH
31905: LD_VAR 0 1
31909: NOT
31910: OR
31911: PUSH
31912: LD_VAR 0 2
31916: NOT
31917: OR
31918: PUSH
31919: LD_VAR 0 3
31923: NOT
31924: OR
31925: IFFALSE 31929
// exit ;
31927: GO 32743
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31929: LD_ADDR_VAR 0 14
31933: PUSH
31934: LD_VAR 0 1
31938: PPUSH
31939: LD_VAR 0 2
31943: PPUSH
31944: LD_VAR 0 3
31948: PPUSH
31949: LD_VAR 0 4
31953: PPUSH
31954: LD_VAR 0 5
31958: PUSH
31959: LD_INT 1
31961: ARRAY
31962: PPUSH
31963: CALL_OW 248
31967: PPUSH
31968: LD_INT 0
31970: PPUSH
31971: CALL 33980 0 6
31975: ST_TO_ADDR
// if not hexes then
31976: LD_VAR 0 14
31980: NOT
31981: IFFALSE 31985
// exit ;
31983: GO 32743
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31985: LD_ADDR_VAR 0 17
31989: PUSH
31990: LD_VAR 0 5
31994: PPUSH
31995: LD_INT 22
31997: PUSH
31998: LD_VAR 0 13
32002: PPUSH
32003: CALL_OW 255
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 2
32014: PUSH
32015: LD_INT 30
32017: PUSH
32018: LD_INT 0
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 30
32027: PUSH
32028: LD_INT 1
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: EMPTY
32036: LIST
32037: LIST
32038: LIST
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PPUSH
32044: CALL_OW 72
32048: ST_TO_ADDR
// for i = 1 to hexes do
32049: LD_ADDR_VAR 0 9
32053: PUSH
32054: DOUBLE
32055: LD_INT 1
32057: DEC
32058: ST_TO_ADDR
32059: LD_VAR 0 14
32063: PUSH
32064: FOR_TO
32065: IFFALSE 32741
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32067: LD_ADDR_VAR 0 13
32071: PUSH
32072: LD_VAR 0 14
32076: PUSH
32077: LD_VAR 0 9
32081: ARRAY
32082: PUSH
32083: LD_INT 1
32085: ARRAY
32086: PPUSH
32087: LD_VAR 0 14
32091: PUSH
32092: LD_VAR 0 9
32096: ARRAY
32097: PUSH
32098: LD_INT 2
32100: ARRAY
32101: PPUSH
32102: CALL_OW 428
32106: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
32107: LD_VAR 0 14
32111: PUSH
32112: LD_VAR 0 9
32116: ARRAY
32117: PUSH
32118: LD_INT 1
32120: ARRAY
32121: PPUSH
32122: LD_VAR 0 14
32126: PUSH
32127: LD_VAR 0 9
32131: ARRAY
32132: PUSH
32133: LD_INT 2
32135: ARRAY
32136: PPUSH
32137: CALL_OW 351
32141: PUSH
32142: LD_VAR 0 14
32146: PUSH
32147: LD_VAR 0 9
32151: ARRAY
32152: PUSH
32153: LD_INT 1
32155: ARRAY
32156: PPUSH
32157: LD_VAR 0 14
32161: PUSH
32162: LD_VAR 0 9
32166: ARRAY
32167: PUSH
32168: LD_INT 2
32170: ARRAY
32171: PPUSH
32172: CALL_OW 488
32176: NOT
32177: OR
32178: PUSH
32179: LD_VAR 0 13
32183: PPUSH
32184: CALL_OW 247
32188: PUSH
32189: LD_INT 3
32191: EQUAL
32192: OR
32193: IFFALSE 32199
// exit ;
32195: POP
32196: POP
32197: GO 32743
// if not tmp then
32199: LD_VAR 0 13
32203: NOT
32204: IFFALSE 32208
// continue ;
32206: GO 32064
// result := true ;
32208: LD_ADDR_VAR 0 8
32212: PUSH
32213: LD_INT 1
32215: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32216: LD_VAR 0 6
32220: PUSH
32221: LD_VAR 0 13
32225: PPUSH
32226: CALL_OW 247
32230: PUSH
32231: LD_INT 2
32233: EQUAL
32234: AND
32235: PUSH
32236: LD_VAR 0 13
32240: PPUSH
32241: CALL_OW 263
32245: PUSH
32246: LD_INT 1
32248: EQUAL
32249: AND
32250: IFFALSE 32414
// begin if IsDrivenBy ( tmp ) then
32252: LD_VAR 0 13
32256: PPUSH
32257: CALL_OW 311
32261: IFFALSE 32265
// continue ;
32263: GO 32064
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32265: LD_VAR 0 6
32269: PPUSH
32270: LD_INT 3
32272: PUSH
32273: LD_INT 60
32275: PUSH
32276: EMPTY
32277: LIST
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 3
32285: PUSH
32286: LD_INT 55
32288: PUSH
32289: EMPTY
32290: LIST
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PPUSH
32300: CALL_OW 72
32304: IFFALSE 32412
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32306: LD_ADDR_VAR 0 18
32310: PUSH
32311: LD_VAR 0 6
32315: PPUSH
32316: LD_INT 3
32318: PUSH
32319: LD_INT 60
32321: PUSH
32322: EMPTY
32323: LIST
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 3
32331: PUSH
32332: LD_INT 55
32334: PUSH
32335: EMPTY
32336: LIST
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PPUSH
32346: CALL_OW 72
32350: PUSH
32351: LD_INT 1
32353: ARRAY
32354: ST_TO_ADDR
// if IsInUnit ( driver ) then
32355: LD_VAR 0 18
32359: PPUSH
32360: CALL_OW 310
32364: IFFALSE 32375
// ComExit ( driver ) ;
32366: LD_VAR 0 18
32370: PPUSH
32371: CALL 57685 0 1
// AddComEnterUnit ( driver , tmp ) ;
32375: LD_VAR 0 18
32379: PPUSH
32380: LD_VAR 0 13
32384: PPUSH
32385: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32389: LD_VAR 0 18
32393: PPUSH
32394: LD_VAR 0 7
32398: PPUSH
32399: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32403: LD_VAR 0 18
32407: PPUSH
32408: CALL_OW 181
// end ; continue ;
32412: GO 32064
// end ; if not cleaners or not tmp in cleaners then
32414: LD_VAR 0 6
32418: NOT
32419: PUSH
32420: LD_VAR 0 13
32424: PUSH
32425: LD_VAR 0 6
32429: IN
32430: NOT
32431: OR
32432: IFFALSE 32739
// begin if dep then
32434: LD_VAR 0 17
32438: IFFALSE 32574
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32440: LD_ADDR_VAR 0 16
32444: PUSH
32445: LD_VAR 0 17
32449: PUSH
32450: LD_INT 1
32452: ARRAY
32453: PPUSH
32454: CALL_OW 250
32458: PPUSH
32459: LD_VAR 0 17
32463: PUSH
32464: LD_INT 1
32466: ARRAY
32467: PPUSH
32468: CALL_OW 254
32472: PPUSH
32473: LD_INT 5
32475: PPUSH
32476: CALL_OW 272
32480: PUSH
32481: LD_VAR 0 17
32485: PUSH
32486: LD_INT 1
32488: ARRAY
32489: PPUSH
32490: CALL_OW 251
32494: PPUSH
32495: LD_VAR 0 17
32499: PUSH
32500: LD_INT 1
32502: ARRAY
32503: PPUSH
32504: CALL_OW 254
32508: PPUSH
32509: LD_INT 5
32511: PPUSH
32512: CALL_OW 273
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32521: LD_VAR 0 16
32525: PUSH
32526: LD_INT 1
32528: ARRAY
32529: PPUSH
32530: LD_VAR 0 16
32534: PUSH
32535: LD_INT 2
32537: ARRAY
32538: PPUSH
32539: CALL_OW 488
32543: IFFALSE 32574
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32545: LD_VAR 0 13
32549: PPUSH
32550: LD_VAR 0 16
32554: PUSH
32555: LD_INT 1
32557: ARRAY
32558: PPUSH
32559: LD_VAR 0 16
32563: PUSH
32564: LD_INT 2
32566: ARRAY
32567: PPUSH
32568: CALL_OW 111
// continue ;
32572: GO 32064
// end ; end ; r := GetDir ( tmp ) ;
32574: LD_ADDR_VAR 0 15
32578: PUSH
32579: LD_VAR 0 13
32583: PPUSH
32584: CALL_OW 254
32588: ST_TO_ADDR
// if r = 5 then
32589: LD_VAR 0 15
32593: PUSH
32594: LD_INT 5
32596: EQUAL
32597: IFFALSE 32607
// r := 0 ;
32599: LD_ADDR_VAR 0 15
32603: PUSH
32604: LD_INT 0
32606: ST_TO_ADDR
// for j = r to 5 do
32607: LD_ADDR_VAR 0 10
32611: PUSH
32612: DOUBLE
32613: LD_VAR 0 15
32617: DEC
32618: ST_TO_ADDR
32619: LD_INT 5
32621: PUSH
32622: FOR_TO
32623: IFFALSE 32737
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32625: LD_ADDR_VAR 0 11
32629: PUSH
32630: LD_VAR 0 13
32634: PPUSH
32635: CALL_OW 250
32639: PPUSH
32640: LD_VAR 0 10
32644: PPUSH
32645: LD_INT 2
32647: PPUSH
32648: CALL_OW 272
32652: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32653: LD_ADDR_VAR 0 12
32657: PUSH
32658: LD_VAR 0 13
32662: PPUSH
32663: CALL_OW 251
32667: PPUSH
32668: LD_VAR 0 10
32672: PPUSH
32673: LD_INT 2
32675: PPUSH
32676: CALL_OW 273
32680: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32681: LD_VAR 0 11
32685: PPUSH
32686: LD_VAR 0 12
32690: PPUSH
32691: CALL_OW 488
32695: PUSH
32696: LD_VAR 0 11
32700: PPUSH
32701: LD_VAR 0 12
32705: PPUSH
32706: CALL_OW 428
32710: NOT
32711: AND
32712: IFFALSE 32735
// begin ComMoveXY ( tmp , _x , _y ) ;
32714: LD_VAR 0 13
32718: PPUSH
32719: LD_VAR 0 11
32723: PPUSH
32724: LD_VAR 0 12
32728: PPUSH
32729: CALL_OW 111
// break ;
32733: GO 32737
// end ; end ;
32735: GO 32622
32737: POP
32738: POP
// end ; end ;
32739: GO 32064
32741: POP
32742: POP
// end ;
32743: LD_VAR 0 8
32747: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32748: LD_INT 0
32750: PPUSH
// result := true ;
32751: LD_ADDR_VAR 0 3
32755: PUSH
32756: LD_INT 1
32758: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32759: LD_VAR 0 2
32763: PUSH
32764: LD_INT 24
32766: DOUBLE
32767: EQUAL
32768: IFTRUE 32778
32770: LD_INT 33
32772: DOUBLE
32773: EQUAL
32774: IFTRUE 32778
32776: GO 32803
32778: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32779: LD_ADDR_VAR 0 3
32783: PUSH
32784: LD_INT 32
32786: PPUSH
32787: LD_VAR 0 1
32791: PPUSH
32792: CALL_OW 321
32796: PUSH
32797: LD_INT 2
32799: EQUAL
32800: ST_TO_ADDR
32801: GO 33123
32803: LD_INT 20
32805: DOUBLE
32806: EQUAL
32807: IFTRUE 32811
32809: GO 32836
32811: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32812: LD_ADDR_VAR 0 3
32816: PUSH
32817: LD_INT 6
32819: PPUSH
32820: LD_VAR 0 1
32824: PPUSH
32825: CALL_OW 321
32829: PUSH
32830: LD_INT 2
32832: EQUAL
32833: ST_TO_ADDR
32834: GO 33123
32836: LD_INT 22
32838: DOUBLE
32839: EQUAL
32840: IFTRUE 32850
32842: LD_INT 36
32844: DOUBLE
32845: EQUAL
32846: IFTRUE 32850
32848: GO 32875
32850: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32851: LD_ADDR_VAR 0 3
32855: PUSH
32856: LD_INT 15
32858: PPUSH
32859: LD_VAR 0 1
32863: PPUSH
32864: CALL_OW 321
32868: PUSH
32869: LD_INT 2
32871: EQUAL
32872: ST_TO_ADDR
32873: GO 33123
32875: LD_INT 30
32877: DOUBLE
32878: EQUAL
32879: IFTRUE 32883
32881: GO 32908
32883: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32884: LD_ADDR_VAR 0 3
32888: PUSH
32889: LD_INT 20
32891: PPUSH
32892: LD_VAR 0 1
32896: PPUSH
32897: CALL_OW 321
32901: PUSH
32902: LD_INT 2
32904: EQUAL
32905: ST_TO_ADDR
32906: GO 33123
32908: LD_INT 28
32910: DOUBLE
32911: EQUAL
32912: IFTRUE 32922
32914: LD_INT 21
32916: DOUBLE
32917: EQUAL
32918: IFTRUE 32922
32920: GO 32947
32922: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32923: LD_ADDR_VAR 0 3
32927: PUSH
32928: LD_INT 21
32930: PPUSH
32931: LD_VAR 0 1
32935: PPUSH
32936: CALL_OW 321
32940: PUSH
32941: LD_INT 2
32943: EQUAL
32944: ST_TO_ADDR
32945: GO 33123
32947: LD_INT 16
32949: DOUBLE
32950: EQUAL
32951: IFTRUE 32955
32953: GO 32982
32955: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32956: LD_ADDR_VAR 0 3
32960: PUSH
32961: LD_EXP 42
32965: PPUSH
32966: LD_VAR 0 1
32970: PPUSH
32971: CALL_OW 321
32975: PUSH
32976: LD_INT 2
32978: EQUAL
32979: ST_TO_ADDR
32980: GO 33123
32982: LD_INT 19
32984: DOUBLE
32985: EQUAL
32986: IFTRUE 32996
32988: LD_INT 23
32990: DOUBLE
32991: EQUAL
32992: IFTRUE 32996
32994: GO 33023
32996: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32997: LD_ADDR_VAR 0 3
33001: PUSH
33002: LD_EXP 41
33006: PPUSH
33007: LD_VAR 0 1
33011: PPUSH
33012: CALL_OW 321
33016: PUSH
33017: LD_INT 2
33019: EQUAL
33020: ST_TO_ADDR
33021: GO 33123
33023: LD_INT 17
33025: DOUBLE
33026: EQUAL
33027: IFTRUE 33031
33029: GO 33056
33031: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
33032: LD_ADDR_VAR 0 3
33036: PUSH
33037: LD_INT 39
33039: PPUSH
33040: LD_VAR 0 1
33044: PPUSH
33045: CALL_OW 321
33049: PUSH
33050: LD_INT 2
33052: EQUAL
33053: ST_TO_ADDR
33054: GO 33123
33056: LD_INT 18
33058: DOUBLE
33059: EQUAL
33060: IFTRUE 33064
33062: GO 33089
33064: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
33065: LD_ADDR_VAR 0 3
33069: PUSH
33070: LD_INT 40
33072: PPUSH
33073: LD_VAR 0 1
33077: PPUSH
33078: CALL_OW 321
33082: PUSH
33083: LD_INT 2
33085: EQUAL
33086: ST_TO_ADDR
33087: GO 33123
33089: LD_INT 27
33091: DOUBLE
33092: EQUAL
33093: IFTRUE 33097
33095: GO 33122
33097: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
33098: LD_ADDR_VAR 0 3
33102: PUSH
33103: LD_INT 35
33105: PPUSH
33106: LD_VAR 0 1
33110: PPUSH
33111: CALL_OW 321
33115: PUSH
33116: LD_INT 2
33118: EQUAL
33119: ST_TO_ADDR
33120: GO 33123
33122: POP
// end ;
33123: LD_VAR 0 3
33127: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
33128: LD_INT 0
33130: PPUSH
33131: PPUSH
33132: PPUSH
33133: PPUSH
33134: PPUSH
33135: PPUSH
33136: PPUSH
33137: PPUSH
33138: PPUSH
33139: PPUSH
33140: PPUSH
// result := false ;
33141: LD_ADDR_VAR 0 6
33145: PUSH
33146: LD_INT 0
33148: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
33149: LD_VAR 0 1
33153: NOT
33154: PUSH
33155: LD_VAR 0 1
33159: PPUSH
33160: CALL_OW 266
33164: PUSH
33165: LD_INT 0
33167: PUSH
33168: LD_INT 1
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: IN
33175: NOT
33176: OR
33177: PUSH
33178: LD_VAR 0 2
33182: NOT
33183: OR
33184: PUSH
33185: LD_VAR 0 5
33189: PUSH
33190: LD_INT 0
33192: PUSH
33193: LD_INT 1
33195: PUSH
33196: LD_INT 2
33198: PUSH
33199: LD_INT 3
33201: PUSH
33202: LD_INT 4
33204: PUSH
33205: LD_INT 5
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: IN
33216: NOT
33217: OR
33218: PUSH
33219: LD_VAR 0 3
33223: PPUSH
33224: LD_VAR 0 4
33228: PPUSH
33229: CALL_OW 488
33233: NOT
33234: OR
33235: IFFALSE 33239
// exit ;
33237: GO 33975
// side := GetSide ( depot ) ;
33239: LD_ADDR_VAR 0 9
33243: PUSH
33244: LD_VAR 0 1
33248: PPUSH
33249: CALL_OW 255
33253: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33254: LD_VAR 0 9
33258: PPUSH
33259: LD_VAR 0 2
33263: PPUSH
33264: CALL 32748 0 2
33268: NOT
33269: IFFALSE 33273
// exit ;
33271: GO 33975
// pom := GetBase ( depot ) ;
33273: LD_ADDR_VAR 0 10
33277: PUSH
33278: LD_VAR 0 1
33282: PPUSH
33283: CALL_OW 274
33287: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33288: LD_ADDR_VAR 0 11
33292: PUSH
33293: LD_VAR 0 2
33297: PPUSH
33298: LD_VAR 0 1
33302: PPUSH
33303: CALL_OW 248
33307: PPUSH
33308: CALL_OW 450
33312: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33313: LD_VAR 0 10
33317: PPUSH
33318: LD_INT 1
33320: PPUSH
33321: CALL_OW 275
33325: PUSH
33326: LD_VAR 0 11
33330: PUSH
33331: LD_INT 1
33333: ARRAY
33334: GREATEREQUAL
33335: PUSH
33336: LD_VAR 0 10
33340: PPUSH
33341: LD_INT 2
33343: PPUSH
33344: CALL_OW 275
33348: PUSH
33349: LD_VAR 0 11
33353: PUSH
33354: LD_INT 2
33356: ARRAY
33357: GREATEREQUAL
33358: AND
33359: PUSH
33360: LD_VAR 0 10
33364: PPUSH
33365: LD_INT 3
33367: PPUSH
33368: CALL_OW 275
33372: PUSH
33373: LD_VAR 0 11
33377: PUSH
33378: LD_INT 3
33380: ARRAY
33381: GREATEREQUAL
33382: AND
33383: NOT
33384: IFFALSE 33388
// exit ;
33386: GO 33975
// if GetBType ( depot ) = b_depot then
33388: LD_VAR 0 1
33392: PPUSH
33393: CALL_OW 266
33397: PUSH
33398: LD_INT 0
33400: EQUAL
33401: IFFALSE 33413
// dist := 28 else
33403: LD_ADDR_VAR 0 14
33407: PUSH
33408: LD_INT 28
33410: ST_TO_ADDR
33411: GO 33421
// dist := 36 ;
33413: LD_ADDR_VAR 0 14
33417: PUSH
33418: LD_INT 36
33420: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33421: LD_VAR 0 1
33425: PPUSH
33426: LD_VAR 0 3
33430: PPUSH
33431: LD_VAR 0 4
33435: PPUSH
33436: CALL_OW 297
33440: PUSH
33441: LD_VAR 0 14
33445: GREATER
33446: IFFALSE 33450
// exit ;
33448: GO 33975
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33450: LD_ADDR_VAR 0 12
33454: PUSH
33455: LD_VAR 0 2
33459: PPUSH
33460: LD_VAR 0 3
33464: PPUSH
33465: LD_VAR 0 4
33469: PPUSH
33470: LD_VAR 0 5
33474: PPUSH
33475: LD_VAR 0 1
33479: PPUSH
33480: CALL_OW 248
33484: PPUSH
33485: LD_INT 0
33487: PPUSH
33488: CALL 33980 0 6
33492: ST_TO_ADDR
// if not hexes then
33493: LD_VAR 0 12
33497: NOT
33498: IFFALSE 33502
// exit ;
33500: GO 33975
// hex := GetHexInfo ( x , y ) ;
33502: LD_ADDR_VAR 0 15
33506: PUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: LD_VAR 0 4
33516: PPUSH
33517: CALL_OW 546
33521: ST_TO_ADDR
// if hex [ 1 ] then
33522: LD_VAR 0 15
33526: PUSH
33527: LD_INT 1
33529: ARRAY
33530: IFFALSE 33534
// exit ;
33532: GO 33975
// height := hex [ 2 ] ;
33534: LD_ADDR_VAR 0 13
33538: PUSH
33539: LD_VAR 0 15
33543: PUSH
33544: LD_INT 2
33546: ARRAY
33547: ST_TO_ADDR
// for i = 1 to hexes do
33548: LD_ADDR_VAR 0 7
33552: PUSH
33553: DOUBLE
33554: LD_INT 1
33556: DEC
33557: ST_TO_ADDR
33558: LD_VAR 0 12
33562: PUSH
33563: FOR_TO
33564: IFFALSE 33894
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33566: LD_VAR 0 12
33570: PUSH
33571: LD_VAR 0 7
33575: ARRAY
33576: PUSH
33577: LD_INT 1
33579: ARRAY
33580: PPUSH
33581: LD_VAR 0 12
33585: PUSH
33586: LD_VAR 0 7
33590: ARRAY
33591: PUSH
33592: LD_INT 2
33594: ARRAY
33595: PPUSH
33596: CALL_OW 488
33600: NOT
33601: PUSH
33602: LD_VAR 0 12
33606: PUSH
33607: LD_VAR 0 7
33611: ARRAY
33612: PUSH
33613: LD_INT 1
33615: ARRAY
33616: PPUSH
33617: LD_VAR 0 12
33621: PUSH
33622: LD_VAR 0 7
33626: ARRAY
33627: PUSH
33628: LD_INT 2
33630: ARRAY
33631: PPUSH
33632: CALL_OW 428
33636: PUSH
33637: LD_INT 0
33639: GREATER
33640: OR
33641: PUSH
33642: LD_VAR 0 12
33646: PUSH
33647: LD_VAR 0 7
33651: ARRAY
33652: PUSH
33653: LD_INT 1
33655: ARRAY
33656: PPUSH
33657: LD_VAR 0 12
33661: PUSH
33662: LD_VAR 0 7
33666: ARRAY
33667: PUSH
33668: LD_INT 2
33670: ARRAY
33671: PPUSH
33672: CALL_OW 351
33676: OR
33677: IFFALSE 33683
// exit ;
33679: POP
33680: POP
33681: GO 33975
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33683: LD_ADDR_VAR 0 8
33687: PUSH
33688: LD_VAR 0 12
33692: PUSH
33693: LD_VAR 0 7
33697: ARRAY
33698: PUSH
33699: LD_INT 1
33701: ARRAY
33702: PPUSH
33703: LD_VAR 0 12
33707: PUSH
33708: LD_VAR 0 7
33712: ARRAY
33713: PUSH
33714: LD_INT 2
33716: ARRAY
33717: PPUSH
33718: CALL_OW 546
33722: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33723: LD_VAR 0 8
33727: PUSH
33728: LD_INT 1
33730: ARRAY
33731: PUSH
33732: LD_VAR 0 8
33736: PUSH
33737: LD_INT 2
33739: ARRAY
33740: PUSH
33741: LD_VAR 0 13
33745: PUSH
33746: LD_INT 2
33748: PLUS
33749: GREATER
33750: OR
33751: PUSH
33752: LD_VAR 0 8
33756: PUSH
33757: LD_INT 2
33759: ARRAY
33760: PUSH
33761: LD_VAR 0 13
33765: PUSH
33766: LD_INT 2
33768: MINUS
33769: LESS
33770: OR
33771: PUSH
33772: LD_VAR 0 8
33776: PUSH
33777: LD_INT 3
33779: ARRAY
33780: PUSH
33781: LD_INT 0
33783: PUSH
33784: LD_INT 8
33786: PUSH
33787: LD_INT 9
33789: PUSH
33790: LD_INT 10
33792: PUSH
33793: LD_INT 11
33795: PUSH
33796: LD_INT 12
33798: PUSH
33799: LD_INT 13
33801: PUSH
33802: LD_INT 16
33804: PUSH
33805: LD_INT 17
33807: PUSH
33808: LD_INT 18
33810: PUSH
33811: LD_INT 19
33813: PUSH
33814: LD_INT 20
33816: PUSH
33817: LD_INT 21
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: LIST
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: IN
33835: NOT
33836: OR
33837: PUSH
33838: LD_VAR 0 8
33842: PUSH
33843: LD_INT 5
33845: ARRAY
33846: NOT
33847: OR
33848: PUSH
33849: LD_VAR 0 8
33853: PUSH
33854: LD_INT 6
33856: ARRAY
33857: PUSH
33858: LD_INT 1
33860: PUSH
33861: LD_INT 2
33863: PUSH
33864: LD_INT 7
33866: PUSH
33867: LD_INT 9
33869: PUSH
33870: LD_INT 10
33872: PUSH
33873: LD_INT 11
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: IN
33884: NOT
33885: OR
33886: IFFALSE 33892
// exit ;
33888: POP
33889: POP
33890: GO 33975
// end ;
33892: GO 33563
33894: POP
33895: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33896: LD_VAR 0 9
33900: PPUSH
33901: LD_VAR 0 3
33905: PPUSH
33906: LD_VAR 0 4
33910: PPUSH
33911: LD_INT 20
33913: PPUSH
33914: CALL 25921 0 4
33918: PUSH
33919: LD_INT 4
33921: ARRAY
33922: IFFALSE 33926
// exit ;
33924: GO 33975
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33926: LD_VAR 0 2
33930: PUSH
33931: LD_INT 29
33933: PUSH
33934: LD_INT 30
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: IN
33941: PUSH
33942: LD_VAR 0 3
33946: PPUSH
33947: LD_VAR 0 4
33951: PPUSH
33952: LD_VAR 0 9
33956: PPUSH
33957: CALL_OW 440
33961: NOT
33962: AND
33963: IFFALSE 33967
// exit ;
33965: GO 33975
// result := true ;
33967: LD_ADDR_VAR 0 6
33971: PUSH
33972: LD_INT 1
33974: ST_TO_ADDR
// end ;
33975: LD_VAR 0 6
33979: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33980: LD_INT 0
33982: PPUSH
33983: PPUSH
33984: PPUSH
33985: PPUSH
33986: PPUSH
33987: PPUSH
33988: PPUSH
33989: PPUSH
33990: PPUSH
33991: PPUSH
33992: PPUSH
33993: PPUSH
33994: PPUSH
33995: PPUSH
33996: PPUSH
33997: PPUSH
33998: PPUSH
33999: PPUSH
34000: PPUSH
34001: PPUSH
34002: PPUSH
34003: PPUSH
34004: PPUSH
34005: PPUSH
34006: PPUSH
34007: PPUSH
34008: PPUSH
34009: PPUSH
34010: PPUSH
34011: PPUSH
34012: PPUSH
34013: PPUSH
34014: PPUSH
34015: PPUSH
34016: PPUSH
34017: PPUSH
34018: PPUSH
34019: PPUSH
34020: PPUSH
34021: PPUSH
34022: PPUSH
34023: PPUSH
34024: PPUSH
34025: PPUSH
34026: PPUSH
34027: PPUSH
34028: PPUSH
34029: PPUSH
34030: PPUSH
34031: PPUSH
34032: PPUSH
34033: PPUSH
34034: PPUSH
34035: PPUSH
34036: PPUSH
34037: PPUSH
34038: PPUSH
34039: PPUSH
// result = [ ] ;
34040: LD_ADDR_VAR 0 7
34044: PUSH
34045: EMPTY
34046: ST_TO_ADDR
// temp_list = [ ] ;
34047: LD_ADDR_VAR 0 9
34051: PUSH
34052: EMPTY
34053: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
34054: LD_VAR 0 4
34058: PUSH
34059: LD_INT 0
34061: PUSH
34062: LD_INT 1
34064: PUSH
34065: LD_INT 2
34067: PUSH
34068: LD_INT 3
34070: PUSH
34071: LD_INT 4
34073: PUSH
34074: LD_INT 5
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: IN
34085: NOT
34086: PUSH
34087: LD_VAR 0 1
34091: PUSH
34092: LD_INT 0
34094: PUSH
34095: LD_INT 1
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: IN
34102: PUSH
34103: LD_VAR 0 5
34107: PUSH
34108: LD_INT 1
34110: PUSH
34111: LD_INT 2
34113: PUSH
34114: LD_INT 3
34116: PUSH
34117: EMPTY
34118: LIST
34119: LIST
34120: LIST
34121: IN
34122: NOT
34123: AND
34124: OR
34125: IFFALSE 34129
// exit ;
34127: GO 52520
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
34129: LD_VAR 0 1
34133: PUSH
34134: LD_INT 6
34136: PUSH
34137: LD_INT 7
34139: PUSH
34140: LD_INT 8
34142: PUSH
34143: LD_INT 13
34145: PUSH
34146: LD_INT 12
34148: PUSH
34149: LD_INT 15
34151: PUSH
34152: LD_INT 11
34154: PUSH
34155: LD_INT 14
34157: PUSH
34158: LD_INT 10
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: IN
34172: IFFALSE 34182
// btype = b_lab ;
34174: LD_ADDR_VAR 0 1
34178: PUSH
34179: LD_INT 6
34181: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34182: LD_VAR 0 6
34186: PUSH
34187: LD_INT 0
34189: PUSH
34190: LD_INT 1
34192: PUSH
34193: LD_INT 2
34195: PUSH
34196: EMPTY
34197: LIST
34198: LIST
34199: LIST
34200: IN
34201: NOT
34202: PUSH
34203: LD_VAR 0 1
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: LD_INT 1
34213: PUSH
34214: LD_INT 2
34216: PUSH
34217: LD_INT 3
34219: PUSH
34220: LD_INT 6
34222: PUSH
34223: LD_INT 36
34225: PUSH
34226: LD_INT 4
34228: PUSH
34229: LD_INT 5
34231: PUSH
34232: LD_INT 31
34234: PUSH
34235: LD_INT 32
34237: PUSH
34238: LD_INT 33
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: LIST
34252: LIST
34253: IN
34254: NOT
34255: PUSH
34256: LD_VAR 0 6
34260: PUSH
34261: LD_INT 1
34263: EQUAL
34264: AND
34265: OR
34266: PUSH
34267: LD_VAR 0 1
34271: PUSH
34272: LD_INT 2
34274: PUSH
34275: LD_INT 3
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: IN
34282: NOT
34283: PUSH
34284: LD_VAR 0 6
34288: PUSH
34289: LD_INT 2
34291: EQUAL
34292: AND
34293: OR
34294: IFFALSE 34304
// mode = 0 ;
34296: LD_ADDR_VAR 0 6
34300: PUSH
34301: LD_INT 0
34303: ST_TO_ADDR
// case mode of 0 :
34304: LD_VAR 0 6
34308: PUSH
34309: LD_INT 0
34311: DOUBLE
34312: EQUAL
34313: IFTRUE 34317
34315: GO 45770
34317: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34318: LD_ADDR_VAR 0 11
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: LD_INT 0
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: LD_INT 1
34338: NEG
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 1
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 0
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 1
34376: NEG
34377: PUSH
34378: LD_INT 0
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 1
34387: NEG
34388: PUSH
34389: LD_INT 1
34391: NEG
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: LD_INT 2
34403: NEG
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 0
34411: PUSH
34412: LD_INT 2
34414: NEG
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 1
34422: PUSH
34423: LD_INT 1
34425: NEG
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 1
34433: PUSH
34434: LD_INT 2
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: LD_INT 2
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: NEG
34454: PUSH
34455: LD_INT 1
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 1
34464: PUSH
34465: LD_INT 3
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 0
34474: PUSH
34475: LD_INT 3
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 1
34484: NEG
34485: PUSH
34486: LD_INT 2
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: LIST
34501: LIST
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: LIST
34507: LIST
34508: LIST
34509: LIST
34510: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34511: LD_ADDR_VAR 0 12
34515: PUSH
34516: LD_INT 0
34518: PUSH
34519: LD_INT 0
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: LD_INT 1
34531: NEG
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 1
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: PUSH
34550: LD_INT 1
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: LD_INT 1
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 1
34569: NEG
34570: PUSH
34571: LD_INT 0
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 1
34580: NEG
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 1
34592: PUSH
34593: LD_INT 1
34595: NEG
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: PUSH
34604: LD_INT 0
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 2
34613: PUSH
34614: LD_INT 1
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 1
34623: NEG
34624: PUSH
34625: LD_INT 1
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 2
34634: NEG
34635: PUSH
34636: LD_INT 0
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 2
34645: NEG
34646: PUSH
34647: LD_INT 1
34649: NEG
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 2
34657: NEG
34658: PUSH
34659: LD_INT 1
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: LD_INT 3
34668: NEG
34669: PUSH
34670: LD_INT 0
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PUSH
34677: LD_INT 3
34679: NEG
34680: PUSH
34681: LD_INT 1
34683: NEG
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: LIST
34705: LIST
34706: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34707: LD_ADDR_VAR 0 13
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: LD_INT 0
34717: PUSH
34718: EMPTY
34719: LIST
34720: LIST
34721: PUSH
34722: LD_INT 0
34724: PUSH
34725: LD_INT 1
34727: NEG
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: PUSH
34736: LD_INT 0
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 1
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 0
34755: PUSH
34756: LD_INT 1
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: NEG
34766: PUSH
34767: LD_INT 0
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 1
34776: NEG
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 1
34788: NEG
34789: PUSH
34790: LD_INT 2
34792: NEG
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: LD_INT 1
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 2
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 1
34820: PUSH
34821: LD_INT 2
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 2
34830: NEG
34831: PUSH
34832: LD_INT 1
34834: NEG
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 2
34842: NEG
34843: PUSH
34844: LD_INT 2
34846: NEG
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 2
34854: NEG
34855: PUSH
34856: LD_INT 3
34858: NEG
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 3
34866: NEG
34867: PUSH
34868: LD_INT 2
34870: NEG
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 3
34878: NEG
34879: PUSH
34880: LD_INT 3
34882: NEG
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34906: LD_ADDR_VAR 0 14
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: LD_INT 0
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 0
34923: PUSH
34924: LD_INT 1
34926: NEG
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 1
34934: PUSH
34935: LD_INT 0
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 0
34954: PUSH
34955: LD_INT 1
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 1
34964: NEG
34965: PUSH
34966: LD_INT 0
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: PUSH
34973: LD_INT 1
34975: NEG
34976: PUSH
34977: LD_INT 1
34979: NEG
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 2
34991: NEG
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 0
34999: PUSH
35000: LD_INT 2
35002: NEG
35003: PUSH
35004: EMPTY
35005: LIST
35006: LIST
35007: PUSH
35008: LD_INT 1
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 1
35021: PUSH
35022: LD_INT 2
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 0
35031: PUSH
35032: LD_INT 2
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: PUSH
35039: LD_INT 1
35041: NEG
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: EMPTY
35047: LIST
35048: LIST
35049: PUSH
35050: LD_INT 1
35052: NEG
35053: PUSH
35054: LD_INT 3
35056: NEG
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: LD_INT 0
35064: PUSH
35065: LD_INT 3
35067: NEG
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 1
35075: PUSH
35076: LD_INT 2
35078: NEG
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35102: LD_ADDR_VAR 0 15
35106: PUSH
35107: LD_INT 0
35109: PUSH
35110: LD_INT 0
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 0
35119: PUSH
35120: LD_INT 1
35122: NEG
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 1
35130: PUSH
35131: LD_INT 0
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 1
35140: PUSH
35141: LD_INT 1
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: LD_INT 1
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 1
35160: NEG
35161: PUSH
35162: LD_INT 0
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: NEG
35172: PUSH
35173: LD_INT 1
35175: NEG
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: LD_INT 1
35186: NEG
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: LD_INT 0
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 2
35204: PUSH
35205: LD_INT 1
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: NEG
35215: PUSH
35216: LD_INT 1
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 2
35225: NEG
35226: PUSH
35227: LD_INT 0
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 2
35236: NEG
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 2
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 3
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 3
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35295: LD_ADDR_VAR 0 16
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 0
35305: PUSH
35306: EMPTY
35307: LIST
35308: LIST
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 0
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 1
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 0
35343: PUSH
35344: LD_INT 1
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 1
35353: NEG
35354: PUSH
35355: LD_INT 0
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 1
35364: NEG
35365: PUSH
35366: LD_INT 1
35368: NEG
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: LD_INT 1
35376: NEG
35377: PUSH
35378: LD_INT 2
35380: NEG
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PUSH
35386: LD_INT 2
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 2
35398: PUSH
35399: LD_INT 2
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: PUSH
35406: LD_INT 1
35408: PUSH
35409: LD_INT 2
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 2
35418: NEG
35419: PUSH
35420: LD_INT 1
35422: NEG
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 2
35430: NEG
35431: PUSH
35432: LD_INT 2
35434: NEG
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 3
35442: PUSH
35443: LD_INT 2
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 3
35452: PUSH
35453: LD_INT 3
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 2
35462: PUSH
35463: LD_INT 3
35465: PUSH
35466: EMPTY
35467: LIST
35468: LIST
35469: PUSH
35470: EMPTY
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35488: LD_ADDR_VAR 0 17
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: LD_INT 0
35498: PUSH
35499: EMPTY
35500: LIST
35501: LIST
35502: PUSH
35503: LD_INT 0
35505: PUSH
35506: LD_INT 1
35508: NEG
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: LD_INT 0
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 0
35536: PUSH
35537: LD_INT 1
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: PUSH
35544: LD_INT 1
35546: NEG
35547: PUSH
35548: LD_INT 0
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 1
35557: NEG
35558: PUSH
35559: LD_INT 1
35561: NEG
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 1
35569: NEG
35570: PUSH
35571: LD_INT 2
35573: NEG
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 0
35581: PUSH
35582: LD_INT 2
35584: NEG
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 1
35592: PUSH
35593: LD_INT 1
35595: NEG
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: PUSH
35604: LD_INT 0
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: PUSH
35624: LD_INT 2
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 1
35633: PUSH
35634: LD_INT 2
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 0
35643: PUSH
35644: LD_INT 2
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 1
35653: NEG
35654: PUSH
35655: LD_INT 1
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 2
35664: NEG
35665: PUSH
35666: LD_INT 0
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: PUSH
35673: LD_INT 2
35675: NEG
35676: PUSH
35677: LD_INT 1
35679: NEG
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 2
35687: NEG
35688: PUSH
35689: LD_INT 2
35691: NEG
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: LIST
35708: LIST
35709: LIST
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: LIST
35716: LIST
35717: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35718: LD_ADDR_VAR 0 18
35722: PUSH
35723: LD_INT 0
35725: PUSH
35726: LD_INT 0
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: PUSH
35733: LD_INT 0
35735: PUSH
35736: LD_INT 1
35738: NEG
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: LD_INT 0
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 1
35756: PUSH
35757: LD_INT 1
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 0
35766: PUSH
35767: LD_INT 1
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 1
35776: NEG
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 1
35787: NEG
35788: PUSH
35789: LD_INT 1
35791: NEG
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 1
35799: NEG
35800: PUSH
35801: LD_INT 2
35803: NEG
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: LD_INT 2
35814: NEG
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 1
35822: PUSH
35823: LD_INT 1
35825: NEG
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: LD_INT 0
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: PUSH
35844: LD_INT 1
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 2
35853: PUSH
35854: LD_INT 2
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 1
35863: PUSH
35864: LD_INT 2
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: LD_INT 2
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 1
35883: NEG
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 2
35894: NEG
35895: PUSH
35896: LD_INT 0
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 2
35905: NEG
35906: PUSH
35907: LD_INT 1
35909: NEG
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 2
35917: NEG
35918: PUSH
35919: LD_INT 2
35921: NEG
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: LIST
35938: LIST
35939: LIST
35940: LIST
35941: LIST
35942: LIST
35943: LIST
35944: LIST
35945: LIST
35946: LIST
35947: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35948: LD_ADDR_VAR 0 19
35952: PUSH
35953: LD_INT 0
35955: PUSH
35956: LD_INT 0
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 0
35965: PUSH
35966: LD_INT 1
35968: NEG
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 1
35976: PUSH
35977: LD_INT 0
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 1
35986: PUSH
35987: LD_INT 1
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 0
35996: PUSH
35997: LD_INT 1
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 1
36006: NEG
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: EMPTY
36012: LIST
36013: LIST
36014: PUSH
36015: LD_INT 1
36017: NEG
36018: PUSH
36019: LD_INT 1
36021: NEG
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 1
36029: NEG
36030: PUSH
36031: LD_INT 2
36033: NEG
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: LD_INT 0
36041: PUSH
36042: LD_INT 2
36044: NEG
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PUSH
36050: LD_INT 1
36052: PUSH
36053: LD_INT 1
36055: NEG
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 2
36063: PUSH
36064: LD_INT 0
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: LD_INT 1
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 2
36083: PUSH
36084: LD_INT 2
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 1
36093: PUSH
36094: LD_INT 2
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 0
36103: PUSH
36104: LD_INT 2
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 1
36113: NEG
36114: PUSH
36115: LD_INT 1
36117: PUSH
36118: EMPTY
36119: LIST
36120: LIST
36121: PUSH
36122: LD_INT 2
36124: NEG
36125: PUSH
36126: LD_INT 0
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: PUSH
36133: LD_INT 2
36135: NEG
36136: PUSH
36137: LD_INT 1
36139: NEG
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 2
36147: NEG
36148: PUSH
36149: LD_INT 2
36151: NEG
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36178: LD_ADDR_VAR 0 20
36182: PUSH
36183: LD_INT 0
36185: PUSH
36186: LD_INT 0
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 0
36195: PUSH
36196: LD_INT 1
36198: NEG
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 1
36206: PUSH
36207: LD_INT 0
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 1
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 0
36226: PUSH
36227: LD_INT 1
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: PUSH
36234: LD_INT 1
36236: NEG
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: LD_INT 1
36247: NEG
36248: PUSH
36249: LD_INT 1
36251: NEG
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 1
36259: NEG
36260: PUSH
36261: LD_INT 2
36263: NEG
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 0
36271: PUSH
36272: LD_INT 2
36274: NEG
36275: PUSH
36276: EMPTY
36277: LIST
36278: LIST
36279: PUSH
36280: LD_INT 1
36282: PUSH
36283: LD_INT 1
36285: NEG
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: LD_INT 0
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 2
36303: PUSH
36304: LD_INT 1
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 2
36313: PUSH
36314: LD_INT 2
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 1
36323: PUSH
36324: LD_INT 2
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 0
36333: PUSH
36334: LD_INT 2
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 1
36343: NEG
36344: PUSH
36345: LD_INT 1
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 2
36354: NEG
36355: PUSH
36356: LD_INT 0
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 2
36365: NEG
36366: PUSH
36367: LD_INT 1
36369: NEG
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 2
36377: NEG
36378: PUSH
36379: LD_INT 2
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: LIST
36407: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36408: LD_ADDR_VAR 0 21
36412: PUSH
36413: LD_INT 0
36415: PUSH
36416: LD_INT 0
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 0
36425: PUSH
36426: LD_INT 1
36428: NEG
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: LD_INT 0
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 1
36446: PUSH
36447: LD_INT 1
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 0
36456: PUSH
36457: LD_INT 1
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: PUSH
36464: LD_INT 1
36466: NEG
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 1
36477: NEG
36478: PUSH
36479: LD_INT 1
36481: NEG
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PUSH
36487: LD_INT 1
36489: NEG
36490: PUSH
36491: LD_INT 2
36493: NEG
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 2
36504: NEG
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: LD_INT 1
36512: PUSH
36513: LD_INT 1
36515: NEG
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 2
36523: PUSH
36524: LD_INT 0
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 2
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 2
36543: PUSH
36544: LD_INT 2
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 1
36553: PUSH
36554: LD_INT 2
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: LD_INT 2
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: LD_INT 1
36573: NEG
36574: PUSH
36575: LD_INT 1
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 2
36584: NEG
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 2
36595: NEG
36596: PUSH
36597: LD_INT 1
36599: NEG
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: LD_INT 2
36607: NEG
36608: PUSH
36609: LD_INT 2
36611: NEG
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: LIST
36632: LIST
36633: LIST
36634: LIST
36635: LIST
36636: LIST
36637: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36638: LD_ADDR_VAR 0 22
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: LD_INT 0
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 0
36655: PUSH
36656: LD_INT 1
36658: NEG
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 1
36666: PUSH
36667: LD_INT 0
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 1
36676: PUSH
36677: LD_INT 1
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 0
36686: PUSH
36687: LD_INT 1
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 1
36696: NEG
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: EMPTY
36702: LIST
36703: LIST
36704: PUSH
36705: LD_INT 1
36707: NEG
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 1
36719: NEG
36720: PUSH
36721: LD_INT 2
36723: NEG
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: LD_INT 0
36731: PUSH
36732: LD_INT 2
36734: NEG
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: LD_INT 1
36745: NEG
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 2
36753: PUSH
36754: LD_INT 0
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: LD_INT 1
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 2
36773: PUSH
36774: LD_INT 2
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 1
36783: PUSH
36784: LD_INT 2
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 0
36793: PUSH
36794: LD_INT 2
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: LD_INT 1
36803: NEG
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 2
36814: NEG
36815: PUSH
36816: LD_INT 0
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 2
36825: NEG
36826: PUSH
36827: LD_INT 1
36829: NEG
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 2
36837: NEG
36838: PUSH
36839: LD_INT 2
36841: NEG
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: LIST
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36868: LD_ADDR_VAR 0 23
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: LD_INT 0
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 0
36885: PUSH
36886: LD_INT 1
36888: NEG
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: LD_INT 0
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 1
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 0
36916: PUSH
36917: LD_INT 1
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 1
36926: NEG
36927: PUSH
36928: LD_INT 0
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 1
36937: NEG
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 1
36949: NEG
36950: PUSH
36951: LD_INT 2
36953: NEG
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 0
36961: PUSH
36962: LD_INT 2
36964: NEG
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: LD_INT 1
36972: PUSH
36973: LD_INT 1
36975: NEG
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 2
36983: PUSH
36984: LD_INT 0
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 2
36993: PUSH
36994: LD_INT 1
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 2
37003: PUSH
37004: LD_INT 2
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 1
37013: PUSH
37014: LD_INT 2
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 0
37023: PUSH
37024: LD_INT 2
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 1
37033: NEG
37034: PUSH
37035: LD_INT 1
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 2
37044: NEG
37045: PUSH
37046: LD_INT 0
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: LD_INT 2
37055: NEG
37056: PUSH
37057: LD_INT 1
37059: NEG
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: PUSH
37065: LD_INT 2
37067: NEG
37068: PUSH
37069: LD_INT 2
37071: NEG
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 2
37079: NEG
37080: PUSH
37081: LD_INT 3
37083: NEG
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 1
37091: NEG
37092: PUSH
37093: LD_INT 3
37095: NEG
37096: PUSH
37097: EMPTY
37098: LIST
37099: LIST
37100: PUSH
37101: LD_INT 1
37103: PUSH
37104: LD_INT 2
37106: NEG
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 2
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: LIST
37147: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
37148: LD_ADDR_VAR 0 24
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: LD_INT 0
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: PUSH
37163: LD_INT 0
37165: PUSH
37166: LD_INT 1
37168: NEG
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 0
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 0
37196: PUSH
37197: LD_INT 1
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 1
37206: NEG
37207: PUSH
37208: LD_INT 0
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: LD_INT 1
37221: NEG
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 1
37229: NEG
37230: PUSH
37231: LD_INT 2
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 0
37241: PUSH
37242: LD_INT 2
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: LD_INT 1
37255: NEG
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 2
37263: PUSH
37264: LD_INT 0
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 1
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 2
37283: PUSH
37284: LD_INT 2
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 1
37293: PUSH
37294: LD_INT 2
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 0
37303: PUSH
37304: LD_INT 2
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 1
37313: NEG
37314: PUSH
37315: LD_INT 1
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 2
37324: NEG
37325: PUSH
37326: LD_INT 0
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 2
37335: NEG
37336: PUSH
37337: LD_INT 1
37339: NEG
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 2
37347: NEG
37348: PUSH
37349: LD_INT 2
37351: NEG
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 1
37359: PUSH
37360: LD_INT 2
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 2
37370: PUSH
37371: LD_INT 1
37373: NEG
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 3
37381: PUSH
37382: LD_INT 1
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: LD_INT 2
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: EMPTY
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37424: LD_ADDR_VAR 0 25
37428: PUSH
37429: LD_INT 0
37431: PUSH
37432: LD_INT 0
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 0
37441: PUSH
37442: LD_INT 1
37444: NEG
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 1
37452: PUSH
37453: LD_INT 0
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 1
37462: PUSH
37463: LD_INT 1
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 0
37472: PUSH
37473: LD_INT 1
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 1
37482: NEG
37483: PUSH
37484: LD_INT 0
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 1
37493: NEG
37494: PUSH
37495: LD_INT 1
37497: NEG
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: PUSH
37503: LD_INT 1
37505: NEG
37506: PUSH
37507: LD_INT 2
37509: NEG
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: PUSH
37515: LD_INT 0
37517: PUSH
37518: LD_INT 2
37520: NEG
37521: PUSH
37522: EMPTY
37523: LIST
37524: LIST
37525: PUSH
37526: LD_INT 1
37528: PUSH
37529: LD_INT 1
37531: NEG
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 2
37539: PUSH
37540: LD_INT 0
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 2
37549: PUSH
37550: LD_INT 1
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 2
37559: PUSH
37560: LD_INT 2
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 1
37569: PUSH
37570: LD_INT 2
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 0
37579: PUSH
37580: LD_INT 2
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 1
37589: NEG
37590: PUSH
37591: LD_INT 1
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 2
37600: NEG
37601: PUSH
37602: LD_INT 0
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 2
37611: NEG
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 2
37623: NEG
37624: PUSH
37625: LD_INT 2
37627: NEG
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 3
37635: PUSH
37636: LD_INT 1
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 3
37645: PUSH
37646: LD_INT 2
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: LD_INT 2
37655: PUSH
37656: LD_INT 3
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: LD_INT 1
37665: PUSH
37666: LD_INT 3
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37698: LD_ADDR_VAR 0 26
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: LD_INT 0
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: LD_INT 1
37718: NEG
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: PUSH
37727: LD_INT 0
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 1
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: LD_INT 1
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 1
37756: NEG
37757: PUSH
37758: LD_INT 0
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 1
37767: NEG
37768: PUSH
37769: LD_INT 1
37771: NEG
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 1
37779: NEG
37780: PUSH
37781: LD_INT 2
37783: NEG
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: PUSH
37803: LD_INT 1
37805: NEG
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 2
37813: PUSH
37814: LD_INT 0
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 2
37823: PUSH
37824: LD_INT 1
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 0
37853: PUSH
37854: LD_INT 2
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: NEG
37864: PUSH
37865: LD_INT 1
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 2
37874: NEG
37875: PUSH
37876: LD_INT 0
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 2
37885: NEG
37886: PUSH
37887: LD_INT 1
37889: NEG
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 2
37897: NEG
37898: PUSH
37899: LD_INT 2
37901: NEG
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 2
37909: PUSH
37910: LD_INT 3
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: PUSH
37920: LD_INT 3
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 1
37929: NEG
37930: PUSH
37931: LD_INT 2
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 2
37940: NEG
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: EMPTY
37946: LIST
37947: LIST
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37974: LD_ADDR_VAR 0 27
37978: PUSH
37979: LD_INT 0
37981: PUSH
37982: LD_INT 0
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 0
37991: PUSH
37992: LD_INT 1
37994: NEG
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 1
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 1
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 0
38022: PUSH
38023: LD_INT 1
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 1
38032: NEG
38033: PUSH
38034: LD_INT 0
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 1
38043: NEG
38044: PUSH
38045: LD_INT 1
38047: NEG
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: LD_INT 1
38055: NEG
38056: PUSH
38057: LD_INT 2
38059: NEG
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 0
38067: PUSH
38068: LD_INT 2
38070: NEG
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 1
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 2
38089: PUSH
38090: LD_INT 0
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 2
38099: PUSH
38100: LD_INT 1
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 2
38109: PUSH
38110: LD_INT 2
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: LD_INT 2
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: LD_INT 1
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 2
38150: NEG
38151: PUSH
38152: LD_INT 0
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 2
38161: NEG
38162: PUSH
38163: LD_INT 1
38165: NEG
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 2
38173: NEG
38174: PUSH
38175: LD_INT 2
38177: NEG
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: PUSH
38183: LD_INT 1
38185: NEG
38186: PUSH
38187: LD_INT 2
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 2
38196: NEG
38197: PUSH
38198: LD_INT 1
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: PUSH
38205: LD_INT 3
38207: NEG
38208: PUSH
38209: LD_INT 1
38211: NEG
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: PUSH
38217: LD_INT 3
38219: NEG
38220: PUSH
38221: LD_INT 2
38223: NEG
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: LIST
38233: LIST
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: LIST
38247: LIST
38248: LIST
38249: LIST
38250: LIST
38251: LIST
38252: LIST
38253: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38254: LD_ADDR_VAR 0 28
38258: PUSH
38259: LD_INT 0
38261: PUSH
38262: LD_INT 0
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: LD_INT 0
38271: PUSH
38272: LD_INT 1
38274: NEG
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 1
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 0
38302: PUSH
38303: LD_INT 1
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 1
38312: NEG
38313: PUSH
38314: LD_INT 0
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 1
38323: NEG
38324: PUSH
38325: LD_INT 1
38327: NEG
38328: PUSH
38329: EMPTY
38330: LIST
38331: LIST
38332: PUSH
38333: LD_INT 1
38335: NEG
38336: PUSH
38337: LD_INT 2
38339: NEG
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 0
38347: PUSH
38348: LD_INT 2
38350: NEG
38351: PUSH
38352: EMPTY
38353: LIST
38354: LIST
38355: PUSH
38356: LD_INT 1
38358: PUSH
38359: LD_INT 1
38361: NEG
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: LD_INT 2
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 2
38379: PUSH
38380: LD_INT 1
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 2
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 1
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 0
38409: PUSH
38410: LD_INT 2
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 1
38419: NEG
38420: PUSH
38421: LD_INT 1
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 2
38430: NEG
38431: PUSH
38432: LD_INT 0
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: PUSH
38439: LD_INT 2
38441: NEG
38442: PUSH
38443: LD_INT 1
38445: NEG
38446: PUSH
38447: EMPTY
38448: LIST
38449: LIST
38450: PUSH
38451: LD_INT 2
38453: NEG
38454: PUSH
38455: LD_INT 2
38457: NEG
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 2
38465: NEG
38466: PUSH
38467: LD_INT 3
38469: NEG
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 1
38477: NEG
38478: PUSH
38479: LD_INT 3
38481: NEG
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 3
38489: NEG
38490: PUSH
38491: LD_INT 1
38493: NEG
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 3
38501: NEG
38502: PUSH
38503: LD_INT 2
38505: NEG
38506: PUSH
38507: EMPTY
38508: LIST
38509: LIST
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: LIST
38526: LIST
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38536: LD_ADDR_VAR 0 29
38540: PUSH
38541: LD_INT 0
38543: PUSH
38544: LD_INT 0
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 0
38553: PUSH
38554: LD_INT 1
38556: NEG
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 1
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 0
38584: PUSH
38585: LD_INT 1
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 1
38594: NEG
38595: PUSH
38596: LD_INT 0
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 1
38605: NEG
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 1
38617: NEG
38618: PUSH
38619: LD_INT 2
38621: NEG
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 0
38629: PUSH
38630: LD_INT 2
38632: NEG
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 1
38640: PUSH
38641: LD_INT 1
38643: NEG
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 2
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 2
38661: PUSH
38662: LD_INT 1
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 1
38671: PUSH
38672: LD_INT 2
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 0
38681: PUSH
38682: LD_INT 2
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 1
38691: NEG
38692: PUSH
38693: LD_INT 1
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 2
38702: NEG
38703: PUSH
38704: LD_INT 1
38706: NEG
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 2
38714: NEG
38715: PUSH
38716: LD_INT 2
38718: NEG
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 2
38726: NEG
38727: PUSH
38728: LD_INT 3
38730: NEG
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 2
38738: PUSH
38739: LD_INT 1
38741: NEG
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 3
38749: PUSH
38750: LD_INT 1
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 1
38759: PUSH
38760: LD_INT 3
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 1
38769: NEG
38770: PUSH
38771: LD_INT 2
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 3
38780: NEG
38781: PUSH
38782: LD_INT 2
38784: NEG
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: LIST
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: LIST
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38815: LD_ADDR_VAR 0 30
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 0
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 0
38832: PUSH
38833: LD_INT 1
38835: NEG
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 1
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 0
38863: PUSH
38864: LD_INT 1
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: LD_INT 1
38873: NEG
38874: PUSH
38875: LD_INT 0
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 1
38884: NEG
38885: PUSH
38886: LD_INT 1
38888: NEG
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: LD_INT 2
38900: NEG
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 0
38908: PUSH
38909: LD_INT 2
38911: NEG
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: LD_INT 1
38922: NEG
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 2
38930: PUSH
38931: LD_INT 0
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 2
38950: PUSH
38951: LD_INT 2
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: PUSH
38961: LD_INT 2
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 1
38970: NEG
38971: PUSH
38972: LD_INT 1
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 2
38981: NEG
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 2
38992: NEG
38993: PUSH
38994: LD_INT 1
38996: NEG
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 3
39008: NEG
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: PUSH
39014: LD_INT 1
39016: PUSH
39017: LD_INT 2
39019: NEG
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 3
39027: PUSH
39028: LD_INT 2
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 2
39037: PUSH
39038: LD_INT 3
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 2
39047: NEG
39048: PUSH
39049: LD_INT 1
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 3
39058: NEG
39059: PUSH
39060: LD_INT 1
39062: NEG
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: EMPTY
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: LIST
39087: LIST
39088: LIST
39089: LIST
39090: LIST
39091: LIST
39092: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39093: LD_ADDR_VAR 0 31
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: LD_INT 0
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 0
39110: PUSH
39111: LD_INT 1
39113: NEG
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 1
39121: PUSH
39122: LD_INT 0
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 1
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 0
39141: PUSH
39142: LD_INT 1
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 1
39151: NEG
39152: PUSH
39153: LD_INT 0
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 1
39162: NEG
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 1
39174: NEG
39175: PUSH
39176: LD_INT 2
39178: NEG
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 1
39186: PUSH
39187: LD_INT 1
39189: NEG
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 2
39197: PUSH
39198: LD_INT 0
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 2
39207: PUSH
39208: LD_INT 1
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 2
39217: PUSH
39218: LD_INT 2
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 1
39227: PUSH
39228: LD_INT 2
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 0
39237: PUSH
39238: LD_INT 2
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: PUSH
39245: LD_INT 1
39247: NEG
39248: PUSH
39249: LD_INT 1
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 2
39258: NEG
39259: PUSH
39260: LD_INT 1
39262: NEG
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: LD_INT 2
39270: NEG
39271: PUSH
39272: LD_INT 2
39274: NEG
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 2
39282: NEG
39283: PUSH
39284: LD_INT 3
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 2
39294: PUSH
39295: LD_INT 1
39297: NEG
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 3
39305: PUSH
39306: LD_INT 1
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: LD_INT 3
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: LD_INT 1
39325: NEG
39326: PUSH
39327: LD_INT 2
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 3
39336: NEG
39337: PUSH
39338: LD_INT 2
39340: NEG
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: PUSH
39346: EMPTY
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: LIST
39369: LIST
39370: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39371: LD_ADDR_VAR 0 32
39375: PUSH
39376: LD_INT 0
39378: PUSH
39379: LD_INT 0
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PUSH
39386: LD_INT 0
39388: PUSH
39389: LD_INT 1
39391: NEG
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: LD_INT 0
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: LD_INT 1
39409: PUSH
39410: LD_INT 1
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 0
39419: PUSH
39420: LD_INT 1
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 1
39429: NEG
39430: PUSH
39431: LD_INT 0
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 1
39440: NEG
39441: PUSH
39442: LD_INT 1
39444: NEG
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 1
39452: NEG
39453: PUSH
39454: LD_INT 2
39456: NEG
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 0
39464: PUSH
39465: LD_INT 2
39467: NEG
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 1
39475: PUSH
39476: LD_INT 1
39478: NEG
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: LD_INT 1
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 2
39496: PUSH
39497: LD_INT 2
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 1
39506: PUSH
39507: LD_INT 2
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 0
39516: PUSH
39517: LD_INT 2
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 1
39526: NEG
39527: PUSH
39528: LD_INT 1
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 2
39537: NEG
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 2
39548: NEG
39549: PUSH
39550: LD_INT 1
39552: NEG
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: LD_INT 1
39560: NEG
39561: PUSH
39562: LD_INT 3
39564: NEG
39565: PUSH
39566: EMPTY
39567: LIST
39568: LIST
39569: PUSH
39570: LD_INT 1
39572: PUSH
39573: LD_INT 2
39575: NEG
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 3
39583: PUSH
39584: LD_INT 2
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 2
39593: PUSH
39594: LD_INT 3
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 2
39603: NEG
39604: PUSH
39605: LD_INT 1
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 3
39614: NEG
39615: PUSH
39616: LD_INT 1
39618: NEG
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39649: LD_ADDR_VAR 0 33
39653: PUSH
39654: LD_INT 0
39656: PUSH
39657: LD_INT 0
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 0
39666: PUSH
39667: LD_INT 1
39669: NEG
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 1
39677: PUSH
39678: LD_INT 0
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 1
39687: PUSH
39688: LD_INT 1
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 0
39697: PUSH
39698: LD_INT 1
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 1
39707: NEG
39708: PUSH
39709: LD_INT 0
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 1
39718: NEG
39719: PUSH
39720: LD_INT 1
39722: NEG
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: PUSH
39728: LD_INT 1
39730: NEG
39731: PUSH
39732: LD_INT 2
39734: NEG
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: LD_INT 1
39742: PUSH
39743: LD_INT 1
39745: NEG
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 2
39763: PUSH
39764: LD_INT 1
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 1
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 0
39783: PUSH
39784: LD_INT 2
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: NEG
39794: PUSH
39795: LD_INT 1
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 2
39804: NEG
39805: PUSH
39806: LD_INT 0
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: LD_INT 2
39815: NEG
39816: PUSH
39817: LD_INT 1
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 2
39827: NEG
39828: PUSH
39829: LD_INT 2
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 2
39839: NEG
39840: PUSH
39841: LD_INT 3
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 2
39851: PUSH
39852: LD_INT 1
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 3
39862: PUSH
39863: LD_INT 1
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 1
39872: PUSH
39873: LD_INT 3
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: LD_INT 1
39882: NEG
39883: PUSH
39884: LD_INT 2
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 3
39893: NEG
39894: PUSH
39895: LD_INT 2
39897: NEG
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39928: LD_ADDR_VAR 0 34
39932: PUSH
39933: LD_INT 0
39935: PUSH
39936: LD_INT 0
39938: PUSH
39939: EMPTY
39940: LIST
39941: LIST
39942: PUSH
39943: LD_INT 0
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 1
39956: PUSH
39957: LD_INT 0
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 1
39966: PUSH
39967: LD_INT 1
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 0
39976: PUSH
39977: LD_INT 1
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 1
39986: NEG
39987: PUSH
39988: LD_INT 0
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 1
39997: NEG
39998: PUSH
39999: LD_INT 1
40001: NEG
40002: PUSH
40003: EMPTY
40004: LIST
40005: LIST
40006: PUSH
40007: LD_INT 1
40009: NEG
40010: PUSH
40011: LD_INT 2
40013: NEG
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: PUSH
40019: LD_INT 0
40021: PUSH
40022: LD_INT 2
40024: NEG
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 1
40032: PUSH
40033: LD_INT 1
40035: NEG
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 2
40043: PUSH
40044: LD_INT 1
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 2
40053: PUSH
40054: LD_INT 2
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: PUSH
40064: LD_INT 2
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 1
40073: NEG
40074: PUSH
40075: LD_INT 1
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 2
40084: NEG
40085: PUSH
40086: LD_INT 0
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 2
40095: NEG
40096: PUSH
40097: LD_INT 1
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 2
40107: NEG
40108: PUSH
40109: LD_INT 2
40111: NEG
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: LD_INT 1
40119: NEG
40120: PUSH
40121: LD_INT 3
40123: NEG
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 1
40131: PUSH
40132: LD_INT 2
40134: NEG
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 3
40142: PUSH
40143: LD_INT 2
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 2
40152: PUSH
40153: LD_INT 3
40155: PUSH
40156: EMPTY
40157: LIST
40158: LIST
40159: PUSH
40160: LD_INT 2
40162: NEG
40163: PUSH
40164: LD_INT 1
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 3
40173: NEG
40174: PUSH
40175: LD_INT 1
40177: NEG
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40208: LD_ADDR_VAR 0 35
40212: PUSH
40213: LD_INT 0
40215: PUSH
40216: LD_INT 0
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: LD_INT 0
40225: PUSH
40226: LD_INT 1
40228: NEG
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 1
40236: PUSH
40237: LD_INT 0
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 0
40256: PUSH
40257: LD_INT 1
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 1
40266: NEG
40267: PUSH
40268: LD_INT 0
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 1
40277: NEG
40278: PUSH
40279: LD_INT 1
40281: NEG
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 2
40289: PUSH
40290: LD_INT 1
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 2
40299: NEG
40300: PUSH
40301: LD_INT 1
40303: NEG
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: LIST
40317: LIST
40318: LIST
40319: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40320: LD_ADDR_VAR 0 36
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: LD_INT 0
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: LD_INT 0
40337: PUSH
40338: LD_INT 1
40340: NEG
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 1
40348: PUSH
40349: LD_INT 0
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: LD_INT 1
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: LD_INT 1
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 1
40378: NEG
40379: PUSH
40380: LD_INT 0
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: LD_INT 1
40389: NEG
40390: PUSH
40391: LD_INT 1
40393: NEG
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: LD_INT 1
40401: NEG
40402: PUSH
40403: LD_INT 2
40405: NEG
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 1
40413: PUSH
40414: LD_INT 2
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: LIST
40428: LIST
40429: LIST
40430: LIST
40431: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40432: LD_ADDR_VAR 0 37
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: LD_INT 0
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 0
40449: PUSH
40450: LD_INT 1
40452: NEG
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: PUSH
40461: LD_INT 0
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: LD_INT 1
40470: PUSH
40471: LD_INT 1
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: PUSH
40478: LD_INT 0
40480: PUSH
40481: LD_INT 1
40483: PUSH
40484: EMPTY
40485: LIST
40486: LIST
40487: PUSH
40488: LD_INT 1
40490: NEG
40491: PUSH
40492: LD_INT 0
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 1
40501: NEG
40502: PUSH
40503: LD_INT 1
40505: NEG
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 1
40513: PUSH
40514: LD_INT 1
40516: NEG
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 1
40524: NEG
40525: PUSH
40526: LD_INT 1
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40544: LD_ADDR_VAR 0 38
40548: PUSH
40549: LD_INT 0
40551: PUSH
40552: LD_INT 0
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: LD_INT 0
40561: PUSH
40562: LD_INT 1
40564: NEG
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 1
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 1
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 0
40592: PUSH
40593: LD_INT 1
40595: PUSH
40596: EMPTY
40597: LIST
40598: LIST
40599: PUSH
40600: LD_INT 1
40602: NEG
40603: PUSH
40604: LD_INT 0
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 1
40613: NEG
40614: PUSH
40615: LD_INT 1
40617: NEG
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 2
40625: PUSH
40626: LD_INT 1
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: PUSH
40633: LD_INT 2
40635: NEG
40636: PUSH
40637: LD_INT 1
40639: NEG
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40656: LD_ADDR_VAR 0 39
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: LD_INT 0
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 0
40673: PUSH
40674: LD_INT 1
40676: NEG
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 1
40684: PUSH
40685: LD_INT 0
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 1
40694: PUSH
40695: LD_INT 1
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 0
40704: PUSH
40705: LD_INT 1
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: PUSH
40712: LD_INT 1
40714: NEG
40715: PUSH
40716: LD_INT 0
40718: PUSH
40719: EMPTY
40720: LIST
40721: LIST
40722: PUSH
40723: LD_INT 1
40725: NEG
40726: PUSH
40727: LD_INT 1
40729: NEG
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: LD_INT 1
40737: NEG
40738: PUSH
40739: LD_INT 2
40741: NEG
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 1
40749: PUSH
40750: LD_INT 2
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: LIST
40761: LIST
40762: LIST
40763: LIST
40764: LIST
40765: LIST
40766: LIST
40767: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40768: LD_ADDR_VAR 0 40
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: LD_INT 0
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 0
40785: PUSH
40786: LD_INT 1
40788: NEG
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 1
40796: PUSH
40797: LD_INT 0
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 1
40806: PUSH
40807: LD_INT 1
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 0
40816: PUSH
40817: LD_INT 1
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 1
40826: NEG
40827: PUSH
40828: LD_INT 0
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 1
40837: NEG
40838: PUSH
40839: LD_INT 1
40841: NEG
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 1
40849: PUSH
40850: LD_INT 1
40852: NEG
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 1
40860: NEG
40861: PUSH
40862: LD_INT 1
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: LIST
40873: LIST
40874: LIST
40875: LIST
40876: LIST
40877: LIST
40878: LIST
40879: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40880: LD_ADDR_VAR 0 41
40884: PUSH
40885: LD_INT 0
40887: PUSH
40888: LD_INT 0
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 0
40897: PUSH
40898: LD_INT 1
40900: NEG
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 1
40908: PUSH
40909: LD_INT 0
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 1
40918: PUSH
40919: LD_INT 1
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 0
40928: PUSH
40929: LD_INT 1
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 1
40938: NEG
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 1
40949: NEG
40950: PUSH
40951: LD_INT 1
40953: NEG
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: LD_INT 1
40961: NEG
40962: PUSH
40963: LD_INT 2
40965: NEG
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: PUSH
40971: LD_INT 1
40973: PUSH
40974: LD_INT 1
40976: NEG
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 2
40984: PUSH
40985: LD_INT 0
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 2
40994: PUSH
40995: LD_INT 1
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 2
41004: PUSH
41005: LD_INT 2
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 1
41014: PUSH
41015: LD_INT 2
41017: PUSH
41018: EMPTY
41019: LIST
41020: LIST
41021: PUSH
41022: LD_INT 1
41024: NEG
41025: PUSH
41026: LD_INT 1
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: PUSH
41033: LD_INT 2
41035: NEG
41036: PUSH
41037: LD_INT 0
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: PUSH
41044: LD_INT 2
41046: NEG
41047: PUSH
41048: LD_INT 1
41050: NEG
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 2
41058: NEG
41059: PUSH
41060: LD_INT 2
41062: NEG
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 2
41070: NEG
41071: PUSH
41072: LD_INT 3
41074: NEG
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: LD_INT 2
41082: PUSH
41083: LD_INT 1
41085: NEG
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 3
41093: PUSH
41094: LD_INT 0
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: LD_INT 3
41103: PUSH
41104: LD_INT 1
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 3
41113: PUSH
41114: LD_INT 2
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 3
41123: PUSH
41124: LD_INT 3
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 2
41133: PUSH
41134: LD_INT 3
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 2
41143: NEG
41144: PUSH
41145: LD_INT 1
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 3
41154: NEG
41155: PUSH
41156: LD_INT 0
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 3
41165: NEG
41166: PUSH
41167: LD_INT 1
41169: NEG
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: PUSH
41175: LD_INT 3
41177: NEG
41178: PUSH
41179: LD_INT 2
41181: NEG
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 3
41189: NEG
41190: PUSH
41191: LD_INT 3
41193: NEG
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: LIST
41220: LIST
41221: LIST
41222: LIST
41223: LIST
41224: LIST
41225: LIST
41226: LIST
41227: LIST
41228: LIST
41229: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41230: LD_ADDR_VAR 0 42
41234: PUSH
41235: LD_INT 0
41237: PUSH
41238: LD_INT 0
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 0
41247: PUSH
41248: LD_INT 1
41250: NEG
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 1
41258: PUSH
41259: LD_INT 0
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 1
41268: PUSH
41269: LD_INT 1
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 0
41278: PUSH
41279: LD_INT 1
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 1
41288: NEG
41289: PUSH
41290: LD_INT 0
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 1
41299: NEG
41300: PUSH
41301: LD_INT 1
41303: NEG
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 1
41311: NEG
41312: PUSH
41313: LD_INT 2
41315: NEG
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: LD_INT 2
41326: NEG
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: PUSH
41332: LD_INT 1
41334: PUSH
41335: LD_INT 1
41337: NEG
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 2
41345: PUSH
41346: LD_INT 1
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 2
41355: PUSH
41356: LD_INT 2
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 1
41365: PUSH
41366: LD_INT 2
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 0
41375: PUSH
41376: LD_INT 2
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 1
41385: NEG
41386: PUSH
41387: LD_INT 1
41389: PUSH
41390: EMPTY
41391: LIST
41392: LIST
41393: PUSH
41394: LD_INT 2
41396: NEG
41397: PUSH
41398: LD_INT 1
41400: NEG
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 2
41408: NEG
41409: PUSH
41410: LD_INT 2
41412: NEG
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: LD_INT 2
41420: NEG
41421: PUSH
41422: LD_INT 3
41424: NEG
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 1
41432: NEG
41433: PUSH
41434: LD_INT 3
41436: NEG
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 0
41444: PUSH
41445: LD_INT 3
41447: NEG
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: LD_INT 1
41455: PUSH
41456: LD_INT 2
41458: NEG
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 3
41466: PUSH
41467: LD_INT 2
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 3
41476: PUSH
41477: LD_INT 3
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 2
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 1
41496: PUSH
41497: LD_INT 3
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 0
41506: PUSH
41507: LD_INT 3
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 1
41516: NEG
41517: PUSH
41518: LD_INT 2
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PUSH
41525: LD_INT 3
41527: NEG
41528: PUSH
41529: LD_INT 2
41531: NEG
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: LD_INT 3
41539: NEG
41540: PUSH
41541: LD_INT 3
41543: NEG
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: LIST
41570: LIST
41571: LIST
41572: LIST
41573: LIST
41574: LIST
41575: LIST
41576: LIST
41577: LIST
41578: LIST
41579: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41580: LD_ADDR_VAR 0 43
41584: PUSH
41585: LD_INT 0
41587: PUSH
41588: LD_INT 0
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 0
41597: PUSH
41598: LD_INT 1
41600: NEG
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 1
41608: PUSH
41609: LD_INT 0
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 1
41618: PUSH
41619: LD_INT 1
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 0
41628: PUSH
41629: LD_INT 1
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 1
41638: NEG
41639: PUSH
41640: LD_INT 0
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: LD_INT 1
41649: NEG
41650: PUSH
41651: LD_INT 1
41653: NEG
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 1
41661: NEG
41662: PUSH
41663: LD_INT 2
41665: NEG
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: LD_INT 0
41673: PUSH
41674: LD_INT 2
41676: NEG
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 1
41684: PUSH
41685: LD_INT 1
41687: NEG
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 2
41695: PUSH
41696: LD_INT 0
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 2
41705: PUSH
41706: LD_INT 1
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: LD_INT 1
41715: PUSH
41716: LD_INT 2
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 0
41725: PUSH
41726: LD_INT 2
41728: PUSH
41729: EMPTY
41730: LIST
41731: LIST
41732: PUSH
41733: LD_INT 1
41735: NEG
41736: PUSH
41737: LD_INT 1
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: PUSH
41744: LD_INT 2
41746: NEG
41747: PUSH
41748: LD_INT 0
41750: PUSH
41751: EMPTY
41752: LIST
41753: LIST
41754: PUSH
41755: LD_INT 2
41757: NEG
41758: PUSH
41759: LD_INT 1
41761: NEG
41762: PUSH
41763: EMPTY
41764: LIST
41765: LIST
41766: PUSH
41767: LD_INT 1
41769: NEG
41770: PUSH
41771: LD_INT 3
41773: NEG
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: PUSH
41779: LD_INT 0
41781: PUSH
41782: LD_INT 3
41784: NEG
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: LD_INT 1
41792: PUSH
41793: LD_INT 2
41795: NEG
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 2
41803: PUSH
41804: LD_INT 1
41806: NEG
41807: PUSH
41808: EMPTY
41809: LIST
41810: LIST
41811: PUSH
41812: LD_INT 3
41814: PUSH
41815: LD_INT 0
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 3
41824: PUSH
41825: LD_INT 1
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: LD_INT 1
41834: PUSH
41835: LD_INT 3
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 0
41844: PUSH
41845: LD_INT 3
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: LD_INT 1
41854: NEG
41855: PUSH
41856: LD_INT 2
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 2
41865: NEG
41866: PUSH
41867: LD_INT 1
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 3
41876: NEG
41877: PUSH
41878: LD_INT 0
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 3
41887: NEG
41888: PUSH
41889: LD_INT 1
41891: NEG
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: LIST
41903: LIST
41904: LIST
41905: LIST
41906: LIST
41907: LIST
41908: LIST
41909: LIST
41910: LIST
41911: LIST
41912: LIST
41913: LIST
41914: LIST
41915: LIST
41916: LIST
41917: LIST
41918: LIST
41919: LIST
41920: LIST
41921: LIST
41922: LIST
41923: LIST
41924: LIST
41925: LIST
41926: LIST
41927: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41928: LD_ADDR_VAR 0 44
41932: PUSH
41933: LD_INT 0
41935: PUSH
41936: LD_INT 0
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: LD_INT 0
41945: PUSH
41946: LD_INT 1
41948: NEG
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 1
41956: PUSH
41957: LD_INT 0
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 1
41966: PUSH
41967: LD_INT 1
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 0
41976: PUSH
41977: LD_INT 1
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: LD_INT 1
41986: NEG
41987: PUSH
41988: LD_INT 0
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 1
41997: NEG
41998: PUSH
41999: LD_INT 1
42001: NEG
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: PUSH
42007: LD_INT 1
42009: NEG
42010: PUSH
42011: LD_INT 2
42013: NEG
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 1
42021: PUSH
42022: LD_INT 1
42024: NEG
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 2
42032: PUSH
42033: LD_INT 0
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: LD_INT 2
42042: PUSH
42043: LD_INT 1
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 2
42052: PUSH
42053: LD_INT 2
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 1
42062: PUSH
42063: LD_INT 2
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 1
42072: NEG
42073: PUSH
42074: LD_INT 1
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 2
42083: NEG
42084: PUSH
42085: LD_INT 0
42087: PUSH
42088: EMPTY
42089: LIST
42090: LIST
42091: PUSH
42092: LD_INT 2
42094: NEG
42095: PUSH
42096: LD_INT 1
42098: NEG
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: PUSH
42104: LD_INT 2
42106: NEG
42107: PUSH
42108: LD_INT 2
42110: NEG
42111: PUSH
42112: EMPTY
42113: LIST
42114: LIST
42115: PUSH
42116: LD_INT 2
42118: NEG
42119: PUSH
42120: LD_INT 3
42122: NEG
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: PUSH
42128: LD_INT 2
42130: PUSH
42131: LD_INT 1
42133: NEG
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 3
42141: PUSH
42142: LD_INT 0
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 3
42151: PUSH
42152: LD_INT 1
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 3
42161: PUSH
42162: LD_INT 2
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: LD_INT 3
42171: PUSH
42172: LD_INT 3
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: PUSH
42182: LD_INT 3
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 2
42191: NEG
42192: PUSH
42193: LD_INT 1
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 3
42202: NEG
42203: PUSH
42204: LD_INT 0
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 3
42213: NEG
42214: PUSH
42215: LD_INT 1
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 3
42225: NEG
42226: PUSH
42227: LD_INT 2
42229: NEG
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 3
42237: NEG
42238: PUSH
42239: LD_INT 3
42241: NEG
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: LIST
42267: LIST
42268: LIST
42269: LIST
42270: LIST
42271: LIST
42272: LIST
42273: LIST
42274: LIST
42275: LIST
42276: LIST
42277: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42278: LD_ADDR_VAR 0 45
42282: PUSH
42283: LD_INT 0
42285: PUSH
42286: LD_INT 0
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 0
42295: PUSH
42296: LD_INT 1
42298: NEG
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 1
42306: PUSH
42307: LD_INT 0
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 1
42316: PUSH
42317: LD_INT 1
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: LD_INT 0
42326: PUSH
42327: LD_INT 1
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 1
42336: NEG
42337: PUSH
42338: LD_INT 0
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 1
42347: NEG
42348: PUSH
42349: LD_INT 1
42351: NEG
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 1
42359: NEG
42360: PUSH
42361: LD_INT 2
42363: NEG
42364: PUSH
42365: EMPTY
42366: LIST
42367: LIST
42368: PUSH
42369: LD_INT 0
42371: PUSH
42372: LD_INT 2
42374: NEG
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: PUSH
42380: LD_INT 1
42382: PUSH
42383: LD_INT 1
42385: NEG
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 2
42393: PUSH
42394: LD_INT 1
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 2
42403: PUSH
42404: LD_INT 2
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 1
42413: PUSH
42414: LD_INT 2
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 0
42423: PUSH
42424: LD_INT 2
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 1
42433: NEG
42434: PUSH
42435: LD_INT 1
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: LD_INT 2
42444: NEG
42445: PUSH
42446: LD_INT 1
42448: NEG
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: LD_INT 2
42456: NEG
42457: PUSH
42458: LD_INT 2
42460: NEG
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 2
42468: NEG
42469: PUSH
42470: LD_INT 3
42472: NEG
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 1
42480: NEG
42481: PUSH
42482: LD_INT 3
42484: NEG
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: PUSH
42490: LD_INT 0
42492: PUSH
42493: LD_INT 3
42495: NEG
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 1
42503: PUSH
42504: LD_INT 2
42506: NEG
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 3
42514: PUSH
42515: LD_INT 2
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 3
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 2
42534: PUSH
42535: LD_INT 3
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 1
42544: PUSH
42545: LD_INT 3
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: LD_INT 3
42557: PUSH
42558: EMPTY
42559: LIST
42560: LIST
42561: PUSH
42562: LD_INT 1
42564: NEG
42565: PUSH
42566: LD_INT 2
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 3
42575: NEG
42576: PUSH
42577: LD_INT 2
42579: NEG
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 3
42587: NEG
42588: PUSH
42589: LD_INT 3
42591: NEG
42592: PUSH
42593: EMPTY
42594: LIST
42595: LIST
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42628: LD_ADDR_VAR 0 46
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: LD_INT 0
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: LD_INT 0
42645: PUSH
42646: LD_INT 1
42648: NEG
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 1
42656: PUSH
42657: LD_INT 0
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 1
42666: PUSH
42667: LD_INT 1
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: LD_INT 0
42676: PUSH
42677: LD_INT 1
42679: PUSH
42680: EMPTY
42681: LIST
42682: LIST
42683: PUSH
42684: LD_INT 1
42686: NEG
42687: PUSH
42688: LD_INT 0
42690: PUSH
42691: EMPTY
42692: LIST
42693: LIST
42694: PUSH
42695: LD_INT 1
42697: NEG
42698: PUSH
42699: LD_INT 1
42701: NEG
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: PUSH
42707: LD_INT 1
42709: NEG
42710: PUSH
42711: LD_INT 2
42713: NEG
42714: PUSH
42715: EMPTY
42716: LIST
42717: LIST
42718: PUSH
42719: LD_INT 0
42721: PUSH
42722: LD_INT 2
42724: NEG
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 1
42732: PUSH
42733: LD_INT 1
42735: NEG
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 2
42743: PUSH
42744: LD_INT 0
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 2
42753: PUSH
42754: LD_INT 1
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PUSH
42761: LD_INT 1
42763: PUSH
42764: LD_INT 2
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 0
42773: PUSH
42774: LD_INT 2
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PUSH
42781: LD_INT 1
42783: NEG
42784: PUSH
42785: LD_INT 1
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 2
42794: NEG
42795: PUSH
42796: LD_INT 0
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 2
42805: NEG
42806: PUSH
42807: LD_INT 1
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 1
42817: NEG
42818: PUSH
42819: LD_INT 3
42821: NEG
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 0
42829: PUSH
42830: LD_INT 3
42832: NEG
42833: PUSH
42834: EMPTY
42835: LIST
42836: LIST
42837: PUSH
42838: LD_INT 1
42840: PUSH
42841: LD_INT 2
42843: NEG
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 2
42851: PUSH
42852: LD_INT 1
42854: NEG
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: LD_INT 3
42862: PUSH
42863: LD_INT 0
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 3
42872: PUSH
42873: LD_INT 1
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 1
42882: PUSH
42883: LD_INT 3
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 0
42892: PUSH
42893: LD_INT 3
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: PUSH
42900: LD_INT 1
42902: NEG
42903: PUSH
42904: LD_INT 2
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 2
42913: NEG
42914: PUSH
42915: LD_INT 1
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: LD_INT 3
42924: NEG
42925: PUSH
42926: LD_INT 0
42928: PUSH
42929: EMPTY
42930: LIST
42931: LIST
42932: PUSH
42933: LD_INT 3
42935: NEG
42936: PUSH
42937: LD_INT 1
42939: NEG
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: LIST
42953: LIST
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: LIST
42966: LIST
42967: LIST
42968: LIST
42969: LIST
42970: LIST
42971: LIST
42972: LIST
42973: LIST
42974: LIST
42975: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42976: LD_ADDR_VAR 0 47
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: LD_INT 0
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 0
42993: PUSH
42994: LD_INT 1
42996: NEG
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_INT 1
43004: PUSH
43005: LD_INT 0
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: PUSH
43012: LD_INT 1
43014: PUSH
43015: LD_INT 1
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 0
43024: PUSH
43025: LD_INT 1
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: PUSH
43032: LD_INT 1
43034: NEG
43035: PUSH
43036: LD_INT 0
43038: PUSH
43039: EMPTY
43040: LIST
43041: LIST
43042: PUSH
43043: LD_INT 1
43045: NEG
43046: PUSH
43047: LD_INT 1
43049: NEG
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: LD_INT 1
43057: NEG
43058: PUSH
43059: LD_INT 2
43061: NEG
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: LD_INT 0
43069: PUSH
43070: LD_INT 2
43072: NEG
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: LD_INT 1
43080: PUSH
43081: LD_INT 1
43083: NEG
43084: PUSH
43085: EMPTY
43086: LIST
43087: LIST
43088: PUSH
43089: LD_INT 2
43091: NEG
43092: PUSH
43093: LD_INT 1
43095: NEG
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 2
43103: NEG
43104: PUSH
43105: LD_INT 2
43107: NEG
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: LIST
43117: LIST
43118: LIST
43119: LIST
43120: LIST
43121: LIST
43122: LIST
43123: LIST
43124: LIST
43125: LIST
43126: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43127: LD_ADDR_VAR 0 48
43131: PUSH
43132: LD_INT 0
43134: PUSH
43135: LD_INT 0
43137: PUSH
43138: EMPTY
43139: LIST
43140: LIST
43141: PUSH
43142: LD_INT 0
43144: PUSH
43145: LD_INT 1
43147: NEG
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 1
43155: PUSH
43156: LD_INT 0
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 1
43165: PUSH
43166: LD_INT 1
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: LD_INT 0
43175: PUSH
43176: LD_INT 1
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: PUSH
43183: LD_INT 1
43185: NEG
43186: PUSH
43187: LD_INT 0
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: LD_INT 1
43196: NEG
43197: PUSH
43198: LD_INT 1
43200: NEG
43201: PUSH
43202: EMPTY
43203: LIST
43204: LIST
43205: PUSH
43206: LD_INT 1
43208: NEG
43209: PUSH
43210: LD_INT 2
43212: NEG
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: LD_INT 0
43220: PUSH
43221: LD_INT 2
43223: NEG
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: LD_INT 1
43231: PUSH
43232: LD_INT 1
43234: NEG
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: LD_INT 2
43242: PUSH
43243: LD_INT 0
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: LD_INT 2
43252: PUSH
43253: LD_INT 1
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: EMPTY
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43274: LD_ADDR_VAR 0 49
43278: PUSH
43279: LD_INT 0
43281: PUSH
43282: LD_INT 0
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 0
43291: PUSH
43292: LD_INT 1
43294: NEG
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: LD_INT 0
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 1
43312: PUSH
43313: LD_INT 1
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 0
43322: PUSH
43323: LD_INT 1
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: NEG
43333: PUSH
43334: LD_INT 0
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: NEG
43344: PUSH
43345: LD_INT 1
43347: NEG
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: LD_INT 1
43355: PUSH
43356: LD_INT 1
43358: NEG
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: LD_INT 0
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 2
43376: PUSH
43377: LD_INT 1
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 2
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: LD_INT 1
43396: PUSH
43397: LD_INT 2
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: LIST
43408: LIST
43409: LIST
43410: LIST
43411: LIST
43412: LIST
43413: LIST
43414: LIST
43415: LIST
43416: LIST
43417: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43418: LD_ADDR_VAR 0 50
43422: PUSH
43423: LD_INT 0
43425: PUSH
43426: LD_INT 0
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: LD_INT 0
43435: PUSH
43436: LD_INT 1
43438: NEG
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: LD_INT 0
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 1
43456: PUSH
43457: LD_INT 1
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 0
43466: PUSH
43467: LD_INT 1
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: PUSH
43474: LD_INT 1
43476: NEG
43477: PUSH
43478: LD_INT 0
43480: PUSH
43481: EMPTY
43482: LIST
43483: LIST
43484: PUSH
43485: LD_INT 1
43487: NEG
43488: PUSH
43489: LD_INT 1
43491: NEG
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 2
43499: PUSH
43500: LD_INT 1
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 2
43509: PUSH
43510: LD_INT 2
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: LD_INT 1
43519: PUSH
43520: LD_INT 2
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 0
43529: PUSH
43530: LD_INT 2
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 1
43539: NEG
43540: PUSH
43541: LD_INT 1
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: LIST
43552: LIST
43553: LIST
43554: LIST
43555: LIST
43556: LIST
43557: LIST
43558: LIST
43559: LIST
43560: LIST
43561: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43562: LD_ADDR_VAR 0 51
43566: PUSH
43567: LD_INT 0
43569: PUSH
43570: LD_INT 0
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: PUSH
43577: LD_INT 0
43579: PUSH
43580: LD_INT 1
43582: NEG
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 1
43590: PUSH
43591: LD_INT 0
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: LD_INT 1
43600: PUSH
43601: LD_INT 1
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: PUSH
43608: LD_INT 0
43610: PUSH
43611: LD_INT 1
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 1
43620: NEG
43621: PUSH
43622: LD_INT 0
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: LD_INT 1
43631: NEG
43632: PUSH
43633: LD_INT 1
43635: NEG
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 1
43643: PUSH
43644: LD_INT 2
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 0
43653: PUSH
43654: LD_INT 2
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 1
43663: NEG
43664: PUSH
43665: LD_INT 1
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PUSH
43672: LD_INT 2
43674: NEG
43675: PUSH
43676: LD_INT 0
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 2
43685: NEG
43686: PUSH
43687: LD_INT 1
43689: NEG
43690: PUSH
43691: EMPTY
43692: LIST
43693: LIST
43694: PUSH
43695: EMPTY
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43709: LD_ADDR_VAR 0 52
43713: PUSH
43714: LD_INT 0
43716: PUSH
43717: LD_INT 0
43719: PUSH
43720: EMPTY
43721: LIST
43722: LIST
43723: PUSH
43724: LD_INT 0
43726: PUSH
43727: LD_INT 1
43729: NEG
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 1
43737: PUSH
43738: LD_INT 0
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 1
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 0
43757: PUSH
43758: LD_INT 1
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 1
43767: NEG
43768: PUSH
43769: LD_INT 0
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 1
43778: NEG
43779: PUSH
43780: LD_INT 1
43782: NEG
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: LD_INT 1
43790: NEG
43791: PUSH
43792: LD_INT 2
43794: NEG
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: PUSH
43800: LD_INT 1
43802: NEG
43803: PUSH
43804: LD_INT 1
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 2
43813: NEG
43814: PUSH
43815: LD_INT 0
43817: PUSH
43818: EMPTY
43819: LIST
43820: LIST
43821: PUSH
43822: LD_INT 2
43824: NEG
43825: PUSH
43826: LD_INT 1
43828: NEG
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 2
43836: NEG
43837: PUSH
43838: LD_INT 2
43840: NEG
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: EMPTY
43847: LIST
43848: LIST
43849: LIST
43850: LIST
43851: LIST
43852: LIST
43853: LIST
43854: LIST
43855: LIST
43856: LIST
43857: LIST
43858: LIST
43859: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43860: LD_ADDR_VAR 0 53
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 0
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: PUSH
43875: LD_INT 0
43877: PUSH
43878: LD_INT 1
43880: NEG
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: LD_INT 0
43891: PUSH
43892: EMPTY
43893: LIST
43894: LIST
43895: PUSH
43896: LD_INT 1
43898: PUSH
43899: LD_INT 1
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 0
43908: PUSH
43909: LD_INT 1
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 1
43918: NEG
43919: PUSH
43920: LD_INT 0
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 1
43929: NEG
43930: PUSH
43931: LD_INT 1
43933: NEG
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 1
43941: NEG
43942: PUSH
43943: LD_INT 2
43945: NEG
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 0
43953: PUSH
43954: LD_INT 2
43956: NEG
43957: PUSH
43958: EMPTY
43959: LIST
43960: LIST
43961: PUSH
43962: LD_INT 1
43964: PUSH
43965: LD_INT 1
43967: NEG
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 2
43975: PUSH
43976: LD_INT 0
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 2
43985: PUSH
43986: LD_INT 1
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PUSH
43993: LD_INT 2
43995: PUSH
43996: LD_INT 2
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 1
44005: PUSH
44006: LD_INT 2
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 0
44015: PUSH
44016: LD_INT 2
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: PUSH
44023: LD_INT 1
44025: NEG
44026: PUSH
44027: LD_INT 1
44029: PUSH
44030: EMPTY
44031: LIST
44032: LIST
44033: PUSH
44034: LD_INT 2
44036: NEG
44037: PUSH
44038: LD_INT 0
44040: PUSH
44041: EMPTY
44042: LIST
44043: LIST
44044: PUSH
44045: LD_INT 2
44047: NEG
44048: PUSH
44049: LD_INT 1
44051: NEG
44052: PUSH
44053: EMPTY
44054: LIST
44055: LIST
44056: PUSH
44057: LD_INT 2
44059: NEG
44060: PUSH
44061: LD_INT 2
44063: NEG
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44090: LD_ADDR_VAR 0 54
44094: PUSH
44095: LD_INT 0
44097: PUSH
44098: LD_INT 0
44100: PUSH
44101: EMPTY
44102: LIST
44103: LIST
44104: PUSH
44105: LD_INT 0
44107: PUSH
44108: LD_INT 1
44110: NEG
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_INT 1
44118: PUSH
44119: LD_INT 0
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 1
44128: PUSH
44129: LD_INT 1
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 0
44138: PUSH
44139: LD_INT 1
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 1
44148: NEG
44149: PUSH
44150: LD_INT 0
44152: PUSH
44153: EMPTY
44154: LIST
44155: LIST
44156: PUSH
44157: LD_INT 1
44159: NEG
44160: PUSH
44161: LD_INT 1
44163: NEG
44164: PUSH
44165: EMPTY
44166: LIST
44167: LIST
44168: PUSH
44169: LD_INT 1
44171: NEG
44172: PUSH
44173: LD_INT 2
44175: NEG
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 0
44183: PUSH
44184: LD_INT 2
44186: NEG
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 1
44194: PUSH
44195: LD_INT 1
44197: NEG
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: PUSH
44206: LD_INT 0
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 2
44215: PUSH
44216: LD_INT 1
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 2
44225: PUSH
44226: LD_INT 2
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 1
44235: PUSH
44236: LD_INT 2
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 0
44245: PUSH
44246: LD_INT 2
44248: PUSH
44249: EMPTY
44250: LIST
44251: LIST
44252: PUSH
44253: LD_INT 1
44255: NEG
44256: PUSH
44257: LD_INT 1
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 2
44266: NEG
44267: PUSH
44268: LD_INT 0
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 2
44277: NEG
44278: PUSH
44279: LD_INT 1
44281: NEG
44282: PUSH
44283: EMPTY
44284: LIST
44285: LIST
44286: PUSH
44287: LD_INT 2
44289: NEG
44290: PUSH
44291: LD_INT 2
44293: NEG
44294: PUSH
44295: EMPTY
44296: LIST
44297: LIST
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: LIST
44309: LIST
44310: LIST
44311: LIST
44312: LIST
44313: LIST
44314: LIST
44315: LIST
44316: LIST
44317: LIST
44318: LIST
44319: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44320: LD_ADDR_VAR 0 55
44324: PUSH
44325: LD_INT 0
44327: PUSH
44328: LD_INT 0
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 0
44337: PUSH
44338: LD_INT 1
44340: NEG
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: LD_INT 0
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 1
44358: PUSH
44359: LD_INT 1
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: LD_INT 1
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: PUSH
44376: LD_INT 1
44378: NEG
44379: PUSH
44380: LD_INT 0
44382: PUSH
44383: EMPTY
44384: LIST
44385: LIST
44386: PUSH
44387: LD_INT 1
44389: NEG
44390: PUSH
44391: LD_INT 1
44393: NEG
44394: PUSH
44395: EMPTY
44396: LIST
44397: LIST
44398: PUSH
44399: LD_INT 1
44401: NEG
44402: PUSH
44403: LD_INT 2
44405: NEG
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: LD_INT 0
44413: PUSH
44414: LD_INT 2
44416: NEG
44417: PUSH
44418: EMPTY
44419: LIST
44420: LIST
44421: PUSH
44422: LD_INT 1
44424: PUSH
44425: LD_INT 1
44427: NEG
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 2
44435: PUSH
44436: LD_INT 0
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 2
44445: PUSH
44446: LD_INT 1
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 2
44455: PUSH
44456: LD_INT 2
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 1
44465: PUSH
44466: LD_INT 2
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 0
44475: PUSH
44476: LD_INT 2
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 1
44485: NEG
44486: PUSH
44487: LD_INT 1
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: LD_INT 2
44496: NEG
44497: PUSH
44498: LD_INT 0
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: LD_INT 2
44507: NEG
44508: PUSH
44509: LD_INT 1
44511: NEG
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: LD_INT 2
44519: NEG
44520: PUSH
44521: LD_INT 2
44523: NEG
44524: PUSH
44525: EMPTY
44526: LIST
44527: LIST
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: LIST
44548: LIST
44549: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44550: LD_ADDR_VAR 0 56
44554: PUSH
44555: LD_INT 0
44557: PUSH
44558: LD_INT 0
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: LD_INT 0
44567: PUSH
44568: LD_INT 1
44570: NEG
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 1
44578: PUSH
44579: LD_INT 0
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 1
44588: PUSH
44589: LD_INT 1
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 0
44598: PUSH
44599: LD_INT 1
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 1
44608: NEG
44609: PUSH
44610: LD_INT 0
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 1
44619: NEG
44620: PUSH
44621: LD_INT 1
44623: NEG
44624: PUSH
44625: EMPTY
44626: LIST
44627: LIST
44628: PUSH
44629: LD_INT 1
44631: NEG
44632: PUSH
44633: LD_INT 2
44635: NEG
44636: PUSH
44637: EMPTY
44638: LIST
44639: LIST
44640: PUSH
44641: LD_INT 0
44643: PUSH
44644: LD_INT 2
44646: NEG
44647: PUSH
44648: EMPTY
44649: LIST
44650: LIST
44651: PUSH
44652: LD_INT 1
44654: PUSH
44655: LD_INT 1
44657: NEG
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: PUSH
44663: LD_INT 2
44665: PUSH
44666: LD_INT 0
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 2
44675: PUSH
44676: LD_INT 1
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 2
44685: PUSH
44686: LD_INT 2
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: LD_INT 1
44695: PUSH
44696: LD_INT 2
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 0
44705: PUSH
44706: LD_INT 2
44708: PUSH
44709: EMPTY
44710: LIST
44711: LIST
44712: PUSH
44713: LD_INT 1
44715: NEG
44716: PUSH
44717: LD_INT 1
44719: PUSH
44720: EMPTY
44721: LIST
44722: LIST
44723: PUSH
44724: LD_INT 2
44726: NEG
44727: PUSH
44728: LD_INT 0
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 2
44737: NEG
44738: PUSH
44739: LD_INT 1
44741: NEG
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: PUSH
44747: LD_INT 2
44749: NEG
44750: PUSH
44751: LD_INT 2
44753: NEG
44754: PUSH
44755: EMPTY
44756: LIST
44757: LIST
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44780: LD_ADDR_VAR 0 57
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: LD_INT 0
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: PUSH
44795: LD_INT 0
44797: PUSH
44798: LD_INT 1
44800: NEG
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 1
44808: PUSH
44809: LD_INT 0
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: PUSH
44816: LD_INT 1
44818: PUSH
44819: LD_INT 1
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 0
44828: PUSH
44829: LD_INT 1
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PUSH
44836: LD_INT 1
44838: NEG
44839: PUSH
44840: LD_INT 0
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PUSH
44847: LD_INT 1
44849: NEG
44850: PUSH
44851: LD_INT 1
44853: NEG
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: PUSH
44859: LD_INT 1
44861: NEG
44862: PUSH
44863: LD_INT 2
44865: NEG
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 0
44873: PUSH
44874: LD_INT 2
44876: NEG
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: LD_INT 1
44884: PUSH
44885: LD_INT 1
44887: NEG
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 2
44895: PUSH
44896: LD_INT 0
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 2
44905: PUSH
44906: LD_INT 1
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 2
44915: PUSH
44916: LD_INT 2
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 1
44925: PUSH
44926: LD_INT 2
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 0
44935: PUSH
44936: LD_INT 2
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: LD_INT 1
44945: NEG
44946: PUSH
44947: LD_INT 1
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 2
44956: NEG
44957: PUSH
44958: LD_INT 0
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 2
44967: NEG
44968: PUSH
44969: LD_INT 1
44971: NEG
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: PUSH
44977: LD_INT 2
44979: NEG
44980: PUSH
44981: LD_INT 2
44983: NEG
44984: PUSH
44985: EMPTY
44986: LIST
44987: LIST
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: LIST
45000: LIST
45001: LIST
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: LIST
45008: LIST
45009: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45010: LD_ADDR_VAR 0 58
45014: PUSH
45015: LD_INT 0
45017: PUSH
45018: LD_INT 0
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: PUSH
45025: LD_INT 0
45027: PUSH
45028: LD_INT 1
45030: NEG
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 0
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 1
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 0
45058: PUSH
45059: LD_INT 1
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 1
45068: NEG
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 1
45079: NEG
45080: PUSH
45081: LD_INT 1
45083: NEG
45084: PUSH
45085: EMPTY
45086: LIST
45087: LIST
45088: PUSH
45089: LD_INT 1
45091: NEG
45092: PUSH
45093: LD_INT 2
45095: NEG
45096: PUSH
45097: EMPTY
45098: LIST
45099: LIST
45100: PUSH
45101: LD_INT 0
45103: PUSH
45104: LD_INT 2
45106: NEG
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: PUSH
45112: LD_INT 1
45114: PUSH
45115: LD_INT 1
45117: NEG
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: PUSH
45123: LD_INT 2
45125: PUSH
45126: LD_INT 0
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 2
45135: PUSH
45136: LD_INT 1
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 2
45145: PUSH
45146: LD_INT 2
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 1
45155: PUSH
45156: LD_INT 2
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 0
45165: PUSH
45166: LD_INT 2
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: PUSH
45173: LD_INT 1
45175: NEG
45176: PUSH
45177: LD_INT 1
45179: PUSH
45180: EMPTY
45181: LIST
45182: LIST
45183: PUSH
45184: LD_INT 2
45186: NEG
45187: PUSH
45188: LD_INT 0
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PUSH
45195: LD_INT 2
45197: NEG
45198: PUSH
45199: LD_INT 1
45201: NEG
45202: PUSH
45203: EMPTY
45204: LIST
45205: LIST
45206: PUSH
45207: LD_INT 2
45209: NEG
45210: PUSH
45211: LD_INT 2
45213: NEG
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: EMPTY
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: LIST
45230: LIST
45231: LIST
45232: LIST
45233: LIST
45234: LIST
45235: LIST
45236: LIST
45237: LIST
45238: LIST
45239: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45240: LD_ADDR_VAR 0 59
45244: PUSH
45245: LD_INT 0
45247: PUSH
45248: LD_INT 0
45250: PUSH
45251: EMPTY
45252: LIST
45253: LIST
45254: PUSH
45255: LD_INT 0
45257: PUSH
45258: LD_INT 1
45260: NEG
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: PUSH
45266: LD_INT 1
45268: PUSH
45269: LD_INT 0
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 1
45278: PUSH
45279: LD_INT 1
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 0
45288: PUSH
45289: LD_INT 1
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: PUSH
45296: LD_INT 1
45298: NEG
45299: PUSH
45300: LD_INT 0
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 1
45309: NEG
45310: PUSH
45311: LD_INT 1
45313: NEG
45314: PUSH
45315: EMPTY
45316: LIST
45317: LIST
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45328: LD_ADDR_VAR 0 60
45332: PUSH
45333: LD_INT 0
45335: PUSH
45336: LD_INT 0
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PUSH
45343: LD_INT 0
45345: PUSH
45346: LD_INT 1
45348: NEG
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 1
45356: PUSH
45357: LD_INT 0
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 1
45366: PUSH
45367: LD_INT 1
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 0
45376: PUSH
45377: LD_INT 1
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: PUSH
45384: LD_INT 1
45386: NEG
45387: PUSH
45388: LD_INT 0
45390: PUSH
45391: EMPTY
45392: LIST
45393: LIST
45394: PUSH
45395: LD_INT 1
45397: NEG
45398: PUSH
45399: LD_INT 1
45401: NEG
45402: PUSH
45403: EMPTY
45404: LIST
45405: LIST
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: LIST
45415: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45416: LD_ADDR_VAR 0 61
45420: PUSH
45421: LD_INT 0
45423: PUSH
45424: LD_INT 0
45426: PUSH
45427: EMPTY
45428: LIST
45429: LIST
45430: PUSH
45431: LD_INT 0
45433: PUSH
45434: LD_INT 1
45436: NEG
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: LD_INT 1
45444: PUSH
45445: LD_INT 0
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 1
45454: PUSH
45455: LD_INT 1
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 0
45464: PUSH
45465: LD_INT 1
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: PUSH
45472: LD_INT 1
45474: NEG
45475: PUSH
45476: LD_INT 0
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 1
45485: NEG
45486: PUSH
45487: LD_INT 1
45489: NEG
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45504: LD_ADDR_VAR 0 62
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: LD_INT 0
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 0
45521: PUSH
45522: LD_INT 1
45524: NEG
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 1
45532: PUSH
45533: LD_INT 0
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 1
45542: PUSH
45543: LD_INT 1
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 0
45552: PUSH
45553: LD_INT 1
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: PUSH
45560: LD_INT 1
45562: NEG
45563: PUSH
45564: LD_INT 0
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 1
45573: NEG
45574: PUSH
45575: LD_INT 1
45577: NEG
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45592: LD_ADDR_VAR 0 63
45596: PUSH
45597: LD_INT 0
45599: PUSH
45600: LD_INT 0
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: PUSH
45607: LD_INT 0
45609: PUSH
45610: LD_INT 1
45612: NEG
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: PUSH
45618: LD_INT 1
45620: PUSH
45621: LD_INT 0
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 1
45630: PUSH
45631: LD_INT 1
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: PUSH
45638: LD_INT 0
45640: PUSH
45641: LD_INT 1
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: PUSH
45648: LD_INT 1
45650: NEG
45651: PUSH
45652: LD_INT 0
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 1
45661: NEG
45662: PUSH
45663: LD_INT 1
45665: NEG
45666: PUSH
45667: EMPTY
45668: LIST
45669: LIST
45670: PUSH
45671: EMPTY
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45680: LD_ADDR_VAR 0 64
45684: PUSH
45685: LD_INT 0
45687: PUSH
45688: LD_INT 0
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PUSH
45695: LD_INT 0
45697: PUSH
45698: LD_INT 1
45700: NEG
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 1
45708: PUSH
45709: LD_INT 0
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 1
45718: PUSH
45719: LD_INT 1
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 0
45728: PUSH
45729: LD_INT 1
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 1
45738: NEG
45739: PUSH
45740: LD_INT 0
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: LD_INT 1
45749: NEG
45750: PUSH
45751: LD_INT 1
45753: NEG
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: PUSH
45759: EMPTY
45760: LIST
45761: LIST
45762: LIST
45763: LIST
45764: LIST
45765: LIST
45766: LIST
45767: ST_TO_ADDR
// end ; 1 :
45768: GO 51665
45770: LD_INT 1
45772: DOUBLE
45773: EQUAL
45774: IFTRUE 45778
45776: GO 48401
45778: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45779: LD_ADDR_VAR 0 11
45783: PUSH
45784: LD_INT 1
45786: NEG
45787: PUSH
45788: LD_INT 3
45790: NEG
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 0
45798: PUSH
45799: LD_INT 3
45801: NEG
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 1
45809: PUSH
45810: LD_INT 2
45812: NEG
45813: PUSH
45814: EMPTY
45815: LIST
45816: LIST
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: LIST
45822: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45823: LD_ADDR_VAR 0 12
45827: PUSH
45828: LD_INT 2
45830: PUSH
45831: LD_INT 1
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 3
45841: PUSH
45842: LD_INT 0
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 3
45851: PUSH
45852: LD_INT 1
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: EMPTY
45860: LIST
45861: LIST
45862: LIST
45863: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45864: LD_ADDR_VAR 0 13
45868: PUSH
45869: LD_INT 3
45871: PUSH
45872: LD_INT 2
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 3
45881: PUSH
45882: LD_INT 3
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: LD_INT 2
45891: PUSH
45892: LD_INT 3
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: LIST
45903: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45904: LD_ADDR_VAR 0 14
45908: PUSH
45909: LD_INT 1
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 0
45921: PUSH
45922: LD_INT 3
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 1
45931: NEG
45932: PUSH
45933: LD_INT 2
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: LIST
45944: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45945: LD_ADDR_VAR 0 15
45949: PUSH
45950: LD_INT 2
45952: NEG
45953: PUSH
45954: LD_INT 1
45956: PUSH
45957: EMPTY
45958: LIST
45959: LIST
45960: PUSH
45961: LD_INT 3
45963: NEG
45964: PUSH
45965: LD_INT 0
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: PUSH
45972: LD_INT 3
45974: NEG
45975: PUSH
45976: LD_INT 1
45978: NEG
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: LIST
45988: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45989: LD_ADDR_VAR 0 16
45993: PUSH
45994: LD_INT 2
45996: NEG
45997: PUSH
45998: LD_INT 3
46000: NEG
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 3
46008: NEG
46009: PUSH
46010: LD_INT 2
46012: NEG
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: LD_INT 3
46020: NEG
46021: PUSH
46022: LD_INT 3
46024: NEG
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: LIST
46034: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46035: LD_ADDR_VAR 0 17
46039: PUSH
46040: LD_INT 1
46042: NEG
46043: PUSH
46044: LD_INT 3
46046: NEG
46047: PUSH
46048: EMPTY
46049: LIST
46050: LIST
46051: PUSH
46052: LD_INT 0
46054: PUSH
46055: LD_INT 3
46057: NEG
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: PUSH
46063: LD_INT 1
46065: PUSH
46066: LD_INT 2
46068: NEG
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: LIST
46078: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46079: LD_ADDR_VAR 0 18
46083: PUSH
46084: LD_INT 2
46086: PUSH
46087: LD_INT 1
46089: NEG
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 3
46097: PUSH
46098: LD_INT 0
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: LD_INT 3
46107: PUSH
46108: LD_INT 1
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: EMPTY
46116: LIST
46117: LIST
46118: LIST
46119: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46120: LD_ADDR_VAR 0 19
46124: PUSH
46125: LD_INT 3
46127: PUSH
46128: LD_INT 2
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 3
46137: PUSH
46138: LD_INT 3
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: LD_INT 2
46147: PUSH
46148: LD_INT 3
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: LIST
46159: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46160: LD_ADDR_VAR 0 20
46164: PUSH
46165: LD_INT 1
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: PUSH
46175: LD_INT 0
46177: PUSH
46178: LD_INT 3
46180: PUSH
46181: EMPTY
46182: LIST
46183: LIST
46184: PUSH
46185: LD_INT 1
46187: NEG
46188: PUSH
46189: LD_INT 2
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: PUSH
46196: EMPTY
46197: LIST
46198: LIST
46199: LIST
46200: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46201: LD_ADDR_VAR 0 21
46205: PUSH
46206: LD_INT 2
46208: NEG
46209: PUSH
46210: LD_INT 1
46212: PUSH
46213: EMPTY
46214: LIST
46215: LIST
46216: PUSH
46217: LD_INT 3
46219: NEG
46220: PUSH
46221: LD_INT 0
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: PUSH
46228: LD_INT 3
46230: NEG
46231: PUSH
46232: LD_INT 1
46234: NEG
46235: PUSH
46236: EMPTY
46237: LIST
46238: LIST
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: LIST
46244: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46245: LD_ADDR_VAR 0 22
46249: PUSH
46250: LD_INT 2
46252: NEG
46253: PUSH
46254: LD_INT 3
46256: NEG
46257: PUSH
46258: EMPTY
46259: LIST
46260: LIST
46261: PUSH
46262: LD_INT 3
46264: NEG
46265: PUSH
46266: LD_INT 2
46268: NEG
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 3
46276: NEG
46277: PUSH
46278: LD_INT 3
46280: NEG
46281: PUSH
46282: EMPTY
46283: LIST
46284: LIST
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: LIST
46290: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46291: LD_ADDR_VAR 0 23
46295: PUSH
46296: LD_INT 0
46298: PUSH
46299: LD_INT 3
46301: NEG
46302: PUSH
46303: EMPTY
46304: LIST
46305: LIST
46306: PUSH
46307: LD_INT 1
46309: NEG
46310: PUSH
46311: LD_INT 4
46313: NEG
46314: PUSH
46315: EMPTY
46316: LIST
46317: LIST
46318: PUSH
46319: LD_INT 1
46321: PUSH
46322: LD_INT 3
46324: NEG
46325: PUSH
46326: EMPTY
46327: LIST
46328: LIST
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: LIST
46334: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46335: LD_ADDR_VAR 0 24
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: LD_INT 0
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 3
46352: PUSH
46353: LD_INT 1
46355: NEG
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 4
46363: PUSH
46364: LD_INT 1
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: EMPTY
46372: LIST
46373: LIST
46374: LIST
46375: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46376: LD_ADDR_VAR 0 25
46380: PUSH
46381: LD_INT 3
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 4
46393: PUSH
46394: LD_INT 3
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 3
46403: PUSH
46404: LD_INT 4
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: PUSH
46411: EMPTY
46412: LIST
46413: LIST
46414: LIST
46415: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46416: LD_ADDR_VAR 0 26
46420: PUSH
46421: LD_INT 0
46423: PUSH
46424: LD_INT 3
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 1
46433: PUSH
46434: LD_INT 4
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 1
46443: NEG
46444: PUSH
46445: LD_INT 3
46447: PUSH
46448: EMPTY
46449: LIST
46450: LIST
46451: PUSH
46452: EMPTY
46453: LIST
46454: LIST
46455: LIST
46456: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46457: LD_ADDR_VAR 0 27
46461: PUSH
46462: LD_INT 3
46464: NEG
46465: PUSH
46466: LD_INT 0
46468: PUSH
46469: EMPTY
46470: LIST
46471: LIST
46472: PUSH
46473: LD_INT 3
46475: NEG
46476: PUSH
46477: LD_INT 1
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: LD_INT 4
46486: NEG
46487: PUSH
46488: LD_INT 1
46490: NEG
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: LIST
46500: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46501: LD_ADDR_VAR 0 28
46505: PUSH
46506: LD_INT 3
46508: NEG
46509: PUSH
46510: LD_INT 3
46512: NEG
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 3
46520: NEG
46521: PUSH
46522: LD_INT 4
46524: NEG
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: PUSH
46530: LD_INT 4
46532: NEG
46533: PUSH
46534: LD_INT 3
46536: NEG
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: PUSH
46542: EMPTY
46543: LIST
46544: LIST
46545: LIST
46546: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46547: LD_ADDR_VAR 0 29
46551: PUSH
46552: LD_INT 1
46554: NEG
46555: PUSH
46556: LD_INT 3
46558: NEG
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PUSH
46564: LD_INT 0
46566: PUSH
46567: LD_INT 3
46569: NEG
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 1
46577: PUSH
46578: LD_INT 2
46580: NEG
46581: PUSH
46582: EMPTY
46583: LIST
46584: LIST
46585: PUSH
46586: LD_INT 1
46588: NEG
46589: PUSH
46590: LD_INT 4
46592: NEG
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: LD_INT 0
46600: PUSH
46601: LD_INT 4
46603: NEG
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: LD_INT 1
46611: PUSH
46612: LD_INT 3
46614: NEG
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_INT 1
46622: NEG
46623: PUSH
46624: LD_INT 5
46626: NEG
46627: PUSH
46628: EMPTY
46629: LIST
46630: LIST
46631: PUSH
46632: LD_INT 0
46634: PUSH
46635: LD_INT 5
46637: NEG
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 1
46645: PUSH
46646: LD_INT 4
46648: NEG
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: PUSH
46654: LD_INT 1
46656: NEG
46657: PUSH
46658: LD_INT 6
46660: NEG
46661: PUSH
46662: EMPTY
46663: LIST
46664: LIST
46665: PUSH
46666: LD_INT 0
46668: PUSH
46669: LD_INT 6
46671: NEG
46672: PUSH
46673: EMPTY
46674: LIST
46675: LIST
46676: PUSH
46677: LD_INT 1
46679: PUSH
46680: LD_INT 5
46682: NEG
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: EMPTY
46689: LIST
46690: LIST
46691: LIST
46692: LIST
46693: LIST
46694: LIST
46695: LIST
46696: LIST
46697: LIST
46698: LIST
46699: LIST
46700: LIST
46701: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46702: LD_ADDR_VAR 0 30
46706: PUSH
46707: LD_INT 2
46709: PUSH
46710: LD_INT 1
46712: NEG
46713: PUSH
46714: EMPTY
46715: LIST
46716: LIST
46717: PUSH
46718: LD_INT 3
46720: PUSH
46721: LD_INT 0
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: LD_INT 3
46730: PUSH
46731: LD_INT 1
46733: PUSH
46734: EMPTY
46735: LIST
46736: LIST
46737: PUSH
46738: LD_INT 3
46740: PUSH
46741: LD_INT 1
46743: NEG
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: LD_INT 4
46751: PUSH
46752: LD_INT 0
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: PUSH
46759: LD_INT 4
46761: PUSH
46762: LD_INT 1
46764: PUSH
46765: EMPTY
46766: LIST
46767: LIST
46768: PUSH
46769: LD_INT 4
46771: PUSH
46772: LD_INT 1
46774: NEG
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 5
46782: PUSH
46783: LD_INT 0
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: LD_INT 5
46792: PUSH
46793: LD_INT 1
46795: PUSH
46796: EMPTY
46797: LIST
46798: LIST
46799: PUSH
46800: LD_INT 5
46802: PUSH
46803: LD_INT 1
46805: NEG
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 6
46813: PUSH
46814: LD_INT 0
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: LD_INT 6
46823: PUSH
46824: LD_INT 1
46826: PUSH
46827: EMPTY
46828: LIST
46829: LIST
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46845: LD_ADDR_VAR 0 31
46849: PUSH
46850: LD_INT 3
46852: PUSH
46853: LD_INT 2
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: PUSH
46860: LD_INT 3
46862: PUSH
46863: LD_INT 3
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: PUSH
46870: LD_INT 2
46872: PUSH
46873: LD_INT 3
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 4
46882: PUSH
46883: LD_INT 3
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PUSH
46890: LD_INT 4
46892: PUSH
46893: LD_INT 4
46895: PUSH
46896: EMPTY
46897: LIST
46898: LIST
46899: PUSH
46900: LD_INT 3
46902: PUSH
46903: LD_INT 4
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: PUSH
46910: LD_INT 5
46912: PUSH
46913: LD_INT 4
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: PUSH
46920: LD_INT 5
46922: PUSH
46923: LD_INT 5
46925: PUSH
46926: EMPTY
46927: LIST
46928: LIST
46929: PUSH
46930: LD_INT 4
46932: PUSH
46933: LD_INT 5
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: PUSH
46940: LD_INT 6
46942: PUSH
46943: LD_INT 5
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_INT 6
46952: PUSH
46953: LD_INT 6
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: PUSH
46960: LD_INT 5
46962: PUSH
46963: LD_INT 6
46965: PUSH
46966: EMPTY
46967: LIST
46968: LIST
46969: PUSH
46970: EMPTY
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: LIST
46982: LIST
46983: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46984: LD_ADDR_VAR 0 32
46988: PUSH
46989: LD_INT 1
46991: PUSH
46992: LD_INT 3
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 0
47001: PUSH
47002: LD_INT 3
47004: PUSH
47005: EMPTY
47006: LIST
47007: LIST
47008: PUSH
47009: LD_INT 1
47011: NEG
47012: PUSH
47013: LD_INT 2
47015: PUSH
47016: EMPTY
47017: LIST
47018: LIST
47019: PUSH
47020: LD_INT 1
47022: PUSH
47023: LD_INT 4
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: PUSH
47030: LD_INT 0
47032: PUSH
47033: LD_INT 4
47035: PUSH
47036: EMPTY
47037: LIST
47038: LIST
47039: PUSH
47040: LD_INT 1
47042: NEG
47043: PUSH
47044: LD_INT 3
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 1
47053: PUSH
47054: LD_INT 5
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: LD_INT 0
47063: PUSH
47064: LD_INT 5
47066: PUSH
47067: EMPTY
47068: LIST
47069: LIST
47070: PUSH
47071: LD_INT 1
47073: NEG
47074: PUSH
47075: LD_INT 4
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: PUSH
47082: LD_INT 1
47084: PUSH
47085: LD_INT 6
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: PUSH
47092: LD_INT 0
47094: PUSH
47095: LD_INT 6
47097: PUSH
47098: EMPTY
47099: LIST
47100: LIST
47101: PUSH
47102: LD_INT 1
47104: NEG
47105: PUSH
47106: LD_INT 5
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: LIST
47117: LIST
47118: LIST
47119: LIST
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: LIST
47126: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
47127: LD_ADDR_VAR 0 33
47131: PUSH
47132: LD_INT 2
47134: NEG
47135: PUSH
47136: LD_INT 1
47138: PUSH
47139: EMPTY
47140: LIST
47141: LIST
47142: PUSH
47143: LD_INT 3
47145: NEG
47146: PUSH
47147: LD_INT 0
47149: PUSH
47150: EMPTY
47151: LIST
47152: LIST
47153: PUSH
47154: LD_INT 3
47156: NEG
47157: PUSH
47158: LD_INT 1
47160: NEG
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PUSH
47166: LD_INT 3
47168: NEG
47169: PUSH
47170: LD_INT 1
47172: PUSH
47173: EMPTY
47174: LIST
47175: LIST
47176: PUSH
47177: LD_INT 4
47179: NEG
47180: PUSH
47181: LD_INT 0
47183: PUSH
47184: EMPTY
47185: LIST
47186: LIST
47187: PUSH
47188: LD_INT 4
47190: NEG
47191: PUSH
47192: LD_INT 1
47194: NEG
47195: PUSH
47196: EMPTY
47197: LIST
47198: LIST
47199: PUSH
47200: LD_INT 4
47202: NEG
47203: PUSH
47204: LD_INT 1
47206: PUSH
47207: EMPTY
47208: LIST
47209: LIST
47210: PUSH
47211: LD_INT 5
47213: NEG
47214: PUSH
47215: LD_INT 0
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: PUSH
47222: LD_INT 5
47224: NEG
47225: PUSH
47226: LD_INT 1
47228: NEG
47229: PUSH
47230: EMPTY
47231: LIST
47232: LIST
47233: PUSH
47234: LD_INT 5
47236: NEG
47237: PUSH
47238: LD_INT 1
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PUSH
47245: LD_INT 6
47247: NEG
47248: PUSH
47249: LD_INT 0
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PUSH
47256: LD_INT 6
47258: NEG
47259: PUSH
47260: LD_INT 1
47262: NEG
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: PUSH
47268: EMPTY
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47282: LD_ADDR_VAR 0 34
47286: PUSH
47287: LD_INT 2
47289: NEG
47290: PUSH
47291: LD_INT 3
47293: NEG
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: LD_INT 3
47301: NEG
47302: PUSH
47303: LD_INT 2
47305: NEG
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 3
47313: NEG
47314: PUSH
47315: LD_INT 3
47317: NEG
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PUSH
47323: LD_INT 3
47325: NEG
47326: PUSH
47327: LD_INT 4
47329: NEG
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PUSH
47335: LD_INT 4
47337: NEG
47338: PUSH
47339: LD_INT 3
47341: NEG
47342: PUSH
47343: EMPTY
47344: LIST
47345: LIST
47346: PUSH
47347: LD_INT 4
47349: NEG
47350: PUSH
47351: LD_INT 4
47353: NEG
47354: PUSH
47355: EMPTY
47356: LIST
47357: LIST
47358: PUSH
47359: LD_INT 4
47361: NEG
47362: PUSH
47363: LD_INT 5
47365: NEG
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: PUSH
47371: LD_INT 5
47373: NEG
47374: PUSH
47375: LD_INT 4
47377: NEG
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: PUSH
47383: LD_INT 5
47385: NEG
47386: PUSH
47387: LD_INT 5
47389: NEG
47390: PUSH
47391: EMPTY
47392: LIST
47393: LIST
47394: PUSH
47395: LD_INT 5
47397: NEG
47398: PUSH
47399: LD_INT 6
47401: NEG
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: LD_INT 6
47409: NEG
47410: PUSH
47411: LD_INT 5
47413: NEG
47414: PUSH
47415: EMPTY
47416: LIST
47417: LIST
47418: PUSH
47419: LD_INT 6
47421: NEG
47422: PUSH
47423: LD_INT 6
47425: NEG
47426: PUSH
47427: EMPTY
47428: LIST
47429: LIST
47430: PUSH
47431: EMPTY
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47445: LD_ADDR_VAR 0 41
47449: PUSH
47450: LD_INT 0
47452: PUSH
47453: LD_INT 2
47455: NEG
47456: PUSH
47457: EMPTY
47458: LIST
47459: LIST
47460: PUSH
47461: LD_INT 1
47463: NEG
47464: PUSH
47465: LD_INT 3
47467: NEG
47468: PUSH
47469: EMPTY
47470: LIST
47471: LIST
47472: PUSH
47473: LD_INT 1
47475: PUSH
47476: LD_INT 2
47478: NEG
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: PUSH
47484: EMPTY
47485: LIST
47486: LIST
47487: LIST
47488: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47489: LD_ADDR_VAR 0 42
47493: PUSH
47494: LD_INT 2
47496: PUSH
47497: LD_INT 0
47499: PUSH
47500: EMPTY
47501: LIST
47502: LIST
47503: PUSH
47504: LD_INT 2
47506: PUSH
47507: LD_INT 1
47509: NEG
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PUSH
47515: LD_INT 3
47517: PUSH
47518: LD_INT 1
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: PUSH
47525: EMPTY
47526: LIST
47527: LIST
47528: LIST
47529: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47530: LD_ADDR_VAR 0 43
47534: PUSH
47535: LD_INT 2
47537: PUSH
47538: LD_INT 2
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: LD_INT 3
47547: PUSH
47548: LD_INT 2
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: LD_INT 2
47557: PUSH
47558: LD_INT 3
47560: PUSH
47561: EMPTY
47562: LIST
47563: LIST
47564: PUSH
47565: EMPTY
47566: LIST
47567: LIST
47568: LIST
47569: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47570: LD_ADDR_VAR 0 44
47574: PUSH
47575: LD_INT 0
47577: PUSH
47578: LD_INT 2
47580: PUSH
47581: EMPTY
47582: LIST
47583: LIST
47584: PUSH
47585: LD_INT 1
47587: PUSH
47588: LD_INT 3
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PUSH
47595: LD_INT 1
47597: NEG
47598: PUSH
47599: LD_INT 2
47601: PUSH
47602: EMPTY
47603: LIST
47604: LIST
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: LIST
47610: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47611: LD_ADDR_VAR 0 45
47615: PUSH
47616: LD_INT 2
47618: NEG
47619: PUSH
47620: LD_INT 0
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: PUSH
47627: LD_INT 2
47629: NEG
47630: PUSH
47631: LD_INT 1
47633: PUSH
47634: EMPTY
47635: LIST
47636: LIST
47637: PUSH
47638: LD_INT 3
47640: NEG
47641: PUSH
47642: LD_INT 1
47644: NEG
47645: PUSH
47646: EMPTY
47647: LIST
47648: LIST
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: LIST
47654: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47655: LD_ADDR_VAR 0 46
47659: PUSH
47660: LD_INT 2
47662: NEG
47663: PUSH
47664: LD_INT 2
47666: NEG
47667: PUSH
47668: EMPTY
47669: LIST
47670: LIST
47671: PUSH
47672: LD_INT 2
47674: NEG
47675: PUSH
47676: LD_INT 3
47678: NEG
47679: PUSH
47680: EMPTY
47681: LIST
47682: LIST
47683: PUSH
47684: LD_INT 3
47686: NEG
47687: PUSH
47688: LD_INT 2
47690: NEG
47691: PUSH
47692: EMPTY
47693: LIST
47694: LIST
47695: PUSH
47696: EMPTY
47697: LIST
47698: LIST
47699: LIST
47700: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47701: LD_ADDR_VAR 0 47
47705: PUSH
47706: LD_INT 2
47708: NEG
47709: PUSH
47710: LD_INT 3
47712: NEG
47713: PUSH
47714: EMPTY
47715: LIST
47716: LIST
47717: PUSH
47718: LD_INT 1
47720: NEG
47721: PUSH
47722: LD_INT 3
47724: NEG
47725: PUSH
47726: EMPTY
47727: LIST
47728: LIST
47729: PUSH
47730: EMPTY
47731: LIST
47732: LIST
47733: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47734: LD_ADDR_VAR 0 48
47738: PUSH
47739: LD_INT 1
47741: PUSH
47742: LD_INT 2
47744: NEG
47745: PUSH
47746: EMPTY
47747: LIST
47748: LIST
47749: PUSH
47750: LD_INT 2
47752: PUSH
47753: LD_INT 1
47755: NEG
47756: PUSH
47757: EMPTY
47758: LIST
47759: LIST
47760: PUSH
47761: EMPTY
47762: LIST
47763: LIST
47764: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47765: LD_ADDR_VAR 0 49
47769: PUSH
47770: LD_INT 3
47772: PUSH
47773: LD_INT 1
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: LD_INT 3
47782: PUSH
47783: LD_INT 2
47785: PUSH
47786: EMPTY
47787: LIST
47788: LIST
47789: PUSH
47790: EMPTY
47791: LIST
47792: LIST
47793: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47794: LD_ADDR_VAR 0 50
47798: PUSH
47799: LD_INT 2
47801: PUSH
47802: LD_INT 3
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: PUSH
47809: LD_INT 1
47811: PUSH
47812: LD_INT 3
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47823: LD_ADDR_VAR 0 51
47827: PUSH
47828: LD_INT 1
47830: NEG
47831: PUSH
47832: LD_INT 2
47834: PUSH
47835: EMPTY
47836: LIST
47837: LIST
47838: PUSH
47839: LD_INT 2
47841: NEG
47842: PUSH
47843: LD_INT 1
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: PUSH
47850: EMPTY
47851: LIST
47852: LIST
47853: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47854: LD_ADDR_VAR 0 52
47858: PUSH
47859: LD_INT 3
47861: NEG
47862: PUSH
47863: LD_INT 1
47865: NEG
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: PUSH
47871: LD_INT 3
47873: NEG
47874: PUSH
47875: LD_INT 2
47877: NEG
47878: PUSH
47879: EMPTY
47880: LIST
47881: LIST
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47887: LD_ADDR_VAR 0 53
47891: PUSH
47892: LD_INT 1
47894: NEG
47895: PUSH
47896: LD_INT 3
47898: NEG
47899: PUSH
47900: EMPTY
47901: LIST
47902: LIST
47903: PUSH
47904: LD_INT 0
47906: PUSH
47907: LD_INT 3
47909: NEG
47910: PUSH
47911: EMPTY
47912: LIST
47913: LIST
47914: PUSH
47915: LD_INT 1
47917: PUSH
47918: LD_INT 2
47920: NEG
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: EMPTY
47927: LIST
47928: LIST
47929: LIST
47930: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47931: LD_ADDR_VAR 0 54
47935: PUSH
47936: LD_INT 2
47938: PUSH
47939: LD_INT 1
47941: NEG
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 3
47949: PUSH
47950: LD_INT 0
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: LD_INT 3
47959: PUSH
47960: LD_INT 1
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: EMPTY
47968: LIST
47969: LIST
47970: LIST
47971: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47972: LD_ADDR_VAR 0 55
47976: PUSH
47977: LD_INT 3
47979: PUSH
47980: LD_INT 2
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 3
47989: PUSH
47990: LD_INT 3
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: LD_INT 2
47999: PUSH
48000: LD_INT 3
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PUSH
48007: EMPTY
48008: LIST
48009: LIST
48010: LIST
48011: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
48012: LD_ADDR_VAR 0 56
48016: PUSH
48017: LD_INT 1
48019: PUSH
48020: LD_INT 3
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 0
48029: PUSH
48030: LD_INT 3
48032: PUSH
48033: EMPTY
48034: LIST
48035: LIST
48036: PUSH
48037: LD_INT 1
48039: NEG
48040: PUSH
48041: LD_INT 2
48043: PUSH
48044: EMPTY
48045: LIST
48046: LIST
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: LIST
48052: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
48053: LD_ADDR_VAR 0 57
48057: PUSH
48058: LD_INT 2
48060: NEG
48061: PUSH
48062: LD_INT 1
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: PUSH
48069: LD_INT 3
48071: NEG
48072: PUSH
48073: LD_INT 0
48075: PUSH
48076: EMPTY
48077: LIST
48078: LIST
48079: PUSH
48080: LD_INT 3
48082: NEG
48083: PUSH
48084: LD_INT 1
48086: NEG
48087: PUSH
48088: EMPTY
48089: LIST
48090: LIST
48091: PUSH
48092: EMPTY
48093: LIST
48094: LIST
48095: LIST
48096: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
48097: LD_ADDR_VAR 0 58
48101: PUSH
48102: LD_INT 2
48104: NEG
48105: PUSH
48106: LD_INT 3
48108: NEG
48109: PUSH
48110: EMPTY
48111: LIST
48112: LIST
48113: PUSH
48114: LD_INT 3
48116: NEG
48117: PUSH
48118: LD_INT 2
48120: NEG
48121: PUSH
48122: EMPTY
48123: LIST
48124: LIST
48125: PUSH
48126: LD_INT 3
48128: NEG
48129: PUSH
48130: LD_INT 3
48132: NEG
48133: PUSH
48134: EMPTY
48135: LIST
48136: LIST
48137: PUSH
48138: EMPTY
48139: LIST
48140: LIST
48141: LIST
48142: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
48143: LD_ADDR_VAR 0 59
48147: PUSH
48148: LD_INT 1
48150: NEG
48151: PUSH
48152: LD_INT 2
48154: NEG
48155: PUSH
48156: EMPTY
48157: LIST
48158: LIST
48159: PUSH
48160: LD_INT 0
48162: PUSH
48163: LD_INT 2
48165: NEG
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: PUSH
48171: LD_INT 1
48173: PUSH
48174: LD_INT 1
48176: NEG
48177: PUSH
48178: EMPTY
48179: LIST
48180: LIST
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: LIST
48186: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48187: LD_ADDR_VAR 0 60
48191: PUSH
48192: LD_INT 1
48194: PUSH
48195: LD_INT 1
48197: NEG
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 2
48205: PUSH
48206: LD_INT 0
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: LD_INT 2
48215: PUSH
48216: LD_INT 1
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PUSH
48223: EMPTY
48224: LIST
48225: LIST
48226: LIST
48227: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48228: LD_ADDR_VAR 0 61
48232: PUSH
48233: LD_INT 2
48235: PUSH
48236: LD_INT 1
48238: PUSH
48239: EMPTY
48240: LIST
48241: LIST
48242: PUSH
48243: LD_INT 2
48245: PUSH
48246: LD_INT 2
48248: PUSH
48249: EMPTY
48250: LIST
48251: LIST
48252: PUSH
48253: LD_INT 1
48255: PUSH
48256: LD_INT 2
48258: PUSH
48259: EMPTY
48260: LIST
48261: LIST
48262: PUSH
48263: EMPTY
48264: LIST
48265: LIST
48266: LIST
48267: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48268: LD_ADDR_VAR 0 62
48272: PUSH
48273: LD_INT 1
48275: PUSH
48276: LD_INT 2
48278: PUSH
48279: EMPTY
48280: LIST
48281: LIST
48282: PUSH
48283: LD_INT 0
48285: PUSH
48286: LD_INT 2
48288: PUSH
48289: EMPTY
48290: LIST
48291: LIST
48292: PUSH
48293: LD_INT 1
48295: NEG
48296: PUSH
48297: LD_INT 1
48299: PUSH
48300: EMPTY
48301: LIST
48302: LIST
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: LIST
48308: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48309: LD_ADDR_VAR 0 63
48313: PUSH
48314: LD_INT 1
48316: NEG
48317: PUSH
48318: LD_INT 1
48320: PUSH
48321: EMPTY
48322: LIST
48323: LIST
48324: PUSH
48325: LD_INT 2
48327: NEG
48328: PUSH
48329: LD_INT 0
48331: PUSH
48332: EMPTY
48333: LIST
48334: LIST
48335: PUSH
48336: LD_INT 2
48338: NEG
48339: PUSH
48340: LD_INT 1
48342: NEG
48343: PUSH
48344: EMPTY
48345: LIST
48346: LIST
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: LIST
48352: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48353: LD_ADDR_VAR 0 64
48357: PUSH
48358: LD_INT 1
48360: NEG
48361: PUSH
48362: LD_INT 2
48364: NEG
48365: PUSH
48366: EMPTY
48367: LIST
48368: LIST
48369: PUSH
48370: LD_INT 2
48372: NEG
48373: PUSH
48374: LD_INT 1
48376: NEG
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: PUSH
48382: LD_INT 2
48384: NEG
48385: PUSH
48386: LD_INT 2
48388: NEG
48389: PUSH
48390: EMPTY
48391: LIST
48392: LIST
48393: PUSH
48394: EMPTY
48395: LIST
48396: LIST
48397: LIST
48398: ST_TO_ADDR
// end ; 2 :
48399: GO 51665
48401: LD_INT 2
48403: DOUBLE
48404: EQUAL
48405: IFTRUE 48409
48407: GO 51664
48409: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48410: LD_ADDR_VAR 0 29
48414: PUSH
48415: LD_INT 4
48417: PUSH
48418: LD_INT 0
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: PUSH
48425: LD_INT 4
48427: PUSH
48428: LD_INT 1
48430: NEG
48431: PUSH
48432: EMPTY
48433: LIST
48434: LIST
48435: PUSH
48436: LD_INT 5
48438: PUSH
48439: LD_INT 0
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PUSH
48446: LD_INT 5
48448: PUSH
48449: LD_INT 1
48451: PUSH
48452: EMPTY
48453: LIST
48454: LIST
48455: PUSH
48456: LD_INT 4
48458: PUSH
48459: LD_INT 1
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: PUSH
48466: LD_INT 3
48468: PUSH
48469: LD_INT 0
48471: PUSH
48472: EMPTY
48473: LIST
48474: LIST
48475: PUSH
48476: LD_INT 3
48478: PUSH
48479: LD_INT 1
48481: NEG
48482: PUSH
48483: EMPTY
48484: LIST
48485: LIST
48486: PUSH
48487: LD_INT 3
48489: PUSH
48490: LD_INT 2
48492: NEG
48493: PUSH
48494: EMPTY
48495: LIST
48496: LIST
48497: PUSH
48498: LD_INT 5
48500: PUSH
48501: LD_INT 2
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 3
48510: PUSH
48511: LD_INT 3
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PUSH
48518: LD_INT 3
48520: PUSH
48521: LD_INT 2
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: PUSH
48528: LD_INT 4
48530: PUSH
48531: LD_INT 3
48533: PUSH
48534: EMPTY
48535: LIST
48536: LIST
48537: PUSH
48538: LD_INT 4
48540: PUSH
48541: LD_INT 4
48543: PUSH
48544: EMPTY
48545: LIST
48546: LIST
48547: PUSH
48548: LD_INT 3
48550: PUSH
48551: LD_INT 4
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PUSH
48558: LD_INT 2
48560: PUSH
48561: LD_INT 3
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 2
48570: PUSH
48571: LD_INT 2
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 4
48580: PUSH
48581: LD_INT 2
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: LD_INT 2
48590: PUSH
48591: LD_INT 4
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 0
48600: PUSH
48601: LD_INT 4
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: PUSH
48608: LD_INT 0
48610: PUSH
48611: LD_INT 3
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: PUSH
48618: LD_INT 1
48620: PUSH
48621: LD_INT 4
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: PUSH
48628: LD_INT 1
48630: PUSH
48631: LD_INT 5
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: PUSH
48638: LD_INT 0
48640: PUSH
48641: LD_INT 5
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: PUSH
48648: LD_INT 1
48650: NEG
48651: PUSH
48652: LD_INT 4
48654: PUSH
48655: EMPTY
48656: LIST
48657: LIST
48658: PUSH
48659: LD_INT 1
48661: NEG
48662: PUSH
48663: LD_INT 3
48665: PUSH
48666: EMPTY
48667: LIST
48668: LIST
48669: PUSH
48670: LD_INT 2
48672: PUSH
48673: LD_INT 5
48675: PUSH
48676: EMPTY
48677: LIST
48678: LIST
48679: PUSH
48680: LD_INT 2
48682: NEG
48683: PUSH
48684: LD_INT 3
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: PUSH
48691: LD_INT 3
48693: NEG
48694: PUSH
48695: LD_INT 0
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: PUSH
48702: LD_INT 3
48704: NEG
48705: PUSH
48706: LD_INT 1
48708: NEG
48709: PUSH
48710: EMPTY
48711: LIST
48712: LIST
48713: PUSH
48714: LD_INT 2
48716: NEG
48717: PUSH
48718: LD_INT 0
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: PUSH
48725: LD_INT 2
48727: NEG
48728: PUSH
48729: LD_INT 1
48731: PUSH
48732: EMPTY
48733: LIST
48734: LIST
48735: PUSH
48736: LD_INT 3
48738: NEG
48739: PUSH
48740: LD_INT 1
48742: PUSH
48743: EMPTY
48744: LIST
48745: LIST
48746: PUSH
48747: LD_INT 4
48749: NEG
48750: PUSH
48751: LD_INT 0
48753: PUSH
48754: EMPTY
48755: LIST
48756: LIST
48757: PUSH
48758: LD_INT 4
48760: NEG
48761: PUSH
48762: LD_INT 1
48764: NEG
48765: PUSH
48766: EMPTY
48767: LIST
48768: LIST
48769: PUSH
48770: LD_INT 4
48772: NEG
48773: PUSH
48774: LD_INT 2
48776: NEG
48777: PUSH
48778: EMPTY
48779: LIST
48780: LIST
48781: PUSH
48782: LD_INT 2
48784: NEG
48785: PUSH
48786: LD_INT 2
48788: PUSH
48789: EMPTY
48790: LIST
48791: LIST
48792: PUSH
48793: LD_INT 4
48795: NEG
48796: PUSH
48797: LD_INT 4
48799: NEG
48800: PUSH
48801: EMPTY
48802: LIST
48803: LIST
48804: PUSH
48805: LD_INT 4
48807: NEG
48808: PUSH
48809: LD_INT 5
48811: NEG
48812: PUSH
48813: EMPTY
48814: LIST
48815: LIST
48816: PUSH
48817: LD_INT 3
48819: NEG
48820: PUSH
48821: LD_INT 4
48823: NEG
48824: PUSH
48825: EMPTY
48826: LIST
48827: LIST
48828: PUSH
48829: LD_INT 3
48831: NEG
48832: PUSH
48833: LD_INT 3
48835: NEG
48836: PUSH
48837: EMPTY
48838: LIST
48839: LIST
48840: PUSH
48841: LD_INT 4
48843: NEG
48844: PUSH
48845: LD_INT 3
48847: NEG
48848: PUSH
48849: EMPTY
48850: LIST
48851: LIST
48852: PUSH
48853: LD_INT 5
48855: NEG
48856: PUSH
48857: LD_INT 4
48859: NEG
48860: PUSH
48861: EMPTY
48862: LIST
48863: LIST
48864: PUSH
48865: LD_INT 5
48867: NEG
48868: PUSH
48869: LD_INT 5
48871: NEG
48872: PUSH
48873: EMPTY
48874: LIST
48875: LIST
48876: PUSH
48877: LD_INT 3
48879: NEG
48880: PUSH
48881: LD_INT 5
48883: NEG
48884: PUSH
48885: EMPTY
48886: LIST
48887: LIST
48888: PUSH
48889: LD_INT 5
48891: NEG
48892: PUSH
48893: LD_INT 3
48895: NEG
48896: PUSH
48897: EMPTY
48898: LIST
48899: LIST
48900: PUSH
48901: EMPTY
48902: LIST
48903: LIST
48904: LIST
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48948: LD_ADDR_VAR 0 30
48952: PUSH
48953: LD_INT 4
48955: PUSH
48956: LD_INT 4
48958: PUSH
48959: EMPTY
48960: LIST
48961: LIST
48962: PUSH
48963: LD_INT 4
48965: PUSH
48966: LD_INT 3
48968: PUSH
48969: EMPTY
48970: LIST
48971: LIST
48972: PUSH
48973: LD_INT 5
48975: PUSH
48976: LD_INT 4
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: PUSH
48983: LD_INT 5
48985: PUSH
48986: LD_INT 5
48988: PUSH
48989: EMPTY
48990: LIST
48991: LIST
48992: PUSH
48993: LD_INT 4
48995: PUSH
48996: LD_INT 5
48998: PUSH
48999: EMPTY
49000: LIST
49001: LIST
49002: PUSH
49003: LD_INT 3
49005: PUSH
49006: LD_INT 4
49008: PUSH
49009: EMPTY
49010: LIST
49011: LIST
49012: PUSH
49013: LD_INT 3
49015: PUSH
49016: LD_INT 3
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: PUSH
49023: LD_INT 5
49025: PUSH
49026: LD_INT 3
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PUSH
49033: LD_INT 3
49035: PUSH
49036: LD_INT 5
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 0
49045: PUSH
49046: LD_INT 3
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PUSH
49053: LD_INT 0
49055: PUSH
49056: LD_INT 2
49058: PUSH
49059: EMPTY
49060: LIST
49061: LIST
49062: PUSH
49063: LD_INT 1
49065: PUSH
49066: LD_INT 3
49068: PUSH
49069: EMPTY
49070: LIST
49071: LIST
49072: PUSH
49073: LD_INT 1
49075: PUSH
49076: LD_INT 4
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: LD_INT 0
49085: PUSH
49086: LD_INT 4
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: PUSH
49093: LD_INT 1
49095: NEG
49096: PUSH
49097: LD_INT 3
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: PUSH
49104: LD_INT 1
49106: NEG
49107: PUSH
49108: LD_INT 2
49110: PUSH
49111: EMPTY
49112: LIST
49113: LIST
49114: PUSH
49115: LD_INT 2
49117: PUSH
49118: LD_INT 4
49120: PUSH
49121: EMPTY
49122: LIST
49123: LIST
49124: PUSH
49125: LD_INT 2
49127: NEG
49128: PUSH
49129: LD_INT 2
49131: PUSH
49132: EMPTY
49133: LIST
49134: LIST
49135: PUSH
49136: LD_INT 4
49138: NEG
49139: PUSH
49140: LD_INT 0
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: PUSH
49147: LD_INT 4
49149: NEG
49150: PUSH
49151: LD_INT 1
49153: NEG
49154: PUSH
49155: EMPTY
49156: LIST
49157: LIST
49158: PUSH
49159: LD_INT 3
49161: NEG
49162: PUSH
49163: LD_INT 0
49165: PUSH
49166: EMPTY
49167: LIST
49168: LIST
49169: PUSH
49170: LD_INT 3
49172: NEG
49173: PUSH
49174: LD_INT 1
49176: PUSH
49177: EMPTY
49178: LIST
49179: LIST
49180: PUSH
49181: LD_INT 4
49183: NEG
49184: PUSH
49185: LD_INT 1
49187: PUSH
49188: EMPTY
49189: LIST
49190: LIST
49191: PUSH
49192: LD_INT 5
49194: NEG
49195: PUSH
49196: LD_INT 0
49198: PUSH
49199: EMPTY
49200: LIST
49201: LIST
49202: PUSH
49203: LD_INT 5
49205: NEG
49206: PUSH
49207: LD_INT 1
49209: NEG
49210: PUSH
49211: EMPTY
49212: LIST
49213: LIST
49214: PUSH
49215: LD_INT 5
49217: NEG
49218: PUSH
49219: LD_INT 2
49221: NEG
49222: PUSH
49223: EMPTY
49224: LIST
49225: LIST
49226: PUSH
49227: LD_INT 3
49229: NEG
49230: PUSH
49231: LD_INT 2
49233: PUSH
49234: EMPTY
49235: LIST
49236: LIST
49237: PUSH
49238: LD_INT 3
49240: NEG
49241: PUSH
49242: LD_INT 3
49244: NEG
49245: PUSH
49246: EMPTY
49247: LIST
49248: LIST
49249: PUSH
49250: LD_INT 3
49252: NEG
49253: PUSH
49254: LD_INT 4
49256: NEG
49257: PUSH
49258: EMPTY
49259: LIST
49260: LIST
49261: PUSH
49262: LD_INT 2
49264: NEG
49265: PUSH
49266: LD_INT 3
49268: NEG
49269: PUSH
49270: EMPTY
49271: LIST
49272: LIST
49273: PUSH
49274: LD_INT 2
49276: NEG
49277: PUSH
49278: LD_INT 2
49280: NEG
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: PUSH
49286: LD_INT 3
49288: NEG
49289: PUSH
49290: LD_INT 2
49292: NEG
49293: PUSH
49294: EMPTY
49295: LIST
49296: LIST
49297: PUSH
49298: LD_INT 4
49300: NEG
49301: PUSH
49302: LD_INT 3
49304: NEG
49305: PUSH
49306: EMPTY
49307: LIST
49308: LIST
49309: PUSH
49310: LD_INT 4
49312: NEG
49313: PUSH
49314: LD_INT 4
49316: NEG
49317: PUSH
49318: EMPTY
49319: LIST
49320: LIST
49321: PUSH
49322: LD_INT 2
49324: NEG
49325: PUSH
49326: LD_INT 4
49328: NEG
49329: PUSH
49330: EMPTY
49331: LIST
49332: LIST
49333: PUSH
49334: LD_INT 4
49336: NEG
49337: PUSH
49338: LD_INT 2
49340: NEG
49341: PUSH
49342: EMPTY
49343: LIST
49344: LIST
49345: PUSH
49346: LD_INT 0
49348: PUSH
49349: LD_INT 4
49351: NEG
49352: PUSH
49353: EMPTY
49354: LIST
49355: LIST
49356: PUSH
49357: LD_INT 0
49359: PUSH
49360: LD_INT 5
49362: NEG
49363: PUSH
49364: EMPTY
49365: LIST
49366: LIST
49367: PUSH
49368: LD_INT 1
49370: PUSH
49371: LD_INT 4
49373: NEG
49374: PUSH
49375: EMPTY
49376: LIST
49377: LIST
49378: PUSH
49379: LD_INT 1
49381: PUSH
49382: LD_INT 3
49384: NEG
49385: PUSH
49386: EMPTY
49387: LIST
49388: LIST
49389: PUSH
49390: LD_INT 0
49392: PUSH
49393: LD_INT 3
49395: NEG
49396: PUSH
49397: EMPTY
49398: LIST
49399: LIST
49400: PUSH
49401: LD_INT 1
49403: NEG
49404: PUSH
49405: LD_INT 4
49407: NEG
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: PUSH
49413: LD_INT 1
49415: NEG
49416: PUSH
49417: LD_INT 5
49419: NEG
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: PUSH
49425: LD_INT 2
49427: PUSH
49428: LD_INT 3
49430: NEG
49431: PUSH
49432: EMPTY
49433: LIST
49434: LIST
49435: PUSH
49436: LD_INT 2
49438: NEG
49439: PUSH
49440: LD_INT 5
49442: NEG
49443: PUSH
49444: EMPTY
49445: LIST
49446: LIST
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: LIST
49485: LIST
49486: LIST
49487: LIST
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: LIST
49493: LIST
49494: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49495: LD_ADDR_VAR 0 31
49499: PUSH
49500: LD_INT 0
49502: PUSH
49503: LD_INT 4
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 0
49512: PUSH
49513: LD_INT 3
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: PUSH
49520: LD_INT 1
49522: PUSH
49523: LD_INT 4
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: LD_INT 1
49532: PUSH
49533: LD_INT 5
49535: PUSH
49536: EMPTY
49537: LIST
49538: LIST
49539: PUSH
49540: LD_INT 0
49542: PUSH
49543: LD_INT 5
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: PUSH
49550: LD_INT 1
49552: NEG
49553: PUSH
49554: LD_INT 4
49556: PUSH
49557: EMPTY
49558: LIST
49559: LIST
49560: PUSH
49561: LD_INT 1
49563: NEG
49564: PUSH
49565: LD_INT 3
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: PUSH
49572: LD_INT 2
49574: PUSH
49575: LD_INT 5
49577: PUSH
49578: EMPTY
49579: LIST
49580: LIST
49581: PUSH
49582: LD_INT 2
49584: NEG
49585: PUSH
49586: LD_INT 3
49588: PUSH
49589: EMPTY
49590: LIST
49591: LIST
49592: PUSH
49593: LD_INT 3
49595: NEG
49596: PUSH
49597: LD_INT 0
49599: PUSH
49600: EMPTY
49601: LIST
49602: LIST
49603: PUSH
49604: LD_INT 3
49606: NEG
49607: PUSH
49608: LD_INT 1
49610: NEG
49611: PUSH
49612: EMPTY
49613: LIST
49614: LIST
49615: PUSH
49616: LD_INT 2
49618: NEG
49619: PUSH
49620: LD_INT 0
49622: PUSH
49623: EMPTY
49624: LIST
49625: LIST
49626: PUSH
49627: LD_INT 2
49629: NEG
49630: PUSH
49631: LD_INT 1
49633: PUSH
49634: EMPTY
49635: LIST
49636: LIST
49637: PUSH
49638: LD_INT 3
49640: NEG
49641: PUSH
49642: LD_INT 1
49644: PUSH
49645: EMPTY
49646: LIST
49647: LIST
49648: PUSH
49649: LD_INT 4
49651: NEG
49652: PUSH
49653: LD_INT 0
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PUSH
49660: LD_INT 4
49662: NEG
49663: PUSH
49664: LD_INT 1
49666: NEG
49667: PUSH
49668: EMPTY
49669: LIST
49670: LIST
49671: PUSH
49672: LD_INT 4
49674: NEG
49675: PUSH
49676: LD_INT 2
49678: NEG
49679: PUSH
49680: EMPTY
49681: LIST
49682: LIST
49683: PUSH
49684: LD_INT 2
49686: NEG
49687: PUSH
49688: LD_INT 2
49690: PUSH
49691: EMPTY
49692: LIST
49693: LIST
49694: PUSH
49695: LD_INT 4
49697: NEG
49698: PUSH
49699: LD_INT 4
49701: NEG
49702: PUSH
49703: EMPTY
49704: LIST
49705: LIST
49706: PUSH
49707: LD_INT 4
49709: NEG
49710: PUSH
49711: LD_INT 5
49713: NEG
49714: PUSH
49715: EMPTY
49716: LIST
49717: LIST
49718: PUSH
49719: LD_INT 3
49721: NEG
49722: PUSH
49723: LD_INT 4
49725: NEG
49726: PUSH
49727: EMPTY
49728: LIST
49729: LIST
49730: PUSH
49731: LD_INT 3
49733: NEG
49734: PUSH
49735: LD_INT 3
49737: NEG
49738: PUSH
49739: EMPTY
49740: LIST
49741: LIST
49742: PUSH
49743: LD_INT 4
49745: NEG
49746: PUSH
49747: LD_INT 3
49749: NEG
49750: PUSH
49751: EMPTY
49752: LIST
49753: LIST
49754: PUSH
49755: LD_INT 5
49757: NEG
49758: PUSH
49759: LD_INT 4
49761: NEG
49762: PUSH
49763: EMPTY
49764: LIST
49765: LIST
49766: PUSH
49767: LD_INT 5
49769: NEG
49770: PUSH
49771: LD_INT 5
49773: NEG
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PUSH
49779: LD_INT 3
49781: NEG
49782: PUSH
49783: LD_INT 5
49785: NEG
49786: PUSH
49787: EMPTY
49788: LIST
49789: LIST
49790: PUSH
49791: LD_INT 5
49793: NEG
49794: PUSH
49795: LD_INT 3
49797: NEG
49798: PUSH
49799: EMPTY
49800: LIST
49801: LIST
49802: PUSH
49803: LD_INT 0
49805: PUSH
49806: LD_INT 3
49808: NEG
49809: PUSH
49810: EMPTY
49811: LIST
49812: LIST
49813: PUSH
49814: LD_INT 0
49816: PUSH
49817: LD_INT 4
49819: NEG
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: PUSH
49825: LD_INT 1
49827: PUSH
49828: LD_INT 3
49830: NEG
49831: PUSH
49832: EMPTY
49833: LIST
49834: LIST
49835: PUSH
49836: LD_INT 1
49838: PUSH
49839: LD_INT 2
49841: NEG
49842: PUSH
49843: EMPTY
49844: LIST
49845: LIST
49846: PUSH
49847: LD_INT 0
49849: PUSH
49850: LD_INT 2
49852: NEG
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: PUSH
49858: LD_INT 1
49860: NEG
49861: PUSH
49862: LD_INT 3
49864: NEG
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PUSH
49870: LD_INT 1
49872: NEG
49873: PUSH
49874: LD_INT 4
49876: NEG
49877: PUSH
49878: EMPTY
49879: LIST
49880: LIST
49881: PUSH
49882: LD_INT 2
49884: PUSH
49885: LD_INT 2
49887: NEG
49888: PUSH
49889: EMPTY
49890: LIST
49891: LIST
49892: PUSH
49893: LD_INT 2
49895: NEG
49896: PUSH
49897: LD_INT 4
49899: NEG
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: LD_INT 4
49907: PUSH
49908: LD_INT 0
49910: PUSH
49911: EMPTY
49912: LIST
49913: LIST
49914: PUSH
49915: LD_INT 4
49917: PUSH
49918: LD_INT 1
49920: NEG
49921: PUSH
49922: EMPTY
49923: LIST
49924: LIST
49925: PUSH
49926: LD_INT 5
49928: PUSH
49929: LD_INT 0
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: PUSH
49936: LD_INT 5
49938: PUSH
49939: LD_INT 1
49941: PUSH
49942: EMPTY
49943: LIST
49944: LIST
49945: PUSH
49946: LD_INT 4
49948: PUSH
49949: LD_INT 1
49951: PUSH
49952: EMPTY
49953: LIST
49954: LIST
49955: PUSH
49956: LD_INT 3
49958: PUSH
49959: LD_INT 0
49961: PUSH
49962: EMPTY
49963: LIST
49964: LIST
49965: PUSH
49966: LD_INT 3
49968: PUSH
49969: LD_INT 1
49971: NEG
49972: PUSH
49973: EMPTY
49974: LIST
49975: LIST
49976: PUSH
49977: LD_INT 3
49979: PUSH
49980: LD_INT 2
49982: NEG
49983: PUSH
49984: EMPTY
49985: LIST
49986: LIST
49987: PUSH
49988: LD_INT 5
49990: PUSH
49991: LD_INT 2
49993: PUSH
49994: EMPTY
49995: LIST
49996: LIST
49997: PUSH
49998: EMPTY
49999: LIST
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: LIST
50009: LIST
50010: LIST
50011: LIST
50012: LIST
50013: LIST
50014: LIST
50015: LIST
50016: LIST
50017: LIST
50018: LIST
50019: LIST
50020: LIST
50021: LIST
50022: LIST
50023: LIST
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: LIST
50029: LIST
50030: LIST
50031: LIST
50032: LIST
50033: LIST
50034: LIST
50035: LIST
50036: LIST
50037: LIST
50038: LIST
50039: LIST
50040: LIST
50041: LIST
50042: LIST
50043: LIST
50044: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
50045: LD_ADDR_VAR 0 32
50049: PUSH
50050: LD_INT 4
50052: NEG
50053: PUSH
50054: LD_INT 0
50056: PUSH
50057: EMPTY
50058: LIST
50059: LIST
50060: PUSH
50061: LD_INT 4
50063: NEG
50064: PUSH
50065: LD_INT 1
50067: NEG
50068: PUSH
50069: EMPTY
50070: LIST
50071: LIST
50072: PUSH
50073: LD_INT 3
50075: NEG
50076: PUSH
50077: LD_INT 0
50079: PUSH
50080: EMPTY
50081: LIST
50082: LIST
50083: PUSH
50084: LD_INT 3
50086: NEG
50087: PUSH
50088: LD_INT 1
50090: PUSH
50091: EMPTY
50092: LIST
50093: LIST
50094: PUSH
50095: LD_INT 4
50097: NEG
50098: PUSH
50099: LD_INT 1
50101: PUSH
50102: EMPTY
50103: LIST
50104: LIST
50105: PUSH
50106: LD_INT 5
50108: NEG
50109: PUSH
50110: LD_INT 0
50112: PUSH
50113: EMPTY
50114: LIST
50115: LIST
50116: PUSH
50117: LD_INT 5
50119: NEG
50120: PUSH
50121: LD_INT 1
50123: NEG
50124: PUSH
50125: EMPTY
50126: LIST
50127: LIST
50128: PUSH
50129: LD_INT 5
50131: NEG
50132: PUSH
50133: LD_INT 2
50135: NEG
50136: PUSH
50137: EMPTY
50138: LIST
50139: LIST
50140: PUSH
50141: LD_INT 3
50143: NEG
50144: PUSH
50145: LD_INT 2
50147: PUSH
50148: EMPTY
50149: LIST
50150: LIST
50151: PUSH
50152: LD_INT 3
50154: NEG
50155: PUSH
50156: LD_INT 3
50158: NEG
50159: PUSH
50160: EMPTY
50161: LIST
50162: LIST
50163: PUSH
50164: LD_INT 3
50166: NEG
50167: PUSH
50168: LD_INT 4
50170: NEG
50171: PUSH
50172: EMPTY
50173: LIST
50174: LIST
50175: PUSH
50176: LD_INT 2
50178: NEG
50179: PUSH
50180: LD_INT 3
50182: NEG
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: LD_INT 2
50190: NEG
50191: PUSH
50192: LD_INT 2
50194: NEG
50195: PUSH
50196: EMPTY
50197: LIST
50198: LIST
50199: PUSH
50200: LD_INT 3
50202: NEG
50203: PUSH
50204: LD_INT 2
50206: NEG
50207: PUSH
50208: EMPTY
50209: LIST
50210: LIST
50211: PUSH
50212: LD_INT 4
50214: NEG
50215: PUSH
50216: LD_INT 3
50218: NEG
50219: PUSH
50220: EMPTY
50221: LIST
50222: LIST
50223: PUSH
50224: LD_INT 4
50226: NEG
50227: PUSH
50228: LD_INT 4
50230: NEG
50231: PUSH
50232: EMPTY
50233: LIST
50234: LIST
50235: PUSH
50236: LD_INT 2
50238: NEG
50239: PUSH
50240: LD_INT 4
50242: NEG
50243: PUSH
50244: EMPTY
50245: LIST
50246: LIST
50247: PUSH
50248: LD_INT 4
50250: NEG
50251: PUSH
50252: LD_INT 2
50254: NEG
50255: PUSH
50256: EMPTY
50257: LIST
50258: LIST
50259: PUSH
50260: LD_INT 0
50262: PUSH
50263: LD_INT 4
50265: NEG
50266: PUSH
50267: EMPTY
50268: LIST
50269: LIST
50270: PUSH
50271: LD_INT 0
50273: PUSH
50274: LD_INT 5
50276: NEG
50277: PUSH
50278: EMPTY
50279: LIST
50280: LIST
50281: PUSH
50282: LD_INT 1
50284: PUSH
50285: LD_INT 4
50287: NEG
50288: PUSH
50289: EMPTY
50290: LIST
50291: LIST
50292: PUSH
50293: LD_INT 1
50295: PUSH
50296: LD_INT 3
50298: NEG
50299: PUSH
50300: EMPTY
50301: LIST
50302: LIST
50303: PUSH
50304: LD_INT 0
50306: PUSH
50307: LD_INT 3
50309: NEG
50310: PUSH
50311: EMPTY
50312: LIST
50313: LIST
50314: PUSH
50315: LD_INT 1
50317: NEG
50318: PUSH
50319: LD_INT 4
50321: NEG
50322: PUSH
50323: EMPTY
50324: LIST
50325: LIST
50326: PUSH
50327: LD_INT 1
50329: NEG
50330: PUSH
50331: LD_INT 5
50333: NEG
50334: PUSH
50335: EMPTY
50336: LIST
50337: LIST
50338: PUSH
50339: LD_INT 2
50341: PUSH
50342: LD_INT 3
50344: NEG
50345: PUSH
50346: EMPTY
50347: LIST
50348: LIST
50349: PUSH
50350: LD_INT 2
50352: NEG
50353: PUSH
50354: LD_INT 5
50356: NEG
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: LD_INT 3
50364: PUSH
50365: LD_INT 0
50367: PUSH
50368: EMPTY
50369: LIST
50370: LIST
50371: PUSH
50372: LD_INT 3
50374: PUSH
50375: LD_INT 1
50377: NEG
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: LD_INT 4
50385: PUSH
50386: LD_INT 0
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: PUSH
50393: LD_INT 4
50395: PUSH
50396: LD_INT 1
50398: PUSH
50399: EMPTY
50400: LIST
50401: LIST
50402: PUSH
50403: LD_INT 3
50405: PUSH
50406: LD_INT 1
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: PUSH
50413: LD_INT 2
50415: PUSH
50416: LD_INT 0
50418: PUSH
50419: EMPTY
50420: LIST
50421: LIST
50422: PUSH
50423: LD_INT 2
50425: PUSH
50426: LD_INT 1
50428: NEG
50429: PUSH
50430: EMPTY
50431: LIST
50432: LIST
50433: PUSH
50434: LD_INT 2
50436: PUSH
50437: LD_INT 2
50439: NEG
50440: PUSH
50441: EMPTY
50442: LIST
50443: LIST
50444: PUSH
50445: LD_INT 4
50447: PUSH
50448: LD_INT 2
50450: PUSH
50451: EMPTY
50452: LIST
50453: LIST
50454: PUSH
50455: LD_INT 4
50457: PUSH
50458: LD_INT 4
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: PUSH
50465: LD_INT 4
50467: PUSH
50468: LD_INT 3
50470: PUSH
50471: EMPTY
50472: LIST
50473: LIST
50474: PUSH
50475: LD_INT 5
50477: PUSH
50478: LD_INT 4
50480: PUSH
50481: EMPTY
50482: LIST
50483: LIST
50484: PUSH
50485: LD_INT 5
50487: PUSH
50488: LD_INT 5
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PUSH
50495: LD_INT 4
50497: PUSH
50498: LD_INT 5
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 3
50507: PUSH
50508: LD_INT 4
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 3
50517: PUSH
50518: LD_INT 3
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 5
50527: PUSH
50528: LD_INT 3
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: LD_INT 3
50537: PUSH
50538: LD_INT 5
50540: PUSH
50541: EMPTY
50542: LIST
50543: LIST
50544: PUSH
50545: EMPTY
50546: LIST
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: LIST
50552: LIST
50553: LIST
50554: LIST
50555: LIST
50556: LIST
50557: LIST
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: LIST
50563: LIST
50564: LIST
50565: LIST
50566: LIST
50567: LIST
50568: LIST
50569: LIST
50570: LIST
50571: LIST
50572: LIST
50573: LIST
50574: LIST
50575: LIST
50576: LIST
50577: LIST
50578: LIST
50579: LIST
50580: LIST
50581: LIST
50582: LIST
50583: LIST
50584: LIST
50585: LIST
50586: LIST
50587: LIST
50588: LIST
50589: LIST
50590: LIST
50591: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50592: LD_ADDR_VAR 0 33
50596: PUSH
50597: LD_INT 4
50599: NEG
50600: PUSH
50601: LD_INT 4
50603: NEG
50604: PUSH
50605: EMPTY
50606: LIST
50607: LIST
50608: PUSH
50609: LD_INT 4
50611: NEG
50612: PUSH
50613: LD_INT 5
50615: NEG
50616: PUSH
50617: EMPTY
50618: LIST
50619: LIST
50620: PUSH
50621: LD_INT 3
50623: NEG
50624: PUSH
50625: LD_INT 4
50627: NEG
50628: PUSH
50629: EMPTY
50630: LIST
50631: LIST
50632: PUSH
50633: LD_INT 3
50635: NEG
50636: PUSH
50637: LD_INT 3
50639: NEG
50640: PUSH
50641: EMPTY
50642: LIST
50643: LIST
50644: PUSH
50645: LD_INT 4
50647: NEG
50648: PUSH
50649: LD_INT 3
50651: NEG
50652: PUSH
50653: EMPTY
50654: LIST
50655: LIST
50656: PUSH
50657: LD_INT 5
50659: NEG
50660: PUSH
50661: LD_INT 4
50663: NEG
50664: PUSH
50665: EMPTY
50666: LIST
50667: LIST
50668: PUSH
50669: LD_INT 5
50671: NEG
50672: PUSH
50673: LD_INT 5
50675: NEG
50676: PUSH
50677: EMPTY
50678: LIST
50679: LIST
50680: PUSH
50681: LD_INT 3
50683: NEG
50684: PUSH
50685: LD_INT 5
50687: NEG
50688: PUSH
50689: EMPTY
50690: LIST
50691: LIST
50692: PUSH
50693: LD_INT 5
50695: NEG
50696: PUSH
50697: LD_INT 3
50699: NEG
50700: PUSH
50701: EMPTY
50702: LIST
50703: LIST
50704: PUSH
50705: LD_INT 0
50707: PUSH
50708: LD_INT 3
50710: NEG
50711: PUSH
50712: EMPTY
50713: LIST
50714: LIST
50715: PUSH
50716: LD_INT 0
50718: PUSH
50719: LD_INT 4
50721: NEG
50722: PUSH
50723: EMPTY
50724: LIST
50725: LIST
50726: PUSH
50727: LD_INT 1
50729: PUSH
50730: LD_INT 3
50732: NEG
50733: PUSH
50734: EMPTY
50735: LIST
50736: LIST
50737: PUSH
50738: LD_INT 1
50740: PUSH
50741: LD_INT 2
50743: NEG
50744: PUSH
50745: EMPTY
50746: LIST
50747: LIST
50748: PUSH
50749: LD_INT 0
50751: PUSH
50752: LD_INT 2
50754: NEG
50755: PUSH
50756: EMPTY
50757: LIST
50758: LIST
50759: PUSH
50760: LD_INT 1
50762: NEG
50763: PUSH
50764: LD_INT 3
50766: NEG
50767: PUSH
50768: EMPTY
50769: LIST
50770: LIST
50771: PUSH
50772: LD_INT 1
50774: NEG
50775: PUSH
50776: LD_INT 4
50778: NEG
50779: PUSH
50780: EMPTY
50781: LIST
50782: LIST
50783: PUSH
50784: LD_INT 2
50786: PUSH
50787: LD_INT 2
50789: NEG
50790: PUSH
50791: EMPTY
50792: LIST
50793: LIST
50794: PUSH
50795: LD_INT 2
50797: NEG
50798: PUSH
50799: LD_INT 4
50801: NEG
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: PUSH
50807: LD_INT 4
50809: PUSH
50810: LD_INT 0
50812: PUSH
50813: EMPTY
50814: LIST
50815: LIST
50816: PUSH
50817: LD_INT 4
50819: PUSH
50820: LD_INT 1
50822: NEG
50823: PUSH
50824: EMPTY
50825: LIST
50826: LIST
50827: PUSH
50828: LD_INT 5
50830: PUSH
50831: LD_INT 0
50833: PUSH
50834: EMPTY
50835: LIST
50836: LIST
50837: PUSH
50838: LD_INT 5
50840: PUSH
50841: LD_INT 1
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: PUSH
50848: LD_INT 4
50850: PUSH
50851: LD_INT 1
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PUSH
50858: LD_INT 3
50860: PUSH
50861: LD_INT 0
50863: PUSH
50864: EMPTY
50865: LIST
50866: LIST
50867: PUSH
50868: LD_INT 3
50870: PUSH
50871: LD_INT 1
50873: NEG
50874: PUSH
50875: EMPTY
50876: LIST
50877: LIST
50878: PUSH
50879: LD_INT 3
50881: PUSH
50882: LD_INT 2
50884: NEG
50885: PUSH
50886: EMPTY
50887: LIST
50888: LIST
50889: PUSH
50890: LD_INT 5
50892: PUSH
50893: LD_INT 2
50895: PUSH
50896: EMPTY
50897: LIST
50898: LIST
50899: PUSH
50900: LD_INT 3
50902: PUSH
50903: LD_INT 3
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 3
50912: PUSH
50913: LD_INT 2
50915: PUSH
50916: EMPTY
50917: LIST
50918: LIST
50919: PUSH
50920: LD_INT 4
50922: PUSH
50923: LD_INT 3
50925: PUSH
50926: EMPTY
50927: LIST
50928: LIST
50929: PUSH
50930: LD_INT 4
50932: PUSH
50933: LD_INT 4
50935: PUSH
50936: EMPTY
50937: LIST
50938: LIST
50939: PUSH
50940: LD_INT 3
50942: PUSH
50943: LD_INT 4
50945: PUSH
50946: EMPTY
50947: LIST
50948: LIST
50949: PUSH
50950: LD_INT 2
50952: PUSH
50953: LD_INT 3
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PUSH
50960: LD_INT 2
50962: PUSH
50963: LD_INT 2
50965: PUSH
50966: EMPTY
50967: LIST
50968: LIST
50969: PUSH
50970: LD_INT 4
50972: PUSH
50973: LD_INT 2
50975: PUSH
50976: EMPTY
50977: LIST
50978: LIST
50979: PUSH
50980: LD_INT 2
50982: PUSH
50983: LD_INT 4
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: PUSH
50990: LD_INT 0
50992: PUSH
50993: LD_INT 4
50995: PUSH
50996: EMPTY
50997: LIST
50998: LIST
50999: PUSH
51000: LD_INT 0
51002: PUSH
51003: LD_INT 3
51005: PUSH
51006: EMPTY
51007: LIST
51008: LIST
51009: PUSH
51010: LD_INT 1
51012: PUSH
51013: LD_INT 4
51015: PUSH
51016: EMPTY
51017: LIST
51018: LIST
51019: PUSH
51020: LD_INT 1
51022: PUSH
51023: LD_INT 5
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PUSH
51030: LD_INT 0
51032: PUSH
51033: LD_INT 5
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: PUSH
51040: LD_INT 1
51042: NEG
51043: PUSH
51044: LD_INT 4
51046: PUSH
51047: EMPTY
51048: LIST
51049: LIST
51050: PUSH
51051: LD_INT 1
51053: NEG
51054: PUSH
51055: LD_INT 3
51057: PUSH
51058: EMPTY
51059: LIST
51060: LIST
51061: PUSH
51062: LD_INT 2
51064: PUSH
51065: LD_INT 5
51067: PUSH
51068: EMPTY
51069: LIST
51070: LIST
51071: PUSH
51072: LD_INT 2
51074: NEG
51075: PUSH
51076: LD_INT 3
51078: PUSH
51079: EMPTY
51080: LIST
51081: LIST
51082: PUSH
51083: EMPTY
51084: LIST
51085: LIST
51086: LIST
51087: LIST
51088: LIST
51089: LIST
51090: LIST
51091: LIST
51092: LIST
51093: LIST
51094: LIST
51095: LIST
51096: LIST
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: LIST
51128: LIST
51129: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
51130: LD_ADDR_VAR 0 34
51134: PUSH
51135: LD_INT 0
51137: PUSH
51138: LD_INT 4
51140: NEG
51141: PUSH
51142: EMPTY
51143: LIST
51144: LIST
51145: PUSH
51146: LD_INT 0
51148: PUSH
51149: LD_INT 5
51151: NEG
51152: PUSH
51153: EMPTY
51154: LIST
51155: LIST
51156: PUSH
51157: LD_INT 1
51159: PUSH
51160: LD_INT 4
51162: NEG
51163: PUSH
51164: EMPTY
51165: LIST
51166: LIST
51167: PUSH
51168: LD_INT 1
51170: PUSH
51171: LD_INT 3
51173: NEG
51174: PUSH
51175: EMPTY
51176: LIST
51177: LIST
51178: PUSH
51179: LD_INT 0
51181: PUSH
51182: LD_INT 3
51184: NEG
51185: PUSH
51186: EMPTY
51187: LIST
51188: LIST
51189: PUSH
51190: LD_INT 1
51192: NEG
51193: PUSH
51194: LD_INT 4
51196: NEG
51197: PUSH
51198: EMPTY
51199: LIST
51200: LIST
51201: PUSH
51202: LD_INT 1
51204: NEG
51205: PUSH
51206: LD_INT 5
51208: NEG
51209: PUSH
51210: EMPTY
51211: LIST
51212: LIST
51213: PUSH
51214: LD_INT 2
51216: PUSH
51217: LD_INT 3
51219: NEG
51220: PUSH
51221: EMPTY
51222: LIST
51223: LIST
51224: PUSH
51225: LD_INT 2
51227: NEG
51228: PUSH
51229: LD_INT 5
51231: NEG
51232: PUSH
51233: EMPTY
51234: LIST
51235: LIST
51236: PUSH
51237: LD_INT 3
51239: PUSH
51240: LD_INT 0
51242: PUSH
51243: EMPTY
51244: LIST
51245: LIST
51246: PUSH
51247: LD_INT 3
51249: PUSH
51250: LD_INT 1
51252: NEG
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PUSH
51258: LD_INT 4
51260: PUSH
51261: LD_INT 0
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 4
51270: PUSH
51271: LD_INT 1
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PUSH
51278: LD_INT 3
51280: PUSH
51281: LD_INT 1
51283: PUSH
51284: EMPTY
51285: LIST
51286: LIST
51287: PUSH
51288: LD_INT 2
51290: PUSH
51291: LD_INT 0
51293: PUSH
51294: EMPTY
51295: LIST
51296: LIST
51297: PUSH
51298: LD_INT 2
51300: PUSH
51301: LD_INT 1
51303: NEG
51304: PUSH
51305: EMPTY
51306: LIST
51307: LIST
51308: PUSH
51309: LD_INT 2
51311: PUSH
51312: LD_INT 2
51314: NEG
51315: PUSH
51316: EMPTY
51317: LIST
51318: LIST
51319: PUSH
51320: LD_INT 4
51322: PUSH
51323: LD_INT 2
51325: PUSH
51326: EMPTY
51327: LIST
51328: LIST
51329: PUSH
51330: LD_INT 4
51332: PUSH
51333: LD_INT 4
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: PUSH
51340: LD_INT 4
51342: PUSH
51343: LD_INT 3
51345: PUSH
51346: EMPTY
51347: LIST
51348: LIST
51349: PUSH
51350: LD_INT 5
51352: PUSH
51353: LD_INT 4
51355: PUSH
51356: EMPTY
51357: LIST
51358: LIST
51359: PUSH
51360: LD_INT 5
51362: PUSH
51363: LD_INT 5
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: PUSH
51370: LD_INT 4
51372: PUSH
51373: LD_INT 5
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 3
51382: PUSH
51383: LD_INT 4
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: PUSH
51390: LD_INT 3
51392: PUSH
51393: LD_INT 3
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PUSH
51400: LD_INT 5
51402: PUSH
51403: LD_INT 3
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 3
51412: PUSH
51413: LD_INT 5
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PUSH
51420: LD_INT 0
51422: PUSH
51423: LD_INT 3
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 0
51432: PUSH
51433: LD_INT 2
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: PUSH
51440: LD_INT 1
51442: PUSH
51443: LD_INT 3
51445: PUSH
51446: EMPTY
51447: LIST
51448: LIST
51449: PUSH
51450: LD_INT 1
51452: PUSH
51453: LD_INT 4
51455: PUSH
51456: EMPTY
51457: LIST
51458: LIST
51459: PUSH
51460: LD_INT 0
51462: PUSH
51463: LD_INT 4
51465: PUSH
51466: EMPTY
51467: LIST
51468: LIST
51469: PUSH
51470: LD_INT 1
51472: NEG
51473: PUSH
51474: LD_INT 3
51476: PUSH
51477: EMPTY
51478: LIST
51479: LIST
51480: PUSH
51481: LD_INT 1
51483: NEG
51484: PUSH
51485: LD_INT 2
51487: PUSH
51488: EMPTY
51489: LIST
51490: LIST
51491: PUSH
51492: LD_INT 2
51494: PUSH
51495: LD_INT 4
51497: PUSH
51498: EMPTY
51499: LIST
51500: LIST
51501: PUSH
51502: LD_INT 2
51504: NEG
51505: PUSH
51506: LD_INT 2
51508: PUSH
51509: EMPTY
51510: LIST
51511: LIST
51512: PUSH
51513: LD_INT 4
51515: NEG
51516: PUSH
51517: LD_INT 0
51519: PUSH
51520: EMPTY
51521: LIST
51522: LIST
51523: PUSH
51524: LD_INT 4
51526: NEG
51527: PUSH
51528: LD_INT 1
51530: NEG
51531: PUSH
51532: EMPTY
51533: LIST
51534: LIST
51535: PUSH
51536: LD_INT 3
51538: NEG
51539: PUSH
51540: LD_INT 0
51542: PUSH
51543: EMPTY
51544: LIST
51545: LIST
51546: PUSH
51547: LD_INT 3
51549: NEG
51550: PUSH
51551: LD_INT 1
51553: PUSH
51554: EMPTY
51555: LIST
51556: LIST
51557: PUSH
51558: LD_INT 4
51560: NEG
51561: PUSH
51562: LD_INT 1
51564: PUSH
51565: EMPTY
51566: LIST
51567: LIST
51568: PUSH
51569: LD_INT 5
51571: NEG
51572: PUSH
51573: LD_INT 0
51575: PUSH
51576: EMPTY
51577: LIST
51578: LIST
51579: PUSH
51580: LD_INT 5
51582: NEG
51583: PUSH
51584: LD_INT 1
51586: NEG
51587: PUSH
51588: EMPTY
51589: LIST
51590: LIST
51591: PUSH
51592: LD_INT 5
51594: NEG
51595: PUSH
51596: LD_INT 2
51598: NEG
51599: PUSH
51600: EMPTY
51601: LIST
51602: LIST
51603: PUSH
51604: LD_INT 3
51606: NEG
51607: PUSH
51608: LD_INT 2
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: PUSH
51615: EMPTY
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: LIST
51627: LIST
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: LIST
51650: LIST
51651: LIST
51652: LIST
51653: LIST
51654: LIST
51655: LIST
51656: LIST
51657: LIST
51658: LIST
51659: LIST
51660: LIST
51661: ST_TO_ADDR
// end ; end ;
51662: GO 51665
51664: POP
// case btype of b_depot , b_warehouse :
51665: LD_VAR 0 1
51669: PUSH
51670: LD_INT 0
51672: DOUBLE
51673: EQUAL
51674: IFTRUE 51684
51676: LD_INT 1
51678: DOUBLE
51679: EQUAL
51680: IFTRUE 51684
51682: GO 51885
51684: POP
// case nation of nation_american :
51685: LD_VAR 0 5
51689: PUSH
51690: LD_INT 1
51692: DOUBLE
51693: EQUAL
51694: IFTRUE 51698
51696: GO 51754
51698: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51699: LD_ADDR_VAR 0 9
51703: PUSH
51704: LD_VAR 0 11
51708: PUSH
51709: LD_VAR 0 12
51713: PUSH
51714: LD_VAR 0 13
51718: PUSH
51719: LD_VAR 0 14
51723: PUSH
51724: LD_VAR 0 15
51728: PUSH
51729: LD_VAR 0 16
51733: PUSH
51734: EMPTY
51735: LIST
51736: LIST
51737: LIST
51738: LIST
51739: LIST
51740: LIST
51741: PUSH
51742: LD_VAR 0 4
51746: PUSH
51747: LD_INT 1
51749: PLUS
51750: ARRAY
51751: ST_TO_ADDR
51752: GO 51883
51754: LD_INT 2
51756: DOUBLE
51757: EQUAL
51758: IFTRUE 51762
51760: GO 51818
51762: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51763: LD_ADDR_VAR 0 9
51767: PUSH
51768: LD_VAR 0 17
51772: PUSH
51773: LD_VAR 0 18
51777: PUSH
51778: LD_VAR 0 19
51782: PUSH
51783: LD_VAR 0 20
51787: PUSH
51788: LD_VAR 0 21
51792: PUSH
51793: LD_VAR 0 22
51797: PUSH
51798: EMPTY
51799: LIST
51800: LIST
51801: LIST
51802: LIST
51803: LIST
51804: LIST
51805: PUSH
51806: LD_VAR 0 4
51810: PUSH
51811: LD_INT 1
51813: PLUS
51814: ARRAY
51815: ST_TO_ADDR
51816: GO 51883
51818: LD_INT 3
51820: DOUBLE
51821: EQUAL
51822: IFTRUE 51826
51824: GO 51882
51826: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51827: LD_ADDR_VAR 0 9
51831: PUSH
51832: LD_VAR 0 23
51836: PUSH
51837: LD_VAR 0 24
51841: PUSH
51842: LD_VAR 0 25
51846: PUSH
51847: LD_VAR 0 26
51851: PUSH
51852: LD_VAR 0 27
51856: PUSH
51857: LD_VAR 0 28
51861: PUSH
51862: EMPTY
51863: LIST
51864: LIST
51865: LIST
51866: LIST
51867: LIST
51868: LIST
51869: PUSH
51870: LD_VAR 0 4
51874: PUSH
51875: LD_INT 1
51877: PLUS
51878: ARRAY
51879: ST_TO_ADDR
51880: GO 51883
51882: POP
51883: GO 52438
51885: LD_INT 2
51887: DOUBLE
51888: EQUAL
51889: IFTRUE 51899
51891: LD_INT 3
51893: DOUBLE
51894: EQUAL
51895: IFTRUE 51899
51897: GO 51955
51899: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51900: LD_ADDR_VAR 0 9
51904: PUSH
51905: LD_VAR 0 29
51909: PUSH
51910: LD_VAR 0 30
51914: PUSH
51915: LD_VAR 0 31
51919: PUSH
51920: LD_VAR 0 32
51924: PUSH
51925: LD_VAR 0 33
51929: PUSH
51930: LD_VAR 0 34
51934: PUSH
51935: EMPTY
51936: LIST
51937: LIST
51938: LIST
51939: LIST
51940: LIST
51941: LIST
51942: PUSH
51943: LD_VAR 0 4
51947: PUSH
51948: LD_INT 1
51950: PLUS
51951: ARRAY
51952: ST_TO_ADDR
51953: GO 52438
51955: LD_INT 16
51957: DOUBLE
51958: EQUAL
51959: IFTRUE 52017
51961: LD_INT 17
51963: DOUBLE
51964: EQUAL
51965: IFTRUE 52017
51967: LD_INT 18
51969: DOUBLE
51970: EQUAL
51971: IFTRUE 52017
51973: LD_INT 19
51975: DOUBLE
51976: EQUAL
51977: IFTRUE 52017
51979: LD_INT 22
51981: DOUBLE
51982: EQUAL
51983: IFTRUE 52017
51985: LD_INT 20
51987: DOUBLE
51988: EQUAL
51989: IFTRUE 52017
51991: LD_INT 21
51993: DOUBLE
51994: EQUAL
51995: IFTRUE 52017
51997: LD_INT 23
51999: DOUBLE
52000: EQUAL
52001: IFTRUE 52017
52003: LD_INT 24
52005: DOUBLE
52006: EQUAL
52007: IFTRUE 52017
52009: LD_INT 25
52011: DOUBLE
52012: EQUAL
52013: IFTRUE 52017
52015: GO 52073
52017: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
52018: LD_ADDR_VAR 0 9
52022: PUSH
52023: LD_VAR 0 35
52027: PUSH
52028: LD_VAR 0 36
52032: PUSH
52033: LD_VAR 0 37
52037: PUSH
52038: LD_VAR 0 38
52042: PUSH
52043: LD_VAR 0 39
52047: PUSH
52048: LD_VAR 0 40
52052: PUSH
52053: EMPTY
52054: LIST
52055: LIST
52056: LIST
52057: LIST
52058: LIST
52059: LIST
52060: PUSH
52061: LD_VAR 0 4
52065: PUSH
52066: LD_INT 1
52068: PLUS
52069: ARRAY
52070: ST_TO_ADDR
52071: GO 52438
52073: LD_INT 6
52075: DOUBLE
52076: EQUAL
52077: IFTRUE 52129
52079: LD_INT 7
52081: DOUBLE
52082: EQUAL
52083: IFTRUE 52129
52085: LD_INT 8
52087: DOUBLE
52088: EQUAL
52089: IFTRUE 52129
52091: LD_INT 13
52093: DOUBLE
52094: EQUAL
52095: IFTRUE 52129
52097: LD_INT 12
52099: DOUBLE
52100: EQUAL
52101: IFTRUE 52129
52103: LD_INT 15
52105: DOUBLE
52106: EQUAL
52107: IFTRUE 52129
52109: LD_INT 11
52111: DOUBLE
52112: EQUAL
52113: IFTRUE 52129
52115: LD_INT 14
52117: DOUBLE
52118: EQUAL
52119: IFTRUE 52129
52121: LD_INT 10
52123: DOUBLE
52124: EQUAL
52125: IFTRUE 52129
52127: GO 52185
52129: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
52130: LD_ADDR_VAR 0 9
52134: PUSH
52135: LD_VAR 0 41
52139: PUSH
52140: LD_VAR 0 42
52144: PUSH
52145: LD_VAR 0 43
52149: PUSH
52150: LD_VAR 0 44
52154: PUSH
52155: LD_VAR 0 45
52159: PUSH
52160: LD_VAR 0 46
52164: PUSH
52165: EMPTY
52166: LIST
52167: LIST
52168: LIST
52169: LIST
52170: LIST
52171: LIST
52172: PUSH
52173: LD_VAR 0 4
52177: PUSH
52178: LD_INT 1
52180: PLUS
52181: ARRAY
52182: ST_TO_ADDR
52183: GO 52438
52185: LD_INT 36
52187: DOUBLE
52188: EQUAL
52189: IFTRUE 52193
52191: GO 52249
52193: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52194: LD_ADDR_VAR 0 9
52198: PUSH
52199: LD_VAR 0 47
52203: PUSH
52204: LD_VAR 0 48
52208: PUSH
52209: LD_VAR 0 49
52213: PUSH
52214: LD_VAR 0 50
52218: PUSH
52219: LD_VAR 0 51
52223: PUSH
52224: LD_VAR 0 52
52228: PUSH
52229: EMPTY
52230: LIST
52231: LIST
52232: LIST
52233: LIST
52234: LIST
52235: LIST
52236: PUSH
52237: LD_VAR 0 4
52241: PUSH
52242: LD_INT 1
52244: PLUS
52245: ARRAY
52246: ST_TO_ADDR
52247: GO 52438
52249: LD_INT 4
52251: DOUBLE
52252: EQUAL
52253: IFTRUE 52275
52255: LD_INT 5
52257: DOUBLE
52258: EQUAL
52259: IFTRUE 52275
52261: LD_INT 34
52263: DOUBLE
52264: EQUAL
52265: IFTRUE 52275
52267: LD_INT 37
52269: DOUBLE
52270: EQUAL
52271: IFTRUE 52275
52273: GO 52331
52275: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52276: LD_ADDR_VAR 0 9
52280: PUSH
52281: LD_VAR 0 53
52285: PUSH
52286: LD_VAR 0 54
52290: PUSH
52291: LD_VAR 0 55
52295: PUSH
52296: LD_VAR 0 56
52300: PUSH
52301: LD_VAR 0 57
52305: PUSH
52306: LD_VAR 0 58
52310: PUSH
52311: EMPTY
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: PUSH
52319: LD_VAR 0 4
52323: PUSH
52324: LD_INT 1
52326: PLUS
52327: ARRAY
52328: ST_TO_ADDR
52329: GO 52438
52331: LD_INT 31
52333: DOUBLE
52334: EQUAL
52335: IFTRUE 52381
52337: LD_INT 32
52339: DOUBLE
52340: EQUAL
52341: IFTRUE 52381
52343: LD_INT 33
52345: DOUBLE
52346: EQUAL
52347: IFTRUE 52381
52349: LD_INT 27
52351: DOUBLE
52352: EQUAL
52353: IFTRUE 52381
52355: LD_INT 26
52357: DOUBLE
52358: EQUAL
52359: IFTRUE 52381
52361: LD_INT 28
52363: DOUBLE
52364: EQUAL
52365: IFTRUE 52381
52367: LD_INT 29
52369: DOUBLE
52370: EQUAL
52371: IFTRUE 52381
52373: LD_INT 30
52375: DOUBLE
52376: EQUAL
52377: IFTRUE 52381
52379: GO 52437
52381: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52382: LD_ADDR_VAR 0 9
52386: PUSH
52387: LD_VAR 0 59
52391: PUSH
52392: LD_VAR 0 60
52396: PUSH
52397: LD_VAR 0 61
52401: PUSH
52402: LD_VAR 0 62
52406: PUSH
52407: LD_VAR 0 63
52411: PUSH
52412: LD_VAR 0 64
52416: PUSH
52417: EMPTY
52418: LIST
52419: LIST
52420: LIST
52421: LIST
52422: LIST
52423: LIST
52424: PUSH
52425: LD_VAR 0 4
52429: PUSH
52430: LD_INT 1
52432: PLUS
52433: ARRAY
52434: ST_TO_ADDR
52435: GO 52438
52437: POP
// temp_list2 = [ ] ;
52438: LD_ADDR_VAR 0 10
52442: PUSH
52443: EMPTY
52444: ST_TO_ADDR
// for i in temp_list do
52445: LD_ADDR_VAR 0 8
52449: PUSH
52450: LD_VAR 0 9
52454: PUSH
52455: FOR_IN
52456: IFFALSE 52508
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52458: LD_ADDR_VAR 0 10
52462: PUSH
52463: LD_VAR 0 10
52467: PUSH
52468: LD_VAR 0 8
52472: PUSH
52473: LD_INT 1
52475: ARRAY
52476: PUSH
52477: LD_VAR 0 2
52481: PLUS
52482: PUSH
52483: LD_VAR 0 8
52487: PUSH
52488: LD_INT 2
52490: ARRAY
52491: PUSH
52492: LD_VAR 0 3
52496: PLUS
52497: PUSH
52498: EMPTY
52499: LIST
52500: LIST
52501: PUSH
52502: EMPTY
52503: LIST
52504: ADD
52505: ST_TO_ADDR
52506: GO 52455
52508: POP
52509: POP
// result = temp_list2 ;
52510: LD_ADDR_VAR 0 7
52514: PUSH
52515: LD_VAR 0 10
52519: ST_TO_ADDR
// end ;
52520: LD_VAR 0 7
52524: RET
// export function EnemyInRange ( unit , dist ) ; begin
52525: LD_INT 0
52527: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52528: LD_ADDR_VAR 0 3
52532: PUSH
52533: LD_VAR 0 1
52537: PPUSH
52538: CALL_OW 255
52542: PPUSH
52543: LD_VAR 0 1
52547: PPUSH
52548: CALL_OW 250
52552: PPUSH
52553: LD_VAR 0 1
52557: PPUSH
52558: CALL_OW 251
52562: PPUSH
52563: LD_VAR 0 2
52567: PPUSH
52568: CALL 25921 0 4
52572: PUSH
52573: LD_INT 4
52575: ARRAY
52576: ST_TO_ADDR
// end ;
52577: LD_VAR 0 3
52581: RET
// export function PlayerSeeMe ( unit ) ; begin
52582: LD_INT 0
52584: PPUSH
// result := See ( your_side , unit ) ;
52585: LD_ADDR_VAR 0 2
52589: PUSH
52590: LD_OWVAR 2
52594: PPUSH
52595: LD_VAR 0 1
52599: PPUSH
52600: CALL_OW 292
52604: ST_TO_ADDR
// end ;
52605: LD_VAR 0 2
52609: RET
// export function ReverseDir ( unit ) ; begin
52610: LD_INT 0
52612: PPUSH
// if not unit then
52613: LD_VAR 0 1
52617: NOT
52618: IFFALSE 52622
// exit ;
52620: GO 52645
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52622: LD_ADDR_VAR 0 2
52626: PUSH
52627: LD_VAR 0 1
52631: PPUSH
52632: CALL_OW 254
52636: PUSH
52637: LD_INT 3
52639: PLUS
52640: PUSH
52641: LD_INT 6
52643: MOD
52644: ST_TO_ADDR
// end ;
52645: LD_VAR 0 2
52649: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
52650: LD_INT 0
52652: PPUSH
52653: PPUSH
52654: PPUSH
52655: PPUSH
52656: PPUSH
// if not hexes then
52657: LD_VAR 0 2
52661: NOT
52662: IFFALSE 52666
// exit ;
52664: GO 52814
// dist := 9999 ;
52666: LD_ADDR_VAR 0 5
52670: PUSH
52671: LD_INT 9999
52673: ST_TO_ADDR
// for i = 1 to hexes do
52674: LD_ADDR_VAR 0 4
52678: PUSH
52679: DOUBLE
52680: LD_INT 1
52682: DEC
52683: ST_TO_ADDR
52684: LD_VAR 0 2
52688: PUSH
52689: FOR_TO
52690: IFFALSE 52802
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
52692: LD_VAR 0 1
52696: PPUSH
52697: LD_VAR 0 2
52701: PUSH
52702: LD_VAR 0 4
52706: ARRAY
52707: PUSH
52708: LD_INT 1
52710: ARRAY
52711: PPUSH
52712: LD_VAR 0 2
52716: PUSH
52717: LD_VAR 0 4
52721: ARRAY
52722: PUSH
52723: LD_INT 2
52725: ARRAY
52726: PPUSH
52727: CALL_OW 297
52731: PUSH
52732: LD_VAR 0 5
52736: LESS
52737: IFFALSE 52800
// begin hex := hexes [ i ] ;
52739: LD_ADDR_VAR 0 7
52743: PUSH
52744: LD_VAR 0 2
52748: PUSH
52749: LD_VAR 0 4
52753: ARRAY
52754: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52755: LD_ADDR_VAR 0 5
52759: PUSH
52760: LD_VAR 0 1
52764: PPUSH
52765: LD_VAR 0 2
52769: PUSH
52770: LD_VAR 0 4
52774: ARRAY
52775: PUSH
52776: LD_INT 1
52778: ARRAY
52779: PPUSH
52780: LD_VAR 0 2
52784: PUSH
52785: LD_VAR 0 4
52789: ARRAY
52790: PUSH
52791: LD_INT 2
52793: ARRAY
52794: PPUSH
52795: CALL_OW 297
52799: ST_TO_ADDR
// end ; end ;
52800: GO 52689
52802: POP
52803: POP
// result := hex ;
52804: LD_ADDR_VAR 0 3
52808: PUSH
52809: LD_VAR 0 7
52813: ST_TO_ADDR
// end ;
52814: LD_VAR 0 3
52818: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52819: LD_INT 0
52821: PPUSH
52822: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52823: LD_VAR 0 1
52827: NOT
52828: PUSH
52829: LD_VAR 0 1
52833: PUSH
52834: LD_INT 21
52836: PUSH
52837: LD_INT 2
52839: PUSH
52840: EMPTY
52841: LIST
52842: LIST
52843: PUSH
52844: LD_INT 23
52846: PUSH
52847: LD_INT 2
52849: PUSH
52850: EMPTY
52851: LIST
52852: LIST
52853: PUSH
52854: EMPTY
52855: LIST
52856: LIST
52857: PPUSH
52858: CALL_OW 69
52862: IN
52863: NOT
52864: OR
52865: IFFALSE 52869
// exit ;
52867: GO 52916
// for i = 1 to 3 do
52869: LD_ADDR_VAR 0 3
52873: PUSH
52874: DOUBLE
52875: LD_INT 1
52877: DEC
52878: ST_TO_ADDR
52879: LD_INT 3
52881: PUSH
52882: FOR_TO
52883: IFFALSE 52914
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52885: LD_VAR 0 1
52889: PPUSH
52890: CALL_OW 250
52894: PPUSH
52895: LD_VAR 0 1
52899: PPUSH
52900: CALL_OW 251
52904: PPUSH
52905: LD_INT 1
52907: PPUSH
52908: CALL_OW 453
52912: GO 52882
52914: POP
52915: POP
// end ;
52916: LD_VAR 0 2
52920: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52921: LD_INT 0
52923: PPUSH
52924: PPUSH
52925: PPUSH
52926: PPUSH
52927: PPUSH
52928: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52929: LD_VAR 0 1
52933: NOT
52934: PUSH
52935: LD_VAR 0 2
52939: NOT
52940: OR
52941: PUSH
52942: LD_VAR 0 1
52946: PPUSH
52947: CALL_OW 314
52951: OR
52952: IFFALSE 52956
// exit ;
52954: GO 53397
// x := GetX ( enemy_unit ) ;
52956: LD_ADDR_VAR 0 7
52960: PUSH
52961: LD_VAR 0 2
52965: PPUSH
52966: CALL_OW 250
52970: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52971: LD_ADDR_VAR 0 8
52975: PUSH
52976: LD_VAR 0 2
52980: PPUSH
52981: CALL_OW 251
52985: ST_TO_ADDR
// if not x or not y then
52986: LD_VAR 0 7
52990: NOT
52991: PUSH
52992: LD_VAR 0 8
52996: NOT
52997: OR
52998: IFFALSE 53002
// exit ;
53000: GO 53397
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
53002: LD_ADDR_VAR 0 6
53006: PUSH
53007: LD_VAR 0 7
53011: PPUSH
53012: LD_INT 0
53014: PPUSH
53015: LD_INT 4
53017: PPUSH
53018: CALL_OW 272
53022: PUSH
53023: LD_VAR 0 8
53027: PPUSH
53028: LD_INT 0
53030: PPUSH
53031: LD_INT 4
53033: PPUSH
53034: CALL_OW 273
53038: PUSH
53039: EMPTY
53040: LIST
53041: LIST
53042: PUSH
53043: LD_VAR 0 7
53047: PPUSH
53048: LD_INT 1
53050: PPUSH
53051: LD_INT 4
53053: PPUSH
53054: CALL_OW 272
53058: PUSH
53059: LD_VAR 0 8
53063: PPUSH
53064: LD_INT 1
53066: PPUSH
53067: LD_INT 4
53069: PPUSH
53070: CALL_OW 273
53074: PUSH
53075: EMPTY
53076: LIST
53077: LIST
53078: PUSH
53079: LD_VAR 0 7
53083: PPUSH
53084: LD_INT 2
53086: PPUSH
53087: LD_INT 4
53089: PPUSH
53090: CALL_OW 272
53094: PUSH
53095: LD_VAR 0 8
53099: PPUSH
53100: LD_INT 2
53102: PPUSH
53103: LD_INT 4
53105: PPUSH
53106: CALL_OW 273
53110: PUSH
53111: EMPTY
53112: LIST
53113: LIST
53114: PUSH
53115: LD_VAR 0 7
53119: PPUSH
53120: LD_INT 3
53122: PPUSH
53123: LD_INT 4
53125: PPUSH
53126: CALL_OW 272
53130: PUSH
53131: LD_VAR 0 8
53135: PPUSH
53136: LD_INT 3
53138: PPUSH
53139: LD_INT 4
53141: PPUSH
53142: CALL_OW 273
53146: PUSH
53147: EMPTY
53148: LIST
53149: LIST
53150: PUSH
53151: LD_VAR 0 7
53155: PPUSH
53156: LD_INT 4
53158: PPUSH
53159: LD_INT 4
53161: PPUSH
53162: CALL_OW 272
53166: PUSH
53167: LD_VAR 0 8
53171: PPUSH
53172: LD_INT 4
53174: PPUSH
53175: LD_INT 4
53177: PPUSH
53178: CALL_OW 273
53182: PUSH
53183: EMPTY
53184: LIST
53185: LIST
53186: PUSH
53187: LD_VAR 0 7
53191: PPUSH
53192: LD_INT 5
53194: PPUSH
53195: LD_INT 4
53197: PPUSH
53198: CALL_OW 272
53202: PUSH
53203: LD_VAR 0 8
53207: PPUSH
53208: LD_INT 5
53210: PPUSH
53211: LD_INT 4
53213: PPUSH
53214: CALL_OW 273
53218: PUSH
53219: EMPTY
53220: LIST
53221: LIST
53222: PUSH
53223: EMPTY
53224: LIST
53225: LIST
53226: LIST
53227: LIST
53228: LIST
53229: LIST
53230: ST_TO_ADDR
// for i = tmp downto 1 do
53231: LD_ADDR_VAR 0 4
53235: PUSH
53236: DOUBLE
53237: LD_VAR 0 6
53241: INC
53242: ST_TO_ADDR
53243: LD_INT 1
53245: PUSH
53246: FOR_DOWNTO
53247: IFFALSE 53348
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53249: LD_VAR 0 6
53253: PUSH
53254: LD_VAR 0 4
53258: ARRAY
53259: PUSH
53260: LD_INT 1
53262: ARRAY
53263: PPUSH
53264: LD_VAR 0 6
53268: PUSH
53269: LD_VAR 0 4
53273: ARRAY
53274: PUSH
53275: LD_INT 2
53277: ARRAY
53278: PPUSH
53279: CALL_OW 488
53283: NOT
53284: PUSH
53285: LD_VAR 0 6
53289: PUSH
53290: LD_VAR 0 4
53294: ARRAY
53295: PUSH
53296: LD_INT 1
53298: ARRAY
53299: PPUSH
53300: LD_VAR 0 6
53304: PUSH
53305: LD_VAR 0 4
53309: ARRAY
53310: PUSH
53311: LD_INT 2
53313: ARRAY
53314: PPUSH
53315: CALL_OW 428
53319: PUSH
53320: LD_INT 0
53322: NONEQUAL
53323: OR
53324: IFFALSE 53346
// tmp := Delete ( tmp , i ) ;
53326: LD_ADDR_VAR 0 6
53330: PUSH
53331: LD_VAR 0 6
53335: PPUSH
53336: LD_VAR 0 4
53340: PPUSH
53341: CALL_OW 3
53345: ST_TO_ADDR
53346: GO 53246
53348: POP
53349: POP
// j := GetClosestHex ( unit , tmp ) ;
53350: LD_ADDR_VAR 0 5
53354: PUSH
53355: LD_VAR 0 1
53359: PPUSH
53360: LD_VAR 0 6
53364: PPUSH
53365: CALL 52650 0 2
53369: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53370: LD_VAR 0 1
53374: PPUSH
53375: LD_VAR 0 5
53379: PUSH
53380: LD_INT 1
53382: ARRAY
53383: PPUSH
53384: LD_VAR 0 5
53388: PUSH
53389: LD_INT 2
53391: ARRAY
53392: PPUSH
53393: CALL_OW 111
// end ;
53397: LD_VAR 0 3
53401: RET
// export function PrepareApemanSoldier ( ) ; begin
53402: LD_INT 0
53404: PPUSH
// uc_nation := 0 ;
53405: LD_ADDR_OWVAR 21
53409: PUSH
53410: LD_INT 0
53412: ST_TO_ADDR
// hc_sex := sex_male ;
53413: LD_ADDR_OWVAR 27
53417: PUSH
53418: LD_INT 1
53420: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
53421: LD_ADDR_OWVAR 28
53425: PUSH
53426: LD_INT 15
53428: ST_TO_ADDR
// hc_gallery :=  ;
53429: LD_ADDR_OWVAR 33
53433: PUSH
53434: LD_STRING 
53436: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53437: LD_ADDR_OWVAR 31
53441: PUSH
53442: LD_INT 0
53444: PPUSH
53445: LD_INT 3
53447: PPUSH
53448: CALL_OW 12
53452: PUSH
53453: LD_INT 0
53455: PPUSH
53456: LD_INT 3
53458: PPUSH
53459: CALL_OW 12
53463: PUSH
53464: LD_INT 0
53466: PUSH
53467: LD_INT 0
53469: PUSH
53470: EMPTY
53471: LIST
53472: LIST
53473: LIST
53474: LIST
53475: ST_TO_ADDR
// end ;
53476: LD_VAR 0 1
53480: RET
// export function PrepareApemanEngineer ( ) ; begin
53481: LD_INT 0
53483: PPUSH
// uc_nation := 0 ;
53484: LD_ADDR_OWVAR 21
53488: PUSH
53489: LD_INT 0
53491: ST_TO_ADDR
// hc_sex := sex_male ;
53492: LD_ADDR_OWVAR 27
53496: PUSH
53497: LD_INT 1
53499: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
53500: LD_ADDR_OWVAR 28
53504: PUSH
53505: LD_INT 16
53507: ST_TO_ADDR
// hc_gallery :=  ;
53508: LD_ADDR_OWVAR 33
53512: PUSH
53513: LD_STRING 
53515: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53516: LD_ADDR_OWVAR 31
53520: PUSH
53521: LD_INT 0
53523: PPUSH
53524: LD_INT 3
53526: PPUSH
53527: CALL_OW 12
53531: PUSH
53532: LD_INT 0
53534: PPUSH
53535: LD_INT 3
53537: PPUSH
53538: CALL_OW 12
53542: PUSH
53543: LD_INT 0
53545: PUSH
53546: LD_INT 0
53548: PUSH
53549: EMPTY
53550: LIST
53551: LIST
53552: LIST
53553: LIST
53554: ST_TO_ADDR
// end ;
53555: LD_VAR 0 1
53559: RET
// export function PrepareApeman ( agressivity ) ; begin
53560: LD_INT 0
53562: PPUSH
// uc_side := 0 ;
53563: LD_ADDR_OWVAR 20
53567: PUSH
53568: LD_INT 0
53570: ST_TO_ADDR
// uc_nation := 0 ;
53571: LD_ADDR_OWVAR 21
53575: PUSH
53576: LD_INT 0
53578: ST_TO_ADDR
// hc_sex := sex_male ;
53579: LD_ADDR_OWVAR 27
53583: PUSH
53584: LD_INT 1
53586: ST_TO_ADDR
// hc_class := class_apeman ;
53587: LD_ADDR_OWVAR 28
53591: PUSH
53592: LD_INT 12
53594: ST_TO_ADDR
// hc_gallery :=  ;
53595: LD_ADDR_OWVAR 33
53599: PUSH
53600: LD_STRING 
53602: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53603: LD_ADDR_OWVAR 35
53607: PUSH
53608: LD_VAR 0 1
53612: NEG
53613: PPUSH
53614: LD_VAR 0 1
53618: PPUSH
53619: CALL_OW 12
53623: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53624: LD_ADDR_OWVAR 31
53628: PUSH
53629: LD_INT 0
53631: PPUSH
53632: LD_INT 3
53634: PPUSH
53635: CALL_OW 12
53639: PUSH
53640: LD_INT 0
53642: PPUSH
53643: LD_INT 3
53645: PPUSH
53646: CALL_OW 12
53650: PUSH
53651: LD_INT 0
53653: PUSH
53654: LD_INT 0
53656: PUSH
53657: EMPTY
53658: LIST
53659: LIST
53660: LIST
53661: LIST
53662: ST_TO_ADDR
// end ;
53663: LD_VAR 0 2
53667: RET
// export function PrepareTiger ( agressivity ) ; begin
53668: LD_INT 0
53670: PPUSH
// uc_side := 0 ;
53671: LD_ADDR_OWVAR 20
53675: PUSH
53676: LD_INT 0
53678: ST_TO_ADDR
// uc_nation := 0 ;
53679: LD_ADDR_OWVAR 21
53683: PUSH
53684: LD_INT 0
53686: ST_TO_ADDR
// hc_class := class_tiger ;
53687: LD_ADDR_OWVAR 28
53691: PUSH
53692: LD_INT 14
53694: ST_TO_ADDR
// hc_gallery :=  ;
53695: LD_ADDR_OWVAR 33
53699: PUSH
53700: LD_STRING 
53702: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53703: LD_ADDR_OWVAR 35
53707: PUSH
53708: LD_VAR 0 1
53712: NEG
53713: PPUSH
53714: LD_VAR 0 1
53718: PPUSH
53719: CALL_OW 12
53723: ST_TO_ADDR
// end ;
53724: LD_VAR 0 2
53728: RET
// export function PrepareEnchidna ( ) ; begin
53729: LD_INT 0
53731: PPUSH
// uc_side := 0 ;
53732: LD_ADDR_OWVAR 20
53736: PUSH
53737: LD_INT 0
53739: ST_TO_ADDR
// uc_nation := 0 ;
53740: LD_ADDR_OWVAR 21
53744: PUSH
53745: LD_INT 0
53747: ST_TO_ADDR
// hc_class := class_baggie ;
53748: LD_ADDR_OWVAR 28
53752: PUSH
53753: LD_INT 13
53755: ST_TO_ADDR
// hc_gallery :=  ;
53756: LD_ADDR_OWVAR 33
53760: PUSH
53761: LD_STRING 
53763: ST_TO_ADDR
// end ;
53764: LD_VAR 0 1
53768: RET
// export function PrepareFrog ( ) ; begin
53769: LD_INT 0
53771: PPUSH
// uc_side := 0 ;
53772: LD_ADDR_OWVAR 20
53776: PUSH
53777: LD_INT 0
53779: ST_TO_ADDR
// uc_nation := 0 ;
53780: LD_ADDR_OWVAR 21
53784: PUSH
53785: LD_INT 0
53787: ST_TO_ADDR
// hc_class := class_frog ;
53788: LD_ADDR_OWVAR 28
53792: PUSH
53793: LD_INT 19
53795: ST_TO_ADDR
// hc_gallery :=  ;
53796: LD_ADDR_OWVAR 33
53800: PUSH
53801: LD_STRING 
53803: ST_TO_ADDR
// end ;
53804: LD_VAR 0 1
53808: RET
// export function PrepareFish ( ) ; begin
53809: LD_INT 0
53811: PPUSH
// uc_side := 0 ;
53812: LD_ADDR_OWVAR 20
53816: PUSH
53817: LD_INT 0
53819: ST_TO_ADDR
// uc_nation := 0 ;
53820: LD_ADDR_OWVAR 21
53824: PUSH
53825: LD_INT 0
53827: ST_TO_ADDR
// hc_class := class_fish ;
53828: LD_ADDR_OWVAR 28
53832: PUSH
53833: LD_INT 20
53835: ST_TO_ADDR
// hc_gallery :=  ;
53836: LD_ADDR_OWVAR 33
53840: PUSH
53841: LD_STRING 
53843: ST_TO_ADDR
// end ;
53844: LD_VAR 0 1
53848: RET
// export function PrepareBird ( ) ; begin
53849: LD_INT 0
53851: PPUSH
// uc_side := 0 ;
53852: LD_ADDR_OWVAR 20
53856: PUSH
53857: LD_INT 0
53859: ST_TO_ADDR
// uc_nation := 0 ;
53860: LD_ADDR_OWVAR 21
53864: PUSH
53865: LD_INT 0
53867: ST_TO_ADDR
// hc_class := class_phororhacos ;
53868: LD_ADDR_OWVAR 28
53872: PUSH
53873: LD_INT 18
53875: ST_TO_ADDR
// hc_gallery :=  ;
53876: LD_ADDR_OWVAR 33
53880: PUSH
53881: LD_STRING 
53883: ST_TO_ADDR
// end ;
53884: LD_VAR 0 1
53888: RET
// export function PrepareHorse ( ) ; begin
53889: LD_INT 0
53891: PPUSH
// uc_side := 0 ;
53892: LD_ADDR_OWVAR 20
53896: PUSH
53897: LD_INT 0
53899: ST_TO_ADDR
// uc_nation := 0 ;
53900: LD_ADDR_OWVAR 21
53904: PUSH
53905: LD_INT 0
53907: ST_TO_ADDR
// hc_class := class_horse ;
53908: LD_ADDR_OWVAR 28
53912: PUSH
53913: LD_INT 21
53915: ST_TO_ADDR
// hc_gallery :=  ;
53916: LD_ADDR_OWVAR 33
53920: PUSH
53921: LD_STRING 
53923: ST_TO_ADDR
// end ;
53924: LD_VAR 0 1
53928: RET
// export function PrepareMastodont ( ) ; begin
53929: LD_INT 0
53931: PPUSH
// uc_side := 0 ;
53932: LD_ADDR_OWVAR 20
53936: PUSH
53937: LD_INT 0
53939: ST_TO_ADDR
// uc_nation := 0 ;
53940: LD_ADDR_OWVAR 21
53944: PUSH
53945: LD_INT 0
53947: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53948: LD_ADDR_OWVAR 37
53952: PUSH
53953: LD_INT 31
53955: ST_TO_ADDR
// vc_control := control_rider ;
53956: LD_ADDR_OWVAR 38
53960: PUSH
53961: LD_INT 4
53963: ST_TO_ADDR
// end ;
53964: LD_VAR 0 1
53968: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53969: LD_INT 0
53971: PPUSH
53972: PPUSH
53973: PPUSH
// uc_side = 0 ;
53974: LD_ADDR_OWVAR 20
53978: PUSH
53979: LD_INT 0
53981: ST_TO_ADDR
// uc_nation = 0 ;
53982: LD_ADDR_OWVAR 21
53986: PUSH
53987: LD_INT 0
53989: ST_TO_ADDR
// InitHc_All ( ) ;
53990: CALL_OW 584
// InitVc ;
53994: CALL_OW 20
// if mastodonts then
53998: LD_VAR 0 6
54002: IFFALSE 54069
// for i = 1 to mastodonts do
54004: LD_ADDR_VAR 0 11
54008: PUSH
54009: DOUBLE
54010: LD_INT 1
54012: DEC
54013: ST_TO_ADDR
54014: LD_VAR 0 6
54018: PUSH
54019: FOR_TO
54020: IFFALSE 54067
// begin vc_chassis := 31 ;
54022: LD_ADDR_OWVAR 37
54026: PUSH
54027: LD_INT 31
54029: ST_TO_ADDR
// vc_control := control_rider ;
54030: LD_ADDR_OWVAR 38
54034: PUSH
54035: LD_INT 4
54037: ST_TO_ADDR
// animal := CreateVehicle ;
54038: LD_ADDR_VAR 0 12
54042: PUSH
54043: CALL_OW 45
54047: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54048: LD_VAR 0 12
54052: PPUSH
54053: LD_VAR 0 8
54057: PPUSH
54058: LD_INT 0
54060: PPUSH
54061: CALL 56204 0 3
// end ;
54065: GO 54019
54067: POP
54068: POP
// if horses then
54069: LD_VAR 0 5
54073: IFFALSE 54140
// for i = 1 to horses do
54075: LD_ADDR_VAR 0 11
54079: PUSH
54080: DOUBLE
54081: LD_INT 1
54083: DEC
54084: ST_TO_ADDR
54085: LD_VAR 0 5
54089: PUSH
54090: FOR_TO
54091: IFFALSE 54138
// begin hc_class := 21 ;
54093: LD_ADDR_OWVAR 28
54097: PUSH
54098: LD_INT 21
54100: ST_TO_ADDR
// hc_gallery :=  ;
54101: LD_ADDR_OWVAR 33
54105: PUSH
54106: LD_STRING 
54108: ST_TO_ADDR
// animal := CreateHuman ;
54109: LD_ADDR_VAR 0 12
54113: PUSH
54114: CALL_OW 44
54118: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54119: LD_VAR 0 12
54123: PPUSH
54124: LD_VAR 0 8
54128: PPUSH
54129: LD_INT 0
54131: PPUSH
54132: CALL 56204 0 3
// end ;
54136: GO 54090
54138: POP
54139: POP
// if birds then
54140: LD_VAR 0 1
54144: IFFALSE 54211
// for i = 1 to birds do
54146: LD_ADDR_VAR 0 11
54150: PUSH
54151: DOUBLE
54152: LD_INT 1
54154: DEC
54155: ST_TO_ADDR
54156: LD_VAR 0 1
54160: PUSH
54161: FOR_TO
54162: IFFALSE 54209
// begin hc_class = 18 ;
54164: LD_ADDR_OWVAR 28
54168: PUSH
54169: LD_INT 18
54171: ST_TO_ADDR
// hc_gallery =  ;
54172: LD_ADDR_OWVAR 33
54176: PUSH
54177: LD_STRING 
54179: ST_TO_ADDR
// animal := CreateHuman ;
54180: LD_ADDR_VAR 0 12
54184: PUSH
54185: CALL_OW 44
54189: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54190: LD_VAR 0 12
54194: PPUSH
54195: LD_VAR 0 8
54199: PPUSH
54200: LD_INT 0
54202: PPUSH
54203: CALL 56204 0 3
// end ;
54207: GO 54161
54209: POP
54210: POP
// if tigers then
54211: LD_VAR 0 2
54215: IFFALSE 54299
// for i = 1 to tigers do
54217: LD_ADDR_VAR 0 11
54221: PUSH
54222: DOUBLE
54223: LD_INT 1
54225: DEC
54226: ST_TO_ADDR
54227: LD_VAR 0 2
54231: PUSH
54232: FOR_TO
54233: IFFALSE 54297
// begin hc_class = class_tiger ;
54235: LD_ADDR_OWVAR 28
54239: PUSH
54240: LD_INT 14
54242: ST_TO_ADDR
// hc_gallery =  ;
54243: LD_ADDR_OWVAR 33
54247: PUSH
54248: LD_STRING 
54250: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
54251: LD_ADDR_OWVAR 35
54255: PUSH
54256: LD_INT 7
54258: NEG
54259: PPUSH
54260: LD_INT 7
54262: PPUSH
54263: CALL_OW 12
54267: ST_TO_ADDR
// animal := CreateHuman ;
54268: LD_ADDR_VAR 0 12
54272: PUSH
54273: CALL_OW 44
54277: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54278: LD_VAR 0 12
54282: PPUSH
54283: LD_VAR 0 8
54287: PPUSH
54288: LD_INT 0
54290: PPUSH
54291: CALL 56204 0 3
// end ;
54295: GO 54232
54297: POP
54298: POP
// if apemans then
54299: LD_VAR 0 3
54303: IFFALSE 54426
// for i = 1 to apemans do
54305: LD_ADDR_VAR 0 11
54309: PUSH
54310: DOUBLE
54311: LD_INT 1
54313: DEC
54314: ST_TO_ADDR
54315: LD_VAR 0 3
54319: PUSH
54320: FOR_TO
54321: IFFALSE 54424
// begin hc_class = class_apeman ;
54323: LD_ADDR_OWVAR 28
54327: PUSH
54328: LD_INT 12
54330: ST_TO_ADDR
// hc_gallery =  ;
54331: LD_ADDR_OWVAR 33
54335: PUSH
54336: LD_STRING 
54338: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
54339: LD_ADDR_OWVAR 35
54343: PUSH
54344: LD_INT 2
54346: NEG
54347: PPUSH
54348: LD_INT 2
54350: PPUSH
54351: CALL_OW 12
54355: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
54356: LD_ADDR_OWVAR 31
54360: PUSH
54361: LD_INT 1
54363: PPUSH
54364: LD_INT 3
54366: PPUSH
54367: CALL_OW 12
54371: PUSH
54372: LD_INT 1
54374: PPUSH
54375: LD_INT 3
54377: PPUSH
54378: CALL_OW 12
54382: PUSH
54383: LD_INT 0
54385: PUSH
54386: LD_INT 0
54388: PUSH
54389: EMPTY
54390: LIST
54391: LIST
54392: LIST
54393: LIST
54394: ST_TO_ADDR
// animal := CreateHuman ;
54395: LD_ADDR_VAR 0 12
54399: PUSH
54400: CALL_OW 44
54404: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54405: LD_VAR 0 12
54409: PPUSH
54410: LD_VAR 0 8
54414: PPUSH
54415: LD_INT 0
54417: PPUSH
54418: CALL 56204 0 3
// end ;
54422: GO 54320
54424: POP
54425: POP
// if enchidnas then
54426: LD_VAR 0 4
54430: IFFALSE 54497
// for i = 1 to enchidnas do
54432: LD_ADDR_VAR 0 11
54436: PUSH
54437: DOUBLE
54438: LD_INT 1
54440: DEC
54441: ST_TO_ADDR
54442: LD_VAR 0 4
54446: PUSH
54447: FOR_TO
54448: IFFALSE 54495
// begin hc_class = 13 ;
54450: LD_ADDR_OWVAR 28
54454: PUSH
54455: LD_INT 13
54457: ST_TO_ADDR
// hc_gallery =  ;
54458: LD_ADDR_OWVAR 33
54462: PUSH
54463: LD_STRING 
54465: ST_TO_ADDR
// animal := CreateHuman ;
54466: LD_ADDR_VAR 0 12
54470: PUSH
54471: CALL_OW 44
54475: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54476: LD_VAR 0 12
54480: PPUSH
54481: LD_VAR 0 8
54485: PPUSH
54486: LD_INT 0
54488: PPUSH
54489: CALL 56204 0 3
// end ;
54493: GO 54447
54495: POP
54496: POP
// if fishes then
54497: LD_VAR 0 7
54501: IFFALSE 54568
// for i = 1 to fishes do
54503: LD_ADDR_VAR 0 11
54507: PUSH
54508: DOUBLE
54509: LD_INT 1
54511: DEC
54512: ST_TO_ADDR
54513: LD_VAR 0 7
54517: PUSH
54518: FOR_TO
54519: IFFALSE 54566
// begin hc_class = 20 ;
54521: LD_ADDR_OWVAR 28
54525: PUSH
54526: LD_INT 20
54528: ST_TO_ADDR
// hc_gallery =  ;
54529: LD_ADDR_OWVAR 33
54533: PUSH
54534: LD_STRING 
54536: ST_TO_ADDR
// animal := CreateHuman ;
54537: LD_ADDR_VAR 0 12
54541: PUSH
54542: CALL_OW 44
54546: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
54547: LD_VAR 0 12
54551: PPUSH
54552: LD_VAR 0 9
54556: PPUSH
54557: LD_INT 0
54559: PPUSH
54560: CALL 56204 0 3
// end ;
54564: GO 54518
54566: POP
54567: POP
// end ;
54568: LD_VAR 0 10
54572: RET
// export function WantHeal ( sci , unit ) ; begin
54573: LD_INT 0
54575: PPUSH
// if GetTaskList ( sci ) > 0 then
54576: LD_VAR 0 1
54580: PPUSH
54581: CALL_OW 437
54585: PUSH
54586: LD_INT 0
54588: GREATER
54589: IFFALSE 54659
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54591: LD_VAR 0 1
54595: PPUSH
54596: CALL_OW 437
54600: PUSH
54601: LD_INT 1
54603: ARRAY
54604: PUSH
54605: LD_INT 1
54607: ARRAY
54608: PUSH
54609: LD_STRING l
54611: EQUAL
54612: PUSH
54613: LD_VAR 0 1
54617: PPUSH
54618: CALL_OW 437
54622: PUSH
54623: LD_INT 1
54625: ARRAY
54626: PUSH
54627: LD_INT 4
54629: ARRAY
54630: PUSH
54631: LD_VAR 0 2
54635: EQUAL
54636: AND
54637: IFFALSE 54649
// result := true else
54639: LD_ADDR_VAR 0 3
54643: PUSH
54644: LD_INT 1
54646: ST_TO_ADDR
54647: GO 54657
// result := false ;
54649: LD_ADDR_VAR 0 3
54653: PUSH
54654: LD_INT 0
54656: ST_TO_ADDR
// end else
54657: GO 54667
// result := false ;
54659: LD_ADDR_VAR 0 3
54663: PUSH
54664: LD_INT 0
54666: ST_TO_ADDR
// end ;
54667: LD_VAR 0 3
54671: RET
// export function HealTarget ( sci ) ; begin
54672: LD_INT 0
54674: PPUSH
// if not sci then
54675: LD_VAR 0 1
54679: NOT
54680: IFFALSE 54684
// exit ;
54682: GO 54749
// result := 0 ;
54684: LD_ADDR_VAR 0 2
54688: PUSH
54689: LD_INT 0
54691: ST_TO_ADDR
// if GetTaskList ( sci ) then
54692: LD_VAR 0 1
54696: PPUSH
54697: CALL_OW 437
54701: IFFALSE 54749
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54703: LD_VAR 0 1
54707: PPUSH
54708: CALL_OW 437
54712: PUSH
54713: LD_INT 1
54715: ARRAY
54716: PUSH
54717: LD_INT 1
54719: ARRAY
54720: PUSH
54721: LD_STRING l
54723: EQUAL
54724: IFFALSE 54749
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54726: LD_ADDR_VAR 0 2
54730: PUSH
54731: LD_VAR 0 1
54735: PPUSH
54736: CALL_OW 437
54740: PUSH
54741: LD_INT 1
54743: ARRAY
54744: PUSH
54745: LD_INT 4
54747: ARRAY
54748: ST_TO_ADDR
// end ;
54749: LD_VAR 0 2
54753: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54754: LD_INT 0
54756: PPUSH
54757: PPUSH
54758: PPUSH
54759: PPUSH
// if not base_units then
54760: LD_VAR 0 1
54764: NOT
54765: IFFALSE 54769
// exit ;
54767: GO 54856
// result := false ;
54769: LD_ADDR_VAR 0 2
54773: PUSH
54774: LD_INT 0
54776: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54777: LD_ADDR_VAR 0 5
54781: PUSH
54782: LD_VAR 0 1
54786: PPUSH
54787: LD_INT 21
54789: PUSH
54790: LD_INT 3
54792: PUSH
54793: EMPTY
54794: LIST
54795: LIST
54796: PPUSH
54797: CALL_OW 72
54801: ST_TO_ADDR
// if not tmp then
54802: LD_VAR 0 5
54806: NOT
54807: IFFALSE 54811
// exit ;
54809: GO 54856
// for i in tmp do
54811: LD_ADDR_VAR 0 3
54815: PUSH
54816: LD_VAR 0 5
54820: PUSH
54821: FOR_IN
54822: IFFALSE 54854
// begin result := EnemyInRange ( i , 22 ) ;
54824: LD_ADDR_VAR 0 2
54828: PUSH
54829: LD_VAR 0 3
54833: PPUSH
54834: LD_INT 22
54836: PPUSH
54837: CALL 52525 0 2
54841: ST_TO_ADDR
// if result then
54842: LD_VAR 0 2
54846: IFFALSE 54852
// exit ;
54848: POP
54849: POP
54850: GO 54856
// end ;
54852: GO 54821
54854: POP
54855: POP
// end ;
54856: LD_VAR 0 2
54860: RET
// export function FilterByTag ( units , tag ) ; begin
54861: LD_INT 0
54863: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54864: LD_ADDR_VAR 0 3
54868: PUSH
54869: LD_VAR 0 1
54873: PPUSH
54874: LD_INT 120
54876: PUSH
54877: LD_VAR 0 2
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: PPUSH
54886: CALL_OW 72
54890: ST_TO_ADDR
// end ;
54891: LD_VAR 0 3
54895: RET
// export function IsDriver ( un ) ; begin
54896: LD_INT 0
54898: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54899: LD_ADDR_VAR 0 2
54903: PUSH
54904: LD_VAR 0 1
54908: PUSH
54909: LD_INT 55
54911: PUSH
54912: EMPTY
54913: LIST
54914: PPUSH
54915: CALL_OW 69
54919: IN
54920: ST_TO_ADDR
// end ;
54921: LD_VAR 0 2
54925: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54926: LD_INT 0
54928: PPUSH
54929: PPUSH
// list := [ ] ;
54930: LD_ADDR_VAR 0 5
54934: PUSH
54935: EMPTY
54936: ST_TO_ADDR
// case d of 0 :
54937: LD_VAR 0 3
54941: PUSH
54942: LD_INT 0
54944: DOUBLE
54945: EQUAL
54946: IFTRUE 54950
54948: GO 55083
54950: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54951: LD_ADDR_VAR 0 5
54955: PUSH
54956: LD_VAR 0 1
54960: PUSH
54961: LD_INT 4
54963: MINUS
54964: PUSH
54965: LD_VAR 0 2
54969: PUSH
54970: LD_INT 4
54972: MINUS
54973: PUSH
54974: LD_INT 2
54976: PUSH
54977: EMPTY
54978: LIST
54979: LIST
54980: LIST
54981: PUSH
54982: LD_VAR 0 1
54986: PUSH
54987: LD_INT 3
54989: MINUS
54990: PUSH
54991: LD_VAR 0 2
54995: PUSH
54996: LD_INT 1
54998: PUSH
54999: EMPTY
55000: LIST
55001: LIST
55002: LIST
55003: PUSH
55004: LD_VAR 0 1
55008: PUSH
55009: LD_INT 4
55011: PLUS
55012: PUSH
55013: LD_VAR 0 2
55017: PUSH
55018: LD_INT 4
55020: PUSH
55021: EMPTY
55022: LIST
55023: LIST
55024: LIST
55025: PUSH
55026: LD_VAR 0 1
55030: PUSH
55031: LD_INT 3
55033: PLUS
55034: PUSH
55035: LD_VAR 0 2
55039: PUSH
55040: LD_INT 3
55042: PLUS
55043: PUSH
55044: LD_INT 5
55046: PUSH
55047: EMPTY
55048: LIST
55049: LIST
55050: LIST
55051: PUSH
55052: LD_VAR 0 1
55056: PUSH
55057: LD_VAR 0 2
55061: PUSH
55062: LD_INT 4
55064: PLUS
55065: PUSH
55066: LD_INT 0
55068: PUSH
55069: EMPTY
55070: LIST
55071: LIST
55072: LIST
55073: PUSH
55074: EMPTY
55075: LIST
55076: LIST
55077: LIST
55078: LIST
55079: LIST
55080: ST_TO_ADDR
// end ; 1 :
55081: GO 55781
55083: LD_INT 1
55085: DOUBLE
55086: EQUAL
55087: IFTRUE 55091
55089: GO 55224
55091: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55092: LD_ADDR_VAR 0 5
55096: PUSH
55097: LD_VAR 0 1
55101: PUSH
55102: LD_VAR 0 2
55106: PUSH
55107: LD_INT 4
55109: MINUS
55110: PUSH
55111: LD_INT 3
55113: PUSH
55114: EMPTY
55115: LIST
55116: LIST
55117: LIST
55118: PUSH
55119: LD_VAR 0 1
55123: PUSH
55124: LD_INT 3
55126: MINUS
55127: PUSH
55128: LD_VAR 0 2
55132: PUSH
55133: LD_INT 3
55135: MINUS
55136: PUSH
55137: LD_INT 2
55139: PUSH
55140: EMPTY
55141: LIST
55142: LIST
55143: LIST
55144: PUSH
55145: LD_VAR 0 1
55149: PUSH
55150: LD_INT 4
55152: MINUS
55153: PUSH
55154: LD_VAR 0 2
55158: PUSH
55159: LD_INT 1
55161: PUSH
55162: EMPTY
55163: LIST
55164: LIST
55165: LIST
55166: PUSH
55167: LD_VAR 0 1
55171: PUSH
55172: LD_VAR 0 2
55176: PUSH
55177: LD_INT 3
55179: PLUS
55180: PUSH
55181: LD_INT 0
55183: PUSH
55184: EMPTY
55185: LIST
55186: LIST
55187: LIST
55188: PUSH
55189: LD_VAR 0 1
55193: PUSH
55194: LD_INT 4
55196: PLUS
55197: PUSH
55198: LD_VAR 0 2
55202: PUSH
55203: LD_INT 4
55205: PLUS
55206: PUSH
55207: LD_INT 5
55209: PUSH
55210: EMPTY
55211: LIST
55212: LIST
55213: LIST
55214: PUSH
55215: EMPTY
55216: LIST
55217: LIST
55218: LIST
55219: LIST
55220: LIST
55221: ST_TO_ADDR
// end ; 2 :
55222: GO 55781
55224: LD_INT 2
55226: DOUBLE
55227: EQUAL
55228: IFTRUE 55232
55230: GO 55361
55232: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55233: LD_ADDR_VAR 0 5
55237: PUSH
55238: LD_VAR 0 1
55242: PUSH
55243: LD_VAR 0 2
55247: PUSH
55248: LD_INT 3
55250: MINUS
55251: PUSH
55252: LD_INT 3
55254: PUSH
55255: EMPTY
55256: LIST
55257: LIST
55258: LIST
55259: PUSH
55260: LD_VAR 0 1
55264: PUSH
55265: LD_INT 4
55267: PLUS
55268: PUSH
55269: LD_VAR 0 2
55273: PUSH
55274: LD_INT 4
55276: PUSH
55277: EMPTY
55278: LIST
55279: LIST
55280: LIST
55281: PUSH
55282: LD_VAR 0 1
55286: PUSH
55287: LD_VAR 0 2
55291: PUSH
55292: LD_INT 4
55294: PLUS
55295: PUSH
55296: LD_INT 0
55298: PUSH
55299: EMPTY
55300: LIST
55301: LIST
55302: LIST
55303: PUSH
55304: LD_VAR 0 1
55308: PUSH
55309: LD_INT 3
55311: MINUS
55312: PUSH
55313: LD_VAR 0 2
55317: PUSH
55318: LD_INT 1
55320: PUSH
55321: EMPTY
55322: LIST
55323: LIST
55324: LIST
55325: PUSH
55326: LD_VAR 0 1
55330: PUSH
55331: LD_INT 4
55333: MINUS
55334: PUSH
55335: LD_VAR 0 2
55339: PUSH
55340: LD_INT 4
55342: MINUS
55343: PUSH
55344: LD_INT 2
55346: PUSH
55347: EMPTY
55348: LIST
55349: LIST
55350: LIST
55351: PUSH
55352: EMPTY
55353: LIST
55354: LIST
55355: LIST
55356: LIST
55357: LIST
55358: ST_TO_ADDR
// end ; 3 :
55359: GO 55781
55361: LD_INT 3
55363: DOUBLE
55364: EQUAL
55365: IFTRUE 55369
55367: GO 55502
55369: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55370: LD_ADDR_VAR 0 5
55374: PUSH
55375: LD_VAR 0 1
55379: PUSH
55380: LD_INT 3
55382: PLUS
55383: PUSH
55384: LD_VAR 0 2
55388: PUSH
55389: LD_INT 4
55391: PUSH
55392: EMPTY
55393: LIST
55394: LIST
55395: LIST
55396: PUSH
55397: LD_VAR 0 1
55401: PUSH
55402: LD_INT 4
55404: PLUS
55405: PUSH
55406: LD_VAR 0 2
55410: PUSH
55411: LD_INT 4
55413: PLUS
55414: PUSH
55415: LD_INT 5
55417: PUSH
55418: EMPTY
55419: LIST
55420: LIST
55421: LIST
55422: PUSH
55423: LD_VAR 0 1
55427: PUSH
55428: LD_INT 4
55430: MINUS
55431: PUSH
55432: LD_VAR 0 2
55436: PUSH
55437: LD_INT 1
55439: PUSH
55440: EMPTY
55441: LIST
55442: LIST
55443: LIST
55444: PUSH
55445: LD_VAR 0 1
55449: PUSH
55450: LD_VAR 0 2
55454: PUSH
55455: LD_INT 4
55457: MINUS
55458: PUSH
55459: LD_INT 3
55461: PUSH
55462: EMPTY
55463: LIST
55464: LIST
55465: LIST
55466: PUSH
55467: LD_VAR 0 1
55471: PUSH
55472: LD_INT 3
55474: MINUS
55475: PUSH
55476: LD_VAR 0 2
55480: PUSH
55481: LD_INT 3
55483: MINUS
55484: PUSH
55485: LD_INT 2
55487: PUSH
55488: EMPTY
55489: LIST
55490: LIST
55491: LIST
55492: PUSH
55493: EMPTY
55494: LIST
55495: LIST
55496: LIST
55497: LIST
55498: LIST
55499: ST_TO_ADDR
// end ; 4 :
55500: GO 55781
55502: LD_INT 4
55504: DOUBLE
55505: EQUAL
55506: IFTRUE 55510
55508: GO 55643
55510: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55511: LD_ADDR_VAR 0 5
55515: PUSH
55516: LD_VAR 0 1
55520: PUSH
55521: LD_VAR 0 2
55525: PUSH
55526: LD_INT 4
55528: PLUS
55529: PUSH
55530: LD_INT 0
55532: PUSH
55533: EMPTY
55534: LIST
55535: LIST
55536: LIST
55537: PUSH
55538: LD_VAR 0 1
55542: PUSH
55543: LD_INT 3
55545: PLUS
55546: PUSH
55547: LD_VAR 0 2
55551: PUSH
55552: LD_INT 3
55554: PLUS
55555: PUSH
55556: LD_INT 5
55558: PUSH
55559: EMPTY
55560: LIST
55561: LIST
55562: LIST
55563: PUSH
55564: LD_VAR 0 1
55568: PUSH
55569: LD_INT 4
55571: PLUS
55572: PUSH
55573: LD_VAR 0 2
55577: PUSH
55578: LD_INT 4
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: LIST
55585: PUSH
55586: LD_VAR 0 1
55590: PUSH
55591: LD_VAR 0 2
55595: PUSH
55596: LD_INT 3
55598: MINUS
55599: PUSH
55600: LD_INT 3
55602: PUSH
55603: EMPTY
55604: LIST
55605: LIST
55606: LIST
55607: PUSH
55608: LD_VAR 0 1
55612: PUSH
55613: LD_INT 4
55615: MINUS
55616: PUSH
55617: LD_VAR 0 2
55621: PUSH
55622: LD_INT 4
55624: MINUS
55625: PUSH
55626: LD_INT 2
55628: PUSH
55629: EMPTY
55630: LIST
55631: LIST
55632: LIST
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: LIST
55638: LIST
55639: LIST
55640: ST_TO_ADDR
// end ; 5 :
55641: GO 55781
55643: LD_INT 5
55645: DOUBLE
55646: EQUAL
55647: IFTRUE 55651
55649: GO 55780
55651: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55652: LD_ADDR_VAR 0 5
55656: PUSH
55657: LD_VAR 0 1
55661: PUSH
55662: LD_INT 4
55664: MINUS
55665: PUSH
55666: LD_VAR 0 2
55670: PUSH
55671: LD_INT 1
55673: PUSH
55674: EMPTY
55675: LIST
55676: LIST
55677: LIST
55678: PUSH
55679: LD_VAR 0 1
55683: PUSH
55684: LD_VAR 0 2
55688: PUSH
55689: LD_INT 4
55691: MINUS
55692: PUSH
55693: LD_INT 3
55695: PUSH
55696: EMPTY
55697: LIST
55698: LIST
55699: LIST
55700: PUSH
55701: LD_VAR 0 1
55705: PUSH
55706: LD_INT 4
55708: PLUS
55709: PUSH
55710: LD_VAR 0 2
55714: PUSH
55715: LD_INT 4
55717: PLUS
55718: PUSH
55719: LD_INT 5
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: LIST
55726: PUSH
55727: LD_VAR 0 1
55731: PUSH
55732: LD_INT 3
55734: PLUS
55735: PUSH
55736: LD_VAR 0 2
55740: PUSH
55741: LD_INT 4
55743: PUSH
55744: EMPTY
55745: LIST
55746: LIST
55747: LIST
55748: PUSH
55749: LD_VAR 0 1
55753: PUSH
55754: LD_VAR 0 2
55758: PUSH
55759: LD_INT 3
55761: PLUS
55762: PUSH
55763: LD_INT 0
55765: PUSH
55766: EMPTY
55767: LIST
55768: LIST
55769: LIST
55770: PUSH
55771: EMPTY
55772: LIST
55773: LIST
55774: LIST
55775: LIST
55776: LIST
55777: ST_TO_ADDR
// end ; end ;
55778: GO 55781
55780: POP
// result := list ;
55781: LD_ADDR_VAR 0 4
55785: PUSH
55786: LD_VAR 0 5
55790: ST_TO_ADDR
// end ;
55791: LD_VAR 0 4
55795: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55796: LD_INT 0
55798: PPUSH
55799: PPUSH
55800: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55801: LD_VAR 0 1
55805: NOT
55806: PUSH
55807: LD_VAR 0 2
55811: PUSH
55812: LD_INT 1
55814: PUSH
55815: LD_INT 2
55817: PUSH
55818: LD_INT 3
55820: PUSH
55821: LD_INT 4
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: LIST
55828: LIST
55829: IN
55830: NOT
55831: OR
55832: IFFALSE 55836
// exit ;
55834: GO 55928
// tmp := [ ] ;
55836: LD_ADDR_VAR 0 5
55840: PUSH
55841: EMPTY
55842: ST_TO_ADDR
// for i in units do
55843: LD_ADDR_VAR 0 4
55847: PUSH
55848: LD_VAR 0 1
55852: PUSH
55853: FOR_IN
55854: IFFALSE 55897
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55856: LD_ADDR_VAR 0 5
55860: PUSH
55861: LD_VAR 0 5
55865: PPUSH
55866: LD_VAR 0 5
55870: PUSH
55871: LD_INT 1
55873: PLUS
55874: PPUSH
55875: LD_VAR 0 4
55879: PPUSH
55880: LD_VAR 0 2
55884: PPUSH
55885: CALL_OW 259
55889: PPUSH
55890: CALL_OW 2
55894: ST_TO_ADDR
55895: GO 55853
55897: POP
55898: POP
// if not tmp then
55899: LD_VAR 0 5
55903: NOT
55904: IFFALSE 55908
// exit ;
55906: GO 55928
// result := SortListByListDesc ( units , tmp ) ;
55908: LD_ADDR_VAR 0 3
55912: PUSH
55913: LD_VAR 0 1
55917: PPUSH
55918: LD_VAR 0 5
55922: PPUSH
55923: CALL_OW 77
55927: ST_TO_ADDR
// end ;
55928: LD_VAR 0 3
55932: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55933: LD_INT 0
55935: PPUSH
55936: PPUSH
55937: PPUSH
// result := false ;
55938: LD_ADDR_VAR 0 3
55942: PUSH
55943: LD_INT 0
55945: ST_TO_ADDR
// x := GetX ( building ) ;
55946: LD_ADDR_VAR 0 4
55950: PUSH
55951: LD_VAR 0 2
55955: PPUSH
55956: CALL_OW 250
55960: ST_TO_ADDR
// y := GetY ( building ) ;
55961: LD_ADDR_VAR 0 5
55965: PUSH
55966: LD_VAR 0 2
55970: PPUSH
55971: CALL_OW 251
55975: ST_TO_ADDR
// if not building or not x or not y then
55976: LD_VAR 0 2
55980: NOT
55981: PUSH
55982: LD_VAR 0 4
55986: NOT
55987: OR
55988: PUSH
55989: LD_VAR 0 5
55993: NOT
55994: OR
55995: IFFALSE 55999
// exit ;
55997: GO 56091
// if GetTaskList ( unit ) then
55999: LD_VAR 0 1
56003: PPUSH
56004: CALL_OW 437
56008: IFFALSE 56091
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56010: LD_STRING e
56012: PUSH
56013: LD_VAR 0 1
56017: PPUSH
56018: CALL_OW 437
56022: PUSH
56023: LD_INT 1
56025: ARRAY
56026: PUSH
56027: LD_INT 1
56029: ARRAY
56030: EQUAL
56031: PUSH
56032: LD_VAR 0 4
56036: PUSH
56037: LD_VAR 0 1
56041: PPUSH
56042: CALL_OW 437
56046: PUSH
56047: LD_INT 1
56049: ARRAY
56050: PUSH
56051: LD_INT 2
56053: ARRAY
56054: EQUAL
56055: AND
56056: PUSH
56057: LD_VAR 0 5
56061: PUSH
56062: LD_VAR 0 1
56066: PPUSH
56067: CALL_OW 437
56071: PUSH
56072: LD_INT 1
56074: ARRAY
56075: PUSH
56076: LD_INT 3
56078: ARRAY
56079: EQUAL
56080: AND
56081: IFFALSE 56091
// result := true end ;
56083: LD_ADDR_VAR 0 3
56087: PUSH
56088: LD_INT 1
56090: ST_TO_ADDR
// end ;
56091: LD_VAR 0 3
56095: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56096: LD_INT 0
56098: PPUSH
// result := false ;
56099: LD_ADDR_VAR 0 4
56103: PUSH
56104: LD_INT 0
56106: ST_TO_ADDR
// if GetTaskList ( unit ) then
56107: LD_VAR 0 1
56111: PPUSH
56112: CALL_OW 437
56116: IFFALSE 56199
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56118: LD_STRING M
56120: PUSH
56121: LD_VAR 0 1
56125: PPUSH
56126: CALL_OW 437
56130: PUSH
56131: LD_INT 1
56133: ARRAY
56134: PUSH
56135: LD_INT 1
56137: ARRAY
56138: EQUAL
56139: PUSH
56140: LD_VAR 0 2
56144: PUSH
56145: LD_VAR 0 1
56149: PPUSH
56150: CALL_OW 437
56154: PUSH
56155: LD_INT 1
56157: ARRAY
56158: PUSH
56159: LD_INT 2
56161: ARRAY
56162: EQUAL
56163: AND
56164: PUSH
56165: LD_VAR 0 3
56169: PUSH
56170: LD_VAR 0 1
56174: PPUSH
56175: CALL_OW 437
56179: PUSH
56180: LD_INT 1
56182: ARRAY
56183: PUSH
56184: LD_INT 3
56186: ARRAY
56187: EQUAL
56188: AND
56189: IFFALSE 56199
// result := true ;
56191: LD_ADDR_VAR 0 4
56195: PUSH
56196: LD_INT 1
56198: ST_TO_ADDR
// end ; end ;
56199: LD_VAR 0 4
56203: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56204: LD_INT 0
56206: PPUSH
56207: PPUSH
56208: PPUSH
56209: PPUSH
// if not unit or not area then
56210: LD_VAR 0 1
56214: NOT
56215: PUSH
56216: LD_VAR 0 2
56220: NOT
56221: OR
56222: IFFALSE 56226
// exit ;
56224: GO 56390
// tmp := AreaToList ( area , i ) ;
56226: LD_ADDR_VAR 0 6
56230: PUSH
56231: LD_VAR 0 2
56235: PPUSH
56236: LD_VAR 0 5
56240: PPUSH
56241: CALL_OW 517
56245: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56246: LD_ADDR_VAR 0 5
56250: PUSH
56251: DOUBLE
56252: LD_INT 1
56254: DEC
56255: ST_TO_ADDR
56256: LD_VAR 0 6
56260: PUSH
56261: LD_INT 1
56263: ARRAY
56264: PUSH
56265: FOR_TO
56266: IFFALSE 56388
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56268: LD_ADDR_VAR 0 7
56272: PUSH
56273: LD_VAR 0 6
56277: PUSH
56278: LD_INT 1
56280: ARRAY
56281: PUSH
56282: LD_VAR 0 5
56286: ARRAY
56287: PUSH
56288: LD_VAR 0 6
56292: PUSH
56293: LD_INT 2
56295: ARRAY
56296: PUSH
56297: LD_VAR 0 5
56301: ARRAY
56302: PUSH
56303: EMPTY
56304: LIST
56305: LIST
56306: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56307: LD_VAR 0 7
56311: PUSH
56312: LD_INT 1
56314: ARRAY
56315: PPUSH
56316: LD_VAR 0 7
56320: PUSH
56321: LD_INT 2
56323: ARRAY
56324: PPUSH
56325: CALL_OW 428
56329: PUSH
56330: LD_INT 0
56332: EQUAL
56333: IFFALSE 56386
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56335: LD_VAR 0 1
56339: PPUSH
56340: LD_VAR 0 7
56344: PUSH
56345: LD_INT 1
56347: ARRAY
56348: PPUSH
56349: LD_VAR 0 7
56353: PUSH
56354: LD_INT 2
56356: ARRAY
56357: PPUSH
56358: LD_VAR 0 3
56362: PPUSH
56363: CALL_OW 48
// result := IsPlaced ( unit ) ;
56367: LD_ADDR_VAR 0 4
56371: PUSH
56372: LD_VAR 0 1
56376: PPUSH
56377: CALL_OW 305
56381: ST_TO_ADDR
// exit ;
56382: POP
56383: POP
56384: GO 56390
// end ; end ;
56386: GO 56265
56388: POP
56389: POP
// end ;
56390: LD_VAR 0 4
56394: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56395: LD_INT 0
56397: PPUSH
56398: PPUSH
56399: PPUSH
// if not side or side > 8 then
56400: LD_VAR 0 1
56404: NOT
56405: PUSH
56406: LD_VAR 0 1
56410: PUSH
56411: LD_INT 8
56413: GREATER
56414: OR
56415: IFFALSE 56419
// exit ;
56417: GO 56606
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56419: LD_ADDR_VAR 0 4
56423: PUSH
56424: LD_INT 22
56426: PUSH
56427: LD_VAR 0 1
56431: PUSH
56432: EMPTY
56433: LIST
56434: LIST
56435: PUSH
56436: LD_INT 21
56438: PUSH
56439: LD_INT 3
56441: PUSH
56442: EMPTY
56443: LIST
56444: LIST
56445: PUSH
56446: EMPTY
56447: LIST
56448: LIST
56449: PPUSH
56450: CALL_OW 69
56454: ST_TO_ADDR
// if not tmp then
56455: LD_VAR 0 4
56459: NOT
56460: IFFALSE 56464
// exit ;
56462: GO 56606
// enable_addtolog := true ;
56464: LD_ADDR_OWVAR 81
56468: PUSH
56469: LD_INT 1
56471: ST_TO_ADDR
// AddToLog ( [ ) ;
56472: LD_STRING [
56474: PPUSH
56475: CALL_OW 561
// for i in tmp do
56479: LD_ADDR_VAR 0 3
56483: PUSH
56484: LD_VAR 0 4
56488: PUSH
56489: FOR_IN
56490: IFFALSE 56597
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56492: LD_STRING [
56494: PUSH
56495: LD_VAR 0 3
56499: PPUSH
56500: CALL_OW 266
56504: STR
56505: PUSH
56506: LD_STRING , 
56508: STR
56509: PUSH
56510: LD_VAR 0 3
56514: PPUSH
56515: CALL_OW 250
56519: STR
56520: PUSH
56521: LD_STRING , 
56523: STR
56524: PUSH
56525: LD_VAR 0 3
56529: PPUSH
56530: CALL_OW 251
56534: STR
56535: PUSH
56536: LD_STRING , 
56538: STR
56539: PUSH
56540: LD_VAR 0 3
56544: PPUSH
56545: CALL_OW 254
56549: STR
56550: PUSH
56551: LD_STRING , 
56553: STR
56554: PUSH
56555: LD_VAR 0 3
56559: PPUSH
56560: LD_INT 1
56562: PPUSH
56563: CALL_OW 268
56567: STR
56568: PUSH
56569: LD_STRING , 
56571: STR
56572: PUSH
56573: LD_VAR 0 3
56577: PPUSH
56578: LD_INT 2
56580: PPUSH
56581: CALL_OW 268
56585: STR
56586: PUSH
56587: LD_STRING ],
56589: STR
56590: PPUSH
56591: CALL_OW 561
// end ;
56595: GO 56489
56597: POP
56598: POP
// AddToLog ( ]; ) ;
56599: LD_STRING ];
56601: PPUSH
56602: CALL_OW 561
// end ;
56606: LD_VAR 0 2
56610: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56611: LD_INT 0
56613: PPUSH
56614: PPUSH
56615: PPUSH
56616: PPUSH
56617: PPUSH
// if not area or not rate or not max then
56618: LD_VAR 0 1
56622: NOT
56623: PUSH
56624: LD_VAR 0 2
56628: NOT
56629: OR
56630: PUSH
56631: LD_VAR 0 4
56635: NOT
56636: OR
56637: IFFALSE 56641
// exit ;
56639: GO 56830
// while 1 do
56641: LD_INT 1
56643: IFFALSE 56830
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56645: LD_ADDR_VAR 0 9
56649: PUSH
56650: LD_VAR 0 1
56654: PPUSH
56655: LD_INT 1
56657: PPUSH
56658: CALL_OW 287
56662: PUSH
56663: LD_INT 10
56665: MUL
56666: ST_TO_ADDR
// r := rate / 10 ;
56667: LD_ADDR_VAR 0 7
56671: PUSH
56672: LD_VAR 0 2
56676: PUSH
56677: LD_INT 10
56679: DIVREAL
56680: ST_TO_ADDR
// time := 1 1$00 ;
56681: LD_ADDR_VAR 0 8
56685: PUSH
56686: LD_INT 2100
56688: ST_TO_ADDR
// if amount < min then
56689: LD_VAR 0 9
56693: PUSH
56694: LD_VAR 0 3
56698: LESS
56699: IFFALSE 56717
// r := r * 2 else
56701: LD_ADDR_VAR 0 7
56705: PUSH
56706: LD_VAR 0 7
56710: PUSH
56711: LD_INT 2
56713: MUL
56714: ST_TO_ADDR
56715: GO 56743
// if amount > max then
56717: LD_VAR 0 9
56721: PUSH
56722: LD_VAR 0 4
56726: GREATER
56727: IFFALSE 56743
// r := r / 2 ;
56729: LD_ADDR_VAR 0 7
56733: PUSH
56734: LD_VAR 0 7
56738: PUSH
56739: LD_INT 2
56741: DIVREAL
56742: ST_TO_ADDR
// time := time / r ;
56743: LD_ADDR_VAR 0 8
56747: PUSH
56748: LD_VAR 0 8
56752: PUSH
56753: LD_VAR 0 7
56757: DIVREAL
56758: ST_TO_ADDR
// if time < 0 then
56759: LD_VAR 0 8
56763: PUSH
56764: LD_INT 0
56766: LESS
56767: IFFALSE 56784
// time := time * - 1 ;
56769: LD_ADDR_VAR 0 8
56773: PUSH
56774: LD_VAR 0 8
56778: PUSH
56779: LD_INT 1
56781: NEG
56782: MUL
56783: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56784: LD_VAR 0 8
56788: PUSH
56789: LD_INT 35
56791: PPUSH
56792: LD_INT 875
56794: PPUSH
56795: CALL_OW 12
56799: PLUS
56800: PPUSH
56801: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56805: LD_INT 1
56807: PPUSH
56808: LD_INT 5
56810: PPUSH
56811: CALL_OW 12
56815: PPUSH
56816: LD_VAR 0 1
56820: PPUSH
56821: LD_INT 1
56823: PPUSH
56824: CALL_OW 55
// end ;
56828: GO 56641
// end ;
56830: LD_VAR 0 5
56834: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56835: LD_INT 0
56837: PPUSH
56838: PPUSH
56839: PPUSH
56840: PPUSH
56841: PPUSH
56842: PPUSH
56843: PPUSH
56844: PPUSH
// if not turrets or not factories then
56845: LD_VAR 0 1
56849: NOT
56850: PUSH
56851: LD_VAR 0 2
56855: NOT
56856: OR
56857: IFFALSE 56861
// exit ;
56859: GO 57168
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56861: LD_ADDR_VAR 0 10
56865: PUSH
56866: LD_INT 5
56868: PUSH
56869: LD_INT 6
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: PUSH
56876: LD_INT 2
56878: PUSH
56879: LD_INT 4
56881: PUSH
56882: EMPTY
56883: LIST
56884: LIST
56885: PUSH
56886: LD_INT 3
56888: PUSH
56889: LD_INT 5
56891: PUSH
56892: EMPTY
56893: LIST
56894: LIST
56895: PUSH
56896: EMPTY
56897: LIST
56898: LIST
56899: LIST
56900: PUSH
56901: LD_INT 24
56903: PUSH
56904: LD_INT 25
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: PUSH
56911: LD_INT 23
56913: PUSH
56914: LD_INT 27
56916: PUSH
56917: EMPTY
56918: LIST
56919: LIST
56920: PUSH
56921: EMPTY
56922: LIST
56923: LIST
56924: PUSH
56925: LD_INT 42
56927: PUSH
56928: LD_INT 43
56930: PUSH
56931: EMPTY
56932: LIST
56933: LIST
56934: PUSH
56935: LD_INT 44
56937: PUSH
56938: LD_INT 46
56940: PUSH
56941: EMPTY
56942: LIST
56943: LIST
56944: PUSH
56945: LD_INT 45
56947: PUSH
56948: LD_INT 47
56950: PUSH
56951: EMPTY
56952: LIST
56953: LIST
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: LIST
56959: PUSH
56960: EMPTY
56961: LIST
56962: LIST
56963: LIST
56964: ST_TO_ADDR
// result := [ ] ;
56965: LD_ADDR_VAR 0 3
56969: PUSH
56970: EMPTY
56971: ST_TO_ADDR
// for i in turrets do
56972: LD_ADDR_VAR 0 4
56976: PUSH
56977: LD_VAR 0 1
56981: PUSH
56982: FOR_IN
56983: IFFALSE 57166
// begin nat := GetNation ( i ) ;
56985: LD_ADDR_VAR 0 7
56989: PUSH
56990: LD_VAR 0 4
56994: PPUSH
56995: CALL_OW 248
56999: ST_TO_ADDR
// weapon := 0 ;
57000: LD_ADDR_VAR 0 8
57004: PUSH
57005: LD_INT 0
57007: ST_TO_ADDR
// if not nat then
57008: LD_VAR 0 7
57012: NOT
57013: IFFALSE 57017
// continue ;
57015: GO 56982
// for j in list [ nat ] do
57017: LD_ADDR_VAR 0 5
57021: PUSH
57022: LD_VAR 0 10
57026: PUSH
57027: LD_VAR 0 7
57031: ARRAY
57032: PUSH
57033: FOR_IN
57034: IFFALSE 57075
// if GetBWeapon ( i ) = j [ 1 ] then
57036: LD_VAR 0 4
57040: PPUSH
57041: CALL_OW 269
57045: PUSH
57046: LD_VAR 0 5
57050: PUSH
57051: LD_INT 1
57053: ARRAY
57054: EQUAL
57055: IFFALSE 57073
// begin weapon := j [ 2 ] ;
57057: LD_ADDR_VAR 0 8
57061: PUSH
57062: LD_VAR 0 5
57066: PUSH
57067: LD_INT 2
57069: ARRAY
57070: ST_TO_ADDR
// break ;
57071: GO 57075
// end ;
57073: GO 57033
57075: POP
57076: POP
// if not weapon then
57077: LD_VAR 0 8
57081: NOT
57082: IFFALSE 57086
// continue ;
57084: GO 56982
// for k in factories do
57086: LD_ADDR_VAR 0 6
57090: PUSH
57091: LD_VAR 0 2
57095: PUSH
57096: FOR_IN
57097: IFFALSE 57162
// begin weapons := AvailableWeaponList ( k ) ;
57099: LD_ADDR_VAR 0 9
57103: PUSH
57104: LD_VAR 0 6
57108: PPUSH
57109: CALL_OW 478
57113: ST_TO_ADDR
// if not weapons then
57114: LD_VAR 0 9
57118: NOT
57119: IFFALSE 57123
// continue ;
57121: GO 57096
// if weapon in weapons then
57123: LD_VAR 0 8
57127: PUSH
57128: LD_VAR 0 9
57132: IN
57133: IFFALSE 57160
// begin result := [ i , weapon ] ;
57135: LD_ADDR_VAR 0 3
57139: PUSH
57140: LD_VAR 0 4
57144: PUSH
57145: LD_VAR 0 8
57149: PUSH
57150: EMPTY
57151: LIST
57152: LIST
57153: ST_TO_ADDR
// exit ;
57154: POP
57155: POP
57156: POP
57157: POP
57158: GO 57168
// end ; end ;
57160: GO 57096
57162: POP
57163: POP
// end ;
57164: GO 56982
57166: POP
57167: POP
// end ;
57168: LD_VAR 0 3
57172: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57173: LD_INT 0
57175: PPUSH
// if not side or side > 8 then
57176: LD_VAR 0 3
57180: NOT
57181: PUSH
57182: LD_VAR 0 3
57186: PUSH
57187: LD_INT 8
57189: GREATER
57190: OR
57191: IFFALSE 57195
// exit ;
57193: GO 57254
// if not range then
57195: LD_VAR 0 4
57199: NOT
57200: IFFALSE 57211
// range := - 12 ;
57202: LD_ADDR_VAR 0 4
57206: PUSH
57207: LD_INT 12
57209: NEG
57210: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57211: LD_VAR 0 1
57215: PPUSH
57216: LD_VAR 0 2
57220: PPUSH
57221: LD_VAR 0 3
57225: PPUSH
57226: LD_VAR 0 4
57230: PPUSH
57231: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57235: LD_VAR 0 1
57239: PPUSH
57240: LD_VAR 0 2
57244: PPUSH
57245: LD_VAR 0 3
57249: PPUSH
57250: CALL_OW 331
// end ;
57254: LD_VAR 0 5
57258: RET
// export function Video ( mode ) ; begin
57259: LD_INT 0
57261: PPUSH
// ingame_video = mode ;
57262: LD_ADDR_OWVAR 52
57266: PUSH
57267: LD_VAR 0 1
57271: ST_TO_ADDR
// interface_hidden = mode ;
57272: LD_ADDR_OWVAR 54
57276: PUSH
57277: LD_VAR 0 1
57281: ST_TO_ADDR
// end ;
57282: LD_VAR 0 2
57286: RET
// export function Join ( array , element ) ; begin
57287: LD_INT 0
57289: PPUSH
// result := Replace ( array , array + 1 , element ) ;
57290: LD_ADDR_VAR 0 3
57294: PUSH
57295: LD_VAR 0 1
57299: PPUSH
57300: LD_VAR 0 1
57304: PUSH
57305: LD_INT 1
57307: PLUS
57308: PPUSH
57309: LD_VAR 0 2
57313: PPUSH
57314: CALL_OW 1
57318: ST_TO_ADDR
// end ;
57319: LD_VAR 0 3
57323: RET
// export function JoinUnion ( array , element ) ; begin
57324: LD_INT 0
57326: PPUSH
// result := array union element ;
57327: LD_ADDR_VAR 0 3
57331: PUSH
57332: LD_VAR 0 1
57336: PUSH
57337: LD_VAR 0 2
57341: UNION
57342: ST_TO_ADDR
// end ;
57343: LD_VAR 0 3
57347: RET
// export function GetBehemoths ( side ) ; begin
57348: LD_INT 0
57350: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
57351: LD_ADDR_VAR 0 2
57355: PUSH
57356: LD_INT 22
57358: PUSH
57359: LD_VAR 0 1
57363: PUSH
57364: EMPTY
57365: LIST
57366: LIST
57367: PUSH
57368: LD_INT 31
57370: PUSH
57371: LD_INT 25
57373: PUSH
57374: EMPTY
57375: LIST
57376: LIST
57377: PUSH
57378: EMPTY
57379: LIST
57380: LIST
57381: PPUSH
57382: CALL_OW 69
57386: ST_TO_ADDR
// end ;
57387: LD_VAR 0 2
57391: RET
// export function Shuffle ( array ) ; var i , index ; begin
57392: LD_INT 0
57394: PPUSH
57395: PPUSH
57396: PPUSH
// result := [ ] ;
57397: LD_ADDR_VAR 0 2
57401: PUSH
57402: EMPTY
57403: ST_TO_ADDR
// if not array then
57404: LD_VAR 0 1
57408: NOT
57409: IFFALSE 57413
// exit ;
57411: GO 57512
// Randomize ;
57413: CALL_OW 10
// for i = array downto 1 do
57417: LD_ADDR_VAR 0 3
57421: PUSH
57422: DOUBLE
57423: LD_VAR 0 1
57427: INC
57428: ST_TO_ADDR
57429: LD_INT 1
57431: PUSH
57432: FOR_DOWNTO
57433: IFFALSE 57510
// begin index := rand ( 1 , array ) ;
57435: LD_ADDR_VAR 0 4
57439: PUSH
57440: LD_INT 1
57442: PPUSH
57443: LD_VAR 0 1
57447: PPUSH
57448: CALL_OW 12
57452: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57453: LD_ADDR_VAR 0 2
57457: PUSH
57458: LD_VAR 0 2
57462: PPUSH
57463: LD_VAR 0 2
57467: PUSH
57468: LD_INT 1
57470: PLUS
57471: PPUSH
57472: LD_VAR 0 1
57476: PUSH
57477: LD_VAR 0 4
57481: ARRAY
57482: PPUSH
57483: CALL_OW 2
57487: ST_TO_ADDR
// array := Delete ( array , index ) ;
57488: LD_ADDR_VAR 0 1
57492: PUSH
57493: LD_VAR 0 1
57497: PPUSH
57498: LD_VAR 0 4
57502: PPUSH
57503: CALL_OW 3
57507: ST_TO_ADDR
// end ;
57508: GO 57432
57510: POP
57511: POP
// end ;
57512: LD_VAR 0 2
57516: RET
// export function GetBaseMaterials ( base ) ; begin
57517: LD_INT 0
57519: PPUSH
// result := [ 0 , 0 , 0 ] ;
57520: LD_ADDR_VAR 0 2
57524: PUSH
57525: LD_INT 0
57527: PUSH
57528: LD_INT 0
57530: PUSH
57531: LD_INT 0
57533: PUSH
57534: EMPTY
57535: LIST
57536: LIST
57537: LIST
57538: ST_TO_ADDR
// if not base then
57539: LD_VAR 0 1
57543: NOT
57544: IFFALSE 57548
// exit ;
57546: GO 57597
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57548: LD_ADDR_VAR 0 2
57552: PUSH
57553: LD_VAR 0 1
57557: PPUSH
57558: LD_INT 1
57560: PPUSH
57561: CALL_OW 275
57565: PUSH
57566: LD_VAR 0 1
57570: PPUSH
57571: LD_INT 2
57573: PPUSH
57574: CALL_OW 275
57578: PUSH
57579: LD_VAR 0 1
57583: PPUSH
57584: LD_INT 3
57586: PPUSH
57587: CALL_OW 275
57591: PUSH
57592: EMPTY
57593: LIST
57594: LIST
57595: LIST
57596: ST_TO_ADDR
// end ;
57597: LD_VAR 0 2
57601: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57602: LD_INT 0
57604: PPUSH
57605: PPUSH
// result := array ;
57606: LD_ADDR_VAR 0 3
57610: PUSH
57611: LD_VAR 0 1
57615: ST_TO_ADDR
// if size >= result then
57616: LD_VAR 0 2
57620: PUSH
57621: LD_VAR 0 3
57625: GREATEREQUAL
57626: IFFALSE 57630
// exit ;
57628: GO 57680
// if size then
57630: LD_VAR 0 2
57634: IFFALSE 57680
// for i := array downto size do
57636: LD_ADDR_VAR 0 4
57640: PUSH
57641: DOUBLE
57642: LD_VAR 0 1
57646: INC
57647: ST_TO_ADDR
57648: LD_VAR 0 2
57652: PUSH
57653: FOR_DOWNTO
57654: IFFALSE 57678
// result := Delete ( result , result ) ;
57656: LD_ADDR_VAR 0 3
57660: PUSH
57661: LD_VAR 0 3
57665: PPUSH
57666: LD_VAR 0 3
57670: PPUSH
57671: CALL_OW 3
57675: ST_TO_ADDR
57676: GO 57653
57678: POP
57679: POP
// end ;
57680: LD_VAR 0 3
57684: RET
// export function ComExit ( unit ) ; var tmp ; begin
57685: LD_INT 0
57687: PPUSH
57688: PPUSH
// if not IsInUnit ( unit ) then
57689: LD_VAR 0 1
57693: PPUSH
57694: CALL_OW 310
57698: NOT
57699: IFFALSE 57703
// exit ;
57701: GO 57763
// tmp := IsInUnit ( unit ) ;
57703: LD_ADDR_VAR 0 3
57707: PUSH
57708: LD_VAR 0 1
57712: PPUSH
57713: CALL_OW 310
57717: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57718: LD_VAR 0 3
57722: PPUSH
57723: CALL_OW 247
57727: PUSH
57728: LD_INT 2
57730: EQUAL
57731: IFFALSE 57744
// ComExitVehicle ( unit ) else
57733: LD_VAR 0 1
57737: PPUSH
57738: CALL_OW 121
57742: GO 57753
// ComExitBuilding ( unit ) ;
57744: LD_VAR 0 1
57748: PPUSH
57749: CALL_OW 122
// result := tmp ;
57753: LD_ADDR_VAR 0 2
57757: PUSH
57758: LD_VAR 0 3
57762: ST_TO_ADDR
// end ;
57763: LD_VAR 0 2
57767: RET
// export function ComExitAll ( units ) ; var i ; begin
57768: LD_INT 0
57770: PPUSH
57771: PPUSH
// if not units then
57772: LD_VAR 0 1
57776: NOT
57777: IFFALSE 57781
// exit ;
57779: GO 57807
// for i in units do
57781: LD_ADDR_VAR 0 3
57785: PUSH
57786: LD_VAR 0 1
57790: PUSH
57791: FOR_IN
57792: IFFALSE 57805
// ComExit ( i ) ;
57794: LD_VAR 0 3
57798: PPUSH
57799: CALL 57685 0 1
57803: GO 57791
57805: POP
57806: POP
// end ;
57807: LD_VAR 0 2
57811: RET
// export function ResetHc ; begin
57812: LD_INT 0
57814: PPUSH
// InitHc ;
57815: CALL_OW 19
// hc_importance := 0 ;
57819: LD_ADDR_OWVAR 32
57823: PUSH
57824: LD_INT 0
57826: ST_TO_ADDR
// end ;
57827: LD_VAR 0 1
57831: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57832: LD_INT 0
57834: PPUSH
57835: PPUSH
57836: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57837: LD_ADDR_VAR 0 6
57841: PUSH
57842: LD_VAR 0 1
57846: PUSH
57847: LD_VAR 0 3
57851: PLUS
57852: PUSH
57853: LD_INT 2
57855: DIV
57856: ST_TO_ADDR
// if _x < 0 then
57857: LD_VAR 0 6
57861: PUSH
57862: LD_INT 0
57864: LESS
57865: IFFALSE 57882
// _x := _x * - 1 ;
57867: LD_ADDR_VAR 0 6
57871: PUSH
57872: LD_VAR 0 6
57876: PUSH
57877: LD_INT 1
57879: NEG
57880: MUL
57881: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57882: LD_ADDR_VAR 0 7
57886: PUSH
57887: LD_VAR 0 2
57891: PUSH
57892: LD_VAR 0 4
57896: PLUS
57897: PUSH
57898: LD_INT 2
57900: DIV
57901: ST_TO_ADDR
// if _y < 0 then
57902: LD_VAR 0 7
57906: PUSH
57907: LD_INT 0
57909: LESS
57910: IFFALSE 57927
// _y := _y * - 1 ;
57912: LD_ADDR_VAR 0 7
57916: PUSH
57917: LD_VAR 0 7
57921: PUSH
57922: LD_INT 1
57924: NEG
57925: MUL
57926: ST_TO_ADDR
// result := [ _x , _y ] ;
57927: LD_ADDR_VAR 0 5
57931: PUSH
57932: LD_VAR 0 6
57936: PUSH
57937: LD_VAR 0 7
57941: PUSH
57942: EMPTY
57943: LIST
57944: LIST
57945: ST_TO_ADDR
// end ;
57946: LD_VAR 0 5
57950: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57951: LD_INT 0
57953: PPUSH
57954: PPUSH
57955: PPUSH
57956: PPUSH
// task := GetTaskList ( unit ) ;
57957: LD_ADDR_VAR 0 7
57961: PUSH
57962: LD_VAR 0 1
57966: PPUSH
57967: CALL_OW 437
57971: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57972: LD_VAR 0 7
57976: NOT
57977: PUSH
57978: LD_VAR 0 1
57982: PPUSH
57983: LD_VAR 0 2
57987: PPUSH
57988: CALL_OW 308
57992: NOT
57993: AND
57994: IFFALSE 57998
// exit ;
57996: GO 58116
// if IsInArea ( unit , area ) then
57998: LD_VAR 0 1
58002: PPUSH
58003: LD_VAR 0 2
58007: PPUSH
58008: CALL_OW 308
58012: IFFALSE 58030
// begin ComMoveToArea ( unit , goAway ) ;
58014: LD_VAR 0 1
58018: PPUSH
58019: LD_VAR 0 3
58023: PPUSH
58024: CALL_OW 113
// exit ;
58028: GO 58116
// end ; if task [ 1 ] [ 1 ] <> M then
58030: LD_VAR 0 7
58034: PUSH
58035: LD_INT 1
58037: ARRAY
58038: PUSH
58039: LD_INT 1
58041: ARRAY
58042: PUSH
58043: LD_STRING M
58045: NONEQUAL
58046: IFFALSE 58050
// exit ;
58048: GO 58116
// x := task [ 1 ] [ 2 ] ;
58050: LD_ADDR_VAR 0 5
58054: PUSH
58055: LD_VAR 0 7
58059: PUSH
58060: LD_INT 1
58062: ARRAY
58063: PUSH
58064: LD_INT 2
58066: ARRAY
58067: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
58068: LD_ADDR_VAR 0 6
58072: PUSH
58073: LD_VAR 0 7
58077: PUSH
58078: LD_INT 1
58080: ARRAY
58081: PUSH
58082: LD_INT 3
58084: ARRAY
58085: ST_TO_ADDR
// if InArea ( x , y , area ) then
58086: LD_VAR 0 5
58090: PPUSH
58091: LD_VAR 0 6
58095: PPUSH
58096: LD_VAR 0 2
58100: PPUSH
58101: CALL_OW 309
58105: IFFALSE 58116
// ComStop ( unit ) ;
58107: LD_VAR 0 1
58111: PPUSH
58112: CALL_OW 141
// end ;
58116: LD_VAR 0 4
58120: RET
// export function Abs ( value ) ; begin
58121: LD_INT 0
58123: PPUSH
// result := value ;
58124: LD_ADDR_VAR 0 2
58128: PUSH
58129: LD_VAR 0 1
58133: ST_TO_ADDR
// if value < 0 then
58134: LD_VAR 0 1
58138: PUSH
58139: LD_INT 0
58141: LESS
58142: IFFALSE 58159
// result := value * - 1 ;
58144: LD_ADDR_VAR 0 2
58148: PUSH
58149: LD_VAR 0 1
58153: PUSH
58154: LD_INT 1
58156: NEG
58157: MUL
58158: ST_TO_ADDR
// end ;
58159: LD_VAR 0 2
58163: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58164: LD_INT 0
58166: PPUSH
58167: PPUSH
58168: PPUSH
58169: PPUSH
58170: PPUSH
58171: PPUSH
58172: PPUSH
58173: PPUSH
// if not unit or not building then
58174: LD_VAR 0 1
58178: NOT
58179: PUSH
58180: LD_VAR 0 2
58184: NOT
58185: OR
58186: IFFALSE 58190
// exit ;
58188: GO 58416
// x := GetX ( building ) ;
58190: LD_ADDR_VAR 0 4
58194: PUSH
58195: LD_VAR 0 2
58199: PPUSH
58200: CALL_OW 250
58204: ST_TO_ADDR
// y := GetY ( building ) ;
58205: LD_ADDR_VAR 0 6
58209: PUSH
58210: LD_VAR 0 2
58214: PPUSH
58215: CALL_OW 251
58219: ST_TO_ADDR
// d := GetDir ( building ) ;
58220: LD_ADDR_VAR 0 8
58224: PUSH
58225: LD_VAR 0 2
58229: PPUSH
58230: CALL_OW 254
58234: ST_TO_ADDR
// r := 4 ;
58235: LD_ADDR_VAR 0 9
58239: PUSH
58240: LD_INT 4
58242: ST_TO_ADDR
// for i := 1 to 5 do
58243: LD_ADDR_VAR 0 10
58247: PUSH
58248: DOUBLE
58249: LD_INT 1
58251: DEC
58252: ST_TO_ADDR
58253: LD_INT 5
58255: PUSH
58256: FOR_TO
58257: IFFALSE 58414
// begin _x := ShiftX ( x , d , r + i ) ;
58259: LD_ADDR_VAR 0 5
58263: PUSH
58264: LD_VAR 0 4
58268: PPUSH
58269: LD_VAR 0 8
58273: PPUSH
58274: LD_VAR 0 9
58278: PUSH
58279: LD_VAR 0 10
58283: PLUS
58284: PPUSH
58285: CALL_OW 272
58289: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
58290: LD_ADDR_VAR 0 7
58294: PUSH
58295: LD_VAR 0 6
58299: PPUSH
58300: LD_VAR 0 8
58304: PPUSH
58305: LD_VAR 0 9
58309: PUSH
58310: LD_VAR 0 10
58314: PLUS
58315: PPUSH
58316: CALL_OW 273
58320: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
58321: LD_VAR 0 5
58325: PPUSH
58326: LD_VAR 0 7
58330: PPUSH
58331: CALL_OW 488
58335: PUSH
58336: LD_VAR 0 5
58340: PPUSH
58341: LD_VAR 0 7
58345: PPUSH
58346: CALL_OW 428
58350: PPUSH
58351: CALL_OW 247
58355: PUSH
58356: LD_INT 3
58358: PUSH
58359: LD_INT 2
58361: PUSH
58362: EMPTY
58363: LIST
58364: LIST
58365: IN
58366: NOT
58367: AND
58368: IFFALSE 58412
// begin ComMoveXY ( unit , _x , _y ) ;
58370: LD_VAR 0 1
58374: PPUSH
58375: LD_VAR 0 5
58379: PPUSH
58380: LD_VAR 0 7
58384: PPUSH
58385: CALL_OW 111
// result := [ _x , _y ] ;
58389: LD_ADDR_VAR 0 3
58393: PUSH
58394: LD_VAR 0 5
58398: PUSH
58399: LD_VAR 0 7
58403: PUSH
58404: EMPTY
58405: LIST
58406: LIST
58407: ST_TO_ADDR
// exit ;
58408: POP
58409: POP
58410: GO 58416
// end ; end ;
58412: GO 58256
58414: POP
58415: POP
// end ;
58416: LD_VAR 0 3
58420: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
58421: LD_INT 0
58423: PPUSH
58424: PPUSH
58425: PPUSH
// result := 0 ;
58426: LD_ADDR_VAR 0 3
58430: PUSH
58431: LD_INT 0
58433: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
58434: LD_VAR 0 1
58438: PUSH
58439: LD_INT 0
58441: LESS
58442: PUSH
58443: LD_VAR 0 1
58447: PUSH
58448: LD_INT 8
58450: GREATER
58451: OR
58452: PUSH
58453: LD_VAR 0 2
58457: PUSH
58458: LD_INT 0
58460: LESS
58461: OR
58462: PUSH
58463: LD_VAR 0 2
58467: PUSH
58468: LD_INT 8
58470: GREATER
58471: OR
58472: IFFALSE 58476
// exit ;
58474: GO 58551
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
58476: LD_ADDR_VAR 0 4
58480: PUSH
58481: LD_INT 22
58483: PUSH
58484: LD_VAR 0 2
58488: PUSH
58489: EMPTY
58490: LIST
58491: LIST
58492: PPUSH
58493: CALL_OW 69
58497: PUSH
58498: FOR_IN
58499: IFFALSE 58549
// begin un := UnitShoot ( i ) ;
58501: LD_ADDR_VAR 0 5
58505: PUSH
58506: LD_VAR 0 4
58510: PPUSH
58511: CALL_OW 504
58515: ST_TO_ADDR
// if GetSide ( un ) = side1 then
58516: LD_VAR 0 5
58520: PPUSH
58521: CALL_OW 255
58525: PUSH
58526: LD_VAR 0 1
58530: EQUAL
58531: IFFALSE 58547
// begin result := un ;
58533: LD_ADDR_VAR 0 3
58537: PUSH
58538: LD_VAR 0 5
58542: ST_TO_ADDR
// exit ;
58543: POP
58544: POP
58545: GO 58551
// end ; end ;
58547: GO 58498
58549: POP
58550: POP
// end ;
58551: LD_VAR 0 3
58555: RET
// export function GetCargoBay ( units ) ; begin
58556: LD_INT 0
58558: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
58559: LD_ADDR_VAR 0 2
58563: PUSH
58564: LD_VAR 0 1
58568: PPUSH
58569: LD_INT 2
58571: PUSH
58572: LD_INT 34
58574: PUSH
58575: LD_INT 12
58577: PUSH
58578: EMPTY
58579: LIST
58580: LIST
58581: PUSH
58582: LD_INT 34
58584: PUSH
58585: LD_INT 51
58587: PUSH
58588: EMPTY
58589: LIST
58590: LIST
58591: PUSH
58592: LD_INT 34
58594: PUSH
58595: LD_INT 32
58597: PUSH
58598: EMPTY
58599: LIST
58600: LIST
58601: PUSH
58602: LD_INT 34
58604: PUSH
58605: LD_EXP 30
58609: PUSH
58610: EMPTY
58611: LIST
58612: LIST
58613: PUSH
58614: EMPTY
58615: LIST
58616: LIST
58617: LIST
58618: LIST
58619: LIST
58620: PPUSH
58621: CALL_OW 72
58625: ST_TO_ADDR
// end ;
58626: LD_VAR 0 2
58630: RET
// export function Negate ( value ) ; begin
58631: LD_INT 0
58633: PPUSH
// result := not value ;
58634: LD_ADDR_VAR 0 2
58638: PUSH
58639: LD_VAR 0 1
58643: NOT
58644: ST_TO_ADDR
// end ;
58645: LD_VAR 0 2
58649: RET
// export function Inc ( value ) ; begin
58650: LD_INT 0
58652: PPUSH
// result := value + 1 ;
58653: LD_ADDR_VAR 0 2
58657: PUSH
58658: LD_VAR 0 1
58662: PUSH
58663: LD_INT 1
58665: PLUS
58666: ST_TO_ADDR
// end ;
58667: LD_VAR 0 2
58671: RET
// export function Dec ( value ) ; begin
58672: LD_INT 0
58674: PPUSH
// result := value - 1 ;
58675: LD_ADDR_VAR 0 2
58679: PUSH
58680: LD_VAR 0 1
58684: PUSH
58685: LD_INT 1
58687: MINUS
58688: ST_TO_ADDR
// end ;
58689: LD_VAR 0 2
58693: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58694: LD_INT 0
58696: PPUSH
58697: PPUSH
58698: PPUSH
58699: PPUSH
58700: PPUSH
58701: PPUSH
58702: PPUSH
58703: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58704: LD_VAR 0 1
58708: PPUSH
58709: LD_VAR 0 2
58713: PPUSH
58714: CALL_OW 488
58718: NOT
58719: PUSH
58720: LD_VAR 0 3
58724: PPUSH
58725: LD_VAR 0 4
58729: PPUSH
58730: CALL_OW 488
58734: NOT
58735: OR
58736: IFFALSE 58749
// begin result := - 1 ;
58738: LD_ADDR_VAR 0 5
58742: PUSH
58743: LD_INT 1
58745: NEG
58746: ST_TO_ADDR
// exit ;
58747: GO 58984
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58749: LD_ADDR_VAR 0 12
58753: PUSH
58754: LD_VAR 0 1
58758: PPUSH
58759: LD_VAR 0 2
58763: PPUSH
58764: LD_VAR 0 3
58768: PPUSH
58769: LD_VAR 0 4
58773: PPUSH
58774: CALL 57832 0 4
58778: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58779: LD_ADDR_VAR 0 11
58783: PUSH
58784: LD_VAR 0 1
58788: PPUSH
58789: LD_VAR 0 2
58793: PPUSH
58794: LD_VAR 0 12
58798: PUSH
58799: LD_INT 1
58801: ARRAY
58802: PPUSH
58803: LD_VAR 0 12
58807: PUSH
58808: LD_INT 2
58810: ARRAY
58811: PPUSH
58812: CALL_OW 298
58816: ST_TO_ADDR
// distance := 9999 ;
58817: LD_ADDR_VAR 0 10
58821: PUSH
58822: LD_INT 9999
58824: ST_TO_ADDR
// for i := 0 to 5 do
58825: LD_ADDR_VAR 0 6
58829: PUSH
58830: DOUBLE
58831: LD_INT 0
58833: DEC
58834: ST_TO_ADDR
58835: LD_INT 5
58837: PUSH
58838: FOR_TO
58839: IFFALSE 58982
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58841: LD_ADDR_VAR 0 7
58845: PUSH
58846: LD_VAR 0 1
58850: PPUSH
58851: LD_VAR 0 6
58855: PPUSH
58856: LD_VAR 0 11
58860: PPUSH
58861: CALL_OW 272
58865: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58866: LD_ADDR_VAR 0 8
58870: PUSH
58871: LD_VAR 0 2
58875: PPUSH
58876: LD_VAR 0 6
58880: PPUSH
58881: LD_VAR 0 11
58885: PPUSH
58886: CALL_OW 273
58890: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58891: LD_VAR 0 7
58895: PPUSH
58896: LD_VAR 0 8
58900: PPUSH
58901: CALL_OW 488
58905: NOT
58906: IFFALSE 58910
// continue ;
58908: GO 58838
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58910: LD_ADDR_VAR 0 9
58914: PUSH
58915: LD_VAR 0 12
58919: PUSH
58920: LD_INT 1
58922: ARRAY
58923: PPUSH
58924: LD_VAR 0 12
58928: PUSH
58929: LD_INT 2
58931: ARRAY
58932: PPUSH
58933: LD_VAR 0 7
58937: PPUSH
58938: LD_VAR 0 8
58942: PPUSH
58943: CALL_OW 298
58947: ST_TO_ADDR
// if tmp < distance then
58948: LD_VAR 0 9
58952: PUSH
58953: LD_VAR 0 10
58957: LESS
58958: IFFALSE 58980
// begin result := i ;
58960: LD_ADDR_VAR 0 5
58964: PUSH
58965: LD_VAR 0 6
58969: ST_TO_ADDR
// distance := tmp ;
58970: LD_ADDR_VAR 0 10
58974: PUSH
58975: LD_VAR 0 9
58979: ST_TO_ADDR
// end ; end ;
58980: GO 58838
58982: POP
58983: POP
// end ;
58984: LD_VAR 0 5
58988: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58989: LD_INT 0
58991: PPUSH
58992: PPUSH
// if not driver or not IsInUnit ( driver ) then
58993: LD_VAR 0 1
58997: NOT
58998: PUSH
58999: LD_VAR 0 1
59003: PPUSH
59004: CALL_OW 310
59008: NOT
59009: OR
59010: IFFALSE 59014
// exit ;
59012: GO 59104
// vehicle := IsInUnit ( driver ) ;
59014: LD_ADDR_VAR 0 3
59018: PUSH
59019: LD_VAR 0 1
59023: PPUSH
59024: CALL_OW 310
59028: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59029: LD_VAR 0 1
59033: PPUSH
59034: LD_STRING \
59036: PUSH
59037: LD_INT 0
59039: PUSH
59040: LD_INT 0
59042: PUSH
59043: LD_INT 0
59045: PUSH
59046: LD_INT 0
59048: PUSH
59049: LD_INT 0
59051: PUSH
59052: LD_INT 0
59054: PUSH
59055: EMPTY
59056: LIST
59057: LIST
59058: LIST
59059: LIST
59060: LIST
59061: LIST
59062: LIST
59063: PUSH
59064: LD_STRING E
59066: PUSH
59067: LD_INT 0
59069: PUSH
59070: LD_INT 0
59072: PUSH
59073: LD_VAR 0 3
59077: PUSH
59078: LD_INT 0
59080: PUSH
59081: LD_INT 0
59083: PUSH
59084: LD_INT 0
59086: PUSH
59087: EMPTY
59088: LIST
59089: LIST
59090: LIST
59091: LIST
59092: LIST
59093: LIST
59094: LIST
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: PPUSH
59100: CALL_OW 446
// end ;
59104: LD_VAR 0 2
59108: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59109: LD_INT 0
59111: PPUSH
59112: PPUSH
// if not driver or not IsInUnit ( driver ) then
59113: LD_VAR 0 1
59117: NOT
59118: PUSH
59119: LD_VAR 0 1
59123: PPUSH
59124: CALL_OW 310
59128: NOT
59129: OR
59130: IFFALSE 59134
// exit ;
59132: GO 59224
// vehicle := IsInUnit ( driver ) ;
59134: LD_ADDR_VAR 0 3
59138: PUSH
59139: LD_VAR 0 1
59143: PPUSH
59144: CALL_OW 310
59148: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59149: LD_VAR 0 1
59153: PPUSH
59154: LD_STRING \
59156: PUSH
59157: LD_INT 0
59159: PUSH
59160: LD_INT 0
59162: PUSH
59163: LD_INT 0
59165: PUSH
59166: LD_INT 0
59168: PUSH
59169: LD_INT 0
59171: PUSH
59172: LD_INT 0
59174: PUSH
59175: EMPTY
59176: LIST
59177: LIST
59178: LIST
59179: LIST
59180: LIST
59181: LIST
59182: LIST
59183: PUSH
59184: LD_STRING E
59186: PUSH
59187: LD_INT 0
59189: PUSH
59190: LD_INT 0
59192: PUSH
59193: LD_VAR 0 3
59197: PUSH
59198: LD_INT 0
59200: PUSH
59201: LD_INT 0
59203: PUSH
59204: LD_INT 0
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: LIST
59211: LIST
59212: LIST
59213: LIST
59214: LIST
59215: PUSH
59216: EMPTY
59217: LIST
59218: LIST
59219: PPUSH
59220: CALL_OW 447
// end ;
59224: LD_VAR 0 2
59228: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
59229: LD_INT 0
59231: PPUSH
59232: PPUSH
59233: PPUSH
// tmp := [ ] ;
59234: LD_ADDR_VAR 0 5
59238: PUSH
59239: EMPTY
59240: ST_TO_ADDR
// for i in units do
59241: LD_ADDR_VAR 0 4
59245: PUSH
59246: LD_VAR 0 1
59250: PUSH
59251: FOR_IN
59252: IFFALSE 59290
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
59254: LD_ADDR_VAR 0 5
59258: PUSH
59259: LD_VAR 0 5
59263: PPUSH
59264: LD_VAR 0 5
59268: PUSH
59269: LD_INT 1
59271: PLUS
59272: PPUSH
59273: LD_VAR 0 4
59277: PPUSH
59278: CALL_OW 256
59282: PPUSH
59283: CALL_OW 2
59287: ST_TO_ADDR
59288: GO 59251
59290: POP
59291: POP
// if not tmp then
59292: LD_VAR 0 5
59296: NOT
59297: IFFALSE 59301
// exit ;
59299: GO 59349
// if asc then
59301: LD_VAR 0 2
59305: IFFALSE 59329
// result := SortListByListAsc ( units , tmp ) else
59307: LD_ADDR_VAR 0 3
59311: PUSH
59312: LD_VAR 0 1
59316: PPUSH
59317: LD_VAR 0 5
59321: PPUSH
59322: CALL_OW 76
59326: ST_TO_ADDR
59327: GO 59349
// result := SortListByListDesc ( units , tmp ) ;
59329: LD_ADDR_VAR 0 3
59333: PUSH
59334: LD_VAR 0 1
59338: PPUSH
59339: LD_VAR 0 5
59343: PPUSH
59344: CALL_OW 77
59348: ST_TO_ADDR
// end ;
59349: LD_VAR 0 3
59353: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
59354: LD_INT 0
59356: PPUSH
59357: PPUSH
// task := GetTaskList ( mech ) ;
59358: LD_ADDR_VAR 0 4
59362: PUSH
59363: LD_VAR 0 1
59367: PPUSH
59368: CALL_OW 437
59372: ST_TO_ADDR
// if not task then
59373: LD_VAR 0 4
59377: NOT
59378: IFFALSE 59382
// exit ;
59380: GO 59424
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
59382: LD_ADDR_VAR 0 3
59386: PUSH
59387: LD_VAR 0 4
59391: PUSH
59392: LD_INT 1
59394: ARRAY
59395: PUSH
59396: LD_INT 1
59398: ARRAY
59399: PUSH
59400: LD_STRING r
59402: EQUAL
59403: PUSH
59404: LD_VAR 0 4
59408: PUSH
59409: LD_INT 1
59411: ARRAY
59412: PUSH
59413: LD_INT 4
59415: ARRAY
59416: PUSH
59417: LD_VAR 0 2
59421: EQUAL
59422: AND
59423: ST_TO_ADDR
// end ;
59424: LD_VAR 0 3
59428: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
59429: LD_INT 0
59431: PPUSH
// SetDir ( unit , d ) ;
59432: LD_VAR 0 1
59436: PPUSH
59437: LD_VAR 0 4
59441: PPUSH
59442: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
59446: LD_VAR 0 1
59450: PPUSH
59451: LD_VAR 0 2
59455: PPUSH
59456: LD_VAR 0 3
59460: PPUSH
59461: LD_VAR 0 5
59465: PPUSH
59466: CALL_OW 48
// end ;
59470: LD_VAR 0 6
59474: RET
// export function ToNaturalNumber ( number ) ; begin
59475: LD_INT 0
59477: PPUSH
// result := number div 1 ;
59478: LD_ADDR_VAR 0 2
59482: PUSH
59483: LD_VAR 0 1
59487: PUSH
59488: LD_INT 1
59490: DIV
59491: ST_TO_ADDR
// if number < 0 then
59492: LD_VAR 0 1
59496: PUSH
59497: LD_INT 0
59499: LESS
59500: IFFALSE 59510
// result := 0 ;
59502: LD_ADDR_VAR 0 2
59506: PUSH
59507: LD_INT 0
59509: ST_TO_ADDR
// end ;
59510: LD_VAR 0 2
59514: RET
// export function SortByClass ( units , class ) ; var un ; begin
59515: LD_INT 0
59517: PPUSH
59518: PPUSH
// if not units or not class then
59519: LD_VAR 0 1
59523: NOT
59524: PUSH
59525: LD_VAR 0 2
59529: NOT
59530: OR
59531: IFFALSE 59535
// exit ;
59533: GO 59630
// result := [ ] ;
59535: LD_ADDR_VAR 0 3
59539: PUSH
59540: EMPTY
59541: ST_TO_ADDR
// for un in units do
59542: LD_ADDR_VAR 0 4
59546: PUSH
59547: LD_VAR 0 1
59551: PUSH
59552: FOR_IN
59553: IFFALSE 59628
// if GetClass ( un ) = class then
59555: LD_VAR 0 4
59559: PPUSH
59560: CALL_OW 257
59564: PUSH
59565: LD_VAR 0 2
59569: EQUAL
59570: IFFALSE 59597
// result := Insert ( result , 1 , un ) else
59572: LD_ADDR_VAR 0 3
59576: PUSH
59577: LD_VAR 0 3
59581: PPUSH
59582: LD_INT 1
59584: PPUSH
59585: LD_VAR 0 4
59589: PPUSH
59590: CALL_OW 2
59594: ST_TO_ADDR
59595: GO 59626
// result := Replace ( result , result + 1 , un ) ;
59597: LD_ADDR_VAR 0 3
59601: PUSH
59602: LD_VAR 0 3
59606: PPUSH
59607: LD_VAR 0 3
59611: PUSH
59612: LD_INT 1
59614: PLUS
59615: PPUSH
59616: LD_VAR 0 4
59620: PPUSH
59621: CALL_OW 1
59625: ST_TO_ADDR
59626: GO 59552
59628: POP
59629: POP
// end ;
59630: LD_VAR 0 3
59634: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59635: LD_INT 0
59637: PPUSH
59638: PPUSH
59639: PPUSH
59640: PPUSH
59641: PPUSH
59642: PPUSH
59643: PPUSH
// result := [ ] ;
59644: LD_ADDR_VAR 0 4
59648: PUSH
59649: EMPTY
59650: ST_TO_ADDR
// if x - r < 0 then
59651: LD_VAR 0 1
59655: PUSH
59656: LD_VAR 0 3
59660: MINUS
59661: PUSH
59662: LD_INT 0
59664: LESS
59665: IFFALSE 59677
// min_x := 0 else
59667: LD_ADDR_VAR 0 8
59671: PUSH
59672: LD_INT 0
59674: ST_TO_ADDR
59675: GO 59693
// min_x := x - r ;
59677: LD_ADDR_VAR 0 8
59681: PUSH
59682: LD_VAR 0 1
59686: PUSH
59687: LD_VAR 0 3
59691: MINUS
59692: ST_TO_ADDR
// if y - r < 0 then
59693: LD_VAR 0 2
59697: PUSH
59698: LD_VAR 0 3
59702: MINUS
59703: PUSH
59704: LD_INT 0
59706: LESS
59707: IFFALSE 59719
// min_y := 0 else
59709: LD_ADDR_VAR 0 7
59713: PUSH
59714: LD_INT 0
59716: ST_TO_ADDR
59717: GO 59735
// min_y := y - r ;
59719: LD_ADDR_VAR 0 7
59723: PUSH
59724: LD_VAR 0 2
59728: PUSH
59729: LD_VAR 0 3
59733: MINUS
59734: ST_TO_ADDR
// max_x := x + r ;
59735: LD_ADDR_VAR 0 9
59739: PUSH
59740: LD_VAR 0 1
59744: PUSH
59745: LD_VAR 0 3
59749: PLUS
59750: ST_TO_ADDR
// max_y := y + r ;
59751: LD_ADDR_VAR 0 10
59755: PUSH
59756: LD_VAR 0 2
59760: PUSH
59761: LD_VAR 0 3
59765: PLUS
59766: ST_TO_ADDR
// for _x = min_x to max_x do
59767: LD_ADDR_VAR 0 5
59771: PUSH
59772: DOUBLE
59773: LD_VAR 0 8
59777: DEC
59778: ST_TO_ADDR
59779: LD_VAR 0 9
59783: PUSH
59784: FOR_TO
59785: IFFALSE 59886
// for _y = min_y to max_y do
59787: LD_ADDR_VAR 0 6
59791: PUSH
59792: DOUBLE
59793: LD_VAR 0 7
59797: DEC
59798: ST_TO_ADDR
59799: LD_VAR 0 10
59803: PUSH
59804: FOR_TO
59805: IFFALSE 59882
// begin if not ValidHex ( _x , _y ) then
59807: LD_VAR 0 5
59811: PPUSH
59812: LD_VAR 0 6
59816: PPUSH
59817: CALL_OW 488
59821: NOT
59822: IFFALSE 59826
// continue ;
59824: GO 59804
// if GetResourceTypeXY ( _x , _y ) then
59826: LD_VAR 0 5
59830: PPUSH
59831: LD_VAR 0 6
59835: PPUSH
59836: CALL_OW 283
59840: IFFALSE 59880
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59842: LD_ADDR_VAR 0 4
59846: PUSH
59847: LD_VAR 0 4
59851: PPUSH
59852: LD_VAR 0 4
59856: PUSH
59857: LD_INT 1
59859: PLUS
59860: PPUSH
59861: LD_VAR 0 5
59865: PUSH
59866: LD_VAR 0 6
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PPUSH
59875: CALL_OW 1
59879: ST_TO_ADDR
// end ;
59880: GO 59804
59882: POP
59883: POP
59884: GO 59784
59886: POP
59887: POP
// end ;
59888: LD_VAR 0 4
59892: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59893: LD_INT 0
59895: PPUSH
59896: PPUSH
59897: PPUSH
59898: PPUSH
59899: PPUSH
59900: PPUSH
59901: PPUSH
59902: PPUSH
// if not units then
59903: LD_VAR 0 1
59907: NOT
59908: IFFALSE 59912
// exit ;
59910: GO 60438
// result := UnitFilter ( units , [ f_ok ] ) ;
59912: LD_ADDR_VAR 0 3
59916: PUSH
59917: LD_VAR 0 1
59921: PPUSH
59922: LD_INT 50
59924: PUSH
59925: EMPTY
59926: LIST
59927: PPUSH
59928: CALL_OW 72
59932: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59933: LD_ADDR_VAR 0 8
59937: PUSH
59938: LD_VAR 0 1
59942: PUSH
59943: LD_INT 1
59945: ARRAY
59946: PPUSH
59947: CALL_OW 255
59951: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59952: LD_ADDR_VAR 0 10
59956: PUSH
59957: LD_INT 29
59959: PUSH
59960: LD_EXP 33
59964: PUSH
59965: LD_INT 49
59967: PUSH
59968: EMPTY
59969: LIST
59970: LIST
59971: LIST
59972: ST_TO_ADDR
// if not result then
59973: LD_VAR 0 3
59977: NOT
59978: IFFALSE 59982
// exit ;
59980: GO 60438
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59982: LD_ADDR_VAR 0 5
59986: PUSH
59987: LD_INT 81
59989: PUSH
59990: LD_VAR 0 8
59994: PUSH
59995: EMPTY
59996: LIST
59997: LIST
59998: PPUSH
59999: CALL_OW 69
60003: ST_TO_ADDR
// for i in result do
60004: LD_ADDR_VAR 0 4
60008: PUSH
60009: LD_VAR 0 3
60013: PUSH
60014: FOR_IN
60015: IFFALSE 60436
// begin tag := GetTag ( i ) + 1 ;
60017: LD_ADDR_VAR 0 9
60021: PUSH
60022: LD_VAR 0 4
60026: PPUSH
60027: CALL_OW 110
60031: PUSH
60032: LD_INT 1
60034: PLUS
60035: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
60036: LD_ADDR_VAR 0 7
60040: PUSH
60041: LD_VAR 0 4
60045: PPUSH
60046: CALL_OW 250
60050: PPUSH
60051: LD_VAR 0 4
60055: PPUSH
60056: CALL_OW 251
60060: PPUSH
60061: LD_INT 6
60063: PPUSH
60064: CALL 59635 0 3
60068: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
60069: LD_VAR 0 4
60073: PPUSH
60074: CALL_OW 247
60078: PUSH
60079: LD_INT 2
60081: EQUAL
60082: PUSH
60083: LD_VAR 0 7
60087: AND
60088: PUSH
60089: LD_VAR 0 4
60093: PPUSH
60094: CALL_OW 264
60098: PUSH
60099: LD_VAR 0 10
60103: IN
60104: NOT
60105: AND
60106: IFFALSE 60145
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
60108: LD_VAR 0 4
60112: PPUSH
60113: LD_VAR 0 7
60117: PUSH
60118: LD_INT 1
60120: ARRAY
60121: PUSH
60122: LD_INT 1
60124: ARRAY
60125: PPUSH
60126: LD_VAR 0 7
60130: PUSH
60131: LD_INT 1
60133: ARRAY
60134: PUSH
60135: LD_INT 2
60137: ARRAY
60138: PPUSH
60139: CALL_OW 116
60143: GO 60434
// if path > tag then
60145: LD_VAR 0 2
60149: PUSH
60150: LD_VAR 0 9
60154: GREATER
60155: IFFALSE 60363
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
60157: LD_ADDR_VAR 0 6
60161: PUSH
60162: LD_VAR 0 5
60166: PPUSH
60167: LD_INT 91
60169: PUSH
60170: LD_VAR 0 4
60174: PUSH
60175: LD_INT 8
60177: PUSH
60178: EMPTY
60179: LIST
60180: LIST
60181: LIST
60182: PPUSH
60183: CALL_OW 72
60187: ST_TO_ADDR
// if nearEnemy then
60188: LD_VAR 0 6
60192: IFFALSE 60261
// begin if GetWeapon ( i ) = ru_time_lapser then
60194: LD_VAR 0 4
60198: PPUSH
60199: CALL_OW 264
60203: PUSH
60204: LD_INT 49
60206: EQUAL
60207: IFFALSE 60235
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
60209: LD_VAR 0 4
60213: PPUSH
60214: LD_VAR 0 6
60218: PPUSH
60219: LD_VAR 0 4
60223: PPUSH
60224: CALL_OW 74
60228: PPUSH
60229: CALL_OW 112
60233: GO 60259
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
60235: LD_VAR 0 4
60239: PPUSH
60240: LD_VAR 0 6
60244: PPUSH
60245: LD_VAR 0 4
60249: PPUSH
60250: CALL_OW 74
60254: PPUSH
60255: CALL_OW 115
// end else
60259: GO 60361
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
60261: LD_VAR 0 4
60265: PPUSH
60266: LD_VAR 0 2
60270: PUSH
60271: LD_VAR 0 9
60275: ARRAY
60276: PUSH
60277: LD_INT 1
60279: ARRAY
60280: PPUSH
60281: LD_VAR 0 2
60285: PUSH
60286: LD_VAR 0 9
60290: ARRAY
60291: PUSH
60292: LD_INT 2
60294: ARRAY
60295: PPUSH
60296: CALL_OW 297
60300: PUSH
60301: LD_INT 6
60303: GREATER
60304: IFFALSE 60347
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
60306: LD_VAR 0 4
60310: PPUSH
60311: LD_VAR 0 2
60315: PUSH
60316: LD_VAR 0 9
60320: ARRAY
60321: PUSH
60322: LD_INT 1
60324: ARRAY
60325: PPUSH
60326: LD_VAR 0 2
60330: PUSH
60331: LD_VAR 0 9
60335: ARRAY
60336: PUSH
60337: LD_INT 2
60339: ARRAY
60340: PPUSH
60341: CALL_OW 114
60345: GO 60361
// SetTag ( i , tag ) ;
60347: LD_VAR 0 4
60351: PPUSH
60352: LD_VAR 0 9
60356: PPUSH
60357: CALL_OW 109
// end else
60361: GO 60434
// if enemy then
60363: LD_VAR 0 5
60367: IFFALSE 60434
// begin if GetWeapon ( i ) = ru_time_lapser then
60369: LD_VAR 0 4
60373: PPUSH
60374: CALL_OW 264
60378: PUSH
60379: LD_INT 49
60381: EQUAL
60382: IFFALSE 60410
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60384: LD_VAR 0 4
60388: PPUSH
60389: LD_VAR 0 5
60393: PPUSH
60394: LD_VAR 0 4
60398: PPUSH
60399: CALL_OW 74
60403: PPUSH
60404: CALL_OW 112
60408: GO 60434
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
60410: LD_VAR 0 4
60414: PPUSH
60415: LD_VAR 0 5
60419: PPUSH
60420: LD_VAR 0 4
60424: PPUSH
60425: CALL_OW 74
60429: PPUSH
60430: CALL_OW 115
// end ; end ;
60434: GO 60014
60436: POP
60437: POP
// end ;
60438: LD_VAR 0 3
60442: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
60443: LD_INT 0
60445: PPUSH
60446: PPUSH
60447: PPUSH
// if not unit or IsInUnit ( unit ) then
60448: LD_VAR 0 1
60452: NOT
60453: PUSH
60454: LD_VAR 0 1
60458: PPUSH
60459: CALL_OW 310
60463: OR
60464: IFFALSE 60468
// exit ;
60466: GO 60559
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
60468: LD_ADDR_VAR 0 4
60472: PUSH
60473: LD_VAR 0 1
60477: PPUSH
60478: CALL_OW 250
60482: PPUSH
60483: LD_VAR 0 2
60487: PPUSH
60488: LD_INT 1
60490: PPUSH
60491: CALL_OW 272
60495: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
60496: LD_ADDR_VAR 0 5
60500: PUSH
60501: LD_VAR 0 1
60505: PPUSH
60506: CALL_OW 251
60510: PPUSH
60511: LD_VAR 0 2
60515: PPUSH
60516: LD_INT 1
60518: PPUSH
60519: CALL_OW 273
60523: ST_TO_ADDR
// if ValidHex ( x , y ) then
60524: LD_VAR 0 4
60528: PPUSH
60529: LD_VAR 0 5
60533: PPUSH
60534: CALL_OW 488
60538: IFFALSE 60559
// ComTurnXY ( unit , x , y ) ;
60540: LD_VAR 0 1
60544: PPUSH
60545: LD_VAR 0 4
60549: PPUSH
60550: LD_VAR 0 5
60554: PPUSH
60555: CALL_OW 118
// end ;
60559: LD_VAR 0 3
60563: RET
// export function SeeUnits ( side , units ) ; var i ; begin
60564: LD_INT 0
60566: PPUSH
60567: PPUSH
// result := false ;
60568: LD_ADDR_VAR 0 3
60572: PUSH
60573: LD_INT 0
60575: ST_TO_ADDR
// if not units then
60576: LD_VAR 0 2
60580: NOT
60581: IFFALSE 60585
// exit ;
60583: GO 60630
// for i in units do
60585: LD_ADDR_VAR 0 4
60589: PUSH
60590: LD_VAR 0 2
60594: PUSH
60595: FOR_IN
60596: IFFALSE 60628
// if See ( side , i ) then
60598: LD_VAR 0 1
60602: PPUSH
60603: LD_VAR 0 4
60607: PPUSH
60608: CALL_OW 292
60612: IFFALSE 60626
// begin result := true ;
60614: LD_ADDR_VAR 0 3
60618: PUSH
60619: LD_INT 1
60621: ST_TO_ADDR
// exit ;
60622: POP
60623: POP
60624: GO 60630
// end ;
60626: GO 60595
60628: POP
60629: POP
// end ;
60630: LD_VAR 0 3
60634: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60635: LD_INT 0
60637: PPUSH
60638: PPUSH
60639: PPUSH
60640: PPUSH
// if not unit or not points then
60641: LD_VAR 0 1
60645: NOT
60646: PUSH
60647: LD_VAR 0 2
60651: NOT
60652: OR
60653: IFFALSE 60657
// exit ;
60655: GO 60747
// dist := 99999 ;
60657: LD_ADDR_VAR 0 5
60661: PUSH
60662: LD_INT 99999
60664: ST_TO_ADDR
// for i in points do
60665: LD_ADDR_VAR 0 4
60669: PUSH
60670: LD_VAR 0 2
60674: PUSH
60675: FOR_IN
60676: IFFALSE 60745
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60678: LD_ADDR_VAR 0 6
60682: PUSH
60683: LD_VAR 0 1
60687: PPUSH
60688: LD_VAR 0 4
60692: PUSH
60693: LD_INT 1
60695: ARRAY
60696: PPUSH
60697: LD_VAR 0 4
60701: PUSH
60702: LD_INT 2
60704: ARRAY
60705: PPUSH
60706: CALL_OW 297
60710: ST_TO_ADDR
// if tmpDist < dist then
60711: LD_VAR 0 6
60715: PUSH
60716: LD_VAR 0 5
60720: LESS
60721: IFFALSE 60743
// begin result := i ;
60723: LD_ADDR_VAR 0 3
60727: PUSH
60728: LD_VAR 0 4
60732: ST_TO_ADDR
// dist := tmpDist ;
60733: LD_ADDR_VAR 0 5
60737: PUSH
60738: LD_VAR 0 6
60742: ST_TO_ADDR
// end ; end ;
60743: GO 60675
60745: POP
60746: POP
// end ;
60747: LD_VAR 0 3
60751: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60752: LD_INT 0
60754: PPUSH
// uc_side := side ;
60755: LD_ADDR_OWVAR 20
60759: PUSH
60760: LD_VAR 0 1
60764: ST_TO_ADDR
// uc_nation := 3 ;
60765: LD_ADDR_OWVAR 21
60769: PUSH
60770: LD_INT 3
60772: ST_TO_ADDR
// vc_chassis := 25 ;
60773: LD_ADDR_OWVAR 37
60777: PUSH
60778: LD_INT 25
60780: ST_TO_ADDR
// vc_engine := engine_siberite ;
60781: LD_ADDR_OWVAR 39
60785: PUSH
60786: LD_INT 3
60788: ST_TO_ADDR
// vc_control := control_computer ;
60789: LD_ADDR_OWVAR 38
60793: PUSH
60794: LD_INT 3
60796: ST_TO_ADDR
// vc_weapon := 59 ;
60797: LD_ADDR_OWVAR 40
60801: PUSH
60802: LD_INT 59
60804: ST_TO_ADDR
// result := CreateVehicle ;
60805: LD_ADDR_VAR 0 5
60809: PUSH
60810: CALL_OW 45
60814: ST_TO_ADDR
// SetDir ( result , d ) ;
60815: LD_VAR 0 5
60819: PPUSH
60820: LD_VAR 0 4
60824: PPUSH
60825: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60829: LD_VAR 0 5
60833: PPUSH
60834: LD_VAR 0 2
60838: PPUSH
60839: LD_VAR 0 3
60843: PPUSH
60844: LD_INT 0
60846: PPUSH
60847: CALL_OW 48
// end ;
60851: LD_VAR 0 5
60855: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60856: LD_INT 0
60858: PPUSH
60859: PPUSH
60860: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60861: LD_ADDR_VAR 0 2
60865: PUSH
60866: LD_INT 0
60868: PUSH
60869: LD_INT 0
60871: PUSH
60872: LD_INT 0
60874: PUSH
60875: LD_INT 0
60877: PUSH
60878: EMPTY
60879: LIST
60880: LIST
60881: LIST
60882: LIST
60883: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60884: LD_VAR 0 1
60888: NOT
60889: PUSH
60890: LD_VAR 0 1
60894: PPUSH
60895: CALL_OW 264
60899: PUSH
60900: LD_INT 12
60902: PUSH
60903: LD_INT 51
60905: PUSH
60906: LD_INT 32
60908: PUSH
60909: LD_EXP 30
60913: PUSH
60914: EMPTY
60915: LIST
60916: LIST
60917: LIST
60918: LIST
60919: IN
60920: NOT
60921: OR
60922: IFFALSE 60926
// exit ;
60924: GO 61024
// for i := 1 to 3 do
60926: LD_ADDR_VAR 0 3
60930: PUSH
60931: DOUBLE
60932: LD_INT 1
60934: DEC
60935: ST_TO_ADDR
60936: LD_INT 3
60938: PUSH
60939: FOR_TO
60940: IFFALSE 61022
// begin tmp := GetCargo ( cargo , i ) ;
60942: LD_ADDR_VAR 0 4
60946: PUSH
60947: LD_VAR 0 1
60951: PPUSH
60952: LD_VAR 0 3
60956: PPUSH
60957: CALL_OW 289
60961: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
60962: LD_ADDR_VAR 0 2
60966: PUSH
60967: LD_VAR 0 2
60971: PPUSH
60972: LD_VAR 0 3
60976: PPUSH
60977: LD_VAR 0 4
60981: PPUSH
60982: CALL_OW 1
60986: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
60987: LD_ADDR_VAR 0 2
60991: PUSH
60992: LD_VAR 0 2
60996: PPUSH
60997: LD_INT 4
60999: PPUSH
61000: LD_VAR 0 2
61004: PUSH
61005: LD_INT 4
61007: ARRAY
61008: PUSH
61009: LD_VAR 0 4
61013: PLUS
61014: PPUSH
61015: CALL_OW 1
61019: ST_TO_ADDR
// end ;
61020: GO 60939
61022: POP
61023: POP
// end ;
61024: LD_VAR 0 2
61028: RET
// export function Length ( array ) ; begin
61029: LD_INT 0
61031: PPUSH
// result := array + 0 ;
61032: LD_ADDR_VAR 0 2
61036: PUSH
61037: LD_VAR 0 1
61041: PUSH
61042: LD_INT 0
61044: PLUS
61045: ST_TO_ADDR
// end ;
61046: LD_VAR 0 2
61050: RET
// export function PrepareArray ( array ) ; begin
61051: LD_INT 0
61053: PPUSH
// result := array diff 0 ;
61054: LD_ADDR_VAR 0 2
61058: PUSH
61059: LD_VAR 0 1
61063: PUSH
61064: LD_INT 0
61066: DIFF
61067: ST_TO_ADDR
// if not result [ 1 ] then
61068: LD_VAR 0 2
61072: PUSH
61073: LD_INT 1
61075: ARRAY
61076: NOT
61077: IFFALSE 61097
// result := Delete ( result , 1 ) ;
61079: LD_ADDR_VAR 0 2
61083: PUSH
61084: LD_VAR 0 2
61088: PPUSH
61089: LD_INT 1
61091: PPUSH
61092: CALL_OW 3
61096: ST_TO_ADDR
// end ; end_of_file
61097: LD_VAR 0 2
61101: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
61102: LD_INT 0
61104: PPUSH
// ar_miner := 81 ;
61105: LD_ADDR_EXP 36
61109: PUSH
61110: LD_INT 81
61112: ST_TO_ADDR
// ar_crane := 88 ;
61113: LD_ADDR_EXP 35
61117: PUSH
61118: LD_INT 88
61120: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
61121: LD_ADDR_EXP 30
61125: PUSH
61126: LD_INT 89
61128: ST_TO_ADDR
// us_hack := 99 ;
61129: LD_ADDR_EXP 31
61133: PUSH
61134: LD_INT 99
61136: ST_TO_ADDR
// us_artillery := 97 ;
61137: LD_ADDR_EXP 32
61141: PUSH
61142: LD_INT 97
61144: ST_TO_ADDR
// ar_bio_bomb := 91 ;
61145: LD_ADDR_EXP 33
61149: PUSH
61150: LD_INT 91
61152: ST_TO_ADDR
// ar_mortar := 92 ;
61153: LD_ADDR_EXP 34
61157: PUSH
61158: LD_INT 92
61160: ST_TO_ADDR
// ru_flamethrower := 93 ;
61161: LD_ADDR_EXP 37
61165: PUSH
61166: LD_INT 93
61168: ST_TO_ADDR
// ru_radar := 98 ;
61169: LD_ADDR_EXP 29
61173: PUSH
61174: LD_INT 98
61176: ST_TO_ADDR
// tech_Artillery := 80 ;
61177: LD_ADDR_EXP 38
61181: PUSH
61182: LD_INT 80
61184: ST_TO_ADDR
// tech_RadMat := 81 ;
61185: LD_ADDR_EXP 39
61189: PUSH
61190: LD_INT 81
61192: ST_TO_ADDR
// tech_BasicTools := 82 ;
61193: LD_ADDR_EXP 40
61197: PUSH
61198: LD_INT 82
61200: ST_TO_ADDR
// tech_Cargo := 83 ;
61201: LD_ADDR_EXP 41
61205: PUSH
61206: LD_INT 83
61208: ST_TO_ADDR
// tech_Track := 84 ;
61209: LD_ADDR_EXP 42
61213: PUSH
61214: LD_INT 84
61216: ST_TO_ADDR
// tech_Crane := 85 ;
61217: LD_ADDR_EXP 43
61221: PUSH
61222: LD_INT 85
61224: ST_TO_ADDR
// tech_Bulldozer := 86 ;
61225: LD_ADDR_EXP 44
61229: PUSH
61230: LD_INT 86
61232: ST_TO_ADDR
// tech_Hovercraft := 87 ;
61233: LD_ADDR_EXP 45
61237: PUSH
61238: LD_INT 87
61240: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
61241: LD_ADDR_EXP 46
61245: PUSH
61246: LD_INT 88
61248: ST_TO_ADDR
// end ;
61249: LD_VAR 0 1
61253: RET
// every 1 do
61254: GO 61256
61256: DISABLE
// InitGlobalVariables ; end_of_file
61257: CALL 61102 0 0
61261: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
61262: LD_INT 0
61264: PPUSH
61265: PPUSH
// skirmish := false ;
61266: LD_ADDR_EXP 47
61270: PUSH
61271: LD_INT 0
61273: ST_TO_ADDR
// debug_mc := false ;
61274: LD_ADDR_EXP 48
61278: PUSH
61279: LD_INT 0
61281: ST_TO_ADDR
// mc_bases := [ ] ;
61282: LD_ADDR_EXP 49
61286: PUSH
61287: EMPTY
61288: ST_TO_ADDR
// mc_sides := [ ] ;
61289: LD_ADDR_EXP 75
61293: PUSH
61294: EMPTY
61295: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61296: LD_ADDR_EXP 50
61300: PUSH
61301: EMPTY
61302: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61303: LD_ADDR_EXP 51
61307: PUSH
61308: EMPTY
61309: ST_TO_ADDR
// mc_need_heal := [ ] ;
61310: LD_ADDR_EXP 52
61314: PUSH
61315: EMPTY
61316: ST_TO_ADDR
// mc_healers := [ ] ;
61317: LD_ADDR_EXP 53
61321: PUSH
61322: EMPTY
61323: ST_TO_ADDR
// mc_build_list := [ ] ;
61324: LD_ADDR_EXP 54
61328: PUSH
61329: EMPTY
61330: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61331: LD_ADDR_EXP 81
61335: PUSH
61336: EMPTY
61337: ST_TO_ADDR
// mc_builders := [ ] ;
61338: LD_ADDR_EXP 55
61342: PUSH
61343: EMPTY
61344: ST_TO_ADDR
// mc_construct_list := [ ] ;
61345: LD_ADDR_EXP 56
61349: PUSH
61350: EMPTY
61351: ST_TO_ADDR
// mc_turret_list := [ ] ;
61352: LD_ADDR_EXP 57
61356: PUSH
61357: EMPTY
61358: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61359: LD_ADDR_EXP 58
61363: PUSH
61364: EMPTY
61365: ST_TO_ADDR
// mc_miners := [ ] ;
61366: LD_ADDR_EXP 63
61370: PUSH
61371: EMPTY
61372: ST_TO_ADDR
// mc_mines := [ ] ;
61373: LD_ADDR_EXP 62
61377: PUSH
61378: EMPTY
61379: ST_TO_ADDR
// mc_minefields := [ ] ;
61380: LD_ADDR_EXP 64
61384: PUSH
61385: EMPTY
61386: ST_TO_ADDR
// mc_crates := [ ] ;
61387: LD_ADDR_EXP 65
61391: PUSH
61392: EMPTY
61393: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61394: LD_ADDR_EXP 66
61398: PUSH
61399: EMPTY
61400: ST_TO_ADDR
// mc_crates_area := [ ] ;
61401: LD_ADDR_EXP 67
61405: PUSH
61406: EMPTY
61407: ST_TO_ADDR
// mc_vehicles := [ ] ;
61408: LD_ADDR_EXP 68
61412: PUSH
61413: EMPTY
61414: ST_TO_ADDR
// mc_attack := [ ] ;
61415: LD_ADDR_EXP 69
61419: PUSH
61420: EMPTY
61421: ST_TO_ADDR
// mc_produce := [ ] ;
61422: LD_ADDR_EXP 70
61426: PUSH
61427: EMPTY
61428: ST_TO_ADDR
// mc_defender := [ ] ;
61429: LD_ADDR_EXP 71
61433: PUSH
61434: EMPTY
61435: ST_TO_ADDR
// mc_parking := [ ] ;
61436: LD_ADDR_EXP 73
61440: PUSH
61441: EMPTY
61442: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61443: LD_ADDR_EXP 59
61447: PUSH
61448: EMPTY
61449: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61450: LD_ADDR_EXP 61
61454: PUSH
61455: EMPTY
61456: ST_TO_ADDR
// mc_scan := [ ] ;
61457: LD_ADDR_EXP 72
61461: PUSH
61462: EMPTY
61463: ST_TO_ADDR
// mc_scan_area := [ ] ;
61464: LD_ADDR_EXP 74
61468: PUSH
61469: EMPTY
61470: ST_TO_ADDR
// mc_tech := [ ] ;
61471: LD_ADDR_EXP 76
61475: PUSH
61476: EMPTY
61477: ST_TO_ADDR
// mc_class := [ ] ;
61478: LD_ADDR_EXP 90
61482: PUSH
61483: EMPTY
61484: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61485: LD_ADDR_EXP 91
61489: PUSH
61490: EMPTY
61491: ST_TO_ADDR
// mc_is_defending := [ ] ;
61492: LD_ADDR_EXP 92
61496: PUSH
61497: EMPTY
61498: ST_TO_ADDR
// end ;
61499: LD_VAR 0 1
61503: RET
// export function MC_Kill ( base ) ; begin
61504: LD_INT 0
61506: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61507: LD_ADDR_EXP 49
61511: PUSH
61512: LD_EXP 49
61516: PPUSH
61517: LD_VAR 0 1
61521: PPUSH
61522: EMPTY
61523: PPUSH
61524: CALL_OW 1
61528: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61529: LD_ADDR_EXP 50
61533: PUSH
61534: LD_EXP 50
61538: PPUSH
61539: LD_VAR 0 1
61543: PPUSH
61544: EMPTY
61545: PPUSH
61546: CALL_OW 1
61550: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61551: LD_ADDR_EXP 51
61555: PUSH
61556: LD_EXP 51
61560: PPUSH
61561: LD_VAR 0 1
61565: PPUSH
61566: EMPTY
61567: PPUSH
61568: CALL_OW 1
61572: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61573: LD_ADDR_EXP 52
61577: PUSH
61578: LD_EXP 52
61582: PPUSH
61583: LD_VAR 0 1
61587: PPUSH
61588: EMPTY
61589: PPUSH
61590: CALL_OW 1
61594: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61595: LD_ADDR_EXP 53
61599: PUSH
61600: LD_EXP 53
61604: PPUSH
61605: LD_VAR 0 1
61609: PPUSH
61610: EMPTY
61611: PPUSH
61612: CALL_OW 1
61616: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61617: LD_ADDR_EXP 54
61621: PUSH
61622: LD_EXP 54
61626: PPUSH
61627: LD_VAR 0 1
61631: PPUSH
61632: EMPTY
61633: PPUSH
61634: CALL_OW 1
61638: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61639: LD_ADDR_EXP 55
61643: PUSH
61644: LD_EXP 55
61648: PPUSH
61649: LD_VAR 0 1
61653: PPUSH
61654: EMPTY
61655: PPUSH
61656: CALL_OW 1
61660: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61661: LD_ADDR_EXP 56
61665: PUSH
61666: LD_EXP 56
61670: PPUSH
61671: LD_VAR 0 1
61675: PPUSH
61676: EMPTY
61677: PPUSH
61678: CALL_OW 1
61682: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61683: LD_ADDR_EXP 57
61687: PUSH
61688: LD_EXP 57
61692: PPUSH
61693: LD_VAR 0 1
61697: PPUSH
61698: EMPTY
61699: PPUSH
61700: CALL_OW 1
61704: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61705: LD_ADDR_EXP 58
61709: PUSH
61710: LD_EXP 58
61714: PPUSH
61715: LD_VAR 0 1
61719: PPUSH
61720: EMPTY
61721: PPUSH
61722: CALL_OW 1
61726: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61727: LD_ADDR_EXP 59
61731: PUSH
61732: LD_EXP 59
61736: PPUSH
61737: LD_VAR 0 1
61741: PPUSH
61742: EMPTY
61743: PPUSH
61744: CALL_OW 1
61748: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61749: LD_ADDR_EXP 60
61753: PUSH
61754: LD_EXP 60
61758: PPUSH
61759: LD_VAR 0 1
61763: PPUSH
61764: LD_INT 0
61766: PPUSH
61767: CALL_OW 1
61771: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61772: LD_ADDR_EXP 61
61776: PUSH
61777: LD_EXP 61
61781: PPUSH
61782: LD_VAR 0 1
61786: PPUSH
61787: EMPTY
61788: PPUSH
61789: CALL_OW 1
61793: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61794: LD_ADDR_EXP 62
61798: PUSH
61799: LD_EXP 62
61803: PPUSH
61804: LD_VAR 0 1
61808: PPUSH
61809: EMPTY
61810: PPUSH
61811: CALL_OW 1
61815: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61816: LD_ADDR_EXP 63
61820: PUSH
61821: LD_EXP 63
61825: PPUSH
61826: LD_VAR 0 1
61830: PPUSH
61831: EMPTY
61832: PPUSH
61833: CALL_OW 1
61837: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61838: LD_ADDR_EXP 64
61842: PUSH
61843: LD_EXP 64
61847: PPUSH
61848: LD_VAR 0 1
61852: PPUSH
61853: EMPTY
61854: PPUSH
61855: CALL_OW 1
61859: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61860: LD_ADDR_EXP 65
61864: PUSH
61865: LD_EXP 65
61869: PPUSH
61870: LD_VAR 0 1
61874: PPUSH
61875: EMPTY
61876: PPUSH
61877: CALL_OW 1
61881: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61882: LD_ADDR_EXP 66
61886: PUSH
61887: LD_EXP 66
61891: PPUSH
61892: LD_VAR 0 1
61896: PPUSH
61897: EMPTY
61898: PPUSH
61899: CALL_OW 1
61903: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61904: LD_ADDR_EXP 67
61908: PUSH
61909: LD_EXP 67
61913: PPUSH
61914: LD_VAR 0 1
61918: PPUSH
61919: EMPTY
61920: PPUSH
61921: CALL_OW 1
61925: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61926: LD_ADDR_EXP 68
61930: PUSH
61931: LD_EXP 68
61935: PPUSH
61936: LD_VAR 0 1
61940: PPUSH
61941: EMPTY
61942: PPUSH
61943: CALL_OW 1
61947: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61948: LD_ADDR_EXP 69
61952: PUSH
61953: LD_EXP 69
61957: PPUSH
61958: LD_VAR 0 1
61962: PPUSH
61963: EMPTY
61964: PPUSH
61965: CALL_OW 1
61969: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61970: LD_ADDR_EXP 70
61974: PUSH
61975: LD_EXP 70
61979: PPUSH
61980: LD_VAR 0 1
61984: PPUSH
61985: EMPTY
61986: PPUSH
61987: CALL_OW 1
61991: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61992: LD_ADDR_EXP 71
61996: PUSH
61997: LD_EXP 71
62001: PPUSH
62002: LD_VAR 0 1
62006: PPUSH
62007: EMPTY
62008: PPUSH
62009: CALL_OW 1
62013: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62014: LD_ADDR_EXP 72
62018: PUSH
62019: LD_EXP 72
62023: PPUSH
62024: LD_VAR 0 1
62028: PPUSH
62029: EMPTY
62030: PPUSH
62031: CALL_OW 1
62035: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62036: LD_ADDR_EXP 73
62040: PUSH
62041: LD_EXP 73
62045: PPUSH
62046: LD_VAR 0 1
62050: PPUSH
62051: EMPTY
62052: PPUSH
62053: CALL_OW 1
62057: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62058: LD_ADDR_EXP 74
62062: PUSH
62063: LD_EXP 74
62067: PPUSH
62068: LD_VAR 0 1
62072: PPUSH
62073: EMPTY
62074: PPUSH
62075: CALL_OW 1
62079: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62080: LD_ADDR_EXP 76
62084: PUSH
62085: LD_EXP 76
62089: PPUSH
62090: LD_VAR 0 1
62094: PPUSH
62095: EMPTY
62096: PPUSH
62097: CALL_OW 1
62101: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62102: LD_ADDR_EXP 78
62106: PUSH
62107: LD_EXP 78
62111: PPUSH
62112: LD_VAR 0 1
62116: PPUSH
62117: EMPTY
62118: PPUSH
62119: CALL_OW 1
62123: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62124: LD_ADDR_EXP 79
62128: PUSH
62129: LD_EXP 79
62133: PPUSH
62134: LD_VAR 0 1
62138: PPUSH
62139: EMPTY
62140: PPUSH
62141: CALL_OW 1
62145: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62146: LD_ADDR_EXP 80
62150: PUSH
62151: LD_EXP 80
62155: PPUSH
62156: LD_VAR 0 1
62160: PPUSH
62161: EMPTY
62162: PPUSH
62163: CALL_OW 1
62167: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62168: LD_ADDR_EXP 81
62172: PUSH
62173: LD_EXP 81
62177: PPUSH
62178: LD_VAR 0 1
62182: PPUSH
62183: EMPTY
62184: PPUSH
62185: CALL_OW 1
62189: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62190: LD_ADDR_EXP 82
62194: PUSH
62195: LD_EXP 82
62199: PPUSH
62200: LD_VAR 0 1
62204: PPUSH
62205: EMPTY
62206: PPUSH
62207: CALL_OW 1
62211: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62212: LD_ADDR_EXP 83
62216: PUSH
62217: LD_EXP 83
62221: PPUSH
62222: LD_VAR 0 1
62226: PPUSH
62227: EMPTY
62228: PPUSH
62229: CALL_OW 1
62233: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62234: LD_ADDR_EXP 84
62238: PUSH
62239: LD_EXP 84
62243: PPUSH
62244: LD_VAR 0 1
62248: PPUSH
62249: EMPTY
62250: PPUSH
62251: CALL_OW 1
62255: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62256: LD_ADDR_EXP 85
62260: PUSH
62261: LD_EXP 85
62265: PPUSH
62266: LD_VAR 0 1
62270: PPUSH
62271: EMPTY
62272: PPUSH
62273: CALL_OW 1
62277: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62278: LD_ADDR_EXP 86
62282: PUSH
62283: LD_EXP 86
62287: PPUSH
62288: LD_VAR 0 1
62292: PPUSH
62293: EMPTY
62294: PPUSH
62295: CALL_OW 1
62299: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62300: LD_ADDR_EXP 87
62304: PUSH
62305: LD_EXP 87
62309: PPUSH
62310: LD_VAR 0 1
62314: PPUSH
62315: EMPTY
62316: PPUSH
62317: CALL_OW 1
62321: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62322: LD_ADDR_EXP 88
62326: PUSH
62327: LD_EXP 88
62331: PPUSH
62332: LD_VAR 0 1
62336: PPUSH
62337: EMPTY
62338: PPUSH
62339: CALL_OW 1
62343: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62344: LD_ADDR_EXP 89
62348: PUSH
62349: LD_EXP 89
62353: PPUSH
62354: LD_VAR 0 1
62358: PPUSH
62359: EMPTY
62360: PPUSH
62361: CALL_OW 1
62365: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62366: LD_ADDR_EXP 90
62370: PUSH
62371: LD_EXP 90
62375: PPUSH
62376: LD_VAR 0 1
62380: PPUSH
62381: EMPTY
62382: PPUSH
62383: CALL_OW 1
62387: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62388: LD_ADDR_EXP 91
62392: PUSH
62393: LD_EXP 91
62397: PPUSH
62398: LD_VAR 0 1
62402: PPUSH
62403: LD_INT 0
62405: PPUSH
62406: CALL_OW 1
62410: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62411: LD_ADDR_EXP 92
62415: PUSH
62416: LD_EXP 92
62420: PPUSH
62421: LD_VAR 0 1
62425: PPUSH
62426: LD_INT 0
62428: PPUSH
62429: CALL_OW 1
62433: ST_TO_ADDR
// end ;
62434: LD_VAR 0 2
62438: RET
// export function MC_Add ( side , units ) ; var base ; begin
62439: LD_INT 0
62441: PPUSH
62442: PPUSH
// base := mc_bases + 1 ;
62443: LD_ADDR_VAR 0 4
62447: PUSH
62448: LD_EXP 49
62452: PUSH
62453: LD_INT 1
62455: PLUS
62456: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62457: LD_ADDR_EXP 75
62461: PUSH
62462: LD_EXP 75
62466: PPUSH
62467: LD_VAR 0 4
62471: PPUSH
62472: LD_VAR 0 1
62476: PPUSH
62477: CALL_OW 1
62481: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62482: LD_ADDR_EXP 49
62486: PUSH
62487: LD_EXP 49
62491: PPUSH
62492: LD_VAR 0 4
62496: PPUSH
62497: LD_VAR 0 2
62501: PPUSH
62502: CALL_OW 1
62506: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62507: LD_ADDR_EXP 50
62511: PUSH
62512: LD_EXP 50
62516: PPUSH
62517: LD_VAR 0 4
62521: PPUSH
62522: EMPTY
62523: PPUSH
62524: CALL_OW 1
62528: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62529: LD_ADDR_EXP 51
62533: PUSH
62534: LD_EXP 51
62538: PPUSH
62539: LD_VAR 0 4
62543: PPUSH
62544: EMPTY
62545: PPUSH
62546: CALL_OW 1
62550: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62551: LD_ADDR_EXP 52
62555: PUSH
62556: LD_EXP 52
62560: PPUSH
62561: LD_VAR 0 4
62565: PPUSH
62566: EMPTY
62567: PPUSH
62568: CALL_OW 1
62572: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62573: LD_ADDR_EXP 53
62577: PUSH
62578: LD_EXP 53
62582: PPUSH
62583: LD_VAR 0 4
62587: PPUSH
62588: EMPTY
62589: PPUSH
62590: CALL_OW 1
62594: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62595: LD_ADDR_EXP 54
62599: PUSH
62600: LD_EXP 54
62604: PPUSH
62605: LD_VAR 0 4
62609: PPUSH
62610: EMPTY
62611: PPUSH
62612: CALL_OW 1
62616: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62617: LD_ADDR_EXP 55
62621: PUSH
62622: LD_EXP 55
62626: PPUSH
62627: LD_VAR 0 4
62631: PPUSH
62632: EMPTY
62633: PPUSH
62634: CALL_OW 1
62638: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62639: LD_ADDR_EXP 56
62643: PUSH
62644: LD_EXP 56
62648: PPUSH
62649: LD_VAR 0 4
62653: PPUSH
62654: EMPTY
62655: PPUSH
62656: CALL_OW 1
62660: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62661: LD_ADDR_EXP 57
62665: PUSH
62666: LD_EXP 57
62670: PPUSH
62671: LD_VAR 0 4
62675: PPUSH
62676: EMPTY
62677: PPUSH
62678: CALL_OW 1
62682: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62683: LD_ADDR_EXP 58
62687: PUSH
62688: LD_EXP 58
62692: PPUSH
62693: LD_VAR 0 4
62697: PPUSH
62698: EMPTY
62699: PPUSH
62700: CALL_OW 1
62704: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62705: LD_ADDR_EXP 59
62709: PUSH
62710: LD_EXP 59
62714: PPUSH
62715: LD_VAR 0 4
62719: PPUSH
62720: EMPTY
62721: PPUSH
62722: CALL_OW 1
62726: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62727: LD_ADDR_EXP 60
62731: PUSH
62732: LD_EXP 60
62736: PPUSH
62737: LD_VAR 0 4
62741: PPUSH
62742: LD_INT 0
62744: PPUSH
62745: CALL_OW 1
62749: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62750: LD_ADDR_EXP 61
62754: PUSH
62755: LD_EXP 61
62759: PPUSH
62760: LD_VAR 0 4
62764: PPUSH
62765: EMPTY
62766: PPUSH
62767: CALL_OW 1
62771: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62772: LD_ADDR_EXP 62
62776: PUSH
62777: LD_EXP 62
62781: PPUSH
62782: LD_VAR 0 4
62786: PPUSH
62787: EMPTY
62788: PPUSH
62789: CALL_OW 1
62793: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62794: LD_ADDR_EXP 63
62798: PUSH
62799: LD_EXP 63
62803: PPUSH
62804: LD_VAR 0 4
62808: PPUSH
62809: EMPTY
62810: PPUSH
62811: CALL_OW 1
62815: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62816: LD_ADDR_EXP 64
62820: PUSH
62821: LD_EXP 64
62825: PPUSH
62826: LD_VAR 0 4
62830: PPUSH
62831: EMPTY
62832: PPUSH
62833: CALL_OW 1
62837: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62838: LD_ADDR_EXP 65
62842: PUSH
62843: LD_EXP 65
62847: PPUSH
62848: LD_VAR 0 4
62852: PPUSH
62853: EMPTY
62854: PPUSH
62855: CALL_OW 1
62859: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62860: LD_ADDR_EXP 66
62864: PUSH
62865: LD_EXP 66
62869: PPUSH
62870: LD_VAR 0 4
62874: PPUSH
62875: EMPTY
62876: PPUSH
62877: CALL_OW 1
62881: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62882: LD_ADDR_EXP 67
62886: PUSH
62887: LD_EXP 67
62891: PPUSH
62892: LD_VAR 0 4
62896: PPUSH
62897: EMPTY
62898: PPUSH
62899: CALL_OW 1
62903: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62904: LD_ADDR_EXP 68
62908: PUSH
62909: LD_EXP 68
62913: PPUSH
62914: LD_VAR 0 4
62918: PPUSH
62919: EMPTY
62920: PPUSH
62921: CALL_OW 1
62925: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62926: LD_ADDR_EXP 69
62930: PUSH
62931: LD_EXP 69
62935: PPUSH
62936: LD_VAR 0 4
62940: PPUSH
62941: EMPTY
62942: PPUSH
62943: CALL_OW 1
62947: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62948: LD_ADDR_EXP 70
62952: PUSH
62953: LD_EXP 70
62957: PPUSH
62958: LD_VAR 0 4
62962: PPUSH
62963: EMPTY
62964: PPUSH
62965: CALL_OW 1
62969: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62970: LD_ADDR_EXP 71
62974: PUSH
62975: LD_EXP 71
62979: PPUSH
62980: LD_VAR 0 4
62984: PPUSH
62985: EMPTY
62986: PPUSH
62987: CALL_OW 1
62991: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62992: LD_ADDR_EXP 72
62996: PUSH
62997: LD_EXP 72
63001: PPUSH
63002: LD_VAR 0 4
63006: PPUSH
63007: EMPTY
63008: PPUSH
63009: CALL_OW 1
63013: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63014: LD_ADDR_EXP 73
63018: PUSH
63019: LD_EXP 73
63023: PPUSH
63024: LD_VAR 0 4
63028: PPUSH
63029: EMPTY
63030: PPUSH
63031: CALL_OW 1
63035: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63036: LD_ADDR_EXP 74
63040: PUSH
63041: LD_EXP 74
63045: PPUSH
63046: LD_VAR 0 4
63050: PPUSH
63051: EMPTY
63052: PPUSH
63053: CALL_OW 1
63057: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63058: LD_ADDR_EXP 76
63062: PUSH
63063: LD_EXP 76
63067: PPUSH
63068: LD_VAR 0 4
63072: PPUSH
63073: EMPTY
63074: PPUSH
63075: CALL_OW 1
63079: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63080: LD_ADDR_EXP 78
63084: PUSH
63085: LD_EXP 78
63089: PPUSH
63090: LD_VAR 0 4
63094: PPUSH
63095: EMPTY
63096: PPUSH
63097: CALL_OW 1
63101: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63102: LD_ADDR_EXP 79
63106: PUSH
63107: LD_EXP 79
63111: PPUSH
63112: LD_VAR 0 4
63116: PPUSH
63117: EMPTY
63118: PPUSH
63119: CALL_OW 1
63123: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63124: LD_ADDR_EXP 80
63128: PUSH
63129: LD_EXP 80
63133: PPUSH
63134: LD_VAR 0 4
63138: PPUSH
63139: EMPTY
63140: PPUSH
63141: CALL_OW 1
63145: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63146: LD_ADDR_EXP 81
63150: PUSH
63151: LD_EXP 81
63155: PPUSH
63156: LD_VAR 0 4
63160: PPUSH
63161: EMPTY
63162: PPUSH
63163: CALL_OW 1
63167: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63168: LD_ADDR_EXP 82
63172: PUSH
63173: LD_EXP 82
63177: PPUSH
63178: LD_VAR 0 4
63182: PPUSH
63183: EMPTY
63184: PPUSH
63185: CALL_OW 1
63189: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63190: LD_ADDR_EXP 83
63194: PUSH
63195: LD_EXP 83
63199: PPUSH
63200: LD_VAR 0 4
63204: PPUSH
63205: EMPTY
63206: PPUSH
63207: CALL_OW 1
63211: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63212: LD_ADDR_EXP 84
63216: PUSH
63217: LD_EXP 84
63221: PPUSH
63222: LD_VAR 0 4
63226: PPUSH
63227: EMPTY
63228: PPUSH
63229: CALL_OW 1
63233: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63234: LD_ADDR_EXP 85
63238: PUSH
63239: LD_EXP 85
63243: PPUSH
63244: LD_VAR 0 4
63248: PPUSH
63249: EMPTY
63250: PPUSH
63251: CALL_OW 1
63255: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63256: LD_ADDR_EXP 86
63260: PUSH
63261: LD_EXP 86
63265: PPUSH
63266: LD_VAR 0 4
63270: PPUSH
63271: EMPTY
63272: PPUSH
63273: CALL_OW 1
63277: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63278: LD_ADDR_EXP 87
63282: PUSH
63283: LD_EXP 87
63287: PPUSH
63288: LD_VAR 0 4
63292: PPUSH
63293: EMPTY
63294: PPUSH
63295: CALL_OW 1
63299: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63300: LD_ADDR_EXP 88
63304: PUSH
63305: LD_EXP 88
63309: PPUSH
63310: LD_VAR 0 4
63314: PPUSH
63315: EMPTY
63316: PPUSH
63317: CALL_OW 1
63321: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63322: LD_ADDR_EXP 89
63326: PUSH
63327: LD_EXP 89
63331: PPUSH
63332: LD_VAR 0 4
63336: PPUSH
63337: EMPTY
63338: PPUSH
63339: CALL_OW 1
63343: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63344: LD_ADDR_EXP 90
63348: PUSH
63349: LD_EXP 90
63353: PPUSH
63354: LD_VAR 0 4
63358: PPUSH
63359: EMPTY
63360: PPUSH
63361: CALL_OW 1
63365: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63366: LD_ADDR_EXP 91
63370: PUSH
63371: LD_EXP 91
63375: PPUSH
63376: LD_VAR 0 4
63380: PPUSH
63381: LD_INT 0
63383: PPUSH
63384: CALL_OW 1
63388: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63389: LD_ADDR_EXP 92
63393: PUSH
63394: LD_EXP 92
63398: PPUSH
63399: LD_VAR 0 4
63403: PPUSH
63404: LD_INT 0
63406: PPUSH
63407: CALL_OW 1
63411: ST_TO_ADDR
// result := base ;
63412: LD_ADDR_VAR 0 3
63416: PUSH
63417: LD_VAR 0 4
63421: ST_TO_ADDR
// end ;
63422: LD_VAR 0 3
63426: RET
// export function MC_Start ( ) ; var i ; begin
63427: LD_INT 0
63429: PPUSH
63430: PPUSH
// for i = 1 to mc_bases do
63431: LD_ADDR_VAR 0 2
63435: PUSH
63436: DOUBLE
63437: LD_INT 1
63439: DEC
63440: ST_TO_ADDR
63441: LD_EXP 49
63445: PUSH
63446: FOR_TO
63447: IFFALSE 64547
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63449: LD_ADDR_EXP 49
63453: PUSH
63454: LD_EXP 49
63458: PPUSH
63459: LD_VAR 0 2
63463: PPUSH
63464: LD_EXP 49
63468: PUSH
63469: LD_VAR 0 2
63473: ARRAY
63474: PUSH
63475: LD_INT 0
63477: DIFF
63478: PPUSH
63479: CALL_OW 1
63483: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63484: LD_ADDR_EXP 50
63488: PUSH
63489: LD_EXP 50
63493: PPUSH
63494: LD_VAR 0 2
63498: PPUSH
63499: EMPTY
63500: PPUSH
63501: CALL_OW 1
63505: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63506: LD_ADDR_EXP 51
63510: PUSH
63511: LD_EXP 51
63515: PPUSH
63516: LD_VAR 0 2
63520: PPUSH
63521: EMPTY
63522: PPUSH
63523: CALL_OW 1
63527: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63528: LD_ADDR_EXP 52
63532: PUSH
63533: LD_EXP 52
63537: PPUSH
63538: LD_VAR 0 2
63542: PPUSH
63543: EMPTY
63544: PPUSH
63545: CALL_OW 1
63549: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63550: LD_ADDR_EXP 53
63554: PUSH
63555: LD_EXP 53
63559: PPUSH
63560: LD_VAR 0 2
63564: PPUSH
63565: EMPTY
63566: PUSH
63567: EMPTY
63568: PUSH
63569: EMPTY
63570: LIST
63571: LIST
63572: PPUSH
63573: CALL_OW 1
63577: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63578: LD_ADDR_EXP 54
63582: PUSH
63583: LD_EXP 54
63587: PPUSH
63588: LD_VAR 0 2
63592: PPUSH
63593: EMPTY
63594: PPUSH
63595: CALL_OW 1
63599: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63600: LD_ADDR_EXP 81
63604: PUSH
63605: LD_EXP 81
63609: PPUSH
63610: LD_VAR 0 2
63614: PPUSH
63615: EMPTY
63616: PPUSH
63617: CALL_OW 1
63621: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63622: LD_ADDR_EXP 55
63626: PUSH
63627: LD_EXP 55
63631: PPUSH
63632: LD_VAR 0 2
63636: PPUSH
63637: EMPTY
63638: PPUSH
63639: CALL_OW 1
63643: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63644: LD_ADDR_EXP 56
63648: PUSH
63649: LD_EXP 56
63653: PPUSH
63654: LD_VAR 0 2
63658: PPUSH
63659: EMPTY
63660: PPUSH
63661: CALL_OW 1
63665: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63666: LD_ADDR_EXP 57
63670: PUSH
63671: LD_EXP 57
63675: PPUSH
63676: LD_VAR 0 2
63680: PPUSH
63681: LD_EXP 49
63685: PUSH
63686: LD_VAR 0 2
63690: ARRAY
63691: PPUSH
63692: LD_INT 2
63694: PUSH
63695: LD_INT 30
63697: PUSH
63698: LD_INT 32
63700: PUSH
63701: EMPTY
63702: LIST
63703: LIST
63704: PUSH
63705: LD_INT 30
63707: PUSH
63708: LD_INT 33
63710: PUSH
63711: EMPTY
63712: LIST
63713: LIST
63714: PUSH
63715: EMPTY
63716: LIST
63717: LIST
63718: LIST
63719: PPUSH
63720: CALL_OW 72
63724: PPUSH
63725: CALL_OW 1
63729: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63730: LD_ADDR_EXP 58
63734: PUSH
63735: LD_EXP 58
63739: PPUSH
63740: LD_VAR 0 2
63744: PPUSH
63745: LD_EXP 49
63749: PUSH
63750: LD_VAR 0 2
63754: ARRAY
63755: PPUSH
63756: LD_INT 2
63758: PUSH
63759: LD_INT 30
63761: PUSH
63762: LD_INT 32
63764: PUSH
63765: EMPTY
63766: LIST
63767: LIST
63768: PUSH
63769: LD_INT 30
63771: PUSH
63772: LD_INT 31
63774: PUSH
63775: EMPTY
63776: LIST
63777: LIST
63778: PUSH
63779: EMPTY
63780: LIST
63781: LIST
63782: LIST
63783: PUSH
63784: LD_INT 58
63786: PUSH
63787: EMPTY
63788: LIST
63789: PUSH
63790: EMPTY
63791: LIST
63792: LIST
63793: PPUSH
63794: CALL_OW 72
63798: PPUSH
63799: CALL_OW 1
63803: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63804: LD_ADDR_EXP 59
63808: PUSH
63809: LD_EXP 59
63813: PPUSH
63814: LD_VAR 0 2
63818: PPUSH
63819: EMPTY
63820: PPUSH
63821: CALL_OW 1
63825: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
63826: LD_ADDR_EXP 63
63830: PUSH
63831: LD_EXP 63
63835: PPUSH
63836: LD_VAR 0 2
63840: PPUSH
63841: EMPTY
63842: PPUSH
63843: CALL_OW 1
63847: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
63848: LD_ADDR_EXP 62
63852: PUSH
63853: LD_EXP 62
63857: PPUSH
63858: LD_VAR 0 2
63862: PPUSH
63863: EMPTY
63864: PPUSH
63865: CALL_OW 1
63869: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
63870: LD_ADDR_EXP 64
63874: PUSH
63875: LD_EXP 64
63879: PPUSH
63880: LD_VAR 0 2
63884: PPUSH
63885: EMPTY
63886: PPUSH
63887: CALL_OW 1
63891: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
63892: LD_ADDR_EXP 65
63896: PUSH
63897: LD_EXP 65
63901: PPUSH
63902: LD_VAR 0 2
63906: PPUSH
63907: EMPTY
63908: PPUSH
63909: CALL_OW 1
63913: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63914: LD_ADDR_EXP 66
63918: PUSH
63919: LD_EXP 66
63923: PPUSH
63924: LD_VAR 0 2
63928: PPUSH
63929: EMPTY
63930: PPUSH
63931: CALL_OW 1
63935: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
63936: LD_ADDR_EXP 67
63940: PUSH
63941: LD_EXP 67
63945: PPUSH
63946: LD_VAR 0 2
63950: PPUSH
63951: EMPTY
63952: PPUSH
63953: CALL_OW 1
63957: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
63958: LD_ADDR_EXP 68
63962: PUSH
63963: LD_EXP 68
63967: PPUSH
63968: LD_VAR 0 2
63972: PPUSH
63973: EMPTY
63974: PPUSH
63975: CALL_OW 1
63979: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63980: LD_ADDR_EXP 69
63984: PUSH
63985: LD_EXP 69
63989: PPUSH
63990: LD_VAR 0 2
63994: PPUSH
63995: EMPTY
63996: PPUSH
63997: CALL_OW 1
64001: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
64002: LD_ADDR_EXP 70
64006: PUSH
64007: LD_EXP 70
64011: PPUSH
64012: LD_VAR 0 2
64016: PPUSH
64017: EMPTY
64018: PPUSH
64019: CALL_OW 1
64023: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64024: LD_ADDR_EXP 71
64028: PUSH
64029: LD_EXP 71
64033: PPUSH
64034: LD_VAR 0 2
64038: PPUSH
64039: EMPTY
64040: PPUSH
64041: CALL_OW 1
64045: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
64046: LD_ADDR_EXP 60
64050: PUSH
64051: LD_EXP 60
64055: PPUSH
64056: LD_VAR 0 2
64060: PPUSH
64061: LD_INT 0
64063: PPUSH
64064: CALL_OW 1
64068: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
64069: LD_ADDR_EXP 73
64073: PUSH
64074: LD_EXP 73
64078: PPUSH
64079: LD_VAR 0 2
64083: PPUSH
64084: LD_INT 0
64086: PPUSH
64087: CALL_OW 1
64091: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64092: LD_ADDR_EXP 61
64096: PUSH
64097: LD_EXP 61
64101: PPUSH
64102: LD_VAR 0 2
64106: PPUSH
64107: EMPTY
64108: PPUSH
64109: CALL_OW 1
64113: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
64114: LD_ADDR_EXP 72
64118: PUSH
64119: LD_EXP 72
64123: PPUSH
64124: LD_VAR 0 2
64128: PPUSH
64129: LD_INT 0
64131: PPUSH
64132: CALL_OW 1
64136: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
64137: LD_ADDR_EXP 74
64141: PUSH
64142: LD_EXP 74
64146: PPUSH
64147: LD_VAR 0 2
64151: PPUSH
64152: EMPTY
64153: PPUSH
64154: CALL_OW 1
64158: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
64159: LD_ADDR_EXP 77
64163: PUSH
64164: LD_EXP 77
64168: PPUSH
64169: LD_VAR 0 2
64173: PPUSH
64174: LD_INT 0
64176: PPUSH
64177: CALL_OW 1
64181: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
64182: LD_ADDR_EXP 78
64186: PUSH
64187: LD_EXP 78
64191: PPUSH
64192: LD_VAR 0 2
64196: PPUSH
64197: EMPTY
64198: PPUSH
64199: CALL_OW 1
64203: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64204: LD_ADDR_EXP 79
64208: PUSH
64209: LD_EXP 79
64213: PPUSH
64214: LD_VAR 0 2
64218: PPUSH
64219: EMPTY
64220: PPUSH
64221: CALL_OW 1
64225: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64226: LD_ADDR_EXP 80
64230: PUSH
64231: LD_EXP 80
64235: PPUSH
64236: LD_VAR 0 2
64240: PPUSH
64241: EMPTY
64242: PPUSH
64243: CALL_OW 1
64247: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64248: LD_ADDR_EXP 82
64252: PUSH
64253: LD_EXP 82
64257: PPUSH
64258: LD_VAR 0 2
64262: PPUSH
64263: LD_EXP 49
64267: PUSH
64268: LD_VAR 0 2
64272: ARRAY
64273: PPUSH
64274: LD_INT 2
64276: PUSH
64277: LD_INT 30
64279: PUSH
64280: LD_INT 6
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: LD_INT 30
64289: PUSH
64290: LD_INT 7
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PUSH
64297: LD_INT 30
64299: PUSH
64300: LD_INT 8
64302: PUSH
64303: EMPTY
64304: LIST
64305: LIST
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: PPUSH
64313: CALL_OW 72
64317: PPUSH
64318: CALL_OW 1
64322: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64323: LD_ADDR_EXP 83
64327: PUSH
64328: LD_EXP 83
64332: PPUSH
64333: LD_VAR 0 2
64337: PPUSH
64338: EMPTY
64339: PPUSH
64340: CALL_OW 1
64344: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64345: LD_ADDR_EXP 84
64349: PUSH
64350: LD_EXP 84
64354: PPUSH
64355: LD_VAR 0 2
64359: PPUSH
64360: EMPTY
64361: PPUSH
64362: CALL_OW 1
64366: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64367: LD_ADDR_EXP 85
64371: PUSH
64372: LD_EXP 85
64376: PPUSH
64377: LD_VAR 0 2
64381: PPUSH
64382: EMPTY
64383: PPUSH
64384: CALL_OW 1
64388: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64389: LD_ADDR_EXP 86
64393: PUSH
64394: LD_EXP 86
64398: PPUSH
64399: LD_VAR 0 2
64403: PPUSH
64404: EMPTY
64405: PPUSH
64406: CALL_OW 1
64410: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64411: LD_ADDR_EXP 87
64415: PUSH
64416: LD_EXP 87
64420: PPUSH
64421: LD_VAR 0 2
64425: PPUSH
64426: EMPTY
64427: PPUSH
64428: CALL_OW 1
64432: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64433: LD_ADDR_EXP 88
64437: PUSH
64438: LD_EXP 88
64442: PPUSH
64443: LD_VAR 0 2
64447: PPUSH
64448: EMPTY
64449: PPUSH
64450: CALL_OW 1
64454: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64455: LD_ADDR_EXP 89
64459: PUSH
64460: LD_EXP 89
64464: PPUSH
64465: LD_VAR 0 2
64469: PPUSH
64470: EMPTY
64471: PPUSH
64472: CALL_OW 1
64476: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64477: LD_ADDR_EXP 90
64481: PUSH
64482: LD_EXP 90
64486: PPUSH
64487: LD_VAR 0 2
64491: PPUSH
64492: EMPTY
64493: PPUSH
64494: CALL_OW 1
64498: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64499: LD_ADDR_EXP 91
64503: PUSH
64504: LD_EXP 91
64508: PPUSH
64509: LD_VAR 0 2
64513: PPUSH
64514: LD_INT 0
64516: PPUSH
64517: CALL_OW 1
64521: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64522: LD_ADDR_EXP 92
64526: PUSH
64527: LD_EXP 92
64531: PPUSH
64532: LD_VAR 0 2
64536: PPUSH
64537: LD_INT 0
64539: PPUSH
64540: CALL_OW 1
64544: ST_TO_ADDR
// end ;
64545: GO 63446
64547: POP
64548: POP
// MC_InitSides ( ) ;
64549: CALL 64835 0 0
// MC_InitResearch ( ) ;
64553: CALL 64574 0 0
// CustomInitMacro ( ) ;
64557: CALL 1411 0 0
// skirmish := true ;
64561: LD_ADDR_EXP 47
64565: PUSH
64566: LD_INT 1
64568: ST_TO_ADDR
// end ;
64569: LD_VAR 0 1
64573: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64574: LD_INT 0
64576: PPUSH
64577: PPUSH
64578: PPUSH
64579: PPUSH
64580: PPUSH
64581: PPUSH
// if not mc_bases then
64582: LD_EXP 49
64586: NOT
64587: IFFALSE 64591
// exit ;
64589: GO 64830
// for i = 1 to 8 do
64591: LD_ADDR_VAR 0 2
64595: PUSH
64596: DOUBLE
64597: LD_INT 1
64599: DEC
64600: ST_TO_ADDR
64601: LD_INT 8
64603: PUSH
64604: FOR_TO
64605: IFFALSE 64631
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64607: LD_ADDR_EXP 76
64611: PUSH
64612: LD_EXP 76
64616: PPUSH
64617: LD_VAR 0 2
64621: PPUSH
64622: EMPTY
64623: PPUSH
64624: CALL_OW 1
64628: ST_TO_ADDR
64629: GO 64604
64631: POP
64632: POP
// tmp := [ ] ;
64633: LD_ADDR_VAR 0 5
64637: PUSH
64638: EMPTY
64639: ST_TO_ADDR
// for i = 1 to mc_sides do
64640: LD_ADDR_VAR 0 2
64644: PUSH
64645: DOUBLE
64646: LD_INT 1
64648: DEC
64649: ST_TO_ADDR
64650: LD_EXP 75
64654: PUSH
64655: FOR_TO
64656: IFFALSE 64714
// if not mc_sides [ i ] in tmp then
64658: LD_EXP 75
64662: PUSH
64663: LD_VAR 0 2
64667: ARRAY
64668: PUSH
64669: LD_VAR 0 5
64673: IN
64674: NOT
64675: IFFALSE 64712
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64677: LD_ADDR_VAR 0 5
64681: PUSH
64682: LD_VAR 0 5
64686: PPUSH
64687: LD_VAR 0 5
64691: PUSH
64692: LD_INT 1
64694: PLUS
64695: PPUSH
64696: LD_EXP 75
64700: PUSH
64701: LD_VAR 0 2
64705: ARRAY
64706: PPUSH
64707: CALL_OW 2
64711: ST_TO_ADDR
64712: GO 64655
64714: POP
64715: POP
// if not tmp then
64716: LD_VAR 0 5
64720: NOT
64721: IFFALSE 64725
// exit ;
64723: GO 64830
// for j in tmp do
64725: LD_ADDR_VAR 0 3
64729: PUSH
64730: LD_VAR 0 5
64734: PUSH
64735: FOR_IN
64736: IFFALSE 64828
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64738: LD_ADDR_VAR 0 6
64742: PUSH
64743: LD_INT 22
64745: PUSH
64746: LD_VAR 0 3
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PPUSH
64755: CALL_OW 69
64759: ST_TO_ADDR
// if not un then
64760: LD_VAR 0 6
64764: NOT
64765: IFFALSE 64769
// continue ;
64767: GO 64735
// nation := GetNation ( un [ 1 ] ) ;
64769: LD_ADDR_VAR 0 4
64773: PUSH
64774: LD_VAR 0 6
64778: PUSH
64779: LD_INT 1
64781: ARRAY
64782: PPUSH
64783: CALL_OW 248
64787: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64788: LD_ADDR_EXP 76
64792: PUSH
64793: LD_EXP 76
64797: PPUSH
64798: LD_VAR 0 3
64802: PPUSH
64803: LD_VAR 0 3
64807: PPUSH
64808: LD_VAR 0 4
64812: PPUSH
64813: LD_INT 1
64815: PPUSH
64816: CALL 19949 0 3
64820: PPUSH
64821: CALL_OW 1
64825: ST_TO_ADDR
// end ;
64826: GO 64735
64828: POP
64829: POP
// end ;
64830: LD_VAR 0 1
64834: RET
// export function MC_InitSides ( ) ; var i ; begin
64835: LD_INT 0
64837: PPUSH
64838: PPUSH
// if not mc_bases then
64839: LD_EXP 49
64843: NOT
64844: IFFALSE 64848
// exit ;
64846: GO 64922
// for i = 1 to mc_bases do
64848: LD_ADDR_VAR 0 2
64852: PUSH
64853: DOUBLE
64854: LD_INT 1
64856: DEC
64857: ST_TO_ADDR
64858: LD_EXP 49
64862: PUSH
64863: FOR_TO
64864: IFFALSE 64920
// if mc_bases [ i ] then
64866: LD_EXP 49
64870: PUSH
64871: LD_VAR 0 2
64875: ARRAY
64876: IFFALSE 64918
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
64878: LD_ADDR_EXP 75
64882: PUSH
64883: LD_EXP 75
64887: PPUSH
64888: LD_VAR 0 2
64892: PPUSH
64893: LD_EXP 49
64897: PUSH
64898: LD_VAR 0 2
64902: ARRAY
64903: PUSH
64904: LD_INT 1
64906: ARRAY
64907: PPUSH
64908: CALL_OW 255
64912: PPUSH
64913: CALL_OW 1
64917: ST_TO_ADDR
64918: GO 64863
64920: POP
64921: POP
// end ;
64922: LD_VAR 0 1
64926: RET
// every 0 0$03 trigger skirmish do
64927: LD_EXP 47
64931: IFFALSE 65085
64933: GO 64935
64935: DISABLE
// begin enable ;
64936: ENABLE
// MC_CheckBuildings ( ) ;
64937: CALL 69583 0 0
// MC_CheckPeopleLife ( ) ;
64941: CALL 69744 0 0
// RaiseSailEvent ( 100 ) ;
64945: LD_INT 100
64947: PPUSH
64948: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
64952: LD_INT 103
64954: PPUSH
64955: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
64959: LD_INT 104
64961: PPUSH
64962: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
64966: LD_INT 105
64968: PPUSH
64969: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
64973: LD_INT 106
64975: PPUSH
64976: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
64980: LD_INT 107
64982: PPUSH
64983: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
64987: LD_INT 108
64989: PPUSH
64990: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
64994: LD_INT 109
64996: PPUSH
64997: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
65001: LD_INT 110
65003: PPUSH
65004: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
65008: LD_INT 111
65010: PPUSH
65011: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
65015: LD_INT 112
65017: PPUSH
65018: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
65022: LD_INT 113
65024: PPUSH
65025: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
65029: LD_INT 120
65031: PPUSH
65032: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
65036: LD_INT 121
65038: PPUSH
65039: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
65043: LD_INT 122
65045: PPUSH
65046: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
65050: LD_INT 123
65052: PPUSH
65053: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
65057: LD_INT 124
65059: PPUSH
65060: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
65064: LD_INT 125
65066: PPUSH
65067: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
65071: LD_INT 126
65073: PPUSH
65074: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
65078: LD_INT 200
65080: PPUSH
65081: CALL_OW 427
// end ;
65085: END
// on SailEvent ( event ) do begin if event < 100 then
65086: LD_VAR 0 1
65090: PUSH
65091: LD_INT 100
65093: LESS
65094: IFFALSE 65105
// CustomEvent ( event ) ;
65096: LD_VAR 0 1
65100: PPUSH
65101: CALL 19113 0 1
// if event = 100 then
65105: LD_VAR 0 1
65109: PUSH
65110: LD_INT 100
65112: EQUAL
65113: IFFALSE 65119
// MC_ClassManager ( ) ;
65115: CALL 65511 0 0
// if event = 101 then
65119: LD_VAR 0 1
65123: PUSH
65124: LD_INT 101
65126: EQUAL
65127: IFFALSE 65133
// MC_RepairBuildings ( ) ;
65129: CALL 70329 0 0
// if event = 102 then
65133: LD_VAR 0 1
65137: PUSH
65138: LD_INT 102
65140: EQUAL
65141: IFFALSE 65147
// MC_Heal ( ) ;
65143: CALL 71236 0 0
// if event = 103 then
65147: LD_VAR 0 1
65151: PUSH
65152: LD_INT 103
65154: EQUAL
65155: IFFALSE 65161
// MC_Build ( ) ;
65157: CALL 71658 0 0
// if event = 104 then
65161: LD_VAR 0 1
65165: PUSH
65166: LD_INT 104
65168: EQUAL
65169: IFFALSE 65175
// MC_TurretWeapon ( ) ;
65171: CALL 73299 0 0
// if event = 105 then
65175: LD_VAR 0 1
65179: PUSH
65180: LD_INT 105
65182: EQUAL
65183: IFFALSE 65189
// MC_BuildUpgrade ( ) ;
65185: CALL 72850 0 0
// if event = 106 then
65189: LD_VAR 0 1
65193: PUSH
65194: LD_INT 106
65196: EQUAL
65197: IFFALSE 65203
// MC_PlantMines ( ) ;
65199: CALL 73729 0 0
// if event = 107 then
65203: LD_VAR 0 1
65207: PUSH
65208: LD_INT 107
65210: EQUAL
65211: IFFALSE 65217
// MC_CollectCrates ( ) ;
65213: CALL 74520 0 0
// if event = 108 then
65217: LD_VAR 0 1
65221: PUSH
65222: LD_INT 108
65224: EQUAL
65225: IFFALSE 65231
// MC_LinkRemoteControl ( ) ;
65227: CALL 76370 0 0
// if event = 109 then
65231: LD_VAR 0 1
65235: PUSH
65236: LD_INT 109
65238: EQUAL
65239: IFFALSE 65245
// MC_ProduceVehicle ( ) ;
65241: CALL 76551 0 0
// if event = 110 then
65245: LD_VAR 0 1
65249: PUSH
65250: LD_INT 110
65252: EQUAL
65253: IFFALSE 65259
// MC_SendAttack ( ) ;
65255: CALL 77017 0 0
// if event = 111 then
65259: LD_VAR 0 1
65263: PUSH
65264: LD_INT 111
65266: EQUAL
65267: IFFALSE 65273
// MC_Defend ( ) ;
65269: CALL 77125 0 0
// if event = 112 then
65273: LD_VAR 0 1
65277: PUSH
65278: LD_INT 112
65280: EQUAL
65281: IFFALSE 65287
// MC_Research ( ) ;
65283: CALL 78005 0 0
// if event = 113 then
65287: LD_VAR 0 1
65291: PUSH
65292: LD_INT 113
65294: EQUAL
65295: IFFALSE 65301
// MC_MinesTrigger ( ) ;
65297: CALL 79119 0 0
// if event = 120 then
65301: LD_VAR 0 1
65305: PUSH
65306: LD_INT 120
65308: EQUAL
65309: IFFALSE 65315
// MC_RepairVehicle ( ) ;
65311: CALL 79218 0 0
// if event = 121 then
65315: LD_VAR 0 1
65319: PUSH
65320: LD_INT 121
65322: EQUAL
65323: IFFALSE 65329
// MC_TameApe ( ) ;
65325: CALL 79959 0 0
// if event = 122 then
65329: LD_VAR 0 1
65333: PUSH
65334: LD_INT 122
65336: EQUAL
65337: IFFALSE 65343
// MC_ChangeApeClass ( ) ;
65339: CALL 80788 0 0
// if event = 123 then
65343: LD_VAR 0 1
65347: PUSH
65348: LD_INT 123
65350: EQUAL
65351: IFFALSE 65357
// MC_Bazooka ( ) ;
65353: CALL 81438 0 0
// if event = 124 then
65357: LD_VAR 0 1
65361: PUSH
65362: LD_INT 124
65364: EQUAL
65365: IFFALSE 65371
// MC_TeleportExit ( ) ;
65367: CALL 81636 0 0
// if event = 125 then
65371: LD_VAR 0 1
65375: PUSH
65376: LD_INT 125
65378: EQUAL
65379: IFFALSE 65385
// MC_Deposits ( ) ;
65381: CALL 82283 0 0
// if event = 126 then
65385: LD_VAR 0 1
65389: PUSH
65390: LD_INT 126
65392: EQUAL
65393: IFFALSE 65399
// MC_RemoteDriver ( ) ;
65395: CALL 82908 0 0
// if event = 200 then
65399: LD_VAR 0 1
65403: PUSH
65404: LD_INT 200
65406: EQUAL
65407: IFFALSE 65413
// MC_Idle ( ) ;
65409: CALL 84857 0 0
// end ;
65413: PPOPN 1
65415: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65416: LD_INT 0
65418: PPUSH
65419: PPUSH
// if not mc_bases [ base ] or not tag then
65420: LD_EXP 49
65424: PUSH
65425: LD_VAR 0 1
65429: ARRAY
65430: NOT
65431: PUSH
65432: LD_VAR 0 2
65436: NOT
65437: OR
65438: IFFALSE 65442
// exit ;
65440: GO 65506
// for i in mc_bases [ base ] union mc_ape [ base ] do
65442: LD_ADDR_VAR 0 4
65446: PUSH
65447: LD_EXP 49
65451: PUSH
65452: LD_VAR 0 1
65456: ARRAY
65457: PUSH
65458: LD_EXP 78
65462: PUSH
65463: LD_VAR 0 1
65467: ARRAY
65468: UNION
65469: PUSH
65470: FOR_IN
65471: IFFALSE 65504
// if GetTag ( i ) = tag then
65473: LD_VAR 0 4
65477: PPUSH
65478: CALL_OW 110
65482: PUSH
65483: LD_VAR 0 2
65487: EQUAL
65488: IFFALSE 65502
// SetTag ( i , 0 ) ;
65490: LD_VAR 0 4
65494: PPUSH
65495: LD_INT 0
65497: PPUSH
65498: CALL_OW 109
65502: GO 65470
65504: POP
65505: POP
// end ;
65506: LD_VAR 0 3
65510: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65511: LD_INT 0
65513: PPUSH
65514: PPUSH
65515: PPUSH
65516: PPUSH
65517: PPUSH
65518: PPUSH
65519: PPUSH
65520: PPUSH
// if not mc_bases then
65521: LD_EXP 49
65525: NOT
65526: IFFALSE 65530
// exit ;
65528: GO 65988
// for i = 1 to mc_bases do
65530: LD_ADDR_VAR 0 2
65534: PUSH
65535: DOUBLE
65536: LD_INT 1
65538: DEC
65539: ST_TO_ADDR
65540: LD_EXP 49
65544: PUSH
65545: FOR_TO
65546: IFFALSE 65986
// begin tmp := MC_ClassCheckReq ( i ) ;
65548: LD_ADDR_VAR 0 4
65552: PUSH
65553: LD_VAR 0 2
65557: PPUSH
65558: CALL 65993 0 1
65562: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65563: LD_ADDR_EXP 90
65567: PUSH
65568: LD_EXP 90
65572: PPUSH
65573: LD_VAR 0 2
65577: PPUSH
65578: LD_VAR 0 4
65582: PPUSH
65583: CALL_OW 1
65587: ST_TO_ADDR
// if not tmp then
65588: LD_VAR 0 4
65592: NOT
65593: IFFALSE 65597
// continue ;
65595: GO 65545
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65597: LD_ADDR_VAR 0 6
65601: PUSH
65602: LD_EXP 49
65606: PUSH
65607: LD_VAR 0 2
65611: ARRAY
65612: PPUSH
65613: LD_INT 2
65615: PUSH
65616: LD_INT 30
65618: PUSH
65619: LD_INT 4
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: PUSH
65626: LD_INT 30
65628: PUSH
65629: LD_INT 5
65631: PUSH
65632: EMPTY
65633: LIST
65634: LIST
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: LIST
65640: PPUSH
65641: CALL_OW 72
65645: PUSH
65646: LD_EXP 49
65650: PUSH
65651: LD_VAR 0 2
65655: ARRAY
65656: PPUSH
65657: LD_INT 2
65659: PUSH
65660: LD_INT 30
65662: PUSH
65663: LD_INT 0
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 30
65672: PUSH
65673: LD_INT 1
65675: PUSH
65676: EMPTY
65677: LIST
65678: LIST
65679: PUSH
65680: EMPTY
65681: LIST
65682: LIST
65683: LIST
65684: PPUSH
65685: CALL_OW 72
65689: PUSH
65690: LD_EXP 49
65694: PUSH
65695: LD_VAR 0 2
65699: ARRAY
65700: PPUSH
65701: LD_INT 30
65703: PUSH
65704: LD_INT 3
65706: PUSH
65707: EMPTY
65708: LIST
65709: LIST
65710: PPUSH
65711: CALL_OW 72
65715: PUSH
65716: LD_EXP 49
65720: PUSH
65721: LD_VAR 0 2
65725: ARRAY
65726: PPUSH
65727: LD_INT 2
65729: PUSH
65730: LD_INT 30
65732: PUSH
65733: LD_INT 6
65735: PUSH
65736: EMPTY
65737: LIST
65738: LIST
65739: PUSH
65740: LD_INT 30
65742: PUSH
65743: LD_INT 7
65745: PUSH
65746: EMPTY
65747: LIST
65748: LIST
65749: PUSH
65750: LD_INT 30
65752: PUSH
65753: LD_INT 8
65755: PUSH
65756: EMPTY
65757: LIST
65758: LIST
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: LIST
65764: LIST
65765: PPUSH
65766: CALL_OW 72
65770: PUSH
65771: EMPTY
65772: LIST
65773: LIST
65774: LIST
65775: LIST
65776: ST_TO_ADDR
// for j = 1 to 4 do
65777: LD_ADDR_VAR 0 3
65781: PUSH
65782: DOUBLE
65783: LD_INT 1
65785: DEC
65786: ST_TO_ADDR
65787: LD_INT 4
65789: PUSH
65790: FOR_TO
65791: IFFALSE 65982
// begin if not tmp [ j ] then
65793: LD_VAR 0 4
65797: PUSH
65798: LD_VAR 0 3
65802: ARRAY
65803: NOT
65804: IFFALSE 65808
// continue ;
65806: GO 65790
// for p in tmp [ j ] do
65808: LD_ADDR_VAR 0 5
65812: PUSH
65813: LD_VAR 0 4
65817: PUSH
65818: LD_VAR 0 3
65822: ARRAY
65823: PUSH
65824: FOR_IN
65825: IFFALSE 65978
// begin if not b [ j ] then
65827: LD_VAR 0 6
65831: PUSH
65832: LD_VAR 0 3
65836: ARRAY
65837: NOT
65838: IFFALSE 65842
// break ;
65840: GO 65978
// e := 0 ;
65842: LD_ADDR_VAR 0 7
65846: PUSH
65847: LD_INT 0
65849: ST_TO_ADDR
// for k in b [ j ] do
65850: LD_ADDR_VAR 0 8
65854: PUSH
65855: LD_VAR 0 6
65859: PUSH
65860: LD_VAR 0 3
65864: ARRAY
65865: PUSH
65866: FOR_IN
65867: IFFALSE 65894
// if IsNotFull ( k ) then
65869: LD_VAR 0 8
65873: PPUSH
65874: CALL 22102 0 1
65878: IFFALSE 65892
// begin e := k ;
65880: LD_ADDR_VAR 0 7
65884: PUSH
65885: LD_VAR 0 8
65889: ST_TO_ADDR
// break ;
65890: GO 65894
// end ;
65892: GO 65866
65894: POP
65895: POP
// if e and not UnitGoingToBuilding ( p , e ) then
65896: LD_VAR 0 7
65900: PUSH
65901: LD_VAR 0 5
65905: PPUSH
65906: LD_VAR 0 7
65910: PPUSH
65911: CALL 55933 0 2
65915: NOT
65916: AND
65917: IFFALSE 65976
// begin if IsInUnit ( p ) then
65919: LD_VAR 0 5
65923: PPUSH
65924: CALL_OW 310
65928: IFFALSE 65939
// ComExitBuilding ( p ) ;
65930: LD_VAR 0 5
65934: PPUSH
65935: CALL_OW 122
// ComEnterUnit ( p , e ) ;
65939: LD_VAR 0 5
65943: PPUSH
65944: LD_VAR 0 7
65948: PPUSH
65949: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
65953: LD_VAR 0 5
65957: PPUSH
65958: LD_VAR 0 3
65962: PPUSH
65963: CALL_OW 183
// AddComExitBuilding ( p ) ;
65967: LD_VAR 0 5
65971: PPUSH
65972: CALL_OW 182
// end ; end ;
65976: GO 65824
65978: POP
65979: POP
// end ;
65980: GO 65790
65982: POP
65983: POP
// end ;
65984: GO 65545
65986: POP
65987: POP
// end ;
65988: LD_VAR 0 1
65992: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
65993: LD_INT 0
65995: PPUSH
65996: PPUSH
65997: PPUSH
65998: PPUSH
65999: PPUSH
66000: PPUSH
66001: PPUSH
66002: PPUSH
66003: PPUSH
66004: PPUSH
66005: PPUSH
66006: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66007: LD_VAR 0 1
66011: NOT
66012: PUSH
66013: LD_EXP 49
66017: PUSH
66018: LD_VAR 0 1
66022: ARRAY
66023: NOT
66024: OR
66025: PUSH
66026: LD_EXP 49
66030: PUSH
66031: LD_VAR 0 1
66035: ARRAY
66036: PPUSH
66037: LD_INT 2
66039: PUSH
66040: LD_INT 30
66042: PUSH
66043: LD_INT 0
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 30
66052: PUSH
66053: LD_INT 1
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: EMPTY
66061: LIST
66062: LIST
66063: LIST
66064: PPUSH
66065: CALL_OW 72
66069: NOT
66070: OR
66071: IFFALSE 66075
// exit ;
66073: GO 69578
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66075: LD_ADDR_VAR 0 4
66079: PUSH
66080: LD_EXP 49
66084: PUSH
66085: LD_VAR 0 1
66089: ARRAY
66090: PPUSH
66091: LD_INT 2
66093: PUSH
66094: LD_INT 25
66096: PUSH
66097: LD_INT 1
66099: PUSH
66100: EMPTY
66101: LIST
66102: LIST
66103: PUSH
66104: LD_INT 25
66106: PUSH
66107: LD_INT 2
66109: PUSH
66110: EMPTY
66111: LIST
66112: LIST
66113: PUSH
66114: LD_INT 25
66116: PUSH
66117: LD_INT 3
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: PUSH
66124: LD_INT 25
66126: PUSH
66127: LD_INT 4
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: PUSH
66134: LD_INT 25
66136: PUSH
66137: LD_INT 5
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: LD_INT 25
66146: PUSH
66147: LD_INT 8
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: PUSH
66154: LD_INT 25
66156: PUSH
66157: LD_INT 9
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: PPUSH
66174: CALL_OW 72
66178: ST_TO_ADDR
// if not tmp then
66179: LD_VAR 0 4
66183: NOT
66184: IFFALSE 66188
// exit ;
66186: GO 69578
// for i in tmp do
66188: LD_ADDR_VAR 0 3
66192: PUSH
66193: LD_VAR 0 4
66197: PUSH
66198: FOR_IN
66199: IFFALSE 66230
// if GetTag ( i ) then
66201: LD_VAR 0 3
66205: PPUSH
66206: CALL_OW 110
66210: IFFALSE 66228
// tmp := tmp diff i ;
66212: LD_ADDR_VAR 0 4
66216: PUSH
66217: LD_VAR 0 4
66221: PUSH
66222: LD_VAR 0 3
66226: DIFF
66227: ST_TO_ADDR
66228: GO 66198
66230: POP
66231: POP
// if not tmp then
66232: LD_VAR 0 4
66236: NOT
66237: IFFALSE 66241
// exit ;
66239: GO 69578
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66241: LD_ADDR_VAR 0 5
66245: PUSH
66246: LD_EXP 49
66250: PUSH
66251: LD_VAR 0 1
66255: ARRAY
66256: PPUSH
66257: LD_INT 2
66259: PUSH
66260: LD_INT 25
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 25
66272: PUSH
66273: LD_INT 5
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 25
66282: PUSH
66283: LD_INT 8
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: PUSH
66290: LD_INT 25
66292: PUSH
66293: LD_INT 9
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: PPUSH
66307: CALL_OW 72
66311: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66312: LD_ADDR_VAR 0 6
66316: PUSH
66317: LD_EXP 49
66321: PUSH
66322: LD_VAR 0 1
66326: ARRAY
66327: PPUSH
66328: LD_INT 25
66330: PUSH
66331: LD_INT 2
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PPUSH
66338: CALL_OW 72
66342: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66343: LD_ADDR_VAR 0 7
66347: PUSH
66348: LD_EXP 49
66352: PUSH
66353: LD_VAR 0 1
66357: ARRAY
66358: PPUSH
66359: LD_INT 25
66361: PUSH
66362: LD_INT 3
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PPUSH
66369: CALL_OW 72
66373: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66374: LD_ADDR_VAR 0 8
66378: PUSH
66379: LD_EXP 49
66383: PUSH
66384: LD_VAR 0 1
66388: ARRAY
66389: PPUSH
66390: LD_INT 25
66392: PUSH
66393: LD_INT 4
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 24
66402: PUSH
66403: LD_INT 251
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: PUSH
66410: EMPTY
66411: LIST
66412: LIST
66413: PPUSH
66414: CALL_OW 72
66418: ST_TO_ADDR
// if mc_is_defending [ base ] then
66419: LD_EXP 92
66423: PUSH
66424: LD_VAR 0 1
66428: ARRAY
66429: IFFALSE 66890
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66431: LD_ADDR_EXP 91
66435: PUSH
66436: LD_EXP 91
66440: PPUSH
66441: LD_VAR 0 1
66445: PPUSH
66446: LD_INT 4
66448: PPUSH
66449: CALL_OW 1
66453: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66454: LD_ADDR_VAR 0 12
66458: PUSH
66459: LD_EXP 49
66463: PUSH
66464: LD_VAR 0 1
66468: ARRAY
66469: PPUSH
66470: LD_INT 2
66472: PUSH
66473: LD_INT 30
66475: PUSH
66476: LD_INT 4
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 30
66485: PUSH
66486: LD_INT 5
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: LIST
66497: PPUSH
66498: CALL_OW 72
66502: ST_TO_ADDR
// if not b then
66503: LD_VAR 0 12
66507: NOT
66508: IFFALSE 66512
// exit ;
66510: GO 69578
// p := [ ] ;
66512: LD_ADDR_VAR 0 11
66516: PUSH
66517: EMPTY
66518: ST_TO_ADDR
// if sci >= 2 then
66519: LD_VAR 0 8
66523: PUSH
66524: LD_INT 2
66526: GREATEREQUAL
66527: IFFALSE 66558
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66529: LD_ADDR_VAR 0 8
66533: PUSH
66534: LD_VAR 0 8
66538: PUSH
66539: LD_INT 1
66541: ARRAY
66542: PUSH
66543: LD_VAR 0 8
66547: PUSH
66548: LD_INT 2
66550: ARRAY
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: ST_TO_ADDR
66556: GO 66619
// if sci = 1 then
66558: LD_VAR 0 8
66562: PUSH
66563: LD_INT 1
66565: EQUAL
66566: IFFALSE 66587
// sci := [ sci [ 1 ] ] else
66568: LD_ADDR_VAR 0 8
66572: PUSH
66573: LD_VAR 0 8
66577: PUSH
66578: LD_INT 1
66580: ARRAY
66581: PUSH
66582: EMPTY
66583: LIST
66584: ST_TO_ADDR
66585: GO 66619
// if sci = 0 then
66587: LD_VAR 0 8
66591: PUSH
66592: LD_INT 0
66594: EQUAL
66595: IFFALSE 66619
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66597: LD_ADDR_VAR 0 11
66601: PUSH
66602: LD_VAR 0 4
66606: PPUSH
66607: LD_INT 4
66609: PPUSH
66610: CALL 55796 0 2
66614: PUSH
66615: LD_INT 1
66617: ARRAY
66618: ST_TO_ADDR
// if eng > 4 then
66619: LD_VAR 0 6
66623: PUSH
66624: LD_INT 4
66626: GREATER
66627: IFFALSE 66673
// for i = eng downto 4 do
66629: LD_ADDR_VAR 0 3
66633: PUSH
66634: DOUBLE
66635: LD_VAR 0 6
66639: INC
66640: ST_TO_ADDR
66641: LD_INT 4
66643: PUSH
66644: FOR_DOWNTO
66645: IFFALSE 66671
// eng := eng diff eng [ i ] ;
66647: LD_ADDR_VAR 0 6
66651: PUSH
66652: LD_VAR 0 6
66656: PUSH
66657: LD_VAR 0 6
66661: PUSH
66662: LD_VAR 0 3
66666: ARRAY
66667: DIFF
66668: ST_TO_ADDR
66669: GO 66644
66671: POP
66672: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66673: LD_ADDR_VAR 0 4
66677: PUSH
66678: LD_VAR 0 4
66682: PUSH
66683: LD_VAR 0 5
66687: PUSH
66688: LD_VAR 0 6
66692: UNION
66693: PUSH
66694: LD_VAR 0 7
66698: UNION
66699: PUSH
66700: LD_VAR 0 8
66704: UNION
66705: DIFF
66706: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66707: LD_ADDR_VAR 0 13
66711: PUSH
66712: LD_EXP 49
66716: PUSH
66717: LD_VAR 0 1
66721: ARRAY
66722: PPUSH
66723: LD_INT 2
66725: PUSH
66726: LD_INT 30
66728: PUSH
66729: LD_INT 32
66731: PUSH
66732: EMPTY
66733: LIST
66734: LIST
66735: PUSH
66736: LD_INT 30
66738: PUSH
66739: LD_INT 31
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: LIST
66750: PPUSH
66751: CALL_OW 72
66755: PUSH
66756: LD_EXP 49
66760: PUSH
66761: LD_VAR 0 1
66765: ARRAY
66766: PPUSH
66767: LD_INT 2
66769: PUSH
66770: LD_INT 30
66772: PUSH
66773: LD_INT 4
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 30
66782: PUSH
66783: LD_INT 5
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: LIST
66794: PPUSH
66795: CALL_OW 72
66799: PUSH
66800: LD_INT 6
66802: MUL
66803: PLUS
66804: ST_TO_ADDR
// if bcount < tmp then
66805: LD_VAR 0 13
66809: PUSH
66810: LD_VAR 0 4
66814: LESS
66815: IFFALSE 66861
// for i = tmp downto bcount do
66817: LD_ADDR_VAR 0 3
66821: PUSH
66822: DOUBLE
66823: LD_VAR 0 4
66827: INC
66828: ST_TO_ADDR
66829: LD_VAR 0 13
66833: PUSH
66834: FOR_DOWNTO
66835: IFFALSE 66859
// tmp := Delete ( tmp , tmp ) ;
66837: LD_ADDR_VAR 0 4
66841: PUSH
66842: LD_VAR 0 4
66846: PPUSH
66847: LD_VAR 0 4
66851: PPUSH
66852: CALL_OW 3
66856: ST_TO_ADDR
66857: GO 66834
66859: POP
66860: POP
// result := [ tmp , 0 , 0 , p ] ;
66861: LD_ADDR_VAR 0 2
66865: PUSH
66866: LD_VAR 0 4
66870: PUSH
66871: LD_INT 0
66873: PUSH
66874: LD_INT 0
66876: PUSH
66877: LD_VAR 0 11
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: ST_TO_ADDR
// exit ;
66888: GO 69578
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66890: LD_EXP 49
66894: PUSH
66895: LD_VAR 0 1
66899: ARRAY
66900: PPUSH
66901: LD_INT 2
66903: PUSH
66904: LD_INT 30
66906: PUSH
66907: LD_INT 6
66909: PUSH
66910: EMPTY
66911: LIST
66912: LIST
66913: PUSH
66914: LD_INT 30
66916: PUSH
66917: LD_INT 7
66919: PUSH
66920: EMPTY
66921: LIST
66922: LIST
66923: PUSH
66924: LD_INT 30
66926: PUSH
66927: LD_INT 8
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: LIST
66938: LIST
66939: PPUSH
66940: CALL_OW 72
66944: NOT
66945: PUSH
66946: LD_EXP 49
66950: PUSH
66951: LD_VAR 0 1
66955: ARRAY
66956: PPUSH
66957: LD_INT 30
66959: PUSH
66960: LD_INT 3
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PPUSH
66967: CALL_OW 72
66971: NOT
66972: AND
66973: IFFALSE 67045
// begin if eng = tmp then
66975: LD_VAR 0 6
66979: PUSH
66980: LD_VAR 0 4
66984: EQUAL
66985: IFFALSE 66989
// exit ;
66987: GO 69578
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
66989: LD_ADDR_EXP 91
66993: PUSH
66994: LD_EXP 91
66998: PPUSH
66999: LD_VAR 0 1
67003: PPUSH
67004: LD_INT 1
67006: PPUSH
67007: CALL_OW 1
67011: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
67012: LD_ADDR_VAR 0 2
67016: PUSH
67017: LD_INT 0
67019: PUSH
67020: LD_VAR 0 4
67024: PUSH
67025: LD_VAR 0 6
67029: DIFF
67030: PUSH
67031: LD_INT 0
67033: PUSH
67034: LD_INT 0
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: ST_TO_ADDR
// exit ;
67043: GO 69578
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67045: LD_EXP 76
67049: PUSH
67050: LD_EXP 75
67054: PUSH
67055: LD_VAR 0 1
67059: ARRAY
67060: ARRAY
67061: PUSH
67062: LD_EXP 49
67066: PUSH
67067: LD_VAR 0 1
67071: ARRAY
67072: PPUSH
67073: LD_INT 2
67075: PUSH
67076: LD_INT 30
67078: PUSH
67079: LD_INT 6
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 30
67088: PUSH
67089: LD_INT 7
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: PUSH
67096: LD_INT 30
67098: PUSH
67099: LD_INT 8
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: PPUSH
67112: CALL_OW 72
67116: AND
67117: PUSH
67118: LD_EXP 49
67122: PUSH
67123: LD_VAR 0 1
67127: ARRAY
67128: PPUSH
67129: LD_INT 30
67131: PUSH
67132: LD_INT 3
67134: PUSH
67135: EMPTY
67136: LIST
67137: LIST
67138: PPUSH
67139: CALL_OW 72
67143: NOT
67144: AND
67145: IFFALSE 67359
// begin if sci >= 6 then
67147: LD_VAR 0 8
67151: PUSH
67152: LD_INT 6
67154: GREATEREQUAL
67155: IFFALSE 67159
// exit ;
67157: GO 69578
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
67159: LD_ADDR_EXP 91
67163: PUSH
67164: LD_EXP 91
67168: PPUSH
67169: LD_VAR 0 1
67173: PPUSH
67174: LD_INT 2
67176: PPUSH
67177: CALL_OW 1
67181: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
67182: LD_ADDR_VAR 0 9
67186: PUSH
67187: LD_VAR 0 4
67191: PUSH
67192: LD_VAR 0 8
67196: DIFF
67197: PPUSH
67198: LD_INT 4
67200: PPUSH
67201: CALL 55796 0 2
67205: ST_TO_ADDR
// p := [ ] ;
67206: LD_ADDR_VAR 0 11
67210: PUSH
67211: EMPTY
67212: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67213: LD_VAR 0 8
67217: PUSH
67218: LD_INT 6
67220: LESS
67221: PUSH
67222: LD_VAR 0 9
67226: PUSH
67227: LD_INT 6
67229: GREATER
67230: AND
67231: IFFALSE 67312
// begin for i = 1 to 6 - sci do
67233: LD_ADDR_VAR 0 3
67237: PUSH
67238: DOUBLE
67239: LD_INT 1
67241: DEC
67242: ST_TO_ADDR
67243: LD_INT 6
67245: PUSH
67246: LD_VAR 0 8
67250: MINUS
67251: PUSH
67252: FOR_TO
67253: IFFALSE 67308
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67255: LD_ADDR_VAR 0 11
67259: PUSH
67260: LD_VAR 0 11
67264: PPUSH
67265: LD_VAR 0 11
67269: PUSH
67270: LD_INT 1
67272: PLUS
67273: PPUSH
67274: LD_VAR 0 9
67278: PUSH
67279: LD_INT 1
67281: ARRAY
67282: PPUSH
67283: CALL_OW 2
67287: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67288: LD_ADDR_VAR 0 9
67292: PUSH
67293: LD_VAR 0 9
67297: PPUSH
67298: LD_INT 1
67300: PPUSH
67301: CALL_OW 3
67305: ST_TO_ADDR
// end ;
67306: GO 67252
67308: POP
67309: POP
// end else
67310: GO 67332
// if sort then
67312: LD_VAR 0 9
67316: IFFALSE 67332
// p := sort [ 1 ] ;
67318: LD_ADDR_VAR 0 11
67322: PUSH
67323: LD_VAR 0 9
67327: PUSH
67328: LD_INT 1
67330: ARRAY
67331: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67332: LD_ADDR_VAR 0 2
67336: PUSH
67337: LD_INT 0
67339: PUSH
67340: LD_INT 0
67342: PUSH
67343: LD_INT 0
67345: PUSH
67346: LD_VAR 0 11
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: LIST
67355: LIST
67356: ST_TO_ADDR
// exit ;
67357: GO 69578
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67359: LD_EXP 76
67363: PUSH
67364: LD_EXP 75
67368: PUSH
67369: LD_VAR 0 1
67373: ARRAY
67374: ARRAY
67375: PUSH
67376: LD_EXP 49
67380: PUSH
67381: LD_VAR 0 1
67385: ARRAY
67386: PPUSH
67387: LD_INT 2
67389: PUSH
67390: LD_INT 30
67392: PUSH
67393: LD_INT 6
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 30
67402: PUSH
67403: LD_INT 7
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 30
67412: PUSH
67413: LD_INT 8
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: LIST
67424: LIST
67425: PPUSH
67426: CALL_OW 72
67430: AND
67431: PUSH
67432: LD_EXP 49
67436: PUSH
67437: LD_VAR 0 1
67441: ARRAY
67442: PPUSH
67443: LD_INT 30
67445: PUSH
67446: LD_INT 3
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PPUSH
67453: CALL_OW 72
67457: AND
67458: IFFALSE 68192
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67460: LD_ADDR_EXP 91
67464: PUSH
67465: LD_EXP 91
67469: PPUSH
67470: LD_VAR 0 1
67474: PPUSH
67475: LD_INT 3
67477: PPUSH
67478: CALL_OW 1
67482: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67483: LD_ADDR_VAR 0 2
67487: PUSH
67488: LD_INT 0
67490: PUSH
67491: LD_INT 0
67493: PUSH
67494: LD_INT 0
67496: PUSH
67497: LD_INT 0
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: ST_TO_ADDR
// if not eng then
67506: LD_VAR 0 6
67510: NOT
67511: IFFALSE 67574
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67513: LD_ADDR_VAR 0 11
67517: PUSH
67518: LD_VAR 0 4
67522: PPUSH
67523: LD_INT 2
67525: PPUSH
67526: CALL 55796 0 2
67530: PUSH
67531: LD_INT 1
67533: ARRAY
67534: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67535: LD_ADDR_VAR 0 2
67539: PUSH
67540: LD_VAR 0 2
67544: PPUSH
67545: LD_INT 2
67547: PPUSH
67548: LD_VAR 0 11
67552: PPUSH
67553: CALL_OW 1
67557: ST_TO_ADDR
// tmp := tmp diff p ;
67558: LD_ADDR_VAR 0 4
67562: PUSH
67563: LD_VAR 0 4
67567: PUSH
67568: LD_VAR 0 11
67572: DIFF
67573: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67574: LD_VAR 0 4
67578: PUSH
67579: LD_VAR 0 8
67583: PUSH
67584: LD_INT 6
67586: LESS
67587: AND
67588: IFFALSE 67776
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67590: LD_ADDR_VAR 0 9
67594: PUSH
67595: LD_VAR 0 4
67599: PUSH
67600: LD_VAR 0 8
67604: PUSH
67605: LD_VAR 0 7
67609: UNION
67610: DIFF
67611: PPUSH
67612: LD_INT 4
67614: PPUSH
67615: CALL 55796 0 2
67619: ST_TO_ADDR
// p := [ ] ;
67620: LD_ADDR_VAR 0 11
67624: PUSH
67625: EMPTY
67626: ST_TO_ADDR
// if sort then
67627: LD_VAR 0 9
67631: IFFALSE 67747
// for i = 1 to 6 - sci do
67633: LD_ADDR_VAR 0 3
67637: PUSH
67638: DOUBLE
67639: LD_INT 1
67641: DEC
67642: ST_TO_ADDR
67643: LD_INT 6
67645: PUSH
67646: LD_VAR 0 8
67650: MINUS
67651: PUSH
67652: FOR_TO
67653: IFFALSE 67745
// begin if i = sort then
67655: LD_VAR 0 3
67659: PUSH
67660: LD_VAR 0 9
67664: EQUAL
67665: IFFALSE 67669
// break ;
67667: GO 67745
// if GetClass ( i ) = 4 then
67669: LD_VAR 0 3
67673: PPUSH
67674: CALL_OW 257
67678: PUSH
67679: LD_INT 4
67681: EQUAL
67682: IFFALSE 67686
// continue ;
67684: GO 67652
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67686: LD_ADDR_VAR 0 11
67690: PUSH
67691: LD_VAR 0 11
67695: PPUSH
67696: LD_VAR 0 11
67700: PUSH
67701: LD_INT 1
67703: PLUS
67704: PPUSH
67705: LD_VAR 0 9
67709: PUSH
67710: LD_VAR 0 3
67714: ARRAY
67715: PPUSH
67716: CALL_OW 2
67720: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67721: LD_ADDR_VAR 0 4
67725: PUSH
67726: LD_VAR 0 4
67730: PUSH
67731: LD_VAR 0 9
67735: PUSH
67736: LD_VAR 0 3
67740: ARRAY
67741: DIFF
67742: ST_TO_ADDR
// end ;
67743: GO 67652
67745: POP
67746: POP
// if p then
67747: LD_VAR 0 11
67751: IFFALSE 67776
// result := Replace ( result , 4 , p ) ;
67753: LD_ADDR_VAR 0 2
67757: PUSH
67758: LD_VAR 0 2
67762: PPUSH
67763: LD_INT 4
67765: PPUSH
67766: LD_VAR 0 11
67770: PPUSH
67771: CALL_OW 1
67775: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67776: LD_VAR 0 4
67780: PUSH
67781: LD_VAR 0 7
67785: PUSH
67786: LD_INT 6
67788: LESS
67789: AND
67790: IFFALSE 67978
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67792: LD_ADDR_VAR 0 9
67796: PUSH
67797: LD_VAR 0 4
67801: PUSH
67802: LD_VAR 0 8
67806: PUSH
67807: LD_VAR 0 7
67811: UNION
67812: DIFF
67813: PPUSH
67814: LD_INT 3
67816: PPUSH
67817: CALL 55796 0 2
67821: ST_TO_ADDR
// p := [ ] ;
67822: LD_ADDR_VAR 0 11
67826: PUSH
67827: EMPTY
67828: ST_TO_ADDR
// if sort then
67829: LD_VAR 0 9
67833: IFFALSE 67949
// for i = 1 to 6 - mech do
67835: LD_ADDR_VAR 0 3
67839: PUSH
67840: DOUBLE
67841: LD_INT 1
67843: DEC
67844: ST_TO_ADDR
67845: LD_INT 6
67847: PUSH
67848: LD_VAR 0 7
67852: MINUS
67853: PUSH
67854: FOR_TO
67855: IFFALSE 67947
// begin if i = sort then
67857: LD_VAR 0 3
67861: PUSH
67862: LD_VAR 0 9
67866: EQUAL
67867: IFFALSE 67871
// break ;
67869: GO 67947
// if GetClass ( i ) = 3 then
67871: LD_VAR 0 3
67875: PPUSH
67876: CALL_OW 257
67880: PUSH
67881: LD_INT 3
67883: EQUAL
67884: IFFALSE 67888
// continue ;
67886: GO 67854
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67888: LD_ADDR_VAR 0 11
67892: PUSH
67893: LD_VAR 0 11
67897: PPUSH
67898: LD_VAR 0 11
67902: PUSH
67903: LD_INT 1
67905: PLUS
67906: PPUSH
67907: LD_VAR 0 9
67911: PUSH
67912: LD_VAR 0 3
67916: ARRAY
67917: PPUSH
67918: CALL_OW 2
67922: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67923: LD_ADDR_VAR 0 4
67927: PUSH
67928: LD_VAR 0 4
67932: PUSH
67933: LD_VAR 0 9
67937: PUSH
67938: LD_VAR 0 3
67942: ARRAY
67943: DIFF
67944: ST_TO_ADDR
// end ;
67945: GO 67854
67947: POP
67948: POP
// if p then
67949: LD_VAR 0 11
67953: IFFALSE 67978
// result := Replace ( result , 3 , p ) ;
67955: LD_ADDR_VAR 0 2
67959: PUSH
67960: LD_VAR 0 2
67964: PPUSH
67965: LD_INT 3
67967: PPUSH
67968: LD_VAR 0 11
67972: PPUSH
67973: CALL_OW 1
67977: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
67978: LD_VAR 0 4
67982: PUSH
67983: LD_INT 6
67985: GREATER
67986: PUSH
67987: LD_VAR 0 6
67991: PUSH
67992: LD_INT 6
67994: LESS
67995: AND
67996: IFFALSE 68190
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67998: LD_ADDR_VAR 0 9
68002: PUSH
68003: LD_VAR 0 4
68007: PUSH
68008: LD_VAR 0 8
68012: PUSH
68013: LD_VAR 0 7
68017: UNION
68018: PUSH
68019: LD_VAR 0 6
68023: UNION
68024: DIFF
68025: PPUSH
68026: LD_INT 2
68028: PPUSH
68029: CALL 55796 0 2
68033: ST_TO_ADDR
// p := [ ] ;
68034: LD_ADDR_VAR 0 11
68038: PUSH
68039: EMPTY
68040: ST_TO_ADDR
// if sort then
68041: LD_VAR 0 9
68045: IFFALSE 68161
// for i = 1 to 6 - eng do
68047: LD_ADDR_VAR 0 3
68051: PUSH
68052: DOUBLE
68053: LD_INT 1
68055: DEC
68056: ST_TO_ADDR
68057: LD_INT 6
68059: PUSH
68060: LD_VAR 0 6
68064: MINUS
68065: PUSH
68066: FOR_TO
68067: IFFALSE 68159
// begin if i = sort then
68069: LD_VAR 0 3
68073: PUSH
68074: LD_VAR 0 9
68078: EQUAL
68079: IFFALSE 68083
// break ;
68081: GO 68159
// if GetClass ( i ) = 2 then
68083: LD_VAR 0 3
68087: PPUSH
68088: CALL_OW 257
68092: PUSH
68093: LD_INT 2
68095: EQUAL
68096: IFFALSE 68100
// continue ;
68098: GO 68066
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68100: LD_ADDR_VAR 0 11
68104: PUSH
68105: LD_VAR 0 11
68109: PPUSH
68110: LD_VAR 0 11
68114: PUSH
68115: LD_INT 1
68117: PLUS
68118: PPUSH
68119: LD_VAR 0 9
68123: PUSH
68124: LD_VAR 0 3
68128: ARRAY
68129: PPUSH
68130: CALL_OW 2
68134: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68135: LD_ADDR_VAR 0 4
68139: PUSH
68140: LD_VAR 0 4
68144: PUSH
68145: LD_VAR 0 9
68149: PUSH
68150: LD_VAR 0 3
68154: ARRAY
68155: DIFF
68156: ST_TO_ADDR
// end ;
68157: GO 68066
68159: POP
68160: POP
// if p then
68161: LD_VAR 0 11
68165: IFFALSE 68190
// result := Replace ( result , 2 , p ) ;
68167: LD_ADDR_VAR 0 2
68171: PUSH
68172: LD_VAR 0 2
68176: PPUSH
68177: LD_INT 2
68179: PPUSH
68180: LD_VAR 0 11
68184: PPUSH
68185: CALL_OW 1
68189: ST_TO_ADDR
// end ; exit ;
68190: GO 69578
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
68192: LD_EXP 76
68196: PUSH
68197: LD_EXP 75
68201: PUSH
68202: LD_VAR 0 1
68206: ARRAY
68207: ARRAY
68208: NOT
68209: PUSH
68210: LD_EXP 49
68214: PUSH
68215: LD_VAR 0 1
68219: ARRAY
68220: PPUSH
68221: LD_INT 30
68223: PUSH
68224: LD_INT 3
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PPUSH
68231: CALL_OW 72
68235: AND
68236: PUSH
68237: LD_EXP 54
68241: PUSH
68242: LD_VAR 0 1
68246: ARRAY
68247: AND
68248: IFFALSE 68856
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68250: LD_ADDR_EXP 91
68254: PUSH
68255: LD_EXP 91
68259: PPUSH
68260: LD_VAR 0 1
68264: PPUSH
68265: LD_INT 5
68267: PPUSH
68268: CALL_OW 1
68272: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68273: LD_ADDR_VAR 0 2
68277: PUSH
68278: LD_INT 0
68280: PUSH
68281: LD_INT 0
68283: PUSH
68284: LD_INT 0
68286: PUSH
68287: LD_INT 0
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: ST_TO_ADDR
// if sci > 1 then
68296: LD_VAR 0 8
68300: PUSH
68301: LD_INT 1
68303: GREATER
68304: IFFALSE 68332
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68306: LD_ADDR_VAR 0 4
68310: PUSH
68311: LD_VAR 0 4
68315: PUSH
68316: LD_VAR 0 8
68320: PUSH
68321: LD_VAR 0 8
68325: PUSH
68326: LD_INT 1
68328: ARRAY
68329: DIFF
68330: DIFF
68331: ST_TO_ADDR
// if tmp and not sci then
68332: LD_VAR 0 4
68336: PUSH
68337: LD_VAR 0 8
68341: NOT
68342: AND
68343: IFFALSE 68412
// begin sort := SortBySkill ( tmp , 4 ) ;
68345: LD_ADDR_VAR 0 9
68349: PUSH
68350: LD_VAR 0 4
68354: PPUSH
68355: LD_INT 4
68357: PPUSH
68358: CALL 55796 0 2
68362: ST_TO_ADDR
// if sort then
68363: LD_VAR 0 9
68367: IFFALSE 68383
// p := sort [ 1 ] ;
68369: LD_ADDR_VAR 0 11
68373: PUSH
68374: LD_VAR 0 9
68378: PUSH
68379: LD_INT 1
68381: ARRAY
68382: ST_TO_ADDR
// if p then
68383: LD_VAR 0 11
68387: IFFALSE 68412
// result := Replace ( result , 4 , p ) ;
68389: LD_ADDR_VAR 0 2
68393: PUSH
68394: LD_VAR 0 2
68398: PPUSH
68399: LD_INT 4
68401: PPUSH
68402: LD_VAR 0 11
68406: PPUSH
68407: CALL_OW 1
68411: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68412: LD_ADDR_VAR 0 4
68416: PUSH
68417: LD_VAR 0 4
68421: PUSH
68422: LD_VAR 0 7
68426: DIFF
68427: ST_TO_ADDR
// if tmp and mech < 6 then
68428: LD_VAR 0 4
68432: PUSH
68433: LD_VAR 0 7
68437: PUSH
68438: LD_INT 6
68440: LESS
68441: AND
68442: IFFALSE 68630
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68444: LD_ADDR_VAR 0 9
68448: PUSH
68449: LD_VAR 0 4
68453: PUSH
68454: LD_VAR 0 8
68458: PUSH
68459: LD_VAR 0 7
68463: UNION
68464: DIFF
68465: PPUSH
68466: LD_INT 3
68468: PPUSH
68469: CALL 55796 0 2
68473: ST_TO_ADDR
// p := [ ] ;
68474: LD_ADDR_VAR 0 11
68478: PUSH
68479: EMPTY
68480: ST_TO_ADDR
// if sort then
68481: LD_VAR 0 9
68485: IFFALSE 68601
// for i = 1 to 6 - mech do
68487: LD_ADDR_VAR 0 3
68491: PUSH
68492: DOUBLE
68493: LD_INT 1
68495: DEC
68496: ST_TO_ADDR
68497: LD_INT 6
68499: PUSH
68500: LD_VAR 0 7
68504: MINUS
68505: PUSH
68506: FOR_TO
68507: IFFALSE 68599
// begin if i = sort then
68509: LD_VAR 0 3
68513: PUSH
68514: LD_VAR 0 9
68518: EQUAL
68519: IFFALSE 68523
// break ;
68521: GO 68599
// if GetClass ( i ) = 3 then
68523: LD_VAR 0 3
68527: PPUSH
68528: CALL_OW 257
68532: PUSH
68533: LD_INT 3
68535: EQUAL
68536: IFFALSE 68540
// continue ;
68538: GO 68506
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68540: LD_ADDR_VAR 0 11
68544: PUSH
68545: LD_VAR 0 11
68549: PPUSH
68550: LD_VAR 0 11
68554: PUSH
68555: LD_INT 1
68557: PLUS
68558: PPUSH
68559: LD_VAR 0 9
68563: PUSH
68564: LD_VAR 0 3
68568: ARRAY
68569: PPUSH
68570: CALL_OW 2
68574: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68575: LD_ADDR_VAR 0 4
68579: PUSH
68580: LD_VAR 0 4
68584: PUSH
68585: LD_VAR 0 9
68589: PUSH
68590: LD_VAR 0 3
68594: ARRAY
68595: DIFF
68596: ST_TO_ADDR
// end ;
68597: GO 68506
68599: POP
68600: POP
// if p then
68601: LD_VAR 0 11
68605: IFFALSE 68630
// result := Replace ( result , 3 , p ) ;
68607: LD_ADDR_VAR 0 2
68611: PUSH
68612: LD_VAR 0 2
68616: PPUSH
68617: LD_INT 3
68619: PPUSH
68620: LD_VAR 0 11
68624: PPUSH
68625: CALL_OW 1
68629: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68630: LD_ADDR_VAR 0 4
68634: PUSH
68635: LD_VAR 0 4
68639: PUSH
68640: LD_VAR 0 6
68644: DIFF
68645: ST_TO_ADDR
// if tmp and eng < 6 then
68646: LD_VAR 0 4
68650: PUSH
68651: LD_VAR 0 6
68655: PUSH
68656: LD_INT 6
68658: LESS
68659: AND
68660: IFFALSE 68854
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68662: LD_ADDR_VAR 0 9
68666: PUSH
68667: LD_VAR 0 4
68671: PUSH
68672: LD_VAR 0 8
68676: PUSH
68677: LD_VAR 0 7
68681: UNION
68682: PUSH
68683: LD_VAR 0 6
68687: UNION
68688: DIFF
68689: PPUSH
68690: LD_INT 2
68692: PPUSH
68693: CALL 55796 0 2
68697: ST_TO_ADDR
// p := [ ] ;
68698: LD_ADDR_VAR 0 11
68702: PUSH
68703: EMPTY
68704: ST_TO_ADDR
// if sort then
68705: LD_VAR 0 9
68709: IFFALSE 68825
// for i = 1 to 6 - eng do
68711: LD_ADDR_VAR 0 3
68715: PUSH
68716: DOUBLE
68717: LD_INT 1
68719: DEC
68720: ST_TO_ADDR
68721: LD_INT 6
68723: PUSH
68724: LD_VAR 0 6
68728: MINUS
68729: PUSH
68730: FOR_TO
68731: IFFALSE 68823
// begin if i = sort then
68733: LD_VAR 0 3
68737: PUSH
68738: LD_VAR 0 9
68742: EQUAL
68743: IFFALSE 68747
// break ;
68745: GO 68823
// if GetClass ( i ) = 2 then
68747: LD_VAR 0 3
68751: PPUSH
68752: CALL_OW 257
68756: PUSH
68757: LD_INT 2
68759: EQUAL
68760: IFFALSE 68764
// continue ;
68762: GO 68730
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68764: LD_ADDR_VAR 0 11
68768: PUSH
68769: LD_VAR 0 11
68773: PPUSH
68774: LD_VAR 0 11
68778: PUSH
68779: LD_INT 1
68781: PLUS
68782: PPUSH
68783: LD_VAR 0 9
68787: PUSH
68788: LD_VAR 0 3
68792: ARRAY
68793: PPUSH
68794: CALL_OW 2
68798: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68799: LD_ADDR_VAR 0 4
68803: PUSH
68804: LD_VAR 0 4
68808: PUSH
68809: LD_VAR 0 9
68813: PUSH
68814: LD_VAR 0 3
68818: ARRAY
68819: DIFF
68820: ST_TO_ADDR
// end ;
68821: GO 68730
68823: POP
68824: POP
// if p then
68825: LD_VAR 0 11
68829: IFFALSE 68854
// result := Replace ( result , 2 , p ) ;
68831: LD_ADDR_VAR 0 2
68835: PUSH
68836: LD_VAR 0 2
68840: PPUSH
68841: LD_INT 2
68843: PPUSH
68844: LD_VAR 0 11
68848: PPUSH
68849: CALL_OW 1
68853: ST_TO_ADDR
// end ; exit ;
68854: GO 69578
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
68856: LD_EXP 76
68860: PUSH
68861: LD_EXP 75
68865: PUSH
68866: LD_VAR 0 1
68870: ARRAY
68871: ARRAY
68872: NOT
68873: PUSH
68874: LD_EXP 49
68878: PUSH
68879: LD_VAR 0 1
68883: ARRAY
68884: PPUSH
68885: LD_INT 30
68887: PUSH
68888: LD_INT 3
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PPUSH
68895: CALL_OW 72
68899: AND
68900: PUSH
68901: LD_EXP 54
68905: PUSH
68906: LD_VAR 0 1
68910: ARRAY
68911: NOT
68912: AND
68913: IFFALSE 69578
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
68915: LD_ADDR_EXP 91
68919: PUSH
68920: LD_EXP 91
68924: PPUSH
68925: LD_VAR 0 1
68929: PPUSH
68930: LD_INT 6
68932: PPUSH
68933: CALL_OW 1
68937: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68938: LD_ADDR_VAR 0 2
68942: PUSH
68943: LD_INT 0
68945: PUSH
68946: LD_INT 0
68948: PUSH
68949: LD_INT 0
68951: PUSH
68952: LD_INT 0
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: ST_TO_ADDR
// if sci >= 1 then
68961: LD_VAR 0 8
68965: PUSH
68966: LD_INT 1
68968: GREATEREQUAL
68969: IFFALSE 68991
// tmp := tmp diff sci [ 1 ] ;
68971: LD_ADDR_VAR 0 4
68975: PUSH
68976: LD_VAR 0 4
68980: PUSH
68981: LD_VAR 0 8
68985: PUSH
68986: LD_INT 1
68988: ARRAY
68989: DIFF
68990: ST_TO_ADDR
// if tmp and not sci then
68991: LD_VAR 0 4
68995: PUSH
68996: LD_VAR 0 8
69000: NOT
69001: AND
69002: IFFALSE 69071
// begin sort := SortBySkill ( tmp , 4 ) ;
69004: LD_ADDR_VAR 0 9
69008: PUSH
69009: LD_VAR 0 4
69013: PPUSH
69014: LD_INT 4
69016: PPUSH
69017: CALL 55796 0 2
69021: ST_TO_ADDR
// if sort then
69022: LD_VAR 0 9
69026: IFFALSE 69042
// p := sort [ 1 ] ;
69028: LD_ADDR_VAR 0 11
69032: PUSH
69033: LD_VAR 0 9
69037: PUSH
69038: LD_INT 1
69040: ARRAY
69041: ST_TO_ADDR
// if p then
69042: LD_VAR 0 11
69046: IFFALSE 69071
// result := Replace ( result , 4 , p ) ;
69048: LD_ADDR_VAR 0 2
69052: PUSH
69053: LD_VAR 0 2
69057: PPUSH
69058: LD_INT 4
69060: PPUSH
69061: LD_VAR 0 11
69065: PPUSH
69066: CALL_OW 1
69070: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69071: LD_ADDR_VAR 0 4
69075: PUSH
69076: LD_VAR 0 4
69080: PUSH
69081: LD_VAR 0 7
69085: DIFF
69086: ST_TO_ADDR
// if tmp and mech < 6 then
69087: LD_VAR 0 4
69091: PUSH
69092: LD_VAR 0 7
69096: PUSH
69097: LD_INT 6
69099: LESS
69100: AND
69101: IFFALSE 69283
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
69103: LD_ADDR_VAR 0 9
69107: PUSH
69108: LD_VAR 0 4
69112: PUSH
69113: LD_VAR 0 7
69117: DIFF
69118: PPUSH
69119: LD_INT 3
69121: PPUSH
69122: CALL 55796 0 2
69126: ST_TO_ADDR
// p := [ ] ;
69127: LD_ADDR_VAR 0 11
69131: PUSH
69132: EMPTY
69133: ST_TO_ADDR
// if sort then
69134: LD_VAR 0 9
69138: IFFALSE 69254
// for i = 1 to 6 - mech do
69140: LD_ADDR_VAR 0 3
69144: PUSH
69145: DOUBLE
69146: LD_INT 1
69148: DEC
69149: ST_TO_ADDR
69150: LD_INT 6
69152: PUSH
69153: LD_VAR 0 7
69157: MINUS
69158: PUSH
69159: FOR_TO
69160: IFFALSE 69252
// begin if i = sort then
69162: LD_VAR 0 3
69166: PUSH
69167: LD_VAR 0 9
69171: EQUAL
69172: IFFALSE 69176
// break ;
69174: GO 69252
// if GetClass ( i ) = 3 then
69176: LD_VAR 0 3
69180: PPUSH
69181: CALL_OW 257
69185: PUSH
69186: LD_INT 3
69188: EQUAL
69189: IFFALSE 69193
// continue ;
69191: GO 69159
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69193: LD_ADDR_VAR 0 11
69197: PUSH
69198: LD_VAR 0 11
69202: PPUSH
69203: LD_VAR 0 11
69207: PUSH
69208: LD_INT 1
69210: PLUS
69211: PPUSH
69212: LD_VAR 0 9
69216: PUSH
69217: LD_VAR 0 3
69221: ARRAY
69222: PPUSH
69223: CALL_OW 2
69227: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69228: LD_ADDR_VAR 0 4
69232: PUSH
69233: LD_VAR 0 4
69237: PUSH
69238: LD_VAR 0 9
69242: PUSH
69243: LD_VAR 0 3
69247: ARRAY
69248: DIFF
69249: ST_TO_ADDR
// end ;
69250: GO 69159
69252: POP
69253: POP
// if p then
69254: LD_VAR 0 11
69258: IFFALSE 69283
// result := Replace ( result , 3 , p ) ;
69260: LD_ADDR_VAR 0 2
69264: PUSH
69265: LD_VAR 0 2
69269: PPUSH
69270: LD_INT 3
69272: PPUSH
69273: LD_VAR 0 11
69277: PPUSH
69278: CALL_OW 1
69282: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69283: LD_ADDR_VAR 0 4
69287: PUSH
69288: LD_VAR 0 4
69292: PUSH
69293: LD_VAR 0 6
69297: DIFF
69298: ST_TO_ADDR
// if tmp and eng < 4 then
69299: LD_VAR 0 4
69303: PUSH
69304: LD_VAR 0 6
69308: PUSH
69309: LD_INT 4
69311: LESS
69312: AND
69313: IFFALSE 69503
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69315: LD_ADDR_VAR 0 9
69319: PUSH
69320: LD_VAR 0 4
69324: PUSH
69325: LD_VAR 0 7
69329: PUSH
69330: LD_VAR 0 6
69334: UNION
69335: DIFF
69336: PPUSH
69337: LD_INT 2
69339: PPUSH
69340: CALL 55796 0 2
69344: ST_TO_ADDR
// p := [ ] ;
69345: LD_ADDR_VAR 0 11
69349: PUSH
69350: EMPTY
69351: ST_TO_ADDR
// if sort then
69352: LD_VAR 0 9
69356: IFFALSE 69472
// for i = 1 to 4 - eng do
69358: LD_ADDR_VAR 0 3
69362: PUSH
69363: DOUBLE
69364: LD_INT 1
69366: DEC
69367: ST_TO_ADDR
69368: LD_INT 4
69370: PUSH
69371: LD_VAR 0 6
69375: MINUS
69376: PUSH
69377: FOR_TO
69378: IFFALSE 69470
// begin if i = sort then
69380: LD_VAR 0 3
69384: PUSH
69385: LD_VAR 0 9
69389: EQUAL
69390: IFFALSE 69394
// break ;
69392: GO 69470
// if GetClass ( i ) = 2 then
69394: LD_VAR 0 3
69398: PPUSH
69399: CALL_OW 257
69403: PUSH
69404: LD_INT 2
69406: EQUAL
69407: IFFALSE 69411
// continue ;
69409: GO 69377
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69411: LD_ADDR_VAR 0 11
69415: PUSH
69416: LD_VAR 0 11
69420: PPUSH
69421: LD_VAR 0 11
69425: PUSH
69426: LD_INT 1
69428: PLUS
69429: PPUSH
69430: LD_VAR 0 9
69434: PUSH
69435: LD_VAR 0 3
69439: ARRAY
69440: PPUSH
69441: CALL_OW 2
69445: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69446: LD_ADDR_VAR 0 4
69450: PUSH
69451: LD_VAR 0 4
69455: PUSH
69456: LD_VAR 0 9
69460: PUSH
69461: LD_VAR 0 3
69465: ARRAY
69466: DIFF
69467: ST_TO_ADDR
// end ;
69468: GO 69377
69470: POP
69471: POP
// if p then
69472: LD_VAR 0 11
69476: IFFALSE 69501
// result := Replace ( result , 2 , p ) ;
69478: LD_ADDR_VAR 0 2
69482: PUSH
69483: LD_VAR 0 2
69487: PPUSH
69488: LD_INT 2
69490: PPUSH
69491: LD_VAR 0 11
69495: PPUSH
69496: CALL_OW 1
69500: ST_TO_ADDR
// end else
69501: GO 69547
// for i = eng downto 5 do
69503: LD_ADDR_VAR 0 3
69507: PUSH
69508: DOUBLE
69509: LD_VAR 0 6
69513: INC
69514: ST_TO_ADDR
69515: LD_INT 5
69517: PUSH
69518: FOR_DOWNTO
69519: IFFALSE 69545
// tmp := tmp union eng [ i ] ;
69521: LD_ADDR_VAR 0 4
69525: PUSH
69526: LD_VAR 0 4
69530: PUSH
69531: LD_VAR 0 6
69535: PUSH
69536: LD_VAR 0 3
69540: ARRAY
69541: UNION
69542: ST_TO_ADDR
69543: GO 69518
69545: POP
69546: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69547: LD_ADDR_VAR 0 2
69551: PUSH
69552: LD_VAR 0 2
69556: PPUSH
69557: LD_INT 1
69559: PPUSH
69560: LD_VAR 0 4
69564: PUSH
69565: LD_VAR 0 5
69569: DIFF
69570: PPUSH
69571: CALL_OW 1
69575: ST_TO_ADDR
// exit ;
69576: GO 69578
// end ; end ;
69578: LD_VAR 0 2
69582: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69583: LD_INT 0
69585: PPUSH
69586: PPUSH
69587: PPUSH
// if not mc_bases then
69588: LD_EXP 49
69592: NOT
69593: IFFALSE 69597
// exit ;
69595: GO 69739
// for i = 1 to mc_bases do
69597: LD_ADDR_VAR 0 2
69601: PUSH
69602: DOUBLE
69603: LD_INT 1
69605: DEC
69606: ST_TO_ADDR
69607: LD_EXP 49
69611: PUSH
69612: FOR_TO
69613: IFFALSE 69730
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69615: LD_ADDR_VAR 0 3
69619: PUSH
69620: LD_EXP 49
69624: PUSH
69625: LD_VAR 0 2
69629: ARRAY
69630: PPUSH
69631: LD_INT 21
69633: PUSH
69634: LD_INT 3
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: LD_INT 3
69643: PUSH
69644: LD_INT 2
69646: PUSH
69647: LD_INT 30
69649: PUSH
69650: LD_INT 29
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 30
69659: PUSH
69660: LD_INT 30
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: LIST
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: PUSH
69676: LD_INT 3
69678: PUSH
69679: LD_INT 24
69681: PUSH
69682: LD_INT 1000
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PUSH
69693: EMPTY
69694: LIST
69695: LIST
69696: LIST
69697: PPUSH
69698: CALL_OW 72
69702: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69703: LD_ADDR_EXP 50
69707: PUSH
69708: LD_EXP 50
69712: PPUSH
69713: LD_VAR 0 2
69717: PPUSH
69718: LD_VAR 0 3
69722: PPUSH
69723: CALL_OW 1
69727: ST_TO_ADDR
// end ;
69728: GO 69612
69730: POP
69731: POP
// RaiseSailEvent ( 101 ) ;
69732: LD_INT 101
69734: PPUSH
69735: CALL_OW 427
// end ;
69739: LD_VAR 0 1
69743: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69744: LD_INT 0
69746: PPUSH
69747: PPUSH
69748: PPUSH
69749: PPUSH
69750: PPUSH
69751: PPUSH
69752: PPUSH
// if not mc_bases then
69753: LD_EXP 49
69757: NOT
69758: IFFALSE 69762
// exit ;
69760: GO 70324
// for i = 1 to mc_bases do
69762: LD_ADDR_VAR 0 2
69766: PUSH
69767: DOUBLE
69768: LD_INT 1
69770: DEC
69771: ST_TO_ADDR
69772: LD_EXP 49
69776: PUSH
69777: FOR_TO
69778: IFFALSE 70315
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69780: LD_ADDR_VAR 0 5
69784: PUSH
69785: LD_EXP 49
69789: PUSH
69790: LD_VAR 0 2
69794: ARRAY
69795: PUSH
69796: LD_EXP 78
69800: PUSH
69801: LD_VAR 0 2
69805: ARRAY
69806: UNION
69807: PPUSH
69808: LD_INT 21
69810: PUSH
69811: LD_INT 1
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 1
69820: PUSH
69821: LD_INT 3
69823: PUSH
69824: LD_INT 54
69826: PUSH
69827: EMPTY
69828: LIST
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 3
69836: PUSH
69837: LD_INT 24
69839: PUSH
69840: LD_INT 1000
69842: PUSH
69843: EMPTY
69844: LIST
69845: LIST
69846: PUSH
69847: EMPTY
69848: LIST
69849: LIST
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: LIST
69855: PUSH
69856: EMPTY
69857: LIST
69858: LIST
69859: PPUSH
69860: CALL_OW 72
69864: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
69865: LD_ADDR_VAR 0 6
69869: PUSH
69870: LD_EXP 49
69874: PUSH
69875: LD_VAR 0 2
69879: ARRAY
69880: PPUSH
69881: LD_INT 21
69883: PUSH
69884: LD_INT 1
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 1
69893: PUSH
69894: LD_INT 3
69896: PUSH
69897: LD_INT 54
69899: PUSH
69900: EMPTY
69901: LIST
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 3
69909: PUSH
69910: LD_INT 24
69912: PUSH
69913: LD_INT 250
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: EMPTY
69921: LIST
69922: LIST
69923: PUSH
69924: EMPTY
69925: LIST
69926: LIST
69927: LIST
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PPUSH
69933: CALL_OW 72
69937: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
69938: LD_ADDR_VAR 0 7
69942: PUSH
69943: LD_VAR 0 5
69947: PUSH
69948: LD_VAR 0 6
69952: DIFF
69953: ST_TO_ADDR
// if not need_heal_1 then
69954: LD_VAR 0 6
69958: NOT
69959: IFFALSE 69992
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
69961: LD_ADDR_EXP 52
69965: PUSH
69966: LD_EXP 52
69970: PPUSH
69971: LD_VAR 0 2
69975: PUSH
69976: LD_INT 1
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PPUSH
69983: EMPTY
69984: PPUSH
69985: CALL 25025 0 3
69989: ST_TO_ADDR
69990: GO 70062
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
69992: LD_ADDR_EXP 52
69996: PUSH
69997: LD_EXP 52
70001: PPUSH
70002: LD_VAR 0 2
70006: PUSH
70007: LD_INT 1
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PPUSH
70014: LD_EXP 52
70018: PUSH
70019: LD_VAR 0 2
70023: ARRAY
70024: PUSH
70025: LD_INT 1
70027: ARRAY
70028: PPUSH
70029: LD_INT 3
70031: PUSH
70032: LD_INT 24
70034: PUSH
70035: LD_INT 1000
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PPUSH
70046: CALL_OW 72
70050: PUSH
70051: LD_VAR 0 6
70055: UNION
70056: PPUSH
70057: CALL 25025 0 3
70061: ST_TO_ADDR
// if not need_heal_2 then
70062: LD_VAR 0 7
70066: NOT
70067: IFFALSE 70100
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
70069: LD_ADDR_EXP 52
70073: PUSH
70074: LD_EXP 52
70078: PPUSH
70079: LD_VAR 0 2
70083: PUSH
70084: LD_INT 2
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PPUSH
70091: EMPTY
70092: PPUSH
70093: CALL 25025 0 3
70097: ST_TO_ADDR
70098: GO 70132
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
70100: LD_ADDR_EXP 52
70104: PUSH
70105: LD_EXP 52
70109: PPUSH
70110: LD_VAR 0 2
70114: PUSH
70115: LD_INT 2
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PPUSH
70122: LD_VAR 0 7
70126: PPUSH
70127: CALL 25025 0 3
70131: ST_TO_ADDR
// if need_heal_2 then
70132: LD_VAR 0 7
70136: IFFALSE 70297
// for j in need_heal_2 do
70138: LD_ADDR_VAR 0 3
70142: PUSH
70143: LD_VAR 0 7
70147: PUSH
70148: FOR_IN
70149: IFFALSE 70295
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70151: LD_ADDR_VAR 0 5
70155: PUSH
70156: LD_EXP 49
70160: PUSH
70161: LD_VAR 0 2
70165: ARRAY
70166: PPUSH
70167: LD_INT 2
70169: PUSH
70170: LD_INT 30
70172: PUSH
70173: LD_INT 6
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 30
70182: PUSH
70183: LD_INT 7
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 30
70192: PUSH
70193: LD_INT 8
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 30
70202: PUSH
70203: LD_INT 0
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: LD_INT 30
70212: PUSH
70213: LD_INT 1
70215: PUSH
70216: EMPTY
70217: LIST
70218: LIST
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: PPUSH
70228: CALL_OW 72
70232: ST_TO_ADDR
// if tmp then
70233: LD_VAR 0 5
70237: IFFALSE 70293
// begin k := NearestUnitToUnit ( tmp , j ) ;
70239: LD_ADDR_VAR 0 4
70243: PUSH
70244: LD_VAR 0 5
70248: PPUSH
70249: LD_VAR 0 3
70253: PPUSH
70254: CALL_OW 74
70258: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70259: LD_VAR 0 3
70263: PPUSH
70264: LD_VAR 0 4
70268: PPUSH
70269: CALL_OW 296
70273: PUSH
70274: LD_INT 5
70276: GREATER
70277: IFFALSE 70293
// ComMoveToNearbyEntrance ( j , k ) ;
70279: LD_VAR 0 3
70283: PPUSH
70284: LD_VAR 0 4
70288: PPUSH
70289: CALL 58164 0 2
// end ; end ;
70293: GO 70148
70295: POP
70296: POP
// if not need_heal_1 and not need_heal_2 then
70297: LD_VAR 0 6
70301: NOT
70302: PUSH
70303: LD_VAR 0 7
70307: NOT
70308: AND
70309: IFFALSE 70313
// continue ;
70311: GO 69777
// end ;
70313: GO 69777
70315: POP
70316: POP
// RaiseSailEvent ( 102 ) ;
70317: LD_INT 102
70319: PPUSH
70320: CALL_OW 427
// end ;
70324: LD_VAR 0 1
70328: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70329: LD_INT 0
70331: PPUSH
70332: PPUSH
70333: PPUSH
70334: PPUSH
70335: PPUSH
70336: PPUSH
70337: PPUSH
70338: PPUSH
// if not mc_bases then
70339: LD_EXP 49
70343: NOT
70344: IFFALSE 70348
// exit ;
70346: GO 71231
// for i = 1 to mc_bases do
70348: LD_ADDR_VAR 0 2
70352: PUSH
70353: DOUBLE
70354: LD_INT 1
70356: DEC
70357: ST_TO_ADDR
70358: LD_EXP 49
70362: PUSH
70363: FOR_TO
70364: IFFALSE 71229
// begin if not mc_building_need_repair [ i ] then
70366: LD_EXP 50
70370: PUSH
70371: LD_VAR 0 2
70375: ARRAY
70376: NOT
70377: IFFALSE 70564
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70379: LD_ADDR_VAR 0 6
70383: PUSH
70384: LD_EXP 68
70388: PUSH
70389: LD_VAR 0 2
70393: ARRAY
70394: PPUSH
70395: LD_INT 3
70397: PUSH
70398: LD_INT 24
70400: PUSH
70401: LD_INT 1000
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: PUSH
70412: LD_INT 2
70414: PUSH
70415: LD_INT 34
70417: PUSH
70418: LD_INT 13
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 34
70427: PUSH
70428: LD_INT 52
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PUSH
70435: LD_INT 34
70437: PUSH
70438: LD_EXP 35
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: LIST
70451: LIST
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PPUSH
70457: CALL_OW 72
70461: ST_TO_ADDR
// if cranes then
70462: LD_VAR 0 6
70466: IFFALSE 70528
// for j in cranes do
70468: LD_ADDR_VAR 0 3
70472: PUSH
70473: LD_VAR 0 6
70477: PUSH
70478: FOR_IN
70479: IFFALSE 70526
// if not IsInArea ( j , mc_parking [ i ] ) then
70481: LD_VAR 0 3
70485: PPUSH
70486: LD_EXP 73
70490: PUSH
70491: LD_VAR 0 2
70495: ARRAY
70496: PPUSH
70497: CALL_OW 308
70501: NOT
70502: IFFALSE 70524
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70504: LD_VAR 0 3
70508: PPUSH
70509: LD_EXP 73
70513: PUSH
70514: LD_VAR 0 2
70518: ARRAY
70519: PPUSH
70520: CALL_OW 113
70524: GO 70478
70526: POP
70527: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70528: LD_ADDR_EXP 51
70532: PUSH
70533: LD_EXP 51
70537: PPUSH
70538: LD_VAR 0 2
70542: PPUSH
70543: EMPTY
70544: PPUSH
70545: CALL_OW 1
70549: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70550: LD_VAR 0 2
70554: PPUSH
70555: LD_INT 101
70557: PPUSH
70558: CALL 65416 0 2
// continue ;
70562: GO 70363
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70564: LD_ADDR_EXP 55
70568: PUSH
70569: LD_EXP 55
70573: PPUSH
70574: LD_VAR 0 2
70578: PPUSH
70579: EMPTY
70580: PPUSH
70581: CALL_OW 1
70585: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70586: LD_VAR 0 2
70590: PPUSH
70591: LD_INT 103
70593: PPUSH
70594: CALL 65416 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70598: LD_ADDR_VAR 0 5
70602: PUSH
70603: LD_EXP 49
70607: PUSH
70608: LD_VAR 0 2
70612: ARRAY
70613: PUSH
70614: LD_EXP 78
70618: PUSH
70619: LD_VAR 0 2
70623: ARRAY
70624: UNION
70625: PPUSH
70626: LD_INT 2
70628: PUSH
70629: LD_INT 25
70631: PUSH
70632: LD_INT 2
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 25
70641: PUSH
70642: LD_INT 16
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: LIST
70653: PUSH
70654: EMPTY
70655: LIST
70656: PPUSH
70657: CALL_OW 72
70661: ST_TO_ADDR
// if mc_need_heal [ i ] then
70662: LD_EXP 52
70666: PUSH
70667: LD_VAR 0 2
70671: ARRAY
70672: IFFALSE 70716
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70674: LD_ADDR_VAR 0 5
70678: PUSH
70679: LD_VAR 0 5
70683: PUSH
70684: LD_EXP 52
70688: PUSH
70689: LD_VAR 0 2
70693: ARRAY
70694: PUSH
70695: LD_INT 1
70697: ARRAY
70698: PUSH
70699: LD_EXP 52
70703: PUSH
70704: LD_VAR 0 2
70708: ARRAY
70709: PUSH
70710: LD_INT 2
70712: ARRAY
70713: UNION
70714: DIFF
70715: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70716: LD_ADDR_VAR 0 6
70720: PUSH
70721: LD_EXP 68
70725: PUSH
70726: LD_VAR 0 2
70730: ARRAY
70731: PPUSH
70732: LD_INT 2
70734: PUSH
70735: LD_INT 34
70737: PUSH
70738: LD_INT 13
70740: PUSH
70741: EMPTY
70742: LIST
70743: LIST
70744: PUSH
70745: LD_INT 34
70747: PUSH
70748: LD_INT 52
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 34
70757: PUSH
70758: LD_EXP 35
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: PPUSH
70773: CALL_OW 72
70777: ST_TO_ADDR
// if cranes then
70778: LD_VAR 0 6
70782: IFFALSE 70918
// begin for j in cranes do
70784: LD_ADDR_VAR 0 3
70788: PUSH
70789: LD_VAR 0 6
70793: PUSH
70794: FOR_IN
70795: IFFALSE 70916
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70797: LD_VAR 0 3
70801: PPUSH
70802: CALL_OW 256
70806: PUSH
70807: LD_INT 1000
70809: EQUAL
70810: PUSH
70811: LD_VAR 0 3
70815: PPUSH
70816: CALL_OW 314
70820: NOT
70821: AND
70822: IFFALSE 70856
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
70824: LD_VAR 0 3
70828: PPUSH
70829: LD_EXP 50
70833: PUSH
70834: LD_VAR 0 2
70838: ARRAY
70839: PPUSH
70840: LD_VAR 0 3
70844: PPUSH
70845: CALL_OW 74
70849: PPUSH
70850: CALL_OW 130
70854: GO 70914
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
70856: LD_VAR 0 3
70860: PPUSH
70861: CALL_OW 256
70865: PUSH
70866: LD_INT 500
70868: LESS
70869: PUSH
70870: LD_VAR 0 3
70874: PPUSH
70875: LD_EXP 73
70879: PUSH
70880: LD_VAR 0 2
70884: ARRAY
70885: PPUSH
70886: CALL_OW 308
70890: NOT
70891: AND
70892: IFFALSE 70914
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70894: LD_VAR 0 3
70898: PPUSH
70899: LD_EXP 73
70903: PUSH
70904: LD_VAR 0 2
70908: ARRAY
70909: PPUSH
70910: CALL_OW 113
// end ;
70914: GO 70794
70916: POP
70917: POP
// end ; if tmp > 3 then
70918: LD_VAR 0 5
70922: PUSH
70923: LD_INT 3
70925: GREATER
70926: IFFALSE 70946
// tmp := ShrinkArray ( tmp , 4 ) ;
70928: LD_ADDR_VAR 0 5
70932: PUSH
70933: LD_VAR 0 5
70937: PPUSH
70938: LD_INT 4
70940: PPUSH
70941: CALL 57602 0 2
70945: ST_TO_ADDR
// if not tmp then
70946: LD_VAR 0 5
70950: NOT
70951: IFFALSE 70955
// continue ;
70953: GO 70363
// for j in tmp do
70955: LD_ADDR_VAR 0 3
70959: PUSH
70960: LD_VAR 0 5
70964: PUSH
70965: FOR_IN
70966: IFFALSE 71225
// begin if IsInUnit ( j ) then
70968: LD_VAR 0 3
70972: PPUSH
70973: CALL_OW 310
70977: IFFALSE 70988
// ComExitBuilding ( j ) ;
70979: LD_VAR 0 3
70983: PPUSH
70984: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
70988: LD_VAR 0 3
70992: PUSH
70993: LD_EXP 51
70997: PUSH
70998: LD_VAR 0 2
71002: ARRAY
71003: IN
71004: NOT
71005: IFFALSE 71063
// begin SetTag ( j , 101 ) ;
71007: LD_VAR 0 3
71011: PPUSH
71012: LD_INT 101
71014: PPUSH
71015: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
71019: LD_ADDR_EXP 51
71023: PUSH
71024: LD_EXP 51
71028: PPUSH
71029: LD_VAR 0 2
71033: PUSH
71034: LD_EXP 51
71038: PUSH
71039: LD_VAR 0 2
71043: ARRAY
71044: PUSH
71045: LD_INT 1
71047: PLUS
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PPUSH
71053: LD_VAR 0 3
71057: PPUSH
71058: CALL 25025 0 3
71062: ST_TO_ADDR
// end ; wait ( 1 ) ;
71063: LD_INT 1
71065: PPUSH
71066: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
71070: LD_ADDR_VAR 0 7
71074: PUSH
71075: LD_EXP 50
71079: PUSH
71080: LD_VAR 0 2
71084: ARRAY
71085: ST_TO_ADDR
// if mc_scan [ i ] then
71086: LD_EXP 72
71090: PUSH
71091: LD_VAR 0 2
71095: ARRAY
71096: IFFALSE 71158
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
71098: LD_ADDR_VAR 0 7
71102: PUSH
71103: LD_EXP 50
71107: PUSH
71108: LD_VAR 0 2
71112: ARRAY
71113: PPUSH
71114: LD_INT 3
71116: PUSH
71117: LD_INT 30
71119: PUSH
71120: LD_INT 32
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 30
71129: PUSH
71130: LD_INT 33
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PUSH
71137: LD_INT 30
71139: PUSH
71140: LD_INT 31
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: PPUSH
71153: CALL_OW 72
71157: ST_TO_ADDR
// if not to_repair_tmp then
71158: LD_VAR 0 7
71162: NOT
71163: IFFALSE 71167
// continue ;
71165: GO 70965
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
71167: LD_ADDR_VAR 0 8
71171: PUSH
71172: LD_VAR 0 7
71176: PPUSH
71177: LD_VAR 0 3
71181: PPUSH
71182: CALL_OW 74
71186: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
71187: LD_VAR 0 8
71191: PPUSH
71192: LD_INT 16
71194: PPUSH
71195: CALL 27624 0 2
71199: PUSH
71200: LD_INT 4
71202: ARRAY
71203: PUSH
71204: LD_INT 10
71206: LESS
71207: IFFALSE 71223
// ComRepairBuilding ( j , to_repair ) ;
71209: LD_VAR 0 3
71213: PPUSH
71214: LD_VAR 0 8
71218: PPUSH
71219: CALL_OW 130
// end ;
71223: GO 70965
71225: POP
71226: POP
// end ;
71227: GO 70363
71229: POP
71230: POP
// end ;
71231: LD_VAR 0 1
71235: RET
// export function MC_Heal ; var i , j , tmp ; begin
71236: LD_INT 0
71238: PPUSH
71239: PPUSH
71240: PPUSH
71241: PPUSH
// if not mc_bases then
71242: LD_EXP 49
71246: NOT
71247: IFFALSE 71251
// exit ;
71249: GO 71653
// for i = 1 to mc_bases do
71251: LD_ADDR_VAR 0 2
71255: PUSH
71256: DOUBLE
71257: LD_INT 1
71259: DEC
71260: ST_TO_ADDR
71261: LD_EXP 49
71265: PUSH
71266: FOR_TO
71267: IFFALSE 71651
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71269: LD_EXP 52
71273: PUSH
71274: LD_VAR 0 2
71278: ARRAY
71279: PUSH
71280: LD_INT 1
71282: ARRAY
71283: NOT
71284: PUSH
71285: LD_EXP 52
71289: PUSH
71290: LD_VAR 0 2
71294: ARRAY
71295: PUSH
71296: LD_INT 2
71298: ARRAY
71299: NOT
71300: AND
71301: IFFALSE 71339
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71303: LD_ADDR_EXP 53
71307: PUSH
71308: LD_EXP 53
71312: PPUSH
71313: LD_VAR 0 2
71317: PPUSH
71318: EMPTY
71319: PPUSH
71320: CALL_OW 1
71324: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71325: LD_VAR 0 2
71329: PPUSH
71330: LD_INT 102
71332: PPUSH
71333: CALL 65416 0 2
// continue ;
71337: GO 71266
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71339: LD_ADDR_VAR 0 4
71343: PUSH
71344: LD_EXP 49
71348: PUSH
71349: LD_VAR 0 2
71353: ARRAY
71354: PPUSH
71355: LD_INT 25
71357: PUSH
71358: LD_INT 4
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PPUSH
71365: CALL_OW 72
71369: ST_TO_ADDR
// if not tmp then
71370: LD_VAR 0 4
71374: NOT
71375: IFFALSE 71379
// continue ;
71377: GO 71266
// if mc_taming [ i ] then
71379: LD_EXP 80
71383: PUSH
71384: LD_VAR 0 2
71388: ARRAY
71389: IFFALSE 71413
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71391: LD_ADDR_EXP 80
71395: PUSH
71396: LD_EXP 80
71400: PPUSH
71401: LD_VAR 0 2
71405: PPUSH
71406: EMPTY
71407: PPUSH
71408: CALL_OW 1
71412: ST_TO_ADDR
// for j in tmp do
71413: LD_ADDR_VAR 0 3
71417: PUSH
71418: LD_VAR 0 4
71422: PUSH
71423: FOR_IN
71424: IFFALSE 71647
// begin if IsInUnit ( j ) then
71426: LD_VAR 0 3
71430: PPUSH
71431: CALL_OW 310
71435: IFFALSE 71446
// ComExitBuilding ( j ) ;
71437: LD_VAR 0 3
71441: PPUSH
71442: CALL_OW 122
// if not j in mc_healers [ i ] then
71446: LD_VAR 0 3
71450: PUSH
71451: LD_EXP 53
71455: PUSH
71456: LD_VAR 0 2
71460: ARRAY
71461: IN
71462: NOT
71463: IFFALSE 71509
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71465: LD_ADDR_EXP 53
71469: PUSH
71470: LD_EXP 53
71474: PPUSH
71475: LD_VAR 0 2
71479: PUSH
71480: LD_EXP 53
71484: PUSH
71485: LD_VAR 0 2
71489: ARRAY
71490: PUSH
71491: LD_INT 1
71493: PLUS
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PPUSH
71499: LD_VAR 0 3
71503: PPUSH
71504: CALL 25025 0 3
71508: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71509: LD_VAR 0 3
71513: PPUSH
71514: CALL_OW 110
71518: PUSH
71519: LD_INT 102
71521: NONEQUAL
71522: IFFALSE 71536
// SetTag ( j , 102 ) ;
71524: LD_VAR 0 3
71528: PPUSH
71529: LD_INT 102
71531: PPUSH
71532: CALL_OW 109
// Wait ( 3 ) ;
71536: LD_INT 3
71538: PPUSH
71539: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71543: LD_EXP 52
71547: PUSH
71548: LD_VAR 0 2
71552: ARRAY
71553: PUSH
71554: LD_INT 1
71556: ARRAY
71557: IFFALSE 71589
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71559: LD_VAR 0 3
71563: PPUSH
71564: LD_EXP 52
71568: PUSH
71569: LD_VAR 0 2
71573: ARRAY
71574: PUSH
71575: LD_INT 1
71577: ARRAY
71578: PUSH
71579: LD_INT 1
71581: ARRAY
71582: PPUSH
71583: CALL_OW 128
71587: GO 71645
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71589: LD_VAR 0 3
71593: PPUSH
71594: CALL_OW 314
71598: NOT
71599: PUSH
71600: LD_EXP 52
71604: PUSH
71605: LD_VAR 0 2
71609: ARRAY
71610: PUSH
71611: LD_INT 2
71613: ARRAY
71614: AND
71615: IFFALSE 71645
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71617: LD_VAR 0 3
71621: PPUSH
71622: LD_EXP 52
71626: PUSH
71627: LD_VAR 0 2
71631: ARRAY
71632: PUSH
71633: LD_INT 2
71635: ARRAY
71636: PUSH
71637: LD_INT 1
71639: ARRAY
71640: PPUSH
71641: CALL_OW 128
// end ;
71645: GO 71423
71647: POP
71648: POP
// end ;
71649: GO 71266
71651: POP
71652: POP
// end ;
71653: LD_VAR 0 1
71657: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
71658: LD_INT 0
71660: PPUSH
71661: PPUSH
71662: PPUSH
71663: PPUSH
71664: PPUSH
// if not mc_bases then
71665: LD_EXP 49
71669: NOT
71670: IFFALSE 71674
// exit ;
71672: GO 72845
// for i = 1 to mc_bases do
71674: LD_ADDR_VAR 0 2
71678: PUSH
71679: DOUBLE
71680: LD_INT 1
71682: DEC
71683: ST_TO_ADDR
71684: LD_EXP 49
71688: PUSH
71689: FOR_TO
71690: IFFALSE 72843
// begin if mc_scan [ i ] then
71692: LD_EXP 72
71696: PUSH
71697: LD_VAR 0 2
71701: ARRAY
71702: IFFALSE 71706
// continue ;
71704: GO 71689
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71706: LD_EXP 54
71710: PUSH
71711: LD_VAR 0 2
71715: ARRAY
71716: NOT
71717: PUSH
71718: LD_EXP 56
71722: PUSH
71723: LD_VAR 0 2
71727: ARRAY
71728: NOT
71729: AND
71730: PUSH
71731: LD_EXP 55
71735: PUSH
71736: LD_VAR 0 2
71740: ARRAY
71741: AND
71742: IFFALSE 71780
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71744: LD_ADDR_EXP 55
71748: PUSH
71749: LD_EXP 55
71753: PPUSH
71754: LD_VAR 0 2
71758: PPUSH
71759: EMPTY
71760: PPUSH
71761: CALL_OW 1
71765: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71766: LD_VAR 0 2
71770: PPUSH
71771: LD_INT 103
71773: PPUSH
71774: CALL 65416 0 2
// continue ;
71778: GO 71689
// end ; if mc_construct_list [ i ] then
71780: LD_EXP 56
71784: PUSH
71785: LD_VAR 0 2
71789: ARRAY
71790: IFFALSE 72010
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71792: LD_ADDR_VAR 0 4
71796: PUSH
71797: LD_EXP 49
71801: PUSH
71802: LD_VAR 0 2
71806: ARRAY
71807: PPUSH
71808: LD_INT 25
71810: PUSH
71811: LD_INT 2
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: PPUSH
71818: CALL_OW 72
71822: PUSH
71823: LD_EXP 51
71827: PUSH
71828: LD_VAR 0 2
71832: ARRAY
71833: DIFF
71834: ST_TO_ADDR
// if not tmp then
71835: LD_VAR 0 4
71839: NOT
71840: IFFALSE 71844
// continue ;
71842: GO 71689
// for j in tmp do
71844: LD_ADDR_VAR 0 3
71848: PUSH
71849: LD_VAR 0 4
71853: PUSH
71854: FOR_IN
71855: IFFALSE 72006
// begin if not mc_builders [ i ] then
71857: LD_EXP 55
71861: PUSH
71862: LD_VAR 0 2
71866: ARRAY
71867: NOT
71868: IFFALSE 71926
// begin SetTag ( j , 103 ) ;
71870: LD_VAR 0 3
71874: PPUSH
71875: LD_INT 103
71877: PPUSH
71878: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71882: LD_ADDR_EXP 55
71886: PUSH
71887: LD_EXP 55
71891: PPUSH
71892: LD_VAR 0 2
71896: PUSH
71897: LD_EXP 55
71901: PUSH
71902: LD_VAR 0 2
71906: ARRAY
71907: PUSH
71908: LD_INT 1
71910: PLUS
71911: PUSH
71912: EMPTY
71913: LIST
71914: LIST
71915: PPUSH
71916: LD_VAR 0 3
71920: PPUSH
71921: CALL 25025 0 3
71925: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71926: LD_VAR 0 3
71930: PPUSH
71931: CALL_OW 310
71935: IFFALSE 71946
// ComExitBuilding ( j ) ;
71937: LD_VAR 0 3
71941: PPUSH
71942: CALL_OW 122
// wait ( 3 ) ;
71946: LD_INT 3
71948: PPUSH
71949: CALL_OW 67
// if not mc_construct_list [ i ] then
71953: LD_EXP 56
71957: PUSH
71958: LD_VAR 0 2
71962: ARRAY
71963: NOT
71964: IFFALSE 71968
// break ;
71966: GO 72006
// if not HasTask ( j ) then
71968: LD_VAR 0 3
71972: PPUSH
71973: CALL_OW 314
71977: NOT
71978: IFFALSE 72004
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
71980: LD_VAR 0 3
71984: PPUSH
71985: LD_EXP 56
71989: PUSH
71990: LD_VAR 0 2
71994: ARRAY
71995: PUSH
71996: LD_INT 1
71998: ARRAY
71999: PPUSH
72000: CALL 27888 0 2
// end ;
72004: GO 71854
72006: POP
72007: POP
// end else
72008: GO 72841
// if mc_build_list [ i ] then
72010: LD_EXP 54
72014: PUSH
72015: LD_VAR 0 2
72019: ARRAY
72020: IFFALSE 72841
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72022: LD_ADDR_VAR 0 5
72026: PUSH
72027: LD_EXP 49
72031: PUSH
72032: LD_VAR 0 2
72036: ARRAY
72037: PPUSH
72038: LD_INT 2
72040: PUSH
72041: LD_INT 30
72043: PUSH
72044: LD_INT 0
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 30
72053: PUSH
72054: LD_INT 1
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: LIST
72065: PPUSH
72066: CALL_OW 72
72070: ST_TO_ADDR
// if depot then
72071: LD_VAR 0 5
72075: IFFALSE 72093
// depot := depot [ 1 ] else
72077: LD_ADDR_VAR 0 5
72081: PUSH
72082: LD_VAR 0 5
72086: PUSH
72087: LD_INT 1
72089: ARRAY
72090: ST_TO_ADDR
72091: GO 72101
// depot := 0 ;
72093: LD_ADDR_VAR 0 5
72097: PUSH
72098: LD_INT 0
72100: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
72101: LD_EXP 54
72105: PUSH
72106: LD_VAR 0 2
72110: ARRAY
72111: PUSH
72112: LD_INT 1
72114: ARRAY
72115: PUSH
72116: LD_INT 1
72118: ARRAY
72119: PPUSH
72120: CALL 27712 0 1
72124: PUSH
72125: LD_EXP 49
72129: PUSH
72130: LD_VAR 0 2
72134: ARRAY
72135: PPUSH
72136: LD_INT 2
72138: PUSH
72139: LD_INT 30
72141: PUSH
72142: LD_INT 2
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: PUSH
72149: LD_INT 30
72151: PUSH
72152: LD_INT 3
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: LIST
72163: PPUSH
72164: CALL_OW 72
72168: NOT
72169: AND
72170: IFFALSE 72275
// begin for j = 1 to mc_build_list [ i ] do
72172: LD_ADDR_VAR 0 3
72176: PUSH
72177: DOUBLE
72178: LD_INT 1
72180: DEC
72181: ST_TO_ADDR
72182: LD_EXP 54
72186: PUSH
72187: LD_VAR 0 2
72191: ARRAY
72192: PUSH
72193: FOR_TO
72194: IFFALSE 72273
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
72196: LD_EXP 54
72200: PUSH
72201: LD_VAR 0 2
72205: ARRAY
72206: PUSH
72207: LD_VAR 0 3
72211: ARRAY
72212: PUSH
72213: LD_INT 1
72215: ARRAY
72216: PUSH
72217: LD_INT 2
72219: EQUAL
72220: IFFALSE 72271
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72222: LD_ADDR_EXP 54
72226: PUSH
72227: LD_EXP 54
72231: PPUSH
72232: LD_VAR 0 2
72236: PPUSH
72237: LD_EXP 54
72241: PUSH
72242: LD_VAR 0 2
72246: ARRAY
72247: PPUSH
72248: LD_VAR 0 3
72252: PPUSH
72253: LD_INT 1
72255: PPUSH
72256: LD_INT 0
72258: PPUSH
72259: CALL 24443 0 4
72263: PPUSH
72264: CALL_OW 1
72268: ST_TO_ADDR
// break ;
72269: GO 72273
// end ;
72271: GO 72193
72273: POP
72274: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
72275: LD_EXP 54
72279: PUSH
72280: LD_VAR 0 2
72284: ARRAY
72285: PUSH
72286: LD_INT 1
72288: ARRAY
72289: PUSH
72290: LD_INT 1
72292: ARRAY
72293: PUSH
72294: LD_INT 0
72296: EQUAL
72297: PUSH
72298: LD_VAR 0 5
72302: PUSH
72303: LD_VAR 0 5
72307: PPUSH
72308: LD_EXP 54
72312: PUSH
72313: LD_VAR 0 2
72317: ARRAY
72318: PUSH
72319: LD_INT 1
72321: ARRAY
72322: PUSH
72323: LD_INT 1
72325: ARRAY
72326: PPUSH
72327: LD_EXP 54
72331: PUSH
72332: LD_VAR 0 2
72336: ARRAY
72337: PUSH
72338: LD_INT 1
72340: ARRAY
72341: PUSH
72342: LD_INT 2
72344: ARRAY
72345: PPUSH
72346: LD_EXP 54
72350: PUSH
72351: LD_VAR 0 2
72355: ARRAY
72356: PUSH
72357: LD_INT 1
72359: ARRAY
72360: PUSH
72361: LD_INT 3
72363: ARRAY
72364: PPUSH
72365: LD_EXP 54
72369: PUSH
72370: LD_VAR 0 2
72374: ARRAY
72375: PUSH
72376: LD_INT 1
72378: ARRAY
72379: PUSH
72380: LD_INT 4
72382: ARRAY
72383: PPUSH
72384: CALL 33128 0 5
72388: AND
72389: OR
72390: IFFALSE 72671
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72392: LD_ADDR_VAR 0 4
72396: PUSH
72397: LD_EXP 49
72401: PUSH
72402: LD_VAR 0 2
72406: ARRAY
72407: PPUSH
72408: LD_INT 25
72410: PUSH
72411: LD_INT 2
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PPUSH
72418: CALL_OW 72
72422: PUSH
72423: LD_EXP 51
72427: PUSH
72428: LD_VAR 0 2
72432: ARRAY
72433: DIFF
72434: ST_TO_ADDR
// if not tmp then
72435: LD_VAR 0 4
72439: NOT
72440: IFFALSE 72444
// continue ;
72442: GO 71689
// for j in tmp do
72444: LD_ADDR_VAR 0 3
72448: PUSH
72449: LD_VAR 0 4
72453: PUSH
72454: FOR_IN
72455: IFFALSE 72667
// begin if not mc_builders [ i ] then
72457: LD_EXP 55
72461: PUSH
72462: LD_VAR 0 2
72466: ARRAY
72467: NOT
72468: IFFALSE 72526
// begin SetTag ( j , 103 ) ;
72470: LD_VAR 0 3
72474: PPUSH
72475: LD_INT 103
72477: PPUSH
72478: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72482: LD_ADDR_EXP 55
72486: PUSH
72487: LD_EXP 55
72491: PPUSH
72492: LD_VAR 0 2
72496: PUSH
72497: LD_EXP 55
72501: PUSH
72502: LD_VAR 0 2
72506: ARRAY
72507: PUSH
72508: LD_INT 1
72510: PLUS
72511: PUSH
72512: EMPTY
72513: LIST
72514: LIST
72515: PPUSH
72516: LD_VAR 0 3
72520: PPUSH
72521: CALL 25025 0 3
72525: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72526: LD_VAR 0 3
72530: PPUSH
72531: CALL_OW 310
72535: IFFALSE 72546
// ComExitBuilding ( j ) ;
72537: LD_VAR 0 3
72541: PPUSH
72542: CALL_OW 122
// wait ( 3 ) ;
72546: LD_INT 3
72548: PPUSH
72549: CALL_OW 67
// if not mc_build_list [ i ] then
72553: LD_EXP 54
72557: PUSH
72558: LD_VAR 0 2
72562: ARRAY
72563: NOT
72564: IFFALSE 72568
// break ;
72566: GO 72667
// if not HasTask ( j ) then
72568: LD_VAR 0 3
72572: PPUSH
72573: CALL_OW 314
72577: NOT
72578: IFFALSE 72665
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72580: LD_VAR 0 3
72584: PPUSH
72585: LD_EXP 54
72589: PUSH
72590: LD_VAR 0 2
72594: ARRAY
72595: PUSH
72596: LD_INT 1
72598: ARRAY
72599: PUSH
72600: LD_INT 1
72602: ARRAY
72603: PPUSH
72604: LD_EXP 54
72608: PUSH
72609: LD_VAR 0 2
72613: ARRAY
72614: PUSH
72615: LD_INT 1
72617: ARRAY
72618: PUSH
72619: LD_INT 2
72621: ARRAY
72622: PPUSH
72623: LD_EXP 54
72627: PUSH
72628: LD_VAR 0 2
72632: ARRAY
72633: PUSH
72634: LD_INT 1
72636: ARRAY
72637: PUSH
72638: LD_INT 3
72640: ARRAY
72641: PPUSH
72642: LD_EXP 54
72646: PUSH
72647: LD_VAR 0 2
72651: ARRAY
72652: PUSH
72653: LD_INT 1
72655: ARRAY
72656: PUSH
72657: LD_INT 4
72659: ARRAY
72660: PPUSH
72661: CALL_OW 145
// end ;
72665: GO 72454
72667: POP
72668: POP
// end else
72669: GO 72841
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72671: LD_EXP 49
72675: PUSH
72676: LD_VAR 0 2
72680: ARRAY
72681: PPUSH
72682: LD_EXP 54
72686: PUSH
72687: LD_VAR 0 2
72691: ARRAY
72692: PUSH
72693: LD_INT 1
72695: ARRAY
72696: PUSH
72697: LD_INT 1
72699: ARRAY
72700: PPUSH
72701: LD_EXP 54
72705: PUSH
72706: LD_VAR 0 2
72710: ARRAY
72711: PUSH
72712: LD_INT 1
72714: ARRAY
72715: PUSH
72716: LD_INT 2
72718: ARRAY
72719: PPUSH
72720: LD_EXP 54
72724: PUSH
72725: LD_VAR 0 2
72729: ARRAY
72730: PUSH
72731: LD_INT 1
72733: ARRAY
72734: PUSH
72735: LD_INT 3
72737: ARRAY
72738: PPUSH
72739: LD_EXP 54
72743: PUSH
72744: LD_VAR 0 2
72748: ARRAY
72749: PUSH
72750: LD_INT 1
72752: ARRAY
72753: PUSH
72754: LD_INT 4
72756: ARRAY
72757: PPUSH
72758: LD_EXP 49
72762: PUSH
72763: LD_VAR 0 2
72767: ARRAY
72768: PPUSH
72769: LD_INT 21
72771: PUSH
72772: LD_INT 3
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PPUSH
72779: CALL_OW 72
72783: PPUSH
72784: EMPTY
72785: PPUSH
72786: CALL 31878 0 7
72790: NOT
72791: IFFALSE 72841
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
72793: LD_ADDR_EXP 54
72797: PUSH
72798: LD_EXP 54
72802: PPUSH
72803: LD_VAR 0 2
72807: PPUSH
72808: LD_EXP 54
72812: PUSH
72813: LD_VAR 0 2
72817: ARRAY
72818: PPUSH
72819: LD_INT 1
72821: PPUSH
72822: LD_INT 1
72824: NEG
72825: PPUSH
72826: LD_INT 0
72828: PPUSH
72829: CALL 24443 0 4
72833: PPUSH
72834: CALL_OW 1
72838: ST_TO_ADDR
// continue ;
72839: GO 71689
// end ; end ; end ;
72841: GO 71689
72843: POP
72844: POP
// end ;
72845: LD_VAR 0 1
72849: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
72850: LD_INT 0
72852: PPUSH
72853: PPUSH
72854: PPUSH
72855: PPUSH
72856: PPUSH
72857: PPUSH
// if not mc_bases then
72858: LD_EXP 49
72862: NOT
72863: IFFALSE 72867
// exit ;
72865: GO 73294
// for i = 1 to mc_bases do
72867: LD_ADDR_VAR 0 2
72871: PUSH
72872: DOUBLE
72873: LD_INT 1
72875: DEC
72876: ST_TO_ADDR
72877: LD_EXP 49
72881: PUSH
72882: FOR_TO
72883: IFFALSE 73292
// begin tmp := mc_build_upgrade [ i ] ;
72885: LD_ADDR_VAR 0 4
72889: PUSH
72890: LD_EXP 81
72894: PUSH
72895: LD_VAR 0 2
72899: ARRAY
72900: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
72901: LD_ADDR_VAR 0 6
72905: PUSH
72906: LD_EXP 82
72910: PUSH
72911: LD_VAR 0 2
72915: ARRAY
72916: PPUSH
72917: LD_INT 2
72919: PUSH
72920: LD_INT 30
72922: PUSH
72923: LD_INT 6
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 30
72932: PUSH
72933: LD_INT 7
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: LIST
72944: PPUSH
72945: CALL_OW 72
72949: ST_TO_ADDR
// if not tmp and not lab then
72950: LD_VAR 0 4
72954: NOT
72955: PUSH
72956: LD_VAR 0 6
72960: NOT
72961: AND
72962: IFFALSE 72966
// continue ;
72964: GO 72882
// if tmp then
72966: LD_VAR 0 4
72970: IFFALSE 73090
// for j in tmp do
72972: LD_ADDR_VAR 0 3
72976: PUSH
72977: LD_VAR 0 4
72981: PUSH
72982: FOR_IN
72983: IFFALSE 73088
// begin if UpgradeCost ( j ) then
72985: LD_VAR 0 3
72989: PPUSH
72990: CALL 31538 0 1
72994: IFFALSE 73086
// begin ComUpgrade ( j ) ;
72996: LD_VAR 0 3
73000: PPUSH
73001: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
73005: LD_ADDR_EXP 81
73009: PUSH
73010: LD_EXP 81
73014: PPUSH
73015: LD_VAR 0 2
73019: PPUSH
73020: LD_EXP 81
73024: PUSH
73025: LD_VAR 0 2
73029: ARRAY
73030: PUSH
73031: LD_VAR 0 3
73035: DIFF
73036: PPUSH
73037: CALL_OW 1
73041: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73042: LD_ADDR_EXP 56
73046: PUSH
73047: LD_EXP 56
73051: PPUSH
73052: LD_VAR 0 2
73056: PUSH
73057: LD_EXP 56
73061: PUSH
73062: LD_VAR 0 2
73066: ARRAY
73067: PUSH
73068: LD_INT 1
73070: PLUS
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PPUSH
73076: LD_VAR 0 3
73080: PPUSH
73081: CALL 25025 0 3
73085: ST_TO_ADDR
// end ; end ;
73086: GO 72982
73088: POP
73089: POP
// if not lab or not mc_lab_upgrade [ i ] then
73090: LD_VAR 0 6
73094: NOT
73095: PUSH
73096: LD_EXP 83
73100: PUSH
73101: LD_VAR 0 2
73105: ARRAY
73106: NOT
73107: OR
73108: IFFALSE 73112
// continue ;
73110: GO 72882
// for j in lab do
73112: LD_ADDR_VAR 0 3
73116: PUSH
73117: LD_VAR 0 6
73121: PUSH
73122: FOR_IN
73123: IFFALSE 73288
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
73125: LD_VAR 0 3
73129: PPUSH
73130: CALL_OW 266
73134: PUSH
73135: LD_INT 6
73137: PUSH
73138: LD_INT 7
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: IN
73145: PUSH
73146: LD_VAR 0 3
73150: PPUSH
73151: CALL_OW 461
73155: PUSH
73156: LD_INT 1
73158: NONEQUAL
73159: AND
73160: IFFALSE 73286
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
73162: LD_VAR 0 3
73166: PPUSH
73167: LD_EXP 83
73171: PUSH
73172: LD_VAR 0 2
73176: ARRAY
73177: PUSH
73178: LD_INT 1
73180: ARRAY
73181: PPUSH
73182: CALL 31743 0 2
73186: IFFALSE 73286
// begin ComCancel ( j ) ;
73188: LD_VAR 0 3
73192: PPUSH
73193: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73197: LD_VAR 0 3
73201: PPUSH
73202: LD_EXP 83
73206: PUSH
73207: LD_VAR 0 2
73211: ARRAY
73212: PUSH
73213: LD_INT 1
73215: ARRAY
73216: PPUSH
73217: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73221: LD_VAR 0 3
73225: PUSH
73226: LD_EXP 56
73230: PUSH
73231: LD_VAR 0 2
73235: ARRAY
73236: IN
73237: NOT
73238: IFFALSE 73284
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73240: LD_ADDR_EXP 56
73244: PUSH
73245: LD_EXP 56
73249: PPUSH
73250: LD_VAR 0 2
73254: PUSH
73255: LD_EXP 56
73259: PUSH
73260: LD_VAR 0 2
73264: ARRAY
73265: PUSH
73266: LD_INT 1
73268: PLUS
73269: PUSH
73270: EMPTY
73271: LIST
73272: LIST
73273: PPUSH
73274: LD_VAR 0 3
73278: PPUSH
73279: CALL 25025 0 3
73283: ST_TO_ADDR
// break ;
73284: GO 73288
// end ; end ; end ;
73286: GO 73122
73288: POP
73289: POP
// end ;
73290: GO 72882
73292: POP
73293: POP
// end ;
73294: LD_VAR 0 1
73298: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73299: LD_INT 0
73301: PPUSH
73302: PPUSH
73303: PPUSH
73304: PPUSH
73305: PPUSH
73306: PPUSH
73307: PPUSH
73308: PPUSH
73309: PPUSH
// if not mc_bases then
73310: LD_EXP 49
73314: NOT
73315: IFFALSE 73319
// exit ;
73317: GO 73724
// for i = 1 to mc_bases do
73319: LD_ADDR_VAR 0 2
73323: PUSH
73324: DOUBLE
73325: LD_INT 1
73327: DEC
73328: ST_TO_ADDR
73329: LD_EXP 49
73333: PUSH
73334: FOR_TO
73335: IFFALSE 73722
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73337: LD_EXP 57
73341: PUSH
73342: LD_VAR 0 2
73346: ARRAY
73347: NOT
73348: PUSH
73349: LD_EXP 49
73353: PUSH
73354: LD_VAR 0 2
73358: ARRAY
73359: PPUSH
73360: LD_INT 30
73362: PUSH
73363: LD_INT 3
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PPUSH
73370: CALL_OW 72
73374: NOT
73375: OR
73376: IFFALSE 73380
// continue ;
73378: GO 73334
// busy := false ;
73380: LD_ADDR_VAR 0 8
73384: PUSH
73385: LD_INT 0
73387: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73388: LD_ADDR_VAR 0 4
73392: PUSH
73393: LD_EXP 49
73397: PUSH
73398: LD_VAR 0 2
73402: ARRAY
73403: PPUSH
73404: LD_INT 30
73406: PUSH
73407: LD_INT 3
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PPUSH
73414: CALL_OW 72
73418: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73419: LD_ADDR_VAR 0 6
73423: PUSH
73424: LD_EXP 57
73428: PUSH
73429: LD_VAR 0 2
73433: ARRAY
73434: PPUSH
73435: LD_INT 2
73437: PUSH
73438: LD_INT 30
73440: PUSH
73441: LD_INT 32
73443: PUSH
73444: EMPTY
73445: LIST
73446: LIST
73447: PUSH
73448: LD_INT 30
73450: PUSH
73451: LD_INT 33
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: LIST
73462: PPUSH
73463: CALL_OW 72
73467: ST_TO_ADDR
// if not t then
73468: LD_VAR 0 6
73472: NOT
73473: IFFALSE 73477
// continue ;
73475: GO 73334
// for j in tmp do
73477: LD_ADDR_VAR 0 3
73481: PUSH
73482: LD_VAR 0 4
73486: PUSH
73487: FOR_IN
73488: IFFALSE 73518
// if not BuildingStatus ( j ) = bs_idle then
73490: LD_VAR 0 3
73494: PPUSH
73495: CALL_OW 461
73499: PUSH
73500: LD_INT 2
73502: EQUAL
73503: NOT
73504: IFFALSE 73516
// begin busy := true ;
73506: LD_ADDR_VAR 0 8
73510: PUSH
73511: LD_INT 1
73513: ST_TO_ADDR
// break ;
73514: GO 73518
// end ;
73516: GO 73487
73518: POP
73519: POP
// if busy then
73520: LD_VAR 0 8
73524: IFFALSE 73528
// continue ;
73526: GO 73334
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73528: LD_ADDR_VAR 0 7
73532: PUSH
73533: LD_VAR 0 6
73537: PPUSH
73538: LD_INT 35
73540: PUSH
73541: LD_INT 0
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PPUSH
73548: CALL_OW 72
73552: ST_TO_ADDR
// if tw then
73553: LD_VAR 0 7
73557: IFFALSE 73634
// begin tw := tw [ 1 ] ;
73559: LD_ADDR_VAR 0 7
73563: PUSH
73564: LD_VAR 0 7
73568: PUSH
73569: LD_INT 1
73571: ARRAY
73572: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73573: LD_ADDR_VAR 0 9
73577: PUSH
73578: LD_VAR 0 7
73582: PPUSH
73583: LD_EXP 74
73587: PUSH
73588: LD_VAR 0 2
73592: ARRAY
73593: PPUSH
73594: CALL 30035 0 2
73598: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73599: LD_EXP 88
73603: PUSH
73604: LD_VAR 0 2
73608: ARRAY
73609: IFFALSE 73632
// if not weapon in mc_allowed_tower_weapons [ i ] then
73611: LD_VAR 0 9
73615: PUSH
73616: LD_EXP 88
73620: PUSH
73621: LD_VAR 0 2
73625: ARRAY
73626: IN
73627: NOT
73628: IFFALSE 73632
// continue ;
73630: GO 73334
// end else
73632: GO 73697
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73634: LD_ADDR_VAR 0 5
73638: PUSH
73639: LD_EXP 57
73643: PUSH
73644: LD_VAR 0 2
73648: ARRAY
73649: PPUSH
73650: LD_VAR 0 4
73654: PPUSH
73655: CALL 56835 0 2
73659: ST_TO_ADDR
// if not tmp2 then
73660: LD_VAR 0 5
73664: NOT
73665: IFFALSE 73669
// continue ;
73667: GO 73334
// tw := tmp2 [ 1 ] ;
73669: LD_ADDR_VAR 0 7
73673: PUSH
73674: LD_VAR 0 5
73678: PUSH
73679: LD_INT 1
73681: ARRAY
73682: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73683: LD_ADDR_VAR 0 9
73687: PUSH
73688: LD_VAR 0 5
73692: PUSH
73693: LD_INT 2
73695: ARRAY
73696: ST_TO_ADDR
// end ; if not weapon then
73697: LD_VAR 0 9
73701: NOT
73702: IFFALSE 73706
// continue ;
73704: GO 73334
// ComPlaceWeapon ( tw , weapon ) ;
73706: LD_VAR 0 7
73710: PPUSH
73711: LD_VAR 0 9
73715: PPUSH
73716: CALL_OW 148
// end ;
73720: GO 73334
73722: POP
73723: POP
// end ;
73724: LD_VAR 0 1
73728: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73729: LD_INT 0
73731: PPUSH
73732: PPUSH
73733: PPUSH
73734: PPUSH
73735: PPUSH
73736: PPUSH
73737: PPUSH
// if not mc_bases then
73738: LD_EXP 49
73742: NOT
73743: IFFALSE 73747
// exit ;
73745: GO 74515
// for i = 1 to mc_bases do
73747: LD_ADDR_VAR 0 2
73751: PUSH
73752: DOUBLE
73753: LD_INT 1
73755: DEC
73756: ST_TO_ADDR
73757: LD_EXP 49
73761: PUSH
73762: FOR_TO
73763: IFFALSE 74513
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73765: LD_EXP 62
73769: PUSH
73770: LD_VAR 0 2
73774: ARRAY
73775: NOT
73776: PUSH
73777: LD_EXP 62
73781: PUSH
73782: LD_VAR 0 2
73786: ARRAY
73787: PUSH
73788: LD_EXP 63
73792: PUSH
73793: LD_VAR 0 2
73797: ARRAY
73798: EQUAL
73799: OR
73800: PUSH
73801: LD_EXP 72
73805: PUSH
73806: LD_VAR 0 2
73810: ARRAY
73811: OR
73812: IFFALSE 73816
// continue ;
73814: GO 73762
// if mc_miners [ i ] then
73816: LD_EXP 63
73820: PUSH
73821: LD_VAR 0 2
73825: ARRAY
73826: IFFALSE 74200
// begin for j = mc_miners [ i ] downto 1 do
73828: LD_ADDR_VAR 0 3
73832: PUSH
73833: DOUBLE
73834: LD_EXP 63
73838: PUSH
73839: LD_VAR 0 2
73843: ARRAY
73844: INC
73845: ST_TO_ADDR
73846: LD_INT 1
73848: PUSH
73849: FOR_DOWNTO
73850: IFFALSE 74198
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
73852: LD_EXP 63
73856: PUSH
73857: LD_VAR 0 2
73861: ARRAY
73862: PUSH
73863: LD_VAR 0 3
73867: ARRAY
73868: PPUSH
73869: CALL_OW 301
73873: PUSH
73874: LD_EXP 63
73878: PUSH
73879: LD_VAR 0 2
73883: ARRAY
73884: PUSH
73885: LD_VAR 0 3
73889: ARRAY
73890: PPUSH
73891: CALL_OW 257
73895: PUSH
73896: LD_INT 1
73898: NONEQUAL
73899: OR
73900: IFFALSE 73963
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
73902: LD_ADDR_VAR 0 5
73906: PUSH
73907: LD_EXP 63
73911: PUSH
73912: LD_VAR 0 2
73916: ARRAY
73917: PUSH
73918: LD_EXP 63
73922: PUSH
73923: LD_VAR 0 2
73927: ARRAY
73928: PUSH
73929: LD_VAR 0 3
73933: ARRAY
73934: DIFF
73935: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
73936: LD_ADDR_EXP 63
73940: PUSH
73941: LD_EXP 63
73945: PPUSH
73946: LD_VAR 0 2
73950: PPUSH
73951: LD_VAR 0 5
73955: PPUSH
73956: CALL_OW 1
73960: ST_TO_ADDR
// continue ;
73961: GO 73849
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
73963: LD_EXP 63
73967: PUSH
73968: LD_VAR 0 2
73972: ARRAY
73973: PUSH
73974: LD_VAR 0 3
73978: ARRAY
73979: PPUSH
73980: CALL_OW 257
73984: PUSH
73985: LD_INT 1
73987: EQUAL
73988: PUSH
73989: LD_EXP 63
73993: PUSH
73994: LD_VAR 0 2
73998: ARRAY
73999: PUSH
74000: LD_VAR 0 3
74004: ARRAY
74005: PPUSH
74006: CALL_OW 459
74010: NOT
74011: AND
74012: PUSH
74013: LD_EXP 63
74017: PUSH
74018: LD_VAR 0 2
74022: ARRAY
74023: PUSH
74024: LD_VAR 0 3
74028: ARRAY
74029: PPUSH
74030: CALL_OW 314
74034: NOT
74035: AND
74036: IFFALSE 74196
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
74038: LD_EXP 63
74042: PUSH
74043: LD_VAR 0 2
74047: ARRAY
74048: PUSH
74049: LD_VAR 0 3
74053: ARRAY
74054: PPUSH
74055: CALL_OW 310
74059: IFFALSE 74082
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
74061: LD_EXP 63
74065: PUSH
74066: LD_VAR 0 2
74070: ARRAY
74071: PUSH
74072: LD_VAR 0 3
74076: ARRAY
74077: PPUSH
74078: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
74082: LD_EXP 63
74086: PUSH
74087: LD_VAR 0 2
74091: ARRAY
74092: PUSH
74093: LD_VAR 0 3
74097: ARRAY
74098: PPUSH
74099: CALL_OW 314
74103: NOT
74104: IFFALSE 74196
// begin r := rand ( 1 , mc_mines [ i ] ) ;
74106: LD_ADDR_VAR 0 7
74110: PUSH
74111: LD_INT 1
74113: PPUSH
74114: LD_EXP 62
74118: PUSH
74119: LD_VAR 0 2
74123: ARRAY
74124: PPUSH
74125: CALL_OW 12
74129: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
74130: LD_EXP 63
74134: PUSH
74135: LD_VAR 0 2
74139: ARRAY
74140: PUSH
74141: LD_VAR 0 3
74145: ARRAY
74146: PPUSH
74147: LD_EXP 62
74151: PUSH
74152: LD_VAR 0 2
74156: ARRAY
74157: PUSH
74158: LD_VAR 0 7
74162: ARRAY
74163: PUSH
74164: LD_INT 1
74166: ARRAY
74167: PPUSH
74168: LD_EXP 62
74172: PUSH
74173: LD_VAR 0 2
74177: ARRAY
74178: PUSH
74179: LD_VAR 0 7
74183: ARRAY
74184: PUSH
74185: LD_INT 2
74187: ARRAY
74188: PPUSH
74189: LD_INT 0
74191: PPUSH
74192: CALL_OW 193
// end ; end ; end ;
74196: GO 73849
74198: POP
74199: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74200: LD_ADDR_VAR 0 5
74204: PUSH
74205: LD_EXP 49
74209: PUSH
74210: LD_VAR 0 2
74214: ARRAY
74215: PPUSH
74216: LD_INT 2
74218: PUSH
74219: LD_INT 30
74221: PUSH
74222: LD_INT 4
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: LD_INT 30
74231: PUSH
74232: LD_INT 5
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: LD_INT 30
74241: PUSH
74242: LD_INT 32
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: PPUSH
74255: CALL_OW 72
74259: ST_TO_ADDR
// if not tmp then
74260: LD_VAR 0 5
74264: NOT
74265: IFFALSE 74269
// continue ;
74267: GO 73762
// list := [ ] ;
74269: LD_ADDR_VAR 0 6
74273: PUSH
74274: EMPTY
74275: ST_TO_ADDR
// for j in tmp do
74276: LD_ADDR_VAR 0 3
74280: PUSH
74281: LD_VAR 0 5
74285: PUSH
74286: FOR_IN
74287: IFFALSE 74356
// begin for k in UnitsInside ( j ) do
74289: LD_ADDR_VAR 0 4
74293: PUSH
74294: LD_VAR 0 3
74298: PPUSH
74299: CALL_OW 313
74303: PUSH
74304: FOR_IN
74305: IFFALSE 74352
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74307: LD_VAR 0 4
74311: PPUSH
74312: CALL_OW 257
74316: PUSH
74317: LD_INT 1
74319: EQUAL
74320: PUSH
74321: LD_VAR 0 4
74325: PPUSH
74326: CALL_OW 459
74330: NOT
74331: AND
74332: IFFALSE 74350
// list := list ^ k ;
74334: LD_ADDR_VAR 0 6
74338: PUSH
74339: LD_VAR 0 6
74343: PUSH
74344: LD_VAR 0 4
74348: ADD
74349: ST_TO_ADDR
74350: GO 74304
74352: POP
74353: POP
// end ;
74354: GO 74286
74356: POP
74357: POP
// list := list diff mc_miners [ i ] ;
74358: LD_ADDR_VAR 0 6
74362: PUSH
74363: LD_VAR 0 6
74367: PUSH
74368: LD_EXP 63
74372: PUSH
74373: LD_VAR 0 2
74377: ARRAY
74378: DIFF
74379: ST_TO_ADDR
// if not list then
74380: LD_VAR 0 6
74384: NOT
74385: IFFALSE 74389
// continue ;
74387: GO 73762
// k := mc_mines [ i ] - mc_miners [ i ] ;
74389: LD_ADDR_VAR 0 4
74393: PUSH
74394: LD_EXP 62
74398: PUSH
74399: LD_VAR 0 2
74403: ARRAY
74404: PUSH
74405: LD_EXP 63
74409: PUSH
74410: LD_VAR 0 2
74414: ARRAY
74415: MINUS
74416: ST_TO_ADDR
// if k > list then
74417: LD_VAR 0 4
74421: PUSH
74422: LD_VAR 0 6
74426: GREATER
74427: IFFALSE 74439
// k := list ;
74429: LD_ADDR_VAR 0 4
74433: PUSH
74434: LD_VAR 0 6
74438: ST_TO_ADDR
// for j = 1 to k do
74439: LD_ADDR_VAR 0 3
74443: PUSH
74444: DOUBLE
74445: LD_INT 1
74447: DEC
74448: ST_TO_ADDR
74449: LD_VAR 0 4
74453: PUSH
74454: FOR_TO
74455: IFFALSE 74509
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74457: LD_ADDR_EXP 63
74461: PUSH
74462: LD_EXP 63
74466: PPUSH
74467: LD_VAR 0 2
74471: PUSH
74472: LD_EXP 63
74476: PUSH
74477: LD_VAR 0 2
74481: ARRAY
74482: PUSH
74483: LD_INT 1
74485: PLUS
74486: PUSH
74487: EMPTY
74488: LIST
74489: LIST
74490: PPUSH
74491: LD_VAR 0 6
74495: PUSH
74496: LD_VAR 0 3
74500: ARRAY
74501: PPUSH
74502: CALL 25025 0 3
74506: ST_TO_ADDR
74507: GO 74454
74509: POP
74510: POP
// end ;
74511: GO 73762
74513: POP
74514: POP
// end ;
74515: LD_VAR 0 1
74519: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74520: LD_INT 0
74522: PPUSH
74523: PPUSH
74524: PPUSH
74525: PPUSH
74526: PPUSH
74527: PPUSH
74528: PPUSH
74529: PPUSH
74530: PPUSH
74531: PPUSH
74532: PPUSH
// if not mc_bases then
74533: LD_EXP 49
74537: NOT
74538: IFFALSE 74542
// exit ;
74540: GO 76365
// for i = 1 to mc_bases do
74542: LD_ADDR_VAR 0 2
74546: PUSH
74547: DOUBLE
74548: LD_INT 1
74550: DEC
74551: ST_TO_ADDR
74552: LD_EXP 49
74556: PUSH
74557: FOR_TO
74558: IFFALSE 76363
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74560: LD_EXP 49
74564: PUSH
74565: LD_VAR 0 2
74569: ARRAY
74570: NOT
74571: PUSH
74572: LD_EXP 56
74576: PUSH
74577: LD_VAR 0 2
74581: ARRAY
74582: OR
74583: IFFALSE 74587
// continue ;
74585: GO 74557
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74587: LD_EXP 65
74591: PUSH
74592: LD_VAR 0 2
74596: ARRAY
74597: NOT
74598: PUSH
74599: LD_EXP 66
74603: PUSH
74604: LD_VAR 0 2
74608: ARRAY
74609: AND
74610: IFFALSE 74648
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74612: LD_ADDR_EXP 66
74616: PUSH
74617: LD_EXP 66
74621: PPUSH
74622: LD_VAR 0 2
74626: PPUSH
74627: EMPTY
74628: PPUSH
74629: CALL_OW 1
74633: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74634: LD_VAR 0 2
74638: PPUSH
74639: LD_INT 107
74641: PPUSH
74642: CALL 65416 0 2
// continue ;
74646: GO 74557
// end ; target := [ ] ;
74648: LD_ADDR_VAR 0 7
74652: PUSH
74653: EMPTY
74654: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74655: LD_ADDR_VAR 0 6
74659: PUSH
74660: LD_EXP 49
74664: PUSH
74665: LD_VAR 0 2
74669: ARRAY
74670: PUSH
74671: LD_INT 1
74673: ARRAY
74674: PPUSH
74675: CALL_OW 255
74679: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74680: LD_ADDR_VAR 0 9
74684: PUSH
74685: LD_EXP 49
74689: PUSH
74690: LD_VAR 0 2
74694: ARRAY
74695: PPUSH
74696: LD_INT 2
74698: PUSH
74699: LD_INT 30
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 30
74711: PUSH
74712: LD_INT 1
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: LIST
74723: PPUSH
74724: CALL_OW 72
74728: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74729: LD_ADDR_VAR 0 3
74733: PUSH
74734: DOUBLE
74735: LD_EXP 65
74739: PUSH
74740: LD_VAR 0 2
74744: ARRAY
74745: INC
74746: ST_TO_ADDR
74747: LD_INT 1
74749: PUSH
74750: FOR_DOWNTO
74751: IFFALSE 74996
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74753: LD_EXP 65
74757: PUSH
74758: LD_VAR 0 2
74762: ARRAY
74763: PUSH
74764: LD_VAR 0 3
74768: ARRAY
74769: PUSH
74770: LD_INT 2
74772: ARRAY
74773: PPUSH
74774: LD_EXP 65
74778: PUSH
74779: LD_VAR 0 2
74783: ARRAY
74784: PUSH
74785: LD_VAR 0 3
74789: ARRAY
74790: PUSH
74791: LD_INT 3
74793: ARRAY
74794: PPUSH
74795: CALL_OW 488
74799: PUSH
74800: LD_EXP 65
74804: PUSH
74805: LD_VAR 0 2
74809: ARRAY
74810: PUSH
74811: LD_VAR 0 3
74815: ARRAY
74816: PUSH
74817: LD_INT 2
74819: ARRAY
74820: PPUSH
74821: LD_EXP 65
74825: PUSH
74826: LD_VAR 0 2
74830: ARRAY
74831: PUSH
74832: LD_VAR 0 3
74836: ARRAY
74837: PUSH
74838: LD_INT 3
74840: ARRAY
74841: PPUSH
74842: CALL_OW 284
74846: PUSH
74847: LD_INT 0
74849: EQUAL
74850: AND
74851: IFFALSE 74906
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
74853: LD_ADDR_VAR 0 5
74857: PUSH
74858: LD_EXP 65
74862: PUSH
74863: LD_VAR 0 2
74867: ARRAY
74868: PPUSH
74869: LD_VAR 0 3
74873: PPUSH
74874: CALL_OW 3
74878: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
74879: LD_ADDR_EXP 65
74883: PUSH
74884: LD_EXP 65
74888: PPUSH
74889: LD_VAR 0 2
74893: PPUSH
74894: LD_VAR 0 5
74898: PPUSH
74899: CALL_OW 1
74903: ST_TO_ADDR
// continue ;
74904: GO 74750
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
74906: LD_VAR 0 6
74910: PPUSH
74911: LD_EXP 65
74915: PUSH
74916: LD_VAR 0 2
74920: ARRAY
74921: PUSH
74922: LD_VAR 0 3
74926: ARRAY
74927: PUSH
74928: LD_INT 2
74930: ARRAY
74931: PPUSH
74932: LD_EXP 65
74936: PUSH
74937: LD_VAR 0 2
74941: ARRAY
74942: PUSH
74943: LD_VAR 0 3
74947: ARRAY
74948: PUSH
74949: LD_INT 3
74951: ARRAY
74952: PPUSH
74953: LD_INT 30
74955: PPUSH
74956: CALL 25921 0 4
74960: PUSH
74961: LD_INT 4
74963: ARRAY
74964: PUSH
74965: LD_INT 0
74967: EQUAL
74968: IFFALSE 74994
// begin target := mc_crates [ i ] [ j ] ;
74970: LD_ADDR_VAR 0 7
74974: PUSH
74975: LD_EXP 65
74979: PUSH
74980: LD_VAR 0 2
74984: ARRAY
74985: PUSH
74986: LD_VAR 0 3
74990: ARRAY
74991: ST_TO_ADDR
// break ;
74992: GO 74996
// end ; end ;
74994: GO 74750
74996: POP
74997: POP
// if not target then
74998: LD_VAR 0 7
75002: NOT
75003: IFFALSE 75007
// continue ;
75005: GO 74557
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75007: LD_ADDR_VAR 0 8
75011: PUSH
75012: LD_EXP 68
75016: PUSH
75017: LD_VAR 0 2
75021: ARRAY
75022: PPUSH
75023: LD_INT 2
75025: PUSH
75026: LD_INT 3
75028: PUSH
75029: LD_INT 58
75031: PUSH
75032: EMPTY
75033: LIST
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PUSH
75039: LD_INT 61
75041: PUSH
75042: EMPTY
75043: LIST
75044: PUSH
75045: LD_INT 33
75047: PUSH
75048: LD_INT 5
75050: PUSH
75051: EMPTY
75052: LIST
75053: LIST
75054: PUSH
75055: LD_INT 33
75057: PUSH
75058: LD_INT 3
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: LIST
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 2
75074: PUSH
75075: LD_INT 34
75077: PUSH
75078: LD_INT 32
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: LD_INT 34
75087: PUSH
75088: LD_INT 51
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: LD_INT 34
75097: PUSH
75098: LD_INT 12
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PPUSH
75115: CALL_OW 72
75119: ST_TO_ADDR
// if not cargo then
75120: LD_VAR 0 8
75124: NOT
75125: IFFALSE 75831
// begin if mc_crates_collector [ i ] < 5 then
75127: LD_EXP 66
75131: PUSH
75132: LD_VAR 0 2
75136: ARRAY
75137: PUSH
75138: LD_INT 5
75140: LESS
75141: IFFALSE 75507
// begin if mc_ape [ i ] then
75143: LD_EXP 78
75147: PUSH
75148: LD_VAR 0 2
75152: ARRAY
75153: IFFALSE 75200
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75155: LD_ADDR_VAR 0 5
75159: PUSH
75160: LD_EXP 78
75164: PUSH
75165: LD_VAR 0 2
75169: ARRAY
75170: PPUSH
75171: LD_INT 25
75173: PUSH
75174: LD_INT 16
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: LD_INT 24
75183: PUSH
75184: LD_INT 750
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PPUSH
75195: CALL_OW 72
75199: ST_TO_ADDR
// if not tmp then
75200: LD_VAR 0 5
75204: NOT
75205: IFFALSE 75252
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75207: LD_ADDR_VAR 0 5
75211: PUSH
75212: LD_EXP 49
75216: PUSH
75217: LD_VAR 0 2
75221: ARRAY
75222: PPUSH
75223: LD_INT 25
75225: PUSH
75226: LD_INT 2
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 24
75235: PUSH
75236: LD_INT 750
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PPUSH
75247: CALL_OW 72
75251: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75252: LD_EXP 78
75256: PUSH
75257: LD_VAR 0 2
75261: ARRAY
75262: PUSH
75263: LD_EXP 49
75267: PUSH
75268: LD_VAR 0 2
75272: ARRAY
75273: PPUSH
75274: LD_INT 25
75276: PUSH
75277: LD_INT 2
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PUSH
75284: LD_INT 24
75286: PUSH
75287: LD_INT 750
75289: PUSH
75290: EMPTY
75291: LIST
75292: LIST
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PPUSH
75298: CALL_OW 72
75302: AND
75303: PUSH
75304: LD_VAR 0 5
75308: PUSH
75309: LD_INT 5
75311: LESS
75312: AND
75313: IFFALSE 75395
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75315: LD_ADDR_VAR 0 3
75319: PUSH
75320: LD_EXP 49
75324: PUSH
75325: LD_VAR 0 2
75329: ARRAY
75330: PPUSH
75331: LD_INT 25
75333: PUSH
75334: LD_INT 2
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PUSH
75341: LD_INT 24
75343: PUSH
75344: LD_INT 750
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PPUSH
75355: CALL_OW 72
75359: PUSH
75360: FOR_IN
75361: IFFALSE 75393
// begin tmp := tmp union j ;
75363: LD_ADDR_VAR 0 5
75367: PUSH
75368: LD_VAR 0 5
75372: PUSH
75373: LD_VAR 0 3
75377: UNION
75378: ST_TO_ADDR
// if tmp >= 5 then
75379: LD_VAR 0 5
75383: PUSH
75384: LD_INT 5
75386: GREATEREQUAL
75387: IFFALSE 75391
// break ;
75389: GO 75393
// end ;
75391: GO 75360
75393: POP
75394: POP
// end ; if not tmp then
75395: LD_VAR 0 5
75399: NOT
75400: IFFALSE 75404
// continue ;
75402: GO 74557
// for j in tmp do
75404: LD_ADDR_VAR 0 3
75408: PUSH
75409: LD_VAR 0 5
75413: PUSH
75414: FOR_IN
75415: IFFALSE 75505
// if not GetTag ( j ) then
75417: LD_VAR 0 3
75421: PPUSH
75422: CALL_OW 110
75426: NOT
75427: IFFALSE 75503
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75429: LD_ADDR_EXP 66
75433: PUSH
75434: LD_EXP 66
75438: PPUSH
75439: LD_VAR 0 2
75443: PUSH
75444: LD_EXP 66
75448: PUSH
75449: LD_VAR 0 2
75453: ARRAY
75454: PUSH
75455: LD_INT 1
75457: PLUS
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PPUSH
75463: LD_VAR 0 3
75467: PPUSH
75468: CALL 25025 0 3
75472: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75473: LD_VAR 0 3
75477: PPUSH
75478: LD_INT 107
75480: PPUSH
75481: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75485: LD_EXP 66
75489: PUSH
75490: LD_VAR 0 2
75494: ARRAY
75495: PUSH
75496: LD_INT 5
75498: GREATEREQUAL
75499: IFFALSE 75503
// break ;
75501: GO 75505
// end ;
75503: GO 75414
75505: POP
75506: POP
// end ; if mc_crates_collector [ i ] and target then
75507: LD_EXP 66
75511: PUSH
75512: LD_VAR 0 2
75516: ARRAY
75517: PUSH
75518: LD_VAR 0 7
75522: AND
75523: IFFALSE 75829
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75525: LD_EXP 66
75529: PUSH
75530: LD_VAR 0 2
75534: ARRAY
75535: PUSH
75536: LD_VAR 0 7
75540: PUSH
75541: LD_INT 1
75543: ARRAY
75544: LESS
75545: IFFALSE 75565
// tmp := mc_crates_collector [ i ] else
75547: LD_ADDR_VAR 0 5
75551: PUSH
75552: LD_EXP 66
75556: PUSH
75557: LD_VAR 0 2
75561: ARRAY
75562: ST_TO_ADDR
75563: GO 75579
// tmp := target [ 1 ] ;
75565: LD_ADDR_VAR 0 5
75569: PUSH
75570: LD_VAR 0 7
75574: PUSH
75575: LD_INT 1
75577: ARRAY
75578: ST_TO_ADDR
// k := 0 ;
75579: LD_ADDR_VAR 0 4
75583: PUSH
75584: LD_INT 0
75586: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75587: LD_ADDR_VAR 0 3
75591: PUSH
75592: LD_EXP 66
75596: PUSH
75597: LD_VAR 0 2
75601: ARRAY
75602: PUSH
75603: FOR_IN
75604: IFFALSE 75827
// begin k := k + 1 ;
75606: LD_ADDR_VAR 0 4
75610: PUSH
75611: LD_VAR 0 4
75615: PUSH
75616: LD_INT 1
75618: PLUS
75619: ST_TO_ADDR
// if k > tmp then
75620: LD_VAR 0 4
75624: PUSH
75625: LD_VAR 0 5
75629: GREATER
75630: IFFALSE 75634
// break ;
75632: GO 75827
// if not GetClass ( j ) in [ 2 , 16 ] then
75634: LD_VAR 0 3
75638: PPUSH
75639: CALL_OW 257
75643: PUSH
75644: LD_INT 2
75646: PUSH
75647: LD_INT 16
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: IN
75654: NOT
75655: IFFALSE 75708
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75657: LD_ADDR_EXP 66
75661: PUSH
75662: LD_EXP 66
75666: PPUSH
75667: LD_VAR 0 2
75671: PPUSH
75672: LD_EXP 66
75676: PUSH
75677: LD_VAR 0 2
75681: ARRAY
75682: PUSH
75683: LD_VAR 0 3
75687: DIFF
75688: PPUSH
75689: CALL_OW 1
75693: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75694: LD_VAR 0 3
75698: PPUSH
75699: LD_INT 0
75701: PPUSH
75702: CALL_OW 109
// continue ;
75706: GO 75603
// end ; if IsInUnit ( j ) then
75708: LD_VAR 0 3
75712: PPUSH
75713: CALL_OW 310
75717: IFFALSE 75728
// ComExitBuilding ( j ) ;
75719: LD_VAR 0 3
75723: PPUSH
75724: CALL_OW 122
// wait ( 3 ) ;
75728: LD_INT 3
75730: PPUSH
75731: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75735: LD_VAR 0 3
75739: PPUSH
75740: CALL_OW 314
75744: PUSH
75745: LD_VAR 0 6
75749: PPUSH
75750: LD_VAR 0 7
75754: PUSH
75755: LD_INT 2
75757: ARRAY
75758: PPUSH
75759: LD_VAR 0 7
75763: PUSH
75764: LD_INT 3
75766: ARRAY
75767: PPUSH
75768: LD_INT 30
75770: PPUSH
75771: CALL 25921 0 4
75775: PUSH
75776: LD_INT 4
75778: ARRAY
75779: AND
75780: IFFALSE 75798
// ComStandNearbyBuilding ( j , depot ) else
75782: LD_VAR 0 3
75786: PPUSH
75787: LD_VAR 0 9
75791: PPUSH
75792: CALL 21450 0 2
75796: GO 75825
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75798: LD_VAR 0 3
75802: PPUSH
75803: LD_VAR 0 7
75807: PUSH
75808: LD_INT 2
75810: ARRAY
75811: PPUSH
75812: LD_VAR 0 7
75816: PUSH
75817: LD_INT 3
75819: ARRAY
75820: PPUSH
75821: CALL_OW 117
// end ;
75825: GO 75603
75827: POP
75828: POP
// end ; end else
75829: GO 76361
// begin for j in cargo do
75831: LD_ADDR_VAR 0 3
75835: PUSH
75836: LD_VAR 0 8
75840: PUSH
75841: FOR_IN
75842: IFFALSE 76359
// begin if GetTag ( j ) <> 0 then
75844: LD_VAR 0 3
75848: PPUSH
75849: CALL_OW 110
75853: PUSH
75854: LD_INT 0
75856: NONEQUAL
75857: IFFALSE 75861
// continue ;
75859: GO 75841
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
75861: LD_VAR 0 3
75865: PPUSH
75866: CALL_OW 256
75870: PUSH
75871: LD_INT 1000
75873: LESS
75874: PUSH
75875: LD_VAR 0 3
75879: PPUSH
75880: LD_EXP 73
75884: PUSH
75885: LD_VAR 0 2
75889: ARRAY
75890: PPUSH
75891: CALL_OW 308
75895: NOT
75896: AND
75897: IFFALSE 75919
// ComMoveToArea ( j , mc_parking [ i ] ) ;
75899: LD_VAR 0 3
75903: PPUSH
75904: LD_EXP 73
75908: PUSH
75909: LD_VAR 0 2
75913: ARRAY
75914: PPUSH
75915: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
75919: LD_VAR 0 3
75923: PPUSH
75924: CALL_OW 256
75928: PUSH
75929: LD_INT 1000
75931: LESS
75932: PUSH
75933: LD_VAR 0 3
75937: PPUSH
75938: LD_EXP 73
75942: PUSH
75943: LD_VAR 0 2
75947: ARRAY
75948: PPUSH
75949: CALL_OW 308
75953: AND
75954: IFFALSE 75958
// continue ;
75956: GO 75841
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
75958: LD_VAR 0 3
75962: PPUSH
75963: CALL_OW 262
75967: PUSH
75968: LD_INT 2
75970: EQUAL
75971: PUSH
75972: LD_VAR 0 3
75976: PPUSH
75977: CALL_OW 261
75981: PUSH
75982: LD_INT 15
75984: LESS
75985: AND
75986: IFFALSE 75990
// continue ;
75988: GO 75841
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
75990: LD_VAR 0 3
75994: PPUSH
75995: CALL_OW 262
75999: PUSH
76000: LD_INT 1
76002: EQUAL
76003: PUSH
76004: LD_VAR 0 3
76008: PPUSH
76009: CALL_OW 261
76013: PUSH
76014: LD_INT 10
76016: LESS
76017: AND
76018: IFFALSE 76298
// begin if not depot then
76020: LD_VAR 0 9
76024: NOT
76025: IFFALSE 76029
// continue ;
76027: GO 75841
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76029: LD_VAR 0 3
76033: PPUSH
76034: LD_VAR 0 9
76038: PPUSH
76039: LD_VAR 0 3
76043: PPUSH
76044: CALL_OW 74
76048: PPUSH
76049: CALL_OW 296
76053: PUSH
76054: LD_INT 6
76056: LESS
76057: IFFALSE 76073
// SetFuel ( j , 100 ) else
76059: LD_VAR 0 3
76063: PPUSH
76064: LD_INT 100
76066: PPUSH
76067: CALL_OW 240
76071: GO 76298
// if GetFuel ( j ) = 0 then
76073: LD_VAR 0 3
76077: PPUSH
76078: CALL_OW 261
76082: PUSH
76083: LD_INT 0
76085: EQUAL
76086: IFFALSE 76298
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
76088: LD_ADDR_EXP 68
76092: PUSH
76093: LD_EXP 68
76097: PPUSH
76098: LD_VAR 0 2
76102: PPUSH
76103: LD_EXP 68
76107: PUSH
76108: LD_VAR 0 2
76112: ARRAY
76113: PUSH
76114: LD_VAR 0 3
76118: DIFF
76119: PPUSH
76120: CALL_OW 1
76124: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
76125: LD_VAR 0 3
76129: PPUSH
76130: CALL_OW 263
76134: PUSH
76135: LD_INT 1
76137: EQUAL
76138: IFFALSE 76154
// ComExitVehicle ( IsInUnit ( j ) ) ;
76140: LD_VAR 0 3
76144: PPUSH
76145: CALL_OW 310
76149: PPUSH
76150: CALL_OW 121
// if GetControl ( j ) = control_remote then
76154: LD_VAR 0 3
76158: PPUSH
76159: CALL_OW 263
76163: PUSH
76164: LD_INT 2
76166: EQUAL
76167: IFFALSE 76178
// ComUnlink ( j ) ;
76169: LD_VAR 0 3
76173: PPUSH
76174: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76178: LD_ADDR_VAR 0 10
76182: PUSH
76183: LD_VAR 0 2
76187: PPUSH
76188: LD_INT 3
76190: PPUSH
76191: CALL 85937 0 2
76195: ST_TO_ADDR
// if fac then
76196: LD_VAR 0 10
76200: IFFALSE 76296
// begin for k in fac do
76202: LD_ADDR_VAR 0 4
76206: PUSH
76207: LD_VAR 0 10
76211: PUSH
76212: FOR_IN
76213: IFFALSE 76294
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76215: LD_ADDR_VAR 0 11
76219: PUSH
76220: LD_VAR 0 10
76224: PPUSH
76225: LD_VAR 0 3
76229: PPUSH
76230: CALL_OW 265
76234: PPUSH
76235: LD_VAR 0 3
76239: PPUSH
76240: CALL_OW 262
76244: PPUSH
76245: LD_VAR 0 3
76249: PPUSH
76250: CALL_OW 263
76254: PPUSH
76255: LD_VAR 0 3
76259: PPUSH
76260: CALL_OW 264
76264: PPUSH
76265: CALL 22521 0 5
76269: ST_TO_ADDR
// if components then
76270: LD_VAR 0 11
76274: IFFALSE 76292
// begin MC_InsertProduceList ( i , components ) ;
76276: LD_VAR 0 2
76280: PPUSH
76281: LD_VAR 0 11
76285: PPUSH
76286: CALL 85482 0 2
// break ;
76290: GO 76294
// end ; end ;
76292: GO 76212
76294: POP
76295: POP
// end ; continue ;
76296: GO 75841
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76298: LD_VAR 0 3
76302: PPUSH
76303: LD_INT 1
76305: PPUSH
76306: CALL_OW 289
76310: PUSH
76311: LD_INT 100
76313: LESS
76314: PUSH
76315: LD_VAR 0 3
76319: PPUSH
76320: CALL_OW 314
76324: NOT
76325: AND
76326: IFFALSE 76355
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76328: LD_VAR 0 3
76332: PPUSH
76333: LD_VAR 0 7
76337: PUSH
76338: LD_INT 2
76340: ARRAY
76341: PPUSH
76342: LD_VAR 0 7
76346: PUSH
76347: LD_INT 3
76349: ARRAY
76350: PPUSH
76351: CALL_OW 117
// break ;
76355: GO 76359
// end ;
76357: GO 75841
76359: POP
76360: POP
// end ; end ;
76361: GO 74557
76363: POP
76364: POP
// end ;
76365: LD_VAR 0 1
76369: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76370: LD_INT 0
76372: PPUSH
76373: PPUSH
76374: PPUSH
76375: PPUSH
// if not mc_bases then
76376: LD_EXP 49
76380: NOT
76381: IFFALSE 76385
// exit ;
76383: GO 76546
// for i = 1 to mc_bases do
76385: LD_ADDR_VAR 0 2
76389: PUSH
76390: DOUBLE
76391: LD_INT 1
76393: DEC
76394: ST_TO_ADDR
76395: LD_EXP 49
76399: PUSH
76400: FOR_TO
76401: IFFALSE 76544
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76403: LD_ADDR_VAR 0 4
76407: PUSH
76408: LD_EXP 68
76412: PUSH
76413: LD_VAR 0 2
76417: ARRAY
76418: PUSH
76419: LD_EXP 71
76423: PUSH
76424: LD_VAR 0 2
76428: ARRAY
76429: UNION
76430: PPUSH
76431: LD_INT 33
76433: PUSH
76434: LD_INT 2
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PPUSH
76441: CALL_OW 72
76445: ST_TO_ADDR
// if tmp then
76446: LD_VAR 0 4
76450: IFFALSE 76542
// for j in tmp do
76452: LD_ADDR_VAR 0 3
76456: PUSH
76457: LD_VAR 0 4
76461: PUSH
76462: FOR_IN
76463: IFFALSE 76540
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76465: LD_VAR 0 3
76469: PPUSH
76470: CALL_OW 312
76474: NOT
76475: PUSH
76476: LD_VAR 0 3
76480: PPUSH
76481: CALL_OW 256
76485: PUSH
76486: LD_INT 250
76488: GREATEREQUAL
76489: AND
76490: IFFALSE 76503
// Connect ( j ) else
76492: LD_VAR 0 3
76496: PPUSH
76497: CALL 27996 0 1
76501: GO 76538
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76503: LD_VAR 0 3
76507: PPUSH
76508: CALL_OW 256
76512: PUSH
76513: LD_INT 250
76515: LESS
76516: PUSH
76517: LD_VAR 0 3
76521: PPUSH
76522: CALL_OW 312
76526: AND
76527: IFFALSE 76538
// ComUnlink ( j ) ;
76529: LD_VAR 0 3
76533: PPUSH
76534: CALL_OW 136
76538: GO 76462
76540: POP
76541: POP
// end ;
76542: GO 76400
76544: POP
76545: POP
// end ;
76546: LD_VAR 0 1
76550: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76551: LD_INT 0
76553: PPUSH
76554: PPUSH
76555: PPUSH
76556: PPUSH
76557: PPUSH
// if not mc_bases then
76558: LD_EXP 49
76562: NOT
76563: IFFALSE 76567
// exit ;
76565: GO 77012
// for i = 1 to mc_bases do
76567: LD_ADDR_VAR 0 2
76571: PUSH
76572: DOUBLE
76573: LD_INT 1
76575: DEC
76576: ST_TO_ADDR
76577: LD_EXP 49
76581: PUSH
76582: FOR_TO
76583: IFFALSE 77010
// begin if not mc_produce [ i ] then
76585: LD_EXP 70
76589: PUSH
76590: LD_VAR 0 2
76594: ARRAY
76595: NOT
76596: IFFALSE 76600
// continue ;
76598: GO 76582
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76600: LD_ADDR_VAR 0 5
76604: PUSH
76605: LD_EXP 49
76609: PUSH
76610: LD_VAR 0 2
76614: ARRAY
76615: PPUSH
76616: LD_INT 30
76618: PUSH
76619: LD_INT 3
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PPUSH
76626: CALL_OW 72
76630: ST_TO_ADDR
// if not fac then
76631: LD_VAR 0 5
76635: NOT
76636: IFFALSE 76640
// continue ;
76638: GO 76582
// for j in fac do
76640: LD_ADDR_VAR 0 3
76644: PUSH
76645: LD_VAR 0 5
76649: PUSH
76650: FOR_IN
76651: IFFALSE 77006
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76653: LD_VAR 0 3
76657: PPUSH
76658: CALL_OW 461
76662: PUSH
76663: LD_INT 2
76665: NONEQUAL
76666: PUSH
76667: LD_VAR 0 3
76671: PPUSH
76672: LD_INT 15
76674: PPUSH
76675: CALL 27624 0 2
76679: PUSH
76680: LD_INT 4
76682: ARRAY
76683: OR
76684: IFFALSE 76688
// continue ;
76686: GO 76650
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76688: LD_VAR 0 3
76692: PPUSH
76693: LD_EXP 70
76697: PUSH
76698: LD_VAR 0 2
76702: ARRAY
76703: PUSH
76704: LD_INT 1
76706: ARRAY
76707: PUSH
76708: LD_INT 1
76710: ARRAY
76711: PPUSH
76712: LD_EXP 70
76716: PUSH
76717: LD_VAR 0 2
76721: ARRAY
76722: PUSH
76723: LD_INT 1
76725: ARRAY
76726: PUSH
76727: LD_INT 2
76729: ARRAY
76730: PPUSH
76731: LD_EXP 70
76735: PUSH
76736: LD_VAR 0 2
76740: ARRAY
76741: PUSH
76742: LD_INT 1
76744: ARRAY
76745: PUSH
76746: LD_INT 3
76748: ARRAY
76749: PPUSH
76750: LD_EXP 70
76754: PUSH
76755: LD_VAR 0 2
76759: ARRAY
76760: PUSH
76761: LD_INT 1
76763: ARRAY
76764: PUSH
76765: LD_INT 4
76767: ARRAY
76768: PPUSH
76769: CALL_OW 448
76773: PUSH
76774: LD_VAR 0 3
76778: PPUSH
76779: LD_EXP 70
76783: PUSH
76784: LD_VAR 0 2
76788: ARRAY
76789: PUSH
76790: LD_INT 1
76792: ARRAY
76793: PUSH
76794: LD_INT 1
76796: ARRAY
76797: PUSH
76798: LD_EXP 70
76802: PUSH
76803: LD_VAR 0 2
76807: ARRAY
76808: PUSH
76809: LD_INT 1
76811: ARRAY
76812: PUSH
76813: LD_INT 2
76815: ARRAY
76816: PUSH
76817: LD_EXP 70
76821: PUSH
76822: LD_VAR 0 2
76826: ARRAY
76827: PUSH
76828: LD_INT 1
76830: ARRAY
76831: PUSH
76832: LD_INT 3
76834: ARRAY
76835: PUSH
76836: LD_EXP 70
76840: PUSH
76841: LD_VAR 0 2
76845: ARRAY
76846: PUSH
76847: LD_INT 1
76849: ARRAY
76850: PUSH
76851: LD_INT 4
76853: ARRAY
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: LIST
76859: LIST
76860: PPUSH
76861: CALL 31391 0 2
76865: AND
76866: IFFALSE 77004
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
76868: LD_VAR 0 3
76872: PPUSH
76873: LD_EXP 70
76877: PUSH
76878: LD_VAR 0 2
76882: ARRAY
76883: PUSH
76884: LD_INT 1
76886: ARRAY
76887: PUSH
76888: LD_INT 1
76890: ARRAY
76891: PPUSH
76892: LD_EXP 70
76896: PUSH
76897: LD_VAR 0 2
76901: ARRAY
76902: PUSH
76903: LD_INT 1
76905: ARRAY
76906: PUSH
76907: LD_INT 2
76909: ARRAY
76910: PPUSH
76911: LD_EXP 70
76915: PUSH
76916: LD_VAR 0 2
76920: ARRAY
76921: PUSH
76922: LD_INT 1
76924: ARRAY
76925: PUSH
76926: LD_INT 3
76928: ARRAY
76929: PPUSH
76930: LD_EXP 70
76934: PUSH
76935: LD_VAR 0 2
76939: ARRAY
76940: PUSH
76941: LD_INT 1
76943: ARRAY
76944: PUSH
76945: LD_INT 4
76947: ARRAY
76948: PPUSH
76949: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
76953: LD_ADDR_VAR 0 4
76957: PUSH
76958: LD_EXP 70
76962: PUSH
76963: LD_VAR 0 2
76967: ARRAY
76968: PPUSH
76969: LD_INT 1
76971: PPUSH
76972: CALL_OW 3
76976: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
76977: LD_ADDR_EXP 70
76981: PUSH
76982: LD_EXP 70
76986: PPUSH
76987: LD_VAR 0 2
76991: PPUSH
76992: LD_VAR 0 4
76996: PPUSH
76997: CALL_OW 1
77001: ST_TO_ADDR
// break ;
77002: GO 77006
// end ; end ;
77004: GO 76650
77006: POP
77007: POP
// end ;
77008: GO 76582
77010: POP
77011: POP
// end ;
77012: LD_VAR 0 1
77016: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77017: LD_INT 0
77019: PPUSH
77020: PPUSH
77021: PPUSH
// if not mc_bases then
77022: LD_EXP 49
77026: NOT
77027: IFFALSE 77031
// exit ;
77029: GO 77120
// for i = 1 to mc_bases do
77031: LD_ADDR_VAR 0 2
77035: PUSH
77036: DOUBLE
77037: LD_INT 1
77039: DEC
77040: ST_TO_ADDR
77041: LD_EXP 49
77045: PUSH
77046: FOR_TO
77047: IFFALSE 77118
// begin if mc_attack [ i ] then
77049: LD_EXP 69
77053: PUSH
77054: LD_VAR 0 2
77058: ARRAY
77059: IFFALSE 77116
// begin tmp := mc_attack [ i ] [ 1 ] ;
77061: LD_ADDR_VAR 0 3
77065: PUSH
77066: LD_EXP 69
77070: PUSH
77071: LD_VAR 0 2
77075: ARRAY
77076: PUSH
77077: LD_INT 1
77079: ARRAY
77080: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
77081: LD_ADDR_EXP 69
77085: PUSH
77086: LD_EXP 69
77090: PPUSH
77091: LD_VAR 0 2
77095: PPUSH
77096: EMPTY
77097: PPUSH
77098: CALL_OW 1
77102: ST_TO_ADDR
// Attack ( tmp ) ;
77103: LD_VAR 0 3
77107: PPUSH
77108: CALL 111850 0 1
// exit ;
77112: POP
77113: POP
77114: GO 77120
// end ; end ;
77116: GO 77046
77118: POP
77119: POP
// end ;
77120: LD_VAR 0 1
77124: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77125: LD_INT 0
77127: PPUSH
77128: PPUSH
77129: PPUSH
77130: PPUSH
77131: PPUSH
77132: PPUSH
77133: PPUSH
// if not mc_bases then
77134: LD_EXP 49
77138: NOT
77139: IFFALSE 77143
// exit ;
77141: GO 78000
// for i = 1 to mc_bases do
77143: LD_ADDR_VAR 0 2
77147: PUSH
77148: DOUBLE
77149: LD_INT 1
77151: DEC
77152: ST_TO_ADDR
77153: LD_EXP 49
77157: PUSH
77158: FOR_TO
77159: IFFALSE 77998
// begin if not mc_bases [ i ] then
77161: LD_EXP 49
77165: PUSH
77166: LD_VAR 0 2
77170: ARRAY
77171: NOT
77172: IFFALSE 77176
// continue ;
77174: GO 77158
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77176: LD_ADDR_VAR 0 7
77180: PUSH
77181: LD_EXP 49
77185: PUSH
77186: LD_VAR 0 2
77190: ARRAY
77191: PUSH
77192: LD_INT 1
77194: ARRAY
77195: PPUSH
77196: CALL 21672 0 1
77200: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77201: LD_ADDR_EXP 72
77205: PUSH
77206: LD_EXP 72
77210: PPUSH
77211: LD_VAR 0 2
77215: PPUSH
77216: LD_EXP 49
77220: PUSH
77221: LD_VAR 0 2
77225: ARRAY
77226: PUSH
77227: LD_INT 1
77229: ARRAY
77230: PPUSH
77231: CALL_OW 255
77235: PPUSH
77236: LD_EXP 74
77240: PUSH
77241: LD_VAR 0 2
77245: ARRAY
77246: PPUSH
77247: CALL 21637 0 2
77251: PPUSH
77252: CALL_OW 1
77256: ST_TO_ADDR
// if not mc_scan [ i ] then
77257: LD_EXP 72
77261: PUSH
77262: LD_VAR 0 2
77266: ARRAY
77267: NOT
77268: IFFALSE 77446
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77270: LD_ADDR_EXP 92
77274: PUSH
77275: LD_EXP 92
77279: PPUSH
77280: LD_VAR 0 2
77284: PPUSH
77285: LD_INT 0
77287: PPUSH
77288: CALL_OW 1
77292: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77293: LD_ADDR_VAR 0 4
77297: PUSH
77298: LD_EXP 49
77302: PUSH
77303: LD_VAR 0 2
77307: ARRAY
77308: PPUSH
77309: LD_INT 2
77311: PUSH
77312: LD_INT 25
77314: PUSH
77315: LD_INT 5
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: PUSH
77322: LD_INT 25
77324: PUSH
77325: LD_INT 8
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: LD_INT 25
77334: PUSH
77335: LD_INT 9
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: LIST
77346: LIST
77347: PPUSH
77348: CALL_OW 72
77352: ST_TO_ADDR
// if not tmp then
77353: LD_VAR 0 4
77357: NOT
77358: IFFALSE 77362
// continue ;
77360: GO 77158
// for j in tmp do
77362: LD_ADDR_VAR 0 3
77366: PUSH
77367: LD_VAR 0 4
77371: PUSH
77372: FOR_IN
77373: IFFALSE 77444
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77375: LD_VAR 0 3
77379: PPUSH
77380: CALL_OW 310
77384: PPUSH
77385: CALL_OW 266
77389: PUSH
77390: LD_INT 5
77392: EQUAL
77393: PUSH
77394: LD_VAR 0 3
77398: PPUSH
77399: CALL_OW 257
77403: PUSH
77404: LD_INT 1
77406: EQUAL
77407: AND
77408: PUSH
77409: LD_VAR 0 3
77413: PPUSH
77414: CALL_OW 459
77418: NOT
77419: AND
77420: PUSH
77421: LD_VAR 0 7
77425: AND
77426: IFFALSE 77442
// ComChangeProfession ( j , class ) ;
77428: LD_VAR 0 3
77432: PPUSH
77433: LD_VAR 0 7
77437: PPUSH
77438: CALL_OW 123
77442: GO 77372
77444: POP
77445: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77446: LD_EXP 72
77450: PUSH
77451: LD_VAR 0 2
77455: ARRAY
77456: PUSH
77457: LD_EXP 92
77461: PUSH
77462: LD_VAR 0 2
77466: ARRAY
77467: NOT
77468: AND
77469: PUSH
77470: LD_EXP 71
77474: PUSH
77475: LD_VAR 0 2
77479: ARRAY
77480: NOT
77481: AND
77482: PUSH
77483: LD_EXP 49
77487: PUSH
77488: LD_VAR 0 2
77492: ARRAY
77493: PPUSH
77494: LD_INT 50
77496: PUSH
77497: EMPTY
77498: LIST
77499: PUSH
77500: LD_INT 2
77502: PUSH
77503: LD_INT 30
77505: PUSH
77506: LD_INT 32
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 30
77515: PUSH
77516: LD_INT 33
77518: PUSH
77519: EMPTY
77520: LIST
77521: LIST
77522: PUSH
77523: LD_INT 30
77525: PUSH
77526: LD_INT 4
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: LD_INT 30
77535: PUSH
77536: LD_INT 5
77538: PUSH
77539: EMPTY
77540: LIST
77541: LIST
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: LIST
77547: LIST
77548: LIST
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PPUSH
77554: CALL_OW 72
77558: PUSH
77559: LD_INT 4
77561: LESS
77562: PUSH
77563: LD_EXP 49
77567: PUSH
77568: LD_VAR 0 2
77572: ARRAY
77573: PPUSH
77574: LD_INT 3
77576: PUSH
77577: LD_INT 24
77579: PUSH
77580: LD_INT 1000
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: EMPTY
77588: LIST
77589: LIST
77590: PUSH
77591: LD_INT 2
77593: PUSH
77594: LD_INT 30
77596: PUSH
77597: LD_INT 0
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 30
77606: PUSH
77607: LD_INT 1
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: LIST
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PPUSH
77623: CALL_OW 72
77627: OR
77628: AND
77629: IFFALSE 77880
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77631: LD_ADDR_EXP 92
77635: PUSH
77636: LD_EXP 92
77640: PPUSH
77641: LD_VAR 0 2
77645: PPUSH
77646: LD_INT 1
77648: PPUSH
77649: CALL_OW 1
77653: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77654: LD_ADDR_VAR 0 4
77658: PUSH
77659: LD_EXP 49
77663: PUSH
77664: LD_VAR 0 2
77668: ARRAY
77669: PPUSH
77670: LD_INT 2
77672: PUSH
77673: LD_INT 25
77675: PUSH
77676: LD_INT 1
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 25
77685: PUSH
77686: LD_INT 5
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 25
77695: PUSH
77696: LD_INT 8
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: LD_INT 25
77705: PUSH
77706: LD_INT 9
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: PPUSH
77720: CALL_OW 72
77724: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77725: LD_ADDR_VAR 0 4
77729: PUSH
77730: LD_VAR 0 4
77734: PUSH
77735: LD_VAR 0 4
77739: PPUSH
77740: LD_INT 18
77742: PPUSH
77743: CALL 54861 0 2
77747: DIFF
77748: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77749: LD_VAR 0 4
77753: NOT
77754: PUSH
77755: LD_EXP 49
77759: PUSH
77760: LD_VAR 0 2
77764: ARRAY
77765: PPUSH
77766: LD_INT 2
77768: PUSH
77769: LD_INT 30
77771: PUSH
77772: LD_INT 4
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 30
77781: PUSH
77782: LD_INT 5
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: LIST
77793: PPUSH
77794: CALL_OW 72
77798: NOT
77799: AND
77800: IFFALSE 77862
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
77802: LD_ADDR_VAR 0 4
77806: PUSH
77807: LD_EXP 49
77811: PUSH
77812: LD_VAR 0 2
77816: ARRAY
77817: PPUSH
77818: LD_INT 2
77820: PUSH
77821: LD_INT 25
77823: PUSH
77824: LD_INT 2
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 25
77833: PUSH
77834: LD_INT 3
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 25
77843: PUSH
77844: LD_INT 4
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: LIST
77855: LIST
77856: PPUSH
77857: CALL_OW 72
77861: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
77862: LD_VAR 0 2
77866: PPUSH
77867: LD_VAR 0 4
77871: PPUSH
77872: CALL 116559 0 2
// exit ;
77876: POP
77877: POP
77878: GO 78000
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
77880: LD_EXP 72
77884: PUSH
77885: LD_VAR 0 2
77889: ARRAY
77890: PUSH
77891: LD_EXP 92
77895: PUSH
77896: LD_VAR 0 2
77900: ARRAY
77901: NOT
77902: AND
77903: PUSH
77904: LD_EXP 71
77908: PUSH
77909: LD_VAR 0 2
77913: ARRAY
77914: AND
77915: IFFALSE 77996
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77917: LD_ADDR_EXP 92
77921: PUSH
77922: LD_EXP 92
77926: PPUSH
77927: LD_VAR 0 2
77931: PPUSH
77932: LD_INT 1
77934: PPUSH
77935: CALL_OW 1
77939: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
77940: LD_ADDR_VAR 0 4
77944: PUSH
77945: LD_EXP 71
77949: PUSH
77950: LD_VAR 0 2
77954: ARRAY
77955: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
77956: LD_ADDR_EXP 71
77960: PUSH
77961: LD_EXP 71
77965: PPUSH
77966: LD_VAR 0 2
77970: PPUSH
77971: EMPTY
77972: PPUSH
77973: CALL_OW 1
77977: ST_TO_ADDR
// Defend ( i , tmp ) ;
77978: LD_VAR 0 2
77982: PPUSH
77983: LD_VAR 0 4
77987: PPUSH
77988: CALL 117155 0 2
// exit ;
77992: POP
77993: POP
77994: GO 78000
// end ; end ;
77996: GO 77158
77998: POP
77999: POP
// end ;
78000: LD_VAR 0 1
78004: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78005: LD_INT 0
78007: PPUSH
78008: PPUSH
78009: PPUSH
78010: PPUSH
78011: PPUSH
78012: PPUSH
78013: PPUSH
78014: PPUSH
78015: PPUSH
78016: PPUSH
78017: PPUSH
// if not mc_bases then
78018: LD_EXP 49
78022: NOT
78023: IFFALSE 78027
// exit ;
78025: GO 79114
// for i = 1 to mc_bases do
78027: LD_ADDR_VAR 0 2
78031: PUSH
78032: DOUBLE
78033: LD_INT 1
78035: DEC
78036: ST_TO_ADDR
78037: LD_EXP 49
78041: PUSH
78042: FOR_TO
78043: IFFALSE 79112
// begin tmp := mc_lab [ i ] ;
78045: LD_ADDR_VAR 0 6
78049: PUSH
78050: LD_EXP 82
78054: PUSH
78055: LD_VAR 0 2
78059: ARRAY
78060: ST_TO_ADDR
// if not tmp then
78061: LD_VAR 0 6
78065: NOT
78066: IFFALSE 78070
// continue ;
78068: GO 78042
// idle_lab := 0 ;
78070: LD_ADDR_VAR 0 11
78074: PUSH
78075: LD_INT 0
78077: ST_TO_ADDR
// for j in tmp do
78078: LD_ADDR_VAR 0 3
78082: PUSH
78083: LD_VAR 0 6
78087: PUSH
78088: FOR_IN
78089: IFFALSE 79108
// begin researching := false ;
78091: LD_ADDR_VAR 0 10
78095: PUSH
78096: LD_INT 0
78098: ST_TO_ADDR
// side := GetSide ( j ) ;
78099: LD_ADDR_VAR 0 4
78103: PUSH
78104: LD_VAR 0 3
78108: PPUSH
78109: CALL_OW 255
78113: ST_TO_ADDR
// if not mc_tech [ side ] then
78114: LD_EXP 76
78118: PUSH
78119: LD_VAR 0 4
78123: ARRAY
78124: NOT
78125: IFFALSE 78129
// continue ;
78127: GO 78088
// if BuildingStatus ( j ) = bs_idle then
78129: LD_VAR 0 3
78133: PPUSH
78134: CALL_OW 461
78138: PUSH
78139: LD_INT 2
78141: EQUAL
78142: IFFALSE 78330
// begin if idle_lab and UnitsInside ( j ) < 6 then
78144: LD_VAR 0 11
78148: PUSH
78149: LD_VAR 0 3
78153: PPUSH
78154: CALL_OW 313
78158: PUSH
78159: LD_INT 6
78161: LESS
78162: AND
78163: IFFALSE 78234
// begin tmp2 := UnitsInside ( idle_lab ) ;
78165: LD_ADDR_VAR 0 9
78169: PUSH
78170: LD_VAR 0 11
78174: PPUSH
78175: CALL_OW 313
78179: ST_TO_ADDR
// if tmp2 then
78180: LD_VAR 0 9
78184: IFFALSE 78226
// for x in tmp2 do
78186: LD_ADDR_VAR 0 7
78190: PUSH
78191: LD_VAR 0 9
78195: PUSH
78196: FOR_IN
78197: IFFALSE 78224
// begin ComExitBuilding ( x ) ;
78199: LD_VAR 0 7
78203: PPUSH
78204: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78208: LD_VAR 0 7
78212: PPUSH
78213: LD_VAR 0 3
78217: PPUSH
78218: CALL_OW 180
// end ;
78222: GO 78196
78224: POP
78225: POP
// idle_lab := 0 ;
78226: LD_ADDR_VAR 0 11
78230: PUSH
78231: LD_INT 0
78233: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78234: LD_ADDR_VAR 0 5
78238: PUSH
78239: LD_EXP 76
78243: PUSH
78244: LD_VAR 0 4
78248: ARRAY
78249: PUSH
78250: FOR_IN
78251: IFFALSE 78311
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78253: LD_VAR 0 3
78257: PPUSH
78258: LD_VAR 0 5
78262: PPUSH
78263: CALL_OW 430
78267: PUSH
78268: LD_VAR 0 4
78272: PPUSH
78273: LD_VAR 0 5
78277: PPUSH
78278: CALL 20742 0 2
78282: AND
78283: IFFALSE 78309
// begin researching := true ;
78285: LD_ADDR_VAR 0 10
78289: PUSH
78290: LD_INT 1
78292: ST_TO_ADDR
// ComResearch ( j , t ) ;
78293: LD_VAR 0 3
78297: PPUSH
78298: LD_VAR 0 5
78302: PPUSH
78303: CALL_OW 124
// break ;
78307: GO 78311
// end ;
78309: GO 78250
78311: POP
78312: POP
// if not researching then
78313: LD_VAR 0 10
78317: NOT
78318: IFFALSE 78330
// idle_lab := j ;
78320: LD_ADDR_VAR 0 11
78324: PUSH
78325: LD_VAR 0 3
78329: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78330: LD_VAR 0 3
78334: PPUSH
78335: CALL_OW 461
78339: PUSH
78340: LD_INT 10
78342: EQUAL
78343: IFFALSE 78931
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78345: LD_EXP 78
78349: PUSH
78350: LD_VAR 0 2
78354: ARRAY
78355: NOT
78356: PUSH
78357: LD_EXP 79
78361: PUSH
78362: LD_VAR 0 2
78366: ARRAY
78367: NOT
78368: AND
78369: PUSH
78370: LD_EXP 76
78374: PUSH
78375: LD_VAR 0 4
78379: ARRAY
78380: PUSH
78381: LD_INT 1
78383: GREATER
78384: AND
78385: IFFALSE 78516
// begin ComCancel ( j ) ;
78387: LD_VAR 0 3
78391: PPUSH
78392: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78396: LD_ADDR_EXP 76
78400: PUSH
78401: LD_EXP 76
78405: PPUSH
78406: LD_VAR 0 4
78410: PPUSH
78411: LD_EXP 76
78415: PUSH
78416: LD_VAR 0 4
78420: ARRAY
78421: PPUSH
78422: LD_EXP 76
78426: PUSH
78427: LD_VAR 0 4
78431: ARRAY
78432: PUSH
78433: LD_INT 1
78435: MINUS
78436: PPUSH
78437: LD_EXP 76
78441: PUSH
78442: LD_VAR 0 4
78446: ARRAY
78447: PPUSH
78448: LD_INT 0
78450: PPUSH
78451: CALL 24443 0 4
78455: PPUSH
78456: CALL_OW 1
78460: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78461: LD_ADDR_EXP 76
78465: PUSH
78466: LD_EXP 76
78470: PPUSH
78471: LD_VAR 0 4
78475: PPUSH
78476: LD_EXP 76
78480: PUSH
78481: LD_VAR 0 4
78485: ARRAY
78486: PPUSH
78487: LD_EXP 76
78491: PUSH
78492: LD_VAR 0 4
78496: ARRAY
78497: PPUSH
78498: LD_INT 1
78500: PPUSH
78501: LD_INT 0
78503: PPUSH
78504: CALL 24443 0 4
78508: PPUSH
78509: CALL_OW 1
78513: ST_TO_ADDR
// continue ;
78514: GO 78088
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78516: LD_EXP 78
78520: PUSH
78521: LD_VAR 0 2
78525: ARRAY
78526: PUSH
78527: LD_EXP 79
78531: PUSH
78532: LD_VAR 0 2
78536: ARRAY
78537: NOT
78538: AND
78539: IFFALSE 78666
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78541: LD_ADDR_EXP 79
78545: PUSH
78546: LD_EXP 79
78550: PPUSH
78551: LD_VAR 0 2
78555: PUSH
78556: LD_EXP 79
78560: PUSH
78561: LD_VAR 0 2
78565: ARRAY
78566: PUSH
78567: LD_INT 1
78569: PLUS
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PPUSH
78575: LD_EXP 78
78579: PUSH
78580: LD_VAR 0 2
78584: ARRAY
78585: PUSH
78586: LD_INT 1
78588: ARRAY
78589: PPUSH
78590: CALL 25025 0 3
78594: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78595: LD_EXP 78
78599: PUSH
78600: LD_VAR 0 2
78604: ARRAY
78605: PUSH
78606: LD_INT 1
78608: ARRAY
78609: PPUSH
78610: LD_INT 112
78612: PPUSH
78613: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78617: LD_ADDR_VAR 0 9
78621: PUSH
78622: LD_EXP 78
78626: PUSH
78627: LD_VAR 0 2
78631: ARRAY
78632: PPUSH
78633: LD_INT 1
78635: PPUSH
78636: CALL_OW 3
78640: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78641: LD_ADDR_EXP 78
78645: PUSH
78646: LD_EXP 78
78650: PPUSH
78651: LD_VAR 0 2
78655: PPUSH
78656: LD_VAR 0 9
78660: PPUSH
78661: CALL_OW 1
78665: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78666: LD_EXP 78
78670: PUSH
78671: LD_VAR 0 2
78675: ARRAY
78676: PUSH
78677: LD_EXP 79
78681: PUSH
78682: LD_VAR 0 2
78686: ARRAY
78687: AND
78688: PUSH
78689: LD_EXP 79
78693: PUSH
78694: LD_VAR 0 2
78698: ARRAY
78699: PUSH
78700: LD_INT 1
78702: ARRAY
78703: PPUSH
78704: CALL_OW 310
78708: NOT
78709: AND
78710: PUSH
78711: LD_VAR 0 3
78715: PPUSH
78716: CALL_OW 313
78720: PUSH
78721: LD_INT 6
78723: EQUAL
78724: AND
78725: IFFALSE 78781
// begin tmp2 := UnitsInside ( j ) ;
78727: LD_ADDR_VAR 0 9
78731: PUSH
78732: LD_VAR 0 3
78736: PPUSH
78737: CALL_OW 313
78741: ST_TO_ADDR
// if tmp2 = 6 then
78742: LD_VAR 0 9
78746: PUSH
78747: LD_INT 6
78749: EQUAL
78750: IFFALSE 78781
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78752: LD_VAR 0 9
78756: PUSH
78757: LD_INT 1
78759: ARRAY
78760: PPUSH
78761: LD_INT 112
78763: PPUSH
78764: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78768: LD_VAR 0 9
78772: PUSH
78773: LD_INT 1
78775: ARRAY
78776: PPUSH
78777: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78781: LD_EXP 79
78785: PUSH
78786: LD_VAR 0 2
78790: ARRAY
78791: PUSH
78792: LD_EXP 79
78796: PUSH
78797: LD_VAR 0 2
78801: ARRAY
78802: PUSH
78803: LD_INT 1
78805: ARRAY
78806: PPUSH
78807: CALL_OW 314
78811: NOT
78812: AND
78813: PUSH
78814: LD_EXP 79
78818: PUSH
78819: LD_VAR 0 2
78823: ARRAY
78824: PUSH
78825: LD_INT 1
78827: ARRAY
78828: PPUSH
78829: CALL_OW 310
78833: NOT
78834: AND
78835: IFFALSE 78861
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78837: LD_EXP 79
78841: PUSH
78842: LD_VAR 0 2
78846: ARRAY
78847: PUSH
78848: LD_INT 1
78850: ARRAY
78851: PPUSH
78852: LD_VAR 0 3
78856: PPUSH
78857: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78861: LD_EXP 79
78865: PUSH
78866: LD_VAR 0 2
78870: ARRAY
78871: PUSH
78872: LD_INT 1
78874: ARRAY
78875: PPUSH
78876: CALL_OW 310
78880: PUSH
78881: LD_EXP 79
78885: PUSH
78886: LD_VAR 0 2
78890: ARRAY
78891: PUSH
78892: LD_INT 1
78894: ARRAY
78895: PPUSH
78896: CALL_OW 310
78900: PPUSH
78901: CALL_OW 461
78905: PUSH
78906: LD_INT 3
78908: NONEQUAL
78909: AND
78910: IFFALSE 78931
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78912: LD_EXP 79
78916: PUSH
78917: LD_VAR 0 2
78921: ARRAY
78922: PUSH
78923: LD_INT 1
78925: ARRAY
78926: PPUSH
78927: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
78931: LD_VAR 0 3
78935: PPUSH
78936: CALL_OW 461
78940: PUSH
78941: LD_INT 6
78943: EQUAL
78944: PUSH
78945: LD_VAR 0 6
78949: PUSH
78950: LD_INT 1
78952: GREATER
78953: AND
78954: IFFALSE 79106
// begin sci := [ ] ;
78956: LD_ADDR_VAR 0 8
78960: PUSH
78961: EMPTY
78962: ST_TO_ADDR
// for x in ( tmp diff j ) do
78963: LD_ADDR_VAR 0 7
78967: PUSH
78968: LD_VAR 0 6
78972: PUSH
78973: LD_VAR 0 3
78977: DIFF
78978: PUSH
78979: FOR_IN
78980: IFFALSE 79032
// begin if sci = 6 then
78982: LD_VAR 0 8
78986: PUSH
78987: LD_INT 6
78989: EQUAL
78990: IFFALSE 78994
// break ;
78992: GO 79032
// if BuildingStatus ( x ) = bs_idle then
78994: LD_VAR 0 7
78998: PPUSH
78999: CALL_OW 461
79003: PUSH
79004: LD_INT 2
79006: EQUAL
79007: IFFALSE 79030
// sci := sci ^ UnitsInside ( x ) ;
79009: LD_ADDR_VAR 0 8
79013: PUSH
79014: LD_VAR 0 8
79018: PUSH
79019: LD_VAR 0 7
79023: PPUSH
79024: CALL_OW 313
79028: ADD
79029: ST_TO_ADDR
// end ;
79030: GO 78979
79032: POP
79033: POP
// if not sci then
79034: LD_VAR 0 8
79038: NOT
79039: IFFALSE 79043
// continue ;
79041: GO 78088
// for x in sci do
79043: LD_ADDR_VAR 0 7
79047: PUSH
79048: LD_VAR 0 8
79052: PUSH
79053: FOR_IN
79054: IFFALSE 79104
// if IsInUnit ( x ) and not HasTask ( x ) then
79056: LD_VAR 0 7
79060: PPUSH
79061: CALL_OW 310
79065: PUSH
79066: LD_VAR 0 7
79070: PPUSH
79071: CALL_OW 314
79075: NOT
79076: AND
79077: IFFALSE 79102
// begin ComExitBuilding ( x ) ;
79079: LD_VAR 0 7
79083: PPUSH
79084: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79088: LD_VAR 0 7
79092: PPUSH
79093: LD_VAR 0 3
79097: PPUSH
79098: CALL_OW 180
// end ;
79102: GO 79053
79104: POP
79105: POP
// end ; end ;
79106: GO 78088
79108: POP
79109: POP
// end ;
79110: GO 78042
79112: POP
79113: POP
// end ;
79114: LD_VAR 0 1
79118: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79119: LD_INT 0
79121: PPUSH
79122: PPUSH
// if not mc_bases then
79123: LD_EXP 49
79127: NOT
79128: IFFALSE 79132
// exit ;
79130: GO 79213
// for i = 1 to mc_bases do
79132: LD_ADDR_VAR 0 2
79136: PUSH
79137: DOUBLE
79138: LD_INT 1
79140: DEC
79141: ST_TO_ADDR
79142: LD_EXP 49
79146: PUSH
79147: FOR_TO
79148: IFFALSE 79211
// if mc_mines [ i ] and mc_miners [ i ] then
79150: LD_EXP 62
79154: PUSH
79155: LD_VAR 0 2
79159: ARRAY
79160: PUSH
79161: LD_EXP 63
79165: PUSH
79166: LD_VAR 0 2
79170: ARRAY
79171: AND
79172: IFFALSE 79209
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79174: LD_EXP 63
79178: PUSH
79179: LD_VAR 0 2
79183: ARRAY
79184: PUSH
79185: LD_INT 1
79187: ARRAY
79188: PPUSH
79189: CALL_OW 255
79193: PPUSH
79194: LD_EXP 62
79198: PUSH
79199: LD_VAR 0 2
79203: ARRAY
79204: PPUSH
79205: CALL 21825 0 2
79209: GO 79147
79211: POP
79212: POP
// end ;
79213: LD_VAR 0 1
79217: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79218: LD_INT 0
79220: PPUSH
79221: PPUSH
79222: PPUSH
79223: PPUSH
79224: PPUSH
79225: PPUSH
79226: PPUSH
79227: PPUSH
// if not mc_bases or not mc_parking then
79228: LD_EXP 49
79232: NOT
79233: PUSH
79234: LD_EXP 73
79238: NOT
79239: OR
79240: IFFALSE 79244
// exit ;
79242: GO 79954
// for i = 1 to mc_bases do
79244: LD_ADDR_VAR 0 2
79248: PUSH
79249: DOUBLE
79250: LD_INT 1
79252: DEC
79253: ST_TO_ADDR
79254: LD_EXP 49
79258: PUSH
79259: FOR_TO
79260: IFFALSE 79952
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79262: LD_EXP 49
79266: PUSH
79267: LD_VAR 0 2
79271: ARRAY
79272: NOT
79273: PUSH
79274: LD_EXP 73
79278: PUSH
79279: LD_VAR 0 2
79283: ARRAY
79284: NOT
79285: OR
79286: IFFALSE 79290
// continue ;
79288: GO 79259
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79290: LD_ADDR_VAR 0 5
79294: PUSH
79295: LD_EXP 49
79299: PUSH
79300: LD_VAR 0 2
79304: ARRAY
79305: PUSH
79306: LD_INT 1
79308: ARRAY
79309: PPUSH
79310: CALL_OW 255
79314: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79315: LD_ADDR_VAR 0 6
79319: PUSH
79320: LD_EXP 49
79324: PUSH
79325: LD_VAR 0 2
79329: ARRAY
79330: PPUSH
79331: LD_INT 30
79333: PUSH
79334: LD_INT 3
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: PPUSH
79341: CALL_OW 72
79345: ST_TO_ADDR
// if not fac then
79346: LD_VAR 0 6
79350: NOT
79351: IFFALSE 79402
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79353: LD_ADDR_VAR 0 6
79357: PUSH
79358: LD_EXP 49
79362: PUSH
79363: LD_VAR 0 2
79367: ARRAY
79368: PPUSH
79369: LD_INT 2
79371: PUSH
79372: LD_INT 30
79374: PUSH
79375: LD_INT 0
79377: PUSH
79378: EMPTY
79379: LIST
79380: LIST
79381: PUSH
79382: LD_INT 30
79384: PUSH
79385: LD_INT 1
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: LIST
79396: PPUSH
79397: CALL_OW 72
79401: ST_TO_ADDR
// if not fac then
79402: LD_VAR 0 6
79406: NOT
79407: IFFALSE 79411
// continue ;
79409: GO 79259
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79411: LD_ADDR_VAR 0 7
79415: PUSH
79416: LD_EXP 73
79420: PUSH
79421: LD_VAR 0 2
79425: ARRAY
79426: PPUSH
79427: LD_INT 22
79429: PUSH
79430: LD_VAR 0 5
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 21
79441: PUSH
79442: LD_INT 2
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 3
79451: PUSH
79452: LD_INT 24
79454: PUSH
79455: LD_INT 1000
79457: PUSH
79458: EMPTY
79459: LIST
79460: LIST
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: LIST
79470: PPUSH
79471: CALL_OW 70
79475: ST_TO_ADDR
// for j in fac do
79476: LD_ADDR_VAR 0 3
79480: PUSH
79481: LD_VAR 0 6
79485: PUSH
79486: FOR_IN
79487: IFFALSE 79568
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79489: LD_ADDR_VAR 0 7
79493: PUSH
79494: LD_VAR 0 7
79498: PUSH
79499: LD_INT 22
79501: PUSH
79502: LD_VAR 0 5
79506: PUSH
79507: EMPTY
79508: LIST
79509: LIST
79510: PUSH
79511: LD_INT 91
79513: PUSH
79514: LD_VAR 0 3
79518: PUSH
79519: LD_INT 15
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 21
79529: PUSH
79530: LD_INT 2
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 3
79539: PUSH
79540: LD_INT 24
79542: PUSH
79543: LD_INT 1000
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: EMPTY
79555: LIST
79556: LIST
79557: LIST
79558: LIST
79559: PPUSH
79560: CALL_OW 69
79564: UNION
79565: ST_TO_ADDR
79566: GO 79486
79568: POP
79569: POP
// if not vehs then
79570: LD_VAR 0 7
79574: NOT
79575: IFFALSE 79601
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79577: LD_ADDR_EXP 61
79581: PUSH
79582: LD_EXP 61
79586: PPUSH
79587: LD_VAR 0 2
79591: PPUSH
79592: EMPTY
79593: PPUSH
79594: CALL_OW 1
79598: ST_TO_ADDR
// continue ;
79599: GO 79259
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79601: LD_ADDR_VAR 0 8
79605: PUSH
79606: LD_EXP 49
79610: PUSH
79611: LD_VAR 0 2
79615: ARRAY
79616: PPUSH
79617: LD_INT 30
79619: PUSH
79620: LD_INT 3
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PPUSH
79627: CALL_OW 72
79631: ST_TO_ADDR
// if tmp then
79632: LD_VAR 0 8
79636: IFFALSE 79739
// begin for j in tmp do
79638: LD_ADDR_VAR 0 3
79642: PUSH
79643: LD_VAR 0 8
79647: PUSH
79648: FOR_IN
79649: IFFALSE 79737
// for k in UnitsInside ( j ) do
79651: LD_ADDR_VAR 0 4
79655: PUSH
79656: LD_VAR 0 3
79660: PPUSH
79661: CALL_OW 313
79665: PUSH
79666: FOR_IN
79667: IFFALSE 79733
// if k then
79669: LD_VAR 0 4
79673: IFFALSE 79731
// if not k in mc_repair_vehicle [ i ] then
79675: LD_VAR 0 4
79679: PUSH
79680: LD_EXP 61
79684: PUSH
79685: LD_VAR 0 2
79689: ARRAY
79690: IN
79691: NOT
79692: IFFALSE 79731
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79694: LD_ADDR_EXP 61
79698: PUSH
79699: LD_EXP 61
79703: PPUSH
79704: LD_VAR 0 2
79708: PPUSH
79709: LD_EXP 61
79713: PUSH
79714: LD_VAR 0 2
79718: ARRAY
79719: PUSH
79720: LD_VAR 0 4
79724: UNION
79725: PPUSH
79726: CALL_OW 1
79730: ST_TO_ADDR
79731: GO 79666
79733: POP
79734: POP
79735: GO 79648
79737: POP
79738: POP
// end ; if not mc_repair_vehicle [ i ] then
79739: LD_EXP 61
79743: PUSH
79744: LD_VAR 0 2
79748: ARRAY
79749: NOT
79750: IFFALSE 79754
// continue ;
79752: GO 79259
// for j in mc_repair_vehicle [ i ] do
79754: LD_ADDR_VAR 0 3
79758: PUSH
79759: LD_EXP 61
79763: PUSH
79764: LD_VAR 0 2
79768: ARRAY
79769: PUSH
79770: FOR_IN
79771: IFFALSE 79948
// begin if GetClass ( j ) <> 3 then
79773: LD_VAR 0 3
79777: PPUSH
79778: CALL_OW 257
79782: PUSH
79783: LD_INT 3
79785: NONEQUAL
79786: IFFALSE 79827
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79788: LD_ADDR_EXP 61
79792: PUSH
79793: LD_EXP 61
79797: PPUSH
79798: LD_VAR 0 2
79802: PPUSH
79803: LD_EXP 61
79807: PUSH
79808: LD_VAR 0 2
79812: ARRAY
79813: PUSH
79814: LD_VAR 0 3
79818: DIFF
79819: PPUSH
79820: CALL_OW 1
79824: ST_TO_ADDR
// continue ;
79825: GO 79770
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79827: LD_VAR 0 3
79831: PPUSH
79832: CALL_OW 311
79836: NOT
79837: PUSH
79838: LD_VAR 0 3
79842: PUSH
79843: LD_EXP 52
79847: PUSH
79848: LD_VAR 0 2
79852: ARRAY
79853: PUSH
79854: LD_INT 1
79856: ARRAY
79857: IN
79858: NOT
79859: AND
79860: PUSH
79861: LD_VAR 0 3
79865: PUSH
79866: LD_EXP 52
79870: PUSH
79871: LD_VAR 0 2
79875: ARRAY
79876: PUSH
79877: LD_INT 2
79879: ARRAY
79880: IN
79881: NOT
79882: AND
79883: IFFALSE 79946
// begin if IsInUnit ( j ) then
79885: LD_VAR 0 3
79889: PPUSH
79890: CALL_OW 310
79894: IFFALSE 79907
// ComExitBuilding ( j ) else
79896: LD_VAR 0 3
79900: PPUSH
79901: CALL_OW 122
79905: GO 79946
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
79907: LD_VAR 0 3
79911: PPUSH
79912: LD_VAR 0 7
79916: PUSH
79917: LD_INT 1
79919: ARRAY
79920: PPUSH
79921: CALL 59354 0 2
79925: NOT
79926: IFFALSE 79946
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
79928: LD_VAR 0 3
79932: PPUSH
79933: LD_VAR 0 7
79937: PUSH
79938: LD_INT 1
79940: ARRAY
79941: PPUSH
79942: CALL_OW 129
// end ; end ;
79946: GO 79770
79948: POP
79949: POP
// end ;
79950: GO 79259
79952: POP
79953: POP
// end ;
79954: LD_VAR 0 1
79958: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
79959: LD_INT 0
79961: PPUSH
79962: PPUSH
79963: PPUSH
79964: PPUSH
79965: PPUSH
79966: PPUSH
79967: PPUSH
79968: PPUSH
79969: PPUSH
79970: PPUSH
79971: PPUSH
// if not mc_bases then
79972: LD_EXP 49
79976: NOT
79977: IFFALSE 79981
// exit ;
79979: GO 80783
// for i = 1 to mc_bases do
79981: LD_ADDR_VAR 0 2
79985: PUSH
79986: DOUBLE
79987: LD_INT 1
79989: DEC
79990: ST_TO_ADDR
79991: LD_EXP 49
79995: PUSH
79996: FOR_TO
79997: IFFALSE 80781
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
79999: LD_EXP 77
80003: PUSH
80004: LD_VAR 0 2
80008: ARRAY
80009: NOT
80010: PUSH
80011: LD_EXP 52
80015: PUSH
80016: LD_VAR 0 2
80020: ARRAY
80021: PUSH
80022: LD_INT 1
80024: ARRAY
80025: OR
80026: PUSH
80027: LD_EXP 52
80031: PUSH
80032: LD_VAR 0 2
80036: ARRAY
80037: PUSH
80038: LD_INT 2
80040: ARRAY
80041: OR
80042: PUSH
80043: LD_EXP 75
80047: PUSH
80048: LD_VAR 0 2
80052: ARRAY
80053: PPUSH
80054: LD_INT 1
80056: PPUSH
80057: CALL_OW 325
80061: NOT
80062: OR
80063: PUSH
80064: LD_EXP 72
80068: PUSH
80069: LD_VAR 0 2
80073: ARRAY
80074: OR
80075: IFFALSE 80079
// continue ;
80077: GO 79996
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80079: LD_ADDR_VAR 0 8
80083: PUSH
80084: LD_EXP 49
80088: PUSH
80089: LD_VAR 0 2
80093: ARRAY
80094: PPUSH
80095: LD_INT 25
80097: PUSH
80098: LD_INT 4
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: LD_INT 50
80107: PUSH
80108: EMPTY
80109: LIST
80110: PUSH
80111: LD_INT 3
80113: PUSH
80114: LD_INT 60
80116: PUSH
80117: EMPTY
80118: LIST
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: LIST
80128: PPUSH
80129: CALL_OW 72
80133: PUSH
80134: LD_EXP 53
80138: PUSH
80139: LD_VAR 0 2
80143: ARRAY
80144: DIFF
80145: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80146: LD_ADDR_VAR 0 9
80150: PUSH
80151: LD_EXP 49
80155: PUSH
80156: LD_VAR 0 2
80160: ARRAY
80161: PPUSH
80162: LD_INT 2
80164: PUSH
80165: LD_INT 30
80167: PUSH
80168: LD_INT 0
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 30
80177: PUSH
80178: LD_INT 1
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: LIST
80189: PPUSH
80190: CALL_OW 72
80194: ST_TO_ADDR
// if not tmp or not dep then
80195: LD_VAR 0 8
80199: NOT
80200: PUSH
80201: LD_VAR 0 9
80205: NOT
80206: OR
80207: IFFALSE 80211
// continue ;
80209: GO 79996
// side := GetSide ( tmp [ 1 ] ) ;
80211: LD_ADDR_VAR 0 11
80215: PUSH
80216: LD_VAR 0 8
80220: PUSH
80221: LD_INT 1
80223: ARRAY
80224: PPUSH
80225: CALL_OW 255
80229: ST_TO_ADDR
// dep := dep [ 1 ] ;
80230: LD_ADDR_VAR 0 9
80234: PUSH
80235: LD_VAR 0 9
80239: PUSH
80240: LD_INT 1
80242: ARRAY
80243: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80244: LD_ADDR_VAR 0 7
80248: PUSH
80249: LD_EXP 77
80253: PUSH
80254: LD_VAR 0 2
80258: ARRAY
80259: PPUSH
80260: LD_INT 22
80262: PUSH
80263: LD_INT 0
80265: PUSH
80266: EMPTY
80267: LIST
80268: LIST
80269: PUSH
80270: LD_INT 25
80272: PUSH
80273: LD_INT 12
80275: PUSH
80276: EMPTY
80277: LIST
80278: LIST
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: PPUSH
80284: CALL_OW 70
80288: PUSH
80289: LD_INT 22
80291: PUSH
80292: LD_INT 0
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 25
80301: PUSH
80302: LD_INT 12
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: LD_INT 91
80311: PUSH
80312: LD_VAR 0 9
80316: PUSH
80317: LD_INT 20
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: LIST
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: LIST
80329: PPUSH
80330: CALL_OW 69
80334: UNION
80335: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80336: LD_ADDR_VAR 0 10
80340: PUSH
80341: LD_EXP 77
80345: PUSH
80346: LD_VAR 0 2
80350: ARRAY
80351: PPUSH
80352: LD_INT 81
80354: PUSH
80355: LD_VAR 0 11
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PPUSH
80364: CALL_OW 70
80368: ST_TO_ADDR
// if not apes or danger_at_area then
80369: LD_VAR 0 7
80373: NOT
80374: PUSH
80375: LD_VAR 0 10
80379: OR
80380: IFFALSE 80430
// begin if mc_taming [ i ] then
80382: LD_EXP 80
80386: PUSH
80387: LD_VAR 0 2
80391: ARRAY
80392: IFFALSE 80428
// begin MC_Reset ( i , 121 ) ;
80394: LD_VAR 0 2
80398: PPUSH
80399: LD_INT 121
80401: PPUSH
80402: CALL 65416 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80406: LD_ADDR_EXP 80
80410: PUSH
80411: LD_EXP 80
80415: PPUSH
80416: LD_VAR 0 2
80420: PPUSH
80421: EMPTY
80422: PPUSH
80423: CALL_OW 1
80427: ST_TO_ADDR
// end ; continue ;
80428: GO 79996
// end ; for j in tmp do
80430: LD_ADDR_VAR 0 3
80434: PUSH
80435: LD_VAR 0 8
80439: PUSH
80440: FOR_IN
80441: IFFALSE 80777
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80443: LD_VAR 0 3
80447: PUSH
80448: LD_EXP 80
80452: PUSH
80453: LD_VAR 0 2
80457: ARRAY
80458: IN
80459: NOT
80460: PUSH
80461: LD_EXP 80
80465: PUSH
80466: LD_VAR 0 2
80470: ARRAY
80471: PUSH
80472: LD_INT 3
80474: LESS
80475: AND
80476: IFFALSE 80534
// begin SetTag ( j , 121 ) ;
80478: LD_VAR 0 3
80482: PPUSH
80483: LD_INT 121
80485: PPUSH
80486: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80490: LD_ADDR_EXP 80
80494: PUSH
80495: LD_EXP 80
80499: PPUSH
80500: LD_VAR 0 2
80504: PUSH
80505: LD_EXP 80
80509: PUSH
80510: LD_VAR 0 2
80514: ARRAY
80515: PUSH
80516: LD_INT 1
80518: PLUS
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PPUSH
80524: LD_VAR 0 3
80528: PPUSH
80529: CALL 25025 0 3
80533: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80534: LD_VAR 0 3
80538: PUSH
80539: LD_EXP 80
80543: PUSH
80544: LD_VAR 0 2
80548: ARRAY
80549: IN
80550: IFFALSE 80775
// begin if GetClass ( j ) <> 4 then
80552: LD_VAR 0 3
80556: PPUSH
80557: CALL_OW 257
80561: PUSH
80562: LD_INT 4
80564: NONEQUAL
80565: IFFALSE 80618
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80567: LD_ADDR_EXP 80
80571: PUSH
80572: LD_EXP 80
80576: PPUSH
80577: LD_VAR 0 2
80581: PPUSH
80582: LD_EXP 80
80586: PUSH
80587: LD_VAR 0 2
80591: ARRAY
80592: PUSH
80593: LD_VAR 0 3
80597: DIFF
80598: PPUSH
80599: CALL_OW 1
80603: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80604: LD_VAR 0 3
80608: PPUSH
80609: LD_INT 0
80611: PPUSH
80612: CALL_OW 109
// continue ;
80616: GO 80440
// end ; if IsInUnit ( j ) then
80618: LD_VAR 0 3
80622: PPUSH
80623: CALL_OW 310
80627: IFFALSE 80638
// ComExitBuilding ( j ) ;
80629: LD_VAR 0 3
80633: PPUSH
80634: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80638: LD_ADDR_VAR 0 6
80642: PUSH
80643: LD_VAR 0 7
80647: PPUSH
80648: LD_VAR 0 3
80652: PPUSH
80653: CALL_OW 74
80657: ST_TO_ADDR
// if not ape then
80658: LD_VAR 0 6
80662: NOT
80663: IFFALSE 80667
// break ;
80665: GO 80777
// x := GetX ( ape ) ;
80667: LD_ADDR_VAR 0 4
80671: PUSH
80672: LD_VAR 0 6
80676: PPUSH
80677: CALL_OW 250
80681: ST_TO_ADDR
// y := GetY ( ape ) ;
80682: LD_ADDR_VAR 0 5
80686: PUSH
80687: LD_VAR 0 6
80691: PPUSH
80692: CALL_OW 251
80696: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80697: LD_VAR 0 4
80701: PPUSH
80702: LD_VAR 0 5
80706: PPUSH
80707: CALL_OW 488
80711: NOT
80712: PUSH
80713: LD_VAR 0 11
80717: PPUSH
80718: LD_VAR 0 4
80722: PPUSH
80723: LD_VAR 0 5
80727: PPUSH
80728: LD_INT 20
80730: PPUSH
80731: CALL 25921 0 4
80735: PUSH
80736: LD_INT 4
80738: ARRAY
80739: OR
80740: IFFALSE 80744
// break ;
80742: GO 80777
// if not HasTask ( j ) then
80744: LD_VAR 0 3
80748: PPUSH
80749: CALL_OW 314
80753: NOT
80754: IFFALSE 80775
// ComTameXY ( j , x , y ) ;
80756: LD_VAR 0 3
80760: PPUSH
80761: LD_VAR 0 4
80765: PPUSH
80766: LD_VAR 0 5
80770: PPUSH
80771: CALL_OW 131
// end ; end ;
80775: GO 80440
80777: POP
80778: POP
// end ;
80779: GO 79996
80781: POP
80782: POP
// end ;
80783: LD_VAR 0 1
80787: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80788: LD_INT 0
80790: PPUSH
80791: PPUSH
80792: PPUSH
80793: PPUSH
80794: PPUSH
80795: PPUSH
80796: PPUSH
80797: PPUSH
// if not mc_bases then
80798: LD_EXP 49
80802: NOT
80803: IFFALSE 80807
// exit ;
80805: GO 81433
// for i = 1 to mc_bases do
80807: LD_ADDR_VAR 0 2
80811: PUSH
80812: DOUBLE
80813: LD_INT 1
80815: DEC
80816: ST_TO_ADDR
80817: LD_EXP 49
80821: PUSH
80822: FOR_TO
80823: IFFALSE 81431
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80825: LD_EXP 78
80829: PUSH
80830: LD_VAR 0 2
80834: ARRAY
80835: NOT
80836: PUSH
80837: LD_EXP 78
80841: PUSH
80842: LD_VAR 0 2
80846: ARRAY
80847: PPUSH
80848: LD_INT 25
80850: PUSH
80851: LD_INT 12
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PPUSH
80858: CALL_OW 72
80862: NOT
80863: OR
80864: IFFALSE 80868
// continue ;
80866: GO 80822
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80868: LD_ADDR_VAR 0 5
80872: PUSH
80873: LD_EXP 78
80877: PUSH
80878: LD_VAR 0 2
80882: ARRAY
80883: PUSH
80884: LD_INT 1
80886: ARRAY
80887: PPUSH
80888: CALL_OW 255
80892: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80893: LD_VAR 0 5
80897: PPUSH
80898: LD_INT 2
80900: PPUSH
80901: CALL_OW 325
80905: IFFALSE 81158
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80907: LD_ADDR_VAR 0 4
80911: PUSH
80912: LD_EXP 78
80916: PUSH
80917: LD_VAR 0 2
80921: ARRAY
80922: PPUSH
80923: LD_INT 25
80925: PUSH
80926: LD_INT 16
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: PPUSH
80933: CALL_OW 72
80937: ST_TO_ADDR
// if tmp < 6 then
80938: LD_VAR 0 4
80942: PUSH
80943: LD_INT 6
80945: LESS
80946: IFFALSE 81158
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80948: LD_ADDR_VAR 0 6
80952: PUSH
80953: LD_EXP 49
80957: PUSH
80958: LD_VAR 0 2
80962: ARRAY
80963: PPUSH
80964: LD_INT 2
80966: PUSH
80967: LD_INT 30
80969: PUSH
80970: LD_INT 0
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 30
80979: PUSH
80980: LD_INT 1
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: LIST
80991: PPUSH
80992: CALL_OW 72
80996: ST_TO_ADDR
// if depot then
80997: LD_VAR 0 6
81001: IFFALSE 81158
// begin selected := 0 ;
81003: LD_ADDR_VAR 0 7
81007: PUSH
81008: LD_INT 0
81010: ST_TO_ADDR
// for j in depot do
81011: LD_ADDR_VAR 0 3
81015: PUSH
81016: LD_VAR 0 6
81020: PUSH
81021: FOR_IN
81022: IFFALSE 81053
// begin if UnitsInside ( j ) < 6 then
81024: LD_VAR 0 3
81028: PPUSH
81029: CALL_OW 313
81033: PUSH
81034: LD_INT 6
81036: LESS
81037: IFFALSE 81051
// begin selected := j ;
81039: LD_ADDR_VAR 0 7
81043: PUSH
81044: LD_VAR 0 3
81048: ST_TO_ADDR
// break ;
81049: GO 81053
// end ; end ;
81051: GO 81021
81053: POP
81054: POP
// if selected then
81055: LD_VAR 0 7
81059: IFFALSE 81158
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81061: LD_ADDR_VAR 0 3
81065: PUSH
81066: LD_EXP 78
81070: PUSH
81071: LD_VAR 0 2
81075: ARRAY
81076: PPUSH
81077: LD_INT 25
81079: PUSH
81080: LD_INT 12
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PPUSH
81087: CALL_OW 72
81091: PUSH
81092: FOR_IN
81093: IFFALSE 81156
// if not HasTask ( j ) then
81095: LD_VAR 0 3
81099: PPUSH
81100: CALL_OW 314
81104: NOT
81105: IFFALSE 81154
// begin if not IsInUnit ( j ) then
81107: LD_VAR 0 3
81111: PPUSH
81112: CALL_OW 310
81116: NOT
81117: IFFALSE 81133
// ComEnterUnit ( j , selected ) ;
81119: LD_VAR 0 3
81123: PPUSH
81124: LD_VAR 0 7
81128: PPUSH
81129: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81133: LD_VAR 0 3
81137: PPUSH
81138: LD_INT 16
81140: PPUSH
81141: CALL_OW 183
// AddComExitBuilding ( j ) ;
81145: LD_VAR 0 3
81149: PPUSH
81150: CALL_OW 182
// end ;
81154: GO 81092
81156: POP
81157: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81158: LD_VAR 0 5
81162: PPUSH
81163: LD_INT 11
81165: PPUSH
81166: CALL_OW 325
81170: IFFALSE 81429
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81172: LD_ADDR_VAR 0 4
81176: PUSH
81177: LD_EXP 78
81181: PUSH
81182: LD_VAR 0 2
81186: ARRAY
81187: PPUSH
81188: LD_INT 25
81190: PUSH
81191: LD_INT 16
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PPUSH
81198: CALL_OW 72
81202: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81203: LD_VAR 0 4
81207: PUSH
81208: LD_INT 6
81210: GREATEREQUAL
81211: PUSH
81212: LD_VAR 0 5
81216: PPUSH
81217: LD_INT 2
81219: PPUSH
81220: CALL_OW 325
81224: NOT
81225: OR
81226: IFFALSE 81429
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81228: LD_ADDR_VAR 0 8
81232: PUSH
81233: LD_EXP 49
81237: PUSH
81238: LD_VAR 0 2
81242: ARRAY
81243: PPUSH
81244: LD_INT 2
81246: PUSH
81247: LD_INT 30
81249: PUSH
81250: LD_INT 4
81252: PUSH
81253: EMPTY
81254: LIST
81255: LIST
81256: PUSH
81257: LD_INT 30
81259: PUSH
81260: LD_INT 5
81262: PUSH
81263: EMPTY
81264: LIST
81265: LIST
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: LIST
81271: PPUSH
81272: CALL_OW 72
81276: ST_TO_ADDR
// if barracks then
81277: LD_VAR 0 8
81281: IFFALSE 81429
// begin selected := 0 ;
81283: LD_ADDR_VAR 0 7
81287: PUSH
81288: LD_INT 0
81290: ST_TO_ADDR
// for j in barracks do
81291: LD_ADDR_VAR 0 3
81295: PUSH
81296: LD_VAR 0 8
81300: PUSH
81301: FOR_IN
81302: IFFALSE 81333
// begin if UnitsInside ( j ) < 6 then
81304: LD_VAR 0 3
81308: PPUSH
81309: CALL_OW 313
81313: PUSH
81314: LD_INT 6
81316: LESS
81317: IFFALSE 81331
// begin selected := j ;
81319: LD_ADDR_VAR 0 7
81323: PUSH
81324: LD_VAR 0 3
81328: ST_TO_ADDR
// break ;
81329: GO 81333
// end ; end ;
81331: GO 81301
81333: POP
81334: POP
// if selected then
81335: LD_VAR 0 7
81339: IFFALSE 81429
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81341: LD_ADDR_VAR 0 3
81345: PUSH
81346: LD_EXP 78
81350: PUSH
81351: LD_VAR 0 2
81355: ARRAY
81356: PPUSH
81357: LD_INT 25
81359: PUSH
81360: LD_INT 12
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PPUSH
81367: CALL_OW 72
81371: PUSH
81372: FOR_IN
81373: IFFALSE 81427
// if not IsInUnit ( j ) and not HasTask ( j ) then
81375: LD_VAR 0 3
81379: PPUSH
81380: CALL_OW 310
81384: NOT
81385: PUSH
81386: LD_VAR 0 3
81390: PPUSH
81391: CALL_OW 314
81395: NOT
81396: AND
81397: IFFALSE 81425
// begin ComEnterUnit ( j , selected ) ;
81399: LD_VAR 0 3
81403: PPUSH
81404: LD_VAR 0 7
81408: PPUSH
81409: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81413: LD_VAR 0 3
81417: PPUSH
81418: LD_INT 15
81420: PPUSH
81421: CALL_OW 183
// end ;
81425: GO 81372
81427: POP
81428: POP
// end ; end ; end ; end ; end ;
81429: GO 80822
81431: POP
81432: POP
// end ;
81433: LD_VAR 0 1
81437: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81438: LD_INT 0
81440: PPUSH
81441: PPUSH
81442: PPUSH
81443: PPUSH
// if not mc_bases then
81444: LD_EXP 49
81448: NOT
81449: IFFALSE 81453
// exit ;
81451: GO 81631
// for i = 1 to mc_bases do
81453: LD_ADDR_VAR 0 2
81457: PUSH
81458: DOUBLE
81459: LD_INT 1
81461: DEC
81462: ST_TO_ADDR
81463: LD_EXP 49
81467: PUSH
81468: FOR_TO
81469: IFFALSE 81629
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81471: LD_ADDR_VAR 0 4
81475: PUSH
81476: LD_EXP 49
81480: PUSH
81481: LD_VAR 0 2
81485: ARRAY
81486: PPUSH
81487: LD_INT 25
81489: PUSH
81490: LD_INT 9
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PPUSH
81497: CALL_OW 72
81501: ST_TO_ADDR
// if not tmp then
81502: LD_VAR 0 4
81506: NOT
81507: IFFALSE 81511
// continue ;
81509: GO 81468
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81511: LD_EXP 75
81515: PUSH
81516: LD_VAR 0 2
81520: ARRAY
81521: PPUSH
81522: LD_INT 29
81524: PPUSH
81525: CALL_OW 325
81529: NOT
81530: PUSH
81531: LD_EXP 75
81535: PUSH
81536: LD_VAR 0 2
81540: ARRAY
81541: PPUSH
81542: LD_INT 28
81544: PPUSH
81545: CALL_OW 325
81549: NOT
81550: AND
81551: IFFALSE 81555
// continue ;
81553: GO 81468
// for j in tmp do
81555: LD_ADDR_VAR 0 3
81559: PUSH
81560: LD_VAR 0 4
81564: PUSH
81565: FOR_IN
81566: IFFALSE 81625
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81568: LD_VAR 0 3
81572: PUSH
81573: LD_EXP 52
81577: PUSH
81578: LD_VAR 0 2
81582: ARRAY
81583: PUSH
81584: LD_INT 1
81586: ARRAY
81587: IN
81588: NOT
81589: PUSH
81590: LD_VAR 0 3
81594: PUSH
81595: LD_EXP 52
81599: PUSH
81600: LD_VAR 0 2
81604: ARRAY
81605: PUSH
81606: LD_INT 2
81608: ARRAY
81609: IN
81610: NOT
81611: AND
81612: IFFALSE 81623
// ComSpaceTimeShoot ( j ) ;
81614: LD_VAR 0 3
81618: PPUSH
81619: CALL 20833 0 1
81623: GO 81565
81625: POP
81626: POP
// end ;
81627: GO 81468
81629: POP
81630: POP
// end ;
81631: LD_VAR 0 1
81635: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81636: LD_INT 0
81638: PPUSH
81639: PPUSH
81640: PPUSH
81641: PPUSH
81642: PPUSH
81643: PPUSH
81644: PPUSH
81645: PPUSH
81646: PPUSH
// if not mc_bases then
81647: LD_EXP 49
81651: NOT
81652: IFFALSE 81656
// exit ;
81654: GO 82278
// for i = 1 to mc_bases do
81656: LD_ADDR_VAR 0 2
81660: PUSH
81661: DOUBLE
81662: LD_INT 1
81664: DEC
81665: ST_TO_ADDR
81666: LD_EXP 49
81670: PUSH
81671: FOR_TO
81672: IFFALSE 82276
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81674: LD_EXP 84
81678: PUSH
81679: LD_VAR 0 2
81683: ARRAY
81684: NOT
81685: PUSH
81686: LD_INT 38
81688: PPUSH
81689: LD_EXP 75
81693: PUSH
81694: LD_VAR 0 2
81698: ARRAY
81699: PPUSH
81700: CALL_OW 321
81704: PUSH
81705: LD_INT 2
81707: NONEQUAL
81708: OR
81709: IFFALSE 81713
// continue ;
81711: GO 81671
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81713: LD_ADDR_VAR 0 8
81717: PUSH
81718: LD_EXP 49
81722: PUSH
81723: LD_VAR 0 2
81727: ARRAY
81728: PPUSH
81729: LD_INT 30
81731: PUSH
81732: LD_INT 34
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PPUSH
81739: CALL_OW 72
81743: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81744: LD_ADDR_VAR 0 9
81748: PUSH
81749: LD_EXP 49
81753: PUSH
81754: LD_VAR 0 2
81758: ARRAY
81759: PPUSH
81760: LD_INT 25
81762: PUSH
81763: LD_INT 4
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: PPUSH
81770: CALL_OW 72
81774: PPUSH
81775: LD_INT 0
81777: PPUSH
81778: CALL 54861 0 2
81782: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81783: LD_VAR 0 9
81787: NOT
81788: PUSH
81789: LD_VAR 0 8
81793: NOT
81794: OR
81795: PUSH
81796: LD_EXP 49
81800: PUSH
81801: LD_VAR 0 2
81805: ARRAY
81806: PPUSH
81807: LD_INT 124
81809: PPUSH
81810: CALL 54861 0 2
81814: OR
81815: IFFALSE 81819
// continue ;
81817: GO 81671
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81819: LD_EXP 85
81823: PUSH
81824: LD_VAR 0 2
81828: ARRAY
81829: PUSH
81830: LD_EXP 84
81834: PUSH
81835: LD_VAR 0 2
81839: ARRAY
81840: LESS
81841: PUSH
81842: LD_EXP 85
81846: PUSH
81847: LD_VAR 0 2
81851: ARRAY
81852: PUSH
81853: LD_VAR 0 8
81857: LESS
81858: AND
81859: IFFALSE 82274
// begin tmp := sci [ 1 ] ;
81861: LD_ADDR_VAR 0 7
81865: PUSH
81866: LD_VAR 0 9
81870: PUSH
81871: LD_INT 1
81873: ARRAY
81874: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81875: LD_VAR 0 7
81879: PPUSH
81880: LD_INT 124
81882: PPUSH
81883: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81887: LD_ADDR_VAR 0 3
81891: PUSH
81892: DOUBLE
81893: LD_EXP 84
81897: PUSH
81898: LD_VAR 0 2
81902: ARRAY
81903: INC
81904: ST_TO_ADDR
81905: LD_EXP 84
81909: PUSH
81910: LD_VAR 0 2
81914: ARRAY
81915: PUSH
81916: FOR_DOWNTO
81917: IFFALSE 82260
// begin if IsInUnit ( tmp ) then
81919: LD_VAR 0 7
81923: PPUSH
81924: CALL_OW 310
81928: IFFALSE 81939
// ComExitBuilding ( tmp ) ;
81930: LD_VAR 0 7
81934: PPUSH
81935: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
81939: LD_INT 35
81941: PPUSH
81942: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
81946: LD_VAR 0 7
81950: PPUSH
81951: CALL_OW 310
81955: NOT
81956: PUSH
81957: LD_VAR 0 7
81961: PPUSH
81962: CALL_OW 314
81966: NOT
81967: AND
81968: IFFALSE 81939
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
81970: LD_ADDR_VAR 0 6
81974: PUSH
81975: LD_VAR 0 7
81979: PPUSH
81980: CALL_OW 250
81984: PUSH
81985: LD_VAR 0 7
81989: PPUSH
81990: CALL_OW 251
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
81999: LD_INT 35
82001: PPUSH
82002: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82006: LD_ADDR_VAR 0 4
82010: PUSH
82011: LD_EXP 84
82015: PUSH
82016: LD_VAR 0 2
82020: ARRAY
82021: PUSH
82022: LD_VAR 0 3
82026: ARRAY
82027: PUSH
82028: LD_INT 1
82030: ARRAY
82031: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82032: LD_ADDR_VAR 0 5
82036: PUSH
82037: LD_EXP 84
82041: PUSH
82042: LD_VAR 0 2
82046: ARRAY
82047: PUSH
82048: LD_VAR 0 3
82052: ARRAY
82053: PUSH
82054: LD_INT 2
82056: ARRAY
82057: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82058: LD_VAR 0 7
82062: PPUSH
82063: LD_INT 10
82065: PPUSH
82066: CALL 27624 0 2
82070: PUSH
82071: LD_INT 4
82073: ARRAY
82074: IFFALSE 82112
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82076: LD_VAR 0 7
82080: PPUSH
82081: LD_VAR 0 6
82085: PUSH
82086: LD_INT 1
82088: ARRAY
82089: PPUSH
82090: LD_VAR 0 6
82094: PUSH
82095: LD_INT 2
82097: ARRAY
82098: PPUSH
82099: CALL_OW 111
// wait ( 0 0$10 ) ;
82103: LD_INT 350
82105: PPUSH
82106: CALL_OW 67
// end else
82110: GO 82138
// begin ComMoveXY ( tmp , x , y ) ;
82112: LD_VAR 0 7
82116: PPUSH
82117: LD_VAR 0 4
82121: PPUSH
82122: LD_VAR 0 5
82126: PPUSH
82127: CALL_OW 111
// wait ( 0 0$3 ) ;
82131: LD_INT 105
82133: PPUSH
82134: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82138: LD_VAR 0 7
82142: PPUSH
82143: LD_VAR 0 4
82147: PPUSH
82148: LD_VAR 0 5
82152: PPUSH
82153: CALL_OW 307
82157: IFFALSE 81999
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82159: LD_VAR 0 7
82163: PPUSH
82164: LD_VAR 0 4
82168: PPUSH
82169: LD_VAR 0 5
82173: PPUSH
82174: LD_VAR 0 8
82178: PUSH
82179: LD_VAR 0 3
82183: ARRAY
82184: PPUSH
82185: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82189: LD_INT 35
82191: PPUSH
82192: CALL_OW 67
// until not HasTask ( tmp ) ;
82196: LD_VAR 0 7
82200: PPUSH
82201: CALL_OW 314
82205: NOT
82206: IFFALSE 82189
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82208: LD_ADDR_EXP 85
82212: PUSH
82213: LD_EXP 85
82217: PPUSH
82218: LD_VAR 0 2
82222: PUSH
82223: LD_EXP 85
82227: PUSH
82228: LD_VAR 0 2
82232: ARRAY
82233: PUSH
82234: LD_INT 1
82236: PLUS
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PPUSH
82242: LD_VAR 0 8
82246: PUSH
82247: LD_VAR 0 3
82251: ARRAY
82252: PPUSH
82253: CALL 25025 0 3
82257: ST_TO_ADDR
// end ;
82258: GO 81916
82260: POP
82261: POP
// MC_Reset ( i , 124 ) ;
82262: LD_VAR 0 2
82266: PPUSH
82267: LD_INT 124
82269: PPUSH
82270: CALL 65416 0 2
// end ; end ;
82274: GO 81671
82276: POP
82277: POP
// end ;
82278: LD_VAR 0 1
82282: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82283: LD_INT 0
82285: PPUSH
82286: PPUSH
82287: PPUSH
// if not mc_bases then
82288: LD_EXP 49
82292: NOT
82293: IFFALSE 82297
// exit ;
82295: GO 82903
// for i = 1 to mc_bases do
82297: LD_ADDR_VAR 0 2
82301: PUSH
82302: DOUBLE
82303: LD_INT 1
82305: DEC
82306: ST_TO_ADDR
82307: LD_EXP 49
82311: PUSH
82312: FOR_TO
82313: IFFALSE 82901
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82315: LD_ADDR_VAR 0 3
82319: PUSH
82320: LD_EXP 49
82324: PUSH
82325: LD_VAR 0 2
82329: ARRAY
82330: PPUSH
82331: LD_INT 25
82333: PUSH
82334: LD_INT 4
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PPUSH
82341: CALL_OW 72
82345: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82346: LD_VAR 0 3
82350: NOT
82351: PUSH
82352: LD_EXP 86
82356: PUSH
82357: LD_VAR 0 2
82361: ARRAY
82362: NOT
82363: OR
82364: PUSH
82365: LD_EXP 49
82369: PUSH
82370: LD_VAR 0 2
82374: ARRAY
82375: PPUSH
82376: LD_INT 2
82378: PUSH
82379: LD_INT 30
82381: PUSH
82382: LD_INT 0
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PUSH
82389: LD_INT 30
82391: PUSH
82392: LD_INT 1
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: LIST
82403: PPUSH
82404: CALL_OW 72
82408: NOT
82409: OR
82410: IFFALSE 82460
// begin if mc_deposits_finder [ i ] then
82412: LD_EXP 87
82416: PUSH
82417: LD_VAR 0 2
82421: ARRAY
82422: IFFALSE 82458
// begin MC_Reset ( i , 125 ) ;
82424: LD_VAR 0 2
82428: PPUSH
82429: LD_INT 125
82431: PPUSH
82432: CALL 65416 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82436: LD_ADDR_EXP 87
82440: PUSH
82441: LD_EXP 87
82445: PPUSH
82446: LD_VAR 0 2
82450: PPUSH
82451: EMPTY
82452: PPUSH
82453: CALL_OW 1
82457: ST_TO_ADDR
// end ; continue ;
82458: GO 82312
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82460: LD_EXP 86
82464: PUSH
82465: LD_VAR 0 2
82469: ARRAY
82470: PUSH
82471: LD_INT 1
82473: ARRAY
82474: PUSH
82475: LD_INT 3
82477: ARRAY
82478: PUSH
82479: LD_INT 1
82481: EQUAL
82482: PUSH
82483: LD_INT 20
82485: PPUSH
82486: LD_EXP 75
82490: PUSH
82491: LD_VAR 0 2
82495: ARRAY
82496: PPUSH
82497: CALL_OW 321
82501: PUSH
82502: LD_INT 2
82504: NONEQUAL
82505: AND
82506: IFFALSE 82556
// begin if mc_deposits_finder [ i ] then
82508: LD_EXP 87
82512: PUSH
82513: LD_VAR 0 2
82517: ARRAY
82518: IFFALSE 82554
// begin MC_Reset ( i , 125 ) ;
82520: LD_VAR 0 2
82524: PPUSH
82525: LD_INT 125
82527: PPUSH
82528: CALL 65416 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82532: LD_ADDR_EXP 87
82536: PUSH
82537: LD_EXP 87
82541: PPUSH
82542: LD_VAR 0 2
82546: PPUSH
82547: EMPTY
82548: PPUSH
82549: CALL_OW 1
82553: ST_TO_ADDR
// end ; continue ;
82554: GO 82312
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82556: LD_EXP 86
82560: PUSH
82561: LD_VAR 0 2
82565: ARRAY
82566: PUSH
82567: LD_INT 1
82569: ARRAY
82570: PUSH
82571: LD_INT 1
82573: ARRAY
82574: PPUSH
82575: LD_EXP 86
82579: PUSH
82580: LD_VAR 0 2
82584: ARRAY
82585: PUSH
82586: LD_INT 1
82588: ARRAY
82589: PUSH
82590: LD_INT 2
82592: ARRAY
82593: PPUSH
82594: LD_EXP 75
82598: PUSH
82599: LD_VAR 0 2
82603: ARRAY
82604: PPUSH
82605: CALL_OW 440
82609: IFFALSE 82652
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82611: LD_ADDR_EXP 86
82615: PUSH
82616: LD_EXP 86
82620: PPUSH
82621: LD_VAR 0 2
82625: PPUSH
82626: LD_EXP 86
82630: PUSH
82631: LD_VAR 0 2
82635: ARRAY
82636: PPUSH
82637: LD_INT 1
82639: PPUSH
82640: CALL_OW 3
82644: PPUSH
82645: CALL_OW 1
82649: ST_TO_ADDR
82650: GO 82899
// begin if not mc_deposits_finder [ i ] then
82652: LD_EXP 87
82656: PUSH
82657: LD_VAR 0 2
82661: ARRAY
82662: NOT
82663: IFFALSE 82715
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82665: LD_ADDR_EXP 87
82669: PUSH
82670: LD_EXP 87
82674: PPUSH
82675: LD_VAR 0 2
82679: PPUSH
82680: LD_VAR 0 3
82684: PUSH
82685: LD_INT 1
82687: ARRAY
82688: PUSH
82689: EMPTY
82690: LIST
82691: PPUSH
82692: CALL_OW 1
82696: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82697: LD_VAR 0 3
82701: PUSH
82702: LD_INT 1
82704: ARRAY
82705: PPUSH
82706: LD_INT 125
82708: PPUSH
82709: CALL_OW 109
// end else
82713: GO 82899
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82715: LD_EXP 87
82719: PUSH
82720: LD_VAR 0 2
82724: ARRAY
82725: PUSH
82726: LD_INT 1
82728: ARRAY
82729: PPUSH
82730: CALL_OW 310
82734: IFFALSE 82757
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82736: LD_EXP 87
82740: PUSH
82741: LD_VAR 0 2
82745: ARRAY
82746: PUSH
82747: LD_INT 1
82749: ARRAY
82750: PPUSH
82751: CALL_OW 122
82755: GO 82899
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82757: LD_EXP 87
82761: PUSH
82762: LD_VAR 0 2
82766: ARRAY
82767: PUSH
82768: LD_INT 1
82770: ARRAY
82771: PPUSH
82772: CALL_OW 314
82776: NOT
82777: PUSH
82778: LD_EXP 87
82782: PUSH
82783: LD_VAR 0 2
82787: ARRAY
82788: PUSH
82789: LD_INT 1
82791: ARRAY
82792: PPUSH
82793: LD_EXP 86
82797: PUSH
82798: LD_VAR 0 2
82802: ARRAY
82803: PUSH
82804: LD_INT 1
82806: ARRAY
82807: PUSH
82808: LD_INT 1
82810: ARRAY
82811: PPUSH
82812: LD_EXP 86
82816: PUSH
82817: LD_VAR 0 2
82821: ARRAY
82822: PUSH
82823: LD_INT 1
82825: ARRAY
82826: PUSH
82827: LD_INT 2
82829: ARRAY
82830: PPUSH
82831: CALL_OW 297
82835: PUSH
82836: LD_INT 6
82838: GREATER
82839: AND
82840: IFFALSE 82899
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82842: LD_EXP 87
82846: PUSH
82847: LD_VAR 0 2
82851: ARRAY
82852: PUSH
82853: LD_INT 1
82855: ARRAY
82856: PPUSH
82857: LD_EXP 86
82861: PUSH
82862: LD_VAR 0 2
82866: ARRAY
82867: PUSH
82868: LD_INT 1
82870: ARRAY
82871: PUSH
82872: LD_INT 1
82874: ARRAY
82875: PPUSH
82876: LD_EXP 86
82880: PUSH
82881: LD_VAR 0 2
82885: ARRAY
82886: PUSH
82887: LD_INT 1
82889: ARRAY
82890: PUSH
82891: LD_INT 2
82893: ARRAY
82894: PPUSH
82895: CALL_OW 111
// end ; end ; end ;
82899: GO 82312
82901: POP
82902: POP
// end ;
82903: LD_VAR 0 1
82907: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
82908: LD_INT 0
82910: PPUSH
82911: PPUSH
82912: PPUSH
82913: PPUSH
82914: PPUSH
82915: PPUSH
82916: PPUSH
82917: PPUSH
82918: PPUSH
82919: PPUSH
82920: PPUSH
// if not mc_bases then
82921: LD_EXP 49
82925: NOT
82926: IFFALSE 82930
// exit ;
82928: GO 83870
// for i = 1 to mc_bases do
82930: LD_ADDR_VAR 0 2
82934: PUSH
82935: DOUBLE
82936: LD_INT 1
82938: DEC
82939: ST_TO_ADDR
82940: LD_EXP 49
82944: PUSH
82945: FOR_TO
82946: IFFALSE 83868
// begin if not mc_bases [ i ] or mc_scan [ i ] then
82948: LD_EXP 49
82952: PUSH
82953: LD_VAR 0 2
82957: ARRAY
82958: NOT
82959: PUSH
82960: LD_EXP 72
82964: PUSH
82965: LD_VAR 0 2
82969: ARRAY
82970: OR
82971: IFFALSE 82975
// continue ;
82973: GO 82945
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
82975: LD_ADDR_VAR 0 7
82979: PUSH
82980: LD_EXP 49
82984: PUSH
82985: LD_VAR 0 2
82989: ARRAY
82990: PUSH
82991: LD_INT 1
82993: ARRAY
82994: PPUSH
82995: CALL_OW 248
82999: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83000: LD_VAR 0 7
83004: PUSH
83005: LD_INT 3
83007: EQUAL
83008: PUSH
83009: LD_EXP 68
83013: PUSH
83014: LD_VAR 0 2
83018: ARRAY
83019: PUSH
83020: LD_EXP 71
83024: PUSH
83025: LD_VAR 0 2
83029: ARRAY
83030: UNION
83031: PPUSH
83032: LD_INT 33
83034: PUSH
83035: LD_INT 2
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PPUSH
83042: CALL_OW 72
83046: NOT
83047: OR
83048: IFFALSE 83052
// continue ;
83050: GO 82945
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83052: LD_ADDR_VAR 0 9
83056: PUSH
83057: LD_EXP 49
83061: PUSH
83062: LD_VAR 0 2
83066: ARRAY
83067: PPUSH
83068: LD_INT 30
83070: PUSH
83071: LD_INT 36
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: PPUSH
83078: CALL_OW 72
83082: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83083: LD_ADDR_VAR 0 10
83087: PUSH
83088: LD_EXP 68
83092: PUSH
83093: LD_VAR 0 2
83097: ARRAY
83098: PPUSH
83099: LD_INT 34
83101: PUSH
83102: LD_INT 31
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PPUSH
83109: CALL_OW 72
83113: ST_TO_ADDR
// if not cts and not mcts then
83114: LD_VAR 0 9
83118: NOT
83119: PUSH
83120: LD_VAR 0 10
83124: NOT
83125: AND
83126: IFFALSE 83130
// continue ;
83128: GO 82945
// x := cts ;
83130: LD_ADDR_VAR 0 11
83134: PUSH
83135: LD_VAR 0 9
83139: ST_TO_ADDR
// if not x then
83140: LD_VAR 0 11
83144: NOT
83145: IFFALSE 83157
// x := mcts ;
83147: LD_ADDR_VAR 0 11
83151: PUSH
83152: LD_VAR 0 10
83156: ST_TO_ADDR
// if not x then
83157: LD_VAR 0 11
83161: NOT
83162: IFFALSE 83166
// continue ;
83164: GO 82945
// if mc_remote_driver [ i ] then
83166: LD_EXP 89
83170: PUSH
83171: LD_VAR 0 2
83175: ARRAY
83176: IFFALSE 83563
// for j in mc_remote_driver [ i ] do
83178: LD_ADDR_VAR 0 3
83182: PUSH
83183: LD_EXP 89
83187: PUSH
83188: LD_VAR 0 2
83192: ARRAY
83193: PUSH
83194: FOR_IN
83195: IFFALSE 83561
// begin if GetClass ( j ) <> 3 then
83197: LD_VAR 0 3
83201: PPUSH
83202: CALL_OW 257
83206: PUSH
83207: LD_INT 3
83209: NONEQUAL
83210: IFFALSE 83263
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83212: LD_ADDR_EXP 89
83216: PUSH
83217: LD_EXP 89
83221: PPUSH
83222: LD_VAR 0 2
83226: PPUSH
83227: LD_EXP 89
83231: PUSH
83232: LD_VAR 0 2
83236: ARRAY
83237: PUSH
83238: LD_VAR 0 3
83242: DIFF
83243: PPUSH
83244: CALL_OW 1
83248: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83249: LD_VAR 0 3
83253: PPUSH
83254: LD_INT 0
83256: PPUSH
83257: CALL_OW 109
// continue ;
83261: GO 83194
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83263: LD_EXP 68
83267: PUSH
83268: LD_VAR 0 2
83272: ARRAY
83273: PPUSH
83274: LD_INT 34
83276: PUSH
83277: LD_INT 31
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 58
83286: PUSH
83287: EMPTY
83288: LIST
83289: PUSH
83290: EMPTY
83291: LIST
83292: LIST
83293: PPUSH
83294: CALL_OW 72
83298: PUSH
83299: LD_VAR 0 3
83303: PPUSH
83304: CALL 54896 0 1
83308: NOT
83309: AND
83310: IFFALSE 83381
// begin if IsInUnit ( j ) then
83312: LD_VAR 0 3
83316: PPUSH
83317: CALL_OW 310
83321: IFFALSE 83332
// ComExitBuilding ( j ) ;
83323: LD_VAR 0 3
83327: PPUSH
83328: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83332: LD_VAR 0 3
83336: PPUSH
83337: LD_EXP 68
83341: PUSH
83342: LD_VAR 0 2
83346: ARRAY
83347: PPUSH
83348: LD_INT 34
83350: PUSH
83351: LD_INT 31
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: PUSH
83358: LD_INT 58
83360: PUSH
83361: EMPTY
83362: LIST
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PPUSH
83368: CALL_OW 72
83372: PUSH
83373: LD_INT 1
83375: ARRAY
83376: PPUSH
83377: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83381: LD_VAR 0 3
83385: PPUSH
83386: CALL_OW 310
83390: NOT
83391: PUSH
83392: LD_VAR 0 3
83396: PPUSH
83397: CALL_OW 310
83401: PPUSH
83402: CALL_OW 266
83406: PUSH
83407: LD_INT 36
83409: NONEQUAL
83410: PUSH
83411: LD_VAR 0 3
83415: PPUSH
83416: CALL 54896 0 1
83420: NOT
83421: AND
83422: OR
83423: IFFALSE 83559
// begin if IsInUnit ( j ) then
83425: LD_VAR 0 3
83429: PPUSH
83430: CALL_OW 310
83434: IFFALSE 83445
// ComExitBuilding ( j ) ;
83436: LD_VAR 0 3
83440: PPUSH
83441: CALL_OW 122
// ct := 0 ;
83445: LD_ADDR_VAR 0 8
83449: PUSH
83450: LD_INT 0
83452: ST_TO_ADDR
// for k in x do
83453: LD_ADDR_VAR 0 4
83457: PUSH
83458: LD_VAR 0 11
83462: PUSH
83463: FOR_IN
83464: IFFALSE 83537
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83466: LD_VAR 0 4
83470: PPUSH
83471: CALL_OW 264
83475: PUSH
83476: LD_INT 31
83478: EQUAL
83479: PUSH
83480: LD_VAR 0 4
83484: PPUSH
83485: CALL_OW 311
83489: NOT
83490: AND
83491: PUSH
83492: LD_VAR 0 4
83496: PPUSH
83497: CALL_OW 266
83501: PUSH
83502: LD_INT 36
83504: EQUAL
83505: PUSH
83506: LD_VAR 0 4
83510: PPUSH
83511: CALL_OW 313
83515: PUSH
83516: LD_INT 3
83518: LESS
83519: AND
83520: OR
83521: IFFALSE 83535
// begin ct := k ;
83523: LD_ADDR_VAR 0 8
83527: PUSH
83528: LD_VAR 0 4
83532: ST_TO_ADDR
// break ;
83533: GO 83537
// end ;
83535: GO 83463
83537: POP
83538: POP
// if ct then
83539: LD_VAR 0 8
83543: IFFALSE 83559
// ComEnterUnit ( j , ct ) ;
83545: LD_VAR 0 3
83549: PPUSH
83550: LD_VAR 0 8
83554: PPUSH
83555: CALL_OW 120
// end ; end ;
83559: GO 83194
83561: POP
83562: POP
// places := 0 ;
83563: LD_ADDR_VAR 0 5
83567: PUSH
83568: LD_INT 0
83570: ST_TO_ADDR
// for j = 1 to x do
83571: LD_ADDR_VAR 0 3
83575: PUSH
83576: DOUBLE
83577: LD_INT 1
83579: DEC
83580: ST_TO_ADDR
83581: LD_VAR 0 11
83585: PUSH
83586: FOR_TO
83587: IFFALSE 83663
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83589: LD_VAR 0 11
83593: PUSH
83594: LD_VAR 0 3
83598: ARRAY
83599: PPUSH
83600: CALL_OW 264
83604: PUSH
83605: LD_INT 31
83607: EQUAL
83608: IFFALSE 83626
// places := places + 1 else
83610: LD_ADDR_VAR 0 5
83614: PUSH
83615: LD_VAR 0 5
83619: PUSH
83620: LD_INT 1
83622: PLUS
83623: ST_TO_ADDR
83624: GO 83661
// if GetBType ( x [ j ] ) = b_control_tower then
83626: LD_VAR 0 11
83630: PUSH
83631: LD_VAR 0 3
83635: ARRAY
83636: PPUSH
83637: CALL_OW 266
83641: PUSH
83642: LD_INT 36
83644: EQUAL
83645: IFFALSE 83661
// places := places + 3 ;
83647: LD_ADDR_VAR 0 5
83651: PUSH
83652: LD_VAR 0 5
83656: PUSH
83657: LD_INT 3
83659: PLUS
83660: ST_TO_ADDR
83661: GO 83586
83663: POP
83664: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83665: LD_VAR 0 5
83669: PUSH
83670: LD_INT 0
83672: EQUAL
83673: PUSH
83674: LD_VAR 0 5
83678: PUSH
83679: LD_EXP 89
83683: PUSH
83684: LD_VAR 0 2
83688: ARRAY
83689: LESSEQUAL
83690: OR
83691: IFFALSE 83695
// continue ;
83693: GO 82945
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83695: LD_ADDR_VAR 0 6
83699: PUSH
83700: LD_EXP 49
83704: PUSH
83705: LD_VAR 0 2
83709: ARRAY
83710: PPUSH
83711: LD_INT 25
83713: PUSH
83714: LD_INT 3
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: PPUSH
83721: CALL_OW 72
83725: PUSH
83726: LD_EXP 89
83730: PUSH
83731: LD_VAR 0 2
83735: ARRAY
83736: DIFF
83737: PPUSH
83738: LD_INT 3
83740: PPUSH
83741: CALL 55796 0 2
83745: ST_TO_ADDR
// for j in tmp do
83746: LD_ADDR_VAR 0 3
83750: PUSH
83751: LD_VAR 0 6
83755: PUSH
83756: FOR_IN
83757: IFFALSE 83792
// if GetTag ( j ) > 0 then
83759: LD_VAR 0 3
83763: PPUSH
83764: CALL_OW 110
83768: PUSH
83769: LD_INT 0
83771: GREATER
83772: IFFALSE 83790
// tmp := tmp diff j ;
83774: LD_ADDR_VAR 0 6
83778: PUSH
83779: LD_VAR 0 6
83783: PUSH
83784: LD_VAR 0 3
83788: DIFF
83789: ST_TO_ADDR
83790: GO 83756
83792: POP
83793: POP
// if not tmp then
83794: LD_VAR 0 6
83798: NOT
83799: IFFALSE 83803
// continue ;
83801: GO 82945
// if places then
83803: LD_VAR 0 5
83807: IFFALSE 83866
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83809: LD_ADDR_EXP 89
83813: PUSH
83814: LD_EXP 89
83818: PPUSH
83819: LD_VAR 0 2
83823: PPUSH
83824: LD_EXP 89
83828: PUSH
83829: LD_VAR 0 2
83833: ARRAY
83834: PUSH
83835: LD_VAR 0 6
83839: PUSH
83840: LD_INT 1
83842: ARRAY
83843: UNION
83844: PPUSH
83845: CALL_OW 1
83849: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83850: LD_VAR 0 6
83854: PUSH
83855: LD_INT 1
83857: ARRAY
83858: PPUSH
83859: LD_INT 126
83861: PPUSH
83862: CALL_OW 109
// end ; end ;
83866: GO 82945
83868: POP
83869: POP
// end ;
83870: LD_VAR 0 1
83874: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83875: LD_INT 0
83877: PPUSH
83878: PPUSH
83879: PPUSH
83880: PPUSH
83881: PPUSH
83882: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83883: LD_VAR 0 1
83887: NOT
83888: PUSH
83889: LD_VAR 0 2
83893: NOT
83894: OR
83895: PUSH
83896: LD_VAR 0 3
83900: NOT
83901: OR
83902: PUSH
83903: LD_VAR 0 4
83907: PUSH
83908: LD_INT 1
83910: PUSH
83911: LD_INT 2
83913: PUSH
83914: LD_INT 3
83916: PUSH
83917: LD_INT 4
83919: PUSH
83920: LD_INT 5
83922: PUSH
83923: LD_INT 8
83925: PUSH
83926: LD_INT 9
83928: PUSH
83929: LD_INT 15
83931: PUSH
83932: LD_INT 16
83934: PUSH
83935: EMPTY
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: IN
83946: NOT
83947: OR
83948: IFFALSE 83952
// exit ;
83950: GO 84852
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
83952: LD_ADDR_VAR 0 2
83956: PUSH
83957: LD_VAR 0 2
83961: PPUSH
83962: LD_INT 21
83964: PUSH
83965: LD_INT 3
83967: PUSH
83968: EMPTY
83969: LIST
83970: LIST
83971: PUSH
83972: LD_INT 24
83974: PUSH
83975: LD_INT 250
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PPUSH
83986: CALL_OW 72
83990: ST_TO_ADDR
// case class of 1 , 15 :
83991: LD_VAR 0 4
83995: PUSH
83996: LD_INT 1
83998: DOUBLE
83999: EQUAL
84000: IFTRUE 84010
84002: LD_INT 15
84004: DOUBLE
84005: EQUAL
84006: IFTRUE 84010
84008: GO 84095
84010: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84011: LD_ADDR_VAR 0 8
84015: PUSH
84016: LD_VAR 0 2
84020: PPUSH
84021: LD_INT 2
84023: PUSH
84024: LD_INT 30
84026: PUSH
84027: LD_INT 32
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 30
84036: PUSH
84037: LD_INT 31
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: LIST
84048: PPUSH
84049: CALL_OW 72
84053: PUSH
84054: LD_VAR 0 2
84058: PPUSH
84059: LD_INT 2
84061: PUSH
84062: LD_INT 30
84064: PUSH
84065: LD_INT 4
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: PUSH
84072: LD_INT 30
84074: PUSH
84075: LD_INT 5
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: LIST
84086: PPUSH
84087: CALL_OW 72
84091: ADD
84092: ST_TO_ADDR
84093: GO 84341
84095: LD_INT 2
84097: DOUBLE
84098: EQUAL
84099: IFTRUE 84109
84101: LD_INT 16
84103: DOUBLE
84104: EQUAL
84105: IFTRUE 84109
84107: GO 84155
84109: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84110: LD_ADDR_VAR 0 8
84114: PUSH
84115: LD_VAR 0 2
84119: PPUSH
84120: LD_INT 2
84122: PUSH
84123: LD_INT 30
84125: PUSH
84126: LD_INT 0
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 30
84135: PUSH
84136: LD_INT 1
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: LIST
84147: PPUSH
84148: CALL_OW 72
84152: ST_TO_ADDR
84153: GO 84341
84155: LD_INT 3
84157: DOUBLE
84158: EQUAL
84159: IFTRUE 84163
84161: GO 84209
84163: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84164: LD_ADDR_VAR 0 8
84168: PUSH
84169: LD_VAR 0 2
84173: PPUSH
84174: LD_INT 2
84176: PUSH
84177: LD_INT 30
84179: PUSH
84180: LD_INT 2
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 30
84189: PUSH
84190: LD_INT 3
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: LIST
84201: PPUSH
84202: CALL_OW 72
84206: ST_TO_ADDR
84207: GO 84341
84209: LD_INT 4
84211: DOUBLE
84212: EQUAL
84213: IFTRUE 84217
84215: GO 84274
84217: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84218: LD_ADDR_VAR 0 8
84222: PUSH
84223: LD_VAR 0 2
84227: PPUSH
84228: LD_INT 2
84230: PUSH
84231: LD_INT 30
84233: PUSH
84234: LD_INT 6
84236: PUSH
84237: EMPTY
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 30
84243: PUSH
84244: LD_INT 7
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 30
84253: PUSH
84254: LD_INT 8
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: LIST
84265: LIST
84266: PPUSH
84267: CALL_OW 72
84271: ST_TO_ADDR
84272: GO 84341
84274: LD_INT 5
84276: DOUBLE
84277: EQUAL
84278: IFTRUE 84294
84280: LD_INT 8
84282: DOUBLE
84283: EQUAL
84284: IFTRUE 84294
84286: LD_INT 9
84288: DOUBLE
84289: EQUAL
84290: IFTRUE 84294
84292: GO 84340
84294: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84295: LD_ADDR_VAR 0 8
84299: PUSH
84300: LD_VAR 0 2
84304: PPUSH
84305: LD_INT 2
84307: PUSH
84308: LD_INT 30
84310: PUSH
84311: LD_INT 4
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 30
84320: PUSH
84321: LD_INT 5
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: LIST
84332: PPUSH
84333: CALL_OW 72
84337: ST_TO_ADDR
84338: GO 84341
84340: POP
// if not tmp then
84341: LD_VAR 0 8
84345: NOT
84346: IFFALSE 84350
// exit ;
84348: GO 84852
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84350: LD_VAR 0 4
84354: PUSH
84355: LD_INT 1
84357: PUSH
84358: LD_INT 15
84360: PUSH
84361: EMPTY
84362: LIST
84363: LIST
84364: IN
84365: PUSH
84366: LD_EXP 58
84370: PUSH
84371: LD_VAR 0 1
84375: ARRAY
84376: AND
84377: IFFALSE 84533
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84379: LD_ADDR_VAR 0 9
84383: PUSH
84384: LD_EXP 58
84388: PUSH
84389: LD_VAR 0 1
84393: ARRAY
84394: PUSH
84395: LD_INT 1
84397: ARRAY
84398: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84399: LD_VAR 0 9
84403: PUSH
84404: LD_EXP 59
84408: PUSH
84409: LD_VAR 0 1
84413: ARRAY
84414: IN
84415: NOT
84416: IFFALSE 84531
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84418: LD_ADDR_EXP 59
84422: PUSH
84423: LD_EXP 59
84427: PPUSH
84428: LD_VAR 0 1
84432: PUSH
84433: LD_EXP 59
84437: PUSH
84438: LD_VAR 0 1
84442: ARRAY
84443: PUSH
84444: LD_INT 1
84446: PLUS
84447: PUSH
84448: EMPTY
84449: LIST
84450: LIST
84451: PPUSH
84452: LD_VAR 0 9
84456: PPUSH
84457: CALL 25025 0 3
84461: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84462: LD_ADDR_EXP 58
84466: PUSH
84467: LD_EXP 58
84471: PPUSH
84472: LD_VAR 0 1
84476: PPUSH
84477: LD_EXP 58
84481: PUSH
84482: LD_VAR 0 1
84486: ARRAY
84487: PUSH
84488: LD_VAR 0 9
84492: DIFF
84493: PPUSH
84494: CALL_OW 1
84498: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84499: LD_VAR 0 3
84503: PPUSH
84504: LD_EXP 59
84508: PUSH
84509: LD_VAR 0 1
84513: ARRAY
84514: PUSH
84515: LD_EXP 59
84519: PUSH
84520: LD_VAR 0 1
84524: ARRAY
84525: ARRAY
84526: PPUSH
84527: CALL_OW 120
// end ; exit ;
84531: GO 84852
// end ; if tmp > 1 then
84533: LD_VAR 0 8
84537: PUSH
84538: LD_INT 1
84540: GREATER
84541: IFFALSE 84645
// for i = 2 to tmp do
84543: LD_ADDR_VAR 0 6
84547: PUSH
84548: DOUBLE
84549: LD_INT 2
84551: DEC
84552: ST_TO_ADDR
84553: LD_VAR 0 8
84557: PUSH
84558: FOR_TO
84559: IFFALSE 84643
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84561: LD_VAR 0 8
84565: PUSH
84566: LD_VAR 0 6
84570: ARRAY
84571: PPUSH
84572: CALL_OW 461
84576: PUSH
84577: LD_INT 6
84579: EQUAL
84580: IFFALSE 84641
// begin x := tmp [ i ] ;
84582: LD_ADDR_VAR 0 9
84586: PUSH
84587: LD_VAR 0 8
84591: PUSH
84592: LD_VAR 0 6
84596: ARRAY
84597: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84598: LD_ADDR_VAR 0 8
84602: PUSH
84603: LD_VAR 0 8
84607: PPUSH
84608: LD_VAR 0 6
84612: PPUSH
84613: CALL_OW 3
84617: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84618: LD_ADDR_VAR 0 8
84622: PUSH
84623: LD_VAR 0 8
84627: PPUSH
84628: LD_INT 1
84630: PPUSH
84631: LD_VAR 0 9
84635: PPUSH
84636: CALL_OW 2
84640: ST_TO_ADDR
// end ;
84641: GO 84558
84643: POP
84644: POP
// for i in tmp do
84645: LD_ADDR_VAR 0 6
84649: PUSH
84650: LD_VAR 0 8
84654: PUSH
84655: FOR_IN
84656: IFFALSE 84725
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
84658: LD_VAR 0 6
84662: PPUSH
84663: CALL_OW 313
84667: PUSH
84668: LD_INT 6
84670: LESS
84671: PUSH
84672: LD_VAR 0 6
84676: PPUSH
84677: CALL_OW 266
84681: PUSH
84682: LD_INT 31
84684: PUSH
84685: LD_INT 32
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: IN
84692: NOT
84693: AND
84694: PUSH
84695: LD_VAR 0 6
84699: PPUSH
84700: CALL_OW 313
84704: PUSH
84705: LD_INT 0
84707: EQUAL
84708: OR
84709: IFFALSE 84723
// begin j := i ;
84711: LD_ADDR_VAR 0 7
84715: PUSH
84716: LD_VAR 0 6
84720: ST_TO_ADDR
// break ;
84721: GO 84725
// end ; end ;
84723: GO 84655
84725: POP
84726: POP
// if j then
84727: LD_VAR 0 7
84731: IFFALSE 84749
// ComEnterUnit ( unit , j ) else
84733: LD_VAR 0 3
84737: PPUSH
84738: LD_VAR 0 7
84742: PPUSH
84743: CALL_OW 120
84747: GO 84852
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84749: LD_ADDR_VAR 0 10
84753: PUSH
84754: LD_VAR 0 2
84758: PPUSH
84759: LD_INT 2
84761: PUSH
84762: LD_INT 30
84764: PUSH
84765: LD_INT 0
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 30
84774: PUSH
84775: LD_INT 1
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: LIST
84786: PPUSH
84787: CALL_OW 72
84791: ST_TO_ADDR
// if depot then
84792: LD_VAR 0 10
84796: IFFALSE 84852
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84798: LD_ADDR_VAR 0 10
84802: PUSH
84803: LD_VAR 0 10
84807: PPUSH
84808: LD_VAR 0 3
84812: PPUSH
84813: CALL_OW 74
84817: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84818: LD_VAR 0 3
84822: PPUSH
84823: LD_VAR 0 10
84827: PPUSH
84828: CALL_OW 296
84832: PUSH
84833: LD_INT 10
84835: GREATER
84836: IFFALSE 84852
// ComStandNearbyBuilding ( unit , depot ) ;
84838: LD_VAR 0 3
84842: PPUSH
84843: LD_VAR 0 10
84847: PPUSH
84848: CALL 21450 0 2
// end ; end ; end ;
84852: LD_VAR 0 5
84856: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84857: LD_INT 0
84859: PPUSH
84860: PPUSH
84861: PPUSH
84862: PPUSH
// if not mc_bases then
84863: LD_EXP 49
84867: NOT
84868: IFFALSE 84872
// exit ;
84870: GO 85111
// for i = 1 to mc_bases do
84872: LD_ADDR_VAR 0 2
84876: PUSH
84877: DOUBLE
84878: LD_INT 1
84880: DEC
84881: ST_TO_ADDR
84882: LD_EXP 49
84886: PUSH
84887: FOR_TO
84888: IFFALSE 85109
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84890: LD_ADDR_VAR 0 4
84894: PUSH
84895: LD_EXP 49
84899: PUSH
84900: LD_VAR 0 2
84904: ARRAY
84905: PPUSH
84906: LD_INT 21
84908: PUSH
84909: LD_INT 1
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PPUSH
84916: CALL_OW 72
84920: PUSH
84921: LD_EXP 78
84925: PUSH
84926: LD_VAR 0 2
84930: ARRAY
84931: UNION
84932: ST_TO_ADDR
// if not tmp then
84933: LD_VAR 0 4
84937: NOT
84938: IFFALSE 84942
// continue ;
84940: GO 84887
// for j in tmp do
84942: LD_ADDR_VAR 0 3
84946: PUSH
84947: LD_VAR 0 4
84951: PUSH
84952: FOR_IN
84953: IFFALSE 85105
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
84955: LD_VAR 0 3
84959: PPUSH
84960: CALL_OW 110
84964: NOT
84965: PUSH
84966: LD_VAR 0 3
84970: PPUSH
84971: CALL_OW 314
84975: NOT
84976: AND
84977: PUSH
84978: LD_VAR 0 3
84982: PPUSH
84983: CALL_OW 311
84987: NOT
84988: AND
84989: PUSH
84990: LD_VAR 0 3
84994: PPUSH
84995: CALL_OW 310
84999: NOT
85000: AND
85001: PUSH
85002: LD_VAR 0 3
85006: PUSH
85007: LD_EXP 52
85011: PUSH
85012: LD_VAR 0 2
85016: ARRAY
85017: PUSH
85018: LD_INT 1
85020: ARRAY
85021: IN
85022: NOT
85023: AND
85024: PUSH
85025: LD_VAR 0 3
85029: PUSH
85030: LD_EXP 52
85034: PUSH
85035: LD_VAR 0 2
85039: ARRAY
85040: PUSH
85041: LD_INT 2
85043: ARRAY
85044: IN
85045: NOT
85046: AND
85047: PUSH
85048: LD_VAR 0 3
85052: PUSH
85053: LD_EXP 61
85057: PUSH
85058: LD_VAR 0 2
85062: ARRAY
85063: IN
85064: NOT
85065: AND
85066: IFFALSE 85103
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85068: LD_VAR 0 2
85072: PPUSH
85073: LD_EXP 49
85077: PUSH
85078: LD_VAR 0 2
85082: ARRAY
85083: PPUSH
85084: LD_VAR 0 3
85088: PPUSH
85089: LD_VAR 0 3
85093: PPUSH
85094: CALL_OW 257
85098: PPUSH
85099: CALL 83875 0 4
// end ;
85103: GO 84952
85105: POP
85106: POP
// end ;
85107: GO 84887
85109: POP
85110: POP
// end ;
85111: LD_VAR 0 1
85115: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
85116: LD_INT 0
85118: PPUSH
85119: PPUSH
85120: PPUSH
85121: PPUSH
85122: PPUSH
85123: PPUSH
// if not mc_bases [ base ] then
85124: LD_EXP 49
85128: PUSH
85129: LD_VAR 0 1
85133: ARRAY
85134: NOT
85135: IFFALSE 85139
// exit ;
85137: GO 85321
// tmp := [ ] ;
85139: LD_ADDR_VAR 0 6
85143: PUSH
85144: EMPTY
85145: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85146: LD_ADDR_VAR 0 7
85150: PUSH
85151: LD_VAR 0 3
85155: PPUSH
85156: LD_INT 0
85158: PPUSH
85159: CALL_OW 517
85163: ST_TO_ADDR
// if not list then
85164: LD_VAR 0 7
85168: NOT
85169: IFFALSE 85173
// exit ;
85171: GO 85321
// for i = 1 to amount do
85173: LD_ADDR_VAR 0 5
85177: PUSH
85178: DOUBLE
85179: LD_INT 1
85181: DEC
85182: ST_TO_ADDR
85183: LD_VAR 0 2
85187: PUSH
85188: FOR_TO
85189: IFFALSE 85269
// begin x := rand ( 1 , list [ 1 ] ) ;
85191: LD_ADDR_VAR 0 8
85195: PUSH
85196: LD_INT 1
85198: PPUSH
85199: LD_VAR 0 7
85203: PUSH
85204: LD_INT 1
85206: ARRAY
85207: PPUSH
85208: CALL_OW 12
85212: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
85213: LD_ADDR_VAR 0 6
85217: PUSH
85218: LD_VAR 0 6
85222: PPUSH
85223: LD_VAR 0 5
85227: PPUSH
85228: LD_VAR 0 7
85232: PUSH
85233: LD_INT 1
85235: ARRAY
85236: PUSH
85237: LD_VAR 0 8
85241: ARRAY
85242: PUSH
85243: LD_VAR 0 7
85247: PUSH
85248: LD_INT 2
85250: ARRAY
85251: PUSH
85252: LD_VAR 0 8
85256: ARRAY
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: PPUSH
85262: CALL_OW 1
85266: ST_TO_ADDR
// end ;
85267: GO 85188
85269: POP
85270: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85271: LD_ADDR_EXP 62
85275: PUSH
85276: LD_EXP 62
85280: PPUSH
85281: LD_VAR 0 1
85285: PPUSH
85286: LD_VAR 0 6
85290: PPUSH
85291: CALL_OW 1
85295: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85296: LD_ADDR_EXP 64
85300: PUSH
85301: LD_EXP 64
85305: PPUSH
85306: LD_VAR 0 1
85310: PPUSH
85311: LD_VAR 0 3
85315: PPUSH
85316: CALL_OW 1
85320: ST_TO_ADDR
// end ;
85321: LD_VAR 0 4
85325: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85326: LD_INT 0
85328: PPUSH
// if not mc_bases [ base ] then
85329: LD_EXP 49
85333: PUSH
85334: LD_VAR 0 1
85338: ARRAY
85339: NOT
85340: IFFALSE 85344
// exit ;
85342: GO 85369
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85344: LD_ADDR_EXP 54
85348: PUSH
85349: LD_EXP 54
85353: PPUSH
85354: LD_VAR 0 1
85358: PPUSH
85359: LD_VAR 0 2
85363: PPUSH
85364: CALL_OW 1
85368: ST_TO_ADDR
// end ;
85369: LD_VAR 0 3
85373: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85374: LD_INT 0
85376: PPUSH
// if not mc_bases [ base ] then
85377: LD_EXP 49
85381: PUSH
85382: LD_VAR 0 1
85386: ARRAY
85387: NOT
85388: IFFALSE 85392
// exit ;
85390: GO 85429
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85392: LD_ADDR_EXP 54
85396: PUSH
85397: LD_EXP 54
85401: PPUSH
85402: LD_VAR 0 1
85406: PPUSH
85407: LD_EXP 54
85411: PUSH
85412: LD_VAR 0 1
85416: ARRAY
85417: PUSH
85418: LD_VAR 0 2
85422: UNION
85423: PPUSH
85424: CALL_OW 1
85428: ST_TO_ADDR
// end ;
85429: LD_VAR 0 3
85433: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85434: LD_INT 0
85436: PPUSH
// if not mc_bases [ base ] then
85437: LD_EXP 49
85441: PUSH
85442: LD_VAR 0 1
85446: ARRAY
85447: NOT
85448: IFFALSE 85452
// exit ;
85450: GO 85477
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85452: LD_ADDR_EXP 70
85456: PUSH
85457: LD_EXP 70
85461: PPUSH
85462: LD_VAR 0 1
85466: PPUSH
85467: LD_VAR 0 2
85471: PPUSH
85472: CALL_OW 1
85476: ST_TO_ADDR
// end ;
85477: LD_VAR 0 3
85481: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85482: LD_INT 0
85484: PPUSH
// if not mc_bases [ base ] then
85485: LD_EXP 49
85489: PUSH
85490: LD_VAR 0 1
85494: ARRAY
85495: NOT
85496: IFFALSE 85500
// exit ;
85498: GO 85537
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85500: LD_ADDR_EXP 70
85504: PUSH
85505: LD_EXP 70
85509: PPUSH
85510: LD_VAR 0 1
85514: PPUSH
85515: LD_EXP 70
85519: PUSH
85520: LD_VAR 0 1
85524: ARRAY
85525: PUSH
85526: LD_VAR 0 2
85530: ADD
85531: PPUSH
85532: CALL_OW 1
85536: ST_TO_ADDR
// end ;
85537: LD_VAR 0 3
85541: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85542: LD_INT 0
85544: PPUSH
// if not mc_bases [ base ] then
85545: LD_EXP 49
85549: PUSH
85550: LD_VAR 0 1
85554: ARRAY
85555: NOT
85556: IFFALSE 85560
// exit ;
85558: GO 85614
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85560: LD_ADDR_EXP 71
85564: PUSH
85565: LD_EXP 71
85569: PPUSH
85570: LD_VAR 0 1
85574: PPUSH
85575: LD_VAR 0 2
85579: PPUSH
85580: CALL_OW 1
85584: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85585: LD_ADDR_EXP 60
85589: PUSH
85590: LD_EXP 60
85594: PPUSH
85595: LD_VAR 0 1
85599: PPUSH
85600: LD_VAR 0 2
85604: PUSH
85605: LD_INT 0
85607: PLUS
85608: PPUSH
85609: CALL_OW 1
85613: ST_TO_ADDR
// end ;
85614: LD_VAR 0 3
85618: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85619: LD_INT 0
85621: PPUSH
// if not mc_bases [ base ] then
85622: LD_EXP 49
85626: PUSH
85627: LD_VAR 0 1
85631: ARRAY
85632: NOT
85633: IFFALSE 85637
// exit ;
85635: GO 85662
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85637: LD_ADDR_EXP 60
85641: PUSH
85642: LD_EXP 60
85646: PPUSH
85647: LD_VAR 0 1
85651: PPUSH
85652: LD_VAR 0 2
85656: PPUSH
85657: CALL_OW 1
85661: ST_TO_ADDR
// end ;
85662: LD_VAR 0 3
85666: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85667: LD_INT 0
85669: PPUSH
85670: PPUSH
85671: PPUSH
85672: PPUSH
// if not mc_bases [ base ] then
85673: LD_EXP 49
85677: PUSH
85678: LD_VAR 0 1
85682: ARRAY
85683: NOT
85684: IFFALSE 85688
// exit ;
85686: GO 85753
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85688: LD_ADDR_EXP 69
85692: PUSH
85693: LD_EXP 69
85697: PPUSH
85698: LD_VAR 0 1
85702: PUSH
85703: LD_EXP 69
85707: PUSH
85708: LD_VAR 0 1
85712: ARRAY
85713: PUSH
85714: LD_INT 1
85716: PLUS
85717: PUSH
85718: EMPTY
85719: LIST
85720: LIST
85721: PPUSH
85722: LD_VAR 0 1
85726: PUSH
85727: LD_VAR 0 2
85731: PUSH
85732: LD_VAR 0 3
85736: PUSH
85737: LD_VAR 0 4
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: PPUSH
85748: CALL 25025 0 3
85752: ST_TO_ADDR
// end ;
85753: LD_VAR 0 5
85757: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85758: LD_INT 0
85760: PPUSH
// if not mc_bases [ base ] then
85761: LD_EXP 49
85765: PUSH
85766: LD_VAR 0 1
85770: ARRAY
85771: NOT
85772: IFFALSE 85776
// exit ;
85774: GO 85801
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85776: LD_ADDR_EXP 86
85780: PUSH
85781: LD_EXP 86
85785: PPUSH
85786: LD_VAR 0 1
85790: PPUSH
85791: LD_VAR 0 2
85795: PPUSH
85796: CALL_OW 1
85800: ST_TO_ADDR
// end ;
85801: LD_VAR 0 3
85805: RET
// export function MC_GetMinesField ( base ) ; begin
85806: LD_INT 0
85808: PPUSH
// result := mc_mines [ base ] ;
85809: LD_ADDR_VAR 0 2
85813: PUSH
85814: LD_EXP 62
85818: PUSH
85819: LD_VAR 0 1
85823: ARRAY
85824: ST_TO_ADDR
// end ;
85825: LD_VAR 0 2
85829: RET
// export function MC_GetProduceList ( base ) ; begin
85830: LD_INT 0
85832: PPUSH
// result := mc_produce [ base ] ;
85833: LD_ADDR_VAR 0 2
85837: PUSH
85838: LD_EXP 70
85842: PUSH
85843: LD_VAR 0 1
85847: ARRAY
85848: ST_TO_ADDR
// end ;
85849: LD_VAR 0 2
85853: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85854: LD_INT 0
85856: PPUSH
85857: PPUSH
// if not mc_bases then
85858: LD_EXP 49
85862: NOT
85863: IFFALSE 85867
// exit ;
85865: GO 85932
// if mc_bases [ base ] then
85867: LD_EXP 49
85871: PUSH
85872: LD_VAR 0 1
85876: ARRAY
85877: IFFALSE 85932
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85879: LD_ADDR_VAR 0 3
85883: PUSH
85884: LD_EXP 49
85888: PUSH
85889: LD_VAR 0 1
85893: ARRAY
85894: PPUSH
85895: LD_INT 30
85897: PUSH
85898: LD_VAR 0 2
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PPUSH
85907: CALL_OW 72
85911: ST_TO_ADDR
// if result then
85912: LD_VAR 0 3
85916: IFFALSE 85932
// result := result [ 1 ] ;
85918: LD_ADDR_VAR 0 3
85922: PUSH
85923: LD_VAR 0 3
85927: PUSH
85928: LD_INT 1
85930: ARRAY
85931: ST_TO_ADDR
// end ; end ;
85932: LD_VAR 0 3
85936: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
85937: LD_INT 0
85939: PPUSH
85940: PPUSH
// if not mc_bases then
85941: LD_EXP 49
85945: NOT
85946: IFFALSE 85950
// exit ;
85948: GO 85995
// if mc_bases [ base ] then
85950: LD_EXP 49
85954: PUSH
85955: LD_VAR 0 1
85959: ARRAY
85960: IFFALSE 85995
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85962: LD_ADDR_VAR 0 3
85966: PUSH
85967: LD_EXP 49
85971: PUSH
85972: LD_VAR 0 1
85976: ARRAY
85977: PPUSH
85978: LD_INT 30
85980: PUSH
85981: LD_VAR 0 2
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PPUSH
85990: CALL_OW 72
85994: ST_TO_ADDR
// end ;
85995: LD_VAR 0 3
85999: RET
// export function MC_SetTame ( base , area ) ; begin
86000: LD_INT 0
86002: PPUSH
// if not mc_bases or not base then
86003: LD_EXP 49
86007: NOT
86008: PUSH
86009: LD_VAR 0 1
86013: NOT
86014: OR
86015: IFFALSE 86019
// exit ;
86017: GO 86044
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86019: LD_ADDR_EXP 77
86023: PUSH
86024: LD_EXP 77
86028: PPUSH
86029: LD_VAR 0 1
86033: PPUSH
86034: LD_VAR 0 2
86038: PPUSH
86039: CALL_OW 1
86043: ST_TO_ADDR
// end ;
86044: LD_VAR 0 3
86048: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86049: LD_INT 0
86051: PPUSH
86052: PPUSH
// if not mc_bases or not base then
86053: LD_EXP 49
86057: NOT
86058: PUSH
86059: LD_VAR 0 1
86063: NOT
86064: OR
86065: IFFALSE 86069
// exit ;
86067: GO 86171
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86069: LD_ADDR_VAR 0 4
86073: PUSH
86074: LD_EXP 49
86078: PUSH
86079: LD_VAR 0 1
86083: ARRAY
86084: PPUSH
86085: LD_INT 30
86087: PUSH
86088: LD_VAR 0 2
86092: PUSH
86093: EMPTY
86094: LIST
86095: LIST
86096: PPUSH
86097: CALL_OW 72
86101: ST_TO_ADDR
// if not tmp then
86102: LD_VAR 0 4
86106: NOT
86107: IFFALSE 86111
// exit ;
86109: GO 86171
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86111: LD_ADDR_EXP 81
86115: PUSH
86116: LD_EXP 81
86120: PPUSH
86121: LD_VAR 0 1
86125: PPUSH
86126: LD_EXP 81
86130: PUSH
86131: LD_VAR 0 1
86135: ARRAY
86136: PPUSH
86137: LD_EXP 81
86141: PUSH
86142: LD_VAR 0 1
86146: ARRAY
86147: PUSH
86148: LD_INT 1
86150: PLUS
86151: PPUSH
86152: LD_VAR 0 4
86156: PUSH
86157: LD_INT 1
86159: ARRAY
86160: PPUSH
86161: CALL_OW 2
86165: PPUSH
86166: CALL_OW 1
86170: ST_TO_ADDR
// end ;
86171: LD_VAR 0 3
86175: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86176: LD_INT 0
86178: PPUSH
86179: PPUSH
// if not mc_bases or not base or not kinds then
86180: LD_EXP 49
86184: NOT
86185: PUSH
86186: LD_VAR 0 1
86190: NOT
86191: OR
86192: PUSH
86193: LD_VAR 0 2
86197: NOT
86198: OR
86199: IFFALSE 86203
// exit ;
86201: GO 86264
// for i in kinds do
86203: LD_ADDR_VAR 0 4
86207: PUSH
86208: LD_VAR 0 2
86212: PUSH
86213: FOR_IN
86214: IFFALSE 86262
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86216: LD_ADDR_EXP 83
86220: PUSH
86221: LD_EXP 83
86225: PPUSH
86226: LD_VAR 0 1
86230: PUSH
86231: LD_EXP 83
86235: PUSH
86236: LD_VAR 0 1
86240: ARRAY
86241: PUSH
86242: LD_INT 1
86244: PLUS
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PPUSH
86250: LD_VAR 0 4
86254: PPUSH
86255: CALL 25025 0 3
86259: ST_TO_ADDR
86260: GO 86213
86262: POP
86263: POP
// end ;
86264: LD_VAR 0 3
86268: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86269: LD_INT 0
86271: PPUSH
// if not mc_bases or not base or not areas then
86272: LD_EXP 49
86276: NOT
86277: PUSH
86278: LD_VAR 0 1
86282: NOT
86283: OR
86284: PUSH
86285: LD_VAR 0 2
86289: NOT
86290: OR
86291: IFFALSE 86295
// exit ;
86293: GO 86320
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86295: LD_ADDR_EXP 67
86299: PUSH
86300: LD_EXP 67
86304: PPUSH
86305: LD_VAR 0 1
86309: PPUSH
86310: LD_VAR 0 2
86314: PPUSH
86315: CALL_OW 1
86319: ST_TO_ADDR
// end ;
86320: LD_VAR 0 3
86324: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86325: LD_INT 0
86327: PPUSH
// if not mc_bases or not base or not teleports_exit then
86328: LD_EXP 49
86332: NOT
86333: PUSH
86334: LD_VAR 0 1
86338: NOT
86339: OR
86340: PUSH
86341: LD_VAR 0 2
86345: NOT
86346: OR
86347: IFFALSE 86351
// exit ;
86349: GO 86376
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86351: LD_ADDR_EXP 84
86355: PUSH
86356: LD_EXP 84
86360: PPUSH
86361: LD_VAR 0 1
86365: PPUSH
86366: LD_VAR 0 2
86370: PPUSH
86371: CALL_OW 1
86375: ST_TO_ADDR
// end ;
86376: LD_VAR 0 3
86380: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86381: LD_INT 0
86383: PPUSH
86384: PPUSH
86385: PPUSH
// if not mc_bases or not base or not ext_list then
86386: LD_EXP 49
86390: NOT
86391: PUSH
86392: LD_VAR 0 1
86396: NOT
86397: OR
86398: PUSH
86399: LD_VAR 0 5
86403: NOT
86404: OR
86405: IFFALSE 86409
// exit ;
86407: GO 86582
// tmp := GetFacExtXYD ( x , y , d ) ;
86409: LD_ADDR_VAR 0 8
86413: PUSH
86414: LD_VAR 0 2
86418: PPUSH
86419: LD_VAR 0 3
86423: PPUSH
86424: LD_VAR 0 4
86428: PPUSH
86429: CALL 54926 0 3
86433: ST_TO_ADDR
// if not tmp then
86434: LD_VAR 0 8
86438: NOT
86439: IFFALSE 86443
// exit ;
86441: GO 86582
// for i in tmp do
86443: LD_ADDR_VAR 0 7
86447: PUSH
86448: LD_VAR 0 8
86452: PUSH
86453: FOR_IN
86454: IFFALSE 86580
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86456: LD_ADDR_EXP 54
86460: PUSH
86461: LD_EXP 54
86465: PPUSH
86466: LD_VAR 0 1
86470: PPUSH
86471: LD_EXP 54
86475: PUSH
86476: LD_VAR 0 1
86480: ARRAY
86481: PPUSH
86482: LD_EXP 54
86486: PUSH
86487: LD_VAR 0 1
86491: ARRAY
86492: PUSH
86493: LD_INT 1
86495: PLUS
86496: PPUSH
86497: LD_VAR 0 5
86501: PUSH
86502: LD_INT 1
86504: ARRAY
86505: PUSH
86506: LD_VAR 0 7
86510: PUSH
86511: LD_INT 1
86513: ARRAY
86514: PUSH
86515: LD_VAR 0 7
86519: PUSH
86520: LD_INT 2
86522: ARRAY
86523: PUSH
86524: LD_VAR 0 7
86528: PUSH
86529: LD_INT 3
86531: ARRAY
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: LIST
86537: LIST
86538: PPUSH
86539: CALL_OW 2
86543: PPUSH
86544: CALL_OW 1
86548: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86549: LD_ADDR_VAR 0 5
86553: PUSH
86554: LD_VAR 0 5
86558: PPUSH
86559: LD_INT 1
86561: PPUSH
86562: CALL_OW 3
86566: ST_TO_ADDR
// if not ext_list then
86567: LD_VAR 0 5
86571: NOT
86572: IFFALSE 86578
// exit ;
86574: POP
86575: POP
86576: GO 86582
// end ;
86578: GO 86453
86580: POP
86581: POP
// end ;
86582: LD_VAR 0 6
86586: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86587: LD_INT 0
86589: PPUSH
// if not mc_bases or not base or not weapon_list then
86590: LD_EXP 49
86594: NOT
86595: PUSH
86596: LD_VAR 0 1
86600: NOT
86601: OR
86602: PUSH
86603: LD_VAR 0 2
86607: NOT
86608: OR
86609: IFFALSE 86613
// exit ;
86611: GO 86638
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86613: LD_ADDR_EXP 88
86617: PUSH
86618: LD_EXP 88
86622: PPUSH
86623: LD_VAR 0 1
86627: PPUSH
86628: LD_VAR 0 2
86632: PPUSH
86633: CALL_OW 1
86637: ST_TO_ADDR
// end ;
86638: LD_VAR 0 3
86642: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86643: LD_INT 0
86645: PPUSH
// if not mc_bases or not base or not tech_list then
86646: LD_EXP 49
86650: NOT
86651: PUSH
86652: LD_VAR 0 1
86656: NOT
86657: OR
86658: PUSH
86659: LD_VAR 0 2
86663: NOT
86664: OR
86665: IFFALSE 86669
// exit ;
86667: GO 86694
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86669: LD_ADDR_EXP 76
86673: PUSH
86674: LD_EXP 76
86678: PPUSH
86679: LD_VAR 0 1
86683: PPUSH
86684: LD_VAR 0 2
86688: PPUSH
86689: CALL_OW 1
86693: ST_TO_ADDR
// end ;
86694: LD_VAR 0 3
86698: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86699: LD_INT 0
86701: PPUSH
// if not mc_bases or not parking_area or not base then
86702: LD_EXP 49
86706: NOT
86707: PUSH
86708: LD_VAR 0 2
86712: NOT
86713: OR
86714: PUSH
86715: LD_VAR 0 1
86719: NOT
86720: OR
86721: IFFALSE 86725
// exit ;
86723: GO 86750
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86725: LD_ADDR_EXP 73
86729: PUSH
86730: LD_EXP 73
86734: PPUSH
86735: LD_VAR 0 1
86739: PPUSH
86740: LD_VAR 0 2
86744: PPUSH
86745: CALL_OW 1
86749: ST_TO_ADDR
// end ;
86750: LD_VAR 0 3
86754: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86755: LD_INT 0
86757: PPUSH
// if not mc_bases or not base or not scan_area then
86758: LD_EXP 49
86762: NOT
86763: PUSH
86764: LD_VAR 0 1
86768: NOT
86769: OR
86770: PUSH
86771: LD_VAR 0 2
86775: NOT
86776: OR
86777: IFFALSE 86781
// exit ;
86779: GO 86806
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86781: LD_ADDR_EXP 74
86785: PUSH
86786: LD_EXP 74
86790: PPUSH
86791: LD_VAR 0 1
86795: PPUSH
86796: LD_VAR 0 2
86800: PPUSH
86801: CALL_OW 1
86805: ST_TO_ADDR
// end ;
86806: LD_VAR 0 3
86810: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86811: LD_INT 0
86813: PPUSH
86814: PPUSH
// if not mc_bases or not base then
86815: LD_EXP 49
86819: NOT
86820: PUSH
86821: LD_VAR 0 1
86825: NOT
86826: OR
86827: IFFALSE 86831
// exit ;
86829: GO 86895
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86831: LD_ADDR_VAR 0 3
86835: PUSH
86836: LD_INT 1
86838: PUSH
86839: LD_INT 2
86841: PUSH
86842: LD_INT 3
86844: PUSH
86845: LD_INT 4
86847: PUSH
86848: LD_INT 11
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86858: LD_ADDR_EXP 76
86862: PUSH
86863: LD_EXP 76
86867: PPUSH
86868: LD_VAR 0 1
86872: PPUSH
86873: LD_EXP 76
86877: PUSH
86878: LD_VAR 0 1
86882: ARRAY
86883: PUSH
86884: LD_VAR 0 3
86888: DIFF
86889: PPUSH
86890: CALL_OW 1
86894: ST_TO_ADDR
// end ;
86895: LD_VAR 0 2
86899: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86900: LD_INT 0
86902: PPUSH
// result := mc_vehicles [ base ] ;
86903: LD_ADDR_VAR 0 3
86907: PUSH
86908: LD_EXP 68
86912: PUSH
86913: LD_VAR 0 1
86917: ARRAY
86918: ST_TO_ADDR
// if onlyCombat then
86919: LD_VAR 0 2
86923: IFFALSE 87101
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
86925: LD_ADDR_VAR 0 3
86929: PUSH
86930: LD_VAR 0 3
86934: PUSH
86935: LD_VAR 0 3
86939: PPUSH
86940: LD_INT 2
86942: PUSH
86943: LD_INT 34
86945: PUSH
86946: LD_INT 12
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 34
86955: PUSH
86956: LD_INT 51
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: PUSH
86963: LD_INT 34
86965: PUSH
86966: LD_EXP 30
86970: PUSH
86971: EMPTY
86972: LIST
86973: LIST
86974: PUSH
86975: LD_INT 34
86977: PUSH
86978: LD_INT 32
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 34
86987: PUSH
86988: LD_INT 13
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: PUSH
86995: LD_INT 34
86997: PUSH
86998: LD_INT 52
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 34
87007: PUSH
87008: LD_EXP 35
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PUSH
87017: LD_INT 34
87019: PUSH
87020: LD_INT 14
87022: PUSH
87023: EMPTY
87024: LIST
87025: LIST
87026: PUSH
87027: LD_INT 34
87029: PUSH
87030: LD_INT 53
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: LD_INT 34
87039: PUSH
87040: LD_EXP 29
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 34
87051: PUSH
87052: LD_INT 31
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 34
87061: PUSH
87062: LD_INT 48
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 34
87071: PUSH
87072: LD_INT 8
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: PPUSH
87095: CALL_OW 72
87099: DIFF
87100: ST_TO_ADDR
// end ; end_of_file
87101: LD_VAR 0 3
87105: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87106: LD_INT 0
87108: PPUSH
87109: PPUSH
87110: PPUSH
// if not mc_bases or not skirmish then
87111: LD_EXP 49
87115: NOT
87116: PUSH
87117: LD_EXP 47
87121: NOT
87122: OR
87123: IFFALSE 87127
// exit ;
87125: GO 87292
// for i = 1 to mc_bases do
87127: LD_ADDR_VAR 0 4
87131: PUSH
87132: DOUBLE
87133: LD_INT 1
87135: DEC
87136: ST_TO_ADDR
87137: LD_EXP 49
87141: PUSH
87142: FOR_TO
87143: IFFALSE 87290
// begin if sci in mc_bases [ i ] then
87145: LD_VAR 0 2
87149: PUSH
87150: LD_EXP 49
87154: PUSH
87155: LD_VAR 0 4
87159: ARRAY
87160: IN
87161: IFFALSE 87288
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87163: LD_ADDR_EXP 78
87167: PUSH
87168: LD_EXP 78
87172: PPUSH
87173: LD_VAR 0 4
87177: PUSH
87178: LD_EXP 78
87182: PUSH
87183: LD_VAR 0 4
87187: ARRAY
87188: PUSH
87189: LD_INT 1
87191: PLUS
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PPUSH
87197: LD_VAR 0 1
87201: PPUSH
87202: CALL 25025 0 3
87206: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87207: LD_ADDR_VAR 0 5
87211: PUSH
87212: LD_EXP 49
87216: PUSH
87217: LD_VAR 0 4
87221: ARRAY
87222: PPUSH
87223: LD_INT 2
87225: PUSH
87226: LD_INT 30
87228: PUSH
87229: LD_INT 0
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: PUSH
87236: LD_INT 30
87238: PUSH
87239: LD_INT 1
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: LIST
87250: PPUSH
87251: CALL_OW 72
87255: PPUSH
87256: LD_VAR 0 1
87260: PPUSH
87261: CALL_OW 74
87265: ST_TO_ADDR
// if tmp then
87266: LD_VAR 0 5
87270: IFFALSE 87286
// ComStandNearbyBuilding ( ape , tmp ) ;
87272: LD_VAR 0 1
87276: PPUSH
87277: LD_VAR 0 5
87281: PPUSH
87282: CALL 21450 0 2
// break ;
87286: GO 87290
// end ; end ;
87288: GO 87142
87290: POP
87291: POP
// end ;
87292: LD_VAR 0 3
87296: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87297: LD_INT 0
87299: PPUSH
87300: PPUSH
87301: PPUSH
// if not mc_bases or not skirmish then
87302: LD_EXP 49
87306: NOT
87307: PUSH
87308: LD_EXP 47
87312: NOT
87313: OR
87314: IFFALSE 87318
// exit ;
87316: GO 87407
// for i = 1 to mc_bases do
87318: LD_ADDR_VAR 0 4
87322: PUSH
87323: DOUBLE
87324: LD_INT 1
87326: DEC
87327: ST_TO_ADDR
87328: LD_EXP 49
87332: PUSH
87333: FOR_TO
87334: IFFALSE 87405
// begin if building in mc_busy_turret_list [ i ] then
87336: LD_VAR 0 1
87340: PUSH
87341: LD_EXP 59
87345: PUSH
87346: LD_VAR 0 4
87350: ARRAY
87351: IN
87352: IFFALSE 87403
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87354: LD_ADDR_VAR 0 5
87358: PUSH
87359: LD_EXP 59
87363: PUSH
87364: LD_VAR 0 4
87368: ARRAY
87369: PUSH
87370: LD_VAR 0 1
87374: DIFF
87375: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87376: LD_ADDR_EXP 59
87380: PUSH
87381: LD_EXP 59
87385: PPUSH
87386: LD_VAR 0 4
87390: PPUSH
87391: LD_VAR 0 5
87395: PPUSH
87396: CALL_OW 1
87400: ST_TO_ADDR
// break ;
87401: GO 87405
// end ; end ;
87403: GO 87333
87405: POP
87406: POP
// end ;
87407: LD_VAR 0 3
87411: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87412: LD_INT 0
87414: PPUSH
87415: PPUSH
87416: PPUSH
// if not mc_bases or not skirmish then
87417: LD_EXP 49
87421: NOT
87422: PUSH
87423: LD_EXP 47
87427: NOT
87428: OR
87429: IFFALSE 87433
// exit ;
87431: GO 87632
// for i = 1 to mc_bases do
87433: LD_ADDR_VAR 0 5
87437: PUSH
87438: DOUBLE
87439: LD_INT 1
87441: DEC
87442: ST_TO_ADDR
87443: LD_EXP 49
87447: PUSH
87448: FOR_TO
87449: IFFALSE 87630
// if building in mc_bases [ i ] then
87451: LD_VAR 0 1
87455: PUSH
87456: LD_EXP 49
87460: PUSH
87461: LD_VAR 0 5
87465: ARRAY
87466: IN
87467: IFFALSE 87628
// begin tmp := mc_bases [ i ] diff building ;
87469: LD_ADDR_VAR 0 6
87473: PUSH
87474: LD_EXP 49
87478: PUSH
87479: LD_VAR 0 5
87483: ARRAY
87484: PUSH
87485: LD_VAR 0 1
87489: DIFF
87490: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87491: LD_ADDR_EXP 49
87495: PUSH
87496: LD_EXP 49
87500: PPUSH
87501: LD_VAR 0 5
87505: PPUSH
87506: LD_VAR 0 6
87510: PPUSH
87511: CALL_OW 1
87515: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87516: LD_VAR 0 1
87520: PUSH
87521: LD_EXP 57
87525: PUSH
87526: LD_VAR 0 5
87530: ARRAY
87531: IN
87532: IFFALSE 87571
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87534: LD_ADDR_EXP 57
87538: PUSH
87539: LD_EXP 57
87543: PPUSH
87544: LD_VAR 0 5
87548: PPUSH
87549: LD_EXP 57
87553: PUSH
87554: LD_VAR 0 5
87558: ARRAY
87559: PUSH
87560: LD_VAR 0 1
87564: DIFF
87565: PPUSH
87566: CALL_OW 1
87570: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87571: LD_VAR 0 1
87575: PUSH
87576: LD_EXP 58
87580: PUSH
87581: LD_VAR 0 5
87585: ARRAY
87586: IN
87587: IFFALSE 87626
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87589: LD_ADDR_EXP 58
87593: PUSH
87594: LD_EXP 58
87598: PPUSH
87599: LD_VAR 0 5
87603: PPUSH
87604: LD_EXP 58
87608: PUSH
87609: LD_VAR 0 5
87613: ARRAY
87614: PUSH
87615: LD_VAR 0 1
87619: DIFF
87620: PPUSH
87621: CALL_OW 1
87625: ST_TO_ADDR
// break ;
87626: GO 87630
// end ;
87628: GO 87448
87630: POP
87631: POP
// end ;
87632: LD_VAR 0 4
87636: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87637: LD_INT 0
87639: PPUSH
87640: PPUSH
87641: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87642: LD_EXP 49
87646: NOT
87647: PUSH
87648: LD_EXP 47
87652: NOT
87653: OR
87654: PUSH
87655: LD_VAR 0 3
87659: PUSH
87660: LD_EXP 75
87664: IN
87665: NOT
87666: OR
87667: IFFALSE 87671
// exit ;
87669: GO 87794
// for i = 1 to mc_vehicles do
87671: LD_ADDR_VAR 0 6
87675: PUSH
87676: DOUBLE
87677: LD_INT 1
87679: DEC
87680: ST_TO_ADDR
87681: LD_EXP 68
87685: PUSH
87686: FOR_TO
87687: IFFALSE 87792
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87689: LD_VAR 0 2
87693: PUSH
87694: LD_EXP 68
87698: PUSH
87699: LD_VAR 0 6
87703: ARRAY
87704: IN
87705: PUSH
87706: LD_VAR 0 1
87710: PUSH
87711: LD_EXP 68
87715: PUSH
87716: LD_VAR 0 6
87720: ARRAY
87721: IN
87722: OR
87723: IFFALSE 87790
// begin tmp := mc_vehicles [ i ] diff old ;
87725: LD_ADDR_VAR 0 7
87729: PUSH
87730: LD_EXP 68
87734: PUSH
87735: LD_VAR 0 6
87739: ARRAY
87740: PUSH
87741: LD_VAR 0 2
87745: DIFF
87746: ST_TO_ADDR
// tmp := tmp diff new ;
87747: LD_ADDR_VAR 0 7
87751: PUSH
87752: LD_VAR 0 7
87756: PUSH
87757: LD_VAR 0 1
87761: DIFF
87762: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87763: LD_ADDR_EXP 68
87767: PUSH
87768: LD_EXP 68
87772: PPUSH
87773: LD_VAR 0 6
87777: PPUSH
87778: LD_VAR 0 7
87782: PPUSH
87783: CALL_OW 1
87787: ST_TO_ADDR
// break ;
87788: GO 87792
// end ;
87790: GO 87686
87792: POP
87793: POP
// end ;
87794: LD_VAR 0 5
87798: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87799: LD_INT 0
87801: PPUSH
87802: PPUSH
87803: PPUSH
87804: PPUSH
// if not mc_bases or not skirmish then
87805: LD_EXP 49
87809: NOT
87810: PUSH
87811: LD_EXP 47
87815: NOT
87816: OR
87817: IFFALSE 87821
// exit ;
87819: GO 88213
// side := GetSide ( vehicle ) ;
87821: LD_ADDR_VAR 0 5
87825: PUSH
87826: LD_VAR 0 1
87830: PPUSH
87831: CALL_OW 255
87835: ST_TO_ADDR
// for i = 1 to mc_bases do
87836: LD_ADDR_VAR 0 4
87840: PUSH
87841: DOUBLE
87842: LD_INT 1
87844: DEC
87845: ST_TO_ADDR
87846: LD_EXP 49
87850: PUSH
87851: FOR_TO
87852: IFFALSE 88211
// begin if factory in mc_bases [ i ] then
87854: LD_VAR 0 2
87858: PUSH
87859: LD_EXP 49
87863: PUSH
87864: LD_VAR 0 4
87868: ARRAY
87869: IN
87870: IFFALSE 88209
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87872: LD_EXP 71
87876: PUSH
87877: LD_VAR 0 4
87881: ARRAY
87882: PUSH
87883: LD_EXP 60
87887: PUSH
87888: LD_VAR 0 4
87892: ARRAY
87893: LESS
87894: PUSH
87895: LD_VAR 0 1
87899: PPUSH
87900: CALL_OW 264
87904: PUSH
87905: LD_INT 31
87907: PUSH
87908: LD_INT 32
87910: PUSH
87911: LD_INT 51
87913: PUSH
87914: LD_EXP 30
87918: PUSH
87919: LD_INT 12
87921: PUSH
87922: LD_INT 30
87924: PUSH
87925: LD_EXP 29
87929: PUSH
87930: LD_INT 11
87932: PUSH
87933: LD_INT 53
87935: PUSH
87936: LD_INT 14
87938: PUSH
87939: LD_EXP 33
87943: PUSH
87944: LD_INT 29
87946: PUSH
87947: LD_EXP 31
87951: PUSH
87952: LD_INT 13
87954: PUSH
87955: LD_INT 52
87957: PUSH
87958: LD_EXP 35
87962: PUSH
87963: LD_INT 48
87965: PUSH
87966: LD_INT 8
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: IN
87989: NOT
87990: AND
87991: IFFALSE 88039
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
87993: LD_ADDR_EXP 71
87997: PUSH
87998: LD_EXP 71
88002: PPUSH
88003: LD_VAR 0 4
88007: PUSH
88008: LD_EXP 71
88012: PUSH
88013: LD_VAR 0 4
88017: ARRAY
88018: PUSH
88019: LD_INT 1
88021: PLUS
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PPUSH
88027: LD_VAR 0 1
88031: PPUSH
88032: CALL 25025 0 3
88036: ST_TO_ADDR
88037: GO 88083
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88039: LD_ADDR_EXP 68
88043: PUSH
88044: LD_EXP 68
88048: PPUSH
88049: LD_VAR 0 4
88053: PUSH
88054: LD_EXP 68
88058: PUSH
88059: LD_VAR 0 4
88063: ARRAY
88064: PUSH
88065: LD_INT 1
88067: PLUS
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PPUSH
88073: LD_VAR 0 1
88077: PPUSH
88078: CALL 25025 0 3
88082: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88083: LD_VAR 0 1
88087: PPUSH
88088: CALL_OW 263
88092: PUSH
88093: LD_INT 2
88095: EQUAL
88096: IFFALSE 88125
// begin repeat wait ( 0 0$3 ) ;
88098: LD_INT 105
88100: PPUSH
88101: CALL_OW 67
// Connect ( vehicle ) ;
88105: LD_VAR 0 1
88109: PPUSH
88110: CALL 27996 0 1
// until IsControledBy ( vehicle ) ;
88114: LD_VAR 0 1
88118: PPUSH
88119: CALL_OW 312
88123: IFFALSE 88098
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88125: LD_VAR 0 1
88129: PPUSH
88130: LD_EXP 73
88134: PUSH
88135: LD_VAR 0 4
88139: ARRAY
88140: PPUSH
88141: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88145: LD_VAR 0 1
88149: PPUSH
88150: CALL_OW 263
88154: PUSH
88155: LD_INT 1
88157: NONEQUAL
88158: IFFALSE 88162
// break ;
88160: GO 88211
// repeat wait ( 0 0$1 ) ;
88162: LD_INT 35
88164: PPUSH
88165: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88169: LD_VAR 0 1
88173: PPUSH
88174: LD_EXP 73
88178: PUSH
88179: LD_VAR 0 4
88183: ARRAY
88184: PPUSH
88185: CALL_OW 308
88189: IFFALSE 88162
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88191: LD_VAR 0 1
88195: PPUSH
88196: CALL_OW 311
88200: PPUSH
88201: CALL_OW 121
// exit ;
88205: POP
88206: POP
88207: GO 88213
// end ; end ;
88209: GO 87851
88211: POP
88212: POP
// end ;
88213: LD_VAR 0 3
88217: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88218: LD_INT 0
88220: PPUSH
88221: PPUSH
88222: PPUSH
88223: PPUSH
// if not mc_bases or not skirmish then
88224: LD_EXP 49
88228: NOT
88229: PUSH
88230: LD_EXP 47
88234: NOT
88235: OR
88236: IFFALSE 88240
// exit ;
88238: GO 88593
// repeat wait ( 0 0$1 ) ;
88240: LD_INT 35
88242: PPUSH
88243: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88247: LD_VAR 0 2
88251: PPUSH
88252: LD_VAR 0 3
88256: PPUSH
88257: CALL_OW 284
88261: IFFALSE 88240
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88263: LD_VAR 0 2
88267: PPUSH
88268: LD_VAR 0 3
88272: PPUSH
88273: CALL_OW 283
88277: PUSH
88278: LD_INT 4
88280: EQUAL
88281: IFFALSE 88285
// exit ;
88283: GO 88593
// for i = 1 to mc_bases do
88285: LD_ADDR_VAR 0 7
88289: PUSH
88290: DOUBLE
88291: LD_INT 1
88293: DEC
88294: ST_TO_ADDR
88295: LD_EXP 49
88299: PUSH
88300: FOR_TO
88301: IFFALSE 88591
// begin if mc_crates_area [ i ] then
88303: LD_EXP 67
88307: PUSH
88308: LD_VAR 0 7
88312: ARRAY
88313: IFFALSE 88424
// for j in mc_crates_area [ i ] do
88315: LD_ADDR_VAR 0 8
88319: PUSH
88320: LD_EXP 67
88324: PUSH
88325: LD_VAR 0 7
88329: ARRAY
88330: PUSH
88331: FOR_IN
88332: IFFALSE 88422
// if InArea ( x , y , j ) then
88334: LD_VAR 0 2
88338: PPUSH
88339: LD_VAR 0 3
88343: PPUSH
88344: LD_VAR 0 8
88348: PPUSH
88349: CALL_OW 309
88353: IFFALSE 88420
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88355: LD_ADDR_EXP 65
88359: PUSH
88360: LD_EXP 65
88364: PPUSH
88365: LD_VAR 0 7
88369: PUSH
88370: LD_EXP 65
88374: PUSH
88375: LD_VAR 0 7
88379: ARRAY
88380: PUSH
88381: LD_INT 1
88383: PLUS
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PPUSH
88389: LD_VAR 0 4
88393: PUSH
88394: LD_VAR 0 2
88398: PUSH
88399: LD_VAR 0 3
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: LIST
88408: PPUSH
88409: CALL 25025 0 3
88413: ST_TO_ADDR
// exit ;
88414: POP
88415: POP
88416: POP
88417: POP
88418: GO 88593
// end ;
88420: GO 88331
88422: POP
88423: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88424: LD_ADDR_VAR 0 9
88428: PUSH
88429: LD_EXP 49
88433: PUSH
88434: LD_VAR 0 7
88438: ARRAY
88439: PPUSH
88440: LD_INT 2
88442: PUSH
88443: LD_INT 30
88445: PUSH
88446: LD_INT 0
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 30
88455: PUSH
88456: LD_INT 1
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: LIST
88467: PPUSH
88468: CALL_OW 72
88472: ST_TO_ADDR
// if not depot then
88473: LD_VAR 0 9
88477: NOT
88478: IFFALSE 88482
// continue ;
88480: GO 88300
// for j in depot do
88482: LD_ADDR_VAR 0 8
88486: PUSH
88487: LD_VAR 0 9
88491: PUSH
88492: FOR_IN
88493: IFFALSE 88587
// if GetDistUnitXY ( j , x , y ) < 30 then
88495: LD_VAR 0 8
88499: PPUSH
88500: LD_VAR 0 2
88504: PPUSH
88505: LD_VAR 0 3
88509: PPUSH
88510: CALL_OW 297
88514: PUSH
88515: LD_INT 30
88517: LESS
88518: IFFALSE 88585
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88520: LD_ADDR_EXP 65
88524: PUSH
88525: LD_EXP 65
88529: PPUSH
88530: LD_VAR 0 7
88534: PUSH
88535: LD_EXP 65
88539: PUSH
88540: LD_VAR 0 7
88544: ARRAY
88545: PUSH
88546: LD_INT 1
88548: PLUS
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PPUSH
88554: LD_VAR 0 4
88558: PUSH
88559: LD_VAR 0 2
88563: PUSH
88564: LD_VAR 0 3
88568: PUSH
88569: EMPTY
88570: LIST
88571: LIST
88572: LIST
88573: PPUSH
88574: CALL 25025 0 3
88578: ST_TO_ADDR
// exit ;
88579: POP
88580: POP
88581: POP
88582: POP
88583: GO 88593
// end ;
88585: GO 88492
88587: POP
88588: POP
// end ;
88589: GO 88300
88591: POP
88592: POP
// end ;
88593: LD_VAR 0 6
88597: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88598: LD_INT 0
88600: PPUSH
88601: PPUSH
88602: PPUSH
88603: PPUSH
// if not mc_bases or not skirmish then
88604: LD_EXP 49
88608: NOT
88609: PUSH
88610: LD_EXP 47
88614: NOT
88615: OR
88616: IFFALSE 88620
// exit ;
88618: GO 88897
// side := GetSide ( lab ) ;
88620: LD_ADDR_VAR 0 4
88624: PUSH
88625: LD_VAR 0 2
88629: PPUSH
88630: CALL_OW 255
88634: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88635: LD_VAR 0 4
88639: PUSH
88640: LD_EXP 75
88644: IN
88645: NOT
88646: PUSH
88647: LD_EXP 76
88651: NOT
88652: OR
88653: PUSH
88654: LD_EXP 49
88658: NOT
88659: OR
88660: IFFALSE 88664
// exit ;
88662: GO 88897
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88664: LD_ADDR_EXP 76
88668: PUSH
88669: LD_EXP 76
88673: PPUSH
88674: LD_VAR 0 4
88678: PPUSH
88679: LD_EXP 76
88683: PUSH
88684: LD_VAR 0 4
88688: ARRAY
88689: PUSH
88690: LD_VAR 0 1
88694: DIFF
88695: PPUSH
88696: CALL_OW 1
88700: ST_TO_ADDR
// for i = 1 to mc_bases do
88701: LD_ADDR_VAR 0 5
88705: PUSH
88706: DOUBLE
88707: LD_INT 1
88709: DEC
88710: ST_TO_ADDR
88711: LD_EXP 49
88715: PUSH
88716: FOR_TO
88717: IFFALSE 88895
// begin if lab in mc_bases [ i ] then
88719: LD_VAR 0 2
88723: PUSH
88724: LD_EXP 49
88728: PUSH
88729: LD_VAR 0 5
88733: ARRAY
88734: IN
88735: IFFALSE 88893
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88737: LD_VAR 0 1
88741: PUSH
88742: LD_INT 11
88744: PUSH
88745: LD_INT 4
88747: PUSH
88748: LD_INT 3
88750: PUSH
88751: LD_INT 2
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: LIST
88758: LIST
88759: IN
88760: PUSH
88761: LD_EXP 79
88765: PUSH
88766: LD_VAR 0 5
88770: ARRAY
88771: AND
88772: IFFALSE 88893
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88774: LD_ADDR_VAR 0 6
88778: PUSH
88779: LD_EXP 79
88783: PUSH
88784: LD_VAR 0 5
88788: ARRAY
88789: PUSH
88790: LD_INT 1
88792: ARRAY
88793: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88794: LD_ADDR_EXP 79
88798: PUSH
88799: LD_EXP 79
88803: PPUSH
88804: LD_VAR 0 5
88808: PPUSH
88809: EMPTY
88810: PPUSH
88811: CALL_OW 1
88815: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88816: LD_VAR 0 6
88820: PPUSH
88821: LD_INT 0
88823: PPUSH
88824: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88828: LD_VAR 0 6
88832: PPUSH
88833: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88837: LD_ADDR_EXP 78
88841: PUSH
88842: LD_EXP 78
88846: PPUSH
88847: LD_VAR 0 5
88851: PPUSH
88852: LD_EXP 78
88856: PUSH
88857: LD_VAR 0 5
88861: ARRAY
88862: PPUSH
88863: LD_INT 1
88865: PPUSH
88866: LD_VAR 0 6
88870: PPUSH
88871: CALL_OW 2
88875: PPUSH
88876: CALL_OW 1
88880: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88881: LD_VAR 0 5
88885: PPUSH
88886: LD_INT 112
88888: PPUSH
88889: CALL 65416 0 2
// end ; end ; end ;
88893: GO 88716
88895: POP
88896: POP
// end ;
88897: LD_VAR 0 3
88901: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
88902: LD_INT 0
88904: PPUSH
88905: PPUSH
88906: PPUSH
88907: PPUSH
88908: PPUSH
88909: PPUSH
88910: PPUSH
88911: PPUSH
// if not mc_bases or not skirmish then
88912: LD_EXP 49
88916: NOT
88917: PUSH
88918: LD_EXP 47
88922: NOT
88923: OR
88924: IFFALSE 88928
// exit ;
88926: GO 90299
// for i = 1 to mc_bases do
88928: LD_ADDR_VAR 0 3
88932: PUSH
88933: DOUBLE
88934: LD_INT 1
88936: DEC
88937: ST_TO_ADDR
88938: LD_EXP 49
88942: PUSH
88943: FOR_TO
88944: IFFALSE 90297
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
88946: LD_VAR 0 1
88950: PUSH
88951: LD_EXP 49
88955: PUSH
88956: LD_VAR 0 3
88960: ARRAY
88961: IN
88962: PUSH
88963: LD_VAR 0 1
88967: PUSH
88968: LD_EXP 56
88972: PUSH
88973: LD_VAR 0 3
88977: ARRAY
88978: IN
88979: OR
88980: PUSH
88981: LD_VAR 0 1
88985: PUSH
88986: LD_EXP 71
88990: PUSH
88991: LD_VAR 0 3
88995: ARRAY
88996: IN
88997: OR
88998: PUSH
88999: LD_VAR 0 1
89003: PUSH
89004: LD_EXP 68
89008: PUSH
89009: LD_VAR 0 3
89013: ARRAY
89014: IN
89015: OR
89016: PUSH
89017: LD_VAR 0 1
89021: PUSH
89022: LD_EXP 78
89026: PUSH
89027: LD_VAR 0 3
89031: ARRAY
89032: IN
89033: OR
89034: PUSH
89035: LD_VAR 0 1
89039: PUSH
89040: LD_EXP 79
89044: PUSH
89045: LD_VAR 0 3
89049: ARRAY
89050: IN
89051: OR
89052: IFFALSE 90295
// begin if un in mc_ape [ i ] then
89054: LD_VAR 0 1
89058: PUSH
89059: LD_EXP 78
89063: PUSH
89064: LD_VAR 0 3
89068: ARRAY
89069: IN
89070: IFFALSE 89109
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89072: LD_ADDR_EXP 78
89076: PUSH
89077: LD_EXP 78
89081: PPUSH
89082: LD_VAR 0 3
89086: PPUSH
89087: LD_EXP 78
89091: PUSH
89092: LD_VAR 0 3
89096: ARRAY
89097: PUSH
89098: LD_VAR 0 1
89102: DIFF
89103: PPUSH
89104: CALL_OW 1
89108: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89109: LD_VAR 0 1
89113: PUSH
89114: LD_EXP 79
89118: PUSH
89119: LD_VAR 0 3
89123: ARRAY
89124: IN
89125: IFFALSE 89149
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89127: LD_ADDR_EXP 79
89131: PUSH
89132: LD_EXP 79
89136: PPUSH
89137: LD_VAR 0 3
89141: PPUSH
89142: EMPTY
89143: PPUSH
89144: CALL_OW 1
89148: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89149: LD_VAR 0 1
89153: PPUSH
89154: CALL_OW 247
89158: PUSH
89159: LD_INT 2
89161: EQUAL
89162: PUSH
89163: LD_VAR 0 1
89167: PPUSH
89168: CALL_OW 110
89172: PUSH
89173: LD_INT 20
89175: EQUAL
89176: PUSH
89177: LD_VAR 0 1
89181: PUSH
89182: LD_EXP 71
89186: PUSH
89187: LD_VAR 0 3
89191: ARRAY
89192: IN
89193: OR
89194: PUSH
89195: LD_VAR 0 1
89199: PPUSH
89200: CALL_OW 264
89204: PUSH
89205: LD_INT 12
89207: PUSH
89208: LD_INT 51
89210: PUSH
89211: LD_EXP 30
89215: PUSH
89216: LD_INT 32
89218: PUSH
89219: LD_INT 13
89221: PUSH
89222: LD_INT 52
89224: PUSH
89225: LD_INT 31
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: IN
89237: OR
89238: AND
89239: IFFALSE 89547
// begin if un in mc_defender [ i ] then
89241: LD_VAR 0 1
89245: PUSH
89246: LD_EXP 71
89250: PUSH
89251: LD_VAR 0 3
89255: ARRAY
89256: IN
89257: IFFALSE 89296
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89259: LD_ADDR_EXP 71
89263: PUSH
89264: LD_EXP 71
89268: PPUSH
89269: LD_VAR 0 3
89273: PPUSH
89274: LD_EXP 71
89278: PUSH
89279: LD_VAR 0 3
89283: ARRAY
89284: PUSH
89285: LD_VAR 0 1
89289: DIFF
89290: PPUSH
89291: CALL_OW 1
89295: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89296: LD_ADDR_VAR 0 8
89300: PUSH
89301: LD_VAR 0 3
89305: PPUSH
89306: LD_INT 3
89308: PPUSH
89309: CALL 85937 0 2
89313: ST_TO_ADDR
// if fac then
89314: LD_VAR 0 8
89318: IFFALSE 89547
// begin for j in fac do
89320: LD_ADDR_VAR 0 4
89324: PUSH
89325: LD_VAR 0 8
89329: PUSH
89330: FOR_IN
89331: IFFALSE 89545
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89333: LD_ADDR_VAR 0 9
89337: PUSH
89338: LD_VAR 0 8
89342: PPUSH
89343: LD_VAR 0 1
89347: PPUSH
89348: CALL_OW 265
89352: PPUSH
89353: LD_VAR 0 1
89357: PPUSH
89358: CALL_OW 262
89362: PPUSH
89363: LD_VAR 0 1
89367: PPUSH
89368: CALL_OW 263
89372: PPUSH
89373: LD_VAR 0 1
89377: PPUSH
89378: CALL_OW 264
89382: PPUSH
89383: CALL 22521 0 5
89387: ST_TO_ADDR
// if components then
89388: LD_VAR 0 9
89392: IFFALSE 89543
// begin if GetWeapon ( un ) = ar_control_tower then
89394: LD_VAR 0 1
89398: PPUSH
89399: CALL_OW 264
89403: PUSH
89404: LD_INT 31
89406: EQUAL
89407: IFFALSE 89524
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89409: LD_VAR 0 1
89413: PPUSH
89414: CALL_OW 311
89418: PPUSH
89419: LD_INT 0
89421: PPUSH
89422: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89426: LD_ADDR_EXP 89
89430: PUSH
89431: LD_EXP 89
89435: PPUSH
89436: LD_VAR 0 3
89440: PPUSH
89441: LD_EXP 89
89445: PUSH
89446: LD_VAR 0 3
89450: ARRAY
89451: PUSH
89452: LD_VAR 0 1
89456: PPUSH
89457: CALL_OW 311
89461: DIFF
89462: PPUSH
89463: CALL_OW 1
89467: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89468: LD_ADDR_VAR 0 7
89472: PUSH
89473: LD_EXP 70
89477: PUSH
89478: LD_VAR 0 3
89482: ARRAY
89483: PPUSH
89484: LD_INT 1
89486: PPUSH
89487: LD_VAR 0 9
89491: PPUSH
89492: CALL_OW 2
89496: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89497: LD_ADDR_EXP 70
89501: PUSH
89502: LD_EXP 70
89506: PPUSH
89507: LD_VAR 0 3
89511: PPUSH
89512: LD_VAR 0 7
89516: PPUSH
89517: CALL_OW 1
89521: ST_TO_ADDR
// end else
89522: GO 89541
// MC_InsertProduceList ( i , [ components ] ) ;
89524: LD_VAR 0 3
89528: PPUSH
89529: LD_VAR 0 9
89533: PUSH
89534: EMPTY
89535: LIST
89536: PPUSH
89537: CALL 85482 0 2
// break ;
89541: GO 89545
// end ; end ;
89543: GO 89330
89545: POP
89546: POP
// end ; end ; if GetType ( un ) = unit_building then
89547: LD_VAR 0 1
89551: PPUSH
89552: CALL_OW 247
89556: PUSH
89557: LD_INT 3
89559: EQUAL
89560: IFFALSE 89963
// begin btype := GetBType ( un ) ;
89562: LD_ADDR_VAR 0 5
89566: PUSH
89567: LD_VAR 0 1
89571: PPUSH
89572: CALL_OW 266
89576: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89577: LD_VAR 0 5
89581: PUSH
89582: LD_INT 29
89584: PUSH
89585: LD_INT 30
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: IN
89592: IFFALSE 89665
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89594: LD_VAR 0 1
89598: PPUSH
89599: CALL_OW 250
89603: PPUSH
89604: LD_VAR 0 1
89608: PPUSH
89609: CALL_OW 251
89613: PPUSH
89614: LD_VAR 0 1
89618: PPUSH
89619: CALL_OW 255
89623: PPUSH
89624: CALL_OW 440
89628: NOT
89629: IFFALSE 89665
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89631: LD_VAR 0 1
89635: PPUSH
89636: CALL_OW 250
89640: PPUSH
89641: LD_VAR 0 1
89645: PPUSH
89646: CALL_OW 251
89650: PPUSH
89651: LD_VAR 0 1
89655: PPUSH
89656: CALL_OW 255
89660: PPUSH
89661: CALL_OW 441
// end ; if btype = b_warehouse then
89665: LD_VAR 0 5
89669: PUSH
89670: LD_INT 1
89672: EQUAL
89673: IFFALSE 89691
// begin btype := b_depot ;
89675: LD_ADDR_VAR 0 5
89679: PUSH
89680: LD_INT 0
89682: ST_TO_ADDR
// pos := 1 ;
89683: LD_ADDR_VAR 0 6
89687: PUSH
89688: LD_INT 1
89690: ST_TO_ADDR
// end ; if btype = b_factory then
89691: LD_VAR 0 5
89695: PUSH
89696: LD_INT 3
89698: EQUAL
89699: IFFALSE 89717
// begin btype := b_workshop ;
89701: LD_ADDR_VAR 0 5
89705: PUSH
89706: LD_INT 2
89708: ST_TO_ADDR
// pos := 1 ;
89709: LD_ADDR_VAR 0 6
89713: PUSH
89714: LD_INT 1
89716: ST_TO_ADDR
// end ; if btype = b_barracks then
89717: LD_VAR 0 5
89721: PUSH
89722: LD_INT 5
89724: EQUAL
89725: IFFALSE 89735
// btype := b_armoury ;
89727: LD_ADDR_VAR 0 5
89731: PUSH
89732: LD_INT 4
89734: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89735: LD_VAR 0 5
89739: PUSH
89740: LD_INT 7
89742: PUSH
89743: LD_INT 8
89745: PUSH
89746: EMPTY
89747: LIST
89748: LIST
89749: IN
89750: IFFALSE 89760
// btype := b_lab ;
89752: LD_ADDR_VAR 0 5
89756: PUSH
89757: LD_INT 6
89759: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89760: LD_ADDR_EXP 54
89764: PUSH
89765: LD_EXP 54
89769: PPUSH
89770: LD_VAR 0 3
89774: PUSH
89775: LD_EXP 54
89779: PUSH
89780: LD_VAR 0 3
89784: ARRAY
89785: PUSH
89786: LD_INT 1
89788: PLUS
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: PPUSH
89794: LD_VAR 0 5
89798: PUSH
89799: LD_VAR 0 1
89803: PPUSH
89804: CALL_OW 250
89808: PUSH
89809: LD_VAR 0 1
89813: PPUSH
89814: CALL_OW 251
89818: PUSH
89819: LD_VAR 0 1
89823: PPUSH
89824: CALL_OW 254
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: PPUSH
89835: CALL 25025 0 3
89839: ST_TO_ADDR
// if pos = 1 then
89840: LD_VAR 0 6
89844: PUSH
89845: LD_INT 1
89847: EQUAL
89848: IFFALSE 89963
// begin tmp := mc_build_list [ i ] ;
89850: LD_ADDR_VAR 0 7
89854: PUSH
89855: LD_EXP 54
89859: PUSH
89860: LD_VAR 0 3
89864: ARRAY
89865: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89866: LD_VAR 0 7
89870: PPUSH
89871: LD_INT 2
89873: PUSH
89874: LD_INT 30
89876: PUSH
89877: LD_INT 0
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: PUSH
89884: LD_INT 30
89886: PUSH
89887: LD_INT 1
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: LIST
89898: PPUSH
89899: CALL_OW 72
89903: IFFALSE 89913
// pos := 2 ;
89905: LD_ADDR_VAR 0 6
89909: PUSH
89910: LD_INT 2
89912: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
89913: LD_ADDR_VAR 0 7
89917: PUSH
89918: LD_VAR 0 7
89922: PPUSH
89923: LD_VAR 0 6
89927: PPUSH
89928: LD_VAR 0 7
89932: PPUSH
89933: CALL 25351 0 3
89937: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
89938: LD_ADDR_EXP 54
89942: PUSH
89943: LD_EXP 54
89947: PPUSH
89948: LD_VAR 0 3
89952: PPUSH
89953: LD_VAR 0 7
89957: PPUSH
89958: CALL_OW 1
89962: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
89963: LD_VAR 0 1
89967: PUSH
89968: LD_EXP 49
89972: PUSH
89973: LD_VAR 0 3
89977: ARRAY
89978: IN
89979: IFFALSE 90018
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
89981: LD_ADDR_EXP 49
89985: PUSH
89986: LD_EXP 49
89990: PPUSH
89991: LD_VAR 0 3
89995: PPUSH
89996: LD_EXP 49
90000: PUSH
90001: LD_VAR 0 3
90005: ARRAY
90006: PUSH
90007: LD_VAR 0 1
90011: DIFF
90012: PPUSH
90013: CALL_OW 1
90017: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90018: LD_VAR 0 1
90022: PUSH
90023: LD_EXP 56
90027: PUSH
90028: LD_VAR 0 3
90032: ARRAY
90033: IN
90034: IFFALSE 90073
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90036: LD_ADDR_EXP 56
90040: PUSH
90041: LD_EXP 56
90045: PPUSH
90046: LD_VAR 0 3
90050: PPUSH
90051: LD_EXP 56
90055: PUSH
90056: LD_VAR 0 3
90060: ARRAY
90061: PUSH
90062: LD_VAR 0 1
90066: DIFF
90067: PPUSH
90068: CALL_OW 1
90072: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90073: LD_VAR 0 1
90077: PUSH
90078: LD_EXP 68
90082: PUSH
90083: LD_VAR 0 3
90087: ARRAY
90088: IN
90089: IFFALSE 90128
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90091: LD_ADDR_EXP 68
90095: PUSH
90096: LD_EXP 68
90100: PPUSH
90101: LD_VAR 0 3
90105: PPUSH
90106: LD_EXP 68
90110: PUSH
90111: LD_VAR 0 3
90115: ARRAY
90116: PUSH
90117: LD_VAR 0 1
90121: DIFF
90122: PPUSH
90123: CALL_OW 1
90127: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90128: LD_VAR 0 1
90132: PUSH
90133: LD_EXP 71
90137: PUSH
90138: LD_VAR 0 3
90142: ARRAY
90143: IN
90144: IFFALSE 90183
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90146: LD_ADDR_EXP 71
90150: PUSH
90151: LD_EXP 71
90155: PPUSH
90156: LD_VAR 0 3
90160: PPUSH
90161: LD_EXP 71
90165: PUSH
90166: LD_VAR 0 3
90170: ARRAY
90171: PUSH
90172: LD_VAR 0 1
90176: DIFF
90177: PPUSH
90178: CALL_OW 1
90182: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90183: LD_VAR 0 1
90187: PUSH
90188: LD_EXP 58
90192: PUSH
90193: LD_VAR 0 3
90197: ARRAY
90198: IN
90199: IFFALSE 90238
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90201: LD_ADDR_EXP 58
90205: PUSH
90206: LD_EXP 58
90210: PPUSH
90211: LD_VAR 0 3
90215: PPUSH
90216: LD_EXP 58
90220: PUSH
90221: LD_VAR 0 3
90225: ARRAY
90226: PUSH
90227: LD_VAR 0 1
90231: DIFF
90232: PPUSH
90233: CALL_OW 1
90237: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90238: LD_VAR 0 1
90242: PUSH
90243: LD_EXP 57
90247: PUSH
90248: LD_VAR 0 3
90252: ARRAY
90253: IN
90254: IFFALSE 90293
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90256: LD_ADDR_EXP 57
90260: PUSH
90261: LD_EXP 57
90265: PPUSH
90266: LD_VAR 0 3
90270: PPUSH
90271: LD_EXP 57
90275: PUSH
90276: LD_VAR 0 3
90280: ARRAY
90281: PUSH
90282: LD_VAR 0 1
90286: DIFF
90287: PPUSH
90288: CALL_OW 1
90292: ST_TO_ADDR
// end ; break ;
90293: GO 90297
// end ;
90295: GO 88943
90297: POP
90298: POP
// end ;
90299: LD_VAR 0 2
90303: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90304: LD_INT 0
90306: PPUSH
90307: PPUSH
90308: PPUSH
// if not mc_bases or not skirmish then
90309: LD_EXP 49
90313: NOT
90314: PUSH
90315: LD_EXP 47
90319: NOT
90320: OR
90321: IFFALSE 90325
// exit ;
90323: GO 90540
// for i = 1 to mc_bases do
90325: LD_ADDR_VAR 0 3
90329: PUSH
90330: DOUBLE
90331: LD_INT 1
90333: DEC
90334: ST_TO_ADDR
90335: LD_EXP 49
90339: PUSH
90340: FOR_TO
90341: IFFALSE 90538
// begin if building in mc_construct_list [ i ] then
90343: LD_VAR 0 1
90347: PUSH
90348: LD_EXP 56
90352: PUSH
90353: LD_VAR 0 3
90357: ARRAY
90358: IN
90359: IFFALSE 90536
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90361: LD_ADDR_EXP 56
90365: PUSH
90366: LD_EXP 56
90370: PPUSH
90371: LD_VAR 0 3
90375: PPUSH
90376: LD_EXP 56
90380: PUSH
90381: LD_VAR 0 3
90385: ARRAY
90386: PUSH
90387: LD_VAR 0 1
90391: DIFF
90392: PPUSH
90393: CALL_OW 1
90397: ST_TO_ADDR
// if building in mc_lab [ i ] then
90398: LD_VAR 0 1
90402: PUSH
90403: LD_EXP 82
90407: PUSH
90408: LD_VAR 0 3
90412: ARRAY
90413: IN
90414: IFFALSE 90469
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90416: LD_ADDR_EXP 83
90420: PUSH
90421: LD_EXP 83
90425: PPUSH
90426: LD_VAR 0 3
90430: PPUSH
90431: LD_EXP 83
90435: PUSH
90436: LD_VAR 0 3
90440: ARRAY
90441: PPUSH
90442: LD_INT 1
90444: PPUSH
90445: LD_EXP 83
90449: PUSH
90450: LD_VAR 0 3
90454: ARRAY
90455: PPUSH
90456: LD_INT 0
90458: PPUSH
90459: CALL 24443 0 4
90463: PPUSH
90464: CALL_OW 1
90468: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90469: LD_VAR 0 1
90473: PUSH
90474: LD_EXP 49
90478: PUSH
90479: LD_VAR 0 3
90483: ARRAY
90484: IN
90485: NOT
90486: IFFALSE 90532
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90488: LD_ADDR_EXP 49
90492: PUSH
90493: LD_EXP 49
90497: PPUSH
90498: LD_VAR 0 3
90502: PUSH
90503: LD_EXP 49
90507: PUSH
90508: LD_VAR 0 3
90512: ARRAY
90513: PUSH
90514: LD_INT 1
90516: PLUS
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PPUSH
90522: LD_VAR 0 1
90526: PPUSH
90527: CALL 25025 0 3
90531: ST_TO_ADDR
// exit ;
90532: POP
90533: POP
90534: GO 90540
// end ; end ;
90536: GO 90340
90538: POP
90539: POP
// end ;
90540: LD_VAR 0 2
90544: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90545: LD_INT 0
90547: PPUSH
90548: PPUSH
90549: PPUSH
90550: PPUSH
90551: PPUSH
90552: PPUSH
90553: PPUSH
// if not mc_bases or not skirmish then
90554: LD_EXP 49
90558: NOT
90559: PUSH
90560: LD_EXP 47
90564: NOT
90565: OR
90566: IFFALSE 90570
// exit ;
90568: GO 91231
// for i = 1 to mc_bases do
90570: LD_ADDR_VAR 0 3
90574: PUSH
90575: DOUBLE
90576: LD_INT 1
90578: DEC
90579: ST_TO_ADDR
90580: LD_EXP 49
90584: PUSH
90585: FOR_TO
90586: IFFALSE 91229
// begin if building in mc_construct_list [ i ] then
90588: LD_VAR 0 1
90592: PUSH
90593: LD_EXP 56
90597: PUSH
90598: LD_VAR 0 3
90602: ARRAY
90603: IN
90604: IFFALSE 91227
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90606: LD_ADDR_EXP 56
90610: PUSH
90611: LD_EXP 56
90615: PPUSH
90616: LD_VAR 0 3
90620: PPUSH
90621: LD_EXP 56
90625: PUSH
90626: LD_VAR 0 3
90630: ARRAY
90631: PUSH
90632: LD_VAR 0 1
90636: DIFF
90637: PPUSH
90638: CALL_OW 1
90642: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90643: LD_ADDR_EXP 49
90647: PUSH
90648: LD_EXP 49
90652: PPUSH
90653: LD_VAR 0 3
90657: PUSH
90658: LD_EXP 49
90662: PUSH
90663: LD_VAR 0 3
90667: ARRAY
90668: PUSH
90669: LD_INT 1
90671: PLUS
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: PPUSH
90677: LD_VAR 0 1
90681: PPUSH
90682: CALL 25025 0 3
90686: ST_TO_ADDR
// btype := GetBType ( building ) ;
90687: LD_ADDR_VAR 0 5
90691: PUSH
90692: LD_VAR 0 1
90696: PPUSH
90697: CALL_OW 266
90701: ST_TO_ADDR
// side := GetSide ( building ) ;
90702: LD_ADDR_VAR 0 8
90706: PUSH
90707: LD_VAR 0 1
90711: PPUSH
90712: CALL_OW 255
90716: ST_TO_ADDR
// if btype = b_lab then
90717: LD_VAR 0 5
90721: PUSH
90722: LD_INT 6
90724: EQUAL
90725: IFFALSE 90775
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90727: LD_ADDR_EXP 82
90731: PUSH
90732: LD_EXP 82
90736: PPUSH
90737: LD_VAR 0 3
90741: PUSH
90742: LD_EXP 82
90746: PUSH
90747: LD_VAR 0 3
90751: ARRAY
90752: PUSH
90753: LD_INT 1
90755: PLUS
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PPUSH
90761: LD_VAR 0 1
90765: PPUSH
90766: CALL 25025 0 3
90770: ST_TO_ADDR
// exit ;
90771: POP
90772: POP
90773: GO 91231
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90775: LD_VAR 0 5
90779: PUSH
90780: LD_INT 0
90782: PUSH
90783: LD_INT 2
90785: PUSH
90786: LD_INT 4
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: LIST
90793: IN
90794: IFFALSE 90918
// begin if btype = b_armoury then
90796: LD_VAR 0 5
90800: PUSH
90801: LD_INT 4
90803: EQUAL
90804: IFFALSE 90814
// btype := b_barracks ;
90806: LD_ADDR_VAR 0 5
90810: PUSH
90811: LD_INT 5
90813: ST_TO_ADDR
// if btype = b_depot then
90814: LD_VAR 0 5
90818: PUSH
90819: LD_INT 0
90821: EQUAL
90822: IFFALSE 90832
// btype := b_warehouse ;
90824: LD_ADDR_VAR 0 5
90828: PUSH
90829: LD_INT 1
90831: ST_TO_ADDR
// if btype = b_workshop then
90832: LD_VAR 0 5
90836: PUSH
90837: LD_INT 2
90839: EQUAL
90840: IFFALSE 90850
// btype := b_factory ;
90842: LD_ADDR_VAR 0 5
90846: PUSH
90847: LD_INT 3
90849: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90850: LD_VAR 0 5
90854: PPUSH
90855: LD_VAR 0 8
90859: PPUSH
90860: CALL_OW 323
90864: PUSH
90865: LD_INT 1
90867: EQUAL
90868: IFFALSE 90914
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90870: LD_ADDR_EXP 81
90874: PUSH
90875: LD_EXP 81
90879: PPUSH
90880: LD_VAR 0 3
90884: PUSH
90885: LD_EXP 81
90889: PUSH
90890: LD_VAR 0 3
90894: ARRAY
90895: PUSH
90896: LD_INT 1
90898: PLUS
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PPUSH
90904: LD_VAR 0 1
90908: PPUSH
90909: CALL 25025 0 3
90913: ST_TO_ADDR
// exit ;
90914: POP
90915: POP
90916: GO 91231
// end ; if btype in [ b_bunker , b_turret ] then
90918: LD_VAR 0 5
90922: PUSH
90923: LD_INT 32
90925: PUSH
90926: LD_INT 33
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: IN
90933: IFFALSE 91223
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
90935: LD_ADDR_EXP 57
90939: PUSH
90940: LD_EXP 57
90944: PPUSH
90945: LD_VAR 0 3
90949: PUSH
90950: LD_EXP 57
90954: PUSH
90955: LD_VAR 0 3
90959: ARRAY
90960: PUSH
90961: LD_INT 1
90963: PLUS
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PPUSH
90969: LD_VAR 0 1
90973: PPUSH
90974: CALL 25025 0 3
90978: ST_TO_ADDR
// if btype = b_bunker then
90979: LD_VAR 0 5
90983: PUSH
90984: LD_INT 32
90986: EQUAL
90987: IFFALSE 91223
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
90989: LD_ADDR_EXP 58
90993: PUSH
90994: LD_EXP 58
90998: PPUSH
90999: LD_VAR 0 3
91003: PUSH
91004: LD_EXP 58
91008: PUSH
91009: LD_VAR 0 3
91013: ARRAY
91014: PUSH
91015: LD_INT 1
91017: PLUS
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PPUSH
91023: LD_VAR 0 1
91027: PPUSH
91028: CALL 25025 0 3
91032: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91033: LD_ADDR_VAR 0 6
91037: PUSH
91038: LD_EXP 49
91042: PUSH
91043: LD_VAR 0 3
91047: ARRAY
91048: PPUSH
91049: LD_INT 25
91051: PUSH
91052: LD_INT 1
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 3
91061: PUSH
91062: LD_INT 54
91064: PUSH
91065: EMPTY
91066: LIST
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PPUSH
91076: CALL_OW 72
91080: ST_TO_ADDR
// if tmp then
91081: LD_VAR 0 6
91085: IFFALSE 91091
// exit ;
91087: POP
91088: POP
91089: GO 91231
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91091: LD_ADDR_VAR 0 6
91095: PUSH
91096: LD_EXP 49
91100: PUSH
91101: LD_VAR 0 3
91105: ARRAY
91106: PPUSH
91107: LD_INT 2
91109: PUSH
91110: LD_INT 30
91112: PUSH
91113: LD_INT 4
91115: PUSH
91116: EMPTY
91117: LIST
91118: LIST
91119: PUSH
91120: LD_INT 30
91122: PUSH
91123: LD_INT 5
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: LIST
91134: PPUSH
91135: CALL_OW 72
91139: ST_TO_ADDR
// if not tmp then
91140: LD_VAR 0 6
91144: NOT
91145: IFFALSE 91151
// exit ;
91147: POP
91148: POP
91149: GO 91231
// for j in tmp do
91151: LD_ADDR_VAR 0 4
91155: PUSH
91156: LD_VAR 0 6
91160: PUSH
91161: FOR_IN
91162: IFFALSE 91221
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91164: LD_ADDR_VAR 0 7
91168: PUSH
91169: LD_VAR 0 4
91173: PPUSH
91174: CALL_OW 313
91178: PPUSH
91179: LD_INT 25
91181: PUSH
91182: LD_INT 1
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PPUSH
91189: CALL_OW 72
91193: ST_TO_ADDR
// if units then
91194: LD_VAR 0 7
91198: IFFALSE 91219
// begin ComExitBuilding ( units [ 1 ] ) ;
91200: LD_VAR 0 7
91204: PUSH
91205: LD_INT 1
91207: ARRAY
91208: PPUSH
91209: CALL_OW 122
// exit ;
91213: POP
91214: POP
91215: POP
91216: POP
91217: GO 91231
// end ; end ;
91219: GO 91161
91221: POP
91222: POP
// end ; end ; exit ;
91223: POP
91224: POP
91225: GO 91231
// end ; end ;
91227: GO 90585
91229: POP
91230: POP
// end ;
91231: LD_VAR 0 2
91235: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91236: LD_INT 0
91238: PPUSH
91239: PPUSH
91240: PPUSH
91241: PPUSH
91242: PPUSH
91243: PPUSH
91244: PPUSH
// if not mc_bases or not skirmish then
91245: LD_EXP 49
91249: NOT
91250: PUSH
91251: LD_EXP 47
91255: NOT
91256: OR
91257: IFFALSE 91261
// exit ;
91259: GO 91526
// btype := GetBType ( building ) ;
91261: LD_ADDR_VAR 0 6
91265: PUSH
91266: LD_VAR 0 1
91270: PPUSH
91271: CALL_OW 266
91275: ST_TO_ADDR
// x := GetX ( building ) ;
91276: LD_ADDR_VAR 0 7
91280: PUSH
91281: LD_VAR 0 1
91285: PPUSH
91286: CALL_OW 250
91290: ST_TO_ADDR
// y := GetY ( building ) ;
91291: LD_ADDR_VAR 0 8
91295: PUSH
91296: LD_VAR 0 1
91300: PPUSH
91301: CALL_OW 251
91305: ST_TO_ADDR
// d := GetDir ( building ) ;
91306: LD_ADDR_VAR 0 9
91310: PUSH
91311: LD_VAR 0 1
91315: PPUSH
91316: CALL_OW 254
91320: ST_TO_ADDR
// for i = 1 to mc_bases do
91321: LD_ADDR_VAR 0 4
91325: PUSH
91326: DOUBLE
91327: LD_INT 1
91329: DEC
91330: ST_TO_ADDR
91331: LD_EXP 49
91335: PUSH
91336: FOR_TO
91337: IFFALSE 91524
// begin if not mc_build_list [ i ] then
91339: LD_EXP 54
91343: PUSH
91344: LD_VAR 0 4
91348: ARRAY
91349: NOT
91350: IFFALSE 91354
// continue ;
91352: GO 91336
// for j := 1 to mc_build_list [ i ] do
91354: LD_ADDR_VAR 0 5
91358: PUSH
91359: DOUBLE
91360: LD_INT 1
91362: DEC
91363: ST_TO_ADDR
91364: LD_EXP 54
91368: PUSH
91369: LD_VAR 0 4
91373: ARRAY
91374: PUSH
91375: FOR_TO
91376: IFFALSE 91520
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91378: LD_VAR 0 6
91382: PUSH
91383: LD_VAR 0 7
91387: PUSH
91388: LD_VAR 0 8
91392: PUSH
91393: LD_VAR 0 9
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: PPUSH
91404: LD_EXP 54
91408: PUSH
91409: LD_VAR 0 4
91413: ARRAY
91414: PUSH
91415: LD_VAR 0 5
91419: ARRAY
91420: PPUSH
91421: CALL 31207 0 2
91425: IFFALSE 91518
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91427: LD_ADDR_EXP 54
91431: PUSH
91432: LD_EXP 54
91436: PPUSH
91437: LD_VAR 0 4
91441: PPUSH
91442: LD_EXP 54
91446: PUSH
91447: LD_VAR 0 4
91451: ARRAY
91452: PPUSH
91453: LD_VAR 0 5
91457: PPUSH
91458: CALL_OW 3
91462: PPUSH
91463: CALL_OW 1
91467: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91468: LD_ADDR_EXP 56
91472: PUSH
91473: LD_EXP 56
91477: PPUSH
91478: LD_VAR 0 4
91482: PUSH
91483: LD_EXP 56
91487: PUSH
91488: LD_VAR 0 4
91492: ARRAY
91493: PUSH
91494: LD_INT 1
91496: PLUS
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PPUSH
91502: LD_VAR 0 1
91506: PPUSH
91507: CALL 25025 0 3
91511: ST_TO_ADDR
// exit ;
91512: POP
91513: POP
91514: POP
91515: POP
91516: GO 91526
// end ;
91518: GO 91375
91520: POP
91521: POP
// end ;
91522: GO 91336
91524: POP
91525: POP
// end ;
91526: LD_VAR 0 3
91530: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91531: LD_INT 0
91533: PPUSH
91534: PPUSH
91535: PPUSH
// if not mc_bases or not skirmish then
91536: LD_EXP 49
91540: NOT
91541: PUSH
91542: LD_EXP 47
91546: NOT
91547: OR
91548: IFFALSE 91552
// exit ;
91550: GO 91742
// for i = 1 to mc_bases do
91552: LD_ADDR_VAR 0 4
91556: PUSH
91557: DOUBLE
91558: LD_INT 1
91560: DEC
91561: ST_TO_ADDR
91562: LD_EXP 49
91566: PUSH
91567: FOR_TO
91568: IFFALSE 91655
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91570: LD_VAR 0 1
91574: PUSH
91575: LD_EXP 57
91579: PUSH
91580: LD_VAR 0 4
91584: ARRAY
91585: IN
91586: PUSH
91587: LD_VAR 0 1
91591: PUSH
91592: LD_EXP 58
91596: PUSH
91597: LD_VAR 0 4
91601: ARRAY
91602: IN
91603: NOT
91604: AND
91605: IFFALSE 91653
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91607: LD_ADDR_EXP 58
91611: PUSH
91612: LD_EXP 58
91616: PPUSH
91617: LD_VAR 0 4
91621: PUSH
91622: LD_EXP 58
91626: PUSH
91627: LD_VAR 0 4
91631: ARRAY
91632: PUSH
91633: LD_INT 1
91635: PLUS
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PPUSH
91641: LD_VAR 0 1
91645: PPUSH
91646: CALL 25025 0 3
91650: ST_TO_ADDR
// break ;
91651: GO 91655
// end ; end ;
91653: GO 91567
91655: POP
91656: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91657: LD_VAR 0 1
91661: PPUSH
91662: CALL_OW 257
91666: PUSH
91667: LD_EXP 75
91671: IN
91672: PUSH
91673: LD_VAR 0 1
91677: PPUSH
91678: CALL_OW 266
91682: PUSH
91683: LD_INT 5
91685: EQUAL
91686: AND
91687: PUSH
91688: LD_VAR 0 2
91692: PPUSH
91693: CALL_OW 110
91697: PUSH
91698: LD_INT 18
91700: NONEQUAL
91701: AND
91702: IFFALSE 91742
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91704: LD_VAR 0 2
91708: PPUSH
91709: CALL_OW 257
91713: PUSH
91714: LD_INT 5
91716: PUSH
91717: LD_INT 8
91719: PUSH
91720: LD_INT 9
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: LIST
91727: IN
91728: IFFALSE 91742
// SetClass ( unit , 1 ) ;
91730: LD_VAR 0 2
91734: PPUSH
91735: LD_INT 1
91737: PPUSH
91738: CALL_OW 336
// end ;
91742: LD_VAR 0 3
91746: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91747: LD_INT 0
91749: PPUSH
91750: PPUSH
// if not mc_bases or not skirmish then
91751: LD_EXP 49
91755: NOT
91756: PUSH
91757: LD_EXP 47
91761: NOT
91762: OR
91763: IFFALSE 91767
// exit ;
91765: GO 91883
// if GetLives ( abandoned_vehicle ) > 250 then
91767: LD_VAR 0 2
91771: PPUSH
91772: CALL_OW 256
91776: PUSH
91777: LD_INT 250
91779: GREATER
91780: IFFALSE 91784
// exit ;
91782: GO 91883
// for i = 1 to mc_bases do
91784: LD_ADDR_VAR 0 6
91788: PUSH
91789: DOUBLE
91790: LD_INT 1
91792: DEC
91793: ST_TO_ADDR
91794: LD_EXP 49
91798: PUSH
91799: FOR_TO
91800: IFFALSE 91881
// begin if driver in mc_bases [ i ] then
91802: LD_VAR 0 1
91806: PUSH
91807: LD_EXP 49
91811: PUSH
91812: LD_VAR 0 6
91816: ARRAY
91817: IN
91818: IFFALSE 91879
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91820: LD_VAR 0 1
91824: PPUSH
91825: LD_EXP 49
91829: PUSH
91830: LD_VAR 0 6
91834: ARRAY
91835: PPUSH
91836: LD_INT 2
91838: PUSH
91839: LD_INT 30
91841: PUSH
91842: LD_INT 0
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: PUSH
91849: LD_INT 30
91851: PUSH
91852: LD_INT 1
91854: PUSH
91855: EMPTY
91856: LIST
91857: LIST
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: LIST
91863: PPUSH
91864: CALL_OW 72
91868: PUSH
91869: LD_INT 1
91871: ARRAY
91872: PPUSH
91873: CALL 58164 0 2
// break ;
91877: GO 91881
// end ; end ;
91879: GO 91799
91881: POP
91882: POP
// end ; end_of_file end_of_file
91883: LD_VAR 0 5
91887: RET
// every 0 0$1 do
91888: GO 91890
91890: DISABLE
// begin enable ;
91891: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91892: LD_STRING updateTimer(
91894: PUSH
91895: LD_OWVAR 1
91899: STR
91900: PUSH
91901: LD_STRING );
91903: STR
91904: PPUSH
91905: CALL_OW 559
// end ;
91909: END
// export function SOS_MapStart ( ) ; begin
91910: LD_INT 0
91912: PPUSH
// if streamModeActive then
91913: LD_EXP 93
91917: IFFALSE 91926
// DefineStreamItems ( true ) ;
91919: LD_INT 1
91921: PPUSH
91922: CALL 93580 0 1
// UpdateFactoryWaypoints ( ) ;
91926: CALL 106441 0 0
// UpdateWarehouseGatheringPoints ( ) ;
91930: CALL 106698 0 0
// end ;
91934: LD_VAR 0 1
91938: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91939: LD_INT 0
91941: PPUSH
// if p2 = 100 then
91942: LD_VAR 0 2
91946: PUSH
91947: LD_INT 100
91949: EQUAL
91950: IFFALSE 92953
// begin if not StreamModeActive then
91952: LD_EXP 93
91956: NOT
91957: IFFALSE 91967
// StreamModeActive := true ;
91959: LD_ADDR_EXP 93
91963: PUSH
91964: LD_INT 1
91966: ST_TO_ADDR
// if p3 = 0 then
91967: LD_VAR 0 3
91971: PUSH
91972: LD_INT 0
91974: EQUAL
91975: IFFALSE 91981
// InitStreamMode ;
91977: CALL 93116 0 0
// if p3 = 1 then
91981: LD_VAR 0 3
91985: PUSH
91986: LD_INT 1
91988: EQUAL
91989: IFFALSE 91999
// sRocket := true ;
91991: LD_ADDR_EXP 98
91995: PUSH
91996: LD_INT 1
91998: ST_TO_ADDR
// if p3 = 2 then
91999: LD_VAR 0 3
92003: PUSH
92004: LD_INT 2
92006: EQUAL
92007: IFFALSE 92017
// sSpeed := true ;
92009: LD_ADDR_EXP 97
92013: PUSH
92014: LD_INT 1
92016: ST_TO_ADDR
// if p3 = 3 then
92017: LD_VAR 0 3
92021: PUSH
92022: LD_INT 3
92024: EQUAL
92025: IFFALSE 92035
// sEngine := true ;
92027: LD_ADDR_EXP 99
92031: PUSH
92032: LD_INT 1
92034: ST_TO_ADDR
// if p3 = 4 then
92035: LD_VAR 0 3
92039: PUSH
92040: LD_INT 4
92042: EQUAL
92043: IFFALSE 92053
// sSpec := true ;
92045: LD_ADDR_EXP 96
92049: PUSH
92050: LD_INT 1
92052: ST_TO_ADDR
// if p3 = 5 then
92053: LD_VAR 0 3
92057: PUSH
92058: LD_INT 5
92060: EQUAL
92061: IFFALSE 92071
// sLevel := true ;
92063: LD_ADDR_EXP 100
92067: PUSH
92068: LD_INT 1
92070: ST_TO_ADDR
// if p3 = 6 then
92071: LD_VAR 0 3
92075: PUSH
92076: LD_INT 6
92078: EQUAL
92079: IFFALSE 92089
// sArmoury := true ;
92081: LD_ADDR_EXP 101
92085: PUSH
92086: LD_INT 1
92088: ST_TO_ADDR
// if p3 = 7 then
92089: LD_VAR 0 3
92093: PUSH
92094: LD_INT 7
92096: EQUAL
92097: IFFALSE 92107
// sRadar := true ;
92099: LD_ADDR_EXP 102
92103: PUSH
92104: LD_INT 1
92106: ST_TO_ADDR
// if p3 = 8 then
92107: LD_VAR 0 3
92111: PUSH
92112: LD_INT 8
92114: EQUAL
92115: IFFALSE 92125
// sBunker := true ;
92117: LD_ADDR_EXP 103
92121: PUSH
92122: LD_INT 1
92124: ST_TO_ADDR
// if p3 = 9 then
92125: LD_VAR 0 3
92129: PUSH
92130: LD_INT 9
92132: EQUAL
92133: IFFALSE 92143
// sHack := true ;
92135: LD_ADDR_EXP 104
92139: PUSH
92140: LD_INT 1
92142: ST_TO_ADDR
// if p3 = 10 then
92143: LD_VAR 0 3
92147: PUSH
92148: LD_INT 10
92150: EQUAL
92151: IFFALSE 92161
// sFire := true ;
92153: LD_ADDR_EXP 105
92157: PUSH
92158: LD_INT 1
92160: ST_TO_ADDR
// if p3 = 11 then
92161: LD_VAR 0 3
92165: PUSH
92166: LD_INT 11
92168: EQUAL
92169: IFFALSE 92179
// sRefresh := true ;
92171: LD_ADDR_EXP 106
92175: PUSH
92176: LD_INT 1
92178: ST_TO_ADDR
// if p3 = 12 then
92179: LD_VAR 0 3
92183: PUSH
92184: LD_INT 12
92186: EQUAL
92187: IFFALSE 92197
// sExp := true ;
92189: LD_ADDR_EXP 107
92193: PUSH
92194: LD_INT 1
92196: ST_TO_ADDR
// if p3 = 13 then
92197: LD_VAR 0 3
92201: PUSH
92202: LD_INT 13
92204: EQUAL
92205: IFFALSE 92215
// sDepot := true ;
92207: LD_ADDR_EXP 108
92211: PUSH
92212: LD_INT 1
92214: ST_TO_ADDR
// if p3 = 14 then
92215: LD_VAR 0 3
92219: PUSH
92220: LD_INT 14
92222: EQUAL
92223: IFFALSE 92233
// sFlag := true ;
92225: LD_ADDR_EXP 109
92229: PUSH
92230: LD_INT 1
92232: ST_TO_ADDR
// if p3 = 15 then
92233: LD_VAR 0 3
92237: PUSH
92238: LD_INT 15
92240: EQUAL
92241: IFFALSE 92251
// sKamikadze := true ;
92243: LD_ADDR_EXP 117
92247: PUSH
92248: LD_INT 1
92250: ST_TO_ADDR
// if p3 = 16 then
92251: LD_VAR 0 3
92255: PUSH
92256: LD_INT 16
92258: EQUAL
92259: IFFALSE 92269
// sTroll := true ;
92261: LD_ADDR_EXP 118
92265: PUSH
92266: LD_INT 1
92268: ST_TO_ADDR
// if p3 = 17 then
92269: LD_VAR 0 3
92273: PUSH
92274: LD_INT 17
92276: EQUAL
92277: IFFALSE 92287
// sSlow := true ;
92279: LD_ADDR_EXP 119
92283: PUSH
92284: LD_INT 1
92286: ST_TO_ADDR
// if p3 = 18 then
92287: LD_VAR 0 3
92291: PUSH
92292: LD_INT 18
92294: EQUAL
92295: IFFALSE 92305
// sLack := true ;
92297: LD_ADDR_EXP 120
92301: PUSH
92302: LD_INT 1
92304: ST_TO_ADDR
// if p3 = 19 then
92305: LD_VAR 0 3
92309: PUSH
92310: LD_INT 19
92312: EQUAL
92313: IFFALSE 92323
// sTank := true ;
92315: LD_ADDR_EXP 122
92319: PUSH
92320: LD_INT 1
92322: ST_TO_ADDR
// if p3 = 20 then
92323: LD_VAR 0 3
92327: PUSH
92328: LD_INT 20
92330: EQUAL
92331: IFFALSE 92341
// sRemote := true ;
92333: LD_ADDR_EXP 123
92337: PUSH
92338: LD_INT 1
92340: ST_TO_ADDR
// if p3 = 21 then
92341: LD_VAR 0 3
92345: PUSH
92346: LD_INT 21
92348: EQUAL
92349: IFFALSE 92359
// sPowell := true ;
92351: LD_ADDR_EXP 124
92355: PUSH
92356: LD_INT 1
92358: ST_TO_ADDR
// if p3 = 22 then
92359: LD_VAR 0 3
92363: PUSH
92364: LD_INT 22
92366: EQUAL
92367: IFFALSE 92377
// sTeleport := true ;
92369: LD_ADDR_EXP 127
92373: PUSH
92374: LD_INT 1
92376: ST_TO_ADDR
// if p3 = 23 then
92377: LD_VAR 0 3
92381: PUSH
92382: LD_INT 23
92384: EQUAL
92385: IFFALSE 92395
// sOilTower := true ;
92387: LD_ADDR_EXP 129
92391: PUSH
92392: LD_INT 1
92394: ST_TO_ADDR
// if p3 = 24 then
92395: LD_VAR 0 3
92399: PUSH
92400: LD_INT 24
92402: EQUAL
92403: IFFALSE 92413
// sShovel := true ;
92405: LD_ADDR_EXP 130
92409: PUSH
92410: LD_INT 1
92412: ST_TO_ADDR
// if p3 = 25 then
92413: LD_VAR 0 3
92417: PUSH
92418: LD_INT 25
92420: EQUAL
92421: IFFALSE 92431
// sSheik := true ;
92423: LD_ADDR_EXP 131
92427: PUSH
92428: LD_INT 1
92430: ST_TO_ADDR
// if p3 = 26 then
92431: LD_VAR 0 3
92435: PUSH
92436: LD_INT 26
92438: EQUAL
92439: IFFALSE 92449
// sEarthquake := true ;
92441: LD_ADDR_EXP 133
92445: PUSH
92446: LD_INT 1
92448: ST_TO_ADDR
// if p3 = 27 then
92449: LD_VAR 0 3
92453: PUSH
92454: LD_INT 27
92456: EQUAL
92457: IFFALSE 92467
// sAI := true ;
92459: LD_ADDR_EXP 134
92463: PUSH
92464: LD_INT 1
92466: ST_TO_ADDR
// if p3 = 28 then
92467: LD_VAR 0 3
92471: PUSH
92472: LD_INT 28
92474: EQUAL
92475: IFFALSE 92485
// sCargo := true ;
92477: LD_ADDR_EXP 137
92481: PUSH
92482: LD_INT 1
92484: ST_TO_ADDR
// if p3 = 29 then
92485: LD_VAR 0 3
92489: PUSH
92490: LD_INT 29
92492: EQUAL
92493: IFFALSE 92503
// sDLaser := true ;
92495: LD_ADDR_EXP 138
92499: PUSH
92500: LD_INT 1
92502: ST_TO_ADDR
// if p3 = 30 then
92503: LD_VAR 0 3
92507: PUSH
92508: LD_INT 30
92510: EQUAL
92511: IFFALSE 92521
// sExchange := true ;
92513: LD_ADDR_EXP 139
92517: PUSH
92518: LD_INT 1
92520: ST_TO_ADDR
// if p3 = 31 then
92521: LD_VAR 0 3
92525: PUSH
92526: LD_INT 31
92528: EQUAL
92529: IFFALSE 92539
// sFac := true ;
92531: LD_ADDR_EXP 140
92535: PUSH
92536: LD_INT 1
92538: ST_TO_ADDR
// if p3 = 32 then
92539: LD_VAR 0 3
92543: PUSH
92544: LD_INT 32
92546: EQUAL
92547: IFFALSE 92557
// sPower := true ;
92549: LD_ADDR_EXP 141
92553: PUSH
92554: LD_INT 1
92556: ST_TO_ADDR
// if p3 = 33 then
92557: LD_VAR 0 3
92561: PUSH
92562: LD_INT 33
92564: EQUAL
92565: IFFALSE 92575
// sRandom := true ;
92567: LD_ADDR_EXP 142
92571: PUSH
92572: LD_INT 1
92574: ST_TO_ADDR
// if p3 = 34 then
92575: LD_VAR 0 3
92579: PUSH
92580: LD_INT 34
92582: EQUAL
92583: IFFALSE 92593
// sShield := true ;
92585: LD_ADDR_EXP 143
92589: PUSH
92590: LD_INT 1
92592: ST_TO_ADDR
// if p3 = 35 then
92593: LD_VAR 0 3
92597: PUSH
92598: LD_INT 35
92600: EQUAL
92601: IFFALSE 92611
// sTime := true ;
92603: LD_ADDR_EXP 144
92607: PUSH
92608: LD_INT 1
92610: ST_TO_ADDR
// if p3 = 36 then
92611: LD_VAR 0 3
92615: PUSH
92616: LD_INT 36
92618: EQUAL
92619: IFFALSE 92629
// sTools := true ;
92621: LD_ADDR_EXP 145
92625: PUSH
92626: LD_INT 1
92628: ST_TO_ADDR
// if p3 = 101 then
92629: LD_VAR 0 3
92633: PUSH
92634: LD_INT 101
92636: EQUAL
92637: IFFALSE 92647
// sSold := true ;
92639: LD_ADDR_EXP 110
92643: PUSH
92644: LD_INT 1
92646: ST_TO_ADDR
// if p3 = 102 then
92647: LD_VAR 0 3
92651: PUSH
92652: LD_INT 102
92654: EQUAL
92655: IFFALSE 92665
// sDiff := true ;
92657: LD_ADDR_EXP 111
92661: PUSH
92662: LD_INT 1
92664: ST_TO_ADDR
// if p3 = 103 then
92665: LD_VAR 0 3
92669: PUSH
92670: LD_INT 103
92672: EQUAL
92673: IFFALSE 92683
// sFog := true ;
92675: LD_ADDR_EXP 114
92679: PUSH
92680: LD_INT 1
92682: ST_TO_ADDR
// if p3 = 104 then
92683: LD_VAR 0 3
92687: PUSH
92688: LD_INT 104
92690: EQUAL
92691: IFFALSE 92701
// sReset := true ;
92693: LD_ADDR_EXP 115
92697: PUSH
92698: LD_INT 1
92700: ST_TO_ADDR
// if p3 = 105 then
92701: LD_VAR 0 3
92705: PUSH
92706: LD_INT 105
92708: EQUAL
92709: IFFALSE 92719
// sSun := true ;
92711: LD_ADDR_EXP 116
92715: PUSH
92716: LD_INT 1
92718: ST_TO_ADDR
// if p3 = 106 then
92719: LD_VAR 0 3
92723: PUSH
92724: LD_INT 106
92726: EQUAL
92727: IFFALSE 92737
// sTiger := true ;
92729: LD_ADDR_EXP 112
92733: PUSH
92734: LD_INT 1
92736: ST_TO_ADDR
// if p3 = 107 then
92737: LD_VAR 0 3
92741: PUSH
92742: LD_INT 107
92744: EQUAL
92745: IFFALSE 92755
// sBomb := true ;
92747: LD_ADDR_EXP 113
92751: PUSH
92752: LD_INT 1
92754: ST_TO_ADDR
// if p3 = 108 then
92755: LD_VAR 0 3
92759: PUSH
92760: LD_INT 108
92762: EQUAL
92763: IFFALSE 92773
// sWound := true ;
92765: LD_ADDR_EXP 121
92769: PUSH
92770: LD_INT 1
92772: ST_TO_ADDR
// if p3 = 109 then
92773: LD_VAR 0 3
92777: PUSH
92778: LD_INT 109
92780: EQUAL
92781: IFFALSE 92791
// sBetray := true ;
92783: LD_ADDR_EXP 125
92787: PUSH
92788: LD_INT 1
92790: ST_TO_ADDR
// if p3 = 110 then
92791: LD_VAR 0 3
92795: PUSH
92796: LD_INT 110
92798: EQUAL
92799: IFFALSE 92809
// sContamin := true ;
92801: LD_ADDR_EXP 126
92805: PUSH
92806: LD_INT 1
92808: ST_TO_ADDR
// if p3 = 111 then
92809: LD_VAR 0 3
92813: PUSH
92814: LD_INT 111
92816: EQUAL
92817: IFFALSE 92827
// sOil := true ;
92819: LD_ADDR_EXP 128
92823: PUSH
92824: LD_INT 1
92826: ST_TO_ADDR
// if p3 = 112 then
92827: LD_VAR 0 3
92831: PUSH
92832: LD_INT 112
92834: EQUAL
92835: IFFALSE 92845
// sStu := true ;
92837: LD_ADDR_EXP 132
92841: PUSH
92842: LD_INT 1
92844: ST_TO_ADDR
// if p3 = 113 then
92845: LD_VAR 0 3
92849: PUSH
92850: LD_INT 113
92852: EQUAL
92853: IFFALSE 92863
// sBazooka := true ;
92855: LD_ADDR_EXP 135
92859: PUSH
92860: LD_INT 1
92862: ST_TO_ADDR
// if p3 = 114 then
92863: LD_VAR 0 3
92867: PUSH
92868: LD_INT 114
92870: EQUAL
92871: IFFALSE 92881
// sMortar := true ;
92873: LD_ADDR_EXP 136
92877: PUSH
92878: LD_INT 1
92880: ST_TO_ADDR
// if p3 = 115 then
92881: LD_VAR 0 3
92885: PUSH
92886: LD_INT 115
92888: EQUAL
92889: IFFALSE 92899
// sRanger := true ;
92891: LD_ADDR_EXP 146
92895: PUSH
92896: LD_INT 1
92898: ST_TO_ADDR
// if p3 = 116 then
92899: LD_VAR 0 3
92903: PUSH
92904: LD_INT 116
92906: EQUAL
92907: IFFALSE 92917
// sComputer := true ;
92909: LD_ADDR_EXP 147
92913: PUSH
92914: LD_INT 1
92916: ST_TO_ADDR
// if p3 = 117 then
92917: LD_VAR 0 3
92921: PUSH
92922: LD_INT 117
92924: EQUAL
92925: IFFALSE 92935
// s30 := true ;
92927: LD_ADDR_EXP 148
92931: PUSH
92932: LD_INT 1
92934: ST_TO_ADDR
// if p3 = 118 then
92935: LD_VAR 0 3
92939: PUSH
92940: LD_INT 118
92942: EQUAL
92943: IFFALSE 92953
// s60 := true ;
92945: LD_ADDR_EXP 149
92949: PUSH
92950: LD_INT 1
92952: ST_TO_ADDR
// end ; if p2 = 101 then
92953: LD_VAR 0 2
92957: PUSH
92958: LD_INT 101
92960: EQUAL
92961: IFFALSE 93089
// begin case p3 of 1 :
92963: LD_VAR 0 3
92967: PUSH
92968: LD_INT 1
92970: DOUBLE
92971: EQUAL
92972: IFTRUE 92976
92974: GO 92983
92976: POP
// hHackUnlimitedResources ; 2 :
92977: CALL 105187 0 0
92981: GO 93089
92983: LD_INT 2
92985: DOUBLE
92986: EQUAL
92987: IFTRUE 92991
92989: GO 92998
92991: POP
// hHackSetLevel10 ; 3 :
92992: CALL 105320 0 0
92996: GO 93089
92998: LD_INT 3
93000: DOUBLE
93001: EQUAL
93002: IFTRUE 93006
93004: GO 93013
93006: POP
// hHackSetLevel10YourUnits ; 4 :
93007: CALL 105405 0 0
93011: GO 93089
93013: LD_INT 4
93015: DOUBLE
93016: EQUAL
93017: IFTRUE 93021
93019: GO 93028
93021: POP
// hHackInvincible ; 5 :
93022: CALL 105853 0 0
93026: GO 93089
93028: LD_INT 5
93030: DOUBLE
93031: EQUAL
93032: IFTRUE 93036
93034: GO 93043
93036: POP
// hHackInvisible ; 6 :
93037: CALL 105964 0 0
93041: GO 93089
93043: LD_INT 6
93045: DOUBLE
93046: EQUAL
93047: IFTRUE 93051
93049: GO 93058
93051: POP
// hHackChangeYourSide ; 7 :
93052: CALL 106021 0 0
93056: GO 93089
93058: LD_INT 7
93060: DOUBLE
93061: EQUAL
93062: IFTRUE 93066
93064: GO 93073
93066: POP
// hHackChangeUnitSide ; 8 :
93067: CALL 106063 0 0
93071: GO 93089
93073: LD_INT 8
93075: DOUBLE
93076: EQUAL
93077: IFTRUE 93081
93079: GO 93088
93081: POP
// hHackFog ; end ;
93082: CALL 106164 0 0
93086: GO 93089
93088: POP
// end ; end ;
93089: LD_VAR 0 7
93093: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
93094: GO 93096
93096: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93097: LD_STRING initStreamRollete();
93099: PPUSH
93100: CALL_OW 559
// InitStreamMode ;
93104: CALL 93116 0 0
// DefineStreamItems ( false ) ;
93108: LD_INT 0
93110: PPUSH
93111: CALL 93580 0 1
// end ;
93115: END
// function InitStreamMode ; begin
93116: LD_INT 0
93118: PPUSH
// streamModeActive := false ;
93119: LD_ADDR_EXP 93
93123: PUSH
93124: LD_INT 0
93126: ST_TO_ADDR
// normalCounter := 36 ;
93127: LD_ADDR_EXP 94
93131: PUSH
93132: LD_INT 36
93134: ST_TO_ADDR
// hardcoreCounter := 18 ;
93135: LD_ADDR_EXP 95
93139: PUSH
93140: LD_INT 18
93142: ST_TO_ADDR
// sRocket := false ;
93143: LD_ADDR_EXP 98
93147: PUSH
93148: LD_INT 0
93150: ST_TO_ADDR
// sSpeed := false ;
93151: LD_ADDR_EXP 97
93155: PUSH
93156: LD_INT 0
93158: ST_TO_ADDR
// sEngine := false ;
93159: LD_ADDR_EXP 99
93163: PUSH
93164: LD_INT 0
93166: ST_TO_ADDR
// sSpec := false ;
93167: LD_ADDR_EXP 96
93171: PUSH
93172: LD_INT 0
93174: ST_TO_ADDR
// sLevel := false ;
93175: LD_ADDR_EXP 100
93179: PUSH
93180: LD_INT 0
93182: ST_TO_ADDR
// sArmoury := false ;
93183: LD_ADDR_EXP 101
93187: PUSH
93188: LD_INT 0
93190: ST_TO_ADDR
// sRadar := false ;
93191: LD_ADDR_EXP 102
93195: PUSH
93196: LD_INT 0
93198: ST_TO_ADDR
// sBunker := false ;
93199: LD_ADDR_EXP 103
93203: PUSH
93204: LD_INT 0
93206: ST_TO_ADDR
// sHack := false ;
93207: LD_ADDR_EXP 104
93211: PUSH
93212: LD_INT 0
93214: ST_TO_ADDR
// sFire := false ;
93215: LD_ADDR_EXP 105
93219: PUSH
93220: LD_INT 0
93222: ST_TO_ADDR
// sRefresh := false ;
93223: LD_ADDR_EXP 106
93227: PUSH
93228: LD_INT 0
93230: ST_TO_ADDR
// sExp := false ;
93231: LD_ADDR_EXP 107
93235: PUSH
93236: LD_INT 0
93238: ST_TO_ADDR
// sDepot := false ;
93239: LD_ADDR_EXP 108
93243: PUSH
93244: LD_INT 0
93246: ST_TO_ADDR
// sFlag := false ;
93247: LD_ADDR_EXP 109
93251: PUSH
93252: LD_INT 0
93254: ST_TO_ADDR
// sKamikadze := false ;
93255: LD_ADDR_EXP 117
93259: PUSH
93260: LD_INT 0
93262: ST_TO_ADDR
// sTroll := false ;
93263: LD_ADDR_EXP 118
93267: PUSH
93268: LD_INT 0
93270: ST_TO_ADDR
// sSlow := false ;
93271: LD_ADDR_EXP 119
93275: PUSH
93276: LD_INT 0
93278: ST_TO_ADDR
// sLack := false ;
93279: LD_ADDR_EXP 120
93283: PUSH
93284: LD_INT 0
93286: ST_TO_ADDR
// sTank := false ;
93287: LD_ADDR_EXP 122
93291: PUSH
93292: LD_INT 0
93294: ST_TO_ADDR
// sRemote := false ;
93295: LD_ADDR_EXP 123
93299: PUSH
93300: LD_INT 0
93302: ST_TO_ADDR
// sPowell := false ;
93303: LD_ADDR_EXP 124
93307: PUSH
93308: LD_INT 0
93310: ST_TO_ADDR
// sTeleport := false ;
93311: LD_ADDR_EXP 127
93315: PUSH
93316: LD_INT 0
93318: ST_TO_ADDR
// sOilTower := false ;
93319: LD_ADDR_EXP 129
93323: PUSH
93324: LD_INT 0
93326: ST_TO_ADDR
// sShovel := false ;
93327: LD_ADDR_EXP 130
93331: PUSH
93332: LD_INT 0
93334: ST_TO_ADDR
// sSheik := false ;
93335: LD_ADDR_EXP 131
93339: PUSH
93340: LD_INT 0
93342: ST_TO_ADDR
// sEarthquake := false ;
93343: LD_ADDR_EXP 133
93347: PUSH
93348: LD_INT 0
93350: ST_TO_ADDR
// sAI := false ;
93351: LD_ADDR_EXP 134
93355: PUSH
93356: LD_INT 0
93358: ST_TO_ADDR
// sCargo := false ;
93359: LD_ADDR_EXP 137
93363: PUSH
93364: LD_INT 0
93366: ST_TO_ADDR
// sDLaser := false ;
93367: LD_ADDR_EXP 138
93371: PUSH
93372: LD_INT 0
93374: ST_TO_ADDR
// sExchange := false ;
93375: LD_ADDR_EXP 139
93379: PUSH
93380: LD_INT 0
93382: ST_TO_ADDR
// sFac := false ;
93383: LD_ADDR_EXP 140
93387: PUSH
93388: LD_INT 0
93390: ST_TO_ADDR
// sPower := false ;
93391: LD_ADDR_EXP 141
93395: PUSH
93396: LD_INT 0
93398: ST_TO_ADDR
// sRandom := false ;
93399: LD_ADDR_EXP 142
93403: PUSH
93404: LD_INT 0
93406: ST_TO_ADDR
// sShield := false ;
93407: LD_ADDR_EXP 143
93411: PUSH
93412: LD_INT 0
93414: ST_TO_ADDR
// sTime := false ;
93415: LD_ADDR_EXP 144
93419: PUSH
93420: LD_INT 0
93422: ST_TO_ADDR
// sTools := false ;
93423: LD_ADDR_EXP 145
93427: PUSH
93428: LD_INT 0
93430: ST_TO_ADDR
// sSold := false ;
93431: LD_ADDR_EXP 110
93435: PUSH
93436: LD_INT 0
93438: ST_TO_ADDR
// sDiff := false ;
93439: LD_ADDR_EXP 111
93443: PUSH
93444: LD_INT 0
93446: ST_TO_ADDR
// sFog := false ;
93447: LD_ADDR_EXP 114
93451: PUSH
93452: LD_INT 0
93454: ST_TO_ADDR
// sReset := false ;
93455: LD_ADDR_EXP 115
93459: PUSH
93460: LD_INT 0
93462: ST_TO_ADDR
// sSun := false ;
93463: LD_ADDR_EXP 116
93467: PUSH
93468: LD_INT 0
93470: ST_TO_ADDR
// sTiger := false ;
93471: LD_ADDR_EXP 112
93475: PUSH
93476: LD_INT 0
93478: ST_TO_ADDR
// sBomb := false ;
93479: LD_ADDR_EXP 113
93483: PUSH
93484: LD_INT 0
93486: ST_TO_ADDR
// sWound := false ;
93487: LD_ADDR_EXP 121
93491: PUSH
93492: LD_INT 0
93494: ST_TO_ADDR
// sBetray := false ;
93495: LD_ADDR_EXP 125
93499: PUSH
93500: LD_INT 0
93502: ST_TO_ADDR
// sContamin := false ;
93503: LD_ADDR_EXP 126
93507: PUSH
93508: LD_INT 0
93510: ST_TO_ADDR
// sOil := false ;
93511: LD_ADDR_EXP 128
93515: PUSH
93516: LD_INT 0
93518: ST_TO_ADDR
// sStu := false ;
93519: LD_ADDR_EXP 132
93523: PUSH
93524: LD_INT 0
93526: ST_TO_ADDR
// sBazooka := false ;
93527: LD_ADDR_EXP 135
93531: PUSH
93532: LD_INT 0
93534: ST_TO_ADDR
// sMortar := false ;
93535: LD_ADDR_EXP 136
93539: PUSH
93540: LD_INT 0
93542: ST_TO_ADDR
// sRanger := false ;
93543: LD_ADDR_EXP 146
93547: PUSH
93548: LD_INT 0
93550: ST_TO_ADDR
// sComputer := false ;
93551: LD_ADDR_EXP 147
93555: PUSH
93556: LD_INT 0
93558: ST_TO_ADDR
// s30 := false ;
93559: LD_ADDR_EXP 148
93563: PUSH
93564: LD_INT 0
93566: ST_TO_ADDR
// s60 := false ;
93567: LD_ADDR_EXP 149
93571: PUSH
93572: LD_INT 0
93574: ST_TO_ADDR
// end ;
93575: LD_VAR 0 1
93579: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93580: LD_INT 0
93582: PPUSH
93583: PPUSH
93584: PPUSH
93585: PPUSH
93586: PPUSH
93587: PPUSH
93588: PPUSH
// result := [ ] ;
93589: LD_ADDR_VAR 0 2
93593: PUSH
93594: EMPTY
93595: ST_TO_ADDR
// if campaign_id = 1 then
93596: LD_OWVAR 69
93600: PUSH
93601: LD_INT 1
93603: EQUAL
93604: IFFALSE 96770
// begin case mission_number of 1 :
93606: LD_OWVAR 70
93610: PUSH
93611: LD_INT 1
93613: DOUBLE
93614: EQUAL
93615: IFTRUE 93619
93617: GO 93695
93619: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93620: LD_ADDR_VAR 0 2
93624: PUSH
93625: LD_INT 2
93627: PUSH
93628: LD_INT 4
93630: PUSH
93631: LD_INT 11
93633: PUSH
93634: LD_INT 12
93636: PUSH
93637: LD_INT 15
93639: PUSH
93640: LD_INT 16
93642: PUSH
93643: LD_INT 22
93645: PUSH
93646: LD_INT 23
93648: PUSH
93649: LD_INT 26
93651: PUSH
93652: EMPTY
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 101
93665: PUSH
93666: LD_INT 102
93668: PUSH
93669: LD_INT 106
93671: PUSH
93672: LD_INT 116
93674: PUSH
93675: LD_INT 117
93677: PUSH
93678: LD_INT 118
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: PUSH
93689: EMPTY
93690: LIST
93691: LIST
93692: ST_TO_ADDR
93693: GO 96768
93695: LD_INT 2
93697: DOUBLE
93698: EQUAL
93699: IFTRUE 93703
93701: GO 93787
93703: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93704: LD_ADDR_VAR 0 2
93708: PUSH
93709: LD_INT 2
93711: PUSH
93712: LD_INT 4
93714: PUSH
93715: LD_INT 11
93717: PUSH
93718: LD_INT 12
93720: PUSH
93721: LD_INT 15
93723: PUSH
93724: LD_INT 16
93726: PUSH
93727: LD_INT 22
93729: PUSH
93730: LD_INT 23
93732: PUSH
93733: LD_INT 26
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: LIST
93740: LIST
93741: LIST
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 101
93749: PUSH
93750: LD_INT 102
93752: PUSH
93753: LD_INT 105
93755: PUSH
93756: LD_INT 106
93758: PUSH
93759: LD_INT 108
93761: PUSH
93762: LD_INT 116
93764: PUSH
93765: LD_INT 117
93767: PUSH
93768: LD_INT 118
93770: PUSH
93771: EMPTY
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: ST_TO_ADDR
93785: GO 96768
93787: LD_INT 3
93789: DOUBLE
93790: EQUAL
93791: IFTRUE 93795
93793: GO 93883
93795: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93796: LD_ADDR_VAR 0 2
93800: PUSH
93801: LD_INT 2
93803: PUSH
93804: LD_INT 4
93806: PUSH
93807: LD_INT 5
93809: PUSH
93810: LD_INT 11
93812: PUSH
93813: LD_INT 12
93815: PUSH
93816: LD_INT 15
93818: PUSH
93819: LD_INT 16
93821: PUSH
93822: LD_INT 22
93824: PUSH
93825: LD_INT 26
93827: PUSH
93828: LD_INT 36
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 101
93845: PUSH
93846: LD_INT 102
93848: PUSH
93849: LD_INT 105
93851: PUSH
93852: LD_INT 106
93854: PUSH
93855: LD_INT 108
93857: PUSH
93858: LD_INT 116
93860: PUSH
93861: LD_INT 117
93863: PUSH
93864: LD_INT 118
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: PUSH
93877: EMPTY
93878: LIST
93879: LIST
93880: ST_TO_ADDR
93881: GO 96768
93883: LD_INT 4
93885: DOUBLE
93886: EQUAL
93887: IFTRUE 93891
93889: GO 93987
93891: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
93892: LD_ADDR_VAR 0 2
93896: PUSH
93897: LD_INT 2
93899: PUSH
93900: LD_INT 4
93902: PUSH
93903: LD_INT 5
93905: PUSH
93906: LD_INT 8
93908: PUSH
93909: LD_INT 11
93911: PUSH
93912: LD_INT 12
93914: PUSH
93915: LD_INT 15
93917: PUSH
93918: LD_INT 16
93920: PUSH
93921: LD_INT 22
93923: PUSH
93924: LD_INT 23
93926: PUSH
93927: LD_INT 26
93929: PUSH
93930: LD_INT 36
93932: PUSH
93933: EMPTY
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: LIST
93946: PUSH
93947: LD_INT 101
93949: PUSH
93950: LD_INT 102
93952: PUSH
93953: LD_INT 105
93955: PUSH
93956: LD_INT 106
93958: PUSH
93959: LD_INT 108
93961: PUSH
93962: LD_INT 116
93964: PUSH
93965: LD_INT 117
93967: PUSH
93968: LD_INT 118
93970: PUSH
93971: EMPTY
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: ST_TO_ADDR
93985: GO 96768
93987: LD_INT 5
93989: DOUBLE
93990: EQUAL
93991: IFTRUE 93995
93993: GO 94107
93995: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93996: LD_ADDR_VAR 0 2
94000: PUSH
94001: LD_INT 2
94003: PUSH
94004: LD_INT 4
94006: PUSH
94007: LD_INT 5
94009: PUSH
94010: LD_INT 6
94012: PUSH
94013: LD_INT 8
94015: PUSH
94016: LD_INT 11
94018: PUSH
94019: LD_INT 12
94021: PUSH
94022: LD_INT 15
94024: PUSH
94025: LD_INT 16
94027: PUSH
94028: LD_INT 22
94030: PUSH
94031: LD_INT 23
94033: PUSH
94034: LD_INT 25
94036: PUSH
94037: LD_INT 26
94039: PUSH
94040: LD_INT 36
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 101
94061: PUSH
94062: LD_INT 102
94064: PUSH
94065: LD_INT 105
94067: PUSH
94068: LD_INT 106
94070: PUSH
94071: LD_INT 108
94073: PUSH
94074: LD_INT 109
94076: PUSH
94077: LD_INT 112
94079: PUSH
94080: LD_INT 116
94082: PUSH
94083: LD_INT 117
94085: PUSH
94086: LD_INT 118
94088: PUSH
94089: EMPTY
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: ST_TO_ADDR
94105: GO 96768
94107: LD_INT 6
94109: DOUBLE
94110: EQUAL
94111: IFTRUE 94115
94113: GO 94247
94115: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94116: LD_ADDR_VAR 0 2
94120: PUSH
94121: LD_INT 2
94123: PUSH
94124: LD_INT 4
94126: PUSH
94127: LD_INT 5
94129: PUSH
94130: LD_INT 6
94132: PUSH
94133: LD_INT 8
94135: PUSH
94136: LD_INT 11
94138: PUSH
94139: LD_INT 12
94141: PUSH
94142: LD_INT 15
94144: PUSH
94145: LD_INT 16
94147: PUSH
94148: LD_INT 20
94150: PUSH
94151: LD_INT 21
94153: PUSH
94154: LD_INT 22
94156: PUSH
94157: LD_INT 23
94159: PUSH
94160: LD_INT 25
94162: PUSH
94163: LD_INT 26
94165: PUSH
94166: LD_INT 30
94168: PUSH
94169: LD_INT 31
94171: PUSH
94172: LD_INT 32
94174: PUSH
94175: LD_INT 36
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: LIST
94187: LIST
94188: LIST
94189: LIST
94190: LIST
94191: LIST
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: PUSH
94199: LD_INT 101
94201: PUSH
94202: LD_INT 102
94204: PUSH
94205: LD_INT 105
94207: PUSH
94208: LD_INT 106
94210: PUSH
94211: LD_INT 108
94213: PUSH
94214: LD_INT 109
94216: PUSH
94217: LD_INT 112
94219: PUSH
94220: LD_INT 116
94222: PUSH
94223: LD_INT 117
94225: PUSH
94226: LD_INT 118
94228: PUSH
94229: EMPTY
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: LIST
94239: LIST
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: ST_TO_ADDR
94245: GO 96768
94247: LD_INT 7
94249: DOUBLE
94250: EQUAL
94251: IFTRUE 94255
94253: GO 94367
94255: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94256: LD_ADDR_VAR 0 2
94260: PUSH
94261: LD_INT 2
94263: PUSH
94264: LD_INT 4
94266: PUSH
94267: LD_INT 5
94269: PUSH
94270: LD_INT 7
94272: PUSH
94273: LD_INT 11
94275: PUSH
94276: LD_INT 12
94278: PUSH
94279: LD_INT 15
94281: PUSH
94282: LD_INT 16
94284: PUSH
94285: LD_INT 20
94287: PUSH
94288: LD_INT 21
94290: PUSH
94291: LD_INT 22
94293: PUSH
94294: LD_INT 23
94296: PUSH
94297: LD_INT 25
94299: PUSH
94300: LD_INT 26
94302: PUSH
94303: EMPTY
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 101
94321: PUSH
94322: LD_INT 102
94324: PUSH
94325: LD_INT 103
94327: PUSH
94328: LD_INT 105
94330: PUSH
94331: LD_INT 106
94333: PUSH
94334: LD_INT 108
94336: PUSH
94337: LD_INT 112
94339: PUSH
94340: LD_INT 116
94342: PUSH
94343: LD_INT 117
94345: PUSH
94346: LD_INT 118
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: ST_TO_ADDR
94365: GO 96768
94367: LD_INT 8
94369: DOUBLE
94370: EQUAL
94371: IFTRUE 94375
94373: GO 94515
94375: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94376: LD_ADDR_VAR 0 2
94380: PUSH
94381: LD_INT 2
94383: PUSH
94384: LD_INT 4
94386: PUSH
94387: LD_INT 5
94389: PUSH
94390: LD_INT 6
94392: PUSH
94393: LD_INT 7
94395: PUSH
94396: LD_INT 8
94398: PUSH
94399: LD_INT 11
94401: PUSH
94402: LD_INT 12
94404: PUSH
94405: LD_INT 15
94407: PUSH
94408: LD_INT 16
94410: PUSH
94411: LD_INT 20
94413: PUSH
94414: LD_INT 21
94416: PUSH
94417: LD_INT 22
94419: PUSH
94420: LD_INT 23
94422: PUSH
94423: LD_INT 25
94425: PUSH
94426: LD_INT 26
94428: PUSH
94429: LD_INT 30
94431: PUSH
94432: LD_INT 31
94434: PUSH
94435: LD_INT 32
94437: PUSH
94438: LD_INT 36
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 101
94465: PUSH
94466: LD_INT 102
94468: PUSH
94469: LD_INT 103
94471: PUSH
94472: LD_INT 105
94474: PUSH
94475: LD_INT 106
94477: PUSH
94478: LD_INT 108
94480: PUSH
94481: LD_INT 109
94483: PUSH
94484: LD_INT 112
94486: PUSH
94487: LD_INT 116
94489: PUSH
94490: LD_INT 117
94492: PUSH
94493: LD_INT 118
94495: PUSH
94496: EMPTY
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: ST_TO_ADDR
94513: GO 96768
94515: LD_INT 9
94517: DOUBLE
94518: EQUAL
94519: IFTRUE 94523
94521: GO 94671
94523: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94524: LD_ADDR_VAR 0 2
94528: PUSH
94529: LD_INT 2
94531: PUSH
94532: LD_INT 4
94534: PUSH
94535: LD_INT 5
94537: PUSH
94538: LD_INT 6
94540: PUSH
94541: LD_INT 7
94543: PUSH
94544: LD_INT 8
94546: PUSH
94547: LD_INT 11
94549: PUSH
94550: LD_INT 12
94552: PUSH
94553: LD_INT 15
94555: PUSH
94556: LD_INT 16
94558: PUSH
94559: LD_INT 20
94561: PUSH
94562: LD_INT 21
94564: PUSH
94565: LD_INT 22
94567: PUSH
94568: LD_INT 23
94570: PUSH
94571: LD_INT 25
94573: PUSH
94574: LD_INT 26
94576: PUSH
94577: LD_INT 28
94579: PUSH
94580: LD_INT 30
94582: PUSH
94583: LD_INT 31
94585: PUSH
94586: LD_INT 32
94588: PUSH
94589: LD_INT 36
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: PUSH
94615: LD_INT 101
94617: PUSH
94618: LD_INT 102
94620: PUSH
94621: LD_INT 103
94623: PUSH
94624: LD_INT 105
94626: PUSH
94627: LD_INT 106
94629: PUSH
94630: LD_INT 108
94632: PUSH
94633: LD_INT 109
94635: PUSH
94636: LD_INT 112
94638: PUSH
94639: LD_INT 114
94641: PUSH
94642: LD_INT 116
94644: PUSH
94645: LD_INT 117
94647: PUSH
94648: LD_INT 118
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: LIST
94659: LIST
94660: LIST
94661: LIST
94662: LIST
94663: LIST
94664: PUSH
94665: EMPTY
94666: LIST
94667: LIST
94668: ST_TO_ADDR
94669: GO 96768
94671: LD_INT 10
94673: DOUBLE
94674: EQUAL
94675: IFTRUE 94679
94677: GO 94875
94679: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94680: LD_ADDR_VAR 0 2
94684: PUSH
94685: LD_INT 2
94687: PUSH
94688: LD_INT 4
94690: PUSH
94691: LD_INT 5
94693: PUSH
94694: LD_INT 6
94696: PUSH
94697: LD_INT 7
94699: PUSH
94700: LD_INT 8
94702: PUSH
94703: LD_INT 9
94705: PUSH
94706: LD_INT 10
94708: PUSH
94709: LD_INT 11
94711: PUSH
94712: LD_INT 12
94714: PUSH
94715: LD_INT 13
94717: PUSH
94718: LD_INT 14
94720: PUSH
94721: LD_INT 15
94723: PUSH
94724: LD_INT 16
94726: PUSH
94727: LD_INT 17
94729: PUSH
94730: LD_INT 18
94732: PUSH
94733: LD_INT 19
94735: PUSH
94736: LD_INT 20
94738: PUSH
94739: LD_INT 21
94741: PUSH
94742: LD_INT 22
94744: PUSH
94745: LD_INT 23
94747: PUSH
94748: LD_INT 24
94750: PUSH
94751: LD_INT 25
94753: PUSH
94754: LD_INT 26
94756: PUSH
94757: LD_INT 28
94759: PUSH
94760: LD_INT 30
94762: PUSH
94763: LD_INT 31
94765: PUSH
94766: LD_INT 32
94768: PUSH
94769: LD_INT 36
94771: PUSH
94772: EMPTY
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: PUSH
94803: LD_INT 101
94805: PUSH
94806: LD_INT 102
94808: PUSH
94809: LD_INT 103
94811: PUSH
94812: LD_INT 104
94814: PUSH
94815: LD_INT 105
94817: PUSH
94818: LD_INT 106
94820: PUSH
94821: LD_INT 107
94823: PUSH
94824: LD_INT 108
94826: PUSH
94827: LD_INT 109
94829: PUSH
94830: LD_INT 110
94832: PUSH
94833: LD_INT 111
94835: PUSH
94836: LD_INT 112
94838: PUSH
94839: LD_INT 114
94841: PUSH
94842: LD_INT 116
94844: PUSH
94845: LD_INT 117
94847: PUSH
94848: LD_INT 118
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: PUSH
94869: EMPTY
94870: LIST
94871: LIST
94872: ST_TO_ADDR
94873: GO 96768
94875: LD_INT 11
94877: DOUBLE
94878: EQUAL
94879: IFTRUE 94883
94881: GO 95087
94883: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
94884: LD_ADDR_VAR 0 2
94888: PUSH
94889: LD_INT 2
94891: PUSH
94892: LD_INT 3
94894: PUSH
94895: LD_INT 4
94897: PUSH
94898: LD_INT 5
94900: PUSH
94901: LD_INT 6
94903: PUSH
94904: LD_INT 7
94906: PUSH
94907: LD_INT 8
94909: PUSH
94910: LD_INT 9
94912: PUSH
94913: LD_INT 10
94915: PUSH
94916: LD_INT 11
94918: PUSH
94919: LD_INT 12
94921: PUSH
94922: LD_INT 13
94924: PUSH
94925: LD_INT 14
94927: PUSH
94928: LD_INT 15
94930: PUSH
94931: LD_INT 16
94933: PUSH
94934: LD_INT 17
94936: PUSH
94937: LD_INT 18
94939: PUSH
94940: LD_INT 19
94942: PUSH
94943: LD_INT 20
94945: PUSH
94946: LD_INT 21
94948: PUSH
94949: LD_INT 22
94951: PUSH
94952: LD_INT 23
94954: PUSH
94955: LD_INT 24
94957: PUSH
94958: LD_INT 25
94960: PUSH
94961: LD_INT 26
94963: PUSH
94964: LD_INT 28
94966: PUSH
94967: LD_INT 30
94969: PUSH
94970: LD_INT 31
94972: PUSH
94973: LD_INT 32
94975: PUSH
94976: LD_INT 34
94978: PUSH
94979: LD_INT 36
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: PUSH
95015: LD_INT 101
95017: PUSH
95018: LD_INT 102
95020: PUSH
95021: LD_INT 103
95023: PUSH
95024: LD_INT 104
95026: PUSH
95027: LD_INT 105
95029: PUSH
95030: LD_INT 106
95032: PUSH
95033: LD_INT 107
95035: PUSH
95036: LD_INT 108
95038: PUSH
95039: LD_INT 109
95041: PUSH
95042: LD_INT 110
95044: PUSH
95045: LD_INT 111
95047: PUSH
95048: LD_INT 112
95050: PUSH
95051: LD_INT 114
95053: PUSH
95054: LD_INT 116
95056: PUSH
95057: LD_INT 117
95059: PUSH
95060: LD_INT 118
95062: PUSH
95063: EMPTY
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: PUSH
95081: EMPTY
95082: LIST
95083: LIST
95084: ST_TO_ADDR
95085: GO 96768
95087: LD_INT 12
95089: DOUBLE
95090: EQUAL
95091: IFTRUE 95095
95093: GO 95315
95095: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95096: LD_ADDR_VAR 0 2
95100: PUSH
95101: LD_INT 1
95103: PUSH
95104: LD_INT 2
95106: PUSH
95107: LD_INT 3
95109: PUSH
95110: LD_INT 4
95112: PUSH
95113: LD_INT 5
95115: PUSH
95116: LD_INT 6
95118: PUSH
95119: LD_INT 7
95121: PUSH
95122: LD_INT 8
95124: PUSH
95125: LD_INT 9
95127: PUSH
95128: LD_INT 10
95130: PUSH
95131: LD_INT 11
95133: PUSH
95134: LD_INT 12
95136: PUSH
95137: LD_INT 13
95139: PUSH
95140: LD_INT 14
95142: PUSH
95143: LD_INT 15
95145: PUSH
95146: LD_INT 16
95148: PUSH
95149: LD_INT 17
95151: PUSH
95152: LD_INT 18
95154: PUSH
95155: LD_INT 19
95157: PUSH
95158: LD_INT 20
95160: PUSH
95161: LD_INT 21
95163: PUSH
95164: LD_INT 22
95166: PUSH
95167: LD_INT 23
95169: PUSH
95170: LD_INT 24
95172: PUSH
95173: LD_INT 25
95175: PUSH
95176: LD_INT 26
95178: PUSH
95179: LD_INT 27
95181: PUSH
95182: LD_INT 28
95184: PUSH
95185: LD_INT 30
95187: PUSH
95188: LD_INT 31
95190: PUSH
95191: LD_INT 32
95193: PUSH
95194: LD_INT 33
95196: PUSH
95197: LD_INT 34
95199: PUSH
95200: LD_INT 36
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: PUSH
95239: LD_INT 101
95241: PUSH
95242: LD_INT 102
95244: PUSH
95245: LD_INT 103
95247: PUSH
95248: LD_INT 104
95250: PUSH
95251: LD_INT 105
95253: PUSH
95254: LD_INT 106
95256: PUSH
95257: LD_INT 107
95259: PUSH
95260: LD_INT 108
95262: PUSH
95263: LD_INT 109
95265: PUSH
95266: LD_INT 110
95268: PUSH
95269: LD_INT 111
95271: PUSH
95272: LD_INT 112
95274: PUSH
95275: LD_INT 113
95277: PUSH
95278: LD_INT 114
95280: PUSH
95281: LD_INT 116
95283: PUSH
95284: LD_INT 117
95286: PUSH
95287: LD_INT 118
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: ST_TO_ADDR
95313: GO 96768
95315: LD_INT 13
95317: DOUBLE
95318: EQUAL
95319: IFTRUE 95323
95321: GO 95531
95323: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95324: LD_ADDR_VAR 0 2
95328: PUSH
95329: LD_INT 1
95331: PUSH
95332: LD_INT 2
95334: PUSH
95335: LD_INT 3
95337: PUSH
95338: LD_INT 4
95340: PUSH
95341: LD_INT 5
95343: PUSH
95344: LD_INT 8
95346: PUSH
95347: LD_INT 9
95349: PUSH
95350: LD_INT 10
95352: PUSH
95353: LD_INT 11
95355: PUSH
95356: LD_INT 12
95358: PUSH
95359: LD_INT 14
95361: PUSH
95362: LD_INT 15
95364: PUSH
95365: LD_INT 16
95367: PUSH
95368: LD_INT 17
95370: PUSH
95371: LD_INT 18
95373: PUSH
95374: LD_INT 19
95376: PUSH
95377: LD_INT 20
95379: PUSH
95380: LD_INT 21
95382: PUSH
95383: LD_INT 22
95385: PUSH
95386: LD_INT 23
95388: PUSH
95389: LD_INT 24
95391: PUSH
95392: LD_INT 25
95394: PUSH
95395: LD_INT 26
95397: PUSH
95398: LD_INT 27
95400: PUSH
95401: LD_INT 28
95403: PUSH
95404: LD_INT 30
95406: PUSH
95407: LD_INT 31
95409: PUSH
95410: LD_INT 32
95412: PUSH
95413: LD_INT 33
95415: PUSH
95416: LD_INT 34
95418: PUSH
95419: LD_INT 36
95421: PUSH
95422: EMPTY
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: PUSH
95455: LD_INT 101
95457: PUSH
95458: LD_INT 102
95460: PUSH
95461: LD_INT 103
95463: PUSH
95464: LD_INT 104
95466: PUSH
95467: LD_INT 105
95469: PUSH
95470: LD_INT 106
95472: PUSH
95473: LD_INT 107
95475: PUSH
95476: LD_INT 108
95478: PUSH
95479: LD_INT 109
95481: PUSH
95482: LD_INT 110
95484: PUSH
95485: LD_INT 111
95487: PUSH
95488: LD_INT 112
95490: PUSH
95491: LD_INT 113
95493: PUSH
95494: LD_INT 114
95496: PUSH
95497: LD_INT 116
95499: PUSH
95500: LD_INT 117
95502: PUSH
95503: LD_INT 118
95505: PUSH
95506: EMPTY
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: ST_TO_ADDR
95529: GO 96768
95531: LD_INT 14
95533: DOUBLE
95534: EQUAL
95535: IFTRUE 95539
95537: GO 95763
95539: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95540: LD_ADDR_VAR 0 2
95544: PUSH
95545: LD_INT 1
95547: PUSH
95548: LD_INT 2
95550: PUSH
95551: LD_INT 3
95553: PUSH
95554: LD_INT 4
95556: PUSH
95557: LD_INT 5
95559: PUSH
95560: LD_INT 6
95562: PUSH
95563: LD_INT 7
95565: PUSH
95566: LD_INT 8
95568: PUSH
95569: LD_INT 9
95571: PUSH
95572: LD_INT 10
95574: PUSH
95575: LD_INT 11
95577: PUSH
95578: LD_INT 12
95580: PUSH
95581: LD_INT 13
95583: PUSH
95584: LD_INT 14
95586: PUSH
95587: LD_INT 15
95589: PUSH
95590: LD_INT 16
95592: PUSH
95593: LD_INT 17
95595: PUSH
95596: LD_INT 18
95598: PUSH
95599: LD_INT 19
95601: PUSH
95602: LD_INT 20
95604: PUSH
95605: LD_INT 21
95607: PUSH
95608: LD_INT 22
95610: PUSH
95611: LD_INT 23
95613: PUSH
95614: LD_INT 24
95616: PUSH
95617: LD_INT 25
95619: PUSH
95620: LD_INT 26
95622: PUSH
95623: LD_INT 27
95625: PUSH
95626: LD_INT 28
95628: PUSH
95629: LD_INT 29
95631: PUSH
95632: LD_INT 30
95634: PUSH
95635: LD_INT 31
95637: PUSH
95638: LD_INT 32
95640: PUSH
95641: LD_INT 33
95643: PUSH
95644: LD_INT 34
95646: PUSH
95647: LD_INT 36
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: PUSH
95687: LD_INT 101
95689: PUSH
95690: LD_INT 102
95692: PUSH
95693: LD_INT 103
95695: PUSH
95696: LD_INT 104
95698: PUSH
95699: LD_INT 105
95701: PUSH
95702: LD_INT 106
95704: PUSH
95705: LD_INT 107
95707: PUSH
95708: LD_INT 108
95710: PUSH
95711: LD_INT 109
95713: PUSH
95714: LD_INT 110
95716: PUSH
95717: LD_INT 111
95719: PUSH
95720: LD_INT 112
95722: PUSH
95723: LD_INT 113
95725: PUSH
95726: LD_INT 114
95728: PUSH
95729: LD_INT 116
95731: PUSH
95732: LD_INT 117
95734: PUSH
95735: LD_INT 118
95737: PUSH
95738: EMPTY
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: ST_TO_ADDR
95761: GO 96768
95763: LD_INT 15
95765: DOUBLE
95766: EQUAL
95767: IFTRUE 95771
95769: GO 95995
95771: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95772: LD_ADDR_VAR 0 2
95776: PUSH
95777: LD_INT 1
95779: PUSH
95780: LD_INT 2
95782: PUSH
95783: LD_INT 3
95785: PUSH
95786: LD_INT 4
95788: PUSH
95789: LD_INT 5
95791: PUSH
95792: LD_INT 6
95794: PUSH
95795: LD_INT 7
95797: PUSH
95798: LD_INT 8
95800: PUSH
95801: LD_INT 9
95803: PUSH
95804: LD_INT 10
95806: PUSH
95807: LD_INT 11
95809: PUSH
95810: LD_INT 12
95812: PUSH
95813: LD_INT 13
95815: PUSH
95816: LD_INT 14
95818: PUSH
95819: LD_INT 15
95821: PUSH
95822: LD_INT 16
95824: PUSH
95825: LD_INT 17
95827: PUSH
95828: LD_INT 18
95830: PUSH
95831: LD_INT 19
95833: PUSH
95834: LD_INT 20
95836: PUSH
95837: LD_INT 21
95839: PUSH
95840: LD_INT 22
95842: PUSH
95843: LD_INT 23
95845: PUSH
95846: LD_INT 24
95848: PUSH
95849: LD_INT 25
95851: PUSH
95852: LD_INT 26
95854: PUSH
95855: LD_INT 27
95857: PUSH
95858: LD_INT 28
95860: PUSH
95861: LD_INT 29
95863: PUSH
95864: LD_INT 30
95866: PUSH
95867: LD_INT 31
95869: PUSH
95870: LD_INT 32
95872: PUSH
95873: LD_INT 33
95875: PUSH
95876: LD_INT 34
95878: PUSH
95879: LD_INT 36
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 101
95921: PUSH
95922: LD_INT 102
95924: PUSH
95925: LD_INT 103
95927: PUSH
95928: LD_INT 104
95930: PUSH
95931: LD_INT 105
95933: PUSH
95934: LD_INT 106
95936: PUSH
95937: LD_INT 107
95939: PUSH
95940: LD_INT 108
95942: PUSH
95943: LD_INT 109
95945: PUSH
95946: LD_INT 110
95948: PUSH
95949: LD_INT 111
95951: PUSH
95952: LD_INT 112
95954: PUSH
95955: LD_INT 113
95957: PUSH
95958: LD_INT 114
95960: PUSH
95961: LD_INT 116
95963: PUSH
95964: LD_INT 117
95966: PUSH
95967: LD_INT 118
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: LIST
95987: LIST
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: ST_TO_ADDR
95993: GO 96768
95995: LD_INT 16
95997: DOUBLE
95998: EQUAL
95999: IFTRUE 96003
96001: GO 96139
96003: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96004: LD_ADDR_VAR 0 2
96008: PUSH
96009: LD_INT 2
96011: PUSH
96012: LD_INT 4
96014: PUSH
96015: LD_INT 5
96017: PUSH
96018: LD_INT 7
96020: PUSH
96021: LD_INT 11
96023: PUSH
96024: LD_INT 12
96026: PUSH
96027: LD_INT 15
96029: PUSH
96030: LD_INT 16
96032: PUSH
96033: LD_INT 20
96035: PUSH
96036: LD_INT 21
96038: PUSH
96039: LD_INT 22
96041: PUSH
96042: LD_INT 23
96044: PUSH
96045: LD_INT 25
96047: PUSH
96048: LD_INT 26
96050: PUSH
96051: LD_INT 30
96053: PUSH
96054: LD_INT 31
96056: PUSH
96057: LD_INT 32
96059: PUSH
96060: LD_INT 33
96062: PUSH
96063: LD_INT 34
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: PUSH
96087: LD_INT 101
96089: PUSH
96090: LD_INT 102
96092: PUSH
96093: LD_INT 103
96095: PUSH
96096: LD_INT 106
96098: PUSH
96099: LD_INT 108
96101: PUSH
96102: LD_INT 112
96104: PUSH
96105: LD_INT 113
96107: PUSH
96108: LD_INT 114
96110: PUSH
96111: LD_INT 116
96113: PUSH
96114: LD_INT 117
96116: PUSH
96117: LD_INT 118
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: PUSH
96133: EMPTY
96134: LIST
96135: LIST
96136: ST_TO_ADDR
96137: GO 96768
96139: LD_INT 17
96141: DOUBLE
96142: EQUAL
96143: IFTRUE 96147
96145: GO 96371
96147: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96148: LD_ADDR_VAR 0 2
96152: PUSH
96153: LD_INT 1
96155: PUSH
96156: LD_INT 2
96158: PUSH
96159: LD_INT 3
96161: PUSH
96162: LD_INT 4
96164: PUSH
96165: LD_INT 5
96167: PUSH
96168: LD_INT 6
96170: PUSH
96171: LD_INT 7
96173: PUSH
96174: LD_INT 8
96176: PUSH
96177: LD_INT 9
96179: PUSH
96180: LD_INT 10
96182: PUSH
96183: LD_INT 11
96185: PUSH
96186: LD_INT 12
96188: PUSH
96189: LD_INT 13
96191: PUSH
96192: LD_INT 14
96194: PUSH
96195: LD_INT 15
96197: PUSH
96198: LD_INT 16
96200: PUSH
96201: LD_INT 17
96203: PUSH
96204: LD_INT 18
96206: PUSH
96207: LD_INT 19
96209: PUSH
96210: LD_INT 20
96212: PUSH
96213: LD_INT 21
96215: PUSH
96216: LD_INT 22
96218: PUSH
96219: LD_INT 23
96221: PUSH
96222: LD_INT 24
96224: PUSH
96225: LD_INT 25
96227: PUSH
96228: LD_INT 26
96230: PUSH
96231: LD_INT 27
96233: PUSH
96234: LD_INT 28
96236: PUSH
96237: LD_INT 29
96239: PUSH
96240: LD_INT 30
96242: PUSH
96243: LD_INT 31
96245: PUSH
96246: LD_INT 32
96248: PUSH
96249: LD_INT 33
96251: PUSH
96252: LD_INT 34
96254: PUSH
96255: LD_INT 36
96257: PUSH
96258: EMPTY
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: PUSH
96295: LD_INT 101
96297: PUSH
96298: LD_INT 102
96300: PUSH
96301: LD_INT 103
96303: PUSH
96304: LD_INT 104
96306: PUSH
96307: LD_INT 105
96309: PUSH
96310: LD_INT 106
96312: PUSH
96313: LD_INT 107
96315: PUSH
96316: LD_INT 108
96318: PUSH
96319: LD_INT 109
96321: PUSH
96322: LD_INT 110
96324: PUSH
96325: LD_INT 111
96327: PUSH
96328: LD_INT 112
96330: PUSH
96331: LD_INT 113
96333: PUSH
96334: LD_INT 114
96336: PUSH
96337: LD_INT 116
96339: PUSH
96340: LD_INT 117
96342: PUSH
96343: LD_INT 118
96345: PUSH
96346: EMPTY
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: PUSH
96365: EMPTY
96366: LIST
96367: LIST
96368: ST_TO_ADDR
96369: GO 96768
96371: LD_INT 18
96373: DOUBLE
96374: EQUAL
96375: IFTRUE 96379
96377: GO 96527
96379: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96380: LD_ADDR_VAR 0 2
96384: PUSH
96385: LD_INT 2
96387: PUSH
96388: LD_INT 4
96390: PUSH
96391: LD_INT 5
96393: PUSH
96394: LD_INT 7
96396: PUSH
96397: LD_INT 11
96399: PUSH
96400: LD_INT 12
96402: PUSH
96403: LD_INT 15
96405: PUSH
96406: LD_INT 16
96408: PUSH
96409: LD_INT 20
96411: PUSH
96412: LD_INT 21
96414: PUSH
96415: LD_INT 22
96417: PUSH
96418: LD_INT 23
96420: PUSH
96421: LD_INT 25
96423: PUSH
96424: LD_INT 26
96426: PUSH
96427: LD_INT 30
96429: PUSH
96430: LD_INT 31
96432: PUSH
96433: LD_INT 32
96435: PUSH
96436: LD_INT 33
96438: PUSH
96439: LD_INT 34
96441: PUSH
96442: LD_INT 35
96444: PUSH
96445: LD_INT 36
96447: PUSH
96448: EMPTY
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 101
96473: PUSH
96474: LD_INT 102
96476: PUSH
96477: LD_INT 103
96479: PUSH
96480: LD_INT 106
96482: PUSH
96483: LD_INT 108
96485: PUSH
96486: LD_INT 112
96488: PUSH
96489: LD_INT 113
96491: PUSH
96492: LD_INT 114
96494: PUSH
96495: LD_INT 115
96497: PUSH
96498: LD_INT 116
96500: PUSH
96501: LD_INT 117
96503: PUSH
96504: LD_INT 118
96506: PUSH
96507: EMPTY
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: PUSH
96521: EMPTY
96522: LIST
96523: LIST
96524: ST_TO_ADDR
96525: GO 96768
96527: LD_INT 19
96529: DOUBLE
96530: EQUAL
96531: IFTRUE 96535
96533: GO 96767
96535: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96536: LD_ADDR_VAR 0 2
96540: PUSH
96541: LD_INT 1
96543: PUSH
96544: LD_INT 2
96546: PUSH
96547: LD_INT 3
96549: PUSH
96550: LD_INT 4
96552: PUSH
96553: LD_INT 5
96555: PUSH
96556: LD_INT 6
96558: PUSH
96559: LD_INT 7
96561: PUSH
96562: LD_INT 8
96564: PUSH
96565: LD_INT 9
96567: PUSH
96568: LD_INT 10
96570: PUSH
96571: LD_INT 11
96573: PUSH
96574: LD_INT 12
96576: PUSH
96577: LD_INT 13
96579: PUSH
96580: LD_INT 14
96582: PUSH
96583: LD_INT 15
96585: PUSH
96586: LD_INT 16
96588: PUSH
96589: LD_INT 17
96591: PUSH
96592: LD_INT 18
96594: PUSH
96595: LD_INT 19
96597: PUSH
96598: LD_INT 20
96600: PUSH
96601: LD_INT 21
96603: PUSH
96604: LD_INT 22
96606: PUSH
96607: LD_INT 23
96609: PUSH
96610: LD_INT 24
96612: PUSH
96613: LD_INT 25
96615: PUSH
96616: LD_INT 26
96618: PUSH
96619: LD_INT 27
96621: PUSH
96622: LD_INT 28
96624: PUSH
96625: LD_INT 29
96627: PUSH
96628: LD_INT 30
96630: PUSH
96631: LD_INT 31
96633: PUSH
96634: LD_INT 32
96636: PUSH
96637: LD_INT 33
96639: PUSH
96640: LD_INT 34
96642: PUSH
96643: LD_INT 35
96645: PUSH
96646: LD_INT 36
96648: PUSH
96649: EMPTY
96650: LIST
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: PUSH
96687: LD_INT 101
96689: PUSH
96690: LD_INT 102
96692: PUSH
96693: LD_INT 103
96695: PUSH
96696: LD_INT 104
96698: PUSH
96699: LD_INT 105
96701: PUSH
96702: LD_INT 106
96704: PUSH
96705: LD_INT 107
96707: PUSH
96708: LD_INT 108
96710: PUSH
96711: LD_INT 109
96713: PUSH
96714: LD_INT 110
96716: PUSH
96717: LD_INT 111
96719: PUSH
96720: LD_INT 112
96722: PUSH
96723: LD_INT 113
96725: PUSH
96726: LD_INT 114
96728: PUSH
96729: LD_INT 115
96731: PUSH
96732: LD_INT 116
96734: PUSH
96735: LD_INT 117
96737: PUSH
96738: LD_INT 118
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: LIST
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: PUSH
96761: EMPTY
96762: LIST
96763: LIST
96764: ST_TO_ADDR
96765: GO 96768
96767: POP
// end else
96768: GO 96999
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96770: LD_ADDR_VAR 0 2
96774: PUSH
96775: LD_INT 1
96777: PUSH
96778: LD_INT 2
96780: PUSH
96781: LD_INT 3
96783: PUSH
96784: LD_INT 4
96786: PUSH
96787: LD_INT 5
96789: PUSH
96790: LD_INT 6
96792: PUSH
96793: LD_INT 7
96795: PUSH
96796: LD_INT 8
96798: PUSH
96799: LD_INT 9
96801: PUSH
96802: LD_INT 10
96804: PUSH
96805: LD_INT 11
96807: PUSH
96808: LD_INT 12
96810: PUSH
96811: LD_INT 13
96813: PUSH
96814: LD_INT 14
96816: PUSH
96817: LD_INT 15
96819: PUSH
96820: LD_INT 16
96822: PUSH
96823: LD_INT 17
96825: PUSH
96826: LD_INT 18
96828: PUSH
96829: LD_INT 19
96831: PUSH
96832: LD_INT 20
96834: PUSH
96835: LD_INT 21
96837: PUSH
96838: LD_INT 22
96840: PUSH
96841: LD_INT 23
96843: PUSH
96844: LD_INT 24
96846: PUSH
96847: LD_INT 25
96849: PUSH
96850: LD_INT 26
96852: PUSH
96853: LD_INT 27
96855: PUSH
96856: LD_INT 28
96858: PUSH
96859: LD_INT 29
96861: PUSH
96862: LD_INT 30
96864: PUSH
96865: LD_INT 31
96867: PUSH
96868: LD_INT 32
96870: PUSH
96871: LD_INT 33
96873: PUSH
96874: LD_INT 34
96876: PUSH
96877: LD_INT 35
96879: PUSH
96880: LD_INT 36
96882: PUSH
96883: EMPTY
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: LIST
96920: PUSH
96921: LD_INT 101
96923: PUSH
96924: LD_INT 102
96926: PUSH
96927: LD_INT 103
96929: PUSH
96930: LD_INT 104
96932: PUSH
96933: LD_INT 105
96935: PUSH
96936: LD_INT 106
96938: PUSH
96939: LD_INT 107
96941: PUSH
96942: LD_INT 108
96944: PUSH
96945: LD_INT 109
96947: PUSH
96948: LD_INT 110
96950: PUSH
96951: LD_INT 111
96953: PUSH
96954: LD_INT 112
96956: PUSH
96957: LD_INT 113
96959: PUSH
96960: LD_INT 114
96962: PUSH
96963: LD_INT 115
96965: PUSH
96966: LD_INT 116
96968: PUSH
96969: LD_INT 117
96971: PUSH
96972: LD_INT 118
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: PUSH
96995: EMPTY
96996: LIST
96997: LIST
96998: ST_TO_ADDR
// if result then
96999: LD_VAR 0 2
97003: IFFALSE 97789
// begin normal :=  ;
97005: LD_ADDR_VAR 0 5
97009: PUSH
97010: LD_STRING 
97012: ST_TO_ADDR
// hardcore :=  ;
97013: LD_ADDR_VAR 0 6
97017: PUSH
97018: LD_STRING 
97020: ST_TO_ADDR
// active :=  ;
97021: LD_ADDR_VAR 0 7
97025: PUSH
97026: LD_STRING 
97028: ST_TO_ADDR
// for i = 1 to normalCounter do
97029: LD_ADDR_VAR 0 8
97033: PUSH
97034: DOUBLE
97035: LD_INT 1
97037: DEC
97038: ST_TO_ADDR
97039: LD_EXP 94
97043: PUSH
97044: FOR_TO
97045: IFFALSE 97146
// begin tmp := 0 ;
97047: LD_ADDR_VAR 0 3
97051: PUSH
97052: LD_STRING 0
97054: ST_TO_ADDR
// if result [ 1 ] then
97055: LD_VAR 0 2
97059: PUSH
97060: LD_INT 1
97062: ARRAY
97063: IFFALSE 97128
// if result [ 1 ] [ 1 ] = i then
97065: LD_VAR 0 2
97069: PUSH
97070: LD_INT 1
97072: ARRAY
97073: PUSH
97074: LD_INT 1
97076: ARRAY
97077: PUSH
97078: LD_VAR 0 8
97082: EQUAL
97083: IFFALSE 97128
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97085: LD_ADDR_VAR 0 2
97089: PUSH
97090: LD_VAR 0 2
97094: PPUSH
97095: LD_INT 1
97097: PPUSH
97098: LD_VAR 0 2
97102: PUSH
97103: LD_INT 1
97105: ARRAY
97106: PPUSH
97107: LD_INT 1
97109: PPUSH
97110: CALL_OW 3
97114: PPUSH
97115: CALL_OW 1
97119: ST_TO_ADDR
// tmp := 1 ;
97120: LD_ADDR_VAR 0 3
97124: PUSH
97125: LD_STRING 1
97127: ST_TO_ADDR
// end ; normal := normal & tmp ;
97128: LD_ADDR_VAR 0 5
97132: PUSH
97133: LD_VAR 0 5
97137: PUSH
97138: LD_VAR 0 3
97142: STR
97143: ST_TO_ADDR
// end ;
97144: GO 97044
97146: POP
97147: POP
// for i = 1 to hardcoreCounter do
97148: LD_ADDR_VAR 0 8
97152: PUSH
97153: DOUBLE
97154: LD_INT 1
97156: DEC
97157: ST_TO_ADDR
97158: LD_EXP 95
97162: PUSH
97163: FOR_TO
97164: IFFALSE 97269
// begin tmp := 0 ;
97166: LD_ADDR_VAR 0 3
97170: PUSH
97171: LD_STRING 0
97173: ST_TO_ADDR
// if result [ 2 ] then
97174: LD_VAR 0 2
97178: PUSH
97179: LD_INT 2
97181: ARRAY
97182: IFFALSE 97251
// if result [ 2 ] [ 1 ] = 100 + i then
97184: LD_VAR 0 2
97188: PUSH
97189: LD_INT 2
97191: ARRAY
97192: PUSH
97193: LD_INT 1
97195: ARRAY
97196: PUSH
97197: LD_INT 100
97199: PUSH
97200: LD_VAR 0 8
97204: PLUS
97205: EQUAL
97206: IFFALSE 97251
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97208: LD_ADDR_VAR 0 2
97212: PUSH
97213: LD_VAR 0 2
97217: PPUSH
97218: LD_INT 2
97220: PPUSH
97221: LD_VAR 0 2
97225: PUSH
97226: LD_INT 2
97228: ARRAY
97229: PPUSH
97230: LD_INT 1
97232: PPUSH
97233: CALL_OW 3
97237: PPUSH
97238: CALL_OW 1
97242: ST_TO_ADDR
// tmp := 1 ;
97243: LD_ADDR_VAR 0 3
97247: PUSH
97248: LD_STRING 1
97250: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97251: LD_ADDR_VAR 0 6
97255: PUSH
97256: LD_VAR 0 6
97260: PUSH
97261: LD_VAR 0 3
97265: STR
97266: ST_TO_ADDR
// end ;
97267: GO 97163
97269: POP
97270: POP
// if isGameLoad then
97271: LD_VAR 0 1
97275: IFFALSE 97750
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97277: LD_ADDR_VAR 0 4
97281: PUSH
97282: LD_EXP 98
97286: PUSH
97287: LD_EXP 97
97291: PUSH
97292: LD_EXP 99
97296: PUSH
97297: LD_EXP 96
97301: PUSH
97302: LD_EXP 100
97306: PUSH
97307: LD_EXP 101
97311: PUSH
97312: LD_EXP 102
97316: PUSH
97317: LD_EXP 103
97321: PUSH
97322: LD_EXP 104
97326: PUSH
97327: LD_EXP 105
97331: PUSH
97332: LD_EXP 106
97336: PUSH
97337: LD_EXP 107
97341: PUSH
97342: LD_EXP 108
97346: PUSH
97347: LD_EXP 109
97351: PUSH
97352: LD_EXP 117
97356: PUSH
97357: LD_EXP 118
97361: PUSH
97362: LD_EXP 119
97366: PUSH
97367: LD_EXP 120
97371: PUSH
97372: LD_EXP 122
97376: PUSH
97377: LD_EXP 123
97381: PUSH
97382: LD_EXP 124
97386: PUSH
97387: LD_EXP 127
97391: PUSH
97392: LD_EXP 129
97396: PUSH
97397: LD_EXP 130
97401: PUSH
97402: LD_EXP 131
97406: PUSH
97407: LD_EXP 133
97411: PUSH
97412: LD_EXP 134
97416: PUSH
97417: LD_EXP 137
97421: PUSH
97422: LD_EXP 138
97426: PUSH
97427: LD_EXP 139
97431: PUSH
97432: LD_EXP 140
97436: PUSH
97437: LD_EXP 141
97441: PUSH
97442: LD_EXP 142
97446: PUSH
97447: LD_EXP 143
97451: PUSH
97452: LD_EXP 144
97456: PUSH
97457: LD_EXP 145
97461: PUSH
97462: LD_EXP 110
97466: PUSH
97467: LD_EXP 111
97471: PUSH
97472: LD_EXP 114
97476: PUSH
97477: LD_EXP 115
97481: PUSH
97482: LD_EXP 116
97486: PUSH
97487: LD_EXP 112
97491: PUSH
97492: LD_EXP 113
97496: PUSH
97497: LD_EXP 121
97501: PUSH
97502: LD_EXP 125
97506: PUSH
97507: LD_EXP 126
97511: PUSH
97512: LD_EXP 128
97516: PUSH
97517: LD_EXP 132
97521: PUSH
97522: LD_EXP 135
97526: PUSH
97527: LD_EXP 136
97531: PUSH
97532: LD_EXP 146
97536: PUSH
97537: LD_EXP 147
97541: PUSH
97542: LD_EXP 148
97546: PUSH
97547: LD_EXP 149
97551: PUSH
97552: EMPTY
97553: LIST
97554: LIST
97555: LIST
97556: LIST
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: LIST
97594: LIST
97595: LIST
97596: LIST
97597: LIST
97598: LIST
97599: LIST
97600: LIST
97601: LIST
97602: LIST
97603: LIST
97604: LIST
97605: LIST
97606: LIST
97607: ST_TO_ADDR
// tmp :=  ;
97608: LD_ADDR_VAR 0 3
97612: PUSH
97613: LD_STRING 
97615: ST_TO_ADDR
// for i = 1 to normalCounter do
97616: LD_ADDR_VAR 0 8
97620: PUSH
97621: DOUBLE
97622: LD_INT 1
97624: DEC
97625: ST_TO_ADDR
97626: LD_EXP 94
97630: PUSH
97631: FOR_TO
97632: IFFALSE 97668
// begin if flags [ i ] then
97634: LD_VAR 0 4
97638: PUSH
97639: LD_VAR 0 8
97643: ARRAY
97644: IFFALSE 97666
// tmp := tmp & i & ; ;
97646: LD_ADDR_VAR 0 3
97650: PUSH
97651: LD_VAR 0 3
97655: PUSH
97656: LD_VAR 0 8
97660: STR
97661: PUSH
97662: LD_STRING ;
97664: STR
97665: ST_TO_ADDR
// end ;
97666: GO 97631
97668: POP
97669: POP
// for i = 1 to hardcoreCounter do
97670: LD_ADDR_VAR 0 8
97674: PUSH
97675: DOUBLE
97676: LD_INT 1
97678: DEC
97679: ST_TO_ADDR
97680: LD_EXP 95
97684: PUSH
97685: FOR_TO
97686: IFFALSE 97732
// begin if flags [ normalCounter + i ] then
97688: LD_VAR 0 4
97692: PUSH
97693: LD_EXP 94
97697: PUSH
97698: LD_VAR 0 8
97702: PLUS
97703: ARRAY
97704: IFFALSE 97730
// tmp := tmp & ( 100 + i ) & ; ;
97706: LD_ADDR_VAR 0 3
97710: PUSH
97711: LD_VAR 0 3
97715: PUSH
97716: LD_INT 100
97718: PUSH
97719: LD_VAR 0 8
97723: PLUS
97724: STR
97725: PUSH
97726: LD_STRING ;
97728: STR
97729: ST_TO_ADDR
// end ;
97730: GO 97685
97732: POP
97733: POP
// if tmp then
97734: LD_VAR 0 3
97738: IFFALSE 97750
// active := tmp ;
97740: LD_ADDR_VAR 0 7
97744: PUSH
97745: LD_VAR 0 3
97749: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97750: LD_STRING getStreamItemsFromMission("
97752: PUSH
97753: LD_VAR 0 5
97757: STR
97758: PUSH
97759: LD_STRING ","
97761: STR
97762: PUSH
97763: LD_VAR 0 6
97767: STR
97768: PUSH
97769: LD_STRING ","
97771: STR
97772: PUSH
97773: LD_VAR 0 7
97777: STR
97778: PUSH
97779: LD_STRING ")
97781: STR
97782: PPUSH
97783: CALL_OW 559
// end else
97787: GO 97796
// ToLua ( getStreamItemsFromMission("","","") ) ;
97789: LD_STRING getStreamItemsFromMission("","","")
97791: PPUSH
97792: CALL_OW 559
// end ;
97796: LD_VAR 0 2
97800: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97801: LD_EXP 93
97805: PUSH
97806: LD_EXP 98
97810: AND
97811: IFFALSE 97935
97813: GO 97815
97815: DISABLE
97816: LD_INT 0
97818: PPUSH
97819: PPUSH
// begin enable ;
97820: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97821: LD_ADDR_VAR 0 2
97825: PUSH
97826: LD_INT 22
97828: PUSH
97829: LD_OWVAR 2
97833: PUSH
97834: EMPTY
97835: LIST
97836: LIST
97837: PUSH
97838: LD_INT 2
97840: PUSH
97841: LD_INT 34
97843: PUSH
97844: LD_INT 7
97846: PUSH
97847: EMPTY
97848: LIST
97849: LIST
97850: PUSH
97851: LD_INT 34
97853: PUSH
97854: LD_INT 45
97856: PUSH
97857: EMPTY
97858: LIST
97859: LIST
97860: PUSH
97861: LD_INT 34
97863: PUSH
97864: LD_INT 28
97866: PUSH
97867: EMPTY
97868: LIST
97869: LIST
97870: PUSH
97871: LD_INT 34
97873: PUSH
97874: LD_INT 47
97876: PUSH
97877: EMPTY
97878: LIST
97879: LIST
97880: PUSH
97881: EMPTY
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: PUSH
97888: EMPTY
97889: LIST
97890: LIST
97891: PPUSH
97892: CALL_OW 69
97896: ST_TO_ADDR
// if not tmp then
97897: LD_VAR 0 2
97901: NOT
97902: IFFALSE 97906
// exit ;
97904: GO 97935
// for i in tmp do
97906: LD_ADDR_VAR 0 1
97910: PUSH
97911: LD_VAR 0 2
97915: PUSH
97916: FOR_IN
97917: IFFALSE 97933
// begin SetLives ( i , 0 ) ;
97919: LD_VAR 0 1
97923: PPUSH
97924: LD_INT 0
97926: PPUSH
97927: CALL_OW 234
// end ;
97931: GO 97916
97933: POP
97934: POP
// end ;
97935: PPOPN 2
97937: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97938: LD_EXP 93
97942: PUSH
97943: LD_EXP 99
97947: AND
97948: IFFALSE 98032
97950: GO 97952
97952: DISABLE
97953: LD_INT 0
97955: PPUSH
97956: PPUSH
// begin enable ;
97957: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97958: LD_ADDR_VAR 0 2
97962: PUSH
97963: LD_INT 22
97965: PUSH
97966: LD_OWVAR 2
97970: PUSH
97971: EMPTY
97972: LIST
97973: LIST
97974: PUSH
97975: LD_INT 32
97977: PUSH
97978: LD_INT 3
97980: PUSH
97981: EMPTY
97982: LIST
97983: LIST
97984: PUSH
97985: EMPTY
97986: LIST
97987: LIST
97988: PPUSH
97989: CALL_OW 69
97993: ST_TO_ADDR
// if not tmp then
97994: LD_VAR 0 2
97998: NOT
97999: IFFALSE 98003
// exit ;
98001: GO 98032
// for i in tmp do
98003: LD_ADDR_VAR 0 1
98007: PUSH
98008: LD_VAR 0 2
98012: PUSH
98013: FOR_IN
98014: IFFALSE 98030
// begin SetLives ( i , 0 ) ;
98016: LD_VAR 0 1
98020: PPUSH
98021: LD_INT 0
98023: PPUSH
98024: CALL_OW 234
// end ;
98028: GO 98013
98030: POP
98031: POP
// end ;
98032: PPOPN 2
98034: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98035: LD_EXP 93
98039: PUSH
98040: LD_EXP 96
98044: AND
98045: IFFALSE 98138
98047: GO 98049
98049: DISABLE
98050: LD_INT 0
98052: PPUSH
// begin enable ;
98053: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98054: LD_ADDR_VAR 0 1
98058: PUSH
98059: LD_INT 22
98061: PUSH
98062: LD_OWVAR 2
98066: PUSH
98067: EMPTY
98068: LIST
98069: LIST
98070: PUSH
98071: LD_INT 2
98073: PUSH
98074: LD_INT 25
98076: PUSH
98077: LD_INT 5
98079: PUSH
98080: EMPTY
98081: LIST
98082: LIST
98083: PUSH
98084: LD_INT 25
98086: PUSH
98087: LD_INT 9
98089: PUSH
98090: EMPTY
98091: LIST
98092: LIST
98093: PUSH
98094: LD_INT 25
98096: PUSH
98097: LD_INT 8
98099: PUSH
98100: EMPTY
98101: LIST
98102: LIST
98103: PUSH
98104: EMPTY
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: PUSH
98110: EMPTY
98111: LIST
98112: LIST
98113: PPUSH
98114: CALL_OW 69
98118: PUSH
98119: FOR_IN
98120: IFFALSE 98136
// begin SetClass ( i , 1 ) ;
98122: LD_VAR 0 1
98126: PPUSH
98127: LD_INT 1
98129: PPUSH
98130: CALL_OW 336
// end ;
98134: GO 98119
98136: POP
98137: POP
// end ;
98138: PPOPN 1
98140: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98141: LD_EXP 93
98145: PUSH
98146: LD_EXP 97
98150: AND
98151: PUSH
98152: LD_OWVAR 65
98156: PUSH
98157: LD_INT 7
98159: LESS
98160: AND
98161: IFFALSE 98175
98163: GO 98165
98165: DISABLE
// begin enable ;
98166: ENABLE
// game_speed := 7 ;
98167: LD_ADDR_OWVAR 65
98171: PUSH
98172: LD_INT 7
98174: ST_TO_ADDR
// end ;
98175: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98176: LD_EXP 93
98180: PUSH
98181: LD_EXP 100
98185: AND
98186: IFFALSE 98388
98188: GO 98190
98190: DISABLE
98191: LD_INT 0
98193: PPUSH
98194: PPUSH
98195: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98196: LD_ADDR_VAR 0 3
98200: PUSH
98201: LD_INT 81
98203: PUSH
98204: LD_OWVAR 2
98208: PUSH
98209: EMPTY
98210: LIST
98211: LIST
98212: PUSH
98213: LD_INT 21
98215: PUSH
98216: LD_INT 1
98218: PUSH
98219: EMPTY
98220: LIST
98221: LIST
98222: PUSH
98223: EMPTY
98224: LIST
98225: LIST
98226: PPUSH
98227: CALL_OW 69
98231: ST_TO_ADDR
// if not tmp then
98232: LD_VAR 0 3
98236: NOT
98237: IFFALSE 98241
// exit ;
98239: GO 98388
// if tmp > 5 then
98241: LD_VAR 0 3
98245: PUSH
98246: LD_INT 5
98248: GREATER
98249: IFFALSE 98261
// k := 5 else
98251: LD_ADDR_VAR 0 2
98255: PUSH
98256: LD_INT 5
98258: ST_TO_ADDR
98259: GO 98271
// k := tmp ;
98261: LD_ADDR_VAR 0 2
98265: PUSH
98266: LD_VAR 0 3
98270: ST_TO_ADDR
// for i := 1 to k do
98271: LD_ADDR_VAR 0 1
98275: PUSH
98276: DOUBLE
98277: LD_INT 1
98279: DEC
98280: ST_TO_ADDR
98281: LD_VAR 0 2
98285: PUSH
98286: FOR_TO
98287: IFFALSE 98386
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98289: LD_VAR 0 3
98293: PUSH
98294: LD_VAR 0 1
98298: ARRAY
98299: PPUSH
98300: LD_VAR 0 1
98304: PUSH
98305: LD_INT 4
98307: MOD
98308: PUSH
98309: LD_INT 1
98311: PLUS
98312: PPUSH
98313: CALL_OW 259
98317: PUSH
98318: LD_INT 10
98320: LESS
98321: IFFALSE 98384
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98323: LD_VAR 0 3
98327: PUSH
98328: LD_VAR 0 1
98332: ARRAY
98333: PPUSH
98334: LD_VAR 0 1
98338: PUSH
98339: LD_INT 4
98341: MOD
98342: PUSH
98343: LD_INT 1
98345: PLUS
98346: PPUSH
98347: LD_VAR 0 3
98351: PUSH
98352: LD_VAR 0 1
98356: ARRAY
98357: PPUSH
98358: LD_VAR 0 1
98362: PUSH
98363: LD_INT 4
98365: MOD
98366: PUSH
98367: LD_INT 1
98369: PLUS
98370: PPUSH
98371: CALL_OW 259
98375: PUSH
98376: LD_INT 1
98378: PLUS
98379: PPUSH
98380: CALL_OW 237
98384: GO 98286
98386: POP
98387: POP
// end ;
98388: PPOPN 3
98390: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98391: LD_EXP 93
98395: PUSH
98396: LD_EXP 101
98400: AND
98401: IFFALSE 98421
98403: GO 98405
98405: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98406: LD_INT 4
98408: PPUSH
98409: LD_OWVAR 2
98413: PPUSH
98414: LD_INT 0
98416: PPUSH
98417: CALL_OW 324
98421: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98422: LD_EXP 93
98426: PUSH
98427: LD_EXP 130
98431: AND
98432: IFFALSE 98452
98434: GO 98436
98436: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98437: LD_INT 19
98439: PPUSH
98440: LD_OWVAR 2
98444: PPUSH
98445: LD_INT 0
98447: PPUSH
98448: CALL_OW 324
98452: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98453: LD_EXP 93
98457: PUSH
98458: LD_EXP 102
98462: AND
98463: IFFALSE 98565
98465: GO 98467
98467: DISABLE
98468: LD_INT 0
98470: PPUSH
98471: PPUSH
// begin enable ;
98472: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98473: LD_ADDR_VAR 0 2
98477: PUSH
98478: LD_INT 22
98480: PUSH
98481: LD_OWVAR 2
98485: PUSH
98486: EMPTY
98487: LIST
98488: LIST
98489: PUSH
98490: LD_INT 2
98492: PUSH
98493: LD_INT 34
98495: PUSH
98496: LD_INT 11
98498: PUSH
98499: EMPTY
98500: LIST
98501: LIST
98502: PUSH
98503: LD_INT 34
98505: PUSH
98506: LD_INT 30
98508: PUSH
98509: EMPTY
98510: LIST
98511: LIST
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: LIST
98517: PUSH
98518: EMPTY
98519: LIST
98520: LIST
98521: PPUSH
98522: CALL_OW 69
98526: ST_TO_ADDR
// if not tmp then
98527: LD_VAR 0 2
98531: NOT
98532: IFFALSE 98536
// exit ;
98534: GO 98565
// for i in tmp do
98536: LD_ADDR_VAR 0 1
98540: PUSH
98541: LD_VAR 0 2
98545: PUSH
98546: FOR_IN
98547: IFFALSE 98563
// begin SetLives ( i , 0 ) ;
98549: LD_VAR 0 1
98553: PPUSH
98554: LD_INT 0
98556: PPUSH
98557: CALL_OW 234
// end ;
98561: GO 98546
98563: POP
98564: POP
// end ;
98565: PPOPN 2
98567: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98568: LD_EXP 93
98572: PUSH
98573: LD_EXP 103
98577: AND
98578: IFFALSE 98598
98580: GO 98582
98582: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98583: LD_INT 32
98585: PPUSH
98586: LD_OWVAR 2
98590: PPUSH
98591: LD_INT 0
98593: PPUSH
98594: CALL_OW 324
98598: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98599: LD_EXP 93
98603: PUSH
98604: LD_EXP 104
98608: AND
98609: IFFALSE 98790
98611: GO 98613
98613: DISABLE
98614: LD_INT 0
98616: PPUSH
98617: PPUSH
98618: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98619: LD_ADDR_VAR 0 2
98623: PUSH
98624: LD_INT 22
98626: PUSH
98627: LD_OWVAR 2
98631: PUSH
98632: EMPTY
98633: LIST
98634: LIST
98635: PUSH
98636: LD_INT 33
98638: PUSH
98639: LD_INT 3
98641: PUSH
98642: EMPTY
98643: LIST
98644: LIST
98645: PUSH
98646: EMPTY
98647: LIST
98648: LIST
98649: PPUSH
98650: CALL_OW 69
98654: ST_TO_ADDR
// if not tmp then
98655: LD_VAR 0 2
98659: NOT
98660: IFFALSE 98664
// exit ;
98662: GO 98790
// side := 0 ;
98664: LD_ADDR_VAR 0 3
98668: PUSH
98669: LD_INT 0
98671: ST_TO_ADDR
// for i := 1 to 8 do
98672: LD_ADDR_VAR 0 1
98676: PUSH
98677: DOUBLE
98678: LD_INT 1
98680: DEC
98681: ST_TO_ADDR
98682: LD_INT 8
98684: PUSH
98685: FOR_TO
98686: IFFALSE 98734
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98688: LD_OWVAR 2
98692: PUSH
98693: LD_VAR 0 1
98697: NONEQUAL
98698: PUSH
98699: LD_OWVAR 2
98703: PPUSH
98704: LD_VAR 0 1
98708: PPUSH
98709: CALL_OW 81
98713: PUSH
98714: LD_INT 2
98716: EQUAL
98717: AND
98718: IFFALSE 98732
// begin side := i ;
98720: LD_ADDR_VAR 0 3
98724: PUSH
98725: LD_VAR 0 1
98729: ST_TO_ADDR
// break ;
98730: GO 98734
// end ;
98732: GO 98685
98734: POP
98735: POP
// if not side then
98736: LD_VAR 0 3
98740: NOT
98741: IFFALSE 98745
// exit ;
98743: GO 98790
// for i := 1 to tmp do
98745: LD_ADDR_VAR 0 1
98749: PUSH
98750: DOUBLE
98751: LD_INT 1
98753: DEC
98754: ST_TO_ADDR
98755: LD_VAR 0 2
98759: PUSH
98760: FOR_TO
98761: IFFALSE 98788
// if Prob ( 60 ) then
98763: LD_INT 60
98765: PPUSH
98766: CALL_OW 13
98770: IFFALSE 98786
// SetSide ( i , side ) ;
98772: LD_VAR 0 1
98776: PPUSH
98777: LD_VAR 0 3
98781: PPUSH
98782: CALL_OW 235
98786: GO 98760
98788: POP
98789: POP
// end ;
98790: PPOPN 3
98792: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98793: LD_EXP 93
98797: PUSH
98798: LD_EXP 106
98802: AND
98803: IFFALSE 98922
98805: GO 98807
98807: DISABLE
98808: LD_INT 0
98810: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98811: LD_ADDR_VAR 0 1
98815: PUSH
98816: LD_INT 22
98818: PUSH
98819: LD_OWVAR 2
98823: PUSH
98824: EMPTY
98825: LIST
98826: LIST
98827: PUSH
98828: LD_INT 21
98830: PUSH
98831: LD_INT 1
98833: PUSH
98834: EMPTY
98835: LIST
98836: LIST
98837: PUSH
98838: LD_INT 3
98840: PUSH
98841: LD_INT 23
98843: PUSH
98844: LD_INT 0
98846: PUSH
98847: EMPTY
98848: LIST
98849: LIST
98850: PUSH
98851: EMPTY
98852: LIST
98853: LIST
98854: PUSH
98855: EMPTY
98856: LIST
98857: LIST
98858: LIST
98859: PPUSH
98860: CALL_OW 69
98864: PUSH
98865: FOR_IN
98866: IFFALSE 98920
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98868: LD_VAR 0 1
98872: PPUSH
98873: CALL_OW 257
98877: PUSH
98878: LD_INT 1
98880: PUSH
98881: LD_INT 2
98883: PUSH
98884: LD_INT 3
98886: PUSH
98887: LD_INT 4
98889: PUSH
98890: EMPTY
98891: LIST
98892: LIST
98893: LIST
98894: LIST
98895: IN
98896: IFFALSE 98918
// SetClass ( un , rand ( 1 , 4 ) ) ;
98898: LD_VAR 0 1
98902: PPUSH
98903: LD_INT 1
98905: PPUSH
98906: LD_INT 4
98908: PPUSH
98909: CALL_OW 12
98913: PPUSH
98914: CALL_OW 336
98918: GO 98865
98920: POP
98921: POP
// end ;
98922: PPOPN 1
98924: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98925: LD_EXP 93
98929: PUSH
98930: LD_EXP 105
98934: AND
98935: IFFALSE 99014
98937: GO 98939
98939: DISABLE
98940: LD_INT 0
98942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98943: LD_ADDR_VAR 0 1
98947: PUSH
98948: LD_INT 22
98950: PUSH
98951: LD_OWVAR 2
98955: PUSH
98956: EMPTY
98957: LIST
98958: LIST
98959: PUSH
98960: LD_INT 21
98962: PUSH
98963: LD_INT 3
98965: PUSH
98966: EMPTY
98967: LIST
98968: LIST
98969: PUSH
98970: EMPTY
98971: LIST
98972: LIST
98973: PPUSH
98974: CALL_OW 69
98978: ST_TO_ADDR
// if not tmp then
98979: LD_VAR 0 1
98983: NOT
98984: IFFALSE 98988
// exit ;
98986: GO 99014
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98988: LD_VAR 0 1
98992: PUSH
98993: LD_INT 1
98995: PPUSH
98996: LD_VAR 0 1
99000: PPUSH
99001: CALL_OW 12
99005: ARRAY
99006: PPUSH
99007: LD_INT 100
99009: PPUSH
99010: CALL_OW 234
// end ;
99014: PPOPN 1
99016: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99017: LD_EXP 93
99021: PUSH
99022: LD_EXP 107
99026: AND
99027: IFFALSE 99125
99029: GO 99031
99031: DISABLE
99032: LD_INT 0
99034: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99035: LD_ADDR_VAR 0 1
99039: PUSH
99040: LD_INT 22
99042: PUSH
99043: LD_OWVAR 2
99047: PUSH
99048: EMPTY
99049: LIST
99050: LIST
99051: PUSH
99052: LD_INT 21
99054: PUSH
99055: LD_INT 1
99057: PUSH
99058: EMPTY
99059: LIST
99060: LIST
99061: PUSH
99062: EMPTY
99063: LIST
99064: LIST
99065: PPUSH
99066: CALL_OW 69
99070: ST_TO_ADDR
// if not tmp then
99071: LD_VAR 0 1
99075: NOT
99076: IFFALSE 99080
// exit ;
99078: GO 99125
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99080: LD_VAR 0 1
99084: PUSH
99085: LD_INT 1
99087: PPUSH
99088: LD_VAR 0 1
99092: PPUSH
99093: CALL_OW 12
99097: ARRAY
99098: PPUSH
99099: LD_INT 1
99101: PPUSH
99102: LD_INT 4
99104: PPUSH
99105: CALL_OW 12
99109: PPUSH
99110: LD_INT 3000
99112: PPUSH
99113: LD_INT 9000
99115: PPUSH
99116: CALL_OW 12
99120: PPUSH
99121: CALL_OW 492
// end ;
99125: PPOPN 1
99127: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99128: LD_EXP 93
99132: PUSH
99133: LD_EXP 108
99137: AND
99138: IFFALSE 99158
99140: GO 99142
99142: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99143: LD_INT 1
99145: PPUSH
99146: LD_OWVAR 2
99150: PPUSH
99151: LD_INT 0
99153: PPUSH
99154: CALL_OW 324
99158: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99159: LD_EXP 93
99163: PUSH
99164: LD_EXP 109
99168: AND
99169: IFFALSE 99252
99171: GO 99173
99173: DISABLE
99174: LD_INT 0
99176: PPUSH
99177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99178: LD_ADDR_VAR 0 2
99182: PUSH
99183: LD_INT 22
99185: PUSH
99186: LD_OWVAR 2
99190: PUSH
99191: EMPTY
99192: LIST
99193: LIST
99194: PUSH
99195: LD_INT 21
99197: PUSH
99198: LD_INT 3
99200: PUSH
99201: EMPTY
99202: LIST
99203: LIST
99204: PUSH
99205: EMPTY
99206: LIST
99207: LIST
99208: PPUSH
99209: CALL_OW 69
99213: ST_TO_ADDR
// if not tmp then
99214: LD_VAR 0 2
99218: NOT
99219: IFFALSE 99223
// exit ;
99221: GO 99252
// for i in tmp do
99223: LD_ADDR_VAR 0 1
99227: PUSH
99228: LD_VAR 0 2
99232: PUSH
99233: FOR_IN
99234: IFFALSE 99250
// SetBLevel ( i , 10 ) ;
99236: LD_VAR 0 1
99240: PPUSH
99241: LD_INT 10
99243: PPUSH
99244: CALL_OW 241
99248: GO 99233
99250: POP
99251: POP
// end ;
99252: PPOPN 2
99254: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99255: LD_EXP 93
99259: PUSH
99260: LD_EXP 110
99264: AND
99265: IFFALSE 99376
99267: GO 99269
99269: DISABLE
99270: LD_INT 0
99272: PPUSH
99273: PPUSH
99274: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99275: LD_ADDR_VAR 0 3
99279: PUSH
99280: LD_INT 22
99282: PUSH
99283: LD_OWVAR 2
99287: PUSH
99288: EMPTY
99289: LIST
99290: LIST
99291: PUSH
99292: LD_INT 25
99294: PUSH
99295: LD_INT 1
99297: PUSH
99298: EMPTY
99299: LIST
99300: LIST
99301: PUSH
99302: EMPTY
99303: LIST
99304: LIST
99305: PPUSH
99306: CALL_OW 69
99310: ST_TO_ADDR
// if not tmp then
99311: LD_VAR 0 3
99315: NOT
99316: IFFALSE 99320
// exit ;
99318: GO 99376
// un := tmp [ rand ( 1 , tmp ) ] ;
99320: LD_ADDR_VAR 0 2
99324: PUSH
99325: LD_VAR 0 3
99329: PUSH
99330: LD_INT 1
99332: PPUSH
99333: LD_VAR 0 3
99337: PPUSH
99338: CALL_OW 12
99342: ARRAY
99343: ST_TO_ADDR
// if Crawls ( un ) then
99344: LD_VAR 0 2
99348: PPUSH
99349: CALL_OW 318
99353: IFFALSE 99364
// ComWalk ( un ) ;
99355: LD_VAR 0 2
99359: PPUSH
99360: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99364: LD_VAR 0 2
99368: PPUSH
99369: LD_INT 5
99371: PPUSH
99372: CALL_OW 336
// end ;
99376: PPOPN 3
99378: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99379: LD_EXP 93
99383: PUSH
99384: LD_EXP 111
99388: AND
99389: PUSH
99390: LD_OWVAR 67
99394: PUSH
99395: LD_INT 4
99397: LESS
99398: AND
99399: IFFALSE 99418
99401: GO 99403
99403: DISABLE
// begin Difficulty := Difficulty + 1 ;
99404: LD_ADDR_OWVAR 67
99408: PUSH
99409: LD_OWVAR 67
99413: PUSH
99414: LD_INT 1
99416: PLUS
99417: ST_TO_ADDR
// end ;
99418: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99419: LD_EXP 93
99423: PUSH
99424: LD_EXP 112
99428: AND
99429: IFFALSE 99532
99431: GO 99433
99433: DISABLE
99434: LD_INT 0
99436: PPUSH
// begin for i := 1 to 5 do
99437: LD_ADDR_VAR 0 1
99441: PUSH
99442: DOUBLE
99443: LD_INT 1
99445: DEC
99446: ST_TO_ADDR
99447: LD_INT 5
99449: PUSH
99450: FOR_TO
99451: IFFALSE 99530
// begin uc_nation := nation_nature ;
99453: LD_ADDR_OWVAR 21
99457: PUSH
99458: LD_INT 0
99460: ST_TO_ADDR
// uc_side := 0 ;
99461: LD_ADDR_OWVAR 20
99465: PUSH
99466: LD_INT 0
99468: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99469: LD_ADDR_OWVAR 29
99473: PUSH
99474: LD_INT 12
99476: PUSH
99477: LD_INT 12
99479: PUSH
99480: EMPTY
99481: LIST
99482: LIST
99483: ST_TO_ADDR
// hc_agressivity := 20 ;
99484: LD_ADDR_OWVAR 35
99488: PUSH
99489: LD_INT 20
99491: ST_TO_ADDR
// hc_class := class_tiger ;
99492: LD_ADDR_OWVAR 28
99496: PUSH
99497: LD_INT 14
99499: ST_TO_ADDR
// hc_gallery :=  ;
99500: LD_ADDR_OWVAR 33
99504: PUSH
99505: LD_STRING 
99507: ST_TO_ADDR
// hc_name :=  ;
99508: LD_ADDR_OWVAR 26
99512: PUSH
99513: LD_STRING 
99515: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99516: CALL_OW 44
99520: PPUSH
99521: LD_INT 0
99523: PPUSH
99524: CALL_OW 51
// end ;
99528: GO 99450
99530: POP
99531: POP
// end ;
99532: PPOPN 1
99534: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99535: LD_EXP 93
99539: PUSH
99540: LD_EXP 113
99544: AND
99545: IFFALSE 99554
99547: GO 99549
99549: DISABLE
// StreamSibBomb ;
99550: CALL 99555 0 0
99554: END
// export function StreamSibBomb ; var i , x , y ; begin
99555: LD_INT 0
99557: PPUSH
99558: PPUSH
99559: PPUSH
99560: PPUSH
// result := false ;
99561: LD_ADDR_VAR 0 1
99565: PUSH
99566: LD_INT 0
99568: ST_TO_ADDR
// for i := 1 to 16 do
99569: LD_ADDR_VAR 0 2
99573: PUSH
99574: DOUBLE
99575: LD_INT 1
99577: DEC
99578: ST_TO_ADDR
99579: LD_INT 16
99581: PUSH
99582: FOR_TO
99583: IFFALSE 99782
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99585: LD_ADDR_VAR 0 3
99589: PUSH
99590: LD_INT 10
99592: PUSH
99593: LD_INT 20
99595: PUSH
99596: LD_INT 30
99598: PUSH
99599: LD_INT 40
99601: PUSH
99602: LD_INT 50
99604: PUSH
99605: LD_INT 60
99607: PUSH
99608: LD_INT 70
99610: PUSH
99611: LD_INT 80
99613: PUSH
99614: LD_INT 90
99616: PUSH
99617: LD_INT 100
99619: PUSH
99620: LD_INT 110
99622: PUSH
99623: LD_INT 120
99625: PUSH
99626: LD_INT 130
99628: PUSH
99629: LD_INT 140
99631: PUSH
99632: LD_INT 150
99634: PUSH
99635: EMPTY
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: PUSH
99652: LD_INT 1
99654: PPUSH
99655: LD_INT 15
99657: PPUSH
99658: CALL_OW 12
99662: ARRAY
99663: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99664: LD_ADDR_VAR 0 4
99668: PUSH
99669: LD_INT 10
99671: PUSH
99672: LD_INT 20
99674: PUSH
99675: LD_INT 30
99677: PUSH
99678: LD_INT 40
99680: PUSH
99681: LD_INT 50
99683: PUSH
99684: LD_INT 60
99686: PUSH
99687: LD_INT 70
99689: PUSH
99690: LD_INT 80
99692: PUSH
99693: LD_INT 90
99695: PUSH
99696: LD_INT 100
99698: PUSH
99699: LD_INT 110
99701: PUSH
99702: LD_INT 120
99704: PUSH
99705: LD_INT 130
99707: PUSH
99708: LD_INT 140
99710: PUSH
99711: LD_INT 150
99713: PUSH
99714: EMPTY
99715: LIST
99716: LIST
99717: LIST
99718: LIST
99719: LIST
99720: LIST
99721: LIST
99722: LIST
99723: LIST
99724: LIST
99725: LIST
99726: LIST
99727: LIST
99728: LIST
99729: LIST
99730: PUSH
99731: LD_INT 1
99733: PPUSH
99734: LD_INT 15
99736: PPUSH
99737: CALL_OW 12
99741: ARRAY
99742: ST_TO_ADDR
// if ValidHex ( x , y ) then
99743: LD_VAR 0 3
99747: PPUSH
99748: LD_VAR 0 4
99752: PPUSH
99753: CALL_OW 488
99757: IFFALSE 99780
// begin result := [ x , y ] ;
99759: LD_ADDR_VAR 0 1
99763: PUSH
99764: LD_VAR 0 3
99768: PUSH
99769: LD_VAR 0 4
99773: PUSH
99774: EMPTY
99775: LIST
99776: LIST
99777: ST_TO_ADDR
// break ;
99778: GO 99782
// end ; end ;
99780: GO 99582
99782: POP
99783: POP
// if result then
99784: LD_VAR 0 1
99788: IFFALSE 99848
// begin ToLua ( playSibBomb() ) ;
99790: LD_STRING playSibBomb()
99792: PPUSH
99793: CALL_OW 559
// wait ( 0 0$14 ) ;
99797: LD_INT 490
99799: PPUSH
99800: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99804: LD_VAR 0 1
99808: PUSH
99809: LD_INT 1
99811: ARRAY
99812: PPUSH
99813: LD_VAR 0 1
99817: PUSH
99818: LD_INT 2
99820: ARRAY
99821: PPUSH
99822: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
99826: LD_VAR 0 1
99830: PUSH
99831: LD_INT 1
99833: ARRAY
99834: PPUSH
99835: LD_VAR 0 1
99839: PUSH
99840: LD_INT 2
99842: ARRAY
99843: PPUSH
99844: CALL_OW 429
// end ; end ;
99848: LD_VAR 0 1
99852: RET
// every 0 0$1 trigger StreamModeActive and sReset do
99853: LD_EXP 93
99857: PUSH
99858: LD_EXP 115
99862: AND
99863: IFFALSE 99875
99865: GO 99867
99867: DISABLE
// YouLost (  ) ;
99868: LD_STRING 
99870: PPUSH
99871: CALL_OW 104
99875: END
// every 0 0$1 trigger StreamModeActive and sFog do
99876: LD_EXP 93
99880: PUSH
99881: LD_EXP 114
99885: AND
99886: IFFALSE 99900
99888: GO 99890
99890: DISABLE
// FogOff ( your_side ) ;
99891: LD_OWVAR 2
99895: PPUSH
99896: CALL_OW 344
99900: END
// every 0 0$1 trigger StreamModeActive and sSun do
99901: LD_EXP 93
99905: PUSH
99906: LD_EXP 116
99910: AND
99911: IFFALSE 99939
99913: GO 99915
99915: DISABLE
// begin solar_recharge_percent := 0 ;
99916: LD_ADDR_OWVAR 79
99920: PUSH
99921: LD_INT 0
99923: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99924: LD_INT 10500
99926: PPUSH
99927: CALL_OW 67
// solar_recharge_percent := 100 ;
99931: LD_ADDR_OWVAR 79
99935: PUSH
99936: LD_INT 100
99938: ST_TO_ADDR
// end ;
99939: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99940: LD_EXP 93
99944: PUSH
99945: LD_EXP 117
99949: AND
99950: IFFALSE 100189
99952: GO 99954
99954: DISABLE
99955: LD_INT 0
99957: PPUSH
99958: PPUSH
99959: PPUSH
// begin tmp := [ ] ;
99960: LD_ADDR_VAR 0 3
99964: PUSH
99965: EMPTY
99966: ST_TO_ADDR
// for i := 1 to 6 do
99967: LD_ADDR_VAR 0 1
99971: PUSH
99972: DOUBLE
99973: LD_INT 1
99975: DEC
99976: ST_TO_ADDR
99977: LD_INT 6
99979: PUSH
99980: FOR_TO
99981: IFFALSE 100086
// begin uc_nation := nation_nature ;
99983: LD_ADDR_OWVAR 21
99987: PUSH
99988: LD_INT 0
99990: ST_TO_ADDR
// uc_side := 0 ;
99991: LD_ADDR_OWVAR 20
99995: PUSH
99996: LD_INT 0
99998: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99999: LD_ADDR_OWVAR 29
100003: PUSH
100004: LD_INT 12
100006: PUSH
100007: LD_INT 12
100009: PUSH
100010: EMPTY
100011: LIST
100012: LIST
100013: ST_TO_ADDR
// hc_agressivity := 20 ;
100014: LD_ADDR_OWVAR 35
100018: PUSH
100019: LD_INT 20
100021: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100022: LD_ADDR_OWVAR 28
100026: PUSH
100027: LD_INT 17
100029: ST_TO_ADDR
// hc_gallery :=  ;
100030: LD_ADDR_OWVAR 33
100034: PUSH
100035: LD_STRING 
100037: ST_TO_ADDR
// hc_name :=  ;
100038: LD_ADDR_OWVAR 26
100042: PUSH
100043: LD_STRING 
100045: ST_TO_ADDR
// un := CreateHuman ;
100046: LD_ADDR_VAR 0 2
100050: PUSH
100051: CALL_OW 44
100055: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100056: LD_VAR 0 2
100060: PPUSH
100061: LD_INT 1
100063: PPUSH
100064: CALL_OW 51
// tmp := tmp ^ un ;
100068: LD_ADDR_VAR 0 3
100072: PUSH
100073: LD_VAR 0 3
100077: PUSH
100078: LD_VAR 0 2
100082: ADD
100083: ST_TO_ADDR
// end ;
100084: GO 99980
100086: POP
100087: POP
// repeat wait ( 0 0$1 ) ;
100088: LD_INT 35
100090: PPUSH
100091: CALL_OW 67
// for un in tmp do
100095: LD_ADDR_VAR 0 2
100099: PUSH
100100: LD_VAR 0 3
100104: PUSH
100105: FOR_IN
100106: IFFALSE 100180
// begin if IsDead ( un ) then
100108: LD_VAR 0 2
100112: PPUSH
100113: CALL_OW 301
100117: IFFALSE 100137
// begin tmp := tmp diff un ;
100119: LD_ADDR_VAR 0 3
100123: PUSH
100124: LD_VAR 0 3
100128: PUSH
100129: LD_VAR 0 2
100133: DIFF
100134: ST_TO_ADDR
// continue ;
100135: GO 100105
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100137: LD_VAR 0 2
100141: PPUSH
100142: LD_INT 3
100144: PUSH
100145: LD_INT 22
100147: PUSH
100148: LD_INT 0
100150: PUSH
100151: EMPTY
100152: LIST
100153: LIST
100154: PUSH
100155: EMPTY
100156: LIST
100157: LIST
100158: PPUSH
100159: CALL_OW 69
100163: PPUSH
100164: LD_VAR 0 2
100168: PPUSH
100169: CALL_OW 74
100173: PPUSH
100174: CALL_OW 115
// end ;
100178: GO 100105
100180: POP
100181: POP
// until not tmp ;
100182: LD_VAR 0 3
100186: NOT
100187: IFFALSE 100088
// end ;
100189: PPOPN 3
100191: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100192: LD_EXP 93
100196: PUSH
100197: LD_EXP 118
100201: AND
100202: IFFALSE 100256
100204: GO 100206
100206: DISABLE
// begin ToLua ( displayTroll(); ) ;
100207: LD_STRING displayTroll();
100209: PPUSH
100210: CALL_OW 559
// wait ( 3 3$00 ) ;
100214: LD_INT 6300
100216: PPUSH
100217: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100221: LD_STRING hideTroll();
100223: PPUSH
100224: CALL_OW 559
// wait ( 1 1$00 ) ;
100228: LD_INT 2100
100230: PPUSH
100231: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100235: LD_STRING displayTroll();
100237: PPUSH
100238: CALL_OW 559
// wait ( 1 1$00 ) ;
100242: LD_INT 2100
100244: PPUSH
100245: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100249: LD_STRING hideTroll();
100251: PPUSH
100252: CALL_OW 559
// end ;
100256: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100257: LD_EXP 93
100261: PUSH
100262: LD_EXP 119
100266: AND
100267: IFFALSE 100330
100269: GO 100271
100271: DISABLE
100272: LD_INT 0
100274: PPUSH
// begin p := 0 ;
100275: LD_ADDR_VAR 0 1
100279: PUSH
100280: LD_INT 0
100282: ST_TO_ADDR
// repeat game_speed := 1 ;
100283: LD_ADDR_OWVAR 65
100287: PUSH
100288: LD_INT 1
100290: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100291: LD_INT 35
100293: PPUSH
100294: CALL_OW 67
// p := p + 1 ;
100298: LD_ADDR_VAR 0 1
100302: PUSH
100303: LD_VAR 0 1
100307: PUSH
100308: LD_INT 1
100310: PLUS
100311: ST_TO_ADDR
// until p >= 60 ;
100312: LD_VAR 0 1
100316: PUSH
100317: LD_INT 60
100319: GREATEREQUAL
100320: IFFALSE 100283
// game_speed := 4 ;
100322: LD_ADDR_OWVAR 65
100326: PUSH
100327: LD_INT 4
100329: ST_TO_ADDR
// end ;
100330: PPOPN 1
100332: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100333: LD_EXP 93
100337: PUSH
100338: LD_EXP 120
100342: AND
100343: IFFALSE 100489
100345: GO 100347
100347: DISABLE
100348: LD_INT 0
100350: PPUSH
100351: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100352: LD_ADDR_VAR 0 1
100356: PUSH
100357: LD_INT 22
100359: PUSH
100360: LD_OWVAR 2
100364: PUSH
100365: EMPTY
100366: LIST
100367: LIST
100368: PUSH
100369: LD_INT 2
100371: PUSH
100372: LD_INT 30
100374: PUSH
100375: LD_INT 0
100377: PUSH
100378: EMPTY
100379: LIST
100380: LIST
100381: PUSH
100382: LD_INT 30
100384: PUSH
100385: LD_INT 1
100387: PUSH
100388: EMPTY
100389: LIST
100390: LIST
100391: PUSH
100392: EMPTY
100393: LIST
100394: LIST
100395: LIST
100396: PUSH
100397: EMPTY
100398: LIST
100399: LIST
100400: PPUSH
100401: CALL_OW 69
100405: ST_TO_ADDR
// if not depot then
100406: LD_VAR 0 1
100410: NOT
100411: IFFALSE 100415
// exit ;
100413: GO 100489
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100415: LD_ADDR_VAR 0 2
100419: PUSH
100420: LD_VAR 0 1
100424: PUSH
100425: LD_INT 1
100427: PPUSH
100428: LD_VAR 0 1
100432: PPUSH
100433: CALL_OW 12
100437: ARRAY
100438: PPUSH
100439: CALL_OW 274
100443: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100444: LD_VAR 0 2
100448: PPUSH
100449: LD_INT 1
100451: PPUSH
100452: LD_INT 0
100454: PPUSH
100455: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100459: LD_VAR 0 2
100463: PPUSH
100464: LD_INT 2
100466: PPUSH
100467: LD_INT 0
100469: PPUSH
100470: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100474: LD_VAR 0 2
100478: PPUSH
100479: LD_INT 3
100481: PPUSH
100482: LD_INT 0
100484: PPUSH
100485: CALL_OW 277
// end ;
100489: PPOPN 2
100491: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100492: LD_EXP 93
100496: PUSH
100497: LD_EXP 121
100501: AND
100502: IFFALSE 100599
100504: GO 100506
100506: DISABLE
100507: LD_INT 0
100509: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100510: LD_ADDR_VAR 0 1
100514: PUSH
100515: LD_INT 22
100517: PUSH
100518: LD_OWVAR 2
100522: PUSH
100523: EMPTY
100524: LIST
100525: LIST
100526: PUSH
100527: LD_INT 21
100529: PUSH
100530: LD_INT 1
100532: PUSH
100533: EMPTY
100534: LIST
100535: LIST
100536: PUSH
100537: LD_INT 3
100539: PUSH
100540: LD_INT 23
100542: PUSH
100543: LD_INT 0
100545: PUSH
100546: EMPTY
100547: LIST
100548: LIST
100549: PUSH
100550: EMPTY
100551: LIST
100552: LIST
100553: PUSH
100554: EMPTY
100555: LIST
100556: LIST
100557: LIST
100558: PPUSH
100559: CALL_OW 69
100563: ST_TO_ADDR
// if not tmp then
100564: LD_VAR 0 1
100568: NOT
100569: IFFALSE 100573
// exit ;
100571: GO 100599
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100573: LD_VAR 0 1
100577: PUSH
100578: LD_INT 1
100580: PPUSH
100581: LD_VAR 0 1
100585: PPUSH
100586: CALL_OW 12
100590: ARRAY
100591: PPUSH
100592: LD_INT 200
100594: PPUSH
100595: CALL_OW 234
// end ;
100599: PPOPN 1
100601: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100602: LD_EXP 93
100606: PUSH
100607: LD_EXP 122
100611: AND
100612: IFFALSE 100691
100614: GO 100616
100616: DISABLE
100617: LD_INT 0
100619: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100620: LD_ADDR_VAR 0 1
100624: PUSH
100625: LD_INT 22
100627: PUSH
100628: LD_OWVAR 2
100632: PUSH
100633: EMPTY
100634: LIST
100635: LIST
100636: PUSH
100637: LD_INT 21
100639: PUSH
100640: LD_INT 2
100642: PUSH
100643: EMPTY
100644: LIST
100645: LIST
100646: PUSH
100647: EMPTY
100648: LIST
100649: LIST
100650: PPUSH
100651: CALL_OW 69
100655: ST_TO_ADDR
// if not tmp then
100656: LD_VAR 0 1
100660: NOT
100661: IFFALSE 100665
// exit ;
100663: GO 100691
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100665: LD_VAR 0 1
100669: PUSH
100670: LD_INT 1
100672: PPUSH
100673: LD_VAR 0 1
100677: PPUSH
100678: CALL_OW 12
100682: ARRAY
100683: PPUSH
100684: LD_INT 60
100686: PPUSH
100687: CALL_OW 234
// end ;
100691: PPOPN 1
100693: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100694: LD_EXP 93
100698: PUSH
100699: LD_EXP 123
100703: AND
100704: IFFALSE 100803
100706: GO 100708
100708: DISABLE
100709: LD_INT 0
100711: PPUSH
100712: PPUSH
// begin enable ;
100713: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100714: LD_ADDR_VAR 0 1
100718: PUSH
100719: LD_INT 22
100721: PUSH
100722: LD_OWVAR 2
100726: PUSH
100727: EMPTY
100728: LIST
100729: LIST
100730: PUSH
100731: LD_INT 61
100733: PUSH
100734: EMPTY
100735: LIST
100736: PUSH
100737: LD_INT 33
100739: PUSH
100740: LD_INT 2
100742: PUSH
100743: EMPTY
100744: LIST
100745: LIST
100746: PUSH
100747: EMPTY
100748: LIST
100749: LIST
100750: LIST
100751: PPUSH
100752: CALL_OW 69
100756: ST_TO_ADDR
// if not tmp then
100757: LD_VAR 0 1
100761: NOT
100762: IFFALSE 100766
// exit ;
100764: GO 100803
// for i in tmp do
100766: LD_ADDR_VAR 0 2
100770: PUSH
100771: LD_VAR 0 1
100775: PUSH
100776: FOR_IN
100777: IFFALSE 100801
// if IsControledBy ( i ) then
100779: LD_VAR 0 2
100783: PPUSH
100784: CALL_OW 312
100788: IFFALSE 100799
// ComUnlink ( i ) ;
100790: LD_VAR 0 2
100794: PPUSH
100795: CALL_OW 136
100799: GO 100776
100801: POP
100802: POP
// end ;
100803: PPOPN 2
100805: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100806: LD_EXP 93
100810: PUSH
100811: LD_EXP 124
100815: AND
100816: IFFALSE 100956
100818: GO 100820
100820: DISABLE
100821: LD_INT 0
100823: PPUSH
100824: PPUSH
// begin ToLua ( displayPowell(); ) ;
100825: LD_STRING displayPowell();
100827: PPUSH
100828: CALL_OW 559
// uc_side := 0 ;
100832: LD_ADDR_OWVAR 20
100836: PUSH
100837: LD_INT 0
100839: ST_TO_ADDR
// uc_nation := 2 ;
100840: LD_ADDR_OWVAR 21
100844: PUSH
100845: LD_INT 2
100847: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
100848: LD_ADDR_OWVAR 37
100852: PUSH
100853: LD_INT 14
100855: ST_TO_ADDR
// vc_engine := engine_siberite ;
100856: LD_ADDR_OWVAR 39
100860: PUSH
100861: LD_INT 3
100863: ST_TO_ADDR
// vc_control := control_apeman ;
100864: LD_ADDR_OWVAR 38
100868: PUSH
100869: LD_INT 5
100871: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100872: LD_ADDR_OWVAR 40
100876: PUSH
100877: LD_INT 29
100879: ST_TO_ADDR
// un := CreateVehicle ;
100880: LD_ADDR_VAR 0 2
100884: PUSH
100885: CALL_OW 45
100889: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100890: LD_VAR 0 2
100894: PPUSH
100895: LD_INT 1
100897: PPUSH
100898: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100902: LD_INT 35
100904: PPUSH
100905: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100909: LD_VAR 0 2
100913: PPUSH
100914: LD_INT 22
100916: PUSH
100917: LD_OWVAR 2
100921: PUSH
100922: EMPTY
100923: LIST
100924: LIST
100925: PPUSH
100926: CALL_OW 69
100930: PPUSH
100931: LD_VAR 0 2
100935: PPUSH
100936: CALL_OW 74
100940: PPUSH
100941: CALL_OW 115
// until IsDead ( un ) ;
100945: LD_VAR 0 2
100949: PPUSH
100950: CALL_OW 301
100954: IFFALSE 100902
// end ;
100956: PPOPN 2
100958: END
// every 0 0$1 trigger StreamModeActive and sStu do
100959: LD_EXP 93
100963: PUSH
100964: LD_EXP 132
100968: AND
100969: IFFALSE 100985
100971: GO 100973
100973: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100974: LD_STRING displayStucuk();
100976: PPUSH
100977: CALL_OW 559
// ResetFog ;
100981: CALL_OW 335
// end ;
100985: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100986: LD_EXP 93
100990: PUSH
100991: LD_EXP 125
100995: AND
100996: IFFALSE 101137
100998: GO 101000
101000: DISABLE
101001: LD_INT 0
101003: PPUSH
101004: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101005: LD_ADDR_VAR 0 2
101009: PUSH
101010: LD_INT 22
101012: PUSH
101013: LD_OWVAR 2
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: PUSH
101022: LD_INT 21
101024: PUSH
101025: LD_INT 1
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: PUSH
101032: EMPTY
101033: LIST
101034: LIST
101035: PPUSH
101036: CALL_OW 69
101040: ST_TO_ADDR
// if not tmp then
101041: LD_VAR 0 2
101045: NOT
101046: IFFALSE 101050
// exit ;
101048: GO 101137
// un := tmp [ rand ( 1 , tmp ) ] ;
101050: LD_ADDR_VAR 0 1
101054: PUSH
101055: LD_VAR 0 2
101059: PUSH
101060: LD_INT 1
101062: PPUSH
101063: LD_VAR 0 2
101067: PPUSH
101068: CALL_OW 12
101072: ARRAY
101073: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101074: LD_VAR 0 1
101078: PPUSH
101079: LD_INT 0
101081: PPUSH
101082: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101086: LD_VAR 0 1
101090: PPUSH
101091: LD_OWVAR 3
101095: PUSH
101096: LD_VAR 0 1
101100: DIFF
101101: PPUSH
101102: LD_VAR 0 1
101106: PPUSH
101107: CALL_OW 74
101111: PPUSH
101112: CALL_OW 115
// wait ( 0 0$20 ) ;
101116: LD_INT 700
101118: PPUSH
101119: CALL_OW 67
// SetSide ( un , your_side ) ;
101123: LD_VAR 0 1
101127: PPUSH
101128: LD_OWVAR 2
101132: PPUSH
101133: CALL_OW 235
// end ;
101137: PPOPN 2
101139: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101140: LD_EXP 93
101144: PUSH
101145: LD_EXP 126
101149: AND
101150: IFFALSE 101256
101152: GO 101154
101154: DISABLE
101155: LD_INT 0
101157: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101158: LD_ADDR_VAR 0 1
101162: PUSH
101163: LD_INT 22
101165: PUSH
101166: LD_OWVAR 2
101170: PUSH
101171: EMPTY
101172: LIST
101173: LIST
101174: PUSH
101175: LD_INT 2
101177: PUSH
101178: LD_INT 30
101180: PUSH
101181: LD_INT 0
101183: PUSH
101184: EMPTY
101185: LIST
101186: LIST
101187: PUSH
101188: LD_INT 30
101190: PUSH
101191: LD_INT 1
101193: PUSH
101194: EMPTY
101195: LIST
101196: LIST
101197: PUSH
101198: EMPTY
101199: LIST
101200: LIST
101201: LIST
101202: PUSH
101203: EMPTY
101204: LIST
101205: LIST
101206: PPUSH
101207: CALL_OW 69
101211: ST_TO_ADDR
// if not depot then
101212: LD_VAR 0 1
101216: NOT
101217: IFFALSE 101221
// exit ;
101219: GO 101256
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101221: LD_VAR 0 1
101225: PUSH
101226: LD_INT 1
101228: ARRAY
101229: PPUSH
101230: CALL_OW 250
101234: PPUSH
101235: LD_VAR 0 1
101239: PUSH
101240: LD_INT 1
101242: ARRAY
101243: PPUSH
101244: CALL_OW 251
101248: PPUSH
101249: LD_INT 70
101251: PPUSH
101252: CALL_OW 495
// end ;
101256: PPOPN 1
101258: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101259: LD_EXP 93
101263: PUSH
101264: LD_EXP 127
101268: AND
101269: IFFALSE 101480
101271: GO 101273
101273: DISABLE
101274: LD_INT 0
101276: PPUSH
101277: PPUSH
101278: PPUSH
101279: PPUSH
101280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101281: LD_ADDR_VAR 0 5
101285: PUSH
101286: LD_INT 22
101288: PUSH
101289: LD_OWVAR 2
101293: PUSH
101294: EMPTY
101295: LIST
101296: LIST
101297: PUSH
101298: LD_INT 21
101300: PUSH
101301: LD_INT 1
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: PUSH
101308: EMPTY
101309: LIST
101310: LIST
101311: PPUSH
101312: CALL_OW 69
101316: ST_TO_ADDR
// if not tmp then
101317: LD_VAR 0 5
101321: NOT
101322: IFFALSE 101326
// exit ;
101324: GO 101480
// for i in tmp do
101326: LD_ADDR_VAR 0 1
101330: PUSH
101331: LD_VAR 0 5
101335: PUSH
101336: FOR_IN
101337: IFFALSE 101478
// begin d := rand ( 0 , 5 ) ;
101339: LD_ADDR_VAR 0 4
101343: PUSH
101344: LD_INT 0
101346: PPUSH
101347: LD_INT 5
101349: PPUSH
101350: CALL_OW 12
101354: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101355: LD_ADDR_VAR 0 2
101359: PUSH
101360: LD_VAR 0 1
101364: PPUSH
101365: CALL_OW 250
101369: PPUSH
101370: LD_VAR 0 4
101374: PPUSH
101375: LD_INT 3
101377: PPUSH
101378: LD_INT 12
101380: PPUSH
101381: CALL_OW 12
101385: PPUSH
101386: CALL_OW 272
101390: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101391: LD_ADDR_VAR 0 3
101395: PUSH
101396: LD_VAR 0 1
101400: PPUSH
101401: CALL_OW 251
101405: PPUSH
101406: LD_VAR 0 4
101410: PPUSH
101411: LD_INT 3
101413: PPUSH
101414: LD_INT 12
101416: PPUSH
101417: CALL_OW 12
101421: PPUSH
101422: CALL_OW 273
101426: ST_TO_ADDR
// if ValidHex ( x , y ) then
101427: LD_VAR 0 2
101431: PPUSH
101432: LD_VAR 0 3
101436: PPUSH
101437: CALL_OW 488
101441: IFFALSE 101476
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101443: LD_VAR 0 1
101447: PPUSH
101448: LD_VAR 0 2
101452: PPUSH
101453: LD_VAR 0 3
101457: PPUSH
101458: LD_INT 3
101460: PPUSH
101461: LD_INT 6
101463: PPUSH
101464: CALL_OW 12
101468: PPUSH
101469: LD_INT 1
101471: PPUSH
101472: CALL_OW 483
// end ;
101476: GO 101336
101478: POP
101479: POP
// end ;
101480: PPOPN 5
101482: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101483: LD_EXP 93
101487: PUSH
101488: LD_EXP 128
101492: AND
101493: IFFALSE 101587
101495: GO 101497
101497: DISABLE
101498: LD_INT 0
101500: PPUSH
101501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101502: LD_ADDR_VAR 0 2
101506: PUSH
101507: LD_INT 22
101509: PUSH
101510: LD_OWVAR 2
101514: PUSH
101515: EMPTY
101516: LIST
101517: LIST
101518: PUSH
101519: LD_INT 32
101521: PUSH
101522: LD_INT 1
101524: PUSH
101525: EMPTY
101526: LIST
101527: LIST
101528: PUSH
101529: LD_INT 21
101531: PUSH
101532: LD_INT 2
101534: PUSH
101535: EMPTY
101536: LIST
101537: LIST
101538: PUSH
101539: EMPTY
101540: LIST
101541: LIST
101542: LIST
101543: PPUSH
101544: CALL_OW 69
101548: ST_TO_ADDR
// if not tmp then
101549: LD_VAR 0 2
101553: NOT
101554: IFFALSE 101558
// exit ;
101556: GO 101587
// for i in tmp do
101558: LD_ADDR_VAR 0 1
101562: PUSH
101563: LD_VAR 0 2
101567: PUSH
101568: FOR_IN
101569: IFFALSE 101585
// SetFuel ( i , 0 ) ;
101571: LD_VAR 0 1
101575: PPUSH
101576: LD_INT 0
101578: PPUSH
101579: CALL_OW 240
101583: GO 101568
101585: POP
101586: POP
// end ;
101587: PPOPN 2
101589: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101590: LD_EXP 93
101594: PUSH
101595: LD_EXP 129
101599: AND
101600: IFFALSE 101666
101602: GO 101604
101604: DISABLE
101605: LD_INT 0
101607: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101608: LD_ADDR_VAR 0 1
101612: PUSH
101613: LD_INT 22
101615: PUSH
101616: LD_OWVAR 2
101620: PUSH
101621: EMPTY
101622: LIST
101623: LIST
101624: PUSH
101625: LD_INT 30
101627: PUSH
101628: LD_INT 29
101630: PUSH
101631: EMPTY
101632: LIST
101633: LIST
101634: PUSH
101635: EMPTY
101636: LIST
101637: LIST
101638: PPUSH
101639: CALL_OW 69
101643: ST_TO_ADDR
// if not tmp then
101644: LD_VAR 0 1
101648: NOT
101649: IFFALSE 101653
// exit ;
101651: GO 101666
// DestroyUnit ( tmp [ 1 ] ) ;
101653: LD_VAR 0 1
101657: PUSH
101658: LD_INT 1
101660: ARRAY
101661: PPUSH
101662: CALL_OW 65
// end ;
101666: PPOPN 1
101668: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101669: LD_EXP 93
101673: PUSH
101674: LD_EXP 131
101678: AND
101679: IFFALSE 101808
101681: GO 101683
101683: DISABLE
101684: LD_INT 0
101686: PPUSH
// begin uc_side := 0 ;
101687: LD_ADDR_OWVAR 20
101691: PUSH
101692: LD_INT 0
101694: ST_TO_ADDR
// uc_nation := nation_arabian ;
101695: LD_ADDR_OWVAR 21
101699: PUSH
101700: LD_INT 2
101702: ST_TO_ADDR
// hc_gallery :=  ;
101703: LD_ADDR_OWVAR 33
101707: PUSH
101708: LD_STRING 
101710: ST_TO_ADDR
// hc_name :=  ;
101711: LD_ADDR_OWVAR 26
101715: PUSH
101716: LD_STRING 
101718: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101719: LD_INT 1
101721: PPUSH
101722: LD_INT 11
101724: PPUSH
101725: LD_INT 10
101727: PPUSH
101728: CALL_OW 380
// un := CreateHuman ;
101732: LD_ADDR_VAR 0 1
101736: PUSH
101737: CALL_OW 44
101741: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101742: LD_VAR 0 1
101746: PPUSH
101747: LD_INT 1
101749: PPUSH
101750: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101754: LD_INT 35
101756: PPUSH
101757: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101761: LD_VAR 0 1
101765: PPUSH
101766: LD_INT 22
101768: PUSH
101769: LD_OWVAR 2
101773: PUSH
101774: EMPTY
101775: LIST
101776: LIST
101777: PPUSH
101778: CALL_OW 69
101782: PPUSH
101783: LD_VAR 0 1
101787: PPUSH
101788: CALL_OW 74
101792: PPUSH
101793: CALL_OW 115
// until IsDead ( un ) ;
101797: LD_VAR 0 1
101801: PPUSH
101802: CALL_OW 301
101806: IFFALSE 101754
// end ;
101808: PPOPN 1
101810: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101811: LD_EXP 93
101815: PUSH
101816: LD_EXP 133
101820: AND
101821: IFFALSE 101833
101823: GO 101825
101825: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
101826: LD_STRING earthquake(getX(game), 0, 32)
101828: PPUSH
101829: CALL_OW 559
101833: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
101834: LD_EXP 93
101838: PUSH
101839: LD_EXP 134
101843: AND
101844: IFFALSE 101935
101846: GO 101848
101848: DISABLE
101849: LD_INT 0
101851: PPUSH
// begin enable ;
101852: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
101853: LD_ADDR_VAR 0 1
101857: PUSH
101858: LD_INT 22
101860: PUSH
101861: LD_OWVAR 2
101865: PUSH
101866: EMPTY
101867: LIST
101868: LIST
101869: PUSH
101870: LD_INT 21
101872: PUSH
101873: LD_INT 2
101875: PUSH
101876: EMPTY
101877: LIST
101878: LIST
101879: PUSH
101880: LD_INT 33
101882: PUSH
101883: LD_INT 3
101885: PUSH
101886: EMPTY
101887: LIST
101888: LIST
101889: PUSH
101890: EMPTY
101891: LIST
101892: LIST
101893: LIST
101894: PPUSH
101895: CALL_OW 69
101899: ST_TO_ADDR
// if not tmp then
101900: LD_VAR 0 1
101904: NOT
101905: IFFALSE 101909
// exit ;
101907: GO 101935
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101909: LD_VAR 0 1
101913: PUSH
101914: LD_INT 1
101916: PPUSH
101917: LD_VAR 0 1
101921: PPUSH
101922: CALL_OW 12
101926: ARRAY
101927: PPUSH
101928: LD_INT 1
101930: PPUSH
101931: CALL_OW 234
// end ;
101935: PPOPN 1
101937: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101938: LD_EXP 93
101942: PUSH
101943: LD_EXP 135
101947: AND
101948: IFFALSE 102089
101950: GO 101952
101952: DISABLE
101953: LD_INT 0
101955: PPUSH
101956: PPUSH
101957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101958: LD_ADDR_VAR 0 3
101962: PUSH
101963: LD_INT 22
101965: PUSH
101966: LD_OWVAR 2
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: PUSH
101975: LD_INT 25
101977: PUSH
101978: LD_INT 1
101980: PUSH
101981: EMPTY
101982: LIST
101983: LIST
101984: PUSH
101985: EMPTY
101986: LIST
101987: LIST
101988: PPUSH
101989: CALL_OW 69
101993: ST_TO_ADDR
// if not tmp then
101994: LD_VAR 0 3
101998: NOT
101999: IFFALSE 102003
// exit ;
102001: GO 102089
// un := tmp [ rand ( 1 , tmp ) ] ;
102003: LD_ADDR_VAR 0 2
102007: PUSH
102008: LD_VAR 0 3
102012: PUSH
102013: LD_INT 1
102015: PPUSH
102016: LD_VAR 0 3
102020: PPUSH
102021: CALL_OW 12
102025: ARRAY
102026: ST_TO_ADDR
// if Crawls ( un ) then
102027: LD_VAR 0 2
102031: PPUSH
102032: CALL_OW 318
102036: IFFALSE 102047
// ComWalk ( un ) ;
102038: LD_VAR 0 2
102042: PPUSH
102043: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102047: LD_VAR 0 2
102051: PPUSH
102052: LD_INT 9
102054: PPUSH
102055: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102059: LD_INT 28
102061: PPUSH
102062: LD_OWVAR 2
102066: PPUSH
102067: LD_INT 2
102069: PPUSH
102070: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102074: LD_INT 29
102076: PPUSH
102077: LD_OWVAR 2
102081: PPUSH
102082: LD_INT 2
102084: PPUSH
102085: CALL_OW 322
// end ;
102089: PPOPN 3
102091: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102092: LD_EXP 93
102096: PUSH
102097: LD_EXP 136
102101: AND
102102: IFFALSE 102213
102104: GO 102106
102106: DISABLE
102107: LD_INT 0
102109: PPUSH
102110: PPUSH
102111: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102112: LD_ADDR_VAR 0 3
102116: PUSH
102117: LD_INT 22
102119: PUSH
102120: LD_OWVAR 2
102124: PUSH
102125: EMPTY
102126: LIST
102127: LIST
102128: PUSH
102129: LD_INT 25
102131: PUSH
102132: LD_INT 1
102134: PUSH
102135: EMPTY
102136: LIST
102137: LIST
102138: PUSH
102139: EMPTY
102140: LIST
102141: LIST
102142: PPUSH
102143: CALL_OW 69
102147: ST_TO_ADDR
// if not tmp then
102148: LD_VAR 0 3
102152: NOT
102153: IFFALSE 102157
// exit ;
102155: GO 102213
// un := tmp [ rand ( 1 , tmp ) ] ;
102157: LD_ADDR_VAR 0 2
102161: PUSH
102162: LD_VAR 0 3
102166: PUSH
102167: LD_INT 1
102169: PPUSH
102170: LD_VAR 0 3
102174: PPUSH
102175: CALL_OW 12
102179: ARRAY
102180: ST_TO_ADDR
// if Crawls ( un ) then
102181: LD_VAR 0 2
102185: PPUSH
102186: CALL_OW 318
102190: IFFALSE 102201
// ComWalk ( un ) ;
102192: LD_VAR 0 2
102196: PPUSH
102197: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102201: LD_VAR 0 2
102205: PPUSH
102206: LD_INT 8
102208: PPUSH
102209: CALL_OW 336
// end ;
102213: PPOPN 3
102215: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102216: LD_EXP 93
102220: PUSH
102221: LD_EXP 137
102225: AND
102226: IFFALSE 102370
102228: GO 102230
102230: DISABLE
102231: LD_INT 0
102233: PPUSH
102234: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102235: LD_ADDR_VAR 0 2
102239: PUSH
102240: LD_INT 22
102242: PUSH
102243: LD_OWVAR 2
102247: PUSH
102248: EMPTY
102249: LIST
102250: LIST
102251: PUSH
102252: LD_INT 21
102254: PUSH
102255: LD_INT 2
102257: PUSH
102258: EMPTY
102259: LIST
102260: LIST
102261: PUSH
102262: LD_INT 2
102264: PUSH
102265: LD_INT 34
102267: PUSH
102268: LD_INT 12
102270: PUSH
102271: EMPTY
102272: LIST
102273: LIST
102274: PUSH
102275: LD_INT 34
102277: PUSH
102278: LD_INT 51
102280: PUSH
102281: EMPTY
102282: LIST
102283: LIST
102284: PUSH
102285: LD_INT 34
102287: PUSH
102288: LD_INT 32
102290: PUSH
102291: EMPTY
102292: LIST
102293: LIST
102294: PUSH
102295: EMPTY
102296: LIST
102297: LIST
102298: LIST
102299: LIST
102300: PUSH
102301: EMPTY
102302: LIST
102303: LIST
102304: LIST
102305: PPUSH
102306: CALL_OW 69
102310: ST_TO_ADDR
// if not tmp then
102311: LD_VAR 0 2
102315: NOT
102316: IFFALSE 102320
// exit ;
102318: GO 102370
// for i in tmp do
102320: LD_ADDR_VAR 0 1
102324: PUSH
102325: LD_VAR 0 2
102329: PUSH
102330: FOR_IN
102331: IFFALSE 102368
// if GetCargo ( i , mat_artifact ) = 0 then
102333: LD_VAR 0 1
102337: PPUSH
102338: LD_INT 4
102340: PPUSH
102341: CALL_OW 289
102345: PUSH
102346: LD_INT 0
102348: EQUAL
102349: IFFALSE 102366
// SetCargo ( i , mat_siberit , 100 ) ;
102351: LD_VAR 0 1
102355: PPUSH
102356: LD_INT 3
102358: PPUSH
102359: LD_INT 100
102361: PPUSH
102362: CALL_OW 290
102366: GO 102330
102368: POP
102369: POP
// end ;
102370: PPOPN 2
102372: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102373: LD_EXP 93
102377: PUSH
102378: LD_EXP 138
102382: AND
102383: IFFALSE 102566
102385: GO 102387
102387: DISABLE
102388: LD_INT 0
102390: PPUSH
102391: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102392: LD_ADDR_VAR 0 2
102396: PUSH
102397: LD_INT 22
102399: PUSH
102400: LD_OWVAR 2
102404: PUSH
102405: EMPTY
102406: LIST
102407: LIST
102408: PPUSH
102409: CALL_OW 69
102413: ST_TO_ADDR
// if not tmp then
102414: LD_VAR 0 2
102418: NOT
102419: IFFALSE 102423
// exit ;
102421: GO 102566
// for i := 1 to 2 do
102423: LD_ADDR_VAR 0 1
102427: PUSH
102428: DOUBLE
102429: LD_INT 1
102431: DEC
102432: ST_TO_ADDR
102433: LD_INT 2
102435: PUSH
102436: FOR_TO
102437: IFFALSE 102564
// begin uc_side := your_side ;
102439: LD_ADDR_OWVAR 20
102443: PUSH
102444: LD_OWVAR 2
102448: ST_TO_ADDR
// uc_nation := nation_american ;
102449: LD_ADDR_OWVAR 21
102453: PUSH
102454: LD_INT 1
102456: ST_TO_ADDR
// vc_chassis := us_morphling ;
102457: LD_ADDR_OWVAR 37
102461: PUSH
102462: LD_INT 5
102464: ST_TO_ADDR
// vc_engine := engine_siberite ;
102465: LD_ADDR_OWVAR 39
102469: PUSH
102470: LD_INT 3
102472: ST_TO_ADDR
// vc_control := control_computer ;
102473: LD_ADDR_OWVAR 38
102477: PUSH
102478: LD_INT 3
102480: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102481: LD_ADDR_OWVAR 40
102485: PUSH
102486: LD_INT 10
102488: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102489: LD_VAR 0 2
102493: PUSH
102494: LD_INT 1
102496: ARRAY
102497: PPUSH
102498: CALL_OW 310
102502: NOT
102503: IFFALSE 102550
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102505: CALL_OW 45
102509: PPUSH
102510: LD_VAR 0 2
102514: PUSH
102515: LD_INT 1
102517: ARRAY
102518: PPUSH
102519: CALL_OW 250
102523: PPUSH
102524: LD_VAR 0 2
102528: PUSH
102529: LD_INT 1
102531: ARRAY
102532: PPUSH
102533: CALL_OW 251
102537: PPUSH
102538: LD_INT 12
102540: PPUSH
102541: LD_INT 1
102543: PPUSH
102544: CALL_OW 50
102548: GO 102562
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102550: CALL_OW 45
102554: PPUSH
102555: LD_INT 1
102557: PPUSH
102558: CALL_OW 51
// end ;
102562: GO 102436
102564: POP
102565: POP
// end ;
102566: PPOPN 2
102568: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102569: LD_EXP 93
102573: PUSH
102574: LD_EXP 139
102578: AND
102579: IFFALSE 102801
102581: GO 102583
102583: DISABLE
102584: LD_INT 0
102586: PPUSH
102587: PPUSH
102588: PPUSH
102589: PPUSH
102590: PPUSH
102591: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102592: LD_ADDR_VAR 0 6
102596: PUSH
102597: LD_INT 22
102599: PUSH
102600: LD_OWVAR 2
102604: PUSH
102605: EMPTY
102606: LIST
102607: LIST
102608: PUSH
102609: LD_INT 21
102611: PUSH
102612: LD_INT 1
102614: PUSH
102615: EMPTY
102616: LIST
102617: LIST
102618: PUSH
102619: LD_INT 3
102621: PUSH
102622: LD_INT 23
102624: PUSH
102625: LD_INT 0
102627: PUSH
102628: EMPTY
102629: LIST
102630: LIST
102631: PUSH
102632: EMPTY
102633: LIST
102634: LIST
102635: PUSH
102636: EMPTY
102637: LIST
102638: LIST
102639: LIST
102640: PPUSH
102641: CALL_OW 69
102645: ST_TO_ADDR
// if not tmp then
102646: LD_VAR 0 6
102650: NOT
102651: IFFALSE 102655
// exit ;
102653: GO 102801
// s1 := rand ( 1 , 4 ) ;
102655: LD_ADDR_VAR 0 2
102659: PUSH
102660: LD_INT 1
102662: PPUSH
102663: LD_INT 4
102665: PPUSH
102666: CALL_OW 12
102670: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102671: LD_ADDR_VAR 0 4
102675: PUSH
102676: LD_VAR 0 6
102680: PUSH
102681: LD_INT 1
102683: ARRAY
102684: PPUSH
102685: LD_VAR 0 2
102689: PPUSH
102690: CALL_OW 259
102694: ST_TO_ADDR
// if s1 = 1 then
102695: LD_VAR 0 2
102699: PUSH
102700: LD_INT 1
102702: EQUAL
102703: IFFALSE 102723
// s2 := rand ( 2 , 4 ) else
102705: LD_ADDR_VAR 0 3
102709: PUSH
102710: LD_INT 2
102712: PPUSH
102713: LD_INT 4
102715: PPUSH
102716: CALL_OW 12
102720: ST_TO_ADDR
102721: GO 102731
// s2 := 1 ;
102723: LD_ADDR_VAR 0 3
102727: PUSH
102728: LD_INT 1
102730: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102731: LD_ADDR_VAR 0 5
102735: PUSH
102736: LD_VAR 0 6
102740: PUSH
102741: LD_INT 1
102743: ARRAY
102744: PPUSH
102745: LD_VAR 0 3
102749: PPUSH
102750: CALL_OW 259
102754: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102755: LD_VAR 0 6
102759: PUSH
102760: LD_INT 1
102762: ARRAY
102763: PPUSH
102764: LD_VAR 0 2
102768: PPUSH
102769: LD_VAR 0 5
102773: PPUSH
102774: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102778: LD_VAR 0 6
102782: PUSH
102783: LD_INT 1
102785: ARRAY
102786: PPUSH
102787: LD_VAR 0 3
102791: PPUSH
102792: LD_VAR 0 4
102796: PPUSH
102797: CALL_OW 237
// end ;
102801: PPOPN 6
102803: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102804: LD_EXP 93
102808: PUSH
102809: LD_EXP 140
102813: AND
102814: IFFALSE 102893
102816: GO 102818
102818: DISABLE
102819: LD_INT 0
102821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102822: LD_ADDR_VAR 0 1
102826: PUSH
102827: LD_INT 22
102829: PUSH
102830: LD_OWVAR 2
102834: PUSH
102835: EMPTY
102836: LIST
102837: LIST
102838: PUSH
102839: LD_INT 30
102841: PUSH
102842: LD_INT 3
102844: PUSH
102845: EMPTY
102846: LIST
102847: LIST
102848: PUSH
102849: EMPTY
102850: LIST
102851: LIST
102852: PPUSH
102853: CALL_OW 69
102857: ST_TO_ADDR
// if not tmp then
102858: LD_VAR 0 1
102862: NOT
102863: IFFALSE 102867
// exit ;
102865: GO 102893
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102867: LD_VAR 0 1
102871: PUSH
102872: LD_INT 1
102874: PPUSH
102875: LD_VAR 0 1
102879: PPUSH
102880: CALL_OW 12
102884: ARRAY
102885: PPUSH
102886: LD_INT 1
102888: PPUSH
102889: CALL_OW 234
// end ;
102893: PPOPN 1
102895: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
102896: LD_EXP 93
102900: PUSH
102901: LD_EXP 141
102905: AND
102906: IFFALSE 103018
102908: GO 102910
102910: DISABLE
102911: LD_INT 0
102913: PPUSH
102914: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102915: LD_ADDR_VAR 0 2
102919: PUSH
102920: LD_INT 22
102922: PUSH
102923: LD_OWVAR 2
102927: PUSH
102928: EMPTY
102929: LIST
102930: LIST
102931: PUSH
102932: LD_INT 2
102934: PUSH
102935: LD_INT 30
102937: PUSH
102938: LD_INT 27
102940: PUSH
102941: EMPTY
102942: LIST
102943: LIST
102944: PUSH
102945: LD_INT 30
102947: PUSH
102948: LD_INT 26
102950: PUSH
102951: EMPTY
102952: LIST
102953: LIST
102954: PUSH
102955: LD_INT 30
102957: PUSH
102958: LD_INT 28
102960: PUSH
102961: EMPTY
102962: LIST
102963: LIST
102964: PUSH
102965: EMPTY
102966: LIST
102967: LIST
102968: LIST
102969: LIST
102970: PUSH
102971: EMPTY
102972: LIST
102973: LIST
102974: PPUSH
102975: CALL_OW 69
102979: ST_TO_ADDR
// if not tmp then
102980: LD_VAR 0 2
102984: NOT
102985: IFFALSE 102989
// exit ;
102987: GO 103018
// for i in tmp do
102989: LD_ADDR_VAR 0 1
102993: PUSH
102994: LD_VAR 0 2
102998: PUSH
102999: FOR_IN
103000: IFFALSE 103016
// SetLives ( i , 1 ) ;
103002: LD_VAR 0 1
103006: PPUSH
103007: LD_INT 1
103009: PPUSH
103010: CALL_OW 234
103014: GO 102999
103016: POP
103017: POP
// end ;
103018: PPOPN 2
103020: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103021: LD_EXP 93
103025: PUSH
103026: LD_EXP 142
103030: AND
103031: IFFALSE 103318
103033: GO 103035
103035: DISABLE
103036: LD_INT 0
103038: PPUSH
103039: PPUSH
103040: PPUSH
// begin i := rand ( 1 , 7 ) ;
103041: LD_ADDR_VAR 0 1
103045: PUSH
103046: LD_INT 1
103048: PPUSH
103049: LD_INT 7
103051: PPUSH
103052: CALL_OW 12
103056: ST_TO_ADDR
// case i of 1 :
103057: LD_VAR 0 1
103061: PUSH
103062: LD_INT 1
103064: DOUBLE
103065: EQUAL
103066: IFTRUE 103070
103068: GO 103080
103070: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103071: LD_STRING earthquake(getX(game), 0, 32)
103073: PPUSH
103074: CALL_OW 559
103078: GO 103318
103080: LD_INT 2
103082: DOUBLE
103083: EQUAL
103084: IFTRUE 103088
103086: GO 103102
103088: POP
// begin ToLua ( displayStucuk(); ) ;
103089: LD_STRING displayStucuk();
103091: PPUSH
103092: CALL_OW 559
// ResetFog ;
103096: CALL_OW 335
// end ; 3 :
103100: GO 103318
103102: LD_INT 3
103104: DOUBLE
103105: EQUAL
103106: IFTRUE 103110
103108: GO 103214
103110: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103111: LD_ADDR_VAR 0 2
103115: PUSH
103116: LD_INT 22
103118: PUSH
103119: LD_OWVAR 2
103123: PUSH
103124: EMPTY
103125: LIST
103126: LIST
103127: PUSH
103128: LD_INT 25
103130: PUSH
103131: LD_INT 1
103133: PUSH
103134: EMPTY
103135: LIST
103136: LIST
103137: PUSH
103138: EMPTY
103139: LIST
103140: LIST
103141: PPUSH
103142: CALL_OW 69
103146: ST_TO_ADDR
// if not tmp then
103147: LD_VAR 0 2
103151: NOT
103152: IFFALSE 103156
// exit ;
103154: GO 103318
// un := tmp [ rand ( 1 , tmp ) ] ;
103156: LD_ADDR_VAR 0 3
103160: PUSH
103161: LD_VAR 0 2
103165: PUSH
103166: LD_INT 1
103168: PPUSH
103169: LD_VAR 0 2
103173: PPUSH
103174: CALL_OW 12
103178: ARRAY
103179: ST_TO_ADDR
// if Crawls ( un ) then
103180: LD_VAR 0 3
103184: PPUSH
103185: CALL_OW 318
103189: IFFALSE 103200
// ComWalk ( un ) ;
103191: LD_VAR 0 3
103195: PPUSH
103196: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103200: LD_VAR 0 3
103204: PPUSH
103205: LD_INT 8
103207: PPUSH
103208: CALL_OW 336
// end ; 4 :
103212: GO 103318
103214: LD_INT 4
103216: DOUBLE
103217: EQUAL
103218: IFTRUE 103222
103220: GO 103296
103222: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103223: LD_ADDR_VAR 0 2
103227: PUSH
103228: LD_INT 22
103230: PUSH
103231: LD_OWVAR 2
103235: PUSH
103236: EMPTY
103237: LIST
103238: LIST
103239: PUSH
103240: LD_INT 30
103242: PUSH
103243: LD_INT 29
103245: PUSH
103246: EMPTY
103247: LIST
103248: LIST
103249: PUSH
103250: EMPTY
103251: LIST
103252: LIST
103253: PPUSH
103254: CALL_OW 69
103258: ST_TO_ADDR
// if not tmp then
103259: LD_VAR 0 2
103263: NOT
103264: IFFALSE 103268
// exit ;
103266: GO 103318
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103268: LD_VAR 0 2
103272: PUSH
103273: LD_INT 1
103275: ARRAY
103276: PPUSH
103277: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103281: LD_VAR 0 2
103285: PUSH
103286: LD_INT 1
103288: ARRAY
103289: PPUSH
103290: CALL_OW 65
// end ; 5 .. 7 :
103294: GO 103318
103296: LD_INT 5
103298: DOUBLE
103299: GREATEREQUAL
103300: IFFALSE 103308
103302: LD_INT 7
103304: DOUBLE
103305: LESSEQUAL
103306: IFTRUE 103310
103308: GO 103317
103310: POP
// StreamSibBomb ; end ;
103311: CALL 99555 0 0
103315: GO 103318
103317: POP
// end ;
103318: PPOPN 3
103320: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103321: LD_EXP 93
103325: PUSH
103326: LD_EXP 143
103330: AND
103331: IFFALSE 103487
103333: GO 103335
103335: DISABLE
103336: LD_INT 0
103338: PPUSH
103339: PPUSH
103340: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103341: LD_ADDR_VAR 0 2
103345: PUSH
103346: LD_INT 81
103348: PUSH
103349: LD_OWVAR 2
103353: PUSH
103354: EMPTY
103355: LIST
103356: LIST
103357: PUSH
103358: LD_INT 2
103360: PUSH
103361: LD_INT 21
103363: PUSH
103364: LD_INT 1
103366: PUSH
103367: EMPTY
103368: LIST
103369: LIST
103370: PUSH
103371: LD_INT 21
103373: PUSH
103374: LD_INT 2
103376: PUSH
103377: EMPTY
103378: LIST
103379: LIST
103380: PUSH
103381: EMPTY
103382: LIST
103383: LIST
103384: LIST
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: PPUSH
103390: CALL_OW 69
103394: ST_TO_ADDR
// if not tmp then
103395: LD_VAR 0 2
103399: NOT
103400: IFFALSE 103404
// exit ;
103402: GO 103487
// p := 0 ;
103404: LD_ADDR_VAR 0 3
103408: PUSH
103409: LD_INT 0
103411: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103412: LD_INT 35
103414: PPUSH
103415: CALL_OW 67
// p := p + 1 ;
103419: LD_ADDR_VAR 0 3
103423: PUSH
103424: LD_VAR 0 3
103428: PUSH
103429: LD_INT 1
103431: PLUS
103432: ST_TO_ADDR
// for i in tmp do
103433: LD_ADDR_VAR 0 1
103437: PUSH
103438: LD_VAR 0 2
103442: PUSH
103443: FOR_IN
103444: IFFALSE 103475
// if GetLives ( i ) < 1000 then
103446: LD_VAR 0 1
103450: PPUSH
103451: CALL_OW 256
103455: PUSH
103456: LD_INT 1000
103458: LESS
103459: IFFALSE 103473
// SetLives ( i , 1000 ) ;
103461: LD_VAR 0 1
103465: PPUSH
103466: LD_INT 1000
103468: PPUSH
103469: CALL_OW 234
103473: GO 103443
103475: POP
103476: POP
// until p > 20 ;
103477: LD_VAR 0 3
103481: PUSH
103482: LD_INT 20
103484: GREATER
103485: IFFALSE 103412
// end ;
103487: PPOPN 3
103489: END
// every 0 0$1 trigger StreamModeActive and sTime do
103490: LD_EXP 93
103494: PUSH
103495: LD_EXP 144
103499: AND
103500: IFFALSE 103535
103502: GO 103504
103504: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103505: LD_INT 28
103507: PPUSH
103508: LD_OWVAR 2
103512: PPUSH
103513: LD_INT 2
103515: PPUSH
103516: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103520: LD_INT 30
103522: PPUSH
103523: LD_OWVAR 2
103527: PPUSH
103528: LD_INT 2
103530: PPUSH
103531: CALL_OW 322
// end ;
103535: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103536: LD_EXP 93
103540: PUSH
103541: LD_EXP 145
103545: AND
103546: IFFALSE 103667
103548: GO 103550
103550: DISABLE
103551: LD_INT 0
103553: PPUSH
103554: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103555: LD_ADDR_VAR 0 2
103559: PUSH
103560: LD_INT 22
103562: PUSH
103563: LD_OWVAR 2
103567: PUSH
103568: EMPTY
103569: LIST
103570: LIST
103571: PUSH
103572: LD_INT 21
103574: PUSH
103575: LD_INT 1
103577: PUSH
103578: EMPTY
103579: LIST
103580: LIST
103581: PUSH
103582: LD_INT 3
103584: PUSH
103585: LD_INT 23
103587: PUSH
103588: LD_INT 0
103590: PUSH
103591: EMPTY
103592: LIST
103593: LIST
103594: PUSH
103595: EMPTY
103596: LIST
103597: LIST
103598: PUSH
103599: EMPTY
103600: LIST
103601: LIST
103602: LIST
103603: PPUSH
103604: CALL_OW 69
103608: ST_TO_ADDR
// if not tmp then
103609: LD_VAR 0 2
103613: NOT
103614: IFFALSE 103618
// exit ;
103616: GO 103667
// for i in tmp do
103618: LD_ADDR_VAR 0 1
103622: PUSH
103623: LD_VAR 0 2
103627: PUSH
103628: FOR_IN
103629: IFFALSE 103665
// begin if Crawls ( i ) then
103631: LD_VAR 0 1
103635: PPUSH
103636: CALL_OW 318
103640: IFFALSE 103651
// ComWalk ( i ) ;
103642: LD_VAR 0 1
103646: PPUSH
103647: CALL_OW 138
// SetClass ( i , 2 ) ;
103651: LD_VAR 0 1
103655: PPUSH
103656: LD_INT 2
103658: PPUSH
103659: CALL_OW 336
// end ;
103663: GO 103628
103665: POP
103666: POP
// end ;
103667: PPOPN 2
103669: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103670: LD_EXP 93
103674: PUSH
103675: LD_EXP 146
103679: AND
103680: IFFALSE 103968
103682: GO 103684
103684: DISABLE
103685: LD_INT 0
103687: PPUSH
103688: PPUSH
103689: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103690: LD_OWVAR 2
103694: PPUSH
103695: LD_INT 9
103697: PPUSH
103698: LD_INT 1
103700: PPUSH
103701: LD_INT 1
103703: PPUSH
103704: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103708: LD_INT 9
103710: PPUSH
103711: LD_OWVAR 2
103715: PPUSH
103716: CALL_OW 343
// uc_side := 9 ;
103720: LD_ADDR_OWVAR 20
103724: PUSH
103725: LD_INT 9
103727: ST_TO_ADDR
// uc_nation := 2 ;
103728: LD_ADDR_OWVAR 21
103732: PUSH
103733: LD_INT 2
103735: ST_TO_ADDR
// hc_name := Dark Warrior ;
103736: LD_ADDR_OWVAR 26
103740: PUSH
103741: LD_STRING Dark Warrior
103743: ST_TO_ADDR
// hc_gallery :=  ;
103744: LD_ADDR_OWVAR 33
103748: PUSH
103749: LD_STRING 
103751: ST_TO_ADDR
// hc_noskilllimit := true ;
103752: LD_ADDR_OWVAR 76
103756: PUSH
103757: LD_INT 1
103759: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103760: LD_ADDR_OWVAR 31
103764: PUSH
103765: LD_INT 30
103767: PUSH
103768: LD_INT 30
103770: PUSH
103771: LD_INT 30
103773: PUSH
103774: LD_INT 30
103776: PUSH
103777: EMPTY
103778: LIST
103779: LIST
103780: LIST
103781: LIST
103782: ST_TO_ADDR
// un := CreateHuman ;
103783: LD_ADDR_VAR 0 3
103787: PUSH
103788: CALL_OW 44
103792: ST_TO_ADDR
// hc_noskilllimit := false ;
103793: LD_ADDR_OWVAR 76
103797: PUSH
103798: LD_INT 0
103800: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103801: LD_VAR 0 3
103805: PPUSH
103806: LD_INT 1
103808: PPUSH
103809: CALL_OW 51
// ToLua ( playRanger() ) ;
103813: LD_STRING playRanger()
103815: PPUSH
103816: CALL_OW 559
// p := 0 ;
103820: LD_ADDR_VAR 0 2
103824: PUSH
103825: LD_INT 0
103827: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103828: LD_INT 35
103830: PPUSH
103831: CALL_OW 67
// p := p + 1 ;
103835: LD_ADDR_VAR 0 2
103839: PUSH
103840: LD_VAR 0 2
103844: PUSH
103845: LD_INT 1
103847: PLUS
103848: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
103849: LD_VAR 0 3
103853: PPUSH
103854: CALL_OW 256
103858: PUSH
103859: LD_INT 1000
103861: LESS
103862: IFFALSE 103876
// SetLives ( un , 1000 ) ;
103864: LD_VAR 0 3
103868: PPUSH
103869: LD_INT 1000
103871: PPUSH
103872: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
103876: LD_VAR 0 3
103880: PPUSH
103881: LD_INT 81
103883: PUSH
103884: LD_OWVAR 2
103888: PUSH
103889: EMPTY
103890: LIST
103891: LIST
103892: PUSH
103893: LD_INT 91
103895: PUSH
103896: LD_VAR 0 3
103900: PUSH
103901: LD_INT 30
103903: PUSH
103904: EMPTY
103905: LIST
103906: LIST
103907: LIST
103908: PUSH
103909: EMPTY
103910: LIST
103911: LIST
103912: PPUSH
103913: CALL_OW 69
103917: PPUSH
103918: LD_VAR 0 3
103922: PPUSH
103923: CALL_OW 74
103927: PPUSH
103928: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103932: LD_VAR 0 2
103936: PUSH
103937: LD_INT 80
103939: GREATER
103940: PUSH
103941: LD_VAR 0 3
103945: PPUSH
103946: CALL_OW 301
103950: OR
103951: IFFALSE 103828
// if un then
103953: LD_VAR 0 3
103957: IFFALSE 103968
// RemoveUnit ( un ) ;
103959: LD_VAR 0 3
103963: PPUSH
103964: CALL_OW 64
// end ;
103968: PPOPN 3
103970: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103971: LD_EXP 147
103975: IFFALSE 104091
103977: GO 103979
103979: DISABLE
103980: LD_INT 0
103982: PPUSH
103983: PPUSH
103984: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103985: LD_ADDR_VAR 0 2
103989: PUSH
103990: LD_INT 81
103992: PUSH
103993: LD_OWVAR 2
103997: PUSH
103998: EMPTY
103999: LIST
104000: LIST
104001: PUSH
104002: LD_INT 21
104004: PUSH
104005: LD_INT 1
104007: PUSH
104008: EMPTY
104009: LIST
104010: LIST
104011: PUSH
104012: EMPTY
104013: LIST
104014: LIST
104015: PPUSH
104016: CALL_OW 69
104020: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104021: LD_STRING playComputer()
104023: PPUSH
104024: CALL_OW 559
// if not tmp then
104028: LD_VAR 0 2
104032: NOT
104033: IFFALSE 104037
// exit ;
104035: GO 104091
// for i in tmp do
104037: LD_ADDR_VAR 0 1
104041: PUSH
104042: LD_VAR 0 2
104046: PUSH
104047: FOR_IN
104048: IFFALSE 104089
// for j := 1 to 4 do
104050: LD_ADDR_VAR 0 3
104054: PUSH
104055: DOUBLE
104056: LD_INT 1
104058: DEC
104059: ST_TO_ADDR
104060: LD_INT 4
104062: PUSH
104063: FOR_TO
104064: IFFALSE 104085
// SetSkill ( i , j , 10 ) ;
104066: LD_VAR 0 1
104070: PPUSH
104071: LD_VAR 0 3
104075: PPUSH
104076: LD_INT 10
104078: PPUSH
104079: CALL_OW 237
104083: GO 104063
104085: POP
104086: POP
104087: GO 104047
104089: POP
104090: POP
// end ;
104091: PPOPN 3
104093: END
// every 0 0$1 trigger s30 do var i , tmp ;
104094: LD_EXP 148
104098: IFFALSE 104167
104100: GO 104102
104102: DISABLE
104103: LD_INT 0
104105: PPUSH
104106: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104107: LD_ADDR_VAR 0 2
104111: PUSH
104112: LD_INT 22
104114: PUSH
104115: LD_OWVAR 2
104119: PUSH
104120: EMPTY
104121: LIST
104122: LIST
104123: PPUSH
104124: CALL_OW 69
104128: ST_TO_ADDR
// if not tmp then
104129: LD_VAR 0 2
104133: NOT
104134: IFFALSE 104138
// exit ;
104136: GO 104167
// for i in tmp do
104138: LD_ADDR_VAR 0 1
104142: PUSH
104143: LD_VAR 0 2
104147: PUSH
104148: FOR_IN
104149: IFFALSE 104165
// SetLives ( i , 300 ) ;
104151: LD_VAR 0 1
104155: PPUSH
104156: LD_INT 300
104158: PPUSH
104159: CALL_OW 234
104163: GO 104148
104165: POP
104166: POP
// end ;
104167: PPOPN 2
104169: END
// every 0 0$1 trigger s60 do var i , tmp ;
104170: LD_EXP 149
104174: IFFALSE 104243
104176: GO 104178
104178: DISABLE
104179: LD_INT 0
104181: PPUSH
104182: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104183: LD_ADDR_VAR 0 2
104187: PUSH
104188: LD_INT 22
104190: PUSH
104191: LD_OWVAR 2
104195: PUSH
104196: EMPTY
104197: LIST
104198: LIST
104199: PPUSH
104200: CALL_OW 69
104204: ST_TO_ADDR
// if not tmp then
104205: LD_VAR 0 2
104209: NOT
104210: IFFALSE 104214
// exit ;
104212: GO 104243
// for i in tmp do
104214: LD_ADDR_VAR 0 1
104218: PUSH
104219: LD_VAR 0 2
104223: PUSH
104224: FOR_IN
104225: IFFALSE 104241
// SetLives ( i , 600 ) ;
104227: LD_VAR 0 1
104231: PPUSH
104232: LD_INT 600
104234: PPUSH
104235: CALL_OW 234
104239: GO 104224
104241: POP
104242: POP
// end ;
104243: PPOPN 2
104245: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104246: LD_INT 0
104248: PPUSH
// case cmd of 301 :
104249: LD_VAR 0 1
104253: PUSH
104254: LD_INT 301
104256: DOUBLE
104257: EQUAL
104258: IFTRUE 104262
104260: GO 104294
104262: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104263: LD_VAR 0 6
104267: PPUSH
104268: LD_VAR 0 7
104272: PPUSH
104273: LD_VAR 0 8
104277: PPUSH
104278: LD_VAR 0 4
104282: PPUSH
104283: LD_VAR 0 5
104287: PPUSH
104288: CALL 105495 0 5
104292: GO 104415
104294: LD_INT 302
104296: DOUBLE
104297: EQUAL
104298: IFTRUE 104302
104300: GO 104339
104302: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104303: LD_VAR 0 6
104307: PPUSH
104308: LD_VAR 0 7
104312: PPUSH
104313: LD_VAR 0 8
104317: PPUSH
104318: LD_VAR 0 9
104322: PPUSH
104323: LD_VAR 0 4
104327: PPUSH
104328: LD_VAR 0 5
104332: PPUSH
104333: CALL 105586 0 6
104337: GO 104415
104339: LD_INT 303
104341: DOUBLE
104342: EQUAL
104343: IFTRUE 104347
104345: GO 104384
104347: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104348: LD_VAR 0 6
104352: PPUSH
104353: LD_VAR 0 7
104357: PPUSH
104358: LD_VAR 0 8
104362: PPUSH
104363: LD_VAR 0 9
104367: PPUSH
104368: LD_VAR 0 4
104372: PPUSH
104373: LD_VAR 0 5
104377: PPUSH
104378: CALL 104420 0 6
104382: GO 104415
104384: LD_INT 304
104386: DOUBLE
104387: EQUAL
104388: IFTRUE 104392
104390: GO 104414
104392: POP
// hHackTeleport ( unit , x , y ) ; end ;
104393: LD_VAR 0 2
104397: PPUSH
104398: LD_VAR 0 4
104402: PPUSH
104403: LD_VAR 0 5
104407: PPUSH
104408: CALL 106179 0 3
104412: GO 104415
104414: POP
// end ;
104415: LD_VAR 0 12
104419: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104420: LD_INT 0
104422: PPUSH
104423: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104424: LD_VAR 0 1
104428: PUSH
104429: LD_INT 1
104431: LESS
104432: PUSH
104433: LD_VAR 0 1
104437: PUSH
104438: LD_INT 3
104440: GREATER
104441: OR
104442: PUSH
104443: LD_VAR 0 5
104447: PPUSH
104448: LD_VAR 0 6
104452: PPUSH
104453: CALL_OW 428
104457: OR
104458: IFFALSE 104462
// exit ;
104460: GO 105182
// uc_side := your_side ;
104462: LD_ADDR_OWVAR 20
104466: PUSH
104467: LD_OWVAR 2
104471: ST_TO_ADDR
// uc_nation := nation ;
104472: LD_ADDR_OWVAR 21
104476: PUSH
104477: LD_VAR 0 1
104481: ST_TO_ADDR
// bc_level = 1 ;
104482: LD_ADDR_OWVAR 43
104486: PUSH
104487: LD_INT 1
104489: ST_TO_ADDR
// case btype of 1 :
104490: LD_VAR 0 2
104494: PUSH
104495: LD_INT 1
104497: DOUBLE
104498: EQUAL
104499: IFTRUE 104503
104501: GO 104514
104503: POP
// bc_type := b_depot ; 2 :
104504: LD_ADDR_OWVAR 42
104508: PUSH
104509: LD_INT 0
104511: ST_TO_ADDR
104512: GO 105126
104514: LD_INT 2
104516: DOUBLE
104517: EQUAL
104518: IFTRUE 104522
104520: GO 104533
104522: POP
// bc_type := b_warehouse ; 3 :
104523: LD_ADDR_OWVAR 42
104527: PUSH
104528: LD_INT 1
104530: ST_TO_ADDR
104531: GO 105126
104533: LD_INT 3
104535: DOUBLE
104536: EQUAL
104537: IFTRUE 104541
104539: GO 104552
104541: POP
// bc_type := b_lab ; 4 .. 9 :
104542: LD_ADDR_OWVAR 42
104546: PUSH
104547: LD_INT 6
104549: ST_TO_ADDR
104550: GO 105126
104552: LD_INT 4
104554: DOUBLE
104555: GREATEREQUAL
104556: IFFALSE 104564
104558: LD_INT 9
104560: DOUBLE
104561: LESSEQUAL
104562: IFTRUE 104566
104564: GO 104618
104566: POP
// begin bc_type := b_lab_half ;
104567: LD_ADDR_OWVAR 42
104571: PUSH
104572: LD_INT 7
104574: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104575: LD_ADDR_OWVAR 44
104579: PUSH
104580: LD_INT 10
104582: PUSH
104583: LD_INT 11
104585: PUSH
104586: LD_INT 12
104588: PUSH
104589: LD_INT 15
104591: PUSH
104592: LD_INT 14
104594: PUSH
104595: LD_INT 13
104597: PUSH
104598: EMPTY
104599: LIST
104600: LIST
104601: LIST
104602: LIST
104603: LIST
104604: LIST
104605: PUSH
104606: LD_VAR 0 2
104610: PUSH
104611: LD_INT 3
104613: MINUS
104614: ARRAY
104615: ST_TO_ADDR
// end ; 10 .. 13 :
104616: GO 105126
104618: LD_INT 10
104620: DOUBLE
104621: GREATEREQUAL
104622: IFFALSE 104630
104624: LD_INT 13
104626: DOUBLE
104627: LESSEQUAL
104628: IFTRUE 104632
104630: GO 104709
104632: POP
// begin bc_type := b_lab_full ;
104633: LD_ADDR_OWVAR 42
104637: PUSH
104638: LD_INT 8
104640: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104641: LD_ADDR_OWVAR 44
104645: PUSH
104646: LD_INT 10
104648: PUSH
104649: LD_INT 12
104651: PUSH
104652: LD_INT 14
104654: PUSH
104655: LD_INT 13
104657: PUSH
104658: EMPTY
104659: LIST
104660: LIST
104661: LIST
104662: LIST
104663: PUSH
104664: LD_VAR 0 2
104668: PUSH
104669: LD_INT 9
104671: MINUS
104672: ARRAY
104673: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104674: LD_ADDR_OWVAR 45
104678: PUSH
104679: LD_INT 11
104681: PUSH
104682: LD_INT 15
104684: PUSH
104685: LD_INT 12
104687: PUSH
104688: LD_INT 15
104690: PUSH
104691: EMPTY
104692: LIST
104693: LIST
104694: LIST
104695: LIST
104696: PUSH
104697: LD_VAR 0 2
104701: PUSH
104702: LD_INT 9
104704: MINUS
104705: ARRAY
104706: ST_TO_ADDR
// end ; 14 :
104707: GO 105126
104709: LD_INT 14
104711: DOUBLE
104712: EQUAL
104713: IFTRUE 104717
104715: GO 104728
104717: POP
// bc_type := b_workshop ; 15 :
104718: LD_ADDR_OWVAR 42
104722: PUSH
104723: LD_INT 2
104725: ST_TO_ADDR
104726: GO 105126
104728: LD_INT 15
104730: DOUBLE
104731: EQUAL
104732: IFTRUE 104736
104734: GO 104747
104736: POP
// bc_type := b_factory ; 16 :
104737: LD_ADDR_OWVAR 42
104741: PUSH
104742: LD_INT 3
104744: ST_TO_ADDR
104745: GO 105126
104747: LD_INT 16
104749: DOUBLE
104750: EQUAL
104751: IFTRUE 104755
104753: GO 104766
104755: POP
// bc_type := b_ext_gun ; 17 :
104756: LD_ADDR_OWVAR 42
104760: PUSH
104761: LD_INT 17
104763: ST_TO_ADDR
104764: GO 105126
104766: LD_INT 17
104768: DOUBLE
104769: EQUAL
104770: IFTRUE 104774
104772: GO 104802
104774: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104775: LD_ADDR_OWVAR 42
104779: PUSH
104780: LD_INT 19
104782: PUSH
104783: LD_INT 23
104785: PUSH
104786: LD_INT 19
104788: PUSH
104789: EMPTY
104790: LIST
104791: LIST
104792: LIST
104793: PUSH
104794: LD_VAR 0 1
104798: ARRAY
104799: ST_TO_ADDR
104800: GO 105126
104802: LD_INT 18
104804: DOUBLE
104805: EQUAL
104806: IFTRUE 104810
104808: GO 104821
104810: POP
// bc_type := b_ext_radar ; 19 :
104811: LD_ADDR_OWVAR 42
104815: PUSH
104816: LD_INT 20
104818: ST_TO_ADDR
104819: GO 105126
104821: LD_INT 19
104823: DOUBLE
104824: EQUAL
104825: IFTRUE 104829
104827: GO 104840
104829: POP
// bc_type := b_ext_radio ; 20 :
104830: LD_ADDR_OWVAR 42
104834: PUSH
104835: LD_INT 22
104837: ST_TO_ADDR
104838: GO 105126
104840: LD_INT 20
104842: DOUBLE
104843: EQUAL
104844: IFTRUE 104848
104846: GO 104859
104848: POP
// bc_type := b_ext_siberium ; 21 :
104849: LD_ADDR_OWVAR 42
104853: PUSH
104854: LD_INT 21
104856: ST_TO_ADDR
104857: GO 105126
104859: LD_INT 21
104861: DOUBLE
104862: EQUAL
104863: IFTRUE 104867
104865: GO 104878
104867: POP
// bc_type := b_ext_computer ; 22 :
104868: LD_ADDR_OWVAR 42
104872: PUSH
104873: LD_INT 24
104875: ST_TO_ADDR
104876: GO 105126
104878: LD_INT 22
104880: DOUBLE
104881: EQUAL
104882: IFTRUE 104886
104884: GO 104897
104886: POP
// bc_type := b_ext_track ; 23 :
104887: LD_ADDR_OWVAR 42
104891: PUSH
104892: LD_INT 16
104894: ST_TO_ADDR
104895: GO 105126
104897: LD_INT 23
104899: DOUBLE
104900: EQUAL
104901: IFTRUE 104905
104903: GO 104916
104905: POP
// bc_type := b_ext_laser ; 24 :
104906: LD_ADDR_OWVAR 42
104910: PUSH
104911: LD_INT 25
104913: ST_TO_ADDR
104914: GO 105126
104916: LD_INT 24
104918: DOUBLE
104919: EQUAL
104920: IFTRUE 104924
104922: GO 104935
104924: POP
// bc_type := b_control_tower ; 25 :
104925: LD_ADDR_OWVAR 42
104929: PUSH
104930: LD_INT 36
104932: ST_TO_ADDR
104933: GO 105126
104935: LD_INT 25
104937: DOUBLE
104938: EQUAL
104939: IFTRUE 104943
104941: GO 104954
104943: POP
// bc_type := b_breastwork ; 26 :
104944: LD_ADDR_OWVAR 42
104948: PUSH
104949: LD_INT 31
104951: ST_TO_ADDR
104952: GO 105126
104954: LD_INT 26
104956: DOUBLE
104957: EQUAL
104958: IFTRUE 104962
104960: GO 104973
104962: POP
// bc_type := b_bunker ; 27 :
104963: LD_ADDR_OWVAR 42
104967: PUSH
104968: LD_INT 32
104970: ST_TO_ADDR
104971: GO 105126
104973: LD_INT 27
104975: DOUBLE
104976: EQUAL
104977: IFTRUE 104981
104979: GO 104992
104981: POP
// bc_type := b_turret ; 28 :
104982: LD_ADDR_OWVAR 42
104986: PUSH
104987: LD_INT 33
104989: ST_TO_ADDR
104990: GO 105126
104992: LD_INT 28
104994: DOUBLE
104995: EQUAL
104996: IFTRUE 105000
104998: GO 105011
105000: POP
// bc_type := b_armoury ; 29 :
105001: LD_ADDR_OWVAR 42
105005: PUSH
105006: LD_INT 4
105008: ST_TO_ADDR
105009: GO 105126
105011: LD_INT 29
105013: DOUBLE
105014: EQUAL
105015: IFTRUE 105019
105017: GO 105030
105019: POP
// bc_type := b_barracks ; 30 :
105020: LD_ADDR_OWVAR 42
105024: PUSH
105025: LD_INT 5
105027: ST_TO_ADDR
105028: GO 105126
105030: LD_INT 30
105032: DOUBLE
105033: EQUAL
105034: IFTRUE 105038
105036: GO 105049
105038: POP
// bc_type := b_solar_power ; 31 :
105039: LD_ADDR_OWVAR 42
105043: PUSH
105044: LD_INT 27
105046: ST_TO_ADDR
105047: GO 105126
105049: LD_INT 31
105051: DOUBLE
105052: EQUAL
105053: IFTRUE 105057
105055: GO 105068
105057: POP
// bc_type := b_oil_power ; 32 :
105058: LD_ADDR_OWVAR 42
105062: PUSH
105063: LD_INT 26
105065: ST_TO_ADDR
105066: GO 105126
105068: LD_INT 32
105070: DOUBLE
105071: EQUAL
105072: IFTRUE 105076
105074: GO 105087
105076: POP
// bc_type := b_siberite_power ; 33 :
105077: LD_ADDR_OWVAR 42
105081: PUSH
105082: LD_INT 28
105084: ST_TO_ADDR
105085: GO 105126
105087: LD_INT 33
105089: DOUBLE
105090: EQUAL
105091: IFTRUE 105095
105093: GO 105106
105095: POP
// bc_type := b_oil_mine ; 34 :
105096: LD_ADDR_OWVAR 42
105100: PUSH
105101: LD_INT 29
105103: ST_TO_ADDR
105104: GO 105126
105106: LD_INT 34
105108: DOUBLE
105109: EQUAL
105110: IFTRUE 105114
105112: GO 105125
105114: POP
// bc_type := b_siberite_mine ; end ;
105115: LD_ADDR_OWVAR 42
105119: PUSH
105120: LD_INT 30
105122: ST_TO_ADDR
105123: GO 105126
105125: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105126: LD_ADDR_VAR 0 8
105130: PUSH
105131: LD_VAR 0 5
105135: PPUSH
105136: LD_VAR 0 6
105140: PPUSH
105141: LD_VAR 0 3
105145: PPUSH
105146: CALL_OW 47
105150: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105151: LD_OWVAR 42
105155: PUSH
105156: LD_INT 32
105158: PUSH
105159: LD_INT 33
105161: PUSH
105162: EMPTY
105163: LIST
105164: LIST
105165: IN
105166: IFFALSE 105182
// PlaceWeaponTurret ( b , weapon ) ;
105168: LD_VAR 0 8
105172: PPUSH
105173: LD_VAR 0 4
105177: PPUSH
105178: CALL_OW 431
// end ;
105182: LD_VAR 0 7
105186: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105187: LD_INT 0
105189: PPUSH
105190: PPUSH
105191: PPUSH
105192: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105193: LD_ADDR_VAR 0 4
105197: PUSH
105198: LD_INT 22
105200: PUSH
105201: LD_OWVAR 2
105205: PUSH
105206: EMPTY
105207: LIST
105208: LIST
105209: PUSH
105210: LD_INT 2
105212: PUSH
105213: LD_INT 30
105215: PUSH
105216: LD_INT 0
105218: PUSH
105219: EMPTY
105220: LIST
105221: LIST
105222: PUSH
105223: LD_INT 30
105225: PUSH
105226: LD_INT 1
105228: PUSH
105229: EMPTY
105230: LIST
105231: LIST
105232: PUSH
105233: EMPTY
105234: LIST
105235: LIST
105236: LIST
105237: PUSH
105238: EMPTY
105239: LIST
105240: LIST
105241: PPUSH
105242: CALL_OW 69
105246: ST_TO_ADDR
// if not tmp then
105247: LD_VAR 0 4
105251: NOT
105252: IFFALSE 105256
// exit ;
105254: GO 105315
// for i in tmp do
105256: LD_ADDR_VAR 0 2
105260: PUSH
105261: LD_VAR 0 4
105265: PUSH
105266: FOR_IN
105267: IFFALSE 105313
// for j = 1 to 3 do
105269: LD_ADDR_VAR 0 3
105273: PUSH
105274: DOUBLE
105275: LD_INT 1
105277: DEC
105278: ST_TO_ADDR
105279: LD_INT 3
105281: PUSH
105282: FOR_TO
105283: IFFALSE 105309
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105285: LD_VAR 0 2
105289: PPUSH
105290: CALL_OW 274
105294: PPUSH
105295: LD_VAR 0 3
105299: PPUSH
105300: LD_INT 99999
105302: PPUSH
105303: CALL_OW 277
105307: GO 105282
105309: POP
105310: POP
105311: GO 105266
105313: POP
105314: POP
// end ;
105315: LD_VAR 0 1
105319: RET
// export function hHackSetLevel10 ; var i , j ; begin
105320: LD_INT 0
105322: PPUSH
105323: PPUSH
105324: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105325: LD_ADDR_VAR 0 2
105329: PUSH
105330: LD_INT 21
105332: PUSH
105333: LD_INT 1
105335: PUSH
105336: EMPTY
105337: LIST
105338: LIST
105339: PPUSH
105340: CALL_OW 69
105344: PUSH
105345: FOR_IN
105346: IFFALSE 105398
// if IsSelected ( i ) then
105348: LD_VAR 0 2
105352: PPUSH
105353: CALL_OW 306
105357: IFFALSE 105396
// begin for j := 1 to 4 do
105359: LD_ADDR_VAR 0 3
105363: PUSH
105364: DOUBLE
105365: LD_INT 1
105367: DEC
105368: ST_TO_ADDR
105369: LD_INT 4
105371: PUSH
105372: FOR_TO
105373: IFFALSE 105394
// SetSkill ( i , j , 10 ) ;
105375: LD_VAR 0 2
105379: PPUSH
105380: LD_VAR 0 3
105384: PPUSH
105385: LD_INT 10
105387: PPUSH
105388: CALL_OW 237
105392: GO 105372
105394: POP
105395: POP
// end ;
105396: GO 105345
105398: POP
105399: POP
// end ;
105400: LD_VAR 0 1
105404: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105405: LD_INT 0
105407: PPUSH
105408: PPUSH
105409: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105410: LD_ADDR_VAR 0 2
105414: PUSH
105415: LD_INT 22
105417: PUSH
105418: LD_OWVAR 2
105422: PUSH
105423: EMPTY
105424: LIST
105425: LIST
105426: PUSH
105427: LD_INT 21
105429: PUSH
105430: LD_INT 1
105432: PUSH
105433: EMPTY
105434: LIST
105435: LIST
105436: PUSH
105437: EMPTY
105438: LIST
105439: LIST
105440: PPUSH
105441: CALL_OW 69
105445: PUSH
105446: FOR_IN
105447: IFFALSE 105488
// begin for j := 1 to 4 do
105449: LD_ADDR_VAR 0 3
105453: PUSH
105454: DOUBLE
105455: LD_INT 1
105457: DEC
105458: ST_TO_ADDR
105459: LD_INT 4
105461: PUSH
105462: FOR_TO
105463: IFFALSE 105484
// SetSkill ( i , j , 10 ) ;
105465: LD_VAR 0 2
105469: PPUSH
105470: LD_VAR 0 3
105474: PPUSH
105475: LD_INT 10
105477: PPUSH
105478: CALL_OW 237
105482: GO 105462
105484: POP
105485: POP
// end ;
105486: GO 105446
105488: POP
105489: POP
// end ;
105490: LD_VAR 0 1
105494: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105495: LD_INT 0
105497: PPUSH
// uc_side := your_side ;
105498: LD_ADDR_OWVAR 20
105502: PUSH
105503: LD_OWVAR 2
105507: ST_TO_ADDR
// uc_nation := nation ;
105508: LD_ADDR_OWVAR 21
105512: PUSH
105513: LD_VAR 0 1
105517: ST_TO_ADDR
// InitHc ;
105518: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105522: LD_INT 0
105524: PPUSH
105525: LD_VAR 0 2
105529: PPUSH
105530: LD_VAR 0 3
105534: PPUSH
105535: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105539: LD_VAR 0 4
105543: PPUSH
105544: LD_VAR 0 5
105548: PPUSH
105549: CALL_OW 428
105553: PUSH
105554: LD_INT 0
105556: EQUAL
105557: IFFALSE 105581
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105559: CALL_OW 44
105563: PPUSH
105564: LD_VAR 0 4
105568: PPUSH
105569: LD_VAR 0 5
105573: PPUSH
105574: LD_INT 1
105576: PPUSH
105577: CALL_OW 48
// end ;
105581: LD_VAR 0 6
105585: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105586: LD_INT 0
105588: PPUSH
105589: PPUSH
// uc_side := your_side ;
105590: LD_ADDR_OWVAR 20
105594: PUSH
105595: LD_OWVAR 2
105599: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105600: LD_VAR 0 1
105604: PUSH
105605: LD_INT 1
105607: PUSH
105608: LD_INT 2
105610: PUSH
105611: LD_INT 3
105613: PUSH
105614: LD_INT 4
105616: PUSH
105617: LD_INT 5
105619: PUSH
105620: EMPTY
105621: LIST
105622: LIST
105623: LIST
105624: LIST
105625: LIST
105626: IN
105627: IFFALSE 105639
// uc_nation := nation_american else
105629: LD_ADDR_OWVAR 21
105633: PUSH
105634: LD_INT 1
105636: ST_TO_ADDR
105637: GO 105682
// if chassis in [ 11 , 12 , 13 , 14 ] then
105639: LD_VAR 0 1
105643: PUSH
105644: LD_INT 11
105646: PUSH
105647: LD_INT 12
105649: PUSH
105650: LD_INT 13
105652: PUSH
105653: LD_INT 14
105655: PUSH
105656: EMPTY
105657: LIST
105658: LIST
105659: LIST
105660: LIST
105661: IN
105662: IFFALSE 105674
// uc_nation := nation_arabian else
105664: LD_ADDR_OWVAR 21
105668: PUSH
105669: LD_INT 2
105671: ST_TO_ADDR
105672: GO 105682
// uc_nation := nation_russian ;
105674: LD_ADDR_OWVAR 21
105678: PUSH
105679: LD_INT 3
105681: ST_TO_ADDR
// vc_chassis := chassis ;
105682: LD_ADDR_OWVAR 37
105686: PUSH
105687: LD_VAR 0 1
105691: ST_TO_ADDR
// vc_engine := engine ;
105692: LD_ADDR_OWVAR 39
105696: PUSH
105697: LD_VAR 0 2
105701: ST_TO_ADDR
// vc_control := control ;
105702: LD_ADDR_OWVAR 38
105706: PUSH
105707: LD_VAR 0 3
105711: ST_TO_ADDR
// vc_weapon := weapon ;
105712: LD_ADDR_OWVAR 40
105716: PUSH
105717: LD_VAR 0 4
105721: ST_TO_ADDR
// un := CreateVehicle ;
105722: LD_ADDR_VAR 0 8
105726: PUSH
105727: CALL_OW 45
105731: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105732: LD_VAR 0 8
105736: PPUSH
105737: LD_INT 0
105739: PPUSH
105740: LD_INT 5
105742: PPUSH
105743: CALL_OW 12
105747: PPUSH
105748: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105752: LD_VAR 0 8
105756: PPUSH
105757: LD_VAR 0 5
105761: PPUSH
105762: LD_VAR 0 6
105766: PPUSH
105767: LD_INT 1
105769: PPUSH
105770: CALL_OW 48
// end ;
105774: LD_VAR 0 7
105778: RET
// export hInvincible ; every 1 do
105779: GO 105781
105781: DISABLE
// hInvincible := [ ] ;
105782: LD_ADDR_EXP 150
105786: PUSH
105787: EMPTY
105788: ST_TO_ADDR
105789: END
// every 10 do var i ;
105790: GO 105792
105792: DISABLE
105793: LD_INT 0
105795: PPUSH
// begin enable ;
105796: ENABLE
// if not hInvincible then
105797: LD_EXP 150
105801: NOT
105802: IFFALSE 105806
// exit ;
105804: GO 105850
// for i in hInvincible do
105806: LD_ADDR_VAR 0 1
105810: PUSH
105811: LD_EXP 150
105815: PUSH
105816: FOR_IN
105817: IFFALSE 105848
// if GetLives ( i ) < 1000 then
105819: LD_VAR 0 1
105823: PPUSH
105824: CALL_OW 256
105828: PUSH
105829: LD_INT 1000
105831: LESS
105832: IFFALSE 105846
// SetLives ( i , 1000 ) ;
105834: LD_VAR 0 1
105838: PPUSH
105839: LD_INT 1000
105841: PPUSH
105842: CALL_OW 234
105846: GO 105816
105848: POP
105849: POP
// end ;
105850: PPOPN 1
105852: END
// export function hHackInvincible ; var i ; begin
105853: LD_INT 0
105855: PPUSH
105856: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
105857: LD_ADDR_VAR 0 2
105861: PUSH
105862: LD_INT 2
105864: PUSH
105865: LD_INT 21
105867: PUSH
105868: LD_INT 1
105870: PUSH
105871: EMPTY
105872: LIST
105873: LIST
105874: PUSH
105875: LD_INT 21
105877: PUSH
105878: LD_INT 2
105880: PUSH
105881: EMPTY
105882: LIST
105883: LIST
105884: PUSH
105885: EMPTY
105886: LIST
105887: LIST
105888: LIST
105889: PPUSH
105890: CALL_OW 69
105894: PUSH
105895: FOR_IN
105896: IFFALSE 105957
// if IsSelected ( i ) then
105898: LD_VAR 0 2
105902: PPUSH
105903: CALL_OW 306
105907: IFFALSE 105955
// begin if i in hInvincible then
105909: LD_VAR 0 2
105913: PUSH
105914: LD_EXP 150
105918: IN
105919: IFFALSE 105939
// hInvincible := hInvincible diff i else
105921: LD_ADDR_EXP 150
105925: PUSH
105926: LD_EXP 150
105930: PUSH
105931: LD_VAR 0 2
105935: DIFF
105936: ST_TO_ADDR
105937: GO 105955
// hInvincible := hInvincible union i ;
105939: LD_ADDR_EXP 150
105943: PUSH
105944: LD_EXP 150
105948: PUSH
105949: LD_VAR 0 2
105953: UNION
105954: ST_TO_ADDR
// end ;
105955: GO 105895
105957: POP
105958: POP
// end ;
105959: LD_VAR 0 1
105963: RET
// export function hHackInvisible ; var i , j ; begin
105964: LD_INT 0
105966: PPUSH
105967: PPUSH
105968: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105969: LD_ADDR_VAR 0 2
105973: PUSH
105974: LD_INT 21
105976: PUSH
105977: LD_INT 1
105979: PUSH
105980: EMPTY
105981: LIST
105982: LIST
105983: PPUSH
105984: CALL_OW 69
105988: PUSH
105989: FOR_IN
105990: IFFALSE 106014
// if IsSelected ( i ) then
105992: LD_VAR 0 2
105996: PPUSH
105997: CALL_OW 306
106001: IFFALSE 106012
// ComForceInvisible ( i ) ;
106003: LD_VAR 0 2
106007: PPUSH
106008: CALL_OW 496
106012: GO 105989
106014: POP
106015: POP
// end ;
106016: LD_VAR 0 1
106020: RET
// export function hHackChangeYourSide ; begin
106021: LD_INT 0
106023: PPUSH
// if your_side = 8 then
106024: LD_OWVAR 2
106028: PUSH
106029: LD_INT 8
106031: EQUAL
106032: IFFALSE 106044
// your_side := 0 else
106034: LD_ADDR_OWVAR 2
106038: PUSH
106039: LD_INT 0
106041: ST_TO_ADDR
106042: GO 106058
// your_side := your_side + 1 ;
106044: LD_ADDR_OWVAR 2
106048: PUSH
106049: LD_OWVAR 2
106053: PUSH
106054: LD_INT 1
106056: PLUS
106057: ST_TO_ADDR
// end ;
106058: LD_VAR 0 1
106062: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106063: LD_INT 0
106065: PPUSH
106066: PPUSH
106067: PPUSH
// for i in all_units do
106068: LD_ADDR_VAR 0 2
106072: PUSH
106073: LD_OWVAR 3
106077: PUSH
106078: FOR_IN
106079: IFFALSE 106157
// if IsSelected ( i ) then
106081: LD_VAR 0 2
106085: PPUSH
106086: CALL_OW 306
106090: IFFALSE 106155
// begin j := GetSide ( i ) ;
106092: LD_ADDR_VAR 0 3
106096: PUSH
106097: LD_VAR 0 2
106101: PPUSH
106102: CALL_OW 255
106106: ST_TO_ADDR
// if j = 8 then
106107: LD_VAR 0 3
106111: PUSH
106112: LD_INT 8
106114: EQUAL
106115: IFFALSE 106127
// j := 0 else
106117: LD_ADDR_VAR 0 3
106121: PUSH
106122: LD_INT 0
106124: ST_TO_ADDR
106125: GO 106141
// j := j + 1 ;
106127: LD_ADDR_VAR 0 3
106131: PUSH
106132: LD_VAR 0 3
106136: PUSH
106137: LD_INT 1
106139: PLUS
106140: ST_TO_ADDR
// SetSide ( i , j ) ;
106141: LD_VAR 0 2
106145: PPUSH
106146: LD_VAR 0 3
106150: PPUSH
106151: CALL_OW 235
// end ;
106155: GO 106078
106157: POP
106158: POP
// end ;
106159: LD_VAR 0 1
106163: RET
// export function hHackFog ; begin
106164: LD_INT 0
106166: PPUSH
// FogOff ( true ) ;
106167: LD_INT 1
106169: PPUSH
106170: CALL_OW 344
// end ;
106174: LD_VAR 0 1
106178: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106179: LD_INT 0
106181: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106182: LD_VAR 0 1
106186: PPUSH
106187: LD_VAR 0 2
106191: PPUSH
106192: LD_VAR 0 3
106196: PPUSH
106197: LD_INT 1
106199: PPUSH
106200: LD_INT 1
106202: PPUSH
106203: CALL_OW 483
// CenterOnXY ( x , y ) ;
106207: LD_VAR 0 2
106211: PPUSH
106212: LD_VAR 0 3
106216: PPUSH
106217: CALL_OW 84
// end ;
106221: LD_VAR 0 4
106225: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106226: LD_INT 0
106228: PPUSH
106229: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106230: LD_VAR 0 1
106234: NOT
106235: PUSH
106236: LD_VAR 0 2
106240: PPUSH
106241: LD_VAR 0 3
106245: PPUSH
106246: CALL_OW 488
106250: NOT
106251: OR
106252: PUSH
106253: LD_VAR 0 1
106257: PPUSH
106258: CALL_OW 266
106262: PUSH
106263: LD_INT 3
106265: NONEQUAL
106266: PUSH
106267: LD_VAR 0 1
106271: PPUSH
106272: CALL_OW 247
106276: PUSH
106277: LD_INT 1
106279: EQUAL
106280: NOT
106281: AND
106282: OR
106283: IFFALSE 106287
// exit ;
106285: GO 106436
// if GetType ( factory ) = unit_human then
106287: LD_VAR 0 1
106291: PPUSH
106292: CALL_OW 247
106296: PUSH
106297: LD_INT 1
106299: EQUAL
106300: IFFALSE 106317
// factory := IsInUnit ( factory ) ;
106302: LD_ADDR_VAR 0 1
106306: PUSH
106307: LD_VAR 0 1
106311: PPUSH
106312: CALL_OW 310
106316: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106317: LD_VAR 0 1
106321: PPUSH
106322: CALL_OW 266
106326: PUSH
106327: LD_INT 3
106329: NONEQUAL
106330: IFFALSE 106334
// exit ;
106332: GO 106436
// if HexInfo ( x , y ) = factory then
106334: LD_VAR 0 2
106338: PPUSH
106339: LD_VAR 0 3
106343: PPUSH
106344: CALL_OW 428
106348: PUSH
106349: LD_VAR 0 1
106353: EQUAL
106354: IFFALSE 106381
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
106356: LD_ADDR_EXP 151
106360: PUSH
106361: LD_EXP 151
106365: PPUSH
106366: LD_VAR 0 1
106370: PPUSH
106371: LD_INT 0
106373: PPUSH
106374: CALL_OW 1
106378: ST_TO_ADDR
106379: GO 106432
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
106381: LD_ADDR_EXP 151
106385: PUSH
106386: LD_EXP 151
106390: PPUSH
106391: LD_VAR 0 1
106395: PPUSH
106396: LD_VAR 0 1
106400: PPUSH
106401: CALL_OW 255
106405: PUSH
106406: LD_VAR 0 1
106410: PUSH
106411: LD_VAR 0 2
106415: PUSH
106416: LD_VAR 0 3
106420: PUSH
106421: EMPTY
106422: LIST
106423: LIST
106424: LIST
106425: LIST
106426: PPUSH
106427: CALL_OW 1
106431: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106432: CALL 106441 0 0
// end ;
106436: LD_VAR 0 4
106440: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106441: LD_INT 0
106443: PPUSH
106444: PPUSH
106445: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106446: LD_STRING resetFactoryWaypoint();
106448: PPUSH
106449: CALL_OW 559
// if factoryWaypoints then
106453: LD_EXP 151
106457: IFFALSE 106583
// begin list := PrepareArray ( factoryWaypoints ) ;
106459: LD_ADDR_VAR 0 3
106463: PUSH
106464: LD_EXP 151
106468: PPUSH
106469: CALL 61051 0 1
106473: ST_TO_ADDR
// for i := 1 to list do
106474: LD_ADDR_VAR 0 2
106478: PUSH
106479: DOUBLE
106480: LD_INT 1
106482: DEC
106483: ST_TO_ADDR
106484: LD_VAR 0 3
106488: PUSH
106489: FOR_TO
106490: IFFALSE 106581
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106492: LD_STRING setFactoryWaypointXY(
106494: PUSH
106495: LD_VAR 0 3
106499: PUSH
106500: LD_VAR 0 2
106504: ARRAY
106505: PUSH
106506: LD_INT 1
106508: ARRAY
106509: STR
106510: PUSH
106511: LD_STRING ,
106513: STR
106514: PUSH
106515: LD_VAR 0 3
106519: PUSH
106520: LD_VAR 0 2
106524: ARRAY
106525: PUSH
106526: LD_INT 2
106528: ARRAY
106529: STR
106530: PUSH
106531: LD_STRING ,
106533: STR
106534: PUSH
106535: LD_VAR 0 3
106539: PUSH
106540: LD_VAR 0 2
106544: ARRAY
106545: PUSH
106546: LD_INT 3
106548: ARRAY
106549: STR
106550: PUSH
106551: LD_STRING ,
106553: STR
106554: PUSH
106555: LD_VAR 0 3
106559: PUSH
106560: LD_VAR 0 2
106564: ARRAY
106565: PUSH
106566: LD_INT 4
106568: ARRAY
106569: STR
106570: PUSH
106571: LD_STRING )
106573: STR
106574: PPUSH
106575: CALL_OW 559
106579: GO 106489
106581: POP
106582: POP
// end ; end ;
106583: LD_VAR 0 1
106587: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106588: LD_INT 0
106590: PPUSH
// if HexInfo ( x , y ) = warehouse then
106591: LD_VAR 0 2
106595: PPUSH
106596: LD_VAR 0 3
106600: PPUSH
106601: CALL_OW 428
106605: PUSH
106606: LD_VAR 0 1
106610: EQUAL
106611: IFFALSE 106638
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106613: LD_ADDR_EXP 152
106617: PUSH
106618: LD_EXP 152
106622: PPUSH
106623: LD_VAR 0 1
106627: PPUSH
106628: LD_INT 0
106630: PPUSH
106631: CALL_OW 1
106635: ST_TO_ADDR
106636: GO 106689
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106638: LD_ADDR_EXP 152
106642: PUSH
106643: LD_EXP 152
106647: PPUSH
106648: LD_VAR 0 1
106652: PPUSH
106653: LD_VAR 0 1
106657: PPUSH
106658: CALL_OW 255
106662: PUSH
106663: LD_VAR 0 1
106667: PUSH
106668: LD_VAR 0 2
106672: PUSH
106673: LD_VAR 0 3
106677: PUSH
106678: EMPTY
106679: LIST
106680: LIST
106681: LIST
106682: LIST
106683: PPUSH
106684: CALL_OW 1
106688: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106689: CALL 106698 0 0
// end ;
106693: LD_VAR 0 4
106697: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106698: LD_INT 0
106700: PPUSH
106701: PPUSH
106702: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106703: LD_STRING resetWarehouseGatheringPoints();
106705: PPUSH
106706: CALL_OW 559
// if warehouseGatheringPoints then
106710: LD_EXP 152
106714: IFFALSE 106840
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106716: LD_ADDR_VAR 0 3
106720: PUSH
106721: LD_EXP 152
106725: PPUSH
106726: CALL 61051 0 1
106730: ST_TO_ADDR
// for i := 1 to list do
106731: LD_ADDR_VAR 0 2
106735: PUSH
106736: DOUBLE
106737: LD_INT 1
106739: DEC
106740: ST_TO_ADDR
106741: LD_VAR 0 3
106745: PUSH
106746: FOR_TO
106747: IFFALSE 106838
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106749: LD_STRING setWarehouseGatheringPointXY(
106751: PUSH
106752: LD_VAR 0 3
106756: PUSH
106757: LD_VAR 0 2
106761: ARRAY
106762: PUSH
106763: LD_INT 1
106765: ARRAY
106766: STR
106767: PUSH
106768: LD_STRING ,
106770: STR
106771: PUSH
106772: LD_VAR 0 3
106776: PUSH
106777: LD_VAR 0 2
106781: ARRAY
106782: PUSH
106783: LD_INT 2
106785: ARRAY
106786: STR
106787: PUSH
106788: LD_STRING ,
106790: STR
106791: PUSH
106792: LD_VAR 0 3
106796: PUSH
106797: LD_VAR 0 2
106801: ARRAY
106802: PUSH
106803: LD_INT 3
106805: ARRAY
106806: STR
106807: PUSH
106808: LD_STRING ,
106810: STR
106811: PUSH
106812: LD_VAR 0 3
106816: PUSH
106817: LD_VAR 0 2
106821: ARRAY
106822: PUSH
106823: LD_INT 4
106825: ARRAY
106826: STR
106827: PUSH
106828: LD_STRING )
106830: STR
106831: PPUSH
106832: CALL_OW 559
106836: GO 106746
106838: POP
106839: POP
// end ; end ;
106840: LD_VAR 0 1
106844: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
106845: LD_EXP 152
106849: IFFALSE 107536
106851: GO 106853
106853: DISABLE
106854: LD_INT 0
106856: PPUSH
106857: PPUSH
106858: PPUSH
106859: PPUSH
106860: PPUSH
106861: PPUSH
106862: PPUSH
106863: PPUSH
106864: PPUSH
// begin enable ;
106865: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
106866: LD_ADDR_VAR 0 3
106870: PUSH
106871: LD_EXP 152
106875: PPUSH
106876: CALL 61051 0 1
106880: ST_TO_ADDR
// if not list then
106881: LD_VAR 0 3
106885: NOT
106886: IFFALSE 106890
// exit ;
106888: GO 107536
// for i := 1 to list do
106890: LD_ADDR_VAR 0 1
106894: PUSH
106895: DOUBLE
106896: LD_INT 1
106898: DEC
106899: ST_TO_ADDR
106900: LD_VAR 0 3
106904: PUSH
106905: FOR_TO
106906: IFFALSE 107534
// begin depot := list [ i ] [ 2 ] ;
106908: LD_ADDR_VAR 0 8
106912: PUSH
106913: LD_VAR 0 3
106917: PUSH
106918: LD_VAR 0 1
106922: ARRAY
106923: PUSH
106924: LD_INT 2
106926: ARRAY
106927: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
106928: LD_ADDR_VAR 0 5
106932: PUSH
106933: LD_VAR 0 3
106937: PUSH
106938: LD_VAR 0 1
106942: ARRAY
106943: PUSH
106944: LD_INT 1
106946: ARRAY
106947: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
106948: LD_VAR 0 8
106952: PPUSH
106953: CALL_OW 301
106957: PUSH
106958: LD_VAR 0 5
106962: PUSH
106963: LD_VAR 0 8
106967: PPUSH
106968: CALL_OW 255
106972: NONEQUAL
106973: OR
106974: IFFALSE 107003
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
106976: LD_ADDR_EXP 152
106980: PUSH
106981: LD_EXP 152
106985: PPUSH
106986: LD_VAR 0 8
106990: PPUSH
106991: LD_INT 0
106993: PPUSH
106994: CALL_OW 1
106998: ST_TO_ADDR
// exit ;
106999: POP
107000: POP
107001: GO 107536
// end ; x := list [ i ] [ 3 ] ;
107003: LD_ADDR_VAR 0 6
107007: PUSH
107008: LD_VAR 0 3
107012: PUSH
107013: LD_VAR 0 1
107017: ARRAY
107018: PUSH
107019: LD_INT 3
107021: ARRAY
107022: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107023: LD_ADDR_VAR 0 7
107027: PUSH
107028: LD_VAR 0 3
107032: PUSH
107033: LD_VAR 0 1
107037: ARRAY
107038: PUSH
107039: LD_INT 4
107041: ARRAY
107042: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107043: LD_ADDR_VAR 0 9
107047: PUSH
107048: LD_VAR 0 6
107052: PPUSH
107053: LD_VAR 0 7
107057: PPUSH
107058: LD_INT 16
107060: PPUSH
107061: CALL 59635 0 3
107065: ST_TO_ADDR
// if not cratesNearbyPoint then
107066: LD_VAR 0 9
107070: NOT
107071: IFFALSE 107077
// exit ;
107073: POP
107074: POP
107075: GO 107536
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107077: LD_ADDR_VAR 0 4
107081: PUSH
107082: LD_INT 22
107084: PUSH
107085: LD_VAR 0 5
107089: PUSH
107090: EMPTY
107091: LIST
107092: LIST
107093: PUSH
107094: LD_INT 3
107096: PUSH
107097: LD_INT 60
107099: PUSH
107100: EMPTY
107101: LIST
107102: PUSH
107103: EMPTY
107104: LIST
107105: LIST
107106: PUSH
107107: LD_INT 91
107109: PUSH
107110: LD_VAR 0 8
107114: PUSH
107115: LD_INT 6
107117: PUSH
107118: EMPTY
107119: LIST
107120: LIST
107121: LIST
107122: PUSH
107123: LD_INT 2
107125: PUSH
107126: LD_INT 25
107128: PUSH
107129: LD_INT 2
107131: PUSH
107132: EMPTY
107133: LIST
107134: LIST
107135: PUSH
107136: LD_INT 25
107138: PUSH
107139: LD_INT 16
107141: PUSH
107142: EMPTY
107143: LIST
107144: LIST
107145: PUSH
107146: EMPTY
107147: LIST
107148: LIST
107149: LIST
107150: PUSH
107151: EMPTY
107152: LIST
107153: LIST
107154: LIST
107155: LIST
107156: PPUSH
107157: CALL_OW 69
107161: PUSH
107162: LD_VAR 0 8
107166: PPUSH
107167: CALL_OW 313
107171: PPUSH
107172: LD_INT 3
107174: PUSH
107175: LD_INT 60
107177: PUSH
107178: EMPTY
107179: LIST
107180: PUSH
107181: EMPTY
107182: LIST
107183: LIST
107184: PUSH
107185: LD_INT 2
107187: PUSH
107188: LD_INT 25
107190: PUSH
107191: LD_INT 2
107193: PUSH
107194: EMPTY
107195: LIST
107196: LIST
107197: PUSH
107198: LD_INT 25
107200: PUSH
107201: LD_INT 16
107203: PUSH
107204: EMPTY
107205: LIST
107206: LIST
107207: PUSH
107208: EMPTY
107209: LIST
107210: LIST
107211: LIST
107212: PUSH
107213: EMPTY
107214: LIST
107215: LIST
107216: PPUSH
107217: CALL_OW 72
107221: UNION
107222: ST_TO_ADDR
// if tmp then
107223: LD_VAR 0 4
107227: IFFALSE 107307
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107229: LD_ADDR_VAR 0 4
107233: PUSH
107234: LD_VAR 0 4
107238: PPUSH
107239: LD_INT 3
107241: PPUSH
107242: CALL 57602 0 2
107246: ST_TO_ADDR
// for j in tmp do
107247: LD_ADDR_VAR 0 2
107251: PUSH
107252: LD_VAR 0 4
107256: PUSH
107257: FOR_IN
107258: IFFALSE 107301
// begin if IsInUnit ( j ) then
107260: LD_VAR 0 2
107264: PPUSH
107265: CALL_OW 310
107269: IFFALSE 107280
// ComExit ( j ) ;
107271: LD_VAR 0 2
107275: PPUSH
107276: CALL 57685 0 1
// AddComCollect ( j , x , y ) ;
107280: LD_VAR 0 2
107284: PPUSH
107285: LD_VAR 0 6
107289: PPUSH
107290: LD_VAR 0 7
107294: PPUSH
107295: CALL_OW 177
// end ;
107299: GO 107257
107301: POP
107302: POP
// exit ;
107303: POP
107304: POP
107305: GO 107536
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107307: LD_ADDR_VAR 0 4
107311: PUSH
107312: LD_INT 22
107314: PUSH
107315: LD_VAR 0 5
107319: PUSH
107320: EMPTY
107321: LIST
107322: LIST
107323: PUSH
107324: LD_INT 91
107326: PUSH
107327: LD_VAR 0 8
107331: PUSH
107332: LD_INT 8
107334: PUSH
107335: EMPTY
107336: LIST
107337: LIST
107338: LIST
107339: PUSH
107340: LD_INT 2
107342: PUSH
107343: LD_INT 34
107345: PUSH
107346: LD_INT 12
107348: PUSH
107349: EMPTY
107350: LIST
107351: LIST
107352: PUSH
107353: LD_INT 34
107355: PUSH
107356: LD_INT 51
107358: PUSH
107359: EMPTY
107360: LIST
107361: LIST
107362: PUSH
107363: LD_INT 34
107365: PUSH
107366: LD_INT 32
107368: PUSH
107369: EMPTY
107370: LIST
107371: LIST
107372: PUSH
107373: LD_INT 34
107375: PUSH
107376: LD_EXP 30
107380: PUSH
107381: EMPTY
107382: LIST
107383: LIST
107384: PUSH
107385: EMPTY
107386: LIST
107387: LIST
107388: LIST
107389: LIST
107390: LIST
107391: PUSH
107392: EMPTY
107393: LIST
107394: LIST
107395: LIST
107396: PPUSH
107397: CALL_OW 69
107401: ST_TO_ADDR
// if tmp then
107402: LD_VAR 0 4
107406: IFFALSE 107532
// begin for j in tmp do
107408: LD_ADDR_VAR 0 2
107412: PUSH
107413: LD_VAR 0 4
107417: PUSH
107418: FOR_IN
107419: IFFALSE 107530
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107421: LD_VAR 0 2
107425: PPUSH
107426: CALL_OW 262
107430: PUSH
107431: LD_INT 3
107433: EQUAL
107434: PUSH
107435: LD_VAR 0 2
107439: PPUSH
107440: CALL_OW 261
107444: PUSH
107445: LD_INT 20
107447: GREATER
107448: OR
107449: PUSH
107450: LD_VAR 0 2
107454: PPUSH
107455: CALL_OW 314
107459: NOT
107460: AND
107461: PUSH
107462: LD_VAR 0 2
107466: PPUSH
107467: CALL_OW 263
107471: PUSH
107472: LD_INT 1
107474: NONEQUAL
107475: PUSH
107476: LD_VAR 0 2
107480: PPUSH
107481: CALL_OW 311
107485: OR
107486: AND
107487: IFFALSE 107528
// begin ComCollect ( j , x , y ) ;
107489: LD_VAR 0 2
107493: PPUSH
107494: LD_VAR 0 6
107498: PPUSH
107499: LD_VAR 0 7
107503: PPUSH
107504: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107508: LD_VAR 0 2
107512: PPUSH
107513: LD_VAR 0 8
107517: PPUSH
107518: CALL_OW 172
// exit ;
107522: POP
107523: POP
107524: POP
107525: POP
107526: GO 107536
// end ;
107528: GO 107418
107530: POP
107531: POP
// end ; end ;
107532: GO 106905
107534: POP
107535: POP
// end ; end_of_file
107536: PPOPN 9
107538: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107539: LD_INT 0
107541: PPUSH
107542: PPUSH
107543: PPUSH
107544: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107545: LD_VAR 0 1
107549: PPUSH
107550: CALL_OW 264
107554: PUSH
107555: LD_EXP 33
107559: EQUAL
107560: IFFALSE 107632
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107562: LD_INT 68
107564: PPUSH
107565: LD_VAR 0 1
107569: PPUSH
107570: CALL_OW 255
107574: PPUSH
107575: CALL_OW 321
107579: PUSH
107580: LD_INT 2
107582: EQUAL
107583: IFFALSE 107595
// eff := 70 else
107585: LD_ADDR_VAR 0 4
107589: PUSH
107590: LD_INT 70
107592: ST_TO_ADDR
107593: GO 107603
// eff := 30 ;
107595: LD_ADDR_VAR 0 4
107599: PUSH
107600: LD_INT 30
107602: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107603: LD_VAR 0 1
107607: PPUSH
107608: CALL_OW 250
107612: PPUSH
107613: LD_VAR 0 1
107617: PPUSH
107618: CALL_OW 251
107622: PPUSH
107623: LD_VAR 0 4
107627: PPUSH
107628: CALL_OW 495
// end ; end ;
107632: LD_VAR 0 2
107636: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107637: LD_INT 0
107639: PPUSH
// end ;
107640: LD_VAR 0 4
107644: RET
// export function SOS_Command ( cmd ) ; begin
107645: LD_INT 0
107647: PPUSH
// end ;
107648: LD_VAR 0 2
107652: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107653: LD_INT 0
107655: PPUSH
// end ;
107656: LD_VAR 0 6
107660: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107661: LD_INT 0
107663: PPUSH
107664: PPUSH
// if not vehicle or not factory then
107665: LD_VAR 0 1
107669: NOT
107670: PUSH
107671: LD_VAR 0 2
107675: NOT
107676: OR
107677: IFFALSE 107681
// exit ;
107679: GO 107912
// if factoryWaypoints >= factory then
107681: LD_EXP 151
107685: PUSH
107686: LD_VAR 0 2
107690: GREATEREQUAL
107691: IFFALSE 107912
// if factoryWaypoints [ factory ] then
107693: LD_EXP 151
107697: PUSH
107698: LD_VAR 0 2
107702: ARRAY
107703: IFFALSE 107912
// begin if GetControl ( vehicle ) = control_manual then
107705: LD_VAR 0 1
107709: PPUSH
107710: CALL_OW 263
107714: PUSH
107715: LD_INT 1
107717: EQUAL
107718: IFFALSE 107799
// begin driver := IsDrivenBy ( vehicle ) ;
107720: LD_ADDR_VAR 0 4
107724: PUSH
107725: LD_VAR 0 1
107729: PPUSH
107730: CALL_OW 311
107734: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107735: LD_VAR 0 4
107739: PPUSH
107740: LD_EXP 151
107744: PUSH
107745: LD_VAR 0 2
107749: ARRAY
107750: PUSH
107751: LD_INT 3
107753: ARRAY
107754: PPUSH
107755: LD_EXP 151
107759: PUSH
107760: LD_VAR 0 2
107764: ARRAY
107765: PUSH
107766: LD_INT 4
107768: ARRAY
107769: PPUSH
107770: CALL_OW 171
// AddComExitVehicle ( driver ) ;
107774: LD_VAR 0 4
107778: PPUSH
107779: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
107783: LD_VAR 0 4
107787: PPUSH
107788: LD_VAR 0 2
107792: PPUSH
107793: CALL_OW 180
// end else
107797: GO 107912
// if GetControl ( vehicle ) = control_remote then
107799: LD_VAR 0 1
107803: PPUSH
107804: CALL_OW 263
107808: PUSH
107809: LD_INT 2
107811: EQUAL
107812: IFFALSE 107873
// begin wait ( 0 0$2 ) ;
107814: LD_INT 70
107816: PPUSH
107817: CALL_OW 67
// if Connect ( vehicle ) then
107821: LD_VAR 0 1
107825: PPUSH
107826: CALL 27996 0 1
107830: IFFALSE 107871
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107832: LD_VAR 0 1
107836: PPUSH
107837: LD_EXP 151
107841: PUSH
107842: LD_VAR 0 2
107846: ARRAY
107847: PUSH
107848: LD_INT 3
107850: ARRAY
107851: PPUSH
107852: LD_EXP 151
107856: PUSH
107857: LD_VAR 0 2
107861: ARRAY
107862: PUSH
107863: LD_INT 4
107865: ARRAY
107866: PPUSH
107867: CALL_OW 171
// end else
107871: GO 107912
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107873: LD_VAR 0 1
107877: PPUSH
107878: LD_EXP 151
107882: PUSH
107883: LD_VAR 0 2
107887: ARRAY
107888: PUSH
107889: LD_INT 3
107891: ARRAY
107892: PPUSH
107893: LD_EXP 151
107897: PUSH
107898: LD_VAR 0 2
107902: ARRAY
107903: PUSH
107904: LD_INT 4
107906: ARRAY
107907: PPUSH
107908: CALL_OW 171
// end ; end ;
107912: LD_VAR 0 3
107916: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107917: LD_INT 0
107919: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107920: LD_VAR 0 1
107924: PUSH
107925: LD_INT 250
107927: EQUAL
107928: PUSH
107929: LD_VAR 0 2
107933: PPUSH
107934: CALL_OW 264
107938: PUSH
107939: LD_EXP 36
107943: EQUAL
107944: AND
107945: IFFALSE 107966
// MinerPlaceMine ( unit , x , y ) ;
107947: LD_VAR 0 2
107951: PPUSH
107952: LD_VAR 0 4
107956: PPUSH
107957: LD_VAR 0 5
107961: PPUSH
107962: CALL 110365 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107966: LD_VAR 0 1
107970: PUSH
107971: LD_INT 251
107973: EQUAL
107974: PUSH
107975: LD_VAR 0 2
107979: PPUSH
107980: CALL_OW 264
107984: PUSH
107985: LD_EXP 36
107989: EQUAL
107990: AND
107991: IFFALSE 108012
// MinerDetonateMine ( unit , x , y ) ;
107993: LD_VAR 0 2
107997: PPUSH
107998: LD_VAR 0 4
108002: PPUSH
108003: LD_VAR 0 5
108007: PPUSH
108008: CALL 110642 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108012: LD_VAR 0 1
108016: PUSH
108017: LD_INT 252
108019: EQUAL
108020: PUSH
108021: LD_VAR 0 2
108025: PPUSH
108026: CALL_OW 264
108030: PUSH
108031: LD_EXP 36
108035: EQUAL
108036: AND
108037: IFFALSE 108058
// MinerCreateMinefield ( unit , x , y ) ;
108039: LD_VAR 0 2
108043: PPUSH
108044: LD_VAR 0 4
108048: PPUSH
108049: LD_VAR 0 5
108053: PPUSH
108054: CALL 111059 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108058: LD_VAR 0 1
108062: PUSH
108063: LD_INT 253
108065: EQUAL
108066: PUSH
108067: LD_VAR 0 2
108071: PPUSH
108072: CALL_OW 257
108076: PUSH
108077: LD_INT 5
108079: EQUAL
108080: AND
108081: IFFALSE 108102
// ComBinocular ( unit , x , y ) ;
108083: LD_VAR 0 2
108087: PPUSH
108088: LD_VAR 0 4
108092: PPUSH
108093: LD_VAR 0 5
108097: PPUSH
108098: CALL 111430 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108102: LD_VAR 0 1
108106: PUSH
108107: LD_INT 254
108109: EQUAL
108110: PUSH
108111: LD_VAR 0 2
108115: PPUSH
108116: CALL_OW 264
108120: PUSH
108121: LD_EXP 31
108125: EQUAL
108126: AND
108127: PUSH
108128: LD_VAR 0 3
108132: PPUSH
108133: CALL_OW 263
108137: PUSH
108138: LD_INT 3
108140: EQUAL
108141: AND
108142: IFFALSE 108158
// HackDestroyVehicle ( unit , selectedUnit ) ;
108144: LD_VAR 0 2
108148: PPUSH
108149: LD_VAR 0 3
108153: PPUSH
108154: CALL 109725 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108158: LD_VAR 0 1
108162: PUSH
108163: LD_INT 255
108165: EQUAL
108166: PUSH
108167: LD_VAR 0 2
108171: PPUSH
108172: CALL_OW 264
108176: PUSH
108177: LD_INT 14
108179: PUSH
108180: LD_INT 53
108182: PUSH
108183: EMPTY
108184: LIST
108185: LIST
108186: IN
108187: AND
108188: PUSH
108189: LD_VAR 0 4
108193: PPUSH
108194: LD_VAR 0 5
108198: PPUSH
108199: CALL_OW 488
108203: AND
108204: IFFALSE 108228
// CutTreeXYR ( unit , x , y , 12 ) ;
108206: LD_VAR 0 2
108210: PPUSH
108211: LD_VAR 0 4
108215: PPUSH
108216: LD_VAR 0 5
108220: PPUSH
108221: LD_INT 12
108223: PPUSH
108224: CALL 108291 0 4
// if cmd = 256 then
108228: LD_VAR 0 1
108232: PUSH
108233: LD_INT 256
108235: EQUAL
108236: IFFALSE 108257
// SetFactoryWaypoint ( unit , x , y ) ;
108238: LD_VAR 0 2
108242: PPUSH
108243: LD_VAR 0 4
108247: PPUSH
108248: LD_VAR 0 5
108252: PPUSH
108253: CALL 106226 0 3
// if cmd = 257 then
108257: LD_VAR 0 1
108261: PUSH
108262: LD_INT 257
108264: EQUAL
108265: IFFALSE 108286
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108267: LD_VAR 0 2
108271: PPUSH
108272: LD_VAR 0 4
108276: PPUSH
108277: LD_VAR 0 5
108281: PPUSH
108282: CALL 106588 0 3
// end ;
108286: LD_VAR 0 6
108290: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108291: LD_INT 0
108293: PPUSH
108294: PPUSH
108295: PPUSH
108296: PPUSH
108297: PPUSH
108298: PPUSH
108299: PPUSH
108300: PPUSH
108301: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108302: LD_VAR 0 1
108306: NOT
108307: PUSH
108308: LD_VAR 0 2
108312: PPUSH
108313: LD_VAR 0 3
108317: PPUSH
108318: CALL_OW 488
108322: NOT
108323: OR
108324: PUSH
108325: LD_VAR 0 4
108329: NOT
108330: OR
108331: IFFALSE 108335
// exit ;
108333: GO 108675
// list := [ ] ;
108335: LD_ADDR_VAR 0 13
108339: PUSH
108340: EMPTY
108341: ST_TO_ADDR
// if x - r < 0 then
108342: LD_VAR 0 2
108346: PUSH
108347: LD_VAR 0 4
108351: MINUS
108352: PUSH
108353: LD_INT 0
108355: LESS
108356: IFFALSE 108368
// min_x := 0 else
108358: LD_ADDR_VAR 0 7
108362: PUSH
108363: LD_INT 0
108365: ST_TO_ADDR
108366: GO 108384
// min_x := x - r ;
108368: LD_ADDR_VAR 0 7
108372: PUSH
108373: LD_VAR 0 2
108377: PUSH
108378: LD_VAR 0 4
108382: MINUS
108383: ST_TO_ADDR
// if y - r < 0 then
108384: LD_VAR 0 3
108388: PUSH
108389: LD_VAR 0 4
108393: MINUS
108394: PUSH
108395: LD_INT 0
108397: LESS
108398: IFFALSE 108410
// min_y := 0 else
108400: LD_ADDR_VAR 0 8
108404: PUSH
108405: LD_INT 0
108407: ST_TO_ADDR
108408: GO 108426
// min_y := y - r ;
108410: LD_ADDR_VAR 0 8
108414: PUSH
108415: LD_VAR 0 3
108419: PUSH
108420: LD_VAR 0 4
108424: MINUS
108425: ST_TO_ADDR
// max_x := x + r ;
108426: LD_ADDR_VAR 0 9
108430: PUSH
108431: LD_VAR 0 2
108435: PUSH
108436: LD_VAR 0 4
108440: PLUS
108441: ST_TO_ADDR
// max_y := y + r ;
108442: LD_ADDR_VAR 0 10
108446: PUSH
108447: LD_VAR 0 3
108451: PUSH
108452: LD_VAR 0 4
108456: PLUS
108457: ST_TO_ADDR
// for _x = min_x to max_x do
108458: LD_ADDR_VAR 0 11
108462: PUSH
108463: DOUBLE
108464: LD_VAR 0 7
108468: DEC
108469: ST_TO_ADDR
108470: LD_VAR 0 9
108474: PUSH
108475: FOR_TO
108476: IFFALSE 108593
// for _y = min_y to max_y do
108478: LD_ADDR_VAR 0 12
108482: PUSH
108483: DOUBLE
108484: LD_VAR 0 8
108488: DEC
108489: ST_TO_ADDR
108490: LD_VAR 0 10
108494: PUSH
108495: FOR_TO
108496: IFFALSE 108589
// begin if not ValidHex ( _x , _y ) then
108498: LD_VAR 0 11
108502: PPUSH
108503: LD_VAR 0 12
108507: PPUSH
108508: CALL_OW 488
108512: NOT
108513: IFFALSE 108517
// continue ;
108515: GO 108495
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108517: LD_VAR 0 11
108521: PPUSH
108522: LD_VAR 0 12
108526: PPUSH
108527: CALL_OW 351
108531: PUSH
108532: LD_VAR 0 11
108536: PPUSH
108537: LD_VAR 0 12
108541: PPUSH
108542: CALL_OW 554
108546: AND
108547: IFFALSE 108587
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108549: LD_ADDR_VAR 0 13
108553: PUSH
108554: LD_VAR 0 13
108558: PPUSH
108559: LD_VAR 0 13
108563: PUSH
108564: LD_INT 1
108566: PLUS
108567: PPUSH
108568: LD_VAR 0 11
108572: PUSH
108573: LD_VAR 0 12
108577: PUSH
108578: EMPTY
108579: LIST
108580: LIST
108581: PPUSH
108582: CALL_OW 2
108586: ST_TO_ADDR
// end ;
108587: GO 108495
108589: POP
108590: POP
108591: GO 108475
108593: POP
108594: POP
// if not list then
108595: LD_VAR 0 13
108599: NOT
108600: IFFALSE 108604
// exit ;
108602: GO 108675
// for i in list do
108604: LD_ADDR_VAR 0 6
108608: PUSH
108609: LD_VAR 0 13
108613: PUSH
108614: FOR_IN
108615: IFFALSE 108673
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108617: LD_VAR 0 1
108621: PPUSH
108622: LD_STRING M
108624: PUSH
108625: LD_VAR 0 6
108629: PUSH
108630: LD_INT 1
108632: ARRAY
108633: PUSH
108634: LD_VAR 0 6
108638: PUSH
108639: LD_INT 2
108641: ARRAY
108642: PUSH
108643: LD_INT 0
108645: PUSH
108646: LD_INT 0
108648: PUSH
108649: LD_INT 0
108651: PUSH
108652: LD_INT 0
108654: PUSH
108655: EMPTY
108656: LIST
108657: LIST
108658: LIST
108659: LIST
108660: LIST
108661: LIST
108662: LIST
108663: PUSH
108664: EMPTY
108665: LIST
108666: PPUSH
108667: CALL_OW 447
108671: GO 108614
108673: POP
108674: POP
// end ;
108675: LD_VAR 0 5
108679: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108680: LD_EXP 154
108684: NOT
108685: IFFALSE 108735
108687: GO 108689
108689: DISABLE
// begin initHack := true ;
108690: LD_ADDR_EXP 154
108694: PUSH
108695: LD_INT 1
108697: ST_TO_ADDR
// hackTanks := [ ] ;
108698: LD_ADDR_EXP 155
108702: PUSH
108703: EMPTY
108704: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108705: LD_ADDR_EXP 156
108709: PUSH
108710: EMPTY
108711: ST_TO_ADDR
// hackLimit := 3 ;
108712: LD_ADDR_EXP 157
108716: PUSH
108717: LD_INT 3
108719: ST_TO_ADDR
// hackDist := 12 ;
108720: LD_ADDR_EXP 158
108724: PUSH
108725: LD_INT 12
108727: ST_TO_ADDR
// hackCounter := [ ] ;
108728: LD_ADDR_EXP 159
108732: PUSH
108733: EMPTY
108734: ST_TO_ADDR
// end ;
108735: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108736: LD_EXP 154
108740: PUSH
108741: LD_INT 34
108743: PUSH
108744: LD_EXP 31
108748: PUSH
108749: EMPTY
108750: LIST
108751: LIST
108752: PPUSH
108753: CALL_OW 69
108757: AND
108758: IFFALSE 109013
108760: GO 108762
108762: DISABLE
108763: LD_INT 0
108765: PPUSH
108766: PPUSH
// begin enable ;
108767: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108768: LD_ADDR_VAR 0 1
108772: PUSH
108773: LD_INT 34
108775: PUSH
108776: LD_EXP 31
108780: PUSH
108781: EMPTY
108782: LIST
108783: LIST
108784: PPUSH
108785: CALL_OW 69
108789: PUSH
108790: FOR_IN
108791: IFFALSE 109011
// begin if not i in hackTanks then
108793: LD_VAR 0 1
108797: PUSH
108798: LD_EXP 155
108802: IN
108803: NOT
108804: IFFALSE 108887
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108806: LD_ADDR_EXP 155
108810: PUSH
108811: LD_EXP 155
108815: PPUSH
108816: LD_EXP 155
108820: PUSH
108821: LD_INT 1
108823: PLUS
108824: PPUSH
108825: LD_VAR 0 1
108829: PPUSH
108830: CALL_OW 1
108834: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108835: LD_ADDR_EXP 156
108839: PUSH
108840: LD_EXP 156
108844: PPUSH
108845: LD_EXP 156
108849: PUSH
108850: LD_INT 1
108852: PLUS
108853: PPUSH
108854: EMPTY
108855: PPUSH
108856: CALL_OW 1
108860: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108861: LD_ADDR_EXP 159
108865: PUSH
108866: LD_EXP 159
108870: PPUSH
108871: LD_EXP 159
108875: PUSH
108876: LD_INT 1
108878: PLUS
108879: PPUSH
108880: EMPTY
108881: PPUSH
108882: CALL_OW 1
108886: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108887: LD_VAR 0 1
108891: PPUSH
108892: CALL_OW 302
108896: NOT
108897: IFFALSE 108910
// begin HackUnlinkAll ( i ) ;
108899: LD_VAR 0 1
108903: PPUSH
108904: CALL 109016 0 1
// continue ;
108908: GO 108790
// end ; HackCheckCapturedStatus ( i ) ;
108910: LD_VAR 0 1
108914: PPUSH
108915: CALL 109459 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
108919: LD_ADDR_VAR 0 2
108923: PUSH
108924: LD_INT 81
108926: PUSH
108927: LD_VAR 0 1
108931: PPUSH
108932: CALL_OW 255
108936: PUSH
108937: EMPTY
108938: LIST
108939: LIST
108940: PUSH
108941: LD_INT 33
108943: PUSH
108944: LD_INT 3
108946: PUSH
108947: EMPTY
108948: LIST
108949: LIST
108950: PUSH
108951: LD_INT 91
108953: PUSH
108954: LD_VAR 0 1
108958: PUSH
108959: LD_EXP 158
108963: PUSH
108964: EMPTY
108965: LIST
108966: LIST
108967: LIST
108968: PUSH
108969: LD_INT 50
108971: PUSH
108972: EMPTY
108973: LIST
108974: PUSH
108975: EMPTY
108976: LIST
108977: LIST
108978: LIST
108979: LIST
108980: PPUSH
108981: CALL_OW 69
108985: ST_TO_ADDR
// if not tmp then
108986: LD_VAR 0 2
108990: NOT
108991: IFFALSE 108995
// continue ;
108993: GO 108790
// HackLink ( i , tmp ) ;
108995: LD_VAR 0 1
108999: PPUSH
109000: LD_VAR 0 2
109004: PPUSH
109005: CALL 109152 0 2
// end ;
109009: GO 108790
109011: POP
109012: POP
// end ;
109013: PPOPN 2
109015: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109016: LD_INT 0
109018: PPUSH
109019: PPUSH
109020: PPUSH
// if not hack in hackTanks then
109021: LD_VAR 0 1
109025: PUSH
109026: LD_EXP 155
109030: IN
109031: NOT
109032: IFFALSE 109036
// exit ;
109034: GO 109147
// index := GetElementIndex ( hackTanks , hack ) ;
109036: LD_ADDR_VAR 0 4
109040: PUSH
109041: LD_EXP 155
109045: PPUSH
109046: LD_VAR 0 1
109050: PPUSH
109051: CALL 24810 0 2
109055: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109056: LD_EXP 156
109060: PUSH
109061: LD_VAR 0 4
109065: ARRAY
109066: IFFALSE 109147
// begin for i in hackTanksCaptured [ index ] do
109068: LD_ADDR_VAR 0 3
109072: PUSH
109073: LD_EXP 156
109077: PUSH
109078: LD_VAR 0 4
109082: ARRAY
109083: PUSH
109084: FOR_IN
109085: IFFALSE 109111
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109087: LD_VAR 0 3
109091: PUSH
109092: LD_INT 1
109094: ARRAY
109095: PPUSH
109096: LD_VAR 0 3
109100: PUSH
109101: LD_INT 2
109103: ARRAY
109104: PPUSH
109105: CALL_OW 235
109109: GO 109084
109111: POP
109112: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109113: LD_ADDR_EXP 156
109117: PUSH
109118: LD_EXP 156
109122: PPUSH
109123: LD_VAR 0 4
109127: PPUSH
109128: EMPTY
109129: PPUSH
109130: CALL_OW 1
109134: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109135: LD_VAR 0 1
109139: PPUSH
109140: LD_INT 0
109142: PPUSH
109143: CALL_OW 505
// end ; end ;
109147: LD_VAR 0 2
109151: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109152: LD_INT 0
109154: PPUSH
109155: PPUSH
109156: PPUSH
// if not hack in hackTanks or not vehicles then
109157: LD_VAR 0 1
109161: PUSH
109162: LD_EXP 155
109166: IN
109167: NOT
109168: PUSH
109169: LD_VAR 0 2
109173: NOT
109174: OR
109175: IFFALSE 109179
// exit ;
109177: GO 109454
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109179: LD_ADDR_VAR 0 2
109183: PUSH
109184: LD_VAR 0 1
109188: PPUSH
109189: LD_VAR 0 2
109193: PPUSH
109194: LD_INT 1
109196: PPUSH
109197: LD_INT 1
109199: PPUSH
109200: CALL 25460 0 4
109204: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109205: LD_ADDR_VAR 0 5
109209: PUSH
109210: LD_EXP 155
109214: PPUSH
109215: LD_VAR 0 1
109219: PPUSH
109220: CALL 24810 0 2
109224: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109225: LD_EXP 156
109229: PUSH
109230: LD_VAR 0 5
109234: ARRAY
109235: PUSH
109236: LD_EXP 157
109240: LESS
109241: IFFALSE 109430
// begin for i := 1 to vehicles do
109243: LD_ADDR_VAR 0 4
109247: PUSH
109248: DOUBLE
109249: LD_INT 1
109251: DEC
109252: ST_TO_ADDR
109253: LD_VAR 0 2
109257: PUSH
109258: FOR_TO
109259: IFFALSE 109428
// begin if hackTanksCaptured [ index ] = hackLimit then
109261: LD_EXP 156
109265: PUSH
109266: LD_VAR 0 5
109270: ARRAY
109271: PUSH
109272: LD_EXP 157
109276: EQUAL
109277: IFFALSE 109281
// break ;
109279: GO 109428
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109281: LD_ADDR_EXP 159
109285: PUSH
109286: LD_EXP 159
109290: PPUSH
109291: LD_VAR 0 5
109295: PPUSH
109296: LD_EXP 159
109300: PUSH
109301: LD_VAR 0 5
109305: ARRAY
109306: PUSH
109307: LD_INT 1
109309: PLUS
109310: PPUSH
109311: CALL_OW 1
109315: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109316: LD_ADDR_EXP 156
109320: PUSH
109321: LD_EXP 156
109325: PPUSH
109326: LD_VAR 0 5
109330: PUSH
109331: LD_EXP 156
109335: PUSH
109336: LD_VAR 0 5
109340: ARRAY
109341: PUSH
109342: LD_INT 1
109344: PLUS
109345: PUSH
109346: EMPTY
109347: LIST
109348: LIST
109349: PPUSH
109350: LD_VAR 0 2
109354: PUSH
109355: LD_VAR 0 4
109359: ARRAY
109360: PUSH
109361: LD_VAR 0 2
109365: PUSH
109366: LD_VAR 0 4
109370: ARRAY
109371: PPUSH
109372: CALL_OW 255
109376: PUSH
109377: EMPTY
109378: LIST
109379: LIST
109380: PPUSH
109381: CALL 25025 0 3
109385: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109386: LD_VAR 0 2
109390: PUSH
109391: LD_VAR 0 4
109395: ARRAY
109396: PPUSH
109397: LD_VAR 0 1
109401: PPUSH
109402: CALL_OW 255
109406: PPUSH
109407: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109411: LD_VAR 0 2
109415: PUSH
109416: LD_VAR 0 4
109420: ARRAY
109421: PPUSH
109422: CALL_OW 141
// end ;
109426: GO 109258
109428: POP
109429: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109430: LD_VAR 0 1
109434: PPUSH
109435: LD_EXP 156
109439: PUSH
109440: LD_VAR 0 5
109444: ARRAY
109445: PUSH
109446: LD_INT 0
109448: PLUS
109449: PPUSH
109450: CALL_OW 505
// end ;
109454: LD_VAR 0 3
109458: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109459: LD_INT 0
109461: PPUSH
109462: PPUSH
109463: PPUSH
109464: PPUSH
// if not hack in hackTanks then
109465: LD_VAR 0 1
109469: PUSH
109470: LD_EXP 155
109474: IN
109475: NOT
109476: IFFALSE 109480
// exit ;
109478: GO 109720
// index := GetElementIndex ( hackTanks , hack ) ;
109480: LD_ADDR_VAR 0 4
109484: PUSH
109485: LD_EXP 155
109489: PPUSH
109490: LD_VAR 0 1
109494: PPUSH
109495: CALL 24810 0 2
109499: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109500: LD_ADDR_VAR 0 3
109504: PUSH
109505: DOUBLE
109506: LD_EXP 156
109510: PUSH
109511: LD_VAR 0 4
109515: ARRAY
109516: INC
109517: ST_TO_ADDR
109518: LD_INT 1
109520: PUSH
109521: FOR_DOWNTO
109522: IFFALSE 109694
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109524: LD_ADDR_VAR 0 5
109528: PUSH
109529: LD_EXP 156
109533: PUSH
109534: LD_VAR 0 4
109538: ARRAY
109539: PUSH
109540: LD_VAR 0 3
109544: ARRAY
109545: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109546: LD_VAR 0 5
109550: PUSH
109551: LD_INT 1
109553: ARRAY
109554: PPUSH
109555: CALL_OW 302
109559: NOT
109560: PUSH
109561: LD_VAR 0 5
109565: PUSH
109566: LD_INT 1
109568: ARRAY
109569: PPUSH
109570: CALL_OW 255
109574: PUSH
109575: LD_VAR 0 1
109579: PPUSH
109580: CALL_OW 255
109584: NONEQUAL
109585: OR
109586: IFFALSE 109692
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109588: LD_VAR 0 5
109592: PUSH
109593: LD_INT 1
109595: ARRAY
109596: PPUSH
109597: CALL_OW 305
109601: PUSH
109602: LD_VAR 0 5
109606: PUSH
109607: LD_INT 1
109609: ARRAY
109610: PPUSH
109611: CALL_OW 255
109615: PUSH
109616: LD_VAR 0 1
109620: PPUSH
109621: CALL_OW 255
109625: EQUAL
109626: AND
109627: IFFALSE 109651
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109629: LD_VAR 0 5
109633: PUSH
109634: LD_INT 1
109636: ARRAY
109637: PPUSH
109638: LD_VAR 0 5
109642: PUSH
109643: LD_INT 2
109645: ARRAY
109646: PPUSH
109647: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109651: LD_ADDR_EXP 156
109655: PUSH
109656: LD_EXP 156
109660: PPUSH
109661: LD_VAR 0 4
109665: PPUSH
109666: LD_EXP 156
109670: PUSH
109671: LD_VAR 0 4
109675: ARRAY
109676: PPUSH
109677: LD_VAR 0 3
109681: PPUSH
109682: CALL_OW 3
109686: PPUSH
109687: CALL_OW 1
109691: ST_TO_ADDR
// end ; end ;
109692: GO 109521
109694: POP
109695: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109696: LD_VAR 0 1
109700: PPUSH
109701: LD_EXP 156
109705: PUSH
109706: LD_VAR 0 4
109710: ARRAY
109711: PUSH
109712: LD_INT 0
109714: PLUS
109715: PPUSH
109716: CALL_OW 505
// end ;
109720: LD_VAR 0 2
109724: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109725: LD_INT 0
109727: PPUSH
109728: PPUSH
109729: PPUSH
109730: PPUSH
// if not hack in hackTanks then
109731: LD_VAR 0 1
109735: PUSH
109736: LD_EXP 155
109740: IN
109741: NOT
109742: IFFALSE 109746
// exit ;
109744: GO 109831
// index := GetElementIndex ( hackTanks , hack ) ;
109746: LD_ADDR_VAR 0 5
109750: PUSH
109751: LD_EXP 155
109755: PPUSH
109756: LD_VAR 0 1
109760: PPUSH
109761: CALL 24810 0 2
109765: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109766: LD_ADDR_VAR 0 4
109770: PUSH
109771: DOUBLE
109772: LD_INT 1
109774: DEC
109775: ST_TO_ADDR
109776: LD_EXP 156
109780: PUSH
109781: LD_VAR 0 5
109785: ARRAY
109786: PUSH
109787: FOR_TO
109788: IFFALSE 109829
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109790: LD_EXP 156
109794: PUSH
109795: LD_VAR 0 5
109799: ARRAY
109800: PUSH
109801: LD_VAR 0 4
109805: ARRAY
109806: PUSH
109807: LD_INT 1
109809: ARRAY
109810: PUSH
109811: LD_VAR 0 2
109815: EQUAL
109816: IFFALSE 109827
// KillUnit ( vehicle ) ;
109818: LD_VAR 0 2
109822: PPUSH
109823: CALL_OW 66
109827: GO 109787
109829: POP
109830: POP
// end ;
109831: LD_VAR 0 3
109835: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109836: LD_EXP 160
109840: NOT
109841: IFFALSE 109876
109843: GO 109845
109845: DISABLE
// begin initMiner := true ;
109846: LD_ADDR_EXP 160
109850: PUSH
109851: LD_INT 1
109853: ST_TO_ADDR
// minersList := [ ] ;
109854: LD_ADDR_EXP 161
109858: PUSH
109859: EMPTY
109860: ST_TO_ADDR
// minerMinesList := [ ] ;
109861: LD_ADDR_EXP 162
109865: PUSH
109866: EMPTY
109867: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109868: LD_ADDR_EXP 163
109872: PUSH
109873: LD_INT 5
109875: ST_TO_ADDR
// end ;
109876: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109877: LD_EXP 160
109881: PUSH
109882: LD_INT 34
109884: PUSH
109885: LD_EXP 36
109889: PUSH
109890: EMPTY
109891: LIST
109892: LIST
109893: PPUSH
109894: CALL_OW 69
109898: AND
109899: IFFALSE 110362
109901: GO 109903
109903: DISABLE
109904: LD_INT 0
109906: PPUSH
109907: PPUSH
109908: PPUSH
109909: PPUSH
// begin enable ;
109910: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
109911: LD_ADDR_VAR 0 1
109915: PUSH
109916: LD_INT 34
109918: PUSH
109919: LD_EXP 36
109923: PUSH
109924: EMPTY
109925: LIST
109926: LIST
109927: PPUSH
109928: CALL_OW 69
109932: PUSH
109933: FOR_IN
109934: IFFALSE 110006
// begin if not i in minersList then
109936: LD_VAR 0 1
109940: PUSH
109941: LD_EXP 161
109945: IN
109946: NOT
109947: IFFALSE 110004
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
109949: LD_ADDR_EXP 161
109953: PUSH
109954: LD_EXP 161
109958: PPUSH
109959: LD_EXP 161
109963: PUSH
109964: LD_INT 1
109966: PLUS
109967: PPUSH
109968: LD_VAR 0 1
109972: PPUSH
109973: CALL_OW 1
109977: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109978: LD_ADDR_EXP 162
109982: PUSH
109983: LD_EXP 162
109987: PPUSH
109988: LD_EXP 162
109992: PUSH
109993: LD_INT 1
109995: PLUS
109996: PPUSH
109997: EMPTY
109998: PPUSH
109999: CALL_OW 1
110003: ST_TO_ADDR
// end end ;
110004: GO 109933
110006: POP
110007: POP
// for i := minerMinesList downto 1 do
110008: LD_ADDR_VAR 0 1
110012: PUSH
110013: DOUBLE
110014: LD_EXP 162
110018: INC
110019: ST_TO_ADDR
110020: LD_INT 1
110022: PUSH
110023: FOR_DOWNTO
110024: IFFALSE 110360
// begin if IsLive ( minersList [ i ] ) then
110026: LD_EXP 161
110030: PUSH
110031: LD_VAR 0 1
110035: ARRAY
110036: PPUSH
110037: CALL_OW 300
110041: IFFALSE 110069
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110043: LD_EXP 161
110047: PUSH
110048: LD_VAR 0 1
110052: ARRAY
110053: PPUSH
110054: LD_EXP 162
110058: PUSH
110059: LD_VAR 0 1
110063: ARRAY
110064: PPUSH
110065: CALL_OW 505
// if not minerMinesList [ i ] then
110069: LD_EXP 162
110073: PUSH
110074: LD_VAR 0 1
110078: ARRAY
110079: NOT
110080: IFFALSE 110084
// continue ;
110082: GO 110023
// for j := minerMinesList [ i ] downto 1 do
110084: LD_ADDR_VAR 0 2
110088: PUSH
110089: DOUBLE
110090: LD_EXP 162
110094: PUSH
110095: LD_VAR 0 1
110099: ARRAY
110100: INC
110101: ST_TO_ADDR
110102: LD_INT 1
110104: PUSH
110105: FOR_DOWNTO
110106: IFFALSE 110356
// begin side := GetSide ( minersList [ i ] ) ;
110108: LD_ADDR_VAR 0 3
110112: PUSH
110113: LD_EXP 161
110117: PUSH
110118: LD_VAR 0 1
110122: ARRAY
110123: PPUSH
110124: CALL_OW 255
110128: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110129: LD_ADDR_VAR 0 4
110133: PUSH
110134: LD_EXP 162
110138: PUSH
110139: LD_VAR 0 1
110143: ARRAY
110144: PUSH
110145: LD_VAR 0 2
110149: ARRAY
110150: PUSH
110151: LD_INT 1
110153: ARRAY
110154: PPUSH
110155: LD_EXP 162
110159: PUSH
110160: LD_VAR 0 1
110164: ARRAY
110165: PUSH
110166: LD_VAR 0 2
110170: ARRAY
110171: PUSH
110172: LD_INT 2
110174: ARRAY
110175: PPUSH
110176: CALL_OW 428
110180: ST_TO_ADDR
// if not tmp then
110181: LD_VAR 0 4
110185: NOT
110186: IFFALSE 110190
// continue ;
110188: GO 110105
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110190: LD_VAR 0 4
110194: PUSH
110195: LD_INT 81
110197: PUSH
110198: LD_VAR 0 3
110202: PUSH
110203: EMPTY
110204: LIST
110205: LIST
110206: PPUSH
110207: CALL_OW 69
110211: IN
110212: PUSH
110213: LD_EXP 162
110217: PUSH
110218: LD_VAR 0 1
110222: ARRAY
110223: PUSH
110224: LD_VAR 0 2
110228: ARRAY
110229: PUSH
110230: LD_INT 1
110232: ARRAY
110233: PPUSH
110234: LD_EXP 162
110238: PUSH
110239: LD_VAR 0 1
110243: ARRAY
110244: PUSH
110245: LD_VAR 0 2
110249: ARRAY
110250: PUSH
110251: LD_INT 2
110253: ARRAY
110254: PPUSH
110255: CALL_OW 458
110259: AND
110260: IFFALSE 110354
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110262: LD_EXP 162
110266: PUSH
110267: LD_VAR 0 1
110271: ARRAY
110272: PUSH
110273: LD_VAR 0 2
110277: ARRAY
110278: PUSH
110279: LD_INT 1
110281: ARRAY
110282: PPUSH
110283: LD_EXP 162
110287: PUSH
110288: LD_VAR 0 1
110292: ARRAY
110293: PUSH
110294: LD_VAR 0 2
110298: ARRAY
110299: PUSH
110300: LD_INT 2
110302: ARRAY
110303: PPUSH
110304: LD_VAR 0 3
110308: PPUSH
110309: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110313: LD_ADDR_EXP 162
110317: PUSH
110318: LD_EXP 162
110322: PPUSH
110323: LD_VAR 0 1
110327: PPUSH
110328: LD_EXP 162
110332: PUSH
110333: LD_VAR 0 1
110337: ARRAY
110338: PPUSH
110339: LD_VAR 0 2
110343: PPUSH
110344: CALL_OW 3
110348: PPUSH
110349: CALL_OW 1
110353: ST_TO_ADDR
// end ; end ;
110354: GO 110105
110356: POP
110357: POP
// end ;
110358: GO 110023
110360: POP
110361: POP
// end ;
110362: PPOPN 4
110364: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110365: LD_INT 0
110367: PPUSH
110368: PPUSH
// result := false ;
110369: LD_ADDR_VAR 0 4
110373: PUSH
110374: LD_INT 0
110376: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110377: LD_VAR 0 1
110381: PPUSH
110382: CALL_OW 264
110386: PUSH
110387: LD_EXP 36
110391: EQUAL
110392: NOT
110393: IFFALSE 110397
// exit ;
110395: GO 110637
// index := GetElementIndex ( minersList , unit ) ;
110397: LD_ADDR_VAR 0 5
110401: PUSH
110402: LD_EXP 161
110406: PPUSH
110407: LD_VAR 0 1
110411: PPUSH
110412: CALL 24810 0 2
110416: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110417: LD_EXP 162
110421: PUSH
110422: LD_VAR 0 5
110426: ARRAY
110427: PUSH
110428: LD_EXP 163
110432: GREATEREQUAL
110433: IFFALSE 110437
// exit ;
110435: GO 110637
// ComMoveXY ( unit , x , y ) ;
110437: LD_VAR 0 1
110441: PPUSH
110442: LD_VAR 0 2
110446: PPUSH
110447: LD_VAR 0 3
110451: PPUSH
110452: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110456: LD_INT 35
110458: PPUSH
110459: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110463: LD_VAR 0 1
110467: PPUSH
110468: LD_VAR 0 2
110472: PPUSH
110473: LD_VAR 0 3
110477: PPUSH
110478: CALL 56096 0 3
110482: NOT
110483: PUSH
110484: LD_VAR 0 1
110488: PPUSH
110489: CALL_OW 314
110493: AND
110494: IFFALSE 110498
// exit ;
110496: GO 110637
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110498: LD_VAR 0 2
110502: PPUSH
110503: LD_VAR 0 3
110507: PPUSH
110508: CALL_OW 428
110512: PUSH
110513: LD_VAR 0 1
110517: EQUAL
110518: PUSH
110519: LD_VAR 0 1
110523: PPUSH
110524: CALL_OW 314
110528: NOT
110529: AND
110530: IFFALSE 110456
// PlaySoundXY ( x , y , PlantMine ) ;
110532: LD_VAR 0 2
110536: PPUSH
110537: LD_VAR 0 3
110541: PPUSH
110542: LD_STRING PlantMine
110544: PPUSH
110545: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110549: LD_VAR 0 2
110553: PPUSH
110554: LD_VAR 0 3
110558: PPUSH
110559: LD_VAR 0 1
110563: PPUSH
110564: CALL_OW 255
110568: PPUSH
110569: LD_INT 0
110571: PPUSH
110572: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110576: LD_ADDR_EXP 162
110580: PUSH
110581: LD_EXP 162
110585: PPUSH
110586: LD_VAR 0 5
110590: PUSH
110591: LD_EXP 162
110595: PUSH
110596: LD_VAR 0 5
110600: ARRAY
110601: PUSH
110602: LD_INT 1
110604: PLUS
110605: PUSH
110606: EMPTY
110607: LIST
110608: LIST
110609: PPUSH
110610: LD_VAR 0 2
110614: PUSH
110615: LD_VAR 0 3
110619: PUSH
110620: EMPTY
110621: LIST
110622: LIST
110623: PPUSH
110624: CALL 25025 0 3
110628: ST_TO_ADDR
// result := true ;
110629: LD_ADDR_VAR 0 4
110633: PUSH
110634: LD_INT 1
110636: ST_TO_ADDR
// end ;
110637: LD_VAR 0 4
110641: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110642: LD_INT 0
110644: PPUSH
110645: PPUSH
110646: PPUSH
// if not unit in minersList then
110647: LD_VAR 0 1
110651: PUSH
110652: LD_EXP 161
110656: IN
110657: NOT
110658: IFFALSE 110662
// exit ;
110660: GO 111054
// index := GetElementIndex ( minersList , unit ) ;
110662: LD_ADDR_VAR 0 6
110666: PUSH
110667: LD_EXP 161
110671: PPUSH
110672: LD_VAR 0 1
110676: PPUSH
110677: CALL 24810 0 2
110681: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110682: LD_ADDR_VAR 0 5
110686: PUSH
110687: DOUBLE
110688: LD_EXP 162
110692: PUSH
110693: LD_VAR 0 6
110697: ARRAY
110698: INC
110699: ST_TO_ADDR
110700: LD_INT 1
110702: PUSH
110703: FOR_DOWNTO
110704: IFFALSE 110865
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110706: LD_EXP 162
110710: PUSH
110711: LD_VAR 0 6
110715: ARRAY
110716: PUSH
110717: LD_VAR 0 5
110721: ARRAY
110722: PUSH
110723: LD_INT 1
110725: ARRAY
110726: PUSH
110727: LD_VAR 0 2
110731: EQUAL
110732: PUSH
110733: LD_EXP 162
110737: PUSH
110738: LD_VAR 0 6
110742: ARRAY
110743: PUSH
110744: LD_VAR 0 5
110748: ARRAY
110749: PUSH
110750: LD_INT 2
110752: ARRAY
110753: PUSH
110754: LD_VAR 0 3
110758: EQUAL
110759: AND
110760: IFFALSE 110863
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110762: LD_EXP 162
110766: PUSH
110767: LD_VAR 0 6
110771: ARRAY
110772: PUSH
110773: LD_VAR 0 5
110777: ARRAY
110778: PUSH
110779: LD_INT 1
110781: ARRAY
110782: PPUSH
110783: LD_EXP 162
110787: PUSH
110788: LD_VAR 0 6
110792: ARRAY
110793: PUSH
110794: LD_VAR 0 5
110798: ARRAY
110799: PUSH
110800: LD_INT 2
110802: ARRAY
110803: PPUSH
110804: LD_VAR 0 1
110808: PPUSH
110809: CALL_OW 255
110813: PPUSH
110814: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110818: LD_ADDR_EXP 162
110822: PUSH
110823: LD_EXP 162
110827: PPUSH
110828: LD_VAR 0 6
110832: PPUSH
110833: LD_EXP 162
110837: PUSH
110838: LD_VAR 0 6
110842: ARRAY
110843: PPUSH
110844: LD_VAR 0 5
110848: PPUSH
110849: CALL_OW 3
110853: PPUSH
110854: CALL_OW 1
110858: ST_TO_ADDR
// exit ;
110859: POP
110860: POP
110861: GO 111054
// end ; end ;
110863: GO 110703
110865: POP
110866: POP
// for i := minerMinesList [ index ] downto 1 do
110867: LD_ADDR_VAR 0 5
110871: PUSH
110872: DOUBLE
110873: LD_EXP 162
110877: PUSH
110878: LD_VAR 0 6
110882: ARRAY
110883: INC
110884: ST_TO_ADDR
110885: LD_INT 1
110887: PUSH
110888: FOR_DOWNTO
110889: IFFALSE 111052
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110891: LD_EXP 162
110895: PUSH
110896: LD_VAR 0 6
110900: ARRAY
110901: PUSH
110902: LD_VAR 0 5
110906: ARRAY
110907: PUSH
110908: LD_INT 1
110910: ARRAY
110911: PPUSH
110912: LD_EXP 162
110916: PUSH
110917: LD_VAR 0 6
110921: ARRAY
110922: PUSH
110923: LD_VAR 0 5
110927: ARRAY
110928: PUSH
110929: LD_INT 2
110931: ARRAY
110932: PPUSH
110933: LD_VAR 0 2
110937: PPUSH
110938: LD_VAR 0 3
110942: PPUSH
110943: CALL_OW 298
110947: PUSH
110948: LD_INT 6
110950: LESS
110951: IFFALSE 111050
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110953: LD_EXP 162
110957: PUSH
110958: LD_VAR 0 6
110962: ARRAY
110963: PUSH
110964: LD_VAR 0 5
110968: ARRAY
110969: PUSH
110970: LD_INT 1
110972: ARRAY
110973: PPUSH
110974: LD_EXP 162
110978: PUSH
110979: LD_VAR 0 6
110983: ARRAY
110984: PUSH
110985: LD_VAR 0 5
110989: ARRAY
110990: PUSH
110991: LD_INT 2
110993: ARRAY
110994: PPUSH
110995: LD_VAR 0 1
110999: PPUSH
111000: CALL_OW 255
111004: PPUSH
111005: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111009: LD_ADDR_EXP 162
111013: PUSH
111014: LD_EXP 162
111018: PPUSH
111019: LD_VAR 0 6
111023: PPUSH
111024: LD_EXP 162
111028: PUSH
111029: LD_VAR 0 6
111033: ARRAY
111034: PPUSH
111035: LD_VAR 0 5
111039: PPUSH
111040: CALL_OW 3
111044: PPUSH
111045: CALL_OW 1
111049: ST_TO_ADDR
// end ; end ;
111050: GO 110888
111052: POP
111053: POP
// end ;
111054: LD_VAR 0 4
111058: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111059: LD_INT 0
111061: PPUSH
111062: PPUSH
111063: PPUSH
111064: PPUSH
111065: PPUSH
111066: PPUSH
111067: PPUSH
111068: PPUSH
111069: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111070: LD_VAR 0 1
111074: PPUSH
111075: CALL_OW 264
111079: PUSH
111080: LD_EXP 36
111084: EQUAL
111085: NOT
111086: PUSH
111087: LD_VAR 0 1
111091: PUSH
111092: LD_EXP 161
111096: IN
111097: NOT
111098: OR
111099: IFFALSE 111103
// exit ;
111101: GO 111425
// index := GetElementIndex ( minersList , unit ) ;
111103: LD_ADDR_VAR 0 6
111107: PUSH
111108: LD_EXP 161
111112: PPUSH
111113: LD_VAR 0 1
111117: PPUSH
111118: CALL 24810 0 2
111122: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111123: LD_ADDR_VAR 0 8
111127: PUSH
111128: LD_EXP 163
111132: PUSH
111133: LD_EXP 162
111137: PUSH
111138: LD_VAR 0 6
111142: ARRAY
111143: MINUS
111144: ST_TO_ADDR
// if not minesFreeAmount then
111145: LD_VAR 0 8
111149: NOT
111150: IFFALSE 111154
// exit ;
111152: GO 111425
// tmp := [ ] ;
111154: LD_ADDR_VAR 0 7
111158: PUSH
111159: EMPTY
111160: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111161: LD_ADDR_VAR 0 5
111165: PUSH
111166: DOUBLE
111167: LD_INT 1
111169: DEC
111170: ST_TO_ADDR
111171: LD_VAR 0 8
111175: PUSH
111176: FOR_TO
111177: IFFALSE 111372
// begin _d := rand ( 0 , 5 ) ;
111179: LD_ADDR_VAR 0 11
111183: PUSH
111184: LD_INT 0
111186: PPUSH
111187: LD_INT 5
111189: PPUSH
111190: CALL_OW 12
111194: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111195: LD_ADDR_VAR 0 12
111199: PUSH
111200: LD_INT 2
111202: PPUSH
111203: LD_INT 6
111205: PPUSH
111206: CALL_OW 12
111210: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111211: LD_ADDR_VAR 0 9
111215: PUSH
111216: LD_VAR 0 2
111220: PPUSH
111221: LD_VAR 0 11
111225: PPUSH
111226: LD_VAR 0 12
111230: PPUSH
111231: CALL_OW 272
111235: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111236: LD_ADDR_VAR 0 10
111240: PUSH
111241: LD_VAR 0 3
111245: PPUSH
111246: LD_VAR 0 11
111250: PPUSH
111251: LD_VAR 0 12
111255: PPUSH
111256: CALL_OW 273
111260: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111261: LD_VAR 0 9
111265: PPUSH
111266: LD_VAR 0 10
111270: PPUSH
111271: CALL_OW 488
111275: PUSH
111276: LD_VAR 0 9
111280: PUSH
111281: LD_VAR 0 10
111285: PUSH
111286: EMPTY
111287: LIST
111288: LIST
111289: PUSH
111290: LD_VAR 0 7
111294: IN
111295: NOT
111296: AND
111297: PUSH
111298: LD_VAR 0 9
111302: PPUSH
111303: LD_VAR 0 10
111307: PPUSH
111308: CALL_OW 458
111312: NOT
111313: AND
111314: IFFALSE 111356
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111316: LD_ADDR_VAR 0 7
111320: PUSH
111321: LD_VAR 0 7
111325: PPUSH
111326: LD_VAR 0 7
111330: PUSH
111331: LD_INT 1
111333: PLUS
111334: PPUSH
111335: LD_VAR 0 9
111339: PUSH
111340: LD_VAR 0 10
111344: PUSH
111345: EMPTY
111346: LIST
111347: LIST
111348: PPUSH
111349: CALL_OW 1
111353: ST_TO_ADDR
111354: GO 111370
// i := i - 1 ;
111356: LD_ADDR_VAR 0 5
111360: PUSH
111361: LD_VAR 0 5
111365: PUSH
111366: LD_INT 1
111368: MINUS
111369: ST_TO_ADDR
// end ;
111370: GO 111176
111372: POP
111373: POP
// for i in tmp do
111374: LD_ADDR_VAR 0 5
111378: PUSH
111379: LD_VAR 0 7
111383: PUSH
111384: FOR_IN
111385: IFFALSE 111423
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111387: LD_VAR 0 1
111391: PPUSH
111392: LD_VAR 0 5
111396: PUSH
111397: LD_INT 1
111399: ARRAY
111400: PPUSH
111401: LD_VAR 0 5
111405: PUSH
111406: LD_INT 2
111408: ARRAY
111409: PPUSH
111410: CALL 110365 0 3
111414: NOT
111415: IFFALSE 111421
// exit ;
111417: POP
111418: POP
111419: GO 111425
111421: GO 111384
111423: POP
111424: POP
// end ;
111425: LD_VAR 0 4
111429: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111430: LD_INT 0
111432: PPUSH
111433: PPUSH
111434: PPUSH
111435: PPUSH
111436: PPUSH
111437: PPUSH
111438: PPUSH
// if not GetClass ( unit ) = class_sniper then
111439: LD_VAR 0 1
111443: PPUSH
111444: CALL_OW 257
111448: PUSH
111449: LD_INT 5
111451: EQUAL
111452: NOT
111453: IFFALSE 111457
// exit ;
111455: GO 111845
// dist := 8 ;
111457: LD_ADDR_VAR 0 5
111461: PUSH
111462: LD_INT 8
111464: ST_TO_ADDR
// viewRange := 12 ;
111465: LD_ADDR_VAR 0 7
111469: PUSH
111470: LD_INT 12
111472: ST_TO_ADDR
// side := GetSide ( unit ) ;
111473: LD_ADDR_VAR 0 6
111477: PUSH
111478: LD_VAR 0 1
111482: PPUSH
111483: CALL_OW 255
111487: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111488: LD_INT 61
111490: PPUSH
111491: LD_VAR 0 6
111495: PPUSH
111496: CALL_OW 321
111500: PUSH
111501: LD_INT 2
111503: EQUAL
111504: IFFALSE 111514
// viewRange := 16 ;
111506: LD_ADDR_VAR 0 7
111510: PUSH
111511: LD_INT 16
111513: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111514: LD_VAR 0 1
111518: PPUSH
111519: LD_VAR 0 2
111523: PPUSH
111524: LD_VAR 0 3
111528: PPUSH
111529: CALL_OW 297
111533: PUSH
111534: LD_VAR 0 5
111538: GREATER
111539: IFFALSE 111618
// begin ComMoveXY ( unit , x , y ) ;
111541: LD_VAR 0 1
111545: PPUSH
111546: LD_VAR 0 2
111550: PPUSH
111551: LD_VAR 0 3
111555: PPUSH
111556: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111560: LD_INT 35
111562: PPUSH
111563: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111567: LD_VAR 0 1
111571: PPUSH
111572: LD_VAR 0 2
111576: PPUSH
111577: LD_VAR 0 3
111581: PPUSH
111582: CALL 56096 0 3
111586: NOT
111587: IFFALSE 111591
// exit ;
111589: GO 111845
// until GetDistUnitXY ( unit , x , y ) < dist ;
111591: LD_VAR 0 1
111595: PPUSH
111596: LD_VAR 0 2
111600: PPUSH
111601: LD_VAR 0 3
111605: PPUSH
111606: CALL_OW 297
111610: PUSH
111611: LD_VAR 0 5
111615: LESS
111616: IFFALSE 111560
// end ; ComTurnXY ( unit , x , y ) ;
111618: LD_VAR 0 1
111622: PPUSH
111623: LD_VAR 0 2
111627: PPUSH
111628: LD_VAR 0 3
111632: PPUSH
111633: CALL_OW 118
// wait ( 5 ) ;
111637: LD_INT 5
111639: PPUSH
111640: CALL_OW 67
// _d := GetDir ( unit ) ;
111644: LD_ADDR_VAR 0 10
111648: PUSH
111649: LD_VAR 0 1
111653: PPUSH
111654: CALL_OW 254
111658: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111659: LD_ADDR_VAR 0 8
111663: PUSH
111664: LD_VAR 0 1
111668: PPUSH
111669: CALL_OW 250
111673: PPUSH
111674: LD_VAR 0 10
111678: PPUSH
111679: LD_VAR 0 5
111683: PPUSH
111684: CALL_OW 272
111688: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111689: LD_ADDR_VAR 0 9
111693: PUSH
111694: LD_VAR 0 1
111698: PPUSH
111699: CALL_OW 251
111703: PPUSH
111704: LD_VAR 0 10
111708: PPUSH
111709: LD_VAR 0 5
111713: PPUSH
111714: CALL_OW 273
111718: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111719: LD_VAR 0 8
111723: PPUSH
111724: LD_VAR 0 9
111728: PPUSH
111729: CALL_OW 488
111733: NOT
111734: IFFALSE 111738
// exit ;
111736: GO 111845
// ComAnimCustom ( unit , 1 ) ;
111738: LD_VAR 0 1
111742: PPUSH
111743: LD_INT 1
111745: PPUSH
111746: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111750: LD_VAR 0 8
111754: PPUSH
111755: LD_VAR 0 9
111759: PPUSH
111760: LD_VAR 0 6
111764: PPUSH
111765: LD_VAR 0 7
111769: PPUSH
111770: CALL_OW 330
// repeat wait ( 1 ) ;
111774: LD_INT 1
111776: PPUSH
111777: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111781: LD_VAR 0 1
111785: PPUSH
111786: CALL_OW 316
111790: PUSH
111791: LD_VAR 0 1
111795: PPUSH
111796: CALL_OW 314
111800: OR
111801: PUSH
111802: LD_VAR 0 1
111806: PPUSH
111807: CALL_OW 302
111811: NOT
111812: OR
111813: PUSH
111814: LD_VAR 0 1
111818: PPUSH
111819: CALL_OW 301
111823: OR
111824: IFFALSE 111774
// RemoveSeeing ( _x , _y , side ) ;
111826: LD_VAR 0 8
111830: PPUSH
111831: LD_VAR 0 9
111835: PPUSH
111836: LD_VAR 0 6
111840: PPUSH
111841: CALL_OW 331
// end ; end_of_file
111845: LD_VAR 0 4
111849: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
111850: LD_INT 0
111852: PPUSH
111853: PPUSH
111854: PPUSH
111855: PPUSH
111856: PPUSH
111857: PPUSH
111858: PPUSH
111859: PPUSH
111860: PPUSH
111861: PPUSH
111862: PPUSH
111863: PPUSH
111864: PPUSH
111865: PPUSH
111866: PPUSH
111867: PPUSH
111868: PPUSH
111869: PPUSH
111870: PPUSH
111871: PPUSH
111872: PPUSH
111873: PPUSH
111874: PPUSH
111875: PPUSH
111876: PPUSH
111877: PPUSH
111878: PPUSH
111879: PPUSH
111880: PPUSH
111881: PPUSH
111882: PPUSH
111883: PPUSH
111884: PPUSH
111885: PPUSH
// if not list then
111886: LD_VAR 0 1
111890: NOT
111891: IFFALSE 111895
// exit ;
111893: GO 116554
// base := list [ 1 ] ;
111895: LD_ADDR_VAR 0 3
111899: PUSH
111900: LD_VAR 0 1
111904: PUSH
111905: LD_INT 1
111907: ARRAY
111908: ST_TO_ADDR
// group := list [ 2 ] ;
111909: LD_ADDR_VAR 0 4
111913: PUSH
111914: LD_VAR 0 1
111918: PUSH
111919: LD_INT 2
111921: ARRAY
111922: ST_TO_ADDR
// path := list [ 3 ] ;
111923: LD_ADDR_VAR 0 5
111927: PUSH
111928: LD_VAR 0 1
111932: PUSH
111933: LD_INT 3
111935: ARRAY
111936: ST_TO_ADDR
// flags := list [ 4 ] ;
111937: LD_ADDR_VAR 0 6
111941: PUSH
111942: LD_VAR 0 1
111946: PUSH
111947: LD_INT 4
111949: ARRAY
111950: ST_TO_ADDR
// mined := [ ] ;
111951: LD_ADDR_VAR 0 27
111955: PUSH
111956: EMPTY
111957: ST_TO_ADDR
// bombed := [ ] ;
111958: LD_ADDR_VAR 0 28
111962: PUSH
111963: EMPTY
111964: ST_TO_ADDR
// healers := [ ] ;
111965: LD_ADDR_VAR 0 31
111969: PUSH
111970: EMPTY
111971: ST_TO_ADDR
// to_heal := [ ] ;
111972: LD_ADDR_VAR 0 30
111976: PUSH
111977: EMPTY
111978: ST_TO_ADDR
// repairs := [ ] ;
111979: LD_ADDR_VAR 0 33
111983: PUSH
111984: EMPTY
111985: ST_TO_ADDR
// to_repair := [ ] ;
111986: LD_ADDR_VAR 0 32
111990: PUSH
111991: EMPTY
111992: ST_TO_ADDR
// if not group or not path then
111993: LD_VAR 0 4
111997: NOT
111998: PUSH
111999: LD_VAR 0 5
112003: NOT
112004: OR
112005: IFFALSE 112009
// exit ;
112007: GO 116554
// side := GetSide ( group [ 1 ] ) ;
112009: LD_ADDR_VAR 0 35
112013: PUSH
112014: LD_VAR 0 4
112018: PUSH
112019: LD_INT 1
112021: ARRAY
112022: PPUSH
112023: CALL_OW 255
112027: ST_TO_ADDR
// if flags then
112028: LD_VAR 0 6
112032: IFFALSE 112176
// begin f_ignore_area := flags [ 1 ] ;
112034: LD_ADDR_VAR 0 17
112038: PUSH
112039: LD_VAR 0 6
112043: PUSH
112044: LD_INT 1
112046: ARRAY
112047: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112048: LD_ADDR_VAR 0 18
112052: PUSH
112053: LD_VAR 0 6
112057: PUSH
112058: LD_INT 2
112060: ARRAY
112061: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112062: LD_ADDR_VAR 0 19
112066: PUSH
112067: LD_VAR 0 6
112071: PUSH
112072: LD_INT 3
112074: ARRAY
112075: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112076: LD_ADDR_VAR 0 20
112080: PUSH
112081: LD_VAR 0 6
112085: PUSH
112086: LD_INT 4
112088: ARRAY
112089: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112090: LD_ADDR_VAR 0 21
112094: PUSH
112095: LD_VAR 0 6
112099: PUSH
112100: LD_INT 5
112102: ARRAY
112103: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112104: LD_ADDR_VAR 0 22
112108: PUSH
112109: LD_VAR 0 6
112113: PUSH
112114: LD_INT 6
112116: ARRAY
112117: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112118: LD_ADDR_VAR 0 23
112122: PUSH
112123: LD_VAR 0 6
112127: PUSH
112128: LD_INT 7
112130: ARRAY
112131: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112132: LD_ADDR_VAR 0 24
112136: PUSH
112137: LD_VAR 0 6
112141: PUSH
112142: LD_INT 8
112144: ARRAY
112145: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112146: LD_ADDR_VAR 0 25
112150: PUSH
112151: LD_VAR 0 6
112155: PUSH
112156: LD_INT 9
112158: ARRAY
112159: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112160: LD_ADDR_VAR 0 26
112164: PUSH
112165: LD_VAR 0 6
112169: PUSH
112170: LD_INT 10
112172: ARRAY
112173: ST_TO_ADDR
// end else
112174: GO 112256
// begin f_ignore_area := false ;
112176: LD_ADDR_VAR 0 17
112180: PUSH
112181: LD_INT 0
112183: ST_TO_ADDR
// f_capture := false ;
112184: LD_ADDR_VAR 0 18
112188: PUSH
112189: LD_INT 0
112191: ST_TO_ADDR
// f_ignore_civ := false ;
112192: LD_ADDR_VAR 0 19
112196: PUSH
112197: LD_INT 0
112199: ST_TO_ADDR
// f_murder := false ;
112200: LD_ADDR_VAR 0 20
112204: PUSH
112205: LD_INT 0
112207: ST_TO_ADDR
// f_mines := false ;
112208: LD_ADDR_VAR 0 21
112212: PUSH
112213: LD_INT 0
112215: ST_TO_ADDR
// f_repair := false ;
112216: LD_ADDR_VAR 0 22
112220: PUSH
112221: LD_INT 0
112223: ST_TO_ADDR
// f_heal := false ;
112224: LD_ADDR_VAR 0 23
112228: PUSH
112229: LD_INT 0
112231: ST_TO_ADDR
// f_spacetime := false ;
112232: LD_ADDR_VAR 0 24
112236: PUSH
112237: LD_INT 0
112239: ST_TO_ADDR
// f_attack_depot := false ;
112240: LD_ADDR_VAR 0 25
112244: PUSH
112245: LD_INT 0
112247: ST_TO_ADDR
// f_crawl := false ;
112248: LD_ADDR_VAR 0 26
112252: PUSH
112253: LD_INT 0
112255: ST_TO_ADDR
// end ; if f_heal then
112256: LD_VAR 0 23
112260: IFFALSE 112287
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112262: LD_ADDR_VAR 0 31
112266: PUSH
112267: LD_VAR 0 4
112271: PPUSH
112272: LD_INT 25
112274: PUSH
112275: LD_INT 4
112277: PUSH
112278: EMPTY
112279: LIST
112280: LIST
112281: PPUSH
112282: CALL_OW 72
112286: ST_TO_ADDR
// if f_repair then
112287: LD_VAR 0 22
112291: IFFALSE 112318
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112293: LD_ADDR_VAR 0 33
112297: PUSH
112298: LD_VAR 0 4
112302: PPUSH
112303: LD_INT 25
112305: PUSH
112306: LD_INT 3
112308: PUSH
112309: EMPTY
112310: LIST
112311: LIST
112312: PPUSH
112313: CALL_OW 72
112317: ST_TO_ADDR
// units_path := [ ] ;
112318: LD_ADDR_VAR 0 16
112322: PUSH
112323: EMPTY
112324: ST_TO_ADDR
// for i = 1 to group do
112325: LD_ADDR_VAR 0 7
112329: PUSH
112330: DOUBLE
112331: LD_INT 1
112333: DEC
112334: ST_TO_ADDR
112335: LD_VAR 0 4
112339: PUSH
112340: FOR_TO
112341: IFFALSE 112370
// units_path := Replace ( units_path , i , path ) ;
112343: LD_ADDR_VAR 0 16
112347: PUSH
112348: LD_VAR 0 16
112352: PPUSH
112353: LD_VAR 0 7
112357: PPUSH
112358: LD_VAR 0 5
112362: PPUSH
112363: CALL_OW 1
112367: ST_TO_ADDR
112368: GO 112340
112370: POP
112371: POP
// repeat for i = group downto 1 do
112372: LD_ADDR_VAR 0 7
112376: PUSH
112377: DOUBLE
112378: LD_VAR 0 4
112382: INC
112383: ST_TO_ADDR
112384: LD_INT 1
112386: PUSH
112387: FOR_DOWNTO
112388: IFFALSE 116510
// begin wait ( 5 ) ;
112390: LD_INT 5
112392: PPUSH
112393: CALL_OW 67
// tmp := [ ] ;
112397: LD_ADDR_VAR 0 14
112401: PUSH
112402: EMPTY
112403: ST_TO_ADDR
// attacking := false ;
112404: LD_ADDR_VAR 0 29
112408: PUSH
112409: LD_INT 0
112411: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112412: LD_VAR 0 4
112416: PUSH
112417: LD_VAR 0 7
112421: ARRAY
112422: PPUSH
112423: CALL_OW 301
112427: PUSH
112428: LD_VAR 0 4
112432: PUSH
112433: LD_VAR 0 7
112437: ARRAY
112438: NOT
112439: OR
112440: IFFALSE 112549
// begin if GetType ( group [ i ] ) = unit_human then
112442: LD_VAR 0 4
112446: PUSH
112447: LD_VAR 0 7
112451: ARRAY
112452: PPUSH
112453: CALL_OW 247
112457: PUSH
112458: LD_INT 1
112460: EQUAL
112461: IFFALSE 112507
// begin to_heal := to_heal diff group [ i ] ;
112463: LD_ADDR_VAR 0 30
112467: PUSH
112468: LD_VAR 0 30
112472: PUSH
112473: LD_VAR 0 4
112477: PUSH
112478: LD_VAR 0 7
112482: ARRAY
112483: DIFF
112484: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112485: LD_ADDR_VAR 0 31
112489: PUSH
112490: LD_VAR 0 31
112494: PUSH
112495: LD_VAR 0 4
112499: PUSH
112500: LD_VAR 0 7
112504: ARRAY
112505: DIFF
112506: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112507: LD_ADDR_VAR 0 4
112511: PUSH
112512: LD_VAR 0 4
112516: PPUSH
112517: LD_VAR 0 7
112521: PPUSH
112522: CALL_OW 3
112526: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112527: LD_ADDR_VAR 0 16
112531: PUSH
112532: LD_VAR 0 16
112536: PPUSH
112537: LD_VAR 0 7
112541: PPUSH
112542: CALL_OW 3
112546: ST_TO_ADDR
// continue ;
112547: GO 112387
// end ; if f_repair then
112549: LD_VAR 0 22
112553: IFFALSE 113042
// begin if GetType ( group [ i ] ) = unit_vehicle then
112555: LD_VAR 0 4
112559: PUSH
112560: LD_VAR 0 7
112564: ARRAY
112565: PPUSH
112566: CALL_OW 247
112570: PUSH
112571: LD_INT 2
112573: EQUAL
112574: IFFALSE 112764
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112576: LD_VAR 0 4
112580: PUSH
112581: LD_VAR 0 7
112585: ARRAY
112586: PPUSH
112587: CALL_OW 256
112591: PUSH
112592: LD_INT 700
112594: LESS
112595: PUSH
112596: LD_VAR 0 4
112600: PUSH
112601: LD_VAR 0 7
112605: ARRAY
112606: PUSH
112607: LD_VAR 0 32
112611: IN
112612: NOT
112613: AND
112614: IFFALSE 112638
// to_repair := to_repair union group [ i ] ;
112616: LD_ADDR_VAR 0 32
112620: PUSH
112621: LD_VAR 0 32
112625: PUSH
112626: LD_VAR 0 4
112630: PUSH
112631: LD_VAR 0 7
112635: ARRAY
112636: UNION
112637: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112638: LD_VAR 0 4
112642: PUSH
112643: LD_VAR 0 7
112647: ARRAY
112648: PPUSH
112649: CALL_OW 256
112653: PUSH
112654: LD_INT 1000
112656: EQUAL
112657: PUSH
112658: LD_VAR 0 4
112662: PUSH
112663: LD_VAR 0 7
112667: ARRAY
112668: PUSH
112669: LD_VAR 0 32
112673: IN
112674: AND
112675: IFFALSE 112699
// to_repair := to_repair diff group [ i ] ;
112677: LD_ADDR_VAR 0 32
112681: PUSH
112682: LD_VAR 0 32
112686: PUSH
112687: LD_VAR 0 4
112691: PUSH
112692: LD_VAR 0 7
112696: ARRAY
112697: DIFF
112698: ST_TO_ADDR
// if group [ i ] in to_repair then
112699: LD_VAR 0 4
112703: PUSH
112704: LD_VAR 0 7
112708: ARRAY
112709: PUSH
112710: LD_VAR 0 32
112714: IN
112715: IFFALSE 112762
// begin if not IsInArea ( group [ i ] , f_repair ) then
112717: LD_VAR 0 4
112721: PUSH
112722: LD_VAR 0 7
112726: ARRAY
112727: PPUSH
112728: LD_VAR 0 22
112732: PPUSH
112733: CALL_OW 308
112737: NOT
112738: IFFALSE 112760
// ComMoveToArea ( group [ i ] , f_repair ) ;
112740: LD_VAR 0 4
112744: PUSH
112745: LD_VAR 0 7
112749: ARRAY
112750: PPUSH
112751: LD_VAR 0 22
112755: PPUSH
112756: CALL_OW 113
// continue ;
112760: GO 112387
// end ; end else
112762: GO 113042
// if group [ i ] in repairs then
112764: LD_VAR 0 4
112768: PUSH
112769: LD_VAR 0 7
112773: ARRAY
112774: PUSH
112775: LD_VAR 0 33
112779: IN
112780: IFFALSE 113042
// begin if IsInUnit ( group [ i ] ) then
112782: LD_VAR 0 4
112786: PUSH
112787: LD_VAR 0 7
112791: ARRAY
112792: PPUSH
112793: CALL_OW 310
112797: IFFALSE 112865
// begin z := IsInUnit ( group [ i ] ) ;
112799: LD_ADDR_VAR 0 13
112803: PUSH
112804: LD_VAR 0 4
112808: PUSH
112809: LD_VAR 0 7
112813: ARRAY
112814: PPUSH
112815: CALL_OW 310
112819: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112820: LD_VAR 0 13
112824: PUSH
112825: LD_VAR 0 32
112829: IN
112830: PUSH
112831: LD_VAR 0 13
112835: PPUSH
112836: LD_VAR 0 22
112840: PPUSH
112841: CALL_OW 308
112845: AND
112846: IFFALSE 112863
// ComExitVehicle ( group [ i ] ) ;
112848: LD_VAR 0 4
112852: PUSH
112853: LD_VAR 0 7
112857: ARRAY
112858: PPUSH
112859: CALL_OW 121
// end else
112863: GO 113042
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
112865: LD_ADDR_VAR 0 13
112869: PUSH
112870: LD_VAR 0 4
112874: PPUSH
112875: LD_INT 95
112877: PUSH
112878: LD_VAR 0 22
112882: PUSH
112883: EMPTY
112884: LIST
112885: LIST
112886: PUSH
112887: LD_INT 58
112889: PUSH
112890: EMPTY
112891: LIST
112892: PUSH
112893: EMPTY
112894: LIST
112895: LIST
112896: PPUSH
112897: CALL_OW 72
112901: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
112902: LD_VAR 0 4
112906: PUSH
112907: LD_VAR 0 7
112911: ARRAY
112912: PPUSH
112913: CALL_OW 314
112917: NOT
112918: IFFALSE 113040
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
112920: LD_ADDR_VAR 0 10
112924: PUSH
112925: LD_VAR 0 13
112929: PPUSH
112930: LD_VAR 0 4
112934: PUSH
112935: LD_VAR 0 7
112939: ARRAY
112940: PPUSH
112941: CALL_OW 74
112945: ST_TO_ADDR
// if not x then
112946: LD_VAR 0 10
112950: NOT
112951: IFFALSE 112955
// continue ;
112953: GO 112387
// if GetLives ( x ) < 1000 then
112955: LD_VAR 0 10
112959: PPUSH
112960: CALL_OW 256
112964: PUSH
112965: LD_INT 1000
112967: LESS
112968: IFFALSE 112992
// ComRepairVehicle ( group [ i ] , x ) else
112970: LD_VAR 0 4
112974: PUSH
112975: LD_VAR 0 7
112979: ARRAY
112980: PPUSH
112981: LD_VAR 0 10
112985: PPUSH
112986: CALL_OW 129
112990: GO 113040
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
112992: LD_VAR 0 23
112996: PUSH
112997: LD_VAR 0 4
113001: PUSH
113002: LD_VAR 0 7
113006: ARRAY
113007: PPUSH
113008: CALL_OW 256
113012: PUSH
113013: LD_INT 1000
113015: LESS
113016: AND
113017: NOT
113018: IFFALSE 113040
// ComEnterUnit ( group [ i ] , x ) ;
113020: LD_VAR 0 4
113024: PUSH
113025: LD_VAR 0 7
113029: ARRAY
113030: PPUSH
113031: LD_VAR 0 10
113035: PPUSH
113036: CALL_OW 120
// end ; continue ;
113040: GO 112387
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113042: LD_VAR 0 23
113046: PUSH
113047: LD_VAR 0 4
113051: PUSH
113052: LD_VAR 0 7
113056: ARRAY
113057: PPUSH
113058: CALL_OW 247
113062: PUSH
113063: LD_INT 1
113065: EQUAL
113066: AND
113067: IFFALSE 113545
// begin if group [ i ] in healers then
113069: LD_VAR 0 4
113073: PUSH
113074: LD_VAR 0 7
113078: ARRAY
113079: PUSH
113080: LD_VAR 0 31
113084: IN
113085: IFFALSE 113358
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113087: LD_VAR 0 4
113091: PUSH
113092: LD_VAR 0 7
113096: ARRAY
113097: PPUSH
113098: LD_VAR 0 23
113102: PPUSH
113103: CALL_OW 308
113107: NOT
113108: PUSH
113109: LD_VAR 0 4
113113: PUSH
113114: LD_VAR 0 7
113118: ARRAY
113119: PPUSH
113120: CALL_OW 314
113124: NOT
113125: AND
113126: IFFALSE 113150
// ComMoveToArea ( group [ i ] , f_heal ) else
113128: LD_VAR 0 4
113132: PUSH
113133: LD_VAR 0 7
113137: ARRAY
113138: PPUSH
113139: LD_VAR 0 23
113143: PPUSH
113144: CALL_OW 113
113148: GO 113356
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113150: LD_VAR 0 4
113154: PUSH
113155: LD_VAR 0 7
113159: ARRAY
113160: PPUSH
113161: CALL 54672 0 1
113165: PPUSH
113166: CALL_OW 256
113170: PUSH
113171: LD_INT 1000
113173: EQUAL
113174: IFFALSE 113193
// ComStop ( group [ i ] ) else
113176: LD_VAR 0 4
113180: PUSH
113181: LD_VAR 0 7
113185: ARRAY
113186: PPUSH
113187: CALL_OW 141
113191: GO 113356
// if not HasTask ( group [ i ] ) and to_heal then
113193: LD_VAR 0 4
113197: PUSH
113198: LD_VAR 0 7
113202: ARRAY
113203: PPUSH
113204: CALL_OW 314
113208: NOT
113209: PUSH
113210: LD_VAR 0 30
113214: AND
113215: IFFALSE 113356
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113217: LD_ADDR_VAR 0 13
113221: PUSH
113222: LD_VAR 0 30
113226: PPUSH
113227: LD_INT 3
113229: PUSH
113230: LD_INT 54
113232: PUSH
113233: EMPTY
113234: LIST
113235: PUSH
113236: EMPTY
113237: LIST
113238: LIST
113239: PPUSH
113240: CALL_OW 72
113244: PPUSH
113245: LD_VAR 0 4
113249: PUSH
113250: LD_VAR 0 7
113254: ARRAY
113255: PPUSH
113256: CALL_OW 74
113260: ST_TO_ADDR
// if z then
113261: LD_VAR 0 13
113265: IFFALSE 113356
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113267: LD_INT 91
113269: PUSH
113270: LD_VAR 0 13
113274: PUSH
113275: LD_INT 10
113277: PUSH
113278: EMPTY
113279: LIST
113280: LIST
113281: LIST
113282: PUSH
113283: LD_INT 81
113285: PUSH
113286: LD_VAR 0 13
113290: PPUSH
113291: CALL_OW 255
113295: PUSH
113296: EMPTY
113297: LIST
113298: LIST
113299: PUSH
113300: EMPTY
113301: LIST
113302: LIST
113303: PPUSH
113304: CALL_OW 69
113308: PUSH
113309: LD_INT 0
113311: EQUAL
113312: IFFALSE 113336
// ComHeal ( group [ i ] , z ) else
113314: LD_VAR 0 4
113318: PUSH
113319: LD_VAR 0 7
113323: ARRAY
113324: PPUSH
113325: LD_VAR 0 13
113329: PPUSH
113330: CALL_OW 128
113334: GO 113356
// ComMoveToArea ( group [ i ] , f_heal ) ;
113336: LD_VAR 0 4
113340: PUSH
113341: LD_VAR 0 7
113345: ARRAY
113346: PPUSH
113347: LD_VAR 0 23
113351: PPUSH
113352: CALL_OW 113
// end ; continue ;
113356: GO 112387
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113358: LD_VAR 0 4
113362: PUSH
113363: LD_VAR 0 7
113367: ARRAY
113368: PPUSH
113369: CALL_OW 256
113373: PUSH
113374: LD_INT 700
113376: LESS
113377: PUSH
113378: LD_VAR 0 4
113382: PUSH
113383: LD_VAR 0 7
113387: ARRAY
113388: PUSH
113389: LD_VAR 0 30
113393: IN
113394: NOT
113395: AND
113396: IFFALSE 113420
// to_heal := to_heal union group [ i ] ;
113398: LD_ADDR_VAR 0 30
113402: PUSH
113403: LD_VAR 0 30
113407: PUSH
113408: LD_VAR 0 4
113412: PUSH
113413: LD_VAR 0 7
113417: ARRAY
113418: UNION
113419: ST_TO_ADDR
// if group [ i ] in to_heal then
113420: LD_VAR 0 4
113424: PUSH
113425: LD_VAR 0 7
113429: ARRAY
113430: PUSH
113431: LD_VAR 0 30
113435: IN
113436: IFFALSE 113545
// begin if GetLives ( group [ i ] ) = 1000 then
113438: LD_VAR 0 4
113442: PUSH
113443: LD_VAR 0 7
113447: ARRAY
113448: PPUSH
113449: CALL_OW 256
113453: PUSH
113454: LD_INT 1000
113456: EQUAL
113457: IFFALSE 113483
// to_heal := to_heal diff group [ i ] else
113459: LD_ADDR_VAR 0 30
113463: PUSH
113464: LD_VAR 0 30
113468: PUSH
113469: LD_VAR 0 4
113473: PUSH
113474: LD_VAR 0 7
113478: ARRAY
113479: DIFF
113480: ST_TO_ADDR
113481: GO 113545
// begin if not IsInArea ( group [ i ] , to_heal ) then
113483: LD_VAR 0 4
113487: PUSH
113488: LD_VAR 0 7
113492: ARRAY
113493: PPUSH
113494: LD_VAR 0 30
113498: PPUSH
113499: CALL_OW 308
113503: NOT
113504: IFFALSE 113528
// ComMoveToArea ( group [ i ] , f_heal ) else
113506: LD_VAR 0 4
113510: PUSH
113511: LD_VAR 0 7
113515: ARRAY
113516: PPUSH
113517: LD_VAR 0 23
113521: PPUSH
113522: CALL_OW 113
113526: GO 113543
// ComHold ( group [ i ] ) ;
113528: LD_VAR 0 4
113532: PUSH
113533: LD_VAR 0 7
113537: ARRAY
113538: PPUSH
113539: CALL_OW 140
// continue ;
113543: GO 112387
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113545: LD_VAR 0 4
113549: PUSH
113550: LD_VAR 0 7
113554: ARRAY
113555: PPUSH
113556: LD_INT 10
113558: PPUSH
113559: CALL 52525 0 2
113563: NOT
113564: PUSH
113565: LD_VAR 0 16
113569: PUSH
113570: LD_VAR 0 7
113574: ARRAY
113575: PUSH
113576: EMPTY
113577: EQUAL
113578: NOT
113579: AND
113580: IFFALSE 113846
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113582: LD_VAR 0 4
113586: PUSH
113587: LD_VAR 0 7
113591: ARRAY
113592: PPUSH
113593: CALL_OW 262
113597: PUSH
113598: LD_INT 1
113600: PUSH
113601: LD_INT 2
113603: PUSH
113604: EMPTY
113605: LIST
113606: LIST
113607: IN
113608: IFFALSE 113649
// if GetFuel ( group [ i ] ) < 10 then
113610: LD_VAR 0 4
113614: PUSH
113615: LD_VAR 0 7
113619: ARRAY
113620: PPUSH
113621: CALL_OW 261
113625: PUSH
113626: LD_INT 10
113628: LESS
113629: IFFALSE 113649
// SetFuel ( group [ i ] , 12 ) ;
113631: LD_VAR 0 4
113635: PUSH
113636: LD_VAR 0 7
113640: ARRAY
113641: PPUSH
113642: LD_INT 12
113644: PPUSH
113645: CALL_OW 240
// if units_path [ i ] then
113649: LD_VAR 0 16
113653: PUSH
113654: LD_VAR 0 7
113658: ARRAY
113659: IFFALSE 113844
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113661: LD_VAR 0 4
113665: PUSH
113666: LD_VAR 0 7
113670: ARRAY
113671: PPUSH
113672: LD_VAR 0 16
113676: PUSH
113677: LD_VAR 0 7
113681: ARRAY
113682: PUSH
113683: LD_INT 1
113685: ARRAY
113686: PUSH
113687: LD_INT 1
113689: ARRAY
113690: PPUSH
113691: LD_VAR 0 16
113695: PUSH
113696: LD_VAR 0 7
113700: ARRAY
113701: PUSH
113702: LD_INT 1
113704: ARRAY
113705: PUSH
113706: LD_INT 2
113708: ARRAY
113709: PPUSH
113710: CALL_OW 297
113714: PUSH
113715: LD_INT 6
113717: GREATER
113718: IFFALSE 113793
// begin if not HasTask ( group [ i ] ) then
113720: LD_VAR 0 4
113724: PUSH
113725: LD_VAR 0 7
113729: ARRAY
113730: PPUSH
113731: CALL_OW 314
113735: NOT
113736: IFFALSE 113791
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113738: LD_VAR 0 4
113742: PUSH
113743: LD_VAR 0 7
113747: ARRAY
113748: PPUSH
113749: LD_VAR 0 16
113753: PUSH
113754: LD_VAR 0 7
113758: ARRAY
113759: PUSH
113760: LD_INT 1
113762: ARRAY
113763: PUSH
113764: LD_INT 1
113766: ARRAY
113767: PPUSH
113768: LD_VAR 0 16
113772: PUSH
113773: LD_VAR 0 7
113777: ARRAY
113778: PUSH
113779: LD_INT 1
113781: ARRAY
113782: PUSH
113783: LD_INT 2
113785: ARRAY
113786: PPUSH
113787: CALL_OW 114
// end else
113791: GO 113844
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113793: LD_ADDR_VAR 0 15
113797: PUSH
113798: LD_VAR 0 16
113802: PUSH
113803: LD_VAR 0 7
113807: ARRAY
113808: PPUSH
113809: LD_INT 1
113811: PPUSH
113812: CALL_OW 3
113816: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113817: LD_ADDR_VAR 0 16
113821: PUSH
113822: LD_VAR 0 16
113826: PPUSH
113827: LD_VAR 0 7
113831: PPUSH
113832: LD_VAR 0 15
113836: PPUSH
113837: CALL_OW 1
113841: ST_TO_ADDR
// continue ;
113842: GO 112387
// end ; end ; end else
113844: GO 116508
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
113846: LD_ADDR_VAR 0 14
113850: PUSH
113851: LD_INT 81
113853: PUSH
113854: LD_VAR 0 4
113858: PUSH
113859: LD_VAR 0 7
113863: ARRAY
113864: PPUSH
113865: CALL_OW 255
113869: PUSH
113870: EMPTY
113871: LIST
113872: LIST
113873: PPUSH
113874: CALL_OW 69
113878: ST_TO_ADDR
// if not tmp then
113879: LD_VAR 0 14
113883: NOT
113884: IFFALSE 113888
// continue ;
113886: GO 112387
// if f_ignore_area then
113888: LD_VAR 0 17
113892: IFFALSE 113980
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
113894: LD_ADDR_VAR 0 15
113898: PUSH
113899: LD_VAR 0 14
113903: PPUSH
113904: LD_INT 3
113906: PUSH
113907: LD_INT 92
113909: PUSH
113910: LD_VAR 0 17
113914: PUSH
113915: LD_INT 1
113917: ARRAY
113918: PUSH
113919: LD_VAR 0 17
113923: PUSH
113924: LD_INT 2
113926: ARRAY
113927: PUSH
113928: LD_VAR 0 17
113932: PUSH
113933: LD_INT 3
113935: ARRAY
113936: PUSH
113937: EMPTY
113938: LIST
113939: LIST
113940: LIST
113941: LIST
113942: PUSH
113943: EMPTY
113944: LIST
113945: LIST
113946: PPUSH
113947: CALL_OW 72
113951: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113952: LD_VAR 0 14
113956: PUSH
113957: LD_VAR 0 15
113961: DIFF
113962: IFFALSE 113980
// tmp := tmp diff tmp2 ;
113964: LD_ADDR_VAR 0 14
113968: PUSH
113969: LD_VAR 0 14
113973: PUSH
113974: LD_VAR 0 15
113978: DIFF
113979: ST_TO_ADDR
// end ; if not f_murder then
113980: LD_VAR 0 20
113984: NOT
113985: IFFALSE 114043
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
113987: LD_ADDR_VAR 0 15
113991: PUSH
113992: LD_VAR 0 14
113996: PPUSH
113997: LD_INT 3
113999: PUSH
114000: LD_INT 50
114002: PUSH
114003: EMPTY
114004: LIST
114005: PUSH
114006: EMPTY
114007: LIST
114008: LIST
114009: PPUSH
114010: CALL_OW 72
114014: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114015: LD_VAR 0 14
114019: PUSH
114020: LD_VAR 0 15
114024: DIFF
114025: IFFALSE 114043
// tmp := tmp diff tmp2 ;
114027: LD_ADDR_VAR 0 14
114031: PUSH
114032: LD_VAR 0 14
114036: PUSH
114037: LD_VAR 0 15
114041: DIFF
114042: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114043: LD_ADDR_VAR 0 14
114047: PUSH
114048: LD_VAR 0 4
114052: PUSH
114053: LD_VAR 0 7
114057: ARRAY
114058: PPUSH
114059: LD_VAR 0 14
114063: PPUSH
114064: LD_INT 1
114066: PPUSH
114067: LD_INT 1
114069: PPUSH
114070: CALL 25460 0 4
114074: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114075: LD_VAR 0 4
114079: PUSH
114080: LD_VAR 0 7
114084: ARRAY
114085: PPUSH
114086: CALL_OW 257
114090: PUSH
114091: LD_INT 1
114093: EQUAL
114094: IFFALSE 114542
// begin if WantPlant ( group [ i ] ) then
114096: LD_VAR 0 4
114100: PUSH
114101: LD_VAR 0 7
114105: ARRAY
114106: PPUSH
114107: CALL 24961 0 1
114111: IFFALSE 114115
// continue ;
114113: GO 112387
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114115: LD_VAR 0 18
114119: PUSH
114120: LD_VAR 0 4
114124: PUSH
114125: LD_VAR 0 7
114129: ARRAY
114130: PPUSH
114131: CALL_OW 310
114135: NOT
114136: AND
114137: PUSH
114138: LD_VAR 0 14
114142: PUSH
114143: LD_INT 1
114145: ARRAY
114146: PUSH
114147: LD_VAR 0 14
114151: PPUSH
114152: LD_INT 21
114154: PUSH
114155: LD_INT 2
114157: PUSH
114158: EMPTY
114159: LIST
114160: LIST
114161: PUSH
114162: LD_INT 58
114164: PUSH
114165: EMPTY
114166: LIST
114167: PUSH
114168: EMPTY
114169: LIST
114170: LIST
114171: PPUSH
114172: CALL_OW 72
114176: IN
114177: AND
114178: IFFALSE 114214
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114180: LD_VAR 0 4
114184: PUSH
114185: LD_VAR 0 7
114189: ARRAY
114190: PPUSH
114191: LD_VAR 0 14
114195: PUSH
114196: LD_INT 1
114198: ARRAY
114199: PPUSH
114200: CALL_OW 120
// attacking := true ;
114204: LD_ADDR_VAR 0 29
114208: PUSH
114209: LD_INT 1
114211: ST_TO_ADDR
// continue ;
114212: GO 112387
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114214: LD_VAR 0 26
114218: PUSH
114219: LD_VAR 0 4
114223: PUSH
114224: LD_VAR 0 7
114228: ARRAY
114229: PPUSH
114230: CALL_OW 257
114234: PUSH
114235: LD_INT 1
114237: EQUAL
114238: AND
114239: PUSH
114240: LD_VAR 0 4
114244: PUSH
114245: LD_VAR 0 7
114249: ARRAY
114250: PPUSH
114251: CALL_OW 256
114255: PUSH
114256: LD_INT 800
114258: LESS
114259: AND
114260: PUSH
114261: LD_VAR 0 4
114265: PUSH
114266: LD_VAR 0 7
114270: ARRAY
114271: PPUSH
114272: CALL_OW 318
114276: NOT
114277: AND
114278: IFFALSE 114295
// ComCrawl ( group [ i ] ) ;
114280: LD_VAR 0 4
114284: PUSH
114285: LD_VAR 0 7
114289: ARRAY
114290: PPUSH
114291: CALL_OW 137
// if f_mines then
114295: LD_VAR 0 21
114299: IFFALSE 114542
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114301: LD_VAR 0 14
114305: PUSH
114306: LD_INT 1
114308: ARRAY
114309: PPUSH
114310: CALL_OW 247
114314: PUSH
114315: LD_INT 3
114317: EQUAL
114318: PUSH
114319: LD_VAR 0 14
114323: PUSH
114324: LD_INT 1
114326: ARRAY
114327: PUSH
114328: LD_VAR 0 27
114332: IN
114333: NOT
114334: AND
114335: IFFALSE 114542
// begin x := GetX ( tmp [ 1 ] ) ;
114337: LD_ADDR_VAR 0 10
114341: PUSH
114342: LD_VAR 0 14
114346: PUSH
114347: LD_INT 1
114349: ARRAY
114350: PPUSH
114351: CALL_OW 250
114355: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114356: LD_ADDR_VAR 0 11
114360: PUSH
114361: LD_VAR 0 14
114365: PUSH
114366: LD_INT 1
114368: ARRAY
114369: PPUSH
114370: CALL_OW 251
114374: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114375: LD_ADDR_VAR 0 12
114379: PUSH
114380: LD_VAR 0 4
114384: PUSH
114385: LD_VAR 0 7
114389: ARRAY
114390: PPUSH
114391: CALL 52610 0 1
114395: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114396: LD_VAR 0 4
114400: PUSH
114401: LD_VAR 0 7
114405: ARRAY
114406: PPUSH
114407: LD_VAR 0 10
114411: PPUSH
114412: LD_VAR 0 11
114416: PPUSH
114417: LD_VAR 0 14
114421: PUSH
114422: LD_INT 1
114424: ARRAY
114425: PPUSH
114426: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114430: LD_VAR 0 4
114434: PUSH
114435: LD_VAR 0 7
114439: ARRAY
114440: PPUSH
114441: LD_VAR 0 10
114445: PPUSH
114446: LD_VAR 0 12
114450: PPUSH
114451: LD_INT 7
114453: PPUSH
114454: CALL_OW 272
114458: PPUSH
114459: LD_VAR 0 11
114463: PPUSH
114464: LD_VAR 0 12
114468: PPUSH
114469: LD_INT 7
114471: PPUSH
114472: CALL_OW 273
114476: PPUSH
114477: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114481: LD_VAR 0 4
114485: PUSH
114486: LD_VAR 0 7
114490: ARRAY
114491: PPUSH
114492: LD_INT 71
114494: PPUSH
114495: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114499: LD_ADDR_VAR 0 27
114503: PUSH
114504: LD_VAR 0 27
114508: PPUSH
114509: LD_VAR 0 27
114513: PUSH
114514: LD_INT 1
114516: PLUS
114517: PPUSH
114518: LD_VAR 0 14
114522: PUSH
114523: LD_INT 1
114525: ARRAY
114526: PPUSH
114527: CALL_OW 1
114531: ST_TO_ADDR
// attacking := true ;
114532: LD_ADDR_VAR 0 29
114536: PUSH
114537: LD_INT 1
114539: ST_TO_ADDR
// continue ;
114540: GO 112387
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114542: LD_VAR 0 4
114546: PUSH
114547: LD_VAR 0 7
114551: ARRAY
114552: PPUSH
114553: CALL_OW 257
114557: PUSH
114558: LD_INT 17
114560: EQUAL
114561: PUSH
114562: LD_VAR 0 4
114566: PUSH
114567: LD_VAR 0 7
114571: ARRAY
114572: PPUSH
114573: CALL_OW 110
114577: PUSH
114578: LD_INT 71
114580: EQUAL
114581: NOT
114582: AND
114583: IFFALSE 114729
// begin attacking := false ;
114585: LD_ADDR_VAR 0 29
114589: PUSH
114590: LD_INT 0
114592: ST_TO_ADDR
// k := 5 ;
114593: LD_ADDR_VAR 0 9
114597: PUSH
114598: LD_INT 5
114600: ST_TO_ADDR
// if tmp < k then
114601: LD_VAR 0 14
114605: PUSH
114606: LD_VAR 0 9
114610: LESS
114611: IFFALSE 114623
// k := tmp ;
114613: LD_ADDR_VAR 0 9
114617: PUSH
114618: LD_VAR 0 14
114622: ST_TO_ADDR
// for j = 1 to k do
114623: LD_ADDR_VAR 0 8
114627: PUSH
114628: DOUBLE
114629: LD_INT 1
114631: DEC
114632: ST_TO_ADDR
114633: LD_VAR 0 9
114637: PUSH
114638: FOR_TO
114639: IFFALSE 114727
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114641: LD_VAR 0 14
114645: PUSH
114646: LD_VAR 0 8
114650: ARRAY
114651: PUSH
114652: LD_VAR 0 14
114656: PPUSH
114657: LD_INT 58
114659: PUSH
114660: EMPTY
114661: LIST
114662: PPUSH
114663: CALL_OW 72
114667: IN
114668: NOT
114669: IFFALSE 114725
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114671: LD_VAR 0 4
114675: PUSH
114676: LD_VAR 0 7
114680: ARRAY
114681: PPUSH
114682: LD_VAR 0 14
114686: PUSH
114687: LD_VAR 0 8
114691: ARRAY
114692: PPUSH
114693: CALL_OW 115
// attacking := true ;
114697: LD_ADDR_VAR 0 29
114701: PUSH
114702: LD_INT 1
114704: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114705: LD_VAR 0 4
114709: PUSH
114710: LD_VAR 0 7
114714: ARRAY
114715: PPUSH
114716: LD_INT 71
114718: PPUSH
114719: CALL_OW 109
// continue ;
114723: GO 114638
// end ; end ;
114725: GO 114638
114727: POP
114728: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114729: LD_VAR 0 4
114733: PUSH
114734: LD_VAR 0 7
114738: ARRAY
114739: PPUSH
114740: CALL_OW 257
114744: PUSH
114745: LD_INT 8
114747: EQUAL
114748: PUSH
114749: LD_VAR 0 4
114753: PUSH
114754: LD_VAR 0 7
114758: ARRAY
114759: PPUSH
114760: CALL_OW 264
114764: PUSH
114765: LD_INT 28
114767: PUSH
114768: LD_INT 45
114770: PUSH
114771: LD_INT 7
114773: PUSH
114774: LD_INT 47
114776: PUSH
114777: EMPTY
114778: LIST
114779: LIST
114780: LIST
114781: LIST
114782: IN
114783: OR
114784: IFFALSE 115040
// begin attacking := false ;
114786: LD_ADDR_VAR 0 29
114790: PUSH
114791: LD_INT 0
114793: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114794: LD_VAR 0 14
114798: PUSH
114799: LD_INT 1
114801: ARRAY
114802: PPUSH
114803: CALL_OW 266
114807: PUSH
114808: LD_INT 32
114810: PUSH
114811: LD_INT 31
114813: PUSH
114814: LD_INT 33
114816: PUSH
114817: LD_INT 4
114819: PUSH
114820: LD_INT 5
114822: PUSH
114823: EMPTY
114824: LIST
114825: LIST
114826: LIST
114827: LIST
114828: LIST
114829: IN
114830: IFFALSE 115016
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
114832: LD_ADDR_VAR 0 9
114836: PUSH
114837: LD_VAR 0 14
114841: PUSH
114842: LD_INT 1
114844: ARRAY
114845: PPUSH
114846: CALL_OW 266
114850: PPUSH
114851: LD_VAR 0 14
114855: PUSH
114856: LD_INT 1
114858: ARRAY
114859: PPUSH
114860: CALL_OW 250
114864: PPUSH
114865: LD_VAR 0 14
114869: PUSH
114870: LD_INT 1
114872: ARRAY
114873: PPUSH
114874: CALL_OW 251
114878: PPUSH
114879: LD_VAR 0 14
114883: PUSH
114884: LD_INT 1
114886: ARRAY
114887: PPUSH
114888: CALL_OW 254
114892: PPUSH
114893: LD_VAR 0 14
114897: PUSH
114898: LD_INT 1
114900: ARRAY
114901: PPUSH
114902: CALL_OW 248
114906: PPUSH
114907: LD_INT 0
114909: PPUSH
114910: CALL 33980 0 6
114914: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
114915: LD_ADDR_VAR 0 8
114919: PUSH
114920: LD_VAR 0 4
114924: PUSH
114925: LD_VAR 0 7
114929: ARRAY
114930: PPUSH
114931: LD_VAR 0 9
114935: PPUSH
114936: CALL 52650 0 2
114940: ST_TO_ADDR
// if j then
114941: LD_VAR 0 8
114945: IFFALSE 115014
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
114947: LD_VAR 0 8
114951: PUSH
114952: LD_INT 1
114954: ARRAY
114955: PPUSH
114956: LD_VAR 0 8
114960: PUSH
114961: LD_INT 2
114963: ARRAY
114964: PPUSH
114965: CALL_OW 488
114969: IFFALSE 115014
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
114971: LD_VAR 0 4
114975: PUSH
114976: LD_VAR 0 7
114980: ARRAY
114981: PPUSH
114982: LD_VAR 0 8
114986: PUSH
114987: LD_INT 1
114989: ARRAY
114990: PPUSH
114991: LD_VAR 0 8
114995: PUSH
114996: LD_INT 2
114998: ARRAY
114999: PPUSH
115000: CALL_OW 116
// attacking := true ;
115004: LD_ADDR_VAR 0 29
115008: PUSH
115009: LD_INT 1
115011: ST_TO_ADDR
// continue ;
115012: GO 112387
// end ; end else
115014: GO 115040
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115016: LD_VAR 0 4
115020: PUSH
115021: LD_VAR 0 7
115025: ARRAY
115026: PPUSH
115027: LD_VAR 0 14
115031: PUSH
115032: LD_INT 1
115034: ARRAY
115035: PPUSH
115036: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115040: LD_VAR 0 4
115044: PUSH
115045: LD_VAR 0 7
115049: ARRAY
115050: PPUSH
115051: CALL_OW 265
115055: PUSH
115056: LD_INT 11
115058: EQUAL
115059: IFFALSE 115337
// begin k := 10 ;
115061: LD_ADDR_VAR 0 9
115065: PUSH
115066: LD_INT 10
115068: ST_TO_ADDR
// x := 0 ;
115069: LD_ADDR_VAR 0 10
115073: PUSH
115074: LD_INT 0
115076: ST_TO_ADDR
// if tmp < k then
115077: LD_VAR 0 14
115081: PUSH
115082: LD_VAR 0 9
115086: LESS
115087: IFFALSE 115099
// k := tmp ;
115089: LD_ADDR_VAR 0 9
115093: PUSH
115094: LD_VAR 0 14
115098: ST_TO_ADDR
// for j = k downto 1 do
115099: LD_ADDR_VAR 0 8
115103: PUSH
115104: DOUBLE
115105: LD_VAR 0 9
115109: INC
115110: ST_TO_ADDR
115111: LD_INT 1
115113: PUSH
115114: FOR_DOWNTO
115115: IFFALSE 115190
// begin if GetType ( tmp [ j ] ) = unit_human then
115117: LD_VAR 0 14
115121: PUSH
115122: LD_VAR 0 8
115126: ARRAY
115127: PPUSH
115128: CALL_OW 247
115132: PUSH
115133: LD_INT 1
115135: EQUAL
115136: IFFALSE 115188
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115138: LD_VAR 0 4
115142: PUSH
115143: LD_VAR 0 7
115147: ARRAY
115148: PPUSH
115149: LD_VAR 0 14
115153: PUSH
115154: LD_VAR 0 8
115158: ARRAY
115159: PPUSH
115160: CALL 52921 0 2
// x := tmp [ j ] ;
115164: LD_ADDR_VAR 0 10
115168: PUSH
115169: LD_VAR 0 14
115173: PUSH
115174: LD_VAR 0 8
115178: ARRAY
115179: ST_TO_ADDR
// attacking := true ;
115180: LD_ADDR_VAR 0 29
115184: PUSH
115185: LD_INT 1
115187: ST_TO_ADDR
// end ; end ;
115188: GO 115114
115190: POP
115191: POP
// if not x then
115192: LD_VAR 0 10
115196: NOT
115197: IFFALSE 115337
// begin attacking := true ;
115199: LD_ADDR_VAR 0 29
115203: PUSH
115204: LD_INT 1
115206: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115207: LD_VAR 0 4
115211: PUSH
115212: LD_VAR 0 7
115216: ARRAY
115217: PPUSH
115218: CALL_OW 250
115222: PPUSH
115223: LD_VAR 0 4
115227: PUSH
115228: LD_VAR 0 7
115232: ARRAY
115233: PPUSH
115234: CALL_OW 251
115238: PPUSH
115239: CALL_OW 546
115243: PUSH
115244: LD_INT 2
115246: ARRAY
115247: PUSH
115248: LD_VAR 0 14
115252: PUSH
115253: LD_INT 1
115255: ARRAY
115256: PPUSH
115257: CALL_OW 250
115261: PPUSH
115262: LD_VAR 0 14
115266: PUSH
115267: LD_INT 1
115269: ARRAY
115270: PPUSH
115271: CALL_OW 251
115275: PPUSH
115276: CALL_OW 546
115280: PUSH
115281: LD_INT 2
115283: ARRAY
115284: EQUAL
115285: IFFALSE 115313
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115287: LD_VAR 0 4
115291: PUSH
115292: LD_VAR 0 7
115296: ARRAY
115297: PPUSH
115298: LD_VAR 0 14
115302: PUSH
115303: LD_INT 1
115305: ARRAY
115306: PPUSH
115307: CALL 52921 0 2
115311: GO 115337
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115313: LD_VAR 0 4
115317: PUSH
115318: LD_VAR 0 7
115322: ARRAY
115323: PPUSH
115324: LD_VAR 0 14
115328: PUSH
115329: LD_INT 1
115331: ARRAY
115332: PPUSH
115333: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115337: LD_VAR 0 4
115341: PUSH
115342: LD_VAR 0 7
115346: ARRAY
115347: PPUSH
115348: CALL_OW 264
115352: PUSH
115353: LD_INT 29
115355: EQUAL
115356: IFFALSE 115722
// begin if WantsToAttack ( group [ i ] ) in bombed then
115358: LD_VAR 0 4
115362: PUSH
115363: LD_VAR 0 7
115367: ARRAY
115368: PPUSH
115369: CALL_OW 319
115373: PUSH
115374: LD_VAR 0 28
115378: IN
115379: IFFALSE 115383
// continue ;
115381: GO 112387
// k := 8 ;
115383: LD_ADDR_VAR 0 9
115387: PUSH
115388: LD_INT 8
115390: ST_TO_ADDR
// x := 0 ;
115391: LD_ADDR_VAR 0 10
115395: PUSH
115396: LD_INT 0
115398: ST_TO_ADDR
// if tmp < k then
115399: LD_VAR 0 14
115403: PUSH
115404: LD_VAR 0 9
115408: LESS
115409: IFFALSE 115421
// k := tmp ;
115411: LD_ADDR_VAR 0 9
115415: PUSH
115416: LD_VAR 0 14
115420: ST_TO_ADDR
// for j = 1 to k do
115421: LD_ADDR_VAR 0 8
115425: PUSH
115426: DOUBLE
115427: LD_INT 1
115429: DEC
115430: ST_TO_ADDR
115431: LD_VAR 0 9
115435: PUSH
115436: FOR_TO
115437: IFFALSE 115569
// begin if GetType ( tmp [ j ] ) = unit_building then
115439: LD_VAR 0 14
115443: PUSH
115444: LD_VAR 0 8
115448: ARRAY
115449: PPUSH
115450: CALL_OW 247
115454: PUSH
115455: LD_INT 3
115457: EQUAL
115458: IFFALSE 115567
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115460: LD_VAR 0 14
115464: PUSH
115465: LD_VAR 0 8
115469: ARRAY
115470: PUSH
115471: LD_VAR 0 28
115475: IN
115476: NOT
115477: PUSH
115478: LD_VAR 0 14
115482: PUSH
115483: LD_VAR 0 8
115487: ARRAY
115488: PPUSH
115489: CALL_OW 313
115493: AND
115494: IFFALSE 115567
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115496: LD_VAR 0 4
115500: PUSH
115501: LD_VAR 0 7
115505: ARRAY
115506: PPUSH
115507: LD_VAR 0 14
115511: PUSH
115512: LD_VAR 0 8
115516: ARRAY
115517: PPUSH
115518: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115522: LD_ADDR_VAR 0 28
115526: PUSH
115527: LD_VAR 0 28
115531: PPUSH
115532: LD_VAR 0 28
115536: PUSH
115537: LD_INT 1
115539: PLUS
115540: PPUSH
115541: LD_VAR 0 14
115545: PUSH
115546: LD_VAR 0 8
115550: ARRAY
115551: PPUSH
115552: CALL_OW 1
115556: ST_TO_ADDR
// attacking := true ;
115557: LD_ADDR_VAR 0 29
115561: PUSH
115562: LD_INT 1
115564: ST_TO_ADDR
// break ;
115565: GO 115569
// end ; end ;
115567: GO 115436
115569: POP
115570: POP
// if not attacking and f_attack_depot then
115571: LD_VAR 0 29
115575: NOT
115576: PUSH
115577: LD_VAR 0 25
115581: AND
115582: IFFALSE 115677
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115584: LD_ADDR_VAR 0 13
115588: PUSH
115589: LD_VAR 0 14
115593: PPUSH
115594: LD_INT 2
115596: PUSH
115597: LD_INT 30
115599: PUSH
115600: LD_INT 0
115602: PUSH
115603: EMPTY
115604: LIST
115605: LIST
115606: PUSH
115607: LD_INT 30
115609: PUSH
115610: LD_INT 1
115612: PUSH
115613: EMPTY
115614: LIST
115615: LIST
115616: PUSH
115617: EMPTY
115618: LIST
115619: LIST
115620: LIST
115621: PPUSH
115622: CALL_OW 72
115626: ST_TO_ADDR
// if z then
115627: LD_VAR 0 13
115631: IFFALSE 115677
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115633: LD_VAR 0 4
115637: PUSH
115638: LD_VAR 0 7
115642: ARRAY
115643: PPUSH
115644: LD_VAR 0 13
115648: PPUSH
115649: LD_VAR 0 4
115653: PUSH
115654: LD_VAR 0 7
115658: ARRAY
115659: PPUSH
115660: CALL_OW 74
115664: PPUSH
115665: CALL_OW 115
// attacking := true ;
115669: LD_ADDR_VAR 0 29
115673: PUSH
115674: LD_INT 1
115676: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115677: LD_VAR 0 4
115681: PUSH
115682: LD_VAR 0 7
115686: ARRAY
115687: PPUSH
115688: CALL_OW 256
115692: PUSH
115693: LD_INT 500
115695: LESS
115696: IFFALSE 115722
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115698: LD_VAR 0 4
115702: PUSH
115703: LD_VAR 0 7
115707: ARRAY
115708: PPUSH
115709: LD_VAR 0 14
115713: PUSH
115714: LD_INT 1
115716: ARRAY
115717: PPUSH
115718: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115722: LD_VAR 0 4
115726: PUSH
115727: LD_VAR 0 7
115731: ARRAY
115732: PPUSH
115733: CALL_OW 264
115737: PUSH
115738: LD_INT 49
115740: EQUAL
115741: IFFALSE 115862
// begin if not HasTask ( group [ i ] ) then
115743: LD_VAR 0 4
115747: PUSH
115748: LD_VAR 0 7
115752: ARRAY
115753: PPUSH
115754: CALL_OW 314
115758: NOT
115759: IFFALSE 115862
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115761: LD_ADDR_VAR 0 9
115765: PUSH
115766: LD_INT 81
115768: PUSH
115769: LD_VAR 0 4
115773: PUSH
115774: LD_VAR 0 7
115778: ARRAY
115779: PPUSH
115780: CALL_OW 255
115784: PUSH
115785: EMPTY
115786: LIST
115787: LIST
115788: PPUSH
115789: CALL_OW 69
115793: PPUSH
115794: LD_VAR 0 4
115798: PUSH
115799: LD_VAR 0 7
115803: ARRAY
115804: PPUSH
115805: CALL_OW 74
115809: ST_TO_ADDR
// if k then
115810: LD_VAR 0 9
115814: IFFALSE 115862
// if GetDistUnits ( group [ i ] , k ) > 10 then
115816: LD_VAR 0 4
115820: PUSH
115821: LD_VAR 0 7
115825: ARRAY
115826: PPUSH
115827: LD_VAR 0 9
115831: PPUSH
115832: CALL_OW 296
115836: PUSH
115837: LD_INT 10
115839: GREATER
115840: IFFALSE 115862
// ComMoveUnit ( group [ i ] , k ) ;
115842: LD_VAR 0 4
115846: PUSH
115847: LD_VAR 0 7
115851: ARRAY
115852: PPUSH
115853: LD_VAR 0 9
115857: PPUSH
115858: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
115862: LD_VAR 0 4
115866: PUSH
115867: LD_VAR 0 7
115871: ARRAY
115872: PPUSH
115873: CALL_OW 256
115877: PUSH
115878: LD_INT 250
115880: LESS
115881: PUSH
115882: LD_VAR 0 4
115886: PUSH
115887: LD_VAR 0 7
115891: ARRAY
115892: PUSH
115893: LD_INT 21
115895: PUSH
115896: LD_INT 2
115898: PUSH
115899: EMPTY
115900: LIST
115901: LIST
115902: PUSH
115903: LD_INT 23
115905: PUSH
115906: LD_INT 2
115908: PUSH
115909: EMPTY
115910: LIST
115911: LIST
115912: PUSH
115913: EMPTY
115914: LIST
115915: LIST
115916: PPUSH
115917: CALL_OW 69
115921: IN
115922: AND
115923: IFFALSE 116048
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
115925: LD_ADDR_VAR 0 9
115929: PUSH
115930: LD_OWVAR 3
115934: PUSH
115935: LD_VAR 0 4
115939: PUSH
115940: LD_VAR 0 7
115944: ARRAY
115945: DIFF
115946: PPUSH
115947: LD_VAR 0 4
115951: PUSH
115952: LD_VAR 0 7
115956: ARRAY
115957: PPUSH
115958: CALL_OW 74
115962: ST_TO_ADDR
// if not k then
115963: LD_VAR 0 9
115967: NOT
115968: IFFALSE 115972
// continue ;
115970: GO 112387
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
115972: LD_VAR 0 9
115976: PUSH
115977: LD_INT 81
115979: PUSH
115980: LD_VAR 0 4
115984: PUSH
115985: LD_VAR 0 7
115989: ARRAY
115990: PPUSH
115991: CALL_OW 255
115995: PUSH
115996: EMPTY
115997: LIST
115998: LIST
115999: PPUSH
116000: CALL_OW 69
116004: IN
116005: PUSH
116006: LD_VAR 0 9
116010: PPUSH
116011: LD_VAR 0 4
116015: PUSH
116016: LD_VAR 0 7
116020: ARRAY
116021: PPUSH
116022: CALL_OW 296
116026: PUSH
116027: LD_INT 5
116029: LESS
116030: AND
116031: IFFALSE 116048
// ComAutodestruct ( group [ i ] ) ;
116033: LD_VAR 0 4
116037: PUSH
116038: LD_VAR 0 7
116042: ARRAY
116043: PPUSH
116044: CALL 52819 0 1
// end ; if f_attack_depot then
116048: LD_VAR 0 25
116052: IFFALSE 116164
// begin k := 6 ;
116054: LD_ADDR_VAR 0 9
116058: PUSH
116059: LD_INT 6
116061: ST_TO_ADDR
// if tmp < k then
116062: LD_VAR 0 14
116066: PUSH
116067: LD_VAR 0 9
116071: LESS
116072: IFFALSE 116084
// k := tmp ;
116074: LD_ADDR_VAR 0 9
116078: PUSH
116079: LD_VAR 0 14
116083: ST_TO_ADDR
// for j = 1 to k do
116084: LD_ADDR_VAR 0 8
116088: PUSH
116089: DOUBLE
116090: LD_INT 1
116092: DEC
116093: ST_TO_ADDR
116094: LD_VAR 0 9
116098: PUSH
116099: FOR_TO
116100: IFFALSE 116162
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116102: LD_VAR 0 8
116106: PPUSH
116107: CALL_OW 266
116111: PUSH
116112: LD_INT 0
116114: PUSH
116115: LD_INT 1
116117: PUSH
116118: EMPTY
116119: LIST
116120: LIST
116121: IN
116122: IFFALSE 116160
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116124: LD_VAR 0 4
116128: PUSH
116129: LD_VAR 0 7
116133: ARRAY
116134: PPUSH
116135: LD_VAR 0 14
116139: PUSH
116140: LD_VAR 0 8
116144: ARRAY
116145: PPUSH
116146: CALL_OW 115
// attacking := true ;
116150: LD_ADDR_VAR 0 29
116154: PUSH
116155: LD_INT 1
116157: ST_TO_ADDR
// break ;
116158: GO 116162
// end ;
116160: GO 116099
116162: POP
116163: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116164: LD_VAR 0 4
116168: PUSH
116169: LD_VAR 0 7
116173: ARRAY
116174: PPUSH
116175: CALL_OW 302
116179: PUSH
116180: LD_VAR 0 29
116184: NOT
116185: AND
116186: IFFALSE 116508
// begin if GetTag ( group [ i ] ) = 71 then
116188: LD_VAR 0 4
116192: PUSH
116193: LD_VAR 0 7
116197: ARRAY
116198: PPUSH
116199: CALL_OW 110
116203: PUSH
116204: LD_INT 71
116206: EQUAL
116207: IFFALSE 116248
// begin if HasTask ( group [ i ] ) then
116209: LD_VAR 0 4
116213: PUSH
116214: LD_VAR 0 7
116218: ARRAY
116219: PPUSH
116220: CALL_OW 314
116224: IFFALSE 116230
// continue else
116226: GO 112387
116228: GO 116248
// SetTag ( group [ i ] , 0 ) ;
116230: LD_VAR 0 4
116234: PUSH
116235: LD_VAR 0 7
116239: ARRAY
116240: PPUSH
116241: LD_INT 0
116243: PPUSH
116244: CALL_OW 109
// end ; k := 8 ;
116248: LD_ADDR_VAR 0 9
116252: PUSH
116253: LD_INT 8
116255: ST_TO_ADDR
// x := 0 ;
116256: LD_ADDR_VAR 0 10
116260: PUSH
116261: LD_INT 0
116263: ST_TO_ADDR
// if tmp < k then
116264: LD_VAR 0 14
116268: PUSH
116269: LD_VAR 0 9
116273: LESS
116274: IFFALSE 116286
// k := tmp ;
116276: LD_ADDR_VAR 0 9
116280: PUSH
116281: LD_VAR 0 14
116285: ST_TO_ADDR
// for j = 1 to k do
116286: LD_ADDR_VAR 0 8
116290: PUSH
116291: DOUBLE
116292: LD_INT 1
116294: DEC
116295: ST_TO_ADDR
116296: LD_VAR 0 9
116300: PUSH
116301: FOR_TO
116302: IFFALSE 116400
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116304: LD_VAR 0 14
116308: PUSH
116309: LD_VAR 0 8
116313: ARRAY
116314: PPUSH
116315: CALL_OW 247
116319: PUSH
116320: LD_INT 1
116322: EQUAL
116323: PUSH
116324: LD_VAR 0 14
116328: PUSH
116329: LD_VAR 0 8
116333: ARRAY
116334: PPUSH
116335: CALL_OW 256
116339: PUSH
116340: LD_INT 250
116342: LESS
116343: PUSH
116344: LD_VAR 0 20
116348: AND
116349: PUSH
116350: LD_VAR 0 20
116354: NOT
116355: PUSH
116356: LD_VAR 0 14
116360: PUSH
116361: LD_VAR 0 8
116365: ARRAY
116366: PPUSH
116367: CALL_OW 256
116371: PUSH
116372: LD_INT 250
116374: GREATEREQUAL
116375: AND
116376: OR
116377: AND
116378: IFFALSE 116398
// begin x := tmp [ j ] ;
116380: LD_ADDR_VAR 0 10
116384: PUSH
116385: LD_VAR 0 14
116389: PUSH
116390: LD_VAR 0 8
116394: ARRAY
116395: ST_TO_ADDR
// break ;
116396: GO 116400
// end ;
116398: GO 116301
116400: POP
116401: POP
// if x then
116402: LD_VAR 0 10
116406: IFFALSE 116430
// ComAttackUnit ( group [ i ] , x ) else
116408: LD_VAR 0 4
116412: PUSH
116413: LD_VAR 0 7
116417: ARRAY
116418: PPUSH
116419: LD_VAR 0 10
116423: PPUSH
116424: CALL_OW 115
116428: GO 116454
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116430: LD_VAR 0 4
116434: PUSH
116435: LD_VAR 0 7
116439: ARRAY
116440: PPUSH
116441: LD_VAR 0 14
116445: PUSH
116446: LD_INT 1
116448: ARRAY
116449: PPUSH
116450: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116454: LD_VAR 0 4
116458: PUSH
116459: LD_VAR 0 7
116463: ARRAY
116464: PPUSH
116465: CALL_OW 314
116469: NOT
116470: IFFALSE 116508
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116472: LD_VAR 0 4
116476: PUSH
116477: LD_VAR 0 7
116481: ARRAY
116482: PPUSH
116483: LD_VAR 0 14
116487: PPUSH
116488: LD_VAR 0 4
116492: PUSH
116493: LD_VAR 0 7
116497: ARRAY
116498: PPUSH
116499: CALL_OW 74
116503: PPUSH
116504: CALL_OW 115
// end ; end ; end ;
116508: GO 112387
116510: POP
116511: POP
// wait ( 0 0$2 ) ;
116512: LD_INT 70
116514: PPUSH
116515: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116519: LD_VAR 0 4
116523: NOT
116524: PUSH
116525: LD_VAR 0 4
116529: PUSH
116530: EMPTY
116531: EQUAL
116532: OR
116533: PUSH
116534: LD_INT 81
116536: PUSH
116537: LD_VAR 0 35
116541: PUSH
116542: EMPTY
116543: LIST
116544: LIST
116545: PPUSH
116546: CALL_OW 69
116550: NOT
116551: OR
116552: IFFALSE 112372
// end ;
116554: LD_VAR 0 2
116558: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116559: LD_INT 0
116561: PPUSH
116562: PPUSH
116563: PPUSH
116564: PPUSH
116565: PPUSH
116566: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116567: LD_VAR 0 1
116571: NOT
116572: PUSH
116573: LD_EXP 49
116577: PUSH
116578: LD_VAR 0 1
116582: ARRAY
116583: NOT
116584: OR
116585: PUSH
116586: LD_VAR 0 2
116590: NOT
116591: OR
116592: IFFALSE 116596
// exit ;
116594: GO 117150
// side := mc_sides [ base ] ;
116596: LD_ADDR_VAR 0 6
116600: PUSH
116601: LD_EXP 75
116605: PUSH
116606: LD_VAR 0 1
116610: ARRAY
116611: ST_TO_ADDR
// if not side then
116612: LD_VAR 0 6
116616: NOT
116617: IFFALSE 116621
// exit ;
116619: GO 117150
// for i in solds do
116621: LD_ADDR_VAR 0 7
116625: PUSH
116626: LD_VAR 0 2
116630: PUSH
116631: FOR_IN
116632: IFFALSE 116693
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116634: LD_VAR 0 7
116638: PPUSH
116639: CALL_OW 310
116643: PPUSH
116644: CALL_OW 266
116648: PUSH
116649: LD_INT 32
116651: PUSH
116652: LD_INT 31
116654: PUSH
116655: EMPTY
116656: LIST
116657: LIST
116658: IN
116659: IFFALSE 116679
// solds := solds diff i else
116661: LD_ADDR_VAR 0 2
116665: PUSH
116666: LD_VAR 0 2
116670: PUSH
116671: LD_VAR 0 7
116675: DIFF
116676: ST_TO_ADDR
116677: GO 116691
// SetTag ( i , 18 ) ;
116679: LD_VAR 0 7
116683: PPUSH
116684: LD_INT 18
116686: PPUSH
116687: CALL_OW 109
116691: GO 116631
116693: POP
116694: POP
// if not solds then
116695: LD_VAR 0 2
116699: NOT
116700: IFFALSE 116704
// exit ;
116702: GO 117150
// repeat wait ( 0 0$2 ) ;
116704: LD_INT 70
116706: PPUSH
116707: CALL_OW 67
// enemy := mc_scan [ base ] ;
116711: LD_ADDR_VAR 0 4
116715: PUSH
116716: LD_EXP 72
116720: PUSH
116721: LD_VAR 0 1
116725: ARRAY
116726: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116727: LD_EXP 49
116731: PUSH
116732: LD_VAR 0 1
116736: ARRAY
116737: NOT
116738: PUSH
116739: LD_EXP 49
116743: PUSH
116744: LD_VAR 0 1
116748: ARRAY
116749: PUSH
116750: EMPTY
116751: EQUAL
116752: OR
116753: IFFALSE 116790
// begin for i in solds do
116755: LD_ADDR_VAR 0 7
116759: PUSH
116760: LD_VAR 0 2
116764: PUSH
116765: FOR_IN
116766: IFFALSE 116779
// ComStop ( i ) ;
116768: LD_VAR 0 7
116772: PPUSH
116773: CALL_OW 141
116777: GO 116765
116779: POP
116780: POP
// solds := [ ] ;
116781: LD_ADDR_VAR 0 2
116785: PUSH
116786: EMPTY
116787: ST_TO_ADDR
// exit ;
116788: GO 117150
// end ; for i in solds do
116790: LD_ADDR_VAR 0 7
116794: PUSH
116795: LD_VAR 0 2
116799: PUSH
116800: FOR_IN
116801: IFFALSE 117122
// begin if IsInUnit ( i ) then
116803: LD_VAR 0 7
116807: PPUSH
116808: CALL_OW 310
116812: IFFALSE 116823
// ComExitBuilding ( i ) ;
116814: LD_VAR 0 7
116818: PPUSH
116819: CALL_OW 122
// if GetLives ( i ) > 500 then
116823: LD_VAR 0 7
116827: PPUSH
116828: CALL_OW 256
116832: PUSH
116833: LD_INT 500
116835: GREATER
116836: IFFALSE 116889
// begin e := NearestUnitToUnit ( enemy , i ) ;
116838: LD_ADDR_VAR 0 5
116842: PUSH
116843: LD_VAR 0 4
116847: PPUSH
116848: LD_VAR 0 7
116852: PPUSH
116853: CALL_OW 74
116857: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
116858: LD_VAR 0 7
116862: PPUSH
116863: LD_VAR 0 5
116867: PPUSH
116868: CALL_OW 250
116872: PPUSH
116873: LD_VAR 0 5
116877: PPUSH
116878: CALL_OW 251
116882: PPUSH
116883: CALL_OW 114
// end else
116887: GO 117120
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
116889: LD_VAR 0 7
116893: PPUSH
116894: LD_EXP 49
116898: PUSH
116899: LD_VAR 0 1
116903: ARRAY
116904: PPUSH
116905: LD_INT 2
116907: PUSH
116908: LD_INT 30
116910: PUSH
116911: LD_INT 0
116913: PUSH
116914: EMPTY
116915: LIST
116916: LIST
116917: PUSH
116918: LD_INT 30
116920: PUSH
116921: LD_INT 1
116923: PUSH
116924: EMPTY
116925: LIST
116926: LIST
116927: PUSH
116928: LD_INT 30
116930: PUSH
116931: LD_INT 6
116933: PUSH
116934: EMPTY
116935: LIST
116936: LIST
116937: PUSH
116938: EMPTY
116939: LIST
116940: LIST
116941: LIST
116942: LIST
116943: PPUSH
116944: CALL_OW 72
116948: PPUSH
116949: LD_VAR 0 7
116953: PPUSH
116954: CALL_OW 74
116958: PPUSH
116959: CALL_OW 296
116963: PUSH
116964: LD_INT 10
116966: GREATER
116967: IFFALSE 117120
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
116969: LD_ADDR_VAR 0 8
116973: PUSH
116974: LD_EXP 49
116978: PUSH
116979: LD_VAR 0 1
116983: ARRAY
116984: PPUSH
116985: LD_INT 2
116987: PUSH
116988: LD_INT 30
116990: PUSH
116991: LD_INT 0
116993: PUSH
116994: EMPTY
116995: LIST
116996: LIST
116997: PUSH
116998: LD_INT 30
117000: PUSH
117001: LD_INT 1
117003: PUSH
117004: EMPTY
117005: LIST
117006: LIST
117007: PUSH
117008: LD_INT 30
117010: PUSH
117011: LD_INT 6
117013: PUSH
117014: EMPTY
117015: LIST
117016: LIST
117017: PUSH
117018: EMPTY
117019: LIST
117020: LIST
117021: LIST
117022: LIST
117023: PPUSH
117024: CALL_OW 72
117028: PPUSH
117029: LD_VAR 0 7
117033: PPUSH
117034: CALL_OW 74
117038: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117039: LD_VAR 0 7
117043: PPUSH
117044: LD_VAR 0 8
117048: PPUSH
117049: CALL_OW 250
117053: PPUSH
117054: LD_INT 3
117056: PPUSH
117057: LD_INT 5
117059: PPUSH
117060: CALL_OW 272
117064: PPUSH
117065: LD_VAR 0 8
117069: PPUSH
117070: CALL_OW 251
117074: PPUSH
117075: LD_INT 3
117077: PPUSH
117078: LD_INT 5
117080: PPUSH
117081: CALL_OW 273
117085: PPUSH
117086: CALL_OW 111
// SetTag ( i , 0 ) ;
117090: LD_VAR 0 7
117094: PPUSH
117095: LD_INT 0
117097: PPUSH
117098: CALL_OW 109
// solds := solds diff i ;
117102: LD_ADDR_VAR 0 2
117106: PUSH
117107: LD_VAR 0 2
117111: PUSH
117112: LD_VAR 0 7
117116: DIFF
117117: ST_TO_ADDR
// continue ;
117118: GO 116800
// end ; end ;
117120: GO 116800
117122: POP
117123: POP
// until not solds or not enemy ;
117124: LD_VAR 0 2
117128: NOT
117129: PUSH
117130: LD_VAR 0 4
117134: NOT
117135: OR
117136: IFFALSE 116704
// MC_Reset ( base , 18 ) ;
117138: LD_VAR 0 1
117142: PPUSH
117143: LD_INT 18
117145: PPUSH
117146: CALL 65416 0 2
// end ;
117150: LD_VAR 0 3
117154: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117155: LD_INT 0
117157: PPUSH
117158: PPUSH
117159: PPUSH
117160: PPUSH
117161: PPUSH
117162: PPUSH
117163: PPUSH
117164: PPUSH
117165: PPUSH
117166: PPUSH
117167: PPUSH
117168: PPUSH
117169: PPUSH
117170: PPUSH
117171: PPUSH
117172: PPUSH
117173: PPUSH
117174: PPUSH
117175: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117176: LD_ADDR_VAR 0 12
117180: PUSH
117181: LD_EXP 49
117185: PUSH
117186: LD_VAR 0 1
117190: ARRAY
117191: PPUSH
117192: LD_INT 25
117194: PUSH
117195: LD_INT 3
117197: PUSH
117198: EMPTY
117199: LIST
117200: LIST
117201: PPUSH
117202: CALL_OW 72
117206: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117207: LD_EXP 89
117211: PUSH
117212: LD_VAR 0 1
117216: ARRAY
117217: IFFALSE 117241
// mechs := mechs diff mc_remote_driver [ base ] ;
117219: LD_ADDR_VAR 0 12
117223: PUSH
117224: LD_VAR 0 12
117228: PUSH
117229: LD_EXP 89
117233: PUSH
117234: LD_VAR 0 1
117238: ARRAY
117239: DIFF
117240: ST_TO_ADDR
// for i in mechs do
117241: LD_ADDR_VAR 0 4
117245: PUSH
117246: LD_VAR 0 12
117250: PUSH
117251: FOR_IN
117252: IFFALSE 117287
// if GetTag ( i ) > 0 then
117254: LD_VAR 0 4
117258: PPUSH
117259: CALL_OW 110
117263: PUSH
117264: LD_INT 0
117266: GREATER
117267: IFFALSE 117285
// mechs := mechs diff i ;
117269: LD_ADDR_VAR 0 12
117273: PUSH
117274: LD_VAR 0 12
117278: PUSH
117279: LD_VAR 0 4
117283: DIFF
117284: ST_TO_ADDR
117285: GO 117251
117287: POP
117288: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117289: LD_ADDR_VAR 0 8
117293: PUSH
117294: LD_EXP 49
117298: PUSH
117299: LD_VAR 0 1
117303: ARRAY
117304: PPUSH
117305: LD_INT 2
117307: PUSH
117308: LD_INT 25
117310: PUSH
117311: LD_INT 1
117313: PUSH
117314: EMPTY
117315: LIST
117316: LIST
117317: PUSH
117318: LD_INT 25
117320: PUSH
117321: LD_INT 5
117323: PUSH
117324: EMPTY
117325: LIST
117326: LIST
117327: PUSH
117328: LD_INT 25
117330: PUSH
117331: LD_INT 8
117333: PUSH
117334: EMPTY
117335: LIST
117336: LIST
117337: PUSH
117338: LD_INT 25
117340: PUSH
117341: LD_INT 9
117343: PUSH
117344: EMPTY
117345: LIST
117346: LIST
117347: PUSH
117348: EMPTY
117349: LIST
117350: LIST
117351: LIST
117352: LIST
117353: LIST
117354: PPUSH
117355: CALL_OW 72
117359: ST_TO_ADDR
// if not defenders and not solds then
117360: LD_VAR 0 2
117364: NOT
117365: PUSH
117366: LD_VAR 0 8
117370: NOT
117371: AND
117372: IFFALSE 117376
// exit ;
117374: GO 119146
// depot_under_attack := false ;
117376: LD_ADDR_VAR 0 16
117380: PUSH
117381: LD_INT 0
117383: ST_TO_ADDR
// sold_defenders := [ ] ;
117384: LD_ADDR_VAR 0 17
117388: PUSH
117389: EMPTY
117390: ST_TO_ADDR
// if mechs then
117391: LD_VAR 0 12
117395: IFFALSE 117548
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117397: LD_ADDR_VAR 0 4
117401: PUSH
117402: LD_VAR 0 2
117406: PPUSH
117407: LD_INT 21
117409: PUSH
117410: LD_INT 2
117412: PUSH
117413: EMPTY
117414: LIST
117415: LIST
117416: PPUSH
117417: CALL_OW 72
117421: PUSH
117422: FOR_IN
117423: IFFALSE 117546
// begin if GetTag ( i ) <> 20 then
117425: LD_VAR 0 4
117429: PPUSH
117430: CALL_OW 110
117434: PUSH
117435: LD_INT 20
117437: NONEQUAL
117438: IFFALSE 117452
// SetTag ( i , 20 ) ;
117440: LD_VAR 0 4
117444: PPUSH
117445: LD_INT 20
117447: PPUSH
117448: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117452: LD_VAR 0 4
117456: PPUSH
117457: CALL_OW 263
117461: PUSH
117462: LD_INT 1
117464: EQUAL
117465: PUSH
117466: LD_VAR 0 4
117470: PPUSH
117471: CALL_OW 311
117475: NOT
117476: AND
117477: IFFALSE 117544
// begin un := mechs [ 1 ] ;
117479: LD_ADDR_VAR 0 10
117483: PUSH
117484: LD_VAR 0 12
117488: PUSH
117489: LD_INT 1
117491: ARRAY
117492: ST_TO_ADDR
// ComExit ( un ) ;
117493: LD_VAR 0 10
117497: PPUSH
117498: CALL 57685 0 1
// AddComEnterUnit ( un , i ) ;
117502: LD_VAR 0 10
117506: PPUSH
117507: LD_VAR 0 4
117511: PPUSH
117512: CALL_OW 180
// SetTag ( un , 19 ) ;
117516: LD_VAR 0 10
117520: PPUSH
117521: LD_INT 19
117523: PPUSH
117524: CALL_OW 109
// mechs := mechs diff un ;
117528: LD_ADDR_VAR 0 12
117532: PUSH
117533: LD_VAR 0 12
117537: PUSH
117538: LD_VAR 0 10
117542: DIFF
117543: ST_TO_ADDR
// end ; end ;
117544: GO 117422
117546: POP
117547: POP
// if solds then
117548: LD_VAR 0 8
117552: IFFALSE 117611
// for i in solds do
117554: LD_ADDR_VAR 0 4
117558: PUSH
117559: LD_VAR 0 8
117563: PUSH
117564: FOR_IN
117565: IFFALSE 117609
// if not GetTag ( i ) then
117567: LD_VAR 0 4
117571: PPUSH
117572: CALL_OW 110
117576: NOT
117577: IFFALSE 117607
// begin defenders := defenders union i ;
117579: LD_ADDR_VAR 0 2
117583: PUSH
117584: LD_VAR 0 2
117588: PUSH
117589: LD_VAR 0 4
117593: UNION
117594: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117595: LD_VAR 0 4
117599: PPUSH
117600: LD_INT 18
117602: PPUSH
117603: CALL_OW 109
// end ;
117607: GO 117564
117609: POP
117610: POP
// repeat wait ( 0 0$2 ) ;
117611: LD_INT 70
117613: PPUSH
117614: CALL_OW 67
// enemy := mc_scan [ base ] ;
117618: LD_ADDR_VAR 0 21
117622: PUSH
117623: LD_EXP 72
117627: PUSH
117628: LD_VAR 0 1
117632: ARRAY
117633: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117634: LD_EXP 49
117638: PUSH
117639: LD_VAR 0 1
117643: ARRAY
117644: NOT
117645: PUSH
117646: LD_EXP 49
117650: PUSH
117651: LD_VAR 0 1
117655: ARRAY
117656: PUSH
117657: EMPTY
117658: EQUAL
117659: OR
117660: IFFALSE 117697
// begin for i in defenders do
117662: LD_ADDR_VAR 0 4
117666: PUSH
117667: LD_VAR 0 2
117671: PUSH
117672: FOR_IN
117673: IFFALSE 117686
// ComStop ( i ) ;
117675: LD_VAR 0 4
117679: PPUSH
117680: CALL_OW 141
117684: GO 117672
117686: POP
117687: POP
// defenders := [ ] ;
117688: LD_ADDR_VAR 0 2
117692: PUSH
117693: EMPTY
117694: ST_TO_ADDR
// exit ;
117695: GO 119146
// end ; for i in defenders do
117697: LD_ADDR_VAR 0 4
117701: PUSH
117702: LD_VAR 0 2
117706: PUSH
117707: FOR_IN
117708: IFFALSE 118606
// begin e := NearestUnitToUnit ( enemy , i ) ;
117710: LD_ADDR_VAR 0 13
117714: PUSH
117715: LD_VAR 0 21
117719: PPUSH
117720: LD_VAR 0 4
117724: PPUSH
117725: CALL_OW 74
117729: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117730: LD_ADDR_VAR 0 7
117734: PUSH
117735: LD_EXP 49
117739: PUSH
117740: LD_VAR 0 1
117744: ARRAY
117745: PPUSH
117746: LD_INT 2
117748: PUSH
117749: LD_INT 30
117751: PUSH
117752: LD_INT 0
117754: PUSH
117755: EMPTY
117756: LIST
117757: LIST
117758: PUSH
117759: LD_INT 30
117761: PUSH
117762: LD_INT 1
117764: PUSH
117765: EMPTY
117766: LIST
117767: LIST
117768: PUSH
117769: EMPTY
117770: LIST
117771: LIST
117772: LIST
117773: PPUSH
117774: CALL_OW 72
117778: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117779: LD_ADDR_VAR 0 16
117783: PUSH
117784: LD_VAR 0 7
117788: NOT
117789: PUSH
117790: LD_VAR 0 7
117794: PPUSH
117795: LD_INT 3
117797: PUSH
117798: LD_INT 24
117800: PUSH
117801: LD_INT 600
117803: PUSH
117804: EMPTY
117805: LIST
117806: LIST
117807: PUSH
117808: EMPTY
117809: LIST
117810: LIST
117811: PPUSH
117812: CALL_OW 72
117816: OR
117817: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117818: LD_VAR 0 4
117822: PPUSH
117823: CALL_OW 247
117827: PUSH
117828: LD_INT 2
117830: DOUBLE
117831: EQUAL
117832: IFTRUE 117836
117834: GO 118232
117836: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
117837: LD_VAR 0 4
117841: PPUSH
117842: CALL_OW 256
117846: PUSH
117847: LD_INT 1000
117849: EQUAL
117850: PUSH
117851: LD_VAR 0 4
117855: PPUSH
117856: LD_VAR 0 13
117860: PPUSH
117861: CALL_OW 296
117865: PUSH
117866: LD_INT 40
117868: LESS
117869: PUSH
117870: LD_VAR 0 13
117874: PPUSH
117875: LD_EXP 74
117879: PUSH
117880: LD_VAR 0 1
117884: ARRAY
117885: PPUSH
117886: CALL_OW 308
117890: OR
117891: AND
117892: IFFALSE 118014
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
117894: LD_VAR 0 4
117898: PPUSH
117899: CALL_OW 262
117903: PUSH
117904: LD_INT 1
117906: EQUAL
117907: PUSH
117908: LD_VAR 0 4
117912: PPUSH
117913: CALL_OW 261
117917: PUSH
117918: LD_INT 30
117920: LESS
117921: AND
117922: PUSH
117923: LD_VAR 0 7
117927: AND
117928: IFFALSE 117998
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
117930: LD_VAR 0 4
117934: PPUSH
117935: LD_VAR 0 7
117939: PPUSH
117940: LD_VAR 0 4
117944: PPUSH
117945: CALL_OW 74
117949: PPUSH
117950: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
117954: LD_VAR 0 4
117958: PPUSH
117959: LD_VAR 0 7
117963: PPUSH
117964: LD_VAR 0 4
117968: PPUSH
117969: CALL_OW 74
117973: PPUSH
117974: CALL_OW 296
117978: PUSH
117979: LD_INT 6
117981: LESS
117982: IFFALSE 117996
// SetFuel ( i , 100 ) ;
117984: LD_VAR 0 4
117988: PPUSH
117989: LD_INT 100
117991: PPUSH
117992: CALL_OW 240
// end else
117996: GO 118012
// ComAttackUnit ( i , e ) ;
117998: LD_VAR 0 4
118002: PPUSH
118003: LD_VAR 0 13
118007: PPUSH
118008: CALL_OW 115
// end else
118012: GO 118115
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118014: LD_VAR 0 13
118018: PPUSH
118019: LD_EXP 74
118023: PUSH
118024: LD_VAR 0 1
118028: ARRAY
118029: PPUSH
118030: CALL_OW 308
118034: NOT
118035: PUSH
118036: LD_VAR 0 4
118040: PPUSH
118041: LD_VAR 0 13
118045: PPUSH
118046: CALL_OW 296
118050: PUSH
118051: LD_INT 40
118053: GREATEREQUAL
118054: AND
118055: PUSH
118056: LD_VAR 0 4
118060: PPUSH
118061: CALL_OW 256
118065: PUSH
118066: LD_INT 650
118068: LESSEQUAL
118069: OR
118070: PUSH
118071: LD_VAR 0 4
118075: PPUSH
118076: LD_EXP 73
118080: PUSH
118081: LD_VAR 0 1
118085: ARRAY
118086: PPUSH
118087: CALL_OW 308
118091: NOT
118092: AND
118093: IFFALSE 118115
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118095: LD_VAR 0 4
118099: PPUSH
118100: LD_EXP 73
118104: PUSH
118105: LD_VAR 0 1
118109: ARRAY
118110: PPUSH
118111: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118115: LD_VAR 0 4
118119: PPUSH
118120: CALL_OW 256
118124: PUSH
118125: LD_INT 1000
118127: LESS
118128: PUSH
118129: LD_VAR 0 4
118133: PPUSH
118134: CALL_OW 263
118138: PUSH
118139: LD_INT 1
118141: EQUAL
118142: AND
118143: PUSH
118144: LD_VAR 0 4
118148: PPUSH
118149: CALL_OW 311
118153: AND
118154: PUSH
118155: LD_VAR 0 4
118159: PPUSH
118160: LD_EXP 73
118164: PUSH
118165: LD_VAR 0 1
118169: ARRAY
118170: PPUSH
118171: CALL_OW 308
118175: AND
118176: IFFALSE 118230
// begin mech := IsDrivenBy ( i ) ;
118178: LD_ADDR_VAR 0 9
118182: PUSH
118183: LD_VAR 0 4
118187: PPUSH
118188: CALL_OW 311
118192: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118193: LD_VAR 0 9
118197: PPUSH
118198: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118202: LD_VAR 0 9
118206: PPUSH
118207: LD_VAR 0 4
118211: PPUSH
118212: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118216: LD_VAR 0 9
118220: PPUSH
118221: LD_VAR 0 4
118225: PPUSH
118226: CALL_OW 180
// end ; end ; unit_human :
118230: GO 118577
118232: LD_INT 1
118234: DOUBLE
118235: EQUAL
118236: IFTRUE 118240
118238: GO 118576
118240: POP
// begin b := IsInUnit ( i ) ;
118241: LD_ADDR_VAR 0 18
118245: PUSH
118246: LD_VAR 0 4
118250: PPUSH
118251: CALL_OW 310
118255: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118256: LD_ADDR_VAR 0 19
118260: PUSH
118261: LD_VAR 0 18
118265: NOT
118266: PUSH
118267: LD_VAR 0 18
118271: PPUSH
118272: CALL_OW 266
118276: PUSH
118277: LD_INT 32
118279: PUSH
118280: LD_INT 31
118282: PUSH
118283: EMPTY
118284: LIST
118285: LIST
118286: IN
118287: OR
118288: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118289: LD_VAR 0 18
118293: PPUSH
118294: CALL_OW 266
118298: PUSH
118299: LD_INT 5
118301: EQUAL
118302: PUSH
118303: LD_VAR 0 4
118307: PPUSH
118308: CALL_OW 257
118312: PUSH
118313: LD_INT 1
118315: PUSH
118316: LD_INT 2
118318: PUSH
118319: LD_INT 3
118321: PUSH
118322: LD_INT 4
118324: PUSH
118325: EMPTY
118326: LIST
118327: LIST
118328: LIST
118329: LIST
118330: IN
118331: AND
118332: IFFALSE 118369
// begin class := AllowSpecClass ( i ) ;
118334: LD_ADDR_VAR 0 20
118338: PUSH
118339: LD_VAR 0 4
118343: PPUSH
118344: CALL 21672 0 1
118348: ST_TO_ADDR
// if class then
118349: LD_VAR 0 20
118353: IFFALSE 118369
// ComChangeProfession ( i , class ) ;
118355: LD_VAR 0 4
118359: PPUSH
118360: LD_VAR 0 20
118364: PPUSH
118365: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118369: LD_VAR 0 16
118373: PUSH
118374: LD_VAR 0 2
118378: PPUSH
118379: LD_INT 21
118381: PUSH
118382: LD_INT 2
118384: PUSH
118385: EMPTY
118386: LIST
118387: LIST
118388: PPUSH
118389: CALL_OW 72
118393: PUSH
118394: LD_INT 1
118396: LESSEQUAL
118397: OR
118398: PUSH
118399: LD_VAR 0 19
118403: AND
118404: PUSH
118405: LD_VAR 0 4
118409: PUSH
118410: LD_VAR 0 17
118414: IN
118415: NOT
118416: AND
118417: IFFALSE 118510
// begin if b then
118419: LD_VAR 0 18
118423: IFFALSE 118472
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118425: LD_VAR 0 18
118429: PPUSH
118430: LD_VAR 0 21
118434: PPUSH
118435: LD_VAR 0 18
118439: PPUSH
118440: CALL_OW 74
118444: PPUSH
118445: CALL_OW 296
118449: PUSH
118450: LD_INT 10
118452: LESS
118453: PUSH
118454: LD_VAR 0 18
118458: PPUSH
118459: CALL_OW 461
118463: PUSH
118464: LD_INT 7
118466: NONEQUAL
118467: AND
118468: IFFALSE 118472
// continue ;
118470: GO 117707
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118472: LD_ADDR_VAR 0 17
118476: PUSH
118477: LD_VAR 0 17
118481: PPUSH
118482: LD_VAR 0 17
118486: PUSH
118487: LD_INT 1
118489: PLUS
118490: PPUSH
118491: LD_VAR 0 4
118495: PPUSH
118496: CALL_OW 1
118500: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118501: LD_VAR 0 4
118505: PPUSH
118506: CALL_OW 122
// end ; if sold_defenders then
118510: LD_VAR 0 17
118514: IFFALSE 118574
// if i in sold_defenders then
118516: LD_VAR 0 4
118520: PUSH
118521: LD_VAR 0 17
118525: IN
118526: IFFALSE 118574
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118528: LD_VAR 0 4
118532: PPUSH
118533: CALL_OW 314
118537: NOT
118538: PUSH
118539: LD_VAR 0 4
118543: PPUSH
118544: LD_VAR 0 13
118548: PPUSH
118549: CALL_OW 296
118553: PUSH
118554: LD_INT 30
118556: LESS
118557: AND
118558: IFFALSE 118574
// ComAttackUnit ( i , e ) ;
118560: LD_VAR 0 4
118564: PPUSH
118565: LD_VAR 0 13
118569: PPUSH
118570: CALL_OW 115
// end ; end ; end ;
118574: GO 118577
118576: POP
// if IsDead ( i ) then
118577: LD_VAR 0 4
118581: PPUSH
118582: CALL_OW 301
118586: IFFALSE 118604
// defenders := defenders diff i ;
118588: LD_ADDR_VAR 0 2
118592: PUSH
118593: LD_VAR 0 2
118597: PUSH
118598: LD_VAR 0 4
118602: DIFF
118603: ST_TO_ADDR
// end ;
118604: GO 117707
118606: POP
118607: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118608: LD_VAR 0 21
118612: NOT
118613: PUSH
118614: LD_VAR 0 2
118618: NOT
118619: OR
118620: PUSH
118621: LD_EXP 49
118625: PUSH
118626: LD_VAR 0 1
118630: ARRAY
118631: NOT
118632: OR
118633: IFFALSE 117611
// MC_Reset ( base , 18 ) ;
118635: LD_VAR 0 1
118639: PPUSH
118640: LD_INT 18
118642: PPUSH
118643: CALL 65416 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118647: LD_ADDR_VAR 0 2
118651: PUSH
118652: LD_VAR 0 2
118656: PUSH
118657: LD_VAR 0 2
118661: PPUSH
118662: LD_INT 2
118664: PUSH
118665: LD_INT 25
118667: PUSH
118668: LD_INT 1
118670: PUSH
118671: EMPTY
118672: LIST
118673: LIST
118674: PUSH
118675: LD_INT 25
118677: PUSH
118678: LD_INT 5
118680: PUSH
118681: EMPTY
118682: LIST
118683: LIST
118684: PUSH
118685: LD_INT 25
118687: PUSH
118688: LD_INT 8
118690: PUSH
118691: EMPTY
118692: LIST
118693: LIST
118694: PUSH
118695: LD_INT 25
118697: PUSH
118698: LD_INT 9
118700: PUSH
118701: EMPTY
118702: LIST
118703: LIST
118704: PUSH
118705: EMPTY
118706: LIST
118707: LIST
118708: LIST
118709: LIST
118710: LIST
118711: PPUSH
118712: CALL_OW 72
118716: DIFF
118717: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118718: LD_VAR 0 21
118722: NOT
118723: PUSH
118724: LD_VAR 0 2
118728: PPUSH
118729: LD_INT 21
118731: PUSH
118732: LD_INT 2
118734: PUSH
118735: EMPTY
118736: LIST
118737: LIST
118738: PPUSH
118739: CALL_OW 72
118743: AND
118744: IFFALSE 119082
// begin tmp := FilterByTag ( defenders , 19 ) ;
118746: LD_ADDR_VAR 0 11
118750: PUSH
118751: LD_VAR 0 2
118755: PPUSH
118756: LD_INT 19
118758: PPUSH
118759: CALL 54861 0 2
118763: ST_TO_ADDR
// if tmp then
118764: LD_VAR 0 11
118768: IFFALSE 118838
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118770: LD_ADDR_VAR 0 11
118774: PUSH
118775: LD_VAR 0 11
118779: PPUSH
118780: LD_INT 25
118782: PUSH
118783: LD_INT 3
118785: PUSH
118786: EMPTY
118787: LIST
118788: LIST
118789: PPUSH
118790: CALL_OW 72
118794: ST_TO_ADDR
// if tmp then
118795: LD_VAR 0 11
118799: IFFALSE 118838
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118801: LD_ADDR_EXP 61
118805: PUSH
118806: LD_EXP 61
118810: PPUSH
118811: LD_VAR 0 1
118815: PPUSH
118816: LD_EXP 61
118820: PUSH
118821: LD_VAR 0 1
118825: ARRAY
118826: PUSH
118827: LD_VAR 0 11
118831: UNION
118832: PPUSH
118833: CALL_OW 1
118837: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
118838: LD_VAR 0 1
118842: PPUSH
118843: LD_INT 19
118845: PPUSH
118846: CALL 65416 0 2
// repeat wait ( 0 0$1 ) ;
118850: LD_INT 35
118852: PPUSH
118853: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118857: LD_EXP 49
118861: PUSH
118862: LD_VAR 0 1
118866: ARRAY
118867: NOT
118868: PUSH
118869: LD_EXP 49
118873: PUSH
118874: LD_VAR 0 1
118878: ARRAY
118879: PUSH
118880: EMPTY
118881: EQUAL
118882: OR
118883: IFFALSE 118920
// begin for i in defenders do
118885: LD_ADDR_VAR 0 4
118889: PUSH
118890: LD_VAR 0 2
118894: PUSH
118895: FOR_IN
118896: IFFALSE 118909
// ComStop ( i ) ;
118898: LD_VAR 0 4
118902: PPUSH
118903: CALL_OW 141
118907: GO 118895
118909: POP
118910: POP
// defenders := [ ] ;
118911: LD_ADDR_VAR 0 2
118915: PUSH
118916: EMPTY
118917: ST_TO_ADDR
// exit ;
118918: GO 119146
// end ; for i in defenders do
118920: LD_ADDR_VAR 0 4
118924: PUSH
118925: LD_VAR 0 2
118929: PUSH
118930: FOR_IN
118931: IFFALSE 119020
// begin if not IsInArea ( i , mc_parking [ base ] ) then
118933: LD_VAR 0 4
118937: PPUSH
118938: LD_EXP 73
118942: PUSH
118943: LD_VAR 0 1
118947: ARRAY
118948: PPUSH
118949: CALL_OW 308
118953: NOT
118954: IFFALSE 118978
// ComMoveToArea ( i , mc_parking [ base ] ) else
118956: LD_VAR 0 4
118960: PPUSH
118961: LD_EXP 73
118965: PUSH
118966: LD_VAR 0 1
118970: ARRAY
118971: PPUSH
118972: CALL_OW 113
118976: GO 119018
// if GetControl ( i ) = control_manual then
118978: LD_VAR 0 4
118982: PPUSH
118983: CALL_OW 263
118987: PUSH
118988: LD_INT 1
118990: EQUAL
118991: IFFALSE 119018
// if IsDrivenBy ( i ) then
118993: LD_VAR 0 4
118997: PPUSH
118998: CALL_OW 311
119002: IFFALSE 119018
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119004: LD_VAR 0 4
119008: PPUSH
119009: CALL_OW 311
119013: PPUSH
119014: CALL_OW 121
// end ;
119018: GO 118930
119020: POP
119021: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119022: LD_VAR 0 2
119026: PPUSH
119027: LD_INT 95
119029: PUSH
119030: LD_EXP 73
119034: PUSH
119035: LD_VAR 0 1
119039: ARRAY
119040: PUSH
119041: EMPTY
119042: LIST
119043: LIST
119044: PPUSH
119045: CALL_OW 72
119049: PUSH
119050: LD_VAR 0 2
119054: EQUAL
119055: PUSH
119056: LD_EXP 72
119060: PUSH
119061: LD_VAR 0 1
119065: ARRAY
119066: OR
119067: PUSH
119068: LD_EXP 49
119072: PUSH
119073: LD_VAR 0 1
119077: ARRAY
119078: NOT
119079: OR
119080: IFFALSE 118850
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119082: LD_ADDR_EXP 71
119086: PUSH
119087: LD_EXP 71
119091: PPUSH
119092: LD_VAR 0 1
119096: PPUSH
119097: LD_VAR 0 2
119101: PPUSH
119102: LD_INT 21
119104: PUSH
119105: LD_INT 2
119107: PUSH
119108: EMPTY
119109: LIST
119110: LIST
119111: PPUSH
119112: CALL_OW 72
119116: PPUSH
119117: CALL_OW 1
119121: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119122: LD_VAR 0 1
119126: PPUSH
119127: LD_INT 19
119129: PPUSH
119130: CALL 65416 0 2
// MC_Reset ( base , 20 ) ;
119134: LD_VAR 0 1
119138: PPUSH
119139: LD_INT 20
119141: PPUSH
119142: CALL 65416 0 2
// end ; end_of_file
119146: LD_VAR 0 3
119150: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119151: LD_VAR 0 1
119155: PUSH
119156: LD_INT 200
119158: DOUBLE
119159: GREATEREQUAL
119160: IFFALSE 119168
119162: LD_INT 299
119164: DOUBLE
119165: LESSEQUAL
119166: IFTRUE 119170
119168: GO 119202
119170: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119171: LD_VAR 0 1
119175: PPUSH
119176: LD_VAR 0 2
119180: PPUSH
119181: LD_VAR 0 3
119185: PPUSH
119186: LD_VAR 0 4
119190: PPUSH
119191: LD_VAR 0 5
119195: PPUSH
119196: CALL 107917 0 5
119200: GO 119279
119202: LD_INT 300
119204: DOUBLE
119205: GREATEREQUAL
119206: IFFALSE 119214
119208: LD_INT 399
119210: DOUBLE
119211: LESSEQUAL
119212: IFTRUE 119216
119214: GO 119278
119216: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119217: LD_VAR 0 1
119221: PPUSH
119222: LD_VAR 0 2
119226: PPUSH
119227: LD_VAR 0 3
119231: PPUSH
119232: LD_VAR 0 4
119236: PPUSH
119237: LD_VAR 0 5
119241: PPUSH
119242: LD_VAR 0 6
119246: PPUSH
119247: LD_VAR 0 7
119251: PPUSH
119252: LD_VAR 0 8
119256: PPUSH
119257: LD_VAR 0 9
119261: PPUSH
119262: LD_VAR 0 10
119266: PPUSH
119267: LD_VAR 0 11
119271: PPUSH
119272: CALL 104246 0 11
119276: GO 119279
119278: POP
// end ;
119279: PPOPN 11
119281: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119282: LD_VAR 0 1
119286: PPUSH
119287: LD_VAR 0 2
119291: PPUSH
119292: LD_VAR 0 3
119296: PPUSH
119297: LD_VAR 0 4
119301: PPUSH
119302: LD_VAR 0 5
119306: PPUSH
119307: CALL 107653 0 5
// end ; end_of_file
119311: PPOPN 5
119313: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119314: LD_VAR 0 1
119318: PPUSH
119319: LD_VAR 0 2
119323: PPUSH
119324: LD_VAR 0 3
119328: PPUSH
119329: LD_VAR 0 4
119333: PPUSH
119334: LD_VAR 0 5
119338: PPUSH
119339: LD_VAR 0 6
119343: PPUSH
119344: CALL 91939 0 6
// end ;
119348: PPOPN 6
119350: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119351: LD_INT 0
119353: PPUSH
// begin if not units then
119354: LD_VAR 0 1
119358: NOT
119359: IFFALSE 119363
// exit ;
119361: GO 119363
// end ;
119363: PPOPN 7
119365: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119366: CALL 91910 0 0
// end ;
119370: PPOPN 1
119372: END
