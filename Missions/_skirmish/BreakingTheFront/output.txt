// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 602 0 0
// SetDiplomacy ;
  42: CALL 814 0 0
// PrepareGame ;
  46: CALL 896 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := 0 ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 0 0$1 trigger game and GameType = 1 and not disableGlobalTimer do
 229: LD_EXP 3
 233: PUSH
 234: LD_EXP 2
 238: PUSH
 239: LD_INT 1
 241: EQUAL
 242: AND
 243: PUSH
 244: LD_EXP 4
 248: NOT
 249: AND
 250: IFFALSE 273
 252: GO 254
 254: DISABLE
// begin enable ;
 255: ENABLE
// display_strings := [ #SkrTime , tick ] ;
 256: LD_ADDR_OWVAR 47
 260: PUSH
 261: LD_STRING #SkrTime
 263: PUSH
 264: LD_OWVAR 1
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: ST_TO_ADDR
// end ;
 273: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 274: LD_EXP 19
 278: PUSH
 279: LD_EXP 3
 283: AND
 284: PUSH
 285: LD_EXP 2
 289: PUSH
 290: LD_INT 1
 292: EQUAL
 293: AND
 294: IFFALSE 355
 296: GO 298
 298: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 299: LD_EXP 19
 303: PUSH
 304: LD_INT 1
 306: ARRAY
 307: PUSH
 308: LD_INT 1
 310: ARRAY
 311: PPUSH
 312: LD_EXP 19
 316: PUSH
 317: LD_INT 1
 319: ARRAY
 320: PUSH
 321: LD_INT 2
 323: ARRAY
 324: PPUSH
 325: LD_EXP 19
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 3
 336: ARRAY
 337: PPUSH
 338: LD_EXP 19
 342: PUSH
 343: LD_INT 1
 345: ARRAY
 346: PUSH
 347: LD_INT 4
 349: ARRAY
 350: PPUSH
 351: CALL 56910 0 4
 355: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 356: LD_EXP 19
 360: PUSH
 361: LD_EXP 3
 365: AND
 366: PUSH
 367: LD_EXP 2
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: IFFALSE 437
 378: GO 380
 380: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 381: LD_EXP 19
 385: PUSH
 386: LD_INT 2
 388: ARRAY
 389: PUSH
 390: LD_INT 1
 392: ARRAY
 393: PPUSH
 394: LD_EXP 19
 398: PUSH
 399: LD_INT 2
 401: ARRAY
 402: PUSH
 403: LD_INT 2
 405: ARRAY
 406: PPUSH
 407: LD_EXP 19
 411: PUSH
 412: LD_INT 2
 414: ARRAY
 415: PUSH
 416: LD_INT 3
 418: ARRAY
 419: PPUSH
 420: LD_EXP 19
 424: PUSH
 425: LD_INT 2
 427: ARRAY
 428: PUSH
 429: LD_INT 4
 431: ARRAY
 432: PPUSH
 433: CALL 56910 0 4
 437: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 438: LD_EXP 19
 442: PUSH
 443: LD_EXP 3
 447: AND
 448: PUSH
 449: LD_EXP 2
 453: PUSH
 454: LD_INT 1
 456: EQUAL
 457: AND
 458: IFFALSE 519
 460: GO 462
 462: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 463: LD_EXP 19
 467: PUSH
 468: LD_INT 3
 470: ARRAY
 471: PUSH
 472: LD_INT 1
 474: ARRAY
 475: PPUSH
 476: LD_EXP 19
 480: PUSH
 481: LD_INT 3
 483: ARRAY
 484: PUSH
 485: LD_INT 2
 487: ARRAY
 488: PPUSH
 489: LD_EXP 19
 493: PUSH
 494: LD_INT 3
 496: ARRAY
 497: PUSH
 498: LD_INT 3
 500: ARRAY
 501: PPUSH
 502: LD_EXP 19
 506: PUSH
 507: LD_INT 3
 509: ARRAY
 510: PUSH
 511: LD_INT 4
 513: ARRAY
 514: PPUSH
 515: CALL 56910 0 4
 519: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 520: LD_EXP 19
 524: PUSH
 525: LD_EXP 3
 529: AND
 530: PUSH
 531: LD_EXP 2
 535: PUSH
 536: LD_INT 1
 538: EQUAL
 539: AND
 540: IFFALSE 601
 542: GO 544
 544: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 545: LD_EXP 19
 549: PUSH
 550: LD_INT 4
 552: ARRAY
 553: PUSH
 554: LD_INT 1
 556: ARRAY
 557: PPUSH
 558: LD_EXP 19
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PPUSH
 571: LD_EXP 19
 575: PUSH
 576: LD_INT 4
 578: ARRAY
 579: PUSH
 580: LD_INT 3
 582: ARRAY
 583: PPUSH
 584: LD_EXP 19
 588: PUSH
 589: LD_INT 4
 591: ARRAY
 592: PUSH
 593: LD_INT 4
 595: ARRAY
 596: PPUSH
 597: CALL 56910 0 4
 601: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 602: LD_INT 0
 604: PPUSH
 605: PPUSH
 606: PPUSH
 607: PPUSH
 608: PPUSH
// if GameType = 1 then
 609: LD_EXP 2
 613: PUSH
 614: LD_INT 1
 616: EQUAL
 617: IFFALSE 686
// begin ban_techs := [ ] ;
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// if sibBombAllowed < 2 then
 626: LD_EXP 23
 630: PUSH
 631: LD_INT 2
 633: LESS
 634: IFFALSE 647
// ban_techs := [ tech_sibFiss ] ;
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: LD_INT 25
 643: PUSH
 644: EMPTY
 645: LIST
 646: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_INT 46
 654: PUSH
 655: LD_INT 47
 657: PUSH
 658: LD_INT 48
 660: PUSH
 661: LD_INT 49
 663: PUSH
 664: LD_INT 50
 666: PUSH
 667: LD_INT 39
 669: PUSH
 670: LD_INT 69
 672: PUSH
 673: LD_INT 40
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: ST_TO_ADDR
// end ; for i = 1 to 8 do
 686: LD_ADDR_VAR 0 2
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_INT 8
 698: PUSH
 699: FOR_TO
 700: IFFALSE 784
// begin if res_techs then
 702: LD_VAR 0 5
 706: IFFALSE 742
// for j in res_techs do
 708: LD_ADDR_VAR 0 3
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: FOR_IN
 719: IFFALSE 740
// SetTech ( j , i , state_researched ) ;
 721: LD_VAR 0 3
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: LD_INT 2
 733: PPUSH
 734: CALL_OW 322
 738: GO 718
 740: POP
 741: POP
// if ban_techs then
 742: LD_VAR 0 4
 746: IFFALSE 782
// for j in ban_techs do
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_VAR 0 4
 757: PUSH
 758: FOR_IN
 759: IFFALSE 780
// SetTech ( j , i , state_disabled ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 322
 778: GO 758
 780: POP
 781: POP
// end ;
 782: GO 699
 784: POP
 785: POP
// if sibBombAllowed = 1 then
 786: LD_EXP 23
 790: PUSH
 791: LD_INT 1
 793: EQUAL
 794: IFFALSE 809
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 796: LD_INT 25
 798: PPUSH
 799: LD_INT 3
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 322
// end ;
 809: LD_VAR 0 1
 813: RET
// export function SetDiplomacy ; begin
 814: LD_INT 0
 816: PPUSH
// if GameType = 1 then
 817: LD_EXP 2
 821: PUSH
 822: LD_INT 1
 824: EQUAL
 825: IFFALSE 891
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 827: LD_INT 1
 829: PPUSH
 830: LD_INT 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 843: LD_INT 3
 845: PPUSH
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 8
 864: PPUSH
 865: LD_INT 1
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 875: LD_INT 6
 877: PPUSH
 878: LD_INT 8
 880: PPUSH
 881: LD_INT 1
 883: PPUSH
 884: LD_INT 1
 886: PPUSH
 887: CALL_OW 80
// end ; end ;
 891: LD_VAR 0 1
 895: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 896: LD_INT 0
 898: PPUSH
 899: PPUSH
 900: PPUSH
 901: PPUSH
// if GameType = 1 then
 902: LD_EXP 2
 906: PUSH
 907: LD_INT 1
 909: EQUAL
 910: IFFALSE 1406
// begin game := false ;
 912: LD_ADDR_EXP 3
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// your_side := 1 ;
 920: LD_ADDR_OWVAR 2
 924: PUSH
 925: LD_INT 1
 927: ST_TO_ADDR
// mc_amer := 1 ;
 928: LD_ADDR_EXP 5
 932: PUSH
 933: LD_INT 1
 935: ST_TO_ADDR
// mc_leg := 2 ;
 936: LD_ADDR_EXP 6
 940: PUSH
 941: LD_INT 2
 943: ST_TO_ADDR
// mc_rus_1 := 3 ;
 944: LD_ADDR_EXP 7
 948: PUSH
 949: LD_INT 3
 951: ST_TO_ADDR
// mc_rus_2 := 4 ;
 952: LD_ADDR_EXP 8
 956: PUSH
 957: LD_INT 4
 959: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 960: LD_ADDR_EXP 19
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: LD_INT 200
 976: PUSH
 977: LD_INT 250
 979: PUSH
 980: LD_INT 300
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_EXP 26
 992: ARRAY
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 13
1002: PUSH
1003: LD_INT 8
1005: PUSH
1006: LD_INT 50
1008: PUSH
1009: LD_INT 500
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 17
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 50
1026: PUSH
1027: LD_INT 300
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 18
1038: PUSH
1039: LD_INT 4
1041: PUSH
1042: LD_INT 5
1044: PUSH
1045: LD_INT 6
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_EXP 26
1057: ARRAY
1058: PUSH
1059: LD_INT 30
1061: PUSH
1062: LD_INT 300
1064: PUSH
1065: LD_INT 450
1067: PUSH
1068: LD_INT 500
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_EXP 26
1080: ARRAY
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: LD_INT 190
1101: PUSH
1102: LD_INT 193
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 182
1115: PUSH
1116: LD_INT 117
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 114
1143: PUSH
1144: LD_INT 152
1146: PUSH
1147: LD_INT 2
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 85
1157: PUSH
1158: LD_INT 38
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i in sources do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: PUSH
1186: FOR_IN
1187: IFFALSE 1222
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1189: LD_VAR 0 2
1193: PUSH
1194: LD_INT 1
1196: ARRAY
1197: PPUSH
1198: LD_VAR 0 2
1202: PUSH
1203: LD_INT 2
1205: ARRAY
1206: PPUSH
1207: LD_VAR 0 2
1211: PUSH
1212: LD_INT 3
1214: ARRAY
1215: PPUSH
1216: CALL_OW 62
1220: GO 1186
1222: POP
1223: POP
// disableGlobalTimer := false ;
1224: LD_ADDR_EXP 4
1228: PUSH
1229: LD_INT 0
1231: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1232: LD_ADDR_EXP 15
1236: PUSH
1237: LD_INT 0
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_OWVAR 67
1258: ARRAY
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: ST_TO_ADDR
// ruOutpost := [ ] ;
1264: LD_ADDR_EXP 14
1268: PUSH
1269: EMPTY
1270: ST_TO_ADDR
// staticMines := [ ] ;
1271: LD_ADDR_EXP 16
1275: PUSH
1276: EMPTY
1277: ST_TO_ADDR
// baseCaptured := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// legDestCounter := 0 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 0
1293: ST_TO_ADDR
// legOfferAccepted := false ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_INT 0
1301: ST_TO_ADDR
// legChangeSide := false ;
1302: LD_ADDR_EXP 21
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// allyDestCounter := 0 ;
1310: LD_ADDR_EXP 22
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// outpostEscape := false ;
1318: LD_ADDR_EXP 27
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// dialogueMineDetected := false ;
1326: LD_ADDR_EXP 28
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// PrepareAmericans ;
1334: CALL 7604 0 0
// PrepareLegion ;
1338: CALL 5538 0 0
// PrepareRussians ;
1342: CALL 2504 0 0
// playerForces := PreparePlayer ;
1346: LD_ADDR_EXP 10
1350: PUSH
1351: CALL 8847 0 0
1355: ST_TO_ADDR
// AnimateTrees ( true ) ;
1356: LD_INT 1
1358: PPUSH
1359: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1363: LD_INT 4
1365: PPUSH
1366: LD_INT 3
1368: PPUSH
1369: LD_INT 8
1371: PPUSH
1372: LD_INT 5
1374: PPUSH
1375: LD_INT 3
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 8
1383: PPUSH
1384: LD_INT 2
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: CALL 54263 0 9
// MC_Start ;
1394: CALL 63988 0 0
// SetAdditionalRussianForces ;
1398: CALL 7273 0 0
// Action ;
1402: CALL 11204 0 0
// end ; end ;
1406: LD_VAR 0 1
1410: RET
// export function CustomInitMacro ; begin
1411: LD_INT 0
1413: PPUSH
// if GameType <> 1 then
1414: LD_EXP 2
1418: PUSH
1419: LD_INT 1
1421: NONEQUAL
1422: IFFALSE 1426
// exit ;
1424: GO 2499
// MC_SetScanArea ( mc_amer , amerBase ) ;
1426: LD_EXP 5
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: CALL 87363 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1438: LD_EXP 5
1442: PPUSH
1443: LD_INT 4
1445: PPUSH
1446: CALL 87307 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1450: LD_EXP 5
1454: PPUSH
1455: LD_INT 11
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 7
1463: PUSH
1464: LD_INT 9
1466: PUSH
1467: LD_INT 10
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: PPUSH
1477: CALL 87195 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1481: LD_EXP 5
1485: PPUSH
1486: LD_INT 5
1488: PPUSH
1489: CALL 86877 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1493: LD_EXP 5
1497: PPUSH
1498: LD_INT 3
1500: PPUSH
1501: CALL 86608 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1505: LD_EXP 5
1509: PPUSH
1510: LD_INT 4
1512: PPUSH
1513: CALL 86227 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1517: LD_EXP 5
1521: PPUSH
1522: LD_INT 3
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 2
1530: PUSH
1531: LD_INT 5
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: LD_INT 9
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 4
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: LD_INT 2
1566: PUSH
1567: LD_INT 7
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: PUSH
1576: LD_INT 4
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: LD_INT 2
1584: PUSH
1585: LD_INT 6
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL 86042 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1604: LD_EXP 5
1608: PPUSH
1609: LD_INT 33
1611: PUSH
1612: LD_INT 114
1614: PUSH
1615: LD_INT 16
1617: PUSH
1618: LD_INT 0
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 110
1632: PUSH
1633: LD_INT 12
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL 85934 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1653: LD_EXP 5
1657: PPUSH
1658: LD_INT 10
1660: PUSH
1661: LD_INT 15
1663: PUSH
1664: LD_INT 12
1666: PUSH
1667: LD_INT 11
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL 86784 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1680: LD_EXP 6
1684: PPUSH
1685: LD_INT 6
1687: PPUSH
1688: CALL 87363 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1692: LD_EXP 6
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL 87307 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1704: LD_EXP 6
1708: PPUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 27
1714: PUSH
1715: LD_INT 28
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL 87195 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1731: LD_EXP 6
1735: PPUSH
1736: LD_INT 17
1738: PPUSH
1739: CALL 86877 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1743: LD_EXP 6
1747: PPUSH
1748: LD_INT 6
1750: PPUSH
1751: CALL 86608 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1755: LD_EXP 6
1759: PPUSH
1760: LD_INT 5
1762: PPUSH
1763: CALL 86227 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1767: LD_EXP 6
1771: PPUSH
1772: LD_INT 10
1774: PPUSH
1775: LD_INT 9
1777: PPUSH
1778: CALL 85705 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1782: LD_EXP 6
1786: PPUSH
1787: LD_INT 4
1789: PUSH
1790: LD_INT 157
1792: PUSH
1793: LD_INT 144
1795: PUSH
1796: LD_INT 0
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 32
1807: PUSH
1808: LD_INT 151
1810: PUSH
1811: LD_INT 142
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 32
1825: PUSH
1826: LD_INT 161
1828: PUSH
1829: LD_INT 144
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 32
1843: PUSH
1844: LD_INT 140
1846: PUSH
1847: LD_INT 133
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL 85934 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1869: LD_EXP 6
1873: PPUSH
1874: LD_INT 13
1876: PUSH
1877: LD_INT 2
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 31
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 13
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 31
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 13
1912: PUSH
1913: LD_INT 1
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 27
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: LD_INT 13
1930: PUSH
1931: LD_INT 1
1933: PUSH
1934: LD_INT 2
1936: PUSH
1937: LD_INT 27
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: PUSH
1946: LD_INT 13
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 27
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 13
1966: PUSH
1967: LD_INT 1
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 28
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 13
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 28
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 13
2002: PUSH
2003: LD_INT 1
2005: PUSH
2006: LD_INT 2
2008: PUSH
2009: LD_INT 32
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_INT 13
2020: PUSH
2021: LD_INT 1
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 88
2029: PUSH
2030: EMPTY
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 86042 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2051: LD_INT 165
2053: PPUSH
2054: LD_INT 156
2056: PPUSH
2057: LD_INT 8
2059: PPUSH
2060: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2064: LD_EXP 7
2068: PPUSH
2069: LD_INT 15
2071: PPUSH
2072: CALL 87363 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2076: LD_EXP 7
2080: PPUSH
2081: LD_INT 16
2083: PPUSH
2084: CALL 87307 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2088: LD_EXP 7
2092: PPUSH
2093: LD_INT 43
2095: PUSH
2096: LD_INT 47
2098: PUSH
2099: LD_INT 45
2101: PUSH
2102: LD_INT 49
2104: PUSH
2105: LD_INT 46
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PPUSH
2115: CALL 87195 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2119: LD_EXP 7
2123: PPUSH
2124: LD_INT 13
2126: PPUSH
2127: CALL 86877 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2131: LD_EXP 7
2135: PPUSH
2136: LD_INT 15
2138: PPUSH
2139: CALL 86608 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2143: LD_EXP 7
2147: PPUSH
2148: LD_INT 5
2150: PPUSH
2151: CALL 86227 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2155: LD_EXP 7
2159: PPUSH
2160: LD_INT 23
2162: PUSH
2163: LD_INT 1
2165: PUSH
2166: LD_INT 3
2168: PUSH
2169: LD_INT 46
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: PUSH
2178: LD_INT 23
2180: PUSH
2181: LD_INT 1
2183: PUSH
2184: LD_INT 1
2186: PUSH
2187: LD_INT 46
2189: PUSH
2190: EMPTY
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_INT 23
2198: PUSH
2199: LD_INT 1
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 45
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 23
2216: PUSH
2217: LD_INT 1
2219: PUSH
2220: LD_INT 1
2222: PUSH
2223: LD_INT 47
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 23
2234: PUSH
2235: LD_INT 1
2237: PUSH
2238: LD_INT 3
2240: PUSH
2241: LD_INT 46
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 21
2252: PUSH
2253: LD_INT 1
2255: PUSH
2256: LD_INT 3
2258: PUSH
2259: LD_INT 51
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: LD_INT 21
2270: PUSH
2271: LD_INT 1
2273: PUSH
2274: LD_INT 3
2276: PUSH
2277: LD_INT 52
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: LIST
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: PPUSH
2295: CALL 86042 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2299: LD_EXP 8
2303: PPUSH
2304: LD_INT 11
2306: PPUSH
2307: CALL 87363 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2311: LD_EXP 8
2315: PPUSH
2316: LD_INT 12
2318: PPUSH
2319: CALL 87307 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2323: LD_EXP 8
2327: PPUSH
2328: LD_INT 43
2330: PUSH
2331: LD_INT 47
2333: PUSH
2334: LD_INT 45
2336: PUSH
2337: LD_INT 49
2339: PUSH
2340: LD_INT 46
2342: PUSH
2343: EMPTY
2344: LIST
2345: LIST
2346: LIST
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL 87195 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2354: LD_EXP 8
2358: PPUSH
2359: LD_INT 13
2361: PPUSH
2362: CALL 86877 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2366: LD_EXP 8
2370: PPUSH
2371: LD_INT 11
2373: PPUSH
2374: CALL 86608 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2378: LD_EXP 8
2382: PPUSH
2383: LD_INT 4
2385: PPUSH
2386: CALL 86227 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2390: LD_EXP 8
2394: PPUSH
2395: LD_INT 115
2397: PUSH
2398: LD_INT 201
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: EMPTY
2406: LIST
2407: PPUSH
2408: CALL 86933 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2412: LD_EXP 8
2416: PPUSH
2417: LD_INT 24
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 3
2425: PUSH
2426: LD_INT 46
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_INT 24
2437: PUSH
2438: LD_INT 3
2440: PUSH
2441: LD_INT 3
2443: PUSH
2444: LD_INT 46
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 24
2455: PUSH
2456: LD_INT 3
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 46
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 24
2473: PUSH
2474: LD_INT 3
2476: PUSH
2477: LD_INT 3
2479: PUSH
2480: LD_INT 46
2482: PUSH
2483: EMPTY
2484: LIST
2485: LIST
2486: LIST
2487: LIST
2488: PUSH
2489: EMPTY
2490: LIST
2491: LIST
2492: LIST
2493: LIST
2494: PPUSH
2495: CALL 86042 0 2
// end ;
2499: LD_VAR 0 1
2503: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2504: LD_INT 0
2506: PPUSH
2507: PPUSH
2508: PPUSH
2509: PPUSH
2510: PPUSH
2511: PPUSH
2512: PPUSH
2513: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2514: LD_INT 0
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: LD_INT 0
2525: PPUSH
2526: LD_INT 0
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 0
2534: PPUSH
2535: LD_INT 14
2537: PPUSH
2538: LD_INT 0
2540: PPUSH
2541: CALL 54263 0 9
// side := 3 ;
2545: LD_ADDR_VAR 0 5
2549: PUSH
2550: LD_INT 3
2552: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2553: LD_INT 38
2555: PPUSH
2556: LD_VAR 0 5
2560: PPUSH
2561: LD_INT 2
2563: PPUSH
2564: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2568: LD_INT 39
2570: PPUSH
2571: LD_VAR 0 5
2575: PPUSH
2576: LD_INT 2
2578: PPUSH
2579: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2583: LD_INT 34
2585: PPUSH
2586: LD_VAR 0 5
2590: PPUSH
2591: LD_INT 2
2593: PPUSH
2594: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2598: LD_ADDR_VAR 0 4
2602: PUSH
2603: LD_INT 0
2605: PUSH
2606: LD_INT 208
2608: PUSH
2609: LD_INT 163
2611: PUSH
2612: LD_INT 4
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: LD_INT 0
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 3
2631: PUSH
2632: LD_INT 194
2634: PUSH
2635: LD_INT 161
2637: PUSH
2638: LD_INT 1
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: LD_INT 0
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: PUSH
2655: LD_INT 17
2657: PUSH
2658: LD_INT 190
2660: PUSH
2661: LD_INT 161
2663: PUSH
2664: LD_INT 1
2666: PUSH
2667: LD_INT 0
2669: PUSH
2670: LD_INT 0
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: LIST
2680: PUSH
2681: LD_INT 5
2683: PUSH
2684: LD_INT 200
2686: PUSH
2687: LD_INT 145
2689: PUSH
2690: LD_INT 3
2692: PUSH
2693: LD_INT 0
2695: PUSH
2696: LD_INT 0
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 32
2709: PUSH
2710: LD_INT 192
2712: PUSH
2713: LD_INT 144
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: LD_INT 0
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PUSH
2733: LD_INT 26
2735: PUSH
2736: LD_INT 216
2738: PUSH
2739: LD_INT 172
2741: PUSH
2742: LD_INT 3
2744: PUSH
2745: LD_INT 0
2747: PUSH
2748: LD_INT 0
2750: PUSH
2751: EMPTY
2752: LIST
2753: LIST
2754: LIST
2755: LIST
2756: LIST
2757: LIST
2758: PUSH
2759: LD_INT 26
2761: PUSH
2762: LD_INT 218
2764: PUSH
2765: LD_INT 176
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: LD_INT 0
2773: PUSH
2774: LD_INT 0
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 29
2787: PUSH
2788: LD_INT 182
2790: PUSH
2791: LD_INT 149
2793: PUSH
2794: LD_INT 3
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: LD_INT 0
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: LD_INT 201
2816: PUSH
2817: LD_INT 171
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: LD_INT 11
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 32
2839: PUSH
2840: LD_INT 188
2842: PUSH
2843: LD_INT 167
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: LD_INT 0
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: PUSH
2863: LD_INT 32
2865: PUSH
2866: LD_INT 202
2868: PUSH
2869: LD_INT 179
2871: PUSH
2872: LD_INT 0
2874: PUSH
2875: LD_INT 0
2877: PUSH
2878: LD_INT 0
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: PUSH
2889: LD_INT 32
2891: PUSH
2892: LD_INT 209
2894: PUSH
2895: LD_INT 182
2897: PUSH
2898: LD_INT 0
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: LD_INT 0
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: PUSH
2915: LD_INT 32
2917: PUSH
2918: LD_INT 220
2920: PUSH
2921: LD_INT 183
2923: PUSH
2924: LD_INT 5
2926: PUSH
2927: LD_INT 0
2929: PUSH
2930: LD_INT 0
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: PUSH
2941: LD_INT 32
2943: PUSH
2944: LD_INT 225
2946: PUSH
2947: LD_INT 181
2949: PUSH
2950: LD_INT 5
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 0
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: PUSH
2967: LD_INT 26
2969: PUSH
2970: LD_INT 220
2972: PUSH
2973: LD_INT 174
2975: PUSH
2976: LD_INT 5
2978: PUSH
2979: LD_INT 0
2981: PUSH
2982: LD_INT 0
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 84
2998: PUSH
2999: LD_INT 128
3001: PUSH
3002: LD_INT 4
3004: PUSH
3005: LD_INT 0
3007: PUSH
3008: LD_INT 0
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 3
3021: PUSH
3022: LD_INT 68
3024: PUSH
3025: LD_INT 121
3027: PUSH
3028: LD_INT 1
3030: PUSH
3031: LD_INT 0
3033: PUSH
3034: LD_INT 0
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 19
3047: PUSH
3048: LD_INT 72
3050: PUSH
3051: LD_INT 125
3053: PUSH
3054: LD_INT 5
3056: PUSH
3057: LD_INT 0
3059: PUSH
3060: LD_INT 0
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: PUSH
3071: LD_INT 18
3073: PUSH
3074: LD_INT 68
3076: PUSH
3077: LD_INT 124
3079: PUSH
3080: LD_INT 0
3082: PUSH
3083: LD_INT 0
3085: PUSH
3086: LD_INT 0
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_INT 24
3099: PUSH
3100: LD_INT 64
3102: PUSH
3103: LD_INT 121
3105: PUSH
3106: LD_INT 1
3108: PUSH
3109: LD_INT 0
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 17
3125: PUSH
3126: LD_INT 65
3128: PUSH
3129: LD_INT 118
3131: PUSH
3132: LD_INT 2
3134: PUSH
3135: LD_INT 0
3137: PUSH
3138: LD_INT 0
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 21
3151: PUSH
3152: LD_INT 68
3154: PUSH
3155: LD_INT 117
3157: PUSH
3158: LD_INT 3
3160: PUSH
3161: LD_INT 0
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: PUSH
3175: LD_INT 8
3177: PUSH
3178: LD_INT 68
3180: PUSH
3181: LD_INT 130
3183: PUSH
3184: LD_INT 1
3186: PUSH
3187: LD_INT 14
3189: PUSH
3190: LD_INT 10
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: PUSH
3201: LD_INT 8
3203: PUSH
3204: LD_INT 67
3206: PUSH
3207: LD_INT 110
3209: PUSH
3210: LD_INT 2
3212: PUSH
3213: LD_INT 11
3215: PUSH
3216: LD_INT 12
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 28
3229: PUSH
3230: LD_INT 85
3232: PUSH
3233: LD_INT 108
3235: PUSH
3236: LD_INT 2
3238: PUSH
3239: LD_INT 0
3241: PUSH
3242: LD_INT 0
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 28
3255: PUSH
3256: LD_INT 85
3258: PUSH
3259: LD_INT 124
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: LD_INT 0
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 30
3281: PUSH
3282: LD_INT 97
3284: PUSH
3285: LD_INT 119
3287: PUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 0
3293: PUSH
3294: LD_INT 0
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: PUSH
3305: LD_INT 5
3307: PUSH
3308: LD_INT 111
3310: PUSH
3311: LD_INT 138
3313: PUSH
3314: LD_INT 4
3316: PUSH
3317: LD_INT 0
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 33
3333: PUSH
3334: LD_INT 104
3336: PUSH
3337: LD_INT 130
3339: PUSH
3340: LD_INT 3
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 33
3359: PUSH
3360: LD_INT 110
3362: PUSH
3363: LD_INT 142
3365: PUSH
3366: LD_INT 5
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 33
3385: PUSH
3386: LD_INT 91
3388: PUSH
3389: LD_INT 131
3391: PUSH
3392: LD_INT 5
3394: PUSH
3395: LD_INT 0
3397: PUSH
3398: LD_INT 0
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 33
3411: PUSH
3412: LD_INT 107
3414: PUSH
3415: LD_INT 157
3417: PUSH
3418: LD_INT 5
3420: PUSH
3421: LD_INT 0
3423: PUSH
3424: LD_INT 0
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 33
3437: PUSH
3438: LD_INT 104
3440: PUSH
3441: LD_INT 160
3443: PUSH
3444: LD_INT 5
3446: PUSH
3447: LD_INT 0
3449: PUSH
3450: LD_INT 0
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 33
3463: PUSH
3464: LD_INT 101
3466: PUSH
3467: LD_INT 162
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 0
3475: PUSH
3476: LD_INT 0
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 32
3489: PUSH
3490: LD_INT 87
3492: PUSH
3493: LD_INT 157
3495: PUSH
3496: LD_INT 5
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: LD_INT 0
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 32
3515: PUSH
3516: LD_INT 105
3518: PUSH
3519: LD_INT 158
3521: PUSH
3522: LD_INT 5
3524: PUSH
3525: LD_INT 0
3527: PUSH
3528: LD_INT 0
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 33
3541: PUSH
3542: LD_INT 91
3544: PUSH
3545: LD_INT 118
3547: PUSH
3548: LD_INT 4
3550: PUSH
3551: LD_INT 0
3553: PUSH
3554: LD_INT 0
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 33
3567: PUSH
3568: LD_INT 89
3570: PUSH
3571: LD_INT 107
3573: PUSH
3574: LD_INT 4
3576: PUSH
3577: LD_INT 0
3579: PUSH
3580: LD_INT 0
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 86
3596: PUSH
3597: LD_INT 96
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: LD_INT 0
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 33
3619: PUSH
3620: LD_INT 91
3622: PUSH
3623: LD_INT 102
3625: PUSH
3626: LD_INT 4
3628: PUSH
3629: LD_INT 0
3631: PUSH
3632: LD_INT 0
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 32
3645: PUSH
3646: LD_INT 80
3648: PUSH
3649: LD_INT 95
3651: PUSH
3652: LD_INT 3
3654: PUSH
3655: LD_INT 0
3657: PUSH
3658: LD_INT 0
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 28
3671: PUSH
3672: LD_INT 77
3674: PUSH
3675: LD_INT 105
3677: PUSH
3678: LD_INT 3
3680: PUSH
3681: LD_INT 0
3683: PUSH
3684: LD_INT 0
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: LIST
3692: LIST
3693: LIST
3694: PUSH
3695: LD_INT 28
3697: PUSH
3698: LD_INT 85
3700: PUSH
3701: LD_INT 113
3703: PUSH
3704: LD_INT 3
3706: PUSH
3707: LD_INT 0
3709: PUSH
3710: LD_INT 0
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 28
3723: PUSH
3724: LD_INT 55
3726: PUSH
3727: LD_INT 97
3729: PUSH
3730: LD_INT 3
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 0
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 28
3749: PUSH
3750: LD_INT 88
3752: PUSH
3753: LD_INT 128
3755: PUSH
3756: LD_INT 3
3758: PUSH
3759: LD_INT 0
3761: PUSH
3762: LD_INT 0
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 32
3775: PUSH
3776: LD_INT 69
3778: PUSH
3779: LD_INT 101
3781: PUSH
3782: LD_INT 2
3784: PUSH
3785: LD_INT 0
3787: PUSH
3788: LD_INT 0
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: PUSH
3799: LD_INT 1
3801: PUSH
3802: LD_INT 34
3804: PUSH
3805: LD_INT 23
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: LD_INT 0
3813: PUSH
3814: LD_INT 0
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 25
3830: PUSH
3831: LD_INT 4
3833: PUSH
3834: LD_INT 3
3836: PUSH
3837: LD_INT 11
3839: PUSH
3840: LD_INT 10
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 8
3853: PUSH
3854: LD_INT 15
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: LD_INT 2
3862: PUSH
3863: LD_INT 14
3865: PUSH
3866: LD_INT 12
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 29
3879: PUSH
3880: LD_INT 55
3882: PUSH
3883: LD_INT 35
3885: PUSH
3886: LD_INT 2
3888: PUSH
3889: LD_INT 0
3891: PUSH
3892: LD_INT 0
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 29
3905: PUSH
3906: LD_INT 24
3908: PUSH
3909: LD_INT 44
3911: PUSH
3912: LD_INT 2
3914: PUSH
3915: LD_INT 0
3917: PUSH
3918: LD_INT 0
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: PUSH
3929: LD_INT 34
3931: PUSH
3932: LD_INT 34
3934: PUSH
3935: LD_INT 32
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: LD_INT 0
3943: PUSH
3944: LD_INT 0
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: PUSH
3955: LD_INT 3
3957: PUSH
3958: LD_INT 14
3960: PUSH
3961: LD_INT 16
3963: PUSH
3964: LD_INT 1
3966: PUSH
3967: LD_INT 0
3969: PUSH
3970: LD_INT 0
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: PUSH
3981: LD_INT 24
3983: PUSH
3984: LD_INT 10
3986: PUSH
3987: LD_INT 16
3989: PUSH
3990: LD_INT 1
3992: PUSH
3993: LD_INT 0
3995: PUSH
3996: LD_INT 0
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_INT 21
4009: PUSH
4010: LD_INT 11
4012: PUSH
4013: LD_INT 13
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: LD_INT 0
4021: PUSH
4022: LD_INT 0
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: PUSH
4033: LD_INT 18
4035: PUSH
4036: LD_INT 14
4038: PUSH
4039: LD_INT 12
4041: PUSH
4042: LD_INT 3
4044: PUSH
4045: LD_INT 0
4047: PUSH
4048: LD_INT 0
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: PUSH
4059: LD_INT 16
4061: PUSH
4062: LD_INT 14
4064: PUSH
4065: LD_INT 19
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: LD_INT 0
4073: PUSH
4074: LD_INT 0
4076: PUSH
4077: EMPTY
4078: LIST
4079: LIST
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 17
4087: PUSH
4088: LD_INT 18
4090: PUSH
4091: LD_INT 20
4093: PUSH
4094: LD_INT 5
4096: PUSH
4097: LD_INT 0
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: PUSH
4111: LD_INT 28
4113: PUSH
4114: LD_INT 10
4116: PUSH
4117: LD_INT 5
4119: PUSH
4120: LD_INT 1
4122: PUSH
4123: LD_INT 0
4125: PUSH
4126: LD_INT 0
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: PUSH
4137: LD_INT 28
4139: PUSH
4140: LD_INT 8
4142: PUSH
4143: LD_INT 8
4145: PUSH
4146: LD_INT 1
4148: PUSH
4149: LD_INT 0
4151: PUSH
4152: LD_INT 0
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: PUSH
4163: LD_INT 26
4165: PUSH
4166: LD_INT 19
4168: PUSH
4169: LD_INT 2
4171: PUSH
4172: LD_INT 1
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: LD_INT 0
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: PUSH
4189: LD_INT 26
4191: PUSH
4192: LD_INT 30
4194: PUSH
4195: LD_INT 2
4197: PUSH
4198: LD_INT 1
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: LD_INT 0
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 5
4217: PUSH
4218: LD_INT 59
4220: PUSH
4221: LD_INT 20
4223: PUSH
4224: LD_INT 4
4226: PUSH
4227: LD_INT 0
4229: PUSH
4230: LD_INT 0
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 32
4243: PUSH
4244: LD_INT 60
4246: PUSH
4247: LD_INT 24
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: LD_INT 0
4255: PUSH
4256: LD_INT 0
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 32
4269: PUSH
4270: LD_INT 61
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 5
4278: PUSH
4279: LD_INT 0
4281: PUSH
4282: LD_INT 0
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 32
4295: PUSH
4296: LD_INT 52
4298: PUSH
4299: LD_INT 51
4301: PUSH
4302: LD_INT 5
4304: PUSH
4305: LD_INT 0
4307: PUSH
4308: LD_INT 0
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: LD_INT 56
4324: PUSH
4325: LD_INT 51
4327: PUSH
4328: LD_INT 5
4330: PUSH
4331: LD_INT 0
4333: PUSH
4334: LD_INT 0
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 33
4347: PUSH
4348: LD_INT 62
4350: PUSH
4351: LD_INT 49
4353: PUSH
4354: LD_INT 5
4356: PUSH
4357: LD_INT 0
4359: PUSH
4360: LD_INT 0
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 33
4373: PUSH
4374: LD_INT 41
4376: PUSH
4377: LD_INT 47
4379: PUSH
4380: LD_INT 5
4382: PUSH
4383: LD_INT 0
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 33
4399: PUSH
4400: LD_INT 33
4402: PUSH
4403: LD_INT 52
4405: PUSH
4406: LD_INT 5
4408: PUSH
4409: LD_INT 0
4411: PUSH
4412: LD_INT 0
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: LD_INT 31
4428: PUSH
4429: LD_INT 40
4431: PUSH
4432: LD_INT 0
4434: PUSH
4435: LD_INT 0
4437: PUSH
4438: LD_INT 0
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: PUSH
4449: LD_INT 33
4451: PUSH
4452: LD_INT 65
4454: PUSH
4455: LD_INT 37
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: LD_INT 0
4463: PUSH
4464: LD_INT 0
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 33
4477: PUSH
4478: LD_INT 63
4480: PUSH
4481: LD_INT 29
4483: PUSH
4484: LD_INT 4
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: LD_INT 0
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: PUSH
4501: LD_INT 33
4503: PUSH
4504: LD_INT 54
4506: PUSH
4507: LD_INT 11
4509: PUSH
4510: LD_INT 4
4512: PUSH
4513: LD_INT 0
4515: PUSH
4516: LD_INT 0
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 33
4529: PUSH
4530: LD_INT 56
4532: PUSH
4533: LD_INT 15
4535: PUSH
4536: LD_INT 4
4538: PUSH
4539: LD_INT 0
4541: PUSH
4542: LD_INT 0
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 33
4555: PUSH
4556: LD_INT 51
4558: PUSH
4559: LD_INT 6
4561: PUSH
4562: LD_INT 4
4564: PUSH
4565: LD_INT 0
4567: PUSH
4568: LD_INT 0
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 26
4581: PUSH
4582: LD_INT 39
4584: PUSH
4585: LD_INT 25
4587: PUSH
4588: LD_INT 0
4590: PUSH
4591: LD_INT 0
4593: PUSH
4594: LD_INT 0
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: PUSH
4605: LD_INT 26
4607: PUSH
4608: LD_INT 37
4610: PUSH
4611: LD_INT 21
4613: PUSH
4614: LD_INT 0
4616: PUSH
4617: LD_INT 0
4619: PUSH
4620: LD_INT 0
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: PUSH
4631: LD_INT 32
4633: PUSH
4634: LD_INT 35
4636: PUSH
4637: LD_INT 17
4639: PUSH
4640: LD_INT 4
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 0
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 33
4659: PUSH
4660: LD_INT 35
4662: PUSH
4663: LD_INT 28
4665: PUSH
4666: LD_INT 4
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: LD_INT 0
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 28
4688: PUSH
4689: LD_INT 46
4691: PUSH
4692: LD_INT 5
4694: PUSH
4695: LD_INT 0
4697: PUSH
4698: LD_INT 0
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: PUSH
4709: LD_INT 33
4711: PUSH
4712: LD_INT 31
4714: PUSH
4715: LD_INT 6
4717: PUSH
4718: LD_INT 4
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: LD_INT 0
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 26
4737: PUSH
4738: LD_INT 54
4740: PUSH
4741: LD_INT 38
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 0
4749: PUSH
4750: LD_INT 0
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_INT 33
4763: PUSH
4764: LD_INT 207
4766: PUSH
4767: LD_INT 167
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: LD_INT 0
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 30
4789: PUSH
4790: LD_INT 43
4792: PUSH
4793: LD_INT 2
4795: PUSH
4796: LD_INT 4
4798: PUSH
4799: LD_INT 0
4801: PUSH
4802: LD_INT 0
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: ST_TO_ADDR
// for i in tmp do
4900: LD_ADDR_VAR 0 2
4904: PUSH
4905: LD_VAR 0 4
4909: PUSH
4910: FOR_IN
4911: IFFALSE 5142
// begin uc_side := side ;
4913: LD_ADDR_OWVAR 20
4917: PUSH
4918: LD_VAR 0 5
4922: ST_TO_ADDR
// uc_nation := nation_russian ;
4923: LD_ADDR_OWVAR 21
4927: PUSH
4928: LD_INT 3
4930: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4931: LD_ADDR_OWVAR 42
4935: PUSH
4936: LD_VAR 0 2
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4945: LD_ADDR_OWVAR 43
4949: PUSH
4950: LD_INT 5
4952: PPUSH
4953: LD_INT 6
4955: PPUSH
4956: CALL_OW 12
4960: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4961: LD_ADDR_OWVAR 44
4965: PUSH
4966: LD_VAR 0 2
4970: PUSH
4971: LD_INT 5
4973: ARRAY
4974: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4975: LD_ADDR_OWVAR 45
4979: PUSH
4980: LD_VAR 0 2
4984: PUSH
4985: LD_INT 6
4987: ARRAY
4988: ST_TO_ADDR
// sr := 0 ;
4989: LD_ADDR_VAR 0 6
4993: PUSH
4994: LD_INT 0
4996: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4997: LD_VAR 0 2
5001: PUSH
5002: LD_INT 1
5004: ARRAY
5005: PUSH
5006: LD_INT 29
5008: EQUAL
5009: IFFALSE 5021
// sr := mat_oil else
5011: LD_ADDR_VAR 0 6
5015: PUSH
5016: LD_INT 2
5018: ST_TO_ADDR
5019: GO 5043
// if i [ 1 ] = b_siberite_mine then
5021: LD_VAR 0 2
5025: PUSH
5026: LD_INT 1
5028: ARRAY
5029: PUSH
5030: LD_INT 30
5032: EQUAL
5033: IFFALSE 5043
// sr := mat_siberit ;
5035: LD_ADDR_VAR 0 6
5039: PUSH
5040: LD_INT 3
5042: ST_TO_ADDR
// if sr then
5043: LD_VAR 0 6
5047: IFFALSE 5103
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5049: LD_VAR 0 2
5053: PUSH
5054: LD_INT 2
5056: ARRAY
5057: PPUSH
5058: LD_VAR 0 2
5062: PUSH
5063: LD_INT 3
5065: ARRAY
5066: PPUSH
5067: LD_VAR 0 6
5071: PPUSH
5072: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5076: LD_VAR 0 2
5080: PUSH
5081: LD_INT 2
5083: ARRAY
5084: PPUSH
5085: LD_VAR 0 2
5089: PUSH
5090: LD_INT 3
5092: ARRAY
5093: PPUSH
5094: LD_VAR 0 5
5098: PPUSH
5099: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5103: LD_ADDR_VAR 0 3
5107: PUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_INT 2
5115: ARRAY
5116: PPUSH
5117: LD_VAR 0 2
5121: PUSH
5122: LD_INT 3
5124: ARRAY
5125: PPUSH
5126: LD_VAR 0 2
5130: PUSH
5131: LD_INT 4
5133: ARRAY
5134: PPUSH
5135: CALL_OW 47
5139: ST_TO_ADDR
// end ;
5140: GO 4910
5142: POP
5143: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5144: LD_ADDR_VAR 0 7
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_VAR 0 5
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PUSH
5161: LD_INT 30
5163: PUSH
5164: LD_INT 1
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PPUSH
5175: CALL_OW 69
5179: ST_TO_ADDR
// if not depot then
5180: LD_VAR 0 7
5184: NOT
5185: IFFALSE 5189
// exit ;
5187: GO 5533
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5189: LD_ADDR_VAR 0 8
5193: PUSH
5194: LD_INT 84
5196: PPUSH
5197: LD_INT 128
5199: PPUSH
5200: CALL_OW 428
5204: PPUSH
5205: LD_INT 15
5207: PPUSH
5208: LD_INT 0
5210: PPUSH
5211: LD_INT 6
5213: PUSH
5214: LD_INT 7
5216: PUSH
5217: LD_INT 8
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: LIST
5224: PUSH
5225: LD_OWVAR 67
5229: ARRAY
5230: PPUSH
5231: LD_INT 3000
5233: PUSH
5234: LD_INT 300
5236: PUSH
5237: LD_INT 100
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: LD_INT 12
5247: PUSH
5248: LD_INT 6
5250: PUSH
5251: LD_INT 6
5253: PUSH
5254: LD_INT 4
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL 28545 0 6
5267: ST_TO_ADDR
// if not base then
5268: LD_VAR 0 8
5272: NOT
5273: IFFALSE 5277
// exit ;
5275: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5277: LD_ADDR_EXP 31
5281: PUSH
5282: LD_EXP 31
5286: PPUSH
5287: LD_EXP 7
5291: PPUSH
5292: LD_VAR 0 8
5296: PPUSH
5297: CALL_OW 1
5301: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5302: LD_ADDR_VAR 0 8
5306: PUSH
5307: LD_INT 34
5309: PPUSH
5310: LD_INT 23
5312: PPUSH
5313: CALL_OW 428
5317: PPUSH
5318: LD_INT 11
5320: PPUSH
5321: LD_INT 0
5323: PPUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 7
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PPUSH
5344: LD_INT 20000
5346: PUSH
5347: LD_INT 3000
5349: PUSH
5350: LD_INT 1000
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: PPUSH
5358: LD_INT 12
5360: PUSH
5361: LD_INT 6
5363: PUSH
5364: LD_INT 6
5366: PUSH
5367: LD_INT 4
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL 28545 0 6
5380: ST_TO_ADDR
// if not base then
5381: LD_VAR 0 8
5385: NOT
5386: IFFALSE 5390
// exit ;
5388: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5390: LD_ADDR_EXP 31
5394: PUSH
5395: LD_EXP 31
5399: PPUSH
5400: LD_EXP 8
5404: PPUSH
5405: LD_VAR 0 8
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5415: LD_ADDR_EXP 14
5419: PUSH
5420: LD_INT 22
5422: PUSH
5423: LD_INT 3
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 30
5432: PUSH
5433: LD_INT 0
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: PUSH
5449: LD_INT 1
5451: ARRAY
5452: PPUSH
5453: LD_INT 25
5455: PPUSH
5456: LD_INT 0
5458: PPUSH
5459: LD_INT 6
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: LD_INT 8
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_OWVAR 67
5477: ARRAY
5478: PPUSH
5479: LD_INT 500
5481: PUSH
5482: LD_INT 100
5484: PUSH
5485: LD_INT 10
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: PPUSH
5493: LD_INT 6
5495: PUSH
5496: LD_INT 7
5498: PUSH
5499: LD_INT 8
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: LIST
5506: PUSH
5507: LD_OWVAR 67
5511: ARRAY
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: LD_INT 0
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: PPUSH
5528: CALL 28545 0 6
5532: ST_TO_ADDR
// end ;
5533: LD_VAR 0 1
5537: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5538: LD_INT 0
5540: PPUSH
5541: PPUSH
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5551: LD_INT 0
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: LD_INT 6
5559: PPUSH
5560: LD_INT 0
5562: PPUSH
5563: LD_INT 0
5565: PPUSH
5566: LD_INT 0
5568: PPUSH
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 8
5574: PPUSH
5575: LD_INT 0
5577: PPUSH
5578: CALL 54263 0 9
// side := 8 ;
5582: LD_ADDR_VAR 0 8
5586: PUSH
5587: LD_INT 8
5589: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5590: LD_ADDR_VAR 0 5
5594: PUSH
5595: LD_INT 20
5597: PPUSH
5598: LD_INT 0
5600: PPUSH
5601: CALL_OW 517
5605: ST_TO_ADDR
// if Difficulty > 2 then
5606: LD_OWVAR 67
5610: PUSH
5611: LD_INT 2
5613: GREATER
5614: IFFALSE 5758
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5616: LD_ADDR_VAR 0 6
5620: PUSH
5621: LD_INT 27
5623: PPUSH
5624: LD_INT 0
5626: PPUSH
5627: CALL_OW 517
5631: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5632: LD_ADDR_VAR 0 2
5636: PUSH
5637: DOUBLE
5638: LD_INT 1
5640: DEC
5641: ST_TO_ADDR
5642: LD_VAR 0 6
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PUSH
5651: FOR_TO
5652: IFFALSE 5756
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5654: LD_ADDR_VAR 0 5
5658: PUSH
5659: LD_VAR 0 5
5663: PPUSH
5664: LD_INT 1
5666: PUSH
5667: LD_VAR 0 5
5671: PUSH
5672: LD_INT 1
5674: ARRAY
5675: PUSH
5676: LD_INT 1
5678: PLUS
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PPUSH
5684: LD_VAR 0 6
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: CALL 24846 0 3
5703: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5704: LD_ADDR_VAR 0 5
5708: PUSH
5709: LD_VAR 0 5
5713: PPUSH
5714: LD_INT 2
5716: PUSH
5717: LD_VAR 0 5
5721: PUSH
5722: LD_INT 2
5724: ARRAY
5725: PUSH
5726: LD_INT 1
5728: PLUS
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: PPUSH
5734: LD_VAR 0 6
5738: PUSH
5739: LD_INT 2
5741: ARRAY
5742: PUSH
5743: LD_VAR 0 2
5747: ARRAY
5748: PPUSH
5749: CALL 24846 0 3
5753: ST_TO_ADDR
// end ;
5754: GO 5651
5756: POP
5757: POP
// end ; if tmp then
5758: LD_VAR 0 5
5762: IFFALSE 5890
// begin for i = 1 to tmp [ 1 ] do
5764: LD_ADDR_VAR 0 2
5768: PUSH
5769: DOUBLE
5770: LD_INT 1
5772: DEC
5773: ST_TO_ADDR
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 1
5781: ARRAY
5782: PUSH
5783: FOR_TO
5784: IFFALSE 5888
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5786: LD_VAR 0 5
5790: PUSH
5791: LD_INT 1
5793: ARRAY
5794: PUSH
5795: LD_VAR 0 2
5799: ARRAY
5800: PPUSH
5801: LD_VAR 0 5
5805: PUSH
5806: LD_INT 2
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 2
5814: ARRAY
5815: PPUSH
5816: LD_VAR 0 8
5820: PPUSH
5821: LD_INT 0
5823: PPUSH
5824: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5828: LD_ADDR_EXP 16
5832: PUSH
5833: LD_EXP 16
5837: PPUSH
5838: LD_EXP 16
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PPUSH
5847: LD_VAR 0 5
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PUSH
5856: LD_VAR 0 2
5860: ARRAY
5861: PUSH
5862: LD_VAR 0 5
5866: PUSH
5867: LD_INT 2
5869: ARRAY
5870: PUSH
5871: LD_VAR 0 2
5875: ARRAY
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: PPUSH
5881: CALL_OW 2
5885: ST_TO_ADDR
// end ;
5886: GO 5783
5888: POP
5889: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5890: LD_ADDR_VAR 0 7
5894: PUSH
5895: LD_INT 165
5897: PUSH
5898: LD_INT 156
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 143
5907: PUSH
5908: LD_INT 145
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 152
5917: PUSH
5918: LD_INT 165
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 123
5927: PUSH
5928: LD_INT 153
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 161
5937: PUSH
5938: LD_INT 215
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PUSH
5945: LD_INT 172
5947: PUSH
5948: LD_INT 100
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PUSH
5955: LD_INT 148
5957: PUSH
5958: LD_INT 83
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: PUSH
5965: LD_INT 122
5967: PUSH
5968: LD_INT 68
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 105
5977: PUSH
5978: LD_INT 74
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 113
5987: PUSH
5988: LD_INT 97
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: ST_TO_ADDR
// for i in cameras do
6007: LD_ADDR_VAR 0 2
6011: PUSH
6012: LD_VAR 0 7
6016: PUSH
6017: FOR_IN
6018: IFFALSE 6049
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
6020: LD_VAR 0 2
6024: PUSH
6025: LD_INT 1
6027: ARRAY
6028: PPUSH
6029: LD_VAR 0 2
6033: PUSH
6034: LD_INT 2
6036: ARRAY
6037: PPUSH
6038: LD_VAR 0 8
6042: PPUSH
6043: CALL_OW 244
6047: GO 6017
6049: POP
6050: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6051: LD_ADDR_VAR 0 5
6055: PUSH
6056: LD_INT 1
6058: PUSH
6059: LD_INT 144
6061: PUSH
6062: LD_INT 110
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: LD_INT 0
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 3
6084: PUSH
6085: LD_INT 151
6087: PUSH
6088: LD_INT 118
6090: PUSH
6091: LD_INT 0
6093: PUSH
6094: LD_INT 0
6096: PUSH
6097: LD_INT 0
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: LD_INT 158
6113: PUSH
6114: LD_INT 110
6116: PUSH
6117: LD_INT 4
6119: PUSH
6120: LD_INT 10
6122: PUSH
6123: LD_INT 15
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: PUSH
6134: LD_INT 23
6136: PUSH
6137: LD_INT 154
6139: PUSH
6140: LD_INT 121
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 155
6165: PUSH
6166: LD_INT 118
6168: PUSH
6169: LD_INT 4
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: LD_INT 0
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_INT 21
6188: PUSH
6189: LD_INT 151
6191: PUSH
6192: LD_INT 122
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: LD_INT 0
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 18
6214: PUSH
6215: LD_INT 148
6217: PUSH
6218: LD_INT 118
6220: PUSH
6221: LD_INT 1
6223: PUSH
6224: LD_INT 0
6226: PUSH
6227: LD_INT 0
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 17
6240: PUSH
6241: LD_INT 147
6243: PUSH
6244: LD_INT 114
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 0
6252: PUSH
6253: LD_INT 0
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 29
6266: PUSH
6267: LD_INT 163
6269: PUSH
6270: LD_INT 120
6272: PUSH
6273: LD_INT 5
6275: PUSH
6276: LD_INT 0
6278: PUSH
6279: LD_INT 0
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 27
6292: PUSH
6293: LD_INT 137
6295: PUSH
6296: LD_INT 116
6298: PUSH
6299: LD_INT 3
6301: PUSH
6302: LD_INT 0
6304: PUSH
6305: LD_INT 0
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 27
6318: PUSH
6319: LD_INT 133
6321: PUSH
6322: LD_INT 111
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: LD_INT 0
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 27
6344: PUSH
6345: LD_INT 132
6347: PUSH
6348: LD_INT 106
6350: PUSH
6351: LD_INT 4
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 26
6370: PUSH
6371: LD_INT 137
6373: PUSH
6374: LD_INT 111
6376: PUSH
6377: LD_INT 0
6379: PUSH
6380: LD_INT 0
6382: PUSH
6383: LD_INT 0
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 141
6399: PUSH
6400: LD_INT 117
6402: PUSH
6403: LD_INT 1
6405: PUSH
6406: LD_INT 13
6408: PUSH
6409: LD_INT 11
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 30
6422: PUSH
6423: LD_INT 140
6425: PUSH
6426: LD_INT 128
6428: PUSH
6429: LD_INT 1
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: LD_INT 0
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 5
6448: PUSH
6449: LD_INT 146
6451: PUSH
6452: LD_INT 96
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 32
6474: PUSH
6475: LD_INT 150
6477: PUSH
6478: LD_INT 98
6480: PUSH
6481: LD_INT 3
6483: PUSH
6484: LD_INT 0
6486: PUSH
6487: LD_INT 0
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 32
6500: PUSH
6501: LD_INT 142
6503: PUSH
6504: LD_INT 95
6506: PUSH
6507: LD_INT 3
6509: PUSH
6510: LD_INT 0
6512: PUSH
6513: LD_INT 0
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 32
6526: PUSH
6527: LD_INT 159
6529: PUSH
6530: LD_INT 104
6532: PUSH
6533: LD_INT 3
6535: PUSH
6536: LD_INT 0
6538: PUSH
6539: LD_INT 0
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: LD_INT 32
6552: PUSH
6553: LD_INT 133
6555: PUSH
6556: LD_INT 95
6558: PUSH
6559: LD_INT 3
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: LD_INT 0
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 32
6578: PUSH
6579: LD_INT 131
6581: PUSH
6582: LD_INT 102
6584: PUSH
6585: LD_INT 2
6587: PUSH
6588: LD_INT 0
6590: PUSH
6591: LD_INT 0
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 32
6604: PUSH
6605: LD_INT 164
6607: PUSH
6608: LD_INT 144
6610: PUSH
6611: LD_INT 0
6613: PUSH
6614: LD_INT 0
6616: PUSH
6617: LD_INT 0
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: LD_INT 146
6633: PUSH
6634: LD_INT 139
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: LD_INT 0
6642: PUSH
6643: LD_INT 0
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 26
6656: PUSH
6657: LD_INT 143
6659: PUSH
6660: LD_INT 122
6662: PUSH
6663: LD_INT 4
6665: PUSH
6666: LD_INT 0
6668: PUSH
6669: LD_INT 0
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 164
6685: PUSH
6686: LD_INT 116
6688: PUSH
6689: LD_INT 2
6691: PUSH
6692: LD_INT 0
6694: PUSH
6695: LD_INT 0
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: ST_TO_ADDR
// for i in tmp do
6733: LD_ADDR_VAR 0 2
6737: PUSH
6738: LD_VAR 0 5
6742: PUSH
6743: FOR_IN
6744: IFFALSE 6975
// begin uc_side := side ;
6746: LD_ADDR_OWVAR 20
6750: PUSH
6751: LD_VAR 0 8
6755: ST_TO_ADDR
// uc_nation := nation_arabian ;
6756: LD_ADDR_OWVAR 21
6760: PUSH
6761: LD_INT 2
6763: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6764: LD_ADDR_OWVAR 42
6768: PUSH
6769: LD_VAR 0 2
6773: PUSH
6774: LD_INT 1
6776: ARRAY
6777: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6778: LD_ADDR_OWVAR 43
6782: PUSH
6783: LD_INT 5
6785: PPUSH
6786: LD_INT 6
6788: PPUSH
6789: CALL_OW 12
6793: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6794: LD_ADDR_OWVAR 44
6798: PUSH
6799: LD_VAR 0 2
6803: PUSH
6804: LD_INT 5
6806: ARRAY
6807: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6808: LD_ADDR_OWVAR 45
6812: PUSH
6813: LD_VAR 0 2
6817: PUSH
6818: LD_INT 6
6820: ARRAY
6821: ST_TO_ADDR
// sr := 0 ;
6822: LD_ADDR_VAR 0 9
6826: PUSH
6827: LD_INT 0
6829: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6830: LD_VAR 0 2
6834: PUSH
6835: LD_INT 1
6837: ARRAY
6838: PUSH
6839: LD_INT 29
6841: EQUAL
6842: IFFALSE 6854
// sr := mat_oil else
6844: LD_ADDR_VAR 0 9
6848: PUSH
6849: LD_INT 2
6851: ST_TO_ADDR
6852: GO 6876
// if i [ 1 ] = b_siberite_mine then
6854: LD_VAR 0 2
6858: PUSH
6859: LD_INT 1
6861: ARRAY
6862: PUSH
6863: LD_INT 30
6865: EQUAL
6866: IFFALSE 6876
// sr := mat_siberit ;
6868: LD_ADDR_VAR 0 9
6872: PUSH
6873: LD_INT 3
6875: ST_TO_ADDR
// if sr then
6876: LD_VAR 0 9
6880: IFFALSE 6936
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6882: LD_VAR 0 2
6886: PUSH
6887: LD_INT 2
6889: ARRAY
6890: PPUSH
6891: LD_VAR 0 2
6895: PUSH
6896: LD_INT 3
6898: ARRAY
6899: PPUSH
6900: LD_VAR 0 9
6904: PPUSH
6905: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6909: LD_VAR 0 2
6913: PUSH
6914: LD_INT 2
6916: ARRAY
6917: PPUSH
6918: LD_VAR 0 2
6922: PUSH
6923: LD_INT 3
6925: ARRAY
6926: PPUSH
6927: LD_VAR 0 8
6931: PPUSH
6932: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6936: LD_ADDR_VAR 0 3
6940: PUSH
6941: LD_VAR 0 2
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PPUSH
6950: LD_VAR 0 2
6954: PUSH
6955: LD_INT 3
6957: ARRAY
6958: PPUSH
6959: LD_VAR 0 2
6963: PUSH
6964: LD_INT 4
6966: ARRAY
6967: PPUSH
6968: CALL_OW 47
6972: ST_TO_ADDR
// end ;
6973: GO 6743
6975: POP
6976: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6977: LD_ADDR_VAR 0 10
6981: PUSH
6982: LD_INT 22
6984: PUSH
6985: LD_VAR 0 8
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PPUSH
7008: CALL_OW 69
7012: ST_TO_ADDR
// if not depot then
7013: LD_VAR 0 10
7017: NOT
7018: IFFALSE 7022
// exit ;
7020: GO 7268
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
7022: LD_ADDR_VAR 0 11
7026: PUSH
7027: LD_VAR 0 10
7031: PUSH
7032: LD_INT 1
7034: ARRAY
7035: PPUSH
7036: LD_INT 6
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: LD_INT 7
7044: PUSH
7045: LD_INT 8
7047: PUSH
7048: LD_INT 10
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: LIST
7055: PUSH
7056: LD_OWVAR 67
7060: ARRAY
7061: PPUSH
7062: LD_INT 3000
7064: PUSH
7065: LD_INT 300
7067: PUSH
7068: LD_INT 100
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: PPUSH
7076: LD_INT 14
7078: PUSH
7079: LD_INT 6
7081: PUSH
7082: LD_INT 6
7084: PUSH
7085: LD_INT 5
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL 28545 0 6
7098: ST_TO_ADDR
// if not base then
7099: LD_VAR 0 11
7103: NOT
7104: IFFALSE 7108
// exit ;
7106: GO 7268
// if Difficulty > 1 then
7108: LD_OWVAR 67
7112: PUSH
7113: LD_INT 1
7115: GREATER
7116: IFFALSE 7189
// begin InitHc ;
7118: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7122: LD_INT 1
7124: PPUSH
7125: LD_INT 5
7127: PPUSH
7128: LD_INT 5
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: PUSH
7143: LD_INT 1
7145: MINUS
7146: ARRAY
7147: PPUSH
7148: CALL_OW 380
// for i = 1 to Difficulty do
7152: LD_ADDR_VAR 0 2
7156: PUSH
7157: DOUBLE
7158: LD_INT 1
7160: DEC
7161: ST_TO_ADDR
7162: LD_OWVAR 67
7166: PUSH
7167: FOR_TO
7168: IFFALSE 7187
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7170: CALL_OW 44
7174: PPUSH
7175: LD_INT 24
7177: PPUSH
7178: LD_INT 0
7180: PPUSH
7181: CALL_OW 49
7185: GO 7167
7187: POP
7188: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7189: LD_ADDR_EXP 31
7193: PUSH
7194: LD_EXP 31
7198: PPUSH
7199: LD_EXP 6
7203: PPUSH
7204: LD_VAR 0 11
7208: PPUSH
7209: CALL_OW 1
7213: ST_TO_ADDR
// hc_gallery := ru ;
7214: LD_ADDR_OWVAR 33
7218: PUSH
7219: LD_STRING ru
7221: ST_TO_ADDR
// hc_face_number := 44 ;
7222: LD_ADDR_OWVAR 34
7226: PUSH
7227: LD_INT 44
7229: ST_TO_ADDR
// hc_name := Robert Farmer ;
7230: LD_ADDR_OWVAR 26
7234: PUSH
7235: LD_STRING Robert Farmer
7237: ST_TO_ADDR
// hc_sex := sex_male ;
7238: LD_ADDR_OWVAR 27
7242: PUSH
7243: LD_INT 1
7245: ST_TO_ADDR
// hc_class := 1 ;
7246: LD_ADDR_OWVAR 28
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// Farmer := CreateHuman ;
7254: LD_ADDR_EXP 13
7258: PUSH
7259: CALL_OW 44
7263: ST_TO_ADDR
// InitHc ;
7264: CALL_OW 19
// end ;
7268: LD_VAR 0 1
7272: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7273: LD_INT 0
7275: PPUSH
7276: PPUSH
7277: PPUSH
7278: PPUSH
// tmp := [ ] ;
7279: LD_ADDR_VAR 0 3
7283: PUSH
7284: EMPTY
7285: ST_TO_ADDR
// for i := 1 to 3 do
7286: LD_ADDR_VAR 0 2
7290: PUSH
7291: DOUBLE
7292: LD_INT 1
7294: DEC
7295: ST_TO_ADDR
7296: LD_INT 3
7298: PUSH
7299: FOR_TO
7300: IFFALSE 7412
// begin uc_side := 3 ;
7302: LD_ADDR_OWVAR 20
7306: PUSH
7307: LD_INT 3
7309: ST_TO_ADDR
// uc_nation := 3 ;
7310: LD_ADDR_OWVAR 21
7314: PUSH
7315: LD_INT 3
7317: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7318: LD_ADDR_OWVAR 37
7322: PUSH
7323: LD_INT 22
7325: ST_TO_ADDR
// vc_engine := engine_siberite ;
7326: LD_ADDR_OWVAR 39
7330: PUSH
7331: LD_INT 3
7333: ST_TO_ADDR
// vc_control := control_computer ;
7334: LD_ADDR_OWVAR 38
7338: PUSH
7339: LD_INT 3
7341: ST_TO_ADDR
// vc_weapon := ru_crane ;
7342: LD_ADDR_OWVAR 40
7346: PUSH
7347: LD_INT 52
7349: ST_TO_ADDR
// veh := CreateVehicle ;
7350: LD_ADDR_VAR 0 4
7354: PUSH
7355: CALL_OW 45
7359: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7360: LD_VAR 0 4
7364: PPUSH
7365: LD_INT 73
7367: PPUSH
7368: LD_INT 122
7370: PPUSH
7371: LD_INT 3
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7381: LD_ADDR_VAR 0 3
7385: PUSH
7386: LD_VAR 0 3
7390: PPUSH
7391: LD_VAR 0 3
7395: PUSH
7396: LD_INT 1
7398: PLUS
7399: PPUSH
7400: LD_VAR 0 4
7404: PPUSH
7405: CALL_OW 1
7409: ST_TO_ADDR
// end ;
7410: GO 7299
7412: POP
7413: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7414: LD_ADDR_EXP 50
7418: PUSH
7419: LD_EXP 50
7423: PPUSH
7424: LD_EXP 7
7428: PPUSH
7429: LD_VAR 0 3
7433: PPUSH
7434: CALL_OW 1
7438: ST_TO_ADDR
// tmp := [ ] ;
7439: LD_ADDR_VAR 0 3
7443: PUSH
7444: EMPTY
7445: ST_TO_ADDR
// for i := 1 to 3 do
7446: LD_ADDR_VAR 0 2
7450: PUSH
7451: DOUBLE
7452: LD_INT 1
7454: DEC
7455: ST_TO_ADDR
7456: LD_INT 3
7458: PUSH
7459: FOR_TO
7460: IFFALSE 7572
// begin uc_side := 3 ;
7462: LD_ADDR_OWVAR 20
7466: PUSH
7467: LD_INT 3
7469: ST_TO_ADDR
// uc_nation := 3 ;
7470: LD_ADDR_OWVAR 21
7474: PUSH
7475: LD_INT 3
7477: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7478: LD_ADDR_OWVAR 37
7482: PUSH
7483: LD_INT 22
7485: ST_TO_ADDR
// vc_engine := engine_siberite ;
7486: LD_ADDR_OWVAR 39
7490: PUSH
7491: LD_INT 3
7493: ST_TO_ADDR
// vc_control := control_computer ;
7494: LD_ADDR_OWVAR 38
7498: PUSH
7499: LD_INT 3
7501: ST_TO_ADDR
// vc_weapon := ru_crane ;
7502: LD_ADDR_OWVAR 40
7506: PUSH
7507: LD_INT 52
7509: ST_TO_ADDR
// veh := CreateVehicle ;
7510: LD_ADDR_VAR 0 4
7514: PUSH
7515: CALL_OW 45
7519: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7520: LD_VAR 0 4
7524: PPUSH
7525: LD_INT 22
7527: PPUSH
7528: LD_INT 28
7530: PPUSH
7531: LD_INT 3
7533: PPUSH
7534: LD_INT 0
7536: PPUSH
7537: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7541: LD_ADDR_VAR 0 3
7545: PUSH
7546: LD_VAR 0 3
7550: PPUSH
7551: LD_VAR 0 3
7555: PUSH
7556: LD_INT 1
7558: PLUS
7559: PPUSH
7560: LD_VAR 0 4
7564: PPUSH
7565: CALL_OW 1
7569: ST_TO_ADDR
// end ;
7570: GO 7459
7572: POP
7573: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7574: LD_ADDR_EXP 50
7578: PUSH
7579: LD_EXP 50
7583: PPUSH
7584: LD_EXP 8
7588: PPUSH
7589: LD_VAR 0 3
7593: PPUSH
7594: CALL_OW 1
7598: ST_TO_ADDR
// end ;
7599: LD_VAR 0 1
7603: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7604: LD_INT 0
7606: PPUSH
7607: PPUSH
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
7613: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7614: LD_INT 0
7616: PPUSH
7617: LD_INT 0
7619: PPUSH
7620: LD_INT 4
7622: PPUSH
7623: LD_INT 0
7625: PPUSH
7626: LD_INT 0
7628: PPUSH
7629: LD_INT 0
7631: PPUSH
7632: LD_INT 0
7634: PPUSH
7635: LD_INT 10
7637: PPUSH
7638: LD_INT 0
7640: PPUSH
7641: CALL 54263 0 9
// side := 4 ;
7645: LD_ADDR_VAR 0 5
7649: PUSH
7650: LD_INT 4
7652: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7653: LD_ADDR_VAR 0 4
7657: PUSH
7658: LD_INT 1
7660: PUSH
7661: LD_INT 144
7663: PUSH
7664: LD_INT 18
7666: PUSH
7667: LD_INT 4
7669: PUSH
7670: LD_INT 0
7672: PUSH
7673: LD_INT 0
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: PUSH
7684: LD_INT 3
7686: PUSH
7687: LD_INT 137
7689: PUSH
7690: LD_INT 8
7692: PUSH
7693: LD_INT 4
7695: PUSH
7696: LD_INT 0
7698: PUSH
7699: LD_INT 0
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_INT 141
7715: PUSH
7716: LD_INT 8
7718: PUSH
7719: LD_INT 4
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: LD_INT 0
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 25
7738: PUSH
7739: LD_INT 137
7741: PUSH
7742: LD_INT 5
7744: PUSH
7745: LD_INT 3
7747: PUSH
7748: LD_INT 0
7750: PUSH
7751: LD_INT 0
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 18
7764: PUSH
7765: LD_INT 137
7767: PUSH
7768: LD_INT 12
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: LD_INT 0
7776: PUSH
7777: LD_INT 0
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 17
7790: PUSH
7791: LD_INT 133
7793: PUSH
7794: LD_INT 4
7796: PUSH
7797: LD_INT 2
7799: PUSH
7800: LD_INT 0
7802: PUSH
7803: LD_INT 0
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 16
7816: PUSH
7817: LD_INT 140
7819: PUSH
7820: LD_INT 11
7822: PUSH
7823: LD_INT 5
7825: PUSH
7826: LD_INT 0
7828: PUSH
7829: LD_INT 0
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: PUSH
7840: LD_INT 8
7842: PUSH
7843: LD_INT 149
7845: PUSH
7846: LD_INT 26
7848: PUSH
7849: LD_INT 4
7851: PUSH
7852: LD_INT 10
7854: PUSH
7855: LD_INT 15
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 8
7868: PUSH
7869: LD_INT 142
7871: PUSH
7872: LD_INT 26
7874: PUSH
7875: LD_INT 1
7877: PUSH
7878: LD_INT 11
7880: PUSH
7881: LD_INT 12
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 27
7894: PUSH
7895: LD_INT 153
7897: PUSH
7898: LD_INT 32
7900: PUSH
7901: LD_INT 5
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: LD_INT 0
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 27
7920: PUSH
7921: LD_INT 145
7923: PUSH
7924: LD_INT 32
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 0
7932: PUSH
7933: LD_INT 0
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: LIST
7941: LIST
7942: LIST
7943: PUSH
7944: LD_INT 27
7946: PUSH
7947: LD_INT 138
7949: PUSH
7950: LD_INT 2
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: LD_INT 0
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: LIST
7968: LIST
7969: PUSH
7970: LD_INT 27
7972: PUSH
7973: LD_INT 144
7975: PUSH
7976: LD_INT 13
7978: PUSH
7979: LD_INT 0
7981: PUSH
7982: LD_INT 0
7984: PUSH
7985: LD_INT 0
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 26
7998: PUSH
7999: LD_INT 124
8001: PUSH
8002: LD_INT 2
8004: PUSH
8005: LD_INT 4
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: LD_INT 0
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 26
8024: PUSH
8025: LD_INT 121
8027: PUSH
8028: LD_INT 2
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: LD_INT 0
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 26
8050: PUSH
8051: LD_INT 118
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: LD_INT 1
8059: PUSH
8060: LD_INT 0
8062: PUSH
8063: LD_INT 0
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 29
8076: PUSH
8077: LD_INT 159
8079: PUSH
8080: LD_INT 47
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 0
8088: PUSH
8089: LD_INT 0
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: PUSH
8100: LD_INT 32
8102: PUSH
8103: LD_INT 146
8105: PUSH
8106: LD_INT 41
8108: PUSH
8109: LD_INT 0
8111: PUSH
8112: LD_INT 0
8114: PUSH
8115: LD_INT 0
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 33
8128: PUSH
8129: LD_INT 136
8131: PUSH
8132: LD_INT 37
8134: PUSH
8135: LD_INT 0
8137: PUSH
8138: LD_INT 0
8140: PUSH
8141: LD_INT 0
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 33
8154: PUSH
8155: LD_INT 132
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 0
8163: PUSH
8164: LD_INT 0
8166: PUSH
8167: LD_INT 0
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: PUSH
8178: LD_INT 36
8180: PUSH
8181: LD_INT 124
8183: PUSH
8184: LD_INT 7
8186: PUSH
8187: LD_INT 1
8189: PUSH
8190: LD_INT 0
8192: PUSH
8193: LD_INT 0
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 5
8206: PUSH
8207: LD_INT 124
8209: PUSH
8210: LD_INT 19
8212: PUSH
8213: LD_INT 0
8215: PUSH
8216: LD_INT 0
8218: PUSH
8219: LD_INT 0
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: PUSH
8230: LD_INT 32
8232: PUSH
8233: LD_INT 127
8235: PUSH
8236: LD_INT 23
8238: PUSH
8239: LD_INT 0
8241: PUSH
8242: LD_INT 0
8244: PUSH
8245: LD_INT 0
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
// for i in tmp do
8281: LD_ADDR_VAR 0 2
8285: PUSH
8286: LD_VAR 0 4
8290: PUSH
8291: FOR_IN
8292: IFFALSE 8523
// begin uc_side := side ;
8294: LD_ADDR_OWVAR 20
8298: PUSH
8299: LD_VAR 0 5
8303: ST_TO_ADDR
// uc_nation := nation_american ;
8304: LD_ADDR_OWVAR 21
8308: PUSH
8309: LD_INT 1
8311: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8312: LD_ADDR_OWVAR 42
8316: PUSH
8317: LD_VAR 0 2
8321: PUSH
8322: LD_INT 1
8324: ARRAY
8325: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8326: LD_ADDR_OWVAR 43
8330: PUSH
8331: LD_INT 5
8333: PPUSH
8334: LD_INT 6
8336: PPUSH
8337: CALL_OW 12
8341: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8342: LD_ADDR_OWVAR 44
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 5
8354: ARRAY
8355: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8356: LD_ADDR_OWVAR 45
8360: PUSH
8361: LD_VAR 0 2
8365: PUSH
8366: LD_INT 6
8368: ARRAY
8369: ST_TO_ADDR
// sr := 0 ;
8370: LD_ADDR_VAR 0 6
8374: PUSH
8375: LD_INT 0
8377: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8378: LD_VAR 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PUSH
8387: LD_INT 29
8389: EQUAL
8390: IFFALSE 8402
// sr := mat_oil else
8392: LD_ADDR_VAR 0 6
8396: PUSH
8397: LD_INT 2
8399: ST_TO_ADDR
8400: GO 8424
// if i [ 1 ] = b_siberite_mine then
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PUSH
8411: LD_INT 30
8413: EQUAL
8414: IFFALSE 8424
// sr := mat_siberit ;
8416: LD_ADDR_VAR 0 6
8420: PUSH
8421: LD_INT 3
8423: ST_TO_ADDR
// if sr then
8424: LD_VAR 0 6
8428: IFFALSE 8484
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8430: LD_VAR 0 2
8434: PUSH
8435: LD_INT 2
8437: ARRAY
8438: PPUSH
8439: LD_VAR 0 2
8443: PUSH
8444: LD_INT 3
8446: ARRAY
8447: PPUSH
8448: LD_VAR 0 6
8452: PPUSH
8453: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8457: LD_VAR 0 2
8461: PUSH
8462: LD_INT 2
8464: ARRAY
8465: PPUSH
8466: LD_VAR 0 2
8470: PUSH
8471: LD_INT 3
8473: ARRAY
8474: PPUSH
8475: LD_VAR 0 5
8479: PPUSH
8480: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8484: LD_ADDR_VAR 0 3
8488: PUSH
8489: LD_VAR 0 2
8493: PUSH
8494: LD_INT 2
8496: ARRAY
8497: PPUSH
8498: LD_VAR 0 2
8502: PUSH
8503: LD_INT 3
8505: ARRAY
8506: PPUSH
8507: LD_VAR 0 2
8511: PUSH
8512: LD_INT 4
8514: ARRAY
8515: PPUSH
8516: CALL_OW 47
8520: ST_TO_ADDR
// end ;
8521: GO 8291
8523: POP
8524: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8525: LD_ADDR_VAR 0 8
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 5
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 30
8544: PUSH
8545: LD_INT 1
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL_OW 69
8560: ST_TO_ADDR
// if not depot then
8561: LD_VAR 0 8
8565: NOT
8566: IFFALSE 8570
// exit ;
8568: GO 8842
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8570: LD_ADDR_VAR 0 7
8574: PUSH
8575: LD_VAR 0 8
8579: PUSH
8580: LD_INT 1
8582: ARRAY
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_STRING theta3
8589: PPUSH
8590: LD_INT 8
8592: PUSH
8593: LD_INT 7
8595: PUSH
8596: LD_INT 6
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: LD_OWVAR 67
8608: ARRAY
8609: PPUSH
8610: LD_INT 2500
8612: PUSH
8613: LD_INT 2000
8615: PUSH
8616: LD_INT 1750
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: LIST
8623: PUSH
8624: LD_OWVAR 67
8628: ARRAY
8629: PUSH
8630: LD_INT 300
8632: PUSH
8633: LD_INT 250
8635: PUSH
8636: LD_INT 200
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: LD_INT 80
8652: PUSH
8653: LD_INT 60
8655: PUSH
8656: LD_INT 50
8658: PUSH
8659: EMPTY
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_OWVAR 67
8668: ARRAY
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PPUSH
8675: LD_INT 7
8677: PUSH
8678: LD_INT 6
8680: PUSH
8681: LD_INT 5
8683: PUSH
8684: LD_INT 5
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: CALL 28545 0 6
8697: ST_TO_ADDR
// if not base then
8698: LD_VAR 0 7
8702: NOT
8703: IFFALSE 8707
// exit ;
8705: GO 8842
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8707: LD_ADDR_EXP 31
8711: PUSH
8712: LD_EXP 31
8716: PPUSH
8717: LD_EXP 5
8721: PPUSH
8722: LD_VAR 0 7
8726: PPUSH
8727: CALL_OW 1
8731: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8732: LD_INT 1
8734: PPUSH
8735: LD_INT 1
8737: PPUSH
8738: LD_INT 7
8740: PPUSH
8741: CALL_OW 380
// allyCommander := CreateHuman ;
8745: LD_ADDR_EXP 11
8749: PUSH
8750: CALL_OW 44
8754: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8755: LD_EXP 11
8759: PPUSH
8760: LD_INT 139
8762: PPUSH
8763: LD_INT 15
8765: PPUSH
8766: LD_INT 0
8768: PPUSH
8769: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8773: LD_EXP 11
8777: PPUSH
8778: LD_INT 137
8780: PPUSH
8781: LD_INT 15
8783: PPUSH
8784: CALL_OW 118
// hc_gallery := us ;
8788: LD_ADDR_OWVAR 33
8792: PUSH
8793: LD_STRING us
8795: ST_TO_ADDR
// hc_face_number := 7 ;
8796: LD_ADDR_OWVAR 34
8800: PUSH
8801: LD_INT 7
8803: ST_TO_ADDR
// hc_name := Arthur Powell ;
8804: LD_ADDR_OWVAR 26
8808: PUSH
8809: LD_STRING Arthur Powell
8811: ST_TO_ADDR
// hc_sex := sex_male ;
8812: LD_ADDR_OWVAR 27
8816: PUSH
8817: LD_INT 1
8819: ST_TO_ADDR
// hc_class := 1 ;
8820: LD_ADDR_OWVAR 28
8824: PUSH
8825: LD_INT 1
8827: ST_TO_ADDR
// Powell := CreateHuman ;
8828: LD_ADDR_EXP 12
8832: PUSH
8833: CALL_OW 44
8837: ST_TO_ADDR
// InitHc ;
8838: CALL_OW 19
// end ;
8842: LD_VAR 0 1
8846: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8847: LD_INT 0
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
// side := 1 ;
8858: LD_ADDR_VAR 0 3
8862: PUSH
8863: LD_INT 1
8865: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8866: LD_ADDR_VAR 0 1
8870: PUSH
8871: EMPTY
8872: PUSH
8873: EMPTY
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: ST_TO_ADDR
// uc_side := side ;
8879: LD_ADDR_OWVAR 20
8883: PUSH
8884: LD_VAR 0 3
8888: ST_TO_ADDR
// uc_nation := nation_american ;
8889: LD_ADDR_OWVAR 21
8893: PUSH
8894: LD_INT 1
8896: ST_TO_ADDR
// InitHc ;
8897: CALL_OW 19
// InitVc ;
8901: CALL_OW 20
// hc_importance := 0 ;
8905: LD_ADDR_OWVAR 32
8909: PUSH
8910: LD_INT 0
8912: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8913: LD_ADDR_VAR 0 7
8917: PUSH
8918: LD_INT 2
8920: PUSH
8921: LD_INT 3
8923: PUSH
8924: LD_INT 3
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// if commander = 2 then
8932: LD_EXP 25
8936: PUSH
8937: LD_INT 2
8939: EQUAL
8940: IFFALSE 8961
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8942: LD_ADDR_VAR 0 7
8946: PUSH
8947: LD_INT 3
8949: PUSH
8950: LD_INT 4
8952: PUSH
8953: LD_INT 4
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: LIST
8960: ST_TO_ADDR
// if commander = 3 then
8961: LD_EXP 25
8965: PUSH
8966: LD_INT 3
8968: EQUAL
8969: IFFALSE 8990
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8971: LD_ADDR_VAR 0 7
8975: PUSH
8976: LD_INT 2
8978: PUSH
8979: LD_INT 5
8981: PUSH
8982: LD_INT 5
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8990: LD_ADDR_VAR 0 8
8994: PUSH
8995: LD_INT 2
8997: PUSH
8998: LD_INT 2
9000: PUSH
9001: LD_INT 1
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: LIST
9008: ST_TO_ADDR
// if commander = 2 then
9009: LD_EXP 25
9013: PUSH
9014: LD_INT 2
9016: EQUAL
9017: IFFALSE 9038
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
9019: LD_ADDR_VAR 0 8
9023: PUSH
9024: LD_INT 1
9026: PUSH
9027: LD_INT 1
9029: PUSH
9030: LD_INT 3
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: ST_TO_ADDR
// if commander = 3 then
9038: LD_EXP 25
9042: PUSH
9043: LD_INT 3
9045: EQUAL
9046: IFFALSE 9067
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9048: LD_ADDR_VAR 0 8
9052: PUSH
9053: LD_INT 3
9055: PUSH
9056: LD_INT 3
9058: PUSH
9059: LD_INT 1
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: LIST
9066: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9067: LD_ADDR_VAR 0 9
9071: PUSH
9072: LD_INT 5
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: LD_INT 4
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// if commander = 2 then
9086: LD_EXP 25
9090: PUSH
9091: LD_INT 2
9093: EQUAL
9094: IFFALSE 9115
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9096: LD_ADDR_VAR 0 9
9100: PUSH
9101: LD_INT 7
9103: PUSH
9104: LD_INT 5
9106: PUSH
9107: LD_INT 6
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: ST_TO_ADDR
// if commander = 3 then
9115: LD_EXP 25
9119: PUSH
9120: LD_INT 3
9122: EQUAL
9123: IFFALSE 9144
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9125: LD_ADDR_VAR 0 9
9129: PUSH
9130: LD_INT 9
9132: PUSH
9133: LD_INT 10
9135: PUSH
9136: LD_INT 7
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: LIST
9143: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9144: LD_ADDR_VAR 0 5
9148: PUSH
9149: LD_INT 5
9151: PUSH
9152: LD_INT 5
9154: PUSH
9155: LD_INT 4
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_OWVAR 67
9167: ARRAY
9168: ST_TO_ADDR
// if commander = 2 then
9169: LD_EXP 25
9173: PUSH
9174: LD_INT 2
9176: EQUAL
9177: IFFALSE 9193
// tanks := tanks + 3 ;
9179: LD_ADDR_VAR 0 5
9183: PUSH
9184: LD_VAR 0 5
9188: PUSH
9189: LD_INT 3
9191: PLUS
9192: ST_TO_ADDR
// for i = 1 to tanks do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_VAR 0 5
9207: PUSH
9208: FOR_TO
9209: IFFALSE 9319
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9211: LD_VAR 0 7
9215: PUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 3
9223: MOD
9224: PUSH
9225: LD_INT 1
9227: PLUS
9228: ARRAY
9229: PPUSH
9230: LD_VAR 0 8
9234: PUSH
9235: LD_INT 1
9237: PPUSH
9238: LD_INT 3
9240: PPUSH
9241: CALL_OW 12
9245: ARRAY
9246: PPUSH
9247: LD_INT 1
9249: PPUSH
9250: LD_VAR 0 9
9254: PUSH
9255: LD_VAR 0 2
9259: PUSH
9260: LD_INT 3
9262: MOD
9263: PUSH
9264: LD_INT 1
9266: PLUS
9267: ARRAY
9268: PPUSH
9269: LD_INT 60
9271: PPUSH
9272: LD_INT 70
9274: PPUSH
9275: CALL_OW 12
9279: PPUSH
9280: CALL 24724 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9284: LD_ADDR_VAR 0 1
9288: PUSH
9289: LD_VAR 0 1
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: LD_VAR 0 1
9301: PUSH
9302: LD_INT 1
9304: ARRAY
9305: PUSH
9306: CALL_OW 45
9310: ADD
9311: PPUSH
9312: CALL_OW 1
9316: ST_TO_ADDR
// end ;
9317: GO 9208
9319: POP
9320: POP
// cl := 1 ;
9321: LD_ADDR_VAR 0 6
9325: PUSH
9326: LD_INT 1
9328: ST_TO_ADDR
// for i = 1 to 10 do
9329: LD_ADDR_VAR 0 2
9333: PUSH
9334: DOUBLE
9335: LD_INT 1
9337: DEC
9338: ST_TO_ADDR
9339: LD_INT 10
9341: PUSH
9342: FOR_TO
9343: IFFALSE 9458
// begin if i mod 4 = 0 then
9345: LD_VAR 0 2
9349: PUSH
9350: LD_INT 4
9352: MOD
9353: PUSH
9354: LD_INT 0
9356: EQUAL
9357: IFFALSE 9373
// cl := cl + 1 ;
9359: LD_ADDR_VAR 0 6
9363: PUSH
9364: LD_VAR 0 6
9368: PUSH
9369: LD_INT 1
9371: PLUS
9372: ST_TO_ADDR
// if cl = 2 then
9373: LD_VAR 0 6
9377: PUSH
9378: LD_INT 2
9380: EQUAL
9381: IFFALSE 9391
// cl := 3 ;
9383: LD_ADDR_VAR 0 6
9387: PUSH
9388: LD_INT 3
9390: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9391: LD_INT 0
9393: PPUSH
9394: LD_VAR 0 6
9398: PPUSH
9399: LD_INT 6
9401: PUSH
9402: LD_INT 6
9404: PUSH
9405: LD_INT 5
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PPUSH
9419: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: LD_VAR 0 1
9432: PPUSH
9433: LD_INT 2
9435: PPUSH
9436: LD_VAR 0 1
9440: PUSH
9441: LD_INT 2
9443: ARRAY
9444: PUSH
9445: CALL_OW 44
9449: ADD
9450: PPUSH
9451: CALL_OW 1
9455: ST_TO_ADDR
// end ;
9456: GO 9342
9458: POP
9459: POP
// if commander = 1 then
9460: LD_EXP 25
9464: PUSH
9465: LD_INT 1
9467: EQUAL
9468: IFFALSE 9536
// for i = 1 to 4 do
9470: LD_ADDR_VAR 0 2
9474: PUSH
9475: DOUBLE
9476: LD_INT 1
9478: DEC
9479: ST_TO_ADDR
9480: LD_INT 4
9482: PUSH
9483: FOR_TO
9484: IFFALSE 9534
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9486: LD_INT 0
9488: PPUSH
9489: LD_INT 1
9491: PPUSH
9492: LD_INT 8
9494: PPUSH
9495: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9499: LD_ADDR_VAR 0 1
9503: PUSH
9504: LD_VAR 0 1
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: LD_VAR 0 1
9516: PUSH
9517: LD_INT 2
9519: ARRAY
9520: PUSH
9521: CALL_OW 44
9525: ADD
9526: PPUSH
9527: CALL_OW 1
9531: ST_TO_ADDR
// end ;
9532: GO 9483
9534: POP
9535: POP
// techs := [ ] ;
9536: LD_ADDR_VAR 0 4
9540: PUSH
9541: EMPTY
9542: ST_TO_ADDR
// if commander = 1 then
9543: LD_EXP 25
9547: PUSH
9548: LD_INT 1
9550: EQUAL
9551: IFFALSE 9576
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9553: LD_ADDR_VAR 0 4
9557: PUSH
9558: LD_INT 51
9560: PUSH
9561: LD_INT 52
9563: PUSH
9564: LD_INT 53
9566: PUSH
9567: LD_INT 12
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: ST_TO_ADDR
// if commander = 2 then
9576: LD_EXP 25
9580: PUSH
9581: LD_INT 2
9583: EQUAL
9584: IFFALSE 9621
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9586: LD_ADDR_VAR 0 4
9590: PUSH
9591: LD_INT 48
9593: PUSH
9594: LD_INT 47
9596: PUSH
9597: LD_INT 46
9599: PUSH
9600: LD_INT 45
9602: PUSH
9603: LD_INT 35
9605: PUSH
9606: LD_INT 60
9608: PUSH
9609: LD_INT 6
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: ST_TO_ADDR
// if commander = 3 then
9621: LD_EXP 25
9625: PUSH
9626: LD_INT 3
9628: EQUAL
9629: IFFALSE 9678
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9631: LD_ADDR_VAR 0 4
9635: PUSH
9636: LD_INT 27
9638: PUSH
9639: LD_INT 36
9641: PUSH
9642: LD_INT 32
9644: PUSH
9645: LD_INT 57
9647: PUSH
9648: LD_INT 58
9650: PUSH
9651: LD_INT 47
9653: PUSH
9654: LD_INT 46
9656: PUSH
9657: LD_INT 51
9659: PUSH
9660: LD_INT 69
9662: PUSH
9663: LD_INT 39
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// if techs then
9678: LD_VAR 0 4
9682: IFFALSE 9716
// for i in techs do
9684: LD_ADDR_VAR 0 2
9688: PUSH
9689: LD_VAR 0 4
9693: PUSH
9694: FOR_IN
9695: IFFALSE 9714
// SetTech ( i , 1 , state_researched ) ;
9697: LD_VAR 0 2
9701: PPUSH
9702: LD_INT 1
9704: PPUSH
9705: LD_INT 2
9707: PPUSH
9708: CALL_OW 322
9712: GO 9694
9714: POP
9715: POP
// hc_gallery := skirmish ;
9716: LD_ADDR_OWVAR 33
9720: PUSH
9721: LD_STRING skirmish
9723: ST_TO_ADDR
// hc_face_number := commander ;
9724: LD_ADDR_OWVAR 34
9728: PUSH
9729: LD_EXP 25
9733: ST_TO_ADDR
// hc_importance := 100 ;
9734: LD_ADDR_OWVAR 32
9738: PUSH
9739: LD_INT 100
9741: ST_TO_ADDR
// case commander of 1 :
9742: LD_EXP 25
9746: PUSH
9747: LD_INT 1
9749: DOUBLE
9750: EQUAL
9751: IFTRUE 9755
9753: GO 9779
9755: POP
// begin hc_name := Jeff Ironside ;
9756: LD_ADDR_OWVAR 26
9760: PUSH
9761: LD_STRING Jeff Ironside
9763: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9764: LD_INT 1
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 7
9772: PPUSH
9773: CALL_OW 380
// end ; 2 :
9777: GO 9844
9779: LD_INT 2
9781: DOUBLE
9782: EQUAL
9783: IFTRUE 9787
9785: GO 9811
9787: POP
// begin hc_name := Paul Johnson ;
9788: LD_ADDR_OWVAR 26
9792: PUSH
9793: LD_STRING Paul Johnson
9795: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9796: LD_INT 1
9798: PPUSH
9799: LD_INT 3
9801: PPUSH
9802: LD_INT 7
9804: PPUSH
9805: CALL_OW 380
// end ; 3 :
9809: GO 9844
9811: LD_INT 3
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9843
9819: POP
// begin hc_name := Lisa Stuart ;
9820: LD_ADDR_OWVAR 26
9824: PUSH
9825: LD_STRING Lisa Stuart
9827: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9828: LD_INT 2
9830: PPUSH
9831: LD_INT 4
9833: PPUSH
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 380
// end ; end ;
9841: GO 9844
9843: POP
// playerCommander := CreateHuman ;
9844: LD_ADDR_EXP 9
9848: PUSH
9849: CALL_OW 44
9853: ST_TO_ADDR
// hc_importance := 0 ;
9854: LD_ADDR_OWVAR 32
9858: PUSH
9859: LD_INT 0
9861: ST_TO_ADDR
// hc_gallery :=  ;
9862: LD_ADDR_OWVAR 33
9866: PUSH
9867: LD_STRING 
9869: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9870: LD_ADDR_VAR 0 1
9874: PUSH
9875: LD_VAR 0 1
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_INT 2
9890: ARRAY
9891: PUSH
9892: LD_EXP 9
9896: ADD
9897: PPUSH
9898: CALL_OW 1
9902: ST_TO_ADDR
// end ;
9903: LD_VAR 0 1
9907: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9908: LD_INT 0
9910: PPUSH
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// uc_side := 1 ;
9916: LD_ADDR_OWVAR 20
9920: PUSH
9921: LD_INT 1
9923: ST_TO_ADDR
// uc_nation := 1 ;
9924: LD_ADDR_OWVAR 21
9928: PUSH
9929: LD_INT 1
9931: ST_TO_ADDR
// InitHc ;
9932: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9936: LD_ADDR_VAR 0 3
9940: PUSH
9941: LD_INT 3
9943: PUSH
9944: LD_INT 3
9946: PUSH
9947: LD_INT 2
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: LIST
9954: PUSH
9955: LD_OWVAR 67
9959: ARRAY
9960: ST_TO_ADDR
// for i = 1 to peopleAmount do
9961: LD_ADDR_VAR 0 2
9965: PUSH
9966: DOUBLE
9967: LD_INT 1
9969: DEC
9970: ST_TO_ADDR
9971: LD_VAR 0 3
9975: PUSH
9976: FOR_TO
9977: IFFALSE 10026
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9979: LD_INT 0
9981: PPUSH
9982: LD_INT 2
9984: PPUSH
9985: LD_INT 7
9987: PUSH
9988: LD_INT 6
9990: PUSH
9991: LD_INT 5
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: PUSH
9999: LD_OWVAR 67
10003: ARRAY
10004: PPUSH
10005: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
10009: CALL_OW 44
10013: PPUSH
10014: LD_INT 19
10016: PPUSH
10017: LD_INT 0
10019: PPUSH
10020: CALL 56491 0 3
// end ;
10024: GO 9976
10026: POP
10027: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
10028: LD_INT 2
10030: PPUSH
10031: LD_INT 1
10033: PPUSH
10034: LD_INT 3
10036: PPUSH
10037: LD_INT 13
10039: PPUSH
10040: LD_INT 58
10042: PPUSH
10043: CALL 24724 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10047: CALL_OW 45
10051: PPUSH
10052: LD_INT 19
10054: PPUSH
10055: LD_INT 0
10057: PPUSH
10058: CALL 56491 0 3
// if commander = 1 then
10062: LD_EXP 25
10066: PUSH
10067: LD_INT 1
10069: EQUAL
10070: IFFALSE 10081
// wait ( 6 6$00 ) else
10072: LD_INT 12600
10074: PPUSH
10075: CALL_OW 67
10079: GO 10088
// wait ( 8 8$00 ) ;
10081: LD_INT 16800
10083: PPUSH
10084: CALL_OW 67
// uc_side := 1 ;
10088: LD_ADDR_OWVAR 20
10092: PUSH
10093: LD_INT 1
10095: ST_TO_ADDR
// uc_nation := 1 ;
10096: LD_ADDR_OWVAR 21
10100: PUSH
10101: LD_INT 1
10103: ST_TO_ADDR
// InitVc ;
10104: CALL_OW 20
// InitHc ;
10108: CALL_OW 19
// for i = 1 to 5 do
10112: LD_ADDR_VAR 0 2
10116: PUSH
10117: DOUBLE
10118: LD_INT 1
10120: DEC
10121: ST_TO_ADDR
10122: LD_INT 5
10124: PUSH
10125: FOR_TO
10126: IFFALSE 10370
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10128: LD_INT 4
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 1
10136: PUSH
10137: EMPTY
10138: LIST
10139: LIST
10140: LIST
10141: PUSH
10142: LD_VAR 0 2
10146: PUSH
10147: LD_INT 3
10149: MOD
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 1
10158: PPUSH
10159: LD_INT 1
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 2
10177: PUSH
10178: LD_INT 3
10180: MOD
10181: PUSH
10182: LD_INT 1
10184: PLUS
10185: ARRAY
10186: PPUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 12
10192: PUSH
10193: LD_INT 11
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: PUSH
10201: LD_VAR 0 2
10205: PUSH
10206: LD_INT 3
10208: MOD
10209: PUSH
10210: LD_INT 1
10212: PLUS
10213: ARRAY
10214: PPUSH
10215: LD_INT 40
10217: PPUSH
10218: LD_INT 55
10220: PPUSH
10221: CALL_OW 12
10225: PPUSH
10226: CALL 24724 0 5
// veh := CreateVehicle ;
10230: LD_ADDR_VAR 0 6
10234: PUSH
10235: CALL_OW 45
10239: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10240: LD_VAR 0 6
10244: PPUSH
10245: LD_INT 19
10247: PPUSH
10248: LD_INT 0
10250: PPUSH
10251: CALL 56491 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10255: LD_VAR 0 6
10259: PPUSH
10260: CALL_OW 264
10264: PUSH
10265: LD_INT 12
10267: EQUAL
10268: IFFALSE 10300
// begin AddCargo ( veh , mat_cans , 70 ) ;
10270: LD_VAR 0 6
10274: PPUSH
10275: LD_INT 1
10277: PPUSH
10278: LD_INT 70
10280: PPUSH
10281: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10285: LD_VAR 0 6
10289: PPUSH
10290: LD_INT 3
10292: PPUSH
10293: LD_INT 30
10295: PPUSH
10296: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10300: LD_VAR 0 6
10304: PPUSH
10305: CALL_OW 263
10309: PUSH
10310: LD_INT 1
10312: EQUAL
10313: IFFALSE 10368
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10315: LD_INT 1
10317: PPUSH
10318: LD_INT 3
10320: PPUSH
10321: LD_INT 6
10323: PPUSH
10324: CALL_OW 380
// un := CreateHuman ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: CALL_OW 44
10337: ST_TO_ADDR
// tmp := tmp ^ un ;
10338: LD_ADDR_VAR 0 4
10342: PUSH
10343: LD_VAR 0 4
10347: PUSH
10348: LD_VAR 0 5
10352: ADD
10353: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10354: LD_VAR 0 5
10358: PPUSH
10359: LD_VAR 0 6
10363: PPUSH
10364: CALL_OW 52
// end ; end ;
10368: GO 10125
10370: POP
10371: POP
// if tmp then
10372: LD_VAR 0 4
10376: IFFALSE 10440
// begin CenterNowOnUnits ( tmp ) ;
10378: LD_VAR 0 4
10382: PPUSH
10383: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10387: LD_VAR 0 4
10391: PUSH
10392: LD_INT 1
10394: ARRAY
10395: PPUSH
10396: LD_STRING DAR-1
10398: PPUSH
10399: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10403: LD_EXP 9
10407: PPUSH
10408: LD_STRING D
10410: PUSH
10411: LD_STRING I
10413: PUSH
10414: LD_STRING J
10416: PUSH
10417: LD_STRING S
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_EXP 25
10429: ARRAY
10430: STR
10431: PUSH
10432: LD_STRING -1-DAR
10434: STR
10435: PPUSH
10436: CALL_OW 88
// end ; if not reinforceAllowed then
10440: LD_EXP 24
10444: NOT
10445: IFFALSE 10449
// exit ;
10447: GO 10603
// wait ( 25 25$00 ) ;
10449: LD_INT 52500
10451: PPUSH
10452: CALL_OW 67
// uc_side := 1 ;
10456: LD_ADDR_OWVAR 20
10460: PUSH
10461: LD_INT 1
10463: ST_TO_ADDR
// uc_nation := 1 ;
10464: LD_ADDR_OWVAR 21
10468: PUSH
10469: LD_INT 1
10471: ST_TO_ADDR
// InitVc ;
10472: CALL_OW 20
// InitHc ;
10476: CALL_OW 19
// for i = 1 to 4 do
10480: LD_ADDR_VAR 0 2
10484: PUSH
10485: DOUBLE
10486: LD_INT 1
10488: DEC
10489: ST_TO_ADDR
10490: LD_INT 4
10492: PUSH
10493: FOR_TO
10494: IFFALSE 10601
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10496: LD_INT 5
10498: PPUSH
10499: LD_INT 3
10501: PPUSH
10502: LD_INT 1
10504: PPUSH
10505: LD_INT 6
10507: PPUSH
10508: LD_INT 1
10510: PPUSH
10511: CALL 24724 0 5
// veh := CreateVehicle ;
10515: LD_ADDR_VAR 0 6
10519: PUSH
10520: CALL_OW 45
10524: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10525: LD_VAR 0 6
10529: PPUSH
10530: LD_INT 19
10532: PPUSH
10533: LD_INT 0
10535: PPUSH
10536: CALL 56491 0 3
// if GetControl ( veh ) = control_manual then
10540: LD_VAR 0 6
10544: PPUSH
10545: CALL_OW 263
10549: PUSH
10550: LD_INT 1
10552: EQUAL
10553: IFFALSE 10599
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10555: LD_INT 0
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_INT 7
10563: PUSH
10564: LD_INT 6
10566: PUSH
10567: LD_INT 5
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: LIST
10574: PUSH
10575: LD_OWVAR 67
10579: ARRAY
10580: PPUSH
10581: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10585: CALL_OW 44
10589: PPUSH
10590: LD_VAR 0 6
10594: PPUSH
10595: CALL_OW 52
// end ; end ;
10599: GO 10493
10601: POP
10602: POP
// end ;
10603: LD_VAR 0 1
10607: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10608: LD_INT 0
10610: PPUSH
10611: PPUSH
10612: PPUSH
10613: PPUSH
10614: PPUSH
// uc_side := 8 ;
10615: LD_ADDR_OWVAR 20
10619: PUSH
10620: LD_INT 8
10622: ST_TO_ADDR
// uc_nation := nation_arabian ;
10623: LD_ADDR_OWVAR 21
10627: PUSH
10628: LD_INT 2
10630: ST_TO_ADDR
// for i = 1 to 2 do
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: DOUBLE
10637: LD_INT 1
10639: DEC
10640: ST_TO_ADDR
10641: LD_INT 2
10643: PUSH
10644: FOR_TO
10645: IFFALSE 10725
// for j = 1 to 4 do
10647: LD_ADDR_VAR 0 4
10651: PUSH
10652: DOUBLE
10653: LD_INT 1
10655: DEC
10656: ST_TO_ADDR
10657: LD_INT 4
10659: PUSH
10660: FOR_TO
10661: IFFALSE 10721
// begin PrepareHuman ( false , j , 8 ) ;
10663: LD_INT 0
10665: PPUSH
10666: LD_VAR 0 4
10670: PPUSH
10671: LD_INT 8
10673: PPUSH
10674: CALL_OW 380
// un := CreateHuman ;
10678: LD_ADDR_VAR 0 3
10682: PUSH
10683: CALL_OW 44
10687: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10688: LD_VAR 0 3
10692: PPUSH
10693: LD_INT 23
10695: PPUSH
10696: LD_INT 0
10698: PPUSH
10699: CALL_OW 49
// tmp := tmp union un ;
10703: LD_ADDR_VAR 0 5
10707: PUSH
10708: LD_VAR 0 5
10712: PUSH
10713: LD_VAR 0 3
10717: UNION
10718: ST_TO_ADDR
// end ;
10719: GO 10660
10721: POP
10722: POP
10723: GO 10644
10725: POP
10726: POP
// for i in tmp do
10727: LD_ADDR_VAR 0 2
10731: PUSH
10732: LD_VAR 0 5
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10757
// ComMoveXY ( i , 150 , 136 ) ;
10740: LD_VAR 0 2
10744: PPUSH
10745: LD_INT 150
10747: PPUSH
10748: LD_INT 136
10750: PPUSH
10751: CALL_OW 111
10755: GO 10737
10757: POP
10758: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10759: LD_ADDR_EXP 31
10763: PUSH
10764: LD_EXP 31
10768: PPUSH
10769: LD_EXP 6
10773: PPUSH
10774: LD_EXP 31
10778: PUSH
10779: LD_EXP 6
10783: ARRAY
10784: PUSH
10785: LD_VAR 0 5
10789: UNION
10790: PPUSH
10791: CALL_OW 1
10795: ST_TO_ADDR
// end ;
10796: LD_VAR 0 1
10800: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10801: LD_OWVAR 67
10805: PUSH
10806: LD_INT 1
10808: GREATER
10809: PUSH
10810: LD_INT 31
10812: PPUSH
10813: LD_INT 3
10815: PPUSH
10816: CALL_OW 321
10820: PUSH
10821: LD_INT 2
10823: EQUAL
10824: AND
10825: IFFALSE 11042
10827: GO 10829
10829: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10830: LD_EXP 7
10834: PPUSH
10835: LD_INT 33
10837: PUSH
10838: LD_INT 101
10840: PUSH
10841: LD_INT 159
10843: PUSH
10844: LD_INT 5
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 33
10855: PUSH
10856: LD_INT 105
10858: PUSH
10859: LD_INT 158
10861: PUSH
10862: LD_INT 5
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 33
10873: PUSH
10874: LD_INT 96
10876: PUSH
10877: LD_INT 136
10879: PUSH
10880: LD_INT 5
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PUSH
10889: LD_INT 33
10891: PUSH
10892: LD_INT 94
10894: PUSH
10895: LD_INT 133
10897: PUSH
10898: LD_INT 4
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: LD_INT 33
10909: PUSH
10910: LD_INT 84
10912: PUSH
10913: LD_INT 102
10915: PUSH
10916: LD_INT 4
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PPUSH
10932: CALL 85982 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10936: LD_EXP 8
10940: PPUSH
10941: LD_INT 33
10943: PUSH
10944: LD_INT 50
10946: PUSH
10947: LD_INT 17
10949: PUSH
10950: LD_INT 4
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: PUSH
10959: LD_INT 33
10961: PUSH
10962: LD_INT 52
10964: PUSH
10965: LD_INT 20
10967: PUSH
10968: LD_INT 4
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 33
10979: PUSH
10980: LD_INT 53
10982: PUSH
10983: LD_INT 23
10985: PUSH
10986: LD_INT 4
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 33
10997: PUSH
10998: LD_INT 45
11000: PUSH
11001: LD_INT 32
11003: PUSH
11004: LD_INT 4
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: LIST
11011: LIST
11012: PUSH
11013: LD_INT 33
11015: PUSH
11016: LD_INT 45
11018: PUSH
11019: LD_INT 39
11021: PUSH
11022: LD_INT 4
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL 85982 0 2
// end ;
11042: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11043: LD_INT 3
11045: PUSH
11046: LD_INT 22
11048: PUSH
11049: LD_OWVAR 2
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PUSH
11062: LD_INT 33
11064: PUSH
11065: LD_INT 2
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: LD_INT 50
11074: PUSH
11075: EMPTY
11076: LIST
11077: PUSH
11078: LD_INT 3
11080: PUSH
11081: LD_INT 61
11083: PUSH
11084: EMPTY
11085: LIST
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PUSH
11091: EMPTY
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: PPUSH
11097: CALL_OW 69
11101: IFFALSE 11201
11103: GO 11105
11105: DISABLE
11106: LD_INT 0
11108: PPUSH
11109: PPUSH
// begin enable ;
11110: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11111: LD_ADDR_VAR 0 2
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 22
11121: PUSH
11122: LD_OWVAR 2
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 33
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 50
11147: PUSH
11148: EMPTY
11149: LIST
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: LD_INT 61
11156: PUSH
11157: EMPTY
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: PPUSH
11170: CALL_OW 69
11174: ST_TO_ADDR
// for i in tmp do
11175: LD_ADDR_VAR 0 1
11179: PUSH
11180: LD_VAR 0 2
11184: PUSH
11185: FOR_IN
11186: IFFALSE 11199
// Connect ( i ) ;
11188: LD_VAR 0 1
11192: PPUSH
11193: CALL 28192 0 1
11197: GO 11185
11199: POP
11200: POP
// end ; end_of_file
11201: PPOPN 2
11203: END
// export function Action ; var i , tmp ; begin
11204: LD_INT 0
11206: PPUSH
11207: PPUSH
11208: PPUSH
// InGameOn ;
11209: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11213: LD_INT 225
11215: PPUSH
11216: LD_INT 217
11218: PPUSH
11219: CALL_OW 86
// for i in playerForces [ 2 ] do
11223: LD_ADDR_VAR 0 2
11227: PUSH
11228: LD_EXP 10
11232: PUSH
11233: LD_INT 2
11235: ARRAY
11236: PUSH
11237: FOR_IN
11238: IFFALSE 11371
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11240: LD_EXP 10
11244: PUSH
11245: LD_INT 1
11247: ARRAY
11248: PUSH
11249: LD_VAR 0 2
11253: PPUSH
11254: CALL_OW 257
11258: PUSH
11259: LD_INT 3
11261: PUSH
11262: LD_INT 4
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: IN
11269: AND
11270: IFFALSE 11354
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11272: LD_EXP 10
11276: PUSH
11277: LD_INT 1
11279: ARRAY
11280: PUSH
11281: LD_INT 1
11283: ARRAY
11284: PPUSH
11285: LD_INT 19
11287: PPUSH
11288: LD_INT 0
11290: PPUSH
11291: CALL 56491 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11295: LD_VAR 0 2
11299: PPUSH
11300: LD_EXP 10
11304: PUSH
11305: LD_INT 1
11307: ARRAY
11308: PUSH
11309: LD_INT 1
11311: ARRAY
11312: PPUSH
11313: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11317: LD_ADDR_EXP 10
11321: PUSH
11322: LD_EXP 10
11326: PPUSH
11327: LD_INT 1
11329: PPUSH
11330: LD_EXP 10
11334: PUSH
11335: LD_INT 1
11337: ARRAY
11338: PPUSH
11339: LD_INT 1
11341: PPUSH
11342: CALL_OW 3
11346: PPUSH
11347: CALL_OW 1
11351: ST_TO_ADDR
// end else
11352: GO 11369
// PlaceUnitInArea ( i , startArea , false ) ;
11354: LD_VAR 0 2
11358: PPUSH
11359: LD_INT 19
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL 56491 0 3
// end ;
11369: GO 11237
11371: POP
11372: POP
// wait ( 0 0$2 ) ;
11373: LD_INT 70
11375: PPUSH
11376: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11380: LD_EXP 9
11384: PPUSH
11385: LD_STRING D
11387: PUSH
11388: LD_STRING I
11390: PUSH
11391: LD_STRING J
11393: PUSH
11394: LD_STRING S
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: LIST
11401: PUSH
11402: LD_EXP 25
11406: ARRAY
11407: STR
11408: PUSH
11409: LD_STRING -1
11411: STR
11412: PPUSH
11413: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11417: LD_EXP 12
11421: PPUSH
11422: LD_STRING DP-1
11424: PPUSH
11425: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11429: LD_EXP 12
11433: PPUSH
11434: LD_STRING DP-2
11436: PPUSH
11437: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11441: LD_EXP 9
11445: PPUSH
11446: LD_STRING D
11448: PUSH
11449: LD_STRING I
11451: PUSH
11452: LD_STRING J
11454: PUSH
11455: LD_STRING S
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: PUSH
11463: LD_EXP 25
11467: ARRAY
11468: STR
11469: PUSH
11470: LD_STRING -2
11472: STR
11473: PPUSH
11474: CALL_OW 88
// InGameOff ;
11478: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11482: LD_STRING O1
11484: PPUSH
11485: CALL_OW 337
// game := true ;
11489: LD_ADDR_EXP 3
11493: PUSH
11494: LD_INT 1
11496: ST_TO_ADDR
// SaveForQuickRestart ;
11497: CALL_OW 22
// wait ( 0 0$5 ) ;
11501: LD_INT 175
11503: PPUSH
11504: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11508: LD_EXP 9
11512: PPUSH
11513: LD_STRING D
11515: PUSH
11516: LD_STRING I
11518: PUSH
11519: LD_STRING J
11521: PUSH
11522: LD_STRING S
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: LIST
11529: PUSH
11530: LD_EXP 25
11534: ARRAY
11535: STR
11536: PUSH
11537: LD_STRING -3
11539: STR
11540: PPUSH
11541: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11545: LD_INT 35
11547: PPUSH
11548: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11552: LD_EXP 15
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PUSH
11561: LD_EXP 15
11565: PUSH
11566: LD_INT 2
11568: ARRAY
11569: GREATEREQUAL
11570: IFFALSE 11545
// outpostEscape := true ;
11572: LD_ADDR_EXP 27
11576: PUSH
11577: LD_INT 1
11579: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11580: LD_ADDR_VAR 0 3
11584: PUSH
11585: LD_EXP 14
11589: PPUSH
11590: LD_INT 26
11592: PUSH
11593: LD_INT 1
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PPUSH
11600: CALL_OW 72
11604: ST_TO_ADDR
// if tmp then
11605: LD_VAR 0 3
11609: IFFALSE 11627
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11611: LD_VAR 0 3
11615: PUSH
11616: LD_INT 1
11618: ARRAY
11619: PPUSH
11620: LD_STRING DR-1-Escape
11622: PPUSH
11623: CALL_OW 88
// wait ( 0 0$1 ) ;
11627: LD_INT 35
11629: PPUSH
11630: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11634: LD_EXP 9
11638: PPUSH
11639: LD_STRING D
11641: PUSH
11642: LD_STRING I
11644: PUSH
11645: LD_STRING J
11647: PUSH
11648: LD_STRING S
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: LIST
11655: PUSH
11656: LD_EXP 25
11660: ARRAY
11661: STR
11662: PUSH
11663: LD_STRING -1-Escape
11665: STR
11666: PPUSH
11667: CALL_OW 88
// for i in ruOutpost do
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_EXP 14
11680: PUSH
11681: FOR_IN
11682: IFFALSE 11736
// begin if IsInUnit ( i ) then
11684: LD_VAR 0 2
11688: PPUSH
11689: CALL_OW 310
11693: IFFALSE 11704
// ComExitBuilding ( i ) ;
11695: LD_VAR 0 2
11699: PPUSH
11700: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11704: LD_VAR 0 2
11708: PPUSH
11709: LD_INT 179
11711: PPUSH
11712: LD_INT 102
11714: PPUSH
11715: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11719: LD_VAR 0 2
11723: PPUSH
11724: LD_INT 28
11726: PPUSH
11727: LD_INT 20
11729: PPUSH
11730: CALL_OW 171
// end ;
11734: GO 11681
11736: POP
11737: POP
// tmp := [ ] ;
11738: LD_ADDR_VAR 0 3
11742: PUSH
11743: EMPTY
11744: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11745: LD_INT 35
11747: PPUSH
11748: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11752: LD_ADDR_VAR 0 3
11756: PUSH
11757: LD_EXP 14
11761: PPUSH
11762: LD_INT 95
11764: PUSH
11765: LD_INT 11
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PPUSH
11772: CALL_OW 72
11776: ST_TO_ADDR
// if tmp then
11777: LD_VAR 0 3
11781: IFFALSE 11860
// for i in tmp do
11783: LD_ADDR_VAR 0 2
11787: PUSH
11788: LD_VAR 0 3
11792: PUSH
11793: FOR_IN
11794: IFFALSE 11858
// begin ruOutpost := ruOutpost diff i ;
11796: LD_ADDR_EXP 14
11800: PUSH
11801: LD_EXP 14
11805: PUSH
11806: LD_VAR 0 2
11810: DIFF
11811: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11812: LD_ADDR_EXP 31
11816: PUSH
11817: LD_EXP 31
11821: PPUSH
11822: LD_EXP 8
11826: PUSH
11827: LD_EXP 31
11831: PUSH
11832: LD_EXP 8
11836: ARRAY
11837: PUSH
11838: LD_INT 1
11840: PLUS
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: PPUSH
11846: LD_VAR 0 2
11850: PPUSH
11851: CALL 24846 0 3
11855: ST_TO_ADDR
// end ;
11856: GO 11793
11858: POP
11859: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11860: LD_EXP 14
11864: PPUSH
11865: LD_INT 21
11867: PUSH
11868: LD_INT 1
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: PPUSH
11875: CALL_OW 72
11879: NOT
11880: IFFALSE 11745
// ruOutpost := [ ] ;
11882: LD_ADDR_EXP 14
11886: PUSH
11887: EMPTY
11888: ST_TO_ADDR
// end ;
11889: LD_VAR 0 1
11893: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11894: LD_EXP 27
11898: IFFALSE 12087
11900: GO 11902
11902: DISABLE
11903: LD_INT 0
11905: PPUSH
11906: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11907: LD_INT 875
11909: PPUSH
11910: LD_INT 1225
11912: PPUSH
11913: CALL_OW 12
11917: PPUSH
11918: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11922: LD_ADDR_VAR 0 2
11926: PUSH
11927: LD_INT 208
11929: PUSH
11930: LD_INT 166
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: PUSH
11937: LD_INT 218
11939: PUSH
11940: LD_INT 174
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 201
11949: PUSH
11950: LD_INT 173
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 189
11959: PUSH
11960: LD_INT 167
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 191
11969: PUSH
11970: LD_INT 160
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 209
11979: PUSH
11980: LD_INT 181
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 192
11989: PUSH
11990: LD_INT 162
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: LD_INT 197
11999: PUSH
12000: LD_INT 166
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
12017: LD_ADDR_VAR 0 1
12021: PUSH
12022: DOUBLE
12023: LD_INT 1
12025: DEC
12026: ST_TO_ADDR
12027: LD_INT 5
12029: PUSH
12030: LD_OWVAR 67
12034: PLUS
12035: PUSH
12036: FOR_TO
12037: IFFALSE 12085
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12039: LD_VAR 0 2
12043: PUSH
12044: LD_VAR 0 1
12048: ARRAY
12049: PUSH
12050: LD_INT 1
12052: ARRAY
12053: PPUSH
12054: LD_VAR 0 2
12058: PUSH
12059: LD_VAR 0 1
12063: ARRAY
12064: PUSH
12065: LD_INT 2
12067: ARRAY
12068: PPUSH
12069: LD_INT 1
12071: PPUSH
12072: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12076: LD_INT 28
12078: PPUSH
12079: CALL_OW 67
// end ;
12083: GO 12036
12085: POP
12086: POP
// end ;
12087: PPOPN 2
12089: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12090: LD_EXP 27
12094: NOT
12095: IFFALSE 12749
12097: GO 12099
12099: DISABLE
12100: LD_INT 0
12102: PPUSH
12103: PPUSH
12104: PPUSH
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// begin enable ;
12109: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12110: LD_ADDR_VAR 0 1
12114: PUSH
12115: LD_EXP 14
12119: PPUSH
12120: LD_INT 22
12122: PUSH
12123: LD_INT 3
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 25
12132: PUSH
12133: LD_INT 1
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PPUSH
12144: CALL_OW 72
12148: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12149: LD_ADDR_VAR 0 2
12153: PUSH
12154: LD_EXP 14
12158: PPUSH
12159: LD_INT 22
12161: PUSH
12162: LD_INT 3
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 25
12171: PUSH
12172: LD_INT 2
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 72
12187: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12188: LD_ADDR_VAR 0 3
12192: PUSH
12193: LD_EXP 14
12197: PPUSH
12198: LD_INT 22
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 21
12210: PUSH
12211: LD_INT 3
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 3
12220: PUSH
12221: LD_INT 24
12223: PUSH
12224: LD_INT 1000
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: LIST
12239: PPUSH
12240: CALL_OW 72
12244: ST_TO_ADDR
// if engs and buildings then
12245: LD_VAR 0 2
12249: PUSH
12250: LD_VAR 0 3
12254: AND
12255: IFFALSE 12328
// begin for i in engs do
12257: LD_ADDR_VAR 0 5
12261: PUSH
12262: LD_VAR 0 2
12266: PUSH
12267: FOR_IN
12268: IFFALSE 12324
// if IsInUnit ( i ) then
12270: LD_VAR 0 5
12274: PPUSH
12275: CALL_OW 310
12279: IFFALSE 12292
// ComExitBuilding ( i ) else
12281: LD_VAR 0 5
12285: PPUSH
12286: CALL_OW 122
12290: GO 12322
// if not HasTask ( i ) then
12292: LD_VAR 0 5
12296: PPUSH
12297: CALL_OW 314
12301: NOT
12302: IFFALSE 12322
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12304: LD_VAR 0 5
12308: PPUSH
12309: LD_VAR 0 3
12313: PUSH
12314: LD_INT 1
12316: ARRAY
12317: PPUSH
12318: CALL_OW 130
12322: GO 12267
12324: POP
12325: POP
// end else
12326: GO 12431
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12328: LD_VAR 0 3
12332: NOT
12333: PUSH
12334: LD_EXP 14
12338: PPUSH
12339: LD_INT 30
12341: PUSH
12342: LD_INT 0
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL_OW 72
12353: AND
12354: PUSH
12355: LD_VAR 0 2
12359: PPUSH
12360: LD_INT 3
12362: PUSH
12363: LD_INT 54
12365: PUSH
12366: EMPTY
12367: LIST
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 72
12377: AND
12378: IFFALSE 12431
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12380: LD_VAR 0 2
12384: PPUSH
12385: LD_INT 3
12387: PUSH
12388: LD_INT 54
12390: PUSH
12391: EMPTY
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 72
12402: PPUSH
12403: LD_EXP 14
12407: PPUSH
12408: LD_INT 30
12410: PUSH
12411: LD_INT 0
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PPUSH
12418: CALL_OW 72
12422: PUSH
12423: LD_INT 1
12425: ARRAY
12426: PPUSH
12427: CALL_OW 120
// if not tmp then
12431: LD_VAR 0 1
12435: NOT
12436: IFFALSE 12440
// exit ;
12438: GO 12749
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12440: LD_INT 26
12442: PPUSH
12443: LD_INT 81
12445: PUSH
12446: LD_INT 3
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PPUSH
12453: CALL_OW 70
12457: PUSH
12458: LD_INT 1
12460: GREATER
12461: IFFALSE 12517
// begin for i in tmp do
12463: LD_ADDR_VAR 0 5
12467: PUSH
12468: LD_VAR 0 1
12472: PUSH
12473: FOR_IN
12474: IFFALSE 12513
// begin if IsInUnit ( i ) then
12476: LD_VAR 0 5
12480: PPUSH
12481: CALL_OW 310
12485: IFFALSE 12496
// ComExitBuilding ( i ) ;
12487: LD_VAR 0 5
12491: PPUSH
12492: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12496: LD_VAR 0 5
12500: PPUSH
12501: LD_INT 204
12503: PPUSH
12504: LD_INT 164
12506: PPUSH
12507: CALL_OW 174
// end ;
12511: GO 12473
12513: POP
12514: POP
// end else
12515: GO 12749
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 3
12524: PUSH
12525: LD_INT 54
12527: PUSH
12528: EMPTY
12529: LIST
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL_OW 72
12539: IFFALSE 12749
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12541: LD_ADDR_VAR 0 4
12545: PUSH
12546: LD_EXP 14
12550: PPUSH
12551: LD_INT 30
12553: PUSH
12554: LD_INT 32
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 58
12563: PUSH
12564: EMPTY
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PPUSH
12571: CALL_OW 72
12575: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12576: LD_VAR 0 4
12580: NOT
12581: PUSH
12582: LD_EXP 14
12586: PPUSH
12587: LD_INT 30
12589: PUSH
12590: LD_INT 5
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: PPUSH
12597: CALL_OW 72
12601: AND
12602: IFFALSE 12639
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: LD_EXP 14
12613: PPUSH
12614: LD_INT 30
12616: PUSH
12617: LD_INT 5
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PPUSH
12624: CALL_OW 72
12628: PUSH
12629: LD_INT 1
12631: ARRAY
12632: PPUSH
12633: CALL_OW 120
// exit ;
12637: GO 12749
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12639: LD_ADDR_VAR 0 6
12643: PUSH
12644: LD_VAR 0 1
12648: PPUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 54
12654: PUSH
12655: EMPTY
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 72
12666: ST_TO_ADDR
// if j < empty then
12667: LD_VAR 0 6
12671: PUSH
12672: LD_VAR 0 4
12676: LESS
12677: IFFALSE 12691
// k := j else
12679: LD_ADDR_VAR 0 7
12683: PUSH
12684: LD_VAR 0 6
12688: ST_TO_ADDR
12689: GO 12701
// k := empty ;
12691: LD_ADDR_VAR 0 7
12695: PUSH
12696: LD_VAR 0 4
12700: ST_TO_ADDR
// for i = 1 to k do
12701: LD_ADDR_VAR 0 5
12705: PUSH
12706: DOUBLE
12707: LD_INT 1
12709: DEC
12710: ST_TO_ADDR
12711: LD_VAR 0 7
12715: PUSH
12716: FOR_TO
12717: IFFALSE 12747
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12719: LD_VAR 0 6
12723: PUSH
12724: LD_VAR 0 5
12728: ARRAY
12729: PPUSH
12730: LD_VAR 0 4
12734: PUSH
12735: LD_VAR 0 5
12739: ARRAY
12740: PPUSH
12741: CALL_OW 120
12745: GO 12716
12747: POP
12748: POP
// end ; end ;
12749: PPOPN 7
12751: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12752: LD_EXP 2
12756: PUSH
12757: LD_INT 1
12759: EQUAL
12760: PUSH
12761: LD_EXP 27
12765: AND
12766: PUSH
12767: LD_INT 22
12769: PUSH
12770: LD_INT 1
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 92
12779: PUSH
12780: LD_INT 208
12782: PUSH
12783: LD_INT 163
12785: PUSH
12786: LD_INT 8
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: AND
12804: PUSH
12805: LD_INT 22
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: LD_INT 21
12817: PUSH
12818: LD_INT 1
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 92
12827: PUSH
12828: LD_INT 208
12830: PUSH
12831: LD_INT 163
12833: PUSH
12834: LD_INT 14
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL_OW 69
12852: NOT
12853: AND
12854: IFFALSE 13159
12856: GO 12858
12858: DISABLE
12859: LD_INT 0
12861: PPUSH
// begin InGameOn ;
12862: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12866: LD_EXP 9
12870: PPUSH
12871: CALL_OW 87
// wait ( 0 0$1 ) ;
12875: LD_INT 35
12877: PPUSH
12878: CALL_OW 67
// DialogueOn ;
12882: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12886: LD_EXP 9
12890: PPUSH
12891: LD_STRING D
12893: PUSH
12894: LD_STRING I
12896: PUSH
12897: LD_STRING J
12899: PUSH
12900: LD_STRING S
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: LIST
12907: PUSH
12908: LD_EXP 25
12912: ARRAY
12913: STR
12914: PUSH
12915: LD_STRING -1-BaseCaptured
12917: STR
12918: PPUSH
12919: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12923: LD_EXP 12
12927: PPUSH
12928: LD_STRING DP-1-BaseCaptured
12930: PPUSH
12931: CALL_OW 94
// if sibBombAllowed then
12935: LD_EXP 23
12939: IFFALSE 13081
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12941: LD_EXP 9
12945: PPUSH
12946: LD_STRING D
12948: PUSH
12949: LD_STRING I
12951: PUSH
12952: LD_STRING J
12954: PUSH
12955: LD_STRING S
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: PUSH
12963: LD_EXP 25
12967: ARRAY
12968: STR
12969: PUSH
12970: LD_STRING -2-BaseCaptured
12972: STR
12973: PPUSH
12974: CALL_OW 88
// if commander = 1 then
12978: LD_EXP 25
12982: PUSH
12983: LD_INT 1
12985: EQUAL
12986: IFFALSE 13000
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12988: LD_EXP 12
12992: PPUSH
12993: LD_STRING DP-2b-BaseCaptured
12995: PPUSH
12996: CALL_OW 94
// if commander = 2 then
13000: LD_EXP 25
13004: PUSH
13005: LD_INT 2
13007: EQUAL
13008: IFFALSE 13022
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
13010: LD_EXP 12
13014: PPUSH
13015: LD_STRING DP-2-BaseCaptured
13017: PPUSH
13018: CALL_OW 94
// if commander = 3 then
13022: LD_EXP 25
13026: PUSH
13027: LD_INT 3
13029: EQUAL
13030: IFFALSE 13044
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13032: LD_EXP 12
13036: PPUSH
13037: LD_STRING DP-2a-BaseCaptured
13039: PPUSH
13040: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13044: LD_EXP 9
13048: PPUSH
13049: LD_STRING D
13051: PUSH
13052: LD_STRING I
13054: PUSH
13055: LD_STRING J
13057: PUSH
13058: LD_STRING S
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: LIST
13065: PUSH
13066: LD_EXP 25
13070: ARRAY
13071: STR
13072: PUSH
13073: LD_STRING -3-BaseCaptured
13075: STR
13076: PPUSH
13077: CALL_OW 88
// end ; DialogueOff ;
13081: CALL_OW 7
// InGameOff ;
13085: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13089: LD_STRING O2
13091: PPUSH
13092: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13096: LD_ADDR_VAR 0 1
13100: PUSH
13101: LD_EXP 14
13105: PPUSH
13106: LD_INT 21
13108: PUSH
13109: LD_INT 3
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PPUSH
13116: CALL_OW 72
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13138
// SetSide ( i , 1 ) ;
13124: LD_VAR 0 1
13128: PPUSH
13129: LD_INT 1
13131: PPUSH
13132: CALL_OW 235
13136: GO 13121
13138: POP
13139: POP
// baseCaptured := true ;
13140: LD_ADDR_EXP 17
13144: PUSH
13145: LD_INT 1
13147: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13148: LD_INT 1225
13150: PPUSH
13151: CALL_OW 67
// PrepareReinforcements ;
13155: CALL 9908 0 0
// end ;
13159: PPOPN 1
13161: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13162: LD_INT 22
13164: PUSH
13165: LD_INT 3
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 92
13174: PUSH
13175: LD_INT 167
13177: PUSH
13178: LD_INT 197
13180: PUSH
13181: LD_INT 20
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 69
13198: PUSH
13199: LD_INT 3
13201: GREATER
13202: IFFALSE 13219
13204: GO 13206
13206: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13207: LD_EXP 12
13211: PPUSH
13212: LD_STRING DP-RuAttack
13214: PPUSH
13215: CALL_OW 94
13219: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13220: LD_EXP 1
13224: NOT
13225: PUSH
13226: LD_INT 1
13228: PPUSH
13229: LD_INT 168
13231: PPUSH
13232: LD_INT 74
13234: PPUSH
13235: CALL_OW 293
13239: AND
13240: PUSH
13241: LD_INT 168
13243: PPUSH
13244: LD_INT 72
13246: PPUSH
13247: CALL_OW 553
13251: AND
13252: IFFALSE 13304
13254: GO 13256
13256: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13257: LD_INT 168
13259: PPUSH
13260: LD_INT 72
13262: PPUSH
13263: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13267: LD_EXP 9
13271: PPUSH
13272: LD_STRING D
13274: PUSH
13275: LD_STRING I
13277: PUSH
13278: LD_STRING J
13280: PUSH
13281: LD_STRING S
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_EXP 25
13293: ARRAY
13294: STR
13295: PUSH
13296: LD_STRING -1-Blockade
13298: STR
13299: PPUSH
13300: CALL_OW 88
// end ;
13304: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13305: LD_EXP 2
13309: PUSH
13310: LD_INT 1
13312: EQUAL
13313: PUSH
13314: LD_INT 22
13316: PUSH
13317: LD_INT 1
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: LD_INT 101
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: AND
13343: IFFALSE 13875
13345: GO 13347
13347: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13348: LD_INT 4
13350: PPUSH
13351: LD_INT 1
13353: PPUSH
13354: CALL_OW 343
// DialogueOn ;
13358: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13362: LD_EXP 11
13366: PPUSH
13367: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13371: LD_EXP 11
13375: PPUSH
13376: LD_STRING DM-1-Contact
13378: PPUSH
13379: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13383: LD_EXP 9
13387: PPUSH
13388: LD_STRING D
13390: PUSH
13391: LD_STRING I
13393: PUSH
13394: LD_STRING J
13396: PUSH
13397: LD_STRING S
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: LIST
13404: PUSH
13405: LD_EXP 25
13409: ARRAY
13410: STR
13411: PUSH
13412: LD_STRING -1-Contact
13414: STR
13415: PPUSH
13416: CALL_OW 88
// if commander = 1 then
13420: LD_EXP 25
13424: PUSH
13425: LD_INT 1
13427: EQUAL
13428: IFFALSE 13560
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13430: LD_EXP 11
13434: PPUSH
13435: LD_STRING DM-2-Contact
13437: PPUSH
13438: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13442: LD_EXP 9
13446: PPUSH
13447: LD_STRING DI-2-Contact
13449: PPUSH
13450: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13454: LD_INT 22
13456: PUSH
13457: LD_INT 8
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 21
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PPUSH
13478: CALL_OW 69
13482: PUSH
13483: LD_INT 8
13485: PPUSH
13486: LD_INT 1
13488: PPUSH
13489: CALL_OW 81
13493: PUSH
13494: LD_INT 2
13496: EQUAL
13497: AND
13498: IFFALSE 13524
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13500: LD_EXP 11
13504: PPUSH
13505: LD_STRING DM-3-Contact
13507: PPUSH
13508: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13512: LD_EXP 9
13516: PPUSH
13517: LD_STRING DI-3-Contact
13519: PPUSH
13520: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13524: LD_EXP 11
13528: PPUSH
13529: LD_STRING DM-4-Contact
13531: PPUSH
13532: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13536: LD_EXP 9
13540: PPUSH
13541: LD_STRING DI-4-Contact
13543: PPUSH
13544: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13548: LD_EXP 11
13552: PPUSH
13553: LD_STRING DM-5-Contact
13555: PPUSH
13556: CALL_OW 94
// end ; if commander = 2 then
13560: LD_EXP 25
13564: PUSH
13565: LD_INT 2
13567: EQUAL
13568: IFFALSE 13700
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13570: LD_EXP 11
13574: PPUSH
13575: LD_STRING DM-2c-Contact
13577: PPUSH
13578: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13582: LD_EXP 9
13586: PPUSH
13587: LD_STRING DJ-2-Contact
13589: PPUSH
13590: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13594: LD_INT 22
13596: PUSH
13597: LD_INT 8
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: LD_INT 21
13606: PUSH
13607: LD_INT 1
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PPUSH
13618: CALL_OW 69
13622: PUSH
13623: LD_INT 8
13625: PPUSH
13626: LD_INT 1
13628: PPUSH
13629: CALL_OW 81
13633: PUSH
13634: LD_INT 2
13636: EQUAL
13637: AND
13638: IFFALSE 13664
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13640: LD_EXP 11
13644: PPUSH
13645: LD_STRING DM-3-Contact
13647: PPUSH
13648: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13652: LD_EXP 9
13656: PPUSH
13657: LD_STRING DJ-3-Contact
13659: PPUSH
13660: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13664: LD_EXP 11
13668: PPUSH
13669: LD_STRING DM-4-Contact
13671: PPUSH
13672: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13676: LD_EXP 9
13680: PPUSH
13681: LD_STRING DJ-4-Contact
13683: PPUSH
13684: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13688: LD_EXP 11
13692: PPUSH
13693: LD_STRING DM-5a-Contact
13695: PPUSH
13696: CALL_OW 94
// end ; if commander = 3 then
13700: LD_EXP 25
13704: PUSH
13705: LD_INT 3
13707: EQUAL
13708: IFFALSE 13864
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13710: LD_EXP 11
13714: PPUSH
13715: LD_STRING DM-2a-Contact
13717: PPUSH
13718: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13722: LD_EXP 9
13726: PPUSH
13727: LD_STRING DS-2a-Contact
13729: PPUSH
13730: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13734: LD_EXP 11
13738: PPUSH
13739: LD_STRING DM-2b-Contact
13741: PPUSH
13742: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13746: LD_EXP 9
13750: PPUSH
13751: LD_STRING DS-2b-Contact
13753: PPUSH
13754: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13758: LD_INT 22
13760: PUSH
13761: LD_INT 8
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PUSH
13768: LD_INT 21
13770: PUSH
13771: LD_INT 1
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_INT 8
13789: PPUSH
13790: LD_INT 1
13792: PPUSH
13793: CALL_OW 81
13797: PUSH
13798: LD_INT 2
13800: EQUAL
13801: AND
13802: IFFALSE 13828
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13804: LD_EXP 11
13808: PPUSH
13809: LD_STRING DM-3-Contact
13811: PPUSH
13812: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13816: LD_EXP 9
13820: PPUSH
13821: LD_STRING DS-3-Contact
13823: PPUSH
13824: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13828: LD_EXP 11
13832: PPUSH
13833: LD_STRING DM-4-Contact
13835: PPUSH
13836: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13840: LD_EXP 9
13844: PPUSH
13845: LD_STRING DS-4-Contact
13847: PPUSH
13848: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13852: LD_EXP 11
13856: PPUSH
13857: LD_STRING DM-5-Contact
13859: PPUSH
13860: CALL_OW 94
// end ; DialogueOff ;
13864: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13868: LD_STRING O3
13870: PPUSH
13871: CALL_OW 337
// end ;
13875: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13876: LD_EXP 2
13880: PUSH
13881: LD_INT 1
13883: EQUAL
13884: PUSH
13885: LD_EXP 18
13889: PUSH
13890: LD_INT 15
13892: PUSH
13893: LD_INT 20
13895: PUSH
13896: LD_INT 25
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: LIST
13903: PUSH
13904: LD_OWVAR 67
13908: ARRAY
13909: GREATEREQUAL
13910: AND
13911: PUSH
13912: LD_INT 22
13914: PUSH
13915: LD_INT 8
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: LD_INT 30
13924: PUSH
13925: LD_INT 1
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PPUSH
13936: CALL_OW 69
13940: AND
13941: PUSH
13942: LD_INT 22
13944: PUSH
13945: LD_INT 8
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 21
13954: PUSH
13955: LD_INT 3
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PPUSH
13966: CALL_OW 69
13970: PUSH
13971: LD_INT 5
13973: GREATEREQUAL
13974: AND
13975: IFFALSE 14498
13977: GO 13979
13979: DISABLE
13980: LD_INT 0
13982: PPUSH
13983: PPUSH
13984: PPUSH
13985: PPUSH
// begin DialogueOn ;
13986: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13990: LD_EXP 13
13994: PPUSH
13995: LD_STRING DF-1-Leg
13997: PPUSH
13998: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14002: LD_EXP 9
14006: PPUSH
14007: LD_STRING D
14009: PUSH
14010: LD_STRING I
14012: PUSH
14013: LD_STRING J
14015: PUSH
14016: LD_STRING S
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: LIST
14023: PUSH
14024: LD_EXP 25
14028: ARRAY
14029: STR
14030: PUSH
14031: LD_STRING -1-Leg
14033: STR
14034: PPUSH
14035: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14039: LD_EXP 13
14043: PPUSH
14044: LD_STRING DF-2-Leg
14046: PPUSH
14047: CALL_OW 94
// DialogueOff ;
14051: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14055: LD_STRING QLegionOffer
14057: PPUSH
14058: CALL_OW 97
14062: PUSH
14063: LD_INT 1
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14074
14071: POP
// ; 2 :
14072: GO 14088
14074: LD_INT 2
14076: DOUBLE
14077: EQUAL
14078: IFTRUE 14082
14080: GO 14087
14082: POP
// exit ; end ;
14083: GO 14498
14085: GO 14088
14087: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14088: LD_EXP 9
14092: PPUSH
14093: LD_STRING D
14095: PUSH
14096: LD_STRING I
14098: PUSH
14099: LD_STRING J
14101: PUSH
14102: LD_STRING S
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PUSH
14110: LD_EXP 25
14114: ARRAY
14115: STR
14116: PUSH
14117: LD_STRING -2-Leg
14119: STR
14120: PPUSH
14121: CALL_OW 88
// legOfferAccepted := true ;
14125: LD_ADDR_EXP 20
14129: PUSH
14130: LD_INT 1
14132: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14133: LD_INT 21
14135: PPUSH
14136: LD_INT 1
14138: PPUSH
14139: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14143: LD_INT 190
14145: PPUSH
14146: LD_INT 227
14148: PPUSH
14149: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14153: LD_ADDR_VAR 0 1
14157: PUSH
14158: LD_INT 16800
14160: PUSH
14161: LD_INT 14700
14163: PUSH
14164: LD_INT 12600
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: LIST
14171: PUSH
14172: LD_OWVAR 67
14176: ARRAY
14177: ST_TO_ADDR
// sib := 100 ;
14178: LD_ADDR_VAR 0 2
14182: PUSH
14183: LD_INT 100
14185: ST_TO_ADDR
// disableGlobalTimer := true ;
14186: LD_ADDR_EXP 4
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14194: LD_INT 35
14196: PPUSH
14197: CALL_OW 67
// time := time - 0 0$1 ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_VAR 0 1
14210: PUSH
14211: LD_INT 35
14213: MINUS
14214: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14215: LD_ADDR_VAR 0 3
14219: PUSH
14220: LD_INT 21
14222: PPUSH
14223: LD_INT 3
14225: PPUSH
14226: CALL_OW 287
14230: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14231: LD_ADDR_OWVAR 47
14235: PUSH
14236: LD_STRING #SkrTime
14238: PUSH
14239: LD_OWVAR 1
14243: PUSH
14244: LD_STRING #Skr-LegOffer
14246: PUSH
14247: LD_VAR 0 2
14251: PUSH
14252: LD_VAR 0 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: ST_TO_ADDR
// if sources then
14264: LD_VAR 0 3
14268: IFFALSE 14300
// begin sib := sib - sources * 10 ;
14270: LD_ADDR_VAR 0 2
14274: PUSH
14275: LD_VAR 0 2
14279: PUSH
14280: LD_VAR 0 3
14284: PUSH
14285: LD_INT 10
14287: MUL
14288: MINUS
14289: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14290: LD_INT 21
14292: PPUSH
14293: LD_INT 3
14295: PPUSH
14296: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14300: LD_VAR 0 1
14304: PUSH
14305: LD_INT 0
14307: EQUAL
14308: PUSH
14309: LD_VAR 0 2
14313: PUSH
14314: LD_INT 0
14316: LESSEQUAL
14317: OR
14318: PUSH
14319: LD_INT 22
14321: PUSH
14322: LD_INT 8
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PPUSH
14329: CALL_OW 69
14333: NOT
14334: OR
14335: IFFALSE 14194
// SetAreaMapShow ( legOfferArea , 0 ) ;
14337: LD_INT 21
14339: PPUSH
14340: LD_INT 0
14342: PPUSH
14343: CALL_OW 424
// disableGlobalTimer := false ;
14347: LD_ADDR_EXP 4
14351: PUSH
14352: LD_INT 0
14354: ST_TO_ADDR
// if sib <= 0 then
14355: LD_VAR 0 2
14359: PUSH
14360: LD_INT 0
14362: LESSEQUAL
14363: IFFALSE 14479
// begin legChangeSide := true ;
14365: LD_ADDR_EXP 21
14369: PUSH
14370: LD_INT 1
14372: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14373: LD_EXP 13
14377: PPUSH
14378: LD_STRING DF-4y-Leg
14380: PPUSH
14381: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14385: LD_STRING O3a
14387: PPUSH
14388: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14392: LD_INT 8
14394: PPUSH
14395: LD_INT 1
14397: PPUSH
14398: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14402: LD_INT 8
14404: PPUSH
14405: LD_INT 1
14407: PPUSH
14408: LD_INT 1
14410: PPUSH
14411: LD_INT 1
14413: PPUSH
14414: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14418: LD_INT 8
14420: PPUSH
14421: LD_INT 4
14423: PPUSH
14424: LD_INT 1
14426: PPUSH
14427: LD_INT 1
14429: PPUSH
14430: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14434: LD_INT 8
14436: PPUSH
14437: LD_INT 6
14439: PPUSH
14440: LD_INT 2
14442: PPUSH
14443: LD_INT 1
14445: PPUSH
14446: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14450: LD_INT 8
14452: PPUSH
14453: LD_INT 3
14455: PPUSH
14456: LD_INT 2
14458: PPUSH
14459: LD_INT 1
14461: PPUSH
14462: CALL_OW 80
// wait ( 0 0$30 ) ;
14466: LD_INT 1050
14468: PPUSH
14469: CALL_OW 67
// PrepareLegionReinforcements ;
14473: CALL 10608 0 0
// end else
14477: GO 14498
// begin ChangeMissionObjectives ( O3a ) ;
14479: LD_STRING O3a
14481: PPUSH
14482: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14486: LD_EXP 13
14490: PPUSH
14491: LD_STRING DF-4n-Leg
14493: PPUSH
14494: CALL_OW 94
// end ; end ;
14498: PPOPN 4
14500: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14501: LD_INT 22
14503: PUSH
14504: LD_INT 8
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PPUSH
14525: CALL_OW 69
14529: PUSH
14530: LD_INT 0
14532: EQUAL
14533: PUSH
14534: LD_INT 8
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: CALL_OW 81
14544: PUSH
14545: LD_INT 2
14547: EQUAL
14548: AND
14549: IFFALSE 14561
14551: GO 14553
14553: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14554: LD_STRING O3a
14556: PPUSH
14557: CALL_OW 337
14561: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14562: LD_EXP 2
14566: PUSH
14567: LD_INT 1
14569: EQUAL
14570: PUSH
14571: LD_EXP 3
14575: AND
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 1
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_INT 0
14608: EQUAL
14609: AND
14610: PUSH
14611: LD_INT 22
14613: PUSH
14614: LD_INT 3
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 30
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: PUSH
14640: LD_INT 0
14642: EQUAL
14643: AND
14644: IFFALSE 14882
14646: GO 14648
14648: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14649: LD_EXP 9
14653: PPUSH
14654: LD_STRING D
14656: PUSH
14657: LD_STRING I
14659: PUSH
14660: LD_STRING J
14662: PUSH
14663: LD_STRING S
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: PUSH
14671: LD_EXP 25
14675: ARRAY
14676: STR
14677: PUSH
14678: LD_STRING -1-Win
14680: STR
14681: PPUSH
14682: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14686: LD_OWVAR 1
14690: PUSH
14691: LD_INT 315000
14693: PUSH
14694: LD_INT 273000
14696: PUSH
14697: LD_INT 231000
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: LIST
14704: PUSH
14705: LD_OWVAR 67
14709: ARRAY
14710: GREATEREQUAL
14711: IFFALSE 14726
// AddMedal ( med1 , - 1 ) else
14713: LD_STRING med1
14715: PPUSH
14716: LD_INT 1
14718: NEG
14719: PPUSH
14720: CALL_OW 101
14724: GO 14736
// AddMedal ( med1 , 1 ) ;
14726: LD_STRING med1
14728: PPUSH
14729: LD_INT 1
14731: PPUSH
14732: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14736: LD_EXP 22
14740: PUSH
14741: LD_INT 20
14743: PUSH
14744: LD_INT 15
14746: PUSH
14747: LD_INT 10
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: LIST
14754: PUSH
14755: LD_OWVAR 67
14759: ARRAY
14760: GREATEREQUAL
14761: IFFALSE 14776
// AddMedal ( med2 , - 1 ) else
14763: LD_STRING med2
14765: PPUSH
14766: LD_INT 1
14768: NEG
14769: PPUSH
14770: CALL_OW 101
14774: GO 14786
// AddMedal ( med2 , 1 ) ;
14776: LD_STRING med2
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14786: LD_INT 8
14788: PPUSH
14789: LD_INT 1
14791: PPUSH
14792: CALL_OW 81
14796: PUSH
14797: LD_INT 1
14799: EQUAL
14800: IFFALSE 14814
// AddMedal ( med3 , 1 ) else
14802: LD_STRING med3
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL_OW 101
14812: GO 14871
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14814: LD_INT 22
14816: PUSH
14817: LD_INT 8
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: PUSH
14824: LD_INT 21
14826: PUSH
14827: LD_INT 1
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: PPUSH
14838: CALL_OW 69
14842: PUSH
14843: LD_INT 0
14845: EQUAL
14846: IFFALSE 14860
// AddMedal ( med3 , 2 ) else
14848: LD_STRING med3
14850: PPUSH
14851: LD_INT 2
14853: PPUSH
14854: CALL_OW 101
14858: GO 14871
// AddMedal ( med3 , - 1 ) ;
14860: LD_STRING med3
14862: PPUSH
14863: LD_INT 1
14865: NEG
14866: PPUSH
14867: CALL_OW 101
// GiveMedals ( MAIN ) ;
14871: LD_STRING MAIN
14873: PPUSH
14874: CALL_OW 102
// YouWin ;
14878: CALL_OW 103
// end ;
14882: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14883: LD_EXP 2
14887: PUSH
14888: LD_INT 1
14890: EQUAL
14891: PUSH
14892: LD_EXP 16
14896: AND
14897: PUSH
14898: LD_INT 20
14900: PPUSH
14901: LD_INT 81
14903: PUSH
14904: LD_INT 8
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PPUSH
14911: CALL_OW 70
14915: AND
14916: IFFALSE 15195
14918: GO 14920
14920: DISABLE
14921: LD_INT 0
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
14927: PPUSH
// begin enable ;
14928: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14929: LD_ADDR_VAR 0 3
14933: PUSH
14934: LD_INT 20
14936: PPUSH
14937: LD_INT 81
14939: PUSH
14940: LD_INT 8
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL_OW 70
14951: ST_TO_ADDR
// if not tmp then
14952: LD_VAR 0 3
14956: NOT
14957: IFFALSE 14961
// exit ;
14959: GO 15195
// for i in tmp do
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_VAR 0 3
14970: PUSH
14971: FOR_IN
14972: IFFALSE 15193
// begin x := GetX ( i ) ;
14974: LD_ADDR_VAR 0 4
14978: PUSH
14979: LD_VAR 0 1
14983: PPUSH
14984: CALL_OW 250
14988: ST_TO_ADDR
// y := GetY ( i ) ;
14989: LD_ADDR_VAR 0 5
14993: PUSH
14994: LD_VAR 0 1
14998: PPUSH
14999: CALL_OW 251
15003: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15004: LD_VAR 0 4
15008: PPUSH
15009: LD_VAR 0 5
15013: PPUSH
15014: CALL_OW 458
15018: IFFALSE 15191
// begin LaunchMineAtPos ( x , y , 8 ) ;
15020: LD_VAR 0 4
15024: PPUSH
15025: LD_VAR 0 5
15029: PPUSH
15030: LD_INT 8
15032: PPUSH
15033: CALL_OW 456
// if not dialogueMineDetected then
15037: LD_EXP 28
15041: NOT
15042: IFFALSE 15103
// begin dialogueMineDetected := true ;
15044: LD_ADDR_EXP 28
15048: PUSH
15049: LD_INT 1
15051: ST_TO_ADDR
// CenterNowOnXY ( x , y ) ;
15052: LD_VAR 0 4
15056: PPUSH
15057: LD_VAR 0 5
15061: PPUSH
15062: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15066: LD_EXP 9
15070: PPUSH
15071: LD_STRING D
15073: PUSH
15074: LD_STRING I
15076: PUSH
15077: LD_STRING J
15079: PUSH
15080: LD_STRING S
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: LIST
15087: PUSH
15088: LD_EXP 25
15092: ARRAY
15093: STR
15094: PUSH
15095: LD_STRING -1-Mine
15097: STR
15098: PPUSH
15099: CALL_OW 88
// end ; for j = 1 to staticMines do
15103: LD_ADDR_VAR 0 2
15107: PUSH
15108: DOUBLE
15109: LD_INT 1
15111: DEC
15112: ST_TO_ADDR
15113: LD_EXP 16
15117: PUSH
15118: FOR_TO
15119: IFFALSE 15189
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15121: LD_EXP 16
15125: PUSH
15126: LD_VAR 0 2
15130: ARRAY
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 4
15140: EQUAL
15141: PUSH
15142: LD_EXP 16
15146: PUSH
15147: LD_VAR 0 2
15151: ARRAY
15152: PUSH
15153: LD_INT 2
15155: ARRAY
15156: PUSH
15157: LD_VAR 0 5
15161: EQUAL
15162: AND
15163: IFFALSE 15187
// begin staticMines := Delete ( staticMines , j ) ;
15165: LD_ADDR_EXP 16
15169: PUSH
15170: LD_EXP 16
15174: PPUSH
15175: LD_VAR 0 2
15179: PPUSH
15180: CALL_OW 3
15184: ST_TO_ADDR
// break ;
15185: GO 15189
// end ;
15187: GO 15118
15189: POP
15190: POP
// end ; end ;
15191: GO 14971
15193: POP
15194: POP
// end ;
15195: PPOPN 5
15197: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15198: LD_EXP 2
15202: PUSH
15203: LD_INT 1
15205: EQUAL
15206: PUSH
15207: LD_EXP 3
15211: AND
15212: PUSH
15213: LD_EXP 23
15217: AND
15218: PUSH
15219: LD_EXP 31
15223: PUSH
15224: LD_EXP 7
15228: ARRAY
15229: PPUSH
15230: LD_INT 30
15232: PUSH
15233: LD_INT 3
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 72
15244: AND
15245: IFFALSE 15449
15247: GO 15249
15249: DISABLE
15250: LD_INT 0
15252: PPUSH
15253: PPUSH
// begin enable ;
15254: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15255: LD_EXP 7
15259: PPUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 3
15265: PUSH
15266: LD_INT 3
15268: PUSH
15269: LD_INT 48
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: PUSH
15278: EMPTY
15279: LIST
15280: PPUSH
15281: CALL 86090 0 2
// repeat wait ( 0 0$1 ) ;
15285: LD_INT 35
15287: PPUSH
15288: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15292: LD_INT 22
15294: PUSH
15295: LD_INT 3
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: LD_INT 34
15304: PUSH
15305: LD_INT 48
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PPUSH
15316: CALL_OW 69
15320: IFFALSE 15285
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: LD_INT 22
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 34
15339: PUSH
15340: LD_INT 48
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: PPUSH
15351: CALL_OW 69
15355: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15356: LD_ADDR_VAR 0 2
15360: PUSH
15361: LD_INT 81
15363: PUSH
15364: LD_INT 3
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: LD_INT 21
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PPUSH
15385: CALL_OW 69
15389: ST_TO_ADDR
// if e then
15390: LD_VAR 0 2
15394: IFFALSE 15420
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15396: LD_ADDR_VAR 0 2
15400: PUSH
15401: LD_VAR 0 2
15405: PPUSH
15406: LD_VAR 0 1
15410: PUSH
15411: LD_INT 1
15413: ARRAY
15414: PPUSH
15415: CALL_OW 74
15419: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15420: LD_VAR 0 1
15424: PPUSH
15425: LD_VAR 0 2
15429: PPUSH
15430: CALL_OW 250
15434: PPUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: CALL_OW 251
15444: PPUSH
15445: CALL_OW 116
// end ;
15449: PPOPN 2
15451: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15452: LD_OWVAR 67
15456: PUSH
15457: LD_INT 1
15459: GREATER
15460: PUSH
15461: LD_EXP 31
15465: PUSH
15466: LD_EXP 7
15470: ARRAY
15471: PPUSH
15472: LD_INT 25
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 72
15486: AND
15487: PUSH
15488: LD_EXP 2
15492: PUSH
15493: LD_INT 1
15495: EQUAL
15496: AND
15497: PUSH
15498: LD_EXP 3
15502: AND
15503: PUSH
15504: LD_INT 23
15506: PPUSH
15507: LD_INT 3
15509: PPUSH
15510: CALL_OW 321
15514: PUSH
15515: LD_INT 2
15517: EQUAL
15518: AND
15519: IFFALSE 15646
15521: GO 15523
15523: DISABLE
15524: LD_INT 0
15526: PPUSH
15527: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15528: LD_ADDR_VAR 0 1
15532: PUSH
15533: LD_EXP 31
15537: PUSH
15538: LD_EXP 7
15542: ARRAY
15543: PPUSH
15544: LD_INT 25
15546: PUSH
15547: LD_INT 3
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 72
15558: ST_TO_ADDR
// if not tmp then
15559: LD_VAR 0 1
15563: NOT
15564: IFFALSE 15568
// exit ;
15566: GO 15646
// for i in tmp do
15568: LD_ADDR_VAR 0 2
15572: PUSH
15573: LD_VAR 0 1
15577: PUSH
15578: FOR_IN
15579: IFFALSE 15625
// begin SetTag ( i , 29 ) ;
15581: LD_VAR 0 2
15585: PPUSH
15586: LD_INT 29
15588: PPUSH
15589: CALL_OW 109
// ComExitBuilding ( i ) ;
15593: LD_VAR 0 2
15597: PPUSH
15598: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15602: LD_VAR 0 2
15606: PPUSH
15607: LD_INT 37
15609: PPUSH
15610: LD_INT 97
15612: PPUSH
15613: LD_INT 133
15615: PPUSH
15616: LD_INT 0
15618: PPUSH
15619: CALL_OW 230
// end ;
15623: GO 15578
15625: POP
15626: POP
// wait ( 1 1$00 ) ;
15627: LD_INT 2100
15629: PPUSH
15630: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15634: LD_EXP 7
15638: PPUSH
15639: LD_INT 29
15641: PPUSH
15642: CALL 65977 0 2
// end ;
15646: PPOPN 2
15648: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15649: LD_EXP 2
15653: PUSH
15654: LD_INT 1
15656: EQUAL
15657: PUSH
15658: LD_INT 84
15660: PPUSH
15661: LD_INT 128
15663: PPUSH
15664: CALL_OW 428
15668: PPUSH
15669: CALL_OW 266
15673: PUSH
15674: LD_INT 1
15676: EQUAL
15677: AND
15678: PUSH
15679: LD_INT 84
15681: PPUSH
15682: LD_INT 128
15684: PPUSH
15685: CALL_OW 428
15689: PPUSH
15690: CALL_OW 255
15694: PUSH
15695: LD_INT 3
15697: EQUAL
15698: AND
15699: IFFALSE 15872
15701: GO 15703
15703: DISABLE
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// begin enable ;
15708: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15709: LD_ADDR_VAR 0 2
15713: PUSH
15714: LD_INT 84
15716: PPUSH
15717: LD_INT 128
15719: PPUSH
15720: CALL_OW 428
15724: ST_TO_ADDR
// uc_side := 3 ;
15725: LD_ADDR_OWVAR 20
15729: PUSH
15730: LD_INT 3
15732: ST_TO_ADDR
// uc_nation := 3 ;
15733: LD_ADDR_OWVAR 21
15737: PUSH
15738: LD_INT 3
15740: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15741: LD_INT 21
15743: PPUSH
15744: LD_INT 3
15746: PPUSH
15747: LD_INT 3
15749: PPUSH
15750: LD_INT 51
15752: PPUSH
15753: LD_INT 0
15755: PPUSH
15756: CALL 24724 0 5
// veh := CreateVehicle ;
15760: LD_ADDR_VAR 0 1
15764: PUSH
15765: CALL_OW 45
15769: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_INT 126
15777: PPUSH
15778: LD_INT 227
15780: PPUSH
15781: LD_INT 0
15783: PPUSH
15784: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15788: LD_VAR 0 1
15792: PPUSH
15793: LD_INT 2
15795: PPUSH
15796: LD_INT 100
15798: PPUSH
15799: CALL_OW 290
// ComGive ( veh , depot ) ;
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_VAR 0 2
15812: PPUSH
15813: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15817: LD_VAR 0 1
15821: PPUSH
15822: LD_INT 126
15824: PPUSH
15825: LD_INT 227
15827: PPUSH
15828: CALL_OW 171
// wait ( 0 0$10 ) ;
15832: LD_INT 350
15834: PPUSH
15835: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15839: LD_INT 35
15841: PPUSH
15842: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15846: LD_VAR 0 1
15850: PPUSH
15851: LD_INT 126
15853: PPUSH
15854: LD_INT 227
15856: PPUSH
15857: CALL_OW 307
15861: IFFALSE 15839
// RemoveUnit ( veh ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 64
// end ;
15872: PPOPN 2
15874: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15875: LD_EXP 2
15879: PUSH
15880: LD_INT 1
15882: EQUAL
15883: PUSH
15884: LD_EXP 27
15888: AND
15889: PUSH
15890: LD_EXP 25
15894: PUSH
15895: LD_INT 2
15897: EQUAL
15898: AND
15899: IFFALSE 16091
15901: GO 15903
15903: DISABLE
15904: LD_INT 0
15906: PPUSH
15907: PPUSH
// begin enable ;
15908: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15909: LD_OWVAR 1
15913: PUSH
15914: LD_INT 105000
15916: PUSH
15917: LD_INT 84000
15919: PUSH
15920: LD_INT 63000
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: LIST
15927: PUSH
15928: LD_OWVAR 67
15932: ARRAY
15933: GREATEREQUAL
15934: IFFALSE 15937
// disable ;
15936: DISABLE
// uc_side := 4 ;
15937: LD_ADDR_OWVAR 20
15941: PUSH
15942: LD_INT 4
15944: ST_TO_ADDR
// uc_nation := 1 ;
15945: LD_ADDR_OWVAR 21
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15953: LD_INT 2
15955: PPUSH
15956: LD_INT 3
15958: PPUSH
15959: LD_INT 3
15961: PPUSH
15962: LD_INT 12
15964: PPUSH
15965: LD_INT 0
15967: PPUSH
15968: CALL 24724 0 5
// veh := CreateVehicle ;
15972: LD_ADDR_VAR 0 1
15976: PUSH
15977: CALL_OW 45
15981: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 229
15989: PPUSH
15990: LD_INT 226
15992: PPUSH
15993: LD_INT 0
15995: PPUSH
15996: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16000: LD_VAR 0 1
16004: PPUSH
16005: LD_INT 1
16007: PPUSH
16008: LD_INT 100
16010: PPUSH
16011: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16015: LD_VAR 0 1
16019: PPUSH
16020: LD_INT 25
16022: PPUSH
16023: CALL_OW 173
// AddComUnload ( veh ) ;
16027: LD_VAR 0 1
16031: PPUSH
16032: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_INT 229
16043: PPUSH
16044: LD_INT 226
16046: PPUSH
16047: CALL_OW 171
// wait ( 0 0$10 ) ;
16051: LD_INT 350
16053: PPUSH
16054: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16058: LD_INT 35
16060: PPUSH
16061: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16065: LD_VAR 0 1
16069: PPUSH
16070: LD_INT 229
16072: PPUSH
16073: LD_INT 226
16075: PPUSH
16076: CALL_OW 307
16080: IFFALSE 16058
// RemoveUnit ( veh ) ;
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 64
// end ;
16091: PPOPN 2
16093: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16094: LD_EXP 2
16098: PUSH
16099: LD_INT 1
16101: EQUAL
16102: PUSH
16103: LD_EXP 3
16107: AND
16108: PUSH
16109: LD_EXP 24
16113: AND
16114: IFFALSE 16447
16116: GO 16118
16118: DISABLE
16119: LD_INT 0
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
16125: PPUSH
// begin enable ;
16126: ENABLE
// tmp := [ ] ;
16127: LD_ADDR_VAR 0 4
16131: PUSH
16132: EMPTY
16133: ST_TO_ADDR
// if commander = 1 then
16134: LD_EXP 25
16138: PUSH
16139: LD_INT 1
16141: EQUAL
16142: IFFALSE 16154
// amount := 3 else
16144: LD_ADDR_VAR 0 5
16148: PUSH
16149: LD_INT 3
16151: ST_TO_ADDR
16152: GO 16162
// amount := 2 ;
16154: LD_ADDR_VAR 0 5
16158: PUSH
16159: LD_INT 2
16161: ST_TO_ADDR
// for i = 1 to amount do
16162: LD_ADDR_VAR 0 1
16166: PUSH
16167: DOUBLE
16168: LD_INT 1
16170: DEC
16171: ST_TO_ADDR
16172: LD_VAR 0 5
16176: PUSH
16177: FOR_TO
16178: IFFALSE 16342
// begin wait ( 0 0$5 ) ;
16180: LD_INT 175
16182: PPUSH
16183: CALL_OW 67
// for j = 1 to 3 do
16187: LD_ADDR_VAR 0 2
16191: PUSH
16192: DOUBLE
16193: LD_INT 1
16195: DEC
16196: ST_TO_ADDR
16197: LD_INT 3
16199: PUSH
16200: FOR_TO
16201: IFFALSE 16338
// begin uc_side := 4 ;
16203: LD_ADDR_OWVAR 20
16207: PUSH
16208: LD_INT 4
16210: ST_TO_ADDR
// uc_nation := 1 ;
16211: LD_ADDR_OWVAR 21
16215: PUSH
16216: LD_INT 1
16218: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16219: LD_INT 3
16221: PUSH
16222: LD_INT 5
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PUSH
16229: LD_INT 1
16231: PPUSH
16232: LD_INT 2
16234: PPUSH
16235: CALL_OW 12
16239: ARRAY
16240: PPUSH
16241: LD_INT 3
16243: PPUSH
16244: LD_INT 3
16246: PPUSH
16247: LD_INT 9
16249: PUSH
16250: LD_INT 5
16252: PUSH
16253: LD_INT 7
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: PUSH
16261: LD_INT 1
16263: PPUSH
16264: LD_INT 3
16266: PPUSH
16267: CALL_OW 12
16271: ARRAY
16272: PPUSH
16273: LD_INT 100
16275: PPUSH
16276: CALL 24724 0 5
// veh := CreateVehicle ;
16280: LD_ADDR_VAR 0 3
16284: PUSH
16285: CALL_OW 45
16289: ST_TO_ADDR
// tmp := tmp ^ veh ;
16290: LD_ADDR_VAR 0 4
16294: PUSH
16295: LD_VAR 0 4
16299: PUSH
16300: LD_VAR 0 3
16304: ADD
16305: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16306: LD_VAR 0 3
16310: PPUSH
16311: LD_INT 22
16313: PPUSH
16314: LD_INT 0
16316: PPUSH
16317: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16321: LD_VAR 0 3
16325: PPUSH
16326: LD_INT 119
16328: PPUSH
16329: LD_INT 215
16331: PPUSH
16332: CALL_OW 111
// end ;
16336: GO 16200
16338: POP
16339: POP
// end ;
16340: GO 16177
16342: POP
16343: POP
// wait ( 0 0$3 ) ;
16344: LD_INT 105
16346: PPUSH
16347: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16351: LD_INT 35
16353: PPUSH
16354: CALL_OW 67
// for i in tmp do
16358: LD_ADDR_VAR 0 1
16362: PUSH
16363: LD_VAR 0 4
16367: PUSH
16368: FOR_IN
16369: IFFALSE 16436
// if IsDead ( i ) then
16371: LD_VAR 0 1
16375: PPUSH
16376: CALL_OW 301
16380: IFFALSE 16400
// tmp := tmp diff i else
16382: LD_ADDR_VAR 0 4
16386: PUSH
16387: LD_VAR 0 4
16391: PUSH
16392: LD_VAR 0 1
16396: DIFF
16397: ST_TO_ADDR
16398: GO 16434
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_INT 81
16407: PUSH
16408: LD_INT 4
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL_OW 69
16419: PPUSH
16420: LD_VAR 0 1
16424: PPUSH
16425: CALL_OW 74
16429: PPUSH
16430: CALL_OW 115
16434: GO 16368
16436: POP
16437: POP
// until tmp = [ ] ;
16438: LD_VAR 0 4
16442: PUSH
16443: EMPTY
16444: EQUAL
16445: IFFALSE 16351
// end ;
16447: PPOPN 5
16449: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16450: LD_EXP 2
16454: PUSH
16455: LD_INT 1
16457: EQUAL
16458: PUSH
16459: LD_EXP 3
16463: AND
16464: IFFALSE 16565
16466: GO 16468
16468: DISABLE
16469: LD_INT 0
16471: PPUSH
16472: PPUSH
// begin enable ;
16473: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16474: LD_ADDR_VAR 0 2
16478: PUSH
16479: LD_INT 3
16481: PUSH
16482: LD_INT 22
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 32
16498: PUSH
16499: LD_INT 1
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PPUSH
16510: CALL_OW 69
16514: ST_TO_ADDR
// if tmp then
16515: LD_VAR 0 2
16519: IFFALSE 16565
// for i in tmp do
16521: LD_ADDR_VAR 0 1
16525: PUSH
16526: LD_VAR 0 2
16530: PUSH
16531: FOR_IN
16532: IFFALSE 16563
// if GetFuel ( i ) < 3 then
16534: LD_VAR 0 1
16538: PPUSH
16539: CALL_OW 261
16543: PUSH
16544: LD_INT 3
16546: LESS
16547: IFFALSE 16561
// SetFuel ( i , 3 ) ;
16549: LD_VAR 0 1
16553: PPUSH
16554: LD_INT 3
16556: PPUSH
16557: CALL_OW 240
16561: GO 16531
16563: POP
16564: POP
// end ;
16565: PPOPN 2
16567: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16568: LD_EXP 3
16572: PUSH
16573: LD_INT 8
16575: PPUSH
16576: LD_INT 4
16578: PPUSH
16579: CALL_OW 81
16583: PUSH
16584: LD_INT 2
16586: EQUAL
16587: AND
16588: IFFALSE 16798
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin enable ;
16598: ENABLE
// tmp := [ ] ;
16599: LD_ADDR_VAR 0 3
16603: PUSH
16604: EMPTY
16605: ST_TO_ADDR
// for i = 1 to 4 do
16606: LD_ADDR_VAR 0 1
16610: PUSH
16611: DOUBLE
16612: LD_INT 1
16614: DEC
16615: ST_TO_ADDR
16616: LD_INT 4
16618: PUSH
16619: FOR_TO
16620: IFFALSE 16764
// begin uc_side := 8 ;
16622: LD_ADDR_OWVAR 20
16626: PUSH
16627: LD_INT 8
16629: ST_TO_ADDR
// uc_nation := nation_arabian ;
16630: LD_ADDR_OWVAR 21
16634: PUSH
16635: LD_INT 2
16637: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16638: LD_INT 11
16640: PPUSH
16641: LD_INT 1
16643: PPUSH
16644: LD_INT 5
16646: PPUSH
16647: LD_INT 24
16649: PUSH
16650: LD_INT 23
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PUSH
16657: LD_INT 1
16659: PPUSH
16660: LD_INT 2
16662: PPUSH
16663: CALL_OW 12
16667: ARRAY
16668: PPUSH
16669: LD_INT 60
16671: PPUSH
16672: LD_INT 80
16674: PPUSH
16675: CALL_OW 12
16679: PPUSH
16680: CALL 24724 0 5
// un := CreateVehicle ;
16684: LD_ADDR_VAR 0 2
16688: PUSH
16689: CALL_OW 45
16693: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16694: LD_VAR 0 2
16698: PPUSH
16699: LD_INT 2
16701: PPUSH
16702: CALL_OW 233
// tmp := tmp ^ un ;
16706: LD_ADDR_VAR 0 3
16710: PUSH
16711: LD_VAR 0 3
16715: PUSH
16716: LD_VAR 0 2
16720: ADD
16721: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16722: LD_VAR 0 2
16726: PPUSH
16727: LD_INT 88
16729: PPUSH
16730: LD_INT 2
16732: PPUSH
16733: LD_INT 0
16735: PPUSH
16736: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16740: LD_VAR 0 2
16744: PPUSH
16745: LD_INT 93
16747: PPUSH
16748: LD_INT 13
16750: PPUSH
16751: CALL_OW 111
// wait ( 0 0$2 ) ;
16755: LD_INT 70
16757: PPUSH
16758: CALL_OW 67
// end ;
16762: GO 16619
16764: POP
16765: POP
// for i in tmp do
16766: LD_ADDR_VAR 0 1
16770: PUSH
16771: LD_VAR 0 3
16775: PUSH
16776: FOR_IN
16777: IFFALSE 16796
// AddComMoveXY ( i , 136 , 19 ) ;
16779: LD_VAR 0 1
16783: PPUSH
16784: LD_INT 136
16786: PPUSH
16787: LD_INT 19
16789: PPUSH
16790: CALL_OW 171
16794: GO 16776
16796: POP
16797: POP
// end ;
16798: PPOPN 3
16800: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16801: LD_EXP 3
16805: IFFALSE 17724
16807: GO 16809
16809: DISABLE
16810: LD_INT 0
16812: PPUSH
16813: PPUSH
16814: PPUSH
16815: PPUSH
// begin enable ;
16816: ENABLE
// base := mc_leg ;
16817: LD_ADDR_VAR 0 2
16821: PUSH
16822: LD_EXP 6
16826: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16827: LD_INT 22
16829: PUSH
16830: LD_INT 8
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 23
16839: PUSH
16840: LD_INT 2
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 3
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 69
16866: NOT
16867: IFFALSE 16871
// exit ;
16869: GO 17724
// if Prob ( 40 ) then
16871: LD_INT 40
16873: PPUSH
16874: CALL_OW 13
16878: IFFALSE 17007
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16880: LD_VAR 0 2
16884: PPUSH
16885: LD_INT 13
16887: PUSH
16888: LD_INT 1
16890: PUSH
16891: LD_INT 2
16893: PUSH
16894: LD_INT 28
16896: PUSH
16897: EMPTY
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 13
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 28
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: PUSH
16921: LD_INT 13
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: LD_INT 2
16929: PUSH
16930: LD_INT 28
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 13
16941: PUSH
16942: LD_INT 1
16944: PUSH
16945: LD_INT 2
16947: PUSH
16948: LD_INT 28
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 13
16959: PUSH
16960: LD_INT 1
16962: PUSH
16963: LD_INT 2
16965: PUSH
16966: LD_INT 28
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: PUSH
16975: LD_INT 13
16977: PUSH
16978: LD_INT 1
16980: PUSH
16981: LD_INT 2
16983: PUSH
16984: LD_INT 26
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: PPUSH
17001: CALL 86090 0 2
// end else
17005: GO 17224
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17007: LD_VAR 0 2
17011: PPUSH
17012: LD_INT 13
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: LD_INT 2
17020: PUSH
17021: LD_INT 27
17023: PUSH
17024: LD_INT 26
17026: PUSH
17027: LD_INT 26
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 1
17037: PPUSH
17038: LD_INT 3
17040: PPUSH
17041: CALL_OW 12
17045: ARRAY
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: PUSH
17053: LD_INT 13
17055: PUSH
17056: LD_INT 1
17058: PUSH
17059: LD_INT 2
17061: PUSH
17062: LD_INT 27
17064: PUSH
17065: LD_INT 26
17067: PUSH
17068: LD_INT 26
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 3
17081: PPUSH
17082: CALL_OW 12
17086: ARRAY
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 13
17096: PUSH
17097: LD_INT 1
17099: PUSH
17100: LD_INT 2
17102: PUSH
17103: LD_INT 26
17105: PUSH
17106: LD_INT 26
17108: PUSH
17109: LD_INT 29
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 1
17119: PPUSH
17120: LD_INT 3
17122: PPUSH
17123: CALL_OW 12
17127: ARRAY
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 13
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: LD_INT 2
17143: PUSH
17144: LD_INT 26
17146: PUSH
17147: LD_INT 29
17149: PUSH
17150: LD_INT 29
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: LIST
17157: PUSH
17158: LD_INT 1
17160: PPUSH
17161: LD_INT 3
17163: PPUSH
17164: CALL_OW 12
17168: ARRAY
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: PUSH
17176: LD_INT 13
17178: PUSH
17179: LD_INT 1
17181: PUSH
17182: LD_INT 2
17184: PUSH
17185: LD_INT 29
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 13
17196: PUSH
17197: LD_INT 1
17199: PUSH
17200: LD_INT 2
17202: PUSH
17203: LD_INT 26
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: PPUSH
17220: CALL 86090 0 2
// end ; repeat wait ( 0 0$1 ) ;
17224: LD_INT 35
17226: PPUSH
17227: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17231: LD_VAR 0 2
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: CALL 87508 0 2
17243: PUSH
17244: LD_INT 6
17246: GREATEREQUAL
17247: PUSH
17248: LD_OWVAR 1
17252: PUSH
17253: LD_INT 21000
17255: MOD
17256: PUSH
17257: LD_INT 0
17259: EQUAL
17260: OR
17261: IFFALSE 17224
// wait ( 0 0$30 ) ;
17263: LD_INT 1050
17265: PPUSH
17266: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17270: LD_ADDR_VAR 0 3
17274: PUSH
17275: LD_VAR 0 2
17279: PPUSH
17280: LD_INT 1
17282: PPUSH
17283: CALL 87508 0 2
17287: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17288: LD_ADDR_EXP 50
17292: PUSH
17293: LD_EXP 50
17297: PPUSH
17298: LD_VAR 0 2
17302: PPUSH
17303: LD_EXP 50
17307: PUSH
17308: LD_VAR 0 2
17312: ARRAY
17313: PUSH
17314: LD_VAR 0 3
17318: DIFF
17319: PPUSH
17320: CALL_OW 1
17324: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17325: LD_ADDR_VAR 0 4
17329: PUSH
17330: LD_INT 0
17332: PPUSH
17333: LD_INT 2
17335: PPUSH
17336: CALL_OW 12
17340: ST_TO_ADDR
// if legChangeSide then
17341: LD_EXP 21
17345: IFFALSE 17355
// target := 2 ;
17347: LD_ADDR_VAR 0 4
17351: PUSH
17352: LD_INT 2
17354: ST_TO_ADDR
// if target = 2 then
17355: LD_VAR 0 4
17359: PUSH
17360: LD_INT 2
17362: EQUAL
17363: IFFALSE 17491
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_VAR 0 3
17374: PPUSH
17375: LD_INT 24
17377: PUSH
17378: LD_INT 250
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: PPUSH
17385: CALL_OW 72
17389: ST_TO_ADDR
// for i in tmp do
17390: LD_ADDR_VAR 0 1
17394: PUSH
17395: LD_VAR 0 3
17399: PUSH
17400: FOR_IN
17401: IFFALSE 17441
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17403: LD_VAR 0 1
17407: PPUSH
17408: LD_INT 112
17410: PPUSH
17411: LD_INT 64
17413: PPUSH
17414: CALL_OW 297
17418: PUSH
17419: LD_INT 9
17421: GREATER
17422: IFFALSE 17439
// ComMoveXY ( i , 112 , 64 ) ;
17424: LD_VAR 0 1
17428: PPUSH
17429: LD_INT 112
17431: PPUSH
17432: LD_INT 64
17434: PPUSH
17435: CALL_OW 111
17439: GO 17400
17441: POP
17442: POP
// wait ( 0 0$1 ) ;
17443: LD_INT 35
17445: PPUSH
17446: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17450: LD_VAR 0 3
17454: PPUSH
17455: LD_INT 92
17457: PUSH
17458: LD_INT 112
17460: PUSH
17461: LD_INT 64
17463: PUSH
17464: LD_INT 9
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: LIST
17472: PPUSH
17473: CALL_OW 72
17477: PUSH
17478: LD_VAR 0 3
17482: PUSH
17483: LD_INT 1
17485: MINUS
17486: GREATEREQUAL
17487: IFFALSE 17365
// end else
17489: GO 17615
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17491: LD_ADDR_VAR 0 3
17495: PUSH
17496: LD_VAR 0 3
17500: PPUSH
17501: LD_INT 24
17503: PUSH
17504: LD_INT 250
17506: PUSH
17507: EMPTY
17508: LIST
17509: LIST
17510: PPUSH
17511: CALL_OW 72
17515: ST_TO_ADDR
// for i in tmp do
17516: LD_ADDR_VAR 0 1
17520: PUSH
17521: LD_VAR 0 3
17525: PUSH
17526: FOR_IN
17527: IFFALSE 17567
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17529: LD_VAR 0 1
17533: PPUSH
17534: LD_INT 174
17536: PPUSH
17537: LD_INT 94
17539: PPUSH
17540: CALL_OW 297
17544: PUSH
17545: LD_INT 9
17547: GREATER
17548: IFFALSE 17565
// ComMoveXY ( i , 174 , 94 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 174
17557: PPUSH
17558: LD_INT 94
17560: PPUSH
17561: CALL_OW 111
17565: GO 17526
17567: POP
17568: POP
// wait ( 0 0$1 ) ;
17569: LD_INT 35
17571: PPUSH
17572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17576: LD_VAR 0 3
17580: PPUSH
17581: LD_INT 92
17583: PUSH
17584: LD_INT 174
17586: PUSH
17587: LD_INT 94
17589: PUSH
17590: LD_INT 9
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: PPUSH
17599: CALL_OW 72
17603: PUSH
17604: LD_VAR 0 3
17608: PUSH
17609: LD_INT 1
17611: MINUS
17612: GREATEREQUAL
17613: IFFALSE 17491
// end ; repeat wait ( 0 0$1 ) ;
17615: LD_INT 35
17617: PPUSH
17618: CALL_OW 67
// for i in tmp do
17622: LD_ADDR_VAR 0 1
17626: PUSH
17627: LD_VAR 0 3
17631: PUSH
17632: FOR_IN
17633: IFFALSE 17715
// begin if GetLives ( i ) > 251 then
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL_OW 256
17644: PUSH
17645: LD_INT 251
17647: GREATER
17648: IFFALSE 17686
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17650: LD_VAR 0 1
17654: PPUSH
17655: LD_INT 81
17657: PUSH
17658: LD_INT 8
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: PPUSH
17665: CALL_OW 69
17669: PPUSH
17670: LD_VAR 0 1
17674: PPUSH
17675: CALL_OW 74
17679: PPUSH
17680: CALL_OW 115
17684: GO 17713
// if IsDead ( i ) then
17686: LD_VAR 0 1
17690: PPUSH
17691: CALL_OW 301
17695: IFFALSE 17713
// tmp := tmp diff i ;
17697: LD_ADDR_VAR 0 3
17701: PUSH
17702: LD_VAR 0 3
17706: PUSH
17707: LD_VAR 0 1
17711: DIFF
17712: ST_TO_ADDR
// end ;
17713: GO 17632
17715: POP
17716: POP
// until not tmp ;
17717: LD_VAR 0 3
17721: NOT
17722: IFFALSE 17615
// end ;
17724: PPOPN 4
17726: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17727: LD_EXP 3
17731: IFFALSE 18719
17733: GO 17735
17735: DISABLE
17736: LD_INT 0
17738: PPUSH
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
// begin enable ;
17743: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17744: LD_EXP 31
17748: PUSH
17749: LD_EXP 8
17753: ARRAY
17754: PPUSH
17755: LD_INT 22
17757: PUSH
17758: LD_INT 3
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 3
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: PPUSH
17779: CALL_OW 72
17783: NOT
17784: IFFALSE 17788
// exit ;
17786: GO 18719
// base := mc_rus_2 ;
17788: LD_ADDR_VAR 0 2
17792: PUSH
17793: LD_EXP 8
17797: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17798: LD_ADDR_VAR 0 5
17802: PUSH
17803: LD_INT 22
17805: PUSH
17806: LD_INT 3
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: PUSH
17813: LD_INT 30
17815: PUSH
17816: LD_INT 34
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: PPUSH
17827: CALL_OW 69
17831: ST_TO_ADDR
// if Prob ( 40 ) then
17832: LD_INT 40
17834: PPUSH
17835: CALL_OW 13
17839: IFFALSE 17968
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17841: LD_VAR 0 2
17845: PPUSH
17846: LD_INT 22
17848: PUSH
17849: LD_INT 3
17851: PUSH
17852: LD_INT 3
17854: PUSH
17855: LD_INT 49
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: PUSH
17864: LD_INT 22
17866: PUSH
17867: LD_INT 3
17869: PUSH
17870: LD_INT 3
17872: PUSH
17873: LD_INT 49
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: PUSH
17882: LD_INT 22
17884: PUSH
17885: LD_INT 3
17887: PUSH
17888: LD_INT 3
17890: PUSH
17891: LD_INT 49
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 24
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: LD_INT 46
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: LIST
17916: LIST
17917: PUSH
17918: LD_INT 24
17920: PUSH
17921: LD_INT 3
17923: PUSH
17924: LD_INT 3
17926: PUSH
17927: LD_INT 46
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: LIST
17934: LIST
17935: PUSH
17936: LD_INT 24
17938: PUSH
17939: LD_INT 3
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 46
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: PPUSH
17962: CALL 86090 0 2
// end else
17966: GO 18093
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17968: LD_VAR 0 2
17972: PPUSH
17973: LD_INT 24
17975: PUSH
17976: LD_INT 3
17978: PUSH
17979: LD_INT 3
17981: PUSH
17982: LD_INT 47
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: PUSH
17991: LD_INT 24
17993: PUSH
17994: LD_INT 3
17996: PUSH
17997: LD_INT 3
17999: PUSH
18000: LD_INT 47
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 24
18011: PUSH
18012: LD_INT 3
18014: PUSH
18015: LD_INT 3
18017: PUSH
18018: LD_INT 47
18020: PUSH
18021: EMPTY
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 24
18029: PUSH
18030: LD_INT 3
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: LD_INT 46
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 24
18047: PUSH
18048: LD_INT 3
18050: PUSH
18051: LD_INT 3
18053: PUSH
18054: LD_INT 46
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: PUSH
18063: LD_INT 24
18065: PUSH
18066: LD_INT 3
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 46
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: PPUSH
18089: CALL 86090 0 2
// end ; if Difficulty > 1 then
18093: LD_OWVAR 67
18097: PUSH
18098: LD_INT 1
18100: GREATER
18101: IFFALSE 18133
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18103: LD_VAR 0 2
18107: PPUSH
18108: LD_INT 24
18110: PUSH
18111: LD_INT 3
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 47
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: PPUSH
18129: CALL 86090 0 2
// repeat wait ( 0 0$1 ) ;
18133: LD_INT 35
18135: PPUSH
18136: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18140: LD_VAR 0 2
18144: PPUSH
18145: LD_INT 1
18147: PPUSH
18148: CALL 87508 0 2
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 7
18158: PUSH
18159: LD_INT 7
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: PUSH
18167: LD_OWVAR 67
18171: ARRAY
18172: GREATEREQUAL
18173: PUSH
18174: LD_OWVAR 1
18178: PUSH
18179: LD_INT 21000
18181: MOD
18182: PUSH
18183: LD_INT 0
18185: EQUAL
18186: OR
18187: IFFALSE 18133
// wait ( 0 0$45 ) ;
18189: LD_INT 1575
18191: PPUSH
18192: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_VAR 0 2
18205: PPUSH
18206: LD_INT 1
18208: PPUSH
18209: CALL 87508 0 2
18213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18214: LD_ADDR_EXP 50
18218: PUSH
18219: LD_EXP 50
18223: PPUSH
18224: LD_VAR 0 2
18228: PPUSH
18229: LD_EXP 50
18233: PUSH
18234: LD_VAR 0 2
18238: ARRAY
18239: PUSH
18240: LD_VAR 0 3
18244: DIFF
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18251: LD_ADDR_VAR 0 4
18255: PUSH
18256: LD_INT 0
18258: PPUSH
18259: LD_INT 1
18261: PPUSH
18262: CALL_OW 12
18266: ST_TO_ADDR
// if target then
18267: LD_VAR 0 4
18271: IFFALSE 18399
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18273: LD_ADDR_VAR 0 3
18277: PUSH
18278: LD_VAR 0 3
18282: PPUSH
18283: LD_INT 24
18285: PUSH
18286: LD_INT 250
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 72
18297: ST_TO_ADDR
// for i in tmp do
18298: LD_ADDR_VAR 0 1
18302: PUSH
18303: LD_VAR 0 3
18307: PUSH
18308: FOR_IN
18309: IFFALSE 18349
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18311: LD_VAR 0 1
18315: PPUSH
18316: LD_INT 84
18318: PPUSH
18319: LD_INT 32
18321: PPUSH
18322: CALL_OW 297
18326: PUSH
18327: LD_INT 9
18329: GREATER
18330: IFFALSE 18347
// ComMoveXY ( i , 84 , 32 ) ;
18332: LD_VAR 0 1
18336: PPUSH
18337: LD_INT 84
18339: PPUSH
18340: LD_INT 32
18342: PPUSH
18343: CALL_OW 111
18347: GO 18308
18349: POP
18350: POP
// wait ( 0 0$1 ) ;
18351: LD_INT 35
18353: PPUSH
18354: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18358: LD_VAR 0 3
18362: PPUSH
18363: LD_INT 92
18365: PUSH
18366: LD_INT 84
18368: PUSH
18369: LD_INT 32
18371: PUSH
18372: LD_INT 9
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: PPUSH
18381: CALL_OW 72
18385: PUSH
18386: LD_VAR 0 3
18390: PUSH
18391: LD_INT 1
18393: MINUS
18394: GREATEREQUAL
18395: IFFALSE 18273
// end else
18397: GO 18559
// begin if teleport then
18399: LD_VAR 0 5
18403: IFFALSE 18423
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18405: LD_VAR 0 3
18409: PPUSH
18410: LD_VAR 0 5
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18423: LD_ADDR_VAR 0 3
18427: PUSH
18428: LD_VAR 0 3
18432: PPUSH
18433: LD_INT 24
18435: PUSH
18436: LD_INT 250
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: PPUSH
18443: CALL_OW 72
18447: ST_TO_ADDR
// for i in tmp do
18448: LD_ADDR_VAR 0 1
18452: PUSH
18453: LD_VAR 0 3
18457: PUSH
18458: FOR_IN
18459: IFFALSE 18511
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 140
18468: PPUSH
18469: LD_INT 219
18471: PPUSH
18472: CALL_OW 297
18476: PUSH
18477: LD_INT 9
18479: GREATER
18480: PUSH
18481: LD_VAR 0 1
18485: PPUSH
18486: CALL_OW 314
18490: NOT
18491: AND
18492: IFFALSE 18509
// AddComMoveXY ( i , 140 , 219 ) ;
18494: LD_VAR 0 1
18498: PPUSH
18499: LD_INT 140
18501: PPUSH
18502: LD_INT 219
18504: PPUSH
18505: CALL_OW 171
18509: GO 18458
18511: POP
18512: POP
// wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_INT 92
18527: PUSH
18528: LD_INT 140
18530: PUSH
18531: LD_INT 219
18533: PUSH
18534: LD_INT 9
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 72
18547: PUSH
18548: LD_VAR 0 3
18552: PUSH
18553: LD_INT 1
18555: MINUS
18556: GREATEREQUAL
18557: IFFALSE 18423
// end ; repeat wait ( 0 0$1 ) ;
18559: LD_INT 35
18561: PPUSH
18562: CALL_OW 67
// for i in tmp do
18566: LD_ADDR_VAR 0 1
18570: PUSH
18571: LD_VAR 0 3
18575: PUSH
18576: FOR_IN
18577: IFFALSE 18710
// begin if GetLives ( i ) > 251 then
18579: LD_VAR 0 1
18583: PPUSH
18584: CALL_OW 256
18588: PUSH
18589: LD_INT 251
18591: GREATER
18592: IFFALSE 18681
// begin if GetWeapon ( i ) = ru_time_lapser then
18594: LD_VAR 0 1
18598: PPUSH
18599: CALL_OW 264
18603: PUSH
18604: LD_INT 49
18606: EQUAL
18607: IFFALSE 18645
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18609: LD_VAR 0 1
18613: PPUSH
18614: LD_INT 81
18616: PUSH
18617: LD_INT 3
18619: PUSH
18620: EMPTY
18621: LIST
18622: LIST
18623: PPUSH
18624: CALL_OW 69
18628: PPUSH
18629: LD_VAR 0 1
18633: PPUSH
18634: CALL_OW 74
18638: PPUSH
18639: CALL_OW 112
18643: GO 18679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18645: LD_VAR 0 1
18649: PPUSH
18650: LD_INT 81
18652: PUSH
18653: LD_INT 3
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL_OW 69
18664: PPUSH
18665: LD_VAR 0 1
18669: PPUSH
18670: CALL_OW 74
18674: PPUSH
18675: CALL_OW 115
// end else
18679: GO 18708
// if IsDead ( i ) then
18681: LD_VAR 0 1
18685: PPUSH
18686: CALL_OW 301
18690: IFFALSE 18708
// tmp := tmp diff i ;
18692: LD_ADDR_VAR 0 3
18696: PUSH
18697: LD_VAR 0 3
18701: PUSH
18702: LD_VAR 0 1
18706: DIFF
18707: ST_TO_ADDR
// end ;
18708: GO 18576
18710: POP
18711: POP
// until not tmp ;
18712: LD_VAR 0 3
18716: NOT
18717: IFFALSE 18559
// end ;
18719: PPOPN 5
18721: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18722: LD_EXP 3
18726: IFFALSE 19108
18728: GO 18730
18730: DISABLE
18731: LD_INT 0
18733: PPUSH
18734: PPUSH
18735: PPUSH
18736: PPUSH
// begin enable ;
18737: ENABLE
// base := mc_amer ;
18738: LD_ADDR_VAR 0 2
18742: PUSH
18743: LD_EXP 5
18747: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18748: LD_INT 22
18750: PUSH
18751: LD_INT 4
18753: PUSH
18754: EMPTY
18755: LIST
18756: LIST
18757: PUSH
18758: LD_INT 23
18760: PUSH
18761: LD_INT 1
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 3
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL_OW 69
18787: NOT
18788: IFFALSE 18792
// exit ;
18790: GO 19108
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18792: LD_VAR 0 2
18796: PPUSH
18797: LD_INT 3
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 5
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 3
18817: PUSH
18818: LD_INT 1
18820: PUSH
18821: LD_INT 2
18823: PUSH
18824: LD_INT 9
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: LIST
18831: LIST
18832: PUSH
18833: LD_INT 3
18835: PUSH
18836: LD_INT 1
18838: PUSH
18839: LD_INT 2
18841: PUSH
18842: LD_INT 7
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: PUSH
18851: LD_INT 3
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: LD_INT 2
18859: PUSH
18860: LD_INT 7
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: LD_INT 1
18874: PUSH
18875: LD_INT 2
18877: PUSH
18878: LD_INT 7
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: PPUSH
18894: CALL 86090 0 2
// repeat wait ( 0 0$1 ) ;
18898: LD_INT 35
18900: PPUSH
18901: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18905: LD_VAR 0 2
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 87508 0 2
18917: PUSH
18918: LD_INT 5
18920: GREATEREQUAL
18921: PUSH
18922: LD_OWVAR 1
18926: PUSH
18927: LD_INT 21000
18929: MOD
18930: PUSH
18931: LD_INT 0
18933: EQUAL
18934: OR
18935: IFFALSE 18898
// wait ( 0 0$30 ) ;
18937: LD_INT 1050
18939: PPUSH
18940: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_VAR 0 2
18953: PPUSH
18954: LD_INT 1
18956: PPUSH
18957: CALL 87508 0 2
18961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18962: LD_ADDR_EXP 50
18966: PUSH
18967: LD_EXP 50
18971: PPUSH
18972: LD_VAR 0 2
18976: PPUSH
18977: LD_EXP 50
18981: PUSH
18982: LD_VAR 0 2
18986: ARRAY
18987: PUSH
18988: LD_VAR 0 3
18992: DIFF
18993: PPUSH
18994: CALL_OW 1
18998: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18999: LD_INT 35
19001: PPUSH
19002: CALL_OW 67
// for i in tmp do
19006: LD_ADDR_VAR 0 1
19010: PUSH
19011: LD_VAR 0 3
19015: PUSH
19016: FOR_IN
19017: IFFALSE 19099
// begin if GetLives ( i ) > 251 then
19019: LD_VAR 0 1
19023: PPUSH
19024: CALL_OW 256
19028: PUSH
19029: LD_INT 251
19031: GREATER
19032: IFFALSE 19070
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19034: LD_VAR 0 1
19038: PPUSH
19039: LD_INT 81
19041: PUSH
19042: LD_INT 4
19044: PUSH
19045: EMPTY
19046: LIST
19047: LIST
19048: PPUSH
19049: CALL_OW 69
19053: PPUSH
19054: LD_VAR 0 1
19058: PPUSH
19059: CALL_OW 74
19063: PPUSH
19064: CALL_OW 115
19068: GO 19097
// if IsDead ( i ) then
19070: LD_VAR 0 1
19074: PPUSH
19075: CALL_OW 301
19079: IFFALSE 19097
// tmp := tmp diff i ;
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_VAR 0 3
19090: PUSH
19091: LD_VAR 0 1
19095: DIFF
19096: ST_TO_ADDR
// end ;
19097: GO 19016
19099: POP
19100: POP
// until not tmp ;
19101: LD_VAR 0 3
19105: NOT
19106: IFFALSE 18999
// end ; end_of_file
19108: PPOPN 4
19110: END
// export function CustomEvent ( event ) ; begin
19111: LD_INT 0
19113: PPUSH
// end ;
19114: LD_VAR 0 2
19118: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19119: LD_VAR 0 1
19123: PUSH
19124: LD_INT 1
19126: EQUAL
19127: PUSH
19128: LD_VAR 0 2
19132: PUSH
19133: LD_INT 4
19135: EQUAL
19136: AND
19137: IFFALSE 19165
// begin SayRadio ( Powell , DP-Lost ) ;
19139: LD_EXP 12
19143: PPUSH
19144: LD_STRING DP-Lost
19146: PPUSH
19147: CALL_OW 94
// wait ( 0 0$2 ) ;
19151: LD_INT 70
19153: PPUSH
19154: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19158: LD_STRING FriendlyFire
19160: PPUSH
19161: CALL_OW 104
// end ; end ;
19165: PPOPN 2
19167: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19168: LD_VAR 0 1
19172: PPUSH
19173: CALL 108318 0 1
// if GameType = 1 then
19177: LD_EXP 2
19181: PUSH
19182: LD_INT 1
19184: EQUAL
19185: IFFALSE 19420
// begin if un = playerCommander then
19187: LD_VAR 0 1
19191: PUSH
19192: LD_EXP 9
19196: EQUAL
19197: IFFALSE 19206
// YouLost ( commanderDied ) ;
19199: LD_STRING commanderDied
19201: PPUSH
19202: CALL_OW 104
// if un = allyCommander then
19206: LD_VAR 0 1
19210: PUSH
19211: LD_EXP 11
19215: EQUAL
19216: IFFALSE 19225
// YouLost ( Theta ) ;
19218: LD_STRING Theta
19220: PPUSH
19221: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19225: LD_VAR 0 1
19229: PUSH
19230: LD_INT 22
19232: PUSH
19233: LD_INT 8
19235: PUSH
19236: EMPTY
19237: LIST
19238: LIST
19239: PUSH
19240: LD_INT 2
19242: PUSH
19243: LD_INT 21
19245: PUSH
19246: LD_INT 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 69
19276: IN
19277: IFFALSE 19293
// legDestCounter := legDestCounter + 1 ;
19279: LD_ADDR_EXP 18
19283: PUSH
19284: LD_EXP 18
19288: PUSH
19289: LD_INT 1
19291: PLUS
19292: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19293: LD_VAR 0 1
19297: PUSH
19298: LD_INT 22
19300: PUSH
19301: LD_INT 4
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: PUSH
19308: LD_INT 2
19310: PUSH
19311: LD_INT 21
19313: PUSH
19314: LD_INT 1
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PUSH
19321: LD_INT 21
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PPUSH
19340: CALL_OW 69
19344: IN
19345: IFFALSE 19361
// allyDestCounter := allyDestCounter + 1 ;
19347: LD_ADDR_EXP 22
19351: PUSH
19352: LD_EXP 22
19356: PUSH
19357: LD_INT 1
19359: PLUS
19360: ST_TO_ADDR
// if un in ruOutpost then
19361: LD_VAR 0 1
19365: PUSH
19366: LD_EXP 14
19370: IN
19371: IFFALSE 19420
// begin ruOutpost := ruOutpost diff un ;
19373: LD_ADDR_EXP 14
19377: PUSH
19378: LD_EXP 14
19382: PUSH
19383: LD_VAR 0 1
19387: DIFF
19388: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19389: LD_ADDR_EXP 15
19393: PUSH
19394: LD_EXP 15
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: LD_EXP 15
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_INT 1
19413: PLUS
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19420: LD_VAR 0 1
19424: PPUSH
19425: CALL 89532 0 1
// end ;
19429: PPOPN 1
19431: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: LD_VAR 0 2
19441: PPUSH
19442: CALL 91864 0 2
// end ;
19446: PPOPN 2
19448: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19449: LD_VAR 0 1
19453: PPUSH
19454: CALL 90932 0 1
// end ;
19458: PPOPN 1
19460: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19461: LD_VAR 0 1
19465: PPUSH
19466: CALL 91173 0 1
// end ;
19470: PPOPN 1
19472: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19473: LD_VAR 0 1
19477: PUSH
19478: LD_INT 14
19480: EQUAL
19481: PUSH
19482: LD_VAR 0 2
19486: PPUSH
19487: CALL_OW 255
19491: PUSH
19492: LD_INT 1
19494: EQUAL
19495: AND
19496: IFFALSE 19537
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19498: LD_EXP 9
19502: PPUSH
19503: LD_STRING D
19505: PUSH
19506: LD_STRING I
19508: PUSH
19509: LD_STRING J
19511: PUSH
19512: LD_STRING S
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: LIST
19519: PUSH
19520: LD_EXP 25
19524: ARRAY
19525: STR
19526: PUSH
19527: LD_STRING -1-Laser
19529: STR
19530: PPUSH
19531: CALL_OW 88
// exit ;
19535: GO 19679
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19537: LD_VAR 0 1
19541: PUSH
19542: LD_INT 7
19544: EQUAL
19545: PUSH
19546: LD_VAR 0 2
19550: PPUSH
19551: CALL_OW 255
19555: PUSH
19556: LD_INT 1
19558: EQUAL
19559: AND
19560: IFFALSE 19601
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19562: LD_EXP 9
19566: PPUSH
19567: LD_STRING D
19569: PUSH
19570: LD_STRING I
19572: PUSH
19573: LD_STRING J
19575: PUSH
19576: LD_STRING S
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_EXP 25
19588: ARRAY
19589: STR
19590: PUSH
19591: LD_STRING -1-Materialization
19593: STR
19594: PPUSH
19595: CALL_OW 88
// exit ;
19599: GO 19679
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19601: LD_VAR 0 1
19605: PUSH
19606: LD_INT 25
19608: EQUAL
19609: PUSH
19610: LD_VAR 0 2
19614: PPUSH
19615: CALL_OW 255
19619: PUSH
19620: LD_INT 1
19622: EQUAL
19623: AND
19624: IFFALSE 19665
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19626: LD_EXP 9
19630: PPUSH
19631: LD_STRING D
19633: PUSH
19634: LD_STRING I
19636: PUSH
19637: LD_STRING J
19639: PUSH
19640: LD_STRING S
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: LIST
19647: PUSH
19648: LD_EXP 25
19652: ARRAY
19653: STR
19654: PUSH
19655: LD_STRING -1-Rocket
19657: STR
19658: PPUSH
19659: CALL_OW 88
// exit ;
19663: GO 19679
// end ; MCE_ResearchComplete ( tech , lab ) ;
19665: LD_VAR 0 1
19669: PPUSH
19670: LD_VAR 0 2
19674: PPUSH
19675: CALL 89228 0 2
// end ;
19679: PPOPN 2
19681: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19682: LD_VAR 0 1
19686: PPUSH
19687: LD_VAR 0 2
19691: PPUSH
19692: LD_VAR 0 3
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: LD_VAR 0 5
19706: PPUSH
19707: CALL 88848 0 5
// end ;
19711: PPOPN 5
19713: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19714: LD_VAR 0 1
19718: PPUSH
19719: LD_VAR 0 2
19723: PPUSH
19724: CALL 108438 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19728: LD_VAR 0 1
19732: PPUSH
19733: LD_VAR 0 2
19737: PPUSH
19738: CALL 88401 0 2
// end ;
19742: PPOPN 2
19744: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19745: LD_VAR 0 1
19749: PPUSH
19750: LD_VAR 0 2
19754: PPUSH
19755: LD_VAR 0 3
19759: PPUSH
19760: LD_VAR 0 4
19764: PPUSH
19765: CALL 88239 0 4
// end ;
19769: PPOPN 4
19771: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19772: LD_VAR 0 1
19776: PPUSH
19777: LD_VAR 0 2
19781: PPUSH
19782: LD_VAR 0 3
19786: PPUSH
19787: CALL 88014 0 3
// end ;
19791: PPOPN 3
19793: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19794: LD_VAR 0 1
19798: PPUSH
19799: LD_VAR 0 2
19803: PPUSH
19804: CALL 87899 0 2
// end ;
19808: PPOPN 2
19810: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19811: LD_VAR 0 1
19815: PPUSH
19816: LD_VAR 0 2
19820: PPUSH
19821: CALL 92159 0 2
// end ;
19825: PPOPN 2
19827: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19828: LD_VAR 0 1
19832: PPUSH
19833: LD_VAR 0 2
19837: PPUSH
19838: LD_VAR 0 3
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: CALL 92375 0 4
// end ;
19852: PPOPN 4
19854: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19855: LD_VAR 0 1
19859: PPUSH
19860: LD_VAR 0 2
19864: PPUSH
19865: CALL 87708 0 2
// end ;
19869: PPOPN 2
19871: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19872: LD_VAR 0 1
19876: PPUSH
19877: CALL 108422 0 1
// end ; end_of_file
19881: PPOPN 1
19883: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19884: LD_INT 0
19886: PPUSH
19887: PPUSH
// if exist_mode then
19888: LD_VAR 0 2
19892: IFFALSE 19917
// unit := CreateCharacter ( prefix & ident ) else
19894: LD_ADDR_VAR 0 5
19898: PUSH
19899: LD_VAR 0 3
19903: PUSH
19904: LD_VAR 0 1
19908: STR
19909: PPUSH
19910: CALL_OW 34
19914: ST_TO_ADDR
19915: GO 19932
// unit := NewCharacter ( ident ) ;
19917: LD_ADDR_VAR 0 5
19921: PUSH
19922: LD_VAR 0 1
19926: PPUSH
19927: CALL_OW 25
19931: ST_TO_ADDR
// result := unit ;
19932: LD_ADDR_VAR 0 4
19936: PUSH
19937: LD_VAR 0 5
19941: ST_TO_ADDR
// end ;
19942: LD_VAR 0 4
19946: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19947: LD_INT 0
19949: PPUSH
19950: PPUSH
// if not side or not nation then
19951: LD_VAR 0 1
19955: NOT
19956: PUSH
19957: LD_VAR 0 2
19961: NOT
19962: OR
19963: IFFALSE 19967
// exit ;
19965: GO 20735
// case nation of nation_american :
19967: LD_VAR 0 2
19971: PUSH
19972: LD_INT 1
19974: DOUBLE
19975: EQUAL
19976: IFTRUE 19980
19978: GO 20194
19980: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19981: LD_ADDR_VAR 0 4
19985: PUSH
19986: LD_INT 35
19988: PUSH
19989: LD_INT 45
19991: PUSH
19992: LD_INT 46
19994: PUSH
19995: LD_INT 47
19997: PUSH
19998: LD_INT 82
20000: PUSH
20001: LD_INT 83
20003: PUSH
20004: LD_INT 84
20006: PUSH
20007: LD_INT 85
20009: PUSH
20010: LD_INT 86
20012: PUSH
20013: LD_INT 1
20015: PUSH
20016: LD_INT 2
20018: PUSH
20019: LD_INT 6
20021: PUSH
20022: LD_INT 15
20024: PUSH
20025: LD_INT 16
20027: PUSH
20028: LD_INT 7
20030: PUSH
20031: LD_INT 12
20033: PUSH
20034: LD_INT 13
20036: PUSH
20037: LD_INT 10
20039: PUSH
20040: LD_INT 14
20042: PUSH
20043: LD_INT 20
20045: PUSH
20046: LD_INT 21
20048: PUSH
20049: LD_INT 22
20051: PUSH
20052: LD_INT 25
20054: PUSH
20055: LD_INT 32
20057: PUSH
20058: LD_INT 27
20060: PUSH
20061: LD_INT 36
20063: PUSH
20064: LD_INT 69
20066: PUSH
20067: LD_INT 39
20069: PUSH
20070: LD_INT 34
20072: PUSH
20073: LD_INT 40
20075: PUSH
20076: LD_INT 48
20078: PUSH
20079: LD_INT 49
20081: PUSH
20082: LD_INT 50
20084: PUSH
20085: LD_INT 51
20087: PUSH
20088: LD_INT 52
20090: PUSH
20091: LD_INT 53
20093: PUSH
20094: LD_INT 54
20096: PUSH
20097: LD_INT 55
20099: PUSH
20100: LD_INT 56
20102: PUSH
20103: LD_INT 57
20105: PUSH
20106: LD_INT 58
20108: PUSH
20109: LD_INT 59
20111: PUSH
20112: LD_INT 60
20114: PUSH
20115: LD_INT 61
20117: PUSH
20118: LD_INT 62
20120: PUSH
20121: LD_INT 80
20123: PUSH
20124: LD_INT 82
20126: PUSH
20127: LD_INT 83
20129: PUSH
20130: LD_INT 84
20132: PUSH
20133: LD_INT 85
20135: PUSH
20136: LD_INT 86
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: ST_TO_ADDR
20192: GO 20659
20194: LD_INT 2
20196: DOUBLE
20197: EQUAL
20198: IFTRUE 20202
20200: GO 20428
20202: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20203: LD_ADDR_VAR 0 4
20207: PUSH
20208: LD_INT 35
20210: PUSH
20211: LD_INT 45
20213: PUSH
20214: LD_INT 46
20216: PUSH
20217: LD_INT 47
20219: PUSH
20220: LD_INT 82
20222: PUSH
20223: LD_INT 83
20225: PUSH
20226: LD_INT 84
20228: PUSH
20229: LD_INT 85
20231: PUSH
20232: LD_INT 87
20234: PUSH
20235: LD_INT 70
20237: PUSH
20238: LD_INT 1
20240: PUSH
20241: LD_INT 11
20243: PUSH
20244: LD_INT 3
20246: PUSH
20247: LD_INT 4
20249: PUSH
20250: LD_INT 5
20252: PUSH
20253: LD_INT 6
20255: PUSH
20256: LD_INT 15
20258: PUSH
20259: LD_INT 18
20261: PUSH
20262: LD_INT 7
20264: PUSH
20265: LD_INT 17
20267: PUSH
20268: LD_INT 8
20270: PUSH
20271: LD_INT 20
20273: PUSH
20274: LD_INT 21
20276: PUSH
20277: LD_INT 22
20279: PUSH
20280: LD_INT 72
20282: PUSH
20283: LD_INT 26
20285: PUSH
20286: LD_INT 69
20288: PUSH
20289: LD_INT 39
20291: PUSH
20292: LD_INT 40
20294: PUSH
20295: LD_INT 41
20297: PUSH
20298: LD_INT 42
20300: PUSH
20301: LD_INT 43
20303: PUSH
20304: LD_INT 48
20306: PUSH
20307: LD_INT 49
20309: PUSH
20310: LD_INT 50
20312: PUSH
20313: LD_INT 51
20315: PUSH
20316: LD_INT 52
20318: PUSH
20319: LD_INT 53
20321: PUSH
20322: LD_INT 54
20324: PUSH
20325: LD_INT 55
20327: PUSH
20328: LD_INT 56
20330: PUSH
20331: LD_INT 60
20333: PUSH
20334: LD_INT 61
20336: PUSH
20337: LD_INT 62
20339: PUSH
20340: LD_INT 66
20342: PUSH
20343: LD_INT 67
20345: PUSH
20346: LD_INT 68
20348: PUSH
20349: LD_INT 81
20351: PUSH
20352: LD_INT 82
20354: PUSH
20355: LD_INT 83
20357: PUSH
20358: LD_INT 84
20360: PUSH
20361: LD_INT 85
20363: PUSH
20364: LD_INT 87
20366: PUSH
20367: LD_INT 88
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: ST_TO_ADDR
20426: GO 20659
20428: LD_INT 3
20430: DOUBLE
20431: EQUAL
20432: IFTRUE 20436
20434: GO 20658
20436: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20437: LD_ADDR_VAR 0 4
20441: PUSH
20442: LD_INT 46
20444: PUSH
20445: LD_INT 47
20447: PUSH
20448: LD_INT 1
20450: PUSH
20451: LD_INT 2
20453: PUSH
20454: LD_INT 82
20456: PUSH
20457: LD_INT 83
20459: PUSH
20460: LD_INT 84
20462: PUSH
20463: LD_INT 85
20465: PUSH
20466: LD_INT 86
20468: PUSH
20469: LD_INT 11
20471: PUSH
20472: LD_INT 9
20474: PUSH
20475: LD_INT 20
20477: PUSH
20478: LD_INT 19
20480: PUSH
20481: LD_INT 21
20483: PUSH
20484: LD_INT 24
20486: PUSH
20487: LD_INT 22
20489: PUSH
20490: LD_INT 25
20492: PUSH
20493: LD_INT 28
20495: PUSH
20496: LD_INT 29
20498: PUSH
20499: LD_INT 30
20501: PUSH
20502: LD_INT 31
20504: PUSH
20505: LD_INT 37
20507: PUSH
20508: LD_INT 38
20510: PUSH
20511: LD_INT 32
20513: PUSH
20514: LD_INT 27
20516: PUSH
20517: LD_INT 33
20519: PUSH
20520: LD_INT 69
20522: PUSH
20523: LD_INT 39
20525: PUSH
20526: LD_INT 34
20528: PUSH
20529: LD_INT 40
20531: PUSH
20532: LD_INT 71
20534: PUSH
20535: LD_INT 23
20537: PUSH
20538: LD_INT 44
20540: PUSH
20541: LD_INT 48
20543: PUSH
20544: LD_INT 49
20546: PUSH
20547: LD_INT 50
20549: PUSH
20550: LD_INT 51
20552: PUSH
20553: LD_INT 52
20555: PUSH
20556: LD_INT 53
20558: PUSH
20559: LD_INT 54
20561: PUSH
20562: LD_INT 55
20564: PUSH
20565: LD_INT 56
20567: PUSH
20568: LD_INT 57
20570: PUSH
20571: LD_INT 58
20573: PUSH
20574: LD_INT 59
20576: PUSH
20577: LD_INT 63
20579: PUSH
20580: LD_INT 64
20582: PUSH
20583: LD_INT 65
20585: PUSH
20586: LD_INT 82
20588: PUSH
20589: LD_INT 83
20591: PUSH
20592: LD_INT 84
20594: PUSH
20595: LD_INT 85
20597: PUSH
20598: LD_INT 86
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: ST_TO_ADDR
20656: GO 20659
20658: POP
// if state > - 1 and state < 3 then
20659: LD_VAR 0 3
20663: PUSH
20664: LD_INT 1
20666: NEG
20667: GREATER
20668: PUSH
20669: LD_VAR 0 3
20673: PUSH
20674: LD_INT 3
20676: LESS
20677: AND
20678: IFFALSE 20735
// for i in result do
20680: LD_ADDR_VAR 0 5
20684: PUSH
20685: LD_VAR 0 4
20689: PUSH
20690: FOR_IN
20691: IFFALSE 20733
// if GetTech ( i , side ) <> state then
20693: LD_VAR 0 5
20697: PPUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: CALL_OW 321
20707: PUSH
20708: LD_VAR 0 3
20712: NONEQUAL
20713: IFFALSE 20731
// result := result diff i ;
20715: LD_ADDR_VAR 0 4
20719: PUSH
20720: LD_VAR 0 4
20724: PUSH
20725: LD_VAR 0 5
20729: DIFF
20730: ST_TO_ADDR
20731: GO 20690
20733: POP
20734: POP
// end ;
20735: LD_VAR 0 4
20739: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20740: LD_INT 0
20742: PPUSH
20743: PPUSH
20744: PPUSH
// result := true ;
20745: LD_ADDR_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20753: LD_ADDR_VAR 0 5
20757: PUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: CALL_OW 480
20767: ST_TO_ADDR
// if not tmp then
20768: LD_VAR 0 5
20772: NOT
20773: IFFALSE 20777
// exit ;
20775: GO 20826
// for i in tmp do
20777: LD_ADDR_VAR 0 4
20781: PUSH
20782: LD_VAR 0 5
20786: PUSH
20787: FOR_IN
20788: IFFALSE 20824
// if GetTech ( i , side ) <> state_researched then
20790: LD_VAR 0 4
20794: PPUSH
20795: LD_VAR 0 1
20799: PPUSH
20800: CALL_OW 321
20804: PUSH
20805: LD_INT 2
20807: NONEQUAL
20808: IFFALSE 20822
// begin result := false ;
20810: LD_ADDR_VAR 0 3
20814: PUSH
20815: LD_INT 0
20817: ST_TO_ADDR
// exit ;
20818: POP
20819: POP
20820: GO 20826
// end ;
20822: GO 20787
20824: POP
20825: POP
// end ;
20826: LD_VAR 0 3
20830: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20831: LD_INT 0
20833: PPUSH
20834: PPUSH
20835: PPUSH
20836: PPUSH
20837: PPUSH
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
20845: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20846: LD_VAR 0 1
20850: NOT
20851: PUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: CALL_OW 257
20861: PUSH
20862: LD_INT 9
20864: NONEQUAL
20865: OR
20866: IFFALSE 20870
// exit ;
20868: GO 21443
// side := GetSide ( unit ) ;
20870: LD_ADDR_VAR 0 9
20874: PUSH
20875: LD_VAR 0 1
20879: PPUSH
20880: CALL_OW 255
20884: ST_TO_ADDR
// tech_space := tech_spacanom ;
20885: LD_ADDR_VAR 0 12
20889: PUSH
20890: LD_INT 29
20892: ST_TO_ADDR
// tech_time := tech_taurad ;
20893: LD_ADDR_VAR 0 13
20897: PUSH
20898: LD_INT 28
20900: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20901: LD_ADDR_VAR 0 11
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 310
20915: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20916: LD_VAR 0 11
20920: PPUSH
20921: CALL_OW 247
20925: PUSH
20926: LD_INT 2
20928: EQUAL
20929: IFFALSE 20933
// exit ;
20931: GO 21443
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20933: LD_ADDR_VAR 0 8
20937: PUSH
20938: LD_INT 81
20940: PUSH
20941: LD_VAR 0 9
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: PUSH
20950: LD_INT 3
20952: PUSH
20953: LD_INT 21
20955: PUSH
20956: LD_INT 3
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PPUSH
20971: CALL_OW 69
20975: ST_TO_ADDR
// if not tmp then
20976: LD_VAR 0 8
20980: NOT
20981: IFFALSE 20985
// exit ;
20983: GO 21443
// if in_unit then
20985: LD_VAR 0 11
20989: IFFALSE 21013
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20991: LD_ADDR_VAR 0 10
20995: PUSH
20996: LD_VAR 0 8
21000: PPUSH
21001: LD_VAR 0 11
21005: PPUSH
21006: CALL_OW 74
21010: ST_TO_ADDR
21011: GO 21033
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21013: LD_ADDR_VAR 0 10
21017: PUSH
21018: LD_VAR 0 8
21022: PPUSH
21023: LD_VAR 0 1
21027: PPUSH
21028: CALL_OW 74
21032: ST_TO_ADDR
// if not enemy then
21033: LD_VAR 0 10
21037: NOT
21038: IFFALSE 21042
// exit ;
21040: GO 21443
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21042: LD_VAR 0 11
21046: PUSH
21047: LD_VAR 0 11
21051: PPUSH
21052: LD_VAR 0 10
21056: PPUSH
21057: CALL_OW 296
21061: PUSH
21062: LD_INT 13
21064: GREATER
21065: AND
21066: PUSH
21067: LD_VAR 0 1
21071: PPUSH
21072: LD_VAR 0 10
21076: PPUSH
21077: CALL_OW 296
21081: PUSH
21082: LD_INT 12
21084: GREATER
21085: OR
21086: IFFALSE 21090
// exit ;
21088: GO 21443
// missile := [ 1 ] ;
21090: LD_ADDR_VAR 0 14
21094: PUSH
21095: LD_INT 1
21097: PUSH
21098: EMPTY
21099: LIST
21100: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21101: LD_VAR 0 9
21105: PPUSH
21106: LD_VAR 0 12
21110: PPUSH
21111: CALL_OW 325
21115: IFFALSE 21144
// missile := Replace ( missile , missile + 1 , 2 ) ;
21117: LD_ADDR_VAR 0 14
21121: PUSH
21122: LD_VAR 0 14
21126: PPUSH
21127: LD_VAR 0 14
21131: PUSH
21132: LD_INT 1
21134: PLUS
21135: PPUSH
21136: LD_INT 2
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21144: LD_VAR 0 9
21148: PPUSH
21149: LD_VAR 0 13
21153: PPUSH
21154: CALL_OW 325
21158: PUSH
21159: LD_VAR 0 10
21163: PPUSH
21164: CALL_OW 255
21168: PPUSH
21169: LD_VAR 0 13
21173: PPUSH
21174: CALL_OW 325
21178: NOT
21179: AND
21180: IFFALSE 21209
// missile := Replace ( missile , missile + 1 , 3 ) ;
21182: LD_ADDR_VAR 0 14
21186: PUSH
21187: LD_VAR 0 14
21191: PPUSH
21192: LD_VAR 0 14
21196: PUSH
21197: LD_INT 1
21199: PLUS
21200: PPUSH
21201: LD_INT 3
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// if missile < 2 then
21209: LD_VAR 0 14
21213: PUSH
21214: LD_INT 2
21216: LESS
21217: IFFALSE 21221
// exit ;
21219: GO 21443
// x := GetX ( enemy ) ;
21221: LD_ADDR_VAR 0 4
21225: PUSH
21226: LD_VAR 0 10
21230: PPUSH
21231: CALL_OW 250
21235: ST_TO_ADDR
// y := GetY ( enemy ) ;
21236: LD_ADDR_VAR 0 5
21240: PUSH
21241: LD_VAR 0 10
21245: PPUSH
21246: CALL_OW 251
21250: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21251: LD_ADDR_VAR 0 6
21255: PUSH
21256: LD_VAR 0 4
21260: PUSH
21261: LD_INT 1
21263: NEG
21264: PPUSH
21265: LD_INT 1
21267: PPUSH
21268: CALL_OW 12
21272: PLUS
21273: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21274: LD_ADDR_VAR 0 7
21278: PUSH
21279: LD_VAR 0 5
21283: PUSH
21284: LD_INT 1
21286: NEG
21287: PPUSH
21288: LD_INT 1
21290: PPUSH
21291: CALL_OW 12
21295: PLUS
21296: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21297: LD_VAR 0 6
21301: PPUSH
21302: LD_VAR 0 7
21306: PPUSH
21307: CALL_OW 488
21311: NOT
21312: IFFALSE 21334
// begin _x := x ;
21314: LD_ADDR_VAR 0 6
21318: PUSH
21319: LD_VAR 0 4
21323: ST_TO_ADDR
// _y := y ;
21324: LD_ADDR_VAR 0 7
21328: PUSH
21329: LD_VAR 0 5
21333: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21334: LD_ADDR_VAR 0 3
21338: PUSH
21339: LD_INT 1
21341: PPUSH
21342: LD_VAR 0 14
21346: PPUSH
21347: CALL_OW 12
21351: ST_TO_ADDR
// case i of 1 :
21352: LD_VAR 0 3
21356: PUSH
21357: LD_INT 1
21359: DOUBLE
21360: EQUAL
21361: IFTRUE 21365
21363: GO 21382
21365: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21366: LD_VAR 0 1
21370: PPUSH
21371: LD_VAR 0 10
21375: PPUSH
21376: CALL_OW 115
21380: GO 21443
21382: LD_INT 2
21384: DOUBLE
21385: EQUAL
21386: IFTRUE 21390
21388: GO 21412
21390: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21391: LD_VAR 0 1
21395: PPUSH
21396: LD_VAR 0 6
21400: PPUSH
21401: LD_VAR 0 7
21405: PPUSH
21406: CALL_OW 153
21410: GO 21443
21412: LD_INT 3
21414: DOUBLE
21415: EQUAL
21416: IFTRUE 21420
21418: GO 21442
21420: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21421: LD_VAR 0 1
21425: PPUSH
21426: LD_VAR 0 6
21430: PPUSH
21431: LD_VAR 0 7
21435: PPUSH
21436: CALL_OW 154
21440: GO 21443
21442: POP
// end ;
21443: LD_VAR 0 2
21447: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
21453: PPUSH
21454: PPUSH
21455: PPUSH
// if not unit or not building then
21456: LD_VAR 0 1
21460: NOT
21461: PUSH
21462: LD_VAR 0 2
21466: NOT
21467: OR
21468: IFFALSE 21472
// exit ;
21470: GO 21630
// x := GetX ( building ) ;
21472: LD_ADDR_VAR 0 5
21476: PUSH
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 250
21486: ST_TO_ADDR
// y := GetY ( building ) ;
21487: LD_ADDR_VAR 0 6
21491: PUSH
21492: LD_VAR 0 2
21496: PPUSH
21497: CALL_OW 251
21501: ST_TO_ADDR
// for i = 0 to 5 do
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: DOUBLE
21508: LD_INT 0
21510: DEC
21511: ST_TO_ADDR
21512: LD_INT 5
21514: PUSH
21515: FOR_TO
21516: IFFALSE 21628
// begin _x := ShiftX ( x , i , 3 ) ;
21518: LD_ADDR_VAR 0 7
21522: PUSH
21523: LD_VAR 0 5
21527: PPUSH
21528: LD_VAR 0 4
21532: PPUSH
21533: LD_INT 3
21535: PPUSH
21536: CALL_OW 272
21540: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21541: LD_ADDR_VAR 0 8
21545: PUSH
21546: LD_VAR 0 6
21550: PPUSH
21551: LD_VAR 0 4
21555: PPUSH
21556: LD_INT 3
21558: PPUSH
21559: CALL_OW 273
21563: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21564: LD_VAR 0 7
21568: PPUSH
21569: LD_VAR 0 8
21573: PPUSH
21574: CALL_OW 488
21578: NOT
21579: IFFALSE 21583
// continue ;
21581: GO 21515
// if HexInfo ( _x , _y ) = 0 then
21583: LD_VAR 0 7
21587: PPUSH
21588: LD_VAR 0 8
21592: PPUSH
21593: CALL_OW 428
21597: PUSH
21598: LD_INT 0
21600: EQUAL
21601: IFFALSE 21626
// begin ComMoveXY ( unit , _x , _y ) ;
21603: LD_VAR 0 1
21607: PPUSH
21608: LD_VAR 0 7
21612: PPUSH
21613: LD_VAR 0 8
21617: PPUSH
21618: CALL_OW 111
// exit ;
21622: POP
21623: POP
21624: GO 21630
// end ; end ;
21626: GO 21515
21628: POP
21629: POP
// end ;
21630: LD_VAR 0 3
21634: RET
// export function ScanBase ( side , base_area ) ; begin
21635: LD_INT 0
21637: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21638: LD_ADDR_VAR 0 3
21642: PUSH
21643: LD_VAR 0 2
21647: PPUSH
21648: LD_INT 81
21650: PUSH
21651: LD_VAR 0 1
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PPUSH
21660: CALL_OW 70
21664: ST_TO_ADDR
// end ;
21665: LD_VAR 0 3
21669: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21670: LD_INT 0
21672: PPUSH
21673: PPUSH
21674: PPUSH
21675: PPUSH
// result := false ;
21676: LD_ADDR_VAR 0 2
21680: PUSH
21681: LD_INT 0
21683: ST_TO_ADDR
// side := GetSide ( unit ) ;
21684: LD_ADDR_VAR 0 3
21688: PUSH
21689: LD_VAR 0 1
21693: PPUSH
21694: CALL_OW 255
21698: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21699: LD_ADDR_VAR 0 4
21703: PUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 248
21713: ST_TO_ADDR
// case nat of 1 :
21714: LD_VAR 0 4
21718: PUSH
21719: LD_INT 1
21721: DOUBLE
21722: EQUAL
21723: IFTRUE 21727
21725: GO 21738
21727: POP
// tech := tech_lassight ; 2 :
21728: LD_ADDR_VAR 0 5
21732: PUSH
21733: LD_INT 12
21735: ST_TO_ADDR
21736: GO 21777
21738: LD_INT 2
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 21757
21746: POP
// tech := tech_mortar ; 3 :
21747: LD_ADDR_VAR 0 5
21751: PUSH
21752: LD_INT 41
21754: ST_TO_ADDR
21755: GO 21777
21757: LD_INT 3
21759: DOUBLE
21760: EQUAL
21761: IFTRUE 21765
21763: GO 21776
21765: POP
// tech := tech_bazooka ; end ;
21766: LD_ADDR_VAR 0 5
21770: PUSH
21771: LD_INT 44
21773: ST_TO_ADDR
21774: GO 21777
21776: POP
// if Researched ( side , tech ) then
21777: LD_VAR 0 3
21781: PPUSH
21782: LD_VAR 0 5
21786: PPUSH
21787: CALL_OW 325
21791: IFFALSE 21818
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21793: LD_ADDR_VAR 0 2
21797: PUSH
21798: LD_INT 5
21800: PUSH
21801: LD_INT 8
21803: PUSH
21804: LD_INT 9
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: PUSH
21812: LD_VAR 0 4
21816: ARRAY
21817: ST_TO_ADDR
// end ;
21818: LD_VAR 0 2
21822: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21823: LD_INT 0
21825: PPUSH
21826: PPUSH
21827: PPUSH
// if not mines then
21828: LD_VAR 0 2
21832: NOT
21833: IFFALSE 21837
// exit ;
21835: GO 21981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21837: LD_ADDR_VAR 0 5
21841: PUSH
21842: LD_INT 81
21844: PUSH
21845: LD_VAR 0 1
21849: PUSH
21850: EMPTY
21851: LIST
21852: LIST
21853: PUSH
21854: LD_INT 3
21856: PUSH
21857: LD_INT 21
21859: PUSH
21860: LD_INT 3
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PPUSH
21875: CALL_OW 69
21879: ST_TO_ADDR
// for i in mines do
21880: LD_ADDR_VAR 0 4
21884: PUSH
21885: LD_VAR 0 2
21889: PUSH
21890: FOR_IN
21891: IFFALSE 21979
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21893: LD_VAR 0 4
21897: PUSH
21898: LD_INT 1
21900: ARRAY
21901: PPUSH
21902: LD_VAR 0 4
21906: PUSH
21907: LD_INT 2
21909: ARRAY
21910: PPUSH
21911: CALL_OW 458
21915: NOT
21916: IFFALSE 21920
// continue ;
21918: GO 21890
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21920: LD_VAR 0 4
21924: PUSH
21925: LD_INT 1
21927: ARRAY
21928: PPUSH
21929: LD_VAR 0 4
21933: PUSH
21934: LD_INT 2
21936: ARRAY
21937: PPUSH
21938: CALL_OW 428
21942: PUSH
21943: LD_VAR 0 5
21947: IN
21948: IFFALSE 21977
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21950: LD_VAR 0 4
21954: PUSH
21955: LD_INT 1
21957: ARRAY
21958: PPUSH
21959: LD_VAR 0 4
21963: PUSH
21964: LD_INT 2
21966: ARRAY
21967: PPUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: CALL_OW 456
// end ;
21977: GO 21890
21979: POP
21980: POP
// end ;
21981: LD_VAR 0 3
21985: RET
// export function Count ( array ) ; begin
21986: LD_INT 0
21988: PPUSH
// result := array + 0 ;
21989: LD_ADDR_VAR 0 2
21993: PUSH
21994: LD_VAR 0 1
21998: PUSH
21999: LD_INT 0
22001: PLUS
22002: ST_TO_ADDR
// end ;
22003: LD_VAR 0 2
22007: RET
// export function IsEmpty ( building ) ; begin
22008: LD_INT 0
22010: PPUSH
// if not building then
22011: LD_VAR 0 1
22015: NOT
22016: IFFALSE 22020
// exit ;
22018: GO 22063
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22020: LD_ADDR_VAR 0 2
22024: PUSH
22025: LD_VAR 0 1
22029: PUSH
22030: LD_INT 22
22032: PUSH
22033: LD_VAR 0 1
22037: PPUSH
22038: CALL_OW 255
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: PUSH
22047: LD_INT 58
22049: PUSH
22050: EMPTY
22051: LIST
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: PPUSH
22057: CALL_OW 69
22061: IN
22062: ST_TO_ADDR
// end ;
22063: LD_VAR 0 2
22067: RET
// export function IsNotFull ( building ) ; var places ; begin
22068: LD_INT 0
22070: PPUSH
22071: PPUSH
// if not building then
22072: LD_VAR 0 1
22076: NOT
22077: IFFALSE 22081
// exit ;
22079: GO 22109
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
22081: LD_ADDR_VAR 0 2
22085: PUSH
22086: LD_VAR 0 1
22090: PPUSH
22091: LD_INT 3
22093: PUSH
22094: LD_INT 62
22096: PUSH
22097: EMPTY
22098: LIST
22099: PUSH
22100: EMPTY
22101: LIST
22102: LIST
22103: PPUSH
22104: CALL_OW 72
22108: ST_TO_ADDR
// end ;
22109: LD_VAR 0 2
22113: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22114: LD_INT 0
22116: PPUSH
22117: PPUSH
22118: PPUSH
22119: PPUSH
// tmp := [ ] ;
22120: LD_ADDR_VAR 0 3
22124: PUSH
22125: EMPTY
22126: ST_TO_ADDR
// list := [ ] ;
22127: LD_ADDR_VAR 0 5
22131: PUSH
22132: EMPTY
22133: ST_TO_ADDR
// for i = 16 to 25 do
22134: LD_ADDR_VAR 0 4
22138: PUSH
22139: DOUBLE
22140: LD_INT 16
22142: DEC
22143: ST_TO_ADDR
22144: LD_INT 25
22146: PUSH
22147: FOR_TO
22148: IFFALSE 22221
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22150: LD_ADDR_VAR 0 3
22154: PUSH
22155: LD_VAR 0 3
22159: PUSH
22160: LD_INT 22
22162: PUSH
22163: LD_VAR 0 1
22167: PPUSH
22168: CALL_OW 255
22172: PUSH
22173: EMPTY
22174: LIST
22175: LIST
22176: PUSH
22177: LD_INT 91
22179: PUSH
22180: LD_VAR 0 1
22184: PUSH
22185: LD_INT 6
22187: PUSH
22188: EMPTY
22189: LIST
22190: LIST
22191: LIST
22192: PUSH
22193: LD_INT 30
22195: PUSH
22196: LD_VAR 0 4
22200: PUSH
22201: EMPTY
22202: LIST
22203: LIST
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: LIST
22209: PUSH
22210: EMPTY
22211: LIST
22212: PPUSH
22213: CALL_OW 69
22217: ADD
22218: ST_TO_ADDR
22219: GO 22147
22221: POP
22222: POP
// for i = 1 to tmp do
22223: LD_ADDR_VAR 0 4
22227: PUSH
22228: DOUBLE
22229: LD_INT 1
22231: DEC
22232: ST_TO_ADDR
22233: LD_VAR 0 3
22237: PUSH
22238: FOR_TO
22239: IFFALSE 22327
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22241: LD_ADDR_VAR 0 5
22245: PUSH
22246: LD_VAR 0 5
22250: PUSH
22251: LD_VAR 0 3
22255: PUSH
22256: LD_VAR 0 4
22260: ARRAY
22261: PPUSH
22262: CALL_OW 266
22266: PUSH
22267: LD_VAR 0 3
22271: PUSH
22272: LD_VAR 0 4
22276: ARRAY
22277: PPUSH
22278: CALL_OW 250
22282: PUSH
22283: LD_VAR 0 3
22287: PUSH
22288: LD_VAR 0 4
22292: ARRAY
22293: PPUSH
22294: CALL_OW 251
22298: PUSH
22299: LD_VAR 0 3
22303: PUSH
22304: LD_VAR 0 4
22308: ARRAY
22309: PPUSH
22310: CALL_OW 254
22314: PUSH
22315: EMPTY
22316: LIST
22317: LIST
22318: LIST
22319: LIST
22320: PUSH
22321: EMPTY
22322: LIST
22323: ADD
22324: ST_TO_ADDR
22325: GO 22238
22327: POP
22328: POP
// result := list ;
22329: LD_ADDR_VAR 0 2
22333: PUSH
22334: LD_VAR 0 5
22338: ST_TO_ADDR
// end ;
22339: LD_VAR 0 2
22343: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22344: LD_INT 0
22346: PPUSH
22347: PPUSH
22348: PPUSH
22349: PPUSH
22350: PPUSH
22351: PPUSH
22352: PPUSH
// if not factory then
22353: LD_VAR 0 1
22357: NOT
22358: IFFALSE 22362
// exit ;
22360: GO 22955
// if control = control_apeman then
22362: LD_VAR 0 4
22366: PUSH
22367: LD_INT 5
22369: EQUAL
22370: IFFALSE 22479
// begin tmp := UnitsInside ( factory ) ;
22372: LD_ADDR_VAR 0 8
22376: PUSH
22377: LD_VAR 0 1
22381: PPUSH
22382: CALL_OW 313
22386: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22387: LD_VAR 0 8
22391: PPUSH
22392: LD_INT 25
22394: PUSH
22395: LD_INT 12
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PPUSH
22402: CALL_OW 72
22406: NOT
22407: IFFALSE 22417
// control := control_manual ;
22409: LD_ADDR_VAR 0 4
22413: PUSH
22414: LD_INT 1
22416: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22417: LD_ADDR_VAR 0 8
22421: PUSH
22422: LD_VAR 0 1
22426: PPUSH
22427: CALL 22114 0 1
22431: ST_TO_ADDR
// if tmp then
22432: LD_VAR 0 8
22436: IFFALSE 22479
// begin for i in tmp do
22438: LD_ADDR_VAR 0 7
22442: PUSH
22443: LD_VAR 0 8
22447: PUSH
22448: FOR_IN
22449: IFFALSE 22477
// if i [ 1 ] = b_ext_radio then
22451: LD_VAR 0 7
22455: PUSH
22456: LD_INT 1
22458: ARRAY
22459: PUSH
22460: LD_INT 22
22462: EQUAL
22463: IFFALSE 22475
// begin control := control_remote ;
22465: LD_ADDR_VAR 0 4
22469: PUSH
22470: LD_INT 2
22472: ST_TO_ADDR
// break ;
22473: GO 22477
// end ;
22475: GO 22448
22477: POP
22478: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_VAR 0 2
22488: PPUSH
22489: LD_VAR 0 3
22493: PPUSH
22494: LD_VAR 0 4
22498: PPUSH
22499: LD_VAR 0 5
22503: PPUSH
22504: CALL_OW 448
22508: IFFALSE 22543
// begin result := [ chassis , engine , control , weapon ] ;
22510: LD_ADDR_VAR 0 6
22514: PUSH
22515: LD_VAR 0 2
22519: PUSH
22520: LD_VAR 0 3
22524: PUSH
22525: LD_VAR 0 4
22529: PUSH
22530: LD_VAR 0 5
22534: PUSH
22535: EMPTY
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: ST_TO_ADDR
// exit ;
22541: GO 22955
// end ; _chassis := AvailableChassisList ( factory ) ;
22543: LD_ADDR_VAR 0 9
22547: PUSH
22548: LD_VAR 0 1
22552: PPUSH
22553: CALL_OW 475
22557: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22558: LD_ADDR_VAR 0 11
22562: PUSH
22563: LD_VAR 0 1
22567: PPUSH
22568: CALL_OW 476
22572: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22573: LD_ADDR_VAR 0 12
22577: PUSH
22578: LD_VAR 0 1
22582: PPUSH
22583: CALL_OW 477
22587: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22588: LD_ADDR_VAR 0 10
22592: PUSH
22593: LD_VAR 0 1
22597: PPUSH
22598: CALL_OW 478
22602: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22603: LD_VAR 0 9
22607: NOT
22608: PUSH
22609: LD_VAR 0 11
22613: NOT
22614: OR
22615: PUSH
22616: LD_VAR 0 12
22620: NOT
22621: OR
22622: PUSH
22623: LD_VAR 0 10
22627: NOT
22628: OR
22629: IFFALSE 22664
// begin result := [ chassis , engine , control , weapon ] ;
22631: LD_ADDR_VAR 0 6
22635: PUSH
22636: LD_VAR 0 2
22640: PUSH
22641: LD_VAR 0 3
22645: PUSH
22646: LD_VAR 0 4
22650: PUSH
22651: LD_VAR 0 5
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: LIST
22660: LIST
22661: ST_TO_ADDR
// exit ;
22662: GO 22955
// end ; if not chassis in _chassis then
22664: LD_VAR 0 2
22668: PUSH
22669: LD_VAR 0 9
22673: IN
22674: NOT
22675: IFFALSE 22701
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22677: LD_ADDR_VAR 0 2
22681: PUSH
22682: LD_VAR 0 9
22686: PUSH
22687: LD_INT 1
22689: PPUSH
22690: LD_VAR 0 9
22694: PPUSH
22695: CALL_OW 12
22699: ARRAY
22700: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22701: LD_VAR 0 2
22705: PPUSH
22706: LD_VAR 0 3
22710: PPUSH
22711: CALL 22960 0 2
22715: NOT
22716: IFFALSE 22775
// repeat engine := _engine [ 1 ] ;
22718: LD_ADDR_VAR 0 3
22722: PUSH
22723: LD_VAR 0 11
22727: PUSH
22728: LD_INT 1
22730: ARRAY
22731: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22732: LD_ADDR_VAR 0 11
22736: PUSH
22737: LD_VAR 0 11
22741: PPUSH
22742: LD_INT 1
22744: PPUSH
22745: CALL_OW 3
22749: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22750: LD_VAR 0 2
22754: PPUSH
22755: LD_VAR 0 3
22759: PPUSH
22760: CALL 22960 0 2
22764: PUSH
22765: LD_VAR 0 11
22769: PUSH
22770: EMPTY
22771: EQUAL
22772: OR
22773: IFFALSE 22718
// if not control in _control then
22775: LD_VAR 0 4
22779: PUSH
22780: LD_VAR 0 12
22784: IN
22785: NOT
22786: IFFALSE 22812
// control := _control [ rand ( 1 , _control ) ] ;
22788: LD_ADDR_VAR 0 4
22792: PUSH
22793: LD_VAR 0 12
22797: PUSH
22798: LD_INT 1
22800: PPUSH
22801: LD_VAR 0 12
22805: PPUSH
22806: CALL_OW 12
22810: ARRAY
22811: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22812: LD_VAR 0 2
22816: PPUSH
22817: LD_VAR 0 5
22821: PPUSH
22822: CALL 23180 0 2
22826: NOT
22827: IFFALSE 22886
// repeat weapon := _weapon [ 1 ] ;
22829: LD_ADDR_VAR 0 5
22833: PUSH
22834: LD_VAR 0 10
22838: PUSH
22839: LD_INT 1
22841: ARRAY
22842: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22843: LD_ADDR_VAR 0 10
22847: PUSH
22848: LD_VAR 0 10
22852: PPUSH
22853: LD_INT 1
22855: PPUSH
22856: CALL_OW 3
22860: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22861: LD_VAR 0 2
22865: PPUSH
22866: LD_VAR 0 5
22870: PPUSH
22871: CALL 23180 0 2
22875: PUSH
22876: LD_VAR 0 10
22880: PUSH
22881: EMPTY
22882: EQUAL
22883: OR
22884: IFFALSE 22829
// result := [ ] ;
22886: LD_ADDR_VAR 0 6
22890: PUSH
22891: EMPTY
22892: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22893: LD_VAR 0 1
22897: PPUSH
22898: LD_VAR 0 2
22902: PPUSH
22903: LD_VAR 0 3
22907: PPUSH
22908: LD_VAR 0 4
22912: PPUSH
22913: LD_VAR 0 5
22917: PPUSH
22918: CALL_OW 448
22922: IFFALSE 22955
// result := [ chassis , engine , control , weapon ] ;
22924: LD_ADDR_VAR 0 6
22928: PUSH
22929: LD_VAR 0 2
22933: PUSH
22934: LD_VAR 0 3
22938: PUSH
22939: LD_VAR 0 4
22943: PUSH
22944: LD_VAR 0 5
22948: PUSH
22949: EMPTY
22950: LIST
22951: LIST
22952: LIST
22953: LIST
22954: ST_TO_ADDR
// end ;
22955: LD_VAR 0 6
22959: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22960: LD_INT 0
22962: PPUSH
// if not chassis or not engine then
22963: LD_VAR 0 1
22967: NOT
22968: PUSH
22969: LD_VAR 0 2
22973: NOT
22974: OR
22975: IFFALSE 22979
// exit ;
22977: GO 23175
// case engine of engine_solar :
22979: LD_VAR 0 2
22983: PUSH
22984: LD_INT 2
22986: DOUBLE
22987: EQUAL
22988: IFTRUE 22992
22990: GO 23030
22992: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22993: LD_ADDR_VAR 0 3
22997: PUSH
22998: LD_INT 11
23000: PUSH
23001: LD_INT 12
23003: PUSH
23004: LD_INT 13
23006: PUSH
23007: LD_INT 14
23009: PUSH
23010: LD_INT 1
23012: PUSH
23013: LD_INT 2
23015: PUSH
23016: LD_INT 3
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: LIST
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: ST_TO_ADDR
23028: GO 23159
23030: LD_INT 1
23032: DOUBLE
23033: EQUAL
23034: IFTRUE 23038
23036: GO 23100
23038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23039: LD_ADDR_VAR 0 3
23043: PUSH
23044: LD_INT 11
23046: PUSH
23047: LD_INT 12
23049: PUSH
23050: LD_INT 13
23052: PUSH
23053: LD_INT 14
23055: PUSH
23056: LD_INT 1
23058: PUSH
23059: LD_INT 2
23061: PUSH
23062: LD_INT 3
23064: PUSH
23065: LD_INT 4
23067: PUSH
23068: LD_INT 5
23070: PUSH
23071: LD_INT 21
23073: PUSH
23074: LD_INT 23
23076: PUSH
23077: LD_INT 22
23079: PUSH
23080: LD_INT 24
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: LIST
23087: LIST
23088: LIST
23089: LIST
23090: LIST
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: LIST
23096: LIST
23097: ST_TO_ADDR
23098: GO 23159
23100: LD_INT 3
23102: DOUBLE
23103: EQUAL
23104: IFTRUE 23108
23106: GO 23158
23108: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23109: LD_ADDR_VAR 0 3
23113: PUSH
23114: LD_INT 13
23116: PUSH
23117: LD_INT 14
23119: PUSH
23120: LD_INT 2
23122: PUSH
23123: LD_INT 3
23125: PUSH
23126: LD_INT 4
23128: PUSH
23129: LD_INT 5
23131: PUSH
23132: LD_INT 21
23134: PUSH
23135: LD_INT 22
23137: PUSH
23138: LD_INT 23
23140: PUSH
23141: LD_INT 24
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: LIST
23148: LIST
23149: LIST
23150: LIST
23151: LIST
23152: LIST
23153: LIST
23154: LIST
23155: ST_TO_ADDR
23156: GO 23159
23158: POP
// result := ( chassis in result ) ;
23159: LD_ADDR_VAR 0 3
23163: PUSH
23164: LD_VAR 0 1
23168: PUSH
23169: LD_VAR 0 3
23173: IN
23174: ST_TO_ADDR
// end ;
23175: LD_VAR 0 3
23179: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23180: LD_INT 0
23182: PPUSH
// if not chassis or not weapon then
23183: LD_VAR 0 1
23187: NOT
23188: PUSH
23189: LD_VAR 0 2
23193: NOT
23194: OR
23195: IFFALSE 23199
// exit ;
23197: GO 24259
// case weapon of us_machine_gun :
23199: LD_VAR 0 2
23203: PUSH
23204: LD_INT 2
23206: DOUBLE
23207: EQUAL
23208: IFTRUE 23212
23210: GO 23242
23212: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23213: LD_ADDR_VAR 0 3
23217: PUSH
23218: LD_INT 1
23220: PUSH
23221: LD_INT 2
23223: PUSH
23224: LD_INT 3
23226: PUSH
23227: LD_INT 4
23229: PUSH
23230: LD_INT 5
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: LIST
23239: ST_TO_ADDR
23240: GO 24243
23242: LD_INT 3
23244: DOUBLE
23245: EQUAL
23246: IFTRUE 23250
23248: GO 23280
23250: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23251: LD_ADDR_VAR 0 3
23255: PUSH
23256: LD_INT 1
23258: PUSH
23259: LD_INT 2
23261: PUSH
23262: LD_INT 3
23264: PUSH
23265: LD_INT 4
23267: PUSH
23268: LD_INT 5
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: LIST
23275: LIST
23276: LIST
23277: ST_TO_ADDR
23278: GO 24243
23280: LD_INT 11
23282: DOUBLE
23283: EQUAL
23284: IFTRUE 23288
23286: GO 23318
23288: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23289: LD_ADDR_VAR 0 3
23293: PUSH
23294: LD_INT 1
23296: PUSH
23297: LD_INT 2
23299: PUSH
23300: LD_INT 3
23302: PUSH
23303: LD_INT 4
23305: PUSH
23306: LD_INT 5
23308: PUSH
23309: EMPTY
23310: LIST
23311: LIST
23312: LIST
23313: LIST
23314: LIST
23315: ST_TO_ADDR
23316: GO 24243
23318: LD_INT 4
23320: DOUBLE
23321: EQUAL
23322: IFTRUE 23326
23324: GO 23352
23326: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23327: LD_ADDR_VAR 0 3
23331: PUSH
23332: LD_INT 2
23334: PUSH
23335: LD_INT 3
23337: PUSH
23338: LD_INT 4
23340: PUSH
23341: LD_INT 5
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: LIST
23348: LIST
23349: ST_TO_ADDR
23350: GO 24243
23352: LD_INT 5
23354: DOUBLE
23355: EQUAL
23356: IFTRUE 23360
23358: GO 23386
23360: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23361: LD_ADDR_VAR 0 3
23365: PUSH
23366: LD_INT 2
23368: PUSH
23369: LD_INT 3
23371: PUSH
23372: LD_INT 4
23374: PUSH
23375: LD_INT 5
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: LIST
23382: LIST
23383: ST_TO_ADDR
23384: GO 24243
23386: LD_INT 9
23388: DOUBLE
23389: EQUAL
23390: IFTRUE 23394
23392: GO 23420
23394: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23395: LD_ADDR_VAR 0 3
23399: PUSH
23400: LD_INT 2
23402: PUSH
23403: LD_INT 3
23405: PUSH
23406: LD_INT 4
23408: PUSH
23409: LD_INT 5
23411: PUSH
23412: EMPTY
23413: LIST
23414: LIST
23415: LIST
23416: LIST
23417: ST_TO_ADDR
23418: GO 24243
23420: LD_INT 7
23422: DOUBLE
23423: EQUAL
23424: IFTRUE 23428
23426: GO 23454
23428: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23429: LD_ADDR_VAR 0 3
23433: PUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 3
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: LD_INT 5
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: ST_TO_ADDR
23452: GO 24243
23454: LD_INT 12
23456: DOUBLE
23457: EQUAL
23458: IFTRUE 23462
23460: GO 23488
23462: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23463: LD_ADDR_VAR 0 3
23467: PUSH
23468: LD_INT 2
23470: PUSH
23471: LD_INT 3
23473: PUSH
23474: LD_INT 4
23476: PUSH
23477: LD_INT 5
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: LIST
23484: LIST
23485: ST_TO_ADDR
23486: GO 24243
23488: LD_INT 13
23490: DOUBLE
23491: EQUAL
23492: IFTRUE 23496
23494: GO 23522
23496: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23497: LD_ADDR_VAR 0 3
23501: PUSH
23502: LD_INT 2
23504: PUSH
23505: LD_INT 3
23507: PUSH
23508: LD_INT 4
23510: PUSH
23511: LD_INT 5
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: LIST
23518: LIST
23519: ST_TO_ADDR
23520: GO 24243
23522: LD_INT 14
23524: DOUBLE
23525: EQUAL
23526: IFTRUE 23530
23528: GO 23548
23530: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23531: LD_ADDR_VAR 0 3
23535: PUSH
23536: LD_INT 4
23538: PUSH
23539: LD_INT 5
23541: PUSH
23542: EMPTY
23543: LIST
23544: LIST
23545: ST_TO_ADDR
23546: GO 24243
23548: LD_INT 6
23550: DOUBLE
23551: EQUAL
23552: IFTRUE 23556
23554: GO 23574
23556: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23557: LD_ADDR_VAR 0 3
23561: PUSH
23562: LD_INT 4
23564: PUSH
23565: LD_INT 5
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: ST_TO_ADDR
23572: GO 24243
23574: LD_INT 10
23576: DOUBLE
23577: EQUAL
23578: IFTRUE 23582
23580: GO 23600
23582: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23583: LD_ADDR_VAR 0 3
23587: PUSH
23588: LD_INT 4
23590: PUSH
23591: LD_INT 5
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: ST_TO_ADDR
23598: GO 24243
23600: LD_INT 22
23602: DOUBLE
23603: EQUAL
23604: IFTRUE 23608
23606: GO 23634
23608: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23609: LD_ADDR_VAR 0 3
23613: PUSH
23614: LD_INT 11
23616: PUSH
23617: LD_INT 12
23619: PUSH
23620: LD_INT 13
23622: PUSH
23623: LD_INT 14
23625: PUSH
23626: EMPTY
23627: LIST
23628: LIST
23629: LIST
23630: LIST
23631: ST_TO_ADDR
23632: GO 24243
23634: LD_INT 23
23636: DOUBLE
23637: EQUAL
23638: IFTRUE 23642
23640: GO 23668
23642: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23643: LD_ADDR_VAR 0 3
23647: PUSH
23648: LD_INT 11
23650: PUSH
23651: LD_INT 12
23653: PUSH
23654: LD_INT 13
23656: PUSH
23657: LD_INT 14
23659: PUSH
23660: EMPTY
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: ST_TO_ADDR
23666: GO 24243
23668: LD_INT 24
23670: DOUBLE
23671: EQUAL
23672: IFTRUE 23676
23674: GO 23702
23676: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23677: LD_ADDR_VAR 0 3
23681: PUSH
23682: LD_INT 11
23684: PUSH
23685: LD_INT 12
23687: PUSH
23688: LD_INT 13
23690: PUSH
23691: LD_INT 14
23693: PUSH
23694: EMPTY
23695: LIST
23696: LIST
23697: LIST
23698: LIST
23699: ST_TO_ADDR
23700: GO 24243
23702: LD_INT 30
23704: DOUBLE
23705: EQUAL
23706: IFTRUE 23710
23708: GO 23736
23710: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23711: LD_ADDR_VAR 0 3
23715: PUSH
23716: LD_INT 11
23718: PUSH
23719: LD_INT 12
23721: PUSH
23722: LD_INT 13
23724: PUSH
23725: LD_INT 14
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: LIST
23732: LIST
23733: ST_TO_ADDR
23734: GO 24243
23736: LD_INT 25
23738: DOUBLE
23739: EQUAL
23740: IFTRUE 23744
23742: GO 23762
23744: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23745: LD_ADDR_VAR 0 3
23749: PUSH
23750: LD_INT 13
23752: PUSH
23753: LD_INT 14
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: ST_TO_ADDR
23760: GO 24243
23762: LD_INT 27
23764: DOUBLE
23765: EQUAL
23766: IFTRUE 23770
23768: GO 23788
23770: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23771: LD_ADDR_VAR 0 3
23775: PUSH
23776: LD_INT 13
23778: PUSH
23779: LD_INT 14
23781: PUSH
23782: EMPTY
23783: LIST
23784: LIST
23785: ST_TO_ADDR
23786: GO 24243
23788: LD_INT 92
23790: DOUBLE
23791: EQUAL
23792: IFTRUE 23796
23794: GO 23822
23796: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23797: LD_ADDR_VAR 0 3
23801: PUSH
23802: LD_INT 11
23804: PUSH
23805: LD_INT 12
23807: PUSH
23808: LD_INT 13
23810: PUSH
23811: LD_INT 14
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: LIST
23818: LIST
23819: ST_TO_ADDR
23820: GO 24243
23822: LD_INT 28
23824: DOUBLE
23825: EQUAL
23826: IFTRUE 23830
23828: GO 23848
23830: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23831: LD_ADDR_VAR 0 3
23835: PUSH
23836: LD_INT 13
23838: PUSH
23839: LD_INT 14
23841: PUSH
23842: EMPTY
23843: LIST
23844: LIST
23845: ST_TO_ADDR
23846: GO 24243
23848: LD_INT 29
23850: DOUBLE
23851: EQUAL
23852: IFTRUE 23856
23854: GO 23874
23856: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23857: LD_ADDR_VAR 0 3
23861: PUSH
23862: LD_INT 13
23864: PUSH
23865: LD_INT 14
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: ST_TO_ADDR
23872: GO 24243
23874: LD_INT 31
23876: DOUBLE
23877: EQUAL
23878: IFTRUE 23882
23880: GO 23900
23882: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23883: LD_ADDR_VAR 0 3
23887: PUSH
23888: LD_INT 13
23890: PUSH
23891: LD_INT 14
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: ST_TO_ADDR
23898: GO 24243
23900: LD_INT 26
23902: DOUBLE
23903: EQUAL
23904: IFTRUE 23908
23906: GO 23926
23908: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23909: LD_ADDR_VAR 0 3
23913: PUSH
23914: LD_INT 13
23916: PUSH
23917: LD_INT 14
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: ST_TO_ADDR
23924: GO 24243
23926: LD_INT 42
23928: DOUBLE
23929: EQUAL
23930: IFTRUE 23934
23932: GO 23960
23934: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23935: LD_ADDR_VAR 0 3
23939: PUSH
23940: LD_INT 21
23942: PUSH
23943: LD_INT 22
23945: PUSH
23946: LD_INT 23
23948: PUSH
23949: LD_INT 24
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: LIST
23956: LIST
23957: ST_TO_ADDR
23958: GO 24243
23960: LD_INT 43
23962: DOUBLE
23963: EQUAL
23964: IFTRUE 23968
23966: GO 23994
23968: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23969: LD_ADDR_VAR 0 3
23973: PUSH
23974: LD_INT 21
23976: PUSH
23977: LD_INT 22
23979: PUSH
23980: LD_INT 23
23982: PUSH
23983: LD_INT 24
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: LIST
23990: LIST
23991: ST_TO_ADDR
23992: GO 24243
23994: LD_INT 44
23996: DOUBLE
23997: EQUAL
23998: IFTRUE 24002
24000: GO 24028
24002: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24003: LD_ADDR_VAR 0 3
24007: PUSH
24008: LD_INT 21
24010: PUSH
24011: LD_INT 22
24013: PUSH
24014: LD_INT 23
24016: PUSH
24017: LD_INT 24
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: LIST
24024: LIST
24025: ST_TO_ADDR
24026: GO 24243
24028: LD_INT 45
24030: DOUBLE
24031: EQUAL
24032: IFTRUE 24036
24034: GO 24062
24036: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24037: LD_ADDR_VAR 0 3
24041: PUSH
24042: LD_INT 21
24044: PUSH
24045: LD_INT 22
24047: PUSH
24048: LD_INT 23
24050: PUSH
24051: LD_INT 24
24053: PUSH
24054: EMPTY
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: ST_TO_ADDR
24060: GO 24243
24062: LD_INT 49
24064: DOUBLE
24065: EQUAL
24066: IFTRUE 24070
24068: GO 24096
24070: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24071: LD_ADDR_VAR 0 3
24075: PUSH
24076: LD_INT 21
24078: PUSH
24079: LD_INT 22
24081: PUSH
24082: LD_INT 23
24084: PUSH
24085: LD_INT 24
24087: PUSH
24088: EMPTY
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: ST_TO_ADDR
24094: GO 24243
24096: LD_INT 51
24098: DOUBLE
24099: EQUAL
24100: IFTRUE 24104
24102: GO 24130
24104: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24105: LD_ADDR_VAR 0 3
24109: PUSH
24110: LD_INT 21
24112: PUSH
24113: LD_INT 22
24115: PUSH
24116: LD_INT 23
24118: PUSH
24119: LD_INT 24
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: ST_TO_ADDR
24128: GO 24243
24130: LD_INT 52
24132: DOUBLE
24133: EQUAL
24134: IFTRUE 24138
24136: GO 24164
24138: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24139: LD_ADDR_VAR 0 3
24143: PUSH
24144: LD_INT 21
24146: PUSH
24147: LD_INT 22
24149: PUSH
24150: LD_INT 23
24152: PUSH
24153: LD_INT 24
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: LIST
24160: LIST
24161: ST_TO_ADDR
24162: GO 24243
24164: LD_INT 53
24166: DOUBLE
24167: EQUAL
24168: IFTRUE 24172
24170: GO 24190
24172: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24173: LD_ADDR_VAR 0 3
24177: PUSH
24178: LD_INT 23
24180: PUSH
24181: LD_INT 24
24183: PUSH
24184: EMPTY
24185: LIST
24186: LIST
24187: ST_TO_ADDR
24188: GO 24243
24190: LD_INT 46
24192: DOUBLE
24193: EQUAL
24194: IFTRUE 24198
24196: GO 24216
24198: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24199: LD_ADDR_VAR 0 3
24203: PUSH
24204: LD_INT 23
24206: PUSH
24207: LD_INT 24
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: ST_TO_ADDR
24214: GO 24243
24216: LD_INT 47
24218: DOUBLE
24219: EQUAL
24220: IFTRUE 24224
24222: GO 24242
24224: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24225: LD_ADDR_VAR 0 3
24229: PUSH
24230: LD_INT 23
24232: PUSH
24233: LD_INT 24
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: ST_TO_ADDR
24240: GO 24243
24242: POP
// result := ( chassis in result ) ;
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 1
24252: PUSH
24253: LD_VAR 0 3
24257: IN
24258: ST_TO_ADDR
// end ;
24259: LD_VAR 0 3
24263: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24264: LD_INT 0
24266: PPUSH
24267: PPUSH
24268: PPUSH
24269: PPUSH
24270: PPUSH
24271: PPUSH
24272: PPUSH
// result := array ;
24273: LD_ADDR_VAR 0 5
24277: PUSH
24278: LD_VAR 0 1
24282: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24283: LD_VAR 0 1
24287: NOT
24288: PUSH
24289: LD_VAR 0 2
24293: NOT
24294: OR
24295: PUSH
24296: LD_VAR 0 3
24300: NOT
24301: OR
24302: PUSH
24303: LD_VAR 0 2
24307: PUSH
24308: LD_VAR 0 1
24312: GREATER
24313: OR
24314: PUSH
24315: LD_VAR 0 3
24319: PUSH
24320: LD_VAR 0 1
24324: GREATER
24325: OR
24326: IFFALSE 24330
// exit ;
24328: GO 24626
// if direction then
24330: LD_VAR 0 4
24334: IFFALSE 24398
// begin d := 1 ;
24336: LD_ADDR_VAR 0 9
24340: PUSH
24341: LD_INT 1
24343: ST_TO_ADDR
// if i_from > i_to then
24344: LD_VAR 0 2
24348: PUSH
24349: LD_VAR 0 3
24353: GREATER
24354: IFFALSE 24380
// length := ( array - i_from ) + i_to else
24356: LD_ADDR_VAR 0 11
24360: PUSH
24361: LD_VAR 0 1
24365: PUSH
24366: LD_VAR 0 2
24370: MINUS
24371: PUSH
24372: LD_VAR 0 3
24376: PLUS
24377: ST_TO_ADDR
24378: GO 24396
// length := i_to - i_from ;
24380: LD_ADDR_VAR 0 11
24384: PUSH
24385: LD_VAR 0 3
24389: PUSH
24390: LD_VAR 0 2
24394: MINUS
24395: ST_TO_ADDR
// end else
24396: GO 24459
// begin d := - 1 ;
24398: LD_ADDR_VAR 0 9
24402: PUSH
24403: LD_INT 1
24405: NEG
24406: ST_TO_ADDR
// if i_from > i_to then
24407: LD_VAR 0 2
24411: PUSH
24412: LD_VAR 0 3
24416: GREATER
24417: IFFALSE 24437
// length := i_from - i_to else
24419: LD_ADDR_VAR 0 11
24423: PUSH
24424: LD_VAR 0 2
24428: PUSH
24429: LD_VAR 0 3
24433: MINUS
24434: ST_TO_ADDR
24435: GO 24459
// length := ( array - i_to ) + i_from ;
24437: LD_ADDR_VAR 0 11
24441: PUSH
24442: LD_VAR 0 1
24446: PUSH
24447: LD_VAR 0 3
24451: MINUS
24452: PUSH
24453: LD_VAR 0 2
24457: PLUS
24458: ST_TO_ADDR
// end ; if not length then
24459: LD_VAR 0 11
24463: NOT
24464: IFFALSE 24468
// exit ;
24466: GO 24626
// tmp := array ;
24468: LD_ADDR_VAR 0 10
24472: PUSH
24473: LD_VAR 0 1
24477: ST_TO_ADDR
// for i = 1 to length do
24478: LD_ADDR_VAR 0 6
24482: PUSH
24483: DOUBLE
24484: LD_INT 1
24486: DEC
24487: ST_TO_ADDR
24488: LD_VAR 0 11
24492: PUSH
24493: FOR_TO
24494: IFFALSE 24614
// begin for j = 1 to array do
24496: LD_ADDR_VAR 0 7
24500: PUSH
24501: DOUBLE
24502: LD_INT 1
24504: DEC
24505: ST_TO_ADDR
24506: LD_VAR 0 1
24510: PUSH
24511: FOR_TO
24512: IFFALSE 24600
// begin k := j + d ;
24514: LD_ADDR_VAR 0 8
24518: PUSH
24519: LD_VAR 0 7
24523: PUSH
24524: LD_VAR 0 9
24528: PLUS
24529: ST_TO_ADDR
// if k > array then
24530: LD_VAR 0 8
24534: PUSH
24535: LD_VAR 0 1
24539: GREATER
24540: IFFALSE 24550
// k := 1 ;
24542: LD_ADDR_VAR 0 8
24546: PUSH
24547: LD_INT 1
24549: ST_TO_ADDR
// if not k then
24550: LD_VAR 0 8
24554: NOT
24555: IFFALSE 24567
// k := array ;
24557: LD_ADDR_VAR 0 8
24561: PUSH
24562: LD_VAR 0 1
24566: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24567: LD_ADDR_VAR 0 10
24571: PUSH
24572: LD_VAR 0 10
24576: PPUSH
24577: LD_VAR 0 8
24581: PPUSH
24582: LD_VAR 0 1
24586: PUSH
24587: LD_VAR 0 7
24591: ARRAY
24592: PPUSH
24593: CALL_OW 1
24597: ST_TO_ADDR
// end ;
24598: GO 24511
24600: POP
24601: POP
// array := tmp ;
24602: LD_ADDR_VAR 0 1
24606: PUSH
24607: LD_VAR 0 10
24611: ST_TO_ADDR
// end ;
24612: GO 24493
24614: POP
24615: POP
// result := array ;
24616: LD_ADDR_VAR 0 5
24620: PUSH
24621: LD_VAR 0 1
24625: ST_TO_ADDR
// end ;
24626: LD_VAR 0 5
24630: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24631: LD_INT 0
24633: PPUSH
24634: PPUSH
// result := 0 ;
24635: LD_ADDR_VAR 0 3
24639: PUSH
24640: LD_INT 0
24642: ST_TO_ADDR
// if not array or not value in array then
24643: LD_VAR 0 1
24647: NOT
24648: PUSH
24649: LD_VAR 0 2
24653: PUSH
24654: LD_VAR 0 1
24658: IN
24659: NOT
24660: OR
24661: IFFALSE 24665
// exit ;
24663: GO 24719
// for i = 1 to array do
24665: LD_ADDR_VAR 0 4
24669: PUSH
24670: DOUBLE
24671: LD_INT 1
24673: DEC
24674: ST_TO_ADDR
24675: LD_VAR 0 1
24679: PUSH
24680: FOR_TO
24681: IFFALSE 24717
// if value = array [ i ] then
24683: LD_VAR 0 2
24687: PUSH
24688: LD_VAR 0 1
24692: PUSH
24693: LD_VAR 0 4
24697: ARRAY
24698: EQUAL
24699: IFFALSE 24715
// begin result := i ;
24701: LD_ADDR_VAR 0 3
24705: PUSH
24706: LD_VAR 0 4
24710: ST_TO_ADDR
// exit ;
24711: POP
24712: POP
24713: GO 24719
// end ;
24715: GO 24680
24717: POP
24718: POP
// end ;
24719: LD_VAR 0 3
24723: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24724: LD_INT 0
24726: PPUSH
// vc_chassis := chassis ;
24727: LD_ADDR_OWVAR 37
24731: PUSH
24732: LD_VAR 0 1
24736: ST_TO_ADDR
// vc_engine := engine ;
24737: LD_ADDR_OWVAR 39
24741: PUSH
24742: LD_VAR 0 2
24746: ST_TO_ADDR
// vc_control := control ;
24747: LD_ADDR_OWVAR 38
24751: PUSH
24752: LD_VAR 0 3
24756: ST_TO_ADDR
// vc_weapon := weapon ;
24757: LD_ADDR_OWVAR 40
24761: PUSH
24762: LD_VAR 0 4
24766: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24767: LD_ADDR_OWVAR 41
24771: PUSH
24772: LD_VAR 0 5
24776: ST_TO_ADDR
// end ;
24777: LD_VAR 0 6
24781: RET
// export function WantPlant ( unit ) ; var task ; begin
24782: LD_INT 0
24784: PPUSH
24785: PPUSH
// result := false ;
24786: LD_ADDR_VAR 0 2
24790: PUSH
24791: LD_INT 0
24793: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24794: LD_ADDR_VAR 0 3
24798: PUSH
24799: LD_VAR 0 1
24803: PPUSH
24804: CALL_OW 437
24808: ST_TO_ADDR
// if task then
24809: LD_VAR 0 3
24813: IFFALSE 24841
// if task [ 1 ] [ 1 ] = p then
24815: LD_VAR 0 3
24819: PUSH
24820: LD_INT 1
24822: ARRAY
24823: PUSH
24824: LD_INT 1
24826: ARRAY
24827: PUSH
24828: LD_STRING p
24830: EQUAL
24831: IFFALSE 24841
// result := true ;
24833: LD_ADDR_VAR 0 2
24837: PUSH
24838: LD_INT 1
24840: ST_TO_ADDR
// end ;
24841: LD_VAR 0 2
24845: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24846: LD_INT 0
24848: PPUSH
24849: PPUSH
24850: PPUSH
24851: PPUSH
// if pos < 1 then
24852: LD_VAR 0 2
24856: PUSH
24857: LD_INT 1
24859: LESS
24860: IFFALSE 24864
// exit ;
24862: GO 25167
// if pos = 1 then
24864: LD_VAR 0 2
24868: PUSH
24869: LD_INT 1
24871: EQUAL
24872: IFFALSE 24905
// result := Replace ( arr , pos [ 1 ] , value ) else
24874: LD_ADDR_VAR 0 4
24878: PUSH
24879: LD_VAR 0 1
24883: PPUSH
24884: LD_VAR 0 2
24888: PUSH
24889: LD_INT 1
24891: ARRAY
24892: PPUSH
24893: LD_VAR 0 3
24897: PPUSH
24898: CALL_OW 1
24902: ST_TO_ADDR
24903: GO 25167
// begin tmp := arr ;
24905: LD_ADDR_VAR 0 6
24909: PUSH
24910: LD_VAR 0 1
24914: ST_TO_ADDR
// s_arr := [ tmp ] ;
24915: LD_ADDR_VAR 0 7
24919: PUSH
24920: LD_VAR 0 6
24924: PUSH
24925: EMPTY
24926: LIST
24927: ST_TO_ADDR
// for i = 1 to pos - 1 do
24928: LD_ADDR_VAR 0 5
24932: PUSH
24933: DOUBLE
24934: LD_INT 1
24936: DEC
24937: ST_TO_ADDR
24938: LD_VAR 0 2
24942: PUSH
24943: LD_INT 1
24945: MINUS
24946: PUSH
24947: FOR_TO
24948: IFFALSE 24993
// begin tmp := tmp [ pos [ i ] ] ;
24950: LD_ADDR_VAR 0 6
24954: PUSH
24955: LD_VAR 0 6
24959: PUSH
24960: LD_VAR 0 2
24964: PUSH
24965: LD_VAR 0 5
24969: ARRAY
24970: ARRAY
24971: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24972: LD_ADDR_VAR 0 7
24976: PUSH
24977: LD_VAR 0 7
24981: PUSH
24982: LD_VAR 0 6
24986: PUSH
24987: EMPTY
24988: LIST
24989: ADD
24990: ST_TO_ADDR
// end ;
24991: GO 24947
24993: POP
24994: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24995: LD_ADDR_VAR 0 6
24999: PUSH
25000: LD_VAR 0 6
25004: PPUSH
25005: LD_VAR 0 2
25009: PUSH
25010: LD_VAR 0 2
25014: ARRAY
25015: PPUSH
25016: LD_VAR 0 3
25020: PPUSH
25021: CALL_OW 1
25025: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25026: LD_ADDR_VAR 0 7
25030: PUSH
25031: LD_VAR 0 7
25035: PPUSH
25036: LD_VAR 0 7
25040: PPUSH
25041: LD_VAR 0 6
25045: PPUSH
25046: CALL_OW 1
25050: ST_TO_ADDR
// for i = s_arr downto 2 do
25051: LD_ADDR_VAR 0 5
25055: PUSH
25056: DOUBLE
25057: LD_VAR 0 7
25061: INC
25062: ST_TO_ADDR
25063: LD_INT 2
25065: PUSH
25066: FOR_DOWNTO
25067: IFFALSE 25151
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25069: LD_ADDR_VAR 0 6
25073: PUSH
25074: LD_VAR 0 7
25078: PUSH
25079: LD_VAR 0 5
25083: PUSH
25084: LD_INT 1
25086: MINUS
25087: ARRAY
25088: PPUSH
25089: LD_VAR 0 2
25093: PUSH
25094: LD_VAR 0 5
25098: PUSH
25099: LD_INT 1
25101: MINUS
25102: ARRAY
25103: PPUSH
25104: LD_VAR 0 7
25108: PUSH
25109: LD_VAR 0 5
25113: ARRAY
25114: PPUSH
25115: CALL_OW 1
25119: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25120: LD_ADDR_VAR 0 7
25124: PUSH
25125: LD_VAR 0 7
25129: PPUSH
25130: LD_VAR 0 5
25134: PUSH
25135: LD_INT 1
25137: MINUS
25138: PPUSH
25139: LD_VAR 0 6
25143: PPUSH
25144: CALL_OW 1
25148: ST_TO_ADDR
// end ;
25149: GO 25066
25151: POP
25152: POP
// result := s_arr [ 1 ] ;
25153: LD_ADDR_VAR 0 4
25157: PUSH
25158: LD_VAR 0 7
25162: PUSH
25163: LD_INT 1
25165: ARRAY
25166: ST_TO_ADDR
// end ; end ;
25167: LD_VAR 0 4
25171: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25172: LD_INT 0
25174: PPUSH
25175: PPUSH
// if not list then
25176: LD_VAR 0 1
25180: NOT
25181: IFFALSE 25185
// exit ;
25183: GO 25276
// i := list [ pos1 ] ;
25185: LD_ADDR_VAR 0 5
25189: PUSH
25190: LD_VAR 0 1
25194: PUSH
25195: LD_VAR 0 2
25199: ARRAY
25200: ST_TO_ADDR
// if not i then
25201: LD_VAR 0 5
25205: NOT
25206: IFFALSE 25210
// exit ;
25208: GO 25276
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_VAR 0 1
25219: PPUSH
25220: LD_VAR 0 2
25224: PPUSH
25225: LD_VAR 0 1
25229: PUSH
25230: LD_VAR 0 3
25234: ARRAY
25235: PPUSH
25236: CALL_OW 1
25240: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25241: LD_ADDR_VAR 0 1
25245: PUSH
25246: LD_VAR 0 1
25250: PPUSH
25251: LD_VAR 0 3
25255: PPUSH
25256: LD_VAR 0 5
25260: PPUSH
25261: CALL_OW 1
25265: ST_TO_ADDR
// result := list ;
25266: LD_ADDR_VAR 0 4
25270: PUSH
25271: LD_VAR 0 1
25275: ST_TO_ADDR
// end ;
25276: LD_VAR 0 4
25280: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25281: LD_INT 0
25283: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25284: LD_ADDR_VAR 0 5
25288: PUSH
25289: LD_VAR 0 1
25293: PPUSH
25294: CALL_OW 250
25298: PPUSH
25299: LD_VAR 0 1
25303: PPUSH
25304: CALL_OW 251
25308: PPUSH
25309: LD_VAR 0 2
25313: PPUSH
25314: LD_VAR 0 3
25318: PPUSH
25319: LD_VAR 0 4
25323: PPUSH
25324: CALL 25702 0 5
25328: ST_TO_ADDR
// end ;
25329: LD_VAR 0 5
25333: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
25334: LD_INT 0
25336: PPUSH
25337: PPUSH
25338: PPUSH
25339: PPUSH
// if not list or not unit then
25340: LD_VAR 0 2
25344: NOT
25345: PUSH
25346: LD_VAR 0 1
25350: NOT
25351: OR
25352: IFFALSE 25356
// exit ;
25354: GO 25697
// result := [ ] ;
25356: LD_ADDR_VAR 0 5
25360: PUSH
25361: EMPTY
25362: ST_TO_ADDR
// for i in list do
25363: LD_ADDR_VAR 0 6
25367: PUSH
25368: LD_VAR 0 2
25372: PUSH
25373: FOR_IN
25374: IFFALSE 25592
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
25376: LD_ADDR_VAR 0 8
25380: PUSH
25381: LD_VAR 0 1
25385: PPUSH
25386: LD_VAR 0 6
25390: PUSH
25391: LD_INT 1
25393: ARRAY
25394: PPUSH
25395: LD_VAR 0 6
25399: PUSH
25400: LD_INT 2
25402: ARRAY
25403: PPUSH
25404: CALL_OW 297
25408: ST_TO_ADDR
// if not Count ( result ) then
25409: LD_VAR 0 5
25413: PPUSH
25414: CALL 21986 0 1
25418: NOT
25419: IFFALSE 25452
// begin result := Join ( result , [ i , tmp ] ) ;
25421: LD_ADDR_VAR 0 5
25425: PUSH
25426: LD_VAR 0 5
25430: PPUSH
25431: LD_VAR 0 6
25435: PUSH
25436: LD_VAR 0 8
25440: PUSH
25441: EMPTY
25442: LIST
25443: LIST
25444: PPUSH
25445: CALL 57586 0 2
25449: ST_TO_ADDR
// continue ;
25450: GO 25373
// end ; if result [ result ] [ 2 ] <= tmp then
25452: LD_VAR 0 5
25456: PUSH
25457: LD_VAR 0 5
25461: ARRAY
25462: PUSH
25463: LD_INT 2
25465: ARRAY
25466: PUSH
25467: LD_VAR 0 8
25471: LESSEQUAL
25472: IFFALSE 25505
// result := Join ( result , [ i , tmp ] ) else
25474: LD_ADDR_VAR 0 5
25478: PUSH
25479: LD_VAR 0 5
25483: PPUSH
25484: LD_VAR 0 6
25488: PUSH
25489: LD_VAR 0 8
25493: PUSH
25494: EMPTY
25495: LIST
25496: LIST
25497: PPUSH
25498: CALL 57586 0 2
25502: ST_TO_ADDR
25503: GO 25590
// begin for j := 1 to Count ( result ) do
25505: LD_ADDR_VAR 0 7
25509: PUSH
25510: DOUBLE
25511: LD_INT 1
25513: DEC
25514: ST_TO_ADDR
25515: LD_VAR 0 5
25519: PPUSH
25520: CALL 21986 0 1
25524: PUSH
25525: FOR_TO
25526: IFFALSE 25588
// begin if tmp < result [ j ] [ 2 ] then
25528: LD_VAR 0 8
25532: PUSH
25533: LD_VAR 0 5
25537: PUSH
25538: LD_VAR 0 7
25542: ARRAY
25543: PUSH
25544: LD_INT 2
25546: ARRAY
25547: LESS
25548: IFFALSE 25586
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25550: LD_ADDR_VAR 0 5
25554: PUSH
25555: LD_VAR 0 5
25559: PPUSH
25560: LD_VAR 0 7
25564: PPUSH
25565: LD_VAR 0 6
25569: PUSH
25570: LD_VAR 0 8
25574: PUSH
25575: EMPTY
25576: LIST
25577: LIST
25578: PPUSH
25579: CALL_OW 2
25583: ST_TO_ADDR
// break ;
25584: GO 25588
// end ; end ;
25586: GO 25525
25588: POP
25589: POP
// end ; end ;
25590: GO 25373
25592: POP
25593: POP
// if result and not asc then
25594: LD_VAR 0 5
25598: PUSH
25599: LD_VAR 0 3
25603: NOT
25604: AND
25605: IFFALSE 25622
// result := ReverseArray ( result ) ;
25607: LD_ADDR_VAR 0 5
25611: PUSH
25612: LD_VAR 0 5
25616: PPUSH
25617: CALL 52862 0 1
25621: ST_TO_ADDR
// tmp := [ ] ;
25622: LD_ADDR_VAR 0 8
25626: PUSH
25627: EMPTY
25628: ST_TO_ADDR
// if mode then
25629: LD_VAR 0 4
25633: IFFALSE 25697
// begin for i := 1 to result do
25635: LD_ADDR_VAR 0 6
25639: PUSH
25640: DOUBLE
25641: LD_INT 1
25643: DEC
25644: ST_TO_ADDR
25645: LD_VAR 0 5
25649: PUSH
25650: FOR_TO
25651: IFFALSE 25685
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
25653: LD_ADDR_VAR 0 8
25657: PUSH
25658: LD_VAR 0 8
25662: PPUSH
25663: LD_VAR 0 5
25667: PUSH
25668: LD_VAR 0 6
25672: ARRAY
25673: PUSH
25674: LD_INT 1
25676: ARRAY
25677: PPUSH
25678: CALL 57586 0 2
25682: ST_TO_ADDR
25683: GO 25650
25685: POP
25686: POP
// result := tmp ;
25687: LD_ADDR_VAR 0 5
25691: PUSH
25692: LD_VAR 0 8
25696: ST_TO_ADDR
// end ; end ;
25697: LD_VAR 0 5
25701: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25702: LD_INT 0
25704: PPUSH
25705: PPUSH
25706: PPUSH
25707: PPUSH
// if not list then
25708: LD_VAR 0 3
25712: NOT
25713: IFFALSE 25717
// exit ;
25715: GO 26105
// result := [ ] ;
25717: LD_ADDR_VAR 0 6
25721: PUSH
25722: EMPTY
25723: ST_TO_ADDR
// for i in list do
25724: LD_ADDR_VAR 0 7
25728: PUSH
25729: LD_VAR 0 3
25733: PUSH
25734: FOR_IN
25735: IFFALSE 25937
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25737: LD_ADDR_VAR 0 9
25741: PUSH
25742: LD_VAR 0 7
25746: PPUSH
25747: LD_VAR 0 1
25751: PPUSH
25752: LD_VAR 0 2
25756: PPUSH
25757: CALL_OW 297
25761: ST_TO_ADDR
// if not result then
25762: LD_VAR 0 6
25766: NOT
25767: IFFALSE 25793
// result := [ [ i , tmp ] ] else
25769: LD_ADDR_VAR 0 6
25773: PUSH
25774: LD_VAR 0 7
25778: PUSH
25779: LD_VAR 0 9
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: PUSH
25788: EMPTY
25789: LIST
25790: ST_TO_ADDR
25791: GO 25935
// begin if result [ result ] [ 2 ] < tmp then
25793: LD_VAR 0 6
25797: PUSH
25798: LD_VAR 0 6
25802: ARRAY
25803: PUSH
25804: LD_INT 2
25806: ARRAY
25807: PUSH
25808: LD_VAR 0 9
25812: LESS
25813: IFFALSE 25855
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25815: LD_ADDR_VAR 0 6
25819: PUSH
25820: LD_VAR 0 6
25824: PPUSH
25825: LD_VAR 0 6
25829: PUSH
25830: LD_INT 1
25832: PLUS
25833: PPUSH
25834: LD_VAR 0 7
25838: PUSH
25839: LD_VAR 0 9
25843: PUSH
25844: EMPTY
25845: LIST
25846: LIST
25847: PPUSH
25848: CALL_OW 2
25852: ST_TO_ADDR
25853: GO 25935
// for j = 1 to result do
25855: LD_ADDR_VAR 0 8
25859: PUSH
25860: DOUBLE
25861: LD_INT 1
25863: DEC
25864: ST_TO_ADDR
25865: LD_VAR 0 6
25869: PUSH
25870: FOR_TO
25871: IFFALSE 25933
// begin if tmp < result [ j ] [ 2 ] then
25873: LD_VAR 0 9
25877: PUSH
25878: LD_VAR 0 6
25882: PUSH
25883: LD_VAR 0 8
25887: ARRAY
25888: PUSH
25889: LD_INT 2
25891: ARRAY
25892: LESS
25893: IFFALSE 25931
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25895: LD_ADDR_VAR 0 6
25899: PUSH
25900: LD_VAR 0 6
25904: PPUSH
25905: LD_VAR 0 8
25909: PPUSH
25910: LD_VAR 0 7
25914: PUSH
25915: LD_VAR 0 9
25919: PUSH
25920: EMPTY
25921: LIST
25922: LIST
25923: PPUSH
25924: CALL_OW 2
25928: ST_TO_ADDR
// break ;
25929: GO 25933
// end ; end ;
25931: GO 25870
25933: POP
25934: POP
// end ; end ;
25935: GO 25734
25937: POP
25938: POP
// if result and not asc then
25939: LD_VAR 0 6
25943: PUSH
25944: LD_VAR 0 4
25948: NOT
25949: AND
25950: IFFALSE 26025
// begin tmp := result ;
25952: LD_ADDR_VAR 0 9
25956: PUSH
25957: LD_VAR 0 6
25961: ST_TO_ADDR
// for i = tmp downto 1 do
25962: LD_ADDR_VAR 0 7
25966: PUSH
25967: DOUBLE
25968: LD_VAR 0 9
25972: INC
25973: ST_TO_ADDR
25974: LD_INT 1
25976: PUSH
25977: FOR_DOWNTO
25978: IFFALSE 26023
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25980: LD_ADDR_VAR 0 6
25984: PUSH
25985: LD_VAR 0 6
25989: PPUSH
25990: LD_VAR 0 9
25994: PUSH
25995: LD_VAR 0 7
25999: MINUS
26000: PUSH
26001: LD_INT 1
26003: PLUS
26004: PPUSH
26005: LD_VAR 0 9
26009: PUSH
26010: LD_VAR 0 7
26014: ARRAY
26015: PPUSH
26016: CALL_OW 1
26020: ST_TO_ADDR
26021: GO 25977
26023: POP
26024: POP
// end ; tmp := [ ] ;
26025: LD_ADDR_VAR 0 9
26029: PUSH
26030: EMPTY
26031: ST_TO_ADDR
// if mode then
26032: LD_VAR 0 5
26036: IFFALSE 26105
// begin for i = 1 to result do
26038: LD_ADDR_VAR 0 7
26042: PUSH
26043: DOUBLE
26044: LD_INT 1
26046: DEC
26047: ST_TO_ADDR
26048: LD_VAR 0 6
26052: PUSH
26053: FOR_TO
26054: IFFALSE 26093
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
26056: LD_ADDR_VAR 0 9
26060: PUSH
26061: LD_VAR 0 9
26065: PPUSH
26066: LD_VAR 0 7
26070: PPUSH
26071: LD_VAR 0 6
26075: PUSH
26076: LD_VAR 0 7
26080: ARRAY
26081: PUSH
26082: LD_INT 1
26084: ARRAY
26085: PPUSH
26086: CALL_OW 1
26090: ST_TO_ADDR
26091: GO 26053
26093: POP
26094: POP
// result := tmp ;
26095: LD_ADDR_VAR 0 6
26099: PUSH
26100: LD_VAR 0 9
26104: ST_TO_ADDR
// end ; end ;
26105: LD_VAR 0 6
26109: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
26110: LD_INT 0
26112: PPUSH
26113: PPUSH
26114: PPUSH
26115: PPUSH
26116: PPUSH
26117: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
26118: LD_ADDR_VAR 0 5
26122: PUSH
26123: LD_INT 0
26125: PUSH
26126: LD_INT 0
26128: PUSH
26129: LD_INT 0
26131: PUSH
26132: EMPTY
26133: PUSH
26134: EMPTY
26135: LIST
26136: LIST
26137: LIST
26138: LIST
26139: ST_TO_ADDR
// if not x or not y then
26140: LD_VAR 0 2
26144: NOT
26145: PUSH
26146: LD_VAR 0 3
26150: NOT
26151: OR
26152: IFFALSE 26156
// exit ;
26154: GO 27806
// if not range then
26156: LD_VAR 0 4
26160: NOT
26161: IFFALSE 26171
// range := 10 ;
26163: LD_ADDR_VAR 0 4
26167: PUSH
26168: LD_INT 10
26170: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
26171: LD_ADDR_VAR 0 8
26175: PUSH
26176: LD_INT 81
26178: PUSH
26179: LD_VAR 0 1
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 92
26190: PUSH
26191: LD_VAR 0 2
26195: PUSH
26196: LD_VAR 0 3
26200: PUSH
26201: LD_VAR 0 4
26205: PUSH
26206: EMPTY
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: PUSH
26212: LD_INT 3
26214: PUSH
26215: LD_INT 21
26217: PUSH
26218: LD_INT 3
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: PUSH
26225: EMPTY
26226: LIST
26227: LIST
26228: PUSH
26229: EMPTY
26230: LIST
26231: LIST
26232: LIST
26233: PPUSH
26234: CALL_OW 69
26238: ST_TO_ADDR
// if not tmp then
26239: LD_VAR 0 8
26243: NOT
26244: IFFALSE 26248
// exit ;
26246: GO 27806
// for i in tmp do
26248: LD_ADDR_VAR 0 6
26252: PUSH
26253: LD_VAR 0 8
26257: PUSH
26258: FOR_IN
26259: IFFALSE 27781
// begin points := [ 0 , 0 , 0 ] ;
26261: LD_ADDR_VAR 0 9
26265: PUSH
26266: LD_INT 0
26268: PUSH
26269: LD_INT 0
26271: PUSH
26272: LD_INT 0
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: LIST
26279: ST_TO_ADDR
// bpoints := 1 ;
26280: LD_ADDR_VAR 0 10
26284: PUSH
26285: LD_INT 1
26287: ST_TO_ADDR
// case GetType ( i ) of unit_human :
26288: LD_VAR 0 6
26292: PPUSH
26293: CALL_OW 247
26297: PUSH
26298: LD_INT 1
26300: DOUBLE
26301: EQUAL
26302: IFTRUE 26306
26304: GO 26884
26306: POP
// begin if GetClass ( i ) = 1 then
26307: LD_VAR 0 6
26311: PPUSH
26312: CALL_OW 257
26316: PUSH
26317: LD_INT 1
26319: EQUAL
26320: IFFALSE 26341
// points := [ 10 , 5 , 3 ] ;
26322: LD_ADDR_VAR 0 9
26326: PUSH
26327: LD_INT 10
26329: PUSH
26330: LD_INT 5
26332: PUSH
26333: LD_INT 3
26335: PUSH
26336: EMPTY
26337: LIST
26338: LIST
26339: LIST
26340: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
26341: LD_VAR 0 6
26345: PPUSH
26346: CALL_OW 257
26350: PUSH
26351: LD_INT 2
26353: PUSH
26354: LD_INT 3
26356: PUSH
26357: LD_INT 4
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: LIST
26364: IN
26365: IFFALSE 26386
// points := [ 3 , 2 , 1 ] ;
26367: LD_ADDR_VAR 0 9
26371: PUSH
26372: LD_INT 3
26374: PUSH
26375: LD_INT 2
26377: PUSH
26378: LD_INT 1
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: LIST
26385: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26386: LD_VAR 0 6
26390: PPUSH
26391: CALL_OW 257
26395: PUSH
26396: LD_INT 5
26398: EQUAL
26399: IFFALSE 26420
// points := [ 130 , 5 , 2 ] ;
26401: LD_ADDR_VAR 0 9
26405: PUSH
26406: LD_INT 130
26408: PUSH
26409: LD_INT 5
26411: PUSH
26412: LD_INT 2
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: LIST
26419: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26420: LD_VAR 0 6
26424: PPUSH
26425: CALL_OW 257
26429: PUSH
26430: LD_INT 8
26432: EQUAL
26433: IFFALSE 26454
// points := [ 35 , 35 , 30 ] ;
26435: LD_ADDR_VAR 0 9
26439: PUSH
26440: LD_INT 35
26442: PUSH
26443: LD_INT 35
26445: PUSH
26446: LD_INT 30
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: LIST
26453: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26454: LD_VAR 0 6
26458: PPUSH
26459: CALL_OW 257
26463: PUSH
26464: LD_INT 9
26466: EQUAL
26467: IFFALSE 26488
// points := [ 20 , 55 , 40 ] ;
26469: LD_ADDR_VAR 0 9
26473: PUSH
26474: LD_INT 20
26476: PUSH
26477: LD_INT 55
26479: PUSH
26480: LD_INT 40
26482: PUSH
26483: EMPTY
26484: LIST
26485: LIST
26486: LIST
26487: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26488: LD_VAR 0 6
26492: PPUSH
26493: CALL_OW 257
26497: PUSH
26498: LD_INT 12
26500: PUSH
26501: LD_INT 16
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: IN
26508: IFFALSE 26529
// points := [ 5 , 3 , 2 ] ;
26510: LD_ADDR_VAR 0 9
26514: PUSH
26515: LD_INT 5
26517: PUSH
26518: LD_INT 3
26520: PUSH
26521: LD_INT 2
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: LIST
26528: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26529: LD_VAR 0 6
26533: PPUSH
26534: CALL_OW 257
26538: PUSH
26539: LD_INT 17
26541: EQUAL
26542: IFFALSE 26563
// points := [ 100 , 50 , 75 ] ;
26544: LD_ADDR_VAR 0 9
26548: PUSH
26549: LD_INT 100
26551: PUSH
26552: LD_INT 50
26554: PUSH
26555: LD_INT 75
26557: PUSH
26558: EMPTY
26559: LIST
26560: LIST
26561: LIST
26562: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26563: LD_VAR 0 6
26567: PPUSH
26568: CALL_OW 257
26572: PUSH
26573: LD_INT 15
26575: EQUAL
26576: IFFALSE 26597
// points := [ 10 , 5 , 3 ] ;
26578: LD_ADDR_VAR 0 9
26582: PUSH
26583: LD_INT 10
26585: PUSH
26586: LD_INT 5
26588: PUSH
26589: LD_INT 3
26591: PUSH
26592: EMPTY
26593: LIST
26594: LIST
26595: LIST
26596: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26597: LD_VAR 0 6
26601: PPUSH
26602: CALL_OW 257
26606: PUSH
26607: LD_INT 14
26609: EQUAL
26610: IFFALSE 26631
// points := [ 10 , 0 , 0 ] ;
26612: LD_ADDR_VAR 0 9
26616: PUSH
26617: LD_INT 10
26619: PUSH
26620: LD_INT 0
26622: PUSH
26623: LD_INT 0
26625: PUSH
26626: EMPTY
26627: LIST
26628: LIST
26629: LIST
26630: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26631: LD_VAR 0 6
26635: PPUSH
26636: CALL_OW 257
26640: PUSH
26641: LD_INT 11
26643: EQUAL
26644: IFFALSE 26665
// points := [ 30 , 10 , 5 ] ;
26646: LD_ADDR_VAR 0 9
26650: PUSH
26651: LD_INT 30
26653: PUSH
26654: LD_INT 10
26656: PUSH
26657: LD_INT 5
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: LIST
26664: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26665: LD_VAR 0 1
26669: PPUSH
26670: LD_INT 5
26672: PPUSH
26673: CALL_OW 321
26677: PUSH
26678: LD_INT 2
26680: EQUAL
26681: IFFALSE 26698
// bpoints := bpoints * 1.8 ;
26683: LD_ADDR_VAR 0 10
26687: PUSH
26688: LD_VAR 0 10
26692: PUSH
26693: LD_REAL  1.80000000000000E+0000
26696: MUL
26697: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26698: LD_VAR 0 6
26702: PPUSH
26703: CALL_OW 257
26707: PUSH
26708: LD_INT 1
26710: PUSH
26711: LD_INT 2
26713: PUSH
26714: LD_INT 3
26716: PUSH
26717: LD_INT 4
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: LIST
26724: LIST
26725: IN
26726: PUSH
26727: LD_VAR 0 1
26731: PPUSH
26732: LD_INT 51
26734: PPUSH
26735: CALL_OW 321
26739: PUSH
26740: LD_INT 2
26742: EQUAL
26743: AND
26744: IFFALSE 26761
// bpoints := bpoints * 1.2 ;
26746: LD_ADDR_VAR 0 10
26750: PUSH
26751: LD_VAR 0 10
26755: PUSH
26756: LD_REAL  1.20000000000000E+0000
26759: MUL
26760: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26761: LD_VAR 0 6
26765: PPUSH
26766: CALL_OW 257
26770: PUSH
26771: LD_INT 5
26773: PUSH
26774: LD_INT 7
26776: PUSH
26777: LD_INT 9
26779: PUSH
26780: EMPTY
26781: LIST
26782: LIST
26783: LIST
26784: IN
26785: PUSH
26786: LD_VAR 0 1
26790: PPUSH
26791: LD_INT 52
26793: PPUSH
26794: CALL_OW 321
26798: PUSH
26799: LD_INT 2
26801: EQUAL
26802: AND
26803: IFFALSE 26820
// bpoints := bpoints * 1.5 ;
26805: LD_ADDR_VAR 0 10
26809: PUSH
26810: LD_VAR 0 10
26814: PUSH
26815: LD_REAL  1.50000000000000E+0000
26818: MUL
26819: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26820: LD_VAR 0 1
26824: PPUSH
26825: LD_INT 66
26827: PPUSH
26828: CALL_OW 321
26832: PUSH
26833: LD_INT 2
26835: EQUAL
26836: IFFALSE 26853
// bpoints := bpoints * 1.1 ;
26838: LD_ADDR_VAR 0 10
26842: PUSH
26843: LD_VAR 0 10
26847: PUSH
26848: LD_REAL  1.10000000000000E+0000
26851: MUL
26852: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26853: LD_ADDR_VAR 0 10
26857: PUSH
26858: LD_VAR 0 10
26862: PUSH
26863: LD_VAR 0 6
26867: PPUSH
26868: LD_INT 1
26870: PPUSH
26871: CALL_OW 259
26875: PUSH
26876: LD_REAL  1.15000000000000E+0000
26879: MUL
26880: MUL
26881: ST_TO_ADDR
// end ; unit_vehicle :
26882: GO 27710
26884: LD_INT 2
26886: DOUBLE
26887: EQUAL
26888: IFTRUE 26892
26890: GO 27698
26892: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26893: LD_VAR 0 6
26897: PPUSH
26898: CALL_OW 264
26902: PUSH
26903: LD_INT 2
26905: PUSH
26906: LD_INT 42
26908: PUSH
26909: LD_INT 24
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: LIST
26916: IN
26917: IFFALSE 26938
// points := [ 25 , 5 , 3 ] ;
26919: LD_ADDR_VAR 0 9
26923: PUSH
26924: LD_INT 25
26926: PUSH
26927: LD_INT 5
26929: PUSH
26930: LD_INT 3
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: LIST
26937: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26938: LD_VAR 0 6
26942: PPUSH
26943: CALL_OW 264
26947: PUSH
26948: LD_INT 4
26950: PUSH
26951: LD_INT 43
26953: PUSH
26954: LD_INT 25
26956: PUSH
26957: EMPTY
26958: LIST
26959: LIST
26960: LIST
26961: IN
26962: IFFALSE 26983
// points := [ 40 , 15 , 5 ] ;
26964: LD_ADDR_VAR 0 9
26968: PUSH
26969: LD_INT 40
26971: PUSH
26972: LD_INT 15
26974: PUSH
26975: LD_INT 5
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: LIST
26982: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26983: LD_VAR 0 6
26987: PPUSH
26988: CALL_OW 264
26992: PUSH
26993: LD_INT 3
26995: PUSH
26996: LD_INT 23
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: IN
27003: IFFALSE 27024
// points := [ 7 , 25 , 8 ] ;
27005: LD_ADDR_VAR 0 9
27009: PUSH
27010: LD_INT 7
27012: PUSH
27013: LD_INT 25
27015: PUSH
27016: LD_INT 8
27018: PUSH
27019: EMPTY
27020: LIST
27021: LIST
27022: LIST
27023: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
27024: LD_VAR 0 6
27028: PPUSH
27029: CALL_OW 264
27033: PUSH
27034: LD_INT 5
27036: PUSH
27037: LD_INT 27
27039: PUSH
27040: LD_INT 44
27042: PUSH
27043: EMPTY
27044: LIST
27045: LIST
27046: LIST
27047: IN
27048: IFFALSE 27069
// points := [ 14 , 50 , 16 ] ;
27050: LD_ADDR_VAR 0 9
27054: PUSH
27055: LD_INT 14
27057: PUSH
27058: LD_INT 50
27060: PUSH
27061: LD_INT 16
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: LIST
27068: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
27069: LD_VAR 0 6
27073: PPUSH
27074: CALL_OW 264
27078: PUSH
27079: LD_INT 6
27081: PUSH
27082: LD_INT 46
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: IN
27089: IFFALSE 27110
// points := [ 32 , 120 , 70 ] ;
27091: LD_ADDR_VAR 0 9
27095: PUSH
27096: LD_INT 32
27098: PUSH
27099: LD_INT 120
27101: PUSH
27102: LD_INT 70
27104: PUSH
27105: EMPTY
27106: LIST
27107: LIST
27108: LIST
27109: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
27110: LD_VAR 0 6
27114: PPUSH
27115: CALL_OW 264
27119: PUSH
27120: LD_INT 7
27122: PUSH
27123: LD_INT 28
27125: PUSH
27126: LD_INT 45
27128: PUSH
27129: LD_INT 92
27131: PUSH
27132: EMPTY
27133: LIST
27134: LIST
27135: LIST
27136: LIST
27137: IN
27138: IFFALSE 27159
// points := [ 35 , 20 , 45 ] ;
27140: LD_ADDR_VAR 0 9
27144: PUSH
27145: LD_INT 35
27147: PUSH
27148: LD_INT 20
27150: PUSH
27151: LD_INT 45
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: LIST
27158: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
27159: LD_VAR 0 6
27163: PPUSH
27164: CALL_OW 264
27168: PUSH
27169: LD_INT 47
27171: PUSH
27172: EMPTY
27173: LIST
27174: IN
27175: IFFALSE 27196
// points := [ 67 , 45 , 75 ] ;
27177: LD_ADDR_VAR 0 9
27181: PUSH
27182: LD_INT 67
27184: PUSH
27185: LD_INT 45
27187: PUSH
27188: LD_INT 75
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: LIST
27195: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
27196: LD_VAR 0 6
27200: PPUSH
27201: CALL_OW 264
27205: PUSH
27206: LD_INT 26
27208: PUSH
27209: EMPTY
27210: LIST
27211: IN
27212: IFFALSE 27233
// points := [ 120 , 30 , 80 ] ;
27214: LD_ADDR_VAR 0 9
27218: PUSH
27219: LD_INT 120
27221: PUSH
27222: LD_INT 30
27224: PUSH
27225: LD_INT 80
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: LIST
27232: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
27233: LD_VAR 0 6
27237: PPUSH
27238: CALL_OW 264
27242: PUSH
27243: LD_INT 22
27245: PUSH
27246: EMPTY
27247: LIST
27248: IN
27249: IFFALSE 27270
// points := [ 40 , 1 , 1 ] ;
27251: LD_ADDR_VAR 0 9
27255: PUSH
27256: LD_INT 40
27258: PUSH
27259: LD_INT 1
27261: PUSH
27262: LD_INT 1
27264: PUSH
27265: EMPTY
27266: LIST
27267: LIST
27268: LIST
27269: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
27270: LD_VAR 0 6
27274: PPUSH
27275: CALL_OW 264
27279: PUSH
27280: LD_INT 29
27282: PUSH
27283: EMPTY
27284: LIST
27285: IN
27286: IFFALSE 27307
// points := [ 70 , 200 , 400 ] ;
27288: LD_ADDR_VAR 0 9
27292: PUSH
27293: LD_INT 70
27295: PUSH
27296: LD_INT 200
27298: PUSH
27299: LD_INT 400
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: LIST
27306: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
27307: LD_VAR 0 6
27311: PPUSH
27312: CALL_OW 264
27316: PUSH
27317: LD_INT 14
27319: PUSH
27320: LD_INT 53
27322: PUSH
27323: EMPTY
27324: LIST
27325: LIST
27326: IN
27327: IFFALSE 27348
// points := [ 40 , 10 , 20 ] ;
27329: LD_ADDR_VAR 0 9
27333: PUSH
27334: LD_INT 40
27336: PUSH
27337: LD_INT 10
27339: PUSH
27340: LD_INT 20
27342: PUSH
27343: EMPTY
27344: LIST
27345: LIST
27346: LIST
27347: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
27348: LD_VAR 0 6
27352: PPUSH
27353: CALL_OW 264
27357: PUSH
27358: LD_INT 9
27360: PUSH
27361: EMPTY
27362: LIST
27363: IN
27364: IFFALSE 27385
// points := [ 5 , 70 , 20 ] ;
27366: LD_ADDR_VAR 0 9
27370: PUSH
27371: LD_INT 5
27373: PUSH
27374: LD_INT 70
27376: PUSH
27377: LD_INT 20
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: LIST
27384: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27385: LD_VAR 0 6
27389: PPUSH
27390: CALL_OW 264
27394: PUSH
27395: LD_INT 10
27397: PUSH
27398: EMPTY
27399: LIST
27400: IN
27401: IFFALSE 27422
// points := [ 35 , 110 , 70 ] ;
27403: LD_ADDR_VAR 0 9
27407: PUSH
27408: LD_INT 35
27410: PUSH
27411: LD_INT 110
27413: PUSH
27414: LD_INT 70
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: LIST
27421: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27422: LD_VAR 0 6
27426: PPUSH
27427: CALL_OW 265
27431: PUSH
27432: LD_INT 25
27434: EQUAL
27435: IFFALSE 27456
// points := [ 80 , 65 , 100 ] ;
27437: LD_ADDR_VAR 0 9
27441: PUSH
27442: LD_INT 80
27444: PUSH
27445: LD_INT 65
27447: PUSH
27448: LD_INT 100
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: LIST
27455: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27456: LD_VAR 0 6
27460: PPUSH
27461: CALL_OW 263
27465: PUSH
27466: LD_INT 1
27468: EQUAL
27469: IFFALSE 27504
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27471: LD_ADDR_VAR 0 10
27475: PUSH
27476: LD_VAR 0 10
27480: PUSH
27481: LD_VAR 0 6
27485: PPUSH
27486: CALL_OW 311
27490: PPUSH
27491: LD_INT 3
27493: PPUSH
27494: CALL_OW 259
27498: PUSH
27499: LD_INT 4
27501: MUL
27502: MUL
27503: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27504: LD_VAR 0 6
27508: PPUSH
27509: CALL_OW 263
27513: PUSH
27514: LD_INT 2
27516: EQUAL
27517: IFFALSE 27568
// begin j := IsControledBy ( i ) ;
27519: LD_ADDR_VAR 0 7
27523: PUSH
27524: LD_VAR 0 6
27528: PPUSH
27529: CALL_OW 312
27533: ST_TO_ADDR
// if j then
27534: LD_VAR 0 7
27538: IFFALSE 27568
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27540: LD_ADDR_VAR 0 10
27544: PUSH
27545: LD_VAR 0 10
27549: PUSH
27550: LD_VAR 0 7
27554: PPUSH
27555: LD_INT 3
27557: PPUSH
27558: CALL_OW 259
27562: PUSH
27563: LD_INT 3
27565: MUL
27566: MUL
27567: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27568: LD_VAR 0 6
27572: PPUSH
27573: CALL_OW 264
27577: PUSH
27578: LD_INT 5
27580: PUSH
27581: LD_INT 6
27583: PUSH
27584: LD_INT 46
27586: PUSH
27587: LD_INT 44
27589: PUSH
27590: LD_INT 47
27592: PUSH
27593: LD_INT 45
27595: PUSH
27596: LD_INT 28
27598: PUSH
27599: LD_INT 7
27601: PUSH
27602: LD_INT 27
27604: PUSH
27605: LD_INT 29
27607: PUSH
27608: EMPTY
27609: LIST
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: LIST
27615: LIST
27616: LIST
27617: LIST
27618: LIST
27619: IN
27620: PUSH
27621: LD_VAR 0 1
27625: PPUSH
27626: LD_INT 52
27628: PPUSH
27629: CALL_OW 321
27633: PUSH
27634: LD_INT 2
27636: EQUAL
27637: AND
27638: IFFALSE 27655
// bpoints := bpoints * 1.2 ;
27640: LD_ADDR_VAR 0 10
27644: PUSH
27645: LD_VAR 0 10
27649: PUSH
27650: LD_REAL  1.20000000000000E+0000
27653: MUL
27654: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27655: LD_VAR 0 6
27659: PPUSH
27660: CALL_OW 264
27664: PUSH
27665: LD_INT 6
27667: PUSH
27668: LD_INT 46
27670: PUSH
27671: LD_INT 47
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: LIST
27678: IN
27679: IFFALSE 27696
// bpoints := bpoints * 1.2 ;
27681: LD_ADDR_VAR 0 10
27685: PUSH
27686: LD_VAR 0 10
27690: PUSH
27691: LD_REAL  1.20000000000000E+0000
27694: MUL
27695: ST_TO_ADDR
// end ; unit_building :
27696: GO 27710
27698: LD_INT 3
27700: DOUBLE
27701: EQUAL
27702: IFTRUE 27706
27704: GO 27709
27706: POP
// ; end ;
27707: GO 27710
27709: POP
// for j = 1 to 3 do
27710: LD_ADDR_VAR 0 7
27714: PUSH
27715: DOUBLE
27716: LD_INT 1
27718: DEC
27719: ST_TO_ADDR
27720: LD_INT 3
27722: PUSH
27723: FOR_TO
27724: IFFALSE 27777
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27726: LD_ADDR_VAR 0 5
27730: PUSH
27731: LD_VAR 0 5
27735: PPUSH
27736: LD_VAR 0 7
27740: PPUSH
27741: LD_VAR 0 5
27745: PUSH
27746: LD_VAR 0 7
27750: ARRAY
27751: PUSH
27752: LD_VAR 0 9
27756: PUSH
27757: LD_VAR 0 7
27761: ARRAY
27762: PUSH
27763: LD_VAR 0 10
27767: MUL
27768: PLUS
27769: PPUSH
27770: CALL_OW 1
27774: ST_TO_ADDR
27775: GO 27723
27777: POP
27778: POP
// end ;
27779: GO 26258
27781: POP
27782: POP
// result := Replace ( result , 4 , tmp ) ;
27783: LD_ADDR_VAR 0 5
27787: PUSH
27788: LD_VAR 0 5
27792: PPUSH
27793: LD_INT 4
27795: PPUSH
27796: LD_VAR 0 8
27800: PPUSH
27801: CALL_OW 1
27805: ST_TO_ADDR
// end ;
27806: LD_VAR 0 5
27810: RET
// export function DangerAtRange ( unit , range ) ; begin
27811: LD_INT 0
27813: PPUSH
// if not unit then
27814: LD_VAR 0 1
27818: NOT
27819: IFFALSE 27823
// exit ;
27821: GO 27868
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27823: LD_ADDR_VAR 0 3
27827: PUSH
27828: LD_VAR 0 1
27832: PPUSH
27833: CALL_OW 255
27837: PPUSH
27838: LD_VAR 0 1
27842: PPUSH
27843: CALL_OW 250
27847: PPUSH
27848: LD_VAR 0 1
27852: PPUSH
27853: CALL_OW 251
27857: PPUSH
27858: LD_VAR 0 2
27862: PPUSH
27863: CALL 26110 0 4
27867: ST_TO_ADDR
// end ;
27868: LD_VAR 0 3
27872: RET
// export function DangerInArea ( side , area ) ; begin
27873: LD_INT 0
27875: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27876: LD_ADDR_VAR 0 3
27880: PUSH
27881: LD_VAR 0 2
27885: PPUSH
27886: LD_INT 81
27888: PUSH
27889: LD_VAR 0 1
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PPUSH
27898: CALL_OW 70
27902: ST_TO_ADDR
// end ;
27903: LD_VAR 0 3
27907: RET
// export function IsExtension ( b ) ; begin
27908: LD_INT 0
27910: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27911: LD_ADDR_VAR 0 2
27915: PUSH
27916: LD_VAR 0 1
27920: PUSH
27921: LD_INT 23
27923: PUSH
27924: LD_INT 20
27926: PUSH
27927: LD_INT 22
27929: PUSH
27930: LD_INT 17
27932: PUSH
27933: LD_INT 24
27935: PUSH
27936: LD_INT 21
27938: PUSH
27939: LD_INT 19
27941: PUSH
27942: LD_INT 16
27944: PUSH
27945: LD_INT 25
27947: PUSH
27948: LD_INT 18
27950: PUSH
27951: EMPTY
27952: LIST
27953: LIST
27954: LIST
27955: LIST
27956: LIST
27957: LIST
27958: LIST
27959: LIST
27960: LIST
27961: LIST
27962: IN
27963: ST_TO_ADDR
// end ;
27964: LD_VAR 0 2
27968: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27969: LD_INT 0
27971: PPUSH
27972: PPUSH
27973: PPUSH
// result := [ ] ;
27974: LD_ADDR_VAR 0 4
27978: PUSH
27979: EMPTY
27980: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27981: LD_ADDR_VAR 0 5
27985: PUSH
27986: LD_VAR 0 2
27990: PPUSH
27991: LD_INT 21
27993: PUSH
27994: LD_INT 3
27996: PUSH
27997: EMPTY
27998: LIST
27999: LIST
28000: PPUSH
28001: CALL_OW 70
28005: ST_TO_ADDR
// if not tmp then
28006: LD_VAR 0 5
28010: NOT
28011: IFFALSE 28015
// exit ;
28013: GO 28079
// if checkLink then
28015: LD_VAR 0 3
28019: IFFALSE 28069
// begin for i in tmp do
28021: LD_ADDR_VAR 0 6
28025: PUSH
28026: LD_VAR 0 5
28030: PUSH
28031: FOR_IN
28032: IFFALSE 28067
// if GetBase ( i ) <> base then
28034: LD_VAR 0 6
28038: PPUSH
28039: CALL_OW 274
28043: PUSH
28044: LD_VAR 0 1
28048: NONEQUAL
28049: IFFALSE 28065
// ComLinkToBase ( base , i ) ;
28051: LD_VAR 0 1
28055: PPUSH
28056: LD_VAR 0 6
28060: PPUSH
28061: CALL_OW 169
28065: GO 28031
28067: POP
28068: POP
// end ; result := tmp ;
28069: LD_ADDR_VAR 0 4
28073: PUSH
28074: LD_VAR 0 5
28078: ST_TO_ADDR
// end ;
28079: LD_VAR 0 4
28083: RET
// export function ComComplete ( units , b ) ; var i ; begin
28084: LD_INT 0
28086: PPUSH
28087: PPUSH
// if not units then
28088: LD_VAR 0 1
28092: NOT
28093: IFFALSE 28097
// exit ;
28095: GO 28187
// for i in units do
28097: LD_ADDR_VAR 0 4
28101: PUSH
28102: LD_VAR 0 1
28106: PUSH
28107: FOR_IN
28108: IFFALSE 28185
// if BuildingStatus ( b ) = bs_build then
28110: LD_VAR 0 2
28114: PPUSH
28115: CALL_OW 461
28119: PUSH
28120: LD_INT 1
28122: EQUAL
28123: IFFALSE 28183
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
28125: LD_VAR 0 4
28129: PPUSH
28130: LD_STRING h
28132: PUSH
28133: LD_VAR 0 2
28137: PPUSH
28138: CALL_OW 250
28142: PUSH
28143: LD_VAR 0 2
28147: PPUSH
28148: CALL_OW 251
28152: PUSH
28153: LD_VAR 0 2
28157: PUSH
28158: LD_INT 0
28160: PUSH
28161: LD_INT 0
28163: PUSH
28164: LD_INT 0
28166: PUSH
28167: EMPTY
28168: LIST
28169: LIST
28170: LIST
28171: LIST
28172: LIST
28173: LIST
28174: LIST
28175: PUSH
28176: EMPTY
28177: LIST
28178: PPUSH
28179: CALL_OW 446
28183: GO 28107
28185: POP
28186: POP
// end ;
28187: LD_VAR 0 3
28191: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
28192: LD_INT 0
28194: PPUSH
28195: PPUSH
28196: PPUSH
28197: PPUSH
28198: PPUSH
28199: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
28200: LD_VAR 0 1
28204: NOT
28205: PUSH
28206: LD_VAR 0 1
28210: PPUSH
28211: CALL_OW 263
28215: PUSH
28216: LD_INT 2
28218: NONEQUAL
28219: OR
28220: IFFALSE 28224
// exit ;
28222: GO 28540
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
28224: LD_ADDR_VAR 0 6
28228: PUSH
28229: LD_INT 22
28231: PUSH
28232: LD_VAR 0 1
28236: PPUSH
28237: CALL_OW 255
28241: PUSH
28242: EMPTY
28243: LIST
28244: LIST
28245: PUSH
28246: LD_INT 2
28248: PUSH
28249: LD_INT 30
28251: PUSH
28252: LD_INT 36
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 34
28261: PUSH
28262: LD_INT 31
28264: PUSH
28265: EMPTY
28266: LIST
28267: LIST
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: LIST
28273: PUSH
28274: EMPTY
28275: LIST
28276: LIST
28277: PPUSH
28278: CALL_OW 69
28282: ST_TO_ADDR
// if not tmp then
28283: LD_VAR 0 6
28287: NOT
28288: IFFALSE 28292
// exit ;
28290: GO 28540
// result := [ ] ;
28292: LD_ADDR_VAR 0 2
28296: PUSH
28297: EMPTY
28298: ST_TO_ADDR
// for i in tmp do
28299: LD_ADDR_VAR 0 3
28303: PUSH
28304: LD_VAR 0 6
28308: PUSH
28309: FOR_IN
28310: IFFALSE 28381
// begin t := UnitsInside ( i ) ;
28312: LD_ADDR_VAR 0 4
28316: PUSH
28317: LD_VAR 0 3
28321: PPUSH
28322: CALL_OW 313
28326: ST_TO_ADDR
// if t then
28327: LD_VAR 0 4
28331: IFFALSE 28379
// for j in t do
28333: LD_ADDR_VAR 0 7
28337: PUSH
28338: LD_VAR 0 4
28342: PUSH
28343: FOR_IN
28344: IFFALSE 28377
// result := Replace ( result , result + 1 , j ) ;
28346: LD_ADDR_VAR 0 2
28350: PUSH
28351: LD_VAR 0 2
28355: PPUSH
28356: LD_VAR 0 2
28360: PUSH
28361: LD_INT 1
28363: PLUS
28364: PPUSH
28365: LD_VAR 0 7
28369: PPUSH
28370: CALL_OW 1
28374: ST_TO_ADDR
28375: GO 28343
28377: POP
28378: POP
// end ;
28379: GO 28309
28381: POP
28382: POP
// if not result then
28383: LD_VAR 0 2
28387: NOT
28388: IFFALSE 28392
// exit ;
28390: GO 28540
// mech := result [ 1 ] ;
28392: LD_ADDR_VAR 0 5
28396: PUSH
28397: LD_VAR 0 2
28401: PUSH
28402: LD_INT 1
28404: ARRAY
28405: ST_TO_ADDR
// if result > 1 then
28406: LD_VAR 0 2
28410: PUSH
28411: LD_INT 1
28413: GREATER
28414: IFFALSE 28526
// begin for i = 2 to result do
28416: LD_ADDR_VAR 0 3
28420: PUSH
28421: DOUBLE
28422: LD_INT 2
28424: DEC
28425: ST_TO_ADDR
28426: LD_VAR 0 2
28430: PUSH
28431: FOR_TO
28432: IFFALSE 28524
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28434: LD_ADDR_VAR 0 4
28438: PUSH
28439: LD_VAR 0 2
28443: PUSH
28444: LD_VAR 0 3
28448: ARRAY
28449: PPUSH
28450: LD_INT 3
28452: PPUSH
28453: CALL_OW 259
28457: PUSH
28458: LD_VAR 0 2
28462: PUSH
28463: LD_VAR 0 3
28467: ARRAY
28468: PPUSH
28469: CALL_OW 432
28473: MINUS
28474: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28475: LD_VAR 0 4
28479: PUSH
28480: LD_VAR 0 5
28484: PPUSH
28485: LD_INT 3
28487: PPUSH
28488: CALL_OW 259
28492: PUSH
28493: LD_VAR 0 5
28497: PPUSH
28498: CALL_OW 432
28502: MINUS
28503: GREATEREQUAL
28504: IFFALSE 28522
// mech := result [ i ] ;
28506: LD_ADDR_VAR 0 5
28510: PUSH
28511: LD_VAR 0 2
28515: PUSH
28516: LD_VAR 0 3
28520: ARRAY
28521: ST_TO_ADDR
// end ;
28522: GO 28431
28524: POP
28525: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28526: LD_VAR 0 1
28530: PPUSH
28531: LD_VAR 0 5
28535: PPUSH
28536: CALL_OW 135
// end ;
28540: LD_VAR 0 2
28544: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28545: LD_INT 0
28547: PPUSH
28548: PPUSH
28549: PPUSH
28550: PPUSH
28551: PPUSH
28552: PPUSH
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
28559: PPUSH
// result := [ ] ;
28560: LD_ADDR_VAR 0 7
28564: PUSH
28565: EMPTY
28566: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28567: LD_VAR 0 1
28571: PPUSH
28572: CALL_OW 266
28576: PUSH
28577: LD_INT 0
28579: PUSH
28580: LD_INT 1
28582: PUSH
28583: EMPTY
28584: LIST
28585: LIST
28586: IN
28587: NOT
28588: IFFALSE 28592
// exit ;
28590: GO 30226
// if name then
28592: LD_VAR 0 3
28596: IFFALSE 28612
// SetBName ( base_dep , name ) ;
28598: LD_VAR 0 1
28602: PPUSH
28603: LD_VAR 0 3
28607: PPUSH
28608: CALL_OW 500
// base := GetBase ( base_dep ) ;
28612: LD_ADDR_VAR 0 15
28616: PUSH
28617: LD_VAR 0 1
28621: PPUSH
28622: CALL_OW 274
28626: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28627: LD_ADDR_VAR 0 16
28631: PUSH
28632: LD_VAR 0 1
28636: PPUSH
28637: CALL_OW 255
28641: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28642: LD_ADDR_VAR 0 17
28646: PUSH
28647: LD_VAR 0 1
28651: PPUSH
28652: CALL_OW 248
28656: ST_TO_ADDR
// if sources then
28657: LD_VAR 0 5
28661: IFFALSE 28708
// for i = 1 to 3 do
28663: LD_ADDR_VAR 0 8
28667: PUSH
28668: DOUBLE
28669: LD_INT 1
28671: DEC
28672: ST_TO_ADDR
28673: LD_INT 3
28675: PUSH
28676: FOR_TO
28677: IFFALSE 28706
// AddResourceType ( base , i , sources [ i ] ) ;
28679: LD_VAR 0 15
28683: PPUSH
28684: LD_VAR 0 8
28688: PPUSH
28689: LD_VAR 0 5
28693: PUSH
28694: LD_VAR 0 8
28698: ARRAY
28699: PPUSH
28700: CALL_OW 276
28704: GO 28676
28706: POP
28707: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28708: LD_ADDR_VAR 0 18
28712: PUSH
28713: LD_VAR 0 15
28717: PPUSH
28718: LD_VAR 0 2
28722: PPUSH
28723: LD_INT 1
28725: PPUSH
28726: CALL 27969 0 3
28730: ST_TO_ADDR
// InitHc ;
28731: CALL_OW 19
// InitUc ;
28735: CALL_OW 18
// uc_side := side ;
28739: LD_ADDR_OWVAR 20
28743: PUSH
28744: LD_VAR 0 16
28748: ST_TO_ADDR
// uc_nation := nation ;
28749: LD_ADDR_OWVAR 21
28753: PUSH
28754: LD_VAR 0 17
28758: ST_TO_ADDR
// if buildings then
28759: LD_VAR 0 18
28763: IFFALSE 30085
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28765: LD_ADDR_VAR 0 19
28769: PUSH
28770: LD_VAR 0 18
28774: PPUSH
28775: LD_INT 2
28777: PUSH
28778: LD_INT 30
28780: PUSH
28781: LD_INT 29
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 30
28790: PUSH
28791: LD_INT 30
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: EMPTY
28799: LIST
28800: LIST
28801: LIST
28802: PPUSH
28803: CALL_OW 72
28807: ST_TO_ADDR
// if tmp then
28808: LD_VAR 0 19
28812: IFFALSE 28860
// for i in tmp do
28814: LD_ADDR_VAR 0 8
28818: PUSH
28819: LD_VAR 0 19
28823: PUSH
28824: FOR_IN
28825: IFFALSE 28858
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28827: LD_VAR 0 8
28831: PPUSH
28832: CALL_OW 250
28836: PPUSH
28837: LD_VAR 0 8
28841: PPUSH
28842: CALL_OW 251
28846: PPUSH
28847: LD_VAR 0 16
28851: PPUSH
28852: CALL_OW 441
28856: GO 28824
28858: POP
28859: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28860: LD_VAR 0 18
28864: PPUSH
28865: LD_INT 2
28867: PUSH
28868: LD_INT 30
28870: PUSH
28871: LD_INT 32
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 30
28880: PUSH
28881: LD_INT 33
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: LIST
28892: PPUSH
28893: CALL_OW 72
28897: IFFALSE 28985
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28899: LD_ADDR_VAR 0 8
28903: PUSH
28904: LD_VAR 0 18
28908: PPUSH
28909: LD_INT 2
28911: PUSH
28912: LD_INT 30
28914: PUSH
28915: LD_INT 32
28917: PUSH
28918: EMPTY
28919: LIST
28920: LIST
28921: PUSH
28922: LD_INT 30
28924: PUSH
28925: LD_INT 33
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: LIST
28936: PPUSH
28937: CALL_OW 72
28941: PUSH
28942: FOR_IN
28943: IFFALSE 28983
// begin if not GetBWeapon ( i ) then
28945: LD_VAR 0 8
28949: PPUSH
28950: CALL_OW 269
28954: NOT
28955: IFFALSE 28981
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28957: LD_VAR 0 8
28961: PPUSH
28962: LD_VAR 0 8
28966: PPUSH
28967: LD_VAR 0 2
28971: PPUSH
28972: CALL 30231 0 2
28976: PPUSH
28977: CALL_OW 431
// end ;
28981: GO 28942
28983: POP
28984: POP
// end ; for i = 1 to personel do
28985: LD_ADDR_VAR 0 8
28989: PUSH
28990: DOUBLE
28991: LD_INT 1
28993: DEC
28994: ST_TO_ADDR
28995: LD_VAR 0 6
28999: PUSH
29000: FOR_TO
29001: IFFALSE 30065
// begin if i > 4 then
29003: LD_VAR 0 8
29007: PUSH
29008: LD_INT 4
29010: GREATER
29011: IFFALSE 29015
// break ;
29013: GO 30065
// case i of 1 :
29015: LD_VAR 0 8
29019: PUSH
29020: LD_INT 1
29022: DOUBLE
29023: EQUAL
29024: IFTRUE 29028
29026: GO 29108
29028: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
29029: LD_ADDR_VAR 0 12
29033: PUSH
29034: LD_VAR 0 18
29038: PPUSH
29039: LD_INT 22
29041: PUSH
29042: LD_VAR 0 16
29046: PUSH
29047: EMPTY
29048: LIST
29049: LIST
29050: PUSH
29051: LD_INT 58
29053: PUSH
29054: EMPTY
29055: LIST
29056: PUSH
29057: LD_INT 2
29059: PUSH
29060: LD_INT 30
29062: PUSH
29063: LD_INT 32
29065: PUSH
29066: EMPTY
29067: LIST
29068: LIST
29069: PUSH
29070: LD_INT 30
29072: PUSH
29073: LD_INT 4
29075: PUSH
29076: EMPTY
29077: LIST
29078: LIST
29079: PUSH
29080: LD_INT 30
29082: PUSH
29083: LD_INT 5
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: LIST
29094: LIST
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: LIST
29100: PPUSH
29101: CALL_OW 72
29105: ST_TO_ADDR
29106: GO 29330
29108: LD_INT 2
29110: DOUBLE
29111: EQUAL
29112: IFTRUE 29116
29114: GO 29178
29116: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
29117: LD_ADDR_VAR 0 12
29121: PUSH
29122: LD_VAR 0 18
29126: PPUSH
29127: LD_INT 22
29129: PUSH
29130: LD_VAR 0 16
29134: PUSH
29135: EMPTY
29136: LIST
29137: LIST
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: LD_INT 30
29144: PUSH
29145: LD_INT 0
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PUSH
29152: LD_INT 30
29154: PUSH
29155: LD_INT 1
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: LIST
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PPUSH
29171: CALL_OW 72
29175: ST_TO_ADDR
29176: GO 29330
29178: LD_INT 3
29180: DOUBLE
29181: EQUAL
29182: IFTRUE 29186
29184: GO 29248
29186: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
29187: LD_ADDR_VAR 0 12
29191: PUSH
29192: LD_VAR 0 18
29196: PPUSH
29197: LD_INT 22
29199: PUSH
29200: LD_VAR 0 16
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 2
29211: PUSH
29212: LD_INT 30
29214: PUSH
29215: LD_INT 2
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 30
29224: PUSH
29225: LD_INT 3
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: LIST
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PPUSH
29241: CALL_OW 72
29245: ST_TO_ADDR
29246: GO 29330
29248: LD_INT 4
29250: DOUBLE
29251: EQUAL
29252: IFTRUE 29256
29254: GO 29329
29256: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
29257: LD_ADDR_VAR 0 12
29261: PUSH
29262: LD_VAR 0 18
29266: PPUSH
29267: LD_INT 22
29269: PUSH
29270: LD_VAR 0 16
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 2
29281: PUSH
29282: LD_INT 30
29284: PUSH
29285: LD_INT 6
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 30
29294: PUSH
29295: LD_INT 7
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 30
29304: PUSH
29305: LD_INT 8
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: EMPTY
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PPUSH
29322: CALL_OW 72
29326: ST_TO_ADDR
29327: GO 29330
29329: POP
// if i = 1 then
29330: LD_VAR 0 8
29334: PUSH
29335: LD_INT 1
29337: EQUAL
29338: IFFALSE 29449
// begin tmp := [ ] ;
29340: LD_ADDR_VAR 0 19
29344: PUSH
29345: EMPTY
29346: ST_TO_ADDR
// for j in f do
29347: LD_ADDR_VAR 0 9
29351: PUSH
29352: LD_VAR 0 12
29356: PUSH
29357: FOR_IN
29358: IFFALSE 29431
// if GetBType ( j ) = b_bunker then
29360: LD_VAR 0 9
29364: PPUSH
29365: CALL_OW 266
29369: PUSH
29370: LD_INT 32
29372: EQUAL
29373: IFFALSE 29400
// tmp := Insert ( tmp , 1 , j ) else
29375: LD_ADDR_VAR 0 19
29379: PUSH
29380: LD_VAR 0 19
29384: PPUSH
29385: LD_INT 1
29387: PPUSH
29388: LD_VAR 0 9
29392: PPUSH
29393: CALL_OW 2
29397: ST_TO_ADDR
29398: GO 29429
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29400: LD_ADDR_VAR 0 19
29404: PUSH
29405: LD_VAR 0 19
29409: PPUSH
29410: LD_VAR 0 19
29414: PUSH
29415: LD_INT 1
29417: PLUS
29418: PPUSH
29419: LD_VAR 0 9
29423: PPUSH
29424: CALL_OW 2
29428: ST_TO_ADDR
29429: GO 29357
29431: POP
29432: POP
// if tmp then
29433: LD_VAR 0 19
29437: IFFALSE 29449
// f := tmp ;
29439: LD_ADDR_VAR 0 12
29443: PUSH
29444: LD_VAR 0 19
29448: ST_TO_ADDR
// end ; x := personel [ i ] ;
29449: LD_ADDR_VAR 0 13
29453: PUSH
29454: LD_VAR 0 6
29458: PUSH
29459: LD_VAR 0 8
29463: ARRAY
29464: ST_TO_ADDR
// if x = - 1 then
29465: LD_VAR 0 13
29469: PUSH
29470: LD_INT 1
29472: NEG
29473: EQUAL
29474: IFFALSE 29683
// begin for j in f do
29476: LD_ADDR_VAR 0 9
29480: PUSH
29481: LD_VAR 0 12
29485: PUSH
29486: FOR_IN
29487: IFFALSE 29679
// repeat InitHc ;
29489: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29493: LD_VAR 0 9
29497: PPUSH
29498: CALL_OW 266
29502: PUSH
29503: LD_INT 5
29505: EQUAL
29506: IFFALSE 29576
// begin if UnitsInside ( j ) < 3 then
29508: LD_VAR 0 9
29512: PPUSH
29513: CALL_OW 313
29517: PUSH
29518: LD_INT 3
29520: LESS
29521: IFFALSE 29557
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29523: LD_INT 0
29525: PPUSH
29526: LD_INT 5
29528: PUSH
29529: LD_INT 8
29531: PUSH
29532: LD_INT 9
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: LIST
29539: PUSH
29540: LD_VAR 0 17
29544: ARRAY
29545: PPUSH
29546: LD_VAR 0 4
29550: PPUSH
29551: CALL_OW 380
29555: GO 29574
// PrepareHuman ( false , i , skill ) ;
29557: LD_INT 0
29559: PPUSH
29560: LD_VAR 0 8
29564: PPUSH
29565: LD_VAR 0 4
29569: PPUSH
29570: CALL_OW 380
// end else
29574: GO 29593
// PrepareHuman ( false , i , skill ) ;
29576: LD_INT 0
29578: PPUSH
29579: LD_VAR 0 8
29583: PPUSH
29584: LD_VAR 0 4
29588: PPUSH
29589: CALL_OW 380
// un := CreateHuman ;
29593: LD_ADDR_VAR 0 14
29597: PUSH
29598: CALL_OW 44
29602: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29603: LD_ADDR_VAR 0 7
29607: PUSH
29608: LD_VAR 0 7
29612: PPUSH
29613: LD_INT 1
29615: PPUSH
29616: LD_VAR 0 14
29620: PPUSH
29621: CALL_OW 2
29625: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29626: LD_VAR 0 14
29630: PPUSH
29631: LD_VAR 0 9
29635: PPUSH
29636: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29640: LD_VAR 0 9
29644: PPUSH
29645: CALL_OW 313
29649: PUSH
29650: LD_INT 6
29652: EQUAL
29653: PUSH
29654: LD_VAR 0 9
29658: PPUSH
29659: CALL_OW 266
29663: PUSH
29664: LD_INT 32
29666: PUSH
29667: LD_INT 31
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: IN
29674: OR
29675: IFFALSE 29489
29677: GO 29486
29679: POP
29680: POP
// end else
29681: GO 30063
// for j = 1 to x do
29683: LD_ADDR_VAR 0 9
29687: PUSH
29688: DOUBLE
29689: LD_INT 1
29691: DEC
29692: ST_TO_ADDR
29693: LD_VAR 0 13
29697: PUSH
29698: FOR_TO
29699: IFFALSE 30061
// begin InitHc ;
29701: CALL_OW 19
// if not f then
29705: LD_VAR 0 12
29709: NOT
29710: IFFALSE 29799
// begin PrepareHuman ( false , i , skill ) ;
29712: LD_INT 0
29714: PPUSH
29715: LD_VAR 0 8
29719: PPUSH
29720: LD_VAR 0 4
29724: PPUSH
29725: CALL_OW 380
// un := CreateHuman ;
29729: LD_ADDR_VAR 0 14
29733: PUSH
29734: CALL_OW 44
29738: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29739: LD_ADDR_VAR 0 7
29743: PUSH
29744: LD_VAR 0 7
29748: PPUSH
29749: LD_INT 1
29751: PPUSH
29752: LD_VAR 0 14
29756: PPUSH
29757: CALL_OW 2
29761: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29762: LD_VAR 0 14
29766: PPUSH
29767: LD_VAR 0 1
29771: PPUSH
29772: CALL_OW 250
29776: PPUSH
29777: LD_VAR 0 1
29781: PPUSH
29782: CALL_OW 251
29786: PPUSH
29787: LD_INT 10
29789: PPUSH
29790: LD_INT 0
29792: PPUSH
29793: CALL_OW 50
// continue ;
29797: GO 29698
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29799: LD_VAR 0 12
29803: PUSH
29804: LD_INT 1
29806: ARRAY
29807: PPUSH
29808: CALL_OW 313
29812: PUSH
29813: LD_VAR 0 12
29817: PUSH
29818: LD_INT 1
29820: ARRAY
29821: PPUSH
29822: CALL_OW 266
29826: PUSH
29827: LD_INT 32
29829: PUSH
29830: LD_INT 31
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: IN
29837: AND
29838: PUSH
29839: LD_VAR 0 12
29843: PUSH
29844: LD_INT 1
29846: ARRAY
29847: PPUSH
29848: CALL_OW 313
29852: PUSH
29853: LD_INT 6
29855: EQUAL
29856: OR
29857: IFFALSE 29877
// f := Delete ( f , 1 ) ;
29859: LD_ADDR_VAR 0 12
29863: PUSH
29864: LD_VAR 0 12
29868: PPUSH
29869: LD_INT 1
29871: PPUSH
29872: CALL_OW 3
29876: ST_TO_ADDR
// if not f then
29877: LD_VAR 0 12
29881: NOT
29882: IFFALSE 29900
// begin x := x + 2 ;
29884: LD_ADDR_VAR 0 13
29888: PUSH
29889: LD_VAR 0 13
29893: PUSH
29894: LD_INT 2
29896: PLUS
29897: ST_TO_ADDR
// continue ;
29898: GO 29698
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29900: LD_VAR 0 12
29904: PUSH
29905: LD_INT 1
29907: ARRAY
29908: PPUSH
29909: CALL_OW 266
29913: PUSH
29914: LD_INT 5
29916: EQUAL
29917: IFFALSE 29991
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29919: LD_VAR 0 12
29923: PUSH
29924: LD_INT 1
29926: ARRAY
29927: PPUSH
29928: CALL_OW 313
29932: PUSH
29933: LD_INT 3
29935: LESS
29936: IFFALSE 29972
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29938: LD_INT 0
29940: PPUSH
29941: LD_INT 5
29943: PUSH
29944: LD_INT 8
29946: PUSH
29947: LD_INT 9
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: LIST
29954: PUSH
29955: LD_VAR 0 17
29959: ARRAY
29960: PPUSH
29961: LD_VAR 0 4
29965: PPUSH
29966: CALL_OW 380
29970: GO 29989
// PrepareHuman ( false , i , skill ) ;
29972: LD_INT 0
29974: PPUSH
29975: LD_VAR 0 8
29979: PPUSH
29980: LD_VAR 0 4
29984: PPUSH
29985: CALL_OW 380
// end else
29989: GO 30008
// PrepareHuman ( false , i , skill ) ;
29991: LD_INT 0
29993: PPUSH
29994: LD_VAR 0 8
29998: PPUSH
29999: LD_VAR 0 4
30003: PPUSH
30004: CALL_OW 380
// un := CreateHuman ;
30008: LD_ADDR_VAR 0 14
30012: PUSH
30013: CALL_OW 44
30017: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
30018: LD_ADDR_VAR 0 7
30022: PUSH
30023: LD_VAR 0 7
30027: PPUSH
30028: LD_INT 1
30030: PPUSH
30031: LD_VAR 0 14
30035: PPUSH
30036: CALL_OW 2
30040: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
30041: LD_VAR 0 14
30045: PPUSH
30046: LD_VAR 0 12
30050: PUSH
30051: LD_INT 1
30053: ARRAY
30054: PPUSH
30055: CALL_OW 52
// end ;
30059: GO 29698
30061: POP
30062: POP
// end ;
30063: GO 29000
30065: POP
30066: POP
// result := result ^ buildings ;
30067: LD_ADDR_VAR 0 7
30071: PUSH
30072: LD_VAR 0 7
30076: PUSH
30077: LD_VAR 0 18
30081: ADD
30082: ST_TO_ADDR
// end else
30083: GO 30226
// begin for i = 1 to personel do
30085: LD_ADDR_VAR 0 8
30089: PUSH
30090: DOUBLE
30091: LD_INT 1
30093: DEC
30094: ST_TO_ADDR
30095: LD_VAR 0 6
30099: PUSH
30100: FOR_TO
30101: IFFALSE 30224
// begin if i > 4 then
30103: LD_VAR 0 8
30107: PUSH
30108: LD_INT 4
30110: GREATER
30111: IFFALSE 30115
// break ;
30113: GO 30224
// x := personel [ i ] ;
30115: LD_ADDR_VAR 0 13
30119: PUSH
30120: LD_VAR 0 6
30124: PUSH
30125: LD_VAR 0 8
30129: ARRAY
30130: ST_TO_ADDR
// if x = - 1 then
30131: LD_VAR 0 13
30135: PUSH
30136: LD_INT 1
30138: NEG
30139: EQUAL
30140: IFFALSE 30144
// continue ;
30142: GO 30100
// PrepareHuman ( false , i , skill ) ;
30144: LD_INT 0
30146: PPUSH
30147: LD_VAR 0 8
30151: PPUSH
30152: LD_VAR 0 4
30156: PPUSH
30157: CALL_OW 380
// un := CreateHuman ;
30161: LD_ADDR_VAR 0 14
30165: PUSH
30166: CALL_OW 44
30170: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
30171: LD_VAR 0 14
30175: PPUSH
30176: LD_VAR 0 1
30180: PPUSH
30181: CALL_OW 250
30185: PPUSH
30186: LD_VAR 0 1
30190: PPUSH
30191: CALL_OW 251
30195: PPUSH
30196: LD_INT 10
30198: PPUSH
30199: LD_INT 0
30201: PPUSH
30202: CALL_OW 50
// result := result ^ un ;
30206: LD_ADDR_VAR 0 7
30210: PUSH
30211: LD_VAR 0 7
30215: PUSH
30216: LD_VAR 0 14
30220: ADD
30221: ST_TO_ADDR
// end ;
30222: GO 30100
30224: POP
30225: POP
// end ; end ;
30226: LD_VAR 0 7
30230: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
30231: LD_INT 0
30233: PPUSH
30234: PPUSH
30235: PPUSH
30236: PPUSH
30237: PPUSH
30238: PPUSH
30239: PPUSH
30240: PPUSH
30241: PPUSH
30242: PPUSH
30243: PPUSH
30244: PPUSH
30245: PPUSH
30246: PPUSH
30247: PPUSH
30248: PPUSH
// result := false ;
30249: LD_ADDR_VAR 0 3
30253: PUSH
30254: LD_INT 0
30256: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
30257: LD_VAR 0 1
30261: NOT
30262: PUSH
30263: LD_VAR 0 1
30267: PPUSH
30268: CALL_OW 266
30272: PUSH
30273: LD_INT 32
30275: PUSH
30276: LD_INT 33
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: IN
30283: NOT
30284: OR
30285: IFFALSE 30289
// exit ;
30287: GO 31398
// nat := GetNation ( tower ) ;
30289: LD_ADDR_VAR 0 12
30293: PUSH
30294: LD_VAR 0 1
30298: PPUSH
30299: CALL_OW 248
30303: ST_TO_ADDR
// side := GetSide ( tower ) ;
30304: LD_ADDR_VAR 0 16
30308: PUSH
30309: LD_VAR 0 1
30313: PPUSH
30314: CALL_OW 255
30318: ST_TO_ADDR
// x := GetX ( tower ) ;
30319: LD_ADDR_VAR 0 10
30323: PUSH
30324: LD_VAR 0 1
30328: PPUSH
30329: CALL_OW 250
30333: ST_TO_ADDR
// y := GetY ( tower ) ;
30334: LD_ADDR_VAR 0 11
30338: PUSH
30339: LD_VAR 0 1
30343: PPUSH
30344: CALL_OW 251
30348: ST_TO_ADDR
// if not x or not y then
30349: LD_VAR 0 10
30353: NOT
30354: PUSH
30355: LD_VAR 0 11
30359: NOT
30360: OR
30361: IFFALSE 30365
// exit ;
30363: GO 31398
// weapon := 0 ;
30365: LD_ADDR_VAR 0 18
30369: PUSH
30370: LD_INT 0
30372: ST_TO_ADDR
// fac_list := [ ] ;
30373: LD_ADDR_VAR 0 17
30377: PUSH
30378: EMPTY
30379: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30380: LD_ADDR_VAR 0 6
30384: PUSH
30385: LD_VAR 0 1
30389: PPUSH
30390: CALL_OW 274
30394: PPUSH
30395: LD_VAR 0 2
30399: PPUSH
30400: LD_INT 0
30402: PPUSH
30403: CALL 27969 0 3
30407: PPUSH
30408: LD_INT 30
30410: PUSH
30411: LD_INT 3
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PPUSH
30418: CALL_OW 72
30422: ST_TO_ADDR
// if not factories then
30423: LD_VAR 0 6
30427: NOT
30428: IFFALSE 30432
// exit ;
30430: GO 31398
// for i in factories do
30432: LD_ADDR_VAR 0 8
30436: PUSH
30437: LD_VAR 0 6
30441: PUSH
30442: FOR_IN
30443: IFFALSE 30468
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30445: LD_ADDR_VAR 0 17
30449: PUSH
30450: LD_VAR 0 17
30454: PUSH
30455: LD_VAR 0 8
30459: PPUSH
30460: CALL_OW 478
30464: UNION
30465: ST_TO_ADDR
30466: GO 30442
30468: POP
30469: POP
// if not fac_list then
30470: LD_VAR 0 17
30474: NOT
30475: IFFALSE 30479
// exit ;
30477: GO 31398
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30479: LD_ADDR_VAR 0 5
30483: PUSH
30484: LD_INT 4
30486: PUSH
30487: LD_INT 5
30489: PUSH
30490: LD_INT 9
30492: PUSH
30493: LD_INT 10
30495: PUSH
30496: LD_INT 6
30498: PUSH
30499: LD_INT 7
30501: PUSH
30502: LD_INT 11
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: LIST
30513: PUSH
30514: LD_INT 27
30516: PUSH
30517: LD_INT 28
30519: PUSH
30520: LD_INT 26
30522: PUSH
30523: LD_INT 30
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: PUSH
30532: LD_INT 43
30534: PUSH
30535: LD_INT 44
30537: PUSH
30538: LD_INT 46
30540: PUSH
30541: LD_INT 45
30543: PUSH
30544: LD_INT 47
30546: PUSH
30547: LD_INT 49
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: LIST
30562: PUSH
30563: LD_VAR 0 12
30567: ARRAY
30568: ST_TO_ADDR
// list := list isect fac_list ;
30569: LD_ADDR_VAR 0 5
30573: PUSH
30574: LD_VAR 0 5
30578: PUSH
30579: LD_VAR 0 17
30583: ISECT
30584: ST_TO_ADDR
// if not list then
30585: LD_VAR 0 5
30589: NOT
30590: IFFALSE 30594
// exit ;
30592: GO 31398
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30594: LD_VAR 0 12
30598: PUSH
30599: LD_INT 3
30601: EQUAL
30602: PUSH
30603: LD_INT 49
30605: PUSH
30606: LD_VAR 0 5
30610: IN
30611: AND
30612: PUSH
30613: LD_INT 31
30615: PPUSH
30616: LD_VAR 0 16
30620: PPUSH
30621: CALL_OW 321
30625: PUSH
30626: LD_INT 2
30628: EQUAL
30629: AND
30630: IFFALSE 30690
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30632: LD_INT 22
30634: PUSH
30635: LD_VAR 0 16
30639: PUSH
30640: EMPTY
30641: LIST
30642: LIST
30643: PUSH
30644: LD_INT 35
30646: PUSH
30647: LD_INT 49
30649: PUSH
30650: EMPTY
30651: LIST
30652: LIST
30653: PUSH
30654: LD_INT 91
30656: PUSH
30657: LD_VAR 0 1
30661: PUSH
30662: LD_INT 10
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: LIST
30669: PUSH
30670: EMPTY
30671: LIST
30672: LIST
30673: LIST
30674: PPUSH
30675: CALL_OW 69
30679: NOT
30680: IFFALSE 30690
// weapon := ru_time_lapser ;
30682: LD_ADDR_VAR 0 18
30686: PUSH
30687: LD_INT 49
30689: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30690: LD_VAR 0 12
30694: PUSH
30695: LD_INT 1
30697: PUSH
30698: LD_INT 2
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: IN
30705: PUSH
30706: LD_INT 11
30708: PUSH
30709: LD_VAR 0 5
30713: IN
30714: PUSH
30715: LD_INT 30
30717: PUSH
30718: LD_VAR 0 5
30722: IN
30723: OR
30724: AND
30725: PUSH
30726: LD_INT 6
30728: PPUSH
30729: LD_VAR 0 16
30733: PPUSH
30734: CALL_OW 321
30738: PUSH
30739: LD_INT 2
30741: EQUAL
30742: AND
30743: IFFALSE 30908
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30745: LD_INT 22
30747: PUSH
30748: LD_VAR 0 16
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 2
30759: PUSH
30760: LD_INT 35
30762: PUSH
30763: LD_INT 11
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: PUSH
30770: LD_INT 35
30772: PUSH
30773: LD_INT 30
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 91
30787: PUSH
30788: LD_VAR 0 1
30792: PUSH
30793: LD_INT 18
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: LIST
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: LIST
30805: PPUSH
30806: CALL_OW 69
30810: NOT
30811: PUSH
30812: LD_INT 22
30814: PUSH
30815: LD_VAR 0 16
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 2
30826: PUSH
30827: LD_INT 30
30829: PUSH
30830: LD_INT 32
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 30
30839: PUSH
30840: LD_INT 33
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: EMPTY
30848: LIST
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 91
30854: PUSH
30855: LD_VAR 0 1
30859: PUSH
30860: LD_INT 12
30862: PUSH
30863: EMPTY
30864: LIST
30865: LIST
30866: LIST
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: LIST
30872: PUSH
30873: EMPTY
30874: LIST
30875: PPUSH
30876: CALL_OW 69
30880: PUSH
30881: LD_INT 2
30883: GREATER
30884: AND
30885: IFFALSE 30908
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30887: LD_ADDR_VAR 0 18
30891: PUSH
30892: LD_INT 11
30894: PUSH
30895: LD_INT 30
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_VAR 0 12
30906: ARRAY
30907: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30908: LD_VAR 0 18
30912: NOT
30913: PUSH
30914: LD_INT 40
30916: PPUSH
30917: LD_VAR 0 16
30921: PPUSH
30922: CALL_OW 321
30926: PUSH
30927: LD_INT 2
30929: EQUAL
30930: AND
30931: PUSH
30932: LD_INT 7
30934: PUSH
30935: LD_VAR 0 5
30939: IN
30940: PUSH
30941: LD_INT 28
30943: PUSH
30944: LD_VAR 0 5
30948: IN
30949: OR
30950: PUSH
30951: LD_INT 45
30953: PUSH
30954: LD_VAR 0 5
30958: IN
30959: OR
30960: AND
30961: IFFALSE 31215
// begin hex := GetHexInfo ( x , y ) ;
30963: LD_ADDR_VAR 0 4
30967: PUSH
30968: LD_VAR 0 10
30972: PPUSH
30973: LD_VAR 0 11
30977: PPUSH
30978: CALL_OW 546
30982: ST_TO_ADDR
// if hex [ 1 ] then
30983: LD_VAR 0 4
30987: PUSH
30988: LD_INT 1
30990: ARRAY
30991: IFFALSE 30995
// exit ;
30993: GO 31398
// height := hex [ 2 ] ;
30995: LD_ADDR_VAR 0 15
30999: PUSH
31000: LD_VAR 0 4
31004: PUSH
31005: LD_INT 2
31007: ARRAY
31008: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
31009: LD_ADDR_VAR 0 14
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: LD_INT 2
31019: PUSH
31020: LD_INT 3
31022: PUSH
31023: LD_INT 5
31025: PUSH
31026: EMPTY
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: ST_TO_ADDR
// for i in tmp do
31032: LD_ADDR_VAR 0 8
31036: PUSH
31037: LD_VAR 0 14
31041: PUSH
31042: FOR_IN
31043: IFFALSE 31213
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
31045: LD_ADDR_VAR 0 9
31049: PUSH
31050: LD_VAR 0 10
31054: PPUSH
31055: LD_VAR 0 8
31059: PPUSH
31060: LD_INT 5
31062: PPUSH
31063: CALL_OW 272
31067: PUSH
31068: LD_VAR 0 11
31072: PPUSH
31073: LD_VAR 0 8
31077: PPUSH
31078: LD_INT 5
31080: PPUSH
31081: CALL_OW 273
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
31090: LD_VAR 0 9
31094: PUSH
31095: LD_INT 1
31097: ARRAY
31098: PPUSH
31099: LD_VAR 0 9
31103: PUSH
31104: LD_INT 2
31106: ARRAY
31107: PPUSH
31108: CALL_OW 488
31112: IFFALSE 31211
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
31114: LD_ADDR_VAR 0 4
31118: PUSH
31119: LD_VAR 0 9
31123: PUSH
31124: LD_INT 1
31126: ARRAY
31127: PPUSH
31128: LD_VAR 0 9
31132: PUSH
31133: LD_INT 2
31135: ARRAY
31136: PPUSH
31137: CALL_OW 546
31141: ST_TO_ADDR
// if hex [ 1 ] then
31142: LD_VAR 0 4
31146: PUSH
31147: LD_INT 1
31149: ARRAY
31150: IFFALSE 31154
// continue ;
31152: GO 31042
// h := hex [ 2 ] ;
31154: LD_ADDR_VAR 0 13
31158: PUSH
31159: LD_VAR 0 4
31163: PUSH
31164: LD_INT 2
31166: ARRAY
31167: ST_TO_ADDR
// if h + 7 < height then
31168: LD_VAR 0 13
31172: PUSH
31173: LD_INT 7
31175: PLUS
31176: PUSH
31177: LD_VAR 0 15
31181: LESS
31182: IFFALSE 31211
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
31184: LD_ADDR_VAR 0 18
31188: PUSH
31189: LD_INT 7
31191: PUSH
31192: LD_INT 28
31194: PUSH
31195: LD_INT 45
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: LIST
31202: PUSH
31203: LD_VAR 0 12
31207: ARRAY
31208: ST_TO_ADDR
// break ;
31209: GO 31213
// end ; end ; end ;
31211: GO 31042
31213: POP
31214: POP
// end ; if not weapon then
31215: LD_VAR 0 18
31219: NOT
31220: IFFALSE 31280
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
31222: LD_ADDR_VAR 0 5
31226: PUSH
31227: LD_VAR 0 5
31231: PUSH
31232: LD_INT 11
31234: PUSH
31235: LD_INT 30
31237: PUSH
31238: LD_INT 49
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: LIST
31245: DIFF
31246: ST_TO_ADDR
// if not list then
31247: LD_VAR 0 5
31251: NOT
31252: IFFALSE 31256
// exit ;
31254: GO 31398
// weapon := list [ rand ( 1 , list ) ] ;
31256: LD_ADDR_VAR 0 18
31260: PUSH
31261: LD_VAR 0 5
31265: PUSH
31266: LD_INT 1
31268: PPUSH
31269: LD_VAR 0 5
31273: PPUSH
31274: CALL_OW 12
31278: ARRAY
31279: ST_TO_ADDR
// end ; if weapon then
31280: LD_VAR 0 18
31284: IFFALSE 31398
// begin tmp := CostOfWeapon ( weapon ) ;
31286: LD_ADDR_VAR 0 14
31290: PUSH
31291: LD_VAR 0 18
31295: PPUSH
31296: CALL_OW 451
31300: ST_TO_ADDR
// j := GetBase ( tower ) ;
31301: LD_ADDR_VAR 0 9
31305: PUSH
31306: LD_VAR 0 1
31310: PPUSH
31311: CALL_OW 274
31315: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
31316: LD_VAR 0 9
31320: PPUSH
31321: LD_INT 1
31323: PPUSH
31324: CALL_OW 275
31328: PUSH
31329: LD_VAR 0 14
31333: PUSH
31334: LD_INT 1
31336: ARRAY
31337: GREATEREQUAL
31338: PUSH
31339: LD_VAR 0 9
31343: PPUSH
31344: LD_INT 2
31346: PPUSH
31347: CALL_OW 275
31351: PUSH
31352: LD_VAR 0 14
31356: PUSH
31357: LD_INT 2
31359: ARRAY
31360: GREATEREQUAL
31361: AND
31362: PUSH
31363: LD_VAR 0 9
31367: PPUSH
31368: LD_INT 3
31370: PPUSH
31371: CALL_OW 275
31375: PUSH
31376: LD_VAR 0 14
31380: PUSH
31381: LD_INT 3
31383: ARRAY
31384: GREATEREQUAL
31385: AND
31386: IFFALSE 31398
// result := weapon ;
31388: LD_ADDR_VAR 0 3
31392: PUSH
31393: LD_VAR 0 18
31397: ST_TO_ADDR
// end ; end ;
31398: LD_VAR 0 3
31402: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31403: LD_INT 0
31405: PPUSH
31406: PPUSH
// result := true ;
31407: LD_ADDR_VAR 0 3
31411: PUSH
31412: LD_INT 1
31414: ST_TO_ADDR
// if array1 = array2 then
31415: LD_VAR 0 1
31419: PUSH
31420: LD_VAR 0 2
31424: EQUAL
31425: IFFALSE 31485
// begin for i = 1 to array1 do
31427: LD_ADDR_VAR 0 4
31431: PUSH
31432: DOUBLE
31433: LD_INT 1
31435: DEC
31436: ST_TO_ADDR
31437: LD_VAR 0 1
31441: PUSH
31442: FOR_TO
31443: IFFALSE 31481
// if array1 [ i ] <> array2 [ i ] then
31445: LD_VAR 0 1
31449: PUSH
31450: LD_VAR 0 4
31454: ARRAY
31455: PUSH
31456: LD_VAR 0 2
31460: PUSH
31461: LD_VAR 0 4
31465: ARRAY
31466: NONEQUAL
31467: IFFALSE 31479
// begin result := false ;
31469: LD_ADDR_VAR 0 3
31473: PUSH
31474: LD_INT 0
31476: ST_TO_ADDR
// break ;
31477: GO 31481
// end ;
31479: GO 31442
31481: POP
31482: POP
// end else
31483: GO 31493
// result := false ;
31485: LD_ADDR_VAR 0 3
31489: PUSH
31490: LD_INT 0
31492: ST_TO_ADDR
// end ;
31493: LD_VAR 0 3
31497: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31498: LD_INT 0
31500: PPUSH
31501: PPUSH
// if not array1 or not array2 then
31502: LD_VAR 0 1
31506: NOT
31507: PUSH
31508: LD_VAR 0 2
31512: NOT
31513: OR
31514: IFFALSE 31518
// exit ;
31516: GO 31582
// result := true ;
31518: LD_ADDR_VAR 0 3
31522: PUSH
31523: LD_INT 1
31525: ST_TO_ADDR
// for i = 1 to array1 do
31526: LD_ADDR_VAR 0 4
31530: PUSH
31531: DOUBLE
31532: LD_INT 1
31534: DEC
31535: ST_TO_ADDR
31536: LD_VAR 0 1
31540: PUSH
31541: FOR_TO
31542: IFFALSE 31580
// if array1 [ i ] <> array2 [ i ] then
31544: LD_VAR 0 1
31548: PUSH
31549: LD_VAR 0 4
31553: ARRAY
31554: PUSH
31555: LD_VAR 0 2
31559: PUSH
31560: LD_VAR 0 4
31564: ARRAY
31565: NONEQUAL
31566: IFFALSE 31578
// begin result := false ;
31568: LD_ADDR_VAR 0 3
31572: PUSH
31573: LD_INT 0
31575: ST_TO_ADDR
// break ;
31576: GO 31580
// end ;
31578: GO 31541
31580: POP
31581: POP
// end ;
31582: LD_VAR 0 3
31586: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31587: LD_INT 0
31589: PPUSH
31590: PPUSH
31591: PPUSH
// pom := GetBase ( fac ) ;
31592: LD_ADDR_VAR 0 5
31596: PUSH
31597: LD_VAR 0 1
31601: PPUSH
31602: CALL_OW 274
31606: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31607: LD_ADDR_VAR 0 4
31611: PUSH
31612: LD_VAR 0 2
31616: PUSH
31617: LD_INT 1
31619: ARRAY
31620: PPUSH
31621: LD_VAR 0 2
31625: PUSH
31626: LD_INT 2
31628: ARRAY
31629: PPUSH
31630: LD_VAR 0 2
31634: PUSH
31635: LD_INT 3
31637: ARRAY
31638: PPUSH
31639: LD_VAR 0 2
31643: PUSH
31644: LD_INT 4
31646: ARRAY
31647: PPUSH
31648: CALL_OW 449
31652: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31653: LD_ADDR_VAR 0 3
31657: PUSH
31658: LD_VAR 0 5
31662: PPUSH
31663: LD_INT 1
31665: PPUSH
31666: CALL_OW 275
31670: PUSH
31671: LD_VAR 0 4
31675: PUSH
31676: LD_INT 1
31678: ARRAY
31679: GREATEREQUAL
31680: PUSH
31681: LD_VAR 0 5
31685: PPUSH
31686: LD_INT 2
31688: PPUSH
31689: CALL_OW 275
31693: PUSH
31694: LD_VAR 0 4
31698: PUSH
31699: LD_INT 2
31701: ARRAY
31702: GREATEREQUAL
31703: AND
31704: PUSH
31705: LD_VAR 0 5
31709: PPUSH
31710: LD_INT 3
31712: PPUSH
31713: CALL_OW 275
31717: PUSH
31718: LD_VAR 0 4
31722: PUSH
31723: LD_INT 3
31725: ARRAY
31726: GREATEREQUAL
31727: AND
31728: ST_TO_ADDR
// end ;
31729: LD_VAR 0 3
31733: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31734: LD_INT 0
31736: PPUSH
31737: PPUSH
31738: PPUSH
31739: PPUSH
// pom := GetBase ( building ) ;
31740: LD_ADDR_VAR 0 3
31744: PUSH
31745: LD_VAR 0 1
31749: PPUSH
31750: CALL_OW 274
31754: ST_TO_ADDR
// if not pom then
31755: LD_VAR 0 3
31759: NOT
31760: IFFALSE 31764
// exit ;
31762: GO 31934
// btype := GetBType ( building ) ;
31764: LD_ADDR_VAR 0 5
31768: PUSH
31769: LD_VAR 0 1
31773: PPUSH
31774: CALL_OW 266
31778: ST_TO_ADDR
// if btype = b_armoury then
31779: LD_VAR 0 5
31783: PUSH
31784: LD_INT 4
31786: EQUAL
31787: IFFALSE 31797
// btype := b_barracks ;
31789: LD_ADDR_VAR 0 5
31793: PUSH
31794: LD_INT 5
31796: ST_TO_ADDR
// if btype = b_depot then
31797: LD_VAR 0 5
31801: PUSH
31802: LD_INT 0
31804: EQUAL
31805: IFFALSE 31815
// btype := b_warehouse ;
31807: LD_ADDR_VAR 0 5
31811: PUSH
31812: LD_INT 1
31814: ST_TO_ADDR
// if btype = b_workshop then
31815: LD_VAR 0 5
31819: PUSH
31820: LD_INT 2
31822: EQUAL
31823: IFFALSE 31833
// btype := b_factory ;
31825: LD_ADDR_VAR 0 5
31829: PUSH
31830: LD_INT 3
31832: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31833: LD_ADDR_VAR 0 4
31837: PUSH
31838: LD_VAR 0 5
31842: PPUSH
31843: LD_VAR 0 1
31847: PPUSH
31848: CALL_OW 248
31852: PPUSH
31853: CALL_OW 450
31857: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31858: LD_ADDR_VAR 0 2
31862: PUSH
31863: LD_VAR 0 3
31867: PPUSH
31868: LD_INT 1
31870: PPUSH
31871: CALL_OW 275
31875: PUSH
31876: LD_VAR 0 4
31880: PUSH
31881: LD_INT 1
31883: ARRAY
31884: GREATEREQUAL
31885: PUSH
31886: LD_VAR 0 3
31890: PPUSH
31891: LD_INT 2
31893: PPUSH
31894: CALL_OW 275
31898: PUSH
31899: LD_VAR 0 4
31903: PUSH
31904: LD_INT 2
31906: ARRAY
31907: GREATEREQUAL
31908: AND
31909: PUSH
31910: LD_VAR 0 3
31914: PPUSH
31915: LD_INT 3
31917: PPUSH
31918: CALL_OW 275
31922: PUSH
31923: LD_VAR 0 4
31927: PUSH
31928: LD_INT 3
31930: ARRAY
31931: GREATEREQUAL
31932: AND
31933: ST_TO_ADDR
// end ;
31934: LD_VAR 0 2
31938: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31939: LD_INT 0
31941: PPUSH
31942: PPUSH
31943: PPUSH
// pom := GetBase ( building ) ;
31944: LD_ADDR_VAR 0 4
31948: PUSH
31949: LD_VAR 0 1
31953: PPUSH
31954: CALL_OW 274
31958: ST_TO_ADDR
// if not pom then
31959: LD_VAR 0 4
31963: NOT
31964: IFFALSE 31968
// exit ;
31966: GO 32069
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31968: LD_ADDR_VAR 0 5
31972: PUSH
31973: LD_VAR 0 2
31977: PPUSH
31978: LD_VAR 0 1
31982: PPUSH
31983: CALL_OW 248
31987: PPUSH
31988: CALL_OW 450
31992: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31993: LD_ADDR_VAR 0 3
31997: PUSH
31998: LD_VAR 0 4
32002: PPUSH
32003: LD_INT 1
32005: PPUSH
32006: CALL_OW 275
32010: PUSH
32011: LD_VAR 0 5
32015: PUSH
32016: LD_INT 1
32018: ARRAY
32019: GREATEREQUAL
32020: PUSH
32021: LD_VAR 0 4
32025: PPUSH
32026: LD_INT 2
32028: PPUSH
32029: CALL_OW 275
32033: PUSH
32034: LD_VAR 0 5
32038: PUSH
32039: LD_INT 2
32041: ARRAY
32042: GREATEREQUAL
32043: AND
32044: PUSH
32045: LD_VAR 0 4
32049: PPUSH
32050: LD_INT 3
32052: PPUSH
32053: CALL_OW 275
32057: PUSH
32058: LD_VAR 0 5
32062: PUSH
32063: LD_INT 3
32065: ARRAY
32066: GREATEREQUAL
32067: AND
32068: ST_TO_ADDR
// end ;
32069: LD_VAR 0 3
32073: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
32074: LD_INT 0
32076: PPUSH
32077: PPUSH
32078: PPUSH
32079: PPUSH
32080: PPUSH
32081: PPUSH
32082: PPUSH
32083: PPUSH
32084: PPUSH
32085: PPUSH
32086: PPUSH
// result := false ;
32087: LD_ADDR_VAR 0 8
32091: PUSH
32092: LD_INT 0
32094: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
32095: LD_VAR 0 5
32099: NOT
32100: PUSH
32101: LD_VAR 0 1
32105: NOT
32106: OR
32107: PUSH
32108: LD_VAR 0 2
32112: NOT
32113: OR
32114: PUSH
32115: LD_VAR 0 3
32119: NOT
32120: OR
32121: IFFALSE 32125
// exit ;
32123: GO 32939
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
32125: LD_ADDR_VAR 0 14
32129: PUSH
32130: LD_VAR 0 1
32134: PPUSH
32135: LD_VAR 0 2
32139: PPUSH
32140: LD_VAR 0 3
32144: PPUSH
32145: LD_VAR 0 4
32149: PPUSH
32150: LD_VAR 0 5
32154: PUSH
32155: LD_INT 1
32157: ARRAY
32158: PPUSH
32159: CALL_OW 248
32163: PPUSH
32164: LD_INT 0
32166: PPUSH
32167: CALL 34192 0 6
32171: ST_TO_ADDR
// if not hexes then
32172: LD_VAR 0 14
32176: NOT
32177: IFFALSE 32181
// exit ;
32179: GO 32939
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
32181: LD_ADDR_VAR 0 17
32185: PUSH
32186: LD_VAR 0 5
32190: PPUSH
32191: LD_INT 22
32193: PUSH
32194: LD_VAR 0 13
32198: PPUSH
32199: CALL_OW 255
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: PUSH
32208: LD_INT 2
32210: PUSH
32211: LD_INT 30
32213: PUSH
32214: LD_INT 0
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 30
32223: PUSH
32224: LD_INT 1
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: LIST
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PPUSH
32240: CALL_OW 72
32244: ST_TO_ADDR
// for i = 1 to hexes do
32245: LD_ADDR_VAR 0 9
32249: PUSH
32250: DOUBLE
32251: LD_INT 1
32253: DEC
32254: ST_TO_ADDR
32255: LD_VAR 0 14
32259: PUSH
32260: FOR_TO
32261: IFFALSE 32937
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32263: LD_ADDR_VAR 0 13
32267: PUSH
32268: LD_VAR 0 14
32272: PUSH
32273: LD_VAR 0 9
32277: ARRAY
32278: PUSH
32279: LD_INT 1
32281: ARRAY
32282: PPUSH
32283: LD_VAR 0 14
32287: PUSH
32288: LD_VAR 0 9
32292: ARRAY
32293: PUSH
32294: LD_INT 2
32296: ARRAY
32297: PPUSH
32298: CALL_OW 428
32302: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
32303: LD_VAR 0 14
32307: PUSH
32308: LD_VAR 0 9
32312: ARRAY
32313: PUSH
32314: LD_INT 1
32316: ARRAY
32317: PPUSH
32318: LD_VAR 0 14
32322: PUSH
32323: LD_VAR 0 9
32327: ARRAY
32328: PUSH
32329: LD_INT 2
32331: ARRAY
32332: PPUSH
32333: CALL_OW 351
32337: PUSH
32338: LD_VAR 0 14
32342: PUSH
32343: LD_VAR 0 9
32347: ARRAY
32348: PUSH
32349: LD_INT 1
32351: ARRAY
32352: PPUSH
32353: LD_VAR 0 14
32357: PUSH
32358: LD_VAR 0 9
32362: ARRAY
32363: PUSH
32364: LD_INT 2
32366: ARRAY
32367: PPUSH
32368: CALL_OW 488
32372: NOT
32373: OR
32374: PUSH
32375: LD_VAR 0 13
32379: PPUSH
32380: CALL_OW 247
32384: PUSH
32385: LD_INT 3
32387: EQUAL
32388: OR
32389: IFFALSE 32395
// exit ;
32391: POP
32392: POP
32393: GO 32939
// if not tmp then
32395: LD_VAR 0 13
32399: NOT
32400: IFFALSE 32404
// continue ;
32402: GO 32260
// result := true ;
32404: LD_ADDR_VAR 0 8
32408: PUSH
32409: LD_INT 1
32411: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32412: LD_VAR 0 6
32416: PUSH
32417: LD_VAR 0 13
32421: PPUSH
32422: CALL_OW 247
32426: PUSH
32427: LD_INT 2
32429: EQUAL
32430: AND
32431: PUSH
32432: LD_VAR 0 13
32436: PPUSH
32437: CALL_OW 263
32441: PUSH
32442: LD_INT 1
32444: EQUAL
32445: AND
32446: IFFALSE 32610
// begin if IsDrivenBy ( tmp ) then
32448: LD_VAR 0 13
32452: PPUSH
32453: CALL_OW 311
32457: IFFALSE 32461
// continue ;
32459: GO 32260
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32461: LD_VAR 0 6
32465: PPUSH
32466: LD_INT 3
32468: PUSH
32469: LD_INT 60
32471: PUSH
32472: EMPTY
32473: LIST
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 3
32481: PUSH
32482: LD_INT 55
32484: PUSH
32485: EMPTY
32486: LIST
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PPUSH
32496: CALL_OW 72
32500: IFFALSE 32608
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32502: LD_ADDR_VAR 0 18
32506: PUSH
32507: LD_VAR 0 6
32511: PPUSH
32512: LD_INT 3
32514: PUSH
32515: LD_INT 60
32517: PUSH
32518: EMPTY
32519: LIST
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 3
32527: PUSH
32528: LD_INT 55
32530: PUSH
32531: EMPTY
32532: LIST
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PPUSH
32542: CALL_OW 72
32546: PUSH
32547: LD_INT 1
32549: ARRAY
32550: ST_TO_ADDR
// if IsInUnit ( driver ) then
32551: LD_VAR 0 18
32555: PPUSH
32556: CALL_OW 310
32560: IFFALSE 32571
// ComExit ( driver ) ;
32562: LD_VAR 0 18
32566: PPUSH
32567: CALL 57984 0 1
// AddComEnterUnit ( driver , tmp ) ;
32571: LD_VAR 0 18
32575: PPUSH
32576: LD_VAR 0 13
32580: PPUSH
32581: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32585: LD_VAR 0 18
32589: PPUSH
32590: LD_VAR 0 7
32594: PPUSH
32595: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32599: LD_VAR 0 18
32603: PPUSH
32604: CALL_OW 181
// end ; continue ;
32608: GO 32260
// end ; if not cleaners or not tmp in cleaners then
32610: LD_VAR 0 6
32614: NOT
32615: PUSH
32616: LD_VAR 0 13
32620: PUSH
32621: LD_VAR 0 6
32625: IN
32626: NOT
32627: OR
32628: IFFALSE 32935
// begin if dep then
32630: LD_VAR 0 17
32634: IFFALSE 32770
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32636: LD_ADDR_VAR 0 16
32640: PUSH
32641: LD_VAR 0 17
32645: PUSH
32646: LD_INT 1
32648: ARRAY
32649: PPUSH
32650: CALL_OW 250
32654: PPUSH
32655: LD_VAR 0 17
32659: PUSH
32660: LD_INT 1
32662: ARRAY
32663: PPUSH
32664: CALL_OW 254
32668: PPUSH
32669: LD_INT 5
32671: PPUSH
32672: CALL_OW 272
32676: PUSH
32677: LD_VAR 0 17
32681: PUSH
32682: LD_INT 1
32684: ARRAY
32685: PPUSH
32686: CALL_OW 251
32690: PPUSH
32691: LD_VAR 0 17
32695: PUSH
32696: LD_INT 1
32698: ARRAY
32699: PPUSH
32700: CALL_OW 254
32704: PPUSH
32705: LD_INT 5
32707: PPUSH
32708: CALL_OW 273
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32717: LD_VAR 0 16
32721: PUSH
32722: LD_INT 1
32724: ARRAY
32725: PPUSH
32726: LD_VAR 0 16
32730: PUSH
32731: LD_INT 2
32733: ARRAY
32734: PPUSH
32735: CALL_OW 488
32739: IFFALSE 32770
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32741: LD_VAR 0 13
32745: PPUSH
32746: LD_VAR 0 16
32750: PUSH
32751: LD_INT 1
32753: ARRAY
32754: PPUSH
32755: LD_VAR 0 16
32759: PUSH
32760: LD_INT 2
32762: ARRAY
32763: PPUSH
32764: CALL_OW 111
// continue ;
32768: GO 32260
// end ; end ; r := GetDir ( tmp ) ;
32770: LD_ADDR_VAR 0 15
32774: PUSH
32775: LD_VAR 0 13
32779: PPUSH
32780: CALL_OW 254
32784: ST_TO_ADDR
// if r = 5 then
32785: LD_VAR 0 15
32789: PUSH
32790: LD_INT 5
32792: EQUAL
32793: IFFALSE 32803
// r := 0 ;
32795: LD_ADDR_VAR 0 15
32799: PUSH
32800: LD_INT 0
32802: ST_TO_ADDR
// for j = r to 5 do
32803: LD_ADDR_VAR 0 10
32807: PUSH
32808: DOUBLE
32809: LD_VAR 0 15
32813: DEC
32814: ST_TO_ADDR
32815: LD_INT 5
32817: PUSH
32818: FOR_TO
32819: IFFALSE 32933
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32821: LD_ADDR_VAR 0 11
32825: PUSH
32826: LD_VAR 0 13
32830: PPUSH
32831: CALL_OW 250
32835: PPUSH
32836: LD_VAR 0 10
32840: PPUSH
32841: LD_INT 2
32843: PPUSH
32844: CALL_OW 272
32848: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32849: LD_ADDR_VAR 0 12
32853: PUSH
32854: LD_VAR 0 13
32858: PPUSH
32859: CALL_OW 251
32863: PPUSH
32864: LD_VAR 0 10
32868: PPUSH
32869: LD_INT 2
32871: PPUSH
32872: CALL_OW 273
32876: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32877: LD_VAR 0 11
32881: PPUSH
32882: LD_VAR 0 12
32886: PPUSH
32887: CALL_OW 488
32891: PUSH
32892: LD_VAR 0 11
32896: PPUSH
32897: LD_VAR 0 12
32901: PPUSH
32902: CALL_OW 428
32906: NOT
32907: AND
32908: IFFALSE 32931
// begin ComMoveXY ( tmp , _x , _y ) ;
32910: LD_VAR 0 13
32914: PPUSH
32915: LD_VAR 0 11
32919: PPUSH
32920: LD_VAR 0 12
32924: PPUSH
32925: CALL_OW 111
// break ;
32929: GO 32933
// end ; end ;
32931: GO 32818
32933: POP
32934: POP
// end ; end ;
32935: GO 32260
32937: POP
32938: POP
// end ;
32939: LD_VAR 0 8
32943: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32944: LD_INT 0
32946: PPUSH
// result := true ;
32947: LD_ADDR_VAR 0 3
32951: PUSH
32952: LD_INT 1
32954: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32955: LD_VAR 0 2
32959: PUSH
32960: LD_INT 24
32962: DOUBLE
32963: EQUAL
32964: IFTRUE 32974
32966: LD_INT 33
32968: DOUBLE
32969: EQUAL
32970: IFTRUE 32974
32972: GO 32999
32974: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32975: LD_ADDR_VAR 0 3
32979: PUSH
32980: LD_INT 32
32982: PPUSH
32983: LD_VAR 0 1
32987: PPUSH
32988: CALL_OW 321
32992: PUSH
32993: LD_INT 2
32995: EQUAL
32996: ST_TO_ADDR
32997: GO 33315
32999: LD_INT 20
33001: DOUBLE
33002: EQUAL
33003: IFTRUE 33007
33005: GO 33032
33007: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
33008: LD_ADDR_VAR 0 3
33012: PUSH
33013: LD_INT 6
33015: PPUSH
33016: LD_VAR 0 1
33020: PPUSH
33021: CALL_OW 321
33025: PUSH
33026: LD_INT 2
33028: EQUAL
33029: ST_TO_ADDR
33030: GO 33315
33032: LD_INT 22
33034: DOUBLE
33035: EQUAL
33036: IFTRUE 33046
33038: LD_INT 36
33040: DOUBLE
33041: EQUAL
33042: IFTRUE 33046
33044: GO 33071
33046: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
33047: LD_ADDR_VAR 0 3
33051: PUSH
33052: LD_INT 15
33054: PPUSH
33055: LD_VAR 0 1
33059: PPUSH
33060: CALL_OW 321
33064: PUSH
33065: LD_INT 2
33067: EQUAL
33068: ST_TO_ADDR
33069: GO 33315
33071: LD_INT 30
33073: DOUBLE
33074: EQUAL
33075: IFTRUE 33079
33077: GO 33104
33079: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
33080: LD_ADDR_VAR 0 3
33084: PUSH
33085: LD_INT 20
33087: PPUSH
33088: LD_VAR 0 1
33092: PPUSH
33093: CALL_OW 321
33097: PUSH
33098: LD_INT 2
33100: EQUAL
33101: ST_TO_ADDR
33102: GO 33315
33104: LD_INT 28
33106: DOUBLE
33107: EQUAL
33108: IFTRUE 33118
33110: LD_INT 21
33112: DOUBLE
33113: EQUAL
33114: IFTRUE 33118
33116: GO 33143
33118: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
33119: LD_ADDR_VAR 0 3
33123: PUSH
33124: LD_INT 21
33126: PPUSH
33127: LD_VAR 0 1
33131: PPUSH
33132: CALL_OW 321
33136: PUSH
33137: LD_INT 2
33139: EQUAL
33140: ST_TO_ADDR
33141: GO 33315
33143: LD_INT 16
33145: DOUBLE
33146: EQUAL
33147: IFTRUE 33151
33149: GO 33176
33151: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
33152: LD_ADDR_VAR 0 3
33156: PUSH
33157: LD_INT 84
33159: PPUSH
33160: LD_VAR 0 1
33164: PPUSH
33165: CALL_OW 321
33169: PUSH
33170: LD_INT 2
33172: EQUAL
33173: ST_TO_ADDR
33174: GO 33315
33176: LD_INT 19
33178: DOUBLE
33179: EQUAL
33180: IFTRUE 33190
33182: LD_INT 23
33184: DOUBLE
33185: EQUAL
33186: IFTRUE 33190
33188: GO 33215
33190: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
33191: LD_ADDR_VAR 0 3
33195: PUSH
33196: LD_INT 83
33198: PPUSH
33199: LD_VAR 0 1
33203: PPUSH
33204: CALL_OW 321
33208: PUSH
33209: LD_INT 2
33211: EQUAL
33212: ST_TO_ADDR
33213: GO 33315
33215: LD_INT 17
33217: DOUBLE
33218: EQUAL
33219: IFTRUE 33223
33221: GO 33248
33223: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
33224: LD_ADDR_VAR 0 3
33228: PUSH
33229: LD_INT 39
33231: PPUSH
33232: LD_VAR 0 1
33236: PPUSH
33237: CALL_OW 321
33241: PUSH
33242: LD_INT 2
33244: EQUAL
33245: ST_TO_ADDR
33246: GO 33315
33248: LD_INT 18
33250: DOUBLE
33251: EQUAL
33252: IFTRUE 33256
33254: GO 33281
33256: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
33257: LD_ADDR_VAR 0 3
33261: PUSH
33262: LD_INT 40
33264: PPUSH
33265: LD_VAR 0 1
33269: PPUSH
33270: CALL_OW 321
33274: PUSH
33275: LD_INT 2
33277: EQUAL
33278: ST_TO_ADDR
33279: GO 33315
33281: LD_INT 27
33283: DOUBLE
33284: EQUAL
33285: IFTRUE 33289
33287: GO 33314
33289: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
33290: LD_ADDR_VAR 0 3
33294: PUSH
33295: LD_INT 35
33297: PPUSH
33298: LD_VAR 0 1
33302: PPUSH
33303: CALL_OW 321
33307: PUSH
33308: LD_INT 2
33310: EQUAL
33311: ST_TO_ADDR
33312: GO 33315
33314: POP
// end ;
33315: LD_VAR 0 3
33319: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
33320: LD_INT 0
33322: PPUSH
33323: PPUSH
33324: PPUSH
33325: PPUSH
33326: PPUSH
33327: PPUSH
33328: PPUSH
33329: PPUSH
33330: PPUSH
33331: PPUSH
33332: PPUSH
// result := false ;
33333: LD_ADDR_VAR 0 6
33337: PUSH
33338: LD_INT 0
33340: ST_TO_ADDR
// if btype = b_depot then
33341: LD_VAR 0 2
33345: PUSH
33346: LD_INT 0
33348: EQUAL
33349: IFFALSE 33361
// begin result := true ;
33351: LD_ADDR_VAR 0 6
33355: PUSH
33356: LD_INT 1
33358: ST_TO_ADDR
// exit ;
33359: GO 34187
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
33361: LD_VAR 0 1
33365: NOT
33366: PUSH
33367: LD_VAR 0 1
33371: PPUSH
33372: CALL_OW 266
33376: PUSH
33377: LD_INT 0
33379: PUSH
33380: LD_INT 1
33382: PUSH
33383: EMPTY
33384: LIST
33385: LIST
33386: IN
33387: NOT
33388: OR
33389: PUSH
33390: LD_VAR 0 2
33394: NOT
33395: OR
33396: PUSH
33397: LD_VAR 0 5
33401: PUSH
33402: LD_INT 0
33404: PUSH
33405: LD_INT 1
33407: PUSH
33408: LD_INT 2
33410: PUSH
33411: LD_INT 3
33413: PUSH
33414: LD_INT 4
33416: PUSH
33417: LD_INT 5
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: LIST
33424: LIST
33425: LIST
33426: LIST
33427: IN
33428: NOT
33429: OR
33430: PUSH
33431: LD_VAR 0 3
33435: PPUSH
33436: LD_VAR 0 4
33440: PPUSH
33441: CALL_OW 488
33445: NOT
33446: OR
33447: IFFALSE 33451
// exit ;
33449: GO 34187
// side := GetSide ( depot ) ;
33451: LD_ADDR_VAR 0 9
33455: PUSH
33456: LD_VAR 0 1
33460: PPUSH
33461: CALL_OW 255
33465: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33466: LD_VAR 0 9
33470: PPUSH
33471: LD_VAR 0 2
33475: PPUSH
33476: CALL 32944 0 2
33480: NOT
33481: IFFALSE 33485
// exit ;
33483: GO 34187
// pom := GetBase ( depot ) ;
33485: LD_ADDR_VAR 0 10
33489: PUSH
33490: LD_VAR 0 1
33494: PPUSH
33495: CALL_OW 274
33499: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33500: LD_ADDR_VAR 0 11
33504: PUSH
33505: LD_VAR 0 2
33509: PPUSH
33510: LD_VAR 0 1
33514: PPUSH
33515: CALL_OW 248
33519: PPUSH
33520: CALL_OW 450
33524: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33525: LD_VAR 0 10
33529: PPUSH
33530: LD_INT 1
33532: PPUSH
33533: CALL_OW 275
33537: PUSH
33538: LD_VAR 0 11
33542: PUSH
33543: LD_INT 1
33545: ARRAY
33546: GREATEREQUAL
33547: PUSH
33548: LD_VAR 0 10
33552: PPUSH
33553: LD_INT 2
33555: PPUSH
33556: CALL_OW 275
33560: PUSH
33561: LD_VAR 0 11
33565: PUSH
33566: LD_INT 2
33568: ARRAY
33569: GREATEREQUAL
33570: AND
33571: PUSH
33572: LD_VAR 0 10
33576: PPUSH
33577: LD_INT 3
33579: PPUSH
33580: CALL_OW 275
33584: PUSH
33585: LD_VAR 0 11
33589: PUSH
33590: LD_INT 3
33592: ARRAY
33593: GREATEREQUAL
33594: AND
33595: NOT
33596: IFFALSE 33600
// exit ;
33598: GO 34187
// if GetBType ( depot ) = b_depot then
33600: LD_VAR 0 1
33604: PPUSH
33605: CALL_OW 266
33609: PUSH
33610: LD_INT 0
33612: EQUAL
33613: IFFALSE 33625
// dist := 28 else
33615: LD_ADDR_VAR 0 14
33619: PUSH
33620: LD_INT 28
33622: ST_TO_ADDR
33623: GO 33633
// dist := 36 ;
33625: LD_ADDR_VAR 0 14
33629: PUSH
33630: LD_INT 36
33632: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33633: LD_VAR 0 1
33637: PPUSH
33638: LD_VAR 0 3
33642: PPUSH
33643: LD_VAR 0 4
33647: PPUSH
33648: CALL_OW 297
33652: PUSH
33653: LD_VAR 0 14
33657: GREATER
33658: IFFALSE 33662
// exit ;
33660: GO 34187
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33662: LD_ADDR_VAR 0 12
33666: PUSH
33667: LD_VAR 0 2
33671: PPUSH
33672: LD_VAR 0 3
33676: PPUSH
33677: LD_VAR 0 4
33681: PPUSH
33682: LD_VAR 0 5
33686: PPUSH
33687: LD_VAR 0 1
33691: PPUSH
33692: CALL_OW 248
33696: PPUSH
33697: LD_INT 0
33699: PPUSH
33700: CALL 34192 0 6
33704: ST_TO_ADDR
// if not hexes then
33705: LD_VAR 0 12
33709: NOT
33710: IFFALSE 33714
// exit ;
33712: GO 34187
// hex := GetHexInfo ( x , y ) ;
33714: LD_ADDR_VAR 0 15
33718: PUSH
33719: LD_VAR 0 3
33723: PPUSH
33724: LD_VAR 0 4
33728: PPUSH
33729: CALL_OW 546
33733: ST_TO_ADDR
// if hex [ 1 ] then
33734: LD_VAR 0 15
33738: PUSH
33739: LD_INT 1
33741: ARRAY
33742: IFFALSE 33746
// exit ;
33744: GO 34187
// height := hex [ 2 ] ;
33746: LD_ADDR_VAR 0 13
33750: PUSH
33751: LD_VAR 0 15
33755: PUSH
33756: LD_INT 2
33758: ARRAY
33759: ST_TO_ADDR
// for i = 1 to hexes do
33760: LD_ADDR_VAR 0 7
33764: PUSH
33765: DOUBLE
33766: LD_INT 1
33768: DEC
33769: ST_TO_ADDR
33770: LD_VAR 0 12
33774: PUSH
33775: FOR_TO
33776: IFFALSE 34106
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33778: LD_VAR 0 12
33782: PUSH
33783: LD_VAR 0 7
33787: ARRAY
33788: PUSH
33789: LD_INT 1
33791: ARRAY
33792: PPUSH
33793: LD_VAR 0 12
33797: PUSH
33798: LD_VAR 0 7
33802: ARRAY
33803: PUSH
33804: LD_INT 2
33806: ARRAY
33807: PPUSH
33808: CALL_OW 488
33812: NOT
33813: PUSH
33814: LD_VAR 0 12
33818: PUSH
33819: LD_VAR 0 7
33823: ARRAY
33824: PUSH
33825: LD_INT 1
33827: ARRAY
33828: PPUSH
33829: LD_VAR 0 12
33833: PUSH
33834: LD_VAR 0 7
33838: ARRAY
33839: PUSH
33840: LD_INT 2
33842: ARRAY
33843: PPUSH
33844: CALL_OW 428
33848: PUSH
33849: LD_INT 0
33851: GREATER
33852: OR
33853: PUSH
33854: LD_VAR 0 12
33858: PUSH
33859: LD_VAR 0 7
33863: ARRAY
33864: PUSH
33865: LD_INT 1
33867: ARRAY
33868: PPUSH
33869: LD_VAR 0 12
33873: PUSH
33874: LD_VAR 0 7
33878: ARRAY
33879: PUSH
33880: LD_INT 2
33882: ARRAY
33883: PPUSH
33884: CALL_OW 351
33888: OR
33889: IFFALSE 33895
// exit ;
33891: POP
33892: POP
33893: GO 34187
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33895: LD_ADDR_VAR 0 8
33899: PUSH
33900: LD_VAR 0 12
33904: PUSH
33905: LD_VAR 0 7
33909: ARRAY
33910: PUSH
33911: LD_INT 1
33913: ARRAY
33914: PPUSH
33915: LD_VAR 0 12
33919: PUSH
33920: LD_VAR 0 7
33924: ARRAY
33925: PUSH
33926: LD_INT 2
33928: ARRAY
33929: PPUSH
33930: CALL_OW 546
33934: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33935: LD_VAR 0 8
33939: PUSH
33940: LD_INT 1
33942: ARRAY
33943: PUSH
33944: LD_VAR 0 8
33948: PUSH
33949: LD_INT 2
33951: ARRAY
33952: PUSH
33953: LD_VAR 0 13
33957: PUSH
33958: LD_INT 2
33960: PLUS
33961: GREATER
33962: OR
33963: PUSH
33964: LD_VAR 0 8
33968: PUSH
33969: LD_INT 2
33971: ARRAY
33972: PUSH
33973: LD_VAR 0 13
33977: PUSH
33978: LD_INT 2
33980: MINUS
33981: LESS
33982: OR
33983: PUSH
33984: LD_VAR 0 8
33988: PUSH
33989: LD_INT 3
33991: ARRAY
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: LD_INT 8
33998: PUSH
33999: LD_INT 9
34001: PUSH
34002: LD_INT 10
34004: PUSH
34005: LD_INT 11
34007: PUSH
34008: LD_INT 12
34010: PUSH
34011: LD_INT 13
34013: PUSH
34014: LD_INT 16
34016: PUSH
34017: LD_INT 17
34019: PUSH
34020: LD_INT 18
34022: PUSH
34023: LD_INT 19
34025: PUSH
34026: LD_INT 20
34028: PUSH
34029: LD_INT 21
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: IN
34047: NOT
34048: OR
34049: PUSH
34050: LD_VAR 0 8
34054: PUSH
34055: LD_INT 5
34057: ARRAY
34058: NOT
34059: OR
34060: PUSH
34061: LD_VAR 0 8
34065: PUSH
34066: LD_INT 6
34068: ARRAY
34069: PUSH
34070: LD_INT 1
34072: PUSH
34073: LD_INT 2
34075: PUSH
34076: LD_INT 7
34078: PUSH
34079: LD_INT 9
34081: PUSH
34082: LD_INT 10
34084: PUSH
34085: LD_INT 11
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: IN
34096: NOT
34097: OR
34098: IFFALSE 34104
// exit ;
34100: POP
34101: POP
34102: GO 34187
// end ;
34104: GO 33775
34106: POP
34107: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
34108: LD_VAR 0 9
34112: PPUSH
34113: LD_VAR 0 3
34117: PPUSH
34118: LD_VAR 0 4
34122: PPUSH
34123: LD_INT 20
34125: PPUSH
34126: CALL 26110 0 4
34130: PUSH
34131: LD_INT 4
34133: ARRAY
34134: IFFALSE 34138
// exit ;
34136: GO 34187
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
34138: LD_VAR 0 2
34142: PUSH
34143: LD_INT 29
34145: PUSH
34146: LD_INT 30
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: IN
34153: PUSH
34154: LD_VAR 0 3
34158: PPUSH
34159: LD_VAR 0 4
34163: PPUSH
34164: LD_VAR 0 9
34168: PPUSH
34169: CALL_OW 440
34173: NOT
34174: AND
34175: IFFALSE 34179
// exit ;
34177: GO 34187
// result := true ;
34179: LD_ADDR_VAR 0 6
34183: PUSH
34184: LD_INT 1
34186: ST_TO_ADDR
// end ;
34187: LD_VAR 0 6
34191: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
34192: LD_INT 0
34194: PPUSH
34195: PPUSH
34196: PPUSH
34197: PPUSH
34198: PPUSH
34199: PPUSH
34200: PPUSH
34201: PPUSH
34202: PPUSH
34203: PPUSH
34204: PPUSH
34205: PPUSH
34206: PPUSH
34207: PPUSH
34208: PPUSH
34209: PPUSH
34210: PPUSH
34211: PPUSH
34212: PPUSH
34213: PPUSH
34214: PPUSH
34215: PPUSH
34216: PPUSH
34217: PPUSH
34218: PPUSH
34219: PPUSH
34220: PPUSH
34221: PPUSH
34222: PPUSH
34223: PPUSH
34224: PPUSH
34225: PPUSH
34226: PPUSH
34227: PPUSH
34228: PPUSH
34229: PPUSH
34230: PPUSH
34231: PPUSH
34232: PPUSH
34233: PPUSH
34234: PPUSH
34235: PPUSH
34236: PPUSH
34237: PPUSH
34238: PPUSH
34239: PPUSH
34240: PPUSH
34241: PPUSH
34242: PPUSH
34243: PPUSH
34244: PPUSH
34245: PPUSH
34246: PPUSH
34247: PPUSH
34248: PPUSH
34249: PPUSH
34250: PPUSH
34251: PPUSH
// result = [ ] ;
34252: LD_ADDR_VAR 0 7
34256: PUSH
34257: EMPTY
34258: ST_TO_ADDR
// temp_list = [ ] ;
34259: LD_ADDR_VAR 0 9
34263: PUSH
34264: EMPTY
34265: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
34266: LD_VAR 0 4
34270: PUSH
34271: LD_INT 0
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: LD_INT 2
34279: PUSH
34280: LD_INT 3
34282: PUSH
34283: LD_INT 4
34285: PUSH
34286: LD_INT 5
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: LIST
34293: LIST
34294: LIST
34295: LIST
34296: IN
34297: NOT
34298: PUSH
34299: LD_VAR 0 1
34303: PUSH
34304: LD_INT 0
34306: PUSH
34307: LD_INT 1
34309: PUSH
34310: EMPTY
34311: LIST
34312: LIST
34313: IN
34314: PUSH
34315: LD_VAR 0 5
34319: PUSH
34320: LD_INT 1
34322: PUSH
34323: LD_INT 2
34325: PUSH
34326: LD_INT 3
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: LIST
34333: IN
34334: NOT
34335: AND
34336: OR
34337: IFFALSE 34341
// exit ;
34339: GO 52732
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
34341: LD_VAR 0 1
34345: PUSH
34346: LD_INT 6
34348: PUSH
34349: LD_INT 7
34351: PUSH
34352: LD_INT 8
34354: PUSH
34355: LD_INT 13
34357: PUSH
34358: LD_INT 12
34360: PUSH
34361: LD_INT 15
34363: PUSH
34364: LD_INT 11
34366: PUSH
34367: LD_INT 14
34369: PUSH
34370: LD_INT 10
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: IN
34384: IFFALSE 34394
// btype = b_lab ;
34386: LD_ADDR_VAR 0 1
34390: PUSH
34391: LD_INT 6
34393: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34394: LD_VAR 0 6
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: LD_INT 1
34404: PUSH
34405: LD_INT 2
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: LIST
34412: IN
34413: NOT
34414: PUSH
34415: LD_VAR 0 1
34419: PUSH
34420: LD_INT 0
34422: PUSH
34423: LD_INT 1
34425: PUSH
34426: LD_INT 2
34428: PUSH
34429: LD_INT 3
34431: PUSH
34432: LD_INT 6
34434: PUSH
34435: LD_INT 36
34437: PUSH
34438: LD_INT 4
34440: PUSH
34441: LD_INT 5
34443: PUSH
34444: LD_INT 31
34446: PUSH
34447: LD_INT 32
34449: PUSH
34450: LD_INT 33
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: LIST
34461: LIST
34462: LIST
34463: LIST
34464: LIST
34465: IN
34466: NOT
34467: PUSH
34468: LD_VAR 0 6
34472: PUSH
34473: LD_INT 1
34475: EQUAL
34476: AND
34477: OR
34478: PUSH
34479: LD_VAR 0 1
34483: PUSH
34484: LD_INT 2
34486: PUSH
34487: LD_INT 3
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: IN
34494: NOT
34495: PUSH
34496: LD_VAR 0 6
34500: PUSH
34501: LD_INT 2
34503: EQUAL
34504: AND
34505: OR
34506: IFFALSE 34516
// mode = 0 ;
34508: LD_ADDR_VAR 0 6
34512: PUSH
34513: LD_INT 0
34515: ST_TO_ADDR
// case mode of 0 :
34516: LD_VAR 0 6
34520: PUSH
34521: LD_INT 0
34523: DOUBLE
34524: EQUAL
34525: IFTRUE 34529
34527: GO 45982
34529: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34530: LD_ADDR_VAR 0 11
34534: PUSH
34535: LD_INT 0
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 0
34547: PUSH
34548: LD_INT 1
34550: NEG
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: LD_INT 1
34558: PUSH
34559: LD_INT 0
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: LD_INT 1
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 0
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 1
34588: NEG
34589: PUSH
34590: LD_INT 0
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: LD_INT 1
34599: NEG
34600: PUSH
34601: LD_INT 1
34603: NEG
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 1
34611: NEG
34612: PUSH
34613: LD_INT 2
34615: NEG
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 0
34623: PUSH
34624: LD_INT 2
34626: NEG
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 1
34634: PUSH
34635: LD_INT 1
34637: NEG
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 1
34645: PUSH
34646: LD_INT 2
34648: PUSH
34649: EMPTY
34650: LIST
34651: LIST
34652: PUSH
34653: LD_INT 0
34655: PUSH
34656: LD_INT 2
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: NEG
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 1
34676: PUSH
34677: LD_INT 3
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 0
34686: PUSH
34687: LD_INT 3
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 1
34696: NEG
34697: PUSH
34698: LD_INT 2
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34723: LD_ADDR_VAR 0 12
34727: PUSH
34728: LD_INT 0
34730: PUSH
34731: LD_INT 0
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 0
34740: PUSH
34741: LD_INT 1
34743: NEG
34744: PUSH
34745: EMPTY
34746: LIST
34747: LIST
34748: PUSH
34749: LD_INT 1
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: EMPTY
34756: LIST
34757: LIST
34758: PUSH
34759: LD_INT 1
34761: PUSH
34762: LD_INT 1
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 0
34771: PUSH
34772: LD_INT 1
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 1
34781: NEG
34782: PUSH
34783: LD_INT 0
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 1
34792: NEG
34793: PUSH
34794: LD_INT 1
34796: NEG
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 1
34804: PUSH
34805: LD_INT 1
34807: NEG
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: LD_INT 2
34815: PUSH
34816: LD_INT 0
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 2
34825: PUSH
34826: LD_INT 1
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 1
34835: NEG
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 2
34846: NEG
34847: PUSH
34848: LD_INT 0
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 2
34857: NEG
34858: PUSH
34859: LD_INT 1
34861: NEG
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PUSH
34867: LD_INT 2
34869: NEG
34870: PUSH
34871: LD_INT 1
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 3
34880: NEG
34881: PUSH
34882: LD_INT 0
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 3
34891: NEG
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: LIST
34912: LIST
34913: LIST
34914: LIST
34915: LIST
34916: LIST
34917: LIST
34918: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34919: LD_ADDR_VAR 0 13
34923: PUSH
34924: LD_INT 0
34926: PUSH
34927: LD_INT 0
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 0
34936: PUSH
34937: LD_INT 1
34939: NEG
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: LD_INT 0
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 1
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 0
34967: PUSH
34968: LD_INT 1
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: LD_INT 0
34981: PUSH
34982: EMPTY
34983: LIST
34984: LIST
34985: PUSH
34986: LD_INT 1
34988: NEG
34989: PUSH
34990: LD_INT 1
34992: NEG
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: LD_INT 1
35000: NEG
35001: PUSH
35002: LD_INT 2
35004: NEG
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 2
35012: PUSH
35013: LD_INT 1
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: PUSH
35020: LD_INT 2
35022: PUSH
35023: LD_INT 2
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: LD_INT 2
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 2
35042: NEG
35043: PUSH
35044: LD_INT 1
35046: NEG
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 2
35054: NEG
35055: PUSH
35056: LD_INT 2
35058: NEG
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 2
35066: NEG
35067: PUSH
35068: LD_INT 3
35070: NEG
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: PUSH
35076: LD_INT 3
35078: NEG
35079: PUSH
35080: LD_INT 2
35082: NEG
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 3
35090: NEG
35091: PUSH
35092: LD_INT 3
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35118: LD_ADDR_VAR 0 14
35122: PUSH
35123: LD_INT 0
35125: PUSH
35126: LD_INT 0
35128: PUSH
35129: EMPTY
35130: LIST
35131: LIST
35132: PUSH
35133: LD_INT 0
35135: PUSH
35136: LD_INT 1
35138: NEG
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: PUSH
35147: LD_INT 0
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 1
35156: PUSH
35157: LD_INT 1
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 0
35166: PUSH
35167: LD_INT 1
35169: PUSH
35170: EMPTY
35171: LIST
35172: LIST
35173: PUSH
35174: LD_INT 1
35176: NEG
35177: PUSH
35178: LD_INT 0
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 1
35187: NEG
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: EMPTY
35194: LIST
35195: LIST
35196: PUSH
35197: LD_INT 1
35199: NEG
35200: PUSH
35201: LD_INT 2
35203: NEG
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 0
35211: PUSH
35212: LD_INT 2
35214: NEG
35215: PUSH
35216: EMPTY
35217: LIST
35218: LIST
35219: PUSH
35220: LD_INT 1
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: PUSH
35234: LD_INT 2
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 0
35243: PUSH
35244: LD_INT 2
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 1
35253: NEG
35254: PUSH
35255: LD_INT 1
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 1
35264: NEG
35265: PUSH
35266: LD_INT 3
35268: NEG
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 0
35276: PUSH
35277: LD_INT 3
35279: NEG
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 1
35287: PUSH
35288: LD_INT 2
35290: NEG
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: LIST
35305: LIST
35306: LIST
35307: LIST
35308: LIST
35309: LIST
35310: LIST
35311: LIST
35312: LIST
35313: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35314: LD_ADDR_VAR 0 15
35318: PUSH
35319: LD_INT 0
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 0
35331: PUSH
35332: LD_INT 1
35334: NEG
35335: PUSH
35336: EMPTY
35337: LIST
35338: LIST
35339: PUSH
35340: LD_INT 1
35342: PUSH
35343: LD_INT 0
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 1
35352: PUSH
35353: LD_INT 1
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 0
35362: PUSH
35363: LD_INT 1
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: LD_INT 0
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: LD_INT 1
35383: NEG
35384: PUSH
35385: LD_INT 1
35387: NEG
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 1
35395: PUSH
35396: LD_INT 1
35398: NEG
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 2
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 2
35416: PUSH
35417: LD_INT 1
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 2
35437: NEG
35438: PUSH
35439: LD_INT 0
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 2
35448: NEG
35449: PUSH
35450: LD_INT 1
35452: NEG
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 2
35460: PUSH
35461: LD_INT 1
35463: NEG
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 3
35471: PUSH
35472: LD_INT 0
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 3
35481: PUSH
35482: LD_INT 1
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: LIST
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35507: LD_ADDR_VAR 0 16
35511: PUSH
35512: LD_INT 0
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 0
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: EMPTY
35530: LIST
35531: LIST
35532: PUSH
35533: LD_INT 1
35535: PUSH
35536: LD_INT 0
35538: PUSH
35539: EMPTY
35540: LIST
35541: LIST
35542: PUSH
35543: LD_INT 1
35545: PUSH
35546: LD_INT 1
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: LD_INT 0
35555: PUSH
35556: LD_INT 1
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 1
35565: NEG
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 1
35576: NEG
35577: PUSH
35578: LD_INT 1
35580: NEG
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 1
35588: NEG
35589: PUSH
35590: LD_INT 2
35592: NEG
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: LD_INT 2
35600: PUSH
35601: LD_INT 1
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 2
35610: PUSH
35611: LD_INT 2
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 1
35620: PUSH
35621: LD_INT 2
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 2
35630: NEG
35631: PUSH
35632: LD_INT 1
35634: NEG
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 2
35642: NEG
35643: PUSH
35644: LD_INT 2
35646: NEG
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 3
35654: PUSH
35655: LD_INT 2
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 3
35664: PUSH
35665: LD_INT 3
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 2
35674: PUSH
35675: LD_INT 3
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: EMPTY
35683: LIST
35684: LIST
35685: LIST
35686: LIST
35687: LIST
35688: LIST
35689: LIST
35690: LIST
35691: LIST
35692: LIST
35693: LIST
35694: LIST
35695: LIST
35696: LIST
35697: LIST
35698: LIST
35699: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35700: LD_ADDR_VAR 0 17
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: LD_INT 0
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 0
35717: PUSH
35718: LD_INT 1
35720: NEG
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 1
35728: PUSH
35729: LD_INT 0
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 1
35738: PUSH
35739: LD_INT 1
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: LD_INT 1
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: LD_INT 0
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 1
35769: NEG
35770: PUSH
35771: LD_INT 1
35773: NEG
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: LD_INT 2
35785: NEG
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: LD_INT 2
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: LD_INT 1
35807: NEG
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 2
35815: PUSH
35816: LD_INT 0
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: PUSH
35823: LD_INT 2
35825: PUSH
35826: LD_INT 1
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 2
35835: PUSH
35836: LD_INT 2
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 1
35845: PUSH
35846: LD_INT 2
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 0
35855: PUSH
35856: LD_INT 2
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 1
35865: NEG
35866: PUSH
35867: LD_INT 1
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 2
35876: NEG
35877: PUSH
35878: LD_INT 0
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 2
35887: NEG
35888: PUSH
35889: LD_INT 1
35891: NEG
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 2
35899: NEG
35900: PUSH
35901: LD_INT 2
35903: NEG
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: LIST
35919: LIST
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35930: LD_ADDR_VAR 0 18
35934: PUSH
35935: LD_INT 0
35937: PUSH
35938: LD_INT 0
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: LD_INT 0
35947: PUSH
35948: LD_INT 1
35950: NEG
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 1
35958: PUSH
35959: LD_INT 0
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 1
35968: PUSH
35969: LD_INT 1
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: LD_INT 1
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: LD_INT 0
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 1
35999: NEG
36000: PUSH
36001: LD_INT 1
36003: NEG
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: LD_INT 2
36015: NEG
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 0
36023: PUSH
36024: LD_INT 2
36026: NEG
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: PUSH
36035: LD_INT 1
36037: NEG
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 2
36045: PUSH
36046: LD_INT 0
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 2
36055: PUSH
36056: LD_INT 1
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 2
36065: PUSH
36066: LD_INT 2
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 1
36075: PUSH
36076: LD_INT 2
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 0
36085: PUSH
36086: LD_INT 2
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: PUSH
36093: LD_INT 1
36095: NEG
36096: PUSH
36097: LD_INT 1
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 2
36106: NEG
36107: PUSH
36108: LD_INT 0
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 2
36117: NEG
36118: PUSH
36119: LD_INT 1
36121: NEG
36122: PUSH
36123: EMPTY
36124: LIST
36125: LIST
36126: PUSH
36127: LD_INT 2
36129: NEG
36130: PUSH
36131: LD_INT 2
36133: NEG
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36160: LD_ADDR_VAR 0 19
36164: PUSH
36165: LD_INT 0
36167: PUSH
36168: LD_INT 0
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 0
36177: PUSH
36178: LD_INT 1
36180: NEG
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 1
36188: PUSH
36189: LD_INT 0
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 1
36198: PUSH
36199: LD_INT 1
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 1
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: LD_INT 0
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 1
36229: NEG
36230: PUSH
36231: LD_INT 1
36233: NEG
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: LD_INT 2
36245: NEG
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: LD_INT 2
36256: NEG
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 1
36264: PUSH
36265: LD_INT 1
36267: NEG
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: LD_INT 2
36275: PUSH
36276: LD_INT 0
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: PUSH
36283: LD_INT 2
36285: PUSH
36286: LD_INT 1
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: PUSH
36293: LD_INT 2
36295: PUSH
36296: LD_INT 2
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 1
36305: PUSH
36306: LD_INT 2
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 0
36315: PUSH
36316: LD_INT 2
36318: PUSH
36319: EMPTY
36320: LIST
36321: LIST
36322: PUSH
36323: LD_INT 1
36325: NEG
36326: PUSH
36327: LD_INT 1
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: LD_INT 2
36336: NEG
36337: PUSH
36338: LD_INT 0
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 2
36347: NEG
36348: PUSH
36349: LD_INT 1
36351: NEG
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 2
36359: NEG
36360: PUSH
36361: LD_INT 2
36363: NEG
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: LIST
36381: LIST
36382: LIST
36383: LIST
36384: LIST
36385: LIST
36386: LIST
36387: LIST
36388: LIST
36389: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36390: LD_ADDR_VAR 0 20
36394: PUSH
36395: LD_INT 0
36397: PUSH
36398: LD_INT 0
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 0
36407: PUSH
36408: LD_INT 1
36410: NEG
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 1
36418: PUSH
36419: LD_INT 0
36421: PUSH
36422: EMPTY
36423: LIST
36424: LIST
36425: PUSH
36426: LD_INT 1
36428: PUSH
36429: LD_INT 1
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: PUSH
36436: LD_INT 0
36438: PUSH
36439: LD_INT 1
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 1
36448: NEG
36449: PUSH
36450: LD_INT 0
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: PUSH
36457: LD_INT 1
36459: NEG
36460: PUSH
36461: LD_INT 1
36463: NEG
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: LD_INT 2
36475: NEG
36476: PUSH
36477: EMPTY
36478: LIST
36479: LIST
36480: PUSH
36481: LD_INT 0
36483: PUSH
36484: LD_INT 2
36486: NEG
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PUSH
36492: LD_INT 1
36494: PUSH
36495: LD_INT 1
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 2
36505: PUSH
36506: LD_INT 0
36508: PUSH
36509: EMPTY
36510: LIST
36511: LIST
36512: PUSH
36513: LD_INT 2
36515: PUSH
36516: LD_INT 1
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PUSH
36523: LD_INT 2
36525: PUSH
36526: LD_INT 2
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PUSH
36533: LD_INT 1
36535: PUSH
36536: LD_INT 2
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 0
36545: PUSH
36546: LD_INT 2
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: LD_INT 1
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 2
36566: NEG
36567: PUSH
36568: LD_INT 0
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 2
36577: NEG
36578: PUSH
36579: LD_INT 1
36581: NEG
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: PUSH
36587: LD_INT 2
36589: NEG
36590: PUSH
36591: LD_INT 2
36593: NEG
36594: PUSH
36595: EMPTY
36596: LIST
36597: LIST
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36620: LD_ADDR_VAR 0 21
36624: PUSH
36625: LD_INT 0
36627: PUSH
36628: LD_INT 0
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 0
36637: PUSH
36638: LD_INT 1
36640: NEG
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 1
36648: PUSH
36649: LD_INT 0
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: LD_INT 1
36658: PUSH
36659: LD_INT 1
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: LD_INT 0
36668: PUSH
36669: LD_INT 1
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 1
36678: NEG
36679: PUSH
36680: LD_INT 0
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 1
36689: NEG
36690: PUSH
36691: LD_INT 1
36693: NEG
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 1
36701: NEG
36702: PUSH
36703: LD_INT 2
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 0
36713: PUSH
36714: LD_INT 2
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 1
36724: PUSH
36725: LD_INT 1
36727: NEG
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 2
36735: PUSH
36736: LD_INT 0
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 2
36745: PUSH
36746: LD_INT 1
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 2
36755: PUSH
36756: LD_INT 2
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 1
36765: PUSH
36766: LD_INT 2
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: LD_INT 2
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 1
36785: NEG
36786: PUSH
36787: LD_INT 1
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: NEG
36797: PUSH
36798: LD_INT 0
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 2
36807: NEG
36808: PUSH
36809: LD_INT 1
36811: NEG
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 2
36819: NEG
36820: PUSH
36821: LD_INT 2
36823: NEG
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36850: LD_ADDR_VAR 0 22
36854: PUSH
36855: LD_INT 0
36857: PUSH
36858: LD_INT 0
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 0
36867: PUSH
36868: LD_INT 1
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 1
36878: PUSH
36879: LD_INT 0
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 1
36888: PUSH
36889: LD_INT 1
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: LD_INT 0
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: LD_INT 1
36908: NEG
36909: PUSH
36910: LD_INT 0
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 1
36919: NEG
36920: PUSH
36921: LD_INT 1
36923: NEG
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: LD_INT 1
36931: NEG
36932: PUSH
36933: LD_INT 2
36935: NEG
36936: PUSH
36937: EMPTY
36938: LIST
36939: LIST
36940: PUSH
36941: LD_INT 0
36943: PUSH
36944: LD_INT 2
36946: NEG
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 1
36954: PUSH
36955: LD_INT 1
36957: NEG
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: LD_INT 2
36965: PUSH
36966: LD_INT 0
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 2
36975: PUSH
36976: LD_INT 1
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 2
36985: PUSH
36986: LD_INT 2
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: LD_INT 1
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: LD_INT 0
37005: PUSH
37006: LD_INT 2
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PUSH
37013: LD_INT 1
37015: NEG
37016: PUSH
37017: LD_INT 1
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: LD_INT 2
37026: NEG
37027: PUSH
37028: LD_INT 0
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 2
37037: NEG
37038: PUSH
37039: LD_INT 1
37041: NEG
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 2
37049: NEG
37050: PUSH
37051: LD_INT 2
37053: NEG
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: LIST
37065: LIST
37066: LIST
37067: LIST
37068: LIST
37069: LIST
37070: LIST
37071: LIST
37072: LIST
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37080: LD_ADDR_VAR 0 23
37084: PUSH
37085: LD_INT 0
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 0
37097: PUSH
37098: LD_INT 1
37100: NEG
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_INT 1
37108: PUSH
37109: LD_INT 0
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: LD_INT 1
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 0
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: EMPTY
37133: LIST
37134: LIST
37135: PUSH
37136: LD_INT 1
37138: NEG
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 1
37149: NEG
37150: PUSH
37151: LD_INT 1
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 1
37161: NEG
37162: PUSH
37163: LD_INT 2
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 0
37173: PUSH
37174: LD_INT 2
37176: NEG
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 1
37184: PUSH
37185: LD_INT 1
37187: NEG
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 2
37195: PUSH
37196: LD_INT 0
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 2
37205: PUSH
37206: LD_INT 1
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 2
37215: PUSH
37216: LD_INT 2
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 1
37225: PUSH
37226: LD_INT 2
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 0
37235: PUSH
37236: LD_INT 2
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: LD_INT 1
37245: NEG
37246: PUSH
37247: LD_INT 1
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 2
37256: NEG
37257: PUSH
37258: LD_INT 0
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 2
37267: NEG
37268: PUSH
37269: LD_INT 1
37271: NEG
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 2
37279: NEG
37280: PUSH
37281: LD_INT 2
37283: NEG
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 2
37291: NEG
37292: PUSH
37293: LD_INT 3
37295: NEG
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 1
37303: NEG
37304: PUSH
37305: LD_INT 3
37307: NEG
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 1
37315: PUSH
37316: LD_INT 2
37318: NEG
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 2
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: LIST
37339: LIST
37340: LIST
37341: LIST
37342: LIST
37343: LIST
37344: LIST
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
37360: LD_ADDR_VAR 0 24
37364: PUSH
37365: LD_INT 0
37367: PUSH
37368: LD_INT 0
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 0
37377: PUSH
37378: LD_INT 1
37380: NEG
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 1
37388: PUSH
37389: LD_INT 0
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: PUSH
37399: LD_INT 1
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 0
37408: PUSH
37409: LD_INT 1
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: LD_INT 1
37418: NEG
37419: PUSH
37420: LD_INT 0
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: LD_INT 1
37429: NEG
37430: PUSH
37431: LD_INT 1
37433: NEG
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 1
37441: NEG
37442: PUSH
37443: LD_INT 2
37445: NEG
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: LD_INT 0
37453: PUSH
37454: LD_INT 2
37456: NEG
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: LD_INT 1
37467: NEG
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: LD_INT 2
37475: PUSH
37476: LD_INT 0
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 2
37485: PUSH
37486: LD_INT 1
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 2
37495: PUSH
37496: LD_INT 2
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: PUSH
37503: LD_INT 1
37505: PUSH
37506: LD_INT 2
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 0
37515: PUSH
37516: LD_INT 2
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 1
37525: NEG
37526: PUSH
37527: LD_INT 1
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: PUSH
37534: LD_INT 2
37536: NEG
37537: PUSH
37538: LD_INT 0
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 2
37547: NEG
37548: PUSH
37549: LD_INT 1
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 2
37559: NEG
37560: PUSH
37561: LD_INT 2
37563: NEG
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: PUSH
37569: LD_INT 1
37571: PUSH
37572: LD_INT 2
37574: NEG
37575: PUSH
37576: EMPTY
37577: LIST
37578: LIST
37579: PUSH
37580: LD_INT 2
37582: PUSH
37583: LD_INT 1
37585: NEG
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 3
37593: PUSH
37594: LD_INT 1
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 3
37603: PUSH
37604: LD_INT 2
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: EMPTY
37612: LIST
37613: LIST
37614: LIST
37615: LIST
37616: LIST
37617: LIST
37618: LIST
37619: LIST
37620: LIST
37621: LIST
37622: LIST
37623: LIST
37624: LIST
37625: LIST
37626: LIST
37627: LIST
37628: LIST
37629: LIST
37630: LIST
37631: LIST
37632: LIST
37633: LIST
37634: LIST
37635: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37636: LD_ADDR_VAR 0 25
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: LD_INT 0
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: LD_INT 1
37656: NEG
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: PUSH
37665: LD_INT 0
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 1
37674: PUSH
37675: LD_INT 1
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: LD_INT 1
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 1
37694: NEG
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 1
37705: NEG
37706: PUSH
37707: LD_INT 1
37709: NEG
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PUSH
37715: LD_INT 1
37717: NEG
37718: PUSH
37719: LD_INT 2
37721: NEG
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 0
37729: PUSH
37730: LD_INT 2
37732: NEG
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: LD_INT 1
37743: NEG
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 2
37751: PUSH
37752: LD_INT 0
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 2
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: PUSH
37772: LD_INT 2
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 1
37781: PUSH
37782: LD_INT 2
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: LD_INT 2
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 1
37801: NEG
37802: PUSH
37803: LD_INT 1
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 2
37812: NEG
37813: PUSH
37814: LD_INT 0
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 2
37823: NEG
37824: PUSH
37825: LD_INT 1
37827: NEG
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 2
37835: NEG
37836: PUSH
37837: LD_INT 2
37839: NEG
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 3
37847: PUSH
37848: LD_INT 1
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 3
37857: PUSH
37858: LD_INT 2
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 2
37867: PUSH
37868: LD_INT 3
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 1
37877: PUSH
37878: LD_INT 3
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: LIST
37889: LIST
37890: LIST
37891: LIST
37892: LIST
37893: LIST
37894: LIST
37895: LIST
37896: LIST
37897: LIST
37898: LIST
37899: LIST
37900: LIST
37901: LIST
37902: LIST
37903: LIST
37904: LIST
37905: LIST
37906: LIST
37907: LIST
37908: LIST
37909: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37910: LD_ADDR_VAR 0 26
37914: PUSH
37915: LD_INT 0
37917: PUSH
37918: LD_INT 0
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 0
37927: PUSH
37928: LD_INT 1
37930: NEG
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: LD_INT 1
37938: PUSH
37939: LD_INT 0
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 1
37948: PUSH
37949: LD_INT 1
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: PUSH
37956: LD_INT 0
37958: PUSH
37959: LD_INT 1
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: PUSH
37966: LD_INT 1
37968: NEG
37969: PUSH
37970: LD_INT 0
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: LD_INT 1
37979: NEG
37980: PUSH
37981: LD_INT 1
37983: NEG
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 1
37991: NEG
37992: PUSH
37993: LD_INT 2
37995: NEG
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 0
38003: PUSH
38004: LD_INT 2
38006: NEG
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: LD_INT 1
38014: PUSH
38015: LD_INT 1
38017: NEG
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: LD_INT 2
38025: PUSH
38026: LD_INT 0
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 2
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 2
38045: PUSH
38046: LD_INT 2
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: LD_INT 1
38055: PUSH
38056: LD_INT 2
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: LD_INT 2
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: LD_INT 1
38075: NEG
38076: PUSH
38077: LD_INT 1
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 2
38086: NEG
38087: PUSH
38088: LD_INT 0
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 2
38097: NEG
38098: PUSH
38099: LD_INT 1
38101: NEG
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 2
38109: NEG
38110: PUSH
38111: LD_INT 2
38113: NEG
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 2
38121: PUSH
38122: LD_INT 3
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 1
38131: PUSH
38132: LD_INT 3
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 1
38141: NEG
38142: PUSH
38143: LD_INT 2
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 2
38152: NEG
38153: PUSH
38154: LD_INT 1
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: LIST
38165: LIST
38166: LIST
38167: LIST
38168: LIST
38169: LIST
38170: LIST
38171: LIST
38172: LIST
38173: LIST
38174: LIST
38175: LIST
38176: LIST
38177: LIST
38178: LIST
38179: LIST
38180: LIST
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38186: LD_ADDR_VAR 0 27
38190: PUSH
38191: LD_INT 0
38193: PUSH
38194: LD_INT 0
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 0
38203: PUSH
38204: LD_INT 1
38206: NEG
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 1
38214: PUSH
38215: LD_INT 0
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 1
38224: PUSH
38225: LD_INT 1
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: LD_INT 1
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 1
38244: NEG
38245: PUSH
38246: LD_INT 0
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: LD_INT 1
38255: NEG
38256: PUSH
38257: LD_INT 1
38259: NEG
38260: PUSH
38261: EMPTY
38262: LIST
38263: LIST
38264: PUSH
38265: LD_INT 1
38267: NEG
38268: PUSH
38269: LD_INT 2
38271: NEG
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 0
38279: PUSH
38280: LD_INT 2
38282: NEG
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 1
38290: PUSH
38291: LD_INT 1
38293: NEG
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: LD_INT 2
38301: PUSH
38302: LD_INT 0
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 2
38311: PUSH
38312: LD_INT 1
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 2
38321: PUSH
38322: LD_INT 2
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 1
38331: PUSH
38332: LD_INT 2
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 0
38341: PUSH
38342: LD_INT 2
38344: PUSH
38345: EMPTY
38346: LIST
38347: LIST
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: LD_INT 1
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 2
38362: NEG
38363: PUSH
38364: LD_INT 0
38366: PUSH
38367: EMPTY
38368: LIST
38369: LIST
38370: PUSH
38371: LD_INT 2
38373: NEG
38374: PUSH
38375: LD_INT 1
38377: NEG
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 2
38385: NEG
38386: PUSH
38387: LD_INT 2
38389: NEG
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PUSH
38395: LD_INT 1
38397: NEG
38398: PUSH
38399: LD_INT 2
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 2
38408: NEG
38409: PUSH
38410: LD_INT 1
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 3
38419: NEG
38420: PUSH
38421: LD_INT 1
38423: NEG
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 3
38431: NEG
38432: PUSH
38433: LD_INT 2
38435: NEG
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: LIST
38445: LIST
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: LIST
38451: LIST
38452: LIST
38453: LIST
38454: LIST
38455: LIST
38456: LIST
38457: LIST
38458: LIST
38459: LIST
38460: LIST
38461: LIST
38462: LIST
38463: LIST
38464: LIST
38465: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38466: LD_ADDR_VAR 0 28
38470: PUSH
38471: LD_INT 0
38473: PUSH
38474: LD_INT 0
38476: PUSH
38477: EMPTY
38478: LIST
38479: LIST
38480: PUSH
38481: LD_INT 0
38483: PUSH
38484: LD_INT 1
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 1
38494: PUSH
38495: LD_INT 0
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: PUSH
38505: LD_INT 1
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 0
38514: PUSH
38515: LD_INT 1
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: NEG
38525: PUSH
38526: LD_INT 0
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 1
38535: NEG
38536: PUSH
38537: LD_INT 1
38539: NEG
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 1
38547: NEG
38548: PUSH
38549: LD_INT 2
38551: NEG
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: LD_INT 2
38562: NEG
38563: PUSH
38564: EMPTY
38565: LIST
38566: LIST
38567: PUSH
38568: LD_INT 1
38570: PUSH
38571: LD_INT 1
38573: NEG
38574: PUSH
38575: EMPTY
38576: LIST
38577: LIST
38578: PUSH
38579: LD_INT 2
38581: PUSH
38582: LD_INT 0
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: PUSH
38589: LD_INT 2
38591: PUSH
38592: LD_INT 1
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 2
38601: PUSH
38602: LD_INT 2
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: LD_INT 1
38611: PUSH
38612: LD_INT 2
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: PUSH
38619: LD_INT 0
38621: PUSH
38622: LD_INT 2
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 1
38631: NEG
38632: PUSH
38633: LD_INT 1
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 2
38642: NEG
38643: PUSH
38644: LD_INT 0
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: LD_INT 2
38653: NEG
38654: PUSH
38655: LD_INT 1
38657: NEG
38658: PUSH
38659: EMPTY
38660: LIST
38661: LIST
38662: PUSH
38663: LD_INT 2
38665: NEG
38666: PUSH
38667: LD_INT 2
38669: NEG
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: LD_INT 2
38677: NEG
38678: PUSH
38679: LD_INT 3
38681: NEG
38682: PUSH
38683: EMPTY
38684: LIST
38685: LIST
38686: PUSH
38687: LD_INT 1
38689: NEG
38690: PUSH
38691: LD_INT 3
38693: NEG
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 3
38701: NEG
38702: PUSH
38703: LD_INT 1
38705: NEG
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: LD_INT 3
38713: NEG
38714: PUSH
38715: LD_INT 2
38717: NEG
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38748: LD_ADDR_VAR 0 29
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: LD_INT 0
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 0
38765: PUSH
38766: LD_INT 1
38768: NEG
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: LD_INT 0
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: LD_INT 1
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 0
38796: PUSH
38797: LD_INT 1
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 1
38806: NEG
38807: PUSH
38808: LD_INT 0
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 1
38817: NEG
38818: PUSH
38819: LD_INT 1
38821: NEG
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 1
38829: NEG
38830: PUSH
38831: LD_INT 2
38833: NEG
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 0
38841: PUSH
38842: LD_INT 2
38844: NEG
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 1
38852: PUSH
38853: LD_INT 1
38855: NEG
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 2
38863: PUSH
38864: LD_INT 0
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: LD_INT 2
38873: PUSH
38874: LD_INT 1
38876: PUSH
38877: EMPTY
38878: LIST
38879: LIST
38880: PUSH
38881: LD_INT 1
38883: PUSH
38884: LD_INT 2
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 0
38893: PUSH
38894: LD_INT 2
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 1
38903: NEG
38904: PUSH
38905: LD_INT 1
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 2
38914: NEG
38915: PUSH
38916: LD_INT 1
38918: NEG
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 2
38926: NEG
38927: PUSH
38928: LD_INT 2
38930: NEG
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 2
38938: NEG
38939: PUSH
38940: LD_INT 3
38942: NEG
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 2
38950: PUSH
38951: LD_INT 1
38953: NEG
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 3
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 1
38971: PUSH
38972: LD_INT 3
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 1
38981: NEG
38982: PUSH
38983: LD_INT 2
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 3
38992: NEG
38993: PUSH
38994: LD_INT 2
38996: NEG
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: LIST
39022: LIST
39023: LIST
39024: LIST
39025: LIST
39026: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39027: LD_ADDR_VAR 0 30
39031: PUSH
39032: LD_INT 0
39034: PUSH
39035: LD_INT 0
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 0
39044: PUSH
39045: LD_INT 1
39047: NEG
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: PUSH
39053: LD_INT 1
39055: PUSH
39056: LD_INT 0
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: LD_INT 1
39065: PUSH
39066: LD_INT 1
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: PUSH
39073: LD_INT 0
39075: PUSH
39076: LD_INT 1
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 1
39085: NEG
39086: PUSH
39087: LD_INT 0
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: LD_INT 1
39096: NEG
39097: PUSH
39098: LD_INT 1
39100: NEG
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 1
39108: NEG
39109: PUSH
39110: LD_INT 2
39112: NEG
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: LD_INT 2
39123: NEG
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 1
39131: PUSH
39132: LD_INT 1
39134: NEG
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: LD_INT 2
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 2
39152: PUSH
39153: LD_INT 1
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 2
39162: PUSH
39163: LD_INT 2
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 1
39172: PUSH
39173: LD_INT 2
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 1
39182: NEG
39183: PUSH
39184: LD_INT 1
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 2
39193: NEG
39194: PUSH
39195: LD_INT 0
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 2
39204: NEG
39205: PUSH
39206: LD_INT 1
39208: NEG
39209: PUSH
39210: EMPTY
39211: LIST
39212: LIST
39213: PUSH
39214: LD_INT 1
39216: NEG
39217: PUSH
39218: LD_INT 3
39220: NEG
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 1
39228: PUSH
39229: LD_INT 2
39231: NEG
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 3
39239: PUSH
39240: LD_INT 2
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 2
39249: PUSH
39250: LD_INT 3
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 2
39259: NEG
39260: PUSH
39261: LD_INT 1
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: LD_INT 3
39270: NEG
39271: PUSH
39272: LD_INT 1
39274: NEG
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: LIST
39299: LIST
39300: LIST
39301: LIST
39302: LIST
39303: LIST
39304: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39305: LD_ADDR_VAR 0 31
39309: PUSH
39310: LD_INT 0
39312: PUSH
39313: LD_INT 0
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: PUSH
39320: LD_INT 0
39322: PUSH
39323: LD_INT 1
39325: NEG
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: LD_INT 1
39333: PUSH
39334: LD_INT 0
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: LD_INT 1
39343: PUSH
39344: LD_INT 1
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PUSH
39351: LD_INT 0
39353: PUSH
39354: LD_INT 1
39356: PUSH
39357: EMPTY
39358: LIST
39359: LIST
39360: PUSH
39361: LD_INT 1
39363: NEG
39364: PUSH
39365: LD_INT 0
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 1
39374: NEG
39375: PUSH
39376: LD_INT 1
39378: NEG
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 1
39386: NEG
39387: PUSH
39388: LD_INT 2
39390: NEG
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: LD_INT 1
39398: PUSH
39399: LD_INT 1
39401: NEG
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: LD_INT 2
39409: PUSH
39410: LD_INT 0
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 2
39419: PUSH
39420: LD_INT 1
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 2
39429: PUSH
39430: LD_INT 2
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: LD_INT 2
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 0
39449: PUSH
39450: LD_INT 2
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 1
39459: NEG
39460: PUSH
39461: LD_INT 1
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 2
39470: NEG
39471: PUSH
39472: LD_INT 1
39474: NEG
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 2
39482: NEG
39483: PUSH
39484: LD_INT 2
39486: NEG
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 2
39494: NEG
39495: PUSH
39496: LD_INT 3
39498: NEG
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 2
39506: PUSH
39507: LD_INT 1
39509: NEG
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 3
39517: PUSH
39518: LD_INT 1
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 1
39527: PUSH
39528: LD_INT 3
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 1
39537: NEG
39538: PUSH
39539: LD_INT 2
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 3
39548: NEG
39549: PUSH
39550: LD_INT 2
39552: NEG
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: LIST
39562: LIST
39563: LIST
39564: LIST
39565: LIST
39566: LIST
39567: LIST
39568: LIST
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: LIST
39575: LIST
39576: LIST
39577: LIST
39578: LIST
39579: LIST
39580: LIST
39581: LIST
39582: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39583: LD_ADDR_VAR 0 32
39587: PUSH
39588: LD_INT 0
39590: PUSH
39591: LD_INT 0
39593: PUSH
39594: EMPTY
39595: LIST
39596: LIST
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: LD_INT 1
39603: NEG
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 1
39611: PUSH
39612: LD_INT 0
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 1
39621: PUSH
39622: LD_INT 1
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 0
39631: PUSH
39632: LD_INT 1
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: LD_INT 1
39641: NEG
39642: PUSH
39643: LD_INT 0
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PUSH
39650: LD_INT 1
39652: NEG
39653: PUSH
39654: LD_INT 1
39656: NEG
39657: PUSH
39658: EMPTY
39659: LIST
39660: LIST
39661: PUSH
39662: LD_INT 1
39664: NEG
39665: PUSH
39666: LD_INT 2
39668: NEG
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 0
39676: PUSH
39677: LD_INT 2
39679: NEG
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 1
39687: PUSH
39688: LD_INT 1
39690: NEG
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 2
39698: PUSH
39699: LD_INT 1
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 2
39708: PUSH
39709: LD_INT 2
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 1
39718: PUSH
39719: LD_INT 2
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 0
39728: PUSH
39729: LD_INT 2
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 1
39738: NEG
39739: PUSH
39740: LD_INT 1
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 2
39749: NEG
39750: PUSH
39751: LD_INT 0
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 2
39760: NEG
39761: PUSH
39762: LD_INT 1
39764: NEG
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 1
39772: NEG
39773: PUSH
39774: LD_INT 3
39776: NEG
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: LD_INT 2
39787: NEG
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: LD_INT 3
39795: PUSH
39796: LD_INT 2
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 2
39805: PUSH
39806: LD_INT 3
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: LD_INT 2
39815: NEG
39816: PUSH
39817: LD_INT 1
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 3
39826: NEG
39827: PUSH
39828: LD_INT 1
39830: NEG
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: LIST
39848: LIST
39849: LIST
39850: LIST
39851: LIST
39852: LIST
39853: LIST
39854: LIST
39855: LIST
39856: LIST
39857: LIST
39858: LIST
39859: LIST
39860: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39861: LD_ADDR_VAR 0 33
39865: PUSH
39866: LD_INT 0
39868: PUSH
39869: LD_INT 0
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: LD_INT 1
39881: NEG
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 1
39889: PUSH
39890: LD_INT 0
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: LD_INT 1
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 1
39919: NEG
39920: PUSH
39921: LD_INT 0
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 1
39930: NEG
39931: PUSH
39932: LD_INT 1
39934: NEG
39935: PUSH
39936: EMPTY
39937: LIST
39938: LIST
39939: PUSH
39940: LD_INT 1
39942: NEG
39943: PUSH
39944: LD_INT 2
39946: NEG
39947: PUSH
39948: EMPTY
39949: LIST
39950: LIST
39951: PUSH
39952: LD_INT 1
39954: PUSH
39955: LD_INT 1
39957: NEG
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: PUSH
39963: LD_INT 2
39965: PUSH
39966: LD_INT 0
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 2
39975: PUSH
39976: LD_INT 1
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: LD_INT 1
39985: PUSH
39986: LD_INT 2
39988: PUSH
39989: EMPTY
39990: LIST
39991: LIST
39992: PUSH
39993: LD_INT 0
39995: PUSH
39996: LD_INT 2
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 1
40005: NEG
40006: PUSH
40007: LD_INT 1
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 2
40016: NEG
40017: PUSH
40018: LD_INT 0
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 2
40027: NEG
40028: PUSH
40029: LD_INT 1
40031: NEG
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 2
40039: NEG
40040: PUSH
40041: LD_INT 2
40043: NEG
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 2
40051: NEG
40052: PUSH
40053: LD_INT 3
40055: NEG
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 2
40063: PUSH
40064: LD_INT 1
40066: NEG
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 3
40074: PUSH
40075: LD_INT 1
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 1
40084: PUSH
40085: LD_INT 3
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: LD_INT 1
40094: NEG
40095: PUSH
40096: LD_INT 2
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 3
40105: NEG
40106: PUSH
40107: LD_INT 2
40109: NEG
40110: PUSH
40111: EMPTY
40112: LIST
40113: LIST
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: LIST
40119: LIST
40120: LIST
40121: LIST
40122: LIST
40123: LIST
40124: LIST
40125: LIST
40126: LIST
40127: LIST
40128: LIST
40129: LIST
40130: LIST
40131: LIST
40132: LIST
40133: LIST
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40140: LD_ADDR_VAR 0 34
40144: PUSH
40145: LD_INT 0
40147: PUSH
40148: LD_INT 0
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: PUSH
40155: LD_INT 0
40157: PUSH
40158: LD_INT 1
40160: NEG
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 1
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 1
40178: PUSH
40179: LD_INT 1
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 0
40188: PUSH
40189: LD_INT 1
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 1
40198: NEG
40199: PUSH
40200: LD_INT 0
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: NEG
40210: PUSH
40211: LD_INT 1
40213: NEG
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PUSH
40219: LD_INT 1
40221: NEG
40222: PUSH
40223: LD_INT 2
40225: NEG
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 0
40233: PUSH
40234: LD_INT 2
40236: NEG
40237: PUSH
40238: EMPTY
40239: LIST
40240: LIST
40241: PUSH
40242: LD_INT 1
40244: PUSH
40245: LD_INT 1
40247: NEG
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 2
40255: PUSH
40256: LD_INT 1
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 2
40265: PUSH
40266: LD_INT 2
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: LD_INT 1
40275: PUSH
40276: LD_INT 2
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: PUSH
40283: LD_INT 1
40285: NEG
40286: PUSH
40287: LD_INT 1
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 2
40296: NEG
40297: PUSH
40298: LD_INT 0
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 2
40307: NEG
40308: PUSH
40309: LD_INT 1
40311: NEG
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 2
40319: NEG
40320: PUSH
40321: LD_INT 2
40323: NEG
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 1
40331: NEG
40332: PUSH
40333: LD_INT 3
40335: NEG
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 1
40343: PUSH
40344: LD_INT 2
40346: NEG
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 3
40354: PUSH
40355: LD_INT 2
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: LD_INT 2
40364: PUSH
40365: LD_INT 3
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 2
40374: NEG
40375: PUSH
40376: LD_INT 1
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 3
40385: NEG
40386: PUSH
40387: LD_INT 1
40389: NEG
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40420: LD_ADDR_VAR 0 35
40424: PUSH
40425: LD_INT 0
40427: PUSH
40428: LD_INT 0
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 0
40437: PUSH
40438: LD_INT 1
40440: NEG
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 1
40448: PUSH
40449: LD_INT 0
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 1
40458: PUSH
40459: LD_INT 1
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 0
40468: PUSH
40469: LD_INT 1
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 1
40478: NEG
40479: PUSH
40480: LD_INT 0
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 1
40489: NEG
40490: PUSH
40491: LD_INT 1
40493: NEG
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 2
40501: PUSH
40502: LD_INT 1
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: PUSH
40509: LD_INT 2
40511: NEG
40512: PUSH
40513: LD_INT 1
40515: NEG
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40532: LD_ADDR_VAR 0 36
40536: PUSH
40537: LD_INT 0
40539: PUSH
40540: LD_INT 0
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 0
40549: PUSH
40550: LD_INT 1
40552: NEG
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 1
40560: PUSH
40561: LD_INT 0
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: PUSH
40571: LD_INT 1
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: LD_INT 1
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PUSH
40588: LD_INT 1
40590: NEG
40591: PUSH
40592: LD_INT 0
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 1
40601: NEG
40602: PUSH
40603: LD_INT 1
40605: NEG
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 1
40613: NEG
40614: PUSH
40615: LD_INT 2
40617: NEG
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 1
40625: PUSH
40626: LD_INT 2
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40644: LD_ADDR_VAR 0 37
40648: PUSH
40649: LD_INT 0
40651: PUSH
40652: LD_INT 0
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 0
40661: PUSH
40662: LD_INT 1
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 1
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 1
40682: PUSH
40683: LD_INT 1
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PUSH
40690: LD_INT 0
40692: PUSH
40693: LD_INT 1
40695: PUSH
40696: EMPTY
40697: LIST
40698: LIST
40699: PUSH
40700: LD_INT 1
40702: NEG
40703: PUSH
40704: LD_INT 0
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 1
40713: NEG
40714: PUSH
40715: LD_INT 1
40717: NEG
40718: PUSH
40719: EMPTY
40720: LIST
40721: LIST
40722: PUSH
40723: LD_INT 1
40725: PUSH
40726: LD_INT 1
40728: NEG
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 1
40736: NEG
40737: PUSH
40738: LD_INT 1
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40756: LD_ADDR_VAR 0 38
40760: PUSH
40761: LD_INT 0
40763: PUSH
40764: LD_INT 0
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PUSH
40771: LD_INT 0
40773: PUSH
40774: LD_INT 1
40776: NEG
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 1
40784: PUSH
40785: LD_INT 0
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: PUSH
40792: LD_INT 1
40794: PUSH
40795: LD_INT 1
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 0
40804: PUSH
40805: LD_INT 1
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 1
40814: NEG
40815: PUSH
40816: LD_INT 0
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: LD_INT 1
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 2
40837: PUSH
40838: LD_INT 1
40840: PUSH
40841: EMPTY
40842: LIST
40843: LIST
40844: PUSH
40845: LD_INT 2
40847: NEG
40848: PUSH
40849: LD_INT 1
40851: NEG
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40868: LD_ADDR_VAR 0 39
40872: PUSH
40873: LD_INT 0
40875: PUSH
40876: LD_INT 0
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: PUSH
40883: LD_INT 0
40885: PUSH
40886: LD_INT 1
40888: NEG
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: LD_INT 1
40896: PUSH
40897: LD_INT 0
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: PUSH
40904: LD_INT 1
40906: PUSH
40907: LD_INT 1
40909: PUSH
40910: EMPTY
40911: LIST
40912: LIST
40913: PUSH
40914: LD_INT 0
40916: PUSH
40917: LD_INT 1
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 1
40926: NEG
40927: PUSH
40928: LD_INT 0
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 1
40937: NEG
40938: PUSH
40939: LD_INT 1
40941: NEG
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 1
40949: NEG
40950: PUSH
40951: LD_INT 2
40953: NEG
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: LD_INT 1
40961: PUSH
40962: LD_INT 2
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40980: LD_ADDR_VAR 0 40
40984: PUSH
40985: LD_INT 0
40987: PUSH
40988: LD_INT 0
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: LD_INT 0
40997: PUSH
40998: LD_INT 1
41000: NEG
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 1
41008: PUSH
41009: LD_INT 0
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 1
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 0
41028: PUSH
41029: LD_INT 1
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 1
41038: NEG
41039: PUSH
41040: LD_INT 0
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: LD_INT 1
41049: NEG
41050: PUSH
41051: LD_INT 1
41053: NEG
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 1
41061: PUSH
41062: LD_INT 1
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 1
41072: NEG
41073: PUSH
41074: LD_INT 1
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41092: LD_ADDR_VAR 0 41
41096: PUSH
41097: LD_INT 0
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: LD_INT 0
41109: PUSH
41110: LD_INT 1
41112: NEG
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: LD_INT 1
41120: PUSH
41121: LD_INT 0
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 1
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 0
41140: PUSH
41141: LD_INT 1
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: LD_INT 1
41150: NEG
41151: PUSH
41152: LD_INT 0
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 1
41161: NEG
41162: PUSH
41163: LD_INT 1
41165: NEG
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PUSH
41171: LD_INT 1
41173: NEG
41174: PUSH
41175: LD_INT 2
41177: NEG
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 1
41185: PUSH
41186: LD_INT 1
41188: NEG
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 2
41196: PUSH
41197: LD_INT 0
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 2
41206: PUSH
41207: LD_INT 1
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 2
41216: PUSH
41217: LD_INT 2
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: PUSH
41224: LD_INT 1
41226: PUSH
41227: LD_INT 2
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PUSH
41234: LD_INT 1
41236: NEG
41237: PUSH
41238: LD_INT 1
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 2
41247: NEG
41248: PUSH
41249: LD_INT 0
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 2
41258: NEG
41259: PUSH
41260: LD_INT 1
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 2
41270: NEG
41271: PUSH
41272: LD_INT 2
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 2
41282: NEG
41283: PUSH
41284: LD_INT 3
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 2
41294: PUSH
41295: LD_INT 1
41297: NEG
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: PUSH
41303: LD_INT 3
41305: PUSH
41306: LD_INT 0
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 3
41315: PUSH
41316: LD_INT 1
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: PUSH
41323: LD_INT 3
41325: PUSH
41326: LD_INT 2
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: LD_INT 3
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 2
41345: PUSH
41346: LD_INT 3
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 2
41355: NEG
41356: PUSH
41357: LD_INT 1
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PUSH
41364: LD_INT 3
41366: NEG
41367: PUSH
41368: LD_INT 0
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: LD_INT 3
41377: NEG
41378: PUSH
41379: LD_INT 1
41381: NEG
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 3
41389: NEG
41390: PUSH
41391: LD_INT 2
41393: NEG
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 3
41401: NEG
41402: PUSH
41403: LD_INT 3
41405: NEG
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: LIST
41415: LIST
41416: LIST
41417: LIST
41418: LIST
41419: LIST
41420: LIST
41421: LIST
41422: LIST
41423: LIST
41424: LIST
41425: LIST
41426: LIST
41427: LIST
41428: LIST
41429: LIST
41430: LIST
41431: LIST
41432: LIST
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41442: LD_ADDR_VAR 0 42
41446: PUSH
41447: LD_INT 0
41449: PUSH
41450: LD_INT 0
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 0
41459: PUSH
41460: LD_INT 1
41462: NEG
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 1
41470: PUSH
41471: LD_INT 0
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 1
41480: PUSH
41481: LD_INT 1
41483: PUSH
41484: EMPTY
41485: LIST
41486: LIST
41487: PUSH
41488: LD_INT 0
41490: PUSH
41491: LD_INT 1
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 1
41500: NEG
41501: PUSH
41502: LD_INT 0
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PUSH
41509: LD_INT 1
41511: NEG
41512: PUSH
41513: LD_INT 1
41515: NEG
41516: PUSH
41517: EMPTY
41518: LIST
41519: LIST
41520: PUSH
41521: LD_INT 1
41523: NEG
41524: PUSH
41525: LD_INT 2
41527: NEG
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PUSH
41533: LD_INT 0
41535: PUSH
41536: LD_INT 2
41538: NEG
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 1
41546: PUSH
41547: LD_INT 1
41549: NEG
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: LD_INT 2
41557: PUSH
41558: LD_INT 1
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: LD_INT 2
41567: PUSH
41568: LD_INT 2
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: LD_INT 1
41577: PUSH
41578: LD_INT 2
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 0
41587: PUSH
41588: LD_INT 2
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 1
41597: NEG
41598: PUSH
41599: LD_INT 1
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 2
41608: NEG
41609: PUSH
41610: LD_INT 1
41612: NEG
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: PUSH
41618: LD_INT 2
41620: NEG
41621: PUSH
41622: LD_INT 2
41624: NEG
41625: PUSH
41626: EMPTY
41627: LIST
41628: LIST
41629: PUSH
41630: LD_INT 2
41632: NEG
41633: PUSH
41634: LD_INT 3
41636: NEG
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 1
41644: NEG
41645: PUSH
41646: LD_INT 3
41648: NEG
41649: PUSH
41650: EMPTY
41651: LIST
41652: LIST
41653: PUSH
41654: LD_INT 0
41656: PUSH
41657: LD_INT 3
41659: NEG
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 1
41667: PUSH
41668: LD_INT 2
41670: NEG
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 3
41678: PUSH
41679: LD_INT 2
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 3
41688: PUSH
41689: LD_INT 3
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 2
41698: PUSH
41699: LD_INT 3
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 1
41708: PUSH
41709: LD_INT 3
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 0
41718: PUSH
41719: LD_INT 3
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 1
41728: NEG
41729: PUSH
41730: LD_INT 2
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 3
41739: NEG
41740: PUSH
41741: LD_INT 2
41743: NEG
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 3
41751: NEG
41752: PUSH
41753: LD_INT 3
41755: NEG
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: EMPTY
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41792: LD_ADDR_VAR 0 43
41796: PUSH
41797: LD_INT 0
41799: PUSH
41800: LD_INT 0
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: LD_INT 0
41809: PUSH
41810: LD_INT 1
41812: NEG
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 1
41820: PUSH
41821: LD_INT 0
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 1
41830: PUSH
41831: LD_INT 1
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 0
41840: PUSH
41841: LD_INT 1
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 1
41850: NEG
41851: PUSH
41852: LD_INT 0
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 1
41861: NEG
41862: PUSH
41863: LD_INT 1
41865: NEG
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: PUSH
41871: LD_INT 1
41873: NEG
41874: PUSH
41875: LD_INT 2
41877: NEG
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: PUSH
41883: LD_INT 0
41885: PUSH
41886: LD_INT 2
41888: NEG
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 1
41896: PUSH
41897: LD_INT 1
41899: NEG
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 2
41907: PUSH
41908: LD_INT 0
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 2
41917: PUSH
41918: LD_INT 1
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 1
41927: PUSH
41928: LD_INT 2
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: LD_INT 0
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 1
41947: NEG
41948: PUSH
41949: LD_INT 1
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: PUSH
41956: LD_INT 2
41958: NEG
41959: PUSH
41960: LD_INT 0
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: PUSH
41967: LD_INT 2
41969: NEG
41970: PUSH
41971: LD_INT 1
41973: NEG
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 1
41981: NEG
41982: PUSH
41983: LD_INT 3
41985: NEG
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 0
41993: PUSH
41994: LD_INT 3
41996: NEG
41997: PUSH
41998: EMPTY
41999: LIST
42000: LIST
42001: PUSH
42002: LD_INT 1
42004: PUSH
42005: LD_INT 2
42007: NEG
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 2
42015: PUSH
42016: LD_INT 1
42018: NEG
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PUSH
42024: LD_INT 3
42026: PUSH
42027: LD_INT 0
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 3
42036: PUSH
42037: LD_INT 1
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: LD_INT 1
42046: PUSH
42047: LD_INT 3
42049: PUSH
42050: EMPTY
42051: LIST
42052: LIST
42053: PUSH
42054: LD_INT 0
42056: PUSH
42057: LD_INT 3
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 1
42066: NEG
42067: PUSH
42068: LD_INT 2
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 2
42077: NEG
42078: PUSH
42079: LD_INT 1
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: LD_INT 3
42088: NEG
42089: PUSH
42090: LD_INT 0
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: PUSH
42097: LD_INT 3
42099: NEG
42100: PUSH
42101: LD_INT 1
42103: NEG
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: LIST
42113: LIST
42114: LIST
42115: LIST
42116: LIST
42117: LIST
42118: LIST
42119: LIST
42120: LIST
42121: LIST
42122: LIST
42123: LIST
42124: LIST
42125: LIST
42126: LIST
42127: LIST
42128: LIST
42129: LIST
42130: LIST
42131: LIST
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42140: LD_ADDR_VAR 0 44
42144: PUSH
42145: LD_INT 0
42147: PUSH
42148: LD_INT 0
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 0
42157: PUSH
42158: LD_INT 1
42160: NEG
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: LD_INT 1
42168: PUSH
42169: LD_INT 0
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 1
42178: PUSH
42179: LD_INT 1
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: LD_INT 0
42188: PUSH
42189: LD_INT 1
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 1
42198: NEG
42199: PUSH
42200: LD_INT 0
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 1
42209: NEG
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 1
42221: NEG
42222: PUSH
42223: LD_INT 2
42225: NEG
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 1
42233: PUSH
42234: LD_INT 1
42236: NEG
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PUSH
42242: LD_INT 2
42244: PUSH
42245: LD_INT 0
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 2
42254: PUSH
42255: LD_INT 1
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: PUSH
42262: LD_INT 2
42264: PUSH
42265: LD_INT 2
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 1
42274: PUSH
42275: LD_INT 2
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: LD_INT 1
42284: NEG
42285: PUSH
42286: LD_INT 1
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 2
42295: NEG
42296: PUSH
42297: LD_INT 0
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 2
42306: NEG
42307: PUSH
42308: LD_INT 1
42310: NEG
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 2
42318: NEG
42319: PUSH
42320: LD_INT 2
42322: NEG
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 2
42330: NEG
42331: PUSH
42332: LD_INT 3
42334: NEG
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 2
42342: PUSH
42343: LD_INT 1
42345: NEG
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 3
42353: PUSH
42354: LD_INT 0
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 3
42363: PUSH
42364: LD_INT 1
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 3
42373: PUSH
42374: LD_INT 2
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 3
42383: PUSH
42384: LD_INT 3
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 2
42393: PUSH
42394: LD_INT 3
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 2
42403: NEG
42404: PUSH
42405: LD_INT 1
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PUSH
42412: LD_INT 3
42414: NEG
42415: PUSH
42416: LD_INT 0
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 3
42425: NEG
42426: PUSH
42427: LD_INT 1
42429: NEG
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 3
42437: NEG
42438: PUSH
42439: LD_INT 2
42441: NEG
42442: PUSH
42443: EMPTY
42444: LIST
42445: LIST
42446: PUSH
42447: LD_INT 3
42449: NEG
42450: PUSH
42451: LD_INT 3
42453: NEG
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: EMPTY
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: LIST
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42490: LD_ADDR_VAR 0 45
42494: PUSH
42495: LD_INT 0
42497: PUSH
42498: LD_INT 0
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: LD_INT 1
42510: NEG
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 1
42518: PUSH
42519: LD_INT 0
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 1
42528: PUSH
42529: LD_INT 1
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: LD_INT 1
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 1
42548: NEG
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 1
42559: NEG
42560: PUSH
42561: LD_INT 1
42563: NEG
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 1
42571: NEG
42572: PUSH
42573: LD_INT 2
42575: NEG
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 0
42583: PUSH
42584: LD_INT 2
42586: NEG
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: LD_INT 1
42594: PUSH
42595: LD_INT 1
42597: NEG
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: LD_INT 2
42605: PUSH
42606: LD_INT 1
42608: PUSH
42609: EMPTY
42610: LIST
42611: LIST
42612: PUSH
42613: LD_INT 2
42615: PUSH
42616: LD_INT 2
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: LD_INT 1
42625: PUSH
42626: LD_INT 2
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: LD_INT 2
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: LD_INT 1
42645: NEG
42646: PUSH
42647: LD_INT 1
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 2
42656: NEG
42657: PUSH
42658: LD_INT 1
42660: NEG
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 2
42668: NEG
42669: PUSH
42670: LD_INT 2
42672: NEG
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 2
42680: NEG
42681: PUSH
42682: LD_INT 3
42684: NEG
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 1
42692: NEG
42693: PUSH
42694: LD_INT 3
42696: NEG
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 0
42704: PUSH
42705: LD_INT 3
42707: NEG
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 1
42715: PUSH
42716: LD_INT 2
42718: NEG
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 3
42726: PUSH
42727: LD_INT 2
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 3
42736: PUSH
42737: LD_INT 3
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 2
42746: PUSH
42747: LD_INT 3
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: PUSH
42754: LD_INT 1
42756: PUSH
42757: LD_INT 3
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 0
42766: PUSH
42767: LD_INT 3
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: LD_INT 1
42776: NEG
42777: PUSH
42778: LD_INT 2
42780: PUSH
42781: EMPTY
42782: LIST
42783: LIST
42784: PUSH
42785: LD_INT 3
42787: NEG
42788: PUSH
42789: LD_INT 2
42791: NEG
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: LD_INT 3
42799: NEG
42800: PUSH
42801: LD_INT 3
42803: NEG
42804: PUSH
42805: EMPTY
42806: LIST
42807: LIST
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: LIST
42813: LIST
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: LIST
42821: LIST
42822: LIST
42823: LIST
42824: LIST
42825: LIST
42826: LIST
42827: LIST
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: LIST
42835: LIST
42836: LIST
42837: LIST
42838: LIST
42839: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42840: LD_ADDR_VAR 0 46
42844: PUSH
42845: LD_INT 0
42847: PUSH
42848: LD_INT 0
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 0
42857: PUSH
42858: LD_INT 1
42860: NEG
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: LD_INT 1
42868: PUSH
42869: LD_INT 0
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 1
42878: PUSH
42879: LD_INT 1
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: LD_INT 0
42888: PUSH
42889: LD_INT 1
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: PUSH
42896: LD_INT 1
42898: NEG
42899: PUSH
42900: LD_INT 0
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: LD_INT 1
42909: NEG
42910: PUSH
42911: LD_INT 1
42913: NEG
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PUSH
42919: LD_INT 1
42921: NEG
42922: PUSH
42923: LD_INT 2
42925: NEG
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 0
42933: PUSH
42934: LD_INT 2
42936: NEG
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: PUSH
42942: LD_INT 1
42944: PUSH
42945: LD_INT 1
42947: NEG
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: PUSH
42953: LD_INT 2
42955: PUSH
42956: LD_INT 0
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: LD_INT 2
42965: PUSH
42966: LD_INT 1
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 1
42975: PUSH
42976: LD_INT 2
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: LD_INT 0
42985: PUSH
42986: LD_INT 2
42988: PUSH
42989: EMPTY
42990: LIST
42991: LIST
42992: PUSH
42993: LD_INT 1
42995: NEG
42996: PUSH
42997: LD_INT 1
42999: PUSH
43000: EMPTY
43001: LIST
43002: LIST
43003: PUSH
43004: LD_INT 2
43006: NEG
43007: PUSH
43008: LD_INT 0
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 2
43017: NEG
43018: PUSH
43019: LD_INT 1
43021: NEG
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 1
43029: NEG
43030: PUSH
43031: LD_INT 3
43033: NEG
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 0
43041: PUSH
43042: LD_INT 3
43044: NEG
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: PUSH
43050: LD_INT 1
43052: PUSH
43053: LD_INT 2
43055: NEG
43056: PUSH
43057: EMPTY
43058: LIST
43059: LIST
43060: PUSH
43061: LD_INT 2
43063: PUSH
43064: LD_INT 1
43066: NEG
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: PUSH
43072: LD_INT 3
43074: PUSH
43075: LD_INT 0
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 3
43084: PUSH
43085: LD_INT 1
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: PUSH
43092: LD_INT 1
43094: PUSH
43095: LD_INT 3
43097: PUSH
43098: EMPTY
43099: LIST
43100: LIST
43101: PUSH
43102: LD_INT 0
43104: PUSH
43105: LD_INT 3
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 1
43114: NEG
43115: PUSH
43116: LD_INT 2
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 2
43125: NEG
43126: PUSH
43127: LD_INT 1
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 3
43136: NEG
43137: PUSH
43138: LD_INT 0
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 3
43147: NEG
43148: PUSH
43149: LD_INT 1
43151: NEG
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: EMPTY
43158: LIST
43159: LIST
43160: LIST
43161: LIST
43162: LIST
43163: LIST
43164: LIST
43165: LIST
43166: LIST
43167: LIST
43168: LIST
43169: LIST
43170: LIST
43171: LIST
43172: LIST
43173: LIST
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43188: LD_ADDR_VAR 0 47
43192: PUSH
43193: LD_INT 0
43195: PUSH
43196: LD_INT 0
43198: PUSH
43199: EMPTY
43200: LIST
43201: LIST
43202: PUSH
43203: LD_INT 0
43205: PUSH
43206: LD_INT 1
43208: NEG
43209: PUSH
43210: EMPTY
43211: LIST
43212: LIST
43213: PUSH
43214: LD_INT 1
43216: PUSH
43217: LD_INT 0
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 1
43226: PUSH
43227: LD_INT 1
43229: PUSH
43230: EMPTY
43231: LIST
43232: LIST
43233: PUSH
43234: LD_INT 0
43236: PUSH
43237: LD_INT 1
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 1
43246: NEG
43247: PUSH
43248: LD_INT 0
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: PUSH
43255: LD_INT 1
43257: NEG
43258: PUSH
43259: LD_INT 1
43261: NEG
43262: PUSH
43263: EMPTY
43264: LIST
43265: LIST
43266: PUSH
43267: LD_INT 1
43269: NEG
43270: PUSH
43271: LD_INT 2
43273: NEG
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 0
43281: PUSH
43282: LD_INT 2
43284: NEG
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 1
43292: PUSH
43293: LD_INT 1
43295: NEG
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 2
43303: NEG
43304: PUSH
43305: LD_INT 1
43307: NEG
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: LD_INT 2
43315: NEG
43316: PUSH
43317: LD_INT 2
43319: NEG
43320: PUSH
43321: EMPTY
43322: LIST
43323: LIST
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: LIST
43329: LIST
43330: LIST
43331: LIST
43332: LIST
43333: LIST
43334: LIST
43335: LIST
43336: LIST
43337: LIST
43338: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43339: LD_ADDR_VAR 0 48
43343: PUSH
43344: LD_INT 0
43346: PUSH
43347: LD_INT 0
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 0
43356: PUSH
43357: LD_INT 1
43359: NEG
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: PUSH
43365: LD_INT 1
43367: PUSH
43368: LD_INT 0
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 1
43377: PUSH
43378: LD_INT 1
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 0
43387: PUSH
43388: LD_INT 1
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: PUSH
43395: LD_INT 1
43397: NEG
43398: PUSH
43399: LD_INT 0
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: PUSH
43406: LD_INT 1
43408: NEG
43409: PUSH
43410: LD_INT 1
43412: NEG
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: LD_INT 1
43420: NEG
43421: PUSH
43422: LD_INT 2
43424: NEG
43425: PUSH
43426: EMPTY
43427: LIST
43428: LIST
43429: PUSH
43430: LD_INT 0
43432: PUSH
43433: LD_INT 2
43435: NEG
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 1
43443: PUSH
43444: LD_INT 1
43446: NEG
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 2
43454: PUSH
43455: LD_INT 0
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 2
43464: PUSH
43465: LD_INT 1
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: LIST
43476: LIST
43477: LIST
43478: LIST
43479: LIST
43480: LIST
43481: LIST
43482: LIST
43483: LIST
43484: LIST
43485: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43486: LD_ADDR_VAR 0 49
43490: PUSH
43491: LD_INT 0
43493: PUSH
43494: LD_INT 0
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 0
43503: PUSH
43504: LD_INT 1
43506: NEG
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 1
43514: PUSH
43515: LD_INT 0
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 1
43524: PUSH
43525: LD_INT 1
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 0
43534: PUSH
43535: LD_INT 1
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 1
43544: NEG
43545: PUSH
43546: LD_INT 0
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 1
43555: NEG
43556: PUSH
43557: LD_INT 1
43559: NEG
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: LD_INT 1
43567: PUSH
43568: LD_INT 1
43570: NEG
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PUSH
43576: LD_INT 2
43578: PUSH
43579: LD_INT 0
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: LD_INT 2
43588: PUSH
43589: LD_INT 1
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 2
43598: PUSH
43599: LD_INT 2
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 1
43608: PUSH
43609: LD_INT 2
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: EMPTY
43617: LIST
43618: LIST
43619: LIST
43620: LIST
43621: LIST
43622: LIST
43623: LIST
43624: LIST
43625: LIST
43626: LIST
43627: LIST
43628: LIST
43629: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43630: LD_ADDR_VAR 0 50
43634: PUSH
43635: LD_INT 0
43637: PUSH
43638: LD_INT 0
43640: PUSH
43641: EMPTY
43642: LIST
43643: LIST
43644: PUSH
43645: LD_INT 0
43647: PUSH
43648: LD_INT 1
43650: NEG
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: PUSH
43656: LD_INT 1
43658: PUSH
43659: LD_INT 0
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 1
43668: PUSH
43669: LD_INT 1
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 0
43678: PUSH
43679: LD_INT 1
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 1
43688: NEG
43689: PUSH
43690: LD_INT 0
43692: PUSH
43693: EMPTY
43694: LIST
43695: LIST
43696: PUSH
43697: LD_INT 1
43699: NEG
43700: PUSH
43701: LD_INT 1
43703: NEG
43704: PUSH
43705: EMPTY
43706: LIST
43707: LIST
43708: PUSH
43709: LD_INT 2
43711: PUSH
43712: LD_INT 1
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 2
43721: PUSH
43722: LD_INT 2
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: LD_INT 1
43731: PUSH
43732: LD_INT 2
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 0
43741: PUSH
43742: LD_INT 2
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 1
43751: NEG
43752: PUSH
43753: LD_INT 1
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: EMPTY
43761: LIST
43762: LIST
43763: LIST
43764: LIST
43765: LIST
43766: LIST
43767: LIST
43768: LIST
43769: LIST
43770: LIST
43771: LIST
43772: LIST
43773: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43774: LD_ADDR_VAR 0 51
43778: PUSH
43779: LD_INT 0
43781: PUSH
43782: LD_INT 0
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 0
43791: PUSH
43792: LD_INT 1
43794: NEG
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: PUSH
43800: LD_INT 1
43802: PUSH
43803: LD_INT 0
43805: PUSH
43806: EMPTY
43807: LIST
43808: LIST
43809: PUSH
43810: LD_INT 1
43812: PUSH
43813: LD_INT 1
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 0
43822: PUSH
43823: LD_INT 1
43825: PUSH
43826: EMPTY
43827: LIST
43828: LIST
43829: PUSH
43830: LD_INT 1
43832: NEG
43833: PUSH
43834: LD_INT 0
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 1
43843: NEG
43844: PUSH
43845: LD_INT 1
43847: NEG
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 1
43855: PUSH
43856: LD_INT 2
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: PUSH
43863: LD_INT 0
43865: PUSH
43866: LD_INT 2
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: PUSH
43873: LD_INT 1
43875: NEG
43876: PUSH
43877: LD_INT 1
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: LD_INT 2
43886: NEG
43887: PUSH
43888: LD_INT 0
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PUSH
43895: LD_INT 2
43897: NEG
43898: PUSH
43899: LD_INT 1
43901: NEG
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43921: LD_ADDR_VAR 0 52
43925: PUSH
43926: LD_INT 0
43928: PUSH
43929: LD_INT 0
43931: PUSH
43932: EMPTY
43933: LIST
43934: LIST
43935: PUSH
43936: LD_INT 0
43938: PUSH
43939: LD_INT 1
43941: NEG
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: PUSH
43947: LD_INT 1
43949: PUSH
43950: LD_INT 0
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: LD_INT 1
43959: PUSH
43960: LD_INT 1
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 0
43969: PUSH
43970: LD_INT 1
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: PUSH
43977: LD_INT 1
43979: NEG
43980: PUSH
43981: LD_INT 0
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PUSH
43988: LD_INT 1
43990: NEG
43991: PUSH
43992: LD_INT 1
43994: NEG
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 1
44002: NEG
44003: PUSH
44004: LD_INT 2
44006: NEG
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 1
44014: NEG
44015: PUSH
44016: LD_INT 1
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: PUSH
44023: LD_INT 2
44025: NEG
44026: PUSH
44027: LD_INT 0
44029: PUSH
44030: EMPTY
44031: LIST
44032: LIST
44033: PUSH
44034: LD_INT 2
44036: NEG
44037: PUSH
44038: LD_INT 1
44040: NEG
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 2
44048: NEG
44049: PUSH
44050: LD_INT 2
44052: NEG
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44072: LD_ADDR_VAR 0 53
44076: PUSH
44077: LD_INT 0
44079: PUSH
44080: LD_INT 0
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: LD_INT 0
44089: PUSH
44090: LD_INT 1
44092: NEG
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 1
44100: PUSH
44101: LD_INT 0
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 1
44110: PUSH
44111: LD_INT 1
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: LD_INT 1
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: LD_INT 0
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 1
44141: NEG
44142: PUSH
44143: LD_INT 1
44145: NEG
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_INT 1
44153: NEG
44154: PUSH
44155: LD_INT 2
44157: NEG
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PUSH
44163: LD_INT 0
44165: PUSH
44166: LD_INT 2
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 1
44176: PUSH
44177: LD_INT 1
44179: NEG
44180: PUSH
44181: EMPTY
44182: LIST
44183: LIST
44184: PUSH
44185: LD_INT 2
44187: PUSH
44188: LD_INT 0
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: PUSH
44195: LD_INT 2
44197: PUSH
44198: LD_INT 1
44200: PUSH
44201: EMPTY
44202: LIST
44203: LIST
44204: PUSH
44205: LD_INT 2
44207: PUSH
44208: LD_INT 2
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 1
44217: PUSH
44218: LD_INT 2
44220: PUSH
44221: EMPTY
44222: LIST
44223: LIST
44224: PUSH
44225: LD_INT 0
44227: PUSH
44228: LD_INT 2
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 1
44237: NEG
44238: PUSH
44239: LD_INT 1
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 2
44248: NEG
44249: PUSH
44250: LD_INT 0
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PUSH
44257: LD_INT 2
44259: NEG
44260: PUSH
44261: LD_INT 1
44263: NEG
44264: PUSH
44265: EMPTY
44266: LIST
44267: LIST
44268: PUSH
44269: LD_INT 2
44271: NEG
44272: PUSH
44273: LD_INT 2
44275: NEG
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44302: LD_ADDR_VAR 0 54
44306: PUSH
44307: LD_INT 0
44309: PUSH
44310: LD_INT 0
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 0
44319: PUSH
44320: LD_INT 1
44322: NEG
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 1
44330: PUSH
44331: LD_INT 0
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 1
44340: PUSH
44341: LD_INT 1
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: LD_INT 1
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: LD_INT 0
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 1
44371: NEG
44372: PUSH
44373: LD_INT 1
44375: NEG
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: PUSH
44381: LD_INT 1
44383: NEG
44384: PUSH
44385: LD_INT 2
44387: NEG
44388: PUSH
44389: EMPTY
44390: LIST
44391: LIST
44392: PUSH
44393: LD_INT 0
44395: PUSH
44396: LD_INT 2
44398: NEG
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 1
44406: PUSH
44407: LD_INT 1
44409: NEG
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 2
44417: PUSH
44418: LD_INT 0
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 2
44427: PUSH
44428: LD_INT 1
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 2
44437: PUSH
44438: LD_INT 2
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 1
44447: PUSH
44448: LD_INT 2
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 0
44457: PUSH
44458: LD_INT 2
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 1
44467: NEG
44468: PUSH
44469: LD_INT 1
44471: PUSH
44472: EMPTY
44473: LIST
44474: LIST
44475: PUSH
44476: LD_INT 2
44478: NEG
44479: PUSH
44480: LD_INT 0
44482: PUSH
44483: EMPTY
44484: LIST
44485: LIST
44486: PUSH
44487: LD_INT 2
44489: NEG
44490: PUSH
44491: LD_INT 1
44493: NEG
44494: PUSH
44495: EMPTY
44496: LIST
44497: LIST
44498: PUSH
44499: LD_INT 2
44501: NEG
44502: PUSH
44503: LD_INT 2
44505: NEG
44506: PUSH
44507: EMPTY
44508: LIST
44509: LIST
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: LIST
44515: LIST
44516: LIST
44517: LIST
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44532: LD_ADDR_VAR 0 55
44536: PUSH
44537: LD_INT 0
44539: PUSH
44540: LD_INT 0
44542: PUSH
44543: EMPTY
44544: LIST
44545: LIST
44546: PUSH
44547: LD_INT 0
44549: PUSH
44550: LD_INT 1
44552: NEG
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 1
44560: PUSH
44561: LD_INT 0
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 1
44570: PUSH
44571: LD_INT 1
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 0
44580: PUSH
44581: LD_INT 1
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 1
44590: NEG
44591: PUSH
44592: LD_INT 0
44594: PUSH
44595: EMPTY
44596: LIST
44597: LIST
44598: PUSH
44599: LD_INT 1
44601: NEG
44602: PUSH
44603: LD_INT 1
44605: NEG
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 1
44613: NEG
44614: PUSH
44615: LD_INT 2
44617: NEG
44618: PUSH
44619: EMPTY
44620: LIST
44621: LIST
44622: PUSH
44623: LD_INT 0
44625: PUSH
44626: LD_INT 2
44628: NEG
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 1
44636: PUSH
44637: LD_INT 1
44639: NEG
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 2
44647: PUSH
44648: LD_INT 0
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 2
44657: PUSH
44658: LD_INT 1
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: PUSH
44665: LD_INT 2
44667: PUSH
44668: LD_INT 2
44670: PUSH
44671: EMPTY
44672: LIST
44673: LIST
44674: PUSH
44675: LD_INT 1
44677: PUSH
44678: LD_INT 2
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: PUSH
44685: LD_INT 0
44687: PUSH
44688: LD_INT 2
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 1
44697: NEG
44698: PUSH
44699: LD_INT 1
44701: PUSH
44702: EMPTY
44703: LIST
44704: LIST
44705: PUSH
44706: LD_INT 2
44708: NEG
44709: PUSH
44710: LD_INT 0
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 2
44719: NEG
44720: PUSH
44721: LD_INT 1
44723: NEG
44724: PUSH
44725: EMPTY
44726: LIST
44727: LIST
44728: PUSH
44729: LD_INT 2
44731: NEG
44732: PUSH
44733: LD_INT 2
44735: NEG
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: LIST
44758: LIST
44759: LIST
44760: LIST
44761: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44762: LD_ADDR_VAR 0 56
44766: PUSH
44767: LD_INT 0
44769: PUSH
44770: LD_INT 0
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 0
44779: PUSH
44780: LD_INT 1
44782: NEG
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PUSH
44788: LD_INT 1
44790: PUSH
44791: LD_INT 0
44793: PUSH
44794: EMPTY
44795: LIST
44796: LIST
44797: PUSH
44798: LD_INT 1
44800: PUSH
44801: LD_INT 1
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: LD_INT 0
44810: PUSH
44811: LD_INT 1
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 1
44820: NEG
44821: PUSH
44822: LD_INT 0
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 1
44831: NEG
44832: PUSH
44833: LD_INT 1
44835: NEG
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: LD_INT 1
44843: NEG
44844: PUSH
44845: LD_INT 2
44847: NEG
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: PUSH
44853: LD_INT 0
44855: PUSH
44856: LD_INT 2
44858: NEG
44859: PUSH
44860: EMPTY
44861: LIST
44862: LIST
44863: PUSH
44864: LD_INT 1
44866: PUSH
44867: LD_INT 1
44869: NEG
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 2
44877: PUSH
44878: LD_INT 0
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PUSH
44885: LD_INT 2
44887: PUSH
44888: LD_INT 1
44890: PUSH
44891: EMPTY
44892: LIST
44893: LIST
44894: PUSH
44895: LD_INT 2
44897: PUSH
44898: LD_INT 2
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: LD_INT 1
44907: PUSH
44908: LD_INT 2
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 0
44917: PUSH
44918: LD_INT 2
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: LD_INT 1
44927: NEG
44928: PUSH
44929: LD_INT 1
44931: PUSH
44932: EMPTY
44933: LIST
44934: LIST
44935: PUSH
44936: LD_INT 2
44938: NEG
44939: PUSH
44940: LD_INT 0
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: PUSH
44947: LD_INT 2
44949: NEG
44950: PUSH
44951: LD_INT 1
44953: NEG
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: PUSH
44959: LD_INT 2
44961: NEG
44962: PUSH
44963: LD_INT 2
44965: NEG
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: LIST
44975: LIST
44976: LIST
44977: LIST
44978: LIST
44979: LIST
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: LIST
44990: LIST
44991: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44992: LD_ADDR_VAR 0 57
44996: PUSH
44997: LD_INT 0
44999: PUSH
45000: LD_INT 0
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 0
45009: PUSH
45010: LD_INT 1
45012: NEG
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PUSH
45018: LD_INT 1
45020: PUSH
45021: LD_INT 0
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: LD_INT 1
45030: PUSH
45031: LD_INT 1
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 0
45040: PUSH
45041: LD_INT 1
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: PUSH
45048: LD_INT 1
45050: NEG
45051: PUSH
45052: LD_INT 0
45054: PUSH
45055: EMPTY
45056: LIST
45057: LIST
45058: PUSH
45059: LD_INT 1
45061: NEG
45062: PUSH
45063: LD_INT 1
45065: NEG
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: PUSH
45071: LD_INT 1
45073: NEG
45074: PUSH
45075: LD_INT 2
45077: NEG
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PUSH
45083: LD_INT 0
45085: PUSH
45086: LD_INT 2
45088: NEG
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 1
45096: PUSH
45097: LD_INT 1
45099: NEG
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: LD_INT 2
45107: PUSH
45108: LD_INT 0
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PUSH
45115: LD_INT 2
45117: PUSH
45118: LD_INT 1
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: LD_INT 2
45127: PUSH
45128: LD_INT 2
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 1
45137: PUSH
45138: LD_INT 2
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 0
45147: PUSH
45148: LD_INT 2
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: LD_INT 1
45157: NEG
45158: PUSH
45159: LD_INT 1
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PUSH
45166: LD_INT 2
45168: NEG
45169: PUSH
45170: LD_INT 0
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: PUSH
45177: LD_INT 2
45179: NEG
45180: PUSH
45181: LD_INT 1
45183: NEG
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 2
45191: NEG
45192: PUSH
45193: LD_INT 2
45195: NEG
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45222: LD_ADDR_VAR 0 58
45226: PUSH
45227: LD_INT 0
45229: PUSH
45230: LD_INT 0
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 0
45239: PUSH
45240: LD_INT 1
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 1
45250: PUSH
45251: LD_INT 0
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PUSH
45258: LD_INT 1
45260: PUSH
45261: LD_INT 1
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 0
45270: PUSH
45271: LD_INT 1
45273: PUSH
45274: EMPTY
45275: LIST
45276: LIST
45277: PUSH
45278: LD_INT 1
45280: NEG
45281: PUSH
45282: LD_INT 0
45284: PUSH
45285: EMPTY
45286: LIST
45287: LIST
45288: PUSH
45289: LD_INT 1
45291: NEG
45292: PUSH
45293: LD_INT 1
45295: NEG
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 1
45303: NEG
45304: PUSH
45305: LD_INT 2
45307: NEG
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: PUSH
45313: LD_INT 0
45315: PUSH
45316: LD_INT 2
45318: NEG
45319: PUSH
45320: EMPTY
45321: LIST
45322: LIST
45323: PUSH
45324: LD_INT 1
45326: PUSH
45327: LD_INT 1
45329: NEG
45330: PUSH
45331: EMPTY
45332: LIST
45333: LIST
45334: PUSH
45335: LD_INT 2
45337: PUSH
45338: LD_INT 0
45340: PUSH
45341: EMPTY
45342: LIST
45343: LIST
45344: PUSH
45345: LD_INT 2
45347: PUSH
45348: LD_INT 1
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: PUSH
45355: LD_INT 2
45357: PUSH
45358: LD_INT 2
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: PUSH
45365: LD_INT 1
45367: PUSH
45368: LD_INT 2
45370: PUSH
45371: EMPTY
45372: LIST
45373: LIST
45374: PUSH
45375: LD_INT 0
45377: PUSH
45378: LD_INT 2
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 1
45387: NEG
45388: PUSH
45389: LD_INT 1
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 2
45398: NEG
45399: PUSH
45400: LD_INT 0
45402: PUSH
45403: EMPTY
45404: LIST
45405: LIST
45406: PUSH
45407: LD_INT 2
45409: NEG
45410: PUSH
45411: LD_INT 1
45413: NEG
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 2
45421: NEG
45422: PUSH
45423: LD_INT 2
45425: NEG
45426: PUSH
45427: EMPTY
45428: LIST
45429: LIST
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: LIST
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45452: LD_ADDR_VAR 0 59
45456: PUSH
45457: LD_INT 0
45459: PUSH
45460: LD_INT 0
45462: PUSH
45463: EMPTY
45464: LIST
45465: LIST
45466: PUSH
45467: LD_INT 0
45469: PUSH
45470: LD_INT 1
45472: NEG
45473: PUSH
45474: EMPTY
45475: LIST
45476: LIST
45477: PUSH
45478: LD_INT 1
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: EMPTY
45485: LIST
45486: LIST
45487: PUSH
45488: LD_INT 1
45490: PUSH
45491: LD_INT 1
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: LD_INT 0
45500: PUSH
45501: LD_INT 1
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: PUSH
45508: LD_INT 1
45510: NEG
45511: PUSH
45512: LD_INT 0
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 1
45521: NEG
45522: PUSH
45523: LD_INT 1
45525: NEG
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45540: LD_ADDR_VAR 0 60
45544: PUSH
45545: LD_INT 0
45547: PUSH
45548: LD_INT 0
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: PUSH
45555: LD_INT 0
45557: PUSH
45558: LD_INT 1
45560: NEG
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 1
45568: PUSH
45569: LD_INT 0
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 1
45578: PUSH
45579: LD_INT 1
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 0
45588: PUSH
45589: LD_INT 1
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: LD_INT 1
45598: NEG
45599: PUSH
45600: LD_INT 0
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: PUSH
45607: LD_INT 1
45609: NEG
45610: PUSH
45611: LD_INT 1
45613: NEG
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: EMPTY
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45628: LD_ADDR_VAR 0 61
45632: PUSH
45633: LD_INT 0
45635: PUSH
45636: LD_INT 0
45638: PUSH
45639: EMPTY
45640: LIST
45641: LIST
45642: PUSH
45643: LD_INT 0
45645: PUSH
45646: LD_INT 1
45648: NEG
45649: PUSH
45650: EMPTY
45651: LIST
45652: LIST
45653: PUSH
45654: LD_INT 1
45656: PUSH
45657: LD_INT 0
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: PUSH
45664: LD_INT 1
45666: PUSH
45667: LD_INT 1
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 0
45676: PUSH
45677: LD_INT 1
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: PUSH
45684: LD_INT 1
45686: NEG
45687: PUSH
45688: LD_INT 0
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PUSH
45695: LD_INT 1
45697: NEG
45698: PUSH
45699: LD_INT 1
45701: NEG
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: EMPTY
45708: LIST
45709: LIST
45710: LIST
45711: LIST
45712: LIST
45713: LIST
45714: LIST
45715: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45716: LD_ADDR_VAR 0 62
45720: PUSH
45721: LD_INT 0
45723: PUSH
45724: LD_INT 0
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 0
45733: PUSH
45734: LD_INT 1
45736: NEG
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 1
45744: PUSH
45745: LD_INT 0
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 1
45754: PUSH
45755: LD_INT 1
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 0
45764: PUSH
45765: LD_INT 1
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 1
45774: NEG
45775: PUSH
45776: LD_INT 0
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: PUSH
45783: LD_INT 1
45785: NEG
45786: PUSH
45787: LD_INT 1
45789: NEG
45790: PUSH
45791: EMPTY
45792: LIST
45793: LIST
45794: PUSH
45795: EMPTY
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45804: LD_ADDR_VAR 0 63
45808: PUSH
45809: LD_INT 0
45811: PUSH
45812: LD_INT 0
45814: PUSH
45815: EMPTY
45816: LIST
45817: LIST
45818: PUSH
45819: LD_INT 0
45821: PUSH
45822: LD_INT 1
45824: NEG
45825: PUSH
45826: EMPTY
45827: LIST
45828: LIST
45829: PUSH
45830: LD_INT 1
45832: PUSH
45833: LD_INT 0
45835: PUSH
45836: EMPTY
45837: LIST
45838: LIST
45839: PUSH
45840: LD_INT 1
45842: PUSH
45843: LD_INT 1
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PUSH
45850: LD_INT 0
45852: PUSH
45853: LD_INT 1
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PUSH
45860: LD_INT 1
45862: NEG
45863: PUSH
45864: LD_INT 0
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 1
45873: NEG
45874: PUSH
45875: LD_INT 1
45877: NEG
45878: PUSH
45879: EMPTY
45880: LIST
45881: LIST
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45892: LD_ADDR_VAR 0 64
45896: PUSH
45897: LD_INT 0
45899: PUSH
45900: LD_INT 0
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: PUSH
45907: LD_INT 0
45909: PUSH
45910: LD_INT 1
45912: NEG
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: PUSH
45918: LD_INT 1
45920: PUSH
45921: LD_INT 0
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: LD_INT 1
45930: PUSH
45931: LD_INT 1
45933: PUSH
45934: EMPTY
45935: LIST
45936: LIST
45937: PUSH
45938: LD_INT 0
45940: PUSH
45941: LD_INT 1
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 1
45950: NEG
45951: PUSH
45952: LD_INT 0
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 1
45961: NEG
45962: PUSH
45963: LD_INT 1
45965: NEG
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: PUSH
45971: EMPTY
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: ST_TO_ADDR
// end ; 1 :
45980: GO 51877
45982: LD_INT 1
45984: DOUBLE
45985: EQUAL
45986: IFTRUE 45990
45988: GO 48613
45990: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45991: LD_ADDR_VAR 0 11
45995: PUSH
45996: LD_INT 1
45998: NEG
45999: PUSH
46000: LD_INT 3
46002: NEG
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 0
46010: PUSH
46011: LD_INT 3
46013: NEG
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 1
46021: PUSH
46022: LD_INT 2
46024: NEG
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: LIST
46034: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46035: LD_ADDR_VAR 0 12
46039: PUSH
46040: LD_INT 2
46042: PUSH
46043: LD_INT 1
46045: NEG
46046: PUSH
46047: EMPTY
46048: LIST
46049: LIST
46050: PUSH
46051: LD_INT 3
46053: PUSH
46054: LD_INT 0
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 3
46063: PUSH
46064: LD_INT 1
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: LIST
46075: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46076: LD_ADDR_VAR 0 13
46080: PUSH
46081: LD_INT 3
46083: PUSH
46084: LD_INT 2
46086: PUSH
46087: EMPTY
46088: LIST
46089: LIST
46090: PUSH
46091: LD_INT 3
46093: PUSH
46094: LD_INT 3
46096: PUSH
46097: EMPTY
46098: LIST
46099: LIST
46100: PUSH
46101: LD_INT 2
46103: PUSH
46104: LD_INT 3
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: LIST
46115: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46116: LD_ADDR_VAR 0 14
46120: PUSH
46121: LD_INT 1
46123: PUSH
46124: LD_INT 3
46126: PUSH
46127: EMPTY
46128: LIST
46129: LIST
46130: PUSH
46131: LD_INT 0
46133: PUSH
46134: LD_INT 3
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PUSH
46141: LD_INT 1
46143: NEG
46144: PUSH
46145: LD_INT 2
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: LIST
46156: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46157: LD_ADDR_VAR 0 15
46161: PUSH
46162: LD_INT 2
46164: NEG
46165: PUSH
46166: LD_INT 1
46168: PUSH
46169: EMPTY
46170: LIST
46171: LIST
46172: PUSH
46173: LD_INT 3
46175: NEG
46176: PUSH
46177: LD_INT 0
46179: PUSH
46180: EMPTY
46181: LIST
46182: LIST
46183: PUSH
46184: LD_INT 3
46186: NEG
46187: PUSH
46188: LD_INT 1
46190: NEG
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: PUSH
46196: EMPTY
46197: LIST
46198: LIST
46199: LIST
46200: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46201: LD_ADDR_VAR 0 16
46205: PUSH
46206: LD_INT 2
46208: NEG
46209: PUSH
46210: LD_INT 3
46212: NEG
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 3
46220: NEG
46221: PUSH
46222: LD_INT 2
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: LD_INT 3
46232: NEG
46233: PUSH
46234: LD_INT 3
46236: NEG
46237: PUSH
46238: EMPTY
46239: LIST
46240: LIST
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: LIST
46246: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46247: LD_ADDR_VAR 0 17
46251: PUSH
46252: LD_INT 1
46254: NEG
46255: PUSH
46256: LD_INT 3
46258: NEG
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 0
46266: PUSH
46267: LD_INT 3
46269: NEG
46270: PUSH
46271: EMPTY
46272: LIST
46273: LIST
46274: PUSH
46275: LD_INT 1
46277: PUSH
46278: LD_INT 2
46280: NEG
46281: PUSH
46282: EMPTY
46283: LIST
46284: LIST
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: LIST
46290: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46291: LD_ADDR_VAR 0 18
46295: PUSH
46296: LD_INT 2
46298: PUSH
46299: LD_INT 1
46301: NEG
46302: PUSH
46303: EMPTY
46304: LIST
46305: LIST
46306: PUSH
46307: LD_INT 3
46309: PUSH
46310: LD_INT 0
46312: PUSH
46313: EMPTY
46314: LIST
46315: LIST
46316: PUSH
46317: LD_INT 3
46319: PUSH
46320: LD_INT 1
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: LIST
46331: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46332: LD_ADDR_VAR 0 19
46336: PUSH
46337: LD_INT 3
46339: PUSH
46340: LD_INT 2
46342: PUSH
46343: EMPTY
46344: LIST
46345: LIST
46346: PUSH
46347: LD_INT 3
46349: PUSH
46350: LD_INT 3
46352: PUSH
46353: EMPTY
46354: LIST
46355: LIST
46356: PUSH
46357: LD_INT 2
46359: PUSH
46360: LD_INT 3
46362: PUSH
46363: EMPTY
46364: LIST
46365: LIST
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: LIST
46371: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46372: LD_ADDR_VAR 0 20
46376: PUSH
46377: LD_INT 1
46379: PUSH
46380: LD_INT 3
46382: PUSH
46383: EMPTY
46384: LIST
46385: LIST
46386: PUSH
46387: LD_INT 0
46389: PUSH
46390: LD_INT 3
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: PUSH
46397: LD_INT 1
46399: NEG
46400: PUSH
46401: LD_INT 2
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: LIST
46412: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46413: LD_ADDR_VAR 0 21
46417: PUSH
46418: LD_INT 2
46420: NEG
46421: PUSH
46422: LD_INT 1
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: PUSH
46429: LD_INT 3
46431: NEG
46432: PUSH
46433: LD_INT 0
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: PUSH
46440: LD_INT 3
46442: NEG
46443: PUSH
46444: LD_INT 1
46446: NEG
46447: PUSH
46448: EMPTY
46449: LIST
46450: LIST
46451: PUSH
46452: EMPTY
46453: LIST
46454: LIST
46455: LIST
46456: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46457: LD_ADDR_VAR 0 22
46461: PUSH
46462: LD_INT 2
46464: NEG
46465: PUSH
46466: LD_INT 3
46468: NEG
46469: PUSH
46470: EMPTY
46471: LIST
46472: LIST
46473: PUSH
46474: LD_INT 3
46476: NEG
46477: PUSH
46478: LD_INT 2
46480: NEG
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: LD_INT 3
46488: NEG
46489: PUSH
46490: LD_INT 3
46492: NEG
46493: PUSH
46494: EMPTY
46495: LIST
46496: LIST
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: LIST
46502: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46503: LD_ADDR_VAR 0 23
46507: PUSH
46508: LD_INT 0
46510: PUSH
46511: LD_INT 3
46513: NEG
46514: PUSH
46515: EMPTY
46516: LIST
46517: LIST
46518: PUSH
46519: LD_INT 1
46521: NEG
46522: PUSH
46523: LD_INT 4
46525: NEG
46526: PUSH
46527: EMPTY
46528: LIST
46529: LIST
46530: PUSH
46531: LD_INT 1
46533: PUSH
46534: LD_INT 3
46536: NEG
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: PUSH
46542: EMPTY
46543: LIST
46544: LIST
46545: LIST
46546: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46547: LD_ADDR_VAR 0 24
46551: PUSH
46552: LD_INT 3
46554: PUSH
46555: LD_INT 0
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: PUSH
46562: LD_INT 3
46564: PUSH
46565: LD_INT 1
46567: NEG
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: PUSH
46573: LD_INT 4
46575: PUSH
46576: LD_INT 1
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: EMPTY
46584: LIST
46585: LIST
46586: LIST
46587: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46588: LD_ADDR_VAR 0 25
46592: PUSH
46593: LD_INT 3
46595: PUSH
46596: LD_INT 3
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 4
46605: PUSH
46606: LD_INT 3
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 3
46615: PUSH
46616: LD_INT 4
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: LIST
46627: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46628: LD_ADDR_VAR 0 26
46632: PUSH
46633: LD_INT 0
46635: PUSH
46636: LD_INT 3
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 1
46645: PUSH
46646: LD_INT 4
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 1
46655: NEG
46656: PUSH
46657: LD_INT 3
46659: PUSH
46660: EMPTY
46661: LIST
46662: LIST
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: LIST
46668: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46669: LD_ADDR_VAR 0 27
46673: PUSH
46674: LD_INT 3
46676: NEG
46677: PUSH
46678: LD_INT 0
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: PUSH
46685: LD_INT 3
46687: NEG
46688: PUSH
46689: LD_INT 1
46691: PUSH
46692: EMPTY
46693: LIST
46694: LIST
46695: PUSH
46696: LD_INT 4
46698: NEG
46699: PUSH
46700: LD_INT 1
46702: NEG
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: EMPTY
46709: LIST
46710: LIST
46711: LIST
46712: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46713: LD_ADDR_VAR 0 28
46717: PUSH
46718: LD_INT 3
46720: NEG
46721: PUSH
46722: LD_INT 3
46724: NEG
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: PUSH
46730: LD_INT 3
46732: NEG
46733: PUSH
46734: LD_INT 4
46736: NEG
46737: PUSH
46738: EMPTY
46739: LIST
46740: LIST
46741: PUSH
46742: LD_INT 4
46744: NEG
46745: PUSH
46746: LD_INT 3
46748: NEG
46749: PUSH
46750: EMPTY
46751: LIST
46752: LIST
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: LIST
46758: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46759: LD_ADDR_VAR 0 29
46763: PUSH
46764: LD_INT 1
46766: NEG
46767: PUSH
46768: LD_INT 3
46770: NEG
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 0
46778: PUSH
46779: LD_INT 3
46781: NEG
46782: PUSH
46783: EMPTY
46784: LIST
46785: LIST
46786: PUSH
46787: LD_INT 1
46789: PUSH
46790: LD_INT 2
46792: NEG
46793: PUSH
46794: EMPTY
46795: LIST
46796: LIST
46797: PUSH
46798: LD_INT 1
46800: NEG
46801: PUSH
46802: LD_INT 4
46804: NEG
46805: PUSH
46806: EMPTY
46807: LIST
46808: LIST
46809: PUSH
46810: LD_INT 0
46812: PUSH
46813: LD_INT 4
46815: NEG
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: LD_INT 1
46823: PUSH
46824: LD_INT 3
46826: NEG
46827: PUSH
46828: EMPTY
46829: LIST
46830: LIST
46831: PUSH
46832: LD_INT 1
46834: NEG
46835: PUSH
46836: LD_INT 5
46838: NEG
46839: PUSH
46840: EMPTY
46841: LIST
46842: LIST
46843: PUSH
46844: LD_INT 0
46846: PUSH
46847: LD_INT 5
46849: NEG
46850: PUSH
46851: EMPTY
46852: LIST
46853: LIST
46854: PUSH
46855: LD_INT 1
46857: PUSH
46858: LD_INT 4
46860: NEG
46861: PUSH
46862: EMPTY
46863: LIST
46864: LIST
46865: PUSH
46866: LD_INT 1
46868: NEG
46869: PUSH
46870: LD_INT 6
46872: NEG
46873: PUSH
46874: EMPTY
46875: LIST
46876: LIST
46877: PUSH
46878: LD_INT 0
46880: PUSH
46881: LD_INT 6
46883: NEG
46884: PUSH
46885: EMPTY
46886: LIST
46887: LIST
46888: PUSH
46889: LD_INT 1
46891: PUSH
46892: LD_INT 5
46894: NEG
46895: PUSH
46896: EMPTY
46897: LIST
46898: LIST
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46914: LD_ADDR_VAR 0 30
46918: PUSH
46919: LD_INT 2
46921: PUSH
46922: LD_INT 1
46924: NEG
46925: PUSH
46926: EMPTY
46927: LIST
46928: LIST
46929: PUSH
46930: LD_INT 3
46932: PUSH
46933: LD_INT 0
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: PUSH
46940: LD_INT 3
46942: PUSH
46943: LD_INT 1
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_INT 3
46952: PUSH
46953: LD_INT 1
46955: NEG
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: PUSH
46961: LD_INT 4
46963: PUSH
46964: LD_INT 0
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PUSH
46971: LD_INT 4
46973: PUSH
46974: LD_INT 1
46976: PUSH
46977: EMPTY
46978: LIST
46979: LIST
46980: PUSH
46981: LD_INT 4
46983: PUSH
46984: LD_INT 1
46986: NEG
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: PUSH
46992: LD_INT 5
46994: PUSH
46995: LD_INT 0
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: PUSH
47002: LD_INT 5
47004: PUSH
47005: LD_INT 1
47007: PUSH
47008: EMPTY
47009: LIST
47010: LIST
47011: PUSH
47012: LD_INT 5
47014: PUSH
47015: LD_INT 1
47017: NEG
47018: PUSH
47019: EMPTY
47020: LIST
47021: LIST
47022: PUSH
47023: LD_INT 6
47025: PUSH
47026: LD_INT 0
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 6
47035: PUSH
47036: LD_INT 1
47038: PUSH
47039: EMPTY
47040: LIST
47041: LIST
47042: PUSH
47043: EMPTY
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
47057: LD_ADDR_VAR 0 31
47061: PUSH
47062: LD_INT 3
47064: PUSH
47065: LD_INT 2
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: PUSH
47072: LD_INT 3
47074: PUSH
47075: LD_INT 3
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: PUSH
47082: LD_INT 2
47084: PUSH
47085: LD_INT 3
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: PUSH
47092: LD_INT 4
47094: PUSH
47095: LD_INT 3
47097: PUSH
47098: EMPTY
47099: LIST
47100: LIST
47101: PUSH
47102: LD_INT 4
47104: PUSH
47105: LD_INT 4
47107: PUSH
47108: EMPTY
47109: LIST
47110: LIST
47111: PUSH
47112: LD_INT 3
47114: PUSH
47115: LD_INT 4
47117: PUSH
47118: EMPTY
47119: LIST
47120: LIST
47121: PUSH
47122: LD_INT 5
47124: PUSH
47125: LD_INT 4
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 5
47134: PUSH
47135: LD_INT 5
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 4
47144: PUSH
47145: LD_INT 5
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: LD_INT 6
47154: PUSH
47155: LD_INT 5
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: PUSH
47162: LD_INT 6
47164: PUSH
47165: LD_INT 6
47167: PUSH
47168: EMPTY
47169: LIST
47170: LIST
47171: PUSH
47172: LD_INT 5
47174: PUSH
47175: LD_INT 6
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
47196: LD_ADDR_VAR 0 32
47200: PUSH
47201: LD_INT 1
47203: PUSH
47204: LD_INT 3
47206: PUSH
47207: EMPTY
47208: LIST
47209: LIST
47210: PUSH
47211: LD_INT 0
47213: PUSH
47214: LD_INT 3
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: PUSH
47221: LD_INT 1
47223: NEG
47224: PUSH
47225: LD_INT 2
47227: PUSH
47228: EMPTY
47229: LIST
47230: LIST
47231: PUSH
47232: LD_INT 1
47234: PUSH
47235: LD_INT 4
47237: PUSH
47238: EMPTY
47239: LIST
47240: LIST
47241: PUSH
47242: LD_INT 0
47244: PUSH
47245: LD_INT 4
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: PUSH
47252: LD_INT 1
47254: NEG
47255: PUSH
47256: LD_INT 3
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PUSH
47263: LD_INT 1
47265: PUSH
47266: LD_INT 5
47268: PUSH
47269: EMPTY
47270: LIST
47271: LIST
47272: PUSH
47273: LD_INT 0
47275: PUSH
47276: LD_INT 5
47278: PUSH
47279: EMPTY
47280: LIST
47281: LIST
47282: PUSH
47283: LD_INT 1
47285: NEG
47286: PUSH
47287: LD_INT 4
47289: PUSH
47290: EMPTY
47291: LIST
47292: LIST
47293: PUSH
47294: LD_INT 1
47296: PUSH
47297: LD_INT 6
47299: PUSH
47300: EMPTY
47301: LIST
47302: LIST
47303: PUSH
47304: LD_INT 0
47306: PUSH
47307: LD_INT 6
47309: PUSH
47310: EMPTY
47311: LIST
47312: LIST
47313: PUSH
47314: LD_INT 1
47316: NEG
47317: PUSH
47318: LD_INT 5
47320: PUSH
47321: EMPTY
47322: LIST
47323: LIST
47324: PUSH
47325: EMPTY
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: LIST
47333: LIST
47334: LIST
47335: LIST
47336: LIST
47337: LIST
47338: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
47339: LD_ADDR_VAR 0 33
47343: PUSH
47344: LD_INT 2
47346: NEG
47347: PUSH
47348: LD_INT 1
47350: PUSH
47351: EMPTY
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 3
47357: NEG
47358: PUSH
47359: LD_INT 0
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: PUSH
47366: LD_INT 3
47368: NEG
47369: PUSH
47370: LD_INT 1
47372: NEG
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: PUSH
47378: LD_INT 3
47380: NEG
47381: PUSH
47382: LD_INT 1
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PUSH
47389: LD_INT 4
47391: NEG
47392: PUSH
47393: LD_INT 0
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: PUSH
47400: LD_INT 4
47402: NEG
47403: PUSH
47404: LD_INT 1
47406: NEG
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: PUSH
47412: LD_INT 4
47414: NEG
47415: PUSH
47416: LD_INT 1
47418: PUSH
47419: EMPTY
47420: LIST
47421: LIST
47422: PUSH
47423: LD_INT 5
47425: NEG
47426: PUSH
47427: LD_INT 0
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: PUSH
47434: LD_INT 5
47436: NEG
47437: PUSH
47438: LD_INT 1
47440: NEG
47441: PUSH
47442: EMPTY
47443: LIST
47444: LIST
47445: PUSH
47446: LD_INT 5
47448: NEG
47449: PUSH
47450: LD_INT 1
47452: PUSH
47453: EMPTY
47454: LIST
47455: LIST
47456: PUSH
47457: LD_INT 6
47459: NEG
47460: PUSH
47461: LD_INT 0
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 6
47470: NEG
47471: PUSH
47472: LD_INT 1
47474: NEG
47475: PUSH
47476: EMPTY
47477: LIST
47478: LIST
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: LIST
47487: LIST
47488: LIST
47489: LIST
47490: LIST
47491: LIST
47492: LIST
47493: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47494: LD_ADDR_VAR 0 34
47498: PUSH
47499: LD_INT 2
47501: NEG
47502: PUSH
47503: LD_INT 3
47505: NEG
47506: PUSH
47507: EMPTY
47508: LIST
47509: LIST
47510: PUSH
47511: LD_INT 3
47513: NEG
47514: PUSH
47515: LD_INT 2
47517: NEG
47518: PUSH
47519: EMPTY
47520: LIST
47521: LIST
47522: PUSH
47523: LD_INT 3
47525: NEG
47526: PUSH
47527: LD_INT 3
47529: NEG
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 3
47537: NEG
47538: PUSH
47539: LD_INT 4
47541: NEG
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: PUSH
47547: LD_INT 4
47549: NEG
47550: PUSH
47551: LD_INT 3
47553: NEG
47554: PUSH
47555: EMPTY
47556: LIST
47557: LIST
47558: PUSH
47559: LD_INT 4
47561: NEG
47562: PUSH
47563: LD_INT 4
47565: NEG
47566: PUSH
47567: EMPTY
47568: LIST
47569: LIST
47570: PUSH
47571: LD_INT 4
47573: NEG
47574: PUSH
47575: LD_INT 5
47577: NEG
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: PUSH
47583: LD_INT 5
47585: NEG
47586: PUSH
47587: LD_INT 4
47589: NEG
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PUSH
47595: LD_INT 5
47597: NEG
47598: PUSH
47599: LD_INT 5
47601: NEG
47602: PUSH
47603: EMPTY
47604: LIST
47605: LIST
47606: PUSH
47607: LD_INT 5
47609: NEG
47610: PUSH
47611: LD_INT 6
47613: NEG
47614: PUSH
47615: EMPTY
47616: LIST
47617: LIST
47618: PUSH
47619: LD_INT 6
47621: NEG
47622: PUSH
47623: LD_INT 5
47625: NEG
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 6
47633: NEG
47634: PUSH
47635: LD_INT 6
47637: NEG
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: PUSH
47643: EMPTY
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47657: LD_ADDR_VAR 0 41
47661: PUSH
47662: LD_INT 0
47664: PUSH
47665: LD_INT 2
47667: NEG
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PUSH
47673: LD_INT 1
47675: NEG
47676: PUSH
47677: LD_INT 3
47679: NEG
47680: PUSH
47681: EMPTY
47682: LIST
47683: LIST
47684: PUSH
47685: LD_INT 1
47687: PUSH
47688: LD_INT 2
47690: NEG
47691: PUSH
47692: EMPTY
47693: LIST
47694: LIST
47695: PUSH
47696: EMPTY
47697: LIST
47698: LIST
47699: LIST
47700: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47701: LD_ADDR_VAR 0 42
47705: PUSH
47706: LD_INT 2
47708: PUSH
47709: LD_INT 0
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: PUSH
47716: LD_INT 2
47718: PUSH
47719: LD_INT 1
47721: NEG
47722: PUSH
47723: EMPTY
47724: LIST
47725: LIST
47726: PUSH
47727: LD_INT 3
47729: PUSH
47730: LD_INT 1
47732: PUSH
47733: EMPTY
47734: LIST
47735: LIST
47736: PUSH
47737: EMPTY
47738: LIST
47739: LIST
47740: LIST
47741: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47742: LD_ADDR_VAR 0 43
47746: PUSH
47747: LD_INT 2
47749: PUSH
47750: LD_INT 2
47752: PUSH
47753: EMPTY
47754: LIST
47755: LIST
47756: PUSH
47757: LD_INT 3
47759: PUSH
47760: LD_INT 2
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: PUSH
47767: LD_INT 2
47769: PUSH
47770: LD_INT 3
47772: PUSH
47773: EMPTY
47774: LIST
47775: LIST
47776: PUSH
47777: EMPTY
47778: LIST
47779: LIST
47780: LIST
47781: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47782: LD_ADDR_VAR 0 44
47786: PUSH
47787: LD_INT 0
47789: PUSH
47790: LD_INT 2
47792: PUSH
47793: EMPTY
47794: LIST
47795: LIST
47796: PUSH
47797: LD_INT 1
47799: PUSH
47800: LD_INT 3
47802: PUSH
47803: EMPTY
47804: LIST
47805: LIST
47806: PUSH
47807: LD_INT 1
47809: NEG
47810: PUSH
47811: LD_INT 2
47813: PUSH
47814: EMPTY
47815: LIST
47816: LIST
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: LIST
47822: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47823: LD_ADDR_VAR 0 45
47827: PUSH
47828: LD_INT 2
47830: NEG
47831: PUSH
47832: LD_INT 0
47834: PUSH
47835: EMPTY
47836: LIST
47837: LIST
47838: PUSH
47839: LD_INT 2
47841: NEG
47842: PUSH
47843: LD_INT 1
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: PUSH
47850: LD_INT 3
47852: NEG
47853: PUSH
47854: LD_INT 1
47856: NEG
47857: PUSH
47858: EMPTY
47859: LIST
47860: LIST
47861: PUSH
47862: EMPTY
47863: LIST
47864: LIST
47865: LIST
47866: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47867: LD_ADDR_VAR 0 46
47871: PUSH
47872: LD_INT 2
47874: NEG
47875: PUSH
47876: LD_INT 2
47878: NEG
47879: PUSH
47880: EMPTY
47881: LIST
47882: LIST
47883: PUSH
47884: LD_INT 2
47886: NEG
47887: PUSH
47888: LD_INT 3
47890: NEG
47891: PUSH
47892: EMPTY
47893: LIST
47894: LIST
47895: PUSH
47896: LD_INT 3
47898: NEG
47899: PUSH
47900: LD_INT 2
47902: NEG
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: PUSH
47908: EMPTY
47909: LIST
47910: LIST
47911: LIST
47912: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47913: LD_ADDR_VAR 0 47
47917: PUSH
47918: LD_INT 2
47920: NEG
47921: PUSH
47922: LD_INT 3
47924: NEG
47925: PUSH
47926: EMPTY
47927: LIST
47928: LIST
47929: PUSH
47930: LD_INT 1
47932: NEG
47933: PUSH
47934: LD_INT 3
47936: NEG
47937: PUSH
47938: EMPTY
47939: LIST
47940: LIST
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47946: LD_ADDR_VAR 0 48
47950: PUSH
47951: LD_INT 1
47953: PUSH
47954: LD_INT 2
47956: NEG
47957: PUSH
47958: EMPTY
47959: LIST
47960: LIST
47961: PUSH
47962: LD_INT 2
47964: PUSH
47965: LD_INT 1
47967: NEG
47968: PUSH
47969: EMPTY
47970: LIST
47971: LIST
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47977: LD_ADDR_VAR 0 49
47981: PUSH
47982: LD_INT 3
47984: PUSH
47985: LD_INT 1
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: PUSH
47992: LD_INT 3
47994: PUSH
47995: LD_INT 2
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: PUSH
48002: EMPTY
48003: LIST
48004: LIST
48005: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
48006: LD_ADDR_VAR 0 50
48010: PUSH
48011: LD_INT 2
48013: PUSH
48014: LD_INT 3
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: PUSH
48021: LD_INT 1
48023: PUSH
48024: LD_INT 3
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: PUSH
48031: EMPTY
48032: LIST
48033: LIST
48034: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
48035: LD_ADDR_VAR 0 51
48039: PUSH
48040: LD_INT 1
48042: NEG
48043: PUSH
48044: LD_INT 2
48046: PUSH
48047: EMPTY
48048: LIST
48049: LIST
48050: PUSH
48051: LD_INT 2
48053: NEG
48054: PUSH
48055: LD_INT 1
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: PUSH
48062: EMPTY
48063: LIST
48064: LIST
48065: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
48066: LD_ADDR_VAR 0 52
48070: PUSH
48071: LD_INT 3
48073: NEG
48074: PUSH
48075: LD_INT 1
48077: NEG
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: PUSH
48083: LD_INT 3
48085: NEG
48086: PUSH
48087: LD_INT 2
48089: NEG
48090: PUSH
48091: EMPTY
48092: LIST
48093: LIST
48094: PUSH
48095: EMPTY
48096: LIST
48097: LIST
48098: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
48099: LD_ADDR_VAR 0 53
48103: PUSH
48104: LD_INT 1
48106: NEG
48107: PUSH
48108: LD_INT 3
48110: NEG
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: PUSH
48116: LD_INT 0
48118: PUSH
48119: LD_INT 3
48121: NEG
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: PUSH
48127: LD_INT 1
48129: PUSH
48130: LD_INT 2
48132: NEG
48133: PUSH
48134: EMPTY
48135: LIST
48136: LIST
48137: PUSH
48138: EMPTY
48139: LIST
48140: LIST
48141: LIST
48142: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
48143: LD_ADDR_VAR 0 54
48147: PUSH
48148: LD_INT 2
48150: PUSH
48151: LD_INT 1
48153: NEG
48154: PUSH
48155: EMPTY
48156: LIST
48157: LIST
48158: PUSH
48159: LD_INT 3
48161: PUSH
48162: LD_INT 0
48164: PUSH
48165: EMPTY
48166: LIST
48167: LIST
48168: PUSH
48169: LD_INT 3
48171: PUSH
48172: LD_INT 1
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: LIST
48183: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
48184: LD_ADDR_VAR 0 55
48188: PUSH
48189: LD_INT 3
48191: PUSH
48192: LD_INT 2
48194: PUSH
48195: EMPTY
48196: LIST
48197: LIST
48198: PUSH
48199: LD_INT 3
48201: PUSH
48202: LD_INT 3
48204: PUSH
48205: EMPTY
48206: LIST
48207: LIST
48208: PUSH
48209: LD_INT 2
48211: PUSH
48212: LD_INT 3
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: LIST
48223: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
48224: LD_ADDR_VAR 0 56
48228: PUSH
48229: LD_INT 1
48231: PUSH
48232: LD_INT 3
48234: PUSH
48235: EMPTY
48236: LIST
48237: LIST
48238: PUSH
48239: LD_INT 0
48241: PUSH
48242: LD_INT 3
48244: PUSH
48245: EMPTY
48246: LIST
48247: LIST
48248: PUSH
48249: LD_INT 1
48251: NEG
48252: PUSH
48253: LD_INT 2
48255: PUSH
48256: EMPTY
48257: LIST
48258: LIST
48259: PUSH
48260: EMPTY
48261: LIST
48262: LIST
48263: LIST
48264: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
48265: LD_ADDR_VAR 0 57
48269: PUSH
48270: LD_INT 2
48272: NEG
48273: PUSH
48274: LD_INT 1
48276: PUSH
48277: EMPTY
48278: LIST
48279: LIST
48280: PUSH
48281: LD_INT 3
48283: NEG
48284: PUSH
48285: LD_INT 0
48287: PUSH
48288: EMPTY
48289: LIST
48290: LIST
48291: PUSH
48292: LD_INT 3
48294: NEG
48295: PUSH
48296: LD_INT 1
48298: NEG
48299: PUSH
48300: EMPTY
48301: LIST
48302: LIST
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: LIST
48308: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
48309: LD_ADDR_VAR 0 58
48313: PUSH
48314: LD_INT 2
48316: NEG
48317: PUSH
48318: LD_INT 3
48320: NEG
48321: PUSH
48322: EMPTY
48323: LIST
48324: LIST
48325: PUSH
48326: LD_INT 3
48328: NEG
48329: PUSH
48330: LD_INT 2
48332: NEG
48333: PUSH
48334: EMPTY
48335: LIST
48336: LIST
48337: PUSH
48338: LD_INT 3
48340: NEG
48341: PUSH
48342: LD_INT 3
48344: NEG
48345: PUSH
48346: EMPTY
48347: LIST
48348: LIST
48349: PUSH
48350: EMPTY
48351: LIST
48352: LIST
48353: LIST
48354: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
48355: LD_ADDR_VAR 0 59
48359: PUSH
48360: LD_INT 1
48362: NEG
48363: PUSH
48364: LD_INT 2
48366: NEG
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: PUSH
48372: LD_INT 0
48374: PUSH
48375: LD_INT 2
48377: NEG
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: LD_INT 1
48385: PUSH
48386: LD_INT 1
48388: NEG
48389: PUSH
48390: EMPTY
48391: LIST
48392: LIST
48393: PUSH
48394: EMPTY
48395: LIST
48396: LIST
48397: LIST
48398: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48399: LD_ADDR_VAR 0 60
48403: PUSH
48404: LD_INT 1
48406: PUSH
48407: LD_INT 1
48409: NEG
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 2
48417: PUSH
48418: LD_INT 0
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: PUSH
48425: LD_INT 2
48427: PUSH
48428: LD_INT 1
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: EMPTY
48436: LIST
48437: LIST
48438: LIST
48439: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48440: LD_ADDR_VAR 0 61
48444: PUSH
48445: LD_INT 2
48447: PUSH
48448: LD_INT 1
48450: PUSH
48451: EMPTY
48452: LIST
48453: LIST
48454: PUSH
48455: LD_INT 2
48457: PUSH
48458: LD_INT 2
48460: PUSH
48461: EMPTY
48462: LIST
48463: LIST
48464: PUSH
48465: LD_INT 1
48467: PUSH
48468: LD_INT 2
48470: PUSH
48471: EMPTY
48472: LIST
48473: LIST
48474: PUSH
48475: EMPTY
48476: LIST
48477: LIST
48478: LIST
48479: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48480: LD_ADDR_VAR 0 62
48484: PUSH
48485: LD_INT 1
48487: PUSH
48488: LD_INT 2
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: LD_INT 0
48497: PUSH
48498: LD_INT 2
48500: PUSH
48501: EMPTY
48502: LIST
48503: LIST
48504: PUSH
48505: LD_INT 1
48507: NEG
48508: PUSH
48509: LD_INT 1
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: PUSH
48516: EMPTY
48517: LIST
48518: LIST
48519: LIST
48520: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48521: LD_ADDR_VAR 0 63
48525: PUSH
48526: LD_INT 1
48528: NEG
48529: PUSH
48530: LD_INT 1
48532: PUSH
48533: EMPTY
48534: LIST
48535: LIST
48536: PUSH
48537: LD_INT 2
48539: NEG
48540: PUSH
48541: LD_INT 0
48543: PUSH
48544: EMPTY
48545: LIST
48546: LIST
48547: PUSH
48548: LD_INT 2
48550: NEG
48551: PUSH
48552: LD_INT 1
48554: NEG
48555: PUSH
48556: EMPTY
48557: LIST
48558: LIST
48559: PUSH
48560: EMPTY
48561: LIST
48562: LIST
48563: LIST
48564: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48565: LD_ADDR_VAR 0 64
48569: PUSH
48570: LD_INT 1
48572: NEG
48573: PUSH
48574: LD_INT 2
48576: NEG
48577: PUSH
48578: EMPTY
48579: LIST
48580: LIST
48581: PUSH
48582: LD_INT 2
48584: NEG
48585: PUSH
48586: LD_INT 1
48588: NEG
48589: PUSH
48590: EMPTY
48591: LIST
48592: LIST
48593: PUSH
48594: LD_INT 2
48596: NEG
48597: PUSH
48598: LD_INT 2
48600: NEG
48601: PUSH
48602: EMPTY
48603: LIST
48604: LIST
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: LIST
48610: ST_TO_ADDR
// end ; 2 :
48611: GO 51877
48613: LD_INT 2
48615: DOUBLE
48616: EQUAL
48617: IFTRUE 48621
48619: GO 51876
48621: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48622: LD_ADDR_VAR 0 29
48626: PUSH
48627: LD_INT 4
48629: PUSH
48630: LD_INT 0
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: PUSH
48637: LD_INT 4
48639: PUSH
48640: LD_INT 1
48642: NEG
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: PUSH
48648: LD_INT 5
48650: PUSH
48651: LD_INT 0
48653: PUSH
48654: EMPTY
48655: LIST
48656: LIST
48657: PUSH
48658: LD_INT 5
48660: PUSH
48661: LD_INT 1
48663: PUSH
48664: EMPTY
48665: LIST
48666: LIST
48667: PUSH
48668: LD_INT 4
48670: PUSH
48671: LD_INT 1
48673: PUSH
48674: EMPTY
48675: LIST
48676: LIST
48677: PUSH
48678: LD_INT 3
48680: PUSH
48681: LD_INT 0
48683: PUSH
48684: EMPTY
48685: LIST
48686: LIST
48687: PUSH
48688: LD_INT 3
48690: PUSH
48691: LD_INT 1
48693: NEG
48694: PUSH
48695: EMPTY
48696: LIST
48697: LIST
48698: PUSH
48699: LD_INT 3
48701: PUSH
48702: LD_INT 2
48704: NEG
48705: PUSH
48706: EMPTY
48707: LIST
48708: LIST
48709: PUSH
48710: LD_INT 5
48712: PUSH
48713: LD_INT 2
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: PUSH
48720: LD_INT 3
48722: PUSH
48723: LD_INT 3
48725: PUSH
48726: EMPTY
48727: LIST
48728: LIST
48729: PUSH
48730: LD_INT 3
48732: PUSH
48733: LD_INT 2
48735: PUSH
48736: EMPTY
48737: LIST
48738: LIST
48739: PUSH
48740: LD_INT 4
48742: PUSH
48743: LD_INT 3
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: PUSH
48750: LD_INT 4
48752: PUSH
48753: LD_INT 4
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: PUSH
48760: LD_INT 3
48762: PUSH
48763: LD_INT 4
48765: PUSH
48766: EMPTY
48767: LIST
48768: LIST
48769: PUSH
48770: LD_INT 2
48772: PUSH
48773: LD_INT 3
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: PUSH
48780: LD_INT 2
48782: PUSH
48783: LD_INT 2
48785: PUSH
48786: EMPTY
48787: LIST
48788: LIST
48789: PUSH
48790: LD_INT 4
48792: PUSH
48793: LD_INT 2
48795: PUSH
48796: EMPTY
48797: LIST
48798: LIST
48799: PUSH
48800: LD_INT 2
48802: PUSH
48803: LD_INT 4
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: PUSH
48810: LD_INT 0
48812: PUSH
48813: LD_INT 4
48815: PUSH
48816: EMPTY
48817: LIST
48818: LIST
48819: PUSH
48820: LD_INT 0
48822: PUSH
48823: LD_INT 3
48825: PUSH
48826: EMPTY
48827: LIST
48828: LIST
48829: PUSH
48830: LD_INT 1
48832: PUSH
48833: LD_INT 4
48835: PUSH
48836: EMPTY
48837: LIST
48838: LIST
48839: PUSH
48840: LD_INT 1
48842: PUSH
48843: LD_INT 5
48845: PUSH
48846: EMPTY
48847: LIST
48848: LIST
48849: PUSH
48850: LD_INT 0
48852: PUSH
48853: LD_INT 5
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PUSH
48860: LD_INT 1
48862: NEG
48863: PUSH
48864: LD_INT 4
48866: PUSH
48867: EMPTY
48868: LIST
48869: LIST
48870: PUSH
48871: LD_INT 1
48873: NEG
48874: PUSH
48875: LD_INT 3
48877: PUSH
48878: EMPTY
48879: LIST
48880: LIST
48881: PUSH
48882: LD_INT 2
48884: PUSH
48885: LD_INT 5
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: PUSH
48892: LD_INT 2
48894: NEG
48895: PUSH
48896: LD_INT 3
48898: PUSH
48899: EMPTY
48900: LIST
48901: LIST
48902: PUSH
48903: LD_INT 3
48905: NEG
48906: PUSH
48907: LD_INT 0
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: PUSH
48914: LD_INT 3
48916: NEG
48917: PUSH
48918: LD_INT 1
48920: NEG
48921: PUSH
48922: EMPTY
48923: LIST
48924: LIST
48925: PUSH
48926: LD_INT 2
48928: NEG
48929: PUSH
48930: LD_INT 0
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PUSH
48937: LD_INT 2
48939: NEG
48940: PUSH
48941: LD_INT 1
48943: PUSH
48944: EMPTY
48945: LIST
48946: LIST
48947: PUSH
48948: LD_INT 3
48950: NEG
48951: PUSH
48952: LD_INT 1
48954: PUSH
48955: EMPTY
48956: LIST
48957: LIST
48958: PUSH
48959: LD_INT 4
48961: NEG
48962: PUSH
48963: LD_INT 0
48965: PUSH
48966: EMPTY
48967: LIST
48968: LIST
48969: PUSH
48970: LD_INT 4
48972: NEG
48973: PUSH
48974: LD_INT 1
48976: NEG
48977: PUSH
48978: EMPTY
48979: LIST
48980: LIST
48981: PUSH
48982: LD_INT 4
48984: NEG
48985: PUSH
48986: LD_INT 2
48988: NEG
48989: PUSH
48990: EMPTY
48991: LIST
48992: LIST
48993: PUSH
48994: LD_INT 2
48996: NEG
48997: PUSH
48998: LD_INT 2
49000: PUSH
49001: EMPTY
49002: LIST
49003: LIST
49004: PUSH
49005: LD_INT 4
49007: NEG
49008: PUSH
49009: LD_INT 4
49011: NEG
49012: PUSH
49013: EMPTY
49014: LIST
49015: LIST
49016: PUSH
49017: LD_INT 4
49019: NEG
49020: PUSH
49021: LD_INT 5
49023: NEG
49024: PUSH
49025: EMPTY
49026: LIST
49027: LIST
49028: PUSH
49029: LD_INT 3
49031: NEG
49032: PUSH
49033: LD_INT 4
49035: NEG
49036: PUSH
49037: EMPTY
49038: LIST
49039: LIST
49040: PUSH
49041: LD_INT 3
49043: NEG
49044: PUSH
49045: LD_INT 3
49047: NEG
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PUSH
49053: LD_INT 4
49055: NEG
49056: PUSH
49057: LD_INT 3
49059: NEG
49060: PUSH
49061: EMPTY
49062: LIST
49063: LIST
49064: PUSH
49065: LD_INT 5
49067: NEG
49068: PUSH
49069: LD_INT 4
49071: NEG
49072: PUSH
49073: EMPTY
49074: LIST
49075: LIST
49076: PUSH
49077: LD_INT 5
49079: NEG
49080: PUSH
49081: LD_INT 5
49083: NEG
49084: PUSH
49085: EMPTY
49086: LIST
49087: LIST
49088: PUSH
49089: LD_INT 3
49091: NEG
49092: PUSH
49093: LD_INT 5
49095: NEG
49096: PUSH
49097: EMPTY
49098: LIST
49099: LIST
49100: PUSH
49101: LD_INT 5
49103: NEG
49104: PUSH
49105: LD_INT 3
49107: NEG
49108: PUSH
49109: EMPTY
49110: LIST
49111: LIST
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: LIST
49129: LIST
49130: LIST
49131: LIST
49132: LIST
49133: LIST
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
49160: LD_ADDR_VAR 0 30
49164: PUSH
49165: LD_INT 4
49167: PUSH
49168: LD_INT 4
49170: PUSH
49171: EMPTY
49172: LIST
49173: LIST
49174: PUSH
49175: LD_INT 4
49177: PUSH
49178: LD_INT 3
49180: PUSH
49181: EMPTY
49182: LIST
49183: LIST
49184: PUSH
49185: LD_INT 5
49187: PUSH
49188: LD_INT 4
49190: PUSH
49191: EMPTY
49192: LIST
49193: LIST
49194: PUSH
49195: LD_INT 5
49197: PUSH
49198: LD_INT 5
49200: PUSH
49201: EMPTY
49202: LIST
49203: LIST
49204: PUSH
49205: LD_INT 4
49207: PUSH
49208: LD_INT 5
49210: PUSH
49211: EMPTY
49212: LIST
49213: LIST
49214: PUSH
49215: LD_INT 3
49217: PUSH
49218: LD_INT 4
49220: PUSH
49221: EMPTY
49222: LIST
49223: LIST
49224: PUSH
49225: LD_INT 3
49227: PUSH
49228: LD_INT 3
49230: PUSH
49231: EMPTY
49232: LIST
49233: LIST
49234: PUSH
49235: LD_INT 5
49237: PUSH
49238: LD_INT 3
49240: PUSH
49241: EMPTY
49242: LIST
49243: LIST
49244: PUSH
49245: LD_INT 3
49247: PUSH
49248: LD_INT 5
49250: PUSH
49251: EMPTY
49252: LIST
49253: LIST
49254: PUSH
49255: LD_INT 0
49257: PUSH
49258: LD_INT 3
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: PUSH
49265: LD_INT 0
49267: PUSH
49268: LD_INT 2
49270: PUSH
49271: EMPTY
49272: LIST
49273: LIST
49274: PUSH
49275: LD_INT 1
49277: PUSH
49278: LD_INT 3
49280: PUSH
49281: EMPTY
49282: LIST
49283: LIST
49284: PUSH
49285: LD_INT 1
49287: PUSH
49288: LD_INT 4
49290: PUSH
49291: EMPTY
49292: LIST
49293: LIST
49294: PUSH
49295: LD_INT 0
49297: PUSH
49298: LD_INT 4
49300: PUSH
49301: EMPTY
49302: LIST
49303: LIST
49304: PUSH
49305: LD_INT 1
49307: NEG
49308: PUSH
49309: LD_INT 3
49311: PUSH
49312: EMPTY
49313: LIST
49314: LIST
49315: PUSH
49316: LD_INT 1
49318: NEG
49319: PUSH
49320: LD_INT 2
49322: PUSH
49323: EMPTY
49324: LIST
49325: LIST
49326: PUSH
49327: LD_INT 2
49329: PUSH
49330: LD_INT 4
49332: PUSH
49333: EMPTY
49334: LIST
49335: LIST
49336: PUSH
49337: LD_INT 2
49339: NEG
49340: PUSH
49341: LD_INT 2
49343: PUSH
49344: EMPTY
49345: LIST
49346: LIST
49347: PUSH
49348: LD_INT 4
49350: NEG
49351: PUSH
49352: LD_INT 0
49354: PUSH
49355: EMPTY
49356: LIST
49357: LIST
49358: PUSH
49359: LD_INT 4
49361: NEG
49362: PUSH
49363: LD_INT 1
49365: NEG
49366: PUSH
49367: EMPTY
49368: LIST
49369: LIST
49370: PUSH
49371: LD_INT 3
49373: NEG
49374: PUSH
49375: LD_INT 0
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: PUSH
49382: LD_INT 3
49384: NEG
49385: PUSH
49386: LD_INT 1
49388: PUSH
49389: EMPTY
49390: LIST
49391: LIST
49392: PUSH
49393: LD_INT 4
49395: NEG
49396: PUSH
49397: LD_INT 1
49399: PUSH
49400: EMPTY
49401: LIST
49402: LIST
49403: PUSH
49404: LD_INT 5
49406: NEG
49407: PUSH
49408: LD_INT 0
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PUSH
49415: LD_INT 5
49417: NEG
49418: PUSH
49419: LD_INT 1
49421: NEG
49422: PUSH
49423: EMPTY
49424: LIST
49425: LIST
49426: PUSH
49427: LD_INT 5
49429: NEG
49430: PUSH
49431: LD_INT 2
49433: NEG
49434: PUSH
49435: EMPTY
49436: LIST
49437: LIST
49438: PUSH
49439: LD_INT 3
49441: NEG
49442: PUSH
49443: LD_INT 2
49445: PUSH
49446: EMPTY
49447: LIST
49448: LIST
49449: PUSH
49450: LD_INT 3
49452: NEG
49453: PUSH
49454: LD_INT 3
49456: NEG
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: LD_INT 3
49464: NEG
49465: PUSH
49466: LD_INT 4
49468: NEG
49469: PUSH
49470: EMPTY
49471: LIST
49472: LIST
49473: PUSH
49474: LD_INT 2
49476: NEG
49477: PUSH
49478: LD_INT 3
49480: NEG
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: PUSH
49486: LD_INT 2
49488: NEG
49489: PUSH
49490: LD_INT 2
49492: NEG
49493: PUSH
49494: EMPTY
49495: LIST
49496: LIST
49497: PUSH
49498: LD_INT 3
49500: NEG
49501: PUSH
49502: LD_INT 2
49504: NEG
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 4
49512: NEG
49513: PUSH
49514: LD_INT 3
49516: NEG
49517: PUSH
49518: EMPTY
49519: LIST
49520: LIST
49521: PUSH
49522: LD_INT 4
49524: NEG
49525: PUSH
49526: LD_INT 4
49528: NEG
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PUSH
49534: LD_INT 2
49536: NEG
49537: PUSH
49538: LD_INT 4
49540: NEG
49541: PUSH
49542: EMPTY
49543: LIST
49544: LIST
49545: PUSH
49546: LD_INT 4
49548: NEG
49549: PUSH
49550: LD_INT 2
49552: NEG
49553: PUSH
49554: EMPTY
49555: LIST
49556: LIST
49557: PUSH
49558: LD_INT 0
49560: PUSH
49561: LD_INT 4
49563: NEG
49564: PUSH
49565: EMPTY
49566: LIST
49567: LIST
49568: PUSH
49569: LD_INT 0
49571: PUSH
49572: LD_INT 5
49574: NEG
49575: PUSH
49576: EMPTY
49577: LIST
49578: LIST
49579: PUSH
49580: LD_INT 1
49582: PUSH
49583: LD_INT 4
49585: NEG
49586: PUSH
49587: EMPTY
49588: LIST
49589: LIST
49590: PUSH
49591: LD_INT 1
49593: PUSH
49594: LD_INT 3
49596: NEG
49597: PUSH
49598: EMPTY
49599: LIST
49600: LIST
49601: PUSH
49602: LD_INT 0
49604: PUSH
49605: LD_INT 3
49607: NEG
49608: PUSH
49609: EMPTY
49610: LIST
49611: LIST
49612: PUSH
49613: LD_INT 1
49615: NEG
49616: PUSH
49617: LD_INT 4
49619: NEG
49620: PUSH
49621: EMPTY
49622: LIST
49623: LIST
49624: PUSH
49625: LD_INT 1
49627: NEG
49628: PUSH
49629: LD_INT 5
49631: NEG
49632: PUSH
49633: EMPTY
49634: LIST
49635: LIST
49636: PUSH
49637: LD_INT 2
49639: PUSH
49640: LD_INT 3
49642: NEG
49643: PUSH
49644: EMPTY
49645: LIST
49646: LIST
49647: PUSH
49648: LD_INT 2
49650: NEG
49651: PUSH
49652: LD_INT 5
49654: NEG
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PUSH
49660: EMPTY
49661: LIST
49662: LIST
49663: LIST
49664: LIST
49665: LIST
49666: LIST
49667: LIST
49668: LIST
49669: LIST
49670: LIST
49671: LIST
49672: LIST
49673: LIST
49674: LIST
49675: LIST
49676: LIST
49677: LIST
49678: LIST
49679: LIST
49680: LIST
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: LIST
49686: LIST
49687: LIST
49688: LIST
49689: LIST
49690: LIST
49691: LIST
49692: LIST
49693: LIST
49694: LIST
49695: LIST
49696: LIST
49697: LIST
49698: LIST
49699: LIST
49700: LIST
49701: LIST
49702: LIST
49703: LIST
49704: LIST
49705: LIST
49706: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49707: LD_ADDR_VAR 0 31
49711: PUSH
49712: LD_INT 0
49714: PUSH
49715: LD_INT 4
49717: PUSH
49718: EMPTY
49719: LIST
49720: LIST
49721: PUSH
49722: LD_INT 0
49724: PUSH
49725: LD_INT 3
49727: PUSH
49728: EMPTY
49729: LIST
49730: LIST
49731: PUSH
49732: LD_INT 1
49734: PUSH
49735: LD_INT 4
49737: PUSH
49738: EMPTY
49739: LIST
49740: LIST
49741: PUSH
49742: LD_INT 1
49744: PUSH
49745: LD_INT 5
49747: PUSH
49748: EMPTY
49749: LIST
49750: LIST
49751: PUSH
49752: LD_INT 0
49754: PUSH
49755: LD_INT 5
49757: PUSH
49758: EMPTY
49759: LIST
49760: LIST
49761: PUSH
49762: LD_INT 1
49764: NEG
49765: PUSH
49766: LD_INT 4
49768: PUSH
49769: EMPTY
49770: LIST
49771: LIST
49772: PUSH
49773: LD_INT 1
49775: NEG
49776: PUSH
49777: LD_INT 3
49779: PUSH
49780: EMPTY
49781: LIST
49782: LIST
49783: PUSH
49784: LD_INT 2
49786: PUSH
49787: LD_INT 5
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: PUSH
49794: LD_INT 2
49796: NEG
49797: PUSH
49798: LD_INT 3
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PUSH
49805: LD_INT 3
49807: NEG
49808: PUSH
49809: LD_INT 0
49811: PUSH
49812: EMPTY
49813: LIST
49814: LIST
49815: PUSH
49816: LD_INT 3
49818: NEG
49819: PUSH
49820: LD_INT 1
49822: NEG
49823: PUSH
49824: EMPTY
49825: LIST
49826: LIST
49827: PUSH
49828: LD_INT 2
49830: NEG
49831: PUSH
49832: LD_INT 0
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: PUSH
49839: LD_INT 2
49841: NEG
49842: PUSH
49843: LD_INT 1
49845: PUSH
49846: EMPTY
49847: LIST
49848: LIST
49849: PUSH
49850: LD_INT 3
49852: NEG
49853: PUSH
49854: LD_INT 1
49856: PUSH
49857: EMPTY
49858: LIST
49859: LIST
49860: PUSH
49861: LD_INT 4
49863: NEG
49864: PUSH
49865: LD_INT 0
49867: PUSH
49868: EMPTY
49869: LIST
49870: LIST
49871: PUSH
49872: LD_INT 4
49874: NEG
49875: PUSH
49876: LD_INT 1
49878: NEG
49879: PUSH
49880: EMPTY
49881: LIST
49882: LIST
49883: PUSH
49884: LD_INT 4
49886: NEG
49887: PUSH
49888: LD_INT 2
49890: NEG
49891: PUSH
49892: EMPTY
49893: LIST
49894: LIST
49895: PUSH
49896: LD_INT 2
49898: NEG
49899: PUSH
49900: LD_INT 2
49902: PUSH
49903: EMPTY
49904: LIST
49905: LIST
49906: PUSH
49907: LD_INT 4
49909: NEG
49910: PUSH
49911: LD_INT 4
49913: NEG
49914: PUSH
49915: EMPTY
49916: LIST
49917: LIST
49918: PUSH
49919: LD_INT 4
49921: NEG
49922: PUSH
49923: LD_INT 5
49925: NEG
49926: PUSH
49927: EMPTY
49928: LIST
49929: LIST
49930: PUSH
49931: LD_INT 3
49933: NEG
49934: PUSH
49935: LD_INT 4
49937: NEG
49938: PUSH
49939: EMPTY
49940: LIST
49941: LIST
49942: PUSH
49943: LD_INT 3
49945: NEG
49946: PUSH
49947: LD_INT 3
49949: NEG
49950: PUSH
49951: EMPTY
49952: LIST
49953: LIST
49954: PUSH
49955: LD_INT 4
49957: NEG
49958: PUSH
49959: LD_INT 3
49961: NEG
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: LD_INT 5
49969: NEG
49970: PUSH
49971: LD_INT 4
49973: NEG
49974: PUSH
49975: EMPTY
49976: LIST
49977: LIST
49978: PUSH
49979: LD_INT 5
49981: NEG
49982: PUSH
49983: LD_INT 5
49985: NEG
49986: PUSH
49987: EMPTY
49988: LIST
49989: LIST
49990: PUSH
49991: LD_INT 3
49993: NEG
49994: PUSH
49995: LD_INT 5
49997: NEG
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: PUSH
50003: LD_INT 5
50005: NEG
50006: PUSH
50007: LD_INT 3
50009: NEG
50010: PUSH
50011: EMPTY
50012: LIST
50013: LIST
50014: PUSH
50015: LD_INT 0
50017: PUSH
50018: LD_INT 3
50020: NEG
50021: PUSH
50022: EMPTY
50023: LIST
50024: LIST
50025: PUSH
50026: LD_INT 0
50028: PUSH
50029: LD_INT 4
50031: NEG
50032: PUSH
50033: EMPTY
50034: LIST
50035: LIST
50036: PUSH
50037: LD_INT 1
50039: PUSH
50040: LD_INT 3
50042: NEG
50043: PUSH
50044: EMPTY
50045: LIST
50046: LIST
50047: PUSH
50048: LD_INT 1
50050: PUSH
50051: LD_INT 2
50053: NEG
50054: PUSH
50055: EMPTY
50056: LIST
50057: LIST
50058: PUSH
50059: LD_INT 0
50061: PUSH
50062: LD_INT 2
50064: NEG
50065: PUSH
50066: EMPTY
50067: LIST
50068: LIST
50069: PUSH
50070: LD_INT 1
50072: NEG
50073: PUSH
50074: LD_INT 3
50076: NEG
50077: PUSH
50078: EMPTY
50079: LIST
50080: LIST
50081: PUSH
50082: LD_INT 1
50084: NEG
50085: PUSH
50086: LD_INT 4
50088: NEG
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: PUSH
50094: LD_INT 2
50096: PUSH
50097: LD_INT 2
50099: NEG
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PUSH
50105: LD_INT 2
50107: NEG
50108: PUSH
50109: LD_INT 4
50111: NEG
50112: PUSH
50113: EMPTY
50114: LIST
50115: LIST
50116: PUSH
50117: LD_INT 4
50119: PUSH
50120: LD_INT 0
50122: PUSH
50123: EMPTY
50124: LIST
50125: LIST
50126: PUSH
50127: LD_INT 4
50129: PUSH
50130: LD_INT 1
50132: NEG
50133: PUSH
50134: EMPTY
50135: LIST
50136: LIST
50137: PUSH
50138: LD_INT 5
50140: PUSH
50141: LD_INT 0
50143: PUSH
50144: EMPTY
50145: LIST
50146: LIST
50147: PUSH
50148: LD_INT 5
50150: PUSH
50151: LD_INT 1
50153: PUSH
50154: EMPTY
50155: LIST
50156: LIST
50157: PUSH
50158: LD_INT 4
50160: PUSH
50161: LD_INT 1
50163: PUSH
50164: EMPTY
50165: LIST
50166: LIST
50167: PUSH
50168: LD_INT 3
50170: PUSH
50171: LD_INT 0
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 3
50180: PUSH
50181: LD_INT 1
50183: NEG
50184: PUSH
50185: EMPTY
50186: LIST
50187: LIST
50188: PUSH
50189: LD_INT 3
50191: PUSH
50192: LD_INT 2
50194: NEG
50195: PUSH
50196: EMPTY
50197: LIST
50198: LIST
50199: PUSH
50200: LD_INT 5
50202: PUSH
50203: LD_INT 2
50205: PUSH
50206: EMPTY
50207: LIST
50208: LIST
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: LIST
50214: LIST
50215: LIST
50216: LIST
50217: LIST
50218: LIST
50219: LIST
50220: LIST
50221: LIST
50222: LIST
50223: LIST
50224: LIST
50225: LIST
50226: LIST
50227: LIST
50228: LIST
50229: LIST
50230: LIST
50231: LIST
50232: LIST
50233: LIST
50234: LIST
50235: LIST
50236: LIST
50237: LIST
50238: LIST
50239: LIST
50240: LIST
50241: LIST
50242: LIST
50243: LIST
50244: LIST
50245: LIST
50246: LIST
50247: LIST
50248: LIST
50249: LIST
50250: LIST
50251: LIST
50252: LIST
50253: LIST
50254: LIST
50255: LIST
50256: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
50257: LD_ADDR_VAR 0 32
50261: PUSH
50262: LD_INT 4
50264: NEG
50265: PUSH
50266: LD_INT 0
50268: PUSH
50269: EMPTY
50270: LIST
50271: LIST
50272: PUSH
50273: LD_INT 4
50275: NEG
50276: PUSH
50277: LD_INT 1
50279: NEG
50280: PUSH
50281: EMPTY
50282: LIST
50283: LIST
50284: PUSH
50285: LD_INT 3
50287: NEG
50288: PUSH
50289: LD_INT 0
50291: PUSH
50292: EMPTY
50293: LIST
50294: LIST
50295: PUSH
50296: LD_INT 3
50298: NEG
50299: PUSH
50300: LD_INT 1
50302: PUSH
50303: EMPTY
50304: LIST
50305: LIST
50306: PUSH
50307: LD_INT 4
50309: NEG
50310: PUSH
50311: LD_INT 1
50313: PUSH
50314: EMPTY
50315: LIST
50316: LIST
50317: PUSH
50318: LD_INT 5
50320: NEG
50321: PUSH
50322: LD_INT 0
50324: PUSH
50325: EMPTY
50326: LIST
50327: LIST
50328: PUSH
50329: LD_INT 5
50331: NEG
50332: PUSH
50333: LD_INT 1
50335: NEG
50336: PUSH
50337: EMPTY
50338: LIST
50339: LIST
50340: PUSH
50341: LD_INT 5
50343: NEG
50344: PUSH
50345: LD_INT 2
50347: NEG
50348: PUSH
50349: EMPTY
50350: LIST
50351: LIST
50352: PUSH
50353: LD_INT 3
50355: NEG
50356: PUSH
50357: LD_INT 2
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: PUSH
50364: LD_INT 3
50366: NEG
50367: PUSH
50368: LD_INT 3
50370: NEG
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: LD_INT 3
50378: NEG
50379: PUSH
50380: LD_INT 4
50382: NEG
50383: PUSH
50384: EMPTY
50385: LIST
50386: LIST
50387: PUSH
50388: LD_INT 2
50390: NEG
50391: PUSH
50392: LD_INT 3
50394: NEG
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: PUSH
50400: LD_INT 2
50402: NEG
50403: PUSH
50404: LD_INT 2
50406: NEG
50407: PUSH
50408: EMPTY
50409: LIST
50410: LIST
50411: PUSH
50412: LD_INT 3
50414: NEG
50415: PUSH
50416: LD_INT 2
50418: NEG
50419: PUSH
50420: EMPTY
50421: LIST
50422: LIST
50423: PUSH
50424: LD_INT 4
50426: NEG
50427: PUSH
50428: LD_INT 3
50430: NEG
50431: PUSH
50432: EMPTY
50433: LIST
50434: LIST
50435: PUSH
50436: LD_INT 4
50438: NEG
50439: PUSH
50440: LD_INT 4
50442: NEG
50443: PUSH
50444: EMPTY
50445: LIST
50446: LIST
50447: PUSH
50448: LD_INT 2
50450: NEG
50451: PUSH
50452: LD_INT 4
50454: NEG
50455: PUSH
50456: EMPTY
50457: LIST
50458: LIST
50459: PUSH
50460: LD_INT 4
50462: NEG
50463: PUSH
50464: LD_INT 2
50466: NEG
50467: PUSH
50468: EMPTY
50469: LIST
50470: LIST
50471: PUSH
50472: LD_INT 0
50474: PUSH
50475: LD_INT 4
50477: NEG
50478: PUSH
50479: EMPTY
50480: LIST
50481: LIST
50482: PUSH
50483: LD_INT 0
50485: PUSH
50486: LD_INT 5
50488: NEG
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: PUSH
50494: LD_INT 1
50496: PUSH
50497: LD_INT 4
50499: NEG
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 1
50507: PUSH
50508: LD_INT 3
50510: NEG
50511: PUSH
50512: EMPTY
50513: LIST
50514: LIST
50515: PUSH
50516: LD_INT 0
50518: PUSH
50519: LD_INT 3
50521: NEG
50522: PUSH
50523: EMPTY
50524: LIST
50525: LIST
50526: PUSH
50527: LD_INT 1
50529: NEG
50530: PUSH
50531: LD_INT 4
50533: NEG
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: PUSH
50539: LD_INT 1
50541: NEG
50542: PUSH
50543: LD_INT 5
50545: NEG
50546: PUSH
50547: EMPTY
50548: LIST
50549: LIST
50550: PUSH
50551: LD_INT 2
50553: PUSH
50554: LD_INT 3
50556: NEG
50557: PUSH
50558: EMPTY
50559: LIST
50560: LIST
50561: PUSH
50562: LD_INT 2
50564: NEG
50565: PUSH
50566: LD_INT 5
50568: NEG
50569: PUSH
50570: EMPTY
50571: LIST
50572: LIST
50573: PUSH
50574: LD_INT 3
50576: PUSH
50577: LD_INT 0
50579: PUSH
50580: EMPTY
50581: LIST
50582: LIST
50583: PUSH
50584: LD_INT 3
50586: PUSH
50587: LD_INT 1
50589: NEG
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PUSH
50595: LD_INT 4
50597: PUSH
50598: LD_INT 0
50600: PUSH
50601: EMPTY
50602: LIST
50603: LIST
50604: PUSH
50605: LD_INT 4
50607: PUSH
50608: LD_INT 1
50610: PUSH
50611: EMPTY
50612: LIST
50613: LIST
50614: PUSH
50615: LD_INT 3
50617: PUSH
50618: LD_INT 1
50620: PUSH
50621: EMPTY
50622: LIST
50623: LIST
50624: PUSH
50625: LD_INT 2
50627: PUSH
50628: LD_INT 0
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 2
50637: PUSH
50638: LD_INT 1
50640: NEG
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: PUSH
50646: LD_INT 2
50648: PUSH
50649: LD_INT 2
50651: NEG
50652: PUSH
50653: EMPTY
50654: LIST
50655: LIST
50656: PUSH
50657: LD_INT 4
50659: PUSH
50660: LD_INT 2
50662: PUSH
50663: EMPTY
50664: LIST
50665: LIST
50666: PUSH
50667: LD_INT 4
50669: PUSH
50670: LD_INT 4
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: LD_INT 4
50679: PUSH
50680: LD_INT 3
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: PUSH
50687: LD_INT 5
50689: PUSH
50690: LD_INT 4
50692: PUSH
50693: EMPTY
50694: LIST
50695: LIST
50696: PUSH
50697: LD_INT 5
50699: PUSH
50700: LD_INT 5
50702: PUSH
50703: EMPTY
50704: LIST
50705: LIST
50706: PUSH
50707: LD_INT 4
50709: PUSH
50710: LD_INT 5
50712: PUSH
50713: EMPTY
50714: LIST
50715: LIST
50716: PUSH
50717: LD_INT 3
50719: PUSH
50720: LD_INT 4
50722: PUSH
50723: EMPTY
50724: LIST
50725: LIST
50726: PUSH
50727: LD_INT 3
50729: PUSH
50730: LD_INT 3
50732: PUSH
50733: EMPTY
50734: LIST
50735: LIST
50736: PUSH
50737: LD_INT 5
50739: PUSH
50740: LD_INT 3
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: PUSH
50747: LD_INT 3
50749: PUSH
50750: LD_INT 5
50752: PUSH
50753: EMPTY
50754: LIST
50755: LIST
50756: PUSH
50757: EMPTY
50758: LIST
50759: LIST
50760: LIST
50761: LIST
50762: LIST
50763: LIST
50764: LIST
50765: LIST
50766: LIST
50767: LIST
50768: LIST
50769: LIST
50770: LIST
50771: LIST
50772: LIST
50773: LIST
50774: LIST
50775: LIST
50776: LIST
50777: LIST
50778: LIST
50779: LIST
50780: LIST
50781: LIST
50782: LIST
50783: LIST
50784: LIST
50785: LIST
50786: LIST
50787: LIST
50788: LIST
50789: LIST
50790: LIST
50791: LIST
50792: LIST
50793: LIST
50794: LIST
50795: LIST
50796: LIST
50797: LIST
50798: LIST
50799: LIST
50800: LIST
50801: LIST
50802: LIST
50803: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50804: LD_ADDR_VAR 0 33
50808: PUSH
50809: LD_INT 4
50811: NEG
50812: PUSH
50813: LD_INT 4
50815: NEG
50816: PUSH
50817: EMPTY
50818: LIST
50819: LIST
50820: PUSH
50821: LD_INT 4
50823: NEG
50824: PUSH
50825: LD_INT 5
50827: NEG
50828: PUSH
50829: EMPTY
50830: LIST
50831: LIST
50832: PUSH
50833: LD_INT 3
50835: NEG
50836: PUSH
50837: LD_INT 4
50839: NEG
50840: PUSH
50841: EMPTY
50842: LIST
50843: LIST
50844: PUSH
50845: LD_INT 3
50847: NEG
50848: PUSH
50849: LD_INT 3
50851: NEG
50852: PUSH
50853: EMPTY
50854: LIST
50855: LIST
50856: PUSH
50857: LD_INT 4
50859: NEG
50860: PUSH
50861: LD_INT 3
50863: NEG
50864: PUSH
50865: EMPTY
50866: LIST
50867: LIST
50868: PUSH
50869: LD_INT 5
50871: NEG
50872: PUSH
50873: LD_INT 4
50875: NEG
50876: PUSH
50877: EMPTY
50878: LIST
50879: LIST
50880: PUSH
50881: LD_INT 5
50883: NEG
50884: PUSH
50885: LD_INT 5
50887: NEG
50888: PUSH
50889: EMPTY
50890: LIST
50891: LIST
50892: PUSH
50893: LD_INT 3
50895: NEG
50896: PUSH
50897: LD_INT 5
50899: NEG
50900: PUSH
50901: EMPTY
50902: LIST
50903: LIST
50904: PUSH
50905: LD_INT 5
50907: NEG
50908: PUSH
50909: LD_INT 3
50911: NEG
50912: PUSH
50913: EMPTY
50914: LIST
50915: LIST
50916: PUSH
50917: LD_INT 0
50919: PUSH
50920: LD_INT 3
50922: NEG
50923: PUSH
50924: EMPTY
50925: LIST
50926: LIST
50927: PUSH
50928: LD_INT 0
50930: PUSH
50931: LD_INT 4
50933: NEG
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: PUSH
50939: LD_INT 1
50941: PUSH
50942: LD_INT 3
50944: NEG
50945: PUSH
50946: EMPTY
50947: LIST
50948: LIST
50949: PUSH
50950: LD_INT 1
50952: PUSH
50953: LD_INT 2
50955: NEG
50956: PUSH
50957: EMPTY
50958: LIST
50959: LIST
50960: PUSH
50961: LD_INT 0
50963: PUSH
50964: LD_INT 2
50966: NEG
50967: PUSH
50968: EMPTY
50969: LIST
50970: LIST
50971: PUSH
50972: LD_INT 1
50974: NEG
50975: PUSH
50976: LD_INT 3
50978: NEG
50979: PUSH
50980: EMPTY
50981: LIST
50982: LIST
50983: PUSH
50984: LD_INT 1
50986: NEG
50987: PUSH
50988: LD_INT 4
50990: NEG
50991: PUSH
50992: EMPTY
50993: LIST
50994: LIST
50995: PUSH
50996: LD_INT 2
50998: PUSH
50999: LD_INT 2
51001: NEG
51002: PUSH
51003: EMPTY
51004: LIST
51005: LIST
51006: PUSH
51007: LD_INT 2
51009: NEG
51010: PUSH
51011: LD_INT 4
51013: NEG
51014: PUSH
51015: EMPTY
51016: LIST
51017: LIST
51018: PUSH
51019: LD_INT 4
51021: PUSH
51022: LD_INT 0
51024: PUSH
51025: EMPTY
51026: LIST
51027: LIST
51028: PUSH
51029: LD_INT 4
51031: PUSH
51032: LD_INT 1
51034: NEG
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: PUSH
51040: LD_INT 5
51042: PUSH
51043: LD_INT 0
51045: PUSH
51046: EMPTY
51047: LIST
51048: LIST
51049: PUSH
51050: LD_INT 5
51052: PUSH
51053: LD_INT 1
51055: PUSH
51056: EMPTY
51057: LIST
51058: LIST
51059: PUSH
51060: LD_INT 4
51062: PUSH
51063: LD_INT 1
51065: PUSH
51066: EMPTY
51067: LIST
51068: LIST
51069: PUSH
51070: LD_INT 3
51072: PUSH
51073: LD_INT 0
51075: PUSH
51076: EMPTY
51077: LIST
51078: LIST
51079: PUSH
51080: LD_INT 3
51082: PUSH
51083: LD_INT 1
51085: NEG
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PUSH
51091: LD_INT 3
51093: PUSH
51094: LD_INT 2
51096: NEG
51097: PUSH
51098: EMPTY
51099: LIST
51100: LIST
51101: PUSH
51102: LD_INT 5
51104: PUSH
51105: LD_INT 2
51107: PUSH
51108: EMPTY
51109: LIST
51110: LIST
51111: PUSH
51112: LD_INT 3
51114: PUSH
51115: LD_INT 3
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PUSH
51122: LD_INT 3
51124: PUSH
51125: LD_INT 2
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: PUSH
51132: LD_INT 4
51134: PUSH
51135: LD_INT 3
51137: PUSH
51138: EMPTY
51139: LIST
51140: LIST
51141: PUSH
51142: LD_INT 4
51144: PUSH
51145: LD_INT 4
51147: PUSH
51148: EMPTY
51149: LIST
51150: LIST
51151: PUSH
51152: LD_INT 3
51154: PUSH
51155: LD_INT 4
51157: PUSH
51158: EMPTY
51159: LIST
51160: LIST
51161: PUSH
51162: LD_INT 2
51164: PUSH
51165: LD_INT 3
51167: PUSH
51168: EMPTY
51169: LIST
51170: LIST
51171: PUSH
51172: LD_INT 2
51174: PUSH
51175: LD_INT 2
51177: PUSH
51178: EMPTY
51179: LIST
51180: LIST
51181: PUSH
51182: LD_INT 4
51184: PUSH
51185: LD_INT 2
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: PUSH
51192: LD_INT 2
51194: PUSH
51195: LD_INT 4
51197: PUSH
51198: EMPTY
51199: LIST
51200: LIST
51201: PUSH
51202: LD_INT 0
51204: PUSH
51205: LD_INT 4
51207: PUSH
51208: EMPTY
51209: LIST
51210: LIST
51211: PUSH
51212: LD_INT 0
51214: PUSH
51215: LD_INT 3
51217: PUSH
51218: EMPTY
51219: LIST
51220: LIST
51221: PUSH
51222: LD_INT 1
51224: PUSH
51225: LD_INT 4
51227: PUSH
51228: EMPTY
51229: LIST
51230: LIST
51231: PUSH
51232: LD_INT 1
51234: PUSH
51235: LD_INT 5
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: PUSH
51242: LD_INT 0
51244: PUSH
51245: LD_INT 5
51247: PUSH
51248: EMPTY
51249: LIST
51250: LIST
51251: PUSH
51252: LD_INT 1
51254: NEG
51255: PUSH
51256: LD_INT 4
51258: PUSH
51259: EMPTY
51260: LIST
51261: LIST
51262: PUSH
51263: LD_INT 1
51265: NEG
51266: PUSH
51267: LD_INT 3
51269: PUSH
51270: EMPTY
51271: LIST
51272: LIST
51273: PUSH
51274: LD_INT 2
51276: PUSH
51277: LD_INT 5
51279: PUSH
51280: EMPTY
51281: LIST
51282: LIST
51283: PUSH
51284: LD_INT 2
51286: NEG
51287: PUSH
51288: LD_INT 3
51290: PUSH
51291: EMPTY
51292: LIST
51293: LIST
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: LIST
51299: LIST
51300: LIST
51301: LIST
51302: LIST
51303: LIST
51304: LIST
51305: LIST
51306: LIST
51307: LIST
51308: LIST
51309: LIST
51310: LIST
51311: LIST
51312: LIST
51313: LIST
51314: LIST
51315: LIST
51316: LIST
51317: LIST
51318: LIST
51319: LIST
51320: LIST
51321: LIST
51322: LIST
51323: LIST
51324: LIST
51325: LIST
51326: LIST
51327: LIST
51328: LIST
51329: LIST
51330: LIST
51331: LIST
51332: LIST
51333: LIST
51334: LIST
51335: LIST
51336: LIST
51337: LIST
51338: LIST
51339: LIST
51340: LIST
51341: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
51342: LD_ADDR_VAR 0 34
51346: PUSH
51347: LD_INT 0
51349: PUSH
51350: LD_INT 4
51352: NEG
51353: PUSH
51354: EMPTY
51355: LIST
51356: LIST
51357: PUSH
51358: LD_INT 0
51360: PUSH
51361: LD_INT 5
51363: NEG
51364: PUSH
51365: EMPTY
51366: LIST
51367: LIST
51368: PUSH
51369: LD_INT 1
51371: PUSH
51372: LD_INT 4
51374: NEG
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 1
51382: PUSH
51383: LD_INT 3
51385: NEG
51386: PUSH
51387: EMPTY
51388: LIST
51389: LIST
51390: PUSH
51391: LD_INT 0
51393: PUSH
51394: LD_INT 3
51396: NEG
51397: PUSH
51398: EMPTY
51399: LIST
51400: LIST
51401: PUSH
51402: LD_INT 1
51404: NEG
51405: PUSH
51406: LD_INT 4
51408: NEG
51409: PUSH
51410: EMPTY
51411: LIST
51412: LIST
51413: PUSH
51414: LD_INT 1
51416: NEG
51417: PUSH
51418: LD_INT 5
51420: NEG
51421: PUSH
51422: EMPTY
51423: LIST
51424: LIST
51425: PUSH
51426: LD_INT 2
51428: PUSH
51429: LD_INT 3
51431: NEG
51432: PUSH
51433: EMPTY
51434: LIST
51435: LIST
51436: PUSH
51437: LD_INT 2
51439: NEG
51440: PUSH
51441: LD_INT 5
51443: NEG
51444: PUSH
51445: EMPTY
51446: LIST
51447: LIST
51448: PUSH
51449: LD_INT 3
51451: PUSH
51452: LD_INT 0
51454: PUSH
51455: EMPTY
51456: LIST
51457: LIST
51458: PUSH
51459: LD_INT 3
51461: PUSH
51462: LD_INT 1
51464: NEG
51465: PUSH
51466: EMPTY
51467: LIST
51468: LIST
51469: PUSH
51470: LD_INT 4
51472: PUSH
51473: LD_INT 0
51475: PUSH
51476: EMPTY
51477: LIST
51478: LIST
51479: PUSH
51480: LD_INT 4
51482: PUSH
51483: LD_INT 1
51485: PUSH
51486: EMPTY
51487: LIST
51488: LIST
51489: PUSH
51490: LD_INT 3
51492: PUSH
51493: LD_INT 1
51495: PUSH
51496: EMPTY
51497: LIST
51498: LIST
51499: PUSH
51500: LD_INT 2
51502: PUSH
51503: LD_INT 0
51505: PUSH
51506: EMPTY
51507: LIST
51508: LIST
51509: PUSH
51510: LD_INT 2
51512: PUSH
51513: LD_INT 1
51515: NEG
51516: PUSH
51517: EMPTY
51518: LIST
51519: LIST
51520: PUSH
51521: LD_INT 2
51523: PUSH
51524: LD_INT 2
51526: NEG
51527: PUSH
51528: EMPTY
51529: LIST
51530: LIST
51531: PUSH
51532: LD_INT 4
51534: PUSH
51535: LD_INT 2
51537: PUSH
51538: EMPTY
51539: LIST
51540: LIST
51541: PUSH
51542: LD_INT 4
51544: PUSH
51545: LD_INT 4
51547: PUSH
51548: EMPTY
51549: LIST
51550: LIST
51551: PUSH
51552: LD_INT 4
51554: PUSH
51555: LD_INT 3
51557: PUSH
51558: EMPTY
51559: LIST
51560: LIST
51561: PUSH
51562: LD_INT 5
51564: PUSH
51565: LD_INT 4
51567: PUSH
51568: EMPTY
51569: LIST
51570: LIST
51571: PUSH
51572: LD_INT 5
51574: PUSH
51575: LD_INT 5
51577: PUSH
51578: EMPTY
51579: LIST
51580: LIST
51581: PUSH
51582: LD_INT 4
51584: PUSH
51585: LD_INT 5
51587: PUSH
51588: EMPTY
51589: LIST
51590: LIST
51591: PUSH
51592: LD_INT 3
51594: PUSH
51595: LD_INT 4
51597: PUSH
51598: EMPTY
51599: LIST
51600: LIST
51601: PUSH
51602: LD_INT 3
51604: PUSH
51605: LD_INT 3
51607: PUSH
51608: EMPTY
51609: LIST
51610: LIST
51611: PUSH
51612: LD_INT 5
51614: PUSH
51615: LD_INT 3
51617: PUSH
51618: EMPTY
51619: LIST
51620: LIST
51621: PUSH
51622: LD_INT 3
51624: PUSH
51625: LD_INT 5
51627: PUSH
51628: EMPTY
51629: LIST
51630: LIST
51631: PUSH
51632: LD_INT 0
51634: PUSH
51635: LD_INT 3
51637: PUSH
51638: EMPTY
51639: LIST
51640: LIST
51641: PUSH
51642: LD_INT 0
51644: PUSH
51645: LD_INT 2
51647: PUSH
51648: EMPTY
51649: LIST
51650: LIST
51651: PUSH
51652: LD_INT 1
51654: PUSH
51655: LD_INT 3
51657: PUSH
51658: EMPTY
51659: LIST
51660: LIST
51661: PUSH
51662: LD_INT 1
51664: PUSH
51665: LD_INT 4
51667: PUSH
51668: EMPTY
51669: LIST
51670: LIST
51671: PUSH
51672: LD_INT 0
51674: PUSH
51675: LD_INT 4
51677: PUSH
51678: EMPTY
51679: LIST
51680: LIST
51681: PUSH
51682: LD_INT 1
51684: NEG
51685: PUSH
51686: LD_INT 3
51688: PUSH
51689: EMPTY
51690: LIST
51691: LIST
51692: PUSH
51693: LD_INT 1
51695: NEG
51696: PUSH
51697: LD_INT 2
51699: PUSH
51700: EMPTY
51701: LIST
51702: LIST
51703: PUSH
51704: LD_INT 2
51706: PUSH
51707: LD_INT 4
51709: PUSH
51710: EMPTY
51711: LIST
51712: LIST
51713: PUSH
51714: LD_INT 2
51716: NEG
51717: PUSH
51718: LD_INT 2
51720: PUSH
51721: EMPTY
51722: LIST
51723: LIST
51724: PUSH
51725: LD_INT 4
51727: NEG
51728: PUSH
51729: LD_INT 0
51731: PUSH
51732: EMPTY
51733: LIST
51734: LIST
51735: PUSH
51736: LD_INT 4
51738: NEG
51739: PUSH
51740: LD_INT 1
51742: NEG
51743: PUSH
51744: EMPTY
51745: LIST
51746: LIST
51747: PUSH
51748: LD_INT 3
51750: NEG
51751: PUSH
51752: LD_INT 0
51754: PUSH
51755: EMPTY
51756: LIST
51757: LIST
51758: PUSH
51759: LD_INT 3
51761: NEG
51762: PUSH
51763: LD_INT 1
51765: PUSH
51766: EMPTY
51767: LIST
51768: LIST
51769: PUSH
51770: LD_INT 4
51772: NEG
51773: PUSH
51774: LD_INT 1
51776: PUSH
51777: EMPTY
51778: LIST
51779: LIST
51780: PUSH
51781: LD_INT 5
51783: NEG
51784: PUSH
51785: LD_INT 0
51787: PUSH
51788: EMPTY
51789: LIST
51790: LIST
51791: PUSH
51792: LD_INT 5
51794: NEG
51795: PUSH
51796: LD_INT 1
51798: NEG
51799: PUSH
51800: EMPTY
51801: LIST
51802: LIST
51803: PUSH
51804: LD_INT 5
51806: NEG
51807: PUSH
51808: LD_INT 2
51810: NEG
51811: PUSH
51812: EMPTY
51813: LIST
51814: LIST
51815: PUSH
51816: LD_INT 3
51818: NEG
51819: PUSH
51820: LD_INT 2
51822: PUSH
51823: EMPTY
51824: LIST
51825: LIST
51826: PUSH
51827: EMPTY
51828: LIST
51829: LIST
51830: LIST
51831: LIST
51832: LIST
51833: LIST
51834: LIST
51835: LIST
51836: LIST
51837: LIST
51838: LIST
51839: LIST
51840: LIST
51841: LIST
51842: LIST
51843: LIST
51844: LIST
51845: LIST
51846: LIST
51847: LIST
51848: LIST
51849: LIST
51850: LIST
51851: LIST
51852: LIST
51853: LIST
51854: LIST
51855: LIST
51856: LIST
51857: LIST
51858: LIST
51859: LIST
51860: LIST
51861: LIST
51862: LIST
51863: LIST
51864: LIST
51865: LIST
51866: LIST
51867: LIST
51868: LIST
51869: LIST
51870: LIST
51871: LIST
51872: LIST
51873: ST_TO_ADDR
// end ; end ;
51874: GO 51877
51876: POP
// case btype of b_depot , b_warehouse :
51877: LD_VAR 0 1
51881: PUSH
51882: LD_INT 0
51884: DOUBLE
51885: EQUAL
51886: IFTRUE 51896
51888: LD_INT 1
51890: DOUBLE
51891: EQUAL
51892: IFTRUE 51896
51894: GO 52097
51896: POP
// case nation of nation_american :
51897: LD_VAR 0 5
51901: PUSH
51902: LD_INT 1
51904: DOUBLE
51905: EQUAL
51906: IFTRUE 51910
51908: GO 51966
51910: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51911: LD_ADDR_VAR 0 9
51915: PUSH
51916: LD_VAR 0 11
51920: PUSH
51921: LD_VAR 0 12
51925: PUSH
51926: LD_VAR 0 13
51930: PUSH
51931: LD_VAR 0 14
51935: PUSH
51936: LD_VAR 0 15
51940: PUSH
51941: LD_VAR 0 16
51945: PUSH
51946: EMPTY
51947: LIST
51948: LIST
51949: LIST
51950: LIST
51951: LIST
51952: LIST
51953: PUSH
51954: LD_VAR 0 4
51958: PUSH
51959: LD_INT 1
51961: PLUS
51962: ARRAY
51963: ST_TO_ADDR
51964: GO 52095
51966: LD_INT 2
51968: DOUBLE
51969: EQUAL
51970: IFTRUE 51974
51972: GO 52030
51974: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51975: LD_ADDR_VAR 0 9
51979: PUSH
51980: LD_VAR 0 17
51984: PUSH
51985: LD_VAR 0 18
51989: PUSH
51990: LD_VAR 0 19
51994: PUSH
51995: LD_VAR 0 20
51999: PUSH
52000: LD_VAR 0 21
52004: PUSH
52005: LD_VAR 0 22
52009: PUSH
52010: EMPTY
52011: LIST
52012: LIST
52013: LIST
52014: LIST
52015: LIST
52016: LIST
52017: PUSH
52018: LD_VAR 0 4
52022: PUSH
52023: LD_INT 1
52025: PLUS
52026: ARRAY
52027: ST_TO_ADDR
52028: GO 52095
52030: LD_INT 3
52032: DOUBLE
52033: EQUAL
52034: IFTRUE 52038
52036: GO 52094
52038: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
52039: LD_ADDR_VAR 0 9
52043: PUSH
52044: LD_VAR 0 23
52048: PUSH
52049: LD_VAR 0 24
52053: PUSH
52054: LD_VAR 0 25
52058: PUSH
52059: LD_VAR 0 26
52063: PUSH
52064: LD_VAR 0 27
52068: PUSH
52069: LD_VAR 0 28
52073: PUSH
52074: EMPTY
52075: LIST
52076: LIST
52077: LIST
52078: LIST
52079: LIST
52080: LIST
52081: PUSH
52082: LD_VAR 0 4
52086: PUSH
52087: LD_INT 1
52089: PLUS
52090: ARRAY
52091: ST_TO_ADDR
52092: GO 52095
52094: POP
52095: GO 52650
52097: LD_INT 2
52099: DOUBLE
52100: EQUAL
52101: IFTRUE 52111
52103: LD_INT 3
52105: DOUBLE
52106: EQUAL
52107: IFTRUE 52111
52109: GO 52167
52111: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
52112: LD_ADDR_VAR 0 9
52116: PUSH
52117: LD_VAR 0 29
52121: PUSH
52122: LD_VAR 0 30
52126: PUSH
52127: LD_VAR 0 31
52131: PUSH
52132: LD_VAR 0 32
52136: PUSH
52137: LD_VAR 0 33
52141: PUSH
52142: LD_VAR 0 34
52146: PUSH
52147: EMPTY
52148: LIST
52149: LIST
52150: LIST
52151: LIST
52152: LIST
52153: LIST
52154: PUSH
52155: LD_VAR 0 4
52159: PUSH
52160: LD_INT 1
52162: PLUS
52163: ARRAY
52164: ST_TO_ADDR
52165: GO 52650
52167: LD_INT 16
52169: DOUBLE
52170: EQUAL
52171: IFTRUE 52229
52173: LD_INT 17
52175: DOUBLE
52176: EQUAL
52177: IFTRUE 52229
52179: LD_INT 18
52181: DOUBLE
52182: EQUAL
52183: IFTRUE 52229
52185: LD_INT 19
52187: DOUBLE
52188: EQUAL
52189: IFTRUE 52229
52191: LD_INT 22
52193: DOUBLE
52194: EQUAL
52195: IFTRUE 52229
52197: LD_INT 20
52199: DOUBLE
52200: EQUAL
52201: IFTRUE 52229
52203: LD_INT 21
52205: DOUBLE
52206: EQUAL
52207: IFTRUE 52229
52209: LD_INT 23
52211: DOUBLE
52212: EQUAL
52213: IFTRUE 52229
52215: LD_INT 24
52217: DOUBLE
52218: EQUAL
52219: IFTRUE 52229
52221: LD_INT 25
52223: DOUBLE
52224: EQUAL
52225: IFTRUE 52229
52227: GO 52285
52229: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
52230: LD_ADDR_VAR 0 9
52234: PUSH
52235: LD_VAR 0 35
52239: PUSH
52240: LD_VAR 0 36
52244: PUSH
52245: LD_VAR 0 37
52249: PUSH
52250: LD_VAR 0 38
52254: PUSH
52255: LD_VAR 0 39
52259: PUSH
52260: LD_VAR 0 40
52264: PUSH
52265: EMPTY
52266: LIST
52267: LIST
52268: LIST
52269: LIST
52270: LIST
52271: LIST
52272: PUSH
52273: LD_VAR 0 4
52277: PUSH
52278: LD_INT 1
52280: PLUS
52281: ARRAY
52282: ST_TO_ADDR
52283: GO 52650
52285: LD_INT 6
52287: DOUBLE
52288: EQUAL
52289: IFTRUE 52341
52291: LD_INT 7
52293: DOUBLE
52294: EQUAL
52295: IFTRUE 52341
52297: LD_INT 8
52299: DOUBLE
52300: EQUAL
52301: IFTRUE 52341
52303: LD_INT 13
52305: DOUBLE
52306: EQUAL
52307: IFTRUE 52341
52309: LD_INT 12
52311: DOUBLE
52312: EQUAL
52313: IFTRUE 52341
52315: LD_INT 15
52317: DOUBLE
52318: EQUAL
52319: IFTRUE 52341
52321: LD_INT 11
52323: DOUBLE
52324: EQUAL
52325: IFTRUE 52341
52327: LD_INT 14
52329: DOUBLE
52330: EQUAL
52331: IFTRUE 52341
52333: LD_INT 10
52335: DOUBLE
52336: EQUAL
52337: IFTRUE 52341
52339: GO 52397
52341: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
52342: LD_ADDR_VAR 0 9
52346: PUSH
52347: LD_VAR 0 41
52351: PUSH
52352: LD_VAR 0 42
52356: PUSH
52357: LD_VAR 0 43
52361: PUSH
52362: LD_VAR 0 44
52366: PUSH
52367: LD_VAR 0 45
52371: PUSH
52372: LD_VAR 0 46
52376: PUSH
52377: EMPTY
52378: LIST
52379: LIST
52380: LIST
52381: LIST
52382: LIST
52383: LIST
52384: PUSH
52385: LD_VAR 0 4
52389: PUSH
52390: LD_INT 1
52392: PLUS
52393: ARRAY
52394: ST_TO_ADDR
52395: GO 52650
52397: LD_INT 36
52399: DOUBLE
52400: EQUAL
52401: IFTRUE 52405
52403: GO 52461
52405: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52406: LD_ADDR_VAR 0 9
52410: PUSH
52411: LD_VAR 0 47
52415: PUSH
52416: LD_VAR 0 48
52420: PUSH
52421: LD_VAR 0 49
52425: PUSH
52426: LD_VAR 0 50
52430: PUSH
52431: LD_VAR 0 51
52435: PUSH
52436: LD_VAR 0 52
52440: PUSH
52441: EMPTY
52442: LIST
52443: LIST
52444: LIST
52445: LIST
52446: LIST
52447: LIST
52448: PUSH
52449: LD_VAR 0 4
52453: PUSH
52454: LD_INT 1
52456: PLUS
52457: ARRAY
52458: ST_TO_ADDR
52459: GO 52650
52461: LD_INT 4
52463: DOUBLE
52464: EQUAL
52465: IFTRUE 52487
52467: LD_INT 5
52469: DOUBLE
52470: EQUAL
52471: IFTRUE 52487
52473: LD_INT 34
52475: DOUBLE
52476: EQUAL
52477: IFTRUE 52487
52479: LD_INT 37
52481: DOUBLE
52482: EQUAL
52483: IFTRUE 52487
52485: GO 52543
52487: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52488: LD_ADDR_VAR 0 9
52492: PUSH
52493: LD_VAR 0 53
52497: PUSH
52498: LD_VAR 0 54
52502: PUSH
52503: LD_VAR 0 55
52507: PUSH
52508: LD_VAR 0 56
52512: PUSH
52513: LD_VAR 0 57
52517: PUSH
52518: LD_VAR 0 58
52522: PUSH
52523: EMPTY
52524: LIST
52525: LIST
52526: LIST
52527: LIST
52528: LIST
52529: LIST
52530: PUSH
52531: LD_VAR 0 4
52535: PUSH
52536: LD_INT 1
52538: PLUS
52539: ARRAY
52540: ST_TO_ADDR
52541: GO 52650
52543: LD_INT 31
52545: DOUBLE
52546: EQUAL
52547: IFTRUE 52593
52549: LD_INT 32
52551: DOUBLE
52552: EQUAL
52553: IFTRUE 52593
52555: LD_INT 33
52557: DOUBLE
52558: EQUAL
52559: IFTRUE 52593
52561: LD_INT 27
52563: DOUBLE
52564: EQUAL
52565: IFTRUE 52593
52567: LD_INT 26
52569: DOUBLE
52570: EQUAL
52571: IFTRUE 52593
52573: LD_INT 28
52575: DOUBLE
52576: EQUAL
52577: IFTRUE 52593
52579: LD_INT 29
52581: DOUBLE
52582: EQUAL
52583: IFTRUE 52593
52585: LD_INT 30
52587: DOUBLE
52588: EQUAL
52589: IFTRUE 52593
52591: GO 52649
52593: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52594: LD_ADDR_VAR 0 9
52598: PUSH
52599: LD_VAR 0 59
52603: PUSH
52604: LD_VAR 0 60
52608: PUSH
52609: LD_VAR 0 61
52613: PUSH
52614: LD_VAR 0 62
52618: PUSH
52619: LD_VAR 0 63
52623: PUSH
52624: LD_VAR 0 64
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: LIST
52633: LIST
52634: LIST
52635: LIST
52636: PUSH
52637: LD_VAR 0 4
52641: PUSH
52642: LD_INT 1
52644: PLUS
52645: ARRAY
52646: ST_TO_ADDR
52647: GO 52650
52649: POP
// temp_list2 = [ ] ;
52650: LD_ADDR_VAR 0 10
52654: PUSH
52655: EMPTY
52656: ST_TO_ADDR
// for i in temp_list do
52657: LD_ADDR_VAR 0 8
52661: PUSH
52662: LD_VAR 0 9
52666: PUSH
52667: FOR_IN
52668: IFFALSE 52720
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52670: LD_ADDR_VAR 0 10
52674: PUSH
52675: LD_VAR 0 10
52679: PUSH
52680: LD_VAR 0 8
52684: PUSH
52685: LD_INT 1
52687: ARRAY
52688: PUSH
52689: LD_VAR 0 2
52693: PLUS
52694: PUSH
52695: LD_VAR 0 8
52699: PUSH
52700: LD_INT 2
52702: ARRAY
52703: PUSH
52704: LD_VAR 0 3
52708: PLUS
52709: PUSH
52710: EMPTY
52711: LIST
52712: LIST
52713: PUSH
52714: EMPTY
52715: LIST
52716: ADD
52717: ST_TO_ADDR
52718: GO 52667
52720: POP
52721: POP
// result = temp_list2 ;
52722: LD_ADDR_VAR 0 7
52726: PUSH
52727: LD_VAR 0 10
52731: ST_TO_ADDR
// end ;
52732: LD_VAR 0 7
52736: RET
// export function EnemyInRange ( unit , dist ) ; begin
52737: LD_INT 0
52739: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52740: LD_ADDR_VAR 0 3
52744: PUSH
52745: LD_VAR 0 1
52749: PPUSH
52750: CALL_OW 255
52754: PPUSH
52755: LD_VAR 0 1
52759: PPUSH
52760: CALL_OW 250
52764: PPUSH
52765: LD_VAR 0 1
52769: PPUSH
52770: CALL_OW 251
52774: PPUSH
52775: LD_VAR 0 2
52779: PPUSH
52780: CALL 26110 0 4
52784: PUSH
52785: LD_INT 4
52787: ARRAY
52788: ST_TO_ADDR
// end ;
52789: LD_VAR 0 3
52793: RET
// export function PlayerSeeMe ( unit ) ; begin
52794: LD_INT 0
52796: PPUSH
// result := See ( your_side , unit ) ;
52797: LD_ADDR_VAR 0 2
52801: PUSH
52802: LD_OWVAR 2
52806: PPUSH
52807: LD_VAR 0 1
52811: PPUSH
52812: CALL_OW 292
52816: ST_TO_ADDR
// end ;
52817: LD_VAR 0 2
52821: RET
// export function ReverseDir ( unit ) ; begin
52822: LD_INT 0
52824: PPUSH
// if not unit then
52825: LD_VAR 0 1
52829: NOT
52830: IFFALSE 52834
// exit ;
52832: GO 52857
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52834: LD_ADDR_VAR 0 2
52838: PUSH
52839: LD_VAR 0 1
52843: PPUSH
52844: CALL_OW 254
52848: PUSH
52849: LD_INT 3
52851: PLUS
52852: PUSH
52853: LD_INT 6
52855: MOD
52856: ST_TO_ADDR
// end ;
52857: LD_VAR 0 2
52861: RET
// export function ReverseArray ( array ) ; var i ; begin
52862: LD_INT 0
52864: PPUSH
52865: PPUSH
// if not array then
52866: LD_VAR 0 1
52870: NOT
52871: IFFALSE 52875
// exit ;
52873: GO 52930
// result := [ ] ;
52875: LD_ADDR_VAR 0 2
52879: PUSH
52880: EMPTY
52881: ST_TO_ADDR
// for i := array downto 1 do
52882: LD_ADDR_VAR 0 3
52886: PUSH
52887: DOUBLE
52888: LD_VAR 0 1
52892: INC
52893: ST_TO_ADDR
52894: LD_INT 1
52896: PUSH
52897: FOR_DOWNTO
52898: IFFALSE 52928
// result := Join ( result , array [ i ] ) ;
52900: LD_ADDR_VAR 0 2
52904: PUSH
52905: LD_VAR 0 2
52909: PPUSH
52910: LD_VAR 0 1
52914: PUSH
52915: LD_VAR 0 3
52919: ARRAY
52920: PPUSH
52921: CALL 57586 0 2
52925: ST_TO_ADDR
52926: GO 52897
52928: POP
52929: POP
// end ;
52930: LD_VAR 0 2
52934: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52935: LD_INT 0
52937: PPUSH
52938: PPUSH
52939: PPUSH
52940: PPUSH
52941: PPUSH
52942: PPUSH
// if not unit or not hexes then
52943: LD_VAR 0 1
52947: NOT
52948: PUSH
52949: LD_VAR 0 2
52953: NOT
52954: OR
52955: IFFALSE 52959
// exit ;
52957: GO 53082
// dist := 9999 ;
52959: LD_ADDR_VAR 0 5
52963: PUSH
52964: LD_INT 9999
52966: ST_TO_ADDR
// for i = 1 to hexes do
52967: LD_ADDR_VAR 0 4
52971: PUSH
52972: DOUBLE
52973: LD_INT 1
52975: DEC
52976: ST_TO_ADDR
52977: LD_VAR 0 2
52981: PUSH
52982: FOR_TO
52983: IFFALSE 53070
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52985: LD_ADDR_VAR 0 6
52989: PUSH
52990: LD_VAR 0 1
52994: PPUSH
52995: LD_VAR 0 2
52999: PUSH
53000: LD_VAR 0 4
53004: ARRAY
53005: PUSH
53006: LD_INT 1
53008: ARRAY
53009: PPUSH
53010: LD_VAR 0 2
53014: PUSH
53015: LD_VAR 0 4
53019: ARRAY
53020: PUSH
53021: LD_INT 2
53023: ARRAY
53024: PPUSH
53025: CALL_OW 297
53029: ST_TO_ADDR
// if tdist < dist then
53030: LD_VAR 0 6
53034: PUSH
53035: LD_VAR 0 5
53039: LESS
53040: IFFALSE 53068
// begin hex := hexes [ i ] ;
53042: LD_ADDR_VAR 0 8
53046: PUSH
53047: LD_VAR 0 2
53051: PUSH
53052: LD_VAR 0 4
53056: ARRAY
53057: ST_TO_ADDR
// dist := tdist ;
53058: LD_ADDR_VAR 0 5
53062: PUSH
53063: LD_VAR 0 6
53067: ST_TO_ADDR
// end ; end ;
53068: GO 52982
53070: POP
53071: POP
// result := hex ;
53072: LD_ADDR_VAR 0 3
53076: PUSH
53077: LD_VAR 0 8
53081: ST_TO_ADDR
// end ;
53082: LD_VAR 0 3
53086: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
53087: LD_INT 0
53089: PPUSH
53090: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53091: LD_VAR 0 1
53095: NOT
53096: PUSH
53097: LD_VAR 0 1
53101: PUSH
53102: LD_INT 21
53104: PUSH
53105: LD_INT 2
53107: PUSH
53108: EMPTY
53109: LIST
53110: LIST
53111: PUSH
53112: LD_INT 23
53114: PUSH
53115: LD_INT 2
53117: PUSH
53118: EMPTY
53119: LIST
53120: LIST
53121: PUSH
53122: EMPTY
53123: LIST
53124: LIST
53125: PPUSH
53126: CALL_OW 69
53130: IN
53131: NOT
53132: OR
53133: IFFALSE 53137
// exit ;
53135: GO 53184
// for i = 1 to 3 do
53137: LD_ADDR_VAR 0 3
53141: PUSH
53142: DOUBLE
53143: LD_INT 1
53145: DEC
53146: ST_TO_ADDR
53147: LD_INT 3
53149: PUSH
53150: FOR_TO
53151: IFFALSE 53182
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
53153: LD_VAR 0 1
53157: PPUSH
53158: CALL_OW 250
53162: PPUSH
53163: LD_VAR 0 1
53167: PPUSH
53168: CALL_OW 251
53172: PPUSH
53173: LD_INT 1
53175: PPUSH
53176: CALL_OW 453
53180: GO 53150
53182: POP
53183: POP
// end ;
53184: LD_VAR 0 2
53188: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
53189: LD_INT 0
53191: PPUSH
53192: PPUSH
53193: PPUSH
53194: PPUSH
53195: PPUSH
53196: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
53197: LD_VAR 0 1
53201: NOT
53202: PUSH
53203: LD_VAR 0 2
53207: NOT
53208: OR
53209: PUSH
53210: LD_VAR 0 1
53214: PPUSH
53215: CALL_OW 314
53219: OR
53220: IFFALSE 53224
// exit ;
53222: GO 53691
// if GetLives ( i ) < 250 then
53224: LD_VAR 0 4
53228: PPUSH
53229: CALL_OW 256
53233: PUSH
53234: LD_INT 250
53236: LESS
53237: IFFALSE 53250
// begin ComAutodestruct ( i ) ;
53239: LD_VAR 0 4
53243: PPUSH
53244: CALL 53087 0 1
// exit ;
53248: GO 53691
// end ; x := GetX ( enemy_unit ) ;
53250: LD_ADDR_VAR 0 7
53254: PUSH
53255: LD_VAR 0 2
53259: PPUSH
53260: CALL_OW 250
53264: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
53265: LD_ADDR_VAR 0 8
53269: PUSH
53270: LD_VAR 0 2
53274: PPUSH
53275: CALL_OW 251
53279: ST_TO_ADDR
// if not x or not y then
53280: LD_VAR 0 7
53284: NOT
53285: PUSH
53286: LD_VAR 0 8
53290: NOT
53291: OR
53292: IFFALSE 53296
// exit ;
53294: GO 53691
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
53296: LD_ADDR_VAR 0 6
53300: PUSH
53301: LD_VAR 0 7
53305: PPUSH
53306: LD_INT 0
53308: PPUSH
53309: LD_INT 4
53311: PPUSH
53312: CALL_OW 272
53316: PUSH
53317: LD_VAR 0 8
53321: PPUSH
53322: LD_INT 0
53324: PPUSH
53325: LD_INT 4
53327: PPUSH
53328: CALL_OW 273
53332: PUSH
53333: EMPTY
53334: LIST
53335: LIST
53336: PUSH
53337: LD_VAR 0 7
53341: PPUSH
53342: LD_INT 1
53344: PPUSH
53345: LD_INT 4
53347: PPUSH
53348: CALL_OW 272
53352: PUSH
53353: LD_VAR 0 8
53357: PPUSH
53358: LD_INT 1
53360: PPUSH
53361: LD_INT 4
53363: PPUSH
53364: CALL_OW 273
53368: PUSH
53369: EMPTY
53370: LIST
53371: LIST
53372: PUSH
53373: LD_VAR 0 7
53377: PPUSH
53378: LD_INT 2
53380: PPUSH
53381: LD_INT 4
53383: PPUSH
53384: CALL_OW 272
53388: PUSH
53389: LD_VAR 0 8
53393: PPUSH
53394: LD_INT 2
53396: PPUSH
53397: LD_INT 4
53399: PPUSH
53400: CALL_OW 273
53404: PUSH
53405: EMPTY
53406: LIST
53407: LIST
53408: PUSH
53409: LD_VAR 0 7
53413: PPUSH
53414: LD_INT 3
53416: PPUSH
53417: LD_INT 4
53419: PPUSH
53420: CALL_OW 272
53424: PUSH
53425: LD_VAR 0 8
53429: PPUSH
53430: LD_INT 3
53432: PPUSH
53433: LD_INT 4
53435: PPUSH
53436: CALL_OW 273
53440: PUSH
53441: EMPTY
53442: LIST
53443: LIST
53444: PUSH
53445: LD_VAR 0 7
53449: PPUSH
53450: LD_INT 4
53452: PPUSH
53453: LD_INT 4
53455: PPUSH
53456: CALL_OW 272
53460: PUSH
53461: LD_VAR 0 8
53465: PPUSH
53466: LD_INT 4
53468: PPUSH
53469: LD_INT 4
53471: PPUSH
53472: CALL_OW 273
53476: PUSH
53477: EMPTY
53478: LIST
53479: LIST
53480: PUSH
53481: LD_VAR 0 7
53485: PPUSH
53486: LD_INT 5
53488: PPUSH
53489: LD_INT 4
53491: PPUSH
53492: CALL_OW 272
53496: PUSH
53497: LD_VAR 0 8
53501: PPUSH
53502: LD_INT 5
53504: PPUSH
53505: LD_INT 4
53507: PPUSH
53508: CALL_OW 273
53512: PUSH
53513: EMPTY
53514: LIST
53515: LIST
53516: PUSH
53517: EMPTY
53518: LIST
53519: LIST
53520: LIST
53521: LIST
53522: LIST
53523: LIST
53524: ST_TO_ADDR
// for i = tmp downto 1 do
53525: LD_ADDR_VAR 0 4
53529: PUSH
53530: DOUBLE
53531: LD_VAR 0 6
53535: INC
53536: ST_TO_ADDR
53537: LD_INT 1
53539: PUSH
53540: FOR_DOWNTO
53541: IFFALSE 53642
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53543: LD_VAR 0 6
53547: PUSH
53548: LD_VAR 0 4
53552: ARRAY
53553: PUSH
53554: LD_INT 1
53556: ARRAY
53557: PPUSH
53558: LD_VAR 0 6
53562: PUSH
53563: LD_VAR 0 4
53567: ARRAY
53568: PUSH
53569: LD_INT 2
53571: ARRAY
53572: PPUSH
53573: CALL_OW 488
53577: NOT
53578: PUSH
53579: LD_VAR 0 6
53583: PUSH
53584: LD_VAR 0 4
53588: ARRAY
53589: PUSH
53590: LD_INT 1
53592: ARRAY
53593: PPUSH
53594: LD_VAR 0 6
53598: PUSH
53599: LD_VAR 0 4
53603: ARRAY
53604: PUSH
53605: LD_INT 2
53607: ARRAY
53608: PPUSH
53609: CALL_OW 428
53613: PUSH
53614: LD_INT 0
53616: NONEQUAL
53617: OR
53618: IFFALSE 53640
// tmp := Delete ( tmp , i ) ;
53620: LD_ADDR_VAR 0 6
53624: PUSH
53625: LD_VAR 0 6
53629: PPUSH
53630: LD_VAR 0 4
53634: PPUSH
53635: CALL_OW 3
53639: ST_TO_ADDR
53640: GO 53540
53642: POP
53643: POP
// j := GetClosestHex ( unit , tmp ) ;
53644: LD_ADDR_VAR 0 5
53648: PUSH
53649: LD_VAR 0 1
53653: PPUSH
53654: LD_VAR 0 6
53658: PPUSH
53659: CALL 52935 0 2
53663: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53664: LD_VAR 0 1
53668: PPUSH
53669: LD_VAR 0 5
53673: PUSH
53674: LD_INT 1
53676: ARRAY
53677: PPUSH
53678: LD_VAR 0 5
53682: PUSH
53683: LD_INT 2
53685: ARRAY
53686: PPUSH
53687: CALL_OW 111
// end ;
53691: LD_VAR 0 3
53695: RET
// export function PrepareApemanSoldier ( ) ; begin
53696: LD_INT 0
53698: PPUSH
// uc_nation := 0 ;
53699: LD_ADDR_OWVAR 21
53703: PUSH
53704: LD_INT 0
53706: ST_TO_ADDR
// hc_sex := sex_male ;
53707: LD_ADDR_OWVAR 27
53711: PUSH
53712: LD_INT 1
53714: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
53715: LD_ADDR_OWVAR 28
53719: PUSH
53720: LD_INT 15
53722: ST_TO_ADDR
// hc_gallery :=  ;
53723: LD_ADDR_OWVAR 33
53727: PUSH
53728: LD_STRING 
53730: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53731: LD_ADDR_OWVAR 31
53735: PUSH
53736: LD_INT 0
53738: PPUSH
53739: LD_INT 3
53741: PPUSH
53742: CALL_OW 12
53746: PUSH
53747: LD_INT 0
53749: PPUSH
53750: LD_INT 3
53752: PPUSH
53753: CALL_OW 12
53757: PUSH
53758: LD_INT 0
53760: PUSH
53761: LD_INT 0
53763: PUSH
53764: EMPTY
53765: LIST
53766: LIST
53767: LIST
53768: LIST
53769: ST_TO_ADDR
// end ;
53770: LD_VAR 0 1
53774: RET
// export function PrepareApemanEngineer ( ) ; begin
53775: LD_INT 0
53777: PPUSH
// uc_nation := 0 ;
53778: LD_ADDR_OWVAR 21
53782: PUSH
53783: LD_INT 0
53785: ST_TO_ADDR
// hc_sex := sex_male ;
53786: LD_ADDR_OWVAR 27
53790: PUSH
53791: LD_INT 1
53793: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
53794: LD_ADDR_OWVAR 28
53798: PUSH
53799: LD_INT 16
53801: ST_TO_ADDR
// hc_gallery :=  ;
53802: LD_ADDR_OWVAR 33
53806: PUSH
53807: LD_STRING 
53809: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53810: LD_ADDR_OWVAR 31
53814: PUSH
53815: LD_INT 0
53817: PPUSH
53818: LD_INT 3
53820: PPUSH
53821: CALL_OW 12
53825: PUSH
53826: LD_INT 0
53828: PPUSH
53829: LD_INT 3
53831: PPUSH
53832: CALL_OW 12
53836: PUSH
53837: LD_INT 0
53839: PUSH
53840: LD_INT 0
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: LIST
53847: LIST
53848: ST_TO_ADDR
// end ;
53849: LD_VAR 0 1
53853: RET
// export function PrepareApeman ( agressivity ) ; begin
53854: LD_INT 0
53856: PPUSH
// uc_side := 0 ;
53857: LD_ADDR_OWVAR 20
53861: PUSH
53862: LD_INT 0
53864: ST_TO_ADDR
// uc_nation := 0 ;
53865: LD_ADDR_OWVAR 21
53869: PUSH
53870: LD_INT 0
53872: ST_TO_ADDR
// hc_sex := sex_male ;
53873: LD_ADDR_OWVAR 27
53877: PUSH
53878: LD_INT 1
53880: ST_TO_ADDR
// hc_class := class_apeman ;
53881: LD_ADDR_OWVAR 28
53885: PUSH
53886: LD_INT 12
53888: ST_TO_ADDR
// hc_gallery :=  ;
53889: LD_ADDR_OWVAR 33
53893: PUSH
53894: LD_STRING 
53896: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53897: LD_ADDR_OWVAR 35
53901: PUSH
53902: LD_VAR 0 1
53906: NEG
53907: PPUSH
53908: LD_VAR 0 1
53912: PPUSH
53913: CALL_OW 12
53917: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53918: LD_ADDR_OWVAR 31
53922: PUSH
53923: LD_INT 0
53925: PPUSH
53926: LD_INT 3
53928: PPUSH
53929: CALL_OW 12
53933: PUSH
53934: LD_INT 0
53936: PPUSH
53937: LD_INT 3
53939: PPUSH
53940: CALL_OW 12
53944: PUSH
53945: LD_INT 0
53947: PUSH
53948: LD_INT 0
53950: PUSH
53951: EMPTY
53952: LIST
53953: LIST
53954: LIST
53955: LIST
53956: ST_TO_ADDR
// end ;
53957: LD_VAR 0 2
53961: RET
// export function PrepareTiger ( agressivity ) ; begin
53962: LD_INT 0
53964: PPUSH
// uc_side := 0 ;
53965: LD_ADDR_OWVAR 20
53969: PUSH
53970: LD_INT 0
53972: ST_TO_ADDR
// uc_nation := 0 ;
53973: LD_ADDR_OWVAR 21
53977: PUSH
53978: LD_INT 0
53980: ST_TO_ADDR
// hc_class := class_tiger ;
53981: LD_ADDR_OWVAR 28
53985: PUSH
53986: LD_INT 14
53988: ST_TO_ADDR
// hc_gallery :=  ;
53989: LD_ADDR_OWVAR 33
53993: PUSH
53994: LD_STRING 
53996: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53997: LD_ADDR_OWVAR 35
54001: PUSH
54002: LD_VAR 0 1
54006: NEG
54007: PPUSH
54008: LD_VAR 0 1
54012: PPUSH
54013: CALL_OW 12
54017: ST_TO_ADDR
// end ;
54018: LD_VAR 0 2
54022: RET
// export function PrepareEnchidna ( ) ; begin
54023: LD_INT 0
54025: PPUSH
// uc_side := 0 ;
54026: LD_ADDR_OWVAR 20
54030: PUSH
54031: LD_INT 0
54033: ST_TO_ADDR
// uc_nation := 0 ;
54034: LD_ADDR_OWVAR 21
54038: PUSH
54039: LD_INT 0
54041: ST_TO_ADDR
// hc_class := class_baggie ;
54042: LD_ADDR_OWVAR 28
54046: PUSH
54047: LD_INT 13
54049: ST_TO_ADDR
// hc_gallery :=  ;
54050: LD_ADDR_OWVAR 33
54054: PUSH
54055: LD_STRING 
54057: ST_TO_ADDR
// end ;
54058: LD_VAR 0 1
54062: RET
// export function PrepareFrog ( ) ; begin
54063: LD_INT 0
54065: PPUSH
// uc_side := 0 ;
54066: LD_ADDR_OWVAR 20
54070: PUSH
54071: LD_INT 0
54073: ST_TO_ADDR
// uc_nation := 0 ;
54074: LD_ADDR_OWVAR 21
54078: PUSH
54079: LD_INT 0
54081: ST_TO_ADDR
// hc_class := class_frog ;
54082: LD_ADDR_OWVAR 28
54086: PUSH
54087: LD_INT 19
54089: ST_TO_ADDR
// hc_gallery :=  ;
54090: LD_ADDR_OWVAR 33
54094: PUSH
54095: LD_STRING 
54097: ST_TO_ADDR
// end ;
54098: LD_VAR 0 1
54102: RET
// export function PrepareFish ( ) ; begin
54103: LD_INT 0
54105: PPUSH
// uc_side := 0 ;
54106: LD_ADDR_OWVAR 20
54110: PUSH
54111: LD_INT 0
54113: ST_TO_ADDR
// uc_nation := 0 ;
54114: LD_ADDR_OWVAR 21
54118: PUSH
54119: LD_INT 0
54121: ST_TO_ADDR
// hc_class := class_fish ;
54122: LD_ADDR_OWVAR 28
54126: PUSH
54127: LD_INT 20
54129: ST_TO_ADDR
// hc_gallery :=  ;
54130: LD_ADDR_OWVAR 33
54134: PUSH
54135: LD_STRING 
54137: ST_TO_ADDR
// end ;
54138: LD_VAR 0 1
54142: RET
// export function PrepareBird ( ) ; begin
54143: LD_INT 0
54145: PPUSH
// uc_side := 0 ;
54146: LD_ADDR_OWVAR 20
54150: PUSH
54151: LD_INT 0
54153: ST_TO_ADDR
// uc_nation := 0 ;
54154: LD_ADDR_OWVAR 21
54158: PUSH
54159: LD_INT 0
54161: ST_TO_ADDR
// hc_class := class_phororhacos ;
54162: LD_ADDR_OWVAR 28
54166: PUSH
54167: LD_INT 18
54169: ST_TO_ADDR
// hc_gallery :=  ;
54170: LD_ADDR_OWVAR 33
54174: PUSH
54175: LD_STRING 
54177: ST_TO_ADDR
// end ;
54178: LD_VAR 0 1
54182: RET
// export function PrepareHorse ( ) ; begin
54183: LD_INT 0
54185: PPUSH
// uc_side := 0 ;
54186: LD_ADDR_OWVAR 20
54190: PUSH
54191: LD_INT 0
54193: ST_TO_ADDR
// uc_nation := 0 ;
54194: LD_ADDR_OWVAR 21
54198: PUSH
54199: LD_INT 0
54201: ST_TO_ADDR
// hc_class := class_horse ;
54202: LD_ADDR_OWVAR 28
54206: PUSH
54207: LD_INT 21
54209: ST_TO_ADDR
// hc_gallery :=  ;
54210: LD_ADDR_OWVAR 33
54214: PUSH
54215: LD_STRING 
54217: ST_TO_ADDR
// end ;
54218: LD_VAR 0 1
54222: RET
// export function PrepareMastodont ( ) ; begin
54223: LD_INT 0
54225: PPUSH
// uc_side := 0 ;
54226: LD_ADDR_OWVAR 20
54230: PUSH
54231: LD_INT 0
54233: ST_TO_ADDR
// uc_nation := 0 ;
54234: LD_ADDR_OWVAR 21
54238: PUSH
54239: LD_INT 0
54241: ST_TO_ADDR
// vc_chassis := class_mastodont ;
54242: LD_ADDR_OWVAR 37
54246: PUSH
54247: LD_INT 31
54249: ST_TO_ADDR
// vc_control := control_rider ;
54250: LD_ADDR_OWVAR 38
54254: PUSH
54255: LD_INT 4
54257: ST_TO_ADDR
// end ;
54258: LD_VAR 0 1
54262: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
54263: LD_INT 0
54265: PPUSH
54266: PPUSH
54267: PPUSH
// uc_side = 0 ;
54268: LD_ADDR_OWVAR 20
54272: PUSH
54273: LD_INT 0
54275: ST_TO_ADDR
// uc_nation = 0 ;
54276: LD_ADDR_OWVAR 21
54280: PUSH
54281: LD_INT 0
54283: ST_TO_ADDR
// InitHc_All ( ) ;
54284: CALL_OW 584
// InitVc ;
54288: CALL_OW 20
// if mastodonts then
54292: LD_VAR 0 6
54296: IFFALSE 54363
// for i = 1 to mastodonts do
54298: LD_ADDR_VAR 0 11
54302: PUSH
54303: DOUBLE
54304: LD_INT 1
54306: DEC
54307: ST_TO_ADDR
54308: LD_VAR 0 6
54312: PUSH
54313: FOR_TO
54314: IFFALSE 54361
// begin vc_chassis := 31 ;
54316: LD_ADDR_OWVAR 37
54320: PUSH
54321: LD_INT 31
54323: ST_TO_ADDR
// vc_control := control_rider ;
54324: LD_ADDR_OWVAR 38
54328: PUSH
54329: LD_INT 4
54331: ST_TO_ADDR
// animal := CreateVehicle ;
54332: LD_ADDR_VAR 0 12
54336: PUSH
54337: CALL_OW 45
54341: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54342: LD_VAR 0 12
54346: PPUSH
54347: LD_VAR 0 8
54351: PPUSH
54352: LD_INT 0
54354: PPUSH
54355: CALL 56491 0 3
// end ;
54359: GO 54313
54361: POP
54362: POP
// if horses then
54363: LD_VAR 0 5
54367: IFFALSE 54434
// for i = 1 to horses do
54369: LD_ADDR_VAR 0 11
54373: PUSH
54374: DOUBLE
54375: LD_INT 1
54377: DEC
54378: ST_TO_ADDR
54379: LD_VAR 0 5
54383: PUSH
54384: FOR_TO
54385: IFFALSE 54432
// begin hc_class := 21 ;
54387: LD_ADDR_OWVAR 28
54391: PUSH
54392: LD_INT 21
54394: ST_TO_ADDR
// hc_gallery :=  ;
54395: LD_ADDR_OWVAR 33
54399: PUSH
54400: LD_STRING 
54402: ST_TO_ADDR
// animal := CreateHuman ;
54403: LD_ADDR_VAR 0 12
54407: PUSH
54408: CALL_OW 44
54412: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54413: LD_VAR 0 12
54417: PPUSH
54418: LD_VAR 0 8
54422: PPUSH
54423: LD_INT 0
54425: PPUSH
54426: CALL 56491 0 3
// end ;
54430: GO 54384
54432: POP
54433: POP
// if birds then
54434: LD_VAR 0 1
54438: IFFALSE 54505
// for i = 1 to birds do
54440: LD_ADDR_VAR 0 11
54444: PUSH
54445: DOUBLE
54446: LD_INT 1
54448: DEC
54449: ST_TO_ADDR
54450: LD_VAR 0 1
54454: PUSH
54455: FOR_TO
54456: IFFALSE 54503
// begin hc_class := 18 ;
54458: LD_ADDR_OWVAR 28
54462: PUSH
54463: LD_INT 18
54465: ST_TO_ADDR
// hc_gallery =  ;
54466: LD_ADDR_OWVAR 33
54470: PUSH
54471: LD_STRING 
54473: ST_TO_ADDR
// animal := CreateHuman ;
54474: LD_ADDR_VAR 0 12
54478: PUSH
54479: CALL_OW 44
54483: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54484: LD_VAR 0 12
54488: PPUSH
54489: LD_VAR 0 8
54493: PPUSH
54494: LD_INT 0
54496: PPUSH
54497: CALL 56491 0 3
// end ;
54501: GO 54455
54503: POP
54504: POP
// if tigers then
54505: LD_VAR 0 2
54509: IFFALSE 54593
// for i = 1 to tigers do
54511: LD_ADDR_VAR 0 11
54515: PUSH
54516: DOUBLE
54517: LD_INT 1
54519: DEC
54520: ST_TO_ADDR
54521: LD_VAR 0 2
54525: PUSH
54526: FOR_TO
54527: IFFALSE 54591
// begin hc_class = class_tiger ;
54529: LD_ADDR_OWVAR 28
54533: PUSH
54534: LD_INT 14
54536: ST_TO_ADDR
// hc_gallery =  ;
54537: LD_ADDR_OWVAR 33
54541: PUSH
54542: LD_STRING 
54544: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
54545: LD_ADDR_OWVAR 35
54549: PUSH
54550: LD_INT 7
54552: NEG
54553: PPUSH
54554: LD_INT 7
54556: PPUSH
54557: CALL_OW 12
54561: ST_TO_ADDR
// animal := CreateHuman ;
54562: LD_ADDR_VAR 0 12
54566: PUSH
54567: CALL_OW 44
54571: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54572: LD_VAR 0 12
54576: PPUSH
54577: LD_VAR 0 8
54581: PPUSH
54582: LD_INT 0
54584: PPUSH
54585: CALL 56491 0 3
// end ;
54589: GO 54526
54591: POP
54592: POP
// if apemans then
54593: LD_VAR 0 3
54597: IFFALSE 54720
// for i = 1 to apemans do
54599: LD_ADDR_VAR 0 11
54603: PUSH
54604: DOUBLE
54605: LD_INT 1
54607: DEC
54608: ST_TO_ADDR
54609: LD_VAR 0 3
54613: PUSH
54614: FOR_TO
54615: IFFALSE 54718
// begin hc_class = class_apeman ;
54617: LD_ADDR_OWVAR 28
54621: PUSH
54622: LD_INT 12
54624: ST_TO_ADDR
// hc_gallery =  ;
54625: LD_ADDR_OWVAR 33
54629: PUSH
54630: LD_STRING 
54632: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
54633: LD_ADDR_OWVAR 35
54637: PUSH
54638: LD_INT 2
54640: NEG
54641: PPUSH
54642: LD_INT 2
54644: PPUSH
54645: CALL_OW 12
54649: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
54650: LD_ADDR_OWVAR 31
54654: PUSH
54655: LD_INT 1
54657: PPUSH
54658: LD_INT 3
54660: PPUSH
54661: CALL_OW 12
54665: PUSH
54666: LD_INT 1
54668: PPUSH
54669: LD_INT 3
54671: PPUSH
54672: CALL_OW 12
54676: PUSH
54677: LD_INT 0
54679: PUSH
54680: LD_INT 0
54682: PUSH
54683: EMPTY
54684: LIST
54685: LIST
54686: LIST
54687: LIST
54688: ST_TO_ADDR
// animal := CreateHuman ;
54689: LD_ADDR_VAR 0 12
54693: PUSH
54694: CALL_OW 44
54698: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54699: LD_VAR 0 12
54703: PPUSH
54704: LD_VAR 0 8
54708: PPUSH
54709: LD_INT 0
54711: PPUSH
54712: CALL 56491 0 3
// end ;
54716: GO 54614
54718: POP
54719: POP
// if enchidnas then
54720: LD_VAR 0 4
54724: IFFALSE 54791
// for i = 1 to enchidnas do
54726: LD_ADDR_VAR 0 11
54730: PUSH
54731: DOUBLE
54732: LD_INT 1
54734: DEC
54735: ST_TO_ADDR
54736: LD_VAR 0 4
54740: PUSH
54741: FOR_TO
54742: IFFALSE 54789
// begin hc_class = 13 ;
54744: LD_ADDR_OWVAR 28
54748: PUSH
54749: LD_INT 13
54751: ST_TO_ADDR
// hc_gallery =  ;
54752: LD_ADDR_OWVAR 33
54756: PUSH
54757: LD_STRING 
54759: ST_TO_ADDR
// animal := CreateHuman ;
54760: LD_ADDR_VAR 0 12
54764: PUSH
54765: CALL_OW 44
54769: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54770: LD_VAR 0 12
54774: PPUSH
54775: LD_VAR 0 8
54779: PPUSH
54780: LD_INT 0
54782: PPUSH
54783: CALL 56491 0 3
// end ;
54787: GO 54741
54789: POP
54790: POP
// if fishes then
54791: LD_VAR 0 7
54795: IFFALSE 54862
// for i = 1 to fishes do
54797: LD_ADDR_VAR 0 11
54801: PUSH
54802: DOUBLE
54803: LD_INT 1
54805: DEC
54806: ST_TO_ADDR
54807: LD_VAR 0 7
54811: PUSH
54812: FOR_TO
54813: IFFALSE 54860
// begin hc_class = 20 ;
54815: LD_ADDR_OWVAR 28
54819: PUSH
54820: LD_INT 20
54822: ST_TO_ADDR
// hc_gallery =  ;
54823: LD_ADDR_OWVAR 33
54827: PUSH
54828: LD_STRING 
54830: ST_TO_ADDR
// animal := CreateHuman ;
54831: LD_ADDR_VAR 0 12
54835: PUSH
54836: CALL_OW 44
54840: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
54841: LD_VAR 0 12
54845: PPUSH
54846: LD_VAR 0 9
54850: PPUSH
54851: LD_INT 0
54853: PPUSH
54854: CALL 56491 0 3
// end ;
54858: GO 54812
54860: POP
54861: POP
// end ;
54862: LD_VAR 0 10
54866: RET
// export function WantHeal ( sci , unit ) ; begin
54867: LD_INT 0
54869: PPUSH
// if GetTaskList ( sci ) > 0 then
54870: LD_VAR 0 1
54874: PPUSH
54875: CALL_OW 437
54879: PUSH
54880: LD_INT 0
54882: GREATER
54883: IFFALSE 54953
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54885: LD_VAR 0 1
54889: PPUSH
54890: CALL_OW 437
54894: PUSH
54895: LD_INT 1
54897: ARRAY
54898: PUSH
54899: LD_INT 1
54901: ARRAY
54902: PUSH
54903: LD_STRING l
54905: EQUAL
54906: PUSH
54907: LD_VAR 0 1
54911: PPUSH
54912: CALL_OW 437
54916: PUSH
54917: LD_INT 1
54919: ARRAY
54920: PUSH
54921: LD_INT 4
54923: ARRAY
54924: PUSH
54925: LD_VAR 0 2
54929: EQUAL
54930: AND
54931: IFFALSE 54943
// result := true else
54933: LD_ADDR_VAR 0 3
54937: PUSH
54938: LD_INT 1
54940: ST_TO_ADDR
54941: GO 54951
// result := false ;
54943: LD_ADDR_VAR 0 3
54947: PUSH
54948: LD_INT 0
54950: ST_TO_ADDR
// end else
54951: GO 54961
// result := false ;
54953: LD_ADDR_VAR 0 3
54957: PUSH
54958: LD_INT 0
54960: ST_TO_ADDR
// end ;
54961: LD_VAR 0 3
54965: RET
// export function HealTarget ( sci ) ; begin
54966: LD_INT 0
54968: PPUSH
// if not sci then
54969: LD_VAR 0 1
54973: NOT
54974: IFFALSE 54978
// exit ;
54976: GO 55043
// result := 0 ;
54978: LD_ADDR_VAR 0 2
54982: PUSH
54983: LD_INT 0
54985: ST_TO_ADDR
// if GetTaskList ( sci ) then
54986: LD_VAR 0 1
54990: PPUSH
54991: CALL_OW 437
54995: IFFALSE 55043
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54997: LD_VAR 0 1
55001: PPUSH
55002: CALL_OW 437
55006: PUSH
55007: LD_INT 1
55009: ARRAY
55010: PUSH
55011: LD_INT 1
55013: ARRAY
55014: PUSH
55015: LD_STRING l
55017: EQUAL
55018: IFFALSE 55043
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
55020: LD_ADDR_VAR 0 2
55024: PUSH
55025: LD_VAR 0 1
55029: PPUSH
55030: CALL_OW 437
55034: PUSH
55035: LD_INT 1
55037: ARRAY
55038: PUSH
55039: LD_INT 4
55041: ARRAY
55042: ST_TO_ADDR
// end ;
55043: LD_VAR 0 2
55047: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
55048: LD_INT 0
55050: PPUSH
55051: PPUSH
55052: PPUSH
55053: PPUSH
// if not base_units then
55054: LD_VAR 0 1
55058: NOT
55059: IFFALSE 55063
// exit ;
55061: GO 55150
// result := false ;
55063: LD_ADDR_VAR 0 2
55067: PUSH
55068: LD_INT 0
55070: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
55071: LD_ADDR_VAR 0 5
55075: PUSH
55076: LD_VAR 0 1
55080: PPUSH
55081: LD_INT 21
55083: PUSH
55084: LD_INT 3
55086: PUSH
55087: EMPTY
55088: LIST
55089: LIST
55090: PPUSH
55091: CALL_OW 72
55095: ST_TO_ADDR
// if not tmp then
55096: LD_VAR 0 5
55100: NOT
55101: IFFALSE 55105
// exit ;
55103: GO 55150
// for i in tmp do
55105: LD_ADDR_VAR 0 3
55109: PUSH
55110: LD_VAR 0 5
55114: PUSH
55115: FOR_IN
55116: IFFALSE 55148
// begin result := EnemyInRange ( i , 22 ) ;
55118: LD_ADDR_VAR 0 2
55122: PUSH
55123: LD_VAR 0 3
55127: PPUSH
55128: LD_INT 22
55130: PPUSH
55131: CALL 52737 0 2
55135: ST_TO_ADDR
// if result then
55136: LD_VAR 0 2
55140: IFFALSE 55146
// exit ;
55142: POP
55143: POP
55144: GO 55150
// end ;
55146: GO 55115
55148: POP
55149: POP
// end ;
55150: LD_VAR 0 2
55154: RET
// export function FilterByTag ( units , tag ) ; begin
55155: LD_INT 0
55157: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
55158: LD_ADDR_VAR 0 3
55162: PUSH
55163: LD_VAR 0 1
55167: PPUSH
55168: LD_INT 120
55170: PUSH
55171: LD_VAR 0 2
55175: PUSH
55176: EMPTY
55177: LIST
55178: LIST
55179: PPUSH
55180: CALL_OW 72
55184: ST_TO_ADDR
// end ;
55185: LD_VAR 0 3
55189: RET
// export function IsDriver ( un ) ; begin
55190: LD_INT 0
55192: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
55193: LD_ADDR_VAR 0 2
55197: PUSH
55198: LD_VAR 0 1
55202: PUSH
55203: LD_INT 55
55205: PUSH
55206: EMPTY
55207: LIST
55208: PPUSH
55209: CALL_OW 69
55213: IN
55214: ST_TO_ADDR
// end ;
55215: LD_VAR 0 2
55219: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
55220: LD_INT 0
55222: PPUSH
55223: PPUSH
// list := [ ] ;
55224: LD_ADDR_VAR 0 5
55228: PUSH
55229: EMPTY
55230: ST_TO_ADDR
// case d of 0 :
55231: LD_VAR 0 3
55235: PUSH
55236: LD_INT 0
55238: DOUBLE
55239: EQUAL
55240: IFTRUE 55244
55242: GO 55377
55244: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
55245: LD_ADDR_VAR 0 5
55249: PUSH
55250: LD_VAR 0 1
55254: PUSH
55255: LD_INT 4
55257: MINUS
55258: PUSH
55259: LD_VAR 0 2
55263: PUSH
55264: LD_INT 4
55266: MINUS
55267: PUSH
55268: LD_INT 2
55270: PUSH
55271: EMPTY
55272: LIST
55273: LIST
55274: LIST
55275: PUSH
55276: LD_VAR 0 1
55280: PUSH
55281: LD_INT 3
55283: MINUS
55284: PUSH
55285: LD_VAR 0 2
55289: PUSH
55290: LD_INT 1
55292: PUSH
55293: EMPTY
55294: LIST
55295: LIST
55296: LIST
55297: PUSH
55298: LD_VAR 0 1
55302: PUSH
55303: LD_INT 4
55305: PLUS
55306: PUSH
55307: LD_VAR 0 2
55311: PUSH
55312: LD_INT 4
55314: PUSH
55315: EMPTY
55316: LIST
55317: LIST
55318: LIST
55319: PUSH
55320: LD_VAR 0 1
55324: PUSH
55325: LD_INT 3
55327: PLUS
55328: PUSH
55329: LD_VAR 0 2
55333: PUSH
55334: LD_INT 3
55336: PLUS
55337: PUSH
55338: LD_INT 5
55340: PUSH
55341: EMPTY
55342: LIST
55343: LIST
55344: LIST
55345: PUSH
55346: LD_VAR 0 1
55350: PUSH
55351: LD_VAR 0 2
55355: PUSH
55356: LD_INT 4
55358: PLUS
55359: PUSH
55360: LD_INT 0
55362: PUSH
55363: EMPTY
55364: LIST
55365: LIST
55366: LIST
55367: PUSH
55368: EMPTY
55369: LIST
55370: LIST
55371: LIST
55372: LIST
55373: LIST
55374: ST_TO_ADDR
// end ; 1 :
55375: GO 56075
55377: LD_INT 1
55379: DOUBLE
55380: EQUAL
55381: IFTRUE 55385
55383: GO 55518
55385: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55386: LD_ADDR_VAR 0 5
55390: PUSH
55391: LD_VAR 0 1
55395: PUSH
55396: LD_VAR 0 2
55400: PUSH
55401: LD_INT 4
55403: MINUS
55404: PUSH
55405: LD_INT 3
55407: PUSH
55408: EMPTY
55409: LIST
55410: LIST
55411: LIST
55412: PUSH
55413: LD_VAR 0 1
55417: PUSH
55418: LD_INT 3
55420: MINUS
55421: PUSH
55422: LD_VAR 0 2
55426: PUSH
55427: LD_INT 3
55429: MINUS
55430: PUSH
55431: LD_INT 2
55433: PUSH
55434: EMPTY
55435: LIST
55436: LIST
55437: LIST
55438: PUSH
55439: LD_VAR 0 1
55443: PUSH
55444: LD_INT 4
55446: MINUS
55447: PUSH
55448: LD_VAR 0 2
55452: PUSH
55453: LD_INT 1
55455: PUSH
55456: EMPTY
55457: LIST
55458: LIST
55459: LIST
55460: PUSH
55461: LD_VAR 0 1
55465: PUSH
55466: LD_VAR 0 2
55470: PUSH
55471: LD_INT 3
55473: PLUS
55474: PUSH
55475: LD_INT 0
55477: PUSH
55478: EMPTY
55479: LIST
55480: LIST
55481: LIST
55482: PUSH
55483: LD_VAR 0 1
55487: PUSH
55488: LD_INT 4
55490: PLUS
55491: PUSH
55492: LD_VAR 0 2
55496: PUSH
55497: LD_INT 4
55499: PLUS
55500: PUSH
55501: LD_INT 5
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: PUSH
55509: EMPTY
55510: LIST
55511: LIST
55512: LIST
55513: LIST
55514: LIST
55515: ST_TO_ADDR
// end ; 2 :
55516: GO 56075
55518: LD_INT 2
55520: DOUBLE
55521: EQUAL
55522: IFTRUE 55526
55524: GO 55655
55526: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55527: LD_ADDR_VAR 0 5
55531: PUSH
55532: LD_VAR 0 1
55536: PUSH
55537: LD_VAR 0 2
55541: PUSH
55542: LD_INT 3
55544: MINUS
55545: PUSH
55546: LD_INT 3
55548: PUSH
55549: EMPTY
55550: LIST
55551: LIST
55552: LIST
55553: PUSH
55554: LD_VAR 0 1
55558: PUSH
55559: LD_INT 4
55561: PLUS
55562: PUSH
55563: LD_VAR 0 2
55567: PUSH
55568: LD_INT 4
55570: PUSH
55571: EMPTY
55572: LIST
55573: LIST
55574: LIST
55575: PUSH
55576: LD_VAR 0 1
55580: PUSH
55581: LD_VAR 0 2
55585: PUSH
55586: LD_INT 4
55588: PLUS
55589: PUSH
55590: LD_INT 0
55592: PUSH
55593: EMPTY
55594: LIST
55595: LIST
55596: LIST
55597: PUSH
55598: LD_VAR 0 1
55602: PUSH
55603: LD_INT 3
55605: MINUS
55606: PUSH
55607: LD_VAR 0 2
55611: PUSH
55612: LD_INT 1
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: LIST
55619: PUSH
55620: LD_VAR 0 1
55624: PUSH
55625: LD_INT 4
55627: MINUS
55628: PUSH
55629: LD_VAR 0 2
55633: PUSH
55634: LD_INT 4
55636: MINUS
55637: PUSH
55638: LD_INT 2
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: LIST
55645: PUSH
55646: EMPTY
55647: LIST
55648: LIST
55649: LIST
55650: LIST
55651: LIST
55652: ST_TO_ADDR
// end ; 3 :
55653: GO 56075
55655: LD_INT 3
55657: DOUBLE
55658: EQUAL
55659: IFTRUE 55663
55661: GO 55796
55663: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55664: LD_ADDR_VAR 0 5
55668: PUSH
55669: LD_VAR 0 1
55673: PUSH
55674: LD_INT 3
55676: PLUS
55677: PUSH
55678: LD_VAR 0 2
55682: PUSH
55683: LD_INT 4
55685: PUSH
55686: EMPTY
55687: LIST
55688: LIST
55689: LIST
55690: PUSH
55691: LD_VAR 0 1
55695: PUSH
55696: LD_INT 4
55698: PLUS
55699: PUSH
55700: LD_VAR 0 2
55704: PUSH
55705: LD_INT 4
55707: PLUS
55708: PUSH
55709: LD_INT 5
55711: PUSH
55712: EMPTY
55713: LIST
55714: LIST
55715: LIST
55716: PUSH
55717: LD_VAR 0 1
55721: PUSH
55722: LD_INT 4
55724: MINUS
55725: PUSH
55726: LD_VAR 0 2
55730: PUSH
55731: LD_INT 1
55733: PUSH
55734: EMPTY
55735: LIST
55736: LIST
55737: LIST
55738: PUSH
55739: LD_VAR 0 1
55743: PUSH
55744: LD_VAR 0 2
55748: PUSH
55749: LD_INT 4
55751: MINUS
55752: PUSH
55753: LD_INT 3
55755: PUSH
55756: EMPTY
55757: LIST
55758: LIST
55759: LIST
55760: PUSH
55761: LD_VAR 0 1
55765: PUSH
55766: LD_INT 3
55768: MINUS
55769: PUSH
55770: LD_VAR 0 2
55774: PUSH
55775: LD_INT 3
55777: MINUS
55778: PUSH
55779: LD_INT 2
55781: PUSH
55782: EMPTY
55783: LIST
55784: LIST
55785: LIST
55786: PUSH
55787: EMPTY
55788: LIST
55789: LIST
55790: LIST
55791: LIST
55792: LIST
55793: ST_TO_ADDR
// end ; 4 :
55794: GO 56075
55796: LD_INT 4
55798: DOUBLE
55799: EQUAL
55800: IFTRUE 55804
55802: GO 55937
55804: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55805: LD_ADDR_VAR 0 5
55809: PUSH
55810: LD_VAR 0 1
55814: PUSH
55815: LD_VAR 0 2
55819: PUSH
55820: LD_INT 4
55822: PLUS
55823: PUSH
55824: LD_INT 0
55826: PUSH
55827: EMPTY
55828: LIST
55829: LIST
55830: LIST
55831: PUSH
55832: LD_VAR 0 1
55836: PUSH
55837: LD_INT 3
55839: PLUS
55840: PUSH
55841: LD_VAR 0 2
55845: PUSH
55846: LD_INT 3
55848: PLUS
55849: PUSH
55850: LD_INT 5
55852: PUSH
55853: EMPTY
55854: LIST
55855: LIST
55856: LIST
55857: PUSH
55858: LD_VAR 0 1
55862: PUSH
55863: LD_INT 4
55865: PLUS
55866: PUSH
55867: LD_VAR 0 2
55871: PUSH
55872: LD_INT 4
55874: PUSH
55875: EMPTY
55876: LIST
55877: LIST
55878: LIST
55879: PUSH
55880: LD_VAR 0 1
55884: PUSH
55885: LD_VAR 0 2
55889: PUSH
55890: LD_INT 3
55892: MINUS
55893: PUSH
55894: LD_INT 3
55896: PUSH
55897: EMPTY
55898: LIST
55899: LIST
55900: LIST
55901: PUSH
55902: LD_VAR 0 1
55906: PUSH
55907: LD_INT 4
55909: MINUS
55910: PUSH
55911: LD_VAR 0 2
55915: PUSH
55916: LD_INT 4
55918: MINUS
55919: PUSH
55920: LD_INT 2
55922: PUSH
55923: EMPTY
55924: LIST
55925: LIST
55926: LIST
55927: PUSH
55928: EMPTY
55929: LIST
55930: LIST
55931: LIST
55932: LIST
55933: LIST
55934: ST_TO_ADDR
// end ; 5 :
55935: GO 56075
55937: LD_INT 5
55939: DOUBLE
55940: EQUAL
55941: IFTRUE 55945
55943: GO 56074
55945: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55946: LD_ADDR_VAR 0 5
55950: PUSH
55951: LD_VAR 0 1
55955: PUSH
55956: LD_INT 4
55958: MINUS
55959: PUSH
55960: LD_VAR 0 2
55964: PUSH
55965: LD_INT 1
55967: PUSH
55968: EMPTY
55969: LIST
55970: LIST
55971: LIST
55972: PUSH
55973: LD_VAR 0 1
55977: PUSH
55978: LD_VAR 0 2
55982: PUSH
55983: LD_INT 4
55985: MINUS
55986: PUSH
55987: LD_INT 3
55989: PUSH
55990: EMPTY
55991: LIST
55992: LIST
55993: LIST
55994: PUSH
55995: LD_VAR 0 1
55999: PUSH
56000: LD_INT 4
56002: PLUS
56003: PUSH
56004: LD_VAR 0 2
56008: PUSH
56009: LD_INT 4
56011: PLUS
56012: PUSH
56013: LD_INT 5
56015: PUSH
56016: EMPTY
56017: LIST
56018: LIST
56019: LIST
56020: PUSH
56021: LD_VAR 0 1
56025: PUSH
56026: LD_INT 3
56028: PLUS
56029: PUSH
56030: LD_VAR 0 2
56034: PUSH
56035: LD_INT 4
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: LIST
56042: PUSH
56043: LD_VAR 0 1
56047: PUSH
56048: LD_VAR 0 2
56052: PUSH
56053: LD_INT 3
56055: PLUS
56056: PUSH
56057: LD_INT 0
56059: PUSH
56060: EMPTY
56061: LIST
56062: LIST
56063: LIST
56064: PUSH
56065: EMPTY
56066: LIST
56067: LIST
56068: LIST
56069: LIST
56070: LIST
56071: ST_TO_ADDR
// end ; end ;
56072: GO 56075
56074: POP
// result := list ;
56075: LD_ADDR_VAR 0 4
56079: PUSH
56080: LD_VAR 0 5
56084: ST_TO_ADDR
// end ;
56085: LD_VAR 0 4
56089: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
56090: LD_INT 0
56092: PPUSH
56093: PPUSH
56094: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
56095: LD_VAR 0 1
56099: NOT
56100: PUSH
56101: LD_VAR 0 2
56105: PUSH
56106: LD_INT 1
56108: PUSH
56109: LD_INT 2
56111: PUSH
56112: LD_INT 3
56114: PUSH
56115: LD_INT 4
56117: PUSH
56118: EMPTY
56119: LIST
56120: LIST
56121: LIST
56122: LIST
56123: IN
56124: NOT
56125: OR
56126: IFFALSE 56130
// exit ;
56128: GO 56213
// tmp := [ ] ;
56130: LD_ADDR_VAR 0 5
56134: PUSH
56135: EMPTY
56136: ST_TO_ADDR
// for i in units do
56137: LD_ADDR_VAR 0 4
56141: PUSH
56142: LD_VAR 0 1
56146: PUSH
56147: FOR_IN
56148: IFFALSE 56182
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
56150: LD_ADDR_VAR 0 5
56154: PUSH
56155: LD_VAR 0 5
56159: PPUSH
56160: LD_VAR 0 4
56164: PPUSH
56165: LD_VAR 0 2
56169: PPUSH
56170: CALL_OW 259
56174: PPUSH
56175: CALL 57586 0 2
56179: ST_TO_ADDR
56180: GO 56147
56182: POP
56183: POP
// if not tmp then
56184: LD_VAR 0 5
56188: NOT
56189: IFFALSE 56193
// exit ;
56191: GO 56213
// result := SortListByListDesc ( units , tmp ) ;
56193: LD_ADDR_VAR 0 3
56197: PUSH
56198: LD_VAR 0 1
56202: PPUSH
56203: LD_VAR 0 5
56207: PPUSH
56208: CALL_OW 77
56212: ST_TO_ADDR
// end ;
56213: LD_VAR 0 3
56217: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
56218: LD_INT 0
56220: PPUSH
56221: PPUSH
56222: PPUSH
// result := false ;
56223: LD_ADDR_VAR 0 3
56227: PUSH
56228: LD_INT 0
56230: ST_TO_ADDR
// if not building then
56231: LD_VAR 0 2
56235: NOT
56236: IFFALSE 56240
// exit ;
56238: GO 56378
// x := GetX ( building ) ;
56240: LD_ADDR_VAR 0 4
56244: PUSH
56245: LD_VAR 0 2
56249: PPUSH
56250: CALL_OW 250
56254: ST_TO_ADDR
// y := GetY ( building ) ;
56255: LD_ADDR_VAR 0 5
56259: PUSH
56260: LD_VAR 0 2
56264: PPUSH
56265: CALL_OW 251
56269: ST_TO_ADDR
// if not x or not y then
56270: LD_VAR 0 4
56274: NOT
56275: PUSH
56276: LD_VAR 0 5
56280: NOT
56281: OR
56282: IFFALSE 56286
// exit ;
56284: GO 56378
// if GetTaskList ( unit ) then
56286: LD_VAR 0 1
56290: PPUSH
56291: CALL_OW 437
56295: IFFALSE 56378
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56297: LD_STRING e
56299: PUSH
56300: LD_VAR 0 1
56304: PPUSH
56305: CALL_OW 437
56309: PUSH
56310: LD_INT 1
56312: ARRAY
56313: PUSH
56314: LD_INT 1
56316: ARRAY
56317: EQUAL
56318: PUSH
56319: LD_VAR 0 4
56323: PUSH
56324: LD_VAR 0 1
56328: PPUSH
56329: CALL_OW 437
56333: PUSH
56334: LD_INT 1
56336: ARRAY
56337: PUSH
56338: LD_INT 2
56340: ARRAY
56341: EQUAL
56342: AND
56343: PUSH
56344: LD_VAR 0 5
56348: PUSH
56349: LD_VAR 0 1
56353: PPUSH
56354: CALL_OW 437
56358: PUSH
56359: LD_INT 1
56361: ARRAY
56362: PUSH
56363: LD_INT 3
56365: ARRAY
56366: EQUAL
56367: AND
56368: IFFALSE 56378
// result := true end ;
56370: LD_ADDR_VAR 0 3
56374: PUSH
56375: LD_INT 1
56377: ST_TO_ADDR
// end ;
56378: LD_VAR 0 3
56382: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56383: LD_INT 0
56385: PPUSH
// result := false ;
56386: LD_ADDR_VAR 0 4
56390: PUSH
56391: LD_INT 0
56393: ST_TO_ADDR
// if GetTaskList ( unit ) then
56394: LD_VAR 0 1
56398: PPUSH
56399: CALL_OW 437
56403: IFFALSE 56486
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56405: LD_STRING M
56407: PUSH
56408: LD_VAR 0 1
56412: PPUSH
56413: CALL_OW 437
56417: PUSH
56418: LD_INT 1
56420: ARRAY
56421: PUSH
56422: LD_INT 1
56424: ARRAY
56425: EQUAL
56426: PUSH
56427: LD_VAR 0 2
56431: PUSH
56432: LD_VAR 0 1
56436: PPUSH
56437: CALL_OW 437
56441: PUSH
56442: LD_INT 1
56444: ARRAY
56445: PUSH
56446: LD_INT 2
56448: ARRAY
56449: EQUAL
56450: AND
56451: PUSH
56452: LD_VAR 0 3
56456: PUSH
56457: LD_VAR 0 1
56461: PPUSH
56462: CALL_OW 437
56466: PUSH
56467: LD_INT 1
56469: ARRAY
56470: PUSH
56471: LD_INT 3
56473: ARRAY
56474: EQUAL
56475: AND
56476: IFFALSE 56486
// result := true ;
56478: LD_ADDR_VAR 0 4
56482: PUSH
56483: LD_INT 1
56485: ST_TO_ADDR
// end ; end ;
56486: LD_VAR 0 4
56490: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56491: LD_INT 0
56493: PPUSH
56494: PPUSH
56495: PPUSH
56496: PPUSH
// if not unit or not area then
56497: LD_VAR 0 1
56501: NOT
56502: PUSH
56503: LD_VAR 0 2
56507: NOT
56508: OR
56509: IFFALSE 56513
// exit ;
56511: GO 56689
// tmp := AreaToList ( area , i ) ;
56513: LD_ADDR_VAR 0 6
56517: PUSH
56518: LD_VAR 0 2
56522: PPUSH
56523: LD_VAR 0 5
56527: PPUSH
56528: CALL_OW 517
56532: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56533: LD_ADDR_VAR 0 5
56537: PUSH
56538: DOUBLE
56539: LD_INT 1
56541: DEC
56542: ST_TO_ADDR
56543: LD_VAR 0 6
56547: PUSH
56548: LD_INT 1
56550: ARRAY
56551: PUSH
56552: FOR_TO
56553: IFFALSE 56687
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56555: LD_ADDR_VAR 0 7
56559: PUSH
56560: LD_VAR 0 6
56564: PUSH
56565: LD_INT 1
56567: ARRAY
56568: PUSH
56569: LD_VAR 0 5
56573: ARRAY
56574: PUSH
56575: LD_VAR 0 6
56579: PUSH
56580: LD_INT 2
56582: ARRAY
56583: PUSH
56584: LD_VAR 0 5
56588: ARRAY
56589: PUSH
56590: EMPTY
56591: LIST
56592: LIST
56593: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
56594: LD_INT 92
56596: PUSH
56597: LD_VAR 0 7
56601: PUSH
56602: LD_INT 1
56604: ARRAY
56605: PUSH
56606: LD_VAR 0 7
56610: PUSH
56611: LD_INT 2
56613: ARRAY
56614: PUSH
56615: LD_INT 2
56617: PUSH
56618: EMPTY
56619: LIST
56620: LIST
56621: LIST
56622: LIST
56623: PPUSH
56624: CALL_OW 69
56628: PUSH
56629: LD_INT 0
56631: EQUAL
56632: IFFALSE 56685
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56634: LD_VAR 0 1
56638: PPUSH
56639: LD_VAR 0 7
56643: PUSH
56644: LD_INT 1
56646: ARRAY
56647: PPUSH
56648: LD_VAR 0 7
56652: PUSH
56653: LD_INT 2
56655: ARRAY
56656: PPUSH
56657: LD_VAR 0 3
56661: PPUSH
56662: CALL_OW 48
// result := IsPlaced ( unit ) ;
56666: LD_ADDR_VAR 0 4
56670: PUSH
56671: LD_VAR 0 1
56675: PPUSH
56676: CALL_OW 305
56680: ST_TO_ADDR
// exit ;
56681: POP
56682: POP
56683: GO 56689
// end ; end ;
56685: GO 56552
56687: POP
56688: POP
// end ;
56689: LD_VAR 0 4
56693: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56694: LD_INT 0
56696: PPUSH
56697: PPUSH
56698: PPUSH
// if not side or side > 8 then
56699: LD_VAR 0 1
56703: NOT
56704: PUSH
56705: LD_VAR 0 1
56709: PUSH
56710: LD_INT 8
56712: GREATER
56713: OR
56714: IFFALSE 56718
// exit ;
56716: GO 56905
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56718: LD_ADDR_VAR 0 4
56722: PUSH
56723: LD_INT 22
56725: PUSH
56726: LD_VAR 0 1
56730: PUSH
56731: EMPTY
56732: LIST
56733: LIST
56734: PUSH
56735: LD_INT 21
56737: PUSH
56738: LD_INT 3
56740: PUSH
56741: EMPTY
56742: LIST
56743: LIST
56744: PUSH
56745: EMPTY
56746: LIST
56747: LIST
56748: PPUSH
56749: CALL_OW 69
56753: ST_TO_ADDR
// if not tmp then
56754: LD_VAR 0 4
56758: NOT
56759: IFFALSE 56763
// exit ;
56761: GO 56905
// enable_addtolog := true ;
56763: LD_ADDR_OWVAR 81
56767: PUSH
56768: LD_INT 1
56770: ST_TO_ADDR
// AddToLog ( [ ) ;
56771: LD_STRING [
56773: PPUSH
56774: CALL_OW 561
// for i in tmp do
56778: LD_ADDR_VAR 0 3
56782: PUSH
56783: LD_VAR 0 4
56787: PUSH
56788: FOR_IN
56789: IFFALSE 56896
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56791: LD_STRING [
56793: PUSH
56794: LD_VAR 0 3
56798: PPUSH
56799: CALL_OW 266
56803: STR
56804: PUSH
56805: LD_STRING , 
56807: STR
56808: PUSH
56809: LD_VAR 0 3
56813: PPUSH
56814: CALL_OW 250
56818: STR
56819: PUSH
56820: LD_STRING , 
56822: STR
56823: PUSH
56824: LD_VAR 0 3
56828: PPUSH
56829: CALL_OW 251
56833: STR
56834: PUSH
56835: LD_STRING , 
56837: STR
56838: PUSH
56839: LD_VAR 0 3
56843: PPUSH
56844: CALL_OW 254
56848: STR
56849: PUSH
56850: LD_STRING , 
56852: STR
56853: PUSH
56854: LD_VAR 0 3
56858: PPUSH
56859: LD_INT 1
56861: PPUSH
56862: CALL_OW 268
56866: STR
56867: PUSH
56868: LD_STRING , 
56870: STR
56871: PUSH
56872: LD_VAR 0 3
56876: PPUSH
56877: LD_INT 2
56879: PPUSH
56880: CALL_OW 268
56884: STR
56885: PUSH
56886: LD_STRING ],
56888: STR
56889: PPUSH
56890: CALL_OW 561
// end ;
56894: GO 56788
56896: POP
56897: POP
// AddToLog ( ]; ) ;
56898: LD_STRING ];
56900: PPUSH
56901: CALL_OW 561
// end ;
56905: LD_VAR 0 2
56909: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56910: LD_INT 0
56912: PPUSH
56913: PPUSH
56914: PPUSH
56915: PPUSH
56916: PPUSH
// if not area or not rate or not max then
56917: LD_VAR 0 1
56921: NOT
56922: PUSH
56923: LD_VAR 0 2
56927: NOT
56928: OR
56929: PUSH
56930: LD_VAR 0 4
56934: NOT
56935: OR
56936: IFFALSE 56940
// exit ;
56938: GO 57129
// while 1 do
56940: LD_INT 1
56942: IFFALSE 57129
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56944: LD_ADDR_VAR 0 9
56948: PUSH
56949: LD_VAR 0 1
56953: PPUSH
56954: LD_INT 1
56956: PPUSH
56957: CALL_OW 287
56961: PUSH
56962: LD_INT 10
56964: MUL
56965: ST_TO_ADDR
// r := rate / 10 ;
56966: LD_ADDR_VAR 0 7
56970: PUSH
56971: LD_VAR 0 2
56975: PUSH
56976: LD_INT 10
56978: DIVREAL
56979: ST_TO_ADDR
// time := 1 1$00 ;
56980: LD_ADDR_VAR 0 8
56984: PUSH
56985: LD_INT 2100
56987: ST_TO_ADDR
// if amount < min then
56988: LD_VAR 0 9
56992: PUSH
56993: LD_VAR 0 3
56997: LESS
56998: IFFALSE 57016
// r := r * 2 else
57000: LD_ADDR_VAR 0 7
57004: PUSH
57005: LD_VAR 0 7
57009: PUSH
57010: LD_INT 2
57012: MUL
57013: ST_TO_ADDR
57014: GO 57042
// if amount > max then
57016: LD_VAR 0 9
57020: PUSH
57021: LD_VAR 0 4
57025: GREATER
57026: IFFALSE 57042
// r := r / 2 ;
57028: LD_ADDR_VAR 0 7
57032: PUSH
57033: LD_VAR 0 7
57037: PUSH
57038: LD_INT 2
57040: DIVREAL
57041: ST_TO_ADDR
// time := time / r ;
57042: LD_ADDR_VAR 0 8
57046: PUSH
57047: LD_VAR 0 8
57051: PUSH
57052: LD_VAR 0 7
57056: DIVREAL
57057: ST_TO_ADDR
// if time < 0 then
57058: LD_VAR 0 8
57062: PUSH
57063: LD_INT 0
57065: LESS
57066: IFFALSE 57083
// time := time * - 1 ;
57068: LD_ADDR_VAR 0 8
57072: PUSH
57073: LD_VAR 0 8
57077: PUSH
57078: LD_INT 1
57080: NEG
57081: MUL
57082: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
57083: LD_VAR 0 8
57087: PUSH
57088: LD_INT 35
57090: PPUSH
57091: LD_INT 875
57093: PPUSH
57094: CALL_OW 12
57098: PLUS
57099: PPUSH
57100: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
57104: LD_INT 1
57106: PPUSH
57107: LD_INT 5
57109: PPUSH
57110: CALL_OW 12
57114: PPUSH
57115: LD_VAR 0 1
57119: PPUSH
57120: LD_INT 1
57122: PPUSH
57123: CALL_OW 55
// end ;
57127: GO 56940
// end ;
57129: LD_VAR 0 5
57133: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
57134: LD_INT 0
57136: PPUSH
57137: PPUSH
57138: PPUSH
57139: PPUSH
57140: PPUSH
57141: PPUSH
57142: PPUSH
57143: PPUSH
// if not turrets or not factories then
57144: LD_VAR 0 1
57148: NOT
57149: PUSH
57150: LD_VAR 0 2
57154: NOT
57155: OR
57156: IFFALSE 57160
// exit ;
57158: GO 57467
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
57160: LD_ADDR_VAR 0 10
57164: PUSH
57165: LD_INT 5
57167: PUSH
57168: LD_INT 6
57170: PUSH
57171: EMPTY
57172: LIST
57173: LIST
57174: PUSH
57175: LD_INT 2
57177: PUSH
57178: LD_INT 4
57180: PUSH
57181: EMPTY
57182: LIST
57183: LIST
57184: PUSH
57185: LD_INT 3
57187: PUSH
57188: LD_INT 5
57190: PUSH
57191: EMPTY
57192: LIST
57193: LIST
57194: PUSH
57195: EMPTY
57196: LIST
57197: LIST
57198: LIST
57199: PUSH
57200: LD_INT 24
57202: PUSH
57203: LD_INT 25
57205: PUSH
57206: EMPTY
57207: LIST
57208: LIST
57209: PUSH
57210: LD_INT 23
57212: PUSH
57213: LD_INT 27
57215: PUSH
57216: EMPTY
57217: LIST
57218: LIST
57219: PUSH
57220: EMPTY
57221: LIST
57222: LIST
57223: PUSH
57224: LD_INT 42
57226: PUSH
57227: LD_INT 43
57229: PUSH
57230: EMPTY
57231: LIST
57232: LIST
57233: PUSH
57234: LD_INT 44
57236: PUSH
57237: LD_INT 46
57239: PUSH
57240: EMPTY
57241: LIST
57242: LIST
57243: PUSH
57244: LD_INT 45
57246: PUSH
57247: LD_INT 47
57249: PUSH
57250: EMPTY
57251: LIST
57252: LIST
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: LIST
57258: PUSH
57259: EMPTY
57260: LIST
57261: LIST
57262: LIST
57263: ST_TO_ADDR
// result := [ ] ;
57264: LD_ADDR_VAR 0 3
57268: PUSH
57269: EMPTY
57270: ST_TO_ADDR
// for i in turrets do
57271: LD_ADDR_VAR 0 4
57275: PUSH
57276: LD_VAR 0 1
57280: PUSH
57281: FOR_IN
57282: IFFALSE 57465
// begin nat := GetNation ( i ) ;
57284: LD_ADDR_VAR 0 7
57288: PUSH
57289: LD_VAR 0 4
57293: PPUSH
57294: CALL_OW 248
57298: ST_TO_ADDR
// weapon := 0 ;
57299: LD_ADDR_VAR 0 8
57303: PUSH
57304: LD_INT 0
57306: ST_TO_ADDR
// if not nat then
57307: LD_VAR 0 7
57311: NOT
57312: IFFALSE 57316
// continue ;
57314: GO 57281
// for j in list [ nat ] do
57316: LD_ADDR_VAR 0 5
57320: PUSH
57321: LD_VAR 0 10
57325: PUSH
57326: LD_VAR 0 7
57330: ARRAY
57331: PUSH
57332: FOR_IN
57333: IFFALSE 57374
// if GetBWeapon ( i ) = j [ 1 ] then
57335: LD_VAR 0 4
57339: PPUSH
57340: CALL_OW 269
57344: PUSH
57345: LD_VAR 0 5
57349: PUSH
57350: LD_INT 1
57352: ARRAY
57353: EQUAL
57354: IFFALSE 57372
// begin weapon := j [ 2 ] ;
57356: LD_ADDR_VAR 0 8
57360: PUSH
57361: LD_VAR 0 5
57365: PUSH
57366: LD_INT 2
57368: ARRAY
57369: ST_TO_ADDR
// break ;
57370: GO 57374
// end ;
57372: GO 57332
57374: POP
57375: POP
// if not weapon then
57376: LD_VAR 0 8
57380: NOT
57381: IFFALSE 57385
// continue ;
57383: GO 57281
// for k in factories do
57385: LD_ADDR_VAR 0 6
57389: PUSH
57390: LD_VAR 0 2
57394: PUSH
57395: FOR_IN
57396: IFFALSE 57461
// begin weapons := AvailableWeaponList ( k ) ;
57398: LD_ADDR_VAR 0 9
57402: PUSH
57403: LD_VAR 0 6
57407: PPUSH
57408: CALL_OW 478
57412: ST_TO_ADDR
// if not weapons then
57413: LD_VAR 0 9
57417: NOT
57418: IFFALSE 57422
// continue ;
57420: GO 57395
// if weapon in weapons then
57422: LD_VAR 0 8
57426: PUSH
57427: LD_VAR 0 9
57431: IN
57432: IFFALSE 57459
// begin result := [ i , weapon ] ;
57434: LD_ADDR_VAR 0 3
57438: PUSH
57439: LD_VAR 0 4
57443: PUSH
57444: LD_VAR 0 8
57448: PUSH
57449: EMPTY
57450: LIST
57451: LIST
57452: ST_TO_ADDR
// exit ;
57453: POP
57454: POP
57455: POP
57456: POP
57457: GO 57467
// end ; end ;
57459: GO 57395
57461: POP
57462: POP
// end ;
57463: GO 57281
57465: POP
57466: POP
// end ;
57467: LD_VAR 0 3
57471: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57472: LD_INT 0
57474: PPUSH
// if not side or side > 8 then
57475: LD_VAR 0 3
57479: NOT
57480: PUSH
57481: LD_VAR 0 3
57485: PUSH
57486: LD_INT 8
57488: GREATER
57489: OR
57490: IFFALSE 57494
// exit ;
57492: GO 57553
// if not range then
57494: LD_VAR 0 4
57498: NOT
57499: IFFALSE 57510
// range := - 12 ;
57501: LD_ADDR_VAR 0 4
57505: PUSH
57506: LD_INT 12
57508: NEG
57509: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57510: LD_VAR 0 1
57514: PPUSH
57515: LD_VAR 0 2
57519: PPUSH
57520: LD_VAR 0 3
57524: PPUSH
57525: LD_VAR 0 4
57529: PPUSH
57530: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57534: LD_VAR 0 1
57538: PPUSH
57539: LD_VAR 0 2
57543: PPUSH
57544: LD_VAR 0 3
57548: PPUSH
57549: CALL_OW 331
// end ;
57553: LD_VAR 0 5
57557: RET
// export function Video ( mode ) ; begin
57558: LD_INT 0
57560: PPUSH
// ingame_video = mode ;
57561: LD_ADDR_OWVAR 52
57565: PUSH
57566: LD_VAR 0 1
57570: ST_TO_ADDR
// interface_hidden = mode ;
57571: LD_ADDR_OWVAR 54
57575: PUSH
57576: LD_VAR 0 1
57580: ST_TO_ADDR
// end ;
57581: LD_VAR 0 2
57585: RET
// export function Join ( array , element ) ; begin
57586: LD_INT 0
57588: PPUSH
// result := Replace ( array , array + 1 , element ) ;
57589: LD_ADDR_VAR 0 3
57593: PUSH
57594: LD_VAR 0 1
57598: PPUSH
57599: LD_VAR 0 1
57603: PUSH
57604: LD_INT 1
57606: PLUS
57607: PPUSH
57608: LD_VAR 0 2
57612: PPUSH
57613: CALL_OW 1
57617: ST_TO_ADDR
// end ;
57618: LD_VAR 0 3
57622: RET
// export function JoinUnion ( array , element ) ; begin
57623: LD_INT 0
57625: PPUSH
// result := array union element ;
57626: LD_ADDR_VAR 0 3
57630: PUSH
57631: LD_VAR 0 1
57635: PUSH
57636: LD_VAR 0 2
57640: UNION
57641: ST_TO_ADDR
// end ;
57642: LD_VAR 0 3
57646: RET
// export function GetBehemoths ( side ) ; begin
57647: LD_INT 0
57649: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
57650: LD_ADDR_VAR 0 2
57654: PUSH
57655: LD_INT 22
57657: PUSH
57658: LD_VAR 0 1
57662: PUSH
57663: EMPTY
57664: LIST
57665: LIST
57666: PUSH
57667: LD_INT 31
57669: PUSH
57670: LD_INT 25
57672: PUSH
57673: EMPTY
57674: LIST
57675: LIST
57676: PUSH
57677: EMPTY
57678: LIST
57679: LIST
57680: PPUSH
57681: CALL_OW 69
57685: ST_TO_ADDR
// end ;
57686: LD_VAR 0 2
57690: RET
// export function Shuffle ( array ) ; var i , index ; begin
57691: LD_INT 0
57693: PPUSH
57694: PPUSH
57695: PPUSH
// result := [ ] ;
57696: LD_ADDR_VAR 0 2
57700: PUSH
57701: EMPTY
57702: ST_TO_ADDR
// if not array then
57703: LD_VAR 0 1
57707: NOT
57708: IFFALSE 57712
// exit ;
57710: GO 57811
// Randomize ;
57712: CALL_OW 10
// for i = array downto 1 do
57716: LD_ADDR_VAR 0 3
57720: PUSH
57721: DOUBLE
57722: LD_VAR 0 1
57726: INC
57727: ST_TO_ADDR
57728: LD_INT 1
57730: PUSH
57731: FOR_DOWNTO
57732: IFFALSE 57809
// begin index := rand ( 1 , array ) ;
57734: LD_ADDR_VAR 0 4
57738: PUSH
57739: LD_INT 1
57741: PPUSH
57742: LD_VAR 0 1
57746: PPUSH
57747: CALL_OW 12
57751: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57752: LD_ADDR_VAR 0 2
57756: PUSH
57757: LD_VAR 0 2
57761: PPUSH
57762: LD_VAR 0 2
57766: PUSH
57767: LD_INT 1
57769: PLUS
57770: PPUSH
57771: LD_VAR 0 1
57775: PUSH
57776: LD_VAR 0 4
57780: ARRAY
57781: PPUSH
57782: CALL_OW 2
57786: ST_TO_ADDR
// array := Delete ( array , index ) ;
57787: LD_ADDR_VAR 0 1
57791: PUSH
57792: LD_VAR 0 1
57796: PPUSH
57797: LD_VAR 0 4
57801: PPUSH
57802: CALL_OW 3
57806: ST_TO_ADDR
// end ;
57807: GO 57731
57809: POP
57810: POP
// end ;
57811: LD_VAR 0 2
57815: RET
// export function GetBaseMaterials ( base ) ; begin
57816: LD_INT 0
57818: PPUSH
// result := [ 0 , 0 , 0 ] ;
57819: LD_ADDR_VAR 0 2
57823: PUSH
57824: LD_INT 0
57826: PUSH
57827: LD_INT 0
57829: PUSH
57830: LD_INT 0
57832: PUSH
57833: EMPTY
57834: LIST
57835: LIST
57836: LIST
57837: ST_TO_ADDR
// if not base then
57838: LD_VAR 0 1
57842: NOT
57843: IFFALSE 57847
// exit ;
57845: GO 57896
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57847: LD_ADDR_VAR 0 2
57851: PUSH
57852: LD_VAR 0 1
57856: PPUSH
57857: LD_INT 1
57859: PPUSH
57860: CALL_OW 275
57864: PUSH
57865: LD_VAR 0 1
57869: PPUSH
57870: LD_INT 2
57872: PPUSH
57873: CALL_OW 275
57877: PUSH
57878: LD_VAR 0 1
57882: PPUSH
57883: LD_INT 3
57885: PPUSH
57886: CALL_OW 275
57890: PUSH
57891: EMPTY
57892: LIST
57893: LIST
57894: LIST
57895: ST_TO_ADDR
// end ;
57896: LD_VAR 0 2
57900: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57901: LD_INT 0
57903: PPUSH
57904: PPUSH
// result := array ;
57905: LD_ADDR_VAR 0 3
57909: PUSH
57910: LD_VAR 0 1
57914: ST_TO_ADDR
// if size >= result then
57915: LD_VAR 0 2
57919: PUSH
57920: LD_VAR 0 3
57924: GREATEREQUAL
57925: IFFALSE 57929
// exit ;
57927: GO 57979
// if size then
57929: LD_VAR 0 2
57933: IFFALSE 57979
// for i := array downto size do
57935: LD_ADDR_VAR 0 4
57939: PUSH
57940: DOUBLE
57941: LD_VAR 0 1
57945: INC
57946: ST_TO_ADDR
57947: LD_VAR 0 2
57951: PUSH
57952: FOR_DOWNTO
57953: IFFALSE 57977
// result := Delete ( result , result ) ;
57955: LD_ADDR_VAR 0 3
57959: PUSH
57960: LD_VAR 0 3
57964: PPUSH
57965: LD_VAR 0 3
57969: PPUSH
57970: CALL_OW 3
57974: ST_TO_ADDR
57975: GO 57952
57977: POP
57978: POP
// end ;
57979: LD_VAR 0 3
57983: RET
// export function ComExit ( unit ) ; var tmp ; begin
57984: LD_INT 0
57986: PPUSH
57987: PPUSH
// if not IsInUnit ( unit ) then
57988: LD_VAR 0 1
57992: PPUSH
57993: CALL_OW 310
57997: NOT
57998: IFFALSE 58002
// exit ;
58000: GO 58062
// tmp := IsInUnit ( unit ) ;
58002: LD_ADDR_VAR 0 3
58006: PUSH
58007: LD_VAR 0 1
58011: PPUSH
58012: CALL_OW 310
58016: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
58017: LD_VAR 0 3
58021: PPUSH
58022: CALL_OW 247
58026: PUSH
58027: LD_INT 2
58029: EQUAL
58030: IFFALSE 58043
// ComExitVehicle ( unit ) else
58032: LD_VAR 0 1
58036: PPUSH
58037: CALL_OW 121
58041: GO 58052
// ComExitBuilding ( unit ) ;
58043: LD_VAR 0 1
58047: PPUSH
58048: CALL_OW 122
// result := tmp ;
58052: LD_ADDR_VAR 0 2
58056: PUSH
58057: LD_VAR 0 3
58061: ST_TO_ADDR
// end ;
58062: LD_VAR 0 2
58066: RET
// export function ComExitAll ( units ) ; var i ; begin
58067: LD_INT 0
58069: PPUSH
58070: PPUSH
// if not units then
58071: LD_VAR 0 1
58075: NOT
58076: IFFALSE 58080
// exit ;
58078: GO 58106
// for i in units do
58080: LD_ADDR_VAR 0 3
58084: PUSH
58085: LD_VAR 0 1
58089: PUSH
58090: FOR_IN
58091: IFFALSE 58104
// ComExit ( i ) ;
58093: LD_VAR 0 3
58097: PPUSH
58098: CALL 57984 0 1
58102: GO 58090
58104: POP
58105: POP
// end ;
58106: LD_VAR 0 2
58110: RET
// export function ResetHc ; begin
58111: LD_INT 0
58113: PPUSH
// InitHc ;
58114: CALL_OW 19
// hc_importance := 0 ;
58118: LD_ADDR_OWVAR 32
58122: PUSH
58123: LD_INT 0
58125: ST_TO_ADDR
// end ;
58126: LD_VAR 0 1
58130: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
58131: LD_INT 0
58133: PPUSH
58134: PPUSH
58135: PPUSH
// _x := ( x1 + x2 ) div 2 ;
58136: LD_ADDR_VAR 0 6
58140: PUSH
58141: LD_VAR 0 1
58145: PUSH
58146: LD_VAR 0 3
58150: PLUS
58151: PUSH
58152: LD_INT 2
58154: DIV
58155: ST_TO_ADDR
// if _x < 0 then
58156: LD_VAR 0 6
58160: PUSH
58161: LD_INT 0
58163: LESS
58164: IFFALSE 58181
// _x := _x * - 1 ;
58166: LD_ADDR_VAR 0 6
58170: PUSH
58171: LD_VAR 0 6
58175: PUSH
58176: LD_INT 1
58178: NEG
58179: MUL
58180: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
58181: LD_ADDR_VAR 0 7
58185: PUSH
58186: LD_VAR 0 2
58190: PUSH
58191: LD_VAR 0 4
58195: PLUS
58196: PUSH
58197: LD_INT 2
58199: DIV
58200: ST_TO_ADDR
// if _y < 0 then
58201: LD_VAR 0 7
58205: PUSH
58206: LD_INT 0
58208: LESS
58209: IFFALSE 58226
// _y := _y * - 1 ;
58211: LD_ADDR_VAR 0 7
58215: PUSH
58216: LD_VAR 0 7
58220: PUSH
58221: LD_INT 1
58223: NEG
58224: MUL
58225: ST_TO_ADDR
// result := [ _x , _y ] ;
58226: LD_ADDR_VAR 0 5
58230: PUSH
58231: LD_VAR 0 6
58235: PUSH
58236: LD_VAR 0 7
58240: PUSH
58241: EMPTY
58242: LIST
58243: LIST
58244: ST_TO_ADDR
// end ;
58245: LD_VAR 0 5
58249: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
58250: LD_INT 0
58252: PPUSH
58253: PPUSH
58254: PPUSH
58255: PPUSH
// task := GetTaskList ( unit ) ;
58256: LD_ADDR_VAR 0 7
58260: PUSH
58261: LD_VAR 0 1
58265: PPUSH
58266: CALL_OW 437
58270: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
58271: LD_VAR 0 7
58275: NOT
58276: PUSH
58277: LD_VAR 0 1
58281: PPUSH
58282: LD_VAR 0 2
58286: PPUSH
58287: CALL_OW 308
58291: NOT
58292: AND
58293: IFFALSE 58297
// exit ;
58295: GO 58415
// if IsInArea ( unit , area ) then
58297: LD_VAR 0 1
58301: PPUSH
58302: LD_VAR 0 2
58306: PPUSH
58307: CALL_OW 308
58311: IFFALSE 58329
// begin ComMoveToArea ( unit , goAway ) ;
58313: LD_VAR 0 1
58317: PPUSH
58318: LD_VAR 0 3
58322: PPUSH
58323: CALL_OW 113
// exit ;
58327: GO 58415
// end ; if task [ 1 ] [ 1 ] <> M then
58329: LD_VAR 0 7
58333: PUSH
58334: LD_INT 1
58336: ARRAY
58337: PUSH
58338: LD_INT 1
58340: ARRAY
58341: PUSH
58342: LD_STRING M
58344: NONEQUAL
58345: IFFALSE 58349
// exit ;
58347: GO 58415
// x := task [ 1 ] [ 2 ] ;
58349: LD_ADDR_VAR 0 5
58353: PUSH
58354: LD_VAR 0 7
58358: PUSH
58359: LD_INT 1
58361: ARRAY
58362: PUSH
58363: LD_INT 2
58365: ARRAY
58366: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
58367: LD_ADDR_VAR 0 6
58371: PUSH
58372: LD_VAR 0 7
58376: PUSH
58377: LD_INT 1
58379: ARRAY
58380: PUSH
58381: LD_INT 3
58383: ARRAY
58384: ST_TO_ADDR
// if InArea ( x , y , area ) then
58385: LD_VAR 0 5
58389: PPUSH
58390: LD_VAR 0 6
58394: PPUSH
58395: LD_VAR 0 2
58399: PPUSH
58400: CALL_OW 309
58404: IFFALSE 58415
// ComStop ( unit ) ;
58406: LD_VAR 0 1
58410: PPUSH
58411: CALL_OW 141
// end ;
58415: LD_VAR 0 4
58419: RET
// export function Abs ( value ) ; begin
58420: LD_INT 0
58422: PPUSH
// result := value ;
58423: LD_ADDR_VAR 0 2
58427: PUSH
58428: LD_VAR 0 1
58432: ST_TO_ADDR
// if value < 0 then
58433: LD_VAR 0 1
58437: PUSH
58438: LD_INT 0
58440: LESS
58441: IFFALSE 58458
// result := value * - 1 ;
58443: LD_ADDR_VAR 0 2
58447: PUSH
58448: LD_VAR 0 1
58452: PUSH
58453: LD_INT 1
58455: NEG
58456: MUL
58457: ST_TO_ADDR
// end ;
58458: LD_VAR 0 2
58462: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58463: LD_INT 0
58465: PPUSH
58466: PPUSH
58467: PPUSH
58468: PPUSH
58469: PPUSH
58470: PPUSH
58471: PPUSH
58472: PPUSH
// if not unit or not building then
58473: LD_VAR 0 1
58477: NOT
58478: PUSH
58479: LD_VAR 0 2
58483: NOT
58484: OR
58485: IFFALSE 58489
// exit ;
58487: GO 58715
// x := GetX ( building ) ;
58489: LD_ADDR_VAR 0 4
58493: PUSH
58494: LD_VAR 0 2
58498: PPUSH
58499: CALL_OW 250
58503: ST_TO_ADDR
// y := GetY ( building ) ;
58504: LD_ADDR_VAR 0 6
58508: PUSH
58509: LD_VAR 0 2
58513: PPUSH
58514: CALL_OW 251
58518: ST_TO_ADDR
// d := GetDir ( building ) ;
58519: LD_ADDR_VAR 0 8
58523: PUSH
58524: LD_VAR 0 2
58528: PPUSH
58529: CALL_OW 254
58533: ST_TO_ADDR
// r := 4 ;
58534: LD_ADDR_VAR 0 9
58538: PUSH
58539: LD_INT 4
58541: ST_TO_ADDR
// for i := 1 to 5 do
58542: LD_ADDR_VAR 0 10
58546: PUSH
58547: DOUBLE
58548: LD_INT 1
58550: DEC
58551: ST_TO_ADDR
58552: LD_INT 5
58554: PUSH
58555: FOR_TO
58556: IFFALSE 58713
// begin _x := ShiftX ( x , d , r + i ) ;
58558: LD_ADDR_VAR 0 5
58562: PUSH
58563: LD_VAR 0 4
58567: PPUSH
58568: LD_VAR 0 8
58572: PPUSH
58573: LD_VAR 0 9
58577: PUSH
58578: LD_VAR 0 10
58582: PLUS
58583: PPUSH
58584: CALL_OW 272
58588: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
58589: LD_ADDR_VAR 0 7
58593: PUSH
58594: LD_VAR 0 6
58598: PPUSH
58599: LD_VAR 0 8
58603: PPUSH
58604: LD_VAR 0 9
58608: PUSH
58609: LD_VAR 0 10
58613: PLUS
58614: PPUSH
58615: CALL_OW 273
58619: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
58620: LD_VAR 0 5
58624: PPUSH
58625: LD_VAR 0 7
58629: PPUSH
58630: CALL_OW 488
58634: PUSH
58635: LD_VAR 0 5
58639: PPUSH
58640: LD_VAR 0 7
58644: PPUSH
58645: CALL_OW 428
58649: PPUSH
58650: CALL_OW 247
58654: PUSH
58655: LD_INT 3
58657: PUSH
58658: LD_INT 2
58660: PUSH
58661: EMPTY
58662: LIST
58663: LIST
58664: IN
58665: NOT
58666: AND
58667: IFFALSE 58711
// begin ComMoveXY ( unit , _x , _y ) ;
58669: LD_VAR 0 1
58673: PPUSH
58674: LD_VAR 0 5
58678: PPUSH
58679: LD_VAR 0 7
58683: PPUSH
58684: CALL_OW 111
// result := [ _x , _y ] ;
58688: LD_ADDR_VAR 0 3
58692: PUSH
58693: LD_VAR 0 5
58697: PUSH
58698: LD_VAR 0 7
58702: PUSH
58703: EMPTY
58704: LIST
58705: LIST
58706: ST_TO_ADDR
// exit ;
58707: POP
58708: POP
58709: GO 58715
// end ; end ;
58711: GO 58555
58713: POP
58714: POP
// end ;
58715: LD_VAR 0 3
58719: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
58720: LD_INT 0
58722: PPUSH
58723: PPUSH
58724: PPUSH
// result := 0 ;
58725: LD_ADDR_VAR 0 3
58729: PUSH
58730: LD_INT 0
58732: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
58733: LD_VAR 0 1
58737: PUSH
58738: LD_INT 0
58740: LESS
58741: PUSH
58742: LD_VAR 0 1
58746: PUSH
58747: LD_INT 8
58749: GREATER
58750: OR
58751: PUSH
58752: LD_VAR 0 2
58756: PUSH
58757: LD_INT 0
58759: LESS
58760: OR
58761: PUSH
58762: LD_VAR 0 2
58766: PUSH
58767: LD_INT 8
58769: GREATER
58770: OR
58771: IFFALSE 58775
// exit ;
58773: GO 58850
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
58775: LD_ADDR_VAR 0 4
58779: PUSH
58780: LD_INT 22
58782: PUSH
58783: LD_VAR 0 2
58787: PUSH
58788: EMPTY
58789: LIST
58790: LIST
58791: PPUSH
58792: CALL_OW 69
58796: PUSH
58797: FOR_IN
58798: IFFALSE 58848
// begin un := UnitShoot ( i ) ;
58800: LD_ADDR_VAR 0 5
58804: PUSH
58805: LD_VAR 0 4
58809: PPUSH
58810: CALL_OW 504
58814: ST_TO_ADDR
// if GetSide ( un ) = side1 then
58815: LD_VAR 0 5
58819: PPUSH
58820: CALL_OW 255
58824: PUSH
58825: LD_VAR 0 1
58829: EQUAL
58830: IFFALSE 58846
// begin result := un ;
58832: LD_ADDR_VAR 0 3
58836: PUSH
58837: LD_VAR 0 5
58841: ST_TO_ADDR
// exit ;
58842: POP
58843: POP
58844: GO 58850
// end ; end ;
58846: GO 58797
58848: POP
58849: POP
// end ;
58850: LD_VAR 0 3
58854: RET
// export function GetCargoBay ( units ) ; begin
58855: LD_INT 0
58857: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
58858: LD_ADDR_VAR 0 2
58862: PUSH
58863: LD_VAR 0 1
58867: PPUSH
58868: LD_INT 2
58870: PUSH
58871: LD_INT 34
58873: PUSH
58874: LD_INT 12
58876: PUSH
58877: EMPTY
58878: LIST
58879: LIST
58880: PUSH
58881: LD_INT 34
58883: PUSH
58884: LD_INT 51
58886: PUSH
58887: EMPTY
58888: LIST
58889: LIST
58890: PUSH
58891: LD_INT 34
58893: PUSH
58894: LD_INT 32
58896: PUSH
58897: EMPTY
58898: LIST
58899: LIST
58900: PUSH
58901: LD_INT 34
58903: PUSH
58904: LD_INT 89
58906: PUSH
58907: EMPTY
58908: LIST
58909: LIST
58910: PUSH
58911: EMPTY
58912: LIST
58913: LIST
58914: LIST
58915: LIST
58916: LIST
58917: PPUSH
58918: CALL_OW 72
58922: ST_TO_ADDR
// end ;
58923: LD_VAR 0 2
58927: RET
// export function Negate ( value ) ; begin
58928: LD_INT 0
58930: PPUSH
// result := not value ;
58931: LD_ADDR_VAR 0 2
58935: PUSH
58936: LD_VAR 0 1
58940: NOT
58941: ST_TO_ADDR
// end ;
58942: LD_VAR 0 2
58946: RET
// export function Inc ( value ) ; begin
58947: LD_INT 0
58949: PPUSH
// result := value + 1 ;
58950: LD_ADDR_VAR 0 2
58954: PUSH
58955: LD_VAR 0 1
58959: PUSH
58960: LD_INT 1
58962: PLUS
58963: ST_TO_ADDR
// end ;
58964: LD_VAR 0 2
58968: RET
// export function Dec ( value ) ; begin
58969: LD_INT 0
58971: PPUSH
// result := value - 1 ;
58972: LD_ADDR_VAR 0 2
58976: PUSH
58977: LD_VAR 0 1
58981: PUSH
58982: LD_INT 1
58984: MINUS
58985: ST_TO_ADDR
// end ;
58986: LD_VAR 0 2
58990: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58991: LD_INT 0
58993: PPUSH
58994: PPUSH
58995: PPUSH
58996: PPUSH
58997: PPUSH
58998: PPUSH
58999: PPUSH
59000: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
59001: LD_VAR 0 1
59005: PPUSH
59006: LD_VAR 0 2
59010: PPUSH
59011: CALL_OW 488
59015: NOT
59016: PUSH
59017: LD_VAR 0 3
59021: PPUSH
59022: LD_VAR 0 4
59026: PPUSH
59027: CALL_OW 488
59031: NOT
59032: OR
59033: IFFALSE 59046
// begin result := - 1 ;
59035: LD_ADDR_VAR 0 5
59039: PUSH
59040: LD_INT 1
59042: NEG
59043: ST_TO_ADDR
// exit ;
59044: GO 59281
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
59046: LD_ADDR_VAR 0 12
59050: PUSH
59051: LD_VAR 0 1
59055: PPUSH
59056: LD_VAR 0 2
59060: PPUSH
59061: LD_VAR 0 3
59065: PPUSH
59066: LD_VAR 0 4
59070: PPUSH
59071: CALL 58131 0 4
59075: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
59076: LD_ADDR_VAR 0 11
59080: PUSH
59081: LD_VAR 0 1
59085: PPUSH
59086: LD_VAR 0 2
59090: PPUSH
59091: LD_VAR 0 12
59095: PUSH
59096: LD_INT 1
59098: ARRAY
59099: PPUSH
59100: LD_VAR 0 12
59104: PUSH
59105: LD_INT 2
59107: ARRAY
59108: PPUSH
59109: CALL_OW 298
59113: ST_TO_ADDR
// distance := 9999 ;
59114: LD_ADDR_VAR 0 10
59118: PUSH
59119: LD_INT 9999
59121: ST_TO_ADDR
// for i := 0 to 5 do
59122: LD_ADDR_VAR 0 6
59126: PUSH
59127: DOUBLE
59128: LD_INT 0
59130: DEC
59131: ST_TO_ADDR
59132: LD_INT 5
59134: PUSH
59135: FOR_TO
59136: IFFALSE 59279
// begin _x := ShiftX ( x1 , i , centerDist ) ;
59138: LD_ADDR_VAR 0 7
59142: PUSH
59143: LD_VAR 0 1
59147: PPUSH
59148: LD_VAR 0 6
59152: PPUSH
59153: LD_VAR 0 11
59157: PPUSH
59158: CALL_OW 272
59162: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
59163: LD_ADDR_VAR 0 8
59167: PUSH
59168: LD_VAR 0 2
59172: PPUSH
59173: LD_VAR 0 6
59177: PPUSH
59178: LD_VAR 0 11
59182: PPUSH
59183: CALL_OW 273
59187: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
59188: LD_VAR 0 7
59192: PPUSH
59193: LD_VAR 0 8
59197: PPUSH
59198: CALL_OW 488
59202: NOT
59203: IFFALSE 59207
// continue ;
59205: GO 59135
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
59207: LD_ADDR_VAR 0 9
59211: PUSH
59212: LD_VAR 0 12
59216: PUSH
59217: LD_INT 1
59219: ARRAY
59220: PPUSH
59221: LD_VAR 0 12
59225: PUSH
59226: LD_INT 2
59228: ARRAY
59229: PPUSH
59230: LD_VAR 0 7
59234: PPUSH
59235: LD_VAR 0 8
59239: PPUSH
59240: CALL_OW 298
59244: ST_TO_ADDR
// if tmp < distance then
59245: LD_VAR 0 9
59249: PUSH
59250: LD_VAR 0 10
59254: LESS
59255: IFFALSE 59277
// begin result := i ;
59257: LD_ADDR_VAR 0 5
59261: PUSH
59262: LD_VAR 0 6
59266: ST_TO_ADDR
// distance := tmp ;
59267: LD_ADDR_VAR 0 10
59271: PUSH
59272: LD_VAR 0 9
59276: ST_TO_ADDR
// end ; end ;
59277: GO 59135
59279: POP
59280: POP
// end ;
59281: LD_VAR 0 5
59285: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59286: LD_INT 0
59288: PPUSH
59289: PPUSH
// if not driver or not IsInUnit ( driver ) then
59290: LD_VAR 0 1
59294: NOT
59295: PUSH
59296: LD_VAR 0 1
59300: PPUSH
59301: CALL_OW 310
59305: NOT
59306: OR
59307: IFFALSE 59311
// exit ;
59309: GO 59401
// vehicle := IsInUnit ( driver ) ;
59311: LD_ADDR_VAR 0 3
59315: PUSH
59316: LD_VAR 0 1
59320: PPUSH
59321: CALL_OW 310
59325: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59326: LD_VAR 0 1
59330: PPUSH
59331: LD_STRING \
59333: PUSH
59334: LD_INT 0
59336: PUSH
59337: LD_INT 0
59339: PUSH
59340: LD_INT 0
59342: PUSH
59343: LD_INT 0
59345: PUSH
59346: LD_INT 0
59348: PUSH
59349: LD_INT 0
59351: PUSH
59352: EMPTY
59353: LIST
59354: LIST
59355: LIST
59356: LIST
59357: LIST
59358: LIST
59359: LIST
59360: PUSH
59361: LD_STRING E
59363: PUSH
59364: LD_INT 0
59366: PUSH
59367: LD_INT 0
59369: PUSH
59370: LD_VAR 0 3
59374: PUSH
59375: LD_INT 0
59377: PUSH
59378: LD_INT 0
59380: PUSH
59381: LD_INT 0
59383: PUSH
59384: EMPTY
59385: LIST
59386: LIST
59387: LIST
59388: LIST
59389: LIST
59390: LIST
59391: LIST
59392: PUSH
59393: EMPTY
59394: LIST
59395: LIST
59396: PPUSH
59397: CALL_OW 446
// end ;
59401: LD_VAR 0 2
59405: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59406: LD_INT 0
59408: PPUSH
59409: PPUSH
// if not driver or not IsInUnit ( driver ) then
59410: LD_VAR 0 1
59414: NOT
59415: PUSH
59416: LD_VAR 0 1
59420: PPUSH
59421: CALL_OW 310
59425: NOT
59426: OR
59427: IFFALSE 59431
// exit ;
59429: GO 59521
// vehicle := IsInUnit ( driver ) ;
59431: LD_ADDR_VAR 0 3
59435: PUSH
59436: LD_VAR 0 1
59440: PPUSH
59441: CALL_OW 310
59445: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59446: LD_VAR 0 1
59450: PPUSH
59451: LD_STRING \
59453: PUSH
59454: LD_INT 0
59456: PUSH
59457: LD_INT 0
59459: PUSH
59460: LD_INT 0
59462: PUSH
59463: LD_INT 0
59465: PUSH
59466: LD_INT 0
59468: PUSH
59469: LD_INT 0
59471: PUSH
59472: EMPTY
59473: LIST
59474: LIST
59475: LIST
59476: LIST
59477: LIST
59478: LIST
59479: LIST
59480: PUSH
59481: LD_STRING E
59483: PUSH
59484: LD_INT 0
59486: PUSH
59487: LD_INT 0
59489: PUSH
59490: LD_VAR 0 3
59494: PUSH
59495: LD_INT 0
59497: PUSH
59498: LD_INT 0
59500: PUSH
59501: LD_INT 0
59503: PUSH
59504: EMPTY
59505: LIST
59506: LIST
59507: LIST
59508: LIST
59509: LIST
59510: LIST
59511: LIST
59512: PUSH
59513: EMPTY
59514: LIST
59515: LIST
59516: PPUSH
59517: CALL_OW 447
// end ;
59521: LD_VAR 0 2
59525: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
59526: LD_INT 0
59528: PPUSH
59529: PPUSH
59530: PPUSH
// tmp := [ ] ;
59531: LD_ADDR_VAR 0 5
59535: PUSH
59536: EMPTY
59537: ST_TO_ADDR
// for i in units do
59538: LD_ADDR_VAR 0 4
59542: PUSH
59543: LD_VAR 0 1
59547: PUSH
59548: FOR_IN
59549: IFFALSE 59587
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
59551: LD_ADDR_VAR 0 5
59555: PUSH
59556: LD_VAR 0 5
59560: PPUSH
59561: LD_VAR 0 5
59565: PUSH
59566: LD_INT 1
59568: PLUS
59569: PPUSH
59570: LD_VAR 0 4
59574: PPUSH
59575: CALL_OW 256
59579: PPUSH
59580: CALL_OW 2
59584: ST_TO_ADDR
59585: GO 59548
59587: POP
59588: POP
// if not tmp then
59589: LD_VAR 0 5
59593: NOT
59594: IFFALSE 59598
// exit ;
59596: GO 59646
// if asc then
59598: LD_VAR 0 2
59602: IFFALSE 59626
// result := SortListByListAsc ( units , tmp ) else
59604: LD_ADDR_VAR 0 3
59608: PUSH
59609: LD_VAR 0 1
59613: PPUSH
59614: LD_VAR 0 5
59618: PPUSH
59619: CALL_OW 76
59623: ST_TO_ADDR
59624: GO 59646
// result := SortListByListDesc ( units , tmp ) ;
59626: LD_ADDR_VAR 0 3
59630: PUSH
59631: LD_VAR 0 1
59635: PPUSH
59636: LD_VAR 0 5
59640: PPUSH
59641: CALL_OW 77
59645: ST_TO_ADDR
// end ;
59646: LD_VAR 0 3
59650: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
59651: LD_INT 0
59653: PPUSH
59654: PPUSH
// task := GetTaskList ( mech ) ;
59655: LD_ADDR_VAR 0 4
59659: PUSH
59660: LD_VAR 0 1
59664: PPUSH
59665: CALL_OW 437
59669: ST_TO_ADDR
// if not task then
59670: LD_VAR 0 4
59674: NOT
59675: IFFALSE 59679
// exit ;
59677: GO 59721
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
59679: LD_ADDR_VAR 0 3
59683: PUSH
59684: LD_VAR 0 4
59688: PUSH
59689: LD_INT 1
59691: ARRAY
59692: PUSH
59693: LD_INT 1
59695: ARRAY
59696: PUSH
59697: LD_STRING r
59699: EQUAL
59700: PUSH
59701: LD_VAR 0 4
59705: PUSH
59706: LD_INT 1
59708: ARRAY
59709: PUSH
59710: LD_INT 4
59712: ARRAY
59713: PUSH
59714: LD_VAR 0 2
59718: EQUAL
59719: AND
59720: ST_TO_ADDR
// end ;
59721: LD_VAR 0 3
59725: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
59726: LD_INT 0
59728: PPUSH
// SetDir ( unit , d ) ;
59729: LD_VAR 0 1
59733: PPUSH
59734: LD_VAR 0 4
59738: PPUSH
59739: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
59743: LD_VAR 0 1
59747: PPUSH
59748: LD_VAR 0 2
59752: PPUSH
59753: LD_VAR 0 3
59757: PPUSH
59758: LD_VAR 0 5
59762: PPUSH
59763: CALL_OW 48
// end ;
59767: LD_VAR 0 6
59771: RET
// export function ToNaturalNumber ( number ) ; begin
59772: LD_INT 0
59774: PPUSH
// result := number div 1 ;
59775: LD_ADDR_VAR 0 2
59779: PUSH
59780: LD_VAR 0 1
59784: PUSH
59785: LD_INT 1
59787: DIV
59788: ST_TO_ADDR
// if number < 0 then
59789: LD_VAR 0 1
59793: PUSH
59794: LD_INT 0
59796: LESS
59797: IFFALSE 59807
// result := 0 ;
59799: LD_ADDR_VAR 0 2
59803: PUSH
59804: LD_INT 0
59806: ST_TO_ADDR
// end ;
59807: LD_VAR 0 2
59811: RET
// export function SortByClass ( units , class ) ; var un ; begin
59812: LD_INT 0
59814: PPUSH
59815: PPUSH
// if not units or not class then
59816: LD_VAR 0 1
59820: NOT
59821: PUSH
59822: LD_VAR 0 2
59826: NOT
59827: OR
59828: IFFALSE 59832
// exit ;
59830: GO 59927
// result := [ ] ;
59832: LD_ADDR_VAR 0 3
59836: PUSH
59837: EMPTY
59838: ST_TO_ADDR
// for un in units do
59839: LD_ADDR_VAR 0 4
59843: PUSH
59844: LD_VAR 0 1
59848: PUSH
59849: FOR_IN
59850: IFFALSE 59925
// if GetClass ( un ) = class then
59852: LD_VAR 0 4
59856: PPUSH
59857: CALL_OW 257
59861: PUSH
59862: LD_VAR 0 2
59866: EQUAL
59867: IFFALSE 59894
// result := Insert ( result , 1 , un ) else
59869: LD_ADDR_VAR 0 3
59873: PUSH
59874: LD_VAR 0 3
59878: PPUSH
59879: LD_INT 1
59881: PPUSH
59882: LD_VAR 0 4
59886: PPUSH
59887: CALL_OW 2
59891: ST_TO_ADDR
59892: GO 59923
// result := Replace ( result , result + 1 , un ) ;
59894: LD_ADDR_VAR 0 3
59898: PUSH
59899: LD_VAR 0 3
59903: PPUSH
59904: LD_VAR 0 3
59908: PUSH
59909: LD_INT 1
59911: PLUS
59912: PPUSH
59913: LD_VAR 0 4
59917: PPUSH
59918: CALL_OW 1
59922: ST_TO_ADDR
59923: GO 59849
59925: POP
59926: POP
// end ;
59927: LD_VAR 0 3
59931: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59932: LD_INT 0
59934: PPUSH
59935: PPUSH
59936: PPUSH
59937: PPUSH
59938: PPUSH
59939: PPUSH
59940: PPUSH
// result := [ ] ;
59941: LD_ADDR_VAR 0 4
59945: PUSH
59946: EMPTY
59947: ST_TO_ADDR
// if x - r < 0 then
59948: LD_VAR 0 1
59952: PUSH
59953: LD_VAR 0 3
59957: MINUS
59958: PUSH
59959: LD_INT 0
59961: LESS
59962: IFFALSE 59974
// min_x := 0 else
59964: LD_ADDR_VAR 0 8
59968: PUSH
59969: LD_INT 0
59971: ST_TO_ADDR
59972: GO 59990
// min_x := x - r ;
59974: LD_ADDR_VAR 0 8
59978: PUSH
59979: LD_VAR 0 1
59983: PUSH
59984: LD_VAR 0 3
59988: MINUS
59989: ST_TO_ADDR
// if y - r < 0 then
59990: LD_VAR 0 2
59994: PUSH
59995: LD_VAR 0 3
59999: MINUS
60000: PUSH
60001: LD_INT 0
60003: LESS
60004: IFFALSE 60016
// min_y := 0 else
60006: LD_ADDR_VAR 0 7
60010: PUSH
60011: LD_INT 0
60013: ST_TO_ADDR
60014: GO 60032
// min_y := y - r ;
60016: LD_ADDR_VAR 0 7
60020: PUSH
60021: LD_VAR 0 2
60025: PUSH
60026: LD_VAR 0 3
60030: MINUS
60031: ST_TO_ADDR
// max_x := x + r ;
60032: LD_ADDR_VAR 0 9
60036: PUSH
60037: LD_VAR 0 1
60041: PUSH
60042: LD_VAR 0 3
60046: PLUS
60047: ST_TO_ADDR
// max_y := y + r ;
60048: LD_ADDR_VAR 0 10
60052: PUSH
60053: LD_VAR 0 2
60057: PUSH
60058: LD_VAR 0 3
60062: PLUS
60063: ST_TO_ADDR
// for _x = min_x to max_x do
60064: LD_ADDR_VAR 0 5
60068: PUSH
60069: DOUBLE
60070: LD_VAR 0 8
60074: DEC
60075: ST_TO_ADDR
60076: LD_VAR 0 9
60080: PUSH
60081: FOR_TO
60082: IFFALSE 60183
// for _y = min_y to max_y do
60084: LD_ADDR_VAR 0 6
60088: PUSH
60089: DOUBLE
60090: LD_VAR 0 7
60094: DEC
60095: ST_TO_ADDR
60096: LD_VAR 0 10
60100: PUSH
60101: FOR_TO
60102: IFFALSE 60179
// begin if not ValidHex ( _x , _y ) then
60104: LD_VAR 0 5
60108: PPUSH
60109: LD_VAR 0 6
60113: PPUSH
60114: CALL_OW 488
60118: NOT
60119: IFFALSE 60123
// continue ;
60121: GO 60101
// if GetResourceTypeXY ( _x , _y ) then
60123: LD_VAR 0 5
60127: PPUSH
60128: LD_VAR 0 6
60132: PPUSH
60133: CALL_OW 283
60137: IFFALSE 60177
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
60139: LD_ADDR_VAR 0 4
60143: PUSH
60144: LD_VAR 0 4
60148: PPUSH
60149: LD_VAR 0 4
60153: PUSH
60154: LD_INT 1
60156: PLUS
60157: PPUSH
60158: LD_VAR 0 5
60162: PUSH
60163: LD_VAR 0 6
60167: PUSH
60168: EMPTY
60169: LIST
60170: LIST
60171: PPUSH
60172: CALL_OW 1
60176: ST_TO_ADDR
// end ;
60177: GO 60101
60179: POP
60180: POP
60181: GO 60081
60183: POP
60184: POP
// end ;
60185: LD_VAR 0 4
60189: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
60190: LD_INT 0
60192: PPUSH
60193: PPUSH
60194: PPUSH
60195: PPUSH
60196: PPUSH
60197: PPUSH
60198: PPUSH
60199: PPUSH
// if not units then
60200: LD_VAR 0 1
60204: NOT
60205: IFFALSE 60209
// exit ;
60207: GO 60733
// result := UnitFilter ( units , [ f_ok ] ) ;
60209: LD_ADDR_VAR 0 3
60213: PUSH
60214: LD_VAR 0 1
60218: PPUSH
60219: LD_INT 50
60221: PUSH
60222: EMPTY
60223: LIST
60224: PPUSH
60225: CALL_OW 72
60229: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
60230: LD_ADDR_VAR 0 8
60234: PUSH
60235: LD_VAR 0 1
60239: PUSH
60240: LD_INT 1
60242: ARRAY
60243: PPUSH
60244: CALL_OW 255
60248: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
60249: LD_ADDR_VAR 0 10
60253: PUSH
60254: LD_INT 29
60256: PUSH
60257: LD_INT 91
60259: PUSH
60260: LD_INT 49
60262: PUSH
60263: EMPTY
60264: LIST
60265: LIST
60266: LIST
60267: ST_TO_ADDR
// if not result then
60268: LD_VAR 0 3
60272: NOT
60273: IFFALSE 60277
// exit ;
60275: GO 60733
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
60277: LD_ADDR_VAR 0 5
60281: PUSH
60282: LD_INT 81
60284: PUSH
60285: LD_VAR 0 8
60289: PUSH
60290: EMPTY
60291: LIST
60292: LIST
60293: PPUSH
60294: CALL_OW 69
60298: ST_TO_ADDR
// for i in result do
60299: LD_ADDR_VAR 0 4
60303: PUSH
60304: LD_VAR 0 3
60308: PUSH
60309: FOR_IN
60310: IFFALSE 60731
// begin tag := GetTag ( i ) + 1 ;
60312: LD_ADDR_VAR 0 9
60316: PUSH
60317: LD_VAR 0 4
60321: PPUSH
60322: CALL_OW 110
60326: PUSH
60327: LD_INT 1
60329: PLUS
60330: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
60331: LD_ADDR_VAR 0 7
60335: PUSH
60336: LD_VAR 0 4
60340: PPUSH
60341: CALL_OW 250
60345: PPUSH
60346: LD_VAR 0 4
60350: PPUSH
60351: CALL_OW 251
60355: PPUSH
60356: LD_INT 6
60358: PPUSH
60359: CALL 59932 0 3
60363: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
60364: LD_VAR 0 4
60368: PPUSH
60369: CALL_OW 247
60373: PUSH
60374: LD_INT 2
60376: EQUAL
60377: PUSH
60378: LD_VAR 0 7
60382: AND
60383: PUSH
60384: LD_VAR 0 4
60388: PPUSH
60389: CALL_OW 264
60393: PUSH
60394: LD_VAR 0 10
60398: IN
60399: NOT
60400: AND
60401: IFFALSE 60440
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
60403: LD_VAR 0 4
60407: PPUSH
60408: LD_VAR 0 7
60412: PUSH
60413: LD_INT 1
60415: ARRAY
60416: PUSH
60417: LD_INT 1
60419: ARRAY
60420: PPUSH
60421: LD_VAR 0 7
60425: PUSH
60426: LD_INT 1
60428: ARRAY
60429: PUSH
60430: LD_INT 2
60432: ARRAY
60433: PPUSH
60434: CALL_OW 116
60438: GO 60729
// if path > tag then
60440: LD_VAR 0 2
60444: PUSH
60445: LD_VAR 0 9
60449: GREATER
60450: IFFALSE 60658
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
60452: LD_ADDR_VAR 0 6
60456: PUSH
60457: LD_VAR 0 5
60461: PPUSH
60462: LD_INT 91
60464: PUSH
60465: LD_VAR 0 4
60469: PUSH
60470: LD_INT 8
60472: PUSH
60473: EMPTY
60474: LIST
60475: LIST
60476: LIST
60477: PPUSH
60478: CALL_OW 72
60482: ST_TO_ADDR
// if nearEnemy then
60483: LD_VAR 0 6
60487: IFFALSE 60556
// begin if GetWeapon ( i ) = ru_time_lapser then
60489: LD_VAR 0 4
60493: PPUSH
60494: CALL_OW 264
60498: PUSH
60499: LD_INT 49
60501: EQUAL
60502: IFFALSE 60530
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
60504: LD_VAR 0 4
60508: PPUSH
60509: LD_VAR 0 6
60513: PPUSH
60514: LD_VAR 0 4
60518: PPUSH
60519: CALL_OW 74
60523: PPUSH
60524: CALL_OW 112
60528: GO 60554
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
60530: LD_VAR 0 4
60534: PPUSH
60535: LD_VAR 0 6
60539: PPUSH
60540: LD_VAR 0 4
60544: PPUSH
60545: CALL_OW 74
60549: PPUSH
60550: CALL 61658 0 2
// end else
60554: GO 60656
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
60556: LD_VAR 0 4
60560: PPUSH
60561: LD_VAR 0 2
60565: PUSH
60566: LD_VAR 0 9
60570: ARRAY
60571: PUSH
60572: LD_INT 1
60574: ARRAY
60575: PPUSH
60576: LD_VAR 0 2
60580: PUSH
60581: LD_VAR 0 9
60585: ARRAY
60586: PUSH
60587: LD_INT 2
60589: ARRAY
60590: PPUSH
60591: CALL_OW 297
60595: PUSH
60596: LD_INT 6
60598: GREATER
60599: IFFALSE 60642
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
60601: LD_VAR 0 4
60605: PPUSH
60606: LD_VAR 0 2
60610: PUSH
60611: LD_VAR 0 9
60615: ARRAY
60616: PUSH
60617: LD_INT 1
60619: ARRAY
60620: PPUSH
60621: LD_VAR 0 2
60625: PUSH
60626: LD_VAR 0 9
60630: ARRAY
60631: PUSH
60632: LD_INT 2
60634: ARRAY
60635: PPUSH
60636: CALL_OW 114
60640: GO 60656
// SetTag ( i , tag ) ;
60642: LD_VAR 0 4
60646: PPUSH
60647: LD_VAR 0 9
60651: PPUSH
60652: CALL_OW 109
// end else
60656: GO 60729
// if enemy then
60658: LD_VAR 0 5
60662: IFFALSE 60729
// begin if GetWeapon ( i ) = ru_time_lapser then
60664: LD_VAR 0 4
60668: PPUSH
60669: CALL_OW 264
60673: PUSH
60674: LD_INT 49
60676: EQUAL
60677: IFFALSE 60705
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60679: LD_VAR 0 4
60683: PPUSH
60684: LD_VAR 0 5
60688: PPUSH
60689: LD_VAR 0 4
60693: PPUSH
60694: CALL_OW 74
60698: PPUSH
60699: CALL_OW 112
60703: GO 60729
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
60705: LD_VAR 0 4
60709: PPUSH
60710: LD_VAR 0 5
60714: PPUSH
60715: LD_VAR 0 4
60719: PPUSH
60720: CALL_OW 74
60724: PPUSH
60725: CALL 61658 0 2
// end ; end ;
60729: GO 60309
60731: POP
60732: POP
// end ;
60733: LD_VAR 0 3
60737: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
60738: LD_INT 0
60740: PPUSH
60741: PPUSH
60742: PPUSH
// if not unit or IsInUnit ( unit ) then
60743: LD_VAR 0 1
60747: NOT
60748: PUSH
60749: LD_VAR 0 1
60753: PPUSH
60754: CALL_OW 310
60758: OR
60759: IFFALSE 60763
// exit ;
60761: GO 60854
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
60763: LD_ADDR_VAR 0 4
60767: PUSH
60768: LD_VAR 0 1
60772: PPUSH
60773: CALL_OW 250
60777: PPUSH
60778: LD_VAR 0 2
60782: PPUSH
60783: LD_INT 1
60785: PPUSH
60786: CALL_OW 272
60790: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
60791: LD_ADDR_VAR 0 5
60795: PUSH
60796: LD_VAR 0 1
60800: PPUSH
60801: CALL_OW 251
60805: PPUSH
60806: LD_VAR 0 2
60810: PPUSH
60811: LD_INT 1
60813: PPUSH
60814: CALL_OW 273
60818: ST_TO_ADDR
// if ValidHex ( x , y ) then
60819: LD_VAR 0 4
60823: PPUSH
60824: LD_VAR 0 5
60828: PPUSH
60829: CALL_OW 488
60833: IFFALSE 60854
// ComTurnXY ( unit , x , y ) ;
60835: LD_VAR 0 1
60839: PPUSH
60840: LD_VAR 0 4
60844: PPUSH
60845: LD_VAR 0 5
60849: PPUSH
60850: CALL_OW 118
// end ;
60854: LD_VAR 0 3
60858: RET
// export function SeeUnits ( side , units ) ; var i ; begin
60859: LD_INT 0
60861: PPUSH
60862: PPUSH
// result := false ;
60863: LD_ADDR_VAR 0 3
60867: PUSH
60868: LD_INT 0
60870: ST_TO_ADDR
// if not units then
60871: LD_VAR 0 2
60875: NOT
60876: IFFALSE 60880
// exit ;
60878: GO 60925
// for i in units do
60880: LD_ADDR_VAR 0 4
60884: PUSH
60885: LD_VAR 0 2
60889: PUSH
60890: FOR_IN
60891: IFFALSE 60923
// if See ( side , i ) then
60893: LD_VAR 0 1
60897: PPUSH
60898: LD_VAR 0 4
60902: PPUSH
60903: CALL_OW 292
60907: IFFALSE 60921
// begin result := true ;
60909: LD_ADDR_VAR 0 3
60913: PUSH
60914: LD_INT 1
60916: ST_TO_ADDR
// exit ;
60917: POP
60918: POP
60919: GO 60925
// end ;
60921: GO 60890
60923: POP
60924: POP
// end ;
60925: LD_VAR 0 3
60929: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60930: LD_INT 0
60932: PPUSH
60933: PPUSH
60934: PPUSH
60935: PPUSH
// if not unit or not points then
60936: LD_VAR 0 1
60940: NOT
60941: PUSH
60942: LD_VAR 0 2
60946: NOT
60947: OR
60948: IFFALSE 60952
// exit ;
60950: GO 61042
// dist := 99999 ;
60952: LD_ADDR_VAR 0 5
60956: PUSH
60957: LD_INT 99999
60959: ST_TO_ADDR
// for i in points do
60960: LD_ADDR_VAR 0 4
60964: PUSH
60965: LD_VAR 0 2
60969: PUSH
60970: FOR_IN
60971: IFFALSE 61040
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60973: LD_ADDR_VAR 0 6
60977: PUSH
60978: LD_VAR 0 1
60982: PPUSH
60983: LD_VAR 0 4
60987: PUSH
60988: LD_INT 1
60990: ARRAY
60991: PPUSH
60992: LD_VAR 0 4
60996: PUSH
60997: LD_INT 2
60999: ARRAY
61000: PPUSH
61001: CALL_OW 297
61005: ST_TO_ADDR
// if tmpDist < dist then
61006: LD_VAR 0 6
61010: PUSH
61011: LD_VAR 0 5
61015: LESS
61016: IFFALSE 61038
// begin result := i ;
61018: LD_ADDR_VAR 0 3
61022: PUSH
61023: LD_VAR 0 4
61027: ST_TO_ADDR
// dist := tmpDist ;
61028: LD_ADDR_VAR 0 5
61032: PUSH
61033: LD_VAR 0 6
61037: ST_TO_ADDR
// end ; end ;
61038: GO 60970
61040: POP
61041: POP
// end ;
61042: LD_VAR 0 3
61046: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
61047: LD_INT 0
61049: PPUSH
// uc_side := side ;
61050: LD_ADDR_OWVAR 20
61054: PUSH
61055: LD_VAR 0 1
61059: ST_TO_ADDR
// uc_nation := 3 ;
61060: LD_ADDR_OWVAR 21
61064: PUSH
61065: LD_INT 3
61067: ST_TO_ADDR
// vc_chassis := 25 ;
61068: LD_ADDR_OWVAR 37
61072: PUSH
61073: LD_INT 25
61075: ST_TO_ADDR
// vc_engine := engine_siberite ;
61076: LD_ADDR_OWVAR 39
61080: PUSH
61081: LD_INT 3
61083: ST_TO_ADDR
// vc_control := control_computer ;
61084: LD_ADDR_OWVAR 38
61088: PUSH
61089: LD_INT 3
61091: ST_TO_ADDR
// vc_weapon := 59 ;
61092: LD_ADDR_OWVAR 40
61096: PUSH
61097: LD_INT 59
61099: ST_TO_ADDR
// result := CreateVehicle ;
61100: LD_ADDR_VAR 0 5
61104: PUSH
61105: CALL_OW 45
61109: ST_TO_ADDR
// SetDir ( result , d ) ;
61110: LD_VAR 0 5
61114: PPUSH
61115: LD_VAR 0 4
61119: PPUSH
61120: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
61124: LD_VAR 0 5
61128: PPUSH
61129: LD_VAR 0 2
61133: PPUSH
61134: LD_VAR 0 3
61138: PPUSH
61139: LD_INT 0
61141: PPUSH
61142: CALL_OW 48
// end ;
61146: LD_VAR 0 5
61150: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
61151: LD_INT 0
61153: PPUSH
61154: PPUSH
61155: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
61156: LD_ADDR_VAR 0 2
61160: PUSH
61161: LD_INT 0
61163: PUSH
61164: LD_INT 0
61166: PUSH
61167: LD_INT 0
61169: PUSH
61170: LD_INT 0
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: LIST
61177: LIST
61178: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
61179: LD_VAR 0 1
61183: NOT
61184: PUSH
61185: LD_VAR 0 1
61189: PPUSH
61190: CALL_OW 264
61194: PUSH
61195: LD_INT 12
61197: PUSH
61198: LD_INT 51
61200: PUSH
61201: LD_INT 32
61203: PUSH
61204: LD_INT 89
61206: PUSH
61207: EMPTY
61208: LIST
61209: LIST
61210: LIST
61211: LIST
61212: IN
61213: NOT
61214: OR
61215: IFFALSE 61219
// exit ;
61217: GO 61317
// for i := 1 to 3 do
61219: LD_ADDR_VAR 0 3
61223: PUSH
61224: DOUBLE
61225: LD_INT 1
61227: DEC
61228: ST_TO_ADDR
61229: LD_INT 3
61231: PUSH
61232: FOR_TO
61233: IFFALSE 61315
// begin tmp := GetCargo ( cargo , i ) ;
61235: LD_ADDR_VAR 0 4
61239: PUSH
61240: LD_VAR 0 1
61244: PPUSH
61245: LD_VAR 0 3
61249: PPUSH
61250: CALL_OW 289
61254: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
61255: LD_ADDR_VAR 0 2
61259: PUSH
61260: LD_VAR 0 2
61264: PPUSH
61265: LD_VAR 0 3
61269: PPUSH
61270: LD_VAR 0 4
61274: PPUSH
61275: CALL_OW 1
61279: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
61280: LD_ADDR_VAR 0 2
61284: PUSH
61285: LD_VAR 0 2
61289: PPUSH
61290: LD_INT 4
61292: PPUSH
61293: LD_VAR 0 2
61297: PUSH
61298: LD_INT 4
61300: ARRAY
61301: PUSH
61302: LD_VAR 0 4
61306: PLUS
61307: PPUSH
61308: CALL_OW 1
61312: ST_TO_ADDR
// end ;
61313: GO 61232
61315: POP
61316: POP
// end ;
61317: LD_VAR 0 2
61321: RET
// export function Length ( array ) ; begin
61322: LD_INT 0
61324: PPUSH
// result := array + 0 ;
61325: LD_ADDR_VAR 0 2
61329: PUSH
61330: LD_VAR 0 1
61334: PUSH
61335: LD_INT 0
61337: PLUS
61338: ST_TO_ADDR
// end ;
61339: LD_VAR 0 2
61343: RET
// export function PrepareArray ( array ) ; begin
61344: LD_INT 0
61346: PPUSH
// result := array diff 0 ;
61347: LD_ADDR_VAR 0 2
61351: PUSH
61352: LD_VAR 0 1
61356: PUSH
61357: LD_INT 0
61359: DIFF
61360: ST_TO_ADDR
// if not result [ 1 ] then
61361: LD_VAR 0 2
61365: PUSH
61366: LD_INT 1
61368: ARRAY
61369: NOT
61370: IFFALSE 61390
// result := Delete ( result , 1 ) ;
61372: LD_ADDR_VAR 0 2
61376: PUSH
61377: LD_VAR 0 2
61381: PPUSH
61382: LD_INT 1
61384: PPUSH
61385: CALL_OW 3
61389: ST_TO_ADDR
// end ;
61390: LD_VAR 0 2
61394: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
61395: LD_INT 0
61397: PPUSH
61398: PPUSH
61399: PPUSH
61400: PPUSH
// sibRocketRange := 25 ;
61401: LD_ADDR_VAR 0 6
61405: PUSH
61406: LD_INT 25
61408: ST_TO_ADDR
// result := false ;
61409: LD_ADDR_VAR 0 4
61413: PUSH
61414: LD_INT 0
61416: ST_TO_ADDR
// for i := 0 to 5 do
61417: LD_ADDR_VAR 0 5
61421: PUSH
61422: DOUBLE
61423: LD_INT 0
61425: DEC
61426: ST_TO_ADDR
61427: LD_INT 5
61429: PUSH
61430: FOR_TO
61431: IFFALSE 61498
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
61433: LD_VAR 0 1
61437: PPUSH
61438: LD_VAR 0 5
61442: PPUSH
61443: LD_VAR 0 6
61447: PPUSH
61448: CALL_OW 272
61452: PPUSH
61453: LD_VAR 0 2
61457: PPUSH
61458: LD_VAR 0 5
61462: PPUSH
61463: LD_VAR 0 6
61467: PPUSH
61468: CALL_OW 273
61472: PPUSH
61473: LD_VAR 0 3
61477: PPUSH
61478: CALL_OW 309
61482: IFFALSE 61496
// begin result := true ;
61484: LD_ADDR_VAR 0 4
61488: PUSH
61489: LD_INT 1
61491: ST_TO_ADDR
// exit ;
61492: POP
61493: POP
61494: GO 61500
// end ;
61496: GO 61430
61498: POP
61499: POP
// end ;
61500: LD_VAR 0 4
61504: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
61505: LD_INT 0
61507: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
61508: LD_VAR 0 1
61512: PPUSH
61513: LD_VAR 0 2
61517: PPUSH
61518: LD_INT 0
61520: PPUSH
61521: LD_INT 0
61523: PPUSH
61524: LD_INT 1
61526: PPUSH
61527: LD_INT 0
61529: PPUSH
61530: CALL_OW 587
// end ;
61534: LD_VAR 0 3
61538: RET
// export function CenterOnNow ( unit ) ; begin
61539: LD_INT 0
61541: PPUSH
// result := IsInUnit ( unit ) ;
61542: LD_ADDR_VAR 0 2
61546: PUSH
61547: LD_VAR 0 1
61551: PPUSH
61552: CALL_OW 310
61556: ST_TO_ADDR
// if not result then
61557: LD_VAR 0 2
61561: NOT
61562: IFFALSE 61574
// result := unit ;
61564: LD_ADDR_VAR 0 2
61568: PUSH
61569: LD_VAR 0 1
61573: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
61574: LD_VAR 0 1
61578: PPUSH
61579: CALL_OW 87
// end ;
61583: LD_VAR 0 2
61587: RET
// export function ComMoveHex ( unit , hex ) ; begin
61588: LD_INT 0
61590: PPUSH
// if not hex then
61591: LD_VAR 0 2
61595: NOT
61596: IFFALSE 61600
// exit ;
61598: GO 61653
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
61600: LD_VAR 0 2
61604: PUSH
61605: LD_INT 1
61607: ARRAY
61608: PPUSH
61609: LD_VAR 0 2
61613: PUSH
61614: LD_INT 2
61616: ARRAY
61617: PPUSH
61618: CALL_OW 428
61622: IFFALSE 61626
// exit ;
61624: GO 61653
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
61626: LD_VAR 0 1
61630: PPUSH
61631: LD_VAR 0 2
61635: PUSH
61636: LD_INT 1
61638: ARRAY
61639: PPUSH
61640: LD_VAR 0 2
61644: PUSH
61645: LD_INT 2
61647: ARRAY
61648: PPUSH
61649: CALL_OW 111
// end ;
61653: LD_VAR 0 3
61657: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
61658: LD_INT 0
61660: PPUSH
61661: PPUSH
61662: PPUSH
// if not unit or not enemy then
61663: LD_VAR 0 1
61667: NOT
61668: PUSH
61669: LD_VAR 0 2
61673: NOT
61674: OR
61675: IFFALSE 61679
// exit ;
61677: GO 61803
// x := GetX ( enemy ) ;
61679: LD_ADDR_VAR 0 4
61683: PUSH
61684: LD_VAR 0 2
61688: PPUSH
61689: CALL_OW 250
61693: ST_TO_ADDR
// y := GetY ( enemy ) ;
61694: LD_ADDR_VAR 0 5
61698: PUSH
61699: LD_VAR 0 2
61703: PPUSH
61704: CALL_OW 251
61708: ST_TO_ADDR
// if ValidHex ( x , y ) then
61709: LD_VAR 0 4
61713: PPUSH
61714: LD_VAR 0 5
61718: PPUSH
61719: CALL_OW 488
61723: IFFALSE 61803
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
61725: LD_VAR 0 2
61729: PPUSH
61730: CALL_OW 247
61734: PUSH
61735: LD_INT 3
61737: PUSH
61738: LD_INT 2
61740: PUSH
61741: EMPTY
61742: LIST
61743: LIST
61744: IN
61745: PUSH
61746: LD_VAR 0 1
61750: PPUSH
61751: CALL_OW 255
61755: PPUSH
61756: LD_VAR 0 2
61760: PPUSH
61761: CALL_OW 292
61765: AND
61766: IFFALSE 61784
// ComAttackUnit ( unit , enemy ) else
61768: LD_VAR 0 1
61772: PPUSH
61773: LD_VAR 0 2
61777: PPUSH
61778: CALL_OW 115
61782: GO 61803
// ComAgressiveMove ( unit , x , y ) ;
61784: LD_VAR 0 1
61788: PPUSH
61789: LD_VAR 0 4
61793: PPUSH
61794: LD_VAR 0 5
61798: PPUSH
61799: CALL_OW 114
// end ; end_of_file
61803: LD_VAR 0 3
61807: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
61808: LD_INT 0
61810: PPUSH
61811: PPUSH
// skirmish := false ;
61812: LD_ADDR_EXP 29
61816: PUSH
61817: LD_INT 0
61819: ST_TO_ADDR
// debug_mc := false ;
61820: LD_ADDR_EXP 30
61824: PUSH
61825: LD_INT 0
61827: ST_TO_ADDR
// mc_bases := [ ] ;
61828: LD_ADDR_EXP 31
61832: PUSH
61833: EMPTY
61834: ST_TO_ADDR
// mc_sides := [ ] ;
61835: LD_ADDR_EXP 57
61839: PUSH
61840: EMPTY
61841: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61842: LD_ADDR_EXP 32
61846: PUSH
61847: EMPTY
61848: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61849: LD_ADDR_EXP 33
61853: PUSH
61854: EMPTY
61855: ST_TO_ADDR
// mc_need_heal := [ ] ;
61856: LD_ADDR_EXP 34
61860: PUSH
61861: EMPTY
61862: ST_TO_ADDR
// mc_healers := [ ] ;
61863: LD_ADDR_EXP 35
61867: PUSH
61868: EMPTY
61869: ST_TO_ADDR
// mc_build_list := [ ] ;
61870: LD_ADDR_EXP 36
61874: PUSH
61875: EMPTY
61876: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61877: LD_ADDR_EXP 63
61881: PUSH
61882: EMPTY
61883: ST_TO_ADDR
// mc_builders := [ ] ;
61884: LD_ADDR_EXP 37
61888: PUSH
61889: EMPTY
61890: ST_TO_ADDR
// mc_construct_list := [ ] ;
61891: LD_ADDR_EXP 38
61895: PUSH
61896: EMPTY
61897: ST_TO_ADDR
// mc_turret_list := [ ] ;
61898: LD_ADDR_EXP 39
61902: PUSH
61903: EMPTY
61904: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61905: LD_ADDR_EXP 40
61909: PUSH
61910: EMPTY
61911: ST_TO_ADDR
// mc_miners := [ ] ;
61912: LD_ADDR_EXP 45
61916: PUSH
61917: EMPTY
61918: ST_TO_ADDR
// mc_mines := [ ] ;
61919: LD_ADDR_EXP 44
61923: PUSH
61924: EMPTY
61925: ST_TO_ADDR
// mc_minefields := [ ] ;
61926: LD_ADDR_EXP 46
61930: PUSH
61931: EMPTY
61932: ST_TO_ADDR
// mc_crates := [ ] ;
61933: LD_ADDR_EXP 47
61937: PUSH
61938: EMPTY
61939: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61940: LD_ADDR_EXP 48
61944: PUSH
61945: EMPTY
61946: ST_TO_ADDR
// mc_crates_area := [ ] ;
61947: LD_ADDR_EXP 49
61951: PUSH
61952: EMPTY
61953: ST_TO_ADDR
// mc_vehicles := [ ] ;
61954: LD_ADDR_EXP 50
61958: PUSH
61959: EMPTY
61960: ST_TO_ADDR
// mc_attack := [ ] ;
61961: LD_ADDR_EXP 51
61965: PUSH
61966: EMPTY
61967: ST_TO_ADDR
// mc_produce := [ ] ;
61968: LD_ADDR_EXP 52
61972: PUSH
61973: EMPTY
61974: ST_TO_ADDR
// mc_defender := [ ] ;
61975: LD_ADDR_EXP 53
61979: PUSH
61980: EMPTY
61981: ST_TO_ADDR
// mc_parking := [ ] ;
61982: LD_ADDR_EXP 55
61986: PUSH
61987: EMPTY
61988: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61989: LD_ADDR_EXP 41
61993: PUSH
61994: EMPTY
61995: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61996: LD_ADDR_EXP 43
62000: PUSH
62001: EMPTY
62002: ST_TO_ADDR
// mc_scan := [ ] ;
62003: LD_ADDR_EXP 54
62007: PUSH
62008: EMPTY
62009: ST_TO_ADDR
// mc_scan_area := [ ] ;
62010: LD_ADDR_EXP 56
62014: PUSH
62015: EMPTY
62016: ST_TO_ADDR
// mc_tech := [ ] ;
62017: LD_ADDR_EXP 58
62021: PUSH
62022: EMPTY
62023: ST_TO_ADDR
// mc_class := [ ] ;
62024: LD_ADDR_EXP 72
62028: PUSH
62029: EMPTY
62030: ST_TO_ADDR
// mc_class_case_use := [ ] ;
62031: LD_ADDR_EXP 73
62035: PUSH
62036: EMPTY
62037: ST_TO_ADDR
// mc_is_defending := [ ] ;
62038: LD_ADDR_EXP 74
62042: PUSH
62043: EMPTY
62044: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
62045: LD_ADDR_EXP 65
62049: PUSH
62050: EMPTY
62051: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
62052: LD_ADDR_EXP 75
62056: PUSH
62057: LD_INT 0
62059: ST_TO_ADDR
// end ;
62060: LD_VAR 0 1
62064: RET
// export function MC_Kill ( base ) ; begin
62065: LD_INT 0
62067: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
62068: LD_ADDR_EXP 31
62072: PUSH
62073: LD_EXP 31
62077: PPUSH
62078: LD_VAR 0 1
62082: PPUSH
62083: EMPTY
62084: PPUSH
62085: CALL_OW 1
62089: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62090: LD_ADDR_EXP 32
62094: PUSH
62095: LD_EXP 32
62099: PPUSH
62100: LD_VAR 0 1
62104: PPUSH
62105: EMPTY
62106: PPUSH
62107: CALL_OW 1
62111: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62112: LD_ADDR_EXP 33
62116: PUSH
62117: LD_EXP 33
62121: PPUSH
62122: LD_VAR 0 1
62126: PPUSH
62127: EMPTY
62128: PPUSH
62129: CALL_OW 1
62133: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62134: LD_ADDR_EXP 34
62138: PUSH
62139: LD_EXP 34
62143: PPUSH
62144: LD_VAR 0 1
62148: PPUSH
62149: EMPTY
62150: PPUSH
62151: CALL_OW 1
62155: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62156: LD_ADDR_EXP 35
62160: PUSH
62161: LD_EXP 35
62165: PPUSH
62166: LD_VAR 0 1
62170: PPUSH
62171: EMPTY
62172: PPUSH
62173: CALL_OW 1
62177: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62178: LD_ADDR_EXP 36
62182: PUSH
62183: LD_EXP 36
62187: PPUSH
62188: LD_VAR 0 1
62192: PPUSH
62193: EMPTY
62194: PPUSH
62195: CALL_OW 1
62199: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62200: LD_ADDR_EXP 37
62204: PUSH
62205: LD_EXP 37
62209: PPUSH
62210: LD_VAR 0 1
62214: PPUSH
62215: EMPTY
62216: PPUSH
62217: CALL_OW 1
62221: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62222: LD_ADDR_EXP 38
62226: PUSH
62227: LD_EXP 38
62231: PPUSH
62232: LD_VAR 0 1
62236: PPUSH
62237: EMPTY
62238: PPUSH
62239: CALL_OW 1
62243: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62244: LD_ADDR_EXP 39
62248: PUSH
62249: LD_EXP 39
62253: PPUSH
62254: LD_VAR 0 1
62258: PPUSH
62259: EMPTY
62260: PPUSH
62261: CALL_OW 1
62265: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62266: LD_ADDR_EXP 40
62270: PUSH
62271: LD_EXP 40
62275: PPUSH
62276: LD_VAR 0 1
62280: PPUSH
62281: EMPTY
62282: PPUSH
62283: CALL_OW 1
62287: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62288: LD_ADDR_EXP 41
62292: PUSH
62293: LD_EXP 41
62297: PPUSH
62298: LD_VAR 0 1
62302: PPUSH
62303: EMPTY
62304: PPUSH
62305: CALL_OW 1
62309: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62310: LD_ADDR_EXP 42
62314: PUSH
62315: LD_EXP 42
62319: PPUSH
62320: LD_VAR 0 1
62324: PPUSH
62325: LD_INT 0
62327: PPUSH
62328: CALL_OW 1
62332: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62333: LD_ADDR_EXP 43
62337: PUSH
62338: LD_EXP 43
62342: PPUSH
62343: LD_VAR 0 1
62347: PPUSH
62348: EMPTY
62349: PPUSH
62350: CALL_OW 1
62354: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62355: LD_ADDR_EXP 44
62359: PUSH
62360: LD_EXP 44
62364: PPUSH
62365: LD_VAR 0 1
62369: PPUSH
62370: EMPTY
62371: PPUSH
62372: CALL_OW 1
62376: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62377: LD_ADDR_EXP 45
62381: PUSH
62382: LD_EXP 45
62386: PPUSH
62387: LD_VAR 0 1
62391: PPUSH
62392: EMPTY
62393: PPUSH
62394: CALL_OW 1
62398: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62399: LD_ADDR_EXP 46
62403: PUSH
62404: LD_EXP 46
62408: PPUSH
62409: LD_VAR 0 1
62413: PPUSH
62414: EMPTY
62415: PPUSH
62416: CALL_OW 1
62420: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62421: LD_ADDR_EXP 47
62425: PUSH
62426: LD_EXP 47
62430: PPUSH
62431: LD_VAR 0 1
62435: PPUSH
62436: EMPTY
62437: PPUSH
62438: CALL_OW 1
62442: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62443: LD_ADDR_EXP 48
62447: PUSH
62448: LD_EXP 48
62452: PPUSH
62453: LD_VAR 0 1
62457: PPUSH
62458: EMPTY
62459: PPUSH
62460: CALL_OW 1
62464: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62465: LD_ADDR_EXP 49
62469: PUSH
62470: LD_EXP 49
62474: PPUSH
62475: LD_VAR 0 1
62479: PPUSH
62480: EMPTY
62481: PPUSH
62482: CALL_OW 1
62486: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62487: LD_ADDR_EXP 50
62491: PUSH
62492: LD_EXP 50
62496: PPUSH
62497: LD_VAR 0 1
62501: PPUSH
62502: EMPTY
62503: PPUSH
62504: CALL_OW 1
62508: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62509: LD_ADDR_EXP 51
62513: PUSH
62514: LD_EXP 51
62518: PPUSH
62519: LD_VAR 0 1
62523: PPUSH
62524: EMPTY
62525: PPUSH
62526: CALL_OW 1
62530: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62531: LD_ADDR_EXP 52
62535: PUSH
62536: LD_EXP 52
62540: PPUSH
62541: LD_VAR 0 1
62545: PPUSH
62546: EMPTY
62547: PPUSH
62548: CALL_OW 1
62552: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62553: LD_ADDR_EXP 53
62557: PUSH
62558: LD_EXP 53
62562: PPUSH
62563: LD_VAR 0 1
62567: PPUSH
62568: EMPTY
62569: PPUSH
62570: CALL_OW 1
62574: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62575: LD_ADDR_EXP 54
62579: PUSH
62580: LD_EXP 54
62584: PPUSH
62585: LD_VAR 0 1
62589: PPUSH
62590: EMPTY
62591: PPUSH
62592: CALL_OW 1
62596: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62597: LD_ADDR_EXP 55
62601: PUSH
62602: LD_EXP 55
62606: PPUSH
62607: LD_VAR 0 1
62611: PPUSH
62612: EMPTY
62613: PPUSH
62614: CALL_OW 1
62618: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62619: LD_ADDR_EXP 56
62623: PUSH
62624: LD_EXP 56
62628: PPUSH
62629: LD_VAR 0 1
62633: PPUSH
62634: EMPTY
62635: PPUSH
62636: CALL_OW 1
62640: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62641: LD_ADDR_EXP 58
62645: PUSH
62646: LD_EXP 58
62650: PPUSH
62651: LD_VAR 0 1
62655: PPUSH
62656: EMPTY
62657: PPUSH
62658: CALL_OW 1
62662: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62663: LD_ADDR_EXP 60
62667: PUSH
62668: LD_EXP 60
62672: PPUSH
62673: LD_VAR 0 1
62677: PPUSH
62678: EMPTY
62679: PPUSH
62680: CALL_OW 1
62684: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62685: LD_ADDR_EXP 61
62689: PUSH
62690: LD_EXP 61
62694: PPUSH
62695: LD_VAR 0 1
62699: PPUSH
62700: EMPTY
62701: PPUSH
62702: CALL_OW 1
62706: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62707: LD_ADDR_EXP 62
62711: PUSH
62712: LD_EXP 62
62716: PPUSH
62717: LD_VAR 0 1
62721: PPUSH
62722: EMPTY
62723: PPUSH
62724: CALL_OW 1
62728: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62729: LD_ADDR_EXP 63
62733: PUSH
62734: LD_EXP 63
62738: PPUSH
62739: LD_VAR 0 1
62743: PPUSH
62744: EMPTY
62745: PPUSH
62746: CALL_OW 1
62750: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62751: LD_ADDR_EXP 64
62755: PUSH
62756: LD_EXP 64
62760: PPUSH
62761: LD_VAR 0 1
62765: PPUSH
62766: EMPTY
62767: PPUSH
62768: CALL_OW 1
62772: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62773: LD_ADDR_EXP 65
62777: PUSH
62778: LD_EXP 65
62782: PPUSH
62783: LD_VAR 0 1
62787: PPUSH
62788: EMPTY
62789: PPUSH
62790: CALL_OW 1
62794: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62795: LD_ADDR_EXP 66
62799: PUSH
62800: LD_EXP 66
62804: PPUSH
62805: LD_VAR 0 1
62809: PPUSH
62810: EMPTY
62811: PPUSH
62812: CALL_OW 1
62816: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62817: LD_ADDR_EXP 67
62821: PUSH
62822: LD_EXP 67
62826: PPUSH
62827: LD_VAR 0 1
62831: PPUSH
62832: EMPTY
62833: PPUSH
62834: CALL_OW 1
62838: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62839: LD_ADDR_EXP 68
62843: PUSH
62844: LD_EXP 68
62848: PPUSH
62849: LD_VAR 0 1
62853: PPUSH
62854: EMPTY
62855: PPUSH
62856: CALL_OW 1
62860: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62861: LD_ADDR_EXP 69
62865: PUSH
62866: LD_EXP 69
62870: PPUSH
62871: LD_VAR 0 1
62875: PPUSH
62876: EMPTY
62877: PPUSH
62878: CALL_OW 1
62882: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62883: LD_ADDR_EXP 70
62887: PUSH
62888: LD_EXP 70
62892: PPUSH
62893: LD_VAR 0 1
62897: PPUSH
62898: EMPTY
62899: PPUSH
62900: CALL_OW 1
62904: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62905: LD_ADDR_EXP 71
62909: PUSH
62910: LD_EXP 71
62914: PPUSH
62915: LD_VAR 0 1
62919: PPUSH
62920: EMPTY
62921: PPUSH
62922: CALL_OW 1
62926: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62927: LD_ADDR_EXP 72
62931: PUSH
62932: LD_EXP 72
62936: PPUSH
62937: LD_VAR 0 1
62941: PPUSH
62942: EMPTY
62943: PPUSH
62944: CALL_OW 1
62948: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62949: LD_ADDR_EXP 73
62953: PUSH
62954: LD_EXP 73
62958: PPUSH
62959: LD_VAR 0 1
62963: PPUSH
62964: LD_INT 0
62966: PPUSH
62967: CALL_OW 1
62971: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62972: LD_ADDR_EXP 74
62976: PUSH
62977: LD_EXP 74
62981: PPUSH
62982: LD_VAR 0 1
62986: PPUSH
62987: LD_INT 0
62989: PPUSH
62990: CALL_OW 1
62994: ST_TO_ADDR
// end ;
62995: LD_VAR 0 2
62999: RET
// export function MC_Add ( side , units ) ; var base ; begin
63000: LD_INT 0
63002: PPUSH
63003: PPUSH
// base := mc_bases + 1 ;
63004: LD_ADDR_VAR 0 4
63008: PUSH
63009: LD_EXP 31
63013: PUSH
63014: LD_INT 1
63016: PLUS
63017: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
63018: LD_ADDR_EXP 57
63022: PUSH
63023: LD_EXP 57
63027: PPUSH
63028: LD_VAR 0 4
63032: PPUSH
63033: LD_VAR 0 1
63037: PPUSH
63038: CALL_OW 1
63042: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
63043: LD_ADDR_EXP 31
63047: PUSH
63048: LD_EXP 31
63052: PPUSH
63053: LD_VAR 0 4
63057: PPUSH
63058: LD_VAR 0 2
63062: PPUSH
63063: CALL_OW 1
63067: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
63068: LD_ADDR_EXP 32
63072: PUSH
63073: LD_EXP 32
63077: PPUSH
63078: LD_VAR 0 4
63082: PPUSH
63083: EMPTY
63084: PPUSH
63085: CALL_OW 1
63089: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
63090: LD_ADDR_EXP 33
63094: PUSH
63095: LD_EXP 33
63099: PPUSH
63100: LD_VAR 0 4
63104: PPUSH
63105: EMPTY
63106: PPUSH
63107: CALL_OW 1
63111: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
63112: LD_ADDR_EXP 34
63116: PUSH
63117: LD_EXP 34
63121: PPUSH
63122: LD_VAR 0 4
63126: PPUSH
63127: EMPTY
63128: PPUSH
63129: CALL_OW 1
63133: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
63134: LD_ADDR_EXP 35
63138: PUSH
63139: LD_EXP 35
63143: PPUSH
63144: LD_VAR 0 4
63148: PPUSH
63149: EMPTY
63150: PPUSH
63151: CALL_OW 1
63155: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
63156: LD_ADDR_EXP 36
63160: PUSH
63161: LD_EXP 36
63165: PPUSH
63166: LD_VAR 0 4
63170: PPUSH
63171: EMPTY
63172: PPUSH
63173: CALL_OW 1
63177: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
63178: LD_ADDR_EXP 37
63182: PUSH
63183: LD_EXP 37
63187: PPUSH
63188: LD_VAR 0 4
63192: PPUSH
63193: EMPTY
63194: PPUSH
63195: CALL_OW 1
63199: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
63200: LD_ADDR_EXP 38
63204: PUSH
63205: LD_EXP 38
63209: PPUSH
63210: LD_VAR 0 4
63214: PPUSH
63215: EMPTY
63216: PPUSH
63217: CALL_OW 1
63221: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
63222: LD_ADDR_EXP 39
63226: PUSH
63227: LD_EXP 39
63231: PPUSH
63232: LD_VAR 0 4
63236: PPUSH
63237: EMPTY
63238: PPUSH
63239: CALL_OW 1
63243: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
63244: LD_ADDR_EXP 40
63248: PUSH
63249: LD_EXP 40
63253: PPUSH
63254: LD_VAR 0 4
63258: PPUSH
63259: EMPTY
63260: PPUSH
63261: CALL_OW 1
63265: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
63266: LD_ADDR_EXP 41
63270: PUSH
63271: LD_EXP 41
63275: PPUSH
63276: LD_VAR 0 4
63280: PPUSH
63281: EMPTY
63282: PPUSH
63283: CALL_OW 1
63287: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
63288: LD_ADDR_EXP 42
63292: PUSH
63293: LD_EXP 42
63297: PPUSH
63298: LD_VAR 0 4
63302: PPUSH
63303: LD_INT 0
63305: PPUSH
63306: CALL_OW 1
63310: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
63311: LD_ADDR_EXP 43
63315: PUSH
63316: LD_EXP 43
63320: PPUSH
63321: LD_VAR 0 4
63325: PPUSH
63326: EMPTY
63327: PPUSH
63328: CALL_OW 1
63332: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
63333: LD_ADDR_EXP 44
63337: PUSH
63338: LD_EXP 44
63342: PPUSH
63343: LD_VAR 0 4
63347: PPUSH
63348: EMPTY
63349: PPUSH
63350: CALL_OW 1
63354: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
63355: LD_ADDR_EXP 45
63359: PUSH
63360: LD_EXP 45
63364: PPUSH
63365: LD_VAR 0 4
63369: PPUSH
63370: EMPTY
63371: PPUSH
63372: CALL_OW 1
63376: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
63377: LD_ADDR_EXP 46
63381: PUSH
63382: LD_EXP 46
63386: PPUSH
63387: LD_VAR 0 4
63391: PPUSH
63392: EMPTY
63393: PPUSH
63394: CALL_OW 1
63398: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
63399: LD_ADDR_EXP 47
63403: PUSH
63404: LD_EXP 47
63408: PPUSH
63409: LD_VAR 0 4
63413: PPUSH
63414: EMPTY
63415: PPUSH
63416: CALL_OW 1
63420: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
63421: LD_ADDR_EXP 48
63425: PUSH
63426: LD_EXP 48
63430: PPUSH
63431: LD_VAR 0 4
63435: PPUSH
63436: EMPTY
63437: PPUSH
63438: CALL_OW 1
63442: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
63443: LD_ADDR_EXP 49
63447: PUSH
63448: LD_EXP 49
63452: PPUSH
63453: LD_VAR 0 4
63457: PPUSH
63458: EMPTY
63459: PPUSH
63460: CALL_OW 1
63464: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
63465: LD_ADDR_EXP 50
63469: PUSH
63470: LD_EXP 50
63474: PPUSH
63475: LD_VAR 0 4
63479: PPUSH
63480: EMPTY
63481: PPUSH
63482: CALL_OW 1
63486: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
63487: LD_ADDR_EXP 51
63491: PUSH
63492: LD_EXP 51
63496: PPUSH
63497: LD_VAR 0 4
63501: PPUSH
63502: EMPTY
63503: PPUSH
63504: CALL_OW 1
63508: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
63509: LD_ADDR_EXP 52
63513: PUSH
63514: LD_EXP 52
63518: PPUSH
63519: LD_VAR 0 4
63523: PPUSH
63524: EMPTY
63525: PPUSH
63526: CALL_OW 1
63530: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
63531: LD_ADDR_EXP 53
63535: PUSH
63536: LD_EXP 53
63540: PPUSH
63541: LD_VAR 0 4
63545: PPUSH
63546: EMPTY
63547: PPUSH
63548: CALL_OW 1
63552: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
63553: LD_ADDR_EXP 54
63557: PUSH
63558: LD_EXP 54
63562: PPUSH
63563: LD_VAR 0 4
63567: PPUSH
63568: EMPTY
63569: PPUSH
63570: CALL_OW 1
63574: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63575: LD_ADDR_EXP 55
63579: PUSH
63580: LD_EXP 55
63584: PPUSH
63585: LD_VAR 0 4
63589: PPUSH
63590: EMPTY
63591: PPUSH
63592: CALL_OW 1
63596: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63597: LD_ADDR_EXP 56
63601: PUSH
63602: LD_EXP 56
63606: PPUSH
63607: LD_VAR 0 4
63611: PPUSH
63612: EMPTY
63613: PPUSH
63614: CALL_OW 1
63618: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63619: LD_ADDR_EXP 58
63623: PUSH
63624: LD_EXP 58
63628: PPUSH
63629: LD_VAR 0 4
63633: PPUSH
63634: EMPTY
63635: PPUSH
63636: CALL_OW 1
63640: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63641: LD_ADDR_EXP 60
63645: PUSH
63646: LD_EXP 60
63650: PPUSH
63651: LD_VAR 0 4
63655: PPUSH
63656: EMPTY
63657: PPUSH
63658: CALL_OW 1
63662: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63663: LD_ADDR_EXP 61
63667: PUSH
63668: LD_EXP 61
63672: PPUSH
63673: LD_VAR 0 4
63677: PPUSH
63678: EMPTY
63679: PPUSH
63680: CALL_OW 1
63684: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63685: LD_ADDR_EXP 62
63689: PUSH
63690: LD_EXP 62
63694: PPUSH
63695: LD_VAR 0 4
63699: PPUSH
63700: EMPTY
63701: PPUSH
63702: CALL_OW 1
63706: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63707: LD_ADDR_EXP 63
63711: PUSH
63712: LD_EXP 63
63716: PPUSH
63717: LD_VAR 0 4
63721: PPUSH
63722: EMPTY
63723: PPUSH
63724: CALL_OW 1
63728: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63729: LD_ADDR_EXP 64
63733: PUSH
63734: LD_EXP 64
63738: PPUSH
63739: LD_VAR 0 4
63743: PPUSH
63744: EMPTY
63745: PPUSH
63746: CALL_OW 1
63750: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63751: LD_ADDR_EXP 65
63755: PUSH
63756: LD_EXP 65
63760: PPUSH
63761: LD_VAR 0 4
63765: PPUSH
63766: EMPTY
63767: PPUSH
63768: CALL_OW 1
63772: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63773: LD_ADDR_EXP 66
63777: PUSH
63778: LD_EXP 66
63782: PPUSH
63783: LD_VAR 0 4
63787: PPUSH
63788: EMPTY
63789: PPUSH
63790: CALL_OW 1
63794: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63795: LD_ADDR_EXP 67
63799: PUSH
63800: LD_EXP 67
63804: PPUSH
63805: LD_VAR 0 4
63809: PPUSH
63810: EMPTY
63811: PPUSH
63812: CALL_OW 1
63816: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63817: LD_ADDR_EXP 68
63821: PUSH
63822: LD_EXP 68
63826: PPUSH
63827: LD_VAR 0 4
63831: PPUSH
63832: EMPTY
63833: PPUSH
63834: CALL_OW 1
63838: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63839: LD_ADDR_EXP 69
63843: PUSH
63844: LD_EXP 69
63848: PPUSH
63849: LD_VAR 0 4
63853: PPUSH
63854: EMPTY
63855: PPUSH
63856: CALL_OW 1
63860: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63861: LD_ADDR_EXP 70
63865: PUSH
63866: LD_EXP 70
63870: PPUSH
63871: LD_VAR 0 4
63875: PPUSH
63876: EMPTY
63877: PPUSH
63878: CALL_OW 1
63882: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63883: LD_ADDR_EXP 71
63887: PUSH
63888: LD_EXP 71
63892: PPUSH
63893: LD_VAR 0 4
63897: PPUSH
63898: EMPTY
63899: PPUSH
63900: CALL_OW 1
63904: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63905: LD_ADDR_EXP 72
63909: PUSH
63910: LD_EXP 72
63914: PPUSH
63915: LD_VAR 0 4
63919: PPUSH
63920: EMPTY
63921: PPUSH
63922: CALL_OW 1
63926: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63927: LD_ADDR_EXP 73
63931: PUSH
63932: LD_EXP 73
63936: PPUSH
63937: LD_VAR 0 4
63941: PPUSH
63942: LD_INT 0
63944: PPUSH
63945: CALL_OW 1
63949: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63950: LD_ADDR_EXP 74
63954: PUSH
63955: LD_EXP 74
63959: PPUSH
63960: LD_VAR 0 4
63964: PPUSH
63965: LD_INT 0
63967: PPUSH
63968: CALL_OW 1
63972: ST_TO_ADDR
// result := base ;
63973: LD_ADDR_VAR 0 3
63977: PUSH
63978: LD_VAR 0 4
63982: ST_TO_ADDR
// end ;
63983: LD_VAR 0 3
63987: RET
// export function MC_Start ( ) ; var i ; begin
63988: LD_INT 0
63990: PPUSH
63991: PPUSH
// for i = 1 to mc_bases do
63992: LD_ADDR_VAR 0 2
63996: PUSH
63997: DOUBLE
63998: LD_INT 1
64000: DEC
64001: ST_TO_ADDR
64002: LD_EXP 31
64006: PUSH
64007: FOR_TO
64008: IFFALSE 65108
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
64010: LD_ADDR_EXP 31
64014: PUSH
64015: LD_EXP 31
64019: PPUSH
64020: LD_VAR 0 2
64024: PPUSH
64025: LD_EXP 31
64029: PUSH
64030: LD_VAR 0 2
64034: ARRAY
64035: PUSH
64036: LD_INT 0
64038: DIFF
64039: PPUSH
64040: CALL_OW 1
64044: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
64045: LD_ADDR_EXP 32
64049: PUSH
64050: LD_EXP 32
64054: PPUSH
64055: LD_VAR 0 2
64059: PPUSH
64060: EMPTY
64061: PPUSH
64062: CALL_OW 1
64066: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64067: LD_ADDR_EXP 33
64071: PUSH
64072: LD_EXP 33
64076: PPUSH
64077: LD_VAR 0 2
64081: PPUSH
64082: EMPTY
64083: PPUSH
64084: CALL_OW 1
64088: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
64089: LD_ADDR_EXP 34
64093: PUSH
64094: LD_EXP 34
64098: PPUSH
64099: LD_VAR 0 2
64103: PPUSH
64104: EMPTY
64105: PPUSH
64106: CALL_OW 1
64110: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
64111: LD_ADDR_EXP 35
64115: PUSH
64116: LD_EXP 35
64120: PPUSH
64121: LD_VAR 0 2
64125: PPUSH
64126: EMPTY
64127: PUSH
64128: EMPTY
64129: PUSH
64130: EMPTY
64131: LIST
64132: LIST
64133: PPUSH
64134: CALL_OW 1
64138: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
64139: LD_ADDR_EXP 36
64143: PUSH
64144: LD_EXP 36
64148: PPUSH
64149: LD_VAR 0 2
64153: PPUSH
64154: EMPTY
64155: PPUSH
64156: CALL_OW 1
64160: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
64161: LD_ADDR_EXP 63
64165: PUSH
64166: LD_EXP 63
64170: PPUSH
64171: LD_VAR 0 2
64175: PPUSH
64176: EMPTY
64177: PPUSH
64178: CALL_OW 1
64182: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
64183: LD_ADDR_EXP 37
64187: PUSH
64188: LD_EXP 37
64192: PPUSH
64193: LD_VAR 0 2
64197: PPUSH
64198: EMPTY
64199: PPUSH
64200: CALL_OW 1
64204: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
64205: LD_ADDR_EXP 38
64209: PUSH
64210: LD_EXP 38
64214: PPUSH
64215: LD_VAR 0 2
64219: PPUSH
64220: EMPTY
64221: PPUSH
64222: CALL_OW 1
64226: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
64227: LD_ADDR_EXP 39
64231: PUSH
64232: LD_EXP 39
64236: PPUSH
64237: LD_VAR 0 2
64241: PPUSH
64242: LD_EXP 31
64246: PUSH
64247: LD_VAR 0 2
64251: ARRAY
64252: PPUSH
64253: LD_INT 2
64255: PUSH
64256: LD_INT 30
64258: PUSH
64259: LD_INT 32
64261: PUSH
64262: EMPTY
64263: LIST
64264: LIST
64265: PUSH
64266: LD_INT 30
64268: PUSH
64269: LD_INT 33
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: LIST
64280: PPUSH
64281: CALL_OW 72
64285: PPUSH
64286: CALL_OW 1
64290: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
64291: LD_ADDR_EXP 40
64295: PUSH
64296: LD_EXP 40
64300: PPUSH
64301: LD_VAR 0 2
64305: PPUSH
64306: LD_EXP 31
64310: PUSH
64311: LD_VAR 0 2
64315: ARRAY
64316: PPUSH
64317: LD_INT 2
64319: PUSH
64320: LD_INT 30
64322: PUSH
64323: LD_INT 32
64325: PUSH
64326: EMPTY
64327: LIST
64328: LIST
64329: PUSH
64330: LD_INT 30
64332: PUSH
64333: LD_INT 31
64335: PUSH
64336: EMPTY
64337: LIST
64338: LIST
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: LIST
64344: PUSH
64345: LD_INT 58
64347: PUSH
64348: EMPTY
64349: LIST
64350: PUSH
64351: EMPTY
64352: LIST
64353: LIST
64354: PPUSH
64355: CALL_OW 72
64359: PPUSH
64360: CALL_OW 1
64364: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
64365: LD_ADDR_EXP 41
64369: PUSH
64370: LD_EXP 41
64374: PPUSH
64375: LD_VAR 0 2
64379: PPUSH
64380: EMPTY
64381: PPUSH
64382: CALL_OW 1
64386: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
64387: LD_ADDR_EXP 45
64391: PUSH
64392: LD_EXP 45
64396: PPUSH
64397: LD_VAR 0 2
64401: PPUSH
64402: EMPTY
64403: PPUSH
64404: CALL_OW 1
64408: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
64409: LD_ADDR_EXP 44
64413: PUSH
64414: LD_EXP 44
64418: PPUSH
64419: LD_VAR 0 2
64423: PPUSH
64424: EMPTY
64425: PPUSH
64426: CALL_OW 1
64430: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
64431: LD_ADDR_EXP 46
64435: PUSH
64436: LD_EXP 46
64440: PPUSH
64441: LD_VAR 0 2
64445: PPUSH
64446: EMPTY
64447: PPUSH
64448: CALL_OW 1
64452: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
64453: LD_ADDR_EXP 47
64457: PUSH
64458: LD_EXP 47
64462: PPUSH
64463: LD_VAR 0 2
64467: PPUSH
64468: EMPTY
64469: PPUSH
64470: CALL_OW 1
64474: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64475: LD_ADDR_EXP 48
64479: PUSH
64480: LD_EXP 48
64484: PPUSH
64485: LD_VAR 0 2
64489: PPUSH
64490: EMPTY
64491: PPUSH
64492: CALL_OW 1
64496: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
64497: LD_ADDR_EXP 49
64501: PUSH
64502: LD_EXP 49
64506: PPUSH
64507: LD_VAR 0 2
64511: PPUSH
64512: EMPTY
64513: PPUSH
64514: CALL_OW 1
64518: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
64519: LD_ADDR_EXP 50
64523: PUSH
64524: LD_EXP 50
64528: PPUSH
64529: LD_VAR 0 2
64533: PPUSH
64534: EMPTY
64535: PPUSH
64536: CALL_OW 1
64540: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
64541: LD_ADDR_EXP 51
64545: PUSH
64546: LD_EXP 51
64550: PPUSH
64551: LD_VAR 0 2
64555: PPUSH
64556: EMPTY
64557: PPUSH
64558: CALL_OW 1
64562: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
64563: LD_ADDR_EXP 52
64567: PUSH
64568: LD_EXP 52
64572: PPUSH
64573: LD_VAR 0 2
64577: PPUSH
64578: EMPTY
64579: PPUSH
64580: CALL_OW 1
64584: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64585: LD_ADDR_EXP 53
64589: PUSH
64590: LD_EXP 53
64594: PPUSH
64595: LD_VAR 0 2
64599: PPUSH
64600: EMPTY
64601: PPUSH
64602: CALL_OW 1
64606: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
64607: LD_ADDR_EXP 42
64611: PUSH
64612: LD_EXP 42
64616: PPUSH
64617: LD_VAR 0 2
64621: PPUSH
64622: LD_INT 0
64624: PPUSH
64625: CALL_OW 1
64629: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
64630: LD_ADDR_EXP 55
64634: PUSH
64635: LD_EXP 55
64639: PPUSH
64640: LD_VAR 0 2
64644: PPUSH
64645: LD_INT 0
64647: PPUSH
64648: CALL_OW 1
64652: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64653: LD_ADDR_EXP 43
64657: PUSH
64658: LD_EXP 43
64662: PPUSH
64663: LD_VAR 0 2
64667: PPUSH
64668: EMPTY
64669: PPUSH
64670: CALL_OW 1
64674: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
64675: LD_ADDR_EXP 54
64679: PUSH
64680: LD_EXP 54
64684: PPUSH
64685: LD_VAR 0 2
64689: PPUSH
64690: LD_INT 0
64692: PPUSH
64693: CALL_OW 1
64697: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
64698: LD_ADDR_EXP 56
64702: PUSH
64703: LD_EXP 56
64707: PPUSH
64708: LD_VAR 0 2
64712: PPUSH
64713: EMPTY
64714: PPUSH
64715: CALL_OW 1
64719: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
64720: LD_ADDR_EXP 59
64724: PUSH
64725: LD_EXP 59
64729: PPUSH
64730: LD_VAR 0 2
64734: PPUSH
64735: LD_INT 0
64737: PPUSH
64738: CALL_OW 1
64742: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
64743: LD_ADDR_EXP 60
64747: PUSH
64748: LD_EXP 60
64752: PPUSH
64753: LD_VAR 0 2
64757: PPUSH
64758: EMPTY
64759: PPUSH
64760: CALL_OW 1
64764: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64765: LD_ADDR_EXP 61
64769: PUSH
64770: LD_EXP 61
64774: PPUSH
64775: LD_VAR 0 2
64779: PPUSH
64780: EMPTY
64781: PPUSH
64782: CALL_OW 1
64786: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64787: LD_ADDR_EXP 62
64791: PUSH
64792: LD_EXP 62
64796: PPUSH
64797: LD_VAR 0 2
64801: PPUSH
64802: EMPTY
64803: PPUSH
64804: CALL_OW 1
64808: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64809: LD_ADDR_EXP 64
64813: PUSH
64814: LD_EXP 64
64818: PPUSH
64819: LD_VAR 0 2
64823: PPUSH
64824: LD_EXP 31
64828: PUSH
64829: LD_VAR 0 2
64833: ARRAY
64834: PPUSH
64835: LD_INT 2
64837: PUSH
64838: LD_INT 30
64840: PUSH
64841: LD_INT 6
64843: PUSH
64844: EMPTY
64845: LIST
64846: LIST
64847: PUSH
64848: LD_INT 30
64850: PUSH
64851: LD_INT 7
64853: PUSH
64854: EMPTY
64855: LIST
64856: LIST
64857: PUSH
64858: LD_INT 30
64860: PUSH
64861: LD_INT 8
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: LIST
64872: LIST
64873: PPUSH
64874: CALL_OW 72
64878: PPUSH
64879: CALL_OW 1
64883: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64884: LD_ADDR_EXP 65
64888: PUSH
64889: LD_EXP 65
64893: PPUSH
64894: LD_VAR 0 2
64898: PPUSH
64899: EMPTY
64900: PPUSH
64901: CALL_OW 1
64905: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64906: LD_ADDR_EXP 66
64910: PUSH
64911: LD_EXP 66
64915: PPUSH
64916: LD_VAR 0 2
64920: PPUSH
64921: EMPTY
64922: PPUSH
64923: CALL_OW 1
64927: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64928: LD_ADDR_EXP 67
64932: PUSH
64933: LD_EXP 67
64937: PPUSH
64938: LD_VAR 0 2
64942: PPUSH
64943: EMPTY
64944: PPUSH
64945: CALL_OW 1
64949: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64950: LD_ADDR_EXP 68
64954: PUSH
64955: LD_EXP 68
64959: PPUSH
64960: LD_VAR 0 2
64964: PPUSH
64965: EMPTY
64966: PPUSH
64967: CALL_OW 1
64971: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64972: LD_ADDR_EXP 69
64976: PUSH
64977: LD_EXP 69
64981: PPUSH
64982: LD_VAR 0 2
64986: PPUSH
64987: EMPTY
64988: PPUSH
64989: CALL_OW 1
64993: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64994: LD_ADDR_EXP 70
64998: PUSH
64999: LD_EXP 70
65003: PPUSH
65004: LD_VAR 0 2
65008: PPUSH
65009: EMPTY
65010: PPUSH
65011: CALL_OW 1
65015: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
65016: LD_ADDR_EXP 71
65020: PUSH
65021: LD_EXP 71
65025: PPUSH
65026: LD_VAR 0 2
65030: PPUSH
65031: EMPTY
65032: PPUSH
65033: CALL_OW 1
65037: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
65038: LD_ADDR_EXP 72
65042: PUSH
65043: LD_EXP 72
65047: PPUSH
65048: LD_VAR 0 2
65052: PPUSH
65053: EMPTY
65054: PPUSH
65055: CALL_OW 1
65059: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
65060: LD_ADDR_EXP 73
65064: PUSH
65065: LD_EXP 73
65069: PPUSH
65070: LD_VAR 0 2
65074: PPUSH
65075: LD_INT 0
65077: PPUSH
65078: CALL_OW 1
65082: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
65083: LD_ADDR_EXP 74
65087: PUSH
65088: LD_EXP 74
65092: PPUSH
65093: LD_VAR 0 2
65097: PPUSH
65098: LD_INT 0
65100: PPUSH
65101: CALL_OW 1
65105: ST_TO_ADDR
// end ;
65106: GO 64007
65108: POP
65109: POP
// MC_InitSides ( ) ;
65110: CALL 65396 0 0
// MC_InitResearch ( ) ;
65114: CALL 65135 0 0
// CustomInitMacro ( ) ;
65118: CALL 1411 0 0
// skirmish := true ;
65122: LD_ADDR_EXP 29
65126: PUSH
65127: LD_INT 1
65129: ST_TO_ADDR
// end ;
65130: LD_VAR 0 1
65134: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
65135: LD_INT 0
65137: PPUSH
65138: PPUSH
65139: PPUSH
65140: PPUSH
65141: PPUSH
65142: PPUSH
// if not mc_bases then
65143: LD_EXP 31
65147: NOT
65148: IFFALSE 65152
// exit ;
65150: GO 65391
// for i = 1 to 8 do
65152: LD_ADDR_VAR 0 2
65156: PUSH
65157: DOUBLE
65158: LD_INT 1
65160: DEC
65161: ST_TO_ADDR
65162: LD_INT 8
65164: PUSH
65165: FOR_TO
65166: IFFALSE 65192
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
65168: LD_ADDR_EXP 58
65172: PUSH
65173: LD_EXP 58
65177: PPUSH
65178: LD_VAR 0 2
65182: PPUSH
65183: EMPTY
65184: PPUSH
65185: CALL_OW 1
65189: ST_TO_ADDR
65190: GO 65165
65192: POP
65193: POP
// tmp := [ ] ;
65194: LD_ADDR_VAR 0 5
65198: PUSH
65199: EMPTY
65200: ST_TO_ADDR
// for i = 1 to mc_sides do
65201: LD_ADDR_VAR 0 2
65205: PUSH
65206: DOUBLE
65207: LD_INT 1
65209: DEC
65210: ST_TO_ADDR
65211: LD_EXP 57
65215: PUSH
65216: FOR_TO
65217: IFFALSE 65275
// if not mc_sides [ i ] in tmp then
65219: LD_EXP 57
65223: PUSH
65224: LD_VAR 0 2
65228: ARRAY
65229: PUSH
65230: LD_VAR 0 5
65234: IN
65235: NOT
65236: IFFALSE 65273
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
65238: LD_ADDR_VAR 0 5
65242: PUSH
65243: LD_VAR 0 5
65247: PPUSH
65248: LD_VAR 0 5
65252: PUSH
65253: LD_INT 1
65255: PLUS
65256: PPUSH
65257: LD_EXP 57
65261: PUSH
65262: LD_VAR 0 2
65266: ARRAY
65267: PPUSH
65268: CALL_OW 2
65272: ST_TO_ADDR
65273: GO 65216
65275: POP
65276: POP
// if not tmp then
65277: LD_VAR 0 5
65281: NOT
65282: IFFALSE 65286
// exit ;
65284: GO 65391
// for j in tmp do
65286: LD_ADDR_VAR 0 3
65290: PUSH
65291: LD_VAR 0 5
65295: PUSH
65296: FOR_IN
65297: IFFALSE 65389
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
65299: LD_ADDR_VAR 0 6
65303: PUSH
65304: LD_INT 22
65306: PUSH
65307: LD_VAR 0 3
65311: PUSH
65312: EMPTY
65313: LIST
65314: LIST
65315: PPUSH
65316: CALL_OW 69
65320: ST_TO_ADDR
// if not un then
65321: LD_VAR 0 6
65325: NOT
65326: IFFALSE 65330
// continue ;
65328: GO 65296
// nation := GetNation ( un [ 1 ] ) ;
65330: LD_ADDR_VAR 0 4
65334: PUSH
65335: LD_VAR 0 6
65339: PUSH
65340: LD_INT 1
65342: ARRAY
65343: PPUSH
65344: CALL_OW 248
65348: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
65349: LD_ADDR_EXP 58
65353: PUSH
65354: LD_EXP 58
65358: PPUSH
65359: LD_VAR 0 3
65363: PPUSH
65364: LD_VAR 0 3
65368: PPUSH
65369: LD_VAR 0 4
65373: PPUSH
65374: LD_INT 1
65376: PPUSH
65377: CALL 19947 0 3
65381: PPUSH
65382: CALL_OW 1
65386: ST_TO_ADDR
// end ;
65387: GO 65296
65389: POP
65390: POP
// end ;
65391: LD_VAR 0 1
65395: RET
// export function MC_InitSides ( ) ; var i ; begin
65396: LD_INT 0
65398: PPUSH
65399: PPUSH
// if not mc_bases then
65400: LD_EXP 31
65404: NOT
65405: IFFALSE 65409
// exit ;
65407: GO 65483
// for i = 1 to mc_bases do
65409: LD_ADDR_VAR 0 2
65413: PUSH
65414: DOUBLE
65415: LD_INT 1
65417: DEC
65418: ST_TO_ADDR
65419: LD_EXP 31
65423: PUSH
65424: FOR_TO
65425: IFFALSE 65481
// if mc_bases [ i ] then
65427: LD_EXP 31
65431: PUSH
65432: LD_VAR 0 2
65436: ARRAY
65437: IFFALSE 65479
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
65439: LD_ADDR_EXP 57
65443: PUSH
65444: LD_EXP 57
65448: PPUSH
65449: LD_VAR 0 2
65453: PPUSH
65454: LD_EXP 31
65458: PUSH
65459: LD_VAR 0 2
65463: ARRAY
65464: PUSH
65465: LD_INT 1
65467: ARRAY
65468: PPUSH
65469: CALL_OW 255
65473: PPUSH
65474: CALL_OW 1
65478: ST_TO_ADDR
65479: GO 65424
65481: POP
65482: POP
// end ;
65483: LD_VAR 0 1
65487: RET
// every 0 0$03 trigger skirmish do
65488: LD_EXP 29
65492: IFFALSE 65646
65494: GO 65496
65496: DISABLE
// begin enable ;
65497: ENABLE
// MC_CheckBuildings ( ) ;
65498: CALL 70158 0 0
// MC_CheckPeopleLife ( ) ;
65502: CALL 70319 0 0
// RaiseSailEvent ( 100 ) ;
65506: LD_INT 100
65508: PPUSH
65509: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
65513: LD_INT 103
65515: PPUSH
65516: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
65520: LD_INT 104
65522: PPUSH
65523: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
65527: LD_INT 105
65529: PPUSH
65530: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
65534: LD_INT 106
65536: PPUSH
65537: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
65541: LD_INT 107
65543: PPUSH
65544: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
65548: LD_INT 108
65550: PPUSH
65551: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
65555: LD_INT 109
65557: PPUSH
65558: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
65562: LD_INT 110
65564: PPUSH
65565: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
65569: LD_INT 111
65571: PPUSH
65572: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
65576: LD_INT 112
65578: PPUSH
65579: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
65583: LD_INT 113
65585: PPUSH
65586: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
65590: LD_INT 120
65592: PPUSH
65593: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
65597: LD_INT 121
65599: PPUSH
65600: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
65604: LD_INT 122
65606: PPUSH
65607: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
65611: LD_INT 123
65613: PPUSH
65614: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
65618: LD_INT 124
65620: PPUSH
65621: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
65625: LD_INT 125
65627: PPUSH
65628: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
65632: LD_INT 126
65634: PPUSH
65635: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
65639: LD_INT 200
65641: PPUSH
65642: CALL_OW 427
// end ;
65646: END
// on SailEvent ( event ) do begin if event < 100 then
65647: LD_VAR 0 1
65651: PUSH
65652: LD_INT 100
65654: LESS
65655: IFFALSE 65666
// CustomEvent ( event ) ;
65657: LD_VAR 0 1
65661: PPUSH
65662: CALL 19111 0 1
// if event = 100 then
65666: LD_VAR 0 1
65670: PUSH
65671: LD_INT 100
65673: EQUAL
65674: IFFALSE 65680
// MC_ClassManager ( ) ;
65676: CALL 66072 0 0
// if event = 101 then
65680: LD_VAR 0 1
65684: PUSH
65685: LD_INT 101
65687: EQUAL
65688: IFFALSE 65694
// MC_RepairBuildings ( ) ;
65690: CALL 70904 0 0
// if event = 102 then
65694: LD_VAR 0 1
65698: PUSH
65699: LD_INT 102
65701: EQUAL
65702: IFFALSE 65708
// MC_Heal ( ) ;
65704: CALL 71839 0 0
// if event = 103 then
65708: LD_VAR 0 1
65712: PUSH
65713: LD_INT 103
65715: EQUAL
65716: IFFALSE 65722
// MC_Build ( ) ;
65718: CALL 72261 0 0
// if event = 104 then
65722: LD_VAR 0 1
65726: PUSH
65727: LD_INT 104
65729: EQUAL
65730: IFFALSE 65736
// MC_TurretWeapon ( ) ;
65732: CALL 73895 0 0
// if event = 105 then
65736: LD_VAR 0 1
65740: PUSH
65741: LD_INT 105
65743: EQUAL
65744: IFFALSE 65750
// MC_BuildUpgrade ( ) ;
65746: CALL 73446 0 0
// if event = 106 then
65750: LD_VAR 0 1
65754: PUSH
65755: LD_INT 106
65757: EQUAL
65758: IFFALSE 65764
// MC_PlantMines ( ) ;
65760: CALL 74325 0 0
// if event = 107 then
65764: LD_VAR 0 1
65768: PUSH
65769: LD_INT 107
65771: EQUAL
65772: IFFALSE 65778
// MC_CollectCrates ( ) ;
65774: CALL 75123 0 0
// if event = 108 then
65778: LD_VAR 0 1
65782: PUSH
65783: LD_INT 108
65785: EQUAL
65786: IFFALSE 65792
// MC_LinkRemoteControl ( ) ;
65788: CALL 76973 0 0
// if event = 109 then
65792: LD_VAR 0 1
65796: PUSH
65797: LD_INT 109
65799: EQUAL
65800: IFFALSE 65806
// MC_ProduceVehicle ( ) ;
65802: CALL 77154 0 0
// if event = 110 then
65806: LD_VAR 0 1
65810: PUSH
65811: LD_INT 110
65813: EQUAL
65814: IFFALSE 65820
// MC_SendAttack ( ) ;
65816: CALL 77620 0 0
// if event = 111 then
65820: LD_VAR 0 1
65824: PUSH
65825: LD_INT 111
65827: EQUAL
65828: IFFALSE 65834
// MC_Defend ( ) ;
65830: CALL 77728 0 0
// if event = 112 then
65834: LD_VAR 0 1
65838: PUSH
65839: LD_INT 112
65841: EQUAL
65842: IFFALSE 65848
// MC_Research ( ) ;
65844: CALL 78608 0 0
// if event = 113 then
65848: LD_VAR 0 1
65852: PUSH
65853: LD_INT 113
65855: EQUAL
65856: IFFALSE 65862
// MC_MinesTrigger ( ) ;
65858: CALL 79722 0 0
// if event = 120 then
65862: LD_VAR 0 1
65866: PUSH
65867: LD_INT 120
65869: EQUAL
65870: IFFALSE 65876
// MC_RepairVehicle ( ) ;
65872: CALL 79821 0 0
// if event = 121 then
65876: LD_VAR 0 1
65880: PUSH
65881: LD_INT 121
65883: EQUAL
65884: IFFALSE 65890
// MC_TameApe ( ) ;
65886: CALL 80590 0 0
// if event = 122 then
65890: LD_VAR 0 1
65894: PUSH
65895: LD_INT 122
65897: EQUAL
65898: IFFALSE 65904
// MC_ChangeApeClass ( ) ;
65900: CALL 81419 0 0
// if event = 123 then
65904: LD_VAR 0 1
65908: PUSH
65909: LD_INT 123
65911: EQUAL
65912: IFFALSE 65918
// MC_Bazooka ( ) ;
65914: CALL 82069 0 0
// if event = 124 then
65918: LD_VAR 0 1
65922: PUSH
65923: LD_INT 124
65925: EQUAL
65926: IFFALSE 65932
// MC_TeleportExit ( ) ;
65928: CALL 82267 0 0
// if event = 125 then
65932: LD_VAR 0 1
65936: PUSH
65937: LD_INT 125
65939: EQUAL
65940: IFFALSE 65946
// MC_Deposits ( ) ;
65942: CALL 82914 0 0
// if event = 126 then
65946: LD_VAR 0 1
65950: PUSH
65951: LD_INT 126
65953: EQUAL
65954: IFFALSE 65960
// MC_RemoteDriver ( ) ;
65956: CALL 83539 0 0
// if event = 200 then
65960: LD_VAR 0 1
65964: PUSH
65965: LD_INT 200
65967: EQUAL
65968: IFFALSE 65974
// MC_Idle ( ) ;
65970: CALL 85446 0 0
// end ;
65974: PPOPN 1
65976: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65977: LD_INT 0
65979: PPUSH
65980: PPUSH
// if not mc_bases [ base ] or not tag then
65981: LD_EXP 31
65985: PUSH
65986: LD_VAR 0 1
65990: ARRAY
65991: NOT
65992: PUSH
65993: LD_VAR 0 2
65997: NOT
65998: OR
65999: IFFALSE 66003
// exit ;
66001: GO 66067
// for i in mc_bases [ base ] union mc_ape [ base ] do
66003: LD_ADDR_VAR 0 4
66007: PUSH
66008: LD_EXP 31
66012: PUSH
66013: LD_VAR 0 1
66017: ARRAY
66018: PUSH
66019: LD_EXP 60
66023: PUSH
66024: LD_VAR 0 1
66028: ARRAY
66029: UNION
66030: PUSH
66031: FOR_IN
66032: IFFALSE 66065
// if GetTag ( i ) = tag then
66034: LD_VAR 0 4
66038: PPUSH
66039: CALL_OW 110
66043: PUSH
66044: LD_VAR 0 2
66048: EQUAL
66049: IFFALSE 66063
// SetTag ( i , 0 ) ;
66051: LD_VAR 0 4
66055: PPUSH
66056: LD_INT 0
66058: PPUSH
66059: CALL_OW 109
66063: GO 66031
66065: POP
66066: POP
// end ;
66067: LD_VAR 0 3
66071: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
66072: LD_INT 0
66074: PPUSH
66075: PPUSH
66076: PPUSH
66077: PPUSH
66078: PPUSH
66079: PPUSH
66080: PPUSH
66081: PPUSH
// if not mc_bases then
66082: LD_EXP 31
66086: NOT
66087: IFFALSE 66091
// exit ;
66089: GO 66540
// for i = 1 to mc_bases do
66091: LD_ADDR_VAR 0 2
66095: PUSH
66096: DOUBLE
66097: LD_INT 1
66099: DEC
66100: ST_TO_ADDR
66101: LD_EXP 31
66105: PUSH
66106: FOR_TO
66107: IFFALSE 66538
// begin tmp := MC_ClassCheckReq ( i ) ;
66109: LD_ADDR_VAR 0 4
66113: PUSH
66114: LD_VAR 0 2
66118: PPUSH
66119: CALL 66545 0 1
66123: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
66124: LD_ADDR_EXP 72
66128: PUSH
66129: LD_EXP 72
66133: PPUSH
66134: LD_VAR 0 2
66138: PPUSH
66139: LD_VAR 0 4
66143: PPUSH
66144: CALL_OW 1
66148: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
66149: LD_ADDR_VAR 0 6
66153: PUSH
66154: LD_EXP 31
66158: PUSH
66159: LD_VAR 0 2
66163: ARRAY
66164: PPUSH
66165: LD_INT 2
66167: PUSH
66168: LD_INT 30
66170: PUSH
66171: LD_INT 4
66173: PUSH
66174: EMPTY
66175: LIST
66176: LIST
66177: PUSH
66178: LD_INT 30
66180: PUSH
66181: LD_INT 5
66183: PUSH
66184: EMPTY
66185: LIST
66186: LIST
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: LIST
66192: PPUSH
66193: CALL_OW 72
66197: PUSH
66198: LD_EXP 31
66202: PUSH
66203: LD_VAR 0 2
66207: ARRAY
66208: PPUSH
66209: LD_INT 2
66211: PUSH
66212: LD_INT 30
66214: PUSH
66215: LD_INT 0
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PUSH
66222: LD_INT 30
66224: PUSH
66225: LD_INT 1
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: LIST
66236: PPUSH
66237: CALL_OW 72
66241: PUSH
66242: LD_EXP 31
66246: PUSH
66247: LD_VAR 0 2
66251: ARRAY
66252: PPUSH
66253: LD_INT 30
66255: PUSH
66256: LD_INT 3
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PPUSH
66263: CALL_OW 72
66267: PUSH
66268: LD_EXP 31
66272: PUSH
66273: LD_VAR 0 2
66277: ARRAY
66278: PPUSH
66279: LD_INT 2
66281: PUSH
66282: LD_INT 30
66284: PUSH
66285: LD_INT 6
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 30
66294: PUSH
66295: LD_INT 7
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 30
66304: PUSH
66305: LD_INT 8
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: LIST
66316: LIST
66317: PPUSH
66318: CALL_OW 72
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: LIST
66327: LIST
66328: ST_TO_ADDR
// for j := 1 to 4 do
66329: LD_ADDR_VAR 0 3
66333: PUSH
66334: DOUBLE
66335: LD_INT 1
66337: DEC
66338: ST_TO_ADDR
66339: LD_INT 4
66341: PUSH
66342: FOR_TO
66343: IFFALSE 66534
// begin if not tmp [ j ] then
66345: LD_VAR 0 4
66349: PUSH
66350: LD_VAR 0 3
66354: ARRAY
66355: NOT
66356: IFFALSE 66360
// continue ;
66358: GO 66342
// for p in tmp [ j ] do
66360: LD_ADDR_VAR 0 5
66364: PUSH
66365: LD_VAR 0 4
66369: PUSH
66370: LD_VAR 0 3
66374: ARRAY
66375: PUSH
66376: FOR_IN
66377: IFFALSE 66530
// begin if not b [ j ] then
66379: LD_VAR 0 6
66383: PUSH
66384: LD_VAR 0 3
66388: ARRAY
66389: NOT
66390: IFFALSE 66394
// break ;
66392: GO 66530
// e := 0 ;
66394: LD_ADDR_VAR 0 7
66398: PUSH
66399: LD_INT 0
66401: ST_TO_ADDR
// for k in b [ j ] do
66402: LD_ADDR_VAR 0 8
66406: PUSH
66407: LD_VAR 0 6
66411: PUSH
66412: LD_VAR 0 3
66416: ARRAY
66417: PUSH
66418: FOR_IN
66419: IFFALSE 66446
// if IsNotFull ( k ) then
66421: LD_VAR 0 8
66425: PPUSH
66426: CALL 22068 0 1
66430: IFFALSE 66444
// begin e := k ;
66432: LD_ADDR_VAR 0 7
66436: PUSH
66437: LD_VAR 0 8
66441: ST_TO_ADDR
// break ;
66442: GO 66446
// end ;
66444: GO 66418
66446: POP
66447: POP
// if e and not UnitGoingToBuilding ( p , e ) then
66448: LD_VAR 0 7
66452: PUSH
66453: LD_VAR 0 5
66457: PPUSH
66458: LD_VAR 0 7
66462: PPUSH
66463: CALL 56218 0 2
66467: NOT
66468: AND
66469: IFFALSE 66528
// begin if IsInUnit ( p ) then
66471: LD_VAR 0 5
66475: PPUSH
66476: CALL_OW 310
66480: IFFALSE 66491
// ComExitBuilding ( p ) ;
66482: LD_VAR 0 5
66486: PPUSH
66487: CALL_OW 122
// ComEnterUnit ( p , e ) ;
66491: LD_VAR 0 5
66495: PPUSH
66496: LD_VAR 0 7
66500: PPUSH
66501: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
66505: LD_VAR 0 5
66509: PPUSH
66510: LD_VAR 0 3
66514: PPUSH
66515: CALL_OW 183
// AddComExitBuilding ( p ) ;
66519: LD_VAR 0 5
66523: PPUSH
66524: CALL_OW 182
// end ; end ;
66528: GO 66376
66530: POP
66531: POP
// end ;
66532: GO 66342
66534: POP
66535: POP
// end ;
66536: GO 66106
66538: POP
66539: POP
// end ;
66540: LD_VAR 0 1
66544: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
66545: LD_INT 0
66547: PPUSH
66548: PPUSH
66549: PPUSH
66550: PPUSH
66551: PPUSH
66552: PPUSH
66553: PPUSH
66554: PPUSH
66555: PPUSH
66556: PPUSH
66557: PPUSH
66558: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
66559: LD_ADDR_VAR 0 2
66563: PUSH
66564: LD_INT 0
66566: PUSH
66567: LD_INT 0
66569: PUSH
66570: LD_INT 0
66572: PUSH
66573: LD_INT 0
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: LIST
66580: LIST
66581: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66582: LD_VAR 0 1
66586: NOT
66587: PUSH
66588: LD_EXP 31
66592: PUSH
66593: LD_VAR 0 1
66597: ARRAY
66598: NOT
66599: OR
66600: PUSH
66601: LD_EXP 31
66605: PUSH
66606: LD_VAR 0 1
66610: ARRAY
66611: PPUSH
66612: LD_INT 2
66614: PUSH
66615: LD_INT 30
66617: PUSH
66618: LD_INT 0
66620: PUSH
66621: EMPTY
66622: LIST
66623: LIST
66624: PUSH
66625: LD_INT 30
66627: PUSH
66628: LD_INT 1
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: EMPTY
66636: LIST
66637: LIST
66638: LIST
66639: PPUSH
66640: CALL_OW 72
66644: NOT
66645: OR
66646: IFFALSE 66650
// exit ;
66648: GO 70153
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66650: LD_ADDR_VAR 0 4
66654: PUSH
66655: LD_EXP 31
66659: PUSH
66660: LD_VAR 0 1
66664: ARRAY
66665: PPUSH
66666: LD_INT 2
66668: PUSH
66669: LD_INT 25
66671: PUSH
66672: LD_INT 1
66674: PUSH
66675: EMPTY
66676: LIST
66677: LIST
66678: PUSH
66679: LD_INT 25
66681: PUSH
66682: LD_INT 2
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 25
66691: PUSH
66692: LD_INT 3
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 25
66701: PUSH
66702: LD_INT 4
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: PUSH
66709: LD_INT 25
66711: PUSH
66712: LD_INT 5
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PUSH
66719: LD_INT 25
66721: PUSH
66722: LD_INT 8
66724: PUSH
66725: EMPTY
66726: LIST
66727: LIST
66728: PUSH
66729: LD_INT 25
66731: PUSH
66732: LD_INT 9
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: PPUSH
66749: CALL_OW 72
66753: ST_TO_ADDR
// if not tmp then
66754: LD_VAR 0 4
66758: NOT
66759: IFFALSE 66763
// exit ;
66761: GO 70153
// for i in tmp do
66763: LD_ADDR_VAR 0 3
66767: PUSH
66768: LD_VAR 0 4
66772: PUSH
66773: FOR_IN
66774: IFFALSE 66805
// if GetTag ( i ) then
66776: LD_VAR 0 3
66780: PPUSH
66781: CALL_OW 110
66785: IFFALSE 66803
// tmp := tmp diff i ;
66787: LD_ADDR_VAR 0 4
66791: PUSH
66792: LD_VAR 0 4
66796: PUSH
66797: LD_VAR 0 3
66801: DIFF
66802: ST_TO_ADDR
66803: GO 66773
66805: POP
66806: POP
// if not tmp then
66807: LD_VAR 0 4
66811: NOT
66812: IFFALSE 66816
// exit ;
66814: GO 70153
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66816: LD_ADDR_VAR 0 5
66820: PUSH
66821: LD_EXP 31
66825: PUSH
66826: LD_VAR 0 1
66830: ARRAY
66831: PPUSH
66832: LD_INT 2
66834: PUSH
66835: LD_INT 25
66837: PUSH
66838: LD_INT 1
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 25
66847: PUSH
66848: LD_INT 5
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 25
66857: PUSH
66858: LD_INT 8
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 25
66867: PUSH
66868: LD_INT 9
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: PPUSH
66882: CALL_OW 72
66886: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66887: LD_ADDR_VAR 0 6
66891: PUSH
66892: LD_EXP 31
66896: PUSH
66897: LD_VAR 0 1
66901: ARRAY
66902: PPUSH
66903: LD_INT 25
66905: PUSH
66906: LD_INT 2
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PPUSH
66913: CALL_OW 72
66917: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66918: LD_ADDR_VAR 0 7
66922: PUSH
66923: LD_EXP 31
66927: PUSH
66928: LD_VAR 0 1
66932: ARRAY
66933: PPUSH
66934: LD_INT 25
66936: PUSH
66937: LD_INT 3
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PPUSH
66944: CALL_OW 72
66948: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66949: LD_ADDR_VAR 0 8
66953: PUSH
66954: LD_EXP 31
66958: PUSH
66959: LD_VAR 0 1
66963: ARRAY
66964: PPUSH
66965: LD_INT 25
66967: PUSH
66968: LD_INT 4
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 24
66977: PUSH
66978: LD_INT 251
66980: PUSH
66981: EMPTY
66982: LIST
66983: LIST
66984: PUSH
66985: EMPTY
66986: LIST
66987: LIST
66988: PPUSH
66989: CALL_OW 72
66993: ST_TO_ADDR
// if mc_is_defending [ base ] then
66994: LD_EXP 74
66998: PUSH
66999: LD_VAR 0 1
67003: ARRAY
67004: IFFALSE 67465
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
67006: LD_ADDR_EXP 73
67010: PUSH
67011: LD_EXP 73
67015: PPUSH
67016: LD_VAR 0 1
67020: PPUSH
67021: LD_INT 4
67023: PPUSH
67024: CALL_OW 1
67028: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
67029: LD_ADDR_VAR 0 12
67033: PUSH
67034: LD_EXP 31
67038: PUSH
67039: LD_VAR 0 1
67043: ARRAY
67044: PPUSH
67045: LD_INT 2
67047: PUSH
67048: LD_INT 30
67050: PUSH
67051: LD_INT 4
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: LD_INT 30
67060: PUSH
67061: LD_INT 5
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: PUSH
67068: EMPTY
67069: LIST
67070: LIST
67071: LIST
67072: PPUSH
67073: CALL_OW 72
67077: ST_TO_ADDR
// if not b then
67078: LD_VAR 0 12
67082: NOT
67083: IFFALSE 67087
// exit ;
67085: GO 70153
// p := [ ] ;
67087: LD_ADDR_VAR 0 11
67091: PUSH
67092: EMPTY
67093: ST_TO_ADDR
// if sci >= 2 then
67094: LD_VAR 0 8
67098: PUSH
67099: LD_INT 2
67101: GREATEREQUAL
67102: IFFALSE 67133
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
67104: LD_ADDR_VAR 0 8
67108: PUSH
67109: LD_VAR 0 8
67113: PUSH
67114: LD_INT 1
67116: ARRAY
67117: PUSH
67118: LD_VAR 0 8
67122: PUSH
67123: LD_INT 2
67125: ARRAY
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: ST_TO_ADDR
67131: GO 67194
// if sci = 1 then
67133: LD_VAR 0 8
67137: PUSH
67138: LD_INT 1
67140: EQUAL
67141: IFFALSE 67162
// sci := [ sci [ 1 ] ] else
67143: LD_ADDR_VAR 0 8
67147: PUSH
67148: LD_VAR 0 8
67152: PUSH
67153: LD_INT 1
67155: ARRAY
67156: PUSH
67157: EMPTY
67158: LIST
67159: ST_TO_ADDR
67160: GO 67194
// if sci = 0 then
67162: LD_VAR 0 8
67166: PUSH
67167: LD_INT 0
67169: EQUAL
67170: IFFALSE 67194
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
67172: LD_ADDR_VAR 0 11
67176: PUSH
67177: LD_VAR 0 4
67181: PPUSH
67182: LD_INT 4
67184: PPUSH
67185: CALL 56090 0 2
67189: PUSH
67190: LD_INT 1
67192: ARRAY
67193: ST_TO_ADDR
// if eng > 4 then
67194: LD_VAR 0 6
67198: PUSH
67199: LD_INT 4
67201: GREATER
67202: IFFALSE 67248
// for i = eng downto 4 do
67204: LD_ADDR_VAR 0 3
67208: PUSH
67209: DOUBLE
67210: LD_VAR 0 6
67214: INC
67215: ST_TO_ADDR
67216: LD_INT 4
67218: PUSH
67219: FOR_DOWNTO
67220: IFFALSE 67246
// eng := eng diff eng [ i ] ;
67222: LD_ADDR_VAR 0 6
67226: PUSH
67227: LD_VAR 0 6
67231: PUSH
67232: LD_VAR 0 6
67236: PUSH
67237: LD_VAR 0 3
67241: ARRAY
67242: DIFF
67243: ST_TO_ADDR
67244: GO 67219
67246: POP
67247: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
67248: LD_ADDR_VAR 0 4
67252: PUSH
67253: LD_VAR 0 4
67257: PUSH
67258: LD_VAR 0 5
67262: PUSH
67263: LD_VAR 0 6
67267: UNION
67268: PUSH
67269: LD_VAR 0 7
67273: UNION
67274: PUSH
67275: LD_VAR 0 8
67279: UNION
67280: DIFF
67281: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
67282: LD_ADDR_VAR 0 13
67286: PUSH
67287: LD_EXP 31
67291: PUSH
67292: LD_VAR 0 1
67296: ARRAY
67297: PPUSH
67298: LD_INT 2
67300: PUSH
67301: LD_INT 30
67303: PUSH
67304: LD_INT 32
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 30
67313: PUSH
67314: LD_INT 31
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: EMPTY
67322: LIST
67323: LIST
67324: LIST
67325: PPUSH
67326: CALL_OW 72
67330: PUSH
67331: LD_EXP 31
67335: PUSH
67336: LD_VAR 0 1
67340: ARRAY
67341: PPUSH
67342: LD_INT 2
67344: PUSH
67345: LD_INT 30
67347: PUSH
67348: LD_INT 4
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 30
67357: PUSH
67358: LD_INT 5
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: LIST
67369: PPUSH
67370: CALL_OW 72
67374: PUSH
67375: LD_INT 6
67377: MUL
67378: PLUS
67379: ST_TO_ADDR
// if bcount < tmp then
67380: LD_VAR 0 13
67384: PUSH
67385: LD_VAR 0 4
67389: LESS
67390: IFFALSE 67436
// for i = tmp downto bcount do
67392: LD_ADDR_VAR 0 3
67396: PUSH
67397: DOUBLE
67398: LD_VAR 0 4
67402: INC
67403: ST_TO_ADDR
67404: LD_VAR 0 13
67408: PUSH
67409: FOR_DOWNTO
67410: IFFALSE 67434
// tmp := Delete ( tmp , tmp ) ;
67412: LD_ADDR_VAR 0 4
67416: PUSH
67417: LD_VAR 0 4
67421: PPUSH
67422: LD_VAR 0 4
67426: PPUSH
67427: CALL_OW 3
67431: ST_TO_ADDR
67432: GO 67409
67434: POP
67435: POP
// result := [ tmp , 0 , 0 , p ] ;
67436: LD_ADDR_VAR 0 2
67440: PUSH
67441: LD_VAR 0 4
67445: PUSH
67446: LD_INT 0
67448: PUSH
67449: LD_INT 0
67451: PUSH
67452: LD_VAR 0 11
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: ST_TO_ADDR
// exit ;
67463: GO 70153
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67465: LD_EXP 31
67469: PUSH
67470: LD_VAR 0 1
67474: ARRAY
67475: PPUSH
67476: LD_INT 2
67478: PUSH
67479: LD_INT 30
67481: PUSH
67482: LD_INT 6
67484: PUSH
67485: EMPTY
67486: LIST
67487: LIST
67488: PUSH
67489: LD_INT 30
67491: PUSH
67492: LD_INT 7
67494: PUSH
67495: EMPTY
67496: LIST
67497: LIST
67498: PUSH
67499: LD_INT 30
67501: PUSH
67502: LD_INT 8
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: LIST
67513: LIST
67514: PPUSH
67515: CALL_OW 72
67519: NOT
67520: PUSH
67521: LD_EXP 31
67525: PUSH
67526: LD_VAR 0 1
67530: ARRAY
67531: PPUSH
67532: LD_INT 30
67534: PUSH
67535: LD_INT 3
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PPUSH
67542: CALL_OW 72
67546: NOT
67547: AND
67548: IFFALSE 67620
// begin if eng = tmp then
67550: LD_VAR 0 6
67554: PUSH
67555: LD_VAR 0 4
67559: EQUAL
67560: IFFALSE 67564
// exit ;
67562: GO 70153
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
67564: LD_ADDR_EXP 73
67568: PUSH
67569: LD_EXP 73
67573: PPUSH
67574: LD_VAR 0 1
67578: PPUSH
67579: LD_INT 1
67581: PPUSH
67582: CALL_OW 1
67586: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
67587: LD_ADDR_VAR 0 2
67591: PUSH
67592: LD_INT 0
67594: PUSH
67595: LD_VAR 0 4
67599: PUSH
67600: LD_VAR 0 6
67604: DIFF
67605: PUSH
67606: LD_INT 0
67608: PUSH
67609: LD_INT 0
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: ST_TO_ADDR
// exit ;
67618: GO 70153
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67620: LD_EXP 58
67624: PUSH
67625: LD_EXP 57
67629: PUSH
67630: LD_VAR 0 1
67634: ARRAY
67635: ARRAY
67636: PUSH
67637: LD_EXP 31
67641: PUSH
67642: LD_VAR 0 1
67646: ARRAY
67647: PPUSH
67648: LD_INT 2
67650: PUSH
67651: LD_INT 30
67653: PUSH
67654: LD_INT 6
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 30
67663: PUSH
67664: LD_INT 7
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 30
67673: PUSH
67674: LD_INT 8
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: LIST
67685: LIST
67686: PPUSH
67687: CALL_OW 72
67691: AND
67692: PUSH
67693: LD_EXP 31
67697: PUSH
67698: LD_VAR 0 1
67702: ARRAY
67703: PPUSH
67704: LD_INT 30
67706: PUSH
67707: LD_INT 3
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PPUSH
67714: CALL_OW 72
67718: NOT
67719: AND
67720: IFFALSE 67934
// begin if sci >= 6 then
67722: LD_VAR 0 8
67726: PUSH
67727: LD_INT 6
67729: GREATEREQUAL
67730: IFFALSE 67734
// exit ;
67732: GO 70153
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
67734: LD_ADDR_EXP 73
67738: PUSH
67739: LD_EXP 73
67743: PPUSH
67744: LD_VAR 0 1
67748: PPUSH
67749: LD_INT 2
67751: PPUSH
67752: CALL_OW 1
67756: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
67757: LD_ADDR_VAR 0 9
67761: PUSH
67762: LD_VAR 0 4
67766: PUSH
67767: LD_VAR 0 8
67771: DIFF
67772: PPUSH
67773: LD_INT 4
67775: PPUSH
67776: CALL 56090 0 2
67780: ST_TO_ADDR
// p := [ ] ;
67781: LD_ADDR_VAR 0 11
67785: PUSH
67786: EMPTY
67787: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67788: LD_VAR 0 8
67792: PUSH
67793: LD_INT 6
67795: LESS
67796: PUSH
67797: LD_VAR 0 9
67801: PUSH
67802: LD_INT 6
67804: GREATER
67805: AND
67806: IFFALSE 67887
// begin for i = 1 to 6 - sci do
67808: LD_ADDR_VAR 0 3
67812: PUSH
67813: DOUBLE
67814: LD_INT 1
67816: DEC
67817: ST_TO_ADDR
67818: LD_INT 6
67820: PUSH
67821: LD_VAR 0 8
67825: MINUS
67826: PUSH
67827: FOR_TO
67828: IFFALSE 67883
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67830: LD_ADDR_VAR 0 11
67834: PUSH
67835: LD_VAR 0 11
67839: PPUSH
67840: LD_VAR 0 11
67844: PUSH
67845: LD_INT 1
67847: PLUS
67848: PPUSH
67849: LD_VAR 0 9
67853: PUSH
67854: LD_INT 1
67856: ARRAY
67857: PPUSH
67858: CALL_OW 2
67862: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67863: LD_ADDR_VAR 0 9
67867: PUSH
67868: LD_VAR 0 9
67872: PPUSH
67873: LD_INT 1
67875: PPUSH
67876: CALL_OW 3
67880: ST_TO_ADDR
// end ;
67881: GO 67827
67883: POP
67884: POP
// end else
67885: GO 67907
// if sort then
67887: LD_VAR 0 9
67891: IFFALSE 67907
// p := sort [ 1 ] ;
67893: LD_ADDR_VAR 0 11
67897: PUSH
67898: LD_VAR 0 9
67902: PUSH
67903: LD_INT 1
67905: ARRAY
67906: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67907: LD_ADDR_VAR 0 2
67911: PUSH
67912: LD_INT 0
67914: PUSH
67915: LD_INT 0
67917: PUSH
67918: LD_INT 0
67920: PUSH
67921: LD_VAR 0 11
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: ST_TO_ADDR
// exit ;
67932: GO 70153
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67934: LD_EXP 58
67938: PUSH
67939: LD_EXP 57
67943: PUSH
67944: LD_VAR 0 1
67948: ARRAY
67949: ARRAY
67950: PUSH
67951: LD_EXP 31
67955: PUSH
67956: LD_VAR 0 1
67960: ARRAY
67961: PPUSH
67962: LD_INT 2
67964: PUSH
67965: LD_INT 30
67967: PUSH
67968: LD_INT 6
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: PUSH
67975: LD_INT 30
67977: PUSH
67978: LD_INT 7
67980: PUSH
67981: EMPTY
67982: LIST
67983: LIST
67984: PUSH
67985: LD_INT 30
67987: PUSH
67988: LD_INT 8
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: LIST
67999: LIST
68000: PPUSH
68001: CALL_OW 72
68005: AND
68006: PUSH
68007: LD_EXP 31
68011: PUSH
68012: LD_VAR 0 1
68016: ARRAY
68017: PPUSH
68018: LD_INT 30
68020: PUSH
68021: LD_INT 3
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PPUSH
68028: CALL_OW 72
68032: AND
68033: IFFALSE 68767
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
68035: LD_ADDR_EXP 73
68039: PUSH
68040: LD_EXP 73
68044: PPUSH
68045: LD_VAR 0 1
68049: PPUSH
68050: LD_INT 3
68052: PPUSH
68053: CALL_OW 1
68057: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68058: LD_ADDR_VAR 0 2
68062: PUSH
68063: LD_INT 0
68065: PUSH
68066: LD_INT 0
68068: PUSH
68069: LD_INT 0
68071: PUSH
68072: LD_INT 0
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: ST_TO_ADDR
// if not eng then
68081: LD_VAR 0 6
68085: NOT
68086: IFFALSE 68149
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
68088: LD_ADDR_VAR 0 11
68092: PUSH
68093: LD_VAR 0 4
68097: PPUSH
68098: LD_INT 2
68100: PPUSH
68101: CALL 56090 0 2
68105: PUSH
68106: LD_INT 1
68108: ARRAY
68109: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
68110: LD_ADDR_VAR 0 2
68114: PUSH
68115: LD_VAR 0 2
68119: PPUSH
68120: LD_INT 2
68122: PPUSH
68123: LD_VAR 0 11
68127: PPUSH
68128: CALL_OW 1
68132: ST_TO_ADDR
// tmp := tmp diff p ;
68133: LD_ADDR_VAR 0 4
68137: PUSH
68138: LD_VAR 0 4
68142: PUSH
68143: LD_VAR 0 11
68147: DIFF
68148: ST_TO_ADDR
// end ; if tmp and sci < 6 then
68149: LD_VAR 0 4
68153: PUSH
68154: LD_VAR 0 8
68158: PUSH
68159: LD_INT 6
68161: LESS
68162: AND
68163: IFFALSE 68351
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
68165: LD_ADDR_VAR 0 9
68169: PUSH
68170: LD_VAR 0 4
68174: PUSH
68175: LD_VAR 0 8
68179: PUSH
68180: LD_VAR 0 7
68184: UNION
68185: DIFF
68186: PPUSH
68187: LD_INT 4
68189: PPUSH
68190: CALL 56090 0 2
68194: ST_TO_ADDR
// p := [ ] ;
68195: LD_ADDR_VAR 0 11
68199: PUSH
68200: EMPTY
68201: ST_TO_ADDR
// if sort then
68202: LD_VAR 0 9
68206: IFFALSE 68322
// for i = 1 to 6 - sci do
68208: LD_ADDR_VAR 0 3
68212: PUSH
68213: DOUBLE
68214: LD_INT 1
68216: DEC
68217: ST_TO_ADDR
68218: LD_INT 6
68220: PUSH
68221: LD_VAR 0 8
68225: MINUS
68226: PUSH
68227: FOR_TO
68228: IFFALSE 68320
// begin if i = sort then
68230: LD_VAR 0 3
68234: PUSH
68235: LD_VAR 0 9
68239: EQUAL
68240: IFFALSE 68244
// break ;
68242: GO 68320
// if GetClass ( i ) = 4 then
68244: LD_VAR 0 3
68248: PPUSH
68249: CALL_OW 257
68253: PUSH
68254: LD_INT 4
68256: EQUAL
68257: IFFALSE 68261
// continue ;
68259: GO 68227
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68261: LD_ADDR_VAR 0 11
68265: PUSH
68266: LD_VAR 0 11
68270: PPUSH
68271: LD_VAR 0 11
68275: PUSH
68276: LD_INT 1
68278: PLUS
68279: PPUSH
68280: LD_VAR 0 9
68284: PUSH
68285: LD_VAR 0 3
68289: ARRAY
68290: PPUSH
68291: CALL_OW 2
68295: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68296: LD_ADDR_VAR 0 4
68300: PUSH
68301: LD_VAR 0 4
68305: PUSH
68306: LD_VAR 0 9
68310: PUSH
68311: LD_VAR 0 3
68315: ARRAY
68316: DIFF
68317: ST_TO_ADDR
// end ;
68318: GO 68227
68320: POP
68321: POP
// if p then
68322: LD_VAR 0 11
68326: IFFALSE 68351
// result := Replace ( result , 4 , p ) ;
68328: LD_ADDR_VAR 0 2
68332: PUSH
68333: LD_VAR 0 2
68337: PPUSH
68338: LD_INT 4
68340: PPUSH
68341: LD_VAR 0 11
68345: PPUSH
68346: CALL_OW 1
68350: ST_TO_ADDR
// end ; if tmp and mech < 6 then
68351: LD_VAR 0 4
68355: PUSH
68356: LD_VAR 0 7
68360: PUSH
68361: LD_INT 6
68363: LESS
68364: AND
68365: IFFALSE 68553
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68367: LD_ADDR_VAR 0 9
68371: PUSH
68372: LD_VAR 0 4
68376: PUSH
68377: LD_VAR 0 8
68381: PUSH
68382: LD_VAR 0 7
68386: UNION
68387: DIFF
68388: PPUSH
68389: LD_INT 3
68391: PPUSH
68392: CALL 56090 0 2
68396: ST_TO_ADDR
// p := [ ] ;
68397: LD_ADDR_VAR 0 11
68401: PUSH
68402: EMPTY
68403: ST_TO_ADDR
// if sort then
68404: LD_VAR 0 9
68408: IFFALSE 68524
// for i = 1 to 6 - mech do
68410: LD_ADDR_VAR 0 3
68414: PUSH
68415: DOUBLE
68416: LD_INT 1
68418: DEC
68419: ST_TO_ADDR
68420: LD_INT 6
68422: PUSH
68423: LD_VAR 0 7
68427: MINUS
68428: PUSH
68429: FOR_TO
68430: IFFALSE 68522
// begin if i = sort then
68432: LD_VAR 0 3
68436: PUSH
68437: LD_VAR 0 9
68441: EQUAL
68442: IFFALSE 68446
// break ;
68444: GO 68522
// if GetClass ( i ) = 3 then
68446: LD_VAR 0 3
68450: PPUSH
68451: CALL_OW 257
68455: PUSH
68456: LD_INT 3
68458: EQUAL
68459: IFFALSE 68463
// continue ;
68461: GO 68429
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68463: LD_ADDR_VAR 0 11
68467: PUSH
68468: LD_VAR 0 11
68472: PPUSH
68473: LD_VAR 0 11
68477: PUSH
68478: LD_INT 1
68480: PLUS
68481: PPUSH
68482: LD_VAR 0 9
68486: PUSH
68487: LD_VAR 0 3
68491: ARRAY
68492: PPUSH
68493: CALL_OW 2
68497: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68498: LD_ADDR_VAR 0 4
68502: PUSH
68503: LD_VAR 0 4
68507: PUSH
68508: LD_VAR 0 9
68512: PUSH
68513: LD_VAR 0 3
68517: ARRAY
68518: DIFF
68519: ST_TO_ADDR
// end ;
68520: GO 68429
68522: POP
68523: POP
// if p then
68524: LD_VAR 0 11
68528: IFFALSE 68553
// result := Replace ( result , 3 , p ) ;
68530: LD_ADDR_VAR 0 2
68534: PUSH
68535: LD_VAR 0 2
68539: PPUSH
68540: LD_INT 3
68542: PPUSH
68543: LD_VAR 0 11
68547: PPUSH
68548: CALL_OW 1
68552: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
68553: LD_VAR 0 4
68557: PUSH
68558: LD_INT 6
68560: GREATER
68561: PUSH
68562: LD_VAR 0 6
68566: PUSH
68567: LD_INT 6
68569: LESS
68570: AND
68571: IFFALSE 68765
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68573: LD_ADDR_VAR 0 9
68577: PUSH
68578: LD_VAR 0 4
68582: PUSH
68583: LD_VAR 0 8
68587: PUSH
68588: LD_VAR 0 7
68592: UNION
68593: PUSH
68594: LD_VAR 0 6
68598: UNION
68599: DIFF
68600: PPUSH
68601: LD_INT 2
68603: PPUSH
68604: CALL 56090 0 2
68608: ST_TO_ADDR
// p := [ ] ;
68609: LD_ADDR_VAR 0 11
68613: PUSH
68614: EMPTY
68615: ST_TO_ADDR
// if sort then
68616: LD_VAR 0 9
68620: IFFALSE 68736
// for i = 1 to 6 - eng do
68622: LD_ADDR_VAR 0 3
68626: PUSH
68627: DOUBLE
68628: LD_INT 1
68630: DEC
68631: ST_TO_ADDR
68632: LD_INT 6
68634: PUSH
68635: LD_VAR 0 6
68639: MINUS
68640: PUSH
68641: FOR_TO
68642: IFFALSE 68734
// begin if i = sort then
68644: LD_VAR 0 3
68648: PUSH
68649: LD_VAR 0 9
68653: EQUAL
68654: IFFALSE 68658
// break ;
68656: GO 68734
// if GetClass ( i ) = 2 then
68658: LD_VAR 0 3
68662: PPUSH
68663: CALL_OW 257
68667: PUSH
68668: LD_INT 2
68670: EQUAL
68671: IFFALSE 68675
// continue ;
68673: GO 68641
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68675: LD_ADDR_VAR 0 11
68679: PUSH
68680: LD_VAR 0 11
68684: PPUSH
68685: LD_VAR 0 11
68689: PUSH
68690: LD_INT 1
68692: PLUS
68693: PPUSH
68694: LD_VAR 0 9
68698: PUSH
68699: LD_VAR 0 3
68703: ARRAY
68704: PPUSH
68705: CALL_OW 2
68709: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68710: LD_ADDR_VAR 0 4
68714: PUSH
68715: LD_VAR 0 4
68719: PUSH
68720: LD_VAR 0 9
68724: PUSH
68725: LD_VAR 0 3
68729: ARRAY
68730: DIFF
68731: ST_TO_ADDR
// end ;
68732: GO 68641
68734: POP
68735: POP
// if p then
68736: LD_VAR 0 11
68740: IFFALSE 68765
// result := Replace ( result , 2 , p ) ;
68742: LD_ADDR_VAR 0 2
68746: PUSH
68747: LD_VAR 0 2
68751: PPUSH
68752: LD_INT 2
68754: PPUSH
68755: LD_VAR 0 11
68759: PPUSH
68760: CALL_OW 1
68764: ST_TO_ADDR
// end ; exit ;
68765: GO 70153
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
68767: LD_EXP 58
68771: PUSH
68772: LD_EXP 57
68776: PUSH
68777: LD_VAR 0 1
68781: ARRAY
68782: ARRAY
68783: NOT
68784: PUSH
68785: LD_EXP 31
68789: PUSH
68790: LD_VAR 0 1
68794: ARRAY
68795: PPUSH
68796: LD_INT 30
68798: PUSH
68799: LD_INT 3
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PPUSH
68806: CALL_OW 72
68810: AND
68811: PUSH
68812: LD_EXP 36
68816: PUSH
68817: LD_VAR 0 1
68821: ARRAY
68822: AND
68823: IFFALSE 69431
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68825: LD_ADDR_EXP 73
68829: PUSH
68830: LD_EXP 73
68834: PPUSH
68835: LD_VAR 0 1
68839: PPUSH
68840: LD_INT 5
68842: PPUSH
68843: CALL_OW 1
68847: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68848: LD_ADDR_VAR 0 2
68852: PUSH
68853: LD_INT 0
68855: PUSH
68856: LD_INT 0
68858: PUSH
68859: LD_INT 0
68861: PUSH
68862: LD_INT 0
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: ST_TO_ADDR
// if sci > 1 then
68871: LD_VAR 0 8
68875: PUSH
68876: LD_INT 1
68878: GREATER
68879: IFFALSE 68907
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68881: LD_ADDR_VAR 0 4
68885: PUSH
68886: LD_VAR 0 4
68890: PUSH
68891: LD_VAR 0 8
68895: PUSH
68896: LD_VAR 0 8
68900: PUSH
68901: LD_INT 1
68903: ARRAY
68904: DIFF
68905: DIFF
68906: ST_TO_ADDR
// if tmp and not sci then
68907: LD_VAR 0 4
68911: PUSH
68912: LD_VAR 0 8
68916: NOT
68917: AND
68918: IFFALSE 68987
// begin sort := SortBySkill ( tmp , 4 ) ;
68920: LD_ADDR_VAR 0 9
68924: PUSH
68925: LD_VAR 0 4
68929: PPUSH
68930: LD_INT 4
68932: PPUSH
68933: CALL 56090 0 2
68937: ST_TO_ADDR
// if sort then
68938: LD_VAR 0 9
68942: IFFALSE 68958
// p := sort [ 1 ] ;
68944: LD_ADDR_VAR 0 11
68948: PUSH
68949: LD_VAR 0 9
68953: PUSH
68954: LD_INT 1
68956: ARRAY
68957: ST_TO_ADDR
// if p then
68958: LD_VAR 0 11
68962: IFFALSE 68987
// result := Replace ( result , 4 , p ) ;
68964: LD_ADDR_VAR 0 2
68968: PUSH
68969: LD_VAR 0 2
68973: PPUSH
68974: LD_INT 4
68976: PPUSH
68977: LD_VAR 0 11
68981: PPUSH
68982: CALL_OW 1
68986: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68987: LD_ADDR_VAR 0 4
68991: PUSH
68992: LD_VAR 0 4
68996: PUSH
68997: LD_VAR 0 7
69001: DIFF
69002: ST_TO_ADDR
// if tmp and mech < 6 then
69003: LD_VAR 0 4
69007: PUSH
69008: LD_VAR 0 7
69012: PUSH
69013: LD_INT 6
69015: LESS
69016: AND
69017: IFFALSE 69205
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
69019: LD_ADDR_VAR 0 9
69023: PUSH
69024: LD_VAR 0 4
69028: PUSH
69029: LD_VAR 0 8
69033: PUSH
69034: LD_VAR 0 7
69038: UNION
69039: DIFF
69040: PPUSH
69041: LD_INT 3
69043: PPUSH
69044: CALL 56090 0 2
69048: ST_TO_ADDR
// p := [ ] ;
69049: LD_ADDR_VAR 0 11
69053: PUSH
69054: EMPTY
69055: ST_TO_ADDR
// if sort then
69056: LD_VAR 0 9
69060: IFFALSE 69176
// for i = 1 to 6 - mech do
69062: LD_ADDR_VAR 0 3
69066: PUSH
69067: DOUBLE
69068: LD_INT 1
69070: DEC
69071: ST_TO_ADDR
69072: LD_INT 6
69074: PUSH
69075: LD_VAR 0 7
69079: MINUS
69080: PUSH
69081: FOR_TO
69082: IFFALSE 69174
// begin if i = sort then
69084: LD_VAR 0 3
69088: PUSH
69089: LD_VAR 0 9
69093: EQUAL
69094: IFFALSE 69098
// break ;
69096: GO 69174
// if GetClass ( i ) = 3 then
69098: LD_VAR 0 3
69102: PPUSH
69103: CALL_OW 257
69107: PUSH
69108: LD_INT 3
69110: EQUAL
69111: IFFALSE 69115
// continue ;
69113: GO 69081
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69115: LD_ADDR_VAR 0 11
69119: PUSH
69120: LD_VAR 0 11
69124: PPUSH
69125: LD_VAR 0 11
69129: PUSH
69130: LD_INT 1
69132: PLUS
69133: PPUSH
69134: LD_VAR 0 9
69138: PUSH
69139: LD_VAR 0 3
69143: ARRAY
69144: PPUSH
69145: CALL_OW 2
69149: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69150: LD_ADDR_VAR 0 4
69154: PUSH
69155: LD_VAR 0 4
69159: PUSH
69160: LD_VAR 0 9
69164: PUSH
69165: LD_VAR 0 3
69169: ARRAY
69170: DIFF
69171: ST_TO_ADDR
// end ;
69172: GO 69081
69174: POP
69175: POP
// if p then
69176: LD_VAR 0 11
69180: IFFALSE 69205
// result := Replace ( result , 3 , p ) ;
69182: LD_ADDR_VAR 0 2
69186: PUSH
69187: LD_VAR 0 2
69191: PPUSH
69192: LD_INT 3
69194: PPUSH
69195: LD_VAR 0 11
69199: PPUSH
69200: CALL_OW 1
69204: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69205: LD_ADDR_VAR 0 4
69209: PUSH
69210: LD_VAR 0 4
69214: PUSH
69215: LD_VAR 0 6
69219: DIFF
69220: ST_TO_ADDR
// if tmp and eng < 6 then
69221: LD_VAR 0 4
69225: PUSH
69226: LD_VAR 0 6
69230: PUSH
69231: LD_INT 6
69233: LESS
69234: AND
69235: IFFALSE 69429
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
69237: LD_ADDR_VAR 0 9
69241: PUSH
69242: LD_VAR 0 4
69246: PUSH
69247: LD_VAR 0 8
69251: PUSH
69252: LD_VAR 0 7
69256: UNION
69257: PUSH
69258: LD_VAR 0 6
69262: UNION
69263: DIFF
69264: PPUSH
69265: LD_INT 2
69267: PPUSH
69268: CALL 56090 0 2
69272: ST_TO_ADDR
// p := [ ] ;
69273: LD_ADDR_VAR 0 11
69277: PUSH
69278: EMPTY
69279: ST_TO_ADDR
// if sort then
69280: LD_VAR 0 9
69284: IFFALSE 69400
// for i = 1 to 6 - eng do
69286: LD_ADDR_VAR 0 3
69290: PUSH
69291: DOUBLE
69292: LD_INT 1
69294: DEC
69295: ST_TO_ADDR
69296: LD_INT 6
69298: PUSH
69299: LD_VAR 0 6
69303: MINUS
69304: PUSH
69305: FOR_TO
69306: IFFALSE 69398
// begin if i = sort then
69308: LD_VAR 0 3
69312: PUSH
69313: LD_VAR 0 9
69317: EQUAL
69318: IFFALSE 69322
// break ;
69320: GO 69398
// if GetClass ( i ) = 2 then
69322: LD_VAR 0 3
69326: PPUSH
69327: CALL_OW 257
69331: PUSH
69332: LD_INT 2
69334: EQUAL
69335: IFFALSE 69339
// continue ;
69337: GO 69305
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69339: LD_ADDR_VAR 0 11
69343: PUSH
69344: LD_VAR 0 11
69348: PPUSH
69349: LD_VAR 0 11
69353: PUSH
69354: LD_INT 1
69356: PLUS
69357: PPUSH
69358: LD_VAR 0 9
69362: PUSH
69363: LD_VAR 0 3
69367: ARRAY
69368: PPUSH
69369: CALL_OW 2
69373: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69374: LD_ADDR_VAR 0 4
69378: PUSH
69379: LD_VAR 0 4
69383: PUSH
69384: LD_VAR 0 9
69388: PUSH
69389: LD_VAR 0 3
69393: ARRAY
69394: DIFF
69395: ST_TO_ADDR
// end ;
69396: GO 69305
69398: POP
69399: POP
// if p then
69400: LD_VAR 0 11
69404: IFFALSE 69429
// result := Replace ( result , 2 , p ) ;
69406: LD_ADDR_VAR 0 2
69410: PUSH
69411: LD_VAR 0 2
69415: PPUSH
69416: LD_INT 2
69418: PPUSH
69419: LD_VAR 0 11
69423: PPUSH
69424: CALL_OW 1
69428: ST_TO_ADDR
// end ; exit ;
69429: GO 70153
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
69431: LD_EXP 58
69435: PUSH
69436: LD_EXP 57
69440: PUSH
69441: LD_VAR 0 1
69445: ARRAY
69446: ARRAY
69447: NOT
69448: PUSH
69449: LD_EXP 31
69453: PUSH
69454: LD_VAR 0 1
69458: ARRAY
69459: PPUSH
69460: LD_INT 30
69462: PUSH
69463: LD_INT 3
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PPUSH
69470: CALL_OW 72
69474: AND
69475: PUSH
69476: LD_EXP 36
69480: PUSH
69481: LD_VAR 0 1
69485: ARRAY
69486: NOT
69487: AND
69488: IFFALSE 70153
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
69490: LD_ADDR_EXP 73
69494: PUSH
69495: LD_EXP 73
69499: PPUSH
69500: LD_VAR 0 1
69504: PPUSH
69505: LD_INT 6
69507: PPUSH
69508: CALL_OW 1
69512: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
69513: LD_ADDR_VAR 0 2
69517: PUSH
69518: LD_INT 0
69520: PUSH
69521: LD_INT 0
69523: PUSH
69524: LD_INT 0
69526: PUSH
69527: LD_INT 0
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: LIST
69534: LIST
69535: ST_TO_ADDR
// if sci >= 1 then
69536: LD_VAR 0 8
69540: PUSH
69541: LD_INT 1
69543: GREATEREQUAL
69544: IFFALSE 69566
// tmp := tmp diff sci [ 1 ] ;
69546: LD_ADDR_VAR 0 4
69550: PUSH
69551: LD_VAR 0 4
69555: PUSH
69556: LD_VAR 0 8
69560: PUSH
69561: LD_INT 1
69563: ARRAY
69564: DIFF
69565: ST_TO_ADDR
// if tmp and not sci then
69566: LD_VAR 0 4
69570: PUSH
69571: LD_VAR 0 8
69575: NOT
69576: AND
69577: IFFALSE 69646
// begin sort := SortBySkill ( tmp , 4 ) ;
69579: LD_ADDR_VAR 0 9
69583: PUSH
69584: LD_VAR 0 4
69588: PPUSH
69589: LD_INT 4
69591: PPUSH
69592: CALL 56090 0 2
69596: ST_TO_ADDR
// if sort then
69597: LD_VAR 0 9
69601: IFFALSE 69617
// p := sort [ 1 ] ;
69603: LD_ADDR_VAR 0 11
69607: PUSH
69608: LD_VAR 0 9
69612: PUSH
69613: LD_INT 1
69615: ARRAY
69616: ST_TO_ADDR
// if p then
69617: LD_VAR 0 11
69621: IFFALSE 69646
// result := Replace ( result , 4 , p ) ;
69623: LD_ADDR_VAR 0 2
69627: PUSH
69628: LD_VAR 0 2
69632: PPUSH
69633: LD_INT 4
69635: PPUSH
69636: LD_VAR 0 11
69640: PPUSH
69641: CALL_OW 1
69645: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69646: LD_ADDR_VAR 0 4
69650: PUSH
69651: LD_VAR 0 4
69655: PUSH
69656: LD_VAR 0 7
69660: DIFF
69661: ST_TO_ADDR
// if tmp and mech < 6 then
69662: LD_VAR 0 4
69666: PUSH
69667: LD_VAR 0 7
69671: PUSH
69672: LD_INT 6
69674: LESS
69675: AND
69676: IFFALSE 69858
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
69678: LD_ADDR_VAR 0 9
69682: PUSH
69683: LD_VAR 0 4
69687: PUSH
69688: LD_VAR 0 7
69692: DIFF
69693: PPUSH
69694: LD_INT 3
69696: PPUSH
69697: CALL 56090 0 2
69701: ST_TO_ADDR
// p := [ ] ;
69702: LD_ADDR_VAR 0 11
69706: PUSH
69707: EMPTY
69708: ST_TO_ADDR
// if sort then
69709: LD_VAR 0 9
69713: IFFALSE 69829
// for i = 1 to 6 - mech do
69715: LD_ADDR_VAR 0 3
69719: PUSH
69720: DOUBLE
69721: LD_INT 1
69723: DEC
69724: ST_TO_ADDR
69725: LD_INT 6
69727: PUSH
69728: LD_VAR 0 7
69732: MINUS
69733: PUSH
69734: FOR_TO
69735: IFFALSE 69827
// begin if i = sort then
69737: LD_VAR 0 3
69741: PUSH
69742: LD_VAR 0 9
69746: EQUAL
69747: IFFALSE 69751
// break ;
69749: GO 69827
// if GetClass ( i ) = 3 then
69751: LD_VAR 0 3
69755: PPUSH
69756: CALL_OW 257
69760: PUSH
69761: LD_INT 3
69763: EQUAL
69764: IFFALSE 69768
// continue ;
69766: GO 69734
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69768: LD_ADDR_VAR 0 11
69772: PUSH
69773: LD_VAR 0 11
69777: PPUSH
69778: LD_VAR 0 11
69782: PUSH
69783: LD_INT 1
69785: PLUS
69786: PPUSH
69787: LD_VAR 0 9
69791: PUSH
69792: LD_VAR 0 3
69796: ARRAY
69797: PPUSH
69798: CALL_OW 2
69802: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69803: LD_ADDR_VAR 0 4
69807: PUSH
69808: LD_VAR 0 4
69812: PUSH
69813: LD_VAR 0 9
69817: PUSH
69818: LD_VAR 0 3
69822: ARRAY
69823: DIFF
69824: ST_TO_ADDR
// end ;
69825: GO 69734
69827: POP
69828: POP
// if p then
69829: LD_VAR 0 11
69833: IFFALSE 69858
// result := Replace ( result , 3 , p ) ;
69835: LD_ADDR_VAR 0 2
69839: PUSH
69840: LD_VAR 0 2
69844: PPUSH
69845: LD_INT 3
69847: PPUSH
69848: LD_VAR 0 11
69852: PPUSH
69853: CALL_OW 1
69857: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69858: LD_ADDR_VAR 0 4
69862: PUSH
69863: LD_VAR 0 4
69867: PUSH
69868: LD_VAR 0 6
69872: DIFF
69873: ST_TO_ADDR
// if tmp and eng < 4 then
69874: LD_VAR 0 4
69878: PUSH
69879: LD_VAR 0 6
69883: PUSH
69884: LD_INT 4
69886: LESS
69887: AND
69888: IFFALSE 70078
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69890: LD_ADDR_VAR 0 9
69894: PUSH
69895: LD_VAR 0 4
69899: PUSH
69900: LD_VAR 0 7
69904: PUSH
69905: LD_VAR 0 6
69909: UNION
69910: DIFF
69911: PPUSH
69912: LD_INT 2
69914: PPUSH
69915: CALL 56090 0 2
69919: ST_TO_ADDR
// p := [ ] ;
69920: LD_ADDR_VAR 0 11
69924: PUSH
69925: EMPTY
69926: ST_TO_ADDR
// if sort then
69927: LD_VAR 0 9
69931: IFFALSE 70047
// for i = 1 to 4 - eng do
69933: LD_ADDR_VAR 0 3
69937: PUSH
69938: DOUBLE
69939: LD_INT 1
69941: DEC
69942: ST_TO_ADDR
69943: LD_INT 4
69945: PUSH
69946: LD_VAR 0 6
69950: MINUS
69951: PUSH
69952: FOR_TO
69953: IFFALSE 70045
// begin if i = sort then
69955: LD_VAR 0 3
69959: PUSH
69960: LD_VAR 0 9
69964: EQUAL
69965: IFFALSE 69969
// break ;
69967: GO 70045
// if GetClass ( i ) = 2 then
69969: LD_VAR 0 3
69973: PPUSH
69974: CALL_OW 257
69978: PUSH
69979: LD_INT 2
69981: EQUAL
69982: IFFALSE 69986
// continue ;
69984: GO 69952
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69986: LD_ADDR_VAR 0 11
69990: PUSH
69991: LD_VAR 0 11
69995: PPUSH
69996: LD_VAR 0 11
70000: PUSH
70001: LD_INT 1
70003: PLUS
70004: PPUSH
70005: LD_VAR 0 9
70009: PUSH
70010: LD_VAR 0 3
70014: ARRAY
70015: PPUSH
70016: CALL_OW 2
70020: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70021: LD_ADDR_VAR 0 4
70025: PUSH
70026: LD_VAR 0 4
70030: PUSH
70031: LD_VAR 0 9
70035: PUSH
70036: LD_VAR 0 3
70040: ARRAY
70041: DIFF
70042: ST_TO_ADDR
// end ;
70043: GO 69952
70045: POP
70046: POP
// if p then
70047: LD_VAR 0 11
70051: IFFALSE 70076
// result := Replace ( result , 2 , p ) ;
70053: LD_ADDR_VAR 0 2
70057: PUSH
70058: LD_VAR 0 2
70062: PPUSH
70063: LD_INT 2
70065: PPUSH
70066: LD_VAR 0 11
70070: PPUSH
70071: CALL_OW 1
70075: ST_TO_ADDR
// end else
70076: GO 70122
// for i = eng downto 5 do
70078: LD_ADDR_VAR 0 3
70082: PUSH
70083: DOUBLE
70084: LD_VAR 0 6
70088: INC
70089: ST_TO_ADDR
70090: LD_INT 5
70092: PUSH
70093: FOR_DOWNTO
70094: IFFALSE 70120
// tmp := tmp union eng [ i ] ;
70096: LD_ADDR_VAR 0 4
70100: PUSH
70101: LD_VAR 0 4
70105: PUSH
70106: LD_VAR 0 6
70110: PUSH
70111: LD_VAR 0 3
70115: ARRAY
70116: UNION
70117: ST_TO_ADDR
70118: GO 70093
70120: POP
70121: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
70122: LD_ADDR_VAR 0 2
70126: PUSH
70127: LD_VAR 0 2
70131: PPUSH
70132: LD_INT 1
70134: PPUSH
70135: LD_VAR 0 4
70139: PUSH
70140: LD_VAR 0 5
70144: DIFF
70145: PPUSH
70146: CALL_OW 1
70150: ST_TO_ADDR
// exit ;
70151: GO 70153
// end ; end ;
70153: LD_VAR 0 2
70157: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
70158: LD_INT 0
70160: PPUSH
70161: PPUSH
70162: PPUSH
// if not mc_bases then
70163: LD_EXP 31
70167: NOT
70168: IFFALSE 70172
// exit ;
70170: GO 70314
// for i = 1 to mc_bases do
70172: LD_ADDR_VAR 0 2
70176: PUSH
70177: DOUBLE
70178: LD_INT 1
70180: DEC
70181: ST_TO_ADDR
70182: LD_EXP 31
70186: PUSH
70187: FOR_TO
70188: IFFALSE 70305
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70190: LD_ADDR_VAR 0 3
70194: PUSH
70195: LD_EXP 31
70199: PUSH
70200: LD_VAR 0 2
70204: ARRAY
70205: PPUSH
70206: LD_INT 21
70208: PUSH
70209: LD_INT 3
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 3
70218: PUSH
70219: LD_INT 2
70221: PUSH
70222: LD_INT 30
70224: PUSH
70225: LD_INT 29
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 30
70234: PUSH
70235: LD_INT 30
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: LIST
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: PUSH
70251: LD_INT 3
70253: PUSH
70254: LD_INT 24
70256: PUSH
70257: LD_INT 1000
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: LIST
70272: PPUSH
70273: CALL_OW 72
70277: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
70278: LD_ADDR_EXP 32
70282: PUSH
70283: LD_EXP 32
70287: PPUSH
70288: LD_VAR 0 2
70292: PPUSH
70293: LD_VAR 0 3
70297: PPUSH
70298: CALL_OW 1
70302: ST_TO_ADDR
// end ;
70303: GO 70187
70305: POP
70306: POP
// RaiseSailEvent ( 101 ) ;
70307: LD_INT 101
70309: PPUSH
70310: CALL_OW 427
// end ;
70314: LD_VAR 0 1
70318: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
70319: LD_INT 0
70321: PPUSH
70322: PPUSH
70323: PPUSH
70324: PPUSH
70325: PPUSH
70326: PPUSH
70327: PPUSH
// if not mc_bases then
70328: LD_EXP 31
70332: NOT
70333: IFFALSE 70337
// exit ;
70335: GO 70899
// for i = 1 to mc_bases do
70337: LD_ADDR_VAR 0 2
70341: PUSH
70342: DOUBLE
70343: LD_INT 1
70345: DEC
70346: ST_TO_ADDR
70347: LD_EXP 31
70351: PUSH
70352: FOR_TO
70353: IFFALSE 70890
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
70355: LD_ADDR_VAR 0 5
70359: PUSH
70360: LD_EXP 31
70364: PUSH
70365: LD_VAR 0 2
70369: ARRAY
70370: PUSH
70371: LD_EXP 60
70375: PUSH
70376: LD_VAR 0 2
70380: ARRAY
70381: UNION
70382: PPUSH
70383: LD_INT 21
70385: PUSH
70386: LD_INT 1
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PUSH
70393: LD_INT 1
70395: PUSH
70396: LD_INT 3
70398: PUSH
70399: LD_INT 54
70401: PUSH
70402: EMPTY
70403: LIST
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 3
70411: PUSH
70412: LD_INT 24
70414: PUSH
70415: LD_INT 1000
70417: PUSH
70418: EMPTY
70419: LIST
70420: LIST
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: LIST
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PPUSH
70435: CALL_OW 72
70439: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
70440: LD_ADDR_VAR 0 6
70444: PUSH
70445: LD_EXP 31
70449: PUSH
70450: LD_VAR 0 2
70454: ARRAY
70455: PPUSH
70456: LD_INT 21
70458: PUSH
70459: LD_INT 1
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 1
70468: PUSH
70469: LD_INT 3
70471: PUSH
70472: LD_INT 54
70474: PUSH
70475: EMPTY
70476: LIST
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: PUSH
70482: LD_INT 3
70484: PUSH
70485: LD_INT 24
70487: PUSH
70488: LD_INT 250
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: LIST
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PPUSH
70508: CALL_OW 72
70512: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
70513: LD_ADDR_VAR 0 7
70517: PUSH
70518: LD_VAR 0 5
70522: PUSH
70523: LD_VAR 0 6
70527: DIFF
70528: ST_TO_ADDR
// if not need_heal_1 then
70529: LD_VAR 0 6
70533: NOT
70534: IFFALSE 70567
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
70536: LD_ADDR_EXP 34
70540: PUSH
70541: LD_EXP 34
70545: PPUSH
70546: LD_VAR 0 2
70550: PUSH
70551: LD_INT 1
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PPUSH
70558: EMPTY
70559: PPUSH
70560: CALL 24846 0 3
70564: ST_TO_ADDR
70565: GO 70637
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
70567: LD_ADDR_EXP 34
70571: PUSH
70572: LD_EXP 34
70576: PPUSH
70577: LD_VAR 0 2
70581: PUSH
70582: LD_INT 1
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PPUSH
70589: LD_EXP 34
70593: PUSH
70594: LD_VAR 0 2
70598: ARRAY
70599: PUSH
70600: LD_INT 1
70602: ARRAY
70603: PPUSH
70604: LD_INT 3
70606: PUSH
70607: LD_INT 24
70609: PUSH
70610: LD_INT 1000
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PPUSH
70621: CALL_OW 72
70625: PUSH
70626: LD_VAR 0 6
70630: UNION
70631: PPUSH
70632: CALL 24846 0 3
70636: ST_TO_ADDR
// if not need_heal_2 then
70637: LD_VAR 0 7
70641: NOT
70642: IFFALSE 70675
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
70644: LD_ADDR_EXP 34
70648: PUSH
70649: LD_EXP 34
70653: PPUSH
70654: LD_VAR 0 2
70658: PUSH
70659: LD_INT 2
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PPUSH
70666: EMPTY
70667: PPUSH
70668: CALL 24846 0 3
70672: ST_TO_ADDR
70673: GO 70707
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
70675: LD_ADDR_EXP 34
70679: PUSH
70680: LD_EXP 34
70684: PPUSH
70685: LD_VAR 0 2
70689: PUSH
70690: LD_INT 2
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PPUSH
70697: LD_VAR 0 7
70701: PPUSH
70702: CALL 24846 0 3
70706: ST_TO_ADDR
// if need_heal_2 then
70707: LD_VAR 0 7
70711: IFFALSE 70872
// for j in need_heal_2 do
70713: LD_ADDR_VAR 0 3
70717: PUSH
70718: LD_VAR 0 7
70722: PUSH
70723: FOR_IN
70724: IFFALSE 70870
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70726: LD_ADDR_VAR 0 5
70730: PUSH
70731: LD_EXP 31
70735: PUSH
70736: LD_VAR 0 2
70740: ARRAY
70741: PPUSH
70742: LD_INT 2
70744: PUSH
70745: LD_INT 30
70747: PUSH
70748: LD_INT 6
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 30
70757: PUSH
70758: LD_INT 7
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 30
70767: PUSH
70768: LD_INT 8
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: LD_INT 30
70777: PUSH
70778: LD_INT 0
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PUSH
70785: LD_INT 30
70787: PUSH
70788: LD_INT 1
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: PPUSH
70803: CALL_OW 72
70807: ST_TO_ADDR
// if tmp then
70808: LD_VAR 0 5
70812: IFFALSE 70868
// begin k := NearestUnitToUnit ( tmp , j ) ;
70814: LD_ADDR_VAR 0 4
70818: PUSH
70819: LD_VAR 0 5
70823: PPUSH
70824: LD_VAR 0 3
70828: PPUSH
70829: CALL_OW 74
70833: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70834: LD_VAR 0 3
70838: PPUSH
70839: LD_VAR 0 4
70843: PPUSH
70844: CALL_OW 296
70848: PUSH
70849: LD_INT 5
70851: GREATER
70852: IFFALSE 70868
// ComMoveToNearbyEntrance ( j , k ) ;
70854: LD_VAR 0 3
70858: PPUSH
70859: LD_VAR 0 4
70863: PPUSH
70864: CALL 58463 0 2
// end ; end ;
70868: GO 70723
70870: POP
70871: POP
// if not need_heal_1 and not need_heal_2 then
70872: LD_VAR 0 6
70876: NOT
70877: PUSH
70878: LD_VAR 0 7
70882: NOT
70883: AND
70884: IFFALSE 70888
// continue ;
70886: GO 70352
// end ;
70888: GO 70352
70890: POP
70891: POP
// RaiseSailEvent ( 102 ) ;
70892: LD_INT 102
70894: PPUSH
70895: CALL_OW 427
// end ;
70899: LD_VAR 0 1
70903: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70904: LD_INT 0
70906: PPUSH
70907: PPUSH
70908: PPUSH
70909: PPUSH
70910: PPUSH
70911: PPUSH
70912: PPUSH
70913: PPUSH
// if not mc_bases then
70914: LD_EXP 31
70918: NOT
70919: IFFALSE 70923
// exit ;
70921: GO 71834
// for i = 1 to mc_bases do
70923: LD_ADDR_VAR 0 2
70927: PUSH
70928: DOUBLE
70929: LD_INT 1
70931: DEC
70932: ST_TO_ADDR
70933: LD_EXP 31
70937: PUSH
70938: FOR_TO
70939: IFFALSE 71832
// begin if not mc_building_need_repair [ i ] then
70941: LD_EXP 32
70945: PUSH
70946: LD_VAR 0 2
70950: ARRAY
70951: NOT
70952: IFFALSE 71137
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70954: LD_ADDR_VAR 0 6
70958: PUSH
70959: LD_EXP 50
70963: PUSH
70964: LD_VAR 0 2
70968: ARRAY
70969: PPUSH
70970: LD_INT 3
70972: PUSH
70973: LD_INT 24
70975: PUSH
70976: LD_INT 1000
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 2
70989: PUSH
70990: LD_INT 34
70992: PUSH
70993: LD_INT 13
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PUSH
71000: LD_INT 34
71002: PUSH
71003: LD_INT 52
71005: PUSH
71006: EMPTY
71007: LIST
71008: LIST
71009: PUSH
71010: LD_INT 34
71012: PUSH
71013: LD_INT 88
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: EMPTY
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PPUSH
71030: CALL_OW 72
71034: ST_TO_ADDR
// if cranes then
71035: LD_VAR 0 6
71039: IFFALSE 71101
// for j in cranes do
71041: LD_ADDR_VAR 0 3
71045: PUSH
71046: LD_VAR 0 6
71050: PUSH
71051: FOR_IN
71052: IFFALSE 71099
// if not IsInArea ( j , mc_parking [ i ] ) then
71054: LD_VAR 0 3
71058: PPUSH
71059: LD_EXP 55
71063: PUSH
71064: LD_VAR 0 2
71068: ARRAY
71069: PPUSH
71070: CALL_OW 308
71074: NOT
71075: IFFALSE 71097
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71077: LD_VAR 0 3
71081: PPUSH
71082: LD_EXP 55
71086: PUSH
71087: LD_VAR 0 2
71091: ARRAY
71092: PPUSH
71093: CALL_OW 113
71097: GO 71051
71099: POP
71100: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
71101: LD_ADDR_EXP 33
71105: PUSH
71106: LD_EXP 33
71110: PPUSH
71111: LD_VAR 0 2
71115: PPUSH
71116: EMPTY
71117: PPUSH
71118: CALL_OW 1
71122: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
71123: LD_VAR 0 2
71127: PPUSH
71128: LD_INT 101
71130: PPUSH
71131: CALL 65977 0 2
// continue ;
71135: GO 70938
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
71137: LD_ADDR_EXP 37
71141: PUSH
71142: LD_EXP 37
71146: PPUSH
71147: LD_VAR 0 2
71151: PPUSH
71152: EMPTY
71153: PPUSH
71154: CALL_OW 1
71158: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71159: LD_VAR 0 2
71163: PPUSH
71164: LD_INT 103
71166: PPUSH
71167: CALL 65977 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
71171: LD_ADDR_VAR 0 5
71175: PUSH
71176: LD_EXP 31
71180: PUSH
71181: LD_VAR 0 2
71185: ARRAY
71186: PUSH
71187: LD_EXP 60
71191: PUSH
71192: LD_VAR 0 2
71196: ARRAY
71197: UNION
71198: PPUSH
71199: LD_INT 2
71201: PUSH
71202: LD_INT 25
71204: PUSH
71205: LD_INT 2
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 25
71214: PUSH
71215: LD_INT 16
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: EMPTY
71223: LIST
71224: LIST
71225: LIST
71226: PUSH
71227: EMPTY
71228: LIST
71229: PPUSH
71230: CALL_OW 72
71234: ST_TO_ADDR
// if mc_need_heal [ i ] then
71235: LD_EXP 34
71239: PUSH
71240: LD_VAR 0 2
71244: ARRAY
71245: IFFALSE 71289
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
71247: LD_ADDR_VAR 0 5
71251: PUSH
71252: LD_VAR 0 5
71256: PUSH
71257: LD_EXP 34
71261: PUSH
71262: LD_VAR 0 2
71266: ARRAY
71267: PUSH
71268: LD_INT 1
71270: ARRAY
71271: PUSH
71272: LD_EXP 34
71276: PUSH
71277: LD_VAR 0 2
71281: ARRAY
71282: PUSH
71283: LD_INT 2
71285: ARRAY
71286: UNION
71287: DIFF
71288: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
71289: LD_ADDR_VAR 0 6
71293: PUSH
71294: LD_EXP 50
71298: PUSH
71299: LD_VAR 0 2
71303: ARRAY
71304: PPUSH
71305: LD_INT 2
71307: PUSH
71308: LD_INT 34
71310: PUSH
71311: LD_INT 13
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 34
71320: PUSH
71321: LD_INT 52
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 34
71330: PUSH
71331: LD_INT 88
71333: PUSH
71334: EMPTY
71335: LIST
71336: LIST
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: PPUSH
71344: CALL_OW 72
71348: ST_TO_ADDR
// if cranes then
71349: LD_VAR 0 6
71353: IFFALSE 71521
// begin for j in cranes do
71355: LD_ADDR_VAR 0 3
71359: PUSH
71360: LD_VAR 0 6
71364: PUSH
71365: FOR_IN
71366: IFFALSE 71519
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
71368: LD_VAR 0 3
71372: PPUSH
71373: CALL_OW 256
71377: PUSH
71378: LD_INT 1000
71380: EQUAL
71381: PUSH
71382: LD_VAR 0 3
71386: PPUSH
71387: CALL_OW 314
71391: NOT
71392: AND
71393: IFFALSE 71459
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
71395: LD_ADDR_VAR 0 8
71399: PUSH
71400: LD_EXP 32
71404: PUSH
71405: LD_VAR 0 2
71409: ARRAY
71410: PPUSH
71411: LD_VAR 0 3
71415: PPUSH
71416: CALL_OW 74
71420: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
71421: LD_VAR 0 8
71425: PPUSH
71426: LD_INT 16
71428: PPUSH
71429: CALL 27811 0 2
71433: PUSH
71434: LD_INT 4
71436: ARRAY
71437: PUSH
71438: LD_INT 10
71440: LESS
71441: IFFALSE 71457
// ComRepairBuilding ( j , to_repair ) ;
71443: LD_VAR 0 3
71447: PPUSH
71448: LD_VAR 0 8
71452: PPUSH
71453: CALL_OW 130
// end else
71457: GO 71517
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
71459: LD_VAR 0 3
71463: PPUSH
71464: CALL_OW 256
71468: PUSH
71469: LD_INT 500
71471: LESS
71472: PUSH
71473: LD_VAR 0 3
71477: PPUSH
71478: LD_EXP 55
71482: PUSH
71483: LD_VAR 0 2
71487: ARRAY
71488: PPUSH
71489: CALL_OW 308
71493: NOT
71494: AND
71495: IFFALSE 71517
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71497: LD_VAR 0 3
71501: PPUSH
71502: LD_EXP 55
71506: PUSH
71507: LD_VAR 0 2
71511: ARRAY
71512: PPUSH
71513: CALL_OW 113
// end ;
71517: GO 71365
71519: POP
71520: POP
// end ; if tmp > 3 then
71521: LD_VAR 0 5
71525: PUSH
71526: LD_INT 3
71528: GREATER
71529: IFFALSE 71549
// tmp := ShrinkArray ( tmp , 4 ) ;
71531: LD_ADDR_VAR 0 5
71535: PUSH
71536: LD_VAR 0 5
71540: PPUSH
71541: LD_INT 4
71543: PPUSH
71544: CALL 57901 0 2
71548: ST_TO_ADDR
// if not tmp then
71549: LD_VAR 0 5
71553: NOT
71554: IFFALSE 71558
// continue ;
71556: GO 70938
// for j in tmp do
71558: LD_ADDR_VAR 0 3
71562: PUSH
71563: LD_VAR 0 5
71567: PUSH
71568: FOR_IN
71569: IFFALSE 71828
// begin if IsInUnit ( j ) then
71571: LD_VAR 0 3
71575: PPUSH
71576: CALL_OW 310
71580: IFFALSE 71591
// ComExitBuilding ( j ) ;
71582: LD_VAR 0 3
71586: PPUSH
71587: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
71591: LD_VAR 0 3
71595: PUSH
71596: LD_EXP 33
71600: PUSH
71601: LD_VAR 0 2
71605: ARRAY
71606: IN
71607: NOT
71608: IFFALSE 71666
// begin SetTag ( j , 101 ) ;
71610: LD_VAR 0 3
71614: PPUSH
71615: LD_INT 101
71617: PPUSH
71618: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
71622: LD_ADDR_EXP 33
71626: PUSH
71627: LD_EXP 33
71631: PPUSH
71632: LD_VAR 0 2
71636: PUSH
71637: LD_EXP 33
71641: PUSH
71642: LD_VAR 0 2
71646: ARRAY
71647: PUSH
71648: LD_INT 1
71650: PLUS
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PPUSH
71656: LD_VAR 0 3
71660: PPUSH
71661: CALL 24846 0 3
71665: ST_TO_ADDR
// end ; wait ( 1 ) ;
71666: LD_INT 1
71668: PPUSH
71669: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
71673: LD_ADDR_VAR 0 7
71677: PUSH
71678: LD_EXP 32
71682: PUSH
71683: LD_VAR 0 2
71687: ARRAY
71688: ST_TO_ADDR
// if mc_scan [ i ] then
71689: LD_EXP 54
71693: PUSH
71694: LD_VAR 0 2
71698: ARRAY
71699: IFFALSE 71761
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
71701: LD_ADDR_VAR 0 7
71705: PUSH
71706: LD_EXP 32
71710: PUSH
71711: LD_VAR 0 2
71715: ARRAY
71716: PPUSH
71717: LD_INT 3
71719: PUSH
71720: LD_INT 30
71722: PUSH
71723: LD_INT 32
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 30
71732: PUSH
71733: LD_INT 33
71735: PUSH
71736: EMPTY
71737: LIST
71738: LIST
71739: PUSH
71740: LD_INT 30
71742: PUSH
71743: LD_INT 31
71745: PUSH
71746: EMPTY
71747: LIST
71748: LIST
71749: PUSH
71750: EMPTY
71751: LIST
71752: LIST
71753: LIST
71754: LIST
71755: PPUSH
71756: CALL_OW 72
71760: ST_TO_ADDR
// if not to_repair_tmp then
71761: LD_VAR 0 7
71765: NOT
71766: IFFALSE 71770
// continue ;
71768: GO 71568
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
71770: LD_ADDR_VAR 0 8
71774: PUSH
71775: LD_VAR 0 7
71779: PPUSH
71780: LD_VAR 0 3
71784: PPUSH
71785: CALL_OW 74
71789: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
71790: LD_VAR 0 8
71794: PPUSH
71795: LD_INT 16
71797: PPUSH
71798: CALL 27811 0 2
71802: PUSH
71803: LD_INT 4
71805: ARRAY
71806: PUSH
71807: LD_INT 14
71809: LESS
71810: IFFALSE 71826
// ComRepairBuilding ( j , to_repair ) ;
71812: LD_VAR 0 3
71816: PPUSH
71817: LD_VAR 0 8
71821: PPUSH
71822: CALL_OW 130
// end ;
71826: GO 71568
71828: POP
71829: POP
// end ;
71830: GO 70938
71832: POP
71833: POP
// end ;
71834: LD_VAR 0 1
71838: RET
// export function MC_Heal ; var i , j , tmp ; begin
71839: LD_INT 0
71841: PPUSH
71842: PPUSH
71843: PPUSH
71844: PPUSH
// if not mc_bases then
71845: LD_EXP 31
71849: NOT
71850: IFFALSE 71854
// exit ;
71852: GO 72256
// for i = 1 to mc_bases do
71854: LD_ADDR_VAR 0 2
71858: PUSH
71859: DOUBLE
71860: LD_INT 1
71862: DEC
71863: ST_TO_ADDR
71864: LD_EXP 31
71868: PUSH
71869: FOR_TO
71870: IFFALSE 72254
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71872: LD_EXP 34
71876: PUSH
71877: LD_VAR 0 2
71881: ARRAY
71882: PUSH
71883: LD_INT 1
71885: ARRAY
71886: NOT
71887: PUSH
71888: LD_EXP 34
71892: PUSH
71893: LD_VAR 0 2
71897: ARRAY
71898: PUSH
71899: LD_INT 2
71901: ARRAY
71902: NOT
71903: AND
71904: IFFALSE 71942
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71906: LD_ADDR_EXP 35
71910: PUSH
71911: LD_EXP 35
71915: PPUSH
71916: LD_VAR 0 2
71920: PPUSH
71921: EMPTY
71922: PPUSH
71923: CALL_OW 1
71927: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71928: LD_VAR 0 2
71932: PPUSH
71933: LD_INT 102
71935: PPUSH
71936: CALL 65977 0 2
// continue ;
71940: GO 71869
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71942: LD_ADDR_VAR 0 4
71946: PUSH
71947: LD_EXP 31
71951: PUSH
71952: LD_VAR 0 2
71956: ARRAY
71957: PPUSH
71958: LD_INT 25
71960: PUSH
71961: LD_INT 4
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PPUSH
71968: CALL_OW 72
71972: ST_TO_ADDR
// if not tmp then
71973: LD_VAR 0 4
71977: NOT
71978: IFFALSE 71982
// continue ;
71980: GO 71869
// if mc_taming [ i ] then
71982: LD_EXP 62
71986: PUSH
71987: LD_VAR 0 2
71991: ARRAY
71992: IFFALSE 72016
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71994: LD_ADDR_EXP 62
71998: PUSH
71999: LD_EXP 62
72003: PPUSH
72004: LD_VAR 0 2
72008: PPUSH
72009: EMPTY
72010: PPUSH
72011: CALL_OW 1
72015: ST_TO_ADDR
// for j in tmp do
72016: LD_ADDR_VAR 0 3
72020: PUSH
72021: LD_VAR 0 4
72025: PUSH
72026: FOR_IN
72027: IFFALSE 72250
// begin if IsInUnit ( j ) then
72029: LD_VAR 0 3
72033: PPUSH
72034: CALL_OW 310
72038: IFFALSE 72049
// ComExitBuilding ( j ) ;
72040: LD_VAR 0 3
72044: PPUSH
72045: CALL_OW 122
// if not j in mc_healers [ i ] then
72049: LD_VAR 0 3
72053: PUSH
72054: LD_EXP 35
72058: PUSH
72059: LD_VAR 0 2
72063: ARRAY
72064: IN
72065: NOT
72066: IFFALSE 72112
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
72068: LD_ADDR_EXP 35
72072: PUSH
72073: LD_EXP 35
72077: PPUSH
72078: LD_VAR 0 2
72082: PUSH
72083: LD_EXP 35
72087: PUSH
72088: LD_VAR 0 2
72092: ARRAY
72093: PUSH
72094: LD_INT 1
72096: PLUS
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PPUSH
72102: LD_VAR 0 3
72106: PPUSH
72107: CALL 24846 0 3
72111: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
72112: LD_VAR 0 3
72116: PPUSH
72117: CALL_OW 110
72121: PUSH
72122: LD_INT 102
72124: NONEQUAL
72125: IFFALSE 72139
// SetTag ( j , 102 ) ;
72127: LD_VAR 0 3
72131: PPUSH
72132: LD_INT 102
72134: PPUSH
72135: CALL_OW 109
// Wait ( 3 ) ;
72139: LD_INT 3
72141: PPUSH
72142: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
72146: LD_EXP 34
72150: PUSH
72151: LD_VAR 0 2
72155: ARRAY
72156: PUSH
72157: LD_INT 1
72159: ARRAY
72160: IFFALSE 72192
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
72162: LD_VAR 0 3
72166: PPUSH
72167: LD_EXP 34
72171: PUSH
72172: LD_VAR 0 2
72176: ARRAY
72177: PUSH
72178: LD_INT 1
72180: ARRAY
72181: PUSH
72182: LD_INT 1
72184: ARRAY
72185: PPUSH
72186: CALL_OW 128
72190: GO 72248
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
72192: LD_VAR 0 3
72196: PPUSH
72197: CALL_OW 314
72201: NOT
72202: PUSH
72203: LD_EXP 34
72207: PUSH
72208: LD_VAR 0 2
72212: ARRAY
72213: PUSH
72214: LD_INT 2
72216: ARRAY
72217: AND
72218: IFFALSE 72248
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
72220: LD_VAR 0 3
72224: PPUSH
72225: LD_EXP 34
72229: PUSH
72230: LD_VAR 0 2
72234: ARRAY
72235: PUSH
72236: LD_INT 2
72238: ARRAY
72239: PUSH
72240: LD_INT 1
72242: ARRAY
72243: PPUSH
72244: CALL_OW 128
// end ;
72248: GO 72026
72250: POP
72251: POP
// end ;
72252: GO 71869
72254: POP
72255: POP
// end ;
72256: LD_VAR 0 1
72260: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
72261: LD_INT 0
72263: PPUSH
72264: PPUSH
72265: PPUSH
72266: PPUSH
72267: PPUSH
72268: PPUSH
// if not mc_bases then
72269: LD_EXP 31
72273: NOT
72274: IFFALSE 72278
// exit ;
72276: GO 73441
// for i = 1 to mc_bases do
72278: LD_ADDR_VAR 0 2
72282: PUSH
72283: DOUBLE
72284: LD_INT 1
72286: DEC
72287: ST_TO_ADDR
72288: LD_EXP 31
72292: PUSH
72293: FOR_TO
72294: IFFALSE 73439
// begin if mc_scan [ i ] then
72296: LD_EXP 54
72300: PUSH
72301: LD_VAR 0 2
72305: ARRAY
72306: IFFALSE 72310
// continue ;
72308: GO 72293
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
72310: LD_EXP 36
72314: PUSH
72315: LD_VAR 0 2
72319: ARRAY
72320: NOT
72321: PUSH
72322: LD_EXP 38
72326: PUSH
72327: LD_VAR 0 2
72331: ARRAY
72332: NOT
72333: AND
72334: PUSH
72335: LD_EXP 37
72339: PUSH
72340: LD_VAR 0 2
72344: ARRAY
72345: AND
72346: IFFALSE 72384
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
72348: LD_ADDR_EXP 37
72352: PUSH
72353: LD_EXP 37
72357: PPUSH
72358: LD_VAR 0 2
72362: PPUSH
72363: EMPTY
72364: PPUSH
72365: CALL_OW 1
72369: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
72370: LD_VAR 0 2
72374: PPUSH
72375: LD_INT 103
72377: PPUSH
72378: CALL 65977 0 2
// continue ;
72382: GO 72293
// end ; if mc_construct_list [ i ] then
72384: LD_EXP 38
72388: PUSH
72389: LD_VAR 0 2
72393: ARRAY
72394: IFFALSE 72614
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72396: LD_ADDR_VAR 0 5
72400: PUSH
72401: LD_EXP 31
72405: PUSH
72406: LD_VAR 0 2
72410: ARRAY
72411: PPUSH
72412: LD_INT 25
72414: PUSH
72415: LD_INT 2
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PPUSH
72422: CALL_OW 72
72426: PUSH
72427: LD_EXP 33
72431: PUSH
72432: LD_VAR 0 2
72436: ARRAY
72437: DIFF
72438: ST_TO_ADDR
// if not tmp then
72439: LD_VAR 0 5
72443: NOT
72444: IFFALSE 72448
// continue ;
72446: GO 72293
// for j in tmp do
72448: LD_ADDR_VAR 0 3
72452: PUSH
72453: LD_VAR 0 5
72457: PUSH
72458: FOR_IN
72459: IFFALSE 72610
// begin if not mc_builders [ i ] then
72461: LD_EXP 37
72465: PUSH
72466: LD_VAR 0 2
72470: ARRAY
72471: NOT
72472: IFFALSE 72530
// begin SetTag ( j , 103 ) ;
72474: LD_VAR 0 3
72478: PPUSH
72479: LD_INT 103
72481: PPUSH
72482: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72486: LD_ADDR_EXP 37
72490: PUSH
72491: LD_EXP 37
72495: PPUSH
72496: LD_VAR 0 2
72500: PUSH
72501: LD_EXP 37
72505: PUSH
72506: LD_VAR 0 2
72510: ARRAY
72511: PUSH
72512: LD_INT 1
72514: PLUS
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PPUSH
72520: LD_VAR 0 3
72524: PPUSH
72525: CALL 24846 0 3
72529: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72530: LD_VAR 0 3
72534: PPUSH
72535: CALL_OW 310
72539: IFFALSE 72550
// ComExitBuilding ( j ) ;
72541: LD_VAR 0 3
72545: PPUSH
72546: CALL_OW 122
// wait ( 3 ) ;
72550: LD_INT 3
72552: PPUSH
72553: CALL_OW 67
// if not mc_construct_list [ i ] then
72557: LD_EXP 38
72561: PUSH
72562: LD_VAR 0 2
72566: ARRAY
72567: NOT
72568: IFFALSE 72572
// break ;
72570: GO 72610
// if not HasTask ( j ) then
72572: LD_VAR 0 3
72576: PPUSH
72577: CALL_OW 314
72581: NOT
72582: IFFALSE 72608
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
72584: LD_VAR 0 3
72588: PPUSH
72589: LD_EXP 38
72593: PUSH
72594: LD_VAR 0 2
72598: ARRAY
72599: PUSH
72600: LD_INT 1
72602: ARRAY
72603: PPUSH
72604: CALL 28084 0 2
// end ;
72608: GO 72458
72610: POP
72611: POP
// end else
72612: GO 73437
// if mc_build_list [ i ] then
72614: LD_EXP 36
72618: PUSH
72619: LD_VAR 0 2
72623: ARRAY
72624: IFFALSE 73437
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
72626: LD_EXP 36
72630: PUSH
72631: LD_VAR 0 2
72635: ARRAY
72636: PUSH
72637: LD_INT 1
72639: ARRAY
72640: PUSH
72641: LD_INT 1
72643: ARRAY
72644: PPUSH
72645: CALL 27908 0 1
72649: PUSH
72650: LD_EXP 31
72654: PUSH
72655: LD_VAR 0 2
72659: ARRAY
72660: PPUSH
72661: LD_INT 2
72663: PUSH
72664: LD_INT 30
72666: PUSH
72667: LD_INT 2
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 30
72676: PUSH
72677: LD_INT 3
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: LIST
72688: PPUSH
72689: CALL_OW 72
72693: NOT
72694: AND
72695: IFFALSE 72800
// begin for j = 1 to mc_build_list [ i ] do
72697: LD_ADDR_VAR 0 3
72701: PUSH
72702: DOUBLE
72703: LD_INT 1
72705: DEC
72706: ST_TO_ADDR
72707: LD_EXP 36
72711: PUSH
72712: LD_VAR 0 2
72716: ARRAY
72717: PUSH
72718: FOR_TO
72719: IFFALSE 72798
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
72721: LD_EXP 36
72725: PUSH
72726: LD_VAR 0 2
72730: ARRAY
72731: PUSH
72732: LD_VAR 0 3
72736: ARRAY
72737: PUSH
72738: LD_INT 1
72740: ARRAY
72741: PUSH
72742: LD_INT 2
72744: EQUAL
72745: IFFALSE 72796
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72747: LD_ADDR_EXP 36
72751: PUSH
72752: LD_EXP 36
72756: PPUSH
72757: LD_VAR 0 2
72761: PPUSH
72762: LD_EXP 36
72766: PUSH
72767: LD_VAR 0 2
72771: ARRAY
72772: PPUSH
72773: LD_VAR 0 3
72777: PPUSH
72778: LD_INT 1
72780: PPUSH
72781: LD_INT 0
72783: PPUSH
72784: CALL 24264 0 4
72788: PPUSH
72789: CALL_OW 1
72793: ST_TO_ADDR
// break ;
72794: GO 72798
// end ;
72796: GO 72718
72798: POP
72799: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72800: LD_ADDR_VAR 0 6
72804: PUSH
72805: LD_EXP 31
72809: PUSH
72810: LD_VAR 0 2
72814: ARRAY
72815: PPUSH
72816: LD_INT 2
72818: PUSH
72819: LD_INT 30
72821: PUSH
72822: LD_INT 0
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: PUSH
72829: LD_INT 30
72831: PUSH
72832: LD_INT 1
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: LIST
72843: PPUSH
72844: CALL_OW 72
72848: ST_TO_ADDR
// for k := 1 to depot do
72849: LD_ADDR_VAR 0 4
72853: PUSH
72854: DOUBLE
72855: LD_INT 1
72857: DEC
72858: ST_TO_ADDR
72859: LD_VAR 0 6
72863: PUSH
72864: FOR_TO
72865: IFFALSE 73435
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
72867: LD_EXP 36
72871: PUSH
72872: LD_VAR 0 2
72876: ARRAY
72877: PUSH
72878: LD_INT 1
72880: ARRAY
72881: PUSH
72882: LD_INT 1
72884: ARRAY
72885: PUSH
72886: LD_INT 0
72888: EQUAL
72889: PUSH
72890: LD_VAR 0 6
72894: PUSH
72895: LD_VAR 0 4
72899: ARRAY
72900: PPUSH
72901: LD_EXP 36
72905: PUSH
72906: LD_VAR 0 2
72910: ARRAY
72911: PUSH
72912: LD_INT 1
72914: ARRAY
72915: PUSH
72916: LD_INT 1
72918: ARRAY
72919: PPUSH
72920: LD_EXP 36
72924: PUSH
72925: LD_VAR 0 2
72929: ARRAY
72930: PUSH
72931: LD_INT 1
72933: ARRAY
72934: PUSH
72935: LD_INT 2
72937: ARRAY
72938: PPUSH
72939: LD_EXP 36
72943: PUSH
72944: LD_VAR 0 2
72948: ARRAY
72949: PUSH
72950: LD_INT 1
72952: ARRAY
72953: PUSH
72954: LD_INT 3
72956: ARRAY
72957: PPUSH
72958: LD_EXP 36
72962: PUSH
72963: LD_VAR 0 2
72967: ARRAY
72968: PUSH
72969: LD_INT 1
72971: ARRAY
72972: PUSH
72973: LD_INT 4
72975: ARRAY
72976: PPUSH
72977: CALL 33320 0 5
72981: OR
72982: IFFALSE 73263
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72984: LD_ADDR_VAR 0 5
72988: PUSH
72989: LD_EXP 31
72993: PUSH
72994: LD_VAR 0 2
72998: ARRAY
72999: PPUSH
73000: LD_INT 25
73002: PUSH
73003: LD_INT 2
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PPUSH
73010: CALL_OW 72
73014: PUSH
73015: LD_EXP 33
73019: PUSH
73020: LD_VAR 0 2
73024: ARRAY
73025: DIFF
73026: ST_TO_ADDR
// if not tmp then
73027: LD_VAR 0 5
73031: NOT
73032: IFFALSE 73036
// continue ;
73034: GO 72864
// for j in tmp do
73036: LD_ADDR_VAR 0 3
73040: PUSH
73041: LD_VAR 0 5
73045: PUSH
73046: FOR_IN
73047: IFFALSE 73259
// begin if not mc_builders [ i ] then
73049: LD_EXP 37
73053: PUSH
73054: LD_VAR 0 2
73058: ARRAY
73059: NOT
73060: IFFALSE 73118
// begin SetTag ( j , 103 ) ;
73062: LD_VAR 0 3
73066: PPUSH
73067: LD_INT 103
73069: PPUSH
73070: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
73074: LD_ADDR_EXP 37
73078: PUSH
73079: LD_EXP 37
73083: PPUSH
73084: LD_VAR 0 2
73088: PUSH
73089: LD_EXP 37
73093: PUSH
73094: LD_VAR 0 2
73098: ARRAY
73099: PUSH
73100: LD_INT 1
73102: PLUS
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PPUSH
73108: LD_VAR 0 3
73112: PPUSH
73113: CALL 24846 0 3
73117: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
73118: LD_VAR 0 3
73122: PPUSH
73123: CALL_OW 310
73127: IFFALSE 73138
// ComExitBuilding ( j ) ;
73129: LD_VAR 0 3
73133: PPUSH
73134: CALL_OW 122
// wait ( 3 ) ;
73138: LD_INT 3
73140: PPUSH
73141: CALL_OW 67
// if not mc_build_list [ i ] then
73145: LD_EXP 36
73149: PUSH
73150: LD_VAR 0 2
73154: ARRAY
73155: NOT
73156: IFFALSE 73160
// break ;
73158: GO 73259
// if not HasTask ( j ) then
73160: LD_VAR 0 3
73164: PPUSH
73165: CALL_OW 314
73169: NOT
73170: IFFALSE 73257
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
73172: LD_VAR 0 3
73176: PPUSH
73177: LD_EXP 36
73181: PUSH
73182: LD_VAR 0 2
73186: ARRAY
73187: PUSH
73188: LD_INT 1
73190: ARRAY
73191: PUSH
73192: LD_INT 1
73194: ARRAY
73195: PPUSH
73196: LD_EXP 36
73200: PUSH
73201: LD_VAR 0 2
73205: ARRAY
73206: PUSH
73207: LD_INT 1
73209: ARRAY
73210: PUSH
73211: LD_INT 2
73213: ARRAY
73214: PPUSH
73215: LD_EXP 36
73219: PUSH
73220: LD_VAR 0 2
73224: ARRAY
73225: PUSH
73226: LD_INT 1
73228: ARRAY
73229: PUSH
73230: LD_INT 3
73232: ARRAY
73233: PPUSH
73234: LD_EXP 36
73238: PUSH
73239: LD_VAR 0 2
73243: ARRAY
73244: PUSH
73245: LD_INT 1
73247: ARRAY
73248: PUSH
73249: LD_INT 4
73251: ARRAY
73252: PPUSH
73253: CALL_OW 145
// end ;
73257: GO 73046
73259: POP
73260: POP
// end else
73261: GO 73433
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
73263: LD_EXP 31
73267: PUSH
73268: LD_VAR 0 2
73272: ARRAY
73273: PPUSH
73274: LD_EXP 36
73278: PUSH
73279: LD_VAR 0 2
73283: ARRAY
73284: PUSH
73285: LD_INT 1
73287: ARRAY
73288: PUSH
73289: LD_INT 1
73291: ARRAY
73292: PPUSH
73293: LD_EXP 36
73297: PUSH
73298: LD_VAR 0 2
73302: ARRAY
73303: PUSH
73304: LD_INT 1
73306: ARRAY
73307: PUSH
73308: LD_INT 2
73310: ARRAY
73311: PPUSH
73312: LD_EXP 36
73316: PUSH
73317: LD_VAR 0 2
73321: ARRAY
73322: PUSH
73323: LD_INT 1
73325: ARRAY
73326: PUSH
73327: LD_INT 3
73329: ARRAY
73330: PPUSH
73331: LD_EXP 36
73335: PUSH
73336: LD_VAR 0 2
73340: ARRAY
73341: PUSH
73342: LD_INT 1
73344: ARRAY
73345: PUSH
73346: LD_INT 4
73348: ARRAY
73349: PPUSH
73350: LD_EXP 31
73354: PUSH
73355: LD_VAR 0 2
73359: ARRAY
73360: PPUSH
73361: LD_INT 21
73363: PUSH
73364: LD_INT 3
73366: PUSH
73367: EMPTY
73368: LIST
73369: LIST
73370: PPUSH
73371: CALL_OW 72
73375: PPUSH
73376: EMPTY
73377: PPUSH
73378: CALL 32074 0 7
73382: NOT
73383: IFFALSE 73433
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
73385: LD_ADDR_EXP 36
73389: PUSH
73390: LD_EXP 36
73394: PPUSH
73395: LD_VAR 0 2
73399: PPUSH
73400: LD_EXP 36
73404: PUSH
73405: LD_VAR 0 2
73409: ARRAY
73410: PPUSH
73411: LD_INT 1
73413: PPUSH
73414: LD_INT 1
73416: NEG
73417: PPUSH
73418: LD_INT 0
73420: PPUSH
73421: CALL 24264 0 4
73425: PPUSH
73426: CALL_OW 1
73430: ST_TO_ADDR
// continue ;
73431: GO 72864
// end ; end ;
73433: GO 72864
73435: POP
73436: POP
// end ; end ;
73437: GO 72293
73439: POP
73440: POP
// end ;
73441: LD_VAR 0 1
73445: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
73446: LD_INT 0
73448: PPUSH
73449: PPUSH
73450: PPUSH
73451: PPUSH
73452: PPUSH
73453: PPUSH
// if not mc_bases then
73454: LD_EXP 31
73458: NOT
73459: IFFALSE 73463
// exit ;
73461: GO 73890
// for i = 1 to mc_bases do
73463: LD_ADDR_VAR 0 2
73467: PUSH
73468: DOUBLE
73469: LD_INT 1
73471: DEC
73472: ST_TO_ADDR
73473: LD_EXP 31
73477: PUSH
73478: FOR_TO
73479: IFFALSE 73888
// begin tmp := mc_build_upgrade [ i ] ;
73481: LD_ADDR_VAR 0 4
73485: PUSH
73486: LD_EXP 63
73490: PUSH
73491: LD_VAR 0 2
73495: ARRAY
73496: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
73497: LD_ADDR_VAR 0 6
73501: PUSH
73502: LD_EXP 64
73506: PUSH
73507: LD_VAR 0 2
73511: ARRAY
73512: PPUSH
73513: LD_INT 2
73515: PUSH
73516: LD_INT 30
73518: PUSH
73519: LD_INT 6
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 30
73528: PUSH
73529: LD_INT 7
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: LIST
73540: PPUSH
73541: CALL_OW 72
73545: ST_TO_ADDR
// if not tmp and not lab then
73546: LD_VAR 0 4
73550: NOT
73551: PUSH
73552: LD_VAR 0 6
73556: NOT
73557: AND
73558: IFFALSE 73562
// continue ;
73560: GO 73478
// if tmp then
73562: LD_VAR 0 4
73566: IFFALSE 73686
// for j in tmp do
73568: LD_ADDR_VAR 0 3
73572: PUSH
73573: LD_VAR 0 4
73577: PUSH
73578: FOR_IN
73579: IFFALSE 73684
// begin if UpgradeCost ( j ) then
73581: LD_VAR 0 3
73585: PPUSH
73586: CALL 31734 0 1
73590: IFFALSE 73682
// begin ComUpgrade ( j ) ;
73592: LD_VAR 0 3
73596: PPUSH
73597: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
73601: LD_ADDR_EXP 63
73605: PUSH
73606: LD_EXP 63
73610: PPUSH
73611: LD_VAR 0 2
73615: PPUSH
73616: LD_EXP 63
73620: PUSH
73621: LD_VAR 0 2
73625: ARRAY
73626: PUSH
73627: LD_VAR 0 3
73631: DIFF
73632: PPUSH
73633: CALL_OW 1
73637: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73638: LD_ADDR_EXP 38
73642: PUSH
73643: LD_EXP 38
73647: PPUSH
73648: LD_VAR 0 2
73652: PUSH
73653: LD_EXP 38
73657: PUSH
73658: LD_VAR 0 2
73662: ARRAY
73663: PUSH
73664: LD_INT 1
73666: PLUS
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PPUSH
73672: LD_VAR 0 3
73676: PPUSH
73677: CALL 24846 0 3
73681: ST_TO_ADDR
// end ; end ;
73682: GO 73578
73684: POP
73685: POP
// if not lab or not mc_lab_upgrade [ i ] then
73686: LD_VAR 0 6
73690: NOT
73691: PUSH
73692: LD_EXP 65
73696: PUSH
73697: LD_VAR 0 2
73701: ARRAY
73702: NOT
73703: OR
73704: IFFALSE 73708
// continue ;
73706: GO 73478
// for j in lab do
73708: LD_ADDR_VAR 0 3
73712: PUSH
73713: LD_VAR 0 6
73717: PUSH
73718: FOR_IN
73719: IFFALSE 73884
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
73721: LD_VAR 0 3
73725: PPUSH
73726: CALL_OW 266
73730: PUSH
73731: LD_INT 6
73733: PUSH
73734: LD_INT 7
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: IN
73741: PUSH
73742: LD_VAR 0 3
73746: PPUSH
73747: CALL_OW 461
73751: PUSH
73752: LD_INT 1
73754: NONEQUAL
73755: AND
73756: IFFALSE 73882
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
73758: LD_VAR 0 3
73762: PPUSH
73763: LD_EXP 65
73767: PUSH
73768: LD_VAR 0 2
73772: ARRAY
73773: PUSH
73774: LD_INT 1
73776: ARRAY
73777: PPUSH
73778: CALL 31939 0 2
73782: IFFALSE 73882
// begin ComCancel ( j ) ;
73784: LD_VAR 0 3
73788: PPUSH
73789: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73793: LD_VAR 0 3
73797: PPUSH
73798: LD_EXP 65
73802: PUSH
73803: LD_VAR 0 2
73807: ARRAY
73808: PUSH
73809: LD_INT 1
73811: ARRAY
73812: PPUSH
73813: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73817: LD_VAR 0 3
73821: PUSH
73822: LD_EXP 38
73826: PUSH
73827: LD_VAR 0 2
73831: ARRAY
73832: IN
73833: NOT
73834: IFFALSE 73880
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73836: LD_ADDR_EXP 38
73840: PUSH
73841: LD_EXP 38
73845: PPUSH
73846: LD_VAR 0 2
73850: PUSH
73851: LD_EXP 38
73855: PUSH
73856: LD_VAR 0 2
73860: ARRAY
73861: PUSH
73862: LD_INT 1
73864: PLUS
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PPUSH
73870: LD_VAR 0 3
73874: PPUSH
73875: CALL 24846 0 3
73879: ST_TO_ADDR
// break ;
73880: GO 73884
// end ; end ; end ;
73882: GO 73718
73884: POP
73885: POP
// end ;
73886: GO 73478
73888: POP
73889: POP
// end ;
73890: LD_VAR 0 1
73894: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73895: LD_INT 0
73897: PPUSH
73898: PPUSH
73899: PPUSH
73900: PPUSH
73901: PPUSH
73902: PPUSH
73903: PPUSH
73904: PPUSH
73905: PPUSH
// if not mc_bases then
73906: LD_EXP 31
73910: NOT
73911: IFFALSE 73915
// exit ;
73913: GO 74320
// for i = 1 to mc_bases do
73915: LD_ADDR_VAR 0 2
73919: PUSH
73920: DOUBLE
73921: LD_INT 1
73923: DEC
73924: ST_TO_ADDR
73925: LD_EXP 31
73929: PUSH
73930: FOR_TO
73931: IFFALSE 74318
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73933: LD_EXP 39
73937: PUSH
73938: LD_VAR 0 2
73942: ARRAY
73943: NOT
73944: PUSH
73945: LD_EXP 31
73949: PUSH
73950: LD_VAR 0 2
73954: ARRAY
73955: PPUSH
73956: LD_INT 30
73958: PUSH
73959: LD_INT 3
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PPUSH
73966: CALL_OW 72
73970: NOT
73971: OR
73972: IFFALSE 73976
// continue ;
73974: GO 73930
// busy := false ;
73976: LD_ADDR_VAR 0 8
73980: PUSH
73981: LD_INT 0
73983: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73984: LD_ADDR_VAR 0 4
73988: PUSH
73989: LD_EXP 31
73993: PUSH
73994: LD_VAR 0 2
73998: ARRAY
73999: PPUSH
74000: LD_INT 30
74002: PUSH
74003: LD_INT 3
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PPUSH
74010: CALL_OW 72
74014: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
74015: LD_ADDR_VAR 0 6
74019: PUSH
74020: LD_EXP 39
74024: PUSH
74025: LD_VAR 0 2
74029: ARRAY
74030: PPUSH
74031: LD_INT 2
74033: PUSH
74034: LD_INT 30
74036: PUSH
74037: LD_INT 32
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 30
74046: PUSH
74047: LD_INT 33
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: LIST
74058: PPUSH
74059: CALL_OW 72
74063: ST_TO_ADDR
// if not t then
74064: LD_VAR 0 6
74068: NOT
74069: IFFALSE 74073
// continue ;
74071: GO 73930
// for j in tmp do
74073: LD_ADDR_VAR 0 3
74077: PUSH
74078: LD_VAR 0 4
74082: PUSH
74083: FOR_IN
74084: IFFALSE 74114
// if not BuildingStatus ( j ) = bs_idle then
74086: LD_VAR 0 3
74090: PPUSH
74091: CALL_OW 461
74095: PUSH
74096: LD_INT 2
74098: EQUAL
74099: NOT
74100: IFFALSE 74112
// begin busy := true ;
74102: LD_ADDR_VAR 0 8
74106: PUSH
74107: LD_INT 1
74109: ST_TO_ADDR
// break ;
74110: GO 74114
// end ;
74112: GO 74083
74114: POP
74115: POP
// if busy then
74116: LD_VAR 0 8
74120: IFFALSE 74124
// continue ;
74122: GO 73930
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
74124: LD_ADDR_VAR 0 7
74128: PUSH
74129: LD_VAR 0 6
74133: PPUSH
74134: LD_INT 35
74136: PUSH
74137: LD_INT 0
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PPUSH
74144: CALL_OW 72
74148: ST_TO_ADDR
// if tw then
74149: LD_VAR 0 7
74153: IFFALSE 74230
// begin tw := tw [ 1 ] ;
74155: LD_ADDR_VAR 0 7
74159: PUSH
74160: LD_VAR 0 7
74164: PUSH
74165: LD_INT 1
74167: ARRAY
74168: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
74169: LD_ADDR_VAR 0 9
74173: PUSH
74174: LD_VAR 0 7
74178: PPUSH
74179: LD_EXP 56
74183: PUSH
74184: LD_VAR 0 2
74188: ARRAY
74189: PPUSH
74190: CALL 30231 0 2
74194: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
74195: LD_EXP 70
74199: PUSH
74200: LD_VAR 0 2
74204: ARRAY
74205: IFFALSE 74228
// if not weapon in mc_allowed_tower_weapons [ i ] then
74207: LD_VAR 0 9
74211: PUSH
74212: LD_EXP 70
74216: PUSH
74217: LD_VAR 0 2
74221: ARRAY
74222: IN
74223: NOT
74224: IFFALSE 74228
// continue ;
74226: GO 73930
// end else
74228: GO 74293
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
74230: LD_ADDR_VAR 0 5
74234: PUSH
74235: LD_EXP 39
74239: PUSH
74240: LD_VAR 0 2
74244: ARRAY
74245: PPUSH
74246: LD_VAR 0 4
74250: PPUSH
74251: CALL 57134 0 2
74255: ST_TO_ADDR
// if not tmp2 then
74256: LD_VAR 0 5
74260: NOT
74261: IFFALSE 74265
// continue ;
74263: GO 73930
// tw := tmp2 [ 1 ] ;
74265: LD_ADDR_VAR 0 7
74269: PUSH
74270: LD_VAR 0 5
74274: PUSH
74275: LD_INT 1
74277: ARRAY
74278: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
74279: LD_ADDR_VAR 0 9
74283: PUSH
74284: LD_VAR 0 5
74288: PUSH
74289: LD_INT 2
74291: ARRAY
74292: ST_TO_ADDR
// end ; if not weapon then
74293: LD_VAR 0 9
74297: NOT
74298: IFFALSE 74302
// continue ;
74300: GO 73930
// ComPlaceWeapon ( tw , weapon ) ;
74302: LD_VAR 0 7
74306: PPUSH
74307: LD_VAR 0 9
74311: PPUSH
74312: CALL_OW 148
// end ;
74316: GO 73930
74318: POP
74319: POP
// end ;
74320: LD_VAR 0 1
74324: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
74325: LD_INT 0
74327: PPUSH
74328: PPUSH
74329: PPUSH
74330: PPUSH
74331: PPUSH
74332: PPUSH
74333: PPUSH
// if not mc_bases then
74334: LD_EXP 31
74338: NOT
74339: IFFALSE 74343
// exit ;
74341: GO 75118
// for i = 1 to mc_bases do
74343: LD_ADDR_VAR 0 2
74347: PUSH
74348: DOUBLE
74349: LD_INT 1
74351: DEC
74352: ST_TO_ADDR
74353: LD_EXP 31
74357: PUSH
74358: FOR_TO
74359: IFFALSE 75116
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
74361: LD_EXP 44
74365: PUSH
74366: LD_VAR 0 2
74370: ARRAY
74371: NOT
74372: PUSH
74373: LD_EXP 44
74377: PUSH
74378: LD_VAR 0 2
74382: ARRAY
74383: PUSH
74384: LD_EXP 45
74388: PUSH
74389: LD_VAR 0 2
74393: ARRAY
74394: EQUAL
74395: OR
74396: PUSH
74397: LD_EXP 54
74401: PUSH
74402: LD_VAR 0 2
74406: ARRAY
74407: OR
74408: IFFALSE 74412
// continue ;
74410: GO 74358
// if mc_miners [ i ] then
74412: LD_EXP 45
74416: PUSH
74417: LD_VAR 0 2
74421: ARRAY
74422: IFFALSE 74803
// begin for j = mc_miners [ i ] downto 1 do
74424: LD_ADDR_VAR 0 3
74428: PUSH
74429: DOUBLE
74430: LD_EXP 45
74434: PUSH
74435: LD_VAR 0 2
74439: ARRAY
74440: INC
74441: ST_TO_ADDR
74442: LD_INT 1
74444: PUSH
74445: FOR_DOWNTO
74446: IFFALSE 74801
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
74448: LD_EXP 45
74452: PUSH
74453: LD_VAR 0 2
74457: ARRAY
74458: PUSH
74459: LD_VAR 0 3
74463: ARRAY
74464: PPUSH
74465: CALL_OW 301
74469: PUSH
74470: LD_EXP 45
74474: PUSH
74475: LD_VAR 0 2
74479: ARRAY
74480: PUSH
74481: LD_VAR 0 3
74485: ARRAY
74486: PPUSH
74487: CALL_OW 257
74491: PUSH
74492: LD_INT 1
74494: NONEQUAL
74495: OR
74496: IFFALSE 74559
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
74498: LD_ADDR_VAR 0 5
74502: PUSH
74503: LD_EXP 45
74507: PUSH
74508: LD_VAR 0 2
74512: ARRAY
74513: PUSH
74514: LD_EXP 45
74518: PUSH
74519: LD_VAR 0 2
74523: ARRAY
74524: PUSH
74525: LD_VAR 0 3
74529: ARRAY
74530: DIFF
74531: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
74532: LD_ADDR_EXP 45
74536: PUSH
74537: LD_EXP 45
74541: PPUSH
74542: LD_VAR 0 2
74546: PPUSH
74547: LD_VAR 0 5
74551: PPUSH
74552: CALL_OW 1
74556: ST_TO_ADDR
// continue ;
74557: GO 74445
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
74559: LD_EXP 45
74563: PUSH
74564: LD_VAR 0 2
74568: ARRAY
74569: PUSH
74570: LD_VAR 0 3
74574: ARRAY
74575: PPUSH
74576: CALL_OW 257
74580: PUSH
74581: LD_INT 1
74583: EQUAL
74584: PUSH
74585: LD_EXP 45
74589: PUSH
74590: LD_VAR 0 2
74594: ARRAY
74595: PUSH
74596: LD_VAR 0 3
74600: ARRAY
74601: PPUSH
74602: CALL_OW 459
74606: NOT
74607: AND
74608: PUSH
74609: LD_EXP 45
74613: PUSH
74614: LD_VAR 0 2
74618: ARRAY
74619: PUSH
74620: LD_VAR 0 3
74624: ARRAY
74625: PPUSH
74626: CALL_OW 314
74630: NOT
74631: AND
74632: IFFALSE 74799
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
74634: LD_EXP 45
74638: PUSH
74639: LD_VAR 0 2
74643: ARRAY
74644: PUSH
74645: LD_VAR 0 3
74649: ARRAY
74650: PPUSH
74651: CALL_OW 310
74655: IFFALSE 74678
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
74657: LD_EXP 45
74661: PUSH
74662: LD_VAR 0 2
74666: ARRAY
74667: PUSH
74668: LD_VAR 0 3
74672: ARRAY
74673: PPUSH
74674: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
74678: LD_EXP 45
74682: PUSH
74683: LD_VAR 0 2
74687: ARRAY
74688: PUSH
74689: LD_VAR 0 3
74693: ARRAY
74694: PPUSH
74695: CALL_OW 314
74699: NOT
74700: IFFALSE 74799
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
74702: LD_ADDR_VAR 0 7
74706: PUSH
74707: LD_VAR 0 3
74711: PUSH
74712: LD_EXP 44
74716: PUSH
74717: LD_VAR 0 2
74721: ARRAY
74722: PPUSH
74723: CALL 21986 0 1
74727: MOD
74728: PUSH
74729: LD_INT 1
74731: PLUS
74732: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
74733: LD_EXP 45
74737: PUSH
74738: LD_VAR 0 2
74742: ARRAY
74743: PUSH
74744: LD_VAR 0 3
74748: ARRAY
74749: PPUSH
74750: LD_EXP 44
74754: PUSH
74755: LD_VAR 0 2
74759: ARRAY
74760: PUSH
74761: LD_VAR 0 7
74765: ARRAY
74766: PUSH
74767: LD_INT 1
74769: ARRAY
74770: PPUSH
74771: LD_EXP 44
74775: PUSH
74776: LD_VAR 0 2
74780: ARRAY
74781: PUSH
74782: LD_VAR 0 7
74786: ARRAY
74787: PUSH
74788: LD_INT 2
74790: ARRAY
74791: PPUSH
74792: LD_INT 0
74794: PPUSH
74795: CALL_OW 193
// end ; end ; end ;
74799: GO 74445
74801: POP
74802: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74803: LD_ADDR_VAR 0 5
74807: PUSH
74808: LD_EXP 31
74812: PUSH
74813: LD_VAR 0 2
74817: ARRAY
74818: PPUSH
74819: LD_INT 2
74821: PUSH
74822: LD_INT 30
74824: PUSH
74825: LD_INT 4
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 30
74834: PUSH
74835: LD_INT 5
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 30
74844: PUSH
74845: LD_INT 32
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: LIST
74856: LIST
74857: PPUSH
74858: CALL_OW 72
74862: ST_TO_ADDR
// if not tmp then
74863: LD_VAR 0 5
74867: NOT
74868: IFFALSE 74872
// continue ;
74870: GO 74358
// list := [ ] ;
74872: LD_ADDR_VAR 0 6
74876: PUSH
74877: EMPTY
74878: ST_TO_ADDR
// for j in tmp do
74879: LD_ADDR_VAR 0 3
74883: PUSH
74884: LD_VAR 0 5
74888: PUSH
74889: FOR_IN
74890: IFFALSE 74959
// begin for k in UnitsInside ( j ) do
74892: LD_ADDR_VAR 0 4
74896: PUSH
74897: LD_VAR 0 3
74901: PPUSH
74902: CALL_OW 313
74906: PUSH
74907: FOR_IN
74908: IFFALSE 74955
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74910: LD_VAR 0 4
74914: PPUSH
74915: CALL_OW 257
74919: PUSH
74920: LD_INT 1
74922: EQUAL
74923: PUSH
74924: LD_VAR 0 4
74928: PPUSH
74929: CALL_OW 459
74933: NOT
74934: AND
74935: IFFALSE 74953
// list := list ^ k ;
74937: LD_ADDR_VAR 0 6
74941: PUSH
74942: LD_VAR 0 6
74946: PUSH
74947: LD_VAR 0 4
74951: ADD
74952: ST_TO_ADDR
74953: GO 74907
74955: POP
74956: POP
// end ;
74957: GO 74889
74959: POP
74960: POP
// list := list diff mc_miners [ i ] ;
74961: LD_ADDR_VAR 0 6
74965: PUSH
74966: LD_VAR 0 6
74970: PUSH
74971: LD_EXP 45
74975: PUSH
74976: LD_VAR 0 2
74980: ARRAY
74981: DIFF
74982: ST_TO_ADDR
// if not list then
74983: LD_VAR 0 6
74987: NOT
74988: IFFALSE 74992
// continue ;
74990: GO 74358
// k := mc_mines [ i ] - mc_miners [ i ] ;
74992: LD_ADDR_VAR 0 4
74996: PUSH
74997: LD_EXP 44
75001: PUSH
75002: LD_VAR 0 2
75006: ARRAY
75007: PUSH
75008: LD_EXP 45
75012: PUSH
75013: LD_VAR 0 2
75017: ARRAY
75018: MINUS
75019: ST_TO_ADDR
// if k > list then
75020: LD_VAR 0 4
75024: PUSH
75025: LD_VAR 0 6
75029: GREATER
75030: IFFALSE 75042
// k := list ;
75032: LD_ADDR_VAR 0 4
75036: PUSH
75037: LD_VAR 0 6
75041: ST_TO_ADDR
// for j = 1 to k do
75042: LD_ADDR_VAR 0 3
75046: PUSH
75047: DOUBLE
75048: LD_INT 1
75050: DEC
75051: ST_TO_ADDR
75052: LD_VAR 0 4
75056: PUSH
75057: FOR_TO
75058: IFFALSE 75112
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
75060: LD_ADDR_EXP 45
75064: PUSH
75065: LD_EXP 45
75069: PPUSH
75070: LD_VAR 0 2
75074: PUSH
75075: LD_EXP 45
75079: PUSH
75080: LD_VAR 0 2
75084: ARRAY
75085: PUSH
75086: LD_INT 1
75088: PLUS
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PPUSH
75094: LD_VAR 0 6
75098: PUSH
75099: LD_VAR 0 3
75103: ARRAY
75104: PPUSH
75105: CALL 24846 0 3
75109: ST_TO_ADDR
75110: GO 75057
75112: POP
75113: POP
// end ;
75114: GO 74358
75116: POP
75117: POP
// end ;
75118: LD_VAR 0 1
75122: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
75123: LD_INT 0
75125: PPUSH
75126: PPUSH
75127: PPUSH
75128: PPUSH
75129: PPUSH
75130: PPUSH
75131: PPUSH
75132: PPUSH
75133: PPUSH
75134: PPUSH
75135: PPUSH
// if not mc_bases then
75136: LD_EXP 31
75140: NOT
75141: IFFALSE 75145
// exit ;
75143: GO 76968
// for i = 1 to mc_bases do
75145: LD_ADDR_VAR 0 2
75149: PUSH
75150: DOUBLE
75151: LD_INT 1
75153: DEC
75154: ST_TO_ADDR
75155: LD_EXP 31
75159: PUSH
75160: FOR_TO
75161: IFFALSE 76966
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
75163: LD_EXP 31
75167: PUSH
75168: LD_VAR 0 2
75172: ARRAY
75173: NOT
75174: PUSH
75175: LD_EXP 38
75179: PUSH
75180: LD_VAR 0 2
75184: ARRAY
75185: OR
75186: IFFALSE 75190
// continue ;
75188: GO 75160
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
75190: LD_EXP 47
75194: PUSH
75195: LD_VAR 0 2
75199: ARRAY
75200: NOT
75201: PUSH
75202: LD_EXP 48
75206: PUSH
75207: LD_VAR 0 2
75211: ARRAY
75212: AND
75213: IFFALSE 75251
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
75215: LD_ADDR_EXP 48
75219: PUSH
75220: LD_EXP 48
75224: PPUSH
75225: LD_VAR 0 2
75229: PPUSH
75230: EMPTY
75231: PPUSH
75232: CALL_OW 1
75236: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
75237: LD_VAR 0 2
75241: PPUSH
75242: LD_INT 107
75244: PPUSH
75245: CALL 65977 0 2
// continue ;
75249: GO 75160
// end ; target := [ ] ;
75251: LD_ADDR_VAR 0 7
75255: PUSH
75256: EMPTY
75257: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
75258: LD_ADDR_VAR 0 6
75262: PUSH
75263: LD_EXP 31
75267: PUSH
75268: LD_VAR 0 2
75272: ARRAY
75273: PUSH
75274: LD_INT 1
75276: ARRAY
75277: PPUSH
75278: CALL_OW 255
75282: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75283: LD_ADDR_VAR 0 9
75287: PUSH
75288: LD_EXP 31
75292: PUSH
75293: LD_VAR 0 2
75297: ARRAY
75298: PPUSH
75299: LD_INT 2
75301: PUSH
75302: LD_INT 30
75304: PUSH
75305: LD_INT 0
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 30
75314: PUSH
75315: LD_INT 1
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: LIST
75326: PPUSH
75327: CALL_OW 72
75331: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
75332: LD_ADDR_VAR 0 3
75336: PUSH
75337: DOUBLE
75338: LD_EXP 47
75342: PUSH
75343: LD_VAR 0 2
75347: ARRAY
75348: INC
75349: ST_TO_ADDR
75350: LD_INT 1
75352: PUSH
75353: FOR_DOWNTO
75354: IFFALSE 75599
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
75356: LD_EXP 47
75360: PUSH
75361: LD_VAR 0 2
75365: ARRAY
75366: PUSH
75367: LD_VAR 0 3
75371: ARRAY
75372: PUSH
75373: LD_INT 2
75375: ARRAY
75376: PPUSH
75377: LD_EXP 47
75381: PUSH
75382: LD_VAR 0 2
75386: ARRAY
75387: PUSH
75388: LD_VAR 0 3
75392: ARRAY
75393: PUSH
75394: LD_INT 3
75396: ARRAY
75397: PPUSH
75398: CALL_OW 488
75402: PUSH
75403: LD_EXP 47
75407: PUSH
75408: LD_VAR 0 2
75412: ARRAY
75413: PUSH
75414: LD_VAR 0 3
75418: ARRAY
75419: PUSH
75420: LD_INT 2
75422: ARRAY
75423: PPUSH
75424: LD_EXP 47
75428: PUSH
75429: LD_VAR 0 2
75433: ARRAY
75434: PUSH
75435: LD_VAR 0 3
75439: ARRAY
75440: PUSH
75441: LD_INT 3
75443: ARRAY
75444: PPUSH
75445: CALL_OW 284
75449: PUSH
75450: LD_INT 0
75452: EQUAL
75453: AND
75454: IFFALSE 75509
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
75456: LD_ADDR_VAR 0 5
75460: PUSH
75461: LD_EXP 47
75465: PUSH
75466: LD_VAR 0 2
75470: ARRAY
75471: PPUSH
75472: LD_VAR 0 3
75476: PPUSH
75477: CALL_OW 3
75481: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
75482: LD_ADDR_EXP 47
75486: PUSH
75487: LD_EXP 47
75491: PPUSH
75492: LD_VAR 0 2
75496: PPUSH
75497: LD_VAR 0 5
75501: PPUSH
75502: CALL_OW 1
75506: ST_TO_ADDR
// continue ;
75507: GO 75353
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
75509: LD_VAR 0 6
75513: PPUSH
75514: LD_EXP 47
75518: PUSH
75519: LD_VAR 0 2
75523: ARRAY
75524: PUSH
75525: LD_VAR 0 3
75529: ARRAY
75530: PUSH
75531: LD_INT 2
75533: ARRAY
75534: PPUSH
75535: LD_EXP 47
75539: PUSH
75540: LD_VAR 0 2
75544: ARRAY
75545: PUSH
75546: LD_VAR 0 3
75550: ARRAY
75551: PUSH
75552: LD_INT 3
75554: ARRAY
75555: PPUSH
75556: LD_INT 30
75558: PPUSH
75559: CALL 26110 0 4
75563: PUSH
75564: LD_INT 4
75566: ARRAY
75567: PUSH
75568: LD_INT 0
75570: EQUAL
75571: IFFALSE 75597
// begin target := mc_crates [ i ] [ j ] ;
75573: LD_ADDR_VAR 0 7
75577: PUSH
75578: LD_EXP 47
75582: PUSH
75583: LD_VAR 0 2
75587: ARRAY
75588: PUSH
75589: LD_VAR 0 3
75593: ARRAY
75594: ST_TO_ADDR
// break ;
75595: GO 75599
// end ; end ;
75597: GO 75353
75599: POP
75600: POP
// if not target then
75601: LD_VAR 0 7
75605: NOT
75606: IFFALSE 75610
// continue ;
75608: GO 75160
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75610: LD_ADDR_VAR 0 8
75614: PUSH
75615: LD_EXP 50
75619: PUSH
75620: LD_VAR 0 2
75624: ARRAY
75625: PPUSH
75626: LD_INT 2
75628: PUSH
75629: LD_INT 3
75631: PUSH
75632: LD_INT 58
75634: PUSH
75635: EMPTY
75636: LIST
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: LD_INT 61
75644: PUSH
75645: EMPTY
75646: LIST
75647: PUSH
75648: LD_INT 33
75650: PUSH
75651: LD_INT 5
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 33
75660: PUSH
75661: LD_INT 3
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: LIST
75672: LIST
75673: LIST
75674: PUSH
75675: LD_INT 2
75677: PUSH
75678: LD_INT 34
75680: PUSH
75681: LD_INT 32
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: LD_INT 34
75690: PUSH
75691: LD_INT 51
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_INT 34
75700: PUSH
75701: LD_INT 12
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: LIST
75712: LIST
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PPUSH
75718: CALL_OW 72
75722: ST_TO_ADDR
// if not cargo then
75723: LD_VAR 0 8
75727: NOT
75728: IFFALSE 76434
// begin if mc_crates_collector [ i ] < 5 then
75730: LD_EXP 48
75734: PUSH
75735: LD_VAR 0 2
75739: ARRAY
75740: PUSH
75741: LD_INT 5
75743: LESS
75744: IFFALSE 76110
// begin if mc_ape [ i ] then
75746: LD_EXP 60
75750: PUSH
75751: LD_VAR 0 2
75755: ARRAY
75756: IFFALSE 75803
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75758: LD_ADDR_VAR 0 5
75762: PUSH
75763: LD_EXP 60
75767: PUSH
75768: LD_VAR 0 2
75772: ARRAY
75773: PPUSH
75774: LD_INT 25
75776: PUSH
75777: LD_INT 16
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 24
75786: PUSH
75787: LD_INT 750
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PPUSH
75798: CALL_OW 72
75802: ST_TO_ADDR
// if not tmp then
75803: LD_VAR 0 5
75807: NOT
75808: IFFALSE 75855
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75810: LD_ADDR_VAR 0 5
75814: PUSH
75815: LD_EXP 31
75819: PUSH
75820: LD_VAR 0 2
75824: ARRAY
75825: PPUSH
75826: LD_INT 25
75828: PUSH
75829: LD_INT 2
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 24
75838: PUSH
75839: LD_INT 750
75841: PUSH
75842: EMPTY
75843: LIST
75844: LIST
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PPUSH
75850: CALL_OW 72
75854: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75855: LD_EXP 60
75859: PUSH
75860: LD_VAR 0 2
75864: ARRAY
75865: PUSH
75866: LD_EXP 31
75870: PUSH
75871: LD_VAR 0 2
75875: ARRAY
75876: PPUSH
75877: LD_INT 25
75879: PUSH
75880: LD_INT 2
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 24
75889: PUSH
75890: LD_INT 750
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: EMPTY
75898: LIST
75899: LIST
75900: PPUSH
75901: CALL_OW 72
75905: AND
75906: PUSH
75907: LD_VAR 0 5
75911: PUSH
75912: LD_INT 5
75914: LESS
75915: AND
75916: IFFALSE 75998
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75918: LD_ADDR_VAR 0 3
75922: PUSH
75923: LD_EXP 31
75927: PUSH
75928: LD_VAR 0 2
75932: ARRAY
75933: PPUSH
75934: LD_INT 25
75936: PUSH
75937: LD_INT 2
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: LD_INT 24
75946: PUSH
75947: LD_INT 750
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PPUSH
75958: CALL_OW 72
75962: PUSH
75963: FOR_IN
75964: IFFALSE 75996
// begin tmp := tmp union j ;
75966: LD_ADDR_VAR 0 5
75970: PUSH
75971: LD_VAR 0 5
75975: PUSH
75976: LD_VAR 0 3
75980: UNION
75981: ST_TO_ADDR
// if tmp >= 5 then
75982: LD_VAR 0 5
75986: PUSH
75987: LD_INT 5
75989: GREATEREQUAL
75990: IFFALSE 75994
// break ;
75992: GO 75996
// end ;
75994: GO 75963
75996: POP
75997: POP
// end ; if not tmp then
75998: LD_VAR 0 5
76002: NOT
76003: IFFALSE 76007
// continue ;
76005: GO 75160
// for j in tmp do
76007: LD_ADDR_VAR 0 3
76011: PUSH
76012: LD_VAR 0 5
76016: PUSH
76017: FOR_IN
76018: IFFALSE 76108
// if not GetTag ( j ) then
76020: LD_VAR 0 3
76024: PPUSH
76025: CALL_OW 110
76029: NOT
76030: IFFALSE 76106
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
76032: LD_ADDR_EXP 48
76036: PUSH
76037: LD_EXP 48
76041: PPUSH
76042: LD_VAR 0 2
76046: PUSH
76047: LD_EXP 48
76051: PUSH
76052: LD_VAR 0 2
76056: ARRAY
76057: PUSH
76058: LD_INT 1
76060: PLUS
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: PPUSH
76066: LD_VAR 0 3
76070: PPUSH
76071: CALL 24846 0 3
76075: ST_TO_ADDR
// SetTag ( j , 107 ) ;
76076: LD_VAR 0 3
76080: PPUSH
76081: LD_INT 107
76083: PPUSH
76084: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
76088: LD_EXP 48
76092: PUSH
76093: LD_VAR 0 2
76097: ARRAY
76098: PUSH
76099: LD_INT 5
76101: GREATEREQUAL
76102: IFFALSE 76106
// break ;
76104: GO 76108
// end ;
76106: GO 76017
76108: POP
76109: POP
// end ; if mc_crates_collector [ i ] and target then
76110: LD_EXP 48
76114: PUSH
76115: LD_VAR 0 2
76119: ARRAY
76120: PUSH
76121: LD_VAR 0 7
76125: AND
76126: IFFALSE 76432
// begin if mc_crates_collector [ i ] < target [ 1 ] then
76128: LD_EXP 48
76132: PUSH
76133: LD_VAR 0 2
76137: ARRAY
76138: PUSH
76139: LD_VAR 0 7
76143: PUSH
76144: LD_INT 1
76146: ARRAY
76147: LESS
76148: IFFALSE 76168
// tmp := mc_crates_collector [ i ] else
76150: LD_ADDR_VAR 0 5
76154: PUSH
76155: LD_EXP 48
76159: PUSH
76160: LD_VAR 0 2
76164: ARRAY
76165: ST_TO_ADDR
76166: GO 76182
// tmp := target [ 1 ] ;
76168: LD_ADDR_VAR 0 5
76172: PUSH
76173: LD_VAR 0 7
76177: PUSH
76178: LD_INT 1
76180: ARRAY
76181: ST_TO_ADDR
// k := 0 ;
76182: LD_ADDR_VAR 0 4
76186: PUSH
76187: LD_INT 0
76189: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
76190: LD_ADDR_VAR 0 3
76194: PUSH
76195: LD_EXP 48
76199: PUSH
76200: LD_VAR 0 2
76204: ARRAY
76205: PUSH
76206: FOR_IN
76207: IFFALSE 76430
// begin k := k + 1 ;
76209: LD_ADDR_VAR 0 4
76213: PUSH
76214: LD_VAR 0 4
76218: PUSH
76219: LD_INT 1
76221: PLUS
76222: ST_TO_ADDR
// if k > tmp then
76223: LD_VAR 0 4
76227: PUSH
76228: LD_VAR 0 5
76232: GREATER
76233: IFFALSE 76237
// break ;
76235: GO 76430
// if not GetClass ( j ) in [ 2 , 16 ] then
76237: LD_VAR 0 3
76241: PPUSH
76242: CALL_OW 257
76246: PUSH
76247: LD_INT 2
76249: PUSH
76250: LD_INT 16
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: IN
76257: NOT
76258: IFFALSE 76311
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
76260: LD_ADDR_EXP 48
76264: PUSH
76265: LD_EXP 48
76269: PPUSH
76270: LD_VAR 0 2
76274: PPUSH
76275: LD_EXP 48
76279: PUSH
76280: LD_VAR 0 2
76284: ARRAY
76285: PUSH
76286: LD_VAR 0 3
76290: DIFF
76291: PPUSH
76292: CALL_OW 1
76296: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76297: LD_VAR 0 3
76301: PPUSH
76302: LD_INT 0
76304: PPUSH
76305: CALL_OW 109
// continue ;
76309: GO 76206
// end ; if IsInUnit ( j ) then
76311: LD_VAR 0 3
76315: PPUSH
76316: CALL_OW 310
76320: IFFALSE 76331
// ComExitBuilding ( j ) ;
76322: LD_VAR 0 3
76326: PPUSH
76327: CALL_OW 122
// wait ( 3 ) ;
76331: LD_INT 3
76333: PPUSH
76334: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
76338: LD_VAR 0 3
76342: PPUSH
76343: CALL_OW 314
76347: PUSH
76348: LD_VAR 0 6
76352: PPUSH
76353: LD_VAR 0 7
76357: PUSH
76358: LD_INT 2
76360: ARRAY
76361: PPUSH
76362: LD_VAR 0 7
76366: PUSH
76367: LD_INT 3
76369: ARRAY
76370: PPUSH
76371: LD_INT 30
76373: PPUSH
76374: CALL 26110 0 4
76378: PUSH
76379: LD_INT 4
76381: ARRAY
76382: AND
76383: IFFALSE 76401
// ComStandNearbyBuilding ( j , depot ) else
76385: LD_VAR 0 3
76389: PPUSH
76390: LD_VAR 0 9
76394: PPUSH
76395: CALL 21448 0 2
76399: GO 76428
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76401: LD_VAR 0 3
76405: PPUSH
76406: LD_VAR 0 7
76410: PUSH
76411: LD_INT 2
76413: ARRAY
76414: PPUSH
76415: LD_VAR 0 7
76419: PUSH
76420: LD_INT 3
76422: ARRAY
76423: PPUSH
76424: CALL_OW 117
// end ;
76428: GO 76206
76430: POP
76431: POP
// end ; end else
76432: GO 76964
// begin for j in cargo do
76434: LD_ADDR_VAR 0 3
76438: PUSH
76439: LD_VAR 0 8
76443: PUSH
76444: FOR_IN
76445: IFFALSE 76962
// begin if GetTag ( j ) <> 0 then
76447: LD_VAR 0 3
76451: PPUSH
76452: CALL_OW 110
76456: PUSH
76457: LD_INT 0
76459: NONEQUAL
76460: IFFALSE 76464
// continue ;
76462: GO 76444
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
76464: LD_VAR 0 3
76468: PPUSH
76469: CALL_OW 256
76473: PUSH
76474: LD_INT 1000
76476: LESS
76477: PUSH
76478: LD_VAR 0 3
76482: PPUSH
76483: LD_EXP 55
76487: PUSH
76488: LD_VAR 0 2
76492: ARRAY
76493: PPUSH
76494: CALL_OW 308
76498: NOT
76499: AND
76500: IFFALSE 76522
// ComMoveToArea ( j , mc_parking [ i ] ) ;
76502: LD_VAR 0 3
76506: PPUSH
76507: LD_EXP 55
76511: PUSH
76512: LD_VAR 0 2
76516: ARRAY
76517: PPUSH
76518: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
76522: LD_VAR 0 3
76526: PPUSH
76527: CALL_OW 256
76531: PUSH
76532: LD_INT 1000
76534: LESS
76535: PUSH
76536: LD_VAR 0 3
76540: PPUSH
76541: LD_EXP 55
76545: PUSH
76546: LD_VAR 0 2
76550: ARRAY
76551: PPUSH
76552: CALL_OW 308
76556: AND
76557: IFFALSE 76561
// continue ;
76559: GO 76444
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
76561: LD_VAR 0 3
76565: PPUSH
76566: CALL_OW 262
76570: PUSH
76571: LD_INT 2
76573: EQUAL
76574: PUSH
76575: LD_VAR 0 3
76579: PPUSH
76580: CALL_OW 261
76584: PUSH
76585: LD_INT 15
76587: LESS
76588: AND
76589: IFFALSE 76593
// continue ;
76591: GO 76444
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
76593: LD_VAR 0 3
76597: PPUSH
76598: CALL_OW 262
76602: PUSH
76603: LD_INT 1
76605: EQUAL
76606: PUSH
76607: LD_VAR 0 3
76611: PPUSH
76612: CALL_OW 261
76616: PUSH
76617: LD_INT 10
76619: LESS
76620: AND
76621: IFFALSE 76901
// begin if not depot then
76623: LD_VAR 0 9
76627: NOT
76628: IFFALSE 76632
// continue ;
76630: GO 76444
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76632: LD_VAR 0 3
76636: PPUSH
76637: LD_VAR 0 9
76641: PPUSH
76642: LD_VAR 0 3
76646: PPUSH
76647: CALL_OW 74
76651: PPUSH
76652: CALL_OW 296
76656: PUSH
76657: LD_INT 6
76659: LESS
76660: IFFALSE 76676
// SetFuel ( j , 100 ) else
76662: LD_VAR 0 3
76666: PPUSH
76667: LD_INT 100
76669: PPUSH
76670: CALL_OW 240
76674: GO 76901
// if GetFuel ( j ) = 0 then
76676: LD_VAR 0 3
76680: PPUSH
76681: CALL_OW 261
76685: PUSH
76686: LD_INT 0
76688: EQUAL
76689: IFFALSE 76901
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
76691: LD_ADDR_EXP 50
76695: PUSH
76696: LD_EXP 50
76700: PPUSH
76701: LD_VAR 0 2
76705: PPUSH
76706: LD_EXP 50
76710: PUSH
76711: LD_VAR 0 2
76715: ARRAY
76716: PUSH
76717: LD_VAR 0 3
76721: DIFF
76722: PPUSH
76723: CALL_OW 1
76727: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
76728: LD_VAR 0 3
76732: PPUSH
76733: CALL_OW 263
76737: PUSH
76738: LD_INT 1
76740: EQUAL
76741: IFFALSE 76757
// ComExitVehicle ( IsInUnit ( j ) ) ;
76743: LD_VAR 0 3
76747: PPUSH
76748: CALL_OW 310
76752: PPUSH
76753: CALL_OW 121
// if GetControl ( j ) = control_remote then
76757: LD_VAR 0 3
76761: PPUSH
76762: CALL_OW 263
76766: PUSH
76767: LD_INT 2
76769: EQUAL
76770: IFFALSE 76781
// ComUnlink ( j ) ;
76772: LD_VAR 0 3
76776: PPUSH
76777: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76781: LD_ADDR_VAR 0 10
76785: PUSH
76786: LD_VAR 0 2
76790: PPUSH
76791: LD_INT 3
76793: PPUSH
76794: CALL 86545 0 2
76798: ST_TO_ADDR
// if fac then
76799: LD_VAR 0 10
76803: IFFALSE 76899
// begin for k in fac do
76805: LD_ADDR_VAR 0 4
76809: PUSH
76810: LD_VAR 0 10
76814: PUSH
76815: FOR_IN
76816: IFFALSE 76897
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76818: LD_ADDR_VAR 0 11
76822: PUSH
76823: LD_VAR 0 10
76827: PPUSH
76828: LD_VAR 0 3
76832: PPUSH
76833: CALL_OW 265
76837: PPUSH
76838: LD_VAR 0 3
76842: PPUSH
76843: CALL_OW 262
76847: PPUSH
76848: LD_VAR 0 3
76852: PPUSH
76853: CALL_OW 263
76857: PPUSH
76858: LD_VAR 0 3
76862: PPUSH
76863: CALL_OW 264
76867: PPUSH
76868: CALL 22344 0 5
76872: ST_TO_ADDR
// if components then
76873: LD_VAR 0 11
76877: IFFALSE 76895
// begin MC_InsertProduceList ( i , components ) ;
76879: LD_VAR 0 2
76883: PPUSH
76884: LD_VAR 0 11
76888: PPUSH
76889: CALL 86090 0 2
// break ;
76893: GO 76897
// end ; end ;
76895: GO 76815
76897: POP
76898: POP
// end ; continue ;
76899: GO 76444
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76901: LD_VAR 0 3
76905: PPUSH
76906: LD_INT 1
76908: PPUSH
76909: CALL_OW 289
76913: PUSH
76914: LD_INT 100
76916: LESS
76917: PUSH
76918: LD_VAR 0 3
76922: PPUSH
76923: CALL_OW 314
76927: NOT
76928: AND
76929: IFFALSE 76958
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76931: LD_VAR 0 3
76935: PPUSH
76936: LD_VAR 0 7
76940: PUSH
76941: LD_INT 2
76943: ARRAY
76944: PPUSH
76945: LD_VAR 0 7
76949: PUSH
76950: LD_INT 3
76952: ARRAY
76953: PPUSH
76954: CALL_OW 117
// break ;
76958: GO 76962
// end ;
76960: GO 76444
76962: POP
76963: POP
// end ; end ;
76964: GO 75160
76966: POP
76967: POP
// end ;
76968: LD_VAR 0 1
76972: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76973: LD_INT 0
76975: PPUSH
76976: PPUSH
76977: PPUSH
76978: PPUSH
// if not mc_bases then
76979: LD_EXP 31
76983: NOT
76984: IFFALSE 76988
// exit ;
76986: GO 77149
// for i = 1 to mc_bases do
76988: LD_ADDR_VAR 0 2
76992: PUSH
76993: DOUBLE
76994: LD_INT 1
76996: DEC
76997: ST_TO_ADDR
76998: LD_EXP 31
77002: PUSH
77003: FOR_TO
77004: IFFALSE 77147
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
77006: LD_ADDR_VAR 0 4
77010: PUSH
77011: LD_EXP 50
77015: PUSH
77016: LD_VAR 0 2
77020: ARRAY
77021: PUSH
77022: LD_EXP 53
77026: PUSH
77027: LD_VAR 0 2
77031: ARRAY
77032: UNION
77033: PPUSH
77034: LD_INT 33
77036: PUSH
77037: LD_INT 2
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PPUSH
77044: CALL_OW 72
77048: ST_TO_ADDR
// if tmp then
77049: LD_VAR 0 4
77053: IFFALSE 77145
// for j in tmp do
77055: LD_ADDR_VAR 0 3
77059: PUSH
77060: LD_VAR 0 4
77064: PUSH
77065: FOR_IN
77066: IFFALSE 77143
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
77068: LD_VAR 0 3
77072: PPUSH
77073: CALL_OW 312
77077: NOT
77078: PUSH
77079: LD_VAR 0 3
77083: PPUSH
77084: CALL_OW 256
77088: PUSH
77089: LD_INT 250
77091: GREATEREQUAL
77092: AND
77093: IFFALSE 77106
// Connect ( j ) else
77095: LD_VAR 0 3
77099: PPUSH
77100: CALL 28192 0 1
77104: GO 77141
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
77106: LD_VAR 0 3
77110: PPUSH
77111: CALL_OW 256
77115: PUSH
77116: LD_INT 250
77118: LESS
77119: PUSH
77120: LD_VAR 0 3
77124: PPUSH
77125: CALL_OW 312
77129: AND
77130: IFFALSE 77141
// ComUnlink ( j ) ;
77132: LD_VAR 0 3
77136: PPUSH
77137: CALL_OW 136
77141: GO 77065
77143: POP
77144: POP
// end ;
77145: GO 77003
77147: POP
77148: POP
// end ;
77149: LD_VAR 0 1
77153: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
77154: LD_INT 0
77156: PPUSH
77157: PPUSH
77158: PPUSH
77159: PPUSH
77160: PPUSH
// if not mc_bases then
77161: LD_EXP 31
77165: NOT
77166: IFFALSE 77170
// exit ;
77168: GO 77615
// for i = 1 to mc_bases do
77170: LD_ADDR_VAR 0 2
77174: PUSH
77175: DOUBLE
77176: LD_INT 1
77178: DEC
77179: ST_TO_ADDR
77180: LD_EXP 31
77184: PUSH
77185: FOR_TO
77186: IFFALSE 77613
// begin if not mc_produce [ i ] then
77188: LD_EXP 52
77192: PUSH
77193: LD_VAR 0 2
77197: ARRAY
77198: NOT
77199: IFFALSE 77203
// continue ;
77201: GO 77185
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77203: LD_ADDR_VAR 0 5
77207: PUSH
77208: LD_EXP 31
77212: PUSH
77213: LD_VAR 0 2
77217: ARRAY
77218: PPUSH
77219: LD_INT 30
77221: PUSH
77222: LD_INT 3
77224: PUSH
77225: EMPTY
77226: LIST
77227: LIST
77228: PPUSH
77229: CALL_OW 72
77233: ST_TO_ADDR
// if not fac then
77234: LD_VAR 0 5
77238: NOT
77239: IFFALSE 77243
// continue ;
77241: GO 77185
// for j in fac do
77243: LD_ADDR_VAR 0 3
77247: PUSH
77248: LD_VAR 0 5
77252: PUSH
77253: FOR_IN
77254: IFFALSE 77609
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
77256: LD_VAR 0 3
77260: PPUSH
77261: CALL_OW 461
77265: PUSH
77266: LD_INT 2
77268: NONEQUAL
77269: PUSH
77270: LD_VAR 0 3
77274: PPUSH
77275: LD_INT 15
77277: PPUSH
77278: CALL 27811 0 2
77282: PUSH
77283: LD_INT 4
77285: ARRAY
77286: OR
77287: IFFALSE 77291
// continue ;
77289: GO 77253
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
77291: LD_VAR 0 3
77295: PPUSH
77296: LD_EXP 52
77300: PUSH
77301: LD_VAR 0 2
77305: ARRAY
77306: PUSH
77307: LD_INT 1
77309: ARRAY
77310: PUSH
77311: LD_INT 1
77313: ARRAY
77314: PPUSH
77315: LD_EXP 52
77319: PUSH
77320: LD_VAR 0 2
77324: ARRAY
77325: PUSH
77326: LD_INT 1
77328: ARRAY
77329: PUSH
77330: LD_INT 2
77332: ARRAY
77333: PPUSH
77334: LD_EXP 52
77338: PUSH
77339: LD_VAR 0 2
77343: ARRAY
77344: PUSH
77345: LD_INT 1
77347: ARRAY
77348: PUSH
77349: LD_INT 3
77351: ARRAY
77352: PPUSH
77353: LD_EXP 52
77357: PUSH
77358: LD_VAR 0 2
77362: ARRAY
77363: PUSH
77364: LD_INT 1
77366: ARRAY
77367: PUSH
77368: LD_INT 4
77370: ARRAY
77371: PPUSH
77372: CALL_OW 448
77376: PUSH
77377: LD_VAR 0 3
77381: PPUSH
77382: LD_EXP 52
77386: PUSH
77387: LD_VAR 0 2
77391: ARRAY
77392: PUSH
77393: LD_INT 1
77395: ARRAY
77396: PUSH
77397: LD_INT 1
77399: ARRAY
77400: PUSH
77401: LD_EXP 52
77405: PUSH
77406: LD_VAR 0 2
77410: ARRAY
77411: PUSH
77412: LD_INT 1
77414: ARRAY
77415: PUSH
77416: LD_INT 2
77418: ARRAY
77419: PUSH
77420: LD_EXP 52
77424: PUSH
77425: LD_VAR 0 2
77429: ARRAY
77430: PUSH
77431: LD_INT 1
77433: ARRAY
77434: PUSH
77435: LD_INT 3
77437: ARRAY
77438: PUSH
77439: LD_EXP 52
77443: PUSH
77444: LD_VAR 0 2
77448: ARRAY
77449: PUSH
77450: LD_INT 1
77452: ARRAY
77453: PUSH
77454: LD_INT 4
77456: ARRAY
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: PPUSH
77464: CALL 31587 0 2
77468: AND
77469: IFFALSE 77607
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
77471: LD_VAR 0 3
77475: PPUSH
77476: LD_EXP 52
77480: PUSH
77481: LD_VAR 0 2
77485: ARRAY
77486: PUSH
77487: LD_INT 1
77489: ARRAY
77490: PUSH
77491: LD_INT 1
77493: ARRAY
77494: PPUSH
77495: LD_EXP 52
77499: PUSH
77500: LD_VAR 0 2
77504: ARRAY
77505: PUSH
77506: LD_INT 1
77508: ARRAY
77509: PUSH
77510: LD_INT 2
77512: ARRAY
77513: PPUSH
77514: LD_EXP 52
77518: PUSH
77519: LD_VAR 0 2
77523: ARRAY
77524: PUSH
77525: LD_INT 1
77527: ARRAY
77528: PUSH
77529: LD_INT 3
77531: ARRAY
77532: PPUSH
77533: LD_EXP 52
77537: PUSH
77538: LD_VAR 0 2
77542: ARRAY
77543: PUSH
77544: LD_INT 1
77546: ARRAY
77547: PUSH
77548: LD_INT 4
77550: ARRAY
77551: PPUSH
77552: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
77556: LD_ADDR_VAR 0 4
77560: PUSH
77561: LD_EXP 52
77565: PUSH
77566: LD_VAR 0 2
77570: ARRAY
77571: PPUSH
77572: LD_INT 1
77574: PPUSH
77575: CALL_OW 3
77579: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77580: LD_ADDR_EXP 52
77584: PUSH
77585: LD_EXP 52
77589: PPUSH
77590: LD_VAR 0 2
77594: PPUSH
77595: LD_VAR 0 4
77599: PPUSH
77600: CALL_OW 1
77604: ST_TO_ADDR
// break ;
77605: GO 77609
// end ; end ;
77607: GO 77253
77609: POP
77610: POP
// end ;
77611: GO 77185
77613: POP
77614: POP
// end ;
77615: LD_VAR 0 1
77619: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77620: LD_INT 0
77622: PPUSH
77623: PPUSH
77624: PPUSH
// if not mc_bases then
77625: LD_EXP 31
77629: NOT
77630: IFFALSE 77634
// exit ;
77632: GO 77723
// for i = 1 to mc_bases do
77634: LD_ADDR_VAR 0 2
77638: PUSH
77639: DOUBLE
77640: LD_INT 1
77642: DEC
77643: ST_TO_ADDR
77644: LD_EXP 31
77648: PUSH
77649: FOR_TO
77650: IFFALSE 77721
// begin if mc_attack [ i ] then
77652: LD_EXP 51
77656: PUSH
77657: LD_VAR 0 2
77661: ARRAY
77662: IFFALSE 77719
// begin tmp := mc_attack [ i ] [ 1 ] ;
77664: LD_ADDR_VAR 0 3
77668: PUSH
77669: LD_EXP 51
77673: PUSH
77674: LD_VAR 0 2
77678: ARRAY
77679: PUSH
77680: LD_INT 1
77682: ARRAY
77683: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
77684: LD_ADDR_EXP 51
77688: PUSH
77689: LD_EXP 51
77693: PPUSH
77694: LD_VAR 0 2
77698: PPUSH
77699: EMPTY
77700: PPUSH
77701: CALL_OW 1
77705: ST_TO_ADDR
// Attack ( tmp ) ;
77706: LD_VAR 0 3
77710: PPUSH
77711: CALL 113046 0 1
// exit ;
77715: POP
77716: POP
77717: GO 77723
// end ; end ;
77719: GO 77649
77721: POP
77722: POP
// end ;
77723: LD_VAR 0 1
77727: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77728: LD_INT 0
77730: PPUSH
77731: PPUSH
77732: PPUSH
77733: PPUSH
77734: PPUSH
77735: PPUSH
77736: PPUSH
// if not mc_bases then
77737: LD_EXP 31
77741: NOT
77742: IFFALSE 77746
// exit ;
77744: GO 78603
// for i = 1 to mc_bases do
77746: LD_ADDR_VAR 0 2
77750: PUSH
77751: DOUBLE
77752: LD_INT 1
77754: DEC
77755: ST_TO_ADDR
77756: LD_EXP 31
77760: PUSH
77761: FOR_TO
77762: IFFALSE 78601
// begin if not mc_bases [ i ] then
77764: LD_EXP 31
77768: PUSH
77769: LD_VAR 0 2
77773: ARRAY
77774: NOT
77775: IFFALSE 77779
// continue ;
77777: GO 77761
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77779: LD_ADDR_VAR 0 7
77783: PUSH
77784: LD_EXP 31
77788: PUSH
77789: LD_VAR 0 2
77793: ARRAY
77794: PUSH
77795: LD_INT 1
77797: ARRAY
77798: PPUSH
77799: CALL 21670 0 1
77803: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77804: LD_ADDR_EXP 54
77808: PUSH
77809: LD_EXP 54
77813: PPUSH
77814: LD_VAR 0 2
77818: PPUSH
77819: LD_EXP 31
77823: PUSH
77824: LD_VAR 0 2
77828: ARRAY
77829: PUSH
77830: LD_INT 1
77832: ARRAY
77833: PPUSH
77834: CALL_OW 255
77838: PPUSH
77839: LD_EXP 56
77843: PUSH
77844: LD_VAR 0 2
77848: ARRAY
77849: PPUSH
77850: CALL 21635 0 2
77854: PPUSH
77855: CALL_OW 1
77859: ST_TO_ADDR
// if not mc_scan [ i ] then
77860: LD_EXP 54
77864: PUSH
77865: LD_VAR 0 2
77869: ARRAY
77870: NOT
77871: IFFALSE 78049
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77873: LD_ADDR_EXP 74
77877: PUSH
77878: LD_EXP 74
77882: PPUSH
77883: LD_VAR 0 2
77887: PPUSH
77888: LD_INT 0
77890: PPUSH
77891: CALL_OW 1
77895: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77896: LD_ADDR_VAR 0 4
77900: PUSH
77901: LD_EXP 31
77905: PUSH
77906: LD_VAR 0 2
77910: ARRAY
77911: PPUSH
77912: LD_INT 2
77914: PUSH
77915: LD_INT 25
77917: PUSH
77918: LD_INT 5
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 25
77927: PUSH
77928: LD_INT 8
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: PUSH
77935: LD_INT 25
77937: PUSH
77938: LD_INT 9
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: LIST
77949: LIST
77950: PPUSH
77951: CALL_OW 72
77955: ST_TO_ADDR
// if not tmp then
77956: LD_VAR 0 4
77960: NOT
77961: IFFALSE 77965
// continue ;
77963: GO 77761
// for j in tmp do
77965: LD_ADDR_VAR 0 3
77969: PUSH
77970: LD_VAR 0 4
77974: PUSH
77975: FOR_IN
77976: IFFALSE 78047
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77978: LD_VAR 0 3
77982: PPUSH
77983: CALL_OW 310
77987: PPUSH
77988: CALL_OW 266
77992: PUSH
77993: LD_INT 5
77995: EQUAL
77996: PUSH
77997: LD_VAR 0 3
78001: PPUSH
78002: CALL_OW 257
78006: PUSH
78007: LD_INT 1
78009: EQUAL
78010: AND
78011: PUSH
78012: LD_VAR 0 3
78016: PPUSH
78017: CALL_OW 459
78021: NOT
78022: AND
78023: PUSH
78024: LD_VAR 0 7
78028: AND
78029: IFFALSE 78045
// ComChangeProfession ( j , class ) ;
78031: LD_VAR 0 3
78035: PPUSH
78036: LD_VAR 0 7
78040: PPUSH
78041: CALL_OW 123
78045: GO 77975
78047: POP
78048: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
78049: LD_EXP 54
78053: PUSH
78054: LD_VAR 0 2
78058: ARRAY
78059: PUSH
78060: LD_EXP 74
78064: PUSH
78065: LD_VAR 0 2
78069: ARRAY
78070: NOT
78071: AND
78072: PUSH
78073: LD_EXP 53
78077: PUSH
78078: LD_VAR 0 2
78082: ARRAY
78083: NOT
78084: AND
78085: PUSH
78086: LD_EXP 31
78090: PUSH
78091: LD_VAR 0 2
78095: ARRAY
78096: PPUSH
78097: LD_INT 50
78099: PUSH
78100: EMPTY
78101: LIST
78102: PUSH
78103: LD_INT 2
78105: PUSH
78106: LD_INT 30
78108: PUSH
78109: LD_INT 32
78111: PUSH
78112: EMPTY
78113: LIST
78114: LIST
78115: PUSH
78116: LD_INT 30
78118: PUSH
78119: LD_INT 33
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: PUSH
78126: LD_INT 30
78128: PUSH
78129: LD_INT 4
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: PUSH
78136: LD_INT 30
78138: PUSH
78139: LD_INT 5
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: PPUSH
78157: CALL_OW 72
78161: PUSH
78162: LD_INT 4
78164: LESS
78165: PUSH
78166: LD_EXP 31
78170: PUSH
78171: LD_VAR 0 2
78175: ARRAY
78176: PPUSH
78177: LD_INT 3
78179: PUSH
78180: LD_INT 24
78182: PUSH
78183: LD_INT 1000
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 2
78196: PUSH
78197: LD_INT 30
78199: PUSH
78200: LD_INT 0
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: PUSH
78207: LD_INT 30
78209: PUSH
78210: LD_INT 1
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: PUSH
78217: EMPTY
78218: LIST
78219: LIST
78220: LIST
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PPUSH
78226: CALL_OW 72
78230: OR
78231: AND
78232: IFFALSE 78483
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
78234: LD_ADDR_EXP 74
78238: PUSH
78239: LD_EXP 74
78243: PPUSH
78244: LD_VAR 0 2
78248: PPUSH
78249: LD_INT 1
78251: PPUSH
78252: CALL_OW 1
78256: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
78257: LD_ADDR_VAR 0 4
78261: PUSH
78262: LD_EXP 31
78266: PUSH
78267: LD_VAR 0 2
78271: ARRAY
78272: PPUSH
78273: LD_INT 2
78275: PUSH
78276: LD_INT 25
78278: PUSH
78279: LD_INT 1
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 25
78288: PUSH
78289: LD_INT 5
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 25
78298: PUSH
78299: LD_INT 8
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 25
78308: PUSH
78309: LD_INT 9
78311: PUSH
78312: EMPTY
78313: LIST
78314: LIST
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: LIST
78320: LIST
78321: LIST
78322: PPUSH
78323: CALL_OW 72
78327: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
78328: LD_ADDR_VAR 0 4
78332: PUSH
78333: LD_VAR 0 4
78337: PUSH
78338: LD_VAR 0 4
78342: PPUSH
78343: LD_INT 18
78345: PPUSH
78346: CALL 55155 0 2
78350: DIFF
78351: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
78352: LD_VAR 0 4
78356: NOT
78357: PUSH
78358: LD_EXP 31
78362: PUSH
78363: LD_VAR 0 2
78367: ARRAY
78368: PPUSH
78369: LD_INT 2
78371: PUSH
78372: LD_INT 30
78374: PUSH
78375: LD_INT 4
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 30
78384: PUSH
78385: LD_INT 5
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: LIST
78396: PPUSH
78397: CALL_OW 72
78401: NOT
78402: AND
78403: IFFALSE 78465
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
78405: LD_ADDR_VAR 0 4
78409: PUSH
78410: LD_EXP 31
78414: PUSH
78415: LD_VAR 0 2
78419: ARRAY
78420: PPUSH
78421: LD_INT 2
78423: PUSH
78424: LD_INT 25
78426: PUSH
78427: LD_INT 2
78429: PUSH
78430: EMPTY
78431: LIST
78432: LIST
78433: PUSH
78434: LD_INT 25
78436: PUSH
78437: LD_INT 3
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: LD_INT 25
78446: PUSH
78447: LD_INT 4
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: LIST
78458: LIST
78459: PPUSH
78460: CALL_OW 72
78464: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
78465: LD_VAR 0 2
78469: PPUSH
78470: LD_VAR 0 4
78474: PPUSH
78475: CALL 117755 0 2
// exit ;
78479: POP
78480: POP
78481: GO 78603
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
78483: LD_EXP 54
78487: PUSH
78488: LD_VAR 0 2
78492: ARRAY
78493: PUSH
78494: LD_EXP 74
78498: PUSH
78499: LD_VAR 0 2
78503: ARRAY
78504: NOT
78505: AND
78506: PUSH
78507: LD_EXP 53
78511: PUSH
78512: LD_VAR 0 2
78516: ARRAY
78517: AND
78518: IFFALSE 78599
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
78520: LD_ADDR_EXP 74
78524: PUSH
78525: LD_EXP 74
78529: PPUSH
78530: LD_VAR 0 2
78534: PPUSH
78535: LD_INT 1
78537: PPUSH
78538: CALL_OW 1
78542: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
78543: LD_ADDR_VAR 0 4
78547: PUSH
78548: LD_EXP 53
78552: PUSH
78553: LD_VAR 0 2
78557: ARRAY
78558: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
78559: LD_ADDR_EXP 53
78563: PUSH
78564: LD_EXP 53
78568: PPUSH
78569: LD_VAR 0 2
78573: PPUSH
78574: EMPTY
78575: PPUSH
78576: CALL_OW 1
78580: ST_TO_ADDR
// Defend ( i , tmp ) ;
78581: LD_VAR 0 2
78585: PPUSH
78586: LD_VAR 0 4
78590: PPUSH
78591: CALL 118351 0 2
// exit ;
78595: POP
78596: POP
78597: GO 78603
// end ; end ;
78599: GO 77761
78601: POP
78602: POP
// end ;
78603: LD_VAR 0 1
78607: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78608: LD_INT 0
78610: PPUSH
78611: PPUSH
78612: PPUSH
78613: PPUSH
78614: PPUSH
78615: PPUSH
78616: PPUSH
78617: PPUSH
78618: PPUSH
78619: PPUSH
78620: PPUSH
// if not mc_bases then
78621: LD_EXP 31
78625: NOT
78626: IFFALSE 78630
// exit ;
78628: GO 79717
// for i = 1 to mc_bases do
78630: LD_ADDR_VAR 0 2
78634: PUSH
78635: DOUBLE
78636: LD_INT 1
78638: DEC
78639: ST_TO_ADDR
78640: LD_EXP 31
78644: PUSH
78645: FOR_TO
78646: IFFALSE 79715
// begin tmp := mc_lab [ i ] ;
78648: LD_ADDR_VAR 0 6
78652: PUSH
78653: LD_EXP 64
78657: PUSH
78658: LD_VAR 0 2
78662: ARRAY
78663: ST_TO_ADDR
// if not tmp then
78664: LD_VAR 0 6
78668: NOT
78669: IFFALSE 78673
// continue ;
78671: GO 78645
// idle_lab := 0 ;
78673: LD_ADDR_VAR 0 11
78677: PUSH
78678: LD_INT 0
78680: ST_TO_ADDR
// for j in tmp do
78681: LD_ADDR_VAR 0 3
78685: PUSH
78686: LD_VAR 0 6
78690: PUSH
78691: FOR_IN
78692: IFFALSE 79711
// begin researching := false ;
78694: LD_ADDR_VAR 0 10
78698: PUSH
78699: LD_INT 0
78701: ST_TO_ADDR
// side := GetSide ( j ) ;
78702: LD_ADDR_VAR 0 4
78706: PUSH
78707: LD_VAR 0 3
78711: PPUSH
78712: CALL_OW 255
78716: ST_TO_ADDR
// if not mc_tech [ side ] then
78717: LD_EXP 58
78721: PUSH
78722: LD_VAR 0 4
78726: ARRAY
78727: NOT
78728: IFFALSE 78732
// continue ;
78730: GO 78691
// if BuildingStatus ( j ) = bs_idle then
78732: LD_VAR 0 3
78736: PPUSH
78737: CALL_OW 461
78741: PUSH
78742: LD_INT 2
78744: EQUAL
78745: IFFALSE 78933
// begin if idle_lab and UnitsInside ( j ) < 6 then
78747: LD_VAR 0 11
78751: PUSH
78752: LD_VAR 0 3
78756: PPUSH
78757: CALL_OW 313
78761: PUSH
78762: LD_INT 6
78764: LESS
78765: AND
78766: IFFALSE 78837
// begin tmp2 := UnitsInside ( idle_lab ) ;
78768: LD_ADDR_VAR 0 9
78772: PUSH
78773: LD_VAR 0 11
78777: PPUSH
78778: CALL_OW 313
78782: ST_TO_ADDR
// if tmp2 then
78783: LD_VAR 0 9
78787: IFFALSE 78829
// for x in tmp2 do
78789: LD_ADDR_VAR 0 7
78793: PUSH
78794: LD_VAR 0 9
78798: PUSH
78799: FOR_IN
78800: IFFALSE 78827
// begin ComExitBuilding ( x ) ;
78802: LD_VAR 0 7
78806: PPUSH
78807: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78811: LD_VAR 0 7
78815: PPUSH
78816: LD_VAR 0 3
78820: PPUSH
78821: CALL_OW 180
// end ;
78825: GO 78799
78827: POP
78828: POP
// idle_lab := 0 ;
78829: LD_ADDR_VAR 0 11
78833: PUSH
78834: LD_INT 0
78836: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78837: LD_ADDR_VAR 0 5
78841: PUSH
78842: LD_EXP 58
78846: PUSH
78847: LD_VAR 0 4
78851: ARRAY
78852: PUSH
78853: FOR_IN
78854: IFFALSE 78914
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78856: LD_VAR 0 3
78860: PPUSH
78861: LD_VAR 0 5
78865: PPUSH
78866: CALL_OW 430
78870: PUSH
78871: LD_VAR 0 4
78875: PPUSH
78876: LD_VAR 0 5
78880: PPUSH
78881: CALL 20740 0 2
78885: AND
78886: IFFALSE 78912
// begin researching := true ;
78888: LD_ADDR_VAR 0 10
78892: PUSH
78893: LD_INT 1
78895: ST_TO_ADDR
// ComResearch ( j , t ) ;
78896: LD_VAR 0 3
78900: PPUSH
78901: LD_VAR 0 5
78905: PPUSH
78906: CALL_OW 124
// break ;
78910: GO 78914
// end ;
78912: GO 78853
78914: POP
78915: POP
// if not researching then
78916: LD_VAR 0 10
78920: NOT
78921: IFFALSE 78933
// idle_lab := j ;
78923: LD_ADDR_VAR 0 11
78927: PUSH
78928: LD_VAR 0 3
78932: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78933: LD_VAR 0 3
78937: PPUSH
78938: CALL_OW 461
78942: PUSH
78943: LD_INT 10
78945: EQUAL
78946: IFFALSE 79534
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78948: LD_EXP 60
78952: PUSH
78953: LD_VAR 0 2
78957: ARRAY
78958: NOT
78959: PUSH
78960: LD_EXP 61
78964: PUSH
78965: LD_VAR 0 2
78969: ARRAY
78970: NOT
78971: AND
78972: PUSH
78973: LD_EXP 58
78977: PUSH
78978: LD_VAR 0 4
78982: ARRAY
78983: PUSH
78984: LD_INT 1
78986: GREATER
78987: AND
78988: IFFALSE 79119
// begin ComCancel ( j ) ;
78990: LD_VAR 0 3
78994: PPUSH
78995: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78999: LD_ADDR_EXP 58
79003: PUSH
79004: LD_EXP 58
79008: PPUSH
79009: LD_VAR 0 4
79013: PPUSH
79014: LD_EXP 58
79018: PUSH
79019: LD_VAR 0 4
79023: ARRAY
79024: PPUSH
79025: LD_EXP 58
79029: PUSH
79030: LD_VAR 0 4
79034: ARRAY
79035: PUSH
79036: LD_INT 1
79038: MINUS
79039: PPUSH
79040: LD_EXP 58
79044: PUSH
79045: LD_VAR 0 4
79049: ARRAY
79050: PPUSH
79051: LD_INT 0
79053: PPUSH
79054: CALL 24264 0 4
79058: PPUSH
79059: CALL_OW 1
79063: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
79064: LD_ADDR_EXP 58
79068: PUSH
79069: LD_EXP 58
79073: PPUSH
79074: LD_VAR 0 4
79078: PPUSH
79079: LD_EXP 58
79083: PUSH
79084: LD_VAR 0 4
79088: ARRAY
79089: PPUSH
79090: LD_EXP 58
79094: PUSH
79095: LD_VAR 0 4
79099: ARRAY
79100: PPUSH
79101: LD_INT 1
79103: PPUSH
79104: LD_INT 0
79106: PPUSH
79107: CALL 24264 0 4
79111: PPUSH
79112: CALL_OW 1
79116: ST_TO_ADDR
// continue ;
79117: GO 78691
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
79119: LD_EXP 60
79123: PUSH
79124: LD_VAR 0 2
79128: ARRAY
79129: PUSH
79130: LD_EXP 61
79134: PUSH
79135: LD_VAR 0 2
79139: ARRAY
79140: NOT
79141: AND
79142: IFFALSE 79269
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
79144: LD_ADDR_EXP 61
79148: PUSH
79149: LD_EXP 61
79153: PPUSH
79154: LD_VAR 0 2
79158: PUSH
79159: LD_EXP 61
79163: PUSH
79164: LD_VAR 0 2
79168: ARRAY
79169: PUSH
79170: LD_INT 1
79172: PLUS
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PPUSH
79178: LD_EXP 60
79182: PUSH
79183: LD_VAR 0 2
79187: ARRAY
79188: PUSH
79189: LD_INT 1
79191: ARRAY
79192: PPUSH
79193: CALL 24846 0 3
79197: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
79198: LD_EXP 60
79202: PUSH
79203: LD_VAR 0 2
79207: ARRAY
79208: PUSH
79209: LD_INT 1
79211: ARRAY
79212: PPUSH
79213: LD_INT 112
79215: PPUSH
79216: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
79220: LD_ADDR_VAR 0 9
79224: PUSH
79225: LD_EXP 60
79229: PUSH
79230: LD_VAR 0 2
79234: ARRAY
79235: PPUSH
79236: LD_INT 1
79238: PPUSH
79239: CALL_OW 3
79243: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
79244: LD_ADDR_EXP 60
79248: PUSH
79249: LD_EXP 60
79253: PPUSH
79254: LD_VAR 0 2
79258: PPUSH
79259: LD_VAR 0 9
79263: PPUSH
79264: CALL_OW 1
79268: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
79269: LD_EXP 60
79273: PUSH
79274: LD_VAR 0 2
79278: ARRAY
79279: PUSH
79280: LD_EXP 61
79284: PUSH
79285: LD_VAR 0 2
79289: ARRAY
79290: AND
79291: PUSH
79292: LD_EXP 61
79296: PUSH
79297: LD_VAR 0 2
79301: ARRAY
79302: PUSH
79303: LD_INT 1
79305: ARRAY
79306: PPUSH
79307: CALL_OW 310
79311: NOT
79312: AND
79313: PUSH
79314: LD_VAR 0 3
79318: PPUSH
79319: CALL_OW 313
79323: PUSH
79324: LD_INT 6
79326: EQUAL
79327: AND
79328: IFFALSE 79384
// begin tmp2 := UnitsInside ( j ) ;
79330: LD_ADDR_VAR 0 9
79334: PUSH
79335: LD_VAR 0 3
79339: PPUSH
79340: CALL_OW 313
79344: ST_TO_ADDR
// if tmp2 = 6 then
79345: LD_VAR 0 9
79349: PUSH
79350: LD_INT 6
79352: EQUAL
79353: IFFALSE 79384
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
79355: LD_VAR 0 9
79359: PUSH
79360: LD_INT 1
79362: ARRAY
79363: PPUSH
79364: LD_INT 112
79366: PPUSH
79367: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
79371: LD_VAR 0 9
79375: PUSH
79376: LD_INT 1
79378: ARRAY
79379: PPUSH
79380: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
79384: LD_EXP 61
79388: PUSH
79389: LD_VAR 0 2
79393: ARRAY
79394: PUSH
79395: LD_EXP 61
79399: PUSH
79400: LD_VAR 0 2
79404: ARRAY
79405: PUSH
79406: LD_INT 1
79408: ARRAY
79409: PPUSH
79410: CALL_OW 314
79414: NOT
79415: AND
79416: PUSH
79417: LD_EXP 61
79421: PUSH
79422: LD_VAR 0 2
79426: ARRAY
79427: PUSH
79428: LD_INT 1
79430: ARRAY
79431: PPUSH
79432: CALL_OW 310
79436: NOT
79437: AND
79438: IFFALSE 79464
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
79440: LD_EXP 61
79444: PUSH
79445: LD_VAR 0 2
79449: ARRAY
79450: PUSH
79451: LD_INT 1
79453: ARRAY
79454: PPUSH
79455: LD_VAR 0 3
79459: PPUSH
79460: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
79464: LD_EXP 61
79468: PUSH
79469: LD_VAR 0 2
79473: ARRAY
79474: PUSH
79475: LD_INT 1
79477: ARRAY
79478: PPUSH
79479: CALL_OW 310
79483: PUSH
79484: LD_EXP 61
79488: PUSH
79489: LD_VAR 0 2
79493: ARRAY
79494: PUSH
79495: LD_INT 1
79497: ARRAY
79498: PPUSH
79499: CALL_OW 310
79503: PPUSH
79504: CALL_OW 461
79508: PUSH
79509: LD_INT 3
79511: NONEQUAL
79512: AND
79513: IFFALSE 79534
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
79515: LD_EXP 61
79519: PUSH
79520: LD_VAR 0 2
79524: ARRAY
79525: PUSH
79526: LD_INT 1
79528: ARRAY
79529: PPUSH
79530: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
79534: LD_VAR 0 3
79538: PPUSH
79539: CALL_OW 461
79543: PUSH
79544: LD_INT 6
79546: EQUAL
79547: PUSH
79548: LD_VAR 0 6
79552: PUSH
79553: LD_INT 1
79555: GREATER
79556: AND
79557: IFFALSE 79709
// begin sci := [ ] ;
79559: LD_ADDR_VAR 0 8
79563: PUSH
79564: EMPTY
79565: ST_TO_ADDR
// for x in ( tmp diff j ) do
79566: LD_ADDR_VAR 0 7
79570: PUSH
79571: LD_VAR 0 6
79575: PUSH
79576: LD_VAR 0 3
79580: DIFF
79581: PUSH
79582: FOR_IN
79583: IFFALSE 79635
// begin if sci = 6 then
79585: LD_VAR 0 8
79589: PUSH
79590: LD_INT 6
79592: EQUAL
79593: IFFALSE 79597
// break ;
79595: GO 79635
// if BuildingStatus ( x ) = bs_idle then
79597: LD_VAR 0 7
79601: PPUSH
79602: CALL_OW 461
79606: PUSH
79607: LD_INT 2
79609: EQUAL
79610: IFFALSE 79633
// sci := sci ^ UnitsInside ( x ) ;
79612: LD_ADDR_VAR 0 8
79616: PUSH
79617: LD_VAR 0 8
79621: PUSH
79622: LD_VAR 0 7
79626: PPUSH
79627: CALL_OW 313
79631: ADD
79632: ST_TO_ADDR
// end ;
79633: GO 79582
79635: POP
79636: POP
// if not sci then
79637: LD_VAR 0 8
79641: NOT
79642: IFFALSE 79646
// continue ;
79644: GO 78691
// for x in sci do
79646: LD_ADDR_VAR 0 7
79650: PUSH
79651: LD_VAR 0 8
79655: PUSH
79656: FOR_IN
79657: IFFALSE 79707
// if IsInUnit ( x ) and not HasTask ( x ) then
79659: LD_VAR 0 7
79663: PPUSH
79664: CALL_OW 310
79668: PUSH
79669: LD_VAR 0 7
79673: PPUSH
79674: CALL_OW 314
79678: NOT
79679: AND
79680: IFFALSE 79705
// begin ComExitBuilding ( x ) ;
79682: LD_VAR 0 7
79686: PPUSH
79687: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79691: LD_VAR 0 7
79695: PPUSH
79696: LD_VAR 0 3
79700: PPUSH
79701: CALL_OW 180
// end ;
79705: GO 79656
79707: POP
79708: POP
// end ; end ;
79709: GO 78691
79711: POP
79712: POP
// end ;
79713: GO 78645
79715: POP
79716: POP
// end ;
79717: LD_VAR 0 1
79721: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79722: LD_INT 0
79724: PPUSH
79725: PPUSH
// if not mc_bases then
79726: LD_EXP 31
79730: NOT
79731: IFFALSE 79735
// exit ;
79733: GO 79816
// for i = 1 to mc_bases do
79735: LD_ADDR_VAR 0 2
79739: PUSH
79740: DOUBLE
79741: LD_INT 1
79743: DEC
79744: ST_TO_ADDR
79745: LD_EXP 31
79749: PUSH
79750: FOR_TO
79751: IFFALSE 79814
// if mc_mines [ i ] and mc_miners [ i ] then
79753: LD_EXP 44
79757: PUSH
79758: LD_VAR 0 2
79762: ARRAY
79763: PUSH
79764: LD_EXP 45
79768: PUSH
79769: LD_VAR 0 2
79773: ARRAY
79774: AND
79775: IFFALSE 79812
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79777: LD_EXP 45
79781: PUSH
79782: LD_VAR 0 2
79786: ARRAY
79787: PUSH
79788: LD_INT 1
79790: ARRAY
79791: PPUSH
79792: CALL_OW 255
79796: PPUSH
79797: LD_EXP 44
79801: PUSH
79802: LD_VAR 0 2
79806: ARRAY
79807: PPUSH
79808: CALL 21823 0 2
79812: GO 79750
79814: POP
79815: POP
// end ;
79816: LD_VAR 0 1
79820: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79821: LD_INT 0
79823: PPUSH
79824: PPUSH
79825: PPUSH
79826: PPUSH
79827: PPUSH
79828: PPUSH
79829: PPUSH
79830: PPUSH
// if not mc_bases or not mc_parking then
79831: LD_EXP 31
79835: NOT
79836: PUSH
79837: LD_EXP 55
79841: NOT
79842: OR
79843: IFFALSE 79847
// exit ;
79845: GO 80585
// for i = 1 to mc_bases do
79847: LD_ADDR_VAR 0 2
79851: PUSH
79852: DOUBLE
79853: LD_INT 1
79855: DEC
79856: ST_TO_ADDR
79857: LD_EXP 31
79861: PUSH
79862: FOR_TO
79863: IFFALSE 80583
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79865: LD_EXP 31
79869: PUSH
79870: LD_VAR 0 2
79874: ARRAY
79875: NOT
79876: PUSH
79877: LD_EXP 55
79881: PUSH
79882: LD_VAR 0 2
79886: ARRAY
79887: NOT
79888: OR
79889: IFFALSE 79893
// continue ;
79891: GO 79862
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79893: LD_ADDR_VAR 0 5
79897: PUSH
79898: LD_EXP 31
79902: PUSH
79903: LD_VAR 0 2
79907: ARRAY
79908: PUSH
79909: LD_INT 1
79911: ARRAY
79912: PPUSH
79913: CALL_OW 255
79917: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79918: LD_ADDR_VAR 0 6
79922: PUSH
79923: LD_EXP 31
79927: PUSH
79928: LD_VAR 0 2
79932: ARRAY
79933: PPUSH
79934: LD_INT 30
79936: PUSH
79937: LD_INT 3
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PPUSH
79944: CALL_OW 72
79948: ST_TO_ADDR
// if not fac then
79949: LD_VAR 0 6
79953: NOT
79954: IFFALSE 80005
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79956: LD_ADDR_VAR 0 6
79960: PUSH
79961: LD_EXP 31
79965: PUSH
79966: LD_VAR 0 2
79970: ARRAY
79971: PPUSH
79972: LD_INT 2
79974: PUSH
79975: LD_INT 30
79977: PUSH
79978: LD_INT 0
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 30
79987: PUSH
79988: LD_INT 1
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: LIST
79999: PPUSH
80000: CALL_OW 72
80004: ST_TO_ADDR
// if not fac then
80005: LD_VAR 0 6
80009: NOT
80010: IFFALSE 80014
// continue ;
80012: GO 79862
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
80014: LD_ADDR_VAR 0 7
80018: PUSH
80019: LD_EXP 55
80023: PUSH
80024: LD_VAR 0 2
80028: ARRAY
80029: PPUSH
80030: LD_INT 22
80032: PUSH
80033: LD_VAR 0 5
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 21
80044: PUSH
80045: LD_INT 2
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 3
80054: PUSH
80055: LD_INT 60
80057: PUSH
80058: EMPTY
80059: LIST
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: LD_INT 3
80067: PUSH
80068: LD_INT 24
80070: PUSH
80071: LD_INT 1000
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: PPUSH
80088: CALL_OW 70
80092: ST_TO_ADDR
// for j in fac do
80093: LD_ADDR_VAR 0 3
80097: PUSH
80098: LD_VAR 0 6
80102: PUSH
80103: FOR_IN
80104: IFFALSE 80199
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
80106: LD_ADDR_VAR 0 7
80110: PUSH
80111: LD_VAR 0 7
80115: PUSH
80116: LD_INT 22
80118: PUSH
80119: LD_VAR 0 5
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 91
80130: PUSH
80131: LD_VAR 0 3
80135: PUSH
80136: LD_INT 15
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: LIST
80143: PUSH
80144: LD_INT 21
80146: PUSH
80147: LD_INT 2
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 3
80156: PUSH
80157: LD_INT 60
80159: PUSH
80160: EMPTY
80161: LIST
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 3
80169: PUSH
80170: LD_INT 24
80172: PUSH
80173: LD_INT 1000
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: PPUSH
80191: CALL_OW 69
80195: UNION
80196: ST_TO_ADDR
80197: GO 80103
80199: POP
80200: POP
// if not vehs then
80201: LD_VAR 0 7
80205: NOT
80206: IFFALSE 80232
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
80208: LD_ADDR_EXP 43
80212: PUSH
80213: LD_EXP 43
80217: PPUSH
80218: LD_VAR 0 2
80222: PPUSH
80223: EMPTY
80224: PPUSH
80225: CALL_OW 1
80229: ST_TO_ADDR
// continue ;
80230: GO 79862
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
80232: LD_ADDR_VAR 0 8
80236: PUSH
80237: LD_EXP 31
80241: PUSH
80242: LD_VAR 0 2
80246: ARRAY
80247: PPUSH
80248: LD_INT 30
80250: PUSH
80251: LD_INT 3
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PPUSH
80258: CALL_OW 72
80262: ST_TO_ADDR
// if tmp then
80263: LD_VAR 0 8
80267: IFFALSE 80370
// begin for j in tmp do
80269: LD_ADDR_VAR 0 3
80273: PUSH
80274: LD_VAR 0 8
80278: PUSH
80279: FOR_IN
80280: IFFALSE 80368
// for k in UnitsInside ( j ) do
80282: LD_ADDR_VAR 0 4
80286: PUSH
80287: LD_VAR 0 3
80291: PPUSH
80292: CALL_OW 313
80296: PUSH
80297: FOR_IN
80298: IFFALSE 80364
// if k then
80300: LD_VAR 0 4
80304: IFFALSE 80362
// if not k in mc_repair_vehicle [ i ] then
80306: LD_VAR 0 4
80310: PUSH
80311: LD_EXP 43
80315: PUSH
80316: LD_VAR 0 2
80320: ARRAY
80321: IN
80322: NOT
80323: IFFALSE 80362
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
80325: LD_ADDR_EXP 43
80329: PUSH
80330: LD_EXP 43
80334: PPUSH
80335: LD_VAR 0 2
80339: PPUSH
80340: LD_EXP 43
80344: PUSH
80345: LD_VAR 0 2
80349: ARRAY
80350: PUSH
80351: LD_VAR 0 4
80355: UNION
80356: PPUSH
80357: CALL_OW 1
80361: ST_TO_ADDR
80362: GO 80297
80364: POP
80365: POP
80366: GO 80279
80368: POP
80369: POP
// end ; if not mc_repair_vehicle [ i ] then
80370: LD_EXP 43
80374: PUSH
80375: LD_VAR 0 2
80379: ARRAY
80380: NOT
80381: IFFALSE 80385
// continue ;
80383: GO 79862
// for j in mc_repair_vehicle [ i ] do
80385: LD_ADDR_VAR 0 3
80389: PUSH
80390: LD_EXP 43
80394: PUSH
80395: LD_VAR 0 2
80399: ARRAY
80400: PUSH
80401: FOR_IN
80402: IFFALSE 80579
// begin if GetClass ( j ) <> 3 then
80404: LD_VAR 0 3
80408: PPUSH
80409: CALL_OW 257
80413: PUSH
80414: LD_INT 3
80416: NONEQUAL
80417: IFFALSE 80458
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
80419: LD_ADDR_EXP 43
80423: PUSH
80424: LD_EXP 43
80428: PPUSH
80429: LD_VAR 0 2
80433: PPUSH
80434: LD_EXP 43
80438: PUSH
80439: LD_VAR 0 2
80443: ARRAY
80444: PUSH
80445: LD_VAR 0 3
80449: DIFF
80450: PPUSH
80451: CALL_OW 1
80455: ST_TO_ADDR
// continue ;
80456: GO 80401
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
80458: LD_VAR 0 3
80462: PPUSH
80463: CALL_OW 311
80467: NOT
80468: PUSH
80469: LD_VAR 0 3
80473: PUSH
80474: LD_EXP 34
80478: PUSH
80479: LD_VAR 0 2
80483: ARRAY
80484: PUSH
80485: LD_INT 1
80487: ARRAY
80488: IN
80489: NOT
80490: AND
80491: PUSH
80492: LD_VAR 0 3
80496: PUSH
80497: LD_EXP 34
80501: PUSH
80502: LD_VAR 0 2
80506: ARRAY
80507: PUSH
80508: LD_INT 2
80510: ARRAY
80511: IN
80512: NOT
80513: AND
80514: IFFALSE 80577
// begin if IsInUnit ( j ) then
80516: LD_VAR 0 3
80520: PPUSH
80521: CALL_OW 310
80525: IFFALSE 80538
// ComExitBuilding ( j ) else
80527: LD_VAR 0 3
80531: PPUSH
80532: CALL_OW 122
80536: GO 80577
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
80538: LD_VAR 0 3
80542: PPUSH
80543: LD_VAR 0 7
80547: PUSH
80548: LD_INT 1
80550: ARRAY
80551: PPUSH
80552: CALL 59651 0 2
80556: NOT
80557: IFFALSE 80577
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
80559: LD_VAR 0 3
80563: PPUSH
80564: LD_VAR 0 7
80568: PUSH
80569: LD_INT 1
80571: ARRAY
80572: PPUSH
80573: CALL_OW 129
// end ; end ;
80577: GO 80401
80579: POP
80580: POP
// end ;
80581: GO 79862
80583: POP
80584: POP
// end ;
80585: LD_VAR 0 1
80589: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
80590: LD_INT 0
80592: PPUSH
80593: PPUSH
80594: PPUSH
80595: PPUSH
80596: PPUSH
80597: PPUSH
80598: PPUSH
80599: PPUSH
80600: PPUSH
80601: PPUSH
80602: PPUSH
// if not mc_bases then
80603: LD_EXP 31
80607: NOT
80608: IFFALSE 80612
// exit ;
80610: GO 81414
// for i = 1 to mc_bases do
80612: LD_ADDR_VAR 0 2
80616: PUSH
80617: DOUBLE
80618: LD_INT 1
80620: DEC
80621: ST_TO_ADDR
80622: LD_EXP 31
80626: PUSH
80627: FOR_TO
80628: IFFALSE 81412
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
80630: LD_EXP 59
80634: PUSH
80635: LD_VAR 0 2
80639: ARRAY
80640: NOT
80641: PUSH
80642: LD_EXP 34
80646: PUSH
80647: LD_VAR 0 2
80651: ARRAY
80652: PUSH
80653: LD_INT 1
80655: ARRAY
80656: OR
80657: PUSH
80658: LD_EXP 34
80662: PUSH
80663: LD_VAR 0 2
80667: ARRAY
80668: PUSH
80669: LD_INT 2
80671: ARRAY
80672: OR
80673: PUSH
80674: LD_EXP 57
80678: PUSH
80679: LD_VAR 0 2
80683: ARRAY
80684: PPUSH
80685: LD_INT 1
80687: PPUSH
80688: CALL_OW 325
80692: NOT
80693: OR
80694: PUSH
80695: LD_EXP 54
80699: PUSH
80700: LD_VAR 0 2
80704: ARRAY
80705: OR
80706: IFFALSE 80710
// continue ;
80708: GO 80627
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80710: LD_ADDR_VAR 0 8
80714: PUSH
80715: LD_EXP 31
80719: PUSH
80720: LD_VAR 0 2
80724: ARRAY
80725: PPUSH
80726: LD_INT 25
80728: PUSH
80729: LD_INT 4
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 50
80738: PUSH
80739: EMPTY
80740: LIST
80741: PUSH
80742: LD_INT 3
80744: PUSH
80745: LD_INT 60
80747: PUSH
80748: EMPTY
80749: LIST
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: LIST
80759: PPUSH
80760: CALL_OW 72
80764: PUSH
80765: LD_EXP 35
80769: PUSH
80770: LD_VAR 0 2
80774: ARRAY
80775: DIFF
80776: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80777: LD_ADDR_VAR 0 9
80781: PUSH
80782: LD_EXP 31
80786: PUSH
80787: LD_VAR 0 2
80791: ARRAY
80792: PPUSH
80793: LD_INT 2
80795: PUSH
80796: LD_INT 30
80798: PUSH
80799: LD_INT 0
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 30
80808: PUSH
80809: LD_INT 1
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: LIST
80820: PPUSH
80821: CALL_OW 72
80825: ST_TO_ADDR
// if not tmp or not dep then
80826: LD_VAR 0 8
80830: NOT
80831: PUSH
80832: LD_VAR 0 9
80836: NOT
80837: OR
80838: IFFALSE 80842
// continue ;
80840: GO 80627
// side := GetSide ( tmp [ 1 ] ) ;
80842: LD_ADDR_VAR 0 11
80846: PUSH
80847: LD_VAR 0 8
80851: PUSH
80852: LD_INT 1
80854: ARRAY
80855: PPUSH
80856: CALL_OW 255
80860: ST_TO_ADDR
// dep := dep [ 1 ] ;
80861: LD_ADDR_VAR 0 9
80865: PUSH
80866: LD_VAR 0 9
80870: PUSH
80871: LD_INT 1
80873: ARRAY
80874: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80875: LD_ADDR_VAR 0 7
80879: PUSH
80880: LD_EXP 59
80884: PUSH
80885: LD_VAR 0 2
80889: ARRAY
80890: PPUSH
80891: LD_INT 22
80893: PUSH
80894: LD_INT 0
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 25
80903: PUSH
80904: LD_INT 12
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PPUSH
80915: CALL_OW 70
80919: PUSH
80920: LD_INT 22
80922: PUSH
80923: LD_INT 0
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 25
80932: PUSH
80933: LD_INT 12
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: PUSH
80940: LD_INT 91
80942: PUSH
80943: LD_VAR 0 9
80947: PUSH
80948: LD_INT 20
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: LIST
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: LIST
80960: PPUSH
80961: CALL_OW 69
80965: UNION
80966: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80967: LD_ADDR_VAR 0 10
80971: PUSH
80972: LD_EXP 59
80976: PUSH
80977: LD_VAR 0 2
80981: ARRAY
80982: PPUSH
80983: LD_INT 81
80985: PUSH
80986: LD_VAR 0 11
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PPUSH
80995: CALL_OW 70
80999: ST_TO_ADDR
// if not apes or danger_at_area then
81000: LD_VAR 0 7
81004: NOT
81005: PUSH
81006: LD_VAR 0 10
81010: OR
81011: IFFALSE 81061
// begin if mc_taming [ i ] then
81013: LD_EXP 62
81017: PUSH
81018: LD_VAR 0 2
81022: ARRAY
81023: IFFALSE 81059
// begin MC_Reset ( i , 121 ) ;
81025: LD_VAR 0 2
81029: PPUSH
81030: LD_INT 121
81032: PPUSH
81033: CALL 65977 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
81037: LD_ADDR_EXP 62
81041: PUSH
81042: LD_EXP 62
81046: PPUSH
81047: LD_VAR 0 2
81051: PPUSH
81052: EMPTY
81053: PPUSH
81054: CALL_OW 1
81058: ST_TO_ADDR
// end ; continue ;
81059: GO 80627
// end ; for j in tmp do
81061: LD_ADDR_VAR 0 3
81065: PUSH
81066: LD_VAR 0 8
81070: PUSH
81071: FOR_IN
81072: IFFALSE 81408
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
81074: LD_VAR 0 3
81078: PUSH
81079: LD_EXP 62
81083: PUSH
81084: LD_VAR 0 2
81088: ARRAY
81089: IN
81090: NOT
81091: PUSH
81092: LD_EXP 62
81096: PUSH
81097: LD_VAR 0 2
81101: ARRAY
81102: PUSH
81103: LD_INT 3
81105: LESS
81106: AND
81107: IFFALSE 81165
// begin SetTag ( j , 121 ) ;
81109: LD_VAR 0 3
81113: PPUSH
81114: LD_INT 121
81116: PPUSH
81117: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
81121: LD_ADDR_EXP 62
81125: PUSH
81126: LD_EXP 62
81130: PPUSH
81131: LD_VAR 0 2
81135: PUSH
81136: LD_EXP 62
81140: PUSH
81141: LD_VAR 0 2
81145: ARRAY
81146: PUSH
81147: LD_INT 1
81149: PLUS
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: PPUSH
81155: LD_VAR 0 3
81159: PPUSH
81160: CALL 24846 0 3
81164: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
81165: LD_VAR 0 3
81169: PUSH
81170: LD_EXP 62
81174: PUSH
81175: LD_VAR 0 2
81179: ARRAY
81180: IN
81181: IFFALSE 81406
// begin if GetClass ( j ) <> 4 then
81183: LD_VAR 0 3
81187: PPUSH
81188: CALL_OW 257
81192: PUSH
81193: LD_INT 4
81195: NONEQUAL
81196: IFFALSE 81249
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
81198: LD_ADDR_EXP 62
81202: PUSH
81203: LD_EXP 62
81207: PPUSH
81208: LD_VAR 0 2
81212: PPUSH
81213: LD_EXP 62
81217: PUSH
81218: LD_VAR 0 2
81222: ARRAY
81223: PUSH
81224: LD_VAR 0 3
81228: DIFF
81229: PPUSH
81230: CALL_OW 1
81234: ST_TO_ADDR
// SetTag ( j , 0 ) ;
81235: LD_VAR 0 3
81239: PPUSH
81240: LD_INT 0
81242: PPUSH
81243: CALL_OW 109
// continue ;
81247: GO 81071
// end ; if IsInUnit ( j ) then
81249: LD_VAR 0 3
81253: PPUSH
81254: CALL_OW 310
81258: IFFALSE 81269
// ComExitBuilding ( j ) ;
81260: LD_VAR 0 3
81264: PPUSH
81265: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
81269: LD_ADDR_VAR 0 6
81273: PUSH
81274: LD_VAR 0 7
81278: PPUSH
81279: LD_VAR 0 3
81283: PPUSH
81284: CALL_OW 74
81288: ST_TO_ADDR
// if not ape then
81289: LD_VAR 0 6
81293: NOT
81294: IFFALSE 81298
// break ;
81296: GO 81408
// x := GetX ( ape ) ;
81298: LD_ADDR_VAR 0 4
81302: PUSH
81303: LD_VAR 0 6
81307: PPUSH
81308: CALL_OW 250
81312: ST_TO_ADDR
// y := GetY ( ape ) ;
81313: LD_ADDR_VAR 0 5
81317: PUSH
81318: LD_VAR 0 6
81322: PPUSH
81323: CALL_OW 251
81327: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81328: LD_VAR 0 4
81332: PPUSH
81333: LD_VAR 0 5
81337: PPUSH
81338: CALL_OW 488
81342: NOT
81343: PUSH
81344: LD_VAR 0 11
81348: PPUSH
81349: LD_VAR 0 4
81353: PPUSH
81354: LD_VAR 0 5
81358: PPUSH
81359: LD_INT 20
81361: PPUSH
81362: CALL 26110 0 4
81366: PUSH
81367: LD_INT 4
81369: ARRAY
81370: OR
81371: IFFALSE 81375
// break ;
81373: GO 81408
// if not HasTask ( j ) then
81375: LD_VAR 0 3
81379: PPUSH
81380: CALL_OW 314
81384: NOT
81385: IFFALSE 81406
// ComTameXY ( j , x , y ) ;
81387: LD_VAR 0 3
81391: PPUSH
81392: LD_VAR 0 4
81396: PPUSH
81397: LD_VAR 0 5
81401: PPUSH
81402: CALL_OW 131
// end ; end ;
81406: GO 81071
81408: POP
81409: POP
// end ;
81410: GO 80627
81412: POP
81413: POP
// end ;
81414: LD_VAR 0 1
81418: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
81419: LD_INT 0
81421: PPUSH
81422: PPUSH
81423: PPUSH
81424: PPUSH
81425: PPUSH
81426: PPUSH
81427: PPUSH
81428: PPUSH
// if not mc_bases then
81429: LD_EXP 31
81433: NOT
81434: IFFALSE 81438
// exit ;
81436: GO 82064
// for i = 1 to mc_bases do
81438: LD_ADDR_VAR 0 2
81442: PUSH
81443: DOUBLE
81444: LD_INT 1
81446: DEC
81447: ST_TO_ADDR
81448: LD_EXP 31
81452: PUSH
81453: FOR_TO
81454: IFFALSE 82062
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
81456: LD_EXP 60
81460: PUSH
81461: LD_VAR 0 2
81465: ARRAY
81466: NOT
81467: PUSH
81468: LD_EXP 60
81472: PUSH
81473: LD_VAR 0 2
81477: ARRAY
81478: PPUSH
81479: LD_INT 25
81481: PUSH
81482: LD_INT 12
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PPUSH
81489: CALL_OW 72
81493: NOT
81494: OR
81495: IFFALSE 81499
// continue ;
81497: GO 81453
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
81499: LD_ADDR_VAR 0 5
81503: PUSH
81504: LD_EXP 60
81508: PUSH
81509: LD_VAR 0 2
81513: ARRAY
81514: PUSH
81515: LD_INT 1
81517: ARRAY
81518: PPUSH
81519: CALL_OW 255
81523: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
81524: LD_VAR 0 5
81528: PPUSH
81529: LD_INT 2
81531: PPUSH
81532: CALL_OW 325
81536: IFFALSE 81789
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81538: LD_ADDR_VAR 0 4
81542: PUSH
81543: LD_EXP 60
81547: PUSH
81548: LD_VAR 0 2
81552: ARRAY
81553: PPUSH
81554: LD_INT 25
81556: PUSH
81557: LD_INT 16
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PPUSH
81564: CALL_OW 72
81568: ST_TO_ADDR
// if tmp < 6 then
81569: LD_VAR 0 4
81573: PUSH
81574: LD_INT 6
81576: LESS
81577: IFFALSE 81789
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81579: LD_ADDR_VAR 0 6
81583: PUSH
81584: LD_EXP 31
81588: PUSH
81589: LD_VAR 0 2
81593: ARRAY
81594: PPUSH
81595: LD_INT 2
81597: PUSH
81598: LD_INT 30
81600: PUSH
81601: LD_INT 0
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 30
81610: PUSH
81611: LD_INT 1
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: LIST
81622: PPUSH
81623: CALL_OW 72
81627: ST_TO_ADDR
// if depot then
81628: LD_VAR 0 6
81632: IFFALSE 81789
// begin selected := 0 ;
81634: LD_ADDR_VAR 0 7
81638: PUSH
81639: LD_INT 0
81641: ST_TO_ADDR
// for j in depot do
81642: LD_ADDR_VAR 0 3
81646: PUSH
81647: LD_VAR 0 6
81651: PUSH
81652: FOR_IN
81653: IFFALSE 81684
// begin if UnitsInside ( j ) < 6 then
81655: LD_VAR 0 3
81659: PPUSH
81660: CALL_OW 313
81664: PUSH
81665: LD_INT 6
81667: LESS
81668: IFFALSE 81682
// begin selected := j ;
81670: LD_ADDR_VAR 0 7
81674: PUSH
81675: LD_VAR 0 3
81679: ST_TO_ADDR
// break ;
81680: GO 81684
// end ; end ;
81682: GO 81652
81684: POP
81685: POP
// if selected then
81686: LD_VAR 0 7
81690: IFFALSE 81789
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81692: LD_ADDR_VAR 0 3
81696: PUSH
81697: LD_EXP 60
81701: PUSH
81702: LD_VAR 0 2
81706: ARRAY
81707: PPUSH
81708: LD_INT 25
81710: PUSH
81711: LD_INT 12
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PPUSH
81718: CALL_OW 72
81722: PUSH
81723: FOR_IN
81724: IFFALSE 81787
// if not HasTask ( j ) then
81726: LD_VAR 0 3
81730: PPUSH
81731: CALL_OW 314
81735: NOT
81736: IFFALSE 81785
// begin if not IsInUnit ( j ) then
81738: LD_VAR 0 3
81742: PPUSH
81743: CALL_OW 310
81747: NOT
81748: IFFALSE 81764
// ComEnterUnit ( j , selected ) ;
81750: LD_VAR 0 3
81754: PPUSH
81755: LD_VAR 0 7
81759: PPUSH
81760: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81764: LD_VAR 0 3
81768: PPUSH
81769: LD_INT 16
81771: PPUSH
81772: CALL_OW 183
// AddComExitBuilding ( j ) ;
81776: LD_VAR 0 3
81780: PPUSH
81781: CALL_OW 182
// end ;
81785: GO 81723
81787: POP
81788: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81789: LD_VAR 0 5
81793: PPUSH
81794: LD_INT 11
81796: PPUSH
81797: CALL_OW 325
81801: IFFALSE 82060
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81803: LD_ADDR_VAR 0 4
81807: PUSH
81808: LD_EXP 60
81812: PUSH
81813: LD_VAR 0 2
81817: ARRAY
81818: PPUSH
81819: LD_INT 25
81821: PUSH
81822: LD_INT 16
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PPUSH
81829: CALL_OW 72
81833: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81834: LD_VAR 0 4
81838: PUSH
81839: LD_INT 6
81841: GREATEREQUAL
81842: PUSH
81843: LD_VAR 0 5
81847: PPUSH
81848: LD_INT 2
81850: PPUSH
81851: CALL_OW 325
81855: NOT
81856: OR
81857: IFFALSE 82060
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81859: LD_ADDR_VAR 0 8
81863: PUSH
81864: LD_EXP 31
81868: PUSH
81869: LD_VAR 0 2
81873: ARRAY
81874: PPUSH
81875: LD_INT 2
81877: PUSH
81878: LD_INT 30
81880: PUSH
81881: LD_INT 4
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_INT 30
81890: PUSH
81891: LD_INT 5
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: LIST
81902: PPUSH
81903: CALL_OW 72
81907: ST_TO_ADDR
// if barracks then
81908: LD_VAR 0 8
81912: IFFALSE 82060
// begin selected := 0 ;
81914: LD_ADDR_VAR 0 7
81918: PUSH
81919: LD_INT 0
81921: ST_TO_ADDR
// for j in barracks do
81922: LD_ADDR_VAR 0 3
81926: PUSH
81927: LD_VAR 0 8
81931: PUSH
81932: FOR_IN
81933: IFFALSE 81964
// begin if UnitsInside ( j ) < 6 then
81935: LD_VAR 0 3
81939: PPUSH
81940: CALL_OW 313
81944: PUSH
81945: LD_INT 6
81947: LESS
81948: IFFALSE 81962
// begin selected := j ;
81950: LD_ADDR_VAR 0 7
81954: PUSH
81955: LD_VAR 0 3
81959: ST_TO_ADDR
// break ;
81960: GO 81964
// end ; end ;
81962: GO 81932
81964: POP
81965: POP
// if selected then
81966: LD_VAR 0 7
81970: IFFALSE 82060
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81972: LD_ADDR_VAR 0 3
81976: PUSH
81977: LD_EXP 60
81981: PUSH
81982: LD_VAR 0 2
81986: ARRAY
81987: PPUSH
81988: LD_INT 25
81990: PUSH
81991: LD_INT 12
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PPUSH
81998: CALL_OW 72
82002: PUSH
82003: FOR_IN
82004: IFFALSE 82058
// if not IsInUnit ( j ) and not HasTask ( j ) then
82006: LD_VAR 0 3
82010: PPUSH
82011: CALL_OW 310
82015: NOT
82016: PUSH
82017: LD_VAR 0 3
82021: PPUSH
82022: CALL_OW 314
82026: NOT
82027: AND
82028: IFFALSE 82056
// begin ComEnterUnit ( j , selected ) ;
82030: LD_VAR 0 3
82034: PPUSH
82035: LD_VAR 0 7
82039: PPUSH
82040: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
82044: LD_VAR 0 3
82048: PPUSH
82049: LD_INT 15
82051: PPUSH
82052: CALL_OW 183
// end ;
82056: GO 82003
82058: POP
82059: POP
// end ; end ; end ; end ; end ;
82060: GO 81453
82062: POP
82063: POP
// end ;
82064: LD_VAR 0 1
82068: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
82069: LD_INT 0
82071: PPUSH
82072: PPUSH
82073: PPUSH
82074: PPUSH
// if not mc_bases then
82075: LD_EXP 31
82079: NOT
82080: IFFALSE 82084
// exit ;
82082: GO 82262
// for i = 1 to mc_bases do
82084: LD_ADDR_VAR 0 2
82088: PUSH
82089: DOUBLE
82090: LD_INT 1
82092: DEC
82093: ST_TO_ADDR
82094: LD_EXP 31
82098: PUSH
82099: FOR_TO
82100: IFFALSE 82260
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
82102: LD_ADDR_VAR 0 4
82106: PUSH
82107: LD_EXP 31
82111: PUSH
82112: LD_VAR 0 2
82116: ARRAY
82117: PPUSH
82118: LD_INT 25
82120: PUSH
82121: LD_INT 9
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PPUSH
82128: CALL_OW 72
82132: ST_TO_ADDR
// if not tmp then
82133: LD_VAR 0 4
82137: NOT
82138: IFFALSE 82142
// continue ;
82140: GO 82099
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
82142: LD_EXP 57
82146: PUSH
82147: LD_VAR 0 2
82151: ARRAY
82152: PPUSH
82153: LD_INT 29
82155: PPUSH
82156: CALL_OW 325
82160: NOT
82161: PUSH
82162: LD_EXP 57
82166: PUSH
82167: LD_VAR 0 2
82171: ARRAY
82172: PPUSH
82173: LD_INT 28
82175: PPUSH
82176: CALL_OW 325
82180: NOT
82181: AND
82182: IFFALSE 82186
// continue ;
82184: GO 82099
// for j in tmp do
82186: LD_ADDR_VAR 0 3
82190: PUSH
82191: LD_VAR 0 4
82195: PUSH
82196: FOR_IN
82197: IFFALSE 82256
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
82199: LD_VAR 0 3
82203: PUSH
82204: LD_EXP 34
82208: PUSH
82209: LD_VAR 0 2
82213: ARRAY
82214: PUSH
82215: LD_INT 1
82217: ARRAY
82218: IN
82219: NOT
82220: PUSH
82221: LD_VAR 0 3
82225: PUSH
82226: LD_EXP 34
82230: PUSH
82231: LD_VAR 0 2
82235: ARRAY
82236: PUSH
82237: LD_INT 2
82239: ARRAY
82240: IN
82241: NOT
82242: AND
82243: IFFALSE 82254
// ComSpaceTimeShoot ( j ) ;
82245: LD_VAR 0 3
82249: PPUSH
82250: CALL 20831 0 1
82254: GO 82196
82256: POP
82257: POP
// end ;
82258: GO 82099
82260: POP
82261: POP
// end ;
82262: LD_VAR 0 1
82266: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
82267: LD_INT 0
82269: PPUSH
82270: PPUSH
82271: PPUSH
82272: PPUSH
82273: PPUSH
82274: PPUSH
82275: PPUSH
82276: PPUSH
82277: PPUSH
// if not mc_bases then
82278: LD_EXP 31
82282: NOT
82283: IFFALSE 82287
// exit ;
82285: GO 82909
// for i = 1 to mc_bases do
82287: LD_ADDR_VAR 0 2
82291: PUSH
82292: DOUBLE
82293: LD_INT 1
82295: DEC
82296: ST_TO_ADDR
82297: LD_EXP 31
82301: PUSH
82302: FOR_TO
82303: IFFALSE 82907
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
82305: LD_EXP 66
82309: PUSH
82310: LD_VAR 0 2
82314: ARRAY
82315: NOT
82316: PUSH
82317: LD_INT 38
82319: PPUSH
82320: LD_EXP 57
82324: PUSH
82325: LD_VAR 0 2
82329: ARRAY
82330: PPUSH
82331: CALL_OW 321
82335: PUSH
82336: LD_INT 2
82338: NONEQUAL
82339: OR
82340: IFFALSE 82344
// continue ;
82342: GO 82302
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
82344: LD_ADDR_VAR 0 8
82348: PUSH
82349: LD_EXP 31
82353: PUSH
82354: LD_VAR 0 2
82358: ARRAY
82359: PPUSH
82360: LD_INT 30
82362: PUSH
82363: LD_INT 34
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PPUSH
82370: CALL_OW 72
82374: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
82375: LD_ADDR_VAR 0 9
82379: PUSH
82380: LD_EXP 31
82384: PUSH
82385: LD_VAR 0 2
82389: ARRAY
82390: PPUSH
82391: LD_INT 25
82393: PUSH
82394: LD_INT 4
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: PPUSH
82401: CALL_OW 72
82405: PPUSH
82406: LD_INT 0
82408: PPUSH
82409: CALL 55155 0 2
82413: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
82414: LD_VAR 0 9
82418: NOT
82419: PUSH
82420: LD_VAR 0 8
82424: NOT
82425: OR
82426: PUSH
82427: LD_EXP 31
82431: PUSH
82432: LD_VAR 0 2
82436: ARRAY
82437: PPUSH
82438: LD_INT 124
82440: PPUSH
82441: CALL 55155 0 2
82445: OR
82446: IFFALSE 82450
// continue ;
82448: GO 82302
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
82450: LD_EXP 67
82454: PUSH
82455: LD_VAR 0 2
82459: ARRAY
82460: PUSH
82461: LD_EXP 66
82465: PUSH
82466: LD_VAR 0 2
82470: ARRAY
82471: LESS
82472: PUSH
82473: LD_EXP 67
82477: PUSH
82478: LD_VAR 0 2
82482: ARRAY
82483: PUSH
82484: LD_VAR 0 8
82488: LESS
82489: AND
82490: IFFALSE 82905
// begin tmp := sci [ 1 ] ;
82492: LD_ADDR_VAR 0 7
82496: PUSH
82497: LD_VAR 0 9
82501: PUSH
82502: LD_INT 1
82504: ARRAY
82505: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
82506: LD_VAR 0 7
82510: PPUSH
82511: LD_INT 124
82513: PPUSH
82514: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
82518: LD_ADDR_VAR 0 3
82522: PUSH
82523: DOUBLE
82524: LD_EXP 66
82528: PUSH
82529: LD_VAR 0 2
82533: ARRAY
82534: INC
82535: ST_TO_ADDR
82536: LD_EXP 66
82540: PUSH
82541: LD_VAR 0 2
82545: ARRAY
82546: PUSH
82547: FOR_DOWNTO
82548: IFFALSE 82891
// begin if IsInUnit ( tmp ) then
82550: LD_VAR 0 7
82554: PPUSH
82555: CALL_OW 310
82559: IFFALSE 82570
// ComExitBuilding ( tmp ) ;
82561: LD_VAR 0 7
82565: PPUSH
82566: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
82570: LD_INT 35
82572: PPUSH
82573: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
82577: LD_VAR 0 7
82581: PPUSH
82582: CALL_OW 310
82586: NOT
82587: PUSH
82588: LD_VAR 0 7
82592: PPUSH
82593: CALL_OW 314
82597: NOT
82598: AND
82599: IFFALSE 82570
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
82601: LD_ADDR_VAR 0 6
82605: PUSH
82606: LD_VAR 0 7
82610: PPUSH
82611: CALL_OW 250
82615: PUSH
82616: LD_VAR 0 7
82620: PPUSH
82621: CALL_OW 251
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
82630: LD_INT 35
82632: PPUSH
82633: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82637: LD_ADDR_VAR 0 4
82641: PUSH
82642: LD_EXP 66
82646: PUSH
82647: LD_VAR 0 2
82651: ARRAY
82652: PUSH
82653: LD_VAR 0 3
82657: ARRAY
82658: PUSH
82659: LD_INT 1
82661: ARRAY
82662: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82663: LD_ADDR_VAR 0 5
82667: PUSH
82668: LD_EXP 66
82672: PUSH
82673: LD_VAR 0 2
82677: ARRAY
82678: PUSH
82679: LD_VAR 0 3
82683: ARRAY
82684: PUSH
82685: LD_INT 2
82687: ARRAY
82688: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82689: LD_VAR 0 7
82693: PPUSH
82694: LD_INT 10
82696: PPUSH
82697: CALL 27811 0 2
82701: PUSH
82702: LD_INT 4
82704: ARRAY
82705: IFFALSE 82743
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82707: LD_VAR 0 7
82711: PPUSH
82712: LD_VAR 0 6
82716: PUSH
82717: LD_INT 1
82719: ARRAY
82720: PPUSH
82721: LD_VAR 0 6
82725: PUSH
82726: LD_INT 2
82728: ARRAY
82729: PPUSH
82730: CALL_OW 111
// wait ( 0 0$10 ) ;
82734: LD_INT 350
82736: PPUSH
82737: CALL_OW 67
// end else
82741: GO 82769
// begin ComMoveXY ( tmp , x , y ) ;
82743: LD_VAR 0 7
82747: PPUSH
82748: LD_VAR 0 4
82752: PPUSH
82753: LD_VAR 0 5
82757: PPUSH
82758: CALL_OW 111
// wait ( 0 0$3 ) ;
82762: LD_INT 105
82764: PPUSH
82765: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82769: LD_VAR 0 7
82773: PPUSH
82774: LD_VAR 0 4
82778: PPUSH
82779: LD_VAR 0 5
82783: PPUSH
82784: CALL_OW 307
82788: IFFALSE 82630
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82790: LD_VAR 0 7
82794: PPUSH
82795: LD_VAR 0 4
82799: PPUSH
82800: LD_VAR 0 5
82804: PPUSH
82805: LD_VAR 0 8
82809: PUSH
82810: LD_VAR 0 3
82814: ARRAY
82815: PPUSH
82816: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82820: LD_INT 35
82822: PPUSH
82823: CALL_OW 67
// until not HasTask ( tmp ) ;
82827: LD_VAR 0 7
82831: PPUSH
82832: CALL_OW 314
82836: NOT
82837: IFFALSE 82820
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82839: LD_ADDR_EXP 67
82843: PUSH
82844: LD_EXP 67
82848: PPUSH
82849: LD_VAR 0 2
82853: PUSH
82854: LD_EXP 67
82858: PUSH
82859: LD_VAR 0 2
82863: ARRAY
82864: PUSH
82865: LD_INT 1
82867: PLUS
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PPUSH
82873: LD_VAR 0 8
82877: PUSH
82878: LD_VAR 0 3
82882: ARRAY
82883: PPUSH
82884: CALL 24846 0 3
82888: ST_TO_ADDR
// end ;
82889: GO 82547
82891: POP
82892: POP
// MC_Reset ( i , 124 ) ;
82893: LD_VAR 0 2
82897: PPUSH
82898: LD_INT 124
82900: PPUSH
82901: CALL 65977 0 2
// end ; end ;
82905: GO 82302
82907: POP
82908: POP
// end ;
82909: LD_VAR 0 1
82913: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82914: LD_INT 0
82916: PPUSH
82917: PPUSH
82918: PPUSH
// if not mc_bases then
82919: LD_EXP 31
82923: NOT
82924: IFFALSE 82928
// exit ;
82926: GO 83534
// for i = 1 to mc_bases do
82928: LD_ADDR_VAR 0 2
82932: PUSH
82933: DOUBLE
82934: LD_INT 1
82936: DEC
82937: ST_TO_ADDR
82938: LD_EXP 31
82942: PUSH
82943: FOR_TO
82944: IFFALSE 83532
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82946: LD_ADDR_VAR 0 3
82950: PUSH
82951: LD_EXP 31
82955: PUSH
82956: LD_VAR 0 2
82960: ARRAY
82961: PPUSH
82962: LD_INT 25
82964: PUSH
82965: LD_INT 4
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PPUSH
82972: CALL_OW 72
82976: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82977: LD_VAR 0 3
82981: NOT
82982: PUSH
82983: LD_EXP 68
82987: PUSH
82988: LD_VAR 0 2
82992: ARRAY
82993: NOT
82994: OR
82995: PUSH
82996: LD_EXP 31
83000: PUSH
83001: LD_VAR 0 2
83005: ARRAY
83006: PPUSH
83007: LD_INT 2
83009: PUSH
83010: LD_INT 30
83012: PUSH
83013: LD_INT 0
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 30
83022: PUSH
83023: LD_INT 1
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: LIST
83034: PPUSH
83035: CALL_OW 72
83039: NOT
83040: OR
83041: IFFALSE 83091
// begin if mc_deposits_finder [ i ] then
83043: LD_EXP 69
83047: PUSH
83048: LD_VAR 0 2
83052: ARRAY
83053: IFFALSE 83089
// begin MC_Reset ( i , 125 ) ;
83055: LD_VAR 0 2
83059: PPUSH
83060: LD_INT 125
83062: PPUSH
83063: CALL 65977 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
83067: LD_ADDR_EXP 69
83071: PUSH
83072: LD_EXP 69
83076: PPUSH
83077: LD_VAR 0 2
83081: PPUSH
83082: EMPTY
83083: PPUSH
83084: CALL_OW 1
83088: ST_TO_ADDR
// end ; continue ;
83089: GO 82943
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
83091: LD_EXP 68
83095: PUSH
83096: LD_VAR 0 2
83100: ARRAY
83101: PUSH
83102: LD_INT 1
83104: ARRAY
83105: PUSH
83106: LD_INT 3
83108: ARRAY
83109: PUSH
83110: LD_INT 1
83112: EQUAL
83113: PUSH
83114: LD_INT 20
83116: PPUSH
83117: LD_EXP 57
83121: PUSH
83122: LD_VAR 0 2
83126: ARRAY
83127: PPUSH
83128: CALL_OW 321
83132: PUSH
83133: LD_INT 2
83135: NONEQUAL
83136: AND
83137: IFFALSE 83187
// begin if mc_deposits_finder [ i ] then
83139: LD_EXP 69
83143: PUSH
83144: LD_VAR 0 2
83148: ARRAY
83149: IFFALSE 83185
// begin MC_Reset ( i , 125 ) ;
83151: LD_VAR 0 2
83155: PPUSH
83156: LD_INT 125
83158: PPUSH
83159: CALL 65977 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
83163: LD_ADDR_EXP 69
83167: PUSH
83168: LD_EXP 69
83172: PPUSH
83173: LD_VAR 0 2
83177: PPUSH
83178: EMPTY
83179: PPUSH
83180: CALL_OW 1
83184: ST_TO_ADDR
// end ; continue ;
83185: GO 82943
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
83187: LD_EXP 68
83191: PUSH
83192: LD_VAR 0 2
83196: ARRAY
83197: PUSH
83198: LD_INT 1
83200: ARRAY
83201: PUSH
83202: LD_INT 1
83204: ARRAY
83205: PPUSH
83206: LD_EXP 68
83210: PUSH
83211: LD_VAR 0 2
83215: ARRAY
83216: PUSH
83217: LD_INT 1
83219: ARRAY
83220: PUSH
83221: LD_INT 2
83223: ARRAY
83224: PPUSH
83225: LD_EXP 57
83229: PUSH
83230: LD_VAR 0 2
83234: ARRAY
83235: PPUSH
83236: CALL_OW 440
83240: IFFALSE 83283
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
83242: LD_ADDR_EXP 68
83246: PUSH
83247: LD_EXP 68
83251: PPUSH
83252: LD_VAR 0 2
83256: PPUSH
83257: LD_EXP 68
83261: PUSH
83262: LD_VAR 0 2
83266: ARRAY
83267: PPUSH
83268: LD_INT 1
83270: PPUSH
83271: CALL_OW 3
83275: PPUSH
83276: CALL_OW 1
83280: ST_TO_ADDR
83281: GO 83530
// begin if not mc_deposits_finder [ i ] then
83283: LD_EXP 69
83287: PUSH
83288: LD_VAR 0 2
83292: ARRAY
83293: NOT
83294: IFFALSE 83346
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
83296: LD_ADDR_EXP 69
83300: PUSH
83301: LD_EXP 69
83305: PPUSH
83306: LD_VAR 0 2
83310: PPUSH
83311: LD_VAR 0 3
83315: PUSH
83316: LD_INT 1
83318: ARRAY
83319: PUSH
83320: EMPTY
83321: LIST
83322: PPUSH
83323: CALL_OW 1
83327: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
83328: LD_VAR 0 3
83332: PUSH
83333: LD_INT 1
83335: ARRAY
83336: PPUSH
83337: LD_INT 125
83339: PPUSH
83340: CALL_OW 109
// end else
83344: GO 83530
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
83346: LD_EXP 69
83350: PUSH
83351: LD_VAR 0 2
83355: ARRAY
83356: PUSH
83357: LD_INT 1
83359: ARRAY
83360: PPUSH
83361: CALL_OW 310
83365: IFFALSE 83388
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
83367: LD_EXP 69
83371: PUSH
83372: LD_VAR 0 2
83376: ARRAY
83377: PUSH
83378: LD_INT 1
83380: ARRAY
83381: PPUSH
83382: CALL_OW 122
83386: GO 83530
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
83388: LD_EXP 69
83392: PUSH
83393: LD_VAR 0 2
83397: ARRAY
83398: PUSH
83399: LD_INT 1
83401: ARRAY
83402: PPUSH
83403: CALL_OW 314
83407: NOT
83408: PUSH
83409: LD_EXP 69
83413: PUSH
83414: LD_VAR 0 2
83418: ARRAY
83419: PUSH
83420: LD_INT 1
83422: ARRAY
83423: PPUSH
83424: LD_EXP 68
83428: PUSH
83429: LD_VAR 0 2
83433: ARRAY
83434: PUSH
83435: LD_INT 1
83437: ARRAY
83438: PUSH
83439: LD_INT 1
83441: ARRAY
83442: PPUSH
83443: LD_EXP 68
83447: PUSH
83448: LD_VAR 0 2
83452: ARRAY
83453: PUSH
83454: LD_INT 1
83456: ARRAY
83457: PUSH
83458: LD_INT 2
83460: ARRAY
83461: PPUSH
83462: CALL_OW 297
83466: PUSH
83467: LD_INT 6
83469: GREATER
83470: AND
83471: IFFALSE 83530
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
83473: LD_EXP 69
83477: PUSH
83478: LD_VAR 0 2
83482: ARRAY
83483: PUSH
83484: LD_INT 1
83486: ARRAY
83487: PPUSH
83488: LD_EXP 68
83492: PUSH
83493: LD_VAR 0 2
83497: ARRAY
83498: PUSH
83499: LD_INT 1
83501: ARRAY
83502: PUSH
83503: LD_INT 1
83505: ARRAY
83506: PPUSH
83507: LD_EXP 68
83511: PUSH
83512: LD_VAR 0 2
83516: ARRAY
83517: PUSH
83518: LD_INT 1
83520: ARRAY
83521: PUSH
83522: LD_INT 2
83524: ARRAY
83525: PPUSH
83526: CALL_OW 111
// end ; end ; end ;
83530: GO 82943
83532: POP
83533: POP
// end ;
83534: LD_VAR 0 1
83538: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
83539: LD_INT 0
83541: PPUSH
83542: PPUSH
83543: PPUSH
83544: PPUSH
83545: PPUSH
83546: PPUSH
83547: PPUSH
83548: PPUSH
83549: PPUSH
83550: PPUSH
83551: PPUSH
// if not mc_bases then
83552: LD_EXP 31
83556: NOT
83557: IFFALSE 83561
// exit ;
83559: GO 84501
// for i = 1 to mc_bases do
83561: LD_ADDR_VAR 0 2
83565: PUSH
83566: DOUBLE
83567: LD_INT 1
83569: DEC
83570: ST_TO_ADDR
83571: LD_EXP 31
83575: PUSH
83576: FOR_TO
83577: IFFALSE 84499
// begin if not mc_bases [ i ] or mc_scan [ i ] then
83579: LD_EXP 31
83583: PUSH
83584: LD_VAR 0 2
83588: ARRAY
83589: NOT
83590: PUSH
83591: LD_EXP 54
83595: PUSH
83596: LD_VAR 0 2
83600: ARRAY
83601: OR
83602: IFFALSE 83606
// continue ;
83604: GO 83576
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
83606: LD_ADDR_VAR 0 7
83610: PUSH
83611: LD_EXP 31
83615: PUSH
83616: LD_VAR 0 2
83620: ARRAY
83621: PUSH
83622: LD_INT 1
83624: ARRAY
83625: PPUSH
83626: CALL_OW 248
83630: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83631: LD_VAR 0 7
83635: PUSH
83636: LD_INT 3
83638: EQUAL
83639: PUSH
83640: LD_EXP 50
83644: PUSH
83645: LD_VAR 0 2
83649: ARRAY
83650: PUSH
83651: LD_EXP 53
83655: PUSH
83656: LD_VAR 0 2
83660: ARRAY
83661: UNION
83662: PPUSH
83663: LD_INT 33
83665: PUSH
83666: LD_INT 2
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PPUSH
83673: CALL_OW 72
83677: NOT
83678: OR
83679: IFFALSE 83683
// continue ;
83681: GO 83576
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83683: LD_ADDR_VAR 0 9
83687: PUSH
83688: LD_EXP 31
83692: PUSH
83693: LD_VAR 0 2
83697: ARRAY
83698: PPUSH
83699: LD_INT 30
83701: PUSH
83702: LD_INT 36
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PPUSH
83709: CALL_OW 72
83713: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83714: LD_ADDR_VAR 0 10
83718: PUSH
83719: LD_EXP 50
83723: PUSH
83724: LD_VAR 0 2
83728: ARRAY
83729: PPUSH
83730: LD_INT 34
83732: PUSH
83733: LD_INT 31
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PPUSH
83740: CALL_OW 72
83744: ST_TO_ADDR
// if not cts and not mcts then
83745: LD_VAR 0 9
83749: NOT
83750: PUSH
83751: LD_VAR 0 10
83755: NOT
83756: AND
83757: IFFALSE 83761
// continue ;
83759: GO 83576
// x := cts ;
83761: LD_ADDR_VAR 0 11
83765: PUSH
83766: LD_VAR 0 9
83770: ST_TO_ADDR
// if not x then
83771: LD_VAR 0 11
83775: NOT
83776: IFFALSE 83788
// x := mcts ;
83778: LD_ADDR_VAR 0 11
83782: PUSH
83783: LD_VAR 0 10
83787: ST_TO_ADDR
// if not x then
83788: LD_VAR 0 11
83792: NOT
83793: IFFALSE 83797
// continue ;
83795: GO 83576
// if mc_remote_driver [ i ] then
83797: LD_EXP 71
83801: PUSH
83802: LD_VAR 0 2
83806: ARRAY
83807: IFFALSE 84194
// for j in mc_remote_driver [ i ] do
83809: LD_ADDR_VAR 0 3
83813: PUSH
83814: LD_EXP 71
83818: PUSH
83819: LD_VAR 0 2
83823: ARRAY
83824: PUSH
83825: FOR_IN
83826: IFFALSE 84192
// begin if GetClass ( j ) <> 3 then
83828: LD_VAR 0 3
83832: PPUSH
83833: CALL_OW 257
83837: PUSH
83838: LD_INT 3
83840: NONEQUAL
83841: IFFALSE 83894
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83843: LD_ADDR_EXP 71
83847: PUSH
83848: LD_EXP 71
83852: PPUSH
83853: LD_VAR 0 2
83857: PPUSH
83858: LD_EXP 71
83862: PUSH
83863: LD_VAR 0 2
83867: ARRAY
83868: PUSH
83869: LD_VAR 0 3
83873: DIFF
83874: PPUSH
83875: CALL_OW 1
83879: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83880: LD_VAR 0 3
83884: PPUSH
83885: LD_INT 0
83887: PPUSH
83888: CALL_OW 109
// continue ;
83892: GO 83825
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83894: LD_EXP 50
83898: PUSH
83899: LD_VAR 0 2
83903: ARRAY
83904: PPUSH
83905: LD_INT 34
83907: PUSH
83908: LD_INT 31
83910: PUSH
83911: EMPTY
83912: LIST
83913: LIST
83914: PUSH
83915: LD_INT 58
83917: PUSH
83918: EMPTY
83919: LIST
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PPUSH
83925: CALL_OW 72
83929: PUSH
83930: LD_VAR 0 3
83934: PPUSH
83935: CALL 55190 0 1
83939: NOT
83940: AND
83941: IFFALSE 84012
// begin if IsInUnit ( j ) then
83943: LD_VAR 0 3
83947: PPUSH
83948: CALL_OW 310
83952: IFFALSE 83963
// ComExitBuilding ( j ) ;
83954: LD_VAR 0 3
83958: PPUSH
83959: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83963: LD_VAR 0 3
83967: PPUSH
83968: LD_EXP 50
83972: PUSH
83973: LD_VAR 0 2
83977: ARRAY
83978: PPUSH
83979: LD_INT 34
83981: PUSH
83982: LD_INT 31
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: PUSH
83989: LD_INT 58
83991: PUSH
83992: EMPTY
83993: LIST
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PPUSH
83999: CALL_OW 72
84003: PUSH
84004: LD_INT 1
84006: ARRAY
84007: PPUSH
84008: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
84012: LD_VAR 0 3
84016: PPUSH
84017: CALL_OW 310
84021: NOT
84022: PUSH
84023: LD_VAR 0 3
84027: PPUSH
84028: CALL_OW 310
84032: PPUSH
84033: CALL_OW 266
84037: PUSH
84038: LD_INT 36
84040: NONEQUAL
84041: PUSH
84042: LD_VAR 0 3
84046: PPUSH
84047: CALL 55190 0 1
84051: NOT
84052: AND
84053: OR
84054: IFFALSE 84190
// begin if IsInUnit ( j ) then
84056: LD_VAR 0 3
84060: PPUSH
84061: CALL_OW 310
84065: IFFALSE 84076
// ComExitBuilding ( j ) ;
84067: LD_VAR 0 3
84071: PPUSH
84072: CALL_OW 122
// ct := 0 ;
84076: LD_ADDR_VAR 0 8
84080: PUSH
84081: LD_INT 0
84083: ST_TO_ADDR
// for k in x do
84084: LD_ADDR_VAR 0 4
84088: PUSH
84089: LD_VAR 0 11
84093: PUSH
84094: FOR_IN
84095: IFFALSE 84168
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
84097: LD_VAR 0 4
84101: PPUSH
84102: CALL_OW 264
84106: PUSH
84107: LD_INT 31
84109: EQUAL
84110: PUSH
84111: LD_VAR 0 4
84115: PPUSH
84116: CALL_OW 311
84120: NOT
84121: AND
84122: PUSH
84123: LD_VAR 0 4
84127: PPUSH
84128: CALL_OW 266
84132: PUSH
84133: LD_INT 36
84135: EQUAL
84136: PUSH
84137: LD_VAR 0 4
84141: PPUSH
84142: CALL_OW 313
84146: PUSH
84147: LD_INT 3
84149: LESS
84150: AND
84151: OR
84152: IFFALSE 84166
// begin ct := k ;
84154: LD_ADDR_VAR 0 8
84158: PUSH
84159: LD_VAR 0 4
84163: ST_TO_ADDR
// break ;
84164: GO 84168
// end ;
84166: GO 84094
84168: POP
84169: POP
// if ct then
84170: LD_VAR 0 8
84174: IFFALSE 84190
// ComEnterUnit ( j , ct ) ;
84176: LD_VAR 0 3
84180: PPUSH
84181: LD_VAR 0 8
84185: PPUSH
84186: CALL_OW 120
// end ; end ;
84190: GO 83825
84192: POP
84193: POP
// places := 0 ;
84194: LD_ADDR_VAR 0 5
84198: PUSH
84199: LD_INT 0
84201: ST_TO_ADDR
// for j = 1 to x do
84202: LD_ADDR_VAR 0 3
84206: PUSH
84207: DOUBLE
84208: LD_INT 1
84210: DEC
84211: ST_TO_ADDR
84212: LD_VAR 0 11
84216: PUSH
84217: FOR_TO
84218: IFFALSE 84294
// if GetWeapon ( x [ j ] ) = ar_control_tower then
84220: LD_VAR 0 11
84224: PUSH
84225: LD_VAR 0 3
84229: ARRAY
84230: PPUSH
84231: CALL_OW 264
84235: PUSH
84236: LD_INT 31
84238: EQUAL
84239: IFFALSE 84257
// places := places + 1 else
84241: LD_ADDR_VAR 0 5
84245: PUSH
84246: LD_VAR 0 5
84250: PUSH
84251: LD_INT 1
84253: PLUS
84254: ST_TO_ADDR
84255: GO 84292
// if GetBType ( x [ j ] ) = b_control_tower then
84257: LD_VAR 0 11
84261: PUSH
84262: LD_VAR 0 3
84266: ARRAY
84267: PPUSH
84268: CALL_OW 266
84272: PUSH
84273: LD_INT 36
84275: EQUAL
84276: IFFALSE 84292
// places := places + 3 ;
84278: LD_ADDR_VAR 0 5
84282: PUSH
84283: LD_VAR 0 5
84287: PUSH
84288: LD_INT 3
84290: PLUS
84291: ST_TO_ADDR
84292: GO 84217
84294: POP
84295: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
84296: LD_VAR 0 5
84300: PUSH
84301: LD_INT 0
84303: EQUAL
84304: PUSH
84305: LD_VAR 0 5
84309: PUSH
84310: LD_EXP 71
84314: PUSH
84315: LD_VAR 0 2
84319: ARRAY
84320: LESSEQUAL
84321: OR
84322: IFFALSE 84326
// continue ;
84324: GO 83576
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
84326: LD_ADDR_VAR 0 6
84330: PUSH
84331: LD_EXP 31
84335: PUSH
84336: LD_VAR 0 2
84340: ARRAY
84341: PPUSH
84342: LD_INT 25
84344: PUSH
84345: LD_INT 3
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PPUSH
84352: CALL_OW 72
84356: PUSH
84357: LD_EXP 71
84361: PUSH
84362: LD_VAR 0 2
84366: ARRAY
84367: DIFF
84368: PPUSH
84369: LD_INT 3
84371: PPUSH
84372: CALL 56090 0 2
84376: ST_TO_ADDR
// for j in tmp do
84377: LD_ADDR_VAR 0 3
84381: PUSH
84382: LD_VAR 0 6
84386: PUSH
84387: FOR_IN
84388: IFFALSE 84423
// if GetTag ( j ) > 0 then
84390: LD_VAR 0 3
84394: PPUSH
84395: CALL_OW 110
84399: PUSH
84400: LD_INT 0
84402: GREATER
84403: IFFALSE 84421
// tmp := tmp diff j ;
84405: LD_ADDR_VAR 0 6
84409: PUSH
84410: LD_VAR 0 6
84414: PUSH
84415: LD_VAR 0 3
84419: DIFF
84420: ST_TO_ADDR
84421: GO 84387
84423: POP
84424: POP
// if not tmp then
84425: LD_VAR 0 6
84429: NOT
84430: IFFALSE 84434
// continue ;
84432: GO 83576
// if places then
84434: LD_VAR 0 5
84438: IFFALSE 84497
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
84440: LD_ADDR_EXP 71
84444: PUSH
84445: LD_EXP 71
84449: PPUSH
84450: LD_VAR 0 2
84454: PPUSH
84455: LD_EXP 71
84459: PUSH
84460: LD_VAR 0 2
84464: ARRAY
84465: PUSH
84466: LD_VAR 0 6
84470: PUSH
84471: LD_INT 1
84473: ARRAY
84474: UNION
84475: PPUSH
84476: CALL_OW 1
84480: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
84481: LD_VAR 0 6
84485: PUSH
84486: LD_INT 1
84488: ARRAY
84489: PPUSH
84490: LD_INT 126
84492: PPUSH
84493: CALL_OW 109
// end ; end ;
84497: GO 83576
84499: POP
84500: POP
// end ;
84501: LD_VAR 0 1
84505: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
84506: LD_INT 0
84508: PPUSH
84509: PPUSH
84510: PPUSH
84511: PPUSH
84512: PPUSH
84513: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
84514: LD_VAR 0 1
84518: NOT
84519: PUSH
84520: LD_VAR 0 2
84524: NOT
84525: OR
84526: PUSH
84527: LD_VAR 0 3
84531: NOT
84532: OR
84533: PUSH
84534: LD_VAR 0 4
84538: PUSH
84539: LD_INT 1
84541: PUSH
84542: LD_INT 2
84544: PUSH
84545: LD_INT 3
84547: PUSH
84548: LD_INT 4
84550: PUSH
84551: LD_INT 5
84553: PUSH
84554: LD_INT 8
84556: PUSH
84557: LD_INT 9
84559: PUSH
84560: LD_INT 15
84562: PUSH
84563: LD_INT 16
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: IN
84577: NOT
84578: OR
84579: IFFALSE 84583
// exit ;
84581: GO 85441
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
84583: LD_ADDR_VAR 0 2
84587: PUSH
84588: LD_VAR 0 2
84592: PPUSH
84593: LD_INT 21
84595: PUSH
84596: LD_INT 3
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: PUSH
84603: LD_INT 24
84605: PUSH
84606: LD_INT 250
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PPUSH
84617: CALL_OW 72
84621: ST_TO_ADDR
// case class of 1 , 15 :
84622: LD_VAR 0 4
84626: PUSH
84627: LD_INT 1
84629: DOUBLE
84630: EQUAL
84631: IFTRUE 84641
84633: LD_INT 15
84635: DOUBLE
84636: EQUAL
84637: IFTRUE 84641
84639: GO 84726
84641: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84642: LD_ADDR_VAR 0 8
84646: PUSH
84647: LD_VAR 0 2
84651: PPUSH
84652: LD_INT 2
84654: PUSH
84655: LD_INT 30
84657: PUSH
84658: LD_INT 32
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 30
84667: PUSH
84668: LD_INT 31
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: LIST
84679: PPUSH
84680: CALL_OW 72
84684: PUSH
84685: LD_VAR 0 2
84689: PPUSH
84690: LD_INT 2
84692: PUSH
84693: LD_INT 30
84695: PUSH
84696: LD_INT 4
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 30
84705: PUSH
84706: LD_INT 5
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: LIST
84717: PPUSH
84718: CALL_OW 72
84722: ADD
84723: ST_TO_ADDR
84724: GO 84972
84726: LD_INT 2
84728: DOUBLE
84729: EQUAL
84730: IFTRUE 84740
84732: LD_INT 16
84734: DOUBLE
84735: EQUAL
84736: IFTRUE 84740
84738: GO 84786
84740: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84741: LD_ADDR_VAR 0 8
84745: PUSH
84746: LD_VAR 0 2
84750: PPUSH
84751: LD_INT 2
84753: PUSH
84754: LD_INT 30
84756: PUSH
84757: LD_INT 0
84759: PUSH
84760: EMPTY
84761: LIST
84762: LIST
84763: PUSH
84764: LD_INT 30
84766: PUSH
84767: LD_INT 1
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: LIST
84778: PPUSH
84779: CALL_OW 72
84783: ST_TO_ADDR
84784: GO 84972
84786: LD_INT 3
84788: DOUBLE
84789: EQUAL
84790: IFTRUE 84794
84792: GO 84840
84794: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84795: LD_ADDR_VAR 0 8
84799: PUSH
84800: LD_VAR 0 2
84804: PPUSH
84805: LD_INT 2
84807: PUSH
84808: LD_INT 30
84810: PUSH
84811: LD_INT 2
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 30
84820: PUSH
84821: LD_INT 3
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: LIST
84832: PPUSH
84833: CALL_OW 72
84837: ST_TO_ADDR
84838: GO 84972
84840: LD_INT 4
84842: DOUBLE
84843: EQUAL
84844: IFTRUE 84848
84846: GO 84905
84848: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84849: LD_ADDR_VAR 0 8
84853: PUSH
84854: LD_VAR 0 2
84858: PPUSH
84859: LD_INT 2
84861: PUSH
84862: LD_INT 30
84864: PUSH
84865: LD_INT 6
84867: PUSH
84868: EMPTY
84869: LIST
84870: LIST
84871: PUSH
84872: LD_INT 30
84874: PUSH
84875: LD_INT 7
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PUSH
84882: LD_INT 30
84884: PUSH
84885: LD_INT 8
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: LIST
84896: LIST
84897: PPUSH
84898: CALL_OW 72
84902: ST_TO_ADDR
84903: GO 84972
84905: LD_INT 5
84907: DOUBLE
84908: EQUAL
84909: IFTRUE 84925
84911: LD_INT 8
84913: DOUBLE
84914: EQUAL
84915: IFTRUE 84925
84917: LD_INT 9
84919: DOUBLE
84920: EQUAL
84921: IFTRUE 84925
84923: GO 84971
84925: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84926: LD_ADDR_VAR 0 8
84930: PUSH
84931: LD_VAR 0 2
84935: PPUSH
84936: LD_INT 2
84938: PUSH
84939: LD_INT 30
84941: PUSH
84942: LD_INT 4
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 30
84951: PUSH
84952: LD_INT 5
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: LIST
84963: PPUSH
84964: CALL_OW 72
84968: ST_TO_ADDR
84969: GO 84972
84971: POP
// if not tmp then
84972: LD_VAR 0 8
84976: NOT
84977: IFFALSE 84981
// exit ;
84979: GO 85441
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84981: LD_VAR 0 4
84985: PUSH
84986: LD_INT 1
84988: PUSH
84989: LD_INT 15
84991: PUSH
84992: EMPTY
84993: LIST
84994: LIST
84995: IN
84996: PUSH
84997: LD_EXP 40
85001: PUSH
85002: LD_VAR 0 1
85006: ARRAY
85007: AND
85008: IFFALSE 85164
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
85010: LD_ADDR_VAR 0 9
85014: PUSH
85015: LD_EXP 40
85019: PUSH
85020: LD_VAR 0 1
85024: ARRAY
85025: PUSH
85026: LD_INT 1
85028: ARRAY
85029: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
85030: LD_VAR 0 9
85034: PUSH
85035: LD_EXP 41
85039: PUSH
85040: LD_VAR 0 1
85044: ARRAY
85045: IN
85046: NOT
85047: IFFALSE 85162
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
85049: LD_ADDR_EXP 41
85053: PUSH
85054: LD_EXP 41
85058: PPUSH
85059: LD_VAR 0 1
85063: PUSH
85064: LD_EXP 41
85068: PUSH
85069: LD_VAR 0 1
85073: ARRAY
85074: PUSH
85075: LD_INT 1
85077: PLUS
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PPUSH
85083: LD_VAR 0 9
85087: PPUSH
85088: CALL 24846 0 3
85092: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
85093: LD_ADDR_EXP 40
85097: PUSH
85098: LD_EXP 40
85102: PPUSH
85103: LD_VAR 0 1
85107: PPUSH
85108: LD_EXP 40
85112: PUSH
85113: LD_VAR 0 1
85117: ARRAY
85118: PUSH
85119: LD_VAR 0 9
85123: DIFF
85124: PPUSH
85125: CALL_OW 1
85129: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
85130: LD_VAR 0 3
85134: PPUSH
85135: LD_EXP 41
85139: PUSH
85140: LD_VAR 0 1
85144: ARRAY
85145: PUSH
85146: LD_EXP 41
85150: PUSH
85151: LD_VAR 0 1
85155: ARRAY
85156: ARRAY
85157: PPUSH
85158: CALL_OW 120
// end ; exit ;
85162: GO 85441
// end ; if tmp > 1 then
85164: LD_VAR 0 8
85168: PUSH
85169: LD_INT 1
85171: GREATER
85172: IFFALSE 85276
// for i = 2 to tmp do
85174: LD_ADDR_VAR 0 6
85178: PUSH
85179: DOUBLE
85180: LD_INT 2
85182: DEC
85183: ST_TO_ADDR
85184: LD_VAR 0 8
85188: PUSH
85189: FOR_TO
85190: IFFALSE 85274
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
85192: LD_VAR 0 8
85196: PUSH
85197: LD_VAR 0 6
85201: ARRAY
85202: PPUSH
85203: CALL_OW 461
85207: PUSH
85208: LD_INT 6
85210: EQUAL
85211: IFFALSE 85272
// begin x := tmp [ i ] ;
85213: LD_ADDR_VAR 0 9
85217: PUSH
85218: LD_VAR 0 8
85222: PUSH
85223: LD_VAR 0 6
85227: ARRAY
85228: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
85229: LD_ADDR_VAR 0 8
85233: PUSH
85234: LD_VAR 0 8
85238: PPUSH
85239: LD_VAR 0 6
85243: PPUSH
85244: CALL_OW 3
85248: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
85249: LD_ADDR_VAR 0 8
85253: PUSH
85254: LD_VAR 0 8
85258: PPUSH
85259: LD_INT 1
85261: PPUSH
85262: LD_VAR 0 9
85266: PPUSH
85267: CALL_OW 2
85271: ST_TO_ADDR
// end ;
85272: GO 85189
85274: POP
85275: POP
// for i in tmp do
85276: LD_ADDR_VAR 0 6
85280: PUSH
85281: LD_VAR 0 8
85285: PUSH
85286: FOR_IN
85287: IFFALSE 85314
// begin if IsNotFull ( i ) then
85289: LD_VAR 0 6
85293: PPUSH
85294: CALL 22068 0 1
85298: IFFALSE 85312
// begin j := i ;
85300: LD_ADDR_VAR 0 7
85304: PUSH
85305: LD_VAR 0 6
85309: ST_TO_ADDR
// break ;
85310: GO 85314
// end ; end ;
85312: GO 85286
85314: POP
85315: POP
// if j then
85316: LD_VAR 0 7
85320: IFFALSE 85338
// ComEnterUnit ( unit , j ) else
85322: LD_VAR 0 3
85326: PPUSH
85327: LD_VAR 0 7
85331: PPUSH
85332: CALL_OW 120
85336: GO 85441
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85338: LD_ADDR_VAR 0 10
85342: PUSH
85343: LD_VAR 0 2
85347: PPUSH
85348: LD_INT 2
85350: PUSH
85351: LD_INT 30
85353: PUSH
85354: LD_INT 0
85356: PUSH
85357: EMPTY
85358: LIST
85359: LIST
85360: PUSH
85361: LD_INT 30
85363: PUSH
85364: LD_INT 1
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: LIST
85375: PPUSH
85376: CALL_OW 72
85380: ST_TO_ADDR
// if depot then
85381: LD_VAR 0 10
85385: IFFALSE 85441
// begin depot := NearestUnitToUnit ( depot , unit ) ;
85387: LD_ADDR_VAR 0 10
85391: PUSH
85392: LD_VAR 0 10
85396: PPUSH
85397: LD_VAR 0 3
85401: PPUSH
85402: CALL_OW 74
85406: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
85407: LD_VAR 0 3
85411: PPUSH
85412: LD_VAR 0 10
85416: PPUSH
85417: CALL_OW 296
85421: PUSH
85422: LD_INT 10
85424: GREATER
85425: IFFALSE 85441
// ComStandNearbyBuilding ( unit , depot ) ;
85427: LD_VAR 0 3
85431: PPUSH
85432: LD_VAR 0 10
85436: PPUSH
85437: CALL 21448 0 2
// end ; end ; end ;
85441: LD_VAR 0 5
85445: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
85446: LD_INT 0
85448: PPUSH
85449: PPUSH
85450: PPUSH
85451: PPUSH
// if not mc_bases then
85452: LD_EXP 31
85456: NOT
85457: IFFALSE 85461
// exit ;
85459: GO 85700
// for i = 1 to mc_bases do
85461: LD_ADDR_VAR 0 2
85465: PUSH
85466: DOUBLE
85467: LD_INT 1
85469: DEC
85470: ST_TO_ADDR
85471: LD_EXP 31
85475: PUSH
85476: FOR_TO
85477: IFFALSE 85698
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
85479: LD_ADDR_VAR 0 4
85483: PUSH
85484: LD_EXP 31
85488: PUSH
85489: LD_VAR 0 2
85493: ARRAY
85494: PPUSH
85495: LD_INT 21
85497: PUSH
85498: LD_INT 1
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PPUSH
85505: CALL_OW 72
85509: PUSH
85510: LD_EXP 60
85514: PUSH
85515: LD_VAR 0 2
85519: ARRAY
85520: UNION
85521: ST_TO_ADDR
// if not tmp then
85522: LD_VAR 0 4
85526: NOT
85527: IFFALSE 85531
// continue ;
85529: GO 85476
// for j in tmp do
85531: LD_ADDR_VAR 0 3
85535: PUSH
85536: LD_VAR 0 4
85540: PUSH
85541: FOR_IN
85542: IFFALSE 85694
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
85544: LD_VAR 0 3
85548: PPUSH
85549: CALL_OW 110
85553: NOT
85554: PUSH
85555: LD_VAR 0 3
85559: PPUSH
85560: CALL_OW 314
85564: NOT
85565: AND
85566: PUSH
85567: LD_VAR 0 3
85571: PPUSH
85572: CALL_OW 311
85576: NOT
85577: AND
85578: PUSH
85579: LD_VAR 0 3
85583: PPUSH
85584: CALL_OW 310
85588: NOT
85589: AND
85590: PUSH
85591: LD_VAR 0 3
85595: PUSH
85596: LD_EXP 34
85600: PUSH
85601: LD_VAR 0 2
85605: ARRAY
85606: PUSH
85607: LD_INT 1
85609: ARRAY
85610: IN
85611: NOT
85612: AND
85613: PUSH
85614: LD_VAR 0 3
85618: PUSH
85619: LD_EXP 34
85623: PUSH
85624: LD_VAR 0 2
85628: ARRAY
85629: PUSH
85630: LD_INT 2
85632: ARRAY
85633: IN
85634: NOT
85635: AND
85636: PUSH
85637: LD_VAR 0 3
85641: PUSH
85642: LD_EXP 43
85646: PUSH
85647: LD_VAR 0 2
85651: ARRAY
85652: IN
85653: NOT
85654: AND
85655: IFFALSE 85692
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85657: LD_VAR 0 2
85661: PPUSH
85662: LD_EXP 31
85666: PUSH
85667: LD_VAR 0 2
85671: ARRAY
85672: PPUSH
85673: LD_VAR 0 3
85677: PPUSH
85678: LD_VAR 0 3
85682: PPUSH
85683: CALL_OW 257
85687: PPUSH
85688: CALL 84506 0 4
// end ;
85692: GO 85541
85694: POP
85695: POP
// end ;
85696: GO 85476
85698: POP
85699: POP
// end ;
85700: LD_VAR 0 1
85704: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
85705: LD_INT 0
85707: PPUSH
85708: PPUSH
85709: PPUSH
85710: PPUSH
85711: PPUSH
85712: PPUSH
// if not mc_bases [ base ] then
85713: LD_EXP 31
85717: PUSH
85718: LD_VAR 0 1
85722: ARRAY
85723: NOT
85724: IFFALSE 85728
// exit ;
85726: GO 85929
// tmp := [ ] ;
85728: LD_ADDR_VAR 0 6
85732: PUSH
85733: EMPTY
85734: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85735: LD_ADDR_VAR 0 7
85739: PUSH
85740: LD_VAR 0 3
85744: PPUSH
85745: LD_INT 0
85747: PPUSH
85748: CALL_OW 517
85752: ST_TO_ADDR
// if not list then
85753: LD_VAR 0 7
85757: NOT
85758: IFFALSE 85762
// exit ;
85760: GO 85929
// c := Count ( list [ 1 ] ) ;
85762: LD_ADDR_VAR 0 9
85766: PUSH
85767: LD_VAR 0 7
85771: PUSH
85772: LD_INT 1
85774: ARRAY
85775: PPUSH
85776: CALL 21986 0 1
85780: ST_TO_ADDR
// if amount > c then
85781: LD_VAR 0 2
85785: PUSH
85786: LD_VAR 0 9
85790: GREATER
85791: IFFALSE 85803
// amount := c ;
85793: LD_ADDR_VAR 0 2
85797: PUSH
85798: LD_VAR 0 9
85802: ST_TO_ADDR
// for i := 1 to amount do
85803: LD_ADDR_VAR 0 5
85807: PUSH
85808: DOUBLE
85809: LD_INT 1
85811: DEC
85812: ST_TO_ADDR
85813: LD_VAR 0 2
85817: PUSH
85818: FOR_TO
85819: IFFALSE 85877
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
85821: LD_ADDR_VAR 0 6
85825: PUSH
85826: LD_VAR 0 6
85830: PPUSH
85831: LD_VAR 0 5
85835: PPUSH
85836: LD_VAR 0 7
85840: PUSH
85841: LD_INT 1
85843: ARRAY
85844: PUSH
85845: LD_VAR 0 5
85849: ARRAY
85850: PUSH
85851: LD_VAR 0 7
85855: PUSH
85856: LD_INT 2
85858: ARRAY
85859: PUSH
85860: LD_VAR 0 5
85864: ARRAY
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PPUSH
85870: CALL_OW 1
85874: ST_TO_ADDR
85875: GO 85818
85877: POP
85878: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85879: LD_ADDR_EXP 44
85883: PUSH
85884: LD_EXP 44
85888: PPUSH
85889: LD_VAR 0 1
85893: PPUSH
85894: LD_VAR 0 6
85898: PPUSH
85899: CALL_OW 1
85903: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85904: LD_ADDR_EXP 46
85908: PUSH
85909: LD_EXP 46
85913: PPUSH
85914: LD_VAR 0 1
85918: PPUSH
85919: LD_VAR 0 3
85923: PPUSH
85924: CALL_OW 1
85928: ST_TO_ADDR
// end ;
85929: LD_VAR 0 4
85933: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85934: LD_INT 0
85936: PPUSH
// if not mc_bases [ base ] then
85937: LD_EXP 31
85941: PUSH
85942: LD_VAR 0 1
85946: ARRAY
85947: NOT
85948: IFFALSE 85952
// exit ;
85950: GO 85977
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85952: LD_ADDR_EXP 36
85956: PUSH
85957: LD_EXP 36
85961: PPUSH
85962: LD_VAR 0 1
85966: PPUSH
85967: LD_VAR 0 2
85971: PPUSH
85972: CALL_OW 1
85976: ST_TO_ADDR
// end ;
85977: LD_VAR 0 3
85981: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85982: LD_INT 0
85984: PPUSH
// if not mc_bases [ base ] then
85985: LD_EXP 31
85989: PUSH
85990: LD_VAR 0 1
85994: ARRAY
85995: NOT
85996: IFFALSE 86000
// exit ;
85998: GO 86037
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
86000: LD_ADDR_EXP 36
86004: PUSH
86005: LD_EXP 36
86009: PPUSH
86010: LD_VAR 0 1
86014: PPUSH
86015: LD_EXP 36
86019: PUSH
86020: LD_VAR 0 1
86024: ARRAY
86025: PUSH
86026: LD_VAR 0 2
86030: UNION
86031: PPUSH
86032: CALL_OW 1
86036: ST_TO_ADDR
// end ;
86037: LD_VAR 0 3
86041: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
86042: LD_INT 0
86044: PPUSH
// if not mc_bases [ base ] then
86045: LD_EXP 31
86049: PUSH
86050: LD_VAR 0 1
86054: ARRAY
86055: NOT
86056: IFFALSE 86060
// exit ;
86058: GO 86085
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
86060: LD_ADDR_EXP 52
86064: PUSH
86065: LD_EXP 52
86069: PPUSH
86070: LD_VAR 0 1
86074: PPUSH
86075: LD_VAR 0 2
86079: PPUSH
86080: CALL_OW 1
86084: ST_TO_ADDR
// end ;
86085: LD_VAR 0 3
86089: RET
// export function MC_InsertProduceList ( base , components ) ; begin
86090: LD_INT 0
86092: PPUSH
// if not mc_bases [ base ] then
86093: LD_EXP 31
86097: PUSH
86098: LD_VAR 0 1
86102: ARRAY
86103: NOT
86104: IFFALSE 86108
// exit ;
86106: GO 86145
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
86108: LD_ADDR_EXP 52
86112: PUSH
86113: LD_EXP 52
86117: PPUSH
86118: LD_VAR 0 1
86122: PPUSH
86123: LD_EXP 52
86127: PUSH
86128: LD_VAR 0 1
86132: ARRAY
86133: PUSH
86134: LD_VAR 0 2
86138: ADD
86139: PPUSH
86140: CALL_OW 1
86144: ST_TO_ADDR
// end ;
86145: LD_VAR 0 3
86149: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
86150: LD_INT 0
86152: PPUSH
// if not mc_bases [ base ] then
86153: LD_EXP 31
86157: PUSH
86158: LD_VAR 0 1
86162: ARRAY
86163: NOT
86164: IFFALSE 86168
// exit ;
86166: GO 86222
// mc_defender := Replace ( mc_defender , base , deflist ) ;
86168: LD_ADDR_EXP 53
86172: PUSH
86173: LD_EXP 53
86177: PPUSH
86178: LD_VAR 0 1
86182: PPUSH
86183: LD_VAR 0 2
86187: PPUSH
86188: CALL_OW 1
86192: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
86193: LD_ADDR_EXP 42
86197: PUSH
86198: LD_EXP 42
86202: PPUSH
86203: LD_VAR 0 1
86207: PPUSH
86208: LD_VAR 0 2
86212: PUSH
86213: LD_INT 0
86215: PLUS
86216: PPUSH
86217: CALL_OW 1
86221: ST_TO_ADDR
// end ;
86222: LD_VAR 0 3
86226: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
86227: LD_INT 0
86229: PPUSH
// if not mc_bases [ base ] then
86230: LD_EXP 31
86234: PUSH
86235: LD_VAR 0 1
86239: ARRAY
86240: NOT
86241: IFFALSE 86245
// exit ;
86243: GO 86270
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
86245: LD_ADDR_EXP 42
86249: PUSH
86250: LD_EXP 42
86254: PPUSH
86255: LD_VAR 0 1
86259: PPUSH
86260: LD_VAR 0 2
86264: PPUSH
86265: CALL_OW 1
86269: ST_TO_ADDR
// end ;
86270: LD_VAR 0 3
86274: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
86275: LD_INT 0
86277: PPUSH
86278: PPUSH
86279: PPUSH
86280: PPUSH
// if not mc_bases [ base ] then
86281: LD_EXP 31
86285: PUSH
86286: LD_VAR 0 1
86290: ARRAY
86291: NOT
86292: IFFALSE 86296
// exit ;
86294: GO 86361
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
86296: LD_ADDR_EXP 51
86300: PUSH
86301: LD_EXP 51
86305: PPUSH
86306: LD_VAR 0 1
86310: PUSH
86311: LD_EXP 51
86315: PUSH
86316: LD_VAR 0 1
86320: ARRAY
86321: PUSH
86322: LD_INT 1
86324: PLUS
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: PPUSH
86330: LD_VAR 0 1
86334: PUSH
86335: LD_VAR 0 2
86339: PUSH
86340: LD_VAR 0 3
86344: PUSH
86345: LD_VAR 0 4
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: LIST
86354: LIST
86355: PPUSH
86356: CALL 24846 0 3
86360: ST_TO_ADDR
// end ;
86361: LD_VAR 0 5
86365: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
86366: LD_INT 0
86368: PPUSH
// if not mc_bases [ base ] then
86369: LD_EXP 31
86373: PUSH
86374: LD_VAR 0 1
86378: ARRAY
86379: NOT
86380: IFFALSE 86384
// exit ;
86382: GO 86409
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
86384: LD_ADDR_EXP 68
86388: PUSH
86389: LD_EXP 68
86393: PPUSH
86394: LD_VAR 0 1
86398: PPUSH
86399: LD_VAR 0 2
86403: PPUSH
86404: CALL_OW 1
86408: ST_TO_ADDR
// end ;
86409: LD_VAR 0 3
86413: RET
// export function MC_GetMinesField ( base ) ; begin
86414: LD_INT 0
86416: PPUSH
// result := mc_mines [ base ] ;
86417: LD_ADDR_VAR 0 2
86421: PUSH
86422: LD_EXP 44
86426: PUSH
86427: LD_VAR 0 1
86431: ARRAY
86432: ST_TO_ADDR
// end ;
86433: LD_VAR 0 2
86437: RET
// export function MC_GetProduceList ( base ) ; begin
86438: LD_INT 0
86440: PPUSH
// result := mc_produce [ base ] ;
86441: LD_ADDR_VAR 0 2
86445: PUSH
86446: LD_EXP 52
86450: PUSH
86451: LD_VAR 0 1
86455: ARRAY
86456: ST_TO_ADDR
// end ;
86457: LD_VAR 0 2
86461: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
86462: LD_INT 0
86464: PPUSH
86465: PPUSH
// if not mc_bases then
86466: LD_EXP 31
86470: NOT
86471: IFFALSE 86475
// exit ;
86473: GO 86540
// if mc_bases [ base ] then
86475: LD_EXP 31
86479: PUSH
86480: LD_VAR 0 1
86484: ARRAY
86485: IFFALSE 86540
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86487: LD_ADDR_VAR 0 3
86491: PUSH
86492: LD_EXP 31
86496: PUSH
86497: LD_VAR 0 1
86501: ARRAY
86502: PPUSH
86503: LD_INT 30
86505: PUSH
86506: LD_VAR 0 2
86510: PUSH
86511: EMPTY
86512: LIST
86513: LIST
86514: PPUSH
86515: CALL_OW 72
86519: ST_TO_ADDR
// if result then
86520: LD_VAR 0 3
86524: IFFALSE 86540
// result := result [ 1 ] ;
86526: LD_ADDR_VAR 0 3
86530: PUSH
86531: LD_VAR 0 3
86535: PUSH
86536: LD_INT 1
86538: ARRAY
86539: ST_TO_ADDR
// end ; end ;
86540: LD_VAR 0 3
86544: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
86545: LD_INT 0
86547: PPUSH
86548: PPUSH
// if not mc_bases then
86549: LD_EXP 31
86553: NOT
86554: IFFALSE 86558
// exit ;
86556: GO 86603
// if mc_bases [ base ] then
86558: LD_EXP 31
86562: PUSH
86563: LD_VAR 0 1
86567: ARRAY
86568: IFFALSE 86603
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86570: LD_ADDR_VAR 0 3
86574: PUSH
86575: LD_EXP 31
86579: PUSH
86580: LD_VAR 0 1
86584: ARRAY
86585: PPUSH
86586: LD_INT 30
86588: PUSH
86589: LD_VAR 0 2
86593: PUSH
86594: EMPTY
86595: LIST
86596: LIST
86597: PPUSH
86598: CALL_OW 72
86602: ST_TO_ADDR
// end ;
86603: LD_VAR 0 3
86607: RET
// export function MC_SetTame ( base , area ) ; begin
86608: LD_INT 0
86610: PPUSH
// if not mc_bases or not base then
86611: LD_EXP 31
86615: NOT
86616: PUSH
86617: LD_VAR 0 1
86621: NOT
86622: OR
86623: IFFALSE 86627
// exit ;
86625: GO 86652
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86627: LD_ADDR_EXP 59
86631: PUSH
86632: LD_EXP 59
86636: PPUSH
86637: LD_VAR 0 1
86641: PPUSH
86642: LD_VAR 0 2
86646: PPUSH
86647: CALL_OW 1
86651: ST_TO_ADDR
// end ;
86652: LD_VAR 0 3
86656: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86657: LD_INT 0
86659: PPUSH
86660: PPUSH
// if not mc_bases or not base then
86661: LD_EXP 31
86665: NOT
86666: PUSH
86667: LD_VAR 0 1
86671: NOT
86672: OR
86673: IFFALSE 86677
// exit ;
86675: GO 86779
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86677: LD_ADDR_VAR 0 4
86681: PUSH
86682: LD_EXP 31
86686: PUSH
86687: LD_VAR 0 1
86691: ARRAY
86692: PPUSH
86693: LD_INT 30
86695: PUSH
86696: LD_VAR 0 2
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PPUSH
86705: CALL_OW 72
86709: ST_TO_ADDR
// if not tmp then
86710: LD_VAR 0 4
86714: NOT
86715: IFFALSE 86719
// exit ;
86717: GO 86779
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86719: LD_ADDR_EXP 63
86723: PUSH
86724: LD_EXP 63
86728: PPUSH
86729: LD_VAR 0 1
86733: PPUSH
86734: LD_EXP 63
86738: PUSH
86739: LD_VAR 0 1
86743: ARRAY
86744: PPUSH
86745: LD_EXP 63
86749: PUSH
86750: LD_VAR 0 1
86754: ARRAY
86755: PUSH
86756: LD_INT 1
86758: PLUS
86759: PPUSH
86760: LD_VAR 0 4
86764: PUSH
86765: LD_INT 1
86767: ARRAY
86768: PPUSH
86769: CALL_OW 2
86773: PPUSH
86774: CALL_OW 1
86778: ST_TO_ADDR
// end ;
86779: LD_VAR 0 3
86783: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86784: LD_INT 0
86786: PPUSH
86787: PPUSH
// if not mc_bases or not base or not kinds then
86788: LD_EXP 31
86792: NOT
86793: PUSH
86794: LD_VAR 0 1
86798: NOT
86799: OR
86800: PUSH
86801: LD_VAR 0 2
86805: NOT
86806: OR
86807: IFFALSE 86811
// exit ;
86809: GO 86872
// for i in kinds do
86811: LD_ADDR_VAR 0 4
86815: PUSH
86816: LD_VAR 0 2
86820: PUSH
86821: FOR_IN
86822: IFFALSE 86870
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86824: LD_ADDR_EXP 65
86828: PUSH
86829: LD_EXP 65
86833: PPUSH
86834: LD_VAR 0 1
86838: PUSH
86839: LD_EXP 65
86843: PUSH
86844: LD_VAR 0 1
86848: ARRAY
86849: PUSH
86850: LD_INT 1
86852: PLUS
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PPUSH
86858: LD_VAR 0 4
86862: PPUSH
86863: CALL 24846 0 3
86867: ST_TO_ADDR
86868: GO 86821
86870: POP
86871: POP
// end ;
86872: LD_VAR 0 3
86876: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86877: LD_INT 0
86879: PPUSH
// if not mc_bases or not base or not areas then
86880: LD_EXP 31
86884: NOT
86885: PUSH
86886: LD_VAR 0 1
86890: NOT
86891: OR
86892: PUSH
86893: LD_VAR 0 2
86897: NOT
86898: OR
86899: IFFALSE 86903
// exit ;
86901: GO 86928
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86903: LD_ADDR_EXP 49
86907: PUSH
86908: LD_EXP 49
86912: PPUSH
86913: LD_VAR 0 1
86917: PPUSH
86918: LD_VAR 0 2
86922: PPUSH
86923: CALL_OW 1
86927: ST_TO_ADDR
// end ;
86928: LD_VAR 0 3
86932: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86933: LD_INT 0
86935: PPUSH
// if not mc_bases or not base or not teleports_exit then
86936: LD_EXP 31
86940: NOT
86941: PUSH
86942: LD_VAR 0 1
86946: NOT
86947: OR
86948: PUSH
86949: LD_VAR 0 2
86953: NOT
86954: OR
86955: IFFALSE 86959
// exit ;
86957: GO 86984
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86959: LD_ADDR_EXP 66
86963: PUSH
86964: LD_EXP 66
86968: PPUSH
86969: LD_VAR 0 1
86973: PPUSH
86974: LD_VAR 0 2
86978: PPUSH
86979: CALL_OW 1
86983: ST_TO_ADDR
// end ;
86984: LD_VAR 0 3
86988: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86989: LD_INT 0
86991: PPUSH
86992: PPUSH
86993: PPUSH
// if not mc_bases or not base or not ext_list then
86994: LD_EXP 31
86998: NOT
86999: PUSH
87000: LD_VAR 0 1
87004: NOT
87005: OR
87006: PUSH
87007: LD_VAR 0 5
87011: NOT
87012: OR
87013: IFFALSE 87017
// exit ;
87015: GO 87190
// tmp := GetFacExtXYD ( x , y , d ) ;
87017: LD_ADDR_VAR 0 8
87021: PUSH
87022: LD_VAR 0 2
87026: PPUSH
87027: LD_VAR 0 3
87031: PPUSH
87032: LD_VAR 0 4
87036: PPUSH
87037: CALL 55220 0 3
87041: ST_TO_ADDR
// if not tmp then
87042: LD_VAR 0 8
87046: NOT
87047: IFFALSE 87051
// exit ;
87049: GO 87190
// for i in tmp do
87051: LD_ADDR_VAR 0 7
87055: PUSH
87056: LD_VAR 0 8
87060: PUSH
87061: FOR_IN
87062: IFFALSE 87188
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
87064: LD_ADDR_EXP 36
87068: PUSH
87069: LD_EXP 36
87073: PPUSH
87074: LD_VAR 0 1
87078: PPUSH
87079: LD_EXP 36
87083: PUSH
87084: LD_VAR 0 1
87088: ARRAY
87089: PPUSH
87090: LD_EXP 36
87094: PUSH
87095: LD_VAR 0 1
87099: ARRAY
87100: PUSH
87101: LD_INT 1
87103: PLUS
87104: PPUSH
87105: LD_VAR 0 5
87109: PUSH
87110: LD_INT 1
87112: ARRAY
87113: PUSH
87114: LD_VAR 0 7
87118: PUSH
87119: LD_INT 1
87121: ARRAY
87122: PUSH
87123: LD_VAR 0 7
87127: PUSH
87128: LD_INT 2
87130: ARRAY
87131: PUSH
87132: LD_VAR 0 7
87136: PUSH
87137: LD_INT 3
87139: ARRAY
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: PPUSH
87147: CALL_OW 2
87151: PPUSH
87152: CALL_OW 1
87156: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
87157: LD_ADDR_VAR 0 5
87161: PUSH
87162: LD_VAR 0 5
87166: PPUSH
87167: LD_INT 1
87169: PPUSH
87170: CALL_OW 3
87174: ST_TO_ADDR
// if not ext_list then
87175: LD_VAR 0 5
87179: NOT
87180: IFFALSE 87186
// exit ;
87182: POP
87183: POP
87184: GO 87190
// end ;
87186: GO 87061
87188: POP
87189: POP
// end ;
87190: LD_VAR 0 6
87194: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
87195: LD_INT 0
87197: PPUSH
// if not mc_bases or not base or not weapon_list then
87198: LD_EXP 31
87202: NOT
87203: PUSH
87204: LD_VAR 0 1
87208: NOT
87209: OR
87210: PUSH
87211: LD_VAR 0 2
87215: NOT
87216: OR
87217: IFFALSE 87221
// exit ;
87219: GO 87246
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
87221: LD_ADDR_EXP 70
87225: PUSH
87226: LD_EXP 70
87230: PPUSH
87231: LD_VAR 0 1
87235: PPUSH
87236: LD_VAR 0 2
87240: PPUSH
87241: CALL_OW 1
87245: ST_TO_ADDR
// end ;
87246: LD_VAR 0 3
87250: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
87251: LD_INT 0
87253: PPUSH
// if not mc_bases or not base or not tech_list then
87254: LD_EXP 31
87258: NOT
87259: PUSH
87260: LD_VAR 0 1
87264: NOT
87265: OR
87266: PUSH
87267: LD_VAR 0 2
87271: NOT
87272: OR
87273: IFFALSE 87277
// exit ;
87275: GO 87302
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
87277: LD_ADDR_EXP 58
87281: PUSH
87282: LD_EXP 58
87286: PPUSH
87287: LD_VAR 0 1
87291: PPUSH
87292: LD_VAR 0 2
87296: PPUSH
87297: CALL_OW 1
87301: ST_TO_ADDR
// end ;
87302: LD_VAR 0 3
87306: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
87307: LD_INT 0
87309: PPUSH
// if not mc_bases or not parking_area or not base then
87310: LD_EXP 31
87314: NOT
87315: PUSH
87316: LD_VAR 0 2
87320: NOT
87321: OR
87322: PUSH
87323: LD_VAR 0 1
87327: NOT
87328: OR
87329: IFFALSE 87333
// exit ;
87331: GO 87358
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
87333: LD_ADDR_EXP 55
87337: PUSH
87338: LD_EXP 55
87342: PPUSH
87343: LD_VAR 0 1
87347: PPUSH
87348: LD_VAR 0 2
87352: PPUSH
87353: CALL_OW 1
87357: ST_TO_ADDR
// end ;
87358: LD_VAR 0 3
87362: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
87363: LD_INT 0
87365: PPUSH
// if not mc_bases or not base or not scan_area then
87366: LD_EXP 31
87370: NOT
87371: PUSH
87372: LD_VAR 0 1
87376: NOT
87377: OR
87378: PUSH
87379: LD_VAR 0 2
87383: NOT
87384: OR
87385: IFFALSE 87389
// exit ;
87387: GO 87414
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
87389: LD_ADDR_EXP 56
87393: PUSH
87394: LD_EXP 56
87398: PPUSH
87399: LD_VAR 0 1
87403: PPUSH
87404: LD_VAR 0 2
87408: PPUSH
87409: CALL_OW 1
87413: ST_TO_ADDR
// end ;
87414: LD_VAR 0 3
87418: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
87419: LD_INT 0
87421: PPUSH
87422: PPUSH
// if not mc_bases or not base then
87423: LD_EXP 31
87427: NOT
87428: PUSH
87429: LD_VAR 0 1
87433: NOT
87434: OR
87435: IFFALSE 87439
// exit ;
87437: GO 87503
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
87439: LD_ADDR_VAR 0 3
87443: PUSH
87444: LD_INT 1
87446: PUSH
87447: LD_INT 2
87449: PUSH
87450: LD_INT 3
87452: PUSH
87453: LD_INT 4
87455: PUSH
87456: LD_INT 11
87458: PUSH
87459: EMPTY
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
87466: LD_ADDR_EXP 58
87470: PUSH
87471: LD_EXP 58
87475: PPUSH
87476: LD_VAR 0 1
87480: PPUSH
87481: LD_EXP 58
87485: PUSH
87486: LD_VAR 0 1
87490: ARRAY
87491: PUSH
87492: LD_VAR 0 3
87496: DIFF
87497: PPUSH
87498: CALL_OW 1
87502: ST_TO_ADDR
// end ;
87503: LD_VAR 0 2
87507: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
87508: LD_INT 0
87510: PPUSH
// result := mc_vehicles [ base ] ;
87511: LD_ADDR_VAR 0 3
87515: PUSH
87516: LD_EXP 50
87520: PUSH
87521: LD_VAR 0 1
87525: ARRAY
87526: ST_TO_ADDR
// if onlyCombat then
87527: LD_VAR 0 2
87531: IFFALSE 87703
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
87533: LD_ADDR_VAR 0 3
87537: PUSH
87538: LD_VAR 0 3
87542: PUSH
87543: LD_VAR 0 3
87547: PPUSH
87548: LD_INT 2
87550: PUSH
87551: LD_INT 34
87553: PUSH
87554: LD_INT 12
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 34
87563: PUSH
87564: LD_INT 51
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: PUSH
87571: LD_INT 34
87573: PUSH
87574: LD_INT 89
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: PUSH
87581: LD_INT 34
87583: PUSH
87584: LD_INT 32
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 34
87593: PUSH
87594: LD_INT 13
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 34
87603: PUSH
87604: LD_INT 52
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 34
87613: PUSH
87614: LD_INT 88
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 34
87623: PUSH
87624: LD_INT 14
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 34
87633: PUSH
87634: LD_INT 53
87636: PUSH
87637: EMPTY
87638: LIST
87639: LIST
87640: PUSH
87641: LD_INT 34
87643: PUSH
87644: LD_INT 98
87646: PUSH
87647: EMPTY
87648: LIST
87649: LIST
87650: PUSH
87651: LD_INT 34
87653: PUSH
87654: LD_INT 31
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: PUSH
87661: LD_INT 34
87663: PUSH
87664: LD_INT 48
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: LD_INT 34
87673: PUSH
87674: LD_INT 8
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: PPUSH
87697: CALL_OW 72
87701: DIFF
87702: ST_TO_ADDR
// end ; end_of_file
87703: LD_VAR 0 3
87707: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87708: LD_INT 0
87710: PPUSH
87711: PPUSH
87712: PPUSH
// if not mc_bases or not skirmish then
87713: LD_EXP 31
87717: NOT
87718: PUSH
87719: LD_EXP 29
87723: NOT
87724: OR
87725: IFFALSE 87729
// exit ;
87727: GO 87894
// for i = 1 to mc_bases do
87729: LD_ADDR_VAR 0 4
87733: PUSH
87734: DOUBLE
87735: LD_INT 1
87737: DEC
87738: ST_TO_ADDR
87739: LD_EXP 31
87743: PUSH
87744: FOR_TO
87745: IFFALSE 87892
// begin if sci in mc_bases [ i ] then
87747: LD_VAR 0 2
87751: PUSH
87752: LD_EXP 31
87756: PUSH
87757: LD_VAR 0 4
87761: ARRAY
87762: IN
87763: IFFALSE 87890
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87765: LD_ADDR_EXP 60
87769: PUSH
87770: LD_EXP 60
87774: PPUSH
87775: LD_VAR 0 4
87779: PUSH
87780: LD_EXP 60
87784: PUSH
87785: LD_VAR 0 4
87789: ARRAY
87790: PUSH
87791: LD_INT 1
87793: PLUS
87794: PUSH
87795: EMPTY
87796: LIST
87797: LIST
87798: PPUSH
87799: LD_VAR 0 1
87803: PPUSH
87804: CALL 24846 0 3
87808: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87809: LD_ADDR_VAR 0 5
87813: PUSH
87814: LD_EXP 31
87818: PUSH
87819: LD_VAR 0 4
87823: ARRAY
87824: PPUSH
87825: LD_INT 2
87827: PUSH
87828: LD_INT 30
87830: PUSH
87831: LD_INT 0
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: PUSH
87838: LD_INT 30
87840: PUSH
87841: LD_INT 1
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: LIST
87852: PPUSH
87853: CALL_OW 72
87857: PPUSH
87858: LD_VAR 0 1
87862: PPUSH
87863: CALL_OW 74
87867: ST_TO_ADDR
// if tmp then
87868: LD_VAR 0 5
87872: IFFALSE 87888
// ComStandNearbyBuilding ( ape , tmp ) ;
87874: LD_VAR 0 1
87878: PPUSH
87879: LD_VAR 0 5
87883: PPUSH
87884: CALL 21448 0 2
// break ;
87888: GO 87892
// end ; end ;
87890: GO 87744
87892: POP
87893: POP
// end ;
87894: LD_VAR 0 3
87898: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87899: LD_INT 0
87901: PPUSH
87902: PPUSH
87903: PPUSH
// if not mc_bases or not skirmish then
87904: LD_EXP 31
87908: NOT
87909: PUSH
87910: LD_EXP 29
87914: NOT
87915: OR
87916: IFFALSE 87920
// exit ;
87918: GO 88009
// for i = 1 to mc_bases do
87920: LD_ADDR_VAR 0 4
87924: PUSH
87925: DOUBLE
87926: LD_INT 1
87928: DEC
87929: ST_TO_ADDR
87930: LD_EXP 31
87934: PUSH
87935: FOR_TO
87936: IFFALSE 88007
// begin if building in mc_busy_turret_list [ i ] then
87938: LD_VAR 0 1
87942: PUSH
87943: LD_EXP 41
87947: PUSH
87948: LD_VAR 0 4
87952: ARRAY
87953: IN
87954: IFFALSE 88005
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87956: LD_ADDR_VAR 0 5
87960: PUSH
87961: LD_EXP 41
87965: PUSH
87966: LD_VAR 0 4
87970: ARRAY
87971: PUSH
87972: LD_VAR 0 1
87976: DIFF
87977: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87978: LD_ADDR_EXP 41
87982: PUSH
87983: LD_EXP 41
87987: PPUSH
87988: LD_VAR 0 4
87992: PPUSH
87993: LD_VAR 0 5
87997: PPUSH
87998: CALL_OW 1
88002: ST_TO_ADDR
// break ;
88003: GO 88007
// end ; end ;
88005: GO 87935
88007: POP
88008: POP
// end ;
88009: LD_VAR 0 3
88013: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
88014: LD_INT 0
88016: PPUSH
88017: PPUSH
88018: PPUSH
// if not mc_bases or not skirmish then
88019: LD_EXP 31
88023: NOT
88024: PUSH
88025: LD_EXP 29
88029: NOT
88030: OR
88031: IFFALSE 88035
// exit ;
88033: GO 88234
// for i = 1 to mc_bases do
88035: LD_ADDR_VAR 0 5
88039: PUSH
88040: DOUBLE
88041: LD_INT 1
88043: DEC
88044: ST_TO_ADDR
88045: LD_EXP 31
88049: PUSH
88050: FOR_TO
88051: IFFALSE 88232
// if building in mc_bases [ i ] then
88053: LD_VAR 0 1
88057: PUSH
88058: LD_EXP 31
88062: PUSH
88063: LD_VAR 0 5
88067: ARRAY
88068: IN
88069: IFFALSE 88230
// begin tmp := mc_bases [ i ] diff building ;
88071: LD_ADDR_VAR 0 6
88075: PUSH
88076: LD_EXP 31
88080: PUSH
88081: LD_VAR 0 5
88085: ARRAY
88086: PUSH
88087: LD_VAR 0 1
88091: DIFF
88092: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
88093: LD_ADDR_EXP 31
88097: PUSH
88098: LD_EXP 31
88102: PPUSH
88103: LD_VAR 0 5
88107: PPUSH
88108: LD_VAR 0 6
88112: PPUSH
88113: CALL_OW 1
88117: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
88118: LD_VAR 0 1
88122: PUSH
88123: LD_EXP 39
88127: PUSH
88128: LD_VAR 0 5
88132: ARRAY
88133: IN
88134: IFFALSE 88173
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
88136: LD_ADDR_EXP 39
88140: PUSH
88141: LD_EXP 39
88145: PPUSH
88146: LD_VAR 0 5
88150: PPUSH
88151: LD_EXP 39
88155: PUSH
88156: LD_VAR 0 5
88160: ARRAY
88161: PUSH
88162: LD_VAR 0 1
88166: DIFF
88167: PPUSH
88168: CALL_OW 1
88172: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
88173: LD_VAR 0 1
88177: PUSH
88178: LD_EXP 40
88182: PUSH
88183: LD_VAR 0 5
88187: ARRAY
88188: IN
88189: IFFALSE 88228
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
88191: LD_ADDR_EXP 40
88195: PUSH
88196: LD_EXP 40
88200: PPUSH
88201: LD_VAR 0 5
88205: PPUSH
88206: LD_EXP 40
88210: PUSH
88211: LD_VAR 0 5
88215: ARRAY
88216: PUSH
88217: LD_VAR 0 1
88221: DIFF
88222: PPUSH
88223: CALL_OW 1
88227: ST_TO_ADDR
// break ;
88228: GO 88232
// end ;
88230: GO 88050
88232: POP
88233: POP
// end ;
88234: LD_VAR 0 4
88238: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
88239: LD_INT 0
88241: PPUSH
88242: PPUSH
88243: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
88244: LD_EXP 31
88248: NOT
88249: PUSH
88250: LD_EXP 29
88254: NOT
88255: OR
88256: PUSH
88257: LD_VAR 0 3
88261: PUSH
88262: LD_EXP 57
88266: IN
88267: NOT
88268: OR
88269: IFFALSE 88273
// exit ;
88271: GO 88396
// for i = 1 to mc_vehicles do
88273: LD_ADDR_VAR 0 6
88277: PUSH
88278: DOUBLE
88279: LD_INT 1
88281: DEC
88282: ST_TO_ADDR
88283: LD_EXP 50
88287: PUSH
88288: FOR_TO
88289: IFFALSE 88394
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
88291: LD_VAR 0 2
88295: PUSH
88296: LD_EXP 50
88300: PUSH
88301: LD_VAR 0 6
88305: ARRAY
88306: IN
88307: PUSH
88308: LD_VAR 0 1
88312: PUSH
88313: LD_EXP 50
88317: PUSH
88318: LD_VAR 0 6
88322: ARRAY
88323: IN
88324: OR
88325: IFFALSE 88392
// begin tmp := mc_vehicles [ i ] diff old ;
88327: LD_ADDR_VAR 0 7
88331: PUSH
88332: LD_EXP 50
88336: PUSH
88337: LD_VAR 0 6
88341: ARRAY
88342: PUSH
88343: LD_VAR 0 2
88347: DIFF
88348: ST_TO_ADDR
// tmp := tmp diff new ;
88349: LD_ADDR_VAR 0 7
88353: PUSH
88354: LD_VAR 0 7
88358: PUSH
88359: LD_VAR 0 1
88363: DIFF
88364: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
88365: LD_ADDR_EXP 50
88369: PUSH
88370: LD_EXP 50
88374: PPUSH
88375: LD_VAR 0 6
88379: PPUSH
88380: LD_VAR 0 7
88384: PPUSH
88385: CALL_OW 1
88389: ST_TO_ADDR
// break ;
88390: GO 88394
// end ;
88392: GO 88288
88394: POP
88395: POP
// end ;
88396: LD_VAR 0 5
88400: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
88401: LD_INT 0
88403: PPUSH
88404: PPUSH
88405: PPUSH
88406: PPUSH
// if not mc_bases or not skirmish then
88407: LD_EXP 31
88411: NOT
88412: PUSH
88413: LD_EXP 29
88417: NOT
88418: OR
88419: IFFALSE 88423
// exit ;
88421: GO 88843
// repeat wait ( 0 0$1 ) ;
88423: LD_INT 35
88425: PPUSH
88426: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
88430: LD_EXP 75
88434: NOT
88435: IFFALSE 88423
// mc_block_vehicle_constructed_thread := true ;
88437: LD_ADDR_EXP 75
88441: PUSH
88442: LD_INT 1
88444: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
88445: LD_ADDR_VAR 0 5
88449: PUSH
88450: LD_VAR 0 1
88454: PPUSH
88455: CALL_OW 255
88459: ST_TO_ADDR
// for i = 1 to mc_bases do
88460: LD_ADDR_VAR 0 4
88464: PUSH
88465: DOUBLE
88466: LD_INT 1
88468: DEC
88469: ST_TO_ADDR
88470: LD_EXP 31
88474: PUSH
88475: FOR_TO
88476: IFFALSE 88833
// begin if factory in mc_bases [ i ] then
88478: LD_VAR 0 2
88482: PUSH
88483: LD_EXP 31
88487: PUSH
88488: LD_VAR 0 4
88492: ARRAY
88493: IN
88494: IFFALSE 88831
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
88496: LD_EXP 53
88500: PUSH
88501: LD_VAR 0 4
88505: ARRAY
88506: PUSH
88507: LD_EXP 42
88511: PUSH
88512: LD_VAR 0 4
88516: ARRAY
88517: LESS
88518: PUSH
88519: LD_VAR 0 1
88523: PPUSH
88524: CALL_OW 264
88528: PUSH
88529: LD_INT 31
88531: PUSH
88532: LD_INT 32
88534: PUSH
88535: LD_INT 51
88537: PUSH
88538: LD_INT 89
88540: PUSH
88541: LD_INT 12
88543: PUSH
88544: LD_INT 30
88546: PUSH
88547: LD_INT 98
88549: PUSH
88550: LD_INT 11
88552: PUSH
88553: LD_INT 53
88555: PUSH
88556: LD_INT 14
88558: PUSH
88559: LD_INT 91
88561: PUSH
88562: LD_INT 29
88564: PUSH
88565: LD_INT 99
88567: PUSH
88568: LD_INT 13
88570: PUSH
88571: LD_INT 52
88573: PUSH
88574: LD_INT 88
88576: PUSH
88577: LD_INT 48
88579: PUSH
88580: LD_INT 8
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: IN
88603: NOT
88604: AND
88605: IFFALSE 88653
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88607: LD_ADDR_EXP 53
88611: PUSH
88612: LD_EXP 53
88616: PPUSH
88617: LD_VAR 0 4
88621: PUSH
88622: LD_EXP 53
88626: PUSH
88627: LD_VAR 0 4
88631: ARRAY
88632: PUSH
88633: LD_INT 1
88635: PLUS
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PPUSH
88641: LD_VAR 0 1
88645: PPUSH
88646: CALL 24846 0 3
88650: ST_TO_ADDR
88651: GO 88697
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88653: LD_ADDR_EXP 50
88657: PUSH
88658: LD_EXP 50
88662: PPUSH
88663: LD_VAR 0 4
88667: PUSH
88668: LD_EXP 50
88672: PUSH
88673: LD_VAR 0 4
88677: ARRAY
88678: PUSH
88679: LD_INT 1
88681: PLUS
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PPUSH
88687: LD_VAR 0 1
88691: PPUSH
88692: CALL 24846 0 3
88696: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
88697: LD_ADDR_EXP 75
88701: PUSH
88702: LD_INT 0
88704: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88705: LD_VAR 0 1
88709: PPUSH
88710: CALL_OW 263
88714: PUSH
88715: LD_INT 2
88717: EQUAL
88718: IFFALSE 88747
// begin repeat wait ( 0 0$3 ) ;
88720: LD_INT 105
88722: PPUSH
88723: CALL_OW 67
// Connect ( vehicle ) ;
88727: LD_VAR 0 1
88731: PPUSH
88732: CALL 28192 0 1
// until IsControledBy ( vehicle ) ;
88736: LD_VAR 0 1
88740: PPUSH
88741: CALL_OW 312
88745: IFFALSE 88720
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88747: LD_VAR 0 1
88751: PPUSH
88752: LD_EXP 55
88756: PUSH
88757: LD_VAR 0 4
88761: ARRAY
88762: PPUSH
88763: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88767: LD_VAR 0 1
88771: PPUSH
88772: CALL_OW 263
88776: PUSH
88777: LD_INT 1
88779: NONEQUAL
88780: IFFALSE 88784
// break ;
88782: GO 88833
// repeat wait ( 0 0$1 ) ;
88784: LD_INT 35
88786: PPUSH
88787: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88791: LD_VAR 0 1
88795: PPUSH
88796: LD_EXP 55
88800: PUSH
88801: LD_VAR 0 4
88805: ARRAY
88806: PPUSH
88807: CALL_OW 308
88811: IFFALSE 88784
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88813: LD_VAR 0 1
88817: PPUSH
88818: CALL_OW 311
88822: PPUSH
88823: CALL_OW 121
// exit ;
88827: POP
88828: POP
88829: GO 88843
// end ; end ;
88831: GO 88475
88833: POP
88834: POP
// mc_block_vehicle_constructed_thread := false ;
88835: LD_ADDR_EXP 75
88839: PUSH
88840: LD_INT 0
88842: ST_TO_ADDR
// end ;
88843: LD_VAR 0 3
88847: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88848: LD_INT 0
88850: PPUSH
88851: PPUSH
88852: PPUSH
88853: PPUSH
// if not mc_bases or not skirmish then
88854: LD_EXP 31
88858: NOT
88859: PUSH
88860: LD_EXP 29
88864: NOT
88865: OR
88866: IFFALSE 88870
// exit ;
88868: GO 89223
// repeat wait ( 0 0$1 ) ;
88870: LD_INT 35
88872: PPUSH
88873: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88877: LD_VAR 0 2
88881: PPUSH
88882: LD_VAR 0 3
88886: PPUSH
88887: CALL_OW 284
88891: IFFALSE 88870
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88893: LD_VAR 0 2
88897: PPUSH
88898: LD_VAR 0 3
88902: PPUSH
88903: CALL_OW 283
88907: PUSH
88908: LD_INT 4
88910: EQUAL
88911: IFFALSE 88915
// exit ;
88913: GO 89223
// for i = 1 to mc_bases do
88915: LD_ADDR_VAR 0 7
88919: PUSH
88920: DOUBLE
88921: LD_INT 1
88923: DEC
88924: ST_TO_ADDR
88925: LD_EXP 31
88929: PUSH
88930: FOR_TO
88931: IFFALSE 89221
// begin if mc_crates_area [ i ] then
88933: LD_EXP 49
88937: PUSH
88938: LD_VAR 0 7
88942: ARRAY
88943: IFFALSE 89054
// for j in mc_crates_area [ i ] do
88945: LD_ADDR_VAR 0 8
88949: PUSH
88950: LD_EXP 49
88954: PUSH
88955: LD_VAR 0 7
88959: ARRAY
88960: PUSH
88961: FOR_IN
88962: IFFALSE 89052
// if InArea ( x , y , j ) then
88964: LD_VAR 0 2
88968: PPUSH
88969: LD_VAR 0 3
88973: PPUSH
88974: LD_VAR 0 8
88978: PPUSH
88979: CALL_OW 309
88983: IFFALSE 89050
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88985: LD_ADDR_EXP 47
88989: PUSH
88990: LD_EXP 47
88994: PPUSH
88995: LD_VAR 0 7
88999: PUSH
89000: LD_EXP 47
89004: PUSH
89005: LD_VAR 0 7
89009: ARRAY
89010: PUSH
89011: LD_INT 1
89013: PLUS
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PPUSH
89019: LD_VAR 0 4
89023: PUSH
89024: LD_VAR 0 2
89028: PUSH
89029: LD_VAR 0 3
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: LIST
89038: PPUSH
89039: CALL 24846 0 3
89043: ST_TO_ADDR
// exit ;
89044: POP
89045: POP
89046: POP
89047: POP
89048: GO 89223
// end ;
89050: GO 88961
89052: POP
89053: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89054: LD_ADDR_VAR 0 9
89058: PUSH
89059: LD_EXP 31
89063: PUSH
89064: LD_VAR 0 7
89068: ARRAY
89069: PPUSH
89070: LD_INT 2
89072: PUSH
89073: LD_INT 30
89075: PUSH
89076: LD_INT 0
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: PUSH
89083: LD_INT 30
89085: PUSH
89086: LD_INT 1
89088: PUSH
89089: EMPTY
89090: LIST
89091: LIST
89092: PUSH
89093: EMPTY
89094: LIST
89095: LIST
89096: LIST
89097: PPUSH
89098: CALL_OW 72
89102: ST_TO_ADDR
// if not depot then
89103: LD_VAR 0 9
89107: NOT
89108: IFFALSE 89112
// continue ;
89110: GO 88930
// for j in depot do
89112: LD_ADDR_VAR 0 8
89116: PUSH
89117: LD_VAR 0 9
89121: PUSH
89122: FOR_IN
89123: IFFALSE 89217
// if GetDistUnitXY ( j , x , y ) < 30 then
89125: LD_VAR 0 8
89129: PPUSH
89130: LD_VAR 0 2
89134: PPUSH
89135: LD_VAR 0 3
89139: PPUSH
89140: CALL_OW 297
89144: PUSH
89145: LD_INT 30
89147: LESS
89148: IFFALSE 89215
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
89150: LD_ADDR_EXP 47
89154: PUSH
89155: LD_EXP 47
89159: PPUSH
89160: LD_VAR 0 7
89164: PUSH
89165: LD_EXP 47
89169: PUSH
89170: LD_VAR 0 7
89174: ARRAY
89175: PUSH
89176: LD_INT 1
89178: PLUS
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: PPUSH
89184: LD_VAR 0 4
89188: PUSH
89189: LD_VAR 0 2
89193: PUSH
89194: LD_VAR 0 3
89198: PUSH
89199: EMPTY
89200: LIST
89201: LIST
89202: LIST
89203: PPUSH
89204: CALL 24846 0 3
89208: ST_TO_ADDR
// exit ;
89209: POP
89210: POP
89211: POP
89212: POP
89213: GO 89223
// end ;
89215: GO 89122
89217: POP
89218: POP
// end ;
89219: GO 88930
89221: POP
89222: POP
// end ;
89223: LD_VAR 0 6
89227: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
89228: LD_INT 0
89230: PPUSH
89231: PPUSH
89232: PPUSH
89233: PPUSH
// if not mc_bases or not skirmish then
89234: LD_EXP 31
89238: NOT
89239: PUSH
89240: LD_EXP 29
89244: NOT
89245: OR
89246: IFFALSE 89250
// exit ;
89248: GO 89527
// side := GetSide ( lab ) ;
89250: LD_ADDR_VAR 0 4
89254: PUSH
89255: LD_VAR 0 2
89259: PPUSH
89260: CALL_OW 255
89264: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
89265: LD_VAR 0 4
89269: PUSH
89270: LD_EXP 57
89274: IN
89275: NOT
89276: PUSH
89277: LD_EXP 58
89281: NOT
89282: OR
89283: PUSH
89284: LD_EXP 31
89288: NOT
89289: OR
89290: IFFALSE 89294
// exit ;
89292: GO 89527
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
89294: LD_ADDR_EXP 58
89298: PUSH
89299: LD_EXP 58
89303: PPUSH
89304: LD_VAR 0 4
89308: PPUSH
89309: LD_EXP 58
89313: PUSH
89314: LD_VAR 0 4
89318: ARRAY
89319: PUSH
89320: LD_VAR 0 1
89324: DIFF
89325: PPUSH
89326: CALL_OW 1
89330: ST_TO_ADDR
// for i = 1 to mc_bases do
89331: LD_ADDR_VAR 0 5
89335: PUSH
89336: DOUBLE
89337: LD_INT 1
89339: DEC
89340: ST_TO_ADDR
89341: LD_EXP 31
89345: PUSH
89346: FOR_TO
89347: IFFALSE 89525
// begin if lab in mc_bases [ i ] then
89349: LD_VAR 0 2
89353: PUSH
89354: LD_EXP 31
89358: PUSH
89359: LD_VAR 0 5
89363: ARRAY
89364: IN
89365: IFFALSE 89523
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
89367: LD_VAR 0 1
89371: PUSH
89372: LD_INT 11
89374: PUSH
89375: LD_INT 4
89377: PUSH
89378: LD_INT 3
89380: PUSH
89381: LD_INT 2
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: IN
89390: PUSH
89391: LD_EXP 61
89395: PUSH
89396: LD_VAR 0 5
89400: ARRAY
89401: AND
89402: IFFALSE 89523
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
89404: LD_ADDR_VAR 0 6
89408: PUSH
89409: LD_EXP 61
89413: PUSH
89414: LD_VAR 0 5
89418: ARRAY
89419: PUSH
89420: LD_INT 1
89422: ARRAY
89423: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89424: LD_ADDR_EXP 61
89428: PUSH
89429: LD_EXP 61
89433: PPUSH
89434: LD_VAR 0 5
89438: PPUSH
89439: EMPTY
89440: PPUSH
89441: CALL_OW 1
89445: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
89446: LD_VAR 0 6
89450: PPUSH
89451: LD_INT 0
89453: PPUSH
89454: CALL_OW 109
// ComExitBuilding ( tmp ) ;
89458: LD_VAR 0 6
89462: PPUSH
89463: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
89467: LD_ADDR_EXP 60
89471: PUSH
89472: LD_EXP 60
89476: PPUSH
89477: LD_VAR 0 5
89481: PPUSH
89482: LD_EXP 60
89486: PUSH
89487: LD_VAR 0 5
89491: ARRAY
89492: PPUSH
89493: LD_INT 1
89495: PPUSH
89496: LD_VAR 0 6
89500: PPUSH
89501: CALL_OW 2
89505: PPUSH
89506: CALL_OW 1
89510: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
89511: LD_VAR 0 5
89515: PPUSH
89516: LD_INT 112
89518: PPUSH
89519: CALL 65977 0 2
// end ; end ; end ;
89523: GO 89346
89525: POP
89526: POP
// end ;
89527: LD_VAR 0 3
89531: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
89532: LD_INT 0
89534: PPUSH
89535: PPUSH
89536: PPUSH
89537: PPUSH
89538: PPUSH
89539: PPUSH
89540: PPUSH
89541: PPUSH
// if not mc_bases or not skirmish then
89542: LD_EXP 31
89546: NOT
89547: PUSH
89548: LD_EXP 29
89552: NOT
89553: OR
89554: IFFALSE 89558
// exit ;
89556: GO 90927
// for i = 1 to mc_bases do
89558: LD_ADDR_VAR 0 3
89562: PUSH
89563: DOUBLE
89564: LD_INT 1
89566: DEC
89567: ST_TO_ADDR
89568: LD_EXP 31
89572: PUSH
89573: FOR_TO
89574: IFFALSE 90925
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
89576: LD_VAR 0 1
89580: PUSH
89581: LD_EXP 31
89585: PUSH
89586: LD_VAR 0 3
89590: ARRAY
89591: IN
89592: PUSH
89593: LD_VAR 0 1
89597: PUSH
89598: LD_EXP 38
89602: PUSH
89603: LD_VAR 0 3
89607: ARRAY
89608: IN
89609: OR
89610: PUSH
89611: LD_VAR 0 1
89615: PUSH
89616: LD_EXP 53
89620: PUSH
89621: LD_VAR 0 3
89625: ARRAY
89626: IN
89627: OR
89628: PUSH
89629: LD_VAR 0 1
89633: PUSH
89634: LD_EXP 50
89638: PUSH
89639: LD_VAR 0 3
89643: ARRAY
89644: IN
89645: OR
89646: PUSH
89647: LD_VAR 0 1
89651: PUSH
89652: LD_EXP 60
89656: PUSH
89657: LD_VAR 0 3
89661: ARRAY
89662: IN
89663: OR
89664: PUSH
89665: LD_VAR 0 1
89669: PUSH
89670: LD_EXP 61
89674: PUSH
89675: LD_VAR 0 3
89679: ARRAY
89680: IN
89681: OR
89682: IFFALSE 90923
// begin if un in mc_ape [ i ] then
89684: LD_VAR 0 1
89688: PUSH
89689: LD_EXP 60
89693: PUSH
89694: LD_VAR 0 3
89698: ARRAY
89699: IN
89700: IFFALSE 89739
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89702: LD_ADDR_EXP 60
89706: PUSH
89707: LD_EXP 60
89711: PPUSH
89712: LD_VAR 0 3
89716: PPUSH
89717: LD_EXP 60
89721: PUSH
89722: LD_VAR 0 3
89726: ARRAY
89727: PUSH
89728: LD_VAR 0 1
89732: DIFF
89733: PPUSH
89734: CALL_OW 1
89738: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89739: LD_VAR 0 1
89743: PUSH
89744: LD_EXP 61
89748: PUSH
89749: LD_VAR 0 3
89753: ARRAY
89754: IN
89755: IFFALSE 89779
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89757: LD_ADDR_EXP 61
89761: PUSH
89762: LD_EXP 61
89766: PPUSH
89767: LD_VAR 0 3
89771: PPUSH
89772: EMPTY
89773: PPUSH
89774: CALL_OW 1
89778: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89779: LD_VAR 0 1
89783: PPUSH
89784: CALL_OW 247
89788: PUSH
89789: LD_INT 2
89791: EQUAL
89792: PUSH
89793: LD_VAR 0 1
89797: PPUSH
89798: CALL_OW 110
89802: PUSH
89803: LD_INT 20
89805: EQUAL
89806: PUSH
89807: LD_VAR 0 1
89811: PUSH
89812: LD_EXP 53
89816: PUSH
89817: LD_VAR 0 3
89821: ARRAY
89822: IN
89823: OR
89824: PUSH
89825: LD_VAR 0 1
89829: PPUSH
89830: CALL_OW 264
89834: PUSH
89835: LD_INT 12
89837: PUSH
89838: LD_INT 51
89840: PUSH
89841: LD_INT 89
89843: PUSH
89844: LD_INT 32
89846: PUSH
89847: LD_INT 13
89849: PUSH
89850: LD_INT 52
89852: PUSH
89853: LD_INT 31
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: IN
89865: OR
89866: AND
89867: IFFALSE 90175
// begin if un in mc_defender [ i ] then
89869: LD_VAR 0 1
89873: PUSH
89874: LD_EXP 53
89878: PUSH
89879: LD_VAR 0 3
89883: ARRAY
89884: IN
89885: IFFALSE 89924
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89887: LD_ADDR_EXP 53
89891: PUSH
89892: LD_EXP 53
89896: PPUSH
89897: LD_VAR 0 3
89901: PPUSH
89902: LD_EXP 53
89906: PUSH
89907: LD_VAR 0 3
89911: ARRAY
89912: PUSH
89913: LD_VAR 0 1
89917: DIFF
89918: PPUSH
89919: CALL_OW 1
89923: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89924: LD_ADDR_VAR 0 8
89928: PUSH
89929: LD_VAR 0 3
89933: PPUSH
89934: LD_INT 3
89936: PPUSH
89937: CALL 86545 0 2
89941: ST_TO_ADDR
// if fac then
89942: LD_VAR 0 8
89946: IFFALSE 90175
// begin for j in fac do
89948: LD_ADDR_VAR 0 4
89952: PUSH
89953: LD_VAR 0 8
89957: PUSH
89958: FOR_IN
89959: IFFALSE 90173
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89961: LD_ADDR_VAR 0 9
89965: PUSH
89966: LD_VAR 0 8
89970: PPUSH
89971: LD_VAR 0 1
89975: PPUSH
89976: CALL_OW 265
89980: PPUSH
89981: LD_VAR 0 1
89985: PPUSH
89986: CALL_OW 262
89990: PPUSH
89991: LD_VAR 0 1
89995: PPUSH
89996: CALL_OW 263
90000: PPUSH
90001: LD_VAR 0 1
90005: PPUSH
90006: CALL_OW 264
90010: PPUSH
90011: CALL 22344 0 5
90015: ST_TO_ADDR
// if components then
90016: LD_VAR 0 9
90020: IFFALSE 90171
// begin if GetWeapon ( un ) = ar_control_tower then
90022: LD_VAR 0 1
90026: PPUSH
90027: CALL_OW 264
90031: PUSH
90032: LD_INT 31
90034: EQUAL
90035: IFFALSE 90152
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
90037: LD_VAR 0 1
90041: PPUSH
90042: CALL_OW 311
90046: PPUSH
90047: LD_INT 0
90049: PPUSH
90050: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
90054: LD_ADDR_EXP 71
90058: PUSH
90059: LD_EXP 71
90063: PPUSH
90064: LD_VAR 0 3
90068: PPUSH
90069: LD_EXP 71
90073: PUSH
90074: LD_VAR 0 3
90078: ARRAY
90079: PUSH
90080: LD_VAR 0 1
90084: PPUSH
90085: CALL_OW 311
90089: DIFF
90090: PPUSH
90091: CALL_OW 1
90095: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
90096: LD_ADDR_VAR 0 7
90100: PUSH
90101: LD_EXP 52
90105: PUSH
90106: LD_VAR 0 3
90110: ARRAY
90111: PPUSH
90112: LD_INT 1
90114: PPUSH
90115: LD_VAR 0 9
90119: PPUSH
90120: CALL_OW 2
90124: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
90125: LD_ADDR_EXP 52
90129: PUSH
90130: LD_EXP 52
90134: PPUSH
90135: LD_VAR 0 3
90139: PPUSH
90140: LD_VAR 0 7
90144: PPUSH
90145: CALL_OW 1
90149: ST_TO_ADDR
// end else
90150: GO 90169
// MC_InsertProduceList ( i , [ components ] ) ;
90152: LD_VAR 0 3
90156: PPUSH
90157: LD_VAR 0 9
90161: PUSH
90162: EMPTY
90163: LIST
90164: PPUSH
90165: CALL 86090 0 2
// break ;
90169: GO 90173
// end ; end ;
90171: GO 89958
90173: POP
90174: POP
// end ; end ; if GetType ( un ) = unit_building then
90175: LD_VAR 0 1
90179: PPUSH
90180: CALL_OW 247
90184: PUSH
90185: LD_INT 3
90187: EQUAL
90188: IFFALSE 90591
// begin btype := GetBType ( un ) ;
90190: LD_ADDR_VAR 0 5
90194: PUSH
90195: LD_VAR 0 1
90199: PPUSH
90200: CALL_OW 266
90204: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
90205: LD_VAR 0 5
90209: PUSH
90210: LD_INT 29
90212: PUSH
90213: LD_INT 30
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: IN
90220: IFFALSE 90293
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
90222: LD_VAR 0 1
90226: PPUSH
90227: CALL_OW 250
90231: PPUSH
90232: LD_VAR 0 1
90236: PPUSH
90237: CALL_OW 251
90241: PPUSH
90242: LD_VAR 0 1
90246: PPUSH
90247: CALL_OW 255
90251: PPUSH
90252: CALL_OW 440
90256: NOT
90257: IFFALSE 90293
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
90259: LD_VAR 0 1
90263: PPUSH
90264: CALL_OW 250
90268: PPUSH
90269: LD_VAR 0 1
90273: PPUSH
90274: CALL_OW 251
90278: PPUSH
90279: LD_VAR 0 1
90283: PPUSH
90284: CALL_OW 255
90288: PPUSH
90289: CALL_OW 441
// end ; if btype = b_warehouse then
90293: LD_VAR 0 5
90297: PUSH
90298: LD_INT 1
90300: EQUAL
90301: IFFALSE 90319
// begin btype := b_depot ;
90303: LD_ADDR_VAR 0 5
90307: PUSH
90308: LD_INT 0
90310: ST_TO_ADDR
// pos := 1 ;
90311: LD_ADDR_VAR 0 6
90315: PUSH
90316: LD_INT 1
90318: ST_TO_ADDR
// end ; if btype = b_factory then
90319: LD_VAR 0 5
90323: PUSH
90324: LD_INT 3
90326: EQUAL
90327: IFFALSE 90345
// begin btype := b_workshop ;
90329: LD_ADDR_VAR 0 5
90333: PUSH
90334: LD_INT 2
90336: ST_TO_ADDR
// pos := 1 ;
90337: LD_ADDR_VAR 0 6
90341: PUSH
90342: LD_INT 1
90344: ST_TO_ADDR
// end ; if btype = b_barracks then
90345: LD_VAR 0 5
90349: PUSH
90350: LD_INT 5
90352: EQUAL
90353: IFFALSE 90363
// btype := b_armoury ;
90355: LD_ADDR_VAR 0 5
90359: PUSH
90360: LD_INT 4
90362: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
90363: LD_VAR 0 5
90367: PUSH
90368: LD_INT 7
90370: PUSH
90371: LD_INT 8
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: IN
90378: IFFALSE 90388
// btype := b_lab ;
90380: LD_ADDR_VAR 0 5
90384: PUSH
90385: LD_INT 6
90387: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
90388: LD_ADDR_EXP 36
90392: PUSH
90393: LD_EXP 36
90397: PPUSH
90398: LD_VAR 0 3
90402: PUSH
90403: LD_EXP 36
90407: PUSH
90408: LD_VAR 0 3
90412: ARRAY
90413: PUSH
90414: LD_INT 1
90416: PLUS
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PPUSH
90422: LD_VAR 0 5
90426: PUSH
90427: LD_VAR 0 1
90431: PPUSH
90432: CALL_OW 250
90436: PUSH
90437: LD_VAR 0 1
90441: PPUSH
90442: CALL_OW 251
90446: PUSH
90447: LD_VAR 0 1
90451: PPUSH
90452: CALL_OW 254
90456: PUSH
90457: EMPTY
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: PPUSH
90463: CALL 24846 0 3
90467: ST_TO_ADDR
// if pos = 1 then
90468: LD_VAR 0 6
90472: PUSH
90473: LD_INT 1
90475: EQUAL
90476: IFFALSE 90591
// begin tmp := mc_build_list [ i ] ;
90478: LD_ADDR_VAR 0 7
90482: PUSH
90483: LD_EXP 36
90487: PUSH
90488: LD_VAR 0 3
90492: ARRAY
90493: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
90494: LD_VAR 0 7
90498: PPUSH
90499: LD_INT 2
90501: PUSH
90502: LD_INT 30
90504: PUSH
90505: LD_INT 0
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 30
90514: PUSH
90515: LD_INT 1
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: EMPTY
90523: LIST
90524: LIST
90525: LIST
90526: PPUSH
90527: CALL_OW 72
90531: IFFALSE 90541
// pos := 2 ;
90533: LD_ADDR_VAR 0 6
90537: PUSH
90538: LD_INT 2
90540: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
90541: LD_ADDR_VAR 0 7
90545: PUSH
90546: LD_VAR 0 7
90550: PPUSH
90551: LD_VAR 0 6
90555: PPUSH
90556: LD_VAR 0 7
90560: PPUSH
90561: CALL 25172 0 3
90565: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
90566: LD_ADDR_EXP 36
90570: PUSH
90571: LD_EXP 36
90575: PPUSH
90576: LD_VAR 0 3
90580: PPUSH
90581: LD_VAR 0 7
90585: PPUSH
90586: CALL_OW 1
90590: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
90591: LD_VAR 0 1
90595: PUSH
90596: LD_EXP 31
90600: PUSH
90601: LD_VAR 0 3
90605: ARRAY
90606: IN
90607: IFFALSE 90646
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90609: LD_ADDR_EXP 31
90613: PUSH
90614: LD_EXP 31
90618: PPUSH
90619: LD_VAR 0 3
90623: PPUSH
90624: LD_EXP 31
90628: PUSH
90629: LD_VAR 0 3
90633: ARRAY
90634: PUSH
90635: LD_VAR 0 1
90639: DIFF
90640: PPUSH
90641: CALL_OW 1
90645: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90646: LD_VAR 0 1
90650: PUSH
90651: LD_EXP 38
90655: PUSH
90656: LD_VAR 0 3
90660: ARRAY
90661: IN
90662: IFFALSE 90701
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90664: LD_ADDR_EXP 38
90668: PUSH
90669: LD_EXP 38
90673: PPUSH
90674: LD_VAR 0 3
90678: PPUSH
90679: LD_EXP 38
90683: PUSH
90684: LD_VAR 0 3
90688: ARRAY
90689: PUSH
90690: LD_VAR 0 1
90694: DIFF
90695: PPUSH
90696: CALL_OW 1
90700: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90701: LD_VAR 0 1
90705: PUSH
90706: LD_EXP 50
90710: PUSH
90711: LD_VAR 0 3
90715: ARRAY
90716: IN
90717: IFFALSE 90756
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90719: LD_ADDR_EXP 50
90723: PUSH
90724: LD_EXP 50
90728: PPUSH
90729: LD_VAR 0 3
90733: PPUSH
90734: LD_EXP 50
90738: PUSH
90739: LD_VAR 0 3
90743: ARRAY
90744: PUSH
90745: LD_VAR 0 1
90749: DIFF
90750: PPUSH
90751: CALL_OW 1
90755: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90756: LD_VAR 0 1
90760: PUSH
90761: LD_EXP 53
90765: PUSH
90766: LD_VAR 0 3
90770: ARRAY
90771: IN
90772: IFFALSE 90811
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90774: LD_ADDR_EXP 53
90778: PUSH
90779: LD_EXP 53
90783: PPUSH
90784: LD_VAR 0 3
90788: PPUSH
90789: LD_EXP 53
90793: PUSH
90794: LD_VAR 0 3
90798: ARRAY
90799: PUSH
90800: LD_VAR 0 1
90804: DIFF
90805: PPUSH
90806: CALL_OW 1
90810: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90811: LD_VAR 0 1
90815: PUSH
90816: LD_EXP 40
90820: PUSH
90821: LD_VAR 0 3
90825: ARRAY
90826: IN
90827: IFFALSE 90866
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90829: LD_ADDR_EXP 40
90833: PUSH
90834: LD_EXP 40
90838: PPUSH
90839: LD_VAR 0 3
90843: PPUSH
90844: LD_EXP 40
90848: PUSH
90849: LD_VAR 0 3
90853: ARRAY
90854: PUSH
90855: LD_VAR 0 1
90859: DIFF
90860: PPUSH
90861: CALL_OW 1
90865: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90866: LD_VAR 0 1
90870: PUSH
90871: LD_EXP 39
90875: PUSH
90876: LD_VAR 0 3
90880: ARRAY
90881: IN
90882: IFFALSE 90921
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90884: LD_ADDR_EXP 39
90888: PUSH
90889: LD_EXP 39
90893: PPUSH
90894: LD_VAR 0 3
90898: PPUSH
90899: LD_EXP 39
90903: PUSH
90904: LD_VAR 0 3
90908: ARRAY
90909: PUSH
90910: LD_VAR 0 1
90914: DIFF
90915: PPUSH
90916: CALL_OW 1
90920: ST_TO_ADDR
// end ; break ;
90921: GO 90925
// end ;
90923: GO 89573
90925: POP
90926: POP
// end ;
90927: LD_VAR 0 2
90931: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90932: LD_INT 0
90934: PPUSH
90935: PPUSH
90936: PPUSH
// if not mc_bases or not skirmish then
90937: LD_EXP 31
90941: NOT
90942: PUSH
90943: LD_EXP 29
90947: NOT
90948: OR
90949: IFFALSE 90953
// exit ;
90951: GO 91168
// for i = 1 to mc_bases do
90953: LD_ADDR_VAR 0 3
90957: PUSH
90958: DOUBLE
90959: LD_INT 1
90961: DEC
90962: ST_TO_ADDR
90963: LD_EXP 31
90967: PUSH
90968: FOR_TO
90969: IFFALSE 91166
// begin if building in mc_construct_list [ i ] then
90971: LD_VAR 0 1
90975: PUSH
90976: LD_EXP 38
90980: PUSH
90981: LD_VAR 0 3
90985: ARRAY
90986: IN
90987: IFFALSE 91164
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90989: LD_ADDR_EXP 38
90993: PUSH
90994: LD_EXP 38
90998: PPUSH
90999: LD_VAR 0 3
91003: PPUSH
91004: LD_EXP 38
91008: PUSH
91009: LD_VAR 0 3
91013: ARRAY
91014: PUSH
91015: LD_VAR 0 1
91019: DIFF
91020: PPUSH
91021: CALL_OW 1
91025: ST_TO_ADDR
// if building in mc_lab [ i ] then
91026: LD_VAR 0 1
91030: PUSH
91031: LD_EXP 64
91035: PUSH
91036: LD_VAR 0 3
91040: ARRAY
91041: IN
91042: IFFALSE 91097
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
91044: LD_ADDR_EXP 65
91048: PUSH
91049: LD_EXP 65
91053: PPUSH
91054: LD_VAR 0 3
91058: PPUSH
91059: LD_EXP 65
91063: PUSH
91064: LD_VAR 0 3
91068: ARRAY
91069: PPUSH
91070: LD_INT 1
91072: PPUSH
91073: LD_EXP 65
91077: PUSH
91078: LD_VAR 0 3
91082: ARRAY
91083: PPUSH
91084: LD_INT 0
91086: PPUSH
91087: CALL 24264 0 4
91091: PPUSH
91092: CALL_OW 1
91096: ST_TO_ADDR
// if not building in mc_bases [ i ] then
91097: LD_VAR 0 1
91101: PUSH
91102: LD_EXP 31
91106: PUSH
91107: LD_VAR 0 3
91111: ARRAY
91112: IN
91113: NOT
91114: IFFALSE 91160
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
91116: LD_ADDR_EXP 31
91120: PUSH
91121: LD_EXP 31
91125: PPUSH
91126: LD_VAR 0 3
91130: PUSH
91131: LD_EXP 31
91135: PUSH
91136: LD_VAR 0 3
91140: ARRAY
91141: PUSH
91142: LD_INT 1
91144: PLUS
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PPUSH
91150: LD_VAR 0 1
91154: PPUSH
91155: CALL 24846 0 3
91159: ST_TO_ADDR
// exit ;
91160: POP
91161: POP
91162: GO 91168
// end ; end ;
91164: GO 90968
91166: POP
91167: POP
// end ;
91168: LD_VAR 0 2
91172: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
91173: LD_INT 0
91175: PPUSH
91176: PPUSH
91177: PPUSH
91178: PPUSH
91179: PPUSH
91180: PPUSH
91181: PPUSH
// if not mc_bases or not skirmish then
91182: LD_EXP 31
91186: NOT
91187: PUSH
91188: LD_EXP 29
91192: NOT
91193: OR
91194: IFFALSE 91198
// exit ;
91196: GO 91859
// for i = 1 to mc_bases do
91198: LD_ADDR_VAR 0 3
91202: PUSH
91203: DOUBLE
91204: LD_INT 1
91206: DEC
91207: ST_TO_ADDR
91208: LD_EXP 31
91212: PUSH
91213: FOR_TO
91214: IFFALSE 91857
// begin if building in mc_construct_list [ i ] then
91216: LD_VAR 0 1
91220: PUSH
91221: LD_EXP 38
91225: PUSH
91226: LD_VAR 0 3
91230: ARRAY
91231: IN
91232: IFFALSE 91855
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
91234: LD_ADDR_EXP 38
91238: PUSH
91239: LD_EXP 38
91243: PPUSH
91244: LD_VAR 0 3
91248: PPUSH
91249: LD_EXP 38
91253: PUSH
91254: LD_VAR 0 3
91258: ARRAY
91259: PUSH
91260: LD_VAR 0 1
91264: DIFF
91265: PPUSH
91266: CALL_OW 1
91270: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
91271: LD_ADDR_EXP 31
91275: PUSH
91276: LD_EXP 31
91280: PPUSH
91281: LD_VAR 0 3
91285: PUSH
91286: LD_EXP 31
91290: PUSH
91291: LD_VAR 0 3
91295: ARRAY
91296: PUSH
91297: LD_INT 1
91299: PLUS
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: PPUSH
91305: LD_VAR 0 1
91309: PPUSH
91310: CALL 24846 0 3
91314: ST_TO_ADDR
// btype := GetBType ( building ) ;
91315: LD_ADDR_VAR 0 5
91319: PUSH
91320: LD_VAR 0 1
91324: PPUSH
91325: CALL_OW 266
91329: ST_TO_ADDR
// side := GetSide ( building ) ;
91330: LD_ADDR_VAR 0 8
91334: PUSH
91335: LD_VAR 0 1
91339: PPUSH
91340: CALL_OW 255
91344: ST_TO_ADDR
// if btype = b_lab then
91345: LD_VAR 0 5
91349: PUSH
91350: LD_INT 6
91352: EQUAL
91353: IFFALSE 91403
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
91355: LD_ADDR_EXP 64
91359: PUSH
91360: LD_EXP 64
91364: PPUSH
91365: LD_VAR 0 3
91369: PUSH
91370: LD_EXP 64
91374: PUSH
91375: LD_VAR 0 3
91379: ARRAY
91380: PUSH
91381: LD_INT 1
91383: PLUS
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: PPUSH
91389: LD_VAR 0 1
91393: PPUSH
91394: CALL 24846 0 3
91398: ST_TO_ADDR
// exit ;
91399: POP
91400: POP
91401: GO 91859
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
91403: LD_VAR 0 5
91407: PUSH
91408: LD_INT 0
91410: PUSH
91411: LD_INT 2
91413: PUSH
91414: LD_INT 4
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: LIST
91421: IN
91422: IFFALSE 91546
// begin if btype = b_armoury then
91424: LD_VAR 0 5
91428: PUSH
91429: LD_INT 4
91431: EQUAL
91432: IFFALSE 91442
// btype := b_barracks ;
91434: LD_ADDR_VAR 0 5
91438: PUSH
91439: LD_INT 5
91441: ST_TO_ADDR
// if btype = b_depot then
91442: LD_VAR 0 5
91446: PUSH
91447: LD_INT 0
91449: EQUAL
91450: IFFALSE 91460
// btype := b_warehouse ;
91452: LD_ADDR_VAR 0 5
91456: PUSH
91457: LD_INT 1
91459: ST_TO_ADDR
// if btype = b_workshop then
91460: LD_VAR 0 5
91464: PUSH
91465: LD_INT 2
91467: EQUAL
91468: IFFALSE 91478
// btype := b_factory ;
91470: LD_ADDR_VAR 0 5
91474: PUSH
91475: LD_INT 3
91477: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
91478: LD_VAR 0 5
91482: PPUSH
91483: LD_VAR 0 8
91487: PPUSH
91488: CALL_OW 323
91492: PUSH
91493: LD_INT 1
91495: EQUAL
91496: IFFALSE 91542
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
91498: LD_ADDR_EXP 63
91502: PUSH
91503: LD_EXP 63
91507: PPUSH
91508: LD_VAR 0 3
91512: PUSH
91513: LD_EXP 63
91517: PUSH
91518: LD_VAR 0 3
91522: ARRAY
91523: PUSH
91524: LD_INT 1
91526: PLUS
91527: PUSH
91528: EMPTY
91529: LIST
91530: LIST
91531: PPUSH
91532: LD_VAR 0 1
91536: PPUSH
91537: CALL 24846 0 3
91541: ST_TO_ADDR
// exit ;
91542: POP
91543: POP
91544: GO 91859
// end ; if btype in [ b_bunker , b_turret ] then
91546: LD_VAR 0 5
91550: PUSH
91551: LD_INT 32
91553: PUSH
91554: LD_INT 33
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: IN
91561: IFFALSE 91851
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
91563: LD_ADDR_EXP 39
91567: PUSH
91568: LD_EXP 39
91572: PPUSH
91573: LD_VAR 0 3
91577: PUSH
91578: LD_EXP 39
91582: PUSH
91583: LD_VAR 0 3
91587: ARRAY
91588: PUSH
91589: LD_INT 1
91591: PLUS
91592: PUSH
91593: EMPTY
91594: LIST
91595: LIST
91596: PPUSH
91597: LD_VAR 0 1
91601: PPUSH
91602: CALL 24846 0 3
91606: ST_TO_ADDR
// if btype = b_bunker then
91607: LD_VAR 0 5
91611: PUSH
91612: LD_INT 32
91614: EQUAL
91615: IFFALSE 91851
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91617: LD_ADDR_EXP 40
91621: PUSH
91622: LD_EXP 40
91626: PPUSH
91627: LD_VAR 0 3
91631: PUSH
91632: LD_EXP 40
91636: PUSH
91637: LD_VAR 0 3
91641: ARRAY
91642: PUSH
91643: LD_INT 1
91645: PLUS
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PPUSH
91651: LD_VAR 0 1
91655: PPUSH
91656: CALL 24846 0 3
91660: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91661: LD_ADDR_VAR 0 6
91665: PUSH
91666: LD_EXP 31
91670: PUSH
91671: LD_VAR 0 3
91675: ARRAY
91676: PPUSH
91677: LD_INT 25
91679: PUSH
91680: LD_INT 1
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: LD_INT 3
91689: PUSH
91690: LD_INT 54
91692: PUSH
91693: EMPTY
91694: LIST
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: EMPTY
91701: LIST
91702: LIST
91703: PPUSH
91704: CALL_OW 72
91708: ST_TO_ADDR
// if tmp then
91709: LD_VAR 0 6
91713: IFFALSE 91719
// exit ;
91715: POP
91716: POP
91717: GO 91859
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91719: LD_ADDR_VAR 0 6
91723: PUSH
91724: LD_EXP 31
91728: PUSH
91729: LD_VAR 0 3
91733: ARRAY
91734: PPUSH
91735: LD_INT 2
91737: PUSH
91738: LD_INT 30
91740: PUSH
91741: LD_INT 4
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: PUSH
91748: LD_INT 30
91750: PUSH
91751: LD_INT 5
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: LIST
91762: PPUSH
91763: CALL_OW 72
91767: ST_TO_ADDR
// if not tmp then
91768: LD_VAR 0 6
91772: NOT
91773: IFFALSE 91779
// exit ;
91775: POP
91776: POP
91777: GO 91859
// for j in tmp do
91779: LD_ADDR_VAR 0 4
91783: PUSH
91784: LD_VAR 0 6
91788: PUSH
91789: FOR_IN
91790: IFFALSE 91849
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91792: LD_ADDR_VAR 0 7
91796: PUSH
91797: LD_VAR 0 4
91801: PPUSH
91802: CALL_OW 313
91806: PPUSH
91807: LD_INT 25
91809: PUSH
91810: LD_INT 1
91812: PUSH
91813: EMPTY
91814: LIST
91815: LIST
91816: PPUSH
91817: CALL_OW 72
91821: ST_TO_ADDR
// if units then
91822: LD_VAR 0 7
91826: IFFALSE 91847
// begin ComExitBuilding ( units [ 1 ] ) ;
91828: LD_VAR 0 7
91832: PUSH
91833: LD_INT 1
91835: ARRAY
91836: PPUSH
91837: CALL_OW 122
// exit ;
91841: POP
91842: POP
91843: POP
91844: POP
91845: GO 91859
// end ; end ;
91847: GO 91789
91849: POP
91850: POP
// end ; end ; exit ;
91851: POP
91852: POP
91853: GO 91859
// end ; end ;
91855: GO 91213
91857: POP
91858: POP
// end ;
91859: LD_VAR 0 2
91863: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91864: LD_INT 0
91866: PPUSH
91867: PPUSH
91868: PPUSH
91869: PPUSH
91870: PPUSH
91871: PPUSH
91872: PPUSH
// if not mc_bases or not skirmish then
91873: LD_EXP 31
91877: NOT
91878: PUSH
91879: LD_EXP 29
91883: NOT
91884: OR
91885: IFFALSE 91889
// exit ;
91887: GO 92154
// btype := GetBType ( building ) ;
91889: LD_ADDR_VAR 0 6
91893: PUSH
91894: LD_VAR 0 1
91898: PPUSH
91899: CALL_OW 266
91903: ST_TO_ADDR
// x := GetX ( building ) ;
91904: LD_ADDR_VAR 0 7
91908: PUSH
91909: LD_VAR 0 1
91913: PPUSH
91914: CALL_OW 250
91918: ST_TO_ADDR
// y := GetY ( building ) ;
91919: LD_ADDR_VAR 0 8
91923: PUSH
91924: LD_VAR 0 1
91928: PPUSH
91929: CALL_OW 251
91933: ST_TO_ADDR
// d := GetDir ( building ) ;
91934: LD_ADDR_VAR 0 9
91938: PUSH
91939: LD_VAR 0 1
91943: PPUSH
91944: CALL_OW 254
91948: ST_TO_ADDR
// for i = 1 to mc_bases do
91949: LD_ADDR_VAR 0 4
91953: PUSH
91954: DOUBLE
91955: LD_INT 1
91957: DEC
91958: ST_TO_ADDR
91959: LD_EXP 31
91963: PUSH
91964: FOR_TO
91965: IFFALSE 92152
// begin if not mc_build_list [ i ] then
91967: LD_EXP 36
91971: PUSH
91972: LD_VAR 0 4
91976: ARRAY
91977: NOT
91978: IFFALSE 91982
// continue ;
91980: GO 91964
// for j := 1 to mc_build_list [ i ] do
91982: LD_ADDR_VAR 0 5
91986: PUSH
91987: DOUBLE
91988: LD_INT 1
91990: DEC
91991: ST_TO_ADDR
91992: LD_EXP 36
91996: PUSH
91997: LD_VAR 0 4
92001: ARRAY
92002: PUSH
92003: FOR_TO
92004: IFFALSE 92148
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
92006: LD_VAR 0 6
92010: PUSH
92011: LD_VAR 0 7
92015: PUSH
92016: LD_VAR 0 8
92020: PUSH
92021: LD_VAR 0 9
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: PPUSH
92032: LD_EXP 36
92036: PUSH
92037: LD_VAR 0 4
92041: ARRAY
92042: PUSH
92043: LD_VAR 0 5
92047: ARRAY
92048: PPUSH
92049: CALL 31403 0 2
92053: IFFALSE 92146
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
92055: LD_ADDR_EXP 36
92059: PUSH
92060: LD_EXP 36
92064: PPUSH
92065: LD_VAR 0 4
92069: PPUSH
92070: LD_EXP 36
92074: PUSH
92075: LD_VAR 0 4
92079: ARRAY
92080: PPUSH
92081: LD_VAR 0 5
92085: PPUSH
92086: CALL_OW 3
92090: PPUSH
92091: CALL_OW 1
92095: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
92096: LD_ADDR_EXP 38
92100: PUSH
92101: LD_EXP 38
92105: PPUSH
92106: LD_VAR 0 4
92110: PUSH
92111: LD_EXP 38
92115: PUSH
92116: LD_VAR 0 4
92120: ARRAY
92121: PUSH
92122: LD_INT 1
92124: PLUS
92125: PUSH
92126: EMPTY
92127: LIST
92128: LIST
92129: PPUSH
92130: LD_VAR 0 1
92134: PPUSH
92135: CALL 24846 0 3
92139: ST_TO_ADDR
// exit ;
92140: POP
92141: POP
92142: POP
92143: POP
92144: GO 92154
// end ;
92146: GO 92003
92148: POP
92149: POP
// end ;
92150: GO 91964
92152: POP
92153: POP
// end ;
92154: LD_VAR 0 3
92158: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
92159: LD_INT 0
92161: PPUSH
92162: PPUSH
92163: PPUSH
// if not mc_bases or not skirmish then
92164: LD_EXP 31
92168: NOT
92169: PUSH
92170: LD_EXP 29
92174: NOT
92175: OR
92176: IFFALSE 92180
// exit ;
92178: GO 92370
// for i = 1 to mc_bases do
92180: LD_ADDR_VAR 0 4
92184: PUSH
92185: DOUBLE
92186: LD_INT 1
92188: DEC
92189: ST_TO_ADDR
92190: LD_EXP 31
92194: PUSH
92195: FOR_TO
92196: IFFALSE 92283
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
92198: LD_VAR 0 1
92202: PUSH
92203: LD_EXP 39
92207: PUSH
92208: LD_VAR 0 4
92212: ARRAY
92213: IN
92214: PUSH
92215: LD_VAR 0 1
92219: PUSH
92220: LD_EXP 40
92224: PUSH
92225: LD_VAR 0 4
92229: ARRAY
92230: IN
92231: NOT
92232: AND
92233: IFFALSE 92281
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
92235: LD_ADDR_EXP 40
92239: PUSH
92240: LD_EXP 40
92244: PPUSH
92245: LD_VAR 0 4
92249: PUSH
92250: LD_EXP 40
92254: PUSH
92255: LD_VAR 0 4
92259: ARRAY
92260: PUSH
92261: LD_INT 1
92263: PLUS
92264: PUSH
92265: EMPTY
92266: LIST
92267: LIST
92268: PPUSH
92269: LD_VAR 0 1
92273: PPUSH
92274: CALL 24846 0 3
92278: ST_TO_ADDR
// break ;
92279: GO 92283
// end ; end ;
92281: GO 92195
92283: POP
92284: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
92285: LD_VAR 0 1
92289: PPUSH
92290: CALL_OW 257
92294: PUSH
92295: LD_EXP 57
92299: IN
92300: PUSH
92301: LD_VAR 0 1
92305: PPUSH
92306: CALL_OW 266
92310: PUSH
92311: LD_INT 5
92313: EQUAL
92314: AND
92315: PUSH
92316: LD_VAR 0 2
92320: PPUSH
92321: CALL_OW 110
92325: PUSH
92326: LD_INT 18
92328: NONEQUAL
92329: AND
92330: IFFALSE 92370
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
92332: LD_VAR 0 2
92336: PPUSH
92337: CALL_OW 257
92341: PUSH
92342: LD_INT 5
92344: PUSH
92345: LD_INT 8
92347: PUSH
92348: LD_INT 9
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: LIST
92355: IN
92356: IFFALSE 92370
// SetClass ( unit , 1 ) ;
92358: LD_VAR 0 2
92362: PPUSH
92363: LD_INT 1
92365: PPUSH
92366: CALL_OW 336
// end ;
92370: LD_VAR 0 3
92374: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
92375: LD_INT 0
92377: PPUSH
92378: PPUSH
// if not mc_bases or not skirmish then
92379: LD_EXP 31
92383: NOT
92384: PUSH
92385: LD_EXP 29
92389: NOT
92390: OR
92391: IFFALSE 92395
// exit ;
92393: GO 92511
// if GetLives ( abandoned_vehicle ) > 250 then
92395: LD_VAR 0 2
92399: PPUSH
92400: CALL_OW 256
92404: PUSH
92405: LD_INT 250
92407: GREATER
92408: IFFALSE 92412
// exit ;
92410: GO 92511
// for i = 1 to mc_bases do
92412: LD_ADDR_VAR 0 6
92416: PUSH
92417: DOUBLE
92418: LD_INT 1
92420: DEC
92421: ST_TO_ADDR
92422: LD_EXP 31
92426: PUSH
92427: FOR_TO
92428: IFFALSE 92509
// begin if driver in mc_bases [ i ] then
92430: LD_VAR 0 1
92434: PUSH
92435: LD_EXP 31
92439: PUSH
92440: LD_VAR 0 6
92444: ARRAY
92445: IN
92446: IFFALSE 92507
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
92448: LD_VAR 0 1
92452: PPUSH
92453: LD_EXP 31
92457: PUSH
92458: LD_VAR 0 6
92462: ARRAY
92463: PPUSH
92464: LD_INT 2
92466: PUSH
92467: LD_INT 30
92469: PUSH
92470: LD_INT 0
92472: PUSH
92473: EMPTY
92474: LIST
92475: LIST
92476: PUSH
92477: LD_INT 30
92479: PUSH
92480: LD_INT 1
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: LIST
92491: PPUSH
92492: CALL_OW 72
92496: PUSH
92497: LD_INT 1
92499: ARRAY
92500: PPUSH
92501: CALL 58463 0 2
// break ;
92505: GO 92509
// end ; end ;
92507: GO 92427
92509: POP
92510: POP
// end ; end_of_file end_of_file
92511: LD_VAR 0 5
92515: RET
// export globalGameSaveCounter ; every 0 0$1 do
92516: GO 92518
92518: DISABLE
// begin enable ;
92519: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
92520: LD_STRING updateTimer(
92522: PUSH
92523: LD_OWVAR 1
92527: STR
92528: PUSH
92529: LD_STRING );
92531: STR
92532: PPUSH
92533: CALL_OW 559
// end ;
92537: END
// every 0 0$1 do
92538: GO 92540
92540: DISABLE
// begin globalGameSaveCounter := 0 ;
92541: LD_ADDR_EXP 76
92545: PUSH
92546: LD_INT 0
92548: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
92549: LD_STRING setGameSaveCounter(0)
92551: PPUSH
92552: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
92556: LD_STRING initStreamRollete();
92558: PPUSH
92559: CALL_OW 559
// InitStreamMode ;
92563: CALL 93889 0 0
// DefineStreamItems ( false ) ;
92567: LD_INT 0
92569: PPUSH
92570: CALL 94353 0 1
// end ;
92574: END
// export function SOS_MapStart ( ) ; begin
92575: LD_INT 0
92577: PPUSH
// if streamModeActive then
92578: LD_EXP 77
92582: IFFALSE 92591
// DefineStreamItems ( true ) ;
92584: LD_INT 1
92586: PPUSH
92587: CALL 94353 0 1
// UpdateLuaVariables ( ) ;
92591: CALL 92608 0 0
// UpdateFactoryWaypoints ( ) ;
92595: CALL 107222 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92599: CALL 107479 0 0
// end ;
92603: LD_VAR 0 1
92607: RET
// function UpdateLuaVariables ( ) ; begin
92608: LD_INT 0
92610: PPUSH
// if globalGameSaveCounter then
92611: LD_EXP 76
92615: IFFALSE 92649
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92617: LD_ADDR_EXP 76
92621: PUSH
92622: LD_EXP 76
92626: PPUSH
92627: CALL 58947 0 1
92631: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92632: LD_STRING setGameSaveCounter(
92634: PUSH
92635: LD_EXP 76
92639: STR
92640: PUSH
92641: LD_STRING )
92643: STR
92644: PPUSH
92645: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92649: LD_STRING setGameDifficulty(
92651: PUSH
92652: LD_OWVAR 67
92656: STR
92657: PUSH
92658: LD_STRING )
92660: STR
92661: PPUSH
92662: CALL_OW 559
// end ;
92666: LD_VAR 0 1
92670: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92671: LD_INT 0
92673: PPUSH
// if p2 = stream_mode then
92674: LD_VAR 0 2
92678: PUSH
92679: LD_INT 100
92681: EQUAL
92682: IFFALSE 93685
// begin if not StreamModeActive then
92684: LD_EXP 77
92688: NOT
92689: IFFALSE 92699
// StreamModeActive := true ;
92691: LD_ADDR_EXP 77
92695: PUSH
92696: LD_INT 1
92698: ST_TO_ADDR
// if p3 = 0 then
92699: LD_VAR 0 3
92703: PUSH
92704: LD_INT 0
92706: EQUAL
92707: IFFALSE 92713
// InitStreamMode ;
92709: CALL 93889 0 0
// if p3 = 1 then
92713: LD_VAR 0 3
92717: PUSH
92718: LD_INT 1
92720: EQUAL
92721: IFFALSE 92731
// sRocket := true ;
92723: LD_ADDR_EXP 82
92727: PUSH
92728: LD_INT 1
92730: ST_TO_ADDR
// if p3 = 2 then
92731: LD_VAR 0 3
92735: PUSH
92736: LD_INT 2
92738: EQUAL
92739: IFFALSE 92749
// sSpeed := true ;
92741: LD_ADDR_EXP 81
92745: PUSH
92746: LD_INT 1
92748: ST_TO_ADDR
// if p3 = 3 then
92749: LD_VAR 0 3
92753: PUSH
92754: LD_INT 3
92756: EQUAL
92757: IFFALSE 92767
// sEngine := true ;
92759: LD_ADDR_EXP 83
92763: PUSH
92764: LD_INT 1
92766: ST_TO_ADDR
// if p3 = 4 then
92767: LD_VAR 0 3
92771: PUSH
92772: LD_INT 4
92774: EQUAL
92775: IFFALSE 92785
// sSpec := true ;
92777: LD_ADDR_EXP 80
92781: PUSH
92782: LD_INT 1
92784: ST_TO_ADDR
// if p3 = 5 then
92785: LD_VAR 0 3
92789: PUSH
92790: LD_INT 5
92792: EQUAL
92793: IFFALSE 92803
// sLevel := true ;
92795: LD_ADDR_EXP 84
92799: PUSH
92800: LD_INT 1
92802: ST_TO_ADDR
// if p3 = 6 then
92803: LD_VAR 0 3
92807: PUSH
92808: LD_INT 6
92810: EQUAL
92811: IFFALSE 92821
// sArmoury := true ;
92813: LD_ADDR_EXP 85
92817: PUSH
92818: LD_INT 1
92820: ST_TO_ADDR
// if p3 = 7 then
92821: LD_VAR 0 3
92825: PUSH
92826: LD_INT 7
92828: EQUAL
92829: IFFALSE 92839
// sRadar := true ;
92831: LD_ADDR_EXP 86
92835: PUSH
92836: LD_INT 1
92838: ST_TO_ADDR
// if p3 = 8 then
92839: LD_VAR 0 3
92843: PUSH
92844: LD_INT 8
92846: EQUAL
92847: IFFALSE 92857
// sBunker := true ;
92849: LD_ADDR_EXP 87
92853: PUSH
92854: LD_INT 1
92856: ST_TO_ADDR
// if p3 = 9 then
92857: LD_VAR 0 3
92861: PUSH
92862: LD_INT 9
92864: EQUAL
92865: IFFALSE 92875
// sHack := true ;
92867: LD_ADDR_EXP 88
92871: PUSH
92872: LD_INT 1
92874: ST_TO_ADDR
// if p3 = 10 then
92875: LD_VAR 0 3
92879: PUSH
92880: LD_INT 10
92882: EQUAL
92883: IFFALSE 92893
// sFire := true ;
92885: LD_ADDR_EXP 89
92889: PUSH
92890: LD_INT 1
92892: ST_TO_ADDR
// if p3 = 11 then
92893: LD_VAR 0 3
92897: PUSH
92898: LD_INT 11
92900: EQUAL
92901: IFFALSE 92911
// sRefresh := true ;
92903: LD_ADDR_EXP 90
92907: PUSH
92908: LD_INT 1
92910: ST_TO_ADDR
// if p3 = 12 then
92911: LD_VAR 0 3
92915: PUSH
92916: LD_INT 12
92918: EQUAL
92919: IFFALSE 92929
// sExp := true ;
92921: LD_ADDR_EXP 91
92925: PUSH
92926: LD_INT 1
92928: ST_TO_ADDR
// if p3 = 13 then
92929: LD_VAR 0 3
92933: PUSH
92934: LD_INT 13
92936: EQUAL
92937: IFFALSE 92947
// sDepot := true ;
92939: LD_ADDR_EXP 92
92943: PUSH
92944: LD_INT 1
92946: ST_TO_ADDR
// if p3 = 14 then
92947: LD_VAR 0 3
92951: PUSH
92952: LD_INT 14
92954: EQUAL
92955: IFFALSE 92965
// sFlag := true ;
92957: LD_ADDR_EXP 93
92961: PUSH
92962: LD_INT 1
92964: ST_TO_ADDR
// if p3 = 15 then
92965: LD_VAR 0 3
92969: PUSH
92970: LD_INT 15
92972: EQUAL
92973: IFFALSE 92983
// sKamikadze := true ;
92975: LD_ADDR_EXP 101
92979: PUSH
92980: LD_INT 1
92982: ST_TO_ADDR
// if p3 = 16 then
92983: LD_VAR 0 3
92987: PUSH
92988: LD_INT 16
92990: EQUAL
92991: IFFALSE 93001
// sTroll := true ;
92993: LD_ADDR_EXP 102
92997: PUSH
92998: LD_INT 1
93000: ST_TO_ADDR
// if p3 = 17 then
93001: LD_VAR 0 3
93005: PUSH
93006: LD_INT 17
93008: EQUAL
93009: IFFALSE 93019
// sSlow := true ;
93011: LD_ADDR_EXP 103
93015: PUSH
93016: LD_INT 1
93018: ST_TO_ADDR
// if p3 = 18 then
93019: LD_VAR 0 3
93023: PUSH
93024: LD_INT 18
93026: EQUAL
93027: IFFALSE 93037
// sLack := true ;
93029: LD_ADDR_EXP 104
93033: PUSH
93034: LD_INT 1
93036: ST_TO_ADDR
// if p3 = 19 then
93037: LD_VAR 0 3
93041: PUSH
93042: LD_INT 19
93044: EQUAL
93045: IFFALSE 93055
// sTank := true ;
93047: LD_ADDR_EXP 106
93051: PUSH
93052: LD_INT 1
93054: ST_TO_ADDR
// if p3 = 20 then
93055: LD_VAR 0 3
93059: PUSH
93060: LD_INT 20
93062: EQUAL
93063: IFFALSE 93073
// sRemote := true ;
93065: LD_ADDR_EXP 107
93069: PUSH
93070: LD_INT 1
93072: ST_TO_ADDR
// if p3 = 21 then
93073: LD_VAR 0 3
93077: PUSH
93078: LD_INT 21
93080: EQUAL
93081: IFFALSE 93091
// sPowell := true ;
93083: LD_ADDR_EXP 108
93087: PUSH
93088: LD_INT 1
93090: ST_TO_ADDR
// if p3 = 22 then
93091: LD_VAR 0 3
93095: PUSH
93096: LD_INT 22
93098: EQUAL
93099: IFFALSE 93109
// sTeleport := true ;
93101: LD_ADDR_EXP 111
93105: PUSH
93106: LD_INT 1
93108: ST_TO_ADDR
// if p3 = 23 then
93109: LD_VAR 0 3
93113: PUSH
93114: LD_INT 23
93116: EQUAL
93117: IFFALSE 93127
// sOilTower := true ;
93119: LD_ADDR_EXP 113
93123: PUSH
93124: LD_INT 1
93126: ST_TO_ADDR
// if p3 = 24 then
93127: LD_VAR 0 3
93131: PUSH
93132: LD_INT 24
93134: EQUAL
93135: IFFALSE 93145
// sShovel := true ;
93137: LD_ADDR_EXP 114
93141: PUSH
93142: LD_INT 1
93144: ST_TO_ADDR
// if p3 = 25 then
93145: LD_VAR 0 3
93149: PUSH
93150: LD_INT 25
93152: EQUAL
93153: IFFALSE 93163
// sSheik := true ;
93155: LD_ADDR_EXP 115
93159: PUSH
93160: LD_INT 1
93162: ST_TO_ADDR
// if p3 = 26 then
93163: LD_VAR 0 3
93167: PUSH
93168: LD_INT 26
93170: EQUAL
93171: IFFALSE 93181
// sEarthquake := true ;
93173: LD_ADDR_EXP 117
93177: PUSH
93178: LD_INT 1
93180: ST_TO_ADDR
// if p3 = 27 then
93181: LD_VAR 0 3
93185: PUSH
93186: LD_INT 27
93188: EQUAL
93189: IFFALSE 93199
// sAI := true ;
93191: LD_ADDR_EXP 118
93195: PUSH
93196: LD_INT 1
93198: ST_TO_ADDR
// if p3 = 28 then
93199: LD_VAR 0 3
93203: PUSH
93204: LD_INT 28
93206: EQUAL
93207: IFFALSE 93217
// sCargo := true ;
93209: LD_ADDR_EXP 121
93213: PUSH
93214: LD_INT 1
93216: ST_TO_ADDR
// if p3 = 29 then
93217: LD_VAR 0 3
93221: PUSH
93222: LD_INT 29
93224: EQUAL
93225: IFFALSE 93235
// sDLaser := true ;
93227: LD_ADDR_EXP 122
93231: PUSH
93232: LD_INT 1
93234: ST_TO_ADDR
// if p3 = 30 then
93235: LD_VAR 0 3
93239: PUSH
93240: LD_INT 30
93242: EQUAL
93243: IFFALSE 93253
// sExchange := true ;
93245: LD_ADDR_EXP 123
93249: PUSH
93250: LD_INT 1
93252: ST_TO_ADDR
// if p3 = 31 then
93253: LD_VAR 0 3
93257: PUSH
93258: LD_INT 31
93260: EQUAL
93261: IFFALSE 93271
// sFac := true ;
93263: LD_ADDR_EXP 124
93267: PUSH
93268: LD_INT 1
93270: ST_TO_ADDR
// if p3 = 32 then
93271: LD_VAR 0 3
93275: PUSH
93276: LD_INT 32
93278: EQUAL
93279: IFFALSE 93289
// sPower := true ;
93281: LD_ADDR_EXP 125
93285: PUSH
93286: LD_INT 1
93288: ST_TO_ADDR
// if p3 = 33 then
93289: LD_VAR 0 3
93293: PUSH
93294: LD_INT 33
93296: EQUAL
93297: IFFALSE 93307
// sRandom := true ;
93299: LD_ADDR_EXP 126
93303: PUSH
93304: LD_INT 1
93306: ST_TO_ADDR
// if p3 = 34 then
93307: LD_VAR 0 3
93311: PUSH
93312: LD_INT 34
93314: EQUAL
93315: IFFALSE 93325
// sShield := true ;
93317: LD_ADDR_EXP 127
93321: PUSH
93322: LD_INT 1
93324: ST_TO_ADDR
// if p3 = 35 then
93325: LD_VAR 0 3
93329: PUSH
93330: LD_INT 35
93332: EQUAL
93333: IFFALSE 93343
// sTime := true ;
93335: LD_ADDR_EXP 128
93339: PUSH
93340: LD_INT 1
93342: ST_TO_ADDR
// if p3 = 36 then
93343: LD_VAR 0 3
93347: PUSH
93348: LD_INT 36
93350: EQUAL
93351: IFFALSE 93361
// sTools := true ;
93353: LD_ADDR_EXP 129
93357: PUSH
93358: LD_INT 1
93360: ST_TO_ADDR
// if p3 = 101 then
93361: LD_VAR 0 3
93365: PUSH
93366: LD_INT 101
93368: EQUAL
93369: IFFALSE 93379
// sSold := true ;
93371: LD_ADDR_EXP 94
93375: PUSH
93376: LD_INT 1
93378: ST_TO_ADDR
// if p3 = 102 then
93379: LD_VAR 0 3
93383: PUSH
93384: LD_INT 102
93386: EQUAL
93387: IFFALSE 93397
// sDiff := true ;
93389: LD_ADDR_EXP 95
93393: PUSH
93394: LD_INT 1
93396: ST_TO_ADDR
// if p3 = 103 then
93397: LD_VAR 0 3
93401: PUSH
93402: LD_INT 103
93404: EQUAL
93405: IFFALSE 93415
// sFog := true ;
93407: LD_ADDR_EXP 98
93411: PUSH
93412: LD_INT 1
93414: ST_TO_ADDR
// if p3 = 104 then
93415: LD_VAR 0 3
93419: PUSH
93420: LD_INT 104
93422: EQUAL
93423: IFFALSE 93433
// sReset := true ;
93425: LD_ADDR_EXP 99
93429: PUSH
93430: LD_INT 1
93432: ST_TO_ADDR
// if p3 = 105 then
93433: LD_VAR 0 3
93437: PUSH
93438: LD_INT 105
93440: EQUAL
93441: IFFALSE 93451
// sSun := true ;
93443: LD_ADDR_EXP 100
93447: PUSH
93448: LD_INT 1
93450: ST_TO_ADDR
// if p3 = 106 then
93451: LD_VAR 0 3
93455: PUSH
93456: LD_INT 106
93458: EQUAL
93459: IFFALSE 93469
// sTiger := true ;
93461: LD_ADDR_EXP 96
93465: PUSH
93466: LD_INT 1
93468: ST_TO_ADDR
// if p3 = 107 then
93469: LD_VAR 0 3
93473: PUSH
93474: LD_INT 107
93476: EQUAL
93477: IFFALSE 93487
// sBomb := true ;
93479: LD_ADDR_EXP 97
93483: PUSH
93484: LD_INT 1
93486: ST_TO_ADDR
// if p3 = 108 then
93487: LD_VAR 0 3
93491: PUSH
93492: LD_INT 108
93494: EQUAL
93495: IFFALSE 93505
// sWound := true ;
93497: LD_ADDR_EXP 105
93501: PUSH
93502: LD_INT 1
93504: ST_TO_ADDR
// if p3 = 109 then
93505: LD_VAR 0 3
93509: PUSH
93510: LD_INT 109
93512: EQUAL
93513: IFFALSE 93523
// sBetray := true ;
93515: LD_ADDR_EXP 109
93519: PUSH
93520: LD_INT 1
93522: ST_TO_ADDR
// if p3 = 110 then
93523: LD_VAR 0 3
93527: PUSH
93528: LD_INT 110
93530: EQUAL
93531: IFFALSE 93541
// sContamin := true ;
93533: LD_ADDR_EXP 110
93537: PUSH
93538: LD_INT 1
93540: ST_TO_ADDR
// if p3 = 111 then
93541: LD_VAR 0 3
93545: PUSH
93546: LD_INT 111
93548: EQUAL
93549: IFFALSE 93559
// sOil := true ;
93551: LD_ADDR_EXP 112
93555: PUSH
93556: LD_INT 1
93558: ST_TO_ADDR
// if p3 = 112 then
93559: LD_VAR 0 3
93563: PUSH
93564: LD_INT 112
93566: EQUAL
93567: IFFALSE 93577
// sStu := true ;
93569: LD_ADDR_EXP 116
93573: PUSH
93574: LD_INT 1
93576: ST_TO_ADDR
// if p3 = 113 then
93577: LD_VAR 0 3
93581: PUSH
93582: LD_INT 113
93584: EQUAL
93585: IFFALSE 93595
// sBazooka := true ;
93587: LD_ADDR_EXP 119
93591: PUSH
93592: LD_INT 1
93594: ST_TO_ADDR
// if p3 = 114 then
93595: LD_VAR 0 3
93599: PUSH
93600: LD_INT 114
93602: EQUAL
93603: IFFALSE 93613
// sMortar := true ;
93605: LD_ADDR_EXP 120
93609: PUSH
93610: LD_INT 1
93612: ST_TO_ADDR
// if p3 = 115 then
93613: LD_VAR 0 3
93617: PUSH
93618: LD_INT 115
93620: EQUAL
93621: IFFALSE 93631
// sRanger := true ;
93623: LD_ADDR_EXP 130
93627: PUSH
93628: LD_INT 1
93630: ST_TO_ADDR
// if p3 = 116 then
93631: LD_VAR 0 3
93635: PUSH
93636: LD_INT 116
93638: EQUAL
93639: IFFALSE 93649
// sComputer := true ;
93641: LD_ADDR_EXP 131
93645: PUSH
93646: LD_INT 1
93648: ST_TO_ADDR
// if p3 = 117 then
93649: LD_VAR 0 3
93653: PUSH
93654: LD_INT 117
93656: EQUAL
93657: IFFALSE 93667
// s30 := true ;
93659: LD_ADDR_EXP 132
93663: PUSH
93664: LD_INT 1
93666: ST_TO_ADDR
// if p3 = 118 then
93667: LD_VAR 0 3
93671: PUSH
93672: LD_INT 118
93674: EQUAL
93675: IFFALSE 93685
// s60 := true ;
93677: LD_ADDR_EXP 133
93681: PUSH
93682: LD_INT 1
93684: ST_TO_ADDR
// end ; if p2 = hack_mode then
93685: LD_VAR 0 2
93689: PUSH
93690: LD_INT 101
93692: EQUAL
93693: IFFALSE 93821
// begin case p3 of 1 :
93695: LD_VAR 0 3
93699: PUSH
93700: LD_INT 1
93702: DOUBLE
93703: EQUAL
93704: IFTRUE 93708
93706: GO 93715
93708: POP
// hHackUnlimitedResources ; 2 :
93709: CALL 105968 0 0
93713: GO 93821
93715: LD_INT 2
93717: DOUBLE
93718: EQUAL
93719: IFTRUE 93723
93721: GO 93730
93723: POP
// hHackSetLevel10 ; 3 :
93724: CALL 106101 0 0
93728: GO 93821
93730: LD_INT 3
93732: DOUBLE
93733: EQUAL
93734: IFTRUE 93738
93736: GO 93745
93738: POP
// hHackSetLevel10YourUnits ; 4 :
93739: CALL 106186 0 0
93743: GO 93821
93745: LD_INT 4
93747: DOUBLE
93748: EQUAL
93749: IFTRUE 93753
93751: GO 93760
93753: POP
// hHackInvincible ; 5 :
93754: CALL 106634 0 0
93758: GO 93821
93760: LD_INT 5
93762: DOUBLE
93763: EQUAL
93764: IFTRUE 93768
93766: GO 93775
93768: POP
// hHackInvisible ; 6 :
93769: CALL 106745 0 0
93773: GO 93821
93775: LD_INT 6
93777: DOUBLE
93778: EQUAL
93779: IFTRUE 93783
93781: GO 93790
93783: POP
// hHackChangeYourSide ; 7 :
93784: CALL 106802 0 0
93788: GO 93821
93790: LD_INT 7
93792: DOUBLE
93793: EQUAL
93794: IFTRUE 93798
93796: GO 93805
93798: POP
// hHackChangeUnitSide ; 8 :
93799: CALL 106844 0 0
93803: GO 93821
93805: LD_INT 8
93807: DOUBLE
93808: EQUAL
93809: IFTRUE 93813
93811: GO 93820
93813: POP
// hHackFog ; end ;
93814: CALL 106945 0 0
93818: GO 93821
93820: POP
// end ; if p2 = game_save_mode then
93821: LD_VAR 0 2
93825: PUSH
93826: LD_INT 102
93828: EQUAL
93829: IFFALSE 93884
// begin if p3 = 1 then
93831: LD_VAR 0 3
93835: PUSH
93836: LD_INT 1
93838: EQUAL
93839: IFFALSE 93851
// globalGameSaveCounter := p4 ;
93841: LD_ADDR_EXP 76
93845: PUSH
93846: LD_VAR 0 4
93850: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93851: LD_VAR 0 3
93855: PUSH
93856: LD_INT 2
93858: EQUAL
93859: PUSH
93860: LD_EXP 76
93864: AND
93865: IFFALSE 93884
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93867: LD_STRING setGameSaveCounter(
93869: PUSH
93870: LD_EXP 76
93874: STR
93875: PUSH
93876: LD_STRING )
93878: STR
93879: PPUSH
93880: CALL_OW 559
// end ; end ;
93884: LD_VAR 0 7
93888: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93889: LD_INT 0
93891: PPUSH
// streamModeActive := false ;
93892: LD_ADDR_EXP 77
93896: PUSH
93897: LD_INT 0
93899: ST_TO_ADDR
// normalCounter := 36 ;
93900: LD_ADDR_EXP 78
93904: PUSH
93905: LD_INT 36
93907: ST_TO_ADDR
// hardcoreCounter := 18 ;
93908: LD_ADDR_EXP 79
93912: PUSH
93913: LD_INT 18
93915: ST_TO_ADDR
// sRocket := false ;
93916: LD_ADDR_EXP 82
93920: PUSH
93921: LD_INT 0
93923: ST_TO_ADDR
// sSpeed := false ;
93924: LD_ADDR_EXP 81
93928: PUSH
93929: LD_INT 0
93931: ST_TO_ADDR
// sEngine := false ;
93932: LD_ADDR_EXP 83
93936: PUSH
93937: LD_INT 0
93939: ST_TO_ADDR
// sSpec := false ;
93940: LD_ADDR_EXP 80
93944: PUSH
93945: LD_INT 0
93947: ST_TO_ADDR
// sLevel := false ;
93948: LD_ADDR_EXP 84
93952: PUSH
93953: LD_INT 0
93955: ST_TO_ADDR
// sArmoury := false ;
93956: LD_ADDR_EXP 85
93960: PUSH
93961: LD_INT 0
93963: ST_TO_ADDR
// sRadar := false ;
93964: LD_ADDR_EXP 86
93968: PUSH
93969: LD_INT 0
93971: ST_TO_ADDR
// sBunker := false ;
93972: LD_ADDR_EXP 87
93976: PUSH
93977: LD_INT 0
93979: ST_TO_ADDR
// sHack := false ;
93980: LD_ADDR_EXP 88
93984: PUSH
93985: LD_INT 0
93987: ST_TO_ADDR
// sFire := false ;
93988: LD_ADDR_EXP 89
93992: PUSH
93993: LD_INT 0
93995: ST_TO_ADDR
// sRefresh := false ;
93996: LD_ADDR_EXP 90
94000: PUSH
94001: LD_INT 0
94003: ST_TO_ADDR
// sExp := false ;
94004: LD_ADDR_EXP 91
94008: PUSH
94009: LD_INT 0
94011: ST_TO_ADDR
// sDepot := false ;
94012: LD_ADDR_EXP 92
94016: PUSH
94017: LD_INT 0
94019: ST_TO_ADDR
// sFlag := false ;
94020: LD_ADDR_EXP 93
94024: PUSH
94025: LD_INT 0
94027: ST_TO_ADDR
// sKamikadze := false ;
94028: LD_ADDR_EXP 101
94032: PUSH
94033: LD_INT 0
94035: ST_TO_ADDR
// sTroll := false ;
94036: LD_ADDR_EXP 102
94040: PUSH
94041: LD_INT 0
94043: ST_TO_ADDR
// sSlow := false ;
94044: LD_ADDR_EXP 103
94048: PUSH
94049: LD_INT 0
94051: ST_TO_ADDR
// sLack := false ;
94052: LD_ADDR_EXP 104
94056: PUSH
94057: LD_INT 0
94059: ST_TO_ADDR
// sTank := false ;
94060: LD_ADDR_EXP 106
94064: PUSH
94065: LD_INT 0
94067: ST_TO_ADDR
// sRemote := false ;
94068: LD_ADDR_EXP 107
94072: PUSH
94073: LD_INT 0
94075: ST_TO_ADDR
// sPowell := false ;
94076: LD_ADDR_EXP 108
94080: PUSH
94081: LD_INT 0
94083: ST_TO_ADDR
// sTeleport := false ;
94084: LD_ADDR_EXP 111
94088: PUSH
94089: LD_INT 0
94091: ST_TO_ADDR
// sOilTower := false ;
94092: LD_ADDR_EXP 113
94096: PUSH
94097: LD_INT 0
94099: ST_TO_ADDR
// sShovel := false ;
94100: LD_ADDR_EXP 114
94104: PUSH
94105: LD_INT 0
94107: ST_TO_ADDR
// sSheik := false ;
94108: LD_ADDR_EXP 115
94112: PUSH
94113: LD_INT 0
94115: ST_TO_ADDR
// sEarthquake := false ;
94116: LD_ADDR_EXP 117
94120: PUSH
94121: LD_INT 0
94123: ST_TO_ADDR
// sAI := false ;
94124: LD_ADDR_EXP 118
94128: PUSH
94129: LD_INT 0
94131: ST_TO_ADDR
// sCargo := false ;
94132: LD_ADDR_EXP 121
94136: PUSH
94137: LD_INT 0
94139: ST_TO_ADDR
// sDLaser := false ;
94140: LD_ADDR_EXP 122
94144: PUSH
94145: LD_INT 0
94147: ST_TO_ADDR
// sExchange := false ;
94148: LD_ADDR_EXP 123
94152: PUSH
94153: LD_INT 0
94155: ST_TO_ADDR
// sFac := false ;
94156: LD_ADDR_EXP 124
94160: PUSH
94161: LD_INT 0
94163: ST_TO_ADDR
// sPower := false ;
94164: LD_ADDR_EXP 125
94168: PUSH
94169: LD_INT 0
94171: ST_TO_ADDR
// sRandom := false ;
94172: LD_ADDR_EXP 126
94176: PUSH
94177: LD_INT 0
94179: ST_TO_ADDR
// sShield := false ;
94180: LD_ADDR_EXP 127
94184: PUSH
94185: LD_INT 0
94187: ST_TO_ADDR
// sTime := false ;
94188: LD_ADDR_EXP 128
94192: PUSH
94193: LD_INT 0
94195: ST_TO_ADDR
// sTools := false ;
94196: LD_ADDR_EXP 129
94200: PUSH
94201: LD_INT 0
94203: ST_TO_ADDR
// sSold := false ;
94204: LD_ADDR_EXP 94
94208: PUSH
94209: LD_INT 0
94211: ST_TO_ADDR
// sDiff := false ;
94212: LD_ADDR_EXP 95
94216: PUSH
94217: LD_INT 0
94219: ST_TO_ADDR
// sFog := false ;
94220: LD_ADDR_EXP 98
94224: PUSH
94225: LD_INT 0
94227: ST_TO_ADDR
// sReset := false ;
94228: LD_ADDR_EXP 99
94232: PUSH
94233: LD_INT 0
94235: ST_TO_ADDR
// sSun := false ;
94236: LD_ADDR_EXP 100
94240: PUSH
94241: LD_INT 0
94243: ST_TO_ADDR
// sTiger := false ;
94244: LD_ADDR_EXP 96
94248: PUSH
94249: LD_INT 0
94251: ST_TO_ADDR
// sBomb := false ;
94252: LD_ADDR_EXP 97
94256: PUSH
94257: LD_INT 0
94259: ST_TO_ADDR
// sWound := false ;
94260: LD_ADDR_EXP 105
94264: PUSH
94265: LD_INT 0
94267: ST_TO_ADDR
// sBetray := false ;
94268: LD_ADDR_EXP 109
94272: PUSH
94273: LD_INT 0
94275: ST_TO_ADDR
// sContamin := false ;
94276: LD_ADDR_EXP 110
94280: PUSH
94281: LD_INT 0
94283: ST_TO_ADDR
// sOil := false ;
94284: LD_ADDR_EXP 112
94288: PUSH
94289: LD_INT 0
94291: ST_TO_ADDR
// sStu := false ;
94292: LD_ADDR_EXP 116
94296: PUSH
94297: LD_INT 0
94299: ST_TO_ADDR
// sBazooka := false ;
94300: LD_ADDR_EXP 119
94304: PUSH
94305: LD_INT 0
94307: ST_TO_ADDR
// sMortar := false ;
94308: LD_ADDR_EXP 120
94312: PUSH
94313: LD_INT 0
94315: ST_TO_ADDR
// sRanger := false ;
94316: LD_ADDR_EXP 130
94320: PUSH
94321: LD_INT 0
94323: ST_TO_ADDR
// sComputer := false ;
94324: LD_ADDR_EXP 131
94328: PUSH
94329: LD_INT 0
94331: ST_TO_ADDR
// s30 := false ;
94332: LD_ADDR_EXP 132
94336: PUSH
94337: LD_INT 0
94339: ST_TO_ADDR
// s60 := false ;
94340: LD_ADDR_EXP 133
94344: PUSH
94345: LD_INT 0
94347: ST_TO_ADDR
// end ;
94348: LD_VAR 0 1
94352: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
94353: LD_INT 0
94355: PPUSH
94356: PPUSH
94357: PPUSH
94358: PPUSH
94359: PPUSH
94360: PPUSH
94361: PPUSH
// result := [ ] ;
94362: LD_ADDR_VAR 0 2
94366: PUSH
94367: EMPTY
94368: ST_TO_ADDR
// if campaign_id = 1 then
94369: LD_OWVAR 69
94373: PUSH
94374: LD_INT 1
94376: EQUAL
94377: IFFALSE 97543
// begin case mission_number of 1 :
94379: LD_OWVAR 70
94383: PUSH
94384: LD_INT 1
94386: DOUBLE
94387: EQUAL
94388: IFTRUE 94392
94390: GO 94468
94392: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
94393: LD_ADDR_VAR 0 2
94397: PUSH
94398: LD_INT 2
94400: PUSH
94401: LD_INT 4
94403: PUSH
94404: LD_INT 11
94406: PUSH
94407: LD_INT 12
94409: PUSH
94410: LD_INT 15
94412: PUSH
94413: LD_INT 16
94415: PUSH
94416: LD_INT 22
94418: PUSH
94419: LD_INT 23
94421: PUSH
94422: LD_INT 26
94424: PUSH
94425: EMPTY
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 101
94438: PUSH
94439: LD_INT 102
94441: PUSH
94442: LD_INT 106
94444: PUSH
94445: LD_INT 116
94447: PUSH
94448: LD_INT 117
94450: PUSH
94451: LD_INT 118
94453: PUSH
94454: EMPTY
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: PUSH
94462: EMPTY
94463: LIST
94464: LIST
94465: ST_TO_ADDR
94466: GO 97541
94468: LD_INT 2
94470: DOUBLE
94471: EQUAL
94472: IFTRUE 94476
94474: GO 94560
94476: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
94477: LD_ADDR_VAR 0 2
94481: PUSH
94482: LD_INT 2
94484: PUSH
94485: LD_INT 4
94487: PUSH
94488: LD_INT 11
94490: PUSH
94491: LD_INT 12
94493: PUSH
94494: LD_INT 15
94496: PUSH
94497: LD_INT 16
94499: PUSH
94500: LD_INT 22
94502: PUSH
94503: LD_INT 23
94505: PUSH
94506: LD_INT 26
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: PUSH
94520: LD_INT 101
94522: PUSH
94523: LD_INT 102
94525: PUSH
94526: LD_INT 105
94528: PUSH
94529: LD_INT 106
94531: PUSH
94532: LD_INT 108
94534: PUSH
94535: LD_INT 116
94537: PUSH
94538: LD_INT 117
94540: PUSH
94541: LD_INT 118
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: ST_TO_ADDR
94558: GO 97541
94560: LD_INT 3
94562: DOUBLE
94563: EQUAL
94564: IFTRUE 94568
94566: GO 94656
94568: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94569: LD_ADDR_VAR 0 2
94573: PUSH
94574: LD_INT 2
94576: PUSH
94577: LD_INT 4
94579: PUSH
94580: LD_INT 5
94582: PUSH
94583: LD_INT 11
94585: PUSH
94586: LD_INT 12
94588: PUSH
94589: LD_INT 15
94591: PUSH
94592: LD_INT 16
94594: PUSH
94595: LD_INT 22
94597: PUSH
94598: LD_INT 26
94600: PUSH
94601: LD_INT 36
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 101
94618: PUSH
94619: LD_INT 102
94621: PUSH
94622: LD_INT 105
94624: PUSH
94625: LD_INT 106
94627: PUSH
94628: LD_INT 108
94630: PUSH
94631: LD_INT 116
94633: PUSH
94634: LD_INT 117
94636: PUSH
94637: LD_INT 118
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: ST_TO_ADDR
94654: GO 97541
94656: LD_INT 4
94658: DOUBLE
94659: EQUAL
94660: IFTRUE 94664
94662: GO 94760
94664: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94665: LD_ADDR_VAR 0 2
94669: PUSH
94670: LD_INT 2
94672: PUSH
94673: LD_INT 4
94675: PUSH
94676: LD_INT 5
94678: PUSH
94679: LD_INT 8
94681: PUSH
94682: LD_INT 11
94684: PUSH
94685: LD_INT 12
94687: PUSH
94688: LD_INT 15
94690: PUSH
94691: LD_INT 16
94693: PUSH
94694: LD_INT 22
94696: PUSH
94697: LD_INT 23
94699: PUSH
94700: LD_INT 26
94702: PUSH
94703: LD_INT 36
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 101
94722: PUSH
94723: LD_INT 102
94725: PUSH
94726: LD_INT 105
94728: PUSH
94729: LD_INT 106
94731: PUSH
94732: LD_INT 108
94734: PUSH
94735: LD_INT 116
94737: PUSH
94738: LD_INT 117
94740: PUSH
94741: LD_INT 118
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: ST_TO_ADDR
94758: GO 97541
94760: LD_INT 5
94762: DOUBLE
94763: EQUAL
94764: IFTRUE 94768
94766: GO 94880
94768: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94769: LD_ADDR_VAR 0 2
94773: PUSH
94774: LD_INT 2
94776: PUSH
94777: LD_INT 4
94779: PUSH
94780: LD_INT 5
94782: PUSH
94783: LD_INT 6
94785: PUSH
94786: LD_INT 8
94788: PUSH
94789: LD_INT 11
94791: PUSH
94792: LD_INT 12
94794: PUSH
94795: LD_INT 15
94797: PUSH
94798: LD_INT 16
94800: PUSH
94801: LD_INT 22
94803: PUSH
94804: LD_INT 23
94806: PUSH
94807: LD_INT 25
94809: PUSH
94810: LD_INT 26
94812: PUSH
94813: LD_INT 36
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: PUSH
94832: LD_INT 101
94834: PUSH
94835: LD_INT 102
94837: PUSH
94838: LD_INT 105
94840: PUSH
94841: LD_INT 106
94843: PUSH
94844: LD_INT 108
94846: PUSH
94847: LD_INT 109
94849: PUSH
94850: LD_INT 112
94852: PUSH
94853: LD_INT 116
94855: PUSH
94856: LD_INT 117
94858: PUSH
94859: LD_INT 118
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: ST_TO_ADDR
94878: GO 97541
94880: LD_INT 6
94882: DOUBLE
94883: EQUAL
94884: IFTRUE 94888
94886: GO 95020
94888: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94889: LD_ADDR_VAR 0 2
94893: PUSH
94894: LD_INT 2
94896: PUSH
94897: LD_INT 4
94899: PUSH
94900: LD_INT 5
94902: PUSH
94903: LD_INT 6
94905: PUSH
94906: LD_INT 8
94908: PUSH
94909: LD_INT 11
94911: PUSH
94912: LD_INT 12
94914: PUSH
94915: LD_INT 15
94917: PUSH
94918: LD_INT 16
94920: PUSH
94921: LD_INT 20
94923: PUSH
94924: LD_INT 21
94926: PUSH
94927: LD_INT 22
94929: PUSH
94930: LD_INT 23
94932: PUSH
94933: LD_INT 25
94935: PUSH
94936: LD_INT 26
94938: PUSH
94939: LD_INT 30
94941: PUSH
94942: LD_INT 31
94944: PUSH
94945: LD_INT 32
94947: PUSH
94948: LD_INT 36
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: PUSH
94972: LD_INT 101
94974: PUSH
94975: LD_INT 102
94977: PUSH
94978: LD_INT 105
94980: PUSH
94981: LD_INT 106
94983: PUSH
94984: LD_INT 108
94986: PUSH
94987: LD_INT 109
94989: PUSH
94990: LD_INT 112
94992: PUSH
94993: LD_INT 116
94995: PUSH
94996: LD_INT 117
94998: PUSH
94999: LD_INT 118
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: ST_TO_ADDR
95018: GO 97541
95020: LD_INT 7
95022: DOUBLE
95023: EQUAL
95024: IFTRUE 95028
95026: GO 95140
95028: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95029: LD_ADDR_VAR 0 2
95033: PUSH
95034: LD_INT 2
95036: PUSH
95037: LD_INT 4
95039: PUSH
95040: LD_INT 5
95042: PUSH
95043: LD_INT 7
95045: PUSH
95046: LD_INT 11
95048: PUSH
95049: LD_INT 12
95051: PUSH
95052: LD_INT 15
95054: PUSH
95055: LD_INT 16
95057: PUSH
95058: LD_INT 20
95060: PUSH
95061: LD_INT 21
95063: PUSH
95064: LD_INT 22
95066: PUSH
95067: LD_INT 23
95069: PUSH
95070: LD_INT 25
95072: PUSH
95073: LD_INT 26
95075: PUSH
95076: EMPTY
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 101
95094: PUSH
95095: LD_INT 102
95097: PUSH
95098: LD_INT 103
95100: PUSH
95101: LD_INT 105
95103: PUSH
95104: LD_INT 106
95106: PUSH
95107: LD_INT 108
95109: PUSH
95110: LD_INT 112
95112: PUSH
95113: LD_INT 116
95115: PUSH
95116: LD_INT 117
95118: PUSH
95119: LD_INT 118
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: LIST
95133: PUSH
95134: EMPTY
95135: LIST
95136: LIST
95137: ST_TO_ADDR
95138: GO 97541
95140: LD_INT 8
95142: DOUBLE
95143: EQUAL
95144: IFTRUE 95148
95146: GO 95288
95148: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95149: LD_ADDR_VAR 0 2
95153: PUSH
95154: LD_INT 2
95156: PUSH
95157: LD_INT 4
95159: PUSH
95160: LD_INT 5
95162: PUSH
95163: LD_INT 6
95165: PUSH
95166: LD_INT 7
95168: PUSH
95169: LD_INT 8
95171: PUSH
95172: LD_INT 11
95174: PUSH
95175: LD_INT 12
95177: PUSH
95178: LD_INT 15
95180: PUSH
95181: LD_INT 16
95183: PUSH
95184: LD_INT 20
95186: PUSH
95187: LD_INT 21
95189: PUSH
95190: LD_INT 22
95192: PUSH
95193: LD_INT 23
95195: PUSH
95196: LD_INT 25
95198: PUSH
95199: LD_INT 26
95201: PUSH
95202: LD_INT 30
95204: PUSH
95205: LD_INT 31
95207: PUSH
95208: LD_INT 32
95210: PUSH
95211: LD_INT 36
95213: PUSH
95214: EMPTY
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: PUSH
95236: LD_INT 101
95238: PUSH
95239: LD_INT 102
95241: PUSH
95242: LD_INT 103
95244: PUSH
95245: LD_INT 105
95247: PUSH
95248: LD_INT 106
95250: PUSH
95251: LD_INT 108
95253: PUSH
95254: LD_INT 109
95256: PUSH
95257: LD_INT 112
95259: PUSH
95260: LD_INT 116
95262: PUSH
95263: LD_INT 117
95265: PUSH
95266: LD_INT 118
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: PUSH
95282: EMPTY
95283: LIST
95284: LIST
95285: ST_TO_ADDR
95286: GO 97541
95288: LD_INT 9
95290: DOUBLE
95291: EQUAL
95292: IFTRUE 95296
95294: GO 95444
95296: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
95297: LD_ADDR_VAR 0 2
95301: PUSH
95302: LD_INT 2
95304: PUSH
95305: LD_INT 4
95307: PUSH
95308: LD_INT 5
95310: PUSH
95311: LD_INT 6
95313: PUSH
95314: LD_INT 7
95316: PUSH
95317: LD_INT 8
95319: PUSH
95320: LD_INT 11
95322: PUSH
95323: LD_INT 12
95325: PUSH
95326: LD_INT 15
95328: PUSH
95329: LD_INT 16
95331: PUSH
95332: LD_INT 20
95334: PUSH
95335: LD_INT 21
95337: PUSH
95338: LD_INT 22
95340: PUSH
95341: LD_INT 23
95343: PUSH
95344: LD_INT 25
95346: PUSH
95347: LD_INT 26
95349: PUSH
95350: LD_INT 28
95352: PUSH
95353: LD_INT 30
95355: PUSH
95356: LD_INT 31
95358: PUSH
95359: LD_INT 32
95361: PUSH
95362: LD_INT 36
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: PUSH
95388: LD_INT 101
95390: PUSH
95391: LD_INT 102
95393: PUSH
95394: LD_INT 103
95396: PUSH
95397: LD_INT 105
95399: PUSH
95400: LD_INT 106
95402: PUSH
95403: LD_INT 108
95405: PUSH
95406: LD_INT 109
95408: PUSH
95409: LD_INT 112
95411: PUSH
95412: LD_INT 114
95414: PUSH
95415: LD_INT 116
95417: PUSH
95418: LD_INT 117
95420: PUSH
95421: LD_INT 118
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: ST_TO_ADDR
95442: GO 97541
95444: LD_INT 10
95446: DOUBLE
95447: EQUAL
95448: IFTRUE 95452
95450: GO 95648
95452: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
95453: LD_ADDR_VAR 0 2
95457: PUSH
95458: LD_INT 2
95460: PUSH
95461: LD_INT 4
95463: PUSH
95464: LD_INT 5
95466: PUSH
95467: LD_INT 6
95469: PUSH
95470: LD_INT 7
95472: PUSH
95473: LD_INT 8
95475: PUSH
95476: LD_INT 9
95478: PUSH
95479: LD_INT 10
95481: PUSH
95482: LD_INT 11
95484: PUSH
95485: LD_INT 12
95487: PUSH
95488: LD_INT 13
95490: PUSH
95491: LD_INT 14
95493: PUSH
95494: LD_INT 15
95496: PUSH
95497: LD_INT 16
95499: PUSH
95500: LD_INT 17
95502: PUSH
95503: LD_INT 18
95505: PUSH
95506: LD_INT 19
95508: PUSH
95509: LD_INT 20
95511: PUSH
95512: LD_INT 21
95514: PUSH
95515: LD_INT 22
95517: PUSH
95518: LD_INT 23
95520: PUSH
95521: LD_INT 24
95523: PUSH
95524: LD_INT 25
95526: PUSH
95527: LD_INT 26
95529: PUSH
95530: LD_INT 28
95532: PUSH
95533: LD_INT 30
95535: PUSH
95536: LD_INT 31
95538: PUSH
95539: LD_INT 32
95541: PUSH
95542: LD_INT 36
95544: PUSH
95545: EMPTY
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: PUSH
95576: LD_INT 101
95578: PUSH
95579: LD_INT 102
95581: PUSH
95582: LD_INT 103
95584: PUSH
95585: LD_INT 104
95587: PUSH
95588: LD_INT 105
95590: PUSH
95591: LD_INT 106
95593: PUSH
95594: LD_INT 107
95596: PUSH
95597: LD_INT 108
95599: PUSH
95600: LD_INT 109
95602: PUSH
95603: LD_INT 110
95605: PUSH
95606: LD_INT 111
95608: PUSH
95609: LD_INT 112
95611: PUSH
95612: LD_INT 114
95614: PUSH
95615: LD_INT 116
95617: PUSH
95618: LD_INT 117
95620: PUSH
95621: LD_INT 118
95623: PUSH
95624: EMPTY
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: ST_TO_ADDR
95646: GO 97541
95648: LD_INT 11
95650: DOUBLE
95651: EQUAL
95652: IFTRUE 95656
95654: GO 95860
95656: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95657: LD_ADDR_VAR 0 2
95661: PUSH
95662: LD_INT 2
95664: PUSH
95665: LD_INT 3
95667: PUSH
95668: LD_INT 4
95670: PUSH
95671: LD_INT 5
95673: PUSH
95674: LD_INT 6
95676: PUSH
95677: LD_INT 7
95679: PUSH
95680: LD_INT 8
95682: PUSH
95683: LD_INT 9
95685: PUSH
95686: LD_INT 10
95688: PUSH
95689: LD_INT 11
95691: PUSH
95692: LD_INT 12
95694: PUSH
95695: LD_INT 13
95697: PUSH
95698: LD_INT 14
95700: PUSH
95701: LD_INT 15
95703: PUSH
95704: LD_INT 16
95706: PUSH
95707: LD_INT 17
95709: PUSH
95710: LD_INT 18
95712: PUSH
95713: LD_INT 19
95715: PUSH
95716: LD_INT 20
95718: PUSH
95719: LD_INT 21
95721: PUSH
95722: LD_INT 22
95724: PUSH
95725: LD_INT 23
95727: PUSH
95728: LD_INT 24
95730: PUSH
95731: LD_INT 25
95733: PUSH
95734: LD_INT 26
95736: PUSH
95737: LD_INT 28
95739: PUSH
95740: LD_INT 30
95742: PUSH
95743: LD_INT 31
95745: PUSH
95746: LD_INT 32
95748: PUSH
95749: LD_INT 34
95751: PUSH
95752: LD_INT 36
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: PUSH
95788: LD_INT 101
95790: PUSH
95791: LD_INT 102
95793: PUSH
95794: LD_INT 103
95796: PUSH
95797: LD_INT 104
95799: PUSH
95800: LD_INT 105
95802: PUSH
95803: LD_INT 106
95805: PUSH
95806: LD_INT 107
95808: PUSH
95809: LD_INT 108
95811: PUSH
95812: LD_INT 109
95814: PUSH
95815: LD_INT 110
95817: PUSH
95818: LD_INT 111
95820: PUSH
95821: LD_INT 112
95823: PUSH
95824: LD_INT 114
95826: PUSH
95827: LD_INT 116
95829: PUSH
95830: LD_INT 117
95832: PUSH
95833: LD_INT 118
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: PUSH
95854: EMPTY
95855: LIST
95856: LIST
95857: ST_TO_ADDR
95858: GO 97541
95860: LD_INT 12
95862: DOUBLE
95863: EQUAL
95864: IFTRUE 95868
95866: GO 96088
95868: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95869: LD_ADDR_VAR 0 2
95873: PUSH
95874: LD_INT 1
95876: PUSH
95877: LD_INT 2
95879: PUSH
95880: LD_INT 3
95882: PUSH
95883: LD_INT 4
95885: PUSH
95886: LD_INT 5
95888: PUSH
95889: LD_INT 6
95891: PUSH
95892: LD_INT 7
95894: PUSH
95895: LD_INT 8
95897: PUSH
95898: LD_INT 9
95900: PUSH
95901: LD_INT 10
95903: PUSH
95904: LD_INT 11
95906: PUSH
95907: LD_INT 12
95909: PUSH
95910: LD_INT 13
95912: PUSH
95913: LD_INT 14
95915: PUSH
95916: LD_INT 15
95918: PUSH
95919: LD_INT 16
95921: PUSH
95922: LD_INT 17
95924: PUSH
95925: LD_INT 18
95927: PUSH
95928: LD_INT 19
95930: PUSH
95931: LD_INT 20
95933: PUSH
95934: LD_INT 21
95936: PUSH
95937: LD_INT 22
95939: PUSH
95940: LD_INT 23
95942: PUSH
95943: LD_INT 24
95945: PUSH
95946: LD_INT 25
95948: PUSH
95949: LD_INT 26
95951: PUSH
95952: LD_INT 27
95954: PUSH
95955: LD_INT 28
95957: PUSH
95958: LD_INT 30
95960: PUSH
95961: LD_INT 31
95963: PUSH
95964: LD_INT 32
95966: PUSH
95967: LD_INT 33
95969: PUSH
95970: LD_INT 34
95972: PUSH
95973: LD_INT 36
95975: PUSH
95976: EMPTY
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: LIST
95987: LIST
95988: LIST
95989: LIST
95990: LIST
95991: LIST
95992: LIST
95993: LIST
95994: LIST
95995: LIST
95996: LIST
95997: LIST
95998: LIST
95999: LIST
96000: LIST
96001: LIST
96002: LIST
96003: LIST
96004: LIST
96005: LIST
96006: LIST
96007: LIST
96008: LIST
96009: LIST
96010: LIST
96011: PUSH
96012: LD_INT 101
96014: PUSH
96015: LD_INT 102
96017: PUSH
96018: LD_INT 103
96020: PUSH
96021: LD_INT 104
96023: PUSH
96024: LD_INT 105
96026: PUSH
96027: LD_INT 106
96029: PUSH
96030: LD_INT 107
96032: PUSH
96033: LD_INT 108
96035: PUSH
96036: LD_INT 109
96038: PUSH
96039: LD_INT 110
96041: PUSH
96042: LD_INT 111
96044: PUSH
96045: LD_INT 112
96047: PUSH
96048: LD_INT 113
96050: PUSH
96051: LD_INT 114
96053: PUSH
96054: LD_INT 116
96056: PUSH
96057: LD_INT 117
96059: PUSH
96060: LD_INT 118
96062: PUSH
96063: EMPTY
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: PUSH
96082: EMPTY
96083: LIST
96084: LIST
96085: ST_TO_ADDR
96086: GO 97541
96088: LD_INT 13
96090: DOUBLE
96091: EQUAL
96092: IFTRUE 96096
96094: GO 96304
96096: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96097: LD_ADDR_VAR 0 2
96101: PUSH
96102: LD_INT 1
96104: PUSH
96105: LD_INT 2
96107: PUSH
96108: LD_INT 3
96110: PUSH
96111: LD_INT 4
96113: PUSH
96114: LD_INT 5
96116: PUSH
96117: LD_INT 8
96119: PUSH
96120: LD_INT 9
96122: PUSH
96123: LD_INT 10
96125: PUSH
96126: LD_INT 11
96128: PUSH
96129: LD_INT 12
96131: PUSH
96132: LD_INT 14
96134: PUSH
96135: LD_INT 15
96137: PUSH
96138: LD_INT 16
96140: PUSH
96141: LD_INT 17
96143: PUSH
96144: LD_INT 18
96146: PUSH
96147: LD_INT 19
96149: PUSH
96150: LD_INT 20
96152: PUSH
96153: LD_INT 21
96155: PUSH
96156: LD_INT 22
96158: PUSH
96159: LD_INT 23
96161: PUSH
96162: LD_INT 24
96164: PUSH
96165: LD_INT 25
96167: PUSH
96168: LD_INT 26
96170: PUSH
96171: LD_INT 27
96173: PUSH
96174: LD_INT 28
96176: PUSH
96177: LD_INT 30
96179: PUSH
96180: LD_INT 31
96182: PUSH
96183: LD_INT 32
96185: PUSH
96186: LD_INT 33
96188: PUSH
96189: LD_INT 34
96191: PUSH
96192: LD_INT 36
96194: PUSH
96195: EMPTY
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: LIST
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 101
96230: PUSH
96231: LD_INT 102
96233: PUSH
96234: LD_INT 103
96236: PUSH
96237: LD_INT 104
96239: PUSH
96240: LD_INT 105
96242: PUSH
96243: LD_INT 106
96245: PUSH
96246: LD_INT 107
96248: PUSH
96249: LD_INT 108
96251: PUSH
96252: LD_INT 109
96254: PUSH
96255: LD_INT 110
96257: PUSH
96258: LD_INT 111
96260: PUSH
96261: LD_INT 112
96263: PUSH
96264: LD_INT 113
96266: PUSH
96267: LD_INT 114
96269: PUSH
96270: LD_INT 116
96272: PUSH
96273: LD_INT 117
96275: PUSH
96276: LD_INT 118
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: PUSH
96298: EMPTY
96299: LIST
96300: LIST
96301: ST_TO_ADDR
96302: GO 97541
96304: LD_INT 14
96306: DOUBLE
96307: EQUAL
96308: IFTRUE 96312
96310: GO 96536
96312: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
96313: LD_ADDR_VAR 0 2
96317: PUSH
96318: LD_INT 1
96320: PUSH
96321: LD_INT 2
96323: PUSH
96324: LD_INT 3
96326: PUSH
96327: LD_INT 4
96329: PUSH
96330: LD_INT 5
96332: PUSH
96333: LD_INT 6
96335: PUSH
96336: LD_INT 7
96338: PUSH
96339: LD_INT 8
96341: PUSH
96342: LD_INT 9
96344: PUSH
96345: LD_INT 10
96347: PUSH
96348: LD_INT 11
96350: PUSH
96351: LD_INT 12
96353: PUSH
96354: LD_INT 13
96356: PUSH
96357: LD_INT 14
96359: PUSH
96360: LD_INT 15
96362: PUSH
96363: LD_INT 16
96365: PUSH
96366: LD_INT 17
96368: PUSH
96369: LD_INT 18
96371: PUSH
96372: LD_INT 19
96374: PUSH
96375: LD_INT 20
96377: PUSH
96378: LD_INT 21
96380: PUSH
96381: LD_INT 22
96383: PUSH
96384: LD_INT 23
96386: PUSH
96387: LD_INT 24
96389: PUSH
96390: LD_INT 25
96392: PUSH
96393: LD_INT 26
96395: PUSH
96396: LD_INT 27
96398: PUSH
96399: LD_INT 28
96401: PUSH
96402: LD_INT 29
96404: PUSH
96405: LD_INT 30
96407: PUSH
96408: LD_INT 31
96410: PUSH
96411: LD_INT 32
96413: PUSH
96414: LD_INT 33
96416: PUSH
96417: LD_INT 34
96419: PUSH
96420: LD_INT 36
96422: PUSH
96423: EMPTY
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: PUSH
96460: LD_INT 101
96462: PUSH
96463: LD_INT 102
96465: PUSH
96466: LD_INT 103
96468: PUSH
96469: LD_INT 104
96471: PUSH
96472: LD_INT 105
96474: PUSH
96475: LD_INT 106
96477: PUSH
96478: LD_INT 107
96480: PUSH
96481: LD_INT 108
96483: PUSH
96484: LD_INT 109
96486: PUSH
96487: LD_INT 110
96489: PUSH
96490: LD_INT 111
96492: PUSH
96493: LD_INT 112
96495: PUSH
96496: LD_INT 113
96498: PUSH
96499: LD_INT 114
96501: PUSH
96502: LD_INT 116
96504: PUSH
96505: LD_INT 117
96507: PUSH
96508: LD_INT 118
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: PUSH
96530: EMPTY
96531: LIST
96532: LIST
96533: ST_TO_ADDR
96534: GO 97541
96536: LD_INT 15
96538: DOUBLE
96539: EQUAL
96540: IFTRUE 96544
96542: GO 96768
96544: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96545: LD_ADDR_VAR 0 2
96549: PUSH
96550: LD_INT 1
96552: PUSH
96553: LD_INT 2
96555: PUSH
96556: LD_INT 3
96558: PUSH
96559: LD_INT 4
96561: PUSH
96562: LD_INT 5
96564: PUSH
96565: LD_INT 6
96567: PUSH
96568: LD_INT 7
96570: PUSH
96571: LD_INT 8
96573: PUSH
96574: LD_INT 9
96576: PUSH
96577: LD_INT 10
96579: PUSH
96580: LD_INT 11
96582: PUSH
96583: LD_INT 12
96585: PUSH
96586: LD_INT 13
96588: PUSH
96589: LD_INT 14
96591: PUSH
96592: LD_INT 15
96594: PUSH
96595: LD_INT 16
96597: PUSH
96598: LD_INT 17
96600: PUSH
96601: LD_INT 18
96603: PUSH
96604: LD_INT 19
96606: PUSH
96607: LD_INT 20
96609: PUSH
96610: LD_INT 21
96612: PUSH
96613: LD_INT 22
96615: PUSH
96616: LD_INT 23
96618: PUSH
96619: LD_INT 24
96621: PUSH
96622: LD_INT 25
96624: PUSH
96625: LD_INT 26
96627: PUSH
96628: LD_INT 27
96630: PUSH
96631: LD_INT 28
96633: PUSH
96634: LD_INT 29
96636: PUSH
96637: LD_INT 30
96639: PUSH
96640: LD_INT 31
96642: PUSH
96643: LD_INT 32
96645: PUSH
96646: LD_INT 33
96648: PUSH
96649: LD_INT 34
96651: PUSH
96652: LD_INT 36
96654: PUSH
96655: EMPTY
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: PUSH
96692: LD_INT 101
96694: PUSH
96695: LD_INT 102
96697: PUSH
96698: LD_INT 103
96700: PUSH
96701: LD_INT 104
96703: PUSH
96704: LD_INT 105
96706: PUSH
96707: LD_INT 106
96709: PUSH
96710: LD_INT 107
96712: PUSH
96713: LD_INT 108
96715: PUSH
96716: LD_INT 109
96718: PUSH
96719: LD_INT 110
96721: PUSH
96722: LD_INT 111
96724: PUSH
96725: LD_INT 112
96727: PUSH
96728: LD_INT 113
96730: PUSH
96731: LD_INT 114
96733: PUSH
96734: LD_INT 116
96736: PUSH
96737: LD_INT 117
96739: PUSH
96740: LD_INT 118
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: LIST
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: LIST
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: ST_TO_ADDR
96766: GO 97541
96768: LD_INT 16
96770: DOUBLE
96771: EQUAL
96772: IFTRUE 96776
96774: GO 96912
96776: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96777: LD_ADDR_VAR 0 2
96781: PUSH
96782: LD_INT 2
96784: PUSH
96785: LD_INT 4
96787: PUSH
96788: LD_INT 5
96790: PUSH
96791: LD_INT 7
96793: PUSH
96794: LD_INT 11
96796: PUSH
96797: LD_INT 12
96799: PUSH
96800: LD_INT 15
96802: PUSH
96803: LD_INT 16
96805: PUSH
96806: LD_INT 20
96808: PUSH
96809: LD_INT 21
96811: PUSH
96812: LD_INT 22
96814: PUSH
96815: LD_INT 23
96817: PUSH
96818: LD_INT 25
96820: PUSH
96821: LD_INT 26
96823: PUSH
96824: LD_INT 30
96826: PUSH
96827: LD_INT 31
96829: PUSH
96830: LD_INT 32
96832: PUSH
96833: LD_INT 33
96835: PUSH
96836: LD_INT 34
96838: PUSH
96839: EMPTY
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: PUSH
96860: LD_INT 101
96862: PUSH
96863: LD_INT 102
96865: PUSH
96866: LD_INT 103
96868: PUSH
96869: LD_INT 106
96871: PUSH
96872: LD_INT 108
96874: PUSH
96875: LD_INT 112
96877: PUSH
96878: LD_INT 113
96880: PUSH
96881: LD_INT 114
96883: PUSH
96884: LD_INT 116
96886: PUSH
96887: LD_INT 117
96889: PUSH
96890: LD_INT 118
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: PUSH
96906: EMPTY
96907: LIST
96908: LIST
96909: ST_TO_ADDR
96910: GO 97541
96912: LD_INT 17
96914: DOUBLE
96915: EQUAL
96916: IFTRUE 96920
96918: GO 97144
96920: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96921: LD_ADDR_VAR 0 2
96925: PUSH
96926: LD_INT 1
96928: PUSH
96929: LD_INT 2
96931: PUSH
96932: LD_INT 3
96934: PUSH
96935: LD_INT 4
96937: PUSH
96938: LD_INT 5
96940: PUSH
96941: LD_INT 6
96943: PUSH
96944: LD_INT 7
96946: PUSH
96947: LD_INT 8
96949: PUSH
96950: LD_INT 9
96952: PUSH
96953: LD_INT 10
96955: PUSH
96956: LD_INT 11
96958: PUSH
96959: LD_INT 12
96961: PUSH
96962: LD_INT 13
96964: PUSH
96965: LD_INT 14
96967: PUSH
96968: LD_INT 15
96970: PUSH
96971: LD_INT 16
96973: PUSH
96974: LD_INT 17
96976: PUSH
96977: LD_INT 18
96979: PUSH
96980: LD_INT 19
96982: PUSH
96983: LD_INT 20
96985: PUSH
96986: LD_INT 21
96988: PUSH
96989: LD_INT 22
96991: PUSH
96992: LD_INT 23
96994: PUSH
96995: LD_INT 24
96997: PUSH
96998: LD_INT 25
97000: PUSH
97001: LD_INT 26
97003: PUSH
97004: LD_INT 27
97006: PUSH
97007: LD_INT 28
97009: PUSH
97010: LD_INT 29
97012: PUSH
97013: LD_INT 30
97015: PUSH
97016: LD_INT 31
97018: PUSH
97019: LD_INT 32
97021: PUSH
97022: LD_INT 33
97024: PUSH
97025: LD_INT 34
97027: PUSH
97028: LD_INT 36
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: LIST
97053: LIST
97054: LIST
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: PUSH
97068: LD_INT 101
97070: PUSH
97071: LD_INT 102
97073: PUSH
97074: LD_INT 103
97076: PUSH
97077: LD_INT 104
97079: PUSH
97080: LD_INT 105
97082: PUSH
97083: LD_INT 106
97085: PUSH
97086: LD_INT 107
97088: PUSH
97089: LD_INT 108
97091: PUSH
97092: LD_INT 109
97094: PUSH
97095: LD_INT 110
97097: PUSH
97098: LD_INT 111
97100: PUSH
97101: LD_INT 112
97103: PUSH
97104: LD_INT 113
97106: PUSH
97107: LD_INT 114
97109: PUSH
97110: LD_INT 116
97112: PUSH
97113: LD_INT 117
97115: PUSH
97116: LD_INT 118
97118: PUSH
97119: EMPTY
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: PUSH
97138: EMPTY
97139: LIST
97140: LIST
97141: ST_TO_ADDR
97142: GO 97541
97144: LD_INT 18
97146: DOUBLE
97147: EQUAL
97148: IFTRUE 97152
97150: GO 97300
97152: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97153: LD_ADDR_VAR 0 2
97157: PUSH
97158: LD_INT 2
97160: PUSH
97161: LD_INT 4
97163: PUSH
97164: LD_INT 5
97166: PUSH
97167: LD_INT 7
97169: PUSH
97170: LD_INT 11
97172: PUSH
97173: LD_INT 12
97175: PUSH
97176: LD_INT 15
97178: PUSH
97179: LD_INT 16
97181: PUSH
97182: LD_INT 20
97184: PUSH
97185: LD_INT 21
97187: PUSH
97188: LD_INT 22
97190: PUSH
97191: LD_INT 23
97193: PUSH
97194: LD_INT 25
97196: PUSH
97197: LD_INT 26
97199: PUSH
97200: LD_INT 30
97202: PUSH
97203: LD_INT 31
97205: PUSH
97206: LD_INT 32
97208: PUSH
97209: LD_INT 33
97211: PUSH
97212: LD_INT 34
97214: PUSH
97215: LD_INT 35
97217: PUSH
97218: LD_INT 36
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: LIST
97235: LIST
97236: LIST
97237: LIST
97238: LIST
97239: LIST
97240: LIST
97241: LIST
97242: LIST
97243: PUSH
97244: LD_INT 101
97246: PUSH
97247: LD_INT 102
97249: PUSH
97250: LD_INT 103
97252: PUSH
97253: LD_INT 106
97255: PUSH
97256: LD_INT 108
97258: PUSH
97259: LD_INT 112
97261: PUSH
97262: LD_INT 113
97264: PUSH
97265: LD_INT 114
97267: PUSH
97268: LD_INT 115
97270: PUSH
97271: LD_INT 116
97273: PUSH
97274: LD_INT 117
97276: PUSH
97277: LD_INT 118
97279: PUSH
97280: EMPTY
97281: LIST
97282: LIST
97283: LIST
97284: LIST
97285: LIST
97286: LIST
97287: LIST
97288: LIST
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: ST_TO_ADDR
97298: GO 97541
97300: LD_INT 19
97302: DOUBLE
97303: EQUAL
97304: IFTRUE 97308
97306: GO 97540
97308: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
97309: LD_ADDR_VAR 0 2
97313: PUSH
97314: LD_INT 1
97316: PUSH
97317: LD_INT 2
97319: PUSH
97320: LD_INT 3
97322: PUSH
97323: LD_INT 4
97325: PUSH
97326: LD_INT 5
97328: PUSH
97329: LD_INT 6
97331: PUSH
97332: LD_INT 7
97334: PUSH
97335: LD_INT 8
97337: PUSH
97338: LD_INT 9
97340: PUSH
97341: LD_INT 10
97343: PUSH
97344: LD_INT 11
97346: PUSH
97347: LD_INT 12
97349: PUSH
97350: LD_INT 13
97352: PUSH
97353: LD_INT 14
97355: PUSH
97356: LD_INT 15
97358: PUSH
97359: LD_INT 16
97361: PUSH
97362: LD_INT 17
97364: PUSH
97365: LD_INT 18
97367: PUSH
97368: LD_INT 19
97370: PUSH
97371: LD_INT 20
97373: PUSH
97374: LD_INT 21
97376: PUSH
97377: LD_INT 22
97379: PUSH
97380: LD_INT 23
97382: PUSH
97383: LD_INT 24
97385: PUSH
97386: LD_INT 25
97388: PUSH
97389: LD_INT 26
97391: PUSH
97392: LD_INT 27
97394: PUSH
97395: LD_INT 28
97397: PUSH
97398: LD_INT 29
97400: PUSH
97401: LD_INT 30
97403: PUSH
97404: LD_INT 31
97406: PUSH
97407: LD_INT 32
97409: PUSH
97410: LD_INT 33
97412: PUSH
97413: LD_INT 34
97415: PUSH
97416: LD_INT 35
97418: PUSH
97419: LD_INT 36
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: PUSH
97460: LD_INT 101
97462: PUSH
97463: LD_INT 102
97465: PUSH
97466: LD_INT 103
97468: PUSH
97469: LD_INT 104
97471: PUSH
97472: LD_INT 105
97474: PUSH
97475: LD_INT 106
97477: PUSH
97478: LD_INT 107
97480: PUSH
97481: LD_INT 108
97483: PUSH
97484: LD_INT 109
97486: PUSH
97487: LD_INT 110
97489: PUSH
97490: LD_INT 111
97492: PUSH
97493: LD_INT 112
97495: PUSH
97496: LD_INT 113
97498: PUSH
97499: LD_INT 114
97501: PUSH
97502: LD_INT 115
97504: PUSH
97505: LD_INT 116
97507: PUSH
97508: LD_INT 117
97510: PUSH
97511: LD_INT 118
97513: PUSH
97514: EMPTY
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: LIST
97528: LIST
97529: LIST
97530: LIST
97531: LIST
97532: LIST
97533: PUSH
97534: EMPTY
97535: LIST
97536: LIST
97537: ST_TO_ADDR
97538: GO 97541
97540: POP
// end else
97541: GO 97772
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97543: LD_ADDR_VAR 0 2
97547: PUSH
97548: LD_INT 1
97550: PUSH
97551: LD_INT 2
97553: PUSH
97554: LD_INT 3
97556: PUSH
97557: LD_INT 4
97559: PUSH
97560: LD_INT 5
97562: PUSH
97563: LD_INT 6
97565: PUSH
97566: LD_INT 7
97568: PUSH
97569: LD_INT 8
97571: PUSH
97572: LD_INT 9
97574: PUSH
97575: LD_INT 10
97577: PUSH
97578: LD_INT 11
97580: PUSH
97581: LD_INT 12
97583: PUSH
97584: LD_INT 13
97586: PUSH
97587: LD_INT 14
97589: PUSH
97590: LD_INT 15
97592: PUSH
97593: LD_INT 16
97595: PUSH
97596: LD_INT 17
97598: PUSH
97599: LD_INT 18
97601: PUSH
97602: LD_INT 19
97604: PUSH
97605: LD_INT 20
97607: PUSH
97608: LD_INT 21
97610: PUSH
97611: LD_INT 22
97613: PUSH
97614: LD_INT 23
97616: PUSH
97617: LD_INT 24
97619: PUSH
97620: LD_INT 25
97622: PUSH
97623: LD_INT 26
97625: PUSH
97626: LD_INT 27
97628: PUSH
97629: LD_INT 28
97631: PUSH
97632: LD_INT 29
97634: PUSH
97635: LD_INT 30
97637: PUSH
97638: LD_INT 31
97640: PUSH
97641: LD_INT 32
97643: PUSH
97644: LD_INT 33
97646: PUSH
97647: LD_INT 34
97649: PUSH
97650: LD_INT 35
97652: PUSH
97653: LD_INT 36
97655: PUSH
97656: EMPTY
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: PUSH
97694: LD_INT 101
97696: PUSH
97697: LD_INT 102
97699: PUSH
97700: LD_INT 103
97702: PUSH
97703: LD_INT 104
97705: PUSH
97706: LD_INT 105
97708: PUSH
97709: LD_INT 106
97711: PUSH
97712: LD_INT 107
97714: PUSH
97715: LD_INT 108
97717: PUSH
97718: LD_INT 109
97720: PUSH
97721: LD_INT 110
97723: PUSH
97724: LD_INT 111
97726: PUSH
97727: LD_INT 112
97729: PUSH
97730: LD_INT 113
97732: PUSH
97733: LD_INT 114
97735: PUSH
97736: LD_INT 115
97738: PUSH
97739: LD_INT 116
97741: PUSH
97742: LD_INT 117
97744: PUSH
97745: LD_INT 118
97747: PUSH
97748: EMPTY
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: LIST
97760: LIST
97761: LIST
97762: LIST
97763: LIST
97764: LIST
97765: LIST
97766: LIST
97767: PUSH
97768: EMPTY
97769: LIST
97770: LIST
97771: ST_TO_ADDR
// if result then
97772: LD_VAR 0 2
97776: IFFALSE 98562
// begin normal :=  ;
97778: LD_ADDR_VAR 0 5
97782: PUSH
97783: LD_STRING 
97785: ST_TO_ADDR
// hardcore :=  ;
97786: LD_ADDR_VAR 0 6
97790: PUSH
97791: LD_STRING 
97793: ST_TO_ADDR
// active :=  ;
97794: LD_ADDR_VAR 0 7
97798: PUSH
97799: LD_STRING 
97801: ST_TO_ADDR
// for i = 1 to normalCounter do
97802: LD_ADDR_VAR 0 8
97806: PUSH
97807: DOUBLE
97808: LD_INT 1
97810: DEC
97811: ST_TO_ADDR
97812: LD_EXP 78
97816: PUSH
97817: FOR_TO
97818: IFFALSE 97919
// begin tmp := 0 ;
97820: LD_ADDR_VAR 0 3
97824: PUSH
97825: LD_STRING 0
97827: ST_TO_ADDR
// if result [ 1 ] then
97828: LD_VAR 0 2
97832: PUSH
97833: LD_INT 1
97835: ARRAY
97836: IFFALSE 97901
// if result [ 1 ] [ 1 ] = i then
97838: LD_VAR 0 2
97842: PUSH
97843: LD_INT 1
97845: ARRAY
97846: PUSH
97847: LD_INT 1
97849: ARRAY
97850: PUSH
97851: LD_VAR 0 8
97855: EQUAL
97856: IFFALSE 97901
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97858: LD_ADDR_VAR 0 2
97862: PUSH
97863: LD_VAR 0 2
97867: PPUSH
97868: LD_INT 1
97870: PPUSH
97871: LD_VAR 0 2
97875: PUSH
97876: LD_INT 1
97878: ARRAY
97879: PPUSH
97880: LD_INT 1
97882: PPUSH
97883: CALL_OW 3
97887: PPUSH
97888: CALL_OW 1
97892: ST_TO_ADDR
// tmp := 1 ;
97893: LD_ADDR_VAR 0 3
97897: PUSH
97898: LD_STRING 1
97900: ST_TO_ADDR
// end ; normal := normal & tmp ;
97901: LD_ADDR_VAR 0 5
97905: PUSH
97906: LD_VAR 0 5
97910: PUSH
97911: LD_VAR 0 3
97915: STR
97916: ST_TO_ADDR
// end ;
97917: GO 97817
97919: POP
97920: POP
// for i = 1 to hardcoreCounter do
97921: LD_ADDR_VAR 0 8
97925: PUSH
97926: DOUBLE
97927: LD_INT 1
97929: DEC
97930: ST_TO_ADDR
97931: LD_EXP 79
97935: PUSH
97936: FOR_TO
97937: IFFALSE 98042
// begin tmp := 0 ;
97939: LD_ADDR_VAR 0 3
97943: PUSH
97944: LD_STRING 0
97946: ST_TO_ADDR
// if result [ 2 ] then
97947: LD_VAR 0 2
97951: PUSH
97952: LD_INT 2
97954: ARRAY
97955: IFFALSE 98024
// if result [ 2 ] [ 1 ] = 100 + i then
97957: LD_VAR 0 2
97961: PUSH
97962: LD_INT 2
97964: ARRAY
97965: PUSH
97966: LD_INT 1
97968: ARRAY
97969: PUSH
97970: LD_INT 100
97972: PUSH
97973: LD_VAR 0 8
97977: PLUS
97978: EQUAL
97979: IFFALSE 98024
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97981: LD_ADDR_VAR 0 2
97985: PUSH
97986: LD_VAR 0 2
97990: PPUSH
97991: LD_INT 2
97993: PPUSH
97994: LD_VAR 0 2
97998: PUSH
97999: LD_INT 2
98001: ARRAY
98002: PPUSH
98003: LD_INT 1
98005: PPUSH
98006: CALL_OW 3
98010: PPUSH
98011: CALL_OW 1
98015: ST_TO_ADDR
// tmp := 1 ;
98016: LD_ADDR_VAR 0 3
98020: PUSH
98021: LD_STRING 1
98023: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98024: LD_ADDR_VAR 0 6
98028: PUSH
98029: LD_VAR 0 6
98033: PUSH
98034: LD_VAR 0 3
98038: STR
98039: ST_TO_ADDR
// end ;
98040: GO 97936
98042: POP
98043: POP
// if isGameLoad then
98044: LD_VAR 0 1
98048: IFFALSE 98523
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
98050: LD_ADDR_VAR 0 4
98054: PUSH
98055: LD_EXP 82
98059: PUSH
98060: LD_EXP 81
98064: PUSH
98065: LD_EXP 83
98069: PUSH
98070: LD_EXP 80
98074: PUSH
98075: LD_EXP 84
98079: PUSH
98080: LD_EXP 85
98084: PUSH
98085: LD_EXP 86
98089: PUSH
98090: LD_EXP 87
98094: PUSH
98095: LD_EXP 88
98099: PUSH
98100: LD_EXP 89
98104: PUSH
98105: LD_EXP 90
98109: PUSH
98110: LD_EXP 91
98114: PUSH
98115: LD_EXP 92
98119: PUSH
98120: LD_EXP 93
98124: PUSH
98125: LD_EXP 101
98129: PUSH
98130: LD_EXP 102
98134: PUSH
98135: LD_EXP 103
98139: PUSH
98140: LD_EXP 104
98144: PUSH
98145: LD_EXP 106
98149: PUSH
98150: LD_EXP 107
98154: PUSH
98155: LD_EXP 108
98159: PUSH
98160: LD_EXP 111
98164: PUSH
98165: LD_EXP 113
98169: PUSH
98170: LD_EXP 114
98174: PUSH
98175: LD_EXP 115
98179: PUSH
98180: LD_EXP 117
98184: PUSH
98185: LD_EXP 118
98189: PUSH
98190: LD_EXP 121
98194: PUSH
98195: LD_EXP 122
98199: PUSH
98200: LD_EXP 123
98204: PUSH
98205: LD_EXP 124
98209: PUSH
98210: LD_EXP 125
98214: PUSH
98215: LD_EXP 126
98219: PUSH
98220: LD_EXP 127
98224: PUSH
98225: LD_EXP 128
98229: PUSH
98230: LD_EXP 129
98234: PUSH
98235: LD_EXP 94
98239: PUSH
98240: LD_EXP 95
98244: PUSH
98245: LD_EXP 98
98249: PUSH
98250: LD_EXP 99
98254: PUSH
98255: LD_EXP 100
98259: PUSH
98260: LD_EXP 96
98264: PUSH
98265: LD_EXP 97
98269: PUSH
98270: LD_EXP 105
98274: PUSH
98275: LD_EXP 109
98279: PUSH
98280: LD_EXP 110
98284: PUSH
98285: LD_EXP 112
98289: PUSH
98290: LD_EXP 116
98294: PUSH
98295: LD_EXP 119
98299: PUSH
98300: LD_EXP 120
98304: PUSH
98305: LD_EXP 130
98309: PUSH
98310: LD_EXP 131
98314: PUSH
98315: LD_EXP 132
98319: PUSH
98320: LD_EXP 133
98324: PUSH
98325: EMPTY
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: LIST
98366: LIST
98367: LIST
98368: LIST
98369: LIST
98370: LIST
98371: LIST
98372: LIST
98373: LIST
98374: LIST
98375: LIST
98376: LIST
98377: LIST
98378: LIST
98379: LIST
98380: ST_TO_ADDR
// tmp :=  ;
98381: LD_ADDR_VAR 0 3
98385: PUSH
98386: LD_STRING 
98388: ST_TO_ADDR
// for i = 1 to normalCounter do
98389: LD_ADDR_VAR 0 8
98393: PUSH
98394: DOUBLE
98395: LD_INT 1
98397: DEC
98398: ST_TO_ADDR
98399: LD_EXP 78
98403: PUSH
98404: FOR_TO
98405: IFFALSE 98441
// begin if flags [ i ] then
98407: LD_VAR 0 4
98411: PUSH
98412: LD_VAR 0 8
98416: ARRAY
98417: IFFALSE 98439
// tmp := tmp & i & ; ;
98419: LD_ADDR_VAR 0 3
98423: PUSH
98424: LD_VAR 0 3
98428: PUSH
98429: LD_VAR 0 8
98433: STR
98434: PUSH
98435: LD_STRING ;
98437: STR
98438: ST_TO_ADDR
// end ;
98439: GO 98404
98441: POP
98442: POP
// for i = 1 to hardcoreCounter do
98443: LD_ADDR_VAR 0 8
98447: PUSH
98448: DOUBLE
98449: LD_INT 1
98451: DEC
98452: ST_TO_ADDR
98453: LD_EXP 79
98457: PUSH
98458: FOR_TO
98459: IFFALSE 98505
// begin if flags [ normalCounter + i ] then
98461: LD_VAR 0 4
98465: PUSH
98466: LD_EXP 78
98470: PUSH
98471: LD_VAR 0 8
98475: PLUS
98476: ARRAY
98477: IFFALSE 98503
// tmp := tmp & ( 100 + i ) & ; ;
98479: LD_ADDR_VAR 0 3
98483: PUSH
98484: LD_VAR 0 3
98488: PUSH
98489: LD_INT 100
98491: PUSH
98492: LD_VAR 0 8
98496: PLUS
98497: STR
98498: PUSH
98499: LD_STRING ;
98501: STR
98502: ST_TO_ADDR
// end ;
98503: GO 98458
98505: POP
98506: POP
// if tmp then
98507: LD_VAR 0 3
98511: IFFALSE 98523
// active := tmp ;
98513: LD_ADDR_VAR 0 7
98517: PUSH
98518: LD_VAR 0 3
98522: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
98523: LD_STRING getStreamItemsFromMission("
98525: PUSH
98526: LD_VAR 0 5
98530: STR
98531: PUSH
98532: LD_STRING ","
98534: STR
98535: PUSH
98536: LD_VAR 0 6
98540: STR
98541: PUSH
98542: LD_STRING ","
98544: STR
98545: PUSH
98546: LD_VAR 0 7
98550: STR
98551: PUSH
98552: LD_STRING ")
98554: STR
98555: PPUSH
98556: CALL_OW 559
// end else
98560: GO 98569
// ToLua ( getStreamItemsFromMission("","","") ) ;
98562: LD_STRING getStreamItemsFromMission("","","")
98564: PPUSH
98565: CALL_OW 559
// end ;
98569: LD_VAR 0 2
98573: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98574: LD_EXP 77
98578: PUSH
98579: LD_EXP 82
98583: AND
98584: IFFALSE 98708
98586: GO 98588
98588: DISABLE
98589: LD_INT 0
98591: PPUSH
98592: PPUSH
// begin enable ;
98593: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98594: LD_ADDR_VAR 0 2
98598: PUSH
98599: LD_INT 22
98601: PUSH
98602: LD_OWVAR 2
98606: PUSH
98607: EMPTY
98608: LIST
98609: LIST
98610: PUSH
98611: LD_INT 2
98613: PUSH
98614: LD_INT 34
98616: PUSH
98617: LD_INT 7
98619: PUSH
98620: EMPTY
98621: LIST
98622: LIST
98623: PUSH
98624: LD_INT 34
98626: PUSH
98627: LD_INT 45
98629: PUSH
98630: EMPTY
98631: LIST
98632: LIST
98633: PUSH
98634: LD_INT 34
98636: PUSH
98637: LD_INT 28
98639: PUSH
98640: EMPTY
98641: LIST
98642: LIST
98643: PUSH
98644: LD_INT 34
98646: PUSH
98647: LD_INT 47
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: PUSH
98654: EMPTY
98655: LIST
98656: LIST
98657: LIST
98658: LIST
98659: LIST
98660: PUSH
98661: EMPTY
98662: LIST
98663: LIST
98664: PPUSH
98665: CALL_OW 69
98669: ST_TO_ADDR
// if not tmp then
98670: LD_VAR 0 2
98674: NOT
98675: IFFALSE 98679
// exit ;
98677: GO 98708
// for i in tmp do
98679: LD_ADDR_VAR 0 1
98683: PUSH
98684: LD_VAR 0 2
98688: PUSH
98689: FOR_IN
98690: IFFALSE 98706
// begin SetLives ( i , 0 ) ;
98692: LD_VAR 0 1
98696: PPUSH
98697: LD_INT 0
98699: PPUSH
98700: CALL_OW 234
// end ;
98704: GO 98689
98706: POP
98707: POP
// end ;
98708: PPOPN 2
98710: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98711: LD_EXP 77
98715: PUSH
98716: LD_EXP 83
98720: AND
98721: IFFALSE 98805
98723: GO 98725
98725: DISABLE
98726: LD_INT 0
98728: PPUSH
98729: PPUSH
// begin enable ;
98730: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98731: LD_ADDR_VAR 0 2
98735: PUSH
98736: LD_INT 22
98738: PUSH
98739: LD_OWVAR 2
98743: PUSH
98744: EMPTY
98745: LIST
98746: LIST
98747: PUSH
98748: LD_INT 32
98750: PUSH
98751: LD_INT 3
98753: PUSH
98754: EMPTY
98755: LIST
98756: LIST
98757: PUSH
98758: EMPTY
98759: LIST
98760: LIST
98761: PPUSH
98762: CALL_OW 69
98766: ST_TO_ADDR
// if not tmp then
98767: LD_VAR 0 2
98771: NOT
98772: IFFALSE 98776
// exit ;
98774: GO 98805
// for i in tmp do
98776: LD_ADDR_VAR 0 1
98780: PUSH
98781: LD_VAR 0 2
98785: PUSH
98786: FOR_IN
98787: IFFALSE 98803
// begin SetLives ( i , 0 ) ;
98789: LD_VAR 0 1
98793: PPUSH
98794: LD_INT 0
98796: PPUSH
98797: CALL_OW 234
// end ;
98801: GO 98786
98803: POP
98804: POP
// end ;
98805: PPOPN 2
98807: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98808: LD_EXP 77
98812: PUSH
98813: LD_EXP 80
98817: AND
98818: IFFALSE 98911
98820: GO 98822
98822: DISABLE
98823: LD_INT 0
98825: PPUSH
// begin enable ;
98826: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98827: LD_ADDR_VAR 0 1
98831: PUSH
98832: LD_INT 22
98834: PUSH
98835: LD_OWVAR 2
98839: PUSH
98840: EMPTY
98841: LIST
98842: LIST
98843: PUSH
98844: LD_INT 2
98846: PUSH
98847: LD_INT 25
98849: PUSH
98850: LD_INT 5
98852: PUSH
98853: EMPTY
98854: LIST
98855: LIST
98856: PUSH
98857: LD_INT 25
98859: PUSH
98860: LD_INT 9
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: PUSH
98867: LD_INT 25
98869: PUSH
98870: LD_INT 8
98872: PUSH
98873: EMPTY
98874: LIST
98875: LIST
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: PUSH
98883: EMPTY
98884: LIST
98885: LIST
98886: PPUSH
98887: CALL_OW 69
98891: PUSH
98892: FOR_IN
98893: IFFALSE 98909
// begin SetClass ( i , 1 ) ;
98895: LD_VAR 0 1
98899: PPUSH
98900: LD_INT 1
98902: PPUSH
98903: CALL_OW 336
// end ;
98907: GO 98892
98909: POP
98910: POP
// end ;
98911: PPOPN 1
98913: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98914: LD_EXP 77
98918: PUSH
98919: LD_EXP 81
98923: AND
98924: PUSH
98925: LD_OWVAR 65
98929: PUSH
98930: LD_INT 7
98932: LESS
98933: AND
98934: IFFALSE 98948
98936: GO 98938
98938: DISABLE
// begin enable ;
98939: ENABLE
// game_speed := 7 ;
98940: LD_ADDR_OWVAR 65
98944: PUSH
98945: LD_INT 7
98947: ST_TO_ADDR
// end ;
98948: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98949: LD_EXP 77
98953: PUSH
98954: LD_EXP 84
98958: AND
98959: IFFALSE 99161
98961: GO 98963
98963: DISABLE
98964: LD_INT 0
98966: PPUSH
98967: PPUSH
98968: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98969: LD_ADDR_VAR 0 3
98973: PUSH
98974: LD_INT 81
98976: PUSH
98977: LD_OWVAR 2
98981: PUSH
98982: EMPTY
98983: LIST
98984: LIST
98985: PUSH
98986: LD_INT 21
98988: PUSH
98989: LD_INT 1
98991: PUSH
98992: EMPTY
98993: LIST
98994: LIST
98995: PUSH
98996: EMPTY
98997: LIST
98998: LIST
98999: PPUSH
99000: CALL_OW 69
99004: ST_TO_ADDR
// if not tmp then
99005: LD_VAR 0 3
99009: NOT
99010: IFFALSE 99014
// exit ;
99012: GO 99161
// if tmp > 5 then
99014: LD_VAR 0 3
99018: PUSH
99019: LD_INT 5
99021: GREATER
99022: IFFALSE 99034
// k := 5 else
99024: LD_ADDR_VAR 0 2
99028: PUSH
99029: LD_INT 5
99031: ST_TO_ADDR
99032: GO 99044
// k := tmp ;
99034: LD_ADDR_VAR 0 2
99038: PUSH
99039: LD_VAR 0 3
99043: ST_TO_ADDR
// for i := 1 to k do
99044: LD_ADDR_VAR 0 1
99048: PUSH
99049: DOUBLE
99050: LD_INT 1
99052: DEC
99053: ST_TO_ADDR
99054: LD_VAR 0 2
99058: PUSH
99059: FOR_TO
99060: IFFALSE 99159
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99062: LD_VAR 0 3
99066: PUSH
99067: LD_VAR 0 1
99071: ARRAY
99072: PPUSH
99073: LD_VAR 0 1
99077: PUSH
99078: LD_INT 4
99080: MOD
99081: PUSH
99082: LD_INT 1
99084: PLUS
99085: PPUSH
99086: CALL_OW 259
99090: PUSH
99091: LD_INT 10
99093: LESS
99094: IFFALSE 99157
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99096: LD_VAR 0 3
99100: PUSH
99101: LD_VAR 0 1
99105: ARRAY
99106: PPUSH
99107: LD_VAR 0 1
99111: PUSH
99112: LD_INT 4
99114: MOD
99115: PUSH
99116: LD_INT 1
99118: PLUS
99119: PPUSH
99120: LD_VAR 0 3
99124: PUSH
99125: LD_VAR 0 1
99129: ARRAY
99130: PPUSH
99131: LD_VAR 0 1
99135: PUSH
99136: LD_INT 4
99138: MOD
99139: PUSH
99140: LD_INT 1
99142: PLUS
99143: PPUSH
99144: CALL_OW 259
99148: PUSH
99149: LD_INT 1
99151: PLUS
99152: PPUSH
99153: CALL_OW 237
99157: GO 99059
99159: POP
99160: POP
// end ;
99161: PPOPN 3
99163: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99164: LD_EXP 77
99168: PUSH
99169: LD_EXP 85
99173: AND
99174: IFFALSE 99194
99176: GO 99178
99178: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99179: LD_INT 4
99181: PPUSH
99182: LD_OWVAR 2
99186: PPUSH
99187: LD_INT 0
99189: PPUSH
99190: CALL_OW 324
99194: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99195: LD_EXP 77
99199: PUSH
99200: LD_EXP 114
99204: AND
99205: IFFALSE 99225
99207: GO 99209
99209: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99210: LD_INT 19
99212: PPUSH
99213: LD_OWVAR 2
99217: PPUSH
99218: LD_INT 0
99220: PPUSH
99221: CALL_OW 324
99225: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99226: LD_EXP 77
99230: PUSH
99231: LD_EXP 86
99235: AND
99236: IFFALSE 99338
99238: GO 99240
99240: DISABLE
99241: LD_INT 0
99243: PPUSH
99244: PPUSH
// begin enable ;
99245: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99246: LD_ADDR_VAR 0 2
99250: PUSH
99251: LD_INT 22
99253: PUSH
99254: LD_OWVAR 2
99258: PUSH
99259: EMPTY
99260: LIST
99261: LIST
99262: PUSH
99263: LD_INT 2
99265: PUSH
99266: LD_INT 34
99268: PUSH
99269: LD_INT 11
99271: PUSH
99272: EMPTY
99273: LIST
99274: LIST
99275: PUSH
99276: LD_INT 34
99278: PUSH
99279: LD_INT 30
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: PUSH
99286: EMPTY
99287: LIST
99288: LIST
99289: LIST
99290: PUSH
99291: EMPTY
99292: LIST
99293: LIST
99294: PPUSH
99295: CALL_OW 69
99299: ST_TO_ADDR
// if not tmp then
99300: LD_VAR 0 2
99304: NOT
99305: IFFALSE 99309
// exit ;
99307: GO 99338
// for i in tmp do
99309: LD_ADDR_VAR 0 1
99313: PUSH
99314: LD_VAR 0 2
99318: PUSH
99319: FOR_IN
99320: IFFALSE 99336
// begin SetLives ( i , 0 ) ;
99322: LD_VAR 0 1
99326: PPUSH
99327: LD_INT 0
99329: PPUSH
99330: CALL_OW 234
// end ;
99334: GO 99319
99336: POP
99337: POP
// end ;
99338: PPOPN 2
99340: END
// every 0 0$1 trigger StreamModeActive and sBunker do
99341: LD_EXP 77
99345: PUSH
99346: LD_EXP 87
99350: AND
99351: IFFALSE 99371
99353: GO 99355
99355: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
99356: LD_INT 32
99358: PPUSH
99359: LD_OWVAR 2
99363: PPUSH
99364: LD_INT 0
99366: PPUSH
99367: CALL_OW 324
99371: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
99372: LD_EXP 77
99376: PUSH
99377: LD_EXP 88
99381: AND
99382: IFFALSE 99563
99384: GO 99386
99386: DISABLE
99387: LD_INT 0
99389: PPUSH
99390: PPUSH
99391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99392: LD_ADDR_VAR 0 2
99396: PUSH
99397: LD_INT 22
99399: PUSH
99400: LD_OWVAR 2
99404: PUSH
99405: EMPTY
99406: LIST
99407: LIST
99408: PUSH
99409: LD_INT 33
99411: PUSH
99412: LD_INT 3
99414: PUSH
99415: EMPTY
99416: LIST
99417: LIST
99418: PUSH
99419: EMPTY
99420: LIST
99421: LIST
99422: PPUSH
99423: CALL_OW 69
99427: ST_TO_ADDR
// if not tmp then
99428: LD_VAR 0 2
99432: NOT
99433: IFFALSE 99437
// exit ;
99435: GO 99563
// side := 0 ;
99437: LD_ADDR_VAR 0 3
99441: PUSH
99442: LD_INT 0
99444: ST_TO_ADDR
// for i := 1 to 8 do
99445: LD_ADDR_VAR 0 1
99449: PUSH
99450: DOUBLE
99451: LD_INT 1
99453: DEC
99454: ST_TO_ADDR
99455: LD_INT 8
99457: PUSH
99458: FOR_TO
99459: IFFALSE 99507
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99461: LD_OWVAR 2
99465: PUSH
99466: LD_VAR 0 1
99470: NONEQUAL
99471: PUSH
99472: LD_OWVAR 2
99476: PPUSH
99477: LD_VAR 0 1
99481: PPUSH
99482: CALL_OW 81
99486: PUSH
99487: LD_INT 2
99489: EQUAL
99490: AND
99491: IFFALSE 99505
// begin side := i ;
99493: LD_ADDR_VAR 0 3
99497: PUSH
99498: LD_VAR 0 1
99502: ST_TO_ADDR
// break ;
99503: GO 99507
// end ;
99505: GO 99458
99507: POP
99508: POP
// if not side then
99509: LD_VAR 0 3
99513: NOT
99514: IFFALSE 99518
// exit ;
99516: GO 99563
// for i := 1 to tmp do
99518: LD_ADDR_VAR 0 1
99522: PUSH
99523: DOUBLE
99524: LD_INT 1
99526: DEC
99527: ST_TO_ADDR
99528: LD_VAR 0 2
99532: PUSH
99533: FOR_TO
99534: IFFALSE 99561
// if Prob ( 60 ) then
99536: LD_INT 60
99538: PPUSH
99539: CALL_OW 13
99543: IFFALSE 99559
// SetSide ( i , side ) ;
99545: LD_VAR 0 1
99549: PPUSH
99550: LD_VAR 0 3
99554: PPUSH
99555: CALL_OW 235
99559: GO 99533
99561: POP
99562: POP
// end ;
99563: PPOPN 3
99565: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99566: LD_EXP 77
99570: PUSH
99571: LD_EXP 90
99575: AND
99576: IFFALSE 99695
99578: GO 99580
99580: DISABLE
99581: LD_INT 0
99583: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99584: LD_ADDR_VAR 0 1
99588: PUSH
99589: LD_INT 22
99591: PUSH
99592: LD_OWVAR 2
99596: PUSH
99597: EMPTY
99598: LIST
99599: LIST
99600: PUSH
99601: LD_INT 21
99603: PUSH
99604: LD_INT 1
99606: PUSH
99607: EMPTY
99608: LIST
99609: LIST
99610: PUSH
99611: LD_INT 3
99613: PUSH
99614: LD_INT 23
99616: PUSH
99617: LD_INT 0
99619: PUSH
99620: EMPTY
99621: LIST
99622: LIST
99623: PUSH
99624: EMPTY
99625: LIST
99626: LIST
99627: PUSH
99628: EMPTY
99629: LIST
99630: LIST
99631: LIST
99632: PPUSH
99633: CALL_OW 69
99637: PUSH
99638: FOR_IN
99639: IFFALSE 99693
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99641: LD_VAR 0 1
99645: PPUSH
99646: CALL_OW 257
99650: PUSH
99651: LD_INT 1
99653: PUSH
99654: LD_INT 2
99656: PUSH
99657: LD_INT 3
99659: PUSH
99660: LD_INT 4
99662: PUSH
99663: EMPTY
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: IN
99669: IFFALSE 99691
// SetClass ( un , rand ( 1 , 4 ) ) ;
99671: LD_VAR 0 1
99675: PPUSH
99676: LD_INT 1
99678: PPUSH
99679: LD_INT 4
99681: PPUSH
99682: CALL_OW 12
99686: PPUSH
99687: CALL_OW 336
99691: GO 99638
99693: POP
99694: POP
// end ;
99695: PPOPN 1
99697: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99698: LD_EXP 77
99702: PUSH
99703: LD_EXP 89
99707: AND
99708: IFFALSE 99787
99710: GO 99712
99712: DISABLE
99713: LD_INT 0
99715: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99716: LD_ADDR_VAR 0 1
99720: PUSH
99721: LD_INT 22
99723: PUSH
99724: LD_OWVAR 2
99728: PUSH
99729: EMPTY
99730: LIST
99731: LIST
99732: PUSH
99733: LD_INT 21
99735: PUSH
99736: LD_INT 3
99738: PUSH
99739: EMPTY
99740: LIST
99741: LIST
99742: PUSH
99743: EMPTY
99744: LIST
99745: LIST
99746: PPUSH
99747: CALL_OW 69
99751: ST_TO_ADDR
// if not tmp then
99752: LD_VAR 0 1
99756: NOT
99757: IFFALSE 99761
// exit ;
99759: GO 99787
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99761: LD_VAR 0 1
99765: PUSH
99766: LD_INT 1
99768: PPUSH
99769: LD_VAR 0 1
99773: PPUSH
99774: CALL_OW 12
99778: ARRAY
99779: PPUSH
99780: LD_INT 100
99782: PPUSH
99783: CALL_OW 234
// end ;
99787: PPOPN 1
99789: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99790: LD_EXP 77
99794: PUSH
99795: LD_EXP 91
99799: AND
99800: IFFALSE 99898
99802: GO 99804
99804: DISABLE
99805: LD_INT 0
99807: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99808: LD_ADDR_VAR 0 1
99812: PUSH
99813: LD_INT 22
99815: PUSH
99816: LD_OWVAR 2
99820: PUSH
99821: EMPTY
99822: LIST
99823: LIST
99824: PUSH
99825: LD_INT 21
99827: PUSH
99828: LD_INT 1
99830: PUSH
99831: EMPTY
99832: LIST
99833: LIST
99834: PUSH
99835: EMPTY
99836: LIST
99837: LIST
99838: PPUSH
99839: CALL_OW 69
99843: ST_TO_ADDR
// if not tmp then
99844: LD_VAR 0 1
99848: NOT
99849: IFFALSE 99853
// exit ;
99851: GO 99898
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99853: LD_VAR 0 1
99857: PUSH
99858: LD_INT 1
99860: PPUSH
99861: LD_VAR 0 1
99865: PPUSH
99866: CALL_OW 12
99870: ARRAY
99871: PPUSH
99872: LD_INT 1
99874: PPUSH
99875: LD_INT 4
99877: PPUSH
99878: CALL_OW 12
99882: PPUSH
99883: LD_INT 3000
99885: PPUSH
99886: LD_INT 9000
99888: PPUSH
99889: CALL_OW 12
99893: PPUSH
99894: CALL_OW 492
// end ;
99898: PPOPN 1
99900: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99901: LD_EXP 77
99905: PUSH
99906: LD_EXP 92
99910: AND
99911: IFFALSE 99931
99913: GO 99915
99915: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99916: LD_INT 1
99918: PPUSH
99919: LD_OWVAR 2
99923: PPUSH
99924: LD_INT 0
99926: PPUSH
99927: CALL_OW 324
99931: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99932: LD_EXP 77
99936: PUSH
99937: LD_EXP 93
99941: AND
99942: IFFALSE 100025
99944: GO 99946
99946: DISABLE
99947: LD_INT 0
99949: PPUSH
99950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99951: LD_ADDR_VAR 0 2
99955: PUSH
99956: LD_INT 22
99958: PUSH
99959: LD_OWVAR 2
99963: PUSH
99964: EMPTY
99965: LIST
99966: LIST
99967: PUSH
99968: LD_INT 21
99970: PUSH
99971: LD_INT 3
99973: PUSH
99974: EMPTY
99975: LIST
99976: LIST
99977: PUSH
99978: EMPTY
99979: LIST
99980: LIST
99981: PPUSH
99982: CALL_OW 69
99986: ST_TO_ADDR
// if not tmp then
99987: LD_VAR 0 2
99991: NOT
99992: IFFALSE 99996
// exit ;
99994: GO 100025
// for i in tmp do
99996: LD_ADDR_VAR 0 1
100000: PUSH
100001: LD_VAR 0 2
100005: PUSH
100006: FOR_IN
100007: IFFALSE 100023
// SetBLevel ( i , 10 ) ;
100009: LD_VAR 0 1
100013: PPUSH
100014: LD_INT 10
100016: PPUSH
100017: CALL_OW 241
100021: GO 100006
100023: POP
100024: POP
// end ;
100025: PPOPN 2
100027: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100028: LD_EXP 77
100032: PUSH
100033: LD_EXP 94
100037: AND
100038: IFFALSE 100149
100040: GO 100042
100042: DISABLE
100043: LD_INT 0
100045: PPUSH
100046: PPUSH
100047: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100048: LD_ADDR_VAR 0 3
100052: PUSH
100053: LD_INT 22
100055: PUSH
100056: LD_OWVAR 2
100060: PUSH
100061: EMPTY
100062: LIST
100063: LIST
100064: PUSH
100065: LD_INT 25
100067: PUSH
100068: LD_INT 1
100070: PUSH
100071: EMPTY
100072: LIST
100073: LIST
100074: PUSH
100075: EMPTY
100076: LIST
100077: LIST
100078: PPUSH
100079: CALL_OW 69
100083: ST_TO_ADDR
// if not tmp then
100084: LD_VAR 0 3
100088: NOT
100089: IFFALSE 100093
// exit ;
100091: GO 100149
// un := tmp [ rand ( 1 , tmp ) ] ;
100093: LD_ADDR_VAR 0 2
100097: PUSH
100098: LD_VAR 0 3
100102: PUSH
100103: LD_INT 1
100105: PPUSH
100106: LD_VAR 0 3
100110: PPUSH
100111: CALL_OW 12
100115: ARRAY
100116: ST_TO_ADDR
// if Crawls ( un ) then
100117: LD_VAR 0 2
100121: PPUSH
100122: CALL_OW 318
100126: IFFALSE 100137
// ComWalk ( un ) ;
100128: LD_VAR 0 2
100132: PPUSH
100133: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100137: LD_VAR 0 2
100141: PPUSH
100142: LD_INT 5
100144: PPUSH
100145: CALL_OW 336
// end ;
100149: PPOPN 3
100151: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
100152: LD_EXP 77
100156: PUSH
100157: LD_EXP 95
100161: AND
100162: PUSH
100163: LD_OWVAR 67
100167: PUSH
100168: LD_INT 4
100170: LESS
100171: AND
100172: IFFALSE 100191
100174: GO 100176
100176: DISABLE
// begin Difficulty := Difficulty + 1 ;
100177: LD_ADDR_OWVAR 67
100181: PUSH
100182: LD_OWVAR 67
100186: PUSH
100187: LD_INT 1
100189: PLUS
100190: ST_TO_ADDR
// end ;
100191: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100192: LD_EXP 77
100196: PUSH
100197: LD_EXP 96
100201: AND
100202: IFFALSE 100305
100204: GO 100206
100206: DISABLE
100207: LD_INT 0
100209: PPUSH
// begin for i := 1 to 5 do
100210: LD_ADDR_VAR 0 1
100214: PUSH
100215: DOUBLE
100216: LD_INT 1
100218: DEC
100219: ST_TO_ADDR
100220: LD_INT 5
100222: PUSH
100223: FOR_TO
100224: IFFALSE 100303
// begin uc_nation := nation_nature ;
100226: LD_ADDR_OWVAR 21
100230: PUSH
100231: LD_INT 0
100233: ST_TO_ADDR
// uc_side := 0 ;
100234: LD_ADDR_OWVAR 20
100238: PUSH
100239: LD_INT 0
100241: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100242: LD_ADDR_OWVAR 29
100246: PUSH
100247: LD_INT 12
100249: PUSH
100250: LD_INT 12
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: ST_TO_ADDR
// hc_agressivity := 20 ;
100257: LD_ADDR_OWVAR 35
100261: PUSH
100262: LD_INT 20
100264: ST_TO_ADDR
// hc_class := class_tiger ;
100265: LD_ADDR_OWVAR 28
100269: PUSH
100270: LD_INT 14
100272: ST_TO_ADDR
// hc_gallery :=  ;
100273: LD_ADDR_OWVAR 33
100277: PUSH
100278: LD_STRING 
100280: ST_TO_ADDR
// hc_name :=  ;
100281: LD_ADDR_OWVAR 26
100285: PUSH
100286: LD_STRING 
100288: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100289: CALL_OW 44
100293: PPUSH
100294: LD_INT 0
100296: PPUSH
100297: CALL_OW 51
// end ;
100301: GO 100223
100303: POP
100304: POP
// end ;
100305: PPOPN 1
100307: END
// every 0 0$1 trigger StreamModeActive and sBomb do
100308: LD_EXP 77
100312: PUSH
100313: LD_EXP 97
100317: AND
100318: IFFALSE 100327
100320: GO 100322
100322: DISABLE
// StreamSibBomb ;
100323: CALL 100328 0 0
100327: END
// export function StreamSibBomb ; var i , x , y ; begin
100328: LD_INT 0
100330: PPUSH
100331: PPUSH
100332: PPUSH
100333: PPUSH
// result := false ;
100334: LD_ADDR_VAR 0 1
100338: PUSH
100339: LD_INT 0
100341: ST_TO_ADDR
// for i := 1 to 16 do
100342: LD_ADDR_VAR 0 2
100346: PUSH
100347: DOUBLE
100348: LD_INT 1
100350: DEC
100351: ST_TO_ADDR
100352: LD_INT 16
100354: PUSH
100355: FOR_TO
100356: IFFALSE 100555
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100358: LD_ADDR_VAR 0 3
100362: PUSH
100363: LD_INT 10
100365: PUSH
100366: LD_INT 20
100368: PUSH
100369: LD_INT 30
100371: PUSH
100372: LD_INT 40
100374: PUSH
100375: LD_INT 50
100377: PUSH
100378: LD_INT 60
100380: PUSH
100381: LD_INT 70
100383: PUSH
100384: LD_INT 80
100386: PUSH
100387: LD_INT 90
100389: PUSH
100390: LD_INT 100
100392: PUSH
100393: LD_INT 110
100395: PUSH
100396: LD_INT 120
100398: PUSH
100399: LD_INT 130
100401: PUSH
100402: LD_INT 140
100404: PUSH
100405: LD_INT 150
100407: PUSH
100408: EMPTY
100409: LIST
100410: LIST
100411: LIST
100412: LIST
100413: LIST
100414: LIST
100415: LIST
100416: LIST
100417: LIST
100418: LIST
100419: LIST
100420: LIST
100421: LIST
100422: LIST
100423: LIST
100424: PUSH
100425: LD_INT 1
100427: PPUSH
100428: LD_INT 15
100430: PPUSH
100431: CALL_OW 12
100435: ARRAY
100436: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100437: LD_ADDR_VAR 0 4
100441: PUSH
100442: LD_INT 10
100444: PUSH
100445: LD_INT 20
100447: PUSH
100448: LD_INT 30
100450: PUSH
100451: LD_INT 40
100453: PUSH
100454: LD_INT 50
100456: PUSH
100457: LD_INT 60
100459: PUSH
100460: LD_INT 70
100462: PUSH
100463: LD_INT 80
100465: PUSH
100466: LD_INT 90
100468: PUSH
100469: LD_INT 100
100471: PUSH
100472: LD_INT 110
100474: PUSH
100475: LD_INT 120
100477: PUSH
100478: LD_INT 130
100480: PUSH
100481: LD_INT 140
100483: PUSH
100484: LD_INT 150
100486: PUSH
100487: EMPTY
100488: LIST
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: PUSH
100504: LD_INT 1
100506: PPUSH
100507: LD_INT 15
100509: PPUSH
100510: CALL_OW 12
100514: ARRAY
100515: ST_TO_ADDR
// if ValidHex ( x , y ) then
100516: LD_VAR 0 3
100520: PPUSH
100521: LD_VAR 0 4
100525: PPUSH
100526: CALL_OW 488
100530: IFFALSE 100553
// begin result := [ x , y ] ;
100532: LD_ADDR_VAR 0 1
100536: PUSH
100537: LD_VAR 0 3
100541: PUSH
100542: LD_VAR 0 4
100546: PUSH
100547: EMPTY
100548: LIST
100549: LIST
100550: ST_TO_ADDR
// break ;
100551: GO 100555
// end ; end ;
100553: GO 100355
100555: POP
100556: POP
// if result then
100557: LD_VAR 0 1
100561: IFFALSE 100621
// begin ToLua ( playSibBomb() ) ;
100563: LD_STRING playSibBomb()
100565: PPUSH
100566: CALL_OW 559
// wait ( 0 0$14 ) ;
100570: LD_INT 490
100572: PPUSH
100573: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100577: LD_VAR 0 1
100581: PUSH
100582: LD_INT 1
100584: ARRAY
100585: PPUSH
100586: LD_VAR 0 1
100590: PUSH
100591: LD_INT 2
100593: ARRAY
100594: PPUSH
100595: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100599: LD_VAR 0 1
100603: PUSH
100604: LD_INT 1
100606: ARRAY
100607: PPUSH
100608: LD_VAR 0 1
100612: PUSH
100613: LD_INT 2
100615: ARRAY
100616: PPUSH
100617: CALL_OW 429
// end ; end ;
100621: LD_VAR 0 1
100625: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100626: LD_EXP 77
100630: PUSH
100631: LD_EXP 99
100635: AND
100636: IFFALSE 100648
100638: GO 100640
100640: DISABLE
// YouLost (  ) ;
100641: LD_STRING 
100643: PPUSH
100644: CALL_OW 104
100648: END
// every 0 0$1 trigger StreamModeActive and sFog do
100649: LD_EXP 77
100653: PUSH
100654: LD_EXP 98
100658: AND
100659: IFFALSE 100673
100661: GO 100663
100663: DISABLE
// FogOff ( your_side ) ;
100664: LD_OWVAR 2
100668: PPUSH
100669: CALL_OW 344
100673: END
// every 0 0$1 trigger StreamModeActive and sSun do
100674: LD_EXP 77
100678: PUSH
100679: LD_EXP 100
100683: AND
100684: IFFALSE 100712
100686: GO 100688
100688: DISABLE
// begin solar_recharge_percent := 0 ;
100689: LD_ADDR_OWVAR 79
100693: PUSH
100694: LD_INT 0
100696: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100697: LD_INT 10500
100699: PPUSH
100700: CALL_OW 67
// solar_recharge_percent := 100 ;
100704: LD_ADDR_OWVAR 79
100708: PUSH
100709: LD_INT 100
100711: ST_TO_ADDR
// end ;
100712: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100713: LD_EXP 77
100717: PUSH
100718: LD_EXP 101
100722: AND
100723: IFFALSE 100962
100725: GO 100727
100727: DISABLE
100728: LD_INT 0
100730: PPUSH
100731: PPUSH
100732: PPUSH
// begin tmp := [ ] ;
100733: LD_ADDR_VAR 0 3
100737: PUSH
100738: EMPTY
100739: ST_TO_ADDR
// for i := 1 to 6 do
100740: LD_ADDR_VAR 0 1
100744: PUSH
100745: DOUBLE
100746: LD_INT 1
100748: DEC
100749: ST_TO_ADDR
100750: LD_INT 6
100752: PUSH
100753: FOR_TO
100754: IFFALSE 100859
// begin uc_nation := nation_nature ;
100756: LD_ADDR_OWVAR 21
100760: PUSH
100761: LD_INT 0
100763: ST_TO_ADDR
// uc_side := 0 ;
100764: LD_ADDR_OWVAR 20
100768: PUSH
100769: LD_INT 0
100771: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100772: LD_ADDR_OWVAR 29
100776: PUSH
100777: LD_INT 12
100779: PUSH
100780: LD_INT 12
100782: PUSH
100783: EMPTY
100784: LIST
100785: LIST
100786: ST_TO_ADDR
// hc_agressivity := 20 ;
100787: LD_ADDR_OWVAR 35
100791: PUSH
100792: LD_INT 20
100794: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100795: LD_ADDR_OWVAR 28
100799: PUSH
100800: LD_INT 17
100802: ST_TO_ADDR
// hc_gallery :=  ;
100803: LD_ADDR_OWVAR 33
100807: PUSH
100808: LD_STRING 
100810: ST_TO_ADDR
// hc_name :=  ;
100811: LD_ADDR_OWVAR 26
100815: PUSH
100816: LD_STRING 
100818: ST_TO_ADDR
// un := CreateHuman ;
100819: LD_ADDR_VAR 0 2
100823: PUSH
100824: CALL_OW 44
100828: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100829: LD_VAR 0 2
100833: PPUSH
100834: LD_INT 1
100836: PPUSH
100837: CALL_OW 51
// tmp := tmp ^ un ;
100841: LD_ADDR_VAR 0 3
100845: PUSH
100846: LD_VAR 0 3
100850: PUSH
100851: LD_VAR 0 2
100855: ADD
100856: ST_TO_ADDR
// end ;
100857: GO 100753
100859: POP
100860: POP
// repeat wait ( 0 0$1 ) ;
100861: LD_INT 35
100863: PPUSH
100864: CALL_OW 67
// for un in tmp do
100868: LD_ADDR_VAR 0 2
100872: PUSH
100873: LD_VAR 0 3
100877: PUSH
100878: FOR_IN
100879: IFFALSE 100953
// begin if IsDead ( un ) then
100881: LD_VAR 0 2
100885: PPUSH
100886: CALL_OW 301
100890: IFFALSE 100910
// begin tmp := tmp diff un ;
100892: LD_ADDR_VAR 0 3
100896: PUSH
100897: LD_VAR 0 3
100901: PUSH
100902: LD_VAR 0 2
100906: DIFF
100907: ST_TO_ADDR
// continue ;
100908: GO 100878
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100910: LD_VAR 0 2
100914: PPUSH
100915: LD_INT 3
100917: PUSH
100918: LD_INT 22
100920: PUSH
100921: LD_INT 0
100923: PUSH
100924: EMPTY
100925: LIST
100926: LIST
100927: PUSH
100928: EMPTY
100929: LIST
100930: LIST
100931: PPUSH
100932: CALL_OW 69
100936: PPUSH
100937: LD_VAR 0 2
100941: PPUSH
100942: CALL_OW 74
100946: PPUSH
100947: CALL_OW 115
// end ;
100951: GO 100878
100953: POP
100954: POP
// until not tmp ;
100955: LD_VAR 0 3
100959: NOT
100960: IFFALSE 100861
// end ;
100962: PPOPN 3
100964: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100965: LD_EXP 77
100969: PUSH
100970: LD_EXP 102
100974: AND
100975: IFFALSE 101029
100977: GO 100979
100979: DISABLE
// begin ToLua ( displayTroll(); ) ;
100980: LD_STRING displayTroll();
100982: PPUSH
100983: CALL_OW 559
// wait ( 3 3$00 ) ;
100987: LD_INT 6300
100989: PPUSH
100990: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100994: LD_STRING hideTroll();
100996: PPUSH
100997: CALL_OW 559
// wait ( 1 1$00 ) ;
101001: LD_INT 2100
101003: PPUSH
101004: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101008: LD_STRING displayTroll();
101010: PPUSH
101011: CALL_OW 559
// wait ( 1 1$00 ) ;
101015: LD_INT 2100
101017: PPUSH
101018: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101022: LD_STRING hideTroll();
101024: PPUSH
101025: CALL_OW 559
// end ;
101029: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101030: LD_EXP 77
101034: PUSH
101035: LD_EXP 103
101039: AND
101040: IFFALSE 101103
101042: GO 101044
101044: DISABLE
101045: LD_INT 0
101047: PPUSH
// begin p := 0 ;
101048: LD_ADDR_VAR 0 1
101052: PUSH
101053: LD_INT 0
101055: ST_TO_ADDR
// repeat game_speed := 1 ;
101056: LD_ADDR_OWVAR 65
101060: PUSH
101061: LD_INT 1
101063: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101064: LD_INT 35
101066: PPUSH
101067: CALL_OW 67
// p := p + 1 ;
101071: LD_ADDR_VAR 0 1
101075: PUSH
101076: LD_VAR 0 1
101080: PUSH
101081: LD_INT 1
101083: PLUS
101084: ST_TO_ADDR
// until p >= 60 ;
101085: LD_VAR 0 1
101089: PUSH
101090: LD_INT 60
101092: GREATEREQUAL
101093: IFFALSE 101056
// game_speed := 4 ;
101095: LD_ADDR_OWVAR 65
101099: PUSH
101100: LD_INT 4
101102: ST_TO_ADDR
// end ;
101103: PPOPN 1
101105: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101106: LD_EXP 77
101110: PUSH
101111: LD_EXP 104
101115: AND
101116: IFFALSE 101262
101118: GO 101120
101120: DISABLE
101121: LD_INT 0
101123: PPUSH
101124: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101125: LD_ADDR_VAR 0 1
101129: PUSH
101130: LD_INT 22
101132: PUSH
101133: LD_OWVAR 2
101137: PUSH
101138: EMPTY
101139: LIST
101140: LIST
101141: PUSH
101142: LD_INT 2
101144: PUSH
101145: LD_INT 30
101147: PUSH
101148: LD_INT 0
101150: PUSH
101151: EMPTY
101152: LIST
101153: LIST
101154: PUSH
101155: LD_INT 30
101157: PUSH
101158: LD_INT 1
101160: PUSH
101161: EMPTY
101162: LIST
101163: LIST
101164: PUSH
101165: EMPTY
101166: LIST
101167: LIST
101168: LIST
101169: PUSH
101170: EMPTY
101171: LIST
101172: LIST
101173: PPUSH
101174: CALL_OW 69
101178: ST_TO_ADDR
// if not depot then
101179: LD_VAR 0 1
101183: NOT
101184: IFFALSE 101188
// exit ;
101186: GO 101262
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101188: LD_ADDR_VAR 0 2
101192: PUSH
101193: LD_VAR 0 1
101197: PUSH
101198: LD_INT 1
101200: PPUSH
101201: LD_VAR 0 1
101205: PPUSH
101206: CALL_OW 12
101210: ARRAY
101211: PPUSH
101212: CALL_OW 274
101216: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101217: LD_VAR 0 2
101221: PPUSH
101222: LD_INT 1
101224: PPUSH
101225: LD_INT 0
101227: PPUSH
101228: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101232: LD_VAR 0 2
101236: PPUSH
101237: LD_INT 2
101239: PPUSH
101240: LD_INT 0
101242: PPUSH
101243: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101247: LD_VAR 0 2
101251: PPUSH
101252: LD_INT 3
101254: PPUSH
101255: LD_INT 0
101257: PPUSH
101258: CALL_OW 277
// end ;
101262: PPOPN 2
101264: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101265: LD_EXP 77
101269: PUSH
101270: LD_EXP 105
101274: AND
101275: IFFALSE 101372
101277: GO 101279
101279: DISABLE
101280: LD_INT 0
101282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101283: LD_ADDR_VAR 0 1
101287: PUSH
101288: LD_INT 22
101290: PUSH
101291: LD_OWVAR 2
101295: PUSH
101296: EMPTY
101297: LIST
101298: LIST
101299: PUSH
101300: LD_INT 21
101302: PUSH
101303: LD_INT 1
101305: PUSH
101306: EMPTY
101307: LIST
101308: LIST
101309: PUSH
101310: LD_INT 3
101312: PUSH
101313: LD_INT 23
101315: PUSH
101316: LD_INT 0
101318: PUSH
101319: EMPTY
101320: LIST
101321: LIST
101322: PUSH
101323: EMPTY
101324: LIST
101325: LIST
101326: PUSH
101327: EMPTY
101328: LIST
101329: LIST
101330: LIST
101331: PPUSH
101332: CALL_OW 69
101336: ST_TO_ADDR
// if not tmp then
101337: LD_VAR 0 1
101341: NOT
101342: IFFALSE 101346
// exit ;
101344: GO 101372
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
101346: LD_VAR 0 1
101350: PUSH
101351: LD_INT 1
101353: PPUSH
101354: LD_VAR 0 1
101358: PPUSH
101359: CALL_OW 12
101363: ARRAY
101364: PPUSH
101365: LD_INT 200
101367: PPUSH
101368: CALL_OW 234
// end ;
101372: PPOPN 1
101374: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
101375: LD_EXP 77
101379: PUSH
101380: LD_EXP 106
101384: AND
101385: IFFALSE 101464
101387: GO 101389
101389: DISABLE
101390: LD_INT 0
101392: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101393: LD_ADDR_VAR 0 1
101397: PUSH
101398: LD_INT 22
101400: PUSH
101401: LD_OWVAR 2
101405: PUSH
101406: EMPTY
101407: LIST
101408: LIST
101409: PUSH
101410: LD_INT 21
101412: PUSH
101413: LD_INT 2
101415: PUSH
101416: EMPTY
101417: LIST
101418: LIST
101419: PUSH
101420: EMPTY
101421: LIST
101422: LIST
101423: PPUSH
101424: CALL_OW 69
101428: ST_TO_ADDR
// if not tmp then
101429: LD_VAR 0 1
101433: NOT
101434: IFFALSE 101438
// exit ;
101436: GO 101464
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101438: LD_VAR 0 1
101442: PUSH
101443: LD_INT 1
101445: PPUSH
101446: LD_VAR 0 1
101450: PPUSH
101451: CALL_OW 12
101455: ARRAY
101456: PPUSH
101457: LD_INT 60
101459: PPUSH
101460: CALL_OW 234
// end ;
101464: PPOPN 1
101466: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101467: LD_EXP 77
101471: PUSH
101472: LD_EXP 107
101476: AND
101477: IFFALSE 101576
101479: GO 101481
101481: DISABLE
101482: LD_INT 0
101484: PPUSH
101485: PPUSH
// begin enable ;
101486: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101487: LD_ADDR_VAR 0 1
101491: PUSH
101492: LD_INT 22
101494: PUSH
101495: LD_OWVAR 2
101499: PUSH
101500: EMPTY
101501: LIST
101502: LIST
101503: PUSH
101504: LD_INT 61
101506: PUSH
101507: EMPTY
101508: LIST
101509: PUSH
101510: LD_INT 33
101512: PUSH
101513: LD_INT 2
101515: PUSH
101516: EMPTY
101517: LIST
101518: LIST
101519: PUSH
101520: EMPTY
101521: LIST
101522: LIST
101523: LIST
101524: PPUSH
101525: CALL_OW 69
101529: ST_TO_ADDR
// if not tmp then
101530: LD_VAR 0 1
101534: NOT
101535: IFFALSE 101539
// exit ;
101537: GO 101576
// for i in tmp do
101539: LD_ADDR_VAR 0 2
101543: PUSH
101544: LD_VAR 0 1
101548: PUSH
101549: FOR_IN
101550: IFFALSE 101574
// if IsControledBy ( i ) then
101552: LD_VAR 0 2
101556: PPUSH
101557: CALL_OW 312
101561: IFFALSE 101572
// ComUnlink ( i ) ;
101563: LD_VAR 0 2
101567: PPUSH
101568: CALL_OW 136
101572: GO 101549
101574: POP
101575: POP
// end ;
101576: PPOPN 2
101578: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101579: LD_EXP 77
101583: PUSH
101584: LD_EXP 108
101588: AND
101589: IFFALSE 101729
101591: GO 101593
101593: DISABLE
101594: LD_INT 0
101596: PPUSH
101597: PPUSH
// begin ToLua ( displayPowell(); ) ;
101598: LD_STRING displayPowell();
101600: PPUSH
101601: CALL_OW 559
// uc_side := 0 ;
101605: LD_ADDR_OWVAR 20
101609: PUSH
101610: LD_INT 0
101612: ST_TO_ADDR
// uc_nation := 2 ;
101613: LD_ADDR_OWVAR 21
101617: PUSH
101618: LD_INT 2
101620: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101621: LD_ADDR_OWVAR 37
101625: PUSH
101626: LD_INT 14
101628: ST_TO_ADDR
// vc_engine := engine_siberite ;
101629: LD_ADDR_OWVAR 39
101633: PUSH
101634: LD_INT 3
101636: ST_TO_ADDR
// vc_control := control_apeman ;
101637: LD_ADDR_OWVAR 38
101641: PUSH
101642: LD_INT 5
101644: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101645: LD_ADDR_OWVAR 40
101649: PUSH
101650: LD_INT 29
101652: ST_TO_ADDR
// un := CreateVehicle ;
101653: LD_ADDR_VAR 0 2
101657: PUSH
101658: CALL_OW 45
101662: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101663: LD_VAR 0 2
101667: PPUSH
101668: LD_INT 1
101670: PPUSH
101671: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101675: LD_INT 35
101677: PPUSH
101678: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101682: LD_VAR 0 2
101686: PPUSH
101687: LD_INT 22
101689: PUSH
101690: LD_OWVAR 2
101694: PUSH
101695: EMPTY
101696: LIST
101697: LIST
101698: PPUSH
101699: CALL_OW 69
101703: PPUSH
101704: LD_VAR 0 2
101708: PPUSH
101709: CALL_OW 74
101713: PPUSH
101714: CALL_OW 115
// until IsDead ( un ) ;
101718: LD_VAR 0 2
101722: PPUSH
101723: CALL_OW 301
101727: IFFALSE 101675
// end ;
101729: PPOPN 2
101731: END
// every 0 0$1 trigger StreamModeActive and sStu do
101732: LD_EXP 77
101736: PUSH
101737: LD_EXP 116
101741: AND
101742: IFFALSE 101758
101744: GO 101746
101746: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101747: LD_STRING displayStucuk();
101749: PPUSH
101750: CALL_OW 559
// ResetFog ;
101754: CALL_OW 335
// end ;
101758: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101759: LD_EXP 77
101763: PUSH
101764: LD_EXP 109
101768: AND
101769: IFFALSE 101910
101771: GO 101773
101773: DISABLE
101774: LD_INT 0
101776: PPUSH
101777: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101778: LD_ADDR_VAR 0 2
101782: PUSH
101783: LD_INT 22
101785: PUSH
101786: LD_OWVAR 2
101790: PUSH
101791: EMPTY
101792: LIST
101793: LIST
101794: PUSH
101795: LD_INT 21
101797: PUSH
101798: LD_INT 1
101800: PUSH
101801: EMPTY
101802: LIST
101803: LIST
101804: PUSH
101805: EMPTY
101806: LIST
101807: LIST
101808: PPUSH
101809: CALL_OW 69
101813: ST_TO_ADDR
// if not tmp then
101814: LD_VAR 0 2
101818: NOT
101819: IFFALSE 101823
// exit ;
101821: GO 101910
// un := tmp [ rand ( 1 , tmp ) ] ;
101823: LD_ADDR_VAR 0 1
101827: PUSH
101828: LD_VAR 0 2
101832: PUSH
101833: LD_INT 1
101835: PPUSH
101836: LD_VAR 0 2
101840: PPUSH
101841: CALL_OW 12
101845: ARRAY
101846: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101847: LD_VAR 0 1
101851: PPUSH
101852: LD_INT 0
101854: PPUSH
101855: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101859: LD_VAR 0 1
101863: PPUSH
101864: LD_OWVAR 3
101868: PUSH
101869: LD_VAR 0 1
101873: DIFF
101874: PPUSH
101875: LD_VAR 0 1
101879: PPUSH
101880: CALL_OW 74
101884: PPUSH
101885: CALL_OW 115
// wait ( 0 0$20 ) ;
101889: LD_INT 700
101891: PPUSH
101892: CALL_OW 67
// SetSide ( un , your_side ) ;
101896: LD_VAR 0 1
101900: PPUSH
101901: LD_OWVAR 2
101905: PPUSH
101906: CALL_OW 235
// end ;
101910: PPOPN 2
101912: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101913: LD_EXP 77
101917: PUSH
101918: LD_EXP 110
101922: AND
101923: IFFALSE 102029
101925: GO 101927
101927: DISABLE
101928: LD_INT 0
101930: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101931: LD_ADDR_VAR 0 1
101935: PUSH
101936: LD_INT 22
101938: PUSH
101939: LD_OWVAR 2
101943: PUSH
101944: EMPTY
101945: LIST
101946: LIST
101947: PUSH
101948: LD_INT 2
101950: PUSH
101951: LD_INT 30
101953: PUSH
101954: LD_INT 0
101956: PUSH
101957: EMPTY
101958: LIST
101959: LIST
101960: PUSH
101961: LD_INT 30
101963: PUSH
101964: LD_INT 1
101966: PUSH
101967: EMPTY
101968: LIST
101969: LIST
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: LIST
101975: PUSH
101976: EMPTY
101977: LIST
101978: LIST
101979: PPUSH
101980: CALL_OW 69
101984: ST_TO_ADDR
// if not depot then
101985: LD_VAR 0 1
101989: NOT
101990: IFFALSE 101994
// exit ;
101992: GO 102029
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101994: LD_VAR 0 1
101998: PUSH
101999: LD_INT 1
102001: ARRAY
102002: PPUSH
102003: CALL_OW 250
102007: PPUSH
102008: LD_VAR 0 1
102012: PUSH
102013: LD_INT 1
102015: ARRAY
102016: PPUSH
102017: CALL_OW 251
102021: PPUSH
102022: LD_INT 70
102024: PPUSH
102025: CALL_OW 495
// end ;
102029: PPOPN 1
102031: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102032: LD_EXP 77
102036: PUSH
102037: LD_EXP 111
102041: AND
102042: IFFALSE 102253
102044: GO 102046
102046: DISABLE
102047: LD_INT 0
102049: PPUSH
102050: PPUSH
102051: PPUSH
102052: PPUSH
102053: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102054: LD_ADDR_VAR 0 5
102058: PUSH
102059: LD_INT 22
102061: PUSH
102062: LD_OWVAR 2
102066: PUSH
102067: EMPTY
102068: LIST
102069: LIST
102070: PUSH
102071: LD_INT 21
102073: PUSH
102074: LD_INT 1
102076: PUSH
102077: EMPTY
102078: LIST
102079: LIST
102080: PUSH
102081: EMPTY
102082: LIST
102083: LIST
102084: PPUSH
102085: CALL_OW 69
102089: ST_TO_ADDR
// if not tmp then
102090: LD_VAR 0 5
102094: NOT
102095: IFFALSE 102099
// exit ;
102097: GO 102253
// for i in tmp do
102099: LD_ADDR_VAR 0 1
102103: PUSH
102104: LD_VAR 0 5
102108: PUSH
102109: FOR_IN
102110: IFFALSE 102251
// begin d := rand ( 0 , 5 ) ;
102112: LD_ADDR_VAR 0 4
102116: PUSH
102117: LD_INT 0
102119: PPUSH
102120: LD_INT 5
102122: PPUSH
102123: CALL_OW 12
102127: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102128: LD_ADDR_VAR 0 2
102132: PUSH
102133: LD_VAR 0 1
102137: PPUSH
102138: CALL_OW 250
102142: PPUSH
102143: LD_VAR 0 4
102147: PPUSH
102148: LD_INT 3
102150: PPUSH
102151: LD_INT 12
102153: PPUSH
102154: CALL_OW 12
102158: PPUSH
102159: CALL_OW 272
102163: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102164: LD_ADDR_VAR 0 3
102168: PUSH
102169: LD_VAR 0 1
102173: PPUSH
102174: CALL_OW 251
102178: PPUSH
102179: LD_VAR 0 4
102183: PPUSH
102184: LD_INT 3
102186: PPUSH
102187: LD_INT 12
102189: PPUSH
102190: CALL_OW 12
102194: PPUSH
102195: CALL_OW 273
102199: ST_TO_ADDR
// if ValidHex ( x , y ) then
102200: LD_VAR 0 2
102204: PPUSH
102205: LD_VAR 0 3
102209: PPUSH
102210: CALL_OW 488
102214: IFFALSE 102249
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102216: LD_VAR 0 1
102220: PPUSH
102221: LD_VAR 0 2
102225: PPUSH
102226: LD_VAR 0 3
102230: PPUSH
102231: LD_INT 3
102233: PPUSH
102234: LD_INT 6
102236: PPUSH
102237: CALL_OW 12
102241: PPUSH
102242: LD_INT 1
102244: PPUSH
102245: CALL_OW 483
// end ;
102249: GO 102109
102251: POP
102252: POP
// end ;
102253: PPOPN 5
102255: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102256: LD_EXP 77
102260: PUSH
102261: LD_EXP 112
102265: AND
102266: IFFALSE 102360
102268: GO 102270
102270: DISABLE
102271: LD_INT 0
102273: PPUSH
102274: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102275: LD_ADDR_VAR 0 2
102279: PUSH
102280: LD_INT 22
102282: PUSH
102283: LD_OWVAR 2
102287: PUSH
102288: EMPTY
102289: LIST
102290: LIST
102291: PUSH
102292: LD_INT 32
102294: PUSH
102295: LD_INT 1
102297: PUSH
102298: EMPTY
102299: LIST
102300: LIST
102301: PUSH
102302: LD_INT 21
102304: PUSH
102305: LD_INT 2
102307: PUSH
102308: EMPTY
102309: LIST
102310: LIST
102311: PUSH
102312: EMPTY
102313: LIST
102314: LIST
102315: LIST
102316: PPUSH
102317: CALL_OW 69
102321: ST_TO_ADDR
// if not tmp then
102322: LD_VAR 0 2
102326: NOT
102327: IFFALSE 102331
// exit ;
102329: GO 102360
// for i in tmp do
102331: LD_ADDR_VAR 0 1
102335: PUSH
102336: LD_VAR 0 2
102340: PUSH
102341: FOR_IN
102342: IFFALSE 102358
// SetFuel ( i , 0 ) ;
102344: LD_VAR 0 1
102348: PPUSH
102349: LD_INT 0
102351: PPUSH
102352: CALL_OW 240
102356: GO 102341
102358: POP
102359: POP
// end ;
102360: PPOPN 2
102362: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
102363: LD_EXP 77
102367: PUSH
102368: LD_EXP 113
102372: AND
102373: IFFALSE 102439
102375: GO 102377
102377: DISABLE
102378: LD_INT 0
102380: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102381: LD_ADDR_VAR 0 1
102385: PUSH
102386: LD_INT 22
102388: PUSH
102389: LD_OWVAR 2
102393: PUSH
102394: EMPTY
102395: LIST
102396: LIST
102397: PUSH
102398: LD_INT 30
102400: PUSH
102401: LD_INT 29
102403: PUSH
102404: EMPTY
102405: LIST
102406: LIST
102407: PUSH
102408: EMPTY
102409: LIST
102410: LIST
102411: PPUSH
102412: CALL_OW 69
102416: ST_TO_ADDR
// if not tmp then
102417: LD_VAR 0 1
102421: NOT
102422: IFFALSE 102426
// exit ;
102424: GO 102439
// DestroyUnit ( tmp [ 1 ] ) ;
102426: LD_VAR 0 1
102430: PUSH
102431: LD_INT 1
102433: ARRAY
102434: PPUSH
102435: CALL_OW 65
// end ;
102439: PPOPN 1
102441: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102442: LD_EXP 77
102446: PUSH
102447: LD_EXP 115
102451: AND
102452: IFFALSE 102581
102454: GO 102456
102456: DISABLE
102457: LD_INT 0
102459: PPUSH
// begin uc_side := 0 ;
102460: LD_ADDR_OWVAR 20
102464: PUSH
102465: LD_INT 0
102467: ST_TO_ADDR
// uc_nation := nation_arabian ;
102468: LD_ADDR_OWVAR 21
102472: PUSH
102473: LD_INT 2
102475: ST_TO_ADDR
// hc_gallery :=  ;
102476: LD_ADDR_OWVAR 33
102480: PUSH
102481: LD_STRING 
102483: ST_TO_ADDR
// hc_name :=  ;
102484: LD_ADDR_OWVAR 26
102488: PUSH
102489: LD_STRING 
102491: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102492: LD_INT 1
102494: PPUSH
102495: LD_INT 11
102497: PPUSH
102498: LD_INT 10
102500: PPUSH
102501: CALL_OW 380
// un := CreateHuman ;
102505: LD_ADDR_VAR 0 1
102509: PUSH
102510: CALL_OW 44
102514: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102515: LD_VAR 0 1
102519: PPUSH
102520: LD_INT 1
102522: PPUSH
102523: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102527: LD_INT 35
102529: PPUSH
102530: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102534: LD_VAR 0 1
102538: PPUSH
102539: LD_INT 22
102541: PUSH
102542: LD_OWVAR 2
102546: PUSH
102547: EMPTY
102548: LIST
102549: LIST
102550: PPUSH
102551: CALL_OW 69
102555: PPUSH
102556: LD_VAR 0 1
102560: PPUSH
102561: CALL_OW 74
102565: PPUSH
102566: CALL_OW 115
// until IsDead ( un ) ;
102570: LD_VAR 0 1
102574: PPUSH
102575: CALL_OW 301
102579: IFFALSE 102527
// end ;
102581: PPOPN 1
102583: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102584: LD_EXP 77
102588: PUSH
102589: LD_EXP 117
102593: AND
102594: IFFALSE 102606
102596: GO 102598
102598: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102599: LD_STRING earthquake(getX(game), 0, 32)
102601: PPUSH
102602: CALL_OW 559
102606: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102607: LD_EXP 77
102611: PUSH
102612: LD_EXP 118
102616: AND
102617: IFFALSE 102708
102619: GO 102621
102621: DISABLE
102622: LD_INT 0
102624: PPUSH
// begin enable ;
102625: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102626: LD_ADDR_VAR 0 1
102630: PUSH
102631: LD_INT 22
102633: PUSH
102634: LD_OWVAR 2
102638: PUSH
102639: EMPTY
102640: LIST
102641: LIST
102642: PUSH
102643: LD_INT 21
102645: PUSH
102646: LD_INT 2
102648: PUSH
102649: EMPTY
102650: LIST
102651: LIST
102652: PUSH
102653: LD_INT 33
102655: PUSH
102656: LD_INT 3
102658: PUSH
102659: EMPTY
102660: LIST
102661: LIST
102662: PUSH
102663: EMPTY
102664: LIST
102665: LIST
102666: LIST
102667: PPUSH
102668: CALL_OW 69
102672: ST_TO_ADDR
// if not tmp then
102673: LD_VAR 0 1
102677: NOT
102678: IFFALSE 102682
// exit ;
102680: GO 102708
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102682: LD_VAR 0 1
102686: PUSH
102687: LD_INT 1
102689: PPUSH
102690: LD_VAR 0 1
102694: PPUSH
102695: CALL_OW 12
102699: ARRAY
102700: PPUSH
102701: LD_INT 1
102703: PPUSH
102704: CALL_OW 234
// end ;
102708: PPOPN 1
102710: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102711: LD_EXP 77
102715: PUSH
102716: LD_EXP 119
102720: AND
102721: IFFALSE 102862
102723: GO 102725
102725: DISABLE
102726: LD_INT 0
102728: PPUSH
102729: PPUSH
102730: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102731: LD_ADDR_VAR 0 3
102735: PUSH
102736: LD_INT 22
102738: PUSH
102739: LD_OWVAR 2
102743: PUSH
102744: EMPTY
102745: LIST
102746: LIST
102747: PUSH
102748: LD_INT 25
102750: PUSH
102751: LD_INT 1
102753: PUSH
102754: EMPTY
102755: LIST
102756: LIST
102757: PUSH
102758: EMPTY
102759: LIST
102760: LIST
102761: PPUSH
102762: CALL_OW 69
102766: ST_TO_ADDR
// if not tmp then
102767: LD_VAR 0 3
102771: NOT
102772: IFFALSE 102776
// exit ;
102774: GO 102862
// un := tmp [ rand ( 1 , tmp ) ] ;
102776: LD_ADDR_VAR 0 2
102780: PUSH
102781: LD_VAR 0 3
102785: PUSH
102786: LD_INT 1
102788: PPUSH
102789: LD_VAR 0 3
102793: PPUSH
102794: CALL_OW 12
102798: ARRAY
102799: ST_TO_ADDR
// if Crawls ( un ) then
102800: LD_VAR 0 2
102804: PPUSH
102805: CALL_OW 318
102809: IFFALSE 102820
// ComWalk ( un ) ;
102811: LD_VAR 0 2
102815: PPUSH
102816: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102820: LD_VAR 0 2
102824: PPUSH
102825: LD_INT 9
102827: PPUSH
102828: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102832: LD_INT 28
102834: PPUSH
102835: LD_OWVAR 2
102839: PPUSH
102840: LD_INT 2
102842: PPUSH
102843: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102847: LD_INT 29
102849: PPUSH
102850: LD_OWVAR 2
102854: PPUSH
102855: LD_INT 2
102857: PPUSH
102858: CALL_OW 322
// end ;
102862: PPOPN 3
102864: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102865: LD_EXP 77
102869: PUSH
102870: LD_EXP 120
102874: AND
102875: IFFALSE 102986
102877: GO 102879
102879: DISABLE
102880: LD_INT 0
102882: PPUSH
102883: PPUSH
102884: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102885: LD_ADDR_VAR 0 3
102889: PUSH
102890: LD_INT 22
102892: PUSH
102893: LD_OWVAR 2
102897: PUSH
102898: EMPTY
102899: LIST
102900: LIST
102901: PUSH
102902: LD_INT 25
102904: PUSH
102905: LD_INT 1
102907: PUSH
102908: EMPTY
102909: LIST
102910: LIST
102911: PUSH
102912: EMPTY
102913: LIST
102914: LIST
102915: PPUSH
102916: CALL_OW 69
102920: ST_TO_ADDR
// if not tmp then
102921: LD_VAR 0 3
102925: NOT
102926: IFFALSE 102930
// exit ;
102928: GO 102986
// un := tmp [ rand ( 1 , tmp ) ] ;
102930: LD_ADDR_VAR 0 2
102934: PUSH
102935: LD_VAR 0 3
102939: PUSH
102940: LD_INT 1
102942: PPUSH
102943: LD_VAR 0 3
102947: PPUSH
102948: CALL_OW 12
102952: ARRAY
102953: ST_TO_ADDR
// if Crawls ( un ) then
102954: LD_VAR 0 2
102958: PPUSH
102959: CALL_OW 318
102963: IFFALSE 102974
// ComWalk ( un ) ;
102965: LD_VAR 0 2
102969: PPUSH
102970: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102974: LD_VAR 0 2
102978: PPUSH
102979: LD_INT 8
102981: PPUSH
102982: CALL_OW 336
// end ;
102986: PPOPN 3
102988: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102989: LD_EXP 77
102993: PUSH
102994: LD_EXP 121
102998: AND
102999: IFFALSE 103143
103001: GO 103003
103003: DISABLE
103004: LD_INT 0
103006: PPUSH
103007: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103008: LD_ADDR_VAR 0 2
103012: PUSH
103013: LD_INT 22
103015: PUSH
103016: LD_OWVAR 2
103020: PUSH
103021: EMPTY
103022: LIST
103023: LIST
103024: PUSH
103025: LD_INT 21
103027: PUSH
103028: LD_INT 2
103030: PUSH
103031: EMPTY
103032: LIST
103033: LIST
103034: PUSH
103035: LD_INT 2
103037: PUSH
103038: LD_INT 34
103040: PUSH
103041: LD_INT 12
103043: PUSH
103044: EMPTY
103045: LIST
103046: LIST
103047: PUSH
103048: LD_INT 34
103050: PUSH
103051: LD_INT 51
103053: PUSH
103054: EMPTY
103055: LIST
103056: LIST
103057: PUSH
103058: LD_INT 34
103060: PUSH
103061: LD_INT 32
103063: PUSH
103064: EMPTY
103065: LIST
103066: LIST
103067: PUSH
103068: EMPTY
103069: LIST
103070: LIST
103071: LIST
103072: LIST
103073: PUSH
103074: EMPTY
103075: LIST
103076: LIST
103077: LIST
103078: PPUSH
103079: CALL_OW 69
103083: ST_TO_ADDR
// if not tmp then
103084: LD_VAR 0 2
103088: NOT
103089: IFFALSE 103093
// exit ;
103091: GO 103143
// for i in tmp do
103093: LD_ADDR_VAR 0 1
103097: PUSH
103098: LD_VAR 0 2
103102: PUSH
103103: FOR_IN
103104: IFFALSE 103141
// if GetCargo ( i , mat_artifact ) = 0 then
103106: LD_VAR 0 1
103110: PPUSH
103111: LD_INT 4
103113: PPUSH
103114: CALL_OW 289
103118: PUSH
103119: LD_INT 0
103121: EQUAL
103122: IFFALSE 103139
// SetCargo ( i , mat_siberit , 100 ) ;
103124: LD_VAR 0 1
103128: PPUSH
103129: LD_INT 3
103131: PPUSH
103132: LD_INT 100
103134: PPUSH
103135: CALL_OW 290
103139: GO 103103
103141: POP
103142: POP
// end ;
103143: PPOPN 2
103145: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103146: LD_EXP 77
103150: PUSH
103151: LD_EXP 122
103155: AND
103156: IFFALSE 103339
103158: GO 103160
103160: DISABLE
103161: LD_INT 0
103163: PPUSH
103164: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103165: LD_ADDR_VAR 0 2
103169: PUSH
103170: LD_INT 22
103172: PUSH
103173: LD_OWVAR 2
103177: PUSH
103178: EMPTY
103179: LIST
103180: LIST
103181: PPUSH
103182: CALL_OW 69
103186: ST_TO_ADDR
// if not tmp then
103187: LD_VAR 0 2
103191: NOT
103192: IFFALSE 103196
// exit ;
103194: GO 103339
// for i := 1 to 2 do
103196: LD_ADDR_VAR 0 1
103200: PUSH
103201: DOUBLE
103202: LD_INT 1
103204: DEC
103205: ST_TO_ADDR
103206: LD_INT 2
103208: PUSH
103209: FOR_TO
103210: IFFALSE 103337
// begin uc_side := your_side ;
103212: LD_ADDR_OWVAR 20
103216: PUSH
103217: LD_OWVAR 2
103221: ST_TO_ADDR
// uc_nation := nation_american ;
103222: LD_ADDR_OWVAR 21
103226: PUSH
103227: LD_INT 1
103229: ST_TO_ADDR
// vc_chassis := us_morphling ;
103230: LD_ADDR_OWVAR 37
103234: PUSH
103235: LD_INT 5
103237: ST_TO_ADDR
// vc_engine := engine_siberite ;
103238: LD_ADDR_OWVAR 39
103242: PUSH
103243: LD_INT 3
103245: ST_TO_ADDR
// vc_control := control_computer ;
103246: LD_ADDR_OWVAR 38
103250: PUSH
103251: LD_INT 3
103253: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103254: LD_ADDR_OWVAR 40
103258: PUSH
103259: LD_INT 10
103261: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
103262: LD_VAR 0 2
103266: PUSH
103267: LD_INT 1
103269: ARRAY
103270: PPUSH
103271: CALL_OW 310
103275: NOT
103276: IFFALSE 103323
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
103278: CALL_OW 45
103282: PPUSH
103283: LD_VAR 0 2
103287: PUSH
103288: LD_INT 1
103290: ARRAY
103291: PPUSH
103292: CALL_OW 250
103296: PPUSH
103297: LD_VAR 0 2
103301: PUSH
103302: LD_INT 1
103304: ARRAY
103305: PPUSH
103306: CALL_OW 251
103310: PPUSH
103311: LD_INT 12
103313: PPUSH
103314: LD_INT 1
103316: PPUSH
103317: CALL_OW 50
103321: GO 103335
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
103323: CALL_OW 45
103327: PPUSH
103328: LD_INT 1
103330: PPUSH
103331: CALL_OW 51
// end ;
103335: GO 103209
103337: POP
103338: POP
// end ;
103339: PPOPN 2
103341: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
103342: LD_EXP 77
103346: PUSH
103347: LD_EXP 123
103351: AND
103352: IFFALSE 103574
103354: GO 103356
103356: DISABLE
103357: LD_INT 0
103359: PPUSH
103360: PPUSH
103361: PPUSH
103362: PPUSH
103363: PPUSH
103364: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103365: LD_ADDR_VAR 0 6
103369: PUSH
103370: LD_INT 22
103372: PUSH
103373: LD_OWVAR 2
103377: PUSH
103378: EMPTY
103379: LIST
103380: LIST
103381: PUSH
103382: LD_INT 21
103384: PUSH
103385: LD_INT 1
103387: PUSH
103388: EMPTY
103389: LIST
103390: LIST
103391: PUSH
103392: LD_INT 3
103394: PUSH
103395: LD_INT 23
103397: PUSH
103398: LD_INT 0
103400: PUSH
103401: EMPTY
103402: LIST
103403: LIST
103404: PUSH
103405: EMPTY
103406: LIST
103407: LIST
103408: PUSH
103409: EMPTY
103410: LIST
103411: LIST
103412: LIST
103413: PPUSH
103414: CALL_OW 69
103418: ST_TO_ADDR
// if not tmp then
103419: LD_VAR 0 6
103423: NOT
103424: IFFALSE 103428
// exit ;
103426: GO 103574
// s1 := rand ( 1 , 4 ) ;
103428: LD_ADDR_VAR 0 2
103432: PUSH
103433: LD_INT 1
103435: PPUSH
103436: LD_INT 4
103438: PPUSH
103439: CALL_OW 12
103443: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103444: LD_ADDR_VAR 0 4
103448: PUSH
103449: LD_VAR 0 6
103453: PUSH
103454: LD_INT 1
103456: ARRAY
103457: PPUSH
103458: LD_VAR 0 2
103462: PPUSH
103463: CALL_OW 259
103467: ST_TO_ADDR
// if s1 = 1 then
103468: LD_VAR 0 2
103472: PUSH
103473: LD_INT 1
103475: EQUAL
103476: IFFALSE 103496
// s2 := rand ( 2 , 4 ) else
103478: LD_ADDR_VAR 0 3
103482: PUSH
103483: LD_INT 2
103485: PPUSH
103486: LD_INT 4
103488: PPUSH
103489: CALL_OW 12
103493: ST_TO_ADDR
103494: GO 103504
// s2 := 1 ;
103496: LD_ADDR_VAR 0 3
103500: PUSH
103501: LD_INT 1
103503: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103504: LD_ADDR_VAR 0 5
103508: PUSH
103509: LD_VAR 0 6
103513: PUSH
103514: LD_INT 1
103516: ARRAY
103517: PPUSH
103518: LD_VAR 0 3
103522: PPUSH
103523: CALL_OW 259
103527: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103528: LD_VAR 0 6
103532: PUSH
103533: LD_INT 1
103535: ARRAY
103536: PPUSH
103537: LD_VAR 0 2
103541: PPUSH
103542: LD_VAR 0 5
103546: PPUSH
103547: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103551: LD_VAR 0 6
103555: PUSH
103556: LD_INT 1
103558: ARRAY
103559: PPUSH
103560: LD_VAR 0 3
103564: PPUSH
103565: LD_VAR 0 4
103569: PPUSH
103570: CALL_OW 237
// end ;
103574: PPOPN 6
103576: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103577: LD_EXP 77
103581: PUSH
103582: LD_EXP 124
103586: AND
103587: IFFALSE 103666
103589: GO 103591
103591: DISABLE
103592: LD_INT 0
103594: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103595: LD_ADDR_VAR 0 1
103599: PUSH
103600: LD_INT 22
103602: PUSH
103603: LD_OWVAR 2
103607: PUSH
103608: EMPTY
103609: LIST
103610: LIST
103611: PUSH
103612: LD_INT 30
103614: PUSH
103615: LD_INT 3
103617: PUSH
103618: EMPTY
103619: LIST
103620: LIST
103621: PUSH
103622: EMPTY
103623: LIST
103624: LIST
103625: PPUSH
103626: CALL_OW 69
103630: ST_TO_ADDR
// if not tmp then
103631: LD_VAR 0 1
103635: NOT
103636: IFFALSE 103640
// exit ;
103638: GO 103666
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103640: LD_VAR 0 1
103644: PUSH
103645: LD_INT 1
103647: PPUSH
103648: LD_VAR 0 1
103652: PPUSH
103653: CALL_OW 12
103657: ARRAY
103658: PPUSH
103659: LD_INT 1
103661: PPUSH
103662: CALL_OW 234
// end ;
103666: PPOPN 1
103668: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103669: LD_EXP 77
103673: PUSH
103674: LD_EXP 125
103678: AND
103679: IFFALSE 103791
103681: GO 103683
103683: DISABLE
103684: LD_INT 0
103686: PPUSH
103687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103688: LD_ADDR_VAR 0 2
103692: PUSH
103693: LD_INT 22
103695: PUSH
103696: LD_OWVAR 2
103700: PUSH
103701: EMPTY
103702: LIST
103703: LIST
103704: PUSH
103705: LD_INT 2
103707: PUSH
103708: LD_INT 30
103710: PUSH
103711: LD_INT 27
103713: PUSH
103714: EMPTY
103715: LIST
103716: LIST
103717: PUSH
103718: LD_INT 30
103720: PUSH
103721: LD_INT 26
103723: PUSH
103724: EMPTY
103725: LIST
103726: LIST
103727: PUSH
103728: LD_INT 30
103730: PUSH
103731: LD_INT 28
103733: PUSH
103734: EMPTY
103735: LIST
103736: LIST
103737: PUSH
103738: EMPTY
103739: LIST
103740: LIST
103741: LIST
103742: LIST
103743: PUSH
103744: EMPTY
103745: LIST
103746: LIST
103747: PPUSH
103748: CALL_OW 69
103752: ST_TO_ADDR
// if not tmp then
103753: LD_VAR 0 2
103757: NOT
103758: IFFALSE 103762
// exit ;
103760: GO 103791
// for i in tmp do
103762: LD_ADDR_VAR 0 1
103766: PUSH
103767: LD_VAR 0 2
103771: PUSH
103772: FOR_IN
103773: IFFALSE 103789
// SetLives ( i , 1 ) ;
103775: LD_VAR 0 1
103779: PPUSH
103780: LD_INT 1
103782: PPUSH
103783: CALL_OW 234
103787: GO 103772
103789: POP
103790: POP
// end ;
103791: PPOPN 2
103793: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103794: LD_EXP 77
103798: PUSH
103799: LD_EXP 126
103803: AND
103804: IFFALSE 104091
103806: GO 103808
103808: DISABLE
103809: LD_INT 0
103811: PPUSH
103812: PPUSH
103813: PPUSH
// begin i := rand ( 1 , 7 ) ;
103814: LD_ADDR_VAR 0 1
103818: PUSH
103819: LD_INT 1
103821: PPUSH
103822: LD_INT 7
103824: PPUSH
103825: CALL_OW 12
103829: ST_TO_ADDR
// case i of 1 :
103830: LD_VAR 0 1
103834: PUSH
103835: LD_INT 1
103837: DOUBLE
103838: EQUAL
103839: IFTRUE 103843
103841: GO 103853
103843: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103844: LD_STRING earthquake(getX(game), 0, 32)
103846: PPUSH
103847: CALL_OW 559
103851: GO 104091
103853: LD_INT 2
103855: DOUBLE
103856: EQUAL
103857: IFTRUE 103861
103859: GO 103875
103861: POP
// begin ToLua ( displayStucuk(); ) ;
103862: LD_STRING displayStucuk();
103864: PPUSH
103865: CALL_OW 559
// ResetFog ;
103869: CALL_OW 335
// end ; 3 :
103873: GO 104091
103875: LD_INT 3
103877: DOUBLE
103878: EQUAL
103879: IFTRUE 103883
103881: GO 103987
103883: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103884: LD_ADDR_VAR 0 2
103888: PUSH
103889: LD_INT 22
103891: PUSH
103892: LD_OWVAR 2
103896: PUSH
103897: EMPTY
103898: LIST
103899: LIST
103900: PUSH
103901: LD_INT 25
103903: PUSH
103904: LD_INT 1
103906: PUSH
103907: EMPTY
103908: LIST
103909: LIST
103910: PUSH
103911: EMPTY
103912: LIST
103913: LIST
103914: PPUSH
103915: CALL_OW 69
103919: ST_TO_ADDR
// if not tmp then
103920: LD_VAR 0 2
103924: NOT
103925: IFFALSE 103929
// exit ;
103927: GO 104091
// un := tmp [ rand ( 1 , tmp ) ] ;
103929: LD_ADDR_VAR 0 3
103933: PUSH
103934: LD_VAR 0 2
103938: PUSH
103939: LD_INT 1
103941: PPUSH
103942: LD_VAR 0 2
103946: PPUSH
103947: CALL_OW 12
103951: ARRAY
103952: ST_TO_ADDR
// if Crawls ( un ) then
103953: LD_VAR 0 3
103957: PPUSH
103958: CALL_OW 318
103962: IFFALSE 103973
// ComWalk ( un ) ;
103964: LD_VAR 0 3
103968: PPUSH
103969: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103973: LD_VAR 0 3
103977: PPUSH
103978: LD_INT 8
103980: PPUSH
103981: CALL_OW 336
// end ; 4 :
103985: GO 104091
103987: LD_INT 4
103989: DOUBLE
103990: EQUAL
103991: IFTRUE 103995
103993: GO 104069
103995: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103996: LD_ADDR_VAR 0 2
104000: PUSH
104001: LD_INT 22
104003: PUSH
104004: LD_OWVAR 2
104008: PUSH
104009: EMPTY
104010: LIST
104011: LIST
104012: PUSH
104013: LD_INT 30
104015: PUSH
104016: LD_INT 29
104018: PUSH
104019: EMPTY
104020: LIST
104021: LIST
104022: PUSH
104023: EMPTY
104024: LIST
104025: LIST
104026: PPUSH
104027: CALL_OW 69
104031: ST_TO_ADDR
// if not tmp then
104032: LD_VAR 0 2
104036: NOT
104037: IFFALSE 104041
// exit ;
104039: GO 104091
// CenterNowOnUnits ( tmp [ 1 ] ) ;
104041: LD_VAR 0 2
104045: PUSH
104046: LD_INT 1
104048: ARRAY
104049: PPUSH
104050: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
104054: LD_VAR 0 2
104058: PUSH
104059: LD_INT 1
104061: ARRAY
104062: PPUSH
104063: CALL_OW 65
// end ; 5 .. 7 :
104067: GO 104091
104069: LD_INT 5
104071: DOUBLE
104072: GREATEREQUAL
104073: IFFALSE 104081
104075: LD_INT 7
104077: DOUBLE
104078: LESSEQUAL
104079: IFTRUE 104083
104081: GO 104090
104083: POP
// StreamSibBomb ; end ;
104084: CALL 100328 0 0
104088: GO 104091
104090: POP
// end ;
104091: PPOPN 3
104093: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104094: LD_EXP 77
104098: PUSH
104099: LD_EXP 127
104103: AND
104104: IFFALSE 104260
104106: GO 104108
104108: DISABLE
104109: LD_INT 0
104111: PPUSH
104112: PPUSH
104113: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104114: LD_ADDR_VAR 0 2
104118: PUSH
104119: LD_INT 81
104121: PUSH
104122: LD_OWVAR 2
104126: PUSH
104127: EMPTY
104128: LIST
104129: LIST
104130: PUSH
104131: LD_INT 2
104133: PUSH
104134: LD_INT 21
104136: PUSH
104137: LD_INT 1
104139: PUSH
104140: EMPTY
104141: LIST
104142: LIST
104143: PUSH
104144: LD_INT 21
104146: PUSH
104147: LD_INT 2
104149: PUSH
104150: EMPTY
104151: LIST
104152: LIST
104153: PUSH
104154: EMPTY
104155: LIST
104156: LIST
104157: LIST
104158: PUSH
104159: EMPTY
104160: LIST
104161: LIST
104162: PPUSH
104163: CALL_OW 69
104167: ST_TO_ADDR
// if not tmp then
104168: LD_VAR 0 2
104172: NOT
104173: IFFALSE 104177
// exit ;
104175: GO 104260
// p := 0 ;
104177: LD_ADDR_VAR 0 3
104181: PUSH
104182: LD_INT 0
104184: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104185: LD_INT 35
104187: PPUSH
104188: CALL_OW 67
// p := p + 1 ;
104192: LD_ADDR_VAR 0 3
104196: PUSH
104197: LD_VAR 0 3
104201: PUSH
104202: LD_INT 1
104204: PLUS
104205: ST_TO_ADDR
// for i in tmp do
104206: LD_ADDR_VAR 0 1
104210: PUSH
104211: LD_VAR 0 2
104215: PUSH
104216: FOR_IN
104217: IFFALSE 104248
// if GetLives ( i ) < 1000 then
104219: LD_VAR 0 1
104223: PPUSH
104224: CALL_OW 256
104228: PUSH
104229: LD_INT 1000
104231: LESS
104232: IFFALSE 104246
// SetLives ( i , 1000 ) ;
104234: LD_VAR 0 1
104238: PPUSH
104239: LD_INT 1000
104241: PPUSH
104242: CALL_OW 234
104246: GO 104216
104248: POP
104249: POP
// until p > 20 ;
104250: LD_VAR 0 3
104254: PUSH
104255: LD_INT 20
104257: GREATER
104258: IFFALSE 104185
// end ;
104260: PPOPN 3
104262: END
// every 0 0$1 trigger StreamModeActive and sTime do
104263: LD_EXP 77
104267: PUSH
104268: LD_EXP 128
104272: AND
104273: IFFALSE 104308
104275: GO 104277
104277: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104278: LD_INT 28
104280: PPUSH
104281: LD_OWVAR 2
104285: PPUSH
104286: LD_INT 2
104288: PPUSH
104289: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104293: LD_INT 30
104295: PPUSH
104296: LD_OWVAR 2
104300: PPUSH
104301: LD_INT 2
104303: PPUSH
104304: CALL_OW 322
// end ;
104308: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
104309: LD_EXP 77
104313: PUSH
104314: LD_EXP 129
104318: AND
104319: IFFALSE 104440
104321: GO 104323
104323: DISABLE
104324: LD_INT 0
104326: PPUSH
104327: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104328: LD_ADDR_VAR 0 2
104332: PUSH
104333: LD_INT 22
104335: PUSH
104336: LD_OWVAR 2
104340: PUSH
104341: EMPTY
104342: LIST
104343: LIST
104344: PUSH
104345: LD_INT 21
104347: PUSH
104348: LD_INT 1
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: PUSH
104355: LD_INT 3
104357: PUSH
104358: LD_INT 23
104360: PUSH
104361: LD_INT 0
104363: PUSH
104364: EMPTY
104365: LIST
104366: LIST
104367: PUSH
104368: EMPTY
104369: LIST
104370: LIST
104371: PUSH
104372: EMPTY
104373: LIST
104374: LIST
104375: LIST
104376: PPUSH
104377: CALL_OW 69
104381: ST_TO_ADDR
// if not tmp then
104382: LD_VAR 0 2
104386: NOT
104387: IFFALSE 104391
// exit ;
104389: GO 104440
// for i in tmp do
104391: LD_ADDR_VAR 0 1
104395: PUSH
104396: LD_VAR 0 2
104400: PUSH
104401: FOR_IN
104402: IFFALSE 104438
// begin if Crawls ( i ) then
104404: LD_VAR 0 1
104408: PPUSH
104409: CALL_OW 318
104413: IFFALSE 104424
// ComWalk ( i ) ;
104415: LD_VAR 0 1
104419: PPUSH
104420: CALL_OW 138
// SetClass ( i , 2 ) ;
104424: LD_VAR 0 1
104428: PPUSH
104429: LD_INT 2
104431: PPUSH
104432: CALL_OW 336
// end ;
104436: GO 104401
104438: POP
104439: POP
// end ;
104440: PPOPN 2
104442: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104443: LD_EXP 77
104447: PUSH
104448: LD_EXP 130
104452: AND
104453: IFFALSE 104741
104455: GO 104457
104457: DISABLE
104458: LD_INT 0
104460: PPUSH
104461: PPUSH
104462: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104463: LD_OWVAR 2
104467: PPUSH
104468: LD_INT 9
104470: PPUSH
104471: LD_INT 1
104473: PPUSH
104474: LD_INT 1
104476: PPUSH
104477: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104481: LD_INT 9
104483: PPUSH
104484: LD_OWVAR 2
104488: PPUSH
104489: CALL_OW 343
// uc_side := 9 ;
104493: LD_ADDR_OWVAR 20
104497: PUSH
104498: LD_INT 9
104500: ST_TO_ADDR
// uc_nation := 2 ;
104501: LD_ADDR_OWVAR 21
104505: PUSH
104506: LD_INT 2
104508: ST_TO_ADDR
// hc_name := Dark Warrior ;
104509: LD_ADDR_OWVAR 26
104513: PUSH
104514: LD_STRING Dark Warrior
104516: ST_TO_ADDR
// hc_gallery :=  ;
104517: LD_ADDR_OWVAR 33
104521: PUSH
104522: LD_STRING 
104524: ST_TO_ADDR
// hc_noskilllimit := true ;
104525: LD_ADDR_OWVAR 76
104529: PUSH
104530: LD_INT 1
104532: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104533: LD_ADDR_OWVAR 31
104537: PUSH
104538: LD_INT 30
104540: PUSH
104541: LD_INT 30
104543: PUSH
104544: LD_INT 30
104546: PUSH
104547: LD_INT 30
104549: PUSH
104550: EMPTY
104551: LIST
104552: LIST
104553: LIST
104554: LIST
104555: ST_TO_ADDR
// un := CreateHuman ;
104556: LD_ADDR_VAR 0 3
104560: PUSH
104561: CALL_OW 44
104565: ST_TO_ADDR
// hc_noskilllimit := false ;
104566: LD_ADDR_OWVAR 76
104570: PUSH
104571: LD_INT 0
104573: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104574: LD_VAR 0 3
104578: PPUSH
104579: LD_INT 1
104581: PPUSH
104582: CALL_OW 51
// ToLua ( playRanger() ) ;
104586: LD_STRING playRanger()
104588: PPUSH
104589: CALL_OW 559
// p := 0 ;
104593: LD_ADDR_VAR 0 2
104597: PUSH
104598: LD_INT 0
104600: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104601: LD_INT 35
104603: PPUSH
104604: CALL_OW 67
// p := p + 1 ;
104608: LD_ADDR_VAR 0 2
104612: PUSH
104613: LD_VAR 0 2
104617: PUSH
104618: LD_INT 1
104620: PLUS
104621: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104622: LD_VAR 0 3
104626: PPUSH
104627: CALL_OW 256
104631: PUSH
104632: LD_INT 1000
104634: LESS
104635: IFFALSE 104649
// SetLives ( un , 1000 ) ;
104637: LD_VAR 0 3
104641: PPUSH
104642: LD_INT 1000
104644: PPUSH
104645: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104649: LD_VAR 0 3
104653: PPUSH
104654: LD_INT 81
104656: PUSH
104657: LD_OWVAR 2
104661: PUSH
104662: EMPTY
104663: LIST
104664: LIST
104665: PUSH
104666: LD_INT 91
104668: PUSH
104669: LD_VAR 0 3
104673: PUSH
104674: LD_INT 30
104676: PUSH
104677: EMPTY
104678: LIST
104679: LIST
104680: LIST
104681: PUSH
104682: EMPTY
104683: LIST
104684: LIST
104685: PPUSH
104686: CALL_OW 69
104690: PPUSH
104691: LD_VAR 0 3
104695: PPUSH
104696: CALL_OW 74
104700: PPUSH
104701: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104705: LD_VAR 0 2
104709: PUSH
104710: LD_INT 80
104712: GREATER
104713: PUSH
104714: LD_VAR 0 3
104718: PPUSH
104719: CALL_OW 301
104723: OR
104724: IFFALSE 104601
// if un then
104726: LD_VAR 0 3
104730: IFFALSE 104741
// RemoveUnit ( un ) ;
104732: LD_VAR 0 3
104736: PPUSH
104737: CALL_OW 64
// end ;
104741: PPOPN 3
104743: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104744: LD_EXP 131
104748: IFFALSE 104864
104750: GO 104752
104752: DISABLE
104753: LD_INT 0
104755: PPUSH
104756: PPUSH
104757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104758: LD_ADDR_VAR 0 2
104762: PUSH
104763: LD_INT 81
104765: PUSH
104766: LD_OWVAR 2
104770: PUSH
104771: EMPTY
104772: LIST
104773: LIST
104774: PUSH
104775: LD_INT 21
104777: PUSH
104778: LD_INT 1
104780: PUSH
104781: EMPTY
104782: LIST
104783: LIST
104784: PUSH
104785: EMPTY
104786: LIST
104787: LIST
104788: PPUSH
104789: CALL_OW 69
104793: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104794: LD_STRING playComputer()
104796: PPUSH
104797: CALL_OW 559
// if not tmp then
104801: LD_VAR 0 2
104805: NOT
104806: IFFALSE 104810
// exit ;
104808: GO 104864
// for i in tmp do
104810: LD_ADDR_VAR 0 1
104814: PUSH
104815: LD_VAR 0 2
104819: PUSH
104820: FOR_IN
104821: IFFALSE 104862
// for j := 1 to 4 do
104823: LD_ADDR_VAR 0 3
104827: PUSH
104828: DOUBLE
104829: LD_INT 1
104831: DEC
104832: ST_TO_ADDR
104833: LD_INT 4
104835: PUSH
104836: FOR_TO
104837: IFFALSE 104858
// SetSkill ( i , j , 10 ) ;
104839: LD_VAR 0 1
104843: PPUSH
104844: LD_VAR 0 3
104848: PPUSH
104849: LD_INT 10
104851: PPUSH
104852: CALL_OW 237
104856: GO 104836
104858: POP
104859: POP
104860: GO 104820
104862: POP
104863: POP
// end ;
104864: PPOPN 3
104866: END
// every 0 0$1 trigger s30 do var i , tmp ;
104867: LD_EXP 132
104871: IFFALSE 104940
104873: GO 104875
104875: DISABLE
104876: LD_INT 0
104878: PPUSH
104879: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104880: LD_ADDR_VAR 0 2
104884: PUSH
104885: LD_INT 22
104887: PUSH
104888: LD_OWVAR 2
104892: PUSH
104893: EMPTY
104894: LIST
104895: LIST
104896: PPUSH
104897: CALL_OW 69
104901: ST_TO_ADDR
// if not tmp then
104902: LD_VAR 0 2
104906: NOT
104907: IFFALSE 104911
// exit ;
104909: GO 104940
// for i in tmp do
104911: LD_ADDR_VAR 0 1
104915: PUSH
104916: LD_VAR 0 2
104920: PUSH
104921: FOR_IN
104922: IFFALSE 104938
// SetLives ( i , 300 ) ;
104924: LD_VAR 0 1
104928: PPUSH
104929: LD_INT 300
104931: PPUSH
104932: CALL_OW 234
104936: GO 104921
104938: POP
104939: POP
// end ;
104940: PPOPN 2
104942: END
// every 0 0$1 trigger s60 do var i , tmp ;
104943: LD_EXP 133
104947: IFFALSE 105016
104949: GO 104951
104951: DISABLE
104952: LD_INT 0
104954: PPUSH
104955: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104956: LD_ADDR_VAR 0 2
104960: PUSH
104961: LD_INT 22
104963: PUSH
104964: LD_OWVAR 2
104968: PUSH
104969: EMPTY
104970: LIST
104971: LIST
104972: PPUSH
104973: CALL_OW 69
104977: ST_TO_ADDR
// if not tmp then
104978: LD_VAR 0 2
104982: NOT
104983: IFFALSE 104987
// exit ;
104985: GO 105016
// for i in tmp do
104987: LD_ADDR_VAR 0 1
104991: PUSH
104992: LD_VAR 0 2
104996: PUSH
104997: FOR_IN
104998: IFFALSE 105014
// SetLives ( i , 600 ) ;
105000: LD_VAR 0 1
105004: PPUSH
105005: LD_INT 600
105007: PPUSH
105008: CALL_OW 234
105012: GO 104997
105014: POP
105015: POP
// end ;
105016: PPOPN 2
105018: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105019: LD_INT 0
105021: PPUSH
// case cmd of 301 :
105022: LD_VAR 0 1
105026: PUSH
105027: LD_INT 301
105029: DOUBLE
105030: EQUAL
105031: IFTRUE 105035
105033: GO 105067
105035: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
105036: LD_VAR 0 6
105040: PPUSH
105041: LD_VAR 0 7
105045: PPUSH
105046: LD_VAR 0 8
105050: PPUSH
105051: LD_VAR 0 4
105055: PPUSH
105056: LD_VAR 0 5
105060: PPUSH
105061: CALL 106276 0 5
105065: GO 105188
105067: LD_INT 302
105069: DOUBLE
105070: EQUAL
105071: IFTRUE 105075
105073: GO 105112
105075: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
105076: LD_VAR 0 6
105080: PPUSH
105081: LD_VAR 0 7
105085: PPUSH
105086: LD_VAR 0 8
105090: PPUSH
105091: LD_VAR 0 9
105095: PPUSH
105096: LD_VAR 0 4
105100: PPUSH
105101: LD_VAR 0 5
105105: PPUSH
105106: CALL 106367 0 6
105110: GO 105188
105112: LD_INT 303
105114: DOUBLE
105115: EQUAL
105116: IFTRUE 105120
105118: GO 105157
105120: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
105121: LD_VAR 0 6
105125: PPUSH
105126: LD_VAR 0 7
105130: PPUSH
105131: LD_VAR 0 8
105135: PPUSH
105136: LD_VAR 0 9
105140: PPUSH
105141: LD_VAR 0 4
105145: PPUSH
105146: LD_VAR 0 5
105150: PPUSH
105151: CALL 105193 0 6
105155: GO 105188
105157: LD_INT 304
105159: DOUBLE
105160: EQUAL
105161: IFTRUE 105165
105163: GO 105187
105165: POP
// hHackTeleport ( unit , x , y ) ; end ;
105166: LD_VAR 0 2
105170: PPUSH
105171: LD_VAR 0 4
105175: PPUSH
105176: LD_VAR 0 5
105180: PPUSH
105181: CALL 106960 0 3
105185: GO 105188
105187: POP
// end ;
105188: LD_VAR 0 12
105192: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
105193: LD_INT 0
105195: PPUSH
105196: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
105197: LD_VAR 0 1
105201: PUSH
105202: LD_INT 1
105204: LESS
105205: PUSH
105206: LD_VAR 0 1
105210: PUSH
105211: LD_INT 3
105213: GREATER
105214: OR
105215: PUSH
105216: LD_VAR 0 5
105220: PPUSH
105221: LD_VAR 0 6
105225: PPUSH
105226: CALL_OW 428
105230: OR
105231: IFFALSE 105235
// exit ;
105233: GO 105963
// uc_side := your_side ;
105235: LD_ADDR_OWVAR 20
105239: PUSH
105240: LD_OWVAR 2
105244: ST_TO_ADDR
// uc_nation := nation ;
105245: LD_ADDR_OWVAR 21
105249: PUSH
105250: LD_VAR 0 1
105254: ST_TO_ADDR
// bc_level = 1 ;
105255: LD_ADDR_OWVAR 43
105259: PUSH
105260: LD_INT 1
105262: ST_TO_ADDR
// case btype of 1 :
105263: LD_VAR 0 2
105267: PUSH
105268: LD_INT 1
105270: DOUBLE
105271: EQUAL
105272: IFTRUE 105276
105274: GO 105287
105276: POP
// bc_type := b_depot ; 2 :
105277: LD_ADDR_OWVAR 42
105281: PUSH
105282: LD_INT 0
105284: ST_TO_ADDR
105285: GO 105907
105287: LD_INT 2
105289: DOUBLE
105290: EQUAL
105291: IFTRUE 105295
105293: GO 105306
105295: POP
// bc_type := b_warehouse ; 3 :
105296: LD_ADDR_OWVAR 42
105300: PUSH
105301: LD_INT 1
105303: ST_TO_ADDR
105304: GO 105907
105306: LD_INT 3
105308: DOUBLE
105309: EQUAL
105310: IFTRUE 105314
105312: GO 105325
105314: POP
// bc_type := b_lab ; 4 .. 9 :
105315: LD_ADDR_OWVAR 42
105319: PUSH
105320: LD_INT 6
105322: ST_TO_ADDR
105323: GO 105907
105325: LD_INT 4
105327: DOUBLE
105328: GREATEREQUAL
105329: IFFALSE 105337
105331: LD_INT 9
105333: DOUBLE
105334: LESSEQUAL
105335: IFTRUE 105339
105337: GO 105399
105339: POP
// begin bc_type := b_lab_half ;
105340: LD_ADDR_OWVAR 42
105344: PUSH
105345: LD_INT 7
105347: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
105348: LD_ADDR_OWVAR 44
105352: PUSH
105353: LD_INT 10
105355: PUSH
105356: LD_INT 11
105358: PUSH
105359: LD_INT 12
105361: PUSH
105362: LD_INT 15
105364: PUSH
105365: LD_INT 14
105367: PUSH
105368: LD_INT 13
105370: PUSH
105371: EMPTY
105372: LIST
105373: LIST
105374: LIST
105375: LIST
105376: LIST
105377: LIST
105378: PUSH
105379: LD_VAR 0 2
105383: PUSH
105384: LD_INT 3
105386: MINUS
105387: ARRAY
105388: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
105389: LD_ADDR_OWVAR 45
105393: PUSH
105394: LD_INT 9
105396: ST_TO_ADDR
// end ; 10 .. 13 :
105397: GO 105907
105399: LD_INT 10
105401: DOUBLE
105402: GREATEREQUAL
105403: IFFALSE 105411
105405: LD_INT 13
105407: DOUBLE
105408: LESSEQUAL
105409: IFTRUE 105413
105411: GO 105490
105413: POP
// begin bc_type := b_lab_full ;
105414: LD_ADDR_OWVAR 42
105418: PUSH
105419: LD_INT 8
105421: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105422: LD_ADDR_OWVAR 44
105426: PUSH
105427: LD_INT 10
105429: PUSH
105430: LD_INT 12
105432: PUSH
105433: LD_INT 14
105435: PUSH
105436: LD_INT 13
105438: PUSH
105439: EMPTY
105440: LIST
105441: LIST
105442: LIST
105443: LIST
105444: PUSH
105445: LD_VAR 0 2
105449: PUSH
105450: LD_INT 9
105452: MINUS
105453: ARRAY
105454: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105455: LD_ADDR_OWVAR 45
105459: PUSH
105460: LD_INT 11
105462: PUSH
105463: LD_INT 15
105465: PUSH
105466: LD_INT 12
105468: PUSH
105469: LD_INT 15
105471: PUSH
105472: EMPTY
105473: LIST
105474: LIST
105475: LIST
105476: LIST
105477: PUSH
105478: LD_VAR 0 2
105482: PUSH
105483: LD_INT 9
105485: MINUS
105486: ARRAY
105487: ST_TO_ADDR
// end ; 14 :
105488: GO 105907
105490: LD_INT 14
105492: DOUBLE
105493: EQUAL
105494: IFTRUE 105498
105496: GO 105509
105498: POP
// bc_type := b_workshop ; 15 :
105499: LD_ADDR_OWVAR 42
105503: PUSH
105504: LD_INT 2
105506: ST_TO_ADDR
105507: GO 105907
105509: LD_INT 15
105511: DOUBLE
105512: EQUAL
105513: IFTRUE 105517
105515: GO 105528
105517: POP
// bc_type := b_factory ; 16 :
105518: LD_ADDR_OWVAR 42
105522: PUSH
105523: LD_INT 3
105525: ST_TO_ADDR
105526: GO 105907
105528: LD_INT 16
105530: DOUBLE
105531: EQUAL
105532: IFTRUE 105536
105534: GO 105547
105536: POP
// bc_type := b_ext_gun ; 17 :
105537: LD_ADDR_OWVAR 42
105541: PUSH
105542: LD_INT 17
105544: ST_TO_ADDR
105545: GO 105907
105547: LD_INT 17
105549: DOUBLE
105550: EQUAL
105551: IFTRUE 105555
105553: GO 105583
105555: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105556: LD_ADDR_OWVAR 42
105560: PUSH
105561: LD_INT 19
105563: PUSH
105564: LD_INT 23
105566: PUSH
105567: LD_INT 19
105569: PUSH
105570: EMPTY
105571: LIST
105572: LIST
105573: LIST
105574: PUSH
105575: LD_VAR 0 1
105579: ARRAY
105580: ST_TO_ADDR
105581: GO 105907
105583: LD_INT 18
105585: DOUBLE
105586: EQUAL
105587: IFTRUE 105591
105589: GO 105602
105591: POP
// bc_type := b_ext_radar ; 19 :
105592: LD_ADDR_OWVAR 42
105596: PUSH
105597: LD_INT 20
105599: ST_TO_ADDR
105600: GO 105907
105602: LD_INT 19
105604: DOUBLE
105605: EQUAL
105606: IFTRUE 105610
105608: GO 105621
105610: POP
// bc_type := b_ext_radio ; 20 :
105611: LD_ADDR_OWVAR 42
105615: PUSH
105616: LD_INT 22
105618: ST_TO_ADDR
105619: GO 105907
105621: LD_INT 20
105623: DOUBLE
105624: EQUAL
105625: IFTRUE 105629
105627: GO 105640
105629: POP
// bc_type := b_ext_siberium ; 21 :
105630: LD_ADDR_OWVAR 42
105634: PUSH
105635: LD_INT 21
105637: ST_TO_ADDR
105638: GO 105907
105640: LD_INT 21
105642: DOUBLE
105643: EQUAL
105644: IFTRUE 105648
105646: GO 105659
105648: POP
// bc_type := b_ext_computer ; 22 :
105649: LD_ADDR_OWVAR 42
105653: PUSH
105654: LD_INT 24
105656: ST_TO_ADDR
105657: GO 105907
105659: LD_INT 22
105661: DOUBLE
105662: EQUAL
105663: IFTRUE 105667
105665: GO 105678
105667: POP
// bc_type := b_ext_track ; 23 :
105668: LD_ADDR_OWVAR 42
105672: PUSH
105673: LD_INT 16
105675: ST_TO_ADDR
105676: GO 105907
105678: LD_INT 23
105680: DOUBLE
105681: EQUAL
105682: IFTRUE 105686
105684: GO 105697
105686: POP
// bc_type := b_ext_laser ; 24 :
105687: LD_ADDR_OWVAR 42
105691: PUSH
105692: LD_INT 25
105694: ST_TO_ADDR
105695: GO 105907
105697: LD_INT 24
105699: DOUBLE
105700: EQUAL
105701: IFTRUE 105705
105703: GO 105716
105705: POP
// bc_type := b_control_tower ; 25 :
105706: LD_ADDR_OWVAR 42
105710: PUSH
105711: LD_INT 36
105713: ST_TO_ADDR
105714: GO 105907
105716: LD_INT 25
105718: DOUBLE
105719: EQUAL
105720: IFTRUE 105724
105722: GO 105735
105724: POP
// bc_type := b_breastwork ; 26 :
105725: LD_ADDR_OWVAR 42
105729: PUSH
105730: LD_INT 31
105732: ST_TO_ADDR
105733: GO 105907
105735: LD_INT 26
105737: DOUBLE
105738: EQUAL
105739: IFTRUE 105743
105741: GO 105754
105743: POP
// bc_type := b_bunker ; 27 :
105744: LD_ADDR_OWVAR 42
105748: PUSH
105749: LD_INT 32
105751: ST_TO_ADDR
105752: GO 105907
105754: LD_INT 27
105756: DOUBLE
105757: EQUAL
105758: IFTRUE 105762
105760: GO 105773
105762: POP
// bc_type := b_turret ; 28 :
105763: LD_ADDR_OWVAR 42
105767: PUSH
105768: LD_INT 33
105770: ST_TO_ADDR
105771: GO 105907
105773: LD_INT 28
105775: DOUBLE
105776: EQUAL
105777: IFTRUE 105781
105779: GO 105792
105781: POP
// bc_type := b_armoury ; 29 :
105782: LD_ADDR_OWVAR 42
105786: PUSH
105787: LD_INT 4
105789: ST_TO_ADDR
105790: GO 105907
105792: LD_INT 29
105794: DOUBLE
105795: EQUAL
105796: IFTRUE 105800
105798: GO 105811
105800: POP
// bc_type := b_barracks ; 30 :
105801: LD_ADDR_OWVAR 42
105805: PUSH
105806: LD_INT 5
105808: ST_TO_ADDR
105809: GO 105907
105811: LD_INT 30
105813: DOUBLE
105814: EQUAL
105815: IFTRUE 105819
105817: GO 105830
105819: POP
// bc_type := b_solar_power ; 31 :
105820: LD_ADDR_OWVAR 42
105824: PUSH
105825: LD_INT 27
105827: ST_TO_ADDR
105828: GO 105907
105830: LD_INT 31
105832: DOUBLE
105833: EQUAL
105834: IFTRUE 105838
105836: GO 105849
105838: POP
// bc_type := b_oil_power ; 32 :
105839: LD_ADDR_OWVAR 42
105843: PUSH
105844: LD_INT 26
105846: ST_TO_ADDR
105847: GO 105907
105849: LD_INT 32
105851: DOUBLE
105852: EQUAL
105853: IFTRUE 105857
105855: GO 105868
105857: POP
// bc_type := b_siberite_power ; 33 :
105858: LD_ADDR_OWVAR 42
105862: PUSH
105863: LD_INT 28
105865: ST_TO_ADDR
105866: GO 105907
105868: LD_INT 33
105870: DOUBLE
105871: EQUAL
105872: IFTRUE 105876
105874: GO 105887
105876: POP
// bc_type := b_oil_mine ; 34 :
105877: LD_ADDR_OWVAR 42
105881: PUSH
105882: LD_INT 29
105884: ST_TO_ADDR
105885: GO 105907
105887: LD_INT 34
105889: DOUBLE
105890: EQUAL
105891: IFTRUE 105895
105893: GO 105906
105895: POP
// bc_type := b_siberite_mine ; end ;
105896: LD_ADDR_OWVAR 42
105900: PUSH
105901: LD_INT 30
105903: ST_TO_ADDR
105904: GO 105907
105906: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105907: LD_ADDR_VAR 0 8
105911: PUSH
105912: LD_VAR 0 5
105916: PPUSH
105917: LD_VAR 0 6
105921: PPUSH
105922: LD_VAR 0 3
105926: PPUSH
105927: CALL_OW 47
105931: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105932: LD_OWVAR 42
105936: PUSH
105937: LD_INT 32
105939: PUSH
105940: LD_INT 33
105942: PUSH
105943: EMPTY
105944: LIST
105945: LIST
105946: IN
105947: IFFALSE 105963
// PlaceWeaponTurret ( b , weapon ) ;
105949: LD_VAR 0 8
105953: PPUSH
105954: LD_VAR 0 4
105958: PPUSH
105959: CALL_OW 431
// end ;
105963: LD_VAR 0 7
105967: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105968: LD_INT 0
105970: PPUSH
105971: PPUSH
105972: PPUSH
105973: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105974: LD_ADDR_VAR 0 4
105978: PUSH
105979: LD_INT 22
105981: PUSH
105982: LD_OWVAR 2
105986: PUSH
105987: EMPTY
105988: LIST
105989: LIST
105990: PUSH
105991: LD_INT 2
105993: PUSH
105994: LD_INT 30
105996: PUSH
105997: LD_INT 0
105999: PUSH
106000: EMPTY
106001: LIST
106002: LIST
106003: PUSH
106004: LD_INT 30
106006: PUSH
106007: LD_INT 1
106009: PUSH
106010: EMPTY
106011: LIST
106012: LIST
106013: PUSH
106014: EMPTY
106015: LIST
106016: LIST
106017: LIST
106018: PUSH
106019: EMPTY
106020: LIST
106021: LIST
106022: PPUSH
106023: CALL_OW 69
106027: ST_TO_ADDR
// if not tmp then
106028: LD_VAR 0 4
106032: NOT
106033: IFFALSE 106037
// exit ;
106035: GO 106096
// for i in tmp do
106037: LD_ADDR_VAR 0 2
106041: PUSH
106042: LD_VAR 0 4
106046: PUSH
106047: FOR_IN
106048: IFFALSE 106094
// for j = 1 to 3 do
106050: LD_ADDR_VAR 0 3
106054: PUSH
106055: DOUBLE
106056: LD_INT 1
106058: DEC
106059: ST_TO_ADDR
106060: LD_INT 3
106062: PUSH
106063: FOR_TO
106064: IFFALSE 106090
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
106066: LD_VAR 0 2
106070: PPUSH
106071: CALL_OW 274
106075: PPUSH
106076: LD_VAR 0 3
106080: PPUSH
106081: LD_INT 99999
106083: PPUSH
106084: CALL_OW 277
106088: GO 106063
106090: POP
106091: POP
106092: GO 106047
106094: POP
106095: POP
// end ;
106096: LD_VAR 0 1
106100: RET
// export function hHackSetLevel10 ; var i , j ; begin
106101: LD_INT 0
106103: PPUSH
106104: PPUSH
106105: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106106: LD_ADDR_VAR 0 2
106110: PUSH
106111: LD_INT 21
106113: PUSH
106114: LD_INT 1
106116: PUSH
106117: EMPTY
106118: LIST
106119: LIST
106120: PPUSH
106121: CALL_OW 69
106125: PUSH
106126: FOR_IN
106127: IFFALSE 106179
// if IsSelected ( i ) then
106129: LD_VAR 0 2
106133: PPUSH
106134: CALL_OW 306
106138: IFFALSE 106177
// begin for j := 1 to 4 do
106140: LD_ADDR_VAR 0 3
106144: PUSH
106145: DOUBLE
106146: LD_INT 1
106148: DEC
106149: ST_TO_ADDR
106150: LD_INT 4
106152: PUSH
106153: FOR_TO
106154: IFFALSE 106175
// SetSkill ( i , j , 10 ) ;
106156: LD_VAR 0 2
106160: PPUSH
106161: LD_VAR 0 3
106165: PPUSH
106166: LD_INT 10
106168: PPUSH
106169: CALL_OW 237
106173: GO 106153
106175: POP
106176: POP
// end ;
106177: GO 106126
106179: POP
106180: POP
// end ;
106181: LD_VAR 0 1
106185: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
106186: LD_INT 0
106188: PPUSH
106189: PPUSH
106190: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
106191: LD_ADDR_VAR 0 2
106195: PUSH
106196: LD_INT 22
106198: PUSH
106199: LD_OWVAR 2
106203: PUSH
106204: EMPTY
106205: LIST
106206: LIST
106207: PUSH
106208: LD_INT 21
106210: PUSH
106211: LD_INT 1
106213: PUSH
106214: EMPTY
106215: LIST
106216: LIST
106217: PUSH
106218: EMPTY
106219: LIST
106220: LIST
106221: PPUSH
106222: CALL_OW 69
106226: PUSH
106227: FOR_IN
106228: IFFALSE 106269
// begin for j := 1 to 4 do
106230: LD_ADDR_VAR 0 3
106234: PUSH
106235: DOUBLE
106236: LD_INT 1
106238: DEC
106239: ST_TO_ADDR
106240: LD_INT 4
106242: PUSH
106243: FOR_TO
106244: IFFALSE 106265
// SetSkill ( i , j , 10 ) ;
106246: LD_VAR 0 2
106250: PPUSH
106251: LD_VAR 0 3
106255: PPUSH
106256: LD_INT 10
106258: PPUSH
106259: CALL_OW 237
106263: GO 106243
106265: POP
106266: POP
// end ;
106267: GO 106227
106269: POP
106270: POP
// end ;
106271: LD_VAR 0 1
106275: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
106276: LD_INT 0
106278: PPUSH
// uc_side := your_side ;
106279: LD_ADDR_OWVAR 20
106283: PUSH
106284: LD_OWVAR 2
106288: ST_TO_ADDR
// uc_nation := nation ;
106289: LD_ADDR_OWVAR 21
106293: PUSH
106294: LD_VAR 0 1
106298: ST_TO_ADDR
// InitHc ;
106299: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
106303: LD_INT 0
106305: PPUSH
106306: LD_VAR 0 2
106310: PPUSH
106311: LD_VAR 0 3
106315: PPUSH
106316: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
106320: LD_VAR 0 4
106324: PPUSH
106325: LD_VAR 0 5
106329: PPUSH
106330: CALL_OW 428
106334: PUSH
106335: LD_INT 0
106337: EQUAL
106338: IFFALSE 106362
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
106340: CALL_OW 44
106344: PPUSH
106345: LD_VAR 0 4
106349: PPUSH
106350: LD_VAR 0 5
106354: PPUSH
106355: LD_INT 1
106357: PPUSH
106358: CALL_OW 48
// end ;
106362: LD_VAR 0 6
106366: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
106367: LD_INT 0
106369: PPUSH
106370: PPUSH
// uc_side := your_side ;
106371: LD_ADDR_OWVAR 20
106375: PUSH
106376: LD_OWVAR 2
106380: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
106381: LD_VAR 0 1
106385: PUSH
106386: LD_INT 1
106388: PUSH
106389: LD_INT 2
106391: PUSH
106392: LD_INT 3
106394: PUSH
106395: LD_INT 4
106397: PUSH
106398: LD_INT 5
106400: PUSH
106401: EMPTY
106402: LIST
106403: LIST
106404: LIST
106405: LIST
106406: LIST
106407: IN
106408: IFFALSE 106420
// uc_nation := nation_american else
106410: LD_ADDR_OWVAR 21
106414: PUSH
106415: LD_INT 1
106417: ST_TO_ADDR
106418: GO 106463
// if chassis in [ 11 , 12 , 13 , 14 ] then
106420: LD_VAR 0 1
106424: PUSH
106425: LD_INT 11
106427: PUSH
106428: LD_INT 12
106430: PUSH
106431: LD_INT 13
106433: PUSH
106434: LD_INT 14
106436: PUSH
106437: EMPTY
106438: LIST
106439: LIST
106440: LIST
106441: LIST
106442: IN
106443: IFFALSE 106455
// uc_nation := nation_arabian else
106445: LD_ADDR_OWVAR 21
106449: PUSH
106450: LD_INT 2
106452: ST_TO_ADDR
106453: GO 106463
// uc_nation := nation_russian ;
106455: LD_ADDR_OWVAR 21
106459: PUSH
106460: LD_INT 3
106462: ST_TO_ADDR
// vc_chassis := chassis ;
106463: LD_ADDR_OWVAR 37
106467: PUSH
106468: LD_VAR 0 1
106472: ST_TO_ADDR
// vc_engine := engine ;
106473: LD_ADDR_OWVAR 39
106477: PUSH
106478: LD_VAR 0 2
106482: ST_TO_ADDR
// vc_control := control ;
106483: LD_ADDR_OWVAR 38
106487: PUSH
106488: LD_VAR 0 3
106492: ST_TO_ADDR
// vc_weapon := weapon ;
106493: LD_ADDR_OWVAR 40
106497: PUSH
106498: LD_VAR 0 4
106502: ST_TO_ADDR
// un := CreateVehicle ;
106503: LD_ADDR_VAR 0 8
106507: PUSH
106508: CALL_OW 45
106512: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106513: LD_VAR 0 8
106517: PPUSH
106518: LD_INT 0
106520: PPUSH
106521: LD_INT 5
106523: PPUSH
106524: CALL_OW 12
106528: PPUSH
106529: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106533: LD_VAR 0 8
106537: PPUSH
106538: LD_VAR 0 5
106542: PPUSH
106543: LD_VAR 0 6
106547: PPUSH
106548: LD_INT 1
106550: PPUSH
106551: CALL_OW 48
// end ;
106555: LD_VAR 0 7
106559: RET
// export hInvincible ; every 1 do
106560: GO 106562
106562: DISABLE
// hInvincible := [ ] ;
106563: LD_ADDR_EXP 134
106567: PUSH
106568: EMPTY
106569: ST_TO_ADDR
106570: END
// every 10 do var i ;
106571: GO 106573
106573: DISABLE
106574: LD_INT 0
106576: PPUSH
// begin enable ;
106577: ENABLE
// if not hInvincible then
106578: LD_EXP 134
106582: NOT
106583: IFFALSE 106587
// exit ;
106585: GO 106631
// for i in hInvincible do
106587: LD_ADDR_VAR 0 1
106591: PUSH
106592: LD_EXP 134
106596: PUSH
106597: FOR_IN
106598: IFFALSE 106629
// if GetLives ( i ) < 1000 then
106600: LD_VAR 0 1
106604: PPUSH
106605: CALL_OW 256
106609: PUSH
106610: LD_INT 1000
106612: LESS
106613: IFFALSE 106627
// SetLives ( i , 1000 ) ;
106615: LD_VAR 0 1
106619: PPUSH
106620: LD_INT 1000
106622: PPUSH
106623: CALL_OW 234
106627: GO 106597
106629: POP
106630: POP
// end ;
106631: PPOPN 1
106633: END
// export function hHackInvincible ; var i ; begin
106634: LD_INT 0
106636: PPUSH
106637: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106638: LD_ADDR_VAR 0 2
106642: PUSH
106643: LD_INT 2
106645: PUSH
106646: LD_INT 21
106648: PUSH
106649: LD_INT 1
106651: PUSH
106652: EMPTY
106653: LIST
106654: LIST
106655: PUSH
106656: LD_INT 21
106658: PUSH
106659: LD_INT 2
106661: PUSH
106662: EMPTY
106663: LIST
106664: LIST
106665: PUSH
106666: EMPTY
106667: LIST
106668: LIST
106669: LIST
106670: PPUSH
106671: CALL_OW 69
106675: PUSH
106676: FOR_IN
106677: IFFALSE 106738
// if IsSelected ( i ) then
106679: LD_VAR 0 2
106683: PPUSH
106684: CALL_OW 306
106688: IFFALSE 106736
// begin if i in hInvincible then
106690: LD_VAR 0 2
106694: PUSH
106695: LD_EXP 134
106699: IN
106700: IFFALSE 106720
// hInvincible := hInvincible diff i else
106702: LD_ADDR_EXP 134
106706: PUSH
106707: LD_EXP 134
106711: PUSH
106712: LD_VAR 0 2
106716: DIFF
106717: ST_TO_ADDR
106718: GO 106736
// hInvincible := hInvincible union i ;
106720: LD_ADDR_EXP 134
106724: PUSH
106725: LD_EXP 134
106729: PUSH
106730: LD_VAR 0 2
106734: UNION
106735: ST_TO_ADDR
// end ;
106736: GO 106676
106738: POP
106739: POP
// end ;
106740: LD_VAR 0 1
106744: RET
// export function hHackInvisible ; var i , j ; begin
106745: LD_INT 0
106747: PPUSH
106748: PPUSH
106749: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106750: LD_ADDR_VAR 0 2
106754: PUSH
106755: LD_INT 21
106757: PUSH
106758: LD_INT 1
106760: PUSH
106761: EMPTY
106762: LIST
106763: LIST
106764: PPUSH
106765: CALL_OW 69
106769: PUSH
106770: FOR_IN
106771: IFFALSE 106795
// if IsSelected ( i ) then
106773: LD_VAR 0 2
106777: PPUSH
106778: CALL_OW 306
106782: IFFALSE 106793
// ComForceInvisible ( i ) ;
106784: LD_VAR 0 2
106788: PPUSH
106789: CALL_OW 496
106793: GO 106770
106795: POP
106796: POP
// end ;
106797: LD_VAR 0 1
106801: RET
// export function hHackChangeYourSide ; begin
106802: LD_INT 0
106804: PPUSH
// if your_side = 8 then
106805: LD_OWVAR 2
106809: PUSH
106810: LD_INT 8
106812: EQUAL
106813: IFFALSE 106825
// your_side := 0 else
106815: LD_ADDR_OWVAR 2
106819: PUSH
106820: LD_INT 0
106822: ST_TO_ADDR
106823: GO 106839
// your_side := your_side + 1 ;
106825: LD_ADDR_OWVAR 2
106829: PUSH
106830: LD_OWVAR 2
106834: PUSH
106835: LD_INT 1
106837: PLUS
106838: ST_TO_ADDR
// end ;
106839: LD_VAR 0 1
106843: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106844: LD_INT 0
106846: PPUSH
106847: PPUSH
106848: PPUSH
// for i in all_units do
106849: LD_ADDR_VAR 0 2
106853: PUSH
106854: LD_OWVAR 3
106858: PUSH
106859: FOR_IN
106860: IFFALSE 106938
// if IsSelected ( i ) then
106862: LD_VAR 0 2
106866: PPUSH
106867: CALL_OW 306
106871: IFFALSE 106936
// begin j := GetSide ( i ) ;
106873: LD_ADDR_VAR 0 3
106877: PUSH
106878: LD_VAR 0 2
106882: PPUSH
106883: CALL_OW 255
106887: ST_TO_ADDR
// if j = 8 then
106888: LD_VAR 0 3
106892: PUSH
106893: LD_INT 8
106895: EQUAL
106896: IFFALSE 106908
// j := 0 else
106898: LD_ADDR_VAR 0 3
106902: PUSH
106903: LD_INT 0
106905: ST_TO_ADDR
106906: GO 106922
// j := j + 1 ;
106908: LD_ADDR_VAR 0 3
106912: PUSH
106913: LD_VAR 0 3
106917: PUSH
106918: LD_INT 1
106920: PLUS
106921: ST_TO_ADDR
// SetSide ( i , j ) ;
106922: LD_VAR 0 2
106926: PPUSH
106927: LD_VAR 0 3
106931: PPUSH
106932: CALL_OW 235
// end ;
106936: GO 106859
106938: POP
106939: POP
// end ;
106940: LD_VAR 0 1
106944: RET
// export function hHackFog ; begin
106945: LD_INT 0
106947: PPUSH
// FogOff ( true ) ;
106948: LD_INT 1
106950: PPUSH
106951: CALL_OW 344
// end ;
106955: LD_VAR 0 1
106959: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106960: LD_INT 0
106962: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106963: LD_VAR 0 1
106967: PPUSH
106968: LD_VAR 0 2
106972: PPUSH
106973: LD_VAR 0 3
106977: PPUSH
106978: LD_INT 1
106980: PPUSH
106981: LD_INT 1
106983: PPUSH
106984: CALL_OW 483
// CenterOnXY ( x , y ) ;
106988: LD_VAR 0 2
106992: PPUSH
106993: LD_VAR 0 3
106997: PPUSH
106998: CALL_OW 84
// end ;
107002: LD_VAR 0 4
107006: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107007: LD_INT 0
107009: PPUSH
107010: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107011: LD_VAR 0 1
107015: NOT
107016: PUSH
107017: LD_VAR 0 2
107021: PPUSH
107022: LD_VAR 0 3
107026: PPUSH
107027: CALL_OW 488
107031: NOT
107032: OR
107033: PUSH
107034: LD_VAR 0 1
107038: PPUSH
107039: CALL_OW 266
107043: PUSH
107044: LD_INT 3
107046: NONEQUAL
107047: PUSH
107048: LD_VAR 0 1
107052: PPUSH
107053: CALL_OW 247
107057: PUSH
107058: LD_INT 1
107060: EQUAL
107061: NOT
107062: AND
107063: OR
107064: IFFALSE 107068
// exit ;
107066: GO 107217
// if GetType ( factory ) = unit_human then
107068: LD_VAR 0 1
107072: PPUSH
107073: CALL_OW 247
107077: PUSH
107078: LD_INT 1
107080: EQUAL
107081: IFFALSE 107098
// factory := IsInUnit ( factory ) ;
107083: LD_ADDR_VAR 0 1
107087: PUSH
107088: LD_VAR 0 1
107092: PPUSH
107093: CALL_OW 310
107097: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
107098: LD_VAR 0 1
107102: PPUSH
107103: CALL_OW 266
107107: PUSH
107108: LD_INT 3
107110: NONEQUAL
107111: IFFALSE 107115
// exit ;
107113: GO 107217
// if HexInfo ( x , y ) = factory then
107115: LD_VAR 0 2
107119: PPUSH
107120: LD_VAR 0 3
107124: PPUSH
107125: CALL_OW 428
107129: PUSH
107130: LD_VAR 0 1
107134: EQUAL
107135: IFFALSE 107162
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
107137: LD_ADDR_EXP 135
107141: PUSH
107142: LD_EXP 135
107146: PPUSH
107147: LD_VAR 0 1
107151: PPUSH
107152: LD_INT 0
107154: PPUSH
107155: CALL_OW 1
107159: ST_TO_ADDR
107160: GO 107213
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
107162: LD_ADDR_EXP 135
107166: PUSH
107167: LD_EXP 135
107171: PPUSH
107172: LD_VAR 0 1
107176: PPUSH
107177: LD_VAR 0 1
107181: PPUSH
107182: CALL_OW 255
107186: PUSH
107187: LD_VAR 0 1
107191: PUSH
107192: LD_VAR 0 2
107196: PUSH
107197: LD_VAR 0 3
107201: PUSH
107202: EMPTY
107203: LIST
107204: LIST
107205: LIST
107206: LIST
107207: PPUSH
107208: CALL_OW 1
107212: ST_TO_ADDR
// UpdateFactoryWaypoints ;
107213: CALL 107222 0 0
// end ;
107217: LD_VAR 0 4
107221: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
107222: LD_INT 0
107224: PPUSH
107225: PPUSH
107226: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
107227: LD_STRING resetFactoryWaypoint();
107229: PPUSH
107230: CALL_OW 559
// if factoryWaypoints then
107234: LD_EXP 135
107238: IFFALSE 107364
// begin list := PrepareArray ( factoryWaypoints ) ;
107240: LD_ADDR_VAR 0 3
107244: PUSH
107245: LD_EXP 135
107249: PPUSH
107250: CALL 61344 0 1
107254: ST_TO_ADDR
// for i := 1 to list do
107255: LD_ADDR_VAR 0 2
107259: PUSH
107260: DOUBLE
107261: LD_INT 1
107263: DEC
107264: ST_TO_ADDR
107265: LD_VAR 0 3
107269: PUSH
107270: FOR_TO
107271: IFFALSE 107362
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107273: LD_STRING setFactoryWaypointXY(
107275: PUSH
107276: LD_VAR 0 3
107280: PUSH
107281: LD_VAR 0 2
107285: ARRAY
107286: PUSH
107287: LD_INT 1
107289: ARRAY
107290: STR
107291: PUSH
107292: LD_STRING ,
107294: STR
107295: PUSH
107296: LD_VAR 0 3
107300: PUSH
107301: LD_VAR 0 2
107305: ARRAY
107306: PUSH
107307: LD_INT 2
107309: ARRAY
107310: STR
107311: PUSH
107312: LD_STRING ,
107314: STR
107315: PUSH
107316: LD_VAR 0 3
107320: PUSH
107321: LD_VAR 0 2
107325: ARRAY
107326: PUSH
107327: LD_INT 3
107329: ARRAY
107330: STR
107331: PUSH
107332: LD_STRING ,
107334: STR
107335: PUSH
107336: LD_VAR 0 3
107340: PUSH
107341: LD_VAR 0 2
107345: ARRAY
107346: PUSH
107347: LD_INT 4
107349: ARRAY
107350: STR
107351: PUSH
107352: LD_STRING )
107354: STR
107355: PPUSH
107356: CALL_OW 559
107360: GO 107270
107362: POP
107363: POP
// end ; end ;
107364: LD_VAR 0 1
107368: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
107369: LD_INT 0
107371: PPUSH
// if HexInfo ( x , y ) = warehouse then
107372: LD_VAR 0 2
107376: PPUSH
107377: LD_VAR 0 3
107381: PPUSH
107382: CALL_OW 428
107386: PUSH
107387: LD_VAR 0 1
107391: EQUAL
107392: IFFALSE 107419
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
107394: LD_ADDR_EXP 136
107398: PUSH
107399: LD_EXP 136
107403: PPUSH
107404: LD_VAR 0 1
107408: PPUSH
107409: LD_INT 0
107411: PPUSH
107412: CALL_OW 1
107416: ST_TO_ADDR
107417: GO 107470
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
107419: LD_ADDR_EXP 136
107423: PUSH
107424: LD_EXP 136
107428: PPUSH
107429: LD_VAR 0 1
107433: PPUSH
107434: LD_VAR 0 1
107438: PPUSH
107439: CALL_OW 255
107443: PUSH
107444: LD_VAR 0 1
107448: PUSH
107449: LD_VAR 0 2
107453: PUSH
107454: LD_VAR 0 3
107458: PUSH
107459: EMPTY
107460: LIST
107461: LIST
107462: LIST
107463: LIST
107464: PPUSH
107465: CALL_OW 1
107469: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
107470: CALL 107479 0 0
// end ;
107474: LD_VAR 0 4
107478: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
107479: LD_INT 0
107481: PPUSH
107482: PPUSH
107483: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
107484: LD_STRING resetWarehouseGatheringPoints();
107486: PPUSH
107487: CALL_OW 559
// if warehouseGatheringPoints then
107491: LD_EXP 136
107495: IFFALSE 107621
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
107497: LD_ADDR_VAR 0 3
107501: PUSH
107502: LD_EXP 136
107506: PPUSH
107507: CALL 61344 0 1
107511: ST_TO_ADDR
// for i := 1 to list do
107512: LD_ADDR_VAR 0 2
107516: PUSH
107517: DOUBLE
107518: LD_INT 1
107520: DEC
107521: ST_TO_ADDR
107522: LD_VAR 0 3
107526: PUSH
107527: FOR_TO
107528: IFFALSE 107619
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107530: LD_STRING setWarehouseGatheringPointXY(
107532: PUSH
107533: LD_VAR 0 3
107537: PUSH
107538: LD_VAR 0 2
107542: ARRAY
107543: PUSH
107544: LD_INT 1
107546: ARRAY
107547: STR
107548: PUSH
107549: LD_STRING ,
107551: STR
107552: PUSH
107553: LD_VAR 0 3
107557: PUSH
107558: LD_VAR 0 2
107562: ARRAY
107563: PUSH
107564: LD_INT 2
107566: ARRAY
107567: STR
107568: PUSH
107569: LD_STRING ,
107571: STR
107572: PUSH
107573: LD_VAR 0 3
107577: PUSH
107578: LD_VAR 0 2
107582: ARRAY
107583: PUSH
107584: LD_INT 3
107586: ARRAY
107587: STR
107588: PUSH
107589: LD_STRING ,
107591: STR
107592: PUSH
107593: LD_VAR 0 3
107597: PUSH
107598: LD_VAR 0 2
107602: ARRAY
107603: PUSH
107604: LD_INT 4
107606: ARRAY
107607: STR
107608: PUSH
107609: LD_STRING )
107611: STR
107612: PPUSH
107613: CALL_OW 559
107617: GO 107527
107619: POP
107620: POP
// end ; end ;
107621: LD_VAR 0 1
107625: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107626: LD_EXP 136
107630: IFFALSE 108315
107632: GO 107634
107634: DISABLE
107635: LD_INT 0
107637: PPUSH
107638: PPUSH
107639: PPUSH
107640: PPUSH
107641: PPUSH
107642: PPUSH
107643: PPUSH
107644: PPUSH
107645: PPUSH
// begin enable ;
107646: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107647: LD_ADDR_VAR 0 3
107651: PUSH
107652: LD_EXP 136
107656: PPUSH
107657: CALL 61344 0 1
107661: ST_TO_ADDR
// if not list then
107662: LD_VAR 0 3
107666: NOT
107667: IFFALSE 107671
// exit ;
107669: GO 108315
// for i := 1 to list do
107671: LD_ADDR_VAR 0 1
107675: PUSH
107676: DOUBLE
107677: LD_INT 1
107679: DEC
107680: ST_TO_ADDR
107681: LD_VAR 0 3
107685: PUSH
107686: FOR_TO
107687: IFFALSE 108313
// begin depot := list [ i ] [ 2 ] ;
107689: LD_ADDR_VAR 0 8
107693: PUSH
107694: LD_VAR 0 3
107698: PUSH
107699: LD_VAR 0 1
107703: ARRAY
107704: PUSH
107705: LD_INT 2
107707: ARRAY
107708: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107709: LD_ADDR_VAR 0 5
107713: PUSH
107714: LD_VAR 0 3
107718: PUSH
107719: LD_VAR 0 1
107723: ARRAY
107724: PUSH
107725: LD_INT 1
107727: ARRAY
107728: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107729: LD_VAR 0 8
107733: PPUSH
107734: CALL_OW 301
107738: PUSH
107739: LD_VAR 0 5
107743: PUSH
107744: LD_VAR 0 8
107748: PPUSH
107749: CALL_OW 255
107753: NONEQUAL
107754: OR
107755: IFFALSE 107784
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107757: LD_ADDR_EXP 136
107761: PUSH
107762: LD_EXP 136
107766: PPUSH
107767: LD_VAR 0 8
107771: PPUSH
107772: LD_INT 0
107774: PPUSH
107775: CALL_OW 1
107779: ST_TO_ADDR
// exit ;
107780: POP
107781: POP
107782: GO 108315
// end ; x := list [ i ] [ 3 ] ;
107784: LD_ADDR_VAR 0 6
107788: PUSH
107789: LD_VAR 0 3
107793: PUSH
107794: LD_VAR 0 1
107798: ARRAY
107799: PUSH
107800: LD_INT 3
107802: ARRAY
107803: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107804: LD_ADDR_VAR 0 7
107808: PUSH
107809: LD_VAR 0 3
107813: PUSH
107814: LD_VAR 0 1
107818: ARRAY
107819: PUSH
107820: LD_INT 4
107822: ARRAY
107823: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107824: LD_ADDR_VAR 0 9
107828: PUSH
107829: LD_VAR 0 6
107833: PPUSH
107834: LD_VAR 0 7
107838: PPUSH
107839: LD_INT 16
107841: PPUSH
107842: CALL 59932 0 3
107846: ST_TO_ADDR
// if not cratesNearbyPoint then
107847: LD_VAR 0 9
107851: NOT
107852: IFFALSE 107858
// exit ;
107854: POP
107855: POP
107856: GO 108315
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107858: LD_ADDR_VAR 0 4
107862: PUSH
107863: LD_INT 22
107865: PUSH
107866: LD_VAR 0 5
107870: PUSH
107871: EMPTY
107872: LIST
107873: LIST
107874: PUSH
107875: LD_INT 3
107877: PUSH
107878: LD_INT 60
107880: PUSH
107881: EMPTY
107882: LIST
107883: PUSH
107884: EMPTY
107885: LIST
107886: LIST
107887: PUSH
107888: LD_INT 91
107890: PUSH
107891: LD_VAR 0 8
107895: PUSH
107896: LD_INT 6
107898: PUSH
107899: EMPTY
107900: LIST
107901: LIST
107902: LIST
107903: PUSH
107904: LD_INT 2
107906: PUSH
107907: LD_INT 25
107909: PUSH
107910: LD_INT 2
107912: PUSH
107913: EMPTY
107914: LIST
107915: LIST
107916: PUSH
107917: LD_INT 25
107919: PUSH
107920: LD_INT 16
107922: PUSH
107923: EMPTY
107924: LIST
107925: LIST
107926: PUSH
107927: EMPTY
107928: LIST
107929: LIST
107930: LIST
107931: PUSH
107932: EMPTY
107933: LIST
107934: LIST
107935: LIST
107936: LIST
107937: PPUSH
107938: CALL_OW 69
107942: PUSH
107943: LD_VAR 0 8
107947: PPUSH
107948: CALL_OW 313
107952: PPUSH
107953: LD_INT 3
107955: PUSH
107956: LD_INT 60
107958: PUSH
107959: EMPTY
107960: LIST
107961: PUSH
107962: EMPTY
107963: LIST
107964: LIST
107965: PUSH
107966: LD_INT 2
107968: PUSH
107969: LD_INT 25
107971: PUSH
107972: LD_INT 2
107974: PUSH
107975: EMPTY
107976: LIST
107977: LIST
107978: PUSH
107979: LD_INT 25
107981: PUSH
107982: LD_INT 16
107984: PUSH
107985: EMPTY
107986: LIST
107987: LIST
107988: PUSH
107989: EMPTY
107990: LIST
107991: LIST
107992: LIST
107993: PUSH
107994: EMPTY
107995: LIST
107996: LIST
107997: PPUSH
107998: CALL_OW 72
108002: UNION
108003: ST_TO_ADDR
// if tmp then
108004: LD_VAR 0 4
108008: IFFALSE 108088
// begin tmp := ShrinkArray ( tmp , 3 ) ;
108010: LD_ADDR_VAR 0 4
108014: PUSH
108015: LD_VAR 0 4
108019: PPUSH
108020: LD_INT 3
108022: PPUSH
108023: CALL 57901 0 2
108027: ST_TO_ADDR
// for j in tmp do
108028: LD_ADDR_VAR 0 2
108032: PUSH
108033: LD_VAR 0 4
108037: PUSH
108038: FOR_IN
108039: IFFALSE 108082
// begin if IsInUnit ( j ) then
108041: LD_VAR 0 2
108045: PPUSH
108046: CALL_OW 310
108050: IFFALSE 108061
// ComExit ( j ) ;
108052: LD_VAR 0 2
108056: PPUSH
108057: CALL 57984 0 1
// AddComCollect ( j , x , y ) ;
108061: LD_VAR 0 2
108065: PPUSH
108066: LD_VAR 0 6
108070: PPUSH
108071: LD_VAR 0 7
108075: PPUSH
108076: CALL_OW 177
// end ;
108080: GO 108038
108082: POP
108083: POP
// exit ;
108084: POP
108085: POP
108086: GO 108315
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
108088: LD_ADDR_VAR 0 4
108092: PUSH
108093: LD_INT 22
108095: PUSH
108096: LD_VAR 0 5
108100: PUSH
108101: EMPTY
108102: LIST
108103: LIST
108104: PUSH
108105: LD_INT 91
108107: PUSH
108108: LD_VAR 0 8
108112: PUSH
108113: LD_INT 8
108115: PUSH
108116: EMPTY
108117: LIST
108118: LIST
108119: LIST
108120: PUSH
108121: LD_INT 2
108123: PUSH
108124: LD_INT 34
108126: PUSH
108127: LD_INT 12
108129: PUSH
108130: EMPTY
108131: LIST
108132: LIST
108133: PUSH
108134: LD_INT 34
108136: PUSH
108137: LD_INT 51
108139: PUSH
108140: EMPTY
108141: LIST
108142: LIST
108143: PUSH
108144: LD_INT 34
108146: PUSH
108147: LD_INT 32
108149: PUSH
108150: EMPTY
108151: LIST
108152: LIST
108153: PUSH
108154: LD_INT 34
108156: PUSH
108157: LD_INT 89
108159: PUSH
108160: EMPTY
108161: LIST
108162: LIST
108163: PUSH
108164: EMPTY
108165: LIST
108166: LIST
108167: LIST
108168: LIST
108169: LIST
108170: PUSH
108171: EMPTY
108172: LIST
108173: LIST
108174: LIST
108175: PPUSH
108176: CALL_OW 69
108180: ST_TO_ADDR
// if tmp then
108181: LD_VAR 0 4
108185: IFFALSE 108311
// begin for j in tmp do
108187: LD_ADDR_VAR 0 2
108191: PUSH
108192: LD_VAR 0 4
108196: PUSH
108197: FOR_IN
108198: IFFALSE 108309
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
108200: LD_VAR 0 2
108204: PPUSH
108205: CALL_OW 262
108209: PUSH
108210: LD_INT 3
108212: EQUAL
108213: PUSH
108214: LD_VAR 0 2
108218: PPUSH
108219: CALL_OW 261
108223: PUSH
108224: LD_INT 20
108226: GREATER
108227: OR
108228: PUSH
108229: LD_VAR 0 2
108233: PPUSH
108234: CALL_OW 314
108238: NOT
108239: AND
108240: PUSH
108241: LD_VAR 0 2
108245: PPUSH
108246: CALL_OW 263
108250: PUSH
108251: LD_INT 1
108253: NONEQUAL
108254: PUSH
108255: LD_VAR 0 2
108259: PPUSH
108260: CALL_OW 311
108264: OR
108265: AND
108266: IFFALSE 108307
// begin ComCollect ( j , x , y ) ;
108268: LD_VAR 0 2
108272: PPUSH
108273: LD_VAR 0 6
108277: PPUSH
108278: LD_VAR 0 7
108282: PPUSH
108283: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
108287: LD_VAR 0 2
108291: PPUSH
108292: LD_VAR 0 8
108296: PPUSH
108297: CALL_OW 172
// exit ;
108301: POP
108302: POP
108303: POP
108304: POP
108305: GO 108315
// end ;
108307: GO 108197
108309: POP
108310: POP
// end ; end ;
108311: GO 107686
108313: POP
108314: POP
// end ; end_of_file
108315: PPOPN 9
108317: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
108318: LD_INT 0
108320: PPUSH
108321: PPUSH
108322: PPUSH
108323: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
108324: LD_VAR 0 1
108328: PPUSH
108329: CALL_OW 264
108333: PUSH
108334: LD_INT 91
108336: EQUAL
108337: IFFALSE 108409
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
108339: LD_INT 68
108341: PPUSH
108342: LD_VAR 0 1
108346: PPUSH
108347: CALL_OW 255
108351: PPUSH
108352: CALL_OW 321
108356: PUSH
108357: LD_INT 2
108359: EQUAL
108360: IFFALSE 108372
// eff := 70 else
108362: LD_ADDR_VAR 0 4
108366: PUSH
108367: LD_INT 70
108369: ST_TO_ADDR
108370: GO 108380
// eff := 30 ;
108372: LD_ADDR_VAR 0 4
108376: PUSH
108377: LD_INT 30
108379: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
108380: LD_VAR 0 1
108384: PPUSH
108385: CALL_OW 250
108389: PPUSH
108390: LD_VAR 0 1
108394: PPUSH
108395: CALL_OW 251
108399: PPUSH
108400: LD_VAR 0 4
108404: PPUSH
108405: CALL_OW 495
// end ; end ;
108409: LD_VAR 0 2
108413: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
108414: LD_INT 0
108416: PPUSH
// end ;
108417: LD_VAR 0 4
108421: RET
// export function SOS_Command ( cmd ) ; begin
108422: LD_INT 0
108424: PPUSH
// end ;
108425: LD_VAR 0 2
108429: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
108430: LD_INT 0
108432: PPUSH
// end ;
108433: LD_VAR 0 6
108437: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
108438: LD_INT 0
108440: PPUSH
108441: PPUSH
// if not vehicle or not factory then
108442: LD_VAR 0 1
108446: NOT
108447: PUSH
108448: LD_VAR 0 2
108452: NOT
108453: OR
108454: IFFALSE 108458
// exit ;
108456: GO 108689
// if factoryWaypoints >= factory then
108458: LD_EXP 135
108462: PUSH
108463: LD_VAR 0 2
108467: GREATEREQUAL
108468: IFFALSE 108689
// if factoryWaypoints [ factory ] then
108470: LD_EXP 135
108474: PUSH
108475: LD_VAR 0 2
108479: ARRAY
108480: IFFALSE 108689
// begin if GetControl ( vehicle ) = control_manual then
108482: LD_VAR 0 1
108486: PPUSH
108487: CALL_OW 263
108491: PUSH
108492: LD_INT 1
108494: EQUAL
108495: IFFALSE 108576
// begin driver := IsDrivenBy ( vehicle ) ;
108497: LD_ADDR_VAR 0 4
108501: PUSH
108502: LD_VAR 0 1
108506: PPUSH
108507: CALL_OW 311
108511: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108512: LD_VAR 0 4
108516: PPUSH
108517: LD_EXP 135
108521: PUSH
108522: LD_VAR 0 2
108526: ARRAY
108527: PUSH
108528: LD_INT 3
108530: ARRAY
108531: PPUSH
108532: LD_EXP 135
108536: PUSH
108537: LD_VAR 0 2
108541: ARRAY
108542: PUSH
108543: LD_INT 4
108545: ARRAY
108546: PPUSH
108547: CALL_OW 171
// AddComExitVehicle ( driver ) ;
108551: LD_VAR 0 4
108555: PPUSH
108556: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
108560: LD_VAR 0 4
108564: PPUSH
108565: LD_VAR 0 2
108569: PPUSH
108570: CALL_OW 180
// end else
108574: GO 108689
// if GetControl ( vehicle ) = control_remote then
108576: LD_VAR 0 1
108580: PPUSH
108581: CALL_OW 263
108585: PUSH
108586: LD_INT 2
108588: EQUAL
108589: IFFALSE 108650
// begin wait ( 0 0$2 ) ;
108591: LD_INT 70
108593: PPUSH
108594: CALL_OW 67
// if Connect ( vehicle ) then
108598: LD_VAR 0 1
108602: PPUSH
108603: CALL 28192 0 1
108607: IFFALSE 108648
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108609: LD_VAR 0 1
108613: PPUSH
108614: LD_EXP 135
108618: PUSH
108619: LD_VAR 0 2
108623: ARRAY
108624: PUSH
108625: LD_INT 3
108627: ARRAY
108628: PPUSH
108629: LD_EXP 135
108633: PUSH
108634: LD_VAR 0 2
108638: ARRAY
108639: PUSH
108640: LD_INT 4
108642: ARRAY
108643: PPUSH
108644: CALL_OW 171
// end else
108648: GO 108689
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108650: LD_VAR 0 1
108654: PPUSH
108655: LD_EXP 135
108659: PUSH
108660: LD_VAR 0 2
108664: ARRAY
108665: PUSH
108666: LD_INT 3
108668: ARRAY
108669: PPUSH
108670: LD_EXP 135
108674: PUSH
108675: LD_VAR 0 2
108679: ARRAY
108680: PUSH
108681: LD_INT 4
108683: ARRAY
108684: PPUSH
108685: CALL_OW 171
// end ; end ;
108689: LD_VAR 0 3
108693: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108694: LD_INT 0
108696: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108697: LD_VAR 0 1
108701: PUSH
108702: LD_INT 250
108704: EQUAL
108705: PUSH
108706: LD_VAR 0 2
108710: PPUSH
108711: CALL_OW 264
108715: PUSH
108716: LD_INT 81
108718: EQUAL
108719: AND
108720: IFFALSE 108741
// MinerPlaceMine ( unit , x , y ) ;
108722: LD_VAR 0 2
108726: PPUSH
108727: LD_VAR 0 4
108731: PPUSH
108732: LD_VAR 0 5
108736: PPUSH
108737: CALL 111565 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108741: LD_VAR 0 1
108745: PUSH
108746: LD_INT 251
108748: EQUAL
108749: PUSH
108750: LD_VAR 0 2
108754: PPUSH
108755: CALL_OW 264
108759: PUSH
108760: LD_INT 81
108762: EQUAL
108763: AND
108764: IFFALSE 108785
// MinerDetonateMine ( unit , x , y ) ;
108766: LD_VAR 0 2
108770: PPUSH
108771: LD_VAR 0 4
108775: PPUSH
108776: LD_VAR 0 5
108780: PPUSH
108781: CALL 111840 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108785: LD_VAR 0 1
108789: PUSH
108790: LD_INT 252
108792: EQUAL
108793: PUSH
108794: LD_VAR 0 2
108798: PPUSH
108799: CALL_OW 264
108803: PUSH
108804: LD_INT 81
108806: EQUAL
108807: AND
108808: IFFALSE 108829
// MinerCreateMinefield ( unit , x , y ) ;
108810: LD_VAR 0 2
108814: PPUSH
108815: LD_VAR 0 4
108819: PPUSH
108820: LD_VAR 0 5
108824: PPUSH
108825: CALL 112257 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108829: LD_VAR 0 1
108833: PUSH
108834: LD_INT 253
108836: EQUAL
108837: PUSH
108838: LD_VAR 0 2
108842: PPUSH
108843: CALL_OW 257
108847: PUSH
108848: LD_INT 5
108850: EQUAL
108851: AND
108852: IFFALSE 108873
// ComBinocular ( unit , x , y ) ;
108854: LD_VAR 0 2
108858: PPUSH
108859: LD_VAR 0 4
108863: PPUSH
108864: LD_VAR 0 5
108868: PPUSH
108869: CALL 112626 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108873: LD_VAR 0 1
108877: PUSH
108878: LD_INT 254
108880: EQUAL
108881: PUSH
108882: LD_VAR 0 2
108886: PPUSH
108887: CALL_OW 264
108891: PUSH
108892: LD_INT 99
108894: EQUAL
108895: AND
108896: PUSH
108897: LD_VAR 0 3
108901: PPUSH
108902: CALL_OW 263
108906: PUSH
108907: LD_INT 3
108909: EQUAL
108910: AND
108911: IFFALSE 108927
// HackDestroyVehicle ( unit , selectedUnit ) ;
108913: LD_VAR 0 2
108917: PPUSH
108918: LD_VAR 0 3
108922: PPUSH
108923: CALL 110929 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108927: LD_VAR 0 1
108931: PUSH
108932: LD_INT 255
108934: EQUAL
108935: PUSH
108936: LD_VAR 0 2
108940: PPUSH
108941: CALL_OW 264
108945: PUSH
108946: LD_INT 14
108948: PUSH
108949: LD_INT 53
108951: PUSH
108952: EMPTY
108953: LIST
108954: LIST
108955: IN
108956: AND
108957: PUSH
108958: LD_VAR 0 4
108962: PPUSH
108963: LD_VAR 0 5
108967: PPUSH
108968: CALL_OW 488
108972: AND
108973: IFFALSE 108997
// CutTreeXYR ( unit , x , y , 12 ) ;
108975: LD_VAR 0 2
108979: PPUSH
108980: LD_VAR 0 4
108984: PPUSH
108985: LD_VAR 0 5
108989: PPUSH
108990: LD_INT 12
108992: PPUSH
108993: CALL 109092 0 4
// if cmd = 256 then
108997: LD_VAR 0 1
109001: PUSH
109002: LD_INT 256
109004: EQUAL
109005: IFFALSE 109026
// SetFactoryWaypoint ( unit , x , y ) ;
109007: LD_VAR 0 2
109011: PPUSH
109012: LD_VAR 0 4
109016: PPUSH
109017: LD_VAR 0 5
109021: PPUSH
109022: CALL 107007 0 3
// if cmd = 257 then
109026: LD_VAR 0 1
109030: PUSH
109031: LD_INT 257
109033: EQUAL
109034: IFFALSE 109055
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109036: LD_VAR 0 2
109040: PPUSH
109041: LD_VAR 0 4
109045: PPUSH
109046: LD_VAR 0 5
109050: PPUSH
109051: CALL 107369 0 3
// if cmd = 258 then
109055: LD_VAR 0 1
109059: PUSH
109060: LD_INT 258
109062: EQUAL
109063: IFFALSE 109087
// BurnTreeXYR ( unit , x , y , 8 ) ;
109065: LD_VAR 0 2
109069: PPUSH
109070: LD_VAR 0 4
109074: PPUSH
109075: LD_VAR 0 5
109079: PPUSH
109080: LD_INT 8
109082: PPUSH
109083: CALL 109486 0 4
// end ;
109087: LD_VAR 0 6
109091: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109092: LD_INT 0
109094: PPUSH
109095: PPUSH
109096: PPUSH
109097: PPUSH
109098: PPUSH
109099: PPUSH
109100: PPUSH
109101: PPUSH
109102: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
109103: LD_VAR 0 1
109107: PPUSH
109108: CALL_OW 302
109112: NOT
109113: PUSH
109114: LD_VAR 0 2
109118: PPUSH
109119: LD_VAR 0 3
109123: PPUSH
109124: CALL_OW 488
109128: NOT
109129: OR
109130: PUSH
109131: LD_VAR 0 4
109135: NOT
109136: OR
109137: IFFALSE 109141
// exit ;
109139: GO 109481
// list := [ ] ;
109141: LD_ADDR_VAR 0 13
109145: PUSH
109146: EMPTY
109147: ST_TO_ADDR
// if x - r < 0 then
109148: LD_VAR 0 2
109152: PUSH
109153: LD_VAR 0 4
109157: MINUS
109158: PUSH
109159: LD_INT 0
109161: LESS
109162: IFFALSE 109174
// min_x := 0 else
109164: LD_ADDR_VAR 0 7
109168: PUSH
109169: LD_INT 0
109171: ST_TO_ADDR
109172: GO 109190
// min_x := x - r ;
109174: LD_ADDR_VAR 0 7
109178: PUSH
109179: LD_VAR 0 2
109183: PUSH
109184: LD_VAR 0 4
109188: MINUS
109189: ST_TO_ADDR
// if y - r < 0 then
109190: LD_VAR 0 3
109194: PUSH
109195: LD_VAR 0 4
109199: MINUS
109200: PUSH
109201: LD_INT 0
109203: LESS
109204: IFFALSE 109216
// min_y := 0 else
109206: LD_ADDR_VAR 0 8
109210: PUSH
109211: LD_INT 0
109213: ST_TO_ADDR
109214: GO 109232
// min_y := y - r ;
109216: LD_ADDR_VAR 0 8
109220: PUSH
109221: LD_VAR 0 3
109225: PUSH
109226: LD_VAR 0 4
109230: MINUS
109231: ST_TO_ADDR
// max_x := x + r ;
109232: LD_ADDR_VAR 0 9
109236: PUSH
109237: LD_VAR 0 2
109241: PUSH
109242: LD_VAR 0 4
109246: PLUS
109247: ST_TO_ADDR
// max_y := y + r ;
109248: LD_ADDR_VAR 0 10
109252: PUSH
109253: LD_VAR 0 3
109257: PUSH
109258: LD_VAR 0 4
109262: PLUS
109263: ST_TO_ADDR
// for _x = min_x to max_x do
109264: LD_ADDR_VAR 0 11
109268: PUSH
109269: DOUBLE
109270: LD_VAR 0 7
109274: DEC
109275: ST_TO_ADDR
109276: LD_VAR 0 9
109280: PUSH
109281: FOR_TO
109282: IFFALSE 109399
// for _y = min_y to max_y do
109284: LD_ADDR_VAR 0 12
109288: PUSH
109289: DOUBLE
109290: LD_VAR 0 8
109294: DEC
109295: ST_TO_ADDR
109296: LD_VAR 0 10
109300: PUSH
109301: FOR_TO
109302: IFFALSE 109395
// begin if not ValidHex ( _x , _y ) then
109304: LD_VAR 0 11
109308: PPUSH
109309: LD_VAR 0 12
109313: PPUSH
109314: CALL_OW 488
109318: NOT
109319: IFFALSE 109323
// continue ;
109321: GO 109301
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109323: LD_VAR 0 11
109327: PPUSH
109328: LD_VAR 0 12
109332: PPUSH
109333: CALL_OW 351
109337: PUSH
109338: LD_VAR 0 11
109342: PPUSH
109343: LD_VAR 0 12
109347: PPUSH
109348: CALL_OW 554
109352: AND
109353: IFFALSE 109393
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109355: LD_ADDR_VAR 0 13
109359: PUSH
109360: LD_VAR 0 13
109364: PPUSH
109365: LD_VAR 0 13
109369: PUSH
109370: LD_INT 1
109372: PLUS
109373: PPUSH
109374: LD_VAR 0 11
109378: PUSH
109379: LD_VAR 0 12
109383: PUSH
109384: EMPTY
109385: LIST
109386: LIST
109387: PPUSH
109388: CALL_OW 2
109392: ST_TO_ADDR
// end ;
109393: GO 109301
109395: POP
109396: POP
109397: GO 109281
109399: POP
109400: POP
// if not list then
109401: LD_VAR 0 13
109405: NOT
109406: IFFALSE 109410
// exit ;
109408: GO 109481
// for i in list do
109410: LD_ADDR_VAR 0 6
109414: PUSH
109415: LD_VAR 0 13
109419: PUSH
109420: FOR_IN
109421: IFFALSE 109479
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109423: LD_VAR 0 1
109427: PPUSH
109428: LD_STRING M
109430: PUSH
109431: LD_VAR 0 6
109435: PUSH
109436: LD_INT 1
109438: ARRAY
109439: PUSH
109440: LD_VAR 0 6
109444: PUSH
109445: LD_INT 2
109447: ARRAY
109448: PUSH
109449: LD_INT 0
109451: PUSH
109452: LD_INT 0
109454: PUSH
109455: LD_INT 0
109457: PUSH
109458: LD_INT 0
109460: PUSH
109461: EMPTY
109462: LIST
109463: LIST
109464: LIST
109465: LIST
109466: LIST
109467: LIST
109468: LIST
109469: PUSH
109470: EMPTY
109471: LIST
109472: PPUSH
109473: CALL_OW 447
109477: GO 109420
109479: POP
109480: POP
// end ;
109481: LD_VAR 0 5
109485: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109486: LD_INT 0
109488: PPUSH
109489: PPUSH
109490: PPUSH
109491: PPUSH
109492: PPUSH
109493: PPUSH
109494: PPUSH
109495: PPUSH
109496: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
109497: LD_VAR 0 1
109501: PPUSH
109502: CALL_OW 302
109506: NOT
109507: PUSH
109508: LD_VAR 0 2
109512: PPUSH
109513: LD_VAR 0 3
109517: PPUSH
109518: CALL_OW 488
109522: NOT
109523: OR
109524: PUSH
109525: LD_VAR 0 4
109529: NOT
109530: OR
109531: IFFALSE 109535
// exit ;
109533: GO 109883
// list := [ ] ;
109535: LD_ADDR_VAR 0 13
109539: PUSH
109540: EMPTY
109541: ST_TO_ADDR
// if x - r < 0 then
109542: LD_VAR 0 2
109546: PUSH
109547: LD_VAR 0 4
109551: MINUS
109552: PUSH
109553: LD_INT 0
109555: LESS
109556: IFFALSE 109568
// min_x := 0 else
109558: LD_ADDR_VAR 0 7
109562: PUSH
109563: LD_INT 0
109565: ST_TO_ADDR
109566: GO 109584
// min_x := x - r ;
109568: LD_ADDR_VAR 0 7
109572: PUSH
109573: LD_VAR 0 2
109577: PUSH
109578: LD_VAR 0 4
109582: MINUS
109583: ST_TO_ADDR
// if y - r < 0 then
109584: LD_VAR 0 3
109588: PUSH
109589: LD_VAR 0 4
109593: MINUS
109594: PUSH
109595: LD_INT 0
109597: LESS
109598: IFFALSE 109610
// min_y := 0 else
109600: LD_ADDR_VAR 0 8
109604: PUSH
109605: LD_INT 0
109607: ST_TO_ADDR
109608: GO 109626
// min_y := y - r ;
109610: LD_ADDR_VAR 0 8
109614: PUSH
109615: LD_VAR 0 3
109619: PUSH
109620: LD_VAR 0 4
109624: MINUS
109625: ST_TO_ADDR
// max_x := x + r ;
109626: LD_ADDR_VAR 0 9
109630: PUSH
109631: LD_VAR 0 2
109635: PUSH
109636: LD_VAR 0 4
109640: PLUS
109641: ST_TO_ADDR
// max_y := y + r ;
109642: LD_ADDR_VAR 0 10
109646: PUSH
109647: LD_VAR 0 3
109651: PUSH
109652: LD_VAR 0 4
109656: PLUS
109657: ST_TO_ADDR
// for _x = min_x to max_x do
109658: LD_ADDR_VAR 0 11
109662: PUSH
109663: DOUBLE
109664: LD_VAR 0 7
109668: DEC
109669: ST_TO_ADDR
109670: LD_VAR 0 9
109674: PUSH
109675: FOR_TO
109676: IFFALSE 109793
// for _y = min_y to max_y do
109678: LD_ADDR_VAR 0 12
109682: PUSH
109683: DOUBLE
109684: LD_VAR 0 8
109688: DEC
109689: ST_TO_ADDR
109690: LD_VAR 0 10
109694: PUSH
109695: FOR_TO
109696: IFFALSE 109789
// begin if not ValidHex ( _x , _y ) then
109698: LD_VAR 0 11
109702: PPUSH
109703: LD_VAR 0 12
109707: PPUSH
109708: CALL_OW 488
109712: NOT
109713: IFFALSE 109717
// continue ;
109715: GO 109695
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109717: LD_VAR 0 11
109721: PPUSH
109722: LD_VAR 0 12
109726: PPUSH
109727: CALL_OW 351
109731: PUSH
109732: LD_VAR 0 11
109736: PPUSH
109737: LD_VAR 0 12
109741: PPUSH
109742: CALL_OW 554
109746: AND
109747: IFFALSE 109787
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109749: LD_ADDR_VAR 0 13
109753: PUSH
109754: LD_VAR 0 13
109758: PPUSH
109759: LD_VAR 0 13
109763: PUSH
109764: LD_INT 1
109766: PLUS
109767: PPUSH
109768: LD_VAR 0 11
109772: PUSH
109773: LD_VAR 0 12
109777: PUSH
109778: EMPTY
109779: LIST
109780: LIST
109781: PPUSH
109782: CALL_OW 2
109786: ST_TO_ADDR
// end ;
109787: GO 109695
109789: POP
109790: POP
109791: GO 109675
109793: POP
109794: POP
// if not list then
109795: LD_VAR 0 13
109799: NOT
109800: IFFALSE 109804
// exit ;
109802: GO 109883
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
109804: LD_ADDR_VAR 0 13
109808: PUSH
109809: LD_VAR 0 1
109813: PPUSH
109814: LD_VAR 0 13
109818: PPUSH
109819: LD_INT 1
109821: PPUSH
109822: LD_INT 1
109824: PPUSH
109825: CALL 25334 0 4
109829: ST_TO_ADDR
// ComStop ( flame ) ;
109830: LD_VAR 0 1
109834: PPUSH
109835: CALL_OW 141
// for i in list do
109839: LD_ADDR_VAR 0 6
109843: PUSH
109844: LD_VAR 0 13
109848: PUSH
109849: FOR_IN
109850: IFFALSE 109881
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
109852: LD_VAR 0 1
109856: PPUSH
109857: LD_VAR 0 6
109861: PUSH
109862: LD_INT 1
109864: ARRAY
109865: PPUSH
109866: LD_VAR 0 6
109870: PUSH
109871: LD_INT 2
109873: ARRAY
109874: PPUSH
109875: CALL_OW 176
109879: GO 109849
109881: POP
109882: POP
// end ;
109883: LD_VAR 0 5
109887: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
109888: LD_EXP 138
109892: NOT
109893: IFFALSE 109943
109895: GO 109897
109897: DISABLE
// begin initHack := true ;
109898: LD_ADDR_EXP 138
109902: PUSH
109903: LD_INT 1
109905: ST_TO_ADDR
// hackTanks := [ ] ;
109906: LD_ADDR_EXP 139
109910: PUSH
109911: EMPTY
109912: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
109913: LD_ADDR_EXP 140
109917: PUSH
109918: EMPTY
109919: ST_TO_ADDR
// hackLimit := 3 ;
109920: LD_ADDR_EXP 141
109924: PUSH
109925: LD_INT 3
109927: ST_TO_ADDR
// hackDist := 12 ;
109928: LD_ADDR_EXP 142
109932: PUSH
109933: LD_INT 12
109935: ST_TO_ADDR
// hackCounter := [ ] ;
109936: LD_ADDR_EXP 143
109940: PUSH
109941: EMPTY
109942: ST_TO_ADDR
// end ;
109943: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
109944: LD_EXP 138
109948: PUSH
109949: LD_INT 34
109951: PUSH
109952: LD_INT 99
109954: PUSH
109955: EMPTY
109956: LIST
109957: LIST
109958: PPUSH
109959: CALL_OW 69
109963: AND
109964: IFFALSE 110217
109966: GO 109968
109968: DISABLE
109969: LD_INT 0
109971: PPUSH
109972: PPUSH
// begin enable ;
109973: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
109974: LD_ADDR_VAR 0 1
109978: PUSH
109979: LD_INT 34
109981: PUSH
109982: LD_INT 99
109984: PUSH
109985: EMPTY
109986: LIST
109987: LIST
109988: PPUSH
109989: CALL_OW 69
109993: PUSH
109994: FOR_IN
109995: IFFALSE 110215
// begin if not i in hackTanks then
109997: LD_VAR 0 1
110001: PUSH
110002: LD_EXP 139
110006: IN
110007: NOT
110008: IFFALSE 110091
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110010: LD_ADDR_EXP 139
110014: PUSH
110015: LD_EXP 139
110019: PPUSH
110020: LD_EXP 139
110024: PUSH
110025: LD_INT 1
110027: PLUS
110028: PPUSH
110029: LD_VAR 0 1
110033: PPUSH
110034: CALL_OW 1
110038: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110039: LD_ADDR_EXP 140
110043: PUSH
110044: LD_EXP 140
110048: PPUSH
110049: LD_EXP 140
110053: PUSH
110054: LD_INT 1
110056: PLUS
110057: PPUSH
110058: EMPTY
110059: PPUSH
110060: CALL_OW 1
110064: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110065: LD_ADDR_EXP 143
110069: PUSH
110070: LD_EXP 143
110074: PPUSH
110075: LD_EXP 143
110079: PUSH
110080: LD_INT 1
110082: PLUS
110083: PPUSH
110084: EMPTY
110085: PPUSH
110086: CALL_OW 1
110090: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110091: LD_VAR 0 1
110095: PPUSH
110096: CALL_OW 302
110100: NOT
110101: IFFALSE 110114
// begin HackUnlinkAll ( i ) ;
110103: LD_VAR 0 1
110107: PPUSH
110108: CALL 110220 0 1
// continue ;
110112: GO 109994
// end ; HackCheckCapturedStatus ( i ) ;
110114: LD_VAR 0 1
110118: PPUSH
110119: CALL 110663 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110123: LD_ADDR_VAR 0 2
110127: PUSH
110128: LD_INT 81
110130: PUSH
110131: LD_VAR 0 1
110135: PPUSH
110136: CALL_OW 255
110140: PUSH
110141: EMPTY
110142: LIST
110143: LIST
110144: PUSH
110145: LD_INT 33
110147: PUSH
110148: LD_INT 3
110150: PUSH
110151: EMPTY
110152: LIST
110153: LIST
110154: PUSH
110155: LD_INT 91
110157: PUSH
110158: LD_VAR 0 1
110162: PUSH
110163: LD_EXP 142
110167: PUSH
110168: EMPTY
110169: LIST
110170: LIST
110171: LIST
110172: PUSH
110173: LD_INT 50
110175: PUSH
110176: EMPTY
110177: LIST
110178: PUSH
110179: EMPTY
110180: LIST
110181: LIST
110182: LIST
110183: LIST
110184: PPUSH
110185: CALL_OW 69
110189: ST_TO_ADDR
// if not tmp then
110190: LD_VAR 0 2
110194: NOT
110195: IFFALSE 110199
// continue ;
110197: GO 109994
// HackLink ( i , tmp ) ;
110199: LD_VAR 0 1
110203: PPUSH
110204: LD_VAR 0 2
110208: PPUSH
110209: CALL 110356 0 2
// end ;
110213: GO 109994
110215: POP
110216: POP
// end ;
110217: PPOPN 2
110219: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110220: LD_INT 0
110222: PPUSH
110223: PPUSH
110224: PPUSH
// if not hack in hackTanks then
110225: LD_VAR 0 1
110229: PUSH
110230: LD_EXP 139
110234: IN
110235: NOT
110236: IFFALSE 110240
// exit ;
110238: GO 110351
// index := GetElementIndex ( hackTanks , hack ) ;
110240: LD_ADDR_VAR 0 4
110244: PUSH
110245: LD_EXP 139
110249: PPUSH
110250: LD_VAR 0 1
110254: PPUSH
110255: CALL 24631 0 2
110259: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110260: LD_EXP 140
110264: PUSH
110265: LD_VAR 0 4
110269: ARRAY
110270: IFFALSE 110351
// begin for i in hackTanksCaptured [ index ] do
110272: LD_ADDR_VAR 0 3
110276: PUSH
110277: LD_EXP 140
110281: PUSH
110282: LD_VAR 0 4
110286: ARRAY
110287: PUSH
110288: FOR_IN
110289: IFFALSE 110315
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110291: LD_VAR 0 3
110295: PUSH
110296: LD_INT 1
110298: ARRAY
110299: PPUSH
110300: LD_VAR 0 3
110304: PUSH
110305: LD_INT 2
110307: ARRAY
110308: PPUSH
110309: CALL_OW 235
110313: GO 110288
110315: POP
110316: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110317: LD_ADDR_EXP 140
110321: PUSH
110322: LD_EXP 140
110326: PPUSH
110327: LD_VAR 0 4
110331: PPUSH
110332: EMPTY
110333: PPUSH
110334: CALL_OW 1
110338: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110339: LD_VAR 0 1
110343: PPUSH
110344: LD_INT 0
110346: PPUSH
110347: CALL_OW 505
// end ; end ;
110351: LD_VAR 0 2
110355: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110356: LD_INT 0
110358: PPUSH
110359: PPUSH
110360: PPUSH
// if not hack in hackTanks or not vehicles then
110361: LD_VAR 0 1
110365: PUSH
110366: LD_EXP 139
110370: IN
110371: NOT
110372: PUSH
110373: LD_VAR 0 2
110377: NOT
110378: OR
110379: IFFALSE 110383
// exit ;
110381: GO 110658
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110383: LD_ADDR_VAR 0 2
110387: PUSH
110388: LD_VAR 0 1
110392: PPUSH
110393: LD_VAR 0 2
110397: PPUSH
110398: LD_INT 1
110400: PPUSH
110401: LD_INT 1
110403: PPUSH
110404: CALL 25281 0 4
110408: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110409: LD_ADDR_VAR 0 5
110413: PUSH
110414: LD_EXP 139
110418: PPUSH
110419: LD_VAR 0 1
110423: PPUSH
110424: CALL 24631 0 2
110428: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110429: LD_EXP 140
110433: PUSH
110434: LD_VAR 0 5
110438: ARRAY
110439: PUSH
110440: LD_EXP 141
110444: LESS
110445: IFFALSE 110634
// begin for i := 1 to vehicles do
110447: LD_ADDR_VAR 0 4
110451: PUSH
110452: DOUBLE
110453: LD_INT 1
110455: DEC
110456: ST_TO_ADDR
110457: LD_VAR 0 2
110461: PUSH
110462: FOR_TO
110463: IFFALSE 110632
// begin if hackTanksCaptured [ index ] = hackLimit then
110465: LD_EXP 140
110469: PUSH
110470: LD_VAR 0 5
110474: ARRAY
110475: PUSH
110476: LD_EXP 141
110480: EQUAL
110481: IFFALSE 110485
// break ;
110483: GO 110632
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110485: LD_ADDR_EXP 143
110489: PUSH
110490: LD_EXP 143
110494: PPUSH
110495: LD_VAR 0 5
110499: PPUSH
110500: LD_EXP 143
110504: PUSH
110505: LD_VAR 0 5
110509: ARRAY
110510: PUSH
110511: LD_INT 1
110513: PLUS
110514: PPUSH
110515: CALL_OW 1
110519: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110520: LD_ADDR_EXP 140
110524: PUSH
110525: LD_EXP 140
110529: PPUSH
110530: LD_VAR 0 5
110534: PUSH
110535: LD_EXP 140
110539: PUSH
110540: LD_VAR 0 5
110544: ARRAY
110545: PUSH
110546: LD_INT 1
110548: PLUS
110549: PUSH
110550: EMPTY
110551: LIST
110552: LIST
110553: PPUSH
110554: LD_VAR 0 2
110558: PUSH
110559: LD_VAR 0 4
110563: ARRAY
110564: PUSH
110565: LD_VAR 0 2
110569: PUSH
110570: LD_VAR 0 4
110574: ARRAY
110575: PPUSH
110576: CALL_OW 255
110580: PUSH
110581: EMPTY
110582: LIST
110583: LIST
110584: PPUSH
110585: CALL 24846 0 3
110589: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110590: LD_VAR 0 2
110594: PUSH
110595: LD_VAR 0 4
110599: ARRAY
110600: PPUSH
110601: LD_VAR 0 1
110605: PPUSH
110606: CALL_OW 255
110610: PPUSH
110611: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110615: LD_VAR 0 2
110619: PUSH
110620: LD_VAR 0 4
110624: ARRAY
110625: PPUSH
110626: CALL_OW 141
// end ;
110630: GO 110462
110632: POP
110633: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110634: LD_VAR 0 1
110638: PPUSH
110639: LD_EXP 140
110643: PUSH
110644: LD_VAR 0 5
110648: ARRAY
110649: PUSH
110650: LD_INT 0
110652: PLUS
110653: PPUSH
110654: CALL_OW 505
// end ;
110658: LD_VAR 0 3
110662: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110663: LD_INT 0
110665: PPUSH
110666: PPUSH
110667: PPUSH
110668: PPUSH
// if not hack in hackTanks then
110669: LD_VAR 0 1
110673: PUSH
110674: LD_EXP 139
110678: IN
110679: NOT
110680: IFFALSE 110684
// exit ;
110682: GO 110924
// index := GetElementIndex ( hackTanks , hack ) ;
110684: LD_ADDR_VAR 0 4
110688: PUSH
110689: LD_EXP 139
110693: PPUSH
110694: LD_VAR 0 1
110698: PPUSH
110699: CALL 24631 0 2
110703: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
110704: LD_ADDR_VAR 0 3
110708: PUSH
110709: DOUBLE
110710: LD_EXP 140
110714: PUSH
110715: LD_VAR 0 4
110719: ARRAY
110720: INC
110721: ST_TO_ADDR
110722: LD_INT 1
110724: PUSH
110725: FOR_DOWNTO
110726: IFFALSE 110898
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
110728: LD_ADDR_VAR 0 5
110732: PUSH
110733: LD_EXP 140
110737: PUSH
110738: LD_VAR 0 4
110742: ARRAY
110743: PUSH
110744: LD_VAR 0 3
110748: ARRAY
110749: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
110750: LD_VAR 0 5
110754: PUSH
110755: LD_INT 1
110757: ARRAY
110758: PPUSH
110759: CALL_OW 302
110763: NOT
110764: PUSH
110765: LD_VAR 0 5
110769: PUSH
110770: LD_INT 1
110772: ARRAY
110773: PPUSH
110774: CALL_OW 255
110778: PUSH
110779: LD_VAR 0 1
110783: PPUSH
110784: CALL_OW 255
110788: NONEQUAL
110789: OR
110790: IFFALSE 110896
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
110792: LD_VAR 0 5
110796: PUSH
110797: LD_INT 1
110799: ARRAY
110800: PPUSH
110801: CALL_OW 305
110805: PUSH
110806: LD_VAR 0 5
110810: PUSH
110811: LD_INT 1
110813: ARRAY
110814: PPUSH
110815: CALL_OW 255
110819: PUSH
110820: LD_VAR 0 1
110824: PPUSH
110825: CALL_OW 255
110829: EQUAL
110830: AND
110831: IFFALSE 110855
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
110833: LD_VAR 0 5
110837: PUSH
110838: LD_INT 1
110840: ARRAY
110841: PPUSH
110842: LD_VAR 0 5
110846: PUSH
110847: LD_INT 2
110849: ARRAY
110850: PPUSH
110851: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
110855: LD_ADDR_EXP 140
110859: PUSH
110860: LD_EXP 140
110864: PPUSH
110865: LD_VAR 0 4
110869: PPUSH
110870: LD_EXP 140
110874: PUSH
110875: LD_VAR 0 4
110879: ARRAY
110880: PPUSH
110881: LD_VAR 0 3
110885: PPUSH
110886: CALL_OW 3
110890: PPUSH
110891: CALL_OW 1
110895: ST_TO_ADDR
// end ; end ;
110896: GO 110725
110898: POP
110899: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110900: LD_VAR 0 1
110904: PPUSH
110905: LD_EXP 140
110909: PUSH
110910: LD_VAR 0 4
110914: ARRAY
110915: PUSH
110916: LD_INT 0
110918: PLUS
110919: PPUSH
110920: CALL_OW 505
// end ;
110924: LD_VAR 0 2
110928: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
110929: LD_INT 0
110931: PPUSH
110932: PPUSH
110933: PPUSH
110934: PPUSH
// if not hack in hackTanks then
110935: LD_VAR 0 1
110939: PUSH
110940: LD_EXP 139
110944: IN
110945: NOT
110946: IFFALSE 110950
// exit ;
110948: GO 111035
// index := GetElementIndex ( hackTanks , hack ) ;
110950: LD_ADDR_VAR 0 5
110954: PUSH
110955: LD_EXP 139
110959: PPUSH
110960: LD_VAR 0 1
110964: PPUSH
110965: CALL 24631 0 2
110969: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
110970: LD_ADDR_VAR 0 4
110974: PUSH
110975: DOUBLE
110976: LD_INT 1
110978: DEC
110979: ST_TO_ADDR
110980: LD_EXP 140
110984: PUSH
110985: LD_VAR 0 5
110989: ARRAY
110990: PUSH
110991: FOR_TO
110992: IFFALSE 111033
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
110994: LD_EXP 140
110998: PUSH
110999: LD_VAR 0 5
111003: ARRAY
111004: PUSH
111005: LD_VAR 0 4
111009: ARRAY
111010: PUSH
111011: LD_INT 1
111013: ARRAY
111014: PUSH
111015: LD_VAR 0 2
111019: EQUAL
111020: IFFALSE 111031
// KillUnit ( vehicle ) ;
111022: LD_VAR 0 2
111026: PPUSH
111027: CALL_OW 66
111031: GO 110991
111033: POP
111034: POP
// end ;
111035: LD_VAR 0 3
111039: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
111040: LD_EXP 144
111044: NOT
111045: IFFALSE 111080
111047: GO 111049
111049: DISABLE
// begin initMiner := true ;
111050: LD_ADDR_EXP 144
111054: PUSH
111055: LD_INT 1
111057: ST_TO_ADDR
// minersList := [ ] ;
111058: LD_ADDR_EXP 145
111062: PUSH
111063: EMPTY
111064: ST_TO_ADDR
// minerMinesList := [ ] ;
111065: LD_ADDR_EXP 146
111069: PUSH
111070: EMPTY
111071: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111072: LD_ADDR_EXP 147
111076: PUSH
111077: LD_INT 5
111079: ST_TO_ADDR
// end ;
111080: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111081: LD_EXP 144
111085: PUSH
111086: LD_INT 34
111088: PUSH
111089: LD_INT 81
111091: PUSH
111092: EMPTY
111093: LIST
111094: LIST
111095: PPUSH
111096: CALL_OW 69
111100: AND
111101: IFFALSE 111562
111103: GO 111105
111105: DISABLE
111106: LD_INT 0
111108: PPUSH
111109: PPUSH
111110: PPUSH
111111: PPUSH
// begin enable ;
111112: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111113: LD_ADDR_VAR 0 1
111117: PUSH
111118: LD_INT 34
111120: PUSH
111121: LD_INT 81
111123: PUSH
111124: EMPTY
111125: LIST
111126: LIST
111127: PPUSH
111128: CALL_OW 69
111132: PUSH
111133: FOR_IN
111134: IFFALSE 111206
// begin if not i in minersList then
111136: LD_VAR 0 1
111140: PUSH
111141: LD_EXP 145
111145: IN
111146: NOT
111147: IFFALSE 111204
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111149: LD_ADDR_EXP 145
111153: PUSH
111154: LD_EXP 145
111158: PPUSH
111159: LD_EXP 145
111163: PUSH
111164: LD_INT 1
111166: PLUS
111167: PPUSH
111168: LD_VAR 0 1
111172: PPUSH
111173: CALL_OW 1
111177: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111178: LD_ADDR_EXP 146
111182: PUSH
111183: LD_EXP 146
111187: PPUSH
111188: LD_EXP 146
111192: PUSH
111193: LD_INT 1
111195: PLUS
111196: PPUSH
111197: EMPTY
111198: PPUSH
111199: CALL_OW 1
111203: ST_TO_ADDR
// end end ;
111204: GO 111133
111206: POP
111207: POP
// for i := minerMinesList downto 1 do
111208: LD_ADDR_VAR 0 1
111212: PUSH
111213: DOUBLE
111214: LD_EXP 146
111218: INC
111219: ST_TO_ADDR
111220: LD_INT 1
111222: PUSH
111223: FOR_DOWNTO
111224: IFFALSE 111560
// begin if IsLive ( minersList [ i ] ) then
111226: LD_EXP 145
111230: PUSH
111231: LD_VAR 0 1
111235: ARRAY
111236: PPUSH
111237: CALL_OW 300
111241: IFFALSE 111269
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111243: LD_EXP 145
111247: PUSH
111248: LD_VAR 0 1
111252: ARRAY
111253: PPUSH
111254: LD_EXP 146
111258: PUSH
111259: LD_VAR 0 1
111263: ARRAY
111264: PPUSH
111265: CALL_OW 505
// if not minerMinesList [ i ] then
111269: LD_EXP 146
111273: PUSH
111274: LD_VAR 0 1
111278: ARRAY
111279: NOT
111280: IFFALSE 111284
// continue ;
111282: GO 111223
// for j := minerMinesList [ i ] downto 1 do
111284: LD_ADDR_VAR 0 2
111288: PUSH
111289: DOUBLE
111290: LD_EXP 146
111294: PUSH
111295: LD_VAR 0 1
111299: ARRAY
111300: INC
111301: ST_TO_ADDR
111302: LD_INT 1
111304: PUSH
111305: FOR_DOWNTO
111306: IFFALSE 111556
// begin side := GetSide ( minersList [ i ] ) ;
111308: LD_ADDR_VAR 0 3
111312: PUSH
111313: LD_EXP 145
111317: PUSH
111318: LD_VAR 0 1
111322: ARRAY
111323: PPUSH
111324: CALL_OW 255
111328: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111329: LD_ADDR_VAR 0 4
111333: PUSH
111334: LD_EXP 146
111338: PUSH
111339: LD_VAR 0 1
111343: ARRAY
111344: PUSH
111345: LD_VAR 0 2
111349: ARRAY
111350: PUSH
111351: LD_INT 1
111353: ARRAY
111354: PPUSH
111355: LD_EXP 146
111359: PUSH
111360: LD_VAR 0 1
111364: ARRAY
111365: PUSH
111366: LD_VAR 0 2
111370: ARRAY
111371: PUSH
111372: LD_INT 2
111374: ARRAY
111375: PPUSH
111376: CALL_OW 428
111380: ST_TO_ADDR
// if not tmp then
111381: LD_VAR 0 4
111385: NOT
111386: IFFALSE 111390
// continue ;
111388: GO 111305
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111390: LD_VAR 0 4
111394: PUSH
111395: LD_INT 81
111397: PUSH
111398: LD_VAR 0 3
111402: PUSH
111403: EMPTY
111404: LIST
111405: LIST
111406: PPUSH
111407: CALL_OW 69
111411: IN
111412: PUSH
111413: LD_EXP 146
111417: PUSH
111418: LD_VAR 0 1
111422: ARRAY
111423: PUSH
111424: LD_VAR 0 2
111428: ARRAY
111429: PUSH
111430: LD_INT 1
111432: ARRAY
111433: PPUSH
111434: LD_EXP 146
111438: PUSH
111439: LD_VAR 0 1
111443: ARRAY
111444: PUSH
111445: LD_VAR 0 2
111449: ARRAY
111450: PUSH
111451: LD_INT 2
111453: ARRAY
111454: PPUSH
111455: CALL_OW 458
111459: AND
111460: IFFALSE 111554
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111462: LD_EXP 146
111466: PUSH
111467: LD_VAR 0 1
111471: ARRAY
111472: PUSH
111473: LD_VAR 0 2
111477: ARRAY
111478: PUSH
111479: LD_INT 1
111481: ARRAY
111482: PPUSH
111483: LD_EXP 146
111487: PUSH
111488: LD_VAR 0 1
111492: ARRAY
111493: PUSH
111494: LD_VAR 0 2
111498: ARRAY
111499: PUSH
111500: LD_INT 2
111502: ARRAY
111503: PPUSH
111504: LD_VAR 0 3
111508: PPUSH
111509: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111513: LD_ADDR_EXP 146
111517: PUSH
111518: LD_EXP 146
111522: PPUSH
111523: LD_VAR 0 1
111527: PPUSH
111528: LD_EXP 146
111532: PUSH
111533: LD_VAR 0 1
111537: ARRAY
111538: PPUSH
111539: LD_VAR 0 2
111543: PPUSH
111544: CALL_OW 3
111548: PPUSH
111549: CALL_OW 1
111553: ST_TO_ADDR
// end ; end ;
111554: GO 111305
111556: POP
111557: POP
// end ;
111558: GO 111223
111560: POP
111561: POP
// end ;
111562: PPOPN 4
111564: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111565: LD_INT 0
111567: PPUSH
111568: PPUSH
// result := false ;
111569: LD_ADDR_VAR 0 4
111573: PUSH
111574: LD_INT 0
111576: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111577: LD_VAR 0 1
111581: PPUSH
111582: CALL_OW 264
111586: PUSH
111587: LD_INT 81
111589: EQUAL
111590: NOT
111591: IFFALSE 111595
// exit ;
111593: GO 111835
// index := GetElementIndex ( minersList , unit ) ;
111595: LD_ADDR_VAR 0 5
111599: PUSH
111600: LD_EXP 145
111604: PPUSH
111605: LD_VAR 0 1
111609: PPUSH
111610: CALL 24631 0 2
111614: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111615: LD_EXP 146
111619: PUSH
111620: LD_VAR 0 5
111624: ARRAY
111625: PUSH
111626: LD_EXP 147
111630: GREATEREQUAL
111631: IFFALSE 111635
// exit ;
111633: GO 111835
// ComMoveXY ( unit , x , y ) ;
111635: LD_VAR 0 1
111639: PPUSH
111640: LD_VAR 0 2
111644: PPUSH
111645: LD_VAR 0 3
111649: PPUSH
111650: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111654: LD_INT 35
111656: PPUSH
111657: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111661: LD_VAR 0 1
111665: PPUSH
111666: LD_VAR 0 2
111670: PPUSH
111671: LD_VAR 0 3
111675: PPUSH
111676: CALL 56383 0 3
111680: NOT
111681: PUSH
111682: LD_VAR 0 1
111686: PPUSH
111687: CALL_OW 314
111691: AND
111692: IFFALSE 111696
// exit ;
111694: GO 111835
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
111696: LD_VAR 0 2
111700: PPUSH
111701: LD_VAR 0 3
111705: PPUSH
111706: CALL_OW 428
111710: PUSH
111711: LD_VAR 0 1
111715: EQUAL
111716: PUSH
111717: LD_VAR 0 1
111721: PPUSH
111722: CALL_OW 314
111726: NOT
111727: AND
111728: IFFALSE 111654
// PlaySoundXY ( x , y , PlantMine ) ;
111730: LD_VAR 0 2
111734: PPUSH
111735: LD_VAR 0 3
111739: PPUSH
111740: LD_STRING PlantMine
111742: PPUSH
111743: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
111747: LD_VAR 0 2
111751: PPUSH
111752: LD_VAR 0 3
111756: PPUSH
111757: LD_VAR 0 1
111761: PPUSH
111762: CALL_OW 255
111766: PPUSH
111767: LD_INT 0
111769: PPUSH
111770: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
111774: LD_ADDR_EXP 146
111778: PUSH
111779: LD_EXP 146
111783: PPUSH
111784: LD_VAR 0 5
111788: PUSH
111789: LD_EXP 146
111793: PUSH
111794: LD_VAR 0 5
111798: ARRAY
111799: PUSH
111800: LD_INT 1
111802: PLUS
111803: PUSH
111804: EMPTY
111805: LIST
111806: LIST
111807: PPUSH
111808: LD_VAR 0 2
111812: PUSH
111813: LD_VAR 0 3
111817: PUSH
111818: EMPTY
111819: LIST
111820: LIST
111821: PPUSH
111822: CALL 24846 0 3
111826: ST_TO_ADDR
// result := true ;
111827: LD_ADDR_VAR 0 4
111831: PUSH
111832: LD_INT 1
111834: ST_TO_ADDR
// end ;
111835: LD_VAR 0 4
111839: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
111840: LD_INT 0
111842: PPUSH
111843: PPUSH
111844: PPUSH
// if not unit in minersList then
111845: LD_VAR 0 1
111849: PUSH
111850: LD_EXP 145
111854: IN
111855: NOT
111856: IFFALSE 111860
// exit ;
111858: GO 112252
// index := GetElementIndex ( minersList , unit ) ;
111860: LD_ADDR_VAR 0 6
111864: PUSH
111865: LD_EXP 145
111869: PPUSH
111870: LD_VAR 0 1
111874: PPUSH
111875: CALL 24631 0 2
111879: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
111880: LD_ADDR_VAR 0 5
111884: PUSH
111885: DOUBLE
111886: LD_EXP 146
111890: PUSH
111891: LD_VAR 0 6
111895: ARRAY
111896: INC
111897: ST_TO_ADDR
111898: LD_INT 1
111900: PUSH
111901: FOR_DOWNTO
111902: IFFALSE 112063
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
111904: LD_EXP 146
111908: PUSH
111909: LD_VAR 0 6
111913: ARRAY
111914: PUSH
111915: LD_VAR 0 5
111919: ARRAY
111920: PUSH
111921: LD_INT 1
111923: ARRAY
111924: PUSH
111925: LD_VAR 0 2
111929: EQUAL
111930: PUSH
111931: LD_EXP 146
111935: PUSH
111936: LD_VAR 0 6
111940: ARRAY
111941: PUSH
111942: LD_VAR 0 5
111946: ARRAY
111947: PUSH
111948: LD_INT 2
111950: ARRAY
111951: PUSH
111952: LD_VAR 0 3
111956: EQUAL
111957: AND
111958: IFFALSE 112061
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111960: LD_EXP 146
111964: PUSH
111965: LD_VAR 0 6
111969: ARRAY
111970: PUSH
111971: LD_VAR 0 5
111975: ARRAY
111976: PUSH
111977: LD_INT 1
111979: ARRAY
111980: PPUSH
111981: LD_EXP 146
111985: PUSH
111986: LD_VAR 0 6
111990: ARRAY
111991: PUSH
111992: LD_VAR 0 5
111996: ARRAY
111997: PUSH
111998: LD_INT 2
112000: ARRAY
112001: PPUSH
112002: LD_VAR 0 1
112006: PPUSH
112007: CALL_OW 255
112011: PPUSH
112012: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112016: LD_ADDR_EXP 146
112020: PUSH
112021: LD_EXP 146
112025: PPUSH
112026: LD_VAR 0 6
112030: PPUSH
112031: LD_EXP 146
112035: PUSH
112036: LD_VAR 0 6
112040: ARRAY
112041: PPUSH
112042: LD_VAR 0 5
112046: PPUSH
112047: CALL_OW 3
112051: PPUSH
112052: CALL_OW 1
112056: ST_TO_ADDR
// exit ;
112057: POP
112058: POP
112059: GO 112252
// end ; end ;
112061: GO 111901
112063: POP
112064: POP
// for i := minerMinesList [ index ] downto 1 do
112065: LD_ADDR_VAR 0 5
112069: PUSH
112070: DOUBLE
112071: LD_EXP 146
112075: PUSH
112076: LD_VAR 0 6
112080: ARRAY
112081: INC
112082: ST_TO_ADDR
112083: LD_INT 1
112085: PUSH
112086: FOR_DOWNTO
112087: IFFALSE 112250
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112089: LD_EXP 146
112093: PUSH
112094: LD_VAR 0 6
112098: ARRAY
112099: PUSH
112100: LD_VAR 0 5
112104: ARRAY
112105: PUSH
112106: LD_INT 1
112108: ARRAY
112109: PPUSH
112110: LD_EXP 146
112114: PUSH
112115: LD_VAR 0 6
112119: ARRAY
112120: PUSH
112121: LD_VAR 0 5
112125: ARRAY
112126: PUSH
112127: LD_INT 2
112129: ARRAY
112130: PPUSH
112131: LD_VAR 0 2
112135: PPUSH
112136: LD_VAR 0 3
112140: PPUSH
112141: CALL_OW 298
112145: PUSH
112146: LD_INT 6
112148: LESS
112149: IFFALSE 112248
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112151: LD_EXP 146
112155: PUSH
112156: LD_VAR 0 6
112160: ARRAY
112161: PUSH
112162: LD_VAR 0 5
112166: ARRAY
112167: PUSH
112168: LD_INT 1
112170: ARRAY
112171: PPUSH
112172: LD_EXP 146
112176: PUSH
112177: LD_VAR 0 6
112181: ARRAY
112182: PUSH
112183: LD_VAR 0 5
112187: ARRAY
112188: PUSH
112189: LD_INT 2
112191: ARRAY
112192: PPUSH
112193: LD_VAR 0 1
112197: PPUSH
112198: CALL_OW 255
112202: PPUSH
112203: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112207: LD_ADDR_EXP 146
112211: PUSH
112212: LD_EXP 146
112216: PPUSH
112217: LD_VAR 0 6
112221: PPUSH
112222: LD_EXP 146
112226: PUSH
112227: LD_VAR 0 6
112231: ARRAY
112232: PPUSH
112233: LD_VAR 0 5
112237: PPUSH
112238: CALL_OW 3
112242: PPUSH
112243: CALL_OW 1
112247: ST_TO_ADDR
// end ; end ;
112248: GO 112086
112250: POP
112251: POP
// end ;
112252: LD_VAR 0 4
112256: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112257: LD_INT 0
112259: PPUSH
112260: PPUSH
112261: PPUSH
112262: PPUSH
112263: PPUSH
112264: PPUSH
112265: PPUSH
112266: PPUSH
112267: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112268: LD_VAR 0 1
112272: PPUSH
112273: CALL_OW 264
112277: PUSH
112278: LD_INT 81
112280: EQUAL
112281: NOT
112282: PUSH
112283: LD_VAR 0 1
112287: PUSH
112288: LD_EXP 145
112292: IN
112293: NOT
112294: OR
112295: IFFALSE 112299
// exit ;
112297: GO 112621
// index := GetElementIndex ( minersList , unit ) ;
112299: LD_ADDR_VAR 0 6
112303: PUSH
112304: LD_EXP 145
112308: PPUSH
112309: LD_VAR 0 1
112313: PPUSH
112314: CALL 24631 0 2
112318: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112319: LD_ADDR_VAR 0 8
112323: PUSH
112324: LD_EXP 147
112328: PUSH
112329: LD_EXP 146
112333: PUSH
112334: LD_VAR 0 6
112338: ARRAY
112339: MINUS
112340: ST_TO_ADDR
// if not minesFreeAmount then
112341: LD_VAR 0 8
112345: NOT
112346: IFFALSE 112350
// exit ;
112348: GO 112621
// tmp := [ ] ;
112350: LD_ADDR_VAR 0 7
112354: PUSH
112355: EMPTY
112356: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112357: LD_ADDR_VAR 0 5
112361: PUSH
112362: DOUBLE
112363: LD_INT 1
112365: DEC
112366: ST_TO_ADDR
112367: LD_VAR 0 8
112371: PUSH
112372: FOR_TO
112373: IFFALSE 112568
// begin _d := rand ( 0 , 5 ) ;
112375: LD_ADDR_VAR 0 11
112379: PUSH
112380: LD_INT 0
112382: PPUSH
112383: LD_INT 5
112385: PPUSH
112386: CALL_OW 12
112390: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112391: LD_ADDR_VAR 0 12
112395: PUSH
112396: LD_INT 2
112398: PPUSH
112399: LD_INT 6
112401: PPUSH
112402: CALL_OW 12
112406: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112407: LD_ADDR_VAR 0 9
112411: PUSH
112412: LD_VAR 0 2
112416: PPUSH
112417: LD_VAR 0 11
112421: PPUSH
112422: LD_VAR 0 12
112426: PPUSH
112427: CALL_OW 272
112431: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112432: LD_ADDR_VAR 0 10
112436: PUSH
112437: LD_VAR 0 3
112441: PPUSH
112442: LD_VAR 0 11
112446: PPUSH
112447: LD_VAR 0 12
112451: PPUSH
112452: CALL_OW 273
112456: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112457: LD_VAR 0 9
112461: PPUSH
112462: LD_VAR 0 10
112466: PPUSH
112467: CALL_OW 488
112471: PUSH
112472: LD_VAR 0 9
112476: PUSH
112477: LD_VAR 0 10
112481: PUSH
112482: EMPTY
112483: LIST
112484: LIST
112485: PUSH
112486: LD_VAR 0 7
112490: IN
112491: NOT
112492: AND
112493: PUSH
112494: LD_VAR 0 9
112498: PPUSH
112499: LD_VAR 0 10
112503: PPUSH
112504: CALL_OW 458
112508: NOT
112509: AND
112510: IFFALSE 112552
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112512: LD_ADDR_VAR 0 7
112516: PUSH
112517: LD_VAR 0 7
112521: PPUSH
112522: LD_VAR 0 7
112526: PUSH
112527: LD_INT 1
112529: PLUS
112530: PPUSH
112531: LD_VAR 0 9
112535: PUSH
112536: LD_VAR 0 10
112540: PUSH
112541: EMPTY
112542: LIST
112543: LIST
112544: PPUSH
112545: CALL_OW 1
112549: ST_TO_ADDR
112550: GO 112566
// i := i - 1 ;
112552: LD_ADDR_VAR 0 5
112556: PUSH
112557: LD_VAR 0 5
112561: PUSH
112562: LD_INT 1
112564: MINUS
112565: ST_TO_ADDR
// end ;
112566: GO 112372
112568: POP
112569: POP
// for i in tmp do
112570: LD_ADDR_VAR 0 5
112574: PUSH
112575: LD_VAR 0 7
112579: PUSH
112580: FOR_IN
112581: IFFALSE 112619
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112583: LD_VAR 0 1
112587: PPUSH
112588: LD_VAR 0 5
112592: PUSH
112593: LD_INT 1
112595: ARRAY
112596: PPUSH
112597: LD_VAR 0 5
112601: PUSH
112602: LD_INT 2
112604: ARRAY
112605: PPUSH
112606: CALL 111565 0 3
112610: NOT
112611: IFFALSE 112617
// exit ;
112613: POP
112614: POP
112615: GO 112621
112617: GO 112580
112619: POP
112620: POP
// end ;
112621: LD_VAR 0 4
112625: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
112626: LD_INT 0
112628: PPUSH
112629: PPUSH
112630: PPUSH
112631: PPUSH
112632: PPUSH
112633: PPUSH
112634: PPUSH
// if not GetClass ( unit ) = class_sniper then
112635: LD_VAR 0 1
112639: PPUSH
112640: CALL_OW 257
112644: PUSH
112645: LD_INT 5
112647: EQUAL
112648: NOT
112649: IFFALSE 112653
// exit ;
112651: GO 113041
// dist := 8 ;
112653: LD_ADDR_VAR 0 5
112657: PUSH
112658: LD_INT 8
112660: ST_TO_ADDR
// viewRange := 12 ;
112661: LD_ADDR_VAR 0 7
112665: PUSH
112666: LD_INT 12
112668: ST_TO_ADDR
// side := GetSide ( unit ) ;
112669: LD_ADDR_VAR 0 6
112673: PUSH
112674: LD_VAR 0 1
112678: PPUSH
112679: CALL_OW 255
112683: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
112684: LD_INT 61
112686: PPUSH
112687: LD_VAR 0 6
112691: PPUSH
112692: CALL_OW 321
112696: PUSH
112697: LD_INT 2
112699: EQUAL
112700: IFFALSE 112710
// viewRange := 16 ;
112702: LD_ADDR_VAR 0 7
112706: PUSH
112707: LD_INT 16
112709: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
112710: LD_VAR 0 1
112714: PPUSH
112715: LD_VAR 0 2
112719: PPUSH
112720: LD_VAR 0 3
112724: PPUSH
112725: CALL_OW 297
112729: PUSH
112730: LD_VAR 0 5
112734: GREATER
112735: IFFALSE 112814
// begin ComMoveXY ( unit , x , y ) ;
112737: LD_VAR 0 1
112741: PPUSH
112742: LD_VAR 0 2
112746: PPUSH
112747: LD_VAR 0 3
112751: PPUSH
112752: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112756: LD_INT 35
112758: PPUSH
112759: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
112763: LD_VAR 0 1
112767: PPUSH
112768: LD_VAR 0 2
112772: PPUSH
112773: LD_VAR 0 3
112777: PPUSH
112778: CALL 56383 0 3
112782: NOT
112783: IFFALSE 112787
// exit ;
112785: GO 113041
// until GetDistUnitXY ( unit , x , y ) < dist ;
112787: LD_VAR 0 1
112791: PPUSH
112792: LD_VAR 0 2
112796: PPUSH
112797: LD_VAR 0 3
112801: PPUSH
112802: CALL_OW 297
112806: PUSH
112807: LD_VAR 0 5
112811: LESS
112812: IFFALSE 112756
// end ; ComTurnXY ( unit , x , y ) ;
112814: LD_VAR 0 1
112818: PPUSH
112819: LD_VAR 0 2
112823: PPUSH
112824: LD_VAR 0 3
112828: PPUSH
112829: CALL_OW 118
// wait ( 5 ) ;
112833: LD_INT 5
112835: PPUSH
112836: CALL_OW 67
// _d := GetDir ( unit ) ;
112840: LD_ADDR_VAR 0 10
112844: PUSH
112845: LD_VAR 0 1
112849: PPUSH
112850: CALL_OW 254
112854: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
112855: LD_ADDR_VAR 0 8
112859: PUSH
112860: LD_VAR 0 1
112864: PPUSH
112865: CALL_OW 250
112869: PPUSH
112870: LD_VAR 0 10
112874: PPUSH
112875: LD_VAR 0 5
112879: PPUSH
112880: CALL_OW 272
112884: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
112885: LD_ADDR_VAR 0 9
112889: PUSH
112890: LD_VAR 0 1
112894: PPUSH
112895: CALL_OW 251
112899: PPUSH
112900: LD_VAR 0 10
112904: PPUSH
112905: LD_VAR 0 5
112909: PPUSH
112910: CALL_OW 273
112914: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
112915: LD_VAR 0 8
112919: PPUSH
112920: LD_VAR 0 9
112924: PPUSH
112925: CALL_OW 488
112929: NOT
112930: IFFALSE 112934
// exit ;
112932: GO 113041
// ComAnimCustom ( unit , 1 ) ;
112934: LD_VAR 0 1
112938: PPUSH
112939: LD_INT 1
112941: PPUSH
112942: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
112946: LD_VAR 0 8
112950: PPUSH
112951: LD_VAR 0 9
112955: PPUSH
112956: LD_VAR 0 6
112960: PPUSH
112961: LD_VAR 0 7
112965: PPUSH
112966: CALL_OW 330
// repeat wait ( 1 ) ;
112970: LD_INT 1
112972: PPUSH
112973: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
112977: LD_VAR 0 1
112981: PPUSH
112982: CALL_OW 316
112986: PUSH
112987: LD_VAR 0 1
112991: PPUSH
112992: CALL_OW 314
112996: OR
112997: PUSH
112998: LD_VAR 0 1
113002: PPUSH
113003: CALL_OW 302
113007: NOT
113008: OR
113009: PUSH
113010: LD_VAR 0 1
113014: PPUSH
113015: CALL_OW 301
113019: OR
113020: IFFALSE 112970
// RemoveSeeing ( _x , _y , side ) ;
113022: LD_VAR 0 8
113026: PPUSH
113027: LD_VAR 0 9
113031: PPUSH
113032: LD_VAR 0 6
113036: PPUSH
113037: CALL_OW 331
// end ; end_of_file
113041: LD_VAR 0 4
113045: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113046: LD_INT 0
113048: PPUSH
113049: PPUSH
113050: PPUSH
113051: PPUSH
113052: PPUSH
113053: PPUSH
113054: PPUSH
113055: PPUSH
113056: PPUSH
113057: PPUSH
113058: PPUSH
113059: PPUSH
113060: PPUSH
113061: PPUSH
113062: PPUSH
113063: PPUSH
113064: PPUSH
113065: PPUSH
113066: PPUSH
113067: PPUSH
113068: PPUSH
113069: PPUSH
113070: PPUSH
113071: PPUSH
113072: PPUSH
113073: PPUSH
113074: PPUSH
113075: PPUSH
113076: PPUSH
113077: PPUSH
113078: PPUSH
113079: PPUSH
113080: PPUSH
113081: PPUSH
// if not list then
113082: LD_VAR 0 1
113086: NOT
113087: IFFALSE 113091
// exit ;
113089: GO 117750
// base := list [ 1 ] ;
113091: LD_ADDR_VAR 0 3
113095: PUSH
113096: LD_VAR 0 1
113100: PUSH
113101: LD_INT 1
113103: ARRAY
113104: ST_TO_ADDR
// group := list [ 2 ] ;
113105: LD_ADDR_VAR 0 4
113109: PUSH
113110: LD_VAR 0 1
113114: PUSH
113115: LD_INT 2
113117: ARRAY
113118: ST_TO_ADDR
// path := list [ 3 ] ;
113119: LD_ADDR_VAR 0 5
113123: PUSH
113124: LD_VAR 0 1
113128: PUSH
113129: LD_INT 3
113131: ARRAY
113132: ST_TO_ADDR
// flags := list [ 4 ] ;
113133: LD_ADDR_VAR 0 6
113137: PUSH
113138: LD_VAR 0 1
113142: PUSH
113143: LD_INT 4
113145: ARRAY
113146: ST_TO_ADDR
// mined := [ ] ;
113147: LD_ADDR_VAR 0 27
113151: PUSH
113152: EMPTY
113153: ST_TO_ADDR
// bombed := [ ] ;
113154: LD_ADDR_VAR 0 28
113158: PUSH
113159: EMPTY
113160: ST_TO_ADDR
// healers := [ ] ;
113161: LD_ADDR_VAR 0 31
113165: PUSH
113166: EMPTY
113167: ST_TO_ADDR
// to_heal := [ ] ;
113168: LD_ADDR_VAR 0 30
113172: PUSH
113173: EMPTY
113174: ST_TO_ADDR
// repairs := [ ] ;
113175: LD_ADDR_VAR 0 33
113179: PUSH
113180: EMPTY
113181: ST_TO_ADDR
// to_repair := [ ] ;
113182: LD_ADDR_VAR 0 32
113186: PUSH
113187: EMPTY
113188: ST_TO_ADDR
// if not group or not path then
113189: LD_VAR 0 4
113193: NOT
113194: PUSH
113195: LD_VAR 0 5
113199: NOT
113200: OR
113201: IFFALSE 113205
// exit ;
113203: GO 117750
// side := GetSide ( group [ 1 ] ) ;
113205: LD_ADDR_VAR 0 35
113209: PUSH
113210: LD_VAR 0 4
113214: PUSH
113215: LD_INT 1
113217: ARRAY
113218: PPUSH
113219: CALL_OW 255
113223: ST_TO_ADDR
// if flags then
113224: LD_VAR 0 6
113228: IFFALSE 113372
// begin f_ignore_area := flags [ 1 ] ;
113230: LD_ADDR_VAR 0 17
113234: PUSH
113235: LD_VAR 0 6
113239: PUSH
113240: LD_INT 1
113242: ARRAY
113243: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113244: LD_ADDR_VAR 0 18
113248: PUSH
113249: LD_VAR 0 6
113253: PUSH
113254: LD_INT 2
113256: ARRAY
113257: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113258: LD_ADDR_VAR 0 19
113262: PUSH
113263: LD_VAR 0 6
113267: PUSH
113268: LD_INT 3
113270: ARRAY
113271: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113272: LD_ADDR_VAR 0 20
113276: PUSH
113277: LD_VAR 0 6
113281: PUSH
113282: LD_INT 4
113284: ARRAY
113285: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113286: LD_ADDR_VAR 0 21
113290: PUSH
113291: LD_VAR 0 6
113295: PUSH
113296: LD_INT 5
113298: ARRAY
113299: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113300: LD_ADDR_VAR 0 22
113304: PUSH
113305: LD_VAR 0 6
113309: PUSH
113310: LD_INT 6
113312: ARRAY
113313: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113314: LD_ADDR_VAR 0 23
113318: PUSH
113319: LD_VAR 0 6
113323: PUSH
113324: LD_INT 7
113326: ARRAY
113327: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113328: LD_ADDR_VAR 0 24
113332: PUSH
113333: LD_VAR 0 6
113337: PUSH
113338: LD_INT 8
113340: ARRAY
113341: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113342: LD_ADDR_VAR 0 25
113346: PUSH
113347: LD_VAR 0 6
113351: PUSH
113352: LD_INT 9
113354: ARRAY
113355: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113356: LD_ADDR_VAR 0 26
113360: PUSH
113361: LD_VAR 0 6
113365: PUSH
113366: LD_INT 10
113368: ARRAY
113369: ST_TO_ADDR
// end else
113370: GO 113452
// begin f_ignore_area := false ;
113372: LD_ADDR_VAR 0 17
113376: PUSH
113377: LD_INT 0
113379: ST_TO_ADDR
// f_capture := false ;
113380: LD_ADDR_VAR 0 18
113384: PUSH
113385: LD_INT 0
113387: ST_TO_ADDR
// f_ignore_civ := false ;
113388: LD_ADDR_VAR 0 19
113392: PUSH
113393: LD_INT 0
113395: ST_TO_ADDR
// f_murder := false ;
113396: LD_ADDR_VAR 0 20
113400: PUSH
113401: LD_INT 0
113403: ST_TO_ADDR
// f_mines := false ;
113404: LD_ADDR_VAR 0 21
113408: PUSH
113409: LD_INT 0
113411: ST_TO_ADDR
// f_repair := false ;
113412: LD_ADDR_VAR 0 22
113416: PUSH
113417: LD_INT 0
113419: ST_TO_ADDR
// f_heal := false ;
113420: LD_ADDR_VAR 0 23
113424: PUSH
113425: LD_INT 0
113427: ST_TO_ADDR
// f_spacetime := false ;
113428: LD_ADDR_VAR 0 24
113432: PUSH
113433: LD_INT 0
113435: ST_TO_ADDR
// f_attack_depot := false ;
113436: LD_ADDR_VAR 0 25
113440: PUSH
113441: LD_INT 0
113443: ST_TO_ADDR
// f_crawl := false ;
113444: LD_ADDR_VAR 0 26
113448: PUSH
113449: LD_INT 0
113451: ST_TO_ADDR
// end ; if f_heal then
113452: LD_VAR 0 23
113456: IFFALSE 113483
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113458: LD_ADDR_VAR 0 31
113462: PUSH
113463: LD_VAR 0 4
113467: PPUSH
113468: LD_INT 25
113470: PUSH
113471: LD_INT 4
113473: PUSH
113474: EMPTY
113475: LIST
113476: LIST
113477: PPUSH
113478: CALL_OW 72
113482: ST_TO_ADDR
// if f_repair then
113483: LD_VAR 0 22
113487: IFFALSE 113514
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113489: LD_ADDR_VAR 0 33
113493: PUSH
113494: LD_VAR 0 4
113498: PPUSH
113499: LD_INT 25
113501: PUSH
113502: LD_INT 3
113504: PUSH
113505: EMPTY
113506: LIST
113507: LIST
113508: PPUSH
113509: CALL_OW 72
113513: ST_TO_ADDR
// units_path := [ ] ;
113514: LD_ADDR_VAR 0 16
113518: PUSH
113519: EMPTY
113520: ST_TO_ADDR
// for i = 1 to group do
113521: LD_ADDR_VAR 0 7
113525: PUSH
113526: DOUBLE
113527: LD_INT 1
113529: DEC
113530: ST_TO_ADDR
113531: LD_VAR 0 4
113535: PUSH
113536: FOR_TO
113537: IFFALSE 113566
// units_path := Replace ( units_path , i , path ) ;
113539: LD_ADDR_VAR 0 16
113543: PUSH
113544: LD_VAR 0 16
113548: PPUSH
113549: LD_VAR 0 7
113553: PPUSH
113554: LD_VAR 0 5
113558: PPUSH
113559: CALL_OW 1
113563: ST_TO_ADDR
113564: GO 113536
113566: POP
113567: POP
// repeat for i = group downto 1 do
113568: LD_ADDR_VAR 0 7
113572: PUSH
113573: DOUBLE
113574: LD_VAR 0 4
113578: INC
113579: ST_TO_ADDR
113580: LD_INT 1
113582: PUSH
113583: FOR_DOWNTO
113584: IFFALSE 117706
// begin wait ( 5 ) ;
113586: LD_INT 5
113588: PPUSH
113589: CALL_OW 67
// tmp := [ ] ;
113593: LD_ADDR_VAR 0 14
113597: PUSH
113598: EMPTY
113599: ST_TO_ADDR
// attacking := false ;
113600: LD_ADDR_VAR 0 29
113604: PUSH
113605: LD_INT 0
113607: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113608: LD_VAR 0 4
113612: PUSH
113613: LD_VAR 0 7
113617: ARRAY
113618: PPUSH
113619: CALL_OW 301
113623: PUSH
113624: LD_VAR 0 4
113628: PUSH
113629: LD_VAR 0 7
113633: ARRAY
113634: NOT
113635: OR
113636: IFFALSE 113745
// begin if GetType ( group [ i ] ) = unit_human then
113638: LD_VAR 0 4
113642: PUSH
113643: LD_VAR 0 7
113647: ARRAY
113648: PPUSH
113649: CALL_OW 247
113653: PUSH
113654: LD_INT 1
113656: EQUAL
113657: IFFALSE 113703
// begin to_heal := to_heal diff group [ i ] ;
113659: LD_ADDR_VAR 0 30
113663: PUSH
113664: LD_VAR 0 30
113668: PUSH
113669: LD_VAR 0 4
113673: PUSH
113674: LD_VAR 0 7
113678: ARRAY
113679: DIFF
113680: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113681: LD_ADDR_VAR 0 31
113685: PUSH
113686: LD_VAR 0 31
113690: PUSH
113691: LD_VAR 0 4
113695: PUSH
113696: LD_VAR 0 7
113700: ARRAY
113701: DIFF
113702: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113703: LD_ADDR_VAR 0 4
113707: PUSH
113708: LD_VAR 0 4
113712: PPUSH
113713: LD_VAR 0 7
113717: PPUSH
113718: CALL_OW 3
113722: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113723: LD_ADDR_VAR 0 16
113727: PUSH
113728: LD_VAR 0 16
113732: PPUSH
113733: LD_VAR 0 7
113737: PPUSH
113738: CALL_OW 3
113742: ST_TO_ADDR
// continue ;
113743: GO 113583
// end ; if f_repair then
113745: LD_VAR 0 22
113749: IFFALSE 114238
// begin if GetType ( group [ i ] ) = unit_vehicle then
113751: LD_VAR 0 4
113755: PUSH
113756: LD_VAR 0 7
113760: ARRAY
113761: PPUSH
113762: CALL_OW 247
113766: PUSH
113767: LD_INT 2
113769: EQUAL
113770: IFFALSE 113960
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113772: LD_VAR 0 4
113776: PUSH
113777: LD_VAR 0 7
113781: ARRAY
113782: PPUSH
113783: CALL_OW 256
113787: PUSH
113788: LD_INT 700
113790: LESS
113791: PUSH
113792: LD_VAR 0 4
113796: PUSH
113797: LD_VAR 0 7
113801: ARRAY
113802: PUSH
113803: LD_VAR 0 32
113807: IN
113808: NOT
113809: AND
113810: IFFALSE 113834
// to_repair := to_repair union group [ i ] ;
113812: LD_ADDR_VAR 0 32
113816: PUSH
113817: LD_VAR 0 32
113821: PUSH
113822: LD_VAR 0 4
113826: PUSH
113827: LD_VAR 0 7
113831: ARRAY
113832: UNION
113833: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113834: LD_VAR 0 4
113838: PUSH
113839: LD_VAR 0 7
113843: ARRAY
113844: PPUSH
113845: CALL_OW 256
113849: PUSH
113850: LD_INT 1000
113852: EQUAL
113853: PUSH
113854: LD_VAR 0 4
113858: PUSH
113859: LD_VAR 0 7
113863: ARRAY
113864: PUSH
113865: LD_VAR 0 32
113869: IN
113870: AND
113871: IFFALSE 113895
// to_repair := to_repair diff group [ i ] ;
113873: LD_ADDR_VAR 0 32
113877: PUSH
113878: LD_VAR 0 32
113882: PUSH
113883: LD_VAR 0 4
113887: PUSH
113888: LD_VAR 0 7
113892: ARRAY
113893: DIFF
113894: ST_TO_ADDR
// if group [ i ] in to_repair then
113895: LD_VAR 0 4
113899: PUSH
113900: LD_VAR 0 7
113904: ARRAY
113905: PUSH
113906: LD_VAR 0 32
113910: IN
113911: IFFALSE 113958
// begin if not IsInArea ( group [ i ] , f_repair ) then
113913: LD_VAR 0 4
113917: PUSH
113918: LD_VAR 0 7
113922: ARRAY
113923: PPUSH
113924: LD_VAR 0 22
113928: PPUSH
113929: CALL_OW 308
113933: NOT
113934: IFFALSE 113956
// ComMoveToArea ( group [ i ] , f_repair ) ;
113936: LD_VAR 0 4
113940: PUSH
113941: LD_VAR 0 7
113945: ARRAY
113946: PPUSH
113947: LD_VAR 0 22
113951: PPUSH
113952: CALL_OW 113
// continue ;
113956: GO 113583
// end ; end else
113958: GO 114238
// if group [ i ] in repairs then
113960: LD_VAR 0 4
113964: PUSH
113965: LD_VAR 0 7
113969: ARRAY
113970: PUSH
113971: LD_VAR 0 33
113975: IN
113976: IFFALSE 114238
// begin if IsInUnit ( group [ i ] ) then
113978: LD_VAR 0 4
113982: PUSH
113983: LD_VAR 0 7
113987: ARRAY
113988: PPUSH
113989: CALL_OW 310
113993: IFFALSE 114061
// begin z := IsInUnit ( group [ i ] ) ;
113995: LD_ADDR_VAR 0 13
113999: PUSH
114000: LD_VAR 0 4
114004: PUSH
114005: LD_VAR 0 7
114009: ARRAY
114010: PPUSH
114011: CALL_OW 310
114015: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114016: LD_VAR 0 13
114020: PUSH
114021: LD_VAR 0 32
114025: IN
114026: PUSH
114027: LD_VAR 0 13
114031: PPUSH
114032: LD_VAR 0 22
114036: PPUSH
114037: CALL_OW 308
114041: AND
114042: IFFALSE 114059
// ComExitVehicle ( group [ i ] ) ;
114044: LD_VAR 0 4
114048: PUSH
114049: LD_VAR 0 7
114053: ARRAY
114054: PPUSH
114055: CALL_OW 121
// end else
114059: GO 114238
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114061: LD_ADDR_VAR 0 13
114065: PUSH
114066: LD_VAR 0 4
114070: PPUSH
114071: LD_INT 95
114073: PUSH
114074: LD_VAR 0 22
114078: PUSH
114079: EMPTY
114080: LIST
114081: LIST
114082: PUSH
114083: LD_INT 58
114085: PUSH
114086: EMPTY
114087: LIST
114088: PUSH
114089: EMPTY
114090: LIST
114091: LIST
114092: PPUSH
114093: CALL_OW 72
114097: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114098: LD_VAR 0 4
114102: PUSH
114103: LD_VAR 0 7
114107: ARRAY
114108: PPUSH
114109: CALL_OW 314
114113: NOT
114114: IFFALSE 114236
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114116: LD_ADDR_VAR 0 10
114120: PUSH
114121: LD_VAR 0 13
114125: PPUSH
114126: LD_VAR 0 4
114130: PUSH
114131: LD_VAR 0 7
114135: ARRAY
114136: PPUSH
114137: CALL_OW 74
114141: ST_TO_ADDR
// if not x then
114142: LD_VAR 0 10
114146: NOT
114147: IFFALSE 114151
// continue ;
114149: GO 113583
// if GetLives ( x ) < 1000 then
114151: LD_VAR 0 10
114155: PPUSH
114156: CALL_OW 256
114160: PUSH
114161: LD_INT 1000
114163: LESS
114164: IFFALSE 114188
// ComRepairVehicle ( group [ i ] , x ) else
114166: LD_VAR 0 4
114170: PUSH
114171: LD_VAR 0 7
114175: ARRAY
114176: PPUSH
114177: LD_VAR 0 10
114181: PPUSH
114182: CALL_OW 129
114186: GO 114236
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114188: LD_VAR 0 23
114192: PUSH
114193: LD_VAR 0 4
114197: PUSH
114198: LD_VAR 0 7
114202: ARRAY
114203: PPUSH
114204: CALL_OW 256
114208: PUSH
114209: LD_INT 1000
114211: LESS
114212: AND
114213: NOT
114214: IFFALSE 114236
// ComEnterUnit ( group [ i ] , x ) ;
114216: LD_VAR 0 4
114220: PUSH
114221: LD_VAR 0 7
114225: ARRAY
114226: PPUSH
114227: LD_VAR 0 10
114231: PPUSH
114232: CALL_OW 120
// end ; continue ;
114236: GO 113583
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114238: LD_VAR 0 23
114242: PUSH
114243: LD_VAR 0 4
114247: PUSH
114248: LD_VAR 0 7
114252: ARRAY
114253: PPUSH
114254: CALL_OW 247
114258: PUSH
114259: LD_INT 1
114261: EQUAL
114262: AND
114263: IFFALSE 114741
// begin if group [ i ] in healers then
114265: LD_VAR 0 4
114269: PUSH
114270: LD_VAR 0 7
114274: ARRAY
114275: PUSH
114276: LD_VAR 0 31
114280: IN
114281: IFFALSE 114554
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114283: LD_VAR 0 4
114287: PUSH
114288: LD_VAR 0 7
114292: ARRAY
114293: PPUSH
114294: LD_VAR 0 23
114298: PPUSH
114299: CALL_OW 308
114303: NOT
114304: PUSH
114305: LD_VAR 0 4
114309: PUSH
114310: LD_VAR 0 7
114314: ARRAY
114315: PPUSH
114316: CALL_OW 314
114320: NOT
114321: AND
114322: IFFALSE 114346
// ComMoveToArea ( group [ i ] , f_heal ) else
114324: LD_VAR 0 4
114328: PUSH
114329: LD_VAR 0 7
114333: ARRAY
114334: PPUSH
114335: LD_VAR 0 23
114339: PPUSH
114340: CALL_OW 113
114344: GO 114552
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114346: LD_VAR 0 4
114350: PUSH
114351: LD_VAR 0 7
114355: ARRAY
114356: PPUSH
114357: CALL 54966 0 1
114361: PPUSH
114362: CALL_OW 256
114366: PUSH
114367: LD_INT 1000
114369: EQUAL
114370: IFFALSE 114389
// ComStop ( group [ i ] ) else
114372: LD_VAR 0 4
114376: PUSH
114377: LD_VAR 0 7
114381: ARRAY
114382: PPUSH
114383: CALL_OW 141
114387: GO 114552
// if not HasTask ( group [ i ] ) and to_heal then
114389: LD_VAR 0 4
114393: PUSH
114394: LD_VAR 0 7
114398: ARRAY
114399: PPUSH
114400: CALL_OW 314
114404: NOT
114405: PUSH
114406: LD_VAR 0 30
114410: AND
114411: IFFALSE 114552
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114413: LD_ADDR_VAR 0 13
114417: PUSH
114418: LD_VAR 0 30
114422: PPUSH
114423: LD_INT 3
114425: PUSH
114426: LD_INT 54
114428: PUSH
114429: EMPTY
114430: LIST
114431: PUSH
114432: EMPTY
114433: LIST
114434: LIST
114435: PPUSH
114436: CALL_OW 72
114440: PPUSH
114441: LD_VAR 0 4
114445: PUSH
114446: LD_VAR 0 7
114450: ARRAY
114451: PPUSH
114452: CALL_OW 74
114456: ST_TO_ADDR
// if z then
114457: LD_VAR 0 13
114461: IFFALSE 114552
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114463: LD_INT 91
114465: PUSH
114466: LD_VAR 0 13
114470: PUSH
114471: LD_INT 10
114473: PUSH
114474: EMPTY
114475: LIST
114476: LIST
114477: LIST
114478: PUSH
114479: LD_INT 81
114481: PUSH
114482: LD_VAR 0 13
114486: PPUSH
114487: CALL_OW 255
114491: PUSH
114492: EMPTY
114493: LIST
114494: LIST
114495: PUSH
114496: EMPTY
114497: LIST
114498: LIST
114499: PPUSH
114500: CALL_OW 69
114504: PUSH
114505: LD_INT 0
114507: EQUAL
114508: IFFALSE 114532
// ComHeal ( group [ i ] , z ) else
114510: LD_VAR 0 4
114514: PUSH
114515: LD_VAR 0 7
114519: ARRAY
114520: PPUSH
114521: LD_VAR 0 13
114525: PPUSH
114526: CALL_OW 128
114530: GO 114552
// ComMoveToArea ( group [ i ] , f_heal ) ;
114532: LD_VAR 0 4
114536: PUSH
114537: LD_VAR 0 7
114541: ARRAY
114542: PPUSH
114543: LD_VAR 0 23
114547: PPUSH
114548: CALL_OW 113
// end ; continue ;
114552: GO 113583
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114554: LD_VAR 0 4
114558: PUSH
114559: LD_VAR 0 7
114563: ARRAY
114564: PPUSH
114565: CALL_OW 256
114569: PUSH
114570: LD_INT 700
114572: LESS
114573: PUSH
114574: LD_VAR 0 4
114578: PUSH
114579: LD_VAR 0 7
114583: ARRAY
114584: PUSH
114585: LD_VAR 0 30
114589: IN
114590: NOT
114591: AND
114592: IFFALSE 114616
// to_heal := to_heal union group [ i ] ;
114594: LD_ADDR_VAR 0 30
114598: PUSH
114599: LD_VAR 0 30
114603: PUSH
114604: LD_VAR 0 4
114608: PUSH
114609: LD_VAR 0 7
114613: ARRAY
114614: UNION
114615: ST_TO_ADDR
// if group [ i ] in to_heal then
114616: LD_VAR 0 4
114620: PUSH
114621: LD_VAR 0 7
114625: ARRAY
114626: PUSH
114627: LD_VAR 0 30
114631: IN
114632: IFFALSE 114741
// begin if GetLives ( group [ i ] ) = 1000 then
114634: LD_VAR 0 4
114638: PUSH
114639: LD_VAR 0 7
114643: ARRAY
114644: PPUSH
114645: CALL_OW 256
114649: PUSH
114650: LD_INT 1000
114652: EQUAL
114653: IFFALSE 114679
// to_heal := to_heal diff group [ i ] else
114655: LD_ADDR_VAR 0 30
114659: PUSH
114660: LD_VAR 0 30
114664: PUSH
114665: LD_VAR 0 4
114669: PUSH
114670: LD_VAR 0 7
114674: ARRAY
114675: DIFF
114676: ST_TO_ADDR
114677: GO 114741
// begin if not IsInArea ( group [ i ] , to_heal ) then
114679: LD_VAR 0 4
114683: PUSH
114684: LD_VAR 0 7
114688: ARRAY
114689: PPUSH
114690: LD_VAR 0 30
114694: PPUSH
114695: CALL_OW 308
114699: NOT
114700: IFFALSE 114724
// ComMoveToArea ( group [ i ] , f_heal ) else
114702: LD_VAR 0 4
114706: PUSH
114707: LD_VAR 0 7
114711: ARRAY
114712: PPUSH
114713: LD_VAR 0 23
114717: PPUSH
114718: CALL_OW 113
114722: GO 114739
// ComHold ( group [ i ] ) ;
114724: LD_VAR 0 4
114728: PUSH
114729: LD_VAR 0 7
114733: ARRAY
114734: PPUSH
114735: CALL_OW 140
// continue ;
114739: GO 113583
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114741: LD_VAR 0 4
114745: PUSH
114746: LD_VAR 0 7
114750: ARRAY
114751: PPUSH
114752: LD_INT 10
114754: PPUSH
114755: CALL 52737 0 2
114759: NOT
114760: PUSH
114761: LD_VAR 0 16
114765: PUSH
114766: LD_VAR 0 7
114770: ARRAY
114771: PUSH
114772: EMPTY
114773: EQUAL
114774: NOT
114775: AND
114776: IFFALSE 115042
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114778: LD_VAR 0 4
114782: PUSH
114783: LD_VAR 0 7
114787: ARRAY
114788: PPUSH
114789: CALL_OW 262
114793: PUSH
114794: LD_INT 1
114796: PUSH
114797: LD_INT 2
114799: PUSH
114800: EMPTY
114801: LIST
114802: LIST
114803: IN
114804: IFFALSE 114845
// if GetFuel ( group [ i ] ) < 10 then
114806: LD_VAR 0 4
114810: PUSH
114811: LD_VAR 0 7
114815: ARRAY
114816: PPUSH
114817: CALL_OW 261
114821: PUSH
114822: LD_INT 10
114824: LESS
114825: IFFALSE 114845
// SetFuel ( group [ i ] , 12 ) ;
114827: LD_VAR 0 4
114831: PUSH
114832: LD_VAR 0 7
114836: ARRAY
114837: PPUSH
114838: LD_INT 12
114840: PPUSH
114841: CALL_OW 240
// if units_path [ i ] then
114845: LD_VAR 0 16
114849: PUSH
114850: LD_VAR 0 7
114854: ARRAY
114855: IFFALSE 115040
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114857: LD_VAR 0 4
114861: PUSH
114862: LD_VAR 0 7
114866: ARRAY
114867: PPUSH
114868: LD_VAR 0 16
114872: PUSH
114873: LD_VAR 0 7
114877: ARRAY
114878: PUSH
114879: LD_INT 1
114881: ARRAY
114882: PUSH
114883: LD_INT 1
114885: ARRAY
114886: PPUSH
114887: LD_VAR 0 16
114891: PUSH
114892: LD_VAR 0 7
114896: ARRAY
114897: PUSH
114898: LD_INT 1
114900: ARRAY
114901: PUSH
114902: LD_INT 2
114904: ARRAY
114905: PPUSH
114906: CALL_OW 297
114910: PUSH
114911: LD_INT 6
114913: GREATER
114914: IFFALSE 114989
// begin if not HasTask ( group [ i ] ) then
114916: LD_VAR 0 4
114920: PUSH
114921: LD_VAR 0 7
114925: ARRAY
114926: PPUSH
114927: CALL_OW 314
114931: NOT
114932: IFFALSE 114987
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114934: LD_VAR 0 4
114938: PUSH
114939: LD_VAR 0 7
114943: ARRAY
114944: PPUSH
114945: LD_VAR 0 16
114949: PUSH
114950: LD_VAR 0 7
114954: ARRAY
114955: PUSH
114956: LD_INT 1
114958: ARRAY
114959: PUSH
114960: LD_INT 1
114962: ARRAY
114963: PPUSH
114964: LD_VAR 0 16
114968: PUSH
114969: LD_VAR 0 7
114973: ARRAY
114974: PUSH
114975: LD_INT 1
114977: ARRAY
114978: PUSH
114979: LD_INT 2
114981: ARRAY
114982: PPUSH
114983: CALL_OW 114
// end else
114987: GO 115040
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114989: LD_ADDR_VAR 0 15
114993: PUSH
114994: LD_VAR 0 16
114998: PUSH
114999: LD_VAR 0 7
115003: ARRAY
115004: PPUSH
115005: LD_INT 1
115007: PPUSH
115008: CALL_OW 3
115012: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115013: LD_ADDR_VAR 0 16
115017: PUSH
115018: LD_VAR 0 16
115022: PPUSH
115023: LD_VAR 0 7
115027: PPUSH
115028: LD_VAR 0 15
115032: PPUSH
115033: CALL_OW 1
115037: ST_TO_ADDR
// continue ;
115038: GO 113583
// end ; end ; end else
115040: GO 117704
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115042: LD_ADDR_VAR 0 14
115046: PUSH
115047: LD_INT 81
115049: PUSH
115050: LD_VAR 0 4
115054: PUSH
115055: LD_VAR 0 7
115059: ARRAY
115060: PPUSH
115061: CALL_OW 255
115065: PUSH
115066: EMPTY
115067: LIST
115068: LIST
115069: PPUSH
115070: CALL_OW 69
115074: ST_TO_ADDR
// if not tmp then
115075: LD_VAR 0 14
115079: NOT
115080: IFFALSE 115084
// continue ;
115082: GO 113583
// if f_ignore_area then
115084: LD_VAR 0 17
115088: IFFALSE 115176
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115090: LD_ADDR_VAR 0 15
115094: PUSH
115095: LD_VAR 0 14
115099: PPUSH
115100: LD_INT 3
115102: PUSH
115103: LD_INT 92
115105: PUSH
115106: LD_VAR 0 17
115110: PUSH
115111: LD_INT 1
115113: ARRAY
115114: PUSH
115115: LD_VAR 0 17
115119: PUSH
115120: LD_INT 2
115122: ARRAY
115123: PUSH
115124: LD_VAR 0 17
115128: PUSH
115129: LD_INT 3
115131: ARRAY
115132: PUSH
115133: EMPTY
115134: LIST
115135: LIST
115136: LIST
115137: LIST
115138: PUSH
115139: EMPTY
115140: LIST
115141: LIST
115142: PPUSH
115143: CALL_OW 72
115147: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115148: LD_VAR 0 14
115152: PUSH
115153: LD_VAR 0 15
115157: DIFF
115158: IFFALSE 115176
// tmp := tmp diff tmp2 ;
115160: LD_ADDR_VAR 0 14
115164: PUSH
115165: LD_VAR 0 14
115169: PUSH
115170: LD_VAR 0 15
115174: DIFF
115175: ST_TO_ADDR
// end ; if not f_murder then
115176: LD_VAR 0 20
115180: NOT
115181: IFFALSE 115239
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115183: LD_ADDR_VAR 0 15
115187: PUSH
115188: LD_VAR 0 14
115192: PPUSH
115193: LD_INT 3
115195: PUSH
115196: LD_INT 50
115198: PUSH
115199: EMPTY
115200: LIST
115201: PUSH
115202: EMPTY
115203: LIST
115204: LIST
115205: PPUSH
115206: CALL_OW 72
115210: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115211: LD_VAR 0 14
115215: PUSH
115216: LD_VAR 0 15
115220: DIFF
115221: IFFALSE 115239
// tmp := tmp diff tmp2 ;
115223: LD_ADDR_VAR 0 14
115227: PUSH
115228: LD_VAR 0 14
115232: PUSH
115233: LD_VAR 0 15
115237: DIFF
115238: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115239: LD_ADDR_VAR 0 14
115243: PUSH
115244: LD_VAR 0 4
115248: PUSH
115249: LD_VAR 0 7
115253: ARRAY
115254: PPUSH
115255: LD_VAR 0 14
115259: PPUSH
115260: LD_INT 1
115262: PPUSH
115263: LD_INT 1
115265: PPUSH
115266: CALL 25281 0 4
115270: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115271: LD_VAR 0 4
115275: PUSH
115276: LD_VAR 0 7
115280: ARRAY
115281: PPUSH
115282: CALL_OW 257
115286: PUSH
115287: LD_INT 1
115289: EQUAL
115290: IFFALSE 115738
// begin if WantPlant ( group [ i ] ) then
115292: LD_VAR 0 4
115296: PUSH
115297: LD_VAR 0 7
115301: ARRAY
115302: PPUSH
115303: CALL 24782 0 1
115307: IFFALSE 115311
// continue ;
115309: GO 113583
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115311: LD_VAR 0 18
115315: PUSH
115316: LD_VAR 0 4
115320: PUSH
115321: LD_VAR 0 7
115325: ARRAY
115326: PPUSH
115327: CALL_OW 310
115331: NOT
115332: AND
115333: PUSH
115334: LD_VAR 0 14
115338: PUSH
115339: LD_INT 1
115341: ARRAY
115342: PUSH
115343: LD_VAR 0 14
115347: PPUSH
115348: LD_INT 21
115350: PUSH
115351: LD_INT 2
115353: PUSH
115354: EMPTY
115355: LIST
115356: LIST
115357: PUSH
115358: LD_INT 58
115360: PUSH
115361: EMPTY
115362: LIST
115363: PUSH
115364: EMPTY
115365: LIST
115366: LIST
115367: PPUSH
115368: CALL_OW 72
115372: IN
115373: AND
115374: IFFALSE 115410
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115376: LD_VAR 0 4
115380: PUSH
115381: LD_VAR 0 7
115385: ARRAY
115386: PPUSH
115387: LD_VAR 0 14
115391: PUSH
115392: LD_INT 1
115394: ARRAY
115395: PPUSH
115396: CALL_OW 120
// attacking := true ;
115400: LD_ADDR_VAR 0 29
115404: PUSH
115405: LD_INT 1
115407: ST_TO_ADDR
// continue ;
115408: GO 113583
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115410: LD_VAR 0 26
115414: PUSH
115415: LD_VAR 0 4
115419: PUSH
115420: LD_VAR 0 7
115424: ARRAY
115425: PPUSH
115426: CALL_OW 257
115430: PUSH
115431: LD_INT 1
115433: EQUAL
115434: AND
115435: PUSH
115436: LD_VAR 0 4
115440: PUSH
115441: LD_VAR 0 7
115445: ARRAY
115446: PPUSH
115447: CALL_OW 256
115451: PUSH
115452: LD_INT 800
115454: LESS
115455: AND
115456: PUSH
115457: LD_VAR 0 4
115461: PUSH
115462: LD_VAR 0 7
115466: ARRAY
115467: PPUSH
115468: CALL_OW 318
115472: NOT
115473: AND
115474: IFFALSE 115491
// ComCrawl ( group [ i ] ) ;
115476: LD_VAR 0 4
115480: PUSH
115481: LD_VAR 0 7
115485: ARRAY
115486: PPUSH
115487: CALL_OW 137
// if f_mines then
115491: LD_VAR 0 21
115495: IFFALSE 115738
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115497: LD_VAR 0 14
115501: PUSH
115502: LD_INT 1
115504: ARRAY
115505: PPUSH
115506: CALL_OW 247
115510: PUSH
115511: LD_INT 3
115513: EQUAL
115514: PUSH
115515: LD_VAR 0 14
115519: PUSH
115520: LD_INT 1
115522: ARRAY
115523: PUSH
115524: LD_VAR 0 27
115528: IN
115529: NOT
115530: AND
115531: IFFALSE 115738
// begin x := GetX ( tmp [ 1 ] ) ;
115533: LD_ADDR_VAR 0 10
115537: PUSH
115538: LD_VAR 0 14
115542: PUSH
115543: LD_INT 1
115545: ARRAY
115546: PPUSH
115547: CALL_OW 250
115551: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115552: LD_ADDR_VAR 0 11
115556: PUSH
115557: LD_VAR 0 14
115561: PUSH
115562: LD_INT 1
115564: ARRAY
115565: PPUSH
115566: CALL_OW 251
115570: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115571: LD_ADDR_VAR 0 12
115575: PUSH
115576: LD_VAR 0 4
115580: PUSH
115581: LD_VAR 0 7
115585: ARRAY
115586: PPUSH
115587: CALL 52822 0 1
115591: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115592: LD_VAR 0 4
115596: PUSH
115597: LD_VAR 0 7
115601: ARRAY
115602: PPUSH
115603: LD_VAR 0 10
115607: PPUSH
115608: LD_VAR 0 11
115612: PPUSH
115613: LD_VAR 0 14
115617: PUSH
115618: LD_INT 1
115620: ARRAY
115621: PPUSH
115622: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115626: LD_VAR 0 4
115630: PUSH
115631: LD_VAR 0 7
115635: ARRAY
115636: PPUSH
115637: LD_VAR 0 10
115641: PPUSH
115642: LD_VAR 0 12
115646: PPUSH
115647: LD_INT 7
115649: PPUSH
115650: CALL_OW 272
115654: PPUSH
115655: LD_VAR 0 11
115659: PPUSH
115660: LD_VAR 0 12
115664: PPUSH
115665: LD_INT 7
115667: PPUSH
115668: CALL_OW 273
115672: PPUSH
115673: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115677: LD_VAR 0 4
115681: PUSH
115682: LD_VAR 0 7
115686: ARRAY
115687: PPUSH
115688: LD_INT 71
115690: PPUSH
115691: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115695: LD_ADDR_VAR 0 27
115699: PUSH
115700: LD_VAR 0 27
115704: PPUSH
115705: LD_VAR 0 27
115709: PUSH
115710: LD_INT 1
115712: PLUS
115713: PPUSH
115714: LD_VAR 0 14
115718: PUSH
115719: LD_INT 1
115721: ARRAY
115722: PPUSH
115723: CALL_OW 1
115727: ST_TO_ADDR
// attacking := true ;
115728: LD_ADDR_VAR 0 29
115732: PUSH
115733: LD_INT 1
115735: ST_TO_ADDR
// continue ;
115736: GO 113583
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115738: LD_VAR 0 4
115742: PUSH
115743: LD_VAR 0 7
115747: ARRAY
115748: PPUSH
115749: CALL_OW 257
115753: PUSH
115754: LD_INT 17
115756: EQUAL
115757: PUSH
115758: LD_VAR 0 4
115762: PUSH
115763: LD_VAR 0 7
115767: ARRAY
115768: PPUSH
115769: CALL_OW 110
115773: PUSH
115774: LD_INT 71
115776: EQUAL
115777: NOT
115778: AND
115779: IFFALSE 115925
// begin attacking := false ;
115781: LD_ADDR_VAR 0 29
115785: PUSH
115786: LD_INT 0
115788: ST_TO_ADDR
// k := 5 ;
115789: LD_ADDR_VAR 0 9
115793: PUSH
115794: LD_INT 5
115796: ST_TO_ADDR
// if tmp < k then
115797: LD_VAR 0 14
115801: PUSH
115802: LD_VAR 0 9
115806: LESS
115807: IFFALSE 115819
// k := tmp ;
115809: LD_ADDR_VAR 0 9
115813: PUSH
115814: LD_VAR 0 14
115818: ST_TO_ADDR
// for j = 1 to k do
115819: LD_ADDR_VAR 0 8
115823: PUSH
115824: DOUBLE
115825: LD_INT 1
115827: DEC
115828: ST_TO_ADDR
115829: LD_VAR 0 9
115833: PUSH
115834: FOR_TO
115835: IFFALSE 115923
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115837: LD_VAR 0 14
115841: PUSH
115842: LD_VAR 0 8
115846: ARRAY
115847: PUSH
115848: LD_VAR 0 14
115852: PPUSH
115853: LD_INT 58
115855: PUSH
115856: EMPTY
115857: LIST
115858: PPUSH
115859: CALL_OW 72
115863: IN
115864: NOT
115865: IFFALSE 115921
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115867: LD_VAR 0 4
115871: PUSH
115872: LD_VAR 0 7
115876: ARRAY
115877: PPUSH
115878: LD_VAR 0 14
115882: PUSH
115883: LD_VAR 0 8
115887: ARRAY
115888: PPUSH
115889: CALL_OW 115
// attacking := true ;
115893: LD_ADDR_VAR 0 29
115897: PUSH
115898: LD_INT 1
115900: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115901: LD_VAR 0 4
115905: PUSH
115906: LD_VAR 0 7
115910: ARRAY
115911: PPUSH
115912: LD_INT 71
115914: PPUSH
115915: CALL_OW 109
// continue ;
115919: GO 115834
// end ; end ;
115921: GO 115834
115923: POP
115924: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115925: LD_VAR 0 4
115929: PUSH
115930: LD_VAR 0 7
115934: ARRAY
115935: PPUSH
115936: CALL_OW 257
115940: PUSH
115941: LD_INT 8
115943: EQUAL
115944: PUSH
115945: LD_VAR 0 4
115949: PUSH
115950: LD_VAR 0 7
115954: ARRAY
115955: PPUSH
115956: CALL_OW 264
115960: PUSH
115961: LD_INT 28
115963: PUSH
115964: LD_INT 45
115966: PUSH
115967: LD_INT 7
115969: PUSH
115970: LD_INT 47
115972: PUSH
115973: EMPTY
115974: LIST
115975: LIST
115976: LIST
115977: LIST
115978: IN
115979: OR
115980: IFFALSE 116236
// begin attacking := false ;
115982: LD_ADDR_VAR 0 29
115986: PUSH
115987: LD_INT 0
115989: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115990: LD_VAR 0 14
115994: PUSH
115995: LD_INT 1
115997: ARRAY
115998: PPUSH
115999: CALL_OW 266
116003: PUSH
116004: LD_INT 32
116006: PUSH
116007: LD_INT 31
116009: PUSH
116010: LD_INT 33
116012: PUSH
116013: LD_INT 4
116015: PUSH
116016: LD_INT 5
116018: PUSH
116019: EMPTY
116020: LIST
116021: LIST
116022: LIST
116023: LIST
116024: LIST
116025: IN
116026: IFFALSE 116212
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116028: LD_ADDR_VAR 0 9
116032: PUSH
116033: LD_VAR 0 14
116037: PUSH
116038: LD_INT 1
116040: ARRAY
116041: PPUSH
116042: CALL_OW 266
116046: PPUSH
116047: LD_VAR 0 14
116051: PUSH
116052: LD_INT 1
116054: ARRAY
116055: PPUSH
116056: CALL_OW 250
116060: PPUSH
116061: LD_VAR 0 14
116065: PUSH
116066: LD_INT 1
116068: ARRAY
116069: PPUSH
116070: CALL_OW 251
116074: PPUSH
116075: LD_VAR 0 14
116079: PUSH
116080: LD_INT 1
116082: ARRAY
116083: PPUSH
116084: CALL_OW 254
116088: PPUSH
116089: LD_VAR 0 14
116093: PUSH
116094: LD_INT 1
116096: ARRAY
116097: PPUSH
116098: CALL_OW 248
116102: PPUSH
116103: LD_INT 0
116105: PPUSH
116106: CALL 34192 0 6
116110: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116111: LD_ADDR_VAR 0 8
116115: PUSH
116116: LD_VAR 0 4
116120: PUSH
116121: LD_VAR 0 7
116125: ARRAY
116126: PPUSH
116127: LD_VAR 0 9
116131: PPUSH
116132: CALL 52935 0 2
116136: ST_TO_ADDR
// if j then
116137: LD_VAR 0 8
116141: IFFALSE 116210
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116143: LD_VAR 0 8
116147: PUSH
116148: LD_INT 1
116150: ARRAY
116151: PPUSH
116152: LD_VAR 0 8
116156: PUSH
116157: LD_INT 2
116159: ARRAY
116160: PPUSH
116161: CALL_OW 488
116165: IFFALSE 116210
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116167: LD_VAR 0 4
116171: PUSH
116172: LD_VAR 0 7
116176: ARRAY
116177: PPUSH
116178: LD_VAR 0 8
116182: PUSH
116183: LD_INT 1
116185: ARRAY
116186: PPUSH
116187: LD_VAR 0 8
116191: PUSH
116192: LD_INT 2
116194: ARRAY
116195: PPUSH
116196: CALL_OW 116
// attacking := true ;
116200: LD_ADDR_VAR 0 29
116204: PUSH
116205: LD_INT 1
116207: ST_TO_ADDR
// continue ;
116208: GO 113583
// end ; end else
116210: GO 116236
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116212: LD_VAR 0 4
116216: PUSH
116217: LD_VAR 0 7
116221: ARRAY
116222: PPUSH
116223: LD_VAR 0 14
116227: PUSH
116228: LD_INT 1
116230: ARRAY
116231: PPUSH
116232: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116236: LD_VAR 0 4
116240: PUSH
116241: LD_VAR 0 7
116245: ARRAY
116246: PPUSH
116247: CALL_OW 265
116251: PUSH
116252: LD_INT 11
116254: EQUAL
116255: IFFALSE 116533
// begin k := 10 ;
116257: LD_ADDR_VAR 0 9
116261: PUSH
116262: LD_INT 10
116264: ST_TO_ADDR
// x := 0 ;
116265: LD_ADDR_VAR 0 10
116269: PUSH
116270: LD_INT 0
116272: ST_TO_ADDR
// if tmp < k then
116273: LD_VAR 0 14
116277: PUSH
116278: LD_VAR 0 9
116282: LESS
116283: IFFALSE 116295
// k := tmp ;
116285: LD_ADDR_VAR 0 9
116289: PUSH
116290: LD_VAR 0 14
116294: ST_TO_ADDR
// for j = k downto 1 do
116295: LD_ADDR_VAR 0 8
116299: PUSH
116300: DOUBLE
116301: LD_VAR 0 9
116305: INC
116306: ST_TO_ADDR
116307: LD_INT 1
116309: PUSH
116310: FOR_DOWNTO
116311: IFFALSE 116386
// begin if GetType ( tmp [ j ] ) = unit_human then
116313: LD_VAR 0 14
116317: PUSH
116318: LD_VAR 0 8
116322: ARRAY
116323: PPUSH
116324: CALL_OW 247
116328: PUSH
116329: LD_INT 1
116331: EQUAL
116332: IFFALSE 116384
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116334: LD_VAR 0 4
116338: PUSH
116339: LD_VAR 0 7
116343: ARRAY
116344: PPUSH
116345: LD_VAR 0 14
116349: PUSH
116350: LD_VAR 0 8
116354: ARRAY
116355: PPUSH
116356: CALL 53189 0 2
// x := tmp [ j ] ;
116360: LD_ADDR_VAR 0 10
116364: PUSH
116365: LD_VAR 0 14
116369: PUSH
116370: LD_VAR 0 8
116374: ARRAY
116375: ST_TO_ADDR
// attacking := true ;
116376: LD_ADDR_VAR 0 29
116380: PUSH
116381: LD_INT 1
116383: ST_TO_ADDR
// end ; end ;
116384: GO 116310
116386: POP
116387: POP
// if not x then
116388: LD_VAR 0 10
116392: NOT
116393: IFFALSE 116533
// begin attacking := true ;
116395: LD_ADDR_VAR 0 29
116399: PUSH
116400: LD_INT 1
116402: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116403: LD_VAR 0 4
116407: PUSH
116408: LD_VAR 0 7
116412: ARRAY
116413: PPUSH
116414: CALL_OW 250
116418: PPUSH
116419: LD_VAR 0 4
116423: PUSH
116424: LD_VAR 0 7
116428: ARRAY
116429: PPUSH
116430: CALL_OW 251
116434: PPUSH
116435: CALL_OW 546
116439: PUSH
116440: LD_INT 2
116442: ARRAY
116443: PUSH
116444: LD_VAR 0 14
116448: PUSH
116449: LD_INT 1
116451: ARRAY
116452: PPUSH
116453: CALL_OW 250
116457: PPUSH
116458: LD_VAR 0 14
116462: PUSH
116463: LD_INT 1
116465: ARRAY
116466: PPUSH
116467: CALL_OW 251
116471: PPUSH
116472: CALL_OW 546
116476: PUSH
116477: LD_INT 2
116479: ARRAY
116480: EQUAL
116481: IFFALSE 116509
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116483: LD_VAR 0 4
116487: PUSH
116488: LD_VAR 0 7
116492: ARRAY
116493: PPUSH
116494: LD_VAR 0 14
116498: PUSH
116499: LD_INT 1
116501: ARRAY
116502: PPUSH
116503: CALL 53189 0 2
116507: GO 116533
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116509: LD_VAR 0 4
116513: PUSH
116514: LD_VAR 0 7
116518: ARRAY
116519: PPUSH
116520: LD_VAR 0 14
116524: PUSH
116525: LD_INT 1
116527: ARRAY
116528: PPUSH
116529: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116533: LD_VAR 0 4
116537: PUSH
116538: LD_VAR 0 7
116542: ARRAY
116543: PPUSH
116544: CALL_OW 264
116548: PUSH
116549: LD_INT 29
116551: EQUAL
116552: IFFALSE 116918
// begin if WantsToAttack ( group [ i ] ) in bombed then
116554: LD_VAR 0 4
116558: PUSH
116559: LD_VAR 0 7
116563: ARRAY
116564: PPUSH
116565: CALL_OW 319
116569: PUSH
116570: LD_VAR 0 28
116574: IN
116575: IFFALSE 116579
// continue ;
116577: GO 113583
// k := 8 ;
116579: LD_ADDR_VAR 0 9
116583: PUSH
116584: LD_INT 8
116586: ST_TO_ADDR
// x := 0 ;
116587: LD_ADDR_VAR 0 10
116591: PUSH
116592: LD_INT 0
116594: ST_TO_ADDR
// if tmp < k then
116595: LD_VAR 0 14
116599: PUSH
116600: LD_VAR 0 9
116604: LESS
116605: IFFALSE 116617
// k := tmp ;
116607: LD_ADDR_VAR 0 9
116611: PUSH
116612: LD_VAR 0 14
116616: ST_TO_ADDR
// for j = 1 to k do
116617: LD_ADDR_VAR 0 8
116621: PUSH
116622: DOUBLE
116623: LD_INT 1
116625: DEC
116626: ST_TO_ADDR
116627: LD_VAR 0 9
116631: PUSH
116632: FOR_TO
116633: IFFALSE 116765
// begin if GetType ( tmp [ j ] ) = unit_building then
116635: LD_VAR 0 14
116639: PUSH
116640: LD_VAR 0 8
116644: ARRAY
116645: PPUSH
116646: CALL_OW 247
116650: PUSH
116651: LD_INT 3
116653: EQUAL
116654: IFFALSE 116763
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116656: LD_VAR 0 14
116660: PUSH
116661: LD_VAR 0 8
116665: ARRAY
116666: PUSH
116667: LD_VAR 0 28
116671: IN
116672: NOT
116673: PUSH
116674: LD_VAR 0 14
116678: PUSH
116679: LD_VAR 0 8
116683: ARRAY
116684: PPUSH
116685: CALL_OW 313
116689: AND
116690: IFFALSE 116763
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116692: LD_VAR 0 4
116696: PUSH
116697: LD_VAR 0 7
116701: ARRAY
116702: PPUSH
116703: LD_VAR 0 14
116707: PUSH
116708: LD_VAR 0 8
116712: ARRAY
116713: PPUSH
116714: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116718: LD_ADDR_VAR 0 28
116722: PUSH
116723: LD_VAR 0 28
116727: PPUSH
116728: LD_VAR 0 28
116732: PUSH
116733: LD_INT 1
116735: PLUS
116736: PPUSH
116737: LD_VAR 0 14
116741: PUSH
116742: LD_VAR 0 8
116746: ARRAY
116747: PPUSH
116748: CALL_OW 1
116752: ST_TO_ADDR
// attacking := true ;
116753: LD_ADDR_VAR 0 29
116757: PUSH
116758: LD_INT 1
116760: ST_TO_ADDR
// break ;
116761: GO 116765
// end ; end ;
116763: GO 116632
116765: POP
116766: POP
// if not attacking and f_attack_depot then
116767: LD_VAR 0 29
116771: NOT
116772: PUSH
116773: LD_VAR 0 25
116777: AND
116778: IFFALSE 116873
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116780: LD_ADDR_VAR 0 13
116784: PUSH
116785: LD_VAR 0 14
116789: PPUSH
116790: LD_INT 2
116792: PUSH
116793: LD_INT 30
116795: PUSH
116796: LD_INT 0
116798: PUSH
116799: EMPTY
116800: LIST
116801: LIST
116802: PUSH
116803: LD_INT 30
116805: PUSH
116806: LD_INT 1
116808: PUSH
116809: EMPTY
116810: LIST
116811: LIST
116812: PUSH
116813: EMPTY
116814: LIST
116815: LIST
116816: LIST
116817: PPUSH
116818: CALL_OW 72
116822: ST_TO_ADDR
// if z then
116823: LD_VAR 0 13
116827: IFFALSE 116873
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116829: LD_VAR 0 4
116833: PUSH
116834: LD_VAR 0 7
116838: ARRAY
116839: PPUSH
116840: LD_VAR 0 13
116844: PPUSH
116845: LD_VAR 0 4
116849: PUSH
116850: LD_VAR 0 7
116854: ARRAY
116855: PPUSH
116856: CALL_OW 74
116860: PPUSH
116861: CALL_OW 115
// attacking := true ;
116865: LD_ADDR_VAR 0 29
116869: PUSH
116870: LD_INT 1
116872: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116873: LD_VAR 0 4
116877: PUSH
116878: LD_VAR 0 7
116882: ARRAY
116883: PPUSH
116884: CALL_OW 256
116888: PUSH
116889: LD_INT 500
116891: LESS
116892: IFFALSE 116918
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116894: LD_VAR 0 4
116898: PUSH
116899: LD_VAR 0 7
116903: ARRAY
116904: PPUSH
116905: LD_VAR 0 14
116909: PUSH
116910: LD_INT 1
116912: ARRAY
116913: PPUSH
116914: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116918: LD_VAR 0 4
116922: PUSH
116923: LD_VAR 0 7
116927: ARRAY
116928: PPUSH
116929: CALL_OW 264
116933: PUSH
116934: LD_INT 49
116936: EQUAL
116937: IFFALSE 117058
// begin if not HasTask ( group [ i ] ) then
116939: LD_VAR 0 4
116943: PUSH
116944: LD_VAR 0 7
116948: ARRAY
116949: PPUSH
116950: CALL_OW 314
116954: NOT
116955: IFFALSE 117058
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116957: LD_ADDR_VAR 0 9
116961: PUSH
116962: LD_INT 81
116964: PUSH
116965: LD_VAR 0 4
116969: PUSH
116970: LD_VAR 0 7
116974: ARRAY
116975: PPUSH
116976: CALL_OW 255
116980: PUSH
116981: EMPTY
116982: LIST
116983: LIST
116984: PPUSH
116985: CALL_OW 69
116989: PPUSH
116990: LD_VAR 0 4
116994: PUSH
116995: LD_VAR 0 7
116999: ARRAY
117000: PPUSH
117001: CALL_OW 74
117005: ST_TO_ADDR
// if k then
117006: LD_VAR 0 9
117010: IFFALSE 117058
// if GetDistUnits ( group [ i ] , k ) > 10 then
117012: LD_VAR 0 4
117016: PUSH
117017: LD_VAR 0 7
117021: ARRAY
117022: PPUSH
117023: LD_VAR 0 9
117027: PPUSH
117028: CALL_OW 296
117032: PUSH
117033: LD_INT 10
117035: GREATER
117036: IFFALSE 117058
// ComMoveUnit ( group [ i ] , k ) ;
117038: LD_VAR 0 4
117042: PUSH
117043: LD_VAR 0 7
117047: ARRAY
117048: PPUSH
117049: LD_VAR 0 9
117053: PPUSH
117054: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117058: LD_VAR 0 4
117062: PUSH
117063: LD_VAR 0 7
117067: ARRAY
117068: PPUSH
117069: CALL_OW 256
117073: PUSH
117074: LD_INT 250
117076: LESS
117077: PUSH
117078: LD_VAR 0 4
117082: PUSH
117083: LD_VAR 0 7
117087: ARRAY
117088: PUSH
117089: LD_INT 21
117091: PUSH
117092: LD_INT 2
117094: PUSH
117095: EMPTY
117096: LIST
117097: LIST
117098: PUSH
117099: LD_INT 23
117101: PUSH
117102: LD_INT 2
117104: PUSH
117105: EMPTY
117106: LIST
117107: LIST
117108: PUSH
117109: EMPTY
117110: LIST
117111: LIST
117112: PPUSH
117113: CALL_OW 69
117117: IN
117118: AND
117119: IFFALSE 117244
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117121: LD_ADDR_VAR 0 9
117125: PUSH
117126: LD_OWVAR 3
117130: PUSH
117131: LD_VAR 0 4
117135: PUSH
117136: LD_VAR 0 7
117140: ARRAY
117141: DIFF
117142: PPUSH
117143: LD_VAR 0 4
117147: PUSH
117148: LD_VAR 0 7
117152: ARRAY
117153: PPUSH
117154: CALL_OW 74
117158: ST_TO_ADDR
// if not k then
117159: LD_VAR 0 9
117163: NOT
117164: IFFALSE 117168
// continue ;
117166: GO 113583
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117168: LD_VAR 0 9
117172: PUSH
117173: LD_INT 81
117175: PUSH
117176: LD_VAR 0 4
117180: PUSH
117181: LD_VAR 0 7
117185: ARRAY
117186: PPUSH
117187: CALL_OW 255
117191: PUSH
117192: EMPTY
117193: LIST
117194: LIST
117195: PPUSH
117196: CALL_OW 69
117200: IN
117201: PUSH
117202: LD_VAR 0 9
117206: PPUSH
117207: LD_VAR 0 4
117211: PUSH
117212: LD_VAR 0 7
117216: ARRAY
117217: PPUSH
117218: CALL_OW 296
117222: PUSH
117223: LD_INT 5
117225: LESS
117226: AND
117227: IFFALSE 117244
// ComAutodestruct ( group [ i ] ) ;
117229: LD_VAR 0 4
117233: PUSH
117234: LD_VAR 0 7
117238: ARRAY
117239: PPUSH
117240: CALL 53087 0 1
// end ; if f_attack_depot then
117244: LD_VAR 0 25
117248: IFFALSE 117360
// begin k := 6 ;
117250: LD_ADDR_VAR 0 9
117254: PUSH
117255: LD_INT 6
117257: ST_TO_ADDR
// if tmp < k then
117258: LD_VAR 0 14
117262: PUSH
117263: LD_VAR 0 9
117267: LESS
117268: IFFALSE 117280
// k := tmp ;
117270: LD_ADDR_VAR 0 9
117274: PUSH
117275: LD_VAR 0 14
117279: ST_TO_ADDR
// for j = 1 to k do
117280: LD_ADDR_VAR 0 8
117284: PUSH
117285: DOUBLE
117286: LD_INT 1
117288: DEC
117289: ST_TO_ADDR
117290: LD_VAR 0 9
117294: PUSH
117295: FOR_TO
117296: IFFALSE 117358
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117298: LD_VAR 0 8
117302: PPUSH
117303: CALL_OW 266
117307: PUSH
117308: LD_INT 0
117310: PUSH
117311: LD_INT 1
117313: PUSH
117314: EMPTY
117315: LIST
117316: LIST
117317: IN
117318: IFFALSE 117356
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117320: LD_VAR 0 4
117324: PUSH
117325: LD_VAR 0 7
117329: ARRAY
117330: PPUSH
117331: LD_VAR 0 14
117335: PUSH
117336: LD_VAR 0 8
117340: ARRAY
117341: PPUSH
117342: CALL_OW 115
// attacking := true ;
117346: LD_ADDR_VAR 0 29
117350: PUSH
117351: LD_INT 1
117353: ST_TO_ADDR
// break ;
117354: GO 117358
// end ;
117356: GO 117295
117358: POP
117359: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117360: LD_VAR 0 4
117364: PUSH
117365: LD_VAR 0 7
117369: ARRAY
117370: PPUSH
117371: CALL_OW 302
117375: PUSH
117376: LD_VAR 0 29
117380: NOT
117381: AND
117382: IFFALSE 117704
// begin if GetTag ( group [ i ] ) = 71 then
117384: LD_VAR 0 4
117388: PUSH
117389: LD_VAR 0 7
117393: ARRAY
117394: PPUSH
117395: CALL_OW 110
117399: PUSH
117400: LD_INT 71
117402: EQUAL
117403: IFFALSE 117444
// begin if HasTask ( group [ i ] ) then
117405: LD_VAR 0 4
117409: PUSH
117410: LD_VAR 0 7
117414: ARRAY
117415: PPUSH
117416: CALL_OW 314
117420: IFFALSE 117426
// continue else
117422: GO 113583
117424: GO 117444
// SetTag ( group [ i ] , 0 ) ;
117426: LD_VAR 0 4
117430: PUSH
117431: LD_VAR 0 7
117435: ARRAY
117436: PPUSH
117437: LD_INT 0
117439: PPUSH
117440: CALL_OW 109
// end ; k := 8 ;
117444: LD_ADDR_VAR 0 9
117448: PUSH
117449: LD_INT 8
117451: ST_TO_ADDR
// x := 0 ;
117452: LD_ADDR_VAR 0 10
117456: PUSH
117457: LD_INT 0
117459: ST_TO_ADDR
// if tmp < k then
117460: LD_VAR 0 14
117464: PUSH
117465: LD_VAR 0 9
117469: LESS
117470: IFFALSE 117482
// k := tmp ;
117472: LD_ADDR_VAR 0 9
117476: PUSH
117477: LD_VAR 0 14
117481: ST_TO_ADDR
// for j = 1 to k do
117482: LD_ADDR_VAR 0 8
117486: PUSH
117487: DOUBLE
117488: LD_INT 1
117490: DEC
117491: ST_TO_ADDR
117492: LD_VAR 0 9
117496: PUSH
117497: FOR_TO
117498: IFFALSE 117596
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117500: LD_VAR 0 14
117504: PUSH
117505: LD_VAR 0 8
117509: ARRAY
117510: PPUSH
117511: CALL_OW 247
117515: PUSH
117516: LD_INT 1
117518: EQUAL
117519: PUSH
117520: LD_VAR 0 14
117524: PUSH
117525: LD_VAR 0 8
117529: ARRAY
117530: PPUSH
117531: CALL_OW 256
117535: PUSH
117536: LD_INT 250
117538: LESS
117539: PUSH
117540: LD_VAR 0 20
117544: AND
117545: PUSH
117546: LD_VAR 0 20
117550: NOT
117551: PUSH
117552: LD_VAR 0 14
117556: PUSH
117557: LD_VAR 0 8
117561: ARRAY
117562: PPUSH
117563: CALL_OW 256
117567: PUSH
117568: LD_INT 250
117570: GREATEREQUAL
117571: AND
117572: OR
117573: AND
117574: IFFALSE 117594
// begin x := tmp [ j ] ;
117576: LD_ADDR_VAR 0 10
117580: PUSH
117581: LD_VAR 0 14
117585: PUSH
117586: LD_VAR 0 8
117590: ARRAY
117591: ST_TO_ADDR
// break ;
117592: GO 117596
// end ;
117594: GO 117497
117596: POP
117597: POP
// if x then
117598: LD_VAR 0 10
117602: IFFALSE 117626
// ComAttackUnit ( group [ i ] , x ) else
117604: LD_VAR 0 4
117608: PUSH
117609: LD_VAR 0 7
117613: ARRAY
117614: PPUSH
117615: LD_VAR 0 10
117619: PPUSH
117620: CALL_OW 115
117624: GO 117650
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117626: LD_VAR 0 4
117630: PUSH
117631: LD_VAR 0 7
117635: ARRAY
117636: PPUSH
117637: LD_VAR 0 14
117641: PUSH
117642: LD_INT 1
117644: ARRAY
117645: PPUSH
117646: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117650: LD_VAR 0 4
117654: PUSH
117655: LD_VAR 0 7
117659: ARRAY
117660: PPUSH
117661: CALL_OW 314
117665: NOT
117666: IFFALSE 117704
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117668: LD_VAR 0 4
117672: PUSH
117673: LD_VAR 0 7
117677: ARRAY
117678: PPUSH
117679: LD_VAR 0 14
117683: PPUSH
117684: LD_VAR 0 4
117688: PUSH
117689: LD_VAR 0 7
117693: ARRAY
117694: PPUSH
117695: CALL_OW 74
117699: PPUSH
117700: CALL_OW 115
// end ; end ; end ;
117704: GO 113583
117706: POP
117707: POP
// wait ( 0 0$2 ) ;
117708: LD_INT 70
117710: PPUSH
117711: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117715: LD_VAR 0 4
117719: NOT
117720: PUSH
117721: LD_VAR 0 4
117725: PUSH
117726: EMPTY
117727: EQUAL
117728: OR
117729: PUSH
117730: LD_INT 81
117732: PUSH
117733: LD_VAR 0 35
117737: PUSH
117738: EMPTY
117739: LIST
117740: LIST
117741: PPUSH
117742: CALL_OW 69
117746: NOT
117747: OR
117748: IFFALSE 113568
// end ;
117750: LD_VAR 0 2
117754: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
117755: LD_INT 0
117757: PPUSH
117758: PPUSH
117759: PPUSH
117760: PPUSH
117761: PPUSH
117762: PPUSH
// if not base or not mc_bases [ base ] or not solds then
117763: LD_VAR 0 1
117767: NOT
117768: PUSH
117769: LD_EXP 31
117773: PUSH
117774: LD_VAR 0 1
117778: ARRAY
117779: NOT
117780: OR
117781: PUSH
117782: LD_VAR 0 2
117786: NOT
117787: OR
117788: IFFALSE 117792
// exit ;
117790: GO 118346
// side := mc_sides [ base ] ;
117792: LD_ADDR_VAR 0 6
117796: PUSH
117797: LD_EXP 57
117801: PUSH
117802: LD_VAR 0 1
117806: ARRAY
117807: ST_TO_ADDR
// if not side then
117808: LD_VAR 0 6
117812: NOT
117813: IFFALSE 117817
// exit ;
117815: GO 118346
// for i in solds do
117817: LD_ADDR_VAR 0 7
117821: PUSH
117822: LD_VAR 0 2
117826: PUSH
117827: FOR_IN
117828: IFFALSE 117889
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117830: LD_VAR 0 7
117834: PPUSH
117835: CALL_OW 310
117839: PPUSH
117840: CALL_OW 266
117844: PUSH
117845: LD_INT 32
117847: PUSH
117848: LD_INT 31
117850: PUSH
117851: EMPTY
117852: LIST
117853: LIST
117854: IN
117855: IFFALSE 117875
// solds := solds diff i else
117857: LD_ADDR_VAR 0 2
117861: PUSH
117862: LD_VAR 0 2
117866: PUSH
117867: LD_VAR 0 7
117871: DIFF
117872: ST_TO_ADDR
117873: GO 117887
// SetTag ( i , 18 ) ;
117875: LD_VAR 0 7
117879: PPUSH
117880: LD_INT 18
117882: PPUSH
117883: CALL_OW 109
117887: GO 117827
117889: POP
117890: POP
// if not solds then
117891: LD_VAR 0 2
117895: NOT
117896: IFFALSE 117900
// exit ;
117898: GO 118346
// repeat wait ( 0 0$2 ) ;
117900: LD_INT 70
117902: PPUSH
117903: CALL_OW 67
// enemy := mc_scan [ base ] ;
117907: LD_ADDR_VAR 0 4
117911: PUSH
117912: LD_EXP 54
117916: PUSH
117917: LD_VAR 0 1
117921: ARRAY
117922: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117923: LD_EXP 31
117927: PUSH
117928: LD_VAR 0 1
117932: ARRAY
117933: NOT
117934: PUSH
117935: LD_EXP 31
117939: PUSH
117940: LD_VAR 0 1
117944: ARRAY
117945: PUSH
117946: EMPTY
117947: EQUAL
117948: OR
117949: IFFALSE 117986
// begin for i in solds do
117951: LD_ADDR_VAR 0 7
117955: PUSH
117956: LD_VAR 0 2
117960: PUSH
117961: FOR_IN
117962: IFFALSE 117975
// ComStop ( i ) ;
117964: LD_VAR 0 7
117968: PPUSH
117969: CALL_OW 141
117973: GO 117961
117975: POP
117976: POP
// solds := [ ] ;
117977: LD_ADDR_VAR 0 2
117981: PUSH
117982: EMPTY
117983: ST_TO_ADDR
// exit ;
117984: GO 118346
// end ; for i in solds do
117986: LD_ADDR_VAR 0 7
117990: PUSH
117991: LD_VAR 0 2
117995: PUSH
117996: FOR_IN
117997: IFFALSE 118318
// begin if IsInUnit ( i ) then
117999: LD_VAR 0 7
118003: PPUSH
118004: CALL_OW 310
118008: IFFALSE 118019
// ComExitBuilding ( i ) ;
118010: LD_VAR 0 7
118014: PPUSH
118015: CALL_OW 122
// if GetLives ( i ) > 500 then
118019: LD_VAR 0 7
118023: PPUSH
118024: CALL_OW 256
118028: PUSH
118029: LD_INT 500
118031: GREATER
118032: IFFALSE 118085
// begin e := NearestUnitToUnit ( enemy , i ) ;
118034: LD_ADDR_VAR 0 5
118038: PUSH
118039: LD_VAR 0 4
118043: PPUSH
118044: LD_VAR 0 7
118048: PPUSH
118049: CALL_OW 74
118053: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
118054: LD_VAR 0 7
118058: PPUSH
118059: LD_VAR 0 5
118063: PPUSH
118064: CALL_OW 250
118068: PPUSH
118069: LD_VAR 0 5
118073: PPUSH
118074: CALL_OW 251
118078: PPUSH
118079: CALL_OW 114
// end else
118083: GO 118316
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118085: LD_VAR 0 7
118089: PPUSH
118090: LD_EXP 31
118094: PUSH
118095: LD_VAR 0 1
118099: ARRAY
118100: PPUSH
118101: LD_INT 2
118103: PUSH
118104: LD_INT 30
118106: PUSH
118107: LD_INT 0
118109: PUSH
118110: EMPTY
118111: LIST
118112: LIST
118113: PUSH
118114: LD_INT 30
118116: PUSH
118117: LD_INT 1
118119: PUSH
118120: EMPTY
118121: LIST
118122: LIST
118123: PUSH
118124: LD_INT 30
118126: PUSH
118127: LD_INT 6
118129: PUSH
118130: EMPTY
118131: LIST
118132: LIST
118133: PUSH
118134: EMPTY
118135: LIST
118136: LIST
118137: LIST
118138: LIST
118139: PPUSH
118140: CALL_OW 72
118144: PPUSH
118145: LD_VAR 0 7
118149: PPUSH
118150: CALL_OW 74
118154: PPUSH
118155: CALL_OW 296
118159: PUSH
118160: LD_INT 10
118162: GREATER
118163: IFFALSE 118316
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118165: LD_ADDR_VAR 0 8
118169: PUSH
118170: LD_EXP 31
118174: PUSH
118175: LD_VAR 0 1
118179: ARRAY
118180: PPUSH
118181: LD_INT 2
118183: PUSH
118184: LD_INT 30
118186: PUSH
118187: LD_INT 0
118189: PUSH
118190: EMPTY
118191: LIST
118192: LIST
118193: PUSH
118194: LD_INT 30
118196: PUSH
118197: LD_INT 1
118199: PUSH
118200: EMPTY
118201: LIST
118202: LIST
118203: PUSH
118204: LD_INT 30
118206: PUSH
118207: LD_INT 6
118209: PUSH
118210: EMPTY
118211: LIST
118212: LIST
118213: PUSH
118214: EMPTY
118215: LIST
118216: LIST
118217: LIST
118218: LIST
118219: PPUSH
118220: CALL_OW 72
118224: PPUSH
118225: LD_VAR 0 7
118229: PPUSH
118230: CALL_OW 74
118234: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118235: LD_VAR 0 7
118239: PPUSH
118240: LD_VAR 0 8
118244: PPUSH
118245: CALL_OW 250
118249: PPUSH
118250: LD_INT 3
118252: PPUSH
118253: LD_INT 5
118255: PPUSH
118256: CALL_OW 272
118260: PPUSH
118261: LD_VAR 0 8
118265: PPUSH
118266: CALL_OW 251
118270: PPUSH
118271: LD_INT 3
118273: PPUSH
118274: LD_INT 5
118276: PPUSH
118277: CALL_OW 273
118281: PPUSH
118282: CALL_OW 111
// SetTag ( i , 0 ) ;
118286: LD_VAR 0 7
118290: PPUSH
118291: LD_INT 0
118293: PPUSH
118294: CALL_OW 109
// solds := solds diff i ;
118298: LD_ADDR_VAR 0 2
118302: PUSH
118303: LD_VAR 0 2
118307: PUSH
118308: LD_VAR 0 7
118312: DIFF
118313: ST_TO_ADDR
// continue ;
118314: GO 117996
// end ; end ;
118316: GO 117996
118318: POP
118319: POP
// until not solds or not enemy ;
118320: LD_VAR 0 2
118324: NOT
118325: PUSH
118326: LD_VAR 0 4
118330: NOT
118331: OR
118332: IFFALSE 117900
// MC_Reset ( base , 18 ) ;
118334: LD_VAR 0 1
118338: PPUSH
118339: LD_INT 18
118341: PPUSH
118342: CALL 65977 0 2
// end ;
118346: LD_VAR 0 3
118350: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118351: LD_INT 0
118353: PPUSH
118354: PPUSH
118355: PPUSH
118356: PPUSH
118357: PPUSH
118358: PPUSH
118359: PPUSH
118360: PPUSH
118361: PPUSH
118362: PPUSH
118363: PPUSH
118364: PPUSH
118365: PPUSH
118366: PPUSH
118367: PPUSH
118368: PPUSH
118369: PPUSH
118370: PPUSH
118371: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118372: LD_ADDR_VAR 0 12
118376: PUSH
118377: LD_EXP 31
118381: PUSH
118382: LD_VAR 0 1
118386: ARRAY
118387: PPUSH
118388: LD_INT 25
118390: PUSH
118391: LD_INT 3
118393: PUSH
118394: EMPTY
118395: LIST
118396: LIST
118397: PPUSH
118398: CALL_OW 72
118402: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118403: LD_EXP 71
118407: PUSH
118408: LD_VAR 0 1
118412: ARRAY
118413: IFFALSE 118437
// mechs := mechs diff mc_remote_driver [ base ] ;
118415: LD_ADDR_VAR 0 12
118419: PUSH
118420: LD_VAR 0 12
118424: PUSH
118425: LD_EXP 71
118429: PUSH
118430: LD_VAR 0 1
118434: ARRAY
118435: DIFF
118436: ST_TO_ADDR
// for i in mechs do
118437: LD_ADDR_VAR 0 4
118441: PUSH
118442: LD_VAR 0 12
118446: PUSH
118447: FOR_IN
118448: IFFALSE 118483
// if GetTag ( i ) > 0 then
118450: LD_VAR 0 4
118454: PPUSH
118455: CALL_OW 110
118459: PUSH
118460: LD_INT 0
118462: GREATER
118463: IFFALSE 118481
// mechs := mechs diff i ;
118465: LD_ADDR_VAR 0 12
118469: PUSH
118470: LD_VAR 0 12
118474: PUSH
118475: LD_VAR 0 4
118479: DIFF
118480: ST_TO_ADDR
118481: GO 118447
118483: POP
118484: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118485: LD_ADDR_VAR 0 8
118489: PUSH
118490: LD_EXP 31
118494: PUSH
118495: LD_VAR 0 1
118499: ARRAY
118500: PPUSH
118501: LD_INT 2
118503: PUSH
118504: LD_INT 25
118506: PUSH
118507: LD_INT 1
118509: PUSH
118510: EMPTY
118511: LIST
118512: LIST
118513: PUSH
118514: LD_INT 25
118516: PUSH
118517: LD_INT 5
118519: PUSH
118520: EMPTY
118521: LIST
118522: LIST
118523: PUSH
118524: LD_INT 25
118526: PUSH
118527: LD_INT 8
118529: PUSH
118530: EMPTY
118531: LIST
118532: LIST
118533: PUSH
118534: LD_INT 25
118536: PUSH
118537: LD_INT 9
118539: PUSH
118540: EMPTY
118541: LIST
118542: LIST
118543: PUSH
118544: EMPTY
118545: LIST
118546: LIST
118547: LIST
118548: LIST
118549: LIST
118550: PPUSH
118551: CALL_OW 72
118555: ST_TO_ADDR
// if not defenders and not solds then
118556: LD_VAR 0 2
118560: NOT
118561: PUSH
118562: LD_VAR 0 8
118566: NOT
118567: AND
118568: IFFALSE 118572
// exit ;
118570: GO 120342
// depot_under_attack := false ;
118572: LD_ADDR_VAR 0 16
118576: PUSH
118577: LD_INT 0
118579: ST_TO_ADDR
// sold_defenders := [ ] ;
118580: LD_ADDR_VAR 0 17
118584: PUSH
118585: EMPTY
118586: ST_TO_ADDR
// if mechs then
118587: LD_VAR 0 12
118591: IFFALSE 118744
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
118593: LD_ADDR_VAR 0 4
118597: PUSH
118598: LD_VAR 0 2
118602: PPUSH
118603: LD_INT 21
118605: PUSH
118606: LD_INT 2
118608: PUSH
118609: EMPTY
118610: LIST
118611: LIST
118612: PPUSH
118613: CALL_OW 72
118617: PUSH
118618: FOR_IN
118619: IFFALSE 118742
// begin if GetTag ( i ) <> 20 then
118621: LD_VAR 0 4
118625: PPUSH
118626: CALL_OW 110
118630: PUSH
118631: LD_INT 20
118633: NONEQUAL
118634: IFFALSE 118648
// SetTag ( i , 20 ) ;
118636: LD_VAR 0 4
118640: PPUSH
118641: LD_INT 20
118643: PPUSH
118644: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
118648: LD_VAR 0 4
118652: PPUSH
118653: CALL_OW 263
118657: PUSH
118658: LD_INT 1
118660: EQUAL
118661: PUSH
118662: LD_VAR 0 4
118666: PPUSH
118667: CALL_OW 311
118671: NOT
118672: AND
118673: IFFALSE 118740
// begin un := mechs [ 1 ] ;
118675: LD_ADDR_VAR 0 10
118679: PUSH
118680: LD_VAR 0 12
118684: PUSH
118685: LD_INT 1
118687: ARRAY
118688: ST_TO_ADDR
// ComExit ( un ) ;
118689: LD_VAR 0 10
118693: PPUSH
118694: CALL 57984 0 1
// AddComEnterUnit ( un , i ) ;
118698: LD_VAR 0 10
118702: PPUSH
118703: LD_VAR 0 4
118707: PPUSH
118708: CALL_OW 180
// SetTag ( un , 19 ) ;
118712: LD_VAR 0 10
118716: PPUSH
118717: LD_INT 19
118719: PPUSH
118720: CALL_OW 109
// mechs := mechs diff un ;
118724: LD_ADDR_VAR 0 12
118728: PUSH
118729: LD_VAR 0 12
118733: PUSH
118734: LD_VAR 0 10
118738: DIFF
118739: ST_TO_ADDR
// end ; end ;
118740: GO 118618
118742: POP
118743: POP
// if solds then
118744: LD_VAR 0 8
118748: IFFALSE 118807
// for i in solds do
118750: LD_ADDR_VAR 0 4
118754: PUSH
118755: LD_VAR 0 8
118759: PUSH
118760: FOR_IN
118761: IFFALSE 118805
// if not GetTag ( i ) then
118763: LD_VAR 0 4
118767: PPUSH
118768: CALL_OW 110
118772: NOT
118773: IFFALSE 118803
// begin defenders := defenders union i ;
118775: LD_ADDR_VAR 0 2
118779: PUSH
118780: LD_VAR 0 2
118784: PUSH
118785: LD_VAR 0 4
118789: UNION
118790: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118791: LD_VAR 0 4
118795: PPUSH
118796: LD_INT 18
118798: PPUSH
118799: CALL_OW 109
// end ;
118803: GO 118760
118805: POP
118806: POP
// repeat wait ( 0 0$2 ) ;
118807: LD_INT 70
118809: PPUSH
118810: CALL_OW 67
// enemy := mc_scan [ base ] ;
118814: LD_ADDR_VAR 0 21
118818: PUSH
118819: LD_EXP 54
118823: PUSH
118824: LD_VAR 0 1
118828: ARRAY
118829: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118830: LD_EXP 31
118834: PUSH
118835: LD_VAR 0 1
118839: ARRAY
118840: NOT
118841: PUSH
118842: LD_EXP 31
118846: PUSH
118847: LD_VAR 0 1
118851: ARRAY
118852: PUSH
118853: EMPTY
118854: EQUAL
118855: OR
118856: IFFALSE 118893
// begin for i in defenders do
118858: LD_ADDR_VAR 0 4
118862: PUSH
118863: LD_VAR 0 2
118867: PUSH
118868: FOR_IN
118869: IFFALSE 118882
// ComStop ( i ) ;
118871: LD_VAR 0 4
118875: PPUSH
118876: CALL_OW 141
118880: GO 118868
118882: POP
118883: POP
// defenders := [ ] ;
118884: LD_ADDR_VAR 0 2
118888: PUSH
118889: EMPTY
118890: ST_TO_ADDR
// exit ;
118891: GO 120342
// end ; for i in defenders do
118893: LD_ADDR_VAR 0 4
118897: PUSH
118898: LD_VAR 0 2
118902: PUSH
118903: FOR_IN
118904: IFFALSE 119802
// begin e := NearestUnitToUnit ( enemy , i ) ;
118906: LD_ADDR_VAR 0 13
118910: PUSH
118911: LD_VAR 0 21
118915: PPUSH
118916: LD_VAR 0 4
118920: PPUSH
118921: CALL_OW 74
118925: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118926: LD_ADDR_VAR 0 7
118930: PUSH
118931: LD_EXP 31
118935: PUSH
118936: LD_VAR 0 1
118940: ARRAY
118941: PPUSH
118942: LD_INT 2
118944: PUSH
118945: LD_INT 30
118947: PUSH
118948: LD_INT 0
118950: PUSH
118951: EMPTY
118952: LIST
118953: LIST
118954: PUSH
118955: LD_INT 30
118957: PUSH
118958: LD_INT 1
118960: PUSH
118961: EMPTY
118962: LIST
118963: LIST
118964: PUSH
118965: EMPTY
118966: LIST
118967: LIST
118968: LIST
118969: PPUSH
118970: CALL_OW 72
118974: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118975: LD_ADDR_VAR 0 16
118979: PUSH
118980: LD_VAR 0 7
118984: NOT
118985: PUSH
118986: LD_VAR 0 7
118990: PPUSH
118991: LD_INT 3
118993: PUSH
118994: LD_INT 24
118996: PUSH
118997: LD_INT 600
118999: PUSH
119000: EMPTY
119001: LIST
119002: LIST
119003: PUSH
119004: EMPTY
119005: LIST
119006: LIST
119007: PPUSH
119008: CALL_OW 72
119012: OR
119013: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119014: LD_VAR 0 4
119018: PPUSH
119019: CALL_OW 247
119023: PUSH
119024: LD_INT 2
119026: DOUBLE
119027: EQUAL
119028: IFTRUE 119032
119030: GO 119428
119032: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
119033: LD_VAR 0 4
119037: PPUSH
119038: CALL_OW 256
119042: PUSH
119043: LD_INT 1000
119045: EQUAL
119046: PUSH
119047: LD_VAR 0 4
119051: PPUSH
119052: LD_VAR 0 13
119056: PPUSH
119057: CALL_OW 296
119061: PUSH
119062: LD_INT 40
119064: LESS
119065: PUSH
119066: LD_VAR 0 13
119070: PPUSH
119071: LD_EXP 56
119075: PUSH
119076: LD_VAR 0 1
119080: ARRAY
119081: PPUSH
119082: CALL_OW 308
119086: OR
119087: AND
119088: IFFALSE 119210
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119090: LD_VAR 0 4
119094: PPUSH
119095: CALL_OW 262
119099: PUSH
119100: LD_INT 1
119102: EQUAL
119103: PUSH
119104: LD_VAR 0 4
119108: PPUSH
119109: CALL_OW 261
119113: PUSH
119114: LD_INT 30
119116: LESS
119117: AND
119118: PUSH
119119: LD_VAR 0 7
119123: AND
119124: IFFALSE 119194
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119126: LD_VAR 0 4
119130: PPUSH
119131: LD_VAR 0 7
119135: PPUSH
119136: LD_VAR 0 4
119140: PPUSH
119141: CALL_OW 74
119145: PPUSH
119146: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119150: LD_VAR 0 4
119154: PPUSH
119155: LD_VAR 0 7
119159: PPUSH
119160: LD_VAR 0 4
119164: PPUSH
119165: CALL_OW 74
119169: PPUSH
119170: CALL_OW 296
119174: PUSH
119175: LD_INT 6
119177: LESS
119178: IFFALSE 119192
// SetFuel ( i , 100 ) ;
119180: LD_VAR 0 4
119184: PPUSH
119185: LD_INT 100
119187: PPUSH
119188: CALL_OW 240
// end else
119192: GO 119208
// ComAttackUnit ( i , e ) ;
119194: LD_VAR 0 4
119198: PPUSH
119199: LD_VAR 0 13
119203: PPUSH
119204: CALL_OW 115
// end else
119208: GO 119311
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119210: LD_VAR 0 13
119214: PPUSH
119215: LD_EXP 56
119219: PUSH
119220: LD_VAR 0 1
119224: ARRAY
119225: PPUSH
119226: CALL_OW 308
119230: NOT
119231: PUSH
119232: LD_VAR 0 4
119236: PPUSH
119237: LD_VAR 0 13
119241: PPUSH
119242: CALL_OW 296
119246: PUSH
119247: LD_INT 40
119249: GREATEREQUAL
119250: AND
119251: PUSH
119252: LD_VAR 0 4
119256: PPUSH
119257: CALL_OW 256
119261: PUSH
119262: LD_INT 650
119264: LESSEQUAL
119265: OR
119266: PUSH
119267: LD_VAR 0 4
119271: PPUSH
119272: LD_EXP 55
119276: PUSH
119277: LD_VAR 0 1
119281: ARRAY
119282: PPUSH
119283: CALL_OW 308
119287: NOT
119288: AND
119289: IFFALSE 119311
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119291: LD_VAR 0 4
119295: PPUSH
119296: LD_EXP 55
119300: PUSH
119301: LD_VAR 0 1
119305: ARRAY
119306: PPUSH
119307: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119311: LD_VAR 0 4
119315: PPUSH
119316: CALL_OW 256
119320: PUSH
119321: LD_INT 1000
119323: LESS
119324: PUSH
119325: LD_VAR 0 4
119329: PPUSH
119330: CALL_OW 263
119334: PUSH
119335: LD_INT 1
119337: EQUAL
119338: AND
119339: PUSH
119340: LD_VAR 0 4
119344: PPUSH
119345: CALL_OW 311
119349: AND
119350: PUSH
119351: LD_VAR 0 4
119355: PPUSH
119356: LD_EXP 55
119360: PUSH
119361: LD_VAR 0 1
119365: ARRAY
119366: PPUSH
119367: CALL_OW 308
119371: AND
119372: IFFALSE 119426
// begin mech := IsDrivenBy ( i ) ;
119374: LD_ADDR_VAR 0 9
119378: PUSH
119379: LD_VAR 0 4
119383: PPUSH
119384: CALL_OW 311
119388: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119389: LD_VAR 0 9
119393: PPUSH
119394: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119398: LD_VAR 0 9
119402: PPUSH
119403: LD_VAR 0 4
119407: PPUSH
119408: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119412: LD_VAR 0 9
119416: PPUSH
119417: LD_VAR 0 4
119421: PPUSH
119422: CALL_OW 180
// end ; end ; unit_human :
119426: GO 119773
119428: LD_INT 1
119430: DOUBLE
119431: EQUAL
119432: IFTRUE 119436
119434: GO 119772
119436: POP
// begin b := IsInUnit ( i ) ;
119437: LD_ADDR_VAR 0 18
119441: PUSH
119442: LD_VAR 0 4
119446: PPUSH
119447: CALL_OW 310
119451: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119452: LD_ADDR_VAR 0 19
119456: PUSH
119457: LD_VAR 0 18
119461: NOT
119462: PUSH
119463: LD_VAR 0 18
119467: PPUSH
119468: CALL_OW 266
119472: PUSH
119473: LD_INT 32
119475: PUSH
119476: LD_INT 31
119478: PUSH
119479: EMPTY
119480: LIST
119481: LIST
119482: IN
119483: OR
119484: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119485: LD_VAR 0 18
119489: PPUSH
119490: CALL_OW 266
119494: PUSH
119495: LD_INT 5
119497: EQUAL
119498: PUSH
119499: LD_VAR 0 4
119503: PPUSH
119504: CALL_OW 257
119508: PUSH
119509: LD_INT 1
119511: PUSH
119512: LD_INT 2
119514: PUSH
119515: LD_INT 3
119517: PUSH
119518: LD_INT 4
119520: PUSH
119521: EMPTY
119522: LIST
119523: LIST
119524: LIST
119525: LIST
119526: IN
119527: AND
119528: IFFALSE 119565
// begin class := AllowSpecClass ( i ) ;
119530: LD_ADDR_VAR 0 20
119534: PUSH
119535: LD_VAR 0 4
119539: PPUSH
119540: CALL 21670 0 1
119544: ST_TO_ADDR
// if class then
119545: LD_VAR 0 20
119549: IFFALSE 119565
// ComChangeProfession ( i , class ) ;
119551: LD_VAR 0 4
119555: PPUSH
119556: LD_VAR 0 20
119560: PPUSH
119561: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119565: LD_VAR 0 16
119569: PUSH
119570: LD_VAR 0 2
119574: PPUSH
119575: LD_INT 21
119577: PUSH
119578: LD_INT 2
119580: PUSH
119581: EMPTY
119582: LIST
119583: LIST
119584: PPUSH
119585: CALL_OW 72
119589: PUSH
119590: LD_INT 1
119592: LESSEQUAL
119593: OR
119594: PUSH
119595: LD_VAR 0 19
119599: AND
119600: PUSH
119601: LD_VAR 0 4
119605: PUSH
119606: LD_VAR 0 17
119610: IN
119611: NOT
119612: AND
119613: IFFALSE 119706
// begin if b then
119615: LD_VAR 0 18
119619: IFFALSE 119668
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119621: LD_VAR 0 18
119625: PPUSH
119626: LD_VAR 0 21
119630: PPUSH
119631: LD_VAR 0 18
119635: PPUSH
119636: CALL_OW 74
119640: PPUSH
119641: CALL_OW 296
119645: PUSH
119646: LD_INT 10
119648: LESS
119649: PUSH
119650: LD_VAR 0 18
119654: PPUSH
119655: CALL_OW 461
119659: PUSH
119660: LD_INT 7
119662: NONEQUAL
119663: AND
119664: IFFALSE 119668
// continue ;
119666: GO 118903
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119668: LD_ADDR_VAR 0 17
119672: PUSH
119673: LD_VAR 0 17
119677: PPUSH
119678: LD_VAR 0 17
119682: PUSH
119683: LD_INT 1
119685: PLUS
119686: PPUSH
119687: LD_VAR 0 4
119691: PPUSH
119692: CALL_OW 1
119696: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119697: LD_VAR 0 4
119701: PPUSH
119702: CALL_OW 122
// end ; if sold_defenders then
119706: LD_VAR 0 17
119710: IFFALSE 119770
// if i in sold_defenders then
119712: LD_VAR 0 4
119716: PUSH
119717: LD_VAR 0 17
119721: IN
119722: IFFALSE 119770
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119724: LD_VAR 0 4
119728: PPUSH
119729: CALL_OW 314
119733: NOT
119734: PUSH
119735: LD_VAR 0 4
119739: PPUSH
119740: LD_VAR 0 13
119744: PPUSH
119745: CALL_OW 296
119749: PUSH
119750: LD_INT 30
119752: LESS
119753: AND
119754: IFFALSE 119770
// ComAttackUnit ( i , e ) ;
119756: LD_VAR 0 4
119760: PPUSH
119761: LD_VAR 0 13
119765: PPUSH
119766: CALL_OW 115
// end ; end ; end ;
119770: GO 119773
119772: POP
// if IsDead ( i ) then
119773: LD_VAR 0 4
119777: PPUSH
119778: CALL_OW 301
119782: IFFALSE 119800
// defenders := defenders diff i ;
119784: LD_ADDR_VAR 0 2
119788: PUSH
119789: LD_VAR 0 2
119793: PUSH
119794: LD_VAR 0 4
119798: DIFF
119799: ST_TO_ADDR
// end ;
119800: GO 118903
119802: POP
119803: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119804: LD_VAR 0 21
119808: NOT
119809: PUSH
119810: LD_VAR 0 2
119814: NOT
119815: OR
119816: PUSH
119817: LD_EXP 31
119821: PUSH
119822: LD_VAR 0 1
119826: ARRAY
119827: NOT
119828: OR
119829: IFFALSE 118807
// MC_Reset ( base , 18 ) ;
119831: LD_VAR 0 1
119835: PPUSH
119836: LD_INT 18
119838: PPUSH
119839: CALL 65977 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119843: LD_ADDR_VAR 0 2
119847: PUSH
119848: LD_VAR 0 2
119852: PUSH
119853: LD_VAR 0 2
119857: PPUSH
119858: LD_INT 2
119860: PUSH
119861: LD_INT 25
119863: PUSH
119864: LD_INT 1
119866: PUSH
119867: EMPTY
119868: LIST
119869: LIST
119870: PUSH
119871: LD_INT 25
119873: PUSH
119874: LD_INT 5
119876: PUSH
119877: EMPTY
119878: LIST
119879: LIST
119880: PUSH
119881: LD_INT 25
119883: PUSH
119884: LD_INT 8
119886: PUSH
119887: EMPTY
119888: LIST
119889: LIST
119890: PUSH
119891: LD_INT 25
119893: PUSH
119894: LD_INT 9
119896: PUSH
119897: EMPTY
119898: LIST
119899: LIST
119900: PUSH
119901: EMPTY
119902: LIST
119903: LIST
119904: LIST
119905: LIST
119906: LIST
119907: PPUSH
119908: CALL_OW 72
119912: DIFF
119913: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119914: LD_VAR 0 21
119918: NOT
119919: PUSH
119920: LD_VAR 0 2
119924: PPUSH
119925: LD_INT 21
119927: PUSH
119928: LD_INT 2
119930: PUSH
119931: EMPTY
119932: LIST
119933: LIST
119934: PPUSH
119935: CALL_OW 72
119939: AND
119940: IFFALSE 120278
// begin tmp := FilterByTag ( defenders , 19 ) ;
119942: LD_ADDR_VAR 0 11
119946: PUSH
119947: LD_VAR 0 2
119951: PPUSH
119952: LD_INT 19
119954: PPUSH
119955: CALL 55155 0 2
119959: ST_TO_ADDR
// if tmp then
119960: LD_VAR 0 11
119964: IFFALSE 120034
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119966: LD_ADDR_VAR 0 11
119970: PUSH
119971: LD_VAR 0 11
119975: PPUSH
119976: LD_INT 25
119978: PUSH
119979: LD_INT 3
119981: PUSH
119982: EMPTY
119983: LIST
119984: LIST
119985: PPUSH
119986: CALL_OW 72
119990: ST_TO_ADDR
// if tmp then
119991: LD_VAR 0 11
119995: IFFALSE 120034
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119997: LD_ADDR_EXP 43
120001: PUSH
120002: LD_EXP 43
120006: PPUSH
120007: LD_VAR 0 1
120011: PPUSH
120012: LD_EXP 43
120016: PUSH
120017: LD_VAR 0 1
120021: ARRAY
120022: PUSH
120023: LD_VAR 0 11
120027: UNION
120028: PPUSH
120029: CALL_OW 1
120033: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
120034: LD_VAR 0 1
120038: PPUSH
120039: LD_INT 19
120041: PPUSH
120042: CALL 65977 0 2
// repeat wait ( 0 0$1 ) ;
120046: LD_INT 35
120048: PPUSH
120049: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120053: LD_EXP 31
120057: PUSH
120058: LD_VAR 0 1
120062: ARRAY
120063: NOT
120064: PUSH
120065: LD_EXP 31
120069: PUSH
120070: LD_VAR 0 1
120074: ARRAY
120075: PUSH
120076: EMPTY
120077: EQUAL
120078: OR
120079: IFFALSE 120116
// begin for i in defenders do
120081: LD_ADDR_VAR 0 4
120085: PUSH
120086: LD_VAR 0 2
120090: PUSH
120091: FOR_IN
120092: IFFALSE 120105
// ComStop ( i ) ;
120094: LD_VAR 0 4
120098: PPUSH
120099: CALL_OW 141
120103: GO 120091
120105: POP
120106: POP
// defenders := [ ] ;
120107: LD_ADDR_VAR 0 2
120111: PUSH
120112: EMPTY
120113: ST_TO_ADDR
// exit ;
120114: GO 120342
// end ; for i in defenders do
120116: LD_ADDR_VAR 0 4
120120: PUSH
120121: LD_VAR 0 2
120125: PUSH
120126: FOR_IN
120127: IFFALSE 120216
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120129: LD_VAR 0 4
120133: PPUSH
120134: LD_EXP 55
120138: PUSH
120139: LD_VAR 0 1
120143: ARRAY
120144: PPUSH
120145: CALL_OW 308
120149: NOT
120150: IFFALSE 120174
// ComMoveToArea ( i , mc_parking [ base ] ) else
120152: LD_VAR 0 4
120156: PPUSH
120157: LD_EXP 55
120161: PUSH
120162: LD_VAR 0 1
120166: ARRAY
120167: PPUSH
120168: CALL_OW 113
120172: GO 120214
// if GetControl ( i ) = control_manual then
120174: LD_VAR 0 4
120178: PPUSH
120179: CALL_OW 263
120183: PUSH
120184: LD_INT 1
120186: EQUAL
120187: IFFALSE 120214
// if IsDrivenBy ( i ) then
120189: LD_VAR 0 4
120193: PPUSH
120194: CALL_OW 311
120198: IFFALSE 120214
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120200: LD_VAR 0 4
120204: PPUSH
120205: CALL_OW 311
120209: PPUSH
120210: CALL_OW 121
// end ;
120214: GO 120126
120216: POP
120217: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120218: LD_VAR 0 2
120222: PPUSH
120223: LD_INT 95
120225: PUSH
120226: LD_EXP 55
120230: PUSH
120231: LD_VAR 0 1
120235: ARRAY
120236: PUSH
120237: EMPTY
120238: LIST
120239: LIST
120240: PPUSH
120241: CALL_OW 72
120245: PUSH
120246: LD_VAR 0 2
120250: EQUAL
120251: PUSH
120252: LD_EXP 54
120256: PUSH
120257: LD_VAR 0 1
120261: ARRAY
120262: OR
120263: PUSH
120264: LD_EXP 31
120268: PUSH
120269: LD_VAR 0 1
120273: ARRAY
120274: NOT
120275: OR
120276: IFFALSE 120046
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120278: LD_ADDR_EXP 53
120282: PUSH
120283: LD_EXP 53
120287: PPUSH
120288: LD_VAR 0 1
120292: PPUSH
120293: LD_VAR 0 2
120297: PPUSH
120298: LD_INT 21
120300: PUSH
120301: LD_INT 2
120303: PUSH
120304: EMPTY
120305: LIST
120306: LIST
120307: PPUSH
120308: CALL_OW 72
120312: PPUSH
120313: CALL_OW 1
120317: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120318: LD_VAR 0 1
120322: PPUSH
120323: LD_INT 19
120325: PPUSH
120326: CALL 65977 0 2
// MC_Reset ( base , 20 ) ;
120330: LD_VAR 0 1
120334: PPUSH
120335: LD_INT 20
120337: PPUSH
120338: CALL 65977 0 2
// end ; end_of_file
120342: LD_VAR 0 3
120346: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120347: LD_VAR 0 1
120351: PUSH
120352: LD_INT 200
120354: DOUBLE
120355: GREATEREQUAL
120356: IFFALSE 120364
120358: LD_INT 299
120360: DOUBLE
120361: LESSEQUAL
120362: IFTRUE 120366
120364: GO 120398
120366: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120367: LD_VAR 0 1
120371: PPUSH
120372: LD_VAR 0 2
120376: PPUSH
120377: LD_VAR 0 3
120381: PPUSH
120382: LD_VAR 0 4
120386: PPUSH
120387: LD_VAR 0 5
120391: PPUSH
120392: CALL 108694 0 5
120396: GO 120475
120398: LD_INT 300
120400: DOUBLE
120401: GREATEREQUAL
120402: IFFALSE 120410
120404: LD_INT 399
120406: DOUBLE
120407: LESSEQUAL
120408: IFTRUE 120412
120410: GO 120474
120412: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120413: LD_VAR 0 1
120417: PPUSH
120418: LD_VAR 0 2
120422: PPUSH
120423: LD_VAR 0 3
120427: PPUSH
120428: LD_VAR 0 4
120432: PPUSH
120433: LD_VAR 0 5
120437: PPUSH
120438: LD_VAR 0 6
120442: PPUSH
120443: LD_VAR 0 7
120447: PPUSH
120448: LD_VAR 0 8
120452: PPUSH
120453: LD_VAR 0 9
120457: PPUSH
120458: LD_VAR 0 10
120462: PPUSH
120463: LD_VAR 0 11
120467: PPUSH
120468: CALL 105019 0 11
120472: GO 120475
120474: POP
// end ;
120475: PPOPN 11
120477: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120478: LD_VAR 0 1
120482: PPUSH
120483: LD_VAR 0 2
120487: PPUSH
120488: LD_VAR 0 3
120492: PPUSH
120493: LD_VAR 0 4
120497: PPUSH
120498: LD_VAR 0 5
120502: PPUSH
120503: CALL 108430 0 5
// end ; end_of_file
120507: PPOPN 5
120509: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
120510: LD_VAR 0 1
120514: PPUSH
120515: LD_VAR 0 2
120519: PPUSH
120520: LD_VAR 0 3
120524: PPUSH
120525: LD_VAR 0 4
120529: PPUSH
120530: LD_VAR 0 5
120534: PPUSH
120535: LD_VAR 0 6
120539: PPUSH
120540: CALL 92671 0 6
// end ;
120544: PPOPN 6
120546: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
120547: LD_INT 0
120549: PPUSH
// begin if not units then
120550: LD_VAR 0 1
120554: NOT
120555: IFFALSE 120559
// exit ;
120557: GO 120559
// end ;
120559: PPOPN 7
120561: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
120562: CALL 92575 0 0
// end ;
120566: PPOPN 1
120568: END
