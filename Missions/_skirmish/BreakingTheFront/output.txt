// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 573 0 0
// SetDiplomacy ;
  42: CALL 785 0 0
// PrepareGame ;
  46: CALL 867 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := false ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 1 trigger cratesSpawns and game and GameType = 1 do
 229: LD_EXP 19
 233: IFFALSE 241
 235: PUSH
 236: LD_EXP 3
 240: AND
 241: IFFALSE 253
 243: PUSH
 244: LD_EXP 2
 248: PUSH
 249: LD_INT 1
 251: EQUAL
 252: AND
 253: IFFALSE 314
 255: GO 257
 257: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 258: LD_EXP 19
 262: PUSH
 263: LD_INT 1
 265: ARRAY
 266: PUSH
 267: LD_INT 1
 269: ARRAY
 270: PPUSH
 271: LD_EXP 19
 275: PUSH
 276: LD_INT 1
 278: ARRAY
 279: PUSH
 280: LD_INT 2
 282: ARRAY
 283: PPUSH
 284: LD_EXP 19
 288: PUSH
 289: LD_INT 1
 291: ARRAY
 292: PUSH
 293: LD_INT 3
 295: ARRAY
 296: PPUSH
 297: LD_EXP 19
 301: PUSH
 302: LD_INT 1
 304: ARRAY
 305: PUSH
 306: LD_INT 4
 308: ARRAY
 309: PPUSH
 310: CALL 57427 0 4
 314: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 315: LD_EXP 19
 319: IFFALSE 327
 321: PUSH
 322: LD_EXP 3
 326: AND
 327: IFFALSE 339
 329: PUSH
 330: LD_EXP 2
 334: PUSH
 335: LD_INT 1
 337: EQUAL
 338: AND
 339: IFFALSE 400
 341: GO 343
 343: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 344: LD_EXP 19
 348: PUSH
 349: LD_INT 2
 351: ARRAY
 352: PUSH
 353: LD_INT 1
 355: ARRAY
 356: PPUSH
 357: LD_EXP 19
 361: PUSH
 362: LD_INT 2
 364: ARRAY
 365: PUSH
 366: LD_INT 2
 368: ARRAY
 369: PPUSH
 370: LD_EXP 19
 374: PUSH
 375: LD_INT 2
 377: ARRAY
 378: PUSH
 379: LD_INT 3
 381: ARRAY
 382: PPUSH
 383: LD_EXP 19
 387: PUSH
 388: LD_INT 2
 390: ARRAY
 391: PUSH
 392: LD_INT 4
 394: ARRAY
 395: PPUSH
 396: CALL 57427 0 4
 400: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 401: LD_EXP 19
 405: IFFALSE 413
 407: PUSH
 408: LD_EXP 3
 412: AND
 413: IFFALSE 425
 415: PUSH
 416: LD_EXP 2
 420: PUSH
 421: LD_INT 1
 423: EQUAL
 424: AND
 425: IFFALSE 486
 427: GO 429
 429: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 430: LD_EXP 19
 434: PUSH
 435: LD_INT 3
 437: ARRAY
 438: PUSH
 439: LD_INT 1
 441: ARRAY
 442: PPUSH
 443: LD_EXP 19
 447: PUSH
 448: LD_INT 3
 450: ARRAY
 451: PUSH
 452: LD_INT 2
 454: ARRAY
 455: PPUSH
 456: LD_EXP 19
 460: PUSH
 461: LD_INT 3
 463: ARRAY
 464: PUSH
 465: LD_INT 3
 467: ARRAY
 468: PPUSH
 469: LD_EXP 19
 473: PUSH
 474: LD_INT 3
 476: ARRAY
 477: PUSH
 478: LD_INT 4
 480: ARRAY
 481: PPUSH
 482: CALL 57427 0 4
 486: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 487: LD_EXP 19
 491: IFFALSE 499
 493: PUSH
 494: LD_EXP 3
 498: AND
 499: IFFALSE 511
 501: PUSH
 502: LD_EXP 2
 506: PUSH
 507: LD_INT 1
 509: EQUAL
 510: AND
 511: IFFALSE 572
 513: GO 515
 515: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 516: LD_EXP 19
 520: PUSH
 521: LD_INT 4
 523: ARRAY
 524: PUSH
 525: LD_INT 1
 527: ARRAY
 528: PPUSH
 529: LD_EXP 19
 533: PUSH
 534: LD_INT 4
 536: ARRAY
 537: PUSH
 538: LD_INT 2
 540: ARRAY
 541: PPUSH
 542: LD_EXP 19
 546: PUSH
 547: LD_INT 4
 549: ARRAY
 550: PUSH
 551: LD_INT 3
 553: ARRAY
 554: PPUSH
 555: LD_EXP 19
 559: PUSH
 560: LD_INT 4
 562: ARRAY
 563: PUSH
 564: LD_INT 4
 566: ARRAY
 567: PPUSH
 568: CALL 57427 0 4
 572: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 573: LD_INT 0
 575: PPUSH
 576: PPUSH
 577: PPUSH
 578: PPUSH
 579: PPUSH
// if GameType = 1 then
 580: LD_EXP 2
 584: PUSH
 585: LD_INT 1
 587: EQUAL
 588: IFFALSE 657
// begin ban_techs := [ ] ;
 590: LD_ADDR_VAR 0 4
 594: PUSH
 595: EMPTY
 596: ST_TO_ADDR
// if sibBombAllowed < 2 then
 597: LD_EXP 23
 601: PUSH
 602: LD_INT 2
 604: LESS
 605: IFFALSE 618
// ban_techs := [ tech_sibFiss ] ;
 607: LD_ADDR_VAR 0 4
 611: PUSH
 612: LD_INT 25
 614: PUSH
 615: EMPTY
 616: LIST
 617: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 618: LD_ADDR_VAR 0 5
 622: PUSH
 623: LD_INT 46
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: LD_INT 48
 631: PUSH
 632: LD_INT 49
 634: PUSH
 635: LD_INT 50
 637: PUSH
 638: LD_INT 39
 640: PUSH
 641: LD_INT 69
 643: PUSH
 644: LD_INT 40
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: ST_TO_ADDR
// end ; for i = 1 to 8 do
 657: LD_ADDR_VAR 0 2
 661: PUSH
 662: DOUBLE
 663: LD_INT 1
 665: DEC
 666: ST_TO_ADDR
 667: LD_INT 8
 669: PUSH
 670: FOR_TO
 671: IFFALSE 755
// begin if res_techs then
 673: LD_VAR 0 5
 677: IFFALSE 713
// for j in res_techs do
 679: LD_ADDR_VAR 0 3
 683: PUSH
 684: LD_VAR 0 5
 688: PUSH
 689: FOR_IN
 690: IFFALSE 711
// SetTech ( j , i , state_researched ) ;
 692: LD_VAR 0 3
 696: PPUSH
 697: LD_VAR 0 2
 701: PPUSH
 702: LD_INT 2
 704: PPUSH
 705: CALL_OW 322
 709: GO 689
 711: POP
 712: POP
// if ban_techs then
 713: LD_VAR 0 4
 717: IFFALSE 753
// for j in ban_techs do
 719: LD_ADDR_VAR 0 3
 723: PUSH
 724: LD_VAR 0 4
 728: PUSH
 729: FOR_IN
 730: IFFALSE 751
// SetTech ( j , i , state_disabled ) ;
 732: LD_VAR 0 3
 736: PPUSH
 737: LD_VAR 0 2
 741: PPUSH
 742: LD_INT 0
 744: PPUSH
 745: CALL_OW 322
 749: GO 729
 751: POP
 752: POP
// end ;
 753: GO 670
 755: POP
 756: POP
// if sibBombAllowed = 1 then
 757: LD_EXP 23
 761: PUSH
 762: LD_INT 1
 764: EQUAL
 765: IFFALSE 780
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 767: LD_INT 25
 769: PPUSH
 770: LD_INT 3
 772: PPUSH
 773: LD_INT 1
 775: PPUSH
 776: CALL_OW 322
// end ;
 780: LD_VAR 0 1
 784: RET
// export function SetDiplomacy ; begin
 785: LD_INT 0
 787: PPUSH
// if GameType = 1 then
 788: LD_EXP 2
 792: PUSH
 793: LD_INT 1
 795: EQUAL
 796: IFFALSE 862
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 798: LD_INT 1
 800: PPUSH
 801: LD_INT 4
 803: PPUSH
 804: LD_INT 1
 806: PPUSH
 807: LD_INT 1
 809: PPUSH
 810: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 814: LD_INT 3
 816: PPUSH
 817: LD_INT 6
 819: PPUSH
 820: LD_INT 1
 822: PPUSH
 823: LD_INT 1
 825: PPUSH
 826: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 830: LD_INT 3
 832: PPUSH
 833: LD_INT 8
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: LD_INT 1
 841: PPUSH
 842: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 8
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: CALL_OW 80
// end ; end ;
 862: LD_VAR 0 1
 866: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 867: LD_INT 0
 869: PPUSH
 870: PPUSH
 871: PPUSH
 872: PPUSH
// if GameType = 1 then
 873: LD_EXP 2
 877: PUSH
 878: LD_INT 1
 880: EQUAL
 881: IFFALSE 1377
// begin game := false ;
 883: LD_ADDR_EXP 3
 887: PUSH
 888: LD_INT 0
 890: ST_TO_ADDR
// your_side := 1 ;
 891: LD_ADDR_OWVAR 2
 895: PUSH
 896: LD_INT 1
 898: ST_TO_ADDR
// mc_amer := 1 ;
 899: LD_ADDR_EXP 5
 903: PUSH
 904: LD_INT 1
 906: ST_TO_ADDR
// mc_leg := 2 ;
 907: LD_ADDR_EXP 6
 911: PUSH
 912: LD_INT 2
 914: ST_TO_ADDR
// mc_rus_1 := 3 ;
 915: LD_ADDR_EXP 7
 919: PUSH
 920: LD_INT 3
 922: ST_TO_ADDR
// mc_rus_2 := 4 ;
 923: LD_ADDR_EXP 8
 927: PUSH
 928: LD_INT 4
 930: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 931: LD_ADDR_EXP 19
 935: PUSH
 936: LD_INT 5
 938: PUSH
 939: LD_INT 1
 941: PUSH
 942: LD_INT 0
 944: PUSH
 945: LD_INT 200
 947: PUSH
 948: LD_INT 250
 950: PUSH
 951: LD_INT 300
 953: PUSH
 954: EMPTY
 955: LIST
 956: LIST
 957: LIST
 958: PUSH
 959: LD_EXP 26
 963: ARRAY
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: LIST
 969: LIST
 970: PUSH
 971: LD_INT 13
 973: PUSH
 974: LD_INT 8
 976: PUSH
 977: LD_INT 50
 979: PUSH
 980: LD_INT 500
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: LIST
 988: PUSH
 989: LD_INT 17
 991: PUSH
 992: LD_INT 5
 994: PUSH
 995: LD_INT 50
 997: PUSH
 998: LD_INT 300
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: PUSH
1007: LD_INT 18
1009: PUSH
1010: LD_INT 4
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: LD_INT 6
1018: PUSH
1019: EMPTY
1020: LIST
1021: LIST
1022: LIST
1023: PUSH
1024: LD_EXP 26
1028: ARRAY
1029: PUSH
1030: LD_INT 30
1032: PUSH
1033: LD_INT 300
1035: PUSH
1036: LD_INT 450
1038: PUSH
1039: LD_INT 500
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: LIST
1046: PUSH
1047: LD_EXP 26
1051: ARRAY
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1065: LD_ADDR_VAR 0 4
1069: PUSH
1070: LD_INT 190
1072: PUSH
1073: LD_INT 193
1075: PUSH
1076: LD_INT 3
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 182
1086: PUSH
1087: LD_INT 117
1089: PUSH
1090: LD_INT 3
1092: PUSH
1093: EMPTY
1094: LIST
1095: LIST
1096: LIST
1097: PUSH
1098: LD_INT 43
1100: PUSH
1101: LD_INT 2
1103: PUSH
1104: LD_INT 3
1106: PUSH
1107: EMPTY
1108: LIST
1109: LIST
1110: LIST
1111: PUSH
1112: LD_INT 114
1114: PUSH
1115: LD_INT 152
1117: PUSH
1118: LD_INT 2
1120: PUSH
1121: EMPTY
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 85
1128: PUSH
1129: LD_INT 38
1131: PUSH
1132: LD_INT 2
1134: PUSH
1135: EMPTY
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: LIST
1146: ST_TO_ADDR
// for i in sources do
1147: LD_ADDR_VAR 0 2
1151: PUSH
1152: LD_VAR 0 4
1156: PUSH
1157: FOR_IN
1158: IFFALSE 1193
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1160: LD_VAR 0 2
1164: PUSH
1165: LD_INT 1
1167: ARRAY
1168: PPUSH
1169: LD_VAR 0 2
1173: PUSH
1174: LD_INT 2
1176: ARRAY
1177: PPUSH
1178: LD_VAR 0 2
1182: PUSH
1183: LD_INT 3
1185: ARRAY
1186: PPUSH
1187: CALL_OW 62
1191: GO 1157
1193: POP
1194: POP
// disableGlobalTimer := false ;
1195: LD_ADDR_EXP 4
1199: PUSH
1200: LD_INT 0
1202: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1203: LD_ADDR_EXP 15
1207: PUSH
1208: LD_INT 0
1210: PUSH
1211: LD_INT 5
1213: PUSH
1214: LD_INT 6
1216: PUSH
1217: LD_INT 7
1219: PUSH
1220: EMPTY
1221: LIST
1222: LIST
1223: LIST
1224: PUSH
1225: LD_OWVAR 67
1229: ARRAY
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: ST_TO_ADDR
// ruOutpost := [ ] ;
1235: LD_ADDR_EXP 14
1239: PUSH
1240: EMPTY
1241: ST_TO_ADDR
// staticMines := [ ] ;
1242: LD_ADDR_EXP 16
1246: PUSH
1247: EMPTY
1248: ST_TO_ADDR
// baseCaptured := false ;
1249: LD_ADDR_EXP 17
1253: PUSH
1254: LD_INT 0
1256: ST_TO_ADDR
// legDestCounter := 0 ;
1257: LD_ADDR_EXP 18
1261: PUSH
1262: LD_INT 0
1264: ST_TO_ADDR
// legOfferAccepted := false ;
1265: LD_ADDR_EXP 20
1269: PUSH
1270: LD_INT 0
1272: ST_TO_ADDR
// legChangeSide := false ;
1273: LD_ADDR_EXP 21
1277: PUSH
1278: LD_INT 0
1280: ST_TO_ADDR
// allyDestCounter := 0 ;
1281: LD_ADDR_EXP 22
1285: PUSH
1286: LD_INT 0
1288: ST_TO_ADDR
// outpostEscape := false ;
1289: LD_ADDR_EXP 27
1293: PUSH
1294: LD_INT 0
1296: ST_TO_ADDR
// dialogueMineDetected := false ;
1297: LD_ADDR_EXP 28
1301: PUSH
1302: LD_INT 0
1304: ST_TO_ADDR
// PrepareAmericans ;
1305: CALL 7575 0 0
// PrepareLegion ;
1309: CALL 5509 0 0
// PrepareRussians ;
1313: CALL 2475 0 0
// playerForces := PreparePlayer ;
1317: LD_ADDR_EXP 10
1321: PUSH
1322: CALL 8818 0 0
1326: ST_TO_ADDR
// AnimateTrees ( true ) ;
1327: LD_INT 1
1329: PPUSH
1330: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1334: LD_INT 4
1336: PPUSH
1337: LD_INT 3
1339: PPUSH
1340: LD_INT 8
1342: PPUSH
1343: LD_INT 5
1345: PPUSH
1346: LD_INT 3
1348: PPUSH
1349: LD_INT 1
1351: PPUSH
1352: LD_INT 8
1354: PPUSH
1355: LD_INT 2
1357: PPUSH
1358: LD_INT 1
1360: PPUSH
1361: CALL 54762 0 9
// MC_Start ;
1365: CALL 65645 0 0
// SetAdditionalRussianForces ;
1369: CALL 7244 0 0
// Action ;
1373: CALL 11177 0 0
// end ; end ;
1377: LD_VAR 0 1
1381: RET
// export function CustomInitMacro ; begin
1382: LD_INT 0
1384: PPUSH
// if GameType <> 1 then
1385: LD_EXP 2
1389: PUSH
1390: LD_INT 1
1392: NONEQUAL
1393: IFFALSE 1397
// exit ;
1395: GO 2470
// MC_SetScanArea ( mc_amer , amerBase ) ;
1397: LD_EXP 5
1401: PPUSH
1402: LD_INT 3
1404: PPUSH
1405: CALL 89308 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1409: LD_EXP 5
1413: PPUSH
1414: LD_INT 4
1416: PPUSH
1417: CALL 89248 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1421: LD_EXP 5
1425: PPUSH
1426: LD_INT 11
1428: PUSH
1429: LD_INT 6
1431: PUSH
1432: LD_INT 7
1434: PUSH
1435: LD_INT 9
1437: PUSH
1438: LD_INT 10
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: PPUSH
1448: CALL 89128 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1452: LD_EXP 5
1456: PPUSH
1457: LD_INT 5
1459: PPUSH
1460: CALL 88798 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1464: LD_EXP 5
1468: PPUSH
1469: LD_INT 3
1471: PPUSH
1472: CALL 88521 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1476: LD_EXP 5
1480: PPUSH
1481: LD_INT 4
1483: PPUSH
1484: CALL 88140 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1488: LD_EXP 5
1492: PPUSH
1493: LD_INT 3
1495: PUSH
1496: LD_INT 1
1498: PUSH
1499: LD_INT 2
1501: PUSH
1502: LD_INT 5
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: LIST
1509: LIST
1510: PUSH
1511: LD_INT 3
1513: PUSH
1514: LD_INT 2
1516: PUSH
1517: LD_INT 2
1519: PUSH
1520: LD_INT 9
1522: PUSH
1523: EMPTY
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: PUSH
1529: LD_INT 4
1531: PUSH
1532: LD_INT 1
1534: PUSH
1535: LD_INT 2
1537: PUSH
1538: LD_INT 7
1540: PUSH
1541: EMPTY
1542: LIST
1543: LIST
1544: LIST
1545: LIST
1546: PUSH
1547: LD_INT 4
1549: PUSH
1550: LD_INT 1
1552: PUSH
1553: LD_INT 2
1555: PUSH
1556: LD_INT 6
1558: PUSH
1559: EMPTY
1560: LIST
1561: LIST
1562: LIST
1563: LIST
1564: PUSH
1565: EMPTY
1566: LIST
1567: LIST
1568: LIST
1569: LIST
1570: PPUSH
1571: CALL 87955 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1575: LD_EXP 5
1579: PPUSH
1580: LD_INT 33
1582: PUSH
1583: LD_INT 114
1585: PUSH
1586: LD_INT 16
1588: PUSH
1589: LD_INT 0
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: LIST
1597: PUSH
1598: LD_INT 32
1600: PUSH
1601: LD_INT 110
1603: PUSH
1604: LD_INT 12
1606: PUSH
1607: LD_INT 0
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: LIST
1614: LIST
1615: PUSH
1616: EMPTY
1617: LIST
1618: LIST
1619: PPUSH
1620: CALL 87847 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1624: LD_EXP 5
1628: PPUSH
1629: LD_INT 10
1631: PUSH
1632: LD_INT 15
1634: PUSH
1635: LD_INT 12
1637: PUSH
1638: LD_INT 11
1640: PUSH
1641: EMPTY
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: PPUSH
1647: CALL 88701 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1651: LD_EXP 6
1655: PPUSH
1656: LD_INT 6
1658: PPUSH
1659: CALL 89308 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1663: LD_EXP 6
1667: PPUSH
1668: LD_INT 7
1670: PPUSH
1671: CALL 89248 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1675: LD_EXP 6
1679: PPUSH
1680: LD_INT 30
1682: PUSH
1683: LD_INT 27
1685: PUSH
1686: LD_INT 28
1688: PUSH
1689: LD_INT 25
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: PPUSH
1698: CALL 89128 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1702: LD_EXP 6
1706: PPUSH
1707: LD_INT 17
1709: PPUSH
1710: CALL 88798 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1714: LD_EXP 6
1718: PPUSH
1719: LD_INT 6
1721: PPUSH
1722: CALL 88521 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1726: LD_EXP 6
1730: PPUSH
1731: LD_INT 5
1733: PPUSH
1734: CALL 88140 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1738: LD_EXP 6
1742: PPUSH
1743: LD_INT 10
1745: PPUSH
1746: LD_INT 9
1748: PPUSH
1749: CALL 87618 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1753: LD_EXP 6
1757: PPUSH
1758: LD_INT 4
1760: PUSH
1761: LD_INT 157
1763: PUSH
1764: LD_INT 144
1766: PUSH
1767: LD_INT 0
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: PUSH
1776: LD_INT 32
1778: PUSH
1779: LD_INT 151
1781: PUSH
1782: LD_INT 142
1784: PUSH
1785: LD_INT 0
1787: PUSH
1788: EMPTY
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 32
1796: PUSH
1797: LD_INT 161
1799: PUSH
1800: LD_INT 144
1802: PUSH
1803: LD_INT 0
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: LIST
1811: PUSH
1812: LD_INT 32
1814: PUSH
1815: LD_INT 140
1817: PUSH
1818: LD_INT 133
1820: PUSH
1821: LD_INT 0
1823: PUSH
1824: EMPTY
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: PPUSH
1836: CALL 87847 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1840: LD_EXP 6
1844: PPUSH
1845: LD_INT 13
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 1
1853: PUSH
1854: LD_INT 31
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: PUSH
1863: LD_INT 13
1865: PUSH
1866: LD_INT 2
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 31
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: PUSH
1881: LD_INT 13
1883: PUSH
1884: LD_INT 1
1886: PUSH
1887: LD_INT 1
1889: PUSH
1890: LD_INT 27
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: PUSH
1899: LD_INT 13
1901: PUSH
1902: LD_INT 1
1904: PUSH
1905: LD_INT 2
1907: PUSH
1908: LD_INT 27
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: PUSH
1917: LD_INT 13
1919: PUSH
1920: LD_INT 1
1922: PUSH
1923: LD_INT 2
1925: PUSH
1926: LD_INT 27
1928: PUSH
1929: EMPTY
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: PUSH
1935: LD_INT 13
1937: PUSH
1938: LD_INT 1
1940: PUSH
1941: LD_INT 2
1943: PUSH
1944: LD_INT 28
1946: PUSH
1947: EMPTY
1948: LIST
1949: LIST
1950: LIST
1951: LIST
1952: PUSH
1953: LD_INT 13
1955: PUSH
1956: LD_INT 1
1958: PUSH
1959: LD_INT 2
1961: PUSH
1962: LD_INT 28
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: LIST
1969: LIST
1970: PUSH
1971: LD_INT 13
1973: PUSH
1974: LD_INT 1
1976: PUSH
1977: LD_INT 2
1979: PUSH
1980: LD_INT 32
1982: PUSH
1983: EMPTY
1984: LIST
1985: LIST
1986: LIST
1987: LIST
1988: PUSH
1989: LD_INT 13
1991: PUSH
1992: LD_INT 1
1994: PUSH
1995: LD_INT 2
1997: PUSH
1998: LD_INT 88
2000: PUSH
2001: EMPTY
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: PUSH
2007: EMPTY
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PPUSH
2018: CALL 87955 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2022: LD_INT 165
2024: PPUSH
2025: LD_INT 156
2027: PPUSH
2028: LD_INT 8
2030: PPUSH
2031: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2035: LD_EXP 7
2039: PPUSH
2040: LD_INT 15
2042: PPUSH
2043: CALL 89308 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2047: LD_EXP 7
2051: PPUSH
2052: LD_INT 16
2054: PPUSH
2055: CALL 89248 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2059: LD_EXP 7
2063: PPUSH
2064: LD_INT 43
2066: PUSH
2067: LD_INT 47
2069: PUSH
2070: LD_INT 45
2072: PUSH
2073: LD_INT 49
2075: PUSH
2076: LD_INT 46
2078: PUSH
2079: EMPTY
2080: LIST
2081: LIST
2082: LIST
2083: LIST
2084: LIST
2085: PPUSH
2086: CALL 89128 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2090: LD_EXP 7
2094: PPUSH
2095: LD_INT 13
2097: PPUSH
2098: CALL 88798 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2102: LD_EXP 7
2106: PPUSH
2107: LD_INT 15
2109: PPUSH
2110: CALL 88521 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2114: LD_EXP 7
2118: PPUSH
2119: LD_INT 5
2121: PPUSH
2122: CALL 88140 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2126: LD_EXP 7
2130: PPUSH
2131: LD_INT 23
2133: PUSH
2134: LD_INT 1
2136: PUSH
2137: LD_INT 3
2139: PUSH
2140: LD_INT 46
2142: PUSH
2143: EMPTY
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: PUSH
2149: LD_INT 23
2151: PUSH
2152: LD_INT 1
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 46
2160: PUSH
2161: EMPTY
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PUSH
2167: LD_INT 23
2169: PUSH
2170: LD_INT 1
2172: PUSH
2173: LD_INT 3
2175: PUSH
2176: LD_INT 45
2178: PUSH
2179: EMPTY
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: PUSH
2185: LD_INT 23
2187: PUSH
2188: LD_INT 1
2190: PUSH
2191: LD_INT 1
2193: PUSH
2194: LD_INT 47
2196: PUSH
2197: EMPTY
2198: LIST
2199: LIST
2200: LIST
2201: LIST
2202: PUSH
2203: LD_INT 23
2205: PUSH
2206: LD_INT 1
2208: PUSH
2209: LD_INT 3
2211: PUSH
2212: LD_INT 46
2214: PUSH
2215: EMPTY
2216: LIST
2217: LIST
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 21
2223: PUSH
2224: LD_INT 1
2226: PUSH
2227: LD_INT 3
2229: PUSH
2230: LD_INT 51
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: LIST
2237: LIST
2238: PUSH
2239: LD_INT 21
2241: PUSH
2242: LD_INT 1
2244: PUSH
2245: LD_INT 3
2247: PUSH
2248: LD_INT 52
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: LIST
2256: PUSH
2257: EMPTY
2258: LIST
2259: LIST
2260: LIST
2261: LIST
2262: LIST
2263: LIST
2264: LIST
2265: PPUSH
2266: CALL 87955 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2270: LD_EXP 8
2274: PPUSH
2275: LD_INT 11
2277: PPUSH
2278: CALL 89308 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2282: LD_EXP 8
2286: PPUSH
2287: LD_INT 12
2289: PPUSH
2290: CALL 89248 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2294: LD_EXP 8
2298: PPUSH
2299: LD_INT 43
2301: PUSH
2302: LD_INT 47
2304: PUSH
2305: LD_INT 45
2307: PUSH
2308: LD_INT 49
2310: PUSH
2311: LD_INT 46
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: LIST
2318: LIST
2319: LIST
2320: PPUSH
2321: CALL 89128 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2325: LD_EXP 8
2329: PPUSH
2330: LD_INT 13
2332: PPUSH
2333: CALL 88798 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2337: LD_EXP 8
2341: PPUSH
2342: LD_INT 11
2344: PPUSH
2345: CALL 88521 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2349: LD_EXP 8
2353: PPUSH
2354: LD_INT 4
2356: PPUSH
2357: CALL 88140 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2361: LD_EXP 8
2365: PPUSH
2366: LD_INT 115
2368: PUSH
2369: LD_INT 201
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PUSH
2376: EMPTY
2377: LIST
2378: PPUSH
2379: CALL 88858 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2383: LD_EXP 8
2387: PPUSH
2388: LD_INT 24
2390: PUSH
2391: LD_INT 3
2393: PUSH
2394: LD_INT 3
2396: PUSH
2397: LD_INT 46
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 24
2408: PUSH
2409: LD_INT 3
2411: PUSH
2412: LD_INT 3
2414: PUSH
2415: LD_INT 46
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: LIST
2422: LIST
2423: PUSH
2424: LD_INT 24
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: LD_INT 3
2432: PUSH
2433: LD_INT 46
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: LIST
2440: LIST
2441: PUSH
2442: LD_INT 24
2444: PUSH
2445: LD_INT 3
2447: PUSH
2448: LD_INT 3
2450: PUSH
2451: LD_INT 46
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: PUSH
2460: EMPTY
2461: LIST
2462: LIST
2463: LIST
2464: LIST
2465: PPUSH
2466: CALL 87955 0 2
// end ;
2470: LD_VAR 0 1
2474: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2475: LD_INT 0
2477: PPUSH
2478: PPUSH
2479: PPUSH
2480: PPUSH
2481: PPUSH
2482: PPUSH
2483: PPUSH
2484: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2485: LD_INT 0
2487: PPUSH
2488: LD_INT 0
2490: PPUSH
2491: LD_INT 3
2493: PPUSH
2494: LD_INT 0
2496: PPUSH
2497: LD_INT 0
2499: PPUSH
2500: LD_INT 0
2502: PPUSH
2503: LD_INT 0
2505: PPUSH
2506: LD_INT 14
2508: PPUSH
2509: LD_INT 0
2511: PPUSH
2512: CALL 54762 0 9
// side := 3 ;
2516: LD_ADDR_VAR 0 5
2520: PUSH
2521: LD_INT 3
2523: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2524: LD_INT 38
2526: PPUSH
2527: LD_VAR 0 5
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2539: LD_INT 39
2541: PPUSH
2542: LD_VAR 0 5
2546: PPUSH
2547: LD_INT 2
2549: PPUSH
2550: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2554: LD_INT 34
2556: PPUSH
2557: LD_VAR 0 5
2561: PPUSH
2562: LD_INT 2
2564: PPUSH
2565: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2569: LD_ADDR_VAR 0 4
2573: PUSH
2574: LD_INT 0
2576: PUSH
2577: LD_INT 208
2579: PUSH
2580: LD_INT 163
2582: PUSH
2583: LD_INT 4
2585: PUSH
2586: LD_INT 0
2588: PUSH
2589: LD_INT 0
2591: PUSH
2592: EMPTY
2593: LIST
2594: LIST
2595: LIST
2596: LIST
2597: LIST
2598: LIST
2599: PUSH
2600: LD_INT 3
2602: PUSH
2603: LD_INT 194
2605: PUSH
2606: LD_INT 161
2608: PUSH
2609: LD_INT 1
2611: PUSH
2612: LD_INT 0
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: EMPTY
2619: LIST
2620: LIST
2621: LIST
2622: LIST
2623: LIST
2624: LIST
2625: PUSH
2626: LD_INT 17
2628: PUSH
2629: LD_INT 190
2631: PUSH
2632: LD_INT 161
2634: PUSH
2635: LD_INT 1
2637: PUSH
2638: LD_INT 0
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: LIST
2648: LIST
2649: LIST
2650: LIST
2651: PUSH
2652: LD_INT 5
2654: PUSH
2655: LD_INT 200
2657: PUSH
2658: LD_INT 145
2660: PUSH
2661: LD_INT 3
2663: PUSH
2664: LD_INT 0
2666: PUSH
2667: LD_INT 0
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: LIST
2674: LIST
2675: LIST
2676: LIST
2677: PUSH
2678: LD_INT 32
2680: PUSH
2681: LD_INT 192
2683: PUSH
2684: LD_INT 144
2686: PUSH
2687: LD_INT 3
2689: PUSH
2690: LD_INT 0
2692: PUSH
2693: LD_INT 0
2695: PUSH
2696: EMPTY
2697: LIST
2698: LIST
2699: LIST
2700: LIST
2701: LIST
2702: LIST
2703: PUSH
2704: LD_INT 26
2706: PUSH
2707: LD_INT 216
2709: PUSH
2710: LD_INT 172
2712: PUSH
2713: LD_INT 3
2715: PUSH
2716: LD_INT 0
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: LIST
2726: LIST
2727: LIST
2728: LIST
2729: PUSH
2730: LD_INT 26
2732: PUSH
2733: LD_INT 218
2735: PUSH
2736: LD_INT 176
2738: PUSH
2739: LD_INT 3
2741: PUSH
2742: LD_INT 0
2744: PUSH
2745: LD_INT 0
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: LIST
2754: LIST
2755: PUSH
2756: LD_INT 29
2758: PUSH
2759: LD_INT 182
2761: PUSH
2762: LD_INT 149
2764: PUSH
2765: LD_INT 3
2767: PUSH
2768: LD_INT 0
2770: PUSH
2771: LD_INT 0
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: LIST
2778: LIST
2779: LIST
2780: LIST
2781: PUSH
2782: LD_INT 8
2784: PUSH
2785: LD_INT 201
2787: PUSH
2788: LD_INT 171
2790: PUSH
2791: LD_INT 0
2793: PUSH
2794: LD_INT 10
2796: PUSH
2797: LD_INT 11
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: LIST
2804: LIST
2805: LIST
2806: LIST
2807: PUSH
2808: LD_INT 32
2810: PUSH
2811: LD_INT 188
2813: PUSH
2814: LD_INT 167
2816: PUSH
2817: LD_INT 0
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: LD_INT 0
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: LIST
2830: LIST
2831: LIST
2832: LIST
2833: PUSH
2834: LD_INT 32
2836: PUSH
2837: LD_INT 202
2839: PUSH
2840: LD_INT 179
2842: PUSH
2843: LD_INT 0
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: EMPTY
2853: LIST
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: LIST
2859: PUSH
2860: LD_INT 32
2862: PUSH
2863: LD_INT 209
2865: PUSH
2866: LD_INT 182
2868: PUSH
2869: LD_INT 0
2871: PUSH
2872: LD_INT 0
2874: PUSH
2875: LD_INT 0
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: LIST
2882: LIST
2883: LIST
2884: LIST
2885: PUSH
2886: LD_INT 32
2888: PUSH
2889: LD_INT 220
2891: PUSH
2892: LD_INT 183
2894: PUSH
2895: LD_INT 5
2897: PUSH
2898: LD_INT 0
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: EMPTY
2905: LIST
2906: LIST
2907: LIST
2908: LIST
2909: LIST
2910: LIST
2911: PUSH
2912: LD_INT 32
2914: PUSH
2915: LD_INT 225
2917: PUSH
2918: LD_INT 181
2920: PUSH
2921: LD_INT 5
2923: PUSH
2924: LD_INT 0
2926: PUSH
2927: LD_INT 0
2929: PUSH
2930: EMPTY
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: PUSH
2938: LD_INT 26
2940: PUSH
2941: LD_INT 220
2943: PUSH
2944: LD_INT 174
2946: PUSH
2947: LD_INT 5
2949: PUSH
2950: LD_INT 0
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: LIST
2960: LIST
2961: LIST
2962: LIST
2963: PUSH
2964: LD_INT 1
2966: PUSH
2967: LD_INT 84
2969: PUSH
2970: LD_INT 128
2972: PUSH
2973: LD_INT 4
2975: PUSH
2976: LD_INT 0
2978: PUSH
2979: LD_INT 0
2981: PUSH
2982: EMPTY
2983: LIST
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_INT 3
2992: PUSH
2993: LD_INT 68
2995: PUSH
2996: LD_INT 121
2998: PUSH
2999: LD_INT 1
3001: PUSH
3002: LD_INT 0
3004: PUSH
3005: LD_INT 0
3007: PUSH
3008: EMPTY
3009: LIST
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_INT 19
3018: PUSH
3019: LD_INT 72
3021: PUSH
3022: LD_INT 125
3024: PUSH
3025: LD_INT 5
3027: PUSH
3028: LD_INT 0
3030: PUSH
3031: LD_INT 0
3033: PUSH
3034: EMPTY
3035: LIST
3036: LIST
3037: LIST
3038: LIST
3039: LIST
3040: LIST
3041: PUSH
3042: LD_INT 18
3044: PUSH
3045: LD_INT 68
3047: PUSH
3048: LD_INT 124
3050: PUSH
3051: LD_INT 0
3053: PUSH
3054: LD_INT 0
3056: PUSH
3057: LD_INT 0
3059: PUSH
3060: EMPTY
3061: LIST
3062: LIST
3063: LIST
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: LD_INT 24
3070: PUSH
3071: LD_INT 64
3073: PUSH
3074: LD_INT 121
3076: PUSH
3077: LD_INT 1
3079: PUSH
3080: LD_INT 0
3082: PUSH
3083: LD_INT 0
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 17
3096: PUSH
3097: LD_INT 65
3099: PUSH
3100: LD_INT 118
3102: PUSH
3103: LD_INT 2
3105: PUSH
3106: LD_INT 0
3108: PUSH
3109: LD_INT 0
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: LIST
3116: LIST
3117: LIST
3118: LIST
3119: PUSH
3120: LD_INT 21
3122: PUSH
3123: LD_INT 68
3125: PUSH
3126: LD_INT 117
3128: PUSH
3129: LD_INT 3
3131: PUSH
3132: LD_INT 0
3134: PUSH
3135: LD_INT 0
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: PUSH
3146: LD_INT 8
3148: PUSH
3149: LD_INT 68
3151: PUSH
3152: LD_INT 130
3154: PUSH
3155: LD_INT 1
3157: PUSH
3158: LD_INT 14
3160: PUSH
3161: LD_INT 10
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: PUSH
3172: LD_INT 8
3174: PUSH
3175: LD_INT 67
3177: PUSH
3178: LD_INT 110
3180: PUSH
3181: LD_INT 2
3183: PUSH
3184: LD_INT 11
3186: PUSH
3187: LD_INT 12
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: LIST
3194: LIST
3195: LIST
3196: LIST
3197: PUSH
3198: LD_INT 28
3200: PUSH
3201: LD_INT 85
3203: PUSH
3204: LD_INT 108
3206: PUSH
3207: LD_INT 2
3209: PUSH
3210: LD_INT 0
3212: PUSH
3213: LD_INT 0
3215: PUSH
3216: EMPTY
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: PUSH
3224: LD_INT 28
3226: PUSH
3227: LD_INT 85
3229: PUSH
3230: LD_INT 124
3232: PUSH
3233: LD_INT 2
3235: PUSH
3236: LD_INT 0
3238: PUSH
3239: LD_INT 0
3241: PUSH
3242: EMPTY
3243: LIST
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: PUSH
3250: LD_INT 30
3252: PUSH
3253: LD_INT 97
3255: PUSH
3256: LD_INT 119
3258: PUSH
3259: LD_INT 2
3261: PUSH
3262: LD_INT 0
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: LIST
3275: PUSH
3276: LD_INT 5
3278: PUSH
3279: LD_INT 111
3281: PUSH
3282: LD_INT 138
3284: PUSH
3285: LD_INT 4
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: LD_INT 0
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: PUSH
3302: LD_INT 33
3304: PUSH
3305: LD_INT 104
3307: PUSH
3308: LD_INT 130
3310: PUSH
3311: LD_INT 3
3313: PUSH
3314: LD_INT 0
3316: PUSH
3317: LD_INT 0
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: LIST
3324: LIST
3325: LIST
3326: LIST
3327: PUSH
3328: LD_INT 33
3330: PUSH
3331: LD_INT 110
3333: PUSH
3334: LD_INT 142
3336: PUSH
3337: LD_INT 5
3339: PUSH
3340: LD_INT 0
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: LIST
3350: LIST
3351: LIST
3352: LIST
3353: PUSH
3354: LD_INT 33
3356: PUSH
3357: LD_INT 91
3359: PUSH
3360: LD_INT 131
3362: PUSH
3363: LD_INT 5
3365: PUSH
3366: LD_INT 0
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: LIST
3379: PUSH
3380: LD_INT 33
3382: PUSH
3383: LD_INT 107
3385: PUSH
3386: LD_INT 157
3388: PUSH
3389: LD_INT 5
3391: PUSH
3392: LD_INT 0
3394: PUSH
3395: LD_INT 0
3397: PUSH
3398: EMPTY
3399: LIST
3400: LIST
3401: LIST
3402: LIST
3403: LIST
3404: LIST
3405: PUSH
3406: LD_INT 33
3408: PUSH
3409: LD_INT 104
3411: PUSH
3412: LD_INT 160
3414: PUSH
3415: LD_INT 5
3417: PUSH
3418: LD_INT 0
3420: PUSH
3421: LD_INT 0
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 33
3434: PUSH
3435: LD_INT 101
3437: PUSH
3438: LD_INT 162
3440: PUSH
3441: LD_INT 5
3443: PUSH
3444: LD_INT 0
3446: PUSH
3447: LD_INT 0
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: LIST
3456: LIST
3457: PUSH
3458: LD_INT 32
3460: PUSH
3461: LD_INT 87
3463: PUSH
3464: LD_INT 157
3466: PUSH
3467: LD_INT 5
3469: PUSH
3470: LD_INT 0
3472: PUSH
3473: LD_INT 0
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: LIST
3483: PUSH
3484: LD_INT 32
3486: PUSH
3487: LD_INT 105
3489: PUSH
3490: LD_INT 158
3492: PUSH
3493: LD_INT 5
3495: PUSH
3496: LD_INT 0
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: LIST
3506: LIST
3507: LIST
3508: LIST
3509: PUSH
3510: LD_INT 33
3512: PUSH
3513: LD_INT 91
3515: PUSH
3516: LD_INT 118
3518: PUSH
3519: LD_INT 4
3521: PUSH
3522: LD_INT 0
3524: PUSH
3525: LD_INT 0
3527: PUSH
3528: EMPTY
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: LIST
3534: LIST
3535: PUSH
3536: LD_INT 33
3538: PUSH
3539: LD_INT 89
3541: PUSH
3542: LD_INT 107
3544: PUSH
3545: LD_INT 4
3547: PUSH
3548: LD_INT 0
3550: PUSH
3551: LD_INT 0
3553: PUSH
3554: EMPTY
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: LIST
3560: LIST
3561: PUSH
3562: LD_INT 5
3564: PUSH
3565: LD_INT 86
3567: PUSH
3568: LD_INT 96
3570: PUSH
3571: LD_INT 3
3573: PUSH
3574: LD_INT 0
3576: PUSH
3577: LD_INT 0
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: PUSH
3588: LD_INT 33
3590: PUSH
3591: LD_INT 91
3593: PUSH
3594: LD_INT 102
3596: PUSH
3597: LD_INT 4
3599: PUSH
3600: LD_INT 0
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 32
3616: PUSH
3617: LD_INT 80
3619: PUSH
3620: LD_INT 95
3622: PUSH
3623: LD_INT 3
3625: PUSH
3626: LD_INT 0
3628: PUSH
3629: LD_INT 0
3631: PUSH
3632: EMPTY
3633: LIST
3634: LIST
3635: LIST
3636: LIST
3637: LIST
3638: LIST
3639: PUSH
3640: LD_INT 28
3642: PUSH
3643: LD_INT 77
3645: PUSH
3646: LD_INT 105
3648: PUSH
3649: LD_INT 3
3651: PUSH
3652: LD_INT 0
3654: PUSH
3655: LD_INT 0
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: LIST
3662: LIST
3663: LIST
3664: LIST
3665: PUSH
3666: LD_INT 28
3668: PUSH
3669: LD_INT 85
3671: PUSH
3672: LD_INT 113
3674: PUSH
3675: LD_INT 3
3677: PUSH
3678: LD_INT 0
3680: PUSH
3681: LD_INT 0
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: LIST
3688: LIST
3689: LIST
3690: LIST
3691: PUSH
3692: LD_INT 28
3694: PUSH
3695: LD_INT 55
3697: PUSH
3698: LD_INT 97
3700: PUSH
3701: LD_INT 3
3703: PUSH
3704: LD_INT 0
3706: PUSH
3707: LD_INT 0
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: LIST
3714: LIST
3715: LIST
3716: LIST
3717: PUSH
3718: LD_INT 28
3720: PUSH
3721: LD_INT 88
3723: PUSH
3724: LD_INT 128
3726: PUSH
3727: LD_INT 3
3729: PUSH
3730: LD_INT 0
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: LIST
3740: LIST
3741: LIST
3742: LIST
3743: PUSH
3744: LD_INT 32
3746: PUSH
3747: LD_INT 69
3749: PUSH
3750: LD_INT 101
3752: PUSH
3753: LD_INT 2
3755: PUSH
3756: LD_INT 0
3758: PUSH
3759: LD_INT 0
3761: PUSH
3762: EMPTY
3763: LIST
3764: LIST
3765: LIST
3766: LIST
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 1
3772: PUSH
3773: LD_INT 34
3775: PUSH
3776: LD_INT 23
3778: PUSH
3779: LD_INT 4
3781: PUSH
3782: LD_INT 0
3784: PUSH
3785: LD_INT 0
3787: PUSH
3788: EMPTY
3789: LIST
3790: LIST
3791: LIST
3792: LIST
3793: LIST
3794: LIST
3795: PUSH
3796: LD_INT 8
3798: PUSH
3799: LD_INT 25
3801: PUSH
3802: LD_INT 4
3804: PUSH
3805: LD_INT 3
3807: PUSH
3808: LD_INT 11
3810: PUSH
3811: LD_INT 10
3813: PUSH
3814: EMPTY
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: LIST
3821: PUSH
3822: LD_INT 8
3824: PUSH
3825: LD_INT 15
3827: PUSH
3828: LD_INT 4
3830: PUSH
3831: LD_INT 2
3833: PUSH
3834: LD_INT 14
3836: PUSH
3837: LD_INT 12
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: LIST
3844: LIST
3845: LIST
3846: LIST
3847: PUSH
3848: LD_INT 29
3850: PUSH
3851: LD_INT 55
3853: PUSH
3854: LD_INT 35
3856: PUSH
3857: LD_INT 2
3859: PUSH
3860: LD_INT 0
3862: PUSH
3863: LD_INT 0
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: PUSH
3874: LD_INT 29
3876: PUSH
3877: LD_INT 24
3879: PUSH
3880: LD_INT 44
3882: PUSH
3883: LD_INT 2
3885: PUSH
3886: LD_INT 0
3888: PUSH
3889: LD_INT 0
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: LIST
3896: LIST
3897: LIST
3898: LIST
3899: PUSH
3900: LD_INT 34
3902: PUSH
3903: LD_INT 34
3905: PUSH
3906: LD_INT 32
3908: PUSH
3909: LD_INT 4
3911: PUSH
3912: LD_INT 0
3914: PUSH
3915: LD_INT 0
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: LIST
3925: PUSH
3926: LD_INT 3
3928: PUSH
3929: LD_INT 14
3931: PUSH
3932: LD_INT 16
3934: PUSH
3935: LD_INT 1
3937: PUSH
3938: LD_INT 0
3940: PUSH
3941: LD_INT 0
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: LIST
3948: LIST
3949: LIST
3950: LIST
3951: PUSH
3952: LD_INT 24
3954: PUSH
3955: LD_INT 10
3957: PUSH
3958: LD_INT 16
3960: PUSH
3961: LD_INT 1
3963: PUSH
3964: LD_INT 0
3966: PUSH
3967: LD_INT 0
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: LIST
3977: PUSH
3978: LD_INT 21
3980: PUSH
3981: LD_INT 11
3983: PUSH
3984: LD_INT 13
3986: PUSH
3987: LD_INT 2
3989: PUSH
3990: LD_INT 0
3992: PUSH
3993: LD_INT 0
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: LIST
4002: LIST
4003: PUSH
4004: LD_INT 18
4006: PUSH
4007: LD_INT 14
4009: PUSH
4010: LD_INT 12
4012: PUSH
4013: LD_INT 3
4015: PUSH
4016: LD_INT 0
4018: PUSH
4019: LD_INT 0
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: PUSH
4030: LD_INT 16
4032: PUSH
4033: LD_INT 14
4035: PUSH
4036: LD_INT 19
4038: PUSH
4039: LD_INT 0
4041: PUSH
4042: LD_INT 0
4044: PUSH
4045: LD_INT 0
4047: PUSH
4048: EMPTY
4049: LIST
4050: LIST
4051: LIST
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_INT 17
4058: PUSH
4059: LD_INT 18
4061: PUSH
4062: LD_INT 20
4064: PUSH
4065: LD_INT 5
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: LD_INT 0
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: LIST
4078: LIST
4079: LIST
4080: LIST
4081: PUSH
4082: LD_INT 28
4084: PUSH
4085: LD_INT 10
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: LD_INT 1
4093: PUSH
4094: LD_INT 0
4096: PUSH
4097: LD_INT 0
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: PUSH
4108: LD_INT 28
4110: PUSH
4111: LD_INT 8
4113: PUSH
4114: LD_INT 8
4116: PUSH
4117: LD_INT 1
4119: PUSH
4120: LD_INT 0
4122: PUSH
4123: LD_INT 0
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: LIST
4130: LIST
4131: LIST
4132: LIST
4133: PUSH
4134: LD_INT 26
4136: PUSH
4137: LD_INT 19
4139: PUSH
4140: LD_INT 2
4142: PUSH
4143: LD_INT 1
4145: PUSH
4146: LD_INT 0
4148: PUSH
4149: LD_INT 0
4151: PUSH
4152: EMPTY
4153: LIST
4154: LIST
4155: LIST
4156: LIST
4157: LIST
4158: LIST
4159: PUSH
4160: LD_INT 26
4162: PUSH
4163: LD_INT 30
4165: PUSH
4166: LD_INT 2
4168: PUSH
4169: LD_INT 1
4171: PUSH
4172: LD_INT 0
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: LIST
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 5
4188: PUSH
4189: LD_INT 59
4191: PUSH
4192: LD_INT 20
4194: PUSH
4195: LD_INT 4
4197: PUSH
4198: LD_INT 0
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: LIST
4208: LIST
4209: LIST
4210: LIST
4211: PUSH
4212: LD_INT 32
4214: PUSH
4215: LD_INT 60
4217: PUSH
4218: LD_INT 24
4220: PUSH
4221: LD_INT 4
4223: PUSH
4224: LD_INT 0
4226: PUSH
4227: LD_INT 0
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: LIST
4236: LIST
4237: PUSH
4238: LD_INT 32
4240: PUSH
4241: LD_INT 61
4243: PUSH
4244: LD_INT 45
4246: PUSH
4247: LD_INT 5
4249: PUSH
4250: LD_INT 0
4252: PUSH
4253: LD_INT 0
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 32
4266: PUSH
4267: LD_INT 52
4269: PUSH
4270: LD_INT 51
4272: PUSH
4273: LD_INT 5
4275: PUSH
4276: LD_INT 0
4278: PUSH
4279: LD_INT 0
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: LIST
4286: LIST
4287: LIST
4288: LIST
4289: PUSH
4290: LD_INT 33
4292: PUSH
4293: LD_INT 56
4295: PUSH
4296: LD_INT 51
4298: PUSH
4299: LD_INT 5
4301: PUSH
4302: LD_INT 0
4304: PUSH
4305: LD_INT 0
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: LIST
4312: LIST
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 33
4318: PUSH
4319: LD_INT 62
4321: PUSH
4322: LD_INT 49
4324: PUSH
4325: LD_INT 5
4327: PUSH
4328: LD_INT 0
4330: PUSH
4331: LD_INT 0
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: PUSH
4342: LD_INT 33
4344: PUSH
4345: LD_INT 41
4347: PUSH
4348: LD_INT 47
4350: PUSH
4351: LD_INT 5
4353: PUSH
4354: LD_INT 0
4356: PUSH
4357: LD_INT 0
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: LIST
4364: LIST
4365: LIST
4366: LIST
4367: PUSH
4368: LD_INT 33
4370: PUSH
4371: LD_INT 33
4373: PUSH
4374: LD_INT 52
4376: PUSH
4377: LD_INT 5
4379: PUSH
4380: LD_INT 0
4382: PUSH
4383: LD_INT 0
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: LIST
4390: LIST
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 5
4396: PUSH
4397: LD_INT 31
4399: PUSH
4400: LD_INT 40
4402: PUSH
4403: LD_INT 0
4405: PUSH
4406: LD_INT 0
4408: PUSH
4409: LD_INT 0
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 33
4422: PUSH
4423: LD_INT 65
4425: PUSH
4426: LD_INT 37
4428: PUSH
4429: LD_INT 5
4431: PUSH
4432: LD_INT 0
4434: PUSH
4435: LD_INT 0
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: LIST
4442: LIST
4443: LIST
4444: LIST
4445: PUSH
4446: LD_INT 33
4448: PUSH
4449: LD_INT 63
4451: PUSH
4452: LD_INT 29
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: LD_INT 0
4460: PUSH
4461: LD_INT 0
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 33
4474: PUSH
4475: LD_INT 54
4477: PUSH
4478: LD_INT 11
4480: PUSH
4481: LD_INT 4
4483: PUSH
4484: LD_INT 0
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: LIST
4496: LIST
4497: PUSH
4498: LD_INT 33
4500: PUSH
4501: LD_INT 56
4503: PUSH
4504: LD_INT 15
4506: PUSH
4507: LD_INT 4
4509: PUSH
4510: LD_INT 0
4512: PUSH
4513: LD_INT 0
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: LIST
4523: PUSH
4524: LD_INT 33
4526: PUSH
4527: LD_INT 51
4529: PUSH
4530: LD_INT 6
4532: PUSH
4533: LD_INT 4
4535: PUSH
4536: LD_INT 0
4538: PUSH
4539: LD_INT 0
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: PUSH
4550: LD_INT 26
4552: PUSH
4553: LD_INT 39
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 0
4561: PUSH
4562: LD_INT 0
4564: PUSH
4565: LD_INT 0
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: LIST
4572: LIST
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 26
4578: PUSH
4579: LD_INT 37
4581: PUSH
4582: LD_INT 21
4584: PUSH
4585: LD_INT 0
4587: PUSH
4588: LD_INT 0
4590: PUSH
4591: LD_INT 0
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: PUSH
4602: LD_INT 32
4604: PUSH
4605: LD_INT 35
4607: PUSH
4608: LD_INT 17
4610: PUSH
4611: LD_INT 4
4613: PUSH
4614: LD_INT 0
4616: PUSH
4617: LD_INT 0
4619: PUSH
4620: EMPTY
4621: LIST
4622: LIST
4623: LIST
4624: LIST
4625: LIST
4626: LIST
4627: PUSH
4628: LD_INT 33
4630: PUSH
4631: LD_INT 35
4633: PUSH
4634: LD_INT 28
4636: PUSH
4637: LD_INT 4
4639: PUSH
4640: LD_INT 0
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: EMPTY
4647: LIST
4648: LIST
4649: LIST
4650: LIST
4651: LIST
4652: LIST
4653: PUSH
4654: LD_INT 33
4656: PUSH
4657: LD_INT 28
4659: PUSH
4660: LD_INT 46
4662: PUSH
4663: LD_INT 5
4665: PUSH
4666: LD_INT 0
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: LIST
4676: LIST
4677: LIST
4678: LIST
4679: PUSH
4680: LD_INT 33
4682: PUSH
4683: LD_INT 31
4685: PUSH
4686: LD_INT 6
4688: PUSH
4689: LD_INT 4
4691: PUSH
4692: LD_INT 0
4694: PUSH
4695: LD_INT 0
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: PUSH
4706: LD_INT 26
4708: PUSH
4709: LD_INT 54
4711: PUSH
4712: LD_INT 38
4714: PUSH
4715: LD_INT 4
4717: PUSH
4718: LD_INT 0
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: LIST
4731: PUSH
4732: LD_INT 33
4734: PUSH
4735: LD_INT 207
4737: PUSH
4738: LD_INT 167
4740: PUSH
4741: LD_INT 3
4743: PUSH
4744: LD_INT 0
4746: PUSH
4747: LD_INT 0
4749: PUSH
4750: EMPTY
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: LD_INT 30
4760: PUSH
4761: LD_INT 43
4763: PUSH
4764: LD_INT 2
4766: PUSH
4767: LD_INT 4
4769: PUSH
4770: LD_INT 0
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: EMPTY
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: LIST
4788: LIST
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: LIST
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: LIST
4804: LIST
4805: LIST
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: ST_TO_ADDR
// for i in tmp do
4871: LD_ADDR_VAR 0 2
4875: PUSH
4876: LD_VAR 0 4
4880: PUSH
4881: FOR_IN
4882: IFFALSE 5113
// begin uc_side := side ;
4884: LD_ADDR_OWVAR 20
4888: PUSH
4889: LD_VAR 0 5
4893: ST_TO_ADDR
// uc_nation := nation_russian ;
4894: LD_ADDR_OWVAR 21
4898: PUSH
4899: LD_INT 3
4901: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4902: LD_ADDR_OWVAR 42
4906: PUSH
4907: LD_VAR 0 2
4911: PUSH
4912: LD_INT 1
4914: ARRAY
4915: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4916: LD_ADDR_OWVAR 43
4920: PUSH
4921: LD_INT 5
4923: PPUSH
4924: LD_INT 6
4926: PPUSH
4927: CALL_OW 12
4931: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4932: LD_ADDR_OWVAR 44
4936: PUSH
4937: LD_VAR 0 2
4941: PUSH
4942: LD_INT 5
4944: ARRAY
4945: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4946: LD_ADDR_OWVAR 45
4950: PUSH
4951: LD_VAR 0 2
4955: PUSH
4956: LD_INT 6
4958: ARRAY
4959: ST_TO_ADDR
// sr := 0 ;
4960: LD_ADDR_VAR 0 6
4964: PUSH
4965: LD_INT 0
4967: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4968: LD_VAR 0 2
4972: PUSH
4973: LD_INT 1
4975: ARRAY
4976: PUSH
4977: LD_INT 29
4979: EQUAL
4980: IFFALSE 4992
// sr := mat_oil else
4982: LD_ADDR_VAR 0 6
4986: PUSH
4987: LD_INT 2
4989: ST_TO_ADDR
4990: GO 5014
// if i [ 1 ] = b_siberite_mine then
4992: LD_VAR 0 2
4996: PUSH
4997: LD_INT 1
4999: ARRAY
5000: PUSH
5001: LD_INT 30
5003: EQUAL
5004: IFFALSE 5014
// sr := mat_siberit ;
5006: LD_ADDR_VAR 0 6
5010: PUSH
5011: LD_INT 3
5013: ST_TO_ADDR
// if sr then
5014: LD_VAR 0 6
5018: IFFALSE 5074
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5020: LD_VAR 0 2
5024: PUSH
5025: LD_INT 2
5027: ARRAY
5028: PPUSH
5029: LD_VAR 0 2
5033: PUSH
5034: LD_INT 3
5036: ARRAY
5037: PPUSH
5038: LD_VAR 0 6
5042: PPUSH
5043: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5047: LD_VAR 0 2
5051: PUSH
5052: LD_INT 2
5054: ARRAY
5055: PPUSH
5056: LD_VAR 0 2
5060: PUSH
5061: LD_INT 3
5063: ARRAY
5064: PPUSH
5065: LD_VAR 0 5
5069: PPUSH
5070: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5074: LD_ADDR_VAR 0 3
5078: PUSH
5079: LD_VAR 0 2
5083: PUSH
5084: LD_INT 2
5086: ARRAY
5087: PPUSH
5088: LD_VAR 0 2
5092: PUSH
5093: LD_INT 3
5095: ARRAY
5096: PPUSH
5097: LD_VAR 0 2
5101: PUSH
5102: LD_INT 4
5104: ARRAY
5105: PPUSH
5106: CALL_OW 47
5110: ST_TO_ADDR
// end ;
5111: GO 4881
5113: POP
5114: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5115: LD_ADDR_VAR 0 7
5119: PUSH
5120: LD_INT 22
5122: PUSH
5123: LD_VAR 0 5
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 30
5134: PUSH
5135: LD_INT 1
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PPUSH
5146: CALL_OW 69
5150: ST_TO_ADDR
// if not depot then
5151: LD_VAR 0 7
5155: NOT
5156: IFFALSE 5160
// exit ;
5158: GO 5504
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5160: LD_ADDR_VAR 0 8
5164: PUSH
5165: LD_INT 84
5167: PPUSH
5168: LD_INT 128
5170: PPUSH
5171: CALL_OW 428
5175: PPUSH
5176: LD_INT 15
5178: PPUSH
5179: LD_INT 0
5181: PPUSH
5182: LD_INT 6
5184: PUSH
5185: LD_INT 7
5187: PUSH
5188: LD_INT 8
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: PUSH
5196: LD_OWVAR 67
5200: ARRAY
5201: PPUSH
5202: LD_INT 3000
5204: PUSH
5205: LD_INT 300
5207: PUSH
5208: LD_INT 100
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: LIST
5215: PPUSH
5216: LD_INT 12
5218: PUSH
5219: LD_INT 6
5221: PUSH
5222: LD_INT 6
5224: PUSH
5225: LD_INT 4
5227: PUSH
5228: EMPTY
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: PPUSH
5234: CALL 28778 0 6
5238: ST_TO_ADDR
// if not base then
5239: LD_VAR 0 8
5243: NOT
5244: IFFALSE 5248
// exit ;
5246: GO 5504
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5248: LD_ADDR_EXP 31
5252: PUSH
5253: LD_EXP 31
5257: PPUSH
5258: LD_EXP 7
5262: PPUSH
5263: LD_VAR 0 8
5267: PPUSH
5268: CALL_OW 1
5272: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5273: LD_ADDR_VAR 0 8
5277: PUSH
5278: LD_INT 34
5280: PPUSH
5281: LD_INT 23
5283: PPUSH
5284: CALL_OW 428
5288: PPUSH
5289: LD_INT 11
5291: PPUSH
5292: LD_INT 0
5294: PPUSH
5295: LD_INT 6
5297: PUSH
5298: LD_INT 7
5300: PUSH
5301: LD_INT 8
5303: PUSH
5304: EMPTY
5305: LIST
5306: LIST
5307: LIST
5308: PUSH
5309: LD_OWVAR 67
5313: ARRAY
5314: PPUSH
5315: LD_INT 20000
5317: PUSH
5318: LD_INT 3000
5320: PUSH
5321: LD_INT 1000
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: LIST
5328: PPUSH
5329: LD_INT 12
5331: PUSH
5332: LD_INT 6
5334: PUSH
5335: LD_INT 6
5337: PUSH
5338: LD_INT 4
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: LIST
5345: LIST
5346: PPUSH
5347: CALL 28778 0 6
5351: ST_TO_ADDR
// if not base then
5352: LD_VAR 0 8
5356: NOT
5357: IFFALSE 5361
// exit ;
5359: GO 5504
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5361: LD_ADDR_EXP 31
5365: PUSH
5366: LD_EXP 31
5370: PPUSH
5371: LD_EXP 8
5375: PPUSH
5376: LD_VAR 0 8
5380: PPUSH
5381: CALL_OW 1
5385: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5386: LD_ADDR_EXP 14
5390: PUSH
5391: LD_INT 22
5393: PUSH
5394: LD_INT 3
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: PUSH
5401: LD_INT 30
5403: PUSH
5404: LD_INT 0
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PPUSH
5415: CALL_OW 69
5419: PUSH
5420: LD_INT 1
5422: ARRAY
5423: PPUSH
5424: LD_INT 25
5426: PPUSH
5427: LD_INT 0
5429: PPUSH
5430: LD_INT 6
5432: PUSH
5433: LD_INT 7
5435: PUSH
5436: LD_INT 8
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: LIST
5443: PUSH
5444: LD_OWVAR 67
5448: ARRAY
5449: PPUSH
5450: LD_INT 500
5452: PUSH
5453: LD_INT 100
5455: PUSH
5456: LD_INT 10
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: LIST
5463: PPUSH
5464: LD_INT 6
5466: PUSH
5467: LD_INT 7
5469: PUSH
5470: LD_INT 8
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: PUSH
5478: LD_OWVAR 67
5482: ARRAY
5483: PUSH
5484: LD_INT 2
5486: PUSH
5487: LD_INT 0
5489: PUSH
5490: LD_INT 1
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: LIST
5497: LIST
5498: PPUSH
5499: CALL 28778 0 6
5503: ST_TO_ADDR
// end ;
5504: LD_VAR 0 1
5508: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5509: LD_INT 0
5511: PPUSH
5512: PPUSH
5513: PPUSH
5514: PPUSH
5515: PPUSH
5516: PPUSH
5517: PPUSH
5518: PPUSH
5519: PPUSH
5520: PPUSH
5521: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5522: LD_INT 0
5524: PPUSH
5525: LD_INT 0
5527: PPUSH
5528: LD_INT 6
5530: PPUSH
5531: LD_INT 0
5533: PPUSH
5534: LD_INT 0
5536: PPUSH
5537: LD_INT 0
5539: PPUSH
5540: LD_INT 0
5542: PPUSH
5543: LD_INT 8
5545: PPUSH
5546: LD_INT 0
5548: PPUSH
5549: CALL 54762 0 9
// side := 8 ;
5553: LD_ADDR_VAR 0 8
5557: PUSH
5558: LD_INT 8
5560: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5561: LD_ADDR_VAR 0 5
5565: PUSH
5566: LD_INT 20
5568: PPUSH
5569: LD_INT 0
5571: PPUSH
5572: CALL_OW 517
5576: ST_TO_ADDR
// if Difficulty > 2 then
5577: LD_OWVAR 67
5581: PUSH
5582: LD_INT 2
5584: GREATER
5585: IFFALSE 5729
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5587: LD_ADDR_VAR 0 6
5591: PUSH
5592: LD_INT 27
5594: PPUSH
5595: LD_INT 0
5597: PPUSH
5598: CALL_OW 517
5602: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5603: LD_ADDR_VAR 0 2
5607: PUSH
5608: DOUBLE
5609: LD_INT 1
5611: DEC
5612: ST_TO_ADDR
5613: LD_VAR 0 6
5617: PUSH
5618: LD_INT 1
5620: ARRAY
5621: PUSH
5622: FOR_TO
5623: IFFALSE 5727
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5625: LD_ADDR_VAR 0 5
5629: PUSH
5630: LD_VAR 0 5
5634: PPUSH
5635: LD_INT 1
5637: PUSH
5638: LD_VAR 0 5
5642: PUSH
5643: LD_INT 1
5645: ARRAY
5646: PUSH
5647: LD_INT 1
5649: PLUS
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: PPUSH
5655: LD_VAR 0 6
5659: PUSH
5660: LD_INT 1
5662: ARRAY
5663: PUSH
5664: LD_VAR 0 2
5668: ARRAY
5669: PPUSH
5670: CALL 25063 0 3
5674: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5675: LD_ADDR_VAR 0 5
5679: PUSH
5680: LD_VAR 0 5
5684: PPUSH
5685: LD_INT 2
5687: PUSH
5688: LD_VAR 0 5
5692: PUSH
5693: LD_INT 2
5695: ARRAY
5696: PUSH
5697: LD_INT 1
5699: PLUS
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PPUSH
5705: LD_VAR 0 6
5709: PUSH
5710: LD_INT 2
5712: ARRAY
5713: PUSH
5714: LD_VAR 0 2
5718: ARRAY
5719: PPUSH
5720: CALL 25063 0 3
5724: ST_TO_ADDR
// end ;
5725: GO 5622
5727: POP
5728: POP
// end ; if tmp then
5729: LD_VAR 0 5
5733: IFFALSE 5861
// begin for i = 1 to tmp [ 1 ] do
5735: LD_ADDR_VAR 0 2
5739: PUSH
5740: DOUBLE
5741: LD_INT 1
5743: DEC
5744: ST_TO_ADDR
5745: LD_VAR 0 5
5749: PUSH
5750: LD_INT 1
5752: ARRAY
5753: PUSH
5754: FOR_TO
5755: IFFALSE 5859
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5757: LD_VAR 0 5
5761: PUSH
5762: LD_INT 1
5764: ARRAY
5765: PUSH
5766: LD_VAR 0 2
5770: ARRAY
5771: PPUSH
5772: LD_VAR 0 5
5776: PUSH
5777: LD_INT 2
5779: ARRAY
5780: PUSH
5781: LD_VAR 0 2
5785: ARRAY
5786: PPUSH
5787: LD_VAR 0 8
5791: PPUSH
5792: LD_INT 0
5794: PPUSH
5795: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5799: LD_ADDR_EXP 16
5803: PUSH
5804: LD_EXP 16
5808: PPUSH
5809: LD_EXP 16
5813: PUSH
5814: LD_INT 1
5816: PLUS
5817: PPUSH
5818: LD_VAR 0 5
5822: PUSH
5823: LD_INT 1
5825: ARRAY
5826: PUSH
5827: LD_VAR 0 2
5831: ARRAY
5832: PUSH
5833: LD_VAR 0 5
5837: PUSH
5838: LD_INT 2
5840: ARRAY
5841: PUSH
5842: LD_VAR 0 2
5846: ARRAY
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL_OW 2
5856: ST_TO_ADDR
// end ;
5857: GO 5754
5859: POP
5860: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5861: LD_ADDR_VAR 0 7
5865: PUSH
5866: LD_INT 165
5868: PUSH
5869: LD_INT 156
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: LD_INT 143
5878: PUSH
5879: LD_INT 145
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: PUSH
5886: LD_INT 152
5888: PUSH
5889: LD_INT 165
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PUSH
5896: LD_INT 123
5898: PUSH
5899: LD_INT 153
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 161
5908: PUSH
5909: LD_INT 215
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PUSH
5916: LD_INT 172
5918: PUSH
5919: LD_INT 100
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: PUSH
5926: LD_INT 148
5928: PUSH
5929: LD_INT 83
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: PUSH
5936: LD_INT 122
5938: PUSH
5939: LD_INT 68
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: PUSH
5946: LD_INT 105
5948: PUSH
5949: LD_INT 74
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: PUSH
5956: LD_INT 113
5958: PUSH
5959: LD_INT 97
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: PUSH
5966: EMPTY
5967: LIST
5968: LIST
5969: LIST
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: ST_TO_ADDR
// for i in cameras do
5978: LD_ADDR_VAR 0 2
5982: PUSH
5983: LD_VAR 0 7
5987: PUSH
5988: FOR_IN
5989: IFFALSE 6020
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
5991: LD_VAR 0 2
5995: PUSH
5996: LD_INT 1
5998: ARRAY
5999: PPUSH
6000: LD_VAR 0 2
6004: PUSH
6005: LD_INT 2
6007: ARRAY
6008: PPUSH
6009: LD_VAR 0 8
6013: PPUSH
6014: CALL_OW 244
6018: GO 5988
6020: POP
6021: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6022: LD_ADDR_VAR 0 5
6026: PUSH
6027: LD_INT 1
6029: PUSH
6030: LD_INT 144
6032: PUSH
6033: LD_INT 110
6035: PUSH
6036: LD_INT 1
6038: PUSH
6039: LD_INT 0
6041: PUSH
6042: LD_INT 0
6044: PUSH
6045: EMPTY
6046: LIST
6047: LIST
6048: LIST
6049: LIST
6050: LIST
6051: LIST
6052: PUSH
6053: LD_INT 3
6055: PUSH
6056: LD_INT 151
6058: PUSH
6059: LD_INT 118
6061: PUSH
6062: LD_INT 0
6064: PUSH
6065: LD_INT 0
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 8
6081: PUSH
6082: LD_INT 158
6084: PUSH
6085: LD_INT 110
6087: PUSH
6088: LD_INT 4
6090: PUSH
6091: LD_INT 10
6093: PUSH
6094: LD_INT 15
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: PUSH
6105: LD_INT 23
6107: PUSH
6108: LD_INT 154
6110: PUSH
6111: LD_INT 121
6113: PUSH
6114: LD_INT 5
6116: PUSH
6117: LD_INT 0
6119: PUSH
6120: LD_INT 0
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: LIST
6127: LIST
6128: LIST
6129: LIST
6130: PUSH
6131: LD_INT 22
6133: PUSH
6134: LD_INT 155
6136: PUSH
6137: LD_INT 118
6139: PUSH
6140: LD_INT 4
6142: PUSH
6143: LD_INT 0
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: LIST
6156: PUSH
6157: LD_INT 21
6159: PUSH
6160: LD_INT 151
6162: PUSH
6163: LD_INT 122
6165: PUSH
6166: LD_INT 0
6168: PUSH
6169: LD_INT 0
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: LIST
6182: PUSH
6183: LD_INT 18
6185: PUSH
6186: LD_INT 148
6188: PUSH
6189: LD_INT 118
6191: PUSH
6192: LD_INT 1
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: LD_INT 0
6200: PUSH
6201: EMPTY
6202: LIST
6203: LIST
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 17
6211: PUSH
6212: LD_INT 147
6214: PUSH
6215: LD_INT 114
6217: PUSH
6218: LD_INT 2
6220: PUSH
6221: LD_INT 0
6223: PUSH
6224: LD_INT 0
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 29
6237: PUSH
6238: LD_INT 163
6240: PUSH
6241: LD_INT 120
6243: PUSH
6244: LD_INT 5
6246: PUSH
6247: LD_INT 0
6249: PUSH
6250: LD_INT 0
6252: PUSH
6253: EMPTY
6254: LIST
6255: LIST
6256: LIST
6257: LIST
6258: LIST
6259: LIST
6260: PUSH
6261: LD_INT 27
6263: PUSH
6264: LD_INT 137
6266: PUSH
6267: LD_INT 116
6269: PUSH
6270: LD_INT 3
6272: PUSH
6273: LD_INT 0
6275: PUSH
6276: LD_INT 0
6278: PUSH
6279: EMPTY
6280: LIST
6281: LIST
6282: LIST
6283: LIST
6284: LIST
6285: LIST
6286: PUSH
6287: LD_INT 27
6289: PUSH
6290: LD_INT 133
6292: PUSH
6293: LD_INT 111
6295: PUSH
6296: LD_INT 1
6298: PUSH
6299: LD_INT 0
6301: PUSH
6302: LD_INT 0
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: LIST
6312: PUSH
6313: LD_INT 27
6315: PUSH
6316: LD_INT 132
6318: PUSH
6319: LD_INT 106
6321: PUSH
6322: LD_INT 4
6324: PUSH
6325: LD_INT 0
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: LD_INT 26
6341: PUSH
6342: LD_INT 137
6344: PUSH
6345: LD_INT 111
6347: PUSH
6348: LD_INT 0
6350: PUSH
6351: LD_INT 0
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: LD_INT 8
6367: PUSH
6368: LD_INT 141
6370: PUSH
6371: LD_INT 117
6373: PUSH
6374: LD_INT 1
6376: PUSH
6377: LD_INT 13
6379: PUSH
6380: LD_INT 11
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_INT 30
6393: PUSH
6394: LD_INT 140
6396: PUSH
6397: LD_INT 128
6399: PUSH
6400: LD_INT 1
6402: PUSH
6403: LD_INT 0
6405: PUSH
6406: LD_INT 0
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: PUSH
6417: LD_INT 5
6419: PUSH
6420: LD_INT 146
6422: PUSH
6423: LD_INT 96
6425: PUSH
6426: LD_INT 3
6428: PUSH
6429: LD_INT 0
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: EMPTY
6436: LIST
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: PUSH
6443: LD_INT 32
6445: PUSH
6446: LD_INT 150
6448: PUSH
6449: LD_INT 98
6451: PUSH
6452: LD_INT 3
6454: PUSH
6455: LD_INT 0
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: LIST
6467: LIST
6468: PUSH
6469: LD_INT 32
6471: PUSH
6472: LD_INT 142
6474: PUSH
6475: LD_INT 95
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 0
6483: PUSH
6484: LD_INT 0
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: LIST
6494: PUSH
6495: LD_INT 32
6497: PUSH
6498: LD_INT 159
6500: PUSH
6501: LD_INT 104
6503: PUSH
6504: LD_INT 3
6506: PUSH
6507: LD_INT 0
6509: PUSH
6510: LD_INT 0
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: LIST
6517: LIST
6518: LIST
6519: LIST
6520: PUSH
6521: LD_INT 32
6523: PUSH
6524: LD_INT 133
6526: PUSH
6527: LD_INT 95
6529: PUSH
6530: LD_INT 3
6532: PUSH
6533: LD_INT 0
6535: PUSH
6536: LD_INT 0
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: LIST
6543: LIST
6544: LIST
6545: LIST
6546: PUSH
6547: LD_INT 32
6549: PUSH
6550: LD_INT 131
6552: PUSH
6553: LD_INT 102
6555: PUSH
6556: LD_INT 2
6558: PUSH
6559: LD_INT 0
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: LIST
6569: LIST
6570: LIST
6571: LIST
6572: PUSH
6573: LD_INT 32
6575: PUSH
6576: LD_INT 164
6578: PUSH
6579: LD_INT 144
6581: PUSH
6582: LD_INT 0
6584: PUSH
6585: LD_INT 0
6587: PUSH
6588: LD_INT 0
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: LIST
6595: LIST
6596: LIST
6597: LIST
6598: PUSH
6599: LD_INT 32
6601: PUSH
6602: LD_INT 146
6604: PUSH
6605: LD_INT 139
6607: PUSH
6608: LD_INT 0
6610: PUSH
6611: LD_INT 0
6613: PUSH
6614: LD_INT 0
6616: PUSH
6617: EMPTY
6618: LIST
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: LIST
6624: PUSH
6625: LD_INT 26
6627: PUSH
6628: LD_INT 143
6630: PUSH
6631: LD_INT 122
6633: PUSH
6634: LD_INT 4
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: LD_INT 0
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 26
6653: PUSH
6654: LD_INT 164
6656: PUSH
6657: LD_INT 116
6659: PUSH
6660: LD_INT 2
6662: PUSH
6663: LD_INT 0
6665: PUSH
6666: LD_INT 0
6668: PUSH
6669: EMPTY
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: LIST
6690: LIST
6691: LIST
6692: LIST
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: ST_TO_ADDR
// for i in tmp do
6704: LD_ADDR_VAR 0 2
6708: PUSH
6709: LD_VAR 0 5
6713: PUSH
6714: FOR_IN
6715: IFFALSE 6946
// begin uc_side := side ;
6717: LD_ADDR_OWVAR 20
6721: PUSH
6722: LD_VAR 0 8
6726: ST_TO_ADDR
// uc_nation := nation_arabian ;
6727: LD_ADDR_OWVAR 21
6731: PUSH
6732: LD_INT 2
6734: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6735: LD_ADDR_OWVAR 42
6739: PUSH
6740: LD_VAR 0 2
6744: PUSH
6745: LD_INT 1
6747: ARRAY
6748: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6749: LD_ADDR_OWVAR 43
6753: PUSH
6754: LD_INT 5
6756: PPUSH
6757: LD_INT 6
6759: PPUSH
6760: CALL_OW 12
6764: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6765: LD_ADDR_OWVAR 44
6769: PUSH
6770: LD_VAR 0 2
6774: PUSH
6775: LD_INT 5
6777: ARRAY
6778: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6779: LD_ADDR_OWVAR 45
6783: PUSH
6784: LD_VAR 0 2
6788: PUSH
6789: LD_INT 6
6791: ARRAY
6792: ST_TO_ADDR
// sr := 0 ;
6793: LD_ADDR_VAR 0 9
6797: PUSH
6798: LD_INT 0
6800: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6801: LD_VAR 0 2
6805: PUSH
6806: LD_INT 1
6808: ARRAY
6809: PUSH
6810: LD_INT 29
6812: EQUAL
6813: IFFALSE 6825
// sr := mat_oil else
6815: LD_ADDR_VAR 0 9
6819: PUSH
6820: LD_INT 2
6822: ST_TO_ADDR
6823: GO 6847
// if i [ 1 ] = b_siberite_mine then
6825: LD_VAR 0 2
6829: PUSH
6830: LD_INT 1
6832: ARRAY
6833: PUSH
6834: LD_INT 30
6836: EQUAL
6837: IFFALSE 6847
// sr := mat_siberit ;
6839: LD_ADDR_VAR 0 9
6843: PUSH
6844: LD_INT 3
6846: ST_TO_ADDR
// if sr then
6847: LD_VAR 0 9
6851: IFFALSE 6907
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6853: LD_VAR 0 2
6857: PUSH
6858: LD_INT 2
6860: ARRAY
6861: PPUSH
6862: LD_VAR 0 2
6866: PUSH
6867: LD_INT 3
6869: ARRAY
6870: PPUSH
6871: LD_VAR 0 9
6875: PPUSH
6876: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6880: LD_VAR 0 2
6884: PUSH
6885: LD_INT 2
6887: ARRAY
6888: PPUSH
6889: LD_VAR 0 2
6893: PUSH
6894: LD_INT 3
6896: ARRAY
6897: PPUSH
6898: LD_VAR 0 8
6902: PPUSH
6903: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6907: LD_ADDR_VAR 0 3
6911: PUSH
6912: LD_VAR 0 2
6916: PUSH
6917: LD_INT 2
6919: ARRAY
6920: PPUSH
6921: LD_VAR 0 2
6925: PUSH
6926: LD_INT 3
6928: ARRAY
6929: PPUSH
6930: LD_VAR 0 2
6934: PUSH
6935: LD_INT 4
6937: ARRAY
6938: PPUSH
6939: CALL_OW 47
6943: ST_TO_ADDR
// end ;
6944: GO 6714
6946: POP
6947: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6948: LD_ADDR_VAR 0 10
6952: PUSH
6953: LD_INT 22
6955: PUSH
6956: LD_VAR 0 8
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: PUSH
6965: LD_INT 30
6967: PUSH
6968: LD_INT 1
6970: PUSH
6971: EMPTY
6972: LIST
6973: LIST
6974: PUSH
6975: EMPTY
6976: LIST
6977: LIST
6978: PPUSH
6979: CALL_OW 69
6983: ST_TO_ADDR
// if not depot then
6984: LD_VAR 0 10
6988: NOT
6989: IFFALSE 6993
// exit ;
6991: GO 7239
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
6993: LD_ADDR_VAR 0 11
6997: PUSH
6998: LD_VAR 0 10
7002: PUSH
7003: LD_INT 1
7005: ARRAY
7006: PPUSH
7007: LD_INT 6
7009: PPUSH
7010: LD_INT 0
7012: PPUSH
7013: LD_INT 7
7015: PUSH
7016: LD_INT 8
7018: PUSH
7019: LD_INT 10
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: LIST
7026: PUSH
7027: LD_OWVAR 67
7031: ARRAY
7032: PPUSH
7033: LD_INT 3000
7035: PUSH
7036: LD_INT 300
7038: PUSH
7039: LD_INT 100
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: LIST
7046: PPUSH
7047: LD_INT 14
7049: PUSH
7050: LD_INT 6
7052: PUSH
7053: LD_INT 6
7055: PUSH
7056: LD_INT 5
7058: PUSH
7059: EMPTY
7060: LIST
7061: LIST
7062: LIST
7063: LIST
7064: PPUSH
7065: CALL 28778 0 6
7069: ST_TO_ADDR
// if not base then
7070: LD_VAR 0 11
7074: NOT
7075: IFFALSE 7079
// exit ;
7077: GO 7239
// if Difficulty > 1 then
7079: LD_OWVAR 67
7083: PUSH
7084: LD_INT 1
7086: GREATER
7087: IFFALSE 7160
// begin InitHc ;
7089: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7093: LD_INT 1
7095: PPUSH
7096: LD_INT 5
7098: PPUSH
7099: LD_INT 5
7101: PUSH
7102: LD_INT 8
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: PUSH
7109: LD_OWVAR 67
7113: PUSH
7114: LD_INT 1
7116: MINUS
7117: ARRAY
7118: PPUSH
7119: CALL_OW 380
// for i = 1 to Difficulty do
7123: LD_ADDR_VAR 0 2
7127: PUSH
7128: DOUBLE
7129: LD_INT 1
7131: DEC
7132: ST_TO_ADDR
7133: LD_OWVAR 67
7137: PUSH
7138: FOR_TO
7139: IFFALSE 7158
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7141: CALL_OW 44
7145: PPUSH
7146: LD_INT 24
7148: PPUSH
7149: LD_INT 0
7151: PPUSH
7152: CALL_OW 49
7156: GO 7138
7158: POP
7159: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7160: LD_ADDR_EXP 31
7164: PUSH
7165: LD_EXP 31
7169: PPUSH
7170: LD_EXP 6
7174: PPUSH
7175: LD_VAR 0 11
7179: PPUSH
7180: CALL_OW 1
7184: ST_TO_ADDR
// hc_gallery := ru ;
7185: LD_ADDR_OWVAR 33
7189: PUSH
7190: LD_STRING ru
7192: ST_TO_ADDR
// hc_face_number := 44 ;
7193: LD_ADDR_OWVAR 34
7197: PUSH
7198: LD_INT 44
7200: ST_TO_ADDR
// hc_name := Robert Farmer ;
7201: LD_ADDR_OWVAR 26
7205: PUSH
7206: LD_STRING Robert Farmer
7208: ST_TO_ADDR
// hc_sex := sex_male ;
7209: LD_ADDR_OWVAR 27
7213: PUSH
7214: LD_INT 1
7216: ST_TO_ADDR
// hc_class := 1 ;
7217: LD_ADDR_OWVAR 28
7221: PUSH
7222: LD_INT 1
7224: ST_TO_ADDR
// Farmer := CreateHuman ;
7225: LD_ADDR_EXP 13
7229: PUSH
7230: CALL_OW 44
7234: ST_TO_ADDR
// InitHc ;
7235: CALL_OW 19
// end ;
7239: LD_VAR 0 1
7243: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7244: LD_INT 0
7246: PPUSH
7247: PPUSH
7248: PPUSH
7249: PPUSH
// tmp := [ ] ;
7250: LD_ADDR_VAR 0 3
7254: PUSH
7255: EMPTY
7256: ST_TO_ADDR
// for i := 1 to 3 do
7257: LD_ADDR_VAR 0 2
7261: PUSH
7262: DOUBLE
7263: LD_INT 1
7265: DEC
7266: ST_TO_ADDR
7267: LD_INT 3
7269: PUSH
7270: FOR_TO
7271: IFFALSE 7383
// begin uc_side := 3 ;
7273: LD_ADDR_OWVAR 20
7277: PUSH
7278: LD_INT 3
7280: ST_TO_ADDR
// uc_nation := 3 ;
7281: LD_ADDR_OWVAR 21
7285: PUSH
7286: LD_INT 3
7288: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7289: LD_ADDR_OWVAR 37
7293: PUSH
7294: LD_INT 22
7296: ST_TO_ADDR
// vc_engine := engine_siberite ;
7297: LD_ADDR_OWVAR 39
7301: PUSH
7302: LD_INT 3
7304: ST_TO_ADDR
// vc_control := control_computer ;
7305: LD_ADDR_OWVAR 38
7309: PUSH
7310: LD_INT 3
7312: ST_TO_ADDR
// vc_weapon := ru_crane ;
7313: LD_ADDR_OWVAR 40
7317: PUSH
7318: LD_INT 52
7320: ST_TO_ADDR
// veh := CreateVehicle ;
7321: LD_ADDR_VAR 0 4
7325: PUSH
7326: CALL_OW 45
7330: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7331: LD_VAR 0 4
7335: PPUSH
7336: LD_INT 73
7338: PPUSH
7339: LD_INT 122
7341: PPUSH
7342: LD_INT 3
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7352: LD_ADDR_VAR 0 3
7356: PUSH
7357: LD_VAR 0 3
7361: PPUSH
7362: LD_VAR 0 3
7366: PUSH
7367: LD_INT 1
7369: PLUS
7370: PPUSH
7371: LD_VAR 0 4
7375: PPUSH
7376: CALL_OW 1
7380: ST_TO_ADDR
// end ;
7381: GO 7270
7383: POP
7384: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7385: LD_ADDR_EXP 50
7389: PUSH
7390: LD_EXP 50
7394: PPUSH
7395: LD_EXP 7
7399: PPUSH
7400: LD_VAR 0 3
7404: PPUSH
7405: CALL_OW 1
7409: ST_TO_ADDR
// tmp := [ ] ;
7410: LD_ADDR_VAR 0 3
7414: PUSH
7415: EMPTY
7416: ST_TO_ADDR
// for i := 1 to 3 do
7417: LD_ADDR_VAR 0 2
7421: PUSH
7422: DOUBLE
7423: LD_INT 1
7425: DEC
7426: ST_TO_ADDR
7427: LD_INT 3
7429: PUSH
7430: FOR_TO
7431: IFFALSE 7543
// begin uc_side := 3 ;
7433: LD_ADDR_OWVAR 20
7437: PUSH
7438: LD_INT 3
7440: ST_TO_ADDR
// uc_nation := 3 ;
7441: LD_ADDR_OWVAR 21
7445: PUSH
7446: LD_INT 3
7448: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7449: LD_ADDR_OWVAR 37
7453: PUSH
7454: LD_INT 22
7456: ST_TO_ADDR
// vc_engine := engine_siberite ;
7457: LD_ADDR_OWVAR 39
7461: PUSH
7462: LD_INT 3
7464: ST_TO_ADDR
// vc_control := control_computer ;
7465: LD_ADDR_OWVAR 38
7469: PUSH
7470: LD_INT 3
7472: ST_TO_ADDR
// vc_weapon := ru_crane ;
7473: LD_ADDR_OWVAR 40
7477: PUSH
7478: LD_INT 52
7480: ST_TO_ADDR
// veh := CreateVehicle ;
7481: LD_ADDR_VAR 0 4
7485: PUSH
7486: CALL_OW 45
7490: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7491: LD_VAR 0 4
7495: PPUSH
7496: LD_INT 22
7498: PPUSH
7499: LD_INT 28
7501: PPUSH
7502: LD_INT 3
7504: PPUSH
7505: LD_INT 0
7507: PPUSH
7508: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7512: LD_ADDR_VAR 0 3
7516: PUSH
7517: LD_VAR 0 3
7521: PPUSH
7522: LD_VAR 0 3
7526: PUSH
7527: LD_INT 1
7529: PLUS
7530: PPUSH
7531: LD_VAR 0 4
7535: PPUSH
7536: CALL_OW 1
7540: ST_TO_ADDR
// end ;
7541: GO 7430
7543: POP
7544: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7545: LD_ADDR_EXP 50
7549: PUSH
7550: LD_EXP 50
7554: PPUSH
7555: LD_EXP 8
7559: PPUSH
7560: LD_VAR 0 3
7564: PPUSH
7565: CALL_OW 1
7569: ST_TO_ADDR
// end ;
7570: LD_VAR 0 1
7574: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7575: LD_INT 0
7577: PPUSH
7578: PPUSH
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
7584: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7585: LD_INT 0
7587: PPUSH
7588: LD_INT 0
7590: PPUSH
7591: LD_INT 4
7593: PPUSH
7594: LD_INT 0
7596: PPUSH
7597: LD_INT 0
7599: PPUSH
7600: LD_INT 0
7602: PPUSH
7603: LD_INT 0
7605: PPUSH
7606: LD_INT 10
7608: PPUSH
7609: LD_INT 0
7611: PPUSH
7612: CALL 54762 0 9
// side := 4 ;
7616: LD_ADDR_VAR 0 5
7620: PUSH
7621: LD_INT 4
7623: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7624: LD_ADDR_VAR 0 4
7628: PUSH
7629: LD_INT 1
7631: PUSH
7632: LD_INT 144
7634: PUSH
7635: LD_INT 18
7637: PUSH
7638: LD_INT 4
7640: PUSH
7641: LD_INT 0
7643: PUSH
7644: LD_INT 0
7646: PUSH
7647: EMPTY
7648: LIST
7649: LIST
7650: LIST
7651: LIST
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 3
7657: PUSH
7658: LD_INT 137
7660: PUSH
7661: LD_INT 8
7663: PUSH
7664: LD_INT 4
7666: PUSH
7667: LD_INT 0
7669: PUSH
7670: LD_INT 0
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: LIST
7680: PUSH
7681: LD_INT 22
7683: PUSH
7684: LD_INT 141
7686: PUSH
7687: LD_INT 8
7689: PUSH
7690: LD_INT 4
7692: PUSH
7693: LD_INT 0
7695: PUSH
7696: LD_INT 0
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 25
7709: PUSH
7710: LD_INT 137
7712: PUSH
7713: LD_INT 5
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: LD_INT 0
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: EMPTY
7726: LIST
7727: LIST
7728: LIST
7729: LIST
7730: LIST
7731: LIST
7732: PUSH
7733: LD_INT 18
7735: PUSH
7736: LD_INT 137
7738: PUSH
7739: LD_INT 12
7741: PUSH
7742: LD_INT 0
7744: PUSH
7745: LD_INT 0
7747: PUSH
7748: LD_INT 0
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 17
7761: PUSH
7762: LD_INT 133
7764: PUSH
7765: LD_INT 4
7767: PUSH
7768: LD_INT 2
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: LD_INT 0
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: LIST
7782: LIST
7783: LIST
7784: PUSH
7785: LD_INT 16
7787: PUSH
7788: LD_INT 140
7790: PUSH
7791: LD_INT 11
7793: PUSH
7794: LD_INT 5
7796: PUSH
7797: LD_INT 0
7799: PUSH
7800: LD_INT 0
7802: PUSH
7803: EMPTY
7804: LIST
7805: LIST
7806: LIST
7807: LIST
7808: LIST
7809: LIST
7810: PUSH
7811: LD_INT 8
7813: PUSH
7814: LD_INT 149
7816: PUSH
7817: LD_INT 26
7819: PUSH
7820: LD_INT 4
7822: PUSH
7823: LD_INT 10
7825: PUSH
7826: LD_INT 15
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: LIST
7836: PUSH
7837: LD_INT 8
7839: PUSH
7840: LD_INT 142
7842: PUSH
7843: LD_INT 26
7845: PUSH
7846: LD_INT 1
7848: PUSH
7849: LD_INT 11
7851: PUSH
7852: LD_INT 12
7854: PUSH
7855: EMPTY
7856: LIST
7857: LIST
7858: LIST
7859: LIST
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 27
7865: PUSH
7866: LD_INT 153
7868: PUSH
7869: LD_INT 32
7871: PUSH
7872: LD_INT 5
7874: PUSH
7875: LD_INT 0
7877: PUSH
7878: LD_INT 0
7880: PUSH
7881: EMPTY
7882: LIST
7883: LIST
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: PUSH
7889: LD_INT 27
7891: PUSH
7892: LD_INT 145
7894: PUSH
7895: LD_INT 32
7897: PUSH
7898: LD_INT 3
7900: PUSH
7901: LD_INT 0
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: EMPTY
7908: LIST
7909: LIST
7910: LIST
7911: LIST
7912: LIST
7913: LIST
7914: PUSH
7915: LD_INT 27
7917: PUSH
7918: LD_INT 138
7920: PUSH
7921: LD_INT 2
7923: PUSH
7924: LD_INT 4
7926: PUSH
7927: LD_INT 0
7929: PUSH
7930: LD_INT 0
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: LIST
7939: LIST
7940: PUSH
7941: LD_INT 27
7943: PUSH
7944: LD_INT 144
7946: PUSH
7947: LD_INT 13
7949: PUSH
7950: LD_INT 0
7952: PUSH
7953: LD_INT 0
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: LIST
7963: LIST
7964: LIST
7965: LIST
7966: PUSH
7967: LD_INT 26
7969: PUSH
7970: LD_INT 124
7972: PUSH
7973: LD_INT 2
7975: PUSH
7976: LD_INT 4
7978: PUSH
7979: LD_INT 0
7981: PUSH
7982: LD_INT 0
7984: PUSH
7985: EMPTY
7986: LIST
7987: LIST
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 26
7995: PUSH
7996: LD_INT 121
7998: PUSH
7999: LD_INT 2
8001: PUSH
8002: LD_INT 2
8004: PUSH
8005: LD_INT 0
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: LIST
8015: LIST
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 26
8021: PUSH
8022: LD_INT 118
8024: PUSH
8025: LD_INT 2
8027: PUSH
8028: LD_INT 1
8030: PUSH
8031: LD_INT 0
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 29
8047: PUSH
8048: LD_INT 159
8050: PUSH
8051: LD_INT 47
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: LD_INT 0
8059: PUSH
8060: LD_INT 0
8062: PUSH
8063: EMPTY
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: LIST
8069: LIST
8070: PUSH
8071: LD_INT 32
8073: PUSH
8074: LD_INT 146
8076: PUSH
8077: LD_INT 41
8079: PUSH
8080: LD_INT 0
8082: PUSH
8083: LD_INT 0
8085: PUSH
8086: LD_INT 0
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: LIST
8093: LIST
8094: LIST
8095: LIST
8096: PUSH
8097: LD_INT 33
8099: PUSH
8100: LD_INT 136
8102: PUSH
8103: LD_INT 37
8105: PUSH
8106: LD_INT 0
8108: PUSH
8109: LD_INT 0
8111: PUSH
8112: LD_INT 0
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: LIST
8120: LIST
8121: LIST
8122: PUSH
8123: LD_INT 33
8125: PUSH
8126: LD_INT 132
8128: PUSH
8129: LD_INT 34
8131: PUSH
8132: LD_INT 0
8134: PUSH
8135: LD_INT 0
8137: PUSH
8138: LD_INT 0
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 36
8151: PUSH
8152: LD_INT 124
8154: PUSH
8155: LD_INT 7
8157: PUSH
8158: LD_INT 1
8160: PUSH
8161: LD_INT 0
8163: PUSH
8164: LD_INT 0
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: LIST
8171: LIST
8172: LIST
8173: LIST
8174: PUSH
8175: LD_INT 5
8177: PUSH
8178: LD_INT 124
8180: PUSH
8181: LD_INT 19
8183: PUSH
8184: LD_INT 0
8186: PUSH
8187: LD_INT 0
8189: PUSH
8190: LD_INT 0
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: LIST
8197: LIST
8198: LIST
8199: LIST
8200: PUSH
8201: LD_INT 32
8203: PUSH
8204: LD_INT 127
8206: PUSH
8207: LD_INT 23
8209: PUSH
8210: LD_INT 0
8212: PUSH
8213: LD_INT 0
8215: PUSH
8216: LD_INT 0
8218: PUSH
8219: EMPTY
8220: LIST
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: LIST
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: LIST
8234: LIST
8235: LIST
8236: LIST
8237: LIST
8238: LIST
8239: LIST
8240: LIST
8241: LIST
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: ST_TO_ADDR
// for i in tmp do
8252: LD_ADDR_VAR 0 2
8256: PUSH
8257: LD_VAR 0 4
8261: PUSH
8262: FOR_IN
8263: IFFALSE 8494
// begin uc_side := side ;
8265: LD_ADDR_OWVAR 20
8269: PUSH
8270: LD_VAR 0 5
8274: ST_TO_ADDR
// uc_nation := nation_american ;
8275: LD_ADDR_OWVAR 21
8279: PUSH
8280: LD_INT 1
8282: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8283: LD_ADDR_OWVAR 42
8287: PUSH
8288: LD_VAR 0 2
8292: PUSH
8293: LD_INT 1
8295: ARRAY
8296: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8297: LD_ADDR_OWVAR 43
8301: PUSH
8302: LD_INT 5
8304: PPUSH
8305: LD_INT 6
8307: PPUSH
8308: CALL_OW 12
8312: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8313: LD_ADDR_OWVAR 44
8317: PUSH
8318: LD_VAR 0 2
8322: PUSH
8323: LD_INT 5
8325: ARRAY
8326: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8327: LD_ADDR_OWVAR 45
8331: PUSH
8332: LD_VAR 0 2
8336: PUSH
8337: LD_INT 6
8339: ARRAY
8340: ST_TO_ADDR
// sr := 0 ;
8341: LD_ADDR_VAR 0 6
8345: PUSH
8346: LD_INT 0
8348: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8349: LD_VAR 0 2
8353: PUSH
8354: LD_INT 1
8356: ARRAY
8357: PUSH
8358: LD_INT 29
8360: EQUAL
8361: IFFALSE 8373
// sr := mat_oil else
8363: LD_ADDR_VAR 0 6
8367: PUSH
8368: LD_INT 2
8370: ST_TO_ADDR
8371: GO 8395
// if i [ 1 ] = b_siberite_mine then
8373: LD_VAR 0 2
8377: PUSH
8378: LD_INT 1
8380: ARRAY
8381: PUSH
8382: LD_INT 30
8384: EQUAL
8385: IFFALSE 8395
// sr := mat_siberit ;
8387: LD_ADDR_VAR 0 6
8391: PUSH
8392: LD_INT 3
8394: ST_TO_ADDR
// if sr then
8395: LD_VAR 0 6
8399: IFFALSE 8455
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8401: LD_VAR 0 2
8405: PUSH
8406: LD_INT 2
8408: ARRAY
8409: PPUSH
8410: LD_VAR 0 2
8414: PUSH
8415: LD_INT 3
8417: ARRAY
8418: PPUSH
8419: LD_VAR 0 6
8423: PPUSH
8424: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8428: LD_VAR 0 2
8432: PUSH
8433: LD_INT 2
8435: ARRAY
8436: PPUSH
8437: LD_VAR 0 2
8441: PUSH
8442: LD_INT 3
8444: ARRAY
8445: PPUSH
8446: LD_VAR 0 5
8450: PPUSH
8451: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8455: LD_ADDR_VAR 0 3
8459: PUSH
8460: LD_VAR 0 2
8464: PUSH
8465: LD_INT 2
8467: ARRAY
8468: PPUSH
8469: LD_VAR 0 2
8473: PUSH
8474: LD_INT 3
8476: ARRAY
8477: PPUSH
8478: LD_VAR 0 2
8482: PUSH
8483: LD_INT 4
8485: ARRAY
8486: PPUSH
8487: CALL_OW 47
8491: ST_TO_ADDR
// end ;
8492: GO 8262
8494: POP
8495: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8496: LD_ADDR_VAR 0 8
8500: PUSH
8501: LD_INT 22
8503: PUSH
8504: LD_VAR 0 5
8508: PUSH
8509: EMPTY
8510: LIST
8511: LIST
8512: PUSH
8513: LD_INT 30
8515: PUSH
8516: LD_INT 1
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PUSH
8523: EMPTY
8524: LIST
8525: LIST
8526: PPUSH
8527: CALL_OW 69
8531: ST_TO_ADDR
// if not depot then
8532: LD_VAR 0 8
8536: NOT
8537: IFFALSE 8541
// exit ;
8539: GO 8813
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8541: LD_ADDR_VAR 0 7
8545: PUSH
8546: LD_VAR 0 8
8550: PUSH
8551: LD_INT 1
8553: ARRAY
8554: PPUSH
8555: LD_INT 3
8557: PPUSH
8558: LD_STRING theta3
8560: PPUSH
8561: LD_INT 8
8563: PUSH
8564: LD_INT 7
8566: PUSH
8567: LD_INT 6
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: LIST
8574: PUSH
8575: LD_OWVAR 67
8579: ARRAY
8580: PPUSH
8581: LD_INT 2500
8583: PUSH
8584: LD_INT 2000
8586: PUSH
8587: LD_INT 1750
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: LIST
8594: PUSH
8595: LD_OWVAR 67
8599: ARRAY
8600: PUSH
8601: LD_INT 300
8603: PUSH
8604: LD_INT 250
8606: PUSH
8607: LD_INT 200
8609: PUSH
8610: EMPTY
8611: LIST
8612: LIST
8613: LIST
8614: PUSH
8615: LD_OWVAR 67
8619: ARRAY
8620: PUSH
8621: LD_INT 80
8623: PUSH
8624: LD_INT 60
8626: PUSH
8627: LD_INT 50
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: PUSH
8635: LD_OWVAR 67
8639: ARRAY
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: LIST
8645: PPUSH
8646: LD_INT 7
8648: PUSH
8649: LD_INT 6
8651: PUSH
8652: LD_INT 5
8654: PUSH
8655: LD_INT 5
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: LIST
8662: LIST
8663: PPUSH
8664: CALL 28778 0 6
8668: ST_TO_ADDR
// if not base then
8669: LD_VAR 0 7
8673: NOT
8674: IFFALSE 8678
// exit ;
8676: GO 8813
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8678: LD_ADDR_EXP 31
8682: PUSH
8683: LD_EXP 31
8687: PPUSH
8688: LD_EXP 5
8692: PPUSH
8693: LD_VAR 0 7
8697: PPUSH
8698: CALL_OW 1
8702: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8703: LD_INT 1
8705: PPUSH
8706: LD_INT 1
8708: PPUSH
8709: LD_INT 7
8711: PPUSH
8712: CALL_OW 380
// allyCommander := CreateHuman ;
8716: LD_ADDR_EXP 11
8720: PUSH
8721: CALL_OW 44
8725: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8726: LD_EXP 11
8730: PPUSH
8731: LD_INT 139
8733: PPUSH
8734: LD_INT 15
8736: PPUSH
8737: LD_INT 0
8739: PPUSH
8740: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8744: LD_EXP 11
8748: PPUSH
8749: LD_INT 137
8751: PPUSH
8752: LD_INT 15
8754: PPUSH
8755: CALL_OW 118
// hc_gallery := us ;
8759: LD_ADDR_OWVAR 33
8763: PUSH
8764: LD_STRING us
8766: ST_TO_ADDR
// hc_face_number := 7 ;
8767: LD_ADDR_OWVAR 34
8771: PUSH
8772: LD_INT 7
8774: ST_TO_ADDR
// hc_name := Arthur Powell ;
8775: LD_ADDR_OWVAR 26
8779: PUSH
8780: LD_STRING Arthur Powell
8782: ST_TO_ADDR
// hc_sex := sex_male ;
8783: LD_ADDR_OWVAR 27
8787: PUSH
8788: LD_INT 1
8790: ST_TO_ADDR
// hc_class := 1 ;
8791: LD_ADDR_OWVAR 28
8795: PUSH
8796: LD_INT 1
8798: ST_TO_ADDR
// Powell := CreateHuman ;
8799: LD_ADDR_EXP 12
8803: PUSH
8804: CALL_OW 44
8808: ST_TO_ADDR
// InitHc ;
8809: CALL_OW 19
// end ;
8813: LD_VAR 0 1
8817: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8818: LD_INT 0
8820: PPUSH
8821: PPUSH
8822: PPUSH
8823: PPUSH
8824: PPUSH
8825: PPUSH
8826: PPUSH
8827: PPUSH
8828: PPUSH
// side := 1 ;
8829: LD_ADDR_VAR 0 3
8833: PUSH
8834: LD_INT 1
8836: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8837: LD_ADDR_VAR 0 1
8841: PUSH
8842: EMPTY
8843: PUSH
8844: EMPTY
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// uc_side := side ;
8850: LD_ADDR_OWVAR 20
8854: PUSH
8855: LD_VAR 0 3
8859: ST_TO_ADDR
// uc_nation := nation_american ;
8860: LD_ADDR_OWVAR 21
8864: PUSH
8865: LD_INT 1
8867: ST_TO_ADDR
// InitHc ;
8868: CALL_OW 19
// InitVc ;
8872: CALL_OW 20
// hc_importance := 0 ;
8876: LD_ADDR_OWVAR 32
8880: PUSH
8881: LD_INT 0
8883: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8884: LD_ADDR_VAR 0 7
8888: PUSH
8889: LD_INT 2
8891: PUSH
8892: LD_INT 3
8894: PUSH
8895: LD_INT 3
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: LIST
8902: ST_TO_ADDR
// if commander = 2 then
8903: LD_EXP 25
8907: PUSH
8908: LD_INT 2
8910: EQUAL
8911: IFFALSE 8932
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8913: LD_ADDR_VAR 0 7
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: LD_INT 4
8923: PUSH
8924: LD_INT 4
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// if commander = 3 then
8932: LD_EXP 25
8936: PUSH
8937: LD_INT 3
8939: EQUAL
8940: IFFALSE 8961
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8942: LD_ADDR_VAR 0 7
8946: PUSH
8947: LD_INT 2
8949: PUSH
8950: LD_INT 5
8952: PUSH
8953: LD_INT 5
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: LIST
8960: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8961: LD_ADDR_VAR 0 8
8965: PUSH
8966: LD_INT 2
8968: PUSH
8969: LD_INT 2
8971: PUSH
8972: LD_INT 1
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: ST_TO_ADDR
// if commander = 2 then
8980: LD_EXP 25
8984: PUSH
8985: LD_INT 2
8987: EQUAL
8988: IFFALSE 9009
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
8990: LD_ADDR_VAR 0 8
8994: PUSH
8995: LD_INT 1
8997: PUSH
8998: LD_INT 1
9000: PUSH
9001: LD_INT 3
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: LIST
9008: ST_TO_ADDR
// if commander = 3 then
9009: LD_EXP 25
9013: PUSH
9014: LD_INT 3
9016: EQUAL
9017: IFFALSE 9038
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9019: LD_ADDR_VAR 0 8
9023: PUSH
9024: LD_INT 3
9026: PUSH
9027: LD_INT 3
9029: PUSH
9030: LD_INT 1
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9038: LD_ADDR_VAR 0 9
9042: PUSH
9043: LD_INT 5
9045: PUSH
9046: LD_INT 3
9048: PUSH
9049: LD_INT 4
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: ST_TO_ADDR
// if commander = 2 then
9057: LD_EXP 25
9061: PUSH
9062: LD_INT 2
9064: EQUAL
9065: IFFALSE 9086
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9067: LD_ADDR_VAR 0 9
9071: PUSH
9072: LD_INT 7
9074: PUSH
9075: LD_INT 5
9077: PUSH
9078: LD_INT 6
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// if commander = 3 then
9086: LD_EXP 25
9090: PUSH
9091: LD_INT 3
9093: EQUAL
9094: IFFALSE 9115
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9096: LD_ADDR_VAR 0 9
9100: PUSH
9101: LD_INT 9
9103: PUSH
9104: LD_INT 10
9106: PUSH
9107: LD_INT 7
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9115: LD_ADDR_VAR 0 5
9119: PUSH
9120: LD_INT 5
9122: PUSH
9123: LD_INT 5
9125: PUSH
9126: LD_INT 4
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: LIST
9133: PUSH
9134: LD_OWVAR 67
9138: ARRAY
9139: ST_TO_ADDR
// if commander = 2 then
9140: LD_EXP 25
9144: PUSH
9145: LD_INT 2
9147: EQUAL
9148: IFFALSE 9164
// tanks := tanks + 3 ;
9150: LD_ADDR_VAR 0 5
9154: PUSH
9155: LD_VAR 0 5
9159: PUSH
9160: LD_INT 3
9162: PLUS
9163: ST_TO_ADDR
// for i = 1 to tanks do
9164: LD_ADDR_VAR 0 2
9168: PUSH
9169: DOUBLE
9170: LD_INT 1
9172: DEC
9173: ST_TO_ADDR
9174: LD_VAR 0 5
9178: PUSH
9179: FOR_TO
9180: IFFALSE 9290
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9182: LD_VAR 0 7
9186: PUSH
9187: LD_VAR 0 2
9191: PUSH
9192: LD_INT 3
9194: MOD
9195: PUSH
9196: LD_INT 1
9198: PLUS
9199: ARRAY
9200: PPUSH
9201: LD_VAR 0 8
9205: PUSH
9206: LD_INT 1
9208: PPUSH
9209: LD_INT 3
9211: PPUSH
9212: CALL_OW 12
9216: ARRAY
9217: PPUSH
9218: LD_INT 1
9220: PPUSH
9221: LD_VAR 0 9
9225: PUSH
9226: LD_VAR 0 2
9230: PUSH
9231: LD_INT 3
9233: MOD
9234: PUSH
9235: LD_INT 1
9237: PLUS
9238: ARRAY
9239: PPUSH
9240: LD_INT 60
9242: PPUSH
9243: LD_INT 70
9245: PPUSH
9246: CALL_OW 12
9250: PPUSH
9251: CALL 24941 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9255: LD_ADDR_VAR 0 1
9259: PUSH
9260: LD_VAR 0 1
9264: PPUSH
9265: LD_INT 1
9267: PPUSH
9268: LD_VAR 0 1
9272: PUSH
9273: LD_INT 1
9275: ARRAY
9276: PUSH
9277: CALL_OW 45
9281: ADD
9282: PPUSH
9283: CALL_OW 1
9287: ST_TO_ADDR
// end ;
9288: GO 9179
9290: POP
9291: POP
// cl := 1 ;
9292: LD_ADDR_VAR 0 6
9296: PUSH
9297: LD_INT 1
9299: ST_TO_ADDR
// for i = 1 to 10 do
9300: LD_ADDR_VAR 0 2
9304: PUSH
9305: DOUBLE
9306: LD_INT 1
9308: DEC
9309: ST_TO_ADDR
9310: LD_INT 10
9312: PUSH
9313: FOR_TO
9314: IFFALSE 9429
// begin if i mod 4 = 0 then
9316: LD_VAR 0 2
9320: PUSH
9321: LD_INT 4
9323: MOD
9324: PUSH
9325: LD_INT 0
9327: EQUAL
9328: IFFALSE 9344
// cl := cl + 1 ;
9330: LD_ADDR_VAR 0 6
9334: PUSH
9335: LD_VAR 0 6
9339: PUSH
9340: LD_INT 1
9342: PLUS
9343: ST_TO_ADDR
// if cl = 2 then
9344: LD_VAR 0 6
9348: PUSH
9349: LD_INT 2
9351: EQUAL
9352: IFFALSE 9362
// cl := 3 ;
9354: LD_ADDR_VAR 0 6
9358: PUSH
9359: LD_INT 3
9361: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9362: LD_INT 0
9364: PPUSH
9365: LD_VAR 0 6
9369: PPUSH
9370: LD_INT 6
9372: PUSH
9373: LD_INT 6
9375: PUSH
9376: LD_INT 5
9378: PUSH
9379: EMPTY
9380: LIST
9381: LIST
9382: LIST
9383: PUSH
9384: LD_OWVAR 67
9388: ARRAY
9389: PPUSH
9390: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9394: LD_ADDR_VAR 0 1
9398: PUSH
9399: LD_VAR 0 1
9403: PPUSH
9404: LD_INT 2
9406: PPUSH
9407: LD_VAR 0 1
9411: PUSH
9412: LD_INT 2
9414: ARRAY
9415: PUSH
9416: CALL_OW 44
9420: ADD
9421: PPUSH
9422: CALL_OW 1
9426: ST_TO_ADDR
// end ;
9427: GO 9313
9429: POP
9430: POP
// if commander = 1 then
9431: LD_EXP 25
9435: PUSH
9436: LD_INT 1
9438: EQUAL
9439: IFFALSE 9507
// for i = 1 to 4 do
9441: LD_ADDR_VAR 0 2
9445: PUSH
9446: DOUBLE
9447: LD_INT 1
9449: DEC
9450: ST_TO_ADDR
9451: LD_INT 4
9453: PUSH
9454: FOR_TO
9455: IFFALSE 9505
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9457: LD_INT 0
9459: PPUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 8
9465: PPUSH
9466: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9470: LD_ADDR_VAR 0 1
9474: PUSH
9475: LD_VAR 0 1
9479: PPUSH
9480: LD_INT 2
9482: PPUSH
9483: LD_VAR 0 1
9487: PUSH
9488: LD_INT 2
9490: ARRAY
9491: PUSH
9492: CALL_OW 44
9496: ADD
9497: PPUSH
9498: CALL_OW 1
9502: ST_TO_ADDR
// end ;
9503: GO 9454
9505: POP
9506: POP
// techs := [ ] ;
9507: LD_ADDR_VAR 0 4
9511: PUSH
9512: EMPTY
9513: ST_TO_ADDR
// if commander = 1 then
9514: LD_EXP 25
9518: PUSH
9519: LD_INT 1
9521: EQUAL
9522: IFFALSE 9547
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9524: LD_ADDR_VAR 0 4
9528: PUSH
9529: LD_INT 51
9531: PUSH
9532: LD_INT 52
9534: PUSH
9535: LD_INT 53
9537: PUSH
9538: LD_INT 12
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: LIST
9545: LIST
9546: ST_TO_ADDR
// if commander = 2 then
9547: LD_EXP 25
9551: PUSH
9552: LD_INT 2
9554: EQUAL
9555: IFFALSE 9592
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9557: LD_ADDR_VAR 0 4
9561: PUSH
9562: LD_INT 48
9564: PUSH
9565: LD_INT 47
9567: PUSH
9568: LD_INT 46
9570: PUSH
9571: LD_INT 45
9573: PUSH
9574: LD_INT 35
9576: PUSH
9577: LD_INT 60
9579: PUSH
9580: LD_INT 6
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: LIST
9587: LIST
9588: LIST
9589: LIST
9590: LIST
9591: ST_TO_ADDR
// if commander = 3 then
9592: LD_EXP 25
9596: PUSH
9597: LD_INT 3
9599: EQUAL
9600: IFFALSE 9649
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9602: LD_ADDR_VAR 0 4
9606: PUSH
9607: LD_INT 27
9609: PUSH
9610: LD_INT 36
9612: PUSH
9613: LD_INT 32
9615: PUSH
9616: LD_INT 57
9618: PUSH
9619: LD_INT 58
9621: PUSH
9622: LD_INT 47
9624: PUSH
9625: LD_INT 46
9627: PUSH
9628: LD_INT 51
9630: PUSH
9631: LD_INT 69
9633: PUSH
9634: LD_INT 39
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: ST_TO_ADDR
// if techs then
9649: LD_VAR 0 4
9653: IFFALSE 9687
// for i in techs do
9655: LD_ADDR_VAR 0 2
9659: PUSH
9660: LD_VAR 0 4
9664: PUSH
9665: FOR_IN
9666: IFFALSE 9685
// SetTech ( i , 1 , state_researched ) ;
9668: LD_VAR 0 2
9672: PPUSH
9673: LD_INT 1
9675: PPUSH
9676: LD_INT 2
9678: PPUSH
9679: CALL_OW 322
9683: GO 9665
9685: POP
9686: POP
// hc_gallery := skirmish ;
9687: LD_ADDR_OWVAR 33
9691: PUSH
9692: LD_STRING skirmish
9694: ST_TO_ADDR
// hc_face_number := commander ;
9695: LD_ADDR_OWVAR 34
9699: PUSH
9700: LD_EXP 25
9704: ST_TO_ADDR
// hc_importance := 100 ;
9705: LD_ADDR_OWVAR 32
9709: PUSH
9710: LD_INT 100
9712: ST_TO_ADDR
// case commander of 1 :
9713: LD_EXP 25
9717: PUSH
9718: LD_INT 1
9720: DOUBLE
9721: EQUAL
9722: IFTRUE 9726
9724: GO 9750
9726: POP
// begin hc_name := Jeff Ironside ;
9727: LD_ADDR_OWVAR 26
9731: PUSH
9732: LD_STRING Jeff Ironside
9734: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9735: LD_INT 1
9737: PPUSH
9738: LD_INT 1
9740: PPUSH
9741: LD_INT 7
9743: PPUSH
9744: CALL_OW 380
// end ; 2 :
9748: GO 9815
9750: LD_INT 2
9752: DOUBLE
9753: EQUAL
9754: IFTRUE 9758
9756: GO 9782
9758: POP
// begin hc_name := Paul Johnson ;
9759: LD_ADDR_OWVAR 26
9763: PUSH
9764: LD_STRING Paul Johnson
9766: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 3
9772: PPUSH
9773: LD_INT 7
9775: PPUSH
9776: CALL_OW 380
// end ; 3 :
9780: GO 9815
9782: LD_INT 3
9784: DOUBLE
9785: EQUAL
9786: IFTRUE 9790
9788: GO 9814
9790: POP
// begin hc_name := Lisa Stuart ;
9791: LD_ADDR_OWVAR 26
9795: PUSH
9796: LD_STRING Lisa Stuart
9798: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9799: LD_INT 2
9801: PPUSH
9802: LD_INT 4
9804: PPUSH
9805: LD_INT 7
9807: PPUSH
9808: CALL_OW 380
// end ; end ;
9812: GO 9815
9814: POP
// playerCommander := CreateHuman ;
9815: LD_ADDR_EXP 9
9819: PUSH
9820: CALL_OW 44
9824: ST_TO_ADDR
// hc_importance := 0 ;
9825: LD_ADDR_OWVAR 32
9829: PUSH
9830: LD_INT 0
9832: ST_TO_ADDR
// hc_gallery :=  ;
9833: LD_ADDR_OWVAR 33
9837: PUSH
9838: LD_STRING 
9840: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9841: LD_ADDR_VAR 0 1
9845: PUSH
9846: LD_VAR 0 1
9850: PPUSH
9851: LD_INT 2
9853: PPUSH
9854: LD_VAR 0 1
9858: PUSH
9859: LD_INT 2
9861: ARRAY
9862: PUSH
9863: LD_EXP 9
9867: ADD
9868: PPUSH
9869: CALL_OW 1
9873: ST_TO_ADDR
// end ;
9874: LD_VAR 0 1
9878: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9879: LD_INT 0
9881: PPUSH
9882: PPUSH
9883: PPUSH
9884: PPUSH
9885: PPUSH
9886: PPUSH
// uc_side := 1 ;
9887: LD_ADDR_OWVAR 20
9891: PUSH
9892: LD_INT 1
9894: ST_TO_ADDR
// uc_nation := 1 ;
9895: LD_ADDR_OWVAR 21
9899: PUSH
9900: LD_INT 1
9902: ST_TO_ADDR
// InitHc ;
9903: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9907: LD_ADDR_VAR 0 3
9911: PUSH
9912: LD_INT 3
9914: PUSH
9915: LD_INT 3
9917: PUSH
9918: LD_INT 2
9920: PUSH
9921: EMPTY
9922: LIST
9923: LIST
9924: LIST
9925: PUSH
9926: LD_OWVAR 67
9930: ARRAY
9931: ST_TO_ADDR
// for i = 1 to peopleAmount do
9932: LD_ADDR_VAR 0 2
9936: PUSH
9937: DOUBLE
9938: LD_INT 1
9940: DEC
9941: ST_TO_ADDR
9942: LD_VAR 0 3
9946: PUSH
9947: FOR_TO
9948: IFFALSE 9997
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9950: LD_INT 0
9952: PPUSH
9953: LD_INT 2
9955: PPUSH
9956: LD_INT 7
9958: PUSH
9959: LD_INT 6
9961: PUSH
9962: LD_INT 5
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: LIST
9969: PUSH
9970: LD_OWVAR 67
9974: ARRAY
9975: PPUSH
9976: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
9980: CALL_OW 44
9984: PPUSH
9985: LD_INT 19
9987: PPUSH
9988: LD_INT 0
9990: PPUSH
9991: CALL 57004 0 3
// end ;
9995: GO 9947
9997: POP
9998: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
9999: LD_INT 2
10001: PPUSH
10002: LD_INT 1
10004: PPUSH
10005: LD_INT 3
10007: PPUSH
10008: LD_INT 13
10010: PPUSH
10011: LD_INT 58
10013: PPUSH
10014: CALL 24941 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10018: CALL_OW 45
10022: PPUSH
10023: LD_INT 19
10025: PPUSH
10026: LD_INT 0
10028: PPUSH
10029: CALL 57004 0 3
// if commander = 1 then
10033: LD_EXP 25
10037: PUSH
10038: LD_INT 1
10040: EQUAL
10041: IFFALSE 10052
// wait ( 6 6$00 ) else
10043: LD_INT 12600
10045: PPUSH
10046: CALL_OW 67
10050: GO 10059
// wait ( 8 8$00 ) ;
10052: LD_INT 16800
10054: PPUSH
10055: CALL_OW 67
// uc_side := 1 ;
10059: LD_ADDR_OWVAR 20
10063: PUSH
10064: LD_INT 1
10066: ST_TO_ADDR
// uc_nation := 1 ;
10067: LD_ADDR_OWVAR 21
10071: PUSH
10072: LD_INT 1
10074: ST_TO_ADDR
// InitVc ;
10075: CALL_OW 20
// InitHc ;
10079: CALL_OW 19
// for i = 1 to 5 do
10083: LD_ADDR_VAR 0 2
10087: PUSH
10088: DOUBLE
10089: LD_INT 1
10091: DEC
10092: ST_TO_ADDR
10093: LD_INT 5
10095: PUSH
10096: FOR_TO
10097: IFFALSE 10341
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10099: LD_INT 4
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: LD_INT 1
10107: PUSH
10108: EMPTY
10109: LIST
10110: LIST
10111: LIST
10112: PUSH
10113: LD_VAR 0 2
10117: PUSH
10118: LD_INT 3
10120: MOD
10121: PUSH
10122: LD_INT 1
10124: PLUS
10125: ARRAY
10126: PPUSH
10127: LD_INT 1
10129: PPUSH
10130: LD_INT 1
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: LD_INT 3
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: LIST
10143: PUSH
10144: LD_VAR 0 2
10148: PUSH
10149: LD_INT 3
10151: MOD
10152: PUSH
10153: LD_INT 1
10155: PLUS
10156: ARRAY
10157: PPUSH
10158: LD_INT 6
10160: PUSH
10161: LD_INT 12
10163: PUSH
10164: LD_INT 11
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: LIST
10171: PUSH
10172: LD_VAR 0 2
10176: PUSH
10177: LD_INT 3
10179: MOD
10180: PUSH
10181: LD_INT 1
10183: PLUS
10184: ARRAY
10185: PPUSH
10186: LD_INT 40
10188: PPUSH
10189: LD_INT 55
10191: PPUSH
10192: CALL_OW 12
10196: PPUSH
10197: CALL 24941 0 5
// veh := CreateVehicle ;
10201: LD_ADDR_VAR 0 6
10205: PUSH
10206: CALL_OW 45
10210: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10211: LD_VAR 0 6
10215: PPUSH
10216: LD_INT 19
10218: PPUSH
10219: LD_INT 0
10221: PPUSH
10222: CALL 57004 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10226: LD_VAR 0 6
10230: PPUSH
10231: CALL_OW 264
10235: PUSH
10236: LD_INT 12
10238: EQUAL
10239: IFFALSE 10271
// begin AddCargo ( veh , mat_cans , 70 ) ;
10241: LD_VAR 0 6
10245: PPUSH
10246: LD_INT 1
10248: PPUSH
10249: LD_INT 70
10251: PPUSH
10252: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10256: LD_VAR 0 6
10260: PPUSH
10261: LD_INT 3
10263: PPUSH
10264: LD_INT 30
10266: PPUSH
10267: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10271: LD_VAR 0 6
10275: PPUSH
10276: CALL_OW 263
10280: PUSH
10281: LD_INT 1
10283: EQUAL
10284: IFFALSE 10339
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10286: LD_INT 1
10288: PPUSH
10289: LD_INT 3
10291: PPUSH
10292: LD_INT 6
10294: PPUSH
10295: CALL_OW 380
// un := CreateHuman ;
10299: LD_ADDR_VAR 0 5
10303: PUSH
10304: CALL_OW 44
10308: ST_TO_ADDR
// tmp := tmp ^ un ;
10309: LD_ADDR_VAR 0 4
10313: PUSH
10314: LD_VAR 0 4
10318: PUSH
10319: LD_VAR 0 5
10323: ADD
10324: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10325: LD_VAR 0 5
10329: PPUSH
10330: LD_VAR 0 6
10334: PPUSH
10335: CALL_OW 52
// end ; end ;
10339: GO 10096
10341: POP
10342: POP
// if tmp then
10343: LD_VAR 0 4
10347: IFFALSE 10411
// begin CenterNowOnUnits ( tmp ) ;
10349: LD_VAR 0 4
10353: PPUSH
10354: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10358: LD_VAR 0 4
10362: PUSH
10363: LD_INT 1
10365: ARRAY
10366: PPUSH
10367: LD_STRING DAR-1
10369: PPUSH
10370: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10374: LD_EXP 9
10378: PPUSH
10379: LD_STRING D
10381: PUSH
10382: LD_STRING I
10384: PUSH
10385: LD_STRING J
10387: PUSH
10388: LD_STRING S
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: LIST
10395: PUSH
10396: LD_EXP 25
10400: ARRAY
10401: STR
10402: PUSH
10403: LD_STRING -1-DAR
10405: STR
10406: PPUSH
10407: CALL_OW 88
// end ; if not reinforceAllowed then
10411: LD_EXP 24
10415: NOT
10416: IFFALSE 10420
// exit ;
10418: GO 10574
// wait ( 25 25$00 ) ;
10420: LD_INT 52500
10422: PPUSH
10423: CALL_OW 67
// uc_side := 1 ;
10427: LD_ADDR_OWVAR 20
10431: PUSH
10432: LD_INT 1
10434: ST_TO_ADDR
// uc_nation := 1 ;
10435: LD_ADDR_OWVAR 21
10439: PUSH
10440: LD_INT 1
10442: ST_TO_ADDR
// InitVc ;
10443: CALL_OW 20
// InitHc ;
10447: CALL_OW 19
// for i = 1 to 4 do
10451: LD_ADDR_VAR 0 2
10455: PUSH
10456: DOUBLE
10457: LD_INT 1
10459: DEC
10460: ST_TO_ADDR
10461: LD_INT 4
10463: PUSH
10464: FOR_TO
10465: IFFALSE 10572
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10467: LD_INT 5
10469: PPUSH
10470: LD_INT 3
10472: PPUSH
10473: LD_INT 1
10475: PPUSH
10476: LD_INT 6
10478: PPUSH
10479: LD_INT 1
10481: PPUSH
10482: CALL 24941 0 5
// veh := CreateVehicle ;
10486: LD_ADDR_VAR 0 6
10490: PUSH
10491: CALL_OW 45
10495: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10496: LD_VAR 0 6
10500: PPUSH
10501: LD_INT 19
10503: PPUSH
10504: LD_INT 0
10506: PPUSH
10507: CALL 57004 0 3
// if GetControl ( veh ) = control_manual then
10511: LD_VAR 0 6
10515: PPUSH
10516: CALL_OW 263
10520: PUSH
10521: LD_INT 1
10523: EQUAL
10524: IFFALSE 10570
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10526: LD_INT 0
10528: PPUSH
10529: LD_INT 3
10531: PPUSH
10532: LD_INT 7
10534: PUSH
10535: LD_INT 6
10537: PUSH
10538: LD_INT 5
10540: PUSH
10541: EMPTY
10542: LIST
10543: LIST
10544: LIST
10545: PUSH
10546: LD_OWVAR 67
10550: ARRAY
10551: PPUSH
10552: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10556: CALL_OW 44
10560: PPUSH
10561: LD_VAR 0 6
10565: PPUSH
10566: CALL_OW 52
// end ; end ;
10570: GO 10464
10572: POP
10573: POP
// end ;
10574: LD_VAR 0 1
10578: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10579: LD_INT 0
10581: PPUSH
10582: PPUSH
10583: PPUSH
10584: PPUSH
10585: PPUSH
// uc_side := 8 ;
10586: LD_ADDR_OWVAR 20
10590: PUSH
10591: LD_INT 8
10593: ST_TO_ADDR
// uc_nation := nation_arabian ;
10594: LD_ADDR_OWVAR 21
10598: PUSH
10599: LD_INT 2
10601: ST_TO_ADDR
// for i = 1 to 2 do
10602: LD_ADDR_VAR 0 2
10606: PUSH
10607: DOUBLE
10608: LD_INT 1
10610: DEC
10611: ST_TO_ADDR
10612: LD_INT 2
10614: PUSH
10615: FOR_TO
10616: IFFALSE 10696
// for j = 1 to 4 do
10618: LD_ADDR_VAR 0 4
10622: PUSH
10623: DOUBLE
10624: LD_INT 1
10626: DEC
10627: ST_TO_ADDR
10628: LD_INT 4
10630: PUSH
10631: FOR_TO
10632: IFFALSE 10692
// begin PrepareHuman ( false , j , 8 ) ;
10634: LD_INT 0
10636: PPUSH
10637: LD_VAR 0 4
10641: PPUSH
10642: LD_INT 8
10644: PPUSH
10645: CALL_OW 380
// un := CreateHuman ;
10649: LD_ADDR_VAR 0 3
10653: PUSH
10654: CALL_OW 44
10658: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10659: LD_VAR 0 3
10663: PPUSH
10664: LD_INT 23
10666: PPUSH
10667: LD_INT 0
10669: PPUSH
10670: CALL_OW 49
// tmp := tmp union un ;
10674: LD_ADDR_VAR 0 5
10678: PUSH
10679: LD_VAR 0 5
10683: PUSH
10684: LD_VAR 0 3
10688: UNION
10689: ST_TO_ADDR
// end ;
10690: GO 10631
10692: POP
10693: POP
10694: GO 10615
10696: POP
10697: POP
// for i in tmp do
10698: LD_ADDR_VAR 0 2
10702: PUSH
10703: LD_VAR 0 5
10707: PUSH
10708: FOR_IN
10709: IFFALSE 10728
// ComMoveXY ( i , 150 , 136 ) ;
10711: LD_VAR 0 2
10715: PPUSH
10716: LD_INT 150
10718: PPUSH
10719: LD_INT 136
10721: PPUSH
10722: CALL_OW 111
10726: GO 10708
10728: POP
10729: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10730: LD_ADDR_EXP 31
10734: PUSH
10735: LD_EXP 31
10739: PPUSH
10740: LD_EXP 6
10744: PPUSH
10745: LD_EXP 31
10749: PUSH
10750: LD_EXP 6
10754: ARRAY
10755: PUSH
10756: LD_VAR 0 5
10760: UNION
10761: PPUSH
10762: CALL_OW 1
10766: ST_TO_ADDR
// end ;
10767: LD_VAR 0 1
10771: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10772: LD_OWVAR 67
10776: PUSH
10777: LD_INT 1
10779: GREATER
10780: IFFALSE 10798
10782: PUSH
10783: LD_INT 31
10785: PPUSH
10786: LD_INT 3
10788: PPUSH
10789: CALL_OW 321
10793: PUSH
10794: LD_INT 2
10796: EQUAL
10797: AND
10798: IFFALSE 11015
10800: GO 10802
10802: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10803: LD_EXP 7
10807: PPUSH
10808: LD_INT 33
10810: PUSH
10811: LD_INT 101
10813: PUSH
10814: LD_INT 159
10816: PUSH
10817: LD_INT 5
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 33
10828: PUSH
10829: LD_INT 105
10831: PUSH
10832: LD_INT 158
10834: PUSH
10835: LD_INT 5
10837: PUSH
10838: EMPTY
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: PUSH
10844: LD_INT 33
10846: PUSH
10847: LD_INT 96
10849: PUSH
10850: LD_INT 136
10852: PUSH
10853: LD_INT 5
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: PUSH
10862: LD_INT 33
10864: PUSH
10865: LD_INT 94
10867: PUSH
10868: LD_INT 133
10870: PUSH
10871: LD_INT 4
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: PUSH
10880: LD_INT 33
10882: PUSH
10883: LD_INT 84
10885: PUSH
10886: LD_INT 102
10888: PUSH
10889: LD_INT 4
10891: PUSH
10892: EMPTY
10893: LIST
10894: LIST
10895: LIST
10896: LIST
10897: PUSH
10898: EMPTY
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: LIST
10904: PPUSH
10905: CALL 87895 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10909: LD_EXP 8
10913: PPUSH
10914: LD_INT 33
10916: PUSH
10917: LD_INT 50
10919: PUSH
10920: LD_INT 17
10922: PUSH
10923: LD_INT 4
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 33
10934: PUSH
10935: LD_INT 52
10937: PUSH
10938: LD_INT 20
10940: PUSH
10941: LD_INT 4
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: LIST
10948: LIST
10949: PUSH
10950: LD_INT 33
10952: PUSH
10953: LD_INT 53
10955: PUSH
10956: LD_INT 23
10958: PUSH
10959: LD_INT 4
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: LIST
10966: LIST
10967: PUSH
10968: LD_INT 33
10970: PUSH
10971: LD_INT 45
10973: PUSH
10974: LD_INT 32
10976: PUSH
10977: LD_INT 4
10979: PUSH
10980: EMPTY
10981: LIST
10982: LIST
10983: LIST
10984: LIST
10985: PUSH
10986: LD_INT 33
10988: PUSH
10989: LD_INT 45
10991: PUSH
10992: LD_INT 39
10994: PUSH
10995: LD_INT 4
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: LIST
11008: LIST
11009: LIST
11010: PPUSH
11011: CALL 87895 0 2
// end ;
11015: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11016: LD_INT 3
11018: PUSH
11019: LD_INT 22
11021: PUSH
11022: LD_OWVAR 2
11026: PUSH
11027: EMPTY
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: LIST
11034: PUSH
11035: LD_INT 33
11037: PUSH
11038: LD_INT 2
11040: PUSH
11041: EMPTY
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 50
11047: PUSH
11048: EMPTY
11049: LIST
11050: PUSH
11051: LD_INT 3
11053: PUSH
11054: LD_INT 61
11056: PUSH
11057: EMPTY
11058: LIST
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: EMPTY
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: PPUSH
11070: CALL_OW 69
11074: IFFALSE 11174
11076: GO 11078
11078: DISABLE
11079: LD_INT 0
11081: PPUSH
11082: PPUSH
// begin enable ;
11083: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11084: LD_ADDR_VAR 0 2
11088: PUSH
11089: LD_INT 3
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_OWVAR 2
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PUSH
11108: LD_INT 33
11110: PUSH
11111: LD_INT 2
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: LD_INT 50
11120: PUSH
11121: EMPTY
11122: LIST
11123: PUSH
11124: LD_INT 3
11126: PUSH
11127: LD_INT 61
11129: PUSH
11130: EMPTY
11131: LIST
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PUSH
11137: EMPTY
11138: LIST
11139: LIST
11140: LIST
11141: LIST
11142: PPUSH
11143: CALL_OW 69
11147: ST_TO_ADDR
// for i in tmp do
11148: LD_ADDR_VAR 0 1
11152: PUSH
11153: LD_VAR 0 2
11157: PUSH
11158: FOR_IN
11159: IFFALSE 11172
// Connect ( i ) ;
11161: LD_VAR 0 1
11165: PPUSH
11166: CALL 28423 0 1
11170: GO 11158
11172: POP
11173: POP
// end ; end_of_file
11174: PPOPN 2
11176: END
// export function Action ; var i , tmp ; begin
11177: LD_INT 0
11179: PPUSH
11180: PPUSH
11181: PPUSH
// InGameOn ;
11182: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11186: LD_INT 225
11188: PPUSH
11189: LD_INT 217
11191: PPUSH
11192: CALL_OW 86
// for i in playerForces [ 2 ] do
11196: LD_ADDR_VAR 0 2
11200: PUSH
11201: LD_EXP 10
11205: PUSH
11206: LD_INT 2
11208: ARRAY
11209: PUSH
11210: FOR_IN
11211: IFFALSE 11346
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11213: LD_EXP 10
11217: PUSH
11218: LD_INT 1
11220: ARRAY
11221: IFFALSE 11245
11223: PUSH
11224: LD_VAR 0 2
11228: PPUSH
11229: CALL_OW 257
11233: PUSH
11234: LD_INT 3
11236: PUSH
11237: LD_INT 4
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: IN
11244: AND
11245: IFFALSE 11329
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11247: LD_EXP 10
11251: PUSH
11252: LD_INT 1
11254: ARRAY
11255: PUSH
11256: LD_INT 1
11258: ARRAY
11259: PPUSH
11260: LD_INT 19
11262: PPUSH
11263: LD_INT 0
11265: PPUSH
11266: CALL 57004 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11270: LD_VAR 0 2
11274: PPUSH
11275: LD_EXP 10
11279: PUSH
11280: LD_INT 1
11282: ARRAY
11283: PUSH
11284: LD_INT 1
11286: ARRAY
11287: PPUSH
11288: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11292: LD_ADDR_EXP 10
11296: PUSH
11297: LD_EXP 10
11301: PPUSH
11302: LD_INT 1
11304: PPUSH
11305: LD_EXP 10
11309: PUSH
11310: LD_INT 1
11312: ARRAY
11313: PPUSH
11314: LD_INT 1
11316: PPUSH
11317: CALL_OW 3
11321: PPUSH
11322: CALL_OW 1
11326: ST_TO_ADDR
// end else
11327: GO 11344
// PlaceUnitInArea ( i , startArea , false ) ;
11329: LD_VAR 0 2
11333: PPUSH
11334: LD_INT 19
11336: PPUSH
11337: LD_INT 0
11339: PPUSH
11340: CALL 57004 0 3
// end ;
11344: GO 11210
11346: POP
11347: POP
// wait ( 0 0$2 ) ;
11348: LD_INT 70
11350: PPUSH
11351: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11355: LD_EXP 9
11359: PPUSH
11360: LD_STRING D
11362: PUSH
11363: LD_STRING I
11365: PUSH
11366: LD_STRING J
11368: PUSH
11369: LD_STRING S
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: LIST
11376: PUSH
11377: LD_EXP 25
11381: ARRAY
11382: STR
11383: PUSH
11384: LD_STRING -1
11386: STR
11387: PPUSH
11388: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11392: LD_EXP 12
11396: PPUSH
11397: LD_STRING DP-1
11399: PPUSH
11400: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11404: LD_EXP 12
11408: PPUSH
11409: LD_STRING DP-2
11411: PPUSH
11412: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11416: LD_EXP 9
11420: PPUSH
11421: LD_STRING D
11423: PUSH
11424: LD_STRING I
11426: PUSH
11427: LD_STRING J
11429: PUSH
11430: LD_STRING S
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: LIST
11437: PUSH
11438: LD_EXP 25
11442: ARRAY
11443: STR
11444: PUSH
11445: LD_STRING -2
11447: STR
11448: PPUSH
11449: CALL_OW 88
// InGameOff ;
11453: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11457: LD_STRING O1
11459: PPUSH
11460: CALL_OW 337
// game := true ;
11464: LD_ADDR_EXP 3
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// SaveForQuickRestart ;
11472: CALL_OW 22
// wait ( 0 0$5 ) ;
11476: LD_INT 175
11478: PPUSH
11479: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11483: LD_EXP 9
11487: PPUSH
11488: LD_STRING D
11490: PUSH
11491: LD_STRING I
11493: PUSH
11494: LD_STRING J
11496: PUSH
11497: LD_STRING S
11499: PUSH
11500: EMPTY
11501: LIST
11502: LIST
11503: LIST
11504: PUSH
11505: LD_EXP 25
11509: ARRAY
11510: STR
11511: PUSH
11512: LD_STRING -3
11514: STR
11515: PPUSH
11516: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11520: LD_INT 35
11522: PPUSH
11523: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11527: LD_EXP 15
11531: PUSH
11532: LD_INT 1
11534: ARRAY
11535: PUSH
11536: LD_EXP 15
11540: PUSH
11541: LD_INT 2
11543: ARRAY
11544: GREATEREQUAL
11545: IFFALSE 11520
// outpostEscape := true ;
11547: LD_ADDR_EXP 27
11551: PUSH
11552: LD_INT 1
11554: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11555: LD_ADDR_VAR 0 3
11559: PUSH
11560: LD_EXP 14
11564: PPUSH
11565: LD_INT 26
11567: PUSH
11568: LD_INT 1
11570: PUSH
11571: EMPTY
11572: LIST
11573: LIST
11574: PPUSH
11575: CALL_OW 72
11579: ST_TO_ADDR
// if tmp then
11580: LD_VAR 0 3
11584: IFFALSE 11602
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11586: LD_VAR 0 3
11590: PUSH
11591: LD_INT 1
11593: ARRAY
11594: PPUSH
11595: LD_STRING DR-1-Escape
11597: PPUSH
11598: CALL_OW 88
// wait ( 0 0$1 ) ;
11602: LD_INT 35
11604: PPUSH
11605: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11609: LD_EXP 9
11613: PPUSH
11614: LD_STRING D
11616: PUSH
11617: LD_STRING I
11619: PUSH
11620: LD_STRING J
11622: PUSH
11623: LD_STRING S
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: LIST
11630: PUSH
11631: LD_EXP 25
11635: ARRAY
11636: STR
11637: PUSH
11638: LD_STRING -1-Escape
11640: STR
11641: PPUSH
11642: CALL_OW 88
// for i in ruOutpost do
11646: LD_ADDR_VAR 0 2
11650: PUSH
11651: LD_EXP 14
11655: PUSH
11656: FOR_IN
11657: IFFALSE 11711
// begin if IsInUnit ( i ) then
11659: LD_VAR 0 2
11663: PPUSH
11664: CALL_OW 310
11668: IFFALSE 11679
// ComExitBuilding ( i ) ;
11670: LD_VAR 0 2
11674: PPUSH
11675: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11679: LD_VAR 0 2
11683: PPUSH
11684: LD_INT 179
11686: PPUSH
11687: LD_INT 102
11689: PPUSH
11690: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11694: LD_VAR 0 2
11698: PPUSH
11699: LD_INT 28
11701: PPUSH
11702: LD_INT 20
11704: PPUSH
11705: CALL_OW 171
// end ;
11709: GO 11656
11711: POP
11712: POP
// tmp := [ ] ;
11713: LD_ADDR_VAR 0 3
11717: PUSH
11718: EMPTY
11719: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11720: LD_INT 35
11722: PPUSH
11723: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11727: LD_ADDR_VAR 0 3
11731: PUSH
11732: LD_EXP 14
11736: PPUSH
11737: LD_INT 95
11739: PUSH
11740: LD_INT 11
11742: PUSH
11743: EMPTY
11744: LIST
11745: LIST
11746: PPUSH
11747: CALL_OW 72
11751: ST_TO_ADDR
// if tmp then
11752: LD_VAR 0 3
11756: IFFALSE 11835
// for i in tmp do
11758: LD_ADDR_VAR 0 2
11762: PUSH
11763: LD_VAR 0 3
11767: PUSH
11768: FOR_IN
11769: IFFALSE 11833
// begin ruOutpost := ruOutpost diff i ;
11771: LD_ADDR_EXP 14
11775: PUSH
11776: LD_EXP 14
11780: PUSH
11781: LD_VAR 0 2
11785: DIFF
11786: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11787: LD_ADDR_EXP 31
11791: PUSH
11792: LD_EXP 31
11796: PPUSH
11797: LD_EXP 8
11801: PUSH
11802: LD_EXP 31
11806: PUSH
11807: LD_EXP 8
11811: ARRAY
11812: PUSH
11813: LD_INT 1
11815: PLUS
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PPUSH
11821: LD_VAR 0 2
11825: PPUSH
11826: CALL 25063 0 3
11830: ST_TO_ADDR
// end ;
11831: GO 11768
11833: POP
11834: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11835: LD_EXP 14
11839: PPUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 1
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PPUSH
11850: CALL_OW 72
11854: NOT
11855: IFFALSE 11720
// ruOutpost := [ ] ;
11857: LD_ADDR_EXP 14
11861: PUSH
11862: EMPTY
11863: ST_TO_ADDR
// end ;
11864: LD_VAR 0 1
11868: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11869: LD_EXP 27
11873: IFFALSE 12062
11875: GO 11877
11877: DISABLE
11878: LD_INT 0
11880: PPUSH
11881: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11882: LD_INT 875
11884: PPUSH
11885: LD_INT 1225
11887: PPUSH
11888: CALL_OW 12
11892: PPUSH
11893: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11897: LD_ADDR_VAR 0 2
11901: PUSH
11902: LD_INT 208
11904: PUSH
11905: LD_INT 166
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 218
11914: PUSH
11915: LD_INT 174
11917: PUSH
11918: EMPTY
11919: LIST
11920: LIST
11921: PUSH
11922: LD_INT 201
11924: PUSH
11925: LD_INT 173
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PUSH
11932: LD_INT 189
11934: PUSH
11935: LD_INT 167
11937: PUSH
11938: EMPTY
11939: LIST
11940: LIST
11941: PUSH
11942: LD_INT 191
11944: PUSH
11945: LD_INT 160
11947: PUSH
11948: EMPTY
11949: LIST
11950: LIST
11951: PUSH
11952: LD_INT 209
11954: PUSH
11955: LD_INT 181
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: PUSH
11962: LD_INT 192
11964: PUSH
11965: LD_INT 162
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 197
11974: PUSH
11975: LD_INT 166
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
11992: LD_ADDR_VAR 0 1
11996: PUSH
11997: DOUBLE
11998: LD_INT 1
12000: DEC
12001: ST_TO_ADDR
12002: LD_INT 5
12004: PUSH
12005: LD_OWVAR 67
12009: PLUS
12010: PUSH
12011: FOR_TO
12012: IFFALSE 12060
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12014: LD_VAR 0 2
12018: PUSH
12019: LD_VAR 0 1
12023: ARRAY
12024: PUSH
12025: LD_INT 1
12027: ARRAY
12028: PPUSH
12029: LD_VAR 0 2
12033: PUSH
12034: LD_VAR 0 1
12038: ARRAY
12039: PUSH
12040: LD_INT 2
12042: ARRAY
12043: PPUSH
12044: LD_INT 1
12046: PPUSH
12047: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12051: LD_INT 28
12053: PPUSH
12054: CALL_OW 67
// end ;
12058: GO 12011
12060: POP
12061: POP
// end ;
12062: PPOPN 2
12064: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12065: LD_EXP 27
12069: NOT
12070: IFFALSE 12732
12072: GO 12074
12074: DISABLE
12075: LD_INT 0
12077: PPUSH
12078: PPUSH
12079: PPUSH
12080: PPUSH
12081: PPUSH
12082: PPUSH
12083: PPUSH
// begin enable ;
12084: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12085: LD_ADDR_VAR 0 1
12089: PUSH
12090: LD_EXP 14
12094: PPUSH
12095: LD_INT 22
12097: PUSH
12098: LD_INT 3
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: LD_INT 25
12107: PUSH
12108: LD_INT 1
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PPUSH
12119: CALL_OW 72
12123: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12124: LD_ADDR_VAR 0 2
12128: PUSH
12129: LD_EXP 14
12133: PPUSH
12134: LD_INT 22
12136: PUSH
12137: LD_INT 3
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PUSH
12144: LD_INT 25
12146: PUSH
12147: LD_INT 2
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: PPUSH
12158: CALL_OW 72
12162: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12163: LD_ADDR_VAR 0 3
12167: PUSH
12168: LD_EXP 14
12172: PPUSH
12173: LD_INT 22
12175: PUSH
12176: LD_INT 3
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PUSH
12183: LD_INT 21
12185: PUSH
12186: LD_INT 3
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: PUSH
12193: LD_INT 3
12195: PUSH
12196: LD_INT 24
12198: PUSH
12199: LD_INT 1000
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: LIST
12214: PPUSH
12215: CALL_OW 72
12219: ST_TO_ADDR
// if engs and buildings then
12220: LD_VAR 0 2
12224: IFFALSE 12232
12226: PUSH
12227: LD_VAR 0 3
12231: AND
12232: IFFALSE 12305
// begin for i in engs do
12234: LD_ADDR_VAR 0 5
12238: PUSH
12239: LD_VAR 0 2
12243: PUSH
12244: FOR_IN
12245: IFFALSE 12301
// if IsInUnit ( i ) then
12247: LD_VAR 0 5
12251: PPUSH
12252: CALL_OW 310
12256: IFFALSE 12269
// ComExitBuilding ( i ) else
12258: LD_VAR 0 5
12262: PPUSH
12263: CALL_OW 122
12267: GO 12299
// if not HasTask ( i ) then
12269: LD_VAR 0 5
12273: PPUSH
12274: CALL_OW 314
12278: NOT
12279: IFFALSE 12299
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12281: LD_VAR 0 5
12285: PPUSH
12286: LD_VAR 0 3
12290: PUSH
12291: LD_INT 1
12293: ARRAY
12294: PPUSH
12295: CALL_OW 130
12299: GO 12244
12301: POP
12302: POP
// end else
12303: GO 12412
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12305: LD_VAR 0 3
12309: NOT
12310: IFFALSE 12333
12312: PUSH
12313: LD_EXP 14
12317: PPUSH
12318: LD_INT 30
12320: PUSH
12321: LD_INT 0
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PPUSH
12328: CALL_OW 72
12332: AND
12333: IFFALSE 12359
12335: PUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: LD_INT 3
12343: PUSH
12344: LD_INT 54
12346: PUSH
12347: EMPTY
12348: LIST
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PPUSH
12354: CALL_OW 72
12358: AND
12359: IFFALSE 12412
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12361: LD_VAR 0 2
12365: PPUSH
12366: LD_INT 3
12368: PUSH
12369: LD_INT 54
12371: PUSH
12372: EMPTY
12373: LIST
12374: PUSH
12375: EMPTY
12376: LIST
12377: LIST
12378: PPUSH
12379: CALL_OW 72
12383: PPUSH
12384: LD_EXP 14
12388: PPUSH
12389: LD_INT 30
12391: PUSH
12392: LD_INT 0
12394: PUSH
12395: EMPTY
12396: LIST
12397: LIST
12398: PPUSH
12399: CALL_OW 72
12403: PUSH
12404: LD_INT 1
12406: ARRAY
12407: PPUSH
12408: CALL_OW 120
// if not tmp then
12412: LD_VAR 0 1
12416: NOT
12417: IFFALSE 12421
// exit ;
12419: GO 12732
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12421: LD_INT 26
12423: PPUSH
12424: LD_INT 81
12426: PUSH
12427: LD_INT 3
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PPUSH
12434: CALL_OW 70
12438: PUSH
12439: LD_INT 1
12441: GREATER
12442: IFFALSE 12498
// begin for i in tmp do
12444: LD_ADDR_VAR 0 5
12448: PUSH
12449: LD_VAR 0 1
12453: PUSH
12454: FOR_IN
12455: IFFALSE 12494
// begin if IsInUnit ( i ) then
12457: LD_VAR 0 5
12461: PPUSH
12462: CALL_OW 310
12466: IFFALSE 12477
// ComExitBuilding ( i ) ;
12468: LD_VAR 0 5
12472: PPUSH
12473: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12477: LD_VAR 0 5
12481: PPUSH
12482: LD_INT 204
12484: PPUSH
12485: LD_INT 164
12487: PPUSH
12488: CALL_OW 174
// end ;
12492: GO 12454
12494: POP
12495: POP
// end else
12496: GO 12732
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12498: LD_VAR 0 1
12502: PPUSH
12503: LD_INT 3
12505: PUSH
12506: LD_INT 54
12508: PUSH
12509: EMPTY
12510: LIST
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PPUSH
12516: CALL_OW 72
12520: IFFALSE 12732
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12522: LD_ADDR_VAR 0 4
12526: PUSH
12527: LD_EXP 14
12531: PPUSH
12532: LD_INT 30
12534: PUSH
12535: LD_INT 32
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PUSH
12542: LD_INT 58
12544: PUSH
12545: EMPTY
12546: LIST
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PPUSH
12552: CALL_OW 72
12556: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12557: LD_VAR 0 4
12561: NOT
12562: IFFALSE 12585
12564: PUSH
12565: LD_EXP 14
12569: PPUSH
12570: LD_INT 30
12572: PUSH
12573: LD_INT 5
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: PPUSH
12580: CALL_OW 72
12584: AND
12585: IFFALSE 12622
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12587: LD_VAR 0 1
12591: PPUSH
12592: LD_EXP 14
12596: PPUSH
12597: LD_INT 30
12599: PUSH
12600: LD_INT 5
12602: PUSH
12603: EMPTY
12604: LIST
12605: LIST
12606: PPUSH
12607: CALL_OW 72
12611: PUSH
12612: LD_INT 1
12614: ARRAY
12615: PPUSH
12616: CALL_OW 120
// exit ;
12620: GO 12732
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12622: LD_ADDR_VAR 0 6
12626: PUSH
12627: LD_VAR 0 1
12631: PPUSH
12632: LD_INT 3
12634: PUSH
12635: LD_INT 54
12637: PUSH
12638: EMPTY
12639: LIST
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PPUSH
12645: CALL_OW 72
12649: ST_TO_ADDR
// if j < empty then
12650: LD_VAR 0 6
12654: PUSH
12655: LD_VAR 0 4
12659: LESS
12660: IFFALSE 12674
// k := j else
12662: LD_ADDR_VAR 0 7
12666: PUSH
12667: LD_VAR 0 6
12671: ST_TO_ADDR
12672: GO 12684
// k := empty ;
12674: LD_ADDR_VAR 0 7
12678: PUSH
12679: LD_VAR 0 4
12683: ST_TO_ADDR
// for i = 1 to k do
12684: LD_ADDR_VAR 0 5
12688: PUSH
12689: DOUBLE
12690: LD_INT 1
12692: DEC
12693: ST_TO_ADDR
12694: LD_VAR 0 7
12698: PUSH
12699: FOR_TO
12700: IFFALSE 12730
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12702: LD_VAR 0 6
12706: PUSH
12707: LD_VAR 0 5
12711: ARRAY
12712: PPUSH
12713: LD_VAR 0 4
12717: PUSH
12718: LD_VAR 0 5
12722: ARRAY
12723: PPUSH
12724: CALL_OW 120
12728: GO 12699
12730: POP
12731: POP
// end ; end ;
12732: PPOPN 7
12734: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12735: LD_EXP 2
12739: PUSH
12740: LD_INT 1
12742: EQUAL
12743: IFFALSE 12751
12745: PUSH
12746: LD_EXP 27
12750: AND
12751: IFFALSE 12791
12753: PUSH
12754: LD_INT 22
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: LD_INT 92
12766: PUSH
12767: LD_INT 208
12769: PUSH
12770: LD_INT 163
12772: PUSH
12773: LD_INT 8
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: LIST
12780: LIST
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PPUSH
12786: CALL_OW 69
12790: AND
12791: IFFALSE 12843
12793: PUSH
12794: LD_INT 22
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 21
12806: PUSH
12807: LD_INT 1
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 92
12816: PUSH
12817: LD_INT 208
12819: PUSH
12820: LD_INT 163
12822: PUSH
12823: LD_INT 14
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: LIST
12830: LIST
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: LIST
12836: PPUSH
12837: CALL_OW 69
12841: NOT
12842: AND
12843: IFFALSE 13148
12845: GO 12847
12847: DISABLE
12848: LD_INT 0
12850: PPUSH
// begin InGameOn ;
12851: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12855: LD_EXP 9
12859: PPUSH
12860: CALL_OW 87
// wait ( 0 0$1 ) ;
12864: LD_INT 35
12866: PPUSH
12867: CALL_OW 67
// DialogueOn ;
12871: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12875: LD_EXP 9
12879: PPUSH
12880: LD_STRING D
12882: PUSH
12883: LD_STRING I
12885: PUSH
12886: LD_STRING J
12888: PUSH
12889: LD_STRING S
12891: PUSH
12892: EMPTY
12893: LIST
12894: LIST
12895: LIST
12896: PUSH
12897: LD_EXP 25
12901: ARRAY
12902: STR
12903: PUSH
12904: LD_STRING -1-BaseCaptured
12906: STR
12907: PPUSH
12908: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12912: LD_EXP 12
12916: PPUSH
12917: LD_STRING DP-1-BaseCaptured
12919: PPUSH
12920: CALL_OW 94
// if sibBombAllowed then
12924: LD_EXP 23
12928: IFFALSE 13070
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12930: LD_EXP 9
12934: PPUSH
12935: LD_STRING D
12937: PUSH
12938: LD_STRING I
12940: PUSH
12941: LD_STRING J
12943: PUSH
12944: LD_STRING S
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: PUSH
12952: LD_EXP 25
12956: ARRAY
12957: STR
12958: PUSH
12959: LD_STRING -2-BaseCaptured
12961: STR
12962: PPUSH
12963: CALL_OW 88
// if commander = 1 then
12967: LD_EXP 25
12971: PUSH
12972: LD_INT 1
12974: EQUAL
12975: IFFALSE 12989
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12977: LD_EXP 12
12981: PPUSH
12982: LD_STRING DP-2b-BaseCaptured
12984: PPUSH
12985: CALL_OW 94
// if commander = 2 then
12989: LD_EXP 25
12993: PUSH
12994: LD_INT 2
12996: EQUAL
12997: IFFALSE 13011
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
12999: LD_EXP 12
13003: PPUSH
13004: LD_STRING DP-2-BaseCaptured
13006: PPUSH
13007: CALL_OW 94
// if commander = 3 then
13011: LD_EXP 25
13015: PUSH
13016: LD_INT 3
13018: EQUAL
13019: IFFALSE 13033
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13021: LD_EXP 12
13025: PPUSH
13026: LD_STRING DP-2a-BaseCaptured
13028: PPUSH
13029: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13033: LD_EXP 9
13037: PPUSH
13038: LD_STRING D
13040: PUSH
13041: LD_STRING I
13043: PUSH
13044: LD_STRING J
13046: PUSH
13047: LD_STRING S
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: LIST
13054: PUSH
13055: LD_EXP 25
13059: ARRAY
13060: STR
13061: PUSH
13062: LD_STRING -3-BaseCaptured
13064: STR
13065: PPUSH
13066: CALL_OW 88
// end ; DialogueOff ;
13070: CALL_OW 7
// InGameOff ;
13074: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13078: LD_STRING O2
13080: PPUSH
13081: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13085: LD_ADDR_VAR 0 1
13089: PUSH
13090: LD_EXP 14
13094: PPUSH
13095: LD_INT 21
13097: PUSH
13098: LD_INT 3
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: PPUSH
13105: CALL_OW 72
13109: PUSH
13110: FOR_IN
13111: IFFALSE 13127
// SetSide ( i , 1 ) ;
13113: LD_VAR 0 1
13117: PPUSH
13118: LD_INT 1
13120: PPUSH
13121: CALL_OW 235
13125: GO 13110
13127: POP
13128: POP
// baseCaptured := true ;
13129: LD_ADDR_EXP 17
13133: PUSH
13134: LD_INT 1
13136: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13137: LD_INT 1225
13139: PPUSH
13140: CALL_OW 67
// PrepareReinforcements ;
13144: CALL 9879 0 0
// end ;
13148: PPOPN 1
13150: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13151: LD_INT 22
13153: PUSH
13154: LD_INT 3
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: PUSH
13161: LD_INT 92
13163: PUSH
13164: LD_INT 167
13166: PUSH
13167: LD_INT 197
13169: PUSH
13170: LD_INT 20
13172: PUSH
13173: EMPTY
13174: LIST
13175: LIST
13176: LIST
13177: LIST
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: PPUSH
13183: CALL_OW 69
13187: PUSH
13188: LD_INT 3
13190: GREATER
13191: IFFALSE 13208
13193: GO 13195
13195: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13196: LD_EXP 12
13200: PPUSH
13201: LD_STRING DP-RuAttack
13203: PPUSH
13204: CALL_OW 94
13208: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13209: LD_EXP 1
13213: NOT
13214: IFFALSE 13231
13216: PUSH
13217: LD_INT 1
13219: PPUSH
13220: LD_INT 168
13222: PPUSH
13223: LD_INT 74
13225: PPUSH
13226: CALL_OW 293
13230: AND
13231: IFFALSE 13245
13233: PUSH
13234: LD_INT 168
13236: PPUSH
13237: LD_INT 72
13239: PPUSH
13240: CALL_OW 553
13244: AND
13245: IFFALSE 13297
13247: GO 13249
13249: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13250: LD_INT 168
13252: PPUSH
13253: LD_INT 72
13255: PPUSH
13256: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13260: LD_EXP 9
13264: PPUSH
13265: LD_STRING D
13267: PUSH
13268: LD_STRING I
13270: PUSH
13271: LD_STRING J
13273: PUSH
13274: LD_STRING S
13276: PUSH
13277: EMPTY
13278: LIST
13279: LIST
13280: LIST
13281: PUSH
13282: LD_EXP 25
13286: ARRAY
13287: STR
13288: PUSH
13289: LD_STRING -1-Blockade
13291: STR
13292: PPUSH
13293: CALL_OW 88
// end ;
13297: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13298: LD_EXP 2
13302: PUSH
13303: LD_INT 1
13305: EQUAL
13306: IFFALSE 13338
13308: PUSH
13309: LD_INT 22
13311: PUSH
13312: LD_INT 1
13314: PUSH
13315: EMPTY
13316: LIST
13317: LIST
13318: PUSH
13319: LD_INT 101
13321: PUSH
13322: LD_INT 4
13324: PUSH
13325: EMPTY
13326: LIST
13327: LIST
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL_OW 69
13337: AND
13338: IFFALSE 13876
13340: GO 13342
13342: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13343: LD_INT 4
13345: PPUSH
13346: LD_INT 1
13348: PPUSH
13349: CALL_OW 343
// DialogueOn ;
13353: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13357: LD_EXP 11
13361: PPUSH
13362: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13366: LD_EXP 11
13370: PPUSH
13371: LD_STRING DM-1-Contact
13373: PPUSH
13374: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13378: LD_EXP 9
13382: PPUSH
13383: LD_STRING D
13385: PUSH
13386: LD_STRING I
13388: PUSH
13389: LD_STRING J
13391: PUSH
13392: LD_STRING S
13394: PUSH
13395: EMPTY
13396: LIST
13397: LIST
13398: LIST
13399: PUSH
13400: LD_EXP 25
13404: ARRAY
13405: STR
13406: PUSH
13407: LD_STRING -1-Contact
13409: STR
13410: PPUSH
13411: CALL_OW 88
// if commander = 1 then
13415: LD_EXP 25
13419: PUSH
13420: LD_INT 1
13422: EQUAL
13423: IFFALSE 13557
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13425: LD_EXP 11
13429: PPUSH
13430: LD_STRING DM-2-Contact
13432: PPUSH
13433: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13437: LD_EXP 9
13441: PPUSH
13442: LD_STRING DI-2-Contact
13444: PPUSH
13445: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13449: LD_INT 22
13451: PUSH
13452: LD_INT 8
13454: PUSH
13455: EMPTY
13456: LIST
13457: LIST
13458: PUSH
13459: LD_INT 21
13461: PUSH
13462: LD_INT 1
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: PPUSH
13473: CALL_OW 69
13477: IFFALSE 13495
13479: PUSH
13480: LD_INT 8
13482: PPUSH
13483: LD_INT 1
13485: PPUSH
13486: CALL_OW 81
13490: PUSH
13491: LD_INT 2
13493: EQUAL
13494: AND
13495: IFFALSE 13521
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13497: LD_EXP 11
13501: PPUSH
13502: LD_STRING DM-3-Contact
13504: PPUSH
13505: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13509: LD_EXP 9
13513: PPUSH
13514: LD_STRING DI-3-Contact
13516: PPUSH
13517: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13521: LD_EXP 11
13525: PPUSH
13526: LD_STRING DM-4-Contact
13528: PPUSH
13529: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13533: LD_EXP 9
13537: PPUSH
13538: LD_STRING DI-4-Contact
13540: PPUSH
13541: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13545: LD_EXP 11
13549: PPUSH
13550: LD_STRING DM-5-Contact
13552: PPUSH
13553: CALL_OW 94
// end ; if commander = 2 then
13557: LD_EXP 25
13561: PUSH
13562: LD_INT 2
13564: EQUAL
13565: IFFALSE 13699
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13567: LD_EXP 11
13571: PPUSH
13572: LD_STRING DM-2c-Contact
13574: PPUSH
13575: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13579: LD_EXP 9
13583: PPUSH
13584: LD_STRING DJ-2-Contact
13586: PPUSH
13587: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13591: LD_INT 22
13593: PUSH
13594: LD_INT 8
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 21
13603: PUSH
13604: LD_INT 1
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PPUSH
13615: CALL_OW 69
13619: IFFALSE 13637
13621: PUSH
13622: LD_INT 8
13624: PPUSH
13625: LD_INT 1
13627: PPUSH
13628: CALL_OW 81
13632: PUSH
13633: LD_INT 2
13635: EQUAL
13636: AND
13637: IFFALSE 13663
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13639: LD_EXP 11
13643: PPUSH
13644: LD_STRING DM-3-Contact
13646: PPUSH
13647: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13651: LD_EXP 9
13655: PPUSH
13656: LD_STRING DJ-3-Contact
13658: PPUSH
13659: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13663: LD_EXP 11
13667: PPUSH
13668: LD_STRING DM-4-Contact
13670: PPUSH
13671: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13675: LD_EXP 9
13679: PPUSH
13680: LD_STRING DJ-4-Contact
13682: PPUSH
13683: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13687: LD_EXP 11
13691: PPUSH
13692: LD_STRING DM-5a-Contact
13694: PPUSH
13695: CALL_OW 94
// end ; if commander = 3 then
13699: LD_EXP 25
13703: PUSH
13704: LD_INT 3
13706: EQUAL
13707: IFFALSE 13865
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13709: LD_EXP 11
13713: PPUSH
13714: LD_STRING DM-2a-Contact
13716: PPUSH
13717: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13721: LD_EXP 9
13725: PPUSH
13726: LD_STRING DS-2a-Contact
13728: PPUSH
13729: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13733: LD_EXP 11
13737: PPUSH
13738: LD_STRING DM-2b-Contact
13740: PPUSH
13741: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13745: LD_EXP 9
13749: PPUSH
13750: LD_STRING DS-2b-Contact
13752: PPUSH
13753: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13757: LD_INT 22
13759: PUSH
13760: LD_INT 8
13762: PUSH
13763: EMPTY
13764: LIST
13765: LIST
13766: PUSH
13767: LD_INT 21
13769: PUSH
13770: LD_INT 1
13772: PUSH
13773: EMPTY
13774: LIST
13775: LIST
13776: PUSH
13777: EMPTY
13778: LIST
13779: LIST
13780: PPUSH
13781: CALL_OW 69
13785: IFFALSE 13803
13787: PUSH
13788: LD_INT 8
13790: PPUSH
13791: LD_INT 1
13793: PPUSH
13794: CALL_OW 81
13798: PUSH
13799: LD_INT 2
13801: EQUAL
13802: AND
13803: IFFALSE 13829
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13805: LD_EXP 11
13809: PPUSH
13810: LD_STRING DM-3-Contact
13812: PPUSH
13813: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13817: LD_EXP 9
13821: PPUSH
13822: LD_STRING DS-3-Contact
13824: PPUSH
13825: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13829: LD_EXP 11
13833: PPUSH
13834: LD_STRING DM-4-Contact
13836: PPUSH
13837: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13841: LD_EXP 9
13845: PPUSH
13846: LD_STRING DS-4-Contact
13848: PPUSH
13849: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13853: LD_EXP 11
13857: PPUSH
13858: LD_STRING DM-5-Contact
13860: PPUSH
13861: CALL_OW 94
// end ; DialogueOff ;
13865: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13869: LD_STRING O3
13871: PPUSH
13872: CALL_OW 337
// end ;
13876: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13877: LD_EXP 2
13881: PUSH
13882: LD_INT 1
13884: EQUAL
13885: IFFALSE 13914
13887: PUSH
13888: LD_EXP 18
13892: PUSH
13893: LD_INT 15
13895: PUSH
13896: LD_INT 20
13898: PUSH
13899: LD_INT 25
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: LIST
13906: PUSH
13907: LD_OWVAR 67
13911: ARRAY
13912: GREATEREQUAL
13913: AND
13914: IFFALSE 13946
13916: PUSH
13917: LD_INT 22
13919: PUSH
13920: LD_INT 8
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: PUSH
13927: LD_INT 30
13929: PUSH
13930: LD_INT 1
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: PPUSH
13941: CALL_OW 69
13945: AND
13946: IFFALSE 13982
13948: PUSH
13949: LD_INT 22
13951: PUSH
13952: LD_INT 8
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: LD_INT 21
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: PPUSH
13973: CALL_OW 69
13977: PUSH
13978: LD_INT 5
13980: GREATEREQUAL
13981: AND
13982: IFFALSE 14509
13984: GO 13986
13986: DISABLE
13987: LD_INT 0
13989: PPUSH
13990: PPUSH
13991: PPUSH
13992: PPUSH
// begin DialogueOn ;
13993: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13997: LD_EXP 13
14001: PPUSH
14002: LD_STRING DF-1-Leg
14004: PPUSH
14005: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14009: LD_EXP 9
14013: PPUSH
14014: LD_STRING D
14016: PUSH
14017: LD_STRING I
14019: PUSH
14020: LD_STRING J
14022: PUSH
14023: LD_STRING S
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: LIST
14030: PUSH
14031: LD_EXP 25
14035: ARRAY
14036: STR
14037: PUSH
14038: LD_STRING -1-Leg
14040: STR
14041: PPUSH
14042: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14046: LD_EXP 13
14050: PPUSH
14051: LD_STRING DF-2-Leg
14053: PPUSH
14054: CALL_OW 94
// DialogueOff ;
14058: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14062: LD_STRING QLegionOffer
14064: PPUSH
14065: CALL_OW 97
14069: PUSH
14070: LD_INT 1
14072: DOUBLE
14073: EQUAL
14074: IFTRUE 14078
14076: GO 14081
14078: POP
// ; 2 :
14079: GO 14095
14081: LD_INT 2
14083: DOUBLE
14084: EQUAL
14085: IFTRUE 14089
14087: GO 14094
14089: POP
// exit ; end ;
14090: GO 14509
14092: GO 14095
14094: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14095: LD_EXP 9
14099: PPUSH
14100: LD_STRING D
14102: PUSH
14103: LD_STRING I
14105: PUSH
14106: LD_STRING J
14108: PUSH
14109: LD_STRING S
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: LIST
14116: PUSH
14117: LD_EXP 25
14121: ARRAY
14122: STR
14123: PUSH
14124: LD_STRING -2-Leg
14126: STR
14127: PPUSH
14128: CALL_OW 88
// legOfferAccepted := true ;
14132: LD_ADDR_EXP 20
14136: PUSH
14137: LD_INT 1
14139: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14140: LD_INT 21
14142: PPUSH
14143: LD_INT 1
14145: PPUSH
14146: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14150: LD_INT 190
14152: PPUSH
14153: LD_INT 227
14155: PPUSH
14156: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14160: LD_ADDR_VAR 0 1
14164: PUSH
14165: LD_INT 16800
14167: PUSH
14168: LD_INT 14700
14170: PUSH
14171: LD_INT 12600
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: LIST
14178: PUSH
14179: LD_OWVAR 67
14183: ARRAY
14184: ST_TO_ADDR
// sib := 100 ;
14185: LD_ADDR_VAR 0 2
14189: PUSH
14190: LD_INT 100
14192: ST_TO_ADDR
// disableGlobalTimer := true ;
14193: LD_ADDR_EXP 4
14197: PUSH
14198: LD_INT 1
14200: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14201: LD_INT 35
14203: PPUSH
14204: CALL_OW 67
// time := time - 0 0$1 ;
14208: LD_ADDR_VAR 0 1
14212: PUSH
14213: LD_VAR 0 1
14217: PUSH
14218: LD_INT 35
14220: MINUS
14221: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14222: LD_ADDR_VAR 0 3
14226: PUSH
14227: LD_INT 21
14229: PPUSH
14230: LD_INT 3
14232: PPUSH
14233: CALL_OW 287
14237: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14238: LD_ADDR_OWVAR 47
14242: PUSH
14243: LD_STRING #SkrTime
14245: PUSH
14246: LD_OWVAR 1
14250: PUSH
14251: LD_STRING #Skr-LegOffer
14253: PUSH
14254: LD_VAR 0 2
14258: PUSH
14259: LD_VAR 0 1
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: LIST
14268: LIST
14269: LIST
14270: ST_TO_ADDR
// if sources then
14271: LD_VAR 0 3
14275: IFFALSE 14307
// begin sib := sib - sources * 10 ;
14277: LD_ADDR_VAR 0 2
14281: PUSH
14282: LD_VAR 0 2
14286: PUSH
14287: LD_VAR 0 3
14291: PUSH
14292: LD_INT 10
14294: MUL
14295: MINUS
14296: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14297: LD_INT 21
14299: PPUSH
14300: LD_INT 3
14302: PPUSH
14303: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14307: LD_VAR 0 1
14311: PUSH
14312: LD_INT 0
14314: EQUAL
14315: IFTRUE 14327
14317: PUSH
14318: LD_VAR 0 2
14322: PUSH
14323: LD_INT 0
14325: LESSEQUAL
14326: OR
14327: IFTRUE 14346
14329: PUSH
14330: LD_INT 22
14332: PUSH
14333: LD_INT 8
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: PPUSH
14340: CALL_OW 69
14344: NOT
14345: OR
14346: IFFALSE 14201
// SetAreaMapShow ( legOfferArea , 0 ) ;
14348: LD_INT 21
14350: PPUSH
14351: LD_INT 0
14353: PPUSH
14354: CALL_OW 424
// disableGlobalTimer := false ;
14358: LD_ADDR_EXP 4
14362: PUSH
14363: LD_INT 0
14365: ST_TO_ADDR
// if sib <= 0 then
14366: LD_VAR 0 2
14370: PUSH
14371: LD_INT 0
14373: LESSEQUAL
14374: IFFALSE 14490
// begin legChangeSide := true ;
14376: LD_ADDR_EXP 21
14380: PUSH
14381: LD_INT 1
14383: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14384: LD_EXP 13
14388: PPUSH
14389: LD_STRING DF-4y-Leg
14391: PPUSH
14392: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14396: LD_STRING O3a
14398: PPUSH
14399: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14403: LD_INT 8
14405: PPUSH
14406: LD_INT 1
14408: PPUSH
14409: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14413: LD_INT 8
14415: PPUSH
14416: LD_INT 1
14418: PPUSH
14419: LD_INT 1
14421: PPUSH
14422: LD_INT 1
14424: PPUSH
14425: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14429: LD_INT 8
14431: PPUSH
14432: LD_INT 4
14434: PPUSH
14435: LD_INT 1
14437: PPUSH
14438: LD_INT 1
14440: PPUSH
14441: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14445: LD_INT 8
14447: PPUSH
14448: LD_INT 6
14450: PPUSH
14451: LD_INT 2
14453: PPUSH
14454: LD_INT 1
14456: PPUSH
14457: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14461: LD_INT 8
14463: PPUSH
14464: LD_INT 3
14466: PPUSH
14467: LD_INT 2
14469: PPUSH
14470: LD_INT 1
14472: PPUSH
14473: CALL_OW 80
// wait ( 0 0$30 ) ;
14477: LD_INT 1050
14479: PPUSH
14480: CALL_OW 67
// PrepareLegionReinforcements ;
14484: CALL 10579 0 0
// end else
14488: GO 14509
// begin ChangeMissionObjectives ( O3a ) ;
14490: LD_STRING O3a
14492: PPUSH
14493: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14497: LD_EXP 13
14501: PPUSH
14502: LD_STRING DF-4n-Leg
14504: PPUSH
14505: CALL_OW 94
// end ; end ;
14509: PPOPN 4
14511: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14512: LD_INT 22
14514: PUSH
14515: LD_INT 8
14517: PUSH
14518: EMPTY
14519: LIST
14520: LIST
14521: PUSH
14522: LD_INT 21
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PUSH
14532: EMPTY
14533: LIST
14534: LIST
14535: PPUSH
14536: CALL_OW 69
14540: PUSH
14541: LD_INT 0
14543: EQUAL
14544: IFFALSE 14562
14546: PUSH
14547: LD_INT 8
14549: PPUSH
14550: LD_INT 1
14552: PPUSH
14553: CALL_OW 81
14557: PUSH
14558: LD_INT 2
14560: EQUAL
14561: AND
14562: IFFALSE 14574
14564: GO 14566
14566: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14567: LD_STRING O3a
14569: PPUSH
14570: CALL_OW 337
14574: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14575: LD_EXP 2
14579: PUSH
14580: LD_INT 1
14582: EQUAL
14583: IFFALSE 14591
14585: PUSH
14586: LD_EXP 3
14590: AND
14591: IFFALSE 14627
14593: PUSH
14594: LD_INT 22
14596: PUSH
14597: LD_INT 3
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: PUSH
14604: LD_INT 21
14606: PUSH
14607: LD_INT 1
14609: PUSH
14610: EMPTY
14611: LIST
14612: LIST
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: PPUSH
14618: CALL_OW 69
14622: PUSH
14623: LD_INT 0
14625: EQUAL
14626: AND
14627: IFFALSE 14663
14629: PUSH
14630: LD_INT 22
14632: PUSH
14633: LD_INT 3
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PUSH
14640: LD_INT 30
14642: PUSH
14643: LD_INT 1
14645: PUSH
14646: EMPTY
14647: LIST
14648: LIST
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: PPUSH
14654: CALL_OW 69
14658: PUSH
14659: LD_INT 0
14661: EQUAL
14662: AND
14663: IFFALSE 14901
14665: GO 14667
14667: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14668: LD_EXP 9
14672: PPUSH
14673: LD_STRING D
14675: PUSH
14676: LD_STRING I
14678: PUSH
14679: LD_STRING J
14681: PUSH
14682: LD_STRING S
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: LIST
14689: PUSH
14690: LD_EXP 25
14694: ARRAY
14695: STR
14696: PUSH
14697: LD_STRING -1-Win
14699: STR
14700: PPUSH
14701: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14705: LD_OWVAR 1
14709: PUSH
14710: LD_INT 315000
14712: PUSH
14713: LD_INT 273000
14715: PUSH
14716: LD_INT 231000
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: LIST
14723: PUSH
14724: LD_OWVAR 67
14728: ARRAY
14729: GREATEREQUAL
14730: IFFALSE 14745
// AddMedal ( med1 , - 1 ) else
14732: LD_STRING med1
14734: PPUSH
14735: LD_INT 1
14737: NEG
14738: PPUSH
14739: CALL_OW 101
14743: GO 14755
// AddMedal ( med1 , 1 ) ;
14745: LD_STRING med1
14747: PPUSH
14748: LD_INT 1
14750: PPUSH
14751: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14755: LD_EXP 22
14759: PUSH
14760: LD_INT 20
14762: PUSH
14763: LD_INT 15
14765: PUSH
14766: LD_INT 10
14768: PUSH
14769: EMPTY
14770: LIST
14771: LIST
14772: LIST
14773: PUSH
14774: LD_OWVAR 67
14778: ARRAY
14779: GREATEREQUAL
14780: IFFALSE 14795
// AddMedal ( med2 , - 1 ) else
14782: LD_STRING med2
14784: PPUSH
14785: LD_INT 1
14787: NEG
14788: PPUSH
14789: CALL_OW 101
14793: GO 14805
// AddMedal ( med2 , 1 ) ;
14795: LD_STRING med2
14797: PPUSH
14798: LD_INT 1
14800: PPUSH
14801: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14805: LD_INT 8
14807: PPUSH
14808: LD_INT 1
14810: PPUSH
14811: CALL_OW 81
14815: PUSH
14816: LD_INT 1
14818: EQUAL
14819: IFFALSE 14833
// AddMedal ( med3 , 1 ) else
14821: LD_STRING med3
14823: PPUSH
14824: LD_INT 1
14826: PPUSH
14827: CALL_OW 101
14831: GO 14890
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14833: LD_INT 22
14835: PUSH
14836: LD_INT 8
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PUSH
14843: LD_INT 21
14845: PUSH
14846: LD_INT 1
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: PPUSH
14857: CALL_OW 69
14861: PUSH
14862: LD_INT 0
14864: EQUAL
14865: IFFALSE 14879
// AddMedal ( med3 , 2 ) else
14867: LD_STRING med3
14869: PPUSH
14870: LD_INT 2
14872: PPUSH
14873: CALL_OW 101
14877: GO 14890
// AddMedal ( med3 , - 1 ) ;
14879: LD_STRING med3
14881: PPUSH
14882: LD_INT 1
14884: NEG
14885: PPUSH
14886: CALL_OW 101
// GiveMedals ( MAIN ) ;
14890: LD_STRING MAIN
14892: PPUSH
14893: CALL_OW 102
// YouWin ;
14897: CALL_OW 103
// end ;
14901: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14902: LD_EXP 2
14906: PUSH
14907: LD_INT 1
14909: EQUAL
14910: IFFALSE 14918
14912: PUSH
14913: LD_EXP 16
14917: AND
14918: IFFALSE 14939
14920: PUSH
14921: LD_INT 20
14923: PPUSH
14924: LD_INT 81
14926: PUSH
14927: LD_INT 8
14929: PUSH
14930: EMPTY
14931: LIST
14932: LIST
14933: PPUSH
14934: CALL_OW 70
14938: AND
14939: IFFALSE 15220
14941: GO 14943
14943: DISABLE
14944: LD_INT 0
14946: PPUSH
14947: PPUSH
14948: PPUSH
14949: PPUSH
14950: PPUSH
// begin enable ;
14951: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14952: LD_ADDR_VAR 0 3
14956: PUSH
14957: LD_INT 20
14959: PPUSH
14960: LD_INT 81
14962: PUSH
14963: LD_INT 8
14965: PUSH
14966: EMPTY
14967: LIST
14968: LIST
14969: PPUSH
14970: CALL_OW 70
14974: ST_TO_ADDR
// if not tmp then
14975: LD_VAR 0 3
14979: NOT
14980: IFFALSE 14984
// exit ;
14982: GO 15220
// for i in tmp do
14984: LD_ADDR_VAR 0 1
14988: PUSH
14989: LD_VAR 0 3
14993: PUSH
14994: FOR_IN
14995: IFFALSE 15218
// begin x := GetX ( i ) ;
14997: LD_ADDR_VAR 0 4
15001: PUSH
15002: LD_VAR 0 1
15006: PPUSH
15007: CALL_OW 250
15011: ST_TO_ADDR
// y := GetY ( i ) ;
15012: LD_ADDR_VAR 0 5
15016: PUSH
15017: LD_VAR 0 1
15021: PPUSH
15022: CALL_OW 251
15026: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15027: LD_VAR 0 4
15031: PPUSH
15032: LD_VAR 0 5
15036: PPUSH
15037: CALL_OW 458
15041: IFFALSE 15216
// begin LaunchMineAtPos ( x , y , 8 ) ;
15043: LD_VAR 0 4
15047: PPUSH
15048: LD_VAR 0 5
15052: PPUSH
15053: LD_INT 8
15055: PPUSH
15056: CALL_OW 456
// if not dialogueMineDetected then
15060: LD_EXP 28
15064: NOT
15065: IFFALSE 15126
// begin dialogueMineDetected := true ;
15067: LD_ADDR_EXP 28
15071: PUSH
15072: LD_INT 1
15074: ST_TO_ADDR
// CenterNowOnXY ( x , y ) ;
15075: LD_VAR 0 4
15079: PPUSH
15080: LD_VAR 0 5
15084: PPUSH
15085: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15089: LD_EXP 9
15093: PPUSH
15094: LD_STRING D
15096: PUSH
15097: LD_STRING I
15099: PUSH
15100: LD_STRING J
15102: PUSH
15103: LD_STRING S
15105: PUSH
15106: EMPTY
15107: LIST
15108: LIST
15109: LIST
15110: PUSH
15111: LD_EXP 25
15115: ARRAY
15116: STR
15117: PUSH
15118: LD_STRING -1-Mine
15120: STR
15121: PPUSH
15122: CALL_OW 88
// end ; for j = 1 to staticMines do
15126: LD_ADDR_VAR 0 2
15130: PUSH
15131: DOUBLE
15132: LD_INT 1
15134: DEC
15135: ST_TO_ADDR
15136: LD_EXP 16
15140: PUSH
15141: FOR_TO
15142: IFFALSE 15214
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15144: LD_EXP 16
15148: PUSH
15149: LD_VAR 0 2
15153: ARRAY
15154: PUSH
15155: LD_INT 1
15157: ARRAY
15158: PUSH
15159: LD_VAR 0 4
15163: EQUAL
15164: IFFALSE 15188
15166: PUSH
15167: LD_EXP 16
15171: PUSH
15172: LD_VAR 0 2
15176: ARRAY
15177: PUSH
15178: LD_INT 2
15180: ARRAY
15181: PUSH
15182: LD_VAR 0 5
15186: EQUAL
15187: AND
15188: IFFALSE 15212
// begin staticMines := Delete ( staticMines , j ) ;
15190: LD_ADDR_EXP 16
15194: PUSH
15195: LD_EXP 16
15199: PPUSH
15200: LD_VAR 0 2
15204: PPUSH
15205: CALL_OW 3
15209: ST_TO_ADDR
// break ;
15210: GO 15214
// end ;
15212: GO 15141
15214: POP
15215: POP
// end ; end ;
15216: GO 14994
15218: POP
15219: POP
// end ;
15220: PPOPN 5
15222: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15223: LD_EXP 2
15227: PUSH
15228: LD_INT 1
15230: EQUAL
15231: IFFALSE 15239
15233: PUSH
15234: LD_EXP 3
15238: AND
15239: IFFALSE 15247
15241: PUSH
15242: LD_EXP 23
15246: AND
15247: IFFALSE 15276
15249: PUSH
15250: LD_EXP 31
15254: PUSH
15255: LD_EXP 7
15259: ARRAY
15260: PPUSH
15261: LD_INT 30
15263: PUSH
15264: LD_INT 3
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 72
15275: AND
15276: IFFALSE 15480
15278: GO 15280
15280: DISABLE
15281: LD_INT 0
15283: PPUSH
15284: PPUSH
// begin enable ;
15285: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15286: LD_EXP 7
15290: PPUSH
15291: LD_INT 23
15293: PUSH
15294: LD_INT 3
15296: PUSH
15297: LD_INT 3
15299: PUSH
15300: LD_INT 48
15302: PUSH
15303: EMPTY
15304: LIST
15305: LIST
15306: LIST
15307: LIST
15308: PUSH
15309: EMPTY
15310: LIST
15311: PPUSH
15312: CALL 88003 0 2
// repeat wait ( 0 0$1 ) ;
15316: LD_INT 35
15318: PPUSH
15319: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15323: LD_INT 22
15325: PUSH
15326: LD_INT 3
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: PUSH
15333: LD_INT 34
15335: PUSH
15336: LD_INT 48
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PPUSH
15347: CALL_OW 69
15351: IFFALSE 15316
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15353: LD_ADDR_VAR 0 1
15357: PUSH
15358: LD_INT 22
15360: PUSH
15361: LD_INT 3
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: PUSH
15368: LD_INT 34
15370: PUSH
15371: LD_INT 48
15373: PUSH
15374: EMPTY
15375: LIST
15376: LIST
15377: PUSH
15378: EMPTY
15379: LIST
15380: LIST
15381: PPUSH
15382: CALL_OW 69
15386: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15387: LD_ADDR_VAR 0 2
15391: PUSH
15392: LD_INT 81
15394: PUSH
15395: LD_INT 3
15397: PUSH
15398: EMPTY
15399: LIST
15400: LIST
15401: PUSH
15402: LD_INT 21
15404: PUSH
15405: LD_INT 3
15407: PUSH
15408: EMPTY
15409: LIST
15410: LIST
15411: PUSH
15412: EMPTY
15413: LIST
15414: LIST
15415: PPUSH
15416: CALL_OW 69
15420: ST_TO_ADDR
// if e then
15421: LD_VAR 0 2
15425: IFFALSE 15451
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15427: LD_ADDR_VAR 0 2
15431: PUSH
15432: LD_VAR 0 2
15436: PPUSH
15437: LD_VAR 0 1
15441: PUSH
15442: LD_INT 1
15444: ARRAY
15445: PPUSH
15446: CALL_OW 74
15450: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15451: LD_VAR 0 1
15455: PPUSH
15456: LD_VAR 0 2
15460: PPUSH
15461: CALL_OW 250
15465: PPUSH
15466: LD_VAR 0 2
15470: PPUSH
15471: CALL_OW 251
15475: PPUSH
15476: CALL_OW 116
// end ;
15480: PPOPN 2
15482: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15483: LD_OWVAR 67
15487: PUSH
15488: LD_INT 1
15490: GREATER
15491: IFFALSE 15520
15493: PUSH
15494: LD_EXP 31
15498: PUSH
15499: LD_EXP 7
15503: ARRAY
15504: PPUSH
15505: LD_INT 25
15507: PUSH
15508: LD_INT 3
15510: PUSH
15511: EMPTY
15512: LIST
15513: LIST
15514: PPUSH
15515: CALL_OW 72
15519: AND
15520: IFFALSE 15532
15522: PUSH
15523: LD_EXP 2
15527: PUSH
15528: LD_INT 1
15530: EQUAL
15531: AND
15532: IFFALSE 15540
15534: PUSH
15535: LD_EXP 3
15539: AND
15540: IFFALSE 15558
15542: PUSH
15543: LD_INT 23
15545: PPUSH
15546: LD_INT 3
15548: PPUSH
15549: CALL_OW 321
15553: PUSH
15554: LD_INT 2
15556: EQUAL
15557: AND
15558: IFFALSE 15685
15560: GO 15562
15562: DISABLE
15563: LD_INT 0
15565: PPUSH
15566: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15567: LD_ADDR_VAR 0 1
15571: PUSH
15572: LD_EXP 31
15576: PUSH
15577: LD_EXP 7
15581: ARRAY
15582: PPUSH
15583: LD_INT 25
15585: PUSH
15586: LD_INT 3
15588: PUSH
15589: EMPTY
15590: LIST
15591: LIST
15592: PPUSH
15593: CALL_OW 72
15597: ST_TO_ADDR
// if not tmp then
15598: LD_VAR 0 1
15602: NOT
15603: IFFALSE 15607
// exit ;
15605: GO 15685
// for i in tmp do
15607: LD_ADDR_VAR 0 2
15611: PUSH
15612: LD_VAR 0 1
15616: PUSH
15617: FOR_IN
15618: IFFALSE 15664
// begin SetTag ( i , 29 ) ;
15620: LD_VAR 0 2
15624: PPUSH
15625: LD_INT 29
15627: PPUSH
15628: CALL_OW 109
// ComExitBuilding ( i ) ;
15632: LD_VAR 0 2
15636: PPUSH
15637: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15641: LD_VAR 0 2
15645: PPUSH
15646: LD_INT 37
15648: PPUSH
15649: LD_INT 97
15651: PPUSH
15652: LD_INT 133
15654: PPUSH
15655: LD_INT 0
15657: PPUSH
15658: CALL_OW 230
// end ;
15662: GO 15617
15664: POP
15665: POP
// wait ( 1 1$00 ) ;
15666: LD_INT 2100
15668: PPUSH
15669: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15673: LD_EXP 7
15677: PPUSH
15678: LD_INT 29
15680: PPUSH
15681: CALL 67634 0 2
// end ;
15685: PPOPN 2
15687: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15688: LD_EXP 2
15692: PUSH
15693: LD_INT 1
15695: EQUAL
15696: IFFALSE 15719
15698: PUSH
15699: LD_INT 84
15701: PPUSH
15702: LD_INT 128
15704: PPUSH
15705: CALL_OW 428
15709: PPUSH
15710: CALL_OW 266
15714: PUSH
15715: LD_INT 1
15717: EQUAL
15718: AND
15719: IFFALSE 15742
15721: PUSH
15722: LD_INT 84
15724: PPUSH
15725: LD_INT 128
15727: PPUSH
15728: CALL_OW 428
15732: PPUSH
15733: CALL_OW 255
15737: PUSH
15738: LD_INT 3
15740: EQUAL
15741: AND
15742: IFFALSE 15915
15744: GO 15746
15746: DISABLE
15747: LD_INT 0
15749: PPUSH
15750: PPUSH
// begin enable ;
15751: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15752: LD_ADDR_VAR 0 2
15756: PUSH
15757: LD_INT 84
15759: PPUSH
15760: LD_INT 128
15762: PPUSH
15763: CALL_OW 428
15767: ST_TO_ADDR
// uc_side := 3 ;
15768: LD_ADDR_OWVAR 20
15772: PUSH
15773: LD_INT 3
15775: ST_TO_ADDR
// uc_nation := 3 ;
15776: LD_ADDR_OWVAR 21
15780: PUSH
15781: LD_INT 3
15783: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15784: LD_INT 21
15786: PPUSH
15787: LD_INT 3
15789: PPUSH
15790: LD_INT 3
15792: PPUSH
15793: LD_INT 51
15795: PPUSH
15796: LD_INT 0
15798: PPUSH
15799: CALL 24941 0 5
// veh := CreateVehicle ;
15803: LD_ADDR_VAR 0 1
15807: PUSH
15808: CALL_OW 45
15812: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15813: LD_VAR 0 1
15817: PPUSH
15818: LD_INT 126
15820: PPUSH
15821: LD_INT 227
15823: PPUSH
15824: LD_INT 0
15826: PPUSH
15827: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15831: LD_VAR 0 1
15835: PPUSH
15836: LD_INT 2
15838: PPUSH
15839: LD_INT 100
15841: PPUSH
15842: CALL_OW 290
// ComGive ( veh , depot ) ;
15846: LD_VAR 0 1
15850: PPUSH
15851: LD_VAR 0 2
15855: PPUSH
15856: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15860: LD_VAR 0 1
15864: PPUSH
15865: LD_INT 126
15867: PPUSH
15868: LD_INT 227
15870: PPUSH
15871: CALL_OW 171
// wait ( 0 0$10 ) ;
15875: LD_INT 350
15877: PPUSH
15878: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15882: LD_INT 35
15884: PPUSH
15885: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15889: LD_VAR 0 1
15893: PPUSH
15894: LD_INT 126
15896: PPUSH
15897: LD_INT 227
15899: PPUSH
15900: CALL_OW 307
15904: IFFALSE 15882
// RemoveUnit ( veh ) ;
15906: LD_VAR 0 1
15910: PPUSH
15911: CALL_OW 64
// end ;
15915: PPOPN 2
15917: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15918: LD_EXP 2
15922: PUSH
15923: LD_INT 1
15925: EQUAL
15926: IFFALSE 15934
15928: PUSH
15929: LD_EXP 27
15933: AND
15934: IFFALSE 15946
15936: PUSH
15937: LD_EXP 25
15941: PUSH
15942: LD_INT 2
15944: EQUAL
15945: AND
15946: IFFALSE 16138
15948: GO 15950
15950: DISABLE
15951: LD_INT 0
15953: PPUSH
15954: PPUSH
// begin enable ;
15955: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15956: LD_OWVAR 1
15960: PUSH
15961: LD_INT 105000
15963: PUSH
15964: LD_INT 84000
15966: PUSH
15967: LD_INT 63000
15969: PUSH
15970: EMPTY
15971: LIST
15972: LIST
15973: LIST
15974: PUSH
15975: LD_OWVAR 67
15979: ARRAY
15980: GREATEREQUAL
15981: IFFALSE 15984
// disable ;
15983: DISABLE
// uc_side := 4 ;
15984: LD_ADDR_OWVAR 20
15988: PUSH
15989: LD_INT 4
15991: ST_TO_ADDR
// uc_nation := 1 ;
15992: LD_ADDR_OWVAR 21
15996: PUSH
15997: LD_INT 1
15999: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
16000: LD_INT 2
16002: PPUSH
16003: LD_INT 3
16005: PPUSH
16006: LD_INT 3
16008: PPUSH
16009: LD_INT 12
16011: PPUSH
16012: LD_INT 0
16014: PPUSH
16015: CALL 24941 0 5
// veh := CreateVehicle ;
16019: LD_ADDR_VAR 0 1
16023: PUSH
16024: CALL_OW 45
16028: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
16029: LD_VAR 0 1
16033: PPUSH
16034: LD_INT 229
16036: PPUSH
16037: LD_INT 226
16039: PPUSH
16040: LD_INT 0
16042: PPUSH
16043: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16047: LD_VAR 0 1
16051: PPUSH
16052: LD_INT 1
16054: PPUSH
16055: LD_INT 100
16057: PPUSH
16058: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16062: LD_VAR 0 1
16066: PPUSH
16067: LD_INT 25
16069: PPUSH
16070: CALL_OW 173
// AddComUnload ( veh ) ;
16074: LD_VAR 0 1
16078: PPUSH
16079: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16083: LD_VAR 0 1
16087: PPUSH
16088: LD_INT 229
16090: PPUSH
16091: LD_INT 226
16093: PPUSH
16094: CALL_OW 171
// wait ( 0 0$10 ) ;
16098: LD_INT 350
16100: PPUSH
16101: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16105: LD_INT 35
16107: PPUSH
16108: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16112: LD_VAR 0 1
16116: PPUSH
16117: LD_INT 229
16119: PPUSH
16120: LD_INT 226
16122: PPUSH
16123: CALL_OW 307
16127: IFFALSE 16105
// RemoveUnit ( veh ) ;
16129: LD_VAR 0 1
16133: PPUSH
16134: CALL_OW 64
// end ;
16138: PPOPN 2
16140: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16141: LD_EXP 2
16145: PUSH
16146: LD_INT 1
16148: EQUAL
16149: IFFALSE 16157
16151: PUSH
16152: LD_EXP 3
16156: AND
16157: IFFALSE 16165
16159: PUSH
16160: LD_EXP 24
16164: AND
16165: IFFALSE 16498
16167: GO 16169
16169: DISABLE
16170: LD_INT 0
16172: PPUSH
16173: PPUSH
16174: PPUSH
16175: PPUSH
16176: PPUSH
// begin enable ;
16177: ENABLE
// tmp := [ ] ;
16178: LD_ADDR_VAR 0 4
16182: PUSH
16183: EMPTY
16184: ST_TO_ADDR
// if commander = 1 then
16185: LD_EXP 25
16189: PUSH
16190: LD_INT 1
16192: EQUAL
16193: IFFALSE 16205
// amount := 3 else
16195: LD_ADDR_VAR 0 5
16199: PUSH
16200: LD_INT 3
16202: ST_TO_ADDR
16203: GO 16213
// amount := 2 ;
16205: LD_ADDR_VAR 0 5
16209: PUSH
16210: LD_INT 2
16212: ST_TO_ADDR
// for i = 1 to amount do
16213: LD_ADDR_VAR 0 1
16217: PUSH
16218: DOUBLE
16219: LD_INT 1
16221: DEC
16222: ST_TO_ADDR
16223: LD_VAR 0 5
16227: PUSH
16228: FOR_TO
16229: IFFALSE 16393
// begin wait ( 0 0$5 ) ;
16231: LD_INT 175
16233: PPUSH
16234: CALL_OW 67
// for j = 1 to 3 do
16238: LD_ADDR_VAR 0 2
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_INT 3
16250: PUSH
16251: FOR_TO
16252: IFFALSE 16389
// begin uc_side := 4 ;
16254: LD_ADDR_OWVAR 20
16258: PUSH
16259: LD_INT 4
16261: ST_TO_ADDR
// uc_nation := 1 ;
16262: LD_ADDR_OWVAR 21
16266: PUSH
16267: LD_INT 1
16269: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16270: LD_INT 3
16272: PUSH
16273: LD_INT 5
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: PUSH
16280: LD_INT 1
16282: PPUSH
16283: LD_INT 2
16285: PPUSH
16286: CALL_OW 12
16290: ARRAY
16291: PPUSH
16292: LD_INT 3
16294: PPUSH
16295: LD_INT 3
16297: PPUSH
16298: LD_INT 9
16300: PUSH
16301: LD_INT 5
16303: PUSH
16304: LD_INT 7
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: LIST
16311: PUSH
16312: LD_INT 1
16314: PPUSH
16315: LD_INT 3
16317: PPUSH
16318: CALL_OW 12
16322: ARRAY
16323: PPUSH
16324: LD_INT 100
16326: PPUSH
16327: CALL 24941 0 5
// veh := CreateVehicle ;
16331: LD_ADDR_VAR 0 3
16335: PUSH
16336: CALL_OW 45
16340: ST_TO_ADDR
// tmp := tmp ^ veh ;
16341: LD_ADDR_VAR 0 4
16345: PUSH
16346: LD_VAR 0 4
16350: PUSH
16351: LD_VAR 0 3
16355: ADD
16356: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16357: LD_VAR 0 3
16361: PPUSH
16362: LD_INT 22
16364: PPUSH
16365: LD_INT 0
16367: PPUSH
16368: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16372: LD_VAR 0 3
16376: PPUSH
16377: LD_INT 119
16379: PPUSH
16380: LD_INT 215
16382: PPUSH
16383: CALL_OW 111
// end ;
16387: GO 16251
16389: POP
16390: POP
// end ;
16391: GO 16228
16393: POP
16394: POP
// wait ( 0 0$3 ) ;
16395: LD_INT 105
16397: PPUSH
16398: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16402: LD_INT 35
16404: PPUSH
16405: CALL_OW 67
// for i in tmp do
16409: LD_ADDR_VAR 0 1
16413: PUSH
16414: LD_VAR 0 4
16418: PUSH
16419: FOR_IN
16420: IFFALSE 16487
// if IsDead ( i ) then
16422: LD_VAR 0 1
16426: PPUSH
16427: CALL_OW 301
16431: IFFALSE 16451
// tmp := tmp diff i else
16433: LD_ADDR_VAR 0 4
16437: PUSH
16438: LD_VAR 0 4
16442: PUSH
16443: LD_VAR 0 1
16447: DIFF
16448: ST_TO_ADDR
16449: GO 16485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_INT 81
16458: PUSH
16459: LD_INT 4
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PPUSH
16466: CALL_OW 69
16470: PPUSH
16471: LD_VAR 0 1
16475: PPUSH
16476: CALL_OW 74
16480: PPUSH
16481: CALL_OW 115
16485: GO 16419
16487: POP
16488: POP
// until tmp = [ ] ;
16489: LD_VAR 0 4
16493: PUSH
16494: EMPTY
16495: EQUAL
16496: IFFALSE 16402
// end ;
16498: PPOPN 5
16500: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16501: LD_EXP 2
16505: PUSH
16506: LD_INT 1
16508: EQUAL
16509: IFFALSE 16517
16511: PUSH
16512: LD_EXP 3
16516: AND
16517: IFFALSE 16618
16519: GO 16521
16521: DISABLE
16522: LD_INT 0
16524: PPUSH
16525: PPUSH
// begin enable ;
16526: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16527: LD_ADDR_VAR 0 2
16531: PUSH
16532: LD_INT 3
16534: PUSH
16535: LD_INT 22
16537: PUSH
16538: LD_INT 1
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: LD_INT 32
16551: PUSH
16552: LD_INT 1
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PUSH
16559: EMPTY
16560: LIST
16561: LIST
16562: PPUSH
16563: CALL_OW 69
16567: ST_TO_ADDR
// if tmp then
16568: LD_VAR 0 2
16572: IFFALSE 16618
// for i in tmp do
16574: LD_ADDR_VAR 0 1
16578: PUSH
16579: LD_VAR 0 2
16583: PUSH
16584: FOR_IN
16585: IFFALSE 16616
// if GetFuel ( i ) < 3 then
16587: LD_VAR 0 1
16591: PPUSH
16592: CALL_OW 261
16596: PUSH
16597: LD_INT 3
16599: LESS
16600: IFFALSE 16614
// SetFuel ( i , 3 ) ;
16602: LD_VAR 0 1
16606: PPUSH
16607: LD_INT 3
16609: PPUSH
16610: CALL_OW 240
16614: GO 16584
16616: POP
16617: POP
// end ;
16618: PPOPN 2
16620: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16621: LD_EXP 3
16625: IFFALSE 16643
16627: PUSH
16628: LD_INT 8
16630: PPUSH
16631: LD_INT 4
16633: PPUSH
16634: CALL_OW 81
16638: PUSH
16639: LD_INT 2
16641: EQUAL
16642: AND
16643: IFFALSE 16853
16645: GO 16647
16647: DISABLE
16648: LD_INT 0
16650: PPUSH
16651: PPUSH
16652: PPUSH
// begin enable ;
16653: ENABLE
// tmp := [ ] ;
16654: LD_ADDR_VAR 0 3
16658: PUSH
16659: EMPTY
16660: ST_TO_ADDR
// for i = 1 to 4 do
16661: LD_ADDR_VAR 0 1
16665: PUSH
16666: DOUBLE
16667: LD_INT 1
16669: DEC
16670: ST_TO_ADDR
16671: LD_INT 4
16673: PUSH
16674: FOR_TO
16675: IFFALSE 16819
// begin uc_side := 8 ;
16677: LD_ADDR_OWVAR 20
16681: PUSH
16682: LD_INT 8
16684: ST_TO_ADDR
// uc_nation := nation_arabian ;
16685: LD_ADDR_OWVAR 21
16689: PUSH
16690: LD_INT 2
16692: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16693: LD_INT 11
16695: PPUSH
16696: LD_INT 1
16698: PPUSH
16699: LD_INT 5
16701: PPUSH
16702: LD_INT 24
16704: PUSH
16705: LD_INT 23
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: PUSH
16712: LD_INT 1
16714: PPUSH
16715: LD_INT 2
16717: PPUSH
16718: CALL_OW 12
16722: ARRAY
16723: PPUSH
16724: LD_INT 60
16726: PPUSH
16727: LD_INT 80
16729: PPUSH
16730: CALL_OW 12
16734: PPUSH
16735: CALL 24941 0 5
// un := CreateVehicle ;
16739: LD_ADDR_VAR 0 2
16743: PUSH
16744: CALL_OW 45
16748: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16749: LD_VAR 0 2
16753: PPUSH
16754: LD_INT 2
16756: PPUSH
16757: CALL_OW 233
// tmp := tmp ^ un ;
16761: LD_ADDR_VAR 0 3
16765: PUSH
16766: LD_VAR 0 3
16770: PUSH
16771: LD_VAR 0 2
16775: ADD
16776: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16777: LD_VAR 0 2
16781: PPUSH
16782: LD_INT 88
16784: PPUSH
16785: LD_INT 2
16787: PPUSH
16788: LD_INT 0
16790: PPUSH
16791: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16795: LD_VAR 0 2
16799: PPUSH
16800: LD_INT 93
16802: PPUSH
16803: LD_INT 13
16805: PPUSH
16806: CALL_OW 111
// wait ( 0 0$2 ) ;
16810: LD_INT 70
16812: PPUSH
16813: CALL_OW 67
// end ;
16817: GO 16674
16819: POP
16820: POP
// for i in tmp do
16821: LD_ADDR_VAR 0 1
16825: PUSH
16826: LD_VAR 0 3
16830: PUSH
16831: FOR_IN
16832: IFFALSE 16851
// AddComMoveXY ( i , 136 , 19 ) ;
16834: LD_VAR 0 1
16838: PPUSH
16839: LD_INT 136
16841: PPUSH
16842: LD_INT 19
16844: PPUSH
16845: CALL_OW 171
16849: GO 16831
16851: POP
16852: POP
// end ;
16853: PPOPN 3
16855: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16856: LD_EXP 3
16860: IFFALSE 17781
16862: GO 16864
16864: DISABLE
16865: LD_INT 0
16867: PPUSH
16868: PPUSH
16869: PPUSH
16870: PPUSH
// begin enable ;
16871: ENABLE
// base := mc_leg ;
16872: LD_ADDR_VAR 0 2
16876: PUSH
16877: LD_EXP 6
16881: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16882: LD_INT 22
16884: PUSH
16885: LD_INT 8
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: PUSH
16892: LD_INT 23
16894: PUSH
16895: LD_INT 2
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: PUSH
16902: LD_INT 30
16904: PUSH
16905: LD_INT 3
16907: PUSH
16908: EMPTY
16909: LIST
16910: LIST
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: PPUSH
16917: CALL_OW 69
16921: NOT
16922: IFFALSE 16926
// exit ;
16924: GO 17781
// if Prob ( 40 ) then
16926: LD_INT 40
16928: PPUSH
16929: CALL_OW 13
16933: IFFALSE 17062
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16935: LD_VAR 0 2
16939: PPUSH
16940: LD_INT 13
16942: PUSH
16943: LD_INT 1
16945: PUSH
16946: LD_INT 2
16948: PUSH
16949: LD_INT 28
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: PUSH
16958: LD_INT 13
16960: PUSH
16961: LD_INT 1
16963: PUSH
16964: LD_INT 2
16966: PUSH
16967: LD_INT 28
16969: PUSH
16970: EMPTY
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: PUSH
16976: LD_INT 13
16978: PUSH
16979: LD_INT 1
16981: PUSH
16982: LD_INT 2
16984: PUSH
16985: LD_INT 28
16987: PUSH
16988: EMPTY
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: PUSH
16994: LD_INT 13
16996: PUSH
16997: LD_INT 1
16999: PUSH
17000: LD_INT 2
17002: PUSH
17003: LD_INT 28
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: PUSH
17012: LD_INT 13
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: LD_INT 2
17020: PUSH
17021: LD_INT 28
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: LIST
17028: LIST
17029: PUSH
17030: LD_INT 13
17032: PUSH
17033: LD_INT 1
17035: PUSH
17036: LD_INT 2
17038: PUSH
17039: LD_INT 26
17041: PUSH
17042: EMPTY
17043: LIST
17044: LIST
17045: LIST
17046: LIST
17047: PUSH
17048: EMPTY
17049: LIST
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: LIST
17055: PPUSH
17056: CALL 88003 0 2
// end else
17060: GO 17279
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17062: LD_VAR 0 2
17066: PPUSH
17067: LD_INT 13
17069: PUSH
17070: LD_INT 1
17072: PUSH
17073: LD_INT 2
17075: PUSH
17076: LD_INT 27
17078: PUSH
17079: LD_INT 26
17081: PUSH
17082: LD_INT 26
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PUSH
17090: LD_INT 1
17092: PPUSH
17093: LD_INT 3
17095: PPUSH
17096: CALL_OW 12
17100: ARRAY
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: PUSH
17108: LD_INT 13
17110: PUSH
17111: LD_INT 1
17113: PUSH
17114: LD_INT 2
17116: PUSH
17117: LD_INT 27
17119: PUSH
17120: LD_INT 26
17122: PUSH
17123: LD_INT 26
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: LIST
17130: PUSH
17131: LD_INT 1
17133: PPUSH
17134: LD_INT 3
17136: PPUSH
17137: CALL_OW 12
17141: ARRAY
17142: PUSH
17143: EMPTY
17144: LIST
17145: LIST
17146: LIST
17147: LIST
17148: PUSH
17149: LD_INT 13
17151: PUSH
17152: LD_INT 1
17154: PUSH
17155: LD_INT 2
17157: PUSH
17158: LD_INT 26
17160: PUSH
17161: LD_INT 26
17163: PUSH
17164: LD_INT 29
17166: PUSH
17167: EMPTY
17168: LIST
17169: LIST
17170: LIST
17171: PUSH
17172: LD_INT 1
17174: PPUSH
17175: LD_INT 3
17177: PPUSH
17178: CALL_OW 12
17182: ARRAY
17183: PUSH
17184: EMPTY
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: PUSH
17190: LD_INT 13
17192: PUSH
17193: LD_INT 1
17195: PUSH
17196: LD_INT 2
17198: PUSH
17199: LD_INT 26
17201: PUSH
17202: LD_INT 29
17204: PUSH
17205: LD_INT 29
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: LIST
17212: PUSH
17213: LD_INT 1
17215: PPUSH
17216: LD_INT 3
17218: PPUSH
17219: CALL_OW 12
17223: ARRAY
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: LIST
17230: PUSH
17231: LD_INT 13
17233: PUSH
17234: LD_INT 1
17236: PUSH
17237: LD_INT 2
17239: PUSH
17240: LD_INT 29
17242: PUSH
17243: EMPTY
17244: LIST
17245: LIST
17246: LIST
17247: LIST
17248: PUSH
17249: LD_INT 13
17251: PUSH
17252: LD_INT 1
17254: PUSH
17255: LD_INT 2
17257: PUSH
17258: LD_INT 26
17260: PUSH
17261: EMPTY
17262: LIST
17263: LIST
17264: LIST
17265: LIST
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: LIST
17271: LIST
17272: LIST
17273: LIST
17274: PPUSH
17275: CALL 88003 0 2
// end ; repeat wait ( 0 0$1 ) ;
17279: LD_INT 35
17281: PPUSH
17282: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17286: LD_VAR 0 2
17290: PPUSH
17291: LD_INT 1
17293: PPUSH
17294: CALL 89459 0 2
17298: PUSH
17299: LD_INT 6
17301: GREATEREQUAL
17302: IFTRUE 17318
17304: PUSH
17305: LD_OWVAR 1
17309: PUSH
17310: LD_INT 21000
17312: MOD
17313: PUSH
17314: LD_INT 0
17316: EQUAL
17317: OR
17318: IFFALSE 17279
// wait ( 0 0$30 ) ;
17320: LD_INT 1050
17322: PPUSH
17323: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17327: LD_ADDR_VAR 0 3
17331: PUSH
17332: LD_VAR 0 2
17336: PPUSH
17337: LD_INT 1
17339: PPUSH
17340: CALL 89459 0 2
17344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17345: LD_ADDR_EXP 50
17349: PUSH
17350: LD_EXP 50
17354: PPUSH
17355: LD_VAR 0 2
17359: PPUSH
17360: LD_EXP 50
17364: PUSH
17365: LD_VAR 0 2
17369: ARRAY
17370: PUSH
17371: LD_VAR 0 3
17375: DIFF
17376: PPUSH
17377: CALL_OW 1
17381: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17382: LD_ADDR_VAR 0 4
17386: PUSH
17387: LD_INT 0
17389: PPUSH
17390: LD_INT 2
17392: PPUSH
17393: CALL_OW 12
17397: ST_TO_ADDR
// if legChangeSide then
17398: LD_EXP 21
17402: IFFALSE 17412
// target := 2 ;
17404: LD_ADDR_VAR 0 4
17408: PUSH
17409: LD_INT 2
17411: ST_TO_ADDR
// if target = 2 then
17412: LD_VAR 0 4
17416: PUSH
17417: LD_INT 2
17419: EQUAL
17420: IFFALSE 17548
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17422: LD_ADDR_VAR 0 3
17426: PUSH
17427: LD_VAR 0 3
17431: PPUSH
17432: LD_INT 24
17434: PUSH
17435: LD_INT 250
17437: PUSH
17438: EMPTY
17439: LIST
17440: LIST
17441: PPUSH
17442: CALL_OW 72
17446: ST_TO_ADDR
// for i in tmp do
17447: LD_ADDR_VAR 0 1
17451: PUSH
17452: LD_VAR 0 3
17456: PUSH
17457: FOR_IN
17458: IFFALSE 17498
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17460: LD_VAR 0 1
17464: PPUSH
17465: LD_INT 112
17467: PPUSH
17468: LD_INT 64
17470: PPUSH
17471: CALL_OW 297
17475: PUSH
17476: LD_INT 9
17478: GREATER
17479: IFFALSE 17496
// ComMoveXY ( i , 112 , 64 ) ;
17481: LD_VAR 0 1
17485: PPUSH
17486: LD_INT 112
17488: PPUSH
17489: LD_INT 64
17491: PPUSH
17492: CALL_OW 111
17496: GO 17457
17498: POP
17499: POP
// wait ( 0 0$1 ) ;
17500: LD_INT 35
17502: PPUSH
17503: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17507: LD_VAR 0 3
17511: PPUSH
17512: LD_INT 92
17514: PUSH
17515: LD_INT 112
17517: PUSH
17518: LD_INT 64
17520: PUSH
17521: LD_INT 9
17523: PUSH
17524: EMPTY
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: PPUSH
17530: CALL_OW 72
17534: PUSH
17535: LD_VAR 0 3
17539: PUSH
17540: LD_INT 1
17542: MINUS
17543: GREATEREQUAL
17544: IFFALSE 17422
// end else
17546: GO 17672
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17548: LD_ADDR_VAR 0 3
17552: PUSH
17553: LD_VAR 0 3
17557: PPUSH
17558: LD_INT 24
17560: PUSH
17561: LD_INT 250
17563: PUSH
17564: EMPTY
17565: LIST
17566: LIST
17567: PPUSH
17568: CALL_OW 72
17572: ST_TO_ADDR
// for i in tmp do
17573: LD_ADDR_VAR 0 1
17577: PUSH
17578: LD_VAR 0 3
17582: PUSH
17583: FOR_IN
17584: IFFALSE 17624
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17586: LD_VAR 0 1
17590: PPUSH
17591: LD_INT 174
17593: PPUSH
17594: LD_INT 94
17596: PPUSH
17597: CALL_OW 297
17601: PUSH
17602: LD_INT 9
17604: GREATER
17605: IFFALSE 17622
// ComMoveXY ( i , 174 , 94 ) ;
17607: LD_VAR 0 1
17611: PPUSH
17612: LD_INT 174
17614: PPUSH
17615: LD_INT 94
17617: PPUSH
17618: CALL_OW 111
17622: GO 17583
17624: POP
17625: POP
// wait ( 0 0$1 ) ;
17626: LD_INT 35
17628: PPUSH
17629: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17633: LD_VAR 0 3
17637: PPUSH
17638: LD_INT 92
17640: PUSH
17641: LD_INT 174
17643: PUSH
17644: LD_INT 94
17646: PUSH
17647: LD_INT 9
17649: PUSH
17650: EMPTY
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: PPUSH
17656: CALL_OW 72
17660: PUSH
17661: LD_VAR 0 3
17665: PUSH
17666: LD_INT 1
17668: MINUS
17669: GREATEREQUAL
17670: IFFALSE 17548
// end ; repeat wait ( 0 0$1 ) ;
17672: LD_INT 35
17674: PPUSH
17675: CALL_OW 67
// for i in tmp do
17679: LD_ADDR_VAR 0 1
17683: PUSH
17684: LD_VAR 0 3
17688: PUSH
17689: FOR_IN
17690: IFFALSE 17772
// begin if GetLives ( i ) > 251 then
17692: LD_VAR 0 1
17696: PPUSH
17697: CALL_OW 256
17701: PUSH
17702: LD_INT 251
17704: GREATER
17705: IFFALSE 17743
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17707: LD_VAR 0 1
17711: PPUSH
17712: LD_INT 81
17714: PUSH
17715: LD_INT 8
17717: PUSH
17718: EMPTY
17719: LIST
17720: LIST
17721: PPUSH
17722: CALL_OW 69
17726: PPUSH
17727: LD_VAR 0 1
17731: PPUSH
17732: CALL_OW 74
17736: PPUSH
17737: CALL_OW 115
17741: GO 17770
// if IsDead ( i ) then
17743: LD_VAR 0 1
17747: PPUSH
17748: CALL_OW 301
17752: IFFALSE 17770
// tmp := tmp diff i ;
17754: LD_ADDR_VAR 0 3
17758: PUSH
17759: LD_VAR 0 3
17763: PUSH
17764: LD_VAR 0 1
17768: DIFF
17769: ST_TO_ADDR
// end ;
17770: GO 17689
17772: POP
17773: POP
// until not tmp ;
17774: LD_VAR 0 3
17778: NOT
17779: IFFALSE 17672
// end ;
17781: PPOPN 4
17783: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17784: LD_EXP 3
17788: IFFALSE 18780
17790: GO 17792
17792: DISABLE
17793: LD_INT 0
17795: PPUSH
17796: PPUSH
17797: PPUSH
17798: PPUSH
17799: PPUSH
// begin enable ;
17800: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17801: LD_EXP 31
17805: PUSH
17806: LD_EXP 8
17810: ARRAY
17811: PPUSH
17812: LD_INT 22
17814: PUSH
17815: LD_INT 3
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: PUSH
17822: LD_INT 30
17824: PUSH
17825: LD_INT 3
17827: PUSH
17828: EMPTY
17829: LIST
17830: LIST
17831: PUSH
17832: EMPTY
17833: LIST
17834: LIST
17835: PPUSH
17836: CALL_OW 72
17840: NOT
17841: IFFALSE 17845
// exit ;
17843: GO 18780
// base := mc_rus_2 ;
17845: LD_ADDR_VAR 0 2
17849: PUSH
17850: LD_EXP 8
17854: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17855: LD_ADDR_VAR 0 5
17859: PUSH
17860: LD_INT 22
17862: PUSH
17863: LD_INT 3
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: PUSH
17870: LD_INT 30
17872: PUSH
17873: LD_INT 34
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: PPUSH
17884: CALL_OW 69
17888: ST_TO_ADDR
// if Prob ( 40 ) then
17889: LD_INT 40
17891: PPUSH
17892: CALL_OW 13
17896: IFFALSE 18025
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17898: LD_VAR 0 2
17902: PPUSH
17903: LD_INT 22
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: LD_INT 3
17911: PUSH
17912: LD_INT 49
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: LIST
17919: LIST
17920: PUSH
17921: LD_INT 22
17923: PUSH
17924: LD_INT 3
17926: PUSH
17927: LD_INT 3
17929: PUSH
17930: LD_INT 49
17932: PUSH
17933: EMPTY
17934: LIST
17935: LIST
17936: LIST
17937: LIST
17938: PUSH
17939: LD_INT 22
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 3
17947: PUSH
17948: LD_INT 49
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: LIST
17955: LIST
17956: PUSH
17957: LD_INT 24
17959: PUSH
17960: LD_INT 3
17962: PUSH
17963: LD_INT 3
17965: PUSH
17966: LD_INT 46
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 24
17977: PUSH
17978: LD_INT 3
17980: PUSH
17981: LD_INT 3
17983: PUSH
17984: LD_INT 46
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 24
17995: PUSH
17996: LD_INT 3
17998: PUSH
17999: LD_INT 3
18001: PUSH
18002: LD_INT 46
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: PPUSH
18019: CALL 88003 0 2
// end else
18023: GO 18150
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
18025: LD_VAR 0 2
18029: PPUSH
18030: LD_INT 24
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: LD_INT 3
18038: PUSH
18039: LD_INT 47
18041: PUSH
18042: EMPTY
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: PUSH
18048: LD_INT 24
18050: PUSH
18051: LD_INT 3
18053: PUSH
18054: LD_INT 3
18056: PUSH
18057: LD_INT 47
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: LIST
18065: PUSH
18066: LD_INT 24
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 3
18074: PUSH
18075: LD_INT 47
18077: PUSH
18078: EMPTY
18079: LIST
18080: LIST
18081: LIST
18082: LIST
18083: PUSH
18084: LD_INT 24
18086: PUSH
18087: LD_INT 3
18089: PUSH
18090: LD_INT 3
18092: PUSH
18093: LD_INT 46
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: LIST
18100: LIST
18101: PUSH
18102: LD_INT 24
18104: PUSH
18105: LD_INT 3
18107: PUSH
18108: LD_INT 3
18110: PUSH
18111: LD_INT 46
18113: PUSH
18114: EMPTY
18115: LIST
18116: LIST
18117: LIST
18118: LIST
18119: PUSH
18120: LD_INT 24
18122: PUSH
18123: LD_INT 3
18125: PUSH
18126: LD_INT 3
18128: PUSH
18129: LD_INT 46
18131: PUSH
18132: EMPTY
18133: LIST
18134: LIST
18135: LIST
18136: LIST
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: LIST
18142: LIST
18143: LIST
18144: LIST
18145: PPUSH
18146: CALL 88003 0 2
// end ; if Difficulty > 1 then
18150: LD_OWVAR 67
18154: PUSH
18155: LD_INT 1
18157: GREATER
18158: IFFALSE 18190
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18160: LD_VAR 0 2
18164: PPUSH
18165: LD_INT 24
18167: PUSH
18168: LD_INT 3
18170: PUSH
18171: LD_INT 3
18173: PUSH
18174: LD_INT 47
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: LIST
18181: LIST
18182: PUSH
18183: EMPTY
18184: LIST
18185: PPUSH
18186: CALL 88003 0 2
// repeat wait ( 0 0$1 ) ;
18190: LD_INT 35
18192: PPUSH
18193: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18197: LD_VAR 0 2
18201: PPUSH
18202: LD_INT 1
18204: PPUSH
18205: CALL 89459 0 2
18209: PUSH
18210: LD_INT 6
18212: PUSH
18213: LD_INT 7
18215: PUSH
18216: LD_INT 7
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: LIST
18223: PUSH
18224: LD_OWVAR 67
18228: ARRAY
18229: GREATEREQUAL
18230: IFTRUE 18246
18232: PUSH
18233: LD_OWVAR 1
18237: PUSH
18238: LD_INT 21000
18240: MOD
18241: PUSH
18242: LD_INT 0
18244: EQUAL
18245: OR
18246: IFFALSE 18190
// wait ( 0 0$45 ) ;
18248: LD_INT 1575
18250: PPUSH
18251: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18255: LD_ADDR_VAR 0 3
18259: PUSH
18260: LD_VAR 0 2
18264: PPUSH
18265: LD_INT 1
18267: PPUSH
18268: CALL 89459 0 2
18272: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18273: LD_ADDR_EXP 50
18277: PUSH
18278: LD_EXP 50
18282: PPUSH
18283: LD_VAR 0 2
18287: PPUSH
18288: LD_EXP 50
18292: PUSH
18293: LD_VAR 0 2
18297: ARRAY
18298: PUSH
18299: LD_VAR 0 3
18303: DIFF
18304: PPUSH
18305: CALL_OW 1
18309: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18310: LD_ADDR_VAR 0 4
18314: PUSH
18315: LD_INT 0
18317: PPUSH
18318: LD_INT 1
18320: PPUSH
18321: CALL_OW 12
18325: ST_TO_ADDR
// if target then
18326: LD_VAR 0 4
18330: IFFALSE 18458
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18332: LD_ADDR_VAR 0 3
18336: PUSH
18337: LD_VAR 0 3
18341: PPUSH
18342: LD_INT 24
18344: PUSH
18345: LD_INT 250
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: PPUSH
18352: CALL_OW 72
18356: ST_TO_ADDR
// for i in tmp do
18357: LD_ADDR_VAR 0 1
18361: PUSH
18362: LD_VAR 0 3
18366: PUSH
18367: FOR_IN
18368: IFFALSE 18408
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18370: LD_VAR 0 1
18374: PPUSH
18375: LD_INT 84
18377: PPUSH
18378: LD_INT 32
18380: PPUSH
18381: CALL_OW 297
18385: PUSH
18386: LD_INT 9
18388: GREATER
18389: IFFALSE 18406
// ComMoveXY ( i , 84 , 32 ) ;
18391: LD_VAR 0 1
18395: PPUSH
18396: LD_INT 84
18398: PPUSH
18399: LD_INT 32
18401: PPUSH
18402: CALL_OW 111
18406: GO 18367
18408: POP
18409: POP
// wait ( 0 0$1 ) ;
18410: LD_INT 35
18412: PPUSH
18413: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18417: LD_VAR 0 3
18421: PPUSH
18422: LD_INT 92
18424: PUSH
18425: LD_INT 84
18427: PUSH
18428: LD_INT 32
18430: PUSH
18431: LD_INT 9
18433: PUSH
18434: EMPTY
18435: LIST
18436: LIST
18437: LIST
18438: LIST
18439: PPUSH
18440: CALL_OW 72
18444: PUSH
18445: LD_VAR 0 3
18449: PUSH
18450: LD_INT 1
18452: MINUS
18453: GREATEREQUAL
18454: IFFALSE 18332
// end else
18456: GO 18620
// begin if teleport then
18458: LD_VAR 0 5
18462: IFFALSE 18482
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18464: LD_VAR 0 3
18468: PPUSH
18469: LD_VAR 0 5
18473: PUSH
18474: LD_INT 1
18476: ARRAY
18477: PPUSH
18478: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18482: LD_ADDR_VAR 0 3
18486: PUSH
18487: LD_VAR 0 3
18491: PPUSH
18492: LD_INT 24
18494: PUSH
18495: LD_INT 250
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: PPUSH
18502: CALL_OW 72
18506: ST_TO_ADDR
// for i in tmp do
18507: LD_ADDR_VAR 0 1
18511: PUSH
18512: LD_VAR 0 3
18516: PUSH
18517: FOR_IN
18518: IFFALSE 18572
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18520: LD_VAR 0 1
18524: PPUSH
18525: LD_INT 140
18527: PPUSH
18528: LD_INT 219
18530: PPUSH
18531: CALL_OW 297
18535: PUSH
18536: LD_INT 9
18538: GREATER
18539: IFFALSE 18553
18541: PUSH
18542: LD_VAR 0 1
18546: PPUSH
18547: CALL_OW 314
18551: NOT
18552: AND
18553: IFFALSE 18570
// AddComMoveXY ( i , 140 , 219 ) ;
18555: LD_VAR 0 1
18559: PPUSH
18560: LD_INT 140
18562: PPUSH
18563: LD_INT 219
18565: PPUSH
18566: CALL_OW 171
18570: GO 18517
18572: POP
18573: POP
// wait ( 0 0$1 ) ;
18574: LD_INT 35
18576: PPUSH
18577: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18581: LD_VAR 0 3
18585: PPUSH
18586: LD_INT 92
18588: PUSH
18589: LD_INT 140
18591: PUSH
18592: LD_INT 219
18594: PUSH
18595: LD_INT 9
18597: PUSH
18598: EMPTY
18599: LIST
18600: LIST
18601: LIST
18602: LIST
18603: PPUSH
18604: CALL_OW 72
18608: PUSH
18609: LD_VAR 0 3
18613: PUSH
18614: LD_INT 1
18616: MINUS
18617: GREATEREQUAL
18618: IFFALSE 18482
// end ; repeat wait ( 0 0$1 ) ;
18620: LD_INT 35
18622: PPUSH
18623: CALL_OW 67
// for i in tmp do
18627: LD_ADDR_VAR 0 1
18631: PUSH
18632: LD_VAR 0 3
18636: PUSH
18637: FOR_IN
18638: IFFALSE 18771
// begin if GetLives ( i ) > 251 then
18640: LD_VAR 0 1
18644: PPUSH
18645: CALL_OW 256
18649: PUSH
18650: LD_INT 251
18652: GREATER
18653: IFFALSE 18742
// begin if GetWeapon ( i ) = ru_time_lapser then
18655: LD_VAR 0 1
18659: PPUSH
18660: CALL_OW 264
18664: PUSH
18665: LD_INT 49
18667: EQUAL
18668: IFFALSE 18706
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18670: LD_VAR 0 1
18674: PPUSH
18675: LD_INT 81
18677: PUSH
18678: LD_INT 3
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: PPUSH
18685: CALL_OW 69
18689: PPUSH
18690: LD_VAR 0 1
18694: PPUSH
18695: CALL_OW 74
18699: PPUSH
18700: CALL_OW 112
18704: GO 18740
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18706: LD_VAR 0 1
18710: PPUSH
18711: LD_INT 81
18713: PUSH
18714: LD_INT 3
18716: PUSH
18717: EMPTY
18718: LIST
18719: LIST
18720: PPUSH
18721: CALL_OW 69
18725: PPUSH
18726: LD_VAR 0 1
18730: PPUSH
18731: CALL_OW 74
18735: PPUSH
18736: CALL_OW 115
// end else
18740: GO 18769
// if IsDead ( i ) then
18742: LD_VAR 0 1
18746: PPUSH
18747: CALL_OW 301
18751: IFFALSE 18769
// tmp := tmp diff i ;
18753: LD_ADDR_VAR 0 3
18757: PUSH
18758: LD_VAR 0 3
18762: PUSH
18763: LD_VAR 0 1
18767: DIFF
18768: ST_TO_ADDR
// end ;
18769: GO 18637
18771: POP
18772: POP
// until not tmp ;
18773: LD_VAR 0 3
18777: NOT
18778: IFFALSE 18620
// end ;
18780: PPOPN 5
18782: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18783: LD_EXP 3
18787: IFFALSE 19171
18789: GO 18791
18791: DISABLE
18792: LD_INT 0
18794: PPUSH
18795: PPUSH
18796: PPUSH
18797: PPUSH
// begin enable ;
18798: ENABLE
// base := mc_amer ;
18799: LD_ADDR_VAR 0 2
18803: PUSH
18804: LD_EXP 5
18808: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18809: LD_INT 22
18811: PUSH
18812: LD_INT 4
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: PUSH
18819: LD_INT 23
18821: PUSH
18822: LD_INT 1
18824: PUSH
18825: EMPTY
18826: LIST
18827: LIST
18828: PUSH
18829: LD_INT 30
18831: PUSH
18832: LD_INT 3
18834: PUSH
18835: EMPTY
18836: LIST
18837: LIST
18838: PUSH
18839: EMPTY
18840: LIST
18841: LIST
18842: LIST
18843: PPUSH
18844: CALL_OW 69
18848: NOT
18849: IFFALSE 18853
// exit ;
18851: GO 19171
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18853: LD_VAR 0 2
18857: PPUSH
18858: LD_INT 3
18860: PUSH
18861: LD_INT 1
18863: PUSH
18864: LD_INT 2
18866: PUSH
18867: LD_INT 5
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 3
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: LD_INT 2
18884: PUSH
18885: LD_INT 9
18887: PUSH
18888: EMPTY
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: PUSH
18894: LD_INT 3
18896: PUSH
18897: LD_INT 1
18899: PUSH
18900: LD_INT 2
18902: PUSH
18903: LD_INT 7
18905: PUSH
18906: EMPTY
18907: LIST
18908: LIST
18909: LIST
18910: LIST
18911: PUSH
18912: LD_INT 3
18914: PUSH
18915: LD_INT 1
18917: PUSH
18918: LD_INT 2
18920: PUSH
18921: LD_INT 7
18923: PUSH
18924: EMPTY
18925: LIST
18926: LIST
18927: LIST
18928: LIST
18929: PUSH
18930: LD_INT 3
18932: PUSH
18933: LD_INT 1
18935: PUSH
18936: LD_INT 2
18938: PUSH
18939: LD_INT 7
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: LIST
18946: LIST
18947: PUSH
18948: EMPTY
18949: LIST
18950: LIST
18951: LIST
18952: LIST
18953: LIST
18954: PPUSH
18955: CALL 88003 0 2
// repeat wait ( 0 0$1 ) ;
18959: LD_INT 35
18961: PPUSH
18962: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18966: LD_VAR 0 2
18970: PPUSH
18971: LD_INT 1
18973: PPUSH
18974: CALL 89459 0 2
18978: PUSH
18979: LD_INT 5
18981: GREATEREQUAL
18982: IFTRUE 18998
18984: PUSH
18985: LD_OWVAR 1
18989: PUSH
18990: LD_INT 21000
18992: MOD
18993: PUSH
18994: LD_INT 0
18996: EQUAL
18997: OR
18998: IFFALSE 18959
// wait ( 0 0$30 ) ;
19000: LD_INT 1050
19002: PPUSH
19003: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
19007: LD_ADDR_VAR 0 3
19011: PUSH
19012: LD_VAR 0 2
19016: PPUSH
19017: LD_INT 1
19019: PPUSH
19020: CALL 89459 0 2
19024: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
19025: LD_ADDR_EXP 50
19029: PUSH
19030: LD_EXP 50
19034: PPUSH
19035: LD_VAR 0 2
19039: PPUSH
19040: LD_EXP 50
19044: PUSH
19045: LD_VAR 0 2
19049: ARRAY
19050: PUSH
19051: LD_VAR 0 3
19055: DIFF
19056: PPUSH
19057: CALL_OW 1
19061: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19062: LD_INT 35
19064: PPUSH
19065: CALL_OW 67
// for i in tmp do
19069: LD_ADDR_VAR 0 1
19073: PUSH
19074: LD_VAR 0 3
19078: PUSH
19079: FOR_IN
19080: IFFALSE 19162
// begin if GetLives ( i ) > 251 then
19082: LD_VAR 0 1
19086: PPUSH
19087: CALL_OW 256
19091: PUSH
19092: LD_INT 251
19094: GREATER
19095: IFFALSE 19133
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19097: LD_VAR 0 1
19101: PPUSH
19102: LD_INT 81
19104: PUSH
19105: LD_INT 4
19107: PUSH
19108: EMPTY
19109: LIST
19110: LIST
19111: PPUSH
19112: CALL_OW 69
19116: PPUSH
19117: LD_VAR 0 1
19121: PPUSH
19122: CALL_OW 74
19126: PPUSH
19127: CALL_OW 115
19131: GO 19160
// if IsDead ( i ) then
19133: LD_VAR 0 1
19137: PPUSH
19138: CALL_OW 301
19142: IFFALSE 19160
// tmp := tmp diff i ;
19144: LD_ADDR_VAR 0 3
19148: PUSH
19149: LD_VAR 0 3
19153: PUSH
19154: LD_VAR 0 1
19158: DIFF
19159: ST_TO_ADDR
// end ;
19160: GO 19079
19162: POP
19163: POP
// until not tmp ;
19164: LD_VAR 0 3
19168: NOT
19169: IFFALSE 19062
// end ; end_of_file
19171: PPOPN 4
19173: END
// export function CustomEvent ( event ) ; begin
19174: LD_INT 0
19176: PPUSH
// end ;
19177: LD_VAR 0 2
19181: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19182: LD_VAR 0 1
19186: PUSH
19187: LD_INT 1
19189: EQUAL
19190: IFFALSE 19202
19192: PUSH
19193: LD_VAR 0 2
19197: PUSH
19198: LD_INT 4
19200: EQUAL
19201: AND
19202: IFFALSE 19230
// begin SayRadio ( Powell , DP-Lost ) ;
19204: LD_EXP 12
19208: PPUSH
19209: LD_STRING DP-Lost
19211: PPUSH
19212: CALL_OW 94
// wait ( 0 0$2 ) ;
19216: LD_INT 70
19218: PPUSH
19219: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19223: LD_STRING FriendlyFire
19225: PPUSH
19226: CALL_OW 104
// end ; end ;
19230: PPOPN 2
19232: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19233: LD_VAR 0 1
19237: PPUSH
19238: CALL 110606 0 1
// if GameType = 1 then
19242: LD_EXP 2
19246: PUSH
19247: LD_INT 1
19249: EQUAL
19250: IFFALSE 19485
// begin if un = playerCommander then
19252: LD_VAR 0 1
19256: PUSH
19257: LD_EXP 9
19261: EQUAL
19262: IFFALSE 19271
// YouLost ( commanderDied ) ;
19264: LD_STRING commanderDied
19266: PPUSH
19267: CALL_OW 104
// if un = allyCommander then
19271: LD_VAR 0 1
19275: PUSH
19276: LD_EXP 11
19280: EQUAL
19281: IFFALSE 19290
// YouLost ( Theta ) ;
19283: LD_STRING Theta
19285: PPUSH
19286: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19290: LD_VAR 0 1
19294: PUSH
19295: LD_INT 22
19297: PUSH
19298: LD_INT 8
19300: PUSH
19301: EMPTY
19302: LIST
19303: LIST
19304: PUSH
19305: LD_INT 2
19307: PUSH
19308: LD_INT 21
19310: PUSH
19311: LD_INT 1
19313: PUSH
19314: EMPTY
19315: LIST
19316: LIST
19317: PUSH
19318: LD_INT 21
19320: PUSH
19321: LD_INT 3
19323: PUSH
19324: EMPTY
19325: LIST
19326: LIST
19327: PUSH
19328: EMPTY
19329: LIST
19330: LIST
19331: LIST
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: PPUSH
19337: CALL_OW 69
19341: IN
19342: IFFALSE 19358
// legDestCounter := legDestCounter + 1 ;
19344: LD_ADDR_EXP 18
19348: PUSH
19349: LD_EXP 18
19353: PUSH
19354: LD_INT 1
19356: PLUS
19357: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19358: LD_VAR 0 1
19362: PUSH
19363: LD_INT 22
19365: PUSH
19366: LD_INT 4
19368: PUSH
19369: EMPTY
19370: LIST
19371: LIST
19372: PUSH
19373: LD_INT 2
19375: PUSH
19376: LD_INT 21
19378: PUSH
19379: LD_INT 1
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 3
19391: PUSH
19392: EMPTY
19393: LIST
19394: LIST
19395: PUSH
19396: EMPTY
19397: LIST
19398: LIST
19399: LIST
19400: PUSH
19401: EMPTY
19402: LIST
19403: LIST
19404: PPUSH
19405: CALL_OW 69
19409: IN
19410: IFFALSE 19426
// allyDestCounter := allyDestCounter + 1 ;
19412: LD_ADDR_EXP 22
19416: PUSH
19417: LD_EXP 22
19421: PUSH
19422: LD_INT 1
19424: PLUS
19425: ST_TO_ADDR
// if un in ruOutpost then
19426: LD_VAR 0 1
19430: PUSH
19431: LD_EXP 14
19435: IN
19436: IFFALSE 19485
// begin ruOutpost := ruOutpost diff un ;
19438: LD_ADDR_EXP 14
19442: PUSH
19443: LD_EXP 14
19447: PUSH
19448: LD_VAR 0 1
19452: DIFF
19453: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19454: LD_ADDR_EXP 15
19458: PUSH
19459: LD_EXP 15
19463: PPUSH
19464: LD_INT 1
19466: PPUSH
19467: LD_EXP 15
19471: PUSH
19472: LD_INT 1
19474: ARRAY
19475: PUSH
19476: LD_INT 1
19478: PLUS
19479: PPUSH
19480: CALL_OW 1
19484: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19485: LD_VAR 0 1
19489: PPUSH
19490: CALL 91509 0 1
// end ;
19494: PPOPN 1
19496: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19497: LD_VAR 0 1
19501: PPUSH
19502: LD_VAR 0 2
19506: PPUSH
19507: CALL 93863 0 2
// end ;
19511: PPOPN 2
19513: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19514: LD_VAR 0 1
19518: PPUSH
19519: CALL 92927 0 1
// end ;
19523: PPOPN 1
19525: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19526: LD_VAR 0 1
19530: PPUSH
19531: CALL 93170 0 1
// end ;
19535: PPOPN 1
19537: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19538: LD_VAR 0 1
19542: PUSH
19543: LD_INT 14
19545: EQUAL
19546: IFFALSE 19563
19548: PUSH
19549: LD_VAR 0 2
19553: PPUSH
19554: CALL_OW 255
19558: PUSH
19559: LD_INT 1
19561: EQUAL
19562: AND
19563: IFFALSE 19604
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19565: LD_EXP 9
19569: PPUSH
19570: LD_STRING D
19572: PUSH
19573: LD_STRING I
19575: PUSH
19576: LD_STRING J
19578: PUSH
19579: LD_STRING S
19581: PUSH
19582: EMPTY
19583: LIST
19584: LIST
19585: LIST
19586: PUSH
19587: LD_EXP 25
19591: ARRAY
19592: STR
19593: PUSH
19594: LD_STRING -1-Laser
19596: STR
19597: PPUSH
19598: CALL_OW 88
// exit ;
19602: GO 19750
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19604: LD_VAR 0 1
19608: PUSH
19609: LD_INT 7
19611: EQUAL
19612: IFFALSE 19629
19614: PUSH
19615: LD_VAR 0 2
19619: PPUSH
19620: CALL_OW 255
19624: PUSH
19625: LD_INT 1
19627: EQUAL
19628: AND
19629: IFFALSE 19670
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19631: LD_EXP 9
19635: PPUSH
19636: LD_STRING D
19638: PUSH
19639: LD_STRING I
19641: PUSH
19642: LD_STRING J
19644: PUSH
19645: LD_STRING S
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: PUSH
19653: LD_EXP 25
19657: ARRAY
19658: STR
19659: PUSH
19660: LD_STRING -1-Materialization
19662: STR
19663: PPUSH
19664: CALL_OW 88
// exit ;
19668: GO 19750
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19670: LD_VAR 0 1
19674: PUSH
19675: LD_INT 25
19677: EQUAL
19678: IFFALSE 19695
19680: PUSH
19681: LD_VAR 0 2
19685: PPUSH
19686: CALL_OW 255
19690: PUSH
19691: LD_INT 1
19693: EQUAL
19694: AND
19695: IFFALSE 19736
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19697: LD_EXP 9
19701: PPUSH
19702: LD_STRING D
19704: PUSH
19705: LD_STRING I
19707: PUSH
19708: LD_STRING J
19710: PUSH
19711: LD_STRING S
19713: PUSH
19714: EMPTY
19715: LIST
19716: LIST
19717: LIST
19718: PUSH
19719: LD_EXP 25
19723: ARRAY
19724: STR
19725: PUSH
19726: LD_STRING -1-Rocket
19728: STR
19729: PPUSH
19730: CALL_OW 88
// exit ;
19734: GO 19750
// end ; MCE_ResearchComplete ( tech , lab ) ;
19736: LD_VAR 0 1
19740: PPUSH
19741: LD_VAR 0 2
19745: PPUSH
19746: CALL 91197 0 2
// end ;
19750: PPOPN 2
19752: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19753: LD_VAR 0 1
19757: PPUSH
19758: LD_VAR 0 2
19762: PPUSH
19763: LD_VAR 0 3
19767: PPUSH
19768: LD_VAR 0 4
19772: PPUSH
19773: LD_VAR 0 5
19777: PPUSH
19778: CALL 90815 0 5
// end ;
19782: PPOPN 5
19784: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19785: LD_VAR 0 1
19789: PPUSH
19790: LD_VAR 0 2
19794: PPUSH
19795: CALL 110664 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19799: LD_VAR 0 1
19803: PPUSH
19804: LD_VAR 0 2
19808: PPUSH
19809: CALL 90364 0 2
// end ;
19813: PPOPN 2
19815: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19816: LD_VAR 0 1
19820: PPUSH
19821: LD_VAR 0 2
19825: PPUSH
19826: LD_VAR 0 3
19830: PPUSH
19831: LD_VAR 0 4
19835: PPUSH
19836: CALL 90196 0 4
// end ;
19840: PPOPN 4
19842: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19843: LD_VAR 0 1
19847: PPUSH
19848: LD_VAR 0 2
19852: PPUSH
19853: LD_VAR 0 3
19857: PPUSH
19858: CALL 89969 0 3
// end ;
19862: PPOPN 3
19864: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19865: LD_VAR 0 1
19869: PPUSH
19870: LD_VAR 0 2
19874: PPUSH
19875: CALL 89852 0 2
// end ;
19879: PPOPN 2
19881: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19882: LD_VAR 0 1
19886: PPUSH
19887: LD_VAR 0 2
19891: PPUSH
19892: CALL 94160 0 2
// end ;
19896: PPOPN 2
19898: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19899: LD_VAR 0 1
19903: PPUSH
19904: LD_VAR 0 2
19908: PPUSH
19909: LD_VAR 0 3
19913: PPUSH
19914: LD_VAR 0 4
19918: PPUSH
19919: CALL 94384 0 4
// end ;
19923: PPOPN 4
19925: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19926: LD_VAR 0 1
19930: PPUSH
19931: LD_VAR 0 2
19935: PPUSH
19936: CALL 89659 0 2
// end ;
19940: PPOPN 2
19942: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19943: LD_VAR 0 1
19947: PPUSH
19948: CALL 110648 0 1
// end ; end_of_file
19952: PPOPN 1
19954: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19955: LD_INT 0
19957: PPUSH
19958: PPUSH
// if exist_mode then
19959: LD_VAR 0 2
19963: IFFALSE 20009
// begin unit := CreateCharacter ( prefix & ident ) ;
19965: LD_ADDR_VAR 0 5
19969: PUSH
19970: LD_VAR 0 3
19974: PUSH
19975: LD_VAR 0 1
19979: STR
19980: PPUSH
19981: CALL_OW 34
19985: ST_TO_ADDR
// if unit then
19986: LD_VAR 0 5
19990: IFFALSE 20007
// DeleteCharacters ( prefix & ident ) ;
19992: LD_VAR 0 3
19996: PUSH
19997: LD_VAR 0 1
20001: STR
20002: PPUSH
20003: CALL_OW 40
// end else
20007: GO 20024
// unit := NewCharacter ( ident ) ;
20009: LD_ADDR_VAR 0 5
20013: PUSH
20014: LD_VAR 0 1
20018: PPUSH
20019: CALL_OW 25
20023: ST_TO_ADDR
// result := unit ;
20024: LD_ADDR_VAR 0 4
20028: PUSH
20029: LD_VAR 0 5
20033: ST_TO_ADDR
// end ;
20034: LD_VAR 0 4
20038: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
20039: LD_INT 0
20041: PPUSH
20042: PPUSH
// if exist_mode then
20043: LD_VAR 0 2
20047: IFFALSE 20072
// unit := CreateCharacter ( prefix & ident ) else
20049: LD_ADDR_VAR 0 5
20053: PUSH
20054: LD_VAR 0 3
20058: PUSH
20059: LD_VAR 0 1
20063: STR
20064: PPUSH
20065: CALL_OW 34
20069: ST_TO_ADDR
20070: GO 20087
// unit := NewCharacter ( ident ) ;
20072: LD_ADDR_VAR 0 5
20076: PUSH
20077: LD_VAR 0 1
20081: PPUSH
20082: CALL_OW 25
20086: ST_TO_ADDR
// result := unit ;
20087: LD_ADDR_VAR 0 4
20091: PUSH
20092: LD_VAR 0 5
20096: ST_TO_ADDR
// end ;
20097: LD_VAR 0 4
20101: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
20102: LD_INT 0
20104: PPUSH
20105: PPUSH
// if not side or not nation then
20106: LD_VAR 0 1
20110: NOT
20111: IFTRUE 20120
20113: PUSH
20114: LD_VAR 0 2
20118: NOT
20119: OR
20120: IFFALSE 20124
// exit ;
20122: GO 20918
// case nation of nation_american :
20124: LD_VAR 0 2
20128: PUSH
20129: LD_INT 1
20131: DOUBLE
20132: EQUAL
20133: IFTRUE 20137
20135: GO 20359
20137: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
20138: LD_ADDR_VAR 0 4
20142: PUSH
20143: LD_INT 35
20145: PUSH
20146: LD_INT 45
20148: PUSH
20149: LD_INT 46
20151: PUSH
20152: LD_INT 47
20154: PUSH
20155: LD_INT 82
20157: PUSH
20158: LD_INT 83
20160: PUSH
20161: LD_INT 84
20163: PUSH
20164: LD_INT 85
20166: PUSH
20167: LD_INT 86
20169: PUSH
20170: LD_INT 1
20172: PUSH
20173: LD_INT 2
20175: PUSH
20176: LD_INT 6
20178: PUSH
20179: LD_INT 15
20181: PUSH
20182: LD_INT 16
20184: PUSH
20185: LD_INT 7
20187: PUSH
20188: LD_INT 12
20190: PUSH
20191: LD_INT 13
20193: PUSH
20194: LD_INT 10
20196: PUSH
20197: LD_INT 14
20199: PUSH
20200: LD_INT 20
20202: PUSH
20203: LD_INT 21
20205: PUSH
20206: LD_INT 22
20208: PUSH
20209: LD_INT 25
20211: PUSH
20212: LD_INT 32
20214: PUSH
20215: LD_INT 27
20217: PUSH
20218: LD_INT 36
20220: PUSH
20221: LD_INT 69
20223: PUSH
20224: LD_INT 39
20226: PUSH
20227: LD_INT 34
20229: PUSH
20230: LD_INT 40
20232: PUSH
20233: LD_INT 48
20235: PUSH
20236: LD_INT 49
20238: PUSH
20239: LD_INT 50
20241: PUSH
20242: LD_INT 51
20244: PUSH
20245: LD_INT 52
20247: PUSH
20248: LD_INT 53
20250: PUSH
20251: LD_INT 54
20253: PUSH
20254: LD_INT 55
20256: PUSH
20257: LD_INT 56
20259: PUSH
20260: LD_INT 57
20262: PUSH
20263: LD_INT 58
20265: PUSH
20266: LD_INT 59
20268: PUSH
20269: LD_INT 60
20271: PUSH
20272: LD_INT 61
20274: PUSH
20275: LD_INT 62
20277: PUSH
20278: LD_INT 80
20280: PUSH
20281: LD_INT 82
20283: PUSH
20284: LD_INT 83
20286: PUSH
20287: LD_INT 84
20289: PUSH
20290: LD_INT 85
20292: PUSH
20293: LD_INT 86
20295: PUSH
20296: LD_INT 90
20298: PUSH
20299: LD_INT 93
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: LIST
20306: LIST
20307: LIST
20308: LIST
20309: LIST
20310: LIST
20311: LIST
20312: LIST
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: LIST
20328: LIST
20329: LIST
20330: LIST
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: LIST
20336: LIST
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: LIST
20343: LIST
20344: LIST
20345: LIST
20346: LIST
20347: LIST
20348: LIST
20349: LIST
20350: LIST
20351: LIST
20352: LIST
20353: LIST
20354: LIST
20355: LIST
20356: ST_TO_ADDR
20357: GO 20840
20359: LD_INT 2
20361: DOUBLE
20362: EQUAL
20363: IFTRUE 20367
20365: GO 20601
20367: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
20368: LD_ADDR_VAR 0 4
20372: PUSH
20373: LD_INT 35
20375: PUSH
20376: LD_INT 45
20378: PUSH
20379: LD_INT 46
20381: PUSH
20382: LD_INT 47
20384: PUSH
20385: LD_INT 82
20387: PUSH
20388: LD_INT 83
20390: PUSH
20391: LD_INT 84
20393: PUSH
20394: LD_INT 85
20396: PUSH
20397: LD_INT 87
20399: PUSH
20400: LD_INT 70
20402: PUSH
20403: LD_INT 1
20405: PUSH
20406: LD_INT 11
20408: PUSH
20409: LD_INT 3
20411: PUSH
20412: LD_INT 4
20414: PUSH
20415: LD_INT 5
20417: PUSH
20418: LD_INT 6
20420: PUSH
20421: LD_INT 15
20423: PUSH
20424: LD_INT 18
20426: PUSH
20427: LD_INT 7
20429: PUSH
20430: LD_INT 17
20432: PUSH
20433: LD_INT 8
20435: PUSH
20436: LD_INT 20
20438: PUSH
20439: LD_INT 21
20441: PUSH
20442: LD_INT 22
20444: PUSH
20445: LD_INT 72
20447: PUSH
20448: LD_INT 26
20450: PUSH
20451: LD_INT 69
20453: PUSH
20454: LD_INT 39
20456: PUSH
20457: LD_INT 40
20459: PUSH
20460: LD_INT 41
20462: PUSH
20463: LD_INT 42
20465: PUSH
20466: LD_INT 43
20468: PUSH
20469: LD_INT 48
20471: PUSH
20472: LD_INT 49
20474: PUSH
20475: LD_INT 50
20477: PUSH
20478: LD_INT 51
20480: PUSH
20481: LD_INT 52
20483: PUSH
20484: LD_INT 53
20486: PUSH
20487: LD_INT 54
20489: PUSH
20490: LD_INT 55
20492: PUSH
20493: LD_INT 56
20495: PUSH
20496: LD_INT 60
20498: PUSH
20499: LD_INT 61
20501: PUSH
20502: LD_INT 62
20504: PUSH
20505: LD_INT 66
20507: PUSH
20508: LD_INT 67
20510: PUSH
20511: LD_INT 68
20513: PUSH
20514: LD_INT 81
20516: PUSH
20517: LD_INT 82
20519: PUSH
20520: LD_INT 83
20522: PUSH
20523: LD_INT 84
20525: PUSH
20526: LD_INT 85
20528: PUSH
20529: LD_INT 87
20531: PUSH
20532: LD_INT 88
20534: PUSH
20535: LD_INT 92
20537: PUSH
20538: LD_INT 94
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: LIST
20545: LIST
20546: LIST
20547: LIST
20548: LIST
20549: LIST
20550: LIST
20551: LIST
20552: LIST
20553: LIST
20554: LIST
20555: LIST
20556: LIST
20557: LIST
20558: LIST
20559: LIST
20560: LIST
20561: LIST
20562: LIST
20563: LIST
20564: LIST
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: LIST
20570: LIST
20571: LIST
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: LIST
20577: LIST
20578: LIST
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: LIST
20596: LIST
20597: LIST
20598: ST_TO_ADDR
20599: GO 20840
20601: LD_INT 3
20603: DOUBLE
20604: EQUAL
20605: IFTRUE 20609
20607: GO 20839
20609: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
20610: LD_ADDR_VAR 0 4
20614: PUSH
20615: LD_INT 46
20617: PUSH
20618: LD_INT 47
20620: PUSH
20621: LD_INT 1
20623: PUSH
20624: LD_INT 2
20626: PUSH
20627: LD_INT 82
20629: PUSH
20630: LD_INT 83
20632: PUSH
20633: LD_INT 84
20635: PUSH
20636: LD_INT 85
20638: PUSH
20639: LD_INT 86
20641: PUSH
20642: LD_INT 11
20644: PUSH
20645: LD_INT 9
20647: PUSH
20648: LD_INT 20
20650: PUSH
20651: LD_INT 19
20653: PUSH
20654: LD_INT 21
20656: PUSH
20657: LD_INT 24
20659: PUSH
20660: LD_INT 22
20662: PUSH
20663: LD_INT 25
20665: PUSH
20666: LD_INT 28
20668: PUSH
20669: LD_INT 29
20671: PUSH
20672: LD_INT 30
20674: PUSH
20675: LD_INT 31
20677: PUSH
20678: LD_INT 37
20680: PUSH
20681: LD_INT 38
20683: PUSH
20684: LD_INT 32
20686: PUSH
20687: LD_INT 27
20689: PUSH
20690: LD_INT 33
20692: PUSH
20693: LD_INT 69
20695: PUSH
20696: LD_INT 39
20698: PUSH
20699: LD_INT 34
20701: PUSH
20702: LD_INT 40
20704: PUSH
20705: LD_INT 71
20707: PUSH
20708: LD_INT 23
20710: PUSH
20711: LD_INT 44
20713: PUSH
20714: LD_INT 48
20716: PUSH
20717: LD_INT 49
20719: PUSH
20720: LD_INT 50
20722: PUSH
20723: LD_INT 51
20725: PUSH
20726: LD_INT 52
20728: PUSH
20729: LD_INT 53
20731: PUSH
20732: LD_INT 54
20734: PUSH
20735: LD_INT 55
20737: PUSH
20738: LD_INT 56
20740: PUSH
20741: LD_INT 57
20743: PUSH
20744: LD_INT 58
20746: PUSH
20747: LD_INT 59
20749: PUSH
20750: LD_INT 63
20752: PUSH
20753: LD_INT 64
20755: PUSH
20756: LD_INT 65
20758: PUSH
20759: LD_INT 82
20761: PUSH
20762: LD_INT 83
20764: PUSH
20765: LD_INT 84
20767: PUSH
20768: LD_INT 85
20770: PUSH
20771: LD_INT 86
20773: PUSH
20774: LD_INT 89
20776: PUSH
20777: LD_INT 91
20779: PUSH
20780: EMPTY
20781: LIST
20782: LIST
20783: LIST
20784: LIST
20785: LIST
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: LIST
20804: LIST
20805: LIST
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: LIST
20818: LIST
20819: LIST
20820: LIST
20821: LIST
20822: LIST
20823: LIST
20824: LIST
20825: LIST
20826: LIST
20827: LIST
20828: LIST
20829: LIST
20830: LIST
20831: LIST
20832: LIST
20833: LIST
20834: LIST
20835: LIST
20836: ST_TO_ADDR
20837: GO 20840
20839: POP
// if state > - 1 and state < 3 then
20840: LD_VAR 0 3
20844: PUSH
20845: LD_INT 1
20847: NEG
20848: GREATER
20849: IFFALSE 20861
20851: PUSH
20852: LD_VAR 0 3
20856: PUSH
20857: LD_INT 3
20859: LESS
20860: AND
20861: IFFALSE 20918
// for i in result do
20863: LD_ADDR_VAR 0 5
20867: PUSH
20868: LD_VAR 0 4
20872: PUSH
20873: FOR_IN
20874: IFFALSE 20916
// if GetTech ( i , side ) <> state then
20876: LD_VAR 0 5
20880: PPUSH
20881: LD_VAR 0 1
20885: PPUSH
20886: CALL_OW 321
20890: PUSH
20891: LD_VAR 0 3
20895: NONEQUAL
20896: IFFALSE 20914
// result := result diff i ;
20898: LD_ADDR_VAR 0 4
20902: PUSH
20903: LD_VAR 0 4
20907: PUSH
20908: LD_VAR 0 5
20912: DIFF
20913: ST_TO_ADDR
20914: GO 20873
20916: POP
20917: POP
// end ;
20918: LD_VAR 0 4
20922: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20923: LD_INT 0
20925: PPUSH
20926: PPUSH
20927: PPUSH
// result := true ;
20928: LD_ADDR_VAR 0 3
20932: PUSH
20933: LD_INT 1
20935: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20936: LD_ADDR_VAR 0 5
20940: PUSH
20941: LD_VAR 0 2
20945: PPUSH
20946: CALL_OW 480
20950: ST_TO_ADDR
// if not tmp then
20951: LD_VAR 0 5
20955: NOT
20956: IFFALSE 20960
// exit ;
20958: GO 21009
// for i in tmp do
20960: LD_ADDR_VAR 0 4
20964: PUSH
20965: LD_VAR 0 5
20969: PUSH
20970: FOR_IN
20971: IFFALSE 21007
// if GetTech ( i , side ) <> state_researched then
20973: LD_VAR 0 4
20977: PPUSH
20978: LD_VAR 0 1
20982: PPUSH
20983: CALL_OW 321
20987: PUSH
20988: LD_INT 2
20990: NONEQUAL
20991: IFFALSE 21005
// begin result := false ;
20993: LD_ADDR_VAR 0 3
20997: PUSH
20998: LD_INT 0
21000: ST_TO_ADDR
// exit ;
21001: POP
21002: POP
21003: GO 21009
// end ;
21005: GO 20970
21007: POP
21008: POP
// end ;
21009: LD_VAR 0 3
21013: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
21014: LD_INT 0
21016: PPUSH
21017: PPUSH
21018: PPUSH
21019: PPUSH
21020: PPUSH
21021: PPUSH
21022: PPUSH
21023: PPUSH
21024: PPUSH
21025: PPUSH
21026: PPUSH
21027: PPUSH
21028: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
21029: LD_VAR 0 1
21033: NOT
21034: IFTRUE 21051
21036: PUSH
21037: LD_VAR 0 1
21041: PPUSH
21042: CALL_OW 257
21046: PUSH
21047: LD_INT 9
21049: NONEQUAL
21050: OR
21051: IFFALSE 21055
// exit ;
21053: GO 21634
// side := GetSide ( unit ) ;
21055: LD_ADDR_VAR 0 9
21059: PUSH
21060: LD_VAR 0 1
21064: PPUSH
21065: CALL_OW 255
21069: ST_TO_ADDR
// tech_space := tech_spacanom ;
21070: LD_ADDR_VAR 0 12
21074: PUSH
21075: LD_INT 29
21077: ST_TO_ADDR
// tech_time := tech_taurad ;
21078: LD_ADDR_VAR 0 13
21082: PUSH
21083: LD_INT 28
21085: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
21086: LD_ADDR_VAR 0 11
21090: PUSH
21091: LD_VAR 0 1
21095: PPUSH
21096: CALL_OW 310
21100: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
21101: LD_VAR 0 11
21105: PPUSH
21106: CALL_OW 247
21110: PUSH
21111: LD_INT 2
21113: EQUAL
21114: IFFALSE 21118
// exit ;
21116: GO 21634
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21118: LD_ADDR_VAR 0 8
21122: PUSH
21123: LD_INT 81
21125: PUSH
21126: LD_VAR 0 9
21130: PUSH
21131: EMPTY
21132: LIST
21133: LIST
21134: PUSH
21135: LD_INT 3
21137: PUSH
21138: LD_INT 21
21140: PUSH
21141: LD_INT 3
21143: PUSH
21144: EMPTY
21145: LIST
21146: LIST
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: PUSH
21152: EMPTY
21153: LIST
21154: LIST
21155: PPUSH
21156: CALL_OW 69
21160: ST_TO_ADDR
// if not tmp then
21161: LD_VAR 0 8
21165: NOT
21166: IFFALSE 21170
// exit ;
21168: GO 21634
// if in_unit then
21170: LD_VAR 0 11
21174: IFFALSE 21198
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
21176: LD_ADDR_VAR 0 10
21180: PUSH
21181: LD_VAR 0 8
21185: PPUSH
21186: LD_VAR 0 11
21190: PPUSH
21191: CALL_OW 74
21195: ST_TO_ADDR
21196: GO 21218
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21198: LD_ADDR_VAR 0 10
21202: PUSH
21203: LD_VAR 0 8
21207: PPUSH
21208: LD_VAR 0 1
21212: PPUSH
21213: CALL_OW 74
21217: ST_TO_ADDR
// if not enemy then
21218: LD_VAR 0 10
21222: NOT
21223: IFFALSE 21227
// exit ;
21225: GO 21634
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21227: LD_VAR 0 11
21231: IFFALSE 21253
21233: PUSH
21234: LD_VAR 0 11
21238: PPUSH
21239: LD_VAR 0 10
21243: PPUSH
21244: CALL_OW 296
21248: PUSH
21249: LD_INT 13
21251: GREATER
21252: AND
21253: IFTRUE 21275
21255: PUSH
21256: LD_VAR 0 1
21260: PPUSH
21261: LD_VAR 0 10
21265: PPUSH
21266: CALL_OW 296
21270: PUSH
21271: LD_INT 12
21273: GREATER
21274: OR
21275: IFFALSE 21279
// exit ;
21277: GO 21634
// missile := [ 1 ] ;
21279: LD_ADDR_VAR 0 14
21283: PUSH
21284: LD_INT 1
21286: PUSH
21287: EMPTY
21288: LIST
21289: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21290: LD_VAR 0 9
21294: PPUSH
21295: LD_VAR 0 12
21299: PPUSH
21300: CALL_OW 325
21304: IFFALSE 21333
// missile := Replace ( missile , missile + 1 , 2 ) ;
21306: LD_ADDR_VAR 0 14
21310: PUSH
21311: LD_VAR 0 14
21315: PPUSH
21316: LD_VAR 0 14
21320: PUSH
21321: LD_INT 1
21323: PLUS
21324: PPUSH
21325: LD_INT 2
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21333: LD_VAR 0 9
21337: PPUSH
21338: LD_VAR 0 13
21342: PPUSH
21343: CALL_OW 325
21347: IFFALSE 21371
21349: PUSH
21350: LD_VAR 0 10
21354: PPUSH
21355: CALL_OW 255
21359: PPUSH
21360: LD_VAR 0 13
21364: PPUSH
21365: CALL_OW 325
21369: NOT
21370: AND
21371: IFFALSE 21400
// missile := Replace ( missile , missile + 1 , 3 ) ;
21373: LD_ADDR_VAR 0 14
21377: PUSH
21378: LD_VAR 0 14
21382: PPUSH
21383: LD_VAR 0 14
21387: PUSH
21388: LD_INT 1
21390: PLUS
21391: PPUSH
21392: LD_INT 3
21394: PPUSH
21395: CALL_OW 1
21399: ST_TO_ADDR
// if missile < 2 then
21400: LD_VAR 0 14
21404: PUSH
21405: LD_INT 2
21407: LESS
21408: IFFALSE 21412
// exit ;
21410: GO 21634
// x := GetX ( enemy ) ;
21412: LD_ADDR_VAR 0 4
21416: PUSH
21417: LD_VAR 0 10
21421: PPUSH
21422: CALL_OW 250
21426: ST_TO_ADDR
// y := GetY ( enemy ) ;
21427: LD_ADDR_VAR 0 5
21431: PUSH
21432: LD_VAR 0 10
21436: PPUSH
21437: CALL_OW 251
21441: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21442: LD_ADDR_VAR 0 6
21446: PUSH
21447: LD_VAR 0 4
21451: PUSH
21452: LD_INT 1
21454: NEG
21455: PPUSH
21456: LD_INT 1
21458: PPUSH
21459: CALL_OW 12
21463: PLUS
21464: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21465: LD_ADDR_VAR 0 7
21469: PUSH
21470: LD_VAR 0 5
21474: PUSH
21475: LD_INT 1
21477: NEG
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 12
21486: PLUS
21487: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21488: LD_VAR 0 6
21492: PPUSH
21493: LD_VAR 0 7
21497: PPUSH
21498: CALL_OW 488
21502: NOT
21503: IFFALSE 21525
// begin _x := x ;
21505: LD_ADDR_VAR 0 6
21509: PUSH
21510: LD_VAR 0 4
21514: ST_TO_ADDR
// _y := y ;
21515: LD_ADDR_VAR 0 7
21519: PUSH
21520: LD_VAR 0 5
21524: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21525: LD_ADDR_VAR 0 3
21529: PUSH
21530: LD_INT 1
21532: PPUSH
21533: LD_VAR 0 14
21537: PPUSH
21538: CALL_OW 12
21542: ST_TO_ADDR
// case i of 1 :
21543: LD_VAR 0 3
21547: PUSH
21548: LD_INT 1
21550: DOUBLE
21551: EQUAL
21552: IFTRUE 21556
21554: GO 21573
21556: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21557: LD_VAR 0 1
21561: PPUSH
21562: LD_VAR 0 10
21566: PPUSH
21567: CALL_OW 115
21571: GO 21634
21573: LD_INT 2
21575: DOUBLE
21576: EQUAL
21577: IFTRUE 21581
21579: GO 21603
21581: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21582: LD_VAR 0 1
21586: PPUSH
21587: LD_VAR 0 6
21591: PPUSH
21592: LD_VAR 0 7
21596: PPUSH
21597: CALL_OW 153
21601: GO 21634
21603: LD_INT 3
21605: DOUBLE
21606: EQUAL
21607: IFTRUE 21611
21609: GO 21633
21611: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21612: LD_VAR 0 1
21616: PPUSH
21617: LD_VAR 0 6
21621: PPUSH
21622: LD_VAR 0 7
21626: PPUSH
21627: CALL_OW 154
21631: GO 21634
21633: POP
// end ;
21634: LD_VAR 0 2
21638: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21639: LD_INT 0
21641: PPUSH
21642: PPUSH
21643: PPUSH
21644: PPUSH
21645: PPUSH
21646: PPUSH
// if not unit or not building then
21647: LD_VAR 0 1
21651: NOT
21652: IFTRUE 21661
21654: PUSH
21655: LD_VAR 0 2
21659: NOT
21660: OR
21661: IFFALSE 21665
// exit ;
21663: GO 21823
// x := GetX ( building ) ;
21665: LD_ADDR_VAR 0 5
21669: PUSH
21670: LD_VAR 0 2
21674: PPUSH
21675: CALL_OW 250
21679: ST_TO_ADDR
// y := GetY ( building ) ;
21680: LD_ADDR_VAR 0 6
21684: PUSH
21685: LD_VAR 0 2
21689: PPUSH
21690: CALL_OW 251
21694: ST_TO_ADDR
// for i := 0 to 5 do
21695: LD_ADDR_VAR 0 4
21699: PUSH
21700: DOUBLE
21701: LD_INT 0
21703: DEC
21704: ST_TO_ADDR
21705: LD_INT 5
21707: PUSH
21708: FOR_TO
21709: IFFALSE 21821
// begin _x := ShiftX ( x , i , 3 ) ;
21711: LD_ADDR_VAR 0 7
21715: PUSH
21716: LD_VAR 0 5
21720: PPUSH
21721: LD_VAR 0 4
21725: PPUSH
21726: LD_INT 3
21728: PPUSH
21729: CALL_OW 272
21733: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21734: LD_ADDR_VAR 0 8
21738: PUSH
21739: LD_VAR 0 6
21743: PPUSH
21744: LD_VAR 0 4
21748: PPUSH
21749: LD_INT 3
21751: PPUSH
21752: CALL_OW 273
21756: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21757: LD_VAR 0 7
21761: PPUSH
21762: LD_VAR 0 8
21766: PPUSH
21767: CALL_OW 488
21771: NOT
21772: IFFALSE 21776
// continue ;
21774: GO 21708
// if HexInfo ( _x , _y ) = 0 then
21776: LD_VAR 0 7
21780: PPUSH
21781: LD_VAR 0 8
21785: PPUSH
21786: CALL_OW 428
21790: PUSH
21791: LD_INT 0
21793: EQUAL
21794: IFFALSE 21819
// begin ComMoveXY ( unit , _x , _y ) ;
21796: LD_VAR 0 1
21800: PPUSH
21801: LD_VAR 0 7
21805: PPUSH
21806: LD_VAR 0 8
21810: PPUSH
21811: CALL_OW 111
// exit ;
21815: POP
21816: POP
21817: GO 21823
// end ; end ;
21819: GO 21708
21821: POP
21822: POP
// end ;
21823: LD_VAR 0 3
21827: RET
// export function ScanBase ( side , base_area ) ; begin
21828: LD_INT 0
21830: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21831: LD_ADDR_VAR 0 3
21835: PUSH
21836: LD_VAR 0 2
21840: PPUSH
21841: LD_INT 81
21843: PUSH
21844: LD_VAR 0 1
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: PPUSH
21853: CALL_OW 70
21857: ST_TO_ADDR
// end ;
21858: LD_VAR 0 3
21862: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21863: LD_INT 0
21865: PPUSH
21866: PPUSH
21867: PPUSH
21868: PPUSH
// result := false ;
21869: LD_ADDR_VAR 0 2
21873: PUSH
21874: LD_INT 0
21876: ST_TO_ADDR
// side := GetSide ( unit ) ;
21877: LD_ADDR_VAR 0 3
21881: PUSH
21882: LD_VAR 0 1
21886: PPUSH
21887: CALL_OW 255
21891: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21892: LD_ADDR_VAR 0 4
21896: PUSH
21897: LD_VAR 0 1
21901: PPUSH
21902: CALL_OW 248
21906: ST_TO_ADDR
// case nat of 1 :
21907: LD_VAR 0 4
21911: PUSH
21912: LD_INT 1
21914: DOUBLE
21915: EQUAL
21916: IFTRUE 21920
21918: GO 21931
21920: POP
// tech := tech_lassight ; 2 :
21921: LD_ADDR_VAR 0 5
21925: PUSH
21926: LD_INT 12
21928: ST_TO_ADDR
21929: GO 21970
21931: LD_INT 2
21933: DOUBLE
21934: EQUAL
21935: IFTRUE 21939
21937: GO 21950
21939: POP
// tech := tech_mortar ; 3 :
21940: LD_ADDR_VAR 0 5
21944: PUSH
21945: LD_INT 41
21947: ST_TO_ADDR
21948: GO 21970
21950: LD_INT 3
21952: DOUBLE
21953: EQUAL
21954: IFTRUE 21958
21956: GO 21969
21958: POP
// tech := tech_bazooka ; end ;
21959: LD_ADDR_VAR 0 5
21963: PUSH
21964: LD_INT 44
21966: ST_TO_ADDR
21967: GO 21970
21969: POP
// if Researched ( side , tech ) then
21970: LD_VAR 0 3
21974: PPUSH
21975: LD_VAR 0 5
21979: PPUSH
21980: CALL_OW 325
21984: IFFALSE 22011
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21986: LD_ADDR_VAR 0 2
21990: PUSH
21991: LD_INT 5
21993: PUSH
21994: LD_INT 8
21996: PUSH
21997: LD_INT 9
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: LIST
22004: PUSH
22005: LD_VAR 0 4
22009: ARRAY
22010: ST_TO_ADDR
// end ;
22011: LD_VAR 0 2
22015: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
22016: LD_INT 0
22018: PPUSH
22019: PPUSH
22020: PPUSH
// if not mines then
22021: LD_VAR 0 2
22025: NOT
22026: IFFALSE 22030
// exit ;
22028: GO 22174
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22030: LD_ADDR_VAR 0 5
22034: PUSH
22035: LD_INT 81
22037: PUSH
22038: LD_VAR 0 1
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: PUSH
22047: LD_INT 3
22049: PUSH
22050: LD_INT 21
22052: PUSH
22053: LD_INT 3
22055: PUSH
22056: EMPTY
22057: LIST
22058: LIST
22059: PUSH
22060: EMPTY
22061: LIST
22062: LIST
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: PPUSH
22068: CALL_OW 69
22072: ST_TO_ADDR
// for i in mines do
22073: LD_ADDR_VAR 0 4
22077: PUSH
22078: LD_VAR 0 2
22082: PUSH
22083: FOR_IN
22084: IFFALSE 22172
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
22086: LD_VAR 0 4
22090: PUSH
22091: LD_INT 1
22093: ARRAY
22094: PPUSH
22095: LD_VAR 0 4
22099: PUSH
22100: LD_INT 2
22102: ARRAY
22103: PPUSH
22104: CALL_OW 458
22108: NOT
22109: IFFALSE 22113
// continue ;
22111: GO 22083
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
22113: LD_VAR 0 4
22117: PUSH
22118: LD_INT 1
22120: ARRAY
22121: PPUSH
22122: LD_VAR 0 4
22126: PUSH
22127: LD_INT 2
22129: ARRAY
22130: PPUSH
22131: CALL_OW 428
22135: PUSH
22136: LD_VAR 0 5
22140: IN
22141: IFFALSE 22170
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
22143: LD_VAR 0 4
22147: PUSH
22148: LD_INT 1
22150: ARRAY
22151: PPUSH
22152: LD_VAR 0 4
22156: PUSH
22157: LD_INT 2
22159: ARRAY
22160: PPUSH
22161: LD_VAR 0 1
22165: PPUSH
22166: CALL_OW 456
// end ;
22170: GO 22083
22172: POP
22173: POP
// end ;
22174: LD_VAR 0 3
22178: RET
// export function Count ( array ) ; begin
22179: LD_INT 0
22181: PPUSH
// result := array + 0 ;
22182: LD_ADDR_VAR 0 2
22186: PUSH
22187: LD_VAR 0 1
22191: PUSH
22192: LD_INT 0
22194: PLUS
22195: ST_TO_ADDR
// end ;
22196: LD_VAR 0 2
22200: RET
// export function IsEmpty ( building ) ; begin
22201: LD_INT 0
22203: PPUSH
// if not building then
22204: LD_VAR 0 1
22208: NOT
22209: IFFALSE 22213
// exit ;
22211: GO 22256
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22213: LD_ADDR_VAR 0 2
22217: PUSH
22218: LD_VAR 0 1
22222: PUSH
22223: LD_INT 22
22225: PUSH
22226: LD_VAR 0 1
22230: PPUSH
22231: CALL_OW 255
22235: PUSH
22236: EMPTY
22237: LIST
22238: LIST
22239: PUSH
22240: LD_INT 58
22242: PUSH
22243: EMPTY
22244: LIST
22245: PUSH
22246: EMPTY
22247: LIST
22248: LIST
22249: PPUSH
22250: CALL_OW 69
22254: IN
22255: ST_TO_ADDR
// end ;
22256: LD_VAR 0 2
22260: RET
// export function IsNotFull ( building ) ; var places ; begin
22261: LD_INT 0
22263: PPUSH
22264: PPUSH
// if not building then
22265: LD_VAR 0 1
22269: NOT
22270: IFFALSE 22274
// exit ;
22272: GO 22302
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
22274: LD_ADDR_VAR 0 2
22278: PUSH
22279: LD_VAR 0 1
22283: PPUSH
22284: LD_INT 3
22286: PUSH
22287: LD_INT 62
22289: PUSH
22290: EMPTY
22291: LIST
22292: PUSH
22293: EMPTY
22294: LIST
22295: LIST
22296: PPUSH
22297: CALL_OW 72
22301: ST_TO_ADDR
// end ;
22302: LD_VAR 0 2
22306: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22307: LD_INT 0
22309: PPUSH
22310: PPUSH
22311: PPUSH
22312: PPUSH
// tmp := [ ] ;
22313: LD_ADDR_VAR 0 3
22317: PUSH
22318: EMPTY
22319: ST_TO_ADDR
// list := [ ] ;
22320: LD_ADDR_VAR 0 5
22324: PUSH
22325: EMPTY
22326: ST_TO_ADDR
// for i = 16 to 25 do
22327: LD_ADDR_VAR 0 4
22331: PUSH
22332: DOUBLE
22333: LD_INT 16
22335: DEC
22336: ST_TO_ADDR
22337: LD_INT 25
22339: PUSH
22340: FOR_TO
22341: IFFALSE 22414
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22343: LD_ADDR_VAR 0 3
22347: PUSH
22348: LD_VAR 0 3
22352: PUSH
22353: LD_INT 22
22355: PUSH
22356: LD_VAR 0 1
22360: PPUSH
22361: CALL_OW 255
22365: PUSH
22366: EMPTY
22367: LIST
22368: LIST
22369: PUSH
22370: LD_INT 91
22372: PUSH
22373: LD_VAR 0 1
22377: PUSH
22378: LD_INT 6
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: PUSH
22386: LD_INT 30
22388: PUSH
22389: LD_VAR 0 4
22393: PUSH
22394: EMPTY
22395: LIST
22396: LIST
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: LIST
22402: PUSH
22403: EMPTY
22404: LIST
22405: PPUSH
22406: CALL_OW 69
22410: ADD
22411: ST_TO_ADDR
22412: GO 22340
22414: POP
22415: POP
// for i = 1 to tmp do
22416: LD_ADDR_VAR 0 4
22420: PUSH
22421: DOUBLE
22422: LD_INT 1
22424: DEC
22425: ST_TO_ADDR
22426: LD_VAR 0 3
22430: PUSH
22431: FOR_TO
22432: IFFALSE 22520
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: LD_VAR 0 5
22443: PUSH
22444: LD_VAR 0 3
22448: PUSH
22449: LD_VAR 0 4
22453: ARRAY
22454: PPUSH
22455: CALL_OW 266
22459: PUSH
22460: LD_VAR 0 3
22464: PUSH
22465: LD_VAR 0 4
22469: ARRAY
22470: PPUSH
22471: CALL_OW 250
22475: PUSH
22476: LD_VAR 0 3
22480: PUSH
22481: LD_VAR 0 4
22485: ARRAY
22486: PPUSH
22487: CALL_OW 251
22491: PUSH
22492: LD_VAR 0 3
22496: PUSH
22497: LD_VAR 0 4
22501: ARRAY
22502: PPUSH
22503: CALL_OW 254
22507: PUSH
22508: EMPTY
22509: LIST
22510: LIST
22511: LIST
22512: LIST
22513: PUSH
22514: EMPTY
22515: LIST
22516: ADD
22517: ST_TO_ADDR
22518: GO 22431
22520: POP
22521: POP
// result := list ;
22522: LD_ADDR_VAR 0 2
22526: PUSH
22527: LD_VAR 0 5
22531: ST_TO_ADDR
// end ;
22532: LD_VAR 0 2
22536: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22537: LD_INT 0
22539: PPUSH
22540: PPUSH
22541: PPUSH
22542: PPUSH
22543: PPUSH
22544: PPUSH
22545: PPUSH
// if not factory then
22546: LD_VAR 0 1
22550: NOT
22551: IFFALSE 22555
// exit ;
22553: GO 23158
// if control = control_apeman then
22555: LD_VAR 0 4
22559: PUSH
22560: LD_INT 5
22562: EQUAL
22563: IFFALSE 22672
// begin tmp := UnitsInside ( factory ) ;
22565: LD_ADDR_VAR 0 8
22569: PUSH
22570: LD_VAR 0 1
22574: PPUSH
22575: CALL_OW 313
22579: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22580: LD_VAR 0 8
22584: PPUSH
22585: LD_INT 25
22587: PUSH
22588: LD_INT 12
22590: PUSH
22591: EMPTY
22592: LIST
22593: LIST
22594: PPUSH
22595: CALL_OW 72
22599: NOT
22600: IFFALSE 22610
// control := control_manual ;
22602: LD_ADDR_VAR 0 4
22606: PUSH
22607: LD_INT 1
22609: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22610: LD_ADDR_VAR 0 8
22614: PUSH
22615: LD_VAR 0 1
22619: PPUSH
22620: CALL 22307 0 1
22624: ST_TO_ADDR
// if tmp then
22625: LD_VAR 0 8
22629: IFFALSE 22672
// begin for i in tmp do
22631: LD_ADDR_VAR 0 7
22635: PUSH
22636: LD_VAR 0 8
22640: PUSH
22641: FOR_IN
22642: IFFALSE 22670
// if i [ 1 ] = b_ext_radio then
22644: LD_VAR 0 7
22648: PUSH
22649: LD_INT 1
22651: ARRAY
22652: PUSH
22653: LD_INT 22
22655: EQUAL
22656: IFFALSE 22668
// begin control := control_remote ;
22658: LD_ADDR_VAR 0 4
22662: PUSH
22663: LD_INT 2
22665: ST_TO_ADDR
// break ;
22666: GO 22670
// end ;
22668: GO 22641
22670: POP
22671: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22672: LD_VAR 0 1
22676: PPUSH
22677: LD_VAR 0 2
22681: PPUSH
22682: LD_VAR 0 3
22686: PPUSH
22687: LD_VAR 0 4
22691: PPUSH
22692: LD_VAR 0 5
22696: PPUSH
22697: CALL_OW 448
22701: IFFALSE 22736
// begin result := [ chassis , engine , control , weapon ] ;
22703: LD_ADDR_VAR 0 6
22707: PUSH
22708: LD_VAR 0 2
22712: PUSH
22713: LD_VAR 0 3
22717: PUSH
22718: LD_VAR 0 4
22722: PUSH
22723: LD_VAR 0 5
22727: PUSH
22728: EMPTY
22729: LIST
22730: LIST
22731: LIST
22732: LIST
22733: ST_TO_ADDR
// exit ;
22734: GO 23158
// end ; _chassis := AvailableChassisList ( factory ) ;
22736: LD_ADDR_VAR 0 9
22740: PUSH
22741: LD_VAR 0 1
22745: PPUSH
22746: CALL_OW 475
22750: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22751: LD_ADDR_VAR 0 11
22755: PUSH
22756: LD_VAR 0 1
22760: PPUSH
22761: CALL_OW 476
22765: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22766: LD_ADDR_VAR 0 12
22770: PUSH
22771: LD_VAR 0 1
22775: PPUSH
22776: CALL_OW 477
22780: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22781: LD_ADDR_VAR 0 10
22785: PUSH
22786: LD_VAR 0 1
22790: PPUSH
22791: CALL_OW 478
22795: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22796: LD_VAR 0 9
22800: NOT
22801: IFTRUE 22810
22803: PUSH
22804: LD_VAR 0 11
22808: NOT
22809: OR
22810: IFTRUE 22819
22812: PUSH
22813: LD_VAR 0 12
22817: NOT
22818: OR
22819: IFTRUE 22828
22821: PUSH
22822: LD_VAR 0 10
22826: NOT
22827: OR
22828: IFFALSE 22863
// begin result := [ chassis , engine , control , weapon ] ;
22830: LD_ADDR_VAR 0 6
22834: PUSH
22835: LD_VAR 0 2
22839: PUSH
22840: LD_VAR 0 3
22844: PUSH
22845: LD_VAR 0 4
22849: PUSH
22850: LD_VAR 0 5
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: LIST
22860: ST_TO_ADDR
// exit ;
22861: GO 23158
// end ; if not chassis in _chassis then
22863: LD_VAR 0 2
22867: PUSH
22868: LD_VAR 0 9
22872: IN
22873: NOT
22874: IFFALSE 22900
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22876: LD_ADDR_VAR 0 2
22880: PUSH
22881: LD_VAR 0 9
22885: PUSH
22886: LD_INT 1
22888: PPUSH
22889: LD_VAR 0 9
22893: PPUSH
22894: CALL_OW 12
22898: ARRAY
22899: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22900: LD_VAR 0 2
22904: PPUSH
22905: LD_VAR 0 3
22909: PPUSH
22910: CALL 23163 0 2
22914: NOT
22915: IFFALSE 22976
// repeat engine := _engine [ 1 ] ;
22917: LD_ADDR_VAR 0 3
22921: PUSH
22922: LD_VAR 0 11
22926: PUSH
22927: LD_INT 1
22929: ARRAY
22930: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22931: LD_ADDR_VAR 0 11
22935: PUSH
22936: LD_VAR 0 11
22940: PPUSH
22941: LD_INT 1
22943: PPUSH
22944: CALL_OW 3
22948: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22949: LD_VAR 0 2
22953: PPUSH
22954: LD_VAR 0 3
22958: PPUSH
22959: CALL 23163 0 2
22963: IFTRUE 22974
22965: PUSH
22966: LD_VAR 0 11
22970: PUSH
22971: EMPTY
22972: EQUAL
22973: OR
22974: IFFALSE 22917
// if not control in _control then
22976: LD_VAR 0 4
22980: PUSH
22981: LD_VAR 0 12
22985: IN
22986: NOT
22987: IFFALSE 23013
// control := _control [ rand ( 1 , _control ) ] ;
22989: LD_ADDR_VAR 0 4
22993: PUSH
22994: LD_VAR 0 12
22998: PUSH
22999: LD_INT 1
23001: PPUSH
23002: LD_VAR 0 12
23006: PPUSH
23007: CALL_OW 12
23011: ARRAY
23012: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
23013: LD_VAR 0 2
23017: PPUSH
23018: LD_VAR 0 5
23022: PPUSH
23023: CALL 23385 0 2
23027: NOT
23028: IFFALSE 23089
// repeat weapon := _weapon [ 1 ] ;
23030: LD_ADDR_VAR 0 5
23034: PUSH
23035: LD_VAR 0 10
23039: PUSH
23040: LD_INT 1
23042: ARRAY
23043: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
23044: LD_ADDR_VAR 0 10
23048: PUSH
23049: LD_VAR 0 10
23053: PPUSH
23054: LD_INT 1
23056: PPUSH
23057: CALL_OW 3
23061: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
23062: LD_VAR 0 2
23066: PPUSH
23067: LD_VAR 0 5
23071: PPUSH
23072: CALL 23385 0 2
23076: IFTRUE 23087
23078: PUSH
23079: LD_VAR 0 10
23083: PUSH
23084: EMPTY
23085: EQUAL
23086: OR
23087: IFFALSE 23030
// result := [ ] ;
23089: LD_ADDR_VAR 0 6
23093: PUSH
23094: EMPTY
23095: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
23096: LD_VAR 0 1
23100: PPUSH
23101: LD_VAR 0 2
23105: PPUSH
23106: LD_VAR 0 3
23110: PPUSH
23111: LD_VAR 0 4
23115: PPUSH
23116: LD_VAR 0 5
23120: PPUSH
23121: CALL_OW 448
23125: IFFALSE 23158
// result := [ chassis , engine , control , weapon ] ;
23127: LD_ADDR_VAR 0 6
23131: PUSH
23132: LD_VAR 0 2
23136: PUSH
23137: LD_VAR 0 3
23141: PUSH
23142: LD_VAR 0 4
23146: PUSH
23147: LD_VAR 0 5
23151: PUSH
23152: EMPTY
23153: LIST
23154: LIST
23155: LIST
23156: LIST
23157: ST_TO_ADDR
// end ;
23158: LD_VAR 0 6
23162: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
23163: LD_INT 0
23165: PPUSH
// if not chassis or not engine then
23166: LD_VAR 0 1
23170: NOT
23171: IFTRUE 23180
23173: PUSH
23174: LD_VAR 0 2
23178: NOT
23179: OR
23180: IFFALSE 23184
// exit ;
23182: GO 23380
// case engine of engine_solar :
23184: LD_VAR 0 2
23188: PUSH
23189: LD_INT 2
23191: DOUBLE
23192: EQUAL
23193: IFTRUE 23197
23195: GO 23235
23197: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
23198: LD_ADDR_VAR 0 3
23202: PUSH
23203: LD_INT 11
23205: PUSH
23206: LD_INT 12
23208: PUSH
23209: LD_INT 13
23211: PUSH
23212: LD_INT 14
23214: PUSH
23215: LD_INT 1
23217: PUSH
23218: LD_INT 2
23220: PUSH
23221: LD_INT 3
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: ST_TO_ADDR
23233: GO 23364
23235: LD_INT 1
23237: DOUBLE
23238: EQUAL
23239: IFTRUE 23243
23241: GO 23305
23243: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23244: LD_ADDR_VAR 0 3
23248: PUSH
23249: LD_INT 11
23251: PUSH
23252: LD_INT 12
23254: PUSH
23255: LD_INT 13
23257: PUSH
23258: LD_INT 14
23260: PUSH
23261: LD_INT 1
23263: PUSH
23264: LD_INT 2
23266: PUSH
23267: LD_INT 3
23269: PUSH
23270: LD_INT 4
23272: PUSH
23273: LD_INT 5
23275: PUSH
23276: LD_INT 21
23278: PUSH
23279: LD_INT 23
23281: PUSH
23282: LD_INT 22
23284: PUSH
23285: LD_INT 24
23287: PUSH
23288: EMPTY
23289: LIST
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: LIST
23295: LIST
23296: LIST
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: LIST
23302: ST_TO_ADDR
23303: GO 23364
23305: LD_INT 3
23307: DOUBLE
23308: EQUAL
23309: IFTRUE 23313
23311: GO 23363
23313: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23314: LD_ADDR_VAR 0 3
23318: PUSH
23319: LD_INT 13
23321: PUSH
23322: LD_INT 14
23324: PUSH
23325: LD_INT 2
23327: PUSH
23328: LD_INT 3
23330: PUSH
23331: LD_INT 4
23333: PUSH
23334: LD_INT 5
23336: PUSH
23337: LD_INT 21
23339: PUSH
23340: LD_INT 22
23342: PUSH
23343: LD_INT 23
23345: PUSH
23346: LD_INT 24
23348: PUSH
23349: EMPTY
23350: LIST
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: LIST
23356: LIST
23357: LIST
23358: LIST
23359: LIST
23360: ST_TO_ADDR
23361: GO 23364
23363: POP
// result := ( chassis in result ) ;
23364: LD_ADDR_VAR 0 3
23368: PUSH
23369: LD_VAR 0 1
23373: PUSH
23374: LD_VAR 0 3
23378: IN
23379: ST_TO_ADDR
// end ;
23380: LD_VAR 0 3
23384: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23385: LD_INT 0
23387: PPUSH
// if not chassis or not weapon then
23388: LD_VAR 0 1
23392: NOT
23393: IFTRUE 23402
23395: PUSH
23396: LD_VAR 0 2
23400: NOT
23401: OR
23402: IFFALSE 23406
// exit ;
23404: GO 24466
// case weapon of us_machine_gun :
23406: LD_VAR 0 2
23410: PUSH
23411: LD_INT 2
23413: DOUBLE
23414: EQUAL
23415: IFTRUE 23419
23417: GO 23449
23419: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23420: LD_ADDR_VAR 0 3
23424: PUSH
23425: LD_INT 1
23427: PUSH
23428: LD_INT 2
23430: PUSH
23431: LD_INT 3
23433: PUSH
23434: LD_INT 4
23436: PUSH
23437: LD_INT 5
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: LIST
23444: LIST
23445: LIST
23446: ST_TO_ADDR
23447: GO 24450
23449: LD_INT 3
23451: DOUBLE
23452: EQUAL
23453: IFTRUE 23457
23455: GO 23487
23457: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23458: LD_ADDR_VAR 0 3
23462: PUSH
23463: LD_INT 1
23465: PUSH
23466: LD_INT 2
23468: PUSH
23469: LD_INT 3
23471: PUSH
23472: LD_INT 4
23474: PUSH
23475: LD_INT 5
23477: PUSH
23478: EMPTY
23479: LIST
23480: LIST
23481: LIST
23482: LIST
23483: LIST
23484: ST_TO_ADDR
23485: GO 24450
23487: LD_INT 11
23489: DOUBLE
23490: EQUAL
23491: IFTRUE 23495
23493: GO 23525
23495: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23496: LD_ADDR_VAR 0 3
23500: PUSH
23501: LD_INT 1
23503: PUSH
23504: LD_INT 2
23506: PUSH
23507: LD_INT 3
23509: PUSH
23510: LD_INT 4
23512: PUSH
23513: LD_INT 5
23515: PUSH
23516: EMPTY
23517: LIST
23518: LIST
23519: LIST
23520: LIST
23521: LIST
23522: ST_TO_ADDR
23523: GO 24450
23525: LD_INT 4
23527: DOUBLE
23528: EQUAL
23529: IFTRUE 23533
23531: GO 23559
23533: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23534: LD_ADDR_VAR 0 3
23538: PUSH
23539: LD_INT 2
23541: PUSH
23542: LD_INT 3
23544: PUSH
23545: LD_INT 4
23547: PUSH
23548: LD_INT 5
23550: PUSH
23551: EMPTY
23552: LIST
23553: LIST
23554: LIST
23555: LIST
23556: ST_TO_ADDR
23557: GO 24450
23559: LD_INT 5
23561: DOUBLE
23562: EQUAL
23563: IFTRUE 23567
23565: GO 23593
23567: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23568: LD_ADDR_VAR 0 3
23572: PUSH
23573: LD_INT 2
23575: PUSH
23576: LD_INT 3
23578: PUSH
23579: LD_INT 4
23581: PUSH
23582: LD_INT 5
23584: PUSH
23585: EMPTY
23586: LIST
23587: LIST
23588: LIST
23589: LIST
23590: ST_TO_ADDR
23591: GO 24450
23593: LD_INT 9
23595: DOUBLE
23596: EQUAL
23597: IFTRUE 23601
23599: GO 23627
23601: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23602: LD_ADDR_VAR 0 3
23606: PUSH
23607: LD_INT 2
23609: PUSH
23610: LD_INT 3
23612: PUSH
23613: LD_INT 4
23615: PUSH
23616: LD_INT 5
23618: PUSH
23619: EMPTY
23620: LIST
23621: LIST
23622: LIST
23623: LIST
23624: ST_TO_ADDR
23625: GO 24450
23627: LD_INT 7
23629: DOUBLE
23630: EQUAL
23631: IFTRUE 23635
23633: GO 23661
23635: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23636: LD_ADDR_VAR 0 3
23640: PUSH
23641: LD_INT 2
23643: PUSH
23644: LD_INT 3
23646: PUSH
23647: LD_INT 4
23649: PUSH
23650: LD_INT 5
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: LIST
23657: LIST
23658: ST_TO_ADDR
23659: GO 24450
23661: LD_INT 12
23663: DOUBLE
23664: EQUAL
23665: IFTRUE 23669
23667: GO 23695
23669: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23670: LD_ADDR_VAR 0 3
23674: PUSH
23675: LD_INT 2
23677: PUSH
23678: LD_INT 3
23680: PUSH
23681: LD_INT 4
23683: PUSH
23684: LD_INT 5
23686: PUSH
23687: EMPTY
23688: LIST
23689: LIST
23690: LIST
23691: LIST
23692: ST_TO_ADDR
23693: GO 24450
23695: LD_INT 13
23697: DOUBLE
23698: EQUAL
23699: IFTRUE 23703
23701: GO 23729
23703: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23704: LD_ADDR_VAR 0 3
23708: PUSH
23709: LD_INT 2
23711: PUSH
23712: LD_INT 3
23714: PUSH
23715: LD_INT 4
23717: PUSH
23718: LD_INT 5
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: LIST
23725: LIST
23726: ST_TO_ADDR
23727: GO 24450
23729: LD_INT 14
23731: DOUBLE
23732: EQUAL
23733: IFTRUE 23737
23735: GO 23755
23737: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23738: LD_ADDR_VAR 0 3
23742: PUSH
23743: LD_INT 4
23745: PUSH
23746: LD_INT 5
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: ST_TO_ADDR
23753: GO 24450
23755: LD_INT 6
23757: DOUBLE
23758: EQUAL
23759: IFTRUE 23763
23761: GO 23781
23763: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23764: LD_ADDR_VAR 0 3
23768: PUSH
23769: LD_INT 4
23771: PUSH
23772: LD_INT 5
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: ST_TO_ADDR
23779: GO 24450
23781: LD_INT 10
23783: DOUBLE
23784: EQUAL
23785: IFTRUE 23789
23787: GO 23807
23789: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23790: LD_ADDR_VAR 0 3
23794: PUSH
23795: LD_INT 4
23797: PUSH
23798: LD_INT 5
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: ST_TO_ADDR
23805: GO 24450
23807: LD_INT 22
23809: DOUBLE
23810: EQUAL
23811: IFTRUE 23815
23813: GO 23841
23815: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23816: LD_ADDR_VAR 0 3
23820: PUSH
23821: LD_INT 11
23823: PUSH
23824: LD_INT 12
23826: PUSH
23827: LD_INT 13
23829: PUSH
23830: LD_INT 14
23832: PUSH
23833: EMPTY
23834: LIST
23835: LIST
23836: LIST
23837: LIST
23838: ST_TO_ADDR
23839: GO 24450
23841: LD_INT 23
23843: DOUBLE
23844: EQUAL
23845: IFTRUE 23849
23847: GO 23875
23849: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23850: LD_ADDR_VAR 0 3
23854: PUSH
23855: LD_INT 11
23857: PUSH
23858: LD_INT 12
23860: PUSH
23861: LD_INT 13
23863: PUSH
23864: LD_INT 14
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: LIST
23871: LIST
23872: ST_TO_ADDR
23873: GO 24450
23875: LD_INT 24
23877: DOUBLE
23878: EQUAL
23879: IFTRUE 23883
23881: GO 23909
23883: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23884: LD_ADDR_VAR 0 3
23888: PUSH
23889: LD_INT 11
23891: PUSH
23892: LD_INT 12
23894: PUSH
23895: LD_INT 13
23897: PUSH
23898: LD_INT 14
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: LIST
23905: LIST
23906: ST_TO_ADDR
23907: GO 24450
23909: LD_INT 30
23911: DOUBLE
23912: EQUAL
23913: IFTRUE 23917
23915: GO 23943
23917: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23918: LD_ADDR_VAR 0 3
23922: PUSH
23923: LD_INT 11
23925: PUSH
23926: LD_INT 12
23928: PUSH
23929: LD_INT 13
23931: PUSH
23932: LD_INT 14
23934: PUSH
23935: EMPTY
23936: LIST
23937: LIST
23938: LIST
23939: LIST
23940: ST_TO_ADDR
23941: GO 24450
23943: LD_INT 25
23945: DOUBLE
23946: EQUAL
23947: IFTRUE 23951
23949: GO 23969
23951: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23952: LD_ADDR_VAR 0 3
23956: PUSH
23957: LD_INT 13
23959: PUSH
23960: LD_INT 14
23962: PUSH
23963: EMPTY
23964: LIST
23965: LIST
23966: ST_TO_ADDR
23967: GO 24450
23969: LD_INT 27
23971: DOUBLE
23972: EQUAL
23973: IFTRUE 23977
23975: GO 23995
23977: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23978: LD_ADDR_VAR 0 3
23982: PUSH
23983: LD_INT 13
23985: PUSH
23986: LD_INT 14
23988: PUSH
23989: EMPTY
23990: LIST
23991: LIST
23992: ST_TO_ADDR
23993: GO 24450
23995: LD_INT 92
23997: DOUBLE
23998: EQUAL
23999: IFTRUE 24003
24001: GO 24029
24003: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
24004: LD_ADDR_VAR 0 3
24008: PUSH
24009: LD_INT 11
24011: PUSH
24012: LD_INT 12
24014: PUSH
24015: LD_INT 13
24017: PUSH
24018: LD_INT 14
24020: PUSH
24021: EMPTY
24022: LIST
24023: LIST
24024: LIST
24025: LIST
24026: ST_TO_ADDR
24027: GO 24450
24029: LD_INT 28
24031: DOUBLE
24032: EQUAL
24033: IFTRUE 24037
24035: GO 24055
24037: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
24038: LD_ADDR_VAR 0 3
24042: PUSH
24043: LD_INT 13
24045: PUSH
24046: LD_INT 14
24048: PUSH
24049: EMPTY
24050: LIST
24051: LIST
24052: ST_TO_ADDR
24053: GO 24450
24055: LD_INT 29
24057: DOUBLE
24058: EQUAL
24059: IFTRUE 24063
24061: GO 24081
24063: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
24064: LD_ADDR_VAR 0 3
24068: PUSH
24069: LD_INT 13
24071: PUSH
24072: LD_INT 14
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: ST_TO_ADDR
24079: GO 24450
24081: LD_INT 31
24083: DOUBLE
24084: EQUAL
24085: IFTRUE 24089
24087: GO 24107
24089: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
24090: LD_ADDR_VAR 0 3
24094: PUSH
24095: LD_INT 13
24097: PUSH
24098: LD_INT 14
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: ST_TO_ADDR
24105: GO 24450
24107: LD_INT 26
24109: DOUBLE
24110: EQUAL
24111: IFTRUE 24115
24113: GO 24133
24115: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
24116: LD_ADDR_VAR 0 3
24120: PUSH
24121: LD_INT 13
24123: PUSH
24124: LD_INT 14
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: ST_TO_ADDR
24131: GO 24450
24133: LD_INT 42
24135: DOUBLE
24136: EQUAL
24137: IFTRUE 24141
24139: GO 24167
24141: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
24142: LD_ADDR_VAR 0 3
24146: PUSH
24147: LD_INT 21
24149: PUSH
24150: LD_INT 22
24152: PUSH
24153: LD_INT 23
24155: PUSH
24156: LD_INT 24
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: ST_TO_ADDR
24165: GO 24450
24167: LD_INT 43
24169: DOUBLE
24170: EQUAL
24171: IFTRUE 24175
24173: GO 24201
24175: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
24176: LD_ADDR_VAR 0 3
24180: PUSH
24181: LD_INT 21
24183: PUSH
24184: LD_INT 22
24186: PUSH
24187: LD_INT 23
24189: PUSH
24190: LD_INT 24
24192: PUSH
24193: EMPTY
24194: LIST
24195: LIST
24196: LIST
24197: LIST
24198: ST_TO_ADDR
24199: GO 24450
24201: LD_INT 44
24203: DOUBLE
24204: EQUAL
24205: IFTRUE 24209
24207: GO 24235
24209: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24210: LD_ADDR_VAR 0 3
24214: PUSH
24215: LD_INT 21
24217: PUSH
24218: LD_INT 22
24220: PUSH
24221: LD_INT 23
24223: PUSH
24224: LD_INT 24
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: ST_TO_ADDR
24233: GO 24450
24235: LD_INT 45
24237: DOUBLE
24238: EQUAL
24239: IFTRUE 24243
24241: GO 24269
24243: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24244: LD_ADDR_VAR 0 3
24248: PUSH
24249: LD_INT 21
24251: PUSH
24252: LD_INT 22
24254: PUSH
24255: LD_INT 23
24257: PUSH
24258: LD_INT 24
24260: PUSH
24261: EMPTY
24262: LIST
24263: LIST
24264: LIST
24265: LIST
24266: ST_TO_ADDR
24267: GO 24450
24269: LD_INT 49
24271: DOUBLE
24272: EQUAL
24273: IFTRUE 24277
24275: GO 24303
24277: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24278: LD_ADDR_VAR 0 3
24282: PUSH
24283: LD_INT 21
24285: PUSH
24286: LD_INT 22
24288: PUSH
24289: LD_INT 23
24291: PUSH
24292: LD_INT 24
24294: PUSH
24295: EMPTY
24296: LIST
24297: LIST
24298: LIST
24299: LIST
24300: ST_TO_ADDR
24301: GO 24450
24303: LD_INT 51
24305: DOUBLE
24306: EQUAL
24307: IFTRUE 24311
24309: GO 24337
24311: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24312: LD_ADDR_VAR 0 3
24316: PUSH
24317: LD_INT 21
24319: PUSH
24320: LD_INT 22
24322: PUSH
24323: LD_INT 23
24325: PUSH
24326: LD_INT 24
24328: PUSH
24329: EMPTY
24330: LIST
24331: LIST
24332: LIST
24333: LIST
24334: ST_TO_ADDR
24335: GO 24450
24337: LD_INT 52
24339: DOUBLE
24340: EQUAL
24341: IFTRUE 24345
24343: GO 24371
24345: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24346: LD_ADDR_VAR 0 3
24350: PUSH
24351: LD_INT 21
24353: PUSH
24354: LD_INT 22
24356: PUSH
24357: LD_INT 23
24359: PUSH
24360: LD_INT 24
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: LIST
24367: LIST
24368: ST_TO_ADDR
24369: GO 24450
24371: LD_INT 53
24373: DOUBLE
24374: EQUAL
24375: IFTRUE 24379
24377: GO 24397
24379: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24380: LD_ADDR_VAR 0 3
24384: PUSH
24385: LD_INT 23
24387: PUSH
24388: LD_INT 24
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: ST_TO_ADDR
24395: GO 24450
24397: LD_INT 46
24399: DOUBLE
24400: EQUAL
24401: IFTRUE 24405
24403: GO 24423
24405: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24406: LD_ADDR_VAR 0 3
24410: PUSH
24411: LD_INT 23
24413: PUSH
24414: LD_INT 24
24416: PUSH
24417: EMPTY
24418: LIST
24419: LIST
24420: ST_TO_ADDR
24421: GO 24450
24423: LD_INT 47
24425: DOUBLE
24426: EQUAL
24427: IFTRUE 24431
24429: GO 24449
24431: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24432: LD_ADDR_VAR 0 3
24436: PUSH
24437: LD_INT 23
24439: PUSH
24440: LD_INT 24
24442: PUSH
24443: EMPTY
24444: LIST
24445: LIST
24446: ST_TO_ADDR
24447: GO 24450
24449: POP
// result := ( chassis in result ) ;
24450: LD_ADDR_VAR 0 3
24454: PUSH
24455: LD_VAR 0 1
24459: PUSH
24460: LD_VAR 0 3
24464: IN
24465: ST_TO_ADDR
// end ;
24466: LD_VAR 0 3
24470: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24471: LD_INT 0
24473: PPUSH
24474: PPUSH
24475: PPUSH
24476: PPUSH
24477: PPUSH
24478: PPUSH
24479: PPUSH
// result := array ;
24480: LD_ADDR_VAR 0 5
24484: PUSH
24485: LD_VAR 0 1
24489: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24490: LD_VAR 0 1
24494: NOT
24495: IFTRUE 24504
24497: PUSH
24498: LD_VAR 0 2
24502: NOT
24503: OR
24504: IFTRUE 24513
24506: PUSH
24507: LD_VAR 0 3
24511: NOT
24512: OR
24513: IFTRUE 24527
24515: PUSH
24516: LD_VAR 0 2
24520: PUSH
24521: LD_VAR 0 1
24525: GREATER
24526: OR
24527: IFTRUE 24541
24529: PUSH
24530: LD_VAR 0 3
24534: PUSH
24535: LD_VAR 0 1
24539: GREATER
24540: OR
24541: IFFALSE 24545
// exit ;
24543: GO 24841
// if direction then
24545: LD_VAR 0 4
24549: IFFALSE 24613
// begin d := 1 ;
24551: LD_ADDR_VAR 0 9
24555: PUSH
24556: LD_INT 1
24558: ST_TO_ADDR
// if i_from > i_to then
24559: LD_VAR 0 2
24563: PUSH
24564: LD_VAR 0 3
24568: GREATER
24569: IFFALSE 24595
// length := ( array - i_from ) + i_to else
24571: LD_ADDR_VAR 0 11
24575: PUSH
24576: LD_VAR 0 1
24580: PUSH
24581: LD_VAR 0 2
24585: MINUS
24586: PUSH
24587: LD_VAR 0 3
24591: PLUS
24592: ST_TO_ADDR
24593: GO 24611
// length := i_to - i_from ;
24595: LD_ADDR_VAR 0 11
24599: PUSH
24600: LD_VAR 0 3
24604: PUSH
24605: LD_VAR 0 2
24609: MINUS
24610: ST_TO_ADDR
// end else
24611: GO 24674
// begin d := - 1 ;
24613: LD_ADDR_VAR 0 9
24617: PUSH
24618: LD_INT 1
24620: NEG
24621: ST_TO_ADDR
// if i_from > i_to then
24622: LD_VAR 0 2
24626: PUSH
24627: LD_VAR 0 3
24631: GREATER
24632: IFFALSE 24652
// length := i_from - i_to else
24634: LD_ADDR_VAR 0 11
24638: PUSH
24639: LD_VAR 0 2
24643: PUSH
24644: LD_VAR 0 3
24648: MINUS
24649: ST_TO_ADDR
24650: GO 24674
// length := ( array - i_to ) + i_from ;
24652: LD_ADDR_VAR 0 11
24656: PUSH
24657: LD_VAR 0 1
24661: PUSH
24662: LD_VAR 0 3
24666: MINUS
24667: PUSH
24668: LD_VAR 0 2
24672: PLUS
24673: ST_TO_ADDR
// end ; if not length then
24674: LD_VAR 0 11
24678: NOT
24679: IFFALSE 24683
// exit ;
24681: GO 24841
// tmp := array ;
24683: LD_ADDR_VAR 0 10
24687: PUSH
24688: LD_VAR 0 1
24692: ST_TO_ADDR
// for i = 1 to length do
24693: LD_ADDR_VAR 0 6
24697: PUSH
24698: DOUBLE
24699: LD_INT 1
24701: DEC
24702: ST_TO_ADDR
24703: LD_VAR 0 11
24707: PUSH
24708: FOR_TO
24709: IFFALSE 24829
// begin for j = 1 to array do
24711: LD_ADDR_VAR 0 7
24715: PUSH
24716: DOUBLE
24717: LD_INT 1
24719: DEC
24720: ST_TO_ADDR
24721: LD_VAR 0 1
24725: PUSH
24726: FOR_TO
24727: IFFALSE 24815
// begin k := j + d ;
24729: LD_ADDR_VAR 0 8
24733: PUSH
24734: LD_VAR 0 7
24738: PUSH
24739: LD_VAR 0 9
24743: PLUS
24744: ST_TO_ADDR
// if k > array then
24745: LD_VAR 0 8
24749: PUSH
24750: LD_VAR 0 1
24754: GREATER
24755: IFFALSE 24765
// k := 1 ;
24757: LD_ADDR_VAR 0 8
24761: PUSH
24762: LD_INT 1
24764: ST_TO_ADDR
// if not k then
24765: LD_VAR 0 8
24769: NOT
24770: IFFALSE 24782
// k := array ;
24772: LD_ADDR_VAR 0 8
24776: PUSH
24777: LD_VAR 0 1
24781: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24782: LD_ADDR_VAR 0 10
24786: PUSH
24787: LD_VAR 0 10
24791: PPUSH
24792: LD_VAR 0 8
24796: PPUSH
24797: LD_VAR 0 1
24801: PUSH
24802: LD_VAR 0 7
24806: ARRAY
24807: PPUSH
24808: CALL_OW 1
24812: ST_TO_ADDR
// end ;
24813: GO 24726
24815: POP
24816: POP
// array := tmp ;
24817: LD_ADDR_VAR 0 1
24821: PUSH
24822: LD_VAR 0 10
24826: ST_TO_ADDR
// end ;
24827: GO 24708
24829: POP
24830: POP
// result := array ;
24831: LD_ADDR_VAR 0 5
24835: PUSH
24836: LD_VAR 0 1
24840: ST_TO_ADDR
// end ;
24841: LD_VAR 0 5
24845: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24846: LD_INT 0
24848: PPUSH
24849: PPUSH
// result := 0 ;
24850: LD_ADDR_VAR 0 3
24854: PUSH
24855: LD_INT 0
24857: ST_TO_ADDR
// if not array or not value in array then
24858: LD_VAR 0 1
24862: NOT
24863: IFTRUE 24878
24865: PUSH
24866: LD_VAR 0 2
24870: PUSH
24871: LD_VAR 0 1
24875: IN
24876: NOT
24877: OR
24878: IFFALSE 24882
// exit ;
24880: GO 24936
// for i = 1 to array do
24882: LD_ADDR_VAR 0 4
24886: PUSH
24887: DOUBLE
24888: LD_INT 1
24890: DEC
24891: ST_TO_ADDR
24892: LD_VAR 0 1
24896: PUSH
24897: FOR_TO
24898: IFFALSE 24934
// if value = array [ i ] then
24900: LD_VAR 0 2
24904: PUSH
24905: LD_VAR 0 1
24909: PUSH
24910: LD_VAR 0 4
24914: ARRAY
24915: EQUAL
24916: IFFALSE 24932
// begin result := i ;
24918: LD_ADDR_VAR 0 3
24922: PUSH
24923: LD_VAR 0 4
24927: ST_TO_ADDR
// exit ;
24928: POP
24929: POP
24930: GO 24936
// end ;
24932: GO 24897
24934: POP
24935: POP
// end ;
24936: LD_VAR 0 3
24940: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24941: LD_INT 0
24943: PPUSH
// vc_chassis := chassis ;
24944: LD_ADDR_OWVAR 37
24948: PUSH
24949: LD_VAR 0 1
24953: ST_TO_ADDR
// vc_engine := engine ;
24954: LD_ADDR_OWVAR 39
24958: PUSH
24959: LD_VAR 0 2
24963: ST_TO_ADDR
// vc_control := control ;
24964: LD_ADDR_OWVAR 38
24968: PUSH
24969: LD_VAR 0 3
24973: ST_TO_ADDR
// vc_weapon := weapon ;
24974: LD_ADDR_OWVAR 40
24978: PUSH
24979: LD_VAR 0 4
24983: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24984: LD_ADDR_OWVAR 41
24988: PUSH
24989: LD_VAR 0 5
24993: ST_TO_ADDR
// end ;
24994: LD_VAR 0 6
24998: RET
// export function WantPlant ( unit ) ; var task ; begin
24999: LD_INT 0
25001: PPUSH
25002: PPUSH
// result := false ;
25003: LD_ADDR_VAR 0 2
25007: PUSH
25008: LD_INT 0
25010: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
25011: LD_ADDR_VAR 0 3
25015: PUSH
25016: LD_VAR 0 1
25020: PPUSH
25021: CALL_OW 437
25025: ST_TO_ADDR
// if task then
25026: LD_VAR 0 3
25030: IFFALSE 25058
// if task [ 1 ] [ 1 ] = p then
25032: LD_VAR 0 3
25036: PUSH
25037: LD_INT 1
25039: ARRAY
25040: PUSH
25041: LD_INT 1
25043: ARRAY
25044: PUSH
25045: LD_STRING p
25047: EQUAL
25048: IFFALSE 25058
// result := true ;
25050: LD_ADDR_VAR 0 2
25054: PUSH
25055: LD_INT 1
25057: ST_TO_ADDR
// end ;
25058: LD_VAR 0 2
25062: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
25063: LD_INT 0
25065: PPUSH
25066: PPUSH
25067: PPUSH
25068: PPUSH
// if pos < 1 then
25069: LD_VAR 0 2
25073: PUSH
25074: LD_INT 1
25076: LESS
25077: IFFALSE 25081
// exit ;
25079: GO 25384
// if pos = 1 then
25081: LD_VAR 0 2
25085: PUSH
25086: LD_INT 1
25088: EQUAL
25089: IFFALSE 25122
// result := Replace ( arr , pos [ 1 ] , value ) else
25091: LD_ADDR_VAR 0 4
25095: PUSH
25096: LD_VAR 0 1
25100: PPUSH
25101: LD_VAR 0 2
25105: PUSH
25106: LD_INT 1
25108: ARRAY
25109: PPUSH
25110: LD_VAR 0 3
25114: PPUSH
25115: CALL_OW 1
25119: ST_TO_ADDR
25120: GO 25384
// begin tmp := arr ;
25122: LD_ADDR_VAR 0 6
25126: PUSH
25127: LD_VAR 0 1
25131: ST_TO_ADDR
// s_arr := [ tmp ] ;
25132: LD_ADDR_VAR 0 7
25136: PUSH
25137: LD_VAR 0 6
25141: PUSH
25142: EMPTY
25143: LIST
25144: ST_TO_ADDR
// for i = 1 to pos - 1 do
25145: LD_ADDR_VAR 0 5
25149: PUSH
25150: DOUBLE
25151: LD_INT 1
25153: DEC
25154: ST_TO_ADDR
25155: LD_VAR 0 2
25159: PUSH
25160: LD_INT 1
25162: MINUS
25163: PUSH
25164: FOR_TO
25165: IFFALSE 25210
// begin tmp := tmp [ pos [ i ] ] ;
25167: LD_ADDR_VAR 0 6
25171: PUSH
25172: LD_VAR 0 6
25176: PUSH
25177: LD_VAR 0 2
25181: PUSH
25182: LD_VAR 0 5
25186: ARRAY
25187: ARRAY
25188: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
25189: LD_ADDR_VAR 0 7
25193: PUSH
25194: LD_VAR 0 7
25198: PUSH
25199: LD_VAR 0 6
25203: PUSH
25204: EMPTY
25205: LIST
25206: ADD
25207: ST_TO_ADDR
// end ;
25208: GO 25164
25210: POP
25211: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
25212: LD_ADDR_VAR 0 6
25216: PUSH
25217: LD_VAR 0 6
25221: PPUSH
25222: LD_VAR 0 2
25226: PUSH
25227: LD_VAR 0 2
25231: ARRAY
25232: PPUSH
25233: LD_VAR 0 3
25237: PPUSH
25238: CALL_OW 1
25242: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25243: LD_ADDR_VAR 0 7
25247: PUSH
25248: LD_VAR 0 7
25252: PPUSH
25253: LD_VAR 0 7
25257: PPUSH
25258: LD_VAR 0 6
25262: PPUSH
25263: CALL_OW 1
25267: ST_TO_ADDR
// for i = s_arr downto 2 do
25268: LD_ADDR_VAR 0 5
25272: PUSH
25273: DOUBLE
25274: LD_VAR 0 7
25278: INC
25279: ST_TO_ADDR
25280: LD_INT 2
25282: PUSH
25283: FOR_DOWNTO
25284: IFFALSE 25368
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25286: LD_ADDR_VAR 0 6
25290: PUSH
25291: LD_VAR 0 7
25295: PUSH
25296: LD_VAR 0 5
25300: PUSH
25301: LD_INT 1
25303: MINUS
25304: ARRAY
25305: PPUSH
25306: LD_VAR 0 2
25310: PUSH
25311: LD_VAR 0 5
25315: PUSH
25316: LD_INT 1
25318: MINUS
25319: ARRAY
25320: PPUSH
25321: LD_VAR 0 7
25325: PUSH
25326: LD_VAR 0 5
25330: ARRAY
25331: PPUSH
25332: CALL_OW 1
25336: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25337: LD_ADDR_VAR 0 7
25341: PUSH
25342: LD_VAR 0 7
25346: PPUSH
25347: LD_VAR 0 5
25351: PUSH
25352: LD_INT 1
25354: MINUS
25355: PPUSH
25356: LD_VAR 0 6
25360: PPUSH
25361: CALL_OW 1
25365: ST_TO_ADDR
// end ;
25366: GO 25283
25368: POP
25369: POP
// result := s_arr [ 1 ] ;
25370: LD_ADDR_VAR 0 4
25374: PUSH
25375: LD_VAR 0 7
25379: PUSH
25380: LD_INT 1
25382: ARRAY
25383: ST_TO_ADDR
// end ; end ;
25384: LD_VAR 0 4
25388: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25389: LD_INT 0
25391: PPUSH
25392: PPUSH
// if not list then
25393: LD_VAR 0 1
25397: NOT
25398: IFFALSE 25402
// exit ;
25400: GO 25493
// i := list [ pos1 ] ;
25402: LD_ADDR_VAR 0 5
25406: PUSH
25407: LD_VAR 0 1
25411: PUSH
25412: LD_VAR 0 2
25416: ARRAY
25417: ST_TO_ADDR
// if not i then
25418: LD_VAR 0 5
25422: NOT
25423: IFFALSE 25427
// exit ;
25425: GO 25493
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25427: LD_ADDR_VAR 0 1
25431: PUSH
25432: LD_VAR 0 1
25436: PPUSH
25437: LD_VAR 0 2
25441: PPUSH
25442: LD_VAR 0 1
25446: PUSH
25447: LD_VAR 0 3
25451: ARRAY
25452: PPUSH
25453: CALL_OW 1
25457: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25458: LD_ADDR_VAR 0 1
25462: PUSH
25463: LD_VAR 0 1
25467: PPUSH
25468: LD_VAR 0 3
25472: PPUSH
25473: LD_VAR 0 5
25477: PPUSH
25478: CALL_OW 1
25482: ST_TO_ADDR
// result := list ;
25483: LD_ADDR_VAR 0 4
25487: PUSH
25488: LD_VAR 0 1
25492: ST_TO_ADDR
// end ;
25493: LD_VAR 0 4
25497: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25498: LD_INT 0
25500: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25501: LD_ADDR_VAR 0 5
25505: PUSH
25506: LD_VAR 0 1
25510: PPUSH
25511: CALL_OW 250
25515: PPUSH
25516: LD_VAR 0 1
25520: PPUSH
25521: CALL_OW 251
25525: PPUSH
25526: LD_VAR 0 2
25530: PPUSH
25531: LD_VAR 0 3
25535: PPUSH
25536: LD_VAR 0 4
25540: PPUSH
25541: CALL 25923 0 5
25545: ST_TO_ADDR
// end ;
25546: LD_VAR 0 5
25550: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
25551: LD_INT 0
25553: PPUSH
25554: PPUSH
25555: PPUSH
25556: PPUSH
// if not list or not unit then
25557: LD_VAR 0 2
25561: NOT
25562: IFTRUE 25571
25564: PUSH
25565: LD_VAR 0 1
25569: NOT
25570: OR
25571: IFFALSE 25575
// exit ;
25573: GO 25918
// result := [ ] ;
25575: LD_ADDR_VAR 0 5
25579: PUSH
25580: EMPTY
25581: ST_TO_ADDR
// for i in list do
25582: LD_ADDR_VAR 0 6
25586: PUSH
25587: LD_VAR 0 2
25591: PUSH
25592: FOR_IN
25593: IFFALSE 25811
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
25595: LD_ADDR_VAR 0 8
25599: PUSH
25600: LD_VAR 0 1
25604: PPUSH
25605: LD_VAR 0 6
25609: PUSH
25610: LD_INT 1
25612: ARRAY
25613: PPUSH
25614: LD_VAR 0 6
25618: PUSH
25619: LD_INT 2
25621: ARRAY
25622: PPUSH
25623: CALL_OW 297
25627: ST_TO_ADDR
// if not Count ( result ) then
25628: LD_VAR 0 5
25632: PPUSH
25633: CALL 22179 0 1
25637: NOT
25638: IFFALSE 25671
// begin result := Join ( result , [ i , tmp ] ) ;
25640: LD_ADDR_VAR 0 5
25644: PUSH
25645: LD_VAR 0 5
25649: PPUSH
25650: LD_VAR 0 6
25654: PUSH
25655: LD_VAR 0 8
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PPUSH
25664: CALL 58111 0 2
25668: ST_TO_ADDR
// continue ;
25669: GO 25592
// end ; if result [ result ] [ 2 ] <= tmp then
25671: LD_VAR 0 5
25675: PUSH
25676: LD_VAR 0 5
25680: ARRAY
25681: PUSH
25682: LD_INT 2
25684: ARRAY
25685: PUSH
25686: LD_VAR 0 8
25690: LESSEQUAL
25691: IFFALSE 25724
// result := Join ( result , [ i , tmp ] ) else
25693: LD_ADDR_VAR 0 5
25697: PUSH
25698: LD_VAR 0 5
25702: PPUSH
25703: LD_VAR 0 6
25707: PUSH
25708: LD_VAR 0 8
25712: PUSH
25713: EMPTY
25714: LIST
25715: LIST
25716: PPUSH
25717: CALL 58111 0 2
25721: ST_TO_ADDR
25722: GO 25809
// begin for j := 1 to Count ( result ) do
25724: LD_ADDR_VAR 0 7
25728: PUSH
25729: DOUBLE
25730: LD_INT 1
25732: DEC
25733: ST_TO_ADDR
25734: LD_VAR 0 5
25738: PPUSH
25739: CALL 22179 0 1
25743: PUSH
25744: FOR_TO
25745: IFFALSE 25807
// begin if tmp < result [ j ] [ 2 ] then
25747: LD_VAR 0 8
25751: PUSH
25752: LD_VAR 0 5
25756: PUSH
25757: LD_VAR 0 7
25761: ARRAY
25762: PUSH
25763: LD_INT 2
25765: ARRAY
25766: LESS
25767: IFFALSE 25805
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25769: LD_ADDR_VAR 0 5
25773: PUSH
25774: LD_VAR 0 5
25778: PPUSH
25779: LD_VAR 0 7
25783: PPUSH
25784: LD_VAR 0 6
25788: PUSH
25789: LD_VAR 0 8
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: PPUSH
25798: CALL_OW 2
25802: ST_TO_ADDR
// break ;
25803: GO 25807
// end ; end ;
25805: GO 25744
25807: POP
25808: POP
// end ; end ;
25809: GO 25592
25811: POP
25812: POP
// if result and not asc then
25813: LD_VAR 0 5
25817: IFFALSE 25826
25819: PUSH
25820: LD_VAR 0 3
25824: NOT
25825: AND
25826: IFFALSE 25843
// result := ReverseArray ( result ) ;
25828: LD_ADDR_VAR 0 5
25832: PUSH
25833: LD_VAR 0 5
25837: PPUSH
25838: CALL 53201 0 1
25842: ST_TO_ADDR
// tmp := [ ] ;
25843: LD_ADDR_VAR 0 8
25847: PUSH
25848: EMPTY
25849: ST_TO_ADDR
// if mode then
25850: LD_VAR 0 4
25854: IFFALSE 25918
// begin for i := 1 to result do
25856: LD_ADDR_VAR 0 6
25860: PUSH
25861: DOUBLE
25862: LD_INT 1
25864: DEC
25865: ST_TO_ADDR
25866: LD_VAR 0 5
25870: PUSH
25871: FOR_TO
25872: IFFALSE 25906
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
25874: LD_ADDR_VAR 0 8
25878: PUSH
25879: LD_VAR 0 8
25883: PPUSH
25884: LD_VAR 0 5
25888: PUSH
25889: LD_VAR 0 6
25893: ARRAY
25894: PUSH
25895: LD_INT 1
25897: ARRAY
25898: PPUSH
25899: CALL 58111 0 2
25903: ST_TO_ADDR
25904: GO 25871
25906: POP
25907: POP
// result := tmp ;
25908: LD_ADDR_VAR 0 5
25912: PUSH
25913: LD_VAR 0 8
25917: ST_TO_ADDR
// end ; end ;
25918: LD_VAR 0 5
25922: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25923: LD_INT 0
25925: PPUSH
25926: PPUSH
25927: PPUSH
25928: PPUSH
// if not list then
25929: LD_VAR 0 3
25933: NOT
25934: IFFALSE 25938
// exit ;
25936: GO 26328
// result := [ ] ;
25938: LD_ADDR_VAR 0 6
25942: PUSH
25943: EMPTY
25944: ST_TO_ADDR
// for i in list do
25945: LD_ADDR_VAR 0 7
25949: PUSH
25950: LD_VAR 0 3
25954: PUSH
25955: FOR_IN
25956: IFFALSE 26158
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25958: LD_ADDR_VAR 0 9
25962: PUSH
25963: LD_VAR 0 7
25967: PPUSH
25968: LD_VAR 0 1
25972: PPUSH
25973: LD_VAR 0 2
25977: PPUSH
25978: CALL_OW 297
25982: ST_TO_ADDR
// if not result then
25983: LD_VAR 0 6
25987: NOT
25988: IFFALSE 26014
// result := [ [ i , tmp ] ] else
25990: LD_ADDR_VAR 0 6
25994: PUSH
25995: LD_VAR 0 7
25999: PUSH
26000: LD_VAR 0 9
26004: PUSH
26005: EMPTY
26006: LIST
26007: LIST
26008: PUSH
26009: EMPTY
26010: LIST
26011: ST_TO_ADDR
26012: GO 26156
// begin if result [ result ] [ 2 ] <= tmp then
26014: LD_VAR 0 6
26018: PUSH
26019: LD_VAR 0 6
26023: ARRAY
26024: PUSH
26025: LD_INT 2
26027: ARRAY
26028: PUSH
26029: LD_VAR 0 9
26033: LESSEQUAL
26034: IFFALSE 26076
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
26036: LD_ADDR_VAR 0 6
26040: PUSH
26041: LD_VAR 0 6
26045: PPUSH
26046: LD_VAR 0 6
26050: PUSH
26051: LD_INT 1
26053: PLUS
26054: PPUSH
26055: LD_VAR 0 7
26059: PUSH
26060: LD_VAR 0 9
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PPUSH
26069: CALL_OW 2
26073: ST_TO_ADDR
26074: GO 26156
// for j := 1 to result do
26076: LD_ADDR_VAR 0 8
26080: PUSH
26081: DOUBLE
26082: LD_INT 1
26084: DEC
26085: ST_TO_ADDR
26086: LD_VAR 0 6
26090: PUSH
26091: FOR_TO
26092: IFFALSE 26154
// begin if tmp < result [ j ] [ 2 ] then
26094: LD_VAR 0 9
26098: PUSH
26099: LD_VAR 0 6
26103: PUSH
26104: LD_VAR 0 8
26108: ARRAY
26109: PUSH
26110: LD_INT 2
26112: ARRAY
26113: LESS
26114: IFFALSE 26152
// begin result := Insert ( result , j , [ i , tmp ] ) ;
26116: LD_ADDR_VAR 0 6
26120: PUSH
26121: LD_VAR 0 6
26125: PPUSH
26126: LD_VAR 0 8
26130: PPUSH
26131: LD_VAR 0 7
26135: PUSH
26136: LD_VAR 0 9
26140: PUSH
26141: EMPTY
26142: LIST
26143: LIST
26144: PPUSH
26145: CALL_OW 2
26149: ST_TO_ADDR
// break ;
26150: GO 26154
// end ; end ;
26152: GO 26091
26154: POP
26155: POP
// end ; end ;
26156: GO 25955
26158: POP
26159: POP
// if result and not asc then
26160: LD_VAR 0 6
26164: IFFALSE 26173
26166: PUSH
26167: LD_VAR 0 4
26171: NOT
26172: AND
26173: IFFALSE 26248
// begin tmp := result ;
26175: LD_ADDR_VAR 0 9
26179: PUSH
26180: LD_VAR 0 6
26184: ST_TO_ADDR
// for i = tmp downto 1 do
26185: LD_ADDR_VAR 0 7
26189: PUSH
26190: DOUBLE
26191: LD_VAR 0 9
26195: INC
26196: ST_TO_ADDR
26197: LD_INT 1
26199: PUSH
26200: FOR_DOWNTO
26201: IFFALSE 26246
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
26203: LD_ADDR_VAR 0 6
26207: PUSH
26208: LD_VAR 0 6
26212: PPUSH
26213: LD_VAR 0 9
26217: PUSH
26218: LD_VAR 0 7
26222: MINUS
26223: PUSH
26224: LD_INT 1
26226: PLUS
26227: PPUSH
26228: LD_VAR 0 9
26232: PUSH
26233: LD_VAR 0 7
26237: ARRAY
26238: PPUSH
26239: CALL_OW 1
26243: ST_TO_ADDR
26244: GO 26200
26246: POP
26247: POP
// end ; tmp := [ ] ;
26248: LD_ADDR_VAR 0 9
26252: PUSH
26253: EMPTY
26254: ST_TO_ADDR
// if mode then
26255: LD_VAR 0 5
26259: IFFALSE 26328
// begin for i = 1 to result do
26261: LD_ADDR_VAR 0 7
26265: PUSH
26266: DOUBLE
26267: LD_INT 1
26269: DEC
26270: ST_TO_ADDR
26271: LD_VAR 0 6
26275: PUSH
26276: FOR_TO
26277: IFFALSE 26316
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
26279: LD_ADDR_VAR 0 9
26283: PUSH
26284: LD_VAR 0 9
26288: PPUSH
26289: LD_VAR 0 7
26293: PPUSH
26294: LD_VAR 0 6
26298: PUSH
26299: LD_VAR 0 7
26303: ARRAY
26304: PUSH
26305: LD_INT 1
26307: ARRAY
26308: PPUSH
26309: CALL_OW 1
26313: ST_TO_ADDR
26314: GO 26276
26316: POP
26317: POP
// result := tmp ;
26318: LD_ADDR_VAR 0 6
26322: PUSH
26323: LD_VAR 0 9
26327: ST_TO_ADDR
// end ; end ;
26328: LD_VAR 0 6
26332: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
26333: LD_INT 0
26335: PPUSH
26336: PPUSH
26337: PPUSH
26338: PPUSH
26339: PPUSH
26340: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
26341: LD_ADDR_VAR 0 5
26345: PUSH
26346: LD_INT 0
26348: PUSH
26349: LD_INT 0
26351: PUSH
26352: LD_INT 0
26354: PUSH
26355: EMPTY
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: ST_TO_ADDR
// if not x or not y then
26363: LD_VAR 0 2
26367: NOT
26368: IFTRUE 26377
26370: PUSH
26371: LD_VAR 0 3
26375: NOT
26376: OR
26377: IFFALSE 26381
// exit ;
26379: GO 28037
// if not range then
26381: LD_VAR 0 4
26385: NOT
26386: IFFALSE 26396
// range := 10 ;
26388: LD_ADDR_VAR 0 4
26392: PUSH
26393: LD_INT 10
26395: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
26396: LD_ADDR_VAR 0 8
26400: PUSH
26401: LD_INT 81
26403: PUSH
26404: LD_VAR 0 1
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: PUSH
26413: LD_INT 92
26415: PUSH
26416: LD_VAR 0 2
26420: PUSH
26421: LD_VAR 0 3
26425: PUSH
26426: LD_VAR 0 4
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: LIST
26435: LIST
26436: PUSH
26437: LD_INT 3
26439: PUSH
26440: LD_INT 21
26442: PUSH
26443: LD_INT 3
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: LIST
26458: PPUSH
26459: CALL_OW 69
26463: ST_TO_ADDR
// if not tmp then
26464: LD_VAR 0 8
26468: NOT
26469: IFFALSE 26473
// exit ;
26471: GO 28037
// for i in tmp do
26473: LD_ADDR_VAR 0 6
26477: PUSH
26478: LD_VAR 0 8
26482: PUSH
26483: FOR_IN
26484: IFFALSE 28012
// begin points := [ 0 , 0 , 0 ] ;
26486: LD_ADDR_VAR 0 9
26490: PUSH
26491: LD_INT 0
26493: PUSH
26494: LD_INT 0
26496: PUSH
26497: LD_INT 0
26499: PUSH
26500: EMPTY
26501: LIST
26502: LIST
26503: LIST
26504: ST_TO_ADDR
// bpoints := 1 ;
26505: LD_ADDR_VAR 0 10
26509: PUSH
26510: LD_INT 1
26512: ST_TO_ADDR
// case GetType ( i ) of unit_human :
26513: LD_VAR 0 6
26517: PPUSH
26518: CALL_OW 247
26522: PUSH
26523: LD_INT 1
26525: DOUBLE
26526: EQUAL
26527: IFTRUE 26531
26529: GO 27113
26531: POP
// begin if GetClass ( i ) = 1 then
26532: LD_VAR 0 6
26536: PPUSH
26537: CALL_OW 257
26541: PUSH
26542: LD_INT 1
26544: EQUAL
26545: IFFALSE 26566
// points := [ 10 , 5 , 3 ] ;
26547: LD_ADDR_VAR 0 9
26551: PUSH
26552: LD_INT 10
26554: PUSH
26555: LD_INT 5
26557: PUSH
26558: LD_INT 3
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: LIST
26565: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
26566: LD_VAR 0 6
26570: PPUSH
26571: CALL_OW 257
26575: PUSH
26576: LD_INT 2
26578: PUSH
26579: LD_INT 3
26581: PUSH
26582: LD_INT 4
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: LIST
26589: IN
26590: IFFALSE 26611
// points := [ 3 , 2 , 1 ] ;
26592: LD_ADDR_VAR 0 9
26596: PUSH
26597: LD_INT 3
26599: PUSH
26600: LD_INT 2
26602: PUSH
26603: LD_INT 1
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: LIST
26610: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26611: LD_VAR 0 6
26615: PPUSH
26616: CALL_OW 257
26620: PUSH
26621: LD_INT 5
26623: EQUAL
26624: IFFALSE 26645
// points := [ 130 , 5 , 2 ] ;
26626: LD_ADDR_VAR 0 9
26630: PUSH
26631: LD_INT 130
26633: PUSH
26634: LD_INT 5
26636: PUSH
26637: LD_INT 2
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: LIST
26644: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26645: LD_VAR 0 6
26649: PPUSH
26650: CALL_OW 257
26654: PUSH
26655: LD_INT 8
26657: EQUAL
26658: IFFALSE 26679
// points := [ 35 , 35 , 30 ] ;
26660: LD_ADDR_VAR 0 9
26664: PUSH
26665: LD_INT 35
26667: PUSH
26668: LD_INT 35
26670: PUSH
26671: LD_INT 30
26673: PUSH
26674: EMPTY
26675: LIST
26676: LIST
26677: LIST
26678: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26679: LD_VAR 0 6
26683: PPUSH
26684: CALL_OW 257
26688: PUSH
26689: LD_INT 9
26691: EQUAL
26692: IFFALSE 26713
// points := [ 20 , 55 , 40 ] ;
26694: LD_ADDR_VAR 0 9
26698: PUSH
26699: LD_INT 20
26701: PUSH
26702: LD_INT 55
26704: PUSH
26705: LD_INT 40
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: LIST
26712: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26713: LD_VAR 0 6
26717: PPUSH
26718: CALL_OW 257
26722: PUSH
26723: LD_INT 12
26725: PUSH
26726: LD_INT 16
26728: PUSH
26729: EMPTY
26730: LIST
26731: LIST
26732: IN
26733: IFFALSE 26754
// points := [ 5 , 3 , 2 ] ;
26735: LD_ADDR_VAR 0 9
26739: PUSH
26740: LD_INT 5
26742: PUSH
26743: LD_INT 3
26745: PUSH
26746: LD_INT 2
26748: PUSH
26749: EMPTY
26750: LIST
26751: LIST
26752: LIST
26753: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26754: LD_VAR 0 6
26758: PPUSH
26759: CALL_OW 257
26763: PUSH
26764: LD_INT 17
26766: EQUAL
26767: IFFALSE 26788
// points := [ 100 , 50 , 75 ] ;
26769: LD_ADDR_VAR 0 9
26773: PUSH
26774: LD_INT 100
26776: PUSH
26777: LD_INT 50
26779: PUSH
26780: LD_INT 75
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: LIST
26787: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26788: LD_VAR 0 6
26792: PPUSH
26793: CALL_OW 257
26797: PUSH
26798: LD_INT 15
26800: EQUAL
26801: IFFALSE 26822
// points := [ 10 , 5 , 3 ] ;
26803: LD_ADDR_VAR 0 9
26807: PUSH
26808: LD_INT 10
26810: PUSH
26811: LD_INT 5
26813: PUSH
26814: LD_INT 3
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: LIST
26821: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26822: LD_VAR 0 6
26826: PPUSH
26827: CALL_OW 257
26831: PUSH
26832: LD_INT 14
26834: EQUAL
26835: IFFALSE 26856
// points := [ 10 , 0 , 0 ] ;
26837: LD_ADDR_VAR 0 9
26841: PUSH
26842: LD_INT 10
26844: PUSH
26845: LD_INT 0
26847: PUSH
26848: LD_INT 0
26850: PUSH
26851: EMPTY
26852: LIST
26853: LIST
26854: LIST
26855: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26856: LD_VAR 0 6
26860: PPUSH
26861: CALL_OW 257
26865: PUSH
26866: LD_INT 11
26868: EQUAL
26869: IFFALSE 26890
// points := [ 30 , 10 , 5 ] ;
26871: LD_ADDR_VAR 0 9
26875: PUSH
26876: LD_INT 30
26878: PUSH
26879: LD_INT 10
26881: PUSH
26882: LD_INT 5
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: LIST
26889: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26890: LD_VAR 0 1
26894: PPUSH
26895: LD_INT 5
26897: PPUSH
26898: CALL_OW 321
26902: PUSH
26903: LD_INT 2
26905: EQUAL
26906: IFFALSE 26923
// bpoints := bpoints * 1.8 ;
26908: LD_ADDR_VAR 0 10
26912: PUSH
26913: LD_VAR 0 10
26917: PUSH
26918: LD_REAL  1.80000000000000E+0000
26921: MUL
26922: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26923: LD_VAR 0 6
26927: PPUSH
26928: CALL_OW 257
26932: PUSH
26933: LD_INT 1
26935: PUSH
26936: LD_INT 2
26938: PUSH
26939: LD_INT 3
26941: PUSH
26942: LD_INT 4
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: LIST
26949: LIST
26950: IN
26951: IFFALSE 26971
26953: PUSH
26954: LD_VAR 0 1
26958: PPUSH
26959: LD_INT 51
26961: PPUSH
26962: CALL_OW 321
26966: PUSH
26967: LD_INT 2
26969: EQUAL
26970: AND
26971: IFFALSE 26988
// bpoints := bpoints * 1.2 ;
26973: LD_ADDR_VAR 0 10
26977: PUSH
26978: LD_VAR 0 10
26982: PUSH
26983: LD_REAL  1.20000000000000E+0000
26986: MUL
26987: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26988: LD_VAR 0 6
26992: PPUSH
26993: CALL_OW 257
26997: PUSH
26998: LD_INT 5
27000: PUSH
27001: LD_INT 7
27003: PUSH
27004: LD_INT 9
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: LIST
27011: IN
27012: IFFALSE 27032
27014: PUSH
27015: LD_VAR 0 1
27019: PPUSH
27020: LD_INT 52
27022: PPUSH
27023: CALL_OW 321
27027: PUSH
27028: LD_INT 2
27030: EQUAL
27031: AND
27032: IFFALSE 27049
// bpoints := bpoints * 1.5 ;
27034: LD_ADDR_VAR 0 10
27038: PUSH
27039: LD_VAR 0 10
27043: PUSH
27044: LD_REAL  1.50000000000000E+0000
27047: MUL
27048: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
27049: LD_VAR 0 1
27053: PPUSH
27054: LD_INT 66
27056: PPUSH
27057: CALL_OW 321
27061: PUSH
27062: LD_INT 2
27064: EQUAL
27065: IFFALSE 27082
// bpoints := bpoints * 1.1 ;
27067: LD_ADDR_VAR 0 10
27071: PUSH
27072: LD_VAR 0 10
27076: PUSH
27077: LD_REAL  1.10000000000000E+0000
27080: MUL
27081: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
27082: LD_ADDR_VAR 0 10
27086: PUSH
27087: LD_VAR 0 10
27091: PUSH
27092: LD_VAR 0 6
27096: PPUSH
27097: LD_INT 1
27099: PPUSH
27100: CALL_OW 259
27104: PUSH
27105: LD_REAL  1.15000000000000E+0000
27108: MUL
27109: MUL
27110: ST_TO_ADDR
// end ; unit_vehicle :
27111: GO 27941
27113: LD_INT 2
27115: DOUBLE
27116: EQUAL
27117: IFTRUE 27121
27119: GO 27929
27121: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
27122: LD_VAR 0 6
27126: PPUSH
27127: CALL_OW 264
27131: PUSH
27132: LD_INT 2
27134: PUSH
27135: LD_INT 42
27137: PUSH
27138: LD_INT 24
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: LIST
27145: IN
27146: IFFALSE 27167
// points := [ 25 , 5 , 3 ] ;
27148: LD_ADDR_VAR 0 9
27152: PUSH
27153: LD_INT 25
27155: PUSH
27156: LD_INT 5
27158: PUSH
27159: LD_INT 3
27161: PUSH
27162: EMPTY
27163: LIST
27164: LIST
27165: LIST
27166: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
27167: LD_VAR 0 6
27171: PPUSH
27172: CALL_OW 264
27176: PUSH
27177: LD_INT 4
27179: PUSH
27180: LD_INT 43
27182: PUSH
27183: LD_INT 25
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: LIST
27190: IN
27191: IFFALSE 27212
// points := [ 40 , 15 , 5 ] ;
27193: LD_ADDR_VAR 0 9
27197: PUSH
27198: LD_INT 40
27200: PUSH
27201: LD_INT 15
27203: PUSH
27204: LD_INT 5
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: LIST
27211: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
27212: LD_VAR 0 6
27216: PPUSH
27217: CALL_OW 264
27221: PUSH
27222: LD_INT 3
27224: PUSH
27225: LD_INT 23
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: IN
27232: IFFALSE 27253
// points := [ 7 , 25 , 8 ] ;
27234: LD_ADDR_VAR 0 9
27238: PUSH
27239: LD_INT 7
27241: PUSH
27242: LD_INT 25
27244: PUSH
27245: LD_INT 8
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: LIST
27252: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
27253: LD_VAR 0 6
27257: PPUSH
27258: CALL_OW 264
27262: PUSH
27263: LD_INT 5
27265: PUSH
27266: LD_INT 27
27268: PUSH
27269: LD_INT 44
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: LIST
27276: IN
27277: IFFALSE 27298
// points := [ 14 , 50 , 16 ] ;
27279: LD_ADDR_VAR 0 9
27283: PUSH
27284: LD_INT 14
27286: PUSH
27287: LD_INT 50
27289: PUSH
27290: LD_INT 16
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: LIST
27297: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
27298: LD_VAR 0 6
27302: PPUSH
27303: CALL_OW 264
27307: PUSH
27308: LD_INT 6
27310: PUSH
27311: LD_INT 46
27313: PUSH
27314: EMPTY
27315: LIST
27316: LIST
27317: IN
27318: IFFALSE 27339
// points := [ 32 , 120 , 70 ] ;
27320: LD_ADDR_VAR 0 9
27324: PUSH
27325: LD_INT 32
27327: PUSH
27328: LD_INT 120
27330: PUSH
27331: LD_INT 70
27333: PUSH
27334: EMPTY
27335: LIST
27336: LIST
27337: LIST
27338: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
27339: LD_VAR 0 6
27343: PPUSH
27344: CALL_OW 264
27348: PUSH
27349: LD_INT 7
27351: PUSH
27352: LD_INT 28
27354: PUSH
27355: LD_INT 45
27357: PUSH
27358: LD_INT 92
27360: PUSH
27361: EMPTY
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: IN
27367: IFFALSE 27388
// points := [ 35 , 20 , 45 ] ;
27369: LD_ADDR_VAR 0 9
27373: PUSH
27374: LD_INT 35
27376: PUSH
27377: LD_INT 20
27379: PUSH
27380: LD_INT 45
27382: PUSH
27383: EMPTY
27384: LIST
27385: LIST
27386: LIST
27387: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
27388: LD_VAR 0 6
27392: PPUSH
27393: CALL_OW 264
27397: PUSH
27398: LD_INT 47
27400: PUSH
27401: EMPTY
27402: LIST
27403: IN
27404: IFFALSE 27425
// points := [ 67 , 45 , 75 ] ;
27406: LD_ADDR_VAR 0 9
27410: PUSH
27411: LD_INT 67
27413: PUSH
27414: LD_INT 45
27416: PUSH
27417: LD_INT 75
27419: PUSH
27420: EMPTY
27421: LIST
27422: LIST
27423: LIST
27424: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
27425: LD_VAR 0 6
27429: PPUSH
27430: CALL_OW 264
27434: PUSH
27435: LD_INT 26
27437: PUSH
27438: EMPTY
27439: LIST
27440: IN
27441: IFFALSE 27462
// points := [ 120 , 30 , 80 ] ;
27443: LD_ADDR_VAR 0 9
27447: PUSH
27448: LD_INT 120
27450: PUSH
27451: LD_INT 30
27453: PUSH
27454: LD_INT 80
27456: PUSH
27457: EMPTY
27458: LIST
27459: LIST
27460: LIST
27461: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
27462: LD_VAR 0 6
27466: PPUSH
27467: CALL_OW 264
27471: PUSH
27472: LD_INT 22
27474: PUSH
27475: EMPTY
27476: LIST
27477: IN
27478: IFFALSE 27499
// points := [ 40 , 1 , 1 ] ;
27480: LD_ADDR_VAR 0 9
27484: PUSH
27485: LD_INT 40
27487: PUSH
27488: LD_INT 1
27490: PUSH
27491: LD_INT 1
27493: PUSH
27494: EMPTY
27495: LIST
27496: LIST
27497: LIST
27498: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
27499: LD_VAR 0 6
27503: PPUSH
27504: CALL_OW 264
27508: PUSH
27509: LD_INT 29
27511: PUSH
27512: EMPTY
27513: LIST
27514: IN
27515: IFFALSE 27536
// points := [ 70 , 200 , 400 ] ;
27517: LD_ADDR_VAR 0 9
27521: PUSH
27522: LD_INT 70
27524: PUSH
27525: LD_INT 200
27527: PUSH
27528: LD_INT 400
27530: PUSH
27531: EMPTY
27532: LIST
27533: LIST
27534: LIST
27535: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
27536: LD_VAR 0 6
27540: PPUSH
27541: CALL_OW 264
27545: PUSH
27546: LD_INT 14
27548: PUSH
27549: LD_INT 53
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: IN
27556: IFFALSE 27577
// points := [ 40 , 10 , 20 ] ;
27558: LD_ADDR_VAR 0 9
27562: PUSH
27563: LD_INT 40
27565: PUSH
27566: LD_INT 10
27568: PUSH
27569: LD_INT 20
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: LIST
27576: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
27577: LD_VAR 0 6
27581: PPUSH
27582: CALL_OW 264
27586: PUSH
27587: LD_INT 9
27589: PUSH
27590: EMPTY
27591: LIST
27592: IN
27593: IFFALSE 27614
// points := [ 5 , 70 , 20 ] ;
27595: LD_ADDR_VAR 0 9
27599: PUSH
27600: LD_INT 5
27602: PUSH
27603: LD_INT 70
27605: PUSH
27606: LD_INT 20
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: LIST
27613: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27614: LD_VAR 0 6
27618: PPUSH
27619: CALL_OW 264
27623: PUSH
27624: LD_INT 10
27626: PUSH
27627: EMPTY
27628: LIST
27629: IN
27630: IFFALSE 27651
// points := [ 35 , 110 , 70 ] ;
27632: LD_ADDR_VAR 0 9
27636: PUSH
27637: LD_INT 35
27639: PUSH
27640: LD_INT 110
27642: PUSH
27643: LD_INT 70
27645: PUSH
27646: EMPTY
27647: LIST
27648: LIST
27649: LIST
27650: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27651: LD_VAR 0 6
27655: PPUSH
27656: CALL_OW 265
27660: PUSH
27661: LD_INT 25
27663: EQUAL
27664: IFFALSE 27685
// points := [ 80 , 65 , 100 ] ;
27666: LD_ADDR_VAR 0 9
27670: PUSH
27671: LD_INT 80
27673: PUSH
27674: LD_INT 65
27676: PUSH
27677: LD_INT 100
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: LIST
27684: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27685: LD_VAR 0 6
27689: PPUSH
27690: CALL_OW 263
27694: PUSH
27695: LD_INT 1
27697: EQUAL
27698: IFFALSE 27733
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27700: LD_ADDR_VAR 0 10
27704: PUSH
27705: LD_VAR 0 10
27709: PUSH
27710: LD_VAR 0 6
27714: PPUSH
27715: CALL_OW 311
27719: PPUSH
27720: LD_INT 3
27722: PPUSH
27723: CALL_OW 259
27727: PUSH
27728: LD_INT 4
27730: MUL
27731: MUL
27732: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27733: LD_VAR 0 6
27737: PPUSH
27738: CALL_OW 263
27742: PUSH
27743: LD_INT 2
27745: EQUAL
27746: IFFALSE 27797
// begin j := IsControledBy ( i ) ;
27748: LD_ADDR_VAR 0 7
27752: PUSH
27753: LD_VAR 0 6
27757: PPUSH
27758: CALL_OW 312
27762: ST_TO_ADDR
// if j then
27763: LD_VAR 0 7
27767: IFFALSE 27797
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27769: LD_ADDR_VAR 0 10
27773: PUSH
27774: LD_VAR 0 10
27778: PUSH
27779: LD_VAR 0 7
27783: PPUSH
27784: LD_INT 3
27786: PPUSH
27787: CALL_OW 259
27791: PUSH
27792: LD_INT 3
27794: MUL
27795: MUL
27796: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27797: LD_VAR 0 6
27801: PPUSH
27802: CALL_OW 264
27806: PUSH
27807: LD_INT 5
27809: PUSH
27810: LD_INT 6
27812: PUSH
27813: LD_INT 46
27815: PUSH
27816: LD_INT 44
27818: PUSH
27819: LD_INT 47
27821: PUSH
27822: LD_INT 45
27824: PUSH
27825: LD_INT 28
27827: PUSH
27828: LD_INT 7
27830: PUSH
27831: LD_INT 27
27833: PUSH
27834: LD_INT 29
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: IN
27849: IFFALSE 27869
27851: PUSH
27852: LD_VAR 0 1
27856: PPUSH
27857: LD_INT 52
27859: PPUSH
27860: CALL_OW 321
27864: PUSH
27865: LD_INT 2
27867: EQUAL
27868: AND
27869: IFFALSE 27886
// bpoints := bpoints * 1.2 ;
27871: LD_ADDR_VAR 0 10
27875: PUSH
27876: LD_VAR 0 10
27880: PUSH
27881: LD_REAL  1.20000000000000E+0000
27884: MUL
27885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27886: LD_VAR 0 6
27890: PPUSH
27891: CALL_OW 264
27895: PUSH
27896: LD_INT 6
27898: PUSH
27899: LD_INT 46
27901: PUSH
27902: LD_INT 47
27904: PUSH
27905: EMPTY
27906: LIST
27907: LIST
27908: LIST
27909: IN
27910: IFFALSE 27927
// bpoints := bpoints * 1.2 ;
27912: LD_ADDR_VAR 0 10
27916: PUSH
27917: LD_VAR 0 10
27921: PUSH
27922: LD_REAL  1.20000000000000E+0000
27925: MUL
27926: ST_TO_ADDR
// end ; unit_building :
27927: GO 27941
27929: LD_INT 3
27931: DOUBLE
27932: EQUAL
27933: IFTRUE 27937
27935: GO 27940
27937: POP
// ; end ;
27938: GO 27941
27940: POP
// for j = 1 to 3 do
27941: LD_ADDR_VAR 0 7
27945: PUSH
27946: DOUBLE
27947: LD_INT 1
27949: DEC
27950: ST_TO_ADDR
27951: LD_INT 3
27953: PUSH
27954: FOR_TO
27955: IFFALSE 28008
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27957: LD_ADDR_VAR 0 5
27961: PUSH
27962: LD_VAR 0 5
27966: PPUSH
27967: LD_VAR 0 7
27971: PPUSH
27972: LD_VAR 0 5
27976: PUSH
27977: LD_VAR 0 7
27981: ARRAY
27982: PUSH
27983: LD_VAR 0 9
27987: PUSH
27988: LD_VAR 0 7
27992: ARRAY
27993: PUSH
27994: LD_VAR 0 10
27998: MUL
27999: PLUS
28000: PPUSH
28001: CALL_OW 1
28005: ST_TO_ADDR
28006: GO 27954
28008: POP
28009: POP
// end ;
28010: GO 26483
28012: POP
28013: POP
// result := Replace ( result , 4 , tmp ) ;
28014: LD_ADDR_VAR 0 5
28018: PUSH
28019: LD_VAR 0 5
28023: PPUSH
28024: LD_INT 4
28026: PPUSH
28027: LD_VAR 0 8
28031: PPUSH
28032: CALL_OW 1
28036: ST_TO_ADDR
// end ;
28037: LD_VAR 0 5
28041: RET
// export function DangerAtRange ( unit , range ) ; begin
28042: LD_INT 0
28044: PPUSH
// if not unit then
28045: LD_VAR 0 1
28049: NOT
28050: IFFALSE 28054
// exit ;
28052: GO 28099
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
28054: LD_ADDR_VAR 0 3
28058: PUSH
28059: LD_VAR 0 1
28063: PPUSH
28064: CALL_OW 255
28068: PPUSH
28069: LD_VAR 0 1
28073: PPUSH
28074: CALL_OW 250
28078: PPUSH
28079: LD_VAR 0 1
28083: PPUSH
28084: CALL_OW 251
28088: PPUSH
28089: LD_VAR 0 2
28093: PPUSH
28094: CALL 26333 0 4
28098: ST_TO_ADDR
// end ;
28099: LD_VAR 0 3
28103: RET
// export function DangerInArea ( side , area ) ; begin
28104: LD_INT 0
28106: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
28107: LD_ADDR_VAR 0 3
28111: PUSH
28112: LD_VAR 0 2
28116: PPUSH
28117: LD_INT 81
28119: PUSH
28120: LD_VAR 0 1
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PPUSH
28129: CALL_OW 70
28133: ST_TO_ADDR
// end ;
28134: LD_VAR 0 3
28138: RET
// export function IsExtension ( b ) ; begin
28139: LD_INT 0
28141: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
28142: LD_ADDR_VAR 0 2
28146: PUSH
28147: LD_VAR 0 1
28151: PUSH
28152: LD_INT 23
28154: PUSH
28155: LD_INT 20
28157: PUSH
28158: LD_INT 22
28160: PUSH
28161: LD_INT 17
28163: PUSH
28164: LD_INT 24
28166: PUSH
28167: LD_INT 21
28169: PUSH
28170: LD_INT 19
28172: PUSH
28173: LD_INT 16
28175: PUSH
28176: LD_INT 25
28178: PUSH
28179: LD_INT 18
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: LIST
28186: LIST
28187: LIST
28188: LIST
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: IN
28194: ST_TO_ADDR
// end ;
28195: LD_VAR 0 2
28199: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
28200: LD_INT 0
28202: PPUSH
28203: PPUSH
28204: PPUSH
// result := [ ] ;
28205: LD_ADDR_VAR 0 4
28209: PUSH
28210: EMPTY
28211: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
28212: LD_ADDR_VAR 0 5
28216: PUSH
28217: LD_VAR 0 2
28221: PPUSH
28222: LD_INT 21
28224: PUSH
28225: LD_INT 3
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PPUSH
28232: CALL_OW 70
28236: ST_TO_ADDR
// if not tmp then
28237: LD_VAR 0 5
28241: NOT
28242: IFFALSE 28246
// exit ;
28244: GO 28310
// if checkLink then
28246: LD_VAR 0 3
28250: IFFALSE 28300
// begin for i in tmp do
28252: LD_ADDR_VAR 0 6
28256: PUSH
28257: LD_VAR 0 5
28261: PUSH
28262: FOR_IN
28263: IFFALSE 28298
// if GetBase ( i ) <> base then
28265: LD_VAR 0 6
28269: PPUSH
28270: CALL_OW 274
28274: PUSH
28275: LD_VAR 0 1
28279: NONEQUAL
28280: IFFALSE 28296
// ComLinkToBase ( base , i ) ;
28282: LD_VAR 0 1
28286: PPUSH
28287: LD_VAR 0 6
28291: PPUSH
28292: CALL_OW 169
28296: GO 28262
28298: POP
28299: POP
// end ; result := tmp ;
28300: LD_ADDR_VAR 0 4
28304: PUSH
28305: LD_VAR 0 5
28309: ST_TO_ADDR
// end ;
28310: LD_VAR 0 4
28314: RET
// export function ComComplete ( units , b ) ; var i ; begin
28315: LD_INT 0
28317: PPUSH
28318: PPUSH
// if not units then
28319: LD_VAR 0 1
28323: NOT
28324: IFFALSE 28328
// exit ;
28326: GO 28418
// for i in units do
28328: LD_ADDR_VAR 0 4
28332: PUSH
28333: LD_VAR 0 1
28337: PUSH
28338: FOR_IN
28339: IFFALSE 28416
// if BuildingStatus ( b ) = bs_build then
28341: LD_VAR 0 2
28345: PPUSH
28346: CALL_OW 461
28350: PUSH
28351: LD_INT 1
28353: EQUAL
28354: IFFALSE 28414
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
28356: LD_VAR 0 4
28360: PPUSH
28361: LD_STRING h
28363: PUSH
28364: LD_VAR 0 2
28368: PPUSH
28369: CALL_OW 250
28373: PUSH
28374: LD_VAR 0 2
28378: PPUSH
28379: CALL_OW 251
28383: PUSH
28384: LD_VAR 0 2
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: LD_INT 0
28394: PUSH
28395: LD_INT 0
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: PUSH
28407: EMPTY
28408: LIST
28409: PPUSH
28410: CALL_OW 446
28414: GO 28338
28416: POP
28417: POP
// end ;
28418: LD_VAR 0 3
28422: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
28423: LD_INT 0
28425: PPUSH
28426: PPUSH
28427: PPUSH
28428: PPUSH
28429: PPUSH
28430: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
28431: LD_VAR 0 1
28435: NOT
28436: IFTRUE 28453
28438: PUSH
28439: LD_VAR 0 1
28443: PPUSH
28444: CALL_OW 263
28448: PUSH
28449: LD_INT 2
28451: NONEQUAL
28452: OR
28453: IFFALSE 28457
// exit ;
28455: GO 28773
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
28457: LD_ADDR_VAR 0 6
28461: PUSH
28462: LD_INT 22
28464: PUSH
28465: LD_VAR 0 1
28469: PPUSH
28470: CALL_OW 255
28474: PUSH
28475: EMPTY
28476: LIST
28477: LIST
28478: PUSH
28479: LD_INT 2
28481: PUSH
28482: LD_INT 30
28484: PUSH
28485: LD_INT 36
28487: PUSH
28488: EMPTY
28489: LIST
28490: LIST
28491: PUSH
28492: LD_INT 34
28494: PUSH
28495: LD_INT 31
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: LIST
28506: PUSH
28507: EMPTY
28508: LIST
28509: LIST
28510: PPUSH
28511: CALL_OW 69
28515: ST_TO_ADDR
// if not tmp then
28516: LD_VAR 0 6
28520: NOT
28521: IFFALSE 28525
// exit ;
28523: GO 28773
// result := [ ] ;
28525: LD_ADDR_VAR 0 2
28529: PUSH
28530: EMPTY
28531: ST_TO_ADDR
// for i in tmp do
28532: LD_ADDR_VAR 0 3
28536: PUSH
28537: LD_VAR 0 6
28541: PUSH
28542: FOR_IN
28543: IFFALSE 28614
// begin t := UnitsInside ( i ) ;
28545: LD_ADDR_VAR 0 4
28549: PUSH
28550: LD_VAR 0 3
28554: PPUSH
28555: CALL_OW 313
28559: ST_TO_ADDR
// if t then
28560: LD_VAR 0 4
28564: IFFALSE 28612
// for j in t do
28566: LD_ADDR_VAR 0 7
28570: PUSH
28571: LD_VAR 0 4
28575: PUSH
28576: FOR_IN
28577: IFFALSE 28610
// result := Replace ( result , result + 1 , j ) ;
28579: LD_ADDR_VAR 0 2
28583: PUSH
28584: LD_VAR 0 2
28588: PPUSH
28589: LD_VAR 0 2
28593: PUSH
28594: LD_INT 1
28596: PLUS
28597: PPUSH
28598: LD_VAR 0 7
28602: PPUSH
28603: CALL_OW 1
28607: ST_TO_ADDR
28608: GO 28576
28610: POP
28611: POP
// end ;
28612: GO 28542
28614: POP
28615: POP
// if not result then
28616: LD_VAR 0 2
28620: NOT
28621: IFFALSE 28625
// exit ;
28623: GO 28773
// mech := result [ 1 ] ;
28625: LD_ADDR_VAR 0 5
28629: PUSH
28630: LD_VAR 0 2
28634: PUSH
28635: LD_INT 1
28637: ARRAY
28638: ST_TO_ADDR
// if result > 1 then
28639: LD_VAR 0 2
28643: PUSH
28644: LD_INT 1
28646: GREATER
28647: IFFALSE 28759
// begin for i = 2 to result do
28649: LD_ADDR_VAR 0 3
28653: PUSH
28654: DOUBLE
28655: LD_INT 2
28657: DEC
28658: ST_TO_ADDR
28659: LD_VAR 0 2
28663: PUSH
28664: FOR_TO
28665: IFFALSE 28757
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28667: LD_ADDR_VAR 0 4
28671: PUSH
28672: LD_VAR 0 2
28676: PUSH
28677: LD_VAR 0 3
28681: ARRAY
28682: PPUSH
28683: LD_INT 3
28685: PPUSH
28686: CALL_OW 259
28690: PUSH
28691: LD_VAR 0 2
28695: PUSH
28696: LD_VAR 0 3
28700: ARRAY
28701: PPUSH
28702: CALL_OW 432
28706: MINUS
28707: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28708: LD_VAR 0 4
28712: PUSH
28713: LD_VAR 0 5
28717: PPUSH
28718: LD_INT 3
28720: PPUSH
28721: CALL_OW 259
28725: PUSH
28726: LD_VAR 0 5
28730: PPUSH
28731: CALL_OW 432
28735: MINUS
28736: GREATEREQUAL
28737: IFFALSE 28755
// mech := result [ i ] ;
28739: LD_ADDR_VAR 0 5
28743: PUSH
28744: LD_VAR 0 2
28748: PUSH
28749: LD_VAR 0 3
28753: ARRAY
28754: ST_TO_ADDR
// end ;
28755: GO 28664
28757: POP
28758: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28759: LD_VAR 0 1
28763: PPUSH
28764: LD_VAR 0 5
28768: PPUSH
28769: CALL_OW 135
// end ;
28773: LD_VAR 0 2
28777: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28778: LD_INT 0
28780: PPUSH
28781: PPUSH
28782: PPUSH
28783: PPUSH
28784: PPUSH
28785: PPUSH
28786: PPUSH
28787: PPUSH
28788: PPUSH
28789: PPUSH
28790: PPUSH
28791: PPUSH
28792: PPUSH
// result := [ ] ;
28793: LD_ADDR_VAR 0 7
28797: PUSH
28798: EMPTY
28799: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28800: LD_VAR 0 1
28804: PPUSH
28805: CALL_OW 266
28809: PUSH
28810: LD_INT 0
28812: PUSH
28813: LD_INT 1
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: IN
28820: NOT
28821: IFFALSE 28825
// exit ;
28823: GO 30465
// if name then
28825: LD_VAR 0 3
28829: IFFALSE 28845
// SetBName ( base_dep , name ) ;
28831: LD_VAR 0 1
28835: PPUSH
28836: LD_VAR 0 3
28840: PPUSH
28841: CALL_OW 500
// base := GetBase ( base_dep ) ;
28845: LD_ADDR_VAR 0 15
28849: PUSH
28850: LD_VAR 0 1
28854: PPUSH
28855: CALL_OW 274
28859: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28860: LD_ADDR_VAR 0 16
28864: PUSH
28865: LD_VAR 0 1
28869: PPUSH
28870: CALL_OW 255
28874: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28875: LD_ADDR_VAR 0 17
28879: PUSH
28880: LD_VAR 0 1
28884: PPUSH
28885: CALL_OW 248
28889: ST_TO_ADDR
// if sources then
28890: LD_VAR 0 5
28894: IFFALSE 28941
// for i = 1 to 3 do
28896: LD_ADDR_VAR 0 8
28900: PUSH
28901: DOUBLE
28902: LD_INT 1
28904: DEC
28905: ST_TO_ADDR
28906: LD_INT 3
28908: PUSH
28909: FOR_TO
28910: IFFALSE 28939
// AddResourceType ( base , i , sources [ i ] ) ;
28912: LD_VAR 0 15
28916: PPUSH
28917: LD_VAR 0 8
28921: PPUSH
28922: LD_VAR 0 5
28926: PUSH
28927: LD_VAR 0 8
28931: ARRAY
28932: PPUSH
28933: CALL_OW 276
28937: GO 28909
28939: POP
28940: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28941: LD_ADDR_VAR 0 18
28945: PUSH
28946: LD_VAR 0 15
28950: PPUSH
28951: LD_VAR 0 2
28955: PPUSH
28956: LD_INT 1
28958: PPUSH
28959: CALL 28200 0 3
28963: ST_TO_ADDR
// InitHc ;
28964: CALL_OW 19
// InitUc ;
28968: CALL_OW 18
// uc_side := side ;
28972: LD_ADDR_OWVAR 20
28976: PUSH
28977: LD_VAR 0 16
28981: ST_TO_ADDR
// uc_nation := nation ;
28982: LD_ADDR_OWVAR 21
28986: PUSH
28987: LD_VAR 0 17
28991: ST_TO_ADDR
// if buildings then
28992: LD_VAR 0 18
28996: IFFALSE 30324
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28998: LD_ADDR_VAR 0 19
29002: PUSH
29003: LD_VAR 0 18
29007: PPUSH
29008: LD_INT 2
29010: PUSH
29011: LD_INT 30
29013: PUSH
29014: LD_INT 29
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: PUSH
29021: LD_INT 30
29023: PUSH
29024: LD_INT 30
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: LIST
29035: PPUSH
29036: CALL_OW 72
29040: ST_TO_ADDR
// if tmp then
29041: LD_VAR 0 19
29045: IFFALSE 29093
// for i in tmp do
29047: LD_ADDR_VAR 0 8
29051: PUSH
29052: LD_VAR 0 19
29056: PUSH
29057: FOR_IN
29058: IFFALSE 29091
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
29060: LD_VAR 0 8
29064: PPUSH
29065: CALL_OW 250
29069: PPUSH
29070: LD_VAR 0 8
29074: PPUSH
29075: CALL_OW 251
29079: PPUSH
29080: LD_VAR 0 16
29084: PPUSH
29085: CALL_OW 441
29089: GO 29057
29091: POP
29092: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
29093: LD_VAR 0 18
29097: PPUSH
29098: LD_INT 2
29100: PUSH
29101: LD_INT 30
29103: PUSH
29104: LD_INT 32
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 30
29113: PUSH
29114: LD_INT 33
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: LIST
29125: PPUSH
29126: CALL_OW 72
29130: IFFALSE 29218
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
29132: LD_ADDR_VAR 0 8
29136: PUSH
29137: LD_VAR 0 18
29141: PPUSH
29142: LD_INT 2
29144: PUSH
29145: LD_INT 30
29147: PUSH
29148: LD_INT 32
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PUSH
29155: LD_INT 30
29157: PUSH
29158: LD_INT 33
29160: PUSH
29161: EMPTY
29162: LIST
29163: LIST
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: LIST
29169: PPUSH
29170: CALL_OW 72
29174: PUSH
29175: FOR_IN
29176: IFFALSE 29216
// begin if not GetBWeapon ( i ) then
29178: LD_VAR 0 8
29182: PPUSH
29183: CALL_OW 269
29187: NOT
29188: IFFALSE 29214
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
29190: LD_VAR 0 8
29194: PPUSH
29195: LD_VAR 0 8
29199: PPUSH
29200: LD_VAR 0 2
29204: PPUSH
29205: CALL 30470 0 2
29209: PPUSH
29210: CALL_OW 431
// end ;
29214: GO 29175
29216: POP
29217: POP
// end ; for i = 1 to personel do
29218: LD_ADDR_VAR 0 8
29222: PUSH
29223: DOUBLE
29224: LD_INT 1
29226: DEC
29227: ST_TO_ADDR
29228: LD_VAR 0 6
29232: PUSH
29233: FOR_TO
29234: IFFALSE 30304
// begin if i > 4 then
29236: LD_VAR 0 8
29240: PUSH
29241: LD_INT 4
29243: GREATER
29244: IFFALSE 29248
// break ;
29246: GO 30304
// case i of 1 :
29248: LD_VAR 0 8
29252: PUSH
29253: LD_INT 1
29255: DOUBLE
29256: EQUAL
29257: IFTRUE 29261
29259: GO 29341
29261: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
29262: LD_ADDR_VAR 0 12
29266: PUSH
29267: LD_VAR 0 18
29271: PPUSH
29272: LD_INT 22
29274: PUSH
29275: LD_VAR 0 16
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 58
29286: PUSH
29287: EMPTY
29288: LIST
29289: PUSH
29290: LD_INT 2
29292: PUSH
29293: LD_INT 30
29295: PUSH
29296: LD_INT 32
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 30
29305: PUSH
29306: LD_INT 4
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 30
29315: PUSH
29316: LD_INT 5
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: LIST
29333: PPUSH
29334: CALL_OW 72
29338: ST_TO_ADDR
29339: GO 29563
29341: LD_INT 2
29343: DOUBLE
29344: EQUAL
29345: IFTRUE 29349
29347: GO 29411
29349: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
29350: LD_ADDR_VAR 0 12
29354: PUSH
29355: LD_VAR 0 18
29359: PPUSH
29360: LD_INT 22
29362: PUSH
29363: LD_VAR 0 16
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 2
29374: PUSH
29375: LD_INT 30
29377: PUSH
29378: LD_INT 0
29380: PUSH
29381: EMPTY
29382: LIST
29383: LIST
29384: PUSH
29385: LD_INT 30
29387: PUSH
29388: LD_INT 1
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: EMPTY
29396: LIST
29397: LIST
29398: LIST
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PPUSH
29404: CALL_OW 72
29408: ST_TO_ADDR
29409: GO 29563
29411: LD_INT 3
29413: DOUBLE
29414: EQUAL
29415: IFTRUE 29419
29417: GO 29481
29419: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
29420: LD_ADDR_VAR 0 12
29424: PUSH
29425: LD_VAR 0 18
29429: PPUSH
29430: LD_INT 22
29432: PUSH
29433: LD_VAR 0 16
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 2
29444: PUSH
29445: LD_INT 30
29447: PUSH
29448: LD_INT 2
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: PUSH
29455: LD_INT 30
29457: PUSH
29458: LD_INT 3
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: LIST
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: PPUSH
29474: CALL_OW 72
29478: ST_TO_ADDR
29479: GO 29563
29481: LD_INT 4
29483: DOUBLE
29484: EQUAL
29485: IFTRUE 29489
29487: GO 29562
29489: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
29490: LD_ADDR_VAR 0 12
29494: PUSH
29495: LD_VAR 0 18
29499: PPUSH
29500: LD_INT 22
29502: PUSH
29503: LD_VAR 0 16
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: LD_INT 2
29514: PUSH
29515: LD_INT 30
29517: PUSH
29518: LD_INT 6
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PUSH
29525: LD_INT 30
29527: PUSH
29528: LD_INT 7
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 30
29537: PUSH
29538: LD_INT 8
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: LIST
29549: LIST
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PPUSH
29555: CALL_OW 72
29559: ST_TO_ADDR
29560: GO 29563
29562: POP
// if i = 1 then
29563: LD_VAR 0 8
29567: PUSH
29568: LD_INT 1
29570: EQUAL
29571: IFFALSE 29682
// begin tmp := [ ] ;
29573: LD_ADDR_VAR 0 19
29577: PUSH
29578: EMPTY
29579: ST_TO_ADDR
// for j in f do
29580: LD_ADDR_VAR 0 9
29584: PUSH
29585: LD_VAR 0 12
29589: PUSH
29590: FOR_IN
29591: IFFALSE 29664
// if GetBType ( j ) = b_bunker then
29593: LD_VAR 0 9
29597: PPUSH
29598: CALL_OW 266
29602: PUSH
29603: LD_INT 32
29605: EQUAL
29606: IFFALSE 29633
// tmp := Insert ( tmp , 1 , j ) else
29608: LD_ADDR_VAR 0 19
29612: PUSH
29613: LD_VAR 0 19
29617: PPUSH
29618: LD_INT 1
29620: PPUSH
29621: LD_VAR 0 9
29625: PPUSH
29626: CALL_OW 2
29630: ST_TO_ADDR
29631: GO 29662
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29633: LD_ADDR_VAR 0 19
29637: PUSH
29638: LD_VAR 0 19
29642: PPUSH
29643: LD_VAR 0 19
29647: PUSH
29648: LD_INT 1
29650: PLUS
29651: PPUSH
29652: LD_VAR 0 9
29656: PPUSH
29657: CALL_OW 2
29661: ST_TO_ADDR
29662: GO 29590
29664: POP
29665: POP
// if tmp then
29666: LD_VAR 0 19
29670: IFFALSE 29682
// f := tmp ;
29672: LD_ADDR_VAR 0 12
29676: PUSH
29677: LD_VAR 0 19
29681: ST_TO_ADDR
// end ; x := personel [ i ] ;
29682: LD_ADDR_VAR 0 13
29686: PUSH
29687: LD_VAR 0 6
29691: PUSH
29692: LD_VAR 0 8
29696: ARRAY
29697: ST_TO_ADDR
// if x = - 1 then
29698: LD_VAR 0 13
29702: PUSH
29703: LD_INT 1
29705: NEG
29706: EQUAL
29707: IFFALSE 29918
// begin for j in f do
29709: LD_ADDR_VAR 0 9
29713: PUSH
29714: LD_VAR 0 12
29718: PUSH
29719: FOR_IN
29720: IFFALSE 29914
// repeat InitHc ;
29722: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29726: LD_VAR 0 9
29730: PPUSH
29731: CALL_OW 266
29735: PUSH
29736: LD_INT 5
29738: EQUAL
29739: IFFALSE 29809
// begin if UnitsInside ( j ) < 3 then
29741: LD_VAR 0 9
29745: PPUSH
29746: CALL_OW 313
29750: PUSH
29751: LD_INT 3
29753: LESS
29754: IFFALSE 29790
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29756: LD_INT 0
29758: PPUSH
29759: LD_INT 5
29761: PUSH
29762: LD_INT 8
29764: PUSH
29765: LD_INT 9
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: LIST
29772: PUSH
29773: LD_VAR 0 17
29777: ARRAY
29778: PPUSH
29779: LD_VAR 0 4
29783: PPUSH
29784: CALL_OW 380
29788: GO 29807
// PrepareHuman ( false , i , skill ) ;
29790: LD_INT 0
29792: PPUSH
29793: LD_VAR 0 8
29797: PPUSH
29798: LD_VAR 0 4
29802: PPUSH
29803: CALL_OW 380
// end else
29807: GO 29826
// PrepareHuman ( false , i , skill ) ;
29809: LD_INT 0
29811: PPUSH
29812: LD_VAR 0 8
29816: PPUSH
29817: LD_VAR 0 4
29821: PPUSH
29822: CALL_OW 380
// un := CreateHuman ;
29826: LD_ADDR_VAR 0 14
29830: PUSH
29831: CALL_OW 44
29835: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29836: LD_ADDR_VAR 0 7
29840: PUSH
29841: LD_VAR 0 7
29845: PPUSH
29846: LD_INT 1
29848: PPUSH
29849: LD_VAR 0 14
29853: PPUSH
29854: CALL_OW 2
29858: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29859: LD_VAR 0 14
29863: PPUSH
29864: LD_VAR 0 9
29868: PPUSH
29869: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29873: LD_VAR 0 9
29877: PPUSH
29878: CALL_OW 313
29882: PUSH
29883: LD_INT 6
29885: EQUAL
29886: IFTRUE 29910
29888: PUSH
29889: LD_VAR 0 9
29893: PPUSH
29894: CALL_OW 266
29898: PUSH
29899: LD_INT 32
29901: PUSH
29902: LD_INT 31
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: IN
29909: OR
29910: IFFALSE 29722
29912: GO 29719
29914: POP
29915: POP
// end else
29916: GO 30302
// for j = 1 to x do
29918: LD_ADDR_VAR 0 9
29922: PUSH
29923: DOUBLE
29924: LD_INT 1
29926: DEC
29927: ST_TO_ADDR
29928: LD_VAR 0 13
29932: PUSH
29933: FOR_TO
29934: IFFALSE 30300
// begin InitHc ;
29936: CALL_OW 19
// if not f then
29940: LD_VAR 0 12
29944: NOT
29945: IFFALSE 30034
// begin PrepareHuman ( false , i , skill ) ;
29947: LD_INT 0
29949: PPUSH
29950: LD_VAR 0 8
29954: PPUSH
29955: LD_VAR 0 4
29959: PPUSH
29960: CALL_OW 380
// un := CreateHuman ;
29964: LD_ADDR_VAR 0 14
29968: PUSH
29969: CALL_OW 44
29973: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29974: LD_ADDR_VAR 0 7
29978: PUSH
29979: LD_VAR 0 7
29983: PPUSH
29984: LD_INT 1
29986: PPUSH
29987: LD_VAR 0 14
29991: PPUSH
29992: CALL_OW 2
29996: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29997: LD_VAR 0 14
30001: PPUSH
30002: LD_VAR 0 1
30006: PPUSH
30007: CALL_OW 250
30011: PPUSH
30012: LD_VAR 0 1
30016: PPUSH
30017: CALL_OW 251
30021: PPUSH
30022: LD_INT 10
30024: PPUSH
30025: LD_INT 0
30027: PPUSH
30028: CALL_OW 50
// continue ;
30032: GO 29933
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
30034: LD_VAR 0 12
30038: PUSH
30039: LD_INT 1
30041: ARRAY
30042: PPUSH
30043: CALL_OW 313
30047: IFFALSE 30075
30049: PUSH
30050: LD_VAR 0 12
30054: PUSH
30055: LD_INT 1
30057: ARRAY
30058: PPUSH
30059: CALL_OW 266
30063: PUSH
30064: LD_INT 32
30066: PUSH
30067: LD_INT 31
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: IN
30074: AND
30075: IFTRUE 30096
30077: PUSH
30078: LD_VAR 0 12
30082: PUSH
30083: LD_INT 1
30085: ARRAY
30086: PPUSH
30087: CALL_OW 313
30091: PUSH
30092: LD_INT 6
30094: EQUAL
30095: OR
30096: IFFALSE 30116
// f := Delete ( f , 1 ) ;
30098: LD_ADDR_VAR 0 12
30102: PUSH
30103: LD_VAR 0 12
30107: PPUSH
30108: LD_INT 1
30110: PPUSH
30111: CALL_OW 3
30115: ST_TO_ADDR
// if not f then
30116: LD_VAR 0 12
30120: NOT
30121: IFFALSE 30139
// begin x := x + 2 ;
30123: LD_ADDR_VAR 0 13
30127: PUSH
30128: LD_VAR 0 13
30132: PUSH
30133: LD_INT 2
30135: PLUS
30136: ST_TO_ADDR
// continue ;
30137: GO 29933
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
30139: LD_VAR 0 12
30143: PUSH
30144: LD_INT 1
30146: ARRAY
30147: PPUSH
30148: CALL_OW 266
30152: PUSH
30153: LD_INT 5
30155: EQUAL
30156: IFFALSE 30230
// begin if UnitsInside ( f [ 1 ] ) < 3 then
30158: LD_VAR 0 12
30162: PUSH
30163: LD_INT 1
30165: ARRAY
30166: PPUSH
30167: CALL_OW 313
30171: PUSH
30172: LD_INT 3
30174: LESS
30175: IFFALSE 30211
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
30177: LD_INT 0
30179: PPUSH
30180: LD_INT 5
30182: PUSH
30183: LD_INT 8
30185: PUSH
30186: LD_INT 9
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: LIST
30193: PUSH
30194: LD_VAR 0 17
30198: ARRAY
30199: PPUSH
30200: LD_VAR 0 4
30204: PPUSH
30205: CALL_OW 380
30209: GO 30228
// PrepareHuman ( false , i , skill ) ;
30211: LD_INT 0
30213: PPUSH
30214: LD_VAR 0 8
30218: PPUSH
30219: LD_VAR 0 4
30223: PPUSH
30224: CALL_OW 380
// end else
30228: GO 30247
// PrepareHuman ( false , i , skill ) ;
30230: LD_INT 0
30232: PPUSH
30233: LD_VAR 0 8
30237: PPUSH
30238: LD_VAR 0 4
30242: PPUSH
30243: CALL_OW 380
// un := CreateHuman ;
30247: LD_ADDR_VAR 0 14
30251: PUSH
30252: CALL_OW 44
30256: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
30257: LD_ADDR_VAR 0 7
30261: PUSH
30262: LD_VAR 0 7
30266: PPUSH
30267: LD_INT 1
30269: PPUSH
30270: LD_VAR 0 14
30274: PPUSH
30275: CALL_OW 2
30279: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
30280: LD_VAR 0 14
30284: PPUSH
30285: LD_VAR 0 12
30289: PUSH
30290: LD_INT 1
30292: ARRAY
30293: PPUSH
30294: CALL_OW 52
// end ;
30298: GO 29933
30300: POP
30301: POP
// end ;
30302: GO 29233
30304: POP
30305: POP
// result := result ^ buildings ;
30306: LD_ADDR_VAR 0 7
30310: PUSH
30311: LD_VAR 0 7
30315: PUSH
30316: LD_VAR 0 18
30320: ADD
30321: ST_TO_ADDR
// end else
30322: GO 30465
// begin for i = 1 to personel do
30324: LD_ADDR_VAR 0 8
30328: PUSH
30329: DOUBLE
30330: LD_INT 1
30332: DEC
30333: ST_TO_ADDR
30334: LD_VAR 0 6
30338: PUSH
30339: FOR_TO
30340: IFFALSE 30463
// begin if i > 4 then
30342: LD_VAR 0 8
30346: PUSH
30347: LD_INT 4
30349: GREATER
30350: IFFALSE 30354
// break ;
30352: GO 30463
// x := personel [ i ] ;
30354: LD_ADDR_VAR 0 13
30358: PUSH
30359: LD_VAR 0 6
30363: PUSH
30364: LD_VAR 0 8
30368: ARRAY
30369: ST_TO_ADDR
// if x = - 1 then
30370: LD_VAR 0 13
30374: PUSH
30375: LD_INT 1
30377: NEG
30378: EQUAL
30379: IFFALSE 30383
// continue ;
30381: GO 30339
// PrepareHuman ( false , i , skill ) ;
30383: LD_INT 0
30385: PPUSH
30386: LD_VAR 0 8
30390: PPUSH
30391: LD_VAR 0 4
30395: PPUSH
30396: CALL_OW 380
// un := CreateHuman ;
30400: LD_ADDR_VAR 0 14
30404: PUSH
30405: CALL_OW 44
30409: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
30410: LD_VAR 0 14
30414: PPUSH
30415: LD_VAR 0 1
30419: PPUSH
30420: CALL_OW 250
30424: PPUSH
30425: LD_VAR 0 1
30429: PPUSH
30430: CALL_OW 251
30434: PPUSH
30435: LD_INT 10
30437: PPUSH
30438: LD_INT 0
30440: PPUSH
30441: CALL_OW 50
// result := result ^ un ;
30445: LD_ADDR_VAR 0 7
30449: PUSH
30450: LD_VAR 0 7
30454: PUSH
30455: LD_VAR 0 14
30459: ADD
30460: ST_TO_ADDR
// end ;
30461: GO 30339
30463: POP
30464: POP
// end ; end ;
30465: LD_VAR 0 7
30469: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
30470: LD_INT 0
30472: PPUSH
30473: PPUSH
30474: PPUSH
30475: PPUSH
30476: PPUSH
30477: PPUSH
30478: PPUSH
30479: PPUSH
30480: PPUSH
30481: PPUSH
30482: PPUSH
30483: PPUSH
30484: PPUSH
30485: PPUSH
30486: PPUSH
30487: PPUSH
// result := false ;
30488: LD_ADDR_VAR 0 3
30492: PUSH
30493: LD_INT 0
30495: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
30496: LD_VAR 0 1
30500: NOT
30501: IFTRUE 30526
30503: PUSH
30504: LD_VAR 0 1
30508: PPUSH
30509: CALL_OW 266
30513: PUSH
30514: LD_INT 32
30516: PUSH
30517: LD_INT 33
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: IN
30524: NOT
30525: OR
30526: IFFALSE 30530
// exit ;
30528: GO 31665
// nat := GetNation ( tower ) ;
30530: LD_ADDR_VAR 0 12
30534: PUSH
30535: LD_VAR 0 1
30539: PPUSH
30540: CALL_OW 248
30544: ST_TO_ADDR
// side := GetSide ( tower ) ;
30545: LD_ADDR_VAR 0 16
30549: PUSH
30550: LD_VAR 0 1
30554: PPUSH
30555: CALL_OW 255
30559: ST_TO_ADDR
// x := GetX ( tower ) ;
30560: LD_ADDR_VAR 0 10
30564: PUSH
30565: LD_VAR 0 1
30569: PPUSH
30570: CALL_OW 250
30574: ST_TO_ADDR
// y := GetY ( tower ) ;
30575: LD_ADDR_VAR 0 11
30579: PUSH
30580: LD_VAR 0 1
30584: PPUSH
30585: CALL_OW 251
30589: ST_TO_ADDR
// if not x or not y then
30590: LD_VAR 0 10
30594: NOT
30595: IFTRUE 30604
30597: PUSH
30598: LD_VAR 0 11
30602: NOT
30603: OR
30604: IFFALSE 30608
// exit ;
30606: GO 31665
// weapon := 0 ;
30608: LD_ADDR_VAR 0 18
30612: PUSH
30613: LD_INT 0
30615: ST_TO_ADDR
// fac_list := [ ] ;
30616: LD_ADDR_VAR 0 17
30620: PUSH
30621: EMPTY
30622: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30623: LD_ADDR_VAR 0 6
30627: PUSH
30628: LD_VAR 0 1
30632: PPUSH
30633: CALL_OW 274
30637: PPUSH
30638: LD_VAR 0 2
30642: PPUSH
30643: LD_INT 0
30645: PPUSH
30646: CALL 28200 0 3
30650: PPUSH
30651: LD_INT 30
30653: PUSH
30654: LD_INT 3
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: PPUSH
30661: CALL_OW 72
30665: ST_TO_ADDR
// if not factories then
30666: LD_VAR 0 6
30670: NOT
30671: IFFALSE 30675
// exit ;
30673: GO 31665
// for i in factories do
30675: LD_ADDR_VAR 0 8
30679: PUSH
30680: LD_VAR 0 6
30684: PUSH
30685: FOR_IN
30686: IFFALSE 30711
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30688: LD_ADDR_VAR 0 17
30692: PUSH
30693: LD_VAR 0 17
30697: PUSH
30698: LD_VAR 0 8
30702: PPUSH
30703: CALL_OW 478
30707: UNION
30708: ST_TO_ADDR
30709: GO 30685
30711: POP
30712: POP
// if not fac_list then
30713: LD_VAR 0 17
30717: NOT
30718: IFFALSE 30722
// exit ;
30720: GO 31665
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30722: LD_ADDR_VAR 0 5
30726: PUSH
30727: LD_INT 4
30729: PUSH
30730: LD_INT 5
30732: PUSH
30733: LD_INT 9
30735: PUSH
30736: LD_INT 10
30738: PUSH
30739: LD_INT 6
30741: PUSH
30742: LD_INT 7
30744: PUSH
30745: LD_INT 11
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: LIST
30752: LIST
30753: LIST
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 27
30759: PUSH
30760: LD_INT 28
30762: PUSH
30763: LD_INT 26
30765: PUSH
30766: LD_INT 30
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 43
30777: PUSH
30778: LD_INT 44
30780: PUSH
30781: LD_INT 46
30783: PUSH
30784: LD_INT 45
30786: PUSH
30787: LD_INT 47
30789: PUSH
30790: LD_INT 49
30792: PUSH
30793: EMPTY
30794: LIST
30795: LIST
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: LIST
30805: PUSH
30806: LD_VAR 0 12
30810: ARRAY
30811: ST_TO_ADDR
// list := list isect fac_list ;
30812: LD_ADDR_VAR 0 5
30816: PUSH
30817: LD_VAR 0 5
30821: PUSH
30822: LD_VAR 0 17
30826: ISECT
30827: ST_TO_ADDR
// if not list then
30828: LD_VAR 0 5
30832: NOT
30833: IFFALSE 30837
// exit ;
30835: GO 31665
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30837: LD_VAR 0 12
30841: PUSH
30842: LD_INT 3
30844: EQUAL
30845: IFFALSE 30857
30847: PUSH
30848: LD_INT 49
30850: PUSH
30851: LD_VAR 0 5
30855: IN
30856: AND
30857: IFFALSE 30877
30859: PUSH
30860: LD_INT 31
30862: PPUSH
30863: LD_VAR 0 16
30867: PPUSH
30868: CALL_OW 321
30872: PUSH
30873: LD_INT 2
30875: EQUAL
30876: AND
30877: IFFALSE 30937
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30879: LD_INT 22
30881: PUSH
30882: LD_VAR 0 16
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 35
30893: PUSH
30894: LD_INT 49
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 91
30903: PUSH
30904: LD_VAR 0 1
30908: PUSH
30909: LD_INT 10
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: LIST
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: LIST
30921: PPUSH
30922: CALL_OW 69
30926: NOT
30927: IFFALSE 30937
// weapon := ru_time_lapser ;
30929: LD_ADDR_VAR 0 18
30933: PUSH
30934: LD_INT 49
30936: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30937: LD_VAR 0 12
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: LD_INT 2
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: IN
30952: IFFALSE 30976
30954: PUSH
30955: LD_INT 11
30957: PUSH
30958: LD_VAR 0 5
30962: IN
30963: IFTRUE 30975
30965: PUSH
30966: LD_INT 30
30968: PUSH
30969: LD_VAR 0 5
30973: IN
30974: OR
30975: AND
30976: IFFALSE 30996
30978: PUSH
30979: LD_INT 6
30981: PPUSH
30982: LD_VAR 0 16
30986: PPUSH
30987: CALL_OW 321
30991: PUSH
30992: LD_INT 2
30994: EQUAL
30995: AND
30996: IFFALSE 31163
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30998: LD_INT 22
31000: PUSH
31001: LD_VAR 0 16
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 2
31012: PUSH
31013: LD_INT 35
31015: PUSH
31016: LD_INT 11
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 35
31025: PUSH
31026: LD_INT 30
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: EMPTY
31034: LIST
31035: LIST
31036: LIST
31037: PUSH
31038: LD_INT 91
31040: PUSH
31041: LD_VAR 0 1
31045: PUSH
31046: LD_INT 18
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: LIST
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: LIST
31058: PPUSH
31059: CALL_OW 69
31063: NOT
31064: IFFALSE 31140
31066: PUSH
31067: LD_INT 22
31069: PUSH
31070: LD_VAR 0 16
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 2
31081: PUSH
31082: LD_INT 30
31084: PUSH
31085: LD_INT 32
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 30
31094: PUSH
31095: LD_INT 33
31097: PUSH
31098: EMPTY
31099: LIST
31100: LIST
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 91
31109: PUSH
31110: LD_VAR 0 1
31114: PUSH
31115: LD_INT 12
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: LIST
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: LIST
31127: PUSH
31128: EMPTY
31129: LIST
31130: PPUSH
31131: CALL_OW 69
31135: PUSH
31136: LD_INT 2
31138: GREATER
31139: AND
31140: IFFALSE 31163
// weapon := [ us_radar , ar_radar ] [ nat ] ;
31142: LD_ADDR_VAR 0 18
31146: PUSH
31147: LD_INT 11
31149: PUSH
31150: LD_INT 30
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: LD_VAR 0 12
31161: ARRAY
31162: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
31163: LD_VAR 0 18
31167: NOT
31168: IFFALSE 31188
31170: PUSH
31171: LD_INT 40
31173: PPUSH
31174: LD_VAR 0 16
31178: PPUSH
31179: CALL_OW 321
31183: PUSH
31184: LD_INT 2
31186: EQUAL
31187: AND
31188: IFFALSE 31224
31190: PUSH
31191: LD_INT 7
31193: PUSH
31194: LD_VAR 0 5
31198: IN
31199: IFTRUE 31211
31201: PUSH
31202: LD_INT 28
31204: PUSH
31205: LD_VAR 0 5
31209: IN
31210: OR
31211: IFTRUE 31223
31213: PUSH
31214: LD_INT 45
31216: PUSH
31217: LD_VAR 0 5
31221: IN
31222: OR
31223: AND
31224: IFFALSE 31478
// begin hex := GetHexInfo ( x , y ) ;
31226: LD_ADDR_VAR 0 4
31230: PUSH
31231: LD_VAR 0 10
31235: PPUSH
31236: LD_VAR 0 11
31240: PPUSH
31241: CALL_OW 546
31245: ST_TO_ADDR
// if hex [ 1 ] then
31246: LD_VAR 0 4
31250: PUSH
31251: LD_INT 1
31253: ARRAY
31254: IFFALSE 31258
// exit ;
31256: GO 31665
// height := hex [ 2 ] ;
31258: LD_ADDR_VAR 0 15
31262: PUSH
31263: LD_VAR 0 4
31267: PUSH
31268: LD_INT 2
31270: ARRAY
31271: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
31272: LD_ADDR_VAR 0 14
31276: PUSH
31277: LD_INT 0
31279: PUSH
31280: LD_INT 2
31282: PUSH
31283: LD_INT 3
31285: PUSH
31286: LD_INT 5
31288: PUSH
31289: EMPTY
31290: LIST
31291: LIST
31292: LIST
31293: LIST
31294: ST_TO_ADDR
// for i in tmp do
31295: LD_ADDR_VAR 0 8
31299: PUSH
31300: LD_VAR 0 14
31304: PUSH
31305: FOR_IN
31306: IFFALSE 31476
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
31308: LD_ADDR_VAR 0 9
31312: PUSH
31313: LD_VAR 0 10
31317: PPUSH
31318: LD_VAR 0 8
31322: PPUSH
31323: LD_INT 5
31325: PPUSH
31326: CALL_OW 272
31330: PUSH
31331: LD_VAR 0 11
31335: PPUSH
31336: LD_VAR 0 8
31340: PPUSH
31341: LD_INT 5
31343: PPUSH
31344: CALL_OW 273
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
31353: LD_VAR 0 9
31357: PUSH
31358: LD_INT 1
31360: ARRAY
31361: PPUSH
31362: LD_VAR 0 9
31366: PUSH
31367: LD_INT 2
31369: ARRAY
31370: PPUSH
31371: CALL_OW 488
31375: IFFALSE 31474
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
31377: LD_ADDR_VAR 0 4
31381: PUSH
31382: LD_VAR 0 9
31386: PUSH
31387: LD_INT 1
31389: ARRAY
31390: PPUSH
31391: LD_VAR 0 9
31395: PUSH
31396: LD_INT 2
31398: ARRAY
31399: PPUSH
31400: CALL_OW 546
31404: ST_TO_ADDR
// if hex [ 1 ] then
31405: LD_VAR 0 4
31409: PUSH
31410: LD_INT 1
31412: ARRAY
31413: IFFALSE 31417
// continue ;
31415: GO 31305
// h := hex [ 2 ] ;
31417: LD_ADDR_VAR 0 13
31421: PUSH
31422: LD_VAR 0 4
31426: PUSH
31427: LD_INT 2
31429: ARRAY
31430: ST_TO_ADDR
// if h + 7 < height then
31431: LD_VAR 0 13
31435: PUSH
31436: LD_INT 7
31438: PLUS
31439: PUSH
31440: LD_VAR 0 15
31444: LESS
31445: IFFALSE 31474
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
31447: LD_ADDR_VAR 0 18
31451: PUSH
31452: LD_INT 7
31454: PUSH
31455: LD_INT 28
31457: PUSH
31458: LD_INT 45
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: LIST
31465: PUSH
31466: LD_VAR 0 12
31470: ARRAY
31471: ST_TO_ADDR
// break ;
31472: GO 31476
// end ; end ; end ;
31474: GO 31305
31476: POP
31477: POP
// end ; if not weapon then
31478: LD_VAR 0 18
31482: NOT
31483: IFFALSE 31543
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
31485: LD_ADDR_VAR 0 5
31489: PUSH
31490: LD_VAR 0 5
31494: PUSH
31495: LD_INT 11
31497: PUSH
31498: LD_INT 30
31500: PUSH
31501: LD_INT 49
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: LIST
31508: DIFF
31509: ST_TO_ADDR
// if not list then
31510: LD_VAR 0 5
31514: NOT
31515: IFFALSE 31519
// exit ;
31517: GO 31665
// weapon := list [ rand ( 1 , list ) ] ;
31519: LD_ADDR_VAR 0 18
31523: PUSH
31524: LD_VAR 0 5
31528: PUSH
31529: LD_INT 1
31531: PPUSH
31532: LD_VAR 0 5
31536: PPUSH
31537: CALL_OW 12
31541: ARRAY
31542: ST_TO_ADDR
// end ; if weapon then
31543: LD_VAR 0 18
31547: IFFALSE 31665
// begin tmp := CostOfWeapon ( weapon ) ;
31549: LD_ADDR_VAR 0 14
31553: PUSH
31554: LD_VAR 0 18
31558: PPUSH
31559: CALL_OW 451
31563: ST_TO_ADDR
// j := GetBase ( tower ) ;
31564: LD_ADDR_VAR 0 9
31568: PUSH
31569: LD_VAR 0 1
31573: PPUSH
31574: CALL_OW 274
31578: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
31579: LD_VAR 0 9
31583: PPUSH
31584: LD_INT 1
31586: PPUSH
31587: CALL_OW 275
31591: PUSH
31592: LD_VAR 0 14
31596: PUSH
31597: LD_INT 1
31599: ARRAY
31600: GREATEREQUAL
31601: IFFALSE 31627
31603: PUSH
31604: LD_VAR 0 9
31608: PPUSH
31609: LD_INT 2
31611: PPUSH
31612: CALL_OW 275
31616: PUSH
31617: LD_VAR 0 14
31621: PUSH
31622: LD_INT 2
31624: ARRAY
31625: GREATEREQUAL
31626: AND
31627: IFFALSE 31653
31629: PUSH
31630: LD_VAR 0 9
31634: PPUSH
31635: LD_INT 3
31637: PPUSH
31638: CALL_OW 275
31642: PUSH
31643: LD_VAR 0 14
31647: PUSH
31648: LD_INT 3
31650: ARRAY
31651: GREATEREQUAL
31652: AND
31653: IFFALSE 31665
// result := weapon ;
31655: LD_ADDR_VAR 0 3
31659: PUSH
31660: LD_VAR 0 18
31664: ST_TO_ADDR
// end ; end ;
31665: LD_VAR 0 3
31669: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31670: LD_INT 0
31672: PPUSH
31673: PPUSH
// result := true ;
31674: LD_ADDR_VAR 0 3
31678: PUSH
31679: LD_INT 1
31681: ST_TO_ADDR
// if array1 = array2 then
31682: LD_VAR 0 1
31686: PUSH
31687: LD_VAR 0 2
31691: EQUAL
31692: IFFALSE 31752
// begin for i = 1 to array1 do
31694: LD_ADDR_VAR 0 4
31698: PUSH
31699: DOUBLE
31700: LD_INT 1
31702: DEC
31703: ST_TO_ADDR
31704: LD_VAR 0 1
31708: PUSH
31709: FOR_TO
31710: IFFALSE 31748
// if array1 [ i ] <> array2 [ i ] then
31712: LD_VAR 0 1
31716: PUSH
31717: LD_VAR 0 4
31721: ARRAY
31722: PUSH
31723: LD_VAR 0 2
31727: PUSH
31728: LD_VAR 0 4
31732: ARRAY
31733: NONEQUAL
31734: IFFALSE 31746
// begin result := false ;
31736: LD_ADDR_VAR 0 3
31740: PUSH
31741: LD_INT 0
31743: ST_TO_ADDR
// break ;
31744: GO 31748
// end ;
31746: GO 31709
31748: POP
31749: POP
// end else
31750: GO 31760
// result := false ;
31752: LD_ADDR_VAR 0 3
31756: PUSH
31757: LD_INT 0
31759: ST_TO_ADDR
// end ;
31760: LD_VAR 0 3
31764: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31765: LD_INT 0
31767: PPUSH
31768: PPUSH
// if not array1 or not array2 then
31769: LD_VAR 0 1
31773: NOT
31774: IFTRUE 31783
31776: PUSH
31777: LD_VAR 0 2
31781: NOT
31782: OR
31783: IFFALSE 31787
// exit ;
31785: GO 31851
// result := true ;
31787: LD_ADDR_VAR 0 3
31791: PUSH
31792: LD_INT 1
31794: ST_TO_ADDR
// for i = 1 to array1 do
31795: LD_ADDR_VAR 0 4
31799: PUSH
31800: DOUBLE
31801: LD_INT 1
31803: DEC
31804: ST_TO_ADDR
31805: LD_VAR 0 1
31809: PUSH
31810: FOR_TO
31811: IFFALSE 31849
// if array1 [ i ] <> array2 [ i ] then
31813: LD_VAR 0 1
31817: PUSH
31818: LD_VAR 0 4
31822: ARRAY
31823: PUSH
31824: LD_VAR 0 2
31828: PUSH
31829: LD_VAR 0 4
31833: ARRAY
31834: NONEQUAL
31835: IFFALSE 31847
// begin result := false ;
31837: LD_ADDR_VAR 0 3
31841: PUSH
31842: LD_INT 0
31844: ST_TO_ADDR
// break ;
31845: GO 31849
// end ;
31847: GO 31810
31849: POP
31850: POP
// end ;
31851: LD_VAR 0 3
31855: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31856: LD_INT 0
31858: PPUSH
31859: PPUSH
31860: PPUSH
// pom := GetBase ( fac ) ;
31861: LD_ADDR_VAR 0 5
31865: PUSH
31866: LD_VAR 0 1
31870: PPUSH
31871: CALL_OW 274
31875: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31876: LD_ADDR_VAR 0 4
31880: PUSH
31881: LD_VAR 0 2
31885: PUSH
31886: LD_INT 1
31888: ARRAY
31889: PPUSH
31890: LD_VAR 0 2
31894: PUSH
31895: LD_INT 2
31897: ARRAY
31898: PPUSH
31899: LD_VAR 0 2
31903: PUSH
31904: LD_INT 3
31906: ARRAY
31907: PPUSH
31908: LD_VAR 0 2
31912: PUSH
31913: LD_INT 4
31915: ARRAY
31916: PPUSH
31917: CALL_OW 449
31921: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31922: LD_ADDR_VAR 0 3
31926: PUSH
31927: LD_VAR 0 5
31931: PPUSH
31932: LD_INT 1
31934: PPUSH
31935: CALL_OW 275
31939: PUSH
31940: LD_VAR 0 4
31944: PUSH
31945: LD_INT 1
31947: ARRAY
31948: GREATEREQUAL
31949: IFFALSE 31975
31951: PUSH
31952: LD_VAR 0 5
31956: PPUSH
31957: LD_INT 2
31959: PPUSH
31960: CALL_OW 275
31964: PUSH
31965: LD_VAR 0 4
31969: PUSH
31970: LD_INT 2
31972: ARRAY
31973: GREATEREQUAL
31974: AND
31975: IFFALSE 32001
31977: PUSH
31978: LD_VAR 0 5
31982: PPUSH
31983: LD_INT 3
31985: PPUSH
31986: CALL_OW 275
31990: PUSH
31991: LD_VAR 0 4
31995: PUSH
31996: LD_INT 3
31998: ARRAY
31999: GREATEREQUAL
32000: AND
32001: ST_TO_ADDR
// end ;
32002: LD_VAR 0 3
32006: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
32007: LD_INT 0
32009: PPUSH
32010: PPUSH
32011: PPUSH
32012: PPUSH
// pom := GetBase ( building ) ;
32013: LD_ADDR_VAR 0 3
32017: PUSH
32018: LD_VAR 0 1
32022: PPUSH
32023: CALL_OW 274
32027: ST_TO_ADDR
// if not pom then
32028: LD_VAR 0 3
32032: NOT
32033: IFFALSE 32037
// exit ;
32035: GO 32211
// btype := GetBType ( building ) ;
32037: LD_ADDR_VAR 0 5
32041: PUSH
32042: LD_VAR 0 1
32046: PPUSH
32047: CALL_OW 266
32051: ST_TO_ADDR
// if btype = b_armoury then
32052: LD_VAR 0 5
32056: PUSH
32057: LD_INT 4
32059: EQUAL
32060: IFFALSE 32070
// btype := b_barracks ;
32062: LD_ADDR_VAR 0 5
32066: PUSH
32067: LD_INT 5
32069: ST_TO_ADDR
// if btype = b_depot then
32070: LD_VAR 0 5
32074: PUSH
32075: LD_INT 0
32077: EQUAL
32078: IFFALSE 32088
// btype := b_warehouse ;
32080: LD_ADDR_VAR 0 5
32084: PUSH
32085: LD_INT 1
32087: ST_TO_ADDR
// if btype = b_workshop then
32088: LD_VAR 0 5
32092: PUSH
32093: LD_INT 2
32095: EQUAL
32096: IFFALSE 32106
// btype := b_factory ;
32098: LD_ADDR_VAR 0 5
32102: PUSH
32103: LD_INT 3
32105: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
32106: LD_ADDR_VAR 0 4
32110: PUSH
32111: LD_VAR 0 5
32115: PPUSH
32116: LD_VAR 0 1
32120: PPUSH
32121: CALL_OW 248
32125: PPUSH
32126: CALL_OW 450
32130: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
32131: LD_ADDR_VAR 0 2
32135: PUSH
32136: LD_VAR 0 3
32140: PPUSH
32141: LD_INT 1
32143: PPUSH
32144: CALL_OW 275
32148: PUSH
32149: LD_VAR 0 4
32153: PUSH
32154: LD_INT 1
32156: ARRAY
32157: GREATEREQUAL
32158: IFFALSE 32184
32160: PUSH
32161: LD_VAR 0 3
32165: PPUSH
32166: LD_INT 2
32168: PPUSH
32169: CALL_OW 275
32173: PUSH
32174: LD_VAR 0 4
32178: PUSH
32179: LD_INT 2
32181: ARRAY
32182: GREATEREQUAL
32183: AND
32184: IFFALSE 32210
32186: PUSH
32187: LD_VAR 0 3
32191: PPUSH
32192: LD_INT 3
32194: PPUSH
32195: CALL_OW 275
32199: PUSH
32200: LD_VAR 0 4
32204: PUSH
32205: LD_INT 3
32207: ARRAY
32208: GREATEREQUAL
32209: AND
32210: ST_TO_ADDR
// end ;
32211: LD_VAR 0 2
32215: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
32216: LD_INT 0
32218: PPUSH
32219: PPUSH
32220: PPUSH
// pom := GetBase ( building ) ;
32221: LD_ADDR_VAR 0 4
32225: PUSH
32226: LD_VAR 0 1
32230: PPUSH
32231: CALL_OW 274
32235: ST_TO_ADDR
// if not pom then
32236: LD_VAR 0 4
32240: NOT
32241: IFFALSE 32245
// exit ;
32243: GO 32350
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
32245: LD_ADDR_VAR 0 5
32249: PUSH
32250: LD_VAR 0 2
32254: PPUSH
32255: LD_VAR 0 1
32259: PPUSH
32260: CALL_OW 248
32264: PPUSH
32265: CALL_OW 450
32269: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
32270: LD_ADDR_VAR 0 3
32274: PUSH
32275: LD_VAR 0 4
32279: PPUSH
32280: LD_INT 1
32282: PPUSH
32283: CALL_OW 275
32287: PUSH
32288: LD_VAR 0 5
32292: PUSH
32293: LD_INT 1
32295: ARRAY
32296: GREATEREQUAL
32297: IFFALSE 32323
32299: PUSH
32300: LD_VAR 0 4
32304: PPUSH
32305: LD_INT 2
32307: PPUSH
32308: CALL_OW 275
32312: PUSH
32313: LD_VAR 0 5
32317: PUSH
32318: LD_INT 2
32320: ARRAY
32321: GREATEREQUAL
32322: AND
32323: IFFALSE 32349
32325: PUSH
32326: LD_VAR 0 4
32330: PPUSH
32331: LD_INT 3
32333: PPUSH
32334: CALL_OW 275
32338: PUSH
32339: LD_VAR 0 5
32343: PUSH
32344: LD_INT 3
32346: ARRAY
32347: GREATEREQUAL
32348: AND
32349: ST_TO_ADDR
// end ;
32350: LD_VAR 0 3
32354: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
32355: LD_INT 0
32357: PPUSH
32358: PPUSH
32359: PPUSH
32360: PPUSH
32361: PPUSH
32362: PPUSH
32363: PPUSH
32364: PPUSH
32365: PPUSH
32366: PPUSH
32367: PPUSH
// result := false ;
32368: LD_ADDR_VAR 0 8
32372: PUSH
32373: LD_INT 0
32375: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
32376: LD_VAR 0 5
32380: NOT
32381: IFTRUE 32390
32383: PUSH
32384: LD_VAR 0 1
32388: NOT
32389: OR
32390: IFTRUE 32399
32392: PUSH
32393: LD_VAR 0 2
32397: NOT
32398: OR
32399: IFTRUE 32408
32401: PUSH
32402: LD_VAR 0 3
32406: NOT
32407: OR
32408: IFFALSE 32412
// exit ;
32410: GO 33238
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
32412: LD_ADDR_VAR 0 14
32416: PUSH
32417: LD_VAR 0 1
32421: PPUSH
32422: LD_VAR 0 2
32426: PPUSH
32427: LD_VAR 0 3
32431: PPUSH
32432: LD_VAR 0 4
32436: PPUSH
32437: LD_VAR 0 5
32441: PUSH
32442: LD_INT 1
32444: ARRAY
32445: PPUSH
32446: CALL_OW 248
32450: PPUSH
32451: LD_INT 0
32453: PPUSH
32454: CALL 34519 0 6
32458: ST_TO_ADDR
// if not hexes then
32459: LD_VAR 0 14
32463: NOT
32464: IFFALSE 32468
// exit ;
32466: GO 33238
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
32468: LD_ADDR_VAR 0 17
32472: PUSH
32473: LD_VAR 0 5
32477: PPUSH
32478: LD_INT 22
32480: PUSH
32481: LD_VAR 0 13
32485: PPUSH
32486: CALL_OW 255
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 2
32497: PUSH
32498: LD_INT 30
32500: PUSH
32501: LD_INT 0
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 30
32510: PUSH
32511: LD_INT 1
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: LIST
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PPUSH
32527: CALL_OW 72
32531: ST_TO_ADDR
// for i = 1 to hexes do
32532: LD_ADDR_VAR 0 9
32536: PUSH
32537: DOUBLE
32538: LD_INT 1
32540: DEC
32541: ST_TO_ADDR
32542: LD_VAR 0 14
32546: PUSH
32547: FOR_TO
32548: IFFALSE 33236
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32550: LD_ADDR_VAR 0 13
32554: PUSH
32555: LD_VAR 0 14
32559: PUSH
32560: LD_VAR 0 9
32564: ARRAY
32565: PUSH
32566: LD_INT 1
32568: ARRAY
32569: PPUSH
32570: LD_VAR 0 14
32574: PUSH
32575: LD_VAR 0 9
32579: ARRAY
32580: PUSH
32581: LD_INT 2
32583: ARRAY
32584: PPUSH
32585: CALL_OW 428
32589: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
32590: LD_VAR 0 14
32594: PUSH
32595: LD_VAR 0 9
32599: ARRAY
32600: PUSH
32601: LD_INT 1
32603: ARRAY
32604: PPUSH
32605: LD_VAR 0 14
32609: PUSH
32610: LD_VAR 0 9
32614: ARRAY
32615: PUSH
32616: LD_INT 2
32618: ARRAY
32619: PPUSH
32620: CALL_OW 351
32624: IFTRUE 32663
32626: PUSH
32627: LD_VAR 0 14
32631: PUSH
32632: LD_VAR 0 9
32636: ARRAY
32637: PUSH
32638: LD_INT 1
32640: ARRAY
32641: PPUSH
32642: LD_VAR 0 14
32646: PUSH
32647: LD_VAR 0 9
32651: ARRAY
32652: PUSH
32653: LD_INT 2
32655: ARRAY
32656: PPUSH
32657: CALL_OW 488
32661: NOT
32662: OR
32663: IFTRUE 32680
32665: PUSH
32666: LD_VAR 0 13
32670: PPUSH
32671: CALL_OW 247
32675: PUSH
32676: LD_INT 3
32678: EQUAL
32679: OR
32680: IFFALSE 32686
// exit ;
32682: POP
32683: POP
32684: GO 33238
// if not tmp then
32686: LD_VAR 0 13
32690: NOT
32691: IFFALSE 32695
// continue ;
32693: GO 32547
// result := true ;
32695: LD_ADDR_VAR 0 8
32699: PUSH
32700: LD_INT 1
32702: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32703: LD_VAR 0 6
32707: IFFALSE 32724
32709: PUSH
32710: LD_VAR 0 13
32714: PPUSH
32715: CALL_OW 247
32719: PUSH
32720: LD_INT 2
32722: EQUAL
32723: AND
32724: IFFALSE 32741
32726: PUSH
32727: LD_VAR 0 13
32731: PPUSH
32732: CALL_OW 263
32736: PUSH
32737: LD_INT 1
32739: EQUAL
32740: AND
32741: IFFALSE 32905
// begin if IsDrivenBy ( tmp ) then
32743: LD_VAR 0 13
32747: PPUSH
32748: CALL_OW 311
32752: IFFALSE 32756
// continue ;
32754: GO 32547
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32756: LD_VAR 0 6
32760: PPUSH
32761: LD_INT 3
32763: PUSH
32764: LD_INT 60
32766: PUSH
32767: EMPTY
32768: LIST
32769: PUSH
32770: EMPTY
32771: LIST
32772: LIST
32773: PUSH
32774: LD_INT 3
32776: PUSH
32777: LD_INT 55
32779: PUSH
32780: EMPTY
32781: LIST
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PPUSH
32791: CALL_OW 72
32795: IFFALSE 32903
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32797: LD_ADDR_VAR 0 18
32801: PUSH
32802: LD_VAR 0 6
32806: PPUSH
32807: LD_INT 3
32809: PUSH
32810: LD_INT 60
32812: PUSH
32813: EMPTY
32814: LIST
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: LD_INT 3
32822: PUSH
32823: LD_INT 55
32825: PUSH
32826: EMPTY
32827: LIST
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PPUSH
32837: CALL_OW 72
32841: PUSH
32842: LD_INT 1
32844: ARRAY
32845: ST_TO_ADDR
// if IsInUnit ( driver ) then
32846: LD_VAR 0 18
32850: PPUSH
32851: CALL_OW 310
32855: IFFALSE 32866
// ComExit ( driver ) ;
32857: LD_VAR 0 18
32861: PPUSH
32862: CALL 58509 0 1
// AddComEnterUnit ( driver , tmp ) ;
32866: LD_VAR 0 18
32870: PPUSH
32871: LD_VAR 0 13
32875: PPUSH
32876: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32880: LD_VAR 0 18
32884: PPUSH
32885: LD_VAR 0 7
32889: PPUSH
32890: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32894: LD_VAR 0 18
32898: PPUSH
32899: CALL_OW 181
// end ; continue ;
32903: GO 32547
// end ; if not cleaners or not tmp in cleaners then
32905: LD_VAR 0 6
32909: NOT
32910: IFTRUE 32925
32912: PUSH
32913: LD_VAR 0 13
32917: PUSH
32918: LD_VAR 0 6
32922: IN
32923: NOT
32924: OR
32925: IFFALSE 33234
// begin if dep then
32927: LD_VAR 0 17
32931: IFFALSE 33067
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32933: LD_ADDR_VAR 0 16
32937: PUSH
32938: LD_VAR 0 17
32942: PUSH
32943: LD_INT 1
32945: ARRAY
32946: PPUSH
32947: CALL_OW 250
32951: PPUSH
32952: LD_VAR 0 17
32956: PUSH
32957: LD_INT 1
32959: ARRAY
32960: PPUSH
32961: CALL_OW 254
32965: PPUSH
32966: LD_INT 5
32968: PPUSH
32969: CALL_OW 272
32973: PUSH
32974: LD_VAR 0 17
32978: PUSH
32979: LD_INT 1
32981: ARRAY
32982: PPUSH
32983: CALL_OW 251
32987: PPUSH
32988: LD_VAR 0 17
32992: PUSH
32993: LD_INT 1
32995: ARRAY
32996: PPUSH
32997: CALL_OW 254
33001: PPUSH
33002: LD_INT 5
33004: PPUSH
33005: CALL_OW 273
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
33014: LD_VAR 0 16
33018: PUSH
33019: LD_INT 1
33021: ARRAY
33022: PPUSH
33023: LD_VAR 0 16
33027: PUSH
33028: LD_INT 2
33030: ARRAY
33031: PPUSH
33032: CALL_OW 488
33036: IFFALSE 33067
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
33038: LD_VAR 0 13
33042: PPUSH
33043: LD_VAR 0 16
33047: PUSH
33048: LD_INT 1
33050: ARRAY
33051: PPUSH
33052: LD_VAR 0 16
33056: PUSH
33057: LD_INT 2
33059: ARRAY
33060: PPUSH
33061: CALL_OW 111
// continue ;
33065: GO 32547
// end ; end ; r := GetDir ( tmp ) ;
33067: LD_ADDR_VAR 0 15
33071: PUSH
33072: LD_VAR 0 13
33076: PPUSH
33077: CALL_OW 254
33081: ST_TO_ADDR
// if r = 5 then
33082: LD_VAR 0 15
33086: PUSH
33087: LD_INT 5
33089: EQUAL
33090: IFFALSE 33100
// r := 0 ;
33092: LD_ADDR_VAR 0 15
33096: PUSH
33097: LD_INT 0
33099: ST_TO_ADDR
// for j = r to 5 do
33100: LD_ADDR_VAR 0 10
33104: PUSH
33105: DOUBLE
33106: LD_VAR 0 15
33110: DEC
33111: ST_TO_ADDR
33112: LD_INT 5
33114: PUSH
33115: FOR_TO
33116: IFFALSE 33232
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
33118: LD_ADDR_VAR 0 11
33122: PUSH
33123: LD_VAR 0 13
33127: PPUSH
33128: CALL_OW 250
33132: PPUSH
33133: LD_VAR 0 10
33137: PPUSH
33138: LD_INT 2
33140: PPUSH
33141: CALL_OW 272
33145: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
33146: LD_ADDR_VAR 0 12
33150: PUSH
33151: LD_VAR 0 13
33155: PPUSH
33156: CALL_OW 251
33160: PPUSH
33161: LD_VAR 0 10
33165: PPUSH
33166: LD_INT 2
33168: PPUSH
33169: CALL_OW 273
33173: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
33174: LD_VAR 0 11
33178: PPUSH
33179: LD_VAR 0 12
33183: PPUSH
33184: CALL_OW 488
33188: IFFALSE 33207
33190: PUSH
33191: LD_VAR 0 11
33195: PPUSH
33196: LD_VAR 0 12
33200: PPUSH
33201: CALL_OW 428
33205: NOT
33206: AND
33207: IFFALSE 33230
// begin ComMoveXY ( tmp , _x , _y ) ;
33209: LD_VAR 0 13
33213: PPUSH
33214: LD_VAR 0 11
33218: PPUSH
33219: LD_VAR 0 12
33223: PPUSH
33224: CALL_OW 111
// break ;
33228: GO 33232
// end ; end ;
33230: GO 33115
33232: POP
33233: POP
// end ; end ;
33234: GO 32547
33236: POP
33237: POP
// end ;
33238: LD_VAR 0 8
33242: RET
// export function BuildingTechInvented ( side , btype ) ; begin
33243: LD_INT 0
33245: PPUSH
// result := true ;
33246: LD_ADDR_VAR 0 3
33250: PUSH
33251: LD_INT 1
33253: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
33254: LD_VAR 0 2
33258: PUSH
33259: LD_INT 24
33261: DOUBLE
33262: EQUAL
33263: IFTRUE 33273
33265: LD_INT 33
33267: DOUBLE
33268: EQUAL
33269: IFTRUE 33273
33271: GO 33298
33273: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
33274: LD_ADDR_VAR 0 3
33278: PUSH
33279: LD_INT 32
33281: PPUSH
33282: LD_VAR 0 1
33286: PPUSH
33287: CALL_OW 321
33291: PUSH
33292: LD_INT 2
33294: EQUAL
33295: ST_TO_ADDR
33296: GO 33614
33298: LD_INT 20
33300: DOUBLE
33301: EQUAL
33302: IFTRUE 33306
33304: GO 33331
33306: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
33307: LD_ADDR_VAR 0 3
33311: PUSH
33312: LD_INT 6
33314: PPUSH
33315: LD_VAR 0 1
33319: PPUSH
33320: CALL_OW 321
33324: PUSH
33325: LD_INT 2
33327: EQUAL
33328: ST_TO_ADDR
33329: GO 33614
33331: LD_INT 22
33333: DOUBLE
33334: EQUAL
33335: IFTRUE 33345
33337: LD_INT 36
33339: DOUBLE
33340: EQUAL
33341: IFTRUE 33345
33343: GO 33370
33345: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
33346: LD_ADDR_VAR 0 3
33350: PUSH
33351: LD_INT 15
33353: PPUSH
33354: LD_VAR 0 1
33358: PPUSH
33359: CALL_OW 321
33363: PUSH
33364: LD_INT 2
33366: EQUAL
33367: ST_TO_ADDR
33368: GO 33614
33370: LD_INT 30
33372: DOUBLE
33373: EQUAL
33374: IFTRUE 33378
33376: GO 33403
33378: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
33379: LD_ADDR_VAR 0 3
33383: PUSH
33384: LD_INT 20
33386: PPUSH
33387: LD_VAR 0 1
33391: PPUSH
33392: CALL_OW 321
33396: PUSH
33397: LD_INT 2
33399: EQUAL
33400: ST_TO_ADDR
33401: GO 33614
33403: LD_INT 28
33405: DOUBLE
33406: EQUAL
33407: IFTRUE 33417
33409: LD_INT 21
33411: DOUBLE
33412: EQUAL
33413: IFTRUE 33417
33415: GO 33442
33417: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
33418: LD_ADDR_VAR 0 3
33422: PUSH
33423: LD_INT 21
33425: PPUSH
33426: LD_VAR 0 1
33430: PPUSH
33431: CALL_OW 321
33435: PUSH
33436: LD_INT 2
33438: EQUAL
33439: ST_TO_ADDR
33440: GO 33614
33442: LD_INT 16
33444: DOUBLE
33445: EQUAL
33446: IFTRUE 33450
33448: GO 33475
33450: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
33451: LD_ADDR_VAR 0 3
33455: PUSH
33456: LD_INT 84
33458: PPUSH
33459: LD_VAR 0 1
33463: PPUSH
33464: CALL_OW 321
33468: PUSH
33469: LD_INT 2
33471: EQUAL
33472: ST_TO_ADDR
33473: GO 33614
33475: LD_INT 19
33477: DOUBLE
33478: EQUAL
33479: IFTRUE 33489
33481: LD_INT 23
33483: DOUBLE
33484: EQUAL
33485: IFTRUE 33489
33487: GO 33514
33489: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
33490: LD_ADDR_VAR 0 3
33494: PUSH
33495: LD_INT 83
33497: PPUSH
33498: LD_VAR 0 1
33502: PPUSH
33503: CALL_OW 321
33507: PUSH
33508: LD_INT 2
33510: EQUAL
33511: ST_TO_ADDR
33512: GO 33614
33514: LD_INT 17
33516: DOUBLE
33517: EQUAL
33518: IFTRUE 33522
33520: GO 33547
33522: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
33523: LD_ADDR_VAR 0 3
33527: PUSH
33528: LD_INT 39
33530: PPUSH
33531: LD_VAR 0 1
33535: PPUSH
33536: CALL_OW 321
33540: PUSH
33541: LD_INT 2
33543: EQUAL
33544: ST_TO_ADDR
33545: GO 33614
33547: LD_INT 18
33549: DOUBLE
33550: EQUAL
33551: IFTRUE 33555
33553: GO 33580
33555: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
33556: LD_ADDR_VAR 0 3
33560: PUSH
33561: LD_INT 40
33563: PPUSH
33564: LD_VAR 0 1
33568: PPUSH
33569: CALL_OW 321
33573: PUSH
33574: LD_INT 2
33576: EQUAL
33577: ST_TO_ADDR
33578: GO 33614
33580: LD_INT 27
33582: DOUBLE
33583: EQUAL
33584: IFTRUE 33588
33586: GO 33613
33588: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
33589: LD_ADDR_VAR 0 3
33593: PUSH
33594: LD_INT 35
33596: PPUSH
33597: LD_VAR 0 1
33601: PPUSH
33602: CALL_OW 321
33606: PUSH
33607: LD_INT 2
33609: EQUAL
33610: ST_TO_ADDR
33611: GO 33614
33613: POP
// end ;
33614: LD_VAR 0 3
33618: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
33619: LD_INT 0
33621: PPUSH
33622: PPUSH
33623: PPUSH
33624: PPUSH
33625: PPUSH
33626: PPUSH
33627: PPUSH
33628: PPUSH
33629: PPUSH
33630: PPUSH
33631: PPUSH
// result := false ;
33632: LD_ADDR_VAR 0 6
33636: PUSH
33637: LD_INT 0
33639: ST_TO_ADDR
// if btype = b_depot then
33640: LD_VAR 0 2
33644: PUSH
33645: LD_INT 0
33647: EQUAL
33648: IFFALSE 33660
// begin result := true ;
33650: LD_ADDR_VAR 0 6
33654: PUSH
33655: LD_INT 1
33657: ST_TO_ADDR
// exit ;
33658: GO 34514
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
33660: LD_VAR 0 1
33664: NOT
33665: IFTRUE 33690
33667: PUSH
33668: LD_VAR 0 1
33672: PPUSH
33673: CALL_OW 266
33677: PUSH
33678: LD_INT 0
33680: PUSH
33681: LD_INT 1
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: IN
33688: NOT
33689: OR
33690: IFTRUE 33699
33692: PUSH
33693: LD_VAR 0 2
33697: NOT
33698: OR
33699: IFTRUE 33735
33701: PUSH
33702: LD_VAR 0 5
33706: PUSH
33707: LD_INT 0
33709: PUSH
33710: LD_INT 1
33712: PUSH
33713: LD_INT 2
33715: PUSH
33716: LD_INT 3
33718: PUSH
33719: LD_INT 4
33721: PUSH
33722: LD_INT 5
33724: PUSH
33725: EMPTY
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: IN
33733: NOT
33734: OR
33735: IFTRUE 33754
33737: PUSH
33738: LD_VAR 0 3
33742: PPUSH
33743: LD_VAR 0 4
33747: PPUSH
33748: CALL_OW 488
33752: NOT
33753: OR
33754: IFFALSE 33758
// exit ;
33756: GO 34514
// side := GetSide ( depot ) ;
33758: LD_ADDR_VAR 0 9
33762: PUSH
33763: LD_VAR 0 1
33767: PPUSH
33768: CALL_OW 255
33772: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33773: LD_VAR 0 9
33777: PPUSH
33778: LD_VAR 0 2
33782: PPUSH
33783: CALL 33243 0 2
33787: NOT
33788: IFFALSE 33792
// exit ;
33790: GO 34514
// pom := GetBase ( depot ) ;
33792: LD_ADDR_VAR 0 10
33796: PUSH
33797: LD_VAR 0 1
33801: PPUSH
33802: CALL_OW 274
33806: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33807: LD_ADDR_VAR 0 11
33811: PUSH
33812: LD_VAR 0 2
33816: PPUSH
33817: LD_VAR 0 1
33821: PPUSH
33822: CALL_OW 248
33826: PPUSH
33827: CALL_OW 450
33831: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33832: LD_VAR 0 10
33836: PPUSH
33837: LD_INT 1
33839: PPUSH
33840: CALL_OW 275
33844: PUSH
33845: LD_VAR 0 11
33849: PUSH
33850: LD_INT 1
33852: ARRAY
33853: GREATEREQUAL
33854: IFFALSE 33880
33856: PUSH
33857: LD_VAR 0 10
33861: PPUSH
33862: LD_INT 2
33864: PPUSH
33865: CALL_OW 275
33869: PUSH
33870: LD_VAR 0 11
33874: PUSH
33875: LD_INT 2
33877: ARRAY
33878: GREATEREQUAL
33879: AND
33880: IFFALSE 33906
33882: PUSH
33883: LD_VAR 0 10
33887: PPUSH
33888: LD_INT 3
33890: PPUSH
33891: CALL_OW 275
33895: PUSH
33896: LD_VAR 0 11
33900: PUSH
33901: LD_INT 3
33903: ARRAY
33904: GREATEREQUAL
33905: AND
33906: NOT
33907: IFFALSE 33911
// exit ;
33909: GO 34514
// if GetBType ( depot ) = b_depot then
33911: LD_VAR 0 1
33915: PPUSH
33916: CALL_OW 266
33920: PUSH
33921: LD_INT 0
33923: EQUAL
33924: IFFALSE 33936
// dist := 28 else
33926: LD_ADDR_VAR 0 14
33930: PUSH
33931: LD_INT 28
33933: ST_TO_ADDR
33934: GO 33944
// dist := 36 ;
33936: LD_ADDR_VAR 0 14
33940: PUSH
33941: LD_INT 36
33943: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33944: LD_VAR 0 1
33948: PPUSH
33949: LD_VAR 0 3
33953: PPUSH
33954: LD_VAR 0 4
33958: PPUSH
33959: CALL_OW 297
33963: PUSH
33964: LD_VAR 0 14
33968: GREATER
33969: IFFALSE 33973
// exit ;
33971: GO 34514
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33973: LD_ADDR_VAR 0 12
33977: PUSH
33978: LD_VAR 0 2
33982: PPUSH
33983: LD_VAR 0 3
33987: PPUSH
33988: LD_VAR 0 4
33992: PPUSH
33993: LD_VAR 0 5
33997: PPUSH
33998: LD_VAR 0 1
34002: PPUSH
34003: CALL_OW 248
34007: PPUSH
34008: LD_INT 0
34010: PPUSH
34011: CALL 34519 0 6
34015: ST_TO_ADDR
// if not hexes then
34016: LD_VAR 0 12
34020: NOT
34021: IFFALSE 34025
// exit ;
34023: GO 34514
// hex := GetHexInfo ( x , y ) ;
34025: LD_ADDR_VAR 0 15
34029: PUSH
34030: LD_VAR 0 3
34034: PPUSH
34035: LD_VAR 0 4
34039: PPUSH
34040: CALL_OW 546
34044: ST_TO_ADDR
// if hex [ 1 ] then
34045: LD_VAR 0 15
34049: PUSH
34050: LD_INT 1
34052: ARRAY
34053: IFFALSE 34057
// exit ;
34055: GO 34514
// height := hex [ 2 ] ;
34057: LD_ADDR_VAR 0 13
34061: PUSH
34062: LD_VAR 0 15
34066: PUSH
34067: LD_INT 2
34069: ARRAY
34070: ST_TO_ADDR
// for i = 1 to hexes do
34071: LD_ADDR_VAR 0 7
34075: PUSH
34076: DOUBLE
34077: LD_INT 1
34079: DEC
34080: ST_TO_ADDR
34081: LD_VAR 0 12
34085: PUSH
34086: FOR_TO
34087: IFFALSE 34431
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
34089: LD_VAR 0 12
34093: PUSH
34094: LD_VAR 0 7
34098: ARRAY
34099: PUSH
34100: LD_INT 1
34102: ARRAY
34103: PPUSH
34104: LD_VAR 0 12
34108: PUSH
34109: LD_VAR 0 7
34113: ARRAY
34114: PUSH
34115: LD_INT 2
34117: ARRAY
34118: PPUSH
34119: CALL_OW 488
34123: NOT
34124: IFTRUE 34166
34126: PUSH
34127: LD_VAR 0 12
34131: PUSH
34132: LD_VAR 0 7
34136: ARRAY
34137: PUSH
34138: LD_INT 1
34140: ARRAY
34141: PPUSH
34142: LD_VAR 0 12
34146: PUSH
34147: LD_VAR 0 7
34151: ARRAY
34152: PUSH
34153: LD_INT 2
34155: ARRAY
34156: PPUSH
34157: CALL_OW 428
34161: PUSH
34162: LD_INT 0
34164: GREATER
34165: OR
34166: IFTRUE 34204
34168: PUSH
34169: LD_VAR 0 12
34173: PUSH
34174: LD_VAR 0 7
34178: ARRAY
34179: PUSH
34180: LD_INT 1
34182: ARRAY
34183: PPUSH
34184: LD_VAR 0 12
34188: PUSH
34189: LD_VAR 0 7
34193: ARRAY
34194: PUSH
34195: LD_INT 2
34197: ARRAY
34198: PPUSH
34199: CALL_OW 351
34203: OR
34204: IFFALSE 34210
// exit ;
34206: POP
34207: POP
34208: GO 34514
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
34210: LD_ADDR_VAR 0 8
34214: PUSH
34215: LD_VAR 0 12
34219: PUSH
34220: LD_VAR 0 7
34224: ARRAY
34225: PUSH
34226: LD_INT 1
34228: ARRAY
34229: PPUSH
34230: LD_VAR 0 12
34234: PUSH
34235: LD_VAR 0 7
34239: ARRAY
34240: PUSH
34241: LD_INT 2
34243: ARRAY
34244: PPUSH
34245: CALL_OW 546
34249: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
34250: LD_VAR 0 8
34254: PUSH
34255: LD_INT 1
34257: ARRAY
34258: IFTRUE 34280
34260: PUSH
34261: LD_VAR 0 8
34265: PUSH
34266: LD_INT 2
34268: ARRAY
34269: PUSH
34270: LD_VAR 0 13
34274: PUSH
34275: LD_INT 2
34277: PLUS
34278: GREATER
34279: OR
34280: IFTRUE 34302
34282: PUSH
34283: LD_VAR 0 8
34287: PUSH
34288: LD_INT 2
34290: ARRAY
34291: PUSH
34292: LD_VAR 0 13
34296: PUSH
34297: LD_INT 2
34299: MINUS
34300: LESS
34301: OR
34302: IFTRUE 34370
34304: PUSH
34305: LD_VAR 0 8
34309: PUSH
34310: LD_INT 3
34312: ARRAY
34313: PUSH
34314: LD_INT 0
34316: PUSH
34317: LD_INT 8
34319: PUSH
34320: LD_INT 9
34322: PUSH
34323: LD_INT 10
34325: PUSH
34326: LD_INT 11
34328: PUSH
34329: LD_INT 12
34331: PUSH
34332: LD_INT 13
34334: PUSH
34335: LD_INT 16
34337: PUSH
34338: LD_INT 17
34340: PUSH
34341: LD_INT 18
34343: PUSH
34344: LD_INT 19
34346: PUSH
34347: LD_INT 20
34349: PUSH
34350: LD_INT 21
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: LIST
34362: LIST
34363: LIST
34364: LIST
34365: LIST
34366: LIST
34367: IN
34368: NOT
34369: OR
34370: IFTRUE 34383
34372: PUSH
34373: LD_VAR 0 8
34377: PUSH
34378: LD_INT 5
34380: ARRAY
34381: NOT
34382: OR
34383: IFTRUE 34423
34385: PUSH
34386: LD_VAR 0 8
34390: PUSH
34391: LD_INT 6
34393: ARRAY
34394: PUSH
34395: LD_INT 1
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: LD_INT 7
34403: PUSH
34404: LD_INT 9
34406: PUSH
34407: LD_INT 10
34409: PUSH
34410: LD_INT 11
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: IN
34421: NOT
34422: OR
34423: IFFALSE 34429
// exit ;
34425: POP
34426: POP
34427: GO 34514
// end ;
34429: GO 34086
34431: POP
34432: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
34433: LD_VAR 0 9
34437: PPUSH
34438: LD_VAR 0 3
34442: PPUSH
34443: LD_VAR 0 4
34447: PPUSH
34448: LD_INT 20
34450: PPUSH
34451: CALL 26333 0 4
34455: PUSH
34456: LD_INT 4
34458: ARRAY
34459: IFFALSE 34463
// exit ;
34461: GO 34514
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
34463: LD_VAR 0 2
34467: PUSH
34468: LD_INT 29
34470: PUSH
34471: LD_INT 30
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: IN
34478: IFFALSE 34502
34480: PUSH
34481: LD_VAR 0 3
34485: PPUSH
34486: LD_VAR 0 4
34490: PPUSH
34491: LD_VAR 0 9
34495: PPUSH
34496: CALL_OW 440
34500: NOT
34501: AND
34502: IFFALSE 34506
// exit ;
34504: GO 34514
// result := true ;
34506: LD_ADDR_VAR 0 6
34510: PUSH
34511: LD_INT 1
34513: ST_TO_ADDR
// end ;
34514: LD_VAR 0 6
34518: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
34519: LD_INT 0
34521: PPUSH
34522: PPUSH
34523: PPUSH
34524: PPUSH
34525: PPUSH
34526: PPUSH
34527: PPUSH
34528: PPUSH
34529: PPUSH
34530: PPUSH
34531: PPUSH
34532: PPUSH
34533: PPUSH
34534: PPUSH
34535: PPUSH
34536: PPUSH
34537: PPUSH
34538: PPUSH
34539: PPUSH
34540: PPUSH
34541: PPUSH
34542: PPUSH
34543: PPUSH
34544: PPUSH
34545: PPUSH
34546: PPUSH
34547: PPUSH
34548: PPUSH
34549: PPUSH
34550: PPUSH
34551: PPUSH
34552: PPUSH
34553: PPUSH
34554: PPUSH
34555: PPUSH
34556: PPUSH
34557: PPUSH
34558: PPUSH
34559: PPUSH
34560: PPUSH
34561: PPUSH
34562: PPUSH
34563: PPUSH
34564: PPUSH
34565: PPUSH
34566: PPUSH
34567: PPUSH
34568: PPUSH
34569: PPUSH
34570: PPUSH
34571: PPUSH
34572: PPUSH
34573: PPUSH
34574: PPUSH
34575: PPUSH
34576: PPUSH
34577: PPUSH
34578: PPUSH
// result = [ ] ;
34579: LD_ADDR_VAR 0 7
34583: PUSH
34584: EMPTY
34585: ST_TO_ADDR
// temp_list = [ ] ;
34586: LD_ADDR_VAR 0 9
34590: PUSH
34591: EMPTY
34592: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
34593: LD_VAR 0 4
34597: PUSH
34598: LD_INT 0
34600: PUSH
34601: LD_INT 1
34603: PUSH
34604: LD_INT 2
34606: PUSH
34607: LD_INT 3
34609: PUSH
34610: LD_INT 4
34612: PUSH
34613: LD_INT 5
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: IN
34624: NOT
34625: IFTRUE 34668
34627: PUSH
34628: LD_VAR 0 1
34632: PUSH
34633: LD_INT 0
34635: PUSH
34636: LD_INT 1
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: IN
34643: IFFALSE 34667
34645: PUSH
34646: LD_VAR 0 5
34650: PUSH
34651: LD_INT 1
34653: PUSH
34654: LD_INT 2
34656: PUSH
34657: LD_INT 3
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: LIST
34664: IN
34665: NOT
34666: AND
34667: OR
34668: IFFALSE 34672
// exit ;
34670: GO 53071
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
34672: LD_VAR 0 1
34676: PUSH
34677: LD_INT 6
34679: PUSH
34680: LD_INT 7
34682: PUSH
34683: LD_INT 8
34685: PUSH
34686: LD_INT 13
34688: PUSH
34689: LD_INT 12
34691: PUSH
34692: LD_INT 15
34694: PUSH
34695: LD_INT 11
34697: PUSH
34698: LD_INT 14
34700: PUSH
34701: LD_INT 10
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: IN
34715: IFFALSE 34725
// btype = b_lab ;
34717: LD_ADDR_VAR 0 1
34721: PUSH
34722: LD_INT 6
34724: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34725: LD_VAR 0 6
34729: PUSH
34730: LD_INT 0
34732: PUSH
34733: LD_INT 1
34735: PUSH
34736: LD_INT 2
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: LIST
34743: IN
34744: NOT
34745: IFTRUE 34813
34747: PUSH
34748: LD_VAR 0 1
34752: PUSH
34753: LD_INT 0
34755: PUSH
34756: LD_INT 1
34758: PUSH
34759: LD_INT 2
34761: PUSH
34762: LD_INT 3
34764: PUSH
34765: LD_INT 6
34767: PUSH
34768: LD_INT 36
34770: PUSH
34771: LD_INT 4
34773: PUSH
34774: LD_INT 5
34776: PUSH
34777: LD_INT 31
34779: PUSH
34780: LD_INT 32
34782: PUSH
34783: LD_INT 33
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: IN
34799: NOT
34800: IFFALSE 34812
34802: PUSH
34803: LD_VAR 0 6
34807: PUSH
34808: LD_INT 1
34810: EQUAL
34811: AND
34812: OR
34813: IFTRUE 34845
34815: PUSH
34816: LD_VAR 0 1
34820: PUSH
34821: LD_INT 2
34823: PUSH
34824: LD_INT 3
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: IN
34831: NOT
34832: IFFALSE 34844
34834: PUSH
34835: LD_VAR 0 6
34839: PUSH
34840: LD_INT 2
34842: EQUAL
34843: AND
34844: OR
34845: IFFALSE 34855
// mode = 0 ;
34847: LD_ADDR_VAR 0 6
34851: PUSH
34852: LD_INT 0
34854: ST_TO_ADDR
// case mode of 0 :
34855: LD_VAR 0 6
34859: PUSH
34860: LD_INT 0
34862: DOUBLE
34863: EQUAL
34864: IFTRUE 34868
34866: GO 46321
34868: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34869: LD_ADDR_VAR 0 11
34873: PUSH
34874: LD_INT 0
34876: PUSH
34877: LD_INT 0
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 0
34886: PUSH
34887: LD_INT 1
34889: NEG
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 1
34897: PUSH
34898: LD_INT 0
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: PUSH
34908: LD_INT 1
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 0
34917: PUSH
34918: LD_INT 1
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 1
34927: NEG
34928: PUSH
34929: LD_INT 0
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 1
34938: NEG
34939: PUSH
34940: LD_INT 1
34942: NEG
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 1
34950: NEG
34951: PUSH
34952: LD_INT 2
34954: NEG
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 0
34962: PUSH
34963: LD_INT 2
34965: NEG
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 1
34973: PUSH
34974: LD_INT 1
34976: NEG
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: PUSH
34985: LD_INT 2
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 0
34994: PUSH
34995: LD_INT 2
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: LD_INT 1
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 1
35015: PUSH
35016: LD_INT 3
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 0
35025: PUSH
35026: LD_INT 3
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 1
35035: NEG
35036: PUSH
35037: LD_INT 2
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35062: LD_ADDR_VAR 0 12
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: LD_INT 0
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 0
35079: PUSH
35080: LD_INT 1
35082: NEG
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 1
35090: PUSH
35091: LD_INT 0
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 1
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 0
35110: PUSH
35111: LD_INT 1
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: NEG
35121: PUSH
35122: LD_INT 0
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: LD_INT 1
35131: NEG
35132: PUSH
35133: LD_INT 1
35135: NEG
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: PUSH
35144: LD_INT 1
35146: NEG
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 2
35154: PUSH
35155: LD_INT 0
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: PUSH
35162: LD_INT 2
35164: PUSH
35165: LD_INT 1
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 1
35174: NEG
35175: PUSH
35176: LD_INT 1
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: PUSH
35183: LD_INT 2
35185: NEG
35186: PUSH
35187: LD_INT 0
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: PUSH
35194: LD_INT 2
35196: NEG
35197: PUSH
35198: LD_INT 1
35200: NEG
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 2
35208: NEG
35209: PUSH
35210: LD_INT 1
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 3
35219: NEG
35220: PUSH
35221: LD_INT 0
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 3
35230: NEG
35231: PUSH
35232: LD_INT 1
35234: NEG
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: LIST
35244: LIST
35245: LIST
35246: LIST
35247: LIST
35248: LIST
35249: LIST
35250: LIST
35251: LIST
35252: LIST
35253: LIST
35254: LIST
35255: LIST
35256: LIST
35257: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35258: LD_ADDR_VAR 0 13
35262: PUSH
35263: LD_INT 0
35265: PUSH
35266: LD_INT 0
35268: PUSH
35269: EMPTY
35270: LIST
35271: LIST
35272: PUSH
35273: LD_INT 0
35275: PUSH
35276: LD_INT 1
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 1
35286: PUSH
35287: LD_INT 0
35289: PUSH
35290: EMPTY
35291: LIST
35292: LIST
35293: PUSH
35294: LD_INT 1
35296: PUSH
35297: LD_INT 1
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: LD_INT 0
35306: PUSH
35307: LD_INT 1
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: LD_INT 1
35316: NEG
35317: PUSH
35318: LD_INT 0
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 1
35327: NEG
35328: PUSH
35329: LD_INT 1
35331: NEG
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 1
35339: NEG
35340: PUSH
35341: LD_INT 2
35343: NEG
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 2
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 2
35361: PUSH
35362: LD_INT 2
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 1
35371: PUSH
35372: LD_INT 2
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 2
35381: NEG
35382: PUSH
35383: LD_INT 1
35385: NEG
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: PUSH
35391: LD_INT 2
35393: NEG
35394: PUSH
35395: LD_INT 2
35397: NEG
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 2
35405: NEG
35406: PUSH
35407: LD_INT 3
35409: NEG
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 3
35417: NEG
35418: PUSH
35419: LD_INT 2
35421: NEG
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: LD_INT 3
35429: NEG
35430: PUSH
35431: LD_INT 3
35433: NEG
35434: PUSH
35435: EMPTY
35436: LIST
35437: LIST
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35457: LD_ADDR_VAR 0 14
35461: PUSH
35462: LD_INT 0
35464: PUSH
35465: LD_INT 0
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 0
35474: PUSH
35475: LD_INT 1
35477: NEG
35478: PUSH
35479: EMPTY
35480: LIST
35481: LIST
35482: PUSH
35483: LD_INT 1
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 1
35495: PUSH
35496: LD_INT 1
35498: PUSH
35499: EMPTY
35500: LIST
35501: LIST
35502: PUSH
35503: LD_INT 0
35505: PUSH
35506: LD_INT 1
35508: PUSH
35509: EMPTY
35510: LIST
35511: LIST
35512: PUSH
35513: LD_INT 1
35515: NEG
35516: PUSH
35517: LD_INT 0
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: NEG
35527: PUSH
35528: LD_INT 1
35530: NEG
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 1
35538: NEG
35539: PUSH
35540: LD_INT 2
35542: NEG
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 0
35550: PUSH
35551: LD_INT 2
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: LD_INT 1
35564: NEG
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 1
35572: PUSH
35573: LD_INT 2
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 0
35582: PUSH
35583: LD_INT 2
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 1
35592: NEG
35593: PUSH
35594: LD_INT 1
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 1
35603: NEG
35604: PUSH
35605: LD_INT 3
35607: NEG
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 0
35615: PUSH
35616: LD_INT 3
35618: NEG
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 1
35626: PUSH
35627: LD_INT 2
35629: NEG
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35653: LD_ADDR_VAR 0 15
35657: PUSH
35658: LD_INT 0
35660: PUSH
35661: LD_INT 0
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 0
35670: PUSH
35671: LD_INT 1
35673: NEG
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 1
35681: PUSH
35682: LD_INT 0
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 1
35691: PUSH
35692: LD_INT 1
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 0
35701: PUSH
35702: LD_INT 1
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: LD_INT 1
35711: NEG
35712: PUSH
35713: LD_INT 0
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: LD_INT 1
35726: NEG
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 1
35734: PUSH
35735: LD_INT 1
35737: NEG
35738: PUSH
35739: EMPTY
35740: LIST
35741: LIST
35742: PUSH
35743: LD_INT 2
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 2
35755: PUSH
35756: LD_INT 1
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: PUSH
35763: LD_INT 1
35765: NEG
35766: PUSH
35767: LD_INT 1
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 2
35776: NEG
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 2
35787: NEG
35788: PUSH
35789: LD_INT 1
35791: NEG
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 2
35799: PUSH
35800: LD_INT 1
35802: NEG
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 3
35810: PUSH
35811: LD_INT 0
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 3
35820: PUSH
35821: LD_INT 1
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35846: LD_ADDR_VAR 0 16
35850: PUSH
35851: LD_INT 0
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 1
35866: NEG
35867: PUSH
35868: EMPTY
35869: LIST
35870: LIST
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: LD_INT 0
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 1
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 0
35894: PUSH
35895: LD_INT 1
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: NEG
35905: PUSH
35906: LD_INT 0
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 1
35915: NEG
35916: PUSH
35917: LD_INT 1
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: NEG
35928: PUSH
35929: LD_INT 2
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: PUSH
35950: LD_INT 2
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: LD_INT 2
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 2
35969: NEG
35970: PUSH
35971: LD_INT 1
35973: NEG
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: LD_INT 2
35981: NEG
35982: PUSH
35983: LD_INT 2
35985: NEG
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: LD_INT 3
35993: PUSH
35994: LD_INT 2
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 3
36003: PUSH
36004: LD_INT 3
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 2
36013: PUSH
36014: LD_INT 3
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: EMPTY
36022: LIST
36023: LIST
36024: LIST
36025: LIST
36026: LIST
36027: LIST
36028: LIST
36029: LIST
36030: LIST
36031: LIST
36032: LIST
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: LIST
36038: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36039: LD_ADDR_VAR 0 17
36043: PUSH
36044: LD_INT 0
36046: PUSH
36047: LD_INT 0
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: LD_INT 1
36059: NEG
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: LD_INT 0
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 1
36077: PUSH
36078: LD_INT 1
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 0
36087: PUSH
36088: LD_INT 1
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 1
36097: NEG
36098: PUSH
36099: LD_INT 0
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 1
36108: NEG
36109: PUSH
36110: LD_INT 1
36112: NEG
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 1
36120: NEG
36121: PUSH
36122: LD_INT 2
36124: NEG
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 0
36132: PUSH
36133: LD_INT 2
36135: NEG
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 1
36143: PUSH
36144: LD_INT 1
36146: NEG
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: LD_INT 2
36154: PUSH
36155: LD_INT 0
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 2
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 2
36174: PUSH
36175: LD_INT 2
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 1
36184: PUSH
36185: LD_INT 2
36187: PUSH
36188: EMPTY
36189: LIST
36190: LIST
36191: PUSH
36192: LD_INT 0
36194: PUSH
36195: LD_INT 2
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 1
36204: NEG
36205: PUSH
36206: LD_INT 1
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 2
36215: NEG
36216: PUSH
36217: LD_INT 0
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 2
36226: NEG
36227: PUSH
36228: LD_INT 1
36230: NEG
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 2
36238: NEG
36239: PUSH
36240: LD_INT 2
36242: NEG
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: LIST
36252: LIST
36253: LIST
36254: LIST
36255: LIST
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36269: LD_ADDR_VAR 0 18
36273: PUSH
36274: LD_INT 0
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: LD_INT 1
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 1
36307: PUSH
36308: LD_INT 1
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 0
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 1
36327: NEG
36328: PUSH
36329: LD_INT 0
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 1
36338: NEG
36339: PUSH
36340: LD_INT 1
36342: NEG
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 1
36350: NEG
36351: PUSH
36352: LD_INT 2
36354: NEG
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 0
36362: PUSH
36363: LD_INT 2
36365: NEG
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: PUSH
36374: LD_INT 1
36376: NEG
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 2
36384: PUSH
36385: LD_INT 0
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 2
36394: PUSH
36395: LD_INT 1
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 2
36404: PUSH
36405: LD_INT 2
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: PUSH
36415: LD_INT 2
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 0
36424: PUSH
36425: LD_INT 2
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 2
36445: NEG
36446: PUSH
36447: LD_INT 0
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 2
36456: NEG
36457: PUSH
36458: LD_INT 1
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 2
36468: NEG
36469: PUSH
36470: LD_INT 2
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36499: LD_ADDR_VAR 0 19
36503: PUSH
36504: LD_INT 0
36506: PUSH
36507: LD_INT 0
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: LD_INT 1
36519: NEG
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 1
36527: PUSH
36528: LD_INT 0
36530: PUSH
36531: EMPTY
36532: LIST
36533: LIST
36534: PUSH
36535: LD_INT 1
36537: PUSH
36538: LD_INT 1
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: LD_INT 0
36547: PUSH
36548: LD_INT 1
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 1
36557: NEG
36558: PUSH
36559: LD_INT 0
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: NEG
36569: PUSH
36570: LD_INT 1
36572: NEG
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: PUSH
36578: LD_INT 1
36580: NEG
36581: PUSH
36582: LD_INT 2
36584: NEG
36585: PUSH
36586: EMPTY
36587: LIST
36588: LIST
36589: PUSH
36590: LD_INT 0
36592: PUSH
36593: LD_INT 2
36595: NEG
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: LD_INT 1
36603: PUSH
36604: LD_INT 1
36606: NEG
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 2
36614: PUSH
36615: LD_INT 0
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 2
36624: PUSH
36625: LD_INT 1
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: PUSH
36632: LD_INT 2
36634: PUSH
36635: LD_INT 2
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 1
36644: PUSH
36645: LD_INT 2
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 0
36654: PUSH
36655: LD_INT 2
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: LD_INT 1
36664: NEG
36665: PUSH
36666: LD_INT 1
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 2
36675: NEG
36676: PUSH
36677: LD_INT 0
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 2
36686: NEG
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 2
36698: NEG
36699: PUSH
36700: LD_INT 2
36702: NEG
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: LIST
36712: LIST
36713: LIST
36714: LIST
36715: LIST
36716: LIST
36717: LIST
36718: LIST
36719: LIST
36720: LIST
36721: LIST
36722: LIST
36723: LIST
36724: LIST
36725: LIST
36726: LIST
36727: LIST
36728: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36729: LD_ADDR_VAR 0 20
36733: PUSH
36734: LD_INT 0
36736: PUSH
36737: LD_INT 0
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 0
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 1
36757: PUSH
36758: LD_INT 0
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 1
36767: PUSH
36768: LD_INT 1
36770: PUSH
36771: EMPTY
36772: LIST
36773: LIST
36774: PUSH
36775: LD_INT 0
36777: PUSH
36778: LD_INT 1
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 1
36787: NEG
36788: PUSH
36789: LD_INT 0
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: LD_INT 1
36802: NEG
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 1
36810: NEG
36811: PUSH
36812: LD_INT 2
36814: NEG
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 0
36822: PUSH
36823: LD_INT 2
36825: NEG
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 1
36833: PUSH
36834: LD_INT 1
36836: NEG
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 2
36844: PUSH
36845: LD_INT 0
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 2
36854: PUSH
36855: LD_INT 1
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: PUSH
36862: LD_INT 2
36864: PUSH
36865: LD_INT 2
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 1
36874: PUSH
36875: LD_INT 2
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: LD_INT 0
36884: PUSH
36885: LD_INT 2
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 1
36894: NEG
36895: PUSH
36896: LD_INT 1
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 2
36905: NEG
36906: PUSH
36907: LD_INT 0
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 2
36916: NEG
36917: PUSH
36918: LD_INT 1
36920: NEG
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 2
36928: NEG
36929: PUSH
36930: LD_INT 2
36932: NEG
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: LIST
36948: LIST
36949: LIST
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36959: LD_ADDR_VAR 0 21
36963: PUSH
36964: LD_INT 0
36966: PUSH
36967: LD_INT 0
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: LD_INT 1
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: PUSH
36988: LD_INT 0
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 1
36997: PUSH
36998: LD_INT 1
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 0
37007: PUSH
37008: LD_INT 1
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 1
37017: NEG
37018: PUSH
37019: LD_INT 0
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 1
37028: NEG
37029: PUSH
37030: LD_INT 1
37032: NEG
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: LD_INT 2
37044: NEG
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 0
37052: PUSH
37053: LD_INT 2
37055: NEG
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: LD_INT 1
37066: NEG
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 2
37074: PUSH
37075: LD_INT 0
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 2
37084: PUSH
37085: LD_INT 1
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: LD_INT 2
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: LD_INT 2
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 0
37114: PUSH
37115: LD_INT 2
37117: PUSH
37118: EMPTY
37119: LIST
37120: LIST
37121: PUSH
37122: LD_INT 1
37124: NEG
37125: PUSH
37126: LD_INT 1
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 2
37135: NEG
37136: PUSH
37137: LD_INT 0
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 2
37146: NEG
37147: PUSH
37148: LD_INT 1
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 2
37158: NEG
37159: PUSH
37160: LD_INT 2
37162: NEG
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: LIST
37176: LIST
37177: LIST
37178: LIST
37179: LIST
37180: LIST
37181: LIST
37182: LIST
37183: LIST
37184: LIST
37185: LIST
37186: LIST
37187: LIST
37188: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37189: LD_ADDR_VAR 0 22
37193: PUSH
37194: LD_INT 0
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 0
37206: PUSH
37207: LD_INT 1
37209: NEG
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: PUSH
37218: LD_INT 0
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: LD_INT 1
37227: PUSH
37228: LD_INT 1
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 0
37237: PUSH
37238: LD_INT 1
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 1
37247: NEG
37248: PUSH
37249: LD_INT 0
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 1
37258: NEG
37259: PUSH
37260: LD_INT 1
37262: NEG
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 1
37270: NEG
37271: PUSH
37272: LD_INT 2
37274: NEG
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 0
37282: PUSH
37283: LD_INT 2
37285: NEG
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 1
37293: PUSH
37294: LD_INT 1
37296: NEG
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 2
37304: PUSH
37305: LD_INT 0
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 2
37314: PUSH
37315: LD_INT 1
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 2
37324: PUSH
37325: LD_INT 2
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 1
37334: PUSH
37335: LD_INT 2
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: LD_INT 0
37344: PUSH
37345: LD_INT 2
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 1
37354: NEG
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 2
37365: NEG
37366: PUSH
37367: LD_INT 0
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 2
37376: NEG
37377: PUSH
37378: LD_INT 1
37380: NEG
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 2
37388: NEG
37389: PUSH
37390: LD_INT 2
37392: NEG
37393: PUSH
37394: EMPTY
37395: LIST
37396: LIST
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37419: LD_ADDR_VAR 0 23
37423: PUSH
37424: LD_INT 0
37426: PUSH
37427: LD_INT 0
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 0
37436: PUSH
37437: LD_INT 1
37439: NEG
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 1
37447: PUSH
37448: LD_INT 0
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 1
37457: PUSH
37458: LD_INT 1
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 0
37467: PUSH
37468: LD_INT 1
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: LD_INT 0
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 1
37488: NEG
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 1
37500: NEG
37501: PUSH
37502: LD_INT 2
37504: NEG
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 0
37512: PUSH
37513: LD_INT 2
37515: NEG
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: PUSH
37524: LD_INT 1
37526: NEG
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 2
37534: PUSH
37535: LD_INT 0
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: LD_INT 2
37544: PUSH
37545: LD_INT 1
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 2
37554: PUSH
37555: LD_INT 2
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 1
37564: PUSH
37565: LD_INT 2
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 0
37574: PUSH
37575: LD_INT 2
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 1
37584: NEG
37585: PUSH
37586: LD_INT 1
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PUSH
37593: LD_INT 2
37595: NEG
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PUSH
37604: LD_INT 2
37606: NEG
37607: PUSH
37608: LD_INT 1
37610: NEG
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: LD_INT 2
37618: NEG
37619: PUSH
37620: LD_INT 2
37622: NEG
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 2
37630: NEG
37631: PUSH
37632: LD_INT 3
37634: NEG
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: LD_INT 3
37646: NEG
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 1
37654: PUSH
37655: LD_INT 2
37657: NEG
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: LD_INT 2
37665: PUSH
37666: LD_INT 1
37668: NEG
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
37699: LD_ADDR_VAR 0 24
37703: PUSH
37704: LD_INT 0
37706: PUSH
37707: LD_INT 0
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 0
37716: PUSH
37717: LD_INT 1
37719: NEG
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 1
37727: PUSH
37728: LD_INT 0
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: LD_INT 1
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 0
37747: PUSH
37748: LD_INT 1
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 0
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 1
37768: NEG
37769: PUSH
37770: LD_INT 1
37772: NEG
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: LD_INT 1
37780: NEG
37781: PUSH
37782: LD_INT 2
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 0
37792: PUSH
37793: LD_INT 2
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 1
37803: PUSH
37804: LD_INT 1
37806: NEG
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 2
37814: PUSH
37815: LD_INT 0
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 2
37824: PUSH
37825: LD_INT 1
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: LD_INT 2
37834: PUSH
37835: LD_INT 2
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: LD_INT 1
37844: PUSH
37845: LD_INT 2
37847: PUSH
37848: EMPTY
37849: LIST
37850: LIST
37851: PUSH
37852: LD_INT 0
37854: PUSH
37855: LD_INT 2
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 1
37864: NEG
37865: PUSH
37866: LD_INT 1
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 2
37875: NEG
37876: PUSH
37877: LD_INT 0
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 2
37886: NEG
37887: PUSH
37888: LD_INT 1
37890: NEG
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 2
37898: NEG
37899: PUSH
37900: LD_INT 2
37902: NEG
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: PUSH
37908: LD_INT 1
37910: PUSH
37911: LD_INT 2
37913: NEG
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 2
37921: PUSH
37922: LD_INT 1
37924: NEG
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 3
37932: PUSH
37933: LD_INT 1
37935: PUSH
37936: EMPTY
37937: LIST
37938: LIST
37939: PUSH
37940: LD_INT 3
37942: PUSH
37943: LD_INT 2
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: LIST
37974: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37975: LD_ADDR_VAR 0 25
37979: PUSH
37980: LD_INT 0
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 0
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 1
38003: PUSH
38004: LD_INT 0
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 1
38013: PUSH
38014: LD_INT 1
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 0
38023: PUSH
38024: LD_INT 1
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 1
38033: NEG
38034: PUSH
38035: LD_INT 0
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: PUSH
38042: LD_INT 1
38044: NEG
38045: PUSH
38046: LD_INT 1
38048: NEG
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 1
38056: NEG
38057: PUSH
38058: LD_INT 2
38060: NEG
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 0
38068: PUSH
38069: LD_INT 2
38071: NEG
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 1
38079: PUSH
38080: LD_INT 1
38082: NEG
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 2
38090: PUSH
38091: LD_INT 0
38093: PUSH
38094: EMPTY
38095: LIST
38096: LIST
38097: PUSH
38098: LD_INT 2
38100: PUSH
38101: LD_INT 1
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 2
38110: PUSH
38111: LD_INT 2
38113: PUSH
38114: EMPTY
38115: LIST
38116: LIST
38117: PUSH
38118: LD_INT 1
38120: PUSH
38121: LD_INT 2
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: LD_INT 2
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 1
38140: NEG
38141: PUSH
38142: LD_INT 1
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: LD_INT 0
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 2
38162: NEG
38163: PUSH
38164: LD_INT 1
38166: NEG
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 2
38174: NEG
38175: PUSH
38176: LD_INT 2
38178: NEG
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 3
38186: PUSH
38187: LD_INT 1
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 3
38196: PUSH
38197: LD_INT 2
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PUSH
38204: LD_INT 2
38206: PUSH
38207: LD_INT 3
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 1
38216: PUSH
38217: LD_INT 3
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: LIST
38233: LIST
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: LIST
38247: LIST
38248: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38249: LD_ADDR_VAR 0 26
38253: PUSH
38254: LD_INT 0
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 0
38266: PUSH
38267: LD_INT 1
38269: NEG
38270: PUSH
38271: EMPTY
38272: LIST
38273: LIST
38274: PUSH
38275: LD_INT 1
38277: PUSH
38278: LD_INT 0
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: LD_INT 1
38287: PUSH
38288: LD_INT 1
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 0
38297: PUSH
38298: LD_INT 1
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: LD_INT 1
38307: NEG
38308: PUSH
38309: LD_INT 0
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: PUSH
38316: LD_INT 1
38318: NEG
38319: PUSH
38320: LD_INT 1
38322: NEG
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 1
38330: NEG
38331: PUSH
38332: LD_INT 2
38334: NEG
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 0
38342: PUSH
38343: LD_INT 2
38345: NEG
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: LD_INT 1
38353: PUSH
38354: LD_INT 1
38356: NEG
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 2
38364: PUSH
38365: LD_INT 0
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 2
38374: PUSH
38375: LD_INT 1
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: LD_INT 2
38384: PUSH
38385: LD_INT 2
38387: PUSH
38388: EMPTY
38389: LIST
38390: LIST
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: LD_INT 2
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 0
38404: PUSH
38405: LD_INT 2
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 1
38414: NEG
38415: PUSH
38416: LD_INT 1
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 2
38425: NEG
38426: PUSH
38427: LD_INT 0
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 2
38436: NEG
38437: PUSH
38438: LD_INT 1
38440: NEG
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 2
38448: NEG
38449: PUSH
38450: LD_INT 2
38452: NEG
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 2
38460: PUSH
38461: LD_INT 3
38463: PUSH
38464: EMPTY
38465: LIST
38466: LIST
38467: PUSH
38468: LD_INT 1
38470: PUSH
38471: LD_INT 3
38473: PUSH
38474: EMPTY
38475: LIST
38476: LIST
38477: PUSH
38478: LD_INT 1
38480: NEG
38481: PUSH
38482: LD_INT 2
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 2
38491: NEG
38492: PUSH
38493: LD_INT 1
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38525: LD_ADDR_VAR 0 27
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: LD_INT 0
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 0
38542: PUSH
38543: LD_INT 1
38545: NEG
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 1
38553: PUSH
38554: LD_INT 0
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 1
38563: PUSH
38564: LD_INT 1
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 0
38573: PUSH
38574: LD_INT 1
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: LD_INT 1
38583: NEG
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 1
38594: NEG
38595: PUSH
38596: LD_INT 1
38598: NEG
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 1
38606: NEG
38607: PUSH
38608: LD_INT 2
38610: NEG
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 0
38618: PUSH
38619: LD_INT 2
38621: NEG
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 1
38629: PUSH
38630: LD_INT 1
38632: NEG
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 2
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 2
38650: PUSH
38651: LD_INT 1
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 2
38660: PUSH
38661: LD_INT 2
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 1
38670: PUSH
38671: LD_INT 2
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 0
38680: PUSH
38681: LD_INT 2
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: NEG
38691: PUSH
38692: LD_INT 1
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 2
38701: NEG
38702: PUSH
38703: LD_INT 0
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: PUSH
38710: LD_INT 2
38712: NEG
38713: PUSH
38714: LD_INT 1
38716: NEG
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 2
38724: NEG
38725: PUSH
38726: LD_INT 2
38728: NEG
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: LD_INT 1
38736: NEG
38737: PUSH
38738: LD_INT 2
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 2
38747: NEG
38748: PUSH
38749: LD_INT 1
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 3
38758: NEG
38759: PUSH
38760: LD_INT 1
38762: NEG
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 3
38770: NEG
38771: PUSH
38772: LD_INT 2
38774: NEG
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38805: LD_ADDR_VAR 0 28
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: LD_INT 0
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 1
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: LD_INT 0
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 1
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 1
38863: NEG
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: NEG
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: LD_INT 2
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 2
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: PUSH
38921: LD_INT 0
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 2
38930: PUSH
38931: LD_INT 1
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: LD_INT 2
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: LD_INT 2
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 0
38960: PUSH
38961: LD_INT 2
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 1
38970: NEG
38971: PUSH
38972: LD_INT 1
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 2
38981: NEG
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 2
38992: NEG
38993: PUSH
38994: LD_INT 1
38996: NEG
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 2
39004: NEG
39005: PUSH
39006: LD_INT 2
39008: NEG
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: PUSH
39014: LD_INT 2
39016: NEG
39017: PUSH
39018: LD_INT 3
39020: NEG
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: LD_INT 1
39028: NEG
39029: PUSH
39030: LD_INT 3
39032: NEG
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 3
39040: NEG
39041: PUSH
39042: LD_INT 1
39044: NEG
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 3
39052: NEG
39053: PUSH
39054: LD_INT 2
39056: NEG
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39087: LD_ADDR_VAR 0 29
39091: PUSH
39092: LD_INT 0
39094: PUSH
39095: LD_INT 0
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 0
39104: PUSH
39105: LD_INT 1
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 1
39115: PUSH
39116: LD_INT 0
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: PUSH
39126: LD_INT 1
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 0
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 1
39145: NEG
39146: PUSH
39147: LD_INT 0
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 1
39156: NEG
39157: PUSH
39158: LD_INT 1
39160: NEG
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 1
39168: NEG
39169: PUSH
39170: LD_INT 2
39172: NEG
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 0
39180: PUSH
39181: LD_INT 2
39183: NEG
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 1
39191: PUSH
39192: LD_INT 1
39194: NEG
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 2
39202: PUSH
39203: LD_INT 0
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 2
39212: PUSH
39213: LD_INT 1
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 1
39222: PUSH
39223: LD_INT 2
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: LD_INT 0
39232: PUSH
39233: LD_INT 2
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 1
39242: NEG
39243: PUSH
39244: LD_INT 1
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 2
39253: NEG
39254: PUSH
39255: LD_INT 1
39257: NEG
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: LD_INT 2
39265: NEG
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 2
39277: NEG
39278: PUSH
39279: LD_INT 3
39281: NEG
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 2
39289: PUSH
39290: LD_INT 1
39292: NEG
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PUSH
39298: LD_INT 3
39300: PUSH
39301: LD_INT 1
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: LD_INT 1
39310: PUSH
39311: LD_INT 3
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 1
39320: NEG
39321: PUSH
39322: LD_INT 2
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 3
39331: NEG
39332: PUSH
39333: LD_INT 2
39335: NEG
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39366: LD_ADDR_VAR 0 30
39370: PUSH
39371: LD_INT 0
39373: PUSH
39374: LD_INT 0
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: LD_INT 0
39383: PUSH
39384: LD_INT 1
39386: NEG
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 1
39394: PUSH
39395: LD_INT 0
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 1
39404: PUSH
39405: LD_INT 1
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: LD_INT 1
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: LD_INT 1
39424: NEG
39425: PUSH
39426: LD_INT 0
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 1
39435: NEG
39436: PUSH
39437: LD_INT 1
39439: NEG
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: LD_INT 1
39447: NEG
39448: PUSH
39449: LD_INT 2
39451: NEG
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: LD_INT 2
39462: NEG
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 1
39470: PUSH
39471: LD_INT 1
39473: NEG
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 2
39481: PUSH
39482: LD_INT 0
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 2
39491: PUSH
39492: LD_INT 1
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: LD_INT 2
39501: PUSH
39502: LD_INT 2
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 1
39511: PUSH
39512: LD_INT 2
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 1
39521: NEG
39522: PUSH
39523: LD_INT 1
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: LD_INT 2
39532: NEG
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 2
39543: NEG
39544: PUSH
39545: LD_INT 1
39547: NEG
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 1
39555: NEG
39556: PUSH
39557: LD_INT 3
39559: NEG
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 1
39567: PUSH
39568: LD_INT 2
39570: NEG
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 3
39578: PUSH
39579: LD_INT 2
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 2
39588: PUSH
39589: LD_INT 3
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 2
39598: NEG
39599: PUSH
39600: LD_INT 1
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 3
39609: NEG
39610: PUSH
39611: LD_INT 1
39613: NEG
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39644: LD_ADDR_VAR 0 31
39648: PUSH
39649: LD_INT 0
39651: PUSH
39652: LD_INT 0
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 0
39661: PUSH
39662: LD_INT 1
39664: NEG
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: LD_INT 0
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 1
39682: PUSH
39683: LD_INT 1
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 0
39692: PUSH
39693: LD_INT 1
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: LD_INT 1
39702: NEG
39703: PUSH
39704: LD_INT 0
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: PUSH
39711: LD_INT 1
39713: NEG
39714: PUSH
39715: LD_INT 1
39717: NEG
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 1
39725: NEG
39726: PUSH
39727: LD_INT 2
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 1
39737: PUSH
39738: LD_INT 1
39740: NEG
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 2
39748: PUSH
39749: LD_INT 0
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 2
39758: PUSH
39759: LD_INT 1
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PUSH
39766: LD_INT 2
39768: PUSH
39769: LD_INT 2
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 1
39778: PUSH
39779: LD_INT 2
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: PUSH
39786: LD_INT 0
39788: PUSH
39789: LD_INT 2
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: NEG
39799: PUSH
39800: LD_INT 1
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 2
39809: NEG
39810: PUSH
39811: LD_INT 1
39813: NEG
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 2
39821: NEG
39822: PUSH
39823: LD_INT 2
39825: NEG
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 2
39833: NEG
39834: PUSH
39835: LD_INT 3
39837: NEG
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: LD_INT 2
39845: PUSH
39846: LD_INT 1
39848: NEG
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 3
39856: PUSH
39857: LD_INT 1
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 1
39866: PUSH
39867: LD_INT 3
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 1
39876: NEG
39877: PUSH
39878: LD_INT 2
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: PUSH
39885: LD_INT 3
39887: NEG
39888: PUSH
39889: LD_INT 2
39891: NEG
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39922: LD_ADDR_VAR 0 32
39926: PUSH
39927: LD_INT 0
39929: PUSH
39930: LD_INT 0
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 0
39939: PUSH
39940: LD_INT 1
39942: NEG
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 1
39950: PUSH
39951: LD_INT 0
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 1
39960: PUSH
39961: LD_INT 1
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: LD_INT 1
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 1
39980: NEG
39981: PUSH
39982: LD_INT 0
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 1
39991: NEG
39992: PUSH
39993: LD_INT 1
39995: NEG
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 1
40003: NEG
40004: PUSH
40005: LD_INT 2
40007: NEG
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: LD_INT 2
40018: NEG
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 1
40026: PUSH
40027: LD_INT 1
40029: NEG
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 2
40037: PUSH
40038: LD_INT 1
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 2
40047: PUSH
40048: LD_INT 2
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 1
40057: PUSH
40058: LD_INT 2
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 0
40067: PUSH
40068: LD_INT 2
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 1
40077: NEG
40078: PUSH
40079: LD_INT 1
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 2
40088: NEG
40089: PUSH
40090: LD_INT 0
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PUSH
40097: LD_INT 2
40099: NEG
40100: PUSH
40101: LD_INT 1
40103: NEG
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 1
40111: NEG
40112: PUSH
40113: LD_INT 3
40115: NEG
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 1
40123: PUSH
40124: LD_INT 2
40126: NEG
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 3
40134: PUSH
40135: LD_INT 2
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 2
40144: PUSH
40145: LD_INT 3
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 2
40154: NEG
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PUSH
40163: LD_INT 3
40165: NEG
40166: PUSH
40167: LD_INT 1
40169: NEG
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
40200: LD_ADDR_VAR 0 33
40204: PUSH
40205: LD_INT 0
40207: PUSH
40208: LD_INT 0
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 0
40217: PUSH
40218: LD_INT 1
40220: NEG
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 1
40228: PUSH
40229: LD_INT 0
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: LD_INT 1
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 0
40248: PUSH
40249: LD_INT 1
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PUSH
40256: LD_INT 1
40258: NEG
40259: PUSH
40260: LD_INT 0
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 1
40269: NEG
40270: PUSH
40271: LD_INT 1
40273: NEG
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 1
40281: NEG
40282: PUSH
40283: LD_INT 2
40285: NEG
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 1
40293: PUSH
40294: LD_INT 1
40296: NEG
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 2
40304: PUSH
40305: LD_INT 0
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 2
40314: PUSH
40315: LD_INT 1
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 1
40324: PUSH
40325: LD_INT 2
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 0
40334: PUSH
40335: LD_INT 2
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 1
40344: NEG
40345: PUSH
40346: LD_INT 1
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 2
40355: NEG
40356: PUSH
40357: LD_INT 0
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 2
40366: NEG
40367: PUSH
40368: LD_INT 1
40370: NEG
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 2
40378: NEG
40379: PUSH
40380: LD_INT 2
40382: NEG
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: PUSH
40388: LD_INT 2
40390: NEG
40391: PUSH
40392: LD_INT 3
40394: NEG
40395: PUSH
40396: EMPTY
40397: LIST
40398: LIST
40399: PUSH
40400: LD_INT 2
40402: PUSH
40403: LD_INT 1
40405: NEG
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 3
40413: PUSH
40414: LD_INT 1
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 1
40423: PUSH
40424: LD_INT 3
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 1
40433: NEG
40434: PUSH
40435: LD_INT 2
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 3
40444: NEG
40445: PUSH
40446: LD_INT 2
40448: NEG
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: LIST
40472: LIST
40473: LIST
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40479: LD_ADDR_VAR 0 34
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 0
40496: PUSH
40497: LD_INT 1
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: LD_INT 0
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 1
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 0
40527: PUSH
40528: LD_INT 1
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 1
40537: NEG
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 1
40548: NEG
40549: PUSH
40550: LD_INT 1
40552: NEG
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 1
40560: NEG
40561: PUSH
40562: LD_INT 2
40564: NEG
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 0
40572: PUSH
40573: LD_INT 2
40575: NEG
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 1
40583: PUSH
40584: LD_INT 1
40586: NEG
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 2
40594: PUSH
40595: LD_INT 1
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 2
40604: PUSH
40605: LD_INT 2
40607: PUSH
40608: EMPTY
40609: LIST
40610: LIST
40611: PUSH
40612: LD_INT 1
40614: PUSH
40615: LD_INT 2
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 1
40624: NEG
40625: PUSH
40626: LD_INT 1
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: PUSH
40633: LD_INT 2
40635: NEG
40636: PUSH
40637: LD_INT 0
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: PUSH
40644: LD_INT 2
40646: NEG
40647: PUSH
40648: LD_INT 1
40650: NEG
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 2
40658: NEG
40659: PUSH
40660: LD_INT 2
40662: NEG
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 1
40670: NEG
40671: PUSH
40672: LD_INT 3
40674: NEG
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 1
40682: PUSH
40683: LD_INT 2
40685: NEG
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 3
40693: PUSH
40694: LD_INT 2
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: LD_INT 2
40703: PUSH
40704: LD_INT 3
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 2
40713: NEG
40714: PUSH
40715: LD_INT 1
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 3
40724: NEG
40725: PUSH
40726: LD_INT 1
40728: NEG
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: LIST
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: LIST
40758: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40759: LD_ADDR_VAR 0 35
40763: PUSH
40764: LD_INT 0
40766: PUSH
40767: LD_INT 0
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 0
40776: PUSH
40777: LD_INT 1
40779: NEG
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 1
40787: PUSH
40788: LD_INT 0
40790: PUSH
40791: EMPTY
40792: LIST
40793: LIST
40794: PUSH
40795: LD_INT 1
40797: PUSH
40798: LD_INT 1
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 0
40807: PUSH
40808: LD_INT 1
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: LD_INT 1
40817: NEG
40818: PUSH
40819: LD_INT 0
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: LD_INT 1
40828: NEG
40829: PUSH
40830: LD_INT 1
40832: NEG
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 2
40840: PUSH
40841: LD_INT 1
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 2
40850: NEG
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: LIST
40870: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40871: LD_ADDR_VAR 0 36
40875: PUSH
40876: LD_INT 0
40878: PUSH
40879: LD_INT 0
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 0
40888: PUSH
40889: LD_INT 1
40891: NEG
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 1
40899: PUSH
40900: LD_INT 0
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: LD_INT 1
40909: PUSH
40910: LD_INT 1
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: PUSH
40917: LD_INT 0
40919: PUSH
40920: LD_INT 1
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 1
40929: NEG
40930: PUSH
40931: LD_INT 0
40933: PUSH
40934: EMPTY
40935: LIST
40936: LIST
40937: PUSH
40938: LD_INT 1
40940: NEG
40941: PUSH
40942: LD_INT 1
40944: NEG
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 1
40952: NEG
40953: PUSH
40954: LD_INT 2
40956: NEG
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: LD_INT 1
40964: PUSH
40965: LD_INT 2
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: LIST
40980: LIST
40981: LIST
40982: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40983: LD_ADDR_VAR 0 37
40987: PUSH
40988: LD_INT 0
40990: PUSH
40991: LD_INT 0
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: PUSH
40998: LD_INT 0
41000: PUSH
41001: LD_INT 1
41003: NEG
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 1
41011: PUSH
41012: LD_INT 0
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: LD_INT 1
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: LD_INT 0
41031: PUSH
41032: LD_INT 1
41034: PUSH
41035: EMPTY
41036: LIST
41037: LIST
41038: PUSH
41039: LD_INT 1
41041: NEG
41042: PUSH
41043: LD_INT 0
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 1
41052: NEG
41053: PUSH
41054: LD_INT 1
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: LD_INT 1
41064: PUSH
41065: LD_INT 1
41067: NEG
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: PUSH
41073: LD_INT 1
41075: NEG
41076: PUSH
41077: LD_INT 1
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: EMPTY
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
41095: LD_ADDR_VAR 0 38
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: LD_INT 0
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: LD_INT 0
41112: PUSH
41113: LD_INT 1
41115: NEG
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 1
41123: PUSH
41124: LD_INT 0
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 1
41133: PUSH
41134: LD_INT 1
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 0
41143: PUSH
41144: LD_INT 1
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 1
41153: NEG
41154: PUSH
41155: LD_INT 0
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: NEG
41165: PUSH
41166: LD_INT 1
41168: NEG
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 2
41176: PUSH
41177: LD_INT 1
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 2
41186: NEG
41187: PUSH
41188: LD_INT 1
41190: NEG
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
41207: LD_ADDR_VAR 0 39
41211: PUSH
41212: LD_INT 0
41214: PUSH
41215: LD_INT 0
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: LD_INT 0
41224: PUSH
41225: LD_INT 1
41227: NEG
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 1
41235: PUSH
41236: LD_INT 0
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 1
41245: PUSH
41246: LD_INT 1
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: LD_INT 0
41255: PUSH
41256: LD_INT 1
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: LD_INT 1
41265: NEG
41266: PUSH
41267: LD_INT 0
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 1
41276: NEG
41277: PUSH
41278: LD_INT 1
41280: NEG
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 1
41288: NEG
41289: PUSH
41290: LD_INT 2
41292: NEG
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: PUSH
41298: LD_INT 1
41300: PUSH
41301: LD_INT 2
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: LIST
41312: LIST
41313: LIST
41314: LIST
41315: LIST
41316: LIST
41317: LIST
41318: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
41319: LD_ADDR_VAR 0 40
41323: PUSH
41324: LD_INT 0
41326: PUSH
41327: LD_INT 0
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 0
41336: PUSH
41337: LD_INT 1
41339: NEG
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 1
41347: PUSH
41348: LD_INT 0
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: LD_INT 1
41357: PUSH
41358: LD_INT 1
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 0
41367: PUSH
41368: LD_INT 1
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: LD_INT 1
41377: NEG
41378: PUSH
41379: LD_INT 0
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: PUSH
41386: LD_INT 1
41388: NEG
41389: PUSH
41390: LD_INT 1
41392: NEG
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: LD_INT 1
41400: PUSH
41401: LD_INT 1
41403: NEG
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 1
41411: NEG
41412: PUSH
41413: LD_INT 1
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: EMPTY
41421: LIST
41422: LIST
41423: LIST
41424: LIST
41425: LIST
41426: LIST
41427: LIST
41428: LIST
41429: LIST
41430: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41431: LD_ADDR_VAR 0 41
41435: PUSH
41436: LD_INT 0
41438: PUSH
41439: LD_INT 0
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 0
41448: PUSH
41449: LD_INT 1
41451: NEG
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 1
41459: PUSH
41460: LD_INT 0
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 1
41469: PUSH
41470: LD_INT 1
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: LD_INT 0
41479: PUSH
41480: LD_INT 1
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 1
41489: NEG
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 1
41500: NEG
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 1
41512: NEG
41513: PUSH
41514: LD_INT 2
41516: NEG
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: LD_INT 1
41524: PUSH
41525: LD_INT 1
41527: NEG
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PUSH
41533: LD_INT 2
41535: PUSH
41536: LD_INT 0
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: PUSH
41543: LD_INT 2
41545: PUSH
41546: LD_INT 1
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 2
41555: PUSH
41556: LD_INT 2
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: PUSH
41563: LD_INT 1
41565: PUSH
41566: LD_INT 2
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 1
41575: NEG
41576: PUSH
41577: LD_INT 1
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 2
41586: NEG
41587: PUSH
41588: LD_INT 0
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 2
41597: NEG
41598: PUSH
41599: LD_INT 1
41601: NEG
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: LD_INT 2
41609: NEG
41610: PUSH
41611: LD_INT 2
41613: NEG
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 2
41621: NEG
41622: PUSH
41623: LD_INT 3
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 2
41633: PUSH
41634: LD_INT 1
41636: NEG
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 3
41644: PUSH
41645: LD_INT 0
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 3
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: PUSH
41662: LD_INT 3
41664: PUSH
41665: LD_INT 2
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 3
41674: PUSH
41675: LD_INT 3
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 2
41684: PUSH
41685: LD_INT 3
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 2
41694: NEG
41695: PUSH
41696: LD_INT 1
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 3
41705: NEG
41706: PUSH
41707: LD_INT 0
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 3
41716: NEG
41717: PUSH
41718: LD_INT 1
41720: NEG
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 3
41728: NEG
41729: PUSH
41730: LD_INT 2
41732: NEG
41733: PUSH
41734: EMPTY
41735: LIST
41736: LIST
41737: PUSH
41738: LD_INT 3
41740: NEG
41741: PUSH
41742: LD_INT 3
41744: NEG
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41781: LD_ADDR_VAR 0 42
41785: PUSH
41786: LD_INT 0
41788: PUSH
41789: LD_INT 0
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: LD_INT 0
41798: PUSH
41799: LD_INT 1
41801: NEG
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: LD_INT 1
41809: PUSH
41810: LD_INT 0
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: LD_INT 1
41819: PUSH
41820: LD_INT 1
41822: PUSH
41823: EMPTY
41824: LIST
41825: LIST
41826: PUSH
41827: LD_INT 0
41829: PUSH
41830: LD_INT 1
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 1
41839: NEG
41840: PUSH
41841: LD_INT 0
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 1
41850: NEG
41851: PUSH
41852: LD_INT 1
41854: NEG
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 1
41862: NEG
41863: PUSH
41864: LD_INT 2
41866: NEG
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: PUSH
41872: LD_INT 0
41874: PUSH
41875: LD_INT 2
41877: NEG
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: PUSH
41883: LD_INT 1
41885: PUSH
41886: LD_INT 1
41888: NEG
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 2
41896: PUSH
41897: LD_INT 1
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 2
41906: PUSH
41907: LD_INT 2
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 1
41916: PUSH
41917: LD_INT 2
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: PUSH
41924: LD_INT 0
41926: PUSH
41927: LD_INT 2
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 1
41936: NEG
41937: PUSH
41938: LD_INT 1
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 2
41947: NEG
41948: PUSH
41949: LD_INT 1
41951: NEG
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: LD_INT 2
41959: NEG
41960: PUSH
41961: LD_INT 2
41963: NEG
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 2
41971: NEG
41972: PUSH
41973: LD_INT 3
41975: NEG
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 1
41983: NEG
41984: PUSH
41985: LD_INT 3
41987: NEG
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: PUSH
41993: LD_INT 0
41995: PUSH
41996: LD_INT 3
41998: NEG
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 1
42006: PUSH
42007: LD_INT 2
42009: NEG
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: PUSH
42015: LD_INT 3
42017: PUSH
42018: LD_INT 2
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 3
42027: PUSH
42028: LD_INT 3
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: LD_INT 2
42037: PUSH
42038: LD_INT 3
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 1
42047: PUSH
42048: LD_INT 3
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 0
42057: PUSH
42058: LD_INT 3
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 1
42067: NEG
42068: PUSH
42069: LD_INT 2
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 3
42078: NEG
42079: PUSH
42080: LD_INT 2
42082: NEG
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 3
42090: NEG
42091: PUSH
42092: LD_INT 3
42094: NEG
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: LIST
42104: LIST
42105: LIST
42106: LIST
42107: LIST
42108: LIST
42109: LIST
42110: LIST
42111: LIST
42112: LIST
42113: LIST
42114: LIST
42115: LIST
42116: LIST
42117: LIST
42118: LIST
42119: LIST
42120: LIST
42121: LIST
42122: LIST
42123: LIST
42124: LIST
42125: LIST
42126: LIST
42127: LIST
42128: LIST
42129: LIST
42130: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42131: LD_ADDR_VAR 0 43
42135: PUSH
42136: LD_INT 0
42138: PUSH
42139: LD_INT 0
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 0
42148: PUSH
42149: LD_INT 1
42151: NEG
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 1
42159: PUSH
42160: LD_INT 0
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 1
42169: PUSH
42170: LD_INT 1
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: LD_INT 0
42179: PUSH
42180: LD_INT 1
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 1
42189: NEG
42190: PUSH
42191: LD_INT 0
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: PUSH
42198: LD_INT 1
42200: NEG
42201: PUSH
42202: LD_INT 1
42204: NEG
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 1
42212: NEG
42213: PUSH
42214: LD_INT 2
42216: NEG
42217: PUSH
42218: EMPTY
42219: LIST
42220: LIST
42221: PUSH
42222: LD_INT 0
42224: PUSH
42225: LD_INT 2
42227: NEG
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 1
42235: PUSH
42236: LD_INT 1
42238: NEG
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: LD_INT 2
42246: PUSH
42247: LD_INT 0
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PUSH
42254: LD_INT 2
42256: PUSH
42257: LD_INT 1
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: PUSH
42264: LD_INT 1
42266: PUSH
42267: LD_INT 2
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 0
42276: PUSH
42277: LD_INT 2
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: LD_INT 1
42286: NEG
42287: PUSH
42288: LD_INT 1
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 2
42297: NEG
42298: PUSH
42299: LD_INT 0
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PUSH
42306: LD_INT 2
42308: NEG
42309: PUSH
42310: LD_INT 1
42312: NEG
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 1
42320: NEG
42321: PUSH
42322: LD_INT 3
42324: NEG
42325: PUSH
42326: EMPTY
42327: LIST
42328: LIST
42329: PUSH
42330: LD_INT 0
42332: PUSH
42333: LD_INT 3
42335: NEG
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: PUSH
42341: LD_INT 1
42343: PUSH
42344: LD_INT 2
42346: NEG
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 2
42354: PUSH
42355: LD_INT 1
42357: NEG
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 3
42365: PUSH
42366: LD_INT 0
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 3
42375: PUSH
42376: LD_INT 1
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PUSH
42383: LD_INT 1
42385: PUSH
42386: LD_INT 3
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 0
42395: PUSH
42396: LD_INT 3
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 1
42405: NEG
42406: PUSH
42407: LD_INT 2
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 2
42416: NEG
42417: PUSH
42418: LD_INT 1
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 3
42427: NEG
42428: PUSH
42429: LD_INT 0
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: PUSH
42436: LD_INT 3
42438: NEG
42439: PUSH
42440: LD_INT 1
42442: NEG
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: LIST
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42479: LD_ADDR_VAR 0 44
42483: PUSH
42484: LD_INT 0
42486: PUSH
42487: LD_INT 0
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 0
42496: PUSH
42497: LD_INT 1
42499: NEG
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 1
42507: PUSH
42508: LD_INT 0
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 1
42517: PUSH
42518: LD_INT 1
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 0
42527: PUSH
42528: LD_INT 1
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: PUSH
42535: LD_INT 1
42537: NEG
42538: PUSH
42539: LD_INT 0
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 1
42548: NEG
42549: PUSH
42550: LD_INT 1
42552: NEG
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 1
42560: NEG
42561: PUSH
42562: LD_INT 2
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 1
42572: PUSH
42573: LD_INT 1
42575: NEG
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 2
42583: PUSH
42584: LD_INT 0
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: LD_INT 2
42593: PUSH
42594: LD_INT 1
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: PUSH
42601: LD_INT 2
42603: PUSH
42604: LD_INT 2
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 1
42613: PUSH
42614: LD_INT 2
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 1
42623: NEG
42624: PUSH
42625: LD_INT 1
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 2
42634: NEG
42635: PUSH
42636: LD_INT 0
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: LD_INT 2
42645: NEG
42646: PUSH
42647: LD_INT 1
42649: NEG
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: LD_INT 2
42657: NEG
42658: PUSH
42659: LD_INT 2
42661: NEG
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 2
42669: NEG
42670: PUSH
42671: LD_INT 3
42673: NEG
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 2
42681: PUSH
42682: LD_INT 1
42684: NEG
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 3
42692: PUSH
42693: LD_INT 0
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: LD_INT 3
42702: PUSH
42703: LD_INT 1
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 3
42712: PUSH
42713: LD_INT 2
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 3
42722: PUSH
42723: LD_INT 3
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 2
42732: PUSH
42733: LD_INT 3
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 2
42742: NEG
42743: PUSH
42744: LD_INT 1
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 3
42753: NEG
42754: PUSH
42755: LD_INT 0
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 3
42764: NEG
42765: PUSH
42766: LD_INT 1
42768: NEG
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: LD_INT 3
42776: NEG
42777: PUSH
42778: LD_INT 2
42780: NEG
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: LD_INT 3
42788: NEG
42789: PUSH
42790: LD_INT 3
42792: NEG
42793: PUSH
42794: EMPTY
42795: LIST
42796: LIST
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: LIST
42802: LIST
42803: LIST
42804: LIST
42805: LIST
42806: LIST
42807: LIST
42808: LIST
42809: LIST
42810: LIST
42811: LIST
42812: LIST
42813: LIST
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: LIST
42821: LIST
42822: LIST
42823: LIST
42824: LIST
42825: LIST
42826: LIST
42827: LIST
42828: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42829: LD_ADDR_VAR 0 45
42833: PUSH
42834: LD_INT 0
42836: PUSH
42837: LD_INT 0
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 0
42846: PUSH
42847: LD_INT 1
42849: NEG
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 1
42857: PUSH
42858: LD_INT 0
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 1
42867: PUSH
42868: LD_INT 1
42870: PUSH
42871: EMPTY
42872: LIST
42873: LIST
42874: PUSH
42875: LD_INT 0
42877: PUSH
42878: LD_INT 1
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: PUSH
42885: LD_INT 1
42887: NEG
42888: PUSH
42889: LD_INT 0
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: PUSH
42896: LD_INT 1
42898: NEG
42899: PUSH
42900: LD_INT 1
42902: NEG
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 1
42910: NEG
42911: PUSH
42912: LD_INT 2
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 0
42922: PUSH
42923: LD_INT 2
42925: NEG
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: LD_INT 1
42936: NEG
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: PUSH
42942: LD_INT 2
42944: PUSH
42945: LD_INT 1
42947: PUSH
42948: EMPTY
42949: LIST
42950: LIST
42951: PUSH
42952: LD_INT 2
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: LD_INT 1
42964: PUSH
42965: LD_INT 2
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: PUSH
42972: LD_INT 0
42974: PUSH
42975: LD_INT 2
42977: PUSH
42978: EMPTY
42979: LIST
42980: LIST
42981: PUSH
42982: LD_INT 1
42984: NEG
42985: PUSH
42986: LD_INT 1
42988: PUSH
42989: EMPTY
42990: LIST
42991: LIST
42992: PUSH
42993: LD_INT 2
42995: NEG
42996: PUSH
42997: LD_INT 1
42999: NEG
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 2
43007: NEG
43008: PUSH
43009: LD_INT 2
43011: NEG
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 2
43019: NEG
43020: PUSH
43021: LD_INT 3
43023: NEG
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: PUSH
43029: LD_INT 1
43031: NEG
43032: PUSH
43033: LD_INT 3
43035: NEG
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PUSH
43041: LD_INT 0
43043: PUSH
43044: LD_INT 3
43046: NEG
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: LD_INT 1
43054: PUSH
43055: LD_INT 2
43057: NEG
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 3
43065: PUSH
43066: LD_INT 2
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 3
43075: PUSH
43076: LD_INT 3
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 2
43085: PUSH
43086: LD_INT 3
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 1
43095: PUSH
43096: LD_INT 3
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 0
43105: PUSH
43106: LD_INT 3
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 1
43115: NEG
43116: PUSH
43117: LD_INT 2
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 3
43126: NEG
43127: PUSH
43128: LD_INT 2
43130: NEG
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: LD_INT 3
43138: NEG
43139: PUSH
43140: LD_INT 3
43142: NEG
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: PUSH
43148: EMPTY
43149: LIST
43150: LIST
43151: LIST
43152: LIST
43153: LIST
43154: LIST
43155: LIST
43156: LIST
43157: LIST
43158: LIST
43159: LIST
43160: LIST
43161: LIST
43162: LIST
43163: LIST
43164: LIST
43165: LIST
43166: LIST
43167: LIST
43168: LIST
43169: LIST
43170: LIST
43171: LIST
43172: LIST
43173: LIST
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43179: LD_ADDR_VAR 0 46
43183: PUSH
43184: LD_INT 0
43186: PUSH
43187: LD_INT 0
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: LD_INT 0
43196: PUSH
43197: LD_INT 1
43199: NEG
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: PUSH
43205: LD_INT 1
43207: PUSH
43208: LD_INT 0
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: PUSH
43215: LD_INT 1
43217: PUSH
43218: LD_INT 1
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: LD_INT 1
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: PUSH
43235: LD_INT 1
43237: NEG
43238: PUSH
43239: LD_INT 0
43241: PUSH
43242: EMPTY
43243: LIST
43244: LIST
43245: PUSH
43246: LD_INT 1
43248: NEG
43249: PUSH
43250: LD_INT 1
43252: NEG
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: LD_INT 1
43260: NEG
43261: PUSH
43262: LD_INT 2
43264: NEG
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 0
43272: PUSH
43273: LD_INT 2
43275: NEG
43276: PUSH
43277: EMPTY
43278: LIST
43279: LIST
43280: PUSH
43281: LD_INT 1
43283: PUSH
43284: LD_INT 1
43286: NEG
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 2
43294: PUSH
43295: LD_INT 0
43297: PUSH
43298: EMPTY
43299: LIST
43300: LIST
43301: PUSH
43302: LD_INT 2
43304: PUSH
43305: LD_INT 1
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 1
43314: PUSH
43315: LD_INT 2
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 0
43324: PUSH
43325: LD_INT 2
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 1
43334: NEG
43335: PUSH
43336: LD_INT 1
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 2
43345: NEG
43346: PUSH
43347: LD_INT 0
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 2
43356: NEG
43357: PUSH
43358: LD_INT 1
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 1
43368: NEG
43369: PUSH
43370: LD_INT 3
43372: NEG
43373: PUSH
43374: EMPTY
43375: LIST
43376: LIST
43377: PUSH
43378: LD_INT 0
43380: PUSH
43381: LD_INT 3
43383: NEG
43384: PUSH
43385: EMPTY
43386: LIST
43387: LIST
43388: PUSH
43389: LD_INT 1
43391: PUSH
43392: LD_INT 2
43394: NEG
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: LD_INT 2
43402: PUSH
43403: LD_INT 1
43405: NEG
43406: PUSH
43407: EMPTY
43408: LIST
43409: LIST
43410: PUSH
43411: LD_INT 3
43413: PUSH
43414: LD_INT 0
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 3
43423: PUSH
43424: LD_INT 1
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 1
43433: PUSH
43434: LD_INT 3
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 0
43443: PUSH
43444: LD_INT 3
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: LD_INT 1
43453: NEG
43454: PUSH
43455: LD_INT 2
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 2
43464: NEG
43465: PUSH
43466: LD_INT 1
43468: PUSH
43469: EMPTY
43470: LIST
43471: LIST
43472: PUSH
43473: LD_INT 3
43475: NEG
43476: PUSH
43477: LD_INT 0
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 3
43486: NEG
43487: PUSH
43488: LD_INT 1
43490: NEG
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: LIST
43504: LIST
43505: LIST
43506: LIST
43507: LIST
43508: LIST
43509: LIST
43510: LIST
43511: LIST
43512: LIST
43513: LIST
43514: LIST
43515: LIST
43516: LIST
43517: LIST
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: LIST
43525: LIST
43526: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43527: LD_ADDR_VAR 0 47
43531: PUSH
43532: LD_INT 0
43534: PUSH
43535: LD_INT 0
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 0
43544: PUSH
43545: LD_INT 1
43547: NEG
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 1
43555: PUSH
43556: LD_INT 0
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: LD_INT 1
43565: PUSH
43566: LD_INT 1
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: PUSH
43573: LD_INT 0
43575: PUSH
43576: LD_INT 1
43578: PUSH
43579: EMPTY
43580: LIST
43581: LIST
43582: PUSH
43583: LD_INT 1
43585: NEG
43586: PUSH
43587: LD_INT 0
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 1
43596: NEG
43597: PUSH
43598: LD_INT 1
43600: NEG
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 1
43608: NEG
43609: PUSH
43610: LD_INT 2
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 0
43620: PUSH
43621: LD_INT 2
43623: NEG
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: LD_INT 1
43631: PUSH
43632: LD_INT 1
43634: NEG
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: LD_INT 2
43642: NEG
43643: PUSH
43644: LD_INT 1
43646: NEG
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: PUSH
43652: LD_INT 2
43654: NEG
43655: PUSH
43656: LD_INT 2
43658: NEG
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: LIST
43668: LIST
43669: LIST
43670: LIST
43671: LIST
43672: LIST
43673: LIST
43674: LIST
43675: LIST
43676: LIST
43677: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43678: LD_ADDR_VAR 0 48
43682: PUSH
43683: LD_INT 0
43685: PUSH
43686: LD_INT 0
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 0
43695: PUSH
43696: LD_INT 1
43698: NEG
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 1
43706: PUSH
43707: LD_INT 0
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 1
43716: PUSH
43717: LD_INT 1
43719: PUSH
43720: EMPTY
43721: LIST
43722: LIST
43723: PUSH
43724: LD_INT 0
43726: PUSH
43727: LD_INT 1
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 1
43736: NEG
43737: PUSH
43738: LD_INT 0
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 1
43747: NEG
43748: PUSH
43749: LD_INT 1
43751: NEG
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 1
43759: NEG
43760: PUSH
43761: LD_INT 2
43763: NEG
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 0
43771: PUSH
43772: LD_INT 2
43774: NEG
43775: PUSH
43776: EMPTY
43777: LIST
43778: LIST
43779: PUSH
43780: LD_INT 1
43782: PUSH
43783: LD_INT 1
43785: NEG
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 2
43793: PUSH
43794: LD_INT 0
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 2
43803: PUSH
43804: LD_INT 1
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: LIST
43815: LIST
43816: LIST
43817: LIST
43818: LIST
43819: LIST
43820: LIST
43821: LIST
43822: LIST
43823: LIST
43824: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43825: LD_ADDR_VAR 0 49
43829: PUSH
43830: LD_INT 0
43832: PUSH
43833: LD_INT 0
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: PUSH
43840: LD_INT 0
43842: PUSH
43843: LD_INT 1
43845: NEG
43846: PUSH
43847: EMPTY
43848: LIST
43849: LIST
43850: PUSH
43851: LD_INT 1
43853: PUSH
43854: LD_INT 0
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: PUSH
43861: LD_INT 1
43863: PUSH
43864: LD_INT 1
43866: PUSH
43867: EMPTY
43868: LIST
43869: LIST
43870: PUSH
43871: LD_INT 0
43873: PUSH
43874: LD_INT 1
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: PUSH
43881: LD_INT 1
43883: NEG
43884: PUSH
43885: LD_INT 0
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: LD_INT 1
43894: NEG
43895: PUSH
43896: LD_INT 1
43898: NEG
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 1
43906: PUSH
43907: LD_INT 1
43909: NEG
43910: PUSH
43911: EMPTY
43912: LIST
43913: LIST
43914: PUSH
43915: LD_INT 2
43917: PUSH
43918: LD_INT 0
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: PUSH
43925: LD_INT 2
43927: PUSH
43928: LD_INT 1
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 2
43937: PUSH
43938: LD_INT 2
43940: PUSH
43941: EMPTY
43942: LIST
43943: LIST
43944: PUSH
43945: LD_INT 1
43947: PUSH
43948: LD_INT 2
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: LIST
43965: LIST
43966: LIST
43967: LIST
43968: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43969: LD_ADDR_VAR 0 50
43973: PUSH
43974: LD_INT 0
43976: PUSH
43977: LD_INT 0
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 0
43986: PUSH
43987: LD_INT 1
43989: NEG
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 1
43997: PUSH
43998: LD_INT 0
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 1
44007: PUSH
44008: LD_INT 1
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: LD_INT 0
44017: PUSH
44018: LD_INT 1
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: LD_INT 1
44027: NEG
44028: PUSH
44029: LD_INT 0
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 1
44038: NEG
44039: PUSH
44040: LD_INT 1
44042: NEG
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 2
44050: PUSH
44051: LD_INT 1
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 2
44060: PUSH
44061: LD_INT 2
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 1
44070: PUSH
44071: LD_INT 2
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 0
44080: PUSH
44081: LD_INT 2
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 1
44090: NEG
44091: PUSH
44092: LD_INT 1
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: LIST
44110: LIST
44111: LIST
44112: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44113: LD_ADDR_VAR 0 51
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: LD_INT 0
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 0
44130: PUSH
44131: LD_INT 1
44133: NEG
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 1
44141: PUSH
44142: LD_INT 0
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: PUSH
44149: LD_INT 1
44151: PUSH
44152: LD_INT 1
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 0
44161: PUSH
44162: LD_INT 1
44164: PUSH
44165: EMPTY
44166: LIST
44167: LIST
44168: PUSH
44169: LD_INT 1
44171: NEG
44172: PUSH
44173: LD_INT 0
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 1
44182: NEG
44183: PUSH
44184: LD_INT 1
44186: NEG
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 1
44194: PUSH
44195: LD_INT 2
44197: PUSH
44198: EMPTY
44199: LIST
44200: LIST
44201: PUSH
44202: LD_INT 0
44204: PUSH
44205: LD_INT 2
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 1
44214: NEG
44215: PUSH
44216: LD_INT 1
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 2
44225: NEG
44226: PUSH
44227: LD_INT 0
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: LD_INT 2
44236: NEG
44237: PUSH
44238: LD_INT 1
44240: NEG
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44260: LD_ADDR_VAR 0 52
44264: PUSH
44265: LD_INT 0
44267: PUSH
44268: LD_INT 0
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 0
44277: PUSH
44278: LD_INT 1
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 1
44288: PUSH
44289: LD_INT 0
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: LD_INT 1
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 0
44308: PUSH
44309: LD_INT 1
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 1
44318: NEG
44319: PUSH
44320: LD_INT 0
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 1
44329: NEG
44330: PUSH
44331: LD_INT 1
44333: NEG
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 1
44341: NEG
44342: PUSH
44343: LD_INT 2
44345: NEG
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: LD_INT 1
44353: NEG
44354: PUSH
44355: LD_INT 1
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 2
44364: NEG
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 2
44375: NEG
44376: PUSH
44377: LD_INT 1
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 2
44387: NEG
44388: PUSH
44389: LD_INT 2
44391: NEG
44392: PUSH
44393: EMPTY
44394: LIST
44395: LIST
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44411: LD_ADDR_VAR 0 53
44415: PUSH
44416: LD_INT 0
44418: PUSH
44419: LD_INT 0
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 0
44428: PUSH
44429: LD_INT 1
44431: NEG
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: LD_INT 1
44439: PUSH
44440: LD_INT 0
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: LD_INT 1
44449: PUSH
44450: LD_INT 1
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 0
44459: PUSH
44460: LD_INT 1
44462: PUSH
44463: EMPTY
44464: LIST
44465: LIST
44466: PUSH
44467: LD_INT 1
44469: NEG
44470: PUSH
44471: LD_INT 0
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: LD_INT 1
44480: NEG
44481: PUSH
44482: LD_INT 1
44484: NEG
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PUSH
44490: LD_INT 1
44492: NEG
44493: PUSH
44494: LD_INT 2
44496: NEG
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: PUSH
44502: LD_INT 0
44504: PUSH
44505: LD_INT 2
44507: NEG
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 1
44515: PUSH
44516: LD_INT 1
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 2
44526: PUSH
44527: LD_INT 0
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: LD_INT 2
44536: PUSH
44537: LD_INT 1
44539: PUSH
44540: EMPTY
44541: LIST
44542: LIST
44543: PUSH
44544: LD_INT 2
44546: PUSH
44547: LD_INT 2
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 1
44556: PUSH
44557: LD_INT 2
44559: PUSH
44560: EMPTY
44561: LIST
44562: LIST
44563: PUSH
44564: LD_INT 0
44566: PUSH
44567: LD_INT 2
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: PUSH
44574: LD_INT 1
44576: NEG
44577: PUSH
44578: LD_INT 1
44580: PUSH
44581: EMPTY
44582: LIST
44583: LIST
44584: PUSH
44585: LD_INT 2
44587: NEG
44588: PUSH
44589: LD_INT 0
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 2
44598: NEG
44599: PUSH
44600: LD_INT 1
44602: NEG
44603: PUSH
44604: EMPTY
44605: LIST
44606: LIST
44607: PUSH
44608: LD_INT 2
44610: NEG
44611: PUSH
44612: LD_INT 2
44614: NEG
44615: PUSH
44616: EMPTY
44617: LIST
44618: LIST
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: LIST
44624: LIST
44625: LIST
44626: LIST
44627: LIST
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: LIST
44635: LIST
44636: LIST
44637: LIST
44638: LIST
44639: LIST
44640: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44641: LD_ADDR_VAR 0 54
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: LD_INT 0
44651: PUSH
44652: EMPTY
44653: LIST
44654: LIST
44655: PUSH
44656: LD_INT 0
44658: PUSH
44659: LD_INT 1
44661: NEG
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 1
44669: PUSH
44670: LD_INT 0
44672: PUSH
44673: EMPTY
44674: LIST
44675: LIST
44676: PUSH
44677: LD_INT 1
44679: PUSH
44680: LD_INT 1
44682: PUSH
44683: EMPTY
44684: LIST
44685: LIST
44686: PUSH
44687: LD_INT 0
44689: PUSH
44690: LD_INT 1
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: PUSH
44697: LD_INT 1
44699: NEG
44700: PUSH
44701: LD_INT 0
44703: PUSH
44704: EMPTY
44705: LIST
44706: LIST
44707: PUSH
44708: LD_INT 1
44710: NEG
44711: PUSH
44712: LD_INT 1
44714: NEG
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 1
44722: NEG
44723: PUSH
44724: LD_INT 2
44726: NEG
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PUSH
44732: LD_INT 0
44734: PUSH
44735: LD_INT 2
44737: NEG
44738: PUSH
44739: EMPTY
44740: LIST
44741: LIST
44742: PUSH
44743: LD_INT 1
44745: PUSH
44746: LD_INT 1
44748: NEG
44749: PUSH
44750: EMPTY
44751: LIST
44752: LIST
44753: PUSH
44754: LD_INT 2
44756: PUSH
44757: LD_INT 0
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PUSH
44764: LD_INT 2
44766: PUSH
44767: LD_INT 1
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: LD_INT 2
44776: PUSH
44777: LD_INT 2
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: PUSH
44784: LD_INT 1
44786: PUSH
44787: LD_INT 2
44789: PUSH
44790: EMPTY
44791: LIST
44792: LIST
44793: PUSH
44794: LD_INT 0
44796: PUSH
44797: LD_INT 2
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: PUSH
44804: LD_INT 1
44806: NEG
44807: PUSH
44808: LD_INT 1
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: PUSH
44815: LD_INT 2
44817: NEG
44818: PUSH
44819: LD_INT 0
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 2
44828: NEG
44829: PUSH
44830: LD_INT 1
44832: NEG
44833: PUSH
44834: EMPTY
44835: LIST
44836: LIST
44837: PUSH
44838: LD_INT 2
44840: NEG
44841: PUSH
44842: LD_INT 2
44844: NEG
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: EMPTY
44851: LIST
44852: LIST
44853: LIST
44854: LIST
44855: LIST
44856: LIST
44857: LIST
44858: LIST
44859: LIST
44860: LIST
44861: LIST
44862: LIST
44863: LIST
44864: LIST
44865: LIST
44866: LIST
44867: LIST
44868: LIST
44869: LIST
44870: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44871: LD_ADDR_VAR 0 55
44875: PUSH
44876: LD_INT 0
44878: PUSH
44879: LD_INT 0
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: LD_INT 1
44891: NEG
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: LD_INT 1
44899: PUSH
44900: LD_INT 0
44902: PUSH
44903: EMPTY
44904: LIST
44905: LIST
44906: PUSH
44907: LD_INT 1
44909: PUSH
44910: LD_INT 1
44912: PUSH
44913: EMPTY
44914: LIST
44915: LIST
44916: PUSH
44917: LD_INT 0
44919: PUSH
44920: LD_INT 1
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: PUSH
44927: LD_INT 1
44929: NEG
44930: PUSH
44931: LD_INT 0
44933: PUSH
44934: EMPTY
44935: LIST
44936: LIST
44937: PUSH
44938: LD_INT 1
44940: NEG
44941: PUSH
44942: LD_INT 1
44944: NEG
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 1
44952: NEG
44953: PUSH
44954: LD_INT 2
44956: NEG
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: PUSH
44962: LD_INT 0
44964: PUSH
44965: LD_INT 2
44967: NEG
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_INT 1
44975: PUSH
44976: LD_INT 1
44978: NEG
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: PUSH
44984: LD_INT 2
44986: PUSH
44987: LD_INT 0
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PUSH
44994: LD_INT 2
44996: PUSH
44997: LD_INT 1
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: PUSH
45004: LD_INT 2
45006: PUSH
45007: LD_INT 2
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 1
45016: PUSH
45017: LD_INT 2
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 0
45026: PUSH
45027: LD_INT 2
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 1
45036: NEG
45037: PUSH
45038: LD_INT 1
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: LD_INT 2
45047: NEG
45048: PUSH
45049: LD_INT 0
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 2
45058: NEG
45059: PUSH
45060: LD_INT 1
45062: NEG
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: PUSH
45068: LD_INT 2
45070: NEG
45071: PUSH
45072: LD_INT 2
45074: NEG
45075: PUSH
45076: EMPTY
45077: LIST
45078: LIST
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: LIST
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: LIST
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: LIST
45098: LIST
45099: LIST
45100: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45101: LD_ADDR_VAR 0 56
45105: PUSH
45106: LD_INT 0
45108: PUSH
45109: LD_INT 0
45111: PUSH
45112: EMPTY
45113: LIST
45114: LIST
45115: PUSH
45116: LD_INT 0
45118: PUSH
45119: LD_INT 1
45121: NEG
45122: PUSH
45123: EMPTY
45124: LIST
45125: LIST
45126: PUSH
45127: LD_INT 1
45129: PUSH
45130: LD_INT 0
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 1
45139: PUSH
45140: LD_INT 1
45142: PUSH
45143: EMPTY
45144: LIST
45145: LIST
45146: PUSH
45147: LD_INT 0
45149: PUSH
45150: LD_INT 1
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 1
45159: NEG
45160: PUSH
45161: LD_INT 0
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: PUSH
45168: LD_INT 1
45170: NEG
45171: PUSH
45172: LD_INT 1
45174: NEG
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 1
45182: NEG
45183: PUSH
45184: LD_INT 2
45186: NEG
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: LD_INT 0
45194: PUSH
45195: LD_INT 2
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 1
45205: PUSH
45206: LD_INT 1
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 2
45216: PUSH
45217: LD_INT 0
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 2
45226: PUSH
45227: LD_INT 1
45229: PUSH
45230: EMPTY
45231: LIST
45232: LIST
45233: PUSH
45234: LD_INT 2
45236: PUSH
45237: LD_INT 2
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PUSH
45244: LD_INT 1
45246: PUSH
45247: LD_INT 2
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: PUSH
45254: LD_INT 0
45256: PUSH
45257: LD_INT 2
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 1
45266: NEG
45267: PUSH
45268: LD_INT 1
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: LD_INT 2
45277: NEG
45278: PUSH
45279: LD_INT 0
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 2
45288: NEG
45289: PUSH
45290: LD_INT 1
45292: NEG
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PUSH
45298: LD_INT 2
45300: NEG
45301: PUSH
45302: LD_INT 2
45304: NEG
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45331: LD_ADDR_VAR 0 57
45335: PUSH
45336: LD_INT 0
45338: PUSH
45339: LD_INT 0
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: PUSH
45346: LD_INT 0
45348: PUSH
45349: LD_INT 1
45351: NEG
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 1
45359: PUSH
45360: LD_INT 0
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PUSH
45367: LD_INT 1
45369: PUSH
45370: LD_INT 1
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 0
45379: PUSH
45380: LD_INT 1
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 1
45389: NEG
45390: PUSH
45391: LD_INT 0
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: LD_INT 1
45400: NEG
45401: PUSH
45402: LD_INT 1
45404: NEG
45405: PUSH
45406: EMPTY
45407: LIST
45408: LIST
45409: PUSH
45410: LD_INT 1
45412: NEG
45413: PUSH
45414: LD_INT 2
45416: NEG
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 0
45424: PUSH
45425: LD_INT 2
45427: NEG
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 1
45435: PUSH
45436: LD_INT 1
45438: NEG
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: PUSH
45444: LD_INT 2
45446: PUSH
45447: LD_INT 0
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: LD_INT 2
45456: PUSH
45457: LD_INT 1
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: LD_INT 2
45466: PUSH
45467: LD_INT 2
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: PUSH
45474: LD_INT 1
45476: PUSH
45477: LD_INT 2
45479: PUSH
45480: EMPTY
45481: LIST
45482: LIST
45483: PUSH
45484: LD_INT 0
45486: PUSH
45487: LD_INT 2
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: PUSH
45494: LD_INT 1
45496: NEG
45497: PUSH
45498: LD_INT 1
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: PUSH
45505: LD_INT 2
45507: NEG
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: EMPTY
45513: LIST
45514: LIST
45515: PUSH
45516: LD_INT 2
45518: NEG
45519: PUSH
45520: LD_INT 1
45522: NEG
45523: PUSH
45524: EMPTY
45525: LIST
45526: LIST
45527: PUSH
45528: LD_INT 2
45530: NEG
45531: PUSH
45532: LD_INT 2
45534: NEG
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: EMPTY
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: LIST
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45561: LD_ADDR_VAR 0 58
45565: PUSH
45566: LD_INT 0
45568: PUSH
45569: LD_INT 0
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 0
45578: PUSH
45579: LD_INT 1
45581: NEG
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: PUSH
45587: LD_INT 1
45589: PUSH
45590: LD_INT 0
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 1
45599: PUSH
45600: LD_INT 1
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: PUSH
45607: LD_INT 0
45609: PUSH
45610: LD_INT 1
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: PUSH
45617: LD_INT 1
45619: NEG
45620: PUSH
45621: LD_INT 0
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 1
45630: NEG
45631: PUSH
45632: LD_INT 1
45634: NEG
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: PUSH
45640: LD_INT 1
45642: NEG
45643: PUSH
45644: LD_INT 2
45646: NEG
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 0
45654: PUSH
45655: LD_INT 2
45657: NEG
45658: PUSH
45659: EMPTY
45660: LIST
45661: LIST
45662: PUSH
45663: LD_INT 1
45665: PUSH
45666: LD_INT 1
45668: NEG
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 2
45676: PUSH
45677: LD_INT 0
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: PUSH
45684: LD_INT 2
45686: PUSH
45687: LD_INT 1
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: PUSH
45694: LD_INT 2
45696: PUSH
45697: LD_INT 2
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: PUSH
45704: LD_INT 1
45706: PUSH
45707: LD_INT 2
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: LD_INT 0
45716: PUSH
45717: LD_INT 2
45719: PUSH
45720: EMPTY
45721: LIST
45722: LIST
45723: PUSH
45724: LD_INT 1
45726: NEG
45727: PUSH
45728: LD_INT 1
45730: PUSH
45731: EMPTY
45732: LIST
45733: LIST
45734: PUSH
45735: LD_INT 2
45737: NEG
45738: PUSH
45739: LD_INT 0
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: PUSH
45746: LD_INT 2
45748: NEG
45749: PUSH
45750: LD_INT 1
45752: NEG
45753: PUSH
45754: EMPTY
45755: LIST
45756: LIST
45757: PUSH
45758: LD_INT 2
45760: NEG
45761: PUSH
45762: LD_INT 2
45764: NEG
45765: PUSH
45766: EMPTY
45767: LIST
45768: LIST
45769: PUSH
45770: EMPTY
45771: LIST
45772: LIST
45773: LIST
45774: LIST
45775: LIST
45776: LIST
45777: LIST
45778: LIST
45779: LIST
45780: LIST
45781: LIST
45782: LIST
45783: LIST
45784: LIST
45785: LIST
45786: LIST
45787: LIST
45788: LIST
45789: LIST
45790: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45791: LD_ADDR_VAR 0 59
45795: PUSH
45796: LD_INT 0
45798: PUSH
45799: LD_INT 0
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 0
45808: PUSH
45809: LD_INT 1
45811: NEG
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 1
45819: PUSH
45820: LD_INT 0
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 1
45829: PUSH
45830: LD_INT 1
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: PUSH
45837: LD_INT 0
45839: PUSH
45840: LD_INT 1
45842: PUSH
45843: EMPTY
45844: LIST
45845: LIST
45846: PUSH
45847: LD_INT 1
45849: NEG
45850: PUSH
45851: LD_INT 0
45853: PUSH
45854: EMPTY
45855: LIST
45856: LIST
45857: PUSH
45858: LD_INT 1
45860: NEG
45861: PUSH
45862: LD_INT 1
45864: NEG
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45879: LD_ADDR_VAR 0 60
45883: PUSH
45884: LD_INT 0
45886: PUSH
45887: LD_INT 0
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 0
45896: PUSH
45897: LD_INT 1
45899: NEG
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PUSH
45905: LD_INT 1
45907: PUSH
45908: LD_INT 0
45910: PUSH
45911: EMPTY
45912: LIST
45913: LIST
45914: PUSH
45915: LD_INT 1
45917: PUSH
45918: LD_INT 1
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: PUSH
45925: LD_INT 0
45927: PUSH
45928: LD_INT 1
45930: PUSH
45931: EMPTY
45932: LIST
45933: LIST
45934: PUSH
45935: LD_INT 1
45937: NEG
45938: PUSH
45939: LD_INT 0
45941: PUSH
45942: EMPTY
45943: LIST
45944: LIST
45945: PUSH
45946: LD_INT 1
45948: NEG
45949: PUSH
45950: LD_INT 1
45952: NEG
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45967: LD_ADDR_VAR 0 61
45971: PUSH
45972: LD_INT 0
45974: PUSH
45975: LD_INT 0
45977: PUSH
45978: EMPTY
45979: LIST
45980: LIST
45981: PUSH
45982: LD_INT 0
45984: PUSH
45985: LD_INT 1
45987: NEG
45988: PUSH
45989: EMPTY
45990: LIST
45991: LIST
45992: PUSH
45993: LD_INT 1
45995: PUSH
45996: LD_INT 0
45998: PUSH
45999: EMPTY
46000: LIST
46001: LIST
46002: PUSH
46003: LD_INT 1
46005: PUSH
46006: LD_INT 1
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: LD_INT 0
46015: PUSH
46016: LD_INT 1
46018: PUSH
46019: EMPTY
46020: LIST
46021: LIST
46022: PUSH
46023: LD_INT 1
46025: NEG
46026: PUSH
46027: LD_INT 0
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: PUSH
46034: LD_INT 1
46036: NEG
46037: PUSH
46038: LD_INT 1
46040: NEG
46041: PUSH
46042: EMPTY
46043: LIST
46044: LIST
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: LIST
46052: LIST
46053: LIST
46054: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
46055: LD_ADDR_VAR 0 62
46059: PUSH
46060: LD_INT 0
46062: PUSH
46063: LD_INT 0
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 0
46072: PUSH
46073: LD_INT 1
46075: NEG
46076: PUSH
46077: EMPTY
46078: LIST
46079: LIST
46080: PUSH
46081: LD_INT 1
46083: PUSH
46084: LD_INT 0
46086: PUSH
46087: EMPTY
46088: LIST
46089: LIST
46090: PUSH
46091: LD_INT 1
46093: PUSH
46094: LD_INT 1
46096: PUSH
46097: EMPTY
46098: LIST
46099: LIST
46100: PUSH
46101: LD_INT 0
46103: PUSH
46104: LD_INT 1
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 1
46113: NEG
46114: PUSH
46115: LD_INT 0
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: LD_INT 1
46124: NEG
46125: PUSH
46126: LD_INT 1
46128: NEG
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
46143: LD_ADDR_VAR 0 63
46147: PUSH
46148: LD_INT 0
46150: PUSH
46151: LD_INT 0
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: PUSH
46158: LD_INT 0
46160: PUSH
46161: LD_INT 1
46163: NEG
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 1
46171: PUSH
46172: LD_INT 0
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 1
46181: PUSH
46182: LD_INT 1
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PUSH
46189: LD_INT 0
46191: PUSH
46192: LD_INT 1
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 1
46201: NEG
46202: PUSH
46203: LD_INT 0
46205: PUSH
46206: EMPTY
46207: LIST
46208: LIST
46209: PUSH
46210: LD_INT 1
46212: NEG
46213: PUSH
46214: LD_INT 1
46216: NEG
46217: PUSH
46218: EMPTY
46219: LIST
46220: LIST
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: LIST
46229: LIST
46230: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
46231: LD_ADDR_VAR 0 64
46235: PUSH
46236: LD_INT 0
46238: PUSH
46239: LD_INT 0
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 0
46248: PUSH
46249: LD_INT 1
46251: NEG
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: LD_INT 1
46259: PUSH
46260: LD_INT 0
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 1
46269: PUSH
46270: LD_INT 1
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: PUSH
46277: LD_INT 0
46279: PUSH
46280: LD_INT 1
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 1
46289: NEG
46290: PUSH
46291: LD_INT 0
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: LD_INT 1
46300: NEG
46301: PUSH
46302: LD_INT 1
46304: NEG
46305: PUSH
46306: EMPTY
46307: LIST
46308: LIST
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: ST_TO_ADDR
// end ; 1 :
46319: GO 52216
46321: LD_INT 1
46323: DOUBLE
46324: EQUAL
46325: IFTRUE 46329
46327: GO 48952
46329: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46330: LD_ADDR_VAR 0 11
46334: PUSH
46335: LD_INT 1
46337: NEG
46338: PUSH
46339: LD_INT 3
46341: NEG
46342: PUSH
46343: EMPTY
46344: LIST
46345: LIST
46346: PUSH
46347: LD_INT 0
46349: PUSH
46350: LD_INT 3
46352: NEG
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: PUSH
46358: LD_INT 1
46360: PUSH
46361: LD_INT 2
46363: NEG
46364: PUSH
46365: EMPTY
46366: LIST
46367: LIST
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: LIST
46373: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46374: LD_ADDR_VAR 0 12
46378: PUSH
46379: LD_INT 2
46381: PUSH
46382: LD_INT 1
46384: NEG
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 3
46392: PUSH
46393: LD_INT 0
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: PUSH
46400: LD_INT 3
46402: PUSH
46403: LD_INT 1
46405: PUSH
46406: EMPTY
46407: LIST
46408: LIST
46409: PUSH
46410: EMPTY
46411: LIST
46412: LIST
46413: LIST
46414: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46415: LD_ADDR_VAR 0 13
46419: PUSH
46420: LD_INT 3
46422: PUSH
46423: LD_INT 2
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 3
46432: PUSH
46433: LD_INT 3
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: PUSH
46440: LD_INT 2
46442: PUSH
46443: LD_INT 3
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: EMPTY
46451: LIST
46452: LIST
46453: LIST
46454: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46455: LD_ADDR_VAR 0 14
46459: PUSH
46460: LD_INT 1
46462: PUSH
46463: LD_INT 3
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 0
46472: PUSH
46473: LD_INT 3
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: PUSH
46480: LD_INT 1
46482: NEG
46483: PUSH
46484: LD_INT 2
46486: PUSH
46487: EMPTY
46488: LIST
46489: LIST
46490: PUSH
46491: EMPTY
46492: LIST
46493: LIST
46494: LIST
46495: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46496: LD_ADDR_VAR 0 15
46500: PUSH
46501: LD_INT 2
46503: NEG
46504: PUSH
46505: LD_INT 1
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: LD_INT 3
46514: NEG
46515: PUSH
46516: LD_INT 0
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 3
46525: NEG
46526: PUSH
46527: LD_INT 1
46529: NEG
46530: PUSH
46531: EMPTY
46532: LIST
46533: LIST
46534: PUSH
46535: EMPTY
46536: LIST
46537: LIST
46538: LIST
46539: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46540: LD_ADDR_VAR 0 16
46544: PUSH
46545: LD_INT 2
46547: NEG
46548: PUSH
46549: LD_INT 3
46551: NEG
46552: PUSH
46553: EMPTY
46554: LIST
46555: LIST
46556: PUSH
46557: LD_INT 3
46559: NEG
46560: PUSH
46561: LD_INT 2
46563: NEG
46564: PUSH
46565: EMPTY
46566: LIST
46567: LIST
46568: PUSH
46569: LD_INT 3
46571: NEG
46572: PUSH
46573: LD_INT 3
46575: NEG
46576: PUSH
46577: EMPTY
46578: LIST
46579: LIST
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: LIST
46585: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46586: LD_ADDR_VAR 0 17
46590: PUSH
46591: LD_INT 1
46593: NEG
46594: PUSH
46595: LD_INT 3
46597: NEG
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 0
46605: PUSH
46606: LD_INT 3
46608: NEG
46609: PUSH
46610: EMPTY
46611: LIST
46612: LIST
46613: PUSH
46614: LD_INT 1
46616: PUSH
46617: LD_INT 2
46619: NEG
46620: PUSH
46621: EMPTY
46622: LIST
46623: LIST
46624: PUSH
46625: EMPTY
46626: LIST
46627: LIST
46628: LIST
46629: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46630: LD_ADDR_VAR 0 18
46634: PUSH
46635: LD_INT 2
46637: PUSH
46638: LD_INT 1
46640: NEG
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 3
46648: PUSH
46649: LD_INT 0
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 3
46658: PUSH
46659: LD_INT 1
46661: PUSH
46662: EMPTY
46663: LIST
46664: LIST
46665: PUSH
46666: EMPTY
46667: LIST
46668: LIST
46669: LIST
46670: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46671: LD_ADDR_VAR 0 19
46675: PUSH
46676: LD_INT 3
46678: PUSH
46679: LD_INT 2
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: PUSH
46686: LD_INT 3
46688: PUSH
46689: LD_INT 3
46691: PUSH
46692: EMPTY
46693: LIST
46694: LIST
46695: PUSH
46696: LD_INT 2
46698: PUSH
46699: LD_INT 3
46701: PUSH
46702: EMPTY
46703: LIST
46704: LIST
46705: PUSH
46706: EMPTY
46707: LIST
46708: LIST
46709: LIST
46710: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46711: LD_ADDR_VAR 0 20
46715: PUSH
46716: LD_INT 1
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: EMPTY
46723: LIST
46724: LIST
46725: PUSH
46726: LD_INT 0
46728: PUSH
46729: LD_INT 3
46731: PUSH
46732: EMPTY
46733: LIST
46734: LIST
46735: PUSH
46736: LD_INT 1
46738: NEG
46739: PUSH
46740: LD_INT 2
46742: PUSH
46743: EMPTY
46744: LIST
46745: LIST
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: LIST
46751: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46752: LD_ADDR_VAR 0 21
46756: PUSH
46757: LD_INT 2
46759: NEG
46760: PUSH
46761: LD_INT 1
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: PUSH
46768: LD_INT 3
46770: NEG
46771: PUSH
46772: LD_INT 0
46774: PUSH
46775: EMPTY
46776: LIST
46777: LIST
46778: PUSH
46779: LD_INT 3
46781: NEG
46782: PUSH
46783: LD_INT 1
46785: NEG
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: LIST
46795: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46796: LD_ADDR_VAR 0 22
46800: PUSH
46801: LD_INT 2
46803: NEG
46804: PUSH
46805: LD_INT 3
46807: NEG
46808: PUSH
46809: EMPTY
46810: LIST
46811: LIST
46812: PUSH
46813: LD_INT 3
46815: NEG
46816: PUSH
46817: LD_INT 2
46819: NEG
46820: PUSH
46821: EMPTY
46822: LIST
46823: LIST
46824: PUSH
46825: LD_INT 3
46827: NEG
46828: PUSH
46829: LD_INT 3
46831: NEG
46832: PUSH
46833: EMPTY
46834: LIST
46835: LIST
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: LIST
46841: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46842: LD_ADDR_VAR 0 23
46846: PUSH
46847: LD_INT 0
46849: PUSH
46850: LD_INT 3
46852: NEG
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 1
46860: NEG
46861: PUSH
46862: LD_INT 4
46864: NEG
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: PUSH
46870: LD_INT 1
46872: PUSH
46873: LD_INT 3
46875: NEG
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: LIST
46885: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46886: LD_ADDR_VAR 0 24
46890: PUSH
46891: LD_INT 3
46893: PUSH
46894: LD_INT 0
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PUSH
46901: LD_INT 3
46903: PUSH
46904: LD_INT 1
46906: NEG
46907: PUSH
46908: EMPTY
46909: LIST
46910: LIST
46911: PUSH
46912: LD_INT 4
46914: PUSH
46915: LD_INT 1
46917: PUSH
46918: EMPTY
46919: LIST
46920: LIST
46921: PUSH
46922: EMPTY
46923: LIST
46924: LIST
46925: LIST
46926: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46927: LD_ADDR_VAR 0 25
46931: PUSH
46932: LD_INT 3
46934: PUSH
46935: LD_INT 3
46937: PUSH
46938: EMPTY
46939: LIST
46940: LIST
46941: PUSH
46942: LD_INT 4
46944: PUSH
46945: LD_INT 3
46947: PUSH
46948: EMPTY
46949: LIST
46950: LIST
46951: PUSH
46952: LD_INT 3
46954: PUSH
46955: LD_INT 4
46957: PUSH
46958: EMPTY
46959: LIST
46960: LIST
46961: PUSH
46962: EMPTY
46963: LIST
46964: LIST
46965: LIST
46966: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46967: LD_ADDR_VAR 0 26
46971: PUSH
46972: LD_INT 0
46974: PUSH
46975: LD_INT 3
46977: PUSH
46978: EMPTY
46979: LIST
46980: LIST
46981: PUSH
46982: LD_INT 1
46984: PUSH
46985: LD_INT 4
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: PUSH
46992: LD_INT 1
46994: NEG
46995: PUSH
46996: LD_INT 3
46998: PUSH
46999: EMPTY
47000: LIST
47001: LIST
47002: PUSH
47003: EMPTY
47004: LIST
47005: LIST
47006: LIST
47007: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
47008: LD_ADDR_VAR 0 27
47012: PUSH
47013: LD_INT 3
47015: NEG
47016: PUSH
47017: LD_INT 0
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: LD_INT 3
47026: NEG
47027: PUSH
47028: LD_INT 1
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: PUSH
47035: LD_INT 4
47037: NEG
47038: PUSH
47039: LD_INT 1
47041: NEG
47042: PUSH
47043: EMPTY
47044: LIST
47045: LIST
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: LIST
47051: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
47052: LD_ADDR_VAR 0 28
47056: PUSH
47057: LD_INT 3
47059: NEG
47060: PUSH
47061: LD_INT 3
47063: NEG
47064: PUSH
47065: EMPTY
47066: LIST
47067: LIST
47068: PUSH
47069: LD_INT 3
47071: NEG
47072: PUSH
47073: LD_INT 4
47075: NEG
47076: PUSH
47077: EMPTY
47078: LIST
47079: LIST
47080: PUSH
47081: LD_INT 4
47083: NEG
47084: PUSH
47085: LD_INT 3
47087: NEG
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: LIST
47097: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
47098: LD_ADDR_VAR 0 29
47102: PUSH
47103: LD_INT 1
47105: NEG
47106: PUSH
47107: LD_INT 3
47109: NEG
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: PUSH
47115: LD_INT 0
47117: PUSH
47118: LD_INT 3
47120: NEG
47121: PUSH
47122: EMPTY
47123: LIST
47124: LIST
47125: PUSH
47126: LD_INT 1
47128: PUSH
47129: LD_INT 2
47131: NEG
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PUSH
47137: LD_INT 1
47139: NEG
47140: PUSH
47141: LD_INT 4
47143: NEG
47144: PUSH
47145: EMPTY
47146: LIST
47147: LIST
47148: PUSH
47149: LD_INT 0
47151: PUSH
47152: LD_INT 4
47154: NEG
47155: PUSH
47156: EMPTY
47157: LIST
47158: LIST
47159: PUSH
47160: LD_INT 1
47162: PUSH
47163: LD_INT 3
47165: NEG
47166: PUSH
47167: EMPTY
47168: LIST
47169: LIST
47170: PUSH
47171: LD_INT 1
47173: NEG
47174: PUSH
47175: LD_INT 5
47177: NEG
47178: PUSH
47179: EMPTY
47180: LIST
47181: LIST
47182: PUSH
47183: LD_INT 0
47185: PUSH
47186: LD_INT 5
47188: NEG
47189: PUSH
47190: EMPTY
47191: LIST
47192: LIST
47193: PUSH
47194: LD_INT 1
47196: PUSH
47197: LD_INT 4
47199: NEG
47200: PUSH
47201: EMPTY
47202: LIST
47203: LIST
47204: PUSH
47205: LD_INT 1
47207: NEG
47208: PUSH
47209: LD_INT 6
47211: NEG
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: PUSH
47217: LD_INT 0
47219: PUSH
47220: LD_INT 6
47222: NEG
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 1
47230: PUSH
47231: LD_INT 5
47233: NEG
47234: PUSH
47235: EMPTY
47236: LIST
47237: LIST
47238: PUSH
47239: EMPTY
47240: LIST
47241: LIST
47242: LIST
47243: LIST
47244: LIST
47245: LIST
47246: LIST
47247: LIST
47248: LIST
47249: LIST
47250: LIST
47251: LIST
47252: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
47253: LD_ADDR_VAR 0 30
47257: PUSH
47258: LD_INT 2
47260: PUSH
47261: LD_INT 1
47263: NEG
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PUSH
47269: LD_INT 3
47271: PUSH
47272: LD_INT 0
47274: PUSH
47275: EMPTY
47276: LIST
47277: LIST
47278: PUSH
47279: LD_INT 3
47281: PUSH
47282: LD_INT 1
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: LD_INT 3
47291: PUSH
47292: LD_INT 1
47294: NEG
47295: PUSH
47296: EMPTY
47297: LIST
47298: LIST
47299: PUSH
47300: LD_INT 4
47302: PUSH
47303: LD_INT 0
47305: PUSH
47306: EMPTY
47307: LIST
47308: LIST
47309: PUSH
47310: LD_INT 4
47312: PUSH
47313: LD_INT 1
47315: PUSH
47316: EMPTY
47317: LIST
47318: LIST
47319: PUSH
47320: LD_INT 4
47322: PUSH
47323: LD_INT 1
47325: NEG
47326: PUSH
47327: EMPTY
47328: LIST
47329: LIST
47330: PUSH
47331: LD_INT 5
47333: PUSH
47334: LD_INT 0
47336: PUSH
47337: EMPTY
47338: LIST
47339: LIST
47340: PUSH
47341: LD_INT 5
47343: PUSH
47344: LD_INT 1
47346: PUSH
47347: EMPTY
47348: LIST
47349: LIST
47350: PUSH
47351: LD_INT 5
47353: PUSH
47354: LD_INT 1
47356: NEG
47357: PUSH
47358: EMPTY
47359: LIST
47360: LIST
47361: PUSH
47362: LD_INT 6
47364: PUSH
47365: LD_INT 0
47367: PUSH
47368: EMPTY
47369: LIST
47370: LIST
47371: PUSH
47372: LD_INT 6
47374: PUSH
47375: LD_INT 1
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: PUSH
47382: EMPTY
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
47396: LD_ADDR_VAR 0 31
47400: PUSH
47401: LD_INT 3
47403: PUSH
47404: LD_INT 2
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: PUSH
47411: LD_INT 3
47413: PUSH
47414: LD_INT 3
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: LD_INT 2
47423: PUSH
47424: LD_INT 3
47426: PUSH
47427: EMPTY
47428: LIST
47429: LIST
47430: PUSH
47431: LD_INT 4
47433: PUSH
47434: LD_INT 3
47436: PUSH
47437: EMPTY
47438: LIST
47439: LIST
47440: PUSH
47441: LD_INT 4
47443: PUSH
47444: LD_INT 4
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: PUSH
47451: LD_INT 3
47453: PUSH
47454: LD_INT 4
47456: PUSH
47457: EMPTY
47458: LIST
47459: LIST
47460: PUSH
47461: LD_INT 5
47463: PUSH
47464: LD_INT 4
47466: PUSH
47467: EMPTY
47468: LIST
47469: LIST
47470: PUSH
47471: LD_INT 5
47473: PUSH
47474: LD_INT 5
47476: PUSH
47477: EMPTY
47478: LIST
47479: LIST
47480: PUSH
47481: LD_INT 4
47483: PUSH
47484: LD_INT 5
47486: PUSH
47487: EMPTY
47488: LIST
47489: LIST
47490: PUSH
47491: LD_INT 6
47493: PUSH
47494: LD_INT 5
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: PUSH
47501: LD_INT 6
47503: PUSH
47504: LD_INT 6
47506: PUSH
47507: EMPTY
47508: LIST
47509: LIST
47510: PUSH
47511: LD_INT 5
47513: PUSH
47514: LD_INT 6
47516: PUSH
47517: EMPTY
47518: LIST
47519: LIST
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: LIST
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: LIST
47530: LIST
47531: LIST
47532: LIST
47533: LIST
47534: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
47535: LD_ADDR_VAR 0 32
47539: PUSH
47540: LD_INT 1
47542: PUSH
47543: LD_INT 3
47545: PUSH
47546: EMPTY
47547: LIST
47548: LIST
47549: PUSH
47550: LD_INT 0
47552: PUSH
47553: LD_INT 3
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: PUSH
47560: LD_INT 1
47562: NEG
47563: PUSH
47564: LD_INT 2
47566: PUSH
47567: EMPTY
47568: LIST
47569: LIST
47570: PUSH
47571: LD_INT 1
47573: PUSH
47574: LD_INT 4
47576: PUSH
47577: EMPTY
47578: LIST
47579: LIST
47580: PUSH
47581: LD_INT 0
47583: PUSH
47584: LD_INT 4
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PUSH
47591: LD_INT 1
47593: NEG
47594: PUSH
47595: LD_INT 3
47597: PUSH
47598: EMPTY
47599: LIST
47600: LIST
47601: PUSH
47602: LD_INT 1
47604: PUSH
47605: LD_INT 5
47607: PUSH
47608: EMPTY
47609: LIST
47610: LIST
47611: PUSH
47612: LD_INT 0
47614: PUSH
47615: LD_INT 5
47617: PUSH
47618: EMPTY
47619: LIST
47620: LIST
47621: PUSH
47622: LD_INT 1
47624: NEG
47625: PUSH
47626: LD_INT 4
47628: PUSH
47629: EMPTY
47630: LIST
47631: LIST
47632: PUSH
47633: LD_INT 1
47635: PUSH
47636: LD_INT 6
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: PUSH
47643: LD_INT 0
47645: PUSH
47646: LD_INT 6
47648: PUSH
47649: EMPTY
47650: LIST
47651: LIST
47652: PUSH
47653: LD_INT 1
47655: NEG
47656: PUSH
47657: LD_INT 5
47659: PUSH
47660: EMPTY
47661: LIST
47662: LIST
47663: PUSH
47664: EMPTY
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: LIST
47671: LIST
47672: LIST
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
47678: LD_ADDR_VAR 0 33
47682: PUSH
47683: LD_INT 2
47685: NEG
47686: PUSH
47687: LD_INT 1
47689: PUSH
47690: EMPTY
47691: LIST
47692: LIST
47693: PUSH
47694: LD_INT 3
47696: NEG
47697: PUSH
47698: LD_INT 0
47700: PUSH
47701: EMPTY
47702: LIST
47703: LIST
47704: PUSH
47705: LD_INT 3
47707: NEG
47708: PUSH
47709: LD_INT 1
47711: NEG
47712: PUSH
47713: EMPTY
47714: LIST
47715: LIST
47716: PUSH
47717: LD_INT 3
47719: NEG
47720: PUSH
47721: LD_INT 1
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: PUSH
47728: LD_INT 4
47730: NEG
47731: PUSH
47732: LD_INT 0
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PUSH
47739: LD_INT 4
47741: NEG
47742: PUSH
47743: LD_INT 1
47745: NEG
47746: PUSH
47747: EMPTY
47748: LIST
47749: LIST
47750: PUSH
47751: LD_INT 4
47753: NEG
47754: PUSH
47755: LD_INT 1
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: PUSH
47762: LD_INT 5
47764: NEG
47765: PUSH
47766: LD_INT 0
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 5
47775: NEG
47776: PUSH
47777: LD_INT 1
47779: NEG
47780: PUSH
47781: EMPTY
47782: LIST
47783: LIST
47784: PUSH
47785: LD_INT 5
47787: NEG
47788: PUSH
47789: LD_INT 1
47791: PUSH
47792: EMPTY
47793: LIST
47794: LIST
47795: PUSH
47796: LD_INT 6
47798: NEG
47799: PUSH
47800: LD_INT 0
47802: PUSH
47803: EMPTY
47804: LIST
47805: LIST
47806: PUSH
47807: LD_INT 6
47809: NEG
47810: PUSH
47811: LD_INT 1
47813: NEG
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47833: LD_ADDR_VAR 0 34
47837: PUSH
47838: LD_INT 2
47840: NEG
47841: PUSH
47842: LD_INT 3
47844: NEG
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: PUSH
47850: LD_INT 3
47852: NEG
47853: PUSH
47854: LD_INT 2
47856: NEG
47857: PUSH
47858: EMPTY
47859: LIST
47860: LIST
47861: PUSH
47862: LD_INT 3
47864: NEG
47865: PUSH
47866: LD_INT 3
47868: NEG
47869: PUSH
47870: EMPTY
47871: LIST
47872: LIST
47873: PUSH
47874: LD_INT 3
47876: NEG
47877: PUSH
47878: LD_INT 4
47880: NEG
47881: PUSH
47882: EMPTY
47883: LIST
47884: LIST
47885: PUSH
47886: LD_INT 4
47888: NEG
47889: PUSH
47890: LD_INT 3
47892: NEG
47893: PUSH
47894: EMPTY
47895: LIST
47896: LIST
47897: PUSH
47898: LD_INT 4
47900: NEG
47901: PUSH
47902: LD_INT 4
47904: NEG
47905: PUSH
47906: EMPTY
47907: LIST
47908: LIST
47909: PUSH
47910: LD_INT 4
47912: NEG
47913: PUSH
47914: LD_INT 5
47916: NEG
47917: PUSH
47918: EMPTY
47919: LIST
47920: LIST
47921: PUSH
47922: LD_INT 5
47924: NEG
47925: PUSH
47926: LD_INT 4
47928: NEG
47929: PUSH
47930: EMPTY
47931: LIST
47932: LIST
47933: PUSH
47934: LD_INT 5
47936: NEG
47937: PUSH
47938: LD_INT 5
47940: NEG
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: PUSH
47946: LD_INT 5
47948: NEG
47949: PUSH
47950: LD_INT 6
47952: NEG
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PUSH
47958: LD_INT 6
47960: NEG
47961: PUSH
47962: LD_INT 5
47964: NEG
47965: PUSH
47966: EMPTY
47967: LIST
47968: LIST
47969: PUSH
47970: LD_INT 6
47972: NEG
47973: PUSH
47974: LD_INT 6
47976: NEG
47977: PUSH
47978: EMPTY
47979: LIST
47980: LIST
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47996: LD_ADDR_VAR 0 41
48000: PUSH
48001: LD_INT 0
48003: PUSH
48004: LD_INT 2
48006: NEG
48007: PUSH
48008: EMPTY
48009: LIST
48010: LIST
48011: PUSH
48012: LD_INT 1
48014: NEG
48015: PUSH
48016: LD_INT 3
48018: NEG
48019: PUSH
48020: EMPTY
48021: LIST
48022: LIST
48023: PUSH
48024: LD_INT 1
48026: PUSH
48027: LD_INT 2
48029: NEG
48030: PUSH
48031: EMPTY
48032: LIST
48033: LIST
48034: PUSH
48035: EMPTY
48036: LIST
48037: LIST
48038: LIST
48039: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
48040: LD_ADDR_VAR 0 42
48044: PUSH
48045: LD_INT 2
48047: PUSH
48048: LD_INT 0
48050: PUSH
48051: EMPTY
48052: LIST
48053: LIST
48054: PUSH
48055: LD_INT 2
48057: PUSH
48058: LD_INT 1
48060: NEG
48061: PUSH
48062: EMPTY
48063: LIST
48064: LIST
48065: PUSH
48066: LD_INT 3
48068: PUSH
48069: LD_INT 1
48071: PUSH
48072: EMPTY
48073: LIST
48074: LIST
48075: PUSH
48076: EMPTY
48077: LIST
48078: LIST
48079: LIST
48080: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
48081: LD_ADDR_VAR 0 43
48085: PUSH
48086: LD_INT 2
48088: PUSH
48089: LD_INT 2
48091: PUSH
48092: EMPTY
48093: LIST
48094: LIST
48095: PUSH
48096: LD_INT 3
48098: PUSH
48099: LD_INT 2
48101: PUSH
48102: EMPTY
48103: LIST
48104: LIST
48105: PUSH
48106: LD_INT 2
48108: PUSH
48109: LD_INT 3
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: PUSH
48116: EMPTY
48117: LIST
48118: LIST
48119: LIST
48120: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
48121: LD_ADDR_VAR 0 44
48125: PUSH
48126: LD_INT 0
48128: PUSH
48129: LD_INT 2
48131: PUSH
48132: EMPTY
48133: LIST
48134: LIST
48135: PUSH
48136: LD_INT 1
48138: PUSH
48139: LD_INT 3
48141: PUSH
48142: EMPTY
48143: LIST
48144: LIST
48145: PUSH
48146: LD_INT 1
48148: NEG
48149: PUSH
48150: LD_INT 2
48152: PUSH
48153: EMPTY
48154: LIST
48155: LIST
48156: PUSH
48157: EMPTY
48158: LIST
48159: LIST
48160: LIST
48161: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
48162: LD_ADDR_VAR 0 45
48166: PUSH
48167: LD_INT 2
48169: NEG
48170: PUSH
48171: LD_INT 0
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: PUSH
48178: LD_INT 2
48180: NEG
48181: PUSH
48182: LD_INT 1
48184: PUSH
48185: EMPTY
48186: LIST
48187: LIST
48188: PUSH
48189: LD_INT 3
48191: NEG
48192: PUSH
48193: LD_INT 1
48195: NEG
48196: PUSH
48197: EMPTY
48198: LIST
48199: LIST
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: LIST
48205: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
48206: LD_ADDR_VAR 0 46
48210: PUSH
48211: LD_INT 2
48213: NEG
48214: PUSH
48215: LD_INT 2
48217: NEG
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PUSH
48223: LD_INT 2
48225: NEG
48226: PUSH
48227: LD_INT 3
48229: NEG
48230: PUSH
48231: EMPTY
48232: LIST
48233: LIST
48234: PUSH
48235: LD_INT 3
48237: NEG
48238: PUSH
48239: LD_INT 2
48241: NEG
48242: PUSH
48243: EMPTY
48244: LIST
48245: LIST
48246: PUSH
48247: EMPTY
48248: LIST
48249: LIST
48250: LIST
48251: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
48252: LD_ADDR_VAR 0 47
48256: PUSH
48257: LD_INT 2
48259: NEG
48260: PUSH
48261: LD_INT 3
48263: NEG
48264: PUSH
48265: EMPTY
48266: LIST
48267: LIST
48268: PUSH
48269: LD_INT 1
48271: NEG
48272: PUSH
48273: LD_INT 3
48275: NEG
48276: PUSH
48277: EMPTY
48278: LIST
48279: LIST
48280: PUSH
48281: EMPTY
48282: LIST
48283: LIST
48284: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
48285: LD_ADDR_VAR 0 48
48289: PUSH
48290: LD_INT 1
48292: PUSH
48293: LD_INT 2
48295: NEG
48296: PUSH
48297: EMPTY
48298: LIST
48299: LIST
48300: PUSH
48301: LD_INT 2
48303: PUSH
48304: LD_INT 1
48306: NEG
48307: PUSH
48308: EMPTY
48309: LIST
48310: LIST
48311: PUSH
48312: EMPTY
48313: LIST
48314: LIST
48315: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
48316: LD_ADDR_VAR 0 49
48320: PUSH
48321: LD_INT 3
48323: PUSH
48324: LD_INT 1
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 3
48333: PUSH
48334: LD_INT 2
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: PUSH
48341: EMPTY
48342: LIST
48343: LIST
48344: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
48345: LD_ADDR_VAR 0 50
48349: PUSH
48350: LD_INT 2
48352: PUSH
48353: LD_INT 3
48355: PUSH
48356: EMPTY
48357: LIST
48358: LIST
48359: PUSH
48360: LD_INT 1
48362: PUSH
48363: LD_INT 3
48365: PUSH
48366: EMPTY
48367: LIST
48368: LIST
48369: PUSH
48370: EMPTY
48371: LIST
48372: LIST
48373: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
48374: LD_ADDR_VAR 0 51
48378: PUSH
48379: LD_INT 1
48381: NEG
48382: PUSH
48383: LD_INT 2
48385: PUSH
48386: EMPTY
48387: LIST
48388: LIST
48389: PUSH
48390: LD_INT 2
48392: NEG
48393: PUSH
48394: LD_INT 1
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: PUSH
48401: EMPTY
48402: LIST
48403: LIST
48404: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
48405: LD_ADDR_VAR 0 52
48409: PUSH
48410: LD_INT 3
48412: NEG
48413: PUSH
48414: LD_INT 1
48416: NEG
48417: PUSH
48418: EMPTY
48419: LIST
48420: LIST
48421: PUSH
48422: LD_INT 3
48424: NEG
48425: PUSH
48426: LD_INT 2
48428: NEG
48429: PUSH
48430: EMPTY
48431: LIST
48432: LIST
48433: PUSH
48434: EMPTY
48435: LIST
48436: LIST
48437: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
48438: LD_ADDR_VAR 0 53
48442: PUSH
48443: LD_INT 1
48445: NEG
48446: PUSH
48447: LD_INT 3
48449: NEG
48450: PUSH
48451: EMPTY
48452: LIST
48453: LIST
48454: PUSH
48455: LD_INT 0
48457: PUSH
48458: LD_INT 3
48460: NEG
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: PUSH
48466: LD_INT 1
48468: PUSH
48469: LD_INT 2
48471: NEG
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: PUSH
48477: EMPTY
48478: LIST
48479: LIST
48480: LIST
48481: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
48482: LD_ADDR_VAR 0 54
48486: PUSH
48487: LD_INT 2
48489: PUSH
48490: LD_INT 1
48492: NEG
48493: PUSH
48494: EMPTY
48495: LIST
48496: LIST
48497: PUSH
48498: LD_INT 3
48500: PUSH
48501: LD_INT 0
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 3
48510: PUSH
48511: LD_INT 1
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PUSH
48518: EMPTY
48519: LIST
48520: LIST
48521: LIST
48522: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
48523: LD_ADDR_VAR 0 55
48527: PUSH
48528: LD_INT 3
48530: PUSH
48531: LD_INT 2
48533: PUSH
48534: EMPTY
48535: LIST
48536: LIST
48537: PUSH
48538: LD_INT 3
48540: PUSH
48541: LD_INT 3
48543: PUSH
48544: EMPTY
48545: LIST
48546: LIST
48547: PUSH
48548: LD_INT 2
48550: PUSH
48551: LD_INT 3
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PUSH
48558: EMPTY
48559: LIST
48560: LIST
48561: LIST
48562: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
48563: LD_ADDR_VAR 0 56
48567: PUSH
48568: LD_INT 1
48570: PUSH
48571: LD_INT 3
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 0
48580: PUSH
48581: LD_INT 3
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: LD_INT 1
48590: NEG
48591: PUSH
48592: LD_INT 2
48594: PUSH
48595: EMPTY
48596: LIST
48597: LIST
48598: PUSH
48599: EMPTY
48600: LIST
48601: LIST
48602: LIST
48603: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
48604: LD_ADDR_VAR 0 57
48608: PUSH
48609: LD_INT 2
48611: NEG
48612: PUSH
48613: LD_INT 1
48615: PUSH
48616: EMPTY
48617: LIST
48618: LIST
48619: PUSH
48620: LD_INT 3
48622: NEG
48623: PUSH
48624: LD_INT 0
48626: PUSH
48627: EMPTY
48628: LIST
48629: LIST
48630: PUSH
48631: LD_INT 3
48633: NEG
48634: PUSH
48635: LD_INT 1
48637: NEG
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: PUSH
48643: EMPTY
48644: LIST
48645: LIST
48646: LIST
48647: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
48648: LD_ADDR_VAR 0 58
48652: PUSH
48653: LD_INT 2
48655: NEG
48656: PUSH
48657: LD_INT 3
48659: NEG
48660: PUSH
48661: EMPTY
48662: LIST
48663: LIST
48664: PUSH
48665: LD_INT 3
48667: NEG
48668: PUSH
48669: LD_INT 2
48671: NEG
48672: PUSH
48673: EMPTY
48674: LIST
48675: LIST
48676: PUSH
48677: LD_INT 3
48679: NEG
48680: PUSH
48681: LD_INT 3
48683: NEG
48684: PUSH
48685: EMPTY
48686: LIST
48687: LIST
48688: PUSH
48689: EMPTY
48690: LIST
48691: LIST
48692: LIST
48693: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
48694: LD_ADDR_VAR 0 59
48698: PUSH
48699: LD_INT 1
48701: NEG
48702: PUSH
48703: LD_INT 2
48705: NEG
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: PUSH
48711: LD_INT 0
48713: PUSH
48714: LD_INT 2
48716: NEG
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: PUSH
48722: LD_INT 1
48724: PUSH
48725: LD_INT 1
48727: NEG
48728: PUSH
48729: EMPTY
48730: LIST
48731: LIST
48732: PUSH
48733: EMPTY
48734: LIST
48735: LIST
48736: LIST
48737: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48738: LD_ADDR_VAR 0 60
48742: PUSH
48743: LD_INT 1
48745: PUSH
48746: LD_INT 1
48748: NEG
48749: PUSH
48750: EMPTY
48751: LIST
48752: LIST
48753: PUSH
48754: LD_INT 2
48756: PUSH
48757: LD_INT 0
48759: PUSH
48760: EMPTY
48761: LIST
48762: LIST
48763: PUSH
48764: LD_INT 2
48766: PUSH
48767: LD_INT 1
48769: PUSH
48770: EMPTY
48771: LIST
48772: LIST
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: LIST
48778: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48779: LD_ADDR_VAR 0 61
48783: PUSH
48784: LD_INT 2
48786: PUSH
48787: LD_INT 1
48789: PUSH
48790: EMPTY
48791: LIST
48792: LIST
48793: PUSH
48794: LD_INT 2
48796: PUSH
48797: LD_INT 2
48799: PUSH
48800: EMPTY
48801: LIST
48802: LIST
48803: PUSH
48804: LD_INT 1
48806: PUSH
48807: LD_INT 2
48809: PUSH
48810: EMPTY
48811: LIST
48812: LIST
48813: PUSH
48814: EMPTY
48815: LIST
48816: LIST
48817: LIST
48818: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48819: LD_ADDR_VAR 0 62
48823: PUSH
48824: LD_INT 1
48826: PUSH
48827: LD_INT 2
48829: PUSH
48830: EMPTY
48831: LIST
48832: LIST
48833: PUSH
48834: LD_INT 0
48836: PUSH
48837: LD_INT 2
48839: PUSH
48840: EMPTY
48841: LIST
48842: LIST
48843: PUSH
48844: LD_INT 1
48846: NEG
48847: PUSH
48848: LD_INT 1
48850: PUSH
48851: EMPTY
48852: LIST
48853: LIST
48854: PUSH
48855: EMPTY
48856: LIST
48857: LIST
48858: LIST
48859: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48860: LD_ADDR_VAR 0 63
48864: PUSH
48865: LD_INT 1
48867: NEG
48868: PUSH
48869: LD_INT 1
48871: PUSH
48872: EMPTY
48873: LIST
48874: LIST
48875: PUSH
48876: LD_INT 2
48878: NEG
48879: PUSH
48880: LD_INT 0
48882: PUSH
48883: EMPTY
48884: LIST
48885: LIST
48886: PUSH
48887: LD_INT 2
48889: NEG
48890: PUSH
48891: LD_INT 1
48893: NEG
48894: PUSH
48895: EMPTY
48896: LIST
48897: LIST
48898: PUSH
48899: EMPTY
48900: LIST
48901: LIST
48902: LIST
48903: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48904: LD_ADDR_VAR 0 64
48908: PUSH
48909: LD_INT 1
48911: NEG
48912: PUSH
48913: LD_INT 2
48915: NEG
48916: PUSH
48917: EMPTY
48918: LIST
48919: LIST
48920: PUSH
48921: LD_INT 2
48923: NEG
48924: PUSH
48925: LD_INT 1
48927: NEG
48928: PUSH
48929: EMPTY
48930: LIST
48931: LIST
48932: PUSH
48933: LD_INT 2
48935: NEG
48936: PUSH
48937: LD_INT 2
48939: NEG
48940: PUSH
48941: EMPTY
48942: LIST
48943: LIST
48944: PUSH
48945: EMPTY
48946: LIST
48947: LIST
48948: LIST
48949: ST_TO_ADDR
// end ; 2 :
48950: GO 52216
48952: LD_INT 2
48954: DOUBLE
48955: EQUAL
48956: IFTRUE 48960
48958: GO 52215
48960: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48961: LD_ADDR_VAR 0 29
48965: PUSH
48966: LD_INT 4
48968: PUSH
48969: LD_INT 0
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 4
48978: PUSH
48979: LD_INT 1
48981: NEG
48982: PUSH
48983: EMPTY
48984: LIST
48985: LIST
48986: PUSH
48987: LD_INT 5
48989: PUSH
48990: LD_INT 0
48992: PUSH
48993: EMPTY
48994: LIST
48995: LIST
48996: PUSH
48997: LD_INT 5
48999: PUSH
49000: LD_INT 1
49002: PUSH
49003: EMPTY
49004: LIST
49005: LIST
49006: PUSH
49007: LD_INT 4
49009: PUSH
49010: LD_INT 1
49012: PUSH
49013: EMPTY
49014: LIST
49015: LIST
49016: PUSH
49017: LD_INT 3
49019: PUSH
49020: LD_INT 0
49022: PUSH
49023: EMPTY
49024: LIST
49025: LIST
49026: PUSH
49027: LD_INT 3
49029: PUSH
49030: LD_INT 1
49032: NEG
49033: PUSH
49034: EMPTY
49035: LIST
49036: LIST
49037: PUSH
49038: LD_INT 3
49040: PUSH
49041: LD_INT 2
49043: NEG
49044: PUSH
49045: EMPTY
49046: LIST
49047: LIST
49048: PUSH
49049: LD_INT 5
49051: PUSH
49052: LD_INT 2
49054: PUSH
49055: EMPTY
49056: LIST
49057: LIST
49058: PUSH
49059: LD_INT 3
49061: PUSH
49062: LD_INT 3
49064: PUSH
49065: EMPTY
49066: LIST
49067: LIST
49068: PUSH
49069: LD_INT 3
49071: PUSH
49072: LD_INT 2
49074: PUSH
49075: EMPTY
49076: LIST
49077: LIST
49078: PUSH
49079: LD_INT 4
49081: PUSH
49082: LD_INT 3
49084: PUSH
49085: EMPTY
49086: LIST
49087: LIST
49088: PUSH
49089: LD_INT 4
49091: PUSH
49092: LD_INT 4
49094: PUSH
49095: EMPTY
49096: LIST
49097: LIST
49098: PUSH
49099: LD_INT 3
49101: PUSH
49102: LD_INT 4
49104: PUSH
49105: EMPTY
49106: LIST
49107: LIST
49108: PUSH
49109: LD_INT 2
49111: PUSH
49112: LD_INT 3
49114: PUSH
49115: EMPTY
49116: LIST
49117: LIST
49118: PUSH
49119: LD_INT 2
49121: PUSH
49122: LD_INT 2
49124: PUSH
49125: EMPTY
49126: LIST
49127: LIST
49128: PUSH
49129: LD_INT 4
49131: PUSH
49132: LD_INT 2
49134: PUSH
49135: EMPTY
49136: LIST
49137: LIST
49138: PUSH
49139: LD_INT 2
49141: PUSH
49142: LD_INT 4
49144: PUSH
49145: EMPTY
49146: LIST
49147: LIST
49148: PUSH
49149: LD_INT 0
49151: PUSH
49152: LD_INT 4
49154: PUSH
49155: EMPTY
49156: LIST
49157: LIST
49158: PUSH
49159: LD_INT 0
49161: PUSH
49162: LD_INT 3
49164: PUSH
49165: EMPTY
49166: LIST
49167: LIST
49168: PUSH
49169: LD_INT 1
49171: PUSH
49172: LD_INT 4
49174: PUSH
49175: EMPTY
49176: LIST
49177: LIST
49178: PUSH
49179: LD_INT 1
49181: PUSH
49182: LD_INT 5
49184: PUSH
49185: EMPTY
49186: LIST
49187: LIST
49188: PUSH
49189: LD_INT 0
49191: PUSH
49192: LD_INT 5
49194: PUSH
49195: EMPTY
49196: LIST
49197: LIST
49198: PUSH
49199: LD_INT 1
49201: NEG
49202: PUSH
49203: LD_INT 4
49205: PUSH
49206: EMPTY
49207: LIST
49208: LIST
49209: PUSH
49210: LD_INT 1
49212: NEG
49213: PUSH
49214: LD_INT 3
49216: PUSH
49217: EMPTY
49218: LIST
49219: LIST
49220: PUSH
49221: LD_INT 2
49223: PUSH
49224: LD_INT 5
49226: PUSH
49227: EMPTY
49228: LIST
49229: LIST
49230: PUSH
49231: LD_INT 2
49233: NEG
49234: PUSH
49235: LD_INT 3
49237: PUSH
49238: EMPTY
49239: LIST
49240: LIST
49241: PUSH
49242: LD_INT 3
49244: NEG
49245: PUSH
49246: LD_INT 0
49248: PUSH
49249: EMPTY
49250: LIST
49251: LIST
49252: PUSH
49253: LD_INT 3
49255: NEG
49256: PUSH
49257: LD_INT 1
49259: NEG
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: PUSH
49265: LD_INT 2
49267: NEG
49268: PUSH
49269: LD_INT 0
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: PUSH
49276: LD_INT 2
49278: NEG
49279: PUSH
49280: LD_INT 1
49282: PUSH
49283: EMPTY
49284: LIST
49285: LIST
49286: PUSH
49287: LD_INT 3
49289: NEG
49290: PUSH
49291: LD_INT 1
49293: PUSH
49294: EMPTY
49295: LIST
49296: LIST
49297: PUSH
49298: LD_INT 4
49300: NEG
49301: PUSH
49302: LD_INT 0
49304: PUSH
49305: EMPTY
49306: LIST
49307: LIST
49308: PUSH
49309: LD_INT 4
49311: NEG
49312: PUSH
49313: LD_INT 1
49315: NEG
49316: PUSH
49317: EMPTY
49318: LIST
49319: LIST
49320: PUSH
49321: LD_INT 4
49323: NEG
49324: PUSH
49325: LD_INT 2
49327: NEG
49328: PUSH
49329: EMPTY
49330: LIST
49331: LIST
49332: PUSH
49333: LD_INT 2
49335: NEG
49336: PUSH
49337: LD_INT 2
49339: PUSH
49340: EMPTY
49341: LIST
49342: LIST
49343: PUSH
49344: LD_INT 4
49346: NEG
49347: PUSH
49348: LD_INT 4
49350: NEG
49351: PUSH
49352: EMPTY
49353: LIST
49354: LIST
49355: PUSH
49356: LD_INT 4
49358: NEG
49359: PUSH
49360: LD_INT 5
49362: NEG
49363: PUSH
49364: EMPTY
49365: LIST
49366: LIST
49367: PUSH
49368: LD_INT 3
49370: NEG
49371: PUSH
49372: LD_INT 4
49374: NEG
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: PUSH
49380: LD_INT 3
49382: NEG
49383: PUSH
49384: LD_INT 3
49386: NEG
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 4
49394: NEG
49395: PUSH
49396: LD_INT 3
49398: NEG
49399: PUSH
49400: EMPTY
49401: LIST
49402: LIST
49403: PUSH
49404: LD_INT 5
49406: NEG
49407: PUSH
49408: LD_INT 4
49410: NEG
49411: PUSH
49412: EMPTY
49413: LIST
49414: LIST
49415: PUSH
49416: LD_INT 5
49418: NEG
49419: PUSH
49420: LD_INT 5
49422: NEG
49423: PUSH
49424: EMPTY
49425: LIST
49426: LIST
49427: PUSH
49428: LD_INT 3
49430: NEG
49431: PUSH
49432: LD_INT 5
49434: NEG
49435: PUSH
49436: EMPTY
49437: LIST
49438: LIST
49439: PUSH
49440: LD_INT 5
49442: NEG
49443: PUSH
49444: LD_INT 3
49446: NEG
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: PUSH
49452: EMPTY
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: LIST
49485: LIST
49486: LIST
49487: LIST
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: LIST
49493: LIST
49494: LIST
49495: LIST
49496: LIST
49497: LIST
49498: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
49499: LD_ADDR_VAR 0 30
49503: PUSH
49504: LD_INT 4
49506: PUSH
49507: LD_INT 4
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: PUSH
49514: LD_INT 4
49516: PUSH
49517: LD_INT 3
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 5
49526: PUSH
49527: LD_INT 4
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PUSH
49534: LD_INT 5
49536: PUSH
49537: LD_INT 5
49539: PUSH
49540: EMPTY
49541: LIST
49542: LIST
49543: PUSH
49544: LD_INT 4
49546: PUSH
49547: LD_INT 5
49549: PUSH
49550: EMPTY
49551: LIST
49552: LIST
49553: PUSH
49554: LD_INT 3
49556: PUSH
49557: LD_INT 4
49559: PUSH
49560: EMPTY
49561: LIST
49562: LIST
49563: PUSH
49564: LD_INT 3
49566: PUSH
49567: LD_INT 3
49569: PUSH
49570: EMPTY
49571: LIST
49572: LIST
49573: PUSH
49574: LD_INT 5
49576: PUSH
49577: LD_INT 3
49579: PUSH
49580: EMPTY
49581: LIST
49582: LIST
49583: PUSH
49584: LD_INT 3
49586: PUSH
49587: LD_INT 5
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: PUSH
49594: LD_INT 0
49596: PUSH
49597: LD_INT 3
49599: PUSH
49600: EMPTY
49601: LIST
49602: LIST
49603: PUSH
49604: LD_INT 0
49606: PUSH
49607: LD_INT 2
49609: PUSH
49610: EMPTY
49611: LIST
49612: LIST
49613: PUSH
49614: LD_INT 1
49616: PUSH
49617: LD_INT 3
49619: PUSH
49620: EMPTY
49621: LIST
49622: LIST
49623: PUSH
49624: LD_INT 1
49626: PUSH
49627: LD_INT 4
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: PUSH
49634: LD_INT 0
49636: PUSH
49637: LD_INT 4
49639: PUSH
49640: EMPTY
49641: LIST
49642: LIST
49643: PUSH
49644: LD_INT 1
49646: NEG
49647: PUSH
49648: LD_INT 3
49650: PUSH
49651: EMPTY
49652: LIST
49653: LIST
49654: PUSH
49655: LD_INT 1
49657: NEG
49658: PUSH
49659: LD_INT 2
49661: PUSH
49662: EMPTY
49663: LIST
49664: LIST
49665: PUSH
49666: LD_INT 2
49668: PUSH
49669: LD_INT 4
49671: PUSH
49672: EMPTY
49673: LIST
49674: LIST
49675: PUSH
49676: LD_INT 2
49678: NEG
49679: PUSH
49680: LD_INT 2
49682: PUSH
49683: EMPTY
49684: LIST
49685: LIST
49686: PUSH
49687: LD_INT 4
49689: NEG
49690: PUSH
49691: LD_INT 0
49693: PUSH
49694: EMPTY
49695: LIST
49696: LIST
49697: PUSH
49698: LD_INT 4
49700: NEG
49701: PUSH
49702: LD_INT 1
49704: NEG
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: PUSH
49710: LD_INT 3
49712: NEG
49713: PUSH
49714: LD_INT 0
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PUSH
49721: LD_INT 3
49723: NEG
49724: PUSH
49725: LD_INT 1
49727: PUSH
49728: EMPTY
49729: LIST
49730: LIST
49731: PUSH
49732: LD_INT 4
49734: NEG
49735: PUSH
49736: LD_INT 1
49738: PUSH
49739: EMPTY
49740: LIST
49741: LIST
49742: PUSH
49743: LD_INT 5
49745: NEG
49746: PUSH
49747: LD_INT 0
49749: PUSH
49750: EMPTY
49751: LIST
49752: LIST
49753: PUSH
49754: LD_INT 5
49756: NEG
49757: PUSH
49758: LD_INT 1
49760: NEG
49761: PUSH
49762: EMPTY
49763: LIST
49764: LIST
49765: PUSH
49766: LD_INT 5
49768: NEG
49769: PUSH
49770: LD_INT 2
49772: NEG
49773: PUSH
49774: EMPTY
49775: LIST
49776: LIST
49777: PUSH
49778: LD_INT 3
49780: NEG
49781: PUSH
49782: LD_INT 2
49784: PUSH
49785: EMPTY
49786: LIST
49787: LIST
49788: PUSH
49789: LD_INT 3
49791: NEG
49792: PUSH
49793: LD_INT 3
49795: NEG
49796: PUSH
49797: EMPTY
49798: LIST
49799: LIST
49800: PUSH
49801: LD_INT 3
49803: NEG
49804: PUSH
49805: LD_INT 4
49807: NEG
49808: PUSH
49809: EMPTY
49810: LIST
49811: LIST
49812: PUSH
49813: LD_INT 2
49815: NEG
49816: PUSH
49817: LD_INT 3
49819: NEG
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: PUSH
49825: LD_INT 2
49827: NEG
49828: PUSH
49829: LD_INT 2
49831: NEG
49832: PUSH
49833: EMPTY
49834: LIST
49835: LIST
49836: PUSH
49837: LD_INT 3
49839: NEG
49840: PUSH
49841: LD_INT 2
49843: NEG
49844: PUSH
49845: EMPTY
49846: LIST
49847: LIST
49848: PUSH
49849: LD_INT 4
49851: NEG
49852: PUSH
49853: LD_INT 3
49855: NEG
49856: PUSH
49857: EMPTY
49858: LIST
49859: LIST
49860: PUSH
49861: LD_INT 4
49863: NEG
49864: PUSH
49865: LD_INT 4
49867: NEG
49868: PUSH
49869: EMPTY
49870: LIST
49871: LIST
49872: PUSH
49873: LD_INT 2
49875: NEG
49876: PUSH
49877: LD_INT 4
49879: NEG
49880: PUSH
49881: EMPTY
49882: LIST
49883: LIST
49884: PUSH
49885: LD_INT 4
49887: NEG
49888: PUSH
49889: LD_INT 2
49891: NEG
49892: PUSH
49893: EMPTY
49894: LIST
49895: LIST
49896: PUSH
49897: LD_INT 0
49899: PUSH
49900: LD_INT 4
49902: NEG
49903: PUSH
49904: EMPTY
49905: LIST
49906: LIST
49907: PUSH
49908: LD_INT 0
49910: PUSH
49911: LD_INT 5
49913: NEG
49914: PUSH
49915: EMPTY
49916: LIST
49917: LIST
49918: PUSH
49919: LD_INT 1
49921: PUSH
49922: LD_INT 4
49924: NEG
49925: PUSH
49926: EMPTY
49927: LIST
49928: LIST
49929: PUSH
49930: LD_INT 1
49932: PUSH
49933: LD_INT 3
49935: NEG
49936: PUSH
49937: EMPTY
49938: LIST
49939: LIST
49940: PUSH
49941: LD_INT 0
49943: PUSH
49944: LD_INT 3
49946: NEG
49947: PUSH
49948: EMPTY
49949: LIST
49950: LIST
49951: PUSH
49952: LD_INT 1
49954: NEG
49955: PUSH
49956: LD_INT 4
49958: NEG
49959: PUSH
49960: EMPTY
49961: LIST
49962: LIST
49963: PUSH
49964: LD_INT 1
49966: NEG
49967: PUSH
49968: LD_INT 5
49970: NEG
49971: PUSH
49972: EMPTY
49973: LIST
49974: LIST
49975: PUSH
49976: LD_INT 2
49978: PUSH
49979: LD_INT 3
49981: NEG
49982: PUSH
49983: EMPTY
49984: LIST
49985: LIST
49986: PUSH
49987: LD_INT 2
49989: NEG
49990: PUSH
49991: LD_INT 5
49993: NEG
49994: PUSH
49995: EMPTY
49996: LIST
49997: LIST
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: LIST
50009: LIST
50010: LIST
50011: LIST
50012: LIST
50013: LIST
50014: LIST
50015: LIST
50016: LIST
50017: LIST
50018: LIST
50019: LIST
50020: LIST
50021: LIST
50022: LIST
50023: LIST
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: LIST
50029: LIST
50030: LIST
50031: LIST
50032: LIST
50033: LIST
50034: LIST
50035: LIST
50036: LIST
50037: LIST
50038: LIST
50039: LIST
50040: LIST
50041: LIST
50042: LIST
50043: LIST
50044: LIST
50045: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
50046: LD_ADDR_VAR 0 31
50050: PUSH
50051: LD_INT 0
50053: PUSH
50054: LD_INT 4
50056: PUSH
50057: EMPTY
50058: LIST
50059: LIST
50060: PUSH
50061: LD_INT 0
50063: PUSH
50064: LD_INT 3
50066: PUSH
50067: EMPTY
50068: LIST
50069: LIST
50070: PUSH
50071: LD_INT 1
50073: PUSH
50074: LD_INT 4
50076: PUSH
50077: EMPTY
50078: LIST
50079: LIST
50080: PUSH
50081: LD_INT 1
50083: PUSH
50084: LD_INT 5
50086: PUSH
50087: EMPTY
50088: LIST
50089: LIST
50090: PUSH
50091: LD_INT 0
50093: PUSH
50094: LD_INT 5
50096: PUSH
50097: EMPTY
50098: LIST
50099: LIST
50100: PUSH
50101: LD_INT 1
50103: NEG
50104: PUSH
50105: LD_INT 4
50107: PUSH
50108: EMPTY
50109: LIST
50110: LIST
50111: PUSH
50112: LD_INT 1
50114: NEG
50115: PUSH
50116: LD_INT 3
50118: PUSH
50119: EMPTY
50120: LIST
50121: LIST
50122: PUSH
50123: LD_INT 2
50125: PUSH
50126: LD_INT 5
50128: PUSH
50129: EMPTY
50130: LIST
50131: LIST
50132: PUSH
50133: LD_INT 2
50135: NEG
50136: PUSH
50137: LD_INT 3
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: PUSH
50144: LD_INT 3
50146: NEG
50147: PUSH
50148: LD_INT 0
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 3
50157: NEG
50158: PUSH
50159: LD_INT 1
50161: NEG
50162: PUSH
50163: EMPTY
50164: LIST
50165: LIST
50166: PUSH
50167: LD_INT 2
50169: NEG
50170: PUSH
50171: LD_INT 0
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 2
50180: NEG
50181: PUSH
50182: LD_INT 1
50184: PUSH
50185: EMPTY
50186: LIST
50187: LIST
50188: PUSH
50189: LD_INT 3
50191: NEG
50192: PUSH
50193: LD_INT 1
50195: PUSH
50196: EMPTY
50197: LIST
50198: LIST
50199: PUSH
50200: LD_INT 4
50202: NEG
50203: PUSH
50204: LD_INT 0
50206: PUSH
50207: EMPTY
50208: LIST
50209: LIST
50210: PUSH
50211: LD_INT 4
50213: NEG
50214: PUSH
50215: LD_INT 1
50217: NEG
50218: PUSH
50219: EMPTY
50220: LIST
50221: LIST
50222: PUSH
50223: LD_INT 4
50225: NEG
50226: PUSH
50227: LD_INT 2
50229: NEG
50230: PUSH
50231: EMPTY
50232: LIST
50233: LIST
50234: PUSH
50235: LD_INT 2
50237: NEG
50238: PUSH
50239: LD_INT 2
50241: PUSH
50242: EMPTY
50243: LIST
50244: LIST
50245: PUSH
50246: LD_INT 4
50248: NEG
50249: PUSH
50250: LD_INT 4
50252: NEG
50253: PUSH
50254: EMPTY
50255: LIST
50256: LIST
50257: PUSH
50258: LD_INT 4
50260: NEG
50261: PUSH
50262: LD_INT 5
50264: NEG
50265: PUSH
50266: EMPTY
50267: LIST
50268: LIST
50269: PUSH
50270: LD_INT 3
50272: NEG
50273: PUSH
50274: LD_INT 4
50276: NEG
50277: PUSH
50278: EMPTY
50279: LIST
50280: LIST
50281: PUSH
50282: LD_INT 3
50284: NEG
50285: PUSH
50286: LD_INT 3
50288: NEG
50289: PUSH
50290: EMPTY
50291: LIST
50292: LIST
50293: PUSH
50294: LD_INT 4
50296: NEG
50297: PUSH
50298: LD_INT 3
50300: NEG
50301: PUSH
50302: EMPTY
50303: LIST
50304: LIST
50305: PUSH
50306: LD_INT 5
50308: NEG
50309: PUSH
50310: LD_INT 4
50312: NEG
50313: PUSH
50314: EMPTY
50315: LIST
50316: LIST
50317: PUSH
50318: LD_INT 5
50320: NEG
50321: PUSH
50322: LD_INT 5
50324: NEG
50325: PUSH
50326: EMPTY
50327: LIST
50328: LIST
50329: PUSH
50330: LD_INT 3
50332: NEG
50333: PUSH
50334: LD_INT 5
50336: NEG
50337: PUSH
50338: EMPTY
50339: LIST
50340: LIST
50341: PUSH
50342: LD_INT 5
50344: NEG
50345: PUSH
50346: LD_INT 3
50348: NEG
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: PUSH
50354: LD_INT 0
50356: PUSH
50357: LD_INT 3
50359: NEG
50360: PUSH
50361: EMPTY
50362: LIST
50363: LIST
50364: PUSH
50365: LD_INT 0
50367: PUSH
50368: LD_INT 4
50370: NEG
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: LD_INT 1
50378: PUSH
50379: LD_INT 3
50381: NEG
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: PUSH
50387: LD_INT 1
50389: PUSH
50390: LD_INT 2
50392: NEG
50393: PUSH
50394: EMPTY
50395: LIST
50396: LIST
50397: PUSH
50398: LD_INT 0
50400: PUSH
50401: LD_INT 2
50403: NEG
50404: PUSH
50405: EMPTY
50406: LIST
50407: LIST
50408: PUSH
50409: LD_INT 1
50411: NEG
50412: PUSH
50413: LD_INT 3
50415: NEG
50416: PUSH
50417: EMPTY
50418: LIST
50419: LIST
50420: PUSH
50421: LD_INT 1
50423: NEG
50424: PUSH
50425: LD_INT 4
50427: NEG
50428: PUSH
50429: EMPTY
50430: LIST
50431: LIST
50432: PUSH
50433: LD_INT 2
50435: PUSH
50436: LD_INT 2
50438: NEG
50439: PUSH
50440: EMPTY
50441: LIST
50442: LIST
50443: PUSH
50444: LD_INT 2
50446: NEG
50447: PUSH
50448: LD_INT 4
50450: NEG
50451: PUSH
50452: EMPTY
50453: LIST
50454: LIST
50455: PUSH
50456: LD_INT 4
50458: PUSH
50459: LD_INT 0
50461: PUSH
50462: EMPTY
50463: LIST
50464: LIST
50465: PUSH
50466: LD_INT 4
50468: PUSH
50469: LD_INT 1
50471: NEG
50472: PUSH
50473: EMPTY
50474: LIST
50475: LIST
50476: PUSH
50477: LD_INT 5
50479: PUSH
50480: LD_INT 0
50482: PUSH
50483: EMPTY
50484: LIST
50485: LIST
50486: PUSH
50487: LD_INT 5
50489: PUSH
50490: LD_INT 1
50492: PUSH
50493: EMPTY
50494: LIST
50495: LIST
50496: PUSH
50497: LD_INT 4
50499: PUSH
50500: LD_INT 1
50502: PUSH
50503: EMPTY
50504: LIST
50505: LIST
50506: PUSH
50507: LD_INT 3
50509: PUSH
50510: LD_INT 0
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: PUSH
50517: LD_INT 3
50519: PUSH
50520: LD_INT 1
50522: NEG
50523: PUSH
50524: EMPTY
50525: LIST
50526: LIST
50527: PUSH
50528: LD_INT 3
50530: PUSH
50531: LD_INT 2
50533: NEG
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: PUSH
50539: LD_INT 5
50541: PUSH
50542: LD_INT 2
50544: PUSH
50545: EMPTY
50546: LIST
50547: LIST
50548: PUSH
50549: EMPTY
50550: LIST
50551: LIST
50552: LIST
50553: LIST
50554: LIST
50555: LIST
50556: LIST
50557: LIST
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: LIST
50563: LIST
50564: LIST
50565: LIST
50566: LIST
50567: LIST
50568: LIST
50569: LIST
50570: LIST
50571: LIST
50572: LIST
50573: LIST
50574: LIST
50575: LIST
50576: LIST
50577: LIST
50578: LIST
50579: LIST
50580: LIST
50581: LIST
50582: LIST
50583: LIST
50584: LIST
50585: LIST
50586: LIST
50587: LIST
50588: LIST
50589: LIST
50590: LIST
50591: LIST
50592: LIST
50593: LIST
50594: LIST
50595: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
50596: LD_ADDR_VAR 0 32
50600: PUSH
50601: LD_INT 4
50603: NEG
50604: PUSH
50605: LD_INT 0
50607: PUSH
50608: EMPTY
50609: LIST
50610: LIST
50611: PUSH
50612: LD_INT 4
50614: NEG
50615: PUSH
50616: LD_INT 1
50618: NEG
50619: PUSH
50620: EMPTY
50621: LIST
50622: LIST
50623: PUSH
50624: LD_INT 3
50626: NEG
50627: PUSH
50628: LD_INT 0
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 3
50637: NEG
50638: PUSH
50639: LD_INT 1
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: PUSH
50646: LD_INT 4
50648: NEG
50649: PUSH
50650: LD_INT 1
50652: PUSH
50653: EMPTY
50654: LIST
50655: LIST
50656: PUSH
50657: LD_INT 5
50659: NEG
50660: PUSH
50661: LD_INT 0
50663: PUSH
50664: EMPTY
50665: LIST
50666: LIST
50667: PUSH
50668: LD_INT 5
50670: NEG
50671: PUSH
50672: LD_INT 1
50674: NEG
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: LD_INT 5
50682: NEG
50683: PUSH
50684: LD_INT 2
50686: NEG
50687: PUSH
50688: EMPTY
50689: LIST
50690: LIST
50691: PUSH
50692: LD_INT 3
50694: NEG
50695: PUSH
50696: LD_INT 2
50698: PUSH
50699: EMPTY
50700: LIST
50701: LIST
50702: PUSH
50703: LD_INT 3
50705: NEG
50706: PUSH
50707: LD_INT 3
50709: NEG
50710: PUSH
50711: EMPTY
50712: LIST
50713: LIST
50714: PUSH
50715: LD_INT 3
50717: NEG
50718: PUSH
50719: LD_INT 4
50721: NEG
50722: PUSH
50723: EMPTY
50724: LIST
50725: LIST
50726: PUSH
50727: LD_INT 2
50729: NEG
50730: PUSH
50731: LD_INT 3
50733: NEG
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 2
50741: NEG
50742: PUSH
50743: LD_INT 2
50745: NEG
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: PUSH
50751: LD_INT 3
50753: NEG
50754: PUSH
50755: LD_INT 2
50757: NEG
50758: PUSH
50759: EMPTY
50760: LIST
50761: LIST
50762: PUSH
50763: LD_INT 4
50765: NEG
50766: PUSH
50767: LD_INT 3
50769: NEG
50770: PUSH
50771: EMPTY
50772: LIST
50773: LIST
50774: PUSH
50775: LD_INT 4
50777: NEG
50778: PUSH
50779: LD_INT 4
50781: NEG
50782: PUSH
50783: EMPTY
50784: LIST
50785: LIST
50786: PUSH
50787: LD_INT 2
50789: NEG
50790: PUSH
50791: LD_INT 4
50793: NEG
50794: PUSH
50795: EMPTY
50796: LIST
50797: LIST
50798: PUSH
50799: LD_INT 4
50801: NEG
50802: PUSH
50803: LD_INT 2
50805: NEG
50806: PUSH
50807: EMPTY
50808: LIST
50809: LIST
50810: PUSH
50811: LD_INT 0
50813: PUSH
50814: LD_INT 4
50816: NEG
50817: PUSH
50818: EMPTY
50819: LIST
50820: LIST
50821: PUSH
50822: LD_INT 0
50824: PUSH
50825: LD_INT 5
50827: NEG
50828: PUSH
50829: EMPTY
50830: LIST
50831: LIST
50832: PUSH
50833: LD_INT 1
50835: PUSH
50836: LD_INT 4
50838: NEG
50839: PUSH
50840: EMPTY
50841: LIST
50842: LIST
50843: PUSH
50844: LD_INT 1
50846: PUSH
50847: LD_INT 3
50849: NEG
50850: PUSH
50851: EMPTY
50852: LIST
50853: LIST
50854: PUSH
50855: LD_INT 0
50857: PUSH
50858: LD_INT 3
50860: NEG
50861: PUSH
50862: EMPTY
50863: LIST
50864: LIST
50865: PUSH
50866: LD_INT 1
50868: NEG
50869: PUSH
50870: LD_INT 4
50872: NEG
50873: PUSH
50874: EMPTY
50875: LIST
50876: LIST
50877: PUSH
50878: LD_INT 1
50880: NEG
50881: PUSH
50882: LD_INT 5
50884: NEG
50885: PUSH
50886: EMPTY
50887: LIST
50888: LIST
50889: PUSH
50890: LD_INT 2
50892: PUSH
50893: LD_INT 3
50895: NEG
50896: PUSH
50897: EMPTY
50898: LIST
50899: LIST
50900: PUSH
50901: LD_INT 2
50903: NEG
50904: PUSH
50905: LD_INT 5
50907: NEG
50908: PUSH
50909: EMPTY
50910: LIST
50911: LIST
50912: PUSH
50913: LD_INT 3
50915: PUSH
50916: LD_INT 0
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: PUSH
50923: LD_INT 3
50925: PUSH
50926: LD_INT 1
50928: NEG
50929: PUSH
50930: EMPTY
50931: LIST
50932: LIST
50933: PUSH
50934: LD_INT 4
50936: PUSH
50937: LD_INT 0
50939: PUSH
50940: EMPTY
50941: LIST
50942: LIST
50943: PUSH
50944: LD_INT 4
50946: PUSH
50947: LD_INT 1
50949: PUSH
50950: EMPTY
50951: LIST
50952: LIST
50953: PUSH
50954: LD_INT 3
50956: PUSH
50957: LD_INT 1
50959: PUSH
50960: EMPTY
50961: LIST
50962: LIST
50963: PUSH
50964: LD_INT 2
50966: PUSH
50967: LD_INT 0
50969: PUSH
50970: EMPTY
50971: LIST
50972: LIST
50973: PUSH
50974: LD_INT 2
50976: PUSH
50977: LD_INT 1
50979: NEG
50980: PUSH
50981: EMPTY
50982: LIST
50983: LIST
50984: PUSH
50985: LD_INT 2
50987: PUSH
50988: LD_INT 2
50990: NEG
50991: PUSH
50992: EMPTY
50993: LIST
50994: LIST
50995: PUSH
50996: LD_INT 4
50998: PUSH
50999: LD_INT 2
51001: PUSH
51002: EMPTY
51003: LIST
51004: LIST
51005: PUSH
51006: LD_INT 4
51008: PUSH
51009: LD_INT 4
51011: PUSH
51012: EMPTY
51013: LIST
51014: LIST
51015: PUSH
51016: LD_INT 4
51018: PUSH
51019: LD_INT 3
51021: PUSH
51022: EMPTY
51023: LIST
51024: LIST
51025: PUSH
51026: LD_INT 5
51028: PUSH
51029: LD_INT 4
51031: PUSH
51032: EMPTY
51033: LIST
51034: LIST
51035: PUSH
51036: LD_INT 5
51038: PUSH
51039: LD_INT 5
51041: PUSH
51042: EMPTY
51043: LIST
51044: LIST
51045: PUSH
51046: LD_INT 4
51048: PUSH
51049: LD_INT 5
51051: PUSH
51052: EMPTY
51053: LIST
51054: LIST
51055: PUSH
51056: LD_INT 3
51058: PUSH
51059: LD_INT 4
51061: PUSH
51062: EMPTY
51063: LIST
51064: LIST
51065: PUSH
51066: LD_INT 3
51068: PUSH
51069: LD_INT 3
51071: PUSH
51072: EMPTY
51073: LIST
51074: LIST
51075: PUSH
51076: LD_INT 5
51078: PUSH
51079: LD_INT 3
51081: PUSH
51082: EMPTY
51083: LIST
51084: LIST
51085: PUSH
51086: LD_INT 3
51088: PUSH
51089: LD_INT 5
51091: PUSH
51092: EMPTY
51093: LIST
51094: LIST
51095: PUSH
51096: EMPTY
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: LIST
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
51143: LD_ADDR_VAR 0 33
51147: PUSH
51148: LD_INT 4
51150: NEG
51151: PUSH
51152: LD_INT 4
51154: NEG
51155: PUSH
51156: EMPTY
51157: LIST
51158: LIST
51159: PUSH
51160: LD_INT 4
51162: NEG
51163: PUSH
51164: LD_INT 5
51166: NEG
51167: PUSH
51168: EMPTY
51169: LIST
51170: LIST
51171: PUSH
51172: LD_INT 3
51174: NEG
51175: PUSH
51176: LD_INT 4
51178: NEG
51179: PUSH
51180: EMPTY
51181: LIST
51182: LIST
51183: PUSH
51184: LD_INT 3
51186: NEG
51187: PUSH
51188: LD_INT 3
51190: NEG
51191: PUSH
51192: EMPTY
51193: LIST
51194: LIST
51195: PUSH
51196: LD_INT 4
51198: NEG
51199: PUSH
51200: LD_INT 3
51202: NEG
51203: PUSH
51204: EMPTY
51205: LIST
51206: LIST
51207: PUSH
51208: LD_INT 5
51210: NEG
51211: PUSH
51212: LD_INT 4
51214: NEG
51215: PUSH
51216: EMPTY
51217: LIST
51218: LIST
51219: PUSH
51220: LD_INT 5
51222: NEG
51223: PUSH
51224: LD_INT 5
51226: NEG
51227: PUSH
51228: EMPTY
51229: LIST
51230: LIST
51231: PUSH
51232: LD_INT 3
51234: NEG
51235: PUSH
51236: LD_INT 5
51238: NEG
51239: PUSH
51240: EMPTY
51241: LIST
51242: LIST
51243: PUSH
51244: LD_INT 5
51246: NEG
51247: PUSH
51248: LD_INT 3
51250: NEG
51251: PUSH
51252: EMPTY
51253: LIST
51254: LIST
51255: PUSH
51256: LD_INT 0
51258: PUSH
51259: LD_INT 3
51261: NEG
51262: PUSH
51263: EMPTY
51264: LIST
51265: LIST
51266: PUSH
51267: LD_INT 0
51269: PUSH
51270: LD_INT 4
51272: NEG
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PUSH
51278: LD_INT 1
51280: PUSH
51281: LD_INT 3
51283: NEG
51284: PUSH
51285: EMPTY
51286: LIST
51287: LIST
51288: PUSH
51289: LD_INT 1
51291: PUSH
51292: LD_INT 2
51294: NEG
51295: PUSH
51296: EMPTY
51297: LIST
51298: LIST
51299: PUSH
51300: LD_INT 0
51302: PUSH
51303: LD_INT 2
51305: NEG
51306: PUSH
51307: EMPTY
51308: LIST
51309: LIST
51310: PUSH
51311: LD_INT 1
51313: NEG
51314: PUSH
51315: LD_INT 3
51317: NEG
51318: PUSH
51319: EMPTY
51320: LIST
51321: LIST
51322: PUSH
51323: LD_INT 1
51325: NEG
51326: PUSH
51327: LD_INT 4
51329: NEG
51330: PUSH
51331: EMPTY
51332: LIST
51333: LIST
51334: PUSH
51335: LD_INT 2
51337: PUSH
51338: LD_INT 2
51340: NEG
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: PUSH
51346: LD_INT 2
51348: NEG
51349: PUSH
51350: LD_INT 4
51352: NEG
51353: PUSH
51354: EMPTY
51355: LIST
51356: LIST
51357: PUSH
51358: LD_INT 4
51360: PUSH
51361: LD_INT 0
51363: PUSH
51364: EMPTY
51365: LIST
51366: LIST
51367: PUSH
51368: LD_INT 4
51370: PUSH
51371: LD_INT 1
51373: NEG
51374: PUSH
51375: EMPTY
51376: LIST
51377: LIST
51378: PUSH
51379: LD_INT 5
51381: PUSH
51382: LD_INT 0
51384: PUSH
51385: EMPTY
51386: LIST
51387: LIST
51388: PUSH
51389: LD_INT 5
51391: PUSH
51392: LD_INT 1
51394: PUSH
51395: EMPTY
51396: LIST
51397: LIST
51398: PUSH
51399: LD_INT 4
51401: PUSH
51402: LD_INT 1
51404: PUSH
51405: EMPTY
51406: LIST
51407: LIST
51408: PUSH
51409: LD_INT 3
51411: PUSH
51412: LD_INT 0
51414: PUSH
51415: EMPTY
51416: LIST
51417: LIST
51418: PUSH
51419: LD_INT 3
51421: PUSH
51422: LD_INT 1
51424: NEG
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 3
51432: PUSH
51433: LD_INT 2
51435: NEG
51436: PUSH
51437: EMPTY
51438: LIST
51439: LIST
51440: PUSH
51441: LD_INT 5
51443: PUSH
51444: LD_INT 2
51446: PUSH
51447: EMPTY
51448: LIST
51449: LIST
51450: PUSH
51451: LD_INT 3
51453: PUSH
51454: LD_INT 3
51456: PUSH
51457: EMPTY
51458: LIST
51459: LIST
51460: PUSH
51461: LD_INT 3
51463: PUSH
51464: LD_INT 2
51466: PUSH
51467: EMPTY
51468: LIST
51469: LIST
51470: PUSH
51471: LD_INT 4
51473: PUSH
51474: LD_INT 3
51476: PUSH
51477: EMPTY
51478: LIST
51479: LIST
51480: PUSH
51481: LD_INT 4
51483: PUSH
51484: LD_INT 4
51486: PUSH
51487: EMPTY
51488: LIST
51489: LIST
51490: PUSH
51491: LD_INT 3
51493: PUSH
51494: LD_INT 4
51496: PUSH
51497: EMPTY
51498: LIST
51499: LIST
51500: PUSH
51501: LD_INT 2
51503: PUSH
51504: LD_INT 3
51506: PUSH
51507: EMPTY
51508: LIST
51509: LIST
51510: PUSH
51511: LD_INT 2
51513: PUSH
51514: LD_INT 2
51516: PUSH
51517: EMPTY
51518: LIST
51519: LIST
51520: PUSH
51521: LD_INT 4
51523: PUSH
51524: LD_INT 2
51526: PUSH
51527: EMPTY
51528: LIST
51529: LIST
51530: PUSH
51531: LD_INT 2
51533: PUSH
51534: LD_INT 4
51536: PUSH
51537: EMPTY
51538: LIST
51539: LIST
51540: PUSH
51541: LD_INT 0
51543: PUSH
51544: LD_INT 4
51546: PUSH
51547: EMPTY
51548: LIST
51549: LIST
51550: PUSH
51551: LD_INT 0
51553: PUSH
51554: LD_INT 3
51556: PUSH
51557: EMPTY
51558: LIST
51559: LIST
51560: PUSH
51561: LD_INT 1
51563: PUSH
51564: LD_INT 4
51566: PUSH
51567: EMPTY
51568: LIST
51569: LIST
51570: PUSH
51571: LD_INT 1
51573: PUSH
51574: LD_INT 5
51576: PUSH
51577: EMPTY
51578: LIST
51579: LIST
51580: PUSH
51581: LD_INT 0
51583: PUSH
51584: LD_INT 5
51586: PUSH
51587: EMPTY
51588: LIST
51589: LIST
51590: PUSH
51591: LD_INT 1
51593: NEG
51594: PUSH
51595: LD_INT 4
51597: PUSH
51598: EMPTY
51599: LIST
51600: LIST
51601: PUSH
51602: LD_INT 1
51604: NEG
51605: PUSH
51606: LD_INT 3
51608: PUSH
51609: EMPTY
51610: LIST
51611: LIST
51612: PUSH
51613: LD_INT 2
51615: PUSH
51616: LD_INT 5
51618: PUSH
51619: EMPTY
51620: LIST
51621: LIST
51622: PUSH
51623: LD_INT 2
51625: NEG
51626: PUSH
51627: LD_INT 3
51629: PUSH
51630: EMPTY
51631: LIST
51632: LIST
51633: PUSH
51634: EMPTY
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: LIST
51650: LIST
51651: LIST
51652: LIST
51653: LIST
51654: LIST
51655: LIST
51656: LIST
51657: LIST
51658: LIST
51659: LIST
51660: LIST
51661: LIST
51662: LIST
51663: LIST
51664: LIST
51665: LIST
51666: LIST
51667: LIST
51668: LIST
51669: LIST
51670: LIST
51671: LIST
51672: LIST
51673: LIST
51674: LIST
51675: LIST
51676: LIST
51677: LIST
51678: LIST
51679: LIST
51680: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
51681: LD_ADDR_VAR 0 34
51685: PUSH
51686: LD_INT 0
51688: PUSH
51689: LD_INT 4
51691: NEG
51692: PUSH
51693: EMPTY
51694: LIST
51695: LIST
51696: PUSH
51697: LD_INT 0
51699: PUSH
51700: LD_INT 5
51702: NEG
51703: PUSH
51704: EMPTY
51705: LIST
51706: LIST
51707: PUSH
51708: LD_INT 1
51710: PUSH
51711: LD_INT 4
51713: NEG
51714: PUSH
51715: EMPTY
51716: LIST
51717: LIST
51718: PUSH
51719: LD_INT 1
51721: PUSH
51722: LD_INT 3
51724: NEG
51725: PUSH
51726: EMPTY
51727: LIST
51728: LIST
51729: PUSH
51730: LD_INT 0
51732: PUSH
51733: LD_INT 3
51735: NEG
51736: PUSH
51737: EMPTY
51738: LIST
51739: LIST
51740: PUSH
51741: LD_INT 1
51743: NEG
51744: PUSH
51745: LD_INT 4
51747: NEG
51748: PUSH
51749: EMPTY
51750: LIST
51751: LIST
51752: PUSH
51753: LD_INT 1
51755: NEG
51756: PUSH
51757: LD_INT 5
51759: NEG
51760: PUSH
51761: EMPTY
51762: LIST
51763: LIST
51764: PUSH
51765: LD_INT 2
51767: PUSH
51768: LD_INT 3
51770: NEG
51771: PUSH
51772: EMPTY
51773: LIST
51774: LIST
51775: PUSH
51776: LD_INT 2
51778: NEG
51779: PUSH
51780: LD_INT 5
51782: NEG
51783: PUSH
51784: EMPTY
51785: LIST
51786: LIST
51787: PUSH
51788: LD_INT 3
51790: PUSH
51791: LD_INT 0
51793: PUSH
51794: EMPTY
51795: LIST
51796: LIST
51797: PUSH
51798: LD_INT 3
51800: PUSH
51801: LD_INT 1
51803: NEG
51804: PUSH
51805: EMPTY
51806: LIST
51807: LIST
51808: PUSH
51809: LD_INT 4
51811: PUSH
51812: LD_INT 0
51814: PUSH
51815: EMPTY
51816: LIST
51817: LIST
51818: PUSH
51819: LD_INT 4
51821: PUSH
51822: LD_INT 1
51824: PUSH
51825: EMPTY
51826: LIST
51827: LIST
51828: PUSH
51829: LD_INT 3
51831: PUSH
51832: LD_INT 1
51834: PUSH
51835: EMPTY
51836: LIST
51837: LIST
51838: PUSH
51839: LD_INT 2
51841: PUSH
51842: LD_INT 0
51844: PUSH
51845: EMPTY
51846: LIST
51847: LIST
51848: PUSH
51849: LD_INT 2
51851: PUSH
51852: LD_INT 1
51854: NEG
51855: PUSH
51856: EMPTY
51857: LIST
51858: LIST
51859: PUSH
51860: LD_INT 2
51862: PUSH
51863: LD_INT 2
51865: NEG
51866: PUSH
51867: EMPTY
51868: LIST
51869: LIST
51870: PUSH
51871: LD_INT 4
51873: PUSH
51874: LD_INT 2
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: PUSH
51881: LD_INT 4
51883: PUSH
51884: LD_INT 4
51886: PUSH
51887: EMPTY
51888: LIST
51889: LIST
51890: PUSH
51891: LD_INT 4
51893: PUSH
51894: LD_INT 3
51896: PUSH
51897: EMPTY
51898: LIST
51899: LIST
51900: PUSH
51901: LD_INT 5
51903: PUSH
51904: LD_INT 4
51906: PUSH
51907: EMPTY
51908: LIST
51909: LIST
51910: PUSH
51911: LD_INT 5
51913: PUSH
51914: LD_INT 5
51916: PUSH
51917: EMPTY
51918: LIST
51919: LIST
51920: PUSH
51921: LD_INT 4
51923: PUSH
51924: LD_INT 5
51926: PUSH
51927: EMPTY
51928: LIST
51929: LIST
51930: PUSH
51931: LD_INT 3
51933: PUSH
51934: LD_INT 4
51936: PUSH
51937: EMPTY
51938: LIST
51939: LIST
51940: PUSH
51941: LD_INT 3
51943: PUSH
51944: LD_INT 3
51946: PUSH
51947: EMPTY
51948: LIST
51949: LIST
51950: PUSH
51951: LD_INT 5
51953: PUSH
51954: LD_INT 3
51956: PUSH
51957: EMPTY
51958: LIST
51959: LIST
51960: PUSH
51961: LD_INT 3
51963: PUSH
51964: LD_INT 5
51966: PUSH
51967: EMPTY
51968: LIST
51969: LIST
51970: PUSH
51971: LD_INT 0
51973: PUSH
51974: LD_INT 3
51976: PUSH
51977: EMPTY
51978: LIST
51979: LIST
51980: PUSH
51981: LD_INT 0
51983: PUSH
51984: LD_INT 2
51986: PUSH
51987: EMPTY
51988: LIST
51989: LIST
51990: PUSH
51991: LD_INT 1
51993: PUSH
51994: LD_INT 3
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: PUSH
52001: LD_INT 1
52003: PUSH
52004: LD_INT 4
52006: PUSH
52007: EMPTY
52008: LIST
52009: LIST
52010: PUSH
52011: LD_INT 0
52013: PUSH
52014: LD_INT 4
52016: PUSH
52017: EMPTY
52018: LIST
52019: LIST
52020: PUSH
52021: LD_INT 1
52023: NEG
52024: PUSH
52025: LD_INT 3
52027: PUSH
52028: EMPTY
52029: LIST
52030: LIST
52031: PUSH
52032: LD_INT 1
52034: NEG
52035: PUSH
52036: LD_INT 2
52038: PUSH
52039: EMPTY
52040: LIST
52041: LIST
52042: PUSH
52043: LD_INT 2
52045: PUSH
52046: LD_INT 4
52048: PUSH
52049: EMPTY
52050: LIST
52051: LIST
52052: PUSH
52053: LD_INT 2
52055: NEG
52056: PUSH
52057: LD_INT 2
52059: PUSH
52060: EMPTY
52061: LIST
52062: LIST
52063: PUSH
52064: LD_INT 4
52066: NEG
52067: PUSH
52068: LD_INT 0
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: PUSH
52075: LD_INT 4
52077: NEG
52078: PUSH
52079: LD_INT 1
52081: NEG
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: PUSH
52087: LD_INT 3
52089: NEG
52090: PUSH
52091: LD_INT 0
52093: PUSH
52094: EMPTY
52095: LIST
52096: LIST
52097: PUSH
52098: LD_INT 3
52100: NEG
52101: PUSH
52102: LD_INT 1
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: PUSH
52109: LD_INT 4
52111: NEG
52112: PUSH
52113: LD_INT 1
52115: PUSH
52116: EMPTY
52117: LIST
52118: LIST
52119: PUSH
52120: LD_INT 5
52122: NEG
52123: PUSH
52124: LD_INT 0
52126: PUSH
52127: EMPTY
52128: LIST
52129: LIST
52130: PUSH
52131: LD_INT 5
52133: NEG
52134: PUSH
52135: LD_INT 1
52137: NEG
52138: PUSH
52139: EMPTY
52140: LIST
52141: LIST
52142: PUSH
52143: LD_INT 5
52145: NEG
52146: PUSH
52147: LD_INT 2
52149: NEG
52150: PUSH
52151: EMPTY
52152: LIST
52153: LIST
52154: PUSH
52155: LD_INT 3
52157: NEG
52158: PUSH
52159: LD_INT 2
52161: PUSH
52162: EMPTY
52163: LIST
52164: LIST
52165: PUSH
52166: EMPTY
52167: LIST
52168: LIST
52169: LIST
52170: LIST
52171: LIST
52172: LIST
52173: LIST
52174: LIST
52175: LIST
52176: LIST
52177: LIST
52178: LIST
52179: LIST
52180: LIST
52181: LIST
52182: LIST
52183: LIST
52184: LIST
52185: LIST
52186: LIST
52187: LIST
52188: LIST
52189: LIST
52190: LIST
52191: LIST
52192: LIST
52193: LIST
52194: LIST
52195: LIST
52196: LIST
52197: LIST
52198: LIST
52199: LIST
52200: LIST
52201: LIST
52202: LIST
52203: LIST
52204: LIST
52205: LIST
52206: LIST
52207: LIST
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: ST_TO_ADDR
// end ; end ;
52213: GO 52216
52215: POP
// case btype of b_depot , b_warehouse :
52216: LD_VAR 0 1
52220: PUSH
52221: LD_INT 0
52223: DOUBLE
52224: EQUAL
52225: IFTRUE 52235
52227: LD_INT 1
52229: DOUBLE
52230: EQUAL
52231: IFTRUE 52235
52233: GO 52436
52235: POP
// case nation of nation_american :
52236: LD_VAR 0 5
52240: PUSH
52241: LD_INT 1
52243: DOUBLE
52244: EQUAL
52245: IFTRUE 52249
52247: GO 52305
52249: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
52250: LD_ADDR_VAR 0 9
52254: PUSH
52255: LD_VAR 0 11
52259: PUSH
52260: LD_VAR 0 12
52264: PUSH
52265: LD_VAR 0 13
52269: PUSH
52270: LD_VAR 0 14
52274: PUSH
52275: LD_VAR 0 15
52279: PUSH
52280: LD_VAR 0 16
52284: PUSH
52285: EMPTY
52286: LIST
52287: LIST
52288: LIST
52289: LIST
52290: LIST
52291: LIST
52292: PUSH
52293: LD_VAR 0 4
52297: PUSH
52298: LD_INT 1
52300: PLUS
52301: ARRAY
52302: ST_TO_ADDR
52303: GO 52434
52305: LD_INT 2
52307: DOUBLE
52308: EQUAL
52309: IFTRUE 52313
52311: GO 52369
52313: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
52314: LD_ADDR_VAR 0 9
52318: PUSH
52319: LD_VAR 0 17
52323: PUSH
52324: LD_VAR 0 18
52328: PUSH
52329: LD_VAR 0 19
52333: PUSH
52334: LD_VAR 0 20
52338: PUSH
52339: LD_VAR 0 21
52343: PUSH
52344: LD_VAR 0 22
52348: PUSH
52349: EMPTY
52350: LIST
52351: LIST
52352: LIST
52353: LIST
52354: LIST
52355: LIST
52356: PUSH
52357: LD_VAR 0 4
52361: PUSH
52362: LD_INT 1
52364: PLUS
52365: ARRAY
52366: ST_TO_ADDR
52367: GO 52434
52369: LD_INT 3
52371: DOUBLE
52372: EQUAL
52373: IFTRUE 52377
52375: GO 52433
52377: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
52378: LD_ADDR_VAR 0 9
52382: PUSH
52383: LD_VAR 0 23
52387: PUSH
52388: LD_VAR 0 24
52392: PUSH
52393: LD_VAR 0 25
52397: PUSH
52398: LD_VAR 0 26
52402: PUSH
52403: LD_VAR 0 27
52407: PUSH
52408: LD_VAR 0 28
52412: PUSH
52413: EMPTY
52414: LIST
52415: LIST
52416: LIST
52417: LIST
52418: LIST
52419: LIST
52420: PUSH
52421: LD_VAR 0 4
52425: PUSH
52426: LD_INT 1
52428: PLUS
52429: ARRAY
52430: ST_TO_ADDR
52431: GO 52434
52433: POP
52434: GO 52989
52436: LD_INT 2
52438: DOUBLE
52439: EQUAL
52440: IFTRUE 52450
52442: LD_INT 3
52444: DOUBLE
52445: EQUAL
52446: IFTRUE 52450
52448: GO 52506
52450: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
52451: LD_ADDR_VAR 0 9
52455: PUSH
52456: LD_VAR 0 29
52460: PUSH
52461: LD_VAR 0 30
52465: PUSH
52466: LD_VAR 0 31
52470: PUSH
52471: LD_VAR 0 32
52475: PUSH
52476: LD_VAR 0 33
52480: PUSH
52481: LD_VAR 0 34
52485: PUSH
52486: EMPTY
52487: LIST
52488: LIST
52489: LIST
52490: LIST
52491: LIST
52492: LIST
52493: PUSH
52494: LD_VAR 0 4
52498: PUSH
52499: LD_INT 1
52501: PLUS
52502: ARRAY
52503: ST_TO_ADDR
52504: GO 52989
52506: LD_INT 16
52508: DOUBLE
52509: EQUAL
52510: IFTRUE 52568
52512: LD_INT 17
52514: DOUBLE
52515: EQUAL
52516: IFTRUE 52568
52518: LD_INT 18
52520: DOUBLE
52521: EQUAL
52522: IFTRUE 52568
52524: LD_INT 19
52526: DOUBLE
52527: EQUAL
52528: IFTRUE 52568
52530: LD_INT 22
52532: DOUBLE
52533: EQUAL
52534: IFTRUE 52568
52536: LD_INT 20
52538: DOUBLE
52539: EQUAL
52540: IFTRUE 52568
52542: LD_INT 21
52544: DOUBLE
52545: EQUAL
52546: IFTRUE 52568
52548: LD_INT 23
52550: DOUBLE
52551: EQUAL
52552: IFTRUE 52568
52554: LD_INT 24
52556: DOUBLE
52557: EQUAL
52558: IFTRUE 52568
52560: LD_INT 25
52562: DOUBLE
52563: EQUAL
52564: IFTRUE 52568
52566: GO 52624
52568: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
52569: LD_ADDR_VAR 0 9
52573: PUSH
52574: LD_VAR 0 35
52578: PUSH
52579: LD_VAR 0 36
52583: PUSH
52584: LD_VAR 0 37
52588: PUSH
52589: LD_VAR 0 38
52593: PUSH
52594: LD_VAR 0 39
52598: PUSH
52599: LD_VAR 0 40
52603: PUSH
52604: EMPTY
52605: LIST
52606: LIST
52607: LIST
52608: LIST
52609: LIST
52610: LIST
52611: PUSH
52612: LD_VAR 0 4
52616: PUSH
52617: LD_INT 1
52619: PLUS
52620: ARRAY
52621: ST_TO_ADDR
52622: GO 52989
52624: LD_INT 6
52626: DOUBLE
52627: EQUAL
52628: IFTRUE 52680
52630: LD_INT 7
52632: DOUBLE
52633: EQUAL
52634: IFTRUE 52680
52636: LD_INT 8
52638: DOUBLE
52639: EQUAL
52640: IFTRUE 52680
52642: LD_INT 13
52644: DOUBLE
52645: EQUAL
52646: IFTRUE 52680
52648: LD_INT 12
52650: DOUBLE
52651: EQUAL
52652: IFTRUE 52680
52654: LD_INT 15
52656: DOUBLE
52657: EQUAL
52658: IFTRUE 52680
52660: LD_INT 11
52662: DOUBLE
52663: EQUAL
52664: IFTRUE 52680
52666: LD_INT 14
52668: DOUBLE
52669: EQUAL
52670: IFTRUE 52680
52672: LD_INT 10
52674: DOUBLE
52675: EQUAL
52676: IFTRUE 52680
52678: GO 52736
52680: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
52681: LD_ADDR_VAR 0 9
52685: PUSH
52686: LD_VAR 0 41
52690: PUSH
52691: LD_VAR 0 42
52695: PUSH
52696: LD_VAR 0 43
52700: PUSH
52701: LD_VAR 0 44
52705: PUSH
52706: LD_VAR 0 45
52710: PUSH
52711: LD_VAR 0 46
52715: PUSH
52716: EMPTY
52717: LIST
52718: LIST
52719: LIST
52720: LIST
52721: LIST
52722: LIST
52723: PUSH
52724: LD_VAR 0 4
52728: PUSH
52729: LD_INT 1
52731: PLUS
52732: ARRAY
52733: ST_TO_ADDR
52734: GO 52989
52736: LD_INT 36
52738: DOUBLE
52739: EQUAL
52740: IFTRUE 52744
52742: GO 52800
52744: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52745: LD_ADDR_VAR 0 9
52749: PUSH
52750: LD_VAR 0 47
52754: PUSH
52755: LD_VAR 0 48
52759: PUSH
52760: LD_VAR 0 49
52764: PUSH
52765: LD_VAR 0 50
52769: PUSH
52770: LD_VAR 0 51
52774: PUSH
52775: LD_VAR 0 52
52779: PUSH
52780: EMPTY
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: LIST
52787: PUSH
52788: LD_VAR 0 4
52792: PUSH
52793: LD_INT 1
52795: PLUS
52796: ARRAY
52797: ST_TO_ADDR
52798: GO 52989
52800: LD_INT 4
52802: DOUBLE
52803: EQUAL
52804: IFTRUE 52826
52806: LD_INT 5
52808: DOUBLE
52809: EQUAL
52810: IFTRUE 52826
52812: LD_INT 34
52814: DOUBLE
52815: EQUAL
52816: IFTRUE 52826
52818: LD_INT 37
52820: DOUBLE
52821: EQUAL
52822: IFTRUE 52826
52824: GO 52882
52826: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52827: LD_ADDR_VAR 0 9
52831: PUSH
52832: LD_VAR 0 53
52836: PUSH
52837: LD_VAR 0 54
52841: PUSH
52842: LD_VAR 0 55
52846: PUSH
52847: LD_VAR 0 56
52851: PUSH
52852: LD_VAR 0 57
52856: PUSH
52857: LD_VAR 0 58
52861: PUSH
52862: EMPTY
52863: LIST
52864: LIST
52865: LIST
52866: LIST
52867: LIST
52868: LIST
52869: PUSH
52870: LD_VAR 0 4
52874: PUSH
52875: LD_INT 1
52877: PLUS
52878: ARRAY
52879: ST_TO_ADDR
52880: GO 52989
52882: LD_INT 31
52884: DOUBLE
52885: EQUAL
52886: IFTRUE 52932
52888: LD_INT 32
52890: DOUBLE
52891: EQUAL
52892: IFTRUE 52932
52894: LD_INT 33
52896: DOUBLE
52897: EQUAL
52898: IFTRUE 52932
52900: LD_INT 27
52902: DOUBLE
52903: EQUAL
52904: IFTRUE 52932
52906: LD_INT 26
52908: DOUBLE
52909: EQUAL
52910: IFTRUE 52932
52912: LD_INT 28
52914: DOUBLE
52915: EQUAL
52916: IFTRUE 52932
52918: LD_INT 29
52920: DOUBLE
52921: EQUAL
52922: IFTRUE 52932
52924: LD_INT 30
52926: DOUBLE
52927: EQUAL
52928: IFTRUE 52932
52930: GO 52988
52932: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52933: LD_ADDR_VAR 0 9
52937: PUSH
52938: LD_VAR 0 59
52942: PUSH
52943: LD_VAR 0 60
52947: PUSH
52948: LD_VAR 0 61
52952: PUSH
52953: LD_VAR 0 62
52957: PUSH
52958: LD_VAR 0 63
52962: PUSH
52963: LD_VAR 0 64
52967: PUSH
52968: EMPTY
52969: LIST
52970: LIST
52971: LIST
52972: LIST
52973: LIST
52974: LIST
52975: PUSH
52976: LD_VAR 0 4
52980: PUSH
52981: LD_INT 1
52983: PLUS
52984: ARRAY
52985: ST_TO_ADDR
52986: GO 52989
52988: POP
// temp_list2 = [ ] ;
52989: LD_ADDR_VAR 0 10
52993: PUSH
52994: EMPTY
52995: ST_TO_ADDR
// for i in temp_list do
52996: LD_ADDR_VAR 0 8
53000: PUSH
53001: LD_VAR 0 9
53005: PUSH
53006: FOR_IN
53007: IFFALSE 53059
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
53009: LD_ADDR_VAR 0 10
53013: PUSH
53014: LD_VAR 0 10
53018: PUSH
53019: LD_VAR 0 8
53023: PUSH
53024: LD_INT 1
53026: ARRAY
53027: PUSH
53028: LD_VAR 0 2
53032: PLUS
53033: PUSH
53034: LD_VAR 0 8
53038: PUSH
53039: LD_INT 2
53041: ARRAY
53042: PUSH
53043: LD_VAR 0 3
53047: PLUS
53048: PUSH
53049: EMPTY
53050: LIST
53051: LIST
53052: PUSH
53053: EMPTY
53054: LIST
53055: ADD
53056: ST_TO_ADDR
53057: GO 53006
53059: POP
53060: POP
// result = temp_list2 ;
53061: LD_ADDR_VAR 0 7
53065: PUSH
53066: LD_VAR 0 10
53070: ST_TO_ADDR
// end ;
53071: LD_VAR 0 7
53075: RET
// export function EnemyInRange ( unit , dist ) ; begin
53076: LD_INT 0
53078: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
53079: LD_ADDR_VAR 0 3
53083: PUSH
53084: LD_VAR 0 1
53088: PPUSH
53089: CALL_OW 255
53093: PPUSH
53094: LD_VAR 0 1
53098: PPUSH
53099: CALL_OW 250
53103: PPUSH
53104: LD_VAR 0 1
53108: PPUSH
53109: CALL_OW 251
53113: PPUSH
53114: LD_VAR 0 2
53118: PPUSH
53119: CALL 26333 0 4
53123: PUSH
53124: LD_INT 4
53126: ARRAY
53127: ST_TO_ADDR
// end ;
53128: LD_VAR 0 3
53132: RET
// export function PlayerSeeMe ( unit ) ; begin
53133: LD_INT 0
53135: PPUSH
// result := See ( your_side , unit ) ;
53136: LD_ADDR_VAR 0 2
53140: PUSH
53141: LD_OWVAR 2
53145: PPUSH
53146: LD_VAR 0 1
53150: PPUSH
53151: CALL_OW 292
53155: ST_TO_ADDR
// end ;
53156: LD_VAR 0 2
53160: RET
// export function ReverseDir ( unit ) ; begin
53161: LD_INT 0
53163: PPUSH
// if not unit then
53164: LD_VAR 0 1
53168: NOT
53169: IFFALSE 53173
// exit ;
53171: GO 53196
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
53173: LD_ADDR_VAR 0 2
53177: PUSH
53178: LD_VAR 0 1
53182: PPUSH
53183: CALL_OW 254
53187: PUSH
53188: LD_INT 3
53190: PLUS
53191: PUSH
53192: LD_INT 6
53194: MOD
53195: ST_TO_ADDR
// end ;
53196: LD_VAR 0 2
53200: RET
// export function ReverseArray ( array ) ; var i ; begin
53201: LD_INT 0
53203: PPUSH
53204: PPUSH
// if not array then
53205: LD_VAR 0 1
53209: NOT
53210: IFFALSE 53214
// exit ;
53212: GO 53269
// result := [ ] ;
53214: LD_ADDR_VAR 0 2
53218: PUSH
53219: EMPTY
53220: ST_TO_ADDR
// for i := array downto 1 do
53221: LD_ADDR_VAR 0 3
53225: PUSH
53226: DOUBLE
53227: LD_VAR 0 1
53231: INC
53232: ST_TO_ADDR
53233: LD_INT 1
53235: PUSH
53236: FOR_DOWNTO
53237: IFFALSE 53267
// result := Join ( result , array [ i ] ) ;
53239: LD_ADDR_VAR 0 2
53243: PUSH
53244: LD_VAR 0 2
53248: PPUSH
53249: LD_VAR 0 1
53253: PUSH
53254: LD_VAR 0 3
53258: ARRAY
53259: PPUSH
53260: CALL 58111 0 2
53264: ST_TO_ADDR
53265: GO 53236
53267: POP
53268: POP
// end ;
53269: LD_VAR 0 2
53273: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
53274: LD_INT 0
53276: PPUSH
53277: PPUSH
53278: PPUSH
53279: PPUSH
53280: PPUSH
53281: PPUSH
// if not unit or not hexes then
53282: LD_VAR 0 1
53286: NOT
53287: IFTRUE 53296
53289: PUSH
53290: LD_VAR 0 2
53294: NOT
53295: OR
53296: IFFALSE 53300
// exit ;
53298: GO 53423
// dist := 9999 ;
53300: LD_ADDR_VAR 0 5
53304: PUSH
53305: LD_INT 9999
53307: ST_TO_ADDR
// for i = 1 to hexes do
53308: LD_ADDR_VAR 0 4
53312: PUSH
53313: DOUBLE
53314: LD_INT 1
53316: DEC
53317: ST_TO_ADDR
53318: LD_VAR 0 2
53322: PUSH
53323: FOR_TO
53324: IFFALSE 53411
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
53326: LD_ADDR_VAR 0 6
53330: PUSH
53331: LD_VAR 0 1
53335: PPUSH
53336: LD_VAR 0 2
53340: PUSH
53341: LD_VAR 0 4
53345: ARRAY
53346: PUSH
53347: LD_INT 1
53349: ARRAY
53350: PPUSH
53351: LD_VAR 0 2
53355: PUSH
53356: LD_VAR 0 4
53360: ARRAY
53361: PUSH
53362: LD_INT 2
53364: ARRAY
53365: PPUSH
53366: CALL_OW 297
53370: ST_TO_ADDR
// if tdist < dist then
53371: LD_VAR 0 6
53375: PUSH
53376: LD_VAR 0 5
53380: LESS
53381: IFFALSE 53409
// begin hex := hexes [ i ] ;
53383: LD_ADDR_VAR 0 8
53387: PUSH
53388: LD_VAR 0 2
53392: PUSH
53393: LD_VAR 0 4
53397: ARRAY
53398: ST_TO_ADDR
// dist := tdist ;
53399: LD_ADDR_VAR 0 5
53403: PUSH
53404: LD_VAR 0 6
53408: ST_TO_ADDR
// end ; end ;
53409: GO 53323
53411: POP
53412: POP
// result := hex ;
53413: LD_ADDR_VAR 0 3
53417: PUSH
53418: LD_VAR 0 8
53422: ST_TO_ADDR
// end ;
53423: LD_VAR 0 3
53427: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
53428: LD_INT 0
53430: PPUSH
53431: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53432: LD_VAR 0 1
53436: NOT
53437: IFTRUE 53476
53439: PUSH
53440: LD_VAR 0 1
53444: PUSH
53445: LD_INT 21
53447: PUSH
53448: LD_INT 2
53450: PUSH
53451: EMPTY
53452: LIST
53453: LIST
53454: PUSH
53455: LD_INT 23
53457: PUSH
53458: LD_INT 2
53460: PUSH
53461: EMPTY
53462: LIST
53463: LIST
53464: PUSH
53465: EMPTY
53466: LIST
53467: LIST
53468: PPUSH
53469: CALL_OW 69
53473: IN
53474: NOT
53475: OR
53476: IFFALSE 53480
// exit ;
53478: GO 53527
// for i = 1 to 3 do
53480: LD_ADDR_VAR 0 3
53484: PUSH
53485: DOUBLE
53486: LD_INT 1
53488: DEC
53489: ST_TO_ADDR
53490: LD_INT 3
53492: PUSH
53493: FOR_TO
53494: IFFALSE 53525
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
53496: LD_VAR 0 1
53500: PPUSH
53501: CALL_OW 250
53505: PPUSH
53506: LD_VAR 0 1
53510: PPUSH
53511: CALL_OW 251
53515: PPUSH
53516: LD_INT 1
53518: PPUSH
53519: CALL_OW 453
53523: GO 53493
53525: POP
53526: POP
// end ;
53527: LD_VAR 0 2
53531: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
53532: LD_INT 0
53534: PPUSH
53535: PPUSH
53536: PPUSH
53537: PPUSH
53538: PPUSH
53539: PPUSH
// if not unit or not enemy_unit then
53540: LD_VAR 0 1
53544: NOT
53545: IFTRUE 53554
53547: PUSH
53548: LD_VAR 0 2
53552: NOT
53553: OR
53554: IFFALSE 53558
// exit ;
53556: GO 54029
// if GetLives ( i ) < 250 then
53558: LD_VAR 0 4
53562: PPUSH
53563: CALL_OW 256
53567: PUSH
53568: LD_INT 250
53570: LESS
53571: IFFALSE 53584
// begin ComAutodestruct ( i ) ;
53573: LD_VAR 0 4
53577: PPUSH
53578: CALL 53428 0 1
// exit ;
53582: GO 54029
// end ; x := GetX ( enemy_unit ) ;
53584: LD_ADDR_VAR 0 7
53588: PUSH
53589: LD_VAR 0 2
53593: PPUSH
53594: CALL_OW 250
53598: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
53599: LD_ADDR_VAR 0 8
53603: PUSH
53604: LD_VAR 0 2
53608: PPUSH
53609: CALL_OW 251
53613: ST_TO_ADDR
// if not x or not y then
53614: LD_VAR 0 7
53618: NOT
53619: IFTRUE 53628
53621: PUSH
53622: LD_VAR 0 8
53626: NOT
53627: OR
53628: IFFALSE 53632
// exit ;
53630: GO 54029
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
53632: LD_ADDR_VAR 0 6
53636: PUSH
53637: LD_VAR 0 7
53641: PPUSH
53642: LD_INT 0
53644: PPUSH
53645: LD_INT 4
53647: PPUSH
53648: CALL_OW 272
53652: PUSH
53653: LD_VAR 0 8
53657: PPUSH
53658: LD_INT 0
53660: PPUSH
53661: LD_INT 4
53663: PPUSH
53664: CALL_OW 273
53668: PUSH
53669: EMPTY
53670: LIST
53671: LIST
53672: PUSH
53673: LD_VAR 0 7
53677: PPUSH
53678: LD_INT 1
53680: PPUSH
53681: LD_INT 4
53683: PPUSH
53684: CALL_OW 272
53688: PUSH
53689: LD_VAR 0 8
53693: PPUSH
53694: LD_INT 1
53696: PPUSH
53697: LD_INT 4
53699: PPUSH
53700: CALL_OW 273
53704: PUSH
53705: EMPTY
53706: LIST
53707: LIST
53708: PUSH
53709: LD_VAR 0 7
53713: PPUSH
53714: LD_INT 2
53716: PPUSH
53717: LD_INT 4
53719: PPUSH
53720: CALL_OW 272
53724: PUSH
53725: LD_VAR 0 8
53729: PPUSH
53730: LD_INT 2
53732: PPUSH
53733: LD_INT 4
53735: PPUSH
53736: CALL_OW 273
53740: PUSH
53741: EMPTY
53742: LIST
53743: LIST
53744: PUSH
53745: LD_VAR 0 7
53749: PPUSH
53750: LD_INT 3
53752: PPUSH
53753: LD_INT 4
53755: PPUSH
53756: CALL_OW 272
53760: PUSH
53761: LD_VAR 0 8
53765: PPUSH
53766: LD_INT 3
53768: PPUSH
53769: LD_INT 4
53771: PPUSH
53772: CALL_OW 273
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: PUSH
53781: LD_VAR 0 7
53785: PPUSH
53786: LD_INT 4
53788: PPUSH
53789: LD_INT 4
53791: PPUSH
53792: CALL_OW 272
53796: PUSH
53797: LD_VAR 0 8
53801: PPUSH
53802: LD_INT 4
53804: PPUSH
53805: LD_INT 4
53807: PPUSH
53808: CALL_OW 273
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: PUSH
53817: LD_VAR 0 7
53821: PPUSH
53822: LD_INT 5
53824: PPUSH
53825: LD_INT 4
53827: PPUSH
53828: CALL_OW 272
53832: PUSH
53833: LD_VAR 0 8
53837: PPUSH
53838: LD_INT 5
53840: PPUSH
53841: LD_INT 4
53843: PPUSH
53844: CALL_OW 273
53848: PUSH
53849: EMPTY
53850: LIST
53851: LIST
53852: PUSH
53853: EMPTY
53854: LIST
53855: LIST
53856: LIST
53857: LIST
53858: LIST
53859: LIST
53860: ST_TO_ADDR
// for i = tmp downto 1 do
53861: LD_ADDR_VAR 0 4
53865: PUSH
53866: DOUBLE
53867: LD_VAR 0 6
53871: INC
53872: ST_TO_ADDR
53873: LD_INT 1
53875: PUSH
53876: FOR_DOWNTO
53877: IFFALSE 53980
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53879: LD_VAR 0 6
53883: PUSH
53884: LD_VAR 0 4
53888: ARRAY
53889: PUSH
53890: LD_INT 1
53892: ARRAY
53893: PPUSH
53894: LD_VAR 0 6
53898: PUSH
53899: LD_VAR 0 4
53903: ARRAY
53904: PUSH
53905: LD_INT 2
53907: ARRAY
53908: PPUSH
53909: CALL_OW 488
53913: NOT
53914: IFTRUE 53956
53916: PUSH
53917: LD_VAR 0 6
53921: PUSH
53922: LD_VAR 0 4
53926: ARRAY
53927: PUSH
53928: LD_INT 1
53930: ARRAY
53931: PPUSH
53932: LD_VAR 0 6
53936: PUSH
53937: LD_VAR 0 4
53941: ARRAY
53942: PUSH
53943: LD_INT 2
53945: ARRAY
53946: PPUSH
53947: CALL_OW 428
53951: PUSH
53952: LD_INT 0
53954: NONEQUAL
53955: OR
53956: IFFALSE 53978
// tmp := Delete ( tmp , i ) ;
53958: LD_ADDR_VAR 0 6
53962: PUSH
53963: LD_VAR 0 6
53967: PPUSH
53968: LD_VAR 0 4
53972: PPUSH
53973: CALL_OW 3
53977: ST_TO_ADDR
53978: GO 53876
53980: POP
53981: POP
// j := GetClosestHex ( unit , tmp ) ;
53982: LD_ADDR_VAR 0 5
53986: PUSH
53987: LD_VAR 0 1
53991: PPUSH
53992: LD_VAR 0 6
53996: PPUSH
53997: CALL 53274 0 2
54001: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
54002: LD_VAR 0 1
54006: PPUSH
54007: LD_VAR 0 5
54011: PUSH
54012: LD_INT 1
54014: ARRAY
54015: PPUSH
54016: LD_VAR 0 5
54020: PUSH
54021: LD_INT 2
54023: ARRAY
54024: PPUSH
54025: CALL_OW 111
// end ;
54029: LD_VAR 0 3
54033: RET
// export function PrepareApemanSoldier ( ) ; begin
54034: LD_INT 0
54036: PPUSH
// uc_nation := 0 ;
54037: LD_ADDR_OWVAR 21
54041: PUSH
54042: LD_INT 0
54044: ST_TO_ADDR
// hc_sex := sex_male ;
54045: LD_ADDR_OWVAR 27
54049: PUSH
54050: LD_INT 1
54052: ST_TO_ADDR
// hc_name :=  ;
54053: LD_ADDR_OWVAR 26
54057: PUSH
54058: LD_STRING 
54060: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
54061: LD_ADDR_OWVAR 28
54065: PUSH
54066: LD_INT 15
54068: ST_TO_ADDR
// hc_gallery :=  ;
54069: LD_ADDR_OWVAR 33
54073: PUSH
54074: LD_STRING 
54076: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
54077: LD_ADDR_OWVAR 31
54081: PUSH
54082: LD_INT 0
54084: PPUSH
54085: LD_INT 3
54087: PPUSH
54088: CALL_OW 12
54092: PUSH
54093: LD_INT 0
54095: PPUSH
54096: LD_INT 3
54098: PPUSH
54099: CALL_OW 12
54103: PUSH
54104: LD_INT 0
54106: PUSH
54107: LD_INT 0
54109: PUSH
54110: EMPTY
54111: LIST
54112: LIST
54113: LIST
54114: LIST
54115: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
54116: LD_ADDR_OWVAR 29
54120: PUSH
54121: LD_INT 12
54123: PUSH
54124: LD_INT 12
54126: PUSH
54127: EMPTY
54128: LIST
54129: LIST
54130: ST_TO_ADDR
// end ;
54131: LD_VAR 0 1
54135: RET
// export function PrepareApemanEngineer ( ) ; begin
54136: LD_INT 0
54138: PPUSH
// uc_nation := 0 ;
54139: LD_ADDR_OWVAR 21
54143: PUSH
54144: LD_INT 0
54146: ST_TO_ADDR
// hc_sex := sex_male ;
54147: LD_ADDR_OWVAR 27
54151: PUSH
54152: LD_INT 1
54154: ST_TO_ADDR
// hc_name :=  ;
54155: LD_ADDR_OWVAR 26
54159: PUSH
54160: LD_STRING 
54162: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
54163: LD_ADDR_OWVAR 28
54167: PUSH
54168: LD_INT 16
54170: ST_TO_ADDR
// hc_gallery :=  ;
54171: LD_ADDR_OWVAR 33
54175: PUSH
54176: LD_STRING 
54178: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
54179: LD_ADDR_OWVAR 31
54183: PUSH
54184: LD_INT 0
54186: PPUSH
54187: LD_INT 3
54189: PPUSH
54190: CALL_OW 12
54194: PUSH
54195: LD_INT 0
54197: PPUSH
54198: LD_INT 3
54200: PPUSH
54201: CALL_OW 12
54205: PUSH
54206: LD_INT 0
54208: PUSH
54209: LD_INT 0
54211: PUSH
54212: EMPTY
54213: LIST
54214: LIST
54215: LIST
54216: LIST
54217: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
54218: LD_ADDR_OWVAR 29
54222: PUSH
54223: LD_INT 12
54225: PUSH
54226: LD_INT 12
54228: PUSH
54229: EMPTY
54230: LIST
54231: LIST
54232: ST_TO_ADDR
// end ;
54233: LD_VAR 0 1
54237: RET
// export function PrepareApeman ( agressivity ) ; begin
54238: LD_INT 0
54240: PPUSH
// uc_side := 0 ;
54241: LD_ADDR_OWVAR 20
54245: PUSH
54246: LD_INT 0
54248: ST_TO_ADDR
// uc_nation := 0 ;
54249: LD_ADDR_OWVAR 21
54253: PUSH
54254: LD_INT 0
54256: ST_TO_ADDR
// hc_sex := sex_male ;
54257: LD_ADDR_OWVAR 27
54261: PUSH
54262: LD_INT 1
54264: ST_TO_ADDR
// hc_class := class_apeman ;
54265: LD_ADDR_OWVAR 28
54269: PUSH
54270: LD_INT 12
54272: ST_TO_ADDR
// hc_gallery :=  ;
54273: LD_ADDR_OWVAR 33
54277: PUSH
54278: LD_STRING 
54280: ST_TO_ADDR
// hc_name :=  ;
54281: LD_ADDR_OWVAR 26
54285: PUSH
54286: LD_STRING 
54288: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
54289: LD_ADDR_OWVAR 29
54293: PUSH
54294: LD_INT 12
54296: PUSH
54297: LD_INT 12
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: ST_TO_ADDR
// if agressivity = 0 then
54304: LD_VAR 0 1
54308: PUSH
54309: LD_INT 0
54311: EQUAL
54312: IFFALSE 54324
// hc_agressivity := 0 else
54314: LD_ADDR_OWVAR 35
54318: PUSH
54319: LD_INT 0
54321: ST_TO_ADDR
54322: GO 54345
// hc_agressivity := rand ( - agressivity , agressivity ) ;
54324: LD_ADDR_OWVAR 35
54328: PUSH
54329: LD_VAR 0 1
54333: NEG
54334: PPUSH
54335: LD_VAR 0 1
54339: PPUSH
54340: CALL_OW 12
54344: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
54345: LD_ADDR_OWVAR 31
54349: PUSH
54350: LD_INT 0
54352: PPUSH
54353: LD_INT 3
54355: PPUSH
54356: CALL_OW 12
54360: PUSH
54361: LD_INT 0
54363: PPUSH
54364: LD_INT 3
54366: PPUSH
54367: CALL_OW 12
54371: PUSH
54372: LD_INT 0
54374: PUSH
54375: LD_INT 0
54377: PUSH
54378: EMPTY
54379: LIST
54380: LIST
54381: LIST
54382: LIST
54383: ST_TO_ADDR
// end ;
54384: LD_VAR 0 2
54388: RET
// export function PrepareTiger ( agressivity ) ; begin
54389: LD_INT 0
54391: PPUSH
// uc_side := 0 ;
54392: LD_ADDR_OWVAR 20
54396: PUSH
54397: LD_INT 0
54399: ST_TO_ADDR
// uc_nation := 0 ;
54400: LD_ADDR_OWVAR 21
54404: PUSH
54405: LD_INT 0
54407: ST_TO_ADDR
// InitHc ;
54408: CALL_OW 19
// hc_class := class_tiger ;
54412: LD_ADDR_OWVAR 28
54416: PUSH
54417: LD_INT 14
54419: ST_TO_ADDR
// hc_gallery :=  ;
54420: LD_ADDR_OWVAR 33
54424: PUSH
54425: LD_STRING 
54427: ST_TO_ADDR
// hc_name :=  ;
54428: LD_ADDR_OWVAR 26
54432: PUSH
54433: LD_STRING 
54435: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
54436: LD_ADDR_OWVAR 35
54440: PUSH
54441: LD_VAR 0 1
54445: NEG
54446: PPUSH
54447: LD_VAR 0 1
54451: PPUSH
54452: CALL_OW 12
54456: ST_TO_ADDR
// end ;
54457: LD_VAR 0 2
54461: RET
// export function PrepareEnchidna ( ) ; begin
54462: LD_INT 0
54464: PPUSH
// uc_side := 0 ;
54465: LD_ADDR_OWVAR 20
54469: PUSH
54470: LD_INT 0
54472: ST_TO_ADDR
// uc_nation := 0 ;
54473: LD_ADDR_OWVAR 21
54477: PUSH
54478: LD_INT 0
54480: ST_TO_ADDR
// InitHc ;
54481: CALL_OW 19
// hc_class := class_baggie ;
54485: LD_ADDR_OWVAR 28
54489: PUSH
54490: LD_INT 13
54492: ST_TO_ADDR
// hc_gallery :=  ;
54493: LD_ADDR_OWVAR 33
54497: PUSH
54498: LD_STRING 
54500: ST_TO_ADDR
// hc_name :=  ;
54501: LD_ADDR_OWVAR 26
54505: PUSH
54506: LD_STRING 
54508: ST_TO_ADDR
// end ;
54509: LD_VAR 0 1
54513: RET
// export function PrepareFrog ( ) ; begin
54514: LD_INT 0
54516: PPUSH
// uc_side := 0 ;
54517: LD_ADDR_OWVAR 20
54521: PUSH
54522: LD_INT 0
54524: ST_TO_ADDR
// uc_nation := 0 ;
54525: LD_ADDR_OWVAR 21
54529: PUSH
54530: LD_INT 0
54532: ST_TO_ADDR
// InitHc ;
54533: CALL_OW 19
// hc_class := class_frog ;
54537: LD_ADDR_OWVAR 28
54541: PUSH
54542: LD_INT 19
54544: ST_TO_ADDR
// hc_gallery :=  ;
54545: LD_ADDR_OWVAR 33
54549: PUSH
54550: LD_STRING 
54552: ST_TO_ADDR
// hc_name :=  ;
54553: LD_ADDR_OWVAR 26
54557: PUSH
54558: LD_STRING 
54560: ST_TO_ADDR
// end ;
54561: LD_VAR 0 1
54565: RET
// export function PrepareFish ( ) ; begin
54566: LD_INT 0
54568: PPUSH
// uc_side := 0 ;
54569: LD_ADDR_OWVAR 20
54573: PUSH
54574: LD_INT 0
54576: ST_TO_ADDR
// uc_nation := 0 ;
54577: LD_ADDR_OWVAR 21
54581: PUSH
54582: LD_INT 0
54584: ST_TO_ADDR
// InitHc ;
54585: CALL_OW 19
// hc_class := class_fish ;
54589: LD_ADDR_OWVAR 28
54593: PUSH
54594: LD_INT 20
54596: ST_TO_ADDR
// hc_gallery :=  ;
54597: LD_ADDR_OWVAR 33
54601: PUSH
54602: LD_STRING 
54604: ST_TO_ADDR
// hc_name :=  ;
54605: LD_ADDR_OWVAR 26
54609: PUSH
54610: LD_STRING 
54612: ST_TO_ADDR
// end ;
54613: LD_VAR 0 1
54617: RET
// export function PrepareBird ( ) ; begin
54618: LD_INT 0
54620: PPUSH
// uc_side := 0 ;
54621: LD_ADDR_OWVAR 20
54625: PUSH
54626: LD_INT 0
54628: ST_TO_ADDR
// uc_nation := 0 ;
54629: LD_ADDR_OWVAR 21
54633: PUSH
54634: LD_INT 0
54636: ST_TO_ADDR
// InitHc ;
54637: CALL_OW 19
// hc_class := class_phororhacos ;
54641: LD_ADDR_OWVAR 28
54645: PUSH
54646: LD_INT 18
54648: ST_TO_ADDR
// hc_gallery :=  ;
54649: LD_ADDR_OWVAR 33
54653: PUSH
54654: LD_STRING 
54656: ST_TO_ADDR
// hc_name :=  ;
54657: LD_ADDR_OWVAR 26
54661: PUSH
54662: LD_STRING 
54664: ST_TO_ADDR
// end ;
54665: LD_VAR 0 1
54669: RET
// export function PrepareHorse ( ) ; begin
54670: LD_INT 0
54672: PPUSH
// uc_side := 0 ;
54673: LD_ADDR_OWVAR 20
54677: PUSH
54678: LD_INT 0
54680: ST_TO_ADDR
// uc_nation := 0 ;
54681: LD_ADDR_OWVAR 21
54685: PUSH
54686: LD_INT 0
54688: ST_TO_ADDR
// InitHc ;
54689: CALL_OW 19
// hc_class := class_horse ;
54693: LD_ADDR_OWVAR 28
54697: PUSH
54698: LD_INT 21
54700: ST_TO_ADDR
// hc_gallery :=  ;
54701: LD_ADDR_OWVAR 33
54705: PUSH
54706: LD_STRING 
54708: ST_TO_ADDR
// hc_name :=  ;
54709: LD_ADDR_OWVAR 26
54713: PUSH
54714: LD_STRING 
54716: ST_TO_ADDR
// end ;
54717: LD_VAR 0 1
54721: RET
// export function PrepareMastodont ( ) ; begin
54722: LD_INT 0
54724: PPUSH
// uc_side := 0 ;
54725: LD_ADDR_OWVAR 20
54729: PUSH
54730: LD_INT 0
54732: ST_TO_ADDR
// uc_nation := 0 ;
54733: LD_ADDR_OWVAR 21
54737: PUSH
54738: LD_INT 0
54740: ST_TO_ADDR
// vc_chassis := class_mastodont ;
54741: LD_ADDR_OWVAR 37
54745: PUSH
54746: LD_INT 31
54748: ST_TO_ADDR
// vc_control := control_rider ;
54749: LD_ADDR_OWVAR 38
54753: PUSH
54754: LD_INT 4
54756: ST_TO_ADDR
// end ;
54757: LD_VAR 0 1
54761: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
54762: LD_INT 0
54764: PPUSH
54765: PPUSH
54766: PPUSH
// uc_side = 0 ;
54767: LD_ADDR_OWVAR 20
54771: PUSH
54772: LD_INT 0
54774: ST_TO_ADDR
// uc_nation = 0 ;
54775: LD_ADDR_OWVAR 21
54779: PUSH
54780: LD_INT 0
54782: ST_TO_ADDR
// InitHc_All ( ) ;
54783: CALL_OW 584
// InitVc ;
54787: CALL_OW 20
// if mastodonts then
54791: LD_VAR 0 6
54795: IFFALSE 54862
// for i = 1 to mastodonts do
54797: LD_ADDR_VAR 0 11
54801: PUSH
54802: DOUBLE
54803: LD_INT 1
54805: DEC
54806: ST_TO_ADDR
54807: LD_VAR 0 6
54811: PUSH
54812: FOR_TO
54813: IFFALSE 54860
// begin vc_chassis := 31 ;
54815: LD_ADDR_OWVAR 37
54819: PUSH
54820: LD_INT 31
54822: ST_TO_ADDR
// vc_control := control_rider ;
54823: LD_ADDR_OWVAR 38
54827: PUSH
54828: LD_INT 4
54830: ST_TO_ADDR
// animal := CreateVehicle ;
54831: LD_ADDR_VAR 0 12
54835: PUSH
54836: CALL_OW 45
54840: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54841: LD_VAR 0 12
54845: PPUSH
54846: LD_VAR 0 8
54850: PPUSH
54851: LD_INT 0
54853: PPUSH
54854: CALL 57004 0 3
// end ;
54858: GO 54812
54860: POP
54861: POP
// if horses then
54862: LD_VAR 0 5
54866: IFFALSE 54933
// for i = 1 to horses do
54868: LD_ADDR_VAR 0 11
54872: PUSH
54873: DOUBLE
54874: LD_INT 1
54876: DEC
54877: ST_TO_ADDR
54878: LD_VAR 0 5
54882: PUSH
54883: FOR_TO
54884: IFFALSE 54931
// begin hc_class := 21 ;
54886: LD_ADDR_OWVAR 28
54890: PUSH
54891: LD_INT 21
54893: ST_TO_ADDR
// hc_gallery :=  ;
54894: LD_ADDR_OWVAR 33
54898: PUSH
54899: LD_STRING 
54901: ST_TO_ADDR
// animal := CreateHuman ;
54902: LD_ADDR_VAR 0 12
54906: PUSH
54907: CALL_OW 44
54911: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54912: LD_VAR 0 12
54916: PPUSH
54917: LD_VAR 0 8
54921: PPUSH
54922: LD_INT 0
54924: PPUSH
54925: CALL 57004 0 3
// end ;
54929: GO 54883
54931: POP
54932: POP
// if birds then
54933: LD_VAR 0 1
54937: IFFALSE 55004
// for i = 1 to birds do
54939: LD_ADDR_VAR 0 11
54943: PUSH
54944: DOUBLE
54945: LD_INT 1
54947: DEC
54948: ST_TO_ADDR
54949: LD_VAR 0 1
54953: PUSH
54954: FOR_TO
54955: IFFALSE 55002
// begin hc_class := 18 ;
54957: LD_ADDR_OWVAR 28
54961: PUSH
54962: LD_INT 18
54964: ST_TO_ADDR
// hc_gallery =  ;
54965: LD_ADDR_OWVAR 33
54969: PUSH
54970: LD_STRING 
54972: ST_TO_ADDR
// animal := CreateHuman ;
54973: LD_ADDR_VAR 0 12
54977: PUSH
54978: CALL_OW 44
54982: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54983: LD_VAR 0 12
54987: PPUSH
54988: LD_VAR 0 8
54992: PPUSH
54993: LD_INT 0
54995: PPUSH
54996: CALL 57004 0 3
// end ;
55000: GO 54954
55002: POP
55003: POP
// if tigers then
55004: LD_VAR 0 2
55008: IFFALSE 55092
// for i = 1 to tigers do
55010: LD_ADDR_VAR 0 11
55014: PUSH
55015: DOUBLE
55016: LD_INT 1
55018: DEC
55019: ST_TO_ADDR
55020: LD_VAR 0 2
55024: PUSH
55025: FOR_TO
55026: IFFALSE 55090
// begin hc_class = class_tiger ;
55028: LD_ADDR_OWVAR 28
55032: PUSH
55033: LD_INT 14
55035: ST_TO_ADDR
// hc_gallery =  ;
55036: LD_ADDR_OWVAR 33
55040: PUSH
55041: LD_STRING 
55043: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
55044: LD_ADDR_OWVAR 35
55048: PUSH
55049: LD_INT 7
55051: NEG
55052: PPUSH
55053: LD_INT 7
55055: PPUSH
55056: CALL_OW 12
55060: ST_TO_ADDR
// animal := CreateHuman ;
55061: LD_ADDR_VAR 0 12
55065: PUSH
55066: CALL_OW 44
55070: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
55071: LD_VAR 0 12
55075: PPUSH
55076: LD_VAR 0 8
55080: PPUSH
55081: LD_INT 0
55083: PPUSH
55084: CALL 57004 0 3
// end ;
55088: GO 55025
55090: POP
55091: POP
// if apemans then
55092: LD_VAR 0 3
55096: IFFALSE 55219
// for i = 1 to apemans do
55098: LD_ADDR_VAR 0 11
55102: PUSH
55103: DOUBLE
55104: LD_INT 1
55106: DEC
55107: ST_TO_ADDR
55108: LD_VAR 0 3
55112: PUSH
55113: FOR_TO
55114: IFFALSE 55217
// begin hc_class = class_apeman ;
55116: LD_ADDR_OWVAR 28
55120: PUSH
55121: LD_INT 12
55123: ST_TO_ADDR
// hc_gallery =  ;
55124: LD_ADDR_OWVAR 33
55128: PUSH
55129: LD_STRING 
55131: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
55132: LD_ADDR_OWVAR 35
55136: PUSH
55137: LD_INT 2
55139: NEG
55140: PPUSH
55141: LD_INT 2
55143: PPUSH
55144: CALL_OW 12
55148: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
55149: LD_ADDR_OWVAR 31
55153: PUSH
55154: LD_INT 1
55156: PPUSH
55157: LD_INT 3
55159: PPUSH
55160: CALL_OW 12
55164: PUSH
55165: LD_INT 1
55167: PPUSH
55168: LD_INT 3
55170: PPUSH
55171: CALL_OW 12
55175: PUSH
55176: LD_INT 0
55178: PUSH
55179: LD_INT 0
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: LIST
55186: LIST
55187: ST_TO_ADDR
// animal := CreateHuman ;
55188: LD_ADDR_VAR 0 12
55192: PUSH
55193: CALL_OW 44
55197: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
55198: LD_VAR 0 12
55202: PPUSH
55203: LD_VAR 0 8
55207: PPUSH
55208: LD_INT 0
55210: PPUSH
55211: CALL 57004 0 3
// end ;
55215: GO 55113
55217: POP
55218: POP
// if enchidnas then
55219: LD_VAR 0 4
55223: IFFALSE 55290
// for i = 1 to enchidnas do
55225: LD_ADDR_VAR 0 11
55229: PUSH
55230: DOUBLE
55231: LD_INT 1
55233: DEC
55234: ST_TO_ADDR
55235: LD_VAR 0 4
55239: PUSH
55240: FOR_TO
55241: IFFALSE 55288
// begin hc_class = 13 ;
55243: LD_ADDR_OWVAR 28
55247: PUSH
55248: LD_INT 13
55250: ST_TO_ADDR
// hc_gallery =  ;
55251: LD_ADDR_OWVAR 33
55255: PUSH
55256: LD_STRING 
55258: ST_TO_ADDR
// animal := CreateHuman ;
55259: LD_ADDR_VAR 0 12
55263: PUSH
55264: CALL_OW 44
55268: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
55269: LD_VAR 0 12
55273: PPUSH
55274: LD_VAR 0 8
55278: PPUSH
55279: LD_INT 0
55281: PPUSH
55282: CALL 57004 0 3
// end ;
55286: GO 55240
55288: POP
55289: POP
// if fishes then
55290: LD_VAR 0 7
55294: IFFALSE 55361
// for i = 1 to fishes do
55296: LD_ADDR_VAR 0 11
55300: PUSH
55301: DOUBLE
55302: LD_INT 1
55304: DEC
55305: ST_TO_ADDR
55306: LD_VAR 0 7
55310: PUSH
55311: FOR_TO
55312: IFFALSE 55359
// begin hc_class = 20 ;
55314: LD_ADDR_OWVAR 28
55318: PUSH
55319: LD_INT 20
55321: ST_TO_ADDR
// hc_gallery =  ;
55322: LD_ADDR_OWVAR 33
55326: PUSH
55327: LD_STRING 
55329: ST_TO_ADDR
// animal := CreateHuman ;
55330: LD_ADDR_VAR 0 12
55334: PUSH
55335: CALL_OW 44
55339: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
55340: LD_VAR 0 12
55344: PPUSH
55345: LD_VAR 0 9
55349: PPUSH
55350: LD_INT 0
55352: PPUSH
55353: CALL 57004 0 3
// end ;
55357: GO 55311
55359: POP
55360: POP
// end ;
55361: LD_VAR 0 10
55365: RET
// export function WantHeal ( sci , unit ) ; begin
55366: LD_INT 0
55368: PPUSH
// if GetTaskList ( sci ) > 0 then
55369: LD_VAR 0 1
55373: PPUSH
55374: CALL_OW 437
55378: PUSH
55379: LD_INT 0
55381: GREATER
55382: IFFALSE 55454
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
55384: LD_VAR 0 1
55388: PPUSH
55389: CALL_OW 437
55393: PUSH
55394: LD_INT 1
55396: ARRAY
55397: PUSH
55398: LD_INT 1
55400: ARRAY
55401: PUSH
55402: LD_STRING l
55404: EQUAL
55405: IFFALSE 55432
55407: PUSH
55408: LD_VAR 0 1
55412: PPUSH
55413: CALL_OW 437
55417: PUSH
55418: LD_INT 1
55420: ARRAY
55421: PUSH
55422: LD_INT 4
55424: ARRAY
55425: PUSH
55426: LD_VAR 0 2
55430: EQUAL
55431: AND
55432: IFFALSE 55444
// result := true else
55434: LD_ADDR_VAR 0 3
55438: PUSH
55439: LD_INT 1
55441: ST_TO_ADDR
55442: GO 55452
// result := false ;
55444: LD_ADDR_VAR 0 3
55448: PUSH
55449: LD_INT 0
55451: ST_TO_ADDR
// end else
55452: GO 55462
// result := false ;
55454: LD_ADDR_VAR 0 3
55458: PUSH
55459: LD_INT 0
55461: ST_TO_ADDR
// end ;
55462: LD_VAR 0 3
55466: RET
// export function HealTarget ( sci ) ; begin
55467: LD_INT 0
55469: PPUSH
// if not sci then
55470: LD_VAR 0 1
55474: NOT
55475: IFFALSE 55479
// exit ;
55477: GO 55544
// result := 0 ;
55479: LD_ADDR_VAR 0 2
55483: PUSH
55484: LD_INT 0
55486: ST_TO_ADDR
// if GetTaskList ( sci ) then
55487: LD_VAR 0 1
55491: PPUSH
55492: CALL_OW 437
55496: IFFALSE 55544
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
55498: LD_VAR 0 1
55502: PPUSH
55503: CALL_OW 437
55507: PUSH
55508: LD_INT 1
55510: ARRAY
55511: PUSH
55512: LD_INT 1
55514: ARRAY
55515: PUSH
55516: LD_STRING l
55518: EQUAL
55519: IFFALSE 55544
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
55521: LD_ADDR_VAR 0 2
55525: PUSH
55526: LD_VAR 0 1
55530: PPUSH
55531: CALL_OW 437
55535: PUSH
55536: LD_INT 1
55538: ARRAY
55539: PUSH
55540: LD_INT 4
55542: ARRAY
55543: ST_TO_ADDR
// end ;
55544: LD_VAR 0 2
55548: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
55549: LD_INT 0
55551: PPUSH
55552: PPUSH
55553: PPUSH
55554: PPUSH
// if not base_units then
55555: LD_VAR 0 1
55559: NOT
55560: IFFALSE 55564
// exit ;
55562: GO 55651
// result := false ;
55564: LD_ADDR_VAR 0 2
55568: PUSH
55569: LD_INT 0
55571: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
55572: LD_ADDR_VAR 0 5
55576: PUSH
55577: LD_VAR 0 1
55581: PPUSH
55582: LD_INT 21
55584: PUSH
55585: LD_INT 3
55587: PUSH
55588: EMPTY
55589: LIST
55590: LIST
55591: PPUSH
55592: CALL_OW 72
55596: ST_TO_ADDR
// if not tmp then
55597: LD_VAR 0 5
55601: NOT
55602: IFFALSE 55606
// exit ;
55604: GO 55651
// for i in tmp do
55606: LD_ADDR_VAR 0 3
55610: PUSH
55611: LD_VAR 0 5
55615: PUSH
55616: FOR_IN
55617: IFFALSE 55649
// begin result := EnemyInRange ( i , 22 ) ;
55619: LD_ADDR_VAR 0 2
55623: PUSH
55624: LD_VAR 0 3
55628: PPUSH
55629: LD_INT 22
55631: PPUSH
55632: CALL 53076 0 2
55636: ST_TO_ADDR
// if result then
55637: LD_VAR 0 2
55641: IFFALSE 55647
// exit ;
55643: POP
55644: POP
55645: GO 55651
// end ;
55647: GO 55616
55649: POP
55650: POP
// end ;
55651: LD_VAR 0 2
55655: RET
// export function FilterByTag ( units , tag ) ; begin
55656: LD_INT 0
55658: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
55659: LD_ADDR_VAR 0 3
55663: PUSH
55664: LD_VAR 0 1
55668: PPUSH
55669: LD_INT 120
55671: PUSH
55672: LD_VAR 0 2
55676: PUSH
55677: EMPTY
55678: LIST
55679: LIST
55680: PPUSH
55681: CALL_OW 72
55685: ST_TO_ADDR
// end ;
55686: LD_VAR 0 3
55690: RET
// export function IsDriver ( un ) ; begin
55691: LD_INT 0
55693: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
55694: LD_ADDR_VAR 0 2
55698: PUSH
55699: LD_VAR 0 1
55703: PUSH
55704: LD_INT 55
55706: PUSH
55707: EMPTY
55708: LIST
55709: PPUSH
55710: CALL_OW 69
55714: IN
55715: ST_TO_ADDR
// end ;
55716: LD_VAR 0 2
55720: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
55721: LD_INT 0
55723: PPUSH
55724: PPUSH
// list := [ ] ;
55725: LD_ADDR_VAR 0 5
55729: PUSH
55730: EMPTY
55731: ST_TO_ADDR
// case d of 0 :
55732: LD_VAR 0 3
55736: PUSH
55737: LD_INT 0
55739: DOUBLE
55740: EQUAL
55741: IFTRUE 55745
55743: GO 55878
55745: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
55746: LD_ADDR_VAR 0 5
55750: PUSH
55751: LD_VAR 0 1
55755: PUSH
55756: LD_INT 4
55758: MINUS
55759: PUSH
55760: LD_VAR 0 2
55764: PUSH
55765: LD_INT 4
55767: MINUS
55768: PUSH
55769: LD_INT 2
55771: PUSH
55772: EMPTY
55773: LIST
55774: LIST
55775: LIST
55776: PUSH
55777: LD_VAR 0 1
55781: PUSH
55782: LD_INT 3
55784: MINUS
55785: PUSH
55786: LD_VAR 0 2
55790: PUSH
55791: LD_INT 1
55793: PUSH
55794: EMPTY
55795: LIST
55796: LIST
55797: LIST
55798: PUSH
55799: LD_VAR 0 1
55803: PUSH
55804: LD_INT 4
55806: PLUS
55807: PUSH
55808: LD_VAR 0 2
55812: PUSH
55813: LD_INT 4
55815: PUSH
55816: EMPTY
55817: LIST
55818: LIST
55819: LIST
55820: PUSH
55821: LD_VAR 0 1
55825: PUSH
55826: LD_INT 3
55828: PLUS
55829: PUSH
55830: LD_VAR 0 2
55834: PUSH
55835: LD_INT 3
55837: PLUS
55838: PUSH
55839: LD_INT 5
55841: PUSH
55842: EMPTY
55843: LIST
55844: LIST
55845: LIST
55846: PUSH
55847: LD_VAR 0 1
55851: PUSH
55852: LD_VAR 0 2
55856: PUSH
55857: LD_INT 4
55859: PLUS
55860: PUSH
55861: LD_INT 0
55863: PUSH
55864: EMPTY
55865: LIST
55866: LIST
55867: LIST
55868: PUSH
55869: EMPTY
55870: LIST
55871: LIST
55872: LIST
55873: LIST
55874: LIST
55875: ST_TO_ADDR
// end ; 1 :
55876: GO 56576
55878: LD_INT 1
55880: DOUBLE
55881: EQUAL
55882: IFTRUE 55886
55884: GO 56019
55886: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55887: LD_ADDR_VAR 0 5
55891: PUSH
55892: LD_VAR 0 1
55896: PUSH
55897: LD_VAR 0 2
55901: PUSH
55902: LD_INT 4
55904: MINUS
55905: PUSH
55906: LD_INT 3
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: LIST
55913: PUSH
55914: LD_VAR 0 1
55918: PUSH
55919: LD_INT 3
55921: MINUS
55922: PUSH
55923: LD_VAR 0 2
55927: PUSH
55928: LD_INT 3
55930: MINUS
55931: PUSH
55932: LD_INT 2
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: LIST
55939: PUSH
55940: LD_VAR 0 1
55944: PUSH
55945: LD_INT 4
55947: MINUS
55948: PUSH
55949: LD_VAR 0 2
55953: PUSH
55954: LD_INT 1
55956: PUSH
55957: EMPTY
55958: LIST
55959: LIST
55960: LIST
55961: PUSH
55962: LD_VAR 0 1
55966: PUSH
55967: LD_VAR 0 2
55971: PUSH
55972: LD_INT 3
55974: PLUS
55975: PUSH
55976: LD_INT 0
55978: PUSH
55979: EMPTY
55980: LIST
55981: LIST
55982: LIST
55983: PUSH
55984: LD_VAR 0 1
55988: PUSH
55989: LD_INT 4
55991: PLUS
55992: PUSH
55993: LD_VAR 0 2
55997: PUSH
55998: LD_INT 4
56000: PLUS
56001: PUSH
56002: LD_INT 5
56004: PUSH
56005: EMPTY
56006: LIST
56007: LIST
56008: LIST
56009: PUSH
56010: EMPTY
56011: LIST
56012: LIST
56013: LIST
56014: LIST
56015: LIST
56016: ST_TO_ADDR
// end ; 2 :
56017: GO 56576
56019: LD_INT 2
56021: DOUBLE
56022: EQUAL
56023: IFTRUE 56027
56025: GO 56156
56027: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
56028: LD_ADDR_VAR 0 5
56032: PUSH
56033: LD_VAR 0 1
56037: PUSH
56038: LD_VAR 0 2
56042: PUSH
56043: LD_INT 3
56045: MINUS
56046: PUSH
56047: LD_INT 3
56049: PUSH
56050: EMPTY
56051: LIST
56052: LIST
56053: LIST
56054: PUSH
56055: LD_VAR 0 1
56059: PUSH
56060: LD_INT 4
56062: PLUS
56063: PUSH
56064: LD_VAR 0 2
56068: PUSH
56069: LD_INT 4
56071: PUSH
56072: EMPTY
56073: LIST
56074: LIST
56075: LIST
56076: PUSH
56077: LD_VAR 0 1
56081: PUSH
56082: LD_VAR 0 2
56086: PUSH
56087: LD_INT 4
56089: PLUS
56090: PUSH
56091: LD_INT 0
56093: PUSH
56094: EMPTY
56095: LIST
56096: LIST
56097: LIST
56098: PUSH
56099: LD_VAR 0 1
56103: PUSH
56104: LD_INT 3
56106: MINUS
56107: PUSH
56108: LD_VAR 0 2
56112: PUSH
56113: LD_INT 1
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: LIST
56120: PUSH
56121: LD_VAR 0 1
56125: PUSH
56126: LD_INT 4
56128: MINUS
56129: PUSH
56130: LD_VAR 0 2
56134: PUSH
56135: LD_INT 4
56137: MINUS
56138: PUSH
56139: LD_INT 2
56141: PUSH
56142: EMPTY
56143: LIST
56144: LIST
56145: LIST
56146: PUSH
56147: EMPTY
56148: LIST
56149: LIST
56150: LIST
56151: LIST
56152: LIST
56153: ST_TO_ADDR
// end ; 3 :
56154: GO 56576
56156: LD_INT 3
56158: DOUBLE
56159: EQUAL
56160: IFTRUE 56164
56162: GO 56297
56164: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
56165: LD_ADDR_VAR 0 5
56169: PUSH
56170: LD_VAR 0 1
56174: PUSH
56175: LD_INT 3
56177: PLUS
56178: PUSH
56179: LD_VAR 0 2
56183: PUSH
56184: LD_INT 4
56186: PUSH
56187: EMPTY
56188: LIST
56189: LIST
56190: LIST
56191: PUSH
56192: LD_VAR 0 1
56196: PUSH
56197: LD_INT 4
56199: PLUS
56200: PUSH
56201: LD_VAR 0 2
56205: PUSH
56206: LD_INT 4
56208: PLUS
56209: PUSH
56210: LD_INT 5
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: LIST
56217: PUSH
56218: LD_VAR 0 1
56222: PUSH
56223: LD_INT 4
56225: MINUS
56226: PUSH
56227: LD_VAR 0 2
56231: PUSH
56232: LD_INT 1
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: LIST
56239: PUSH
56240: LD_VAR 0 1
56244: PUSH
56245: LD_VAR 0 2
56249: PUSH
56250: LD_INT 4
56252: MINUS
56253: PUSH
56254: LD_INT 3
56256: PUSH
56257: EMPTY
56258: LIST
56259: LIST
56260: LIST
56261: PUSH
56262: LD_VAR 0 1
56266: PUSH
56267: LD_INT 3
56269: MINUS
56270: PUSH
56271: LD_VAR 0 2
56275: PUSH
56276: LD_INT 3
56278: MINUS
56279: PUSH
56280: LD_INT 2
56282: PUSH
56283: EMPTY
56284: LIST
56285: LIST
56286: LIST
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: LIST
56292: LIST
56293: LIST
56294: ST_TO_ADDR
// end ; 4 :
56295: GO 56576
56297: LD_INT 4
56299: DOUBLE
56300: EQUAL
56301: IFTRUE 56305
56303: GO 56438
56305: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
56306: LD_ADDR_VAR 0 5
56310: PUSH
56311: LD_VAR 0 1
56315: PUSH
56316: LD_VAR 0 2
56320: PUSH
56321: LD_INT 4
56323: PLUS
56324: PUSH
56325: LD_INT 0
56327: PUSH
56328: EMPTY
56329: LIST
56330: LIST
56331: LIST
56332: PUSH
56333: LD_VAR 0 1
56337: PUSH
56338: LD_INT 3
56340: PLUS
56341: PUSH
56342: LD_VAR 0 2
56346: PUSH
56347: LD_INT 3
56349: PLUS
56350: PUSH
56351: LD_INT 5
56353: PUSH
56354: EMPTY
56355: LIST
56356: LIST
56357: LIST
56358: PUSH
56359: LD_VAR 0 1
56363: PUSH
56364: LD_INT 4
56366: PLUS
56367: PUSH
56368: LD_VAR 0 2
56372: PUSH
56373: LD_INT 4
56375: PUSH
56376: EMPTY
56377: LIST
56378: LIST
56379: LIST
56380: PUSH
56381: LD_VAR 0 1
56385: PUSH
56386: LD_VAR 0 2
56390: PUSH
56391: LD_INT 3
56393: MINUS
56394: PUSH
56395: LD_INT 3
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: LIST
56402: PUSH
56403: LD_VAR 0 1
56407: PUSH
56408: LD_INT 4
56410: MINUS
56411: PUSH
56412: LD_VAR 0 2
56416: PUSH
56417: LD_INT 4
56419: MINUS
56420: PUSH
56421: LD_INT 2
56423: PUSH
56424: EMPTY
56425: LIST
56426: LIST
56427: LIST
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: LIST
56433: LIST
56434: LIST
56435: ST_TO_ADDR
// end ; 5 :
56436: GO 56576
56438: LD_INT 5
56440: DOUBLE
56441: EQUAL
56442: IFTRUE 56446
56444: GO 56575
56446: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
56447: LD_ADDR_VAR 0 5
56451: PUSH
56452: LD_VAR 0 1
56456: PUSH
56457: LD_INT 4
56459: MINUS
56460: PUSH
56461: LD_VAR 0 2
56465: PUSH
56466: LD_INT 1
56468: PUSH
56469: EMPTY
56470: LIST
56471: LIST
56472: LIST
56473: PUSH
56474: LD_VAR 0 1
56478: PUSH
56479: LD_VAR 0 2
56483: PUSH
56484: LD_INT 4
56486: MINUS
56487: PUSH
56488: LD_INT 3
56490: PUSH
56491: EMPTY
56492: LIST
56493: LIST
56494: LIST
56495: PUSH
56496: LD_VAR 0 1
56500: PUSH
56501: LD_INT 4
56503: PLUS
56504: PUSH
56505: LD_VAR 0 2
56509: PUSH
56510: LD_INT 4
56512: PLUS
56513: PUSH
56514: LD_INT 5
56516: PUSH
56517: EMPTY
56518: LIST
56519: LIST
56520: LIST
56521: PUSH
56522: LD_VAR 0 1
56526: PUSH
56527: LD_INT 3
56529: PLUS
56530: PUSH
56531: LD_VAR 0 2
56535: PUSH
56536: LD_INT 4
56538: PUSH
56539: EMPTY
56540: LIST
56541: LIST
56542: LIST
56543: PUSH
56544: LD_VAR 0 1
56548: PUSH
56549: LD_VAR 0 2
56553: PUSH
56554: LD_INT 3
56556: PLUS
56557: PUSH
56558: LD_INT 0
56560: PUSH
56561: EMPTY
56562: LIST
56563: LIST
56564: LIST
56565: PUSH
56566: EMPTY
56567: LIST
56568: LIST
56569: LIST
56570: LIST
56571: LIST
56572: ST_TO_ADDR
// end ; end ;
56573: GO 56576
56575: POP
// result := list ;
56576: LD_ADDR_VAR 0 4
56580: PUSH
56581: LD_VAR 0 5
56585: ST_TO_ADDR
// end ;
56586: LD_VAR 0 4
56590: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
56591: LD_INT 0
56593: PPUSH
56594: PPUSH
56595: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
56596: LD_VAR 0 1
56600: NOT
56601: IFTRUE 56629
56603: PUSH
56604: LD_VAR 0 2
56608: PUSH
56609: LD_INT 1
56611: PUSH
56612: LD_INT 2
56614: PUSH
56615: LD_INT 3
56617: PUSH
56618: LD_INT 4
56620: PUSH
56621: EMPTY
56622: LIST
56623: LIST
56624: LIST
56625: LIST
56626: IN
56627: NOT
56628: OR
56629: IFFALSE 56633
// exit ;
56631: GO 56716
// tmp := [ ] ;
56633: LD_ADDR_VAR 0 5
56637: PUSH
56638: EMPTY
56639: ST_TO_ADDR
// for i in units do
56640: LD_ADDR_VAR 0 4
56644: PUSH
56645: LD_VAR 0 1
56649: PUSH
56650: FOR_IN
56651: IFFALSE 56685
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
56653: LD_ADDR_VAR 0 5
56657: PUSH
56658: LD_VAR 0 5
56662: PPUSH
56663: LD_VAR 0 4
56667: PPUSH
56668: LD_VAR 0 2
56672: PPUSH
56673: CALL_OW 259
56677: PPUSH
56678: CALL 58111 0 2
56682: ST_TO_ADDR
56683: GO 56650
56685: POP
56686: POP
// if not tmp then
56687: LD_VAR 0 5
56691: NOT
56692: IFFALSE 56696
// exit ;
56694: GO 56716
// result := SortListByListDesc ( units , tmp ) ;
56696: LD_ADDR_VAR 0 3
56700: PUSH
56701: LD_VAR 0 1
56705: PPUSH
56706: LD_VAR 0 5
56710: PPUSH
56711: CALL_OW 77
56715: ST_TO_ADDR
// end ;
56716: LD_VAR 0 3
56720: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
56721: LD_INT 0
56723: PPUSH
56724: PPUSH
56725: PPUSH
// result := false ;
56726: LD_ADDR_VAR 0 3
56730: PUSH
56731: LD_INT 0
56733: ST_TO_ADDR
// if not building then
56734: LD_VAR 0 2
56738: NOT
56739: IFFALSE 56743
// exit ;
56741: GO 56887
// x := GetX ( building ) ;
56743: LD_ADDR_VAR 0 4
56747: PUSH
56748: LD_VAR 0 2
56752: PPUSH
56753: CALL_OW 250
56757: ST_TO_ADDR
// y := GetY ( building ) ;
56758: LD_ADDR_VAR 0 5
56762: PUSH
56763: LD_VAR 0 2
56767: PPUSH
56768: CALL_OW 251
56772: ST_TO_ADDR
// if not x or not y then
56773: LD_VAR 0 4
56777: NOT
56778: IFTRUE 56787
56780: PUSH
56781: LD_VAR 0 5
56785: NOT
56786: OR
56787: IFFALSE 56791
// exit ;
56789: GO 56887
// if GetTaskList ( unit ) then
56791: LD_VAR 0 1
56795: PPUSH
56796: CALL_OW 437
56800: IFFALSE 56887
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56802: LD_STRING e
56804: PUSH
56805: LD_VAR 0 1
56809: PPUSH
56810: CALL_OW 437
56814: PUSH
56815: LD_INT 1
56817: ARRAY
56818: PUSH
56819: LD_INT 1
56821: ARRAY
56822: EQUAL
56823: IFFALSE 56850
56825: PUSH
56826: LD_VAR 0 4
56830: PUSH
56831: LD_VAR 0 1
56835: PPUSH
56836: CALL_OW 437
56840: PUSH
56841: LD_INT 1
56843: ARRAY
56844: PUSH
56845: LD_INT 2
56847: ARRAY
56848: EQUAL
56849: AND
56850: IFFALSE 56877
56852: PUSH
56853: LD_VAR 0 5
56857: PUSH
56858: LD_VAR 0 1
56862: PPUSH
56863: CALL_OW 437
56867: PUSH
56868: LD_INT 1
56870: ARRAY
56871: PUSH
56872: LD_INT 3
56874: ARRAY
56875: EQUAL
56876: AND
56877: IFFALSE 56887
// result := true end ;
56879: LD_ADDR_VAR 0 3
56883: PUSH
56884: LD_INT 1
56886: ST_TO_ADDR
// end ;
56887: LD_VAR 0 3
56891: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56892: LD_INT 0
56894: PPUSH
// result := false ;
56895: LD_ADDR_VAR 0 4
56899: PUSH
56900: LD_INT 0
56902: ST_TO_ADDR
// if GetTaskList ( unit ) then
56903: LD_VAR 0 1
56907: PPUSH
56908: CALL_OW 437
56912: IFFALSE 56999
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56914: LD_STRING M
56916: PUSH
56917: LD_VAR 0 1
56921: PPUSH
56922: CALL_OW 437
56926: PUSH
56927: LD_INT 1
56929: ARRAY
56930: PUSH
56931: LD_INT 1
56933: ARRAY
56934: EQUAL
56935: IFFALSE 56962
56937: PUSH
56938: LD_VAR 0 2
56942: PUSH
56943: LD_VAR 0 1
56947: PPUSH
56948: CALL_OW 437
56952: PUSH
56953: LD_INT 1
56955: ARRAY
56956: PUSH
56957: LD_INT 2
56959: ARRAY
56960: EQUAL
56961: AND
56962: IFFALSE 56989
56964: PUSH
56965: LD_VAR 0 3
56969: PUSH
56970: LD_VAR 0 1
56974: PPUSH
56975: CALL_OW 437
56979: PUSH
56980: LD_INT 1
56982: ARRAY
56983: PUSH
56984: LD_INT 3
56986: ARRAY
56987: EQUAL
56988: AND
56989: IFFALSE 56999
// result := true ;
56991: LD_ADDR_VAR 0 4
56995: PUSH
56996: LD_INT 1
56998: ST_TO_ADDR
// end ; end ;
56999: LD_VAR 0 4
57003: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
57004: LD_INT 0
57006: PPUSH
57007: PPUSH
57008: PPUSH
57009: PPUSH
// if not unit or not area then
57010: LD_VAR 0 1
57014: NOT
57015: IFTRUE 57024
57017: PUSH
57018: LD_VAR 0 2
57022: NOT
57023: OR
57024: IFFALSE 57028
// exit ;
57026: GO 57204
// tmp := AreaToList ( area , i ) ;
57028: LD_ADDR_VAR 0 6
57032: PUSH
57033: LD_VAR 0 2
57037: PPUSH
57038: LD_VAR 0 5
57042: PPUSH
57043: CALL_OW 517
57047: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
57048: LD_ADDR_VAR 0 5
57052: PUSH
57053: DOUBLE
57054: LD_INT 1
57056: DEC
57057: ST_TO_ADDR
57058: LD_VAR 0 6
57062: PUSH
57063: LD_INT 1
57065: ARRAY
57066: PUSH
57067: FOR_TO
57068: IFFALSE 57202
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
57070: LD_ADDR_VAR 0 7
57074: PUSH
57075: LD_VAR 0 6
57079: PUSH
57080: LD_INT 1
57082: ARRAY
57083: PUSH
57084: LD_VAR 0 5
57088: ARRAY
57089: PUSH
57090: LD_VAR 0 6
57094: PUSH
57095: LD_INT 2
57097: ARRAY
57098: PUSH
57099: LD_VAR 0 5
57103: ARRAY
57104: PUSH
57105: EMPTY
57106: LIST
57107: LIST
57108: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
57109: LD_INT 92
57111: PUSH
57112: LD_VAR 0 7
57116: PUSH
57117: LD_INT 1
57119: ARRAY
57120: PUSH
57121: LD_VAR 0 7
57125: PUSH
57126: LD_INT 2
57128: ARRAY
57129: PUSH
57130: LD_INT 2
57132: PUSH
57133: EMPTY
57134: LIST
57135: LIST
57136: LIST
57137: LIST
57138: PPUSH
57139: CALL_OW 69
57143: PUSH
57144: LD_INT 0
57146: EQUAL
57147: IFFALSE 57200
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
57149: LD_VAR 0 1
57153: PPUSH
57154: LD_VAR 0 7
57158: PUSH
57159: LD_INT 1
57161: ARRAY
57162: PPUSH
57163: LD_VAR 0 7
57167: PUSH
57168: LD_INT 2
57170: ARRAY
57171: PPUSH
57172: LD_VAR 0 3
57176: PPUSH
57177: CALL_OW 48
// result := IsPlaced ( unit ) ;
57181: LD_ADDR_VAR 0 4
57185: PUSH
57186: LD_VAR 0 1
57190: PPUSH
57191: CALL_OW 305
57195: ST_TO_ADDR
// exit ;
57196: POP
57197: POP
57198: GO 57204
// end ; end ;
57200: GO 57067
57202: POP
57203: POP
// end ;
57204: LD_VAR 0 4
57208: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
57209: LD_INT 0
57211: PPUSH
57212: PPUSH
57213: PPUSH
// if not side or side > 8 then
57214: LD_VAR 0 1
57218: NOT
57219: IFTRUE 57231
57221: PUSH
57222: LD_VAR 0 1
57226: PUSH
57227: LD_INT 8
57229: GREATER
57230: OR
57231: IFFALSE 57235
// exit ;
57233: GO 57422
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
57235: LD_ADDR_VAR 0 4
57239: PUSH
57240: LD_INT 22
57242: PUSH
57243: LD_VAR 0 1
57247: PUSH
57248: EMPTY
57249: LIST
57250: LIST
57251: PUSH
57252: LD_INT 21
57254: PUSH
57255: LD_INT 3
57257: PUSH
57258: EMPTY
57259: LIST
57260: LIST
57261: PUSH
57262: EMPTY
57263: LIST
57264: LIST
57265: PPUSH
57266: CALL_OW 69
57270: ST_TO_ADDR
// if not tmp then
57271: LD_VAR 0 4
57275: NOT
57276: IFFALSE 57280
// exit ;
57278: GO 57422
// enable_addtolog := true ;
57280: LD_ADDR_OWVAR 81
57284: PUSH
57285: LD_INT 1
57287: ST_TO_ADDR
// AddToLog ( [ ) ;
57288: LD_STRING [
57290: PPUSH
57291: CALL_OW 561
// for i in tmp do
57295: LD_ADDR_VAR 0 3
57299: PUSH
57300: LD_VAR 0 4
57304: PUSH
57305: FOR_IN
57306: IFFALSE 57413
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
57308: LD_STRING [
57310: PUSH
57311: LD_VAR 0 3
57315: PPUSH
57316: CALL_OW 266
57320: STR
57321: PUSH
57322: LD_STRING , 
57324: STR
57325: PUSH
57326: LD_VAR 0 3
57330: PPUSH
57331: CALL_OW 250
57335: STR
57336: PUSH
57337: LD_STRING , 
57339: STR
57340: PUSH
57341: LD_VAR 0 3
57345: PPUSH
57346: CALL_OW 251
57350: STR
57351: PUSH
57352: LD_STRING , 
57354: STR
57355: PUSH
57356: LD_VAR 0 3
57360: PPUSH
57361: CALL_OW 254
57365: STR
57366: PUSH
57367: LD_STRING , 
57369: STR
57370: PUSH
57371: LD_VAR 0 3
57375: PPUSH
57376: LD_INT 1
57378: PPUSH
57379: CALL_OW 268
57383: STR
57384: PUSH
57385: LD_STRING , 
57387: STR
57388: PUSH
57389: LD_VAR 0 3
57393: PPUSH
57394: LD_INT 2
57396: PPUSH
57397: CALL_OW 268
57401: STR
57402: PUSH
57403: LD_STRING ],
57405: STR
57406: PPUSH
57407: CALL_OW 561
// end ;
57411: GO 57305
57413: POP
57414: POP
// AddToLog ( ]; ) ;
57415: LD_STRING ];
57417: PPUSH
57418: CALL_OW 561
// end ;
57422: LD_VAR 0 2
57426: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
57427: LD_INT 0
57429: PPUSH
57430: PPUSH
57431: PPUSH
57432: PPUSH
57433: PPUSH
// if not area or not rate or not max then
57434: LD_VAR 0 1
57438: NOT
57439: IFTRUE 57448
57441: PUSH
57442: LD_VAR 0 2
57446: NOT
57447: OR
57448: IFTRUE 57457
57450: PUSH
57451: LD_VAR 0 4
57455: NOT
57456: OR
57457: IFFALSE 57461
// exit ;
57459: GO 57650
// while 1 do
57461: LD_INT 1
57463: IFFALSE 57650
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
57465: LD_ADDR_VAR 0 9
57469: PUSH
57470: LD_VAR 0 1
57474: PPUSH
57475: LD_INT 1
57477: PPUSH
57478: CALL_OW 287
57482: PUSH
57483: LD_INT 10
57485: MUL
57486: ST_TO_ADDR
// r := rate / 10 ;
57487: LD_ADDR_VAR 0 7
57491: PUSH
57492: LD_VAR 0 2
57496: PUSH
57497: LD_INT 10
57499: DIVREAL
57500: ST_TO_ADDR
// time := 1 1$00 ;
57501: LD_ADDR_VAR 0 8
57505: PUSH
57506: LD_INT 2100
57508: ST_TO_ADDR
// if amount < min then
57509: LD_VAR 0 9
57513: PUSH
57514: LD_VAR 0 3
57518: LESS
57519: IFFALSE 57537
// r := r * 2 else
57521: LD_ADDR_VAR 0 7
57525: PUSH
57526: LD_VAR 0 7
57530: PUSH
57531: LD_INT 2
57533: MUL
57534: ST_TO_ADDR
57535: GO 57563
// if amount > max then
57537: LD_VAR 0 9
57541: PUSH
57542: LD_VAR 0 4
57546: GREATER
57547: IFFALSE 57563
// r := r / 2 ;
57549: LD_ADDR_VAR 0 7
57553: PUSH
57554: LD_VAR 0 7
57558: PUSH
57559: LD_INT 2
57561: DIVREAL
57562: ST_TO_ADDR
// time := time / r ;
57563: LD_ADDR_VAR 0 8
57567: PUSH
57568: LD_VAR 0 8
57572: PUSH
57573: LD_VAR 0 7
57577: DIVREAL
57578: ST_TO_ADDR
// if time < 0 then
57579: LD_VAR 0 8
57583: PUSH
57584: LD_INT 0
57586: LESS
57587: IFFALSE 57604
// time := time * - 1 ;
57589: LD_ADDR_VAR 0 8
57593: PUSH
57594: LD_VAR 0 8
57598: PUSH
57599: LD_INT 1
57601: NEG
57602: MUL
57603: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
57604: LD_VAR 0 8
57608: PUSH
57609: LD_INT 35
57611: PPUSH
57612: LD_INT 875
57614: PPUSH
57615: CALL_OW 12
57619: PLUS
57620: PPUSH
57621: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
57625: LD_INT 1
57627: PPUSH
57628: LD_INT 5
57630: PPUSH
57631: CALL_OW 12
57635: PPUSH
57636: LD_VAR 0 1
57640: PPUSH
57641: LD_INT 1
57643: PPUSH
57644: CALL_OW 55
// end ;
57648: GO 57461
// end ;
57650: LD_VAR 0 5
57654: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
57655: LD_INT 0
57657: PPUSH
57658: PPUSH
57659: PPUSH
57660: PPUSH
57661: PPUSH
57662: PPUSH
57663: PPUSH
57664: PPUSH
// if not turrets or not factories then
57665: LD_VAR 0 1
57669: NOT
57670: IFTRUE 57679
57672: PUSH
57673: LD_VAR 0 2
57677: NOT
57678: OR
57679: IFFALSE 57683
// exit ;
57681: GO 57990
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
57683: LD_ADDR_VAR 0 10
57687: PUSH
57688: LD_INT 5
57690: PUSH
57691: LD_INT 6
57693: PUSH
57694: EMPTY
57695: LIST
57696: LIST
57697: PUSH
57698: LD_INT 2
57700: PUSH
57701: LD_INT 4
57703: PUSH
57704: EMPTY
57705: LIST
57706: LIST
57707: PUSH
57708: LD_INT 3
57710: PUSH
57711: LD_INT 5
57713: PUSH
57714: EMPTY
57715: LIST
57716: LIST
57717: PUSH
57718: EMPTY
57719: LIST
57720: LIST
57721: LIST
57722: PUSH
57723: LD_INT 24
57725: PUSH
57726: LD_INT 25
57728: PUSH
57729: EMPTY
57730: LIST
57731: LIST
57732: PUSH
57733: LD_INT 23
57735: PUSH
57736: LD_INT 27
57738: PUSH
57739: EMPTY
57740: LIST
57741: LIST
57742: PUSH
57743: EMPTY
57744: LIST
57745: LIST
57746: PUSH
57747: LD_INT 42
57749: PUSH
57750: LD_INT 43
57752: PUSH
57753: EMPTY
57754: LIST
57755: LIST
57756: PUSH
57757: LD_INT 44
57759: PUSH
57760: LD_INT 46
57762: PUSH
57763: EMPTY
57764: LIST
57765: LIST
57766: PUSH
57767: LD_INT 45
57769: PUSH
57770: LD_INT 47
57772: PUSH
57773: EMPTY
57774: LIST
57775: LIST
57776: PUSH
57777: EMPTY
57778: LIST
57779: LIST
57780: LIST
57781: PUSH
57782: EMPTY
57783: LIST
57784: LIST
57785: LIST
57786: ST_TO_ADDR
// result := [ ] ;
57787: LD_ADDR_VAR 0 3
57791: PUSH
57792: EMPTY
57793: ST_TO_ADDR
// for i in turrets do
57794: LD_ADDR_VAR 0 4
57798: PUSH
57799: LD_VAR 0 1
57803: PUSH
57804: FOR_IN
57805: IFFALSE 57988
// begin nat := GetNation ( i ) ;
57807: LD_ADDR_VAR 0 7
57811: PUSH
57812: LD_VAR 0 4
57816: PPUSH
57817: CALL_OW 248
57821: ST_TO_ADDR
// weapon := 0 ;
57822: LD_ADDR_VAR 0 8
57826: PUSH
57827: LD_INT 0
57829: ST_TO_ADDR
// if not nat then
57830: LD_VAR 0 7
57834: NOT
57835: IFFALSE 57839
// continue ;
57837: GO 57804
// for j in list [ nat ] do
57839: LD_ADDR_VAR 0 5
57843: PUSH
57844: LD_VAR 0 10
57848: PUSH
57849: LD_VAR 0 7
57853: ARRAY
57854: PUSH
57855: FOR_IN
57856: IFFALSE 57897
// if GetBWeapon ( i ) = j [ 1 ] then
57858: LD_VAR 0 4
57862: PPUSH
57863: CALL_OW 269
57867: PUSH
57868: LD_VAR 0 5
57872: PUSH
57873: LD_INT 1
57875: ARRAY
57876: EQUAL
57877: IFFALSE 57895
// begin weapon := j [ 2 ] ;
57879: LD_ADDR_VAR 0 8
57883: PUSH
57884: LD_VAR 0 5
57888: PUSH
57889: LD_INT 2
57891: ARRAY
57892: ST_TO_ADDR
// break ;
57893: GO 57897
// end ;
57895: GO 57855
57897: POP
57898: POP
// if not weapon then
57899: LD_VAR 0 8
57903: NOT
57904: IFFALSE 57908
// continue ;
57906: GO 57804
// for k in factories do
57908: LD_ADDR_VAR 0 6
57912: PUSH
57913: LD_VAR 0 2
57917: PUSH
57918: FOR_IN
57919: IFFALSE 57984
// begin weapons := AvailableWeaponList ( k ) ;
57921: LD_ADDR_VAR 0 9
57925: PUSH
57926: LD_VAR 0 6
57930: PPUSH
57931: CALL_OW 478
57935: ST_TO_ADDR
// if not weapons then
57936: LD_VAR 0 9
57940: NOT
57941: IFFALSE 57945
// continue ;
57943: GO 57918
// if weapon in weapons then
57945: LD_VAR 0 8
57949: PUSH
57950: LD_VAR 0 9
57954: IN
57955: IFFALSE 57982
// begin result := [ i , weapon ] ;
57957: LD_ADDR_VAR 0 3
57961: PUSH
57962: LD_VAR 0 4
57966: PUSH
57967: LD_VAR 0 8
57971: PUSH
57972: EMPTY
57973: LIST
57974: LIST
57975: ST_TO_ADDR
// exit ;
57976: POP
57977: POP
57978: POP
57979: POP
57980: GO 57990
// end ; end ;
57982: GO 57918
57984: POP
57985: POP
// end ;
57986: GO 57804
57988: POP
57989: POP
// end ;
57990: LD_VAR 0 3
57994: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57995: LD_INT 0
57997: PPUSH
// if not side or side > 8 then
57998: LD_VAR 0 3
58002: NOT
58003: IFTRUE 58015
58005: PUSH
58006: LD_VAR 0 3
58010: PUSH
58011: LD_INT 8
58013: GREATER
58014: OR
58015: IFFALSE 58019
// exit ;
58017: GO 58078
// if not range then
58019: LD_VAR 0 4
58023: NOT
58024: IFFALSE 58035
// range := - 12 ;
58026: LD_ADDR_VAR 0 4
58030: PUSH
58031: LD_INT 12
58033: NEG
58034: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
58035: LD_VAR 0 1
58039: PPUSH
58040: LD_VAR 0 2
58044: PPUSH
58045: LD_VAR 0 3
58049: PPUSH
58050: LD_VAR 0 4
58054: PPUSH
58055: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
58059: LD_VAR 0 1
58063: PPUSH
58064: LD_VAR 0 2
58068: PPUSH
58069: LD_VAR 0 3
58073: PPUSH
58074: CALL_OW 331
// end ;
58078: LD_VAR 0 5
58082: RET
// export function Video ( mode ) ; begin
58083: LD_INT 0
58085: PPUSH
// ingame_video = mode ;
58086: LD_ADDR_OWVAR 52
58090: PUSH
58091: LD_VAR 0 1
58095: ST_TO_ADDR
// interface_hidden = mode ;
58096: LD_ADDR_OWVAR 54
58100: PUSH
58101: LD_VAR 0 1
58105: ST_TO_ADDR
// end ;
58106: LD_VAR 0 2
58110: RET
// export function Join ( array , element ) ; begin
58111: LD_INT 0
58113: PPUSH
// result := Replace ( array , array + 1 , element ) ;
58114: LD_ADDR_VAR 0 3
58118: PUSH
58119: LD_VAR 0 1
58123: PPUSH
58124: LD_VAR 0 1
58128: PUSH
58129: LD_INT 1
58131: PLUS
58132: PPUSH
58133: LD_VAR 0 2
58137: PPUSH
58138: CALL_OW 1
58142: ST_TO_ADDR
// end ;
58143: LD_VAR 0 3
58147: RET
// export function JoinUnion ( array , element ) ; begin
58148: LD_INT 0
58150: PPUSH
// result := array union element ;
58151: LD_ADDR_VAR 0 3
58155: PUSH
58156: LD_VAR 0 1
58160: PUSH
58161: LD_VAR 0 2
58165: UNION
58166: ST_TO_ADDR
// end ;
58167: LD_VAR 0 3
58171: RET
// export function GetBehemoths ( side ) ; begin
58172: LD_INT 0
58174: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
58175: LD_ADDR_VAR 0 2
58179: PUSH
58180: LD_INT 22
58182: PUSH
58183: LD_VAR 0 1
58187: PUSH
58188: EMPTY
58189: LIST
58190: LIST
58191: PUSH
58192: LD_INT 31
58194: PUSH
58195: LD_INT 25
58197: PUSH
58198: EMPTY
58199: LIST
58200: LIST
58201: PUSH
58202: EMPTY
58203: LIST
58204: LIST
58205: PPUSH
58206: CALL_OW 69
58210: ST_TO_ADDR
// end ;
58211: LD_VAR 0 2
58215: RET
// export function Shuffle ( array ) ; var i , index ; begin
58216: LD_INT 0
58218: PPUSH
58219: PPUSH
58220: PPUSH
// result := [ ] ;
58221: LD_ADDR_VAR 0 2
58225: PUSH
58226: EMPTY
58227: ST_TO_ADDR
// if not array then
58228: LD_VAR 0 1
58232: NOT
58233: IFFALSE 58237
// exit ;
58235: GO 58336
// Randomize ;
58237: CALL_OW 10
// for i = array downto 1 do
58241: LD_ADDR_VAR 0 3
58245: PUSH
58246: DOUBLE
58247: LD_VAR 0 1
58251: INC
58252: ST_TO_ADDR
58253: LD_INT 1
58255: PUSH
58256: FOR_DOWNTO
58257: IFFALSE 58334
// begin index := rand ( 1 , array ) ;
58259: LD_ADDR_VAR 0 4
58263: PUSH
58264: LD_INT 1
58266: PPUSH
58267: LD_VAR 0 1
58271: PPUSH
58272: CALL_OW 12
58276: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
58277: LD_ADDR_VAR 0 2
58281: PUSH
58282: LD_VAR 0 2
58286: PPUSH
58287: LD_VAR 0 2
58291: PUSH
58292: LD_INT 1
58294: PLUS
58295: PPUSH
58296: LD_VAR 0 1
58300: PUSH
58301: LD_VAR 0 4
58305: ARRAY
58306: PPUSH
58307: CALL_OW 2
58311: ST_TO_ADDR
// array := Delete ( array , index ) ;
58312: LD_ADDR_VAR 0 1
58316: PUSH
58317: LD_VAR 0 1
58321: PPUSH
58322: LD_VAR 0 4
58326: PPUSH
58327: CALL_OW 3
58331: ST_TO_ADDR
// end ;
58332: GO 58256
58334: POP
58335: POP
// end ;
58336: LD_VAR 0 2
58340: RET
// export function GetBaseMaterials ( base ) ; begin
58341: LD_INT 0
58343: PPUSH
// result := [ 0 , 0 , 0 ] ;
58344: LD_ADDR_VAR 0 2
58348: PUSH
58349: LD_INT 0
58351: PUSH
58352: LD_INT 0
58354: PUSH
58355: LD_INT 0
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: LIST
58362: ST_TO_ADDR
// if not base then
58363: LD_VAR 0 1
58367: NOT
58368: IFFALSE 58372
// exit ;
58370: GO 58421
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
58372: LD_ADDR_VAR 0 2
58376: PUSH
58377: LD_VAR 0 1
58381: PPUSH
58382: LD_INT 1
58384: PPUSH
58385: CALL_OW 275
58389: PUSH
58390: LD_VAR 0 1
58394: PPUSH
58395: LD_INT 2
58397: PPUSH
58398: CALL_OW 275
58402: PUSH
58403: LD_VAR 0 1
58407: PPUSH
58408: LD_INT 3
58410: PPUSH
58411: CALL_OW 275
58415: PUSH
58416: EMPTY
58417: LIST
58418: LIST
58419: LIST
58420: ST_TO_ADDR
// end ;
58421: LD_VAR 0 2
58425: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
58426: LD_INT 0
58428: PPUSH
58429: PPUSH
// result := array ;
58430: LD_ADDR_VAR 0 3
58434: PUSH
58435: LD_VAR 0 1
58439: ST_TO_ADDR
// if size >= result then
58440: LD_VAR 0 2
58444: PUSH
58445: LD_VAR 0 3
58449: GREATEREQUAL
58450: IFFALSE 58454
// exit ;
58452: GO 58504
// if size then
58454: LD_VAR 0 2
58458: IFFALSE 58504
// for i := array downto size do
58460: LD_ADDR_VAR 0 4
58464: PUSH
58465: DOUBLE
58466: LD_VAR 0 1
58470: INC
58471: ST_TO_ADDR
58472: LD_VAR 0 2
58476: PUSH
58477: FOR_DOWNTO
58478: IFFALSE 58502
// result := Delete ( result , result ) ;
58480: LD_ADDR_VAR 0 3
58484: PUSH
58485: LD_VAR 0 3
58489: PPUSH
58490: LD_VAR 0 3
58494: PPUSH
58495: CALL_OW 3
58499: ST_TO_ADDR
58500: GO 58477
58502: POP
58503: POP
// end ;
58504: LD_VAR 0 3
58508: RET
// export function ComExit ( unit ) ; var tmp ; begin
58509: LD_INT 0
58511: PPUSH
58512: PPUSH
// if not IsInUnit ( unit ) then
58513: LD_VAR 0 1
58517: PPUSH
58518: CALL_OW 310
58522: NOT
58523: IFFALSE 58527
// exit ;
58525: GO 58587
// tmp := IsInUnit ( unit ) ;
58527: LD_ADDR_VAR 0 3
58531: PUSH
58532: LD_VAR 0 1
58536: PPUSH
58537: CALL_OW 310
58541: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
58542: LD_VAR 0 3
58546: PPUSH
58547: CALL_OW 247
58551: PUSH
58552: LD_INT 2
58554: EQUAL
58555: IFFALSE 58568
// ComExitVehicle ( unit ) else
58557: LD_VAR 0 1
58561: PPUSH
58562: CALL_OW 121
58566: GO 58577
// ComExitBuilding ( unit ) ;
58568: LD_VAR 0 1
58572: PPUSH
58573: CALL_OW 122
// result := tmp ;
58577: LD_ADDR_VAR 0 2
58581: PUSH
58582: LD_VAR 0 3
58586: ST_TO_ADDR
// end ;
58587: LD_VAR 0 2
58591: RET
// export function ComExitAll ( units ) ; var i ; begin
58592: LD_INT 0
58594: PPUSH
58595: PPUSH
// if not units then
58596: LD_VAR 0 1
58600: NOT
58601: IFFALSE 58605
// exit ;
58603: GO 58631
// for i in units do
58605: LD_ADDR_VAR 0 3
58609: PUSH
58610: LD_VAR 0 1
58614: PUSH
58615: FOR_IN
58616: IFFALSE 58629
// ComExit ( i ) ;
58618: LD_VAR 0 3
58622: PPUSH
58623: CALL 58509 0 1
58627: GO 58615
58629: POP
58630: POP
// end ;
58631: LD_VAR 0 2
58635: RET
// export function ResetHc ; begin
58636: LD_INT 0
58638: PPUSH
// InitHc ;
58639: CALL_OW 19
// hc_importance := 0 ;
58643: LD_ADDR_OWVAR 32
58647: PUSH
58648: LD_INT 0
58650: ST_TO_ADDR
// end ;
58651: LD_VAR 0 1
58655: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
58656: LD_INT 0
58658: PPUSH
58659: PPUSH
58660: PPUSH
// _x := ( x1 + x2 ) div 2 ;
58661: LD_ADDR_VAR 0 6
58665: PUSH
58666: LD_VAR 0 1
58670: PUSH
58671: LD_VAR 0 3
58675: PLUS
58676: PUSH
58677: LD_INT 2
58679: DIV
58680: ST_TO_ADDR
// if _x < 0 then
58681: LD_VAR 0 6
58685: PUSH
58686: LD_INT 0
58688: LESS
58689: IFFALSE 58706
// _x := _x * - 1 ;
58691: LD_ADDR_VAR 0 6
58695: PUSH
58696: LD_VAR 0 6
58700: PUSH
58701: LD_INT 1
58703: NEG
58704: MUL
58705: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
58706: LD_ADDR_VAR 0 7
58710: PUSH
58711: LD_VAR 0 2
58715: PUSH
58716: LD_VAR 0 4
58720: PLUS
58721: PUSH
58722: LD_INT 2
58724: DIV
58725: ST_TO_ADDR
// if _y < 0 then
58726: LD_VAR 0 7
58730: PUSH
58731: LD_INT 0
58733: LESS
58734: IFFALSE 58751
// _y := _y * - 1 ;
58736: LD_ADDR_VAR 0 7
58740: PUSH
58741: LD_VAR 0 7
58745: PUSH
58746: LD_INT 1
58748: NEG
58749: MUL
58750: ST_TO_ADDR
// result := [ _x , _y ] ;
58751: LD_ADDR_VAR 0 5
58755: PUSH
58756: LD_VAR 0 6
58760: PUSH
58761: LD_VAR 0 7
58765: PUSH
58766: EMPTY
58767: LIST
58768: LIST
58769: ST_TO_ADDR
// end ;
58770: LD_VAR 0 5
58774: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
58775: LD_INT 0
58777: PPUSH
58778: PPUSH
58779: PPUSH
58780: PPUSH
// task := GetTaskList ( unit ) ;
58781: LD_ADDR_VAR 0 7
58785: PUSH
58786: LD_VAR 0 1
58790: PPUSH
58791: CALL_OW 437
58795: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
58796: LD_VAR 0 7
58800: NOT
58801: IFFALSE 58820
58803: PUSH
58804: LD_VAR 0 1
58808: PPUSH
58809: LD_VAR 0 2
58813: PPUSH
58814: CALL_OW 308
58818: NOT
58819: AND
58820: IFFALSE 58824
// exit ;
58822: GO 58942
// if IsInArea ( unit , area ) then
58824: LD_VAR 0 1
58828: PPUSH
58829: LD_VAR 0 2
58833: PPUSH
58834: CALL_OW 308
58838: IFFALSE 58856
// begin ComMoveToArea ( unit , goAway ) ;
58840: LD_VAR 0 1
58844: PPUSH
58845: LD_VAR 0 3
58849: PPUSH
58850: CALL_OW 113
// exit ;
58854: GO 58942
// end ; if task [ 1 ] [ 1 ] <> M then
58856: LD_VAR 0 7
58860: PUSH
58861: LD_INT 1
58863: ARRAY
58864: PUSH
58865: LD_INT 1
58867: ARRAY
58868: PUSH
58869: LD_STRING M
58871: NONEQUAL
58872: IFFALSE 58876
// exit ;
58874: GO 58942
// x := task [ 1 ] [ 2 ] ;
58876: LD_ADDR_VAR 0 5
58880: PUSH
58881: LD_VAR 0 7
58885: PUSH
58886: LD_INT 1
58888: ARRAY
58889: PUSH
58890: LD_INT 2
58892: ARRAY
58893: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
58894: LD_ADDR_VAR 0 6
58898: PUSH
58899: LD_VAR 0 7
58903: PUSH
58904: LD_INT 1
58906: ARRAY
58907: PUSH
58908: LD_INT 3
58910: ARRAY
58911: ST_TO_ADDR
// if InArea ( x , y , area ) then
58912: LD_VAR 0 5
58916: PPUSH
58917: LD_VAR 0 6
58921: PPUSH
58922: LD_VAR 0 2
58926: PPUSH
58927: CALL_OW 309
58931: IFFALSE 58942
// ComStop ( unit ) ;
58933: LD_VAR 0 1
58937: PPUSH
58938: CALL_OW 141
// end ;
58942: LD_VAR 0 4
58946: RET
// export function Abs ( value ) ; begin
58947: LD_INT 0
58949: PPUSH
// result := value ;
58950: LD_ADDR_VAR 0 2
58954: PUSH
58955: LD_VAR 0 1
58959: ST_TO_ADDR
// if value < 0 then
58960: LD_VAR 0 1
58964: PUSH
58965: LD_INT 0
58967: LESS
58968: IFFALSE 58985
// result := value * - 1 ;
58970: LD_ADDR_VAR 0 2
58974: PUSH
58975: LD_VAR 0 1
58979: PUSH
58980: LD_INT 1
58982: NEG
58983: MUL
58984: ST_TO_ADDR
// end ;
58985: LD_VAR 0 2
58989: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58990: LD_INT 0
58992: PPUSH
58993: PPUSH
58994: PPUSH
58995: PPUSH
58996: PPUSH
58997: PPUSH
58998: PPUSH
58999: PPUSH
// if not unit or not building then
59000: LD_VAR 0 1
59004: NOT
59005: IFTRUE 59014
59007: PUSH
59008: LD_VAR 0 2
59012: NOT
59013: OR
59014: IFFALSE 59018
// exit ;
59016: GO 59246
// x := GetX ( building ) ;
59018: LD_ADDR_VAR 0 4
59022: PUSH
59023: LD_VAR 0 2
59027: PPUSH
59028: CALL_OW 250
59032: ST_TO_ADDR
// y := GetY ( building ) ;
59033: LD_ADDR_VAR 0 6
59037: PUSH
59038: LD_VAR 0 2
59042: PPUSH
59043: CALL_OW 251
59047: ST_TO_ADDR
// d := GetDir ( building ) ;
59048: LD_ADDR_VAR 0 8
59052: PUSH
59053: LD_VAR 0 2
59057: PPUSH
59058: CALL_OW 254
59062: ST_TO_ADDR
// r := 4 ;
59063: LD_ADDR_VAR 0 9
59067: PUSH
59068: LD_INT 4
59070: ST_TO_ADDR
// for i := 1 to 5 do
59071: LD_ADDR_VAR 0 10
59075: PUSH
59076: DOUBLE
59077: LD_INT 1
59079: DEC
59080: ST_TO_ADDR
59081: LD_INT 5
59083: PUSH
59084: FOR_TO
59085: IFFALSE 59244
// begin _x := ShiftX ( x , d , r + i ) ;
59087: LD_ADDR_VAR 0 5
59091: PUSH
59092: LD_VAR 0 4
59096: PPUSH
59097: LD_VAR 0 8
59101: PPUSH
59102: LD_VAR 0 9
59106: PUSH
59107: LD_VAR 0 10
59111: PLUS
59112: PPUSH
59113: CALL_OW 272
59117: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
59118: LD_ADDR_VAR 0 7
59122: PUSH
59123: LD_VAR 0 6
59127: PPUSH
59128: LD_VAR 0 8
59132: PPUSH
59133: LD_VAR 0 9
59137: PUSH
59138: LD_VAR 0 10
59142: PLUS
59143: PPUSH
59144: CALL_OW 273
59148: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
59149: LD_VAR 0 5
59153: PPUSH
59154: LD_VAR 0 7
59158: PPUSH
59159: CALL_OW 488
59163: IFFALSE 59198
59165: PUSH
59166: LD_VAR 0 5
59170: PPUSH
59171: LD_VAR 0 7
59175: PPUSH
59176: CALL_OW 428
59180: PPUSH
59181: CALL_OW 247
59185: PUSH
59186: LD_INT 3
59188: PUSH
59189: LD_INT 2
59191: PUSH
59192: EMPTY
59193: LIST
59194: LIST
59195: IN
59196: NOT
59197: AND
59198: IFFALSE 59242
// begin ComMoveXY ( unit , _x , _y ) ;
59200: LD_VAR 0 1
59204: PPUSH
59205: LD_VAR 0 5
59209: PPUSH
59210: LD_VAR 0 7
59214: PPUSH
59215: CALL_OW 111
// result := [ _x , _y ] ;
59219: LD_ADDR_VAR 0 3
59223: PUSH
59224: LD_VAR 0 5
59228: PUSH
59229: LD_VAR 0 7
59233: PUSH
59234: EMPTY
59235: LIST
59236: LIST
59237: ST_TO_ADDR
// exit ;
59238: POP
59239: POP
59240: GO 59246
// end ; end ;
59242: GO 59084
59244: POP
59245: POP
// end ;
59246: LD_VAR 0 3
59250: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
59251: LD_INT 0
59253: PPUSH
59254: PPUSH
59255: PPUSH
// result := 0 ;
59256: LD_ADDR_VAR 0 3
59260: PUSH
59261: LD_INT 0
59263: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
59264: LD_VAR 0 1
59268: PUSH
59269: LD_INT 0
59271: LESS
59272: IFTRUE 59284
59274: PUSH
59275: LD_VAR 0 1
59279: PUSH
59280: LD_INT 8
59282: GREATER
59283: OR
59284: IFTRUE 59296
59286: PUSH
59287: LD_VAR 0 2
59291: PUSH
59292: LD_INT 0
59294: LESS
59295: OR
59296: IFTRUE 59308
59298: PUSH
59299: LD_VAR 0 2
59303: PUSH
59304: LD_INT 8
59306: GREATER
59307: OR
59308: IFFALSE 59312
// exit ;
59310: GO 59387
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
59312: LD_ADDR_VAR 0 4
59316: PUSH
59317: LD_INT 22
59319: PUSH
59320: LD_VAR 0 2
59324: PUSH
59325: EMPTY
59326: LIST
59327: LIST
59328: PPUSH
59329: CALL_OW 69
59333: PUSH
59334: FOR_IN
59335: IFFALSE 59385
// begin un := UnitShoot ( i ) ;
59337: LD_ADDR_VAR 0 5
59341: PUSH
59342: LD_VAR 0 4
59346: PPUSH
59347: CALL_OW 504
59351: ST_TO_ADDR
// if GetSide ( un ) = side1 then
59352: LD_VAR 0 5
59356: PPUSH
59357: CALL_OW 255
59361: PUSH
59362: LD_VAR 0 1
59366: EQUAL
59367: IFFALSE 59383
// begin result := un ;
59369: LD_ADDR_VAR 0 3
59373: PUSH
59374: LD_VAR 0 5
59378: ST_TO_ADDR
// exit ;
59379: POP
59380: POP
59381: GO 59387
// end ; end ;
59383: GO 59334
59385: POP
59386: POP
// end ;
59387: LD_VAR 0 3
59391: RET
// export function GetCargoBay ( units ) ; begin
59392: LD_INT 0
59394: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
59395: LD_ADDR_VAR 0 2
59399: PUSH
59400: LD_VAR 0 1
59404: PPUSH
59405: LD_INT 2
59407: PUSH
59408: LD_INT 34
59410: PUSH
59411: LD_INT 12
59413: PUSH
59414: EMPTY
59415: LIST
59416: LIST
59417: PUSH
59418: LD_INT 34
59420: PUSH
59421: LD_INT 51
59423: PUSH
59424: EMPTY
59425: LIST
59426: LIST
59427: PUSH
59428: LD_INT 34
59430: PUSH
59431: LD_INT 32
59433: PUSH
59434: EMPTY
59435: LIST
59436: LIST
59437: PUSH
59438: LD_INT 34
59440: PUSH
59441: LD_INT 89
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: PUSH
59448: EMPTY
59449: LIST
59450: LIST
59451: LIST
59452: LIST
59453: LIST
59454: PPUSH
59455: CALL_OW 72
59459: ST_TO_ADDR
// end ;
59460: LD_VAR 0 2
59464: RET
// export function Negate ( value ) ; begin
59465: LD_INT 0
59467: PPUSH
// result := not value ;
59468: LD_ADDR_VAR 0 2
59472: PUSH
59473: LD_VAR 0 1
59477: NOT
59478: ST_TO_ADDR
// end ;
59479: LD_VAR 0 2
59483: RET
// export function Inc ( value ) ; begin
59484: LD_INT 0
59486: PPUSH
// result := value + 1 ;
59487: LD_ADDR_VAR 0 2
59491: PUSH
59492: LD_VAR 0 1
59496: PUSH
59497: LD_INT 1
59499: PLUS
59500: ST_TO_ADDR
// end ;
59501: LD_VAR 0 2
59505: RET
// export function Dec ( value ) ; begin
59506: LD_INT 0
59508: PPUSH
// result := value - 1 ;
59509: LD_ADDR_VAR 0 2
59513: PUSH
59514: LD_VAR 0 1
59518: PUSH
59519: LD_INT 1
59521: MINUS
59522: ST_TO_ADDR
// end ;
59523: LD_VAR 0 2
59527: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
59528: LD_INT 0
59530: PPUSH
59531: PPUSH
59532: PPUSH
59533: PPUSH
59534: PPUSH
59535: PPUSH
59536: PPUSH
59537: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
59538: LD_VAR 0 1
59542: PPUSH
59543: LD_VAR 0 2
59547: PPUSH
59548: CALL_OW 488
59552: NOT
59553: IFTRUE 59572
59555: PUSH
59556: LD_VAR 0 3
59560: PPUSH
59561: LD_VAR 0 4
59565: PPUSH
59566: CALL_OW 488
59570: NOT
59571: OR
59572: IFFALSE 59585
// begin result := - 1 ;
59574: LD_ADDR_VAR 0 5
59578: PUSH
59579: LD_INT 1
59581: NEG
59582: ST_TO_ADDR
// exit ;
59583: GO 59820
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
59585: LD_ADDR_VAR 0 12
59589: PUSH
59590: LD_VAR 0 1
59594: PPUSH
59595: LD_VAR 0 2
59599: PPUSH
59600: LD_VAR 0 3
59604: PPUSH
59605: LD_VAR 0 4
59609: PPUSH
59610: CALL 58656 0 4
59614: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
59615: LD_ADDR_VAR 0 11
59619: PUSH
59620: LD_VAR 0 1
59624: PPUSH
59625: LD_VAR 0 2
59629: PPUSH
59630: LD_VAR 0 12
59634: PUSH
59635: LD_INT 1
59637: ARRAY
59638: PPUSH
59639: LD_VAR 0 12
59643: PUSH
59644: LD_INT 2
59646: ARRAY
59647: PPUSH
59648: CALL_OW 298
59652: ST_TO_ADDR
// distance := 9999 ;
59653: LD_ADDR_VAR 0 10
59657: PUSH
59658: LD_INT 9999
59660: ST_TO_ADDR
// for i := 0 to 5 do
59661: LD_ADDR_VAR 0 6
59665: PUSH
59666: DOUBLE
59667: LD_INT 0
59669: DEC
59670: ST_TO_ADDR
59671: LD_INT 5
59673: PUSH
59674: FOR_TO
59675: IFFALSE 59818
// begin _x := ShiftX ( x1 , i , centerDist ) ;
59677: LD_ADDR_VAR 0 7
59681: PUSH
59682: LD_VAR 0 1
59686: PPUSH
59687: LD_VAR 0 6
59691: PPUSH
59692: LD_VAR 0 11
59696: PPUSH
59697: CALL_OW 272
59701: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
59702: LD_ADDR_VAR 0 8
59706: PUSH
59707: LD_VAR 0 2
59711: PPUSH
59712: LD_VAR 0 6
59716: PPUSH
59717: LD_VAR 0 11
59721: PPUSH
59722: CALL_OW 273
59726: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
59727: LD_VAR 0 7
59731: PPUSH
59732: LD_VAR 0 8
59736: PPUSH
59737: CALL_OW 488
59741: NOT
59742: IFFALSE 59746
// continue ;
59744: GO 59674
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
59746: LD_ADDR_VAR 0 9
59750: PUSH
59751: LD_VAR 0 12
59755: PUSH
59756: LD_INT 1
59758: ARRAY
59759: PPUSH
59760: LD_VAR 0 12
59764: PUSH
59765: LD_INT 2
59767: ARRAY
59768: PPUSH
59769: LD_VAR 0 7
59773: PPUSH
59774: LD_VAR 0 8
59778: PPUSH
59779: CALL_OW 298
59783: ST_TO_ADDR
// if tmp < distance then
59784: LD_VAR 0 9
59788: PUSH
59789: LD_VAR 0 10
59793: LESS
59794: IFFALSE 59816
// begin result := i ;
59796: LD_ADDR_VAR 0 5
59800: PUSH
59801: LD_VAR 0 6
59805: ST_TO_ADDR
// distance := tmp ;
59806: LD_ADDR_VAR 0 10
59810: PUSH
59811: LD_VAR 0 9
59815: ST_TO_ADDR
// end ; end ;
59816: GO 59674
59818: POP
59819: POP
// end ;
59820: LD_VAR 0 5
59824: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59825: LD_INT 0
59827: PPUSH
59828: PPUSH
// if not driver or not IsInUnit ( driver ) then
59829: LD_VAR 0 1
59833: NOT
59834: IFTRUE 59848
59836: PUSH
59837: LD_VAR 0 1
59841: PPUSH
59842: CALL_OW 310
59846: NOT
59847: OR
59848: IFFALSE 59852
// exit ;
59850: GO 59942
// vehicle := IsInUnit ( driver ) ;
59852: LD_ADDR_VAR 0 3
59856: PUSH
59857: LD_VAR 0 1
59861: PPUSH
59862: CALL_OW 310
59866: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59867: LD_VAR 0 1
59871: PPUSH
59872: LD_STRING \
59874: PUSH
59875: LD_INT 0
59877: PUSH
59878: LD_INT 0
59880: PUSH
59881: LD_INT 0
59883: PUSH
59884: LD_INT 0
59886: PUSH
59887: LD_INT 0
59889: PUSH
59890: LD_INT 0
59892: PUSH
59893: EMPTY
59894: LIST
59895: LIST
59896: LIST
59897: LIST
59898: LIST
59899: LIST
59900: LIST
59901: PUSH
59902: LD_STRING E
59904: PUSH
59905: LD_INT 0
59907: PUSH
59908: LD_INT 0
59910: PUSH
59911: LD_VAR 0 3
59915: PUSH
59916: LD_INT 0
59918: PUSH
59919: LD_INT 0
59921: PUSH
59922: LD_INT 0
59924: PUSH
59925: EMPTY
59926: LIST
59927: LIST
59928: LIST
59929: LIST
59930: LIST
59931: LIST
59932: LIST
59933: PUSH
59934: EMPTY
59935: LIST
59936: LIST
59937: PPUSH
59938: CALL_OW 446
// end ;
59942: LD_VAR 0 2
59946: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59947: LD_INT 0
59949: PPUSH
59950: PPUSH
// if not driver or not IsInUnit ( driver ) then
59951: LD_VAR 0 1
59955: NOT
59956: IFTRUE 59970
59958: PUSH
59959: LD_VAR 0 1
59963: PPUSH
59964: CALL_OW 310
59968: NOT
59969: OR
59970: IFFALSE 59974
// exit ;
59972: GO 60064
// vehicle := IsInUnit ( driver ) ;
59974: LD_ADDR_VAR 0 3
59978: PUSH
59979: LD_VAR 0 1
59983: PPUSH
59984: CALL_OW 310
59988: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59989: LD_VAR 0 1
59993: PPUSH
59994: LD_STRING \
59996: PUSH
59997: LD_INT 0
59999: PUSH
60000: LD_INT 0
60002: PUSH
60003: LD_INT 0
60005: PUSH
60006: LD_INT 0
60008: PUSH
60009: LD_INT 0
60011: PUSH
60012: LD_INT 0
60014: PUSH
60015: EMPTY
60016: LIST
60017: LIST
60018: LIST
60019: LIST
60020: LIST
60021: LIST
60022: LIST
60023: PUSH
60024: LD_STRING E
60026: PUSH
60027: LD_INT 0
60029: PUSH
60030: LD_INT 0
60032: PUSH
60033: LD_VAR 0 3
60037: PUSH
60038: LD_INT 0
60040: PUSH
60041: LD_INT 0
60043: PUSH
60044: LD_INT 0
60046: PUSH
60047: EMPTY
60048: LIST
60049: LIST
60050: LIST
60051: LIST
60052: LIST
60053: LIST
60054: LIST
60055: PUSH
60056: EMPTY
60057: LIST
60058: LIST
60059: PPUSH
60060: CALL_OW 447
// end ;
60064: LD_VAR 0 2
60068: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
60069: LD_INT 0
60071: PPUSH
60072: PPUSH
60073: PPUSH
// tmp := [ ] ;
60074: LD_ADDR_VAR 0 5
60078: PUSH
60079: EMPTY
60080: ST_TO_ADDR
// for i in units do
60081: LD_ADDR_VAR 0 4
60085: PUSH
60086: LD_VAR 0 1
60090: PUSH
60091: FOR_IN
60092: IFFALSE 60130
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
60094: LD_ADDR_VAR 0 5
60098: PUSH
60099: LD_VAR 0 5
60103: PPUSH
60104: LD_VAR 0 5
60108: PUSH
60109: LD_INT 1
60111: PLUS
60112: PPUSH
60113: LD_VAR 0 4
60117: PPUSH
60118: CALL_OW 256
60122: PPUSH
60123: CALL_OW 2
60127: ST_TO_ADDR
60128: GO 60091
60130: POP
60131: POP
// if not tmp then
60132: LD_VAR 0 5
60136: NOT
60137: IFFALSE 60141
// exit ;
60139: GO 60189
// if asc then
60141: LD_VAR 0 2
60145: IFFALSE 60169
// result := SortListByListAsc ( units , tmp ) else
60147: LD_ADDR_VAR 0 3
60151: PUSH
60152: LD_VAR 0 1
60156: PPUSH
60157: LD_VAR 0 5
60161: PPUSH
60162: CALL_OW 76
60166: ST_TO_ADDR
60167: GO 60189
// result := SortListByListDesc ( units , tmp ) ;
60169: LD_ADDR_VAR 0 3
60173: PUSH
60174: LD_VAR 0 1
60178: PPUSH
60179: LD_VAR 0 5
60183: PPUSH
60184: CALL_OW 77
60188: ST_TO_ADDR
// end ;
60189: LD_VAR 0 3
60193: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
60194: LD_INT 0
60196: PPUSH
60197: PPUSH
// task := GetTaskList ( mech ) ;
60198: LD_ADDR_VAR 0 4
60202: PUSH
60203: LD_VAR 0 1
60207: PPUSH
60208: CALL_OW 437
60212: ST_TO_ADDR
// if not task then
60213: LD_VAR 0 4
60217: NOT
60218: IFFALSE 60222
// exit ;
60220: GO 60266
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
60222: LD_ADDR_VAR 0 3
60226: PUSH
60227: LD_VAR 0 4
60231: PUSH
60232: LD_INT 1
60234: ARRAY
60235: PUSH
60236: LD_INT 1
60238: ARRAY
60239: PUSH
60240: LD_STRING r
60242: EQUAL
60243: IFFALSE 60265
60245: PUSH
60246: LD_VAR 0 4
60250: PUSH
60251: LD_INT 1
60253: ARRAY
60254: PUSH
60255: LD_INT 4
60257: ARRAY
60258: PUSH
60259: LD_VAR 0 2
60263: EQUAL
60264: AND
60265: ST_TO_ADDR
// end ;
60266: LD_VAR 0 3
60270: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
60271: LD_INT 0
60273: PPUSH
// SetDir ( unit , d ) ;
60274: LD_VAR 0 1
60278: PPUSH
60279: LD_VAR 0 4
60283: PPUSH
60284: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
60288: LD_ADDR_VAR 0 6
60292: PUSH
60293: LD_VAR 0 1
60297: PPUSH
60298: LD_VAR 0 2
60302: PPUSH
60303: LD_VAR 0 3
60307: PPUSH
60308: LD_VAR 0 5
60312: PPUSH
60313: CALL_OW 48
60317: ST_TO_ADDR
// end ;
60318: LD_VAR 0 6
60322: RET
// export function ToNaturalNumber ( number ) ; begin
60323: LD_INT 0
60325: PPUSH
// result := number div 1 ;
60326: LD_ADDR_VAR 0 2
60330: PUSH
60331: LD_VAR 0 1
60335: PUSH
60336: LD_INT 1
60338: DIV
60339: ST_TO_ADDR
// if number < 0 then
60340: LD_VAR 0 1
60344: PUSH
60345: LD_INT 0
60347: LESS
60348: IFFALSE 60358
// result := 0 ;
60350: LD_ADDR_VAR 0 2
60354: PUSH
60355: LD_INT 0
60357: ST_TO_ADDR
// end ;
60358: LD_VAR 0 2
60362: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
60363: LD_INT 0
60365: PPUSH
60366: PPUSH
60367: PPUSH
// if not buildings then
60368: LD_VAR 0 1
60372: NOT
60373: IFFALSE 60377
// exit ;
60375: GO 60492
// tmp := [ ] ;
60377: LD_ADDR_VAR 0 5
60381: PUSH
60382: EMPTY
60383: ST_TO_ADDR
// for b in buildings do
60384: LD_ADDR_VAR 0 4
60388: PUSH
60389: LD_VAR 0 1
60393: PUSH
60394: FOR_IN
60395: IFFALSE 60433
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
60397: LD_ADDR_VAR 0 5
60401: PUSH
60402: LD_VAR 0 5
60406: PPUSH
60407: LD_VAR 0 5
60411: PUSH
60412: LD_INT 1
60414: PLUS
60415: PPUSH
60416: LD_VAR 0 4
60420: PPUSH
60421: CALL_OW 266
60425: PPUSH
60426: CALL_OW 1
60430: ST_TO_ADDR
60431: GO 60394
60433: POP
60434: POP
// if not tmp then
60435: LD_VAR 0 5
60439: NOT
60440: IFFALSE 60444
// exit ;
60442: GO 60492
// if asc then
60444: LD_VAR 0 2
60448: IFFALSE 60472
// result := SortListByListAsc ( buildings , tmp ) else
60450: LD_ADDR_VAR 0 3
60454: PUSH
60455: LD_VAR 0 1
60459: PPUSH
60460: LD_VAR 0 5
60464: PPUSH
60465: CALL_OW 76
60469: ST_TO_ADDR
60470: GO 60492
// result := SortListByListDesc ( buildings , tmp ) ;
60472: LD_ADDR_VAR 0 3
60476: PUSH
60477: LD_VAR 0 1
60481: PPUSH
60482: LD_VAR 0 5
60486: PPUSH
60487: CALL_OW 77
60491: ST_TO_ADDR
// end ;
60492: LD_VAR 0 3
60496: RET
// export function SortByClass ( units , class ) ; var un ; begin
60497: LD_INT 0
60499: PPUSH
60500: PPUSH
// if not units or not class then
60501: LD_VAR 0 1
60505: NOT
60506: IFTRUE 60515
60508: PUSH
60509: LD_VAR 0 2
60513: NOT
60514: OR
60515: IFFALSE 60519
// exit ;
60517: GO 60614
// result := [ ] ;
60519: LD_ADDR_VAR 0 3
60523: PUSH
60524: EMPTY
60525: ST_TO_ADDR
// for un in units do
60526: LD_ADDR_VAR 0 4
60530: PUSH
60531: LD_VAR 0 1
60535: PUSH
60536: FOR_IN
60537: IFFALSE 60612
// if GetClass ( un ) = class then
60539: LD_VAR 0 4
60543: PPUSH
60544: CALL_OW 257
60548: PUSH
60549: LD_VAR 0 2
60553: EQUAL
60554: IFFALSE 60581
// result := Insert ( result , 1 , un ) else
60556: LD_ADDR_VAR 0 3
60560: PUSH
60561: LD_VAR 0 3
60565: PPUSH
60566: LD_INT 1
60568: PPUSH
60569: LD_VAR 0 4
60573: PPUSH
60574: CALL_OW 2
60578: ST_TO_ADDR
60579: GO 60610
// result := Replace ( result , result + 1 , un ) ;
60581: LD_ADDR_VAR 0 3
60585: PUSH
60586: LD_VAR 0 3
60590: PPUSH
60591: LD_VAR 0 3
60595: PUSH
60596: LD_INT 1
60598: PLUS
60599: PPUSH
60600: LD_VAR 0 4
60604: PPUSH
60605: CALL_OW 1
60609: ST_TO_ADDR
60610: GO 60536
60612: POP
60613: POP
// end ;
60614: LD_VAR 0 3
60618: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
60619: LD_INT 0
60621: PPUSH
60622: PPUSH
60623: PPUSH
60624: PPUSH
60625: PPUSH
60626: PPUSH
60627: PPUSH
// result := [ ] ;
60628: LD_ADDR_VAR 0 4
60632: PUSH
60633: EMPTY
60634: ST_TO_ADDR
// if x - r < 0 then
60635: LD_VAR 0 1
60639: PUSH
60640: LD_VAR 0 3
60644: MINUS
60645: PUSH
60646: LD_INT 0
60648: LESS
60649: IFFALSE 60661
// min_x := 0 else
60651: LD_ADDR_VAR 0 8
60655: PUSH
60656: LD_INT 0
60658: ST_TO_ADDR
60659: GO 60677
// min_x := x - r ;
60661: LD_ADDR_VAR 0 8
60665: PUSH
60666: LD_VAR 0 1
60670: PUSH
60671: LD_VAR 0 3
60675: MINUS
60676: ST_TO_ADDR
// if y - r < 0 then
60677: LD_VAR 0 2
60681: PUSH
60682: LD_VAR 0 3
60686: MINUS
60687: PUSH
60688: LD_INT 0
60690: LESS
60691: IFFALSE 60703
// min_y := 0 else
60693: LD_ADDR_VAR 0 7
60697: PUSH
60698: LD_INT 0
60700: ST_TO_ADDR
60701: GO 60719
// min_y := y - r ;
60703: LD_ADDR_VAR 0 7
60707: PUSH
60708: LD_VAR 0 2
60712: PUSH
60713: LD_VAR 0 3
60717: MINUS
60718: ST_TO_ADDR
// max_x := x + r ;
60719: LD_ADDR_VAR 0 9
60723: PUSH
60724: LD_VAR 0 1
60728: PUSH
60729: LD_VAR 0 3
60733: PLUS
60734: ST_TO_ADDR
// max_y := y + r ;
60735: LD_ADDR_VAR 0 10
60739: PUSH
60740: LD_VAR 0 2
60744: PUSH
60745: LD_VAR 0 3
60749: PLUS
60750: ST_TO_ADDR
// for _x = min_x to max_x do
60751: LD_ADDR_VAR 0 5
60755: PUSH
60756: DOUBLE
60757: LD_VAR 0 8
60761: DEC
60762: ST_TO_ADDR
60763: LD_VAR 0 9
60767: PUSH
60768: FOR_TO
60769: IFFALSE 60870
// for _y = min_y to max_y do
60771: LD_ADDR_VAR 0 6
60775: PUSH
60776: DOUBLE
60777: LD_VAR 0 7
60781: DEC
60782: ST_TO_ADDR
60783: LD_VAR 0 10
60787: PUSH
60788: FOR_TO
60789: IFFALSE 60866
// begin if not ValidHex ( _x , _y ) then
60791: LD_VAR 0 5
60795: PPUSH
60796: LD_VAR 0 6
60800: PPUSH
60801: CALL_OW 488
60805: NOT
60806: IFFALSE 60810
// continue ;
60808: GO 60788
// if GetResourceTypeXY ( _x , _y ) then
60810: LD_VAR 0 5
60814: PPUSH
60815: LD_VAR 0 6
60819: PPUSH
60820: CALL_OW 283
60824: IFFALSE 60864
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
60826: LD_ADDR_VAR 0 4
60830: PUSH
60831: LD_VAR 0 4
60835: PPUSH
60836: LD_VAR 0 4
60840: PUSH
60841: LD_INT 1
60843: PLUS
60844: PPUSH
60845: LD_VAR 0 5
60849: PUSH
60850: LD_VAR 0 6
60854: PUSH
60855: EMPTY
60856: LIST
60857: LIST
60858: PPUSH
60859: CALL_OW 1
60863: ST_TO_ADDR
// end ;
60864: GO 60788
60866: POP
60867: POP
60868: GO 60768
60870: POP
60871: POP
// end ;
60872: LD_VAR 0 4
60876: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
60877: LD_INT 0
60879: PPUSH
60880: PPUSH
60881: PPUSH
60882: PPUSH
60883: PPUSH
60884: PPUSH
60885: PPUSH
60886: PPUSH
// if not units then
60887: LD_VAR 0 1
60891: NOT
60892: IFFALSE 60896
// exit ;
60894: GO 61428
// result := UnitFilter ( units , [ f_ok ] ) ;
60896: LD_ADDR_VAR 0 3
60900: PUSH
60901: LD_VAR 0 1
60905: PPUSH
60906: LD_INT 50
60908: PUSH
60909: EMPTY
60910: LIST
60911: PPUSH
60912: CALL_OW 72
60916: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
60917: LD_ADDR_VAR 0 8
60921: PUSH
60922: LD_VAR 0 1
60926: PUSH
60927: LD_INT 1
60929: ARRAY
60930: PPUSH
60931: CALL_OW 255
60935: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
60936: LD_ADDR_VAR 0 10
60940: PUSH
60941: LD_INT 29
60943: PUSH
60944: LD_INT 91
60946: PUSH
60947: LD_INT 49
60949: PUSH
60950: EMPTY
60951: LIST
60952: LIST
60953: LIST
60954: ST_TO_ADDR
// if not result then
60955: LD_VAR 0 3
60959: NOT
60960: IFFALSE 60964
// exit ;
60962: GO 61428
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
60964: LD_ADDR_VAR 0 5
60968: PUSH
60969: LD_INT 81
60971: PUSH
60972: LD_VAR 0 8
60976: PUSH
60977: EMPTY
60978: LIST
60979: LIST
60980: PPUSH
60981: CALL_OW 69
60985: ST_TO_ADDR
// for i in result do
60986: LD_ADDR_VAR 0 4
60990: PUSH
60991: LD_VAR 0 3
60995: PUSH
60996: FOR_IN
60997: IFFALSE 61426
// begin tag := GetTag ( i ) + 1 ;
60999: LD_ADDR_VAR 0 9
61003: PUSH
61004: LD_VAR 0 4
61008: PPUSH
61009: CALL_OW 110
61013: PUSH
61014: LD_INT 1
61016: PLUS
61017: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
61018: LD_ADDR_VAR 0 7
61022: PUSH
61023: LD_VAR 0 4
61027: PPUSH
61028: CALL_OW 250
61032: PPUSH
61033: LD_VAR 0 4
61037: PPUSH
61038: CALL_OW 251
61042: PPUSH
61043: LD_INT 4
61045: PPUSH
61046: CALL 60619 0 3
61050: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
61051: LD_VAR 0 4
61055: PPUSH
61056: CALL_OW 247
61060: PUSH
61061: LD_INT 2
61063: EQUAL
61064: IFFALSE 61076
61066: PUSH
61067: LD_VAR 0 7
61071: PUSH
61072: LD_INT 2
61074: GREATER
61075: AND
61076: IFFALSE 61096
61078: PUSH
61079: LD_VAR 0 4
61083: PPUSH
61084: CALL_OW 264
61088: PUSH
61089: LD_VAR 0 10
61093: IN
61094: NOT
61095: AND
61096: IFFALSE 61135
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
61098: LD_VAR 0 4
61102: PPUSH
61103: LD_VAR 0 7
61107: PUSH
61108: LD_INT 1
61110: ARRAY
61111: PUSH
61112: LD_INT 1
61114: ARRAY
61115: PPUSH
61116: LD_VAR 0 7
61120: PUSH
61121: LD_INT 1
61123: ARRAY
61124: PUSH
61125: LD_INT 2
61127: ARRAY
61128: PPUSH
61129: CALL_OW 116
61133: GO 61424
// if path > tag then
61135: LD_VAR 0 2
61139: PUSH
61140: LD_VAR 0 9
61144: GREATER
61145: IFFALSE 61353
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
61147: LD_ADDR_VAR 0 6
61151: PUSH
61152: LD_VAR 0 5
61156: PPUSH
61157: LD_INT 91
61159: PUSH
61160: LD_VAR 0 4
61164: PUSH
61165: LD_INT 8
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: LIST
61172: PPUSH
61173: CALL_OW 72
61177: ST_TO_ADDR
// if nearEnemy then
61178: LD_VAR 0 6
61182: IFFALSE 61251
// begin if GetWeapon ( i ) = ru_time_lapser then
61184: LD_VAR 0 4
61188: PPUSH
61189: CALL_OW 264
61193: PUSH
61194: LD_INT 49
61196: EQUAL
61197: IFFALSE 61225
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
61199: LD_VAR 0 4
61203: PPUSH
61204: LD_VAR 0 6
61208: PPUSH
61209: LD_VAR 0 4
61213: PPUSH
61214: CALL_OW 74
61218: PPUSH
61219: CALL_OW 112
61223: GO 61249
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
61225: LD_VAR 0 4
61229: PPUSH
61230: LD_VAR 0 6
61234: PPUSH
61235: LD_VAR 0 4
61239: PPUSH
61240: CALL_OW 74
61244: PPUSH
61245: CALL 62509 0 2
// end else
61249: GO 61351
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
61251: LD_VAR 0 4
61255: PPUSH
61256: LD_VAR 0 2
61260: PUSH
61261: LD_VAR 0 9
61265: ARRAY
61266: PUSH
61267: LD_INT 1
61269: ARRAY
61270: PPUSH
61271: LD_VAR 0 2
61275: PUSH
61276: LD_VAR 0 9
61280: ARRAY
61281: PUSH
61282: LD_INT 2
61284: ARRAY
61285: PPUSH
61286: CALL_OW 297
61290: PUSH
61291: LD_INT 6
61293: GREATER
61294: IFFALSE 61337
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
61296: LD_VAR 0 4
61300: PPUSH
61301: LD_VAR 0 2
61305: PUSH
61306: LD_VAR 0 9
61310: ARRAY
61311: PUSH
61312: LD_INT 1
61314: ARRAY
61315: PPUSH
61316: LD_VAR 0 2
61320: PUSH
61321: LD_VAR 0 9
61325: ARRAY
61326: PUSH
61327: LD_INT 2
61329: ARRAY
61330: PPUSH
61331: CALL_OW 114
61335: GO 61351
// SetTag ( i , tag ) ;
61337: LD_VAR 0 4
61341: PPUSH
61342: LD_VAR 0 9
61346: PPUSH
61347: CALL_OW 109
// end else
61351: GO 61424
// if enemy then
61353: LD_VAR 0 5
61357: IFFALSE 61424
// begin if GetWeapon ( i ) = ru_time_lapser then
61359: LD_VAR 0 4
61363: PPUSH
61364: CALL_OW 264
61368: PUSH
61369: LD_INT 49
61371: EQUAL
61372: IFFALSE 61400
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
61374: LD_VAR 0 4
61378: PPUSH
61379: LD_VAR 0 5
61383: PPUSH
61384: LD_VAR 0 4
61388: PPUSH
61389: CALL_OW 74
61393: PPUSH
61394: CALL_OW 112
61398: GO 61424
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
61400: LD_VAR 0 4
61404: PPUSH
61405: LD_VAR 0 5
61409: PPUSH
61410: LD_VAR 0 4
61414: PPUSH
61415: CALL_OW 74
61419: PPUSH
61420: CALL 62509 0 2
// end ; end ;
61424: GO 60996
61426: POP
61427: POP
// end ;
61428: LD_VAR 0 3
61432: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
61433: LD_INT 0
61435: PPUSH
61436: PPUSH
61437: PPUSH
// if not unit or IsInUnit ( unit ) then
61438: LD_VAR 0 1
61442: NOT
61443: IFTRUE 61456
61445: PUSH
61446: LD_VAR 0 1
61450: PPUSH
61451: CALL_OW 310
61455: OR
61456: IFFALSE 61460
// exit ;
61458: GO 61551
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
61460: LD_ADDR_VAR 0 4
61464: PUSH
61465: LD_VAR 0 1
61469: PPUSH
61470: CALL_OW 250
61474: PPUSH
61475: LD_VAR 0 2
61479: PPUSH
61480: LD_INT 1
61482: PPUSH
61483: CALL_OW 272
61487: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
61488: LD_ADDR_VAR 0 5
61492: PUSH
61493: LD_VAR 0 1
61497: PPUSH
61498: CALL_OW 251
61502: PPUSH
61503: LD_VAR 0 2
61507: PPUSH
61508: LD_INT 1
61510: PPUSH
61511: CALL_OW 273
61515: ST_TO_ADDR
// if ValidHex ( x , y ) then
61516: LD_VAR 0 4
61520: PPUSH
61521: LD_VAR 0 5
61525: PPUSH
61526: CALL_OW 488
61530: IFFALSE 61551
// ComTurnXY ( unit , x , y ) ;
61532: LD_VAR 0 1
61536: PPUSH
61537: LD_VAR 0 4
61541: PPUSH
61542: LD_VAR 0 5
61546: PPUSH
61547: CALL_OW 118
// end ;
61551: LD_VAR 0 3
61555: RET
// export function SeeUnits ( side , units ) ; var i ; begin
61556: LD_INT 0
61558: PPUSH
61559: PPUSH
// result := false ;
61560: LD_ADDR_VAR 0 3
61564: PUSH
61565: LD_INT 0
61567: ST_TO_ADDR
// if not units then
61568: LD_VAR 0 2
61572: NOT
61573: IFFALSE 61577
// exit ;
61575: GO 61622
// for i in units do
61577: LD_ADDR_VAR 0 4
61581: PUSH
61582: LD_VAR 0 2
61586: PUSH
61587: FOR_IN
61588: IFFALSE 61620
// if See ( side , i ) then
61590: LD_VAR 0 1
61594: PPUSH
61595: LD_VAR 0 4
61599: PPUSH
61600: CALL_OW 292
61604: IFFALSE 61618
// begin result := true ;
61606: LD_ADDR_VAR 0 3
61610: PUSH
61611: LD_INT 1
61613: ST_TO_ADDR
// exit ;
61614: POP
61615: POP
61616: GO 61622
// end ;
61618: GO 61587
61620: POP
61621: POP
// end ;
61622: LD_VAR 0 3
61626: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
61627: LD_INT 0
61629: PPUSH
61630: PPUSH
61631: PPUSH
61632: PPUSH
// if not unit or not points then
61633: LD_VAR 0 1
61637: NOT
61638: IFTRUE 61647
61640: PUSH
61641: LD_VAR 0 2
61645: NOT
61646: OR
61647: IFFALSE 61651
// exit ;
61649: GO 61741
// dist := 99999 ;
61651: LD_ADDR_VAR 0 5
61655: PUSH
61656: LD_INT 99999
61658: ST_TO_ADDR
// for i in points do
61659: LD_ADDR_VAR 0 4
61663: PUSH
61664: LD_VAR 0 2
61668: PUSH
61669: FOR_IN
61670: IFFALSE 61739
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
61672: LD_ADDR_VAR 0 6
61676: PUSH
61677: LD_VAR 0 1
61681: PPUSH
61682: LD_VAR 0 4
61686: PUSH
61687: LD_INT 1
61689: ARRAY
61690: PPUSH
61691: LD_VAR 0 4
61695: PUSH
61696: LD_INT 2
61698: ARRAY
61699: PPUSH
61700: CALL_OW 297
61704: ST_TO_ADDR
// if tmpDist < dist then
61705: LD_VAR 0 6
61709: PUSH
61710: LD_VAR 0 5
61714: LESS
61715: IFFALSE 61737
// begin result := i ;
61717: LD_ADDR_VAR 0 3
61721: PUSH
61722: LD_VAR 0 4
61726: ST_TO_ADDR
// dist := tmpDist ;
61727: LD_ADDR_VAR 0 5
61731: PUSH
61732: LD_VAR 0 6
61736: ST_TO_ADDR
// end ; end ;
61737: GO 61669
61739: POP
61740: POP
// end ;
61741: LD_VAR 0 3
61745: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
61746: LD_INT 0
61748: PPUSH
// uc_side := side ;
61749: LD_ADDR_OWVAR 20
61753: PUSH
61754: LD_VAR 0 1
61758: ST_TO_ADDR
// uc_nation := 3 ;
61759: LD_ADDR_OWVAR 21
61763: PUSH
61764: LD_INT 3
61766: ST_TO_ADDR
// vc_chassis := 25 ;
61767: LD_ADDR_OWVAR 37
61771: PUSH
61772: LD_INT 25
61774: ST_TO_ADDR
// vc_engine := engine_siberite ;
61775: LD_ADDR_OWVAR 39
61779: PUSH
61780: LD_INT 3
61782: ST_TO_ADDR
// vc_control := control_computer ;
61783: LD_ADDR_OWVAR 38
61787: PUSH
61788: LD_INT 3
61790: ST_TO_ADDR
// vc_weapon := 59 ;
61791: LD_ADDR_OWVAR 40
61795: PUSH
61796: LD_INT 59
61798: ST_TO_ADDR
// result := CreateVehicle ;
61799: LD_ADDR_VAR 0 5
61803: PUSH
61804: CALL_OW 45
61808: ST_TO_ADDR
// SetDir ( result , d ) ;
61809: LD_VAR 0 5
61813: PPUSH
61814: LD_VAR 0 4
61818: PPUSH
61819: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
61823: LD_VAR 0 5
61827: PPUSH
61828: LD_VAR 0 2
61832: PPUSH
61833: LD_VAR 0 3
61837: PPUSH
61838: LD_INT 0
61840: PPUSH
61841: CALL_OW 48
// end ;
61845: LD_VAR 0 5
61849: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
61850: LD_INT 0
61852: PPUSH
61853: PPUSH
61854: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
61855: LD_ADDR_VAR 0 2
61859: PUSH
61860: LD_INT 0
61862: PUSH
61863: LD_INT 0
61865: PUSH
61866: LD_INT 0
61868: PUSH
61869: LD_INT 0
61871: PUSH
61872: EMPTY
61873: LIST
61874: LIST
61875: LIST
61876: LIST
61877: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
61878: LD_VAR 0 1
61882: NOT
61883: IFTRUE 61916
61885: PUSH
61886: LD_VAR 0 1
61890: PPUSH
61891: CALL_OW 264
61895: PUSH
61896: LD_INT 12
61898: PUSH
61899: LD_INT 51
61901: PUSH
61902: LD_INT 32
61904: PUSH
61905: LD_INT 89
61907: PUSH
61908: EMPTY
61909: LIST
61910: LIST
61911: LIST
61912: LIST
61913: IN
61914: NOT
61915: OR
61916: IFFALSE 61920
// exit ;
61918: GO 62018
// for i := 1 to 3 do
61920: LD_ADDR_VAR 0 3
61924: PUSH
61925: DOUBLE
61926: LD_INT 1
61928: DEC
61929: ST_TO_ADDR
61930: LD_INT 3
61932: PUSH
61933: FOR_TO
61934: IFFALSE 62016
// begin tmp := GetCargo ( cargo , i ) ;
61936: LD_ADDR_VAR 0 4
61940: PUSH
61941: LD_VAR 0 1
61945: PPUSH
61946: LD_VAR 0 3
61950: PPUSH
61951: CALL_OW 289
61955: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
61956: LD_ADDR_VAR 0 2
61960: PUSH
61961: LD_VAR 0 2
61965: PPUSH
61966: LD_VAR 0 3
61970: PPUSH
61971: LD_VAR 0 4
61975: PPUSH
61976: CALL_OW 1
61980: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
61981: LD_ADDR_VAR 0 2
61985: PUSH
61986: LD_VAR 0 2
61990: PPUSH
61991: LD_INT 4
61993: PPUSH
61994: LD_VAR 0 2
61998: PUSH
61999: LD_INT 4
62001: ARRAY
62002: PUSH
62003: LD_VAR 0 4
62007: PLUS
62008: PPUSH
62009: CALL_OW 1
62013: ST_TO_ADDR
// end ;
62014: GO 61933
62016: POP
62017: POP
// end ;
62018: LD_VAR 0 2
62022: RET
// export function Length ( array ) ; begin
62023: LD_INT 0
62025: PPUSH
// result := array + 0 ;
62026: LD_ADDR_VAR 0 2
62030: PUSH
62031: LD_VAR 0 1
62035: PUSH
62036: LD_INT 0
62038: PLUS
62039: ST_TO_ADDR
// end ;
62040: LD_VAR 0 2
62044: RET
// export function PrepareArray ( array ) ; begin
62045: LD_INT 0
62047: PPUSH
// result := array diff 0 ;
62048: LD_ADDR_VAR 0 2
62052: PUSH
62053: LD_VAR 0 1
62057: PUSH
62058: LD_INT 0
62060: DIFF
62061: ST_TO_ADDR
// if not result [ 1 ] then
62062: LD_VAR 0 2
62066: PUSH
62067: LD_INT 1
62069: ARRAY
62070: NOT
62071: IFFALSE 62091
// result := Delete ( result , 1 ) ;
62073: LD_ADDR_VAR 0 2
62077: PUSH
62078: LD_VAR 0 2
62082: PPUSH
62083: LD_INT 1
62085: PPUSH
62086: CALL_OW 3
62090: ST_TO_ADDR
// end ;
62091: LD_VAR 0 2
62095: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
62096: LD_INT 0
62098: PPUSH
62099: PPUSH
62100: PPUSH
62101: PPUSH
// sibRocketRange := 25 ;
62102: LD_ADDR_VAR 0 6
62106: PUSH
62107: LD_INT 25
62109: ST_TO_ADDR
// result := false ;
62110: LD_ADDR_VAR 0 4
62114: PUSH
62115: LD_INT 0
62117: ST_TO_ADDR
// for i := 0 to 5 do
62118: LD_ADDR_VAR 0 5
62122: PUSH
62123: DOUBLE
62124: LD_INT 0
62126: DEC
62127: ST_TO_ADDR
62128: LD_INT 5
62130: PUSH
62131: FOR_TO
62132: IFFALSE 62199
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
62134: LD_VAR 0 1
62138: PPUSH
62139: LD_VAR 0 5
62143: PPUSH
62144: LD_VAR 0 6
62148: PPUSH
62149: CALL_OW 272
62153: PPUSH
62154: LD_VAR 0 2
62158: PPUSH
62159: LD_VAR 0 5
62163: PPUSH
62164: LD_VAR 0 6
62168: PPUSH
62169: CALL_OW 273
62173: PPUSH
62174: LD_VAR 0 3
62178: PPUSH
62179: CALL_OW 309
62183: IFFALSE 62197
// begin result := true ;
62185: LD_ADDR_VAR 0 4
62189: PUSH
62190: LD_INT 1
62192: ST_TO_ADDR
// exit ;
62193: POP
62194: POP
62195: GO 62201
// end ;
62197: GO 62131
62199: POP
62200: POP
// end ;
62201: LD_VAR 0 4
62205: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
62206: LD_INT 0
62208: PPUSH
62209: PPUSH
62210: PPUSH
// if btype = b_depot then
62211: LD_VAR 0 2
62215: PUSH
62216: LD_INT 0
62218: EQUAL
62219: IFFALSE 62231
// begin result := true ;
62221: LD_ADDR_VAR 0 3
62225: PUSH
62226: LD_INT 1
62228: ST_TO_ADDR
// exit ;
62229: GO 62351
// end ; pom := GetBase ( depot ) ;
62231: LD_ADDR_VAR 0 4
62235: PUSH
62236: LD_VAR 0 1
62240: PPUSH
62241: CALL_OW 274
62245: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62246: LD_ADDR_VAR 0 5
62250: PUSH
62251: LD_VAR 0 2
62255: PPUSH
62256: LD_VAR 0 1
62260: PPUSH
62261: CALL_OW 248
62265: PPUSH
62266: CALL_OW 450
62270: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
62271: LD_ADDR_VAR 0 3
62275: PUSH
62276: LD_VAR 0 4
62280: PPUSH
62281: LD_INT 1
62283: PPUSH
62284: CALL_OW 275
62288: PUSH
62289: LD_VAR 0 5
62293: PUSH
62294: LD_INT 1
62296: ARRAY
62297: GREATEREQUAL
62298: IFFALSE 62324
62300: PUSH
62301: LD_VAR 0 4
62305: PPUSH
62306: LD_INT 2
62308: PPUSH
62309: CALL_OW 275
62313: PUSH
62314: LD_VAR 0 5
62318: PUSH
62319: LD_INT 2
62321: ARRAY
62322: GREATEREQUAL
62323: AND
62324: IFFALSE 62350
62326: PUSH
62327: LD_VAR 0 4
62331: PPUSH
62332: LD_INT 3
62334: PPUSH
62335: CALL_OW 275
62339: PUSH
62340: LD_VAR 0 5
62344: PUSH
62345: LD_INT 3
62347: ARRAY
62348: GREATEREQUAL
62349: AND
62350: ST_TO_ADDR
// end ;
62351: LD_VAR 0 3
62355: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
62356: LD_INT 0
62358: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
62359: LD_VAR 0 1
62363: PPUSH
62364: LD_VAR 0 2
62368: PPUSH
62369: LD_INT 0
62371: PPUSH
62372: LD_INT 0
62374: PPUSH
62375: LD_INT 1
62377: PPUSH
62378: LD_INT 0
62380: PPUSH
62381: CALL_OW 587
// end ;
62385: LD_VAR 0 3
62389: RET
// export function CenterOnNow ( unit ) ; begin
62390: LD_INT 0
62392: PPUSH
// result := IsInUnit ( unit ) ;
62393: LD_ADDR_VAR 0 2
62397: PUSH
62398: LD_VAR 0 1
62402: PPUSH
62403: CALL_OW 310
62407: ST_TO_ADDR
// if not result then
62408: LD_VAR 0 2
62412: NOT
62413: IFFALSE 62425
// result := unit ;
62415: LD_ADDR_VAR 0 2
62419: PUSH
62420: LD_VAR 0 1
62424: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
62425: LD_VAR 0 1
62429: PPUSH
62430: CALL_OW 87
// end ;
62434: LD_VAR 0 2
62438: RET
// export function ComMoveHex ( unit , hex ) ; begin
62439: LD_INT 0
62441: PPUSH
// if not hex then
62442: LD_VAR 0 2
62446: NOT
62447: IFFALSE 62451
// exit ;
62449: GO 62504
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
62451: LD_VAR 0 2
62455: PUSH
62456: LD_INT 1
62458: ARRAY
62459: PPUSH
62460: LD_VAR 0 2
62464: PUSH
62465: LD_INT 2
62467: ARRAY
62468: PPUSH
62469: CALL_OW 428
62473: IFFALSE 62477
// exit ;
62475: GO 62504
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
62477: LD_VAR 0 1
62481: PPUSH
62482: LD_VAR 0 2
62486: PUSH
62487: LD_INT 1
62489: ARRAY
62490: PPUSH
62491: LD_VAR 0 2
62495: PUSH
62496: LD_INT 2
62498: ARRAY
62499: PPUSH
62500: CALL_OW 111
// end ;
62504: LD_VAR 0 3
62508: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
62509: LD_INT 0
62511: PPUSH
62512: PPUSH
62513: PPUSH
// if not unit or not enemy then
62514: LD_VAR 0 1
62518: NOT
62519: IFTRUE 62528
62521: PUSH
62522: LD_VAR 0 2
62526: NOT
62527: OR
62528: IFFALSE 62532
// exit ;
62530: GO 62658
// x := GetX ( enemy ) ;
62532: LD_ADDR_VAR 0 4
62536: PUSH
62537: LD_VAR 0 2
62541: PPUSH
62542: CALL_OW 250
62546: ST_TO_ADDR
// y := GetY ( enemy ) ;
62547: LD_ADDR_VAR 0 5
62551: PUSH
62552: LD_VAR 0 2
62556: PPUSH
62557: CALL_OW 251
62561: ST_TO_ADDR
// if ValidHex ( x , y ) then
62562: LD_VAR 0 4
62566: PPUSH
62567: LD_VAR 0 5
62571: PPUSH
62572: CALL_OW 488
62576: IFFALSE 62658
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
62578: LD_VAR 0 2
62582: PPUSH
62583: CALL_OW 247
62587: PUSH
62588: LD_INT 3
62590: PUSH
62591: LD_INT 2
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: IN
62598: IFTRUE 62621
62600: PUSH
62601: LD_VAR 0 1
62605: PPUSH
62606: CALL_OW 255
62610: PPUSH
62611: LD_VAR 0 2
62615: PPUSH
62616: CALL_OW 292
62620: OR
62621: IFFALSE 62639
// ComAttackUnit ( unit , enemy ) else
62623: LD_VAR 0 1
62627: PPUSH
62628: LD_VAR 0 2
62632: PPUSH
62633: CALL_OW 115
62637: GO 62658
// ComAgressiveMove ( unit , x , y ) ;
62639: LD_VAR 0 1
62643: PPUSH
62644: LD_VAR 0 4
62648: PPUSH
62649: LD_VAR 0 5
62653: PPUSH
62654: CALL_OW 114
// end ;
62658: LD_VAR 0 3
62662: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
62663: LD_INT 0
62665: PPUSH
62666: PPUSH
62667: PPUSH
// list := AreaToList ( area , 0 ) ;
62668: LD_ADDR_VAR 0 5
62672: PUSH
62673: LD_VAR 0 1
62677: PPUSH
62678: LD_INT 0
62680: PPUSH
62681: CALL_OW 517
62685: ST_TO_ADDR
// if not list then
62686: LD_VAR 0 5
62690: NOT
62691: IFFALSE 62695
// exit ;
62693: GO 62825
// if all then
62695: LD_VAR 0 2
62699: IFFALSE 62787
// begin for i := 1 to list [ 1 ] do
62701: LD_ADDR_VAR 0 4
62705: PUSH
62706: DOUBLE
62707: LD_INT 1
62709: DEC
62710: ST_TO_ADDR
62711: LD_VAR 0 5
62715: PUSH
62716: LD_INT 1
62718: ARRAY
62719: PUSH
62720: FOR_TO
62721: IFFALSE 62783
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62723: LD_ADDR_VAR 0 3
62727: PUSH
62728: LD_VAR 0 3
62732: PPUSH
62733: LD_VAR 0 3
62737: PUSH
62738: LD_INT 1
62740: PLUS
62741: PPUSH
62742: LD_VAR 0 5
62746: PUSH
62747: LD_INT 1
62749: ARRAY
62750: PUSH
62751: LD_VAR 0 4
62755: ARRAY
62756: PUSH
62757: LD_VAR 0 5
62761: PUSH
62762: LD_INT 2
62764: ARRAY
62765: PUSH
62766: LD_VAR 0 4
62770: ARRAY
62771: PUSH
62772: EMPTY
62773: LIST
62774: LIST
62775: PPUSH
62776: CALL_OW 1
62780: ST_TO_ADDR
62781: GO 62720
62783: POP
62784: POP
// exit ;
62785: GO 62825
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
62787: LD_ADDR_VAR 0 3
62791: PUSH
62792: LD_VAR 0 5
62796: PUSH
62797: LD_INT 1
62799: ARRAY
62800: PUSH
62801: LD_INT 1
62803: ARRAY
62804: PUSH
62805: LD_VAR 0 5
62809: PUSH
62810: LD_INT 2
62812: ARRAY
62813: PUSH
62814: LD_INT 1
62816: ARRAY
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: PUSH
62822: EMPTY
62823: LIST
62824: ST_TO_ADDR
// end ;
62825: LD_VAR 0 3
62829: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
62830: LD_INT 0
62832: PPUSH
62833: PPUSH
// list := AreaToList ( area , 0 ) ;
62834: LD_ADDR_VAR 0 4
62838: PUSH
62839: LD_VAR 0 1
62843: PPUSH
62844: LD_INT 0
62846: PPUSH
62847: CALL_OW 517
62851: ST_TO_ADDR
// if not list then
62852: LD_VAR 0 4
62856: NOT
62857: IFFALSE 62861
// exit ;
62859: GO 62902
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
62861: LD_ADDR_VAR 0 3
62865: PUSH
62866: LD_VAR 0 4
62870: PUSH
62871: LD_INT 1
62873: ARRAY
62874: PUSH
62875: LD_INT 1
62877: ARRAY
62878: PUSH
62879: LD_VAR 0 4
62883: PUSH
62884: LD_INT 2
62886: ARRAY
62887: PUSH
62888: LD_INT 1
62890: ARRAY
62891: PUSH
62892: LD_VAR 0 2
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: LIST
62901: ST_TO_ADDR
// end ;
62902: LD_VAR 0 3
62906: RET
// export function First ( array ) ; begin
62907: LD_INT 0
62909: PPUSH
// if not array then
62910: LD_VAR 0 1
62914: NOT
62915: IFFALSE 62919
// exit ;
62917: GO 62933
// result := array [ 1 ] ;
62919: LD_ADDR_VAR 0 2
62923: PUSH
62924: LD_VAR 0 1
62928: PUSH
62929: LD_INT 1
62931: ARRAY
62932: ST_TO_ADDR
// end ;
62933: LD_VAR 0 2
62937: RET
// export function Last ( array ) ; begin
62938: LD_INT 0
62940: PPUSH
// if not array then
62941: LD_VAR 0 1
62945: NOT
62946: IFFALSE 62950
// exit ;
62948: GO 62966
// result := array [ array ] ;
62950: LD_ADDR_VAR 0 2
62954: PUSH
62955: LD_VAR 0 1
62959: PUSH
62960: LD_VAR 0 1
62964: ARRAY
62965: ST_TO_ADDR
// end ;
62966: LD_VAR 0 2
62970: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
62971: LD_INT 0
62973: PPUSH
62974: PPUSH
// result := [ ] ;
62975: LD_ADDR_VAR 0 5
62979: PUSH
62980: EMPTY
62981: ST_TO_ADDR
// if not array then
62982: LD_VAR 0 1
62986: NOT
62987: IFFALSE 62991
// exit ;
62989: GO 63103
// for i := 1 to array do
62991: LD_ADDR_VAR 0 6
62995: PUSH
62996: DOUBLE
62997: LD_INT 1
62999: DEC
63000: ST_TO_ADDR
63001: LD_VAR 0 1
63005: PUSH
63006: FOR_TO
63007: IFFALSE 63101
// if array [ i ] [ index ] = value then
63009: LD_VAR 0 1
63013: PUSH
63014: LD_VAR 0 6
63018: ARRAY
63019: PUSH
63020: LD_VAR 0 2
63024: ARRAY
63025: PUSH
63026: LD_VAR 0 3
63030: EQUAL
63031: IFFALSE 63099
// begin if indexColumn then
63033: LD_VAR 0 4
63037: IFFALSE 63073
// result := Join ( result , array [ i ] [ indexColumn ] ) else
63039: LD_ADDR_VAR 0 5
63043: PUSH
63044: LD_VAR 0 5
63048: PPUSH
63049: LD_VAR 0 1
63053: PUSH
63054: LD_VAR 0 6
63058: ARRAY
63059: PUSH
63060: LD_VAR 0 4
63064: ARRAY
63065: PPUSH
63066: CALL 58111 0 2
63070: ST_TO_ADDR
63071: GO 63099
// result := Join ( result , array [ i ] ) ;
63073: LD_ADDR_VAR 0 5
63077: PUSH
63078: LD_VAR 0 5
63082: PPUSH
63083: LD_VAR 0 1
63087: PUSH
63088: LD_VAR 0 6
63092: ARRAY
63093: PPUSH
63094: CALL 58111 0 2
63098: ST_TO_ADDR
// end ;
63099: GO 63006
63101: POP
63102: POP
// end ;
63103: LD_VAR 0 5
63107: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
63108: LD_INT 0
63110: PPUSH
// if not vehicles or not parkingPoint then
63111: LD_VAR 0 1
63115: NOT
63116: IFTRUE 63125
63118: PUSH
63119: LD_VAR 0 2
63123: NOT
63124: OR
63125: IFFALSE 63129
// exit ;
63127: GO 63227
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
63129: LD_ADDR_VAR 0 1
63133: PUSH
63134: LD_VAR 0 1
63138: PPUSH
63139: LD_INT 50
63141: PUSH
63142: EMPTY
63143: LIST
63144: PUSH
63145: LD_INT 3
63147: PUSH
63148: LD_INT 92
63150: PUSH
63151: LD_VAR 0 2
63155: PUSH
63156: LD_INT 1
63158: ARRAY
63159: PUSH
63160: LD_VAR 0 2
63164: PUSH
63165: LD_INT 2
63167: ARRAY
63168: PUSH
63169: LD_INT 8
63171: PUSH
63172: EMPTY
63173: LIST
63174: LIST
63175: LIST
63176: LIST
63177: PUSH
63178: EMPTY
63179: LIST
63180: LIST
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: PPUSH
63186: CALL_OW 72
63190: ST_TO_ADDR
// if not vehicles then
63191: LD_VAR 0 1
63195: NOT
63196: IFFALSE 63200
// exit ;
63198: GO 63227
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
63200: LD_VAR 0 1
63204: PPUSH
63205: LD_VAR 0 2
63209: PUSH
63210: LD_INT 1
63212: ARRAY
63213: PPUSH
63214: LD_VAR 0 2
63218: PUSH
63219: LD_INT 2
63221: ARRAY
63222: PPUSH
63223: CALL_OW 111
// end ;
63227: LD_VAR 0 3
63231: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
63232: LD_INT 0
63234: PPUSH
63235: PPUSH
63236: PPUSH
// if not side or not area then
63237: LD_VAR 0 1
63241: NOT
63242: IFTRUE 63251
63244: PUSH
63245: LD_VAR 0 2
63249: NOT
63250: OR
63251: IFFALSE 63255
// exit ;
63253: GO 63374
// tmp := AreaToList ( area , 0 ) ;
63255: LD_ADDR_VAR 0 5
63259: PUSH
63260: LD_VAR 0 2
63264: PPUSH
63265: LD_INT 0
63267: PPUSH
63268: CALL_OW 517
63272: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
63273: LD_ADDR_VAR 0 4
63277: PUSH
63278: DOUBLE
63279: LD_INT 1
63281: DEC
63282: ST_TO_ADDR
63283: LD_VAR 0 5
63287: PUSH
63288: LD_INT 1
63290: ARRAY
63291: PUSH
63292: FOR_TO
63293: IFFALSE 63372
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
63295: LD_VAR 0 5
63299: PUSH
63300: LD_INT 1
63302: ARRAY
63303: PUSH
63304: LD_VAR 0 4
63308: ARRAY
63309: PPUSH
63310: LD_VAR 0 5
63314: PUSH
63315: LD_INT 2
63317: ARRAY
63318: PUSH
63319: LD_VAR 0 4
63323: ARRAY
63324: PPUSH
63325: CALL_OW 351
63329: IFFALSE 63370
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
63331: LD_VAR 0 5
63335: PUSH
63336: LD_INT 1
63338: ARRAY
63339: PUSH
63340: LD_VAR 0 4
63344: ARRAY
63345: PPUSH
63346: LD_VAR 0 5
63350: PUSH
63351: LD_INT 2
63353: ARRAY
63354: PUSH
63355: LD_VAR 0 4
63359: ARRAY
63360: PPUSH
63361: LD_VAR 0 1
63365: PPUSH
63366: CALL_OW 244
// end ;
63370: GO 63292
63372: POP
63373: POP
// end ;
63374: LD_VAR 0 3
63378: RET
// export function UniqueArray ( array ) ; var i ; begin
63379: LD_INT 0
63381: PPUSH
63382: PPUSH
// result := [ ] ;
63383: LD_ADDR_VAR 0 2
63387: PUSH
63388: EMPTY
63389: ST_TO_ADDR
// if not array then
63390: LD_VAR 0 1
63394: NOT
63395: IFFALSE 63399
// exit ;
63397: GO 63460
// for i := 1 to array do
63399: LD_ADDR_VAR 0 3
63403: PUSH
63404: DOUBLE
63405: LD_INT 1
63407: DEC
63408: ST_TO_ADDR
63409: LD_VAR 0 1
63413: PUSH
63414: FOR_TO
63415: IFFALSE 63458
// if not array [ i ] in result then
63417: LD_VAR 0 1
63421: PUSH
63422: LD_VAR 0 3
63426: ARRAY
63427: PUSH
63428: LD_VAR 0 2
63432: IN
63433: NOT
63434: IFFALSE 63456
// result := Join ( result , i ) ;
63436: LD_ADDR_VAR 0 2
63440: PUSH
63441: LD_VAR 0 2
63445: PPUSH
63446: LD_VAR 0 3
63450: PPUSH
63451: CALL 58111 0 2
63455: ST_TO_ADDR
63456: GO 63414
63458: POP
63459: POP
// end ; end_of_file
63460: LD_VAR 0 2
63464: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
63465: LD_INT 0
63467: PPUSH
63468: PPUSH
// skirmish := false ;
63469: LD_ADDR_EXP 29
63473: PUSH
63474: LD_INT 0
63476: ST_TO_ADDR
// debug_mc := false ;
63477: LD_ADDR_EXP 30
63481: PUSH
63482: LD_INT 0
63484: ST_TO_ADDR
// mc_bases := [ ] ;
63485: LD_ADDR_EXP 31
63489: PUSH
63490: EMPTY
63491: ST_TO_ADDR
// mc_sides := [ ] ;
63492: LD_ADDR_EXP 57
63496: PUSH
63497: EMPTY
63498: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
63499: LD_ADDR_EXP 32
63503: PUSH
63504: EMPTY
63505: ST_TO_ADDR
// mc_building_repairs := [ ] ;
63506: LD_ADDR_EXP 33
63510: PUSH
63511: EMPTY
63512: ST_TO_ADDR
// mc_need_heal := [ ] ;
63513: LD_ADDR_EXP 34
63517: PUSH
63518: EMPTY
63519: ST_TO_ADDR
// mc_healers := [ ] ;
63520: LD_ADDR_EXP 35
63524: PUSH
63525: EMPTY
63526: ST_TO_ADDR
// mc_build_list := [ ] ;
63527: LD_ADDR_EXP 36
63531: PUSH
63532: EMPTY
63533: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
63534: LD_ADDR_EXP 63
63538: PUSH
63539: EMPTY
63540: ST_TO_ADDR
// mc_builders := [ ] ;
63541: LD_ADDR_EXP 37
63545: PUSH
63546: EMPTY
63547: ST_TO_ADDR
// mc_construct_list := [ ] ;
63548: LD_ADDR_EXP 38
63552: PUSH
63553: EMPTY
63554: ST_TO_ADDR
// mc_turret_list := [ ] ;
63555: LD_ADDR_EXP 39
63559: PUSH
63560: EMPTY
63561: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
63562: LD_ADDR_EXP 40
63566: PUSH
63567: EMPTY
63568: ST_TO_ADDR
// mc_miners := [ ] ;
63569: LD_ADDR_EXP 45
63573: PUSH
63574: EMPTY
63575: ST_TO_ADDR
// mc_mines := [ ] ;
63576: LD_ADDR_EXP 44
63580: PUSH
63581: EMPTY
63582: ST_TO_ADDR
// mc_minefields := [ ] ;
63583: LD_ADDR_EXP 46
63587: PUSH
63588: EMPTY
63589: ST_TO_ADDR
// mc_crates := [ ] ;
63590: LD_ADDR_EXP 47
63594: PUSH
63595: EMPTY
63596: ST_TO_ADDR
// mc_crates_collector := [ ] ;
63597: LD_ADDR_EXP 48
63601: PUSH
63602: EMPTY
63603: ST_TO_ADDR
// mc_crates_area := [ ] ;
63604: LD_ADDR_EXP 49
63608: PUSH
63609: EMPTY
63610: ST_TO_ADDR
// mc_vehicles := [ ] ;
63611: LD_ADDR_EXP 50
63615: PUSH
63616: EMPTY
63617: ST_TO_ADDR
// mc_attack := [ ] ;
63618: LD_ADDR_EXP 51
63622: PUSH
63623: EMPTY
63624: ST_TO_ADDR
// mc_produce := [ ] ;
63625: LD_ADDR_EXP 52
63629: PUSH
63630: EMPTY
63631: ST_TO_ADDR
// mc_defender := [ ] ;
63632: LD_ADDR_EXP 53
63636: PUSH
63637: EMPTY
63638: ST_TO_ADDR
// mc_parking := [ ] ;
63639: LD_ADDR_EXP 55
63643: PUSH
63644: EMPTY
63645: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
63646: LD_ADDR_EXP 41
63650: PUSH
63651: EMPTY
63652: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
63653: LD_ADDR_EXP 43
63657: PUSH
63658: EMPTY
63659: ST_TO_ADDR
// mc_scan := [ ] ;
63660: LD_ADDR_EXP 54
63664: PUSH
63665: EMPTY
63666: ST_TO_ADDR
// mc_scan_area := [ ] ;
63667: LD_ADDR_EXP 56
63671: PUSH
63672: EMPTY
63673: ST_TO_ADDR
// mc_tech := [ ] ;
63674: LD_ADDR_EXP 58
63678: PUSH
63679: EMPTY
63680: ST_TO_ADDR
// mc_class := [ ] ;
63681: LD_ADDR_EXP 72
63685: PUSH
63686: EMPTY
63687: ST_TO_ADDR
// mc_class_case_use := [ ] ;
63688: LD_ADDR_EXP 73
63692: PUSH
63693: EMPTY
63694: ST_TO_ADDR
// mc_is_defending := [ ] ;
63695: LD_ADDR_EXP 74
63699: PUSH
63700: EMPTY
63701: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
63702: LD_ADDR_EXP 65
63706: PUSH
63707: EMPTY
63708: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
63709: LD_ADDR_EXP 75
63713: PUSH
63714: LD_INT 0
63716: ST_TO_ADDR
// end ;
63717: LD_VAR 0 1
63721: RET
// export function MC_Kill ( base ) ; begin
63722: LD_INT 0
63724: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
63725: LD_ADDR_EXP 31
63729: PUSH
63730: LD_EXP 31
63734: PPUSH
63735: LD_VAR 0 1
63739: PPUSH
63740: EMPTY
63741: PPUSH
63742: CALL_OW 1
63746: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
63747: LD_ADDR_EXP 32
63751: PUSH
63752: LD_EXP 32
63756: PPUSH
63757: LD_VAR 0 1
63761: PPUSH
63762: EMPTY
63763: PPUSH
63764: CALL_OW 1
63768: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
63769: LD_ADDR_EXP 33
63773: PUSH
63774: LD_EXP 33
63778: PPUSH
63779: LD_VAR 0 1
63783: PPUSH
63784: EMPTY
63785: PPUSH
63786: CALL_OW 1
63790: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
63791: LD_ADDR_EXP 34
63795: PUSH
63796: LD_EXP 34
63800: PPUSH
63801: LD_VAR 0 1
63805: PPUSH
63806: EMPTY
63807: PPUSH
63808: CALL_OW 1
63812: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
63813: LD_ADDR_EXP 35
63817: PUSH
63818: LD_EXP 35
63822: PPUSH
63823: LD_VAR 0 1
63827: PPUSH
63828: EMPTY
63829: PPUSH
63830: CALL_OW 1
63834: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
63835: LD_ADDR_EXP 36
63839: PUSH
63840: LD_EXP 36
63844: PPUSH
63845: LD_VAR 0 1
63849: PPUSH
63850: EMPTY
63851: PPUSH
63852: CALL_OW 1
63856: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
63857: LD_ADDR_EXP 37
63861: PUSH
63862: LD_EXP 37
63866: PPUSH
63867: LD_VAR 0 1
63871: PPUSH
63872: EMPTY
63873: PPUSH
63874: CALL_OW 1
63878: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
63879: LD_ADDR_EXP 38
63883: PUSH
63884: LD_EXP 38
63888: PPUSH
63889: LD_VAR 0 1
63893: PPUSH
63894: EMPTY
63895: PPUSH
63896: CALL_OW 1
63900: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
63901: LD_ADDR_EXP 39
63905: PUSH
63906: LD_EXP 39
63910: PPUSH
63911: LD_VAR 0 1
63915: PPUSH
63916: EMPTY
63917: PPUSH
63918: CALL_OW 1
63922: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
63923: LD_ADDR_EXP 40
63927: PUSH
63928: LD_EXP 40
63932: PPUSH
63933: LD_VAR 0 1
63937: PPUSH
63938: EMPTY
63939: PPUSH
63940: CALL_OW 1
63944: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
63945: LD_ADDR_EXP 41
63949: PUSH
63950: LD_EXP 41
63954: PPUSH
63955: LD_VAR 0 1
63959: PPUSH
63960: EMPTY
63961: PPUSH
63962: CALL_OW 1
63966: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
63967: LD_ADDR_EXP 42
63971: PUSH
63972: LD_EXP 42
63976: PPUSH
63977: LD_VAR 0 1
63981: PPUSH
63982: LD_INT 0
63984: PPUSH
63985: CALL_OW 1
63989: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
63990: LD_ADDR_EXP 43
63994: PUSH
63995: LD_EXP 43
63999: PPUSH
64000: LD_VAR 0 1
64004: PPUSH
64005: EMPTY
64006: PPUSH
64007: CALL_OW 1
64011: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
64012: LD_ADDR_EXP 44
64016: PUSH
64017: LD_EXP 44
64021: PPUSH
64022: LD_VAR 0 1
64026: PPUSH
64027: EMPTY
64028: PPUSH
64029: CALL_OW 1
64033: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
64034: LD_ADDR_EXP 45
64038: PUSH
64039: LD_EXP 45
64043: PPUSH
64044: LD_VAR 0 1
64048: PPUSH
64049: EMPTY
64050: PPUSH
64051: CALL_OW 1
64055: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
64056: LD_ADDR_EXP 46
64060: PUSH
64061: LD_EXP 46
64065: PPUSH
64066: LD_VAR 0 1
64070: PPUSH
64071: EMPTY
64072: PPUSH
64073: CALL_OW 1
64077: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
64078: LD_ADDR_EXP 47
64082: PUSH
64083: LD_EXP 47
64087: PPUSH
64088: LD_VAR 0 1
64092: PPUSH
64093: EMPTY
64094: PPUSH
64095: CALL_OW 1
64099: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
64100: LD_ADDR_EXP 48
64104: PUSH
64105: LD_EXP 48
64109: PPUSH
64110: LD_VAR 0 1
64114: PPUSH
64115: EMPTY
64116: PPUSH
64117: CALL_OW 1
64121: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
64122: LD_ADDR_EXP 49
64126: PUSH
64127: LD_EXP 49
64131: PPUSH
64132: LD_VAR 0 1
64136: PPUSH
64137: EMPTY
64138: PPUSH
64139: CALL_OW 1
64143: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
64144: LD_ADDR_EXP 50
64148: PUSH
64149: LD_EXP 50
64153: PPUSH
64154: LD_VAR 0 1
64158: PPUSH
64159: EMPTY
64160: PPUSH
64161: CALL_OW 1
64165: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
64166: LD_ADDR_EXP 51
64170: PUSH
64171: LD_EXP 51
64175: PPUSH
64176: LD_VAR 0 1
64180: PPUSH
64181: EMPTY
64182: PPUSH
64183: CALL_OW 1
64187: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
64188: LD_ADDR_EXP 52
64192: PUSH
64193: LD_EXP 52
64197: PPUSH
64198: LD_VAR 0 1
64202: PPUSH
64203: EMPTY
64204: PPUSH
64205: CALL_OW 1
64209: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
64210: LD_ADDR_EXP 53
64214: PUSH
64215: LD_EXP 53
64219: PPUSH
64220: LD_VAR 0 1
64224: PPUSH
64225: EMPTY
64226: PPUSH
64227: CALL_OW 1
64231: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
64232: LD_ADDR_EXP 54
64236: PUSH
64237: LD_EXP 54
64241: PPUSH
64242: LD_VAR 0 1
64246: PPUSH
64247: EMPTY
64248: PPUSH
64249: CALL_OW 1
64253: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
64254: LD_ADDR_EXP 55
64258: PUSH
64259: LD_EXP 55
64263: PPUSH
64264: LD_VAR 0 1
64268: PPUSH
64269: EMPTY
64270: PPUSH
64271: CALL_OW 1
64275: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
64276: LD_ADDR_EXP 56
64280: PUSH
64281: LD_EXP 56
64285: PPUSH
64286: LD_VAR 0 1
64290: PPUSH
64291: EMPTY
64292: PPUSH
64293: CALL_OW 1
64297: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
64298: LD_ADDR_EXP 58
64302: PUSH
64303: LD_EXP 58
64307: PPUSH
64308: LD_VAR 0 1
64312: PPUSH
64313: EMPTY
64314: PPUSH
64315: CALL_OW 1
64319: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
64320: LD_ADDR_EXP 60
64324: PUSH
64325: LD_EXP 60
64329: PPUSH
64330: LD_VAR 0 1
64334: PPUSH
64335: EMPTY
64336: PPUSH
64337: CALL_OW 1
64341: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
64342: LD_ADDR_EXP 61
64346: PUSH
64347: LD_EXP 61
64351: PPUSH
64352: LD_VAR 0 1
64356: PPUSH
64357: EMPTY
64358: PPUSH
64359: CALL_OW 1
64363: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
64364: LD_ADDR_EXP 62
64368: PUSH
64369: LD_EXP 62
64373: PPUSH
64374: LD_VAR 0 1
64378: PPUSH
64379: EMPTY
64380: PPUSH
64381: CALL_OW 1
64385: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
64386: LD_ADDR_EXP 63
64390: PUSH
64391: LD_EXP 63
64395: PPUSH
64396: LD_VAR 0 1
64400: PPUSH
64401: EMPTY
64402: PPUSH
64403: CALL_OW 1
64407: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
64408: LD_ADDR_EXP 64
64412: PUSH
64413: LD_EXP 64
64417: PPUSH
64418: LD_VAR 0 1
64422: PPUSH
64423: EMPTY
64424: PPUSH
64425: CALL_OW 1
64429: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
64430: LD_ADDR_EXP 65
64434: PUSH
64435: LD_EXP 65
64439: PPUSH
64440: LD_VAR 0 1
64444: PPUSH
64445: EMPTY
64446: PPUSH
64447: CALL_OW 1
64451: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
64452: LD_ADDR_EXP 66
64456: PUSH
64457: LD_EXP 66
64461: PPUSH
64462: LD_VAR 0 1
64466: PPUSH
64467: EMPTY
64468: PPUSH
64469: CALL_OW 1
64473: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
64474: LD_ADDR_EXP 67
64478: PUSH
64479: LD_EXP 67
64483: PPUSH
64484: LD_VAR 0 1
64488: PPUSH
64489: EMPTY
64490: PPUSH
64491: CALL_OW 1
64495: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
64496: LD_ADDR_EXP 68
64500: PUSH
64501: LD_EXP 68
64505: PPUSH
64506: LD_VAR 0 1
64510: PPUSH
64511: EMPTY
64512: PPUSH
64513: CALL_OW 1
64517: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
64518: LD_ADDR_EXP 69
64522: PUSH
64523: LD_EXP 69
64527: PPUSH
64528: LD_VAR 0 1
64532: PPUSH
64533: EMPTY
64534: PPUSH
64535: CALL_OW 1
64539: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
64540: LD_ADDR_EXP 70
64544: PUSH
64545: LD_EXP 70
64549: PPUSH
64550: LD_VAR 0 1
64554: PPUSH
64555: EMPTY
64556: PPUSH
64557: CALL_OW 1
64561: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
64562: LD_ADDR_EXP 71
64566: PUSH
64567: LD_EXP 71
64571: PPUSH
64572: LD_VAR 0 1
64576: PPUSH
64577: EMPTY
64578: PPUSH
64579: CALL_OW 1
64583: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
64584: LD_ADDR_EXP 72
64588: PUSH
64589: LD_EXP 72
64593: PPUSH
64594: LD_VAR 0 1
64598: PPUSH
64599: EMPTY
64600: PPUSH
64601: CALL_OW 1
64605: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
64606: LD_ADDR_EXP 73
64610: PUSH
64611: LD_EXP 73
64615: PPUSH
64616: LD_VAR 0 1
64620: PPUSH
64621: LD_INT 0
64623: PPUSH
64624: CALL_OW 1
64628: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
64629: LD_ADDR_EXP 74
64633: PUSH
64634: LD_EXP 74
64638: PPUSH
64639: LD_VAR 0 1
64643: PPUSH
64644: LD_INT 0
64646: PPUSH
64647: CALL_OW 1
64651: ST_TO_ADDR
// end ;
64652: LD_VAR 0 2
64656: RET
// export function MC_Add ( side , units ) ; var base ; begin
64657: LD_INT 0
64659: PPUSH
64660: PPUSH
// base := mc_bases + 1 ;
64661: LD_ADDR_VAR 0 4
64665: PUSH
64666: LD_EXP 31
64670: PUSH
64671: LD_INT 1
64673: PLUS
64674: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
64675: LD_ADDR_EXP 57
64679: PUSH
64680: LD_EXP 57
64684: PPUSH
64685: LD_VAR 0 4
64689: PPUSH
64690: LD_VAR 0 1
64694: PPUSH
64695: CALL_OW 1
64699: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
64700: LD_ADDR_EXP 31
64704: PUSH
64705: LD_EXP 31
64709: PPUSH
64710: LD_VAR 0 4
64714: PPUSH
64715: LD_VAR 0 2
64719: PPUSH
64720: CALL_OW 1
64724: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
64725: LD_ADDR_EXP 32
64729: PUSH
64730: LD_EXP 32
64734: PPUSH
64735: LD_VAR 0 4
64739: PPUSH
64740: EMPTY
64741: PPUSH
64742: CALL_OW 1
64746: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
64747: LD_ADDR_EXP 33
64751: PUSH
64752: LD_EXP 33
64756: PPUSH
64757: LD_VAR 0 4
64761: PPUSH
64762: EMPTY
64763: PPUSH
64764: CALL_OW 1
64768: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
64769: LD_ADDR_EXP 34
64773: PUSH
64774: LD_EXP 34
64778: PPUSH
64779: LD_VAR 0 4
64783: PPUSH
64784: EMPTY
64785: PPUSH
64786: CALL_OW 1
64790: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
64791: LD_ADDR_EXP 35
64795: PUSH
64796: LD_EXP 35
64800: PPUSH
64801: LD_VAR 0 4
64805: PPUSH
64806: EMPTY
64807: PPUSH
64808: CALL_OW 1
64812: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
64813: LD_ADDR_EXP 36
64817: PUSH
64818: LD_EXP 36
64822: PPUSH
64823: LD_VAR 0 4
64827: PPUSH
64828: EMPTY
64829: PPUSH
64830: CALL_OW 1
64834: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
64835: LD_ADDR_EXP 37
64839: PUSH
64840: LD_EXP 37
64844: PPUSH
64845: LD_VAR 0 4
64849: PPUSH
64850: EMPTY
64851: PPUSH
64852: CALL_OW 1
64856: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
64857: LD_ADDR_EXP 38
64861: PUSH
64862: LD_EXP 38
64866: PPUSH
64867: LD_VAR 0 4
64871: PPUSH
64872: EMPTY
64873: PPUSH
64874: CALL_OW 1
64878: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
64879: LD_ADDR_EXP 39
64883: PUSH
64884: LD_EXP 39
64888: PPUSH
64889: LD_VAR 0 4
64893: PPUSH
64894: EMPTY
64895: PPUSH
64896: CALL_OW 1
64900: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
64901: LD_ADDR_EXP 40
64905: PUSH
64906: LD_EXP 40
64910: PPUSH
64911: LD_VAR 0 4
64915: PPUSH
64916: EMPTY
64917: PPUSH
64918: CALL_OW 1
64922: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
64923: LD_ADDR_EXP 41
64927: PUSH
64928: LD_EXP 41
64932: PPUSH
64933: LD_VAR 0 4
64937: PPUSH
64938: EMPTY
64939: PPUSH
64940: CALL_OW 1
64944: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
64945: LD_ADDR_EXP 42
64949: PUSH
64950: LD_EXP 42
64954: PPUSH
64955: LD_VAR 0 4
64959: PPUSH
64960: LD_INT 0
64962: PPUSH
64963: CALL_OW 1
64967: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
64968: LD_ADDR_EXP 43
64972: PUSH
64973: LD_EXP 43
64977: PPUSH
64978: LD_VAR 0 4
64982: PPUSH
64983: EMPTY
64984: PPUSH
64985: CALL_OW 1
64989: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
64990: LD_ADDR_EXP 44
64994: PUSH
64995: LD_EXP 44
64999: PPUSH
65000: LD_VAR 0 4
65004: PPUSH
65005: EMPTY
65006: PPUSH
65007: CALL_OW 1
65011: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
65012: LD_ADDR_EXP 45
65016: PUSH
65017: LD_EXP 45
65021: PPUSH
65022: LD_VAR 0 4
65026: PPUSH
65027: EMPTY
65028: PPUSH
65029: CALL_OW 1
65033: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
65034: LD_ADDR_EXP 46
65038: PUSH
65039: LD_EXP 46
65043: PPUSH
65044: LD_VAR 0 4
65048: PPUSH
65049: EMPTY
65050: PPUSH
65051: CALL_OW 1
65055: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
65056: LD_ADDR_EXP 47
65060: PUSH
65061: LD_EXP 47
65065: PPUSH
65066: LD_VAR 0 4
65070: PPUSH
65071: EMPTY
65072: PPUSH
65073: CALL_OW 1
65077: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
65078: LD_ADDR_EXP 48
65082: PUSH
65083: LD_EXP 48
65087: PPUSH
65088: LD_VAR 0 4
65092: PPUSH
65093: EMPTY
65094: PPUSH
65095: CALL_OW 1
65099: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
65100: LD_ADDR_EXP 49
65104: PUSH
65105: LD_EXP 49
65109: PPUSH
65110: LD_VAR 0 4
65114: PPUSH
65115: EMPTY
65116: PPUSH
65117: CALL_OW 1
65121: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
65122: LD_ADDR_EXP 50
65126: PUSH
65127: LD_EXP 50
65131: PPUSH
65132: LD_VAR 0 4
65136: PPUSH
65137: EMPTY
65138: PPUSH
65139: CALL_OW 1
65143: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
65144: LD_ADDR_EXP 51
65148: PUSH
65149: LD_EXP 51
65153: PPUSH
65154: LD_VAR 0 4
65158: PPUSH
65159: EMPTY
65160: PPUSH
65161: CALL_OW 1
65165: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
65166: LD_ADDR_EXP 52
65170: PUSH
65171: LD_EXP 52
65175: PPUSH
65176: LD_VAR 0 4
65180: PPUSH
65181: EMPTY
65182: PPUSH
65183: CALL_OW 1
65187: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
65188: LD_ADDR_EXP 53
65192: PUSH
65193: LD_EXP 53
65197: PPUSH
65198: LD_VAR 0 4
65202: PPUSH
65203: EMPTY
65204: PPUSH
65205: CALL_OW 1
65209: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
65210: LD_ADDR_EXP 54
65214: PUSH
65215: LD_EXP 54
65219: PPUSH
65220: LD_VAR 0 4
65224: PPUSH
65225: EMPTY
65226: PPUSH
65227: CALL_OW 1
65231: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
65232: LD_ADDR_EXP 55
65236: PUSH
65237: LD_EXP 55
65241: PPUSH
65242: LD_VAR 0 4
65246: PPUSH
65247: EMPTY
65248: PPUSH
65249: CALL_OW 1
65253: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
65254: LD_ADDR_EXP 56
65258: PUSH
65259: LD_EXP 56
65263: PPUSH
65264: LD_VAR 0 4
65268: PPUSH
65269: EMPTY
65270: PPUSH
65271: CALL_OW 1
65275: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
65276: LD_ADDR_EXP 58
65280: PUSH
65281: LD_EXP 58
65285: PPUSH
65286: LD_VAR 0 4
65290: PPUSH
65291: EMPTY
65292: PPUSH
65293: CALL_OW 1
65297: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
65298: LD_ADDR_EXP 60
65302: PUSH
65303: LD_EXP 60
65307: PPUSH
65308: LD_VAR 0 4
65312: PPUSH
65313: EMPTY
65314: PPUSH
65315: CALL_OW 1
65319: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
65320: LD_ADDR_EXP 61
65324: PUSH
65325: LD_EXP 61
65329: PPUSH
65330: LD_VAR 0 4
65334: PPUSH
65335: EMPTY
65336: PPUSH
65337: CALL_OW 1
65341: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
65342: LD_ADDR_EXP 62
65346: PUSH
65347: LD_EXP 62
65351: PPUSH
65352: LD_VAR 0 4
65356: PPUSH
65357: EMPTY
65358: PPUSH
65359: CALL_OW 1
65363: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
65364: LD_ADDR_EXP 63
65368: PUSH
65369: LD_EXP 63
65373: PPUSH
65374: LD_VAR 0 4
65378: PPUSH
65379: EMPTY
65380: PPUSH
65381: CALL_OW 1
65385: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
65386: LD_ADDR_EXP 64
65390: PUSH
65391: LD_EXP 64
65395: PPUSH
65396: LD_VAR 0 4
65400: PPUSH
65401: EMPTY
65402: PPUSH
65403: CALL_OW 1
65407: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
65408: LD_ADDR_EXP 65
65412: PUSH
65413: LD_EXP 65
65417: PPUSH
65418: LD_VAR 0 4
65422: PPUSH
65423: EMPTY
65424: PPUSH
65425: CALL_OW 1
65429: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
65430: LD_ADDR_EXP 66
65434: PUSH
65435: LD_EXP 66
65439: PPUSH
65440: LD_VAR 0 4
65444: PPUSH
65445: EMPTY
65446: PPUSH
65447: CALL_OW 1
65451: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
65452: LD_ADDR_EXP 67
65456: PUSH
65457: LD_EXP 67
65461: PPUSH
65462: LD_VAR 0 4
65466: PPUSH
65467: EMPTY
65468: PPUSH
65469: CALL_OW 1
65473: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
65474: LD_ADDR_EXP 68
65478: PUSH
65479: LD_EXP 68
65483: PPUSH
65484: LD_VAR 0 4
65488: PPUSH
65489: EMPTY
65490: PPUSH
65491: CALL_OW 1
65495: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
65496: LD_ADDR_EXP 69
65500: PUSH
65501: LD_EXP 69
65505: PPUSH
65506: LD_VAR 0 4
65510: PPUSH
65511: EMPTY
65512: PPUSH
65513: CALL_OW 1
65517: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
65518: LD_ADDR_EXP 70
65522: PUSH
65523: LD_EXP 70
65527: PPUSH
65528: LD_VAR 0 4
65532: PPUSH
65533: EMPTY
65534: PPUSH
65535: CALL_OW 1
65539: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
65540: LD_ADDR_EXP 71
65544: PUSH
65545: LD_EXP 71
65549: PPUSH
65550: LD_VAR 0 4
65554: PPUSH
65555: EMPTY
65556: PPUSH
65557: CALL_OW 1
65561: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
65562: LD_ADDR_EXP 72
65566: PUSH
65567: LD_EXP 72
65571: PPUSH
65572: LD_VAR 0 4
65576: PPUSH
65577: EMPTY
65578: PPUSH
65579: CALL_OW 1
65583: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
65584: LD_ADDR_EXP 73
65588: PUSH
65589: LD_EXP 73
65593: PPUSH
65594: LD_VAR 0 4
65598: PPUSH
65599: LD_INT 0
65601: PPUSH
65602: CALL_OW 1
65606: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
65607: LD_ADDR_EXP 74
65611: PUSH
65612: LD_EXP 74
65616: PPUSH
65617: LD_VAR 0 4
65621: PPUSH
65622: LD_INT 0
65624: PPUSH
65625: CALL_OW 1
65629: ST_TO_ADDR
// result := base ;
65630: LD_ADDR_VAR 0 3
65634: PUSH
65635: LD_VAR 0 4
65639: ST_TO_ADDR
// end ;
65640: LD_VAR 0 3
65644: RET
// export function MC_Start ( ) ; var i ; begin
65645: LD_INT 0
65647: PPUSH
65648: PPUSH
// for i = 1 to mc_bases do
65649: LD_ADDR_VAR 0 2
65653: PUSH
65654: DOUBLE
65655: LD_INT 1
65657: DEC
65658: ST_TO_ADDR
65659: LD_EXP 31
65663: PUSH
65664: FOR_TO
65665: IFFALSE 66765
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
65667: LD_ADDR_EXP 31
65671: PUSH
65672: LD_EXP 31
65676: PPUSH
65677: LD_VAR 0 2
65681: PPUSH
65682: LD_EXP 31
65686: PUSH
65687: LD_VAR 0 2
65691: ARRAY
65692: PUSH
65693: LD_INT 0
65695: DIFF
65696: PPUSH
65697: CALL_OW 1
65701: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
65702: LD_ADDR_EXP 32
65706: PUSH
65707: LD_EXP 32
65711: PPUSH
65712: LD_VAR 0 2
65716: PPUSH
65717: EMPTY
65718: PPUSH
65719: CALL_OW 1
65723: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65724: LD_ADDR_EXP 33
65728: PUSH
65729: LD_EXP 33
65733: PPUSH
65734: LD_VAR 0 2
65738: PPUSH
65739: EMPTY
65740: PPUSH
65741: CALL_OW 1
65745: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
65746: LD_ADDR_EXP 34
65750: PUSH
65751: LD_EXP 34
65755: PPUSH
65756: LD_VAR 0 2
65760: PPUSH
65761: EMPTY
65762: PPUSH
65763: CALL_OW 1
65767: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
65768: LD_ADDR_EXP 35
65772: PUSH
65773: LD_EXP 35
65777: PPUSH
65778: LD_VAR 0 2
65782: PPUSH
65783: EMPTY
65784: PUSH
65785: EMPTY
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PPUSH
65791: CALL_OW 1
65795: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
65796: LD_ADDR_EXP 36
65800: PUSH
65801: LD_EXP 36
65805: PPUSH
65806: LD_VAR 0 2
65810: PPUSH
65811: EMPTY
65812: PPUSH
65813: CALL_OW 1
65817: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
65818: LD_ADDR_EXP 63
65822: PUSH
65823: LD_EXP 63
65827: PPUSH
65828: LD_VAR 0 2
65832: PPUSH
65833: EMPTY
65834: PPUSH
65835: CALL_OW 1
65839: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
65840: LD_ADDR_EXP 37
65844: PUSH
65845: LD_EXP 37
65849: PPUSH
65850: LD_VAR 0 2
65854: PPUSH
65855: EMPTY
65856: PPUSH
65857: CALL_OW 1
65861: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
65862: LD_ADDR_EXP 38
65866: PUSH
65867: LD_EXP 38
65871: PPUSH
65872: LD_VAR 0 2
65876: PPUSH
65877: EMPTY
65878: PPUSH
65879: CALL_OW 1
65883: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
65884: LD_ADDR_EXP 39
65888: PUSH
65889: LD_EXP 39
65893: PPUSH
65894: LD_VAR 0 2
65898: PPUSH
65899: LD_EXP 31
65903: PUSH
65904: LD_VAR 0 2
65908: ARRAY
65909: PPUSH
65910: LD_INT 2
65912: PUSH
65913: LD_INT 30
65915: PUSH
65916: LD_INT 32
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: LD_INT 30
65925: PUSH
65926: LD_INT 33
65928: PUSH
65929: EMPTY
65930: LIST
65931: LIST
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: LIST
65937: PPUSH
65938: CALL_OW 72
65942: PPUSH
65943: CALL_OW 1
65947: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
65948: LD_ADDR_EXP 40
65952: PUSH
65953: LD_EXP 40
65957: PPUSH
65958: LD_VAR 0 2
65962: PPUSH
65963: LD_EXP 31
65967: PUSH
65968: LD_VAR 0 2
65972: ARRAY
65973: PPUSH
65974: LD_INT 2
65976: PUSH
65977: LD_INT 30
65979: PUSH
65980: LD_INT 32
65982: PUSH
65983: EMPTY
65984: LIST
65985: LIST
65986: PUSH
65987: LD_INT 30
65989: PUSH
65990: LD_INT 31
65992: PUSH
65993: EMPTY
65994: LIST
65995: LIST
65996: PUSH
65997: EMPTY
65998: LIST
65999: LIST
66000: LIST
66001: PUSH
66002: LD_INT 58
66004: PUSH
66005: EMPTY
66006: LIST
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: PPUSH
66012: CALL_OW 72
66016: PPUSH
66017: CALL_OW 1
66021: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
66022: LD_ADDR_EXP 41
66026: PUSH
66027: LD_EXP 41
66031: PPUSH
66032: LD_VAR 0 2
66036: PPUSH
66037: EMPTY
66038: PPUSH
66039: CALL_OW 1
66043: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
66044: LD_ADDR_EXP 45
66048: PUSH
66049: LD_EXP 45
66053: PPUSH
66054: LD_VAR 0 2
66058: PPUSH
66059: EMPTY
66060: PPUSH
66061: CALL_OW 1
66065: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
66066: LD_ADDR_EXP 44
66070: PUSH
66071: LD_EXP 44
66075: PPUSH
66076: LD_VAR 0 2
66080: PPUSH
66081: EMPTY
66082: PPUSH
66083: CALL_OW 1
66087: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
66088: LD_ADDR_EXP 46
66092: PUSH
66093: LD_EXP 46
66097: PPUSH
66098: LD_VAR 0 2
66102: PPUSH
66103: EMPTY
66104: PPUSH
66105: CALL_OW 1
66109: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
66110: LD_ADDR_EXP 47
66114: PUSH
66115: LD_EXP 47
66119: PPUSH
66120: LD_VAR 0 2
66124: PPUSH
66125: EMPTY
66126: PPUSH
66127: CALL_OW 1
66131: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
66132: LD_ADDR_EXP 48
66136: PUSH
66137: LD_EXP 48
66141: PPUSH
66142: LD_VAR 0 2
66146: PPUSH
66147: EMPTY
66148: PPUSH
66149: CALL_OW 1
66153: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
66154: LD_ADDR_EXP 49
66158: PUSH
66159: LD_EXP 49
66163: PPUSH
66164: LD_VAR 0 2
66168: PPUSH
66169: EMPTY
66170: PPUSH
66171: CALL_OW 1
66175: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
66176: LD_ADDR_EXP 50
66180: PUSH
66181: LD_EXP 50
66185: PPUSH
66186: LD_VAR 0 2
66190: PPUSH
66191: EMPTY
66192: PPUSH
66193: CALL_OW 1
66197: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66198: LD_ADDR_EXP 51
66202: PUSH
66203: LD_EXP 51
66207: PPUSH
66208: LD_VAR 0 2
66212: PPUSH
66213: EMPTY
66214: PPUSH
66215: CALL_OW 1
66219: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
66220: LD_ADDR_EXP 52
66224: PUSH
66225: LD_EXP 52
66229: PPUSH
66230: LD_VAR 0 2
66234: PPUSH
66235: EMPTY
66236: PPUSH
66237: CALL_OW 1
66241: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
66242: LD_ADDR_EXP 53
66246: PUSH
66247: LD_EXP 53
66251: PPUSH
66252: LD_VAR 0 2
66256: PPUSH
66257: EMPTY
66258: PPUSH
66259: CALL_OW 1
66263: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
66264: LD_ADDR_EXP 42
66268: PUSH
66269: LD_EXP 42
66273: PPUSH
66274: LD_VAR 0 2
66278: PPUSH
66279: LD_INT 0
66281: PPUSH
66282: CALL_OW 1
66286: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
66287: LD_ADDR_EXP 55
66291: PUSH
66292: LD_EXP 55
66296: PPUSH
66297: LD_VAR 0 2
66301: PPUSH
66302: LD_INT 0
66304: PPUSH
66305: CALL_OW 1
66309: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
66310: LD_ADDR_EXP 43
66314: PUSH
66315: LD_EXP 43
66319: PPUSH
66320: LD_VAR 0 2
66324: PPUSH
66325: EMPTY
66326: PPUSH
66327: CALL_OW 1
66331: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
66332: LD_ADDR_EXP 54
66336: PUSH
66337: LD_EXP 54
66341: PPUSH
66342: LD_VAR 0 2
66346: PPUSH
66347: LD_INT 0
66349: PPUSH
66350: CALL_OW 1
66354: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
66355: LD_ADDR_EXP 56
66359: PUSH
66360: LD_EXP 56
66364: PPUSH
66365: LD_VAR 0 2
66369: PPUSH
66370: EMPTY
66371: PPUSH
66372: CALL_OW 1
66376: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
66377: LD_ADDR_EXP 59
66381: PUSH
66382: LD_EXP 59
66386: PPUSH
66387: LD_VAR 0 2
66391: PPUSH
66392: LD_INT 0
66394: PPUSH
66395: CALL_OW 1
66399: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
66400: LD_ADDR_EXP 60
66404: PUSH
66405: LD_EXP 60
66409: PPUSH
66410: LD_VAR 0 2
66414: PPUSH
66415: EMPTY
66416: PPUSH
66417: CALL_OW 1
66421: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66422: LD_ADDR_EXP 61
66426: PUSH
66427: LD_EXP 61
66431: PPUSH
66432: LD_VAR 0 2
66436: PPUSH
66437: EMPTY
66438: PPUSH
66439: CALL_OW 1
66443: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66444: LD_ADDR_EXP 62
66448: PUSH
66449: LD_EXP 62
66453: PPUSH
66454: LD_VAR 0 2
66458: PPUSH
66459: EMPTY
66460: PPUSH
66461: CALL_OW 1
66465: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
66466: LD_ADDR_EXP 64
66470: PUSH
66471: LD_EXP 64
66475: PPUSH
66476: LD_VAR 0 2
66480: PPUSH
66481: LD_EXP 31
66485: PUSH
66486: LD_VAR 0 2
66490: ARRAY
66491: PPUSH
66492: LD_INT 2
66494: PUSH
66495: LD_INT 30
66497: PUSH
66498: LD_INT 6
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 30
66507: PUSH
66508: LD_INT 7
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 30
66517: PUSH
66518: LD_INT 8
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: LIST
66529: LIST
66530: PPUSH
66531: CALL_OW 72
66535: PPUSH
66536: CALL_OW 1
66540: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
66541: LD_ADDR_EXP 65
66545: PUSH
66546: LD_EXP 65
66550: PPUSH
66551: LD_VAR 0 2
66555: PPUSH
66556: EMPTY
66557: PPUSH
66558: CALL_OW 1
66562: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
66563: LD_ADDR_EXP 66
66567: PUSH
66568: LD_EXP 66
66572: PPUSH
66573: LD_VAR 0 2
66577: PPUSH
66578: EMPTY
66579: PPUSH
66580: CALL_OW 1
66584: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
66585: LD_ADDR_EXP 67
66589: PUSH
66590: LD_EXP 67
66594: PPUSH
66595: LD_VAR 0 2
66599: PPUSH
66600: EMPTY
66601: PPUSH
66602: CALL_OW 1
66606: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
66607: LD_ADDR_EXP 68
66611: PUSH
66612: LD_EXP 68
66616: PPUSH
66617: LD_VAR 0 2
66621: PPUSH
66622: EMPTY
66623: PPUSH
66624: CALL_OW 1
66628: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
66629: LD_ADDR_EXP 69
66633: PUSH
66634: LD_EXP 69
66638: PPUSH
66639: LD_VAR 0 2
66643: PPUSH
66644: EMPTY
66645: PPUSH
66646: CALL_OW 1
66650: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
66651: LD_ADDR_EXP 70
66655: PUSH
66656: LD_EXP 70
66660: PPUSH
66661: LD_VAR 0 2
66665: PPUSH
66666: EMPTY
66667: PPUSH
66668: CALL_OW 1
66672: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
66673: LD_ADDR_EXP 71
66677: PUSH
66678: LD_EXP 71
66682: PPUSH
66683: LD_VAR 0 2
66687: PPUSH
66688: EMPTY
66689: PPUSH
66690: CALL_OW 1
66694: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
66695: LD_ADDR_EXP 72
66699: PUSH
66700: LD_EXP 72
66704: PPUSH
66705: LD_VAR 0 2
66709: PPUSH
66710: EMPTY
66711: PPUSH
66712: CALL_OW 1
66716: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
66717: LD_ADDR_EXP 73
66721: PUSH
66722: LD_EXP 73
66726: PPUSH
66727: LD_VAR 0 2
66731: PPUSH
66732: LD_INT 0
66734: PPUSH
66735: CALL_OW 1
66739: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
66740: LD_ADDR_EXP 74
66744: PUSH
66745: LD_EXP 74
66749: PPUSH
66750: LD_VAR 0 2
66754: PPUSH
66755: LD_INT 0
66757: PPUSH
66758: CALL_OW 1
66762: ST_TO_ADDR
// end ;
66763: GO 65664
66765: POP
66766: POP
// MC_InitSides ( ) ;
66767: CALL 67053 0 0
// MC_InitResearch ( ) ;
66771: CALL 66792 0 0
// CustomInitMacro ( ) ;
66775: CALL 1382 0 0
// skirmish := true ;
66779: LD_ADDR_EXP 29
66783: PUSH
66784: LD_INT 1
66786: ST_TO_ADDR
// end ;
66787: LD_VAR 0 1
66791: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
66792: LD_INT 0
66794: PPUSH
66795: PPUSH
66796: PPUSH
66797: PPUSH
66798: PPUSH
66799: PPUSH
// if not mc_bases then
66800: LD_EXP 31
66804: NOT
66805: IFFALSE 66809
// exit ;
66807: GO 67048
// for i = 1 to 8 do
66809: LD_ADDR_VAR 0 2
66813: PUSH
66814: DOUBLE
66815: LD_INT 1
66817: DEC
66818: ST_TO_ADDR
66819: LD_INT 8
66821: PUSH
66822: FOR_TO
66823: IFFALSE 66849
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
66825: LD_ADDR_EXP 58
66829: PUSH
66830: LD_EXP 58
66834: PPUSH
66835: LD_VAR 0 2
66839: PPUSH
66840: EMPTY
66841: PPUSH
66842: CALL_OW 1
66846: ST_TO_ADDR
66847: GO 66822
66849: POP
66850: POP
// tmp := [ ] ;
66851: LD_ADDR_VAR 0 5
66855: PUSH
66856: EMPTY
66857: ST_TO_ADDR
// for i = 1 to mc_sides do
66858: LD_ADDR_VAR 0 2
66862: PUSH
66863: DOUBLE
66864: LD_INT 1
66866: DEC
66867: ST_TO_ADDR
66868: LD_EXP 57
66872: PUSH
66873: FOR_TO
66874: IFFALSE 66932
// if not mc_sides [ i ] in tmp then
66876: LD_EXP 57
66880: PUSH
66881: LD_VAR 0 2
66885: ARRAY
66886: PUSH
66887: LD_VAR 0 5
66891: IN
66892: NOT
66893: IFFALSE 66930
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
66895: LD_ADDR_VAR 0 5
66899: PUSH
66900: LD_VAR 0 5
66904: PPUSH
66905: LD_VAR 0 5
66909: PUSH
66910: LD_INT 1
66912: PLUS
66913: PPUSH
66914: LD_EXP 57
66918: PUSH
66919: LD_VAR 0 2
66923: ARRAY
66924: PPUSH
66925: CALL_OW 2
66929: ST_TO_ADDR
66930: GO 66873
66932: POP
66933: POP
// if not tmp then
66934: LD_VAR 0 5
66938: NOT
66939: IFFALSE 66943
// exit ;
66941: GO 67048
// for j in tmp do
66943: LD_ADDR_VAR 0 3
66947: PUSH
66948: LD_VAR 0 5
66952: PUSH
66953: FOR_IN
66954: IFFALSE 67046
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
66956: LD_ADDR_VAR 0 6
66960: PUSH
66961: LD_INT 22
66963: PUSH
66964: LD_VAR 0 3
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PPUSH
66973: CALL_OW 69
66977: ST_TO_ADDR
// if not un then
66978: LD_VAR 0 6
66982: NOT
66983: IFFALSE 66987
// continue ;
66985: GO 66953
// nation := GetNation ( un [ 1 ] ) ;
66987: LD_ADDR_VAR 0 4
66991: PUSH
66992: LD_VAR 0 6
66996: PUSH
66997: LD_INT 1
66999: ARRAY
67000: PPUSH
67001: CALL_OW 248
67005: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
67006: LD_ADDR_EXP 58
67010: PUSH
67011: LD_EXP 58
67015: PPUSH
67016: LD_VAR 0 3
67020: PPUSH
67021: LD_VAR 0 3
67025: PPUSH
67026: LD_VAR 0 4
67030: PPUSH
67031: LD_INT 1
67033: PPUSH
67034: CALL 20102 0 3
67038: PPUSH
67039: CALL_OW 1
67043: ST_TO_ADDR
// end ;
67044: GO 66953
67046: POP
67047: POP
// end ;
67048: LD_VAR 0 1
67052: RET
// export function MC_InitSides ( ) ; var i ; begin
67053: LD_INT 0
67055: PPUSH
67056: PPUSH
// if not mc_bases then
67057: LD_EXP 31
67061: NOT
67062: IFFALSE 67066
// exit ;
67064: GO 67140
// for i = 1 to mc_bases do
67066: LD_ADDR_VAR 0 2
67070: PUSH
67071: DOUBLE
67072: LD_INT 1
67074: DEC
67075: ST_TO_ADDR
67076: LD_EXP 31
67080: PUSH
67081: FOR_TO
67082: IFFALSE 67138
// if mc_bases [ i ] then
67084: LD_EXP 31
67088: PUSH
67089: LD_VAR 0 2
67093: ARRAY
67094: IFFALSE 67136
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
67096: LD_ADDR_EXP 57
67100: PUSH
67101: LD_EXP 57
67105: PPUSH
67106: LD_VAR 0 2
67110: PPUSH
67111: LD_EXP 31
67115: PUSH
67116: LD_VAR 0 2
67120: ARRAY
67121: PUSH
67122: LD_INT 1
67124: ARRAY
67125: PPUSH
67126: CALL_OW 255
67130: PPUSH
67131: CALL_OW 1
67135: ST_TO_ADDR
67136: GO 67081
67138: POP
67139: POP
// end ;
67140: LD_VAR 0 1
67144: RET
// every 0 0$03 trigger skirmish do
67145: LD_EXP 29
67149: IFFALSE 67303
67151: GO 67153
67153: DISABLE
// begin enable ;
67154: ENABLE
// MC_CheckBuildings ( ) ;
67155: CALL 71861 0 0
// MC_CheckPeopleLife ( ) ;
67159: CALL 72022 0 0
// RaiseSailEvent ( 100 ) ;
67163: LD_INT 100
67165: PPUSH
67166: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
67170: LD_INT 103
67172: PPUSH
67173: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
67177: LD_INT 104
67179: PPUSH
67180: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
67184: LD_INT 105
67186: PPUSH
67187: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
67191: LD_INT 106
67193: PPUSH
67194: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
67198: LD_INT 107
67200: PPUSH
67201: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
67205: LD_INT 108
67207: PPUSH
67208: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
67212: LD_INT 109
67214: PPUSH
67215: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
67219: LD_INT 110
67221: PPUSH
67222: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
67226: LD_INT 111
67228: PPUSH
67229: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
67233: LD_INT 112
67235: PPUSH
67236: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
67240: LD_INT 113
67242: PPUSH
67243: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
67247: LD_INT 120
67249: PPUSH
67250: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
67254: LD_INT 121
67256: PPUSH
67257: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
67261: LD_INT 122
67263: PPUSH
67264: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
67268: LD_INT 123
67270: PPUSH
67271: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
67275: LD_INT 124
67277: PPUSH
67278: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
67282: LD_INT 125
67284: PPUSH
67285: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
67289: LD_INT 126
67291: PPUSH
67292: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
67296: LD_INT 200
67298: PPUSH
67299: CALL_OW 427
// end ;
67303: END
// on SailEvent ( event ) do begin if event < 100 then
67304: LD_VAR 0 1
67308: PUSH
67309: LD_INT 100
67311: LESS
67312: IFFALSE 67323
// CustomEvent ( event ) ;
67314: LD_VAR 0 1
67318: PPUSH
67319: CALL 19174 0 1
// if event = 100 then
67323: LD_VAR 0 1
67327: PUSH
67328: LD_INT 100
67330: EQUAL
67331: IFFALSE 67337
// MC_ClassManager ( ) ;
67333: CALL 67731 0 0
// if event = 101 then
67337: LD_VAR 0 1
67341: PUSH
67342: LD_INT 101
67344: EQUAL
67345: IFFALSE 67351
// MC_RepairBuildings ( ) ;
67347: CALL 72609 0 0
// if event = 102 then
67351: LD_VAR 0 1
67355: PUSH
67356: LD_INT 102
67358: EQUAL
67359: IFFALSE 67365
// MC_Heal ( ) ;
67361: CALL 73548 0 0
// if event = 103 then
67365: LD_VAR 0 1
67369: PUSH
67370: LD_INT 103
67372: EQUAL
67373: IFFALSE 67379
// MC_Build ( ) ;
67375: CALL 73974 0 0
// if event = 104 then
67379: LD_VAR 0 1
67383: PUSH
67384: LD_INT 104
67386: EQUAL
67387: IFFALSE 67393
// MC_TurretWeapon ( ) ;
67389: CALL 75622 0 0
// if event = 105 then
67393: LD_VAR 0 1
67397: PUSH
67398: LD_INT 105
67400: EQUAL
67401: IFFALSE 67407
// MC_BuildUpgrade ( ) ;
67403: CALL 75167 0 0
// if event = 106 then
67407: LD_VAR 0 1
67411: PUSH
67412: LD_INT 106
67414: EQUAL
67415: IFFALSE 67421
// MC_PlantMines ( ) ;
67417: CALL 76054 0 0
// if event = 107 then
67421: LD_VAR 0 1
67425: PUSH
67426: LD_INT 107
67428: EQUAL
67429: IFFALSE 67435
// MC_CollectCrates ( ) ;
67431: CALL 76864 0 0
// if event = 108 then
67435: LD_VAR 0 1
67439: PUSH
67440: LD_INT 108
67442: EQUAL
67443: IFFALSE 67449
// MC_LinkRemoteControl ( ) ;
67445: CALL 78738 0 0
// if event = 109 then
67449: LD_VAR 0 1
67453: PUSH
67454: LD_INT 109
67456: EQUAL
67457: IFFALSE 67463
// MC_ProduceVehicle ( ) ;
67459: CALL 78923 0 0
// if event = 110 then
67463: LD_VAR 0 1
67467: PUSH
67468: LD_INT 110
67470: EQUAL
67471: IFFALSE 67477
// MC_SendAttack ( ) ;
67473: CALL 79393 0 0
// if event = 111 then
67477: LD_VAR 0 1
67481: PUSH
67482: LD_INT 111
67484: EQUAL
67485: IFFALSE 67491
// MC_Defend ( ) ;
67487: CALL 79501 0 0
// if event = 112 then
67491: LD_VAR 0 1
67495: PUSH
67496: LD_INT 112
67498: EQUAL
67499: IFFALSE 67505
// MC_Research ( ) ;
67501: CALL 80401 0 0
// if event = 113 then
67505: LD_VAR 0 1
67509: PUSH
67510: LD_INT 113
67512: EQUAL
67513: IFFALSE 67519
// MC_MinesTrigger ( ) ;
67515: CALL 81541 0 0
// if event = 120 then
67519: LD_VAR 0 1
67523: PUSH
67524: LD_INT 120
67526: EQUAL
67527: IFFALSE 67533
// MC_RepairVehicle ( ) ;
67529: CALL 81642 0 0
// if event = 121 then
67533: LD_VAR 0 1
67537: PUSH
67538: LD_INT 121
67540: EQUAL
67541: IFFALSE 67547
// MC_TameApe ( ) ;
67543: CALL 82419 0 0
// if event = 122 then
67547: LD_VAR 0 1
67551: PUSH
67552: LD_INT 122
67554: EQUAL
67555: IFFALSE 67561
// MC_ChangeApeClass ( ) ;
67557: CALL 83264 0 0
// if event = 123 then
67561: LD_VAR 0 1
67565: PUSH
67566: LD_INT 123
67568: EQUAL
67569: IFFALSE 67575
// MC_Bazooka ( ) ;
67571: CALL 83920 0 0
// if event = 124 then
67575: LD_VAR 0 1
67579: PUSH
67580: LD_INT 124
67582: EQUAL
67583: IFFALSE 67589
// MC_TeleportExit ( ) ;
67585: CALL 84122 0 0
// if event = 125 then
67589: LD_VAR 0 1
67593: PUSH
67594: LD_INT 125
67596: EQUAL
67597: IFFALSE 67603
// MC_Deposits ( ) ;
67599: CALL 84779 0 0
// if event = 126 then
67603: LD_VAR 0 1
67607: PUSH
67608: LD_INT 126
67610: EQUAL
67611: IFFALSE 67617
// MC_RemoteDriver ( ) ;
67613: CALL 85412 0 0
// if event = 200 then
67617: LD_VAR 0 1
67621: PUSH
67622: LD_INT 200
67624: EQUAL
67625: IFFALSE 67631
// MC_Idle ( ) ;
67627: CALL 87347 0 0
// end ;
67631: PPOPN 1
67633: END
// export function MC_Reset ( base , tag ) ; var i ; begin
67634: LD_INT 0
67636: PPUSH
67637: PPUSH
// if not mc_bases [ base ] or not tag then
67638: LD_EXP 31
67642: PUSH
67643: LD_VAR 0 1
67647: ARRAY
67648: NOT
67649: IFTRUE 67658
67651: PUSH
67652: LD_VAR 0 2
67656: NOT
67657: OR
67658: IFFALSE 67662
// exit ;
67660: GO 67726
// for i in mc_bases [ base ] union mc_ape [ base ] do
67662: LD_ADDR_VAR 0 4
67666: PUSH
67667: LD_EXP 31
67671: PUSH
67672: LD_VAR 0 1
67676: ARRAY
67677: PUSH
67678: LD_EXP 60
67682: PUSH
67683: LD_VAR 0 1
67687: ARRAY
67688: UNION
67689: PUSH
67690: FOR_IN
67691: IFFALSE 67724
// if GetTag ( i ) = tag then
67693: LD_VAR 0 4
67697: PPUSH
67698: CALL_OW 110
67702: PUSH
67703: LD_VAR 0 2
67707: EQUAL
67708: IFFALSE 67722
// SetTag ( i , 0 ) ;
67710: LD_VAR 0 4
67714: PPUSH
67715: LD_INT 0
67717: PPUSH
67718: CALL_OW 109
67722: GO 67690
67724: POP
67725: POP
// end ;
67726: LD_VAR 0 3
67730: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
67731: LD_INT 0
67733: PPUSH
67734: PPUSH
67735: PPUSH
67736: PPUSH
67737: PPUSH
67738: PPUSH
67739: PPUSH
67740: PPUSH
// if not mc_bases then
67741: LD_EXP 31
67745: NOT
67746: IFFALSE 67750
// exit ;
67748: GO 68201
// for i = 1 to mc_bases do
67750: LD_ADDR_VAR 0 2
67754: PUSH
67755: DOUBLE
67756: LD_INT 1
67758: DEC
67759: ST_TO_ADDR
67760: LD_EXP 31
67764: PUSH
67765: FOR_TO
67766: IFFALSE 68199
// begin tmp := MC_ClassCheckReq ( i ) ;
67768: LD_ADDR_VAR 0 4
67772: PUSH
67773: LD_VAR 0 2
67777: PPUSH
67778: CALL 68206 0 1
67782: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
67783: LD_ADDR_EXP 72
67787: PUSH
67788: LD_EXP 72
67792: PPUSH
67793: LD_VAR 0 2
67797: PPUSH
67798: LD_VAR 0 4
67802: PPUSH
67803: CALL_OW 1
67807: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
67808: LD_ADDR_VAR 0 6
67812: PUSH
67813: LD_EXP 31
67817: PUSH
67818: LD_VAR 0 2
67822: ARRAY
67823: PPUSH
67824: LD_INT 2
67826: PUSH
67827: LD_INT 30
67829: PUSH
67830: LD_INT 4
67832: PUSH
67833: EMPTY
67834: LIST
67835: LIST
67836: PUSH
67837: LD_INT 30
67839: PUSH
67840: LD_INT 5
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: PUSH
67847: EMPTY
67848: LIST
67849: LIST
67850: LIST
67851: PPUSH
67852: CALL_OW 72
67856: PUSH
67857: LD_EXP 31
67861: PUSH
67862: LD_VAR 0 2
67866: ARRAY
67867: PPUSH
67868: LD_INT 2
67870: PUSH
67871: LD_INT 30
67873: PUSH
67874: LD_INT 0
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: PUSH
67881: LD_INT 30
67883: PUSH
67884: LD_INT 1
67886: PUSH
67887: EMPTY
67888: LIST
67889: LIST
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: LIST
67895: PPUSH
67896: CALL_OW 72
67900: PUSH
67901: LD_EXP 31
67905: PUSH
67906: LD_VAR 0 2
67910: ARRAY
67911: PPUSH
67912: LD_INT 30
67914: PUSH
67915: LD_INT 3
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PPUSH
67922: CALL_OW 72
67926: PUSH
67927: LD_EXP 31
67931: PUSH
67932: LD_VAR 0 2
67936: ARRAY
67937: PPUSH
67938: LD_INT 2
67940: PUSH
67941: LD_INT 30
67943: PUSH
67944: LD_INT 6
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PUSH
67951: LD_INT 30
67953: PUSH
67954: LD_INT 7
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 30
67963: PUSH
67964: LD_INT 8
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: PPUSH
67977: CALL_OW 72
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: ST_TO_ADDR
// for j := 1 to 4 do
67988: LD_ADDR_VAR 0 3
67992: PUSH
67993: DOUBLE
67994: LD_INT 1
67996: DEC
67997: ST_TO_ADDR
67998: LD_INT 4
68000: PUSH
68001: FOR_TO
68002: IFFALSE 68195
// begin if not tmp [ j ] then
68004: LD_VAR 0 4
68008: PUSH
68009: LD_VAR 0 3
68013: ARRAY
68014: NOT
68015: IFFALSE 68019
// continue ;
68017: GO 68001
// for p in tmp [ j ] do
68019: LD_ADDR_VAR 0 5
68023: PUSH
68024: LD_VAR 0 4
68028: PUSH
68029: LD_VAR 0 3
68033: ARRAY
68034: PUSH
68035: FOR_IN
68036: IFFALSE 68191
// begin if not b [ j ] then
68038: LD_VAR 0 6
68042: PUSH
68043: LD_VAR 0 3
68047: ARRAY
68048: NOT
68049: IFFALSE 68053
// break ;
68051: GO 68191
// e := 0 ;
68053: LD_ADDR_VAR 0 7
68057: PUSH
68058: LD_INT 0
68060: ST_TO_ADDR
// for k in b [ j ] do
68061: LD_ADDR_VAR 0 8
68065: PUSH
68066: LD_VAR 0 6
68070: PUSH
68071: LD_VAR 0 3
68075: ARRAY
68076: PUSH
68077: FOR_IN
68078: IFFALSE 68105
// if IsNotFull ( k ) then
68080: LD_VAR 0 8
68084: PPUSH
68085: CALL 22261 0 1
68089: IFFALSE 68103
// begin e := k ;
68091: LD_ADDR_VAR 0 7
68095: PUSH
68096: LD_VAR 0 8
68100: ST_TO_ADDR
// break ;
68101: GO 68105
// end ;
68103: GO 68077
68105: POP
68106: POP
// if e and not UnitGoingToBuilding ( p , e ) then
68107: LD_VAR 0 7
68111: IFFALSE 68130
68113: PUSH
68114: LD_VAR 0 5
68118: PPUSH
68119: LD_VAR 0 7
68123: PPUSH
68124: CALL 56721 0 2
68128: NOT
68129: AND
68130: IFFALSE 68189
// begin if IsInUnit ( p ) then
68132: LD_VAR 0 5
68136: PPUSH
68137: CALL_OW 310
68141: IFFALSE 68152
// ComExitBuilding ( p ) ;
68143: LD_VAR 0 5
68147: PPUSH
68148: CALL_OW 122
// ComEnterUnit ( p , e ) ;
68152: LD_VAR 0 5
68156: PPUSH
68157: LD_VAR 0 7
68161: PPUSH
68162: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
68166: LD_VAR 0 5
68170: PPUSH
68171: LD_VAR 0 3
68175: PPUSH
68176: CALL_OW 183
// AddComExitBuilding ( p ) ;
68180: LD_VAR 0 5
68184: PPUSH
68185: CALL_OW 182
// end ; end ;
68189: GO 68035
68191: POP
68192: POP
// end ;
68193: GO 68001
68195: POP
68196: POP
// end ;
68197: GO 67765
68199: POP
68200: POP
// end ;
68201: LD_VAR 0 1
68205: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
68206: LD_INT 0
68208: PPUSH
68209: PPUSH
68210: PPUSH
68211: PPUSH
68212: PPUSH
68213: PPUSH
68214: PPUSH
68215: PPUSH
68216: PPUSH
68217: PPUSH
68218: PPUSH
68219: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
68220: LD_ADDR_VAR 0 2
68224: PUSH
68225: LD_INT 0
68227: PUSH
68228: LD_INT 0
68230: PUSH
68231: LD_INT 0
68233: PUSH
68234: LD_INT 0
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: LIST
68241: LIST
68242: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68243: LD_VAR 0 1
68247: NOT
68248: IFTRUE 68263
68250: PUSH
68251: LD_EXP 31
68255: PUSH
68256: LD_VAR 0 1
68260: ARRAY
68261: NOT
68262: OR
68263: IFTRUE 68311
68265: PUSH
68266: LD_EXP 31
68270: PUSH
68271: LD_VAR 0 1
68275: ARRAY
68276: PPUSH
68277: LD_INT 2
68279: PUSH
68280: LD_INT 30
68282: PUSH
68283: LD_INT 0
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 30
68292: PUSH
68293: LD_INT 1
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: LIST
68304: PPUSH
68305: CALL_OW 72
68309: NOT
68310: OR
68311: IFFALSE 68315
// exit ;
68313: GO 71856
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68315: LD_ADDR_VAR 0 4
68319: PUSH
68320: LD_EXP 31
68324: PUSH
68325: LD_VAR 0 1
68329: ARRAY
68330: PPUSH
68331: LD_INT 2
68333: PUSH
68334: LD_INT 25
68336: PUSH
68337: LD_INT 1
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PUSH
68344: LD_INT 25
68346: PUSH
68347: LD_INT 2
68349: PUSH
68350: EMPTY
68351: LIST
68352: LIST
68353: PUSH
68354: LD_INT 25
68356: PUSH
68357: LD_INT 3
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 25
68366: PUSH
68367: LD_INT 4
68369: PUSH
68370: EMPTY
68371: LIST
68372: LIST
68373: PUSH
68374: LD_INT 25
68376: PUSH
68377: LD_INT 5
68379: PUSH
68380: EMPTY
68381: LIST
68382: LIST
68383: PUSH
68384: LD_INT 25
68386: PUSH
68387: LD_INT 8
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PUSH
68394: LD_INT 25
68396: PUSH
68397: LD_INT 9
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: PPUSH
68414: CALL_OW 72
68418: ST_TO_ADDR
// if not tmp then
68419: LD_VAR 0 4
68423: NOT
68424: IFFALSE 68428
// exit ;
68426: GO 71856
// for i in tmp do
68428: LD_ADDR_VAR 0 3
68432: PUSH
68433: LD_VAR 0 4
68437: PUSH
68438: FOR_IN
68439: IFFALSE 68470
// if GetTag ( i ) then
68441: LD_VAR 0 3
68445: PPUSH
68446: CALL_OW 110
68450: IFFALSE 68468
// tmp := tmp diff i ;
68452: LD_ADDR_VAR 0 4
68456: PUSH
68457: LD_VAR 0 4
68461: PUSH
68462: LD_VAR 0 3
68466: DIFF
68467: ST_TO_ADDR
68468: GO 68438
68470: POP
68471: POP
// if not tmp then
68472: LD_VAR 0 4
68476: NOT
68477: IFFALSE 68481
// exit ;
68479: GO 71856
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68481: LD_ADDR_VAR 0 5
68485: PUSH
68486: LD_EXP 31
68490: PUSH
68491: LD_VAR 0 1
68495: ARRAY
68496: PPUSH
68497: LD_INT 2
68499: PUSH
68500: LD_INT 25
68502: PUSH
68503: LD_INT 1
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 25
68512: PUSH
68513: LD_INT 5
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: LD_INT 25
68522: PUSH
68523: LD_INT 8
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: PUSH
68530: LD_INT 25
68532: PUSH
68533: LD_INT 9
68535: PUSH
68536: EMPTY
68537: LIST
68538: LIST
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: LIST
68546: PPUSH
68547: CALL_OW 72
68551: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
68552: LD_ADDR_VAR 0 6
68556: PUSH
68557: LD_EXP 31
68561: PUSH
68562: LD_VAR 0 1
68566: ARRAY
68567: PPUSH
68568: LD_INT 25
68570: PUSH
68571: LD_INT 2
68573: PUSH
68574: EMPTY
68575: LIST
68576: LIST
68577: PPUSH
68578: CALL_OW 72
68582: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
68583: LD_ADDR_VAR 0 7
68587: PUSH
68588: LD_EXP 31
68592: PUSH
68593: LD_VAR 0 1
68597: ARRAY
68598: PPUSH
68599: LD_INT 25
68601: PUSH
68602: LD_INT 3
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PPUSH
68609: CALL_OW 72
68613: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
68614: LD_ADDR_VAR 0 8
68618: PUSH
68619: LD_EXP 31
68623: PUSH
68624: LD_VAR 0 1
68628: ARRAY
68629: PPUSH
68630: LD_INT 25
68632: PUSH
68633: LD_INT 4
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 24
68642: PUSH
68643: LD_INT 251
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: PUSH
68650: EMPTY
68651: LIST
68652: LIST
68653: PPUSH
68654: CALL_OW 72
68658: ST_TO_ADDR
// if mc_is_defending [ base ] then
68659: LD_EXP 74
68663: PUSH
68664: LD_VAR 0 1
68668: ARRAY
68669: IFFALSE 69130
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
68671: LD_ADDR_EXP 73
68675: PUSH
68676: LD_EXP 73
68680: PPUSH
68681: LD_VAR 0 1
68685: PPUSH
68686: LD_INT 4
68688: PPUSH
68689: CALL_OW 1
68693: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68694: LD_ADDR_VAR 0 12
68698: PUSH
68699: LD_EXP 31
68703: PUSH
68704: LD_VAR 0 1
68708: ARRAY
68709: PPUSH
68710: LD_INT 2
68712: PUSH
68713: LD_INT 30
68715: PUSH
68716: LD_INT 4
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 30
68725: PUSH
68726: LD_INT 5
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: LIST
68737: PPUSH
68738: CALL_OW 72
68742: ST_TO_ADDR
// if not b then
68743: LD_VAR 0 12
68747: NOT
68748: IFFALSE 68752
// exit ;
68750: GO 71856
// p := [ ] ;
68752: LD_ADDR_VAR 0 11
68756: PUSH
68757: EMPTY
68758: ST_TO_ADDR
// if sci >= 2 then
68759: LD_VAR 0 8
68763: PUSH
68764: LD_INT 2
68766: GREATEREQUAL
68767: IFFALSE 68798
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
68769: LD_ADDR_VAR 0 8
68773: PUSH
68774: LD_VAR 0 8
68778: PUSH
68779: LD_INT 1
68781: ARRAY
68782: PUSH
68783: LD_VAR 0 8
68787: PUSH
68788: LD_INT 2
68790: ARRAY
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: ST_TO_ADDR
68796: GO 68859
// if sci = 1 then
68798: LD_VAR 0 8
68802: PUSH
68803: LD_INT 1
68805: EQUAL
68806: IFFALSE 68827
// sci := [ sci [ 1 ] ] else
68808: LD_ADDR_VAR 0 8
68812: PUSH
68813: LD_VAR 0 8
68817: PUSH
68818: LD_INT 1
68820: ARRAY
68821: PUSH
68822: EMPTY
68823: LIST
68824: ST_TO_ADDR
68825: GO 68859
// if sci = 0 then
68827: LD_VAR 0 8
68831: PUSH
68832: LD_INT 0
68834: EQUAL
68835: IFFALSE 68859
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
68837: LD_ADDR_VAR 0 11
68841: PUSH
68842: LD_VAR 0 4
68846: PPUSH
68847: LD_INT 4
68849: PPUSH
68850: CALL 56591 0 2
68854: PUSH
68855: LD_INT 1
68857: ARRAY
68858: ST_TO_ADDR
// if eng > 4 then
68859: LD_VAR 0 6
68863: PUSH
68864: LD_INT 4
68866: GREATER
68867: IFFALSE 68913
// for i = eng downto 4 do
68869: LD_ADDR_VAR 0 3
68873: PUSH
68874: DOUBLE
68875: LD_VAR 0 6
68879: INC
68880: ST_TO_ADDR
68881: LD_INT 4
68883: PUSH
68884: FOR_DOWNTO
68885: IFFALSE 68911
// eng := eng diff eng [ i ] ;
68887: LD_ADDR_VAR 0 6
68891: PUSH
68892: LD_VAR 0 6
68896: PUSH
68897: LD_VAR 0 6
68901: PUSH
68902: LD_VAR 0 3
68906: ARRAY
68907: DIFF
68908: ST_TO_ADDR
68909: GO 68884
68911: POP
68912: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
68913: LD_ADDR_VAR 0 4
68917: PUSH
68918: LD_VAR 0 4
68922: PUSH
68923: LD_VAR 0 5
68927: PUSH
68928: LD_VAR 0 6
68932: UNION
68933: PUSH
68934: LD_VAR 0 7
68938: UNION
68939: PUSH
68940: LD_VAR 0 8
68944: UNION
68945: DIFF
68946: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
68947: LD_ADDR_VAR 0 13
68951: PUSH
68952: LD_EXP 31
68956: PUSH
68957: LD_VAR 0 1
68961: ARRAY
68962: PPUSH
68963: LD_INT 2
68965: PUSH
68966: LD_INT 30
68968: PUSH
68969: LD_INT 32
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: PUSH
68976: LD_INT 30
68978: PUSH
68979: LD_INT 31
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: EMPTY
68987: LIST
68988: LIST
68989: LIST
68990: PPUSH
68991: CALL_OW 72
68995: PUSH
68996: LD_EXP 31
69000: PUSH
69001: LD_VAR 0 1
69005: ARRAY
69006: PPUSH
69007: LD_INT 2
69009: PUSH
69010: LD_INT 30
69012: PUSH
69013: LD_INT 4
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 30
69022: PUSH
69023: LD_INT 5
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: LIST
69034: PPUSH
69035: CALL_OW 72
69039: PUSH
69040: LD_INT 6
69042: MUL
69043: PLUS
69044: ST_TO_ADDR
// if bcount < tmp then
69045: LD_VAR 0 13
69049: PUSH
69050: LD_VAR 0 4
69054: LESS
69055: IFFALSE 69101
// for i = tmp downto bcount do
69057: LD_ADDR_VAR 0 3
69061: PUSH
69062: DOUBLE
69063: LD_VAR 0 4
69067: INC
69068: ST_TO_ADDR
69069: LD_VAR 0 13
69073: PUSH
69074: FOR_DOWNTO
69075: IFFALSE 69099
// tmp := Delete ( tmp , tmp ) ;
69077: LD_ADDR_VAR 0 4
69081: PUSH
69082: LD_VAR 0 4
69086: PPUSH
69087: LD_VAR 0 4
69091: PPUSH
69092: CALL_OW 3
69096: ST_TO_ADDR
69097: GO 69074
69099: POP
69100: POP
// result := [ tmp , 0 , 0 , p ] ;
69101: LD_ADDR_VAR 0 2
69105: PUSH
69106: LD_VAR 0 4
69110: PUSH
69111: LD_INT 0
69113: PUSH
69114: LD_INT 0
69116: PUSH
69117: LD_VAR 0 11
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: ST_TO_ADDR
// exit ;
69128: GO 71856
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
69130: LD_EXP 31
69134: PUSH
69135: LD_VAR 0 1
69139: ARRAY
69140: PPUSH
69141: LD_INT 2
69143: PUSH
69144: LD_INT 30
69146: PUSH
69147: LD_INT 6
69149: PUSH
69150: EMPTY
69151: LIST
69152: LIST
69153: PUSH
69154: LD_INT 30
69156: PUSH
69157: LD_INT 7
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: LD_INT 30
69166: PUSH
69167: LD_INT 8
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: EMPTY
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: PPUSH
69180: CALL_OW 72
69184: NOT
69185: IFFALSE 69215
69187: PUSH
69188: LD_EXP 31
69192: PUSH
69193: LD_VAR 0 1
69197: ARRAY
69198: PPUSH
69199: LD_INT 30
69201: PUSH
69202: LD_INT 3
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PPUSH
69209: CALL_OW 72
69213: NOT
69214: AND
69215: IFFALSE 69287
// begin if eng = tmp then
69217: LD_VAR 0 6
69221: PUSH
69222: LD_VAR 0 4
69226: EQUAL
69227: IFFALSE 69231
// exit ;
69229: GO 71856
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
69231: LD_ADDR_EXP 73
69235: PUSH
69236: LD_EXP 73
69240: PPUSH
69241: LD_VAR 0 1
69245: PPUSH
69246: LD_INT 1
69248: PPUSH
69249: CALL_OW 1
69253: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
69254: LD_ADDR_VAR 0 2
69258: PUSH
69259: LD_INT 0
69261: PUSH
69262: LD_VAR 0 4
69266: PUSH
69267: LD_VAR 0 6
69271: DIFF
69272: PUSH
69273: LD_INT 0
69275: PUSH
69276: LD_INT 0
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: LIST
69283: LIST
69284: ST_TO_ADDR
// exit ;
69285: GO 71856
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
69287: LD_EXP 58
69291: PUSH
69292: LD_EXP 57
69296: PUSH
69297: LD_VAR 0 1
69301: ARRAY
69302: ARRAY
69303: IFFALSE 69361
69305: PUSH
69306: LD_EXP 31
69310: PUSH
69311: LD_VAR 0 1
69315: ARRAY
69316: PPUSH
69317: LD_INT 2
69319: PUSH
69320: LD_INT 30
69322: PUSH
69323: LD_INT 6
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: PUSH
69330: LD_INT 30
69332: PUSH
69333: LD_INT 7
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 30
69342: PUSH
69343: LD_INT 8
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: PPUSH
69356: CALL_OW 72
69360: AND
69361: IFFALSE 69391
69363: PUSH
69364: LD_EXP 31
69368: PUSH
69369: LD_VAR 0 1
69373: ARRAY
69374: PPUSH
69375: LD_INT 30
69377: PUSH
69378: LD_INT 3
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PPUSH
69385: CALL_OW 72
69389: NOT
69390: AND
69391: IFFALSE 69607
// begin if sci >= 6 then
69393: LD_VAR 0 8
69397: PUSH
69398: LD_INT 6
69400: GREATEREQUAL
69401: IFFALSE 69405
// exit ;
69403: GO 71856
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
69405: LD_ADDR_EXP 73
69409: PUSH
69410: LD_EXP 73
69414: PPUSH
69415: LD_VAR 0 1
69419: PPUSH
69420: LD_INT 2
69422: PPUSH
69423: CALL_OW 1
69427: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
69428: LD_ADDR_VAR 0 9
69432: PUSH
69433: LD_VAR 0 4
69437: PUSH
69438: LD_VAR 0 8
69442: DIFF
69443: PPUSH
69444: LD_INT 4
69446: PPUSH
69447: CALL 56591 0 2
69451: ST_TO_ADDR
// p := [ ] ;
69452: LD_ADDR_VAR 0 11
69456: PUSH
69457: EMPTY
69458: ST_TO_ADDR
// if sci < 6 and sort > 6 then
69459: LD_VAR 0 8
69463: PUSH
69464: LD_INT 6
69466: LESS
69467: IFFALSE 69479
69469: PUSH
69470: LD_VAR 0 9
69474: PUSH
69475: LD_INT 6
69477: GREATER
69478: AND
69479: IFFALSE 69560
// begin for i = 1 to 6 - sci do
69481: LD_ADDR_VAR 0 3
69485: PUSH
69486: DOUBLE
69487: LD_INT 1
69489: DEC
69490: ST_TO_ADDR
69491: LD_INT 6
69493: PUSH
69494: LD_VAR 0 8
69498: MINUS
69499: PUSH
69500: FOR_TO
69501: IFFALSE 69556
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
69503: LD_ADDR_VAR 0 11
69507: PUSH
69508: LD_VAR 0 11
69512: PPUSH
69513: LD_VAR 0 11
69517: PUSH
69518: LD_INT 1
69520: PLUS
69521: PPUSH
69522: LD_VAR 0 9
69526: PUSH
69527: LD_INT 1
69529: ARRAY
69530: PPUSH
69531: CALL_OW 2
69535: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
69536: LD_ADDR_VAR 0 9
69540: PUSH
69541: LD_VAR 0 9
69545: PPUSH
69546: LD_INT 1
69548: PPUSH
69549: CALL_OW 3
69553: ST_TO_ADDR
// end ;
69554: GO 69500
69556: POP
69557: POP
// end else
69558: GO 69580
// if sort then
69560: LD_VAR 0 9
69564: IFFALSE 69580
// p := sort [ 1 ] ;
69566: LD_ADDR_VAR 0 11
69570: PUSH
69571: LD_VAR 0 9
69575: PUSH
69576: LD_INT 1
69578: ARRAY
69579: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
69580: LD_ADDR_VAR 0 2
69584: PUSH
69585: LD_INT 0
69587: PUSH
69588: LD_INT 0
69590: PUSH
69591: LD_INT 0
69593: PUSH
69594: LD_VAR 0 11
69598: PUSH
69599: EMPTY
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: ST_TO_ADDR
// exit ;
69605: GO 71856
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
69607: LD_EXP 58
69611: PUSH
69612: LD_EXP 57
69616: PUSH
69617: LD_VAR 0 1
69621: ARRAY
69622: ARRAY
69623: IFFALSE 69681
69625: PUSH
69626: LD_EXP 31
69630: PUSH
69631: LD_VAR 0 1
69635: ARRAY
69636: PPUSH
69637: LD_INT 2
69639: PUSH
69640: LD_INT 30
69642: PUSH
69643: LD_INT 6
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: LD_INT 30
69652: PUSH
69653: LD_INT 7
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: LD_INT 30
69662: PUSH
69663: LD_INT 8
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: PPUSH
69676: CALL_OW 72
69680: AND
69681: IFFALSE 69710
69683: PUSH
69684: LD_EXP 31
69688: PUSH
69689: LD_VAR 0 1
69693: ARRAY
69694: PPUSH
69695: LD_INT 30
69697: PUSH
69698: LD_INT 3
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PPUSH
69705: CALL_OW 72
69709: AND
69710: IFFALSE 70450
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
69712: LD_ADDR_EXP 73
69716: PUSH
69717: LD_EXP 73
69721: PPUSH
69722: LD_VAR 0 1
69726: PPUSH
69727: LD_INT 3
69729: PPUSH
69730: CALL_OW 1
69734: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
69735: LD_ADDR_VAR 0 2
69739: PUSH
69740: LD_INT 0
69742: PUSH
69743: LD_INT 0
69745: PUSH
69746: LD_INT 0
69748: PUSH
69749: LD_INT 0
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: ST_TO_ADDR
// if not eng then
69758: LD_VAR 0 6
69762: NOT
69763: IFFALSE 69826
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
69765: LD_ADDR_VAR 0 11
69769: PUSH
69770: LD_VAR 0 4
69774: PPUSH
69775: LD_INT 2
69777: PPUSH
69778: CALL 56591 0 2
69782: PUSH
69783: LD_INT 1
69785: ARRAY
69786: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
69787: LD_ADDR_VAR 0 2
69791: PUSH
69792: LD_VAR 0 2
69796: PPUSH
69797: LD_INT 2
69799: PPUSH
69800: LD_VAR 0 11
69804: PPUSH
69805: CALL_OW 1
69809: ST_TO_ADDR
// tmp := tmp diff p ;
69810: LD_ADDR_VAR 0 4
69814: PUSH
69815: LD_VAR 0 4
69819: PUSH
69820: LD_VAR 0 11
69824: DIFF
69825: ST_TO_ADDR
// end ; if tmp and sci < 6 then
69826: LD_VAR 0 4
69830: IFFALSE 69842
69832: PUSH
69833: LD_VAR 0 8
69837: PUSH
69838: LD_INT 6
69840: LESS
69841: AND
69842: IFFALSE 70030
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
69844: LD_ADDR_VAR 0 9
69848: PUSH
69849: LD_VAR 0 4
69853: PUSH
69854: LD_VAR 0 8
69858: PUSH
69859: LD_VAR 0 7
69863: UNION
69864: DIFF
69865: PPUSH
69866: LD_INT 4
69868: PPUSH
69869: CALL 56591 0 2
69873: ST_TO_ADDR
// p := [ ] ;
69874: LD_ADDR_VAR 0 11
69878: PUSH
69879: EMPTY
69880: ST_TO_ADDR
// if sort then
69881: LD_VAR 0 9
69885: IFFALSE 70001
// for i = 1 to 6 - sci do
69887: LD_ADDR_VAR 0 3
69891: PUSH
69892: DOUBLE
69893: LD_INT 1
69895: DEC
69896: ST_TO_ADDR
69897: LD_INT 6
69899: PUSH
69900: LD_VAR 0 8
69904: MINUS
69905: PUSH
69906: FOR_TO
69907: IFFALSE 69999
// begin if i = sort then
69909: LD_VAR 0 3
69913: PUSH
69914: LD_VAR 0 9
69918: EQUAL
69919: IFFALSE 69923
// break ;
69921: GO 69999
// if GetClass ( i ) = 4 then
69923: LD_VAR 0 3
69927: PPUSH
69928: CALL_OW 257
69932: PUSH
69933: LD_INT 4
69935: EQUAL
69936: IFFALSE 69940
// continue ;
69938: GO 69906
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69940: LD_ADDR_VAR 0 11
69944: PUSH
69945: LD_VAR 0 11
69949: PPUSH
69950: LD_VAR 0 11
69954: PUSH
69955: LD_INT 1
69957: PLUS
69958: PPUSH
69959: LD_VAR 0 9
69963: PUSH
69964: LD_VAR 0 3
69968: ARRAY
69969: PPUSH
69970: CALL_OW 2
69974: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69975: LD_ADDR_VAR 0 4
69979: PUSH
69980: LD_VAR 0 4
69984: PUSH
69985: LD_VAR 0 9
69989: PUSH
69990: LD_VAR 0 3
69994: ARRAY
69995: DIFF
69996: ST_TO_ADDR
// end ;
69997: GO 69906
69999: POP
70000: POP
// if p then
70001: LD_VAR 0 11
70005: IFFALSE 70030
// result := Replace ( result , 4 , p ) ;
70007: LD_ADDR_VAR 0 2
70011: PUSH
70012: LD_VAR 0 2
70016: PPUSH
70017: LD_INT 4
70019: PPUSH
70020: LD_VAR 0 11
70024: PPUSH
70025: CALL_OW 1
70029: ST_TO_ADDR
// end ; if tmp and mech < 6 then
70030: LD_VAR 0 4
70034: IFFALSE 70046
70036: PUSH
70037: LD_VAR 0 7
70041: PUSH
70042: LD_INT 6
70044: LESS
70045: AND
70046: IFFALSE 70234
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
70048: LD_ADDR_VAR 0 9
70052: PUSH
70053: LD_VAR 0 4
70057: PUSH
70058: LD_VAR 0 8
70062: PUSH
70063: LD_VAR 0 7
70067: UNION
70068: DIFF
70069: PPUSH
70070: LD_INT 3
70072: PPUSH
70073: CALL 56591 0 2
70077: ST_TO_ADDR
// p := [ ] ;
70078: LD_ADDR_VAR 0 11
70082: PUSH
70083: EMPTY
70084: ST_TO_ADDR
// if sort then
70085: LD_VAR 0 9
70089: IFFALSE 70205
// for i = 1 to 6 - mech do
70091: LD_ADDR_VAR 0 3
70095: PUSH
70096: DOUBLE
70097: LD_INT 1
70099: DEC
70100: ST_TO_ADDR
70101: LD_INT 6
70103: PUSH
70104: LD_VAR 0 7
70108: MINUS
70109: PUSH
70110: FOR_TO
70111: IFFALSE 70203
// begin if i = sort then
70113: LD_VAR 0 3
70117: PUSH
70118: LD_VAR 0 9
70122: EQUAL
70123: IFFALSE 70127
// break ;
70125: GO 70203
// if GetClass ( i ) = 3 then
70127: LD_VAR 0 3
70131: PPUSH
70132: CALL_OW 257
70136: PUSH
70137: LD_INT 3
70139: EQUAL
70140: IFFALSE 70144
// continue ;
70142: GO 70110
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70144: LD_ADDR_VAR 0 11
70148: PUSH
70149: LD_VAR 0 11
70153: PPUSH
70154: LD_VAR 0 11
70158: PUSH
70159: LD_INT 1
70161: PLUS
70162: PPUSH
70163: LD_VAR 0 9
70167: PUSH
70168: LD_VAR 0 3
70172: ARRAY
70173: PPUSH
70174: CALL_OW 2
70178: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70179: LD_ADDR_VAR 0 4
70183: PUSH
70184: LD_VAR 0 4
70188: PUSH
70189: LD_VAR 0 9
70193: PUSH
70194: LD_VAR 0 3
70198: ARRAY
70199: DIFF
70200: ST_TO_ADDR
// end ;
70201: GO 70110
70203: POP
70204: POP
// if p then
70205: LD_VAR 0 11
70209: IFFALSE 70234
// result := Replace ( result , 3 , p ) ;
70211: LD_ADDR_VAR 0 2
70215: PUSH
70216: LD_VAR 0 2
70220: PPUSH
70221: LD_INT 3
70223: PPUSH
70224: LD_VAR 0 11
70228: PPUSH
70229: CALL_OW 1
70233: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
70234: LD_VAR 0 4
70238: PUSH
70239: LD_INT 6
70241: GREATER
70242: IFFALSE 70254
70244: PUSH
70245: LD_VAR 0 6
70249: PUSH
70250: LD_INT 6
70252: LESS
70253: AND
70254: IFFALSE 70448
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
70256: LD_ADDR_VAR 0 9
70260: PUSH
70261: LD_VAR 0 4
70265: PUSH
70266: LD_VAR 0 8
70270: PUSH
70271: LD_VAR 0 7
70275: UNION
70276: PUSH
70277: LD_VAR 0 6
70281: UNION
70282: DIFF
70283: PPUSH
70284: LD_INT 2
70286: PPUSH
70287: CALL 56591 0 2
70291: ST_TO_ADDR
// p := [ ] ;
70292: LD_ADDR_VAR 0 11
70296: PUSH
70297: EMPTY
70298: ST_TO_ADDR
// if sort then
70299: LD_VAR 0 9
70303: IFFALSE 70419
// for i = 1 to 6 - eng do
70305: LD_ADDR_VAR 0 3
70309: PUSH
70310: DOUBLE
70311: LD_INT 1
70313: DEC
70314: ST_TO_ADDR
70315: LD_INT 6
70317: PUSH
70318: LD_VAR 0 6
70322: MINUS
70323: PUSH
70324: FOR_TO
70325: IFFALSE 70417
// begin if i = sort then
70327: LD_VAR 0 3
70331: PUSH
70332: LD_VAR 0 9
70336: EQUAL
70337: IFFALSE 70341
// break ;
70339: GO 70417
// if GetClass ( i ) = 2 then
70341: LD_VAR 0 3
70345: PPUSH
70346: CALL_OW 257
70350: PUSH
70351: LD_INT 2
70353: EQUAL
70354: IFFALSE 70358
// continue ;
70356: GO 70324
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70358: LD_ADDR_VAR 0 11
70362: PUSH
70363: LD_VAR 0 11
70367: PPUSH
70368: LD_VAR 0 11
70372: PUSH
70373: LD_INT 1
70375: PLUS
70376: PPUSH
70377: LD_VAR 0 9
70381: PUSH
70382: LD_VAR 0 3
70386: ARRAY
70387: PPUSH
70388: CALL_OW 2
70392: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70393: LD_ADDR_VAR 0 4
70397: PUSH
70398: LD_VAR 0 4
70402: PUSH
70403: LD_VAR 0 9
70407: PUSH
70408: LD_VAR 0 3
70412: ARRAY
70413: DIFF
70414: ST_TO_ADDR
// end ;
70415: GO 70324
70417: POP
70418: POP
// if p then
70419: LD_VAR 0 11
70423: IFFALSE 70448
// result := Replace ( result , 2 , p ) ;
70425: LD_ADDR_VAR 0 2
70429: PUSH
70430: LD_VAR 0 2
70434: PPUSH
70435: LD_INT 2
70437: PPUSH
70438: LD_VAR 0 11
70442: PPUSH
70443: CALL_OW 1
70447: ST_TO_ADDR
// end ; exit ;
70448: GO 71856
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
70450: LD_EXP 58
70454: PUSH
70455: LD_EXP 57
70459: PUSH
70460: LD_VAR 0 1
70464: ARRAY
70465: ARRAY
70466: NOT
70467: IFFALSE 70496
70469: PUSH
70470: LD_EXP 31
70474: PUSH
70475: LD_VAR 0 1
70479: ARRAY
70480: PPUSH
70481: LD_INT 30
70483: PUSH
70484: LD_INT 3
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PPUSH
70491: CALL_OW 72
70495: AND
70496: IFFALSE 70510
70498: PUSH
70499: LD_EXP 36
70503: PUSH
70504: LD_VAR 0 1
70508: ARRAY
70509: AND
70510: IFFALSE 71124
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
70512: LD_ADDR_EXP 73
70516: PUSH
70517: LD_EXP 73
70521: PPUSH
70522: LD_VAR 0 1
70526: PPUSH
70527: LD_INT 5
70529: PPUSH
70530: CALL_OW 1
70534: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
70535: LD_ADDR_VAR 0 2
70539: PUSH
70540: LD_INT 0
70542: PUSH
70543: LD_INT 0
70545: PUSH
70546: LD_INT 0
70548: PUSH
70549: LD_INT 0
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: ST_TO_ADDR
// if sci > 1 then
70558: LD_VAR 0 8
70562: PUSH
70563: LD_INT 1
70565: GREATER
70566: IFFALSE 70594
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
70568: LD_ADDR_VAR 0 4
70572: PUSH
70573: LD_VAR 0 4
70577: PUSH
70578: LD_VAR 0 8
70582: PUSH
70583: LD_VAR 0 8
70587: PUSH
70588: LD_INT 1
70590: ARRAY
70591: DIFF
70592: DIFF
70593: ST_TO_ADDR
// if tmp and not sci then
70594: LD_VAR 0 4
70598: IFFALSE 70607
70600: PUSH
70601: LD_VAR 0 8
70605: NOT
70606: AND
70607: IFFALSE 70676
// begin sort := SortBySkill ( tmp , 4 ) ;
70609: LD_ADDR_VAR 0 9
70613: PUSH
70614: LD_VAR 0 4
70618: PPUSH
70619: LD_INT 4
70621: PPUSH
70622: CALL 56591 0 2
70626: ST_TO_ADDR
// if sort then
70627: LD_VAR 0 9
70631: IFFALSE 70647
// p := sort [ 1 ] ;
70633: LD_ADDR_VAR 0 11
70637: PUSH
70638: LD_VAR 0 9
70642: PUSH
70643: LD_INT 1
70645: ARRAY
70646: ST_TO_ADDR
// if p then
70647: LD_VAR 0 11
70651: IFFALSE 70676
// result := Replace ( result , 4 , p ) ;
70653: LD_ADDR_VAR 0 2
70657: PUSH
70658: LD_VAR 0 2
70662: PPUSH
70663: LD_INT 4
70665: PPUSH
70666: LD_VAR 0 11
70670: PPUSH
70671: CALL_OW 1
70675: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
70676: LD_ADDR_VAR 0 4
70680: PUSH
70681: LD_VAR 0 4
70685: PUSH
70686: LD_VAR 0 7
70690: DIFF
70691: ST_TO_ADDR
// if tmp and mech < 6 then
70692: LD_VAR 0 4
70696: IFFALSE 70708
70698: PUSH
70699: LD_VAR 0 7
70703: PUSH
70704: LD_INT 6
70706: LESS
70707: AND
70708: IFFALSE 70896
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
70710: LD_ADDR_VAR 0 9
70714: PUSH
70715: LD_VAR 0 4
70719: PUSH
70720: LD_VAR 0 8
70724: PUSH
70725: LD_VAR 0 7
70729: UNION
70730: DIFF
70731: PPUSH
70732: LD_INT 3
70734: PPUSH
70735: CALL 56591 0 2
70739: ST_TO_ADDR
// p := [ ] ;
70740: LD_ADDR_VAR 0 11
70744: PUSH
70745: EMPTY
70746: ST_TO_ADDR
// if sort then
70747: LD_VAR 0 9
70751: IFFALSE 70867
// for i = 1 to 6 - mech do
70753: LD_ADDR_VAR 0 3
70757: PUSH
70758: DOUBLE
70759: LD_INT 1
70761: DEC
70762: ST_TO_ADDR
70763: LD_INT 6
70765: PUSH
70766: LD_VAR 0 7
70770: MINUS
70771: PUSH
70772: FOR_TO
70773: IFFALSE 70865
// begin if i = sort then
70775: LD_VAR 0 3
70779: PUSH
70780: LD_VAR 0 9
70784: EQUAL
70785: IFFALSE 70789
// break ;
70787: GO 70865
// if GetClass ( i ) = 3 then
70789: LD_VAR 0 3
70793: PPUSH
70794: CALL_OW 257
70798: PUSH
70799: LD_INT 3
70801: EQUAL
70802: IFFALSE 70806
// continue ;
70804: GO 70772
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70806: LD_ADDR_VAR 0 11
70810: PUSH
70811: LD_VAR 0 11
70815: PPUSH
70816: LD_VAR 0 11
70820: PUSH
70821: LD_INT 1
70823: PLUS
70824: PPUSH
70825: LD_VAR 0 9
70829: PUSH
70830: LD_VAR 0 3
70834: ARRAY
70835: PPUSH
70836: CALL_OW 2
70840: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70841: LD_ADDR_VAR 0 4
70845: PUSH
70846: LD_VAR 0 4
70850: PUSH
70851: LD_VAR 0 9
70855: PUSH
70856: LD_VAR 0 3
70860: ARRAY
70861: DIFF
70862: ST_TO_ADDR
// end ;
70863: GO 70772
70865: POP
70866: POP
// if p then
70867: LD_VAR 0 11
70871: IFFALSE 70896
// result := Replace ( result , 3 , p ) ;
70873: LD_ADDR_VAR 0 2
70877: PUSH
70878: LD_VAR 0 2
70882: PPUSH
70883: LD_INT 3
70885: PPUSH
70886: LD_VAR 0 11
70890: PPUSH
70891: CALL_OW 1
70895: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
70896: LD_ADDR_VAR 0 4
70900: PUSH
70901: LD_VAR 0 4
70905: PUSH
70906: LD_VAR 0 6
70910: DIFF
70911: ST_TO_ADDR
// if tmp and eng < 6 then
70912: LD_VAR 0 4
70916: IFFALSE 70928
70918: PUSH
70919: LD_VAR 0 6
70923: PUSH
70924: LD_INT 6
70926: LESS
70927: AND
70928: IFFALSE 71122
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
70930: LD_ADDR_VAR 0 9
70934: PUSH
70935: LD_VAR 0 4
70939: PUSH
70940: LD_VAR 0 8
70944: PUSH
70945: LD_VAR 0 7
70949: UNION
70950: PUSH
70951: LD_VAR 0 6
70955: UNION
70956: DIFF
70957: PPUSH
70958: LD_INT 2
70960: PPUSH
70961: CALL 56591 0 2
70965: ST_TO_ADDR
// p := [ ] ;
70966: LD_ADDR_VAR 0 11
70970: PUSH
70971: EMPTY
70972: ST_TO_ADDR
// if sort then
70973: LD_VAR 0 9
70977: IFFALSE 71093
// for i = 1 to 6 - eng do
70979: LD_ADDR_VAR 0 3
70983: PUSH
70984: DOUBLE
70985: LD_INT 1
70987: DEC
70988: ST_TO_ADDR
70989: LD_INT 6
70991: PUSH
70992: LD_VAR 0 6
70996: MINUS
70997: PUSH
70998: FOR_TO
70999: IFFALSE 71091
// begin if i = sort then
71001: LD_VAR 0 3
71005: PUSH
71006: LD_VAR 0 9
71010: EQUAL
71011: IFFALSE 71015
// break ;
71013: GO 71091
// if GetClass ( i ) = 2 then
71015: LD_VAR 0 3
71019: PPUSH
71020: CALL_OW 257
71024: PUSH
71025: LD_INT 2
71027: EQUAL
71028: IFFALSE 71032
// continue ;
71030: GO 70998
// p := Insert ( p , p + 1 , sort [ i ] ) ;
71032: LD_ADDR_VAR 0 11
71036: PUSH
71037: LD_VAR 0 11
71041: PPUSH
71042: LD_VAR 0 11
71046: PUSH
71047: LD_INT 1
71049: PLUS
71050: PPUSH
71051: LD_VAR 0 9
71055: PUSH
71056: LD_VAR 0 3
71060: ARRAY
71061: PPUSH
71062: CALL_OW 2
71066: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
71067: LD_ADDR_VAR 0 4
71071: PUSH
71072: LD_VAR 0 4
71076: PUSH
71077: LD_VAR 0 9
71081: PUSH
71082: LD_VAR 0 3
71086: ARRAY
71087: DIFF
71088: ST_TO_ADDR
// end ;
71089: GO 70998
71091: POP
71092: POP
// if p then
71093: LD_VAR 0 11
71097: IFFALSE 71122
// result := Replace ( result , 2 , p ) ;
71099: LD_ADDR_VAR 0 2
71103: PUSH
71104: LD_VAR 0 2
71108: PPUSH
71109: LD_INT 2
71111: PPUSH
71112: LD_VAR 0 11
71116: PPUSH
71117: CALL_OW 1
71121: ST_TO_ADDR
// end ; exit ;
71122: GO 71856
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
71124: LD_EXP 58
71128: PUSH
71129: LD_EXP 57
71133: PUSH
71134: LD_VAR 0 1
71138: ARRAY
71139: ARRAY
71140: NOT
71141: IFFALSE 71170
71143: PUSH
71144: LD_EXP 31
71148: PUSH
71149: LD_VAR 0 1
71153: ARRAY
71154: PPUSH
71155: LD_INT 30
71157: PUSH
71158: LD_INT 3
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PPUSH
71165: CALL_OW 72
71169: AND
71170: IFFALSE 71185
71172: PUSH
71173: LD_EXP 36
71177: PUSH
71178: LD_VAR 0 1
71182: ARRAY
71183: NOT
71184: AND
71185: IFFALSE 71856
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
71187: LD_ADDR_EXP 73
71191: PUSH
71192: LD_EXP 73
71196: PPUSH
71197: LD_VAR 0 1
71201: PPUSH
71202: LD_INT 6
71204: PPUSH
71205: CALL_OW 1
71209: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
71210: LD_ADDR_VAR 0 2
71214: PUSH
71215: LD_INT 0
71217: PUSH
71218: LD_INT 0
71220: PUSH
71221: LD_INT 0
71223: PUSH
71224: LD_INT 0
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: LIST
71231: LIST
71232: ST_TO_ADDR
// if sci >= 1 then
71233: LD_VAR 0 8
71237: PUSH
71238: LD_INT 1
71240: GREATEREQUAL
71241: IFFALSE 71263
// tmp := tmp diff sci [ 1 ] ;
71243: LD_ADDR_VAR 0 4
71247: PUSH
71248: LD_VAR 0 4
71252: PUSH
71253: LD_VAR 0 8
71257: PUSH
71258: LD_INT 1
71260: ARRAY
71261: DIFF
71262: ST_TO_ADDR
// if tmp and not sci then
71263: LD_VAR 0 4
71267: IFFALSE 71276
71269: PUSH
71270: LD_VAR 0 8
71274: NOT
71275: AND
71276: IFFALSE 71345
// begin sort := SortBySkill ( tmp , 4 ) ;
71278: LD_ADDR_VAR 0 9
71282: PUSH
71283: LD_VAR 0 4
71287: PPUSH
71288: LD_INT 4
71290: PPUSH
71291: CALL 56591 0 2
71295: ST_TO_ADDR
// if sort then
71296: LD_VAR 0 9
71300: IFFALSE 71316
// p := sort [ 1 ] ;
71302: LD_ADDR_VAR 0 11
71306: PUSH
71307: LD_VAR 0 9
71311: PUSH
71312: LD_INT 1
71314: ARRAY
71315: ST_TO_ADDR
// if p then
71316: LD_VAR 0 11
71320: IFFALSE 71345
// result := Replace ( result , 4 , p ) ;
71322: LD_ADDR_VAR 0 2
71326: PUSH
71327: LD_VAR 0 2
71331: PPUSH
71332: LD_INT 4
71334: PPUSH
71335: LD_VAR 0 11
71339: PPUSH
71340: CALL_OW 1
71344: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
71345: LD_ADDR_VAR 0 4
71349: PUSH
71350: LD_VAR 0 4
71354: PUSH
71355: LD_VAR 0 7
71359: DIFF
71360: ST_TO_ADDR
// if tmp and mech < 6 then
71361: LD_VAR 0 4
71365: IFFALSE 71377
71367: PUSH
71368: LD_VAR 0 7
71372: PUSH
71373: LD_INT 6
71375: LESS
71376: AND
71377: IFFALSE 71559
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
71379: LD_ADDR_VAR 0 9
71383: PUSH
71384: LD_VAR 0 4
71388: PUSH
71389: LD_VAR 0 7
71393: DIFF
71394: PPUSH
71395: LD_INT 3
71397: PPUSH
71398: CALL 56591 0 2
71402: ST_TO_ADDR
// p := [ ] ;
71403: LD_ADDR_VAR 0 11
71407: PUSH
71408: EMPTY
71409: ST_TO_ADDR
// if sort then
71410: LD_VAR 0 9
71414: IFFALSE 71530
// for i = 1 to 6 - mech do
71416: LD_ADDR_VAR 0 3
71420: PUSH
71421: DOUBLE
71422: LD_INT 1
71424: DEC
71425: ST_TO_ADDR
71426: LD_INT 6
71428: PUSH
71429: LD_VAR 0 7
71433: MINUS
71434: PUSH
71435: FOR_TO
71436: IFFALSE 71528
// begin if i = sort then
71438: LD_VAR 0 3
71442: PUSH
71443: LD_VAR 0 9
71447: EQUAL
71448: IFFALSE 71452
// break ;
71450: GO 71528
// if GetClass ( i ) = 3 then
71452: LD_VAR 0 3
71456: PPUSH
71457: CALL_OW 257
71461: PUSH
71462: LD_INT 3
71464: EQUAL
71465: IFFALSE 71469
// continue ;
71467: GO 71435
// p := Insert ( p , p + 1 , sort [ i ] ) ;
71469: LD_ADDR_VAR 0 11
71473: PUSH
71474: LD_VAR 0 11
71478: PPUSH
71479: LD_VAR 0 11
71483: PUSH
71484: LD_INT 1
71486: PLUS
71487: PPUSH
71488: LD_VAR 0 9
71492: PUSH
71493: LD_VAR 0 3
71497: ARRAY
71498: PPUSH
71499: CALL_OW 2
71503: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
71504: LD_ADDR_VAR 0 4
71508: PUSH
71509: LD_VAR 0 4
71513: PUSH
71514: LD_VAR 0 9
71518: PUSH
71519: LD_VAR 0 3
71523: ARRAY
71524: DIFF
71525: ST_TO_ADDR
// end ;
71526: GO 71435
71528: POP
71529: POP
// if p then
71530: LD_VAR 0 11
71534: IFFALSE 71559
// result := Replace ( result , 3 , p ) ;
71536: LD_ADDR_VAR 0 2
71540: PUSH
71541: LD_VAR 0 2
71545: PPUSH
71546: LD_INT 3
71548: PPUSH
71549: LD_VAR 0 11
71553: PPUSH
71554: CALL_OW 1
71558: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
71559: LD_ADDR_VAR 0 4
71563: PUSH
71564: LD_VAR 0 4
71568: PUSH
71569: LD_VAR 0 6
71573: DIFF
71574: ST_TO_ADDR
// if tmp and eng < 4 then
71575: LD_VAR 0 4
71579: IFFALSE 71591
71581: PUSH
71582: LD_VAR 0 6
71586: PUSH
71587: LD_INT 4
71589: LESS
71590: AND
71591: IFFALSE 71781
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
71593: LD_ADDR_VAR 0 9
71597: PUSH
71598: LD_VAR 0 4
71602: PUSH
71603: LD_VAR 0 7
71607: PUSH
71608: LD_VAR 0 6
71612: UNION
71613: DIFF
71614: PPUSH
71615: LD_INT 2
71617: PPUSH
71618: CALL 56591 0 2
71622: ST_TO_ADDR
// p := [ ] ;
71623: LD_ADDR_VAR 0 11
71627: PUSH
71628: EMPTY
71629: ST_TO_ADDR
// if sort then
71630: LD_VAR 0 9
71634: IFFALSE 71750
// for i = 1 to 4 - eng do
71636: LD_ADDR_VAR 0 3
71640: PUSH
71641: DOUBLE
71642: LD_INT 1
71644: DEC
71645: ST_TO_ADDR
71646: LD_INT 4
71648: PUSH
71649: LD_VAR 0 6
71653: MINUS
71654: PUSH
71655: FOR_TO
71656: IFFALSE 71748
// begin if i = sort then
71658: LD_VAR 0 3
71662: PUSH
71663: LD_VAR 0 9
71667: EQUAL
71668: IFFALSE 71672
// break ;
71670: GO 71748
// if GetClass ( i ) = 2 then
71672: LD_VAR 0 3
71676: PPUSH
71677: CALL_OW 257
71681: PUSH
71682: LD_INT 2
71684: EQUAL
71685: IFFALSE 71689
// continue ;
71687: GO 71655
// p := Insert ( p , p + 1 , sort [ i ] ) ;
71689: LD_ADDR_VAR 0 11
71693: PUSH
71694: LD_VAR 0 11
71698: PPUSH
71699: LD_VAR 0 11
71703: PUSH
71704: LD_INT 1
71706: PLUS
71707: PPUSH
71708: LD_VAR 0 9
71712: PUSH
71713: LD_VAR 0 3
71717: ARRAY
71718: PPUSH
71719: CALL_OW 2
71723: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
71724: LD_ADDR_VAR 0 4
71728: PUSH
71729: LD_VAR 0 4
71733: PUSH
71734: LD_VAR 0 9
71738: PUSH
71739: LD_VAR 0 3
71743: ARRAY
71744: DIFF
71745: ST_TO_ADDR
// end ;
71746: GO 71655
71748: POP
71749: POP
// if p then
71750: LD_VAR 0 11
71754: IFFALSE 71779
// result := Replace ( result , 2 , p ) ;
71756: LD_ADDR_VAR 0 2
71760: PUSH
71761: LD_VAR 0 2
71765: PPUSH
71766: LD_INT 2
71768: PPUSH
71769: LD_VAR 0 11
71773: PPUSH
71774: CALL_OW 1
71778: ST_TO_ADDR
// end else
71779: GO 71825
// for i = eng downto 5 do
71781: LD_ADDR_VAR 0 3
71785: PUSH
71786: DOUBLE
71787: LD_VAR 0 6
71791: INC
71792: ST_TO_ADDR
71793: LD_INT 5
71795: PUSH
71796: FOR_DOWNTO
71797: IFFALSE 71823
// tmp := tmp union eng [ i ] ;
71799: LD_ADDR_VAR 0 4
71803: PUSH
71804: LD_VAR 0 4
71808: PUSH
71809: LD_VAR 0 6
71813: PUSH
71814: LD_VAR 0 3
71818: ARRAY
71819: UNION
71820: ST_TO_ADDR
71821: GO 71796
71823: POP
71824: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
71825: LD_ADDR_VAR 0 2
71829: PUSH
71830: LD_VAR 0 2
71834: PPUSH
71835: LD_INT 1
71837: PPUSH
71838: LD_VAR 0 4
71842: PUSH
71843: LD_VAR 0 5
71847: DIFF
71848: PPUSH
71849: CALL_OW 1
71853: ST_TO_ADDR
// exit ;
71854: GO 71856
// end ; end ;
71856: LD_VAR 0 2
71860: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
71861: LD_INT 0
71863: PPUSH
71864: PPUSH
71865: PPUSH
// if not mc_bases then
71866: LD_EXP 31
71870: NOT
71871: IFFALSE 71875
// exit ;
71873: GO 72017
// for i = 1 to mc_bases do
71875: LD_ADDR_VAR 0 2
71879: PUSH
71880: DOUBLE
71881: LD_INT 1
71883: DEC
71884: ST_TO_ADDR
71885: LD_EXP 31
71889: PUSH
71890: FOR_TO
71891: IFFALSE 72008
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71893: LD_ADDR_VAR 0 3
71897: PUSH
71898: LD_EXP 31
71902: PUSH
71903: LD_VAR 0 2
71907: ARRAY
71908: PPUSH
71909: LD_INT 21
71911: PUSH
71912: LD_INT 3
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 3
71921: PUSH
71922: LD_INT 2
71924: PUSH
71925: LD_INT 30
71927: PUSH
71928: LD_INT 29
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: LD_INT 30
71937: PUSH
71938: LD_INT 30
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: LIST
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: PUSH
71954: LD_INT 3
71956: PUSH
71957: LD_INT 24
71959: PUSH
71960: LD_INT 1000
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PUSH
71971: EMPTY
71972: LIST
71973: LIST
71974: LIST
71975: PPUSH
71976: CALL_OW 72
71980: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
71981: LD_ADDR_EXP 32
71985: PUSH
71986: LD_EXP 32
71990: PPUSH
71991: LD_VAR 0 2
71995: PPUSH
71996: LD_VAR 0 3
72000: PPUSH
72001: CALL_OW 1
72005: ST_TO_ADDR
// end ;
72006: GO 71890
72008: POP
72009: POP
// RaiseSailEvent ( 101 ) ;
72010: LD_INT 101
72012: PPUSH
72013: CALL_OW 427
// end ;
72017: LD_VAR 0 1
72021: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
72022: LD_INT 0
72024: PPUSH
72025: PPUSH
72026: PPUSH
72027: PPUSH
72028: PPUSH
72029: PPUSH
72030: PPUSH
// if not mc_bases then
72031: LD_EXP 31
72035: NOT
72036: IFFALSE 72040
// exit ;
72038: GO 72604
// for i = 1 to mc_bases do
72040: LD_ADDR_VAR 0 2
72044: PUSH
72045: DOUBLE
72046: LD_INT 1
72048: DEC
72049: ST_TO_ADDR
72050: LD_EXP 31
72054: PUSH
72055: FOR_TO
72056: IFFALSE 72595
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
72058: LD_ADDR_VAR 0 5
72062: PUSH
72063: LD_EXP 31
72067: PUSH
72068: LD_VAR 0 2
72072: ARRAY
72073: PUSH
72074: LD_EXP 60
72078: PUSH
72079: LD_VAR 0 2
72083: ARRAY
72084: UNION
72085: PPUSH
72086: LD_INT 21
72088: PUSH
72089: LD_INT 1
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 1
72098: PUSH
72099: LD_INT 3
72101: PUSH
72102: LD_INT 54
72104: PUSH
72105: EMPTY
72106: LIST
72107: PUSH
72108: EMPTY
72109: LIST
72110: LIST
72111: PUSH
72112: LD_INT 3
72114: PUSH
72115: LD_INT 24
72117: PUSH
72118: LD_INT 1000
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PUSH
72129: EMPTY
72130: LIST
72131: LIST
72132: LIST
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PPUSH
72138: CALL_OW 72
72142: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
72143: LD_ADDR_VAR 0 6
72147: PUSH
72148: LD_EXP 31
72152: PUSH
72153: LD_VAR 0 2
72157: ARRAY
72158: PPUSH
72159: LD_INT 21
72161: PUSH
72162: LD_INT 1
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 1
72171: PUSH
72172: LD_INT 3
72174: PUSH
72175: LD_INT 54
72177: PUSH
72178: EMPTY
72179: LIST
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: PUSH
72185: LD_INT 3
72187: PUSH
72188: LD_INT 24
72190: PUSH
72191: LD_INT 250
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: LIST
72206: PUSH
72207: EMPTY
72208: LIST
72209: LIST
72210: PPUSH
72211: CALL_OW 72
72215: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
72216: LD_ADDR_VAR 0 7
72220: PUSH
72221: LD_VAR 0 5
72225: PUSH
72226: LD_VAR 0 6
72230: DIFF
72231: ST_TO_ADDR
// if not need_heal_1 then
72232: LD_VAR 0 6
72236: NOT
72237: IFFALSE 72270
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
72239: LD_ADDR_EXP 34
72243: PUSH
72244: LD_EXP 34
72248: PPUSH
72249: LD_VAR 0 2
72253: PUSH
72254: LD_INT 1
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PPUSH
72261: EMPTY
72262: PPUSH
72263: CALL 25063 0 3
72267: ST_TO_ADDR
72268: GO 72340
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
72270: LD_ADDR_EXP 34
72274: PUSH
72275: LD_EXP 34
72279: PPUSH
72280: LD_VAR 0 2
72284: PUSH
72285: LD_INT 1
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PPUSH
72292: LD_EXP 34
72296: PUSH
72297: LD_VAR 0 2
72301: ARRAY
72302: PUSH
72303: LD_INT 1
72305: ARRAY
72306: PPUSH
72307: LD_INT 3
72309: PUSH
72310: LD_INT 24
72312: PUSH
72313: LD_INT 1000
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PPUSH
72324: CALL_OW 72
72328: PUSH
72329: LD_VAR 0 6
72333: UNION
72334: PPUSH
72335: CALL 25063 0 3
72339: ST_TO_ADDR
// if not need_heal_2 then
72340: LD_VAR 0 7
72344: NOT
72345: IFFALSE 72378
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
72347: LD_ADDR_EXP 34
72351: PUSH
72352: LD_EXP 34
72356: PPUSH
72357: LD_VAR 0 2
72361: PUSH
72362: LD_INT 2
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PPUSH
72369: EMPTY
72370: PPUSH
72371: CALL 25063 0 3
72375: ST_TO_ADDR
72376: GO 72410
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
72378: LD_ADDR_EXP 34
72382: PUSH
72383: LD_EXP 34
72387: PPUSH
72388: LD_VAR 0 2
72392: PUSH
72393: LD_INT 2
72395: PUSH
72396: EMPTY
72397: LIST
72398: LIST
72399: PPUSH
72400: LD_VAR 0 7
72404: PPUSH
72405: CALL 25063 0 3
72409: ST_TO_ADDR
// if need_heal_2 then
72410: LD_VAR 0 7
72414: IFFALSE 72575
// for j in need_heal_2 do
72416: LD_ADDR_VAR 0 3
72420: PUSH
72421: LD_VAR 0 7
72425: PUSH
72426: FOR_IN
72427: IFFALSE 72573
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72429: LD_ADDR_VAR 0 5
72433: PUSH
72434: LD_EXP 31
72438: PUSH
72439: LD_VAR 0 2
72443: ARRAY
72444: PPUSH
72445: LD_INT 2
72447: PUSH
72448: LD_INT 30
72450: PUSH
72451: LD_INT 6
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PUSH
72458: LD_INT 30
72460: PUSH
72461: LD_INT 7
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: LD_INT 30
72470: PUSH
72471: LD_INT 8
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 30
72480: PUSH
72481: LD_INT 0
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 30
72490: PUSH
72491: LD_INT 1
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: PPUSH
72506: CALL_OW 72
72510: ST_TO_ADDR
// if tmp then
72511: LD_VAR 0 5
72515: IFFALSE 72571
// begin k := NearestUnitToUnit ( tmp , j ) ;
72517: LD_ADDR_VAR 0 4
72521: PUSH
72522: LD_VAR 0 5
72526: PPUSH
72527: LD_VAR 0 3
72531: PPUSH
72532: CALL_OW 74
72536: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
72537: LD_VAR 0 3
72541: PPUSH
72542: LD_VAR 0 4
72546: PPUSH
72547: CALL_OW 296
72551: PUSH
72552: LD_INT 5
72554: GREATER
72555: IFFALSE 72571
// ComMoveToNearbyEntrance ( j , k ) ;
72557: LD_VAR 0 3
72561: PPUSH
72562: LD_VAR 0 4
72566: PPUSH
72567: CALL 58990 0 2
// end ; end ;
72571: GO 72426
72573: POP
72574: POP
// if not need_heal_1 and not need_heal_2 then
72575: LD_VAR 0 6
72579: NOT
72580: IFFALSE 72589
72582: PUSH
72583: LD_VAR 0 7
72587: NOT
72588: AND
72589: IFFALSE 72593
// continue ;
72591: GO 72055
// end ;
72593: GO 72055
72595: POP
72596: POP
// RaiseSailEvent ( 102 ) ;
72597: LD_INT 102
72599: PPUSH
72600: CALL_OW 427
// end ;
72604: LD_VAR 0 1
72608: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
72609: LD_INT 0
72611: PPUSH
72612: PPUSH
72613: PPUSH
72614: PPUSH
72615: PPUSH
72616: PPUSH
72617: PPUSH
72618: PPUSH
// if not mc_bases then
72619: LD_EXP 31
72623: NOT
72624: IFFALSE 72628
// exit ;
72626: GO 73543
// for i = 1 to mc_bases do
72628: LD_ADDR_VAR 0 2
72632: PUSH
72633: DOUBLE
72634: LD_INT 1
72636: DEC
72637: ST_TO_ADDR
72638: LD_EXP 31
72642: PUSH
72643: FOR_TO
72644: IFFALSE 73541
// begin if not mc_building_need_repair [ i ] then
72646: LD_EXP 32
72650: PUSH
72651: LD_VAR 0 2
72655: ARRAY
72656: NOT
72657: IFFALSE 72842
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
72659: LD_ADDR_VAR 0 6
72663: PUSH
72664: LD_EXP 50
72668: PUSH
72669: LD_VAR 0 2
72673: ARRAY
72674: PPUSH
72675: LD_INT 3
72677: PUSH
72678: LD_INT 24
72680: PUSH
72681: LD_INT 1000
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 2
72694: PUSH
72695: LD_INT 34
72697: PUSH
72698: LD_INT 13
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 34
72707: PUSH
72708: LD_INT 52
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 34
72717: PUSH
72718: LD_INT 88
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PPUSH
72735: CALL_OW 72
72739: ST_TO_ADDR
// if cranes then
72740: LD_VAR 0 6
72744: IFFALSE 72806
// for j in cranes do
72746: LD_ADDR_VAR 0 3
72750: PUSH
72751: LD_VAR 0 6
72755: PUSH
72756: FOR_IN
72757: IFFALSE 72804
// if not IsInArea ( j , mc_parking [ i ] ) then
72759: LD_VAR 0 3
72763: PPUSH
72764: LD_EXP 55
72768: PUSH
72769: LD_VAR 0 2
72773: ARRAY
72774: PPUSH
72775: CALL_OW 308
72779: NOT
72780: IFFALSE 72802
// ComMoveToArea ( j , mc_parking [ i ] ) ;
72782: LD_VAR 0 3
72786: PPUSH
72787: LD_EXP 55
72791: PUSH
72792: LD_VAR 0 2
72796: ARRAY
72797: PPUSH
72798: CALL_OW 113
72802: GO 72756
72804: POP
72805: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
72806: LD_ADDR_EXP 33
72810: PUSH
72811: LD_EXP 33
72815: PPUSH
72816: LD_VAR 0 2
72820: PPUSH
72821: EMPTY
72822: PPUSH
72823: CALL_OW 1
72827: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
72828: LD_VAR 0 2
72832: PPUSH
72833: LD_INT 101
72835: PPUSH
72836: CALL 67634 0 2
// continue ;
72840: GO 72643
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
72842: LD_ADDR_EXP 37
72846: PUSH
72847: LD_EXP 37
72851: PPUSH
72852: LD_VAR 0 2
72856: PPUSH
72857: EMPTY
72858: PPUSH
72859: CALL_OW 1
72863: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
72864: LD_VAR 0 2
72868: PPUSH
72869: LD_INT 103
72871: PPUSH
72872: CALL 67634 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
72876: LD_ADDR_VAR 0 5
72880: PUSH
72881: LD_EXP 31
72885: PUSH
72886: LD_VAR 0 2
72890: ARRAY
72891: PUSH
72892: LD_EXP 60
72896: PUSH
72897: LD_VAR 0 2
72901: ARRAY
72902: UNION
72903: PPUSH
72904: LD_INT 2
72906: PUSH
72907: LD_INT 25
72909: PUSH
72910: LD_INT 2
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: PUSH
72917: LD_INT 25
72919: PUSH
72920: LD_INT 16
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: LIST
72931: PUSH
72932: EMPTY
72933: LIST
72934: PPUSH
72935: CALL_OW 72
72939: ST_TO_ADDR
// if mc_need_heal [ i ] then
72940: LD_EXP 34
72944: PUSH
72945: LD_VAR 0 2
72949: ARRAY
72950: IFFALSE 72994
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
72952: LD_ADDR_VAR 0 5
72956: PUSH
72957: LD_VAR 0 5
72961: PUSH
72962: LD_EXP 34
72966: PUSH
72967: LD_VAR 0 2
72971: ARRAY
72972: PUSH
72973: LD_INT 1
72975: ARRAY
72976: PUSH
72977: LD_EXP 34
72981: PUSH
72982: LD_VAR 0 2
72986: ARRAY
72987: PUSH
72988: LD_INT 2
72990: ARRAY
72991: UNION
72992: DIFF
72993: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
72994: LD_ADDR_VAR 0 6
72998: PUSH
72999: LD_EXP 50
73003: PUSH
73004: LD_VAR 0 2
73008: ARRAY
73009: PPUSH
73010: LD_INT 2
73012: PUSH
73013: LD_INT 34
73015: PUSH
73016: LD_INT 13
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 34
73025: PUSH
73026: LD_INT 52
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 34
73035: PUSH
73036: LD_INT 88
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: LIST
73047: LIST
73048: PPUSH
73049: CALL_OW 72
73053: ST_TO_ADDR
// if cranes then
73054: LD_VAR 0 6
73058: IFFALSE 73230
// begin for j in cranes do
73060: LD_ADDR_VAR 0 3
73064: PUSH
73065: LD_VAR 0 6
73069: PUSH
73070: FOR_IN
73071: IFFALSE 73228
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
73073: LD_VAR 0 3
73077: PPUSH
73078: CALL_OW 256
73082: PUSH
73083: LD_INT 1000
73085: EQUAL
73086: IFFALSE 73100
73088: PUSH
73089: LD_VAR 0 3
73093: PPUSH
73094: CALL_OW 314
73098: NOT
73099: AND
73100: IFFALSE 73166
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
73102: LD_ADDR_VAR 0 8
73106: PUSH
73107: LD_EXP 32
73111: PUSH
73112: LD_VAR 0 2
73116: ARRAY
73117: PPUSH
73118: LD_VAR 0 3
73122: PPUSH
73123: CALL_OW 74
73127: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
73128: LD_VAR 0 8
73132: PPUSH
73133: LD_INT 16
73135: PPUSH
73136: CALL 28042 0 2
73140: PUSH
73141: LD_INT 4
73143: ARRAY
73144: PUSH
73145: LD_INT 10
73147: LESS
73148: IFFALSE 73164
// ComRepairBuilding ( j , to_repair ) ;
73150: LD_VAR 0 3
73154: PPUSH
73155: LD_VAR 0 8
73159: PPUSH
73160: CALL_OW 130
// end else
73164: GO 73226
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
73166: LD_VAR 0 3
73170: PPUSH
73171: CALL_OW 256
73175: PUSH
73176: LD_INT 500
73178: LESS
73179: IFFALSE 73204
73181: PUSH
73182: LD_VAR 0 3
73186: PPUSH
73187: LD_EXP 55
73191: PUSH
73192: LD_VAR 0 2
73196: ARRAY
73197: PPUSH
73198: CALL_OW 308
73202: NOT
73203: AND
73204: IFFALSE 73226
// ComMoveToArea ( j , mc_parking [ i ] ) ;
73206: LD_VAR 0 3
73210: PPUSH
73211: LD_EXP 55
73215: PUSH
73216: LD_VAR 0 2
73220: ARRAY
73221: PPUSH
73222: CALL_OW 113
// end ;
73226: GO 73070
73228: POP
73229: POP
// end ; if tmp > 3 then
73230: LD_VAR 0 5
73234: PUSH
73235: LD_INT 3
73237: GREATER
73238: IFFALSE 73258
// tmp := ShrinkArray ( tmp , 4 ) ;
73240: LD_ADDR_VAR 0 5
73244: PUSH
73245: LD_VAR 0 5
73249: PPUSH
73250: LD_INT 4
73252: PPUSH
73253: CALL 58426 0 2
73257: ST_TO_ADDR
// if not tmp then
73258: LD_VAR 0 5
73262: NOT
73263: IFFALSE 73267
// continue ;
73265: GO 72643
// for j in tmp do
73267: LD_ADDR_VAR 0 3
73271: PUSH
73272: LD_VAR 0 5
73276: PUSH
73277: FOR_IN
73278: IFFALSE 73537
// begin if IsInUnit ( j ) then
73280: LD_VAR 0 3
73284: PPUSH
73285: CALL_OW 310
73289: IFFALSE 73300
// ComExitBuilding ( j ) ;
73291: LD_VAR 0 3
73295: PPUSH
73296: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
73300: LD_VAR 0 3
73304: PUSH
73305: LD_EXP 33
73309: PUSH
73310: LD_VAR 0 2
73314: ARRAY
73315: IN
73316: NOT
73317: IFFALSE 73375
// begin SetTag ( j , 101 ) ;
73319: LD_VAR 0 3
73323: PPUSH
73324: LD_INT 101
73326: PPUSH
73327: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
73331: LD_ADDR_EXP 33
73335: PUSH
73336: LD_EXP 33
73340: PPUSH
73341: LD_VAR 0 2
73345: PUSH
73346: LD_EXP 33
73350: PUSH
73351: LD_VAR 0 2
73355: ARRAY
73356: PUSH
73357: LD_INT 1
73359: PLUS
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: PPUSH
73365: LD_VAR 0 3
73369: PPUSH
73370: CALL 25063 0 3
73374: ST_TO_ADDR
// end ; wait ( 1 ) ;
73375: LD_INT 1
73377: PPUSH
73378: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
73382: LD_ADDR_VAR 0 7
73386: PUSH
73387: LD_EXP 32
73391: PUSH
73392: LD_VAR 0 2
73396: ARRAY
73397: ST_TO_ADDR
// if mc_scan [ i ] then
73398: LD_EXP 54
73402: PUSH
73403: LD_VAR 0 2
73407: ARRAY
73408: IFFALSE 73470
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
73410: LD_ADDR_VAR 0 7
73414: PUSH
73415: LD_EXP 32
73419: PUSH
73420: LD_VAR 0 2
73424: ARRAY
73425: PPUSH
73426: LD_INT 3
73428: PUSH
73429: LD_INT 30
73431: PUSH
73432: LD_INT 32
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 30
73441: PUSH
73442: LD_INT 33
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 30
73451: PUSH
73452: LD_INT 31
73454: PUSH
73455: EMPTY
73456: LIST
73457: LIST
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: LIST
73463: LIST
73464: PPUSH
73465: CALL_OW 72
73469: ST_TO_ADDR
// if not to_repair_tmp then
73470: LD_VAR 0 7
73474: NOT
73475: IFFALSE 73479
// continue ;
73477: GO 73277
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
73479: LD_ADDR_VAR 0 8
73483: PUSH
73484: LD_VAR 0 7
73488: PPUSH
73489: LD_VAR 0 3
73493: PPUSH
73494: CALL_OW 74
73498: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
73499: LD_VAR 0 8
73503: PPUSH
73504: LD_INT 16
73506: PPUSH
73507: CALL 28042 0 2
73511: PUSH
73512: LD_INT 4
73514: ARRAY
73515: PUSH
73516: LD_INT 14
73518: LESS
73519: IFFALSE 73535
// ComRepairBuilding ( j , to_repair ) ;
73521: LD_VAR 0 3
73525: PPUSH
73526: LD_VAR 0 8
73530: PPUSH
73531: CALL_OW 130
// end ;
73535: GO 73277
73537: POP
73538: POP
// end ;
73539: GO 72643
73541: POP
73542: POP
// end ;
73543: LD_VAR 0 1
73547: RET
// export function MC_Heal ; var i , j , tmp ; begin
73548: LD_INT 0
73550: PPUSH
73551: PPUSH
73552: PPUSH
73553: PPUSH
// if not mc_bases then
73554: LD_EXP 31
73558: NOT
73559: IFFALSE 73563
// exit ;
73561: GO 73969
// for i = 1 to mc_bases do
73563: LD_ADDR_VAR 0 2
73567: PUSH
73568: DOUBLE
73569: LD_INT 1
73571: DEC
73572: ST_TO_ADDR
73573: LD_EXP 31
73577: PUSH
73578: FOR_TO
73579: IFFALSE 73967
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
73581: LD_EXP 34
73585: PUSH
73586: LD_VAR 0 2
73590: ARRAY
73591: PUSH
73592: LD_INT 1
73594: ARRAY
73595: NOT
73596: IFFALSE 73615
73598: PUSH
73599: LD_EXP 34
73603: PUSH
73604: LD_VAR 0 2
73608: ARRAY
73609: PUSH
73610: LD_INT 2
73612: ARRAY
73613: NOT
73614: AND
73615: IFFALSE 73653
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
73617: LD_ADDR_EXP 35
73621: PUSH
73622: LD_EXP 35
73626: PPUSH
73627: LD_VAR 0 2
73631: PPUSH
73632: EMPTY
73633: PPUSH
73634: CALL_OW 1
73638: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
73639: LD_VAR 0 2
73643: PPUSH
73644: LD_INT 102
73646: PPUSH
73647: CALL 67634 0 2
// continue ;
73651: GO 73578
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73653: LD_ADDR_VAR 0 4
73657: PUSH
73658: LD_EXP 31
73662: PUSH
73663: LD_VAR 0 2
73667: ARRAY
73668: PPUSH
73669: LD_INT 25
73671: PUSH
73672: LD_INT 4
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PPUSH
73679: CALL_OW 72
73683: ST_TO_ADDR
// if not tmp then
73684: LD_VAR 0 4
73688: NOT
73689: IFFALSE 73693
// continue ;
73691: GO 73578
// if mc_taming [ i ] then
73693: LD_EXP 62
73697: PUSH
73698: LD_VAR 0 2
73702: ARRAY
73703: IFFALSE 73727
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73705: LD_ADDR_EXP 62
73709: PUSH
73710: LD_EXP 62
73714: PPUSH
73715: LD_VAR 0 2
73719: PPUSH
73720: EMPTY
73721: PPUSH
73722: CALL_OW 1
73726: ST_TO_ADDR
// for j in tmp do
73727: LD_ADDR_VAR 0 3
73731: PUSH
73732: LD_VAR 0 4
73736: PUSH
73737: FOR_IN
73738: IFFALSE 73963
// begin if IsInUnit ( j ) then
73740: LD_VAR 0 3
73744: PPUSH
73745: CALL_OW 310
73749: IFFALSE 73760
// ComExitBuilding ( j ) ;
73751: LD_VAR 0 3
73755: PPUSH
73756: CALL_OW 122
// if not j in mc_healers [ i ] then
73760: LD_VAR 0 3
73764: PUSH
73765: LD_EXP 35
73769: PUSH
73770: LD_VAR 0 2
73774: ARRAY
73775: IN
73776: NOT
73777: IFFALSE 73823
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
73779: LD_ADDR_EXP 35
73783: PUSH
73784: LD_EXP 35
73788: PPUSH
73789: LD_VAR 0 2
73793: PUSH
73794: LD_EXP 35
73798: PUSH
73799: LD_VAR 0 2
73803: ARRAY
73804: PUSH
73805: LD_INT 1
73807: PLUS
73808: PUSH
73809: EMPTY
73810: LIST
73811: LIST
73812: PPUSH
73813: LD_VAR 0 3
73817: PPUSH
73818: CALL 25063 0 3
73822: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
73823: LD_VAR 0 3
73827: PPUSH
73828: CALL_OW 110
73832: PUSH
73833: LD_INT 102
73835: NONEQUAL
73836: IFFALSE 73850
// SetTag ( j , 102 ) ;
73838: LD_VAR 0 3
73842: PPUSH
73843: LD_INT 102
73845: PPUSH
73846: CALL_OW 109
// Wait ( 3 ) ;
73850: LD_INT 3
73852: PPUSH
73853: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
73857: LD_EXP 34
73861: PUSH
73862: LD_VAR 0 2
73866: ARRAY
73867: PUSH
73868: LD_INT 1
73870: ARRAY
73871: IFFALSE 73903
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
73873: LD_VAR 0 3
73877: PPUSH
73878: LD_EXP 34
73882: PUSH
73883: LD_VAR 0 2
73887: ARRAY
73888: PUSH
73889: LD_INT 1
73891: ARRAY
73892: PUSH
73893: LD_INT 1
73895: ARRAY
73896: PPUSH
73897: CALL_OW 128
73901: GO 73961
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
73903: LD_VAR 0 3
73907: PPUSH
73908: CALL_OW 314
73912: NOT
73913: IFFALSE 73931
73915: PUSH
73916: LD_EXP 34
73920: PUSH
73921: LD_VAR 0 2
73925: ARRAY
73926: PUSH
73927: LD_INT 2
73929: ARRAY
73930: AND
73931: IFFALSE 73961
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
73933: LD_VAR 0 3
73937: PPUSH
73938: LD_EXP 34
73942: PUSH
73943: LD_VAR 0 2
73947: ARRAY
73948: PUSH
73949: LD_INT 2
73951: ARRAY
73952: PUSH
73953: LD_INT 1
73955: ARRAY
73956: PPUSH
73957: CALL_OW 128
// end ;
73961: GO 73737
73963: POP
73964: POP
// end ;
73965: GO 73578
73967: POP
73968: POP
// end ;
73969: LD_VAR 0 1
73973: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
73974: LD_INT 0
73976: PPUSH
73977: PPUSH
73978: PPUSH
73979: PPUSH
73980: PPUSH
73981: PPUSH
// if not mc_bases then
73982: LD_EXP 31
73986: NOT
73987: IFFALSE 73991
// exit ;
73989: GO 75162
// for i = 1 to mc_bases do
73991: LD_ADDR_VAR 0 2
73995: PUSH
73996: DOUBLE
73997: LD_INT 1
73999: DEC
74000: ST_TO_ADDR
74001: LD_EXP 31
74005: PUSH
74006: FOR_TO
74007: IFFALSE 75160
// begin if mc_scan [ i ] then
74009: LD_EXP 54
74013: PUSH
74014: LD_VAR 0 2
74018: ARRAY
74019: IFFALSE 74023
// continue ;
74021: GO 74006
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
74023: LD_EXP 36
74027: PUSH
74028: LD_VAR 0 2
74032: ARRAY
74033: NOT
74034: IFFALSE 74049
74036: PUSH
74037: LD_EXP 38
74041: PUSH
74042: LD_VAR 0 2
74046: ARRAY
74047: NOT
74048: AND
74049: IFFALSE 74063
74051: PUSH
74052: LD_EXP 37
74056: PUSH
74057: LD_VAR 0 2
74061: ARRAY
74062: AND
74063: IFFALSE 74101
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
74065: LD_ADDR_EXP 37
74069: PUSH
74070: LD_EXP 37
74074: PPUSH
74075: LD_VAR 0 2
74079: PPUSH
74080: EMPTY
74081: PPUSH
74082: CALL_OW 1
74086: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
74087: LD_VAR 0 2
74091: PPUSH
74092: LD_INT 103
74094: PPUSH
74095: CALL 67634 0 2
// continue ;
74099: GO 74006
// end ; if mc_construct_list [ i ] then
74101: LD_EXP 38
74105: PUSH
74106: LD_VAR 0 2
74110: ARRAY
74111: IFFALSE 74331
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
74113: LD_ADDR_VAR 0 5
74117: PUSH
74118: LD_EXP 31
74122: PUSH
74123: LD_VAR 0 2
74127: ARRAY
74128: PPUSH
74129: LD_INT 25
74131: PUSH
74132: LD_INT 2
74134: PUSH
74135: EMPTY
74136: LIST
74137: LIST
74138: PPUSH
74139: CALL_OW 72
74143: PUSH
74144: LD_EXP 33
74148: PUSH
74149: LD_VAR 0 2
74153: ARRAY
74154: DIFF
74155: ST_TO_ADDR
// if not tmp then
74156: LD_VAR 0 5
74160: NOT
74161: IFFALSE 74165
// continue ;
74163: GO 74006
// for j in tmp do
74165: LD_ADDR_VAR 0 3
74169: PUSH
74170: LD_VAR 0 5
74174: PUSH
74175: FOR_IN
74176: IFFALSE 74327
// begin if not mc_builders [ i ] then
74178: LD_EXP 37
74182: PUSH
74183: LD_VAR 0 2
74187: ARRAY
74188: NOT
74189: IFFALSE 74247
// begin SetTag ( j , 103 ) ;
74191: LD_VAR 0 3
74195: PPUSH
74196: LD_INT 103
74198: PPUSH
74199: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
74203: LD_ADDR_EXP 37
74207: PUSH
74208: LD_EXP 37
74212: PPUSH
74213: LD_VAR 0 2
74217: PUSH
74218: LD_EXP 37
74222: PUSH
74223: LD_VAR 0 2
74227: ARRAY
74228: PUSH
74229: LD_INT 1
74231: PLUS
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PPUSH
74237: LD_VAR 0 3
74241: PPUSH
74242: CALL 25063 0 3
74246: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
74247: LD_VAR 0 3
74251: PPUSH
74252: CALL_OW 310
74256: IFFALSE 74267
// ComExitBuilding ( j ) ;
74258: LD_VAR 0 3
74262: PPUSH
74263: CALL_OW 122
// wait ( 3 ) ;
74267: LD_INT 3
74269: PPUSH
74270: CALL_OW 67
// if not mc_construct_list [ i ] then
74274: LD_EXP 38
74278: PUSH
74279: LD_VAR 0 2
74283: ARRAY
74284: NOT
74285: IFFALSE 74289
// break ;
74287: GO 74327
// if not HasTask ( j ) then
74289: LD_VAR 0 3
74293: PPUSH
74294: CALL_OW 314
74298: NOT
74299: IFFALSE 74325
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
74301: LD_VAR 0 3
74305: PPUSH
74306: LD_EXP 38
74310: PUSH
74311: LD_VAR 0 2
74315: ARRAY
74316: PUSH
74317: LD_INT 1
74319: ARRAY
74320: PPUSH
74321: CALL 28315 0 2
// end ;
74325: GO 74175
74327: POP
74328: POP
// end else
74329: GO 75158
// if mc_build_list [ i ] then
74331: LD_EXP 36
74335: PUSH
74336: LD_VAR 0 2
74340: ARRAY
74341: IFFALSE 75158
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
74343: LD_EXP 36
74347: PUSH
74348: LD_VAR 0 2
74352: ARRAY
74353: PUSH
74354: LD_INT 1
74356: ARRAY
74357: PUSH
74358: LD_INT 1
74360: ARRAY
74361: PPUSH
74362: CALL 28139 0 1
74366: IFFALSE 74414
74368: PUSH
74369: LD_EXP 31
74373: PUSH
74374: LD_VAR 0 2
74378: ARRAY
74379: PPUSH
74380: LD_INT 2
74382: PUSH
74383: LD_INT 30
74385: PUSH
74386: LD_INT 2
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 30
74395: PUSH
74396: LD_INT 3
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: EMPTY
74404: LIST
74405: LIST
74406: LIST
74407: PPUSH
74408: CALL_OW 72
74412: NOT
74413: AND
74414: IFFALSE 74519
// begin for j = 1 to mc_build_list [ i ] do
74416: LD_ADDR_VAR 0 3
74420: PUSH
74421: DOUBLE
74422: LD_INT 1
74424: DEC
74425: ST_TO_ADDR
74426: LD_EXP 36
74430: PUSH
74431: LD_VAR 0 2
74435: ARRAY
74436: PUSH
74437: FOR_TO
74438: IFFALSE 74517
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
74440: LD_EXP 36
74444: PUSH
74445: LD_VAR 0 2
74449: ARRAY
74450: PUSH
74451: LD_VAR 0 3
74455: ARRAY
74456: PUSH
74457: LD_INT 1
74459: ARRAY
74460: PUSH
74461: LD_INT 2
74463: EQUAL
74464: IFFALSE 74515
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
74466: LD_ADDR_EXP 36
74470: PUSH
74471: LD_EXP 36
74475: PPUSH
74476: LD_VAR 0 2
74480: PPUSH
74481: LD_EXP 36
74485: PUSH
74486: LD_VAR 0 2
74490: ARRAY
74491: PPUSH
74492: LD_VAR 0 3
74496: PPUSH
74497: LD_INT 1
74499: PPUSH
74500: LD_INT 0
74502: PPUSH
74503: CALL 24471 0 4
74507: PPUSH
74508: CALL_OW 1
74512: ST_TO_ADDR
// break ;
74513: GO 74517
// end ;
74515: GO 74437
74517: POP
74518: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74519: LD_ADDR_VAR 0 6
74523: PUSH
74524: LD_EXP 31
74528: PUSH
74529: LD_VAR 0 2
74533: ARRAY
74534: PPUSH
74535: LD_INT 2
74537: PUSH
74538: LD_INT 30
74540: PUSH
74541: LD_INT 0
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 30
74550: PUSH
74551: LD_INT 1
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: LIST
74562: PPUSH
74563: CALL_OW 72
74567: ST_TO_ADDR
// for k := 1 to depot do
74568: LD_ADDR_VAR 0 4
74572: PUSH
74573: DOUBLE
74574: LD_INT 1
74576: DEC
74577: ST_TO_ADDR
74578: LD_VAR 0 6
74582: PUSH
74583: FOR_TO
74584: IFFALSE 75156
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
74586: LD_EXP 36
74590: PUSH
74591: LD_VAR 0 2
74595: ARRAY
74596: PUSH
74597: LD_INT 1
74599: ARRAY
74600: PUSH
74601: LD_INT 1
74603: ARRAY
74604: PUSH
74605: LD_INT 0
74607: EQUAL
74608: IFTRUE 74703
74610: PUSH
74611: LD_VAR 0 6
74615: PUSH
74616: LD_VAR 0 4
74620: ARRAY
74621: PPUSH
74622: LD_EXP 36
74626: PUSH
74627: LD_VAR 0 2
74631: ARRAY
74632: PUSH
74633: LD_INT 1
74635: ARRAY
74636: PUSH
74637: LD_INT 1
74639: ARRAY
74640: PPUSH
74641: LD_EXP 36
74645: PUSH
74646: LD_VAR 0 2
74650: ARRAY
74651: PUSH
74652: LD_INT 1
74654: ARRAY
74655: PUSH
74656: LD_INT 2
74658: ARRAY
74659: PPUSH
74660: LD_EXP 36
74664: PUSH
74665: LD_VAR 0 2
74669: ARRAY
74670: PUSH
74671: LD_INT 1
74673: ARRAY
74674: PUSH
74675: LD_INT 3
74677: ARRAY
74678: PPUSH
74679: LD_EXP 36
74683: PUSH
74684: LD_VAR 0 2
74688: ARRAY
74689: PUSH
74690: LD_INT 1
74692: ARRAY
74693: PUSH
74694: LD_INT 4
74696: ARRAY
74697: PPUSH
74698: CALL 33619 0 5
74702: OR
74703: IFFALSE 74984
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
74705: LD_ADDR_VAR 0 5
74709: PUSH
74710: LD_EXP 31
74714: PUSH
74715: LD_VAR 0 2
74719: ARRAY
74720: PPUSH
74721: LD_INT 25
74723: PUSH
74724: LD_INT 2
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PPUSH
74731: CALL_OW 72
74735: PUSH
74736: LD_EXP 33
74740: PUSH
74741: LD_VAR 0 2
74745: ARRAY
74746: DIFF
74747: ST_TO_ADDR
// if not tmp then
74748: LD_VAR 0 5
74752: NOT
74753: IFFALSE 74757
// continue ;
74755: GO 74583
// for j in tmp do
74757: LD_ADDR_VAR 0 3
74761: PUSH
74762: LD_VAR 0 5
74766: PUSH
74767: FOR_IN
74768: IFFALSE 74980
// begin if not mc_builders [ i ] then
74770: LD_EXP 37
74774: PUSH
74775: LD_VAR 0 2
74779: ARRAY
74780: NOT
74781: IFFALSE 74839
// begin SetTag ( j , 103 ) ;
74783: LD_VAR 0 3
74787: PPUSH
74788: LD_INT 103
74790: PPUSH
74791: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
74795: LD_ADDR_EXP 37
74799: PUSH
74800: LD_EXP 37
74804: PPUSH
74805: LD_VAR 0 2
74809: PUSH
74810: LD_EXP 37
74814: PUSH
74815: LD_VAR 0 2
74819: ARRAY
74820: PUSH
74821: LD_INT 1
74823: PLUS
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PPUSH
74829: LD_VAR 0 3
74833: PPUSH
74834: CALL 25063 0 3
74838: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
74839: LD_VAR 0 3
74843: PPUSH
74844: CALL_OW 310
74848: IFFALSE 74859
// ComExitBuilding ( j ) ;
74850: LD_VAR 0 3
74854: PPUSH
74855: CALL_OW 122
// wait ( 3 ) ;
74859: LD_INT 3
74861: PPUSH
74862: CALL_OW 67
// if not mc_build_list [ i ] then
74866: LD_EXP 36
74870: PUSH
74871: LD_VAR 0 2
74875: ARRAY
74876: NOT
74877: IFFALSE 74881
// break ;
74879: GO 74980
// if not HasTask ( j ) then
74881: LD_VAR 0 3
74885: PPUSH
74886: CALL_OW 314
74890: NOT
74891: IFFALSE 74978
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
74893: LD_VAR 0 3
74897: PPUSH
74898: LD_EXP 36
74902: PUSH
74903: LD_VAR 0 2
74907: ARRAY
74908: PUSH
74909: LD_INT 1
74911: ARRAY
74912: PUSH
74913: LD_INT 1
74915: ARRAY
74916: PPUSH
74917: LD_EXP 36
74921: PUSH
74922: LD_VAR 0 2
74926: ARRAY
74927: PUSH
74928: LD_INT 1
74930: ARRAY
74931: PUSH
74932: LD_INT 2
74934: ARRAY
74935: PPUSH
74936: LD_EXP 36
74940: PUSH
74941: LD_VAR 0 2
74945: ARRAY
74946: PUSH
74947: LD_INT 1
74949: ARRAY
74950: PUSH
74951: LD_INT 3
74953: ARRAY
74954: PPUSH
74955: LD_EXP 36
74959: PUSH
74960: LD_VAR 0 2
74964: ARRAY
74965: PUSH
74966: LD_INT 1
74968: ARRAY
74969: PUSH
74970: LD_INT 4
74972: ARRAY
74973: PPUSH
74974: CALL_OW 145
// end ;
74978: GO 74767
74980: POP
74981: POP
// end else
74982: GO 75154
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
74984: LD_EXP 31
74988: PUSH
74989: LD_VAR 0 2
74993: ARRAY
74994: PPUSH
74995: LD_EXP 36
74999: PUSH
75000: LD_VAR 0 2
75004: ARRAY
75005: PUSH
75006: LD_INT 1
75008: ARRAY
75009: PUSH
75010: LD_INT 1
75012: ARRAY
75013: PPUSH
75014: LD_EXP 36
75018: PUSH
75019: LD_VAR 0 2
75023: ARRAY
75024: PUSH
75025: LD_INT 1
75027: ARRAY
75028: PUSH
75029: LD_INT 2
75031: ARRAY
75032: PPUSH
75033: LD_EXP 36
75037: PUSH
75038: LD_VAR 0 2
75042: ARRAY
75043: PUSH
75044: LD_INT 1
75046: ARRAY
75047: PUSH
75048: LD_INT 3
75050: ARRAY
75051: PPUSH
75052: LD_EXP 36
75056: PUSH
75057: LD_VAR 0 2
75061: ARRAY
75062: PUSH
75063: LD_INT 1
75065: ARRAY
75066: PUSH
75067: LD_INT 4
75069: ARRAY
75070: PPUSH
75071: LD_EXP 31
75075: PUSH
75076: LD_VAR 0 2
75080: ARRAY
75081: PPUSH
75082: LD_INT 21
75084: PUSH
75085: LD_INT 3
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PPUSH
75092: CALL_OW 72
75096: PPUSH
75097: EMPTY
75098: PPUSH
75099: CALL 32355 0 7
75103: NOT
75104: IFFALSE 75154
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
75106: LD_ADDR_EXP 36
75110: PUSH
75111: LD_EXP 36
75115: PPUSH
75116: LD_VAR 0 2
75120: PPUSH
75121: LD_EXP 36
75125: PUSH
75126: LD_VAR 0 2
75130: ARRAY
75131: PPUSH
75132: LD_INT 1
75134: PPUSH
75135: LD_INT 1
75137: NEG
75138: PPUSH
75139: LD_INT 0
75141: PPUSH
75142: CALL 24471 0 4
75146: PPUSH
75147: CALL_OW 1
75151: ST_TO_ADDR
// continue ;
75152: GO 74583
// end ; end ;
75154: GO 74583
75156: POP
75157: POP
// end ; end ;
75158: GO 74006
75160: POP
75161: POP
// end ;
75162: LD_VAR 0 1
75166: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
75167: LD_INT 0
75169: PPUSH
75170: PPUSH
75171: PPUSH
75172: PPUSH
75173: PPUSH
75174: PPUSH
// if not mc_bases then
75175: LD_EXP 31
75179: NOT
75180: IFFALSE 75184
// exit ;
75182: GO 75617
// for i = 1 to mc_bases do
75184: LD_ADDR_VAR 0 2
75188: PUSH
75189: DOUBLE
75190: LD_INT 1
75192: DEC
75193: ST_TO_ADDR
75194: LD_EXP 31
75198: PUSH
75199: FOR_TO
75200: IFFALSE 75615
// begin tmp := mc_build_upgrade [ i ] ;
75202: LD_ADDR_VAR 0 4
75206: PUSH
75207: LD_EXP 63
75211: PUSH
75212: LD_VAR 0 2
75216: ARRAY
75217: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
75218: LD_ADDR_VAR 0 6
75222: PUSH
75223: LD_EXP 64
75227: PUSH
75228: LD_VAR 0 2
75232: ARRAY
75233: PPUSH
75234: LD_INT 2
75236: PUSH
75237: LD_INT 30
75239: PUSH
75240: LD_INT 6
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: LD_INT 30
75249: PUSH
75250: LD_INT 7
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: LIST
75261: PPUSH
75262: CALL_OW 72
75266: ST_TO_ADDR
// if not tmp and not lab then
75267: LD_VAR 0 4
75271: NOT
75272: IFFALSE 75281
75274: PUSH
75275: LD_VAR 0 6
75279: NOT
75280: AND
75281: IFFALSE 75285
// continue ;
75283: GO 75199
// if tmp then
75285: LD_VAR 0 4
75289: IFFALSE 75409
// for j in tmp do
75291: LD_ADDR_VAR 0 3
75295: PUSH
75296: LD_VAR 0 4
75300: PUSH
75301: FOR_IN
75302: IFFALSE 75407
// begin if UpgradeCost ( j ) then
75304: LD_VAR 0 3
75308: PPUSH
75309: CALL 32007 0 1
75313: IFFALSE 75405
// begin ComUpgrade ( j ) ;
75315: LD_VAR 0 3
75319: PPUSH
75320: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
75324: LD_ADDR_EXP 63
75328: PUSH
75329: LD_EXP 63
75333: PPUSH
75334: LD_VAR 0 2
75338: PPUSH
75339: LD_EXP 63
75343: PUSH
75344: LD_VAR 0 2
75348: ARRAY
75349: PUSH
75350: LD_VAR 0 3
75354: DIFF
75355: PPUSH
75356: CALL_OW 1
75360: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
75361: LD_ADDR_EXP 38
75365: PUSH
75366: LD_EXP 38
75370: PPUSH
75371: LD_VAR 0 2
75375: PUSH
75376: LD_EXP 38
75380: PUSH
75381: LD_VAR 0 2
75385: ARRAY
75386: PUSH
75387: LD_INT 1
75389: PLUS
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PPUSH
75395: LD_VAR 0 3
75399: PPUSH
75400: CALL 25063 0 3
75404: ST_TO_ADDR
// end ; end ;
75405: GO 75301
75407: POP
75408: POP
// if not lab or not mc_lab_upgrade [ i ] then
75409: LD_VAR 0 6
75413: NOT
75414: IFTRUE 75429
75416: PUSH
75417: LD_EXP 65
75421: PUSH
75422: LD_VAR 0 2
75426: ARRAY
75427: NOT
75428: OR
75429: IFFALSE 75433
// continue ;
75431: GO 75199
// for j in lab do
75433: LD_ADDR_VAR 0 3
75437: PUSH
75438: LD_VAR 0 6
75442: PUSH
75443: FOR_IN
75444: IFFALSE 75611
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
75446: LD_VAR 0 3
75450: PPUSH
75451: CALL_OW 266
75455: PUSH
75456: LD_INT 6
75458: PUSH
75459: LD_INT 7
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: IN
75466: IFFALSE 75483
75468: PUSH
75469: LD_VAR 0 3
75473: PPUSH
75474: CALL_OW 461
75478: PUSH
75479: LD_INT 1
75481: NONEQUAL
75482: AND
75483: IFFALSE 75609
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
75485: LD_VAR 0 3
75489: PPUSH
75490: LD_EXP 65
75494: PUSH
75495: LD_VAR 0 2
75499: ARRAY
75500: PUSH
75501: LD_INT 1
75503: ARRAY
75504: PPUSH
75505: CALL 32216 0 2
75509: IFFALSE 75609
// begin ComCancel ( j ) ;
75511: LD_VAR 0 3
75515: PPUSH
75516: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
75520: LD_VAR 0 3
75524: PPUSH
75525: LD_EXP 65
75529: PUSH
75530: LD_VAR 0 2
75534: ARRAY
75535: PUSH
75536: LD_INT 1
75538: ARRAY
75539: PPUSH
75540: CALL_OW 207
// if not j in mc_construct_list [ i ] then
75544: LD_VAR 0 3
75548: PUSH
75549: LD_EXP 38
75553: PUSH
75554: LD_VAR 0 2
75558: ARRAY
75559: IN
75560: NOT
75561: IFFALSE 75607
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
75563: LD_ADDR_EXP 38
75567: PUSH
75568: LD_EXP 38
75572: PPUSH
75573: LD_VAR 0 2
75577: PUSH
75578: LD_EXP 38
75582: PUSH
75583: LD_VAR 0 2
75587: ARRAY
75588: PUSH
75589: LD_INT 1
75591: PLUS
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PPUSH
75597: LD_VAR 0 3
75601: PPUSH
75602: CALL 25063 0 3
75606: ST_TO_ADDR
// break ;
75607: GO 75611
// end ; end ; end ;
75609: GO 75443
75611: POP
75612: POP
// end ;
75613: GO 75199
75615: POP
75616: POP
// end ;
75617: LD_VAR 0 1
75621: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
75622: LD_INT 0
75624: PPUSH
75625: PPUSH
75626: PPUSH
75627: PPUSH
75628: PPUSH
75629: PPUSH
75630: PPUSH
75631: PPUSH
75632: PPUSH
// if not mc_bases then
75633: LD_EXP 31
75637: NOT
75638: IFFALSE 75642
// exit ;
75640: GO 76049
// for i = 1 to mc_bases do
75642: LD_ADDR_VAR 0 2
75646: PUSH
75647: DOUBLE
75648: LD_INT 1
75650: DEC
75651: ST_TO_ADDR
75652: LD_EXP 31
75656: PUSH
75657: FOR_TO
75658: IFFALSE 76047
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
75660: LD_EXP 39
75664: PUSH
75665: LD_VAR 0 2
75669: ARRAY
75670: NOT
75671: IFTRUE 75701
75673: PUSH
75674: LD_EXP 31
75678: PUSH
75679: LD_VAR 0 2
75683: ARRAY
75684: PPUSH
75685: LD_INT 30
75687: PUSH
75688: LD_INT 3
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PPUSH
75695: CALL_OW 72
75699: NOT
75700: OR
75701: IFFALSE 75705
// continue ;
75703: GO 75657
// busy := false ;
75705: LD_ADDR_VAR 0 8
75709: PUSH
75710: LD_INT 0
75712: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75713: LD_ADDR_VAR 0 4
75717: PUSH
75718: LD_EXP 31
75722: PUSH
75723: LD_VAR 0 2
75727: ARRAY
75728: PPUSH
75729: LD_INT 30
75731: PUSH
75732: LD_INT 3
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PPUSH
75739: CALL_OW 72
75743: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
75744: LD_ADDR_VAR 0 6
75748: PUSH
75749: LD_EXP 39
75753: PUSH
75754: LD_VAR 0 2
75758: ARRAY
75759: PPUSH
75760: LD_INT 2
75762: PUSH
75763: LD_INT 30
75765: PUSH
75766: LD_INT 32
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: LD_INT 30
75775: PUSH
75776: LD_INT 33
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: LIST
75787: PPUSH
75788: CALL_OW 72
75792: ST_TO_ADDR
// if not t then
75793: LD_VAR 0 6
75797: NOT
75798: IFFALSE 75802
// continue ;
75800: GO 75657
// for j in tmp do
75802: LD_ADDR_VAR 0 3
75806: PUSH
75807: LD_VAR 0 4
75811: PUSH
75812: FOR_IN
75813: IFFALSE 75843
// if not BuildingStatus ( j ) = bs_idle then
75815: LD_VAR 0 3
75819: PPUSH
75820: CALL_OW 461
75824: PUSH
75825: LD_INT 2
75827: EQUAL
75828: NOT
75829: IFFALSE 75841
// begin busy := true ;
75831: LD_ADDR_VAR 0 8
75835: PUSH
75836: LD_INT 1
75838: ST_TO_ADDR
// break ;
75839: GO 75843
// end ;
75841: GO 75812
75843: POP
75844: POP
// if busy then
75845: LD_VAR 0 8
75849: IFFALSE 75853
// continue ;
75851: GO 75657
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
75853: LD_ADDR_VAR 0 7
75857: PUSH
75858: LD_VAR 0 6
75862: PPUSH
75863: LD_INT 35
75865: PUSH
75866: LD_INT 0
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PPUSH
75873: CALL_OW 72
75877: ST_TO_ADDR
// if tw then
75878: LD_VAR 0 7
75882: IFFALSE 75959
// begin tw := tw [ 1 ] ;
75884: LD_ADDR_VAR 0 7
75888: PUSH
75889: LD_VAR 0 7
75893: PUSH
75894: LD_INT 1
75896: ARRAY
75897: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
75898: LD_ADDR_VAR 0 9
75902: PUSH
75903: LD_VAR 0 7
75907: PPUSH
75908: LD_EXP 56
75912: PUSH
75913: LD_VAR 0 2
75917: ARRAY
75918: PPUSH
75919: CALL 30470 0 2
75923: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
75924: LD_EXP 70
75928: PUSH
75929: LD_VAR 0 2
75933: ARRAY
75934: IFFALSE 75957
// if not weapon in mc_allowed_tower_weapons [ i ] then
75936: LD_VAR 0 9
75940: PUSH
75941: LD_EXP 70
75945: PUSH
75946: LD_VAR 0 2
75950: ARRAY
75951: IN
75952: NOT
75953: IFFALSE 75957
// continue ;
75955: GO 75657
// end else
75957: GO 76022
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
75959: LD_ADDR_VAR 0 5
75963: PUSH
75964: LD_EXP 39
75968: PUSH
75969: LD_VAR 0 2
75973: ARRAY
75974: PPUSH
75975: LD_VAR 0 4
75979: PPUSH
75980: CALL 57655 0 2
75984: ST_TO_ADDR
// if not tmp2 then
75985: LD_VAR 0 5
75989: NOT
75990: IFFALSE 75994
// continue ;
75992: GO 75657
// tw := tmp2 [ 1 ] ;
75994: LD_ADDR_VAR 0 7
75998: PUSH
75999: LD_VAR 0 5
76003: PUSH
76004: LD_INT 1
76006: ARRAY
76007: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
76008: LD_ADDR_VAR 0 9
76012: PUSH
76013: LD_VAR 0 5
76017: PUSH
76018: LD_INT 2
76020: ARRAY
76021: ST_TO_ADDR
// end ; if not weapon then
76022: LD_VAR 0 9
76026: NOT
76027: IFFALSE 76031
// continue ;
76029: GO 75657
// ComPlaceWeapon ( tw , weapon ) ;
76031: LD_VAR 0 7
76035: PPUSH
76036: LD_VAR 0 9
76040: PPUSH
76041: CALL_OW 148
// end ;
76045: GO 75657
76047: POP
76048: POP
// end ;
76049: LD_VAR 0 1
76053: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
76054: LD_INT 0
76056: PPUSH
76057: PPUSH
76058: PPUSH
76059: PPUSH
76060: PPUSH
76061: PPUSH
76062: PPUSH
// if not mc_bases then
76063: LD_EXP 31
76067: NOT
76068: IFFALSE 76072
// exit ;
76070: GO 76859
// for i = 1 to mc_bases do
76072: LD_ADDR_VAR 0 2
76076: PUSH
76077: DOUBLE
76078: LD_INT 1
76080: DEC
76081: ST_TO_ADDR
76082: LD_EXP 31
76086: PUSH
76087: FOR_TO
76088: IFFALSE 76857
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
76090: LD_EXP 44
76094: PUSH
76095: LD_VAR 0 2
76099: ARRAY
76100: NOT
76101: IFTRUE 76127
76103: PUSH
76104: LD_EXP 44
76108: PUSH
76109: LD_VAR 0 2
76113: ARRAY
76114: PUSH
76115: LD_EXP 45
76119: PUSH
76120: LD_VAR 0 2
76124: ARRAY
76125: EQUAL
76126: OR
76127: IFTRUE 76141
76129: PUSH
76130: LD_EXP 54
76134: PUSH
76135: LD_VAR 0 2
76139: ARRAY
76140: OR
76141: IFFALSE 76145
// continue ;
76143: GO 76087
// if mc_miners [ i ] then
76145: LD_EXP 45
76149: PUSH
76150: LD_VAR 0 2
76154: ARRAY
76155: IFFALSE 76542
// begin for j = mc_miners [ i ] downto 1 do
76157: LD_ADDR_VAR 0 3
76161: PUSH
76162: DOUBLE
76163: LD_EXP 45
76167: PUSH
76168: LD_VAR 0 2
76172: ARRAY
76173: INC
76174: ST_TO_ADDR
76175: LD_INT 1
76177: PUSH
76178: FOR_DOWNTO
76179: IFFALSE 76540
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
76181: LD_EXP 45
76185: PUSH
76186: LD_VAR 0 2
76190: ARRAY
76191: PUSH
76192: LD_VAR 0 3
76196: ARRAY
76197: PPUSH
76198: CALL_OW 301
76202: IFTRUE 76231
76204: PUSH
76205: LD_EXP 45
76209: PUSH
76210: LD_VAR 0 2
76214: ARRAY
76215: PUSH
76216: LD_VAR 0 3
76220: ARRAY
76221: PPUSH
76222: CALL_OW 257
76226: PUSH
76227: LD_INT 1
76229: NONEQUAL
76230: OR
76231: IFFALSE 76294
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
76233: LD_ADDR_VAR 0 5
76237: PUSH
76238: LD_EXP 45
76242: PUSH
76243: LD_VAR 0 2
76247: ARRAY
76248: PUSH
76249: LD_EXP 45
76253: PUSH
76254: LD_VAR 0 2
76258: ARRAY
76259: PUSH
76260: LD_VAR 0 3
76264: ARRAY
76265: DIFF
76266: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
76267: LD_ADDR_EXP 45
76271: PUSH
76272: LD_EXP 45
76276: PPUSH
76277: LD_VAR 0 2
76281: PPUSH
76282: LD_VAR 0 5
76286: PPUSH
76287: CALL_OW 1
76291: ST_TO_ADDR
// continue ;
76292: GO 76178
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
76294: LD_EXP 45
76298: PUSH
76299: LD_VAR 0 2
76303: ARRAY
76304: PUSH
76305: LD_VAR 0 3
76309: ARRAY
76310: PPUSH
76311: CALL_OW 257
76315: PUSH
76316: LD_INT 1
76318: EQUAL
76319: IFFALSE 76345
76321: PUSH
76322: LD_EXP 45
76326: PUSH
76327: LD_VAR 0 2
76331: ARRAY
76332: PUSH
76333: LD_VAR 0 3
76337: ARRAY
76338: PPUSH
76339: CALL_OW 459
76343: NOT
76344: AND
76345: IFFALSE 76371
76347: PUSH
76348: LD_EXP 45
76352: PUSH
76353: LD_VAR 0 2
76357: ARRAY
76358: PUSH
76359: LD_VAR 0 3
76363: ARRAY
76364: PPUSH
76365: CALL_OW 314
76369: NOT
76370: AND
76371: IFFALSE 76538
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
76373: LD_EXP 45
76377: PUSH
76378: LD_VAR 0 2
76382: ARRAY
76383: PUSH
76384: LD_VAR 0 3
76388: ARRAY
76389: PPUSH
76390: CALL_OW 310
76394: IFFALSE 76417
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
76396: LD_EXP 45
76400: PUSH
76401: LD_VAR 0 2
76405: ARRAY
76406: PUSH
76407: LD_VAR 0 3
76411: ARRAY
76412: PPUSH
76413: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
76417: LD_EXP 45
76421: PUSH
76422: LD_VAR 0 2
76426: ARRAY
76427: PUSH
76428: LD_VAR 0 3
76432: ARRAY
76433: PPUSH
76434: CALL_OW 314
76438: NOT
76439: IFFALSE 76538
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
76441: LD_ADDR_VAR 0 7
76445: PUSH
76446: LD_VAR 0 3
76450: PUSH
76451: LD_EXP 44
76455: PUSH
76456: LD_VAR 0 2
76460: ARRAY
76461: PPUSH
76462: CALL 22179 0 1
76466: MOD
76467: PUSH
76468: LD_INT 1
76470: PLUS
76471: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
76472: LD_EXP 45
76476: PUSH
76477: LD_VAR 0 2
76481: ARRAY
76482: PUSH
76483: LD_VAR 0 3
76487: ARRAY
76488: PPUSH
76489: LD_EXP 44
76493: PUSH
76494: LD_VAR 0 2
76498: ARRAY
76499: PUSH
76500: LD_VAR 0 7
76504: ARRAY
76505: PUSH
76506: LD_INT 1
76508: ARRAY
76509: PPUSH
76510: LD_EXP 44
76514: PUSH
76515: LD_VAR 0 2
76519: ARRAY
76520: PUSH
76521: LD_VAR 0 7
76525: ARRAY
76526: PUSH
76527: LD_INT 2
76529: ARRAY
76530: PPUSH
76531: LD_INT 0
76533: PPUSH
76534: CALL_OW 193
// end ; end ; end ;
76538: GO 76178
76540: POP
76541: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
76542: LD_ADDR_VAR 0 5
76546: PUSH
76547: LD_EXP 31
76551: PUSH
76552: LD_VAR 0 2
76556: ARRAY
76557: PPUSH
76558: LD_INT 2
76560: PUSH
76561: LD_INT 30
76563: PUSH
76564: LD_INT 4
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: PUSH
76571: LD_INT 30
76573: PUSH
76574: LD_INT 5
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: LD_INT 30
76583: PUSH
76584: LD_INT 32
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: PPUSH
76597: CALL_OW 72
76601: ST_TO_ADDR
// if not tmp then
76602: LD_VAR 0 5
76606: NOT
76607: IFFALSE 76611
// continue ;
76609: GO 76087
// list := [ ] ;
76611: LD_ADDR_VAR 0 6
76615: PUSH
76616: EMPTY
76617: ST_TO_ADDR
// for j in tmp do
76618: LD_ADDR_VAR 0 3
76622: PUSH
76623: LD_VAR 0 5
76627: PUSH
76628: FOR_IN
76629: IFFALSE 76700
// begin for k in UnitsInside ( j ) do
76631: LD_ADDR_VAR 0 4
76635: PUSH
76636: LD_VAR 0 3
76640: PPUSH
76641: CALL_OW 313
76645: PUSH
76646: FOR_IN
76647: IFFALSE 76696
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
76649: LD_VAR 0 4
76653: PPUSH
76654: CALL_OW 257
76658: PUSH
76659: LD_INT 1
76661: EQUAL
76662: IFFALSE 76676
76664: PUSH
76665: LD_VAR 0 4
76669: PPUSH
76670: CALL_OW 459
76674: NOT
76675: AND
76676: IFFALSE 76694
// list := list ^ k ;
76678: LD_ADDR_VAR 0 6
76682: PUSH
76683: LD_VAR 0 6
76687: PUSH
76688: LD_VAR 0 4
76692: ADD
76693: ST_TO_ADDR
76694: GO 76646
76696: POP
76697: POP
// end ;
76698: GO 76628
76700: POP
76701: POP
// list := list diff mc_miners [ i ] ;
76702: LD_ADDR_VAR 0 6
76706: PUSH
76707: LD_VAR 0 6
76711: PUSH
76712: LD_EXP 45
76716: PUSH
76717: LD_VAR 0 2
76721: ARRAY
76722: DIFF
76723: ST_TO_ADDR
// if not list then
76724: LD_VAR 0 6
76728: NOT
76729: IFFALSE 76733
// continue ;
76731: GO 76087
// k := mc_mines [ i ] - mc_miners [ i ] ;
76733: LD_ADDR_VAR 0 4
76737: PUSH
76738: LD_EXP 44
76742: PUSH
76743: LD_VAR 0 2
76747: ARRAY
76748: PUSH
76749: LD_EXP 45
76753: PUSH
76754: LD_VAR 0 2
76758: ARRAY
76759: MINUS
76760: ST_TO_ADDR
// if k > list then
76761: LD_VAR 0 4
76765: PUSH
76766: LD_VAR 0 6
76770: GREATER
76771: IFFALSE 76783
// k := list ;
76773: LD_ADDR_VAR 0 4
76777: PUSH
76778: LD_VAR 0 6
76782: ST_TO_ADDR
// for j = 1 to k do
76783: LD_ADDR_VAR 0 3
76787: PUSH
76788: DOUBLE
76789: LD_INT 1
76791: DEC
76792: ST_TO_ADDR
76793: LD_VAR 0 4
76797: PUSH
76798: FOR_TO
76799: IFFALSE 76853
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
76801: LD_ADDR_EXP 45
76805: PUSH
76806: LD_EXP 45
76810: PPUSH
76811: LD_VAR 0 2
76815: PUSH
76816: LD_EXP 45
76820: PUSH
76821: LD_VAR 0 2
76825: ARRAY
76826: PUSH
76827: LD_INT 1
76829: PLUS
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PPUSH
76835: LD_VAR 0 6
76839: PUSH
76840: LD_VAR 0 3
76844: ARRAY
76845: PPUSH
76846: CALL 25063 0 3
76850: ST_TO_ADDR
76851: GO 76798
76853: POP
76854: POP
// end ;
76855: GO 76087
76857: POP
76858: POP
// end ;
76859: LD_VAR 0 1
76863: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
76864: LD_INT 0
76866: PPUSH
76867: PPUSH
76868: PPUSH
76869: PPUSH
76870: PPUSH
76871: PPUSH
76872: PPUSH
76873: PPUSH
76874: PPUSH
76875: PPUSH
76876: PPUSH
// if not mc_bases then
76877: LD_EXP 31
76881: NOT
76882: IFFALSE 76886
// exit ;
76884: GO 78733
// for i = 1 to mc_bases do
76886: LD_ADDR_VAR 0 2
76890: PUSH
76891: DOUBLE
76892: LD_INT 1
76894: DEC
76895: ST_TO_ADDR
76896: LD_EXP 31
76900: PUSH
76901: FOR_TO
76902: IFFALSE 78731
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
76904: LD_EXP 31
76908: PUSH
76909: LD_VAR 0 2
76913: ARRAY
76914: NOT
76915: IFTRUE 76929
76917: PUSH
76918: LD_EXP 38
76922: PUSH
76923: LD_VAR 0 2
76927: ARRAY
76928: OR
76929: IFFALSE 76933
// continue ;
76931: GO 76901
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
76933: LD_EXP 47
76937: PUSH
76938: LD_VAR 0 2
76942: ARRAY
76943: NOT
76944: IFFALSE 76958
76946: PUSH
76947: LD_EXP 48
76951: PUSH
76952: LD_VAR 0 2
76956: ARRAY
76957: AND
76958: IFFALSE 76996
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
76960: LD_ADDR_EXP 48
76964: PUSH
76965: LD_EXP 48
76969: PPUSH
76970: LD_VAR 0 2
76974: PPUSH
76975: EMPTY
76976: PPUSH
76977: CALL_OW 1
76981: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
76982: LD_VAR 0 2
76986: PPUSH
76987: LD_INT 107
76989: PPUSH
76990: CALL 67634 0 2
// continue ;
76994: GO 76901
// end ; target := [ ] ;
76996: LD_ADDR_VAR 0 7
77000: PUSH
77001: EMPTY
77002: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
77003: LD_ADDR_VAR 0 6
77007: PUSH
77008: LD_EXP 31
77012: PUSH
77013: LD_VAR 0 2
77017: ARRAY
77018: PUSH
77019: LD_INT 1
77021: ARRAY
77022: PPUSH
77023: CALL_OW 255
77027: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77028: LD_ADDR_VAR 0 9
77032: PUSH
77033: LD_EXP 31
77037: PUSH
77038: LD_VAR 0 2
77042: ARRAY
77043: PPUSH
77044: LD_INT 2
77046: PUSH
77047: LD_INT 30
77049: PUSH
77050: LD_INT 0
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: PUSH
77057: LD_INT 30
77059: PUSH
77060: LD_INT 1
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: LIST
77071: PPUSH
77072: CALL_OW 72
77076: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
77077: LD_ADDR_VAR 0 3
77081: PUSH
77082: DOUBLE
77083: LD_EXP 47
77087: PUSH
77088: LD_VAR 0 2
77092: ARRAY
77093: INC
77094: ST_TO_ADDR
77095: LD_INT 1
77097: PUSH
77098: FOR_DOWNTO
77099: IFFALSE 77346
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
77101: LD_EXP 47
77105: PUSH
77106: LD_VAR 0 2
77110: ARRAY
77111: PUSH
77112: LD_VAR 0 3
77116: ARRAY
77117: PUSH
77118: LD_INT 2
77120: ARRAY
77121: PPUSH
77122: LD_EXP 47
77126: PUSH
77127: LD_VAR 0 2
77131: ARRAY
77132: PUSH
77133: LD_VAR 0 3
77137: ARRAY
77138: PUSH
77139: LD_INT 3
77141: ARRAY
77142: PPUSH
77143: CALL_OW 488
77147: IFFALSE 77201
77149: PUSH
77150: LD_EXP 47
77154: PUSH
77155: LD_VAR 0 2
77159: ARRAY
77160: PUSH
77161: LD_VAR 0 3
77165: ARRAY
77166: PUSH
77167: LD_INT 2
77169: ARRAY
77170: PPUSH
77171: LD_EXP 47
77175: PUSH
77176: LD_VAR 0 2
77180: ARRAY
77181: PUSH
77182: LD_VAR 0 3
77186: ARRAY
77187: PUSH
77188: LD_INT 3
77190: ARRAY
77191: PPUSH
77192: CALL_OW 284
77196: PUSH
77197: LD_INT 0
77199: EQUAL
77200: AND
77201: IFFALSE 77256
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
77203: LD_ADDR_VAR 0 5
77207: PUSH
77208: LD_EXP 47
77212: PUSH
77213: LD_VAR 0 2
77217: ARRAY
77218: PPUSH
77219: LD_VAR 0 3
77223: PPUSH
77224: CALL_OW 3
77228: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
77229: LD_ADDR_EXP 47
77233: PUSH
77234: LD_EXP 47
77238: PPUSH
77239: LD_VAR 0 2
77243: PPUSH
77244: LD_VAR 0 5
77248: PPUSH
77249: CALL_OW 1
77253: ST_TO_ADDR
// continue ;
77254: GO 77098
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
77256: LD_VAR 0 6
77260: PPUSH
77261: LD_EXP 47
77265: PUSH
77266: LD_VAR 0 2
77270: ARRAY
77271: PUSH
77272: LD_VAR 0 3
77276: ARRAY
77277: PUSH
77278: LD_INT 2
77280: ARRAY
77281: PPUSH
77282: LD_EXP 47
77286: PUSH
77287: LD_VAR 0 2
77291: ARRAY
77292: PUSH
77293: LD_VAR 0 3
77297: ARRAY
77298: PUSH
77299: LD_INT 3
77301: ARRAY
77302: PPUSH
77303: LD_INT 30
77305: PPUSH
77306: CALL 26333 0 4
77310: PUSH
77311: LD_INT 4
77313: ARRAY
77314: PUSH
77315: LD_INT 0
77317: EQUAL
77318: IFFALSE 77344
// begin target := mc_crates [ i ] [ j ] ;
77320: LD_ADDR_VAR 0 7
77324: PUSH
77325: LD_EXP 47
77329: PUSH
77330: LD_VAR 0 2
77334: ARRAY
77335: PUSH
77336: LD_VAR 0 3
77340: ARRAY
77341: ST_TO_ADDR
// break ;
77342: GO 77346
// end ; end ;
77344: GO 77098
77346: POP
77347: POP
// if not target then
77348: LD_VAR 0 7
77352: NOT
77353: IFFALSE 77357
// continue ;
77355: GO 76901
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
77357: LD_ADDR_VAR 0 8
77361: PUSH
77362: LD_EXP 50
77366: PUSH
77367: LD_VAR 0 2
77371: ARRAY
77372: PPUSH
77373: LD_INT 2
77375: PUSH
77376: LD_INT 3
77378: PUSH
77379: LD_INT 58
77381: PUSH
77382: EMPTY
77383: LIST
77384: PUSH
77385: EMPTY
77386: LIST
77387: LIST
77388: PUSH
77389: LD_INT 61
77391: PUSH
77392: EMPTY
77393: LIST
77394: PUSH
77395: LD_INT 33
77397: PUSH
77398: LD_INT 5
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 33
77407: PUSH
77408: LD_INT 3
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PUSH
77415: EMPTY
77416: LIST
77417: LIST
77418: LIST
77419: LIST
77420: LIST
77421: PUSH
77422: LD_INT 2
77424: PUSH
77425: LD_INT 34
77427: PUSH
77428: LD_INT 32
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 34
77437: PUSH
77438: LD_INT 51
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: PUSH
77445: LD_INT 34
77447: PUSH
77448: LD_INT 12
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: PUSH
77461: EMPTY
77462: LIST
77463: LIST
77464: PPUSH
77465: CALL_OW 72
77469: ST_TO_ADDR
// if not cargo then
77470: LD_VAR 0 8
77474: NOT
77475: IFFALSE 78189
// begin if mc_crates_collector [ i ] < 5 then
77477: LD_EXP 48
77481: PUSH
77482: LD_VAR 0 2
77486: ARRAY
77487: PUSH
77488: LD_INT 5
77490: LESS
77491: IFFALSE 77861
// begin if mc_ape [ i ] then
77493: LD_EXP 60
77497: PUSH
77498: LD_VAR 0 2
77502: ARRAY
77503: IFFALSE 77550
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
77505: LD_ADDR_VAR 0 5
77509: PUSH
77510: LD_EXP 60
77514: PUSH
77515: LD_VAR 0 2
77519: ARRAY
77520: PPUSH
77521: LD_INT 25
77523: PUSH
77524: LD_INT 16
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 24
77533: PUSH
77534: LD_INT 750
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PPUSH
77545: CALL_OW 72
77549: ST_TO_ADDR
// if not tmp then
77550: LD_VAR 0 5
77554: NOT
77555: IFFALSE 77602
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
77557: LD_ADDR_VAR 0 5
77561: PUSH
77562: LD_EXP 31
77566: PUSH
77567: LD_VAR 0 2
77571: ARRAY
77572: PPUSH
77573: LD_INT 25
77575: PUSH
77576: LD_INT 2
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PUSH
77583: LD_INT 24
77585: PUSH
77586: LD_INT 750
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PPUSH
77597: CALL_OW 72
77601: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
77602: LD_EXP 60
77606: PUSH
77607: LD_VAR 0 2
77611: ARRAY
77612: IFFALSE 77655
77614: PUSH
77615: LD_EXP 31
77619: PUSH
77620: LD_VAR 0 2
77624: ARRAY
77625: PPUSH
77626: LD_INT 25
77628: PUSH
77629: LD_INT 2
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PUSH
77636: LD_INT 24
77638: PUSH
77639: LD_INT 750
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PPUSH
77650: CALL_OW 72
77654: AND
77655: IFFALSE 77667
77657: PUSH
77658: LD_VAR 0 5
77662: PUSH
77663: LD_INT 5
77665: LESS
77666: AND
77667: IFFALSE 77749
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
77669: LD_ADDR_VAR 0 3
77673: PUSH
77674: LD_EXP 31
77678: PUSH
77679: LD_VAR 0 2
77683: ARRAY
77684: PPUSH
77685: LD_INT 25
77687: PUSH
77688: LD_INT 2
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: LD_INT 24
77697: PUSH
77698: LD_INT 750
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PPUSH
77709: CALL_OW 72
77713: PUSH
77714: FOR_IN
77715: IFFALSE 77747
// begin tmp := tmp union j ;
77717: LD_ADDR_VAR 0 5
77721: PUSH
77722: LD_VAR 0 5
77726: PUSH
77727: LD_VAR 0 3
77731: UNION
77732: ST_TO_ADDR
// if tmp >= 5 then
77733: LD_VAR 0 5
77737: PUSH
77738: LD_INT 5
77740: GREATEREQUAL
77741: IFFALSE 77745
// break ;
77743: GO 77747
// end ;
77745: GO 77714
77747: POP
77748: POP
// end ; if not tmp then
77749: LD_VAR 0 5
77753: NOT
77754: IFFALSE 77758
// continue ;
77756: GO 76901
// for j in tmp do
77758: LD_ADDR_VAR 0 3
77762: PUSH
77763: LD_VAR 0 5
77767: PUSH
77768: FOR_IN
77769: IFFALSE 77859
// if not GetTag ( j ) then
77771: LD_VAR 0 3
77775: PPUSH
77776: CALL_OW 110
77780: NOT
77781: IFFALSE 77857
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
77783: LD_ADDR_EXP 48
77787: PUSH
77788: LD_EXP 48
77792: PPUSH
77793: LD_VAR 0 2
77797: PUSH
77798: LD_EXP 48
77802: PUSH
77803: LD_VAR 0 2
77807: ARRAY
77808: PUSH
77809: LD_INT 1
77811: PLUS
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PPUSH
77817: LD_VAR 0 3
77821: PPUSH
77822: CALL 25063 0 3
77826: ST_TO_ADDR
// SetTag ( j , 107 ) ;
77827: LD_VAR 0 3
77831: PPUSH
77832: LD_INT 107
77834: PPUSH
77835: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
77839: LD_EXP 48
77843: PUSH
77844: LD_VAR 0 2
77848: ARRAY
77849: PUSH
77850: LD_INT 5
77852: GREATEREQUAL
77853: IFFALSE 77857
// break ;
77855: GO 77859
// end ;
77857: GO 77768
77859: POP
77860: POP
// end ; if mc_crates_collector [ i ] and target then
77861: LD_EXP 48
77865: PUSH
77866: LD_VAR 0 2
77870: ARRAY
77871: IFFALSE 77879
77873: PUSH
77874: LD_VAR 0 7
77878: AND
77879: IFFALSE 78187
// begin if mc_crates_collector [ i ] < target [ 1 ] then
77881: LD_EXP 48
77885: PUSH
77886: LD_VAR 0 2
77890: ARRAY
77891: PUSH
77892: LD_VAR 0 7
77896: PUSH
77897: LD_INT 1
77899: ARRAY
77900: LESS
77901: IFFALSE 77921
// tmp := mc_crates_collector [ i ] else
77903: LD_ADDR_VAR 0 5
77907: PUSH
77908: LD_EXP 48
77912: PUSH
77913: LD_VAR 0 2
77917: ARRAY
77918: ST_TO_ADDR
77919: GO 77935
// tmp := target [ 1 ] ;
77921: LD_ADDR_VAR 0 5
77925: PUSH
77926: LD_VAR 0 7
77930: PUSH
77931: LD_INT 1
77933: ARRAY
77934: ST_TO_ADDR
// k := 0 ;
77935: LD_ADDR_VAR 0 4
77939: PUSH
77940: LD_INT 0
77942: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
77943: LD_ADDR_VAR 0 3
77947: PUSH
77948: LD_EXP 48
77952: PUSH
77953: LD_VAR 0 2
77957: ARRAY
77958: PUSH
77959: FOR_IN
77960: IFFALSE 78185
// begin k := k + 1 ;
77962: LD_ADDR_VAR 0 4
77966: PUSH
77967: LD_VAR 0 4
77971: PUSH
77972: LD_INT 1
77974: PLUS
77975: ST_TO_ADDR
// if k > tmp then
77976: LD_VAR 0 4
77980: PUSH
77981: LD_VAR 0 5
77985: GREATER
77986: IFFALSE 77990
// break ;
77988: GO 78185
// if not GetClass ( j ) in [ 2 , 16 ] then
77990: LD_VAR 0 3
77994: PPUSH
77995: CALL_OW 257
77999: PUSH
78000: LD_INT 2
78002: PUSH
78003: LD_INT 16
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: IN
78010: NOT
78011: IFFALSE 78064
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
78013: LD_ADDR_EXP 48
78017: PUSH
78018: LD_EXP 48
78022: PPUSH
78023: LD_VAR 0 2
78027: PPUSH
78028: LD_EXP 48
78032: PUSH
78033: LD_VAR 0 2
78037: ARRAY
78038: PUSH
78039: LD_VAR 0 3
78043: DIFF
78044: PPUSH
78045: CALL_OW 1
78049: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78050: LD_VAR 0 3
78054: PPUSH
78055: LD_INT 0
78057: PPUSH
78058: CALL_OW 109
// continue ;
78062: GO 77959
// end ; if IsInUnit ( j ) then
78064: LD_VAR 0 3
78068: PPUSH
78069: CALL_OW 310
78073: IFFALSE 78084
// ComExitBuilding ( j ) ;
78075: LD_VAR 0 3
78079: PPUSH
78080: CALL_OW 122
// wait ( 3 ) ;
78084: LD_INT 3
78086: PPUSH
78087: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
78091: LD_VAR 0 3
78095: PPUSH
78096: CALL_OW 314
78100: IFFALSE 78138
78102: PUSH
78103: LD_VAR 0 6
78107: PPUSH
78108: LD_VAR 0 7
78112: PUSH
78113: LD_INT 2
78115: ARRAY
78116: PPUSH
78117: LD_VAR 0 7
78121: PUSH
78122: LD_INT 3
78124: ARRAY
78125: PPUSH
78126: LD_INT 30
78128: PPUSH
78129: CALL 26333 0 4
78133: PUSH
78134: LD_INT 4
78136: ARRAY
78137: AND
78138: IFFALSE 78156
// ComStandNearbyBuilding ( j , depot ) else
78140: LD_VAR 0 3
78144: PPUSH
78145: LD_VAR 0 9
78149: PPUSH
78150: CALL 21639 0 2
78154: GO 78183
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
78156: LD_VAR 0 3
78160: PPUSH
78161: LD_VAR 0 7
78165: PUSH
78166: LD_INT 2
78168: ARRAY
78169: PPUSH
78170: LD_VAR 0 7
78174: PUSH
78175: LD_INT 3
78177: ARRAY
78178: PPUSH
78179: CALL_OW 117
// end ;
78183: GO 77959
78185: POP
78186: POP
// end ; end else
78187: GO 78729
// begin for j in cargo do
78189: LD_ADDR_VAR 0 3
78193: PUSH
78194: LD_VAR 0 8
78198: PUSH
78199: FOR_IN
78200: IFFALSE 78727
// begin if GetTag ( j ) <> 0 then
78202: LD_VAR 0 3
78206: PPUSH
78207: CALL_OW 110
78211: PUSH
78212: LD_INT 0
78214: NONEQUAL
78215: IFFALSE 78219
// continue ;
78217: GO 78199
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
78219: LD_VAR 0 3
78223: PPUSH
78224: CALL_OW 256
78228: PUSH
78229: LD_INT 1000
78231: LESS
78232: IFFALSE 78257
78234: PUSH
78235: LD_VAR 0 3
78239: PPUSH
78240: LD_EXP 55
78244: PUSH
78245: LD_VAR 0 2
78249: ARRAY
78250: PPUSH
78251: CALL_OW 308
78255: NOT
78256: AND
78257: IFFALSE 78279
// ComMoveToArea ( j , mc_parking [ i ] ) ;
78259: LD_VAR 0 3
78263: PPUSH
78264: LD_EXP 55
78268: PUSH
78269: LD_VAR 0 2
78273: ARRAY
78274: PPUSH
78275: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
78279: LD_VAR 0 3
78283: PPUSH
78284: CALL_OW 256
78288: PUSH
78289: LD_INT 1000
78291: LESS
78292: IFFALSE 78316
78294: PUSH
78295: LD_VAR 0 3
78299: PPUSH
78300: LD_EXP 55
78304: PUSH
78305: LD_VAR 0 2
78309: ARRAY
78310: PPUSH
78311: CALL_OW 308
78315: AND
78316: IFFALSE 78320
// continue ;
78318: GO 78199
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
78320: LD_VAR 0 3
78324: PPUSH
78325: CALL_OW 262
78329: PUSH
78330: LD_INT 2
78332: EQUAL
78333: IFFALSE 78350
78335: PUSH
78336: LD_VAR 0 3
78340: PPUSH
78341: CALL_OW 261
78345: PUSH
78346: LD_INT 15
78348: LESS
78349: AND
78350: IFFALSE 78354
// continue ;
78352: GO 78199
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
78354: LD_VAR 0 3
78358: PPUSH
78359: CALL_OW 262
78363: PUSH
78364: LD_INT 1
78366: EQUAL
78367: IFFALSE 78384
78369: PUSH
78370: LD_VAR 0 3
78374: PPUSH
78375: CALL_OW 261
78379: PUSH
78380: LD_INT 10
78382: LESS
78383: AND
78384: IFFALSE 78664
// begin if not depot then
78386: LD_VAR 0 9
78390: NOT
78391: IFFALSE 78395
// continue ;
78393: GO 78199
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
78395: LD_VAR 0 3
78399: PPUSH
78400: LD_VAR 0 9
78404: PPUSH
78405: LD_VAR 0 3
78409: PPUSH
78410: CALL_OW 74
78414: PPUSH
78415: CALL_OW 296
78419: PUSH
78420: LD_INT 6
78422: LESS
78423: IFFALSE 78439
// SetFuel ( j , 100 ) else
78425: LD_VAR 0 3
78429: PPUSH
78430: LD_INT 100
78432: PPUSH
78433: CALL_OW 240
78437: GO 78664
// if GetFuel ( j ) = 0 then
78439: LD_VAR 0 3
78443: PPUSH
78444: CALL_OW 261
78448: PUSH
78449: LD_INT 0
78451: EQUAL
78452: IFFALSE 78664
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
78454: LD_ADDR_EXP 50
78458: PUSH
78459: LD_EXP 50
78463: PPUSH
78464: LD_VAR 0 2
78468: PPUSH
78469: LD_EXP 50
78473: PUSH
78474: LD_VAR 0 2
78478: ARRAY
78479: PUSH
78480: LD_VAR 0 3
78484: DIFF
78485: PPUSH
78486: CALL_OW 1
78490: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
78491: LD_VAR 0 3
78495: PPUSH
78496: CALL_OW 263
78500: PUSH
78501: LD_INT 1
78503: EQUAL
78504: IFFALSE 78520
// ComExitVehicle ( IsInUnit ( j ) ) ;
78506: LD_VAR 0 3
78510: PPUSH
78511: CALL_OW 310
78515: PPUSH
78516: CALL_OW 121
// if GetControl ( j ) = control_remote then
78520: LD_VAR 0 3
78524: PPUSH
78525: CALL_OW 263
78529: PUSH
78530: LD_INT 2
78532: EQUAL
78533: IFFALSE 78544
// ComUnlink ( j ) ;
78535: LD_VAR 0 3
78539: PPUSH
78540: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
78544: LD_ADDR_VAR 0 10
78548: PUSH
78549: LD_VAR 0 2
78553: PPUSH
78554: LD_INT 3
78556: PPUSH
78557: CALL 88458 0 2
78561: ST_TO_ADDR
// if fac then
78562: LD_VAR 0 10
78566: IFFALSE 78662
// begin for k in fac do
78568: LD_ADDR_VAR 0 4
78572: PUSH
78573: LD_VAR 0 10
78577: PUSH
78578: FOR_IN
78579: IFFALSE 78660
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
78581: LD_ADDR_VAR 0 11
78585: PUSH
78586: LD_VAR 0 10
78590: PPUSH
78591: LD_VAR 0 3
78595: PPUSH
78596: CALL_OW 265
78600: PPUSH
78601: LD_VAR 0 3
78605: PPUSH
78606: CALL_OW 262
78610: PPUSH
78611: LD_VAR 0 3
78615: PPUSH
78616: CALL_OW 263
78620: PPUSH
78621: LD_VAR 0 3
78625: PPUSH
78626: CALL_OW 264
78630: PPUSH
78631: CALL 22537 0 5
78635: ST_TO_ADDR
// if components then
78636: LD_VAR 0 11
78640: IFFALSE 78658
// begin MC_InsertProduceList ( i , components ) ;
78642: LD_VAR 0 2
78646: PPUSH
78647: LD_VAR 0 11
78651: PPUSH
78652: CALL 88003 0 2
// break ;
78656: GO 78660
// end ; end ;
78658: GO 78578
78660: POP
78661: POP
// end ; continue ;
78662: GO 78199
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
78664: LD_VAR 0 3
78668: PPUSH
78669: LD_INT 1
78671: PPUSH
78672: CALL_OW 289
78676: PUSH
78677: LD_INT 100
78679: LESS
78680: IFFALSE 78694
78682: PUSH
78683: LD_VAR 0 3
78687: PPUSH
78688: CALL_OW 314
78692: NOT
78693: AND
78694: IFFALSE 78723
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
78696: LD_VAR 0 3
78700: PPUSH
78701: LD_VAR 0 7
78705: PUSH
78706: LD_INT 2
78708: ARRAY
78709: PPUSH
78710: LD_VAR 0 7
78714: PUSH
78715: LD_INT 3
78717: ARRAY
78718: PPUSH
78719: CALL_OW 117
// break ;
78723: GO 78727
// end ;
78725: GO 78199
78727: POP
78728: POP
// end ; end ;
78729: GO 76901
78731: POP
78732: POP
// end ;
78733: LD_VAR 0 1
78737: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
78738: LD_INT 0
78740: PPUSH
78741: PPUSH
78742: PPUSH
78743: PPUSH
// if not mc_bases then
78744: LD_EXP 31
78748: NOT
78749: IFFALSE 78753
// exit ;
78751: GO 78918
// for i = 1 to mc_bases do
78753: LD_ADDR_VAR 0 2
78757: PUSH
78758: DOUBLE
78759: LD_INT 1
78761: DEC
78762: ST_TO_ADDR
78763: LD_EXP 31
78767: PUSH
78768: FOR_TO
78769: IFFALSE 78916
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
78771: LD_ADDR_VAR 0 4
78775: PUSH
78776: LD_EXP 50
78780: PUSH
78781: LD_VAR 0 2
78785: ARRAY
78786: PUSH
78787: LD_EXP 53
78791: PUSH
78792: LD_VAR 0 2
78796: ARRAY
78797: UNION
78798: PPUSH
78799: LD_INT 33
78801: PUSH
78802: LD_INT 2
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PPUSH
78809: CALL_OW 72
78813: ST_TO_ADDR
// if tmp then
78814: LD_VAR 0 4
78818: IFFALSE 78914
// for j in tmp do
78820: LD_ADDR_VAR 0 3
78824: PUSH
78825: LD_VAR 0 4
78829: PUSH
78830: FOR_IN
78831: IFFALSE 78912
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
78833: LD_VAR 0 3
78837: PPUSH
78838: CALL_OW 312
78842: NOT
78843: IFFALSE 78860
78845: PUSH
78846: LD_VAR 0 3
78850: PPUSH
78851: CALL_OW 256
78855: PUSH
78856: LD_INT 250
78858: GREATEREQUAL
78859: AND
78860: IFFALSE 78873
// Connect ( j ) else
78862: LD_VAR 0 3
78866: PPUSH
78867: CALL 28423 0 1
78871: GO 78910
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
78873: LD_VAR 0 3
78877: PPUSH
78878: CALL_OW 256
78882: PUSH
78883: LD_INT 250
78885: LESS
78886: IFFALSE 78899
78888: PUSH
78889: LD_VAR 0 3
78893: PPUSH
78894: CALL_OW 312
78898: AND
78899: IFFALSE 78910
// ComUnlink ( j ) ;
78901: LD_VAR 0 3
78905: PPUSH
78906: CALL_OW 136
78910: GO 78830
78912: POP
78913: POP
// end ;
78914: GO 78768
78916: POP
78917: POP
// end ;
78918: LD_VAR 0 1
78922: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
78923: LD_INT 0
78925: PPUSH
78926: PPUSH
78927: PPUSH
78928: PPUSH
78929: PPUSH
// if not mc_bases then
78930: LD_EXP 31
78934: NOT
78935: IFFALSE 78939
// exit ;
78937: GO 79388
// for i = 1 to mc_bases do
78939: LD_ADDR_VAR 0 2
78943: PUSH
78944: DOUBLE
78945: LD_INT 1
78947: DEC
78948: ST_TO_ADDR
78949: LD_EXP 31
78953: PUSH
78954: FOR_TO
78955: IFFALSE 79386
// begin if not mc_produce [ i ] then
78957: LD_EXP 52
78961: PUSH
78962: LD_VAR 0 2
78966: ARRAY
78967: NOT
78968: IFFALSE 78972
// continue ;
78970: GO 78954
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78972: LD_ADDR_VAR 0 5
78976: PUSH
78977: LD_EXP 31
78981: PUSH
78982: LD_VAR 0 2
78986: ARRAY
78987: PPUSH
78988: LD_INT 30
78990: PUSH
78991: LD_INT 3
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PPUSH
78998: CALL_OW 72
79002: ST_TO_ADDR
// if not fac then
79003: LD_VAR 0 5
79007: NOT
79008: IFFALSE 79012
// continue ;
79010: GO 78954
// for j in fac do
79012: LD_ADDR_VAR 0 3
79016: PUSH
79017: LD_VAR 0 5
79021: PUSH
79022: FOR_IN
79023: IFFALSE 79382
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
79025: LD_VAR 0 3
79029: PPUSH
79030: CALL_OW 461
79034: PUSH
79035: LD_INT 2
79037: NONEQUAL
79038: IFTRUE 79058
79040: PUSH
79041: LD_VAR 0 3
79045: PPUSH
79046: LD_INT 15
79048: PPUSH
79049: CALL 28042 0 2
79053: PUSH
79054: LD_INT 4
79056: ARRAY
79057: OR
79058: IFFALSE 79062
// continue ;
79060: GO 79022
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
79062: LD_VAR 0 3
79066: PPUSH
79067: LD_EXP 52
79071: PUSH
79072: LD_VAR 0 2
79076: ARRAY
79077: PUSH
79078: LD_INT 1
79080: ARRAY
79081: PUSH
79082: LD_INT 1
79084: ARRAY
79085: PPUSH
79086: LD_EXP 52
79090: PUSH
79091: LD_VAR 0 2
79095: ARRAY
79096: PUSH
79097: LD_INT 1
79099: ARRAY
79100: PUSH
79101: LD_INT 2
79103: ARRAY
79104: PPUSH
79105: LD_EXP 52
79109: PUSH
79110: LD_VAR 0 2
79114: ARRAY
79115: PUSH
79116: LD_INT 1
79118: ARRAY
79119: PUSH
79120: LD_INT 3
79122: ARRAY
79123: PPUSH
79124: LD_EXP 52
79128: PUSH
79129: LD_VAR 0 2
79133: ARRAY
79134: PUSH
79135: LD_INT 1
79137: ARRAY
79138: PUSH
79139: LD_INT 4
79141: ARRAY
79142: PPUSH
79143: CALL_OW 448
79147: IFFALSE 79242
79149: PUSH
79150: LD_VAR 0 3
79154: PPUSH
79155: LD_EXP 52
79159: PUSH
79160: LD_VAR 0 2
79164: ARRAY
79165: PUSH
79166: LD_INT 1
79168: ARRAY
79169: PUSH
79170: LD_INT 1
79172: ARRAY
79173: PUSH
79174: LD_EXP 52
79178: PUSH
79179: LD_VAR 0 2
79183: ARRAY
79184: PUSH
79185: LD_INT 1
79187: ARRAY
79188: PUSH
79189: LD_INT 2
79191: ARRAY
79192: PUSH
79193: LD_EXP 52
79197: PUSH
79198: LD_VAR 0 2
79202: ARRAY
79203: PUSH
79204: LD_INT 1
79206: ARRAY
79207: PUSH
79208: LD_INT 3
79210: ARRAY
79211: PUSH
79212: LD_EXP 52
79216: PUSH
79217: LD_VAR 0 2
79221: ARRAY
79222: PUSH
79223: LD_INT 1
79225: ARRAY
79226: PUSH
79227: LD_INT 4
79229: ARRAY
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: LIST
79235: LIST
79236: PPUSH
79237: CALL 31856 0 2
79241: AND
79242: IFFALSE 79380
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
79244: LD_VAR 0 3
79248: PPUSH
79249: LD_EXP 52
79253: PUSH
79254: LD_VAR 0 2
79258: ARRAY
79259: PUSH
79260: LD_INT 1
79262: ARRAY
79263: PUSH
79264: LD_INT 1
79266: ARRAY
79267: PPUSH
79268: LD_EXP 52
79272: PUSH
79273: LD_VAR 0 2
79277: ARRAY
79278: PUSH
79279: LD_INT 1
79281: ARRAY
79282: PUSH
79283: LD_INT 2
79285: ARRAY
79286: PPUSH
79287: LD_EXP 52
79291: PUSH
79292: LD_VAR 0 2
79296: ARRAY
79297: PUSH
79298: LD_INT 1
79300: ARRAY
79301: PUSH
79302: LD_INT 3
79304: ARRAY
79305: PPUSH
79306: LD_EXP 52
79310: PUSH
79311: LD_VAR 0 2
79315: ARRAY
79316: PUSH
79317: LD_INT 1
79319: ARRAY
79320: PUSH
79321: LD_INT 4
79323: ARRAY
79324: PPUSH
79325: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
79329: LD_ADDR_VAR 0 4
79333: PUSH
79334: LD_EXP 52
79338: PUSH
79339: LD_VAR 0 2
79343: ARRAY
79344: PPUSH
79345: LD_INT 1
79347: PPUSH
79348: CALL_OW 3
79352: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79353: LD_ADDR_EXP 52
79357: PUSH
79358: LD_EXP 52
79362: PPUSH
79363: LD_VAR 0 2
79367: PPUSH
79368: LD_VAR 0 4
79372: PPUSH
79373: CALL_OW 1
79377: ST_TO_ADDR
// break ;
79378: GO 79382
// end ; end ;
79380: GO 79022
79382: POP
79383: POP
// end ;
79384: GO 78954
79386: POP
79387: POP
// end ;
79388: LD_VAR 0 1
79392: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
79393: LD_INT 0
79395: PPUSH
79396: PPUSH
79397: PPUSH
// if not mc_bases then
79398: LD_EXP 31
79402: NOT
79403: IFFALSE 79407
// exit ;
79405: GO 79496
// for i = 1 to mc_bases do
79407: LD_ADDR_VAR 0 2
79411: PUSH
79412: DOUBLE
79413: LD_INT 1
79415: DEC
79416: ST_TO_ADDR
79417: LD_EXP 31
79421: PUSH
79422: FOR_TO
79423: IFFALSE 79494
// begin if mc_attack [ i ] then
79425: LD_EXP 51
79429: PUSH
79430: LD_VAR 0 2
79434: ARRAY
79435: IFFALSE 79492
// begin tmp := mc_attack [ i ] [ 1 ] ;
79437: LD_ADDR_VAR 0 3
79441: PUSH
79442: LD_EXP 51
79446: PUSH
79447: LD_VAR 0 2
79451: ARRAY
79452: PUSH
79453: LD_INT 1
79455: ARRAY
79456: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
79457: LD_ADDR_EXP 51
79461: PUSH
79462: LD_EXP 51
79466: PPUSH
79467: LD_VAR 0 2
79471: PPUSH
79472: EMPTY
79473: PPUSH
79474: CALL_OW 1
79478: ST_TO_ADDR
// Attack ( tmp ) ;
79479: LD_VAR 0 3
79483: PPUSH
79484: CALL 116809 0 1
// exit ;
79488: POP
79489: POP
79490: GO 79496
// end ; end ;
79492: GO 79422
79494: POP
79495: POP
// end ;
79496: LD_VAR 0 1
79500: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
79501: LD_INT 0
79503: PPUSH
79504: PPUSH
79505: PPUSH
79506: PPUSH
79507: PPUSH
79508: PPUSH
79509: PPUSH
// if not mc_bases then
79510: LD_EXP 31
79514: NOT
79515: IFFALSE 79519
// exit ;
79517: GO 80396
// for i = 1 to mc_bases do
79519: LD_ADDR_VAR 0 2
79523: PUSH
79524: DOUBLE
79525: LD_INT 1
79527: DEC
79528: ST_TO_ADDR
79529: LD_EXP 31
79533: PUSH
79534: FOR_TO
79535: IFFALSE 80394
// begin if not mc_bases [ i ] then
79537: LD_EXP 31
79541: PUSH
79542: LD_VAR 0 2
79546: ARRAY
79547: NOT
79548: IFFALSE 79552
// continue ;
79550: GO 79534
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
79552: LD_ADDR_VAR 0 7
79556: PUSH
79557: LD_EXP 31
79561: PUSH
79562: LD_VAR 0 2
79566: ARRAY
79567: PUSH
79568: LD_INT 1
79570: ARRAY
79571: PPUSH
79572: CALL 21863 0 1
79576: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
79577: LD_ADDR_EXP 54
79581: PUSH
79582: LD_EXP 54
79586: PPUSH
79587: LD_VAR 0 2
79591: PPUSH
79592: LD_EXP 31
79596: PUSH
79597: LD_VAR 0 2
79601: ARRAY
79602: PUSH
79603: LD_INT 1
79605: ARRAY
79606: PPUSH
79607: CALL_OW 255
79611: PPUSH
79612: LD_EXP 56
79616: PUSH
79617: LD_VAR 0 2
79621: ARRAY
79622: PPUSH
79623: CALL 21828 0 2
79627: PPUSH
79628: CALL_OW 1
79632: ST_TO_ADDR
// if not mc_scan [ i ] then
79633: LD_EXP 54
79637: PUSH
79638: LD_VAR 0 2
79642: ARRAY
79643: NOT
79644: IFFALSE 79828
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
79646: LD_ADDR_EXP 74
79650: PUSH
79651: LD_EXP 74
79655: PPUSH
79656: LD_VAR 0 2
79660: PPUSH
79661: LD_INT 0
79663: PPUSH
79664: CALL_OW 1
79668: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
79669: LD_ADDR_VAR 0 4
79673: PUSH
79674: LD_EXP 31
79678: PUSH
79679: LD_VAR 0 2
79683: ARRAY
79684: PPUSH
79685: LD_INT 2
79687: PUSH
79688: LD_INT 25
79690: PUSH
79691: LD_INT 5
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 25
79700: PUSH
79701: LD_INT 8
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 25
79710: PUSH
79711: LD_INT 9
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: LIST
79722: LIST
79723: PPUSH
79724: CALL_OW 72
79728: ST_TO_ADDR
// if not tmp then
79729: LD_VAR 0 4
79733: NOT
79734: IFFALSE 79738
// continue ;
79736: GO 79534
// for j in tmp do
79738: LD_ADDR_VAR 0 3
79742: PUSH
79743: LD_VAR 0 4
79747: PUSH
79748: FOR_IN
79749: IFFALSE 79826
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
79751: LD_VAR 0 3
79755: PPUSH
79756: CALL_OW 310
79760: PPUSH
79761: CALL_OW 266
79765: PUSH
79766: LD_INT 5
79768: EQUAL
79769: IFFALSE 79786
79771: PUSH
79772: LD_VAR 0 3
79776: PPUSH
79777: CALL_OW 257
79781: PUSH
79782: LD_INT 1
79784: EQUAL
79785: AND
79786: IFFALSE 79800
79788: PUSH
79789: LD_VAR 0 3
79793: PPUSH
79794: CALL_OW 459
79798: NOT
79799: AND
79800: IFFALSE 79808
79802: PUSH
79803: LD_VAR 0 7
79807: AND
79808: IFFALSE 79824
// ComChangeProfession ( j , class ) ;
79810: LD_VAR 0 3
79814: PPUSH
79815: LD_VAR 0 7
79819: PPUSH
79820: CALL_OW 123
79824: GO 79748
79826: POP
79827: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
79828: LD_EXP 54
79832: PUSH
79833: LD_VAR 0 2
79837: ARRAY
79838: IFFALSE 79853
79840: PUSH
79841: LD_EXP 74
79845: PUSH
79846: LD_VAR 0 2
79850: ARRAY
79851: NOT
79852: AND
79853: IFFALSE 79868
79855: PUSH
79856: LD_EXP 53
79860: PUSH
79861: LD_VAR 0 2
79865: ARRAY
79866: NOT
79867: AND
79868: IFFALSE 80019
79870: PUSH
79871: LD_EXP 31
79875: PUSH
79876: LD_VAR 0 2
79880: ARRAY
79881: PPUSH
79882: LD_INT 50
79884: PUSH
79885: EMPTY
79886: LIST
79887: PUSH
79888: LD_INT 2
79890: PUSH
79891: LD_INT 30
79893: PUSH
79894: LD_INT 32
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 30
79903: PUSH
79904: LD_INT 33
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: LD_INT 30
79913: PUSH
79914: LD_INT 4
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 30
79923: PUSH
79924: LD_INT 5
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PPUSH
79942: CALL_OW 72
79946: PUSH
79947: LD_INT 4
79949: LESS
79950: IFTRUE 80018
79952: PUSH
79953: LD_EXP 31
79957: PUSH
79958: LD_VAR 0 2
79962: ARRAY
79963: PPUSH
79964: LD_INT 3
79966: PUSH
79967: LD_INT 24
79969: PUSH
79970: LD_INT 1000
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: LD_INT 2
79983: PUSH
79984: LD_INT 30
79986: PUSH
79987: LD_INT 0
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: PUSH
79994: LD_INT 30
79996: PUSH
79997: LD_INT 1
79999: PUSH
80000: EMPTY
80001: LIST
80002: LIST
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: LIST
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PPUSH
80013: CALL_OW 72
80017: OR
80018: AND
80019: IFFALSE 80272
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
80021: LD_ADDR_EXP 74
80025: PUSH
80026: LD_EXP 74
80030: PPUSH
80031: LD_VAR 0 2
80035: PPUSH
80036: LD_INT 1
80038: PPUSH
80039: CALL_OW 1
80043: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
80044: LD_ADDR_VAR 0 4
80048: PUSH
80049: LD_EXP 31
80053: PUSH
80054: LD_VAR 0 2
80058: ARRAY
80059: PPUSH
80060: LD_INT 2
80062: PUSH
80063: LD_INT 25
80065: PUSH
80066: LD_INT 1
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: PUSH
80073: LD_INT 25
80075: PUSH
80076: LD_INT 5
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 25
80085: PUSH
80086: LD_INT 8
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: LD_INT 25
80095: PUSH
80096: LD_INT 9
80098: PUSH
80099: EMPTY
80100: LIST
80101: LIST
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: PPUSH
80110: CALL_OW 72
80114: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
80115: LD_ADDR_VAR 0 4
80119: PUSH
80120: LD_VAR 0 4
80124: PUSH
80125: LD_VAR 0 4
80129: PPUSH
80130: LD_INT 18
80132: PPUSH
80133: CALL 55656 0 2
80137: DIFF
80138: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
80139: LD_VAR 0 4
80143: NOT
80144: IFFALSE 80192
80146: PUSH
80147: LD_EXP 31
80151: PUSH
80152: LD_VAR 0 2
80156: ARRAY
80157: PPUSH
80158: LD_INT 2
80160: PUSH
80161: LD_INT 30
80163: PUSH
80164: LD_INT 4
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 30
80173: PUSH
80174: LD_INT 5
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: LIST
80185: PPUSH
80186: CALL_OW 72
80190: NOT
80191: AND
80192: IFFALSE 80254
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
80194: LD_ADDR_VAR 0 4
80198: PUSH
80199: LD_EXP 31
80203: PUSH
80204: LD_VAR 0 2
80208: ARRAY
80209: PPUSH
80210: LD_INT 2
80212: PUSH
80213: LD_INT 25
80215: PUSH
80216: LD_INT 2
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 25
80225: PUSH
80226: LD_INT 3
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 25
80235: PUSH
80236: LD_INT 4
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: LIST
80247: LIST
80248: PPUSH
80249: CALL_OW 72
80253: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
80254: LD_VAR 0 2
80258: PPUSH
80259: LD_VAR 0 4
80263: PPUSH
80264: CALL 121578 0 2
// exit ;
80268: POP
80269: POP
80270: GO 80396
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
80272: LD_EXP 54
80276: PUSH
80277: LD_VAR 0 2
80281: ARRAY
80282: IFFALSE 80297
80284: PUSH
80285: LD_EXP 74
80289: PUSH
80290: LD_VAR 0 2
80294: ARRAY
80295: NOT
80296: AND
80297: IFFALSE 80311
80299: PUSH
80300: LD_EXP 53
80304: PUSH
80305: LD_VAR 0 2
80309: ARRAY
80310: AND
80311: IFFALSE 80392
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
80313: LD_ADDR_EXP 74
80317: PUSH
80318: LD_EXP 74
80322: PPUSH
80323: LD_VAR 0 2
80327: PPUSH
80328: LD_INT 1
80330: PPUSH
80331: CALL_OW 1
80335: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
80336: LD_ADDR_VAR 0 4
80340: PUSH
80341: LD_EXP 53
80345: PUSH
80346: LD_VAR 0 2
80350: ARRAY
80351: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
80352: LD_ADDR_EXP 53
80356: PUSH
80357: LD_EXP 53
80361: PPUSH
80362: LD_VAR 0 2
80366: PPUSH
80367: EMPTY
80368: PPUSH
80369: CALL_OW 1
80373: ST_TO_ADDR
// Defend ( i , tmp ) ;
80374: LD_VAR 0 2
80378: PPUSH
80379: LD_VAR 0 4
80383: PPUSH
80384: CALL 122182 0 2
// exit ;
80388: POP
80389: POP
80390: GO 80396
// end ; end ;
80392: GO 79534
80394: POP
80395: POP
// end ;
80396: LD_VAR 0 1
80400: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
80401: LD_INT 0
80403: PPUSH
80404: PPUSH
80405: PPUSH
80406: PPUSH
80407: PPUSH
80408: PPUSH
80409: PPUSH
80410: PPUSH
80411: PPUSH
80412: PPUSH
80413: PPUSH
// if not mc_bases then
80414: LD_EXP 31
80418: NOT
80419: IFFALSE 80423
// exit ;
80421: GO 81536
// for i = 1 to mc_bases do
80423: LD_ADDR_VAR 0 2
80427: PUSH
80428: DOUBLE
80429: LD_INT 1
80431: DEC
80432: ST_TO_ADDR
80433: LD_EXP 31
80437: PUSH
80438: FOR_TO
80439: IFFALSE 81534
// begin tmp := mc_lab [ i ] ;
80441: LD_ADDR_VAR 0 6
80445: PUSH
80446: LD_EXP 64
80450: PUSH
80451: LD_VAR 0 2
80455: ARRAY
80456: ST_TO_ADDR
// if not tmp then
80457: LD_VAR 0 6
80461: NOT
80462: IFFALSE 80466
// continue ;
80464: GO 80438
// idle_lab := 0 ;
80466: LD_ADDR_VAR 0 11
80470: PUSH
80471: LD_INT 0
80473: ST_TO_ADDR
// for j in tmp do
80474: LD_ADDR_VAR 0 3
80478: PUSH
80479: LD_VAR 0 6
80483: PUSH
80484: FOR_IN
80485: IFFALSE 81530
// begin researching := false ;
80487: LD_ADDR_VAR 0 10
80491: PUSH
80492: LD_INT 0
80494: ST_TO_ADDR
// side := GetSide ( j ) ;
80495: LD_ADDR_VAR 0 4
80499: PUSH
80500: LD_VAR 0 3
80504: PPUSH
80505: CALL_OW 255
80509: ST_TO_ADDR
// if not mc_tech [ side ] then
80510: LD_EXP 58
80514: PUSH
80515: LD_VAR 0 4
80519: ARRAY
80520: NOT
80521: IFFALSE 80525
// continue ;
80523: GO 80484
// if BuildingStatus ( j ) = bs_idle then
80525: LD_VAR 0 3
80529: PPUSH
80530: CALL_OW 461
80534: PUSH
80535: LD_INT 2
80537: EQUAL
80538: IFFALSE 80730
// begin if idle_lab and UnitsInside ( j ) < 6 then
80540: LD_VAR 0 11
80544: IFFALSE 80561
80546: PUSH
80547: LD_VAR 0 3
80551: PPUSH
80552: CALL_OW 313
80556: PUSH
80557: LD_INT 6
80559: LESS
80560: AND
80561: IFFALSE 80632
// begin tmp2 := UnitsInside ( idle_lab ) ;
80563: LD_ADDR_VAR 0 9
80567: PUSH
80568: LD_VAR 0 11
80572: PPUSH
80573: CALL_OW 313
80577: ST_TO_ADDR
// if tmp2 then
80578: LD_VAR 0 9
80582: IFFALSE 80624
// for x in tmp2 do
80584: LD_ADDR_VAR 0 7
80588: PUSH
80589: LD_VAR 0 9
80593: PUSH
80594: FOR_IN
80595: IFFALSE 80622
// begin ComExitBuilding ( x ) ;
80597: LD_VAR 0 7
80601: PPUSH
80602: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
80606: LD_VAR 0 7
80610: PPUSH
80611: LD_VAR 0 3
80615: PPUSH
80616: CALL_OW 180
// end ;
80620: GO 80594
80622: POP
80623: POP
// idle_lab := 0 ;
80624: LD_ADDR_VAR 0 11
80628: PUSH
80629: LD_INT 0
80631: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
80632: LD_ADDR_VAR 0 5
80636: PUSH
80637: LD_EXP 58
80641: PUSH
80642: LD_VAR 0 4
80646: ARRAY
80647: PUSH
80648: FOR_IN
80649: IFFALSE 80711
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
80651: LD_VAR 0 3
80655: PPUSH
80656: LD_VAR 0 5
80660: PPUSH
80661: CALL_OW 430
80665: IFFALSE 80683
80667: PUSH
80668: LD_VAR 0 4
80672: PPUSH
80673: LD_VAR 0 5
80677: PPUSH
80678: CALL 20923 0 2
80682: AND
80683: IFFALSE 80709
// begin researching := true ;
80685: LD_ADDR_VAR 0 10
80689: PUSH
80690: LD_INT 1
80692: ST_TO_ADDR
// ComResearch ( j , t ) ;
80693: LD_VAR 0 3
80697: PPUSH
80698: LD_VAR 0 5
80702: PPUSH
80703: CALL_OW 124
// break ;
80707: GO 80711
// end ;
80709: GO 80648
80711: POP
80712: POP
// if not researching then
80713: LD_VAR 0 10
80717: NOT
80718: IFFALSE 80730
// idle_lab := j ;
80720: LD_ADDR_VAR 0 11
80724: PUSH
80725: LD_VAR 0 3
80729: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
80730: LD_VAR 0 3
80734: PPUSH
80735: CALL_OW 461
80739: PUSH
80740: LD_INT 10
80742: EQUAL
80743: IFFALSE 81349
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
80745: LD_EXP 60
80749: PUSH
80750: LD_VAR 0 2
80754: ARRAY
80755: NOT
80756: IFFALSE 80771
80758: PUSH
80759: LD_EXP 61
80763: PUSH
80764: LD_VAR 0 2
80768: ARRAY
80769: NOT
80770: AND
80771: IFFALSE 80789
80773: PUSH
80774: LD_EXP 58
80778: PUSH
80779: LD_VAR 0 4
80783: ARRAY
80784: PUSH
80785: LD_INT 1
80787: GREATER
80788: AND
80789: IFFALSE 80920
// begin ComCancel ( j ) ;
80791: LD_VAR 0 3
80795: PPUSH
80796: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
80800: LD_ADDR_EXP 58
80804: PUSH
80805: LD_EXP 58
80809: PPUSH
80810: LD_VAR 0 4
80814: PPUSH
80815: LD_EXP 58
80819: PUSH
80820: LD_VAR 0 4
80824: ARRAY
80825: PPUSH
80826: LD_EXP 58
80830: PUSH
80831: LD_VAR 0 4
80835: ARRAY
80836: PUSH
80837: LD_INT 1
80839: MINUS
80840: PPUSH
80841: LD_EXP 58
80845: PUSH
80846: LD_VAR 0 4
80850: ARRAY
80851: PPUSH
80852: LD_INT 0
80854: PPUSH
80855: CALL 24471 0 4
80859: PPUSH
80860: CALL_OW 1
80864: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
80865: LD_ADDR_EXP 58
80869: PUSH
80870: LD_EXP 58
80874: PPUSH
80875: LD_VAR 0 4
80879: PPUSH
80880: LD_EXP 58
80884: PUSH
80885: LD_VAR 0 4
80889: ARRAY
80890: PPUSH
80891: LD_EXP 58
80895: PUSH
80896: LD_VAR 0 4
80900: ARRAY
80901: PPUSH
80902: LD_INT 1
80904: PPUSH
80905: LD_INT 0
80907: PPUSH
80908: CALL 24471 0 4
80912: PPUSH
80913: CALL_OW 1
80917: ST_TO_ADDR
// continue ;
80918: GO 80484
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
80920: LD_EXP 60
80924: PUSH
80925: LD_VAR 0 2
80929: ARRAY
80930: IFFALSE 80945
80932: PUSH
80933: LD_EXP 61
80937: PUSH
80938: LD_VAR 0 2
80942: ARRAY
80943: NOT
80944: AND
80945: IFFALSE 81072
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
80947: LD_ADDR_EXP 61
80951: PUSH
80952: LD_EXP 61
80956: PPUSH
80957: LD_VAR 0 2
80961: PUSH
80962: LD_EXP 61
80966: PUSH
80967: LD_VAR 0 2
80971: ARRAY
80972: PUSH
80973: LD_INT 1
80975: PLUS
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PPUSH
80981: LD_EXP 60
80985: PUSH
80986: LD_VAR 0 2
80990: ARRAY
80991: PUSH
80992: LD_INT 1
80994: ARRAY
80995: PPUSH
80996: CALL 25063 0 3
81000: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
81001: LD_EXP 60
81005: PUSH
81006: LD_VAR 0 2
81010: ARRAY
81011: PUSH
81012: LD_INT 1
81014: ARRAY
81015: PPUSH
81016: LD_INT 112
81018: PPUSH
81019: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
81023: LD_ADDR_VAR 0 9
81027: PUSH
81028: LD_EXP 60
81032: PUSH
81033: LD_VAR 0 2
81037: ARRAY
81038: PPUSH
81039: LD_INT 1
81041: PPUSH
81042: CALL_OW 3
81046: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
81047: LD_ADDR_EXP 60
81051: PUSH
81052: LD_EXP 60
81056: PPUSH
81057: LD_VAR 0 2
81061: PPUSH
81062: LD_VAR 0 9
81066: PPUSH
81067: CALL_OW 1
81071: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
81072: LD_EXP 60
81076: PUSH
81077: LD_VAR 0 2
81081: ARRAY
81082: IFFALSE 81096
81084: PUSH
81085: LD_EXP 61
81089: PUSH
81090: LD_VAR 0 2
81094: ARRAY
81095: AND
81096: IFFALSE 81120
81098: PUSH
81099: LD_EXP 61
81103: PUSH
81104: LD_VAR 0 2
81108: ARRAY
81109: PUSH
81110: LD_INT 1
81112: ARRAY
81113: PPUSH
81114: CALL_OW 310
81118: NOT
81119: AND
81120: IFFALSE 81137
81122: PUSH
81123: LD_VAR 0 3
81127: PPUSH
81128: CALL_OW 313
81132: PUSH
81133: LD_INT 6
81135: EQUAL
81136: AND
81137: IFFALSE 81193
// begin tmp2 := UnitsInside ( j ) ;
81139: LD_ADDR_VAR 0 9
81143: PUSH
81144: LD_VAR 0 3
81148: PPUSH
81149: CALL_OW 313
81153: ST_TO_ADDR
// if tmp2 = 6 then
81154: LD_VAR 0 9
81158: PUSH
81159: LD_INT 6
81161: EQUAL
81162: IFFALSE 81193
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
81164: LD_VAR 0 9
81168: PUSH
81169: LD_INT 1
81171: ARRAY
81172: PPUSH
81173: LD_INT 112
81175: PPUSH
81176: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
81180: LD_VAR 0 9
81184: PUSH
81185: LD_INT 1
81187: ARRAY
81188: PPUSH
81189: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
81193: LD_EXP 61
81197: PUSH
81198: LD_VAR 0 2
81202: ARRAY
81203: IFFALSE 81227
81205: PUSH
81206: LD_EXP 61
81210: PUSH
81211: LD_VAR 0 2
81215: ARRAY
81216: PUSH
81217: LD_INT 1
81219: ARRAY
81220: PPUSH
81221: CALL_OW 314
81225: NOT
81226: AND
81227: IFFALSE 81251
81229: PUSH
81230: LD_EXP 61
81234: PUSH
81235: LD_VAR 0 2
81239: ARRAY
81240: PUSH
81241: LD_INT 1
81243: ARRAY
81244: PPUSH
81245: CALL_OW 310
81249: NOT
81250: AND
81251: IFFALSE 81277
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
81253: LD_EXP 61
81257: PUSH
81258: LD_VAR 0 2
81262: ARRAY
81263: PUSH
81264: LD_INT 1
81266: ARRAY
81267: PPUSH
81268: LD_VAR 0 3
81272: PPUSH
81273: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
81277: LD_EXP 61
81281: PUSH
81282: LD_VAR 0 2
81286: ARRAY
81287: PUSH
81288: LD_INT 1
81290: ARRAY
81291: PPUSH
81292: CALL_OW 310
81296: IFFALSE 81328
81298: PUSH
81299: LD_EXP 61
81303: PUSH
81304: LD_VAR 0 2
81308: ARRAY
81309: PUSH
81310: LD_INT 1
81312: ARRAY
81313: PPUSH
81314: CALL_OW 310
81318: PPUSH
81319: CALL_OW 461
81323: PUSH
81324: LD_INT 3
81326: NONEQUAL
81327: AND
81328: IFFALSE 81349
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
81330: LD_EXP 61
81334: PUSH
81335: LD_VAR 0 2
81339: ARRAY
81340: PUSH
81341: LD_INT 1
81343: ARRAY
81344: PPUSH
81345: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
81349: LD_VAR 0 3
81353: PPUSH
81354: CALL_OW 461
81358: PUSH
81359: LD_INT 6
81361: EQUAL
81362: IFFALSE 81374
81364: PUSH
81365: LD_VAR 0 6
81369: PUSH
81370: LD_INT 1
81372: GREATER
81373: AND
81374: IFFALSE 81528
// begin sci := [ ] ;
81376: LD_ADDR_VAR 0 8
81380: PUSH
81381: EMPTY
81382: ST_TO_ADDR
// for x in ( tmp diff j ) do
81383: LD_ADDR_VAR 0 7
81387: PUSH
81388: LD_VAR 0 6
81392: PUSH
81393: LD_VAR 0 3
81397: DIFF
81398: PUSH
81399: FOR_IN
81400: IFFALSE 81452
// begin if sci = 6 then
81402: LD_VAR 0 8
81406: PUSH
81407: LD_INT 6
81409: EQUAL
81410: IFFALSE 81414
// break ;
81412: GO 81452
// if BuildingStatus ( x ) = bs_idle then
81414: LD_VAR 0 7
81418: PPUSH
81419: CALL_OW 461
81423: PUSH
81424: LD_INT 2
81426: EQUAL
81427: IFFALSE 81450
// sci := sci ^ UnitsInside ( x ) ;
81429: LD_ADDR_VAR 0 8
81433: PUSH
81434: LD_VAR 0 8
81438: PUSH
81439: LD_VAR 0 7
81443: PPUSH
81444: CALL_OW 313
81448: ADD
81449: ST_TO_ADDR
// end ;
81450: GO 81399
81452: POP
81453: POP
// if not sci then
81454: LD_VAR 0 8
81458: NOT
81459: IFFALSE 81463
// continue ;
81461: GO 80484
// for x in sci do
81463: LD_ADDR_VAR 0 7
81467: PUSH
81468: LD_VAR 0 8
81472: PUSH
81473: FOR_IN
81474: IFFALSE 81526
// if IsInUnit ( x ) and not HasTask ( x ) then
81476: LD_VAR 0 7
81480: PPUSH
81481: CALL_OW 310
81485: IFFALSE 81499
81487: PUSH
81488: LD_VAR 0 7
81492: PPUSH
81493: CALL_OW 314
81497: NOT
81498: AND
81499: IFFALSE 81524
// begin ComExitBuilding ( x ) ;
81501: LD_VAR 0 7
81505: PPUSH
81506: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
81510: LD_VAR 0 7
81514: PPUSH
81515: LD_VAR 0 3
81519: PPUSH
81520: CALL_OW 180
// end ;
81524: GO 81473
81526: POP
81527: POP
// end ; end ;
81528: GO 80484
81530: POP
81531: POP
// end ;
81532: GO 80438
81534: POP
81535: POP
// end ;
81536: LD_VAR 0 1
81540: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
81541: LD_INT 0
81543: PPUSH
81544: PPUSH
// if not mc_bases then
81545: LD_EXP 31
81549: NOT
81550: IFFALSE 81554
// exit ;
81552: GO 81637
// for i = 1 to mc_bases do
81554: LD_ADDR_VAR 0 2
81558: PUSH
81559: DOUBLE
81560: LD_INT 1
81562: DEC
81563: ST_TO_ADDR
81564: LD_EXP 31
81568: PUSH
81569: FOR_TO
81570: IFFALSE 81635
// if mc_mines [ i ] and mc_miners [ i ] then
81572: LD_EXP 44
81576: PUSH
81577: LD_VAR 0 2
81581: ARRAY
81582: IFFALSE 81596
81584: PUSH
81585: LD_EXP 45
81589: PUSH
81590: LD_VAR 0 2
81594: ARRAY
81595: AND
81596: IFFALSE 81633
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
81598: LD_EXP 45
81602: PUSH
81603: LD_VAR 0 2
81607: ARRAY
81608: PUSH
81609: LD_INT 1
81611: ARRAY
81612: PPUSH
81613: CALL_OW 255
81617: PPUSH
81618: LD_EXP 44
81622: PUSH
81623: LD_VAR 0 2
81627: ARRAY
81628: PPUSH
81629: CALL 22016 0 2
81633: GO 81569
81635: POP
81636: POP
// end ;
81637: LD_VAR 0 1
81641: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
81642: LD_INT 0
81644: PPUSH
81645: PPUSH
81646: PPUSH
81647: PPUSH
81648: PPUSH
81649: PPUSH
81650: PPUSH
81651: PPUSH
// if not mc_bases or not mc_parking then
81652: LD_EXP 31
81656: NOT
81657: IFTRUE 81666
81659: PUSH
81660: LD_EXP 55
81664: NOT
81665: OR
81666: IFFALSE 81670
// exit ;
81668: GO 82414
// for i = 1 to mc_bases do
81670: LD_ADDR_VAR 0 2
81674: PUSH
81675: DOUBLE
81676: LD_INT 1
81678: DEC
81679: ST_TO_ADDR
81680: LD_EXP 31
81684: PUSH
81685: FOR_TO
81686: IFFALSE 82412
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
81688: LD_EXP 31
81692: PUSH
81693: LD_VAR 0 2
81697: ARRAY
81698: NOT
81699: IFTRUE 81714
81701: PUSH
81702: LD_EXP 55
81706: PUSH
81707: LD_VAR 0 2
81711: ARRAY
81712: NOT
81713: OR
81714: IFFALSE 81718
// continue ;
81716: GO 81685
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
81718: LD_ADDR_VAR 0 5
81722: PUSH
81723: LD_EXP 31
81727: PUSH
81728: LD_VAR 0 2
81732: ARRAY
81733: PUSH
81734: LD_INT 1
81736: ARRAY
81737: PPUSH
81738: CALL_OW 255
81742: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
81743: LD_ADDR_VAR 0 6
81747: PUSH
81748: LD_EXP 31
81752: PUSH
81753: LD_VAR 0 2
81757: ARRAY
81758: PPUSH
81759: LD_INT 30
81761: PUSH
81762: LD_INT 3
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PPUSH
81769: CALL_OW 72
81773: ST_TO_ADDR
// if not fac then
81774: LD_VAR 0 6
81778: NOT
81779: IFFALSE 81830
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81781: LD_ADDR_VAR 0 6
81785: PUSH
81786: LD_EXP 31
81790: PUSH
81791: LD_VAR 0 2
81795: ARRAY
81796: PPUSH
81797: LD_INT 2
81799: PUSH
81800: LD_INT 30
81802: PUSH
81803: LD_INT 0
81805: PUSH
81806: EMPTY
81807: LIST
81808: LIST
81809: PUSH
81810: LD_INT 30
81812: PUSH
81813: LD_INT 1
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: LIST
81824: PPUSH
81825: CALL_OW 72
81829: ST_TO_ADDR
// if not fac then
81830: LD_VAR 0 6
81834: NOT
81835: IFFALSE 81839
// continue ;
81837: GO 81685
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
81839: LD_ADDR_VAR 0 7
81843: PUSH
81844: LD_EXP 55
81848: PUSH
81849: LD_VAR 0 2
81853: ARRAY
81854: PPUSH
81855: LD_INT 22
81857: PUSH
81858: LD_VAR 0 5
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 21
81869: PUSH
81870: LD_INT 2
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 3
81879: PUSH
81880: LD_INT 60
81882: PUSH
81883: EMPTY
81884: LIST
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 3
81892: PUSH
81893: LD_INT 24
81895: PUSH
81896: LD_INT 1000
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: LIST
81911: LIST
81912: PPUSH
81913: CALL_OW 70
81917: ST_TO_ADDR
// for j in fac do
81918: LD_ADDR_VAR 0 3
81922: PUSH
81923: LD_VAR 0 6
81927: PUSH
81928: FOR_IN
81929: IFFALSE 82024
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
81931: LD_ADDR_VAR 0 7
81935: PUSH
81936: LD_VAR 0 7
81940: PUSH
81941: LD_INT 22
81943: PUSH
81944: LD_VAR 0 5
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 91
81955: PUSH
81956: LD_VAR 0 3
81960: PUSH
81961: LD_INT 15
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 21
81971: PUSH
81972: LD_INT 2
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 3
81981: PUSH
81982: LD_INT 60
81984: PUSH
81985: EMPTY
81986: LIST
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: LD_INT 3
81994: PUSH
81995: LD_INT 24
81997: PUSH
81998: LD_INT 1000
82000: PUSH
82001: EMPTY
82002: LIST
82003: LIST
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: PPUSH
82016: CALL_OW 69
82020: UNION
82021: ST_TO_ADDR
82022: GO 81928
82024: POP
82025: POP
// if not vehs then
82026: LD_VAR 0 7
82030: NOT
82031: IFFALSE 82057
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
82033: LD_ADDR_EXP 43
82037: PUSH
82038: LD_EXP 43
82042: PPUSH
82043: LD_VAR 0 2
82047: PPUSH
82048: EMPTY
82049: PPUSH
82050: CALL_OW 1
82054: ST_TO_ADDR
// continue ;
82055: GO 81685
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
82057: LD_ADDR_VAR 0 8
82061: PUSH
82062: LD_EXP 31
82066: PUSH
82067: LD_VAR 0 2
82071: ARRAY
82072: PPUSH
82073: LD_INT 30
82075: PUSH
82076: LD_INT 3
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PPUSH
82083: CALL_OW 72
82087: ST_TO_ADDR
// if tmp then
82088: LD_VAR 0 8
82092: IFFALSE 82195
// begin for j in tmp do
82094: LD_ADDR_VAR 0 3
82098: PUSH
82099: LD_VAR 0 8
82103: PUSH
82104: FOR_IN
82105: IFFALSE 82193
// for k in UnitsInside ( j ) do
82107: LD_ADDR_VAR 0 4
82111: PUSH
82112: LD_VAR 0 3
82116: PPUSH
82117: CALL_OW 313
82121: PUSH
82122: FOR_IN
82123: IFFALSE 82189
// if k then
82125: LD_VAR 0 4
82129: IFFALSE 82187
// if not k in mc_repair_vehicle [ i ] then
82131: LD_VAR 0 4
82135: PUSH
82136: LD_EXP 43
82140: PUSH
82141: LD_VAR 0 2
82145: ARRAY
82146: IN
82147: NOT
82148: IFFALSE 82187
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
82150: LD_ADDR_EXP 43
82154: PUSH
82155: LD_EXP 43
82159: PPUSH
82160: LD_VAR 0 2
82164: PPUSH
82165: LD_EXP 43
82169: PUSH
82170: LD_VAR 0 2
82174: ARRAY
82175: PUSH
82176: LD_VAR 0 4
82180: UNION
82181: PPUSH
82182: CALL_OW 1
82186: ST_TO_ADDR
82187: GO 82122
82189: POP
82190: POP
82191: GO 82104
82193: POP
82194: POP
// end ; if not mc_repair_vehicle [ i ] then
82195: LD_EXP 43
82199: PUSH
82200: LD_VAR 0 2
82204: ARRAY
82205: NOT
82206: IFFALSE 82210
// continue ;
82208: GO 81685
// for j in mc_repair_vehicle [ i ] do
82210: LD_ADDR_VAR 0 3
82214: PUSH
82215: LD_EXP 43
82219: PUSH
82220: LD_VAR 0 2
82224: ARRAY
82225: PUSH
82226: FOR_IN
82227: IFFALSE 82408
// begin if GetClass ( j ) <> 3 then
82229: LD_VAR 0 3
82233: PPUSH
82234: CALL_OW 257
82238: PUSH
82239: LD_INT 3
82241: NONEQUAL
82242: IFFALSE 82283
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
82244: LD_ADDR_EXP 43
82248: PUSH
82249: LD_EXP 43
82253: PPUSH
82254: LD_VAR 0 2
82258: PPUSH
82259: LD_EXP 43
82263: PUSH
82264: LD_VAR 0 2
82268: ARRAY
82269: PUSH
82270: LD_VAR 0 3
82274: DIFF
82275: PPUSH
82276: CALL_OW 1
82280: ST_TO_ADDR
// continue ;
82281: GO 82226
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
82283: LD_VAR 0 3
82287: PPUSH
82288: CALL_OW 311
82292: NOT
82293: IFFALSE 82318
82295: PUSH
82296: LD_VAR 0 3
82300: PUSH
82301: LD_EXP 34
82305: PUSH
82306: LD_VAR 0 2
82310: ARRAY
82311: PUSH
82312: LD_INT 1
82314: ARRAY
82315: IN
82316: NOT
82317: AND
82318: IFFALSE 82343
82320: PUSH
82321: LD_VAR 0 3
82325: PUSH
82326: LD_EXP 34
82330: PUSH
82331: LD_VAR 0 2
82335: ARRAY
82336: PUSH
82337: LD_INT 2
82339: ARRAY
82340: IN
82341: NOT
82342: AND
82343: IFFALSE 82406
// begin if IsInUnit ( j ) then
82345: LD_VAR 0 3
82349: PPUSH
82350: CALL_OW 310
82354: IFFALSE 82367
// ComExitBuilding ( j ) else
82356: LD_VAR 0 3
82360: PPUSH
82361: CALL_OW 122
82365: GO 82406
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
82367: LD_VAR 0 3
82371: PPUSH
82372: LD_VAR 0 7
82376: PUSH
82377: LD_INT 1
82379: ARRAY
82380: PPUSH
82381: CALL 60194 0 2
82385: NOT
82386: IFFALSE 82406
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
82388: LD_VAR 0 3
82392: PPUSH
82393: LD_VAR 0 7
82397: PUSH
82398: LD_INT 1
82400: ARRAY
82401: PPUSH
82402: CALL_OW 129
// end ; end ;
82406: GO 82226
82408: POP
82409: POP
// end ;
82410: GO 81685
82412: POP
82413: POP
// end ;
82414: LD_VAR 0 1
82418: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
82419: LD_INT 0
82421: PPUSH
82422: PPUSH
82423: PPUSH
82424: PPUSH
82425: PPUSH
82426: PPUSH
82427: PPUSH
82428: PPUSH
82429: PPUSH
82430: PPUSH
82431: PPUSH
// if not mc_bases then
82432: LD_EXP 31
82436: NOT
82437: IFFALSE 82441
// exit ;
82439: GO 83259
// for i = 1 to mc_bases do
82441: LD_ADDR_VAR 0 2
82445: PUSH
82446: DOUBLE
82447: LD_INT 1
82449: DEC
82450: ST_TO_ADDR
82451: LD_EXP 31
82455: PUSH
82456: FOR_TO
82457: IFFALSE 83257
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
82459: LD_EXP 59
82463: PUSH
82464: LD_VAR 0 2
82468: ARRAY
82469: NOT
82470: IFTRUE 82488
82472: PUSH
82473: LD_EXP 34
82477: PUSH
82478: LD_VAR 0 2
82482: ARRAY
82483: PUSH
82484: LD_INT 1
82486: ARRAY
82487: OR
82488: IFTRUE 82506
82490: PUSH
82491: LD_EXP 34
82495: PUSH
82496: LD_VAR 0 2
82500: ARRAY
82501: PUSH
82502: LD_INT 2
82504: ARRAY
82505: OR
82506: IFTRUE 82529
82508: PUSH
82509: LD_EXP 57
82513: PUSH
82514: LD_VAR 0 2
82518: ARRAY
82519: PPUSH
82520: LD_INT 1
82522: PPUSH
82523: CALL_OW 325
82527: NOT
82528: OR
82529: IFTRUE 82543
82531: PUSH
82532: LD_EXP 54
82536: PUSH
82537: LD_VAR 0 2
82541: ARRAY
82542: OR
82543: IFFALSE 82547
// continue ;
82545: GO 82456
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
82547: LD_ADDR_VAR 0 8
82551: PUSH
82552: LD_EXP 31
82556: PUSH
82557: LD_VAR 0 2
82561: ARRAY
82562: PPUSH
82563: LD_INT 25
82565: PUSH
82566: LD_INT 4
82568: PUSH
82569: EMPTY
82570: LIST
82571: LIST
82572: PUSH
82573: LD_INT 50
82575: PUSH
82576: EMPTY
82577: LIST
82578: PUSH
82579: LD_INT 3
82581: PUSH
82582: LD_INT 60
82584: PUSH
82585: EMPTY
82586: LIST
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: LIST
82596: PPUSH
82597: CALL_OW 72
82601: PUSH
82602: LD_EXP 35
82606: PUSH
82607: LD_VAR 0 2
82611: ARRAY
82612: DIFF
82613: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82614: LD_ADDR_VAR 0 9
82618: PUSH
82619: LD_EXP 31
82623: PUSH
82624: LD_VAR 0 2
82628: ARRAY
82629: PPUSH
82630: LD_INT 2
82632: PUSH
82633: LD_INT 30
82635: PUSH
82636: LD_INT 0
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 30
82645: PUSH
82646: LD_INT 1
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: LIST
82657: PPUSH
82658: CALL_OW 72
82662: ST_TO_ADDR
// if not tmp or not dep then
82663: LD_VAR 0 8
82667: NOT
82668: IFTRUE 82677
82670: PUSH
82671: LD_VAR 0 9
82675: NOT
82676: OR
82677: IFFALSE 82681
// continue ;
82679: GO 82456
// side := GetSide ( tmp [ 1 ] ) ;
82681: LD_ADDR_VAR 0 11
82685: PUSH
82686: LD_VAR 0 8
82690: PUSH
82691: LD_INT 1
82693: ARRAY
82694: PPUSH
82695: CALL_OW 255
82699: ST_TO_ADDR
// dep := dep [ 1 ] ;
82700: LD_ADDR_VAR 0 9
82704: PUSH
82705: LD_VAR 0 9
82709: PUSH
82710: LD_INT 1
82712: ARRAY
82713: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
82714: LD_ADDR_VAR 0 7
82718: PUSH
82719: LD_EXP 59
82723: PUSH
82724: LD_VAR 0 2
82728: ARRAY
82729: PPUSH
82730: LD_INT 22
82732: PUSH
82733: LD_INT 0
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 25
82742: PUSH
82743: LD_INT 12
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: EMPTY
82751: LIST
82752: LIST
82753: PPUSH
82754: CALL_OW 70
82758: PUSH
82759: LD_INT 22
82761: PUSH
82762: LD_INT 0
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 25
82771: PUSH
82772: LD_INT 12
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 91
82781: PUSH
82782: LD_VAR 0 9
82786: PUSH
82787: LD_INT 20
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: LIST
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: LIST
82799: PPUSH
82800: CALL_OW 69
82804: UNION
82805: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
82806: LD_ADDR_VAR 0 10
82810: PUSH
82811: LD_EXP 59
82815: PUSH
82816: LD_VAR 0 2
82820: ARRAY
82821: PPUSH
82822: LD_INT 81
82824: PUSH
82825: LD_VAR 0 11
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PPUSH
82834: CALL_OW 70
82838: ST_TO_ADDR
// if not apes or danger_at_area then
82839: LD_VAR 0 7
82843: NOT
82844: IFTRUE 82852
82846: PUSH
82847: LD_VAR 0 10
82851: OR
82852: IFFALSE 82902
// begin if mc_taming [ i ] then
82854: LD_EXP 62
82858: PUSH
82859: LD_VAR 0 2
82863: ARRAY
82864: IFFALSE 82900
// begin MC_Reset ( i , 121 ) ;
82866: LD_VAR 0 2
82870: PPUSH
82871: LD_INT 121
82873: PPUSH
82874: CALL 67634 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
82878: LD_ADDR_EXP 62
82882: PUSH
82883: LD_EXP 62
82887: PPUSH
82888: LD_VAR 0 2
82892: PPUSH
82893: EMPTY
82894: PPUSH
82895: CALL_OW 1
82899: ST_TO_ADDR
// end ; continue ;
82900: GO 82456
// end ; for j in tmp do
82902: LD_ADDR_VAR 0 3
82906: PUSH
82907: LD_VAR 0 8
82911: PUSH
82912: FOR_IN
82913: IFFALSE 83253
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
82915: LD_VAR 0 3
82919: PUSH
82920: LD_EXP 62
82924: PUSH
82925: LD_VAR 0 2
82929: ARRAY
82930: IN
82931: NOT
82932: IFFALSE 82950
82934: PUSH
82935: LD_EXP 62
82939: PUSH
82940: LD_VAR 0 2
82944: ARRAY
82945: PUSH
82946: LD_INT 3
82948: LESS
82949: AND
82950: IFFALSE 83008
// begin SetTag ( j , 121 ) ;
82952: LD_VAR 0 3
82956: PPUSH
82957: LD_INT 121
82959: PPUSH
82960: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
82964: LD_ADDR_EXP 62
82968: PUSH
82969: LD_EXP 62
82973: PPUSH
82974: LD_VAR 0 2
82978: PUSH
82979: LD_EXP 62
82983: PUSH
82984: LD_VAR 0 2
82988: ARRAY
82989: PUSH
82990: LD_INT 1
82992: PLUS
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PPUSH
82998: LD_VAR 0 3
83002: PPUSH
83003: CALL 25063 0 3
83007: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
83008: LD_VAR 0 3
83012: PUSH
83013: LD_EXP 62
83017: PUSH
83018: LD_VAR 0 2
83022: ARRAY
83023: IN
83024: IFFALSE 83251
// begin if GetClass ( j ) <> 4 then
83026: LD_VAR 0 3
83030: PPUSH
83031: CALL_OW 257
83035: PUSH
83036: LD_INT 4
83038: NONEQUAL
83039: IFFALSE 83092
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
83041: LD_ADDR_EXP 62
83045: PUSH
83046: LD_EXP 62
83050: PPUSH
83051: LD_VAR 0 2
83055: PPUSH
83056: LD_EXP 62
83060: PUSH
83061: LD_VAR 0 2
83065: ARRAY
83066: PUSH
83067: LD_VAR 0 3
83071: DIFF
83072: PPUSH
83073: CALL_OW 1
83077: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83078: LD_VAR 0 3
83082: PPUSH
83083: LD_INT 0
83085: PPUSH
83086: CALL_OW 109
// continue ;
83090: GO 82912
// end ; if IsInUnit ( j ) then
83092: LD_VAR 0 3
83096: PPUSH
83097: CALL_OW 310
83101: IFFALSE 83112
// ComExitBuilding ( j ) ;
83103: LD_VAR 0 3
83107: PPUSH
83108: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
83112: LD_ADDR_VAR 0 6
83116: PUSH
83117: LD_VAR 0 7
83121: PPUSH
83122: LD_VAR 0 3
83126: PPUSH
83127: CALL_OW 74
83131: ST_TO_ADDR
// if not ape then
83132: LD_VAR 0 6
83136: NOT
83137: IFFALSE 83141
// break ;
83139: GO 83253
// x := GetX ( ape ) ;
83141: LD_ADDR_VAR 0 4
83145: PUSH
83146: LD_VAR 0 6
83150: PPUSH
83151: CALL_OW 250
83155: ST_TO_ADDR
// y := GetY ( ape ) ;
83156: LD_ADDR_VAR 0 5
83160: PUSH
83161: LD_VAR 0 6
83165: PPUSH
83166: CALL_OW 251
83170: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
83171: LD_VAR 0 4
83175: PPUSH
83176: LD_VAR 0 5
83180: PPUSH
83181: CALL_OW 488
83185: NOT
83186: IFTRUE 83216
83188: PUSH
83189: LD_VAR 0 11
83193: PPUSH
83194: LD_VAR 0 4
83198: PPUSH
83199: LD_VAR 0 5
83203: PPUSH
83204: LD_INT 20
83206: PPUSH
83207: CALL 26333 0 4
83211: PUSH
83212: LD_INT 4
83214: ARRAY
83215: OR
83216: IFFALSE 83220
// break ;
83218: GO 83253
// if not HasTask ( j ) then
83220: LD_VAR 0 3
83224: PPUSH
83225: CALL_OW 314
83229: NOT
83230: IFFALSE 83251
// ComTameXY ( j , x , y ) ;
83232: LD_VAR 0 3
83236: PPUSH
83237: LD_VAR 0 4
83241: PPUSH
83242: LD_VAR 0 5
83246: PPUSH
83247: CALL_OW 131
// end ; end ;
83251: GO 82912
83253: POP
83254: POP
// end ;
83255: GO 82456
83257: POP
83258: POP
// end ;
83259: LD_VAR 0 1
83263: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
83264: LD_INT 0
83266: PPUSH
83267: PPUSH
83268: PPUSH
83269: PPUSH
83270: PPUSH
83271: PPUSH
83272: PPUSH
83273: PPUSH
// if not mc_bases then
83274: LD_EXP 31
83278: NOT
83279: IFFALSE 83283
// exit ;
83281: GO 83915
// for i = 1 to mc_bases do
83283: LD_ADDR_VAR 0 2
83287: PUSH
83288: DOUBLE
83289: LD_INT 1
83291: DEC
83292: ST_TO_ADDR
83293: LD_EXP 31
83297: PUSH
83298: FOR_TO
83299: IFFALSE 83913
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
83301: LD_EXP 60
83305: PUSH
83306: LD_VAR 0 2
83310: ARRAY
83311: NOT
83312: IFTRUE 83342
83314: PUSH
83315: LD_EXP 60
83319: PUSH
83320: LD_VAR 0 2
83324: ARRAY
83325: PPUSH
83326: LD_INT 25
83328: PUSH
83329: LD_INT 12
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PPUSH
83336: CALL_OW 72
83340: NOT
83341: OR
83342: IFFALSE 83346
// continue ;
83344: GO 83298
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
83346: LD_ADDR_VAR 0 5
83350: PUSH
83351: LD_EXP 60
83355: PUSH
83356: LD_VAR 0 2
83360: ARRAY
83361: PUSH
83362: LD_INT 1
83364: ARRAY
83365: PPUSH
83366: CALL_OW 255
83370: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
83371: LD_VAR 0 5
83375: PPUSH
83376: LD_INT 2
83378: PPUSH
83379: CALL_OW 325
83383: IFFALSE 83636
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
83385: LD_ADDR_VAR 0 4
83389: PUSH
83390: LD_EXP 60
83394: PUSH
83395: LD_VAR 0 2
83399: ARRAY
83400: PPUSH
83401: LD_INT 25
83403: PUSH
83404: LD_INT 16
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: PPUSH
83411: CALL_OW 72
83415: ST_TO_ADDR
// if tmp < 6 then
83416: LD_VAR 0 4
83420: PUSH
83421: LD_INT 6
83423: LESS
83424: IFFALSE 83636
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83426: LD_ADDR_VAR 0 6
83430: PUSH
83431: LD_EXP 31
83435: PUSH
83436: LD_VAR 0 2
83440: ARRAY
83441: PPUSH
83442: LD_INT 2
83444: PUSH
83445: LD_INT 30
83447: PUSH
83448: LD_INT 0
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 30
83457: PUSH
83458: LD_INT 1
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: LIST
83469: PPUSH
83470: CALL_OW 72
83474: ST_TO_ADDR
// if depot then
83475: LD_VAR 0 6
83479: IFFALSE 83636
// begin selected := 0 ;
83481: LD_ADDR_VAR 0 7
83485: PUSH
83486: LD_INT 0
83488: ST_TO_ADDR
// for j in depot do
83489: LD_ADDR_VAR 0 3
83493: PUSH
83494: LD_VAR 0 6
83498: PUSH
83499: FOR_IN
83500: IFFALSE 83531
// begin if UnitsInside ( j ) < 6 then
83502: LD_VAR 0 3
83506: PPUSH
83507: CALL_OW 313
83511: PUSH
83512: LD_INT 6
83514: LESS
83515: IFFALSE 83529
// begin selected := j ;
83517: LD_ADDR_VAR 0 7
83521: PUSH
83522: LD_VAR 0 3
83526: ST_TO_ADDR
// break ;
83527: GO 83531
// end ; end ;
83529: GO 83499
83531: POP
83532: POP
// if selected then
83533: LD_VAR 0 7
83537: IFFALSE 83636
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
83539: LD_ADDR_VAR 0 3
83543: PUSH
83544: LD_EXP 60
83548: PUSH
83549: LD_VAR 0 2
83553: ARRAY
83554: PPUSH
83555: LD_INT 25
83557: PUSH
83558: LD_INT 12
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PPUSH
83565: CALL_OW 72
83569: PUSH
83570: FOR_IN
83571: IFFALSE 83634
// if not HasTask ( j ) then
83573: LD_VAR 0 3
83577: PPUSH
83578: CALL_OW 314
83582: NOT
83583: IFFALSE 83632
// begin if not IsInUnit ( j ) then
83585: LD_VAR 0 3
83589: PPUSH
83590: CALL_OW 310
83594: NOT
83595: IFFALSE 83611
// ComEnterUnit ( j , selected ) ;
83597: LD_VAR 0 3
83601: PPUSH
83602: LD_VAR 0 7
83606: PPUSH
83607: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
83611: LD_VAR 0 3
83615: PPUSH
83616: LD_INT 16
83618: PPUSH
83619: CALL_OW 183
// AddComExitBuilding ( j ) ;
83623: LD_VAR 0 3
83627: PPUSH
83628: CALL_OW 182
// end ;
83632: GO 83570
83634: POP
83635: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
83636: LD_VAR 0 5
83640: PPUSH
83641: LD_INT 11
83643: PPUSH
83644: CALL_OW 325
83648: IFFALSE 83911
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
83650: LD_ADDR_VAR 0 4
83654: PUSH
83655: LD_EXP 60
83659: PUSH
83660: LD_VAR 0 2
83664: ARRAY
83665: PPUSH
83666: LD_INT 25
83668: PUSH
83669: LD_INT 16
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PPUSH
83676: CALL_OW 72
83680: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
83681: LD_VAR 0 4
83685: PUSH
83686: LD_INT 6
83688: GREATEREQUAL
83689: IFTRUE 83706
83691: PUSH
83692: LD_VAR 0 5
83696: PPUSH
83697: LD_INT 2
83699: PPUSH
83700: CALL_OW 325
83704: NOT
83705: OR
83706: IFFALSE 83911
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83708: LD_ADDR_VAR 0 8
83712: PUSH
83713: LD_EXP 31
83717: PUSH
83718: LD_VAR 0 2
83722: ARRAY
83723: PPUSH
83724: LD_INT 2
83726: PUSH
83727: LD_INT 30
83729: PUSH
83730: LD_INT 4
83732: PUSH
83733: EMPTY
83734: LIST
83735: LIST
83736: PUSH
83737: LD_INT 30
83739: PUSH
83740: LD_INT 5
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: LIST
83751: PPUSH
83752: CALL_OW 72
83756: ST_TO_ADDR
// if barracks then
83757: LD_VAR 0 8
83761: IFFALSE 83911
// begin selected := 0 ;
83763: LD_ADDR_VAR 0 7
83767: PUSH
83768: LD_INT 0
83770: ST_TO_ADDR
// for j in barracks do
83771: LD_ADDR_VAR 0 3
83775: PUSH
83776: LD_VAR 0 8
83780: PUSH
83781: FOR_IN
83782: IFFALSE 83813
// begin if UnitsInside ( j ) < 6 then
83784: LD_VAR 0 3
83788: PPUSH
83789: CALL_OW 313
83793: PUSH
83794: LD_INT 6
83796: LESS
83797: IFFALSE 83811
// begin selected := j ;
83799: LD_ADDR_VAR 0 7
83803: PUSH
83804: LD_VAR 0 3
83808: ST_TO_ADDR
// break ;
83809: GO 83813
// end ; end ;
83811: GO 83781
83813: POP
83814: POP
// if selected then
83815: LD_VAR 0 7
83819: IFFALSE 83911
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
83821: LD_ADDR_VAR 0 3
83825: PUSH
83826: LD_EXP 60
83830: PUSH
83831: LD_VAR 0 2
83835: ARRAY
83836: PPUSH
83837: LD_INT 25
83839: PUSH
83840: LD_INT 12
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PPUSH
83847: CALL_OW 72
83851: PUSH
83852: FOR_IN
83853: IFFALSE 83909
// if not IsInUnit ( j ) and not HasTask ( j ) then
83855: LD_VAR 0 3
83859: PPUSH
83860: CALL_OW 310
83864: NOT
83865: IFFALSE 83879
83867: PUSH
83868: LD_VAR 0 3
83872: PPUSH
83873: CALL_OW 314
83877: NOT
83878: AND
83879: IFFALSE 83907
// begin ComEnterUnit ( j , selected ) ;
83881: LD_VAR 0 3
83885: PPUSH
83886: LD_VAR 0 7
83890: PPUSH
83891: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
83895: LD_VAR 0 3
83899: PPUSH
83900: LD_INT 15
83902: PPUSH
83903: CALL_OW 183
// end ;
83907: GO 83852
83909: POP
83910: POP
// end ; end ; end ; end ; end ;
83911: GO 83298
83913: POP
83914: POP
// end ;
83915: LD_VAR 0 1
83919: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
83920: LD_INT 0
83922: PPUSH
83923: PPUSH
83924: PPUSH
83925: PPUSH
// if not mc_bases then
83926: LD_EXP 31
83930: NOT
83931: IFFALSE 83935
// exit ;
83933: GO 84117
// for i = 1 to mc_bases do
83935: LD_ADDR_VAR 0 2
83939: PUSH
83940: DOUBLE
83941: LD_INT 1
83943: DEC
83944: ST_TO_ADDR
83945: LD_EXP 31
83949: PUSH
83950: FOR_TO
83951: IFFALSE 84115
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
83953: LD_ADDR_VAR 0 4
83957: PUSH
83958: LD_EXP 31
83962: PUSH
83963: LD_VAR 0 2
83967: ARRAY
83968: PPUSH
83969: LD_INT 25
83971: PUSH
83972: LD_INT 9
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PPUSH
83979: CALL_OW 72
83983: ST_TO_ADDR
// if not tmp then
83984: LD_VAR 0 4
83988: NOT
83989: IFFALSE 83993
// continue ;
83991: GO 83950
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
83993: LD_EXP 57
83997: PUSH
83998: LD_VAR 0 2
84002: ARRAY
84003: PPUSH
84004: LD_INT 29
84006: PPUSH
84007: CALL_OW 325
84011: NOT
84012: IFFALSE 84035
84014: PUSH
84015: LD_EXP 57
84019: PUSH
84020: LD_VAR 0 2
84024: ARRAY
84025: PPUSH
84026: LD_INT 28
84028: PPUSH
84029: CALL_OW 325
84033: NOT
84034: AND
84035: IFFALSE 84039
// continue ;
84037: GO 83950
// for j in tmp do
84039: LD_ADDR_VAR 0 3
84043: PUSH
84044: LD_VAR 0 4
84048: PUSH
84049: FOR_IN
84050: IFFALSE 84111
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
84052: LD_VAR 0 3
84056: PUSH
84057: LD_EXP 34
84061: PUSH
84062: LD_VAR 0 2
84066: ARRAY
84067: PUSH
84068: LD_INT 1
84070: ARRAY
84071: IN
84072: NOT
84073: IFFALSE 84098
84075: PUSH
84076: LD_VAR 0 3
84080: PUSH
84081: LD_EXP 34
84085: PUSH
84086: LD_VAR 0 2
84090: ARRAY
84091: PUSH
84092: LD_INT 2
84094: ARRAY
84095: IN
84096: NOT
84097: AND
84098: IFFALSE 84109
// ComSpaceTimeShoot ( j ) ;
84100: LD_VAR 0 3
84104: PPUSH
84105: CALL 21014 0 1
84109: GO 84049
84111: POP
84112: POP
// end ;
84113: GO 83950
84115: POP
84116: POP
// end ;
84117: LD_VAR 0 1
84121: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
84122: LD_INT 0
84124: PPUSH
84125: PPUSH
84126: PPUSH
84127: PPUSH
84128: PPUSH
84129: PPUSH
84130: PPUSH
84131: PPUSH
84132: PPUSH
// if not mc_bases then
84133: LD_EXP 31
84137: NOT
84138: IFFALSE 84142
// exit ;
84140: GO 84774
// for i = 1 to mc_bases do
84142: LD_ADDR_VAR 0 2
84146: PUSH
84147: DOUBLE
84148: LD_INT 1
84150: DEC
84151: ST_TO_ADDR
84152: LD_EXP 31
84156: PUSH
84157: FOR_TO
84158: IFFALSE 84772
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
84160: LD_EXP 66
84164: PUSH
84165: LD_VAR 0 2
84169: ARRAY
84170: NOT
84171: IFTRUE 84197
84173: PUSH
84174: LD_INT 38
84176: PPUSH
84177: LD_EXP 57
84181: PUSH
84182: LD_VAR 0 2
84186: ARRAY
84187: PPUSH
84188: CALL_OW 321
84192: PUSH
84193: LD_INT 2
84195: NONEQUAL
84196: OR
84197: IFFALSE 84201
// continue ;
84199: GO 84157
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
84201: LD_ADDR_VAR 0 8
84205: PUSH
84206: LD_EXP 31
84210: PUSH
84211: LD_VAR 0 2
84215: ARRAY
84216: PPUSH
84217: LD_INT 30
84219: PUSH
84220: LD_INT 34
84222: PUSH
84223: EMPTY
84224: LIST
84225: LIST
84226: PPUSH
84227: CALL_OW 72
84231: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
84232: LD_ADDR_VAR 0 9
84236: PUSH
84237: LD_EXP 31
84241: PUSH
84242: LD_VAR 0 2
84246: ARRAY
84247: PPUSH
84248: LD_INT 25
84250: PUSH
84251: LD_INT 4
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PPUSH
84258: CALL_OW 72
84262: PPUSH
84263: LD_INT 0
84265: PPUSH
84266: CALL 55656 0 2
84270: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
84271: LD_VAR 0 9
84275: NOT
84276: IFTRUE 84285
84278: PUSH
84279: LD_VAR 0 8
84283: NOT
84284: OR
84285: IFTRUE 84307
84287: PUSH
84288: LD_EXP 31
84292: PUSH
84293: LD_VAR 0 2
84297: ARRAY
84298: PPUSH
84299: LD_INT 124
84301: PPUSH
84302: CALL 55656 0 2
84306: OR
84307: IFFALSE 84311
// continue ;
84309: GO 84157
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
84311: LD_EXP 67
84315: PUSH
84316: LD_VAR 0 2
84320: ARRAY
84321: PUSH
84322: LD_EXP 66
84326: PUSH
84327: LD_VAR 0 2
84331: ARRAY
84332: LESS
84333: IFFALSE 84353
84335: PUSH
84336: LD_EXP 67
84340: PUSH
84341: LD_VAR 0 2
84345: ARRAY
84346: PUSH
84347: LD_VAR 0 8
84351: LESS
84352: AND
84353: IFFALSE 84770
// begin tmp := sci [ 1 ] ;
84355: LD_ADDR_VAR 0 7
84359: PUSH
84360: LD_VAR 0 9
84364: PUSH
84365: LD_INT 1
84367: ARRAY
84368: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
84369: LD_VAR 0 7
84373: PPUSH
84374: LD_INT 124
84376: PPUSH
84377: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
84381: LD_ADDR_VAR 0 3
84385: PUSH
84386: DOUBLE
84387: LD_EXP 66
84391: PUSH
84392: LD_VAR 0 2
84396: ARRAY
84397: INC
84398: ST_TO_ADDR
84399: LD_EXP 66
84403: PUSH
84404: LD_VAR 0 2
84408: ARRAY
84409: PUSH
84410: FOR_DOWNTO
84411: IFFALSE 84756
// begin if IsInUnit ( tmp ) then
84413: LD_VAR 0 7
84417: PPUSH
84418: CALL_OW 310
84422: IFFALSE 84433
// ComExitBuilding ( tmp ) ;
84424: LD_VAR 0 7
84428: PPUSH
84429: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
84433: LD_INT 35
84435: PPUSH
84436: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
84440: LD_VAR 0 7
84444: PPUSH
84445: CALL_OW 310
84449: NOT
84450: IFFALSE 84464
84452: PUSH
84453: LD_VAR 0 7
84457: PPUSH
84458: CALL_OW 314
84462: NOT
84463: AND
84464: IFFALSE 84433
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
84466: LD_ADDR_VAR 0 6
84470: PUSH
84471: LD_VAR 0 7
84475: PPUSH
84476: CALL_OW 250
84480: PUSH
84481: LD_VAR 0 7
84485: PPUSH
84486: CALL_OW 251
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
84495: LD_INT 35
84497: PPUSH
84498: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
84502: LD_ADDR_VAR 0 4
84506: PUSH
84507: LD_EXP 66
84511: PUSH
84512: LD_VAR 0 2
84516: ARRAY
84517: PUSH
84518: LD_VAR 0 3
84522: ARRAY
84523: PUSH
84524: LD_INT 1
84526: ARRAY
84527: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
84528: LD_ADDR_VAR 0 5
84532: PUSH
84533: LD_EXP 66
84537: PUSH
84538: LD_VAR 0 2
84542: ARRAY
84543: PUSH
84544: LD_VAR 0 3
84548: ARRAY
84549: PUSH
84550: LD_INT 2
84552: ARRAY
84553: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
84554: LD_VAR 0 7
84558: PPUSH
84559: LD_INT 10
84561: PPUSH
84562: CALL 28042 0 2
84566: PUSH
84567: LD_INT 4
84569: ARRAY
84570: IFFALSE 84608
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
84572: LD_VAR 0 7
84576: PPUSH
84577: LD_VAR 0 6
84581: PUSH
84582: LD_INT 1
84584: ARRAY
84585: PPUSH
84586: LD_VAR 0 6
84590: PUSH
84591: LD_INT 2
84593: ARRAY
84594: PPUSH
84595: CALL_OW 111
// wait ( 0 0$10 ) ;
84599: LD_INT 350
84601: PPUSH
84602: CALL_OW 67
// end else
84606: GO 84634
// begin ComMoveXY ( tmp , x , y ) ;
84608: LD_VAR 0 7
84612: PPUSH
84613: LD_VAR 0 4
84617: PPUSH
84618: LD_VAR 0 5
84622: PPUSH
84623: CALL_OW 111
// wait ( 0 0$3 ) ;
84627: LD_INT 105
84629: PPUSH
84630: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
84634: LD_VAR 0 7
84638: PPUSH
84639: LD_VAR 0 4
84643: PPUSH
84644: LD_VAR 0 5
84648: PPUSH
84649: CALL_OW 307
84653: IFFALSE 84495
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
84655: LD_VAR 0 7
84659: PPUSH
84660: LD_VAR 0 4
84664: PPUSH
84665: LD_VAR 0 5
84669: PPUSH
84670: LD_VAR 0 8
84674: PUSH
84675: LD_VAR 0 3
84679: ARRAY
84680: PPUSH
84681: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
84685: LD_INT 35
84687: PPUSH
84688: CALL_OW 67
// until not HasTask ( tmp ) ;
84692: LD_VAR 0 7
84696: PPUSH
84697: CALL_OW 314
84701: NOT
84702: IFFALSE 84685
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
84704: LD_ADDR_EXP 67
84708: PUSH
84709: LD_EXP 67
84713: PPUSH
84714: LD_VAR 0 2
84718: PUSH
84719: LD_EXP 67
84723: PUSH
84724: LD_VAR 0 2
84728: ARRAY
84729: PUSH
84730: LD_INT 1
84732: PLUS
84733: PUSH
84734: EMPTY
84735: LIST
84736: LIST
84737: PPUSH
84738: LD_VAR 0 8
84742: PUSH
84743: LD_VAR 0 3
84747: ARRAY
84748: PPUSH
84749: CALL 25063 0 3
84753: ST_TO_ADDR
// end ;
84754: GO 84410
84756: POP
84757: POP
// MC_Reset ( i , 124 ) ;
84758: LD_VAR 0 2
84762: PPUSH
84763: LD_INT 124
84765: PPUSH
84766: CALL 67634 0 2
// end ; end ;
84770: GO 84157
84772: POP
84773: POP
// end ;
84774: LD_VAR 0 1
84778: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
84779: LD_INT 0
84781: PPUSH
84782: PPUSH
84783: PPUSH
// if not mc_bases then
84784: LD_EXP 31
84788: NOT
84789: IFFALSE 84793
// exit ;
84791: GO 85407
// for i = 1 to mc_bases do
84793: LD_ADDR_VAR 0 2
84797: PUSH
84798: DOUBLE
84799: LD_INT 1
84801: DEC
84802: ST_TO_ADDR
84803: LD_EXP 31
84807: PUSH
84808: FOR_TO
84809: IFFALSE 85405
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
84811: LD_ADDR_VAR 0 3
84815: PUSH
84816: LD_EXP 31
84820: PUSH
84821: LD_VAR 0 2
84825: ARRAY
84826: PPUSH
84827: LD_INT 25
84829: PUSH
84830: LD_INT 4
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PPUSH
84837: CALL_OW 72
84841: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84842: LD_VAR 0 3
84846: NOT
84847: IFTRUE 84862
84849: PUSH
84850: LD_EXP 68
84854: PUSH
84855: LD_VAR 0 2
84859: ARRAY
84860: NOT
84861: OR
84862: IFTRUE 84910
84864: PUSH
84865: LD_EXP 31
84869: PUSH
84870: LD_VAR 0 2
84874: ARRAY
84875: PPUSH
84876: LD_INT 2
84878: PUSH
84879: LD_INT 30
84881: PUSH
84882: LD_INT 0
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 30
84891: PUSH
84892: LD_INT 1
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: LIST
84903: PPUSH
84904: CALL_OW 72
84908: NOT
84909: OR
84910: IFFALSE 84960
// begin if mc_deposits_finder [ i ] then
84912: LD_EXP 69
84916: PUSH
84917: LD_VAR 0 2
84921: ARRAY
84922: IFFALSE 84958
// begin MC_Reset ( i , 125 ) ;
84924: LD_VAR 0 2
84928: PPUSH
84929: LD_INT 125
84931: PPUSH
84932: CALL 67634 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
84936: LD_ADDR_EXP 69
84940: PUSH
84941: LD_EXP 69
84945: PPUSH
84946: LD_VAR 0 2
84950: PPUSH
84951: EMPTY
84952: PPUSH
84953: CALL_OW 1
84957: ST_TO_ADDR
// end ; continue ;
84958: GO 84808
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
84960: LD_EXP 68
84964: PUSH
84965: LD_VAR 0 2
84969: ARRAY
84970: PUSH
84971: LD_INT 1
84973: ARRAY
84974: PUSH
84975: LD_INT 3
84977: ARRAY
84978: PUSH
84979: LD_INT 1
84981: EQUAL
84982: IFFALSE 85008
84984: PUSH
84985: LD_INT 20
84987: PPUSH
84988: LD_EXP 57
84992: PUSH
84993: LD_VAR 0 2
84997: ARRAY
84998: PPUSH
84999: CALL_OW 321
85003: PUSH
85004: LD_INT 2
85006: NONEQUAL
85007: AND
85008: IFFALSE 85058
// begin if mc_deposits_finder [ i ] then
85010: LD_EXP 69
85014: PUSH
85015: LD_VAR 0 2
85019: ARRAY
85020: IFFALSE 85056
// begin MC_Reset ( i , 125 ) ;
85022: LD_VAR 0 2
85026: PPUSH
85027: LD_INT 125
85029: PPUSH
85030: CALL 67634 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
85034: LD_ADDR_EXP 69
85038: PUSH
85039: LD_EXP 69
85043: PPUSH
85044: LD_VAR 0 2
85048: PPUSH
85049: EMPTY
85050: PPUSH
85051: CALL_OW 1
85055: ST_TO_ADDR
// end ; continue ;
85056: GO 84808
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
85058: LD_EXP 68
85062: PUSH
85063: LD_VAR 0 2
85067: ARRAY
85068: PUSH
85069: LD_INT 1
85071: ARRAY
85072: PUSH
85073: LD_INT 1
85075: ARRAY
85076: PPUSH
85077: LD_EXP 68
85081: PUSH
85082: LD_VAR 0 2
85086: ARRAY
85087: PUSH
85088: LD_INT 1
85090: ARRAY
85091: PUSH
85092: LD_INT 2
85094: ARRAY
85095: PPUSH
85096: LD_EXP 57
85100: PUSH
85101: LD_VAR 0 2
85105: ARRAY
85106: PPUSH
85107: CALL_OW 440
85111: IFFALSE 85154
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
85113: LD_ADDR_EXP 68
85117: PUSH
85118: LD_EXP 68
85122: PPUSH
85123: LD_VAR 0 2
85127: PPUSH
85128: LD_EXP 68
85132: PUSH
85133: LD_VAR 0 2
85137: ARRAY
85138: PPUSH
85139: LD_INT 1
85141: PPUSH
85142: CALL_OW 3
85146: PPUSH
85147: CALL_OW 1
85151: ST_TO_ADDR
85152: GO 85403
// begin if not mc_deposits_finder [ i ] then
85154: LD_EXP 69
85158: PUSH
85159: LD_VAR 0 2
85163: ARRAY
85164: NOT
85165: IFFALSE 85217
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
85167: LD_ADDR_EXP 69
85171: PUSH
85172: LD_EXP 69
85176: PPUSH
85177: LD_VAR 0 2
85181: PPUSH
85182: LD_VAR 0 3
85186: PUSH
85187: LD_INT 1
85189: ARRAY
85190: PUSH
85191: EMPTY
85192: LIST
85193: PPUSH
85194: CALL_OW 1
85198: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
85199: LD_VAR 0 3
85203: PUSH
85204: LD_INT 1
85206: ARRAY
85207: PPUSH
85208: LD_INT 125
85210: PPUSH
85211: CALL_OW 109
// end else
85215: GO 85403
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
85217: LD_EXP 69
85221: PUSH
85222: LD_VAR 0 2
85226: ARRAY
85227: PUSH
85228: LD_INT 1
85230: ARRAY
85231: PPUSH
85232: CALL_OW 310
85236: IFFALSE 85259
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
85238: LD_EXP 69
85242: PUSH
85243: LD_VAR 0 2
85247: ARRAY
85248: PUSH
85249: LD_INT 1
85251: ARRAY
85252: PPUSH
85253: CALL_OW 122
85257: GO 85403
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
85259: LD_EXP 69
85263: PUSH
85264: LD_VAR 0 2
85268: ARRAY
85269: PUSH
85270: LD_INT 1
85272: ARRAY
85273: PPUSH
85274: CALL_OW 314
85278: NOT
85279: IFFALSE 85344
85281: PUSH
85282: LD_EXP 69
85286: PUSH
85287: LD_VAR 0 2
85291: ARRAY
85292: PUSH
85293: LD_INT 1
85295: ARRAY
85296: PPUSH
85297: LD_EXP 68
85301: PUSH
85302: LD_VAR 0 2
85306: ARRAY
85307: PUSH
85308: LD_INT 1
85310: ARRAY
85311: PUSH
85312: LD_INT 1
85314: ARRAY
85315: PPUSH
85316: LD_EXP 68
85320: PUSH
85321: LD_VAR 0 2
85325: ARRAY
85326: PUSH
85327: LD_INT 1
85329: ARRAY
85330: PUSH
85331: LD_INT 2
85333: ARRAY
85334: PPUSH
85335: CALL_OW 297
85339: PUSH
85340: LD_INT 6
85342: GREATER
85343: AND
85344: IFFALSE 85403
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
85346: LD_EXP 69
85350: PUSH
85351: LD_VAR 0 2
85355: ARRAY
85356: PUSH
85357: LD_INT 1
85359: ARRAY
85360: PPUSH
85361: LD_EXP 68
85365: PUSH
85366: LD_VAR 0 2
85370: ARRAY
85371: PUSH
85372: LD_INT 1
85374: ARRAY
85375: PUSH
85376: LD_INT 1
85378: ARRAY
85379: PPUSH
85380: LD_EXP 68
85384: PUSH
85385: LD_VAR 0 2
85389: ARRAY
85390: PUSH
85391: LD_INT 1
85393: ARRAY
85394: PUSH
85395: LD_INT 2
85397: ARRAY
85398: PPUSH
85399: CALL_OW 111
// end ; end ; end ;
85403: GO 84808
85405: POP
85406: POP
// end ;
85407: LD_VAR 0 1
85411: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
85412: LD_INT 0
85414: PPUSH
85415: PPUSH
85416: PPUSH
85417: PPUSH
85418: PPUSH
85419: PPUSH
85420: PPUSH
85421: PPUSH
85422: PPUSH
85423: PPUSH
85424: PPUSH
// if not mc_bases then
85425: LD_EXP 31
85429: NOT
85430: IFFALSE 85434
// exit ;
85432: GO 86394
// for i = 1 to mc_bases do
85434: LD_ADDR_VAR 0 2
85438: PUSH
85439: DOUBLE
85440: LD_INT 1
85442: DEC
85443: ST_TO_ADDR
85444: LD_EXP 31
85448: PUSH
85449: FOR_TO
85450: IFFALSE 86392
// begin if not mc_bases [ i ] or mc_scan [ i ] then
85452: LD_EXP 31
85456: PUSH
85457: LD_VAR 0 2
85461: ARRAY
85462: NOT
85463: IFTRUE 85477
85465: PUSH
85466: LD_EXP 54
85470: PUSH
85471: LD_VAR 0 2
85475: ARRAY
85476: OR
85477: IFFALSE 85481
// continue ;
85479: GO 85449
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
85481: LD_ADDR_VAR 0 7
85485: PUSH
85486: LD_EXP 31
85490: PUSH
85491: LD_VAR 0 2
85495: ARRAY
85496: PUSH
85497: LD_INT 1
85499: ARRAY
85500: PPUSH
85501: CALL_OW 248
85505: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
85506: LD_VAR 0 7
85510: PUSH
85511: LD_INT 3
85513: EQUAL
85514: IFTRUE 85556
85516: PUSH
85517: LD_EXP 50
85521: PUSH
85522: LD_VAR 0 2
85526: ARRAY
85527: PUSH
85528: LD_EXP 53
85532: PUSH
85533: LD_VAR 0 2
85537: ARRAY
85538: UNION
85539: PPUSH
85540: LD_INT 33
85542: PUSH
85543: LD_INT 2
85545: PUSH
85546: EMPTY
85547: LIST
85548: LIST
85549: PPUSH
85550: CALL_OW 72
85554: NOT
85555: OR
85556: IFFALSE 85560
// continue ;
85558: GO 85449
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
85560: LD_ADDR_VAR 0 9
85564: PUSH
85565: LD_EXP 31
85569: PUSH
85570: LD_VAR 0 2
85574: ARRAY
85575: PPUSH
85576: LD_INT 30
85578: PUSH
85579: LD_INT 36
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PPUSH
85586: CALL_OW 72
85590: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
85591: LD_ADDR_VAR 0 10
85595: PUSH
85596: LD_EXP 50
85600: PUSH
85601: LD_VAR 0 2
85605: ARRAY
85606: PPUSH
85607: LD_INT 34
85609: PUSH
85610: LD_INT 31
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PPUSH
85617: CALL_OW 72
85621: ST_TO_ADDR
// if not cts and not mcts then
85622: LD_VAR 0 9
85626: NOT
85627: IFFALSE 85636
85629: PUSH
85630: LD_VAR 0 10
85634: NOT
85635: AND
85636: IFFALSE 85640
// continue ;
85638: GO 85449
// x := cts ;
85640: LD_ADDR_VAR 0 11
85644: PUSH
85645: LD_VAR 0 9
85649: ST_TO_ADDR
// if not x then
85650: LD_VAR 0 11
85654: NOT
85655: IFFALSE 85667
// x := mcts ;
85657: LD_ADDR_VAR 0 11
85661: PUSH
85662: LD_VAR 0 10
85666: ST_TO_ADDR
// if not x then
85667: LD_VAR 0 11
85671: NOT
85672: IFFALSE 85676
// continue ;
85674: GO 85449
// if mc_remote_driver [ i ] then
85676: LD_EXP 71
85680: PUSH
85681: LD_VAR 0 2
85685: ARRAY
85686: IFFALSE 86085
// for j in mc_remote_driver [ i ] do
85688: LD_ADDR_VAR 0 3
85692: PUSH
85693: LD_EXP 71
85697: PUSH
85698: LD_VAR 0 2
85702: ARRAY
85703: PUSH
85704: FOR_IN
85705: IFFALSE 86083
// begin if GetClass ( j ) <> 3 then
85707: LD_VAR 0 3
85711: PPUSH
85712: CALL_OW 257
85716: PUSH
85717: LD_INT 3
85719: NONEQUAL
85720: IFFALSE 85773
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
85722: LD_ADDR_EXP 71
85726: PUSH
85727: LD_EXP 71
85731: PPUSH
85732: LD_VAR 0 2
85736: PPUSH
85737: LD_EXP 71
85741: PUSH
85742: LD_VAR 0 2
85746: ARRAY
85747: PUSH
85748: LD_VAR 0 3
85752: DIFF
85753: PPUSH
85754: CALL_OW 1
85758: ST_TO_ADDR
// SetTag ( j , 0 ) ;
85759: LD_VAR 0 3
85763: PPUSH
85764: LD_INT 0
85766: PPUSH
85767: CALL_OW 109
// continue ;
85771: GO 85704
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
85773: LD_EXP 50
85777: PUSH
85778: LD_VAR 0 2
85782: ARRAY
85783: PPUSH
85784: LD_INT 34
85786: PUSH
85787: LD_INT 31
85789: PUSH
85790: EMPTY
85791: LIST
85792: LIST
85793: PUSH
85794: LD_INT 58
85796: PUSH
85797: EMPTY
85798: LIST
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: PPUSH
85804: CALL_OW 72
85808: IFFALSE 85822
85810: PUSH
85811: LD_VAR 0 3
85815: PPUSH
85816: CALL 55691 0 1
85820: NOT
85821: AND
85822: IFFALSE 85893
// begin if IsInUnit ( j ) then
85824: LD_VAR 0 3
85828: PPUSH
85829: CALL_OW 310
85833: IFFALSE 85844
// ComExitBuilding ( j ) ;
85835: LD_VAR 0 3
85839: PPUSH
85840: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
85844: LD_VAR 0 3
85848: PPUSH
85849: LD_EXP 50
85853: PUSH
85854: LD_VAR 0 2
85858: ARRAY
85859: PPUSH
85860: LD_INT 34
85862: PUSH
85863: LD_INT 31
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 58
85872: PUSH
85873: EMPTY
85874: LIST
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PPUSH
85880: CALL_OW 72
85884: PUSH
85885: LD_INT 1
85887: ARRAY
85888: PPUSH
85889: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
85893: LD_VAR 0 3
85897: PPUSH
85898: CALL_OW 310
85902: NOT
85903: IFTRUE 85939
85905: PUSH
85906: LD_VAR 0 3
85910: PPUSH
85911: CALL_OW 310
85915: PPUSH
85916: CALL_OW 266
85920: PUSH
85921: LD_INT 36
85923: NONEQUAL
85924: IFFALSE 85938
85926: PUSH
85927: LD_VAR 0 3
85931: PPUSH
85932: CALL 55691 0 1
85936: NOT
85937: AND
85938: OR
85939: IFFALSE 86081
// begin if IsInUnit ( j ) then
85941: LD_VAR 0 3
85945: PPUSH
85946: CALL_OW 310
85950: IFFALSE 85961
// ComExitBuilding ( j ) ;
85952: LD_VAR 0 3
85956: PPUSH
85957: CALL_OW 122
// ct := 0 ;
85961: LD_ADDR_VAR 0 8
85965: PUSH
85966: LD_INT 0
85968: ST_TO_ADDR
// for k in x do
85969: LD_ADDR_VAR 0 4
85973: PUSH
85974: LD_VAR 0 11
85978: PUSH
85979: FOR_IN
85980: IFFALSE 86059
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
85982: LD_VAR 0 4
85986: PPUSH
85987: CALL_OW 264
85991: PUSH
85992: LD_INT 31
85994: EQUAL
85995: IFFALSE 86009
85997: PUSH
85998: LD_VAR 0 4
86002: PPUSH
86003: CALL_OW 311
86007: NOT
86008: AND
86009: IFTRUE 86043
86011: PUSH
86012: LD_VAR 0 4
86016: PPUSH
86017: CALL_OW 266
86021: PUSH
86022: LD_INT 36
86024: EQUAL
86025: IFFALSE 86042
86027: PUSH
86028: LD_VAR 0 4
86032: PPUSH
86033: CALL_OW 313
86037: PUSH
86038: LD_INT 3
86040: LESS
86041: AND
86042: OR
86043: IFFALSE 86057
// begin ct := k ;
86045: LD_ADDR_VAR 0 8
86049: PUSH
86050: LD_VAR 0 4
86054: ST_TO_ADDR
// break ;
86055: GO 86059
// end ;
86057: GO 85979
86059: POP
86060: POP
// if ct then
86061: LD_VAR 0 8
86065: IFFALSE 86081
// ComEnterUnit ( j , ct ) ;
86067: LD_VAR 0 3
86071: PPUSH
86072: LD_VAR 0 8
86076: PPUSH
86077: CALL_OW 120
// end ; end ;
86081: GO 85704
86083: POP
86084: POP
// places := 0 ;
86085: LD_ADDR_VAR 0 5
86089: PUSH
86090: LD_INT 0
86092: ST_TO_ADDR
// for j = 1 to x do
86093: LD_ADDR_VAR 0 3
86097: PUSH
86098: DOUBLE
86099: LD_INT 1
86101: DEC
86102: ST_TO_ADDR
86103: LD_VAR 0 11
86107: PUSH
86108: FOR_TO
86109: IFFALSE 86185
// if GetWeapon ( x [ j ] ) = ar_control_tower then
86111: LD_VAR 0 11
86115: PUSH
86116: LD_VAR 0 3
86120: ARRAY
86121: PPUSH
86122: CALL_OW 264
86126: PUSH
86127: LD_INT 31
86129: EQUAL
86130: IFFALSE 86148
// places := places + 1 else
86132: LD_ADDR_VAR 0 5
86136: PUSH
86137: LD_VAR 0 5
86141: PUSH
86142: LD_INT 1
86144: PLUS
86145: ST_TO_ADDR
86146: GO 86183
// if GetBType ( x [ j ] ) = b_control_tower then
86148: LD_VAR 0 11
86152: PUSH
86153: LD_VAR 0 3
86157: ARRAY
86158: PPUSH
86159: CALL_OW 266
86163: PUSH
86164: LD_INT 36
86166: EQUAL
86167: IFFALSE 86183
// places := places + 3 ;
86169: LD_ADDR_VAR 0 5
86173: PUSH
86174: LD_VAR 0 5
86178: PUSH
86179: LD_INT 3
86181: PLUS
86182: ST_TO_ADDR
86183: GO 86108
86185: POP
86186: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
86187: LD_VAR 0 5
86191: PUSH
86192: LD_INT 0
86194: EQUAL
86195: IFTRUE 86215
86197: PUSH
86198: LD_VAR 0 5
86202: PUSH
86203: LD_EXP 71
86207: PUSH
86208: LD_VAR 0 2
86212: ARRAY
86213: LESSEQUAL
86214: OR
86215: IFFALSE 86219
// continue ;
86217: GO 85449
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
86219: LD_ADDR_VAR 0 6
86223: PUSH
86224: LD_EXP 31
86228: PUSH
86229: LD_VAR 0 2
86233: ARRAY
86234: PPUSH
86235: LD_INT 25
86237: PUSH
86238: LD_INT 3
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PPUSH
86245: CALL_OW 72
86249: PUSH
86250: LD_EXP 71
86254: PUSH
86255: LD_VAR 0 2
86259: ARRAY
86260: DIFF
86261: PPUSH
86262: LD_INT 3
86264: PPUSH
86265: CALL 56591 0 2
86269: ST_TO_ADDR
// for j in tmp do
86270: LD_ADDR_VAR 0 3
86274: PUSH
86275: LD_VAR 0 6
86279: PUSH
86280: FOR_IN
86281: IFFALSE 86316
// if GetTag ( j ) > 0 then
86283: LD_VAR 0 3
86287: PPUSH
86288: CALL_OW 110
86292: PUSH
86293: LD_INT 0
86295: GREATER
86296: IFFALSE 86314
// tmp := tmp diff j ;
86298: LD_ADDR_VAR 0 6
86302: PUSH
86303: LD_VAR 0 6
86307: PUSH
86308: LD_VAR 0 3
86312: DIFF
86313: ST_TO_ADDR
86314: GO 86280
86316: POP
86317: POP
// if not tmp then
86318: LD_VAR 0 6
86322: NOT
86323: IFFALSE 86327
// continue ;
86325: GO 85449
// if places then
86327: LD_VAR 0 5
86331: IFFALSE 86390
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
86333: LD_ADDR_EXP 71
86337: PUSH
86338: LD_EXP 71
86342: PPUSH
86343: LD_VAR 0 2
86347: PPUSH
86348: LD_EXP 71
86352: PUSH
86353: LD_VAR 0 2
86357: ARRAY
86358: PUSH
86359: LD_VAR 0 6
86363: PUSH
86364: LD_INT 1
86366: ARRAY
86367: UNION
86368: PPUSH
86369: CALL_OW 1
86373: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
86374: LD_VAR 0 6
86378: PUSH
86379: LD_INT 1
86381: ARRAY
86382: PPUSH
86383: LD_INT 126
86385: PPUSH
86386: CALL_OW 109
// end ; end ;
86390: GO 85449
86392: POP
86393: POP
// end ;
86394: LD_VAR 0 1
86398: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
86399: LD_INT 0
86401: PPUSH
86402: PPUSH
86403: PPUSH
86404: PPUSH
86405: PPUSH
86406: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
86407: LD_VAR 0 1
86411: NOT
86412: IFTRUE 86421
86414: PUSH
86415: LD_VAR 0 2
86419: NOT
86420: OR
86421: IFTRUE 86430
86423: PUSH
86424: LD_VAR 0 3
86428: NOT
86429: OR
86430: IFTRUE 86478
86432: PUSH
86433: LD_VAR 0 4
86437: PUSH
86438: LD_INT 1
86440: PUSH
86441: LD_INT 2
86443: PUSH
86444: LD_INT 3
86446: PUSH
86447: LD_INT 4
86449: PUSH
86450: LD_INT 5
86452: PUSH
86453: LD_INT 8
86455: PUSH
86456: LD_INT 9
86458: PUSH
86459: LD_INT 15
86461: PUSH
86462: LD_INT 16
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: LIST
86475: IN
86476: NOT
86477: OR
86478: IFFALSE 86482
// exit ;
86480: GO 87342
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
86482: LD_ADDR_VAR 0 2
86486: PUSH
86487: LD_VAR 0 2
86491: PPUSH
86492: LD_INT 21
86494: PUSH
86495: LD_INT 3
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 24
86504: PUSH
86505: LD_INT 250
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: EMPTY
86513: LIST
86514: LIST
86515: PPUSH
86516: CALL_OW 72
86520: ST_TO_ADDR
// case class of 1 , 15 :
86521: LD_VAR 0 4
86525: PUSH
86526: LD_INT 1
86528: DOUBLE
86529: EQUAL
86530: IFTRUE 86540
86532: LD_INT 15
86534: DOUBLE
86535: EQUAL
86536: IFTRUE 86540
86538: GO 86625
86540: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
86541: LD_ADDR_VAR 0 8
86545: PUSH
86546: LD_VAR 0 2
86550: PPUSH
86551: LD_INT 2
86553: PUSH
86554: LD_INT 30
86556: PUSH
86557: LD_INT 32
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 30
86566: PUSH
86567: LD_INT 31
86569: PUSH
86570: EMPTY
86571: LIST
86572: LIST
86573: PUSH
86574: EMPTY
86575: LIST
86576: LIST
86577: LIST
86578: PPUSH
86579: CALL_OW 72
86583: PUSH
86584: LD_VAR 0 2
86588: PPUSH
86589: LD_INT 2
86591: PUSH
86592: LD_INT 30
86594: PUSH
86595: LD_INT 4
86597: PUSH
86598: EMPTY
86599: LIST
86600: LIST
86601: PUSH
86602: LD_INT 30
86604: PUSH
86605: LD_INT 5
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: LIST
86616: PPUSH
86617: CALL_OW 72
86621: ADD
86622: ST_TO_ADDR
86623: GO 86871
86625: LD_INT 2
86627: DOUBLE
86628: EQUAL
86629: IFTRUE 86639
86631: LD_INT 16
86633: DOUBLE
86634: EQUAL
86635: IFTRUE 86639
86637: GO 86685
86639: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
86640: LD_ADDR_VAR 0 8
86644: PUSH
86645: LD_VAR 0 2
86649: PPUSH
86650: LD_INT 2
86652: PUSH
86653: LD_INT 30
86655: PUSH
86656: LD_INT 0
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: LD_INT 30
86665: PUSH
86666: LD_INT 1
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: LIST
86677: PPUSH
86678: CALL_OW 72
86682: ST_TO_ADDR
86683: GO 86871
86685: LD_INT 3
86687: DOUBLE
86688: EQUAL
86689: IFTRUE 86693
86691: GO 86739
86693: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
86694: LD_ADDR_VAR 0 8
86698: PUSH
86699: LD_VAR 0 2
86703: PPUSH
86704: LD_INT 2
86706: PUSH
86707: LD_INT 30
86709: PUSH
86710: LD_INT 2
86712: PUSH
86713: EMPTY
86714: LIST
86715: LIST
86716: PUSH
86717: LD_INT 30
86719: PUSH
86720: LD_INT 3
86722: PUSH
86723: EMPTY
86724: LIST
86725: LIST
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: LIST
86731: PPUSH
86732: CALL_OW 72
86736: ST_TO_ADDR
86737: GO 86871
86739: LD_INT 4
86741: DOUBLE
86742: EQUAL
86743: IFTRUE 86747
86745: GO 86804
86747: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
86748: LD_ADDR_VAR 0 8
86752: PUSH
86753: LD_VAR 0 2
86757: PPUSH
86758: LD_INT 2
86760: PUSH
86761: LD_INT 30
86763: PUSH
86764: LD_INT 6
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 30
86773: PUSH
86774: LD_INT 7
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 30
86783: PUSH
86784: LD_INT 8
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: PPUSH
86797: CALL_OW 72
86801: ST_TO_ADDR
86802: GO 86871
86804: LD_INT 5
86806: DOUBLE
86807: EQUAL
86808: IFTRUE 86824
86810: LD_INT 8
86812: DOUBLE
86813: EQUAL
86814: IFTRUE 86824
86816: LD_INT 9
86818: DOUBLE
86819: EQUAL
86820: IFTRUE 86824
86822: GO 86870
86824: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
86825: LD_ADDR_VAR 0 8
86829: PUSH
86830: LD_VAR 0 2
86834: PPUSH
86835: LD_INT 2
86837: PUSH
86838: LD_INT 30
86840: PUSH
86841: LD_INT 4
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 30
86850: PUSH
86851: LD_INT 5
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: EMPTY
86859: LIST
86860: LIST
86861: LIST
86862: PPUSH
86863: CALL_OW 72
86867: ST_TO_ADDR
86868: GO 86871
86870: POP
// if not tmp then
86871: LD_VAR 0 8
86875: NOT
86876: IFFALSE 86880
// exit ;
86878: GO 87342
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
86880: LD_VAR 0 4
86884: PUSH
86885: LD_INT 1
86887: PUSH
86888: LD_INT 15
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: IN
86895: IFFALSE 86909
86897: PUSH
86898: LD_EXP 40
86902: PUSH
86903: LD_VAR 0 1
86907: ARRAY
86908: AND
86909: IFFALSE 87065
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
86911: LD_ADDR_VAR 0 9
86915: PUSH
86916: LD_EXP 40
86920: PUSH
86921: LD_VAR 0 1
86925: ARRAY
86926: PUSH
86927: LD_INT 1
86929: ARRAY
86930: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
86931: LD_VAR 0 9
86935: PUSH
86936: LD_EXP 41
86940: PUSH
86941: LD_VAR 0 1
86945: ARRAY
86946: IN
86947: NOT
86948: IFFALSE 87063
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
86950: LD_ADDR_EXP 41
86954: PUSH
86955: LD_EXP 41
86959: PPUSH
86960: LD_VAR 0 1
86964: PUSH
86965: LD_EXP 41
86969: PUSH
86970: LD_VAR 0 1
86974: ARRAY
86975: PUSH
86976: LD_INT 1
86978: PLUS
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PPUSH
86984: LD_VAR 0 9
86988: PPUSH
86989: CALL 25063 0 3
86993: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
86994: LD_ADDR_EXP 40
86998: PUSH
86999: LD_EXP 40
87003: PPUSH
87004: LD_VAR 0 1
87008: PPUSH
87009: LD_EXP 40
87013: PUSH
87014: LD_VAR 0 1
87018: ARRAY
87019: PUSH
87020: LD_VAR 0 9
87024: DIFF
87025: PPUSH
87026: CALL_OW 1
87030: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
87031: LD_VAR 0 3
87035: PPUSH
87036: LD_EXP 41
87040: PUSH
87041: LD_VAR 0 1
87045: ARRAY
87046: PUSH
87047: LD_EXP 41
87051: PUSH
87052: LD_VAR 0 1
87056: ARRAY
87057: ARRAY
87058: PPUSH
87059: CALL_OW 120
// end ; exit ;
87063: GO 87342
// end ; if tmp > 1 then
87065: LD_VAR 0 8
87069: PUSH
87070: LD_INT 1
87072: GREATER
87073: IFFALSE 87177
// for i = 2 to tmp do
87075: LD_ADDR_VAR 0 6
87079: PUSH
87080: DOUBLE
87081: LD_INT 2
87083: DEC
87084: ST_TO_ADDR
87085: LD_VAR 0 8
87089: PUSH
87090: FOR_TO
87091: IFFALSE 87175
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
87093: LD_VAR 0 8
87097: PUSH
87098: LD_VAR 0 6
87102: ARRAY
87103: PPUSH
87104: CALL_OW 461
87108: PUSH
87109: LD_INT 6
87111: EQUAL
87112: IFFALSE 87173
// begin x := tmp [ i ] ;
87114: LD_ADDR_VAR 0 9
87118: PUSH
87119: LD_VAR 0 8
87123: PUSH
87124: LD_VAR 0 6
87128: ARRAY
87129: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
87130: LD_ADDR_VAR 0 8
87134: PUSH
87135: LD_VAR 0 8
87139: PPUSH
87140: LD_VAR 0 6
87144: PPUSH
87145: CALL_OW 3
87149: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
87150: LD_ADDR_VAR 0 8
87154: PUSH
87155: LD_VAR 0 8
87159: PPUSH
87160: LD_INT 1
87162: PPUSH
87163: LD_VAR 0 9
87167: PPUSH
87168: CALL_OW 2
87172: ST_TO_ADDR
// end ;
87173: GO 87090
87175: POP
87176: POP
// for i in tmp do
87177: LD_ADDR_VAR 0 6
87181: PUSH
87182: LD_VAR 0 8
87186: PUSH
87187: FOR_IN
87188: IFFALSE 87215
// begin if IsNotFull ( i ) then
87190: LD_VAR 0 6
87194: PPUSH
87195: CALL 22261 0 1
87199: IFFALSE 87213
// begin j := i ;
87201: LD_ADDR_VAR 0 7
87205: PUSH
87206: LD_VAR 0 6
87210: ST_TO_ADDR
// break ;
87211: GO 87215
// end ; end ;
87213: GO 87187
87215: POP
87216: POP
// if j then
87217: LD_VAR 0 7
87221: IFFALSE 87239
// ComEnterUnit ( unit , j ) else
87223: LD_VAR 0 3
87227: PPUSH
87228: LD_VAR 0 7
87232: PPUSH
87233: CALL_OW 120
87237: GO 87342
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87239: LD_ADDR_VAR 0 10
87243: PUSH
87244: LD_VAR 0 2
87248: PPUSH
87249: LD_INT 2
87251: PUSH
87252: LD_INT 30
87254: PUSH
87255: LD_INT 0
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: LD_INT 30
87264: PUSH
87265: LD_INT 1
87267: PUSH
87268: EMPTY
87269: LIST
87270: LIST
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: LIST
87276: PPUSH
87277: CALL_OW 72
87281: ST_TO_ADDR
// if depot then
87282: LD_VAR 0 10
87286: IFFALSE 87342
// begin depot := NearestUnitToUnit ( depot , unit ) ;
87288: LD_ADDR_VAR 0 10
87292: PUSH
87293: LD_VAR 0 10
87297: PPUSH
87298: LD_VAR 0 3
87302: PPUSH
87303: CALL_OW 74
87307: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
87308: LD_VAR 0 3
87312: PPUSH
87313: LD_VAR 0 10
87317: PPUSH
87318: CALL_OW 296
87322: PUSH
87323: LD_INT 10
87325: GREATER
87326: IFFALSE 87342
// ComStandNearbyBuilding ( unit , depot ) ;
87328: LD_VAR 0 3
87332: PPUSH
87333: LD_VAR 0 10
87337: PPUSH
87338: CALL 21639 0 2
// end ; end ; end ;
87342: LD_VAR 0 5
87346: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
87347: LD_INT 0
87349: PPUSH
87350: PPUSH
87351: PPUSH
87352: PPUSH
// if not mc_bases then
87353: LD_EXP 31
87357: NOT
87358: IFFALSE 87362
// exit ;
87360: GO 87613
// for i = 1 to mc_bases do
87362: LD_ADDR_VAR 0 2
87366: PUSH
87367: DOUBLE
87368: LD_INT 1
87370: DEC
87371: ST_TO_ADDR
87372: LD_EXP 31
87376: PUSH
87377: FOR_TO
87378: IFFALSE 87611
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
87380: LD_ADDR_VAR 0 4
87384: PUSH
87385: LD_EXP 31
87389: PUSH
87390: LD_VAR 0 2
87394: ARRAY
87395: PPUSH
87396: LD_INT 21
87398: PUSH
87399: LD_INT 1
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PPUSH
87406: CALL_OW 72
87410: PUSH
87411: LD_EXP 60
87415: PUSH
87416: LD_VAR 0 2
87420: ARRAY
87421: UNION
87422: ST_TO_ADDR
// if not tmp then
87423: LD_VAR 0 4
87427: NOT
87428: IFFALSE 87432
// continue ;
87430: GO 87377
// for j in tmp do
87432: LD_ADDR_VAR 0 3
87436: PUSH
87437: LD_VAR 0 4
87441: PUSH
87442: FOR_IN
87443: IFFALSE 87607
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
87445: LD_VAR 0 3
87449: PPUSH
87450: CALL_OW 110
87454: NOT
87455: IFFALSE 87469
87457: PUSH
87458: LD_VAR 0 3
87462: PPUSH
87463: CALL_OW 314
87467: NOT
87468: AND
87469: IFFALSE 87483
87471: PUSH
87472: LD_VAR 0 3
87476: PPUSH
87477: CALL_OW 311
87481: NOT
87482: AND
87483: IFFALSE 87497
87485: PUSH
87486: LD_VAR 0 3
87490: PPUSH
87491: CALL_OW 310
87495: NOT
87496: AND
87497: IFFALSE 87522
87499: PUSH
87500: LD_VAR 0 3
87504: PUSH
87505: LD_EXP 34
87509: PUSH
87510: LD_VAR 0 2
87514: ARRAY
87515: PUSH
87516: LD_INT 1
87518: ARRAY
87519: IN
87520: NOT
87521: AND
87522: IFFALSE 87547
87524: PUSH
87525: LD_VAR 0 3
87529: PUSH
87530: LD_EXP 34
87534: PUSH
87535: LD_VAR 0 2
87539: ARRAY
87540: PUSH
87541: LD_INT 2
87543: ARRAY
87544: IN
87545: NOT
87546: AND
87547: IFFALSE 87568
87549: PUSH
87550: LD_VAR 0 3
87554: PUSH
87555: LD_EXP 43
87559: PUSH
87560: LD_VAR 0 2
87564: ARRAY
87565: IN
87566: NOT
87567: AND
87568: IFFALSE 87605
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
87570: LD_VAR 0 2
87574: PPUSH
87575: LD_EXP 31
87579: PUSH
87580: LD_VAR 0 2
87584: ARRAY
87585: PPUSH
87586: LD_VAR 0 3
87590: PPUSH
87591: LD_VAR 0 3
87595: PPUSH
87596: CALL_OW 257
87600: PPUSH
87601: CALL 86399 0 4
// end ;
87605: GO 87442
87607: POP
87608: POP
// end ;
87609: GO 87377
87611: POP
87612: POP
// end ;
87613: LD_VAR 0 1
87617: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
87618: LD_INT 0
87620: PPUSH
87621: PPUSH
87622: PPUSH
87623: PPUSH
87624: PPUSH
87625: PPUSH
// if not mc_bases [ base ] then
87626: LD_EXP 31
87630: PUSH
87631: LD_VAR 0 1
87635: ARRAY
87636: NOT
87637: IFFALSE 87641
// exit ;
87639: GO 87842
// tmp := [ ] ;
87641: LD_ADDR_VAR 0 6
87645: PUSH
87646: EMPTY
87647: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
87648: LD_ADDR_VAR 0 7
87652: PUSH
87653: LD_VAR 0 3
87657: PPUSH
87658: LD_INT 0
87660: PPUSH
87661: CALL_OW 517
87665: ST_TO_ADDR
// if not list then
87666: LD_VAR 0 7
87670: NOT
87671: IFFALSE 87675
// exit ;
87673: GO 87842
// c := Count ( list [ 1 ] ) ;
87675: LD_ADDR_VAR 0 9
87679: PUSH
87680: LD_VAR 0 7
87684: PUSH
87685: LD_INT 1
87687: ARRAY
87688: PPUSH
87689: CALL 22179 0 1
87693: ST_TO_ADDR
// if amount > c then
87694: LD_VAR 0 2
87698: PUSH
87699: LD_VAR 0 9
87703: GREATER
87704: IFFALSE 87716
// amount := c ;
87706: LD_ADDR_VAR 0 2
87710: PUSH
87711: LD_VAR 0 9
87715: ST_TO_ADDR
// for i := 1 to amount do
87716: LD_ADDR_VAR 0 5
87720: PUSH
87721: DOUBLE
87722: LD_INT 1
87724: DEC
87725: ST_TO_ADDR
87726: LD_VAR 0 2
87730: PUSH
87731: FOR_TO
87732: IFFALSE 87790
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
87734: LD_ADDR_VAR 0 6
87738: PUSH
87739: LD_VAR 0 6
87743: PPUSH
87744: LD_VAR 0 5
87748: PPUSH
87749: LD_VAR 0 7
87753: PUSH
87754: LD_INT 1
87756: ARRAY
87757: PUSH
87758: LD_VAR 0 5
87762: ARRAY
87763: PUSH
87764: LD_VAR 0 7
87768: PUSH
87769: LD_INT 2
87771: ARRAY
87772: PUSH
87773: LD_VAR 0 5
87777: ARRAY
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: PPUSH
87783: CALL_OW 1
87787: ST_TO_ADDR
87788: GO 87731
87790: POP
87791: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
87792: LD_ADDR_EXP 44
87796: PUSH
87797: LD_EXP 44
87801: PPUSH
87802: LD_VAR 0 1
87806: PPUSH
87807: LD_VAR 0 6
87811: PPUSH
87812: CALL_OW 1
87816: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
87817: LD_ADDR_EXP 46
87821: PUSH
87822: LD_EXP 46
87826: PPUSH
87827: LD_VAR 0 1
87831: PPUSH
87832: LD_VAR 0 3
87836: PPUSH
87837: CALL_OW 1
87841: ST_TO_ADDR
// end ;
87842: LD_VAR 0 4
87846: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
87847: LD_INT 0
87849: PPUSH
// if not mc_bases [ base ] then
87850: LD_EXP 31
87854: PUSH
87855: LD_VAR 0 1
87859: ARRAY
87860: NOT
87861: IFFALSE 87865
// exit ;
87863: GO 87890
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
87865: LD_ADDR_EXP 36
87869: PUSH
87870: LD_EXP 36
87874: PPUSH
87875: LD_VAR 0 1
87879: PPUSH
87880: LD_VAR 0 2
87884: PPUSH
87885: CALL_OW 1
87889: ST_TO_ADDR
// end ;
87890: LD_VAR 0 3
87894: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
87895: LD_INT 0
87897: PPUSH
// if not mc_bases [ base ] then
87898: LD_EXP 31
87902: PUSH
87903: LD_VAR 0 1
87907: ARRAY
87908: NOT
87909: IFFALSE 87913
// exit ;
87911: GO 87950
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
87913: LD_ADDR_EXP 36
87917: PUSH
87918: LD_EXP 36
87922: PPUSH
87923: LD_VAR 0 1
87927: PPUSH
87928: LD_EXP 36
87932: PUSH
87933: LD_VAR 0 1
87937: ARRAY
87938: PUSH
87939: LD_VAR 0 2
87943: UNION
87944: PPUSH
87945: CALL_OW 1
87949: ST_TO_ADDR
// end ;
87950: LD_VAR 0 3
87954: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
87955: LD_INT 0
87957: PPUSH
// if not mc_bases [ base ] then
87958: LD_EXP 31
87962: PUSH
87963: LD_VAR 0 1
87967: ARRAY
87968: NOT
87969: IFFALSE 87973
// exit ;
87971: GO 87998
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
87973: LD_ADDR_EXP 52
87977: PUSH
87978: LD_EXP 52
87982: PPUSH
87983: LD_VAR 0 1
87987: PPUSH
87988: LD_VAR 0 2
87992: PPUSH
87993: CALL_OW 1
87997: ST_TO_ADDR
// end ;
87998: LD_VAR 0 3
88002: RET
// export function MC_InsertProduceList ( base , components ) ; begin
88003: LD_INT 0
88005: PPUSH
// if not mc_bases [ base ] then
88006: LD_EXP 31
88010: PUSH
88011: LD_VAR 0 1
88015: ARRAY
88016: NOT
88017: IFFALSE 88021
// exit ;
88019: GO 88058
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
88021: LD_ADDR_EXP 52
88025: PUSH
88026: LD_EXP 52
88030: PPUSH
88031: LD_VAR 0 1
88035: PPUSH
88036: LD_EXP 52
88040: PUSH
88041: LD_VAR 0 1
88045: ARRAY
88046: PUSH
88047: LD_VAR 0 2
88051: ADD
88052: PPUSH
88053: CALL_OW 1
88057: ST_TO_ADDR
// end ;
88058: LD_VAR 0 3
88062: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
88063: LD_INT 0
88065: PPUSH
// if not mc_bases [ base ] then
88066: LD_EXP 31
88070: PUSH
88071: LD_VAR 0 1
88075: ARRAY
88076: NOT
88077: IFFALSE 88081
// exit ;
88079: GO 88135
// mc_defender := Replace ( mc_defender , base , deflist ) ;
88081: LD_ADDR_EXP 53
88085: PUSH
88086: LD_EXP 53
88090: PPUSH
88091: LD_VAR 0 1
88095: PPUSH
88096: LD_VAR 0 2
88100: PPUSH
88101: CALL_OW 1
88105: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
88106: LD_ADDR_EXP 42
88110: PUSH
88111: LD_EXP 42
88115: PPUSH
88116: LD_VAR 0 1
88120: PPUSH
88121: LD_VAR 0 2
88125: PUSH
88126: LD_INT 0
88128: PLUS
88129: PPUSH
88130: CALL_OW 1
88134: ST_TO_ADDR
// end ;
88135: LD_VAR 0 3
88139: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
88140: LD_INT 0
88142: PPUSH
// if not mc_bases [ base ] then
88143: LD_EXP 31
88147: PUSH
88148: LD_VAR 0 1
88152: ARRAY
88153: NOT
88154: IFFALSE 88158
// exit ;
88156: GO 88183
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
88158: LD_ADDR_EXP 42
88162: PUSH
88163: LD_EXP 42
88167: PPUSH
88168: LD_VAR 0 1
88172: PPUSH
88173: LD_VAR 0 2
88177: PPUSH
88178: CALL_OW 1
88182: ST_TO_ADDR
// end ;
88183: LD_VAR 0 3
88187: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
88188: LD_INT 0
88190: PPUSH
88191: PPUSH
88192: PPUSH
88193: PPUSH
// if not mc_bases [ base ] then
88194: LD_EXP 31
88198: PUSH
88199: LD_VAR 0 1
88203: ARRAY
88204: NOT
88205: IFFALSE 88209
// exit ;
88207: GO 88274
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
88209: LD_ADDR_EXP 51
88213: PUSH
88214: LD_EXP 51
88218: PPUSH
88219: LD_VAR 0 1
88223: PUSH
88224: LD_EXP 51
88228: PUSH
88229: LD_VAR 0 1
88233: ARRAY
88234: PUSH
88235: LD_INT 1
88237: PLUS
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: PPUSH
88243: LD_VAR 0 1
88247: PUSH
88248: LD_VAR 0 2
88252: PUSH
88253: LD_VAR 0 3
88257: PUSH
88258: LD_VAR 0 4
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: PPUSH
88269: CALL 25063 0 3
88273: ST_TO_ADDR
// end ;
88274: LD_VAR 0 5
88278: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
88279: LD_INT 0
88281: PPUSH
// if not mc_bases [ base ] then
88282: LD_EXP 31
88286: PUSH
88287: LD_VAR 0 1
88291: ARRAY
88292: NOT
88293: IFFALSE 88297
// exit ;
88295: GO 88322
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
88297: LD_ADDR_EXP 68
88301: PUSH
88302: LD_EXP 68
88306: PPUSH
88307: LD_VAR 0 1
88311: PPUSH
88312: LD_VAR 0 2
88316: PPUSH
88317: CALL_OW 1
88321: ST_TO_ADDR
// end ;
88322: LD_VAR 0 3
88326: RET
// export function MC_GetMinesField ( base ) ; begin
88327: LD_INT 0
88329: PPUSH
// result := mc_mines [ base ] ;
88330: LD_ADDR_VAR 0 2
88334: PUSH
88335: LD_EXP 44
88339: PUSH
88340: LD_VAR 0 1
88344: ARRAY
88345: ST_TO_ADDR
// end ;
88346: LD_VAR 0 2
88350: RET
// export function MC_GetProduceList ( base ) ; begin
88351: LD_INT 0
88353: PPUSH
// result := mc_produce [ base ] ;
88354: LD_ADDR_VAR 0 2
88358: PUSH
88359: LD_EXP 52
88363: PUSH
88364: LD_VAR 0 1
88368: ARRAY
88369: ST_TO_ADDR
// end ;
88370: LD_VAR 0 2
88374: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
88375: LD_INT 0
88377: PPUSH
88378: PPUSH
// if not mc_bases then
88379: LD_EXP 31
88383: NOT
88384: IFFALSE 88388
// exit ;
88386: GO 88453
// if mc_bases [ base ] then
88388: LD_EXP 31
88392: PUSH
88393: LD_VAR 0 1
88397: ARRAY
88398: IFFALSE 88453
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
88400: LD_ADDR_VAR 0 3
88404: PUSH
88405: LD_EXP 31
88409: PUSH
88410: LD_VAR 0 1
88414: ARRAY
88415: PPUSH
88416: LD_INT 30
88418: PUSH
88419: LD_VAR 0 2
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: PPUSH
88428: CALL_OW 72
88432: ST_TO_ADDR
// if result then
88433: LD_VAR 0 3
88437: IFFALSE 88453
// result := result [ 1 ] ;
88439: LD_ADDR_VAR 0 3
88443: PUSH
88444: LD_VAR 0 3
88448: PUSH
88449: LD_INT 1
88451: ARRAY
88452: ST_TO_ADDR
// end ; end ;
88453: LD_VAR 0 3
88457: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
88458: LD_INT 0
88460: PPUSH
88461: PPUSH
// if not mc_bases then
88462: LD_EXP 31
88466: NOT
88467: IFFALSE 88471
// exit ;
88469: GO 88516
// if mc_bases [ base ] then
88471: LD_EXP 31
88475: PUSH
88476: LD_VAR 0 1
88480: ARRAY
88481: IFFALSE 88516
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
88483: LD_ADDR_VAR 0 3
88487: PUSH
88488: LD_EXP 31
88492: PUSH
88493: LD_VAR 0 1
88497: ARRAY
88498: PPUSH
88499: LD_INT 30
88501: PUSH
88502: LD_VAR 0 2
88506: PUSH
88507: EMPTY
88508: LIST
88509: LIST
88510: PPUSH
88511: CALL_OW 72
88515: ST_TO_ADDR
// end ;
88516: LD_VAR 0 3
88520: RET
// export function MC_SetTame ( base , area ) ; begin
88521: LD_INT 0
88523: PPUSH
// if not mc_bases or not base then
88524: LD_EXP 31
88528: NOT
88529: IFTRUE 88538
88531: PUSH
88532: LD_VAR 0 1
88536: NOT
88537: OR
88538: IFFALSE 88542
// exit ;
88540: GO 88567
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
88542: LD_ADDR_EXP 59
88546: PUSH
88547: LD_EXP 59
88551: PPUSH
88552: LD_VAR 0 1
88556: PPUSH
88557: LD_VAR 0 2
88561: PPUSH
88562: CALL_OW 1
88566: ST_TO_ADDR
// end ;
88567: LD_VAR 0 3
88571: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
88572: LD_INT 0
88574: PPUSH
88575: PPUSH
// if not mc_bases or not base then
88576: LD_EXP 31
88580: NOT
88581: IFTRUE 88590
88583: PUSH
88584: LD_VAR 0 1
88588: NOT
88589: OR
88590: IFFALSE 88594
// exit ;
88592: GO 88696
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
88594: LD_ADDR_VAR 0 4
88598: PUSH
88599: LD_EXP 31
88603: PUSH
88604: LD_VAR 0 1
88608: ARRAY
88609: PPUSH
88610: LD_INT 30
88612: PUSH
88613: LD_VAR 0 2
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: PPUSH
88622: CALL_OW 72
88626: ST_TO_ADDR
// if not tmp then
88627: LD_VAR 0 4
88631: NOT
88632: IFFALSE 88636
// exit ;
88634: GO 88696
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
88636: LD_ADDR_EXP 63
88640: PUSH
88641: LD_EXP 63
88645: PPUSH
88646: LD_VAR 0 1
88650: PPUSH
88651: LD_EXP 63
88655: PUSH
88656: LD_VAR 0 1
88660: ARRAY
88661: PPUSH
88662: LD_EXP 63
88666: PUSH
88667: LD_VAR 0 1
88671: ARRAY
88672: PUSH
88673: LD_INT 1
88675: PLUS
88676: PPUSH
88677: LD_VAR 0 4
88681: PUSH
88682: LD_INT 1
88684: ARRAY
88685: PPUSH
88686: CALL_OW 2
88690: PPUSH
88691: CALL_OW 1
88695: ST_TO_ADDR
// end ;
88696: LD_VAR 0 3
88700: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
88701: LD_INT 0
88703: PPUSH
88704: PPUSH
// if not mc_bases or not base or not kinds then
88705: LD_EXP 31
88709: NOT
88710: IFTRUE 88719
88712: PUSH
88713: LD_VAR 0 1
88717: NOT
88718: OR
88719: IFTRUE 88728
88721: PUSH
88722: LD_VAR 0 2
88726: NOT
88727: OR
88728: IFFALSE 88732
// exit ;
88730: GO 88793
// for i in kinds do
88732: LD_ADDR_VAR 0 4
88736: PUSH
88737: LD_VAR 0 2
88741: PUSH
88742: FOR_IN
88743: IFFALSE 88791
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
88745: LD_ADDR_EXP 65
88749: PUSH
88750: LD_EXP 65
88754: PPUSH
88755: LD_VAR 0 1
88759: PUSH
88760: LD_EXP 65
88764: PUSH
88765: LD_VAR 0 1
88769: ARRAY
88770: PUSH
88771: LD_INT 1
88773: PLUS
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: PPUSH
88779: LD_VAR 0 4
88783: PPUSH
88784: CALL 25063 0 3
88788: ST_TO_ADDR
88789: GO 88742
88791: POP
88792: POP
// end ;
88793: LD_VAR 0 3
88797: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
88798: LD_INT 0
88800: PPUSH
// if not mc_bases or not base or not areas then
88801: LD_EXP 31
88805: NOT
88806: IFTRUE 88815
88808: PUSH
88809: LD_VAR 0 1
88813: NOT
88814: OR
88815: IFTRUE 88824
88817: PUSH
88818: LD_VAR 0 2
88822: NOT
88823: OR
88824: IFFALSE 88828
// exit ;
88826: GO 88853
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
88828: LD_ADDR_EXP 49
88832: PUSH
88833: LD_EXP 49
88837: PPUSH
88838: LD_VAR 0 1
88842: PPUSH
88843: LD_VAR 0 2
88847: PPUSH
88848: CALL_OW 1
88852: ST_TO_ADDR
// end ;
88853: LD_VAR 0 3
88857: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
88858: LD_INT 0
88860: PPUSH
// if not mc_bases or not base or not teleports_exit then
88861: LD_EXP 31
88865: NOT
88866: IFTRUE 88875
88868: PUSH
88869: LD_VAR 0 1
88873: NOT
88874: OR
88875: IFTRUE 88884
88877: PUSH
88878: LD_VAR 0 2
88882: NOT
88883: OR
88884: IFFALSE 88888
// exit ;
88886: GO 88913
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
88888: LD_ADDR_EXP 66
88892: PUSH
88893: LD_EXP 66
88897: PPUSH
88898: LD_VAR 0 1
88902: PPUSH
88903: LD_VAR 0 2
88907: PPUSH
88908: CALL_OW 1
88912: ST_TO_ADDR
// end ;
88913: LD_VAR 0 3
88917: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
88918: LD_INT 0
88920: PPUSH
88921: PPUSH
88922: PPUSH
// if not mc_bases or not base or not ext_list then
88923: LD_EXP 31
88927: NOT
88928: IFTRUE 88937
88930: PUSH
88931: LD_VAR 0 1
88935: NOT
88936: OR
88937: IFTRUE 88946
88939: PUSH
88940: LD_VAR 0 5
88944: NOT
88945: OR
88946: IFFALSE 88950
// exit ;
88948: GO 89123
// tmp := GetFacExtXYD ( x , y , d ) ;
88950: LD_ADDR_VAR 0 8
88954: PUSH
88955: LD_VAR 0 2
88959: PPUSH
88960: LD_VAR 0 3
88964: PPUSH
88965: LD_VAR 0 4
88969: PPUSH
88970: CALL 55721 0 3
88974: ST_TO_ADDR
// if not tmp then
88975: LD_VAR 0 8
88979: NOT
88980: IFFALSE 88984
// exit ;
88982: GO 89123
// for i in tmp do
88984: LD_ADDR_VAR 0 7
88988: PUSH
88989: LD_VAR 0 8
88993: PUSH
88994: FOR_IN
88995: IFFALSE 89121
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
88997: LD_ADDR_EXP 36
89001: PUSH
89002: LD_EXP 36
89006: PPUSH
89007: LD_VAR 0 1
89011: PPUSH
89012: LD_EXP 36
89016: PUSH
89017: LD_VAR 0 1
89021: ARRAY
89022: PPUSH
89023: LD_EXP 36
89027: PUSH
89028: LD_VAR 0 1
89032: ARRAY
89033: PUSH
89034: LD_INT 1
89036: PLUS
89037: PPUSH
89038: LD_VAR 0 5
89042: PUSH
89043: LD_INT 1
89045: ARRAY
89046: PUSH
89047: LD_VAR 0 7
89051: PUSH
89052: LD_INT 1
89054: ARRAY
89055: PUSH
89056: LD_VAR 0 7
89060: PUSH
89061: LD_INT 2
89063: ARRAY
89064: PUSH
89065: LD_VAR 0 7
89069: PUSH
89070: LD_INT 3
89072: ARRAY
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: PPUSH
89080: CALL_OW 2
89084: PPUSH
89085: CALL_OW 1
89089: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
89090: LD_ADDR_VAR 0 5
89094: PUSH
89095: LD_VAR 0 5
89099: PPUSH
89100: LD_INT 1
89102: PPUSH
89103: CALL_OW 3
89107: ST_TO_ADDR
// if not ext_list then
89108: LD_VAR 0 5
89112: NOT
89113: IFFALSE 89119
// exit ;
89115: POP
89116: POP
89117: GO 89123
// end ;
89119: GO 88994
89121: POP
89122: POP
// end ;
89123: LD_VAR 0 6
89127: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
89128: LD_INT 0
89130: PPUSH
// if not mc_bases or not base or not weapon_list then
89131: LD_EXP 31
89135: NOT
89136: IFTRUE 89145
89138: PUSH
89139: LD_VAR 0 1
89143: NOT
89144: OR
89145: IFTRUE 89154
89147: PUSH
89148: LD_VAR 0 2
89152: NOT
89153: OR
89154: IFFALSE 89158
// exit ;
89156: GO 89183
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
89158: LD_ADDR_EXP 70
89162: PUSH
89163: LD_EXP 70
89167: PPUSH
89168: LD_VAR 0 1
89172: PPUSH
89173: LD_VAR 0 2
89177: PPUSH
89178: CALL_OW 1
89182: ST_TO_ADDR
// end ;
89183: LD_VAR 0 3
89187: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
89188: LD_INT 0
89190: PPUSH
// if not mc_bases or not base or not tech_list then
89191: LD_EXP 31
89195: NOT
89196: IFTRUE 89205
89198: PUSH
89199: LD_VAR 0 1
89203: NOT
89204: OR
89205: IFTRUE 89214
89207: PUSH
89208: LD_VAR 0 2
89212: NOT
89213: OR
89214: IFFALSE 89218
// exit ;
89216: GO 89243
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
89218: LD_ADDR_EXP 58
89222: PUSH
89223: LD_EXP 58
89227: PPUSH
89228: LD_VAR 0 1
89232: PPUSH
89233: LD_VAR 0 2
89237: PPUSH
89238: CALL_OW 1
89242: ST_TO_ADDR
// end ;
89243: LD_VAR 0 3
89247: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
89248: LD_INT 0
89250: PPUSH
// if not mc_bases or not parking_area or not base then
89251: LD_EXP 31
89255: NOT
89256: IFTRUE 89265
89258: PUSH
89259: LD_VAR 0 2
89263: NOT
89264: OR
89265: IFTRUE 89274
89267: PUSH
89268: LD_VAR 0 1
89272: NOT
89273: OR
89274: IFFALSE 89278
// exit ;
89276: GO 89303
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
89278: LD_ADDR_EXP 55
89282: PUSH
89283: LD_EXP 55
89287: PPUSH
89288: LD_VAR 0 1
89292: PPUSH
89293: LD_VAR 0 2
89297: PPUSH
89298: CALL_OW 1
89302: ST_TO_ADDR
// end ;
89303: LD_VAR 0 3
89307: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
89308: LD_INT 0
89310: PPUSH
// if not mc_bases or not base or not scan_area then
89311: LD_EXP 31
89315: NOT
89316: IFTRUE 89325
89318: PUSH
89319: LD_VAR 0 1
89323: NOT
89324: OR
89325: IFTRUE 89334
89327: PUSH
89328: LD_VAR 0 2
89332: NOT
89333: OR
89334: IFFALSE 89338
// exit ;
89336: GO 89363
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
89338: LD_ADDR_EXP 56
89342: PUSH
89343: LD_EXP 56
89347: PPUSH
89348: LD_VAR 0 1
89352: PPUSH
89353: LD_VAR 0 2
89357: PPUSH
89358: CALL_OW 1
89362: ST_TO_ADDR
// end ;
89363: LD_VAR 0 3
89367: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
89368: LD_INT 0
89370: PPUSH
89371: PPUSH
// if not mc_bases or not base then
89372: LD_EXP 31
89376: NOT
89377: IFTRUE 89386
89379: PUSH
89380: LD_VAR 0 1
89384: NOT
89385: OR
89386: IFFALSE 89390
// exit ;
89388: GO 89454
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
89390: LD_ADDR_VAR 0 3
89394: PUSH
89395: LD_INT 1
89397: PUSH
89398: LD_INT 2
89400: PUSH
89401: LD_INT 3
89403: PUSH
89404: LD_INT 4
89406: PUSH
89407: LD_INT 11
89409: PUSH
89410: EMPTY
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
89417: LD_ADDR_EXP 58
89421: PUSH
89422: LD_EXP 58
89426: PPUSH
89427: LD_VAR 0 1
89431: PPUSH
89432: LD_EXP 58
89436: PUSH
89437: LD_VAR 0 1
89441: ARRAY
89442: PUSH
89443: LD_VAR 0 3
89447: DIFF
89448: PPUSH
89449: CALL_OW 1
89453: ST_TO_ADDR
// end ;
89454: LD_VAR 0 2
89458: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
89459: LD_INT 0
89461: PPUSH
// result := mc_vehicles [ base ] ;
89462: LD_ADDR_VAR 0 3
89466: PUSH
89467: LD_EXP 50
89471: PUSH
89472: LD_VAR 0 1
89476: ARRAY
89477: ST_TO_ADDR
// if onlyCombat then
89478: LD_VAR 0 2
89482: IFFALSE 89654
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
89484: LD_ADDR_VAR 0 3
89488: PUSH
89489: LD_VAR 0 3
89493: PUSH
89494: LD_VAR 0 3
89498: PPUSH
89499: LD_INT 2
89501: PUSH
89502: LD_INT 34
89504: PUSH
89505: LD_INT 12
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: PUSH
89512: LD_INT 34
89514: PUSH
89515: LD_INT 51
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 34
89524: PUSH
89525: LD_INT 89
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: LD_INT 34
89534: PUSH
89535: LD_INT 32
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: PUSH
89542: LD_INT 34
89544: PUSH
89545: LD_INT 13
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 34
89554: PUSH
89555: LD_INT 52
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: PUSH
89562: LD_INT 34
89564: PUSH
89565: LD_INT 88
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: PUSH
89572: LD_INT 34
89574: PUSH
89575: LD_INT 14
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: LD_INT 34
89584: PUSH
89585: LD_INT 53
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: PUSH
89592: LD_INT 34
89594: PUSH
89595: LD_INT 98
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: PUSH
89602: LD_INT 34
89604: PUSH
89605: LD_INT 31
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 34
89614: PUSH
89615: LD_INT 48
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 34
89624: PUSH
89625: LD_INT 8
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: PPUSH
89648: CALL_OW 72
89652: DIFF
89653: ST_TO_ADDR
// end ; end_of_file
89654: LD_VAR 0 3
89658: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
89659: LD_INT 0
89661: PPUSH
89662: PPUSH
89663: PPUSH
// if not mc_bases or not skirmish then
89664: LD_EXP 31
89668: NOT
89669: IFTRUE 89678
89671: PUSH
89672: LD_EXP 29
89676: NOT
89677: OR
89678: IFFALSE 89682
// exit ;
89680: GO 89847
// for i = 1 to mc_bases do
89682: LD_ADDR_VAR 0 4
89686: PUSH
89687: DOUBLE
89688: LD_INT 1
89690: DEC
89691: ST_TO_ADDR
89692: LD_EXP 31
89696: PUSH
89697: FOR_TO
89698: IFFALSE 89845
// begin if sci in mc_bases [ i ] then
89700: LD_VAR 0 2
89704: PUSH
89705: LD_EXP 31
89709: PUSH
89710: LD_VAR 0 4
89714: ARRAY
89715: IN
89716: IFFALSE 89843
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
89718: LD_ADDR_EXP 60
89722: PUSH
89723: LD_EXP 60
89727: PPUSH
89728: LD_VAR 0 4
89732: PUSH
89733: LD_EXP 60
89737: PUSH
89738: LD_VAR 0 4
89742: ARRAY
89743: PUSH
89744: LD_INT 1
89746: PLUS
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PPUSH
89752: LD_VAR 0 1
89756: PPUSH
89757: CALL 25063 0 3
89761: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
89762: LD_ADDR_VAR 0 5
89766: PUSH
89767: LD_EXP 31
89771: PUSH
89772: LD_VAR 0 4
89776: ARRAY
89777: PPUSH
89778: LD_INT 2
89780: PUSH
89781: LD_INT 30
89783: PUSH
89784: LD_INT 0
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 30
89793: PUSH
89794: LD_INT 1
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: LIST
89805: PPUSH
89806: CALL_OW 72
89810: PPUSH
89811: LD_VAR 0 1
89815: PPUSH
89816: CALL_OW 74
89820: ST_TO_ADDR
// if tmp then
89821: LD_VAR 0 5
89825: IFFALSE 89841
// ComStandNearbyBuilding ( ape , tmp ) ;
89827: LD_VAR 0 1
89831: PPUSH
89832: LD_VAR 0 5
89836: PPUSH
89837: CALL 21639 0 2
// break ;
89841: GO 89845
// end ; end ;
89843: GO 89697
89845: POP
89846: POP
// end ;
89847: LD_VAR 0 3
89851: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
89852: LD_INT 0
89854: PPUSH
89855: PPUSH
89856: PPUSH
// if not mc_bases or not skirmish then
89857: LD_EXP 31
89861: NOT
89862: IFTRUE 89871
89864: PUSH
89865: LD_EXP 29
89869: NOT
89870: OR
89871: IFFALSE 89875
// exit ;
89873: GO 89964
// for i = 1 to mc_bases do
89875: LD_ADDR_VAR 0 4
89879: PUSH
89880: DOUBLE
89881: LD_INT 1
89883: DEC
89884: ST_TO_ADDR
89885: LD_EXP 31
89889: PUSH
89890: FOR_TO
89891: IFFALSE 89962
// begin if building in mc_busy_turret_list [ i ] then
89893: LD_VAR 0 1
89897: PUSH
89898: LD_EXP 41
89902: PUSH
89903: LD_VAR 0 4
89907: ARRAY
89908: IN
89909: IFFALSE 89960
// begin tmp := mc_busy_turret_list [ i ] diff building ;
89911: LD_ADDR_VAR 0 5
89915: PUSH
89916: LD_EXP 41
89920: PUSH
89921: LD_VAR 0 4
89925: ARRAY
89926: PUSH
89927: LD_VAR 0 1
89931: DIFF
89932: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
89933: LD_ADDR_EXP 41
89937: PUSH
89938: LD_EXP 41
89942: PPUSH
89943: LD_VAR 0 4
89947: PPUSH
89948: LD_VAR 0 5
89952: PPUSH
89953: CALL_OW 1
89957: ST_TO_ADDR
// break ;
89958: GO 89962
// end ; end ;
89960: GO 89890
89962: POP
89963: POP
// end ;
89964: LD_VAR 0 3
89968: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
89969: LD_INT 0
89971: PPUSH
89972: PPUSH
89973: PPUSH
// if not mc_bases or not skirmish then
89974: LD_EXP 31
89978: NOT
89979: IFTRUE 89988
89981: PUSH
89982: LD_EXP 29
89986: NOT
89987: OR
89988: IFFALSE 89992
// exit ;
89990: GO 90191
// for i = 1 to mc_bases do
89992: LD_ADDR_VAR 0 5
89996: PUSH
89997: DOUBLE
89998: LD_INT 1
90000: DEC
90001: ST_TO_ADDR
90002: LD_EXP 31
90006: PUSH
90007: FOR_TO
90008: IFFALSE 90189
// if building in mc_bases [ i ] then
90010: LD_VAR 0 1
90014: PUSH
90015: LD_EXP 31
90019: PUSH
90020: LD_VAR 0 5
90024: ARRAY
90025: IN
90026: IFFALSE 90187
// begin tmp := mc_bases [ i ] diff building ;
90028: LD_ADDR_VAR 0 6
90032: PUSH
90033: LD_EXP 31
90037: PUSH
90038: LD_VAR 0 5
90042: ARRAY
90043: PUSH
90044: LD_VAR 0 1
90048: DIFF
90049: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
90050: LD_ADDR_EXP 31
90054: PUSH
90055: LD_EXP 31
90059: PPUSH
90060: LD_VAR 0 5
90064: PPUSH
90065: LD_VAR 0 6
90069: PPUSH
90070: CALL_OW 1
90074: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
90075: LD_VAR 0 1
90079: PUSH
90080: LD_EXP 39
90084: PUSH
90085: LD_VAR 0 5
90089: ARRAY
90090: IN
90091: IFFALSE 90130
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
90093: LD_ADDR_EXP 39
90097: PUSH
90098: LD_EXP 39
90102: PPUSH
90103: LD_VAR 0 5
90107: PPUSH
90108: LD_EXP 39
90112: PUSH
90113: LD_VAR 0 5
90117: ARRAY
90118: PUSH
90119: LD_VAR 0 1
90123: DIFF
90124: PPUSH
90125: CALL_OW 1
90129: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
90130: LD_VAR 0 1
90134: PUSH
90135: LD_EXP 40
90139: PUSH
90140: LD_VAR 0 5
90144: ARRAY
90145: IN
90146: IFFALSE 90185
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
90148: LD_ADDR_EXP 40
90152: PUSH
90153: LD_EXP 40
90157: PPUSH
90158: LD_VAR 0 5
90162: PPUSH
90163: LD_EXP 40
90167: PUSH
90168: LD_VAR 0 5
90172: ARRAY
90173: PUSH
90174: LD_VAR 0 1
90178: DIFF
90179: PPUSH
90180: CALL_OW 1
90184: ST_TO_ADDR
// break ;
90185: GO 90189
// end ;
90187: GO 90007
90189: POP
90190: POP
// end ;
90191: LD_VAR 0 4
90195: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
90196: LD_INT 0
90198: PPUSH
90199: PPUSH
90200: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
90201: LD_EXP 31
90205: NOT
90206: IFTRUE 90215
90208: PUSH
90209: LD_EXP 29
90213: NOT
90214: OR
90215: IFTRUE 90230
90217: PUSH
90218: LD_VAR 0 3
90222: PUSH
90223: LD_EXP 57
90227: IN
90228: NOT
90229: OR
90230: IFFALSE 90234
// exit ;
90232: GO 90359
// for i = 1 to mc_vehicles do
90234: LD_ADDR_VAR 0 6
90238: PUSH
90239: DOUBLE
90240: LD_INT 1
90242: DEC
90243: ST_TO_ADDR
90244: LD_EXP 50
90248: PUSH
90249: FOR_TO
90250: IFFALSE 90357
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
90252: LD_VAR 0 2
90256: PUSH
90257: LD_EXP 50
90261: PUSH
90262: LD_VAR 0 6
90266: ARRAY
90267: IN
90268: IFTRUE 90288
90270: PUSH
90271: LD_VAR 0 1
90275: PUSH
90276: LD_EXP 50
90280: PUSH
90281: LD_VAR 0 6
90285: ARRAY
90286: IN
90287: OR
90288: IFFALSE 90355
// begin tmp := mc_vehicles [ i ] diff old ;
90290: LD_ADDR_VAR 0 7
90294: PUSH
90295: LD_EXP 50
90299: PUSH
90300: LD_VAR 0 6
90304: ARRAY
90305: PUSH
90306: LD_VAR 0 2
90310: DIFF
90311: ST_TO_ADDR
// tmp := tmp diff new ;
90312: LD_ADDR_VAR 0 7
90316: PUSH
90317: LD_VAR 0 7
90321: PUSH
90322: LD_VAR 0 1
90326: DIFF
90327: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
90328: LD_ADDR_EXP 50
90332: PUSH
90333: LD_EXP 50
90337: PPUSH
90338: LD_VAR 0 6
90342: PPUSH
90343: LD_VAR 0 7
90347: PPUSH
90348: CALL_OW 1
90352: ST_TO_ADDR
// break ;
90353: GO 90357
// end ;
90355: GO 90249
90357: POP
90358: POP
// end ;
90359: LD_VAR 0 5
90363: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
90364: LD_INT 0
90366: PPUSH
90367: PPUSH
90368: PPUSH
90369: PPUSH
// if not mc_bases or not skirmish then
90370: LD_EXP 31
90374: NOT
90375: IFTRUE 90384
90377: PUSH
90378: LD_EXP 29
90382: NOT
90383: OR
90384: IFFALSE 90388
// exit ;
90386: GO 90810
// repeat wait ( 0 0$1 ) ;
90388: LD_INT 35
90390: PPUSH
90391: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
90395: LD_EXP 75
90399: NOT
90400: IFFALSE 90388
// mc_block_vehicle_constructed_thread := true ;
90402: LD_ADDR_EXP 75
90406: PUSH
90407: LD_INT 1
90409: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
90410: LD_ADDR_VAR 0 5
90414: PUSH
90415: LD_VAR 0 1
90419: PPUSH
90420: CALL_OW 255
90424: ST_TO_ADDR
// for i = 1 to mc_bases do
90425: LD_ADDR_VAR 0 4
90429: PUSH
90430: DOUBLE
90431: LD_INT 1
90433: DEC
90434: ST_TO_ADDR
90435: LD_EXP 31
90439: PUSH
90440: FOR_TO
90441: IFFALSE 90800
// begin if factory in mc_bases [ i ] then
90443: LD_VAR 0 2
90447: PUSH
90448: LD_EXP 31
90452: PUSH
90453: LD_VAR 0 4
90457: ARRAY
90458: IN
90459: IFFALSE 90798
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
90461: LD_EXP 53
90465: PUSH
90466: LD_VAR 0 4
90470: ARRAY
90471: PUSH
90472: LD_EXP 42
90476: PUSH
90477: LD_VAR 0 4
90481: ARRAY
90482: LESS
90483: IFFALSE 90572
90485: PUSH
90486: LD_VAR 0 1
90490: PPUSH
90491: CALL_OW 264
90495: PUSH
90496: LD_INT 31
90498: PUSH
90499: LD_INT 32
90501: PUSH
90502: LD_INT 51
90504: PUSH
90505: LD_INT 89
90507: PUSH
90508: LD_INT 12
90510: PUSH
90511: LD_INT 30
90513: PUSH
90514: LD_INT 98
90516: PUSH
90517: LD_INT 11
90519: PUSH
90520: LD_INT 53
90522: PUSH
90523: LD_INT 14
90525: PUSH
90526: LD_INT 91
90528: PUSH
90529: LD_INT 29
90531: PUSH
90532: LD_INT 99
90534: PUSH
90535: LD_INT 13
90537: PUSH
90538: LD_INT 52
90540: PUSH
90541: LD_INT 88
90543: PUSH
90544: LD_INT 48
90546: PUSH
90547: LD_INT 8
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: IN
90570: NOT
90571: AND
90572: IFFALSE 90620
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
90574: LD_ADDR_EXP 53
90578: PUSH
90579: LD_EXP 53
90583: PPUSH
90584: LD_VAR 0 4
90588: PUSH
90589: LD_EXP 53
90593: PUSH
90594: LD_VAR 0 4
90598: ARRAY
90599: PUSH
90600: LD_INT 1
90602: PLUS
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PPUSH
90608: LD_VAR 0 1
90612: PPUSH
90613: CALL 25063 0 3
90617: ST_TO_ADDR
90618: GO 90664
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
90620: LD_ADDR_EXP 50
90624: PUSH
90625: LD_EXP 50
90629: PPUSH
90630: LD_VAR 0 4
90634: PUSH
90635: LD_EXP 50
90639: PUSH
90640: LD_VAR 0 4
90644: ARRAY
90645: PUSH
90646: LD_INT 1
90648: PLUS
90649: PUSH
90650: EMPTY
90651: LIST
90652: LIST
90653: PPUSH
90654: LD_VAR 0 1
90658: PPUSH
90659: CALL 25063 0 3
90663: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
90664: LD_ADDR_EXP 75
90668: PUSH
90669: LD_INT 0
90671: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
90672: LD_VAR 0 1
90676: PPUSH
90677: CALL_OW 263
90681: PUSH
90682: LD_INT 2
90684: EQUAL
90685: IFFALSE 90714
// begin repeat wait ( 0 0$3 ) ;
90687: LD_INT 105
90689: PPUSH
90690: CALL_OW 67
// Connect ( vehicle ) ;
90694: LD_VAR 0 1
90698: PPUSH
90699: CALL 28423 0 1
// until IsControledBy ( vehicle ) ;
90703: LD_VAR 0 1
90707: PPUSH
90708: CALL_OW 312
90712: IFFALSE 90687
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
90714: LD_VAR 0 1
90718: PPUSH
90719: LD_EXP 55
90723: PUSH
90724: LD_VAR 0 4
90728: ARRAY
90729: PPUSH
90730: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
90734: LD_VAR 0 1
90738: PPUSH
90739: CALL_OW 263
90743: PUSH
90744: LD_INT 1
90746: NONEQUAL
90747: IFFALSE 90751
// break ;
90749: GO 90800
// repeat wait ( 0 0$1 ) ;
90751: LD_INT 35
90753: PPUSH
90754: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
90758: LD_VAR 0 1
90762: PPUSH
90763: LD_EXP 55
90767: PUSH
90768: LD_VAR 0 4
90772: ARRAY
90773: PPUSH
90774: CALL_OW 308
90778: IFFALSE 90751
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
90780: LD_VAR 0 1
90784: PPUSH
90785: CALL_OW 311
90789: PPUSH
90790: CALL_OW 121
// exit ;
90794: POP
90795: POP
90796: GO 90810
// end ; end ;
90798: GO 90440
90800: POP
90801: POP
// mc_block_vehicle_constructed_thread := false ;
90802: LD_ADDR_EXP 75
90806: PUSH
90807: LD_INT 0
90809: ST_TO_ADDR
// end ;
90810: LD_VAR 0 3
90814: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
90815: LD_INT 0
90817: PPUSH
90818: PPUSH
90819: PPUSH
90820: PPUSH
// if not mc_bases or not skirmish then
90821: LD_EXP 31
90825: NOT
90826: IFTRUE 90835
90828: PUSH
90829: LD_EXP 29
90833: NOT
90834: OR
90835: IFFALSE 90839
// exit ;
90837: GO 91192
// repeat wait ( 0 0$1 ) ;
90839: LD_INT 35
90841: PPUSH
90842: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
90846: LD_VAR 0 2
90850: PPUSH
90851: LD_VAR 0 3
90855: PPUSH
90856: CALL_OW 284
90860: IFFALSE 90839
// if GetResourceTypeXY ( x , y ) = mat_artefact then
90862: LD_VAR 0 2
90866: PPUSH
90867: LD_VAR 0 3
90871: PPUSH
90872: CALL_OW 283
90876: PUSH
90877: LD_INT 4
90879: EQUAL
90880: IFFALSE 90884
// exit ;
90882: GO 91192
// for i = 1 to mc_bases do
90884: LD_ADDR_VAR 0 7
90888: PUSH
90889: DOUBLE
90890: LD_INT 1
90892: DEC
90893: ST_TO_ADDR
90894: LD_EXP 31
90898: PUSH
90899: FOR_TO
90900: IFFALSE 91190
// begin if mc_crates_area [ i ] then
90902: LD_EXP 49
90906: PUSH
90907: LD_VAR 0 7
90911: ARRAY
90912: IFFALSE 91023
// for j in mc_crates_area [ i ] do
90914: LD_ADDR_VAR 0 8
90918: PUSH
90919: LD_EXP 49
90923: PUSH
90924: LD_VAR 0 7
90928: ARRAY
90929: PUSH
90930: FOR_IN
90931: IFFALSE 91021
// if InArea ( x , y , j ) then
90933: LD_VAR 0 2
90937: PPUSH
90938: LD_VAR 0 3
90942: PPUSH
90943: LD_VAR 0 8
90947: PPUSH
90948: CALL_OW 309
90952: IFFALSE 91019
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
90954: LD_ADDR_EXP 47
90958: PUSH
90959: LD_EXP 47
90963: PPUSH
90964: LD_VAR 0 7
90968: PUSH
90969: LD_EXP 47
90973: PUSH
90974: LD_VAR 0 7
90978: ARRAY
90979: PUSH
90980: LD_INT 1
90982: PLUS
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PPUSH
90988: LD_VAR 0 4
90992: PUSH
90993: LD_VAR 0 2
90997: PUSH
90998: LD_VAR 0 3
91002: PUSH
91003: EMPTY
91004: LIST
91005: LIST
91006: LIST
91007: PPUSH
91008: CALL 25063 0 3
91012: ST_TO_ADDR
// exit ;
91013: POP
91014: POP
91015: POP
91016: POP
91017: GO 91192
// end ;
91019: GO 90930
91021: POP
91022: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
91023: LD_ADDR_VAR 0 9
91027: PUSH
91028: LD_EXP 31
91032: PUSH
91033: LD_VAR 0 7
91037: ARRAY
91038: PPUSH
91039: LD_INT 2
91041: PUSH
91042: LD_INT 30
91044: PUSH
91045: LD_INT 0
91047: PUSH
91048: EMPTY
91049: LIST
91050: LIST
91051: PUSH
91052: LD_INT 30
91054: PUSH
91055: LD_INT 1
91057: PUSH
91058: EMPTY
91059: LIST
91060: LIST
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: LIST
91066: PPUSH
91067: CALL_OW 72
91071: ST_TO_ADDR
// if not depot then
91072: LD_VAR 0 9
91076: NOT
91077: IFFALSE 91081
// continue ;
91079: GO 90899
// for j in depot do
91081: LD_ADDR_VAR 0 8
91085: PUSH
91086: LD_VAR 0 9
91090: PUSH
91091: FOR_IN
91092: IFFALSE 91186
// if GetDistUnitXY ( j , x , y ) < 30 then
91094: LD_VAR 0 8
91098: PPUSH
91099: LD_VAR 0 2
91103: PPUSH
91104: LD_VAR 0 3
91108: PPUSH
91109: CALL_OW 297
91113: PUSH
91114: LD_INT 30
91116: LESS
91117: IFFALSE 91184
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
91119: LD_ADDR_EXP 47
91123: PUSH
91124: LD_EXP 47
91128: PPUSH
91129: LD_VAR 0 7
91133: PUSH
91134: LD_EXP 47
91138: PUSH
91139: LD_VAR 0 7
91143: ARRAY
91144: PUSH
91145: LD_INT 1
91147: PLUS
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PPUSH
91153: LD_VAR 0 4
91157: PUSH
91158: LD_VAR 0 2
91162: PUSH
91163: LD_VAR 0 3
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: LIST
91172: PPUSH
91173: CALL 25063 0 3
91177: ST_TO_ADDR
// exit ;
91178: POP
91179: POP
91180: POP
91181: POP
91182: GO 91192
// end ;
91184: GO 91091
91186: POP
91187: POP
// end ;
91188: GO 90899
91190: POP
91191: POP
// end ;
91192: LD_VAR 0 6
91196: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
91197: LD_INT 0
91199: PPUSH
91200: PPUSH
91201: PPUSH
91202: PPUSH
// if not mc_bases or not skirmish then
91203: LD_EXP 31
91207: NOT
91208: IFTRUE 91217
91210: PUSH
91211: LD_EXP 29
91215: NOT
91216: OR
91217: IFFALSE 91221
// exit ;
91219: GO 91504
// side := GetSide ( lab ) ;
91221: LD_ADDR_VAR 0 4
91225: PUSH
91226: LD_VAR 0 2
91230: PPUSH
91231: CALL_OW 255
91235: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
91236: LD_VAR 0 4
91240: PUSH
91241: LD_EXP 57
91245: IN
91246: NOT
91247: IFTRUE 91256
91249: PUSH
91250: LD_EXP 58
91254: NOT
91255: OR
91256: IFTRUE 91265
91258: PUSH
91259: LD_EXP 31
91263: NOT
91264: OR
91265: IFFALSE 91269
// exit ;
91267: GO 91504
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
91269: LD_ADDR_EXP 58
91273: PUSH
91274: LD_EXP 58
91278: PPUSH
91279: LD_VAR 0 4
91283: PPUSH
91284: LD_EXP 58
91288: PUSH
91289: LD_VAR 0 4
91293: ARRAY
91294: PUSH
91295: LD_VAR 0 1
91299: DIFF
91300: PPUSH
91301: CALL_OW 1
91305: ST_TO_ADDR
// for i = 1 to mc_bases do
91306: LD_ADDR_VAR 0 5
91310: PUSH
91311: DOUBLE
91312: LD_INT 1
91314: DEC
91315: ST_TO_ADDR
91316: LD_EXP 31
91320: PUSH
91321: FOR_TO
91322: IFFALSE 91502
// begin if lab in mc_bases [ i ] then
91324: LD_VAR 0 2
91328: PUSH
91329: LD_EXP 31
91333: PUSH
91334: LD_VAR 0 5
91338: ARRAY
91339: IN
91340: IFFALSE 91500
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
91342: LD_VAR 0 1
91346: PUSH
91347: LD_INT 11
91349: PUSH
91350: LD_INT 4
91352: PUSH
91353: LD_INT 3
91355: PUSH
91356: LD_INT 2
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: IN
91365: IFFALSE 91379
91367: PUSH
91368: LD_EXP 61
91372: PUSH
91373: LD_VAR 0 5
91377: ARRAY
91378: AND
91379: IFFALSE 91500
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
91381: LD_ADDR_VAR 0 6
91385: PUSH
91386: LD_EXP 61
91390: PUSH
91391: LD_VAR 0 5
91395: ARRAY
91396: PUSH
91397: LD_INT 1
91399: ARRAY
91400: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
91401: LD_ADDR_EXP 61
91405: PUSH
91406: LD_EXP 61
91410: PPUSH
91411: LD_VAR 0 5
91415: PPUSH
91416: EMPTY
91417: PPUSH
91418: CALL_OW 1
91422: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
91423: LD_VAR 0 6
91427: PPUSH
91428: LD_INT 0
91430: PPUSH
91431: CALL_OW 109
// ComExitBuilding ( tmp ) ;
91435: LD_VAR 0 6
91439: PPUSH
91440: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
91444: LD_ADDR_EXP 60
91448: PUSH
91449: LD_EXP 60
91453: PPUSH
91454: LD_VAR 0 5
91458: PPUSH
91459: LD_EXP 60
91463: PUSH
91464: LD_VAR 0 5
91468: ARRAY
91469: PPUSH
91470: LD_INT 1
91472: PPUSH
91473: LD_VAR 0 6
91477: PPUSH
91478: CALL_OW 2
91482: PPUSH
91483: CALL_OW 1
91487: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
91488: LD_VAR 0 5
91492: PPUSH
91493: LD_INT 112
91495: PPUSH
91496: CALL 67634 0 2
// end ; end ; end ;
91500: GO 91321
91502: POP
91503: POP
// end ;
91504: LD_VAR 0 3
91508: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
91509: LD_INT 0
91511: PPUSH
91512: PPUSH
91513: PPUSH
91514: PPUSH
91515: PPUSH
91516: PPUSH
91517: PPUSH
91518: PPUSH
// if not mc_bases or not skirmish then
91519: LD_EXP 31
91523: NOT
91524: IFTRUE 91533
91526: PUSH
91527: LD_EXP 29
91531: NOT
91532: OR
91533: IFFALSE 91537
// exit ;
91535: GO 92922
// for i = 1 to mc_bases do
91537: LD_ADDR_VAR 0 3
91541: PUSH
91542: DOUBLE
91543: LD_INT 1
91545: DEC
91546: ST_TO_ADDR
91547: LD_EXP 31
91551: PUSH
91552: FOR_TO
91553: IFFALSE 92920
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
91555: LD_VAR 0 1
91559: PUSH
91560: LD_EXP 31
91564: PUSH
91565: LD_VAR 0 3
91569: ARRAY
91570: IN
91571: IFTRUE 91591
91573: PUSH
91574: LD_VAR 0 1
91578: PUSH
91579: LD_EXP 38
91583: PUSH
91584: LD_VAR 0 3
91588: ARRAY
91589: IN
91590: OR
91591: IFTRUE 91611
91593: PUSH
91594: LD_VAR 0 1
91598: PUSH
91599: LD_EXP 53
91603: PUSH
91604: LD_VAR 0 3
91608: ARRAY
91609: IN
91610: OR
91611: IFTRUE 91631
91613: PUSH
91614: LD_VAR 0 1
91618: PUSH
91619: LD_EXP 50
91623: PUSH
91624: LD_VAR 0 3
91628: ARRAY
91629: IN
91630: OR
91631: IFTRUE 91651
91633: PUSH
91634: LD_VAR 0 1
91638: PUSH
91639: LD_EXP 60
91643: PUSH
91644: LD_VAR 0 3
91648: ARRAY
91649: IN
91650: OR
91651: IFTRUE 91671
91653: PUSH
91654: LD_VAR 0 1
91658: PUSH
91659: LD_EXP 61
91663: PUSH
91664: LD_VAR 0 3
91668: ARRAY
91669: IN
91670: OR
91671: IFFALSE 92918
// begin if un in mc_ape [ i ] then
91673: LD_VAR 0 1
91677: PUSH
91678: LD_EXP 60
91682: PUSH
91683: LD_VAR 0 3
91687: ARRAY
91688: IN
91689: IFFALSE 91728
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
91691: LD_ADDR_EXP 60
91695: PUSH
91696: LD_EXP 60
91700: PPUSH
91701: LD_VAR 0 3
91705: PPUSH
91706: LD_EXP 60
91710: PUSH
91711: LD_VAR 0 3
91715: ARRAY
91716: PUSH
91717: LD_VAR 0 1
91721: DIFF
91722: PPUSH
91723: CALL_OW 1
91727: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
91728: LD_VAR 0 1
91732: PUSH
91733: LD_EXP 61
91737: PUSH
91738: LD_VAR 0 3
91742: ARRAY
91743: IN
91744: IFFALSE 91768
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
91746: LD_ADDR_EXP 61
91750: PUSH
91751: LD_EXP 61
91755: PPUSH
91756: LD_VAR 0 3
91760: PPUSH
91761: EMPTY
91762: PPUSH
91763: CALL_OW 1
91767: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
91768: LD_VAR 0 1
91772: PPUSH
91773: CALL_OW 247
91777: PUSH
91778: LD_INT 2
91780: EQUAL
91781: IFFALSE 91862
91783: PUSH
91784: LD_VAR 0 1
91788: PPUSH
91789: CALL_OW 110
91793: PUSH
91794: LD_INT 20
91796: EQUAL
91797: IFTRUE 91817
91799: PUSH
91800: LD_VAR 0 1
91804: PUSH
91805: LD_EXP 53
91809: PUSH
91810: LD_VAR 0 3
91814: ARRAY
91815: IN
91816: OR
91817: IFTRUE 91861
91819: PUSH
91820: LD_VAR 0 1
91824: PPUSH
91825: CALL_OW 264
91829: PUSH
91830: LD_INT 12
91832: PUSH
91833: LD_INT 51
91835: PUSH
91836: LD_INT 89
91838: PUSH
91839: LD_INT 32
91841: PUSH
91842: LD_INT 13
91844: PUSH
91845: LD_INT 52
91847: PUSH
91848: LD_INT 31
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: IN
91860: OR
91861: AND
91862: IFFALSE 92170
// begin if un in mc_defender [ i ] then
91864: LD_VAR 0 1
91868: PUSH
91869: LD_EXP 53
91873: PUSH
91874: LD_VAR 0 3
91878: ARRAY
91879: IN
91880: IFFALSE 91919
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
91882: LD_ADDR_EXP 53
91886: PUSH
91887: LD_EXP 53
91891: PPUSH
91892: LD_VAR 0 3
91896: PPUSH
91897: LD_EXP 53
91901: PUSH
91902: LD_VAR 0 3
91906: ARRAY
91907: PUSH
91908: LD_VAR 0 1
91912: DIFF
91913: PPUSH
91914: CALL_OW 1
91918: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
91919: LD_ADDR_VAR 0 8
91923: PUSH
91924: LD_VAR 0 3
91928: PPUSH
91929: LD_INT 3
91931: PPUSH
91932: CALL 88458 0 2
91936: ST_TO_ADDR
// if fac then
91937: LD_VAR 0 8
91941: IFFALSE 92170
// begin for j in fac do
91943: LD_ADDR_VAR 0 4
91947: PUSH
91948: LD_VAR 0 8
91952: PUSH
91953: FOR_IN
91954: IFFALSE 92168
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
91956: LD_ADDR_VAR 0 9
91960: PUSH
91961: LD_VAR 0 8
91965: PPUSH
91966: LD_VAR 0 1
91970: PPUSH
91971: CALL_OW 265
91975: PPUSH
91976: LD_VAR 0 1
91980: PPUSH
91981: CALL_OW 262
91985: PPUSH
91986: LD_VAR 0 1
91990: PPUSH
91991: CALL_OW 263
91995: PPUSH
91996: LD_VAR 0 1
92000: PPUSH
92001: CALL_OW 264
92005: PPUSH
92006: CALL 22537 0 5
92010: ST_TO_ADDR
// if components then
92011: LD_VAR 0 9
92015: IFFALSE 92166
// begin if GetWeapon ( un ) = ar_control_tower then
92017: LD_VAR 0 1
92021: PPUSH
92022: CALL_OW 264
92026: PUSH
92027: LD_INT 31
92029: EQUAL
92030: IFFALSE 92147
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
92032: LD_VAR 0 1
92036: PPUSH
92037: CALL_OW 311
92041: PPUSH
92042: LD_INT 0
92044: PPUSH
92045: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
92049: LD_ADDR_EXP 71
92053: PUSH
92054: LD_EXP 71
92058: PPUSH
92059: LD_VAR 0 3
92063: PPUSH
92064: LD_EXP 71
92068: PUSH
92069: LD_VAR 0 3
92073: ARRAY
92074: PUSH
92075: LD_VAR 0 1
92079: PPUSH
92080: CALL_OW 311
92084: DIFF
92085: PPUSH
92086: CALL_OW 1
92090: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
92091: LD_ADDR_VAR 0 7
92095: PUSH
92096: LD_EXP 52
92100: PUSH
92101: LD_VAR 0 3
92105: ARRAY
92106: PPUSH
92107: LD_INT 1
92109: PPUSH
92110: LD_VAR 0 9
92114: PPUSH
92115: CALL_OW 2
92119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
92120: LD_ADDR_EXP 52
92124: PUSH
92125: LD_EXP 52
92129: PPUSH
92130: LD_VAR 0 3
92134: PPUSH
92135: LD_VAR 0 7
92139: PPUSH
92140: CALL_OW 1
92144: ST_TO_ADDR
// end else
92145: GO 92164
// MC_InsertProduceList ( i , [ components ] ) ;
92147: LD_VAR 0 3
92151: PPUSH
92152: LD_VAR 0 9
92156: PUSH
92157: EMPTY
92158: LIST
92159: PPUSH
92160: CALL 88003 0 2
// break ;
92164: GO 92168
// end ; end ;
92166: GO 91953
92168: POP
92169: POP
// end ; end ; if GetType ( un ) = unit_building then
92170: LD_VAR 0 1
92174: PPUSH
92175: CALL_OW 247
92179: PUSH
92180: LD_INT 3
92182: EQUAL
92183: IFFALSE 92586
// begin btype := GetBType ( un ) ;
92185: LD_ADDR_VAR 0 5
92189: PUSH
92190: LD_VAR 0 1
92194: PPUSH
92195: CALL_OW 266
92199: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
92200: LD_VAR 0 5
92204: PUSH
92205: LD_INT 29
92207: PUSH
92208: LD_INT 30
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: IN
92215: IFFALSE 92288
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
92217: LD_VAR 0 1
92221: PPUSH
92222: CALL_OW 250
92226: PPUSH
92227: LD_VAR 0 1
92231: PPUSH
92232: CALL_OW 251
92236: PPUSH
92237: LD_VAR 0 1
92241: PPUSH
92242: CALL_OW 255
92246: PPUSH
92247: CALL_OW 440
92251: NOT
92252: IFFALSE 92288
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
92254: LD_VAR 0 1
92258: PPUSH
92259: CALL_OW 250
92263: PPUSH
92264: LD_VAR 0 1
92268: PPUSH
92269: CALL_OW 251
92273: PPUSH
92274: LD_VAR 0 1
92278: PPUSH
92279: CALL_OW 255
92283: PPUSH
92284: CALL_OW 441
// end ; if btype = b_warehouse then
92288: LD_VAR 0 5
92292: PUSH
92293: LD_INT 1
92295: EQUAL
92296: IFFALSE 92314
// begin btype := b_depot ;
92298: LD_ADDR_VAR 0 5
92302: PUSH
92303: LD_INT 0
92305: ST_TO_ADDR
// pos := 1 ;
92306: LD_ADDR_VAR 0 6
92310: PUSH
92311: LD_INT 1
92313: ST_TO_ADDR
// end ; if btype = b_factory then
92314: LD_VAR 0 5
92318: PUSH
92319: LD_INT 3
92321: EQUAL
92322: IFFALSE 92340
// begin btype := b_workshop ;
92324: LD_ADDR_VAR 0 5
92328: PUSH
92329: LD_INT 2
92331: ST_TO_ADDR
// pos := 1 ;
92332: LD_ADDR_VAR 0 6
92336: PUSH
92337: LD_INT 1
92339: ST_TO_ADDR
// end ; if btype = b_barracks then
92340: LD_VAR 0 5
92344: PUSH
92345: LD_INT 5
92347: EQUAL
92348: IFFALSE 92358
// btype := b_armoury ;
92350: LD_ADDR_VAR 0 5
92354: PUSH
92355: LD_INT 4
92357: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
92358: LD_VAR 0 5
92362: PUSH
92363: LD_INT 7
92365: PUSH
92366: LD_INT 8
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: IN
92373: IFFALSE 92383
// btype := b_lab ;
92375: LD_ADDR_VAR 0 5
92379: PUSH
92380: LD_INT 6
92382: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
92383: LD_ADDR_EXP 36
92387: PUSH
92388: LD_EXP 36
92392: PPUSH
92393: LD_VAR 0 3
92397: PUSH
92398: LD_EXP 36
92402: PUSH
92403: LD_VAR 0 3
92407: ARRAY
92408: PUSH
92409: LD_INT 1
92411: PLUS
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PPUSH
92417: LD_VAR 0 5
92421: PUSH
92422: LD_VAR 0 1
92426: PPUSH
92427: CALL_OW 250
92431: PUSH
92432: LD_VAR 0 1
92436: PPUSH
92437: CALL_OW 251
92441: PUSH
92442: LD_VAR 0 1
92446: PPUSH
92447: CALL_OW 254
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: PPUSH
92458: CALL 25063 0 3
92462: ST_TO_ADDR
// if pos = 1 then
92463: LD_VAR 0 6
92467: PUSH
92468: LD_INT 1
92470: EQUAL
92471: IFFALSE 92586
// begin tmp := mc_build_list [ i ] ;
92473: LD_ADDR_VAR 0 7
92477: PUSH
92478: LD_EXP 36
92482: PUSH
92483: LD_VAR 0 3
92487: ARRAY
92488: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
92489: LD_VAR 0 7
92493: PPUSH
92494: LD_INT 2
92496: PUSH
92497: LD_INT 30
92499: PUSH
92500: LD_INT 0
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: LD_INT 30
92509: PUSH
92510: LD_INT 1
92512: PUSH
92513: EMPTY
92514: LIST
92515: LIST
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: LIST
92521: PPUSH
92522: CALL_OW 72
92526: IFFALSE 92536
// pos := 2 ;
92528: LD_ADDR_VAR 0 6
92532: PUSH
92533: LD_INT 2
92535: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
92536: LD_ADDR_VAR 0 7
92540: PUSH
92541: LD_VAR 0 7
92545: PPUSH
92546: LD_VAR 0 6
92550: PPUSH
92551: LD_VAR 0 7
92555: PPUSH
92556: CALL 25389 0 3
92560: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
92561: LD_ADDR_EXP 36
92565: PUSH
92566: LD_EXP 36
92570: PPUSH
92571: LD_VAR 0 3
92575: PPUSH
92576: LD_VAR 0 7
92580: PPUSH
92581: CALL_OW 1
92585: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
92586: LD_VAR 0 1
92590: PUSH
92591: LD_EXP 31
92595: PUSH
92596: LD_VAR 0 3
92600: ARRAY
92601: IN
92602: IFFALSE 92641
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
92604: LD_ADDR_EXP 31
92608: PUSH
92609: LD_EXP 31
92613: PPUSH
92614: LD_VAR 0 3
92618: PPUSH
92619: LD_EXP 31
92623: PUSH
92624: LD_VAR 0 3
92628: ARRAY
92629: PUSH
92630: LD_VAR 0 1
92634: DIFF
92635: PPUSH
92636: CALL_OW 1
92640: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
92641: LD_VAR 0 1
92645: PUSH
92646: LD_EXP 38
92650: PUSH
92651: LD_VAR 0 3
92655: ARRAY
92656: IN
92657: IFFALSE 92696
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
92659: LD_ADDR_EXP 38
92663: PUSH
92664: LD_EXP 38
92668: PPUSH
92669: LD_VAR 0 3
92673: PPUSH
92674: LD_EXP 38
92678: PUSH
92679: LD_VAR 0 3
92683: ARRAY
92684: PUSH
92685: LD_VAR 0 1
92689: DIFF
92690: PPUSH
92691: CALL_OW 1
92695: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
92696: LD_VAR 0 1
92700: PUSH
92701: LD_EXP 50
92705: PUSH
92706: LD_VAR 0 3
92710: ARRAY
92711: IN
92712: IFFALSE 92751
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
92714: LD_ADDR_EXP 50
92718: PUSH
92719: LD_EXP 50
92723: PPUSH
92724: LD_VAR 0 3
92728: PPUSH
92729: LD_EXP 50
92733: PUSH
92734: LD_VAR 0 3
92738: ARRAY
92739: PUSH
92740: LD_VAR 0 1
92744: DIFF
92745: PPUSH
92746: CALL_OW 1
92750: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
92751: LD_VAR 0 1
92755: PUSH
92756: LD_EXP 53
92760: PUSH
92761: LD_VAR 0 3
92765: ARRAY
92766: IN
92767: IFFALSE 92806
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
92769: LD_ADDR_EXP 53
92773: PUSH
92774: LD_EXP 53
92778: PPUSH
92779: LD_VAR 0 3
92783: PPUSH
92784: LD_EXP 53
92788: PUSH
92789: LD_VAR 0 3
92793: ARRAY
92794: PUSH
92795: LD_VAR 0 1
92799: DIFF
92800: PPUSH
92801: CALL_OW 1
92805: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
92806: LD_VAR 0 1
92810: PUSH
92811: LD_EXP 40
92815: PUSH
92816: LD_VAR 0 3
92820: ARRAY
92821: IN
92822: IFFALSE 92861
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
92824: LD_ADDR_EXP 40
92828: PUSH
92829: LD_EXP 40
92833: PPUSH
92834: LD_VAR 0 3
92838: PPUSH
92839: LD_EXP 40
92843: PUSH
92844: LD_VAR 0 3
92848: ARRAY
92849: PUSH
92850: LD_VAR 0 1
92854: DIFF
92855: PPUSH
92856: CALL_OW 1
92860: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
92861: LD_VAR 0 1
92865: PUSH
92866: LD_EXP 39
92870: PUSH
92871: LD_VAR 0 3
92875: ARRAY
92876: IN
92877: IFFALSE 92916
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
92879: LD_ADDR_EXP 39
92883: PUSH
92884: LD_EXP 39
92888: PPUSH
92889: LD_VAR 0 3
92893: PPUSH
92894: LD_EXP 39
92898: PUSH
92899: LD_VAR 0 3
92903: ARRAY
92904: PUSH
92905: LD_VAR 0 1
92909: DIFF
92910: PPUSH
92911: CALL_OW 1
92915: ST_TO_ADDR
// end ; break ;
92916: GO 92920
// end ;
92918: GO 91552
92920: POP
92921: POP
// end ;
92922: LD_VAR 0 2
92926: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
92927: LD_INT 0
92929: PPUSH
92930: PPUSH
92931: PPUSH
// if not mc_bases or not skirmish then
92932: LD_EXP 31
92936: NOT
92937: IFTRUE 92946
92939: PUSH
92940: LD_EXP 29
92944: NOT
92945: OR
92946: IFFALSE 92950
// exit ;
92948: GO 93165
// for i = 1 to mc_bases do
92950: LD_ADDR_VAR 0 3
92954: PUSH
92955: DOUBLE
92956: LD_INT 1
92958: DEC
92959: ST_TO_ADDR
92960: LD_EXP 31
92964: PUSH
92965: FOR_TO
92966: IFFALSE 93163
// begin if building in mc_construct_list [ i ] then
92968: LD_VAR 0 1
92972: PUSH
92973: LD_EXP 38
92977: PUSH
92978: LD_VAR 0 3
92982: ARRAY
92983: IN
92984: IFFALSE 93161
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
92986: LD_ADDR_EXP 38
92990: PUSH
92991: LD_EXP 38
92995: PPUSH
92996: LD_VAR 0 3
93000: PPUSH
93001: LD_EXP 38
93005: PUSH
93006: LD_VAR 0 3
93010: ARRAY
93011: PUSH
93012: LD_VAR 0 1
93016: DIFF
93017: PPUSH
93018: CALL_OW 1
93022: ST_TO_ADDR
// if building in mc_lab [ i ] then
93023: LD_VAR 0 1
93027: PUSH
93028: LD_EXP 64
93032: PUSH
93033: LD_VAR 0 3
93037: ARRAY
93038: IN
93039: IFFALSE 93094
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
93041: LD_ADDR_EXP 65
93045: PUSH
93046: LD_EXP 65
93050: PPUSH
93051: LD_VAR 0 3
93055: PPUSH
93056: LD_EXP 65
93060: PUSH
93061: LD_VAR 0 3
93065: ARRAY
93066: PPUSH
93067: LD_INT 1
93069: PPUSH
93070: LD_EXP 65
93074: PUSH
93075: LD_VAR 0 3
93079: ARRAY
93080: PPUSH
93081: LD_INT 0
93083: PPUSH
93084: CALL 24471 0 4
93088: PPUSH
93089: CALL_OW 1
93093: ST_TO_ADDR
// if not building in mc_bases [ i ] then
93094: LD_VAR 0 1
93098: PUSH
93099: LD_EXP 31
93103: PUSH
93104: LD_VAR 0 3
93108: ARRAY
93109: IN
93110: NOT
93111: IFFALSE 93157
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
93113: LD_ADDR_EXP 31
93117: PUSH
93118: LD_EXP 31
93122: PPUSH
93123: LD_VAR 0 3
93127: PUSH
93128: LD_EXP 31
93132: PUSH
93133: LD_VAR 0 3
93137: ARRAY
93138: PUSH
93139: LD_INT 1
93141: PLUS
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: PPUSH
93147: LD_VAR 0 1
93151: PPUSH
93152: CALL 25063 0 3
93156: ST_TO_ADDR
// exit ;
93157: POP
93158: POP
93159: GO 93165
// end ; end ;
93161: GO 92965
93163: POP
93164: POP
// end ;
93165: LD_VAR 0 2
93169: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
93170: LD_INT 0
93172: PPUSH
93173: PPUSH
93174: PPUSH
93175: PPUSH
93176: PPUSH
93177: PPUSH
93178: PPUSH
// if not mc_bases or not skirmish then
93179: LD_EXP 31
93183: NOT
93184: IFTRUE 93193
93186: PUSH
93187: LD_EXP 29
93191: NOT
93192: OR
93193: IFFALSE 93197
// exit ;
93195: GO 93858
// for i = 1 to mc_bases do
93197: LD_ADDR_VAR 0 3
93201: PUSH
93202: DOUBLE
93203: LD_INT 1
93205: DEC
93206: ST_TO_ADDR
93207: LD_EXP 31
93211: PUSH
93212: FOR_TO
93213: IFFALSE 93856
// begin if building in mc_construct_list [ i ] then
93215: LD_VAR 0 1
93219: PUSH
93220: LD_EXP 38
93224: PUSH
93225: LD_VAR 0 3
93229: ARRAY
93230: IN
93231: IFFALSE 93854
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
93233: LD_ADDR_EXP 38
93237: PUSH
93238: LD_EXP 38
93242: PPUSH
93243: LD_VAR 0 3
93247: PPUSH
93248: LD_EXP 38
93252: PUSH
93253: LD_VAR 0 3
93257: ARRAY
93258: PUSH
93259: LD_VAR 0 1
93263: DIFF
93264: PPUSH
93265: CALL_OW 1
93269: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
93270: LD_ADDR_EXP 31
93274: PUSH
93275: LD_EXP 31
93279: PPUSH
93280: LD_VAR 0 3
93284: PUSH
93285: LD_EXP 31
93289: PUSH
93290: LD_VAR 0 3
93294: ARRAY
93295: PUSH
93296: LD_INT 1
93298: PLUS
93299: PUSH
93300: EMPTY
93301: LIST
93302: LIST
93303: PPUSH
93304: LD_VAR 0 1
93308: PPUSH
93309: CALL 25063 0 3
93313: ST_TO_ADDR
// btype := GetBType ( building ) ;
93314: LD_ADDR_VAR 0 5
93318: PUSH
93319: LD_VAR 0 1
93323: PPUSH
93324: CALL_OW 266
93328: ST_TO_ADDR
// side := GetSide ( building ) ;
93329: LD_ADDR_VAR 0 8
93333: PUSH
93334: LD_VAR 0 1
93338: PPUSH
93339: CALL_OW 255
93343: ST_TO_ADDR
// if btype = b_lab then
93344: LD_VAR 0 5
93348: PUSH
93349: LD_INT 6
93351: EQUAL
93352: IFFALSE 93402
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
93354: LD_ADDR_EXP 64
93358: PUSH
93359: LD_EXP 64
93363: PPUSH
93364: LD_VAR 0 3
93368: PUSH
93369: LD_EXP 64
93373: PUSH
93374: LD_VAR 0 3
93378: ARRAY
93379: PUSH
93380: LD_INT 1
93382: PLUS
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PPUSH
93388: LD_VAR 0 1
93392: PPUSH
93393: CALL 25063 0 3
93397: ST_TO_ADDR
// exit ;
93398: POP
93399: POP
93400: GO 93858
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
93402: LD_VAR 0 5
93406: PUSH
93407: LD_INT 0
93409: PUSH
93410: LD_INT 2
93412: PUSH
93413: LD_INT 4
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: LIST
93420: IN
93421: IFFALSE 93545
// begin if btype = b_armoury then
93423: LD_VAR 0 5
93427: PUSH
93428: LD_INT 4
93430: EQUAL
93431: IFFALSE 93441
// btype := b_barracks ;
93433: LD_ADDR_VAR 0 5
93437: PUSH
93438: LD_INT 5
93440: ST_TO_ADDR
// if btype = b_depot then
93441: LD_VAR 0 5
93445: PUSH
93446: LD_INT 0
93448: EQUAL
93449: IFFALSE 93459
// btype := b_warehouse ;
93451: LD_ADDR_VAR 0 5
93455: PUSH
93456: LD_INT 1
93458: ST_TO_ADDR
// if btype = b_workshop then
93459: LD_VAR 0 5
93463: PUSH
93464: LD_INT 2
93466: EQUAL
93467: IFFALSE 93477
// btype := b_factory ;
93469: LD_ADDR_VAR 0 5
93473: PUSH
93474: LD_INT 3
93476: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
93477: LD_VAR 0 5
93481: PPUSH
93482: LD_VAR 0 8
93486: PPUSH
93487: CALL_OW 323
93491: PUSH
93492: LD_INT 1
93494: EQUAL
93495: IFFALSE 93541
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
93497: LD_ADDR_EXP 63
93501: PUSH
93502: LD_EXP 63
93506: PPUSH
93507: LD_VAR 0 3
93511: PUSH
93512: LD_EXP 63
93516: PUSH
93517: LD_VAR 0 3
93521: ARRAY
93522: PUSH
93523: LD_INT 1
93525: PLUS
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PPUSH
93531: LD_VAR 0 1
93535: PPUSH
93536: CALL 25063 0 3
93540: ST_TO_ADDR
// exit ;
93541: POP
93542: POP
93543: GO 93858
// end ; if btype in [ b_bunker , b_turret ] then
93545: LD_VAR 0 5
93549: PUSH
93550: LD_INT 32
93552: PUSH
93553: LD_INT 33
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: IN
93560: IFFALSE 93850
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
93562: LD_ADDR_EXP 39
93566: PUSH
93567: LD_EXP 39
93571: PPUSH
93572: LD_VAR 0 3
93576: PUSH
93577: LD_EXP 39
93581: PUSH
93582: LD_VAR 0 3
93586: ARRAY
93587: PUSH
93588: LD_INT 1
93590: PLUS
93591: PUSH
93592: EMPTY
93593: LIST
93594: LIST
93595: PPUSH
93596: LD_VAR 0 1
93600: PPUSH
93601: CALL 25063 0 3
93605: ST_TO_ADDR
// if btype = b_bunker then
93606: LD_VAR 0 5
93610: PUSH
93611: LD_INT 32
93613: EQUAL
93614: IFFALSE 93850
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
93616: LD_ADDR_EXP 40
93620: PUSH
93621: LD_EXP 40
93625: PPUSH
93626: LD_VAR 0 3
93630: PUSH
93631: LD_EXP 40
93635: PUSH
93636: LD_VAR 0 3
93640: ARRAY
93641: PUSH
93642: LD_INT 1
93644: PLUS
93645: PUSH
93646: EMPTY
93647: LIST
93648: LIST
93649: PPUSH
93650: LD_VAR 0 1
93654: PPUSH
93655: CALL 25063 0 3
93659: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
93660: LD_ADDR_VAR 0 6
93664: PUSH
93665: LD_EXP 31
93669: PUSH
93670: LD_VAR 0 3
93674: ARRAY
93675: PPUSH
93676: LD_INT 25
93678: PUSH
93679: LD_INT 1
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PUSH
93686: LD_INT 3
93688: PUSH
93689: LD_INT 54
93691: PUSH
93692: EMPTY
93693: LIST
93694: PUSH
93695: EMPTY
93696: LIST
93697: LIST
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PPUSH
93703: CALL_OW 72
93707: ST_TO_ADDR
// if tmp then
93708: LD_VAR 0 6
93712: IFFALSE 93718
// exit ;
93714: POP
93715: POP
93716: GO 93858
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
93718: LD_ADDR_VAR 0 6
93722: PUSH
93723: LD_EXP 31
93727: PUSH
93728: LD_VAR 0 3
93732: ARRAY
93733: PPUSH
93734: LD_INT 2
93736: PUSH
93737: LD_INT 30
93739: PUSH
93740: LD_INT 4
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 30
93749: PUSH
93750: LD_INT 5
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: LIST
93761: PPUSH
93762: CALL_OW 72
93766: ST_TO_ADDR
// if not tmp then
93767: LD_VAR 0 6
93771: NOT
93772: IFFALSE 93778
// exit ;
93774: POP
93775: POP
93776: GO 93858
// for j in tmp do
93778: LD_ADDR_VAR 0 4
93782: PUSH
93783: LD_VAR 0 6
93787: PUSH
93788: FOR_IN
93789: IFFALSE 93848
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
93791: LD_ADDR_VAR 0 7
93795: PUSH
93796: LD_VAR 0 4
93800: PPUSH
93801: CALL_OW 313
93805: PPUSH
93806: LD_INT 25
93808: PUSH
93809: LD_INT 1
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: PPUSH
93816: CALL_OW 72
93820: ST_TO_ADDR
// if units then
93821: LD_VAR 0 7
93825: IFFALSE 93846
// begin ComExitBuilding ( units [ 1 ] ) ;
93827: LD_VAR 0 7
93831: PUSH
93832: LD_INT 1
93834: ARRAY
93835: PPUSH
93836: CALL_OW 122
// exit ;
93840: POP
93841: POP
93842: POP
93843: POP
93844: GO 93858
// end ; end ;
93846: GO 93788
93848: POP
93849: POP
// end ; end ; exit ;
93850: POP
93851: POP
93852: GO 93858
// end ; end ;
93854: GO 93212
93856: POP
93857: POP
// end ;
93858: LD_VAR 0 2
93862: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
93863: LD_INT 0
93865: PPUSH
93866: PPUSH
93867: PPUSH
93868: PPUSH
93869: PPUSH
93870: PPUSH
93871: PPUSH
// if not mc_bases or not skirmish then
93872: LD_EXP 31
93876: NOT
93877: IFTRUE 93886
93879: PUSH
93880: LD_EXP 29
93884: NOT
93885: OR
93886: IFFALSE 93890
// exit ;
93888: GO 94155
// btype := GetBType ( building ) ;
93890: LD_ADDR_VAR 0 6
93894: PUSH
93895: LD_VAR 0 1
93899: PPUSH
93900: CALL_OW 266
93904: ST_TO_ADDR
// x := GetX ( building ) ;
93905: LD_ADDR_VAR 0 7
93909: PUSH
93910: LD_VAR 0 1
93914: PPUSH
93915: CALL_OW 250
93919: ST_TO_ADDR
// y := GetY ( building ) ;
93920: LD_ADDR_VAR 0 8
93924: PUSH
93925: LD_VAR 0 1
93929: PPUSH
93930: CALL_OW 251
93934: ST_TO_ADDR
// d := GetDir ( building ) ;
93935: LD_ADDR_VAR 0 9
93939: PUSH
93940: LD_VAR 0 1
93944: PPUSH
93945: CALL_OW 254
93949: ST_TO_ADDR
// for i = 1 to mc_bases do
93950: LD_ADDR_VAR 0 4
93954: PUSH
93955: DOUBLE
93956: LD_INT 1
93958: DEC
93959: ST_TO_ADDR
93960: LD_EXP 31
93964: PUSH
93965: FOR_TO
93966: IFFALSE 94153
// begin if not mc_build_list [ i ] then
93968: LD_EXP 36
93972: PUSH
93973: LD_VAR 0 4
93977: ARRAY
93978: NOT
93979: IFFALSE 93983
// continue ;
93981: GO 93965
// for j := 1 to mc_build_list [ i ] do
93983: LD_ADDR_VAR 0 5
93987: PUSH
93988: DOUBLE
93989: LD_INT 1
93991: DEC
93992: ST_TO_ADDR
93993: LD_EXP 36
93997: PUSH
93998: LD_VAR 0 4
94002: ARRAY
94003: PUSH
94004: FOR_TO
94005: IFFALSE 94149
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
94007: LD_VAR 0 6
94011: PUSH
94012: LD_VAR 0 7
94016: PUSH
94017: LD_VAR 0 8
94021: PUSH
94022: LD_VAR 0 9
94026: PUSH
94027: EMPTY
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: PPUSH
94033: LD_EXP 36
94037: PUSH
94038: LD_VAR 0 4
94042: ARRAY
94043: PUSH
94044: LD_VAR 0 5
94048: ARRAY
94049: PPUSH
94050: CALL 31670 0 2
94054: IFFALSE 94147
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
94056: LD_ADDR_EXP 36
94060: PUSH
94061: LD_EXP 36
94065: PPUSH
94066: LD_VAR 0 4
94070: PPUSH
94071: LD_EXP 36
94075: PUSH
94076: LD_VAR 0 4
94080: ARRAY
94081: PPUSH
94082: LD_VAR 0 5
94086: PPUSH
94087: CALL_OW 3
94091: PPUSH
94092: CALL_OW 1
94096: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
94097: LD_ADDR_EXP 38
94101: PUSH
94102: LD_EXP 38
94106: PPUSH
94107: LD_VAR 0 4
94111: PUSH
94112: LD_EXP 38
94116: PUSH
94117: LD_VAR 0 4
94121: ARRAY
94122: PUSH
94123: LD_INT 1
94125: PLUS
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PPUSH
94131: LD_VAR 0 1
94135: PPUSH
94136: CALL 25063 0 3
94140: ST_TO_ADDR
// exit ;
94141: POP
94142: POP
94143: POP
94144: POP
94145: GO 94155
// end ;
94147: GO 94004
94149: POP
94150: POP
// end ;
94151: GO 93965
94153: POP
94154: POP
// end ;
94155: LD_VAR 0 3
94159: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
94160: LD_INT 0
94162: PPUSH
94163: PPUSH
94164: PPUSH
// if not mc_bases or not skirmish then
94165: LD_EXP 31
94169: NOT
94170: IFTRUE 94179
94172: PUSH
94173: LD_EXP 29
94177: NOT
94178: OR
94179: IFFALSE 94183
// exit ;
94181: GO 94379
// for i = 1 to mc_bases do
94183: LD_ADDR_VAR 0 4
94187: PUSH
94188: DOUBLE
94189: LD_INT 1
94191: DEC
94192: ST_TO_ADDR
94193: LD_EXP 31
94197: PUSH
94198: FOR_TO
94199: IFFALSE 94288
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
94201: LD_VAR 0 1
94205: PUSH
94206: LD_EXP 39
94210: PUSH
94211: LD_VAR 0 4
94215: ARRAY
94216: IN
94217: IFFALSE 94238
94219: PUSH
94220: LD_VAR 0 1
94224: PUSH
94225: LD_EXP 40
94229: PUSH
94230: LD_VAR 0 4
94234: ARRAY
94235: IN
94236: NOT
94237: AND
94238: IFFALSE 94286
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
94240: LD_ADDR_EXP 40
94244: PUSH
94245: LD_EXP 40
94249: PPUSH
94250: LD_VAR 0 4
94254: PUSH
94255: LD_EXP 40
94259: PUSH
94260: LD_VAR 0 4
94264: ARRAY
94265: PUSH
94266: LD_INT 1
94268: PLUS
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PPUSH
94274: LD_VAR 0 1
94278: PPUSH
94279: CALL 25063 0 3
94283: ST_TO_ADDR
// break ;
94284: GO 94288
// end ; end ;
94286: GO 94198
94288: POP
94289: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
94290: LD_VAR 0 1
94294: PPUSH
94295: CALL_OW 257
94299: PUSH
94300: LD_EXP 57
94304: IN
94305: IFFALSE 94322
94307: PUSH
94308: LD_VAR 0 1
94312: PPUSH
94313: CALL_OW 266
94317: PUSH
94318: LD_INT 5
94320: EQUAL
94321: AND
94322: IFFALSE 94339
94324: PUSH
94325: LD_VAR 0 2
94329: PPUSH
94330: CALL_OW 110
94334: PUSH
94335: LD_INT 18
94337: NONEQUAL
94338: AND
94339: IFFALSE 94379
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
94341: LD_VAR 0 2
94345: PPUSH
94346: CALL_OW 257
94350: PUSH
94351: LD_INT 5
94353: PUSH
94354: LD_INT 8
94356: PUSH
94357: LD_INT 9
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: LIST
94364: IN
94365: IFFALSE 94379
// SetClass ( unit , 1 ) ;
94367: LD_VAR 0 2
94371: PPUSH
94372: LD_INT 1
94374: PPUSH
94375: CALL_OW 336
// end ;
94379: LD_VAR 0 3
94383: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
94384: LD_INT 0
94386: PPUSH
94387: PPUSH
// if not mc_bases or not skirmish then
94388: LD_EXP 31
94392: NOT
94393: IFTRUE 94402
94395: PUSH
94396: LD_EXP 29
94400: NOT
94401: OR
94402: IFFALSE 94406
// exit ;
94404: GO 94522
// if GetLives ( abandoned_vehicle ) > 250 then
94406: LD_VAR 0 2
94410: PPUSH
94411: CALL_OW 256
94415: PUSH
94416: LD_INT 250
94418: GREATER
94419: IFFALSE 94423
// exit ;
94421: GO 94522
// for i = 1 to mc_bases do
94423: LD_ADDR_VAR 0 6
94427: PUSH
94428: DOUBLE
94429: LD_INT 1
94431: DEC
94432: ST_TO_ADDR
94433: LD_EXP 31
94437: PUSH
94438: FOR_TO
94439: IFFALSE 94520
// begin if driver in mc_bases [ i ] then
94441: LD_VAR 0 1
94445: PUSH
94446: LD_EXP 31
94450: PUSH
94451: LD_VAR 0 6
94455: ARRAY
94456: IN
94457: IFFALSE 94518
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
94459: LD_VAR 0 1
94463: PPUSH
94464: LD_EXP 31
94468: PUSH
94469: LD_VAR 0 6
94473: ARRAY
94474: PPUSH
94475: LD_INT 2
94477: PUSH
94478: LD_INT 30
94480: PUSH
94481: LD_INT 0
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: PUSH
94488: LD_INT 30
94490: PUSH
94491: LD_INT 1
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: LIST
94502: PPUSH
94503: CALL_OW 72
94507: PUSH
94508: LD_INT 1
94510: ARRAY
94511: PPUSH
94512: CALL 58990 0 2
// break ;
94516: GO 94520
// end ; end ;
94518: GO 94438
94520: POP
94521: POP
// end ; end_of_file end_of_file
94522: LD_VAR 0 5
94526: RET
// export globalGameSaveCounter ; every 0 0$1 do
94527: GO 94529
94529: DISABLE
// begin enable ;
94530: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94531: LD_STRING updateTimer(
94533: PUSH
94534: LD_OWVAR 1
94538: STR
94539: PUSH
94540: LD_STRING );
94542: STR
94543: PPUSH
94544: CALL_OW 559
// end ;
94548: END
// every 0 0$1 do
94549: GO 94551
94551: DISABLE
// begin globalGameSaveCounter := 0 ;
94552: LD_ADDR_EXP 76
94556: PUSH
94557: LD_INT 0
94559: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
94560: LD_STRING setGameSaveCounter(0)
94562: PPUSH
94563: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
94567: LD_STRING initStreamRollete();
94569: PPUSH
94570: CALL_OW 559
// InitStreamMode ;
94574: CALL 95919 0 0
// DefineStreamItems ( false ) ;
94578: LD_INT 0
94580: PPUSH
94581: CALL 96383 0 1
// end ;
94585: END
// export function SOS_MapStart ( ) ; begin
94586: LD_INT 0
94588: PPUSH
// if streamModeActive then
94589: LD_EXP 77
94593: IFFALSE 94602
// DefineStreamItems ( true ) ;
94595: LD_INT 1
94597: PPUSH
94598: CALL 96383 0 1
// UpdateLuaVariables ( ) ;
94602: CALL 94619 0 0
// UpdateFactoryWaypoints ( ) ;
94606: CALL 109505 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94610: CALL 109757 0 0
// end ;
94614: LD_VAR 0 1
94618: RET
// function UpdateLuaVariables ( ) ; begin
94619: LD_INT 0
94621: PPUSH
// if globalGameSaveCounter then
94622: LD_EXP 76
94626: IFFALSE 94660
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
94628: LD_ADDR_EXP 76
94632: PUSH
94633: LD_EXP 76
94637: PPUSH
94638: CALL 59484 0 1
94642: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94643: LD_STRING setGameSaveCounter(
94645: PUSH
94646: LD_EXP 76
94650: STR
94651: PUSH
94652: LD_STRING )
94654: STR
94655: PPUSH
94656: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
94660: LD_STRING setGameDifficulty(
94662: PUSH
94663: LD_OWVAR 67
94667: STR
94668: PUSH
94669: LD_STRING )
94671: STR
94672: PPUSH
94673: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
94677: LD_STRING displayDifficulty(
94679: PUSH
94680: LD_OWVAR 67
94684: STR
94685: PUSH
94686: LD_STRING )
94688: STR
94689: PPUSH
94690: CALL_OW 559
// end ;
94694: LD_VAR 0 1
94698: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94699: LD_INT 0
94701: PPUSH
// if p2 = stream_mode then
94702: LD_VAR 0 2
94706: PUSH
94707: LD_INT 100
94709: EQUAL
94710: IFFALSE 95713
// begin if not StreamModeActive then
94712: LD_EXP 77
94716: NOT
94717: IFFALSE 94727
// StreamModeActive := true ;
94719: LD_ADDR_EXP 77
94723: PUSH
94724: LD_INT 1
94726: ST_TO_ADDR
// if p3 = 0 then
94727: LD_VAR 0 3
94731: PUSH
94732: LD_INT 0
94734: EQUAL
94735: IFFALSE 94741
// InitStreamMode ;
94737: CALL 95919 0 0
// if p3 = 1 then
94741: LD_VAR 0 3
94745: PUSH
94746: LD_INT 1
94748: EQUAL
94749: IFFALSE 94759
// sRocket := true ;
94751: LD_ADDR_EXP 82
94755: PUSH
94756: LD_INT 1
94758: ST_TO_ADDR
// if p3 = 2 then
94759: LD_VAR 0 3
94763: PUSH
94764: LD_INT 2
94766: EQUAL
94767: IFFALSE 94777
// sSpeed := true ;
94769: LD_ADDR_EXP 81
94773: PUSH
94774: LD_INT 1
94776: ST_TO_ADDR
// if p3 = 3 then
94777: LD_VAR 0 3
94781: PUSH
94782: LD_INT 3
94784: EQUAL
94785: IFFALSE 94795
// sEngine := true ;
94787: LD_ADDR_EXP 83
94791: PUSH
94792: LD_INT 1
94794: ST_TO_ADDR
// if p3 = 4 then
94795: LD_VAR 0 3
94799: PUSH
94800: LD_INT 4
94802: EQUAL
94803: IFFALSE 94813
// sSpec := true ;
94805: LD_ADDR_EXP 80
94809: PUSH
94810: LD_INT 1
94812: ST_TO_ADDR
// if p3 = 5 then
94813: LD_VAR 0 3
94817: PUSH
94818: LD_INT 5
94820: EQUAL
94821: IFFALSE 94831
// sLevel := true ;
94823: LD_ADDR_EXP 84
94827: PUSH
94828: LD_INT 1
94830: ST_TO_ADDR
// if p3 = 6 then
94831: LD_VAR 0 3
94835: PUSH
94836: LD_INT 6
94838: EQUAL
94839: IFFALSE 94849
// sArmoury := true ;
94841: LD_ADDR_EXP 85
94845: PUSH
94846: LD_INT 1
94848: ST_TO_ADDR
// if p3 = 7 then
94849: LD_VAR 0 3
94853: PUSH
94854: LD_INT 7
94856: EQUAL
94857: IFFALSE 94867
// sRadar := true ;
94859: LD_ADDR_EXP 86
94863: PUSH
94864: LD_INT 1
94866: ST_TO_ADDR
// if p3 = 8 then
94867: LD_VAR 0 3
94871: PUSH
94872: LD_INT 8
94874: EQUAL
94875: IFFALSE 94885
// sBunker := true ;
94877: LD_ADDR_EXP 87
94881: PUSH
94882: LD_INT 1
94884: ST_TO_ADDR
// if p3 = 9 then
94885: LD_VAR 0 3
94889: PUSH
94890: LD_INT 9
94892: EQUAL
94893: IFFALSE 94903
// sHack := true ;
94895: LD_ADDR_EXP 88
94899: PUSH
94900: LD_INT 1
94902: ST_TO_ADDR
// if p3 = 10 then
94903: LD_VAR 0 3
94907: PUSH
94908: LD_INT 10
94910: EQUAL
94911: IFFALSE 94921
// sFire := true ;
94913: LD_ADDR_EXP 89
94917: PUSH
94918: LD_INT 1
94920: ST_TO_ADDR
// if p3 = 11 then
94921: LD_VAR 0 3
94925: PUSH
94926: LD_INT 11
94928: EQUAL
94929: IFFALSE 94939
// sRefresh := true ;
94931: LD_ADDR_EXP 90
94935: PUSH
94936: LD_INT 1
94938: ST_TO_ADDR
// if p3 = 12 then
94939: LD_VAR 0 3
94943: PUSH
94944: LD_INT 12
94946: EQUAL
94947: IFFALSE 94957
// sExp := true ;
94949: LD_ADDR_EXP 91
94953: PUSH
94954: LD_INT 1
94956: ST_TO_ADDR
// if p3 = 13 then
94957: LD_VAR 0 3
94961: PUSH
94962: LD_INT 13
94964: EQUAL
94965: IFFALSE 94975
// sDepot := true ;
94967: LD_ADDR_EXP 92
94971: PUSH
94972: LD_INT 1
94974: ST_TO_ADDR
// if p3 = 14 then
94975: LD_VAR 0 3
94979: PUSH
94980: LD_INT 14
94982: EQUAL
94983: IFFALSE 94993
// sFlag := true ;
94985: LD_ADDR_EXP 93
94989: PUSH
94990: LD_INT 1
94992: ST_TO_ADDR
// if p3 = 15 then
94993: LD_VAR 0 3
94997: PUSH
94998: LD_INT 15
95000: EQUAL
95001: IFFALSE 95011
// sKamikadze := true ;
95003: LD_ADDR_EXP 101
95007: PUSH
95008: LD_INT 1
95010: ST_TO_ADDR
// if p3 = 16 then
95011: LD_VAR 0 3
95015: PUSH
95016: LD_INT 16
95018: EQUAL
95019: IFFALSE 95029
// sTroll := true ;
95021: LD_ADDR_EXP 102
95025: PUSH
95026: LD_INT 1
95028: ST_TO_ADDR
// if p3 = 17 then
95029: LD_VAR 0 3
95033: PUSH
95034: LD_INT 17
95036: EQUAL
95037: IFFALSE 95047
// sSlow := true ;
95039: LD_ADDR_EXP 103
95043: PUSH
95044: LD_INT 1
95046: ST_TO_ADDR
// if p3 = 18 then
95047: LD_VAR 0 3
95051: PUSH
95052: LD_INT 18
95054: EQUAL
95055: IFFALSE 95065
// sLack := true ;
95057: LD_ADDR_EXP 104
95061: PUSH
95062: LD_INT 1
95064: ST_TO_ADDR
// if p3 = 19 then
95065: LD_VAR 0 3
95069: PUSH
95070: LD_INT 19
95072: EQUAL
95073: IFFALSE 95083
// sTank := true ;
95075: LD_ADDR_EXP 106
95079: PUSH
95080: LD_INT 1
95082: ST_TO_ADDR
// if p3 = 20 then
95083: LD_VAR 0 3
95087: PUSH
95088: LD_INT 20
95090: EQUAL
95091: IFFALSE 95101
// sRemote := true ;
95093: LD_ADDR_EXP 107
95097: PUSH
95098: LD_INT 1
95100: ST_TO_ADDR
// if p3 = 21 then
95101: LD_VAR 0 3
95105: PUSH
95106: LD_INT 21
95108: EQUAL
95109: IFFALSE 95119
// sPowell := true ;
95111: LD_ADDR_EXP 108
95115: PUSH
95116: LD_INT 1
95118: ST_TO_ADDR
// if p3 = 22 then
95119: LD_VAR 0 3
95123: PUSH
95124: LD_INT 22
95126: EQUAL
95127: IFFALSE 95137
// sTeleport := true ;
95129: LD_ADDR_EXP 111
95133: PUSH
95134: LD_INT 1
95136: ST_TO_ADDR
// if p3 = 23 then
95137: LD_VAR 0 3
95141: PUSH
95142: LD_INT 23
95144: EQUAL
95145: IFFALSE 95155
// sOilTower := true ;
95147: LD_ADDR_EXP 113
95151: PUSH
95152: LD_INT 1
95154: ST_TO_ADDR
// if p3 = 24 then
95155: LD_VAR 0 3
95159: PUSH
95160: LD_INT 24
95162: EQUAL
95163: IFFALSE 95173
// sShovel := true ;
95165: LD_ADDR_EXP 114
95169: PUSH
95170: LD_INT 1
95172: ST_TO_ADDR
// if p3 = 25 then
95173: LD_VAR 0 3
95177: PUSH
95178: LD_INT 25
95180: EQUAL
95181: IFFALSE 95191
// sSheik := true ;
95183: LD_ADDR_EXP 115
95187: PUSH
95188: LD_INT 1
95190: ST_TO_ADDR
// if p3 = 26 then
95191: LD_VAR 0 3
95195: PUSH
95196: LD_INT 26
95198: EQUAL
95199: IFFALSE 95209
// sEarthquake := true ;
95201: LD_ADDR_EXP 117
95205: PUSH
95206: LD_INT 1
95208: ST_TO_ADDR
// if p3 = 27 then
95209: LD_VAR 0 3
95213: PUSH
95214: LD_INT 27
95216: EQUAL
95217: IFFALSE 95227
// sAI := true ;
95219: LD_ADDR_EXP 118
95223: PUSH
95224: LD_INT 1
95226: ST_TO_ADDR
// if p3 = 28 then
95227: LD_VAR 0 3
95231: PUSH
95232: LD_INT 28
95234: EQUAL
95235: IFFALSE 95245
// sCargo := true ;
95237: LD_ADDR_EXP 121
95241: PUSH
95242: LD_INT 1
95244: ST_TO_ADDR
// if p3 = 29 then
95245: LD_VAR 0 3
95249: PUSH
95250: LD_INT 29
95252: EQUAL
95253: IFFALSE 95263
// sDLaser := true ;
95255: LD_ADDR_EXP 122
95259: PUSH
95260: LD_INT 1
95262: ST_TO_ADDR
// if p3 = 30 then
95263: LD_VAR 0 3
95267: PUSH
95268: LD_INT 30
95270: EQUAL
95271: IFFALSE 95281
// sExchange := true ;
95273: LD_ADDR_EXP 123
95277: PUSH
95278: LD_INT 1
95280: ST_TO_ADDR
// if p3 = 31 then
95281: LD_VAR 0 3
95285: PUSH
95286: LD_INT 31
95288: EQUAL
95289: IFFALSE 95299
// sFac := true ;
95291: LD_ADDR_EXP 124
95295: PUSH
95296: LD_INT 1
95298: ST_TO_ADDR
// if p3 = 32 then
95299: LD_VAR 0 3
95303: PUSH
95304: LD_INT 32
95306: EQUAL
95307: IFFALSE 95317
// sPower := true ;
95309: LD_ADDR_EXP 125
95313: PUSH
95314: LD_INT 1
95316: ST_TO_ADDR
// if p3 = 33 then
95317: LD_VAR 0 3
95321: PUSH
95322: LD_INT 33
95324: EQUAL
95325: IFFALSE 95335
// sRandom := true ;
95327: LD_ADDR_EXP 126
95331: PUSH
95332: LD_INT 1
95334: ST_TO_ADDR
// if p3 = 34 then
95335: LD_VAR 0 3
95339: PUSH
95340: LD_INT 34
95342: EQUAL
95343: IFFALSE 95353
// sShield := true ;
95345: LD_ADDR_EXP 127
95349: PUSH
95350: LD_INT 1
95352: ST_TO_ADDR
// if p3 = 35 then
95353: LD_VAR 0 3
95357: PUSH
95358: LD_INT 35
95360: EQUAL
95361: IFFALSE 95371
// sTime := true ;
95363: LD_ADDR_EXP 128
95367: PUSH
95368: LD_INT 1
95370: ST_TO_ADDR
// if p3 = 36 then
95371: LD_VAR 0 3
95375: PUSH
95376: LD_INT 36
95378: EQUAL
95379: IFFALSE 95389
// sTools := true ;
95381: LD_ADDR_EXP 129
95385: PUSH
95386: LD_INT 1
95388: ST_TO_ADDR
// if p3 = 101 then
95389: LD_VAR 0 3
95393: PUSH
95394: LD_INT 101
95396: EQUAL
95397: IFFALSE 95407
// sSold := true ;
95399: LD_ADDR_EXP 94
95403: PUSH
95404: LD_INT 1
95406: ST_TO_ADDR
// if p3 = 102 then
95407: LD_VAR 0 3
95411: PUSH
95412: LD_INT 102
95414: EQUAL
95415: IFFALSE 95425
// sDiff := true ;
95417: LD_ADDR_EXP 95
95421: PUSH
95422: LD_INT 1
95424: ST_TO_ADDR
// if p3 = 103 then
95425: LD_VAR 0 3
95429: PUSH
95430: LD_INT 103
95432: EQUAL
95433: IFFALSE 95443
// sFog := true ;
95435: LD_ADDR_EXP 98
95439: PUSH
95440: LD_INT 1
95442: ST_TO_ADDR
// if p3 = 104 then
95443: LD_VAR 0 3
95447: PUSH
95448: LD_INT 104
95450: EQUAL
95451: IFFALSE 95461
// sReset := true ;
95453: LD_ADDR_EXP 99
95457: PUSH
95458: LD_INT 1
95460: ST_TO_ADDR
// if p3 = 105 then
95461: LD_VAR 0 3
95465: PUSH
95466: LD_INT 105
95468: EQUAL
95469: IFFALSE 95479
// sSun := true ;
95471: LD_ADDR_EXP 100
95475: PUSH
95476: LD_INT 1
95478: ST_TO_ADDR
// if p3 = 106 then
95479: LD_VAR 0 3
95483: PUSH
95484: LD_INT 106
95486: EQUAL
95487: IFFALSE 95497
// sTiger := true ;
95489: LD_ADDR_EXP 96
95493: PUSH
95494: LD_INT 1
95496: ST_TO_ADDR
// if p3 = 107 then
95497: LD_VAR 0 3
95501: PUSH
95502: LD_INT 107
95504: EQUAL
95505: IFFALSE 95515
// sBomb := true ;
95507: LD_ADDR_EXP 97
95511: PUSH
95512: LD_INT 1
95514: ST_TO_ADDR
// if p3 = 108 then
95515: LD_VAR 0 3
95519: PUSH
95520: LD_INT 108
95522: EQUAL
95523: IFFALSE 95533
// sWound := true ;
95525: LD_ADDR_EXP 105
95529: PUSH
95530: LD_INT 1
95532: ST_TO_ADDR
// if p3 = 109 then
95533: LD_VAR 0 3
95537: PUSH
95538: LD_INT 109
95540: EQUAL
95541: IFFALSE 95551
// sBetray := true ;
95543: LD_ADDR_EXP 109
95547: PUSH
95548: LD_INT 1
95550: ST_TO_ADDR
// if p3 = 110 then
95551: LD_VAR 0 3
95555: PUSH
95556: LD_INT 110
95558: EQUAL
95559: IFFALSE 95569
// sContamin := true ;
95561: LD_ADDR_EXP 110
95565: PUSH
95566: LD_INT 1
95568: ST_TO_ADDR
// if p3 = 111 then
95569: LD_VAR 0 3
95573: PUSH
95574: LD_INT 111
95576: EQUAL
95577: IFFALSE 95587
// sOil := true ;
95579: LD_ADDR_EXP 112
95583: PUSH
95584: LD_INT 1
95586: ST_TO_ADDR
// if p3 = 112 then
95587: LD_VAR 0 3
95591: PUSH
95592: LD_INT 112
95594: EQUAL
95595: IFFALSE 95605
// sStu := true ;
95597: LD_ADDR_EXP 116
95601: PUSH
95602: LD_INT 1
95604: ST_TO_ADDR
// if p3 = 113 then
95605: LD_VAR 0 3
95609: PUSH
95610: LD_INT 113
95612: EQUAL
95613: IFFALSE 95623
// sBazooka := true ;
95615: LD_ADDR_EXP 119
95619: PUSH
95620: LD_INT 1
95622: ST_TO_ADDR
// if p3 = 114 then
95623: LD_VAR 0 3
95627: PUSH
95628: LD_INT 114
95630: EQUAL
95631: IFFALSE 95641
// sMortar := true ;
95633: LD_ADDR_EXP 120
95637: PUSH
95638: LD_INT 1
95640: ST_TO_ADDR
// if p3 = 115 then
95641: LD_VAR 0 3
95645: PUSH
95646: LD_INT 115
95648: EQUAL
95649: IFFALSE 95659
// sRanger := true ;
95651: LD_ADDR_EXP 130
95655: PUSH
95656: LD_INT 1
95658: ST_TO_ADDR
// if p3 = 116 then
95659: LD_VAR 0 3
95663: PUSH
95664: LD_INT 116
95666: EQUAL
95667: IFFALSE 95677
// sComputer := true ;
95669: LD_ADDR_EXP 131
95673: PUSH
95674: LD_INT 1
95676: ST_TO_ADDR
// if p3 = 117 then
95677: LD_VAR 0 3
95681: PUSH
95682: LD_INT 117
95684: EQUAL
95685: IFFALSE 95695
// s30 := true ;
95687: LD_ADDR_EXP 132
95691: PUSH
95692: LD_INT 1
95694: ST_TO_ADDR
// if p3 = 118 then
95695: LD_VAR 0 3
95699: PUSH
95700: LD_INT 118
95702: EQUAL
95703: IFFALSE 95713
// s60 := true ;
95705: LD_ADDR_EXP 133
95709: PUSH
95710: LD_INT 1
95712: ST_TO_ADDR
// end ; if p2 = hack_mode then
95713: LD_VAR 0 2
95717: PUSH
95718: LD_INT 101
95720: EQUAL
95721: IFFALSE 95849
// begin case p3 of 1 :
95723: LD_VAR 0 3
95727: PUSH
95728: LD_INT 1
95730: DOUBLE
95731: EQUAL
95732: IFTRUE 95736
95734: GO 95743
95736: POP
// hHackUnlimitedResources ; 2 :
95737: CALL 108112 0 0
95741: GO 95849
95743: LD_INT 2
95745: DOUBLE
95746: EQUAL
95747: IFTRUE 95751
95749: GO 95758
95751: POP
// hHackSetLevel10 ; 3 :
95752: CALL 108245 0 0
95756: GO 95849
95758: LD_INT 3
95760: DOUBLE
95761: EQUAL
95762: IFTRUE 95766
95764: GO 95773
95766: POP
// hHackSetLevel10YourUnits ; 4 :
95767: CALL 108330 0 0
95771: GO 95849
95773: LD_INT 4
95775: DOUBLE
95776: EQUAL
95777: IFTRUE 95781
95779: GO 95788
95781: POP
// hHackInvincible ; 5 :
95782: CALL 108778 0 0
95786: GO 95849
95788: LD_INT 5
95790: DOUBLE
95791: EQUAL
95792: IFTRUE 95796
95794: GO 95803
95796: POP
// hHackInvisible ; 6 :
95797: CALL 108889 0 0
95801: GO 95849
95803: LD_INT 6
95805: DOUBLE
95806: EQUAL
95807: IFTRUE 95811
95809: GO 95818
95811: POP
// hHackChangeYourSide ; 7 :
95812: CALL 108946 0 0
95816: GO 95849
95818: LD_INT 7
95820: DOUBLE
95821: EQUAL
95822: IFTRUE 95826
95824: GO 95833
95826: POP
// hHackChangeUnitSide ; 8 :
95827: CALL 108988 0 0
95831: GO 95849
95833: LD_INT 8
95835: DOUBLE
95836: EQUAL
95837: IFTRUE 95841
95839: GO 95848
95841: POP
// hHackFog ; end ;
95842: CALL 109089 0 0
95846: GO 95849
95848: POP
// end ; if p2 = game_save_mode then
95849: LD_VAR 0 2
95853: PUSH
95854: LD_INT 102
95856: EQUAL
95857: IFFALSE 95914
// begin if p3 = 1 then
95859: LD_VAR 0 3
95863: PUSH
95864: LD_INT 1
95866: EQUAL
95867: IFFALSE 95879
// globalGameSaveCounter := p4 ;
95869: LD_ADDR_EXP 76
95873: PUSH
95874: LD_VAR 0 4
95878: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95879: LD_VAR 0 3
95883: PUSH
95884: LD_INT 2
95886: EQUAL
95887: IFFALSE 95895
95889: PUSH
95890: LD_EXP 76
95894: AND
95895: IFFALSE 95914
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95897: LD_STRING setGameSaveCounter(
95899: PUSH
95900: LD_EXP 76
95904: STR
95905: PUSH
95906: LD_STRING )
95908: STR
95909: PPUSH
95910: CALL_OW 559
// end ; end ;
95914: LD_VAR 0 7
95918: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
95919: LD_INT 0
95921: PPUSH
// streamModeActive := false ;
95922: LD_ADDR_EXP 77
95926: PUSH
95927: LD_INT 0
95929: ST_TO_ADDR
// normalCounter := 36 ;
95930: LD_ADDR_EXP 78
95934: PUSH
95935: LD_INT 36
95937: ST_TO_ADDR
// hardcoreCounter := 18 ;
95938: LD_ADDR_EXP 79
95942: PUSH
95943: LD_INT 18
95945: ST_TO_ADDR
// sRocket := false ;
95946: LD_ADDR_EXP 82
95950: PUSH
95951: LD_INT 0
95953: ST_TO_ADDR
// sSpeed := false ;
95954: LD_ADDR_EXP 81
95958: PUSH
95959: LD_INT 0
95961: ST_TO_ADDR
// sEngine := false ;
95962: LD_ADDR_EXP 83
95966: PUSH
95967: LD_INT 0
95969: ST_TO_ADDR
// sSpec := false ;
95970: LD_ADDR_EXP 80
95974: PUSH
95975: LD_INT 0
95977: ST_TO_ADDR
// sLevel := false ;
95978: LD_ADDR_EXP 84
95982: PUSH
95983: LD_INT 0
95985: ST_TO_ADDR
// sArmoury := false ;
95986: LD_ADDR_EXP 85
95990: PUSH
95991: LD_INT 0
95993: ST_TO_ADDR
// sRadar := false ;
95994: LD_ADDR_EXP 86
95998: PUSH
95999: LD_INT 0
96001: ST_TO_ADDR
// sBunker := false ;
96002: LD_ADDR_EXP 87
96006: PUSH
96007: LD_INT 0
96009: ST_TO_ADDR
// sHack := false ;
96010: LD_ADDR_EXP 88
96014: PUSH
96015: LD_INT 0
96017: ST_TO_ADDR
// sFire := false ;
96018: LD_ADDR_EXP 89
96022: PUSH
96023: LD_INT 0
96025: ST_TO_ADDR
// sRefresh := false ;
96026: LD_ADDR_EXP 90
96030: PUSH
96031: LD_INT 0
96033: ST_TO_ADDR
// sExp := false ;
96034: LD_ADDR_EXP 91
96038: PUSH
96039: LD_INT 0
96041: ST_TO_ADDR
// sDepot := false ;
96042: LD_ADDR_EXP 92
96046: PUSH
96047: LD_INT 0
96049: ST_TO_ADDR
// sFlag := false ;
96050: LD_ADDR_EXP 93
96054: PUSH
96055: LD_INT 0
96057: ST_TO_ADDR
// sKamikadze := false ;
96058: LD_ADDR_EXP 101
96062: PUSH
96063: LD_INT 0
96065: ST_TO_ADDR
// sTroll := false ;
96066: LD_ADDR_EXP 102
96070: PUSH
96071: LD_INT 0
96073: ST_TO_ADDR
// sSlow := false ;
96074: LD_ADDR_EXP 103
96078: PUSH
96079: LD_INT 0
96081: ST_TO_ADDR
// sLack := false ;
96082: LD_ADDR_EXP 104
96086: PUSH
96087: LD_INT 0
96089: ST_TO_ADDR
// sTank := false ;
96090: LD_ADDR_EXP 106
96094: PUSH
96095: LD_INT 0
96097: ST_TO_ADDR
// sRemote := false ;
96098: LD_ADDR_EXP 107
96102: PUSH
96103: LD_INT 0
96105: ST_TO_ADDR
// sPowell := false ;
96106: LD_ADDR_EXP 108
96110: PUSH
96111: LD_INT 0
96113: ST_TO_ADDR
// sTeleport := false ;
96114: LD_ADDR_EXP 111
96118: PUSH
96119: LD_INT 0
96121: ST_TO_ADDR
// sOilTower := false ;
96122: LD_ADDR_EXP 113
96126: PUSH
96127: LD_INT 0
96129: ST_TO_ADDR
// sShovel := false ;
96130: LD_ADDR_EXP 114
96134: PUSH
96135: LD_INT 0
96137: ST_TO_ADDR
// sSheik := false ;
96138: LD_ADDR_EXP 115
96142: PUSH
96143: LD_INT 0
96145: ST_TO_ADDR
// sEarthquake := false ;
96146: LD_ADDR_EXP 117
96150: PUSH
96151: LD_INT 0
96153: ST_TO_ADDR
// sAI := false ;
96154: LD_ADDR_EXP 118
96158: PUSH
96159: LD_INT 0
96161: ST_TO_ADDR
// sCargo := false ;
96162: LD_ADDR_EXP 121
96166: PUSH
96167: LD_INT 0
96169: ST_TO_ADDR
// sDLaser := false ;
96170: LD_ADDR_EXP 122
96174: PUSH
96175: LD_INT 0
96177: ST_TO_ADDR
// sExchange := false ;
96178: LD_ADDR_EXP 123
96182: PUSH
96183: LD_INT 0
96185: ST_TO_ADDR
// sFac := false ;
96186: LD_ADDR_EXP 124
96190: PUSH
96191: LD_INT 0
96193: ST_TO_ADDR
// sPower := false ;
96194: LD_ADDR_EXP 125
96198: PUSH
96199: LD_INT 0
96201: ST_TO_ADDR
// sRandom := false ;
96202: LD_ADDR_EXP 126
96206: PUSH
96207: LD_INT 0
96209: ST_TO_ADDR
// sShield := false ;
96210: LD_ADDR_EXP 127
96214: PUSH
96215: LD_INT 0
96217: ST_TO_ADDR
// sTime := false ;
96218: LD_ADDR_EXP 128
96222: PUSH
96223: LD_INT 0
96225: ST_TO_ADDR
// sTools := false ;
96226: LD_ADDR_EXP 129
96230: PUSH
96231: LD_INT 0
96233: ST_TO_ADDR
// sSold := false ;
96234: LD_ADDR_EXP 94
96238: PUSH
96239: LD_INT 0
96241: ST_TO_ADDR
// sDiff := false ;
96242: LD_ADDR_EXP 95
96246: PUSH
96247: LD_INT 0
96249: ST_TO_ADDR
// sFog := false ;
96250: LD_ADDR_EXP 98
96254: PUSH
96255: LD_INT 0
96257: ST_TO_ADDR
// sReset := false ;
96258: LD_ADDR_EXP 99
96262: PUSH
96263: LD_INT 0
96265: ST_TO_ADDR
// sSun := false ;
96266: LD_ADDR_EXP 100
96270: PUSH
96271: LD_INT 0
96273: ST_TO_ADDR
// sTiger := false ;
96274: LD_ADDR_EXP 96
96278: PUSH
96279: LD_INT 0
96281: ST_TO_ADDR
// sBomb := false ;
96282: LD_ADDR_EXP 97
96286: PUSH
96287: LD_INT 0
96289: ST_TO_ADDR
// sWound := false ;
96290: LD_ADDR_EXP 105
96294: PUSH
96295: LD_INT 0
96297: ST_TO_ADDR
// sBetray := false ;
96298: LD_ADDR_EXP 109
96302: PUSH
96303: LD_INT 0
96305: ST_TO_ADDR
// sContamin := false ;
96306: LD_ADDR_EXP 110
96310: PUSH
96311: LD_INT 0
96313: ST_TO_ADDR
// sOil := false ;
96314: LD_ADDR_EXP 112
96318: PUSH
96319: LD_INT 0
96321: ST_TO_ADDR
// sStu := false ;
96322: LD_ADDR_EXP 116
96326: PUSH
96327: LD_INT 0
96329: ST_TO_ADDR
// sBazooka := false ;
96330: LD_ADDR_EXP 119
96334: PUSH
96335: LD_INT 0
96337: ST_TO_ADDR
// sMortar := false ;
96338: LD_ADDR_EXP 120
96342: PUSH
96343: LD_INT 0
96345: ST_TO_ADDR
// sRanger := false ;
96346: LD_ADDR_EXP 130
96350: PUSH
96351: LD_INT 0
96353: ST_TO_ADDR
// sComputer := false ;
96354: LD_ADDR_EXP 131
96358: PUSH
96359: LD_INT 0
96361: ST_TO_ADDR
// s30 := false ;
96362: LD_ADDR_EXP 132
96366: PUSH
96367: LD_INT 0
96369: ST_TO_ADDR
// s60 := false ;
96370: LD_ADDR_EXP 133
96374: PUSH
96375: LD_INT 0
96377: ST_TO_ADDR
// end ;
96378: LD_VAR 0 1
96382: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96383: LD_INT 0
96385: PPUSH
96386: PPUSH
96387: PPUSH
96388: PPUSH
96389: PPUSH
96390: PPUSH
96391: PPUSH
// result := [ ] ;
96392: LD_ADDR_VAR 0 2
96396: PUSH
96397: EMPTY
96398: ST_TO_ADDR
// if campaign_id = 1 then
96399: LD_OWVAR 69
96403: PUSH
96404: LD_INT 1
96406: EQUAL
96407: IFFALSE 99573
// begin case mission_number of 1 :
96409: LD_OWVAR 70
96413: PUSH
96414: LD_INT 1
96416: DOUBLE
96417: EQUAL
96418: IFTRUE 96422
96420: GO 96498
96422: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96423: LD_ADDR_VAR 0 2
96427: PUSH
96428: LD_INT 2
96430: PUSH
96431: LD_INT 4
96433: PUSH
96434: LD_INT 11
96436: PUSH
96437: LD_INT 12
96439: PUSH
96440: LD_INT 15
96442: PUSH
96443: LD_INT 16
96445: PUSH
96446: LD_INT 22
96448: PUSH
96449: LD_INT 23
96451: PUSH
96452: LD_INT 26
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: PUSH
96466: LD_INT 101
96468: PUSH
96469: LD_INT 102
96471: PUSH
96472: LD_INT 106
96474: PUSH
96475: LD_INT 116
96477: PUSH
96478: LD_INT 117
96480: PUSH
96481: LD_INT 118
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: PUSH
96492: EMPTY
96493: LIST
96494: LIST
96495: ST_TO_ADDR
96496: GO 99571
96498: LD_INT 2
96500: DOUBLE
96501: EQUAL
96502: IFTRUE 96506
96504: GO 96590
96506: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96507: LD_ADDR_VAR 0 2
96511: PUSH
96512: LD_INT 2
96514: PUSH
96515: LD_INT 4
96517: PUSH
96518: LD_INT 11
96520: PUSH
96521: LD_INT 12
96523: PUSH
96524: LD_INT 15
96526: PUSH
96527: LD_INT 16
96529: PUSH
96530: LD_INT 22
96532: PUSH
96533: LD_INT 23
96535: PUSH
96536: LD_INT 26
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 101
96552: PUSH
96553: LD_INT 102
96555: PUSH
96556: LD_INT 105
96558: PUSH
96559: LD_INT 106
96561: PUSH
96562: LD_INT 108
96564: PUSH
96565: LD_INT 116
96567: PUSH
96568: LD_INT 117
96570: PUSH
96571: LD_INT 118
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: ST_TO_ADDR
96588: GO 99571
96590: LD_INT 3
96592: DOUBLE
96593: EQUAL
96594: IFTRUE 96598
96596: GO 96686
96598: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96599: LD_ADDR_VAR 0 2
96603: PUSH
96604: LD_INT 2
96606: PUSH
96607: LD_INT 4
96609: PUSH
96610: LD_INT 5
96612: PUSH
96613: LD_INT 11
96615: PUSH
96616: LD_INT 12
96618: PUSH
96619: LD_INT 15
96621: PUSH
96622: LD_INT 16
96624: PUSH
96625: LD_INT 22
96627: PUSH
96628: LD_INT 26
96630: PUSH
96631: LD_INT 36
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: LIST
96645: PUSH
96646: LD_INT 101
96648: PUSH
96649: LD_INT 102
96651: PUSH
96652: LD_INT 105
96654: PUSH
96655: LD_INT 106
96657: PUSH
96658: LD_INT 108
96660: PUSH
96661: LD_INT 116
96663: PUSH
96664: LD_INT 117
96666: PUSH
96667: LD_INT 118
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: ST_TO_ADDR
96684: GO 99571
96686: LD_INT 4
96688: DOUBLE
96689: EQUAL
96690: IFTRUE 96694
96692: GO 96790
96694: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96695: LD_ADDR_VAR 0 2
96699: PUSH
96700: LD_INT 2
96702: PUSH
96703: LD_INT 4
96705: PUSH
96706: LD_INT 5
96708: PUSH
96709: LD_INT 8
96711: PUSH
96712: LD_INT 11
96714: PUSH
96715: LD_INT 12
96717: PUSH
96718: LD_INT 15
96720: PUSH
96721: LD_INT 16
96723: PUSH
96724: LD_INT 22
96726: PUSH
96727: LD_INT 23
96729: PUSH
96730: LD_INT 26
96732: PUSH
96733: LD_INT 36
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: PUSH
96750: LD_INT 101
96752: PUSH
96753: LD_INT 102
96755: PUSH
96756: LD_INT 105
96758: PUSH
96759: LD_INT 106
96761: PUSH
96762: LD_INT 108
96764: PUSH
96765: LD_INT 116
96767: PUSH
96768: LD_INT 117
96770: PUSH
96771: LD_INT 118
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: LIST
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: ST_TO_ADDR
96788: GO 99571
96790: LD_INT 5
96792: DOUBLE
96793: EQUAL
96794: IFTRUE 96798
96796: GO 96910
96798: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96799: LD_ADDR_VAR 0 2
96803: PUSH
96804: LD_INT 2
96806: PUSH
96807: LD_INT 4
96809: PUSH
96810: LD_INT 5
96812: PUSH
96813: LD_INT 6
96815: PUSH
96816: LD_INT 8
96818: PUSH
96819: LD_INT 11
96821: PUSH
96822: LD_INT 12
96824: PUSH
96825: LD_INT 15
96827: PUSH
96828: LD_INT 16
96830: PUSH
96831: LD_INT 22
96833: PUSH
96834: LD_INT 23
96836: PUSH
96837: LD_INT 25
96839: PUSH
96840: LD_INT 26
96842: PUSH
96843: LD_INT 36
96845: PUSH
96846: EMPTY
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: PUSH
96862: LD_INT 101
96864: PUSH
96865: LD_INT 102
96867: PUSH
96868: LD_INT 105
96870: PUSH
96871: LD_INT 106
96873: PUSH
96874: LD_INT 108
96876: PUSH
96877: LD_INT 109
96879: PUSH
96880: LD_INT 112
96882: PUSH
96883: LD_INT 116
96885: PUSH
96886: LD_INT 117
96888: PUSH
96889: LD_INT 118
96891: PUSH
96892: EMPTY
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: ST_TO_ADDR
96908: GO 99571
96910: LD_INT 6
96912: DOUBLE
96913: EQUAL
96914: IFTRUE 96918
96916: GO 97050
96918: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96919: LD_ADDR_VAR 0 2
96923: PUSH
96924: LD_INT 2
96926: PUSH
96927: LD_INT 4
96929: PUSH
96930: LD_INT 5
96932: PUSH
96933: LD_INT 6
96935: PUSH
96936: LD_INT 8
96938: PUSH
96939: LD_INT 11
96941: PUSH
96942: LD_INT 12
96944: PUSH
96945: LD_INT 15
96947: PUSH
96948: LD_INT 16
96950: PUSH
96951: LD_INT 20
96953: PUSH
96954: LD_INT 21
96956: PUSH
96957: LD_INT 22
96959: PUSH
96960: LD_INT 23
96962: PUSH
96963: LD_INT 25
96965: PUSH
96966: LD_INT 26
96968: PUSH
96969: LD_INT 30
96971: PUSH
96972: LD_INT 31
96974: PUSH
96975: LD_INT 32
96977: PUSH
96978: LD_INT 36
96980: PUSH
96981: EMPTY
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: LIST
96999: LIST
97000: LIST
97001: PUSH
97002: LD_INT 101
97004: PUSH
97005: LD_INT 102
97007: PUSH
97008: LD_INT 105
97010: PUSH
97011: LD_INT 106
97013: PUSH
97014: LD_INT 108
97016: PUSH
97017: LD_INT 109
97019: PUSH
97020: LD_INT 112
97022: PUSH
97023: LD_INT 116
97025: PUSH
97026: LD_INT 117
97028: PUSH
97029: LD_INT 118
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: PUSH
97044: EMPTY
97045: LIST
97046: LIST
97047: ST_TO_ADDR
97048: GO 99571
97050: LD_INT 7
97052: DOUBLE
97053: EQUAL
97054: IFTRUE 97058
97056: GO 97170
97058: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97059: LD_ADDR_VAR 0 2
97063: PUSH
97064: LD_INT 2
97066: PUSH
97067: LD_INT 4
97069: PUSH
97070: LD_INT 5
97072: PUSH
97073: LD_INT 7
97075: PUSH
97076: LD_INT 11
97078: PUSH
97079: LD_INT 12
97081: PUSH
97082: LD_INT 15
97084: PUSH
97085: LD_INT 16
97087: PUSH
97088: LD_INT 20
97090: PUSH
97091: LD_INT 21
97093: PUSH
97094: LD_INT 22
97096: PUSH
97097: LD_INT 23
97099: PUSH
97100: LD_INT 25
97102: PUSH
97103: LD_INT 26
97105: PUSH
97106: EMPTY
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: PUSH
97122: LD_INT 101
97124: PUSH
97125: LD_INT 102
97127: PUSH
97128: LD_INT 103
97130: PUSH
97131: LD_INT 105
97133: PUSH
97134: LD_INT 106
97136: PUSH
97137: LD_INT 108
97139: PUSH
97140: LD_INT 112
97142: PUSH
97143: LD_INT 116
97145: PUSH
97146: LD_INT 117
97148: PUSH
97149: LD_INT 118
97151: PUSH
97152: EMPTY
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: PUSH
97164: EMPTY
97165: LIST
97166: LIST
97167: ST_TO_ADDR
97168: GO 99571
97170: LD_INT 8
97172: DOUBLE
97173: EQUAL
97174: IFTRUE 97178
97176: GO 97318
97178: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97179: LD_ADDR_VAR 0 2
97183: PUSH
97184: LD_INT 2
97186: PUSH
97187: LD_INT 4
97189: PUSH
97190: LD_INT 5
97192: PUSH
97193: LD_INT 6
97195: PUSH
97196: LD_INT 7
97198: PUSH
97199: LD_INT 8
97201: PUSH
97202: LD_INT 11
97204: PUSH
97205: LD_INT 12
97207: PUSH
97208: LD_INT 15
97210: PUSH
97211: LD_INT 16
97213: PUSH
97214: LD_INT 20
97216: PUSH
97217: LD_INT 21
97219: PUSH
97220: LD_INT 22
97222: PUSH
97223: LD_INT 23
97225: PUSH
97226: LD_INT 25
97228: PUSH
97229: LD_INT 26
97231: PUSH
97232: LD_INT 30
97234: PUSH
97235: LD_INT 31
97237: PUSH
97238: LD_INT 32
97240: PUSH
97241: LD_INT 36
97243: PUSH
97244: EMPTY
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 101
97268: PUSH
97269: LD_INT 102
97271: PUSH
97272: LD_INT 103
97274: PUSH
97275: LD_INT 105
97277: PUSH
97278: LD_INT 106
97280: PUSH
97281: LD_INT 108
97283: PUSH
97284: LD_INT 109
97286: PUSH
97287: LD_INT 112
97289: PUSH
97290: LD_INT 116
97292: PUSH
97293: LD_INT 117
97295: PUSH
97296: LD_INT 118
97298: PUSH
97299: EMPTY
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: ST_TO_ADDR
97316: GO 99571
97318: LD_INT 9
97320: DOUBLE
97321: EQUAL
97322: IFTRUE 97326
97324: GO 97474
97326: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97327: LD_ADDR_VAR 0 2
97331: PUSH
97332: LD_INT 2
97334: PUSH
97335: LD_INT 4
97337: PUSH
97338: LD_INT 5
97340: PUSH
97341: LD_INT 6
97343: PUSH
97344: LD_INT 7
97346: PUSH
97347: LD_INT 8
97349: PUSH
97350: LD_INT 11
97352: PUSH
97353: LD_INT 12
97355: PUSH
97356: LD_INT 15
97358: PUSH
97359: LD_INT 16
97361: PUSH
97362: LD_INT 20
97364: PUSH
97365: LD_INT 21
97367: PUSH
97368: LD_INT 22
97370: PUSH
97371: LD_INT 23
97373: PUSH
97374: LD_INT 25
97376: PUSH
97377: LD_INT 26
97379: PUSH
97380: LD_INT 28
97382: PUSH
97383: LD_INT 30
97385: PUSH
97386: LD_INT 31
97388: PUSH
97389: LD_INT 32
97391: PUSH
97392: LD_INT 36
97394: PUSH
97395: EMPTY
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 101
97420: PUSH
97421: LD_INT 102
97423: PUSH
97424: LD_INT 103
97426: PUSH
97427: LD_INT 105
97429: PUSH
97430: LD_INT 106
97432: PUSH
97433: LD_INT 108
97435: PUSH
97436: LD_INT 109
97438: PUSH
97439: LD_INT 112
97441: PUSH
97442: LD_INT 114
97444: PUSH
97445: LD_INT 116
97447: PUSH
97448: LD_INT 117
97450: PUSH
97451: LD_INT 118
97453: PUSH
97454: EMPTY
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: ST_TO_ADDR
97472: GO 99571
97474: LD_INT 10
97476: DOUBLE
97477: EQUAL
97478: IFTRUE 97482
97480: GO 97678
97482: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97483: LD_ADDR_VAR 0 2
97487: PUSH
97488: LD_INT 2
97490: PUSH
97491: LD_INT 4
97493: PUSH
97494: LD_INT 5
97496: PUSH
97497: LD_INT 6
97499: PUSH
97500: LD_INT 7
97502: PUSH
97503: LD_INT 8
97505: PUSH
97506: LD_INT 9
97508: PUSH
97509: LD_INT 10
97511: PUSH
97512: LD_INT 11
97514: PUSH
97515: LD_INT 12
97517: PUSH
97518: LD_INT 13
97520: PUSH
97521: LD_INT 14
97523: PUSH
97524: LD_INT 15
97526: PUSH
97527: LD_INT 16
97529: PUSH
97530: LD_INT 17
97532: PUSH
97533: LD_INT 18
97535: PUSH
97536: LD_INT 19
97538: PUSH
97539: LD_INT 20
97541: PUSH
97542: LD_INT 21
97544: PUSH
97545: LD_INT 22
97547: PUSH
97548: LD_INT 23
97550: PUSH
97551: LD_INT 24
97553: PUSH
97554: LD_INT 25
97556: PUSH
97557: LD_INT 26
97559: PUSH
97560: LD_INT 28
97562: PUSH
97563: LD_INT 30
97565: PUSH
97566: LD_INT 31
97568: PUSH
97569: LD_INT 32
97571: PUSH
97572: LD_INT 36
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: LIST
97594: LIST
97595: LIST
97596: LIST
97597: LIST
97598: LIST
97599: LIST
97600: LIST
97601: LIST
97602: LIST
97603: LIST
97604: LIST
97605: PUSH
97606: LD_INT 101
97608: PUSH
97609: LD_INT 102
97611: PUSH
97612: LD_INT 103
97614: PUSH
97615: LD_INT 104
97617: PUSH
97618: LD_INT 105
97620: PUSH
97621: LD_INT 106
97623: PUSH
97624: LD_INT 107
97626: PUSH
97627: LD_INT 108
97629: PUSH
97630: LD_INT 109
97632: PUSH
97633: LD_INT 110
97635: PUSH
97636: LD_INT 111
97638: PUSH
97639: LD_INT 112
97641: PUSH
97642: LD_INT 114
97644: PUSH
97645: LD_INT 116
97647: PUSH
97648: LD_INT 117
97650: PUSH
97651: LD_INT 118
97653: PUSH
97654: EMPTY
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: ST_TO_ADDR
97676: GO 99571
97678: LD_INT 11
97680: DOUBLE
97681: EQUAL
97682: IFTRUE 97686
97684: GO 97890
97686: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97687: LD_ADDR_VAR 0 2
97691: PUSH
97692: LD_INT 2
97694: PUSH
97695: LD_INT 3
97697: PUSH
97698: LD_INT 4
97700: PUSH
97701: LD_INT 5
97703: PUSH
97704: LD_INT 6
97706: PUSH
97707: LD_INT 7
97709: PUSH
97710: LD_INT 8
97712: PUSH
97713: LD_INT 9
97715: PUSH
97716: LD_INT 10
97718: PUSH
97719: LD_INT 11
97721: PUSH
97722: LD_INT 12
97724: PUSH
97725: LD_INT 13
97727: PUSH
97728: LD_INT 14
97730: PUSH
97731: LD_INT 15
97733: PUSH
97734: LD_INT 16
97736: PUSH
97737: LD_INT 17
97739: PUSH
97740: LD_INT 18
97742: PUSH
97743: LD_INT 19
97745: PUSH
97746: LD_INT 20
97748: PUSH
97749: LD_INT 21
97751: PUSH
97752: LD_INT 22
97754: PUSH
97755: LD_INT 23
97757: PUSH
97758: LD_INT 24
97760: PUSH
97761: LD_INT 25
97763: PUSH
97764: LD_INT 26
97766: PUSH
97767: LD_INT 28
97769: PUSH
97770: LD_INT 30
97772: PUSH
97773: LD_INT 31
97775: PUSH
97776: LD_INT 32
97778: PUSH
97779: LD_INT 34
97781: PUSH
97782: LD_INT 36
97784: PUSH
97785: EMPTY
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 101
97820: PUSH
97821: LD_INT 102
97823: PUSH
97824: LD_INT 103
97826: PUSH
97827: LD_INT 104
97829: PUSH
97830: LD_INT 105
97832: PUSH
97833: LD_INT 106
97835: PUSH
97836: LD_INT 107
97838: PUSH
97839: LD_INT 108
97841: PUSH
97842: LD_INT 109
97844: PUSH
97845: LD_INT 110
97847: PUSH
97848: LD_INT 111
97850: PUSH
97851: LD_INT 112
97853: PUSH
97854: LD_INT 114
97856: PUSH
97857: LD_INT 116
97859: PUSH
97860: LD_INT 117
97862: PUSH
97863: LD_INT 118
97865: PUSH
97866: EMPTY
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: PUSH
97884: EMPTY
97885: LIST
97886: LIST
97887: ST_TO_ADDR
97888: GO 99571
97890: LD_INT 12
97892: DOUBLE
97893: EQUAL
97894: IFTRUE 97898
97896: GO 98118
97898: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97899: LD_ADDR_VAR 0 2
97903: PUSH
97904: LD_INT 1
97906: PUSH
97907: LD_INT 2
97909: PUSH
97910: LD_INT 3
97912: PUSH
97913: LD_INT 4
97915: PUSH
97916: LD_INT 5
97918: PUSH
97919: LD_INT 6
97921: PUSH
97922: LD_INT 7
97924: PUSH
97925: LD_INT 8
97927: PUSH
97928: LD_INT 9
97930: PUSH
97931: LD_INT 10
97933: PUSH
97934: LD_INT 11
97936: PUSH
97937: LD_INT 12
97939: PUSH
97940: LD_INT 13
97942: PUSH
97943: LD_INT 14
97945: PUSH
97946: LD_INT 15
97948: PUSH
97949: LD_INT 16
97951: PUSH
97952: LD_INT 17
97954: PUSH
97955: LD_INT 18
97957: PUSH
97958: LD_INT 19
97960: PUSH
97961: LD_INT 20
97963: PUSH
97964: LD_INT 21
97966: PUSH
97967: LD_INT 22
97969: PUSH
97970: LD_INT 23
97972: PUSH
97973: LD_INT 24
97975: PUSH
97976: LD_INT 25
97978: PUSH
97979: LD_INT 26
97981: PUSH
97982: LD_INT 27
97984: PUSH
97985: LD_INT 28
97987: PUSH
97988: LD_INT 30
97990: PUSH
97991: LD_INT 31
97993: PUSH
97994: LD_INT 32
97996: PUSH
97997: LD_INT 33
97999: PUSH
98000: LD_INT 34
98002: PUSH
98003: LD_INT 36
98005: PUSH
98006: EMPTY
98007: LIST
98008: LIST
98009: LIST
98010: LIST
98011: LIST
98012: LIST
98013: LIST
98014: LIST
98015: LIST
98016: LIST
98017: LIST
98018: LIST
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: PUSH
98042: LD_INT 101
98044: PUSH
98045: LD_INT 102
98047: PUSH
98048: LD_INT 103
98050: PUSH
98051: LD_INT 104
98053: PUSH
98054: LD_INT 105
98056: PUSH
98057: LD_INT 106
98059: PUSH
98060: LD_INT 107
98062: PUSH
98063: LD_INT 108
98065: PUSH
98066: LD_INT 109
98068: PUSH
98069: LD_INT 110
98071: PUSH
98072: LD_INT 111
98074: PUSH
98075: LD_INT 112
98077: PUSH
98078: LD_INT 113
98080: PUSH
98081: LD_INT 114
98083: PUSH
98084: LD_INT 116
98086: PUSH
98087: LD_INT 117
98089: PUSH
98090: LD_INT 118
98092: PUSH
98093: EMPTY
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: ST_TO_ADDR
98116: GO 99571
98118: LD_INT 13
98120: DOUBLE
98121: EQUAL
98122: IFTRUE 98126
98124: GO 98334
98126: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98127: LD_ADDR_VAR 0 2
98131: PUSH
98132: LD_INT 1
98134: PUSH
98135: LD_INT 2
98137: PUSH
98138: LD_INT 3
98140: PUSH
98141: LD_INT 4
98143: PUSH
98144: LD_INT 5
98146: PUSH
98147: LD_INT 8
98149: PUSH
98150: LD_INT 9
98152: PUSH
98153: LD_INT 10
98155: PUSH
98156: LD_INT 11
98158: PUSH
98159: LD_INT 12
98161: PUSH
98162: LD_INT 14
98164: PUSH
98165: LD_INT 15
98167: PUSH
98168: LD_INT 16
98170: PUSH
98171: LD_INT 17
98173: PUSH
98174: LD_INT 18
98176: PUSH
98177: LD_INT 19
98179: PUSH
98180: LD_INT 20
98182: PUSH
98183: LD_INT 21
98185: PUSH
98186: LD_INT 22
98188: PUSH
98189: LD_INT 23
98191: PUSH
98192: LD_INT 24
98194: PUSH
98195: LD_INT 25
98197: PUSH
98198: LD_INT 26
98200: PUSH
98201: LD_INT 27
98203: PUSH
98204: LD_INT 28
98206: PUSH
98207: LD_INT 30
98209: PUSH
98210: LD_INT 31
98212: PUSH
98213: LD_INT 32
98215: PUSH
98216: LD_INT 33
98218: PUSH
98219: LD_INT 34
98221: PUSH
98222: LD_INT 36
98224: PUSH
98225: EMPTY
98226: LIST
98227: LIST
98228: LIST
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: LIST
98234: LIST
98235: LIST
98236: LIST
98237: LIST
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: PUSH
98258: LD_INT 101
98260: PUSH
98261: LD_INT 102
98263: PUSH
98264: LD_INT 103
98266: PUSH
98267: LD_INT 104
98269: PUSH
98270: LD_INT 105
98272: PUSH
98273: LD_INT 106
98275: PUSH
98276: LD_INT 107
98278: PUSH
98279: LD_INT 108
98281: PUSH
98282: LD_INT 109
98284: PUSH
98285: LD_INT 110
98287: PUSH
98288: LD_INT 111
98290: PUSH
98291: LD_INT 112
98293: PUSH
98294: LD_INT 113
98296: PUSH
98297: LD_INT 114
98299: PUSH
98300: LD_INT 116
98302: PUSH
98303: LD_INT 117
98305: PUSH
98306: LD_INT 118
98308: PUSH
98309: EMPTY
98310: LIST
98311: LIST
98312: LIST
98313: LIST
98314: LIST
98315: LIST
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: PUSH
98328: EMPTY
98329: LIST
98330: LIST
98331: ST_TO_ADDR
98332: GO 99571
98334: LD_INT 14
98336: DOUBLE
98337: EQUAL
98338: IFTRUE 98342
98340: GO 98566
98342: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98343: LD_ADDR_VAR 0 2
98347: PUSH
98348: LD_INT 1
98350: PUSH
98351: LD_INT 2
98353: PUSH
98354: LD_INT 3
98356: PUSH
98357: LD_INT 4
98359: PUSH
98360: LD_INT 5
98362: PUSH
98363: LD_INT 6
98365: PUSH
98366: LD_INT 7
98368: PUSH
98369: LD_INT 8
98371: PUSH
98372: LD_INT 9
98374: PUSH
98375: LD_INT 10
98377: PUSH
98378: LD_INT 11
98380: PUSH
98381: LD_INT 12
98383: PUSH
98384: LD_INT 13
98386: PUSH
98387: LD_INT 14
98389: PUSH
98390: LD_INT 15
98392: PUSH
98393: LD_INT 16
98395: PUSH
98396: LD_INT 17
98398: PUSH
98399: LD_INT 18
98401: PUSH
98402: LD_INT 19
98404: PUSH
98405: LD_INT 20
98407: PUSH
98408: LD_INT 21
98410: PUSH
98411: LD_INT 22
98413: PUSH
98414: LD_INT 23
98416: PUSH
98417: LD_INT 24
98419: PUSH
98420: LD_INT 25
98422: PUSH
98423: LD_INT 26
98425: PUSH
98426: LD_INT 27
98428: PUSH
98429: LD_INT 28
98431: PUSH
98432: LD_INT 29
98434: PUSH
98435: LD_INT 30
98437: PUSH
98438: LD_INT 31
98440: PUSH
98441: LD_INT 32
98443: PUSH
98444: LD_INT 33
98446: PUSH
98447: LD_INT 34
98449: PUSH
98450: LD_INT 36
98452: PUSH
98453: EMPTY
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: LIST
98459: LIST
98460: LIST
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: LIST
98469: LIST
98470: LIST
98471: LIST
98472: LIST
98473: LIST
98474: LIST
98475: LIST
98476: LIST
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: PUSH
98490: LD_INT 101
98492: PUSH
98493: LD_INT 102
98495: PUSH
98496: LD_INT 103
98498: PUSH
98499: LD_INT 104
98501: PUSH
98502: LD_INT 105
98504: PUSH
98505: LD_INT 106
98507: PUSH
98508: LD_INT 107
98510: PUSH
98511: LD_INT 108
98513: PUSH
98514: LD_INT 109
98516: PUSH
98517: LD_INT 110
98519: PUSH
98520: LD_INT 111
98522: PUSH
98523: LD_INT 112
98525: PUSH
98526: LD_INT 113
98528: PUSH
98529: LD_INT 114
98531: PUSH
98532: LD_INT 116
98534: PUSH
98535: LD_INT 117
98537: PUSH
98538: LD_INT 118
98540: PUSH
98541: EMPTY
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: PUSH
98560: EMPTY
98561: LIST
98562: LIST
98563: ST_TO_ADDR
98564: GO 99571
98566: LD_INT 15
98568: DOUBLE
98569: EQUAL
98570: IFTRUE 98574
98572: GO 98798
98574: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98575: LD_ADDR_VAR 0 2
98579: PUSH
98580: LD_INT 1
98582: PUSH
98583: LD_INT 2
98585: PUSH
98586: LD_INT 3
98588: PUSH
98589: LD_INT 4
98591: PUSH
98592: LD_INT 5
98594: PUSH
98595: LD_INT 6
98597: PUSH
98598: LD_INT 7
98600: PUSH
98601: LD_INT 8
98603: PUSH
98604: LD_INT 9
98606: PUSH
98607: LD_INT 10
98609: PUSH
98610: LD_INT 11
98612: PUSH
98613: LD_INT 12
98615: PUSH
98616: LD_INT 13
98618: PUSH
98619: LD_INT 14
98621: PUSH
98622: LD_INT 15
98624: PUSH
98625: LD_INT 16
98627: PUSH
98628: LD_INT 17
98630: PUSH
98631: LD_INT 18
98633: PUSH
98634: LD_INT 19
98636: PUSH
98637: LD_INT 20
98639: PUSH
98640: LD_INT 21
98642: PUSH
98643: LD_INT 22
98645: PUSH
98646: LD_INT 23
98648: PUSH
98649: LD_INT 24
98651: PUSH
98652: LD_INT 25
98654: PUSH
98655: LD_INT 26
98657: PUSH
98658: LD_INT 27
98660: PUSH
98661: LD_INT 28
98663: PUSH
98664: LD_INT 29
98666: PUSH
98667: LD_INT 30
98669: PUSH
98670: LD_INT 31
98672: PUSH
98673: LD_INT 32
98675: PUSH
98676: LD_INT 33
98678: PUSH
98679: LD_INT 34
98681: PUSH
98682: LD_INT 36
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: LIST
98689: LIST
98690: LIST
98691: LIST
98692: LIST
98693: LIST
98694: LIST
98695: LIST
98696: LIST
98697: LIST
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: PUSH
98722: LD_INT 101
98724: PUSH
98725: LD_INT 102
98727: PUSH
98728: LD_INT 103
98730: PUSH
98731: LD_INT 104
98733: PUSH
98734: LD_INT 105
98736: PUSH
98737: LD_INT 106
98739: PUSH
98740: LD_INT 107
98742: PUSH
98743: LD_INT 108
98745: PUSH
98746: LD_INT 109
98748: PUSH
98749: LD_INT 110
98751: PUSH
98752: LD_INT 111
98754: PUSH
98755: LD_INT 112
98757: PUSH
98758: LD_INT 113
98760: PUSH
98761: LD_INT 114
98763: PUSH
98764: LD_INT 116
98766: PUSH
98767: LD_INT 117
98769: PUSH
98770: LD_INT 118
98772: PUSH
98773: EMPTY
98774: LIST
98775: LIST
98776: LIST
98777: LIST
98778: LIST
98779: LIST
98780: LIST
98781: LIST
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: PUSH
98792: EMPTY
98793: LIST
98794: LIST
98795: ST_TO_ADDR
98796: GO 99571
98798: LD_INT 16
98800: DOUBLE
98801: EQUAL
98802: IFTRUE 98806
98804: GO 98942
98806: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98807: LD_ADDR_VAR 0 2
98811: PUSH
98812: LD_INT 2
98814: PUSH
98815: LD_INT 4
98817: PUSH
98818: LD_INT 5
98820: PUSH
98821: LD_INT 7
98823: PUSH
98824: LD_INT 11
98826: PUSH
98827: LD_INT 12
98829: PUSH
98830: LD_INT 15
98832: PUSH
98833: LD_INT 16
98835: PUSH
98836: LD_INT 20
98838: PUSH
98839: LD_INT 21
98841: PUSH
98842: LD_INT 22
98844: PUSH
98845: LD_INT 23
98847: PUSH
98848: LD_INT 25
98850: PUSH
98851: LD_INT 26
98853: PUSH
98854: LD_INT 30
98856: PUSH
98857: LD_INT 31
98859: PUSH
98860: LD_INT 32
98862: PUSH
98863: LD_INT 33
98865: PUSH
98866: LD_INT 34
98868: PUSH
98869: EMPTY
98870: LIST
98871: LIST
98872: LIST
98873: LIST
98874: LIST
98875: LIST
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: LIST
98883: LIST
98884: LIST
98885: LIST
98886: LIST
98887: LIST
98888: LIST
98889: PUSH
98890: LD_INT 101
98892: PUSH
98893: LD_INT 102
98895: PUSH
98896: LD_INT 103
98898: PUSH
98899: LD_INT 106
98901: PUSH
98902: LD_INT 108
98904: PUSH
98905: LD_INT 112
98907: PUSH
98908: LD_INT 113
98910: PUSH
98911: LD_INT 114
98913: PUSH
98914: LD_INT 116
98916: PUSH
98917: LD_INT 117
98919: PUSH
98920: LD_INT 118
98922: PUSH
98923: EMPTY
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: PUSH
98936: EMPTY
98937: LIST
98938: LIST
98939: ST_TO_ADDR
98940: GO 99571
98942: LD_INT 17
98944: DOUBLE
98945: EQUAL
98946: IFTRUE 98950
98948: GO 99174
98950: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98951: LD_ADDR_VAR 0 2
98955: PUSH
98956: LD_INT 1
98958: PUSH
98959: LD_INT 2
98961: PUSH
98962: LD_INT 3
98964: PUSH
98965: LD_INT 4
98967: PUSH
98968: LD_INT 5
98970: PUSH
98971: LD_INT 6
98973: PUSH
98974: LD_INT 7
98976: PUSH
98977: LD_INT 8
98979: PUSH
98980: LD_INT 9
98982: PUSH
98983: LD_INT 10
98985: PUSH
98986: LD_INT 11
98988: PUSH
98989: LD_INT 12
98991: PUSH
98992: LD_INT 13
98994: PUSH
98995: LD_INT 14
98997: PUSH
98998: LD_INT 15
99000: PUSH
99001: LD_INT 16
99003: PUSH
99004: LD_INT 17
99006: PUSH
99007: LD_INT 18
99009: PUSH
99010: LD_INT 19
99012: PUSH
99013: LD_INT 20
99015: PUSH
99016: LD_INT 21
99018: PUSH
99019: LD_INT 22
99021: PUSH
99022: LD_INT 23
99024: PUSH
99025: LD_INT 24
99027: PUSH
99028: LD_INT 25
99030: PUSH
99031: LD_INT 26
99033: PUSH
99034: LD_INT 27
99036: PUSH
99037: LD_INT 28
99039: PUSH
99040: LD_INT 29
99042: PUSH
99043: LD_INT 30
99045: PUSH
99046: LD_INT 31
99048: PUSH
99049: LD_INT 32
99051: PUSH
99052: LD_INT 33
99054: PUSH
99055: LD_INT 34
99057: PUSH
99058: LD_INT 36
99060: PUSH
99061: EMPTY
99062: LIST
99063: LIST
99064: LIST
99065: LIST
99066: LIST
99067: LIST
99068: LIST
99069: LIST
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: LIST
99077: LIST
99078: LIST
99079: LIST
99080: LIST
99081: LIST
99082: LIST
99083: LIST
99084: LIST
99085: LIST
99086: LIST
99087: LIST
99088: LIST
99089: LIST
99090: LIST
99091: LIST
99092: LIST
99093: LIST
99094: LIST
99095: LIST
99096: LIST
99097: PUSH
99098: LD_INT 101
99100: PUSH
99101: LD_INT 102
99103: PUSH
99104: LD_INT 103
99106: PUSH
99107: LD_INT 104
99109: PUSH
99110: LD_INT 105
99112: PUSH
99113: LD_INT 106
99115: PUSH
99116: LD_INT 107
99118: PUSH
99119: LD_INT 108
99121: PUSH
99122: LD_INT 109
99124: PUSH
99125: LD_INT 110
99127: PUSH
99128: LD_INT 111
99130: PUSH
99131: LD_INT 112
99133: PUSH
99134: LD_INT 113
99136: PUSH
99137: LD_INT 114
99139: PUSH
99140: LD_INT 116
99142: PUSH
99143: LD_INT 117
99145: PUSH
99146: LD_INT 118
99148: PUSH
99149: EMPTY
99150: LIST
99151: LIST
99152: LIST
99153: LIST
99154: LIST
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: PUSH
99168: EMPTY
99169: LIST
99170: LIST
99171: ST_TO_ADDR
99172: GO 99571
99174: LD_INT 18
99176: DOUBLE
99177: EQUAL
99178: IFTRUE 99182
99180: GO 99330
99182: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99183: LD_ADDR_VAR 0 2
99187: PUSH
99188: LD_INT 2
99190: PUSH
99191: LD_INT 4
99193: PUSH
99194: LD_INT 5
99196: PUSH
99197: LD_INT 7
99199: PUSH
99200: LD_INT 11
99202: PUSH
99203: LD_INT 12
99205: PUSH
99206: LD_INT 15
99208: PUSH
99209: LD_INT 16
99211: PUSH
99212: LD_INT 20
99214: PUSH
99215: LD_INT 21
99217: PUSH
99218: LD_INT 22
99220: PUSH
99221: LD_INT 23
99223: PUSH
99224: LD_INT 25
99226: PUSH
99227: LD_INT 26
99229: PUSH
99230: LD_INT 30
99232: PUSH
99233: LD_INT 31
99235: PUSH
99236: LD_INT 32
99238: PUSH
99239: LD_INT 33
99241: PUSH
99242: LD_INT 34
99244: PUSH
99245: LD_INT 35
99247: PUSH
99248: LD_INT 36
99250: PUSH
99251: EMPTY
99252: LIST
99253: LIST
99254: LIST
99255: LIST
99256: LIST
99257: LIST
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: PUSH
99274: LD_INT 101
99276: PUSH
99277: LD_INT 102
99279: PUSH
99280: LD_INT 103
99282: PUSH
99283: LD_INT 106
99285: PUSH
99286: LD_INT 108
99288: PUSH
99289: LD_INT 112
99291: PUSH
99292: LD_INT 113
99294: PUSH
99295: LD_INT 114
99297: PUSH
99298: LD_INT 115
99300: PUSH
99301: LD_INT 116
99303: PUSH
99304: LD_INT 117
99306: PUSH
99307: LD_INT 118
99309: PUSH
99310: EMPTY
99311: LIST
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: PUSH
99324: EMPTY
99325: LIST
99326: LIST
99327: ST_TO_ADDR
99328: GO 99571
99330: LD_INT 19
99332: DOUBLE
99333: EQUAL
99334: IFTRUE 99338
99336: GO 99570
99338: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99339: LD_ADDR_VAR 0 2
99343: PUSH
99344: LD_INT 1
99346: PUSH
99347: LD_INT 2
99349: PUSH
99350: LD_INT 3
99352: PUSH
99353: LD_INT 4
99355: PUSH
99356: LD_INT 5
99358: PUSH
99359: LD_INT 6
99361: PUSH
99362: LD_INT 7
99364: PUSH
99365: LD_INT 8
99367: PUSH
99368: LD_INT 9
99370: PUSH
99371: LD_INT 10
99373: PUSH
99374: LD_INT 11
99376: PUSH
99377: LD_INT 12
99379: PUSH
99380: LD_INT 13
99382: PUSH
99383: LD_INT 14
99385: PUSH
99386: LD_INT 15
99388: PUSH
99389: LD_INT 16
99391: PUSH
99392: LD_INT 17
99394: PUSH
99395: LD_INT 18
99397: PUSH
99398: LD_INT 19
99400: PUSH
99401: LD_INT 20
99403: PUSH
99404: LD_INT 21
99406: PUSH
99407: LD_INT 22
99409: PUSH
99410: LD_INT 23
99412: PUSH
99413: LD_INT 24
99415: PUSH
99416: LD_INT 25
99418: PUSH
99419: LD_INT 26
99421: PUSH
99422: LD_INT 27
99424: PUSH
99425: LD_INT 28
99427: PUSH
99428: LD_INT 29
99430: PUSH
99431: LD_INT 30
99433: PUSH
99434: LD_INT 31
99436: PUSH
99437: LD_INT 32
99439: PUSH
99440: LD_INT 33
99442: PUSH
99443: LD_INT 34
99445: PUSH
99446: LD_INT 35
99448: PUSH
99449: LD_INT 36
99451: PUSH
99452: EMPTY
99453: LIST
99454: LIST
99455: LIST
99456: LIST
99457: LIST
99458: LIST
99459: LIST
99460: LIST
99461: LIST
99462: LIST
99463: LIST
99464: LIST
99465: LIST
99466: LIST
99467: LIST
99468: LIST
99469: LIST
99470: LIST
99471: LIST
99472: LIST
99473: LIST
99474: LIST
99475: LIST
99476: LIST
99477: LIST
99478: LIST
99479: LIST
99480: LIST
99481: LIST
99482: LIST
99483: LIST
99484: LIST
99485: LIST
99486: LIST
99487: LIST
99488: LIST
99489: PUSH
99490: LD_INT 101
99492: PUSH
99493: LD_INT 102
99495: PUSH
99496: LD_INT 103
99498: PUSH
99499: LD_INT 104
99501: PUSH
99502: LD_INT 105
99504: PUSH
99505: LD_INT 106
99507: PUSH
99508: LD_INT 107
99510: PUSH
99511: LD_INT 108
99513: PUSH
99514: LD_INT 109
99516: PUSH
99517: LD_INT 110
99519: PUSH
99520: LD_INT 111
99522: PUSH
99523: LD_INT 112
99525: PUSH
99526: LD_INT 113
99528: PUSH
99529: LD_INT 114
99531: PUSH
99532: LD_INT 115
99534: PUSH
99535: LD_INT 116
99537: PUSH
99538: LD_INT 117
99540: PUSH
99541: LD_INT 118
99543: PUSH
99544: EMPTY
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: PUSH
99564: EMPTY
99565: LIST
99566: LIST
99567: ST_TO_ADDR
99568: GO 99571
99570: POP
// end else
99571: GO 99802
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99573: LD_ADDR_VAR 0 2
99577: PUSH
99578: LD_INT 1
99580: PUSH
99581: LD_INT 2
99583: PUSH
99584: LD_INT 3
99586: PUSH
99587: LD_INT 4
99589: PUSH
99590: LD_INT 5
99592: PUSH
99593: LD_INT 6
99595: PUSH
99596: LD_INT 7
99598: PUSH
99599: LD_INT 8
99601: PUSH
99602: LD_INT 9
99604: PUSH
99605: LD_INT 10
99607: PUSH
99608: LD_INT 11
99610: PUSH
99611: LD_INT 12
99613: PUSH
99614: LD_INT 13
99616: PUSH
99617: LD_INT 14
99619: PUSH
99620: LD_INT 15
99622: PUSH
99623: LD_INT 16
99625: PUSH
99626: LD_INT 17
99628: PUSH
99629: LD_INT 18
99631: PUSH
99632: LD_INT 19
99634: PUSH
99635: LD_INT 20
99637: PUSH
99638: LD_INT 21
99640: PUSH
99641: LD_INT 22
99643: PUSH
99644: LD_INT 23
99646: PUSH
99647: LD_INT 24
99649: PUSH
99650: LD_INT 25
99652: PUSH
99653: LD_INT 26
99655: PUSH
99656: LD_INT 27
99658: PUSH
99659: LD_INT 28
99661: PUSH
99662: LD_INT 29
99664: PUSH
99665: LD_INT 30
99667: PUSH
99668: LD_INT 31
99670: PUSH
99671: LD_INT 32
99673: PUSH
99674: LD_INT 33
99676: PUSH
99677: LD_INT 34
99679: PUSH
99680: LD_INT 35
99682: PUSH
99683: LD_INT 36
99685: PUSH
99686: EMPTY
99687: LIST
99688: LIST
99689: LIST
99690: LIST
99691: LIST
99692: LIST
99693: LIST
99694: LIST
99695: LIST
99696: LIST
99697: LIST
99698: LIST
99699: LIST
99700: LIST
99701: LIST
99702: LIST
99703: LIST
99704: LIST
99705: LIST
99706: LIST
99707: LIST
99708: LIST
99709: LIST
99710: LIST
99711: LIST
99712: LIST
99713: LIST
99714: LIST
99715: LIST
99716: LIST
99717: LIST
99718: LIST
99719: LIST
99720: LIST
99721: LIST
99722: LIST
99723: PUSH
99724: LD_INT 101
99726: PUSH
99727: LD_INT 102
99729: PUSH
99730: LD_INT 103
99732: PUSH
99733: LD_INT 104
99735: PUSH
99736: LD_INT 105
99738: PUSH
99739: LD_INT 106
99741: PUSH
99742: LD_INT 107
99744: PUSH
99745: LD_INT 108
99747: PUSH
99748: LD_INT 109
99750: PUSH
99751: LD_INT 110
99753: PUSH
99754: LD_INT 111
99756: PUSH
99757: LD_INT 112
99759: PUSH
99760: LD_INT 113
99762: PUSH
99763: LD_INT 114
99765: PUSH
99766: LD_INT 115
99768: PUSH
99769: LD_INT 116
99771: PUSH
99772: LD_INT 117
99774: PUSH
99775: LD_INT 118
99777: PUSH
99778: EMPTY
99779: LIST
99780: LIST
99781: LIST
99782: LIST
99783: LIST
99784: LIST
99785: LIST
99786: LIST
99787: LIST
99788: LIST
99789: LIST
99790: LIST
99791: LIST
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: LIST
99797: PUSH
99798: EMPTY
99799: LIST
99800: LIST
99801: ST_TO_ADDR
// if result then
99802: LD_VAR 0 2
99806: IFFALSE 100592
// begin normal :=  ;
99808: LD_ADDR_VAR 0 5
99812: PUSH
99813: LD_STRING 
99815: ST_TO_ADDR
// hardcore :=  ;
99816: LD_ADDR_VAR 0 6
99820: PUSH
99821: LD_STRING 
99823: ST_TO_ADDR
// active :=  ;
99824: LD_ADDR_VAR 0 7
99828: PUSH
99829: LD_STRING 
99831: ST_TO_ADDR
// for i = 1 to normalCounter do
99832: LD_ADDR_VAR 0 8
99836: PUSH
99837: DOUBLE
99838: LD_INT 1
99840: DEC
99841: ST_TO_ADDR
99842: LD_EXP 78
99846: PUSH
99847: FOR_TO
99848: IFFALSE 99949
// begin tmp := 0 ;
99850: LD_ADDR_VAR 0 3
99854: PUSH
99855: LD_STRING 0
99857: ST_TO_ADDR
// if result [ 1 ] then
99858: LD_VAR 0 2
99862: PUSH
99863: LD_INT 1
99865: ARRAY
99866: IFFALSE 99931
// if result [ 1 ] [ 1 ] = i then
99868: LD_VAR 0 2
99872: PUSH
99873: LD_INT 1
99875: ARRAY
99876: PUSH
99877: LD_INT 1
99879: ARRAY
99880: PUSH
99881: LD_VAR 0 8
99885: EQUAL
99886: IFFALSE 99931
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99888: LD_ADDR_VAR 0 2
99892: PUSH
99893: LD_VAR 0 2
99897: PPUSH
99898: LD_INT 1
99900: PPUSH
99901: LD_VAR 0 2
99905: PUSH
99906: LD_INT 1
99908: ARRAY
99909: PPUSH
99910: LD_INT 1
99912: PPUSH
99913: CALL_OW 3
99917: PPUSH
99918: CALL_OW 1
99922: ST_TO_ADDR
// tmp := 1 ;
99923: LD_ADDR_VAR 0 3
99927: PUSH
99928: LD_STRING 1
99930: ST_TO_ADDR
// end ; normal := normal & tmp ;
99931: LD_ADDR_VAR 0 5
99935: PUSH
99936: LD_VAR 0 5
99940: PUSH
99941: LD_VAR 0 3
99945: STR
99946: ST_TO_ADDR
// end ;
99947: GO 99847
99949: POP
99950: POP
// for i = 1 to hardcoreCounter do
99951: LD_ADDR_VAR 0 8
99955: PUSH
99956: DOUBLE
99957: LD_INT 1
99959: DEC
99960: ST_TO_ADDR
99961: LD_EXP 79
99965: PUSH
99966: FOR_TO
99967: IFFALSE 100072
// begin tmp := 0 ;
99969: LD_ADDR_VAR 0 3
99973: PUSH
99974: LD_STRING 0
99976: ST_TO_ADDR
// if result [ 2 ] then
99977: LD_VAR 0 2
99981: PUSH
99982: LD_INT 2
99984: ARRAY
99985: IFFALSE 100054
// if result [ 2 ] [ 1 ] = 100 + i then
99987: LD_VAR 0 2
99991: PUSH
99992: LD_INT 2
99994: ARRAY
99995: PUSH
99996: LD_INT 1
99998: ARRAY
99999: PUSH
100000: LD_INT 100
100002: PUSH
100003: LD_VAR 0 8
100007: PLUS
100008: EQUAL
100009: IFFALSE 100054
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100011: LD_ADDR_VAR 0 2
100015: PUSH
100016: LD_VAR 0 2
100020: PPUSH
100021: LD_INT 2
100023: PPUSH
100024: LD_VAR 0 2
100028: PUSH
100029: LD_INT 2
100031: ARRAY
100032: PPUSH
100033: LD_INT 1
100035: PPUSH
100036: CALL_OW 3
100040: PPUSH
100041: CALL_OW 1
100045: ST_TO_ADDR
// tmp := 1 ;
100046: LD_ADDR_VAR 0 3
100050: PUSH
100051: LD_STRING 1
100053: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100054: LD_ADDR_VAR 0 6
100058: PUSH
100059: LD_VAR 0 6
100063: PUSH
100064: LD_VAR 0 3
100068: STR
100069: ST_TO_ADDR
// end ;
100070: GO 99966
100072: POP
100073: POP
// if isGameLoad then
100074: LD_VAR 0 1
100078: IFFALSE 100553
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100080: LD_ADDR_VAR 0 4
100084: PUSH
100085: LD_EXP 82
100089: PUSH
100090: LD_EXP 81
100094: PUSH
100095: LD_EXP 83
100099: PUSH
100100: LD_EXP 80
100104: PUSH
100105: LD_EXP 84
100109: PUSH
100110: LD_EXP 85
100114: PUSH
100115: LD_EXP 86
100119: PUSH
100120: LD_EXP 87
100124: PUSH
100125: LD_EXP 88
100129: PUSH
100130: LD_EXP 89
100134: PUSH
100135: LD_EXP 90
100139: PUSH
100140: LD_EXP 91
100144: PUSH
100145: LD_EXP 92
100149: PUSH
100150: LD_EXP 93
100154: PUSH
100155: LD_EXP 101
100159: PUSH
100160: LD_EXP 102
100164: PUSH
100165: LD_EXP 103
100169: PUSH
100170: LD_EXP 104
100174: PUSH
100175: LD_EXP 106
100179: PUSH
100180: LD_EXP 107
100184: PUSH
100185: LD_EXP 108
100189: PUSH
100190: LD_EXP 111
100194: PUSH
100195: LD_EXP 113
100199: PUSH
100200: LD_EXP 114
100204: PUSH
100205: LD_EXP 115
100209: PUSH
100210: LD_EXP 117
100214: PUSH
100215: LD_EXP 118
100219: PUSH
100220: LD_EXP 121
100224: PUSH
100225: LD_EXP 122
100229: PUSH
100230: LD_EXP 123
100234: PUSH
100235: LD_EXP 124
100239: PUSH
100240: LD_EXP 125
100244: PUSH
100245: LD_EXP 126
100249: PUSH
100250: LD_EXP 127
100254: PUSH
100255: LD_EXP 128
100259: PUSH
100260: LD_EXP 129
100264: PUSH
100265: LD_EXP 94
100269: PUSH
100270: LD_EXP 95
100274: PUSH
100275: LD_EXP 98
100279: PUSH
100280: LD_EXP 99
100284: PUSH
100285: LD_EXP 100
100289: PUSH
100290: LD_EXP 96
100294: PUSH
100295: LD_EXP 97
100299: PUSH
100300: LD_EXP 105
100304: PUSH
100305: LD_EXP 109
100309: PUSH
100310: LD_EXP 110
100314: PUSH
100315: LD_EXP 112
100319: PUSH
100320: LD_EXP 116
100324: PUSH
100325: LD_EXP 119
100329: PUSH
100330: LD_EXP 120
100334: PUSH
100335: LD_EXP 130
100339: PUSH
100340: LD_EXP 131
100344: PUSH
100345: LD_EXP 132
100349: PUSH
100350: LD_EXP 133
100354: PUSH
100355: EMPTY
100356: LIST
100357: LIST
100358: LIST
100359: LIST
100360: LIST
100361: LIST
100362: LIST
100363: LIST
100364: LIST
100365: LIST
100366: LIST
100367: LIST
100368: LIST
100369: LIST
100370: LIST
100371: LIST
100372: LIST
100373: LIST
100374: LIST
100375: LIST
100376: LIST
100377: LIST
100378: LIST
100379: LIST
100380: LIST
100381: LIST
100382: LIST
100383: LIST
100384: LIST
100385: LIST
100386: LIST
100387: LIST
100388: LIST
100389: LIST
100390: LIST
100391: LIST
100392: LIST
100393: LIST
100394: LIST
100395: LIST
100396: LIST
100397: LIST
100398: LIST
100399: LIST
100400: LIST
100401: LIST
100402: LIST
100403: LIST
100404: LIST
100405: LIST
100406: LIST
100407: LIST
100408: LIST
100409: LIST
100410: ST_TO_ADDR
// tmp :=  ;
100411: LD_ADDR_VAR 0 3
100415: PUSH
100416: LD_STRING 
100418: ST_TO_ADDR
// for i = 1 to normalCounter do
100419: LD_ADDR_VAR 0 8
100423: PUSH
100424: DOUBLE
100425: LD_INT 1
100427: DEC
100428: ST_TO_ADDR
100429: LD_EXP 78
100433: PUSH
100434: FOR_TO
100435: IFFALSE 100471
// begin if flags [ i ] then
100437: LD_VAR 0 4
100441: PUSH
100442: LD_VAR 0 8
100446: ARRAY
100447: IFFALSE 100469
// tmp := tmp & i & ; ;
100449: LD_ADDR_VAR 0 3
100453: PUSH
100454: LD_VAR 0 3
100458: PUSH
100459: LD_VAR 0 8
100463: STR
100464: PUSH
100465: LD_STRING ;
100467: STR
100468: ST_TO_ADDR
// end ;
100469: GO 100434
100471: POP
100472: POP
// for i = 1 to hardcoreCounter do
100473: LD_ADDR_VAR 0 8
100477: PUSH
100478: DOUBLE
100479: LD_INT 1
100481: DEC
100482: ST_TO_ADDR
100483: LD_EXP 79
100487: PUSH
100488: FOR_TO
100489: IFFALSE 100535
// begin if flags [ normalCounter + i ] then
100491: LD_VAR 0 4
100495: PUSH
100496: LD_EXP 78
100500: PUSH
100501: LD_VAR 0 8
100505: PLUS
100506: ARRAY
100507: IFFALSE 100533
// tmp := tmp & ( 100 + i ) & ; ;
100509: LD_ADDR_VAR 0 3
100513: PUSH
100514: LD_VAR 0 3
100518: PUSH
100519: LD_INT 100
100521: PUSH
100522: LD_VAR 0 8
100526: PLUS
100527: STR
100528: PUSH
100529: LD_STRING ;
100531: STR
100532: ST_TO_ADDR
// end ;
100533: GO 100488
100535: POP
100536: POP
// if tmp then
100537: LD_VAR 0 3
100541: IFFALSE 100553
// active := tmp ;
100543: LD_ADDR_VAR 0 7
100547: PUSH
100548: LD_VAR 0 3
100552: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100553: LD_STRING getStreamItemsFromMission("
100555: PUSH
100556: LD_VAR 0 5
100560: STR
100561: PUSH
100562: LD_STRING ","
100564: STR
100565: PUSH
100566: LD_VAR 0 6
100570: STR
100571: PUSH
100572: LD_STRING ","
100574: STR
100575: PUSH
100576: LD_VAR 0 7
100580: STR
100581: PUSH
100582: LD_STRING ")
100584: STR
100585: PPUSH
100586: CALL_OW 559
// end else
100590: GO 100599
// ToLua ( getStreamItemsFromMission("","","") ) ;
100592: LD_STRING getStreamItemsFromMission("","","")
100594: PPUSH
100595: CALL_OW 559
// end ;
100599: LD_VAR 0 2
100603: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100604: LD_EXP 77
100608: IFFALSE 100616
100610: PUSH
100611: LD_EXP 82
100615: AND
100616: IFFALSE 100740
100618: GO 100620
100620: DISABLE
100621: LD_INT 0
100623: PPUSH
100624: PPUSH
// begin enable ;
100625: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100626: LD_ADDR_VAR 0 2
100630: PUSH
100631: LD_INT 22
100633: PUSH
100634: LD_OWVAR 2
100638: PUSH
100639: EMPTY
100640: LIST
100641: LIST
100642: PUSH
100643: LD_INT 2
100645: PUSH
100646: LD_INT 34
100648: PUSH
100649: LD_INT 7
100651: PUSH
100652: EMPTY
100653: LIST
100654: LIST
100655: PUSH
100656: LD_INT 34
100658: PUSH
100659: LD_INT 45
100661: PUSH
100662: EMPTY
100663: LIST
100664: LIST
100665: PUSH
100666: LD_INT 34
100668: PUSH
100669: LD_INT 28
100671: PUSH
100672: EMPTY
100673: LIST
100674: LIST
100675: PUSH
100676: LD_INT 34
100678: PUSH
100679: LD_INT 47
100681: PUSH
100682: EMPTY
100683: LIST
100684: LIST
100685: PUSH
100686: EMPTY
100687: LIST
100688: LIST
100689: LIST
100690: LIST
100691: LIST
100692: PUSH
100693: EMPTY
100694: LIST
100695: LIST
100696: PPUSH
100697: CALL_OW 69
100701: ST_TO_ADDR
// if not tmp then
100702: LD_VAR 0 2
100706: NOT
100707: IFFALSE 100711
// exit ;
100709: GO 100740
// for i in tmp do
100711: LD_ADDR_VAR 0 1
100715: PUSH
100716: LD_VAR 0 2
100720: PUSH
100721: FOR_IN
100722: IFFALSE 100738
// begin SetLives ( i , 0 ) ;
100724: LD_VAR 0 1
100728: PPUSH
100729: LD_INT 0
100731: PPUSH
100732: CALL_OW 234
// end ;
100736: GO 100721
100738: POP
100739: POP
// end ;
100740: PPOPN 2
100742: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100743: LD_EXP 77
100747: IFFALSE 100755
100749: PUSH
100750: LD_EXP 83
100754: AND
100755: IFFALSE 100839
100757: GO 100759
100759: DISABLE
100760: LD_INT 0
100762: PPUSH
100763: PPUSH
// begin enable ;
100764: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100765: LD_ADDR_VAR 0 2
100769: PUSH
100770: LD_INT 22
100772: PUSH
100773: LD_OWVAR 2
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PUSH
100782: LD_INT 32
100784: PUSH
100785: LD_INT 3
100787: PUSH
100788: EMPTY
100789: LIST
100790: LIST
100791: PUSH
100792: EMPTY
100793: LIST
100794: LIST
100795: PPUSH
100796: CALL_OW 69
100800: ST_TO_ADDR
// if not tmp then
100801: LD_VAR 0 2
100805: NOT
100806: IFFALSE 100810
// exit ;
100808: GO 100839
// for i in tmp do
100810: LD_ADDR_VAR 0 1
100814: PUSH
100815: LD_VAR 0 2
100819: PUSH
100820: FOR_IN
100821: IFFALSE 100837
// begin SetLives ( i , 0 ) ;
100823: LD_VAR 0 1
100827: PPUSH
100828: LD_INT 0
100830: PPUSH
100831: CALL_OW 234
// end ;
100835: GO 100820
100837: POP
100838: POP
// end ;
100839: PPOPN 2
100841: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100842: LD_EXP 77
100846: IFFALSE 100854
100848: PUSH
100849: LD_EXP 80
100853: AND
100854: IFFALSE 100947
100856: GO 100858
100858: DISABLE
100859: LD_INT 0
100861: PPUSH
// begin enable ;
100862: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100863: LD_ADDR_VAR 0 1
100867: PUSH
100868: LD_INT 22
100870: PUSH
100871: LD_OWVAR 2
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: PUSH
100880: LD_INT 2
100882: PUSH
100883: LD_INT 25
100885: PUSH
100886: LD_INT 5
100888: PUSH
100889: EMPTY
100890: LIST
100891: LIST
100892: PUSH
100893: LD_INT 25
100895: PUSH
100896: LD_INT 9
100898: PUSH
100899: EMPTY
100900: LIST
100901: LIST
100902: PUSH
100903: LD_INT 25
100905: PUSH
100906: LD_INT 8
100908: PUSH
100909: EMPTY
100910: LIST
100911: LIST
100912: PUSH
100913: EMPTY
100914: LIST
100915: LIST
100916: LIST
100917: LIST
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: PPUSH
100923: CALL_OW 69
100927: PUSH
100928: FOR_IN
100929: IFFALSE 100945
// begin SetClass ( i , 1 ) ;
100931: LD_VAR 0 1
100935: PPUSH
100936: LD_INT 1
100938: PPUSH
100939: CALL_OW 336
// end ;
100943: GO 100928
100945: POP
100946: POP
// end ;
100947: PPOPN 1
100949: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100950: LD_EXP 77
100954: IFFALSE 100962
100956: PUSH
100957: LD_EXP 81
100961: AND
100962: IFFALSE 100974
100964: PUSH
100965: LD_OWVAR 65
100969: PUSH
100970: LD_INT 7
100972: LESS
100973: AND
100974: IFFALSE 100988
100976: GO 100978
100978: DISABLE
// begin enable ;
100979: ENABLE
// game_speed := 7 ;
100980: LD_ADDR_OWVAR 65
100984: PUSH
100985: LD_INT 7
100987: ST_TO_ADDR
// end ;
100988: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100989: LD_EXP 77
100993: IFFALSE 101001
100995: PUSH
100996: LD_EXP 84
101000: AND
101001: IFFALSE 101203
101003: GO 101005
101005: DISABLE
101006: LD_INT 0
101008: PPUSH
101009: PPUSH
101010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101011: LD_ADDR_VAR 0 3
101015: PUSH
101016: LD_INT 81
101018: PUSH
101019: LD_OWVAR 2
101023: PUSH
101024: EMPTY
101025: LIST
101026: LIST
101027: PUSH
101028: LD_INT 21
101030: PUSH
101031: LD_INT 1
101033: PUSH
101034: EMPTY
101035: LIST
101036: LIST
101037: PUSH
101038: EMPTY
101039: LIST
101040: LIST
101041: PPUSH
101042: CALL_OW 69
101046: ST_TO_ADDR
// if not tmp then
101047: LD_VAR 0 3
101051: NOT
101052: IFFALSE 101056
// exit ;
101054: GO 101203
// if tmp > 5 then
101056: LD_VAR 0 3
101060: PUSH
101061: LD_INT 5
101063: GREATER
101064: IFFALSE 101076
// k := 5 else
101066: LD_ADDR_VAR 0 2
101070: PUSH
101071: LD_INT 5
101073: ST_TO_ADDR
101074: GO 101086
// k := tmp ;
101076: LD_ADDR_VAR 0 2
101080: PUSH
101081: LD_VAR 0 3
101085: ST_TO_ADDR
// for i := 1 to k do
101086: LD_ADDR_VAR 0 1
101090: PUSH
101091: DOUBLE
101092: LD_INT 1
101094: DEC
101095: ST_TO_ADDR
101096: LD_VAR 0 2
101100: PUSH
101101: FOR_TO
101102: IFFALSE 101201
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101104: LD_VAR 0 3
101108: PUSH
101109: LD_VAR 0 1
101113: ARRAY
101114: PPUSH
101115: LD_VAR 0 1
101119: PUSH
101120: LD_INT 4
101122: MOD
101123: PUSH
101124: LD_INT 1
101126: PLUS
101127: PPUSH
101128: CALL_OW 259
101132: PUSH
101133: LD_INT 10
101135: LESS
101136: IFFALSE 101199
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101138: LD_VAR 0 3
101142: PUSH
101143: LD_VAR 0 1
101147: ARRAY
101148: PPUSH
101149: LD_VAR 0 1
101153: PUSH
101154: LD_INT 4
101156: MOD
101157: PUSH
101158: LD_INT 1
101160: PLUS
101161: PPUSH
101162: LD_VAR 0 3
101166: PUSH
101167: LD_VAR 0 1
101171: ARRAY
101172: PPUSH
101173: LD_VAR 0 1
101177: PUSH
101178: LD_INT 4
101180: MOD
101181: PUSH
101182: LD_INT 1
101184: PLUS
101185: PPUSH
101186: CALL_OW 259
101190: PUSH
101191: LD_INT 1
101193: PLUS
101194: PPUSH
101195: CALL_OW 237
101199: GO 101101
101201: POP
101202: POP
// end ;
101203: PPOPN 3
101205: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101206: LD_EXP 77
101210: IFFALSE 101218
101212: PUSH
101213: LD_EXP 85
101217: AND
101218: IFFALSE 101238
101220: GO 101222
101222: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101223: LD_INT 4
101225: PPUSH
101226: LD_OWVAR 2
101230: PPUSH
101231: LD_INT 0
101233: PPUSH
101234: CALL_OW 324
101238: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101239: LD_EXP 77
101243: IFFALSE 101251
101245: PUSH
101246: LD_EXP 114
101250: AND
101251: IFFALSE 101271
101253: GO 101255
101255: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101256: LD_INT 19
101258: PPUSH
101259: LD_OWVAR 2
101263: PPUSH
101264: LD_INT 0
101266: PPUSH
101267: CALL_OW 324
101271: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101272: LD_EXP 77
101276: IFFALSE 101284
101278: PUSH
101279: LD_EXP 86
101283: AND
101284: IFFALSE 101386
101286: GO 101288
101288: DISABLE
101289: LD_INT 0
101291: PPUSH
101292: PPUSH
// begin enable ;
101293: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101294: LD_ADDR_VAR 0 2
101298: PUSH
101299: LD_INT 22
101301: PUSH
101302: LD_OWVAR 2
101306: PUSH
101307: EMPTY
101308: LIST
101309: LIST
101310: PUSH
101311: LD_INT 2
101313: PUSH
101314: LD_INT 34
101316: PUSH
101317: LD_INT 11
101319: PUSH
101320: EMPTY
101321: LIST
101322: LIST
101323: PUSH
101324: LD_INT 34
101326: PUSH
101327: LD_INT 30
101329: PUSH
101330: EMPTY
101331: LIST
101332: LIST
101333: PUSH
101334: EMPTY
101335: LIST
101336: LIST
101337: LIST
101338: PUSH
101339: EMPTY
101340: LIST
101341: LIST
101342: PPUSH
101343: CALL_OW 69
101347: ST_TO_ADDR
// if not tmp then
101348: LD_VAR 0 2
101352: NOT
101353: IFFALSE 101357
// exit ;
101355: GO 101386
// for i in tmp do
101357: LD_ADDR_VAR 0 1
101361: PUSH
101362: LD_VAR 0 2
101366: PUSH
101367: FOR_IN
101368: IFFALSE 101384
// begin SetLives ( i , 0 ) ;
101370: LD_VAR 0 1
101374: PPUSH
101375: LD_INT 0
101377: PPUSH
101378: CALL_OW 234
// end ;
101382: GO 101367
101384: POP
101385: POP
// end ;
101386: PPOPN 2
101388: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101389: LD_EXP 77
101393: IFFALSE 101401
101395: PUSH
101396: LD_EXP 87
101400: AND
101401: IFFALSE 101421
101403: GO 101405
101405: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101406: LD_INT 32
101408: PPUSH
101409: LD_OWVAR 2
101413: PPUSH
101414: LD_INT 0
101416: PPUSH
101417: CALL_OW 324
101421: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101422: LD_EXP 77
101426: IFFALSE 101434
101428: PUSH
101429: LD_EXP 88
101433: AND
101434: IFFALSE 101617
101436: GO 101438
101438: DISABLE
101439: LD_INT 0
101441: PPUSH
101442: PPUSH
101443: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101444: LD_ADDR_VAR 0 2
101448: PUSH
101449: LD_INT 22
101451: PUSH
101452: LD_OWVAR 2
101456: PUSH
101457: EMPTY
101458: LIST
101459: LIST
101460: PUSH
101461: LD_INT 33
101463: PUSH
101464: LD_INT 3
101466: PUSH
101467: EMPTY
101468: LIST
101469: LIST
101470: PUSH
101471: EMPTY
101472: LIST
101473: LIST
101474: PPUSH
101475: CALL_OW 69
101479: ST_TO_ADDR
// if not tmp then
101480: LD_VAR 0 2
101484: NOT
101485: IFFALSE 101489
// exit ;
101487: GO 101617
// side := 0 ;
101489: LD_ADDR_VAR 0 3
101493: PUSH
101494: LD_INT 0
101496: ST_TO_ADDR
// for i := 1 to 8 do
101497: LD_ADDR_VAR 0 1
101501: PUSH
101502: DOUBLE
101503: LD_INT 1
101505: DEC
101506: ST_TO_ADDR
101507: LD_INT 8
101509: PUSH
101510: FOR_TO
101511: IFFALSE 101561
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101513: LD_OWVAR 2
101517: PUSH
101518: LD_VAR 0 1
101522: NONEQUAL
101523: IFFALSE 101545
101525: PUSH
101526: LD_OWVAR 2
101530: PPUSH
101531: LD_VAR 0 1
101535: PPUSH
101536: CALL_OW 81
101540: PUSH
101541: LD_INT 2
101543: EQUAL
101544: AND
101545: IFFALSE 101559
// begin side := i ;
101547: LD_ADDR_VAR 0 3
101551: PUSH
101552: LD_VAR 0 1
101556: ST_TO_ADDR
// break ;
101557: GO 101561
// end ;
101559: GO 101510
101561: POP
101562: POP
// if not side then
101563: LD_VAR 0 3
101567: NOT
101568: IFFALSE 101572
// exit ;
101570: GO 101617
// for i := 1 to tmp do
101572: LD_ADDR_VAR 0 1
101576: PUSH
101577: DOUBLE
101578: LD_INT 1
101580: DEC
101581: ST_TO_ADDR
101582: LD_VAR 0 2
101586: PUSH
101587: FOR_TO
101588: IFFALSE 101615
// if Prob ( 60 ) then
101590: LD_INT 60
101592: PPUSH
101593: CALL_OW 13
101597: IFFALSE 101613
// SetSide ( i , side ) ;
101599: LD_VAR 0 1
101603: PPUSH
101604: LD_VAR 0 3
101608: PPUSH
101609: CALL_OW 235
101613: GO 101587
101615: POP
101616: POP
// end ;
101617: PPOPN 3
101619: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101620: LD_EXP 77
101624: IFFALSE 101632
101626: PUSH
101627: LD_EXP 90
101631: AND
101632: IFFALSE 101751
101634: GO 101636
101636: DISABLE
101637: LD_INT 0
101639: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101640: LD_ADDR_VAR 0 1
101644: PUSH
101645: LD_INT 22
101647: PUSH
101648: LD_OWVAR 2
101652: PUSH
101653: EMPTY
101654: LIST
101655: LIST
101656: PUSH
101657: LD_INT 21
101659: PUSH
101660: LD_INT 1
101662: PUSH
101663: EMPTY
101664: LIST
101665: LIST
101666: PUSH
101667: LD_INT 3
101669: PUSH
101670: LD_INT 23
101672: PUSH
101673: LD_INT 0
101675: PUSH
101676: EMPTY
101677: LIST
101678: LIST
101679: PUSH
101680: EMPTY
101681: LIST
101682: LIST
101683: PUSH
101684: EMPTY
101685: LIST
101686: LIST
101687: LIST
101688: PPUSH
101689: CALL_OW 69
101693: PUSH
101694: FOR_IN
101695: IFFALSE 101749
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101697: LD_VAR 0 1
101701: PPUSH
101702: CALL_OW 257
101706: PUSH
101707: LD_INT 1
101709: PUSH
101710: LD_INT 2
101712: PUSH
101713: LD_INT 3
101715: PUSH
101716: LD_INT 4
101718: PUSH
101719: EMPTY
101720: LIST
101721: LIST
101722: LIST
101723: LIST
101724: IN
101725: IFFALSE 101747
// SetClass ( un , rand ( 1 , 4 ) ) ;
101727: LD_VAR 0 1
101731: PPUSH
101732: LD_INT 1
101734: PPUSH
101735: LD_INT 4
101737: PPUSH
101738: CALL_OW 12
101742: PPUSH
101743: CALL_OW 336
101747: GO 101694
101749: POP
101750: POP
// end ;
101751: PPOPN 1
101753: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101754: LD_EXP 77
101758: IFFALSE 101766
101760: PUSH
101761: LD_EXP 89
101765: AND
101766: IFFALSE 101845
101768: GO 101770
101770: DISABLE
101771: LD_INT 0
101773: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101774: LD_ADDR_VAR 0 1
101778: PUSH
101779: LD_INT 22
101781: PUSH
101782: LD_OWVAR 2
101786: PUSH
101787: EMPTY
101788: LIST
101789: LIST
101790: PUSH
101791: LD_INT 21
101793: PUSH
101794: LD_INT 3
101796: PUSH
101797: EMPTY
101798: LIST
101799: LIST
101800: PUSH
101801: EMPTY
101802: LIST
101803: LIST
101804: PPUSH
101805: CALL_OW 69
101809: ST_TO_ADDR
// if not tmp then
101810: LD_VAR 0 1
101814: NOT
101815: IFFALSE 101819
// exit ;
101817: GO 101845
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101819: LD_VAR 0 1
101823: PUSH
101824: LD_INT 1
101826: PPUSH
101827: LD_VAR 0 1
101831: PPUSH
101832: CALL_OW 12
101836: ARRAY
101837: PPUSH
101838: LD_INT 100
101840: PPUSH
101841: CALL_OW 234
// end ;
101845: PPOPN 1
101847: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101848: LD_EXP 77
101852: IFFALSE 101860
101854: PUSH
101855: LD_EXP 91
101859: AND
101860: IFFALSE 101958
101862: GO 101864
101864: DISABLE
101865: LD_INT 0
101867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101868: LD_ADDR_VAR 0 1
101872: PUSH
101873: LD_INT 22
101875: PUSH
101876: LD_OWVAR 2
101880: PUSH
101881: EMPTY
101882: LIST
101883: LIST
101884: PUSH
101885: LD_INT 21
101887: PUSH
101888: LD_INT 1
101890: PUSH
101891: EMPTY
101892: LIST
101893: LIST
101894: PUSH
101895: EMPTY
101896: LIST
101897: LIST
101898: PPUSH
101899: CALL_OW 69
101903: ST_TO_ADDR
// if not tmp then
101904: LD_VAR 0 1
101908: NOT
101909: IFFALSE 101913
// exit ;
101911: GO 101958
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101913: LD_VAR 0 1
101917: PUSH
101918: LD_INT 1
101920: PPUSH
101921: LD_VAR 0 1
101925: PPUSH
101926: CALL_OW 12
101930: ARRAY
101931: PPUSH
101932: LD_INT 1
101934: PPUSH
101935: LD_INT 4
101937: PPUSH
101938: CALL_OW 12
101942: PPUSH
101943: LD_INT 3000
101945: PPUSH
101946: LD_INT 9000
101948: PPUSH
101949: CALL_OW 12
101953: PPUSH
101954: CALL_OW 492
// end ;
101958: PPOPN 1
101960: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101961: LD_EXP 77
101965: IFFALSE 101973
101967: PUSH
101968: LD_EXP 92
101972: AND
101973: IFFALSE 101993
101975: GO 101977
101977: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101978: LD_INT 1
101980: PPUSH
101981: LD_OWVAR 2
101985: PPUSH
101986: LD_INT 0
101988: PPUSH
101989: CALL_OW 324
101993: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101994: LD_EXP 77
101998: IFFALSE 102006
102000: PUSH
102001: LD_EXP 93
102005: AND
102006: IFFALSE 102089
102008: GO 102010
102010: DISABLE
102011: LD_INT 0
102013: PPUSH
102014: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102015: LD_ADDR_VAR 0 2
102019: PUSH
102020: LD_INT 22
102022: PUSH
102023: LD_OWVAR 2
102027: PUSH
102028: EMPTY
102029: LIST
102030: LIST
102031: PUSH
102032: LD_INT 21
102034: PUSH
102035: LD_INT 3
102037: PUSH
102038: EMPTY
102039: LIST
102040: LIST
102041: PUSH
102042: EMPTY
102043: LIST
102044: LIST
102045: PPUSH
102046: CALL_OW 69
102050: ST_TO_ADDR
// if not tmp then
102051: LD_VAR 0 2
102055: NOT
102056: IFFALSE 102060
// exit ;
102058: GO 102089
// for i in tmp do
102060: LD_ADDR_VAR 0 1
102064: PUSH
102065: LD_VAR 0 2
102069: PUSH
102070: FOR_IN
102071: IFFALSE 102087
// SetBLevel ( i , 10 ) ;
102073: LD_VAR 0 1
102077: PPUSH
102078: LD_INT 10
102080: PPUSH
102081: CALL_OW 241
102085: GO 102070
102087: POP
102088: POP
// end ;
102089: PPOPN 2
102091: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102092: LD_EXP 77
102096: IFFALSE 102104
102098: PUSH
102099: LD_EXP 94
102103: AND
102104: IFFALSE 102215
102106: GO 102108
102108: DISABLE
102109: LD_INT 0
102111: PPUSH
102112: PPUSH
102113: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102114: LD_ADDR_VAR 0 3
102118: PUSH
102119: LD_INT 22
102121: PUSH
102122: LD_OWVAR 2
102126: PUSH
102127: EMPTY
102128: LIST
102129: LIST
102130: PUSH
102131: LD_INT 25
102133: PUSH
102134: LD_INT 1
102136: PUSH
102137: EMPTY
102138: LIST
102139: LIST
102140: PUSH
102141: EMPTY
102142: LIST
102143: LIST
102144: PPUSH
102145: CALL_OW 69
102149: ST_TO_ADDR
// if not tmp then
102150: LD_VAR 0 3
102154: NOT
102155: IFFALSE 102159
// exit ;
102157: GO 102215
// un := tmp [ rand ( 1 , tmp ) ] ;
102159: LD_ADDR_VAR 0 2
102163: PUSH
102164: LD_VAR 0 3
102168: PUSH
102169: LD_INT 1
102171: PPUSH
102172: LD_VAR 0 3
102176: PPUSH
102177: CALL_OW 12
102181: ARRAY
102182: ST_TO_ADDR
// if Crawls ( un ) then
102183: LD_VAR 0 2
102187: PPUSH
102188: CALL_OW 318
102192: IFFALSE 102203
// ComWalk ( un ) ;
102194: LD_VAR 0 2
102198: PPUSH
102199: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102203: LD_VAR 0 2
102207: PPUSH
102208: LD_INT 5
102210: PPUSH
102211: CALL_OW 336
// end ;
102215: PPOPN 3
102217: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102218: LD_EXP 77
102222: IFFALSE 102230
102224: PUSH
102225: LD_EXP 95
102229: AND
102230: IFFALSE 102242
102232: PUSH
102233: LD_OWVAR 67
102237: PUSH
102238: LD_INT 4
102240: LESS
102241: AND
102242: IFFALSE 102261
102244: GO 102246
102246: DISABLE
// begin Difficulty := Difficulty + 1 ;
102247: LD_ADDR_OWVAR 67
102251: PUSH
102252: LD_OWVAR 67
102256: PUSH
102257: LD_INT 1
102259: PLUS
102260: ST_TO_ADDR
// end ;
102261: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102262: LD_EXP 77
102266: IFFALSE 102274
102268: PUSH
102269: LD_EXP 96
102273: AND
102274: IFFALSE 102377
102276: GO 102278
102278: DISABLE
102279: LD_INT 0
102281: PPUSH
// begin for i := 1 to 5 do
102282: LD_ADDR_VAR 0 1
102286: PUSH
102287: DOUBLE
102288: LD_INT 1
102290: DEC
102291: ST_TO_ADDR
102292: LD_INT 5
102294: PUSH
102295: FOR_TO
102296: IFFALSE 102375
// begin uc_nation := nation_nature ;
102298: LD_ADDR_OWVAR 21
102302: PUSH
102303: LD_INT 0
102305: ST_TO_ADDR
// uc_side := 0 ;
102306: LD_ADDR_OWVAR 20
102310: PUSH
102311: LD_INT 0
102313: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102314: LD_ADDR_OWVAR 29
102318: PUSH
102319: LD_INT 12
102321: PUSH
102322: LD_INT 12
102324: PUSH
102325: EMPTY
102326: LIST
102327: LIST
102328: ST_TO_ADDR
// hc_agressivity := 20 ;
102329: LD_ADDR_OWVAR 35
102333: PUSH
102334: LD_INT 20
102336: ST_TO_ADDR
// hc_class := class_tiger ;
102337: LD_ADDR_OWVAR 28
102341: PUSH
102342: LD_INT 14
102344: ST_TO_ADDR
// hc_gallery :=  ;
102345: LD_ADDR_OWVAR 33
102349: PUSH
102350: LD_STRING 
102352: ST_TO_ADDR
// hc_name :=  ;
102353: LD_ADDR_OWVAR 26
102357: PUSH
102358: LD_STRING 
102360: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102361: CALL_OW 44
102365: PPUSH
102366: LD_INT 0
102368: PPUSH
102369: CALL_OW 51
// end ;
102373: GO 102295
102375: POP
102376: POP
// end ;
102377: PPOPN 1
102379: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102380: LD_EXP 77
102384: IFFALSE 102392
102386: PUSH
102387: LD_EXP 97
102391: AND
102392: IFFALSE 102401
102394: GO 102396
102396: DISABLE
// StreamSibBomb ;
102397: CALL 102402 0 0
102401: END
// export function StreamSibBomb ; var i , x , y ; begin
102402: LD_INT 0
102404: PPUSH
102405: PPUSH
102406: PPUSH
102407: PPUSH
// result := false ;
102408: LD_ADDR_VAR 0 1
102412: PUSH
102413: LD_INT 0
102415: ST_TO_ADDR
// for i := 1 to 16 do
102416: LD_ADDR_VAR 0 2
102420: PUSH
102421: DOUBLE
102422: LD_INT 1
102424: DEC
102425: ST_TO_ADDR
102426: LD_INT 16
102428: PUSH
102429: FOR_TO
102430: IFFALSE 102629
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102432: LD_ADDR_VAR 0 3
102436: PUSH
102437: LD_INT 10
102439: PUSH
102440: LD_INT 20
102442: PUSH
102443: LD_INT 30
102445: PUSH
102446: LD_INT 40
102448: PUSH
102449: LD_INT 50
102451: PUSH
102452: LD_INT 60
102454: PUSH
102455: LD_INT 70
102457: PUSH
102458: LD_INT 80
102460: PUSH
102461: LD_INT 90
102463: PUSH
102464: LD_INT 100
102466: PUSH
102467: LD_INT 110
102469: PUSH
102470: LD_INT 120
102472: PUSH
102473: LD_INT 130
102475: PUSH
102476: LD_INT 140
102478: PUSH
102479: LD_INT 150
102481: PUSH
102482: EMPTY
102483: LIST
102484: LIST
102485: LIST
102486: LIST
102487: LIST
102488: LIST
102489: LIST
102490: LIST
102491: LIST
102492: LIST
102493: LIST
102494: LIST
102495: LIST
102496: LIST
102497: LIST
102498: PUSH
102499: LD_INT 1
102501: PPUSH
102502: LD_INT 15
102504: PPUSH
102505: CALL_OW 12
102509: ARRAY
102510: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102511: LD_ADDR_VAR 0 4
102515: PUSH
102516: LD_INT 10
102518: PUSH
102519: LD_INT 20
102521: PUSH
102522: LD_INT 30
102524: PUSH
102525: LD_INT 40
102527: PUSH
102528: LD_INT 50
102530: PUSH
102531: LD_INT 60
102533: PUSH
102534: LD_INT 70
102536: PUSH
102537: LD_INT 80
102539: PUSH
102540: LD_INT 90
102542: PUSH
102543: LD_INT 100
102545: PUSH
102546: LD_INT 110
102548: PUSH
102549: LD_INT 120
102551: PUSH
102552: LD_INT 130
102554: PUSH
102555: LD_INT 140
102557: PUSH
102558: LD_INT 150
102560: PUSH
102561: EMPTY
102562: LIST
102563: LIST
102564: LIST
102565: LIST
102566: LIST
102567: LIST
102568: LIST
102569: LIST
102570: LIST
102571: LIST
102572: LIST
102573: LIST
102574: LIST
102575: LIST
102576: LIST
102577: PUSH
102578: LD_INT 1
102580: PPUSH
102581: LD_INT 15
102583: PPUSH
102584: CALL_OW 12
102588: ARRAY
102589: ST_TO_ADDR
// if ValidHex ( x , y ) then
102590: LD_VAR 0 3
102594: PPUSH
102595: LD_VAR 0 4
102599: PPUSH
102600: CALL_OW 488
102604: IFFALSE 102627
// begin result := [ x , y ] ;
102606: LD_ADDR_VAR 0 1
102610: PUSH
102611: LD_VAR 0 3
102615: PUSH
102616: LD_VAR 0 4
102620: PUSH
102621: EMPTY
102622: LIST
102623: LIST
102624: ST_TO_ADDR
// break ;
102625: GO 102629
// end ; end ;
102627: GO 102429
102629: POP
102630: POP
// if result then
102631: LD_VAR 0 1
102635: IFFALSE 102695
// begin ToLua ( playSibBomb() ) ;
102637: LD_STRING playSibBomb()
102639: PPUSH
102640: CALL_OW 559
// wait ( 0 0$14 ) ;
102644: LD_INT 490
102646: PPUSH
102647: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102651: LD_VAR 0 1
102655: PUSH
102656: LD_INT 1
102658: ARRAY
102659: PPUSH
102660: LD_VAR 0 1
102664: PUSH
102665: LD_INT 2
102667: ARRAY
102668: PPUSH
102669: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102673: LD_VAR 0 1
102677: PUSH
102678: LD_INT 1
102680: ARRAY
102681: PPUSH
102682: LD_VAR 0 1
102686: PUSH
102687: LD_INT 2
102689: ARRAY
102690: PPUSH
102691: CALL_OW 429
// end ; end ;
102695: LD_VAR 0 1
102699: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102700: LD_EXP 77
102704: IFFALSE 102712
102706: PUSH
102707: LD_EXP 99
102711: AND
102712: IFFALSE 102724
102714: GO 102716
102716: DISABLE
// YouLost (  ) ;
102717: LD_STRING 
102719: PPUSH
102720: CALL_OW 104
102724: END
// every 0 0$1 trigger StreamModeActive and sFog do
102725: LD_EXP 77
102729: IFFALSE 102737
102731: PUSH
102732: LD_EXP 98
102736: AND
102737: IFFALSE 102751
102739: GO 102741
102741: DISABLE
// FogOff ( your_side ) ;
102742: LD_OWVAR 2
102746: PPUSH
102747: CALL_OW 344
102751: END
// every 0 0$1 trigger StreamModeActive and sSun do
102752: LD_EXP 77
102756: IFFALSE 102764
102758: PUSH
102759: LD_EXP 100
102763: AND
102764: IFFALSE 102792
102766: GO 102768
102768: DISABLE
// begin solar_recharge_percent := 0 ;
102769: LD_ADDR_OWVAR 79
102773: PUSH
102774: LD_INT 0
102776: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102777: LD_INT 10500
102779: PPUSH
102780: CALL_OW 67
// solar_recharge_percent := 100 ;
102784: LD_ADDR_OWVAR 79
102788: PUSH
102789: LD_INT 100
102791: ST_TO_ADDR
// end ;
102792: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102793: LD_EXP 77
102797: IFFALSE 102805
102799: PUSH
102800: LD_EXP 101
102804: AND
102805: IFFALSE 103044
102807: GO 102809
102809: DISABLE
102810: LD_INT 0
102812: PPUSH
102813: PPUSH
102814: PPUSH
// begin tmp := [ ] ;
102815: LD_ADDR_VAR 0 3
102819: PUSH
102820: EMPTY
102821: ST_TO_ADDR
// for i := 1 to 6 do
102822: LD_ADDR_VAR 0 1
102826: PUSH
102827: DOUBLE
102828: LD_INT 1
102830: DEC
102831: ST_TO_ADDR
102832: LD_INT 6
102834: PUSH
102835: FOR_TO
102836: IFFALSE 102941
// begin uc_nation := nation_nature ;
102838: LD_ADDR_OWVAR 21
102842: PUSH
102843: LD_INT 0
102845: ST_TO_ADDR
// uc_side := 0 ;
102846: LD_ADDR_OWVAR 20
102850: PUSH
102851: LD_INT 0
102853: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102854: LD_ADDR_OWVAR 29
102858: PUSH
102859: LD_INT 12
102861: PUSH
102862: LD_INT 12
102864: PUSH
102865: EMPTY
102866: LIST
102867: LIST
102868: ST_TO_ADDR
// hc_agressivity := 20 ;
102869: LD_ADDR_OWVAR 35
102873: PUSH
102874: LD_INT 20
102876: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102877: LD_ADDR_OWVAR 28
102881: PUSH
102882: LD_INT 17
102884: ST_TO_ADDR
// hc_gallery :=  ;
102885: LD_ADDR_OWVAR 33
102889: PUSH
102890: LD_STRING 
102892: ST_TO_ADDR
// hc_name :=  ;
102893: LD_ADDR_OWVAR 26
102897: PUSH
102898: LD_STRING 
102900: ST_TO_ADDR
// un := CreateHuman ;
102901: LD_ADDR_VAR 0 2
102905: PUSH
102906: CALL_OW 44
102910: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102911: LD_VAR 0 2
102915: PPUSH
102916: LD_INT 1
102918: PPUSH
102919: CALL_OW 51
// tmp := tmp ^ un ;
102923: LD_ADDR_VAR 0 3
102927: PUSH
102928: LD_VAR 0 3
102932: PUSH
102933: LD_VAR 0 2
102937: ADD
102938: ST_TO_ADDR
// end ;
102939: GO 102835
102941: POP
102942: POP
// repeat wait ( 0 0$1 ) ;
102943: LD_INT 35
102945: PPUSH
102946: CALL_OW 67
// for un in tmp do
102950: LD_ADDR_VAR 0 2
102954: PUSH
102955: LD_VAR 0 3
102959: PUSH
102960: FOR_IN
102961: IFFALSE 103035
// begin if IsDead ( un ) then
102963: LD_VAR 0 2
102967: PPUSH
102968: CALL_OW 301
102972: IFFALSE 102992
// begin tmp := tmp diff un ;
102974: LD_ADDR_VAR 0 3
102978: PUSH
102979: LD_VAR 0 3
102983: PUSH
102984: LD_VAR 0 2
102988: DIFF
102989: ST_TO_ADDR
// continue ;
102990: GO 102960
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102992: LD_VAR 0 2
102996: PPUSH
102997: LD_INT 3
102999: PUSH
103000: LD_INT 22
103002: PUSH
103003: LD_INT 0
103005: PUSH
103006: EMPTY
103007: LIST
103008: LIST
103009: PUSH
103010: EMPTY
103011: LIST
103012: LIST
103013: PPUSH
103014: CALL_OW 69
103018: PPUSH
103019: LD_VAR 0 2
103023: PPUSH
103024: CALL_OW 74
103028: PPUSH
103029: CALL_OW 115
// end ;
103033: GO 102960
103035: POP
103036: POP
// until not tmp ;
103037: LD_VAR 0 3
103041: NOT
103042: IFFALSE 102943
// end ;
103044: PPOPN 3
103046: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103047: LD_EXP 77
103051: IFFALSE 103059
103053: PUSH
103054: LD_EXP 102
103058: AND
103059: IFFALSE 103113
103061: GO 103063
103063: DISABLE
// begin ToLua ( displayTroll(); ) ;
103064: LD_STRING displayTroll();
103066: PPUSH
103067: CALL_OW 559
// wait ( 3 3$00 ) ;
103071: LD_INT 6300
103073: PPUSH
103074: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103078: LD_STRING hideTroll();
103080: PPUSH
103081: CALL_OW 559
// wait ( 1 1$00 ) ;
103085: LD_INT 2100
103087: PPUSH
103088: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103092: LD_STRING displayTroll();
103094: PPUSH
103095: CALL_OW 559
// wait ( 1 1$00 ) ;
103099: LD_INT 2100
103101: PPUSH
103102: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103106: LD_STRING hideTroll();
103108: PPUSH
103109: CALL_OW 559
// end ;
103113: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103114: LD_EXP 77
103118: IFFALSE 103126
103120: PUSH
103121: LD_EXP 103
103125: AND
103126: IFFALSE 103189
103128: GO 103130
103130: DISABLE
103131: LD_INT 0
103133: PPUSH
// begin p := 0 ;
103134: LD_ADDR_VAR 0 1
103138: PUSH
103139: LD_INT 0
103141: ST_TO_ADDR
// repeat game_speed := 1 ;
103142: LD_ADDR_OWVAR 65
103146: PUSH
103147: LD_INT 1
103149: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103150: LD_INT 35
103152: PPUSH
103153: CALL_OW 67
// p := p + 1 ;
103157: LD_ADDR_VAR 0 1
103161: PUSH
103162: LD_VAR 0 1
103166: PUSH
103167: LD_INT 1
103169: PLUS
103170: ST_TO_ADDR
// until p >= 60 ;
103171: LD_VAR 0 1
103175: PUSH
103176: LD_INT 60
103178: GREATEREQUAL
103179: IFFALSE 103142
// game_speed := 4 ;
103181: LD_ADDR_OWVAR 65
103185: PUSH
103186: LD_INT 4
103188: ST_TO_ADDR
// end ;
103189: PPOPN 1
103191: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103192: LD_EXP 77
103196: IFFALSE 103204
103198: PUSH
103199: LD_EXP 104
103203: AND
103204: IFFALSE 103350
103206: GO 103208
103208: DISABLE
103209: LD_INT 0
103211: PPUSH
103212: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103213: LD_ADDR_VAR 0 1
103217: PUSH
103218: LD_INT 22
103220: PUSH
103221: LD_OWVAR 2
103225: PUSH
103226: EMPTY
103227: LIST
103228: LIST
103229: PUSH
103230: LD_INT 2
103232: PUSH
103233: LD_INT 30
103235: PUSH
103236: LD_INT 0
103238: PUSH
103239: EMPTY
103240: LIST
103241: LIST
103242: PUSH
103243: LD_INT 30
103245: PUSH
103246: LD_INT 1
103248: PUSH
103249: EMPTY
103250: LIST
103251: LIST
103252: PUSH
103253: EMPTY
103254: LIST
103255: LIST
103256: LIST
103257: PUSH
103258: EMPTY
103259: LIST
103260: LIST
103261: PPUSH
103262: CALL_OW 69
103266: ST_TO_ADDR
// if not depot then
103267: LD_VAR 0 1
103271: NOT
103272: IFFALSE 103276
// exit ;
103274: GO 103350
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103276: LD_ADDR_VAR 0 2
103280: PUSH
103281: LD_VAR 0 1
103285: PUSH
103286: LD_INT 1
103288: PPUSH
103289: LD_VAR 0 1
103293: PPUSH
103294: CALL_OW 12
103298: ARRAY
103299: PPUSH
103300: CALL_OW 274
103304: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103305: LD_VAR 0 2
103309: PPUSH
103310: LD_INT 1
103312: PPUSH
103313: LD_INT 0
103315: PPUSH
103316: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103320: LD_VAR 0 2
103324: PPUSH
103325: LD_INT 2
103327: PPUSH
103328: LD_INT 0
103330: PPUSH
103331: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103335: LD_VAR 0 2
103339: PPUSH
103340: LD_INT 3
103342: PPUSH
103343: LD_INT 0
103345: PPUSH
103346: CALL_OW 277
// end ;
103350: PPOPN 2
103352: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103353: LD_EXP 77
103357: IFFALSE 103365
103359: PUSH
103360: LD_EXP 105
103364: AND
103365: IFFALSE 103462
103367: GO 103369
103369: DISABLE
103370: LD_INT 0
103372: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103373: LD_ADDR_VAR 0 1
103377: PUSH
103378: LD_INT 22
103380: PUSH
103381: LD_OWVAR 2
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: PUSH
103390: LD_INT 21
103392: PUSH
103393: LD_INT 1
103395: PUSH
103396: EMPTY
103397: LIST
103398: LIST
103399: PUSH
103400: LD_INT 3
103402: PUSH
103403: LD_INT 23
103405: PUSH
103406: LD_INT 0
103408: PUSH
103409: EMPTY
103410: LIST
103411: LIST
103412: PUSH
103413: EMPTY
103414: LIST
103415: LIST
103416: PUSH
103417: EMPTY
103418: LIST
103419: LIST
103420: LIST
103421: PPUSH
103422: CALL_OW 69
103426: ST_TO_ADDR
// if not tmp then
103427: LD_VAR 0 1
103431: NOT
103432: IFFALSE 103436
// exit ;
103434: GO 103462
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103436: LD_VAR 0 1
103440: PUSH
103441: LD_INT 1
103443: PPUSH
103444: LD_VAR 0 1
103448: PPUSH
103449: CALL_OW 12
103453: ARRAY
103454: PPUSH
103455: LD_INT 200
103457: PPUSH
103458: CALL_OW 234
// end ;
103462: PPOPN 1
103464: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103465: LD_EXP 77
103469: IFFALSE 103477
103471: PUSH
103472: LD_EXP 106
103476: AND
103477: IFFALSE 103556
103479: GO 103481
103481: DISABLE
103482: LD_INT 0
103484: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103485: LD_ADDR_VAR 0 1
103489: PUSH
103490: LD_INT 22
103492: PUSH
103493: LD_OWVAR 2
103497: PUSH
103498: EMPTY
103499: LIST
103500: LIST
103501: PUSH
103502: LD_INT 21
103504: PUSH
103505: LD_INT 2
103507: PUSH
103508: EMPTY
103509: LIST
103510: LIST
103511: PUSH
103512: EMPTY
103513: LIST
103514: LIST
103515: PPUSH
103516: CALL_OW 69
103520: ST_TO_ADDR
// if not tmp then
103521: LD_VAR 0 1
103525: NOT
103526: IFFALSE 103530
// exit ;
103528: GO 103556
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103530: LD_VAR 0 1
103534: PUSH
103535: LD_INT 1
103537: PPUSH
103538: LD_VAR 0 1
103542: PPUSH
103543: CALL_OW 12
103547: ARRAY
103548: PPUSH
103549: LD_INT 60
103551: PPUSH
103552: CALL_OW 234
// end ;
103556: PPOPN 1
103558: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103559: LD_EXP 77
103563: IFFALSE 103571
103565: PUSH
103566: LD_EXP 107
103570: AND
103571: IFFALSE 103670
103573: GO 103575
103575: DISABLE
103576: LD_INT 0
103578: PPUSH
103579: PPUSH
// begin enable ;
103580: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103581: LD_ADDR_VAR 0 1
103585: PUSH
103586: LD_INT 22
103588: PUSH
103589: LD_OWVAR 2
103593: PUSH
103594: EMPTY
103595: LIST
103596: LIST
103597: PUSH
103598: LD_INT 61
103600: PUSH
103601: EMPTY
103602: LIST
103603: PUSH
103604: LD_INT 33
103606: PUSH
103607: LD_INT 2
103609: PUSH
103610: EMPTY
103611: LIST
103612: LIST
103613: PUSH
103614: EMPTY
103615: LIST
103616: LIST
103617: LIST
103618: PPUSH
103619: CALL_OW 69
103623: ST_TO_ADDR
// if not tmp then
103624: LD_VAR 0 1
103628: NOT
103629: IFFALSE 103633
// exit ;
103631: GO 103670
// for i in tmp do
103633: LD_ADDR_VAR 0 2
103637: PUSH
103638: LD_VAR 0 1
103642: PUSH
103643: FOR_IN
103644: IFFALSE 103668
// if IsControledBy ( i ) then
103646: LD_VAR 0 2
103650: PPUSH
103651: CALL_OW 312
103655: IFFALSE 103666
// ComUnlink ( i ) ;
103657: LD_VAR 0 2
103661: PPUSH
103662: CALL_OW 136
103666: GO 103643
103668: POP
103669: POP
// end ;
103670: PPOPN 2
103672: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103673: LD_EXP 77
103677: IFFALSE 103685
103679: PUSH
103680: LD_EXP 108
103684: AND
103685: IFFALSE 103825
103687: GO 103689
103689: DISABLE
103690: LD_INT 0
103692: PPUSH
103693: PPUSH
// begin ToLua ( displayPowell(); ) ;
103694: LD_STRING displayPowell();
103696: PPUSH
103697: CALL_OW 559
// uc_side := 0 ;
103701: LD_ADDR_OWVAR 20
103705: PUSH
103706: LD_INT 0
103708: ST_TO_ADDR
// uc_nation := 2 ;
103709: LD_ADDR_OWVAR 21
103713: PUSH
103714: LD_INT 2
103716: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103717: LD_ADDR_OWVAR 37
103721: PUSH
103722: LD_INT 14
103724: ST_TO_ADDR
// vc_engine := engine_siberite ;
103725: LD_ADDR_OWVAR 39
103729: PUSH
103730: LD_INT 3
103732: ST_TO_ADDR
// vc_control := control_apeman ;
103733: LD_ADDR_OWVAR 38
103737: PUSH
103738: LD_INT 5
103740: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103741: LD_ADDR_OWVAR 40
103745: PUSH
103746: LD_INT 29
103748: ST_TO_ADDR
// un := CreateVehicle ;
103749: LD_ADDR_VAR 0 2
103753: PUSH
103754: CALL_OW 45
103758: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103759: LD_VAR 0 2
103763: PPUSH
103764: LD_INT 1
103766: PPUSH
103767: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103771: LD_INT 35
103773: PPUSH
103774: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103778: LD_VAR 0 2
103782: PPUSH
103783: LD_INT 22
103785: PUSH
103786: LD_OWVAR 2
103790: PUSH
103791: EMPTY
103792: LIST
103793: LIST
103794: PPUSH
103795: CALL_OW 69
103799: PPUSH
103800: LD_VAR 0 2
103804: PPUSH
103805: CALL_OW 74
103809: PPUSH
103810: CALL_OW 115
// until IsDead ( un ) ;
103814: LD_VAR 0 2
103818: PPUSH
103819: CALL_OW 301
103823: IFFALSE 103771
// end ;
103825: PPOPN 2
103827: END
// every 0 0$1 trigger StreamModeActive and sStu do
103828: LD_EXP 77
103832: IFFALSE 103840
103834: PUSH
103835: LD_EXP 116
103839: AND
103840: IFFALSE 103856
103842: GO 103844
103844: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103845: LD_STRING displayStucuk();
103847: PPUSH
103848: CALL_OW 559
// ResetFog ;
103852: CALL_OW 335
// end ;
103856: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103857: LD_EXP 77
103861: IFFALSE 103869
103863: PUSH
103864: LD_EXP 109
103868: AND
103869: IFFALSE 104010
103871: GO 103873
103873: DISABLE
103874: LD_INT 0
103876: PPUSH
103877: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103878: LD_ADDR_VAR 0 2
103882: PUSH
103883: LD_INT 22
103885: PUSH
103886: LD_OWVAR 2
103890: PUSH
103891: EMPTY
103892: LIST
103893: LIST
103894: PUSH
103895: LD_INT 21
103897: PUSH
103898: LD_INT 1
103900: PUSH
103901: EMPTY
103902: LIST
103903: LIST
103904: PUSH
103905: EMPTY
103906: LIST
103907: LIST
103908: PPUSH
103909: CALL_OW 69
103913: ST_TO_ADDR
// if not tmp then
103914: LD_VAR 0 2
103918: NOT
103919: IFFALSE 103923
// exit ;
103921: GO 104010
// un := tmp [ rand ( 1 , tmp ) ] ;
103923: LD_ADDR_VAR 0 1
103927: PUSH
103928: LD_VAR 0 2
103932: PUSH
103933: LD_INT 1
103935: PPUSH
103936: LD_VAR 0 2
103940: PPUSH
103941: CALL_OW 12
103945: ARRAY
103946: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103947: LD_VAR 0 1
103951: PPUSH
103952: LD_INT 0
103954: PPUSH
103955: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103959: LD_VAR 0 1
103963: PPUSH
103964: LD_OWVAR 3
103968: PUSH
103969: LD_VAR 0 1
103973: DIFF
103974: PPUSH
103975: LD_VAR 0 1
103979: PPUSH
103980: CALL_OW 74
103984: PPUSH
103985: CALL_OW 115
// wait ( 0 0$20 ) ;
103989: LD_INT 700
103991: PPUSH
103992: CALL_OW 67
// SetSide ( un , your_side ) ;
103996: LD_VAR 0 1
104000: PPUSH
104001: LD_OWVAR 2
104005: PPUSH
104006: CALL_OW 235
// end ;
104010: PPOPN 2
104012: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104013: LD_EXP 77
104017: IFFALSE 104025
104019: PUSH
104020: LD_EXP 110
104024: AND
104025: IFFALSE 104131
104027: GO 104029
104029: DISABLE
104030: LD_INT 0
104032: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104033: LD_ADDR_VAR 0 1
104037: PUSH
104038: LD_INT 22
104040: PUSH
104041: LD_OWVAR 2
104045: PUSH
104046: EMPTY
104047: LIST
104048: LIST
104049: PUSH
104050: LD_INT 2
104052: PUSH
104053: LD_INT 30
104055: PUSH
104056: LD_INT 0
104058: PUSH
104059: EMPTY
104060: LIST
104061: LIST
104062: PUSH
104063: LD_INT 30
104065: PUSH
104066: LD_INT 1
104068: PUSH
104069: EMPTY
104070: LIST
104071: LIST
104072: PUSH
104073: EMPTY
104074: LIST
104075: LIST
104076: LIST
104077: PUSH
104078: EMPTY
104079: LIST
104080: LIST
104081: PPUSH
104082: CALL_OW 69
104086: ST_TO_ADDR
// if not depot then
104087: LD_VAR 0 1
104091: NOT
104092: IFFALSE 104096
// exit ;
104094: GO 104131
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104096: LD_VAR 0 1
104100: PUSH
104101: LD_INT 1
104103: ARRAY
104104: PPUSH
104105: CALL_OW 250
104109: PPUSH
104110: LD_VAR 0 1
104114: PUSH
104115: LD_INT 1
104117: ARRAY
104118: PPUSH
104119: CALL_OW 251
104123: PPUSH
104124: LD_INT 70
104126: PPUSH
104127: CALL_OW 495
// end ;
104131: PPOPN 1
104133: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104134: LD_EXP 77
104138: IFFALSE 104146
104140: PUSH
104141: LD_EXP 111
104145: AND
104146: IFFALSE 104357
104148: GO 104150
104150: DISABLE
104151: LD_INT 0
104153: PPUSH
104154: PPUSH
104155: PPUSH
104156: PPUSH
104157: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104158: LD_ADDR_VAR 0 5
104162: PUSH
104163: LD_INT 22
104165: PUSH
104166: LD_OWVAR 2
104170: PUSH
104171: EMPTY
104172: LIST
104173: LIST
104174: PUSH
104175: LD_INT 21
104177: PUSH
104178: LD_INT 1
104180: PUSH
104181: EMPTY
104182: LIST
104183: LIST
104184: PUSH
104185: EMPTY
104186: LIST
104187: LIST
104188: PPUSH
104189: CALL_OW 69
104193: ST_TO_ADDR
// if not tmp then
104194: LD_VAR 0 5
104198: NOT
104199: IFFALSE 104203
// exit ;
104201: GO 104357
// for i in tmp do
104203: LD_ADDR_VAR 0 1
104207: PUSH
104208: LD_VAR 0 5
104212: PUSH
104213: FOR_IN
104214: IFFALSE 104355
// begin d := rand ( 0 , 5 ) ;
104216: LD_ADDR_VAR 0 4
104220: PUSH
104221: LD_INT 0
104223: PPUSH
104224: LD_INT 5
104226: PPUSH
104227: CALL_OW 12
104231: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104232: LD_ADDR_VAR 0 2
104236: PUSH
104237: LD_VAR 0 1
104241: PPUSH
104242: CALL_OW 250
104246: PPUSH
104247: LD_VAR 0 4
104251: PPUSH
104252: LD_INT 3
104254: PPUSH
104255: LD_INT 12
104257: PPUSH
104258: CALL_OW 12
104262: PPUSH
104263: CALL_OW 272
104267: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104268: LD_ADDR_VAR 0 3
104272: PUSH
104273: LD_VAR 0 1
104277: PPUSH
104278: CALL_OW 251
104282: PPUSH
104283: LD_VAR 0 4
104287: PPUSH
104288: LD_INT 3
104290: PPUSH
104291: LD_INT 12
104293: PPUSH
104294: CALL_OW 12
104298: PPUSH
104299: CALL_OW 273
104303: ST_TO_ADDR
// if ValidHex ( x , y ) then
104304: LD_VAR 0 2
104308: PPUSH
104309: LD_VAR 0 3
104313: PPUSH
104314: CALL_OW 488
104318: IFFALSE 104353
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104320: LD_VAR 0 1
104324: PPUSH
104325: LD_VAR 0 2
104329: PPUSH
104330: LD_VAR 0 3
104334: PPUSH
104335: LD_INT 3
104337: PPUSH
104338: LD_INT 6
104340: PPUSH
104341: CALL_OW 12
104345: PPUSH
104346: LD_INT 1
104348: PPUSH
104349: CALL_OW 483
// end ;
104353: GO 104213
104355: POP
104356: POP
// end ;
104357: PPOPN 5
104359: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104360: LD_EXP 77
104364: IFFALSE 104372
104366: PUSH
104367: LD_EXP 112
104371: AND
104372: IFFALSE 104466
104374: GO 104376
104376: DISABLE
104377: LD_INT 0
104379: PPUSH
104380: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104381: LD_ADDR_VAR 0 2
104385: PUSH
104386: LD_INT 22
104388: PUSH
104389: LD_OWVAR 2
104393: PUSH
104394: EMPTY
104395: LIST
104396: LIST
104397: PUSH
104398: LD_INT 32
104400: PUSH
104401: LD_INT 1
104403: PUSH
104404: EMPTY
104405: LIST
104406: LIST
104407: PUSH
104408: LD_INT 21
104410: PUSH
104411: LD_INT 2
104413: PUSH
104414: EMPTY
104415: LIST
104416: LIST
104417: PUSH
104418: EMPTY
104419: LIST
104420: LIST
104421: LIST
104422: PPUSH
104423: CALL_OW 69
104427: ST_TO_ADDR
// if not tmp then
104428: LD_VAR 0 2
104432: NOT
104433: IFFALSE 104437
// exit ;
104435: GO 104466
// for i in tmp do
104437: LD_ADDR_VAR 0 1
104441: PUSH
104442: LD_VAR 0 2
104446: PUSH
104447: FOR_IN
104448: IFFALSE 104464
// SetFuel ( i , 0 ) ;
104450: LD_VAR 0 1
104454: PPUSH
104455: LD_INT 0
104457: PPUSH
104458: CALL_OW 240
104462: GO 104447
104464: POP
104465: POP
// end ;
104466: PPOPN 2
104468: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104469: LD_EXP 77
104473: IFFALSE 104481
104475: PUSH
104476: LD_EXP 113
104480: AND
104481: IFFALSE 104547
104483: GO 104485
104485: DISABLE
104486: LD_INT 0
104488: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104489: LD_ADDR_VAR 0 1
104493: PUSH
104494: LD_INT 22
104496: PUSH
104497: LD_OWVAR 2
104501: PUSH
104502: EMPTY
104503: LIST
104504: LIST
104505: PUSH
104506: LD_INT 30
104508: PUSH
104509: LD_INT 29
104511: PUSH
104512: EMPTY
104513: LIST
104514: LIST
104515: PUSH
104516: EMPTY
104517: LIST
104518: LIST
104519: PPUSH
104520: CALL_OW 69
104524: ST_TO_ADDR
// if not tmp then
104525: LD_VAR 0 1
104529: NOT
104530: IFFALSE 104534
// exit ;
104532: GO 104547
// DestroyUnit ( tmp [ 1 ] ) ;
104534: LD_VAR 0 1
104538: PUSH
104539: LD_INT 1
104541: ARRAY
104542: PPUSH
104543: CALL_OW 65
// end ;
104547: PPOPN 1
104549: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104550: LD_EXP 77
104554: IFFALSE 104562
104556: PUSH
104557: LD_EXP 115
104561: AND
104562: IFFALSE 104691
104564: GO 104566
104566: DISABLE
104567: LD_INT 0
104569: PPUSH
// begin uc_side := 0 ;
104570: LD_ADDR_OWVAR 20
104574: PUSH
104575: LD_INT 0
104577: ST_TO_ADDR
// uc_nation := nation_arabian ;
104578: LD_ADDR_OWVAR 21
104582: PUSH
104583: LD_INT 2
104585: ST_TO_ADDR
// hc_gallery :=  ;
104586: LD_ADDR_OWVAR 33
104590: PUSH
104591: LD_STRING 
104593: ST_TO_ADDR
// hc_name :=  ;
104594: LD_ADDR_OWVAR 26
104598: PUSH
104599: LD_STRING 
104601: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104602: LD_INT 1
104604: PPUSH
104605: LD_INT 11
104607: PPUSH
104608: LD_INT 10
104610: PPUSH
104611: CALL_OW 380
// un := CreateHuman ;
104615: LD_ADDR_VAR 0 1
104619: PUSH
104620: CALL_OW 44
104624: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104625: LD_VAR 0 1
104629: PPUSH
104630: LD_INT 1
104632: PPUSH
104633: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104637: LD_INT 35
104639: PPUSH
104640: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104644: LD_VAR 0 1
104648: PPUSH
104649: LD_INT 22
104651: PUSH
104652: LD_OWVAR 2
104656: PUSH
104657: EMPTY
104658: LIST
104659: LIST
104660: PPUSH
104661: CALL_OW 69
104665: PPUSH
104666: LD_VAR 0 1
104670: PPUSH
104671: CALL_OW 74
104675: PPUSH
104676: CALL_OW 115
// until IsDead ( un ) ;
104680: LD_VAR 0 1
104684: PPUSH
104685: CALL_OW 301
104689: IFFALSE 104637
// end ;
104691: PPOPN 1
104693: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104694: LD_EXP 77
104698: IFFALSE 104706
104700: PUSH
104701: LD_EXP 117
104705: AND
104706: IFFALSE 104718
104708: GO 104710
104710: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104711: LD_STRING earthquake(getX(game), 0, 32)
104713: PPUSH
104714: CALL_OW 559
104718: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104719: LD_EXP 77
104723: IFFALSE 104731
104725: PUSH
104726: LD_EXP 118
104730: AND
104731: IFFALSE 104822
104733: GO 104735
104735: DISABLE
104736: LD_INT 0
104738: PPUSH
// begin enable ;
104739: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104740: LD_ADDR_VAR 0 1
104744: PUSH
104745: LD_INT 22
104747: PUSH
104748: LD_OWVAR 2
104752: PUSH
104753: EMPTY
104754: LIST
104755: LIST
104756: PUSH
104757: LD_INT 21
104759: PUSH
104760: LD_INT 2
104762: PUSH
104763: EMPTY
104764: LIST
104765: LIST
104766: PUSH
104767: LD_INT 33
104769: PUSH
104770: LD_INT 3
104772: PUSH
104773: EMPTY
104774: LIST
104775: LIST
104776: PUSH
104777: EMPTY
104778: LIST
104779: LIST
104780: LIST
104781: PPUSH
104782: CALL_OW 69
104786: ST_TO_ADDR
// if not tmp then
104787: LD_VAR 0 1
104791: NOT
104792: IFFALSE 104796
// exit ;
104794: GO 104822
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104796: LD_VAR 0 1
104800: PUSH
104801: LD_INT 1
104803: PPUSH
104804: LD_VAR 0 1
104808: PPUSH
104809: CALL_OW 12
104813: ARRAY
104814: PPUSH
104815: LD_INT 1
104817: PPUSH
104818: CALL_OW 234
// end ;
104822: PPOPN 1
104824: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104825: LD_EXP 77
104829: IFFALSE 104837
104831: PUSH
104832: LD_EXP 119
104836: AND
104837: IFFALSE 104978
104839: GO 104841
104841: DISABLE
104842: LD_INT 0
104844: PPUSH
104845: PPUSH
104846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104847: LD_ADDR_VAR 0 3
104851: PUSH
104852: LD_INT 22
104854: PUSH
104855: LD_OWVAR 2
104859: PUSH
104860: EMPTY
104861: LIST
104862: LIST
104863: PUSH
104864: LD_INT 25
104866: PUSH
104867: LD_INT 1
104869: PUSH
104870: EMPTY
104871: LIST
104872: LIST
104873: PUSH
104874: EMPTY
104875: LIST
104876: LIST
104877: PPUSH
104878: CALL_OW 69
104882: ST_TO_ADDR
// if not tmp then
104883: LD_VAR 0 3
104887: NOT
104888: IFFALSE 104892
// exit ;
104890: GO 104978
// un := tmp [ rand ( 1 , tmp ) ] ;
104892: LD_ADDR_VAR 0 2
104896: PUSH
104897: LD_VAR 0 3
104901: PUSH
104902: LD_INT 1
104904: PPUSH
104905: LD_VAR 0 3
104909: PPUSH
104910: CALL_OW 12
104914: ARRAY
104915: ST_TO_ADDR
// if Crawls ( un ) then
104916: LD_VAR 0 2
104920: PPUSH
104921: CALL_OW 318
104925: IFFALSE 104936
// ComWalk ( un ) ;
104927: LD_VAR 0 2
104931: PPUSH
104932: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104936: LD_VAR 0 2
104940: PPUSH
104941: LD_INT 9
104943: PPUSH
104944: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104948: LD_INT 28
104950: PPUSH
104951: LD_OWVAR 2
104955: PPUSH
104956: LD_INT 2
104958: PPUSH
104959: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104963: LD_INT 29
104965: PPUSH
104966: LD_OWVAR 2
104970: PPUSH
104971: LD_INT 2
104973: PPUSH
104974: CALL_OW 322
// end ;
104978: PPOPN 3
104980: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104981: LD_EXP 77
104985: IFFALSE 104993
104987: PUSH
104988: LD_EXP 120
104992: AND
104993: IFFALSE 105104
104995: GO 104997
104997: DISABLE
104998: LD_INT 0
105000: PPUSH
105001: PPUSH
105002: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105003: LD_ADDR_VAR 0 3
105007: PUSH
105008: LD_INT 22
105010: PUSH
105011: LD_OWVAR 2
105015: PUSH
105016: EMPTY
105017: LIST
105018: LIST
105019: PUSH
105020: LD_INT 25
105022: PUSH
105023: LD_INT 1
105025: PUSH
105026: EMPTY
105027: LIST
105028: LIST
105029: PUSH
105030: EMPTY
105031: LIST
105032: LIST
105033: PPUSH
105034: CALL_OW 69
105038: ST_TO_ADDR
// if not tmp then
105039: LD_VAR 0 3
105043: NOT
105044: IFFALSE 105048
// exit ;
105046: GO 105104
// un := tmp [ rand ( 1 , tmp ) ] ;
105048: LD_ADDR_VAR 0 2
105052: PUSH
105053: LD_VAR 0 3
105057: PUSH
105058: LD_INT 1
105060: PPUSH
105061: LD_VAR 0 3
105065: PPUSH
105066: CALL_OW 12
105070: ARRAY
105071: ST_TO_ADDR
// if Crawls ( un ) then
105072: LD_VAR 0 2
105076: PPUSH
105077: CALL_OW 318
105081: IFFALSE 105092
// ComWalk ( un ) ;
105083: LD_VAR 0 2
105087: PPUSH
105088: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105092: LD_VAR 0 2
105096: PPUSH
105097: LD_INT 8
105099: PPUSH
105100: CALL_OW 336
// end ;
105104: PPOPN 3
105106: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105107: LD_EXP 77
105111: IFFALSE 105119
105113: PUSH
105114: LD_EXP 121
105118: AND
105119: IFFALSE 105263
105121: GO 105123
105123: DISABLE
105124: LD_INT 0
105126: PPUSH
105127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105128: LD_ADDR_VAR 0 2
105132: PUSH
105133: LD_INT 22
105135: PUSH
105136: LD_OWVAR 2
105140: PUSH
105141: EMPTY
105142: LIST
105143: LIST
105144: PUSH
105145: LD_INT 21
105147: PUSH
105148: LD_INT 2
105150: PUSH
105151: EMPTY
105152: LIST
105153: LIST
105154: PUSH
105155: LD_INT 2
105157: PUSH
105158: LD_INT 34
105160: PUSH
105161: LD_INT 12
105163: PUSH
105164: EMPTY
105165: LIST
105166: LIST
105167: PUSH
105168: LD_INT 34
105170: PUSH
105171: LD_INT 51
105173: PUSH
105174: EMPTY
105175: LIST
105176: LIST
105177: PUSH
105178: LD_INT 34
105180: PUSH
105181: LD_INT 32
105183: PUSH
105184: EMPTY
105185: LIST
105186: LIST
105187: PUSH
105188: EMPTY
105189: LIST
105190: LIST
105191: LIST
105192: LIST
105193: PUSH
105194: EMPTY
105195: LIST
105196: LIST
105197: LIST
105198: PPUSH
105199: CALL_OW 69
105203: ST_TO_ADDR
// if not tmp then
105204: LD_VAR 0 2
105208: NOT
105209: IFFALSE 105213
// exit ;
105211: GO 105263
// for i in tmp do
105213: LD_ADDR_VAR 0 1
105217: PUSH
105218: LD_VAR 0 2
105222: PUSH
105223: FOR_IN
105224: IFFALSE 105261
// if GetCargo ( i , mat_artifact ) = 0 then
105226: LD_VAR 0 1
105230: PPUSH
105231: LD_INT 4
105233: PPUSH
105234: CALL_OW 289
105238: PUSH
105239: LD_INT 0
105241: EQUAL
105242: IFFALSE 105259
// SetCargo ( i , mat_siberit , 100 ) ;
105244: LD_VAR 0 1
105248: PPUSH
105249: LD_INT 3
105251: PPUSH
105252: LD_INT 100
105254: PPUSH
105255: CALL_OW 290
105259: GO 105223
105261: POP
105262: POP
// end ;
105263: PPOPN 2
105265: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105266: LD_EXP 77
105270: IFFALSE 105278
105272: PUSH
105273: LD_EXP 122
105277: AND
105278: IFFALSE 105461
105280: GO 105282
105282: DISABLE
105283: LD_INT 0
105285: PPUSH
105286: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105287: LD_ADDR_VAR 0 2
105291: PUSH
105292: LD_INT 22
105294: PUSH
105295: LD_OWVAR 2
105299: PUSH
105300: EMPTY
105301: LIST
105302: LIST
105303: PPUSH
105304: CALL_OW 69
105308: ST_TO_ADDR
// if not tmp then
105309: LD_VAR 0 2
105313: NOT
105314: IFFALSE 105318
// exit ;
105316: GO 105461
// for i := 1 to 2 do
105318: LD_ADDR_VAR 0 1
105322: PUSH
105323: DOUBLE
105324: LD_INT 1
105326: DEC
105327: ST_TO_ADDR
105328: LD_INT 2
105330: PUSH
105331: FOR_TO
105332: IFFALSE 105459
// begin uc_side := your_side ;
105334: LD_ADDR_OWVAR 20
105338: PUSH
105339: LD_OWVAR 2
105343: ST_TO_ADDR
// uc_nation := nation_american ;
105344: LD_ADDR_OWVAR 21
105348: PUSH
105349: LD_INT 1
105351: ST_TO_ADDR
// vc_chassis := us_morphling ;
105352: LD_ADDR_OWVAR 37
105356: PUSH
105357: LD_INT 5
105359: ST_TO_ADDR
// vc_engine := engine_siberite ;
105360: LD_ADDR_OWVAR 39
105364: PUSH
105365: LD_INT 3
105367: ST_TO_ADDR
// vc_control := control_computer ;
105368: LD_ADDR_OWVAR 38
105372: PUSH
105373: LD_INT 3
105375: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105376: LD_ADDR_OWVAR 40
105380: PUSH
105381: LD_INT 10
105383: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105384: LD_VAR 0 2
105388: PUSH
105389: LD_INT 1
105391: ARRAY
105392: PPUSH
105393: CALL_OW 310
105397: NOT
105398: IFFALSE 105445
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105400: CALL_OW 45
105404: PPUSH
105405: LD_VAR 0 2
105409: PUSH
105410: LD_INT 1
105412: ARRAY
105413: PPUSH
105414: CALL_OW 250
105418: PPUSH
105419: LD_VAR 0 2
105423: PUSH
105424: LD_INT 1
105426: ARRAY
105427: PPUSH
105428: CALL_OW 251
105432: PPUSH
105433: LD_INT 12
105435: PPUSH
105436: LD_INT 1
105438: PPUSH
105439: CALL_OW 50
105443: GO 105457
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105445: CALL_OW 45
105449: PPUSH
105450: LD_INT 1
105452: PPUSH
105453: CALL_OW 51
// end ;
105457: GO 105331
105459: POP
105460: POP
// end ;
105461: PPOPN 2
105463: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105464: LD_EXP 77
105468: IFFALSE 105476
105470: PUSH
105471: LD_EXP 123
105475: AND
105476: IFFALSE 105698
105478: GO 105480
105480: DISABLE
105481: LD_INT 0
105483: PPUSH
105484: PPUSH
105485: PPUSH
105486: PPUSH
105487: PPUSH
105488: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105489: LD_ADDR_VAR 0 6
105493: PUSH
105494: LD_INT 22
105496: PUSH
105497: LD_OWVAR 2
105501: PUSH
105502: EMPTY
105503: LIST
105504: LIST
105505: PUSH
105506: LD_INT 21
105508: PUSH
105509: LD_INT 1
105511: PUSH
105512: EMPTY
105513: LIST
105514: LIST
105515: PUSH
105516: LD_INT 3
105518: PUSH
105519: LD_INT 23
105521: PUSH
105522: LD_INT 0
105524: PUSH
105525: EMPTY
105526: LIST
105527: LIST
105528: PUSH
105529: EMPTY
105530: LIST
105531: LIST
105532: PUSH
105533: EMPTY
105534: LIST
105535: LIST
105536: LIST
105537: PPUSH
105538: CALL_OW 69
105542: ST_TO_ADDR
// if not tmp then
105543: LD_VAR 0 6
105547: NOT
105548: IFFALSE 105552
// exit ;
105550: GO 105698
// s1 := rand ( 1 , 4 ) ;
105552: LD_ADDR_VAR 0 2
105556: PUSH
105557: LD_INT 1
105559: PPUSH
105560: LD_INT 4
105562: PPUSH
105563: CALL_OW 12
105567: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105568: LD_ADDR_VAR 0 4
105572: PUSH
105573: LD_VAR 0 6
105577: PUSH
105578: LD_INT 1
105580: ARRAY
105581: PPUSH
105582: LD_VAR 0 2
105586: PPUSH
105587: CALL_OW 259
105591: ST_TO_ADDR
// if s1 = 1 then
105592: LD_VAR 0 2
105596: PUSH
105597: LD_INT 1
105599: EQUAL
105600: IFFALSE 105620
// s2 := rand ( 2 , 4 ) else
105602: LD_ADDR_VAR 0 3
105606: PUSH
105607: LD_INT 2
105609: PPUSH
105610: LD_INT 4
105612: PPUSH
105613: CALL_OW 12
105617: ST_TO_ADDR
105618: GO 105628
// s2 := 1 ;
105620: LD_ADDR_VAR 0 3
105624: PUSH
105625: LD_INT 1
105627: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105628: LD_ADDR_VAR 0 5
105632: PUSH
105633: LD_VAR 0 6
105637: PUSH
105638: LD_INT 1
105640: ARRAY
105641: PPUSH
105642: LD_VAR 0 3
105646: PPUSH
105647: CALL_OW 259
105651: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105652: LD_VAR 0 6
105656: PUSH
105657: LD_INT 1
105659: ARRAY
105660: PPUSH
105661: LD_VAR 0 2
105665: PPUSH
105666: LD_VAR 0 5
105670: PPUSH
105671: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105675: LD_VAR 0 6
105679: PUSH
105680: LD_INT 1
105682: ARRAY
105683: PPUSH
105684: LD_VAR 0 3
105688: PPUSH
105689: LD_VAR 0 4
105693: PPUSH
105694: CALL_OW 237
// end ;
105698: PPOPN 6
105700: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105701: LD_EXP 77
105705: IFFALSE 105713
105707: PUSH
105708: LD_EXP 124
105712: AND
105713: IFFALSE 105792
105715: GO 105717
105717: DISABLE
105718: LD_INT 0
105720: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105721: LD_ADDR_VAR 0 1
105725: PUSH
105726: LD_INT 22
105728: PUSH
105729: LD_OWVAR 2
105733: PUSH
105734: EMPTY
105735: LIST
105736: LIST
105737: PUSH
105738: LD_INT 30
105740: PUSH
105741: LD_INT 3
105743: PUSH
105744: EMPTY
105745: LIST
105746: LIST
105747: PUSH
105748: EMPTY
105749: LIST
105750: LIST
105751: PPUSH
105752: CALL_OW 69
105756: ST_TO_ADDR
// if not tmp then
105757: LD_VAR 0 1
105761: NOT
105762: IFFALSE 105766
// exit ;
105764: GO 105792
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105766: LD_VAR 0 1
105770: PUSH
105771: LD_INT 1
105773: PPUSH
105774: LD_VAR 0 1
105778: PPUSH
105779: CALL_OW 12
105783: ARRAY
105784: PPUSH
105785: LD_INT 1
105787: PPUSH
105788: CALL_OW 234
// end ;
105792: PPOPN 1
105794: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105795: LD_EXP 77
105799: IFFALSE 105807
105801: PUSH
105802: LD_EXP 125
105806: AND
105807: IFFALSE 105919
105809: GO 105811
105811: DISABLE
105812: LD_INT 0
105814: PPUSH
105815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105816: LD_ADDR_VAR 0 2
105820: PUSH
105821: LD_INT 22
105823: PUSH
105824: LD_OWVAR 2
105828: PUSH
105829: EMPTY
105830: LIST
105831: LIST
105832: PUSH
105833: LD_INT 2
105835: PUSH
105836: LD_INT 30
105838: PUSH
105839: LD_INT 27
105841: PUSH
105842: EMPTY
105843: LIST
105844: LIST
105845: PUSH
105846: LD_INT 30
105848: PUSH
105849: LD_INT 26
105851: PUSH
105852: EMPTY
105853: LIST
105854: LIST
105855: PUSH
105856: LD_INT 30
105858: PUSH
105859: LD_INT 28
105861: PUSH
105862: EMPTY
105863: LIST
105864: LIST
105865: PUSH
105866: EMPTY
105867: LIST
105868: LIST
105869: LIST
105870: LIST
105871: PUSH
105872: EMPTY
105873: LIST
105874: LIST
105875: PPUSH
105876: CALL_OW 69
105880: ST_TO_ADDR
// if not tmp then
105881: LD_VAR 0 2
105885: NOT
105886: IFFALSE 105890
// exit ;
105888: GO 105919
// for i in tmp do
105890: LD_ADDR_VAR 0 1
105894: PUSH
105895: LD_VAR 0 2
105899: PUSH
105900: FOR_IN
105901: IFFALSE 105917
// SetLives ( i , 1 ) ;
105903: LD_VAR 0 1
105907: PPUSH
105908: LD_INT 1
105910: PPUSH
105911: CALL_OW 234
105915: GO 105900
105917: POP
105918: POP
// end ;
105919: PPOPN 2
105921: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105922: LD_EXP 77
105926: IFFALSE 105934
105928: PUSH
105929: LD_EXP 126
105933: AND
105934: IFFALSE 106221
105936: GO 105938
105938: DISABLE
105939: LD_INT 0
105941: PPUSH
105942: PPUSH
105943: PPUSH
// begin i := rand ( 1 , 7 ) ;
105944: LD_ADDR_VAR 0 1
105948: PUSH
105949: LD_INT 1
105951: PPUSH
105952: LD_INT 7
105954: PPUSH
105955: CALL_OW 12
105959: ST_TO_ADDR
// case i of 1 :
105960: LD_VAR 0 1
105964: PUSH
105965: LD_INT 1
105967: DOUBLE
105968: EQUAL
105969: IFTRUE 105973
105971: GO 105983
105973: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105974: LD_STRING earthquake(getX(game), 0, 32)
105976: PPUSH
105977: CALL_OW 559
105981: GO 106221
105983: LD_INT 2
105985: DOUBLE
105986: EQUAL
105987: IFTRUE 105991
105989: GO 106005
105991: POP
// begin ToLua ( displayStucuk(); ) ;
105992: LD_STRING displayStucuk();
105994: PPUSH
105995: CALL_OW 559
// ResetFog ;
105999: CALL_OW 335
// end ; 3 :
106003: GO 106221
106005: LD_INT 3
106007: DOUBLE
106008: EQUAL
106009: IFTRUE 106013
106011: GO 106117
106013: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106014: LD_ADDR_VAR 0 2
106018: PUSH
106019: LD_INT 22
106021: PUSH
106022: LD_OWVAR 2
106026: PUSH
106027: EMPTY
106028: LIST
106029: LIST
106030: PUSH
106031: LD_INT 25
106033: PUSH
106034: LD_INT 1
106036: PUSH
106037: EMPTY
106038: LIST
106039: LIST
106040: PUSH
106041: EMPTY
106042: LIST
106043: LIST
106044: PPUSH
106045: CALL_OW 69
106049: ST_TO_ADDR
// if not tmp then
106050: LD_VAR 0 2
106054: NOT
106055: IFFALSE 106059
// exit ;
106057: GO 106221
// un := tmp [ rand ( 1 , tmp ) ] ;
106059: LD_ADDR_VAR 0 3
106063: PUSH
106064: LD_VAR 0 2
106068: PUSH
106069: LD_INT 1
106071: PPUSH
106072: LD_VAR 0 2
106076: PPUSH
106077: CALL_OW 12
106081: ARRAY
106082: ST_TO_ADDR
// if Crawls ( un ) then
106083: LD_VAR 0 3
106087: PPUSH
106088: CALL_OW 318
106092: IFFALSE 106103
// ComWalk ( un ) ;
106094: LD_VAR 0 3
106098: PPUSH
106099: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106103: LD_VAR 0 3
106107: PPUSH
106108: LD_INT 8
106110: PPUSH
106111: CALL_OW 336
// end ; 4 :
106115: GO 106221
106117: LD_INT 4
106119: DOUBLE
106120: EQUAL
106121: IFTRUE 106125
106123: GO 106199
106125: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106126: LD_ADDR_VAR 0 2
106130: PUSH
106131: LD_INT 22
106133: PUSH
106134: LD_OWVAR 2
106138: PUSH
106139: EMPTY
106140: LIST
106141: LIST
106142: PUSH
106143: LD_INT 30
106145: PUSH
106146: LD_INT 29
106148: PUSH
106149: EMPTY
106150: LIST
106151: LIST
106152: PUSH
106153: EMPTY
106154: LIST
106155: LIST
106156: PPUSH
106157: CALL_OW 69
106161: ST_TO_ADDR
// if not tmp then
106162: LD_VAR 0 2
106166: NOT
106167: IFFALSE 106171
// exit ;
106169: GO 106221
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106171: LD_VAR 0 2
106175: PUSH
106176: LD_INT 1
106178: ARRAY
106179: PPUSH
106180: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106184: LD_VAR 0 2
106188: PUSH
106189: LD_INT 1
106191: ARRAY
106192: PPUSH
106193: CALL_OW 65
// end ; 5 .. 7 :
106197: GO 106221
106199: LD_INT 5
106201: DOUBLE
106202: GREATEREQUAL
106203: IFFALSE 106211
106205: LD_INT 7
106207: DOUBLE
106208: LESSEQUAL
106209: IFTRUE 106213
106211: GO 106220
106213: POP
// StreamSibBomb ; end ;
106214: CALL 102402 0 0
106218: GO 106221
106220: POP
// end ;
106221: PPOPN 3
106223: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106224: LD_EXP 77
106228: IFFALSE 106236
106230: PUSH
106231: LD_EXP 127
106235: AND
106236: IFFALSE 106392
106238: GO 106240
106240: DISABLE
106241: LD_INT 0
106243: PPUSH
106244: PPUSH
106245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106246: LD_ADDR_VAR 0 2
106250: PUSH
106251: LD_INT 81
106253: PUSH
106254: LD_OWVAR 2
106258: PUSH
106259: EMPTY
106260: LIST
106261: LIST
106262: PUSH
106263: LD_INT 2
106265: PUSH
106266: LD_INT 21
106268: PUSH
106269: LD_INT 1
106271: PUSH
106272: EMPTY
106273: LIST
106274: LIST
106275: PUSH
106276: LD_INT 21
106278: PUSH
106279: LD_INT 2
106281: PUSH
106282: EMPTY
106283: LIST
106284: LIST
106285: PUSH
106286: EMPTY
106287: LIST
106288: LIST
106289: LIST
106290: PUSH
106291: EMPTY
106292: LIST
106293: LIST
106294: PPUSH
106295: CALL_OW 69
106299: ST_TO_ADDR
// if not tmp then
106300: LD_VAR 0 2
106304: NOT
106305: IFFALSE 106309
// exit ;
106307: GO 106392
// p := 0 ;
106309: LD_ADDR_VAR 0 3
106313: PUSH
106314: LD_INT 0
106316: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106317: LD_INT 35
106319: PPUSH
106320: CALL_OW 67
// p := p + 1 ;
106324: LD_ADDR_VAR 0 3
106328: PUSH
106329: LD_VAR 0 3
106333: PUSH
106334: LD_INT 1
106336: PLUS
106337: ST_TO_ADDR
// for i in tmp do
106338: LD_ADDR_VAR 0 1
106342: PUSH
106343: LD_VAR 0 2
106347: PUSH
106348: FOR_IN
106349: IFFALSE 106380
// if GetLives ( i ) < 1000 then
106351: LD_VAR 0 1
106355: PPUSH
106356: CALL_OW 256
106360: PUSH
106361: LD_INT 1000
106363: LESS
106364: IFFALSE 106378
// SetLives ( i , 1000 ) ;
106366: LD_VAR 0 1
106370: PPUSH
106371: LD_INT 1000
106373: PPUSH
106374: CALL_OW 234
106378: GO 106348
106380: POP
106381: POP
// until p > 20 ;
106382: LD_VAR 0 3
106386: PUSH
106387: LD_INT 20
106389: GREATER
106390: IFFALSE 106317
// end ;
106392: PPOPN 3
106394: END
// every 0 0$1 trigger StreamModeActive and sTime do
106395: LD_EXP 77
106399: IFFALSE 106407
106401: PUSH
106402: LD_EXP 128
106406: AND
106407: IFFALSE 106442
106409: GO 106411
106411: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106412: LD_INT 28
106414: PPUSH
106415: LD_OWVAR 2
106419: PPUSH
106420: LD_INT 2
106422: PPUSH
106423: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106427: LD_INT 30
106429: PPUSH
106430: LD_OWVAR 2
106434: PPUSH
106435: LD_INT 2
106437: PPUSH
106438: CALL_OW 322
// end ;
106442: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106443: LD_EXP 77
106447: IFFALSE 106455
106449: PUSH
106450: LD_EXP 129
106454: AND
106455: IFFALSE 106576
106457: GO 106459
106459: DISABLE
106460: LD_INT 0
106462: PPUSH
106463: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106464: LD_ADDR_VAR 0 2
106468: PUSH
106469: LD_INT 22
106471: PUSH
106472: LD_OWVAR 2
106476: PUSH
106477: EMPTY
106478: LIST
106479: LIST
106480: PUSH
106481: LD_INT 21
106483: PUSH
106484: LD_INT 1
106486: PUSH
106487: EMPTY
106488: LIST
106489: LIST
106490: PUSH
106491: LD_INT 3
106493: PUSH
106494: LD_INT 23
106496: PUSH
106497: LD_INT 0
106499: PUSH
106500: EMPTY
106501: LIST
106502: LIST
106503: PUSH
106504: EMPTY
106505: LIST
106506: LIST
106507: PUSH
106508: EMPTY
106509: LIST
106510: LIST
106511: LIST
106512: PPUSH
106513: CALL_OW 69
106517: ST_TO_ADDR
// if not tmp then
106518: LD_VAR 0 2
106522: NOT
106523: IFFALSE 106527
// exit ;
106525: GO 106576
// for i in tmp do
106527: LD_ADDR_VAR 0 1
106531: PUSH
106532: LD_VAR 0 2
106536: PUSH
106537: FOR_IN
106538: IFFALSE 106574
// begin if Crawls ( i ) then
106540: LD_VAR 0 1
106544: PPUSH
106545: CALL_OW 318
106549: IFFALSE 106560
// ComWalk ( i ) ;
106551: LD_VAR 0 1
106555: PPUSH
106556: CALL_OW 138
// SetClass ( i , 2 ) ;
106560: LD_VAR 0 1
106564: PPUSH
106565: LD_INT 2
106567: PPUSH
106568: CALL_OW 336
// end ;
106572: GO 106537
106574: POP
106575: POP
// end ;
106576: PPOPN 2
106578: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106579: LD_EXP 77
106583: IFFALSE 106591
106585: PUSH
106586: LD_EXP 130
106590: AND
106591: IFFALSE 106881
106593: GO 106595
106595: DISABLE
106596: LD_INT 0
106598: PPUSH
106599: PPUSH
106600: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106601: LD_OWVAR 2
106605: PPUSH
106606: LD_INT 9
106608: PPUSH
106609: LD_INT 1
106611: PPUSH
106612: LD_INT 1
106614: PPUSH
106615: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106619: LD_INT 9
106621: PPUSH
106622: LD_OWVAR 2
106626: PPUSH
106627: CALL_OW 343
// uc_side := 9 ;
106631: LD_ADDR_OWVAR 20
106635: PUSH
106636: LD_INT 9
106638: ST_TO_ADDR
// uc_nation := 2 ;
106639: LD_ADDR_OWVAR 21
106643: PUSH
106644: LD_INT 2
106646: ST_TO_ADDR
// hc_name := Dark Warrior ;
106647: LD_ADDR_OWVAR 26
106651: PUSH
106652: LD_STRING Dark Warrior
106654: ST_TO_ADDR
// hc_gallery :=  ;
106655: LD_ADDR_OWVAR 33
106659: PUSH
106660: LD_STRING 
106662: ST_TO_ADDR
// hc_noskilllimit := true ;
106663: LD_ADDR_OWVAR 76
106667: PUSH
106668: LD_INT 1
106670: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106671: LD_ADDR_OWVAR 31
106675: PUSH
106676: LD_INT 30
106678: PUSH
106679: LD_INT 30
106681: PUSH
106682: LD_INT 30
106684: PUSH
106685: LD_INT 30
106687: PUSH
106688: EMPTY
106689: LIST
106690: LIST
106691: LIST
106692: LIST
106693: ST_TO_ADDR
// un := CreateHuman ;
106694: LD_ADDR_VAR 0 3
106698: PUSH
106699: CALL_OW 44
106703: ST_TO_ADDR
// hc_noskilllimit := false ;
106704: LD_ADDR_OWVAR 76
106708: PUSH
106709: LD_INT 0
106711: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106712: LD_VAR 0 3
106716: PPUSH
106717: LD_INT 1
106719: PPUSH
106720: CALL_OW 51
// ToLua ( playRanger() ) ;
106724: LD_STRING playRanger()
106726: PPUSH
106727: CALL_OW 559
// p := 0 ;
106731: LD_ADDR_VAR 0 2
106735: PUSH
106736: LD_INT 0
106738: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106739: LD_INT 35
106741: PPUSH
106742: CALL_OW 67
// p := p + 1 ;
106746: LD_ADDR_VAR 0 2
106750: PUSH
106751: LD_VAR 0 2
106755: PUSH
106756: LD_INT 1
106758: PLUS
106759: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106760: LD_VAR 0 3
106764: PPUSH
106765: CALL_OW 256
106769: PUSH
106770: LD_INT 1000
106772: LESS
106773: IFFALSE 106787
// SetLives ( un , 1000 ) ;
106775: LD_VAR 0 3
106779: PPUSH
106780: LD_INT 1000
106782: PPUSH
106783: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106787: LD_VAR 0 3
106791: PPUSH
106792: LD_INT 81
106794: PUSH
106795: LD_OWVAR 2
106799: PUSH
106800: EMPTY
106801: LIST
106802: LIST
106803: PUSH
106804: LD_INT 91
106806: PUSH
106807: LD_VAR 0 3
106811: PUSH
106812: LD_INT 30
106814: PUSH
106815: EMPTY
106816: LIST
106817: LIST
106818: LIST
106819: PUSH
106820: EMPTY
106821: LIST
106822: LIST
106823: PPUSH
106824: CALL_OW 69
106828: PPUSH
106829: LD_VAR 0 3
106833: PPUSH
106834: CALL_OW 74
106838: PPUSH
106839: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106843: LD_VAR 0 2
106847: PUSH
106848: LD_INT 80
106850: GREATER
106851: IFTRUE 106864
106853: PUSH
106854: LD_VAR 0 3
106858: PPUSH
106859: CALL_OW 301
106863: OR
106864: IFFALSE 106739
// if un then
106866: LD_VAR 0 3
106870: IFFALSE 106881
// RemoveUnit ( un ) ;
106872: LD_VAR 0 3
106876: PPUSH
106877: CALL_OW 64
// end ;
106881: PPOPN 3
106883: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106884: LD_EXP 131
106888: IFFALSE 107004
106890: GO 106892
106892: DISABLE
106893: LD_INT 0
106895: PPUSH
106896: PPUSH
106897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106898: LD_ADDR_VAR 0 2
106902: PUSH
106903: LD_INT 81
106905: PUSH
106906: LD_OWVAR 2
106910: PUSH
106911: EMPTY
106912: LIST
106913: LIST
106914: PUSH
106915: LD_INT 21
106917: PUSH
106918: LD_INT 1
106920: PUSH
106921: EMPTY
106922: LIST
106923: LIST
106924: PUSH
106925: EMPTY
106926: LIST
106927: LIST
106928: PPUSH
106929: CALL_OW 69
106933: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106934: LD_STRING playComputer()
106936: PPUSH
106937: CALL_OW 559
// if not tmp then
106941: LD_VAR 0 2
106945: NOT
106946: IFFALSE 106950
// exit ;
106948: GO 107004
// for i in tmp do
106950: LD_ADDR_VAR 0 1
106954: PUSH
106955: LD_VAR 0 2
106959: PUSH
106960: FOR_IN
106961: IFFALSE 107002
// for j := 1 to 4 do
106963: LD_ADDR_VAR 0 3
106967: PUSH
106968: DOUBLE
106969: LD_INT 1
106971: DEC
106972: ST_TO_ADDR
106973: LD_INT 4
106975: PUSH
106976: FOR_TO
106977: IFFALSE 106998
// SetSkill ( i , j , 10 ) ;
106979: LD_VAR 0 1
106983: PPUSH
106984: LD_VAR 0 3
106988: PPUSH
106989: LD_INT 10
106991: PPUSH
106992: CALL_OW 237
106996: GO 106976
106998: POP
106999: POP
107000: GO 106960
107002: POP
107003: POP
// end ;
107004: PPOPN 3
107006: END
// every 0 0$1 trigger s30 do var i , tmp ;
107007: LD_EXP 132
107011: IFFALSE 107080
107013: GO 107015
107015: DISABLE
107016: LD_INT 0
107018: PPUSH
107019: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107020: LD_ADDR_VAR 0 2
107024: PUSH
107025: LD_INT 22
107027: PUSH
107028: LD_OWVAR 2
107032: PUSH
107033: EMPTY
107034: LIST
107035: LIST
107036: PPUSH
107037: CALL_OW 69
107041: ST_TO_ADDR
// if not tmp then
107042: LD_VAR 0 2
107046: NOT
107047: IFFALSE 107051
// exit ;
107049: GO 107080
// for i in tmp do
107051: LD_ADDR_VAR 0 1
107055: PUSH
107056: LD_VAR 0 2
107060: PUSH
107061: FOR_IN
107062: IFFALSE 107078
// SetLives ( i , 300 ) ;
107064: LD_VAR 0 1
107068: PPUSH
107069: LD_INT 300
107071: PPUSH
107072: CALL_OW 234
107076: GO 107061
107078: POP
107079: POP
// end ;
107080: PPOPN 2
107082: END
// every 0 0$1 trigger s60 do var i , tmp ;
107083: LD_EXP 133
107087: IFFALSE 107156
107089: GO 107091
107091: DISABLE
107092: LD_INT 0
107094: PPUSH
107095: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107096: LD_ADDR_VAR 0 2
107100: PUSH
107101: LD_INT 22
107103: PUSH
107104: LD_OWVAR 2
107108: PUSH
107109: EMPTY
107110: LIST
107111: LIST
107112: PPUSH
107113: CALL_OW 69
107117: ST_TO_ADDR
// if not tmp then
107118: LD_VAR 0 2
107122: NOT
107123: IFFALSE 107127
// exit ;
107125: GO 107156
// for i in tmp do
107127: LD_ADDR_VAR 0 1
107131: PUSH
107132: LD_VAR 0 2
107136: PUSH
107137: FOR_IN
107138: IFFALSE 107154
// SetLives ( i , 600 ) ;
107140: LD_VAR 0 1
107144: PPUSH
107145: LD_INT 600
107147: PPUSH
107148: CALL_OW 234
107152: GO 107137
107154: POP
107155: POP
// end ;
107156: PPOPN 2
107158: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107159: LD_INT 0
107161: PPUSH
// case cmd of 301 :
107162: LD_VAR 0 1
107166: PUSH
107167: LD_INT 301
107169: DOUBLE
107170: EQUAL
107171: IFTRUE 107175
107173: GO 107207
107175: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107176: LD_VAR 0 6
107180: PPUSH
107181: LD_VAR 0 7
107185: PPUSH
107186: LD_VAR 0 8
107190: PPUSH
107191: LD_VAR 0 4
107195: PPUSH
107196: LD_VAR 0 5
107200: PPUSH
107201: CALL 108420 0 5
107205: GO 107328
107207: LD_INT 302
107209: DOUBLE
107210: EQUAL
107211: IFTRUE 107215
107213: GO 107252
107215: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107216: LD_VAR 0 6
107220: PPUSH
107221: LD_VAR 0 7
107225: PPUSH
107226: LD_VAR 0 8
107230: PPUSH
107231: LD_VAR 0 9
107235: PPUSH
107236: LD_VAR 0 4
107240: PPUSH
107241: LD_VAR 0 5
107245: PPUSH
107246: CALL 108511 0 6
107250: GO 107328
107252: LD_INT 303
107254: DOUBLE
107255: EQUAL
107256: IFTRUE 107260
107258: GO 107297
107260: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107261: LD_VAR 0 6
107265: PPUSH
107266: LD_VAR 0 7
107270: PPUSH
107271: LD_VAR 0 8
107275: PPUSH
107276: LD_VAR 0 9
107280: PPUSH
107281: LD_VAR 0 4
107285: PPUSH
107286: LD_VAR 0 5
107290: PPUSH
107291: CALL 107333 0 6
107295: GO 107328
107297: LD_INT 304
107299: DOUBLE
107300: EQUAL
107301: IFTRUE 107305
107303: GO 107327
107305: POP
// hHackTeleport ( unit , x , y ) ; end ;
107306: LD_VAR 0 2
107310: PPUSH
107311: LD_VAR 0 4
107315: PPUSH
107316: LD_VAR 0 5
107320: PPUSH
107321: CALL 109104 0 3
107325: GO 107328
107327: POP
// end ;
107328: LD_VAR 0 12
107332: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107333: LD_INT 0
107335: PPUSH
107336: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107337: LD_VAR 0 1
107341: PUSH
107342: LD_INT 1
107344: LESS
107345: IFTRUE 107357
107347: PUSH
107348: LD_VAR 0 1
107352: PUSH
107353: LD_INT 3
107355: GREATER
107356: OR
107357: IFTRUE 107375
107359: PUSH
107360: LD_VAR 0 5
107364: PPUSH
107365: LD_VAR 0 6
107369: PPUSH
107370: CALL_OW 428
107374: OR
107375: IFFALSE 107379
// exit ;
107377: GO 108107
// uc_side := your_side ;
107379: LD_ADDR_OWVAR 20
107383: PUSH
107384: LD_OWVAR 2
107388: ST_TO_ADDR
// uc_nation := nation ;
107389: LD_ADDR_OWVAR 21
107393: PUSH
107394: LD_VAR 0 1
107398: ST_TO_ADDR
// bc_level = 1 ;
107399: LD_ADDR_OWVAR 43
107403: PUSH
107404: LD_INT 1
107406: ST_TO_ADDR
// case btype of 1 :
107407: LD_VAR 0 2
107411: PUSH
107412: LD_INT 1
107414: DOUBLE
107415: EQUAL
107416: IFTRUE 107420
107418: GO 107431
107420: POP
// bc_type := b_depot ; 2 :
107421: LD_ADDR_OWVAR 42
107425: PUSH
107426: LD_INT 0
107428: ST_TO_ADDR
107429: GO 108051
107431: LD_INT 2
107433: DOUBLE
107434: EQUAL
107435: IFTRUE 107439
107437: GO 107450
107439: POP
// bc_type := b_warehouse ; 3 :
107440: LD_ADDR_OWVAR 42
107444: PUSH
107445: LD_INT 1
107447: ST_TO_ADDR
107448: GO 108051
107450: LD_INT 3
107452: DOUBLE
107453: EQUAL
107454: IFTRUE 107458
107456: GO 107469
107458: POP
// bc_type := b_lab ; 4 .. 9 :
107459: LD_ADDR_OWVAR 42
107463: PUSH
107464: LD_INT 6
107466: ST_TO_ADDR
107467: GO 108051
107469: LD_INT 4
107471: DOUBLE
107472: GREATEREQUAL
107473: IFFALSE 107481
107475: LD_INT 9
107477: DOUBLE
107478: LESSEQUAL
107479: IFTRUE 107483
107481: GO 107543
107483: POP
// begin bc_type := b_lab_half ;
107484: LD_ADDR_OWVAR 42
107488: PUSH
107489: LD_INT 7
107491: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107492: LD_ADDR_OWVAR 44
107496: PUSH
107497: LD_INT 10
107499: PUSH
107500: LD_INT 11
107502: PUSH
107503: LD_INT 12
107505: PUSH
107506: LD_INT 15
107508: PUSH
107509: LD_INT 14
107511: PUSH
107512: LD_INT 13
107514: PUSH
107515: EMPTY
107516: LIST
107517: LIST
107518: LIST
107519: LIST
107520: LIST
107521: LIST
107522: PUSH
107523: LD_VAR 0 2
107527: PUSH
107528: LD_INT 3
107530: MINUS
107531: ARRAY
107532: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
107533: LD_ADDR_OWVAR 45
107537: PUSH
107538: LD_INT 9
107540: ST_TO_ADDR
// end ; 10 .. 13 :
107541: GO 108051
107543: LD_INT 10
107545: DOUBLE
107546: GREATEREQUAL
107547: IFFALSE 107555
107549: LD_INT 13
107551: DOUBLE
107552: LESSEQUAL
107553: IFTRUE 107557
107555: GO 107634
107557: POP
// begin bc_type := b_lab_full ;
107558: LD_ADDR_OWVAR 42
107562: PUSH
107563: LD_INT 8
107565: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107566: LD_ADDR_OWVAR 44
107570: PUSH
107571: LD_INT 10
107573: PUSH
107574: LD_INT 12
107576: PUSH
107577: LD_INT 14
107579: PUSH
107580: LD_INT 13
107582: PUSH
107583: EMPTY
107584: LIST
107585: LIST
107586: LIST
107587: LIST
107588: PUSH
107589: LD_VAR 0 2
107593: PUSH
107594: LD_INT 9
107596: MINUS
107597: ARRAY
107598: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107599: LD_ADDR_OWVAR 45
107603: PUSH
107604: LD_INT 11
107606: PUSH
107607: LD_INT 15
107609: PUSH
107610: LD_INT 12
107612: PUSH
107613: LD_INT 15
107615: PUSH
107616: EMPTY
107617: LIST
107618: LIST
107619: LIST
107620: LIST
107621: PUSH
107622: LD_VAR 0 2
107626: PUSH
107627: LD_INT 9
107629: MINUS
107630: ARRAY
107631: ST_TO_ADDR
// end ; 14 :
107632: GO 108051
107634: LD_INT 14
107636: DOUBLE
107637: EQUAL
107638: IFTRUE 107642
107640: GO 107653
107642: POP
// bc_type := b_workshop ; 15 :
107643: LD_ADDR_OWVAR 42
107647: PUSH
107648: LD_INT 2
107650: ST_TO_ADDR
107651: GO 108051
107653: LD_INT 15
107655: DOUBLE
107656: EQUAL
107657: IFTRUE 107661
107659: GO 107672
107661: POP
// bc_type := b_factory ; 16 :
107662: LD_ADDR_OWVAR 42
107666: PUSH
107667: LD_INT 3
107669: ST_TO_ADDR
107670: GO 108051
107672: LD_INT 16
107674: DOUBLE
107675: EQUAL
107676: IFTRUE 107680
107678: GO 107691
107680: POP
// bc_type := b_ext_gun ; 17 :
107681: LD_ADDR_OWVAR 42
107685: PUSH
107686: LD_INT 17
107688: ST_TO_ADDR
107689: GO 108051
107691: LD_INT 17
107693: DOUBLE
107694: EQUAL
107695: IFTRUE 107699
107697: GO 107727
107699: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107700: LD_ADDR_OWVAR 42
107704: PUSH
107705: LD_INT 19
107707: PUSH
107708: LD_INT 23
107710: PUSH
107711: LD_INT 19
107713: PUSH
107714: EMPTY
107715: LIST
107716: LIST
107717: LIST
107718: PUSH
107719: LD_VAR 0 1
107723: ARRAY
107724: ST_TO_ADDR
107725: GO 108051
107727: LD_INT 18
107729: DOUBLE
107730: EQUAL
107731: IFTRUE 107735
107733: GO 107746
107735: POP
// bc_type := b_ext_radar ; 19 :
107736: LD_ADDR_OWVAR 42
107740: PUSH
107741: LD_INT 20
107743: ST_TO_ADDR
107744: GO 108051
107746: LD_INT 19
107748: DOUBLE
107749: EQUAL
107750: IFTRUE 107754
107752: GO 107765
107754: POP
// bc_type := b_ext_radio ; 20 :
107755: LD_ADDR_OWVAR 42
107759: PUSH
107760: LD_INT 22
107762: ST_TO_ADDR
107763: GO 108051
107765: LD_INT 20
107767: DOUBLE
107768: EQUAL
107769: IFTRUE 107773
107771: GO 107784
107773: POP
// bc_type := b_ext_siberium ; 21 :
107774: LD_ADDR_OWVAR 42
107778: PUSH
107779: LD_INT 21
107781: ST_TO_ADDR
107782: GO 108051
107784: LD_INT 21
107786: DOUBLE
107787: EQUAL
107788: IFTRUE 107792
107790: GO 107803
107792: POP
// bc_type := b_ext_computer ; 22 :
107793: LD_ADDR_OWVAR 42
107797: PUSH
107798: LD_INT 24
107800: ST_TO_ADDR
107801: GO 108051
107803: LD_INT 22
107805: DOUBLE
107806: EQUAL
107807: IFTRUE 107811
107809: GO 107822
107811: POP
// bc_type := b_ext_track ; 23 :
107812: LD_ADDR_OWVAR 42
107816: PUSH
107817: LD_INT 16
107819: ST_TO_ADDR
107820: GO 108051
107822: LD_INT 23
107824: DOUBLE
107825: EQUAL
107826: IFTRUE 107830
107828: GO 107841
107830: POP
// bc_type := b_ext_laser ; 24 :
107831: LD_ADDR_OWVAR 42
107835: PUSH
107836: LD_INT 25
107838: ST_TO_ADDR
107839: GO 108051
107841: LD_INT 24
107843: DOUBLE
107844: EQUAL
107845: IFTRUE 107849
107847: GO 107860
107849: POP
// bc_type := b_control_tower ; 25 :
107850: LD_ADDR_OWVAR 42
107854: PUSH
107855: LD_INT 36
107857: ST_TO_ADDR
107858: GO 108051
107860: LD_INT 25
107862: DOUBLE
107863: EQUAL
107864: IFTRUE 107868
107866: GO 107879
107868: POP
// bc_type := b_breastwork ; 26 :
107869: LD_ADDR_OWVAR 42
107873: PUSH
107874: LD_INT 31
107876: ST_TO_ADDR
107877: GO 108051
107879: LD_INT 26
107881: DOUBLE
107882: EQUAL
107883: IFTRUE 107887
107885: GO 107898
107887: POP
// bc_type := b_bunker ; 27 :
107888: LD_ADDR_OWVAR 42
107892: PUSH
107893: LD_INT 32
107895: ST_TO_ADDR
107896: GO 108051
107898: LD_INT 27
107900: DOUBLE
107901: EQUAL
107902: IFTRUE 107906
107904: GO 107917
107906: POP
// bc_type := b_turret ; 28 :
107907: LD_ADDR_OWVAR 42
107911: PUSH
107912: LD_INT 33
107914: ST_TO_ADDR
107915: GO 108051
107917: LD_INT 28
107919: DOUBLE
107920: EQUAL
107921: IFTRUE 107925
107923: GO 107936
107925: POP
// bc_type := b_armoury ; 29 :
107926: LD_ADDR_OWVAR 42
107930: PUSH
107931: LD_INT 4
107933: ST_TO_ADDR
107934: GO 108051
107936: LD_INT 29
107938: DOUBLE
107939: EQUAL
107940: IFTRUE 107944
107942: GO 107955
107944: POP
// bc_type := b_barracks ; 30 :
107945: LD_ADDR_OWVAR 42
107949: PUSH
107950: LD_INT 5
107952: ST_TO_ADDR
107953: GO 108051
107955: LD_INT 30
107957: DOUBLE
107958: EQUAL
107959: IFTRUE 107963
107961: GO 107974
107963: POP
// bc_type := b_solar_power ; 31 :
107964: LD_ADDR_OWVAR 42
107968: PUSH
107969: LD_INT 27
107971: ST_TO_ADDR
107972: GO 108051
107974: LD_INT 31
107976: DOUBLE
107977: EQUAL
107978: IFTRUE 107982
107980: GO 107993
107982: POP
// bc_type := b_oil_power ; 32 :
107983: LD_ADDR_OWVAR 42
107987: PUSH
107988: LD_INT 26
107990: ST_TO_ADDR
107991: GO 108051
107993: LD_INT 32
107995: DOUBLE
107996: EQUAL
107997: IFTRUE 108001
107999: GO 108012
108001: POP
// bc_type := b_siberite_power ; 33 :
108002: LD_ADDR_OWVAR 42
108006: PUSH
108007: LD_INT 28
108009: ST_TO_ADDR
108010: GO 108051
108012: LD_INT 33
108014: DOUBLE
108015: EQUAL
108016: IFTRUE 108020
108018: GO 108031
108020: POP
// bc_type := b_oil_mine ; 34 :
108021: LD_ADDR_OWVAR 42
108025: PUSH
108026: LD_INT 29
108028: ST_TO_ADDR
108029: GO 108051
108031: LD_INT 34
108033: DOUBLE
108034: EQUAL
108035: IFTRUE 108039
108037: GO 108050
108039: POP
// bc_type := b_siberite_mine ; end ;
108040: LD_ADDR_OWVAR 42
108044: PUSH
108045: LD_INT 30
108047: ST_TO_ADDR
108048: GO 108051
108050: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108051: LD_ADDR_VAR 0 8
108055: PUSH
108056: LD_VAR 0 5
108060: PPUSH
108061: LD_VAR 0 6
108065: PPUSH
108066: LD_VAR 0 3
108070: PPUSH
108071: CALL_OW 47
108075: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108076: LD_OWVAR 42
108080: PUSH
108081: LD_INT 32
108083: PUSH
108084: LD_INT 33
108086: PUSH
108087: EMPTY
108088: LIST
108089: LIST
108090: IN
108091: IFFALSE 108107
// PlaceWeaponTurret ( b , weapon ) ;
108093: LD_VAR 0 8
108097: PPUSH
108098: LD_VAR 0 4
108102: PPUSH
108103: CALL_OW 431
// end ;
108107: LD_VAR 0 7
108111: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108112: LD_INT 0
108114: PPUSH
108115: PPUSH
108116: PPUSH
108117: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108118: LD_ADDR_VAR 0 4
108122: PUSH
108123: LD_INT 22
108125: PUSH
108126: LD_OWVAR 2
108130: PUSH
108131: EMPTY
108132: LIST
108133: LIST
108134: PUSH
108135: LD_INT 2
108137: PUSH
108138: LD_INT 30
108140: PUSH
108141: LD_INT 0
108143: PUSH
108144: EMPTY
108145: LIST
108146: LIST
108147: PUSH
108148: LD_INT 30
108150: PUSH
108151: LD_INT 1
108153: PUSH
108154: EMPTY
108155: LIST
108156: LIST
108157: PUSH
108158: EMPTY
108159: LIST
108160: LIST
108161: LIST
108162: PUSH
108163: EMPTY
108164: LIST
108165: LIST
108166: PPUSH
108167: CALL_OW 69
108171: ST_TO_ADDR
// if not tmp then
108172: LD_VAR 0 4
108176: NOT
108177: IFFALSE 108181
// exit ;
108179: GO 108240
// for i in tmp do
108181: LD_ADDR_VAR 0 2
108185: PUSH
108186: LD_VAR 0 4
108190: PUSH
108191: FOR_IN
108192: IFFALSE 108238
// for j = 1 to 3 do
108194: LD_ADDR_VAR 0 3
108198: PUSH
108199: DOUBLE
108200: LD_INT 1
108202: DEC
108203: ST_TO_ADDR
108204: LD_INT 3
108206: PUSH
108207: FOR_TO
108208: IFFALSE 108234
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108210: LD_VAR 0 2
108214: PPUSH
108215: CALL_OW 274
108219: PPUSH
108220: LD_VAR 0 3
108224: PPUSH
108225: LD_INT 99999
108227: PPUSH
108228: CALL_OW 277
108232: GO 108207
108234: POP
108235: POP
108236: GO 108191
108238: POP
108239: POP
// end ;
108240: LD_VAR 0 1
108244: RET
// export function hHackSetLevel10 ; var i , j ; begin
108245: LD_INT 0
108247: PPUSH
108248: PPUSH
108249: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108250: LD_ADDR_VAR 0 2
108254: PUSH
108255: LD_INT 21
108257: PUSH
108258: LD_INT 1
108260: PUSH
108261: EMPTY
108262: LIST
108263: LIST
108264: PPUSH
108265: CALL_OW 69
108269: PUSH
108270: FOR_IN
108271: IFFALSE 108323
// if IsSelected ( i ) then
108273: LD_VAR 0 2
108277: PPUSH
108278: CALL_OW 306
108282: IFFALSE 108321
// begin for j := 1 to 4 do
108284: LD_ADDR_VAR 0 3
108288: PUSH
108289: DOUBLE
108290: LD_INT 1
108292: DEC
108293: ST_TO_ADDR
108294: LD_INT 4
108296: PUSH
108297: FOR_TO
108298: IFFALSE 108319
// SetSkill ( i , j , 10 ) ;
108300: LD_VAR 0 2
108304: PPUSH
108305: LD_VAR 0 3
108309: PPUSH
108310: LD_INT 10
108312: PPUSH
108313: CALL_OW 237
108317: GO 108297
108319: POP
108320: POP
// end ;
108321: GO 108270
108323: POP
108324: POP
// end ;
108325: LD_VAR 0 1
108329: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108330: LD_INT 0
108332: PPUSH
108333: PPUSH
108334: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108335: LD_ADDR_VAR 0 2
108339: PUSH
108340: LD_INT 22
108342: PUSH
108343: LD_OWVAR 2
108347: PUSH
108348: EMPTY
108349: LIST
108350: LIST
108351: PUSH
108352: LD_INT 21
108354: PUSH
108355: LD_INT 1
108357: PUSH
108358: EMPTY
108359: LIST
108360: LIST
108361: PUSH
108362: EMPTY
108363: LIST
108364: LIST
108365: PPUSH
108366: CALL_OW 69
108370: PUSH
108371: FOR_IN
108372: IFFALSE 108413
// begin for j := 1 to 4 do
108374: LD_ADDR_VAR 0 3
108378: PUSH
108379: DOUBLE
108380: LD_INT 1
108382: DEC
108383: ST_TO_ADDR
108384: LD_INT 4
108386: PUSH
108387: FOR_TO
108388: IFFALSE 108409
// SetSkill ( i , j , 10 ) ;
108390: LD_VAR 0 2
108394: PPUSH
108395: LD_VAR 0 3
108399: PPUSH
108400: LD_INT 10
108402: PPUSH
108403: CALL_OW 237
108407: GO 108387
108409: POP
108410: POP
// end ;
108411: GO 108371
108413: POP
108414: POP
// end ;
108415: LD_VAR 0 1
108419: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108420: LD_INT 0
108422: PPUSH
// uc_side := your_side ;
108423: LD_ADDR_OWVAR 20
108427: PUSH
108428: LD_OWVAR 2
108432: ST_TO_ADDR
// uc_nation := nation ;
108433: LD_ADDR_OWVAR 21
108437: PUSH
108438: LD_VAR 0 1
108442: ST_TO_ADDR
// InitHc ;
108443: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108447: LD_INT 0
108449: PPUSH
108450: LD_VAR 0 2
108454: PPUSH
108455: LD_VAR 0 3
108459: PPUSH
108460: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108464: LD_VAR 0 4
108468: PPUSH
108469: LD_VAR 0 5
108473: PPUSH
108474: CALL_OW 428
108478: PUSH
108479: LD_INT 0
108481: EQUAL
108482: IFFALSE 108506
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108484: CALL_OW 44
108488: PPUSH
108489: LD_VAR 0 4
108493: PPUSH
108494: LD_VAR 0 5
108498: PPUSH
108499: LD_INT 1
108501: PPUSH
108502: CALL_OW 48
// end ;
108506: LD_VAR 0 6
108510: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108511: LD_INT 0
108513: PPUSH
108514: PPUSH
// uc_side := your_side ;
108515: LD_ADDR_OWVAR 20
108519: PUSH
108520: LD_OWVAR 2
108524: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108525: LD_VAR 0 1
108529: PUSH
108530: LD_INT 1
108532: PUSH
108533: LD_INT 2
108535: PUSH
108536: LD_INT 3
108538: PUSH
108539: LD_INT 4
108541: PUSH
108542: LD_INT 5
108544: PUSH
108545: EMPTY
108546: LIST
108547: LIST
108548: LIST
108549: LIST
108550: LIST
108551: IN
108552: IFFALSE 108564
// uc_nation := nation_american else
108554: LD_ADDR_OWVAR 21
108558: PUSH
108559: LD_INT 1
108561: ST_TO_ADDR
108562: GO 108607
// if chassis in [ 11 , 12 , 13 , 14 ] then
108564: LD_VAR 0 1
108568: PUSH
108569: LD_INT 11
108571: PUSH
108572: LD_INT 12
108574: PUSH
108575: LD_INT 13
108577: PUSH
108578: LD_INT 14
108580: PUSH
108581: EMPTY
108582: LIST
108583: LIST
108584: LIST
108585: LIST
108586: IN
108587: IFFALSE 108599
// uc_nation := nation_arabian else
108589: LD_ADDR_OWVAR 21
108593: PUSH
108594: LD_INT 2
108596: ST_TO_ADDR
108597: GO 108607
// uc_nation := nation_russian ;
108599: LD_ADDR_OWVAR 21
108603: PUSH
108604: LD_INT 3
108606: ST_TO_ADDR
// vc_chassis := chassis ;
108607: LD_ADDR_OWVAR 37
108611: PUSH
108612: LD_VAR 0 1
108616: ST_TO_ADDR
// vc_engine := engine ;
108617: LD_ADDR_OWVAR 39
108621: PUSH
108622: LD_VAR 0 2
108626: ST_TO_ADDR
// vc_control := control ;
108627: LD_ADDR_OWVAR 38
108631: PUSH
108632: LD_VAR 0 3
108636: ST_TO_ADDR
// vc_weapon := weapon ;
108637: LD_ADDR_OWVAR 40
108641: PUSH
108642: LD_VAR 0 4
108646: ST_TO_ADDR
// un := CreateVehicle ;
108647: LD_ADDR_VAR 0 8
108651: PUSH
108652: CALL_OW 45
108656: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108657: LD_VAR 0 8
108661: PPUSH
108662: LD_INT 0
108664: PPUSH
108665: LD_INT 5
108667: PPUSH
108668: CALL_OW 12
108672: PPUSH
108673: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108677: LD_VAR 0 8
108681: PPUSH
108682: LD_VAR 0 5
108686: PPUSH
108687: LD_VAR 0 6
108691: PPUSH
108692: LD_INT 1
108694: PPUSH
108695: CALL_OW 48
// end ;
108699: LD_VAR 0 7
108703: RET
// export hInvincible ; every 1 do
108704: GO 108706
108706: DISABLE
// hInvincible := [ ] ;
108707: LD_ADDR_EXP 134
108711: PUSH
108712: EMPTY
108713: ST_TO_ADDR
108714: END
// every 10 do var i ;
108715: GO 108717
108717: DISABLE
108718: LD_INT 0
108720: PPUSH
// begin enable ;
108721: ENABLE
// if not hInvincible then
108722: LD_EXP 134
108726: NOT
108727: IFFALSE 108731
// exit ;
108729: GO 108775
// for i in hInvincible do
108731: LD_ADDR_VAR 0 1
108735: PUSH
108736: LD_EXP 134
108740: PUSH
108741: FOR_IN
108742: IFFALSE 108773
// if GetLives ( i ) < 1000 then
108744: LD_VAR 0 1
108748: PPUSH
108749: CALL_OW 256
108753: PUSH
108754: LD_INT 1000
108756: LESS
108757: IFFALSE 108771
// SetLives ( i , 1000 ) ;
108759: LD_VAR 0 1
108763: PPUSH
108764: LD_INT 1000
108766: PPUSH
108767: CALL_OW 234
108771: GO 108741
108773: POP
108774: POP
// end ;
108775: PPOPN 1
108777: END
// export function hHackInvincible ; var i ; begin
108778: LD_INT 0
108780: PPUSH
108781: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108782: LD_ADDR_VAR 0 2
108786: PUSH
108787: LD_INT 2
108789: PUSH
108790: LD_INT 21
108792: PUSH
108793: LD_INT 1
108795: PUSH
108796: EMPTY
108797: LIST
108798: LIST
108799: PUSH
108800: LD_INT 21
108802: PUSH
108803: LD_INT 2
108805: PUSH
108806: EMPTY
108807: LIST
108808: LIST
108809: PUSH
108810: EMPTY
108811: LIST
108812: LIST
108813: LIST
108814: PPUSH
108815: CALL_OW 69
108819: PUSH
108820: FOR_IN
108821: IFFALSE 108882
// if IsSelected ( i ) then
108823: LD_VAR 0 2
108827: PPUSH
108828: CALL_OW 306
108832: IFFALSE 108880
// begin if i in hInvincible then
108834: LD_VAR 0 2
108838: PUSH
108839: LD_EXP 134
108843: IN
108844: IFFALSE 108864
// hInvincible := hInvincible diff i else
108846: LD_ADDR_EXP 134
108850: PUSH
108851: LD_EXP 134
108855: PUSH
108856: LD_VAR 0 2
108860: DIFF
108861: ST_TO_ADDR
108862: GO 108880
// hInvincible := hInvincible union i ;
108864: LD_ADDR_EXP 134
108868: PUSH
108869: LD_EXP 134
108873: PUSH
108874: LD_VAR 0 2
108878: UNION
108879: ST_TO_ADDR
// end ;
108880: GO 108820
108882: POP
108883: POP
// end ;
108884: LD_VAR 0 1
108888: RET
// export function hHackInvisible ; var i , j ; begin
108889: LD_INT 0
108891: PPUSH
108892: PPUSH
108893: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108894: LD_ADDR_VAR 0 2
108898: PUSH
108899: LD_INT 21
108901: PUSH
108902: LD_INT 1
108904: PUSH
108905: EMPTY
108906: LIST
108907: LIST
108908: PPUSH
108909: CALL_OW 69
108913: PUSH
108914: FOR_IN
108915: IFFALSE 108939
// if IsSelected ( i ) then
108917: LD_VAR 0 2
108921: PPUSH
108922: CALL_OW 306
108926: IFFALSE 108937
// ComForceInvisible ( i ) ;
108928: LD_VAR 0 2
108932: PPUSH
108933: CALL_OW 496
108937: GO 108914
108939: POP
108940: POP
// end ;
108941: LD_VAR 0 1
108945: RET
// export function hHackChangeYourSide ; begin
108946: LD_INT 0
108948: PPUSH
// if your_side = 8 then
108949: LD_OWVAR 2
108953: PUSH
108954: LD_INT 8
108956: EQUAL
108957: IFFALSE 108969
// your_side := 0 else
108959: LD_ADDR_OWVAR 2
108963: PUSH
108964: LD_INT 0
108966: ST_TO_ADDR
108967: GO 108983
// your_side := your_side + 1 ;
108969: LD_ADDR_OWVAR 2
108973: PUSH
108974: LD_OWVAR 2
108978: PUSH
108979: LD_INT 1
108981: PLUS
108982: ST_TO_ADDR
// end ;
108983: LD_VAR 0 1
108987: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108988: LD_INT 0
108990: PPUSH
108991: PPUSH
108992: PPUSH
// for i in all_units do
108993: LD_ADDR_VAR 0 2
108997: PUSH
108998: LD_OWVAR 3
109002: PUSH
109003: FOR_IN
109004: IFFALSE 109082
// if IsSelected ( i ) then
109006: LD_VAR 0 2
109010: PPUSH
109011: CALL_OW 306
109015: IFFALSE 109080
// begin j := GetSide ( i ) ;
109017: LD_ADDR_VAR 0 3
109021: PUSH
109022: LD_VAR 0 2
109026: PPUSH
109027: CALL_OW 255
109031: ST_TO_ADDR
// if j = 8 then
109032: LD_VAR 0 3
109036: PUSH
109037: LD_INT 8
109039: EQUAL
109040: IFFALSE 109052
// j := 0 else
109042: LD_ADDR_VAR 0 3
109046: PUSH
109047: LD_INT 0
109049: ST_TO_ADDR
109050: GO 109066
// j := j + 1 ;
109052: LD_ADDR_VAR 0 3
109056: PUSH
109057: LD_VAR 0 3
109061: PUSH
109062: LD_INT 1
109064: PLUS
109065: ST_TO_ADDR
// SetSide ( i , j ) ;
109066: LD_VAR 0 2
109070: PPUSH
109071: LD_VAR 0 3
109075: PPUSH
109076: CALL_OW 235
// end ;
109080: GO 109003
109082: POP
109083: POP
// end ;
109084: LD_VAR 0 1
109088: RET
// export function hHackFog ; begin
109089: LD_INT 0
109091: PPUSH
// FogOff ( true ) ;
109092: LD_INT 1
109094: PPUSH
109095: CALL_OW 344
// end ;
109099: LD_VAR 0 1
109103: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109104: LD_INT 0
109106: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109107: LD_VAR 0 1
109111: PPUSH
109112: LD_VAR 0 2
109116: PPUSH
109117: LD_VAR 0 3
109121: PPUSH
109122: LD_INT 1
109124: PPUSH
109125: LD_INT 1
109127: PPUSH
109128: CALL_OW 483
// CenterOnXY ( x , y ) ;
109132: LD_VAR 0 2
109136: PPUSH
109137: LD_VAR 0 3
109141: PPUSH
109142: CALL_OW 84
// end ;
109146: LD_VAR 0 4
109150: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109151: LD_INT 0
109153: PPUSH
109154: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109155: LD_VAR 0 1
109159: NOT
109160: IFTRUE 109179
109162: PUSH
109163: LD_VAR 0 2
109167: PPUSH
109168: LD_VAR 0 3
109172: PPUSH
109173: CALL_OW 488
109177: NOT
109178: OR
109179: IFTRUE 109214
109181: PUSH
109182: LD_VAR 0 1
109186: PPUSH
109187: CALL_OW 266
109191: PUSH
109192: LD_INT 3
109194: NONEQUAL
109195: IFFALSE 109213
109197: PUSH
109198: LD_VAR 0 1
109202: PPUSH
109203: CALL_OW 247
109207: PUSH
109208: LD_INT 1
109210: EQUAL
109211: NOT
109212: AND
109213: OR
109214: IFFALSE 109218
// exit ;
109216: GO 109500
// if GetType ( factory ) = unit_human then
109218: LD_VAR 0 1
109222: PPUSH
109223: CALL_OW 247
109227: PUSH
109228: LD_INT 1
109230: EQUAL
109231: IFFALSE 109248
// factory := IsInUnit ( factory ) ;
109233: LD_ADDR_VAR 0 1
109237: PUSH
109238: LD_VAR 0 1
109242: PPUSH
109243: CALL_OW 310
109247: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109248: LD_VAR 0 1
109252: PPUSH
109253: CALL_OW 266
109257: PUSH
109258: LD_INT 3
109260: NONEQUAL
109261: IFFALSE 109265
// exit ;
109263: GO 109500
// for i := 1 to Count ( factoryWaypoints ) do
109265: LD_ADDR_VAR 0 5
109269: PUSH
109270: DOUBLE
109271: LD_INT 1
109273: DEC
109274: ST_TO_ADDR
109275: LD_EXP 135
109279: PPUSH
109280: CALL 22179 0 1
109284: PUSH
109285: FOR_TO
109286: IFFALSE 109448
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
109288: LD_VAR 0 2
109292: PPUSH
109293: LD_VAR 0 3
109297: PPUSH
109298: CALL_OW 428
109302: PUSH
109303: LD_EXP 135
109307: PUSH
109308: LD_VAR 0 5
109312: ARRAY
109313: PUSH
109314: LD_INT 2
109316: ARRAY
109317: EQUAL
109318: IFFALSE 109350
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
109320: LD_ADDR_EXP 135
109324: PUSH
109325: LD_EXP 135
109329: PPUSH
109330: LD_VAR 0 5
109334: PPUSH
109335: CALL_OW 3
109339: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109340: CALL 109505 0 0
// exit ;
109344: POP
109345: POP
109346: GO 109500
// end else
109348: GO 109446
// if factory = factoryWaypoints [ i ] [ 2 ] then
109350: LD_VAR 0 1
109354: PUSH
109355: LD_EXP 135
109359: PUSH
109360: LD_VAR 0 5
109364: ARRAY
109365: PUSH
109366: LD_INT 2
109368: ARRAY
109369: EQUAL
109370: IFFALSE 109446
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
109372: LD_ADDR_EXP 135
109376: PUSH
109377: LD_EXP 135
109381: PPUSH
109382: LD_VAR 0 5
109386: PPUSH
109387: CALL_OW 3
109391: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
109392: LD_ADDR_EXP 135
109396: PUSH
109397: LD_EXP 135
109401: PPUSH
109402: LD_VAR 0 1
109406: PPUSH
109407: CALL_OW 255
109411: PUSH
109412: LD_VAR 0 1
109416: PUSH
109417: LD_VAR 0 2
109421: PUSH
109422: LD_VAR 0 3
109426: PUSH
109427: EMPTY
109428: LIST
109429: LIST
109430: LIST
109431: LIST
109432: PPUSH
109433: CALL 58111 0 2
109437: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109438: CALL 109505 0 0
// exit ;
109442: POP
109443: POP
109444: GO 109500
// end ; end ;
109446: GO 109285
109448: POP
109449: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
109450: LD_ADDR_EXP 135
109454: PUSH
109455: LD_EXP 135
109459: PPUSH
109460: LD_VAR 0 1
109464: PPUSH
109465: CALL_OW 255
109469: PUSH
109470: LD_VAR 0 1
109474: PUSH
109475: LD_VAR 0 2
109479: PUSH
109480: LD_VAR 0 3
109484: PUSH
109485: EMPTY
109486: LIST
109487: LIST
109488: LIST
109489: LIST
109490: PPUSH
109491: CALL 58111 0 2
109495: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109496: CALL 109505 0 0
// end ;
109500: LD_VAR 0 4
109504: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109505: LD_INT 0
109507: PPUSH
109508: PPUSH
109509: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109510: LD_STRING resetFactoryWaypoint();
109512: PPUSH
109513: CALL_OW 559
// if factoryWaypoints then
109517: LD_EXP 135
109521: IFFALSE 109642
// begin list := factoryWaypoints ;
109523: LD_ADDR_VAR 0 3
109527: PUSH
109528: LD_EXP 135
109532: ST_TO_ADDR
// for i := 1 to list do
109533: LD_ADDR_VAR 0 2
109537: PUSH
109538: DOUBLE
109539: LD_INT 1
109541: DEC
109542: ST_TO_ADDR
109543: LD_VAR 0 3
109547: PUSH
109548: FOR_TO
109549: IFFALSE 109640
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109551: LD_STRING setFactoryWaypointXY(
109553: PUSH
109554: LD_VAR 0 3
109558: PUSH
109559: LD_VAR 0 2
109563: ARRAY
109564: PUSH
109565: LD_INT 1
109567: ARRAY
109568: STR
109569: PUSH
109570: LD_STRING ,
109572: STR
109573: PUSH
109574: LD_VAR 0 3
109578: PUSH
109579: LD_VAR 0 2
109583: ARRAY
109584: PUSH
109585: LD_INT 2
109587: ARRAY
109588: STR
109589: PUSH
109590: LD_STRING ,
109592: STR
109593: PUSH
109594: LD_VAR 0 3
109598: PUSH
109599: LD_VAR 0 2
109603: ARRAY
109604: PUSH
109605: LD_INT 3
109607: ARRAY
109608: STR
109609: PUSH
109610: LD_STRING ,
109612: STR
109613: PUSH
109614: LD_VAR 0 3
109618: PUSH
109619: LD_VAR 0 2
109623: ARRAY
109624: PUSH
109625: LD_INT 4
109627: ARRAY
109628: STR
109629: PUSH
109630: LD_STRING )
109632: STR
109633: PPUSH
109634: CALL_OW 559
109638: GO 109548
109640: POP
109641: POP
// end ; end ;
109642: LD_VAR 0 1
109646: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109647: LD_INT 0
109649: PPUSH
// if HexInfo ( x , y ) = warehouse then
109650: LD_VAR 0 2
109654: PPUSH
109655: LD_VAR 0 3
109659: PPUSH
109660: CALL_OW 428
109664: PUSH
109665: LD_VAR 0 1
109669: EQUAL
109670: IFFALSE 109697
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109672: LD_ADDR_EXP 137
109676: PUSH
109677: LD_EXP 137
109681: PPUSH
109682: LD_VAR 0 1
109686: PPUSH
109687: LD_INT 0
109689: PPUSH
109690: CALL_OW 1
109694: ST_TO_ADDR
109695: GO 109748
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109697: LD_ADDR_EXP 137
109701: PUSH
109702: LD_EXP 137
109706: PPUSH
109707: LD_VAR 0 1
109711: PPUSH
109712: LD_VAR 0 1
109716: PPUSH
109717: CALL_OW 255
109721: PUSH
109722: LD_VAR 0 1
109726: PUSH
109727: LD_VAR 0 2
109731: PUSH
109732: LD_VAR 0 3
109736: PUSH
109737: EMPTY
109738: LIST
109739: LIST
109740: LIST
109741: LIST
109742: PPUSH
109743: CALL_OW 1
109747: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109748: CALL 109757 0 0
// end ;
109752: LD_VAR 0 4
109756: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109757: LD_INT 0
109759: PPUSH
109760: PPUSH
109761: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109762: LD_STRING resetWarehouseGatheringPoints();
109764: PPUSH
109765: CALL_OW 559
// if warehouseGatheringPoints then
109769: LD_EXP 137
109773: IFFALSE 109899
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109775: LD_ADDR_VAR 0 3
109779: PUSH
109780: LD_EXP 137
109784: PPUSH
109785: CALL 62045 0 1
109789: ST_TO_ADDR
// for i := 1 to list do
109790: LD_ADDR_VAR 0 2
109794: PUSH
109795: DOUBLE
109796: LD_INT 1
109798: DEC
109799: ST_TO_ADDR
109800: LD_VAR 0 3
109804: PUSH
109805: FOR_TO
109806: IFFALSE 109897
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109808: LD_STRING setWarehouseGatheringPointXY(
109810: PUSH
109811: LD_VAR 0 3
109815: PUSH
109816: LD_VAR 0 2
109820: ARRAY
109821: PUSH
109822: LD_INT 1
109824: ARRAY
109825: STR
109826: PUSH
109827: LD_STRING ,
109829: STR
109830: PUSH
109831: LD_VAR 0 3
109835: PUSH
109836: LD_VAR 0 2
109840: ARRAY
109841: PUSH
109842: LD_INT 2
109844: ARRAY
109845: STR
109846: PUSH
109847: LD_STRING ,
109849: STR
109850: PUSH
109851: LD_VAR 0 3
109855: PUSH
109856: LD_VAR 0 2
109860: ARRAY
109861: PUSH
109862: LD_INT 3
109864: ARRAY
109865: STR
109866: PUSH
109867: LD_STRING ,
109869: STR
109870: PUSH
109871: LD_VAR 0 3
109875: PUSH
109876: LD_VAR 0 2
109880: ARRAY
109881: PUSH
109882: LD_INT 4
109884: ARRAY
109885: STR
109886: PUSH
109887: LD_STRING )
109889: STR
109890: PPUSH
109891: CALL_OW 559
109895: GO 109805
109897: POP
109898: POP
// end ; end ;
109899: LD_VAR 0 1
109903: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109904: LD_EXP 137
109908: IFFALSE 110603
109910: GO 109912
109912: DISABLE
109913: LD_INT 0
109915: PPUSH
109916: PPUSH
109917: PPUSH
109918: PPUSH
109919: PPUSH
109920: PPUSH
109921: PPUSH
109922: PPUSH
109923: PPUSH
// begin enable ;
109924: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109925: LD_ADDR_VAR 0 3
109929: PUSH
109930: LD_EXP 137
109934: PPUSH
109935: CALL 62045 0 1
109939: ST_TO_ADDR
// if not list then
109940: LD_VAR 0 3
109944: NOT
109945: IFFALSE 109949
// exit ;
109947: GO 110603
// for i := 1 to list do
109949: LD_ADDR_VAR 0 1
109953: PUSH
109954: DOUBLE
109955: LD_INT 1
109957: DEC
109958: ST_TO_ADDR
109959: LD_VAR 0 3
109963: PUSH
109964: FOR_TO
109965: IFFALSE 110601
// begin depot := list [ i ] [ 2 ] ;
109967: LD_ADDR_VAR 0 8
109971: PUSH
109972: LD_VAR 0 3
109976: PUSH
109977: LD_VAR 0 1
109981: ARRAY
109982: PUSH
109983: LD_INT 2
109985: ARRAY
109986: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109987: LD_ADDR_VAR 0 5
109991: PUSH
109992: LD_VAR 0 3
109996: PUSH
109997: LD_VAR 0 1
110001: ARRAY
110002: PUSH
110003: LD_INT 1
110005: ARRAY
110006: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
110007: LD_VAR 0 8
110011: PPUSH
110012: CALL_OW 301
110016: IFTRUE 110035
110018: PUSH
110019: LD_VAR 0 5
110023: PUSH
110024: LD_VAR 0 8
110028: PPUSH
110029: CALL_OW 255
110033: NONEQUAL
110034: OR
110035: IFFALSE 110064
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
110037: LD_ADDR_EXP 137
110041: PUSH
110042: LD_EXP 137
110046: PPUSH
110047: LD_VAR 0 8
110051: PPUSH
110052: LD_INT 0
110054: PPUSH
110055: CALL_OW 1
110059: ST_TO_ADDR
// exit ;
110060: POP
110061: POP
110062: GO 110603
// end ; x := list [ i ] [ 3 ] ;
110064: LD_ADDR_VAR 0 6
110068: PUSH
110069: LD_VAR 0 3
110073: PUSH
110074: LD_VAR 0 1
110078: ARRAY
110079: PUSH
110080: LD_INT 3
110082: ARRAY
110083: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
110084: LD_ADDR_VAR 0 7
110088: PUSH
110089: LD_VAR 0 3
110093: PUSH
110094: LD_VAR 0 1
110098: ARRAY
110099: PUSH
110100: LD_INT 4
110102: ARRAY
110103: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
110104: LD_ADDR_VAR 0 9
110108: PUSH
110109: LD_VAR 0 6
110113: PPUSH
110114: LD_VAR 0 7
110118: PPUSH
110119: LD_INT 16
110121: PPUSH
110122: CALL 60619 0 3
110126: ST_TO_ADDR
// if not cratesNearbyPoint then
110127: LD_VAR 0 9
110131: NOT
110132: IFFALSE 110138
// exit ;
110134: POP
110135: POP
110136: GO 110603
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
110138: LD_ADDR_VAR 0 4
110142: PUSH
110143: LD_INT 22
110145: PUSH
110146: LD_VAR 0 5
110150: PUSH
110151: EMPTY
110152: LIST
110153: LIST
110154: PUSH
110155: LD_INT 3
110157: PUSH
110158: LD_INT 60
110160: PUSH
110161: EMPTY
110162: LIST
110163: PUSH
110164: EMPTY
110165: LIST
110166: LIST
110167: PUSH
110168: LD_INT 91
110170: PUSH
110171: LD_VAR 0 8
110175: PUSH
110176: LD_INT 6
110178: PUSH
110179: EMPTY
110180: LIST
110181: LIST
110182: LIST
110183: PUSH
110184: LD_INT 2
110186: PUSH
110187: LD_INT 25
110189: PUSH
110190: LD_INT 2
110192: PUSH
110193: EMPTY
110194: LIST
110195: LIST
110196: PUSH
110197: LD_INT 25
110199: PUSH
110200: LD_INT 16
110202: PUSH
110203: EMPTY
110204: LIST
110205: LIST
110206: PUSH
110207: EMPTY
110208: LIST
110209: LIST
110210: LIST
110211: PUSH
110212: EMPTY
110213: LIST
110214: LIST
110215: LIST
110216: LIST
110217: PPUSH
110218: CALL_OW 69
110222: PUSH
110223: LD_VAR 0 8
110227: PPUSH
110228: CALL_OW 313
110232: PPUSH
110233: LD_INT 3
110235: PUSH
110236: LD_INT 60
110238: PUSH
110239: EMPTY
110240: LIST
110241: PUSH
110242: EMPTY
110243: LIST
110244: LIST
110245: PUSH
110246: LD_INT 2
110248: PUSH
110249: LD_INT 25
110251: PUSH
110252: LD_INT 2
110254: PUSH
110255: EMPTY
110256: LIST
110257: LIST
110258: PUSH
110259: LD_INT 25
110261: PUSH
110262: LD_INT 16
110264: PUSH
110265: EMPTY
110266: LIST
110267: LIST
110268: PUSH
110269: EMPTY
110270: LIST
110271: LIST
110272: LIST
110273: PUSH
110274: EMPTY
110275: LIST
110276: LIST
110277: PPUSH
110278: CALL_OW 72
110282: UNION
110283: ST_TO_ADDR
// if tmp then
110284: LD_VAR 0 4
110288: IFFALSE 110368
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110290: LD_ADDR_VAR 0 4
110294: PUSH
110295: LD_VAR 0 4
110299: PPUSH
110300: LD_INT 3
110302: PPUSH
110303: CALL 58426 0 2
110307: ST_TO_ADDR
// for j in tmp do
110308: LD_ADDR_VAR 0 2
110312: PUSH
110313: LD_VAR 0 4
110317: PUSH
110318: FOR_IN
110319: IFFALSE 110362
// begin if IsInUnit ( j ) then
110321: LD_VAR 0 2
110325: PPUSH
110326: CALL_OW 310
110330: IFFALSE 110341
// ComExit ( j ) ;
110332: LD_VAR 0 2
110336: PPUSH
110337: CALL 58509 0 1
// AddComCollect ( j , x , y ) ;
110341: LD_VAR 0 2
110345: PPUSH
110346: LD_VAR 0 6
110350: PPUSH
110351: LD_VAR 0 7
110355: PPUSH
110356: CALL_OW 177
// end ;
110360: GO 110318
110362: POP
110363: POP
// exit ;
110364: POP
110365: POP
110366: GO 110603
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110368: LD_ADDR_VAR 0 4
110372: PUSH
110373: LD_INT 22
110375: PUSH
110376: LD_VAR 0 5
110380: PUSH
110381: EMPTY
110382: LIST
110383: LIST
110384: PUSH
110385: LD_INT 91
110387: PUSH
110388: LD_VAR 0 8
110392: PUSH
110393: LD_INT 8
110395: PUSH
110396: EMPTY
110397: LIST
110398: LIST
110399: LIST
110400: PUSH
110401: LD_INT 2
110403: PUSH
110404: LD_INT 34
110406: PUSH
110407: LD_INT 12
110409: PUSH
110410: EMPTY
110411: LIST
110412: LIST
110413: PUSH
110414: LD_INT 34
110416: PUSH
110417: LD_INT 51
110419: PUSH
110420: EMPTY
110421: LIST
110422: LIST
110423: PUSH
110424: LD_INT 34
110426: PUSH
110427: LD_INT 32
110429: PUSH
110430: EMPTY
110431: LIST
110432: LIST
110433: PUSH
110434: LD_INT 34
110436: PUSH
110437: LD_INT 89
110439: PUSH
110440: EMPTY
110441: LIST
110442: LIST
110443: PUSH
110444: EMPTY
110445: LIST
110446: LIST
110447: LIST
110448: LIST
110449: LIST
110450: PUSH
110451: EMPTY
110452: LIST
110453: LIST
110454: LIST
110455: PPUSH
110456: CALL_OW 69
110460: ST_TO_ADDR
// if tmp then
110461: LD_VAR 0 4
110465: IFFALSE 110599
// begin for j in tmp do
110467: LD_ADDR_VAR 0 2
110471: PUSH
110472: LD_VAR 0 4
110476: PUSH
110477: FOR_IN
110478: IFFALSE 110597
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110480: LD_VAR 0 2
110484: PPUSH
110485: CALL_OW 262
110489: PUSH
110490: LD_INT 3
110492: EQUAL
110493: IFTRUE 110510
110495: PUSH
110496: LD_VAR 0 2
110500: PPUSH
110501: CALL_OW 261
110505: PUSH
110506: LD_INT 20
110508: GREATER
110509: OR
110510: IFFALSE 110524
110512: PUSH
110513: LD_VAR 0 2
110517: PPUSH
110518: CALL_OW 314
110522: NOT
110523: AND
110524: IFFALSE 110554
110526: PUSH
110527: LD_VAR 0 2
110531: PPUSH
110532: CALL_OW 263
110536: PUSH
110537: LD_INT 1
110539: NONEQUAL
110540: IFTRUE 110553
110542: PUSH
110543: LD_VAR 0 2
110547: PPUSH
110548: CALL_OW 311
110552: OR
110553: AND
110554: IFFALSE 110595
// begin ComCollect ( j , x , y ) ;
110556: LD_VAR 0 2
110560: PPUSH
110561: LD_VAR 0 6
110565: PPUSH
110566: LD_VAR 0 7
110570: PPUSH
110571: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110575: LD_VAR 0 2
110579: PPUSH
110580: LD_VAR 0 8
110584: PPUSH
110585: CALL_OW 172
// exit ;
110589: POP
110590: POP
110591: POP
110592: POP
110593: GO 110603
// end ;
110595: GO 110477
110597: POP
110598: POP
// end ; end ;
110599: GO 109964
110601: POP
110602: POP
// end ; end_of_file
110603: PPOPN 9
110605: END
// export function SOS_UnitDestroyed ( un ) ; begin
110606: LD_INT 0
110608: PPUSH
// ComRadiation ( un ) ;
110609: LD_VAR 0 1
110613: PPUSH
110614: CALL 111695 0 1
// end ;
110618: LD_VAR 0 2
110622: RET
// export function SOS_UnitKamikazed ( un ) ; begin
110623: LD_INT 0
110625: PPUSH
// ComRadiation ( un ) ;
110626: LD_VAR 0 1
110630: PPUSH
110631: CALL 111695 0 1
// end ;
110635: LD_VAR 0 2
110639: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
110640: LD_INT 0
110642: PPUSH
// end ;
110643: LD_VAR 0 4
110647: RET
// export function SOS_Command ( cmd ) ; begin
110648: LD_INT 0
110650: PPUSH
// end ;
110651: LD_VAR 0 2
110655: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
110656: LD_INT 0
110658: PPUSH
// end ;
110659: LD_VAR 0 6
110663: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
110664: LD_INT 0
110666: PPUSH
110667: PPUSH
110668: PPUSH
110669: PPUSH
// if not vehicle or not factory then
110670: LD_VAR 0 1
110674: NOT
110675: IFTRUE 110684
110677: PUSH
110678: LD_VAR 0 2
110682: NOT
110683: OR
110684: IFFALSE 110688
// exit ;
110686: GO 111270
// if not factoryWaypoints then
110688: LD_EXP 135
110692: NOT
110693: IFFALSE 110697
// exit ;
110695: GO 111270
// for i := 1 to Count ( factoryWaypoints ) do
110697: LD_ADDR_VAR 0 4
110701: PUSH
110702: DOUBLE
110703: LD_INT 1
110705: DEC
110706: ST_TO_ADDR
110707: LD_EXP 135
110711: PPUSH
110712: CALL 22179 0 1
110716: PUSH
110717: FOR_TO
110718: IFFALSE 111268
// if factoryWaypoints [ i ] [ 2 ] = factory then
110720: LD_EXP 135
110724: PUSH
110725: LD_VAR 0 4
110729: ARRAY
110730: PUSH
110731: LD_INT 2
110733: ARRAY
110734: PUSH
110735: LD_VAR 0 2
110739: EQUAL
110740: IFFALSE 111266
// begin if GetControl ( vehicle ) = control_manual then
110742: LD_VAR 0 1
110746: PPUSH
110747: CALL_OW 263
110751: PUSH
110752: LD_INT 1
110754: EQUAL
110755: IFFALSE 111119
// begin driver := IsDrivenBy ( vehicle ) ;
110757: LD_ADDR_VAR 0 5
110761: PUSH
110762: LD_VAR 0 1
110766: PPUSH
110767: CALL_OW 311
110771: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
110772: LD_VAR 0 5
110776: PUSH
110777: LD_EXP 136
110781: IN
110782: IFTRUE 110796
110784: PUSH
110785: LD_VAR 0 1
110789: PUSH
110790: LD_EXP 136
110794: IN
110795: OR
110796: IFFALSE 110802
// exit ;
110798: POP
110799: POP
110800: GO 111270
// if not HasTask ( driver ) then
110802: LD_VAR 0 5
110806: PPUSH
110807: CALL_OW 314
110811: NOT
110812: IFFALSE 111117
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
110814: LD_ADDR_EXP 136
110818: PUSH
110819: LD_EXP 136
110823: PPUSH
110824: LD_VAR 0 5
110828: PPUSH
110829: CALL 58111 0 2
110833: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
110834: LD_ADDR_EXP 136
110838: PUSH
110839: LD_EXP 136
110843: PPUSH
110844: LD_VAR 0 1
110848: PPUSH
110849: CALL 58111 0 2
110853: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
110854: LD_ADDR_VAR 0 6
110858: PUSH
110859: LD_EXP 135
110863: PUSH
110864: LD_VAR 0 4
110868: ARRAY
110869: PUSH
110870: LD_INT 3
110872: ARRAY
110873: PPUSH
110874: LD_EXP 135
110878: PUSH
110879: LD_VAR 0 4
110883: ARRAY
110884: PUSH
110885: LD_INT 4
110887: ARRAY
110888: PPUSH
110889: CALL_OW 428
110893: ST_TO_ADDR
// if hex then
110894: LD_VAR 0 6
110898: IFFALSE 110916
// ComMoveUnit ( driver , hex ) else
110900: LD_VAR 0 5
110904: PPUSH
110905: LD_VAR 0 6
110909: PPUSH
110910: CALL_OW 112
110914: GO 111000
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
110916: LD_VAR 0 1
110920: PPUSH
110921: LD_EXP 135
110925: PUSH
110926: LD_VAR 0 4
110930: ARRAY
110931: PUSH
110932: LD_INT 3
110934: ARRAY
110935: PPUSH
110936: LD_EXP 135
110940: PUSH
110941: LD_VAR 0 4
110945: ARRAY
110946: PUSH
110947: LD_INT 4
110949: ARRAY
110950: PPUSH
110951: CALL_OW 297
110955: PUSH
110956: LD_INT 0
110958: GREATER
110959: IFFALSE 111000
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
110961: LD_VAR 0 5
110965: PPUSH
110966: LD_EXP 135
110970: PUSH
110971: LD_VAR 0 4
110975: ARRAY
110976: PUSH
110977: LD_INT 3
110979: ARRAY
110980: PPUSH
110981: LD_EXP 135
110985: PUSH
110986: LD_VAR 0 4
110990: ARRAY
110991: PUSH
110992: LD_INT 4
110994: ARRAY
110995: PPUSH
110996: CALL_OW 111
// AddComExitVehicle ( driver ) ;
111000: LD_VAR 0 5
111004: PPUSH
111005: CALL_OW 181
// if Multiplayer then
111009: LD_OWVAR 4
111013: IFFALSE 111062
// begin repeat wait ( 10 ) ;
111015: LD_INT 10
111017: PPUSH
111018: CALL_OW 67
// until not IsInUnit ( driver ) ;
111022: LD_VAR 0 5
111026: PPUSH
111027: CALL_OW 310
111031: NOT
111032: IFFALSE 111015
// if not HasTask ( driver ) then
111034: LD_VAR 0 5
111038: PPUSH
111039: CALL_OW 314
111043: NOT
111044: IFFALSE 111060
// ComEnterUnit ( driver , factory ) ;
111046: LD_VAR 0 5
111050: PPUSH
111051: LD_VAR 0 2
111055: PPUSH
111056: CALL_OW 120
// end else
111060: GO 111076
// AddComEnterUnit ( driver , factory ) ;
111062: LD_VAR 0 5
111066: PPUSH
111067: LD_VAR 0 2
111071: PPUSH
111072: CALL_OW 180
// wait ( 0 0$1 ) ;
111076: LD_INT 35
111078: PPUSH
111079: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
111083: LD_ADDR_EXP 136
111087: PUSH
111088: LD_EXP 136
111092: PUSH
111093: LD_VAR 0 5
111097: DIFF
111098: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
111099: LD_ADDR_EXP 136
111103: PUSH
111104: LD_EXP 136
111108: PUSH
111109: LD_VAR 0 1
111113: DIFF
111114: ST_TO_ADDR
// break ;
111115: GO 111268
// end ; end else
111117: GO 111266
// if GetControl ( vehicle ) = control_remote then
111119: LD_VAR 0 1
111123: PPUSH
111124: CALL_OW 263
111128: PUSH
111129: LD_INT 2
111131: EQUAL
111132: IFFALSE 111218
// begin wait ( 0 0$2 ) ;
111134: LD_INT 70
111136: PPUSH
111137: CALL_OW 67
// repeat wait ( 10 ) ;
111141: LD_INT 10
111143: PPUSH
111144: CALL_OW 67
// Connect ( vehicle ) ;
111148: LD_VAR 0 1
111152: PPUSH
111153: CALL 28423 0 1
// until IsControledBy ( vehicle ) ;
111157: LD_VAR 0 1
111161: PPUSH
111162: CALL_OW 312
111166: IFFALSE 111141
// wait ( 10 ) ;
111168: LD_INT 10
111170: PPUSH
111171: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
111175: LD_VAR 0 1
111179: PPUSH
111180: LD_EXP 135
111184: PUSH
111185: LD_VAR 0 4
111189: ARRAY
111190: PUSH
111191: LD_INT 3
111193: ARRAY
111194: PPUSH
111195: LD_EXP 135
111199: PUSH
111200: LD_VAR 0 4
111204: ARRAY
111205: PUSH
111206: LD_INT 4
111208: ARRAY
111209: PPUSH
111210: CALL_OW 111
// break ;
111214: GO 111268
// end else
111216: GO 111266
// begin wait ( 0 0$3 ) ;
111218: LD_INT 105
111220: PPUSH
111221: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
111225: LD_VAR 0 1
111229: PPUSH
111230: LD_EXP 135
111234: PUSH
111235: LD_VAR 0 4
111239: ARRAY
111240: PUSH
111241: LD_INT 3
111243: ARRAY
111244: PPUSH
111245: LD_EXP 135
111249: PUSH
111250: LD_VAR 0 4
111254: ARRAY
111255: PUSH
111256: LD_INT 4
111258: ARRAY
111259: PPUSH
111260: CALL_OW 111
// break ;
111264: GO 111268
// end ; end ;
111266: GO 110717
111268: POP
111269: POP
// end ;
111270: LD_VAR 0 3
111274: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
111275: LD_INT 0
111277: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
111278: LD_VAR 0 1
111282: PUSH
111283: LD_INT 250
111285: EQUAL
111286: IFFALSE 111303
111288: PUSH
111289: LD_VAR 0 2
111293: PPUSH
111294: CALL_OW 264
111298: PUSH
111299: LD_INT 81
111301: EQUAL
111302: AND
111303: IFFALSE 111324
// MinerPlaceMine ( unit , x , y ) ;
111305: LD_VAR 0 2
111309: PPUSH
111310: LD_VAR 0 4
111314: PPUSH
111315: LD_VAR 0 5
111319: PPUSH
111320: CALL 114456 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
111324: LD_VAR 0 1
111328: PUSH
111329: LD_INT 251
111331: EQUAL
111332: IFFALSE 111349
111334: PUSH
111335: LD_VAR 0 2
111339: PPUSH
111340: CALL_OW 264
111344: PUSH
111345: LD_INT 81
111347: EQUAL
111348: AND
111349: IFFALSE 111370
// MinerDetonateMine ( unit , x , y ) ;
111351: LD_VAR 0 2
111355: PPUSH
111356: LD_VAR 0 4
111360: PPUSH
111361: LD_VAR 0 5
111365: PPUSH
111366: CALL 114735 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
111370: LD_VAR 0 1
111374: PUSH
111375: LD_INT 252
111377: EQUAL
111378: IFFALSE 111395
111380: PUSH
111381: LD_VAR 0 2
111385: PPUSH
111386: CALL_OW 264
111390: PUSH
111391: LD_INT 81
111393: EQUAL
111394: AND
111395: IFFALSE 111416
// MinerCreateMinefield ( unit , x , y ) ;
111397: LD_VAR 0 2
111401: PPUSH
111402: LD_VAR 0 4
111406: PPUSH
111407: LD_VAR 0 5
111411: PPUSH
111412: CALL 115154 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
111416: LD_VAR 0 1
111420: PUSH
111421: LD_INT 253
111423: EQUAL
111424: IFFALSE 111441
111426: PUSH
111427: LD_VAR 0 2
111431: PPUSH
111432: CALL_OW 257
111436: PUSH
111437: LD_INT 5
111439: EQUAL
111440: AND
111441: IFFALSE 111462
// ComBinocular ( unit , x , y ) ;
111443: LD_VAR 0 2
111447: PPUSH
111448: LD_VAR 0 4
111452: PPUSH
111453: LD_VAR 0 5
111457: PPUSH
111458: CALL 115529 0 3
// if selectedUnit then
111462: LD_VAR 0 3
111466: IFFALSE 111526
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
111468: LD_VAR 0 1
111472: PUSH
111473: LD_INT 254
111475: EQUAL
111476: IFFALSE 111493
111478: PUSH
111479: LD_VAR 0 2
111483: PPUSH
111484: CALL_OW 264
111488: PUSH
111489: LD_INT 99
111491: EQUAL
111492: AND
111493: IFFALSE 111510
111495: PUSH
111496: LD_VAR 0 3
111500: PPUSH
111501: CALL_OW 263
111505: PUSH
111506: LD_INT 3
111508: EQUAL
111509: AND
111510: IFFALSE 111526
// HackDestroyVehicle ( unit , selectedUnit ) ;
111512: LD_VAR 0 2
111516: PPUSH
111517: LD_VAR 0 3
111521: PPUSH
111522: CALL 113816 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
111526: LD_VAR 0 1
111530: PUSH
111531: LD_INT 255
111533: EQUAL
111534: IFFALSE 111558
111536: PUSH
111537: LD_VAR 0 2
111541: PPUSH
111542: CALL_OW 264
111546: PUSH
111547: LD_INT 14
111549: PUSH
111550: LD_INT 53
111552: PUSH
111553: EMPTY
111554: LIST
111555: LIST
111556: IN
111557: AND
111558: IFFALSE 111576
111560: PUSH
111561: LD_VAR 0 4
111565: PPUSH
111566: LD_VAR 0 5
111570: PPUSH
111571: CALL_OW 488
111575: AND
111576: IFFALSE 111600
// CutTreeXYR ( unit , x , y , 12 ) ;
111578: LD_VAR 0 2
111582: PPUSH
111583: LD_VAR 0 4
111587: PPUSH
111588: LD_VAR 0 5
111592: PPUSH
111593: LD_INT 12
111595: PPUSH
111596: CALL 111791 0 4
// if cmd = 256 then
111600: LD_VAR 0 1
111604: PUSH
111605: LD_INT 256
111607: EQUAL
111608: IFFALSE 111629
// SetFactoryWaypoint ( unit , x , y ) ;
111610: LD_VAR 0 2
111614: PPUSH
111615: LD_VAR 0 4
111619: PPUSH
111620: LD_VAR 0 5
111624: PPUSH
111625: CALL 109151 0 3
// if cmd = 257 then
111629: LD_VAR 0 1
111633: PUSH
111634: LD_INT 257
111636: EQUAL
111637: IFFALSE 111658
// SetWarehouseGatheringPoint ( unit , x , y ) ;
111639: LD_VAR 0 2
111643: PPUSH
111644: LD_VAR 0 4
111648: PPUSH
111649: LD_VAR 0 5
111653: PPUSH
111654: CALL 109647 0 3
// if cmd = 258 then
111658: LD_VAR 0 1
111662: PUSH
111663: LD_INT 258
111665: EQUAL
111666: IFFALSE 111690
// BurnTreeXYR ( unit , x , y , 8 ) ;
111668: LD_VAR 0 2
111672: PPUSH
111673: LD_VAR 0 4
111677: PPUSH
111678: LD_VAR 0 5
111682: PPUSH
111683: LD_INT 8
111685: PPUSH
111686: CALL 112191 0 4
// end ;
111690: LD_VAR 0 6
111694: RET
// export function ComRadiation ( un ) ; var eff ; begin
111695: LD_INT 0
111697: PPUSH
111698: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
111699: LD_VAR 0 1
111703: PPUSH
111704: CALL_OW 264
111708: PUSH
111709: LD_INT 91
111711: NONEQUAL
111712: IFFALSE 111716
// exit ;
111714: GO 111786
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
111716: LD_INT 68
111718: PPUSH
111719: LD_VAR 0 1
111723: PPUSH
111724: CALL_OW 255
111728: PPUSH
111729: CALL_OW 321
111733: PUSH
111734: LD_INT 2
111736: EQUAL
111737: IFFALSE 111749
// eff := 50 else
111739: LD_ADDR_VAR 0 3
111743: PUSH
111744: LD_INT 50
111746: ST_TO_ADDR
111747: GO 111757
// eff := 25 ;
111749: LD_ADDR_VAR 0 3
111753: PUSH
111754: LD_INT 25
111756: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
111757: LD_VAR 0 1
111761: PPUSH
111762: CALL_OW 250
111766: PPUSH
111767: LD_VAR 0 1
111771: PPUSH
111772: CALL_OW 251
111776: PPUSH
111777: LD_VAR 0 3
111781: PPUSH
111782: CALL_OW 495
// end ;
111786: LD_VAR 0 2
111790: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
111791: LD_INT 0
111793: PPUSH
111794: PPUSH
111795: PPUSH
111796: PPUSH
111797: PPUSH
111798: PPUSH
111799: PPUSH
111800: PPUSH
111801: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
111802: LD_VAR 0 1
111806: PPUSH
111807: CALL_OW 302
111811: NOT
111812: IFTRUE 111831
111814: PUSH
111815: LD_VAR 0 2
111819: PPUSH
111820: LD_VAR 0 3
111824: PPUSH
111825: CALL_OW 488
111829: NOT
111830: OR
111831: IFTRUE 111840
111833: PUSH
111834: LD_VAR 0 4
111838: NOT
111839: OR
111840: IFFALSE 111844
// exit ;
111842: GO 112186
// list := [ ] ;
111844: LD_ADDR_VAR 0 13
111848: PUSH
111849: EMPTY
111850: ST_TO_ADDR
// if x - r < 0 then
111851: LD_VAR 0 2
111855: PUSH
111856: LD_VAR 0 4
111860: MINUS
111861: PUSH
111862: LD_INT 0
111864: LESS
111865: IFFALSE 111877
// min_x := 0 else
111867: LD_ADDR_VAR 0 7
111871: PUSH
111872: LD_INT 0
111874: ST_TO_ADDR
111875: GO 111893
// min_x := x - r ;
111877: LD_ADDR_VAR 0 7
111881: PUSH
111882: LD_VAR 0 2
111886: PUSH
111887: LD_VAR 0 4
111891: MINUS
111892: ST_TO_ADDR
// if y - r < 0 then
111893: LD_VAR 0 3
111897: PUSH
111898: LD_VAR 0 4
111902: MINUS
111903: PUSH
111904: LD_INT 0
111906: LESS
111907: IFFALSE 111919
// min_y := 0 else
111909: LD_ADDR_VAR 0 8
111913: PUSH
111914: LD_INT 0
111916: ST_TO_ADDR
111917: GO 111935
// min_y := y - r ;
111919: LD_ADDR_VAR 0 8
111923: PUSH
111924: LD_VAR 0 3
111928: PUSH
111929: LD_VAR 0 4
111933: MINUS
111934: ST_TO_ADDR
// max_x := x + r ;
111935: LD_ADDR_VAR 0 9
111939: PUSH
111940: LD_VAR 0 2
111944: PUSH
111945: LD_VAR 0 4
111949: PLUS
111950: ST_TO_ADDR
// max_y := y + r ;
111951: LD_ADDR_VAR 0 10
111955: PUSH
111956: LD_VAR 0 3
111960: PUSH
111961: LD_VAR 0 4
111965: PLUS
111966: ST_TO_ADDR
// for _x = min_x to max_x do
111967: LD_ADDR_VAR 0 11
111971: PUSH
111972: DOUBLE
111973: LD_VAR 0 7
111977: DEC
111978: ST_TO_ADDR
111979: LD_VAR 0 9
111983: PUSH
111984: FOR_TO
111985: IFFALSE 112104
// for _y = min_y to max_y do
111987: LD_ADDR_VAR 0 12
111991: PUSH
111992: DOUBLE
111993: LD_VAR 0 8
111997: DEC
111998: ST_TO_ADDR
111999: LD_VAR 0 10
112003: PUSH
112004: FOR_TO
112005: IFFALSE 112100
// begin if not ValidHex ( _x , _y ) then
112007: LD_VAR 0 11
112011: PPUSH
112012: LD_VAR 0 12
112016: PPUSH
112017: CALL_OW 488
112021: NOT
112022: IFFALSE 112026
// continue ;
112024: GO 112004
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112026: LD_VAR 0 11
112030: PPUSH
112031: LD_VAR 0 12
112035: PPUSH
112036: CALL_OW 351
112040: IFFALSE 112058
112042: PUSH
112043: LD_VAR 0 11
112047: PPUSH
112048: LD_VAR 0 12
112052: PPUSH
112053: CALL_OW 554
112057: AND
112058: IFFALSE 112098
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112060: LD_ADDR_VAR 0 13
112064: PUSH
112065: LD_VAR 0 13
112069: PPUSH
112070: LD_VAR 0 13
112074: PUSH
112075: LD_INT 1
112077: PLUS
112078: PPUSH
112079: LD_VAR 0 11
112083: PUSH
112084: LD_VAR 0 12
112088: PUSH
112089: EMPTY
112090: LIST
112091: LIST
112092: PPUSH
112093: CALL_OW 2
112097: ST_TO_ADDR
// end ;
112098: GO 112004
112100: POP
112101: POP
112102: GO 111984
112104: POP
112105: POP
// if not list then
112106: LD_VAR 0 13
112110: NOT
112111: IFFALSE 112115
// exit ;
112113: GO 112186
// for i in list do
112115: LD_ADDR_VAR 0 6
112119: PUSH
112120: LD_VAR 0 13
112124: PUSH
112125: FOR_IN
112126: IFFALSE 112184
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
112128: LD_VAR 0 1
112132: PPUSH
112133: LD_STRING M
112135: PUSH
112136: LD_VAR 0 6
112140: PUSH
112141: LD_INT 1
112143: ARRAY
112144: PUSH
112145: LD_VAR 0 6
112149: PUSH
112150: LD_INT 2
112152: ARRAY
112153: PUSH
112154: LD_INT 0
112156: PUSH
112157: LD_INT 0
112159: PUSH
112160: LD_INT 0
112162: PUSH
112163: LD_INT 0
112165: PUSH
112166: EMPTY
112167: LIST
112168: LIST
112169: LIST
112170: LIST
112171: LIST
112172: LIST
112173: LIST
112174: PUSH
112175: EMPTY
112176: LIST
112177: PPUSH
112178: CALL_OW 447
112182: GO 112125
112184: POP
112185: POP
// end ;
112186: LD_VAR 0 5
112190: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
112191: LD_INT 0
112193: PPUSH
112194: PPUSH
112195: PPUSH
112196: PPUSH
112197: PPUSH
112198: PPUSH
112199: PPUSH
112200: PPUSH
112201: PPUSH
112202: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
112203: LD_VAR 0 1
112207: PPUSH
112208: CALL_OW 302
112212: NOT
112213: IFTRUE 112232
112215: PUSH
112216: LD_VAR 0 2
112220: PPUSH
112221: LD_VAR 0 3
112225: PPUSH
112226: CALL_OW 488
112230: NOT
112231: OR
112232: IFTRUE 112241
112234: PUSH
112235: LD_VAR 0 4
112239: NOT
112240: OR
112241: IFFALSE 112245
// exit ;
112243: GO 112762
// list := [ ] ;
112245: LD_ADDR_VAR 0 13
112249: PUSH
112250: EMPTY
112251: ST_TO_ADDR
// if x - r < 0 then
112252: LD_VAR 0 2
112256: PUSH
112257: LD_VAR 0 4
112261: MINUS
112262: PUSH
112263: LD_INT 0
112265: LESS
112266: IFFALSE 112278
// min_x := 0 else
112268: LD_ADDR_VAR 0 7
112272: PUSH
112273: LD_INT 0
112275: ST_TO_ADDR
112276: GO 112294
// min_x := x - r ;
112278: LD_ADDR_VAR 0 7
112282: PUSH
112283: LD_VAR 0 2
112287: PUSH
112288: LD_VAR 0 4
112292: MINUS
112293: ST_TO_ADDR
// if y - r < 0 then
112294: LD_VAR 0 3
112298: PUSH
112299: LD_VAR 0 4
112303: MINUS
112304: PUSH
112305: LD_INT 0
112307: LESS
112308: IFFALSE 112320
// min_y := 0 else
112310: LD_ADDR_VAR 0 8
112314: PUSH
112315: LD_INT 0
112317: ST_TO_ADDR
112318: GO 112336
// min_y := y - r ;
112320: LD_ADDR_VAR 0 8
112324: PUSH
112325: LD_VAR 0 3
112329: PUSH
112330: LD_VAR 0 4
112334: MINUS
112335: ST_TO_ADDR
// max_x := x + r ;
112336: LD_ADDR_VAR 0 9
112340: PUSH
112341: LD_VAR 0 2
112345: PUSH
112346: LD_VAR 0 4
112350: PLUS
112351: ST_TO_ADDR
// max_y := y + r ;
112352: LD_ADDR_VAR 0 10
112356: PUSH
112357: LD_VAR 0 3
112361: PUSH
112362: LD_VAR 0 4
112366: PLUS
112367: ST_TO_ADDR
// for _x = min_x to max_x do
112368: LD_ADDR_VAR 0 11
112372: PUSH
112373: DOUBLE
112374: LD_VAR 0 7
112378: DEC
112379: ST_TO_ADDR
112380: LD_VAR 0 9
112384: PUSH
112385: FOR_TO
112386: IFFALSE 112505
// for _y = min_y to max_y do
112388: LD_ADDR_VAR 0 12
112392: PUSH
112393: DOUBLE
112394: LD_VAR 0 8
112398: DEC
112399: ST_TO_ADDR
112400: LD_VAR 0 10
112404: PUSH
112405: FOR_TO
112406: IFFALSE 112501
// begin if not ValidHex ( _x , _y ) then
112408: LD_VAR 0 11
112412: PPUSH
112413: LD_VAR 0 12
112417: PPUSH
112418: CALL_OW 488
112422: NOT
112423: IFFALSE 112427
// continue ;
112425: GO 112405
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112427: LD_VAR 0 11
112431: PPUSH
112432: LD_VAR 0 12
112436: PPUSH
112437: CALL_OW 351
112441: IFFALSE 112459
112443: PUSH
112444: LD_VAR 0 11
112448: PPUSH
112449: LD_VAR 0 12
112453: PPUSH
112454: CALL_OW 554
112458: AND
112459: IFFALSE 112499
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112461: LD_ADDR_VAR 0 13
112465: PUSH
112466: LD_VAR 0 13
112470: PPUSH
112471: LD_VAR 0 13
112475: PUSH
112476: LD_INT 1
112478: PLUS
112479: PPUSH
112480: LD_VAR 0 11
112484: PUSH
112485: LD_VAR 0 12
112489: PUSH
112490: EMPTY
112491: LIST
112492: LIST
112493: PPUSH
112494: CALL_OW 2
112498: ST_TO_ADDR
// end ;
112499: GO 112405
112501: POP
112502: POP
112503: GO 112385
112505: POP
112506: POP
// if not list then
112507: LD_VAR 0 13
112511: NOT
112512: IFFALSE 112516
// exit ;
112514: GO 112762
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
112516: LD_ADDR_VAR 0 13
112520: PUSH
112521: LD_VAR 0 1
112525: PPUSH
112526: LD_VAR 0 13
112530: PPUSH
112531: LD_INT 1
112533: PPUSH
112534: LD_INT 1
112536: PPUSH
112537: CALL 25551 0 4
112541: ST_TO_ADDR
// ComStop ( flame ) ;
112542: LD_VAR 0 1
112546: PPUSH
112547: CALL_OW 141
// for i in list do
112551: LD_ADDR_VAR 0 6
112555: PUSH
112556: LD_VAR 0 13
112560: PUSH
112561: FOR_IN
112562: IFFALSE 112593
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
112564: LD_VAR 0 1
112568: PPUSH
112569: LD_VAR 0 6
112573: PUSH
112574: LD_INT 1
112576: ARRAY
112577: PPUSH
112578: LD_VAR 0 6
112582: PUSH
112583: LD_INT 2
112585: ARRAY
112586: PPUSH
112587: CALL_OW 176
112591: GO 112561
112593: POP
112594: POP
// repeat wait ( 0 0$1 ) ;
112595: LD_INT 35
112597: PPUSH
112598: CALL_OW 67
// task := GetTaskList ( flame ) ;
112602: LD_ADDR_VAR 0 14
112606: PUSH
112607: LD_VAR 0 1
112611: PPUSH
112612: CALL_OW 437
112616: ST_TO_ADDR
// if not task then
112617: LD_VAR 0 14
112621: NOT
112622: IFFALSE 112626
// exit ;
112624: GO 112762
// if task [ 1 ] [ 1 ] <> | then
112626: LD_VAR 0 14
112630: PUSH
112631: LD_INT 1
112633: ARRAY
112634: PUSH
112635: LD_INT 1
112637: ARRAY
112638: PUSH
112639: LD_STRING |
112641: NONEQUAL
112642: IFFALSE 112646
// exit ;
112644: GO 112762
// _x := task [ 1 ] [ 2 ] ;
112646: LD_ADDR_VAR 0 11
112650: PUSH
112651: LD_VAR 0 14
112655: PUSH
112656: LD_INT 1
112658: ARRAY
112659: PUSH
112660: LD_INT 2
112662: ARRAY
112663: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
112664: LD_ADDR_VAR 0 12
112668: PUSH
112669: LD_VAR 0 14
112673: PUSH
112674: LD_INT 1
112676: ARRAY
112677: PUSH
112678: LD_INT 3
112680: ARRAY
112681: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
112682: LD_VAR 0 11
112686: PPUSH
112687: LD_VAR 0 12
112691: PPUSH
112692: CALL_OW 351
112696: NOT
112697: IFTRUE 112716
112699: PUSH
112700: LD_VAR 0 11
112704: PPUSH
112705: LD_VAR 0 12
112709: PPUSH
112710: CALL_OW 554
112714: NOT
112715: OR
112716: IFFALSE 112750
// begin task := Delete ( task , 1 ) ;
112718: LD_ADDR_VAR 0 14
112722: PUSH
112723: LD_VAR 0 14
112727: PPUSH
112728: LD_INT 1
112730: PPUSH
112731: CALL_OW 3
112735: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
112736: LD_VAR 0 1
112740: PPUSH
112741: LD_VAR 0 14
112745: PPUSH
112746: CALL_OW 446
// end ; until not HasTask ( flame ) ;
112750: LD_VAR 0 1
112754: PPUSH
112755: CALL_OW 314
112759: NOT
112760: IFFALSE 112595
// end ;
112762: LD_VAR 0 5
112766: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
112767: LD_EXP 139
112771: NOT
112772: IFFALSE 112822
112774: GO 112776
112776: DISABLE
// begin initHack := true ;
112777: LD_ADDR_EXP 139
112781: PUSH
112782: LD_INT 1
112784: ST_TO_ADDR
// hackTanks := [ ] ;
112785: LD_ADDR_EXP 140
112789: PUSH
112790: EMPTY
112791: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
112792: LD_ADDR_EXP 141
112796: PUSH
112797: EMPTY
112798: ST_TO_ADDR
// hackLimit := 3 ;
112799: LD_ADDR_EXP 142
112803: PUSH
112804: LD_INT 3
112806: ST_TO_ADDR
// hackDist := 12 ;
112807: LD_ADDR_EXP 143
112811: PUSH
112812: LD_INT 12
112814: ST_TO_ADDR
// hackCounter := [ ] ;
112815: LD_ADDR_EXP 144
112819: PUSH
112820: EMPTY
112821: ST_TO_ADDR
// end ;
112822: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
112823: LD_EXP 139
112827: IFFALSE 112845
112829: PUSH
112830: LD_INT 34
112832: PUSH
112833: LD_INT 99
112835: PUSH
112836: EMPTY
112837: LIST
112838: LIST
112839: PPUSH
112840: CALL_OW 69
112844: AND
112845: IFFALSE 113098
112847: GO 112849
112849: DISABLE
112850: LD_INT 0
112852: PPUSH
112853: PPUSH
// begin enable ;
112854: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
112855: LD_ADDR_VAR 0 1
112859: PUSH
112860: LD_INT 34
112862: PUSH
112863: LD_INT 99
112865: PUSH
112866: EMPTY
112867: LIST
112868: LIST
112869: PPUSH
112870: CALL_OW 69
112874: PUSH
112875: FOR_IN
112876: IFFALSE 113096
// begin if not i in hackTanks then
112878: LD_VAR 0 1
112882: PUSH
112883: LD_EXP 140
112887: IN
112888: NOT
112889: IFFALSE 112972
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
112891: LD_ADDR_EXP 140
112895: PUSH
112896: LD_EXP 140
112900: PPUSH
112901: LD_EXP 140
112905: PUSH
112906: LD_INT 1
112908: PLUS
112909: PPUSH
112910: LD_VAR 0 1
112914: PPUSH
112915: CALL_OW 1
112919: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
112920: LD_ADDR_EXP 141
112924: PUSH
112925: LD_EXP 141
112929: PPUSH
112930: LD_EXP 141
112934: PUSH
112935: LD_INT 1
112937: PLUS
112938: PPUSH
112939: EMPTY
112940: PPUSH
112941: CALL_OW 1
112945: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
112946: LD_ADDR_EXP 144
112950: PUSH
112951: LD_EXP 144
112955: PPUSH
112956: LD_EXP 144
112960: PUSH
112961: LD_INT 1
112963: PLUS
112964: PPUSH
112965: EMPTY
112966: PPUSH
112967: CALL_OW 1
112971: ST_TO_ADDR
// end ; if not IsOk ( i ) then
112972: LD_VAR 0 1
112976: PPUSH
112977: CALL_OW 302
112981: NOT
112982: IFFALSE 112995
// begin HackUnlinkAll ( i ) ;
112984: LD_VAR 0 1
112988: PPUSH
112989: CALL 113101 0 1
// continue ;
112993: GO 112875
// end ; HackCheckCapturedStatus ( i ) ;
112995: LD_VAR 0 1
112999: PPUSH
113000: CALL 113546 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
113004: LD_ADDR_VAR 0 2
113008: PUSH
113009: LD_INT 81
113011: PUSH
113012: LD_VAR 0 1
113016: PPUSH
113017: CALL_OW 255
113021: PUSH
113022: EMPTY
113023: LIST
113024: LIST
113025: PUSH
113026: LD_INT 33
113028: PUSH
113029: LD_INT 3
113031: PUSH
113032: EMPTY
113033: LIST
113034: LIST
113035: PUSH
113036: LD_INT 91
113038: PUSH
113039: LD_VAR 0 1
113043: PUSH
113044: LD_EXP 143
113048: PUSH
113049: EMPTY
113050: LIST
113051: LIST
113052: LIST
113053: PUSH
113054: LD_INT 50
113056: PUSH
113057: EMPTY
113058: LIST
113059: PUSH
113060: EMPTY
113061: LIST
113062: LIST
113063: LIST
113064: LIST
113065: PPUSH
113066: CALL_OW 69
113070: ST_TO_ADDR
// if not tmp then
113071: LD_VAR 0 2
113075: NOT
113076: IFFALSE 113080
// continue ;
113078: GO 112875
// HackLink ( i , tmp ) ;
113080: LD_VAR 0 1
113084: PPUSH
113085: LD_VAR 0 2
113089: PPUSH
113090: CALL 113237 0 2
// end ;
113094: GO 112875
113096: POP
113097: POP
// end ;
113098: PPOPN 2
113100: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
113101: LD_INT 0
113103: PPUSH
113104: PPUSH
113105: PPUSH
// if not hack in hackTanks then
113106: LD_VAR 0 1
113110: PUSH
113111: LD_EXP 140
113115: IN
113116: NOT
113117: IFFALSE 113121
// exit ;
113119: GO 113232
// index := GetElementIndex ( hackTanks , hack ) ;
113121: LD_ADDR_VAR 0 4
113125: PUSH
113126: LD_EXP 140
113130: PPUSH
113131: LD_VAR 0 1
113135: PPUSH
113136: CALL 24846 0 2
113140: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
113141: LD_EXP 141
113145: PUSH
113146: LD_VAR 0 4
113150: ARRAY
113151: IFFALSE 113232
// begin for i in hackTanksCaptured [ index ] do
113153: LD_ADDR_VAR 0 3
113157: PUSH
113158: LD_EXP 141
113162: PUSH
113163: LD_VAR 0 4
113167: ARRAY
113168: PUSH
113169: FOR_IN
113170: IFFALSE 113196
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
113172: LD_VAR 0 3
113176: PUSH
113177: LD_INT 1
113179: ARRAY
113180: PPUSH
113181: LD_VAR 0 3
113185: PUSH
113186: LD_INT 2
113188: ARRAY
113189: PPUSH
113190: CALL_OW 235
113194: GO 113169
113196: POP
113197: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
113198: LD_ADDR_EXP 141
113202: PUSH
113203: LD_EXP 141
113207: PPUSH
113208: LD_VAR 0 4
113212: PPUSH
113213: EMPTY
113214: PPUSH
113215: CALL_OW 1
113219: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
113220: LD_VAR 0 1
113224: PPUSH
113225: LD_INT 0
113227: PPUSH
113228: CALL_OW 505
// end ; end ;
113232: LD_VAR 0 2
113236: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
113237: LD_INT 0
113239: PPUSH
113240: PPUSH
113241: PPUSH
// if not hack in hackTanks or not vehicles then
113242: LD_VAR 0 1
113246: PUSH
113247: LD_EXP 140
113251: IN
113252: NOT
113253: IFTRUE 113262
113255: PUSH
113256: LD_VAR 0 2
113260: NOT
113261: OR
113262: IFFALSE 113266
// exit ;
113264: GO 113541
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
113266: LD_ADDR_VAR 0 2
113270: PUSH
113271: LD_VAR 0 1
113275: PPUSH
113276: LD_VAR 0 2
113280: PPUSH
113281: LD_INT 1
113283: PPUSH
113284: LD_INT 1
113286: PPUSH
113287: CALL 25498 0 4
113291: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
113292: LD_ADDR_VAR 0 5
113296: PUSH
113297: LD_EXP 140
113301: PPUSH
113302: LD_VAR 0 1
113306: PPUSH
113307: CALL 24846 0 2
113311: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
113312: LD_EXP 141
113316: PUSH
113317: LD_VAR 0 5
113321: ARRAY
113322: PUSH
113323: LD_EXP 142
113327: LESS
113328: IFFALSE 113517
// begin for i := 1 to vehicles do
113330: LD_ADDR_VAR 0 4
113334: PUSH
113335: DOUBLE
113336: LD_INT 1
113338: DEC
113339: ST_TO_ADDR
113340: LD_VAR 0 2
113344: PUSH
113345: FOR_TO
113346: IFFALSE 113515
// begin if hackTanksCaptured [ index ] = hackLimit then
113348: LD_EXP 141
113352: PUSH
113353: LD_VAR 0 5
113357: ARRAY
113358: PUSH
113359: LD_EXP 142
113363: EQUAL
113364: IFFALSE 113368
// break ;
113366: GO 113515
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
113368: LD_ADDR_EXP 144
113372: PUSH
113373: LD_EXP 144
113377: PPUSH
113378: LD_VAR 0 5
113382: PPUSH
113383: LD_EXP 144
113387: PUSH
113388: LD_VAR 0 5
113392: ARRAY
113393: PUSH
113394: LD_INT 1
113396: PLUS
113397: PPUSH
113398: CALL_OW 1
113402: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
113403: LD_ADDR_EXP 141
113407: PUSH
113408: LD_EXP 141
113412: PPUSH
113413: LD_VAR 0 5
113417: PUSH
113418: LD_EXP 141
113422: PUSH
113423: LD_VAR 0 5
113427: ARRAY
113428: PUSH
113429: LD_INT 1
113431: PLUS
113432: PUSH
113433: EMPTY
113434: LIST
113435: LIST
113436: PPUSH
113437: LD_VAR 0 2
113441: PUSH
113442: LD_VAR 0 4
113446: ARRAY
113447: PUSH
113448: LD_VAR 0 2
113452: PUSH
113453: LD_VAR 0 4
113457: ARRAY
113458: PPUSH
113459: CALL_OW 255
113463: PUSH
113464: EMPTY
113465: LIST
113466: LIST
113467: PPUSH
113468: CALL 25063 0 3
113472: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
113473: LD_VAR 0 2
113477: PUSH
113478: LD_VAR 0 4
113482: ARRAY
113483: PPUSH
113484: LD_VAR 0 1
113488: PPUSH
113489: CALL_OW 255
113493: PPUSH
113494: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
113498: LD_VAR 0 2
113502: PUSH
113503: LD_VAR 0 4
113507: ARRAY
113508: PPUSH
113509: CALL_OW 141
// end ;
113513: GO 113345
113515: POP
113516: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
113517: LD_VAR 0 1
113521: PPUSH
113522: LD_EXP 141
113526: PUSH
113527: LD_VAR 0 5
113531: ARRAY
113532: PUSH
113533: LD_INT 0
113535: PLUS
113536: PPUSH
113537: CALL_OW 505
// end ;
113541: LD_VAR 0 3
113545: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
113546: LD_INT 0
113548: PPUSH
113549: PPUSH
113550: PPUSH
113551: PPUSH
// if not hack in hackTanks then
113552: LD_VAR 0 1
113556: PUSH
113557: LD_EXP 140
113561: IN
113562: NOT
113563: IFFALSE 113567
// exit ;
113565: GO 113811
// index := GetElementIndex ( hackTanks , hack ) ;
113567: LD_ADDR_VAR 0 4
113571: PUSH
113572: LD_EXP 140
113576: PPUSH
113577: LD_VAR 0 1
113581: PPUSH
113582: CALL 24846 0 2
113586: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
113587: LD_ADDR_VAR 0 3
113591: PUSH
113592: DOUBLE
113593: LD_EXP 141
113597: PUSH
113598: LD_VAR 0 4
113602: ARRAY
113603: INC
113604: ST_TO_ADDR
113605: LD_INT 1
113607: PUSH
113608: FOR_DOWNTO
113609: IFFALSE 113785
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
113611: LD_ADDR_VAR 0 5
113615: PUSH
113616: LD_EXP 141
113620: PUSH
113621: LD_VAR 0 4
113625: ARRAY
113626: PUSH
113627: LD_VAR 0 3
113631: ARRAY
113632: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
113633: LD_VAR 0 5
113637: PUSH
113638: LD_INT 1
113640: ARRAY
113641: PPUSH
113642: CALL_OW 302
113646: NOT
113647: IFTRUE 113675
113649: PUSH
113650: LD_VAR 0 5
113654: PUSH
113655: LD_INT 1
113657: ARRAY
113658: PPUSH
113659: CALL_OW 255
113663: PUSH
113664: LD_VAR 0 1
113668: PPUSH
113669: CALL_OW 255
113673: NONEQUAL
113674: OR
113675: IFFALSE 113783
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
113677: LD_VAR 0 5
113681: PUSH
113682: LD_INT 1
113684: ARRAY
113685: PPUSH
113686: CALL_OW 305
113690: IFFALSE 113718
113692: PUSH
113693: LD_VAR 0 5
113697: PUSH
113698: LD_INT 1
113700: ARRAY
113701: PPUSH
113702: CALL_OW 255
113706: PUSH
113707: LD_VAR 0 1
113711: PPUSH
113712: CALL_OW 255
113716: EQUAL
113717: AND
113718: IFFALSE 113742
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
113720: LD_VAR 0 5
113724: PUSH
113725: LD_INT 1
113727: ARRAY
113728: PPUSH
113729: LD_VAR 0 5
113733: PUSH
113734: LD_INT 2
113736: ARRAY
113737: PPUSH
113738: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
113742: LD_ADDR_EXP 141
113746: PUSH
113747: LD_EXP 141
113751: PPUSH
113752: LD_VAR 0 4
113756: PPUSH
113757: LD_EXP 141
113761: PUSH
113762: LD_VAR 0 4
113766: ARRAY
113767: PPUSH
113768: LD_VAR 0 3
113772: PPUSH
113773: CALL_OW 3
113777: PPUSH
113778: CALL_OW 1
113782: ST_TO_ADDR
// end ; end ;
113783: GO 113608
113785: POP
113786: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
113787: LD_VAR 0 1
113791: PPUSH
113792: LD_EXP 141
113796: PUSH
113797: LD_VAR 0 4
113801: ARRAY
113802: PUSH
113803: LD_INT 0
113805: PLUS
113806: PPUSH
113807: CALL_OW 505
// end ;
113811: LD_VAR 0 2
113815: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
113816: LD_INT 0
113818: PPUSH
113819: PPUSH
113820: PPUSH
113821: PPUSH
// if not hack in hackTanks then
113822: LD_VAR 0 1
113826: PUSH
113827: LD_EXP 140
113831: IN
113832: NOT
113833: IFFALSE 113837
// exit ;
113835: GO 113922
// index := GetElementIndex ( hackTanks , hack ) ;
113837: LD_ADDR_VAR 0 5
113841: PUSH
113842: LD_EXP 140
113846: PPUSH
113847: LD_VAR 0 1
113851: PPUSH
113852: CALL 24846 0 2
113856: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
113857: LD_ADDR_VAR 0 4
113861: PUSH
113862: DOUBLE
113863: LD_INT 1
113865: DEC
113866: ST_TO_ADDR
113867: LD_EXP 141
113871: PUSH
113872: LD_VAR 0 5
113876: ARRAY
113877: PUSH
113878: FOR_TO
113879: IFFALSE 113920
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
113881: LD_EXP 141
113885: PUSH
113886: LD_VAR 0 5
113890: ARRAY
113891: PUSH
113892: LD_VAR 0 4
113896: ARRAY
113897: PUSH
113898: LD_INT 1
113900: ARRAY
113901: PUSH
113902: LD_VAR 0 2
113906: EQUAL
113907: IFFALSE 113918
// KillUnit ( vehicle ) ;
113909: LD_VAR 0 2
113913: PPUSH
113914: CALL_OW 66
113918: GO 113878
113920: POP
113921: POP
// end ;
113922: LD_VAR 0 3
113926: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
113927: LD_EXP 145
113931: NOT
113932: IFFALSE 113967
113934: GO 113936
113936: DISABLE
// begin initMiner := true ;
113937: LD_ADDR_EXP 145
113941: PUSH
113942: LD_INT 1
113944: ST_TO_ADDR
// minersList := [ ] ;
113945: LD_ADDR_EXP 146
113949: PUSH
113950: EMPTY
113951: ST_TO_ADDR
// minerMinesList := [ ] ;
113952: LD_ADDR_EXP 147
113956: PUSH
113957: EMPTY
113958: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
113959: LD_ADDR_EXP 148
113963: PUSH
113964: LD_INT 5
113966: ST_TO_ADDR
// end ;
113967: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
113968: LD_EXP 145
113972: IFFALSE 113990
113974: PUSH
113975: LD_INT 34
113977: PUSH
113978: LD_INT 81
113980: PUSH
113981: EMPTY
113982: LIST
113983: LIST
113984: PPUSH
113985: CALL_OW 69
113989: AND
113990: IFFALSE 114453
113992: GO 113994
113994: DISABLE
113995: LD_INT 0
113997: PPUSH
113998: PPUSH
113999: PPUSH
114000: PPUSH
// begin enable ;
114001: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
114002: LD_ADDR_VAR 0 1
114006: PUSH
114007: LD_INT 34
114009: PUSH
114010: LD_INT 81
114012: PUSH
114013: EMPTY
114014: LIST
114015: LIST
114016: PPUSH
114017: CALL_OW 69
114021: PUSH
114022: FOR_IN
114023: IFFALSE 114095
// begin if not i in minersList then
114025: LD_VAR 0 1
114029: PUSH
114030: LD_EXP 146
114034: IN
114035: NOT
114036: IFFALSE 114093
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
114038: LD_ADDR_EXP 146
114042: PUSH
114043: LD_EXP 146
114047: PPUSH
114048: LD_EXP 146
114052: PUSH
114053: LD_INT 1
114055: PLUS
114056: PPUSH
114057: LD_VAR 0 1
114061: PPUSH
114062: CALL_OW 1
114066: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
114067: LD_ADDR_EXP 147
114071: PUSH
114072: LD_EXP 147
114076: PPUSH
114077: LD_EXP 147
114081: PUSH
114082: LD_INT 1
114084: PLUS
114085: PPUSH
114086: EMPTY
114087: PPUSH
114088: CALL_OW 1
114092: ST_TO_ADDR
// end end ;
114093: GO 114022
114095: POP
114096: POP
// for i := minerMinesList downto 1 do
114097: LD_ADDR_VAR 0 1
114101: PUSH
114102: DOUBLE
114103: LD_EXP 147
114107: INC
114108: ST_TO_ADDR
114109: LD_INT 1
114111: PUSH
114112: FOR_DOWNTO
114113: IFFALSE 114451
// begin if IsLive ( minersList [ i ] ) then
114115: LD_EXP 146
114119: PUSH
114120: LD_VAR 0 1
114124: ARRAY
114125: PPUSH
114126: CALL_OW 300
114130: IFFALSE 114158
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
114132: LD_EXP 146
114136: PUSH
114137: LD_VAR 0 1
114141: ARRAY
114142: PPUSH
114143: LD_EXP 147
114147: PUSH
114148: LD_VAR 0 1
114152: ARRAY
114153: PPUSH
114154: CALL_OW 505
// if not minerMinesList [ i ] then
114158: LD_EXP 147
114162: PUSH
114163: LD_VAR 0 1
114167: ARRAY
114168: NOT
114169: IFFALSE 114173
// continue ;
114171: GO 114112
// for j := minerMinesList [ i ] downto 1 do
114173: LD_ADDR_VAR 0 2
114177: PUSH
114178: DOUBLE
114179: LD_EXP 147
114183: PUSH
114184: LD_VAR 0 1
114188: ARRAY
114189: INC
114190: ST_TO_ADDR
114191: LD_INT 1
114193: PUSH
114194: FOR_DOWNTO
114195: IFFALSE 114447
// begin side := GetSide ( minersList [ i ] ) ;
114197: LD_ADDR_VAR 0 3
114201: PUSH
114202: LD_EXP 146
114206: PUSH
114207: LD_VAR 0 1
114211: ARRAY
114212: PPUSH
114213: CALL_OW 255
114217: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
114218: LD_ADDR_VAR 0 4
114222: PUSH
114223: LD_EXP 147
114227: PUSH
114228: LD_VAR 0 1
114232: ARRAY
114233: PUSH
114234: LD_VAR 0 2
114238: ARRAY
114239: PUSH
114240: LD_INT 1
114242: ARRAY
114243: PPUSH
114244: LD_EXP 147
114248: PUSH
114249: LD_VAR 0 1
114253: ARRAY
114254: PUSH
114255: LD_VAR 0 2
114259: ARRAY
114260: PUSH
114261: LD_INT 2
114263: ARRAY
114264: PPUSH
114265: CALL_OW 428
114269: ST_TO_ADDR
// if not tmp then
114270: LD_VAR 0 4
114274: NOT
114275: IFFALSE 114279
// continue ;
114277: GO 114194
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
114279: LD_VAR 0 4
114283: PUSH
114284: LD_INT 81
114286: PUSH
114287: LD_VAR 0 3
114291: PUSH
114292: EMPTY
114293: LIST
114294: LIST
114295: PPUSH
114296: CALL_OW 69
114300: IN
114301: IFFALSE 114351
114303: PUSH
114304: LD_EXP 147
114308: PUSH
114309: LD_VAR 0 1
114313: ARRAY
114314: PUSH
114315: LD_VAR 0 2
114319: ARRAY
114320: PUSH
114321: LD_INT 1
114323: ARRAY
114324: PPUSH
114325: LD_EXP 147
114329: PUSH
114330: LD_VAR 0 1
114334: ARRAY
114335: PUSH
114336: LD_VAR 0 2
114340: ARRAY
114341: PUSH
114342: LD_INT 2
114344: ARRAY
114345: PPUSH
114346: CALL_OW 458
114350: AND
114351: IFFALSE 114445
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
114353: LD_EXP 147
114357: PUSH
114358: LD_VAR 0 1
114362: ARRAY
114363: PUSH
114364: LD_VAR 0 2
114368: ARRAY
114369: PUSH
114370: LD_INT 1
114372: ARRAY
114373: PPUSH
114374: LD_EXP 147
114378: PUSH
114379: LD_VAR 0 1
114383: ARRAY
114384: PUSH
114385: LD_VAR 0 2
114389: ARRAY
114390: PUSH
114391: LD_INT 2
114393: ARRAY
114394: PPUSH
114395: LD_VAR 0 3
114399: PPUSH
114400: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
114404: LD_ADDR_EXP 147
114408: PUSH
114409: LD_EXP 147
114413: PPUSH
114414: LD_VAR 0 1
114418: PPUSH
114419: LD_EXP 147
114423: PUSH
114424: LD_VAR 0 1
114428: ARRAY
114429: PPUSH
114430: LD_VAR 0 2
114434: PPUSH
114435: CALL_OW 3
114439: PPUSH
114440: CALL_OW 1
114444: ST_TO_ADDR
// end ; end ;
114445: GO 114194
114447: POP
114448: POP
// end ;
114449: GO 114112
114451: POP
114452: POP
// end ;
114453: PPOPN 4
114455: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
114456: LD_INT 0
114458: PPUSH
114459: PPUSH
// result := false ;
114460: LD_ADDR_VAR 0 4
114464: PUSH
114465: LD_INT 0
114467: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
114468: LD_VAR 0 1
114472: PPUSH
114473: CALL_OW 264
114477: PUSH
114478: LD_INT 81
114480: EQUAL
114481: NOT
114482: IFFALSE 114486
// exit ;
114484: GO 114730
// index := GetElementIndex ( minersList , unit ) ;
114486: LD_ADDR_VAR 0 5
114490: PUSH
114491: LD_EXP 146
114495: PPUSH
114496: LD_VAR 0 1
114500: PPUSH
114501: CALL 24846 0 2
114505: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
114506: LD_EXP 147
114510: PUSH
114511: LD_VAR 0 5
114515: ARRAY
114516: PUSH
114517: LD_EXP 148
114521: GREATEREQUAL
114522: IFFALSE 114526
// exit ;
114524: GO 114730
// ComMoveXY ( unit , x , y ) ;
114526: LD_VAR 0 1
114530: PPUSH
114531: LD_VAR 0 2
114535: PPUSH
114536: LD_VAR 0 3
114540: PPUSH
114541: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
114545: LD_INT 35
114547: PPUSH
114548: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
114552: LD_VAR 0 1
114556: PPUSH
114557: LD_VAR 0 2
114561: PPUSH
114562: LD_VAR 0 3
114566: PPUSH
114567: CALL 56892 0 3
114571: NOT
114572: IFFALSE 114585
114574: PUSH
114575: LD_VAR 0 1
114579: PPUSH
114580: CALL_OW 314
114584: AND
114585: IFFALSE 114589
// exit ;
114587: GO 114730
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
114589: LD_VAR 0 2
114593: PPUSH
114594: LD_VAR 0 3
114598: PPUSH
114599: CALL_OW 428
114603: PUSH
114604: LD_VAR 0 1
114608: EQUAL
114609: IFFALSE 114623
114611: PUSH
114612: LD_VAR 0 1
114616: PPUSH
114617: CALL_OW 314
114621: NOT
114622: AND
114623: IFFALSE 114545
// PlaySoundXY ( x , y , PlantMine ) ;
114625: LD_VAR 0 2
114629: PPUSH
114630: LD_VAR 0 3
114634: PPUSH
114635: LD_STRING PlantMine
114637: PPUSH
114638: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
114642: LD_VAR 0 2
114646: PPUSH
114647: LD_VAR 0 3
114651: PPUSH
114652: LD_VAR 0 1
114656: PPUSH
114657: CALL_OW 255
114661: PPUSH
114662: LD_INT 0
114664: PPUSH
114665: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
114669: LD_ADDR_EXP 147
114673: PUSH
114674: LD_EXP 147
114678: PPUSH
114679: LD_VAR 0 5
114683: PUSH
114684: LD_EXP 147
114688: PUSH
114689: LD_VAR 0 5
114693: ARRAY
114694: PUSH
114695: LD_INT 1
114697: PLUS
114698: PUSH
114699: EMPTY
114700: LIST
114701: LIST
114702: PPUSH
114703: LD_VAR 0 2
114707: PUSH
114708: LD_VAR 0 3
114712: PUSH
114713: EMPTY
114714: LIST
114715: LIST
114716: PPUSH
114717: CALL 25063 0 3
114721: ST_TO_ADDR
// result := true ;
114722: LD_ADDR_VAR 0 4
114726: PUSH
114727: LD_INT 1
114729: ST_TO_ADDR
// end ;
114730: LD_VAR 0 4
114734: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
114735: LD_INT 0
114737: PPUSH
114738: PPUSH
114739: PPUSH
// if not unit in minersList then
114740: LD_VAR 0 1
114744: PUSH
114745: LD_EXP 146
114749: IN
114750: NOT
114751: IFFALSE 114755
// exit ;
114753: GO 115149
// index := GetElementIndex ( minersList , unit ) ;
114755: LD_ADDR_VAR 0 6
114759: PUSH
114760: LD_EXP 146
114764: PPUSH
114765: LD_VAR 0 1
114769: PPUSH
114770: CALL 24846 0 2
114774: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
114775: LD_ADDR_VAR 0 5
114779: PUSH
114780: DOUBLE
114781: LD_EXP 147
114785: PUSH
114786: LD_VAR 0 6
114790: ARRAY
114791: INC
114792: ST_TO_ADDR
114793: LD_INT 1
114795: PUSH
114796: FOR_DOWNTO
114797: IFFALSE 114960
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
114799: LD_EXP 147
114803: PUSH
114804: LD_VAR 0 6
114808: ARRAY
114809: PUSH
114810: LD_VAR 0 5
114814: ARRAY
114815: PUSH
114816: LD_INT 1
114818: ARRAY
114819: PUSH
114820: LD_VAR 0 2
114824: EQUAL
114825: IFFALSE 114855
114827: PUSH
114828: LD_EXP 147
114832: PUSH
114833: LD_VAR 0 6
114837: ARRAY
114838: PUSH
114839: LD_VAR 0 5
114843: ARRAY
114844: PUSH
114845: LD_INT 2
114847: ARRAY
114848: PUSH
114849: LD_VAR 0 3
114853: EQUAL
114854: AND
114855: IFFALSE 114958
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
114857: LD_EXP 147
114861: PUSH
114862: LD_VAR 0 6
114866: ARRAY
114867: PUSH
114868: LD_VAR 0 5
114872: ARRAY
114873: PUSH
114874: LD_INT 1
114876: ARRAY
114877: PPUSH
114878: LD_EXP 147
114882: PUSH
114883: LD_VAR 0 6
114887: ARRAY
114888: PUSH
114889: LD_VAR 0 5
114893: ARRAY
114894: PUSH
114895: LD_INT 2
114897: ARRAY
114898: PPUSH
114899: LD_VAR 0 1
114903: PPUSH
114904: CALL_OW 255
114908: PPUSH
114909: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
114913: LD_ADDR_EXP 147
114917: PUSH
114918: LD_EXP 147
114922: PPUSH
114923: LD_VAR 0 6
114927: PPUSH
114928: LD_EXP 147
114932: PUSH
114933: LD_VAR 0 6
114937: ARRAY
114938: PPUSH
114939: LD_VAR 0 5
114943: PPUSH
114944: CALL_OW 3
114948: PPUSH
114949: CALL_OW 1
114953: ST_TO_ADDR
// exit ;
114954: POP
114955: POP
114956: GO 115149
// end ; end ;
114958: GO 114796
114960: POP
114961: POP
// for i := minerMinesList [ index ] downto 1 do
114962: LD_ADDR_VAR 0 5
114966: PUSH
114967: DOUBLE
114968: LD_EXP 147
114972: PUSH
114973: LD_VAR 0 6
114977: ARRAY
114978: INC
114979: ST_TO_ADDR
114980: LD_INT 1
114982: PUSH
114983: FOR_DOWNTO
114984: IFFALSE 115147
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
114986: LD_EXP 147
114990: PUSH
114991: LD_VAR 0 6
114995: ARRAY
114996: PUSH
114997: LD_VAR 0 5
115001: ARRAY
115002: PUSH
115003: LD_INT 1
115005: ARRAY
115006: PPUSH
115007: LD_EXP 147
115011: PUSH
115012: LD_VAR 0 6
115016: ARRAY
115017: PUSH
115018: LD_VAR 0 5
115022: ARRAY
115023: PUSH
115024: LD_INT 2
115026: ARRAY
115027: PPUSH
115028: LD_VAR 0 2
115032: PPUSH
115033: LD_VAR 0 3
115037: PPUSH
115038: CALL_OW 298
115042: PUSH
115043: LD_INT 6
115045: LESS
115046: IFFALSE 115145
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
115048: LD_EXP 147
115052: PUSH
115053: LD_VAR 0 6
115057: ARRAY
115058: PUSH
115059: LD_VAR 0 5
115063: ARRAY
115064: PUSH
115065: LD_INT 1
115067: ARRAY
115068: PPUSH
115069: LD_EXP 147
115073: PUSH
115074: LD_VAR 0 6
115078: ARRAY
115079: PUSH
115080: LD_VAR 0 5
115084: ARRAY
115085: PUSH
115086: LD_INT 2
115088: ARRAY
115089: PPUSH
115090: LD_VAR 0 1
115094: PPUSH
115095: CALL_OW 255
115099: PPUSH
115100: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
115104: LD_ADDR_EXP 147
115108: PUSH
115109: LD_EXP 147
115113: PPUSH
115114: LD_VAR 0 6
115118: PPUSH
115119: LD_EXP 147
115123: PUSH
115124: LD_VAR 0 6
115128: ARRAY
115129: PPUSH
115130: LD_VAR 0 5
115134: PPUSH
115135: CALL_OW 3
115139: PPUSH
115140: CALL_OW 1
115144: ST_TO_ADDR
// end ; end ;
115145: GO 114983
115147: POP
115148: POP
// end ;
115149: LD_VAR 0 4
115153: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
115154: LD_INT 0
115156: PPUSH
115157: PPUSH
115158: PPUSH
115159: PPUSH
115160: PPUSH
115161: PPUSH
115162: PPUSH
115163: PPUSH
115164: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
115165: LD_VAR 0 1
115169: PPUSH
115170: CALL_OW 264
115174: PUSH
115175: LD_INT 81
115177: EQUAL
115178: NOT
115179: IFTRUE 115194
115181: PUSH
115182: LD_VAR 0 1
115186: PUSH
115187: LD_EXP 146
115191: IN
115192: NOT
115193: OR
115194: IFFALSE 115198
// exit ;
115196: GO 115524
// index := GetElementIndex ( minersList , unit ) ;
115198: LD_ADDR_VAR 0 6
115202: PUSH
115203: LD_EXP 146
115207: PPUSH
115208: LD_VAR 0 1
115212: PPUSH
115213: CALL 24846 0 2
115217: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
115218: LD_ADDR_VAR 0 8
115222: PUSH
115223: LD_EXP 148
115227: PUSH
115228: LD_EXP 147
115232: PUSH
115233: LD_VAR 0 6
115237: ARRAY
115238: MINUS
115239: ST_TO_ADDR
// if not minesFreeAmount then
115240: LD_VAR 0 8
115244: NOT
115245: IFFALSE 115249
// exit ;
115247: GO 115524
// tmp := [ ] ;
115249: LD_ADDR_VAR 0 7
115253: PUSH
115254: EMPTY
115255: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
115256: LD_ADDR_VAR 0 5
115260: PUSH
115261: DOUBLE
115262: LD_INT 1
115264: DEC
115265: ST_TO_ADDR
115266: LD_VAR 0 8
115270: PUSH
115271: FOR_TO
115272: IFFALSE 115471
// begin _d := rand ( 0 , 5 ) ;
115274: LD_ADDR_VAR 0 11
115278: PUSH
115279: LD_INT 0
115281: PPUSH
115282: LD_INT 5
115284: PPUSH
115285: CALL_OW 12
115289: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
115290: LD_ADDR_VAR 0 12
115294: PUSH
115295: LD_INT 2
115297: PPUSH
115298: LD_INT 6
115300: PPUSH
115301: CALL_OW 12
115305: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
115306: LD_ADDR_VAR 0 9
115310: PUSH
115311: LD_VAR 0 2
115315: PPUSH
115316: LD_VAR 0 11
115320: PPUSH
115321: LD_VAR 0 12
115325: PPUSH
115326: CALL_OW 272
115330: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
115331: LD_ADDR_VAR 0 10
115335: PUSH
115336: LD_VAR 0 3
115340: PPUSH
115341: LD_VAR 0 11
115345: PPUSH
115346: LD_VAR 0 12
115350: PPUSH
115351: CALL_OW 273
115355: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
115356: LD_VAR 0 9
115360: PPUSH
115361: LD_VAR 0 10
115365: PPUSH
115366: CALL_OW 488
115370: IFFALSE 115394
115372: PUSH
115373: LD_VAR 0 9
115377: PUSH
115378: LD_VAR 0 10
115382: PUSH
115383: EMPTY
115384: LIST
115385: LIST
115386: PUSH
115387: LD_VAR 0 7
115391: IN
115392: NOT
115393: AND
115394: IFFALSE 115413
115396: PUSH
115397: LD_VAR 0 9
115401: PPUSH
115402: LD_VAR 0 10
115406: PPUSH
115407: CALL_OW 458
115411: NOT
115412: AND
115413: IFFALSE 115455
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
115415: LD_ADDR_VAR 0 7
115419: PUSH
115420: LD_VAR 0 7
115424: PPUSH
115425: LD_VAR 0 7
115429: PUSH
115430: LD_INT 1
115432: PLUS
115433: PPUSH
115434: LD_VAR 0 9
115438: PUSH
115439: LD_VAR 0 10
115443: PUSH
115444: EMPTY
115445: LIST
115446: LIST
115447: PPUSH
115448: CALL_OW 1
115452: ST_TO_ADDR
115453: GO 115469
// i := i - 1 ;
115455: LD_ADDR_VAR 0 5
115459: PUSH
115460: LD_VAR 0 5
115464: PUSH
115465: LD_INT 1
115467: MINUS
115468: ST_TO_ADDR
// end ;
115469: GO 115271
115471: POP
115472: POP
// for i in tmp do
115473: LD_ADDR_VAR 0 5
115477: PUSH
115478: LD_VAR 0 7
115482: PUSH
115483: FOR_IN
115484: IFFALSE 115522
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
115486: LD_VAR 0 1
115490: PPUSH
115491: LD_VAR 0 5
115495: PUSH
115496: LD_INT 1
115498: ARRAY
115499: PPUSH
115500: LD_VAR 0 5
115504: PUSH
115505: LD_INT 2
115507: ARRAY
115508: PPUSH
115509: CALL 114456 0 3
115513: NOT
115514: IFFALSE 115520
// exit ;
115516: POP
115517: POP
115518: GO 115524
115520: GO 115483
115522: POP
115523: POP
// end ;
115524: LD_VAR 0 4
115528: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
115529: LD_INT 0
115531: PPUSH
115532: PPUSH
115533: PPUSH
115534: PPUSH
115535: PPUSH
115536: PPUSH
115537: PPUSH
115538: PPUSH
115539: PPUSH
// if GetClass ( unit ) <> class_sniper then
115540: LD_VAR 0 1
115544: PPUSH
115545: CALL_OW 257
115549: PUSH
115550: LD_INT 5
115552: NONEQUAL
115553: IFFALSE 115557
// exit ;
115555: GO 116027
// dist := 8 ;
115557: LD_ADDR_VAR 0 5
115561: PUSH
115562: LD_INT 8
115564: ST_TO_ADDR
// viewRange := 12 ;
115565: LD_ADDR_VAR 0 8
115569: PUSH
115570: LD_INT 12
115572: ST_TO_ADDR
// side := GetSide ( unit ) ;
115573: LD_ADDR_VAR 0 6
115577: PUSH
115578: LD_VAR 0 1
115582: PPUSH
115583: CALL_OW 255
115587: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
115588: LD_INT 61
115590: PPUSH
115591: LD_VAR 0 6
115595: PPUSH
115596: CALL_OW 321
115600: PUSH
115601: LD_INT 2
115603: EQUAL
115604: IFFALSE 115614
// viewRange := 16 ;
115606: LD_ADDR_VAR 0 8
115610: PUSH
115611: LD_INT 16
115613: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
115614: LD_VAR 0 1
115618: PPUSH
115619: LD_VAR 0 2
115623: PPUSH
115624: LD_VAR 0 3
115628: PPUSH
115629: CALL_OW 297
115633: PUSH
115634: LD_VAR 0 5
115638: GREATER
115639: IFFALSE 115718
// begin ComMoveXY ( unit , x , y ) ;
115641: LD_VAR 0 1
115645: PPUSH
115646: LD_VAR 0 2
115650: PPUSH
115651: LD_VAR 0 3
115655: PPUSH
115656: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
115660: LD_INT 35
115662: PPUSH
115663: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
115667: LD_VAR 0 1
115671: PPUSH
115672: LD_VAR 0 2
115676: PPUSH
115677: LD_VAR 0 3
115681: PPUSH
115682: CALL 56892 0 3
115686: NOT
115687: IFFALSE 115691
// exit ;
115689: GO 116027
// until GetDistUnitXY ( unit , x , y ) < dist ;
115691: LD_VAR 0 1
115695: PPUSH
115696: LD_VAR 0 2
115700: PPUSH
115701: LD_VAR 0 3
115705: PPUSH
115706: CALL_OW 297
115710: PUSH
115711: LD_VAR 0 5
115715: LESS
115716: IFFALSE 115660
// end ; ComTurnXY ( unit , x , y ) ;
115718: LD_VAR 0 1
115722: PPUSH
115723: LD_VAR 0 2
115727: PPUSH
115728: LD_VAR 0 3
115732: PPUSH
115733: CALL_OW 118
// repeat if Multiplayer then
115737: LD_OWVAR 4
115741: IFFALSE 115752
// wait ( 35 ) else
115743: LD_INT 35
115745: PPUSH
115746: CALL_OW 67
115750: GO 115759
// wait ( 5 ) ;
115752: LD_INT 5
115754: PPUSH
115755: CALL_OW 67
// _d := GetDir ( unit ) ;
115759: LD_ADDR_VAR 0 11
115763: PUSH
115764: LD_VAR 0 1
115768: PPUSH
115769: CALL_OW 254
115773: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
115774: LD_ADDR_VAR 0 7
115778: PUSH
115779: LD_VAR 0 1
115783: PPUSH
115784: CALL_OW 250
115788: PPUSH
115789: LD_VAR 0 1
115793: PPUSH
115794: CALL_OW 251
115798: PPUSH
115799: LD_VAR 0 2
115803: PPUSH
115804: LD_VAR 0 3
115808: PPUSH
115809: CALL 59528 0 4
115813: ST_TO_ADDR
// until dir = _d ;
115814: LD_VAR 0 7
115818: PUSH
115819: LD_VAR 0 11
115823: EQUAL
115824: IFFALSE 115737
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
115826: LD_ADDR_VAR 0 9
115830: PUSH
115831: LD_VAR 0 1
115835: PPUSH
115836: CALL_OW 250
115840: PPUSH
115841: LD_VAR 0 7
115845: PPUSH
115846: LD_VAR 0 5
115850: PPUSH
115851: CALL_OW 272
115855: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
115856: LD_ADDR_VAR 0 10
115860: PUSH
115861: LD_VAR 0 1
115865: PPUSH
115866: CALL_OW 251
115870: PPUSH
115871: LD_VAR 0 7
115875: PPUSH
115876: LD_VAR 0 5
115880: PPUSH
115881: CALL_OW 273
115885: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
115886: LD_VAR 0 9
115890: PPUSH
115891: LD_VAR 0 10
115895: PPUSH
115896: CALL_OW 488
115900: NOT
115901: IFFALSE 115905
// exit ;
115903: GO 116027
// ComAnimCustom ( unit , 1 ) ;
115905: LD_VAR 0 1
115909: PPUSH
115910: LD_INT 1
115912: PPUSH
115913: CALL_OW 592
// p := 0 ;
115917: LD_ADDR_VAR 0 12
115921: PUSH
115922: LD_INT 0
115924: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
115925: LD_VAR 0 9
115929: PPUSH
115930: LD_VAR 0 10
115934: PPUSH
115935: LD_VAR 0 6
115939: PPUSH
115940: LD_VAR 0 8
115944: PPUSH
115945: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
115949: LD_INT 35
115951: PPUSH
115952: CALL_OW 67
// p := Inc ( p ) ;
115956: LD_ADDR_VAR 0 12
115960: PUSH
115961: LD_VAR 0 12
115965: PPUSH
115966: CALL 59484 0 1
115970: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
115971: LD_VAR 0 12
115975: PUSH
115976: LD_INT 3
115978: EQUAL
115979: IFTRUE 115993
115981: PUSH
115982: LD_VAR 0 1
115986: PPUSH
115987: CALL_OW 302
115991: NOT
115992: OR
115993: IFTRUE 116006
115995: PUSH
115996: LD_VAR 0 1
116000: PPUSH
116001: CALL_OW 301
116005: OR
116006: IFFALSE 115949
// RemoveSeeing ( _x , _y , side ) ;
116008: LD_VAR 0 9
116012: PPUSH
116013: LD_VAR 0 10
116017: PPUSH
116018: LD_VAR 0 6
116022: PPUSH
116023: CALL_OW 331
// end ;
116027: LD_VAR 0 4
116031: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
116032: LD_INT 0
116034: PPUSH
116035: PPUSH
116036: PPUSH
116037: PPUSH
116038: PPUSH
116039: PPUSH
116040: PPUSH
116041: PPUSH
116042: PPUSH
116043: PPUSH
116044: PPUSH
// if not unit then
116045: LD_VAR 0 1
116049: NOT
116050: IFFALSE 116054
// exit ;
116052: GO 116325
// side := GetSide ( unit ) ;
116054: LD_ADDR_VAR 0 3
116058: PUSH
116059: LD_VAR 0 1
116063: PPUSH
116064: CALL_OW 255
116068: ST_TO_ADDR
// x := GetX ( unit ) ;
116069: LD_ADDR_VAR 0 5
116073: PUSH
116074: LD_VAR 0 1
116078: PPUSH
116079: CALL_OW 250
116083: ST_TO_ADDR
// y := GetY ( unit ) ;
116084: LD_ADDR_VAR 0 6
116088: PUSH
116089: LD_VAR 0 1
116093: PPUSH
116094: CALL_OW 251
116098: ST_TO_ADDR
// r := 8 ;
116099: LD_ADDR_VAR 0 4
116103: PUSH
116104: LD_INT 8
116106: ST_TO_ADDR
// if x - r < 0 then
116107: LD_VAR 0 5
116111: PUSH
116112: LD_VAR 0 4
116116: MINUS
116117: PUSH
116118: LD_INT 0
116120: LESS
116121: IFFALSE 116133
// min_x := 0 else
116123: LD_ADDR_VAR 0 7
116127: PUSH
116128: LD_INT 0
116130: ST_TO_ADDR
116131: GO 116149
// min_x := x - r ;
116133: LD_ADDR_VAR 0 7
116137: PUSH
116138: LD_VAR 0 5
116142: PUSH
116143: LD_VAR 0 4
116147: MINUS
116148: ST_TO_ADDR
// if y - r < 0 then
116149: LD_VAR 0 6
116153: PUSH
116154: LD_VAR 0 4
116158: MINUS
116159: PUSH
116160: LD_INT 0
116162: LESS
116163: IFFALSE 116175
// min_y := 0 else
116165: LD_ADDR_VAR 0 8
116169: PUSH
116170: LD_INT 0
116172: ST_TO_ADDR
116173: GO 116191
// min_y := y - r ;
116175: LD_ADDR_VAR 0 8
116179: PUSH
116180: LD_VAR 0 6
116184: PUSH
116185: LD_VAR 0 4
116189: MINUS
116190: ST_TO_ADDR
// max_x := x + r ;
116191: LD_ADDR_VAR 0 9
116195: PUSH
116196: LD_VAR 0 5
116200: PUSH
116201: LD_VAR 0 4
116205: PLUS
116206: ST_TO_ADDR
// max_y := y + r ;
116207: LD_ADDR_VAR 0 10
116211: PUSH
116212: LD_VAR 0 6
116216: PUSH
116217: LD_VAR 0 4
116221: PLUS
116222: ST_TO_ADDR
// for _x = min_x to max_x do
116223: LD_ADDR_VAR 0 11
116227: PUSH
116228: DOUBLE
116229: LD_VAR 0 7
116233: DEC
116234: ST_TO_ADDR
116235: LD_VAR 0 9
116239: PUSH
116240: FOR_TO
116241: IFFALSE 116323
// for _y = min_y to max_y do
116243: LD_ADDR_VAR 0 12
116247: PUSH
116248: DOUBLE
116249: LD_VAR 0 8
116253: DEC
116254: ST_TO_ADDR
116255: LD_VAR 0 10
116259: PUSH
116260: FOR_TO
116261: IFFALSE 116319
// begin if not ValidHex ( _x , _y ) then
116263: LD_VAR 0 11
116267: PPUSH
116268: LD_VAR 0 12
116272: PPUSH
116273: CALL_OW 488
116277: NOT
116278: IFFALSE 116282
// continue ;
116280: GO 116260
// if MineAtPos ( _x , _y ) then
116282: LD_VAR 0 11
116286: PPUSH
116287: LD_VAR 0 12
116291: PPUSH
116292: CALL_OW 458
116296: IFFALSE 116317
// ViewMineAtPos ( _x , _y , side ) ;
116298: LD_VAR 0 11
116302: PPUSH
116303: LD_VAR 0 12
116307: PPUSH
116308: LD_VAR 0 3
116312: PPUSH
116313: CALL_OW 457
// end ;
116317: GO 116260
116319: POP
116320: POP
116321: GO 116240
116323: POP
116324: POP
// end ;
116325: LD_VAR 0 2
116329: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer ; begin
116330: LD_INT 0
116332: PPUSH
116333: PPUSH
116334: PPUSH
116335: PPUSH
116336: PPUSH
116337: PPUSH
// if not units then
116338: LD_VAR 0 1
116342: NOT
116343: IFFALSE 116347
// exit ;
116345: GO 116777
// scaners := [ ] ;
116347: LD_ADDR_VAR 0 6
116351: PUSH
116352: EMPTY
116353: ST_TO_ADDR
// for i in units do
116354: LD_ADDR_VAR 0 3
116358: PUSH
116359: LD_VAR 0 1
116363: PUSH
116364: FOR_IN
116365: IFFALSE 116522
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
116367: LD_VAR 0 3
116371: PPUSH
116372: CALL_OW 264
116376: PUSH
116377: LD_INT 11
116379: NONEQUAL
116380: IFTRUE 116394
116382: PUSH
116383: LD_VAR 0 3
116387: PPUSH
116388: CALL_OW 302
116392: NOT
116393: OR
116394: IFTRUE 116411
116396: PUSH
116397: LD_VAR 0 3
116401: PPUSH
116402: CALL_OW 110
116406: PUSH
116407: LD_INT 502
116409: EQUAL
116410: OR
116411: IFFALSE 116415
// continue ;
116413: GO 116364
// ComStop ( i ) ;
116415: LD_VAR 0 3
116419: PPUSH
116420: CALL_OW 141
// x := GetX ( i ) ;
116424: LD_ADDR_VAR 0 4
116428: PUSH
116429: LD_VAR 0 3
116433: PPUSH
116434: CALL_OW 250
116438: ST_TO_ADDR
// y := GetY ( i ) ;
116439: LD_ADDR_VAR 0 5
116443: PUSH
116444: LD_VAR 0 3
116448: PPUSH
116449: CALL_OW 251
116453: ST_TO_ADDR
// if GetSide ( i ) = your_side then
116454: LD_VAR 0 3
116458: PPUSH
116459: CALL_OW 255
116463: PUSH
116464: LD_OWVAR 2
116468: EQUAL
116469: IFFALSE 116488
// PlaySoundXY ( x , y , mineDetector ) ;
116471: LD_VAR 0 4
116475: PPUSH
116476: LD_VAR 0 5
116480: PPUSH
116481: LD_STRING mineDetector
116483: PPUSH
116484: CALL_OW 366
// scaners := Join ( scaners , i ) ;
116488: LD_ADDR_VAR 0 6
116492: PUSH
116493: LD_VAR 0 6
116497: PPUSH
116498: LD_VAR 0 3
116502: PPUSH
116503: CALL 58111 0 2
116507: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
116508: LD_VAR 0 3
116512: PPUSH
116513: LD_INT 502
116515: PPUSH
116516: CALL_OW 109
// end ;
116520: GO 116364
116522: POP
116523: POP
// if not scaners then
116524: LD_VAR 0 6
116528: NOT
116529: IFFALSE 116533
// exit ;
116531: GO 116777
// wait ( 3 ) ;
116533: LD_INT 3
116535: PPUSH
116536: CALL_OW 67
// timer := 6 ;
116540: LD_ADDR_VAR 0 7
116544: PUSH
116545: LD_INT 6
116547: ST_TO_ADDR
// repeat for i in scaners do
116548: LD_ADDR_VAR 0 3
116552: PUSH
116553: LD_VAR 0 6
116557: PUSH
116558: FOR_IN
116559: IFFALSE 116675
// begin if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
116561: LD_VAR 0 3
116565: PPUSH
116566: CALL_OW 302
116570: NOT
116571: IFTRUE 116584
116573: PUSH
116574: LD_VAR 0 3
116578: PPUSH
116579: CALL_OW 314
116583: OR
116584: IFTRUE 116615
116586: PUSH
116587: LD_VAR 0 3
116591: PPUSH
116592: CALL_OW 263
116596: PUSH
116597: LD_INT 1
116599: EQUAL
116600: IFFALSE 116614
116602: PUSH
116603: LD_VAR 0 3
116607: PPUSH
116608: CALL_OW 311
116612: NOT
116613: AND
116614: OR
116615: IFFALSE 116659
// begin SetUnitDisplayNumber ( i , 0 ) ;
116617: LD_VAR 0 3
116621: PPUSH
116622: LD_INT 0
116624: PPUSH
116625: CALL_OW 505
// SetTag ( i , 0 ) ;
116629: LD_VAR 0 3
116633: PPUSH
116634: LD_INT 0
116636: PPUSH
116637: CALL_OW 109
// scaners := scaners diff i ;
116641: LD_ADDR_VAR 0 6
116645: PUSH
116646: LD_VAR 0 6
116650: PUSH
116651: LD_VAR 0 3
116655: DIFF
116656: ST_TO_ADDR
// continue ;
116657: GO 116558
// end ; SetUnitDisplayNumber ( i , timer ) ;
116659: LD_VAR 0 3
116663: PPUSH
116664: LD_VAR 0 7
116668: PPUSH
116669: CALL_OW 505
// end ;
116673: GO 116558
116675: POP
116676: POP
// if not scaners then
116677: LD_VAR 0 6
116681: NOT
116682: IFFALSE 116686
// exit ;
116684: GO 116777
// timer := Dec ( timer ) ;
116686: LD_ADDR_VAR 0 7
116690: PUSH
116691: LD_VAR 0 7
116695: PPUSH
116696: CALL 59506 0 1
116700: ST_TO_ADDR
// wait ( 0 0$1 ) ;
116701: LD_INT 35
116703: PPUSH
116704: CALL_OW 67
// until timer = 0 ;
116708: LD_VAR 0 7
116712: PUSH
116713: LD_INT 0
116715: EQUAL
116716: IFFALSE 116548
// if not scaners then
116718: LD_VAR 0 6
116722: NOT
116723: IFFALSE 116727
// exit ;
116725: GO 116777
// for i in scaners do
116727: LD_ADDR_VAR 0 3
116731: PUSH
116732: LD_VAR 0 6
116736: PUSH
116737: FOR_IN
116738: IFFALSE 116775
// begin SetUnitDisplayNumber ( i , 0 ) ;
116740: LD_VAR 0 3
116744: PPUSH
116745: LD_INT 0
116747: PPUSH
116748: CALL_OW 505
// SetTag ( i , 0 ) ;
116752: LD_VAR 0 3
116756: PPUSH
116757: LD_INT 0
116759: PPUSH
116760: CALL_OW 109
// RevealDetectorMine ( i ) ;
116764: LD_VAR 0 3
116768: PPUSH
116769: CALL 116032 0 1
// end ;
116773: GO 116737
116775: POP
116776: POP
// end ;
116777: LD_VAR 0 2
116781: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
116782: LD_INT 0
116784: PPUSH
// if p1 = mine_detector_mode then
116785: LD_VAR 0 2
116789: PUSH
116790: LD_INT 103
116792: EQUAL
116793: IFFALSE 116804
// DetectMine ( units ) ;
116795: LD_VAR 0 1
116799: PPUSH
116800: CALL 116330 0 1
// end ; end_of_file
116804: LD_VAR 0 7
116808: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
116809: LD_INT 0
116811: PPUSH
116812: PPUSH
116813: PPUSH
116814: PPUSH
116815: PPUSH
116816: PPUSH
116817: PPUSH
116818: PPUSH
116819: PPUSH
116820: PPUSH
116821: PPUSH
116822: PPUSH
116823: PPUSH
116824: PPUSH
116825: PPUSH
116826: PPUSH
116827: PPUSH
116828: PPUSH
116829: PPUSH
116830: PPUSH
116831: PPUSH
116832: PPUSH
116833: PPUSH
116834: PPUSH
116835: PPUSH
116836: PPUSH
116837: PPUSH
116838: PPUSH
116839: PPUSH
116840: PPUSH
116841: PPUSH
116842: PPUSH
116843: PPUSH
116844: PPUSH
// if not list then
116845: LD_VAR 0 1
116849: NOT
116850: IFFALSE 116854
// exit ;
116852: GO 121573
// base := list [ 1 ] ;
116854: LD_ADDR_VAR 0 3
116858: PUSH
116859: LD_VAR 0 1
116863: PUSH
116864: LD_INT 1
116866: ARRAY
116867: ST_TO_ADDR
// group := list [ 2 ] ;
116868: LD_ADDR_VAR 0 4
116872: PUSH
116873: LD_VAR 0 1
116877: PUSH
116878: LD_INT 2
116880: ARRAY
116881: ST_TO_ADDR
// path := list [ 3 ] ;
116882: LD_ADDR_VAR 0 5
116886: PUSH
116887: LD_VAR 0 1
116891: PUSH
116892: LD_INT 3
116894: ARRAY
116895: ST_TO_ADDR
// flags := list [ 4 ] ;
116896: LD_ADDR_VAR 0 6
116900: PUSH
116901: LD_VAR 0 1
116905: PUSH
116906: LD_INT 4
116908: ARRAY
116909: ST_TO_ADDR
// mined := [ ] ;
116910: LD_ADDR_VAR 0 27
116914: PUSH
116915: EMPTY
116916: ST_TO_ADDR
// bombed := [ ] ;
116917: LD_ADDR_VAR 0 28
116921: PUSH
116922: EMPTY
116923: ST_TO_ADDR
// healers := [ ] ;
116924: LD_ADDR_VAR 0 31
116928: PUSH
116929: EMPTY
116930: ST_TO_ADDR
// to_heal := [ ] ;
116931: LD_ADDR_VAR 0 30
116935: PUSH
116936: EMPTY
116937: ST_TO_ADDR
// repairs := [ ] ;
116938: LD_ADDR_VAR 0 33
116942: PUSH
116943: EMPTY
116944: ST_TO_ADDR
// to_repair := [ ] ;
116945: LD_ADDR_VAR 0 32
116949: PUSH
116950: EMPTY
116951: ST_TO_ADDR
// if not group or not path then
116952: LD_VAR 0 4
116956: NOT
116957: IFTRUE 116966
116959: PUSH
116960: LD_VAR 0 5
116964: NOT
116965: OR
116966: IFFALSE 116970
// exit ;
116968: GO 121573
// side := GetSide ( group [ 1 ] ) ;
116970: LD_ADDR_VAR 0 35
116974: PUSH
116975: LD_VAR 0 4
116979: PUSH
116980: LD_INT 1
116982: ARRAY
116983: PPUSH
116984: CALL_OW 255
116988: ST_TO_ADDR
// if flags then
116989: LD_VAR 0 6
116993: IFFALSE 117137
// begin f_ignore_area := flags [ 1 ] ;
116995: LD_ADDR_VAR 0 17
116999: PUSH
117000: LD_VAR 0 6
117004: PUSH
117005: LD_INT 1
117007: ARRAY
117008: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
117009: LD_ADDR_VAR 0 18
117013: PUSH
117014: LD_VAR 0 6
117018: PUSH
117019: LD_INT 2
117021: ARRAY
117022: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
117023: LD_ADDR_VAR 0 19
117027: PUSH
117028: LD_VAR 0 6
117032: PUSH
117033: LD_INT 3
117035: ARRAY
117036: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
117037: LD_ADDR_VAR 0 20
117041: PUSH
117042: LD_VAR 0 6
117046: PUSH
117047: LD_INT 4
117049: ARRAY
117050: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
117051: LD_ADDR_VAR 0 21
117055: PUSH
117056: LD_VAR 0 6
117060: PUSH
117061: LD_INT 5
117063: ARRAY
117064: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
117065: LD_ADDR_VAR 0 22
117069: PUSH
117070: LD_VAR 0 6
117074: PUSH
117075: LD_INT 6
117077: ARRAY
117078: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
117079: LD_ADDR_VAR 0 23
117083: PUSH
117084: LD_VAR 0 6
117088: PUSH
117089: LD_INT 7
117091: ARRAY
117092: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
117093: LD_ADDR_VAR 0 24
117097: PUSH
117098: LD_VAR 0 6
117102: PUSH
117103: LD_INT 8
117105: ARRAY
117106: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
117107: LD_ADDR_VAR 0 25
117111: PUSH
117112: LD_VAR 0 6
117116: PUSH
117117: LD_INT 9
117119: ARRAY
117120: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
117121: LD_ADDR_VAR 0 26
117125: PUSH
117126: LD_VAR 0 6
117130: PUSH
117131: LD_INT 10
117133: ARRAY
117134: ST_TO_ADDR
// end else
117135: GO 117217
// begin f_ignore_area := false ;
117137: LD_ADDR_VAR 0 17
117141: PUSH
117142: LD_INT 0
117144: ST_TO_ADDR
// f_capture := false ;
117145: LD_ADDR_VAR 0 18
117149: PUSH
117150: LD_INT 0
117152: ST_TO_ADDR
// f_ignore_civ := false ;
117153: LD_ADDR_VAR 0 19
117157: PUSH
117158: LD_INT 0
117160: ST_TO_ADDR
// f_murder := false ;
117161: LD_ADDR_VAR 0 20
117165: PUSH
117166: LD_INT 0
117168: ST_TO_ADDR
// f_mines := false ;
117169: LD_ADDR_VAR 0 21
117173: PUSH
117174: LD_INT 0
117176: ST_TO_ADDR
// f_repair := false ;
117177: LD_ADDR_VAR 0 22
117181: PUSH
117182: LD_INT 0
117184: ST_TO_ADDR
// f_heal := false ;
117185: LD_ADDR_VAR 0 23
117189: PUSH
117190: LD_INT 0
117192: ST_TO_ADDR
// f_spacetime := false ;
117193: LD_ADDR_VAR 0 24
117197: PUSH
117198: LD_INT 0
117200: ST_TO_ADDR
// f_attack_depot := false ;
117201: LD_ADDR_VAR 0 25
117205: PUSH
117206: LD_INT 0
117208: ST_TO_ADDR
// f_crawl := false ;
117209: LD_ADDR_VAR 0 26
117213: PUSH
117214: LD_INT 0
117216: ST_TO_ADDR
// end ; if f_heal then
117217: LD_VAR 0 23
117221: IFFALSE 117248
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
117223: LD_ADDR_VAR 0 31
117227: PUSH
117228: LD_VAR 0 4
117232: PPUSH
117233: LD_INT 25
117235: PUSH
117236: LD_INT 4
117238: PUSH
117239: EMPTY
117240: LIST
117241: LIST
117242: PPUSH
117243: CALL_OW 72
117247: ST_TO_ADDR
// if f_repair then
117248: LD_VAR 0 22
117252: IFFALSE 117279
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
117254: LD_ADDR_VAR 0 33
117258: PUSH
117259: LD_VAR 0 4
117263: PPUSH
117264: LD_INT 25
117266: PUSH
117267: LD_INT 3
117269: PUSH
117270: EMPTY
117271: LIST
117272: LIST
117273: PPUSH
117274: CALL_OW 72
117278: ST_TO_ADDR
// units_path := [ ] ;
117279: LD_ADDR_VAR 0 16
117283: PUSH
117284: EMPTY
117285: ST_TO_ADDR
// for i = 1 to group do
117286: LD_ADDR_VAR 0 7
117290: PUSH
117291: DOUBLE
117292: LD_INT 1
117294: DEC
117295: ST_TO_ADDR
117296: LD_VAR 0 4
117300: PUSH
117301: FOR_TO
117302: IFFALSE 117331
// units_path := Replace ( units_path , i , path ) ;
117304: LD_ADDR_VAR 0 16
117308: PUSH
117309: LD_VAR 0 16
117313: PPUSH
117314: LD_VAR 0 7
117318: PPUSH
117319: LD_VAR 0 5
117323: PPUSH
117324: CALL_OW 1
117328: ST_TO_ADDR
117329: GO 117301
117331: POP
117332: POP
// repeat for i = group downto 1 do
117333: LD_ADDR_VAR 0 7
117337: PUSH
117338: DOUBLE
117339: LD_VAR 0 4
117343: INC
117344: ST_TO_ADDR
117345: LD_INT 1
117347: PUSH
117348: FOR_DOWNTO
117349: IFFALSE 121525
// begin wait ( 5 ) ;
117351: LD_INT 5
117353: PPUSH
117354: CALL_OW 67
// tmp := [ ] ;
117358: LD_ADDR_VAR 0 14
117362: PUSH
117363: EMPTY
117364: ST_TO_ADDR
// attacking := false ;
117365: LD_ADDR_VAR 0 29
117369: PUSH
117370: LD_INT 0
117372: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
117373: LD_VAR 0 4
117377: PUSH
117378: LD_VAR 0 7
117382: ARRAY
117383: PPUSH
117384: CALL_OW 301
117388: IFTRUE 117403
117390: PUSH
117391: LD_VAR 0 4
117395: PUSH
117396: LD_VAR 0 7
117400: ARRAY
117401: NOT
117402: OR
117403: IFFALSE 117512
// begin if GetType ( group [ i ] ) = unit_human then
117405: LD_VAR 0 4
117409: PUSH
117410: LD_VAR 0 7
117414: ARRAY
117415: PPUSH
117416: CALL_OW 247
117420: PUSH
117421: LD_INT 1
117423: EQUAL
117424: IFFALSE 117470
// begin to_heal := to_heal diff group [ i ] ;
117426: LD_ADDR_VAR 0 30
117430: PUSH
117431: LD_VAR 0 30
117435: PUSH
117436: LD_VAR 0 4
117440: PUSH
117441: LD_VAR 0 7
117445: ARRAY
117446: DIFF
117447: ST_TO_ADDR
// healers := healers diff group [ i ] ;
117448: LD_ADDR_VAR 0 31
117452: PUSH
117453: LD_VAR 0 31
117457: PUSH
117458: LD_VAR 0 4
117462: PUSH
117463: LD_VAR 0 7
117467: ARRAY
117468: DIFF
117469: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
117470: LD_ADDR_VAR 0 4
117474: PUSH
117475: LD_VAR 0 4
117479: PPUSH
117480: LD_VAR 0 7
117484: PPUSH
117485: CALL_OW 3
117489: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
117490: LD_ADDR_VAR 0 16
117494: PUSH
117495: LD_VAR 0 16
117499: PPUSH
117500: LD_VAR 0 7
117504: PPUSH
117505: CALL_OW 3
117509: ST_TO_ADDR
// continue ;
117510: GO 117348
// end ; if f_repair then
117512: LD_VAR 0 22
117516: IFFALSE 118013
// begin if GetType ( group [ i ] ) = unit_vehicle then
117518: LD_VAR 0 4
117522: PUSH
117523: LD_VAR 0 7
117527: ARRAY
117528: PPUSH
117529: CALL_OW 247
117533: PUSH
117534: LD_INT 2
117536: EQUAL
117537: IFFALSE 117731
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
117539: LD_VAR 0 4
117543: PUSH
117544: LD_VAR 0 7
117548: ARRAY
117549: PPUSH
117550: CALL_OW 256
117554: PUSH
117555: LD_INT 700
117557: LESS
117558: IFFALSE 117579
117560: PUSH
117561: LD_VAR 0 4
117565: PUSH
117566: LD_VAR 0 7
117570: ARRAY
117571: PUSH
117572: LD_VAR 0 32
117576: IN
117577: NOT
117578: AND
117579: IFFALSE 117603
// to_repair := to_repair union group [ i ] ;
117581: LD_ADDR_VAR 0 32
117585: PUSH
117586: LD_VAR 0 32
117590: PUSH
117591: LD_VAR 0 4
117595: PUSH
117596: LD_VAR 0 7
117600: ARRAY
117601: UNION
117602: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
117603: LD_VAR 0 4
117607: PUSH
117608: LD_VAR 0 7
117612: ARRAY
117613: PPUSH
117614: CALL_OW 256
117618: PUSH
117619: LD_INT 1000
117621: EQUAL
117622: IFFALSE 117642
117624: PUSH
117625: LD_VAR 0 4
117629: PUSH
117630: LD_VAR 0 7
117634: ARRAY
117635: PUSH
117636: LD_VAR 0 32
117640: IN
117641: AND
117642: IFFALSE 117666
// to_repair := to_repair diff group [ i ] ;
117644: LD_ADDR_VAR 0 32
117648: PUSH
117649: LD_VAR 0 32
117653: PUSH
117654: LD_VAR 0 4
117658: PUSH
117659: LD_VAR 0 7
117663: ARRAY
117664: DIFF
117665: ST_TO_ADDR
// if group [ i ] in to_repair then
117666: LD_VAR 0 4
117670: PUSH
117671: LD_VAR 0 7
117675: ARRAY
117676: PUSH
117677: LD_VAR 0 32
117681: IN
117682: IFFALSE 117729
// begin if not IsInArea ( group [ i ] , f_repair ) then
117684: LD_VAR 0 4
117688: PUSH
117689: LD_VAR 0 7
117693: ARRAY
117694: PPUSH
117695: LD_VAR 0 22
117699: PPUSH
117700: CALL_OW 308
117704: NOT
117705: IFFALSE 117727
// ComMoveToArea ( group [ i ] , f_repair ) ;
117707: LD_VAR 0 4
117711: PUSH
117712: LD_VAR 0 7
117716: ARRAY
117717: PPUSH
117718: LD_VAR 0 22
117722: PPUSH
117723: CALL_OW 113
// continue ;
117727: GO 117348
// end ; end else
117729: GO 118013
// if group [ i ] in repairs then
117731: LD_VAR 0 4
117735: PUSH
117736: LD_VAR 0 7
117740: ARRAY
117741: PUSH
117742: LD_VAR 0 33
117746: IN
117747: IFFALSE 118013
// begin if IsInUnit ( group [ i ] ) then
117749: LD_VAR 0 4
117753: PUSH
117754: LD_VAR 0 7
117758: ARRAY
117759: PPUSH
117760: CALL_OW 310
117764: IFFALSE 117834
// begin z := IsInUnit ( group [ i ] ) ;
117766: LD_ADDR_VAR 0 13
117770: PUSH
117771: LD_VAR 0 4
117775: PUSH
117776: LD_VAR 0 7
117780: ARRAY
117781: PPUSH
117782: CALL_OW 310
117786: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
117787: LD_VAR 0 13
117791: PUSH
117792: LD_VAR 0 32
117796: IN
117797: IFFALSE 117815
117799: PUSH
117800: LD_VAR 0 13
117804: PPUSH
117805: LD_VAR 0 22
117809: PPUSH
117810: CALL_OW 308
117814: AND
117815: IFFALSE 117832
// ComExitVehicle ( group [ i ] ) ;
117817: LD_VAR 0 4
117821: PUSH
117822: LD_VAR 0 7
117826: ARRAY
117827: PPUSH
117828: CALL_OW 121
// end else
117832: GO 118013
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
117834: LD_ADDR_VAR 0 13
117838: PUSH
117839: LD_VAR 0 4
117843: PPUSH
117844: LD_INT 95
117846: PUSH
117847: LD_VAR 0 22
117851: PUSH
117852: EMPTY
117853: LIST
117854: LIST
117855: PUSH
117856: LD_INT 58
117858: PUSH
117859: EMPTY
117860: LIST
117861: PUSH
117862: EMPTY
117863: LIST
117864: LIST
117865: PPUSH
117866: CALL_OW 72
117870: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
117871: LD_VAR 0 4
117875: PUSH
117876: LD_VAR 0 7
117880: ARRAY
117881: PPUSH
117882: CALL_OW 314
117886: NOT
117887: IFFALSE 118011
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
117889: LD_ADDR_VAR 0 10
117893: PUSH
117894: LD_VAR 0 13
117898: PPUSH
117899: LD_VAR 0 4
117903: PUSH
117904: LD_VAR 0 7
117908: ARRAY
117909: PPUSH
117910: CALL_OW 74
117914: ST_TO_ADDR
// if not x then
117915: LD_VAR 0 10
117919: NOT
117920: IFFALSE 117924
// continue ;
117922: GO 117348
// if GetLives ( x ) < 1000 then
117924: LD_VAR 0 10
117928: PPUSH
117929: CALL_OW 256
117933: PUSH
117934: LD_INT 1000
117936: LESS
117937: IFFALSE 117961
// ComRepairVehicle ( group [ i ] , x ) else
117939: LD_VAR 0 4
117943: PUSH
117944: LD_VAR 0 7
117948: ARRAY
117949: PPUSH
117950: LD_VAR 0 10
117954: PPUSH
117955: CALL_OW 129
117959: GO 118011
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
117961: LD_VAR 0 23
117965: IFFALSE 117988
117967: PUSH
117968: LD_VAR 0 4
117972: PUSH
117973: LD_VAR 0 7
117977: ARRAY
117978: PPUSH
117979: CALL_OW 256
117983: PUSH
117984: LD_INT 1000
117986: LESS
117987: AND
117988: NOT
117989: IFFALSE 118011
// ComEnterUnit ( group [ i ] , x ) ;
117991: LD_VAR 0 4
117995: PUSH
117996: LD_VAR 0 7
118000: ARRAY
118001: PPUSH
118002: LD_VAR 0 10
118006: PPUSH
118007: CALL_OW 120
// end ; continue ;
118011: GO 117348
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
118013: LD_VAR 0 23
118017: IFFALSE 118040
118019: PUSH
118020: LD_VAR 0 4
118024: PUSH
118025: LD_VAR 0 7
118029: ARRAY
118030: PPUSH
118031: CALL_OW 247
118035: PUSH
118036: LD_INT 1
118038: EQUAL
118039: AND
118040: IFFALSE 118524
// begin if group [ i ] in healers then
118042: LD_VAR 0 4
118046: PUSH
118047: LD_VAR 0 7
118051: ARRAY
118052: PUSH
118053: LD_VAR 0 31
118057: IN
118058: IFFALSE 118335
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
118060: LD_VAR 0 4
118064: PUSH
118065: LD_VAR 0 7
118069: ARRAY
118070: PPUSH
118071: LD_VAR 0 23
118075: PPUSH
118076: CALL_OW 308
118080: NOT
118081: IFFALSE 118101
118083: PUSH
118084: LD_VAR 0 4
118088: PUSH
118089: LD_VAR 0 7
118093: ARRAY
118094: PPUSH
118095: CALL_OW 314
118099: NOT
118100: AND
118101: IFFALSE 118125
// ComMoveToArea ( group [ i ] , f_heal ) else
118103: LD_VAR 0 4
118107: PUSH
118108: LD_VAR 0 7
118112: ARRAY
118113: PPUSH
118114: LD_VAR 0 23
118118: PPUSH
118119: CALL_OW 113
118123: GO 118333
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
118125: LD_VAR 0 4
118129: PUSH
118130: LD_VAR 0 7
118134: ARRAY
118135: PPUSH
118136: CALL 55467 0 1
118140: PPUSH
118141: CALL_OW 256
118145: PUSH
118146: LD_INT 1000
118148: EQUAL
118149: IFFALSE 118168
// ComStop ( group [ i ] ) else
118151: LD_VAR 0 4
118155: PUSH
118156: LD_VAR 0 7
118160: ARRAY
118161: PPUSH
118162: CALL_OW 141
118166: GO 118333
// if not HasTask ( group [ i ] ) and to_heal then
118168: LD_VAR 0 4
118172: PUSH
118173: LD_VAR 0 7
118177: ARRAY
118178: PPUSH
118179: CALL_OW 314
118183: NOT
118184: IFFALSE 118192
118186: PUSH
118187: LD_VAR 0 30
118191: AND
118192: IFFALSE 118333
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
118194: LD_ADDR_VAR 0 13
118198: PUSH
118199: LD_VAR 0 30
118203: PPUSH
118204: LD_INT 3
118206: PUSH
118207: LD_INT 54
118209: PUSH
118210: EMPTY
118211: LIST
118212: PUSH
118213: EMPTY
118214: LIST
118215: LIST
118216: PPUSH
118217: CALL_OW 72
118221: PPUSH
118222: LD_VAR 0 4
118226: PUSH
118227: LD_VAR 0 7
118231: ARRAY
118232: PPUSH
118233: CALL_OW 74
118237: ST_TO_ADDR
// if z then
118238: LD_VAR 0 13
118242: IFFALSE 118333
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
118244: LD_INT 91
118246: PUSH
118247: LD_VAR 0 13
118251: PUSH
118252: LD_INT 10
118254: PUSH
118255: EMPTY
118256: LIST
118257: LIST
118258: LIST
118259: PUSH
118260: LD_INT 81
118262: PUSH
118263: LD_VAR 0 13
118267: PPUSH
118268: CALL_OW 255
118272: PUSH
118273: EMPTY
118274: LIST
118275: LIST
118276: PUSH
118277: EMPTY
118278: LIST
118279: LIST
118280: PPUSH
118281: CALL_OW 69
118285: PUSH
118286: LD_INT 0
118288: EQUAL
118289: IFFALSE 118313
// ComHeal ( group [ i ] , z ) else
118291: LD_VAR 0 4
118295: PUSH
118296: LD_VAR 0 7
118300: ARRAY
118301: PPUSH
118302: LD_VAR 0 13
118306: PPUSH
118307: CALL_OW 128
118311: GO 118333
// ComMoveToArea ( group [ i ] , f_heal ) ;
118313: LD_VAR 0 4
118317: PUSH
118318: LD_VAR 0 7
118322: ARRAY
118323: PPUSH
118324: LD_VAR 0 23
118328: PPUSH
118329: CALL_OW 113
// end ; continue ;
118333: GO 117348
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
118335: LD_VAR 0 4
118339: PUSH
118340: LD_VAR 0 7
118344: ARRAY
118345: PPUSH
118346: CALL_OW 256
118350: PUSH
118351: LD_INT 700
118353: LESS
118354: IFFALSE 118375
118356: PUSH
118357: LD_VAR 0 4
118361: PUSH
118362: LD_VAR 0 7
118366: ARRAY
118367: PUSH
118368: LD_VAR 0 30
118372: IN
118373: NOT
118374: AND
118375: IFFALSE 118399
// to_heal := to_heal union group [ i ] ;
118377: LD_ADDR_VAR 0 30
118381: PUSH
118382: LD_VAR 0 30
118386: PUSH
118387: LD_VAR 0 4
118391: PUSH
118392: LD_VAR 0 7
118396: ARRAY
118397: UNION
118398: ST_TO_ADDR
// if group [ i ] in to_heal then
118399: LD_VAR 0 4
118403: PUSH
118404: LD_VAR 0 7
118408: ARRAY
118409: PUSH
118410: LD_VAR 0 30
118414: IN
118415: IFFALSE 118524
// begin if GetLives ( group [ i ] ) = 1000 then
118417: LD_VAR 0 4
118421: PUSH
118422: LD_VAR 0 7
118426: ARRAY
118427: PPUSH
118428: CALL_OW 256
118432: PUSH
118433: LD_INT 1000
118435: EQUAL
118436: IFFALSE 118462
// to_heal := to_heal diff group [ i ] else
118438: LD_ADDR_VAR 0 30
118442: PUSH
118443: LD_VAR 0 30
118447: PUSH
118448: LD_VAR 0 4
118452: PUSH
118453: LD_VAR 0 7
118457: ARRAY
118458: DIFF
118459: ST_TO_ADDR
118460: GO 118524
// begin if not IsInArea ( group [ i ] , to_heal ) then
118462: LD_VAR 0 4
118466: PUSH
118467: LD_VAR 0 7
118471: ARRAY
118472: PPUSH
118473: LD_VAR 0 30
118477: PPUSH
118478: CALL_OW 308
118482: NOT
118483: IFFALSE 118507
// ComMoveToArea ( group [ i ] , f_heal ) else
118485: LD_VAR 0 4
118489: PUSH
118490: LD_VAR 0 7
118494: ARRAY
118495: PPUSH
118496: LD_VAR 0 23
118500: PPUSH
118501: CALL_OW 113
118505: GO 118522
// ComHold ( group [ i ] ) ;
118507: LD_VAR 0 4
118511: PUSH
118512: LD_VAR 0 7
118516: ARRAY
118517: PPUSH
118518: CALL_OW 140
// continue ;
118522: GO 117348
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
118524: LD_VAR 0 4
118528: PUSH
118529: LD_VAR 0 7
118533: ARRAY
118534: PPUSH
118535: LD_INT 10
118537: PPUSH
118538: CALL 53076 0 2
118542: NOT
118543: IFFALSE 118561
118545: PUSH
118546: LD_VAR 0 16
118550: PUSH
118551: LD_VAR 0 7
118555: ARRAY
118556: PUSH
118557: EMPTY
118558: EQUAL
118559: NOT
118560: AND
118561: IFFALSE 118827
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
118563: LD_VAR 0 4
118567: PUSH
118568: LD_VAR 0 7
118572: ARRAY
118573: PPUSH
118574: CALL_OW 262
118578: PUSH
118579: LD_INT 1
118581: PUSH
118582: LD_INT 2
118584: PUSH
118585: EMPTY
118586: LIST
118587: LIST
118588: IN
118589: IFFALSE 118630
// if GetFuel ( group [ i ] ) < 10 then
118591: LD_VAR 0 4
118595: PUSH
118596: LD_VAR 0 7
118600: ARRAY
118601: PPUSH
118602: CALL_OW 261
118606: PUSH
118607: LD_INT 10
118609: LESS
118610: IFFALSE 118630
// SetFuel ( group [ i ] , 12 ) ;
118612: LD_VAR 0 4
118616: PUSH
118617: LD_VAR 0 7
118621: ARRAY
118622: PPUSH
118623: LD_INT 12
118625: PPUSH
118626: CALL_OW 240
// if units_path [ i ] then
118630: LD_VAR 0 16
118634: PUSH
118635: LD_VAR 0 7
118639: ARRAY
118640: IFFALSE 118825
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
118642: LD_VAR 0 4
118646: PUSH
118647: LD_VAR 0 7
118651: ARRAY
118652: PPUSH
118653: LD_VAR 0 16
118657: PUSH
118658: LD_VAR 0 7
118662: ARRAY
118663: PUSH
118664: LD_INT 1
118666: ARRAY
118667: PUSH
118668: LD_INT 1
118670: ARRAY
118671: PPUSH
118672: LD_VAR 0 16
118676: PUSH
118677: LD_VAR 0 7
118681: ARRAY
118682: PUSH
118683: LD_INT 1
118685: ARRAY
118686: PUSH
118687: LD_INT 2
118689: ARRAY
118690: PPUSH
118691: CALL_OW 297
118695: PUSH
118696: LD_INT 6
118698: GREATER
118699: IFFALSE 118774
// begin if not HasTask ( group [ i ] ) then
118701: LD_VAR 0 4
118705: PUSH
118706: LD_VAR 0 7
118710: ARRAY
118711: PPUSH
118712: CALL_OW 314
118716: NOT
118717: IFFALSE 118772
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
118719: LD_VAR 0 4
118723: PUSH
118724: LD_VAR 0 7
118728: ARRAY
118729: PPUSH
118730: LD_VAR 0 16
118734: PUSH
118735: LD_VAR 0 7
118739: ARRAY
118740: PUSH
118741: LD_INT 1
118743: ARRAY
118744: PUSH
118745: LD_INT 1
118747: ARRAY
118748: PPUSH
118749: LD_VAR 0 16
118753: PUSH
118754: LD_VAR 0 7
118758: ARRAY
118759: PUSH
118760: LD_INT 1
118762: ARRAY
118763: PUSH
118764: LD_INT 2
118766: ARRAY
118767: PPUSH
118768: CALL_OW 114
// end else
118772: GO 118825
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
118774: LD_ADDR_VAR 0 15
118778: PUSH
118779: LD_VAR 0 16
118783: PUSH
118784: LD_VAR 0 7
118788: ARRAY
118789: PPUSH
118790: LD_INT 1
118792: PPUSH
118793: CALL_OW 3
118797: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
118798: LD_ADDR_VAR 0 16
118802: PUSH
118803: LD_VAR 0 16
118807: PPUSH
118808: LD_VAR 0 7
118812: PPUSH
118813: LD_VAR 0 15
118817: PPUSH
118818: CALL_OW 1
118822: ST_TO_ADDR
// continue ;
118823: GO 117348
// end ; end ; end else
118825: GO 121523
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
118827: LD_ADDR_VAR 0 14
118831: PUSH
118832: LD_INT 81
118834: PUSH
118835: LD_VAR 0 4
118839: PUSH
118840: LD_VAR 0 7
118844: ARRAY
118845: PPUSH
118846: CALL_OW 255
118850: PUSH
118851: EMPTY
118852: LIST
118853: LIST
118854: PPUSH
118855: CALL_OW 69
118859: ST_TO_ADDR
// if not tmp then
118860: LD_VAR 0 14
118864: NOT
118865: IFFALSE 118869
// continue ;
118867: GO 117348
// if f_ignore_area then
118869: LD_VAR 0 17
118873: IFFALSE 118961
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
118875: LD_ADDR_VAR 0 15
118879: PUSH
118880: LD_VAR 0 14
118884: PPUSH
118885: LD_INT 3
118887: PUSH
118888: LD_INT 92
118890: PUSH
118891: LD_VAR 0 17
118895: PUSH
118896: LD_INT 1
118898: ARRAY
118899: PUSH
118900: LD_VAR 0 17
118904: PUSH
118905: LD_INT 2
118907: ARRAY
118908: PUSH
118909: LD_VAR 0 17
118913: PUSH
118914: LD_INT 3
118916: ARRAY
118917: PUSH
118918: EMPTY
118919: LIST
118920: LIST
118921: LIST
118922: LIST
118923: PUSH
118924: EMPTY
118925: LIST
118926: LIST
118927: PPUSH
118928: CALL_OW 72
118932: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
118933: LD_VAR 0 14
118937: PUSH
118938: LD_VAR 0 15
118942: DIFF
118943: IFFALSE 118961
// tmp := tmp diff tmp2 ;
118945: LD_ADDR_VAR 0 14
118949: PUSH
118950: LD_VAR 0 14
118954: PUSH
118955: LD_VAR 0 15
118959: DIFF
118960: ST_TO_ADDR
// end ; if not f_murder then
118961: LD_VAR 0 20
118965: NOT
118966: IFFALSE 119024
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
118968: LD_ADDR_VAR 0 15
118972: PUSH
118973: LD_VAR 0 14
118977: PPUSH
118978: LD_INT 3
118980: PUSH
118981: LD_INT 50
118983: PUSH
118984: EMPTY
118985: LIST
118986: PUSH
118987: EMPTY
118988: LIST
118989: LIST
118990: PPUSH
118991: CALL_OW 72
118995: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
118996: LD_VAR 0 14
119000: PUSH
119001: LD_VAR 0 15
119005: DIFF
119006: IFFALSE 119024
// tmp := tmp diff tmp2 ;
119008: LD_ADDR_VAR 0 14
119012: PUSH
119013: LD_VAR 0 14
119017: PUSH
119018: LD_VAR 0 15
119022: DIFF
119023: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
119024: LD_ADDR_VAR 0 14
119028: PUSH
119029: LD_VAR 0 4
119033: PUSH
119034: LD_VAR 0 7
119038: ARRAY
119039: PPUSH
119040: LD_VAR 0 14
119044: PPUSH
119045: LD_INT 1
119047: PPUSH
119048: LD_INT 1
119050: PPUSH
119051: CALL 25498 0 4
119055: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
119056: LD_VAR 0 4
119060: PUSH
119061: LD_VAR 0 7
119065: ARRAY
119066: PPUSH
119067: CALL_OW 257
119071: PUSH
119072: LD_INT 1
119074: EQUAL
119075: IFFALSE 119535
// begin if WantPlant ( group [ i ] ) then
119077: LD_VAR 0 4
119081: PUSH
119082: LD_VAR 0 7
119086: ARRAY
119087: PPUSH
119088: CALL 24999 0 1
119092: IFFALSE 119096
// continue ;
119094: GO 117348
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
119096: LD_VAR 0 18
119100: IFFALSE 119120
119102: PUSH
119103: LD_VAR 0 4
119107: PUSH
119108: LD_VAR 0 7
119112: ARRAY
119113: PPUSH
119114: CALL_OW 310
119118: NOT
119119: AND
119120: IFFALSE 119163
119122: PUSH
119123: LD_VAR 0 14
119127: PUSH
119128: LD_INT 1
119130: ARRAY
119131: PUSH
119132: LD_VAR 0 14
119136: PPUSH
119137: LD_INT 21
119139: PUSH
119140: LD_INT 2
119142: PUSH
119143: EMPTY
119144: LIST
119145: LIST
119146: PUSH
119147: LD_INT 58
119149: PUSH
119150: EMPTY
119151: LIST
119152: PUSH
119153: EMPTY
119154: LIST
119155: LIST
119156: PPUSH
119157: CALL_OW 72
119161: IN
119162: AND
119163: IFFALSE 119199
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
119165: LD_VAR 0 4
119169: PUSH
119170: LD_VAR 0 7
119174: ARRAY
119175: PPUSH
119176: LD_VAR 0 14
119180: PUSH
119181: LD_INT 1
119183: ARRAY
119184: PPUSH
119185: CALL_OW 120
// attacking := true ;
119189: LD_ADDR_VAR 0 29
119193: PUSH
119194: LD_INT 1
119196: ST_TO_ADDR
// continue ;
119197: GO 117348
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
119199: LD_VAR 0 26
119203: IFFALSE 119226
119205: PUSH
119206: LD_VAR 0 4
119210: PUSH
119211: LD_VAR 0 7
119215: ARRAY
119216: PPUSH
119217: CALL_OW 257
119221: PUSH
119222: LD_INT 1
119224: EQUAL
119225: AND
119226: IFFALSE 119249
119228: PUSH
119229: LD_VAR 0 4
119233: PUSH
119234: LD_VAR 0 7
119238: ARRAY
119239: PPUSH
119240: CALL_OW 256
119244: PUSH
119245: LD_INT 800
119247: LESS
119248: AND
119249: IFFALSE 119269
119251: PUSH
119252: LD_VAR 0 4
119256: PUSH
119257: LD_VAR 0 7
119261: ARRAY
119262: PPUSH
119263: CALL_OW 318
119267: NOT
119268: AND
119269: IFFALSE 119286
// ComCrawl ( group [ i ] ) ;
119271: LD_VAR 0 4
119275: PUSH
119276: LD_VAR 0 7
119280: ARRAY
119281: PPUSH
119282: CALL_OW 137
// if f_mines then
119286: LD_VAR 0 21
119290: IFFALSE 119535
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
119292: LD_VAR 0 14
119296: PUSH
119297: LD_INT 1
119299: ARRAY
119300: PPUSH
119301: CALL_OW 247
119305: PUSH
119306: LD_INT 3
119308: EQUAL
119309: IFFALSE 119328
119311: PUSH
119312: LD_VAR 0 14
119316: PUSH
119317: LD_INT 1
119319: ARRAY
119320: PUSH
119321: LD_VAR 0 27
119325: IN
119326: NOT
119327: AND
119328: IFFALSE 119535
// begin x := GetX ( tmp [ 1 ] ) ;
119330: LD_ADDR_VAR 0 10
119334: PUSH
119335: LD_VAR 0 14
119339: PUSH
119340: LD_INT 1
119342: ARRAY
119343: PPUSH
119344: CALL_OW 250
119348: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
119349: LD_ADDR_VAR 0 11
119353: PUSH
119354: LD_VAR 0 14
119358: PUSH
119359: LD_INT 1
119361: ARRAY
119362: PPUSH
119363: CALL_OW 251
119367: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
119368: LD_ADDR_VAR 0 12
119372: PUSH
119373: LD_VAR 0 4
119377: PUSH
119378: LD_VAR 0 7
119382: ARRAY
119383: PPUSH
119384: CALL 53161 0 1
119388: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
119389: LD_VAR 0 4
119393: PUSH
119394: LD_VAR 0 7
119398: ARRAY
119399: PPUSH
119400: LD_VAR 0 10
119404: PPUSH
119405: LD_VAR 0 11
119409: PPUSH
119410: LD_VAR 0 14
119414: PUSH
119415: LD_INT 1
119417: ARRAY
119418: PPUSH
119419: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
119423: LD_VAR 0 4
119427: PUSH
119428: LD_VAR 0 7
119432: ARRAY
119433: PPUSH
119434: LD_VAR 0 10
119438: PPUSH
119439: LD_VAR 0 12
119443: PPUSH
119444: LD_INT 7
119446: PPUSH
119447: CALL_OW 272
119451: PPUSH
119452: LD_VAR 0 11
119456: PPUSH
119457: LD_VAR 0 12
119461: PPUSH
119462: LD_INT 7
119464: PPUSH
119465: CALL_OW 273
119469: PPUSH
119470: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
119474: LD_VAR 0 4
119478: PUSH
119479: LD_VAR 0 7
119483: ARRAY
119484: PPUSH
119485: LD_INT 71
119487: PPUSH
119488: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
119492: LD_ADDR_VAR 0 27
119496: PUSH
119497: LD_VAR 0 27
119501: PPUSH
119502: LD_VAR 0 27
119506: PUSH
119507: LD_INT 1
119509: PLUS
119510: PPUSH
119511: LD_VAR 0 14
119515: PUSH
119516: LD_INT 1
119518: ARRAY
119519: PPUSH
119520: CALL_OW 1
119524: ST_TO_ADDR
// attacking := true ;
119525: LD_ADDR_VAR 0 29
119529: PUSH
119530: LD_INT 1
119532: ST_TO_ADDR
// continue ;
119533: GO 117348
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
119535: LD_VAR 0 4
119539: PUSH
119540: LD_VAR 0 7
119544: ARRAY
119545: PPUSH
119546: CALL_OW 257
119550: PUSH
119551: LD_INT 17
119553: EQUAL
119554: IFFALSE 119578
119556: PUSH
119557: LD_VAR 0 4
119561: PUSH
119562: LD_VAR 0 7
119566: ARRAY
119567: PPUSH
119568: CALL_OW 110
119572: PUSH
119573: LD_INT 71
119575: EQUAL
119576: NOT
119577: AND
119578: IFFALSE 119724
// begin attacking := false ;
119580: LD_ADDR_VAR 0 29
119584: PUSH
119585: LD_INT 0
119587: ST_TO_ADDR
// k := 5 ;
119588: LD_ADDR_VAR 0 9
119592: PUSH
119593: LD_INT 5
119595: ST_TO_ADDR
// if tmp < k then
119596: LD_VAR 0 14
119600: PUSH
119601: LD_VAR 0 9
119605: LESS
119606: IFFALSE 119618
// k := tmp ;
119608: LD_ADDR_VAR 0 9
119612: PUSH
119613: LD_VAR 0 14
119617: ST_TO_ADDR
// for j = 1 to k do
119618: LD_ADDR_VAR 0 8
119622: PUSH
119623: DOUBLE
119624: LD_INT 1
119626: DEC
119627: ST_TO_ADDR
119628: LD_VAR 0 9
119632: PUSH
119633: FOR_TO
119634: IFFALSE 119722
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
119636: LD_VAR 0 14
119640: PUSH
119641: LD_VAR 0 8
119645: ARRAY
119646: PUSH
119647: LD_VAR 0 14
119651: PPUSH
119652: LD_INT 58
119654: PUSH
119655: EMPTY
119656: LIST
119657: PPUSH
119658: CALL_OW 72
119662: IN
119663: NOT
119664: IFFALSE 119720
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119666: LD_VAR 0 4
119670: PUSH
119671: LD_VAR 0 7
119675: ARRAY
119676: PPUSH
119677: LD_VAR 0 14
119681: PUSH
119682: LD_VAR 0 8
119686: ARRAY
119687: PPUSH
119688: CALL_OW 115
// attacking := true ;
119692: LD_ADDR_VAR 0 29
119696: PUSH
119697: LD_INT 1
119699: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
119700: LD_VAR 0 4
119704: PUSH
119705: LD_VAR 0 7
119709: ARRAY
119710: PPUSH
119711: LD_INT 71
119713: PPUSH
119714: CALL_OW 109
// continue ;
119718: GO 119633
// end ; end ;
119720: GO 119633
119722: POP
119723: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
119724: LD_VAR 0 4
119728: PUSH
119729: LD_VAR 0 7
119733: ARRAY
119734: PPUSH
119735: CALL_OW 257
119739: PUSH
119740: LD_INT 8
119742: EQUAL
119743: IFTRUE 119781
119745: PUSH
119746: LD_VAR 0 4
119750: PUSH
119751: LD_VAR 0 7
119755: ARRAY
119756: PPUSH
119757: CALL_OW 264
119761: PUSH
119762: LD_INT 28
119764: PUSH
119765: LD_INT 45
119767: PUSH
119768: LD_INT 7
119770: PUSH
119771: LD_INT 47
119773: PUSH
119774: EMPTY
119775: LIST
119776: LIST
119777: LIST
119778: LIST
119779: IN
119780: OR
119781: IFFALSE 120037
// begin attacking := false ;
119783: LD_ADDR_VAR 0 29
119787: PUSH
119788: LD_INT 0
119790: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
119791: LD_VAR 0 14
119795: PUSH
119796: LD_INT 1
119798: ARRAY
119799: PPUSH
119800: CALL_OW 266
119804: PUSH
119805: LD_INT 32
119807: PUSH
119808: LD_INT 31
119810: PUSH
119811: LD_INT 33
119813: PUSH
119814: LD_INT 4
119816: PUSH
119817: LD_INT 5
119819: PUSH
119820: EMPTY
119821: LIST
119822: LIST
119823: LIST
119824: LIST
119825: LIST
119826: IN
119827: IFFALSE 120013
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
119829: LD_ADDR_VAR 0 9
119833: PUSH
119834: LD_VAR 0 14
119838: PUSH
119839: LD_INT 1
119841: ARRAY
119842: PPUSH
119843: CALL_OW 266
119847: PPUSH
119848: LD_VAR 0 14
119852: PUSH
119853: LD_INT 1
119855: ARRAY
119856: PPUSH
119857: CALL_OW 250
119861: PPUSH
119862: LD_VAR 0 14
119866: PUSH
119867: LD_INT 1
119869: ARRAY
119870: PPUSH
119871: CALL_OW 251
119875: PPUSH
119876: LD_VAR 0 14
119880: PUSH
119881: LD_INT 1
119883: ARRAY
119884: PPUSH
119885: CALL_OW 254
119889: PPUSH
119890: LD_VAR 0 14
119894: PUSH
119895: LD_INT 1
119897: ARRAY
119898: PPUSH
119899: CALL_OW 248
119903: PPUSH
119904: LD_INT 0
119906: PPUSH
119907: CALL 34519 0 6
119911: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
119912: LD_ADDR_VAR 0 8
119916: PUSH
119917: LD_VAR 0 4
119921: PUSH
119922: LD_VAR 0 7
119926: ARRAY
119927: PPUSH
119928: LD_VAR 0 9
119932: PPUSH
119933: CALL 53274 0 2
119937: ST_TO_ADDR
// if j then
119938: LD_VAR 0 8
119942: IFFALSE 120011
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
119944: LD_VAR 0 8
119948: PUSH
119949: LD_INT 1
119951: ARRAY
119952: PPUSH
119953: LD_VAR 0 8
119957: PUSH
119958: LD_INT 2
119960: ARRAY
119961: PPUSH
119962: CALL_OW 488
119966: IFFALSE 120011
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
119968: LD_VAR 0 4
119972: PUSH
119973: LD_VAR 0 7
119977: ARRAY
119978: PPUSH
119979: LD_VAR 0 8
119983: PUSH
119984: LD_INT 1
119986: ARRAY
119987: PPUSH
119988: LD_VAR 0 8
119992: PUSH
119993: LD_INT 2
119995: ARRAY
119996: PPUSH
119997: CALL_OW 116
// attacking := true ;
120001: LD_ADDR_VAR 0 29
120005: PUSH
120006: LD_INT 1
120008: ST_TO_ADDR
// continue ;
120009: GO 117348
// end ; end else
120011: GO 120037
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120013: LD_VAR 0 4
120017: PUSH
120018: LD_VAR 0 7
120022: ARRAY
120023: PPUSH
120024: LD_VAR 0 14
120028: PUSH
120029: LD_INT 1
120031: ARRAY
120032: PPUSH
120033: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
120037: LD_VAR 0 4
120041: PUSH
120042: LD_VAR 0 7
120046: ARRAY
120047: PPUSH
120048: CALL_OW 265
120052: PUSH
120053: LD_INT 11
120055: EQUAL
120056: IFFALSE 120334
// begin k := 10 ;
120058: LD_ADDR_VAR 0 9
120062: PUSH
120063: LD_INT 10
120065: ST_TO_ADDR
// x := 0 ;
120066: LD_ADDR_VAR 0 10
120070: PUSH
120071: LD_INT 0
120073: ST_TO_ADDR
// if tmp < k then
120074: LD_VAR 0 14
120078: PUSH
120079: LD_VAR 0 9
120083: LESS
120084: IFFALSE 120096
// k := tmp ;
120086: LD_ADDR_VAR 0 9
120090: PUSH
120091: LD_VAR 0 14
120095: ST_TO_ADDR
// for j = k downto 1 do
120096: LD_ADDR_VAR 0 8
120100: PUSH
120101: DOUBLE
120102: LD_VAR 0 9
120106: INC
120107: ST_TO_ADDR
120108: LD_INT 1
120110: PUSH
120111: FOR_DOWNTO
120112: IFFALSE 120187
// begin if GetType ( tmp [ j ] ) = unit_human then
120114: LD_VAR 0 14
120118: PUSH
120119: LD_VAR 0 8
120123: ARRAY
120124: PPUSH
120125: CALL_OW 247
120129: PUSH
120130: LD_INT 1
120132: EQUAL
120133: IFFALSE 120185
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
120135: LD_VAR 0 4
120139: PUSH
120140: LD_VAR 0 7
120144: ARRAY
120145: PPUSH
120146: LD_VAR 0 14
120150: PUSH
120151: LD_VAR 0 8
120155: ARRAY
120156: PPUSH
120157: CALL 53532 0 2
// x := tmp [ j ] ;
120161: LD_ADDR_VAR 0 10
120165: PUSH
120166: LD_VAR 0 14
120170: PUSH
120171: LD_VAR 0 8
120175: ARRAY
120176: ST_TO_ADDR
// attacking := true ;
120177: LD_ADDR_VAR 0 29
120181: PUSH
120182: LD_INT 1
120184: ST_TO_ADDR
// end ; end ;
120185: GO 120111
120187: POP
120188: POP
// if not x then
120189: LD_VAR 0 10
120193: NOT
120194: IFFALSE 120334
// begin attacking := true ;
120196: LD_ADDR_VAR 0 29
120200: PUSH
120201: LD_INT 1
120203: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
120204: LD_VAR 0 4
120208: PUSH
120209: LD_VAR 0 7
120213: ARRAY
120214: PPUSH
120215: CALL_OW 250
120219: PPUSH
120220: LD_VAR 0 4
120224: PUSH
120225: LD_VAR 0 7
120229: ARRAY
120230: PPUSH
120231: CALL_OW 251
120235: PPUSH
120236: CALL_OW 546
120240: PUSH
120241: LD_INT 2
120243: ARRAY
120244: PUSH
120245: LD_VAR 0 14
120249: PUSH
120250: LD_INT 1
120252: ARRAY
120253: PPUSH
120254: CALL_OW 250
120258: PPUSH
120259: LD_VAR 0 14
120263: PUSH
120264: LD_INT 1
120266: ARRAY
120267: PPUSH
120268: CALL_OW 251
120272: PPUSH
120273: CALL_OW 546
120277: PUSH
120278: LD_INT 2
120280: ARRAY
120281: EQUAL
120282: IFFALSE 120310
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
120284: LD_VAR 0 4
120288: PUSH
120289: LD_VAR 0 7
120293: ARRAY
120294: PPUSH
120295: LD_VAR 0 14
120299: PUSH
120300: LD_INT 1
120302: ARRAY
120303: PPUSH
120304: CALL 53532 0 2
120308: GO 120334
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120310: LD_VAR 0 4
120314: PUSH
120315: LD_VAR 0 7
120319: ARRAY
120320: PPUSH
120321: LD_VAR 0 14
120325: PUSH
120326: LD_INT 1
120328: ARRAY
120329: PPUSH
120330: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
120334: LD_VAR 0 4
120338: PUSH
120339: LD_VAR 0 7
120343: ARRAY
120344: PPUSH
120345: CALL_OW 264
120349: PUSH
120350: LD_INT 29
120352: EQUAL
120353: IFFALSE 120723
// begin if WantsToAttack ( group [ i ] ) in bombed then
120355: LD_VAR 0 4
120359: PUSH
120360: LD_VAR 0 7
120364: ARRAY
120365: PPUSH
120366: CALL_OW 319
120370: PUSH
120371: LD_VAR 0 28
120375: IN
120376: IFFALSE 120380
// continue ;
120378: GO 117348
// k := 8 ;
120380: LD_ADDR_VAR 0 9
120384: PUSH
120385: LD_INT 8
120387: ST_TO_ADDR
// x := 0 ;
120388: LD_ADDR_VAR 0 10
120392: PUSH
120393: LD_INT 0
120395: ST_TO_ADDR
// if tmp < k then
120396: LD_VAR 0 14
120400: PUSH
120401: LD_VAR 0 9
120405: LESS
120406: IFFALSE 120418
// k := tmp ;
120408: LD_ADDR_VAR 0 9
120412: PUSH
120413: LD_VAR 0 14
120417: ST_TO_ADDR
// for j = 1 to k do
120418: LD_ADDR_VAR 0 8
120422: PUSH
120423: DOUBLE
120424: LD_INT 1
120426: DEC
120427: ST_TO_ADDR
120428: LD_VAR 0 9
120432: PUSH
120433: FOR_TO
120434: IFFALSE 120568
// begin if GetType ( tmp [ j ] ) = unit_building then
120436: LD_VAR 0 14
120440: PUSH
120441: LD_VAR 0 8
120445: ARRAY
120446: PPUSH
120447: CALL_OW 247
120451: PUSH
120452: LD_INT 3
120454: EQUAL
120455: IFFALSE 120566
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
120457: LD_VAR 0 14
120461: PUSH
120462: LD_VAR 0 8
120466: ARRAY
120467: PUSH
120468: LD_VAR 0 28
120472: IN
120473: NOT
120474: IFFALSE 120493
120476: PUSH
120477: LD_VAR 0 14
120481: PUSH
120482: LD_VAR 0 8
120486: ARRAY
120487: PPUSH
120488: CALL_OW 313
120492: AND
120493: IFFALSE 120566
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120495: LD_VAR 0 4
120499: PUSH
120500: LD_VAR 0 7
120504: ARRAY
120505: PPUSH
120506: LD_VAR 0 14
120510: PUSH
120511: LD_VAR 0 8
120515: ARRAY
120516: PPUSH
120517: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
120521: LD_ADDR_VAR 0 28
120525: PUSH
120526: LD_VAR 0 28
120530: PPUSH
120531: LD_VAR 0 28
120535: PUSH
120536: LD_INT 1
120538: PLUS
120539: PPUSH
120540: LD_VAR 0 14
120544: PUSH
120545: LD_VAR 0 8
120549: ARRAY
120550: PPUSH
120551: CALL_OW 1
120555: ST_TO_ADDR
// attacking := true ;
120556: LD_ADDR_VAR 0 29
120560: PUSH
120561: LD_INT 1
120563: ST_TO_ADDR
// break ;
120564: GO 120568
// end ; end ;
120566: GO 120433
120568: POP
120569: POP
// if not attacking and f_attack_depot then
120570: LD_VAR 0 29
120574: NOT
120575: IFFALSE 120583
120577: PUSH
120578: LD_VAR 0 25
120582: AND
120583: IFFALSE 120678
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120585: LD_ADDR_VAR 0 13
120589: PUSH
120590: LD_VAR 0 14
120594: PPUSH
120595: LD_INT 2
120597: PUSH
120598: LD_INT 30
120600: PUSH
120601: LD_INT 0
120603: PUSH
120604: EMPTY
120605: LIST
120606: LIST
120607: PUSH
120608: LD_INT 30
120610: PUSH
120611: LD_INT 1
120613: PUSH
120614: EMPTY
120615: LIST
120616: LIST
120617: PUSH
120618: EMPTY
120619: LIST
120620: LIST
120621: LIST
120622: PPUSH
120623: CALL_OW 72
120627: ST_TO_ADDR
// if z then
120628: LD_VAR 0 13
120632: IFFALSE 120678
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
120634: LD_VAR 0 4
120638: PUSH
120639: LD_VAR 0 7
120643: ARRAY
120644: PPUSH
120645: LD_VAR 0 13
120649: PPUSH
120650: LD_VAR 0 4
120654: PUSH
120655: LD_VAR 0 7
120659: ARRAY
120660: PPUSH
120661: CALL_OW 74
120665: PPUSH
120666: CALL_OW 115
// attacking := true ;
120670: LD_ADDR_VAR 0 29
120674: PUSH
120675: LD_INT 1
120677: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
120678: LD_VAR 0 4
120682: PUSH
120683: LD_VAR 0 7
120687: ARRAY
120688: PPUSH
120689: CALL_OW 256
120693: PUSH
120694: LD_INT 500
120696: LESS
120697: IFFALSE 120723
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120699: LD_VAR 0 4
120703: PUSH
120704: LD_VAR 0 7
120708: ARRAY
120709: PPUSH
120710: LD_VAR 0 14
120714: PUSH
120715: LD_INT 1
120717: ARRAY
120718: PPUSH
120719: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
120723: LD_VAR 0 4
120727: PUSH
120728: LD_VAR 0 7
120732: ARRAY
120733: PPUSH
120734: CALL_OW 264
120738: PUSH
120739: LD_INT 49
120741: EQUAL
120742: IFFALSE 120863
// begin if not HasTask ( group [ i ] ) then
120744: LD_VAR 0 4
120748: PUSH
120749: LD_VAR 0 7
120753: ARRAY
120754: PPUSH
120755: CALL_OW 314
120759: NOT
120760: IFFALSE 120863
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
120762: LD_ADDR_VAR 0 9
120766: PUSH
120767: LD_INT 81
120769: PUSH
120770: LD_VAR 0 4
120774: PUSH
120775: LD_VAR 0 7
120779: ARRAY
120780: PPUSH
120781: CALL_OW 255
120785: PUSH
120786: EMPTY
120787: LIST
120788: LIST
120789: PPUSH
120790: CALL_OW 69
120794: PPUSH
120795: LD_VAR 0 4
120799: PUSH
120800: LD_VAR 0 7
120804: ARRAY
120805: PPUSH
120806: CALL_OW 74
120810: ST_TO_ADDR
// if k then
120811: LD_VAR 0 9
120815: IFFALSE 120863
// if GetDistUnits ( group [ i ] , k ) > 10 then
120817: LD_VAR 0 4
120821: PUSH
120822: LD_VAR 0 7
120826: ARRAY
120827: PPUSH
120828: LD_VAR 0 9
120832: PPUSH
120833: CALL_OW 296
120837: PUSH
120838: LD_INT 10
120840: GREATER
120841: IFFALSE 120863
// ComMoveUnit ( group [ i ] , k ) ;
120843: LD_VAR 0 4
120847: PUSH
120848: LD_VAR 0 7
120852: ARRAY
120853: PPUSH
120854: LD_VAR 0 9
120858: PPUSH
120859: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
120863: LD_VAR 0 4
120867: PUSH
120868: LD_VAR 0 7
120872: ARRAY
120873: PPUSH
120874: CALL_OW 256
120878: PUSH
120879: LD_INT 250
120881: LESS
120882: IFFALSE 120926
120884: PUSH
120885: LD_VAR 0 4
120889: PUSH
120890: LD_VAR 0 7
120894: ARRAY
120895: PUSH
120896: LD_INT 21
120898: PUSH
120899: LD_INT 2
120901: PUSH
120902: EMPTY
120903: LIST
120904: LIST
120905: PUSH
120906: LD_INT 23
120908: PUSH
120909: LD_INT 2
120911: PUSH
120912: EMPTY
120913: LIST
120914: LIST
120915: PUSH
120916: EMPTY
120917: LIST
120918: LIST
120919: PPUSH
120920: CALL_OW 69
120924: IN
120925: AND
120926: IFFALSE 121053
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
120928: LD_ADDR_VAR 0 9
120932: PUSH
120933: LD_OWVAR 3
120937: PUSH
120938: LD_VAR 0 4
120942: PUSH
120943: LD_VAR 0 7
120947: ARRAY
120948: DIFF
120949: PPUSH
120950: LD_VAR 0 4
120954: PUSH
120955: LD_VAR 0 7
120959: ARRAY
120960: PPUSH
120961: CALL_OW 74
120965: ST_TO_ADDR
// if not k then
120966: LD_VAR 0 9
120970: NOT
120971: IFFALSE 120975
// continue ;
120973: GO 117348
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
120975: LD_VAR 0 9
120979: PUSH
120980: LD_INT 81
120982: PUSH
120983: LD_VAR 0 4
120987: PUSH
120988: LD_VAR 0 7
120992: ARRAY
120993: PPUSH
120994: CALL_OW 255
120998: PUSH
120999: EMPTY
121000: LIST
121001: LIST
121002: PPUSH
121003: CALL_OW 69
121007: IN
121008: IFFALSE 121036
121010: PUSH
121011: LD_VAR 0 9
121015: PPUSH
121016: LD_VAR 0 4
121020: PUSH
121021: LD_VAR 0 7
121025: ARRAY
121026: PPUSH
121027: CALL_OW 296
121031: PUSH
121032: LD_INT 5
121034: LESS
121035: AND
121036: IFFALSE 121053
// ComAutodestruct ( group [ i ] ) ;
121038: LD_VAR 0 4
121042: PUSH
121043: LD_VAR 0 7
121047: ARRAY
121048: PPUSH
121049: CALL 53428 0 1
// end ; if f_attack_depot then
121053: LD_VAR 0 25
121057: IFFALSE 121169
// begin k := 6 ;
121059: LD_ADDR_VAR 0 9
121063: PUSH
121064: LD_INT 6
121066: ST_TO_ADDR
// if tmp < k then
121067: LD_VAR 0 14
121071: PUSH
121072: LD_VAR 0 9
121076: LESS
121077: IFFALSE 121089
// k := tmp ;
121079: LD_ADDR_VAR 0 9
121083: PUSH
121084: LD_VAR 0 14
121088: ST_TO_ADDR
// for j = 1 to k do
121089: LD_ADDR_VAR 0 8
121093: PUSH
121094: DOUBLE
121095: LD_INT 1
121097: DEC
121098: ST_TO_ADDR
121099: LD_VAR 0 9
121103: PUSH
121104: FOR_TO
121105: IFFALSE 121167
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
121107: LD_VAR 0 8
121111: PPUSH
121112: CALL_OW 266
121116: PUSH
121117: LD_INT 0
121119: PUSH
121120: LD_INT 1
121122: PUSH
121123: EMPTY
121124: LIST
121125: LIST
121126: IN
121127: IFFALSE 121165
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
121129: LD_VAR 0 4
121133: PUSH
121134: LD_VAR 0 7
121138: ARRAY
121139: PPUSH
121140: LD_VAR 0 14
121144: PUSH
121145: LD_VAR 0 8
121149: ARRAY
121150: PPUSH
121151: CALL_OW 115
// attacking := true ;
121155: LD_ADDR_VAR 0 29
121159: PUSH
121160: LD_INT 1
121162: ST_TO_ADDR
// break ;
121163: GO 121167
// end ;
121165: GO 121104
121167: POP
121168: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
121169: LD_VAR 0 4
121173: PUSH
121174: LD_VAR 0 7
121178: ARRAY
121179: PPUSH
121180: CALL_OW 302
121184: IFFALSE 121193
121186: PUSH
121187: LD_VAR 0 29
121191: NOT
121192: AND
121193: IFFALSE 121523
// begin if GetTag ( group [ i ] ) = 71 then
121195: LD_VAR 0 4
121199: PUSH
121200: LD_VAR 0 7
121204: ARRAY
121205: PPUSH
121206: CALL_OW 110
121210: PUSH
121211: LD_INT 71
121213: EQUAL
121214: IFFALSE 121255
// begin if HasTask ( group [ i ] ) then
121216: LD_VAR 0 4
121220: PUSH
121221: LD_VAR 0 7
121225: ARRAY
121226: PPUSH
121227: CALL_OW 314
121231: IFFALSE 121237
// continue else
121233: GO 117348
121235: GO 121255
// SetTag ( group [ i ] , 0 ) ;
121237: LD_VAR 0 4
121241: PUSH
121242: LD_VAR 0 7
121246: ARRAY
121247: PPUSH
121248: LD_INT 0
121250: PPUSH
121251: CALL_OW 109
// end ; k := 8 ;
121255: LD_ADDR_VAR 0 9
121259: PUSH
121260: LD_INT 8
121262: ST_TO_ADDR
// x := 0 ;
121263: LD_ADDR_VAR 0 10
121267: PUSH
121268: LD_INT 0
121270: ST_TO_ADDR
// if tmp < k then
121271: LD_VAR 0 14
121275: PUSH
121276: LD_VAR 0 9
121280: LESS
121281: IFFALSE 121293
// k := tmp ;
121283: LD_ADDR_VAR 0 9
121287: PUSH
121288: LD_VAR 0 14
121292: ST_TO_ADDR
// for j = 1 to k do
121293: LD_ADDR_VAR 0 8
121297: PUSH
121298: DOUBLE
121299: LD_INT 1
121301: DEC
121302: ST_TO_ADDR
121303: LD_VAR 0 9
121307: PUSH
121308: FOR_TO
121309: IFFALSE 121415
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
121311: LD_VAR 0 14
121315: PUSH
121316: LD_VAR 0 8
121320: ARRAY
121321: PPUSH
121322: CALL_OW 247
121326: PUSH
121327: LD_INT 1
121329: EQUAL
121330: IFFALSE 121393
121332: PUSH
121333: LD_VAR 0 14
121337: PUSH
121338: LD_VAR 0 8
121342: ARRAY
121343: PPUSH
121344: CALL_OW 256
121348: PUSH
121349: LD_INT 250
121351: LESS
121352: IFFALSE 121360
121354: PUSH
121355: LD_VAR 0 20
121359: AND
121360: IFTRUE 121392
121362: PUSH
121363: LD_VAR 0 20
121367: NOT
121368: IFFALSE 121391
121370: PUSH
121371: LD_VAR 0 14
121375: PUSH
121376: LD_VAR 0 8
121380: ARRAY
121381: PPUSH
121382: CALL_OW 256
121386: PUSH
121387: LD_INT 250
121389: GREATEREQUAL
121390: AND
121391: OR
121392: AND
121393: IFFALSE 121413
// begin x := tmp [ j ] ;
121395: LD_ADDR_VAR 0 10
121399: PUSH
121400: LD_VAR 0 14
121404: PUSH
121405: LD_VAR 0 8
121409: ARRAY
121410: ST_TO_ADDR
// break ;
121411: GO 121415
// end ;
121413: GO 121308
121415: POP
121416: POP
// if x then
121417: LD_VAR 0 10
121421: IFFALSE 121445
// ComAttackUnit ( group [ i ] , x ) else
121423: LD_VAR 0 4
121427: PUSH
121428: LD_VAR 0 7
121432: ARRAY
121433: PPUSH
121434: LD_VAR 0 10
121438: PPUSH
121439: CALL_OW 115
121443: GO 121469
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121445: LD_VAR 0 4
121449: PUSH
121450: LD_VAR 0 7
121454: ARRAY
121455: PPUSH
121456: LD_VAR 0 14
121460: PUSH
121461: LD_INT 1
121463: ARRAY
121464: PPUSH
121465: CALL_OW 115
// if not HasTask ( group [ i ] ) then
121469: LD_VAR 0 4
121473: PUSH
121474: LD_VAR 0 7
121478: ARRAY
121479: PPUSH
121480: CALL_OW 314
121484: NOT
121485: IFFALSE 121523
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
121487: LD_VAR 0 4
121491: PUSH
121492: LD_VAR 0 7
121496: ARRAY
121497: PPUSH
121498: LD_VAR 0 14
121502: PPUSH
121503: LD_VAR 0 4
121507: PUSH
121508: LD_VAR 0 7
121512: ARRAY
121513: PPUSH
121514: CALL_OW 74
121518: PPUSH
121519: CALL_OW 115
// end ; end ; end ;
121523: GO 117348
121525: POP
121526: POP
// wait ( 0 0$2 ) ;
121527: LD_INT 70
121529: PPUSH
121530: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
121534: LD_VAR 0 4
121538: NOT
121539: IFTRUE 121550
121541: PUSH
121542: LD_VAR 0 4
121546: PUSH
121547: EMPTY
121548: EQUAL
121549: OR
121550: IFTRUE 121571
121552: PUSH
121553: LD_INT 81
121555: PUSH
121556: LD_VAR 0 35
121560: PUSH
121561: EMPTY
121562: LIST
121563: LIST
121564: PPUSH
121565: CALL_OW 69
121569: NOT
121570: OR
121571: IFFALSE 117333
// end ;
121573: LD_VAR 0 2
121577: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
121578: LD_INT 0
121580: PPUSH
121581: PPUSH
121582: PPUSH
121583: PPUSH
121584: PPUSH
121585: PPUSH
// if not base or not mc_bases [ base ] or not solds then
121586: LD_VAR 0 1
121590: NOT
121591: IFTRUE 121606
121593: PUSH
121594: LD_EXP 31
121598: PUSH
121599: LD_VAR 0 1
121603: ARRAY
121604: NOT
121605: OR
121606: IFTRUE 121615
121608: PUSH
121609: LD_VAR 0 2
121613: NOT
121614: OR
121615: IFFALSE 121619
// exit ;
121617: GO 122177
// side := mc_sides [ base ] ;
121619: LD_ADDR_VAR 0 6
121623: PUSH
121624: LD_EXP 57
121628: PUSH
121629: LD_VAR 0 1
121633: ARRAY
121634: ST_TO_ADDR
// if not side then
121635: LD_VAR 0 6
121639: NOT
121640: IFFALSE 121644
// exit ;
121642: GO 122177
// for i in solds do
121644: LD_ADDR_VAR 0 7
121648: PUSH
121649: LD_VAR 0 2
121653: PUSH
121654: FOR_IN
121655: IFFALSE 121716
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
121657: LD_VAR 0 7
121661: PPUSH
121662: CALL_OW 310
121666: PPUSH
121667: CALL_OW 266
121671: PUSH
121672: LD_INT 32
121674: PUSH
121675: LD_INT 31
121677: PUSH
121678: EMPTY
121679: LIST
121680: LIST
121681: IN
121682: IFFALSE 121702
// solds := solds diff i else
121684: LD_ADDR_VAR 0 2
121688: PUSH
121689: LD_VAR 0 2
121693: PUSH
121694: LD_VAR 0 7
121698: DIFF
121699: ST_TO_ADDR
121700: GO 121714
// SetTag ( i , 18 ) ;
121702: LD_VAR 0 7
121706: PPUSH
121707: LD_INT 18
121709: PPUSH
121710: CALL_OW 109
121714: GO 121654
121716: POP
121717: POP
// if not solds then
121718: LD_VAR 0 2
121722: NOT
121723: IFFALSE 121727
// exit ;
121725: GO 122177
// repeat wait ( 0 0$2 ) ;
121727: LD_INT 70
121729: PPUSH
121730: CALL_OW 67
// enemy := mc_scan [ base ] ;
121734: LD_ADDR_VAR 0 4
121738: PUSH
121739: LD_EXP 54
121743: PUSH
121744: LD_VAR 0 1
121748: ARRAY
121749: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121750: LD_EXP 31
121754: PUSH
121755: LD_VAR 0 1
121759: ARRAY
121760: NOT
121761: IFTRUE 121778
121763: PUSH
121764: LD_EXP 31
121768: PUSH
121769: LD_VAR 0 1
121773: ARRAY
121774: PUSH
121775: EMPTY
121776: EQUAL
121777: OR
121778: IFFALSE 121815
// begin for i in solds do
121780: LD_ADDR_VAR 0 7
121784: PUSH
121785: LD_VAR 0 2
121789: PUSH
121790: FOR_IN
121791: IFFALSE 121804
// ComStop ( i ) ;
121793: LD_VAR 0 7
121797: PPUSH
121798: CALL_OW 141
121802: GO 121790
121804: POP
121805: POP
// solds := [ ] ;
121806: LD_ADDR_VAR 0 2
121810: PUSH
121811: EMPTY
121812: ST_TO_ADDR
// exit ;
121813: GO 122177
// end ; for i in solds do
121815: LD_ADDR_VAR 0 7
121819: PUSH
121820: LD_VAR 0 2
121824: PUSH
121825: FOR_IN
121826: IFFALSE 122147
// begin if IsInUnit ( i ) then
121828: LD_VAR 0 7
121832: PPUSH
121833: CALL_OW 310
121837: IFFALSE 121848
// ComExitBuilding ( i ) ;
121839: LD_VAR 0 7
121843: PPUSH
121844: CALL_OW 122
// if GetLives ( i ) > 500 then
121848: LD_VAR 0 7
121852: PPUSH
121853: CALL_OW 256
121857: PUSH
121858: LD_INT 500
121860: GREATER
121861: IFFALSE 121914
// begin e := NearestUnitToUnit ( enemy , i ) ;
121863: LD_ADDR_VAR 0 5
121867: PUSH
121868: LD_VAR 0 4
121872: PPUSH
121873: LD_VAR 0 7
121877: PPUSH
121878: CALL_OW 74
121882: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
121883: LD_VAR 0 7
121887: PPUSH
121888: LD_VAR 0 5
121892: PPUSH
121893: CALL_OW 250
121897: PPUSH
121898: LD_VAR 0 5
121902: PPUSH
121903: CALL_OW 251
121907: PPUSH
121908: CALL_OW 114
// end else
121912: GO 122145
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
121914: LD_VAR 0 7
121918: PPUSH
121919: LD_EXP 31
121923: PUSH
121924: LD_VAR 0 1
121928: ARRAY
121929: PPUSH
121930: LD_INT 2
121932: PUSH
121933: LD_INT 30
121935: PUSH
121936: LD_INT 0
121938: PUSH
121939: EMPTY
121940: LIST
121941: LIST
121942: PUSH
121943: LD_INT 30
121945: PUSH
121946: LD_INT 1
121948: PUSH
121949: EMPTY
121950: LIST
121951: LIST
121952: PUSH
121953: LD_INT 30
121955: PUSH
121956: LD_INT 6
121958: PUSH
121959: EMPTY
121960: LIST
121961: LIST
121962: PUSH
121963: EMPTY
121964: LIST
121965: LIST
121966: LIST
121967: LIST
121968: PPUSH
121969: CALL_OW 72
121973: PPUSH
121974: LD_VAR 0 7
121978: PPUSH
121979: CALL_OW 74
121983: PPUSH
121984: CALL_OW 296
121988: PUSH
121989: LD_INT 10
121991: GREATER
121992: IFFALSE 122145
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
121994: LD_ADDR_VAR 0 8
121998: PUSH
121999: LD_EXP 31
122003: PUSH
122004: LD_VAR 0 1
122008: ARRAY
122009: PPUSH
122010: LD_INT 2
122012: PUSH
122013: LD_INT 30
122015: PUSH
122016: LD_INT 0
122018: PUSH
122019: EMPTY
122020: LIST
122021: LIST
122022: PUSH
122023: LD_INT 30
122025: PUSH
122026: LD_INT 1
122028: PUSH
122029: EMPTY
122030: LIST
122031: LIST
122032: PUSH
122033: LD_INT 30
122035: PUSH
122036: LD_INT 6
122038: PUSH
122039: EMPTY
122040: LIST
122041: LIST
122042: PUSH
122043: EMPTY
122044: LIST
122045: LIST
122046: LIST
122047: LIST
122048: PPUSH
122049: CALL_OW 72
122053: PPUSH
122054: LD_VAR 0 7
122058: PPUSH
122059: CALL_OW 74
122063: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
122064: LD_VAR 0 7
122068: PPUSH
122069: LD_VAR 0 8
122073: PPUSH
122074: CALL_OW 250
122078: PPUSH
122079: LD_INT 3
122081: PPUSH
122082: LD_INT 5
122084: PPUSH
122085: CALL_OW 272
122089: PPUSH
122090: LD_VAR 0 8
122094: PPUSH
122095: CALL_OW 251
122099: PPUSH
122100: LD_INT 3
122102: PPUSH
122103: LD_INT 5
122105: PPUSH
122106: CALL_OW 273
122110: PPUSH
122111: CALL_OW 111
// SetTag ( i , 0 ) ;
122115: LD_VAR 0 7
122119: PPUSH
122120: LD_INT 0
122122: PPUSH
122123: CALL_OW 109
// solds := solds diff i ;
122127: LD_ADDR_VAR 0 2
122131: PUSH
122132: LD_VAR 0 2
122136: PUSH
122137: LD_VAR 0 7
122141: DIFF
122142: ST_TO_ADDR
// continue ;
122143: GO 121825
// end ; end ;
122145: GO 121825
122147: POP
122148: POP
// until not solds or not enemy ;
122149: LD_VAR 0 2
122153: NOT
122154: IFTRUE 122163
122156: PUSH
122157: LD_VAR 0 4
122161: NOT
122162: OR
122163: IFFALSE 121727
// MC_Reset ( base , 18 ) ;
122165: LD_VAR 0 1
122169: PPUSH
122170: LD_INT 18
122172: PPUSH
122173: CALL 67634 0 2
// end ;
122177: LD_VAR 0 3
122181: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
122182: LD_INT 0
122184: PPUSH
122185: PPUSH
122186: PPUSH
122187: PPUSH
122188: PPUSH
122189: PPUSH
122190: PPUSH
122191: PPUSH
122192: PPUSH
122193: PPUSH
122194: PPUSH
122195: PPUSH
122196: PPUSH
122197: PPUSH
122198: PPUSH
122199: PPUSH
122200: PPUSH
122201: PPUSH
122202: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
122203: LD_ADDR_VAR 0 12
122207: PUSH
122208: LD_EXP 31
122212: PUSH
122213: LD_VAR 0 1
122217: ARRAY
122218: PPUSH
122219: LD_INT 25
122221: PUSH
122222: LD_INT 3
122224: PUSH
122225: EMPTY
122226: LIST
122227: LIST
122228: PPUSH
122229: CALL_OW 72
122233: ST_TO_ADDR
// if mc_remote_driver [ base ] then
122234: LD_EXP 71
122238: PUSH
122239: LD_VAR 0 1
122243: ARRAY
122244: IFFALSE 122268
// mechs := mechs diff mc_remote_driver [ base ] ;
122246: LD_ADDR_VAR 0 12
122250: PUSH
122251: LD_VAR 0 12
122255: PUSH
122256: LD_EXP 71
122260: PUSH
122261: LD_VAR 0 1
122265: ARRAY
122266: DIFF
122267: ST_TO_ADDR
// for i in mechs do
122268: LD_ADDR_VAR 0 4
122272: PUSH
122273: LD_VAR 0 12
122277: PUSH
122278: FOR_IN
122279: IFFALSE 122314
// if GetTag ( i ) > 0 then
122281: LD_VAR 0 4
122285: PPUSH
122286: CALL_OW 110
122290: PUSH
122291: LD_INT 0
122293: GREATER
122294: IFFALSE 122312
// mechs := mechs diff i ;
122296: LD_ADDR_VAR 0 12
122300: PUSH
122301: LD_VAR 0 12
122305: PUSH
122306: LD_VAR 0 4
122310: DIFF
122311: ST_TO_ADDR
122312: GO 122278
122314: POP
122315: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
122316: LD_ADDR_VAR 0 8
122320: PUSH
122321: LD_EXP 31
122325: PUSH
122326: LD_VAR 0 1
122330: ARRAY
122331: PPUSH
122332: LD_INT 2
122334: PUSH
122335: LD_INT 25
122337: PUSH
122338: LD_INT 1
122340: PUSH
122341: EMPTY
122342: LIST
122343: LIST
122344: PUSH
122345: LD_INT 25
122347: PUSH
122348: LD_INT 5
122350: PUSH
122351: EMPTY
122352: LIST
122353: LIST
122354: PUSH
122355: LD_INT 25
122357: PUSH
122358: LD_INT 8
122360: PUSH
122361: EMPTY
122362: LIST
122363: LIST
122364: PUSH
122365: LD_INT 25
122367: PUSH
122368: LD_INT 9
122370: PUSH
122371: EMPTY
122372: LIST
122373: LIST
122374: PUSH
122375: EMPTY
122376: LIST
122377: LIST
122378: LIST
122379: LIST
122380: LIST
122381: PPUSH
122382: CALL_OW 72
122386: ST_TO_ADDR
// if not defenders and not solds then
122387: LD_VAR 0 2
122391: NOT
122392: IFFALSE 122401
122394: PUSH
122395: LD_VAR 0 8
122399: NOT
122400: AND
122401: IFFALSE 122405
// exit ;
122403: GO 124227
// depot_under_attack := false ;
122405: LD_ADDR_VAR 0 16
122409: PUSH
122410: LD_INT 0
122412: ST_TO_ADDR
// sold_defenders := [ ] ;
122413: LD_ADDR_VAR 0 17
122417: PUSH
122418: EMPTY
122419: ST_TO_ADDR
// if mechs then
122420: LD_VAR 0 12
122424: IFFALSE 122579
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
122426: LD_ADDR_VAR 0 4
122430: PUSH
122431: LD_VAR 0 2
122435: PPUSH
122436: LD_INT 21
122438: PUSH
122439: LD_INT 2
122441: PUSH
122442: EMPTY
122443: LIST
122444: LIST
122445: PPUSH
122446: CALL_OW 72
122450: PUSH
122451: FOR_IN
122452: IFFALSE 122577
// begin if GetTag ( i ) <> 20 then
122454: LD_VAR 0 4
122458: PPUSH
122459: CALL_OW 110
122463: PUSH
122464: LD_INT 20
122466: NONEQUAL
122467: IFFALSE 122481
// SetTag ( i , 20 ) ;
122469: LD_VAR 0 4
122473: PPUSH
122474: LD_INT 20
122476: PPUSH
122477: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
122481: LD_VAR 0 4
122485: PPUSH
122486: CALL_OW 263
122490: PUSH
122491: LD_INT 1
122493: EQUAL
122494: IFFALSE 122508
122496: PUSH
122497: LD_VAR 0 4
122501: PPUSH
122502: CALL_OW 311
122506: NOT
122507: AND
122508: IFFALSE 122575
// begin un := mechs [ 1 ] ;
122510: LD_ADDR_VAR 0 10
122514: PUSH
122515: LD_VAR 0 12
122519: PUSH
122520: LD_INT 1
122522: ARRAY
122523: ST_TO_ADDR
// ComExit ( un ) ;
122524: LD_VAR 0 10
122528: PPUSH
122529: CALL 58509 0 1
// AddComEnterUnit ( un , i ) ;
122533: LD_VAR 0 10
122537: PPUSH
122538: LD_VAR 0 4
122542: PPUSH
122543: CALL_OW 180
// SetTag ( un , 19 ) ;
122547: LD_VAR 0 10
122551: PPUSH
122552: LD_INT 19
122554: PPUSH
122555: CALL_OW 109
// mechs := mechs diff un ;
122559: LD_ADDR_VAR 0 12
122563: PUSH
122564: LD_VAR 0 12
122568: PUSH
122569: LD_VAR 0 10
122573: DIFF
122574: ST_TO_ADDR
// end ; end ;
122575: GO 122451
122577: POP
122578: POP
// if solds then
122579: LD_VAR 0 8
122583: IFFALSE 122642
// for i in solds do
122585: LD_ADDR_VAR 0 4
122589: PUSH
122590: LD_VAR 0 8
122594: PUSH
122595: FOR_IN
122596: IFFALSE 122640
// if not GetTag ( i ) then
122598: LD_VAR 0 4
122602: PPUSH
122603: CALL_OW 110
122607: NOT
122608: IFFALSE 122638
// begin defenders := defenders union i ;
122610: LD_ADDR_VAR 0 2
122614: PUSH
122615: LD_VAR 0 2
122619: PUSH
122620: LD_VAR 0 4
122624: UNION
122625: ST_TO_ADDR
// SetTag ( i , 18 ) ;
122626: LD_VAR 0 4
122630: PPUSH
122631: LD_INT 18
122633: PPUSH
122634: CALL_OW 109
// end ;
122638: GO 122595
122640: POP
122641: POP
// repeat wait ( 0 0$2 ) ;
122642: LD_INT 70
122644: PPUSH
122645: CALL_OW 67
// enemy := mc_scan [ base ] ;
122649: LD_ADDR_VAR 0 21
122653: PUSH
122654: LD_EXP 54
122658: PUSH
122659: LD_VAR 0 1
122663: ARRAY
122664: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122665: LD_EXP 31
122669: PUSH
122670: LD_VAR 0 1
122674: ARRAY
122675: NOT
122676: IFTRUE 122693
122678: PUSH
122679: LD_EXP 31
122683: PUSH
122684: LD_VAR 0 1
122688: ARRAY
122689: PUSH
122690: EMPTY
122691: EQUAL
122692: OR
122693: IFFALSE 122730
// begin for i in defenders do
122695: LD_ADDR_VAR 0 4
122699: PUSH
122700: LD_VAR 0 2
122704: PUSH
122705: FOR_IN
122706: IFFALSE 122719
// ComStop ( i ) ;
122708: LD_VAR 0 4
122712: PPUSH
122713: CALL_OW 141
122717: GO 122705
122719: POP
122720: POP
// defenders := [ ] ;
122721: LD_ADDR_VAR 0 2
122725: PUSH
122726: EMPTY
122727: ST_TO_ADDR
// exit ;
122728: GO 124227
// end ; for i in defenders do
122730: LD_ADDR_VAR 0 4
122734: PUSH
122735: LD_VAR 0 2
122739: PUSH
122740: FOR_IN
122741: IFFALSE 123675
// begin e := NearestUnitToUnit ( enemy , i ) ;
122743: LD_ADDR_VAR 0 13
122747: PUSH
122748: LD_VAR 0 21
122752: PPUSH
122753: LD_VAR 0 4
122757: PPUSH
122758: CALL_OW 74
122762: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
122763: LD_ADDR_VAR 0 7
122767: PUSH
122768: LD_EXP 31
122772: PUSH
122773: LD_VAR 0 1
122777: ARRAY
122778: PPUSH
122779: LD_INT 2
122781: PUSH
122782: LD_INT 30
122784: PUSH
122785: LD_INT 0
122787: PUSH
122788: EMPTY
122789: LIST
122790: LIST
122791: PUSH
122792: LD_INT 30
122794: PUSH
122795: LD_INT 1
122797: PUSH
122798: EMPTY
122799: LIST
122800: LIST
122801: PUSH
122802: EMPTY
122803: LIST
122804: LIST
122805: LIST
122806: PPUSH
122807: CALL_OW 72
122811: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
122812: LD_ADDR_VAR 0 16
122816: PUSH
122817: LD_VAR 0 7
122821: NOT
122822: IFTRUE 122852
122824: PUSH
122825: LD_VAR 0 7
122829: PPUSH
122830: LD_INT 3
122832: PUSH
122833: LD_INT 24
122835: PUSH
122836: LD_INT 600
122838: PUSH
122839: EMPTY
122840: LIST
122841: LIST
122842: PUSH
122843: EMPTY
122844: LIST
122845: LIST
122846: PPUSH
122847: CALL_OW 72
122851: OR
122852: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
122853: LD_VAR 0 4
122857: PPUSH
122858: CALL_OW 247
122862: PUSH
122863: LD_INT 2
122865: DOUBLE
122866: EQUAL
122867: IFTRUE 122871
122869: GO 123287
122871: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
122872: LD_VAR 0 4
122876: PPUSH
122877: CALL_OW 256
122881: PUSH
122882: LD_INT 1000
122884: EQUAL
122885: IFFALSE 122931
122887: PUSH
122888: LD_VAR 0 4
122892: PPUSH
122893: LD_VAR 0 13
122897: PPUSH
122898: CALL_OW 296
122902: PUSH
122903: LD_INT 40
122905: LESS
122906: IFTRUE 122930
122908: PUSH
122909: LD_VAR 0 13
122913: PPUSH
122914: LD_EXP 56
122918: PUSH
122919: LD_VAR 0 1
122923: ARRAY
122924: PPUSH
122925: CALL_OW 308
122929: OR
122930: AND
122931: IFFALSE 123057
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
122933: LD_VAR 0 4
122937: PPUSH
122938: CALL_OW 262
122942: PUSH
122943: LD_INT 1
122945: EQUAL
122946: IFFALSE 122963
122948: PUSH
122949: LD_VAR 0 4
122953: PPUSH
122954: CALL_OW 261
122958: PUSH
122959: LD_INT 30
122961: LESS
122962: AND
122963: IFFALSE 122971
122965: PUSH
122966: LD_VAR 0 7
122970: AND
122971: IFFALSE 123041
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
122973: LD_VAR 0 4
122977: PPUSH
122978: LD_VAR 0 7
122982: PPUSH
122983: LD_VAR 0 4
122987: PPUSH
122988: CALL_OW 74
122992: PPUSH
122993: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
122997: LD_VAR 0 4
123001: PPUSH
123002: LD_VAR 0 7
123006: PPUSH
123007: LD_VAR 0 4
123011: PPUSH
123012: CALL_OW 74
123016: PPUSH
123017: CALL_OW 296
123021: PUSH
123022: LD_INT 6
123024: LESS
123025: IFFALSE 123039
// SetFuel ( i , 100 ) ;
123027: LD_VAR 0 4
123031: PPUSH
123032: LD_INT 100
123034: PPUSH
123035: CALL_OW 240
// end else
123039: GO 123055
// ComAttackUnit ( i , e ) ;
123041: LD_VAR 0 4
123045: PPUSH
123046: LD_VAR 0 13
123050: PPUSH
123051: CALL_OW 115
// end else
123055: GO 123164
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
123057: LD_VAR 0 13
123061: PPUSH
123062: LD_EXP 56
123066: PUSH
123067: LD_VAR 0 1
123071: ARRAY
123072: PPUSH
123073: CALL_OW 308
123077: NOT
123078: IFFALSE 123100
123080: PUSH
123081: LD_VAR 0 4
123085: PPUSH
123086: LD_VAR 0 13
123090: PPUSH
123091: CALL_OW 296
123095: PUSH
123096: LD_INT 40
123098: GREATEREQUAL
123099: AND
123100: IFTRUE 123117
123102: PUSH
123103: LD_VAR 0 4
123107: PPUSH
123108: CALL_OW 256
123112: PUSH
123113: LD_INT 650
123115: LESSEQUAL
123116: OR
123117: IFFALSE 123142
123119: PUSH
123120: LD_VAR 0 4
123124: PPUSH
123125: LD_EXP 55
123129: PUSH
123130: LD_VAR 0 1
123134: ARRAY
123135: PPUSH
123136: CALL_OW 308
123140: NOT
123141: AND
123142: IFFALSE 123164
// ComMoveToArea ( i , mc_parking [ base ] ) ;
123144: LD_VAR 0 4
123148: PPUSH
123149: LD_EXP 55
123153: PUSH
123154: LD_VAR 0 1
123158: ARRAY
123159: PPUSH
123160: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
123164: LD_VAR 0 4
123168: PPUSH
123169: CALL_OW 256
123173: PUSH
123174: LD_INT 1000
123176: LESS
123177: IFFALSE 123194
123179: PUSH
123180: LD_VAR 0 4
123184: PPUSH
123185: CALL_OW 263
123189: PUSH
123190: LD_INT 1
123192: EQUAL
123193: AND
123194: IFFALSE 123207
123196: PUSH
123197: LD_VAR 0 4
123201: PPUSH
123202: CALL_OW 311
123206: AND
123207: IFFALSE 123231
123209: PUSH
123210: LD_VAR 0 4
123214: PPUSH
123215: LD_EXP 55
123219: PUSH
123220: LD_VAR 0 1
123224: ARRAY
123225: PPUSH
123226: CALL_OW 308
123230: AND
123231: IFFALSE 123285
// begin mech := IsDrivenBy ( i ) ;
123233: LD_ADDR_VAR 0 9
123237: PUSH
123238: LD_VAR 0 4
123242: PPUSH
123243: CALL_OW 311
123247: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
123248: LD_VAR 0 9
123252: PPUSH
123253: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
123257: LD_VAR 0 9
123261: PPUSH
123262: LD_VAR 0 4
123266: PPUSH
123267: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
123271: LD_VAR 0 9
123275: PPUSH
123276: LD_VAR 0 4
123280: PPUSH
123281: CALL_OW 180
// end ; end ; unit_human :
123285: GO 123646
123287: LD_INT 1
123289: DOUBLE
123290: EQUAL
123291: IFTRUE 123295
123293: GO 123645
123295: POP
// begin b := IsInUnit ( i ) ;
123296: LD_ADDR_VAR 0 18
123300: PUSH
123301: LD_VAR 0 4
123305: PPUSH
123306: CALL_OW 310
123310: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
123311: LD_ADDR_VAR 0 19
123315: PUSH
123316: LD_VAR 0 18
123320: NOT
123321: IFTRUE 123345
123323: PUSH
123324: LD_VAR 0 18
123328: PPUSH
123329: CALL_OW 266
123333: PUSH
123334: LD_INT 32
123336: PUSH
123337: LD_INT 31
123339: PUSH
123340: EMPTY
123341: LIST
123342: LIST
123343: IN
123344: OR
123345: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
123346: LD_VAR 0 18
123350: PPUSH
123351: CALL_OW 266
123355: PUSH
123356: LD_INT 5
123358: EQUAL
123359: IFFALSE 123391
123361: PUSH
123362: LD_VAR 0 4
123366: PPUSH
123367: CALL_OW 257
123371: PUSH
123372: LD_INT 1
123374: PUSH
123375: LD_INT 2
123377: PUSH
123378: LD_INT 3
123380: PUSH
123381: LD_INT 4
123383: PUSH
123384: EMPTY
123385: LIST
123386: LIST
123387: LIST
123388: LIST
123389: IN
123390: AND
123391: IFFALSE 123428
// begin class := AllowSpecClass ( i ) ;
123393: LD_ADDR_VAR 0 20
123397: PUSH
123398: LD_VAR 0 4
123402: PPUSH
123403: CALL 21863 0 1
123407: ST_TO_ADDR
// if class then
123408: LD_VAR 0 20
123412: IFFALSE 123428
// ComChangeProfession ( i , class ) ;
123414: LD_VAR 0 4
123418: PPUSH
123419: LD_VAR 0 20
123423: PPUSH
123424: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
123428: LD_VAR 0 16
123432: IFTRUE 123459
123434: PUSH
123435: LD_VAR 0 2
123439: PPUSH
123440: LD_INT 21
123442: PUSH
123443: LD_INT 2
123445: PUSH
123446: EMPTY
123447: LIST
123448: LIST
123449: PPUSH
123450: CALL_OW 72
123454: PUSH
123455: LD_INT 1
123457: LESSEQUAL
123458: OR
123459: IFFALSE 123467
123461: PUSH
123462: LD_VAR 0 19
123466: AND
123467: IFFALSE 123482
123469: PUSH
123470: LD_VAR 0 4
123474: PUSH
123475: LD_VAR 0 17
123479: IN
123480: NOT
123481: AND
123482: IFFALSE 123577
// begin if b then
123484: LD_VAR 0 18
123488: IFFALSE 123539
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
123490: LD_VAR 0 18
123494: PPUSH
123495: LD_VAR 0 21
123499: PPUSH
123500: LD_VAR 0 18
123504: PPUSH
123505: CALL_OW 74
123509: PPUSH
123510: CALL_OW 296
123514: PUSH
123515: LD_INT 10
123517: LESS
123518: IFFALSE 123535
123520: PUSH
123521: LD_VAR 0 18
123525: PPUSH
123526: CALL_OW 461
123530: PUSH
123531: LD_INT 7
123533: NONEQUAL
123534: AND
123535: IFFALSE 123539
// continue ;
123537: GO 122740
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
123539: LD_ADDR_VAR 0 17
123543: PUSH
123544: LD_VAR 0 17
123548: PPUSH
123549: LD_VAR 0 17
123553: PUSH
123554: LD_INT 1
123556: PLUS
123557: PPUSH
123558: LD_VAR 0 4
123562: PPUSH
123563: CALL_OW 1
123567: ST_TO_ADDR
// ComExitBuilding ( i ) ;
123568: LD_VAR 0 4
123572: PPUSH
123573: CALL_OW 122
// end ; if sold_defenders then
123577: LD_VAR 0 17
123581: IFFALSE 123643
// if i in sold_defenders then
123583: LD_VAR 0 4
123587: PUSH
123588: LD_VAR 0 17
123592: IN
123593: IFFALSE 123643
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
123595: LD_VAR 0 4
123599: PPUSH
123600: CALL_OW 314
123604: NOT
123605: IFFALSE 123627
123607: PUSH
123608: LD_VAR 0 4
123612: PPUSH
123613: LD_VAR 0 13
123617: PPUSH
123618: CALL_OW 296
123622: PUSH
123623: LD_INT 30
123625: LESS
123626: AND
123627: IFFALSE 123643
// ComAttackUnit ( i , e ) ;
123629: LD_VAR 0 4
123633: PPUSH
123634: LD_VAR 0 13
123638: PPUSH
123639: CALL_OW 115
// end ; end ; end ;
123643: GO 123646
123645: POP
// if IsDead ( i ) then
123646: LD_VAR 0 4
123650: PPUSH
123651: CALL_OW 301
123655: IFFALSE 123673
// defenders := defenders diff i ;
123657: LD_ADDR_VAR 0 2
123661: PUSH
123662: LD_VAR 0 2
123666: PUSH
123667: LD_VAR 0 4
123671: DIFF
123672: ST_TO_ADDR
// end ;
123673: GO 122740
123675: POP
123676: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
123677: LD_VAR 0 21
123681: NOT
123682: IFTRUE 123691
123684: PUSH
123685: LD_VAR 0 2
123689: NOT
123690: OR
123691: IFTRUE 123706
123693: PUSH
123694: LD_EXP 31
123698: PUSH
123699: LD_VAR 0 1
123703: ARRAY
123704: NOT
123705: OR
123706: IFFALSE 122642
// MC_Reset ( base , 18 ) ;
123708: LD_VAR 0 1
123712: PPUSH
123713: LD_INT 18
123715: PPUSH
123716: CALL 67634 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
123720: LD_ADDR_VAR 0 2
123724: PUSH
123725: LD_VAR 0 2
123729: PUSH
123730: LD_VAR 0 2
123734: PPUSH
123735: LD_INT 2
123737: PUSH
123738: LD_INT 25
123740: PUSH
123741: LD_INT 1
123743: PUSH
123744: EMPTY
123745: LIST
123746: LIST
123747: PUSH
123748: LD_INT 25
123750: PUSH
123751: LD_INT 5
123753: PUSH
123754: EMPTY
123755: LIST
123756: LIST
123757: PUSH
123758: LD_INT 25
123760: PUSH
123761: LD_INT 8
123763: PUSH
123764: EMPTY
123765: LIST
123766: LIST
123767: PUSH
123768: LD_INT 25
123770: PUSH
123771: LD_INT 9
123773: PUSH
123774: EMPTY
123775: LIST
123776: LIST
123777: PUSH
123778: EMPTY
123779: LIST
123780: LIST
123781: LIST
123782: LIST
123783: LIST
123784: PPUSH
123785: CALL_OW 72
123789: DIFF
123790: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
123791: LD_VAR 0 21
123795: NOT
123796: IFFALSE 123819
123798: PUSH
123799: LD_VAR 0 2
123803: PPUSH
123804: LD_INT 21
123806: PUSH
123807: LD_INT 2
123809: PUSH
123810: EMPTY
123811: LIST
123812: LIST
123813: PPUSH
123814: CALL_OW 72
123818: AND
123819: IFFALSE 124163
// begin tmp := FilterByTag ( defenders , 19 ) ;
123821: LD_ADDR_VAR 0 11
123825: PUSH
123826: LD_VAR 0 2
123830: PPUSH
123831: LD_INT 19
123833: PPUSH
123834: CALL 55656 0 2
123838: ST_TO_ADDR
// if tmp then
123839: LD_VAR 0 11
123843: IFFALSE 123913
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
123845: LD_ADDR_VAR 0 11
123849: PUSH
123850: LD_VAR 0 11
123854: PPUSH
123855: LD_INT 25
123857: PUSH
123858: LD_INT 3
123860: PUSH
123861: EMPTY
123862: LIST
123863: LIST
123864: PPUSH
123865: CALL_OW 72
123869: ST_TO_ADDR
// if tmp then
123870: LD_VAR 0 11
123874: IFFALSE 123913
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
123876: LD_ADDR_EXP 43
123880: PUSH
123881: LD_EXP 43
123885: PPUSH
123886: LD_VAR 0 1
123890: PPUSH
123891: LD_EXP 43
123895: PUSH
123896: LD_VAR 0 1
123900: ARRAY
123901: PUSH
123902: LD_VAR 0 11
123906: UNION
123907: PPUSH
123908: CALL_OW 1
123912: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
123913: LD_VAR 0 1
123917: PPUSH
123918: LD_INT 19
123920: PPUSH
123921: CALL 67634 0 2
// repeat wait ( 0 0$1 ) ;
123925: LD_INT 35
123927: PPUSH
123928: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
123932: LD_EXP 31
123936: PUSH
123937: LD_VAR 0 1
123941: ARRAY
123942: NOT
123943: IFTRUE 123960
123945: PUSH
123946: LD_EXP 31
123950: PUSH
123951: LD_VAR 0 1
123955: ARRAY
123956: PUSH
123957: EMPTY
123958: EQUAL
123959: OR
123960: IFFALSE 123997
// begin for i in defenders do
123962: LD_ADDR_VAR 0 4
123966: PUSH
123967: LD_VAR 0 2
123971: PUSH
123972: FOR_IN
123973: IFFALSE 123986
// ComStop ( i ) ;
123975: LD_VAR 0 4
123979: PPUSH
123980: CALL_OW 141
123984: GO 123972
123986: POP
123987: POP
// defenders := [ ] ;
123988: LD_ADDR_VAR 0 2
123992: PUSH
123993: EMPTY
123994: ST_TO_ADDR
// exit ;
123995: GO 124227
// end ; for i in defenders do
123997: LD_ADDR_VAR 0 4
124001: PUSH
124002: LD_VAR 0 2
124006: PUSH
124007: FOR_IN
124008: IFFALSE 124097
// begin if not IsInArea ( i , mc_parking [ base ] ) then
124010: LD_VAR 0 4
124014: PPUSH
124015: LD_EXP 55
124019: PUSH
124020: LD_VAR 0 1
124024: ARRAY
124025: PPUSH
124026: CALL_OW 308
124030: NOT
124031: IFFALSE 124055
// ComMoveToArea ( i , mc_parking [ base ] ) else
124033: LD_VAR 0 4
124037: PPUSH
124038: LD_EXP 55
124042: PUSH
124043: LD_VAR 0 1
124047: ARRAY
124048: PPUSH
124049: CALL_OW 113
124053: GO 124095
// if GetControl ( i ) = control_manual then
124055: LD_VAR 0 4
124059: PPUSH
124060: CALL_OW 263
124064: PUSH
124065: LD_INT 1
124067: EQUAL
124068: IFFALSE 124095
// if IsDrivenBy ( i ) then
124070: LD_VAR 0 4
124074: PPUSH
124075: CALL_OW 311
124079: IFFALSE 124095
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
124081: LD_VAR 0 4
124085: PPUSH
124086: CALL_OW 311
124090: PPUSH
124091: CALL_OW 121
// end ;
124095: GO 124007
124097: POP
124098: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
124099: LD_VAR 0 2
124103: PPUSH
124104: LD_INT 95
124106: PUSH
124107: LD_EXP 55
124111: PUSH
124112: LD_VAR 0 1
124116: ARRAY
124117: PUSH
124118: EMPTY
124119: LIST
124120: LIST
124121: PPUSH
124122: CALL_OW 72
124126: PUSH
124127: LD_VAR 0 2
124131: EQUAL
124132: IFTRUE 124146
124134: PUSH
124135: LD_EXP 54
124139: PUSH
124140: LD_VAR 0 1
124144: ARRAY
124145: OR
124146: IFTRUE 124161
124148: PUSH
124149: LD_EXP 31
124153: PUSH
124154: LD_VAR 0 1
124158: ARRAY
124159: NOT
124160: OR
124161: IFFALSE 123925
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
124163: LD_ADDR_EXP 53
124167: PUSH
124168: LD_EXP 53
124172: PPUSH
124173: LD_VAR 0 1
124177: PPUSH
124178: LD_VAR 0 2
124182: PPUSH
124183: LD_INT 21
124185: PUSH
124186: LD_INT 2
124188: PUSH
124189: EMPTY
124190: LIST
124191: LIST
124192: PPUSH
124193: CALL_OW 72
124197: PPUSH
124198: CALL_OW 1
124202: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
124203: LD_VAR 0 1
124207: PPUSH
124208: LD_INT 19
124210: PPUSH
124211: CALL 67634 0 2
// MC_Reset ( base , 20 ) ;
124215: LD_VAR 0 1
124219: PPUSH
124220: LD_INT 20
124222: PPUSH
124223: CALL 67634 0 2
// end ; end_of_file
124227: LD_VAR 0 3
124231: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
124232: LD_VAR 0 1
124236: PUSH
124237: LD_INT 200
124239: DOUBLE
124240: GREATEREQUAL
124241: IFFALSE 124249
124243: LD_INT 299
124245: DOUBLE
124246: LESSEQUAL
124247: IFTRUE 124251
124249: GO 124283
124251: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
124252: LD_VAR 0 1
124256: PPUSH
124257: LD_VAR 0 2
124261: PPUSH
124262: LD_VAR 0 3
124266: PPUSH
124267: LD_VAR 0 4
124271: PPUSH
124272: LD_VAR 0 5
124276: PPUSH
124277: CALL 111275 0 5
124281: GO 124360
124283: LD_INT 300
124285: DOUBLE
124286: GREATEREQUAL
124287: IFFALSE 124295
124289: LD_INT 399
124291: DOUBLE
124292: LESSEQUAL
124293: IFTRUE 124297
124295: GO 124359
124297: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
124298: LD_VAR 0 1
124302: PPUSH
124303: LD_VAR 0 2
124307: PPUSH
124308: LD_VAR 0 3
124312: PPUSH
124313: LD_VAR 0 4
124317: PPUSH
124318: LD_VAR 0 5
124322: PPUSH
124323: LD_VAR 0 6
124327: PPUSH
124328: LD_VAR 0 7
124332: PPUSH
124333: LD_VAR 0 8
124337: PPUSH
124338: LD_VAR 0 9
124342: PPUSH
124343: LD_VAR 0 10
124347: PPUSH
124348: LD_VAR 0 11
124352: PPUSH
124353: CALL 107159 0 11
124357: GO 124360
124359: POP
// end ;
124360: PPOPN 11
124362: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
124363: LD_VAR 0 1
124367: PPUSH
124368: LD_VAR 0 2
124372: PPUSH
124373: LD_VAR 0 3
124377: PPUSH
124378: LD_VAR 0 4
124382: PPUSH
124383: LD_VAR 0 5
124387: PPUSH
124388: CALL 110656 0 5
// end ; end_of_file
124392: PPOPN 5
124394: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
124395: LD_VAR 0 1
124399: PPUSH
124400: LD_VAR 0 2
124404: PPUSH
124405: LD_VAR 0 3
124409: PPUSH
124410: LD_VAR 0 4
124414: PPUSH
124415: LD_VAR 0 5
124419: PPUSH
124420: LD_VAR 0 6
124424: PPUSH
124425: CALL 94699 0 6
// end ;
124429: PPOPN 6
124431: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
124432: LD_INT 0
124434: PPUSH
// begin if not units then
124435: LD_VAR 0 1
124439: NOT
124440: IFFALSE 124444
// exit ;
124442: GO 124478
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
124444: LD_VAR 0 1
124448: PPUSH
124449: LD_VAR 0 2
124453: PPUSH
124454: LD_VAR 0 3
124458: PPUSH
124459: LD_VAR 0 4
124463: PPUSH
124464: LD_VAR 0 5
124468: PPUSH
124469: LD_VAR 0 6
124473: PPUSH
124474: CALL 116782 0 6
// end ;
124478: PPOPN 7
124480: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
124481: CALL 94586 0 0
// end ;
124485: PPOPN 1
124487: END
