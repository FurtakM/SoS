// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 602 0 0
// SetDiplomacy ;
  42: CALL 814 0 0
// PrepareGame ;
  46: CALL 896 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := 0 ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 0 0$1 trigger game and GameType = 1 and not disableGlobalTimer do
 229: LD_EXP 3
 233: PUSH
 234: LD_EXP 2
 238: PUSH
 239: LD_INT 1
 241: EQUAL
 242: AND
 243: PUSH
 244: LD_EXP 4
 248: NOT
 249: AND
 250: IFFALSE 273
 252: GO 254
 254: DISABLE
// begin enable ;
 255: ENABLE
// display_strings := [ #SkrTime , tick ] ;
 256: LD_ADDR_OWVAR 47
 260: PUSH
 261: LD_STRING #SkrTime
 263: PUSH
 264: LD_OWVAR 1
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: ST_TO_ADDR
// end ;
 273: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 274: LD_EXP 19
 278: PUSH
 279: LD_EXP 3
 283: AND
 284: PUSH
 285: LD_EXP 2
 289: PUSH
 290: LD_INT 1
 292: EQUAL
 293: AND
 294: IFFALSE 355
 296: GO 298
 298: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 299: LD_EXP 19
 303: PUSH
 304: LD_INT 1
 306: ARRAY
 307: PUSH
 308: LD_INT 1
 310: ARRAY
 311: PPUSH
 312: LD_EXP 19
 316: PUSH
 317: LD_INT 1
 319: ARRAY
 320: PUSH
 321: LD_INT 2
 323: ARRAY
 324: PPUSH
 325: LD_EXP 19
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 3
 336: ARRAY
 337: PPUSH
 338: LD_EXP 19
 342: PUSH
 343: LD_INT 1
 345: ARRAY
 346: PUSH
 347: LD_INT 4
 349: ARRAY
 350: PPUSH
 351: CALL 56500 0 4
 355: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 356: LD_EXP 19
 360: PUSH
 361: LD_EXP 3
 365: AND
 366: PUSH
 367: LD_EXP 2
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: IFFALSE 437
 378: GO 380
 380: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 381: LD_EXP 19
 385: PUSH
 386: LD_INT 2
 388: ARRAY
 389: PUSH
 390: LD_INT 1
 392: ARRAY
 393: PPUSH
 394: LD_EXP 19
 398: PUSH
 399: LD_INT 2
 401: ARRAY
 402: PUSH
 403: LD_INT 2
 405: ARRAY
 406: PPUSH
 407: LD_EXP 19
 411: PUSH
 412: LD_INT 2
 414: ARRAY
 415: PUSH
 416: LD_INT 3
 418: ARRAY
 419: PPUSH
 420: LD_EXP 19
 424: PUSH
 425: LD_INT 2
 427: ARRAY
 428: PUSH
 429: LD_INT 4
 431: ARRAY
 432: PPUSH
 433: CALL 56500 0 4
 437: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 438: LD_EXP 19
 442: PUSH
 443: LD_EXP 3
 447: AND
 448: PUSH
 449: LD_EXP 2
 453: PUSH
 454: LD_INT 1
 456: EQUAL
 457: AND
 458: IFFALSE 519
 460: GO 462
 462: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 463: LD_EXP 19
 467: PUSH
 468: LD_INT 3
 470: ARRAY
 471: PUSH
 472: LD_INT 1
 474: ARRAY
 475: PPUSH
 476: LD_EXP 19
 480: PUSH
 481: LD_INT 3
 483: ARRAY
 484: PUSH
 485: LD_INT 2
 487: ARRAY
 488: PPUSH
 489: LD_EXP 19
 493: PUSH
 494: LD_INT 3
 496: ARRAY
 497: PUSH
 498: LD_INT 3
 500: ARRAY
 501: PPUSH
 502: LD_EXP 19
 506: PUSH
 507: LD_INT 3
 509: ARRAY
 510: PUSH
 511: LD_INT 4
 513: ARRAY
 514: PPUSH
 515: CALL 56500 0 4
 519: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 520: LD_EXP 19
 524: PUSH
 525: LD_EXP 3
 529: AND
 530: PUSH
 531: LD_EXP 2
 535: PUSH
 536: LD_INT 1
 538: EQUAL
 539: AND
 540: IFFALSE 601
 542: GO 544
 544: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 545: LD_EXP 19
 549: PUSH
 550: LD_INT 4
 552: ARRAY
 553: PUSH
 554: LD_INT 1
 556: ARRAY
 557: PPUSH
 558: LD_EXP 19
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PPUSH
 571: LD_EXP 19
 575: PUSH
 576: LD_INT 4
 578: ARRAY
 579: PUSH
 580: LD_INT 3
 582: ARRAY
 583: PPUSH
 584: LD_EXP 19
 588: PUSH
 589: LD_INT 4
 591: ARRAY
 592: PUSH
 593: LD_INT 4
 595: ARRAY
 596: PPUSH
 597: CALL 56500 0 4
 601: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 602: LD_INT 0
 604: PPUSH
 605: PPUSH
 606: PPUSH
 607: PPUSH
 608: PPUSH
// if GameType = 1 then
 609: LD_EXP 2
 613: PUSH
 614: LD_INT 1
 616: EQUAL
 617: IFFALSE 686
// begin ban_techs := [ ] ;
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// if sibBombAllowed < 2 then
 626: LD_EXP 23
 630: PUSH
 631: LD_INT 2
 633: LESS
 634: IFFALSE 647
// ban_techs := [ tech_sibFiss ] ;
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: LD_INT 25
 643: PUSH
 644: EMPTY
 645: LIST
 646: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_INT 46
 654: PUSH
 655: LD_INT 47
 657: PUSH
 658: LD_INT 48
 660: PUSH
 661: LD_INT 49
 663: PUSH
 664: LD_INT 50
 666: PUSH
 667: LD_INT 39
 669: PUSH
 670: LD_INT 69
 672: PUSH
 673: LD_INT 40
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: ST_TO_ADDR
// end ; for i = 1 to 8 do
 686: LD_ADDR_VAR 0 2
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_INT 8
 698: PUSH
 699: FOR_TO
 700: IFFALSE 784
// begin if res_techs then
 702: LD_VAR 0 5
 706: IFFALSE 742
// for j in res_techs do
 708: LD_ADDR_VAR 0 3
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: FOR_IN
 719: IFFALSE 740
// SetTech ( j , i , state_researched ) ;
 721: LD_VAR 0 3
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: LD_INT 2
 733: PPUSH
 734: CALL_OW 322
 738: GO 718
 740: POP
 741: POP
// if ban_techs then
 742: LD_VAR 0 4
 746: IFFALSE 782
// for j in ban_techs do
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_VAR 0 4
 757: PUSH
 758: FOR_IN
 759: IFFALSE 780
// SetTech ( j , i , state_disabled ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 322
 778: GO 758
 780: POP
 781: POP
// end ;
 782: GO 699
 784: POP
 785: POP
// if sibBombAllowed = 1 then
 786: LD_EXP 23
 790: PUSH
 791: LD_INT 1
 793: EQUAL
 794: IFFALSE 809
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 796: LD_INT 25
 798: PPUSH
 799: LD_INT 3
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 322
// end ;
 809: LD_VAR 0 1
 813: RET
// export function SetDiplomacy ; begin
 814: LD_INT 0
 816: PPUSH
// if GameType = 1 then
 817: LD_EXP 2
 821: PUSH
 822: LD_INT 1
 824: EQUAL
 825: IFFALSE 891
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 827: LD_INT 1
 829: PPUSH
 830: LD_INT 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 843: LD_INT 3
 845: PPUSH
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 8
 864: PPUSH
 865: LD_INT 1
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 875: LD_INT 6
 877: PPUSH
 878: LD_INT 8
 880: PPUSH
 881: LD_INT 1
 883: PPUSH
 884: LD_INT 1
 886: PPUSH
 887: CALL_OW 80
// end ; end ;
 891: LD_VAR 0 1
 895: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 896: LD_INT 0
 898: PPUSH
 899: PPUSH
 900: PPUSH
 901: PPUSH
// if GameType = 1 then
 902: LD_EXP 2
 906: PUSH
 907: LD_INT 1
 909: EQUAL
 910: IFFALSE 1406
// begin game := false ;
 912: LD_ADDR_EXP 3
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// your_side := 1 ;
 920: LD_ADDR_OWVAR 2
 924: PUSH
 925: LD_INT 1
 927: ST_TO_ADDR
// mc_amer := 1 ;
 928: LD_ADDR_EXP 5
 932: PUSH
 933: LD_INT 1
 935: ST_TO_ADDR
// mc_leg := 2 ;
 936: LD_ADDR_EXP 6
 940: PUSH
 941: LD_INT 2
 943: ST_TO_ADDR
// mc_rus_1 := 3 ;
 944: LD_ADDR_EXP 7
 948: PUSH
 949: LD_INT 3
 951: ST_TO_ADDR
// mc_rus_2 := 4 ;
 952: LD_ADDR_EXP 8
 956: PUSH
 957: LD_INT 4
 959: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 960: LD_ADDR_EXP 19
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: LD_INT 200
 976: PUSH
 977: LD_INT 250
 979: PUSH
 980: LD_INT 300
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_EXP 26
 992: ARRAY
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 13
1002: PUSH
1003: LD_INT 8
1005: PUSH
1006: LD_INT 50
1008: PUSH
1009: LD_INT 500
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 17
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 50
1026: PUSH
1027: LD_INT 300
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 18
1038: PUSH
1039: LD_INT 4
1041: PUSH
1042: LD_INT 5
1044: PUSH
1045: LD_INT 6
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_EXP 26
1057: ARRAY
1058: PUSH
1059: LD_INT 30
1061: PUSH
1062: LD_INT 300
1064: PUSH
1065: LD_INT 450
1067: PUSH
1068: LD_INT 500
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_EXP 26
1080: ARRAY
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: LD_INT 190
1101: PUSH
1102: LD_INT 193
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 182
1115: PUSH
1116: LD_INT 117
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 114
1143: PUSH
1144: LD_INT 152
1146: PUSH
1147: LD_INT 2
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 85
1157: PUSH
1158: LD_INT 38
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i in sources do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: PUSH
1186: FOR_IN
1187: IFFALSE 1222
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1189: LD_VAR 0 2
1193: PUSH
1194: LD_INT 1
1196: ARRAY
1197: PPUSH
1198: LD_VAR 0 2
1202: PUSH
1203: LD_INT 2
1205: ARRAY
1206: PPUSH
1207: LD_VAR 0 2
1211: PUSH
1212: LD_INT 3
1214: ARRAY
1215: PPUSH
1216: CALL_OW 62
1220: GO 1186
1222: POP
1223: POP
// disableGlobalTimer := false ;
1224: LD_ADDR_EXP 4
1228: PUSH
1229: LD_INT 0
1231: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1232: LD_ADDR_EXP 15
1236: PUSH
1237: LD_INT 0
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_OWVAR 67
1258: ARRAY
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: ST_TO_ADDR
// ruOutpost := [ ] ;
1264: LD_ADDR_EXP 14
1268: PUSH
1269: EMPTY
1270: ST_TO_ADDR
// staticMines := [ ] ;
1271: LD_ADDR_EXP 16
1275: PUSH
1276: EMPTY
1277: ST_TO_ADDR
// baseCaptured := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// legDestCounter := 0 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 0
1293: ST_TO_ADDR
// legOfferAccepted := false ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_INT 0
1301: ST_TO_ADDR
// legChangeSide := false ;
1302: LD_ADDR_EXP 21
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// allyDestCounter := 0 ;
1310: LD_ADDR_EXP 22
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// outpostEscape := false ;
1318: LD_ADDR_EXP 27
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// dialogueMineDetected := false ;
1326: LD_ADDR_EXP 28
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// PrepareAmericans ;
1334: CALL 7604 0 0
// PrepareLegion ;
1338: CALL 5538 0 0
// PrepareRussians ;
1342: CALL 2504 0 0
// playerForces := PreparePlayer ;
1346: LD_ADDR_EXP 10
1350: PUSH
1351: CALL 8847 0 0
1355: ST_TO_ADDR
// AnimateTrees ( true ) ;
1356: LD_INT 1
1358: PPUSH
1359: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1363: LD_INT 4
1365: PPUSH
1366: LD_INT 3
1368: PPUSH
1369: LD_INT 8
1371: PPUSH
1372: LD_INT 5
1374: PPUSH
1375: LD_INT 3
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 8
1383: PPUSH
1384: LD_INT 2
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: CALL 53866 0 9
// MC_Start ;
1394: CALL 63428 0 0
// SetAdditionalRussianForces ;
1398: CALL 7273 0 0
// Action ;
1402: CALL 11204 0 0
// end ; end ;
1406: LD_VAR 0 1
1410: RET
// export function CustomInitMacro ; begin
1411: LD_INT 0
1413: PPUSH
// if GameType <> 1 then
1414: LD_EXP 2
1418: PUSH
1419: LD_INT 1
1421: NONEQUAL
1422: IFFALSE 1426
// exit ;
1424: GO 2499
// MC_SetScanArea ( mc_amer , amerBase ) ;
1426: LD_EXP 5
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: CALL 86789 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1438: LD_EXP 5
1442: PPUSH
1443: LD_INT 4
1445: PPUSH
1446: CALL 86733 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1450: LD_EXP 5
1454: PPUSH
1455: LD_INT 11
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 7
1463: PUSH
1464: LD_INT 9
1466: PUSH
1467: LD_INT 10
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: PPUSH
1477: CALL 86621 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1481: LD_EXP 5
1485: PPUSH
1486: LD_INT 5
1488: PPUSH
1489: CALL 86303 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1493: LD_EXP 5
1497: PPUSH
1498: LD_INT 3
1500: PPUSH
1501: CALL 86034 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1505: LD_EXP 5
1509: PPUSH
1510: LD_INT 4
1512: PPUSH
1513: CALL 85653 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1517: LD_EXP 5
1521: PPUSH
1522: LD_INT 3
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 2
1530: PUSH
1531: LD_INT 5
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: LD_INT 9
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 4
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: LD_INT 2
1566: PUSH
1567: LD_INT 7
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: PUSH
1576: LD_INT 4
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: LD_INT 2
1584: PUSH
1585: LD_INT 6
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL 85468 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1604: LD_EXP 5
1608: PPUSH
1609: LD_INT 33
1611: PUSH
1612: LD_INT 114
1614: PUSH
1615: LD_INT 16
1617: PUSH
1618: LD_INT 0
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 110
1632: PUSH
1633: LD_INT 12
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL 85360 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1653: LD_EXP 5
1657: PPUSH
1658: LD_INT 10
1660: PUSH
1661: LD_INT 15
1663: PUSH
1664: LD_INT 12
1666: PUSH
1667: LD_INT 11
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL 86210 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1680: LD_EXP 6
1684: PPUSH
1685: LD_INT 6
1687: PPUSH
1688: CALL 86789 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1692: LD_EXP 6
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL 86733 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1704: LD_EXP 6
1708: PPUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 27
1714: PUSH
1715: LD_INT 28
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL 86621 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1731: LD_EXP 6
1735: PPUSH
1736: LD_INT 17
1738: PPUSH
1739: CALL 86303 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1743: LD_EXP 6
1747: PPUSH
1748: LD_INT 6
1750: PPUSH
1751: CALL 86034 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1755: LD_EXP 6
1759: PPUSH
1760: LD_INT 5
1762: PPUSH
1763: CALL 85653 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1767: LD_EXP 6
1771: PPUSH
1772: LD_INT 10
1774: PPUSH
1775: LD_INT 9
1777: PPUSH
1778: CALL 85131 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1782: LD_EXP 6
1786: PPUSH
1787: LD_INT 4
1789: PUSH
1790: LD_INT 157
1792: PUSH
1793: LD_INT 144
1795: PUSH
1796: LD_INT 0
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 32
1807: PUSH
1808: LD_INT 151
1810: PUSH
1811: LD_INT 142
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 32
1825: PUSH
1826: LD_INT 161
1828: PUSH
1829: LD_INT 144
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 32
1843: PUSH
1844: LD_INT 140
1846: PUSH
1847: LD_INT 133
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL 85360 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1869: LD_EXP 6
1873: PPUSH
1874: LD_INT 13
1876: PUSH
1877: LD_INT 2
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 31
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 13
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 31
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 13
1912: PUSH
1913: LD_INT 1
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 27
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: LD_INT 13
1930: PUSH
1931: LD_INT 1
1933: PUSH
1934: LD_INT 2
1936: PUSH
1937: LD_INT 27
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: PUSH
1946: LD_INT 13
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 27
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 13
1966: PUSH
1967: LD_INT 1
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 28
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 13
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 28
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 13
2002: PUSH
2003: LD_INT 1
2005: PUSH
2006: LD_INT 2
2008: PUSH
2009: LD_INT 32
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_INT 13
2020: PUSH
2021: LD_INT 1
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 88
2029: PUSH
2030: EMPTY
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 85468 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2051: LD_INT 165
2053: PPUSH
2054: LD_INT 156
2056: PPUSH
2057: LD_INT 8
2059: PPUSH
2060: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2064: LD_EXP 7
2068: PPUSH
2069: LD_INT 15
2071: PPUSH
2072: CALL 86789 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2076: LD_EXP 7
2080: PPUSH
2081: LD_INT 16
2083: PPUSH
2084: CALL 86733 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2088: LD_EXP 7
2092: PPUSH
2093: LD_INT 43
2095: PUSH
2096: LD_INT 47
2098: PUSH
2099: LD_INT 45
2101: PUSH
2102: LD_INT 49
2104: PUSH
2105: LD_INT 46
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PPUSH
2115: CALL 86621 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2119: LD_EXP 7
2123: PPUSH
2124: LD_INT 13
2126: PPUSH
2127: CALL 86303 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2131: LD_EXP 7
2135: PPUSH
2136: LD_INT 15
2138: PPUSH
2139: CALL 86034 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2143: LD_EXP 7
2147: PPUSH
2148: LD_INT 5
2150: PPUSH
2151: CALL 85653 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2155: LD_EXP 7
2159: PPUSH
2160: LD_INT 23
2162: PUSH
2163: LD_INT 1
2165: PUSH
2166: LD_INT 3
2168: PUSH
2169: LD_INT 46
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: PUSH
2178: LD_INT 23
2180: PUSH
2181: LD_INT 1
2183: PUSH
2184: LD_INT 1
2186: PUSH
2187: LD_INT 46
2189: PUSH
2190: EMPTY
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_INT 23
2198: PUSH
2199: LD_INT 1
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 45
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 23
2216: PUSH
2217: LD_INT 1
2219: PUSH
2220: LD_INT 1
2222: PUSH
2223: LD_INT 47
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 23
2234: PUSH
2235: LD_INT 1
2237: PUSH
2238: LD_INT 3
2240: PUSH
2241: LD_INT 46
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 21
2252: PUSH
2253: LD_INT 1
2255: PUSH
2256: LD_INT 3
2258: PUSH
2259: LD_INT 51
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: LD_INT 21
2270: PUSH
2271: LD_INT 1
2273: PUSH
2274: LD_INT 3
2276: PUSH
2277: LD_INT 52
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: LIST
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: PPUSH
2295: CALL 85468 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2299: LD_EXP 8
2303: PPUSH
2304: LD_INT 11
2306: PPUSH
2307: CALL 86789 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2311: LD_EXP 8
2315: PPUSH
2316: LD_INT 12
2318: PPUSH
2319: CALL 86733 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2323: LD_EXP 8
2327: PPUSH
2328: LD_INT 43
2330: PUSH
2331: LD_INT 47
2333: PUSH
2334: LD_INT 45
2336: PUSH
2337: LD_INT 49
2339: PUSH
2340: LD_INT 46
2342: PUSH
2343: EMPTY
2344: LIST
2345: LIST
2346: LIST
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL 86621 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2354: LD_EXP 8
2358: PPUSH
2359: LD_INT 13
2361: PPUSH
2362: CALL 86303 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2366: LD_EXP 8
2370: PPUSH
2371: LD_INT 11
2373: PPUSH
2374: CALL 86034 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2378: LD_EXP 8
2382: PPUSH
2383: LD_INT 4
2385: PPUSH
2386: CALL 85653 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2390: LD_EXP 8
2394: PPUSH
2395: LD_INT 115
2397: PUSH
2398: LD_INT 201
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: EMPTY
2406: LIST
2407: PPUSH
2408: CALL 86359 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2412: LD_EXP 8
2416: PPUSH
2417: LD_INT 24
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 3
2425: PUSH
2426: LD_INT 46
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_INT 24
2437: PUSH
2438: LD_INT 3
2440: PUSH
2441: LD_INT 3
2443: PUSH
2444: LD_INT 46
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 24
2455: PUSH
2456: LD_INT 3
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 46
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 24
2473: PUSH
2474: LD_INT 3
2476: PUSH
2477: LD_INT 3
2479: PUSH
2480: LD_INT 46
2482: PUSH
2483: EMPTY
2484: LIST
2485: LIST
2486: LIST
2487: LIST
2488: PUSH
2489: EMPTY
2490: LIST
2491: LIST
2492: LIST
2493: LIST
2494: PPUSH
2495: CALL 85468 0 2
// end ;
2499: LD_VAR 0 1
2503: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2504: LD_INT 0
2506: PPUSH
2507: PPUSH
2508: PPUSH
2509: PPUSH
2510: PPUSH
2511: PPUSH
2512: PPUSH
2513: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2514: LD_INT 0
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: LD_INT 0
2525: PPUSH
2526: LD_INT 0
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 0
2534: PPUSH
2535: LD_INT 14
2537: PPUSH
2538: LD_INT 0
2540: PPUSH
2541: CALL 53866 0 9
// side := 3 ;
2545: LD_ADDR_VAR 0 5
2549: PUSH
2550: LD_INT 3
2552: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2553: LD_INT 38
2555: PPUSH
2556: LD_VAR 0 5
2560: PPUSH
2561: LD_INT 2
2563: PPUSH
2564: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2568: LD_INT 39
2570: PPUSH
2571: LD_VAR 0 5
2575: PPUSH
2576: LD_INT 2
2578: PPUSH
2579: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2583: LD_INT 34
2585: PPUSH
2586: LD_VAR 0 5
2590: PPUSH
2591: LD_INT 2
2593: PPUSH
2594: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2598: LD_ADDR_VAR 0 4
2602: PUSH
2603: LD_INT 0
2605: PUSH
2606: LD_INT 208
2608: PUSH
2609: LD_INT 163
2611: PUSH
2612: LD_INT 4
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: LD_INT 0
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 3
2631: PUSH
2632: LD_INT 194
2634: PUSH
2635: LD_INT 161
2637: PUSH
2638: LD_INT 1
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: LD_INT 0
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: PUSH
2655: LD_INT 17
2657: PUSH
2658: LD_INT 190
2660: PUSH
2661: LD_INT 161
2663: PUSH
2664: LD_INT 1
2666: PUSH
2667: LD_INT 0
2669: PUSH
2670: LD_INT 0
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: LIST
2680: PUSH
2681: LD_INT 5
2683: PUSH
2684: LD_INT 200
2686: PUSH
2687: LD_INT 145
2689: PUSH
2690: LD_INT 3
2692: PUSH
2693: LD_INT 0
2695: PUSH
2696: LD_INT 0
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 32
2709: PUSH
2710: LD_INT 192
2712: PUSH
2713: LD_INT 144
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: LD_INT 0
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PUSH
2733: LD_INT 26
2735: PUSH
2736: LD_INT 216
2738: PUSH
2739: LD_INT 172
2741: PUSH
2742: LD_INT 3
2744: PUSH
2745: LD_INT 0
2747: PUSH
2748: LD_INT 0
2750: PUSH
2751: EMPTY
2752: LIST
2753: LIST
2754: LIST
2755: LIST
2756: LIST
2757: LIST
2758: PUSH
2759: LD_INT 26
2761: PUSH
2762: LD_INT 218
2764: PUSH
2765: LD_INT 176
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: LD_INT 0
2773: PUSH
2774: LD_INT 0
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 29
2787: PUSH
2788: LD_INT 182
2790: PUSH
2791: LD_INT 149
2793: PUSH
2794: LD_INT 3
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: LD_INT 0
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: LD_INT 201
2816: PUSH
2817: LD_INT 171
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: LD_INT 11
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 32
2839: PUSH
2840: LD_INT 188
2842: PUSH
2843: LD_INT 167
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: LD_INT 0
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: PUSH
2863: LD_INT 32
2865: PUSH
2866: LD_INT 202
2868: PUSH
2869: LD_INT 179
2871: PUSH
2872: LD_INT 0
2874: PUSH
2875: LD_INT 0
2877: PUSH
2878: LD_INT 0
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: PUSH
2889: LD_INT 32
2891: PUSH
2892: LD_INT 209
2894: PUSH
2895: LD_INT 182
2897: PUSH
2898: LD_INT 0
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: LD_INT 0
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: PUSH
2915: LD_INT 32
2917: PUSH
2918: LD_INT 220
2920: PUSH
2921: LD_INT 183
2923: PUSH
2924: LD_INT 5
2926: PUSH
2927: LD_INT 0
2929: PUSH
2930: LD_INT 0
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: PUSH
2941: LD_INT 32
2943: PUSH
2944: LD_INT 225
2946: PUSH
2947: LD_INT 181
2949: PUSH
2950: LD_INT 5
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 0
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: PUSH
2967: LD_INT 26
2969: PUSH
2970: LD_INT 220
2972: PUSH
2973: LD_INT 174
2975: PUSH
2976: LD_INT 5
2978: PUSH
2979: LD_INT 0
2981: PUSH
2982: LD_INT 0
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 84
2998: PUSH
2999: LD_INT 128
3001: PUSH
3002: LD_INT 4
3004: PUSH
3005: LD_INT 0
3007: PUSH
3008: LD_INT 0
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 3
3021: PUSH
3022: LD_INT 68
3024: PUSH
3025: LD_INT 121
3027: PUSH
3028: LD_INT 1
3030: PUSH
3031: LD_INT 0
3033: PUSH
3034: LD_INT 0
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 19
3047: PUSH
3048: LD_INT 72
3050: PUSH
3051: LD_INT 125
3053: PUSH
3054: LD_INT 5
3056: PUSH
3057: LD_INT 0
3059: PUSH
3060: LD_INT 0
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: PUSH
3071: LD_INT 18
3073: PUSH
3074: LD_INT 68
3076: PUSH
3077: LD_INT 124
3079: PUSH
3080: LD_INT 0
3082: PUSH
3083: LD_INT 0
3085: PUSH
3086: LD_INT 0
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_INT 24
3099: PUSH
3100: LD_INT 64
3102: PUSH
3103: LD_INT 121
3105: PUSH
3106: LD_INT 1
3108: PUSH
3109: LD_INT 0
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 17
3125: PUSH
3126: LD_INT 65
3128: PUSH
3129: LD_INT 118
3131: PUSH
3132: LD_INT 2
3134: PUSH
3135: LD_INT 0
3137: PUSH
3138: LD_INT 0
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 21
3151: PUSH
3152: LD_INT 68
3154: PUSH
3155: LD_INT 117
3157: PUSH
3158: LD_INT 3
3160: PUSH
3161: LD_INT 0
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: PUSH
3175: LD_INT 8
3177: PUSH
3178: LD_INT 68
3180: PUSH
3181: LD_INT 130
3183: PUSH
3184: LD_INT 1
3186: PUSH
3187: LD_INT 14
3189: PUSH
3190: LD_INT 10
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: PUSH
3201: LD_INT 8
3203: PUSH
3204: LD_INT 67
3206: PUSH
3207: LD_INT 110
3209: PUSH
3210: LD_INT 2
3212: PUSH
3213: LD_INT 11
3215: PUSH
3216: LD_INT 12
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 28
3229: PUSH
3230: LD_INT 85
3232: PUSH
3233: LD_INT 108
3235: PUSH
3236: LD_INT 2
3238: PUSH
3239: LD_INT 0
3241: PUSH
3242: LD_INT 0
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 28
3255: PUSH
3256: LD_INT 85
3258: PUSH
3259: LD_INT 124
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: LD_INT 0
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 30
3281: PUSH
3282: LD_INT 97
3284: PUSH
3285: LD_INT 119
3287: PUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 0
3293: PUSH
3294: LD_INT 0
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: PUSH
3305: LD_INT 5
3307: PUSH
3308: LD_INT 111
3310: PUSH
3311: LD_INT 138
3313: PUSH
3314: LD_INT 4
3316: PUSH
3317: LD_INT 0
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 33
3333: PUSH
3334: LD_INT 104
3336: PUSH
3337: LD_INT 130
3339: PUSH
3340: LD_INT 3
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 33
3359: PUSH
3360: LD_INT 110
3362: PUSH
3363: LD_INT 142
3365: PUSH
3366: LD_INT 5
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 33
3385: PUSH
3386: LD_INT 91
3388: PUSH
3389: LD_INT 131
3391: PUSH
3392: LD_INT 5
3394: PUSH
3395: LD_INT 0
3397: PUSH
3398: LD_INT 0
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 33
3411: PUSH
3412: LD_INT 107
3414: PUSH
3415: LD_INT 157
3417: PUSH
3418: LD_INT 5
3420: PUSH
3421: LD_INT 0
3423: PUSH
3424: LD_INT 0
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 33
3437: PUSH
3438: LD_INT 104
3440: PUSH
3441: LD_INT 160
3443: PUSH
3444: LD_INT 5
3446: PUSH
3447: LD_INT 0
3449: PUSH
3450: LD_INT 0
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 33
3463: PUSH
3464: LD_INT 101
3466: PUSH
3467: LD_INT 162
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 0
3475: PUSH
3476: LD_INT 0
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 32
3489: PUSH
3490: LD_INT 87
3492: PUSH
3493: LD_INT 157
3495: PUSH
3496: LD_INT 5
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: LD_INT 0
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 32
3515: PUSH
3516: LD_INT 105
3518: PUSH
3519: LD_INT 158
3521: PUSH
3522: LD_INT 5
3524: PUSH
3525: LD_INT 0
3527: PUSH
3528: LD_INT 0
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 33
3541: PUSH
3542: LD_INT 91
3544: PUSH
3545: LD_INT 118
3547: PUSH
3548: LD_INT 4
3550: PUSH
3551: LD_INT 0
3553: PUSH
3554: LD_INT 0
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 33
3567: PUSH
3568: LD_INT 89
3570: PUSH
3571: LD_INT 107
3573: PUSH
3574: LD_INT 4
3576: PUSH
3577: LD_INT 0
3579: PUSH
3580: LD_INT 0
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 86
3596: PUSH
3597: LD_INT 96
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: LD_INT 0
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 33
3619: PUSH
3620: LD_INT 91
3622: PUSH
3623: LD_INT 102
3625: PUSH
3626: LD_INT 4
3628: PUSH
3629: LD_INT 0
3631: PUSH
3632: LD_INT 0
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 32
3645: PUSH
3646: LD_INT 80
3648: PUSH
3649: LD_INT 95
3651: PUSH
3652: LD_INT 3
3654: PUSH
3655: LD_INT 0
3657: PUSH
3658: LD_INT 0
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 28
3671: PUSH
3672: LD_INT 77
3674: PUSH
3675: LD_INT 105
3677: PUSH
3678: LD_INT 3
3680: PUSH
3681: LD_INT 0
3683: PUSH
3684: LD_INT 0
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: LIST
3692: LIST
3693: LIST
3694: PUSH
3695: LD_INT 28
3697: PUSH
3698: LD_INT 85
3700: PUSH
3701: LD_INT 113
3703: PUSH
3704: LD_INT 3
3706: PUSH
3707: LD_INT 0
3709: PUSH
3710: LD_INT 0
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 28
3723: PUSH
3724: LD_INT 55
3726: PUSH
3727: LD_INT 97
3729: PUSH
3730: LD_INT 3
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 0
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 28
3749: PUSH
3750: LD_INT 88
3752: PUSH
3753: LD_INT 128
3755: PUSH
3756: LD_INT 3
3758: PUSH
3759: LD_INT 0
3761: PUSH
3762: LD_INT 0
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 32
3775: PUSH
3776: LD_INT 69
3778: PUSH
3779: LD_INT 101
3781: PUSH
3782: LD_INT 2
3784: PUSH
3785: LD_INT 0
3787: PUSH
3788: LD_INT 0
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: PUSH
3799: LD_INT 1
3801: PUSH
3802: LD_INT 34
3804: PUSH
3805: LD_INT 23
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: LD_INT 0
3813: PUSH
3814: LD_INT 0
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 25
3830: PUSH
3831: LD_INT 4
3833: PUSH
3834: LD_INT 3
3836: PUSH
3837: LD_INT 11
3839: PUSH
3840: LD_INT 10
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 8
3853: PUSH
3854: LD_INT 15
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: LD_INT 2
3862: PUSH
3863: LD_INT 14
3865: PUSH
3866: LD_INT 12
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 29
3879: PUSH
3880: LD_INT 55
3882: PUSH
3883: LD_INT 35
3885: PUSH
3886: LD_INT 2
3888: PUSH
3889: LD_INT 0
3891: PUSH
3892: LD_INT 0
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 29
3905: PUSH
3906: LD_INT 24
3908: PUSH
3909: LD_INT 44
3911: PUSH
3912: LD_INT 2
3914: PUSH
3915: LD_INT 0
3917: PUSH
3918: LD_INT 0
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: PUSH
3929: LD_INT 34
3931: PUSH
3932: LD_INT 34
3934: PUSH
3935: LD_INT 32
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: LD_INT 0
3943: PUSH
3944: LD_INT 0
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: PUSH
3955: LD_INT 3
3957: PUSH
3958: LD_INT 14
3960: PUSH
3961: LD_INT 16
3963: PUSH
3964: LD_INT 1
3966: PUSH
3967: LD_INT 0
3969: PUSH
3970: LD_INT 0
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: PUSH
3981: LD_INT 24
3983: PUSH
3984: LD_INT 10
3986: PUSH
3987: LD_INT 16
3989: PUSH
3990: LD_INT 1
3992: PUSH
3993: LD_INT 0
3995: PUSH
3996: LD_INT 0
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_INT 21
4009: PUSH
4010: LD_INT 11
4012: PUSH
4013: LD_INT 13
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: LD_INT 0
4021: PUSH
4022: LD_INT 0
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: PUSH
4033: LD_INT 18
4035: PUSH
4036: LD_INT 14
4038: PUSH
4039: LD_INT 12
4041: PUSH
4042: LD_INT 3
4044: PUSH
4045: LD_INT 0
4047: PUSH
4048: LD_INT 0
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: PUSH
4059: LD_INT 16
4061: PUSH
4062: LD_INT 14
4064: PUSH
4065: LD_INT 19
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: LD_INT 0
4073: PUSH
4074: LD_INT 0
4076: PUSH
4077: EMPTY
4078: LIST
4079: LIST
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 17
4087: PUSH
4088: LD_INT 18
4090: PUSH
4091: LD_INT 20
4093: PUSH
4094: LD_INT 5
4096: PUSH
4097: LD_INT 0
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: PUSH
4111: LD_INT 28
4113: PUSH
4114: LD_INT 10
4116: PUSH
4117: LD_INT 5
4119: PUSH
4120: LD_INT 1
4122: PUSH
4123: LD_INT 0
4125: PUSH
4126: LD_INT 0
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: PUSH
4137: LD_INT 28
4139: PUSH
4140: LD_INT 8
4142: PUSH
4143: LD_INT 8
4145: PUSH
4146: LD_INT 1
4148: PUSH
4149: LD_INT 0
4151: PUSH
4152: LD_INT 0
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: PUSH
4163: LD_INT 26
4165: PUSH
4166: LD_INT 19
4168: PUSH
4169: LD_INT 2
4171: PUSH
4172: LD_INT 1
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: LD_INT 0
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: PUSH
4189: LD_INT 26
4191: PUSH
4192: LD_INT 30
4194: PUSH
4195: LD_INT 2
4197: PUSH
4198: LD_INT 1
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: LD_INT 0
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 5
4217: PUSH
4218: LD_INT 59
4220: PUSH
4221: LD_INT 20
4223: PUSH
4224: LD_INT 4
4226: PUSH
4227: LD_INT 0
4229: PUSH
4230: LD_INT 0
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 32
4243: PUSH
4244: LD_INT 60
4246: PUSH
4247: LD_INT 24
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: LD_INT 0
4255: PUSH
4256: LD_INT 0
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 32
4269: PUSH
4270: LD_INT 61
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 5
4278: PUSH
4279: LD_INT 0
4281: PUSH
4282: LD_INT 0
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 32
4295: PUSH
4296: LD_INT 52
4298: PUSH
4299: LD_INT 51
4301: PUSH
4302: LD_INT 5
4304: PUSH
4305: LD_INT 0
4307: PUSH
4308: LD_INT 0
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: LD_INT 56
4324: PUSH
4325: LD_INT 51
4327: PUSH
4328: LD_INT 5
4330: PUSH
4331: LD_INT 0
4333: PUSH
4334: LD_INT 0
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 33
4347: PUSH
4348: LD_INT 62
4350: PUSH
4351: LD_INT 49
4353: PUSH
4354: LD_INT 5
4356: PUSH
4357: LD_INT 0
4359: PUSH
4360: LD_INT 0
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 33
4373: PUSH
4374: LD_INT 41
4376: PUSH
4377: LD_INT 47
4379: PUSH
4380: LD_INT 5
4382: PUSH
4383: LD_INT 0
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 33
4399: PUSH
4400: LD_INT 33
4402: PUSH
4403: LD_INT 52
4405: PUSH
4406: LD_INT 5
4408: PUSH
4409: LD_INT 0
4411: PUSH
4412: LD_INT 0
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: LD_INT 31
4428: PUSH
4429: LD_INT 40
4431: PUSH
4432: LD_INT 0
4434: PUSH
4435: LD_INT 0
4437: PUSH
4438: LD_INT 0
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: PUSH
4449: LD_INT 33
4451: PUSH
4452: LD_INT 65
4454: PUSH
4455: LD_INT 37
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: LD_INT 0
4463: PUSH
4464: LD_INT 0
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 33
4477: PUSH
4478: LD_INT 63
4480: PUSH
4481: LD_INT 29
4483: PUSH
4484: LD_INT 4
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: LD_INT 0
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: PUSH
4501: LD_INT 33
4503: PUSH
4504: LD_INT 54
4506: PUSH
4507: LD_INT 11
4509: PUSH
4510: LD_INT 4
4512: PUSH
4513: LD_INT 0
4515: PUSH
4516: LD_INT 0
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 33
4529: PUSH
4530: LD_INT 56
4532: PUSH
4533: LD_INT 15
4535: PUSH
4536: LD_INT 4
4538: PUSH
4539: LD_INT 0
4541: PUSH
4542: LD_INT 0
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 33
4555: PUSH
4556: LD_INT 51
4558: PUSH
4559: LD_INT 6
4561: PUSH
4562: LD_INT 4
4564: PUSH
4565: LD_INT 0
4567: PUSH
4568: LD_INT 0
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 26
4581: PUSH
4582: LD_INT 39
4584: PUSH
4585: LD_INT 25
4587: PUSH
4588: LD_INT 0
4590: PUSH
4591: LD_INT 0
4593: PUSH
4594: LD_INT 0
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: PUSH
4605: LD_INT 26
4607: PUSH
4608: LD_INT 37
4610: PUSH
4611: LD_INT 21
4613: PUSH
4614: LD_INT 0
4616: PUSH
4617: LD_INT 0
4619: PUSH
4620: LD_INT 0
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: PUSH
4631: LD_INT 32
4633: PUSH
4634: LD_INT 35
4636: PUSH
4637: LD_INT 17
4639: PUSH
4640: LD_INT 4
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 0
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 33
4659: PUSH
4660: LD_INT 35
4662: PUSH
4663: LD_INT 28
4665: PUSH
4666: LD_INT 4
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: LD_INT 0
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 28
4688: PUSH
4689: LD_INT 46
4691: PUSH
4692: LD_INT 5
4694: PUSH
4695: LD_INT 0
4697: PUSH
4698: LD_INT 0
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: PUSH
4709: LD_INT 33
4711: PUSH
4712: LD_INT 31
4714: PUSH
4715: LD_INT 6
4717: PUSH
4718: LD_INT 4
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: LD_INT 0
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 26
4737: PUSH
4738: LD_INT 54
4740: PUSH
4741: LD_INT 38
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 0
4749: PUSH
4750: LD_INT 0
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_INT 33
4763: PUSH
4764: LD_INT 207
4766: PUSH
4767: LD_INT 167
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: LD_INT 0
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 30
4789: PUSH
4790: LD_INT 43
4792: PUSH
4793: LD_INT 2
4795: PUSH
4796: LD_INT 4
4798: PUSH
4799: LD_INT 0
4801: PUSH
4802: LD_INT 0
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: ST_TO_ADDR
// for i in tmp do
4900: LD_ADDR_VAR 0 2
4904: PUSH
4905: LD_VAR 0 4
4909: PUSH
4910: FOR_IN
4911: IFFALSE 5142
// begin uc_side := side ;
4913: LD_ADDR_OWVAR 20
4917: PUSH
4918: LD_VAR 0 5
4922: ST_TO_ADDR
// uc_nation := nation_russian ;
4923: LD_ADDR_OWVAR 21
4927: PUSH
4928: LD_INT 3
4930: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4931: LD_ADDR_OWVAR 42
4935: PUSH
4936: LD_VAR 0 2
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4945: LD_ADDR_OWVAR 43
4949: PUSH
4950: LD_INT 5
4952: PPUSH
4953: LD_INT 6
4955: PPUSH
4956: CALL_OW 12
4960: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4961: LD_ADDR_OWVAR 44
4965: PUSH
4966: LD_VAR 0 2
4970: PUSH
4971: LD_INT 5
4973: ARRAY
4974: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4975: LD_ADDR_OWVAR 45
4979: PUSH
4980: LD_VAR 0 2
4984: PUSH
4985: LD_INT 6
4987: ARRAY
4988: ST_TO_ADDR
// sr := 0 ;
4989: LD_ADDR_VAR 0 6
4993: PUSH
4994: LD_INT 0
4996: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4997: LD_VAR 0 2
5001: PUSH
5002: LD_INT 1
5004: ARRAY
5005: PUSH
5006: LD_INT 29
5008: EQUAL
5009: IFFALSE 5021
// sr := mat_oil else
5011: LD_ADDR_VAR 0 6
5015: PUSH
5016: LD_INT 2
5018: ST_TO_ADDR
5019: GO 5043
// if i [ 1 ] = b_siberite_mine then
5021: LD_VAR 0 2
5025: PUSH
5026: LD_INT 1
5028: ARRAY
5029: PUSH
5030: LD_INT 30
5032: EQUAL
5033: IFFALSE 5043
// sr := mat_siberit ;
5035: LD_ADDR_VAR 0 6
5039: PUSH
5040: LD_INT 3
5042: ST_TO_ADDR
// if sr then
5043: LD_VAR 0 6
5047: IFFALSE 5103
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5049: LD_VAR 0 2
5053: PUSH
5054: LD_INT 2
5056: ARRAY
5057: PPUSH
5058: LD_VAR 0 2
5062: PUSH
5063: LD_INT 3
5065: ARRAY
5066: PPUSH
5067: LD_VAR 0 6
5071: PPUSH
5072: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5076: LD_VAR 0 2
5080: PUSH
5081: LD_INT 2
5083: ARRAY
5084: PPUSH
5085: LD_VAR 0 2
5089: PUSH
5090: LD_INT 3
5092: ARRAY
5093: PPUSH
5094: LD_VAR 0 5
5098: PPUSH
5099: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5103: LD_ADDR_VAR 0 3
5107: PUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_INT 2
5115: ARRAY
5116: PPUSH
5117: LD_VAR 0 2
5121: PUSH
5122: LD_INT 3
5124: ARRAY
5125: PPUSH
5126: LD_VAR 0 2
5130: PUSH
5131: LD_INT 4
5133: ARRAY
5134: PPUSH
5135: CALL_OW 47
5139: ST_TO_ADDR
// end ;
5140: GO 4910
5142: POP
5143: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5144: LD_ADDR_VAR 0 7
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_VAR 0 5
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PUSH
5161: LD_INT 30
5163: PUSH
5164: LD_INT 1
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PPUSH
5175: CALL_OW 69
5179: ST_TO_ADDR
// if not depot then
5180: LD_VAR 0 7
5184: NOT
5185: IFFALSE 5189
// exit ;
5187: GO 5533
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5189: LD_ADDR_VAR 0 8
5193: PUSH
5194: LD_INT 84
5196: PPUSH
5197: LD_INT 128
5199: PPUSH
5200: CALL_OW 428
5204: PPUSH
5205: LD_INT 15
5207: PPUSH
5208: LD_INT 0
5210: PPUSH
5211: LD_INT 6
5213: PUSH
5214: LD_INT 7
5216: PUSH
5217: LD_INT 8
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: LIST
5224: PUSH
5225: LD_OWVAR 67
5229: ARRAY
5230: PPUSH
5231: LD_INT 3000
5233: PUSH
5234: LD_INT 300
5236: PUSH
5237: LD_INT 100
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: LD_INT 12
5247: PUSH
5248: LD_INT 6
5250: PUSH
5251: LD_INT 6
5253: PUSH
5254: LD_INT 4
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL 28168 0 6
5267: ST_TO_ADDR
// if not base then
5268: LD_VAR 0 8
5272: NOT
5273: IFFALSE 5277
// exit ;
5275: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5277: LD_ADDR_EXP 31
5281: PUSH
5282: LD_EXP 31
5286: PPUSH
5287: LD_EXP 7
5291: PPUSH
5292: LD_VAR 0 8
5296: PPUSH
5297: CALL_OW 1
5301: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5302: LD_ADDR_VAR 0 8
5306: PUSH
5307: LD_INT 34
5309: PPUSH
5310: LD_INT 23
5312: PPUSH
5313: CALL_OW 428
5317: PPUSH
5318: LD_INT 11
5320: PPUSH
5321: LD_INT 0
5323: PPUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 7
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PPUSH
5344: LD_INT 20000
5346: PUSH
5347: LD_INT 3000
5349: PUSH
5350: LD_INT 1000
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: PPUSH
5358: LD_INT 12
5360: PUSH
5361: LD_INT 6
5363: PUSH
5364: LD_INT 6
5366: PUSH
5367: LD_INT 4
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL 28168 0 6
5380: ST_TO_ADDR
// if not base then
5381: LD_VAR 0 8
5385: NOT
5386: IFFALSE 5390
// exit ;
5388: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5390: LD_ADDR_EXP 31
5394: PUSH
5395: LD_EXP 31
5399: PPUSH
5400: LD_EXP 8
5404: PPUSH
5405: LD_VAR 0 8
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5415: LD_ADDR_EXP 14
5419: PUSH
5420: LD_INT 22
5422: PUSH
5423: LD_INT 3
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 30
5432: PUSH
5433: LD_INT 0
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: PUSH
5449: LD_INT 1
5451: ARRAY
5452: PPUSH
5453: LD_INT 25
5455: PPUSH
5456: LD_INT 0
5458: PPUSH
5459: LD_INT 6
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: LD_INT 8
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_OWVAR 67
5477: ARRAY
5478: PPUSH
5479: LD_INT 500
5481: PUSH
5482: LD_INT 100
5484: PUSH
5485: LD_INT 10
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: PPUSH
5493: LD_INT 6
5495: PUSH
5496: LD_INT 7
5498: PUSH
5499: LD_INT 8
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: LIST
5506: PUSH
5507: LD_OWVAR 67
5511: ARRAY
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: LD_INT 0
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: PPUSH
5528: CALL 28168 0 6
5532: ST_TO_ADDR
// end ;
5533: LD_VAR 0 1
5537: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5538: LD_INT 0
5540: PPUSH
5541: PPUSH
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5551: LD_INT 0
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: LD_INT 6
5559: PPUSH
5560: LD_INT 0
5562: PPUSH
5563: LD_INT 0
5565: PPUSH
5566: LD_INT 0
5568: PPUSH
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 8
5574: PPUSH
5575: LD_INT 0
5577: PPUSH
5578: CALL 53866 0 9
// side := 8 ;
5582: LD_ADDR_VAR 0 8
5586: PUSH
5587: LD_INT 8
5589: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5590: LD_ADDR_VAR 0 5
5594: PUSH
5595: LD_INT 20
5597: PPUSH
5598: LD_INT 0
5600: PPUSH
5601: CALL_OW 517
5605: ST_TO_ADDR
// if Difficulty > 2 then
5606: LD_OWVAR 67
5610: PUSH
5611: LD_INT 2
5613: GREATER
5614: IFFALSE 5758
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5616: LD_ADDR_VAR 0 6
5620: PUSH
5621: LD_INT 27
5623: PPUSH
5624: LD_INT 0
5626: PPUSH
5627: CALL_OW 517
5631: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5632: LD_ADDR_VAR 0 2
5636: PUSH
5637: DOUBLE
5638: LD_INT 1
5640: DEC
5641: ST_TO_ADDR
5642: LD_VAR 0 6
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PUSH
5651: FOR_TO
5652: IFFALSE 5756
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5654: LD_ADDR_VAR 0 5
5658: PUSH
5659: LD_VAR 0 5
5663: PPUSH
5664: LD_INT 1
5666: PUSH
5667: LD_VAR 0 5
5671: PUSH
5672: LD_INT 1
5674: ARRAY
5675: PUSH
5676: LD_INT 1
5678: PLUS
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PPUSH
5684: LD_VAR 0 6
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: CALL 24846 0 3
5703: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5704: LD_ADDR_VAR 0 5
5708: PUSH
5709: LD_VAR 0 5
5713: PPUSH
5714: LD_INT 2
5716: PUSH
5717: LD_VAR 0 5
5721: PUSH
5722: LD_INT 2
5724: ARRAY
5725: PUSH
5726: LD_INT 1
5728: PLUS
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: PPUSH
5734: LD_VAR 0 6
5738: PUSH
5739: LD_INT 2
5741: ARRAY
5742: PUSH
5743: LD_VAR 0 2
5747: ARRAY
5748: PPUSH
5749: CALL 24846 0 3
5753: ST_TO_ADDR
// end ;
5754: GO 5651
5756: POP
5757: POP
// end ; if tmp then
5758: LD_VAR 0 5
5762: IFFALSE 5890
// begin for i = 1 to tmp [ 1 ] do
5764: LD_ADDR_VAR 0 2
5768: PUSH
5769: DOUBLE
5770: LD_INT 1
5772: DEC
5773: ST_TO_ADDR
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 1
5781: ARRAY
5782: PUSH
5783: FOR_TO
5784: IFFALSE 5888
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5786: LD_VAR 0 5
5790: PUSH
5791: LD_INT 1
5793: ARRAY
5794: PUSH
5795: LD_VAR 0 2
5799: ARRAY
5800: PPUSH
5801: LD_VAR 0 5
5805: PUSH
5806: LD_INT 2
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 2
5814: ARRAY
5815: PPUSH
5816: LD_VAR 0 8
5820: PPUSH
5821: LD_INT 0
5823: PPUSH
5824: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5828: LD_ADDR_EXP 16
5832: PUSH
5833: LD_EXP 16
5837: PPUSH
5838: LD_EXP 16
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PPUSH
5847: LD_VAR 0 5
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PUSH
5856: LD_VAR 0 2
5860: ARRAY
5861: PUSH
5862: LD_VAR 0 5
5866: PUSH
5867: LD_INT 2
5869: ARRAY
5870: PUSH
5871: LD_VAR 0 2
5875: ARRAY
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: PPUSH
5881: CALL_OW 2
5885: ST_TO_ADDR
// end ;
5886: GO 5783
5888: POP
5889: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5890: LD_ADDR_VAR 0 7
5894: PUSH
5895: LD_INT 165
5897: PUSH
5898: LD_INT 156
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 143
5907: PUSH
5908: LD_INT 145
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 152
5917: PUSH
5918: LD_INT 165
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 123
5927: PUSH
5928: LD_INT 153
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 161
5937: PUSH
5938: LD_INT 215
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PUSH
5945: LD_INT 172
5947: PUSH
5948: LD_INT 100
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PUSH
5955: LD_INT 148
5957: PUSH
5958: LD_INT 83
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: PUSH
5965: LD_INT 122
5967: PUSH
5968: LD_INT 68
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 105
5977: PUSH
5978: LD_INT 74
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 113
5987: PUSH
5988: LD_INT 97
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: ST_TO_ADDR
// for i in cameras do
6007: LD_ADDR_VAR 0 2
6011: PUSH
6012: LD_VAR 0 7
6016: PUSH
6017: FOR_IN
6018: IFFALSE 6049
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
6020: LD_VAR 0 2
6024: PUSH
6025: LD_INT 1
6027: ARRAY
6028: PPUSH
6029: LD_VAR 0 2
6033: PUSH
6034: LD_INT 2
6036: ARRAY
6037: PPUSH
6038: LD_VAR 0 8
6042: PPUSH
6043: CALL_OW 244
6047: GO 6017
6049: POP
6050: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6051: LD_ADDR_VAR 0 5
6055: PUSH
6056: LD_INT 1
6058: PUSH
6059: LD_INT 144
6061: PUSH
6062: LD_INT 110
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: LD_INT 0
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 3
6084: PUSH
6085: LD_INT 151
6087: PUSH
6088: LD_INT 118
6090: PUSH
6091: LD_INT 0
6093: PUSH
6094: LD_INT 0
6096: PUSH
6097: LD_INT 0
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: LD_INT 158
6113: PUSH
6114: LD_INT 110
6116: PUSH
6117: LD_INT 4
6119: PUSH
6120: LD_INT 10
6122: PUSH
6123: LD_INT 15
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: PUSH
6134: LD_INT 23
6136: PUSH
6137: LD_INT 154
6139: PUSH
6140: LD_INT 121
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 155
6165: PUSH
6166: LD_INT 118
6168: PUSH
6169: LD_INT 4
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: LD_INT 0
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_INT 21
6188: PUSH
6189: LD_INT 151
6191: PUSH
6192: LD_INT 122
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: LD_INT 0
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 18
6214: PUSH
6215: LD_INT 148
6217: PUSH
6218: LD_INT 118
6220: PUSH
6221: LD_INT 1
6223: PUSH
6224: LD_INT 0
6226: PUSH
6227: LD_INT 0
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 17
6240: PUSH
6241: LD_INT 147
6243: PUSH
6244: LD_INT 114
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 0
6252: PUSH
6253: LD_INT 0
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 29
6266: PUSH
6267: LD_INT 163
6269: PUSH
6270: LD_INT 120
6272: PUSH
6273: LD_INT 5
6275: PUSH
6276: LD_INT 0
6278: PUSH
6279: LD_INT 0
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 27
6292: PUSH
6293: LD_INT 137
6295: PUSH
6296: LD_INT 116
6298: PUSH
6299: LD_INT 3
6301: PUSH
6302: LD_INT 0
6304: PUSH
6305: LD_INT 0
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 27
6318: PUSH
6319: LD_INT 133
6321: PUSH
6322: LD_INT 111
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: LD_INT 0
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 27
6344: PUSH
6345: LD_INT 132
6347: PUSH
6348: LD_INT 106
6350: PUSH
6351: LD_INT 4
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 26
6370: PUSH
6371: LD_INT 137
6373: PUSH
6374: LD_INT 111
6376: PUSH
6377: LD_INT 0
6379: PUSH
6380: LD_INT 0
6382: PUSH
6383: LD_INT 0
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 141
6399: PUSH
6400: LD_INT 117
6402: PUSH
6403: LD_INT 1
6405: PUSH
6406: LD_INT 13
6408: PUSH
6409: LD_INT 11
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 30
6422: PUSH
6423: LD_INT 140
6425: PUSH
6426: LD_INT 128
6428: PUSH
6429: LD_INT 1
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: LD_INT 0
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 5
6448: PUSH
6449: LD_INT 146
6451: PUSH
6452: LD_INT 96
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 32
6474: PUSH
6475: LD_INT 150
6477: PUSH
6478: LD_INT 98
6480: PUSH
6481: LD_INT 3
6483: PUSH
6484: LD_INT 0
6486: PUSH
6487: LD_INT 0
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 32
6500: PUSH
6501: LD_INT 142
6503: PUSH
6504: LD_INT 95
6506: PUSH
6507: LD_INT 3
6509: PUSH
6510: LD_INT 0
6512: PUSH
6513: LD_INT 0
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 32
6526: PUSH
6527: LD_INT 159
6529: PUSH
6530: LD_INT 104
6532: PUSH
6533: LD_INT 3
6535: PUSH
6536: LD_INT 0
6538: PUSH
6539: LD_INT 0
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: LD_INT 32
6552: PUSH
6553: LD_INT 133
6555: PUSH
6556: LD_INT 95
6558: PUSH
6559: LD_INT 3
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: LD_INT 0
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 32
6578: PUSH
6579: LD_INT 131
6581: PUSH
6582: LD_INT 102
6584: PUSH
6585: LD_INT 2
6587: PUSH
6588: LD_INT 0
6590: PUSH
6591: LD_INT 0
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 32
6604: PUSH
6605: LD_INT 164
6607: PUSH
6608: LD_INT 144
6610: PUSH
6611: LD_INT 0
6613: PUSH
6614: LD_INT 0
6616: PUSH
6617: LD_INT 0
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: LD_INT 146
6633: PUSH
6634: LD_INT 139
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: LD_INT 0
6642: PUSH
6643: LD_INT 0
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 26
6656: PUSH
6657: LD_INT 143
6659: PUSH
6660: LD_INT 122
6662: PUSH
6663: LD_INT 4
6665: PUSH
6666: LD_INT 0
6668: PUSH
6669: LD_INT 0
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 164
6685: PUSH
6686: LD_INT 116
6688: PUSH
6689: LD_INT 2
6691: PUSH
6692: LD_INT 0
6694: PUSH
6695: LD_INT 0
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: ST_TO_ADDR
// for i in tmp do
6733: LD_ADDR_VAR 0 2
6737: PUSH
6738: LD_VAR 0 5
6742: PUSH
6743: FOR_IN
6744: IFFALSE 6975
// begin uc_side := side ;
6746: LD_ADDR_OWVAR 20
6750: PUSH
6751: LD_VAR 0 8
6755: ST_TO_ADDR
// uc_nation := nation_arabian ;
6756: LD_ADDR_OWVAR 21
6760: PUSH
6761: LD_INT 2
6763: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6764: LD_ADDR_OWVAR 42
6768: PUSH
6769: LD_VAR 0 2
6773: PUSH
6774: LD_INT 1
6776: ARRAY
6777: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6778: LD_ADDR_OWVAR 43
6782: PUSH
6783: LD_INT 5
6785: PPUSH
6786: LD_INT 6
6788: PPUSH
6789: CALL_OW 12
6793: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6794: LD_ADDR_OWVAR 44
6798: PUSH
6799: LD_VAR 0 2
6803: PUSH
6804: LD_INT 5
6806: ARRAY
6807: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6808: LD_ADDR_OWVAR 45
6812: PUSH
6813: LD_VAR 0 2
6817: PUSH
6818: LD_INT 6
6820: ARRAY
6821: ST_TO_ADDR
// sr := 0 ;
6822: LD_ADDR_VAR 0 9
6826: PUSH
6827: LD_INT 0
6829: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6830: LD_VAR 0 2
6834: PUSH
6835: LD_INT 1
6837: ARRAY
6838: PUSH
6839: LD_INT 29
6841: EQUAL
6842: IFFALSE 6854
// sr := mat_oil else
6844: LD_ADDR_VAR 0 9
6848: PUSH
6849: LD_INT 2
6851: ST_TO_ADDR
6852: GO 6876
// if i [ 1 ] = b_siberite_mine then
6854: LD_VAR 0 2
6858: PUSH
6859: LD_INT 1
6861: ARRAY
6862: PUSH
6863: LD_INT 30
6865: EQUAL
6866: IFFALSE 6876
// sr := mat_siberit ;
6868: LD_ADDR_VAR 0 9
6872: PUSH
6873: LD_INT 3
6875: ST_TO_ADDR
// if sr then
6876: LD_VAR 0 9
6880: IFFALSE 6936
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6882: LD_VAR 0 2
6886: PUSH
6887: LD_INT 2
6889: ARRAY
6890: PPUSH
6891: LD_VAR 0 2
6895: PUSH
6896: LD_INT 3
6898: ARRAY
6899: PPUSH
6900: LD_VAR 0 9
6904: PPUSH
6905: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6909: LD_VAR 0 2
6913: PUSH
6914: LD_INT 2
6916: ARRAY
6917: PPUSH
6918: LD_VAR 0 2
6922: PUSH
6923: LD_INT 3
6925: ARRAY
6926: PPUSH
6927: LD_VAR 0 8
6931: PPUSH
6932: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6936: LD_ADDR_VAR 0 3
6940: PUSH
6941: LD_VAR 0 2
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PPUSH
6950: LD_VAR 0 2
6954: PUSH
6955: LD_INT 3
6957: ARRAY
6958: PPUSH
6959: LD_VAR 0 2
6963: PUSH
6964: LD_INT 4
6966: ARRAY
6967: PPUSH
6968: CALL_OW 47
6972: ST_TO_ADDR
// end ;
6973: GO 6743
6975: POP
6976: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6977: LD_ADDR_VAR 0 10
6981: PUSH
6982: LD_INT 22
6984: PUSH
6985: LD_VAR 0 8
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PPUSH
7008: CALL_OW 69
7012: ST_TO_ADDR
// if not depot then
7013: LD_VAR 0 10
7017: NOT
7018: IFFALSE 7022
// exit ;
7020: GO 7268
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
7022: LD_ADDR_VAR 0 11
7026: PUSH
7027: LD_VAR 0 10
7031: PUSH
7032: LD_INT 1
7034: ARRAY
7035: PPUSH
7036: LD_INT 6
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: LD_INT 7
7044: PUSH
7045: LD_INT 8
7047: PUSH
7048: LD_INT 10
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: LIST
7055: PUSH
7056: LD_OWVAR 67
7060: ARRAY
7061: PPUSH
7062: LD_INT 3000
7064: PUSH
7065: LD_INT 300
7067: PUSH
7068: LD_INT 100
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: PPUSH
7076: LD_INT 14
7078: PUSH
7079: LD_INT 6
7081: PUSH
7082: LD_INT 6
7084: PUSH
7085: LD_INT 5
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL 28168 0 6
7098: ST_TO_ADDR
// if not base then
7099: LD_VAR 0 11
7103: NOT
7104: IFFALSE 7108
// exit ;
7106: GO 7268
// if Difficulty > 1 then
7108: LD_OWVAR 67
7112: PUSH
7113: LD_INT 1
7115: GREATER
7116: IFFALSE 7189
// begin InitHc ;
7118: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7122: LD_INT 1
7124: PPUSH
7125: LD_INT 5
7127: PPUSH
7128: LD_INT 5
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: PUSH
7143: LD_INT 1
7145: MINUS
7146: ARRAY
7147: PPUSH
7148: CALL_OW 380
// for i = 1 to Difficulty do
7152: LD_ADDR_VAR 0 2
7156: PUSH
7157: DOUBLE
7158: LD_INT 1
7160: DEC
7161: ST_TO_ADDR
7162: LD_OWVAR 67
7166: PUSH
7167: FOR_TO
7168: IFFALSE 7187
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7170: CALL_OW 44
7174: PPUSH
7175: LD_INT 24
7177: PPUSH
7178: LD_INT 0
7180: PPUSH
7181: CALL_OW 49
7185: GO 7167
7187: POP
7188: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7189: LD_ADDR_EXP 31
7193: PUSH
7194: LD_EXP 31
7198: PPUSH
7199: LD_EXP 6
7203: PPUSH
7204: LD_VAR 0 11
7208: PPUSH
7209: CALL_OW 1
7213: ST_TO_ADDR
// hc_gallery := ru ;
7214: LD_ADDR_OWVAR 33
7218: PUSH
7219: LD_STRING ru
7221: ST_TO_ADDR
// hc_face_number := 44 ;
7222: LD_ADDR_OWVAR 34
7226: PUSH
7227: LD_INT 44
7229: ST_TO_ADDR
// hc_name := Robert Farmer ;
7230: LD_ADDR_OWVAR 26
7234: PUSH
7235: LD_STRING Robert Farmer
7237: ST_TO_ADDR
// hc_sex := sex_male ;
7238: LD_ADDR_OWVAR 27
7242: PUSH
7243: LD_INT 1
7245: ST_TO_ADDR
// hc_class := 1 ;
7246: LD_ADDR_OWVAR 28
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// Farmer := CreateHuman ;
7254: LD_ADDR_EXP 13
7258: PUSH
7259: CALL_OW 44
7263: ST_TO_ADDR
// InitHc ;
7264: CALL_OW 19
// end ;
7268: LD_VAR 0 1
7272: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7273: LD_INT 0
7275: PPUSH
7276: PPUSH
7277: PPUSH
7278: PPUSH
// tmp := [ ] ;
7279: LD_ADDR_VAR 0 3
7283: PUSH
7284: EMPTY
7285: ST_TO_ADDR
// for i := 1 to 3 do
7286: LD_ADDR_VAR 0 2
7290: PUSH
7291: DOUBLE
7292: LD_INT 1
7294: DEC
7295: ST_TO_ADDR
7296: LD_INT 3
7298: PUSH
7299: FOR_TO
7300: IFFALSE 7412
// begin uc_side := 3 ;
7302: LD_ADDR_OWVAR 20
7306: PUSH
7307: LD_INT 3
7309: ST_TO_ADDR
// uc_nation := 3 ;
7310: LD_ADDR_OWVAR 21
7314: PUSH
7315: LD_INT 3
7317: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7318: LD_ADDR_OWVAR 37
7322: PUSH
7323: LD_INT 22
7325: ST_TO_ADDR
// vc_engine := engine_siberite ;
7326: LD_ADDR_OWVAR 39
7330: PUSH
7331: LD_INT 3
7333: ST_TO_ADDR
// vc_control := control_computer ;
7334: LD_ADDR_OWVAR 38
7338: PUSH
7339: LD_INT 3
7341: ST_TO_ADDR
// vc_weapon := ru_crane ;
7342: LD_ADDR_OWVAR 40
7346: PUSH
7347: LD_INT 52
7349: ST_TO_ADDR
// veh := CreateVehicle ;
7350: LD_ADDR_VAR 0 4
7354: PUSH
7355: CALL_OW 45
7359: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7360: LD_VAR 0 4
7364: PPUSH
7365: LD_INT 73
7367: PPUSH
7368: LD_INT 122
7370: PPUSH
7371: LD_INT 3
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7381: LD_ADDR_VAR 0 3
7385: PUSH
7386: LD_VAR 0 3
7390: PPUSH
7391: LD_VAR 0 3
7395: PUSH
7396: LD_INT 1
7398: PLUS
7399: PPUSH
7400: LD_VAR 0 4
7404: PPUSH
7405: CALL_OW 1
7409: ST_TO_ADDR
// end ;
7410: GO 7299
7412: POP
7413: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7414: LD_ADDR_EXP 50
7418: PUSH
7419: LD_EXP 50
7423: PPUSH
7424: LD_EXP 7
7428: PPUSH
7429: LD_VAR 0 3
7433: PPUSH
7434: CALL_OW 1
7438: ST_TO_ADDR
// tmp := [ ] ;
7439: LD_ADDR_VAR 0 3
7443: PUSH
7444: EMPTY
7445: ST_TO_ADDR
// for i := 1 to 3 do
7446: LD_ADDR_VAR 0 2
7450: PUSH
7451: DOUBLE
7452: LD_INT 1
7454: DEC
7455: ST_TO_ADDR
7456: LD_INT 3
7458: PUSH
7459: FOR_TO
7460: IFFALSE 7572
// begin uc_side := 3 ;
7462: LD_ADDR_OWVAR 20
7466: PUSH
7467: LD_INT 3
7469: ST_TO_ADDR
// uc_nation := 3 ;
7470: LD_ADDR_OWVAR 21
7474: PUSH
7475: LD_INT 3
7477: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7478: LD_ADDR_OWVAR 37
7482: PUSH
7483: LD_INT 22
7485: ST_TO_ADDR
// vc_engine := engine_siberite ;
7486: LD_ADDR_OWVAR 39
7490: PUSH
7491: LD_INT 3
7493: ST_TO_ADDR
// vc_control := control_computer ;
7494: LD_ADDR_OWVAR 38
7498: PUSH
7499: LD_INT 3
7501: ST_TO_ADDR
// vc_weapon := ru_crane ;
7502: LD_ADDR_OWVAR 40
7506: PUSH
7507: LD_INT 52
7509: ST_TO_ADDR
// veh := CreateVehicle ;
7510: LD_ADDR_VAR 0 4
7514: PUSH
7515: CALL_OW 45
7519: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7520: LD_VAR 0 4
7524: PPUSH
7525: LD_INT 22
7527: PPUSH
7528: LD_INT 28
7530: PPUSH
7531: LD_INT 3
7533: PPUSH
7534: LD_INT 0
7536: PPUSH
7537: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7541: LD_ADDR_VAR 0 3
7545: PUSH
7546: LD_VAR 0 3
7550: PPUSH
7551: LD_VAR 0 3
7555: PUSH
7556: LD_INT 1
7558: PLUS
7559: PPUSH
7560: LD_VAR 0 4
7564: PPUSH
7565: CALL_OW 1
7569: ST_TO_ADDR
// end ;
7570: GO 7459
7572: POP
7573: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7574: LD_ADDR_EXP 50
7578: PUSH
7579: LD_EXP 50
7583: PPUSH
7584: LD_EXP 8
7588: PPUSH
7589: LD_VAR 0 3
7593: PPUSH
7594: CALL_OW 1
7598: ST_TO_ADDR
// end ;
7599: LD_VAR 0 1
7603: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7604: LD_INT 0
7606: PPUSH
7607: PPUSH
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
7613: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7614: LD_INT 0
7616: PPUSH
7617: LD_INT 0
7619: PPUSH
7620: LD_INT 4
7622: PPUSH
7623: LD_INT 0
7625: PPUSH
7626: LD_INT 0
7628: PPUSH
7629: LD_INT 0
7631: PPUSH
7632: LD_INT 0
7634: PPUSH
7635: LD_INT 10
7637: PPUSH
7638: LD_INT 0
7640: PPUSH
7641: CALL 53866 0 9
// side := 4 ;
7645: LD_ADDR_VAR 0 5
7649: PUSH
7650: LD_INT 4
7652: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7653: LD_ADDR_VAR 0 4
7657: PUSH
7658: LD_INT 1
7660: PUSH
7661: LD_INT 144
7663: PUSH
7664: LD_INT 18
7666: PUSH
7667: LD_INT 4
7669: PUSH
7670: LD_INT 0
7672: PUSH
7673: LD_INT 0
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: PUSH
7684: LD_INT 3
7686: PUSH
7687: LD_INT 137
7689: PUSH
7690: LD_INT 8
7692: PUSH
7693: LD_INT 4
7695: PUSH
7696: LD_INT 0
7698: PUSH
7699: LD_INT 0
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_INT 141
7715: PUSH
7716: LD_INT 8
7718: PUSH
7719: LD_INT 4
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: LD_INT 0
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 25
7738: PUSH
7739: LD_INT 137
7741: PUSH
7742: LD_INT 5
7744: PUSH
7745: LD_INT 3
7747: PUSH
7748: LD_INT 0
7750: PUSH
7751: LD_INT 0
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 18
7764: PUSH
7765: LD_INT 137
7767: PUSH
7768: LD_INT 12
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: LD_INT 0
7776: PUSH
7777: LD_INT 0
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 17
7790: PUSH
7791: LD_INT 133
7793: PUSH
7794: LD_INT 4
7796: PUSH
7797: LD_INT 2
7799: PUSH
7800: LD_INT 0
7802: PUSH
7803: LD_INT 0
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 16
7816: PUSH
7817: LD_INT 140
7819: PUSH
7820: LD_INT 11
7822: PUSH
7823: LD_INT 5
7825: PUSH
7826: LD_INT 0
7828: PUSH
7829: LD_INT 0
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: PUSH
7840: LD_INT 8
7842: PUSH
7843: LD_INT 149
7845: PUSH
7846: LD_INT 26
7848: PUSH
7849: LD_INT 4
7851: PUSH
7852: LD_INT 10
7854: PUSH
7855: LD_INT 15
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 8
7868: PUSH
7869: LD_INT 142
7871: PUSH
7872: LD_INT 26
7874: PUSH
7875: LD_INT 1
7877: PUSH
7878: LD_INT 11
7880: PUSH
7881: LD_INT 12
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 27
7894: PUSH
7895: LD_INT 153
7897: PUSH
7898: LD_INT 32
7900: PUSH
7901: LD_INT 5
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: LD_INT 0
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 27
7920: PUSH
7921: LD_INT 145
7923: PUSH
7924: LD_INT 32
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 0
7932: PUSH
7933: LD_INT 0
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: LIST
7941: LIST
7942: LIST
7943: PUSH
7944: LD_INT 27
7946: PUSH
7947: LD_INT 138
7949: PUSH
7950: LD_INT 2
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: LD_INT 0
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: LIST
7968: LIST
7969: PUSH
7970: LD_INT 27
7972: PUSH
7973: LD_INT 144
7975: PUSH
7976: LD_INT 13
7978: PUSH
7979: LD_INT 0
7981: PUSH
7982: LD_INT 0
7984: PUSH
7985: LD_INT 0
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 26
7998: PUSH
7999: LD_INT 124
8001: PUSH
8002: LD_INT 2
8004: PUSH
8005: LD_INT 4
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: LD_INT 0
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 26
8024: PUSH
8025: LD_INT 121
8027: PUSH
8028: LD_INT 2
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: LD_INT 0
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 26
8050: PUSH
8051: LD_INT 118
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: LD_INT 1
8059: PUSH
8060: LD_INT 0
8062: PUSH
8063: LD_INT 0
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 29
8076: PUSH
8077: LD_INT 159
8079: PUSH
8080: LD_INT 47
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 0
8088: PUSH
8089: LD_INT 0
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: PUSH
8100: LD_INT 32
8102: PUSH
8103: LD_INT 146
8105: PUSH
8106: LD_INT 41
8108: PUSH
8109: LD_INT 0
8111: PUSH
8112: LD_INT 0
8114: PUSH
8115: LD_INT 0
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 33
8128: PUSH
8129: LD_INT 136
8131: PUSH
8132: LD_INT 37
8134: PUSH
8135: LD_INT 0
8137: PUSH
8138: LD_INT 0
8140: PUSH
8141: LD_INT 0
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 33
8154: PUSH
8155: LD_INT 132
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 0
8163: PUSH
8164: LD_INT 0
8166: PUSH
8167: LD_INT 0
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: PUSH
8178: LD_INT 36
8180: PUSH
8181: LD_INT 124
8183: PUSH
8184: LD_INT 7
8186: PUSH
8187: LD_INT 1
8189: PUSH
8190: LD_INT 0
8192: PUSH
8193: LD_INT 0
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 5
8206: PUSH
8207: LD_INT 124
8209: PUSH
8210: LD_INT 19
8212: PUSH
8213: LD_INT 0
8215: PUSH
8216: LD_INT 0
8218: PUSH
8219: LD_INT 0
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: PUSH
8230: LD_INT 32
8232: PUSH
8233: LD_INT 127
8235: PUSH
8236: LD_INT 23
8238: PUSH
8239: LD_INT 0
8241: PUSH
8242: LD_INT 0
8244: PUSH
8245: LD_INT 0
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
// for i in tmp do
8281: LD_ADDR_VAR 0 2
8285: PUSH
8286: LD_VAR 0 4
8290: PUSH
8291: FOR_IN
8292: IFFALSE 8523
// begin uc_side := side ;
8294: LD_ADDR_OWVAR 20
8298: PUSH
8299: LD_VAR 0 5
8303: ST_TO_ADDR
// uc_nation := nation_american ;
8304: LD_ADDR_OWVAR 21
8308: PUSH
8309: LD_INT 1
8311: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8312: LD_ADDR_OWVAR 42
8316: PUSH
8317: LD_VAR 0 2
8321: PUSH
8322: LD_INT 1
8324: ARRAY
8325: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8326: LD_ADDR_OWVAR 43
8330: PUSH
8331: LD_INT 5
8333: PPUSH
8334: LD_INT 6
8336: PPUSH
8337: CALL_OW 12
8341: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8342: LD_ADDR_OWVAR 44
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 5
8354: ARRAY
8355: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8356: LD_ADDR_OWVAR 45
8360: PUSH
8361: LD_VAR 0 2
8365: PUSH
8366: LD_INT 6
8368: ARRAY
8369: ST_TO_ADDR
// sr := 0 ;
8370: LD_ADDR_VAR 0 6
8374: PUSH
8375: LD_INT 0
8377: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8378: LD_VAR 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PUSH
8387: LD_INT 29
8389: EQUAL
8390: IFFALSE 8402
// sr := mat_oil else
8392: LD_ADDR_VAR 0 6
8396: PUSH
8397: LD_INT 2
8399: ST_TO_ADDR
8400: GO 8424
// if i [ 1 ] = b_siberite_mine then
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PUSH
8411: LD_INT 30
8413: EQUAL
8414: IFFALSE 8424
// sr := mat_siberit ;
8416: LD_ADDR_VAR 0 6
8420: PUSH
8421: LD_INT 3
8423: ST_TO_ADDR
// if sr then
8424: LD_VAR 0 6
8428: IFFALSE 8484
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8430: LD_VAR 0 2
8434: PUSH
8435: LD_INT 2
8437: ARRAY
8438: PPUSH
8439: LD_VAR 0 2
8443: PUSH
8444: LD_INT 3
8446: ARRAY
8447: PPUSH
8448: LD_VAR 0 6
8452: PPUSH
8453: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8457: LD_VAR 0 2
8461: PUSH
8462: LD_INT 2
8464: ARRAY
8465: PPUSH
8466: LD_VAR 0 2
8470: PUSH
8471: LD_INT 3
8473: ARRAY
8474: PPUSH
8475: LD_VAR 0 5
8479: PPUSH
8480: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8484: LD_ADDR_VAR 0 3
8488: PUSH
8489: LD_VAR 0 2
8493: PUSH
8494: LD_INT 2
8496: ARRAY
8497: PPUSH
8498: LD_VAR 0 2
8502: PUSH
8503: LD_INT 3
8505: ARRAY
8506: PPUSH
8507: LD_VAR 0 2
8511: PUSH
8512: LD_INT 4
8514: ARRAY
8515: PPUSH
8516: CALL_OW 47
8520: ST_TO_ADDR
// end ;
8521: GO 8291
8523: POP
8524: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8525: LD_ADDR_VAR 0 8
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 5
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 30
8544: PUSH
8545: LD_INT 1
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL_OW 69
8560: ST_TO_ADDR
// if not depot then
8561: LD_VAR 0 8
8565: NOT
8566: IFFALSE 8570
// exit ;
8568: GO 8842
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8570: LD_ADDR_VAR 0 7
8574: PUSH
8575: LD_VAR 0 8
8579: PUSH
8580: LD_INT 1
8582: ARRAY
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_STRING theta3
8589: PPUSH
8590: LD_INT 8
8592: PUSH
8593: LD_INT 7
8595: PUSH
8596: LD_INT 6
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: LD_OWVAR 67
8608: ARRAY
8609: PPUSH
8610: LD_INT 2500
8612: PUSH
8613: LD_INT 2000
8615: PUSH
8616: LD_INT 1750
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: LIST
8623: PUSH
8624: LD_OWVAR 67
8628: ARRAY
8629: PUSH
8630: LD_INT 300
8632: PUSH
8633: LD_INT 250
8635: PUSH
8636: LD_INT 200
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: LD_INT 80
8652: PUSH
8653: LD_INT 60
8655: PUSH
8656: LD_INT 50
8658: PUSH
8659: EMPTY
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_OWVAR 67
8668: ARRAY
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PPUSH
8675: LD_INT 7
8677: PUSH
8678: LD_INT 6
8680: PUSH
8681: LD_INT 5
8683: PUSH
8684: LD_INT 5
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: CALL 28168 0 6
8697: ST_TO_ADDR
// if not base then
8698: LD_VAR 0 7
8702: NOT
8703: IFFALSE 8707
// exit ;
8705: GO 8842
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8707: LD_ADDR_EXP 31
8711: PUSH
8712: LD_EXP 31
8716: PPUSH
8717: LD_EXP 5
8721: PPUSH
8722: LD_VAR 0 7
8726: PPUSH
8727: CALL_OW 1
8731: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8732: LD_INT 1
8734: PPUSH
8735: LD_INT 1
8737: PPUSH
8738: LD_INT 7
8740: PPUSH
8741: CALL_OW 380
// allyCommander := CreateHuman ;
8745: LD_ADDR_EXP 11
8749: PUSH
8750: CALL_OW 44
8754: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8755: LD_EXP 11
8759: PPUSH
8760: LD_INT 139
8762: PPUSH
8763: LD_INT 15
8765: PPUSH
8766: LD_INT 0
8768: PPUSH
8769: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8773: LD_EXP 11
8777: PPUSH
8778: LD_INT 137
8780: PPUSH
8781: LD_INT 15
8783: PPUSH
8784: CALL_OW 118
// hc_gallery := us ;
8788: LD_ADDR_OWVAR 33
8792: PUSH
8793: LD_STRING us
8795: ST_TO_ADDR
// hc_face_number := 7 ;
8796: LD_ADDR_OWVAR 34
8800: PUSH
8801: LD_INT 7
8803: ST_TO_ADDR
// hc_name := Arthur Powell ;
8804: LD_ADDR_OWVAR 26
8808: PUSH
8809: LD_STRING Arthur Powell
8811: ST_TO_ADDR
// hc_sex := sex_male ;
8812: LD_ADDR_OWVAR 27
8816: PUSH
8817: LD_INT 1
8819: ST_TO_ADDR
// hc_class := 1 ;
8820: LD_ADDR_OWVAR 28
8824: PUSH
8825: LD_INT 1
8827: ST_TO_ADDR
// Powell := CreateHuman ;
8828: LD_ADDR_EXP 12
8832: PUSH
8833: CALL_OW 44
8837: ST_TO_ADDR
// InitHc ;
8838: CALL_OW 19
// end ;
8842: LD_VAR 0 1
8846: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8847: LD_INT 0
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
// side := 1 ;
8858: LD_ADDR_VAR 0 3
8862: PUSH
8863: LD_INT 1
8865: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8866: LD_ADDR_VAR 0 1
8870: PUSH
8871: EMPTY
8872: PUSH
8873: EMPTY
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: ST_TO_ADDR
// uc_side := side ;
8879: LD_ADDR_OWVAR 20
8883: PUSH
8884: LD_VAR 0 3
8888: ST_TO_ADDR
// uc_nation := nation_american ;
8889: LD_ADDR_OWVAR 21
8893: PUSH
8894: LD_INT 1
8896: ST_TO_ADDR
// InitHc ;
8897: CALL_OW 19
// InitVc ;
8901: CALL_OW 20
// hc_importance := 0 ;
8905: LD_ADDR_OWVAR 32
8909: PUSH
8910: LD_INT 0
8912: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8913: LD_ADDR_VAR 0 7
8917: PUSH
8918: LD_INT 2
8920: PUSH
8921: LD_INT 3
8923: PUSH
8924: LD_INT 3
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// if commander = 2 then
8932: LD_EXP 25
8936: PUSH
8937: LD_INT 2
8939: EQUAL
8940: IFFALSE 8961
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8942: LD_ADDR_VAR 0 7
8946: PUSH
8947: LD_INT 3
8949: PUSH
8950: LD_INT 4
8952: PUSH
8953: LD_INT 4
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: LIST
8960: ST_TO_ADDR
// if commander = 3 then
8961: LD_EXP 25
8965: PUSH
8966: LD_INT 3
8968: EQUAL
8969: IFFALSE 8990
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8971: LD_ADDR_VAR 0 7
8975: PUSH
8976: LD_INT 2
8978: PUSH
8979: LD_INT 5
8981: PUSH
8982: LD_INT 5
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8990: LD_ADDR_VAR 0 8
8994: PUSH
8995: LD_INT 2
8997: PUSH
8998: LD_INT 2
9000: PUSH
9001: LD_INT 1
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: LIST
9008: ST_TO_ADDR
// if commander = 2 then
9009: LD_EXP 25
9013: PUSH
9014: LD_INT 2
9016: EQUAL
9017: IFFALSE 9038
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
9019: LD_ADDR_VAR 0 8
9023: PUSH
9024: LD_INT 1
9026: PUSH
9027: LD_INT 1
9029: PUSH
9030: LD_INT 3
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: ST_TO_ADDR
// if commander = 3 then
9038: LD_EXP 25
9042: PUSH
9043: LD_INT 3
9045: EQUAL
9046: IFFALSE 9067
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9048: LD_ADDR_VAR 0 8
9052: PUSH
9053: LD_INT 3
9055: PUSH
9056: LD_INT 3
9058: PUSH
9059: LD_INT 1
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: LIST
9066: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9067: LD_ADDR_VAR 0 9
9071: PUSH
9072: LD_INT 5
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: LD_INT 4
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// if commander = 2 then
9086: LD_EXP 25
9090: PUSH
9091: LD_INT 2
9093: EQUAL
9094: IFFALSE 9115
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9096: LD_ADDR_VAR 0 9
9100: PUSH
9101: LD_INT 7
9103: PUSH
9104: LD_INT 5
9106: PUSH
9107: LD_INT 6
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: ST_TO_ADDR
// if commander = 3 then
9115: LD_EXP 25
9119: PUSH
9120: LD_INT 3
9122: EQUAL
9123: IFFALSE 9144
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9125: LD_ADDR_VAR 0 9
9129: PUSH
9130: LD_INT 9
9132: PUSH
9133: LD_INT 10
9135: PUSH
9136: LD_INT 7
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: LIST
9143: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9144: LD_ADDR_VAR 0 5
9148: PUSH
9149: LD_INT 5
9151: PUSH
9152: LD_INT 5
9154: PUSH
9155: LD_INT 4
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_OWVAR 67
9167: ARRAY
9168: ST_TO_ADDR
// if commander = 2 then
9169: LD_EXP 25
9173: PUSH
9174: LD_INT 2
9176: EQUAL
9177: IFFALSE 9193
// tanks := tanks + 3 ;
9179: LD_ADDR_VAR 0 5
9183: PUSH
9184: LD_VAR 0 5
9188: PUSH
9189: LD_INT 3
9191: PLUS
9192: ST_TO_ADDR
// for i = 1 to tanks do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_VAR 0 5
9207: PUSH
9208: FOR_TO
9209: IFFALSE 9319
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9211: LD_VAR 0 7
9215: PUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 3
9223: MOD
9224: PUSH
9225: LD_INT 1
9227: PLUS
9228: ARRAY
9229: PPUSH
9230: LD_VAR 0 8
9234: PUSH
9235: LD_INT 1
9237: PPUSH
9238: LD_INT 3
9240: PPUSH
9241: CALL_OW 12
9245: ARRAY
9246: PPUSH
9247: LD_INT 1
9249: PPUSH
9250: LD_VAR 0 9
9254: PUSH
9255: LD_VAR 0 2
9259: PUSH
9260: LD_INT 3
9262: MOD
9263: PUSH
9264: LD_INT 1
9266: PLUS
9267: ARRAY
9268: PPUSH
9269: LD_INT 60
9271: PPUSH
9272: LD_INT 70
9274: PPUSH
9275: CALL_OW 12
9279: PPUSH
9280: CALL 24724 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9284: LD_ADDR_VAR 0 1
9288: PUSH
9289: LD_VAR 0 1
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: LD_VAR 0 1
9301: PUSH
9302: LD_INT 1
9304: ARRAY
9305: PUSH
9306: CALL_OW 45
9310: ADD
9311: PPUSH
9312: CALL_OW 1
9316: ST_TO_ADDR
// end ;
9317: GO 9208
9319: POP
9320: POP
// cl := 1 ;
9321: LD_ADDR_VAR 0 6
9325: PUSH
9326: LD_INT 1
9328: ST_TO_ADDR
// for i = 1 to 10 do
9329: LD_ADDR_VAR 0 2
9333: PUSH
9334: DOUBLE
9335: LD_INT 1
9337: DEC
9338: ST_TO_ADDR
9339: LD_INT 10
9341: PUSH
9342: FOR_TO
9343: IFFALSE 9458
// begin if i mod 4 = 0 then
9345: LD_VAR 0 2
9349: PUSH
9350: LD_INT 4
9352: MOD
9353: PUSH
9354: LD_INT 0
9356: EQUAL
9357: IFFALSE 9373
// cl := cl + 1 ;
9359: LD_ADDR_VAR 0 6
9363: PUSH
9364: LD_VAR 0 6
9368: PUSH
9369: LD_INT 1
9371: PLUS
9372: ST_TO_ADDR
// if cl = 2 then
9373: LD_VAR 0 6
9377: PUSH
9378: LD_INT 2
9380: EQUAL
9381: IFFALSE 9391
// cl := 3 ;
9383: LD_ADDR_VAR 0 6
9387: PUSH
9388: LD_INT 3
9390: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9391: LD_INT 0
9393: PPUSH
9394: LD_VAR 0 6
9398: PPUSH
9399: LD_INT 6
9401: PUSH
9402: LD_INT 6
9404: PUSH
9405: LD_INT 5
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PPUSH
9419: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: LD_VAR 0 1
9432: PPUSH
9433: LD_INT 2
9435: PPUSH
9436: LD_VAR 0 1
9440: PUSH
9441: LD_INT 2
9443: ARRAY
9444: PUSH
9445: CALL_OW 44
9449: ADD
9450: PPUSH
9451: CALL_OW 1
9455: ST_TO_ADDR
// end ;
9456: GO 9342
9458: POP
9459: POP
// if commander = 1 then
9460: LD_EXP 25
9464: PUSH
9465: LD_INT 1
9467: EQUAL
9468: IFFALSE 9536
// for i = 1 to 4 do
9470: LD_ADDR_VAR 0 2
9474: PUSH
9475: DOUBLE
9476: LD_INT 1
9478: DEC
9479: ST_TO_ADDR
9480: LD_INT 4
9482: PUSH
9483: FOR_TO
9484: IFFALSE 9534
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9486: LD_INT 0
9488: PPUSH
9489: LD_INT 1
9491: PPUSH
9492: LD_INT 8
9494: PPUSH
9495: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9499: LD_ADDR_VAR 0 1
9503: PUSH
9504: LD_VAR 0 1
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: LD_VAR 0 1
9516: PUSH
9517: LD_INT 2
9519: ARRAY
9520: PUSH
9521: CALL_OW 44
9525: ADD
9526: PPUSH
9527: CALL_OW 1
9531: ST_TO_ADDR
// end ;
9532: GO 9483
9534: POP
9535: POP
// techs := [ ] ;
9536: LD_ADDR_VAR 0 4
9540: PUSH
9541: EMPTY
9542: ST_TO_ADDR
// if commander = 1 then
9543: LD_EXP 25
9547: PUSH
9548: LD_INT 1
9550: EQUAL
9551: IFFALSE 9576
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9553: LD_ADDR_VAR 0 4
9557: PUSH
9558: LD_INT 51
9560: PUSH
9561: LD_INT 52
9563: PUSH
9564: LD_INT 53
9566: PUSH
9567: LD_INT 12
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: ST_TO_ADDR
// if commander = 2 then
9576: LD_EXP 25
9580: PUSH
9581: LD_INT 2
9583: EQUAL
9584: IFFALSE 9621
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9586: LD_ADDR_VAR 0 4
9590: PUSH
9591: LD_INT 48
9593: PUSH
9594: LD_INT 47
9596: PUSH
9597: LD_INT 46
9599: PUSH
9600: LD_INT 45
9602: PUSH
9603: LD_INT 35
9605: PUSH
9606: LD_INT 60
9608: PUSH
9609: LD_INT 6
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: ST_TO_ADDR
// if commander = 3 then
9621: LD_EXP 25
9625: PUSH
9626: LD_INT 3
9628: EQUAL
9629: IFFALSE 9678
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9631: LD_ADDR_VAR 0 4
9635: PUSH
9636: LD_INT 27
9638: PUSH
9639: LD_INT 36
9641: PUSH
9642: LD_INT 32
9644: PUSH
9645: LD_INT 57
9647: PUSH
9648: LD_INT 58
9650: PUSH
9651: LD_INT 47
9653: PUSH
9654: LD_INT 46
9656: PUSH
9657: LD_INT 51
9659: PUSH
9660: LD_INT 69
9662: PUSH
9663: LD_INT 39
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// if techs then
9678: LD_VAR 0 4
9682: IFFALSE 9716
// for i in techs do
9684: LD_ADDR_VAR 0 2
9688: PUSH
9689: LD_VAR 0 4
9693: PUSH
9694: FOR_IN
9695: IFFALSE 9714
// SetTech ( i , 1 , state_researched ) ;
9697: LD_VAR 0 2
9701: PPUSH
9702: LD_INT 1
9704: PPUSH
9705: LD_INT 2
9707: PPUSH
9708: CALL_OW 322
9712: GO 9694
9714: POP
9715: POP
// hc_gallery := skirmish ;
9716: LD_ADDR_OWVAR 33
9720: PUSH
9721: LD_STRING skirmish
9723: ST_TO_ADDR
// hc_face_number := commander ;
9724: LD_ADDR_OWVAR 34
9728: PUSH
9729: LD_EXP 25
9733: ST_TO_ADDR
// hc_importance := 100 ;
9734: LD_ADDR_OWVAR 32
9738: PUSH
9739: LD_INT 100
9741: ST_TO_ADDR
// case commander of 1 :
9742: LD_EXP 25
9746: PUSH
9747: LD_INT 1
9749: DOUBLE
9750: EQUAL
9751: IFTRUE 9755
9753: GO 9779
9755: POP
// begin hc_name := Jeff Ironside ;
9756: LD_ADDR_OWVAR 26
9760: PUSH
9761: LD_STRING Jeff Ironside
9763: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9764: LD_INT 1
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 7
9772: PPUSH
9773: CALL_OW 380
// end ; 2 :
9777: GO 9844
9779: LD_INT 2
9781: DOUBLE
9782: EQUAL
9783: IFTRUE 9787
9785: GO 9811
9787: POP
// begin hc_name := Paul Johnson ;
9788: LD_ADDR_OWVAR 26
9792: PUSH
9793: LD_STRING Paul Johnson
9795: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9796: LD_INT 1
9798: PPUSH
9799: LD_INT 3
9801: PPUSH
9802: LD_INT 7
9804: PPUSH
9805: CALL_OW 380
// end ; 3 :
9809: GO 9844
9811: LD_INT 3
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9843
9819: POP
// begin hc_name := Lisa Stuart ;
9820: LD_ADDR_OWVAR 26
9824: PUSH
9825: LD_STRING Lisa Stuart
9827: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9828: LD_INT 2
9830: PPUSH
9831: LD_INT 4
9833: PPUSH
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 380
// end ; end ;
9841: GO 9844
9843: POP
// playerCommander := CreateHuman ;
9844: LD_ADDR_EXP 9
9848: PUSH
9849: CALL_OW 44
9853: ST_TO_ADDR
// hc_importance := 0 ;
9854: LD_ADDR_OWVAR 32
9858: PUSH
9859: LD_INT 0
9861: ST_TO_ADDR
// hc_gallery :=  ;
9862: LD_ADDR_OWVAR 33
9866: PUSH
9867: LD_STRING 
9869: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9870: LD_ADDR_VAR 0 1
9874: PUSH
9875: LD_VAR 0 1
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_INT 2
9890: ARRAY
9891: PUSH
9892: LD_EXP 9
9896: ADD
9897: PPUSH
9898: CALL_OW 1
9902: ST_TO_ADDR
// end ;
9903: LD_VAR 0 1
9907: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9908: LD_INT 0
9910: PPUSH
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// uc_side := 1 ;
9916: LD_ADDR_OWVAR 20
9920: PUSH
9921: LD_INT 1
9923: ST_TO_ADDR
// uc_nation := 1 ;
9924: LD_ADDR_OWVAR 21
9928: PUSH
9929: LD_INT 1
9931: ST_TO_ADDR
// InitHc ;
9932: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9936: LD_ADDR_VAR 0 3
9940: PUSH
9941: LD_INT 3
9943: PUSH
9944: LD_INT 3
9946: PUSH
9947: LD_INT 2
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: LIST
9954: PUSH
9955: LD_OWVAR 67
9959: ARRAY
9960: ST_TO_ADDR
// for i = 1 to peopleAmount do
9961: LD_ADDR_VAR 0 2
9965: PUSH
9966: DOUBLE
9967: LD_INT 1
9969: DEC
9970: ST_TO_ADDR
9971: LD_VAR 0 3
9975: PUSH
9976: FOR_TO
9977: IFFALSE 10026
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9979: LD_INT 0
9981: PPUSH
9982: LD_INT 2
9984: PPUSH
9985: LD_INT 7
9987: PUSH
9988: LD_INT 6
9990: PUSH
9991: LD_INT 5
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: PUSH
9999: LD_OWVAR 67
10003: ARRAY
10004: PPUSH
10005: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
10009: CALL_OW 44
10013: PPUSH
10014: LD_INT 19
10016: PPUSH
10017: LD_INT 0
10019: PPUSH
10020: CALL 56094 0 3
// end ;
10024: GO 9976
10026: POP
10027: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
10028: LD_INT 2
10030: PPUSH
10031: LD_INT 1
10033: PPUSH
10034: LD_INT 3
10036: PPUSH
10037: LD_INT 13
10039: PPUSH
10040: LD_INT 58
10042: PPUSH
10043: CALL 24724 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10047: CALL_OW 45
10051: PPUSH
10052: LD_INT 19
10054: PPUSH
10055: LD_INT 0
10057: PPUSH
10058: CALL 56094 0 3
// if commander = 1 then
10062: LD_EXP 25
10066: PUSH
10067: LD_INT 1
10069: EQUAL
10070: IFFALSE 10081
// wait ( 6 6$00 ) else
10072: LD_INT 12600
10074: PPUSH
10075: CALL_OW 67
10079: GO 10088
// wait ( 8 8$00 ) ;
10081: LD_INT 16800
10083: PPUSH
10084: CALL_OW 67
// uc_side := 1 ;
10088: LD_ADDR_OWVAR 20
10092: PUSH
10093: LD_INT 1
10095: ST_TO_ADDR
// uc_nation := 1 ;
10096: LD_ADDR_OWVAR 21
10100: PUSH
10101: LD_INT 1
10103: ST_TO_ADDR
// InitVc ;
10104: CALL_OW 20
// InitHc ;
10108: CALL_OW 19
// for i = 1 to 5 do
10112: LD_ADDR_VAR 0 2
10116: PUSH
10117: DOUBLE
10118: LD_INT 1
10120: DEC
10121: ST_TO_ADDR
10122: LD_INT 5
10124: PUSH
10125: FOR_TO
10126: IFFALSE 10370
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10128: LD_INT 4
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 1
10136: PUSH
10137: EMPTY
10138: LIST
10139: LIST
10140: LIST
10141: PUSH
10142: LD_VAR 0 2
10146: PUSH
10147: LD_INT 3
10149: MOD
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 1
10158: PPUSH
10159: LD_INT 1
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 2
10177: PUSH
10178: LD_INT 3
10180: MOD
10181: PUSH
10182: LD_INT 1
10184: PLUS
10185: ARRAY
10186: PPUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 12
10192: PUSH
10193: LD_INT 11
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: PUSH
10201: LD_VAR 0 2
10205: PUSH
10206: LD_INT 3
10208: MOD
10209: PUSH
10210: LD_INT 1
10212: PLUS
10213: ARRAY
10214: PPUSH
10215: LD_INT 40
10217: PPUSH
10218: LD_INT 55
10220: PPUSH
10221: CALL_OW 12
10225: PPUSH
10226: CALL 24724 0 5
// veh := CreateVehicle ;
10230: LD_ADDR_VAR 0 6
10234: PUSH
10235: CALL_OW 45
10239: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10240: LD_VAR 0 6
10244: PPUSH
10245: LD_INT 19
10247: PPUSH
10248: LD_INT 0
10250: PPUSH
10251: CALL 56094 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10255: LD_VAR 0 6
10259: PPUSH
10260: CALL_OW 264
10264: PUSH
10265: LD_INT 12
10267: EQUAL
10268: IFFALSE 10300
// begin AddCargo ( veh , mat_cans , 70 ) ;
10270: LD_VAR 0 6
10274: PPUSH
10275: LD_INT 1
10277: PPUSH
10278: LD_INT 70
10280: PPUSH
10281: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10285: LD_VAR 0 6
10289: PPUSH
10290: LD_INT 3
10292: PPUSH
10293: LD_INT 30
10295: PPUSH
10296: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10300: LD_VAR 0 6
10304: PPUSH
10305: CALL_OW 263
10309: PUSH
10310: LD_INT 1
10312: EQUAL
10313: IFFALSE 10368
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10315: LD_INT 1
10317: PPUSH
10318: LD_INT 3
10320: PPUSH
10321: LD_INT 6
10323: PPUSH
10324: CALL_OW 380
// un := CreateHuman ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: CALL_OW 44
10337: ST_TO_ADDR
// tmp := tmp ^ un ;
10338: LD_ADDR_VAR 0 4
10342: PUSH
10343: LD_VAR 0 4
10347: PUSH
10348: LD_VAR 0 5
10352: ADD
10353: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10354: LD_VAR 0 5
10358: PPUSH
10359: LD_VAR 0 6
10363: PPUSH
10364: CALL_OW 52
// end ; end ;
10368: GO 10125
10370: POP
10371: POP
// if tmp then
10372: LD_VAR 0 4
10376: IFFALSE 10440
// begin CenterNowOnUnits ( tmp ) ;
10378: LD_VAR 0 4
10382: PPUSH
10383: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10387: LD_VAR 0 4
10391: PUSH
10392: LD_INT 1
10394: ARRAY
10395: PPUSH
10396: LD_STRING DAR-1
10398: PPUSH
10399: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10403: LD_EXP 9
10407: PPUSH
10408: LD_STRING D
10410: PUSH
10411: LD_STRING I
10413: PUSH
10414: LD_STRING J
10416: PUSH
10417: LD_STRING S
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_EXP 25
10429: ARRAY
10430: STR
10431: PUSH
10432: LD_STRING -1-DAR
10434: STR
10435: PPUSH
10436: CALL_OW 88
// end ; if not reinforceAllowed then
10440: LD_EXP 24
10444: NOT
10445: IFFALSE 10449
// exit ;
10447: GO 10603
// wait ( 25 25$00 ) ;
10449: LD_INT 52500
10451: PPUSH
10452: CALL_OW 67
// uc_side := 1 ;
10456: LD_ADDR_OWVAR 20
10460: PUSH
10461: LD_INT 1
10463: ST_TO_ADDR
// uc_nation := 1 ;
10464: LD_ADDR_OWVAR 21
10468: PUSH
10469: LD_INT 1
10471: ST_TO_ADDR
// InitVc ;
10472: CALL_OW 20
// InitHc ;
10476: CALL_OW 19
// for i = 1 to 4 do
10480: LD_ADDR_VAR 0 2
10484: PUSH
10485: DOUBLE
10486: LD_INT 1
10488: DEC
10489: ST_TO_ADDR
10490: LD_INT 4
10492: PUSH
10493: FOR_TO
10494: IFFALSE 10601
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10496: LD_INT 5
10498: PPUSH
10499: LD_INT 3
10501: PPUSH
10502: LD_INT 1
10504: PPUSH
10505: LD_INT 6
10507: PPUSH
10508: LD_INT 1
10510: PPUSH
10511: CALL 24724 0 5
// veh := CreateVehicle ;
10515: LD_ADDR_VAR 0 6
10519: PUSH
10520: CALL_OW 45
10524: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10525: LD_VAR 0 6
10529: PPUSH
10530: LD_INT 19
10532: PPUSH
10533: LD_INT 0
10535: PPUSH
10536: CALL 56094 0 3
// if GetControl ( veh ) = control_manual then
10540: LD_VAR 0 6
10544: PPUSH
10545: CALL_OW 263
10549: PUSH
10550: LD_INT 1
10552: EQUAL
10553: IFFALSE 10599
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10555: LD_INT 0
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_INT 7
10563: PUSH
10564: LD_INT 6
10566: PUSH
10567: LD_INT 5
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: LIST
10574: PUSH
10575: LD_OWVAR 67
10579: ARRAY
10580: PPUSH
10581: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10585: CALL_OW 44
10589: PPUSH
10590: LD_VAR 0 6
10594: PPUSH
10595: CALL_OW 52
// end ; end ;
10599: GO 10493
10601: POP
10602: POP
// end ;
10603: LD_VAR 0 1
10607: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10608: LD_INT 0
10610: PPUSH
10611: PPUSH
10612: PPUSH
10613: PPUSH
10614: PPUSH
// uc_side := 8 ;
10615: LD_ADDR_OWVAR 20
10619: PUSH
10620: LD_INT 8
10622: ST_TO_ADDR
// uc_nation := nation_arabian ;
10623: LD_ADDR_OWVAR 21
10627: PUSH
10628: LD_INT 2
10630: ST_TO_ADDR
// for i = 1 to 2 do
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: DOUBLE
10637: LD_INT 1
10639: DEC
10640: ST_TO_ADDR
10641: LD_INT 2
10643: PUSH
10644: FOR_TO
10645: IFFALSE 10725
// for j = 1 to 4 do
10647: LD_ADDR_VAR 0 4
10651: PUSH
10652: DOUBLE
10653: LD_INT 1
10655: DEC
10656: ST_TO_ADDR
10657: LD_INT 4
10659: PUSH
10660: FOR_TO
10661: IFFALSE 10721
// begin PrepareHuman ( false , j , 8 ) ;
10663: LD_INT 0
10665: PPUSH
10666: LD_VAR 0 4
10670: PPUSH
10671: LD_INT 8
10673: PPUSH
10674: CALL_OW 380
// un := CreateHuman ;
10678: LD_ADDR_VAR 0 3
10682: PUSH
10683: CALL_OW 44
10687: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10688: LD_VAR 0 3
10692: PPUSH
10693: LD_INT 23
10695: PPUSH
10696: LD_INT 0
10698: PPUSH
10699: CALL_OW 49
// tmp := tmp union un ;
10703: LD_ADDR_VAR 0 5
10707: PUSH
10708: LD_VAR 0 5
10712: PUSH
10713: LD_VAR 0 3
10717: UNION
10718: ST_TO_ADDR
// end ;
10719: GO 10660
10721: POP
10722: POP
10723: GO 10644
10725: POP
10726: POP
// for i in tmp do
10727: LD_ADDR_VAR 0 2
10731: PUSH
10732: LD_VAR 0 5
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10757
// ComMoveXY ( i , 150 , 136 ) ;
10740: LD_VAR 0 2
10744: PPUSH
10745: LD_INT 150
10747: PPUSH
10748: LD_INT 136
10750: PPUSH
10751: CALL_OW 111
10755: GO 10737
10757: POP
10758: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10759: LD_ADDR_EXP 31
10763: PUSH
10764: LD_EXP 31
10768: PPUSH
10769: LD_EXP 6
10773: PPUSH
10774: LD_EXP 31
10778: PUSH
10779: LD_EXP 6
10783: ARRAY
10784: PUSH
10785: LD_VAR 0 5
10789: UNION
10790: PPUSH
10791: CALL_OW 1
10795: ST_TO_ADDR
// end ;
10796: LD_VAR 0 1
10800: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10801: LD_OWVAR 67
10805: PUSH
10806: LD_INT 1
10808: GREATER
10809: PUSH
10810: LD_INT 31
10812: PPUSH
10813: LD_INT 3
10815: PPUSH
10816: CALL_OW 321
10820: PUSH
10821: LD_INT 2
10823: EQUAL
10824: AND
10825: IFFALSE 11042
10827: GO 10829
10829: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10830: LD_EXP 7
10834: PPUSH
10835: LD_INT 33
10837: PUSH
10838: LD_INT 101
10840: PUSH
10841: LD_INT 159
10843: PUSH
10844: LD_INT 5
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 33
10855: PUSH
10856: LD_INT 105
10858: PUSH
10859: LD_INT 158
10861: PUSH
10862: LD_INT 5
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 33
10873: PUSH
10874: LD_INT 96
10876: PUSH
10877: LD_INT 136
10879: PUSH
10880: LD_INT 5
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PUSH
10889: LD_INT 33
10891: PUSH
10892: LD_INT 94
10894: PUSH
10895: LD_INT 133
10897: PUSH
10898: LD_INT 4
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: LD_INT 33
10909: PUSH
10910: LD_INT 84
10912: PUSH
10913: LD_INT 102
10915: PUSH
10916: LD_INT 4
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PPUSH
10932: CALL 85408 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10936: LD_EXP 8
10940: PPUSH
10941: LD_INT 33
10943: PUSH
10944: LD_INT 50
10946: PUSH
10947: LD_INT 17
10949: PUSH
10950: LD_INT 4
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: PUSH
10959: LD_INT 33
10961: PUSH
10962: LD_INT 52
10964: PUSH
10965: LD_INT 20
10967: PUSH
10968: LD_INT 4
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 33
10979: PUSH
10980: LD_INT 53
10982: PUSH
10983: LD_INT 23
10985: PUSH
10986: LD_INT 4
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 33
10997: PUSH
10998: LD_INT 45
11000: PUSH
11001: LD_INT 32
11003: PUSH
11004: LD_INT 4
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: LIST
11011: LIST
11012: PUSH
11013: LD_INT 33
11015: PUSH
11016: LD_INT 45
11018: PUSH
11019: LD_INT 39
11021: PUSH
11022: LD_INT 4
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL 85408 0 2
// end ;
11042: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11043: LD_INT 3
11045: PUSH
11046: LD_INT 22
11048: PUSH
11049: LD_OWVAR 2
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PUSH
11062: LD_INT 33
11064: PUSH
11065: LD_INT 2
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: LD_INT 50
11074: PUSH
11075: EMPTY
11076: LIST
11077: PUSH
11078: LD_INT 3
11080: PUSH
11081: LD_INT 61
11083: PUSH
11084: EMPTY
11085: LIST
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PUSH
11091: EMPTY
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: PPUSH
11097: CALL_OW 69
11101: IFFALSE 11201
11103: GO 11105
11105: DISABLE
11106: LD_INT 0
11108: PPUSH
11109: PPUSH
// begin enable ;
11110: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11111: LD_ADDR_VAR 0 2
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 22
11121: PUSH
11122: LD_OWVAR 2
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 33
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 50
11147: PUSH
11148: EMPTY
11149: LIST
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: LD_INT 61
11156: PUSH
11157: EMPTY
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: PPUSH
11170: CALL_OW 69
11174: ST_TO_ADDR
// for i in tmp do
11175: LD_ADDR_VAR 0 1
11179: PUSH
11180: LD_VAR 0 2
11184: PUSH
11185: FOR_IN
11186: IFFALSE 11199
// Connect ( i ) ;
11188: LD_VAR 0 1
11192: PPUSH
11193: CALL 27815 0 1
11197: GO 11185
11199: POP
11200: POP
// end ; end_of_file
11201: PPOPN 2
11203: END
// export function Action ; var i , tmp ; begin
11204: LD_INT 0
11206: PPUSH
11207: PPUSH
11208: PPUSH
// InGameOn ;
11209: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11213: LD_INT 225
11215: PPUSH
11216: LD_INT 217
11218: PPUSH
11219: CALL_OW 86
// for i in playerForces [ 2 ] do
11223: LD_ADDR_VAR 0 2
11227: PUSH
11228: LD_EXP 10
11232: PUSH
11233: LD_INT 2
11235: ARRAY
11236: PUSH
11237: FOR_IN
11238: IFFALSE 11371
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11240: LD_EXP 10
11244: PUSH
11245: LD_INT 1
11247: ARRAY
11248: PUSH
11249: LD_VAR 0 2
11253: PPUSH
11254: CALL_OW 257
11258: PUSH
11259: LD_INT 3
11261: PUSH
11262: LD_INT 4
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: IN
11269: AND
11270: IFFALSE 11354
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11272: LD_EXP 10
11276: PUSH
11277: LD_INT 1
11279: ARRAY
11280: PUSH
11281: LD_INT 1
11283: ARRAY
11284: PPUSH
11285: LD_INT 19
11287: PPUSH
11288: LD_INT 0
11290: PPUSH
11291: CALL 56094 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11295: LD_VAR 0 2
11299: PPUSH
11300: LD_EXP 10
11304: PUSH
11305: LD_INT 1
11307: ARRAY
11308: PUSH
11309: LD_INT 1
11311: ARRAY
11312: PPUSH
11313: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11317: LD_ADDR_EXP 10
11321: PUSH
11322: LD_EXP 10
11326: PPUSH
11327: LD_INT 1
11329: PPUSH
11330: LD_EXP 10
11334: PUSH
11335: LD_INT 1
11337: ARRAY
11338: PPUSH
11339: LD_INT 1
11341: PPUSH
11342: CALL_OW 3
11346: PPUSH
11347: CALL_OW 1
11351: ST_TO_ADDR
// end else
11352: GO 11369
// PlaceUnitInArea ( i , startArea , false ) ;
11354: LD_VAR 0 2
11358: PPUSH
11359: LD_INT 19
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL 56094 0 3
// end ;
11369: GO 11237
11371: POP
11372: POP
// wait ( 0 0$2 ) ;
11373: LD_INT 70
11375: PPUSH
11376: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11380: LD_EXP 9
11384: PPUSH
11385: LD_STRING D
11387: PUSH
11388: LD_STRING I
11390: PUSH
11391: LD_STRING J
11393: PUSH
11394: LD_STRING S
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: LIST
11401: PUSH
11402: LD_EXP 25
11406: ARRAY
11407: STR
11408: PUSH
11409: LD_STRING -1
11411: STR
11412: PPUSH
11413: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11417: LD_EXP 12
11421: PPUSH
11422: LD_STRING DP-1
11424: PPUSH
11425: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11429: LD_EXP 12
11433: PPUSH
11434: LD_STRING DP-2
11436: PPUSH
11437: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11441: LD_EXP 9
11445: PPUSH
11446: LD_STRING D
11448: PUSH
11449: LD_STRING I
11451: PUSH
11452: LD_STRING J
11454: PUSH
11455: LD_STRING S
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: PUSH
11463: LD_EXP 25
11467: ARRAY
11468: STR
11469: PUSH
11470: LD_STRING -2
11472: STR
11473: PPUSH
11474: CALL_OW 88
// InGameOff ;
11478: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11482: LD_STRING O1
11484: PPUSH
11485: CALL_OW 337
// game := true ;
11489: LD_ADDR_EXP 3
11493: PUSH
11494: LD_INT 1
11496: ST_TO_ADDR
// SaveForQuickRestart ;
11497: CALL_OW 22
// wait ( 0 0$5 ) ;
11501: LD_INT 175
11503: PPUSH
11504: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11508: LD_EXP 9
11512: PPUSH
11513: LD_STRING D
11515: PUSH
11516: LD_STRING I
11518: PUSH
11519: LD_STRING J
11521: PUSH
11522: LD_STRING S
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: LIST
11529: PUSH
11530: LD_EXP 25
11534: ARRAY
11535: STR
11536: PUSH
11537: LD_STRING -3
11539: STR
11540: PPUSH
11541: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11545: LD_INT 35
11547: PPUSH
11548: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11552: LD_EXP 15
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PUSH
11561: LD_EXP 15
11565: PUSH
11566: LD_INT 2
11568: ARRAY
11569: GREATEREQUAL
11570: IFFALSE 11545
// outpostEscape := true ;
11572: LD_ADDR_EXP 27
11576: PUSH
11577: LD_INT 1
11579: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11580: LD_ADDR_VAR 0 3
11584: PUSH
11585: LD_EXP 14
11589: PPUSH
11590: LD_INT 26
11592: PUSH
11593: LD_INT 1
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PPUSH
11600: CALL_OW 72
11604: ST_TO_ADDR
// if tmp then
11605: LD_VAR 0 3
11609: IFFALSE 11627
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11611: LD_VAR 0 3
11615: PUSH
11616: LD_INT 1
11618: ARRAY
11619: PPUSH
11620: LD_STRING DR-1-Escape
11622: PPUSH
11623: CALL_OW 88
// wait ( 0 0$1 ) ;
11627: LD_INT 35
11629: PPUSH
11630: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11634: LD_EXP 9
11638: PPUSH
11639: LD_STRING D
11641: PUSH
11642: LD_STRING I
11644: PUSH
11645: LD_STRING J
11647: PUSH
11648: LD_STRING S
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: LIST
11655: PUSH
11656: LD_EXP 25
11660: ARRAY
11661: STR
11662: PUSH
11663: LD_STRING -1-Escape
11665: STR
11666: PPUSH
11667: CALL_OW 88
// for i in ruOutpost do
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_EXP 14
11680: PUSH
11681: FOR_IN
11682: IFFALSE 11736
// begin if IsInUnit ( i ) then
11684: LD_VAR 0 2
11688: PPUSH
11689: CALL_OW 310
11693: IFFALSE 11704
// ComExitBuilding ( i ) ;
11695: LD_VAR 0 2
11699: PPUSH
11700: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11704: LD_VAR 0 2
11708: PPUSH
11709: LD_INT 179
11711: PPUSH
11712: LD_INT 102
11714: PPUSH
11715: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11719: LD_VAR 0 2
11723: PPUSH
11724: LD_INT 28
11726: PPUSH
11727: LD_INT 20
11729: PPUSH
11730: CALL_OW 171
// end ;
11734: GO 11681
11736: POP
11737: POP
// tmp := [ ] ;
11738: LD_ADDR_VAR 0 3
11742: PUSH
11743: EMPTY
11744: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11745: LD_INT 35
11747: PPUSH
11748: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11752: LD_ADDR_VAR 0 3
11756: PUSH
11757: LD_EXP 14
11761: PPUSH
11762: LD_INT 95
11764: PUSH
11765: LD_INT 11
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PPUSH
11772: CALL_OW 72
11776: ST_TO_ADDR
// if tmp then
11777: LD_VAR 0 3
11781: IFFALSE 11860
// for i in tmp do
11783: LD_ADDR_VAR 0 2
11787: PUSH
11788: LD_VAR 0 3
11792: PUSH
11793: FOR_IN
11794: IFFALSE 11858
// begin ruOutpost := ruOutpost diff i ;
11796: LD_ADDR_EXP 14
11800: PUSH
11801: LD_EXP 14
11805: PUSH
11806: LD_VAR 0 2
11810: DIFF
11811: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11812: LD_ADDR_EXP 31
11816: PUSH
11817: LD_EXP 31
11821: PPUSH
11822: LD_EXP 8
11826: PUSH
11827: LD_EXP 31
11831: PUSH
11832: LD_EXP 8
11836: ARRAY
11837: PUSH
11838: LD_INT 1
11840: PLUS
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: PPUSH
11846: LD_VAR 0 2
11850: PPUSH
11851: CALL 24846 0 3
11855: ST_TO_ADDR
// end ;
11856: GO 11793
11858: POP
11859: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11860: LD_EXP 14
11864: PPUSH
11865: LD_INT 21
11867: PUSH
11868: LD_INT 1
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: PPUSH
11875: CALL_OW 72
11879: NOT
11880: IFFALSE 11745
// ruOutpost := [ ] ;
11882: LD_ADDR_EXP 14
11886: PUSH
11887: EMPTY
11888: ST_TO_ADDR
// end ;
11889: LD_VAR 0 1
11893: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11894: LD_EXP 27
11898: IFFALSE 12087
11900: GO 11902
11902: DISABLE
11903: LD_INT 0
11905: PPUSH
11906: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11907: LD_INT 875
11909: PPUSH
11910: LD_INT 1225
11912: PPUSH
11913: CALL_OW 12
11917: PPUSH
11918: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11922: LD_ADDR_VAR 0 2
11926: PUSH
11927: LD_INT 208
11929: PUSH
11930: LD_INT 166
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: PUSH
11937: LD_INT 218
11939: PUSH
11940: LD_INT 174
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 201
11949: PUSH
11950: LD_INT 173
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 189
11959: PUSH
11960: LD_INT 167
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 191
11969: PUSH
11970: LD_INT 160
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 209
11979: PUSH
11980: LD_INT 181
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 192
11989: PUSH
11990: LD_INT 162
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: LD_INT 197
11999: PUSH
12000: LD_INT 166
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
12017: LD_ADDR_VAR 0 1
12021: PUSH
12022: DOUBLE
12023: LD_INT 1
12025: DEC
12026: ST_TO_ADDR
12027: LD_INT 5
12029: PUSH
12030: LD_OWVAR 67
12034: PLUS
12035: PUSH
12036: FOR_TO
12037: IFFALSE 12085
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12039: LD_VAR 0 2
12043: PUSH
12044: LD_VAR 0 1
12048: ARRAY
12049: PUSH
12050: LD_INT 1
12052: ARRAY
12053: PPUSH
12054: LD_VAR 0 2
12058: PUSH
12059: LD_VAR 0 1
12063: ARRAY
12064: PUSH
12065: LD_INT 2
12067: ARRAY
12068: PPUSH
12069: LD_INT 1
12071: PPUSH
12072: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12076: LD_INT 28
12078: PPUSH
12079: CALL_OW 67
// end ;
12083: GO 12036
12085: POP
12086: POP
// end ;
12087: PPOPN 2
12089: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12090: LD_EXP 27
12094: NOT
12095: IFFALSE 12749
12097: GO 12099
12099: DISABLE
12100: LD_INT 0
12102: PPUSH
12103: PPUSH
12104: PPUSH
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// begin enable ;
12109: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12110: LD_ADDR_VAR 0 1
12114: PUSH
12115: LD_EXP 14
12119: PPUSH
12120: LD_INT 22
12122: PUSH
12123: LD_INT 3
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 25
12132: PUSH
12133: LD_INT 1
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PPUSH
12144: CALL_OW 72
12148: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12149: LD_ADDR_VAR 0 2
12153: PUSH
12154: LD_EXP 14
12158: PPUSH
12159: LD_INT 22
12161: PUSH
12162: LD_INT 3
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 25
12171: PUSH
12172: LD_INT 2
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 72
12187: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12188: LD_ADDR_VAR 0 3
12192: PUSH
12193: LD_EXP 14
12197: PPUSH
12198: LD_INT 22
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 21
12210: PUSH
12211: LD_INT 3
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 3
12220: PUSH
12221: LD_INT 24
12223: PUSH
12224: LD_INT 1000
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: LIST
12239: PPUSH
12240: CALL_OW 72
12244: ST_TO_ADDR
// if engs and buildings then
12245: LD_VAR 0 2
12249: PUSH
12250: LD_VAR 0 3
12254: AND
12255: IFFALSE 12328
// begin for i in engs do
12257: LD_ADDR_VAR 0 5
12261: PUSH
12262: LD_VAR 0 2
12266: PUSH
12267: FOR_IN
12268: IFFALSE 12324
// if IsInUnit ( i ) then
12270: LD_VAR 0 5
12274: PPUSH
12275: CALL_OW 310
12279: IFFALSE 12292
// ComExitBuilding ( i ) else
12281: LD_VAR 0 5
12285: PPUSH
12286: CALL_OW 122
12290: GO 12322
// if not HasTask ( i ) then
12292: LD_VAR 0 5
12296: PPUSH
12297: CALL_OW 314
12301: NOT
12302: IFFALSE 12322
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12304: LD_VAR 0 5
12308: PPUSH
12309: LD_VAR 0 3
12313: PUSH
12314: LD_INT 1
12316: ARRAY
12317: PPUSH
12318: CALL_OW 130
12322: GO 12267
12324: POP
12325: POP
// end else
12326: GO 12431
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12328: LD_VAR 0 3
12332: NOT
12333: PUSH
12334: LD_EXP 14
12338: PPUSH
12339: LD_INT 30
12341: PUSH
12342: LD_INT 0
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL_OW 72
12353: AND
12354: PUSH
12355: LD_VAR 0 2
12359: PPUSH
12360: LD_INT 3
12362: PUSH
12363: LD_INT 54
12365: PUSH
12366: EMPTY
12367: LIST
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 72
12377: AND
12378: IFFALSE 12431
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12380: LD_VAR 0 2
12384: PPUSH
12385: LD_INT 3
12387: PUSH
12388: LD_INT 54
12390: PUSH
12391: EMPTY
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 72
12402: PPUSH
12403: LD_EXP 14
12407: PPUSH
12408: LD_INT 30
12410: PUSH
12411: LD_INT 0
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PPUSH
12418: CALL_OW 72
12422: PUSH
12423: LD_INT 1
12425: ARRAY
12426: PPUSH
12427: CALL_OW 120
// if not tmp then
12431: LD_VAR 0 1
12435: NOT
12436: IFFALSE 12440
// exit ;
12438: GO 12749
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12440: LD_INT 26
12442: PPUSH
12443: LD_INT 81
12445: PUSH
12446: LD_INT 3
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PPUSH
12453: CALL_OW 70
12457: PUSH
12458: LD_INT 1
12460: GREATER
12461: IFFALSE 12517
// begin for i in tmp do
12463: LD_ADDR_VAR 0 5
12467: PUSH
12468: LD_VAR 0 1
12472: PUSH
12473: FOR_IN
12474: IFFALSE 12513
// begin if IsInUnit ( i ) then
12476: LD_VAR 0 5
12480: PPUSH
12481: CALL_OW 310
12485: IFFALSE 12496
// ComExitBuilding ( i ) ;
12487: LD_VAR 0 5
12491: PPUSH
12492: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12496: LD_VAR 0 5
12500: PPUSH
12501: LD_INT 204
12503: PPUSH
12504: LD_INT 164
12506: PPUSH
12507: CALL_OW 174
// end ;
12511: GO 12473
12513: POP
12514: POP
// end else
12515: GO 12749
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 3
12524: PUSH
12525: LD_INT 54
12527: PUSH
12528: EMPTY
12529: LIST
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL_OW 72
12539: IFFALSE 12749
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12541: LD_ADDR_VAR 0 4
12545: PUSH
12546: LD_EXP 14
12550: PPUSH
12551: LD_INT 30
12553: PUSH
12554: LD_INT 32
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 58
12563: PUSH
12564: EMPTY
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PPUSH
12571: CALL_OW 72
12575: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12576: LD_VAR 0 4
12580: NOT
12581: PUSH
12582: LD_EXP 14
12586: PPUSH
12587: LD_INT 30
12589: PUSH
12590: LD_INT 5
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: PPUSH
12597: CALL_OW 72
12601: AND
12602: IFFALSE 12639
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: LD_EXP 14
12613: PPUSH
12614: LD_INT 30
12616: PUSH
12617: LD_INT 5
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PPUSH
12624: CALL_OW 72
12628: PUSH
12629: LD_INT 1
12631: ARRAY
12632: PPUSH
12633: CALL_OW 120
// exit ;
12637: GO 12749
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12639: LD_ADDR_VAR 0 6
12643: PUSH
12644: LD_VAR 0 1
12648: PPUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 54
12654: PUSH
12655: EMPTY
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 72
12666: ST_TO_ADDR
// if j < empty then
12667: LD_VAR 0 6
12671: PUSH
12672: LD_VAR 0 4
12676: LESS
12677: IFFALSE 12691
// k := j else
12679: LD_ADDR_VAR 0 7
12683: PUSH
12684: LD_VAR 0 6
12688: ST_TO_ADDR
12689: GO 12701
// k := empty ;
12691: LD_ADDR_VAR 0 7
12695: PUSH
12696: LD_VAR 0 4
12700: ST_TO_ADDR
// for i = 1 to k do
12701: LD_ADDR_VAR 0 5
12705: PUSH
12706: DOUBLE
12707: LD_INT 1
12709: DEC
12710: ST_TO_ADDR
12711: LD_VAR 0 7
12715: PUSH
12716: FOR_TO
12717: IFFALSE 12747
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12719: LD_VAR 0 6
12723: PUSH
12724: LD_VAR 0 5
12728: ARRAY
12729: PPUSH
12730: LD_VAR 0 4
12734: PUSH
12735: LD_VAR 0 5
12739: ARRAY
12740: PPUSH
12741: CALL_OW 120
12745: GO 12716
12747: POP
12748: POP
// end ; end ;
12749: PPOPN 7
12751: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12752: LD_EXP 2
12756: PUSH
12757: LD_INT 1
12759: EQUAL
12760: PUSH
12761: LD_EXP 27
12765: AND
12766: PUSH
12767: LD_INT 22
12769: PUSH
12770: LD_INT 1
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 92
12779: PUSH
12780: LD_INT 208
12782: PUSH
12783: LD_INT 163
12785: PUSH
12786: LD_INT 8
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: AND
12804: PUSH
12805: LD_INT 22
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: LD_INT 21
12817: PUSH
12818: LD_INT 1
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 92
12827: PUSH
12828: LD_INT 208
12830: PUSH
12831: LD_INT 163
12833: PUSH
12834: LD_INT 14
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL_OW 69
12852: NOT
12853: AND
12854: IFFALSE 13159
12856: GO 12858
12858: DISABLE
12859: LD_INT 0
12861: PPUSH
// begin InGameOn ;
12862: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12866: LD_EXP 9
12870: PPUSH
12871: CALL_OW 87
// wait ( 0 0$1 ) ;
12875: LD_INT 35
12877: PPUSH
12878: CALL_OW 67
// DialogueOn ;
12882: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12886: LD_EXP 9
12890: PPUSH
12891: LD_STRING D
12893: PUSH
12894: LD_STRING I
12896: PUSH
12897: LD_STRING J
12899: PUSH
12900: LD_STRING S
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: LIST
12907: PUSH
12908: LD_EXP 25
12912: ARRAY
12913: STR
12914: PUSH
12915: LD_STRING -1-BaseCaptured
12917: STR
12918: PPUSH
12919: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12923: LD_EXP 12
12927: PPUSH
12928: LD_STRING DP-1-BaseCaptured
12930: PPUSH
12931: CALL_OW 94
// if sibBombAllowed then
12935: LD_EXP 23
12939: IFFALSE 13081
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12941: LD_EXP 9
12945: PPUSH
12946: LD_STRING D
12948: PUSH
12949: LD_STRING I
12951: PUSH
12952: LD_STRING J
12954: PUSH
12955: LD_STRING S
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: PUSH
12963: LD_EXP 25
12967: ARRAY
12968: STR
12969: PUSH
12970: LD_STRING -2-BaseCaptured
12972: STR
12973: PPUSH
12974: CALL_OW 88
// if commander = 1 then
12978: LD_EXP 25
12982: PUSH
12983: LD_INT 1
12985: EQUAL
12986: IFFALSE 13000
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12988: LD_EXP 12
12992: PPUSH
12993: LD_STRING DP-2b-BaseCaptured
12995: PPUSH
12996: CALL_OW 94
// if commander = 2 then
13000: LD_EXP 25
13004: PUSH
13005: LD_INT 2
13007: EQUAL
13008: IFFALSE 13022
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
13010: LD_EXP 12
13014: PPUSH
13015: LD_STRING DP-2-BaseCaptured
13017: PPUSH
13018: CALL_OW 94
// if commander = 3 then
13022: LD_EXP 25
13026: PUSH
13027: LD_INT 3
13029: EQUAL
13030: IFFALSE 13044
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13032: LD_EXP 12
13036: PPUSH
13037: LD_STRING DP-2a-BaseCaptured
13039: PPUSH
13040: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13044: LD_EXP 9
13048: PPUSH
13049: LD_STRING D
13051: PUSH
13052: LD_STRING I
13054: PUSH
13055: LD_STRING J
13057: PUSH
13058: LD_STRING S
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: LIST
13065: PUSH
13066: LD_EXP 25
13070: ARRAY
13071: STR
13072: PUSH
13073: LD_STRING -3-BaseCaptured
13075: STR
13076: PPUSH
13077: CALL_OW 88
// end ; DialogueOff ;
13081: CALL_OW 7
// InGameOff ;
13085: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13089: LD_STRING O2
13091: PPUSH
13092: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13096: LD_ADDR_VAR 0 1
13100: PUSH
13101: LD_EXP 14
13105: PPUSH
13106: LD_INT 21
13108: PUSH
13109: LD_INT 3
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PPUSH
13116: CALL_OW 72
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13138
// SetSide ( i , 1 ) ;
13124: LD_VAR 0 1
13128: PPUSH
13129: LD_INT 1
13131: PPUSH
13132: CALL_OW 235
13136: GO 13121
13138: POP
13139: POP
// baseCaptured := true ;
13140: LD_ADDR_EXP 17
13144: PUSH
13145: LD_INT 1
13147: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13148: LD_INT 1225
13150: PPUSH
13151: CALL_OW 67
// PrepareReinforcements ;
13155: CALL 9908 0 0
// end ;
13159: PPOPN 1
13161: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13162: LD_INT 22
13164: PUSH
13165: LD_INT 3
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 92
13174: PUSH
13175: LD_INT 167
13177: PUSH
13178: LD_INT 197
13180: PUSH
13181: LD_INT 20
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 69
13198: PUSH
13199: LD_INT 3
13201: GREATER
13202: IFFALSE 13219
13204: GO 13206
13206: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13207: LD_EXP 12
13211: PPUSH
13212: LD_STRING DP-RuAttack
13214: PPUSH
13215: CALL_OW 94
13219: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13220: LD_EXP 1
13224: NOT
13225: PUSH
13226: LD_INT 1
13228: PPUSH
13229: LD_INT 168
13231: PPUSH
13232: LD_INT 74
13234: PPUSH
13235: CALL_OW 293
13239: AND
13240: PUSH
13241: LD_INT 168
13243: PPUSH
13244: LD_INT 72
13246: PPUSH
13247: CALL_OW 553
13251: AND
13252: IFFALSE 13304
13254: GO 13256
13256: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13257: LD_INT 168
13259: PPUSH
13260: LD_INT 72
13262: PPUSH
13263: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13267: LD_EXP 9
13271: PPUSH
13272: LD_STRING D
13274: PUSH
13275: LD_STRING I
13277: PUSH
13278: LD_STRING J
13280: PUSH
13281: LD_STRING S
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_EXP 25
13293: ARRAY
13294: STR
13295: PUSH
13296: LD_STRING -1-Blockade
13298: STR
13299: PPUSH
13300: CALL_OW 88
// end ;
13304: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13305: LD_EXP 2
13309: PUSH
13310: LD_INT 1
13312: EQUAL
13313: PUSH
13314: LD_INT 22
13316: PUSH
13317: LD_INT 1
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: LD_INT 101
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: AND
13343: IFFALSE 13875
13345: GO 13347
13347: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13348: LD_INT 4
13350: PPUSH
13351: LD_INT 1
13353: PPUSH
13354: CALL_OW 343
// DialogueOn ;
13358: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13362: LD_EXP 11
13366: PPUSH
13367: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13371: LD_EXP 11
13375: PPUSH
13376: LD_STRING DM-1-Contact
13378: PPUSH
13379: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13383: LD_EXP 9
13387: PPUSH
13388: LD_STRING D
13390: PUSH
13391: LD_STRING I
13393: PUSH
13394: LD_STRING J
13396: PUSH
13397: LD_STRING S
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: LIST
13404: PUSH
13405: LD_EXP 25
13409: ARRAY
13410: STR
13411: PUSH
13412: LD_STRING -1-Contact
13414: STR
13415: PPUSH
13416: CALL_OW 88
// if commander = 1 then
13420: LD_EXP 25
13424: PUSH
13425: LD_INT 1
13427: EQUAL
13428: IFFALSE 13560
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13430: LD_EXP 11
13434: PPUSH
13435: LD_STRING DM-2-Contact
13437: PPUSH
13438: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13442: LD_EXP 9
13446: PPUSH
13447: LD_STRING DI-2-Contact
13449: PPUSH
13450: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13454: LD_INT 22
13456: PUSH
13457: LD_INT 8
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 21
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PPUSH
13478: CALL_OW 69
13482: PUSH
13483: LD_INT 8
13485: PPUSH
13486: LD_INT 1
13488: PPUSH
13489: CALL_OW 81
13493: PUSH
13494: LD_INT 2
13496: EQUAL
13497: AND
13498: IFFALSE 13524
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13500: LD_EXP 11
13504: PPUSH
13505: LD_STRING DM-3-Contact
13507: PPUSH
13508: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13512: LD_EXP 9
13516: PPUSH
13517: LD_STRING DI-3-Contact
13519: PPUSH
13520: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13524: LD_EXP 11
13528: PPUSH
13529: LD_STRING DM-4-Contact
13531: PPUSH
13532: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13536: LD_EXP 9
13540: PPUSH
13541: LD_STRING DI-4-Contact
13543: PPUSH
13544: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13548: LD_EXP 11
13552: PPUSH
13553: LD_STRING DM-5-Contact
13555: PPUSH
13556: CALL_OW 94
// end ; if commander = 2 then
13560: LD_EXP 25
13564: PUSH
13565: LD_INT 2
13567: EQUAL
13568: IFFALSE 13700
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13570: LD_EXP 11
13574: PPUSH
13575: LD_STRING DM-2c-Contact
13577: PPUSH
13578: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13582: LD_EXP 9
13586: PPUSH
13587: LD_STRING DJ-2-Contact
13589: PPUSH
13590: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13594: LD_INT 22
13596: PUSH
13597: LD_INT 8
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: LD_INT 21
13606: PUSH
13607: LD_INT 1
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PPUSH
13618: CALL_OW 69
13622: PUSH
13623: LD_INT 8
13625: PPUSH
13626: LD_INT 1
13628: PPUSH
13629: CALL_OW 81
13633: PUSH
13634: LD_INT 2
13636: EQUAL
13637: AND
13638: IFFALSE 13664
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13640: LD_EXP 11
13644: PPUSH
13645: LD_STRING DM-3-Contact
13647: PPUSH
13648: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13652: LD_EXP 9
13656: PPUSH
13657: LD_STRING DJ-3-Contact
13659: PPUSH
13660: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13664: LD_EXP 11
13668: PPUSH
13669: LD_STRING DM-4-Contact
13671: PPUSH
13672: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13676: LD_EXP 9
13680: PPUSH
13681: LD_STRING DJ-4-Contact
13683: PPUSH
13684: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13688: LD_EXP 11
13692: PPUSH
13693: LD_STRING DM-5a-Contact
13695: PPUSH
13696: CALL_OW 94
// end ; if commander = 3 then
13700: LD_EXP 25
13704: PUSH
13705: LD_INT 3
13707: EQUAL
13708: IFFALSE 13864
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13710: LD_EXP 11
13714: PPUSH
13715: LD_STRING DM-2a-Contact
13717: PPUSH
13718: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13722: LD_EXP 9
13726: PPUSH
13727: LD_STRING DS-2a-Contact
13729: PPUSH
13730: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13734: LD_EXP 11
13738: PPUSH
13739: LD_STRING DM-2b-Contact
13741: PPUSH
13742: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13746: LD_EXP 9
13750: PPUSH
13751: LD_STRING DS-2b-Contact
13753: PPUSH
13754: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13758: LD_INT 22
13760: PUSH
13761: LD_INT 8
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PUSH
13768: LD_INT 21
13770: PUSH
13771: LD_INT 1
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_INT 8
13789: PPUSH
13790: LD_INT 1
13792: PPUSH
13793: CALL_OW 81
13797: PUSH
13798: LD_INT 2
13800: EQUAL
13801: AND
13802: IFFALSE 13828
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13804: LD_EXP 11
13808: PPUSH
13809: LD_STRING DM-3-Contact
13811: PPUSH
13812: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13816: LD_EXP 9
13820: PPUSH
13821: LD_STRING DS-3-Contact
13823: PPUSH
13824: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13828: LD_EXP 11
13832: PPUSH
13833: LD_STRING DM-4-Contact
13835: PPUSH
13836: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13840: LD_EXP 9
13844: PPUSH
13845: LD_STRING DS-4-Contact
13847: PPUSH
13848: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13852: LD_EXP 11
13856: PPUSH
13857: LD_STRING DM-5-Contact
13859: PPUSH
13860: CALL_OW 94
// end ; DialogueOff ;
13864: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13868: LD_STRING O3
13870: PPUSH
13871: CALL_OW 337
// end ;
13875: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13876: LD_EXP 2
13880: PUSH
13881: LD_INT 1
13883: EQUAL
13884: PUSH
13885: LD_EXP 18
13889: PUSH
13890: LD_INT 15
13892: PUSH
13893: LD_INT 20
13895: PUSH
13896: LD_INT 25
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: LIST
13903: PUSH
13904: LD_OWVAR 67
13908: ARRAY
13909: GREATEREQUAL
13910: AND
13911: PUSH
13912: LD_INT 22
13914: PUSH
13915: LD_INT 8
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: LD_INT 30
13924: PUSH
13925: LD_INT 1
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PPUSH
13936: CALL_OW 69
13940: AND
13941: PUSH
13942: LD_INT 22
13944: PUSH
13945: LD_INT 8
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 21
13954: PUSH
13955: LD_INT 3
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PPUSH
13966: CALL_OW 69
13970: PUSH
13971: LD_INT 5
13973: GREATEREQUAL
13974: AND
13975: IFFALSE 14498
13977: GO 13979
13979: DISABLE
13980: LD_INT 0
13982: PPUSH
13983: PPUSH
13984: PPUSH
13985: PPUSH
// begin DialogueOn ;
13986: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13990: LD_EXP 13
13994: PPUSH
13995: LD_STRING DF-1-Leg
13997: PPUSH
13998: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14002: LD_EXP 9
14006: PPUSH
14007: LD_STRING D
14009: PUSH
14010: LD_STRING I
14012: PUSH
14013: LD_STRING J
14015: PUSH
14016: LD_STRING S
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: LIST
14023: PUSH
14024: LD_EXP 25
14028: ARRAY
14029: STR
14030: PUSH
14031: LD_STRING -1-Leg
14033: STR
14034: PPUSH
14035: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14039: LD_EXP 13
14043: PPUSH
14044: LD_STRING DF-2-Leg
14046: PPUSH
14047: CALL_OW 94
// DialogueOff ;
14051: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14055: LD_STRING QLegionOffer
14057: PPUSH
14058: CALL_OW 97
14062: PUSH
14063: LD_INT 1
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14074
14071: POP
// ; 2 :
14072: GO 14088
14074: LD_INT 2
14076: DOUBLE
14077: EQUAL
14078: IFTRUE 14082
14080: GO 14087
14082: POP
// exit ; end ;
14083: GO 14498
14085: GO 14088
14087: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14088: LD_EXP 9
14092: PPUSH
14093: LD_STRING D
14095: PUSH
14096: LD_STRING I
14098: PUSH
14099: LD_STRING J
14101: PUSH
14102: LD_STRING S
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PUSH
14110: LD_EXP 25
14114: ARRAY
14115: STR
14116: PUSH
14117: LD_STRING -2-Leg
14119: STR
14120: PPUSH
14121: CALL_OW 88
// legOfferAccepted := true ;
14125: LD_ADDR_EXP 20
14129: PUSH
14130: LD_INT 1
14132: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14133: LD_INT 21
14135: PPUSH
14136: LD_INT 1
14138: PPUSH
14139: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14143: LD_INT 190
14145: PPUSH
14146: LD_INT 227
14148: PPUSH
14149: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14153: LD_ADDR_VAR 0 1
14157: PUSH
14158: LD_INT 16800
14160: PUSH
14161: LD_INT 14700
14163: PUSH
14164: LD_INT 12600
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: LIST
14171: PUSH
14172: LD_OWVAR 67
14176: ARRAY
14177: ST_TO_ADDR
// sib := 100 ;
14178: LD_ADDR_VAR 0 2
14182: PUSH
14183: LD_INT 100
14185: ST_TO_ADDR
// disableGlobalTimer := true ;
14186: LD_ADDR_EXP 4
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14194: LD_INT 35
14196: PPUSH
14197: CALL_OW 67
// time := time - 0 0$1 ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_VAR 0 1
14210: PUSH
14211: LD_INT 35
14213: MINUS
14214: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14215: LD_ADDR_VAR 0 3
14219: PUSH
14220: LD_INT 21
14222: PPUSH
14223: LD_INT 3
14225: PPUSH
14226: CALL_OW 287
14230: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14231: LD_ADDR_OWVAR 47
14235: PUSH
14236: LD_STRING #SkrTime
14238: PUSH
14239: LD_OWVAR 1
14243: PUSH
14244: LD_STRING #Skr-LegOffer
14246: PUSH
14247: LD_VAR 0 2
14251: PUSH
14252: LD_VAR 0 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: ST_TO_ADDR
// if sources then
14264: LD_VAR 0 3
14268: IFFALSE 14300
// begin sib := sib - sources * 10 ;
14270: LD_ADDR_VAR 0 2
14274: PUSH
14275: LD_VAR 0 2
14279: PUSH
14280: LD_VAR 0 3
14284: PUSH
14285: LD_INT 10
14287: MUL
14288: MINUS
14289: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14290: LD_INT 21
14292: PPUSH
14293: LD_INT 3
14295: PPUSH
14296: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14300: LD_VAR 0 1
14304: PUSH
14305: LD_INT 0
14307: EQUAL
14308: PUSH
14309: LD_VAR 0 2
14313: PUSH
14314: LD_INT 0
14316: LESSEQUAL
14317: OR
14318: PUSH
14319: LD_INT 22
14321: PUSH
14322: LD_INT 8
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PPUSH
14329: CALL_OW 69
14333: NOT
14334: OR
14335: IFFALSE 14194
// SetAreaMapShow ( legOfferArea , 0 ) ;
14337: LD_INT 21
14339: PPUSH
14340: LD_INT 0
14342: PPUSH
14343: CALL_OW 424
// disableGlobalTimer := false ;
14347: LD_ADDR_EXP 4
14351: PUSH
14352: LD_INT 0
14354: ST_TO_ADDR
// if sib <= 0 then
14355: LD_VAR 0 2
14359: PUSH
14360: LD_INT 0
14362: LESSEQUAL
14363: IFFALSE 14479
// begin legChangeSide := true ;
14365: LD_ADDR_EXP 21
14369: PUSH
14370: LD_INT 1
14372: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14373: LD_EXP 13
14377: PPUSH
14378: LD_STRING DF-4y-Leg
14380: PPUSH
14381: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14385: LD_STRING O3a
14387: PPUSH
14388: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14392: LD_INT 8
14394: PPUSH
14395: LD_INT 1
14397: PPUSH
14398: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14402: LD_INT 8
14404: PPUSH
14405: LD_INT 1
14407: PPUSH
14408: LD_INT 1
14410: PPUSH
14411: LD_INT 1
14413: PPUSH
14414: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14418: LD_INT 8
14420: PPUSH
14421: LD_INT 4
14423: PPUSH
14424: LD_INT 1
14426: PPUSH
14427: LD_INT 1
14429: PPUSH
14430: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14434: LD_INT 8
14436: PPUSH
14437: LD_INT 6
14439: PPUSH
14440: LD_INT 2
14442: PPUSH
14443: LD_INT 1
14445: PPUSH
14446: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14450: LD_INT 8
14452: PPUSH
14453: LD_INT 3
14455: PPUSH
14456: LD_INT 2
14458: PPUSH
14459: LD_INT 1
14461: PPUSH
14462: CALL_OW 80
// wait ( 0 0$30 ) ;
14466: LD_INT 1050
14468: PPUSH
14469: CALL_OW 67
// PrepareLegionReinforcements ;
14473: CALL 10608 0 0
// end else
14477: GO 14498
// begin ChangeMissionObjectives ( O3a ) ;
14479: LD_STRING O3a
14481: PPUSH
14482: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14486: LD_EXP 13
14490: PPUSH
14491: LD_STRING DF-4n-Leg
14493: PPUSH
14494: CALL_OW 94
// end ; end ;
14498: PPOPN 4
14500: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14501: LD_INT 22
14503: PUSH
14504: LD_INT 8
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PPUSH
14525: CALL_OW 69
14529: PUSH
14530: LD_INT 0
14532: EQUAL
14533: PUSH
14534: LD_INT 8
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: CALL_OW 81
14544: PUSH
14545: LD_INT 2
14547: EQUAL
14548: AND
14549: IFFALSE 14561
14551: GO 14553
14553: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14554: LD_STRING O3a
14556: PPUSH
14557: CALL_OW 337
14561: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14562: LD_EXP 2
14566: PUSH
14567: LD_INT 1
14569: EQUAL
14570: PUSH
14571: LD_EXP 3
14575: AND
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 1
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_INT 0
14608: EQUAL
14609: AND
14610: PUSH
14611: LD_INT 22
14613: PUSH
14614: LD_INT 3
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 30
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: PUSH
14640: LD_INT 0
14642: EQUAL
14643: AND
14644: IFFALSE 14882
14646: GO 14648
14648: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14649: LD_EXP 9
14653: PPUSH
14654: LD_STRING D
14656: PUSH
14657: LD_STRING I
14659: PUSH
14660: LD_STRING J
14662: PUSH
14663: LD_STRING S
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: PUSH
14671: LD_EXP 25
14675: ARRAY
14676: STR
14677: PUSH
14678: LD_STRING -1-Win
14680: STR
14681: PPUSH
14682: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14686: LD_OWVAR 1
14690: PUSH
14691: LD_INT 315000
14693: PUSH
14694: LD_INT 273000
14696: PUSH
14697: LD_INT 231000
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: LIST
14704: PUSH
14705: LD_OWVAR 67
14709: ARRAY
14710: GREATEREQUAL
14711: IFFALSE 14726
// AddMedal ( med1 , - 1 ) else
14713: LD_STRING med1
14715: PPUSH
14716: LD_INT 1
14718: NEG
14719: PPUSH
14720: CALL_OW 101
14724: GO 14736
// AddMedal ( med1 , 1 ) ;
14726: LD_STRING med1
14728: PPUSH
14729: LD_INT 1
14731: PPUSH
14732: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14736: LD_EXP 22
14740: PUSH
14741: LD_INT 20
14743: PUSH
14744: LD_INT 15
14746: PUSH
14747: LD_INT 10
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: LIST
14754: PUSH
14755: LD_OWVAR 67
14759: ARRAY
14760: GREATEREQUAL
14761: IFFALSE 14776
// AddMedal ( med2 , - 1 ) else
14763: LD_STRING med2
14765: PPUSH
14766: LD_INT 1
14768: NEG
14769: PPUSH
14770: CALL_OW 101
14774: GO 14786
// AddMedal ( med2 , 1 ) ;
14776: LD_STRING med2
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14786: LD_INT 8
14788: PPUSH
14789: LD_INT 1
14791: PPUSH
14792: CALL_OW 81
14796: PUSH
14797: LD_INT 1
14799: EQUAL
14800: IFFALSE 14814
// AddMedal ( med3 , 1 ) else
14802: LD_STRING med3
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL_OW 101
14812: GO 14871
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14814: LD_INT 22
14816: PUSH
14817: LD_INT 8
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: PUSH
14824: LD_INT 21
14826: PUSH
14827: LD_INT 1
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: PPUSH
14838: CALL_OW 69
14842: PUSH
14843: LD_INT 0
14845: EQUAL
14846: IFFALSE 14860
// AddMedal ( med3 , 2 ) else
14848: LD_STRING med3
14850: PPUSH
14851: LD_INT 2
14853: PPUSH
14854: CALL_OW 101
14858: GO 14871
// AddMedal ( med3 , - 1 ) ;
14860: LD_STRING med3
14862: PPUSH
14863: LD_INT 1
14865: NEG
14866: PPUSH
14867: CALL_OW 101
// GiveMedals ( MAIN ) ;
14871: LD_STRING MAIN
14873: PPUSH
14874: CALL_OW 102
// YouWin ;
14878: CALL_OW 103
// end ;
14882: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14883: LD_EXP 2
14887: PUSH
14888: LD_INT 1
14890: EQUAL
14891: PUSH
14892: LD_EXP 16
14896: AND
14897: PUSH
14898: LD_INT 20
14900: PPUSH
14901: LD_INT 81
14903: PUSH
14904: LD_INT 8
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PPUSH
14911: CALL_OW 70
14915: AND
14916: IFFALSE 15195
14918: GO 14920
14920: DISABLE
14921: LD_INT 0
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
14927: PPUSH
// begin enable ;
14928: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14929: LD_ADDR_VAR 0 3
14933: PUSH
14934: LD_INT 20
14936: PPUSH
14937: LD_INT 81
14939: PUSH
14940: LD_INT 8
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL_OW 70
14951: ST_TO_ADDR
// if not tmp then
14952: LD_VAR 0 3
14956: NOT
14957: IFFALSE 14961
// exit ;
14959: GO 15195
// for i in tmp do
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_VAR 0 3
14970: PUSH
14971: FOR_IN
14972: IFFALSE 15193
// begin x := GetX ( i ) ;
14974: LD_ADDR_VAR 0 4
14978: PUSH
14979: LD_VAR 0 1
14983: PPUSH
14984: CALL_OW 250
14988: ST_TO_ADDR
// y := GetY ( i ) ;
14989: LD_ADDR_VAR 0 5
14993: PUSH
14994: LD_VAR 0 1
14998: PPUSH
14999: CALL_OW 251
15003: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15004: LD_VAR 0 4
15008: PPUSH
15009: LD_VAR 0 5
15013: PPUSH
15014: CALL_OW 458
15018: IFFALSE 15191
// begin LaunchMineAtPos ( x , y , 8 ) ;
15020: LD_VAR 0 4
15024: PPUSH
15025: LD_VAR 0 5
15029: PPUSH
15030: LD_INT 8
15032: PPUSH
15033: CALL_OW 456
// if not dialogueMineDetected then
15037: LD_EXP 28
15041: NOT
15042: IFFALSE 15103
// begin dialogueMineDetected := true ;
15044: LD_ADDR_EXP 28
15048: PUSH
15049: LD_INT 1
15051: ST_TO_ADDR
// CenterNowOnXY ( x , y ) ;
15052: LD_VAR 0 4
15056: PPUSH
15057: LD_VAR 0 5
15061: PPUSH
15062: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15066: LD_EXP 9
15070: PPUSH
15071: LD_STRING D
15073: PUSH
15074: LD_STRING I
15076: PUSH
15077: LD_STRING J
15079: PUSH
15080: LD_STRING S
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: LIST
15087: PUSH
15088: LD_EXP 25
15092: ARRAY
15093: STR
15094: PUSH
15095: LD_STRING -1-Mine
15097: STR
15098: PPUSH
15099: CALL_OW 88
// end ; for j = 1 to staticMines do
15103: LD_ADDR_VAR 0 2
15107: PUSH
15108: DOUBLE
15109: LD_INT 1
15111: DEC
15112: ST_TO_ADDR
15113: LD_EXP 16
15117: PUSH
15118: FOR_TO
15119: IFFALSE 15189
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15121: LD_EXP 16
15125: PUSH
15126: LD_VAR 0 2
15130: ARRAY
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 4
15140: EQUAL
15141: PUSH
15142: LD_EXP 16
15146: PUSH
15147: LD_VAR 0 2
15151: ARRAY
15152: PUSH
15153: LD_INT 2
15155: ARRAY
15156: PUSH
15157: LD_VAR 0 5
15161: EQUAL
15162: AND
15163: IFFALSE 15187
// begin staticMines := Delete ( staticMines , j ) ;
15165: LD_ADDR_EXP 16
15169: PUSH
15170: LD_EXP 16
15174: PPUSH
15175: LD_VAR 0 2
15179: PPUSH
15180: CALL_OW 3
15184: ST_TO_ADDR
// break ;
15185: GO 15189
// end ;
15187: GO 15118
15189: POP
15190: POP
// end ; end ;
15191: GO 14971
15193: POP
15194: POP
// end ;
15195: PPOPN 5
15197: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15198: LD_EXP 2
15202: PUSH
15203: LD_INT 1
15205: EQUAL
15206: PUSH
15207: LD_EXP 3
15211: AND
15212: PUSH
15213: LD_EXP 23
15217: AND
15218: PUSH
15219: LD_EXP 31
15223: PUSH
15224: LD_EXP 7
15228: ARRAY
15229: PPUSH
15230: LD_INT 30
15232: PUSH
15233: LD_INT 3
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 72
15244: AND
15245: IFFALSE 15449
15247: GO 15249
15249: DISABLE
15250: LD_INT 0
15252: PPUSH
15253: PPUSH
// begin enable ;
15254: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15255: LD_EXP 7
15259: PPUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 3
15265: PUSH
15266: LD_INT 3
15268: PUSH
15269: LD_INT 48
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: PUSH
15278: EMPTY
15279: LIST
15280: PPUSH
15281: CALL 85516 0 2
// repeat wait ( 0 0$1 ) ;
15285: LD_INT 35
15287: PPUSH
15288: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15292: LD_INT 22
15294: PUSH
15295: LD_INT 3
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: LD_INT 34
15304: PUSH
15305: LD_INT 48
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PPUSH
15316: CALL_OW 69
15320: IFFALSE 15285
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: LD_INT 22
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 34
15339: PUSH
15340: LD_INT 48
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: PPUSH
15351: CALL_OW 69
15355: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15356: LD_ADDR_VAR 0 2
15360: PUSH
15361: LD_INT 81
15363: PUSH
15364: LD_INT 3
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: LD_INT 21
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PPUSH
15385: CALL_OW 69
15389: ST_TO_ADDR
// if e then
15390: LD_VAR 0 2
15394: IFFALSE 15420
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15396: LD_ADDR_VAR 0 2
15400: PUSH
15401: LD_VAR 0 2
15405: PPUSH
15406: LD_VAR 0 1
15410: PUSH
15411: LD_INT 1
15413: ARRAY
15414: PPUSH
15415: CALL_OW 74
15419: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15420: LD_VAR 0 1
15424: PPUSH
15425: LD_VAR 0 2
15429: PPUSH
15430: CALL_OW 250
15434: PPUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: CALL_OW 251
15444: PPUSH
15445: CALL_OW 116
// end ;
15449: PPOPN 2
15451: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15452: LD_OWVAR 67
15456: PUSH
15457: LD_INT 1
15459: GREATER
15460: PUSH
15461: LD_EXP 31
15465: PUSH
15466: LD_EXP 7
15470: ARRAY
15471: PPUSH
15472: LD_INT 25
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 72
15486: AND
15487: PUSH
15488: LD_EXP 2
15492: PUSH
15493: LD_INT 1
15495: EQUAL
15496: AND
15497: PUSH
15498: LD_EXP 3
15502: AND
15503: PUSH
15504: LD_INT 23
15506: PPUSH
15507: LD_INT 3
15509: PPUSH
15510: CALL_OW 321
15514: PUSH
15515: LD_INT 2
15517: EQUAL
15518: AND
15519: IFFALSE 15646
15521: GO 15523
15523: DISABLE
15524: LD_INT 0
15526: PPUSH
15527: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15528: LD_ADDR_VAR 0 1
15532: PUSH
15533: LD_EXP 31
15537: PUSH
15538: LD_EXP 7
15542: ARRAY
15543: PPUSH
15544: LD_INT 25
15546: PUSH
15547: LD_INT 3
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 72
15558: ST_TO_ADDR
// if not tmp then
15559: LD_VAR 0 1
15563: NOT
15564: IFFALSE 15568
// exit ;
15566: GO 15646
// for i in tmp do
15568: LD_ADDR_VAR 0 2
15572: PUSH
15573: LD_VAR 0 1
15577: PUSH
15578: FOR_IN
15579: IFFALSE 15625
// begin SetTag ( i , 29 ) ;
15581: LD_VAR 0 2
15585: PPUSH
15586: LD_INT 29
15588: PPUSH
15589: CALL_OW 109
// ComExitBuilding ( i ) ;
15593: LD_VAR 0 2
15597: PPUSH
15598: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15602: LD_VAR 0 2
15606: PPUSH
15607: LD_INT 37
15609: PPUSH
15610: LD_INT 97
15612: PPUSH
15613: LD_INT 133
15615: PPUSH
15616: LD_INT 0
15618: PPUSH
15619: CALL_OW 230
// end ;
15623: GO 15578
15625: POP
15626: POP
// wait ( 1 1$00 ) ;
15627: LD_INT 2100
15629: PPUSH
15630: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15634: LD_EXP 7
15638: PPUSH
15639: LD_INT 29
15641: PPUSH
15642: CALL 65417 0 2
// end ;
15646: PPOPN 2
15648: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15649: LD_EXP 2
15653: PUSH
15654: LD_INT 1
15656: EQUAL
15657: PUSH
15658: LD_INT 84
15660: PPUSH
15661: LD_INT 128
15663: PPUSH
15664: CALL_OW 428
15668: PPUSH
15669: CALL_OW 266
15673: PUSH
15674: LD_INT 1
15676: EQUAL
15677: AND
15678: PUSH
15679: LD_INT 84
15681: PPUSH
15682: LD_INT 128
15684: PPUSH
15685: CALL_OW 428
15689: PPUSH
15690: CALL_OW 255
15694: PUSH
15695: LD_INT 3
15697: EQUAL
15698: AND
15699: IFFALSE 15872
15701: GO 15703
15703: DISABLE
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// begin enable ;
15708: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15709: LD_ADDR_VAR 0 2
15713: PUSH
15714: LD_INT 84
15716: PPUSH
15717: LD_INT 128
15719: PPUSH
15720: CALL_OW 428
15724: ST_TO_ADDR
// uc_side := 3 ;
15725: LD_ADDR_OWVAR 20
15729: PUSH
15730: LD_INT 3
15732: ST_TO_ADDR
// uc_nation := 3 ;
15733: LD_ADDR_OWVAR 21
15737: PUSH
15738: LD_INT 3
15740: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15741: LD_INT 21
15743: PPUSH
15744: LD_INT 3
15746: PPUSH
15747: LD_INT 3
15749: PPUSH
15750: LD_INT 51
15752: PPUSH
15753: LD_INT 0
15755: PPUSH
15756: CALL 24724 0 5
// veh := CreateVehicle ;
15760: LD_ADDR_VAR 0 1
15764: PUSH
15765: CALL_OW 45
15769: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_INT 126
15777: PPUSH
15778: LD_INT 227
15780: PPUSH
15781: LD_INT 0
15783: PPUSH
15784: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15788: LD_VAR 0 1
15792: PPUSH
15793: LD_INT 2
15795: PPUSH
15796: LD_INT 100
15798: PPUSH
15799: CALL_OW 290
// ComGive ( veh , depot ) ;
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_VAR 0 2
15812: PPUSH
15813: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15817: LD_VAR 0 1
15821: PPUSH
15822: LD_INT 126
15824: PPUSH
15825: LD_INT 227
15827: PPUSH
15828: CALL_OW 171
// wait ( 0 0$10 ) ;
15832: LD_INT 350
15834: PPUSH
15835: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15839: LD_INT 35
15841: PPUSH
15842: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15846: LD_VAR 0 1
15850: PPUSH
15851: LD_INT 126
15853: PPUSH
15854: LD_INT 227
15856: PPUSH
15857: CALL_OW 307
15861: IFFALSE 15839
// RemoveUnit ( veh ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 64
// end ;
15872: PPOPN 2
15874: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15875: LD_EXP 2
15879: PUSH
15880: LD_INT 1
15882: EQUAL
15883: PUSH
15884: LD_EXP 27
15888: AND
15889: PUSH
15890: LD_EXP 25
15894: PUSH
15895: LD_INT 2
15897: EQUAL
15898: AND
15899: IFFALSE 16091
15901: GO 15903
15903: DISABLE
15904: LD_INT 0
15906: PPUSH
15907: PPUSH
// begin enable ;
15908: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15909: LD_OWVAR 1
15913: PUSH
15914: LD_INT 105000
15916: PUSH
15917: LD_INT 84000
15919: PUSH
15920: LD_INT 63000
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: LIST
15927: PUSH
15928: LD_OWVAR 67
15932: ARRAY
15933: GREATEREQUAL
15934: IFFALSE 15937
// disable ;
15936: DISABLE
// uc_side := 4 ;
15937: LD_ADDR_OWVAR 20
15941: PUSH
15942: LD_INT 4
15944: ST_TO_ADDR
// uc_nation := 1 ;
15945: LD_ADDR_OWVAR 21
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15953: LD_INT 2
15955: PPUSH
15956: LD_INT 3
15958: PPUSH
15959: LD_INT 3
15961: PPUSH
15962: LD_INT 12
15964: PPUSH
15965: LD_INT 0
15967: PPUSH
15968: CALL 24724 0 5
// veh := CreateVehicle ;
15972: LD_ADDR_VAR 0 1
15976: PUSH
15977: CALL_OW 45
15981: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 229
15989: PPUSH
15990: LD_INT 226
15992: PPUSH
15993: LD_INT 0
15995: PPUSH
15996: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16000: LD_VAR 0 1
16004: PPUSH
16005: LD_INT 1
16007: PPUSH
16008: LD_INT 100
16010: PPUSH
16011: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16015: LD_VAR 0 1
16019: PPUSH
16020: LD_INT 25
16022: PPUSH
16023: CALL_OW 173
// AddComUnload ( veh ) ;
16027: LD_VAR 0 1
16031: PPUSH
16032: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_INT 229
16043: PPUSH
16044: LD_INT 226
16046: PPUSH
16047: CALL_OW 171
// wait ( 0 0$10 ) ;
16051: LD_INT 350
16053: PPUSH
16054: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16058: LD_INT 35
16060: PPUSH
16061: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16065: LD_VAR 0 1
16069: PPUSH
16070: LD_INT 229
16072: PPUSH
16073: LD_INT 226
16075: PPUSH
16076: CALL_OW 307
16080: IFFALSE 16058
// RemoveUnit ( veh ) ;
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 64
// end ;
16091: PPOPN 2
16093: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16094: LD_EXP 2
16098: PUSH
16099: LD_INT 1
16101: EQUAL
16102: PUSH
16103: LD_EXP 3
16107: AND
16108: PUSH
16109: LD_EXP 24
16113: AND
16114: IFFALSE 16447
16116: GO 16118
16118: DISABLE
16119: LD_INT 0
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
16125: PPUSH
// begin enable ;
16126: ENABLE
// tmp := [ ] ;
16127: LD_ADDR_VAR 0 4
16131: PUSH
16132: EMPTY
16133: ST_TO_ADDR
// if commander = 1 then
16134: LD_EXP 25
16138: PUSH
16139: LD_INT 1
16141: EQUAL
16142: IFFALSE 16154
// amount := 3 else
16144: LD_ADDR_VAR 0 5
16148: PUSH
16149: LD_INT 3
16151: ST_TO_ADDR
16152: GO 16162
// amount := 2 ;
16154: LD_ADDR_VAR 0 5
16158: PUSH
16159: LD_INT 2
16161: ST_TO_ADDR
// for i = 1 to amount do
16162: LD_ADDR_VAR 0 1
16166: PUSH
16167: DOUBLE
16168: LD_INT 1
16170: DEC
16171: ST_TO_ADDR
16172: LD_VAR 0 5
16176: PUSH
16177: FOR_TO
16178: IFFALSE 16342
// begin wait ( 0 0$5 ) ;
16180: LD_INT 175
16182: PPUSH
16183: CALL_OW 67
// for j = 1 to 3 do
16187: LD_ADDR_VAR 0 2
16191: PUSH
16192: DOUBLE
16193: LD_INT 1
16195: DEC
16196: ST_TO_ADDR
16197: LD_INT 3
16199: PUSH
16200: FOR_TO
16201: IFFALSE 16338
// begin uc_side := 4 ;
16203: LD_ADDR_OWVAR 20
16207: PUSH
16208: LD_INT 4
16210: ST_TO_ADDR
// uc_nation := 1 ;
16211: LD_ADDR_OWVAR 21
16215: PUSH
16216: LD_INT 1
16218: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16219: LD_INT 3
16221: PUSH
16222: LD_INT 5
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PUSH
16229: LD_INT 1
16231: PPUSH
16232: LD_INT 2
16234: PPUSH
16235: CALL_OW 12
16239: ARRAY
16240: PPUSH
16241: LD_INT 3
16243: PPUSH
16244: LD_INT 3
16246: PPUSH
16247: LD_INT 9
16249: PUSH
16250: LD_INT 5
16252: PUSH
16253: LD_INT 7
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: PUSH
16261: LD_INT 1
16263: PPUSH
16264: LD_INT 3
16266: PPUSH
16267: CALL_OW 12
16271: ARRAY
16272: PPUSH
16273: LD_INT 100
16275: PPUSH
16276: CALL 24724 0 5
// veh := CreateVehicle ;
16280: LD_ADDR_VAR 0 3
16284: PUSH
16285: CALL_OW 45
16289: ST_TO_ADDR
// tmp := tmp ^ veh ;
16290: LD_ADDR_VAR 0 4
16294: PUSH
16295: LD_VAR 0 4
16299: PUSH
16300: LD_VAR 0 3
16304: ADD
16305: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16306: LD_VAR 0 3
16310: PPUSH
16311: LD_INT 22
16313: PPUSH
16314: LD_INT 0
16316: PPUSH
16317: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16321: LD_VAR 0 3
16325: PPUSH
16326: LD_INT 119
16328: PPUSH
16329: LD_INT 215
16331: PPUSH
16332: CALL_OW 111
// end ;
16336: GO 16200
16338: POP
16339: POP
// end ;
16340: GO 16177
16342: POP
16343: POP
// wait ( 0 0$3 ) ;
16344: LD_INT 105
16346: PPUSH
16347: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16351: LD_INT 35
16353: PPUSH
16354: CALL_OW 67
// for i in tmp do
16358: LD_ADDR_VAR 0 1
16362: PUSH
16363: LD_VAR 0 4
16367: PUSH
16368: FOR_IN
16369: IFFALSE 16436
// if IsDead ( i ) then
16371: LD_VAR 0 1
16375: PPUSH
16376: CALL_OW 301
16380: IFFALSE 16400
// tmp := tmp diff i else
16382: LD_ADDR_VAR 0 4
16386: PUSH
16387: LD_VAR 0 4
16391: PUSH
16392: LD_VAR 0 1
16396: DIFF
16397: ST_TO_ADDR
16398: GO 16434
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_INT 81
16407: PUSH
16408: LD_INT 4
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL_OW 69
16419: PPUSH
16420: LD_VAR 0 1
16424: PPUSH
16425: CALL_OW 74
16429: PPUSH
16430: CALL_OW 115
16434: GO 16368
16436: POP
16437: POP
// until tmp = [ ] ;
16438: LD_VAR 0 4
16442: PUSH
16443: EMPTY
16444: EQUAL
16445: IFFALSE 16351
// end ;
16447: PPOPN 5
16449: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16450: LD_EXP 2
16454: PUSH
16455: LD_INT 1
16457: EQUAL
16458: PUSH
16459: LD_EXP 3
16463: AND
16464: IFFALSE 16565
16466: GO 16468
16468: DISABLE
16469: LD_INT 0
16471: PPUSH
16472: PPUSH
// begin enable ;
16473: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16474: LD_ADDR_VAR 0 2
16478: PUSH
16479: LD_INT 3
16481: PUSH
16482: LD_INT 22
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 32
16498: PUSH
16499: LD_INT 1
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PPUSH
16510: CALL_OW 69
16514: ST_TO_ADDR
// if tmp then
16515: LD_VAR 0 2
16519: IFFALSE 16565
// for i in tmp do
16521: LD_ADDR_VAR 0 1
16525: PUSH
16526: LD_VAR 0 2
16530: PUSH
16531: FOR_IN
16532: IFFALSE 16563
// if GetFuel ( i ) < 3 then
16534: LD_VAR 0 1
16538: PPUSH
16539: CALL_OW 261
16543: PUSH
16544: LD_INT 3
16546: LESS
16547: IFFALSE 16561
// SetFuel ( i , 3 ) ;
16549: LD_VAR 0 1
16553: PPUSH
16554: LD_INT 3
16556: PPUSH
16557: CALL_OW 240
16561: GO 16531
16563: POP
16564: POP
// end ;
16565: PPOPN 2
16567: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16568: LD_EXP 3
16572: PUSH
16573: LD_INT 8
16575: PPUSH
16576: LD_INT 4
16578: PPUSH
16579: CALL_OW 81
16583: PUSH
16584: LD_INT 2
16586: EQUAL
16587: AND
16588: IFFALSE 16798
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin enable ;
16598: ENABLE
// tmp := [ ] ;
16599: LD_ADDR_VAR 0 3
16603: PUSH
16604: EMPTY
16605: ST_TO_ADDR
// for i = 1 to 4 do
16606: LD_ADDR_VAR 0 1
16610: PUSH
16611: DOUBLE
16612: LD_INT 1
16614: DEC
16615: ST_TO_ADDR
16616: LD_INT 4
16618: PUSH
16619: FOR_TO
16620: IFFALSE 16764
// begin uc_side := 8 ;
16622: LD_ADDR_OWVAR 20
16626: PUSH
16627: LD_INT 8
16629: ST_TO_ADDR
// uc_nation := nation_arabian ;
16630: LD_ADDR_OWVAR 21
16634: PUSH
16635: LD_INT 2
16637: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16638: LD_INT 11
16640: PPUSH
16641: LD_INT 1
16643: PPUSH
16644: LD_INT 5
16646: PPUSH
16647: LD_INT 24
16649: PUSH
16650: LD_INT 23
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PUSH
16657: LD_INT 1
16659: PPUSH
16660: LD_INT 2
16662: PPUSH
16663: CALL_OW 12
16667: ARRAY
16668: PPUSH
16669: LD_INT 60
16671: PPUSH
16672: LD_INT 80
16674: PPUSH
16675: CALL_OW 12
16679: PPUSH
16680: CALL 24724 0 5
// un := CreateVehicle ;
16684: LD_ADDR_VAR 0 2
16688: PUSH
16689: CALL_OW 45
16693: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16694: LD_VAR 0 2
16698: PPUSH
16699: LD_INT 2
16701: PPUSH
16702: CALL_OW 233
// tmp := tmp ^ un ;
16706: LD_ADDR_VAR 0 3
16710: PUSH
16711: LD_VAR 0 3
16715: PUSH
16716: LD_VAR 0 2
16720: ADD
16721: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16722: LD_VAR 0 2
16726: PPUSH
16727: LD_INT 88
16729: PPUSH
16730: LD_INT 2
16732: PPUSH
16733: LD_INT 0
16735: PPUSH
16736: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16740: LD_VAR 0 2
16744: PPUSH
16745: LD_INT 93
16747: PPUSH
16748: LD_INT 13
16750: PPUSH
16751: CALL_OW 111
// wait ( 0 0$2 ) ;
16755: LD_INT 70
16757: PPUSH
16758: CALL_OW 67
// end ;
16762: GO 16619
16764: POP
16765: POP
// for i in tmp do
16766: LD_ADDR_VAR 0 1
16770: PUSH
16771: LD_VAR 0 3
16775: PUSH
16776: FOR_IN
16777: IFFALSE 16796
// AddComMoveXY ( i , 136 , 19 ) ;
16779: LD_VAR 0 1
16783: PPUSH
16784: LD_INT 136
16786: PPUSH
16787: LD_INT 19
16789: PPUSH
16790: CALL_OW 171
16794: GO 16776
16796: POP
16797: POP
// end ;
16798: PPOPN 3
16800: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16801: LD_EXP 3
16805: IFFALSE 17724
16807: GO 16809
16809: DISABLE
16810: LD_INT 0
16812: PPUSH
16813: PPUSH
16814: PPUSH
16815: PPUSH
// begin enable ;
16816: ENABLE
// base := mc_leg ;
16817: LD_ADDR_VAR 0 2
16821: PUSH
16822: LD_EXP 6
16826: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16827: LD_INT 22
16829: PUSH
16830: LD_INT 8
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 23
16839: PUSH
16840: LD_INT 2
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 3
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 69
16866: NOT
16867: IFFALSE 16871
// exit ;
16869: GO 17724
// if Prob ( 40 ) then
16871: LD_INT 40
16873: PPUSH
16874: CALL_OW 13
16878: IFFALSE 17007
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16880: LD_VAR 0 2
16884: PPUSH
16885: LD_INT 13
16887: PUSH
16888: LD_INT 1
16890: PUSH
16891: LD_INT 2
16893: PUSH
16894: LD_INT 28
16896: PUSH
16897: EMPTY
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 13
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 28
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: PUSH
16921: LD_INT 13
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: LD_INT 2
16929: PUSH
16930: LD_INT 28
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 13
16941: PUSH
16942: LD_INT 1
16944: PUSH
16945: LD_INT 2
16947: PUSH
16948: LD_INT 28
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 13
16959: PUSH
16960: LD_INT 1
16962: PUSH
16963: LD_INT 2
16965: PUSH
16966: LD_INT 28
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: PUSH
16975: LD_INT 13
16977: PUSH
16978: LD_INT 1
16980: PUSH
16981: LD_INT 2
16983: PUSH
16984: LD_INT 26
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: PPUSH
17001: CALL 85516 0 2
// end else
17005: GO 17224
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17007: LD_VAR 0 2
17011: PPUSH
17012: LD_INT 13
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: LD_INT 2
17020: PUSH
17021: LD_INT 27
17023: PUSH
17024: LD_INT 26
17026: PUSH
17027: LD_INT 26
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 1
17037: PPUSH
17038: LD_INT 3
17040: PPUSH
17041: CALL_OW 12
17045: ARRAY
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: PUSH
17053: LD_INT 13
17055: PUSH
17056: LD_INT 1
17058: PUSH
17059: LD_INT 2
17061: PUSH
17062: LD_INT 27
17064: PUSH
17065: LD_INT 26
17067: PUSH
17068: LD_INT 26
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 3
17081: PPUSH
17082: CALL_OW 12
17086: ARRAY
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 13
17096: PUSH
17097: LD_INT 1
17099: PUSH
17100: LD_INT 2
17102: PUSH
17103: LD_INT 26
17105: PUSH
17106: LD_INT 26
17108: PUSH
17109: LD_INT 29
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 1
17119: PPUSH
17120: LD_INT 3
17122: PPUSH
17123: CALL_OW 12
17127: ARRAY
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 13
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: LD_INT 2
17143: PUSH
17144: LD_INT 26
17146: PUSH
17147: LD_INT 29
17149: PUSH
17150: LD_INT 29
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: LIST
17157: PUSH
17158: LD_INT 1
17160: PPUSH
17161: LD_INT 3
17163: PPUSH
17164: CALL_OW 12
17168: ARRAY
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: PUSH
17176: LD_INT 13
17178: PUSH
17179: LD_INT 1
17181: PUSH
17182: LD_INT 2
17184: PUSH
17185: LD_INT 29
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 13
17196: PUSH
17197: LD_INT 1
17199: PUSH
17200: LD_INT 2
17202: PUSH
17203: LD_INT 26
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: PPUSH
17220: CALL 85516 0 2
// end ; repeat wait ( 0 0$1 ) ;
17224: LD_INT 35
17226: PPUSH
17227: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17231: LD_VAR 0 2
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: CALL 86934 0 2
17243: PUSH
17244: LD_INT 6
17246: GREATEREQUAL
17247: PUSH
17248: LD_OWVAR 1
17252: PUSH
17253: LD_INT 21000
17255: MOD
17256: PUSH
17257: LD_INT 0
17259: EQUAL
17260: OR
17261: IFFALSE 17224
// wait ( 0 0$30 ) ;
17263: LD_INT 1050
17265: PPUSH
17266: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17270: LD_ADDR_VAR 0 3
17274: PUSH
17275: LD_VAR 0 2
17279: PPUSH
17280: LD_INT 1
17282: PPUSH
17283: CALL 86934 0 2
17287: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17288: LD_ADDR_EXP 50
17292: PUSH
17293: LD_EXP 50
17297: PPUSH
17298: LD_VAR 0 2
17302: PPUSH
17303: LD_EXP 50
17307: PUSH
17308: LD_VAR 0 2
17312: ARRAY
17313: PUSH
17314: LD_VAR 0 3
17318: DIFF
17319: PPUSH
17320: CALL_OW 1
17324: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17325: LD_ADDR_VAR 0 4
17329: PUSH
17330: LD_INT 0
17332: PPUSH
17333: LD_INT 2
17335: PPUSH
17336: CALL_OW 12
17340: ST_TO_ADDR
// if legChangeSide then
17341: LD_EXP 21
17345: IFFALSE 17355
// target := 2 ;
17347: LD_ADDR_VAR 0 4
17351: PUSH
17352: LD_INT 2
17354: ST_TO_ADDR
// if target = 2 then
17355: LD_VAR 0 4
17359: PUSH
17360: LD_INT 2
17362: EQUAL
17363: IFFALSE 17491
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_VAR 0 3
17374: PPUSH
17375: LD_INT 24
17377: PUSH
17378: LD_INT 250
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: PPUSH
17385: CALL_OW 72
17389: ST_TO_ADDR
// for i in tmp do
17390: LD_ADDR_VAR 0 1
17394: PUSH
17395: LD_VAR 0 3
17399: PUSH
17400: FOR_IN
17401: IFFALSE 17441
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17403: LD_VAR 0 1
17407: PPUSH
17408: LD_INT 112
17410: PPUSH
17411: LD_INT 64
17413: PPUSH
17414: CALL_OW 297
17418: PUSH
17419: LD_INT 9
17421: GREATER
17422: IFFALSE 17439
// ComMoveXY ( i , 112 , 64 ) ;
17424: LD_VAR 0 1
17428: PPUSH
17429: LD_INT 112
17431: PPUSH
17432: LD_INT 64
17434: PPUSH
17435: CALL_OW 111
17439: GO 17400
17441: POP
17442: POP
// wait ( 0 0$1 ) ;
17443: LD_INT 35
17445: PPUSH
17446: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17450: LD_VAR 0 3
17454: PPUSH
17455: LD_INT 92
17457: PUSH
17458: LD_INT 112
17460: PUSH
17461: LD_INT 64
17463: PUSH
17464: LD_INT 9
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: LIST
17472: PPUSH
17473: CALL_OW 72
17477: PUSH
17478: LD_VAR 0 3
17482: PUSH
17483: LD_INT 1
17485: MINUS
17486: GREATEREQUAL
17487: IFFALSE 17365
// end else
17489: GO 17615
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17491: LD_ADDR_VAR 0 3
17495: PUSH
17496: LD_VAR 0 3
17500: PPUSH
17501: LD_INT 24
17503: PUSH
17504: LD_INT 250
17506: PUSH
17507: EMPTY
17508: LIST
17509: LIST
17510: PPUSH
17511: CALL_OW 72
17515: ST_TO_ADDR
// for i in tmp do
17516: LD_ADDR_VAR 0 1
17520: PUSH
17521: LD_VAR 0 3
17525: PUSH
17526: FOR_IN
17527: IFFALSE 17567
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17529: LD_VAR 0 1
17533: PPUSH
17534: LD_INT 174
17536: PPUSH
17537: LD_INT 94
17539: PPUSH
17540: CALL_OW 297
17544: PUSH
17545: LD_INT 9
17547: GREATER
17548: IFFALSE 17565
// ComMoveXY ( i , 174 , 94 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 174
17557: PPUSH
17558: LD_INT 94
17560: PPUSH
17561: CALL_OW 111
17565: GO 17526
17567: POP
17568: POP
// wait ( 0 0$1 ) ;
17569: LD_INT 35
17571: PPUSH
17572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17576: LD_VAR 0 3
17580: PPUSH
17581: LD_INT 92
17583: PUSH
17584: LD_INT 174
17586: PUSH
17587: LD_INT 94
17589: PUSH
17590: LD_INT 9
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: PPUSH
17599: CALL_OW 72
17603: PUSH
17604: LD_VAR 0 3
17608: PUSH
17609: LD_INT 1
17611: MINUS
17612: GREATEREQUAL
17613: IFFALSE 17491
// end ; repeat wait ( 0 0$1 ) ;
17615: LD_INT 35
17617: PPUSH
17618: CALL_OW 67
// for i in tmp do
17622: LD_ADDR_VAR 0 1
17626: PUSH
17627: LD_VAR 0 3
17631: PUSH
17632: FOR_IN
17633: IFFALSE 17715
// begin if GetLives ( i ) > 251 then
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL_OW 256
17644: PUSH
17645: LD_INT 251
17647: GREATER
17648: IFFALSE 17686
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17650: LD_VAR 0 1
17654: PPUSH
17655: LD_INT 81
17657: PUSH
17658: LD_INT 8
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: PPUSH
17665: CALL_OW 69
17669: PPUSH
17670: LD_VAR 0 1
17674: PPUSH
17675: CALL_OW 74
17679: PPUSH
17680: CALL_OW 115
17684: GO 17713
// if IsDead ( i ) then
17686: LD_VAR 0 1
17690: PPUSH
17691: CALL_OW 301
17695: IFFALSE 17713
// tmp := tmp diff i ;
17697: LD_ADDR_VAR 0 3
17701: PUSH
17702: LD_VAR 0 3
17706: PUSH
17707: LD_VAR 0 1
17711: DIFF
17712: ST_TO_ADDR
// end ;
17713: GO 17632
17715: POP
17716: POP
// until not tmp ;
17717: LD_VAR 0 3
17721: NOT
17722: IFFALSE 17615
// end ;
17724: PPOPN 4
17726: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17727: LD_EXP 3
17731: IFFALSE 18719
17733: GO 17735
17735: DISABLE
17736: LD_INT 0
17738: PPUSH
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
// begin enable ;
17743: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17744: LD_EXP 31
17748: PUSH
17749: LD_EXP 8
17753: ARRAY
17754: PPUSH
17755: LD_INT 22
17757: PUSH
17758: LD_INT 3
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 3
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: PPUSH
17779: CALL_OW 72
17783: NOT
17784: IFFALSE 17788
// exit ;
17786: GO 18719
// base := mc_rus_2 ;
17788: LD_ADDR_VAR 0 2
17792: PUSH
17793: LD_EXP 8
17797: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17798: LD_ADDR_VAR 0 5
17802: PUSH
17803: LD_INT 22
17805: PUSH
17806: LD_INT 3
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: PUSH
17813: LD_INT 30
17815: PUSH
17816: LD_INT 34
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: PPUSH
17827: CALL_OW 69
17831: ST_TO_ADDR
// if Prob ( 40 ) then
17832: LD_INT 40
17834: PPUSH
17835: CALL_OW 13
17839: IFFALSE 17968
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17841: LD_VAR 0 2
17845: PPUSH
17846: LD_INT 22
17848: PUSH
17849: LD_INT 3
17851: PUSH
17852: LD_INT 3
17854: PUSH
17855: LD_INT 49
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: PUSH
17864: LD_INT 22
17866: PUSH
17867: LD_INT 3
17869: PUSH
17870: LD_INT 3
17872: PUSH
17873: LD_INT 49
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: PUSH
17882: LD_INT 22
17884: PUSH
17885: LD_INT 3
17887: PUSH
17888: LD_INT 3
17890: PUSH
17891: LD_INT 49
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 24
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: LD_INT 46
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: LIST
17916: LIST
17917: PUSH
17918: LD_INT 24
17920: PUSH
17921: LD_INT 3
17923: PUSH
17924: LD_INT 3
17926: PUSH
17927: LD_INT 46
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: LIST
17934: LIST
17935: PUSH
17936: LD_INT 24
17938: PUSH
17939: LD_INT 3
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 46
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: PPUSH
17962: CALL 85516 0 2
// end else
17966: GO 18093
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17968: LD_VAR 0 2
17972: PPUSH
17973: LD_INT 24
17975: PUSH
17976: LD_INT 3
17978: PUSH
17979: LD_INT 3
17981: PUSH
17982: LD_INT 47
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: PUSH
17991: LD_INT 24
17993: PUSH
17994: LD_INT 3
17996: PUSH
17997: LD_INT 3
17999: PUSH
18000: LD_INT 47
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 24
18011: PUSH
18012: LD_INT 3
18014: PUSH
18015: LD_INT 3
18017: PUSH
18018: LD_INT 47
18020: PUSH
18021: EMPTY
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 24
18029: PUSH
18030: LD_INT 3
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: LD_INT 46
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 24
18047: PUSH
18048: LD_INT 3
18050: PUSH
18051: LD_INT 3
18053: PUSH
18054: LD_INT 46
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: PUSH
18063: LD_INT 24
18065: PUSH
18066: LD_INT 3
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 46
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: PPUSH
18089: CALL 85516 0 2
// end ; if Difficulty > 1 then
18093: LD_OWVAR 67
18097: PUSH
18098: LD_INT 1
18100: GREATER
18101: IFFALSE 18133
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18103: LD_VAR 0 2
18107: PPUSH
18108: LD_INT 24
18110: PUSH
18111: LD_INT 3
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 47
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: PPUSH
18129: CALL 85516 0 2
// repeat wait ( 0 0$1 ) ;
18133: LD_INT 35
18135: PPUSH
18136: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18140: LD_VAR 0 2
18144: PPUSH
18145: LD_INT 1
18147: PPUSH
18148: CALL 86934 0 2
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 7
18158: PUSH
18159: LD_INT 7
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: PUSH
18167: LD_OWVAR 67
18171: ARRAY
18172: GREATEREQUAL
18173: PUSH
18174: LD_OWVAR 1
18178: PUSH
18179: LD_INT 21000
18181: MOD
18182: PUSH
18183: LD_INT 0
18185: EQUAL
18186: OR
18187: IFFALSE 18133
// wait ( 0 0$45 ) ;
18189: LD_INT 1575
18191: PPUSH
18192: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_VAR 0 2
18205: PPUSH
18206: LD_INT 1
18208: PPUSH
18209: CALL 86934 0 2
18213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18214: LD_ADDR_EXP 50
18218: PUSH
18219: LD_EXP 50
18223: PPUSH
18224: LD_VAR 0 2
18228: PPUSH
18229: LD_EXP 50
18233: PUSH
18234: LD_VAR 0 2
18238: ARRAY
18239: PUSH
18240: LD_VAR 0 3
18244: DIFF
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18251: LD_ADDR_VAR 0 4
18255: PUSH
18256: LD_INT 0
18258: PPUSH
18259: LD_INT 1
18261: PPUSH
18262: CALL_OW 12
18266: ST_TO_ADDR
// if target then
18267: LD_VAR 0 4
18271: IFFALSE 18399
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18273: LD_ADDR_VAR 0 3
18277: PUSH
18278: LD_VAR 0 3
18282: PPUSH
18283: LD_INT 24
18285: PUSH
18286: LD_INT 250
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 72
18297: ST_TO_ADDR
// for i in tmp do
18298: LD_ADDR_VAR 0 1
18302: PUSH
18303: LD_VAR 0 3
18307: PUSH
18308: FOR_IN
18309: IFFALSE 18349
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18311: LD_VAR 0 1
18315: PPUSH
18316: LD_INT 84
18318: PPUSH
18319: LD_INT 32
18321: PPUSH
18322: CALL_OW 297
18326: PUSH
18327: LD_INT 9
18329: GREATER
18330: IFFALSE 18347
// ComMoveXY ( i , 84 , 32 ) ;
18332: LD_VAR 0 1
18336: PPUSH
18337: LD_INT 84
18339: PPUSH
18340: LD_INT 32
18342: PPUSH
18343: CALL_OW 111
18347: GO 18308
18349: POP
18350: POP
// wait ( 0 0$1 ) ;
18351: LD_INT 35
18353: PPUSH
18354: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18358: LD_VAR 0 3
18362: PPUSH
18363: LD_INT 92
18365: PUSH
18366: LD_INT 84
18368: PUSH
18369: LD_INT 32
18371: PUSH
18372: LD_INT 9
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: PPUSH
18381: CALL_OW 72
18385: PUSH
18386: LD_VAR 0 3
18390: PUSH
18391: LD_INT 1
18393: MINUS
18394: GREATEREQUAL
18395: IFFALSE 18273
// end else
18397: GO 18559
// begin if teleport then
18399: LD_VAR 0 5
18403: IFFALSE 18423
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18405: LD_VAR 0 3
18409: PPUSH
18410: LD_VAR 0 5
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18423: LD_ADDR_VAR 0 3
18427: PUSH
18428: LD_VAR 0 3
18432: PPUSH
18433: LD_INT 24
18435: PUSH
18436: LD_INT 250
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: PPUSH
18443: CALL_OW 72
18447: ST_TO_ADDR
// for i in tmp do
18448: LD_ADDR_VAR 0 1
18452: PUSH
18453: LD_VAR 0 3
18457: PUSH
18458: FOR_IN
18459: IFFALSE 18511
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 140
18468: PPUSH
18469: LD_INT 219
18471: PPUSH
18472: CALL_OW 297
18476: PUSH
18477: LD_INT 9
18479: GREATER
18480: PUSH
18481: LD_VAR 0 1
18485: PPUSH
18486: CALL_OW 314
18490: NOT
18491: AND
18492: IFFALSE 18509
// AddComMoveXY ( i , 140 , 219 ) ;
18494: LD_VAR 0 1
18498: PPUSH
18499: LD_INT 140
18501: PPUSH
18502: LD_INT 219
18504: PPUSH
18505: CALL_OW 171
18509: GO 18458
18511: POP
18512: POP
// wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_INT 92
18527: PUSH
18528: LD_INT 140
18530: PUSH
18531: LD_INT 219
18533: PUSH
18534: LD_INT 9
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 72
18547: PUSH
18548: LD_VAR 0 3
18552: PUSH
18553: LD_INT 1
18555: MINUS
18556: GREATEREQUAL
18557: IFFALSE 18423
// end ; repeat wait ( 0 0$1 ) ;
18559: LD_INT 35
18561: PPUSH
18562: CALL_OW 67
// for i in tmp do
18566: LD_ADDR_VAR 0 1
18570: PUSH
18571: LD_VAR 0 3
18575: PUSH
18576: FOR_IN
18577: IFFALSE 18710
// begin if GetLives ( i ) > 251 then
18579: LD_VAR 0 1
18583: PPUSH
18584: CALL_OW 256
18588: PUSH
18589: LD_INT 251
18591: GREATER
18592: IFFALSE 18681
// begin if GetWeapon ( i ) = ru_time_lapser then
18594: LD_VAR 0 1
18598: PPUSH
18599: CALL_OW 264
18603: PUSH
18604: LD_INT 49
18606: EQUAL
18607: IFFALSE 18645
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18609: LD_VAR 0 1
18613: PPUSH
18614: LD_INT 81
18616: PUSH
18617: LD_INT 3
18619: PUSH
18620: EMPTY
18621: LIST
18622: LIST
18623: PPUSH
18624: CALL_OW 69
18628: PPUSH
18629: LD_VAR 0 1
18633: PPUSH
18634: CALL_OW 74
18638: PPUSH
18639: CALL_OW 112
18643: GO 18679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18645: LD_VAR 0 1
18649: PPUSH
18650: LD_INT 81
18652: PUSH
18653: LD_INT 3
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL_OW 69
18664: PPUSH
18665: LD_VAR 0 1
18669: PPUSH
18670: CALL_OW 74
18674: PPUSH
18675: CALL_OW 115
// end else
18679: GO 18708
// if IsDead ( i ) then
18681: LD_VAR 0 1
18685: PPUSH
18686: CALL_OW 301
18690: IFFALSE 18708
// tmp := tmp diff i ;
18692: LD_ADDR_VAR 0 3
18696: PUSH
18697: LD_VAR 0 3
18701: PUSH
18702: LD_VAR 0 1
18706: DIFF
18707: ST_TO_ADDR
// end ;
18708: GO 18576
18710: POP
18711: POP
// until not tmp ;
18712: LD_VAR 0 3
18716: NOT
18717: IFFALSE 18559
// end ;
18719: PPOPN 5
18721: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18722: LD_EXP 3
18726: IFFALSE 19108
18728: GO 18730
18730: DISABLE
18731: LD_INT 0
18733: PPUSH
18734: PPUSH
18735: PPUSH
18736: PPUSH
// begin enable ;
18737: ENABLE
// base := mc_amer ;
18738: LD_ADDR_VAR 0 2
18742: PUSH
18743: LD_EXP 5
18747: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18748: LD_INT 22
18750: PUSH
18751: LD_INT 4
18753: PUSH
18754: EMPTY
18755: LIST
18756: LIST
18757: PUSH
18758: LD_INT 23
18760: PUSH
18761: LD_INT 1
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 3
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL_OW 69
18787: NOT
18788: IFFALSE 18792
// exit ;
18790: GO 19108
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18792: LD_VAR 0 2
18796: PPUSH
18797: LD_INT 3
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 5
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 3
18817: PUSH
18818: LD_INT 1
18820: PUSH
18821: LD_INT 2
18823: PUSH
18824: LD_INT 9
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: LIST
18831: LIST
18832: PUSH
18833: LD_INT 3
18835: PUSH
18836: LD_INT 1
18838: PUSH
18839: LD_INT 2
18841: PUSH
18842: LD_INT 7
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: PUSH
18851: LD_INT 3
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: LD_INT 2
18859: PUSH
18860: LD_INT 7
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: LD_INT 1
18874: PUSH
18875: LD_INT 2
18877: PUSH
18878: LD_INT 7
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: PPUSH
18894: CALL 85516 0 2
// repeat wait ( 0 0$1 ) ;
18898: LD_INT 35
18900: PPUSH
18901: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18905: LD_VAR 0 2
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 86934 0 2
18917: PUSH
18918: LD_INT 5
18920: GREATEREQUAL
18921: PUSH
18922: LD_OWVAR 1
18926: PUSH
18927: LD_INT 21000
18929: MOD
18930: PUSH
18931: LD_INT 0
18933: EQUAL
18934: OR
18935: IFFALSE 18898
// wait ( 0 0$30 ) ;
18937: LD_INT 1050
18939: PPUSH
18940: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_VAR 0 2
18953: PPUSH
18954: LD_INT 1
18956: PPUSH
18957: CALL 86934 0 2
18961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18962: LD_ADDR_EXP 50
18966: PUSH
18967: LD_EXP 50
18971: PPUSH
18972: LD_VAR 0 2
18976: PPUSH
18977: LD_EXP 50
18981: PUSH
18982: LD_VAR 0 2
18986: ARRAY
18987: PUSH
18988: LD_VAR 0 3
18992: DIFF
18993: PPUSH
18994: CALL_OW 1
18998: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18999: LD_INT 35
19001: PPUSH
19002: CALL_OW 67
// for i in tmp do
19006: LD_ADDR_VAR 0 1
19010: PUSH
19011: LD_VAR 0 3
19015: PUSH
19016: FOR_IN
19017: IFFALSE 19099
// begin if GetLives ( i ) > 251 then
19019: LD_VAR 0 1
19023: PPUSH
19024: CALL_OW 256
19028: PUSH
19029: LD_INT 251
19031: GREATER
19032: IFFALSE 19070
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19034: LD_VAR 0 1
19038: PPUSH
19039: LD_INT 81
19041: PUSH
19042: LD_INT 4
19044: PUSH
19045: EMPTY
19046: LIST
19047: LIST
19048: PPUSH
19049: CALL_OW 69
19053: PPUSH
19054: LD_VAR 0 1
19058: PPUSH
19059: CALL_OW 74
19063: PPUSH
19064: CALL_OW 115
19068: GO 19097
// if IsDead ( i ) then
19070: LD_VAR 0 1
19074: PPUSH
19075: CALL_OW 301
19079: IFFALSE 19097
// tmp := tmp diff i ;
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_VAR 0 3
19090: PUSH
19091: LD_VAR 0 1
19095: DIFF
19096: ST_TO_ADDR
// end ;
19097: GO 19016
19099: POP
19100: POP
// until not tmp ;
19101: LD_VAR 0 3
19105: NOT
19106: IFFALSE 18999
// end ; end_of_file
19108: PPOPN 4
19110: END
// export function CustomEvent ( event ) ; begin
19111: LD_INT 0
19113: PPUSH
// end ;
19114: LD_VAR 0 2
19118: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19119: LD_VAR 0 1
19123: PUSH
19124: LD_INT 1
19126: EQUAL
19127: PUSH
19128: LD_VAR 0 2
19132: PUSH
19133: LD_INT 4
19135: EQUAL
19136: AND
19137: IFFALSE 19165
// begin SayRadio ( Powell , DP-Lost ) ;
19139: LD_EXP 12
19143: PPUSH
19144: LD_STRING DP-Lost
19146: PPUSH
19147: CALL_OW 94
// wait ( 0 0$2 ) ;
19151: LD_INT 70
19153: PPUSH
19154: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19158: LD_STRING FriendlyFire
19160: PPUSH
19161: CALL_OW 104
// end ; end ;
19165: PPOPN 2
19167: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19168: LD_VAR 0 1
19172: PPUSH
19173: CALL 107736 0 1
// if GameType = 1 then
19177: LD_EXP 2
19181: PUSH
19182: LD_INT 1
19184: EQUAL
19185: IFFALSE 19420
// begin if un = playerCommander then
19187: LD_VAR 0 1
19191: PUSH
19192: LD_EXP 9
19196: EQUAL
19197: IFFALSE 19206
// YouLost ( commanderDied ) ;
19199: LD_STRING commanderDied
19201: PPUSH
19202: CALL_OW 104
// if un = allyCommander then
19206: LD_VAR 0 1
19210: PUSH
19211: LD_EXP 11
19215: EQUAL
19216: IFFALSE 19225
// YouLost ( Theta ) ;
19218: LD_STRING Theta
19220: PPUSH
19221: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19225: LD_VAR 0 1
19229: PUSH
19230: LD_INT 22
19232: PUSH
19233: LD_INT 8
19235: PUSH
19236: EMPTY
19237: LIST
19238: LIST
19239: PUSH
19240: LD_INT 2
19242: PUSH
19243: LD_INT 21
19245: PUSH
19246: LD_INT 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 69
19276: IN
19277: IFFALSE 19293
// legDestCounter := legDestCounter + 1 ;
19279: LD_ADDR_EXP 18
19283: PUSH
19284: LD_EXP 18
19288: PUSH
19289: LD_INT 1
19291: PLUS
19292: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19293: LD_VAR 0 1
19297: PUSH
19298: LD_INT 22
19300: PUSH
19301: LD_INT 4
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: PUSH
19308: LD_INT 2
19310: PUSH
19311: LD_INT 21
19313: PUSH
19314: LD_INT 1
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PUSH
19321: LD_INT 21
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PPUSH
19340: CALL_OW 69
19344: IN
19345: IFFALSE 19361
// allyDestCounter := allyDestCounter + 1 ;
19347: LD_ADDR_EXP 22
19351: PUSH
19352: LD_EXP 22
19356: PUSH
19357: LD_INT 1
19359: PLUS
19360: ST_TO_ADDR
// if un in ruOutpost then
19361: LD_VAR 0 1
19365: PUSH
19366: LD_EXP 14
19370: IN
19371: IFFALSE 19420
// begin ruOutpost := ruOutpost diff un ;
19373: LD_ADDR_EXP 14
19377: PUSH
19378: LD_EXP 14
19382: PUSH
19383: LD_VAR 0 1
19387: DIFF
19388: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19389: LD_ADDR_EXP 15
19393: PUSH
19394: LD_EXP 15
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: LD_EXP 15
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_INT 1
19413: PLUS
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19420: LD_VAR 0 1
19424: PPUSH
19425: CALL 88958 0 1
// end ;
19429: PPOPN 1
19431: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: LD_VAR 0 2
19441: PPUSH
19442: CALL 91290 0 2
// end ;
19446: PPOPN 2
19448: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19449: LD_VAR 0 1
19453: PPUSH
19454: CALL 90358 0 1
// end ;
19458: PPOPN 1
19460: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19461: LD_VAR 0 1
19465: PPUSH
19466: CALL 90599 0 1
// end ;
19470: PPOPN 1
19472: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19473: LD_VAR 0 1
19477: PUSH
19478: LD_INT 14
19480: EQUAL
19481: PUSH
19482: LD_VAR 0 2
19486: PPUSH
19487: CALL_OW 255
19491: PUSH
19492: LD_INT 1
19494: EQUAL
19495: AND
19496: IFFALSE 19537
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19498: LD_EXP 9
19502: PPUSH
19503: LD_STRING D
19505: PUSH
19506: LD_STRING I
19508: PUSH
19509: LD_STRING J
19511: PUSH
19512: LD_STRING S
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: LIST
19519: PUSH
19520: LD_EXP 25
19524: ARRAY
19525: STR
19526: PUSH
19527: LD_STRING -1-Laser
19529: STR
19530: PPUSH
19531: CALL_OW 88
// exit ;
19535: GO 19679
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19537: LD_VAR 0 1
19541: PUSH
19542: LD_INT 7
19544: EQUAL
19545: PUSH
19546: LD_VAR 0 2
19550: PPUSH
19551: CALL_OW 255
19555: PUSH
19556: LD_INT 1
19558: EQUAL
19559: AND
19560: IFFALSE 19601
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19562: LD_EXP 9
19566: PPUSH
19567: LD_STRING D
19569: PUSH
19570: LD_STRING I
19572: PUSH
19573: LD_STRING J
19575: PUSH
19576: LD_STRING S
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_EXP 25
19588: ARRAY
19589: STR
19590: PUSH
19591: LD_STRING -1-Materialization
19593: STR
19594: PPUSH
19595: CALL_OW 88
// exit ;
19599: GO 19679
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19601: LD_VAR 0 1
19605: PUSH
19606: LD_INT 25
19608: EQUAL
19609: PUSH
19610: LD_VAR 0 2
19614: PPUSH
19615: CALL_OW 255
19619: PUSH
19620: LD_INT 1
19622: EQUAL
19623: AND
19624: IFFALSE 19665
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19626: LD_EXP 9
19630: PPUSH
19631: LD_STRING D
19633: PUSH
19634: LD_STRING I
19636: PUSH
19637: LD_STRING J
19639: PUSH
19640: LD_STRING S
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: LIST
19647: PUSH
19648: LD_EXP 25
19652: ARRAY
19653: STR
19654: PUSH
19655: LD_STRING -1-Rocket
19657: STR
19658: PPUSH
19659: CALL_OW 88
// exit ;
19663: GO 19679
// end ; MCE_ResearchComplete ( tech , lab ) ;
19665: LD_VAR 0 1
19669: PPUSH
19670: LD_VAR 0 2
19674: PPUSH
19675: CALL 88654 0 2
// end ;
19679: PPOPN 2
19681: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19682: LD_VAR 0 1
19686: PPUSH
19687: LD_VAR 0 2
19691: PPUSH
19692: LD_VAR 0 3
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: LD_VAR 0 5
19706: PPUSH
19707: CALL 88274 0 5
// end ;
19711: PPOPN 5
19713: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19714: LD_VAR 0 1
19718: PPUSH
19719: LD_VAR 0 2
19723: PPUSH
19724: CALL 107856 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19728: LD_VAR 0 1
19732: PPUSH
19733: LD_VAR 0 2
19737: PPUSH
19738: CALL 87827 0 2
// end ;
19742: PPOPN 2
19744: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19745: LD_VAR 0 1
19749: PPUSH
19750: LD_VAR 0 2
19754: PPUSH
19755: LD_VAR 0 3
19759: PPUSH
19760: LD_VAR 0 4
19764: PPUSH
19765: CALL 87665 0 4
// end ;
19769: PPOPN 4
19771: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19772: LD_VAR 0 1
19776: PPUSH
19777: LD_VAR 0 2
19781: PPUSH
19782: LD_VAR 0 3
19786: PPUSH
19787: CALL 87440 0 3
// end ;
19791: PPOPN 3
19793: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19794: LD_VAR 0 1
19798: PPUSH
19799: LD_VAR 0 2
19803: PPUSH
19804: CALL 87325 0 2
// end ;
19808: PPOPN 2
19810: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19811: LD_VAR 0 1
19815: PPUSH
19816: LD_VAR 0 2
19820: PPUSH
19821: CALL 91585 0 2
// end ;
19825: PPOPN 2
19827: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19828: LD_VAR 0 1
19832: PPUSH
19833: LD_VAR 0 2
19837: PPUSH
19838: LD_VAR 0 3
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: CALL 91801 0 4
// end ;
19852: PPOPN 4
19854: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19855: LD_VAR 0 1
19859: PPUSH
19860: LD_VAR 0 2
19864: PPUSH
19865: CALL 87134 0 2
// end ;
19869: PPOPN 2
19871: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19872: LD_VAR 0 1
19876: PPUSH
19877: CALL 107840 0 1
// end ; end_of_file
19881: PPOPN 1
19883: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19884: LD_INT 0
19886: PPUSH
19887: PPUSH
// if exist_mode then
19888: LD_VAR 0 2
19892: IFFALSE 19917
// unit := CreateCharacter ( prefix & ident ) else
19894: LD_ADDR_VAR 0 5
19898: PUSH
19899: LD_VAR 0 3
19903: PUSH
19904: LD_VAR 0 1
19908: STR
19909: PPUSH
19910: CALL_OW 34
19914: ST_TO_ADDR
19915: GO 19932
// unit := NewCharacter ( ident ) ;
19917: LD_ADDR_VAR 0 5
19921: PUSH
19922: LD_VAR 0 1
19926: PPUSH
19927: CALL_OW 25
19931: ST_TO_ADDR
// result := unit ;
19932: LD_ADDR_VAR 0 4
19936: PUSH
19937: LD_VAR 0 5
19941: ST_TO_ADDR
// end ;
19942: LD_VAR 0 4
19946: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19947: LD_INT 0
19949: PPUSH
19950: PPUSH
// if not side or not nation then
19951: LD_VAR 0 1
19955: NOT
19956: PUSH
19957: LD_VAR 0 2
19961: NOT
19962: OR
19963: IFFALSE 19967
// exit ;
19965: GO 20735
// case nation of nation_american :
19967: LD_VAR 0 2
19971: PUSH
19972: LD_INT 1
19974: DOUBLE
19975: EQUAL
19976: IFTRUE 19980
19978: GO 20194
19980: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19981: LD_ADDR_VAR 0 4
19985: PUSH
19986: LD_INT 35
19988: PUSH
19989: LD_INT 45
19991: PUSH
19992: LD_INT 46
19994: PUSH
19995: LD_INT 47
19997: PUSH
19998: LD_INT 82
20000: PUSH
20001: LD_INT 83
20003: PUSH
20004: LD_INT 84
20006: PUSH
20007: LD_INT 85
20009: PUSH
20010: LD_INT 86
20012: PUSH
20013: LD_INT 1
20015: PUSH
20016: LD_INT 2
20018: PUSH
20019: LD_INT 6
20021: PUSH
20022: LD_INT 15
20024: PUSH
20025: LD_INT 16
20027: PUSH
20028: LD_INT 7
20030: PUSH
20031: LD_INT 12
20033: PUSH
20034: LD_INT 13
20036: PUSH
20037: LD_INT 10
20039: PUSH
20040: LD_INT 14
20042: PUSH
20043: LD_INT 20
20045: PUSH
20046: LD_INT 21
20048: PUSH
20049: LD_INT 22
20051: PUSH
20052: LD_INT 25
20054: PUSH
20055: LD_INT 32
20057: PUSH
20058: LD_INT 27
20060: PUSH
20061: LD_INT 36
20063: PUSH
20064: LD_INT 69
20066: PUSH
20067: LD_INT 39
20069: PUSH
20070: LD_INT 34
20072: PUSH
20073: LD_INT 40
20075: PUSH
20076: LD_INT 48
20078: PUSH
20079: LD_INT 49
20081: PUSH
20082: LD_INT 50
20084: PUSH
20085: LD_INT 51
20087: PUSH
20088: LD_INT 52
20090: PUSH
20091: LD_INT 53
20093: PUSH
20094: LD_INT 54
20096: PUSH
20097: LD_INT 55
20099: PUSH
20100: LD_INT 56
20102: PUSH
20103: LD_INT 57
20105: PUSH
20106: LD_INT 58
20108: PUSH
20109: LD_INT 59
20111: PUSH
20112: LD_INT 60
20114: PUSH
20115: LD_INT 61
20117: PUSH
20118: LD_INT 62
20120: PUSH
20121: LD_INT 80
20123: PUSH
20124: LD_INT 82
20126: PUSH
20127: LD_INT 83
20129: PUSH
20130: LD_INT 84
20132: PUSH
20133: LD_INT 85
20135: PUSH
20136: LD_INT 86
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: ST_TO_ADDR
20192: GO 20659
20194: LD_INT 2
20196: DOUBLE
20197: EQUAL
20198: IFTRUE 20202
20200: GO 20428
20202: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20203: LD_ADDR_VAR 0 4
20207: PUSH
20208: LD_INT 35
20210: PUSH
20211: LD_INT 45
20213: PUSH
20214: LD_INT 46
20216: PUSH
20217: LD_INT 47
20219: PUSH
20220: LD_INT 82
20222: PUSH
20223: LD_INT 83
20225: PUSH
20226: LD_INT 84
20228: PUSH
20229: LD_INT 85
20231: PUSH
20232: LD_INT 87
20234: PUSH
20235: LD_INT 70
20237: PUSH
20238: LD_INT 1
20240: PUSH
20241: LD_INT 11
20243: PUSH
20244: LD_INT 3
20246: PUSH
20247: LD_INT 4
20249: PUSH
20250: LD_INT 5
20252: PUSH
20253: LD_INT 6
20255: PUSH
20256: LD_INT 15
20258: PUSH
20259: LD_INT 18
20261: PUSH
20262: LD_INT 7
20264: PUSH
20265: LD_INT 17
20267: PUSH
20268: LD_INT 8
20270: PUSH
20271: LD_INT 20
20273: PUSH
20274: LD_INT 21
20276: PUSH
20277: LD_INT 22
20279: PUSH
20280: LD_INT 72
20282: PUSH
20283: LD_INT 26
20285: PUSH
20286: LD_INT 69
20288: PUSH
20289: LD_INT 39
20291: PUSH
20292: LD_INT 40
20294: PUSH
20295: LD_INT 41
20297: PUSH
20298: LD_INT 42
20300: PUSH
20301: LD_INT 43
20303: PUSH
20304: LD_INT 48
20306: PUSH
20307: LD_INT 49
20309: PUSH
20310: LD_INT 50
20312: PUSH
20313: LD_INT 51
20315: PUSH
20316: LD_INT 52
20318: PUSH
20319: LD_INT 53
20321: PUSH
20322: LD_INT 54
20324: PUSH
20325: LD_INT 55
20327: PUSH
20328: LD_INT 56
20330: PUSH
20331: LD_INT 60
20333: PUSH
20334: LD_INT 61
20336: PUSH
20337: LD_INT 62
20339: PUSH
20340: LD_INT 66
20342: PUSH
20343: LD_INT 67
20345: PUSH
20346: LD_INT 68
20348: PUSH
20349: LD_INT 81
20351: PUSH
20352: LD_INT 82
20354: PUSH
20355: LD_INT 83
20357: PUSH
20358: LD_INT 84
20360: PUSH
20361: LD_INT 85
20363: PUSH
20364: LD_INT 87
20366: PUSH
20367: LD_INT 88
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: ST_TO_ADDR
20426: GO 20659
20428: LD_INT 3
20430: DOUBLE
20431: EQUAL
20432: IFTRUE 20436
20434: GO 20658
20436: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20437: LD_ADDR_VAR 0 4
20441: PUSH
20442: LD_INT 46
20444: PUSH
20445: LD_INT 47
20447: PUSH
20448: LD_INT 1
20450: PUSH
20451: LD_INT 2
20453: PUSH
20454: LD_INT 82
20456: PUSH
20457: LD_INT 83
20459: PUSH
20460: LD_INT 84
20462: PUSH
20463: LD_INT 85
20465: PUSH
20466: LD_INT 86
20468: PUSH
20469: LD_INT 11
20471: PUSH
20472: LD_INT 9
20474: PUSH
20475: LD_INT 20
20477: PUSH
20478: LD_INT 19
20480: PUSH
20481: LD_INT 21
20483: PUSH
20484: LD_INT 24
20486: PUSH
20487: LD_INT 22
20489: PUSH
20490: LD_INT 25
20492: PUSH
20493: LD_INT 28
20495: PUSH
20496: LD_INT 29
20498: PUSH
20499: LD_INT 30
20501: PUSH
20502: LD_INT 31
20504: PUSH
20505: LD_INT 37
20507: PUSH
20508: LD_INT 38
20510: PUSH
20511: LD_INT 32
20513: PUSH
20514: LD_INT 27
20516: PUSH
20517: LD_INT 33
20519: PUSH
20520: LD_INT 69
20522: PUSH
20523: LD_INT 39
20525: PUSH
20526: LD_INT 34
20528: PUSH
20529: LD_INT 40
20531: PUSH
20532: LD_INT 71
20534: PUSH
20535: LD_INT 23
20537: PUSH
20538: LD_INT 44
20540: PUSH
20541: LD_INT 48
20543: PUSH
20544: LD_INT 49
20546: PUSH
20547: LD_INT 50
20549: PUSH
20550: LD_INT 51
20552: PUSH
20553: LD_INT 52
20555: PUSH
20556: LD_INT 53
20558: PUSH
20559: LD_INT 54
20561: PUSH
20562: LD_INT 55
20564: PUSH
20565: LD_INT 56
20567: PUSH
20568: LD_INT 57
20570: PUSH
20571: LD_INT 58
20573: PUSH
20574: LD_INT 59
20576: PUSH
20577: LD_INT 63
20579: PUSH
20580: LD_INT 64
20582: PUSH
20583: LD_INT 65
20585: PUSH
20586: LD_INT 82
20588: PUSH
20589: LD_INT 83
20591: PUSH
20592: LD_INT 84
20594: PUSH
20595: LD_INT 85
20597: PUSH
20598: LD_INT 86
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: ST_TO_ADDR
20656: GO 20659
20658: POP
// if state > - 1 and state < 3 then
20659: LD_VAR 0 3
20663: PUSH
20664: LD_INT 1
20666: NEG
20667: GREATER
20668: PUSH
20669: LD_VAR 0 3
20673: PUSH
20674: LD_INT 3
20676: LESS
20677: AND
20678: IFFALSE 20735
// for i in result do
20680: LD_ADDR_VAR 0 5
20684: PUSH
20685: LD_VAR 0 4
20689: PUSH
20690: FOR_IN
20691: IFFALSE 20733
// if GetTech ( i , side ) <> state then
20693: LD_VAR 0 5
20697: PPUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: CALL_OW 321
20707: PUSH
20708: LD_VAR 0 3
20712: NONEQUAL
20713: IFFALSE 20731
// result := result diff i ;
20715: LD_ADDR_VAR 0 4
20719: PUSH
20720: LD_VAR 0 4
20724: PUSH
20725: LD_VAR 0 5
20729: DIFF
20730: ST_TO_ADDR
20731: GO 20690
20733: POP
20734: POP
// end ;
20735: LD_VAR 0 4
20739: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20740: LD_INT 0
20742: PPUSH
20743: PPUSH
20744: PPUSH
// result := true ;
20745: LD_ADDR_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20753: LD_ADDR_VAR 0 5
20757: PUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: CALL_OW 480
20767: ST_TO_ADDR
// if not tmp then
20768: LD_VAR 0 5
20772: NOT
20773: IFFALSE 20777
// exit ;
20775: GO 20826
// for i in tmp do
20777: LD_ADDR_VAR 0 4
20781: PUSH
20782: LD_VAR 0 5
20786: PUSH
20787: FOR_IN
20788: IFFALSE 20824
// if GetTech ( i , side ) <> state_researched then
20790: LD_VAR 0 4
20794: PPUSH
20795: LD_VAR 0 1
20799: PPUSH
20800: CALL_OW 321
20804: PUSH
20805: LD_INT 2
20807: NONEQUAL
20808: IFFALSE 20822
// begin result := false ;
20810: LD_ADDR_VAR 0 3
20814: PUSH
20815: LD_INT 0
20817: ST_TO_ADDR
// exit ;
20818: POP
20819: POP
20820: GO 20826
// end ;
20822: GO 20787
20824: POP
20825: POP
// end ;
20826: LD_VAR 0 3
20830: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20831: LD_INT 0
20833: PPUSH
20834: PPUSH
20835: PPUSH
20836: PPUSH
20837: PPUSH
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
20845: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20846: LD_VAR 0 1
20850: NOT
20851: PUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: CALL_OW 257
20861: PUSH
20862: LD_INT 9
20864: NONEQUAL
20865: OR
20866: IFFALSE 20870
// exit ;
20868: GO 21443
// side := GetSide ( unit ) ;
20870: LD_ADDR_VAR 0 9
20874: PUSH
20875: LD_VAR 0 1
20879: PPUSH
20880: CALL_OW 255
20884: ST_TO_ADDR
// tech_space := tech_spacanom ;
20885: LD_ADDR_VAR 0 12
20889: PUSH
20890: LD_INT 29
20892: ST_TO_ADDR
// tech_time := tech_taurad ;
20893: LD_ADDR_VAR 0 13
20897: PUSH
20898: LD_INT 28
20900: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20901: LD_ADDR_VAR 0 11
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 310
20915: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20916: LD_VAR 0 11
20920: PPUSH
20921: CALL_OW 247
20925: PUSH
20926: LD_INT 2
20928: EQUAL
20929: IFFALSE 20933
// exit ;
20931: GO 21443
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20933: LD_ADDR_VAR 0 8
20937: PUSH
20938: LD_INT 81
20940: PUSH
20941: LD_VAR 0 9
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: PUSH
20950: LD_INT 3
20952: PUSH
20953: LD_INT 21
20955: PUSH
20956: LD_INT 3
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PPUSH
20971: CALL_OW 69
20975: ST_TO_ADDR
// if not tmp then
20976: LD_VAR 0 8
20980: NOT
20981: IFFALSE 20985
// exit ;
20983: GO 21443
// if in_unit then
20985: LD_VAR 0 11
20989: IFFALSE 21013
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20991: LD_ADDR_VAR 0 10
20995: PUSH
20996: LD_VAR 0 8
21000: PPUSH
21001: LD_VAR 0 11
21005: PPUSH
21006: CALL_OW 74
21010: ST_TO_ADDR
21011: GO 21033
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21013: LD_ADDR_VAR 0 10
21017: PUSH
21018: LD_VAR 0 8
21022: PPUSH
21023: LD_VAR 0 1
21027: PPUSH
21028: CALL_OW 74
21032: ST_TO_ADDR
// if not enemy then
21033: LD_VAR 0 10
21037: NOT
21038: IFFALSE 21042
// exit ;
21040: GO 21443
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21042: LD_VAR 0 11
21046: PUSH
21047: LD_VAR 0 11
21051: PPUSH
21052: LD_VAR 0 10
21056: PPUSH
21057: CALL_OW 296
21061: PUSH
21062: LD_INT 13
21064: GREATER
21065: AND
21066: PUSH
21067: LD_VAR 0 1
21071: PPUSH
21072: LD_VAR 0 10
21076: PPUSH
21077: CALL_OW 296
21081: PUSH
21082: LD_INT 12
21084: GREATER
21085: OR
21086: IFFALSE 21090
// exit ;
21088: GO 21443
// missile := [ 1 ] ;
21090: LD_ADDR_VAR 0 14
21094: PUSH
21095: LD_INT 1
21097: PUSH
21098: EMPTY
21099: LIST
21100: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21101: LD_VAR 0 9
21105: PPUSH
21106: LD_VAR 0 12
21110: PPUSH
21111: CALL_OW 325
21115: IFFALSE 21144
// missile := Replace ( missile , missile + 1 , 2 ) ;
21117: LD_ADDR_VAR 0 14
21121: PUSH
21122: LD_VAR 0 14
21126: PPUSH
21127: LD_VAR 0 14
21131: PUSH
21132: LD_INT 1
21134: PLUS
21135: PPUSH
21136: LD_INT 2
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21144: LD_VAR 0 9
21148: PPUSH
21149: LD_VAR 0 13
21153: PPUSH
21154: CALL_OW 325
21158: PUSH
21159: LD_VAR 0 10
21163: PPUSH
21164: CALL_OW 255
21168: PPUSH
21169: LD_VAR 0 13
21173: PPUSH
21174: CALL_OW 325
21178: NOT
21179: AND
21180: IFFALSE 21209
// missile := Replace ( missile , missile + 1 , 3 ) ;
21182: LD_ADDR_VAR 0 14
21186: PUSH
21187: LD_VAR 0 14
21191: PPUSH
21192: LD_VAR 0 14
21196: PUSH
21197: LD_INT 1
21199: PLUS
21200: PPUSH
21201: LD_INT 3
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// if missile < 2 then
21209: LD_VAR 0 14
21213: PUSH
21214: LD_INT 2
21216: LESS
21217: IFFALSE 21221
// exit ;
21219: GO 21443
// x := GetX ( enemy ) ;
21221: LD_ADDR_VAR 0 4
21225: PUSH
21226: LD_VAR 0 10
21230: PPUSH
21231: CALL_OW 250
21235: ST_TO_ADDR
// y := GetY ( enemy ) ;
21236: LD_ADDR_VAR 0 5
21240: PUSH
21241: LD_VAR 0 10
21245: PPUSH
21246: CALL_OW 251
21250: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21251: LD_ADDR_VAR 0 6
21255: PUSH
21256: LD_VAR 0 4
21260: PUSH
21261: LD_INT 1
21263: NEG
21264: PPUSH
21265: LD_INT 1
21267: PPUSH
21268: CALL_OW 12
21272: PLUS
21273: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21274: LD_ADDR_VAR 0 7
21278: PUSH
21279: LD_VAR 0 5
21283: PUSH
21284: LD_INT 1
21286: NEG
21287: PPUSH
21288: LD_INT 1
21290: PPUSH
21291: CALL_OW 12
21295: PLUS
21296: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21297: LD_VAR 0 6
21301: PPUSH
21302: LD_VAR 0 7
21306: PPUSH
21307: CALL_OW 488
21311: NOT
21312: IFFALSE 21334
// begin _x := x ;
21314: LD_ADDR_VAR 0 6
21318: PUSH
21319: LD_VAR 0 4
21323: ST_TO_ADDR
// _y := y ;
21324: LD_ADDR_VAR 0 7
21328: PUSH
21329: LD_VAR 0 5
21333: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21334: LD_ADDR_VAR 0 3
21338: PUSH
21339: LD_INT 1
21341: PPUSH
21342: LD_VAR 0 14
21346: PPUSH
21347: CALL_OW 12
21351: ST_TO_ADDR
// case i of 1 :
21352: LD_VAR 0 3
21356: PUSH
21357: LD_INT 1
21359: DOUBLE
21360: EQUAL
21361: IFTRUE 21365
21363: GO 21382
21365: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21366: LD_VAR 0 1
21370: PPUSH
21371: LD_VAR 0 10
21375: PPUSH
21376: CALL_OW 115
21380: GO 21443
21382: LD_INT 2
21384: DOUBLE
21385: EQUAL
21386: IFTRUE 21390
21388: GO 21412
21390: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21391: LD_VAR 0 1
21395: PPUSH
21396: LD_VAR 0 6
21400: PPUSH
21401: LD_VAR 0 7
21405: PPUSH
21406: CALL_OW 153
21410: GO 21443
21412: LD_INT 3
21414: DOUBLE
21415: EQUAL
21416: IFTRUE 21420
21418: GO 21442
21420: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21421: LD_VAR 0 1
21425: PPUSH
21426: LD_VAR 0 6
21430: PPUSH
21431: LD_VAR 0 7
21435: PPUSH
21436: CALL_OW 154
21440: GO 21443
21442: POP
// end ;
21443: LD_VAR 0 2
21447: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
21453: PPUSH
21454: PPUSH
21455: PPUSH
// if not unit or not building then
21456: LD_VAR 0 1
21460: NOT
21461: PUSH
21462: LD_VAR 0 2
21466: NOT
21467: OR
21468: IFFALSE 21472
// exit ;
21470: GO 21630
// x := GetX ( building ) ;
21472: LD_ADDR_VAR 0 5
21476: PUSH
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 250
21486: ST_TO_ADDR
// y := GetY ( building ) ;
21487: LD_ADDR_VAR 0 6
21491: PUSH
21492: LD_VAR 0 2
21496: PPUSH
21497: CALL_OW 251
21501: ST_TO_ADDR
// for i = 0 to 5 do
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: DOUBLE
21508: LD_INT 0
21510: DEC
21511: ST_TO_ADDR
21512: LD_INT 5
21514: PUSH
21515: FOR_TO
21516: IFFALSE 21628
// begin _x := ShiftX ( x , i , 3 ) ;
21518: LD_ADDR_VAR 0 7
21522: PUSH
21523: LD_VAR 0 5
21527: PPUSH
21528: LD_VAR 0 4
21532: PPUSH
21533: LD_INT 3
21535: PPUSH
21536: CALL_OW 272
21540: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21541: LD_ADDR_VAR 0 8
21545: PUSH
21546: LD_VAR 0 6
21550: PPUSH
21551: LD_VAR 0 4
21555: PPUSH
21556: LD_INT 3
21558: PPUSH
21559: CALL_OW 273
21563: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21564: LD_VAR 0 7
21568: PPUSH
21569: LD_VAR 0 8
21573: PPUSH
21574: CALL_OW 488
21578: NOT
21579: IFFALSE 21583
// continue ;
21581: GO 21515
// if HexInfo ( _x , _y ) = 0 then
21583: LD_VAR 0 7
21587: PPUSH
21588: LD_VAR 0 8
21592: PPUSH
21593: CALL_OW 428
21597: PUSH
21598: LD_INT 0
21600: EQUAL
21601: IFFALSE 21626
// begin ComMoveXY ( unit , _x , _y ) ;
21603: LD_VAR 0 1
21607: PPUSH
21608: LD_VAR 0 7
21612: PPUSH
21613: LD_VAR 0 8
21617: PPUSH
21618: CALL_OW 111
// exit ;
21622: POP
21623: POP
21624: GO 21630
// end ; end ;
21626: GO 21515
21628: POP
21629: POP
// end ;
21630: LD_VAR 0 3
21634: RET
// export function ScanBase ( side , base_area ) ; begin
21635: LD_INT 0
21637: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21638: LD_ADDR_VAR 0 3
21642: PUSH
21643: LD_VAR 0 2
21647: PPUSH
21648: LD_INT 81
21650: PUSH
21651: LD_VAR 0 1
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PPUSH
21660: CALL_OW 70
21664: ST_TO_ADDR
// end ;
21665: LD_VAR 0 3
21669: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21670: LD_INT 0
21672: PPUSH
21673: PPUSH
21674: PPUSH
21675: PPUSH
// result := false ;
21676: LD_ADDR_VAR 0 2
21680: PUSH
21681: LD_INT 0
21683: ST_TO_ADDR
// side := GetSide ( unit ) ;
21684: LD_ADDR_VAR 0 3
21688: PUSH
21689: LD_VAR 0 1
21693: PPUSH
21694: CALL_OW 255
21698: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21699: LD_ADDR_VAR 0 4
21703: PUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 248
21713: ST_TO_ADDR
// case nat of 1 :
21714: LD_VAR 0 4
21718: PUSH
21719: LD_INT 1
21721: DOUBLE
21722: EQUAL
21723: IFTRUE 21727
21725: GO 21738
21727: POP
// tech := tech_lassight ; 2 :
21728: LD_ADDR_VAR 0 5
21732: PUSH
21733: LD_INT 12
21735: ST_TO_ADDR
21736: GO 21777
21738: LD_INT 2
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 21757
21746: POP
// tech := tech_mortar ; 3 :
21747: LD_ADDR_VAR 0 5
21751: PUSH
21752: LD_INT 41
21754: ST_TO_ADDR
21755: GO 21777
21757: LD_INT 3
21759: DOUBLE
21760: EQUAL
21761: IFTRUE 21765
21763: GO 21776
21765: POP
// tech := tech_bazooka ; end ;
21766: LD_ADDR_VAR 0 5
21770: PUSH
21771: LD_INT 44
21773: ST_TO_ADDR
21774: GO 21777
21776: POP
// if Researched ( side , tech ) then
21777: LD_VAR 0 3
21781: PPUSH
21782: LD_VAR 0 5
21786: PPUSH
21787: CALL_OW 325
21791: IFFALSE 21818
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21793: LD_ADDR_VAR 0 2
21797: PUSH
21798: LD_INT 5
21800: PUSH
21801: LD_INT 8
21803: PUSH
21804: LD_INT 9
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: PUSH
21812: LD_VAR 0 4
21816: ARRAY
21817: ST_TO_ADDR
// end ;
21818: LD_VAR 0 2
21822: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21823: LD_INT 0
21825: PPUSH
21826: PPUSH
21827: PPUSH
// if not mines then
21828: LD_VAR 0 2
21832: NOT
21833: IFFALSE 21837
// exit ;
21835: GO 21981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21837: LD_ADDR_VAR 0 5
21841: PUSH
21842: LD_INT 81
21844: PUSH
21845: LD_VAR 0 1
21849: PUSH
21850: EMPTY
21851: LIST
21852: LIST
21853: PUSH
21854: LD_INT 3
21856: PUSH
21857: LD_INT 21
21859: PUSH
21860: LD_INT 3
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PPUSH
21875: CALL_OW 69
21879: ST_TO_ADDR
// for i in mines do
21880: LD_ADDR_VAR 0 4
21884: PUSH
21885: LD_VAR 0 2
21889: PUSH
21890: FOR_IN
21891: IFFALSE 21979
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21893: LD_VAR 0 4
21897: PUSH
21898: LD_INT 1
21900: ARRAY
21901: PPUSH
21902: LD_VAR 0 4
21906: PUSH
21907: LD_INT 2
21909: ARRAY
21910: PPUSH
21911: CALL_OW 458
21915: NOT
21916: IFFALSE 21920
// continue ;
21918: GO 21890
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21920: LD_VAR 0 4
21924: PUSH
21925: LD_INT 1
21927: ARRAY
21928: PPUSH
21929: LD_VAR 0 4
21933: PUSH
21934: LD_INT 2
21936: ARRAY
21937: PPUSH
21938: CALL_OW 428
21942: PUSH
21943: LD_VAR 0 5
21947: IN
21948: IFFALSE 21977
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21950: LD_VAR 0 4
21954: PUSH
21955: LD_INT 1
21957: ARRAY
21958: PPUSH
21959: LD_VAR 0 4
21963: PUSH
21964: LD_INT 2
21966: ARRAY
21967: PPUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: CALL_OW 456
// end ;
21977: GO 21890
21979: POP
21980: POP
// end ;
21981: LD_VAR 0 3
21985: RET
// export function Count ( array ) ; begin
21986: LD_INT 0
21988: PPUSH
// result := array + 0 ;
21989: LD_ADDR_VAR 0 2
21993: PUSH
21994: LD_VAR 0 1
21998: PUSH
21999: LD_INT 0
22001: PLUS
22002: ST_TO_ADDR
// end ;
22003: LD_VAR 0 2
22007: RET
// export function IsEmpty ( building ) ; begin
22008: LD_INT 0
22010: PPUSH
// if not building then
22011: LD_VAR 0 1
22015: NOT
22016: IFFALSE 22020
// exit ;
22018: GO 22063
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22020: LD_ADDR_VAR 0 2
22024: PUSH
22025: LD_VAR 0 1
22029: PUSH
22030: LD_INT 22
22032: PUSH
22033: LD_VAR 0 1
22037: PPUSH
22038: CALL_OW 255
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: PUSH
22047: LD_INT 58
22049: PUSH
22050: EMPTY
22051: LIST
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: PPUSH
22057: CALL_OW 69
22061: IN
22062: ST_TO_ADDR
// end ;
22063: LD_VAR 0 2
22067: RET
// export function IsNotFull ( building ) ; var places ; begin
22068: LD_INT 0
22070: PPUSH
22071: PPUSH
// if not building then
22072: LD_VAR 0 1
22076: NOT
22077: IFFALSE 22081
// exit ;
22079: GO 22109
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
22081: LD_ADDR_VAR 0 2
22085: PUSH
22086: LD_VAR 0 1
22090: PPUSH
22091: LD_INT 3
22093: PUSH
22094: LD_INT 62
22096: PUSH
22097: EMPTY
22098: LIST
22099: PUSH
22100: EMPTY
22101: LIST
22102: LIST
22103: PPUSH
22104: CALL_OW 72
22108: ST_TO_ADDR
// end ;
22109: LD_VAR 0 2
22113: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22114: LD_INT 0
22116: PPUSH
22117: PPUSH
22118: PPUSH
22119: PPUSH
// tmp := [ ] ;
22120: LD_ADDR_VAR 0 3
22124: PUSH
22125: EMPTY
22126: ST_TO_ADDR
// list := [ ] ;
22127: LD_ADDR_VAR 0 5
22131: PUSH
22132: EMPTY
22133: ST_TO_ADDR
// for i = 16 to 25 do
22134: LD_ADDR_VAR 0 4
22138: PUSH
22139: DOUBLE
22140: LD_INT 16
22142: DEC
22143: ST_TO_ADDR
22144: LD_INT 25
22146: PUSH
22147: FOR_TO
22148: IFFALSE 22221
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22150: LD_ADDR_VAR 0 3
22154: PUSH
22155: LD_VAR 0 3
22159: PUSH
22160: LD_INT 22
22162: PUSH
22163: LD_VAR 0 1
22167: PPUSH
22168: CALL_OW 255
22172: PUSH
22173: EMPTY
22174: LIST
22175: LIST
22176: PUSH
22177: LD_INT 91
22179: PUSH
22180: LD_VAR 0 1
22184: PUSH
22185: LD_INT 6
22187: PUSH
22188: EMPTY
22189: LIST
22190: LIST
22191: LIST
22192: PUSH
22193: LD_INT 30
22195: PUSH
22196: LD_VAR 0 4
22200: PUSH
22201: EMPTY
22202: LIST
22203: LIST
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: LIST
22209: PUSH
22210: EMPTY
22211: LIST
22212: PPUSH
22213: CALL_OW 69
22217: ADD
22218: ST_TO_ADDR
22219: GO 22147
22221: POP
22222: POP
// for i = 1 to tmp do
22223: LD_ADDR_VAR 0 4
22227: PUSH
22228: DOUBLE
22229: LD_INT 1
22231: DEC
22232: ST_TO_ADDR
22233: LD_VAR 0 3
22237: PUSH
22238: FOR_TO
22239: IFFALSE 22327
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22241: LD_ADDR_VAR 0 5
22245: PUSH
22246: LD_VAR 0 5
22250: PUSH
22251: LD_VAR 0 3
22255: PUSH
22256: LD_VAR 0 4
22260: ARRAY
22261: PPUSH
22262: CALL_OW 266
22266: PUSH
22267: LD_VAR 0 3
22271: PUSH
22272: LD_VAR 0 4
22276: ARRAY
22277: PPUSH
22278: CALL_OW 250
22282: PUSH
22283: LD_VAR 0 3
22287: PUSH
22288: LD_VAR 0 4
22292: ARRAY
22293: PPUSH
22294: CALL_OW 251
22298: PUSH
22299: LD_VAR 0 3
22303: PUSH
22304: LD_VAR 0 4
22308: ARRAY
22309: PPUSH
22310: CALL_OW 254
22314: PUSH
22315: EMPTY
22316: LIST
22317: LIST
22318: LIST
22319: LIST
22320: PUSH
22321: EMPTY
22322: LIST
22323: ADD
22324: ST_TO_ADDR
22325: GO 22238
22327: POP
22328: POP
// result := list ;
22329: LD_ADDR_VAR 0 2
22333: PUSH
22334: LD_VAR 0 5
22338: ST_TO_ADDR
// end ;
22339: LD_VAR 0 2
22343: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22344: LD_INT 0
22346: PPUSH
22347: PPUSH
22348: PPUSH
22349: PPUSH
22350: PPUSH
22351: PPUSH
22352: PPUSH
// if not factory then
22353: LD_VAR 0 1
22357: NOT
22358: IFFALSE 22362
// exit ;
22360: GO 22955
// if control = control_apeman then
22362: LD_VAR 0 4
22366: PUSH
22367: LD_INT 5
22369: EQUAL
22370: IFFALSE 22479
// begin tmp := UnitsInside ( factory ) ;
22372: LD_ADDR_VAR 0 8
22376: PUSH
22377: LD_VAR 0 1
22381: PPUSH
22382: CALL_OW 313
22386: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22387: LD_VAR 0 8
22391: PPUSH
22392: LD_INT 25
22394: PUSH
22395: LD_INT 12
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PPUSH
22402: CALL_OW 72
22406: NOT
22407: IFFALSE 22417
// control := control_manual ;
22409: LD_ADDR_VAR 0 4
22413: PUSH
22414: LD_INT 1
22416: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22417: LD_ADDR_VAR 0 8
22421: PUSH
22422: LD_VAR 0 1
22426: PPUSH
22427: CALL 22114 0 1
22431: ST_TO_ADDR
// if tmp then
22432: LD_VAR 0 8
22436: IFFALSE 22479
// begin for i in tmp do
22438: LD_ADDR_VAR 0 7
22442: PUSH
22443: LD_VAR 0 8
22447: PUSH
22448: FOR_IN
22449: IFFALSE 22477
// if i [ 1 ] = b_ext_radio then
22451: LD_VAR 0 7
22455: PUSH
22456: LD_INT 1
22458: ARRAY
22459: PUSH
22460: LD_INT 22
22462: EQUAL
22463: IFFALSE 22475
// begin control := control_remote ;
22465: LD_ADDR_VAR 0 4
22469: PUSH
22470: LD_INT 2
22472: ST_TO_ADDR
// break ;
22473: GO 22477
// end ;
22475: GO 22448
22477: POP
22478: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_VAR 0 2
22488: PPUSH
22489: LD_VAR 0 3
22493: PPUSH
22494: LD_VAR 0 4
22498: PPUSH
22499: LD_VAR 0 5
22503: PPUSH
22504: CALL_OW 448
22508: IFFALSE 22543
// begin result := [ chassis , engine , control , weapon ] ;
22510: LD_ADDR_VAR 0 6
22514: PUSH
22515: LD_VAR 0 2
22519: PUSH
22520: LD_VAR 0 3
22524: PUSH
22525: LD_VAR 0 4
22529: PUSH
22530: LD_VAR 0 5
22534: PUSH
22535: EMPTY
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: ST_TO_ADDR
// exit ;
22541: GO 22955
// end ; _chassis := AvailableChassisList ( factory ) ;
22543: LD_ADDR_VAR 0 9
22547: PUSH
22548: LD_VAR 0 1
22552: PPUSH
22553: CALL_OW 475
22557: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22558: LD_ADDR_VAR 0 11
22562: PUSH
22563: LD_VAR 0 1
22567: PPUSH
22568: CALL_OW 476
22572: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22573: LD_ADDR_VAR 0 12
22577: PUSH
22578: LD_VAR 0 1
22582: PPUSH
22583: CALL_OW 477
22587: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22588: LD_ADDR_VAR 0 10
22592: PUSH
22593: LD_VAR 0 1
22597: PPUSH
22598: CALL_OW 478
22602: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22603: LD_VAR 0 9
22607: NOT
22608: PUSH
22609: LD_VAR 0 11
22613: NOT
22614: OR
22615: PUSH
22616: LD_VAR 0 12
22620: NOT
22621: OR
22622: PUSH
22623: LD_VAR 0 10
22627: NOT
22628: OR
22629: IFFALSE 22664
// begin result := [ chassis , engine , control , weapon ] ;
22631: LD_ADDR_VAR 0 6
22635: PUSH
22636: LD_VAR 0 2
22640: PUSH
22641: LD_VAR 0 3
22645: PUSH
22646: LD_VAR 0 4
22650: PUSH
22651: LD_VAR 0 5
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: LIST
22660: LIST
22661: ST_TO_ADDR
// exit ;
22662: GO 22955
// end ; if not chassis in _chassis then
22664: LD_VAR 0 2
22668: PUSH
22669: LD_VAR 0 9
22673: IN
22674: NOT
22675: IFFALSE 22701
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22677: LD_ADDR_VAR 0 2
22681: PUSH
22682: LD_VAR 0 9
22686: PUSH
22687: LD_INT 1
22689: PPUSH
22690: LD_VAR 0 9
22694: PPUSH
22695: CALL_OW 12
22699: ARRAY
22700: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22701: LD_VAR 0 2
22705: PPUSH
22706: LD_VAR 0 3
22710: PPUSH
22711: CALL 22960 0 2
22715: NOT
22716: IFFALSE 22775
// repeat engine := _engine [ 1 ] ;
22718: LD_ADDR_VAR 0 3
22722: PUSH
22723: LD_VAR 0 11
22727: PUSH
22728: LD_INT 1
22730: ARRAY
22731: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22732: LD_ADDR_VAR 0 11
22736: PUSH
22737: LD_VAR 0 11
22741: PPUSH
22742: LD_INT 1
22744: PPUSH
22745: CALL_OW 3
22749: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22750: LD_VAR 0 2
22754: PPUSH
22755: LD_VAR 0 3
22759: PPUSH
22760: CALL 22960 0 2
22764: PUSH
22765: LD_VAR 0 11
22769: PUSH
22770: EMPTY
22771: EQUAL
22772: OR
22773: IFFALSE 22718
// if not control in _control then
22775: LD_VAR 0 4
22779: PUSH
22780: LD_VAR 0 12
22784: IN
22785: NOT
22786: IFFALSE 22812
// control := _control [ rand ( 1 , _control ) ] ;
22788: LD_ADDR_VAR 0 4
22792: PUSH
22793: LD_VAR 0 12
22797: PUSH
22798: LD_INT 1
22800: PPUSH
22801: LD_VAR 0 12
22805: PPUSH
22806: CALL_OW 12
22810: ARRAY
22811: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22812: LD_VAR 0 2
22816: PPUSH
22817: LD_VAR 0 5
22821: PPUSH
22822: CALL 23180 0 2
22826: NOT
22827: IFFALSE 22886
// repeat weapon := _weapon [ 1 ] ;
22829: LD_ADDR_VAR 0 5
22833: PUSH
22834: LD_VAR 0 10
22838: PUSH
22839: LD_INT 1
22841: ARRAY
22842: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22843: LD_ADDR_VAR 0 10
22847: PUSH
22848: LD_VAR 0 10
22852: PPUSH
22853: LD_INT 1
22855: PPUSH
22856: CALL_OW 3
22860: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22861: LD_VAR 0 2
22865: PPUSH
22866: LD_VAR 0 5
22870: PPUSH
22871: CALL 23180 0 2
22875: PUSH
22876: LD_VAR 0 10
22880: PUSH
22881: EMPTY
22882: EQUAL
22883: OR
22884: IFFALSE 22829
// result := [ ] ;
22886: LD_ADDR_VAR 0 6
22890: PUSH
22891: EMPTY
22892: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22893: LD_VAR 0 1
22897: PPUSH
22898: LD_VAR 0 2
22902: PPUSH
22903: LD_VAR 0 3
22907: PPUSH
22908: LD_VAR 0 4
22912: PPUSH
22913: LD_VAR 0 5
22917: PPUSH
22918: CALL_OW 448
22922: IFFALSE 22955
// result := [ chassis , engine , control , weapon ] ;
22924: LD_ADDR_VAR 0 6
22928: PUSH
22929: LD_VAR 0 2
22933: PUSH
22934: LD_VAR 0 3
22938: PUSH
22939: LD_VAR 0 4
22943: PUSH
22944: LD_VAR 0 5
22948: PUSH
22949: EMPTY
22950: LIST
22951: LIST
22952: LIST
22953: LIST
22954: ST_TO_ADDR
// end ;
22955: LD_VAR 0 6
22959: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22960: LD_INT 0
22962: PPUSH
// if not chassis or not engine then
22963: LD_VAR 0 1
22967: NOT
22968: PUSH
22969: LD_VAR 0 2
22973: NOT
22974: OR
22975: IFFALSE 22979
// exit ;
22977: GO 23175
// case engine of engine_solar :
22979: LD_VAR 0 2
22983: PUSH
22984: LD_INT 2
22986: DOUBLE
22987: EQUAL
22988: IFTRUE 22992
22990: GO 23030
22992: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22993: LD_ADDR_VAR 0 3
22997: PUSH
22998: LD_INT 11
23000: PUSH
23001: LD_INT 12
23003: PUSH
23004: LD_INT 13
23006: PUSH
23007: LD_INT 14
23009: PUSH
23010: LD_INT 1
23012: PUSH
23013: LD_INT 2
23015: PUSH
23016: LD_INT 3
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: LIST
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: ST_TO_ADDR
23028: GO 23159
23030: LD_INT 1
23032: DOUBLE
23033: EQUAL
23034: IFTRUE 23038
23036: GO 23100
23038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23039: LD_ADDR_VAR 0 3
23043: PUSH
23044: LD_INT 11
23046: PUSH
23047: LD_INT 12
23049: PUSH
23050: LD_INT 13
23052: PUSH
23053: LD_INT 14
23055: PUSH
23056: LD_INT 1
23058: PUSH
23059: LD_INT 2
23061: PUSH
23062: LD_INT 3
23064: PUSH
23065: LD_INT 4
23067: PUSH
23068: LD_INT 5
23070: PUSH
23071: LD_INT 21
23073: PUSH
23074: LD_INT 23
23076: PUSH
23077: LD_INT 22
23079: PUSH
23080: LD_INT 24
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: LIST
23087: LIST
23088: LIST
23089: LIST
23090: LIST
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: LIST
23096: LIST
23097: ST_TO_ADDR
23098: GO 23159
23100: LD_INT 3
23102: DOUBLE
23103: EQUAL
23104: IFTRUE 23108
23106: GO 23158
23108: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23109: LD_ADDR_VAR 0 3
23113: PUSH
23114: LD_INT 13
23116: PUSH
23117: LD_INT 14
23119: PUSH
23120: LD_INT 2
23122: PUSH
23123: LD_INT 3
23125: PUSH
23126: LD_INT 4
23128: PUSH
23129: LD_INT 5
23131: PUSH
23132: LD_INT 21
23134: PUSH
23135: LD_INT 22
23137: PUSH
23138: LD_INT 23
23140: PUSH
23141: LD_INT 24
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: LIST
23148: LIST
23149: LIST
23150: LIST
23151: LIST
23152: LIST
23153: LIST
23154: LIST
23155: ST_TO_ADDR
23156: GO 23159
23158: POP
// result := ( chassis in result ) ;
23159: LD_ADDR_VAR 0 3
23163: PUSH
23164: LD_VAR 0 1
23168: PUSH
23169: LD_VAR 0 3
23173: IN
23174: ST_TO_ADDR
// end ;
23175: LD_VAR 0 3
23179: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23180: LD_INT 0
23182: PPUSH
// if not chassis or not weapon then
23183: LD_VAR 0 1
23187: NOT
23188: PUSH
23189: LD_VAR 0 2
23193: NOT
23194: OR
23195: IFFALSE 23199
// exit ;
23197: GO 24259
// case weapon of us_machine_gun :
23199: LD_VAR 0 2
23203: PUSH
23204: LD_INT 2
23206: DOUBLE
23207: EQUAL
23208: IFTRUE 23212
23210: GO 23242
23212: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23213: LD_ADDR_VAR 0 3
23217: PUSH
23218: LD_INT 1
23220: PUSH
23221: LD_INT 2
23223: PUSH
23224: LD_INT 3
23226: PUSH
23227: LD_INT 4
23229: PUSH
23230: LD_INT 5
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: LIST
23239: ST_TO_ADDR
23240: GO 24243
23242: LD_INT 3
23244: DOUBLE
23245: EQUAL
23246: IFTRUE 23250
23248: GO 23280
23250: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23251: LD_ADDR_VAR 0 3
23255: PUSH
23256: LD_INT 1
23258: PUSH
23259: LD_INT 2
23261: PUSH
23262: LD_INT 3
23264: PUSH
23265: LD_INT 4
23267: PUSH
23268: LD_INT 5
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: LIST
23275: LIST
23276: LIST
23277: ST_TO_ADDR
23278: GO 24243
23280: LD_INT 11
23282: DOUBLE
23283: EQUAL
23284: IFTRUE 23288
23286: GO 23318
23288: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23289: LD_ADDR_VAR 0 3
23293: PUSH
23294: LD_INT 1
23296: PUSH
23297: LD_INT 2
23299: PUSH
23300: LD_INT 3
23302: PUSH
23303: LD_INT 4
23305: PUSH
23306: LD_INT 5
23308: PUSH
23309: EMPTY
23310: LIST
23311: LIST
23312: LIST
23313: LIST
23314: LIST
23315: ST_TO_ADDR
23316: GO 24243
23318: LD_INT 4
23320: DOUBLE
23321: EQUAL
23322: IFTRUE 23326
23324: GO 23352
23326: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23327: LD_ADDR_VAR 0 3
23331: PUSH
23332: LD_INT 2
23334: PUSH
23335: LD_INT 3
23337: PUSH
23338: LD_INT 4
23340: PUSH
23341: LD_INT 5
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: LIST
23348: LIST
23349: ST_TO_ADDR
23350: GO 24243
23352: LD_INT 5
23354: DOUBLE
23355: EQUAL
23356: IFTRUE 23360
23358: GO 23386
23360: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23361: LD_ADDR_VAR 0 3
23365: PUSH
23366: LD_INT 2
23368: PUSH
23369: LD_INT 3
23371: PUSH
23372: LD_INT 4
23374: PUSH
23375: LD_INT 5
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: LIST
23382: LIST
23383: ST_TO_ADDR
23384: GO 24243
23386: LD_INT 9
23388: DOUBLE
23389: EQUAL
23390: IFTRUE 23394
23392: GO 23420
23394: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23395: LD_ADDR_VAR 0 3
23399: PUSH
23400: LD_INT 2
23402: PUSH
23403: LD_INT 3
23405: PUSH
23406: LD_INT 4
23408: PUSH
23409: LD_INT 5
23411: PUSH
23412: EMPTY
23413: LIST
23414: LIST
23415: LIST
23416: LIST
23417: ST_TO_ADDR
23418: GO 24243
23420: LD_INT 7
23422: DOUBLE
23423: EQUAL
23424: IFTRUE 23428
23426: GO 23454
23428: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23429: LD_ADDR_VAR 0 3
23433: PUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 3
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: LD_INT 5
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: ST_TO_ADDR
23452: GO 24243
23454: LD_INT 12
23456: DOUBLE
23457: EQUAL
23458: IFTRUE 23462
23460: GO 23488
23462: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23463: LD_ADDR_VAR 0 3
23467: PUSH
23468: LD_INT 2
23470: PUSH
23471: LD_INT 3
23473: PUSH
23474: LD_INT 4
23476: PUSH
23477: LD_INT 5
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: LIST
23484: LIST
23485: ST_TO_ADDR
23486: GO 24243
23488: LD_INT 13
23490: DOUBLE
23491: EQUAL
23492: IFTRUE 23496
23494: GO 23522
23496: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23497: LD_ADDR_VAR 0 3
23501: PUSH
23502: LD_INT 2
23504: PUSH
23505: LD_INT 3
23507: PUSH
23508: LD_INT 4
23510: PUSH
23511: LD_INT 5
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: LIST
23518: LIST
23519: ST_TO_ADDR
23520: GO 24243
23522: LD_INT 14
23524: DOUBLE
23525: EQUAL
23526: IFTRUE 23530
23528: GO 23548
23530: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23531: LD_ADDR_VAR 0 3
23535: PUSH
23536: LD_INT 4
23538: PUSH
23539: LD_INT 5
23541: PUSH
23542: EMPTY
23543: LIST
23544: LIST
23545: ST_TO_ADDR
23546: GO 24243
23548: LD_INT 6
23550: DOUBLE
23551: EQUAL
23552: IFTRUE 23556
23554: GO 23574
23556: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23557: LD_ADDR_VAR 0 3
23561: PUSH
23562: LD_INT 4
23564: PUSH
23565: LD_INT 5
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: ST_TO_ADDR
23572: GO 24243
23574: LD_INT 10
23576: DOUBLE
23577: EQUAL
23578: IFTRUE 23582
23580: GO 23600
23582: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23583: LD_ADDR_VAR 0 3
23587: PUSH
23588: LD_INT 4
23590: PUSH
23591: LD_INT 5
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: ST_TO_ADDR
23598: GO 24243
23600: LD_INT 22
23602: DOUBLE
23603: EQUAL
23604: IFTRUE 23608
23606: GO 23634
23608: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23609: LD_ADDR_VAR 0 3
23613: PUSH
23614: LD_INT 11
23616: PUSH
23617: LD_INT 12
23619: PUSH
23620: LD_INT 13
23622: PUSH
23623: LD_INT 14
23625: PUSH
23626: EMPTY
23627: LIST
23628: LIST
23629: LIST
23630: LIST
23631: ST_TO_ADDR
23632: GO 24243
23634: LD_INT 23
23636: DOUBLE
23637: EQUAL
23638: IFTRUE 23642
23640: GO 23668
23642: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23643: LD_ADDR_VAR 0 3
23647: PUSH
23648: LD_INT 11
23650: PUSH
23651: LD_INT 12
23653: PUSH
23654: LD_INT 13
23656: PUSH
23657: LD_INT 14
23659: PUSH
23660: EMPTY
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: ST_TO_ADDR
23666: GO 24243
23668: LD_INT 24
23670: DOUBLE
23671: EQUAL
23672: IFTRUE 23676
23674: GO 23702
23676: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23677: LD_ADDR_VAR 0 3
23681: PUSH
23682: LD_INT 11
23684: PUSH
23685: LD_INT 12
23687: PUSH
23688: LD_INT 13
23690: PUSH
23691: LD_INT 14
23693: PUSH
23694: EMPTY
23695: LIST
23696: LIST
23697: LIST
23698: LIST
23699: ST_TO_ADDR
23700: GO 24243
23702: LD_INT 30
23704: DOUBLE
23705: EQUAL
23706: IFTRUE 23710
23708: GO 23736
23710: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23711: LD_ADDR_VAR 0 3
23715: PUSH
23716: LD_INT 11
23718: PUSH
23719: LD_INT 12
23721: PUSH
23722: LD_INT 13
23724: PUSH
23725: LD_INT 14
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: LIST
23732: LIST
23733: ST_TO_ADDR
23734: GO 24243
23736: LD_INT 25
23738: DOUBLE
23739: EQUAL
23740: IFTRUE 23744
23742: GO 23762
23744: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23745: LD_ADDR_VAR 0 3
23749: PUSH
23750: LD_INT 13
23752: PUSH
23753: LD_INT 14
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: ST_TO_ADDR
23760: GO 24243
23762: LD_INT 27
23764: DOUBLE
23765: EQUAL
23766: IFTRUE 23770
23768: GO 23788
23770: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23771: LD_ADDR_VAR 0 3
23775: PUSH
23776: LD_INT 13
23778: PUSH
23779: LD_INT 14
23781: PUSH
23782: EMPTY
23783: LIST
23784: LIST
23785: ST_TO_ADDR
23786: GO 24243
23788: LD_INT 92
23790: DOUBLE
23791: EQUAL
23792: IFTRUE 23796
23794: GO 23822
23796: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23797: LD_ADDR_VAR 0 3
23801: PUSH
23802: LD_INT 11
23804: PUSH
23805: LD_INT 12
23807: PUSH
23808: LD_INT 13
23810: PUSH
23811: LD_INT 14
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: LIST
23818: LIST
23819: ST_TO_ADDR
23820: GO 24243
23822: LD_INT 28
23824: DOUBLE
23825: EQUAL
23826: IFTRUE 23830
23828: GO 23848
23830: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23831: LD_ADDR_VAR 0 3
23835: PUSH
23836: LD_INT 13
23838: PUSH
23839: LD_INT 14
23841: PUSH
23842: EMPTY
23843: LIST
23844: LIST
23845: ST_TO_ADDR
23846: GO 24243
23848: LD_INT 29
23850: DOUBLE
23851: EQUAL
23852: IFTRUE 23856
23854: GO 23874
23856: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23857: LD_ADDR_VAR 0 3
23861: PUSH
23862: LD_INT 13
23864: PUSH
23865: LD_INT 14
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: ST_TO_ADDR
23872: GO 24243
23874: LD_INT 31
23876: DOUBLE
23877: EQUAL
23878: IFTRUE 23882
23880: GO 23900
23882: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23883: LD_ADDR_VAR 0 3
23887: PUSH
23888: LD_INT 13
23890: PUSH
23891: LD_INT 14
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: ST_TO_ADDR
23898: GO 24243
23900: LD_INT 26
23902: DOUBLE
23903: EQUAL
23904: IFTRUE 23908
23906: GO 23926
23908: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23909: LD_ADDR_VAR 0 3
23913: PUSH
23914: LD_INT 13
23916: PUSH
23917: LD_INT 14
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: ST_TO_ADDR
23924: GO 24243
23926: LD_INT 42
23928: DOUBLE
23929: EQUAL
23930: IFTRUE 23934
23932: GO 23960
23934: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23935: LD_ADDR_VAR 0 3
23939: PUSH
23940: LD_INT 21
23942: PUSH
23943: LD_INT 22
23945: PUSH
23946: LD_INT 23
23948: PUSH
23949: LD_INT 24
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: LIST
23956: LIST
23957: ST_TO_ADDR
23958: GO 24243
23960: LD_INT 43
23962: DOUBLE
23963: EQUAL
23964: IFTRUE 23968
23966: GO 23994
23968: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23969: LD_ADDR_VAR 0 3
23973: PUSH
23974: LD_INT 21
23976: PUSH
23977: LD_INT 22
23979: PUSH
23980: LD_INT 23
23982: PUSH
23983: LD_INT 24
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: LIST
23990: LIST
23991: ST_TO_ADDR
23992: GO 24243
23994: LD_INT 44
23996: DOUBLE
23997: EQUAL
23998: IFTRUE 24002
24000: GO 24028
24002: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24003: LD_ADDR_VAR 0 3
24007: PUSH
24008: LD_INT 21
24010: PUSH
24011: LD_INT 22
24013: PUSH
24014: LD_INT 23
24016: PUSH
24017: LD_INT 24
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: LIST
24024: LIST
24025: ST_TO_ADDR
24026: GO 24243
24028: LD_INT 45
24030: DOUBLE
24031: EQUAL
24032: IFTRUE 24036
24034: GO 24062
24036: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24037: LD_ADDR_VAR 0 3
24041: PUSH
24042: LD_INT 21
24044: PUSH
24045: LD_INT 22
24047: PUSH
24048: LD_INT 23
24050: PUSH
24051: LD_INT 24
24053: PUSH
24054: EMPTY
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: ST_TO_ADDR
24060: GO 24243
24062: LD_INT 49
24064: DOUBLE
24065: EQUAL
24066: IFTRUE 24070
24068: GO 24096
24070: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24071: LD_ADDR_VAR 0 3
24075: PUSH
24076: LD_INT 21
24078: PUSH
24079: LD_INT 22
24081: PUSH
24082: LD_INT 23
24084: PUSH
24085: LD_INT 24
24087: PUSH
24088: EMPTY
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: ST_TO_ADDR
24094: GO 24243
24096: LD_INT 51
24098: DOUBLE
24099: EQUAL
24100: IFTRUE 24104
24102: GO 24130
24104: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24105: LD_ADDR_VAR 0 3
24109: PUSH
24110: LD_INT 21
24112: PUSH
24113: LD_INT 22
24115: PUSH
24116: LD_INT 23
24118: PUSH
24119: LD_INT 24
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: ST_TO_ADDR
24128: GO 24243
24130: LD_INT 52
24132: DOUBLE
24133: EQUAL
24134: IFTRUE 24138
24136: GO 24164
24138: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24139: LD_ADDR_VAR 0 3
24143: PUSH
24144: LD_INT 21
24146: PUSH
24147: LD_INT 22
24149: PUSH
24150: LD_INT 23
24152: PUSH
24153: LD_INT 24
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: LIST
24160: LIST
24161: ST_TO_ADDR
24162: GO 24243
24164: LD_INT 53
24166: DOUBLE
24167: EQUAL
24168: IFTRUE 24172
24170: GO 24190
24172: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24173: LD_ADDR_VAR 0 3
24177: PUSH
24178: LD_INT 23
24180: PUSH
24181: LD_INT 24
24183: PUSH
24184: EMPTY
24185: LIST
24186: LIST
24187: ST_TO_ADDR
24188: GO 24243
24190: LD_INT 46
24192: DOUBLE
24193: EQUAL
24194: IFTRUE 24198
24196: GO 24216
24198: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24199: LD_ADDR_VAR 0 3
24203: PUSH
24204: LD_INT 23
24206: PUSH
24207: LD_INT 24
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: ST_TO_ADDR
24214: GO 24243
24216: LD_INT 47
24218: DOUBLE
24219: EQUAL
24220: IFTRUE 24224
24222: GO 24242
24224: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24225: LD_ADDR_VAR 0 3
24229: PUSH
24230: LD_INT 23
24232: PUSH
24233: LD_INT 24
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: ST_TO_ADDR
24240: GO 24243
24242: POP
// result := ( chassis in result ) ;
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 1
24252: PUSH
24253: LD_VAR 0 3
24257: IN
24258: ST_TO_ADDR
// end ;
24259: LD_VAR 0 3
24263: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24264: LD_INT 0
24266: PPUSH
24267: PPUSH
24268: PPUSH
24269: PPUSH
24270: PPUSH
24271: PPUSH
24272: PPUSH
// result := array ;
24273: LD_ADDR_VAR 0 5
24277: PUSH
24278: LD_VAR 0 1
24282: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24283: LD_VAR 0 1
24287: NOT
24288: PUSH
24289: LD_VAR 0 2
24293: NOT
24294: OR
24295: PUSH
24296: LD_VAR 0 3
24300: NOT
24301: OR
24302: PUSH
24303: LD_VAR 0 2
24307: PUSH
24308: LD_VAR 0 1
24312: GREATER
24313: OR
24314: PUSH
24315: LD_VAR 0 3
24319: PUSH
24320: LD_VAR 0 1
24324: GREATER
24325: OR
24326: IFFALSE 24330
// exit ;
24328: GO 24626
// if direction then
24330: LD_VAR 0 4
24334: IFFALSE 24398
// begin d := 1 ;
24336: LD_ADDR_VAR 0 9
24340: PUSH
24341: LD_INT 1
24343: ST_TO_ADDR
// if i_from > i_to then
24344: LD_VAR 0 2
24348: PUSH
24349: LD_VAR 0 3
24353: GREATER
24354: IFFALSE 24380
// length := ( array - i_from ) + i_to else
24356: LD_ADDR_VAR 0 11
24360: PUSH
24361: LD_VAR 0 1
24365: PUSH
24366: LD_VAR 0 2
24370: MINUS
24371: PUSH
24372: LD_VAR 0 3
24376: PLUS
24377: ST_TO_ADDR
24378: GO 24396
// length := i_to - i_from ;
24380: LD_ADDR_VAR 0 11
24384: PUSH
24385: LD_VAR 0 3
24389: PUSH
24390: LD_VAR 0 2
24394: MINUS
24395: ST_TO_ADDR
// end else
24396: GO 24459
// begin d := - 1 ;
24398: LD_ADDR_VAR 0 9
24402: PUSH
24403: LD_INT 1
24405: NEG
24406: ST_TO_ADDR
// if i_from > i_to then
24407: LD_VAR 0 2
24411: PUSH
24412: LD_VAR 0 3
24416: GREATER
24417: IFFALSE 24437
// length := i_from - i_to else
24419: LD_ADDR_VAR 0 11
24423: PUSH
24424: LD_VAR 0 2
24428: PUSH
24429: LD_VAR 0 3
24433: MINUS
24434: ST_TO_ADDR
24435: GO 24459
// length := ( array - i_to ) + i_from ;
24437: LD_ADDR_VAR 0 11
24441: PUSH
24442: LD_VAR 0 1
24446: PUSH
24447: LD_VAR 0 3
24451: MINUS
24452: PUSH
24453: LD_VAR 0 2
24457: PLUS
24458: ST_TO_ADDR
// end ; if not length then
24459: LD_VAR 0 11
24463: NOT
24464: IFFALSE 24468
// exit ;
24466: GO 24626
// tmp := array ;
24468: LD_ADDR_VAR 0 10
24472: PUSH
24473: LD_VAR 0 1
24477: ST_TO_ADDR
// for i = 1 to length do
24478: LD_ADDR_VAR 0 6
24482: PUSH
24483: DOUBLE
24484: LD_INT 1
24486: DEC
24487: ST_TO_ADDR
24488: LD_VAR 0 11
24492: PUSH
24493: FOR_TO
24494: IFFALSE 24614
// begin for j = 1 to array do
24496: LD_ADDR_VAR 0 7
24500: PUSH
24501: DOUBLE
24502: LD_INT 1
24504: DEC
24505: ST_TO_ADDR
24506: LD_VAR 0 1
24510: PUSH
24511: FOR_TO
24512: IFFALSE 24600
// begin k := j + d ;
24514: LD_ADDR_VAR 0 8
24518: PUSH
24519: LD_VAR 0 7
24523: PUSH
24524: LD_VAR 0 9
24528: PLUS
24529: ST_TO_ADDR
// if k > array then
24530: LD_VAR 0 8
24534: PUSH
24535: LD_VAR 0 1
24539: GREATER
24540: IFFALSE 24550
// k := 1 ;
24542: LD_ADDR_VAR 0 8
24546: PUSH
24547: LD_INT 1
24549: ST_TO_ADDR
// if not k then
24550: LD_VAR 0 8
24554: NOT
24555: IFFALSE 24567
// k := array ;
24557: LD_ADDR_VAR 0 8
24561: PUSH
24562: LD_VAR 0 1
24566: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24567: LD_ADDR_VAR 0 10
24571: PUSH
24572: LD_VAR 0 10
24576: PPUSH
24577: LD_VAR 0 8
24581: PPUSH
24582: LD_VAR 0 1
24586: PUSH
24587: LD_VAR 0 7
24591: ARRAY
24592: PPUSH
24593: CALL_OW 1
24597: ST_TO_ADDR
// end ;
24598: GO 24511
24600: POP
24601: POP
// array := tmp ;
24602: LD_ADDR_VAR 0 1
24606: PUSH
24607: LD_VAR 0 10
24611: ST_TO_ADDR
// end ;
24612: GO 24493
24614: POP
24615: POP
// result := array ;
24616: LD_ADDR_VAR 0 5
24620: PUSH
24621: LD_VAR 0 1
24625: ST_TO_ADDR
// end ;
24626: LD_VAR 0 5
24630: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24631: LD_INT 0
24633: PPUSH
24634: PPUSH
// result := 0 ;
24635: LD_ADDR_VAR 0 3
24639: PUSH
24640: LD_INT 0
24642: ST_TO_ADDR
// if not array or not value in array then
24643: LD_VAR 0 1
24647: NOT
24648: PUSH
24649: LD_VAR 0 2
24653: PUSH
24654: LD_VAR 0 1
24658: IN
24659: NOT
24660: OR
24661: IFFALSE 24665
// exit ;
24663: GO 24719
// for i = 1 to array do
24665: LD_ADDR_VAR 0 4
24669: PUSH
24670: DOUBLE
24671: LD_INT 1
24673: DEC
24674: ST_TO_ADDR
24675: LD_VAR 0 1
24679: PUSH
24680: FOR_TO
24681: IFFALSE 24717
// if value = array [ i ] then
24683: LD_VAR 0 2
24687: PUSH
24688: LD_VAR 0 1
24692: PUSH
24693: LD_VAR 0 4
24697: ARRAY
24698: EQUAL
24699: IFFALSE 24715
// begin result := i ;
24701: LD_ADDR_VAR 0 3
24705: PUSH
24706: LD_VAR 0 4
24710: ST_TO_ADDR
// exit ;
24711: POP
24712: POP
24713: GO 24719
// end ;
24715: GO 24680
24717: POP
24718: POP
// end ;
24719: LD_VAR 0 3
24723: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24724: LD_INT 0
24726: PPUSH
// vc_chassis := chassis ;
24727: LD_ADDR_OWVAR 37
24731: PUSH
24732: LD_VAR 0 1
24736: ST_TO_ADDR
// vc_engine := engine ;
24737: LD_ADDR_OWVAR 39
24741: PUSH
24742: LD_VAR 0 2
24746: ST_TO_ADDR
// vc_control := control ;
24747: LD_ADDR_OWVAR 38
24751: PUSH
24752: LD_VAR 0 3
24756: ST_TO_ADDR
// vc_weapon := weapon ;
24757: LD_ADDR_OWVAR 40
24761: PUSH
24762: LD_VAR 0 4
24766: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24767: LD_ADDR_OWVAR 41
24771: PUSH
24772: LD_VAR 0 5
24776: ST_TO_ADDR
// end ;
24777: LD_VAR 0 6
24781: RET
// export function WantPlant ( unit ) ; var task ; begin
24782: LD_INT 0
24784: PPUSH
24785: PPUSH
// result := false ;
24786: LD_ADDR_VAR 0 2
24790: PUSH
24791: LD_INT 0
24793: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24794: LD_ADDR_VAR 0 3
24798: PUSH
24799: LD_VAR 0 1
24803: PPUSH
24804: CALL_OW 437
24808: ST_TO_ADDR
// if task then
24809: LD_VAR 0 3
24813: IFFALSE 24841
// if task [ 1 ] [ 1 ] = p then
24815: LD_VAR 0 3
24819: PUSH
24820: LD_INT 1
24822: ARRAY
24823: PUSH
24824: LD_INT 1
24826: ARRAY
24827: PUSH
24828: LD_STRING p
24830: EQUAL
24831: IFFALSE 24841
// result := true ;
24833: LD_ADDR_VAR 0 2
24837: PUSH
24838: LD_INT 1
24840: ST_TO_ADDR
// end ;
24841: LD_VAR 0 2
24845: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24846: LD_INT 0
24848: PPUSH
24849: PPUSH
24850: PPUSH
24851: PPUSH
// if pos < 1 then
24852: LD_VAR 0 2
24856: PUSH
24857: LD_INT 1
24859: LESS
24860: IFFALSE 24864
// exit ;
24862: GO 25167
// if pos = 1 then
24864: LD_VAR 0 2
24868: PUSH
24869: LD_INT 1
24871: EQUAL
24872: IFFALSE 24905
// result := Replace ( arr , pos [ 1 ] , value ) else
24874: LD_ADDR_VAR 0 4
24878: PUSH
24879: LD_VAR 0 1
24883: PPUSH
24884: LD_VAR 0 2
24888: PUSH
24889: LD_INT 1
24891: ARRAY
24892: PPUSH
24893: LD_VAR 0 3
24897: PPUSH
24898: CALL_OW 1
24902: ST_TO_ADDR
24903: GO 25167
// begin tmp := arr ;
24905: LD_ADDR_VAR 0 6
24909: PUSH
24910: LD_VAR 0 1
24914: ST_TO_ADDR
// s_arr := [ tmp ] ;
24915: LD_ADDR_VAR 0 7
24919: PUSH
24920: LD_VAR 0 6
24924: PUSH
24925: EMPTY
24926: LIST
24927: ST_TO_ADDR
// for i = 1 to pos - 1 do
24928: LD_ADDR_VAR 0 5
24932: PUSH
24933: DOUBLE
24934: LD_INT 1
24936: DEC
24937: ST_TO_ADDR
24938: LD_VAR 0 2
24942: PUSH
24943: LD_INT 1
24945: MINUS
24946: PUSH
24947: FOR_TO
24948: IFFALSE 24993
// begin tmp := tmp [ pos [ i ] ] ;
24950: LD_ADDR_VAR 0 6
24954: PUSH
24955: LD_VAR 0 6
24959: PUSH
24960: LD_VAR 0 2
24964: PUSH
24965: LD_VAR 0 5
24969: ARRAY
24970: ARRAY
24971: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24972: LD_ADDR_VAR 0 7
24976: PUSH
24977: LD_VAR 0 7
24981: PUSH
24982: LD_VAR 0 6
24986: PUSH
24987: EMPTY
24988: LIST
24989: ADD
24990: ST_TO_ADDR
// end ;
24991: GO 24947
24993: POP
24994: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24995: LD_ADDR_VAR 0 6
24999: PUSH
25000: LD_VAR 0 6
25004: PPUSH
25005: LD_VAR 0 2
25009: PUSH
25010: LD_VAR 0 2
25014: ARRAY
25015: PPUSH
25016: LD_VAR 0 3
25020: PPUSH
25021: CALL_OW 1
25025: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25026: LD_ADDR_VAR 0 7
25030: PUSH
25031: LD_VAR 0 7
25035: PPUSH
25036: LD_VAR 0 7
25040: PPUSH
25041: LD_VAR 0 6
25045: PPUSH
25046: CALL_OW 1
25050: ST_TO_ADDR
// for i = s_arr downto 2 do
25051: LD_ADDR_VAR 0 5
25055: PUSH
25056: DOUBLE
25057: LD_VAR 0 7
25061: INC
25062: ST_TO_ADDR
25063: LD_INT 2
25065: PUSH
25066: FOR_DOWNTO
25067: IFFALSE 25151
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25069: LD_ADDR_VAR 0 6
25073: PUSH
25074: LD_VAR 0 7
25078: PUSH
25079: LD_VAR 0 5
25083: PUSH
25084: LD_INT 1
25086: MINUS
25087: ARRAY
25088: PPUSH
25089: LD_VAR 0 2
25093: PUSH
25094: LD_VAR 0 5
25098: PUSH
25099: LD_INT 1
25101: MINUS
25102: ARRAY
25103: PPUSH
25104: LD_VAR 0 7
25108: PUSH
25109: LD_VAR 0 5
25113: ARRAY
25114: PPUSH
25115: CALL_OW 1
25119: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25120: LD_ADDR_VAR 0 7
25124: PUSH
25125: LD_VAR 0 7
25129: PPUSH
25130: LD_VAR 0 5
25134: PUSH
25135: LD_INT 1
25137: MINUS
25138: PPUSH
25139: LD_VAR 0 6
25143: PPUSH
25144: CALL_OW 1
25148: ST_TO_ADDR
// end ;
25149: GO 25066
25151: POP
25152: POP
// result := s_arr [ 1 ] ;
25153: LD_ADDR_VAR 0 4
25157: PUSH
25158: LD_VAR 0 7
25162: PUSH
25163: LD_INT 1
25165: ARRAY
25166: ST_TO_ADDR
// end ; end ;
25167: LD_VAR 0 4
25171: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25172: LD_INT 0
25174: PPUSH
25175: PPUSH
// if not list then
25176: LD_VAR 0 1
25180: NOT
25181: IFFALSE 25185
// exit ;
25183: GO 25276
// i := list [ pos1 ] ;
25185: LD_ADDR_VAR 0 5
25189: PUSH
25190: LD_VAR 0 1
25194: PUSH
25195: LD_VAR 0 2
25199: ARRAY
25200: ST_TO_ADDR
// if not i then
25201: LD_VAR 0 5
25205: NOT
25206: IFFALSE 25210
// exit ;
25208: GO 25276
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_VAR 0 1
25219: PPUSH
25220: LD_VAR 0 2
25224: PPUSH
25225: LD_VAR 0 1
25229: PUSH
25230: LD_VAR 0 3
25234: ARRAY
25235: PPUSH
25236: CALL_OW 1
25240: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25241: LD_ADDR_VAR 0 1
25245: PUSH
25246: LD_VAR 0 1
25250: PPUSH
25251: LD_VAR 0 3
25255: PPUSH
25256: LD_VAR 0 5
25260: PPUSH
25261: CALL_OW 1
25265: ST_TO_ADDR
// result := list ;
25266: LD_ADDR_VAR 0 4
25270: PUSH
25271: LD_VAR 0 1
25275: ST_TO_ADDR
// end ;
25276: LD_VAR 0 4
25280: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25281: LD_INT 0
25283: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25284: LD_ADDR_VAR 0 5
25288: PUSH
25289: LD_VAR 0 1
25293: PPUSH
25294: CALL_OW 250
25298: PPUSH
25299: LD_VAR 0 1
25303: PPUSH
25304: CALL_OW 251
25308: PPUSH
25309: LD_VAR 0 2
25313: PPUSH
25314: LD_VAR 0 3
25318: PPUSH
25319: LD_VAR 0 4
25323: PPUSH
25324: CALL 25334 0 5
25328: ST_TO_ADDR
// end ;
25329: LD_VAR 0 5
25333: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25334: LD_INT 0
25336: PPUSH
25337: PPUSH
25338: PPUSH
25339: PPUSH
// if not list then
25340: LD_VAR 0 3
25344: NOT
25345: IFFALSE 25349
// exit ;
25347: GO 25737
// result := [ ] ;
25349: LD_ADDR_VAR 0 6
25353: PUSH
25354: EMPTY
25355: ST_TO_ADDR
// for i in list do
25356: LD_ADDR_VAR 0 7
25360: PUSH
25361: LD_VAR 0 3
25365: PUSH
25366: FOR_IN
25367: IFFALSE 25569
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25369: LD_ADDR_VAR 0 9
25373: PUSH
25374: LD_VAR 0 7
25378: PPUSH
25379: LD_VAR 0 1
25383: PPUSH
25384: LD_VAR 0 2
25388: PPUSH
25389: CALL_OW 297
25393: ST_TO_ADDR
// if not result then
25394: LD_VAR 0 6
25398: NOT
25399: IFFALSE 25425
// result := [ [ i , tmp ] ] else
25401: LD_ADDR_VAR 0 6
25405: PUSH
25406: LD_VAR 0 7
25410: PUSH
25411: LD_VAR 0 9
25415: PUSH
25416: EMPTY
25417: LIST
25418: LIST
25419: PUSH
25420: EMPTY
25421: LIST
25422: ST_TO_ADDR
25423: GO 25567
// begin if result [ result ] [ 2 ] < tmp then
25425: LD_VAR 0 6
25429: PUSH
25430: LD_VAR 0 6
25434: ARRAY
25435: PUSH
25436: LD_INT 2
25438: ARRAY
25439: PUSH
25440: LD_VAR 0 9
25444: LESS
25445: IFFALSE 25487
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25447: LD_ADDR_VAR 0 6
25451: PUSH
25452: LD_VAR 0 6
25456: PPUSH
25457: LD_VAR 0 6
25461: PUSH
25462: LD_INT 1
25464: PLUS
25465: PPUSH
25466: LD_VAR 0 7
25470: PUSH
25471: LD_VAR 0 9
25475: PUSH
25476: EMPTY
25477: LIST
25478: LIST
25479: PPUSH
25480: CALL_OW 2
25484: ST_TO_ADDR
25485: GO 25567
// for j = 1 to result do
25487: LD_ADDR_VAR 0 8
25491: PUSH
25492: DOUBLE
25493: LD_INT 1
25495: DEC
25496: ST_TO_ADDR
25497: LD_VAR 0 6
25501: PUSH
25502: FOR_TO
25503: IFFALSE 25565
// begin if tmp < result [ j ] [ 2 ] then
25505: LD_VAR 0 9
25509: PUSH
25510: LD_VAR 0 6
25514: PUSH
25515: LD_VAR 0 8
25519: ARRAY
25520: PUSH
25521: LD_INT 2
25523: ARRAY
25524: LESS
25525: IFFALSE 25563
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25527: LD_ADDR_VAR 0 6
25531: PUSH
25532: LD_VAR 0 6
25536: PPUSH
25537: LD_VAR 0 8
25541: PPUSH
25542: LD_VAR 0 7
25546: PUSH
25547: LD_VAR 0 9
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PPUSH
25556: CALL_OW 2
25560: ST_TO_ADDR
// break ;
25561: GO 25565
// end ; end ;
25563: GO 25502
25565: POP
25566: POP
// end ; end ;
25567: GO 25366
25569: POP
25570: POP
// if result and not asc then
25571: LD_VAR 0 6
25575: PUSH
25576: LD_VAR 0 4
25580: NOT
25581: AND
25582: IFFALSE 25657
// begin tmp := result ;
25584: LD_ADDR_VAR 0 9
25588: PUSH
25589: LD_VAR 0 6
25593: ST_TO_ADDR
// for i = tmp downto 1 do
25594: LD_ADDR_VAR 0 7
25598: PUSH
25599: DOUBLE
25600: LD_VAR 0 9
25604: INC
25605: ST_TO_ADDR
25606: LD_INT 1
25608: PUSH
25609: FOR_DOWNTO
25610: IFFALSE 25655
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25612: LD_ADDR_VAR 0 6
25616: PUSH
25617: LD_VAR 0 6
25621: PPUSH
25622: LD_VAR 0 9
25626: PUSH
25627: LD_VAR 0 7
25631: MINUS
25632: PUSH
25633: LD_INT 1
25635: PLUS
25636: PPUSH
25637: LD_VAR 0 9
25641: PUSH
25642: LD_VAR 0 7
25646: ARRAY
25647: PPUSH
25648: CALL_OW 1
25652: ST_TO_ADDR
25653: GO 25609
25655: POP
25656: POP
// end ; tmp := [ ] ;
25657: LD_ADDR_VAR 0 9
25661: PUSH
25662: EMPTY
25663: ST_TO_ADDR
// if mode then
25664: LD_VAR 0 5
25668: IFFALSE 25737
// begin for i = 1 to result do
25670: LD_ADDR_VAR 0 7
25674: PUSH
25675: DOUBLE
25676: LD_INT 1
25678: DEC
25679: ST_TO_ADDR
25680: LD_VAR 0 6
25684: PUSH
25685: FOR_TO
25686: IFFALSE 25725
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25688: LD_ADDR_VAR 0 9
25692: PUSH
25693: LD_VAR 0 9
25697: PPUSH
25698: LD_VAR 0 7
25702: PPUSH
25703: LD_VAR 0 6
25707: PUSH
25708: LD_VAR 0 7
25712: ARRAY
25713: PUSH
25714: LD_INT 1
25716: ARRAY
25717: PPUSH
25718: CALL_OW 1
25722: ST_TO_ADDR
25723: GO 25685
25725: POP
25726: POP
// result := tmp ;
25727: LD_ADDR_VAR 0 6
25731: PUSH
25732: LD_VAR 0 9
25736: ST_TO_ADDR
// end ; end ;
25737: LD_VAR 0 6
25741: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25742: LD_INT 0
25744: PPUSH
25745: PPUSH
25746: PPUSH
25747: PPUSH
25748: PPUSH
25749: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25750: LD_ADDR_VAR 0 5
25754: PUSH
25755: LD_INT 0
25757: PUSH
25758: LD_INT 0
25760: PUSH
25761: LD_INT 0
25763: PUSH
25764: EMPTY
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: LIST
25770: LIST
25771: ST_TO_ADDR
// if not x or not y then
25772: LD_VAR 0 2
25776: NOT
25777: PUSH
25778: LD_VAR 0 3
25782: NOT
25783: OR
25784: IFFALSE 25788
// exit ;
25786: GO 27438
// if not range then
25788: LD_VAR 0 4
25792: NOT
25793: IFFALSE 25803
// range := 10 ;
25795: LD_ADDR_VAR 0 4
25799: PUSH
25800: LD_INT 10
25802: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25803: LD_ADDR_VAR 0 8
25807: PUSH
25808: LD_INT 81
25810: PUSH
25811: LD_VAR 0 1
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 92
25822: PUSH
25823: LD_VAR 0 2
25827: PUSH
25828: LD_VAR 0 3
25832: PUSH
25833: LD_VAR 0 4
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: LIST
25842: LIST
25843: PUSH
25844: LD_INT 3
25846: PUSH
25847: LD_INT 21
25849: PUSH
25850: LD_INT 3
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: LIST
25865: PPUSH
25866: CALL_OW 69
25870: ST_TO_ADDR
// if not tmp then
25871: LD_VAR 0 8
25875: NOT
25876: IFFALSE 25880
// exit ;
25878: GO 27438
// for i in tmp do
25880: LD_ADDR_VAR 0 6
25884: PUSH
25885: LD_VAR 0 8
25889: PUSH
25890: FOR_IN
25891: IFFALSE 27413
// begin points := [ 0 , 0 , 0 ] ;
25893: LD_ADDR_VAR 0 9
25897: PUSH
25898: LD_INT 0
25900: PUSH
25901: LD_INT 0
25903: PUSH
25904: LD_INT 0
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: LIST
25911: ST_TO_ADDR
// bpoints := 1 ;
25912: LD_ADDR_VAR 0 10
25916: PUSH
25917: LD_INT 1
25919: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25920: LD_VAR 0 6
25924: PPUSH
25925: CALL_OW 247
25929: PUSH
25930: LD_INT 1
25932: DOUBLE
25933: EQUAL
25934: IFTRUE 25938
25936: GO 26516
25938: POP
// begin if GetClass ( i ) = 1 then
25939: LD_VAR 0 6
25943: PPUSH
25944: CALL_OW 257
25948: PUSH
25949: LD_INT 1
25951: EQUAL
25952: IFFALSE 25973
// points := [ 10 , 5 , 3 ] ;
25954: LD_ADDR_VAR 0 9
25958: PUSH
25959: LD_INT 10
25961: PUSH
25962: LD_INT 5
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: LIST
25972: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25973: LD_VAR 0 6
25977: PPUSH
25978: CALL_OW 257
25982: PUSH
25983: LD_INT 2
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: LD_INT 4
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: LIST
25996: IN
25997: IFFALSE 26018
// points := [ 3 , 2 , 1 ] ;
25999: LD_ADDR_VAR 0 9
26003: PUSH
26004: LD_INT 3
26006: PUSH
26007: LD_INT 2
26009: PUSH
26010: LD_INT 1
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: LIST
26017: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26018: LD_VAR 0 6
26022: PPUSH
26023: CALL_OW 257
26027: PUSH
26028: LD_INT 5
26030: EQUAL
26031: IFFALSE 26052
// points := [ 130 , 5 , 2 ] ;
26033: LD_ADDR_VAR 0 9
26037: PUSH
26038: LD_INT 130
26040: PUSH
26041: LD_INT 5
26043: PUSH
26044: LD_INT 2
26046: PUSH
26047: EMPTY
26048: LIST
26049: LIST
26050: LIST
26051: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26052: LD_VAR 0 6
26056: PPUSH
26057: CALL_OW 257
26061: PUSH
26062: LD_INT 8
26064: EQUAL
26065: IFFALSE 26086
// points := [ 35 , 35 , 30 ] ;
26067: LD_ADDR_VAR 0 9
26071: PUSH
26072: LD_INT 35
26074: PUSH
26075: LD_INT 35
26077: PUSH
26078: LD_INT 30
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: LIST
26085: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26086: LD_VAR 0 6
26090: PPUSH
26091: CALL_OW 257
26095: PUSH
26096: LD_INT 9
26098: EQUAL
26099: IFFALSE 26120
// points := [ 20 , 55 , 40 ] ;
26101: LD_ADDR_VAR 0 9
26105: PUSH
26106: LD_INT 20
26108: PUSH
26109: LD_INT 55
26111: PUSH
26112: LD_INT 40
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: LIST
26119: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26120: LD_VAR 0 6
26124: PPUSH
26125: CALL_OW 257
26129: PUSH
26130: LD_INT 12
26132: PUSH
26133: LD_INT 16
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: IN
26140: IFFALSE 26161
// points := [ 5 , 3 , 2 ] ;
26142: LD_ADDR_VAR 0 9
26146: PUSH
26147: LD_INT 5
26149: PUSH
26150: LD_INT 3
26152: PUSH
26153: LD_INT 2
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: LIST
26160: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26161: LD_VAR 0 6
26165: PPUSH
26166: CALL_OW 257
26170: PUSH
26171: LD_INT 17
26173: EQUAL
26174: IFFALSE 26195
// points := [ 100 , 50 , 75 ] ;
26176: LD_ADDR_VAR 0 9
26180: PUSH
26181: LD_INT 100
26183: PUSH
26184: LD_INT 50
26186: PUSH
26187: LD_INT 75
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: LIST
26194: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26195: LD_VAR 0 6
26199: PPUSH
26200: CALL_OW 257
26204: PUSH
26205: LD_INT 15
26207: EQUAL
26208: IFFALSE 26229
// points := [ 10 , 5 , 3 ] ;
26210: LD_ADDR_VAR 0 9
26214: PUSH
26215: LD_INT 10
26217: PUSH
26218: LD_INT 5
26220: PUSH
26221: LD_INT 3
26223: PUSH
26224: EMPTY
26225: LIST
26226: LIST
26227: LIST
26228: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26229: LD_VAR 0 6
26233: PPUSH
26234: CALL_OW 257
26238: PUSH
26239: LD_INT 14
26241: EQUAL
26242: IFFALSE 26263
// points := [ 10 , 0 , 0 ] ;
26244: LD_ADDR_VAR 0 9
26248: PUSH
26249: LD_INT 10
26251: PUSH
26252: LD_INT 0
26254: PUSH
26255: LD_INT 0
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: LIST
26262: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26263: LD_VAR 0 6
26267: PPUSH
26268: CALL_OW 257
26272: PUSH
26273: LD_INT 11
26275: EQUAL
26276: IFFALSE 26297
// points := [ 30 , 10 , 5 ] ;
26278: LD_ADDR_VAR 0 9
26282: PUSH
26283: LD_INT 30
26285: PUSH
26286: LD_INT 10
26288: PUSH
26289: LD_INT 5
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: LIST
26296: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26297: LD_VAR 0 1
26301: PPUSH
26302: LD_INT 5
26304: PPUSH
26305: CALL_OW 321
26309: PUSH
26310: LD_INT 2
26312: EQUAL
26313: IFFALSE 26330
// bpoints := bpoints * 1.8 ;
26315: LD_ADDR_VAR 0 10
26319: PUSH
26320: LD_VAR 0 10
26324: PUSH
26325: LD_REAL  1.80000000000000E+0000
26328: MUL
26329: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26330: LD_VAR 0 6
26334: PPUSH
26335: CALL_OW 257
26339: PUSH
26340: LD_INT 1
26342: PUSH
26343: LD_INT 2
26345: PUSH
26346: LD_INT 3
26348: PUSH
26349: LD_INT 4
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: IN
26358: PUSH
26359: LD_VAR 0 1
26363: PPUSH
26364: LD_INT 51
26366: PPUSH
26367: CALL_OW 321
26371: PUSH
26372: LD_INT 2
26374: EQUAL
26375: AND
26376: IFFALSE 26393
// bpoints := bpoints * 1.2 ;
26378: LD_ADDR_VAR 0 10
26382: PUSH
26383: LD_VAR 0 10
26387: PUSH
26388: LD_REAL  1.20000000000000E+0000
26391: MUL
26392: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26393: LD_VAR 0 6
26397: PPUSH
26398: CALL_OW 257
26402: PUSH
26403: LD_INT 5
26405: PUSH
26406: LD_INT 7
26408: PUSH
26409: LD_INT 9
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: LIST
26416: IN
26417: PUSH
26418: LD_VAR 0 1
26422: PPUSH
26423: LD_INT 52
26425: PPUSH
26426: CALL_OW 321
26430: PUSH
26431: LD_INT 2
26433: EQUAL
26434: AND
26435: IFFALSE 26452
// bpoints := bpoints * 1.5 ;
26437: LD_ADDR_VAR 0 10
26441: PUSH
26442: LD_VAR 0 10
26446: PUSH
26447: LD_REAL  1.50000000000000E+0000
26450: MUL
26451: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26452: LD_VAR 0 1
26456: PPUSH
26457: LD_INT 66
26459: PPUSH
26460: CALL_OW 321
26464: PUSH
26465: LD_INT 2
26467: EQUAL
26468: IFFALSE 26485
// bpoints := bpoints * 1.1 ;
26470: LD_ADDR_VAR 0 10
26474: PUSH
26475: LD_VAR 0 10
26479: PUSH
26480: LD_REAL  1.10000000000000E+0000
26483: MUL
26484: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26485: LD_ADDR_VAR 0 10
26489: PUSH
26490: LD_VAR 0 10
26494: PUSH
26495: LD_VAR 0 6
26499: PPUSH
26500: LD_INT 1
26502: PPUSH
26503: CALL_OW 259
26507: PUSH
26508: LD_REAL  1.15000000000000E+0000
26511: MUL
26512: MUL
26513: ST_TO_ADDR
// end ; unit_vehicle :
26514: GO 27342
26516: LD_INT 2
26518: DOUBLE
26519: EQUAL
26520: IFTRUE 26524
26522: GO 27330
26524: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26525: LD_VAR 0 6
26529: PPUSH
26530: CALL_OW 264
26534: PUSH
26535: LD_INT 2
26537: PUSH
26538: LD_INT 42
26540: PUSH
26541: LD_INT 24
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: LIST
26548: IN
26549: IFFALSE 26570
// points := [ 25 , 5 , 3 ] ;
26551: LD_ADDR_VAR 0 9
26555: PUSH
26556: LD_INT 25
26558: PUSH
26559: LD_INT 5
26561: PUSH
26562: LD_INT 3
26564: PUSH
26565: EMPTY
26566: LIST
26567: LIST
26568: LIST
26569: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26570: LD_VAR 0 6
26574: PPUSH
26575: CALL_OW 264
26579: PUSH
26580: LD_INT 4
26582: PUSH
26583: LD_INT 43
26585: PUSH
26586: LD_INT 25
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: LIST
26593: IN
26594: IFFALSE 26615
// points := [ 40 , 15 , 5 ] ;
26596: LD_ADDR_VAR 0 9
26600: PUSH
26601: LD_INT 40
26603: PUSH
26604: LD_INT 15
26606: PUSH
26607: LD_INT 5
26609: PUSH
26610: EMPTY
26611: LIST
26612: LIST
26613: LIST
26614: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26615: LD_VAR 0 6
26619: PPUSH
26620: CALL_OW 264
26624: PUSH
26625: LD_INT 3
26627: PUSH
26628: LD_INT 23
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: IN
26635: IFFALSE 26656
// points := [ 7 , 25 , 8 ] ;
26637: LD_ADDR_VAR 0 9
26641: PUSH
26642: LD_INT 7
26644: PUSH
26645: LD_INT 25
26647: PUSH
26648: LD_INT 8
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: LIST
26655: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26656: LD_VAR 0 6
26660: PPUSH
26661: CALL_OW 264
26665: PUSH
26666: LD_INT 5
26668: PUSH
26669: LD_INT 27
26671: PUSH
26672: LD_INT 44
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: LIST
26679: IN
26680: IFFALSE 26701
// points := [ 14 , 50 , 16 ] ;
26682: LD_ADDR_VAR 0 9
26686: PUSH
26687: LD_INT 14
26689: PUSH
26690: LD_INT 50
26692: PUSH
26693: LD_INT 16
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: LIST
26700: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26701: LD_VAR 0 6
26705: PPUSH
26706: CALL_OW 264
26710: PUSH
26711: LD_INT 6
26713: PUSH
26714: LD_INT 46
26716: PUSH
26717: EMPTY
26718: LIST
26719: LIST
26720: IN
26721: IFFALSE 26742
// points := [ 32 , 120 , 70 ] ;
26723: LD_ADDR_VAR 0 9
26727: PUSH
26728: LD_INT 32
26730: PUSH
26731: LD_INT 120
26733: PUSH
26734: LD_INT 70
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: LIST
26741: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26742: LD_VAR 0 6
26746: PPUSH
26747: CALL_OW 264
26751: PUSH
26752: LD_INT 7
26754: PUSH
26755: LD_INT 28
26757: PUSH
26758: LD_INT 45
26760: PUSH
26761: LD_INT 92
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: IN
26770: IFFALSE 26791
// points := [ 35 , 20 , 45 ] ;
26772: LD_ADDR_VAR 0 9
26776: PUSH
26777: LD_INT 35
26779: PUSH
26780: LD_INT 20
26782: PUSH
26783: LD_INT 45
26785: PUSH
26786: EMPTY
26787: LIST
26788: LIST
26789: LIST
26790: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26791: LD_VAR 0 6
26795: PPUSH
26796: CALL_OW 264
26800: PUSH
26801: LD_INT 47
26803: PUSH
26804: EMPTY
26805: LIST
26806: IN
26807: IFFALSE 26828
// points := [ 67 , 45 , 75 ] ;
26809: LD_ADDR_VAR 0 9
26813: PUSH
26814: LD_INT 67
26816: PUSH
26817: LD_INT 45
26819: PUSH
26820: LD_INT 75
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: LIST
26827: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26828: LD_VAR 0 6
26832: PPUSH
26833: CALL_OW 264
26837: PUSH
26838: LD_INT 26
26840: PUSH
26841: EMPTY
26842: LIST
26843: IN
26844: IFFALSE 26865
// points := [ 120 , 30 , 80 ] ;
26846: LD_ADDR_VAR 0 9
26850: PUSH
26851: LD_INT 120
26853: PUSH
26854: LD_INT 30
26856: PUSH
26857: LD_INT 80
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: LIST
26864: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26865: LD_VAR 0 6
26869: PPUSH
26870: CALL_OW 264
26874: PUSH
26875: LD_INT 22
26877: PUSH
26878: EMPTY
26879: LIST
26880: IN
26881: IFFALSE 26902
// points := [ 40 , 1 , 1 ] ;
26883: LD_ADDR_VAR 0 9
26887: PUSH
26888: LD_INT 40
26890: PUSH
26891: LD_INT 1
26893: PUSH
26894: LD_INT 1
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: LIST
26901: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26902: LD_VAR 0 6
26906: PPUSH
26907: CALL_OW 264
26911: PUSH
26912: LD_INT 29
26914: PUSH
26915: EMPTY
26916: LIST
26917: IN
26918: IFFALSE 26939
// points := [ 70 , 200 , 400 ] ;
26920: LD_ADDR_VAR 0 9
26924: PUSH
26925: LD_INT 70
26927: PUSH
26928: LD_INT 200
26930: PUSH
26931: LD_INT 400
26933: PUSH
26934: EMPTY
26935: LIST
26936: LIST
26937: LIST
26938: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26939: LD_VAR 0 6
26943: PPUSH
26944: CALL_OW 264
26948: PUSH
26949: LD_INT 14
26951: PUSH
26952: LD_INT 53
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: IN
26959: IFFALSE 26980
// points := [ 40 , 10 , 20 ] ;
26961: LD_ADDR_VAR 0 9
26965: PUSH
26966: LD_INT 40
26968: PUSH
26969: LD_INT 10
26971: PUSH
26972: LD_INT 20
26974: PUSH
26975: EMPTY
26976: LIST
26977: LIST
26978: LIST
26979: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26980: LD_VAR 0 6
26984: PPUSH
26985: CALL_OW 264
26989: PUSH
26990: LD_INT 9
26992: PUSH
26993: EMPTY
26994: LIST
26995: IN
26996: IFFALSE 27017
// points := [ 5 , 70 , 20 ] ;
26998: LD_ADDR_VAR 0 9
27002: PUSH
27003: LD_INT 5
27005: PUSH
27006: LD_INT 70
27008: PUSH
27009: LD_INT 20
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: LIST
27016: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27017: LD_VAR 0 6
27021: PPUSH
27022: CALL_OW 264
27026: PUSH
27027: LD_INT 10
27029: PUSH
27030: EMPTY
27031: LIST
27032: IN
27033: IFFALSE 27054
// points := [ 35 , 110 , 70 ] ;
27035: LD_ADDR_VAR 0 9
27039: PUSH
27040: LD_INT 35
27042: PUSH
27043: LD_INT 110
27045: PUSH
27046: LD_INT 70
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: LIST
27053: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27054: LD_VAR 0 6
27058: PPUSH
27059: CALL_OW 265
27063: PUSH
27064: LD_INT 25
27066: EQUAL
27067: IFFALSE 27088
// points := [ 80 , 65 , 100 ] ;
27069: LD_ADDR_VAR 0 9
27073: PUSH
27074: LD_INT 80
27076: PUSH
27077: LD_INT 65
27079: PUSH
27080: LD_INT 100
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: LIST
27087: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27088: LD_VAR 0 6
27092: PPUSH
27093: CALL_OW 263
27097: PUSH
27098: LD_INT 1
27100: EQUAL
27101: IFFALSE 27136
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27103: LD_ADDR_VAR 0 10
27107: PUSH
27108: LD_VAR 0 10
27112: PUSH
27113: LD_VAR 0 6
27117: PPUSH
27118: CALL_OW 311
27122: PPUSH
27123: LD_INT 3
27125: PPUSH
27126: CALL_OW 259
27130: PUSH
27131: LD_INT 4
27133: MUL
27134: MUL
27135: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27136: LD_VAR 0 6
27140: PPUSH
27141: CALL_OW 263
27145: PUSH
27146: LD_INT 2
27148: EQUAL
27149: IFFALSE 27200
// begin j := IsControledBy ( i ) ;
27151: LD_ADDR_VAR 0 7
27155: PUSH
27156: LD_VAR 0 6
27160: PPUSH
27161: CALL_OW 312
27165: ST_TO_ADDR
// if j then
27166: LD_VAR 0 7
27170: IFFALSE 27200
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27172: LD_ADDR_VAR 0 10
27176: PUSH
27177: LD_VAR 0 10
27181: PUSH
27182: LD_VAR 0 7
27186: PPUSH
27187: LD_INT 3
27189: PPUSH
27190: CALL_OW 259
27194: PUSH
27195: LD_INT 3
27197: MUL
27198: MUL
27199: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27200: LD_VAR 0 6
27204: PPUSH
27205: CALL_OW 264
27209: PUSH
27210: LD_INT 5
27212: PUSH
27213: LD_INT 6
27215: PUSH
27216: LD_INT 46
27218: PUSH
27219: LD_INT 44
27221: PUSH
27222: LD_INT 47
27224: PUSH
27225: LD_INT 45
27227: PUSH
27228: LD_INT 28
27230: PUSH
27231: LD_INT 7
27233: PUSH
27234: LD_INT 27
27236: PUSH
27237: LD_INT 29
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: LIST
27244: LIST
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: LIST
27250: LIST
27251: IN
27252: PUSH
27253: LD_VAR 0 1
27257: PPUSH
27258: LD_INT 52
27260: PPUSH
27261: CALL_OW 321
27265: PUSH
27266: LD_INT 2
27268: EQUAL
27269: AND
27270: IFFALSE 27287
// bpoints := bpoints * 1.2 ;
27272: LD_ADDR_VAR 0 10
27276: PUSH
27277: LD_VAR 0 10
27281: PUSH
27282: LD_REAL  1.20000000000000E+0000
27285: MUL
27286: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27287: LD_VAR 0 6
27291: PPUSH
27292: CALL_OW 264
27296: PUSH
27297: LD_INT 6
27299: PUSH
27300: LD_INT 46
27302: PUSH
27303: LD_INT 47
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: LIST
27310: IN
27311: IFFALSE 27328
// bpoints := bpoints * 1.2 ;
27313: LD_ADDR_VAR 0 10
27317: PUSH
27318: LD_VAR 0 10
27322: PUSH
27323: LD_REAL  1.20000000000000E+0000
27326: MUL
27327: ST_TO_ADDR
// end ; unit_building :
27328: GO 27342
27330: LD_INT 3
27332: DOUBLE
27333: EQUAL
27334: IFTRUE 27338
27336: GO 27341
27338: POP
// ; end ;
27339: GO 27342
27341: POP
// for j = 1 to 3 do
27342: LD_ADDR_VAR 0 7
27346: PUSH
27347: DOUBLE
27348: LD_INT 1
27350: DEC
27351: ST_TO_ADDR
27352: LD_INT 3
27354: PUSH
27355: FOR_TO
27356: IFFALSE 27409
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27358: LD_ADDR_VAR 0 5
27362: PUSH
27363: LD_VAR 0 5
27367: PPUSH
27368: LD_VAR 0 7
27372: PPUSH
27373: LD_VAR 0 5
27377: PUSH
27378: LD_VAR 0 7
27382: ARRAY
27383: PUSH
27384: LD_VAR 0 9
27388: PUSH
27389: LD_VAR 0 7
27393: ARRAY
27394: PUSH
27395: LD_VAR 0 10
27399: MUL
27400: PLUS
27401: PPUSH
27402: CALL_OW 1
27406: ST_TO_ADDR
27407: GO 27355
27409: POP
27410: POP
// end ;
27411: GO 25890
27413: POP
27414: POP
// result := Replace ( result , 4 , tmp ) ;
27415: LD_ADDR_VAR 0 5
27419: PUSH
27420: LD_VAR 0 5
27424: PPUSH
27425: LD_INT 4
27427: PPUSH
27428: LD_VAR 0 8
27432: PPUSH
27433: CALL_OW 1
27437: ST_TO_ADDR
// end ;
27438: LD_VAR 0 5
27442: RET
// export function DangerAtRange ( unit , range ) ; begin
27443: LD_INT 0
27445: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27446: LD_ADDR_VAR 0 3
27450: PUSH
27451: LD_VAR 0 1
27455: PPUSH
27456: CALL_OW 255
27460: PPUSH
27461: LD_VAR 0 1
27465: PPUSH
27466: CALL_OW 250
27470: PPUSH
27471: LD_VAR 0 1
27475: PPUSH
27476: CALL_OW 251
27480: PPUSH
27481: LD_VAR 0 2
27485: PPUSH
27486: CALL 25742 0 4
27490: ST_TO_ADDR
// end ;
27491: LD_VAR 0 3
27495: RET
// export function DangerInArea ( side , area ) ; begin
27496: LD_INT 0
27498: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27499: LD_ADDR_VAR 0 3
27503: PUSH
27504: LD_VAR 0 2
27508: PPUSH
27509: LD_INT 81
27511: PUSH
27512: LD_VAR 0 1
27516: PUSH
27517: EMPTY
27518: LIST
27519: LIST
27520: PPUSH
27521: CALL_OW 70
27525: ST_TO_ADDR
// end ;
27526: LD_VAR 0 3
27530: RET
// export function IsExtension ( b ) ; begin
27531: LD_INT 0
27533: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27534: LD_ADDR_VAR 0 2
27538: PUSH
27539: LD_VAR 0 1
27543: PUSH
27544: LD_INT 23
27546: PUSH
27547: LD_INT 20
27549: PUSH
27550: LD_INT 22
27552: PUSH
27553: LD_INT 17
27555: PUSH
27556: LD_INT 24
27558: PUSH
27559: LD_INT 21
27561: PUSH
27562: LD_INT 19
27564: PUSH
27565: LD_INT 16
27567: PUSH
27568: LD_INT 25
27570: PUSH
27571: LD_INT 18
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: LIST
27584: LIST
27585: IN
27586: ST_TO_ADDR
// end ;
27587: LD_VAR 0 2
27591: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27592: LD_INT 0
27594: PPUSH
27595: PPUSH
27596: PPUSH
// result := [ ] ;
27597: LD_ADDR_VAR 0 4
27601: PUSH
27602: EMPTY
27603: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27604: LD_ADDR_VAR 0 5
27608: PUSH
27609: LD_VAR 0 2
27613: PPUSH
27614: LD_INT 21
27616: PUSH
27617: LD_INT 3
27619: PUSH
27620: EMPTY
27621: LIST
27622: LIST
27623: PPUSH
27624: CALL_OW 70
27628: ST_TO_ADDR
// if not tmp then
27629: LD_VAR 0 5
27633: NOT
27634: IFFALSE 27638
// exit ;
27636: GO 27702
// if checkLink then
27638: LD_VAR 0 3
27642: IFFALSE 27692
// begin for i in tmp do
27644: LD_ADDR_VAR 0 6
27648: PUSH
27649: LD_VAR 0 5
27653: PUSH
27654: FOR_IN
27655: IFFALSE 27690
// if GetBase ( i ) <> base then
27657: LD_VAR 0 6
27661: PPUSH
27662: CALL_OW 274
27666: PUSH
27667: LD_VAR 0 1
27671: NONEQUAL
27672: IFFALSE 27688
// ComLinkToBase ( base , i ) ;
27674: LD_VAR 0 1
27678: PPUSH
27679: LD_VAR 0 6
27683: PPUSH
27684: CALL_OW 169
27688: GO 27654
27690: POP
27691: POP
// end ; result := tmp ;
27692: LD_ADDR_VAR 0 4
27696: PUSH
27697: LD_VAR 0 5
27701: ST_TO_ADDR
// end ;
27702: LD_VAR 0 4
27706: RET
// export function ComComplete ( units , b ) ; var i ; begin
27707: LD_INT 0
27709: PPUSH
27710: PPUSH
// if not units then
27711: LD_VAR 0 1
27715: NOT
27716: IFFALSE 27720
// exit ;
27718: GO 27810
// for i in units do
27720: LD_ADDR_VAR 0 4
27724: PUSH
27725: LD_VAR 0 1
27729: PUSH
27730: FOR_IN
27731: IFFALSE 27808
// if BuildingStatus ( b ) = bs_build then
27733: LD_VAR 0 2
27737: PPUSH
27738: CALL_OW 461
27742: PUSH
27743: LD_INT 1
27745: EQUAL
27746: IFFALSE 27806
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27748: LD_VAR 0 4
27752: PPUSH
27753: LD_STRING h
27755: PUSH
27756: LD_VAR 0 2
27760: PPUSH
27761: CALL_OW 250
27765: PUSH
27766: LD_VAR 0 2
27770: PPUSH
27771: CALL_OW 251
27775: PUSH
27776: LD_VAR 0 2
27780: PUSH
27781: LD_INT 0
27783: PUSH
27784: LD_INT 0
27786: PUSH
27787: LD_INT 0
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: LIST
27794: LIST
27795: LIST
27796: LIST
27797: LIST
27798: PUSH
27799: EMPTY
27800: LIST
27801: PPUSH
27802: CALL_OW 446
27806: GO 27730
27808: POP
27809: POP
// end ;
27810: LD_VAR 0 3
27814: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27815: LD_INT 0
27817: PPUSH
27818: PPUSH
27819: PPUSH
27820: PPUSH
27821: PPUSH
27822: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27823: LD_VAR 0 1
27827: NOT
27828: PUSH
27829: LD_VAR 0 1
27833: PPUSH
27834: CALL_OW 263
27838: PUSH
27839: LD_INT 2
27841: NONEQUAL
27842: OR
27843: IFFALSE 27847
// exit ;
27845: GO 28163
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27847: LD_ADDR_VAR 0 6
27851: PUSH
27852: LD_INT 22
27854: PUSH
27855: LD_VAR 0 1
27859: PPUSH
27860: CALL_OW 255
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 2
27871: PUSH
27872: LD_INT 30
27874: PUSH
27875: LD_INT 36
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: PUSH
27882: LD_INT 34
27884: PUSH
27885: LD_INT 31
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: LIST
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PPUSH
27901: CALL_OW 69
27905: ST_TO_ADDR
// if not tmp then
27906: LD_VAR 0 6
27910: NOT
27911: IFFALSE 27915
// exit ;
27913: GO 28163
// result := [ ] ;
27915: LD_ADDR_VAR 0 2
27919: PUSH
27920: EMPTY
27921: ST_TO_ADDR
// for i in tmp do
27922: LD_ADDR_VAR 0 3
27926: PUSH
27927: LD_VAR 0 6
27931: PUSH
27932: FOR_IN
27933: IFFALSE 28004
// begin t := UnitsInside ( i ) ;
27935: LD_ADDR_VAR 0 4
27939: PUSH
27940: LD_VAR 0 3
27944: PPUSH
27945: CALL_OW 313
27949: ST_TO_ADDR
// if t then
27950: LD_VAR 0 4
27954: IFFALSE 28002
// for j in t do
27956: LD_ADDR_VAR 0 7
27960: PUSH
27961: LD_VAR 0 4
27965: PUSH
27966: FOR_IN
27967: IFFALSE 28000
// result := Replace ( result , result + 1 , j ) ;
27969: LD_ADDR_VAR 0 2
27973: PUSH
27974: LD_VAR 0 2
27978: PPUSH
27979: LD_VAR 0 2
27983: PUSH
27984: LD_INT 1
27986: PLUS
27987: PPUSH
27988: LD_VAR 0 7
27992: PPUSH
27993: CALL_OW 1
27997: ST_TO_ADDR
27998: GO 27966
28000: POP
28001: POP
// end ;
28002: GO 27932
28004: POP
28005: POP
// if not result then
28006: LD_VAR 0 2
28010: NOT
28011: IFFALSE 28015
// exit ;
28013: GO 28163
// mech := result [ 1 ] ;
28015: LD_ADDR_VAR 0 5
28019: PUSH
28020: LD_VAR 0 2
28024: PUSH
28025: LD_INT 1
28027: ARRAY
28028: ST_TO_ADDR
// if result > 1 then
28029: LD_VAR 0 2
28033: PUSH
28034: LD_INT 1
28036: GREATER
28037: IFFALSE 28149
// begin for i = 2 to result do
28039: LD_ADDR_VAR 0 3
28043: PUSH
28044: DOUBLE
28045: LD_INT 2
28047: DEC
28048: ST_TO_ADDR
28049: LD_VAR 0 2
28053: PUSH
28054: FOR_TO
28055: IFFALSE 28147
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28057: LD_ADDR_VAR 0 4
28061: PUSH
28062: LD_VAR 0 2
28066: PUSH
28067: LD_VAR 0 3
28071: ARRAY
28072: PPUSH
28073: LD_INT 3
28075: PPUSH
28076: CALL_OW 259
28080: PUSH
28081: LD_VAR 0 2
28085: PUSH
28086: LD_VAR 0 3
28090: ARRAY
28091: PPUSH
28092: CALL_OW 432
28096: MINUS
28097: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28098: LD_VAR 0 4
28102: PUSH
28103: LD_VAR 0 5
28107: PPUSH
28108: LD_INT 3
28110: PPUSH
28111: CALL_OW 259
28115: PUSH
28116: LD_VAR 0 5
28120: PPUSH
28121: CALL_OW 432
28125: MINUS
28126: GREATEREQUAL
28127: IFFALSE 28145
// mech := result [ i ] ;
28129: LD_ADDR_VAR 0 5
28133: PUSH
28134: LD_VAR 0 2
28138: PUSH
28139: LD_VAR 0 3
28143: ARRAY
28144: ST_TO_ADDR
// end ;
28145: GO 28054
28147: POP
28148: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28149: LD_VAR 0 1
28153: PPUSH
28154: LD_VAR 0 5
28158: PPUSH
28159: CALL_OW 135
// end ;
28163: LD_VAR 0 2
28167: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28168: LD_INT 0
28170: PPUSH
28171: PPUSH
28172: PPUSH
28173: PPUSH
28174: PPUSH
28175: PPUSH
28176: PPUSH
28177: PPUSH
28178: PPUSH
28179: PPUSH
28180: PPUSH
28181: PPUSH
28182: PPUSH
// result := [ ] ;
28183: LD_ADDR_VAR 0 7
28187: PUSH
28188: EMPTY
28189: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28190: LD_VAR 0 1
28194: PPUSH
28195: CALL_OW 266
28199: PUSH
28200: LD_INT 0
28202: PUSH
28203: LD_INT 1
28205: PUSH
28206: EMPTY
28207: LIST
28208: LIST
28209: IN
28210: NOT
28211: IFFALSE 28215
// exit ;
28213: GO 29849
// if name then
28215: LD_VAR 0 3
28219: IFFALSE 28235
// SetBName ( base_dep , name ) ;
28221: LD_VAR 0 1
28225: PPUSH
28226: LD_VAR 0 3
28230: PPUSH
28231: CALL_OW 500
// base := GetBase ( base_dep ) ;
28235: LD_ADDR_VAR 0 15
28239: PUSH
28240: LD_VAR 0 1
28244: PPUSH
28245: CALL_OW 274
28249: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28250: LD_ADDR_VAR 0 16
28254: PUSH
28255: LD_VAR 0 1
28259: PPUSH
28260: CALL_OW 255
28264: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28265: LD_ADDR_VAR 0 17
28269: PUSH
28270: LD_VAR 0 1
28274: PPUSH
28275: CALL_OW 248
28279: ST_TO_ADDR
// if sources then
28280: LD_VAR 0 5
28284: IFFALSE 28331
// for i = 1 to 3 do
28286: LD_ADDR_VAR 0 8
28290: PUSH
28291: DOUBLE
28292: LD_INT 1
28294: DEC
28295: ST_TO_ADDR
28296: LD_INT 3
28298: PUSH
28299: FOR_TO
28300: IFFALSE 28329
// AddResourceType ( base , i , sources [ i ] ) ;
28302: LD_VAR 0 15
28306: PPUSH
28307: LD_VAR 0 8
28311: PPUSH
28312: LD_VAR 0 5
28316: PUSH
28317: LD_VAR 0 8
28321: ARRAY
28322: PPUSH
28323: CALL_OW 276
28327: GO 28299
28329: POP
28330: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28331: LD_ADDR_VAR 0 18
28335: PUSH
28336: LD_VAR 0 15
28340: PPUSH
28341: LD_VAR 0 2
28345: PPUSH
28346: LD_INT 1
28348: PPUSH
28349: CALL 27592 0 3
28353: ST_TO_ADDR
// InitHc ;
28354: CALL_OW 19
// InitUc ;
28358: CALL_OW 18
// uc_side := side ;
28362: LD_ADDR_OWVAR 20
28366: PUSH
28367: LD_VAR 0 16
28371: ST_TO_ADDR
// uc_nation := nation ;
28372: LD_ADDR_OWVAR 21
28376: PUSH
28377: LD_VAR 0 17
28381: ST_TO_ADDR
// if buildings then
28382: LD_VAR 0 18
28386: IFFALSE 29708
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28388: LD_ADDR_VAR 0 19
28392: PUSH
28393: LD_VAR 0 18
28397: PPUSH
28398: LD_INT 2
28400: PUSH
28401: LD_INT 30
28403: PUSH
28404: LD_INT 29
28406: PUSH
28407: EMPTY
28408: LIST
28409: LIST
28410: PUSH
28411: LD_INT 30
28413: PUSH
28414: LD_INT 30
28416: PUSH
28417: EMPTY
28418: LIST
28419: LIST
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: LIST
28425: PPUSH
28426: CALL_OW 72
28430: ST_TO_ADDR
// if tmp then
28431: LD_VAR 0 19
28435: IFFALSE 28483
// for i in tmp do
28437: LD_ADDR_VAR 0 8
28441: PUSH
28442: LD_VAR 0 19
28446: PUSH
28447: FOR_IN
28448: IFFALSE 28481
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28450: LD_VAR 0 8
28454: PPUSH
28455: CALL_OW 250
28459: PPUSH
28460: LD_VAR 0 8
28464: PPUSH
28465: CALL_OW 251
28469: PPUSH
28470: LD_VAR 0 16
28474: PPUSH
28475: CALL_OW 441
28479: GO 28447
28481: POP
28482: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28483: LD_VAR 0 18
28487: PPUSH
28488: LD_INT 2
28490: PUSH
28491: LD_INT 30
28493: PUSH
28494: LD_INT 32
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PUSH
28501: LD_INT 30
28503: PUSH
28504: LD_INT 33
28506: PUSH
28507: EMPTY
28508: LIST
28509: LIST
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: LIST
28515: PPUSH
28516: CALL_OW 72
28520: IFFALSE 28608
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28522: LD_ADDR_VAR 0 8
28526: PUSH
28527: LD_VAR 0 18
28531: PPUSH
28532: LD_INT 2
28534: PUSH
28535: LD_INT 30
28537: PUSH
28538: LD_INT 32
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: LD_INT 30
28547: PUSH
28548: LD_INT 33
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: LIST
28559: PPUSH
28560: CALL_OW 72
28564: PUSH
28565: FOR_IN
28566: IFFALSE 28606
// begin if not GetBWeapon ( i ) then
28568: LD_VAR 0 8
28572: PPUSH
28573: CALL_OW 269
28577: NOT
28578: IFFALSE 28604
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28580: LD_VAR 0 8
28584: PPUSH
28585: LD_VAR 0 8
28589: PPUSH
28590: LD_VAR 0 2
28594: PPUSH
28595: CALL 29854 0 2
28599: PPUSH
28600: CALL_OW 431
// end ;
28604: GO 28565
28606: POP
28607: POP
// end ; for i = 1 to personel do
28608: LD_ADDR_VAR 0 8
28612: PUSH
28613: DOUBLE
28614: LD_INT 1
28616: DEC
28617: ST_TO_ADDR
28618: LD_VAR 0 6
28622: PUSH
28623: FOR_TO
28624: IFFALSE 29688
// begin if i > 4 then
28626: LD_VAR 0 8
28630: PUSH
28631: LD_INT 4
28633: GREATER
28634: IFFALSE 28638
// break ;
28636: GO 29688
// case i of 1 :
28638: LD_VAR 0 8
28642: PUSH
28643: LD_INT 1
28645: DOUBLE
28646: EQUAL
28647: IFTRUE 28651
28649: GO 28731
28651: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28652: LD_ADDR_VAR 0 12
28656: PUSH
28657: LD_VAR 0 18
28661: PPUSH
28662: LD_INT 22
28664: PUSH
28665: LD_VAR 0 16
28669: PUSH
28670: EMPTY
28671: LIST
28672: LIST
28673: PUSH
28674: LD_INT 58
28676: PUSH
28677: EMPTY
28678: LIST
28679: PUSH
28680: LD_INT 2
28682: PUSH
28683: LD_INT 30
28685: PUSH
28686: LD_INT 32
28688: PUSH
28689: EMPTY
28690: LIST
28691: LIST
28692: PUSH
28693: LD_INT 30
28695: PUSH
28696: LD_INT 4
28698: PUSH
28699: EMPTY
28700: LIST
28701: LIST
28702: PUSH
28703: LD_INT 30
28705: PUSH
28706: LD_INT 5
28708: PUSH
28709: EMPTY
28710: LIST
28711: LIST
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: LIST
28717: LIST
28718: PUSH
28719: EMPTY
28720: LIST
28721: LIST
28722: LIST
28723: PPUSH
28724: CALL_OW 72
28728: ST_TO_ADDR
28729: GO 28953
28731: LD_INT 2
28733: DOUBLE
28734: EQUAL
28735: IFTRUE 28739
28737: GO 28801
28739: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28740: LD_ADDR_VAR 0 12
28744: PUSH
28745: LD_VAR 0 18
28749: PPUSH
28750: LD_INT 22
28752: PUSH
28753: LD_VAR 0 16
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 2
28764: PUSH
28765: LD_INT 30
28767: PUSH
28768: LD_INT 0
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: LD_INT 30
28777: PUSH
28778: LD_INT 1
28780: PUSH
28781: EMPTY
28782: LIST
28783: LIST
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: LIST
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PPUSH
28794: CALL_OW 72
28798: ST_TO_ADDR
28799: GO 28953
28801: LD_INT 3
28803: DOUBLE
28804: EQUAL
28805: IFTRUE 28809
28807: GO 28871
28809: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28810: LD_ADDR_VAR 0 12
28814: PUSH
28815: LD_VAR 0 18
28819: PPUSH
28820: LD_INT 22
28822: PUSH
28823: LD_VAR 0 16
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PUSH
28832: LD_INT 2
28834: PUSH
28835: LD_INT 30
28837: PUSH
28838: LD_INT 2
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: LD_INT 30
28847: PUSH
28848: LD_INT 3
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: LIST
28859: PUSH
28860: EMPTY
28861: LIST
28862: LIST
28863: PPUSH
28864: CALL_OW 72
28868: ST_TO_ADDR
28869: GO 28953
28871: LD_INT 4
28873: DOUBLE
28874: EQUAL
28875: IFTRUE 28879
28877: GO 28952
28879: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28880: LD_ADDR_VAR 0 12
28884: PUSH
28885: LD_VAR 0 18
28889: PPUSH
28890: LD_INT 22
28892: PUSH
28893: LD_VAR 0 16
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PUSH
28902: LD_INT 2
28904: PUSH
28905: LD_INT 30
28907: PUSH
28908: LD_INT 6
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: PUSH
28915: LD_INT 30
28917: PUSH
28918: LD_INT 7
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: LD_INT 30
28927: PUSH
28928: LD_INT 8
28930: PUSH
28931: EMPTY
28932: LIST
28933: LIST
28934: PUSH
28935: EMPTY
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PPUSH
28945: CALL_OW 72
28949: ST_TO_ADDR
28950: GO 28953
28952: POP
// if i = 1 then
28953: LD_VAR 0 8
28957: PUSH
28958: LD_INT 1
28960: EQUAL
28961: IFFALSE 29072
// begin tmp := [ ] ;
28963: LD_ADDR_VAR 0 19
28967: PUSH
28968: EMPTY
28969: ST_TO_ADDR
// for j in f do
28970: LD_ADDR_VAR 0 9
28974: PUSH
28975: LD_VAR 0 12
28979: PUSH
28980: FOR_IN
28981: IFFALSE 29054
// if GetBType ( j ) = b_bunker then
28983: LD_VAR 0 9
28987: PPUSH
28988: CALL_OW 266
28992: PUSH
28993: LD_INT 32
28995: EQUAL
28996: IFFALSE 29023
// tmp := Insert ( tmp , 1 , j ) else
28998: LD_ADDR_VAR 0 19
29002: PUSH
29003: LD_VAR 0 19
29007: PPUSH
29008: LD_INT 1
29010: PPUSH
29011: LD_VAR 0 9
29015: PPUSH
29016: CALL_OW 2
29020: ST_TO_ADDR
29021: GO 29052
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29023: LD_ADDR_VAR 0 19
29027: PUSH
29028: LD_VAR 0 19
29032: PPUSH
29033: LD_VAR 0 19
29037: PUSH
29038: LD_INT 1
29040: PLUS
29041: PPUSH
29042: LD_VAR 0 9
29046: PPUSH
29047: CALL_OW 2
29051: ST_TO_ADDR
29052: GO 28980
29054: POP
29055: POP
// if tmp then
29056: LD_VAR 0 19
29060: IFFALSE 29072
// f := tmp ;
29062: LD_ADDR_VAR 0 12
29066: PUSH
29067: LD_VAR 0 19
29071: ST_TO_ADDR
// end ; x := personel [ i ] ;
29072: LD_ADDR_VAR 0 13
29076: PUSH
29077: LD_VAR 0 6
29081: PUSH
29082: LD_VAR 0 8
29086: ARRAY
29087: ST_TO_ADDR
// if x = - 1 then
29088: LD_VAR 0 13
29092: PUSH
29093: LD_INT 1
29095: NEG
29096: EQUAL
29097: IFFALSE 29306
// begin for j in f do
29099: LD_ADDR_VAR 0 9
29103: PUSH
29104: LD_VAR 0 12
29108: PUSH
29109: FOR_IN
29110: IFFALSE 29302
// repeat InitHc ;
29112: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29116: LD_VAR 0 9
29120: PPUSH
29121: CALL_OW 266
29125: PUSH
29126: LD_INT 5
29128: EQUAL
29129: IFFALSE 29199
// begin if UnitsInside ( j ) < 3 then
29131: LD_VAR 0 9
29135: PPUSH
29136: CALL_OW 313
29140: PUSH
29141: LD_INT 3
29143: LESS
29144: IFFALSE 29180
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29146: LD_INT 0
29148: PPUSH
29149: LD_INT 5
29151: PUSH
29152: LD_INT 8
29154: PUSH
29155: LD_INT 9
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: LIST
29162: PUSH
29163: LD_VAR 0 17
29167: ARRAY
29168: PPUSH
29169: LD_VAR 0 4
29173: PPUSH
29174: CALL_OW 380
29178: GO 29197
// PrepareHuman ( false , i , skill ) ;
29180: LD_INT 0
29182: PPUSH
29183: LD_VAR 0 8
29187: PPUSH
29188: LD_VAR 0 4
29192: PPUSH
29193: CALL_OW 380
// end else
29197: GO 29216
// PrepareHuman ( false , i , skill ) ;
29199: LD_INT 0
29201: PPUSH
29202: LD_VAR 0 8
29206: PPUSH
29207: LD_VAR 0 4
29211: PPUSH
29212: CALL_OW 380
// un := CreateHuman ;
29216: LD_ADDR_VAR 0 14
29220: PUSH
29221: CALL_OW 44
29225: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29226: LD_ADDR_VAR 0 7
29230: PUSH
29231: LD_VAR 0 7
29235: PPUSH
29236: LD_INT 1
29238: PPUSH
29239: LD_VAR 0 14
29243: PPUSH
29244: CALL_OW 2
29248: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29249: LD_VAR 0 14
29253: PPUSH
29254: LD_VAR 0 9
29258: PPUSH
29259: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29263: LD_VAR 0 9
29267: PPUSH
29268: CALL_OW 313
29272: PUSH
29273: LD_INT 6
29275: EQUAL
29276: PUSH
29277: LD_VAR 0 9
29281: PPUSH
29282: CALL_OW 266
29286: PUSH
29287: LD_INT 32
29289: PUSH
29290: LD_INT 31
29292: PUSH
29293: EMPTY
29294: LIST
29295: LIST
29296: IN
29297: OR
29298: IFFALSE 29112
29300: GO 29109
29302: POP
29303: POP
// end else
29304: GO 29686
// for j = 1 to x do
29306: LD_ADDR_VAR 0 9
29310: PUSH
29311: DOUBLE
29312: LD_INT 1
29314: DEC
29315: ST_TO_ADDR
29316: LD_VAR 0 13
29320: PUSH
29321: FOR_TO
29322: IFFALSE 29684
// begin InitHc ;
29324: CALL_OW 19
// if not f then
29328: LD_VAR 0 12
29332: NOT
29333: IFFALSE 29422
// begin PrepareHuman ( false , i , skill ) ;
29335: LD_INT 0
29337: PPUSH
29338: LD_VAR 0 8
29342: PPUSH
29343: LD_VAR 0 4
29347: PPUSH
29348: CALL_OW 380
// un := CreateHuman ;
29352: LD_ADDR_VAR 0 14
29356: PUSH
29357: CALL_OW 44
29361: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29362: LD_ADDR_VAR 0 7
29366: PUSH
29367: LD_VAR 0 7
29371: PPUSH
29372: LD_INT 1
29374: PPUSH
29375: LD_VAR 0 14
29379: PPUSH
29380: CALL_OW 2
29384: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29385: LD_VAR 0 14
29389: PPUSH
29390: LD_VAR 0 1
29394: PPUSH
29395: CALL_OW 250
29399: PPUSH
29400: LD_VAR 0 1
29404: PPUSH
29405: CALL_OW 251
29409: PPUSH
29410: LD_INT 10
29412: PPUSH
29413: LD_INT 0
29415: PPUSH
29416: CALL_OW 50
// continue ;
29420: GO 29321
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29422: LD_VAR 0 12
29426: PUSH
29427: LD_INT 1
29429: ARRAY
29430: PPUSH
29431: CALL_OW 313
29435: PUSH
29436: LD_VAR 0 12
29440: PUSH
29441: LD_INT 1
29443: ARRAY
29444: PPUSH
29445: CALL_OW 266
29449: PUSH
29450: LD_INT 32
29452: PUSH
29453: LD_INT 31
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: IN
29460: AND
29461: PUSH
29462: LD_VAR 0 12
29466: PUSH
29467: LD_INT 1
29469: ARRAY
29470: PPUSH
29471: CALL_OW 313
29475: PUSH
29476: LD_INT 6
29478: EQUAL
29479: OR
29480: IFFALSE 29500
// f := Delete ( f , 1 ) ;
29482: LD_ADDR_VAR 0 12
29486: PUSH
29487: LD_VAR 0 12
29491: PPUSH
29492: LD_INT 1
29494: PPUSH
29495: CALL_OW 3
29499: ST_TO_ADDR
// if not f then
29500: LD_VAR 0 12
29504: NOT
29505: IFFALSE 29523
// begin x := x + 2 ;
29507: LD_ADDR_VAR 0 13
29511: PUSH
29512: LD_VAR 0 13
29516: PUSH
29517: LD_INT 2
29519: PLUS
29520: ST_TO_ADDR
// continue ;
29521: GO 29321
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29523: LD_VAR 0 12
29527: PUSH
29528: LD_INT 1
29530: ARRAY
29531: PPUSH
29532: CALL_OW 266
29536: PUSH
29537: LD_INT 5
29539: EQUAL
29540: IFFALSE 29614
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29542: LD_VAR 0 12
29546: PUSH
29547: LD_INT 1
29549: ARRAY
29550: PPUSH
29551: CALL_OW 313
29555: PUSH
29556: LD_INT 3
29558: LESS
29559: IFFALSE 29595
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29561: LD_INT 0
29563: PPUSH
29564: LD_INT 5
29566: PUSH
29567: LD_INT 8
29569: PUSH
29570: LD_INT 9
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: LIST
29577: PUSH
29578: LD_VAR 0 17
29582: ARRAY
29583: PPUSH
29584: LD_VAR 0 4
29588: PPUSH
29589: CALL_OW 380
29593: GO 29612
// PrepareHuman ( false , i , skill ) ;
29595: LD_INT 0
29597: PPUSH
29598: LD_VAR 0 8
29602: PPUSH
29603: LD_VAR 0 4
29607: PPUSH
29608: CALL_OW 380
// end else
29612: GO 29631
// PrepareHuman ( false , i , skill ) ;
29614: LD_INT 0
29616: PPUSH
29617: LD_VAR 0 8
29621: PPUSH
29622: LD_VAR 0 4
29626: PPUSH
29627: CALL_OW 380
// un := CreateHuman ;
29631: LD_ADDR_VAR 0 14
29635: PUSH
29636: CALL_OW 44
29640: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29641: LD_ADDR_VAR 0 7
29645: PUSH
29646: LD_VAR 0 7
29650: PPUSH
29651: LD_INT 1
29653: PPUSH
29654: LD_VAR 0 14
29658: PPUSH
29659: CALL_OW 2
29663: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29664: LD_VAR 0 14
29668: PPUSH
29669: LD_VAR 0 12
29673: PUSH
29674: LD_INT 1
29676: ARRAY
29677: PPUSH
29678: CALL_OW 52
// end ;
29682: GO 29321
29684: POP
29685: POP
// end ;
29686: GO 28623
29688: POP
29689: POP
// result := result ^ buildings ;
29690: LD_ADDR_VAR 0 7
29694: PUSH
29695: LD_VAR 0 7
29699: PUSH
29700: LD_VAR 0 18
29704: ADD
29705: ST_TO_ADDR
// end else
29706: GO 29849
// begin for i = 1 to personel do
29708: LD_ADDR_VAR 0 8
29712: PUSH
29713: DOUBLE
29714: LD_INT 1
29716: DEC
29717: ST_TO_ADDR
29718: LD_VAR 0 6
29722: PUSH
29723: FOR_TO
29724: IFFALSE 29847
// begin if i > 4 then
29726: LD_VAR 0 8
29730: PUSH
29731: LD_INT 4
29733: GREATER
29734: IFFALSE 29738
// break ;
29736: GO 29847
// x := personel [ i ] ;
29738: LD_ADDR_VAR 0 13
29742: PUSH
29743: LD_VAR 0 6
29747: PUSH
29748: LD_VAR 0 8
29752: ARRAY
29753: ST_TO_ADDR
// if x = - 1 then
29754: LD_VAR 0 13
29758: PUSH
29759: LD_INT 1
29761: NEG
29762: EQUAL
29763: IFFALSE 29767
// continue ;
29765: GO 29723
// PrepareHuman ( false , i , skill ) ;
29767: LD_INT 0
29769: PPUSH
29770: LD_VAR 0 8
29774: PPUSH
29775: LD_VAR 0 4
29779: PPUSH
29780: CALL_OW 380
// un := CreateHuman ;
29784: LD_ADDR_VAR 0 14
29788: PUSH
29789: CALL_OW 44
29793: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29794: LD_VAR 0 14
29798: PPUSH
29799: LD_VAR 0 1
29803: PPUSH
29804: CALL_OW 250
29808: PPUSH
29809: LD_VAR 0 1
29813: PPUSH
29814: CALL_OW 251
29818: PPUSH
29819: LD_INT 10
29821: PPUSH
29822: LD_INT 0
29824: PPUSH
29825: CALL_OW 50
// result := result ^ un ;
29829: LD_ADDR_VAR 0 7
29833: PUSH
29834: LD_VAR 0 7
29838: PUSH
29839: LD_VAR 0 14
29843: ADD
29844: ST_TO_ADDR
// end ;
29845: GO 29723
29847: POP
29848: POP
// end ; end ;
29849: LD_VAR 0 7
29853: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29854: LD_INT 0
29856: PPUSH
29857: PPUSH
29858: PPUSH
29859: PPUSH
29860: PPUSH
29861: PPUSH
29862: PPUSH
29863: PPUSH
29864: PPUSH
29865: PPUSH
29866: PPUSH
29867: PPUSH
29868: PPUSH
29869: PPUSH
29870: PPUSH
29871: PPUSH
// result := false ;
29872: LD_ADDR_VAR 0 3
29876: PUSH
29877: LD_INT 0
29879: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29880: LD_VAR 0 1
29884: NOT
29885: PUSH
29886: LD_VAR 0 1
29890: PPUSH
29891: CALL_OW 266
29895: PUSH
29896: LD_INT 32
29898: PUSH
29899: LD_INT 33
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: IN
29906: NOT
29907: OR
29908: IFFALSE 29912
// exit ;
29910: GO 31021
// nat := GetNation ( tower ) ;
29912: LD_ADDR_VAR 0 12
29916: PUSH
29917: LD_VAR 0 1
29921: PPUSH
29922: CALL_OW 248
29926: ST_TO_ADDR
// side := GetSide ( tower ) ;
29927: LD_ADDR_VAR 0 16
29931: PUSH
29932: LD_VAR 0 1
29936: PPUSH
29937: CALL_OW 255
29941: ST_TO_ADDR
// x := GetX ( tower ) ;
29942: LD_ADDR_VAR 0 10
29946: PUSH
29947: LD_VAR 0 1
29951: PPUSH
29952: CALL_OW 250
29956: ST_TO_ADDR
// y := GetY ( tower ) ;
29957: LD_ADDR_VAR 0 11
29961: PUSH
29962: LD_VAR 0 1
29966: PPUSH
29967: CALL_OW 251
29971: ST_TO_ADDR
// if not x or not y then
29972: LD_VAR 0 10
29976: NOT
29977: PUSH
29978: LD_VAR 0 11
29982: NOT
29983: OR
29984: IFFALSE 29988
// exit ;
29986: GO 31021
// weapon := 0 ;
29988: LD_ADDR_VAR 0 18
29992: PUSH
29993: LD_INT 0
29995: ST_TO_ADDR
// fac_list := [ ] ;
29996: LD_ADDR_VAR 0 17
30000: PUSH
30001: EMPTY
30002: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30003: LD_ADDR_VAR 0 6
30007: PUSH
30008: LD_VAR 0 1
30012: PPUSH
30013: CALL_OW 274
30017: PPUSH
30018: LD_VAR 0 2
30022: PPUSH
30023: LD_INT 0
30025: PPUSH
30026: CALL 27592 0 3
30030: PPUSH
30031: LD_INT 30
30033: PUSH
30034: LD_INT 3
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PPUSH
30041: CALL_OW 72
30045: ST_TO_ADDR
// if not factories then
30046: LD_VAR 0 6
30050: NOT
30051: IFFALSE 30055
// exit ;
30053: GO 31021
// for i in factories do
30055: LD_ADDR_VAR 0 8
30059: PUSH
30060: LD_VAR 0 6
30064: PUSH
30065: FOR_IN
30066: IFFALSE 30091
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30068: LD_ADDR_VAR 0 17
30072: PUSH
30073: LD_VAR 0 17
30077: PUSH
30078: LD_VAR 0 8
30082: PPUSH
30083: CALL_OW 478
30087: UNION
30088: ST_TO_ADDR
30089: GO 30065
30091: POP
30092: POP
// if not fac_list then
30093: LD_VAR 0 17
30097: NOT
30098: IFFALSE 30102
// exit ;
30100: GO 31021
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30102: LD_ADDR_VAR 0 5
30106: PUSH
30107: LD_INT 4
30109: PUSH
30110: LD_INT 5
30112: PUSH
30113: LD_INT 9
30115: PUSH
30116: LD_INT 10
30118: PUSH
30119: LD_INT 6
30121: PUSH
30122: LD_INT 7
30124: PUSH
30125: LD_INT 11
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 27
30139: PUSH
30140: LD_INT 28
30142: PUSH
30143: LD_INT 26
30145: PUSH
30146: LD_INT 30
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 43
30157: PUSH
30158: LD_INT 44
30160: PUSH
30161: LD_INT 46
30163: PUSH
30164: LD_INT 45
30166: PUSH
30167: LD_INT 47
30169: PUSH
30170: LD_INT 49
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: LIST
30177: LIST
30178: LIST
30179: LIST
30180: PUSH
30181: EMPTY
30182: LIST
30183: LIST
30184: LIST
30185: PUSH
30186: LD_VAR 0 12
30190: ARRAY
30191: ST_TO_ADDR
// list := list isect fac_list ;
30192: LD_ADDR_VAR 0 5
30196: PUSH
30197: LD_VAR 0 5
30201: PUSH
30202: LD_VAR 0 17
30206: ISECT
30207: ST_TO_ADDR
// if not list then
30208: LD_VAR 0 5
30212: NOT
30213: IFFALSE 30217
// exit ;
30215: GO 31021
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30217: LD_VAR 0 12
30221: PUSH
30222: LD_INT 3
30224: EQUAL
30225: PUSH
30226: LD_INT 49
30228: PUSH
30229: LD_VAR 0 5
30233: IN
30234: AND
30235: PUSH
30236: LD_INT 31
30238: PPUSH
30239: LD_VAR 0 16
30243: PPUSH
30244: CALL_OW 321
30248: PUSH
30249: LD_INT 2
30251: EQUAL
30252: AND
30253: IFFALSE 30313
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30255: LD_INT 22
30257: PUSH
30258: LD_VAR 0 16
30262: PUSH
30263: EMPTY
30264: LIST
30265: LIST
30266: PUSH
30267: LD_INT 35
30269: PUSH
30270: LD_INT 49
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: PUSH
30277: LD_INT 91
30279: PUSH
30280: LD_VAR 0 1
30284: PUSH
30285: LD_INT 10
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: LIST
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: LIST
30297: PPUSH
30298: CALL_OW 69
30302: NOT
30303: IFFALSE 30313
// weapon := ru_time_lapser ;
30305: LD_ADDR_VAR 0 18
30309: PUSH
30310: LD_INT 49
30312: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30313: LD_VAR 0 12
30317: PUSH
30318: LD_INT 1
30320: PUSH
30321: LD_INT 2
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: IN
30328: PUSH
30329: LD_INT 11
30331: PUSH
30332: LD_VAR 0 5
30336: IN
30337: PUSH
30338: LD_INT 30
30340: PUSH
30341: LD_VAR 0 5
30345: IN
30346: OR
30347: AND
30348: PUSH
30349: LD_INT 6
30351: PPUSH
30352: LD_VAR 0 16
30356: PPUSH
30357: CALL_OW 321
30361: PUSH
30362: LD_INT 2
30364: EQUAL
30365: AND
30366: IFFALSE 30531
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30368: LD_INT 22
30370: PUSH
30371: LD_VAR 0 16
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 2
30382: PUSH
30383: LD_INT 35
30385: PUSH
30386: LD_INT 11
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 35
30395: PUSH
30396: LD_INT 30
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: LIST
30407: PUSH
30408: LD_INT 91
30410: PUSH
30411: LD_VAR 0 1
30415: PUSH
30416: LD_INT 18
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: LIST
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: LIST
30428: PPUSH
30429: CALL_OW 69
30433: NOT
30434: PUSH
30435: LD_INT 22
30437: PUSH
30438: LD_VAR 0 16
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: PUSH
30447: LD_INT 2
30449: PUSH
30450: LD_INT 30
30452: PUSH
30453: LD_INT 32
30455: PUSH
30456: EMPTY
30457: LIST
30458: LIST
30459: PUSH
30460: LD_INT 30
30462: PUSH
30463: LD_INT 33
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 91
30477: PUSH
30478: LD_VAR 0 1
30482: PUSH
30483: LD_INT 12
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: LIST
30490: PUSH
30491: EMPTY
30492: LIST
30493: LIST
30494: LIST
30495: PUSH
30496: EMPTY
30497: LIST
30498: PPUSH
30499: CALL_OW 69
30503: PUSH
30504: LD_INT 2
30506: GREATER
30507: AND
30508: IFFALSE 30531
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30510: LD_ADDR_VAR 0 18
30514: PUSH
30515: LD_INT 11
30517: PUSH
30518: LD_INT 30
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: LD_VAR 0 12
30529: ARRAY
30530: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30531: LD_VAR 0 18
30535: NOT
30536: PUSH
30537: LD_INT 40
30539: PPUSH
30540: LD_VAR 0 16
30544: PPUSH
30545: CALL_OW 321
30549: PUSH
30550: LD_INT 2
30552: EQUAL
30553: AND
30554: PUSH
30555: LD_INT 7
30557: PUSH
30558: LD_VAR 0 5
30562: IN
30563: PUSH
30564: LD_INT 28
30566: PUSH
30567: LD_VAR 0 5
30571: IN
30572: OR
30573: PUSH
30574: LD_INT 45
30576: PUSH
30577: LD_VAR 0 5
30581: IN
30582: OR
30583: AND
30584: IFFALSE 30838
// begin hex := GetHexInfo ( x , y ) ;
30586: LD_ADDR_VAR 0 4
30590: PUSH
30591: LD_VAR 0 10
30595: PPUSH
30596: LD_VAR 0 11
30600: PPUSH
30601: CALL_OW 546
30605: ST_TO_ADDR
// if hex [ 1 ] then
30606: LD_VAR 0 4
30610: PUSH
30611: LD_INT 1
30613: ARRAY
30614: IFFALSE 30618
// exit ;
30616: GO 31021
// height := hex [ 2 ] ;
30618: LD_ADDR_VAR 0 15
30622: PUSH
30623: LD_VAR 0 4
30627: PUSH
30628: LD_INT 2
30630: ARRAY
30631: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30632: LD_ADDR_VAR 0 14
30636: PUSH
30637: LD_INT 0
30639: PUSH
30640: LD_INT 2
30642: PUSH
30643: LD_INT 3
30645: PUSH
30646: LD_INT 5
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: LIST
30653: LIST
30654: ST_TO_ADDR
// for i in tmp do
30655: LD_ADDR_VAR 0 8
30659: PUSH
30660: LD_VAR 0 14
30664: PUSH
30665: FOR_IN
30666: IFFALSE 30836
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30668: LD_ADDR_VAR 0 9
30672: PUSH
30673: LD_VAR 0 10
30677: PPUSH
30678: LD_VAR 0 8
30682: PPUSH
30683: LD_INT 5
30685: PPUSH
30686: CALL_OW 272
30690: PUSH
30691: LD_VAR 0 11
30695: PPUSH
30696: LD_VAR 0 8
30700: PPUSH
30701: LD_INT 5
30703: PPUSH
30704: CALL_OW 273
30708: PUSH
30709: EMPTY
30710: LIST
30711: LIST
30712: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30713: LD_VAR 0 9
30717: PUSH
30718: LD_INT 1
30720: ARRAY
30721: PPUSH
30722: LD_VAR 0 9
30726: PUSH
30727: LD_INT 2
30729: ARRAY
30730: PPUSH
30731: CALL_OW 488
30735: IFFALSE 30834
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30737: LD_ADDR_VAR 0 4
30741: PUSH
30742: LD_VAR 0 9
30746: PUSH
30747: LD_INT 1
30749: ARRAY
30750: PPUSH
30751: LD_VAR 0 9
30755: PUSH
30756: LD_INT 2
30758: ARRAY
30759: PPUSH
30760: CALL_OW 546
30764: ST_TO_ADDR
// if hex [ 1 ] then
30765: LD_VAR 0 4
30769: PUSH
30770: LD_INT 1
30772: ARRAY
30773: IFFALSE 30777
// continue ;
30775: GO 30665
// h := hex [ 2 ] ;
30777: LD_ADDR_VAR 0 13
30781: PUSH
30782: LD_VAR 0 4
30786: PUSH
30787: LD_INT 2
30789: ARRAY
30790: ST_TO_ADDR
// if h + 7 < height then
30791: LD_VAR 0 13
30795: PUSH
30796: LD_INT 7
30798: PLUS
30799: PUSH
30800: LD_VAR 0 15
30804: LESS
30805: IFFALSE 30834
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30807: LD_ADDR_VAR 0 18
30811: PUSH
30812: LD_INT 7
30814: PUSH
30815: LD_INT 28
30817: PUSH
30818: LD_INT 45
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: LIST
30825: PUSH
30826: LD_VAR 0 12
30830: ARRAY
30831: ST_TO_ADDR
// break ;
30832: GO 30836
// end ; end ; end ;
30834: GO 30665
30836: POP
30837: POP
// end ; if not weapon then
30838: LD_VAR 0 18
30842: NOT
30843: IFFALSE 30903
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30845: LD_ADDR_VAR 0 5
30849: PUSH
30850: LD_VAR 0 5
30854: PUSH
30855: LD_INT 11
30857: PUSH
30858: LD_INT 30
30860: PUSH
30861: LD_INT 49
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: LIST
30868: DIFF
30869: ST_TO_ADDR
// if not list then
30870: LD_VAR 0 5
30874: NOT
30875: IFFALSE 30879
// exit ;
30877: GO 31021
// weapon := list [ rand ( 1 , list ) ] ;
30879: LD_ADDR_VAR 0 18
30883: PUSH
30884: LD_VAR 0 5
30888: PUSH
30889: LD_INT 1
30891: PPUSH
30892: LD_VAR 0 5
30896: PPUSH
30897: CALL_OW 12
30901: ARRAY
30902: ST_TO_ADDR
// end ; if weapon then
30903: LD_VAR 0 18
30907: IFFALSE 31021
// begin tmp := CostOfWeapon ( weapon ) ;
30909: LD_ADDR_VAR 0 14
30913: PUSH
30914: LD_VAR 0 18
30918: PPUSH
30919: CALL_OW 451
30923: ST_TO_ADDR
// j := GetBase ( tower ) ;
30924: LD_ADDR_VAR 0 9
30928: PUSH
30929: LD_VAR 0 1
30933: PPUSH
30934: CALL_OW 274
30938: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30939: LD_VAR 0 9
30943: PPUSH
30944: LD_INT 1
30946: PPUSH
30947: CALL_OW 275
30951: PUSH
30952: LD_VAR 0 14
30956: PUSH
30957: LD_INT 1
30959: ARRAY
30960: GREATEREQUAL
30961: PUSH
30962: LD_VAR 0 9
30966: PPUSH
30967: LD_INT 2
30969: PPUSH
30970: CALL_OW 275
30974: PUSH
30975: LD_VAR 0 14
30979: PUSH
30980: LD_INT 2
30982: ARRAY
30983: GREATEREQUAL
30984: AND
30985: PUSH
30986: LD_VAR 0 9
30990: PPUSH
30991: LD_INT 3
30993: PPUSH
30994: CALL_OW 275
30998: PUSH
30999: LD_VAR 0 14
31003: PUSH
31004: LD_INT 3
31006: ARRAY
31007: GREATEREQUAL
31008: AND
31009: IFFALSE 31021
// result := weapon ;
31011: LD_ADDR_VAR 0 3
31015: PUSH
31016: LD_VAR 0 18
31020: ST_TO_ADDR
// end ; end ;
31021: LD_VAR 0 3
31025: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31026: LD_INT 0
31028: PPUSH
31029: PPUSH
// result := true ;
31030: LD_ADDR_VAR 0 3
31034: PUSH
31035: LD_INT 1
31037: ST_TO_ADDR
// if array1 = array2 then
31038: LD_VAR 0 1
31042: PUSH
31043: LD_VAR 0 2
31047: EQUAL
31048: IFFALSE 31108
// begin for i = 1 to array1 do
31050: LD_ADDR_VAR 0 4
31054: PUSH
31055: DOUBLE
31056: LD_INT 1
31058: DEC
31059: ST_TO_ADDR
31060: LD_VAR 0 1
31064: PUSH
31065: FOR_TO
31066: IFFALSE 31104
// if array1 [ i ] <> array2 [ i ] then
31068: LD_VAR 0 1
31072: PUSH
31073: LD_VAR 0 4
31077: ARRAY
31078: PUSH
31079: LD_VAR 0 2
31083: PUSH
31084: LD_VAR 0 4
31088: ARRAY
31089: NONEQUAL
31090: IFFALSE 31102
// begin result := false ;
31092: LD_ADDR_VAR 0 3
31096: PUSH
31097: LD_INT 0
31099: ST_TO_ADDR
// break ;
31100: GO 31104
// end ;
31102: GO 31065
31104: POP
31105: POP
// end else
31106: GO 31116
// result := false ;
31108: LD_ADDR_VAR 0 3
31112: PUSH
31113: LD_INT 0
31115: ST_TO_ADDR
// end ;
31116: LD_VAR 0 3
31120: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31121: LD_INT 0
31123: PPUSH
31124: PPUSH
// if not array1 or not array2 then
31125: LD_VAR 0 1
31129: NOT
31130: PUSH
31131: LD_VAR 0 2
31135: NOT
31136: OR
31137: IFFALSE 31141
// exit ;
31139: GO 31205
// result := true ;
31141: LD_ADDR_VAR 0 3
31145: PUSH
31146: LD_INT 1
31148: ST_TO_ADDR
// for i = 1 to array1 do
31149: LD_ADDR_VAR 0 4
31153: PUSH
31154: DOUBLE
31155: LD_INT 1
31157: DEC
31158: ST_TO_ADDR
31159: LD_VAR 0 1
31163: PUSH
31164: FOR_TO
31165: IFFALSE 31203
// if array1 [ i ] <> array2 [ i ] then
31167: LD_VAR 0 1
31171: PUSH
31172: LD_VAR 0 4
31176: ARRAY
31177: PUSH
31178: LD_VAR 0 2
31182: PUSH
31183: LD_VAR 0 4
31187: ARRAY
31188: NONEQUAL
31189: IFFALSE 31201
// begin result := false ;
31191: LD_ADDR_VAR 0 3
31195: PUSH
31196: LD_INT 0
31198: ST_TO_ADDR
// break ;
31199: GO 31203
// end ;
31201: GO 31164
31203: POP
31204: POP
// end ;
31205: LD_VAR 0 3
31209: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31210: LD_INT 0
31212: PPUSH
31213: PPUSH
31214: PPUSH
// pom := GetBase ( fac ) ;
31215: LD_ADDR_VAR 0 5
31219: PUSH
31220: LD_VAR 0 1
31224: PPUSH
31225: CALL_OW 274
31229: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31230: LD_ADDR_VAR 0 4
31234: PUSH
31235: LD_VAR 0 2
31239: PUSH
31240: LD_INT 1
31242: ARRAY
31243: PPUSH
31244: LD_VAR 0 2
31248: PUSH
31249: LD_INT 2
31251: ARRAY
31252: PPUSH
31253: LD_VAR 0 2
31257: PUSH
31258: LD_INT 3
31260: ARRAY
31261: PPUSH
31262: LD_VAR 0 2
31266: PUSH
31267: LD_INT 4
31269: ARRAY
31270: PPUSH
31271: CALL_OW 449
31275: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31276: LD_ADDR_VAR 0 3
31280: PUSH
31281: LD_VAR 0 5
31285: PPUSH
31286: LD_INT 1
31288: PPUSH
31289: CALL_OW 275
31293: PUSH
31294: LD_VAR 0 4
31298: PUSH
31299: LD_INT 1
31301: ARRAY
31302: GREATEREQUAL
31303: PUSH
31304: LD_VAR 0 5
31308: PPUSH
31309: LD_INT 2
31311: PPUSH
31312: CALL_OW 275
31316: PUSH
31317: LD_VAR 0 4
31321: PUSH
31322: LD_INT 2
31324: ARRAY
31325: GREATEREQUAL
31326: AND
31327: PUSH
31328: LD_VAR 0 5
31332: PPUSH
31333: LD_INT 3
31335: PPUSH
31336: CALL_OW 275
31340: PUSH
31341: LD_VAR 0 4
31345: PUSH
31346: LD_INT 3
31348: ARRAY
31349: GREATEREQUAL
31350: AND
31351: ST_TO_ADDR
// end ;
31352: LD_VAR 0 3
31356: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31357: LD_INT 0
31359: PPUSH
31360: PPUSH
31361: PPUSH
31362: PPUSH
// pom := GetBase ( building ) ;
31363: LD_ADDR_VAR 0 3
31367: PUSH
31368: LD_VAR 0 1
31372: PPUSH
31373: CALL_OW 274
31377: ST_TO_ADDR
// if not pom then
31378: LD_VAR 0 3
31382: NOT
31383: IFFALSE 31387
// exit ;
31385: GO 31557
// btype := GetBType ( building ) ;
31387: LD_ADDR_VAR 0 5
31391: PUSH
31392: LD_VAR 0 1
31396: PPUSH
31397: CALL_OW 266
31401: ST_TO_ADDR
// if btype = b_armoury then
31402: LD_VAR 0 5
31406: PUSH
31407: LD_INT 4
31409: EQUAL
31410: IFFALSE 31420
// btype := b_barracks ;
31412: LD_ADDR_VAR 0 5
31416: PUSH
31417: LD_INT 5
31419: ST_TO_ADDR
// if btype = b_depot then
31420: LD_VAR 0 5
31424: PUSH
31425: LD_INT 0
31427: EQUAL
31428: IFFALSE 31438
// btype := b_warehouse ;
31430: LD_ADDR_VAR 0 5
31434: PUSH
31435: LD_INT 1
31437: ST_TO_ADDR
// if btype = b_workshop then
31438: LD_VAR 0 5
31442: PUSH
31443: LD_INT 2
31445: EQUAL
31446: IFFALSE 31456
// btype := b_factory ;
31448: LD_ADDR_VAR 0 5
31452: PUSH
31453: LD_INT 3
31455: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31456: LD_ADDR_VAR 0 4
31460: PUSH
31461: LD_VAR 0 5
31465: PPUSH
31466: LD_VAR 0 1
31470: PPUSH
31471: CALL_OW 248
31475: PPUSH
31476: CALL_OW 450
31480: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31481: LD_ADDR_VAR 0 2
31485: PUSH
31486: LD_VAR 0 3
31490: PPUSH
31491: LD_INT 1
31493: PPUSH
31494: CALL_OW 275
31498: PUSH
31499: LD_VAR 0 4
31503: PUSH
31504: LD_INT 1
31506: ARRAY
31507: GREATEREQUAL
31508: PUSH
31509: LD_VAR 0 3
31513: PPUSH
31514: LD_INT 2
31516: PPUSH
31517: CALL_OW 275
31521: PUSH
31522: LD_VAR 0 4
31526: PUSH
31527: LD_INT 2
31529: ARRAY
31530: GREATEREQUAL
31531: AND
31532: PUSH
31533: LD_VAR 0 3
31537: PPUSH
31538: LD_INT 3
31540: PPUSH
31541: CALL_OW 275
31545: PUSH
31546: LD_VAR 0 4
31550: PUSH
31551: LD_INT 3
31553: ARRAY
31554: GREATEREQUAL
31555: AND
31556: ST_TO_ADDR
// end ;
31557: LD_VAR 0 2
31561: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31562: LD_INT 0
31564: PPUSH
31565: PPUSH
31566: PPUSH
// pom := GetBase ( building ) ;
31567: LD_ADDR_VAR 0 4
31571: PUSH
31572: LD_VAR 0 1
31576: PPUSH
31577: CALL_OW 274
31581: ST_TO_ADDR
// if not pom then
31582: LD_VAR 0 4
31586: NOT
31587: IFFALSE 31591
// exit ;
31589: GO 31692
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31591: LD_ADDR_VAR 0 5
31595: PUSH
31596: LD_VAR 0 2
31600: PPUSH
31601: LD_VAR 0 1
31605: PPUSH
31606: CALL_OW 248
31610: PPUSH
31611: CALL_OW 450
31615: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31616: LD_ADDR_VAR 0 3
31620: PUSH
31621: LD_VAR 0 4
31625: PPUSH
31626: LD_INT 1
31628: PPUSH
31629: CALL_OW 275
31633: PUSH
31634: LD_VAR 0 5
31638: PUSH
31639: LD_INT 1
31641: ARRAY
31642: GREATEREQUAL
31643: PUSH
31644: LD_VAR 0 4
31648: PPUSH
31649: LD_INT 2
31651: PPUSH
31652: CALL_OW 275
31656: PUSH
31657: LD_VAR 0 5
31661: PUSH
31662: LD_INT 2
31664: ARRAY
31665: GREATEREQUAL
31666: AND
31667: PUSH
31668: LD_VAR 0 4
31672: PPUSH
31673: LD_INT 3
31675: PPUSH
31676: CALL_OW 275
31680: PUSH
31681: LD_VAR 0 5
31685: PUSH
31686: LD_INT 3
31688: ARRAY
31689: GREATEREQUAL
31690: AND
31691: ST_TO_ADDR
// end ;
31692: LD_VAR 0 3
31696: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31697: LD_INT 0
31699: PPUSH
31700: PPUSH
31701: PPUSH
31702: PPUSH
31703: PPUSH
31704: PPUSH
31705: PPUSH
31706: PPUSH
31707: PPUSH
31708: PPUSH
31709: PPUSH
// result := false ;
31710: LD_ADDR_VAR 0 8
31714: PUSH
31715: LD_INT 0
31717: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31718: LD_VAR 0 5
31722: NOT
31723: PUSH
31724: LD_VAR 0 1
31728: NOT
31729: OR
31730: PUSH
31731: LD_VAR 0 2
31735: NOT
31736: OR
31737: PUSH
31738: LD_VAR 0 3
31742: NOT
31743: OR
31744: IFFALSE 31748
// exit ;
31746: GO 32562
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31748: LD_ADDR_VAR 0 14
31752: PUSH
31753: LD_VAR 0 1
31757: PPUSH
31758: LD_VAR 0 2
31762: PPUSH
31763: LD_VAR 0 3
31767: PPUSH
31768: LD_VAR 0 4
31772: PPUSH
31773: LD_VAR 0 5
31777: PUSH
31778: LD_INT 1
31780: ARRAY
31781: PPUSH
31782: CALL_OW 248
31786: PPUSH
31787: LD_INT 0
31789: PPUSH
31790: CALL 33795 0 6
31794: ST_TO_ADDR
// if not hexes then
31795: LD_VAR 0 14
31799: NOT
31800: IFFALSE 31804
// exit ;
31802: GO 32562
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31804: LD_ADDR_VAR 0 17
31808: PUSH
31809: LD_VAR 0 5
31813: PPUSH
31814: LD_INT 22
31816: PUSH
31817: LD_VAR 0 13
31821: PPUSH
31822: CALL_OW 255
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 2
31833: PUSH
31834: LD_INT 30
31836: PUSH
31837: LD_INT 0
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 30
31846: PUSH
31847: LD_INT 1
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: LIST
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PPUSH
31863: CALL_OW 72
31867: ST_TO_ADDR
// for i = 1 to hexes do
31868: LD_ADDR_VAR 0 9
31872: PUSH
31873: DOUBLE
31874: LD_INT 1
31876: DEC
31877: ST_TO_ADDR
31878: LD_VAR 0 14
31882: PUSH
31883: FOR_TO
31884: IFFALSE 32560
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31886: LD_ADDR_VAR 0 13
31890: PUSH
31891: LD_VAR 0 14
31895: PUSH
31896: LD_VAR 0 9
31900: ARRAY
31901: PUSH
31902: LD_INT 1
31904: ARRAY
31905: PPUSH
31906: LD_VAR 0 14
31910: PUSH
31911: LD_VAR 0 9
31915: ARRAY
31916: PUSH
31917: LD_INT 2
31919: ARRAY
31920: PPUSH
31921: CALL_OW 428
31925: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31926: LD_VAR 0 14
31930: PUSH
31931: LD_VAR 0 9
31935: ARRAY
31936: PUSH
31937: LD_INT 1
31939: ARRAY
31940: PPUSH
31941: LD_VAR 0 14
31945: PUSH
31946: LD_VAR 0 9
31950: ARRAY
31951: PUSH
31952: LD_INT 2
31954: ARRAY
31955: PPUSH
31956: CALL_OW 351
31960: PUSH
31961: LD_VAR 0 14
31965: PUSH
31966: LD_VAR 0 9
31970: ARRAY
31971: PUSH
31972: LD_INT 1
31974: ARRAY
31975: PPUSH
31976: LD_VAR 0 14
31980: PUSH
31981: LD_VAR 0 9
31985: ARRAY
31986: PUSH
31987: LD_INT 2
31989: ARRAY
31990: PPUSH
31991: CALL_OW 488
31995: NOT
31996: OR
31997: PUSH
31998: LD_VAR 0 13
32002: PPUSH
32003: CALL_OW 247
32007: PUSH
32008: LD_INT 3
32010: EQUAL
32011: OR
32012: IFFALSE 32018
// exit ;
32014: POP
32015: POP
32016: GO 32562
// if not tmp then
32018: LD_VAR 0 13
32022: NOT
32023: IFFALSE 32027
// continue ;
32025: GO 31883
// result := true ;
32027: LD_ADDR_VAR 0 8
32031: PUSH
32032: LD_INT 1
32034: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32035: LD_VAR 0 6
32039: PUSH
32040: LD_VAR 0 13
32044: PPUSH
32045: CALL_OW 247
32049: PUSH
32050: LD_INT 2
32052: EQUAL
32053: AND
32054: PUSH
32055: LD_VAR 0 13
32059: PPUSH
32060: CALL_OW 263
32064: PUSH
32065: LD_INT 1
32067: EQUAL
32068: AND
32069: IFFALSE 32233
// begin if IsDrivenBy ( tmp ) then
32071: LD_VAR 0 13
32075: PPUSH
32076: CALL_OW 311
32080: IFFALSE 32084
// continue ;
32082: GO 31883
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32084: LD_VAR 0 6
32088: PPUSH
32089: LD_INT 3
32091: PUSH
32092: LD_INT 60
32094: PUSH
32095: EMPTY
32096: LIST
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 3
32104: PUSH
32105: LD_INT 55
32107: PUSH
32108: EMPTY
32109: LIST
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PPUSH
32119: CALL_OW 72
32123: IFFALSE 32231
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32125: LD_ADDR_VAR 0 18
32129: PUSH
32130: LD_VAR 0 6
32134: PPUSH
32135: LD_INT 3
32137: PUSH
32138: LD_INT 60
32140: PUSH
32141: EMPTY
32142: LIST
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 3
32150: PUSH
32151: LD_INT 55
32153: PUSH
32154: EMPTY
32155: LIST
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PPUSH
32165: CALL_OW 72
32169: PUSH
32170: LD_INT 1
32172: ARRAY
32173: ST_TO_ADDR
// if IsInUnit ( driver ) then
32174: LD_VAR 0 18
32178: PPUSH
32179: CALL_OW 310
32183: IFFALSE 32194
// ComExit ( driver ) ;
32185: LD_VAR 0 18
32189: PPUSH
32190: CALL 57574 0 1
// AddComEnterUnit ( driver , tmp ) ;
32194: LD_VAR 0 18
32198: PPUSH
32199: LD_VAR 0 13
32203: PPUSH
32204: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32208: LD_VAR 0 18
32212: PPUSH
32213: LD_VAR 0 7
32217: PPUSH
32218: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32222: LD_VAR 0 18
32226: PPUSH
32227: CALL_OW 181
// end ; continue ;
32231: GO 31883
// end ; if not cleaners or not tmp in cleaners then
32233: LD_VAR 0 6
32237: NOT
32238: PUSH
32239: LD_VAR 0 13
32243: PUSH
32244: LD_VAR 0 6
32248: IN
32249: NOT
32250: OR
32251: IFFALSE 32558
// begin if dep then
32253: LD_VAR 0 17
32257: IFFALSE 32393
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32259: LD_ADDR_VAR 0 16
32263: PUSH
32264: LD_VAR 0 17
32268: PUSH
32269: LD_INT 1
32271: ARRAY
32272: PPUSH
32273: CALL_OW 250
32277: PPUSH
32278: LD_VAR 0 17
32282: PUSH
32283: LD_INT 1
32285: ARRAY
32286: PPUSH
32287: CALL_OW 254
32291: PPUSH
32292: LD_INT 5
32294: PPUSH
32295: CALL_OW 272
32299: PUSH
32300: LD_VAR 0 17
32304: PUSH
32305: LD_INT 1
32307: ARRAY
32308: PPUSH
32309: CALL_OW 251
32313: PPUSH
32314: LD_VAR 0 17
32318: PUSH
32319: LD_INT 1
32321: ARRAY
32322: PPUSH
32323: CALL_OW 254
32327: PPUSH
32328: LD_INT 5
32330: PPUSH
32331: CALL_OW 273
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32340: LD_VAR 0 16
32344: PUSH
32345: LD_INT 1
32347: ARRAY
32348: PPUSH
32349: LD_VAR 0 16
32353: PUSH
32354: LD_INT 2
32356: ARRAY
32357: PPUSH
32358: CALL_OW 488
32362: IFFALSE 32393
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32364: LD_VAR 0 13
32368: PPUSH
32369: LD_VAR 0 16
32373: PUSH
32374: LD_INT 1
32376: ARRAY
32377: PPUSH
32378: LD_VAR 0 16
32382: PUSH
32383: LD_INT 2
32385: ARRAY
32386: PPUSH
32387: CALL_OW 111
// continue ;
32391: GO 31883
// end ; end ; r := GetDir ( tmp ) ;
32393: LD_ADDR_VAR 0 15
32397: PUSH
32398: LD_VAR 0 13
32402: PPUSH
32403: CALL_OW 254
32407: ST_TO_ADDR
// if r = 5 then
32408: LD_VAR 0 15
32412: PUSH
32413: LD_INT 5
32415: EQUAL
32416: IFFALSE 32426
// r := 0 ;
32418: LD_ADDR_VAR 0 15
32422: PUSH
32423: LD_INT 0
32425: ST_TO_ADDR
// for j = r to 5 do
32426: LD_ADDR_VAR 0 10
32430: PUSH
32431: DOUBLE
32432: LD_VAR 0 15
32436: DEC
32437: ST_TO_ADDR
32438: LD_INT 5
32440: PUSH
32441: FOR_TO
32442: IFFALSE 32556
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32444: LD_ADDR_VAR 0 11
32448: PUSH
32449: LD_VAR 0 13
32453: PPUSH
32454: CALL_OW 250
32458: PPUSH
32459: LD_VAR 0 10
32463: PPUSH
32464: LD_INT 2
32466: PPUSH
32467: CALL_OW 272
32471: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32472: LD_ADDR_VAR 0 12
32476: PUSH
32477: LD_VAR 0 13
32481: PPUSH
32482: CALL_OW 251
32486: PPUSH
32487: LD_VAR 0 10
32491: PPUSH
32492: LD_INT 2
32494: PPUSH
32495: CALL_OW 273
32499: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32500: LD_VAR 0 11
32504: PPUSH
32505: LD_VAR 0 12
32509: PPUSH
32510: CALL_OW 488
32514: PUSH
32515: LD_VAR 0 11
32519: PPUSH
32520: LD_VAR 0 12
32524: PPUSH
32525: CALL_OW 428
32529: NOT
32530: AND
32531: IFFALSE 32554
// begin ComMoveXY ( tmp , _x , _y ) ;
32533: LD_VAR 0 13
32537: PPUSH
32538: LD_VAR 0 11
32542: PPUSH
32543: LD_VAR 0 12
32547: PPUSH
32548: CALL_OW 111
// break ;
32552: GO 32556
// end ; end ;
32554: GO 32441
32556: POP
32557: POP
// end ; end ;
32558: GO 31883
32560: POP
32561: POP
// end ;
32562: LD_VAR 0 8
32566: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32567: LD_INT 0
32569: PPUSH
// result := true ;
32570: LD_ADDR_VAR 0 3
32574: PUSH
32575: LD_INT 1
32577: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32578: LD_VAR 0 2
32582: PUSH
32583: LD_INT 24
32585: DOUBLE
32586: EQUAL
32587: IFTRUE 32597
32589: LD_INT 33
32591: DOUBLE
32592: EQUAL
32593: IFTRUE 32597
32595: GO 32622
32597: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32598: LD_ADDR_VAR 0 3
32602: PUSH
32603: LD_INT 32
32605: PPUSH
32606: LD_VAR 0 1
32610: PPUSH
32611: CALL_OW 321
32615: PUSH
32616: LD_INT 2
32618: EQUAL
32619: ST_TO_ADDR
32620: GO 32938
32622: LD_INT 20
32624: DOUBLE
32625: EQUAL
32626: IFTRUE 32630
32628: GO 32655
32630: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32631: LD_ADDR_VAR 0 3
32635: PUSH
32636: LD_INT 6
32638: PPUSH
32639: LD_VAR 0 1
32643: PPUSH
32644: CALL_OW 321
32648: PUSH
32649: LD_INT 2
32651: EQUAL
32652: ST_TO_ADDR
32653: GO 32938
32655: LD_INT 22
32657: DOUBLE
32658: EQUAL
32659: IFTRUE 32669
32661: LD_INT 36
32663: DOUBLE
32664: EQUAL
32665: IFTRUE 32669
32667: GO 32694
32669: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32670: LD_ADDR_VAR 0 3
32674: PUSH
32675: LD_INT 15
32677: PPUSH
32678: LD_VAR 0 1
32682: PPUSH
32683: CALL_OW 321
32687: PUSH
32688: LD_INT 2
32690: EQUAL
32691: ST_TO_ADDR
32692: GO 32938
32694: LD_INT 30
32696: DOUBLE
32697: EQUAL
32698: IFTRUE 32702
32700: GO 32727
32702: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32703: LD_ADDR_VAR 0 3
32707: PUSH
32708: LD_INT 20
32710: PPUSH
32711: LD_VAR 0 1
32715: PPUSH
32716: CALL_OW 321
32720: PUSH
32721: LD_INT 2
32723: EQUAL
32724: ST_TO_ADDR
32725: GO 32938
32727: LD_INT 28
32729: DOUBLE
32730: EQUAL
32731: IFTRUE 32741
32733: LD_INT 21
32735: DOUBLE
32736: EQUAL
32737: IFTRUE 32741
32739: GO 32766
32741: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32742: LD_ADDR_VAR 0 3
32746: PUSH
32747: LD_INT 21
32749: PPUSH
32750: LD_VAR 0 1
32754: PPUSH
32755: CALL_OW 321
32759: PUSH
32760: LD_INT 2
32762: EQUAL
32763: ST_TO_ADDR
32764: GO 32938
32766: LD_INT 16
32768: DOUBLE
32769: EQUAL
32770: IFTRUE 32774
32772: GO 32799
32774: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32775: LD_ADDR_VAR 0 3
32779: PUSH
32780: LD_INT 84
32782: PPUSH
32783: LD_VAR 0 1
32787: PPUSH
32788: CALL_OW 321
32792: PUSH
32793: LD_INT 2
32795: EQUAL
32796: ST_TO_ADDR
32797: GO 32938
32799: LD_INT 19
32801: DOUBLE
32802: EQUAL
32803: IFTRUE 32813
32805: LD_INT 23
32807: DOUBLE
32808: EQUAL
32809: IFTRUE 32813
32811: GO 32838
32813: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32814: LD_ADDR_VAR 0 3
32818: PUSH
32819: LD_INT 83
32821: PPUSH
32822: LD_VAR 0 1
32826: PPUSH
32827: CALL_OW 321
32831: PUSH
32832: LD_INT 2
32834: EQUAL
32835: ST_TO_ADDR
32836: GO 32938
32838: LD_INT 17
32840: DOUBLE
32841: EQUAL
32842: IFTRUE 32846
32844: GO 32871
32846: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32847: LD_ADDR_VAR 0 3
32851: PUSH
32852: LD_INT 39
32854: PPUSH
32855: LD_VAR 0 1
32859: PPUSH
32860: CALL_OW 321
32864: PUSH
32865: LD_INT 2
32867: EQUAL
32868: ST_TO_ADDR
32869: GO 32938
32871: LD_INT 18
32873: DOUBLE
32874: EQUAL
32875: IFTRUE 32879
32877: GO 32904
32879: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32880: LD_ADDR_VAR 0 3
32884: PUSH
32885: LD_INT 40
32887: PPUSH
32888: LD_VAR 0 1
32892: PPUSH
32893: CALL_OW 321
32897: PUSH
32898: LD_INT 2
32900: EQUAL
32901: ST_TO_ADDR
32902: GO 32938
32904: LD_INT 27
32906: DOUBLE
32907: EQUAL
32908: IFTRUE 32912
32910: GO 32937
32912: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32913: LD_ADDR_VAR 0 3
32917: PUSH
32918: LD_INT 35
32920: PPUSH
32921: LD_VAR 0 1
32925: PPUSH
32926: CALL_OW 321
32930: PUSH
32931: LD_INT 2
32933: EQUAL
32934: ST_TO_ADDR
32935: GO 32938
32937: POP
// end ;
32938: LD_VAR 0 3
32942: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32943: LD_INT 0
32945: PPUSH
32946: PPUSH
32947: PPUSH
32948: PPUSH
32949: PPUSH
32950: PPUSH
32951: PPUSH
32952: PPUSH
32953: PPUSH
32954: PPUSH
32955: PPUSH
// result := false ;
32956: LD_ADDR_VAR 0 6
32960: PUSH
32961: LD_INT 0
32963: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32964: LD_VAR 0 1
32968: NOT
32969: PUSH
32970: LD_VAR 0 1
32974: PPUSH
32975: CALL_OW 266
32979: PUSH
32980: LD_INT 0
32982: PUSH
32983: LD_INT 1
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: IN
32990: NOT
32991: OR
32992: PUSH
32993: LD_VAR 0 2
32997: NOT
32998: OR
32999: PUSH
33000: LD_VAR 0 5
33004: PUSH
33005: LD_INT 0
33007: PUSH
33008: LD_INT 1
33010: PUSH
33011: LD_INT 2
33013: PUSH
33014: LD_INT 3
33016: PUSH
33017: LD_INT 4
33019: PUSH
33020: LD_INT 5
33022: PUSH
33023: EMPTY
33024: LIST
33025: LIST
33026: LIST
33027: LIST
33028: LIST
33029: LIST
33030: IN
33031: NOT
33032: OR
33033: PUSH
33034: LD_VAR 0 3
33038: PPUSH
33039: LD_VAR 0 4
33043: PPUSH
33044: CALL_OW 488
33048: NOT
33049: OR
33050: IFFALSE 33054
// exit ;
33052: GO 33790
// side := GetSide ( depot ) ;
33054: LD_ADDR_VAR 0 9
33058: PUSH
33059: LD_VAR 0 1
33063: PPUSH
33064: CALL_OW 255
33068: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33069: LD_VAR 0 9
33073: PPUSH
33074: LD_VAR 0 2
33078: PPUSH
33079: CALL 32567 0 2
33083: NOT
33084: IFFALSE 33088
// exit ;
33086: GO 33790
// pom := GetBase ( depot ) ;
33088: LD_ADDR_VAR 0 10
33092: PUSH
33093: LD_VAR 0 1
33097: PPUSH
33098: CALL_OW 274
33102: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33103: LD_ADDR_VAR 0 11
33107: PUSH
33108: LD_VAR 0 2
33112: PPUSH
33113: LD_VAR 0 1
33117: PPUSH
33118: CALL_OW 248
33122: PPUSH
33123: CALL_OW 450
33127: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33128: LD_VAR 0 10
33132: PPUSH
33133: LD_INT 1
33135: PPUSH
33136: CALL_OW 275
33140: PUSH
33141: LD_VAR 0 11
33145: PUSH
33146: LD_INT 1
33148: ARRAY
33149: GREATEREQUAL
33150: PUSH
33151: LD_VAR 0 10
33155: PPUSH
33156: LD_INT 2
33158: PPUSH
33159: CALL_OW 275
33163: PUSH
33164: LD_VAR 0 11
33168: PUSH
33169: LD_INT 2
33171: ARRAY
33172: GREATEREQUAL
33173: AND
33174: PUSH
33175: LD_VAR 0 10
33179: PPUSH
33180: LD_INT 3
33182: PPUSH
33183: CALL_OW 275
33187: PUSH
33188: LD_VAR 0 11
33192: PUSH
33193: LD_INT 3
33195: ARRAY
33196: GREATEREQUAL
33197: AND
33198: NOT
33199: IFFALSE 33203
// exit ;
33201: GO 33790
// if GetBType ( depot ) = b_depot then
33203: LD_VAR 0 1
33207: PPUSH
33208: CALL_OW 266
33212: PUSH
33213: LD_INT 0
33215: EQUAL
33216: IFFALSE 33228
// dist := 28 else
33218: LD_ADDR_VAR 0 14
33222: PUSH
33223: LD_INT 28
33225: ST_TO_ADDR
33226: GO 33236
// dist := 36 ;
33228: LD_ADDR_VAR 0 14
33232: PUSH
33233: LD_INT 36
33235: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33236: LD_VAR 0 1
33240: PPUSH
33241: LD_VAR 0 3
33245: PPUSH
33246: LD_VAR 0 4
33250: PPUSH
33251: CALL_OW 297
33255: PUSH
33256: LD_VAR 0 14
33260: GREATER
33261: IFFALSE 33265
// exit ;
33263: GO 33790
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33265: LD_ADDR_VAR 0 12
33269: PUSH
33270: LD_VAR 0 2
33274: PPUSH
33275: LD_VAR 0 3
33279: PPUSH
33280: LD_VAR 0 4
33284: PPUSH
33285: LD_VAR 0 5
33289: PPUSH
33290: LD_VAR 0 1
33294: PPUSH
33295: CALL_OW 248
33299: PPUSH
33300: LD_INT 0
33302: PPUSH
33303: CALL 33795 0 6
33307: ST_TO_ADDR
// if not hexes then
33308: LD_VAR 0 12
33312: NOT
33313: IFFALSE 33317
// exit ;
33315: GO 33790
// hex := GetHexInfo ( x , y ) ;
33317: LD_ADDR_VAR 0 15
33321: PUSH
33322: LD_VAR 0 3
33326: PPUSH
33327: LD_VAR 0 4
33331: PPUSH
33332: CALL_OW 546
33336: ST_TO_ADDR
// if hex [ 1 ] then
33337: LD_VAR 0 15
33341: PUSH
33342: LD_INT 1
33344: ARRAY
33345: IFFALSE 33349
// exit ;
33347: GO 33790
// height := hex [ 2 ] ;
33349: LD_ADDR_VAR 0 13
33353: PUSH
33354: LD_VAR 0 15
33358: PUSH
33359: LD_INT 2
33361: ARRAY
33362: ST_TO_ADDR
// for i = 1 to hexes do
33363: LD_ADDR_VAR 0 7
33367: PUSH
33368: DOUBLE
33369: LD_INT 1
33371: DEC
33372: ST_TO_ADDR
33373: LD_VAR 0 12
33377: PUSH
33378: FOR_TO
33379: IFFALSE 33709
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33381: LD_VAR 0 12
33385: PUSH
33386: LD_VAR 0 7
33390: ARRAY
33391: PUSH
33392: LD_INT 1
33394: ARRAY
33395: PPUSH
33396: LD_VAR 0 12
33400: PUSH
33401: LD_VAR 0 7
33405: ARRAY
33406: PUSH
33407: LD_INT 2
33409: ARRAY
33410: PPUSH
33411: CALL_OW 488
33415: NOT
33416: PUSH
33417: LD_VAR 0 12
33421: PUSH
33422: LD_VAR 0 7
33426: ARRAY
33427: PUSH
33428: LD_INT 1
33430: ARRAY
33431: PPUSH
33432: LD_VAR 0 12
33436: PUSH
33437: LD_VAR 0 7
33441: ARRAY
33442: PUSH
33443: LD_INT 2
33445: ARRAY
33446: PPUSH
33447: CALL_OW 428
33451: PUSH
33452: LD_INT 0
33454: GREATER
33455: OR
33456: PUSH
33457: LD_VAR 0 12
33461: PUSH
33462: LD_VAR 0 7
33466: ARRAY
33467: PUSH
33468: LD_INT 1
33470: ARRAY
33471: PPUSH
33472: LD_VAR 0 12
33476: PUSH
33477: LD_VAR 0 7
33481: ARRAY
33482: PUSH
33483: LD_INT 2
33485: ARRAY
33486: PPUSH
33487: CALL_OW 351
33491: OR
33492: IFFALSE 33498
// exit ;
33494: POP
33495: POP
33496: GO 33790
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33498: LD_ADDR_VAR 0 8
33502: PUSH
33503: LD_VAR 0 12
33507: PUSH
33508: LD_VAR 0 7
33512: ARRAY
33513: PUSH
33514: LD_INT 1
33516: ARRAY
33517: PPUSH
33518: LD_VAR 0 12
33522: PUSH
33523: LD_VAR 0 7
33527: ARRAY
33528: PUSH
33529: LD_INT 2
33531: ARRAY
33532: PPUSH
33533: CALL_OW 546
33537: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33538: LD_VAR 0 8
33542: PUSH
33543: LD_INT 1
33545: ARRAY
33546: PUSH
33547: LD_VAR 0 8
33551: PUSH
33552: LD_INT 2
33554: ARRAY
33555: PUSH
33556: LD_VAR 0 13
33560: PUSH
33561: LD_INT 2
33563: PLUS
33564: GREATER
33565: OR
33566: PUSH
33567: LD_VAR 0 8
33571: PUSH
33572: LD_INT 2
33574: ARRAY
33575: PUSH
33576: LD_VAR 0 13
33580: PUSH
33581: LD_INT 2
33583: MINUS
33584: LESS
33585: OR
33586: PUSH
33587: LD_VAR 0 8
33591: PUSH
33592: LD_INT 3
33594: ARRAY
33595: PUSH
33596: LD_INT 0
33598: PUSH
33599: LD_INT 8
33601: PUSH
33602: LD_INT 9
33604: PUSH
33605: LD_INT 10
33607: PUSH
33608: LD_INT 11
33610: PUSH
33611: LD_INT 12
33613: PUSH
33614: LD_INT 13
33616: PUSH
33617: LD_INT 16
33619: PUSH
33620: LD_INT 17
33622: PUSH
33623: LD_INT 18
33625: PUSH
33626: LD_INT 19
33628: PUSH
33629: LD_INT 20
33631: PUSH
33632: LD_INT 21
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: LIST
33639: LIST
33640: LIST
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: IN
33650: NOT
33651: OR
33652: PUSH
33653: LD_VAR 0 8
33657: PUSH
33658: LD_INT 5
33660: ARRAY
33661: NOT
33662: OR
33663: PUSH
33664: LD_VAR 0 8
33668: PUSH
33669: LD_INT 6
33671: ARRAY
33672: PUSH
33673: LD_INT 1
33675: PUSH
33676: LD_INT 2
33678: PUSH
33679: LD_INT 7
33681: PUSH
33682: LD_INT 9
33684: PUSH
33685: LD_INT 10
33687: PUSH
33688: LD_INT 11
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: IN
33699: NOT
33700: OR
33701: IFFALSE 33707
// exit ;
33703: POP
33704: POP
33705: GO 33790
// end ;
33707: GO 33378
33709: POP
33710: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33711: LD_VAR 0 9
33715: PPUSH
33716: LD_VAR 0 3
33720: PPUSH
33721: LD_VAR 0 4
33725: PPUSH
33726: LD_INT 20
33728: PPUSH
33729: CALL 25742 0 4
33733: PUSH
33734: LD_INT 4
33736: ARRAY
33737: IFFALSE 33741
// exit ;
33739: GO 33790
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33741: LD_VAR 0 2
33745: PUSH
33746: LD_INT 29
33748: PUSH
33749: LD_INT 30
33751: PUSH
33752: EMPTY
33753: LIST
33754: LIST
33755: IN
33756: PUSH
33757: LD_VAR 0 3
33761: PPUSH
33762: LD_VAR 0 4
33766: PPUSH
33767: LD_VAR 0 9
33771: PPUSH
33772: CALL_OW 440
33776: NOT
33777: AND
33778: IFFALSE 33782
// exit ;
33780: GO 33790
// result := true ;
33782: LD_ADDR_VAR 0 6
33786: PUSH
33787: LD_INT 1
33789: ST_TO_ADDR
// end ;
33790: LD_VAR 0 6
33794: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33795: LD_INT 0
33797: PPUSH
33798: PPUSH
33799: PPUSH
33800: PPUSH
33801: PPUSH
33802: PPUSH
33803: PPUSH
33804: PPUSH
33805: PPUSH
33806: PPUSH
33807: PPUSH
33808: PPUSH
33809: PPUSH
33810: PPUSH
33811: PPUSH
33812: PPUSH
33813: PPUSH
33814: PPUSH
33815: PPUSH
33816: PPUSH
33817: PPUSH
33818: PPUSH
33819: PPUSH
33820: PPUSH
33821: PPUSH
33822: PPUSH
33823: PPUSH
33824: PPUSH
33825: PPUSH
33826: PPUSH
33827: PPUSH
33828: PPUSH
33829: PPUSH
33830: PPUSH
33831: PPUSH
33832: PPUSH
33833: PPUSH
33834: PPUSH
33835: PPUSH
33836: PPUSH
33837: PPUSH
33838: PPUSH
33839: PPUSH
33840: PPUSH
33841: PPUSH
33842: PPUSH
33843: PPUSH
33844: PPUSH
33845: PPUSH
33846: PPUSH
33847: PPUSH
33848: PPUSH
33849: PPUSH
33850: PPUSH
33851: PPUSH
33852: PPUSH
33853: PPUSH
33854: PPUSH
// result = [ ] ;
33855: LD_ADDR_VAR 0 7
33859: PUSH
33860: EMPTY
33861: ST_TO_ADDR
// temp_list = [ ] ;
33862: LD_ADDR_VAR 0 9
33866: PUSH
33867: EMPTY
33868: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33869: LD_VAR 0 4
33873: PUSH
33874: LD_INT 0
33876: PUSH
33877: LD_INT 1
33879: PUSH
33880: LD_INT 2
33882: PUSH
33883: LD_INT 3
33885: PUSH
33886: LD_INT 4
33888: PUSH
33889: LD_INT 5
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: IN
33900: NOT
33901: PUSH
33902: LD_VAR 0 1
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 1
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: IN
33917: PUSH
33918: LD_VAR 0 5
33922: PUSH
33923: LD_INT 1
33925: PUSH
33926: LD_INT 2
33928: PUSH
33929: LD_INT 3
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: LIST
33936: IN
33937: NOT
33938: AND
33939: OR
33940: IFFALSE 33944
// exit ;
33942: GO 52335
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33944: LD_VAR 0 1
33948: PUSH
33949: LD_INT 6
33951: PUSH
33952: LD_INT 7
33954: PUSH
33955: LD_INT 8
33957: PUSH
33958: LD_INT 13
33960: PUSH
33961: LD_INT 12
33963: PUSH
33964: LD_INT 15
33966: PUSH
33967: LD_INT 11
33969: PUSH
33970: LD_INT 14
33972: PUSH
33973: LD_INT 10
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: LIST
33980: LIST
33981: LIST
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: IN
33987: IFFALSE 33997
// btype = b_lab ;
33989: LD_ADDR_VAR 0 1
33993: PUSH
33994: LD_INT 6
33996: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33997: LD_VAR 0 6
34001: PUSH
34002: LD_INT 0
34004: PUSH
34005: LD_INT 1
34007: PUSH
34008: LD_INT 2
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: LIST
34015: IN
34016: NOT
34017: PUSH
34018: LD_VAR 0 1
34022: PUSH
34023: LD_INT 0
34025: PUSH
34026: LD_INT 1
34028: PUSH
34029: LD_INT 2
34031: PUSH
34032: LD_INT 3
34034: PUSH
34035: LD_INT 6
34037: PUSH
34038: LD_INT 36
34040: PUSH
34041: LD_INT 4
34043: PUSH
34044: LD_INT 5
34046: PUSH
34047: LD_INT 31
34049: PUSH
34050: LD_INT 32
34052: PUSH
34053: LD_INT 33
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: IN
34069: NOT
34070: PUSH
34071: LD_VAR 0 6
34075: PUSH
34076: LD_INT 1
34078: EQUAL
34079: AND
34080: OR
34081: PUSH
34082: LD_VAR 0 1
34086: PUSH
34087: LD_INT 2
34089: PUSH
34090: LD_INT 3
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: IN
34097: NOT
34098: PUSH
34099: LD_VAR 0 6
34103: PUSH
34104: LD_INT 2
34106: EQUAL
34107: AND
34108: OR
34109: IFFALSE 34119
// mode = 0 ;
34111: LD_ADDR_VAR 0 6
34115: PUSH
34116: LD_INT 0
34118: ST_TO_ADDR
// case mode of 0 :
34119: LD_VAR 0 6
34123: PUSH
34124: LD_INT 0
34126: DOUBLE
34127: EQUAL
34128: IFTRUE 34132
34130: GO 45585
34132: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34133: LD_ADDR_VAR 0 11
34137: PUSH
34138: LD_INT 0
34140: PUSH
34141: LD_INT 0
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 0
34150: PUSH
34151: LD_INT 1
34153: NEG
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: EMPTY
34166: LIST
34167: LIST
34168: PUSH
34169: LD_INT 1
34171: PUSH
34172: LD_INT 1
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PUSH
34179: LD_INT 0
34181: PUSH
34182: LD_INT 1
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 1
34191: NEG
34192: PUSH
34193: LD_INT 0
34195: PUSH
34196: EMPTY
34197: LIST
34198: LIST
34199: PUSH
34200: LD_INT 1
34202: NEG
34203: PUSH
34204: LD_INT 1
34206: NEG
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 1
34214: NEG
34215: PUSH
34216: LD_INT 2
34218: NEG
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 0
34226: PUSH
34227: LD_INT 2
34229: NEG
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: PUSH
34238: LD_INT 1
34240: NEG
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 1
34248: PUSH
34249: LD_INT 2
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 0
34258: PUSH
34259: LD_INT 2
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 1
34268: NEG
34269: PUSH
34270: LD_INT 1
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: LD_INT 1
34279: PUSH
34280: LD_INT 3
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: LD_INT 3
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 1
34299: NEG
34300: PUSH
34301: LD_INT 2
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: LIST
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34326: LD_ADDR_VAR 0 12
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 0
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 0
34343: PUSH
34344: LD_INT 1
34346: NEG
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: PUSH
34355: LD_INT 0
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 1
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 0
34374: PUSH
34375: LD_INT 1
34377: PUSH
34378: EMPTY
34379: LIST
34380: LIST
34381: PUSH
34382: LD_INT 1
34384: NEG
34385: PUSH
34386: LD_INT 0
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 1
34395: NEG
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 1
34407: PUSH
34408: LD_INT 1
34410: NEG
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 2
34418: PUSH
34419: LD_INT 0
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 2
34428: PUSH
34429: LD_INT 1
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: LD_INT 1
34438: NEG
34439: PUSH
34440: LD_INT 1
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 2
34449: NEG
34450: PUSH
34451: LD_INT 0
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: LD_INT 2
34460: NEG
34461: PUSH
34462: LD_INT 1
34464: NEG
34465: PUSH
34466: EMPTY
34467: LIST
34468: LIST
34469: PUSH
34470: LD_INT 2
34472: NEG
34473: PUSH
34474: LD_INT 1
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 3
34483: NEG
34484: PUSH
34485: LD_INT 0
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 3
34494: NEG
34495: PUSH
34496: LD_INT 1
34498: NEG
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: LIST
34508: LIST
34509: LIST
34510: LIST
34511: LIST
34512: LIST
34513: LIST
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: LIST
34521: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34522: LD_ADDR_VAR 0 13
34526: PUSH
34527: LD_INT 0
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 0
34539: PUSH
34540: LD_INT 1
34542: NEG
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: LD_INT 1
34550: PUSH
34551: LD_INT 0
34553: PUSH
34554: EMPTY
34555: LIST
34556: LIST
34557: PUSH
34558: LD_INT 1
34560: PUSH
34561: LD_INT 1
34563: PUSH
34564: EMPTY
34565: LIST
34566: LIST
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: LD_INT 1
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 1
34580: NEG
34581: PUSH
34582: LD_INT 0
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 1
34591: NEG
34592: PUSH
34593: LD_INT 1
34595: NEG
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 1
34603: NEG
34604: PUSH
34605: LD_INT 2
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 2
34615: PUSH
34616: LD_INT 1
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 2
34625: PUSH
34626: LD_INT 2
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 1
34635: PUSH
34636: LD_INT 2
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 2
34645: NEG
34646: PUSH
34647: LD_INT 1
34649: NEG
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 2
34657: NEG
34658: PUSH
34659: LD_INT 2
34661: NEG
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 2
34669: NEG
34670: PUSH
34671: LD_INT 3
34673: NEG
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 3
34681: NEG
34682: PUSH
34683: LD_INT 2
34685: NEG
34686: PUSH
34687: EMPTY
34688: LIST
34689: LIST
34690: PUSH
34691: LD_INT 3
34693: NEG
34694: PUSH
34695: LD_INT 3
34697: NEG
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34721: LD_ADDR_VAR 0 14
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: LD_INT 0
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 0
34738: PUSH
34739: LD_INT 1
34741: NEG
34742: PUSH
34743: EMPTY
34744: LIST
34745: LIST
34746: PUSH
34747: LD_INT 1
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: EMPTY
34754: LIST
34755: LIST
34756: PUSH
34757: LD_INT 1
34759: PUSH
34760: LD_INT 1
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 0
34769: PUSH
34770: LD_INT 1
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 1
34779: NEG
34780: PUSH
34781: LD_INT 0
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 1
34790: NEG
34791: PUSH
34792: LD_INT 1
34794: NEG
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 1
34802: NEG
34803: PUSH
34804: LD_INT 2
34806: NEG
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 0
34814: PUSH
34815: LD_INT 2
34817: NEG
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 1
34825: PUSH
34826: LD_INT 1
34828: NEG
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 1
34836: PUSH
34837: LD_INT 2
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: LD_INT 2
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 1
34856: NEG
34857: PUSH
34858: LD_INT 1
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 1
34867: NEG
34868: PUSH
34869: LD_INT 3
34871: NEG
34872: PUSH
34873: EMPTY
34874: LIST
34875: LIST
34876: PUSH
34877: LD_INT 0
34879: PUSH
34880: LD_INT 3
34882: NEG
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: LD_INT 2
34893: NEG
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: LIST
34912: LIST
34913: LIST
34914: LIST
34915: LIST
34916: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34917: LD_ADDR_VAR 0 15
34921: PUSH
34922: LD_INT 0
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 0
34934: PUSH
34935: LD_INT 1
34937: NEG
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 1
34945: PUSH
34946: LD_INT 0
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: PUSH
34953: LD_INT 1
34955: PUSH
34956: LD_INT 1
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: LD_INT 1
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: PUSH
34973: LD_INT 1
34975: NEG
34976: PUSH
34977: LD_INT 0
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: LD_INT 1
34986: NEG
34987: PUSH
34988: LD_INT 1
34990: NEG
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 1
34998: PUSH
34999: LD_INT 1
35001: NEG
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: PUSH
35010: LD_INT 0
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 2
35019: PUSH
35020: LD_INT 1
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 1
35029: NEG
35030: PUSH
35031: LD_INT 1
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 2
35040: NEG
35041: PUSH
35042: LD_INT 0
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 2
35051: NEG
35052: PUSH
35053: LD_INT 1
35055: NEG
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 2
35063: PUSH
35064: LD_INT 1
35066: NEG
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 3
35074: PUSH
35075: LD_INT 0
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 3
35084: PUSH
35085: LD_INT 1
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35110: LD_ADDR_VAR 0 16
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: LD_INT 0
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: LD_INT 1
35130: NEG
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 1
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 1
35148: PUSH
35149: LD_INT 1
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: LD_INT 1
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 1
35168: NEG
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 1
35179: NEG
35180: PUSH
35181: LD_INT 1
35183: NEG
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 2
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 2
35213: PUSH
35214: LD_INT 2
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 1
35223: PUSH
35224: LD_INT 2
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 2
35233: NEG
35234: PUSH
35235: LD_INT 1
35237: NEG
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 2
35245: NEG
35246: PUSH
35247: LD_INT 2
35249: NEG
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 3
35257: PUSH
35258: LD_INT 2
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 3
35267: PUSH
35268: LD_INT 3
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 2
35277: PUSH
35278: LD_INT 3
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: EMPTY
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35303: LD_ADDR_VAR 0 17
35307: PUSH
35308: LD_INT 0
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 0
35320: PUSH
35321: LD_INT 1
35323: NEG
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: LD_INT 0
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 1
35341: PUSH
35342: LD_INT 1
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 1
35361: NEG
35362: PUSH
35363: LD_INT 0
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: LD_INT 1
35376: NEG
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: NEG
35385: PUSH
35386: LD_INT 2
35388: NEG
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: LD_INT 2
35399: NEG
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 1
35407: PUSH
35408: LD_INT 1
35410: NEG
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 2
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 2
35428: PUSH
35429: LD_INT 1
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 2
35438: PUSH
35439: LD_INT 2
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 1
35448: PUSH
35449: LD_INT 2
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: LD_INT 2
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 1
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 2
35479: NEG
35480: PUSH
35481: LD_INT 0
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 2
35490: NEG
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 2
35502: NEG
35503: PUSH
35504: LD_INT 2
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: LIST
35516: LIST
35517: LIST
35518: LIST
35519: LIST
35520: LIST
35521: LIST
35522: LIST
35523: LIST
35524: LIST
35525: LIST
35526: LIST
35527: LIST
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35533: LD_ADDR_VAR 0 18
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: LD_INT 0
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 0
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: LD_INT 0
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 1
35571: PUSH
35572: LD_INT 1
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 0
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 1
35591: NEG
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: LD_INT 1
35606: NEG
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 1
35614: NEG
35615: PUSH
35616: LD_INT 2
35618: NEG
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: LD_INT 2
35629: NEG
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: LD_INT 1
35637: PUSH
35638: LD_INT 1
35640: NEG
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 2
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 2
35658: PUSH
35659: LD_INT 1
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 2
35668: PUSH
35669: LD_INT 2
35671: PUSH
35672: EMPTY
35673: LIST
35674: LIST
35675: PUSH
35676: LD_INT 1
35678: PUSH
35679: LD_INT 2
35681: PUSH
35682: EMPTY
35683: LIST
35684: LIST
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: LD_INT 2
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PUSH
35696: LD_INT 1
35698: NEG
35699: PUSH
35700: LD_INT 1
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 2
35709: NEG
35710: PUSH
35711: LD_INT 0
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 2
35720: NEG
35721: PUSH
35722: LD_INT 1
35724: NEG
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 2
35732: NEG
35733: PUSH
35734: LD_INT 2
35736: NEG
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: LIST
35746: LIST
35747: LIST
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35763: LD_ADDR_VAR 0 19
35767: PUSH
35768: LD_INT 0
35770: PUSH
35771: LD_INT 0
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: LD_INT 1
35783: NEG
35784: PUSH
35785: EMPTY
35786: LIST
35787: LIST
35788: PUSH
35789: LD_INT 1
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 1
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: LD_INT 1
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 1
35821: NEG
35822: PUSH
35823: LD_INT 0
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 1
35832: NEG
35833: PUSH
35834: LD_INT 1
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 1
35844: NEG
35845: PUSH
35846: LD_INT 2
35848: NEG
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: LD_INT 2
35859: NEG
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 1
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 2
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 2
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 2
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 1
35908: PUSH
35909: LD_INT 2
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 1
35928: NEG
35929: PUSH
35930: LD_INT 1
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: NEG
35940: PUSH
35941: LD_INT 0
35943: PUSH
35944: EMPTY
35945: LIST
35946: LIST
35947: PUSH
35948: LD_INT 2
35950: NEG
35951: PUSH
35952: LD_INT 1
35954: NEG
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: LD_INT 2
35962: NEG
35963: PUSH
35964: LD_INT 2
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35993: LD_ADDR_VAR 0 20
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: LD_INT 1
36013: NEG
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 1
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 1
36031: PUSH
36032: LD_INT 1
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: LD_INT 0
36041: PUSH
36042: LD_INT 1
36044: PUSH
36045: EMPTY
36046: LIST
36047: LIST
36048: PUSH
36049: LD_INT 1
36051: NEG
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 1
36062: NEG
36063: PUSH
36064: LD_INT 1
36066: NEG
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 1
36074: NEG
36075: PUSH
36076: LD_INT 2
36078: NEG
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 0
36086: PUSH
36087: LD_INT 2
36089: NEG
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 1
36097: PUSH
36098: LD_INT 1
36100: NEG
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 2
36108: PUSH
36109: LD_INT 0
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 2
36118: PUSH
36119: LD_INT 1
36121: PUSH
36122: EMPTY
36123: LIST
36124: LIST
36125: PUSH
36126: LD_INT 2
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 1
36138: PUSH
36139: LD_INT 2
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: LD_INT 2
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 2
36169: NEG
36170: PUSH
36171: LD_INT 0
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 2
36180: NEG
36181: PUSH
36182: LD_INT 1
36184: NEG
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 2
36192: NEG
36193: PUSH
36194: LD_INT 2
36196: NEG
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: LIST
36206: LIST
36207: LIST
36208: LIST
36209: LIST
36210: LIST
36211: LIST
36212: LIST
36213: LIST
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36223: LD_ADDR_VAR 0 21
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: LD_INT 1
36243: NEG
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 1
36251: PUSH
36252: LD_INT 0
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: LD_INT 1
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 0
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: LD_INT 0
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 1
36292: NEG
36293: PUSH
36294: LD_INT 1
36296: NEG
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: LD_INT 1
36304: NEG
36305: PUSH
36306: LD_INT 2
36308: NEG
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 0
36316: PUSH
36317: LD_INT 2
36319: NEG
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 1
36327: PUSH
36328: LD_INT 1
36330: NEG
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 2
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: EMPTY
36343: LIST
36344: LIST
36345: PUSH
36346: LD_INT 2
36348: PUSH
36349: LD_INT 1
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 2
36358: PUSH
36359: LD_INT 2
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 1
36368: PUSH
36369: LD_INT 2
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: LD_INT 2
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PUSH
36386: LD_INT 1
36388: NEG
36389: PUSH
36390: LD_INT 1
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 2
36399: NEG
36400: PUSH
36401: LD_INT 0
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 2
36410: NEG
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 2
36422: NEG
36423: PUSH
36424: LD_INT 2
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: LIST
36452: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36453: LD_ADDR_VAR 0 22
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: LD_INT 1
36473: NEG
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: LD_INT 1
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 1
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: LD_INT 0
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 1
36522: NEG
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: LD_INT 2
36538: NEG
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 2
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: LD_INT 1
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 2
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 2
36578: PUSH
36579: LD_INT 1
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 2
36588: PUSH
36589: LD_INT 2
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: LD_INT 2
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 0
36608: PUSH
36609: LD_INT 2
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 1
36618: NEG
36619: PUSH
36620: LD_INT 1
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: LD_INT 2
36629: NEG
36630: PUSH
36631: LD_INT 0
36633: PUSH
36634: EMPTY
36635: LIST
36636: LIST
36637: PUSH
36638: LD_INT 2
36640: NEG
36641: PUSH
36642: LD_INT 1
36644: NEG
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 2
36652: NEG
36653: PUSH
36654: LD_INT 2
36656: NEG
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36683: LD_ADDR_VAR 0 23
36687: PUSH
36688: LD_INT 0
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 1
36711: PUSH
36712: LD_INT 0
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 1
36721: PUSH
36722: LD_INT 1
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: LD_INT 0
36731: PUSH
36732: LD_INT 1
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 1
36741: NEG
36742: PUSH
36743: LD_INT 0
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: LD_INT 1
36752: NEG
36753: PUSH
36754: LD_INT 1
36756: NEG
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: LD_INT 2
36768: NEG
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 0
36776: PUSH
36777: LD_INT 2
36779: NEG
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 1
36787: PUSH
36788: LD_INT 1
36790: NEG
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 2
36798: PUSH
36799: LD_INT 0
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: PUSH
36809: LD_INT 1
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 2
36818: PUSH
36819: LD_INT 2
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 1
36828: PUSH
36829: LD_INT 2
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 0
36838: PUSH
36839: LD_INT 2
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 1
36848: NEG
36849: PUSH
36850: LD_INT 1
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 2
36859: NEG
36860: PUSH
36861: LD_INT 0
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 2
36870: NEG
36871: PUSH
36872: LD_INT 1
36874: NEG
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 2
36882: NEG
36883: PUSH
36884: LD_INT 2
36886: NEG
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 2
36894: NEG
36895: PUSH
36896: LD_INT 3
36898: NEG
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 1
36906: NEG
36907: PUSH
36908: LD_INT 3
36910: NEG
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 1
36918: PUSH
36919: LD_INT 2
36921: NEG
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: LD_INT 1
36932: NEG
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: LIST
36948: LIST
36949: LIST
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36963: LD_ADDR_VAR 0 24
36967: PUSH
36968: LD_INT 0
36970: PUSH
36971: LD_INT 0
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 0
36980: PUSH
36981: LD_INT 1
36983: NEG
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PUSH
36989: LD_INT 1
36991: PUSH
36992: LD_INT 0
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: LD_INT 1
37001: PUSH
37002: LD_INT 1
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: PUSH
37009: LD_INT 0
37011: PUSH
37012: LD_INT 1
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PUSH
37019: LD_INT 1
37021: NEG
37022: PUSH
37023: LD_INT 0
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 1
37032: NEG
37033: PUSH
37034: LD_INT 1
37036: NEG
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: LD_INT 2
37048: NEG
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 0
37056: PUSH
37057: LD_INT 2
37059: NEG
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: PUSH
37065: LD_INT 1
37067: PUSH
37068: LD_INT 1
37070: NEG
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: PUSH
37076: LD_INT 2
37078: PUSH
37079: LD_INT 0
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 2
37088: PUSH
37089: LD_INT 1
37091: PUSH
37092: EMPTY
37093: LIST
37094: LIST
37095: PUSH
37096: LD_INT 2
37098: PUSH
37099: LD_INT 2
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_INT 1
37108: PUSH
37109: LD_INT 2
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: LD_INT 0
37118: PUSH
37119: LD_INT 2
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 1
37128: NEG
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 2
37139: NEG
37140: PUSH
37141: LD_INT 0
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: PUSH
37148: LD_INT 2
37150: NEG
37151: PUSH
37152: LD_INT 1
37154: NEG
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 2
37162: NEG
37163: PUSH
37164: LD_INT 2
37166: NEG
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 1
37174: PUSH
37175: LD_INT 2
37177: NEG
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 2
37185: PUSH
37186: LD_INT 1
37188: NEG
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 3
37196: PUSH
37197: LD_INT 1
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 3
37206: PUSH
37207: LD_INT 2
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: LIST
37218: LIST
37219: LIST
37220: LIST
37221: LIST
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37239: LD_ADDR_VAR 0 25
37243: PUSH
37244: LD_INT 0
37246: PUSH
37247: LD_INT 0
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: LD_INT 1
37259: NEG
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 1
37267: PUSH
37268: LD_INT 0
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: LD_INT 1
37277: PUSH
37278: LD_INT 1
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 0
37287: PUSH
37288: LD_INT 1
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 1
37297: NEG
37298: PUSH
37299: LD_INT 0
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 1
37308: NEG
37309: PUSH
37310: LD_INT 1
37312: NEG
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 1
37320: NEG
37321: PUSH
37322: LD_INT 2
37324: NEG
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 0
37332: PUSH
37333: LD_INT 2
37335: NEG
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 1
37343: PUSH
37344: LD_INT 1
37346: NEG
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 2
37354: PUSH
37355: LD_INT 0
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: PUSH
37362: LD_INT 2
37364: PUSH
37365: LD_INT 1
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 2
37374: PUSH
37375: LD_INT 2
37377: PUSH
37378: EMPTY
37379: LIST
37380: LIST
37381: PUSH
37382: LD_INT 1
37384: PUSH
37385: LD_INT 2
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: PUSH
37392: LD_INT 0
37394: PUSH
37395: LD_INT 2
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 1
37404: NEG
37405: PUSH
37406: LD_INT 1
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: PUSH
37413: LD_INT 2
37415: NEG
37416: PUSH
37417: LD_INT 0
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: LD_INT 2
37426: NEG
37427: PUSH
37428: LD_INT 1
37430: NEG
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 2
37438: NEG
37439: PUSH
37440: LD_INT 2
37442: NEG
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: LD_INT 3
37450: PUSH
37451: LD_INT 1
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: PUSH
37458: LD_INT 3
37460: PUSH
37461: LD_INT 2
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 2
37470: PUSH
37471: LD_INT 3
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: LD_INT 3
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: LIST
37492: LIST
37493: LIST
37494: LIST
37495: LIST
37496: LIST
37497: LIST
37498: LIST
37499: LIST
37500: LIST
37501: LIST
37502: LIST
37503: LIST
37504: LIST
37505: LIST
37506: LIST
37507: LIST
37508: LIST
37509: LIST
37510: LIST
37511: LIST
37512: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37513: LD_ADDR_VAR 0 26
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 0
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 0
37530: PUSH
37531: LD_INT 1
37533: NEG
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 1
37541: PUSH
37542: LD_INT 0
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: PUSH
37549: LD_INT 1
37551: PUSH
37552: LD_INT 1
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 0
37561: PUSH
37562: LD_INT 1
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: PUSH
37569: LD_INT 1
37571: NEG
37572: PUSH
37573: LD_INT 0
37575: PUSH
37576: EMPTY
37577: LIST
37578: LIST
37579: PUSH
37580: LD_INT 1
37582: NEG
37583: PUSH
37584: LD_INT 1
37586: NEG
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 1
37594: NEG
37595: PUSH
37596: LD_INT 2
37598: NEG
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PUSH
37604: LD_INT 0
37606: PUSH
37607: LD_INT 2
37609: NEG
37610: PUSH
37611: EMPTY
37612: LIST
37613: LIST
37614: PUSH
37615: LD_INT 1
37617: PUSH
37618: LD_INT 1
37620: NEG
37621: PUSH
37622: EMPTY
37623: LIST
37624: LIST
37625: PUSH
37626: LD_INT 2
37628: PUSH
37629: LD_INT 0
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 2
37638: PUSH
37639: LD_INT 1
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PUSH
37646: LD_INT 2
37648: PUSH
37649: LD_INT 2
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: PUSH
37656: LD_INT 1
37658: PUSH
37659: LD_INT 2
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: LD_INT 2
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: LD_INT 1
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 2
37689: NEG
37690: PUSH
37691: LD_INT 0
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 2
37700: NEG
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 2
37712: NEG
37713: PUSH
37714: LD_INT 2
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 2
37724: PUSH
37725: LD_INT 3
37727: PUSH
37728: EMPTY
37729: LIST
37730: LIST
37731: PUSH
37732: LD_INT 1
37734: PUSH
37735: LD_INT 3
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 1
37744: NEG
37745: PUSH
37746: LD_INT 2
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 2
37755: NEG
37756: PUSH
37757: LD_INT 1
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: LIST
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: LIST
37775: LIST
37776: LIST
37777: LIST
37778: LIST
37779: LIST
37780: LIST
37781: LIST
37782: LIST
37783: LIST
37784: LIST
37785: LIST
37786: LIST
37787: LIST
37788: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37789: LD_ADDR_VAR 0 27
37793: PUSH
37794: LD_INT 0
37796: PUSH
37797: LD_INT 0
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: LD_INT 1
37809: NEG
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: PUSH
37815: LD_INT 1
37817: PUSH
37818: LD_INT 0
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 1
37827: PUSH
37828: LD_INT 1
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 0
37837: PUSH
37838: LD_INT 1
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 1
37847: NEG
37848: PUSH
37849: LD_INT 0
37851: PUSH
37852: EMPTY
37853: LIST
37854: LIST
37855: PUSH
37856: LD_INT 1
37858: NEG
37859: PUSH
37860: LD_INT 1
37862: NEG
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: LD_INT 1
37870: NEG
37871: PUSH
37872: LD_INT 2
37874: NEG
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 0
37882: PUSH
37883: LD_INT 2
37885: NEG
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: LD_INT 1
37893: PUSH
37894: LD_INT 1
37896: NEG
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: PUSH
37902: LD_INT 2
37904: PUSH
37905: LD_INT 0
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 2
37914: PUSH
37915: LD_INT 1
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 2
37924: PUSH
37925: LD_INT 2
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: LD_INT 2
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 0
37944: PUSH
37945: LD_INT 2
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: NEG
37955: PUSH
37956: LD_INT 1
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 2
37965: NEG
37966: PUSH
37967: LD_INT 0
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 2
37976: NEG
37977: PUSH
37978: LD_INT 1
37980: NEG
37981: PUSH
37982: EMPTY
37983: LIST
37984: LIST
37985: PUSH
37986: LD_INT 2
37988: NEG
37989: PUSH
37990: LD_INT 2
37992: NEG
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: PUSH
37998: LD_INT 1
38000: NEG
38001: PUSH
38002: LD_INT 2
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PUSH
38009: LD_INT 2
38011: NEG
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 3
38022: NEG
38023: PUSH
38024: LD_INT 1
38026: NEG
38027: PUSH
38028: EMPTY
38029: LIST
38030: LIST
38031: PUSH
38032: LD_INT 3
38034: NEG
38035: PUSH
38036: LD_INT 2
38038: NEG
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: EMPTY
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38069: LD_ADDR_VAR 0 28
38073: PUSH
38074: LD_INT 0
38076: PUSH
38077: LD_INT 0
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: LD_INT 1
38089: NEG
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: LD_INT 0
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: PUSH
38108: LD_INT 1
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: LD_INT 1
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 1
38127: NEG
38128: PUSH
38129: LD_INT 0
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: NEG
38139: PUSH
38140: LD_INT 1
38142: NEG
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 1
38150: NEG
38151: PUSH
38152: LD_INT 2
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 0
38162: PUSH
38163: LD_INT 2
38165: NEG
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: LD_INT 1
38176: NEG
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 2
38184: PUSH
38185: LD_INT 0
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 2
38194: PUSH
38195: LD_INT 1
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 2
38204: PUSH
38205: LD_INT 2
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 1
38214: PUSH
38215: LD_INT 2
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 0
38224: PUSH
38225: LD_INT 2
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 1
38234: NEG
38235: PUSH
38236: LD_INT 1
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 2
38245: NEG
38246: PUSH
38247: LD_INT 0
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 2
38256: NEG
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 2
38268: NEG
38269: PUSH
38270: LD_INT 2
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 2
38280: NEG
38281: PUSH
38282: LD_INT 3
38284: NEG
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 1
38292: NEG
38293: PUSH
38294: LD_INT 3
38296: NEG
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: PUSH
38302: LD_INT 3
38304: NEG
38305: PUSH
38306: LD_INT 1
38308: NEG
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 3
38316: NEG
38317: PUSH
38318: LD_INT 2
38320: NEG
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: LIST
38345: LIST
38346: LIST
38347: LIST
38348: LIST
38349: LIST
38350: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38351: LD_ADDR_VAR 0 29
38355: PUSH
38356: LD_INT 0
38358: PUSH
38359: LD_INT 0
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 0
38368: PUSH
38369: LD_INT 1
38371: NEG
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 1
38379: PUSH
38380: LD_INT 0
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 1
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 0
38399: PUSH
38400: LD_INT 1
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 1
38409: NEG
38410: PUSH
38411: LD_INT 0
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 1
38420: NEG
38421: PUSH
38422: LD_INT 1
38424: NEG
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: NEG
38433: PUSH
38434: LD_INT 2
38436: NEG
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 0
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 1
38455: PUSH
38456: LD_INT 1
38458: NEG
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: LD_INT 2
38466: PUSH
38467: LD_INT 0
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 2
38476: PUSH
38477: LD_INT 1
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 1
38486: PUSH
38487: LD_INT 2
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 0
38496: PUSH
38497: LD_INT 2
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 1
38506: NEG
38507: PUSH
38508: LD_INT 1
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 2
38517: NEG
38518: PUSH
38519: LD_INT 1
38521: NEG
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: LD_INT 2
38529: NEG
38530: PUSH
38531: LD_INT 2
38533: NEG
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 2
38541: NEG
38542: PUSH
38543: LD_INT 3
38545: NEG
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 2
38553: PUSH
38554: LD_INT 1
38556: NEG
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 3
38564: PUSH
38565: LD_INT 1
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 1
38574: PUSH
38575: LD_INT 3
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 2
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 3
38595: NEG
38596: PUSH
38597: LD_INT 2
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38630: LD_ADDR_VAR 0 30
38634: PUSH
38635: LD_INT 0
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 0
38647: PUSH
38648: LD_INT 1
38650: NEG
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 1
38658: PUSH
38659: LD_INT 0
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 1
38668: PUSH
38669: LD_INT 1
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 0
38678: PUSH
38679: LD_INT 1
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 1
38688: NEG
38689: PUSH
38690: LD_INT 0
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 1
38699: NEG
38700: PUSH
38701: LD_INT 1
38703: NEG
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: LD_INT 2
38715: NEG
38716: PUSH
38717: EMPTY
38718: LIST
38719: LIST
38720: PUSH
38721: LD_INT 0
38723: PUSH
38724: LD_INT 2
38726: NEG
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PUSH
38732: LD_INT 1
38734: PUSH
38735: LD_INT 1
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 2
38745: PUSH
38746: LD_INT 0
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: PUSH
38753: LD_INT 2
38755: PUSH
38756: LD_INT 1
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 2
38765: PUSH
38766: LD_INT 2
38768: PUSH
38769: EMPTY
38770: LIST
38771: LIST
38772: PUSH
38773: LD_INT 1
38775: PUSH
38776: LD_INT 2
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 1
38785: NEG
38786: PUSH
38787: LD_INT 1
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 2
38796: NEG
38797: PUSH
38798: LD_INT 0
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 2
38807: NEG
38808: PUSH
38809: LD_INT 1
38811: NEG
38812: PUSH
38813: EMPTY
38814: LIST
38815: LIST
38816: PUSH
38817: LD_INT 1
38819: NEG
38820: PUSH
38821: LD_INT 3
38823: NEG
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 1
38831: PUSH
38832: LD_INT 2
38834: NEG
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: LD_INT 3
38842: PUSH
38843: LD_INT 2
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 2
38852: PUSH
38853: LD_INT 3
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 2
38862: NEG
38863: PUSH
38864: LD_INT 1
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: LD_INT 3
38873: NEG
38874: PUSH
38875: LD_INT 1
38877: NEG
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: LIST
38907: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38908: LD_ADDR_VAR 0 31
38912: PUSH
38913: LD_INT 0
38915: PUSH
38916: LD_INT 0
38918: PUSH
38919: EMPTY
38920: LIST
38921: LIST
38922: PUSH
38923: LD_INT 0
38925: PUSH
38926: LD_INT 1
38928: NEG
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: PUSH
38937: LD_INT 0
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 1
38946: PUSH
38947: LD_INT 1
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: LD_INT 0
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PUSH
38964: LD_INT 1
38966: NEG
38967: PUSH
38968: LD_INT 0
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: PUSH
38975: LD_INT 1
38977: NEG
38978: PUSH
38979: LD_INT 1
38981: NEG
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 1
38989: NEG
38990: PUSH
38991: LD_INT 2
38993: NEG
38994: PUSH
38995: EMPTY
38996: LIST
38997: LIST
38998: PUSH
38999: LD_INT 1
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 2
39012: PUSH
39013: LD_INT 0
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 2
39022: PUSH
39023: LD_INT 1
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 2
39032: PUSH
39033: LD_INT 2
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 1
39042: PUSH
39043: LD_INT 2
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 0
39052: PUSH
39053: LD_INT 2
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 1
39062: NEG
39063: PUSH
39064: LD_INT 1
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 2
39073: NEG
39074: PUSH
39075: LD_INT 1
39077: NEG
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 2
39085: NEG
39086: PUSH
39087: LD_INT 2
39089: NEG
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 2
39097: NEG
39098: PUSH
39099: LD_INT 3
39101: NEG
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: PUSH
39107: LD_INT 2
39109: PUSH
39110: LD_INT 1
39112: NEG
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 3
39120: PUSH
39121: LD_INT 1
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 1
39130: PUSH
39131: LD_INT 3
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: PUSH
39138: LD_INT 1
39140: NEG
39141: PUSH
39142: LD_INT 2
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 3
39151: NEG
39152: PUSH
39153: LD_INT 2
39155: NEG
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: LIST
39165: LIST
39166: LIST
39167: LIST
39168: LIST
39169: LIST
39170: LIST
39171: LIST
39172: LIST
39173: LIST
39174: LIST
39175: LIST
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39186: LD_ADDR_VAR 0 32
39190: PUSH
39191: LD_INT 0
39193: PUSH
39194: LD_INT 0
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 0
39203: PUSH
39204: LD_INT 1
39206: NEG
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 1
39214: PUSH
39215: LD_INT 0
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: LD_INT 1
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 0
39234: PUSH
39235: LD_INT 1
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 1
39244: NEG
39245: PUSH
39246: LD_INT 0
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 1
39255: NEG
39256: PUSH
39257: LD_INT 1
39259: NEG
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 1
39267: NEG
39268: PUSH
39269: LD_INT 2
39271: NEG
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 0
39279: PUSH
39280: LD_INT 2
39282: NEG
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 1
39290: PUSH
39291: LD_INT 1
39293: NEG
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 2
39301: PUSH
39302: LD_INT 1
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PUSH
39309: LD_INT 2
39311: PUSH
39312: LD_INT 2
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 1
39321: PUSH
39322: LD_INT 2
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 0
39331: PUSH
39332: LD_INT 2
39334: PUSH
39335: EMPTY
39336: LIST
39337: LIST
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: LD_INT 1
39345: PUSH
39346: EMPTY
39347: LIST
39348: LIST
39349: PUSH
39350: LD_INT 2
39352: NEG
39353: PUSH
39354: LD_INT 0
39356: PUSH
39357: EMPTY
39358: LIST
39359: LIST
39360: PUSH
39361: LD_INT 2
39363: NEG
39364: PUSH
39365: LD_INT 1
39367: NEG
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 1
39375: NEG
39376: PUSH
39377: LD_INT 3
39379: NEG
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 1
39387: PUSH
39388: LD_INT 2
39390: NEG
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: LD_INT 3
39398: PUSH
39399: LD_INT 2
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 2
39408: PUSH
39409: LD_INT 3
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: LD_INT 2
39418: NEG
39419: PUSH
39420: LD_INT 1
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 3
39429: NEG
39430: PUSH
39431: LD_INT 1
39433: NEG
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: LIST
39443: LIST
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: LIST
39459: LIST
39460: LIST
39461: LIST
39462: LIST
39463: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39464: LD_ADDR_VAR 0 33
39468: PUSH
39469: LD_INT 0
39471: PUSH
39472: LD_INT 0
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: LD_INT 1
39484: NEG
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 1
39492: PUSH
39493: LD_INT 0
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 1
39502: PUSH
39503: LD_INT 1
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 1
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 1
39522: NEG
39523: PUSH
39524: LD_INT 0
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: NEG
39534: PUSH
39535: LD_INT 1
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 1
39545: NEG
39546: PUSH
39547: LD_INT 2
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 1
39557: PUSH
39558: LD_INT 1
39560: NEG
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 2
39568: PUSH
39569: LD_INT 0
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 2
39578: PUSH
39579: LD_INT 1
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 1
39588: PUSH
39589: LD_INT 2
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 0
39598: PUSH
39599: LD_INT 2
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 1
39608: NEG
39609: PUSH
39610: LD_INT 1
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 2
39619: NEG
39620: PUSH
39621: LD_INT 0
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PUSH
39628: LD_INT 2
39630: NEG
39631: PUSH
39632: LD_INT 1
39634: NEG
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: LD_INT 2
39642: NEG
39643: PUSH
39644: LD_INT 2
39646: NEG
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 2
39654: NEG
39655: PUSH
39656: LD_INT 3
39658: NEG
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 2
39666: PUSH
39667: LD_INT 1
39669: NEG
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 3
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 1
39687: PUSH
39688: LD_INT 3
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: NEG
39698: PUSH
39699: LD_INT 2
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 3
39708: NEG
39709: PUSH
39710: LD_INT 2
39712: NEG
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: LIST
39729: LIST
39730: LIST
39731: LIST
39732: LIST
39733: LIST
39734: LIST
39735: LIST
39736: LIST
39737: LIST
39738: LIST
39739: LIST
39740: LIST
39741: LIST
39742: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39743: LD_ADDR_VAR 0 34
39747: PUSH
39748: LD_INT 0
39750: PUSH
39751: LD_INT 0
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 1
39771: PUSH
39772: LD_INT 0
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 1
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 0
39791: PUSH
39792: LD_INT 1
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: LD_INT 1
39801: NEG
39802: PUSH
39803: LD_INT 0
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: LD_INT 1
39812: NEG
39813: PUSH
39814: LD_INT 1
39816: NEG
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 1
39824: NEG
39825: PUSH
39826: LD_INT 2
39828: NEG
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PUSH
39834: LD_INT 0
39836: PUSH
39837: LD_INT 2
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 1
39847: PUSH
39848: LD_INT 1
39850: NEG
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PUSH
39856: LD_INT 2
39858: PUSH
39859: LD_INT 1
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 2
39868: PUSH
39869: LD_INT 2
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 1
39878: PUSH
39879: LD_INT 2
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 2
39899: NEG
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 2
39910: NEG
39911: PUSH
39912: LD_INT 1
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 2
39922: NEG
39923: PUSH
39924: LD_INT 2
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 1
39934: NEG
39935: PUSH
39936: LD_INT 3
39938: NEG
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 1
39946: PUSH
39947: LD_INT 2
39949: NEG
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 3
39957: PUSH
39958: LD_INT 2
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 2
39967: PUSH
39968: LD_INT 3
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 2
39977: NEG
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 3
39988: NEG
39989: PUSH
39990: LD_INT 1
39992: NEG
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: LIST
40011: LIST
40012: LIST
40013: LIST
40014: LIST
40015: LIST
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40023: LD_ADDR_VAR 0 35
40027: PUSH
40028: LD_INT 0
40030: PUSH
40031: LD_INT 0
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 0
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 1
40061: PUSH
40062: LD_INT 1
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 1
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 1
40081: NEG
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 1
40092: NEG
40093: PUSH
40094: LD_INT 1
40096: NEG
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 2
40104: PUSH
40105: LD_INT 1
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 2
40114: NEG
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: LIST
40128: LIST
40129: LIST
40130: LIST
40131: LIST
40132: LIST
40133: LIST
40134: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40135: LD_ADDR_VAR 0 36
40139: PUSH
40140: LD_INT 0
40142: PUSH
40143: LD_INT 0
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 0
40152: PUSH
40153: LD_INT 1
40155: NEG
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 1
40163: PUSH
40164: LD_INT 0
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 1
40173: PUSH
40174: LD_INT 1
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 0
40183: PUSH
40184: LD_INT 1
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: LD_INT 1
40193: NEG
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: PUSH
40202: LD_INT 1
40204: NEG
40205: PUSH
40206: LD_INT 1
40208: NEG
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 1
40216: NEG
40217: PUSH
40218: LD_INT 2
40220: NEG
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 1
40228: PUSH
40229: LD_INT 2
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: LIST
40240: LIST
40241: LIST
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40247: LD_ADDR_VAR 0 37
40251: PUSH
40252: LD_INT 0
40254: PUSH
40255: LD_INT 0
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PUSH
40262: LD_INT 0
40264: PUSH
40265: LD_INT 1
40267: NEG
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: LD_INT 1
40275: PUSH
40276: LD_INT 0
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: PUSH
40283: LD_INT 1
40285: PUSH
40286: LD_INT 1
40288: PUSH
40289: EMPTY
40290: LIST
40291: LIST
40292: PUSH
40293: LD_INT 0
40295: PUSH
40296: LD_INT 1
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: PUSH
40303: LD_INT 1
40305: NEG
40306: PUSH
40307: LD_INT 0
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: PUSH
40314: LD_INT 1
40316: NEG
40317: PUSH
40318: LD_INT 1
40320: NEG
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 1
40328: PUSH
40329: LD_INT 1
40331: NEG
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 1
40339: NEG
40340: PUSH
40341: LD_INT 1
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: LIST
40352: LIST
40353: LIST
40354: LIST
40355: LIST
40356: LIST
40357: LIST
40358: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40359: LD_ADDR_VAR 0 38
40363: PUSH
40364: LD_INT 0
40366: PUSH
40367: LD_INT 0
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 0
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 1
40387: PUSH
40388: LD_INT 0
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 1
40397: PUSH
40398: LD_INT 1
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 0
40407: PUSH
40408: LD_INT 1
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 1
40417: NEG
40418: PUSH
40419: LD_INT 0
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PUSH
40426: LD_INT 1
40428: NEG
40429: PUSH
40430: LD_INT 1
40432: NEG
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PUSH
40438: LD_INT 2
40440: PUSH
40441: LD_INT 1
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 2
40450: NEG
40451: PUSH
40452: LD_INT 1
40454: NEG
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40471: LD_ADDR_VAR 0 39
40475: PUSH
40476: LD_INT 0
40478: PUSH
40479: LD_INT 0
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PUSH
40486: LD_INT 0
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 1
40499: PUSH
40500: LD_INT 0
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: LD_INT 1
40509: PUSH
40510: LD_INT 1
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 0
40519: PUSH
40520: LD_INT 1
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 1
40529: NEG
40530: PUSH
40531: LD_INT 0
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 1
40540: NEG
40541: PUSH
40542: LD_INT 1
40544: NEG
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 1
40552: NEG
40553: PUSH
40554: LD_INT 2
40556: NEG
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: PUSH
40562: LD_INT 1
40564: PUSH
40565: LD_INT 2
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: LIST
40582: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40583: LD_ADDR_VAR 0 40
40587: PUSH
40588: LD_INT 0
40590: PUSH
40591: LD_INT 0
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: PUSH
40598: LD_INT 0
40600: PUSH
40601: LD_INT 1
40603: NEG
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: LD_INT 0
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 1
40621: PUSH
40622: LD_INT 1
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 0
40631: PUSH
40632: LD_INT 1
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 1
40641: NEG
40642: PUSH
40643: LD_INT 0
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 1
40652: NEG
40653: PUSH
40654: LD_INT 1
40656: NEG
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 1
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 1
40675: NEG
40676: PUSH
40677: LD_INT 1
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: EMPTY
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40695: LD_ADDR_VAR 0 41
40699: PUSH
40700: LD_INT 0
40702: PUSH
40703: LD_INT 0
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: LD_INT 1
40715: NEG
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 1
40723: PUSH
40724: LD_INT 0
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 1
40733: PUSH
40734: LD_INT 1
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 0
40743: PUSH
40744: LD_INT 1
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 1
40753: NEG
40754: PUSH
40755: LD_INT 0
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 1
40764: NEG
40765: PUSH
40766: LD_INT 1
40768: NEG
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 1
40776: NEG
40777: PUSH
40778: LD_INT 2
40780: NEG
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 1
40788: PUSH
40789: LD_INT 1
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 2
40799: PUSH
40800: LD_INT 0
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 2
40809: PUSH
40810: LD_INT 1
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 2
40819: PUSH
40820: LD_INT 2
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 1
40829: PUSH
40830: LD_INT 2
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 1
40839: NEG
40840: PUSH
40841: LD_INT 1
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 2
40850: NEG
40851: PUSH
40852: LD_INT 0
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: LD_INT 2
40861: NEG
40862: PUSH
40863: LD_INT 1
40865: NEG
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: PUSH
40871: LD_INT 2
40873: NEG
40874: PUSH
40875: LD_INT 2
40877: NEG
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: PUSH
40883: LD_INT 2
40885: NEG
40886: PUSH
40887: LD_INT 3
40889: NEG
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 2
40897: PUSH
40898: LD_INT 1
40900: NEG
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 3
40908: PUSH
40909: LD_INT 0
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 3
40918: PUSH
40919: LD_INT 1
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 3
40928: PUSH
40929: LD_INT 2
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 3
40938: PUSH
40939: LD_INT 3
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 2
40948: PUSH
40949: LD_INT 3
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: PUSH
40956: LD_INT 2
40958: NEG
40959: PUSH
40960: LD_INT 1
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 3
40969: NEG
40970: PUSH
40971: LD_INT 0
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 3
40980: NEG
40981: PUSH
40982: LD_INT 1
40984: NEG
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: LD_INT 3
40992: NEG
40993: PUSH
40994: LD_INT 2
40996: NEG
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 3
41004: NEG
41005: PUSH
41006: LD_INT 3
41008: NEG
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: LIST
41033: LIST
41034: LIST
41035: LIST
41036: LIST
41037: LIST
41038: LIST
41039: LIST
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41045: LD_ADDR_VAR 0 42
41049: PUSH
41050: LD_INT 0
41052: PUSH
41053: LD_INT 0
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 0
41062: PUSH
41063: LD_INT 1
41065: NEG
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 1
41073: PUSH
41074: LD_INT 0
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 1
41083: PUSH
41084: LD_INT 1
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 0
41093: PUSH
41094: LD_INT 1
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: LD_INT 1
41103: NEG
41104: PUSH
41105: LD_INT 0
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PUSH
41112: LD_INT 1
41114: NEG
41115: PUSH
41116: LD_INT 1
41118: NEG
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PUSH
41124: LD_INT 1
41126: NEG
41127: PUSH
41128: LD_INT 2
41130: NEG
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 0
41138: PUSH
41139: LD_INT 2
41141: NEG
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: LD_INT 1
41149: PUSH
41150: LD_INT 1
41152: NEG
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: PUSH
41158: LD_INT 2
41160: PUSH
41161: LD_INT 1
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PUSH
41168: LD_INT 2
41170: PUSH
41171: LD_INT 2
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: PUSH
41178: LD_INT 1
41180: PUSH
41181: LD_INT 2
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 0
41190: PUSH
41191: LD_INT 2
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: LD_INT 1
41200: NEG
41201: PUSH
41202: LD_INT 1
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PUSH
41209: LD_INT 2
41211: NEG
41212: PUSH
41213: LD_INT 1
41215: NEG
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: PUSH
41221: LD_INT 2
41223: NEG
41224: PUSH
41225: LD_INT 2
41227: NEG
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 2
41235: NEG
41236: PUSH
41237: LD_INT 3
41239: NEG
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 1
41247: NEG
41248: PUSH
41249: LD_INT 3
41251: NEG
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 0
41259: PUSH
41260: LD_INT 3
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 1
41270: PUSH
41271: LD_INT 2
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 3
41281: PUSH
41282: LD_INT 2
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 3
41291: PUSH
41292: LD_INT 3
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 2
41301: PUSH
41302: LD_INT 3
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 1
41311: PUSH
41312: LD_INT 3
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 0
41321: PUSH
41322: LD_INT 3
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: PUSH
41329: LD_INT 1
41331: NEG
41332: PUSH
41333: LD_INT 2
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 3
41342: NEG
41343: PUSH
41344: LD_INT 2
41346: NEG
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: LD_INT 3
41354: NEG
41355: PUSH
41356: LD_INT 3
41358: NEG
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: LIST
41368: LIST
41369: LIST
41370: LIST
41371: LIST
41372: LIST
41373: LIST
41374: LIST
41375: LIST
41376: LIST
41377: LIST
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: LIST
41385: LIST
41386: LIST
41387: LIST
41388: LIST
41389: LIST
41390: LIST
41391: LIST
41392: LIST
41393: LIST
41394: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41395: LD_ADDR_VAR 0 43
41399: PUSH
41400: LD_INT 0
41402: PUSH
41403: LD_INT 0
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 0
41412: PUSH
41413: LD_INT 1
41415: NEG
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: PUSH
41421: LD_INT 1
41423: PUSH
41424: LD_INT 0
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 1
41433: PUSH
41434: LD_INT 1
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: LD_INT 0
41443: PUSH
41444: LD_INT 1
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 1
41453: NEG
41454: PUSH
41455: LD_INT 0
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 1
41464: NEG
41465: PUSH
41466: LD_INT 1
41468: NEG
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 1
41476: NEG
41477: PUSH
41478: LD_INT 2
41480: NEG
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PUSH
41486: LD_INT 0
41488: PUSH
41489: LD_INT 2
41491: NEG
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: LD_INT 1
41499: PUSH
41500: LD_INT 1
41502: NEG
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: LD_INT 2
41510: PUSH
41511: LD_INT 0
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 2
41520: PUSH
41521: LD_INT 1
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: LD_INT 1
41530: PUSH
41531: LD_INT 2
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 0
41540: PUSH
41541: LD_INT 2
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: LD_INT 1
41550: NEG
41551: PUSH
41552: LD_INT 1
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: PUSH
41559: LD_INT 2
41561: NEG
41562: PUSH
41563: LD_INT 0
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: LD_INT 2
41572: NEG
41573: PUSH
41574: LD_INT 1
41576: NEG
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: PUSH
41582: LD_INT 1
41584: NEG
41585: PUSH
41586: LD_INT 3
41588: NEG
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: PUSH
41594: LD_INT 0
41596: PUSH
41597: LD_INT 3
41599: NEG
41600: PUSH
41601: EMPTY
41602: LIST
41603: LIST
41604: PUSH
41605: LD_INT 1
41607: PUSH
41608: LD_INT 2
41610: NEG
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 2
41618: PUSH
41619: LD_INT 1
41621: NEG
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 3
41629: PUSH
41630: LD_INT 0
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 3
41639: PUSH
41640: LD_INT 1
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: LD_INT 1
41649: PUSH
41650: LD_INT 3
41652: PUSH
41653: EMPTY
41654: LIST
41655: LIST
41656: PUSH
41657: LD_INT 0
41659: PUSH
41660: LD_INT 3
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: LD_INT 1
41669: NEG
41670: PUSH
41671: LD_INT 2
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: PUSH
41678: LD_INT 2
41680: NEG
41681: PUSH
41682: LD_INT 1
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 3
41691: NEG
41692: PUSH
41693: LD_INT 0
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: PUSH
41700: LD_INT 3
41702: NEG
41703: PUSH
41704: LD_INT 1
41706: NEG
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: LIST
41716: LIST
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: LIST
41723: LIST
41724: LIST
41725: LIST
41726: LIST
41727: LIST
41728: LIST
41729: LIST
41730: LIST
41731: LIST
41732: LIST
41733: LIST
41734: LIST
41735: LIST
41736: LIST
41737: LIST
41738: LIST
41739: LIST
41740: LIST
41741: LIST
41742: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41743: LD_ADDR_VAR 0 44
41747: PUSH
41748: LD_INT 0
41750: PUSH
41751: LD_INT 0
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 0
41760: PUSH
41761: LD_INT 1
41763: NEG
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 1
41771: PUSH
41772: LD_INT 0
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: PUSH
41779: LD_INT 1
41781: PUSH
41782: LD_INT 1
41784: PUSH
41785: EMPTY
41786: LIST
41787: LIST
41788: PUSH
41789: LD_INT 0
41791: PUSH
41792: LD_INT 1
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: PUSH
41799: LD_INT 1
41801: NEG
41802: PUSH
41803: LD_INT 0
41805: PUSH
41806: EMPTY
41807: LIST
41808: LIST
41809: PUSH
41810: LD_INT 1
41812: NEG
41813: PUSH
41814: LD_INT 1
41816: NEG
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 1
41824: NEG
41825: PUSH
41826: LD_INT 2
41828: NEG
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: LD_INT 1
41836: PUSH
41837: LD_INT 1
41839: NEG
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PUSH
41845: LD_INT 2
41847: PUSH
41848: LD_INT 0
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 2
41857: PUSH
41858: LD_INT 1
41860: PUSH
41861: EMPTY
41862: LIST
41863: LIST
41864: PUSH
41865: LD_INT 2
41867: PUSH
41868: LD_INT 2
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 1
41877: PUSH
41878: LD_INT 2
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 1
41887: NEG
41888: PUSH
41889: LD_INT 1
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 2
41898: NEG
41899: PUSH
41900: LD_INT 0
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 2
41909: NEG
41910: PUSH
41911: LD_INT 1
41913: NEG
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 2
41921: NEG
41922: PUSH
41923: LD_INT 2
41925: NEG
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: PUSH
41931: LD_INT 2
41933: NEG
41934: PUSH
41935: LD_INT 3
41937: NEG
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: LD_INT 2
41945: PUSH
41946: LD_INT 1
41948: NEG
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 3
41956: PUSH
41957: LD_INT 0
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 3
41966: PUSH
41967: LD_INT 1
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 3
41976: PUSH
41977: LD_INT 2
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: LD_INT 3
41986: PUSH
41987: LD_INT 3
41989: PUSH
41990: EMPTY
41991: LIST
41992: LIST
41993: PUSH
41994: LD_INT 2
41996: PUSH
41997: LD_INT 3
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 2
42006: NEG
42007: PUSH
42008: LD_INT 1
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: PUSH
42015: LD_INT 3
42017: NEG
42018: PUSH
42019: LD_INT 0
42021: PUSH
42022: EMPTY
42023: LIST
42024: LIST
42025: PUSH
42026: LD_INT 3
42028: NEG
42029: PUSH
42030: LD_INT 1
42032: NEG
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 3
42040: NEG
42041: PUSH
42042: LD_INT 2
42044: NEG
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 3
42052: NEG
42053: PUSH
42054: LD_INT 3
42056: NEG
42057: PUSH
42058: EMPTY
42059: LIST
42060: LIST
42061: PUSH
42062: EMPTY
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42093: LD_ADDR_VAR 0 45
42097: PUSH
42098: LD_INT 0
42100: PUSH
42101: LD_INT 0
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 0
42110: PUSH
42111: LD_INT 1
42113: NEG
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 1
42121: PUSH
42122: LD_INT 0
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 1
42131: PUSH
42132: LD_INT 1
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 0
42141: PUSH
42142: LD_INT 1
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 1
42151: NEG
42152: PUSH
42153: LD_INT 0
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: PUSH
42160: LD_INT 1
42162: NEG
42163: PUSH
42164: LD_INT 1
42166: NEG
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: PUSH
42172: LD_INT 1
42174: NEG
42175: PUSH
42176: LD_INT 2
42178: NEG
42179: PUSH
42180: EMPTY
42181: LIST
42182: LIST
42183: PUSH
42184: LD_INT 0
42186: PUSH
42187: LD_INT 2
42189: NEG
42190: PUSH
42191: EMPTY
42192: LIST
42193: LIST
42194: PUSH
42195: LD_INT 1
42197: PUSH
42198: LD_INT 1
42200: NEG
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: LD_INT 2
42208: PUSH
42209: LD_INT 1
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 2
42218: PUSH
42219: LD_INT 2
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: PUSH
42226: LD_INT 1
42228: PUSH
42229: LD_INT 2
42231: PUSH
42232: EMPTY
42233: LIST
42234: LIST
42235: PUSH
42236: LD_INT 0
42238: PUSH
42239: LD_INT 2
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: LD_INT 1
42248: NEG
42249: PUSH
42250: LD_INT 1
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: LD_INT 2
42259: NEG
42260: PUSH
42261: LD_INT 1
42263: NEG
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 2
42271: NEG
42272: PUSH
42273: LD_INT 2
42275: NEG
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: LD_INT 2
42283: NEG
42284: PUSH
42285: LD_INT 3
42287: NEG
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 1
42295: NEG
42296: PUSH
42297: LD_INT 3
42299: NEG
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 0
42307: PUSH
42308: LD_INT 3
42310: NEG
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 1
42318: PUSH
42319: LD_INT 2
42321: NEG
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: LD_INT 3
42329: PUSH
42330: LD_INT 2
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 3
42339: PUSH
42340: LD_INT 3
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 2
42349: PUSH
42350: LD_INT 3
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 1
42359: PUSH
42360: LD_INT 3
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 0
42369: PUSH
42370: LD_INT 3
42372: PUSH
42373: EMPTY
42374: LIST
42375: LIST
42376: PUSH
42377: LD_INT 1
42379: NEG
42380: PUSH
42381: LD_INT 2
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 3
42390: NEG
42391: PUSH
42392: LD_INT 2
42394: NEG
42395: PUSH
42396: EMPTY
42397: LIST
42398: LIST
42399: PUSH
42400: LD_INT 3
42402: NEG
42403: PUSH
42404: LD_INT 3
42406: NEG
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: LIST
42423: LIST
42424: LIST
42425: LIST
42426: LIST
42427: LIST
42428: LIST
42429: LIST
42430: LIST
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42443: LD_ADDR_VAR 0 46
42447: PUSH
42448: LD_INT 0
42450: PUSH
42451: LD_INT 0
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 0
42460: PUSH
42461: LD_INT 1
42463: NEG
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 1
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: LD_INT 1
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 1
42501: NEG
42502: PUSH
42503: LD_INT 0
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 1
42512: NEG
42513: PUSH
42514: LD_INT 1
42516: NEG
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 1
42524: NEG
42525: PUSH
42526: LD_INT 2
42528: NEG
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 0
42536: PUSH
42537: LD_INT 2
42539: NEG
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 1
42547: PUSH
42548: LD_INT 1
42550: NEG
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 2
42558: PUSH
42559: LD_INT 0
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 2
42568: PUSH
42569: LD_INT 1
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: LD_INT 1
42578: PUSH
42579: LD_INT 2
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 0
42588: PUSH
42589: LD_INT 2
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 1
42598: NEG
42599: PUSH
42600: LD_INT 1
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: PUSH
42607: LD_INT 2
42609: NEG
42610: PUSH
42611: LD_INT 0
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 2
42620: NEG
42621: PUSH
42622: LD_INT 1
42624: NEG
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 1
42632: NEG
42633: PUSH
42634: LD_INT 3
42636: NEG
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: LD_INT 0
42644: PUSH
42645: LD_INT 3
42647: NEG
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: LD_INT 2
42658: NEG
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 2
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 3
42677: PUSH
42678: LD_INT 0
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 3
42687: PUSH
42688: LD_INT 1
42690: PUSH
42691: EMPTY
42692: LIST
42693: LIST
42694: PUSH
42695: LD_INT 1
42697: PUSH
42698: LD_INT 3
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: PUSH
42705: LD_INT 0
42707: PUSH
42708: LD_INT 3
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PUSH
42715: LD_INT 1
42717: NEG
42718: PUSH
42719: LD_INT 2
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: PUSH
42726: LD_INT 2
42728: NEG
42729: PUSH
42730: LD_INT 1
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: PUSH
42737: LD_INT 3
42739: NEG
42740: PUSH
42741: LD_INT 0
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 3
42750: NEG
42751: PUSH
42752: LD_INT 1
42754: NEG
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: LIST
42787: LIST
42788: LIST
42789: LIST
42790: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42791: LD_ADDR_VAR 0 47
42795: PUSH
42796: LD_INT 0
42798: PUSH
42799: LD_INT 0
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PUSH
42806: LD_INT 0
42808: PUSH
42809: LD_INT 1
42811: NEG
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 1
42819: PUSH
42820: LD_INT 0
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 1
42829: PUSH
42830: LD_INT 1
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 0
42839: PUSH
42840: LD_INT 1
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: LD_INT 1
42849: NEG
42850: PUSH
42851: LD_INT 0
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: LD_INT 1
42860: NEG
42861: PUSH
42862: LD_INT 1
42864: NEG
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 1
42872: NEG
42873: PUSH
42874: LD_INT 2
42876: NEG
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: PUSH
42882: LD_INT 0
42884: PUSH
42885: LD_INT 2
42887: NEG
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: PUSH
42893: LD_INT 1
42895: PUSH
42896: LD_INT 1
42898: NEG
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: PUSH
42904: LD_INT 2
42906: NEG
42907: PUSH
42908: LD_INT 1
42910: NEG
42911: PUSH
42912: EMPTY
42913: LIST
42914: LIST
42915: PUSH
42916: LD_INT 2
42918: NEG
42919: PUSH
42920: LD_INT 2
42922: NEG
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: LIST
42932: LIST
42933: LIST
42934: LIST
42935: LIST
42936: LIST
42937: LIST
42938: LIST
42939: LIST
42940: LIST
42941: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42942: LD_ADDR_VAR 0 48
42946: PUSH
42947: LD_INT 0
42949: PUSH
42950: LD_INT 0
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: PUSH
42957: LD_INT 0
42959: PUSH
42960: LD_INT 1
42962: NEG
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 1
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: LD_INT 1
42980: PUSH
42981: LD_INT 1
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: LD_INT 0
42990: PUSH
42991: LD_INT 1
42993: PUSH
42994: EMPTY
42995: LIST
42996: LIST
42997: PUSH
42998: LD_INT 1
43000: NEG
43001: PUSH
43002: LD_INT 0
43004: PUSH
43005: EMPTY
43006: LIST
43007: LIST
43008: PUSH
43009: LD_INT 1
43011: NEG
43012: PUSH
43013: LD_INT 1
43015: NEG
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: PUSH
43021: LD_INT 1
43023: NEG
43024: PUSH
43025: LD_INT 2
43027: NEG
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 0
43035: PUSH
43036: LD_INT 2
43038: NEG
43039: PUSH
43040: EMPTY
43041: LIST
43042: LIST
43043: PUSH
43044: LD_INT 1
43046: PUSH
43047: LD_INT 1
43049: NEG
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: LD_INT 2
43057: PUSH
43058: LD_INT 0
43060: PUSH
43061: EMPTY
43062: LIST
43063: LIST
43064: PUSH
43065: LD_INT 2
43067: PUSH
43068: LD_INT 1
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: EMPTY
43076: LIST
43077: LIST
43078: LIST
43079: LIST
43080: LIST
43081: LIST
43082: LIST
43083: LIST
43084: LIST
43085: LIST
43086: LIST
43087: LIST
43088: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43089: LD_ADDR_VAR 0 49
43093: PUSH
43094: LD_INT 0
43096: PUSH
43097: LD_INT 0
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 0
43106: PUSH
43107: LD_INT 1
43109: NEG
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: PUSH
43115: LD_INT 1
43117: PUSH
43118: LD_INT 0
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: PUSH
43125: LD_INT 1
43127: PUSH
43128: LD_INT 1
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 0
43137: PUSH
43138: LD_INT 1
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 1
43147: NEG
43148: PUSH
43149: LD_INT 0
43151: PUSH
43152: EMPTY
43153: LIST
43154: LIST
43155: PUSH
43156: LD_INT 1
43158: NEG
43159: PUSH
43160: LD_INT 1
43162: NEG
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 1
43170: PUSH
43171: LD_INT 1
43173: NEG
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 2
43181: PUSH
43182: LD_INT 0
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 2
43191: PUSH
43192: LD_INT 1
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 2
43201: PUSH
43202: LD_INT 2
43204: PUSH
43205: EMPTY
43206: LIST
43207: LIST
43208: PUSH
43209: LD_INT 1
43211: PUSH
43212: LD_INT 2
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: LIST
43223: LIST
43224: LIST
43225: LIST
43226: LIST
43227: LIST
43228: LIST
43229: LIST
43230: LIST
43231: LIST
43232: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43233: LD_ADDR_VAR 0 50
43237: PUSH
43238: LD_INT 0
43240: PUSH
43241: LD_INT 0
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 0
43250: PUSH
43251: LD_INT 1
43253: NEG
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: LD_INT 1
43261: PUSH
43262: LD_INT 0
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 1
43271: PUSH
43272: LD_INT 1
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 0
43281: PUSH
43282: LD_INT 1
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 1
43291: NEG
43292: PUSH
43293: LD_INT 0
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 1
43302: NEG
43303: PUSH
43304: LD_INT 1
43306: NEG
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 2
43314: PUSH
43315: LD_INT 1
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 2
43324: PUSH
43325: LD_INT 2
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 1
43334: PUSH
43335: LD_INT 2
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 0
43344: PUSH
43345: LD_INT 2
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 1
43354: NEG
43355: PUSH
43356: LD_INT 1
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43377: LD_ADDR_VAR 0 51
43381: PUSH
43382: LD_INT 0
43384: PUSH
43385: LD_INT 0
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: LD_INT 0
43394: PUSH
43395: LD_INT 1
43397: NEG
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 1
43405: PUSH
43406: LD_INT 0
43408: PUSH
43409: EMPTY
43410: LIST
43411: LIST
43412: PUSH
43413: LD_INT 1
43415: PUSH
43416: LD_INT 1
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 0
43425: PUSH
43426: LD_INT 1
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: LD_INT 1
43435: NEG
43436: PUSH
43437: LD_INT 0
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 1
43446: NEG
43447: PUSH
43448: LD_INT 1
43450: NEG
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 1
43458: PUSH
43459: LD_INT 2
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: PUSH
43466: LD_INT 0
43468: PUSH
43469: LD_INT 2
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 1
43478: NEG
43479: PUSH
43480: LD_INT 1
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 2
43489: NEG
43490: PUSH
43491: LD_INT 0
43493: PUSH
43494: EMPTY
43495: LIST
43496: LIST
43497: PUSH
43498: LD_INT 2
43500: NEG
43501: PUSH
43502: LD_INT 1
43504: NEG
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: LIST
43514: LIST
43515: LIST
43516: LIST
43517: LIST
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43524: LD_ADDR_VAR 0 52
43528: PUSH
43529: LD_INT 0
43531: PUSH
43532: LD_INT 0
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PUSH
43539: LD_INT 0
43541: PUSH
43542: LD_INT 1
43544: NEG
43545: PUSH
43546: EMPTY
43547: LIST
43548: LIST
43549: PUSH
43550: LD_INT 1
43552: PUSH
43553: LD_INT 0
43555: PUSH
43556: EMPTY
43557: LIST
43558: LIST
43559: PUSH
43560: LD_INT 1
43562: PUSH
43563: LD_INT 1
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: PUSH
43570: LD_INT 0
43572: PUSH
43573: LD_INT 1
43575: PUSH
43576: EMPTY
43577: LIST
43578: LIST
43579: PUSH
43580: LD_INT 1
43582: NEG
43583: PUSH
43584: LD_INT 0
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 1
43593: NEG
43594: PUSH
43595: LD_INT 1
43597: NEG
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PUSH
43603: LD_INT 1
43605: NEG
43606: PUSH
43607: LD_INT 2
43609: NEG
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: PUSH
43615: LD_INT 1
43617: NEG
43618: PUSH
43619: LD_INT 1
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: PUSH
43626: LD_INT 2
43628: NEG
43629: PUSH
43630: LD_INT 0
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: LD_INT 2
43639: NEG
43640: PUSH
43641: LD_INT 1
43643: NEG
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: PUSH
43649: LD_INT 2
43651: NEG
43652: PUSH
43653: LD_INT 2
43655: NEG
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: LIST
43665: LIST
43666: LIST
43667: LIST
43668: LIST
43669: LIST
43670: LIST
43671: LIST
43672: LIST
43673: LIST
43674: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43675: LD_ADDR_VAR 0 53
43679: PUSH
43680: LD_INT 0
43682: PUSH
43683: LD_INT 0
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: LD_INT 0
43692: PUSH
43693: LD_INT 1
43695: NEG
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 1
43703: PUSH
43704: LD_INT 0
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: LD_INT 1
43713: PUSH
43714: LD_INT 1
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: LD_INT 0
43723: PUSH
43724: LD_INT 1
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PUSH
43731: LD_INT 1
43733: NEG
43734: PUSH
43735: LD_INT 0
43737: PUSH
43738: EMPTY
43739: LIST
43740: LIST
43741: PUSH
43742: LD_INT 1
43744: NEG
43745: PUSH
43746: LD_INT 1
43748: NEG
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 1
43756: NEG
43757: PUSH
43758: LD_INT 2
43760: NEG
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 0
43768: PUSH
43769: LD_INT 2
43771: NEG
43772: PUSH
43773: EMPTY
43774: LIST
43775: LIST
43776: PUSH
43777: LD_INT 1
43779: PUSH
43780: LD_INT 1
43782: NEG
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: LD_INT 2
43790: PUSH
43791: LD_INT 0
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 2
43800: PUSH
43801: LD_INT 1
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PUSH
43808: LD_INT 2
43810: PUSH
43811: LD_INT 2
43813: PUSH
43814: EMPTY
43815: LIST
43816: LIST
43817: PUSH
43818: LD_INT 1
43820: PUSH
43821: LD_INT 2
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: PUSH
43828: LD_INT 0
43830: PUSH
43831: LD_INT 2
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PUSH
43838: LD_INT 1
43840: NEG
43841: PUSH
43842: LD_INT 1
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 2
43851: NEG
43852: PUSH
43853: LD_INT 0
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: PUSH
43860: LD_INT 2
43862: NEG
43863: PUSH
43864: LD_INT 1
43866: NEG
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: LD_INT 2
43874: NEG
43875: PUSH
43876: LD_INT 2
43878: NEG
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: LIST
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: LIST
43897: LIST
43898: LIST
43899: LIST
43900: LIST
43901: LIST
43902: LIST
43903: LIST
43904: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43905: LD_ADDR_VAR 0 54
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: LD_INT 0
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 0
43922: PUSH
43923: LD_INT 1
43925: NEG
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: PUSH
43931: LD_INT 1
43933: PUSH
43934: LD_INT 0
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 1
43943: PUSH
43944: LD_INT 1
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 0
43953: PUSH
43954: LD_INT 1
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 1
43963: NEG
43964: PUSH
43965: LD_INT 0
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: PUSH
43972: LD_INT 1
43974: NEG
43975: PUSH
43976: LD_INT 1
43978: NEG
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 1
43986: NEG
43987: PUSH
43988: LD_INT 2
43990: NEG
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 0
43998: PUSH
43999: LD_INT 2
44001: NEG
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: LD_INT 1
44009: PUSH
44010: LD_INT 1
44012: NEG
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 2
44020: PUSH
44021: LD_INT 0
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: PUSH
44028: LD_INT 2
44030: PUSH
44031: LD_INT 1
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 2
44040: PUSH
44041: LD_INT 2
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 1
44050: PUSH
44051: LD_INT 2
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 0
44060: PUSH
44061: LD_INT 2
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 1
44070: NEG
44071: PUSH
44072: LD_INT 1
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 2
44081: NEG
44082: PUSH
44083: LD_INT 0
44085: PUSH
44086: EMPTY
44087: LIST
44088: LIST
44089: PUSH
44090: LD_INT 2
44092: NEG
44093: PUSH
44094: LD_INT 1
44096: NEG
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 2
44104: NEG
44105: PUSH
44106: LD_INT 2
44108: NEG
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: LIST
44122: LIST
44123: LIST
44124: LIST
44125: LIST
44126: LIST
44127: LIST
44128: LIST
44129: LIST
44130: LIST
44131: LIST
44132: LIST
44133: LIST
44134: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44135: LD_ADDR_VAR 0 55
44139: PUSH
44140: LD_INT 0
44142: PUSH
44143: LD_INT 0
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 0
44152: PUSH
44153: LD_INT 1
44155: NEG
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: PUSH
44161: LD_INT 1
44163: PUSH
44164: LD_INT 0
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 1
44173: PUSH
44174: LD_INT 1
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 0
44183: PUSH
44184: LD_INT 1
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PUSH
44191: LD_INT 1
44193: NEG
44194: PUSH
44195: LD_INT 0
44197: PUSH
44198: EMPTY
44199: LIST
44200: LIST
44201: PUSH
44202: LD_INT 1
44204: NEG
44205: PUSH
44206: LD_INT 1
44208: NEG
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_INT 1
44216: NEG
44217: PUSH
44218: LD_INT 2
44220: NEG
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 0
44228: PUSH
44229: LD_INT 2
44231: NEG
44232: PUSH
44233: EMPTY
44234: LIST
44235: LIST
44236: PUSH
44237: LD_INT 1
44239: PUSH
44240: LD_INT 1
44242: NEG
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: LD_INT 2
44250: PUSH
44251: LD_INT 0
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: PUSH
44258: LD_INT 2
44260: PUSH
44261: LD_INT 1
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 2
44270: PUSH
44271: LD_INT 2
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 1
44280: PUSH
44281: LD_INT 2
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: LD_INT 0
44290: PUSH
44291: LD_INT 2
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: PUSH
44298: LD_INT 1
44300: NEG
44301: PUSH
44302: LD_INT 1
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PUSH
44309: LD_INT 2
44311: NEG
44312: PUSH
44313: LD_INT 0
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: PUSH
44320: LD_INT 2
44322: NEG
44323: PUSH
44324: LD_INT 1
44326: NEG
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: PUSH
44332: LD_INT 2
44334: NEG
44335: PUSH
44336: LD_INT 2
44338: NEG
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: LIST
44348: LIST
44349: LIST
44350: LIST
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44365: LD_ADDR_VAR 0 56
44369: PUSH
44370: LD_INT 0
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 0
44382: PUSH
44383: LD_INT 1
44385: NEG
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 1
44393: PUSH
44394: LD_INT 0
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 1
44403: PUSH
44404: LD_INT 1
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: LD_INT 0
44413: PUSH
44414: LD_INT 1
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 1
44423: NEG
44424: PUSH
44425: LD_INT 0
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: PUSH
44432: LD_INT 1
44434: NEG
44435: PUSH
44436: LD_INT 1
44438: NEG
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 1
44446: NEG
44447: PUSH
44448: LD_INT 2
44450: NEG
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: PUSH
44456: LD_INT 0
44458: PUSH
44459: LD_INT 2
44461: NEG
44462: PUSH
44463: EMPTY
44464: LIST
44465: LIST
44466: PUSH
44467: LD_INT 1
44469: PUSH
44470: LD_INT 1
44472: NEG
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: LD_INT 2
44480: PUSH
44481: LD_INT 0
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PUSH
44488: LD_INT 2
44490: PUSH
44491: LD_INT 1
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 2
44500: PUSH
44501: LD_INT 2
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: PUSH
44508: LD_INT 1
44510: PUSH
44511: LD_INT 2
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: LD_INT 2
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 1
44530: NEG
44531: PUSH
44532: LD_INT 1
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: PUSH
44539: LD_INT 2
44541: NEG
44542: PUSH
44543: LD_INT 0
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PUSH
44550: LD_INT 2
44552: NEG
44553: PUSH
44554: LD_INT 1
44556: NEG
44557: PUSH
44558: EMPTY
44559: LIST
44560: LIST
44561: PUSH
44562: LD_INT 2
44564: NEG
44565: PUSH
44566: LD_INT 2
44568: NEG
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: LIST
44578: LIST
44579: LIST
44580: LIST
44581: LIST
44582: LIST
44583: LIST
44584: LIST
44585: LIST
44586: LIST
44587: LIST
44588: LIST
44589: LIST
44590: LIST
44591: LIST
44592: LIST
44593: LIST
44594: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44595: LD_ADDR_VAR 0 57
44599: PUSH
44600: LD_INT 0
44602: PUSH
44603: LD_INT 0
44605: PUSH
44606: EMPTY
44607: LIST
44608: LIST
44609: PUSH
44610: LD_INT 0
44612: PUSH
44613: LD_INT 1
44615: NEG
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 1
44623: PUSH
44624: LD_INT 0
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: LD_INT 1
44633: PUSH
44634: LD_INT 1
44636: PUSH
44637: EMPTY
44638: LIST
44639: LIST
44640: PUSH
44641: LD_INT 0
44643: PUSH
44644: LD_INT 1
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PUSH
44651: LD_INT 1
44653: NEG
44654: PUSH
44655: LD_INT 0
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: PUSH
44662: LD_INT 1
44664: NEG
44665: PUSH
44666: LD_INT 1
44668: NEG
44669: PUSH
44670: EMPTY
44671: LIST
44672: LIST
44673: PUSH
44674: LD_INT 1
44676: NEG
44677: PUSH
44678: LD_INT 2
44680: NEG
44681: PUSH
44682: EMPTY
44683: LIST
44684: LIST
44685: PUSH
44686: LD_INT 0
44688: PUSH
44689: LD_INT 2
44691: NEG
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: PUSH
44697: LD_INT 1
44699: PUSH
44700: LD_INT 1
44702: NEG
44703: PUSH
44704: EMPTY
44705: LIST
44706: LIST
44707: PUSH
44708: LD_INT 2
44710: PUSH
44711: LD_INT 0
44713: PUSH
44714: EMPTY
44715: LIST
44716: LIST
44717: PUSH
44718: LD_INT 2
44720: PUSH
44721: LD_INT 1
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 2
44730: PUSH
44731: LD_INT 2
44733: PUSH
44734: EMPTY
44735: LIST
44736: LIST
44737: PUSH
44738: LD_INT 1
44740: PUSH
44741: LD_INT 2
44743: PUSH
44744: EMPTY
44745: LIST
44746: LIST
44747: PUSH
44748: LD_INT 0
44750: PUSH
44751: LD_INT 2
44753: PUSH
44754: EMPTY
44755: LIST
44756: LIST
44757: PUSH
44758: LD_INT 1
44760: NEG
44761: PUSH
44762: LD_INT 1
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 2
44771: NEG
44772: PUSH
44773: LD_INT 0
44775: PUSH
44776: EMPTY
44777: LIST
44778: LIST
44779: PUSH
44780: LD_INT 2
44782: NEG
44783: PUSH
44784: LD_INT 1
44786: NEG
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 2
44794: NEG
44795: PUSH
44796: LD_INT 2
44798: NEG
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44825: LD_ADDR_VAR 0 58
44829: PUSH
44830: LD_INT 0
44832: PUSH
44833: LD_INT 0
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 0
44842: PUSH
44843: LD_INT 1
44845: NEG
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: LD_INT 1
44853: PUSH
44854: LD_INT 0
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 1
44863: PUSH
44864: LD_INT 1
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 0
44873: PUSH
44874: LD_INT 1
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 1
44883: NEG
44884: PUSH
44885: LD_INT 0
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: PUSH
44892: LD_INT 1
44894: NEG
44895: PUSH
44896: LD_INT 1
44898: NEG
44899: PUSH
44900: EMPTY
44901: LIST
44902: LIST
44903: PUSH
44904: LD_INT 1
44906: NEG
44907: PUSH
44908: LD_INT 2
44910: NEG
44911: PUSH
44912: EMPTY
44913: LIST
44914: LIST
44915: PUSH
44916: LD_INT 0
44918: PUSH
44919: LD_INT 2
44921: NEG
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: PUSH
44927: LD_INT 1
44929: PUSH
44930: LD_INT 1
44932: NEG
44933: PUSH
44934: EMPTY
44935: LIST
44936: LIST
44937: PUSH
44938: LD_INT 2
44940: PUSH
44941: LD_INT 0
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PUSH
44948: LD_INT 2
44950: PUSH
44951: LD_INT 1
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 2
44960: PUSH
44961: LD_INT 2
44963: PUSH
44964: EMPTY
44965: LIST
44966: LIST
44967: PUSH
44968: LD_INT 1
44970: PUSH
44971: LD_INT 2
44973: PUSH
44974: EMPTY
44975: LIST
44976: LIST
44977: PUSH
44978: LD_INT 0
44980: PUSH
44981: LD_INT 2
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 1
44990: NEG
44991: PUSH
44992: LD_INT 1
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 2
45001: NEG
45002: PUSH
45003: LD_INT 0
45005: PUSH
45006: EMPTY
45007: LIST
45008: LIST
45009: PUSH
45010: LD_INT 2
45012: NEG
45013: PUSH
45014: LD_INT 1
45016: NEG
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: PUSH
45022: LD_INT 2
45024: NEG
45025: PUSH
45026: LD_INT 2
45028: NEG
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: LIST
45038: LIST
45039: LIST
45040: LIST
45041: LIST
45042: LIST
45043: LIST
45044: LIST
45045: LIST
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: LIST
45051: LIST
45052: LIST
45053: LIST
45054: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45055: LD_ADDR_VAR 0 59
45059: PUSH
45060: LD_INT 0
45062: PUSH
45063: LD_INT 0
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: LD_INT 1
45075: NEG
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: PUSH
45081: LD_INT 1
45083: PUSH
45084: LD_INT 0
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 1
45093: PUSH
45094: LD_INT 1
45096: PUSH
45097: EMPTY
45098: LIST
45099: LIST
45100: PUSH
45101: LD_INT 0
45103: PUSH
45104: LD_INT 1
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: PUSH
45111: LD_INT 1
45113: NEG
45114: PUSH
45115: LD_INT 0
45117: PUSH
45118: EMPTY
45119: LIST
45120: LIST
45121: PUSH
45122: LD_INT 1
45124: NEG
45125: PUSH
45126: LD_INT 1
45128: NEG
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45143: LD_ADDR_VAR 0 60
45147: PUSH
45148: LD_INT 0
45150: PUSH
45151: LD_INT 0
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: PUSH
45158: LD_INT 0
45160: PUSH
45161: LD_INT 1
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 1
45171: PUSH
45172: LD_INT 0
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 1
45181: PUSH
45182: LD_INT 1
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 0
45191: PUSH
45192: LD_INT 1
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 1
45201: NEG
45202: PUSH
45203: LD_INT 0
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: PUSH
45210: LD_INT 1
45212: NEG
45213: PUSH
45214: LD_INT 1
45216: NEG
45217: PUSH
45218: EMPTY
45219: LIST
45220: LIST
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: LIST
45230: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45231: LD_ADDR_VAR 0 61
45235: PUSH
45236: LD_INT 0
45238: PUSH
45239: LD_INT 0
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: LD_INT 0
45248: PUSH
45249: LD_INT 1
45251: NEG
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 1
45259: PUSH
45260: LD_INT 0
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: LD_INT 1
45269: PUSH
45270: LD_INT 1
45272: PUSH
45273: EMPTY
45274: LIST
45275: LIST
45276: PUSH
45277: LD_INT 0
45279: PUSH
45280: LD_INT 1
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 1
45289: NEG
45290: PUSH
45291: LD_INT 0
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PUSH
45298: LD_INT 1
45300: NEG
45301: PUSH
45302: LD_INT 1
45304: NEG
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45319: LD_ADDR_VAR 0 62
45323: PUSH
45324: LD_INT 0
45326: PUSH
45327: LD_INT 0
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: PUSH
45334: LD_INT 0
45336: PUSH
45337: LD_INT 1
45339: NEG
45340: PUSH
45341: EMPTY
45342: LIST
45343: LIST
45344: PUSH
45345: LD_INT 1
45347: PUSH
45348: LD_INT 0
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: PUSH
45355: LD_INT 1
45357: PUSH
45358: LD_INT 1
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: PUSH
45365: LD_INT 0
45367: PUSH
45368: LD_INT 1
45370: PUSH
45371: EMPTY
45372: LIST
45373: LIST
45374: PUSH
45375: LD_INT 1
45377: NEG
45378: PUSH
45379: LD_INT 0
45381: PUSH
45382: EMPTY
45383: LIST
45384: LIST
45385: PUSH
45386: LD_INT 1
45388: NEG
45389: PUSH
45390: LD_INT 1
45392: NEG
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: LIST
45406: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45407: LD_ADDR_VAR 0 63
45411: PUSH
45412: LD_INT 0
45414: PUSH
45415: LD_INT 0
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 0
45424: PUSH
45425: LD_INT 1
45427: NEG
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 1
45435: PUSH
45436: LD_INT 0
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 1
45445: PUSH
45446: LD_INT 1
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: PUSH
45453: LD_INT 0
45455: PUSH
45456: LD_INT 1
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: PUSH
45463: LD_INT 1
45465: NEG
45466: PUSH
45467: LD_INT 0
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: PUSH
45474: LD_INT 1
45476: NEG
45477: PUSH
45478: LD_INT 1
45480: NEG
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: PUSH
45486: EMPTY
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45495: LD_ADDR_VAR 0 64
45499: PUSH
45500: LD_INT 0
45502: PUSH
45503: LD_INT 0
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: LD_INT 0
45512: PUSH
45513: LD_INT 1
45515: NEG
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 1
45523: PUSH
45524: LD_INT 0
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PUSH
45531: LD_INT 1
45533: PUSH
45534: LD_INT 1
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: PUSH
45541: LD_INT 0
45543: PUSH
45544: LD_INT 1
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 1
45553: NEG
45554: PUSH
45555: LD_INT 0
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: PUSH
45562: LD_INT 1
45564: NEG
45565: PUSH
45566: LD_INT 1
45568: NEG
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: LIST
45582: ST_TO_ADDR
// end ; 1 :
45583: GO 51480
45585: LD_INT 1
45587: DOUBLE
45588: EQUAL
45589: IFTRUE 45593
45591: GO 48216
45593: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45594: LD_ADDR_VAR 0 11
45598: PUSH
45599: LD_INT 1
45601: NEG
45602: PUSH
45603: LD_INT 3
45605: NEG
45606: PUSH
45607: EMPTY
45608: LIST
45609: LIST
45610: PUSH
45611: LD_INT 0
45613: PUSH
45614: LD_INT 3
45616: NEG
45617: PUSH
45618: EMPTY
45619: LIST
45620: LIST
45621: PUSH
45622: LD_INT 1
45624: PUSH
45625: LD_INT 2
45627: NEG
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: LIST
45637: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45638: LD_ADDR_VAR 0 12
45642: PUSH
45643: LD_INT 2
45645: PUSH
45646: LD_INT 1
45648: NEG
45649: PUSH
45650: EMPTY
45651: LIST
45652: LIST
45653: PUSH
45654: LD_INT 3
45656: PUSH
45657: LD_INT 0
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: PUSH
45664: LD_INT 3
45666: PUSH
45667: LD_INT 1
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: LIST
45678: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45679: LD_ADDR_VAR 0 13
45683: PUSH
45684: LD_INT 3
45686: PUSH
45687: LD_INT 2
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: PUSH
45694: LD_INT 3
45696: PUSH
45697: LD_INT 3
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: PUSH
45704: LD_INT 2
45706: PUSH
45707: LD_INT 3
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: EMPTY
45715: LIST
45716: LIST
45717: LIST
45718: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45719: LD_ADDR_VAR 0 14
45723: PUSH
45724: LD_INT 1
45726: PUSH
45727: LD_INT 3
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PUSH
45734: LD_INT 0
45736: PUSH
45737: LD_INT 3
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 1
45746: NEG
45747: PUSH
45748: LD_INT 2
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: LIST
45759: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45760: LD_ADDR_VAR 0 15
45764: PUSH
45765: LD_INT 2
45767: NEG
45768: PUSH
45769: LD_INT 1
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 3
45778: NEG
45779: PUSH
45780: LD_INT 0
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 3
45789: NEG
45790: PUSH
45791: LD_INT 1
45793: NEG
45794: PUSH
45795: EMPTY
45796: LIST
45797: LIST
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: LIST
45803: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45804: LD_ADDR_VAR 0 16
45808: PUSH
45809: LD_INT 2
45811: NEG
45812: PUSH
45813: LD_INT 3
45815: NEG
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 3
45823: NEG
45824: PUSH
45825: LD_INT 2
45827: NEG
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: PUSH
45833: LD_INT 3
45835: NEG
45836: PUSH
45837: LD_INT 3
45839: NEG
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: LIST
45849: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45850: LD_ADDR_VAR 0 17
45854: PUSH
45855: LD_INT 1
45857: NEG
45858: PUSH
45859: LD_INT 3
45861: NEG
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 0
45869: PUSH
45870: LD_INT 3
45872: NEG
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: LD_INT 1
45880: PUSH
45881: LD_INT 2
45883: NEG
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: LIST
45893: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45894: LD_ADDR_VAR 0 18
45898: PUSH
45899: LD_INT 2
45901: PUSH
45902: LD_INT 1
45904: NEG
45905: PUSH
45906: EMPTY
45907: LIST
45908: LIST
45909: PUSH
45910: LD_INT 3
45912: PUSH
45913: LD_INT 0
45915: PUSH
45916: EMPTY
45917: LIST
45918: LIST
45919: PUSH
45920: LD_INT 3
45922: PUSH
45923: LD_INT 1
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: LIST
45934: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45935: LD_ADDR_VAR 0 19
45939: PUSH
45940: LD_INT 3
45942: PUSH
45943: LD_INT 2
45945: PUSH
45946: EMPTY
45947: LIST
45948: LIST
45949: PUSH
45950: LD_INT 3
45952: PUSH
45953: LD_INT 3
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PUSH
45960: LD_INT 2
45962: PUSH
45963: LD_INT 3
45965: PUSH
45966: EMPTY
45967: LIST
45968: LIST
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: LIST
45974: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45975: LD_ADDR_VAR 0 20
45979: PUSH
45980: LD_INT 1
45982: PUSH
45983: LD_INT 3
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 0
45992: PUSH
45993: LD_INT 3
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 1
46002: NEG
46003: PUSH
46004: LD_INT 2
46006: PUSH
46007: EMPTY
46008: LIST
46009: LIST
46010: PUSH
46011: EMPTY
46012: LIST
46013: LIST
46014: LIST
46015: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46016: LD_ADDR_VAR 0 21
46020: PUSH
46021: LD_INT 2
46023: NEG
46024: PUSH
46025: LD_INT 1
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: LD_INT 3
46034: NEG
46035: PUSH
46036: LD_INT 0
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PUSH
46043: LD_INT 3
46045: NEG
46046: PUSH
46047: LD_INT 1
46049: NEG
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: LIST
46059: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46060: LD_ADDR_VAR 0 22
46064: PUSH
46065: LD_INT 2
46067: NEG
46068: PUSH
46069: LD_INT 3
46071: NEG
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PUSH
46077: LD_INT 3
46079: NEG
46080: PUSH
46081: LD_INT 2
46083: NEG
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 3
46091: NEG
46092: PUSH
46093: LD_INT 3
46095: NEG
46096: PUSH
46097: EMPTY
46098: LIST
46099: LIST
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: LIST
46105: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46106: LD_ADDR_VAR 0 23
46110: PUSH
46111: LD_INT 0
46113: PUSH
46114: LD_INT 3
46116: NEG
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: LD_INT 1
46124: NEG
46125: PUSH
46126: LD_INT 4
46128: NEG
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: LD_INT 1
46136: PUSH
46137: LD_INT 3
46139: NEG
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: LIST
46149: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46150: LD_ADDR_VAR 0 24
46154: PUSH
46155: LD_INT 3
46157: PUSH
46158: LD_INT 0
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: PUSH
46165: LD_INT 3
46167: PUSH
46168: LD_INT 1
46170: NEG
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: LD_INT 4
46178: PUSH
46179: LD_INT 1
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: LIST
46190: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46191: LD_ADDR_VAR 0 25
46195: PUSH
46196: LD_INT 3
46198: PUSH
46199: LD_INT 3
46201: PUSH
46202: EMPTY
46203: LIST
46204: LIST
46205: PUSH
46206: LD_INT 4
46208: PUSH
46209: LD_INT 3
46211: PUSH
46212: EMPTY
46213: LIST
46214: LIST
46215: PUSH
46216: LD_INT 3
46218: PUSH
46219: LD_INT 4
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: LIST
46230: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46231: LD_ADDR_VAR 0 26
46235: PUSH
46236: LD_INT 0
46238: PUSH
46239: LD_INT 3
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 1
46248: PUSH
46249: LD_INT 4
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 1
46258: NEG
46259: PUSH
46260: LD_INT 3
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: LIST
46271: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46272: LD_ADDR_VAR 0 27
46276: PUSH
46277: LD_INT 3
46279: NEG
46280: PUSH
46281: LD_INT 0
46283: PUSH
46284: EMPTY
46285: LIST
46286: LIST
46287: PUSH
46288: LD_INT 3
46290: NEG
46291: PUSH
46292: LD_INT 1
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: PUSH
46299: LD_INT 4
46301: NEG
46302: PUSH
46303: LD_INT 1
46305: NEG
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PUSH
46311: EMPTY
46312: LIST
46313: LIST
46314: LIST
46315: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46316: LD_ADDR_VAR 0 28
46320: PUSH
46321: LD_INT 3
46323: NEG
46324: PUSH
46325: LD_INT 3
46327: NEG
46328: PUSH
46329: EMPTY
46330: LIST
46331: LIST
46332: PUSH
46333: LD_INT 3
46335: NEG
46336: PUSH
46337: LD_INT 4
46339: NEG
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: LD_INT 4
46347: NEG
46348: PUSH
46349: LD_INT 3
46351: NEG
46352: PUSH
46353: EMPTY
46354: LIST
46355: LIST
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: LIST
46361: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46362: LD_ADDR_VAR 0 29
46366: PUSH
46367: LD_INT 1
46369: NEG
46370: PUSH
46371: LD_INT 3
46373: NEG
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: PUSH
46379: LD_INT 0
46381: PUSH
46382: LD_INT 3
46384: NEG
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 1
46392: PUSH
46393: LD_INT 2
46395: NEG
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 1
46403: NEG
46404: PUSH
46405: LD_INT 4
46407: NEG
46408: PUSH
46409: EMPTY
46410: LIST
46411: LIST
46412: PUSH
46413: LD_INT 0
46415: PUSH
46416: LD_INT 4
46418: NEG
46419: PUSH
46420: EMPTY
46421: LIST
46422: LIST
46423: PUSH
46424: LD_INT 1
46426: PUSH
46427: LD_INT 3
46429: NEG
46430: PUSH
46431: EMPTY
46432: LIST
46433: LIST
46434: PUSH
46435: LD_INT 1
46437: NEG
46438: PUSH
46439: LD_INT 5
46441: NEG
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: PUSH
46447: LD_INT 0
46449: PUSH
46450: LD_INT 5
46452: NEG
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 1
46460: PUSH
46461: LD_INT 4
46463: NEG
46464: PUSH
46465: EMPTY
46466: LIST
46467: LIST
46468: PUSH
46469: LD_INT 1
46471: NEG
46472: PUSH
46473: LD_INT 6
46475: NEG
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 0
46483: PUSH
46484: LD_INT 6
46486: NEG
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: PUSH
46492: LD_INT 1
46494: PUSH
46495: LD_INT 5
46497: NEG
46498: PUSH
46499: EMPTY
46500: LIST
46501: LIST
46502: PUSH
46503: EMPTY
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46517: LD_ADDR_VAR 0 30
46521: PUSH
46522: LD_INT 2
46524: PUSH
46525: LD_INT 1
46527: NEG
46528: PUSH
46529: EMPTY
46530: LIST
46531: LIST
46532: PUSH
46533: LD_INT 3
46535: PUSH
46536: LD_INT 0
46538: PUSH
46539: EMPTY
46540: LIST
46541: LIST
46542: PUSH
46543: LD_INT 3
46545: PUSH
46546: LD_INT 1
46548: PUSH
46549: EMPTY
46550: LIST
46551: LIST
46552: PUSH
46553: LD_INT 3
46555: PUSH
46556: LD_INT 1
46558: NEG
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PUSH
46564: LD_INT 4
46566: PUSH
46567: LD_INT 0
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: PUSH
46574: LD_INT 4
46576: PUSH
46577: LD_INT 1
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PUSH
46584: LD_INT 4
46586: PUSH
46587: LD_INT 1
46589: NEG
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: PUSH
46595: LD_INT 5
46597: PUSH
46598: LD_INT 0
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: PUSH
46605: LD_INT 5
46607: PUSH
46608: LD_INT 1
46610: PUSH
46611: EMPTY
46612: LIST
46613: LIST
46614: PUSH
46615: LD_INT 5
46617: PUSH
46618: LD_INT 1
46620: NEG
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: PUSH
46626: LD_INT 6
46628: PUSH
46629: LD_INT 0
46631: PUSH
46632: EMPTY
46633: LIST
46634: LIST
46635: PUSH
46636: LD_INT 6
46638: PUSH
46639: LD_INT 1
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: EMPTY
46647: LIST
46648: LIST
46649: LIST
46650: LIST
46651: LIST
46652: LIST
46653: LIST
46654: LIST
46655: LIST
46656: LIST
46657: LIST
46658: LIST
46659: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46660: LD_ADDR_VAR 0 31
46664: PUSH
46665: LD_INT 3
46667: PUSH
46668: LD_INT 2
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: PUSH
46675: LD_INT 3
46677: PUSH
46678: LD_INT 3
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: PUSH
46685: LD_INT 2
46687: PUSH
46688: LD_INT 3
46690: PUSH
46691: EMPTY
46692: LIST
46693: LIST
46694: PUSH
46695: LD_INT 4
46697: PUSH
46698: LD_INT 3
46700: PUSH
46701: EMPTY
46702: LIST
46703: LIST
46704: PUSH
46705: LD_INT 4
46707: PUSH
46708: LD_INT 4
46710: PUSH
46711: EMPTY
46712: LIST
46713: LIST
46714: PUSH
46715: LD_INT 3
46717: PUSH
46718: LD_INT 4
46720: PUSH
46721: EMPTY
46722: LIST
46723: LIST
46724: PUSH
46725: LD_INT 5
46727: PUSH
46728: LD_INT 4
46730: PUSH
46731: EMPTY
46732: LIST
46733: LIST
46734: PUSH
46735: LD_INT 5
46737: PUSH
46738: LD_INT 5
46740: PUSH
46741: EMPTY
46742: LIST
46743: LIST
46744: PUSH
46745: LD_INT 4
46747: PUSH
46748: LD_INT 5
46750: PUSH
46751: EMPTY
46752: LIST
46753: LIST
46754: PUSH
46755: LD_INT 6
46757: PUSH
46758: LD_INT 5
46760: PUSH
46761: EMPTY
46762: LIST
46763: LIST
46764: PUSH
46765: LD_INT 6
46767: PUSH
46768: LD_INT 6
46770: PUSH
46771: EMPTY
46772: LIST
46773: LIST
46774: PUSH
46775: LD_INT 5
46777: PUSH
46778: LD_INT 6
46780: PUSH
46781: EMPTY
46782: LIST
46783: LIST
46784: PUSH
46785: EMPTY
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46799: LD_ADDR_VAR 0 32
46803: PUSH
46804: LD_INT 1
46806: PUSH
46807: LD_INT 3
46809: PUSH
46810: EMPTY
46811: LIST
46812: LIST
46813: PUSH
46814: LD_INT 0
46816: PUSH
46817: LD_INT 3
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 1
46826: NEG
46827: PUSH
46828: LD_INT 2
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: LD_INT 1
46837: PUSH
46838: LD_INT 4
46840: PUSH
46841: EMPTY
46842: LIST
46843: LIST
46844: PUSH
46845: LD_INT 0
46847: PUSH
46848: LD_INT 4
46850: PUSH
46851: EMPTY
46852: LIST
46853: LIST
46854: PUSH
46855: LD_INT 1
46857: NEG
46858: PUSH
46859: LD_INT 3
46861: PUSH
46862: EMPTY
46863: LIST
46864: LIST
46865: PUSH
46866: LD_INT 1
46868: PUSH
46869: LD_INT 5
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: PUSH
46876: LD_INT 0
46878: PUSH
46879: LD_INT 5
46881: PUSH
46882: EMPTY
46883: LIST
46884: LIST
46885: PUSH
46886: LD_INT 1
46888: NEG
46889: PUSH
46890: LD_INT 4
46892: PUSH
46893: EMPTY
46894: LIST
46895: LIST
46896: PUSH
46897: LD_INT 1
46899: PUSH
46900: LD_INT 6
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: PUSH
46907: LD_INT 0
46909: PUSH
46910: LD_INT 6
46912: PUSH
46913: EMPTY
46914: LIST
46915: LIST
46916: PUSH
46917: LD_INT 1
46919: NEG
46920: PUSH
46921: LD_INT 5
46923: PUSH
46924: EMPTY
46925: LIST
46926: LIST
46927: PUSH
46928: EMPTY
46929: LIST
46930: LIST
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: LIST
46939: LIST
46940: LIST
46941: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46942: LD_ADDR_VAR 0 33
46946: PUSH
46947: LD_INT 2
46949: NEG
46950: PUSH
46951: LD_INT 1
46953: PUSH
46954: EMPTY
46955: LIST
46956: LIST
46957: PUSH
46958: LD_INT 3
46960: NEG
46961: PUSH
46962: LD_INT 0
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: PUSH
46969: LD_INT 3
46971: NEG
46972: PUSH
46973: LD_INT 1
46975: NEG
46976: PUSH
46977: EMPTY
46978: LIST
46979: LIST
46980: PUSH
46981: LD_INT 3
46983: NEG
46984: PUSH
46985: LD_INT 1
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: PUSH
46992: LD_INT 4
46994: NEG
46995: PUSH
46996: LD_INT 0
46998: PUSH
46999: EMPTY
47000: LIST
47001: LIST
47002: PUSH
47003: LD_INT 4
47005: NEG
47006: PUSH
47007: LD_INT 1
47009: NEG
47010: PUSH
47011: EMPTY
47012: LIST
47013: LIST
47014: PUSH
47015: LD_INT 4
47017: NEG
47018: PUSH
47019: LD_INT 1
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PUSH
47026: LD_INT 5
47028: NEG
47029: PUSH
47030: LD_INT 0
47032: PUSH
47033: EMPTY
47034: LIST
47035: LIST
47036: PUSH
47037: LD_INT 5
47039: NEG
47040: PUSH
47041: LD_INT 1
47043: NEG
47044: PUSH
47045: EMPTY
47046: LIST
47047: LIST
47048: PUSH
47049: LD_INT 5
47051: NEG
47052: PUSH
47053: LD_INT 1
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: PUSH
47060: LD_INT 6
47062: NEG
47063: PUSH
47064: LD_INT 0
47066: PUSH
47067: EMPTY
47068: LIST
47069: LIST
47070: PUSH
47071: LD_INT 6
47073: NEG
47074: PUSH
47075: LD_INT 1
47077: NEG
47078: PUSH
47079: EMPTY
47080: LIST
47081: LIST
47082: PUSH
47083: EMPTY
47084: LIST
47085: LIST
47086: LIST
47087: LIST
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: LIST
47095: LIST
47096: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47097: LD_ADDR_VAR 0 34
47101: PUSH
47102: LD_INT 2
47104: NEG
47105: PUSH
47106: LD_INT 3
47108: NEG
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: PUSH
47114: LD_INT 3
47116: NEG
47117: PUSH
47118: LD_INT 2
47120: NEG
47121: PUSH
47122: EMPTY
47123: LIST
47124: LIST
47125: PUSH
47126: LD_INT 3
47128: NEG
47129: PUSH
47130: LD_INT 3
47132: NEG
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PUSH
47138: LD_INT 3
47140: NEG
47141: PUSH
47142: LD_INT 4
47144: NEG
47145: PUSH
47146: EMPTY
47147: LIST
47148: LIST
47149: PUSH
47150: LD_INT 4
47152: NEG
47153: PUSH
47154: LD_INT 3
47156: NEG
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: PUSH
47162: LD_INT 4
47164: NEG
47165: PUSH
47166: LD_INT 4
47168: NEG
47169: PUSH
47170: EMPTY
47171: LIST
47172: LIST
47173: PUSH
47174: LD_INT 4
47176: NEG
47177: PUSH
47178: LD_INT 5
47180: NEG
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 5
47188: NEG
47189: PUSH
47190: LD_INT 4
47192: NEG
47193: PUSH
47194: EMPTY
47195: LIST
47196: LIST
47197: PUSH
47198: LD_INT 5
47200: NEG
47201: PUSH
47202: LD_INT 5
47204: NEG
47205: PUSH
47206: EMPTY
47207: LIST
47208: LIST
47209: PUSH
47210: LD_INT 5
47212: NEG
47213: PUSH
47214: LD_INT 6
47216: NEG
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: PUSH
47222: LD_INT 6
47224: NEG
47225: PUSH
47226: LD_INT 5
47228: NEG
47229: PUSH
47230: EMPTY
47231: LIST
47232: LIST
47233: PUSH
47234: LD_INT 6
47236: NEG
47237: PUSH
47238: LD_INT 6
47240: NEG
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PUSH
47246: EMPTY
47247: LIST
47248: LIST
47249: LIST
47250: LIST
47251: LIST
47252: LIST
47253: LIST
47254: LIST
47255: LIST
47256: LIST
47257: LIST
47258: LIST
47259: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47260: LD_ADDR_VAR 0 41
47264: PUSH
47265: LD_INT 0
47267: PUSH
47268: LD_INT 2
47270: NEG
47271: PUSH
47272: EMPTY
47273: LIST
47274: LIST
47275: PUSH
47276: LD_INT 1
47278: NEG
47279: PUSH
47280: LD_INT 3
47282: NEG
47283: PUSH
47284: EMPTY
47285: LIST
47286: LIST
47287: PUSH
47288: LD_INT 1
47290: PUSH
47291: LD_INT 2
47293: NEG
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: EMPTY
47300: LIST
47301: LIST
47302: LIST
47303: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47304: LD_ADDR_VAR 0 42
47308: PUSH
47309: LD_INT 2
47311: PUSH
47312: LD_INT 0
47314: PUSH
47315: EMPTY
47316: LIST
47317: LIST
47318: PUSH
47319: LD_INT 2
47321: PUSH
47322: LD_INT 1
47324: NEG
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: PUSH
47330: LD_INT 3
47332: PUSH
47333: LD_INT 1
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: LIST
47344: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47345: LD_ADDR_VAR 0 43
47349: PUSH
47350: LD_INT 2
47352: PUSH
47353: LD_INT 2
47355: PUSH
47356: EMPTY
47357: LIST
47358: LIST
47359: PUSH
47360: LD_INT 3
47362: PUSH
47363: LD_INT 2
47365: PUSH
47366: EMPTY
47367: LIST
47368: LIST
47369: PUSH
47370: LD_INT 2
47372: PUSH
47373: LD_INT 3
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: LIST
47384: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47385: LD_ADDR_VAR 0 44
47389: PUSH
47390: LD_INT 0
47392: PUSH
47393: LD_INT 2
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: PUSH
47400: LD_INT 1
47402: PUSH
47403: LD_INT 3
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: LD_INT 1
47412: NEG
47413: PUSH
47414: LD_INT 2
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: EMPTY
47422: LIST
47423: LIST
47424: LIST
47425: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47426: LD_ADDR_VAR 0 45
47430: PUSH
47431: LD_INT 2
47433: NEG
47434: PUSH
47435: LD_INT 0
47437: PUSH
47438: EMPTY
47439: LIST
47440: LIST
47441: PUSH
47442: LD_INT 2
47444: NEG
47445: PUSH
47446: LD_INT 1
47448: PUSH
47449: EMPTY
47450: LIST
47451: LIST
47452: PUSH
47453: LD_INT 3
47455: NEG
47456: PUSH
47457: LD_INT 1
47459: NEG
47460: PUSH
47461: EMPTY
47462: LIST
47463: LIST
47464: PUSH
47465: EMPTY
47466: LIST
47467: LIST
47468: LIST
47469: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47470: LD_ADDR_VAR 0 46
47474: PUSH
47475: LD_INT 2
47477: NEG
47478: PUSH
47479: LD_INT 2
47481: NEG
47482: PUSH
47483: EMPTY
47484: LIST
47485: LIST
47486: PUSH
47487: LD_INT 2
47489: NEG
47490: PUSH
47491: LD_INT 3
47493: NEG
47494: PUSH
47495: EMPTY
47496: LIST
47497: LIST
47498: PUSH
47499: LD_INT 3
47501: NEG
47502: PUSH
47503: LD_INT 2
47505: NEG
47506: PUSH
47507: EMPTY
47508: LIST
47509: LIST
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: LIST
47515: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47516: LD_ADDR_VAR 0 47
47520: PUSH
47521: LD_INT 2
47523: NEG
47524: PUSH
47525: LD_INT 3
47527: NEG
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: LD_INT 1
47535: NEG
47536: PUSH
47537: LD_INT 3
47539: NEG
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: EMPTY
47546: LIST
47547: LIST
47548: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47549: LD_ADDR_VAR 0 48
47553: PUSH
47554: LD_INT 1
47556: PUSH
47557: LD_INT 2
47559: NEG
47560: PUSH
47561: EMPTY
47562: LIST
47563: LIST
47564: PUSH
47565: LD_INT 2
47567: PUSH
47568: LD_INT 1
47570: NEG
47571: PUSH
47572: EMPTY
47573: LIST
47574: LIST
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47580: LD_ADDR_VAR 0 49
47584: PUSH
47585: LD_INT 3
47587: PUSH
47588: LD_INT 1
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PUSH
47595: LD_INT 3
47597: PUSH
47598: LD_INT 2
47600: PUSH
47601: EMPTY
47602: LIST
47603: LIST
47604: PUSH
47605: EMPTY
47606: LIST
47607: LIST
47608: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47609: LD_ADDR_VAR 0 50
47613: PUSH
47614: LD_INT 2
47616: PUSH
47617: LD_INT 3
47619: PUSH
47620: EMPTY
47621: LIST
47622: LIST
47623: PUSH
47624: LD_INT 1
47626: PUSH
47627: LD_INT 3
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PUSH
47634: EMPTY
47635: LIST
47636: LIST
47637: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47638: LD_ADDR_VAR 0 51
47642: PUSH
47643: LD_INT 1
47645: NEG
47646: PUSH
47647: LD_INT 2
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: PUSH
47654: LD_INT 2
47656: NEG
47657: PUSH
47658: LD_INT 1
47660: PUSH
47661: EMPTY
47662: LIST
47663: LIST
47664: PUSH
47665: EMPTY
47666: LIST
47667: LIST
47668: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47669: LD_ADDR_VAR 0 52
47673: PUSH
47674: LD_INT 3
47676: NEG
47677: PUSH
47678: LD_INT 1
47680: NEG
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: LD_INT 3
47688: NEG
47689: PUSH
47690: LD_INT 2
47692: NEG
47693: PUSH
47694: EMPTY
47695: LIST
47696: LIST
47697: PUSH
47698: EMPTY
47699: LIST
47700: LIST
47701: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47702: LD_ADDR_VAR 0 53
47706: PUSH
47707: LD_INT 1
47709: NEG
47710: PUSH
47711: LD_INT 3
47713: NEG
47714: PUSH
47715: EMPTY
47716: LIST
47717: LIST
47718: PUSH
47719: LD_INT 0
47721: PUSH
47722: LD_INT 3
47724: NEG
47725: PUSH
47726: EMPTY
47727: LIST
47728: LIST
47729: PUSH
47730: LD_INT 1
47732: PUSH
47733: LD_INT 2
47735: NEG
47736: PUSH
47737: EMPTY
47738: LIST
47739: LIST
47740: PUSH
47741: EMPTY
47742: LIST
47743: LIST
47744: LIST
47745: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47746: LD_ADDR_VAR 0 54
47750: PUSH
47751: LD_INT 2
47753: PUSH
47754: LD_INT 1
47756: NEG
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: PUSH
47762: LD_INT 3
47764: PUSH
47765: LD_INT 0
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: PUSH
47772: LD_INT 3
47774: PUSH
47775: LD_INT 1
47777: PUSH
47778: EMPTY
47779: LIST
47780: LIST
47781: PUSH
47782: EMPTY
47783: LIST
47784: LIST
47785: LIST
47786: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47787: LD_ADDR_VAR 0 55
47791: PUSH
47792: LD_INT 3
47794: PUSH
47795: LD_INT 2
47797: PUSH
47798: EMPTY
47799: LIST
47800: LIST
47801: PUSH
47802: LD_INT 3
47804: PUSH
47805: LD_INT 3
47807: PUSH
47808: EMPTY
47809: LIST
47810: LIST
47811: PUSH
47812: LD_INT 2
47814: PUSH
47815: LD_INT 3
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: PUSH
47822: EMPTY
47823: LIST
47824: LIST
47825: LIST
47826: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47827: LD_ADDR_VAR 0 56
47831: PUSH
47832: LD_INT 1
47834: PUSH
47835: LD_INT 3
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: PUSH
47842: LD_INT 0
47844: PUSH
47845: LD_INT 3
47847: PUSH
47848: EMPTY
47849: LIST
47850: LIST
47851: PUSH
47852: LD_INT 1
47854: NEG
47855: PUSH
47856: LD_INT 2
47858: PUSH
47859: EMPTY
47860: LIST
47861: LIST
47862: PUSH
47863: EMPTY
47864: LIST
47865: LIST
47866: LIST
47867: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47868: LD_ADDR_VAR 0 57
47872: PUSH
47873: LD_INT 2
47875: NEG
47876: PUSH
47877: LD_INT 1
47879: PUSH
47880: EMPTY
47881: LIST
47882: LIST
47883: PUSH
47884: LD_INT 3
47886: NEG
47887: PUSH
47888: LD_INT 0
47890: PUSH
47891: EMPTY
47892: LIST
47893: LIST
47894: PUSH
47895: LD_INT 3
47897: NEG
47898: PUSH
47899: LD_INT 1
47901: NEG
47902: PUSH
47903: EMPTY
47904: LIST
47905: LIST
47906: PUSH
47907: EMPTY
47908: LIST
47909: LIST
47910: LIST
47911: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47912: LD_ADDR_VAR 0 58
47916: PUSH
47917: LD_INT 2
47919: NEG
47920: PUSH
47921: LD_INT 3
47923: NEG
47924: PUSH
47925: EMPTY
47926: LIST
47927: LIST
47928: PUSH
47929: LD_INT 3
47931: NEG
47932: PUSH
47933: LD_INT 2
47935: NEG
47936: PUSH
47937: EMPTY
47938: LIST
47939: LIST
47940: PUSH
47941: LD_INT 3
47943: NEG
47944: PUSH
47945: LD_INT 3
47947: NEG
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: LIST
47957: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47958: LD_ADDR_VAR 0 59
47962: PUSH
47963: LD_INT 1
47965: NEG
47966: PUSH
47967: LD_INT 2
47969: NEG
47970: PUSH
47971: EMPTY
47972: LIST
47973: LIST
47974: PUSH
47975: LD_INT 0
47977: PUSH
47978: LD_INT 2
47980: NEG
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: PUSH
47986: LD_INT 1
47988: PUSH
47989: LD_INT 1
47991: NEG
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48002: LD_ADDR_VAR 0 60
48006: PUSH
48007: LD_INT 1
48009: PUSH
48010: LD_INT 1
48012: NEG
48013: PUSH
48014: EMPTY
48015: LIST
48016: LIST
48017: PUSH
48018: LD_INT 2
48020: PUSH
48021: LD_INT 0
48023: PUSH
48024: EMPTY
48025: LIST
48026: LIST
48027: PUSH
48028: LD_INT 2
48030: PUSH
48031: LD_INT 1
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: LIST
48042: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48043: LD_ADDR_VAR 0 61
48047: PUSH
48048: LD_INT 2
48050: PUSH
48051: LD_INT 1
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PUSH
48058: LD_INT 2
48060: PUSH
48061: LD_INT 2
48063: PUSH
48064: EMPTY
48065: LIST
48066: LIST
48067: PUSH
48068: LD_INT 1
48070: PUSH
48071: LD_INT 2
48073: PUSH
48074: EMPTY
48075: LIST
48076: LIST
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: LIST
48082: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48083: LD_ADDR_VAR 0 62
48087: PUSH
48088: LD_INT 1
48090: PUSH
48091: LD_INT 2
48093: PUSH
48094: EMPTY
48095: LIST
48096: LIST
48097: PUSH
48098: LD_INT 0
48100: PUSH
48101: LD_INT 2
48103: PUSH
48104: EMPTY
48105: LIST
48106: LIST
48107: PUSH
48108: LD_INT 1
48110: NEG
48111: PUSH
48112: LD_INT 1
48114: PUSH
48115: EMPTY
48116: LIST
48117: LIST
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: LIST
48123: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48124: LD_ADDR_VAR 0 63
48128: PUSH
48129: LD_INT 1
48131: NEG
48132: PUSH
48133: LD_INT 1
48135: PUSH
48136: EMPTY
48137: LIST
48138: LIST
48139: PUSH
48140: LD_INT 2
48142: NEG
48143: PUSH
48144: LD_INT 0
48146: PUSH
48147: EMPTY
48148: LIST
48149: LIST
48150: PUSH
48151: LD_INT 2
48153: NEG
48154: PUSH
48155: LD_INT 1
48157: NEG
48158: PUSH
48159: EMPTY
48160: LIST
48161: LIST
48162: PUSH
48163: EMPTY
48164: LIST
48165: LIST
48166: LIST
48167: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48168: LD_ADDR_VAR 0 64
48172: PUSH
48173: LD_INT 1
48175: NEG
48176: PUSH
48177: LD_INT 2
48179: NEG
48180: PUSH
48181: EMPTY
48182: LIST
48183: LIST
48184: PUSH
48185: LD_INT 2
48187: NEG
48188: PUSH
48189: LD_INT 1
48191: NEG
48192: PUSH
48193: EMPTY
48194: LIST
48195: LIST
48196: PUSH
48197: LD_INT 2
48199: NEG
48200: PUSH
48201: LD_INT 2
48203: NEG
48204: PUSH
48205: EMPTY
48206: LIST
48207: LIST
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: LIST
48213: ST_TO_ADDR
// end ; 2 :
48214: GO 51480
48216: LD_INT 2
48218: DOUBLE
48219: EQUAL
48220: IFTRUE 48224
48222: GO 51479
48224: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48225: LD_ADDR_VAR 0 29
48229: PUSH
48230: LD_INT 4
48232: PUSH
48233: LD_INT 0
48235: PUSH
48236: EMPTY
48237: LIST
48238: LIST
48239: PUSH
48240: LD_INT 4
48242: PUSH
48243: LD_INT 1
48245: NEG
48246: PUSH
48247: EMPTY
48248: LIST
48249: LIST
48250: PUSH
48251: LD_INT 5
48253: PUSH
48254: LD_INT 0
48256: PUSH
48257: EMPTY
48258: LIST
48259: LIST
48260: PUSH
48261: LD_INT 5
48263: PUSH
48264: LD_INT 1
48266: PUSH
48267: EMPTY
48268: LIST
48269: LIST
48270: PUSH
48271: LD_INT 4
48273: PUSH
48274: LD_INT 1
48276: PUSH
48277: EMPTY
48278: LIST
48279: LIST
48280: PUSH
48281: LD_INT 3
48283: PUSH
48284: LD_INT 0
48286: PUSH
48287: EMPTY
48288: LIST
48289: LIST
48290: PUSH
48291: LD_INT 3
48293: PUSH
48294: LD_INT 1
48296: NEG
48297: PUSH
48298: EMPTY
48299: LIST
48300: LIST
48301: PUSH
48302: LD_INT 3
48304: PUSH
48305: LD_INT 2
48307: NEG
48308: PUSH
48309: EMPTY
48310: LIST
48311: LIST
48312: PUSH
48313: LD_INT 5
48315: PUSH
48316: LD_INT 2
48318: PUSH
48319: EMPTY
48320: LIST
48321: LIST
48322: PUSH
48323: LD_INT 3
48325: PUSH
48326: LD_INT 3
48328: PUSH
48329: EMPTY
48330: LIST
48331: LIST
48332: PUSH
48333: LD_INT 3
48335: PUSH
48336: LD_INT 2
48338: PUSH
48339: EMPTY
48340: LIST
48341: LIST
48342: PUSH
48343: LD_INT 4
48345: PUSH
48346: LD_INT 3
48348: PUSH
48349: EMPTY
48350: LIST
48351: LIST
48352: PUSH
48353: LD_INT 4
48355: PUSH
48356: LD_INT 4
48358: PUSH
48359: EMPTY
48360: LIST
48361: LIST
48362: PUSH
48363: LD_INT 3
48365: PUSH
48366: LD_INT 4
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PUSH
48373: LD_INT 2
48375: PUSH
48376: LD_INT 3
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: LD_INT 2
48385: PUSH
48386: LD_INT 2
48388: PUSH
48389: EMPTY
48390: LIST
48391: LIST
48392: PUSH
48393: LD_INT 4
48395: PUSH
48396: LD_INT 2
48398: PUSH
48399: EMPTY
48400: LIST
48401: LIST
48402: PUSH
48403: LD_INT 2
48405: PUSH
48406: LD_INT 4
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: PUSH
48413: LD_INT 0
48415: PUSH
48416: LD_INT 4
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 0
48425: PUSH
48426: LD_INT 3
48428: PUSH
48429: EMPTY
48430: LIST
48431: LIST
48432: PUSH
48433: LD_INT 1
48435: PUSH
48436: LD_INT 4
48438: PUSH
48439: EMPTY
48440: LIST
48441: LIST
48442: PUSH
48443: LD_INT 1
48445: PUSH
48446: LD_INT 5
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PUSH
48453: LD_INT 0
48455: PUSH
48456: LD_INT 5
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PUSH
48463: LD_INT 1
48465: NEG
48466: PUSH
48467: LD_INT 4
48469: PUSH
48470: EMPTY
48471: LIST
48472: LIST
48473: PUSH
48474: LD_INT 1
48476: NEG
48477: PUSH
48478: LD_INT 3
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: PUSH
48485: LD_INT 2
48487: PUSH
48488: LD_INT 5
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: LD_INT 2
48497: NEG
48498: PUSH
48499: LD_INT 3
48501: PUSH
48502: EMPTY
48503: LIST
48504: LIST
48505: PUSH
48506: LD_INT 3
48508: NEG
48509: PUSH
48510: LD_INT 0
48512: PUSH
48513: EMPTY
48514: LIST
48515: LIST
48516: PUSH
48517: LD_INT 3
48519: NEG
48520: PUSH
48521: LD_INT 1
48523: NEG
48524: PUSH
48525: EMPTY
48526: LIST
48527: LIST
48528: PUSH
48529: LD_INT 2
48531: NEG
48532: PUSH
48533: LD_INT 0
48535: PUSH
48536: EMPTY
48537: LIST
48538: LIST
48539: PUSH
48540: LD_INT 2
48542: NEG
48543: PUSH
48544: LD_INT 1
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: PUSH
48551: LD_INT 3
48553: NEG
48554: PUSH
48555: LD_INT 1
48557: PUSH
48558: EMPTY
48559: LIST
48560: LIST
48561: PUSH
48562: LD_INT 4
48564: NEG
48565: PUSH
48566: LD_INT 0
48568: PUSH
48569: EMPTY
48570: LIST
48571: LIST
48572: PUSH
48573: LD_INT 4
48575: NEG
48576: PUSH
48577: LD_INT 1
48579: NEG
48580: PUSH
48581: EMPTY
48582: LIST
48583: LIST
48584: PUSH
48585: LD_INT 4
48587: NEG
48588: PUSH
48589: LD_INT 2
48591: NEG
48592: PUSH
48593: EMPTY
48594: LIST
48595: LIST
48596: PUSH
48597: LD_INT 2
48599: NEG
48600: PUSH
48601: LD_INT 2
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: PUSH
48608: LD_INT 4
48610: NEG
48611: PUSH
48612: LD_INT 4
48614: NEG
48615: PUSH
48616: EMPTY
48617: LIST
48618: LIST
48619: PUSH
48620: LD_INT 4
48622: NEG
48623: PUSH
48624: LD_INT 5
48626: NEG
48627: PUSH
48628: EMPTY
48629: LIST
48630: LIST
48631: PUSH
48632: LD_INT 3
48634: NEG
48635: PUSH
48636: LD_INT 4
48638: NEG
48639: PUSH
48640: EMPTY
48641: LIST
48642: LIST
48643: PUSH
48644: LD_INT 3
48646: NEG
48647: PUSH
48648: LD_INT 3
48650: NEG
48651: PUSH
48652: EMPTY
48653: LIST
48654: LIST
48655: PUSH
48656: LD_INT 4
48658: NEG
48659: PUSH
48660: LD_INT 3
48662: NEG
48663: PUSH
48664: EMPTY
48665: LIST
48666: LIST
48667: PUSH
48668: LD_INT 5
48670: NEG
48671: PUSH
48672: LD_INT 4
48674: NEG
48675: PUSH
48676: EMPTY
48677: LIST
48678: LIST
48679: PUSH
48680: LD_INT 5
48682: NEG
48683: PUSH
48684: LD_INT 5
48686: NEG
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 3
48694: NEG
48695: PUSH
48696: LD_INT 5
48698: NEG
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PUSH
48704: LD_INT 5
48706: NEG
48707: PUSH
48708: LD_INT 3
48710: NEG
48711: PUSH
48712: EMPTY
48713: LIST
48714: LIST
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: LIST
48720: LIST
48721: LIST
48722: LIST
48723: LIST
48724: LIST
48725: LIST
48726: LIST
48727: LIST
48728: LIST
48729: LIST
48730: LIST
48731: LIST
48732: LIST
48733: LIST
48734: LIST
48735: LIST
48736: LIST
48737: LIST
48738: LIST
48739: LIST
48740: LIST
48741: LIST
48742: LIST
48743: LIST
48744: LIST
48745: LIST
48746: LIST
48747: LIST
48748: LIST
48749: LIST
48750: LIST
48751: LIST
48752: LIST
48753: LIST
48754: LIST
48755: LIST
48756: LIST
48757: LIST
48758: LIST
48759: LIST
48760: LIST
48761: LIST
48762: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48763: LD_ADDR_VAR 0 30
48767: PUSH
48768: LD_INT 4
48770: PUSH
48771: LD_INT 4
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PUSH
48778: LD_INT 4
48780: PUSH
48781: LD_INT 3
48783: PUSH
48784: EMPTY
48785: LIST
48786: LIST
48787: PUSH
48788: LD_INT 5
48790: PUSH
48791: LD_INT 4
48793: PUSH
48794: EMPTY
48795: LIST
48796: LIST
48797: PUSH
48798: LD_INT 5
48800: PUSH
48801: LD_INT 5
48803: PUSH
48804: EMPTY
48805: LIST
48806: LIST
48807: PUSH
48808: LD_INT 4
48810: PUSH
48811: LD_INT 5
48813: PUSH
48814: EMPTY
48815: LIST
48816: LIST
48817: PUSH
48818: LD_INT 3
48820: PUSH
48821: LD_INT 4
48823: PUSH
48824: EMPTY
48825: LIST
48826: LIST
48827: PUSH
48828: LD_INT 3
48830: PUSH
48831: LD_INT 3
48833: PUSH
48834: EMPTY
48835: LIST
48836: LIST
48837: PUSH
48838: LD_INT 5
48840: PUSH
48841: LD_INT 3
48843: PUSH
48844: EMPTY
48845: LIST
48846: LIST
48847: PUSH
48848: LD_INT 3
48850: PUSH
48851: LD_INT 5
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PUSH
48858: LD_INT 0
48860: PUSH
48861: LD_INT 3
48863: PUSH
48864: EMPTY
48865: LIST
48866: LIST
48867: PUSH
48868: LD_INT 0
48870: PUSH
48871: LD_INT 2
48873: PUSH
48874: EMPTY
48875: LIST
48876: LIST
48877: PUSH
48878: LD_INT 1
48880: PUSH
48881: LD_INT 3
48883: PUSH
48884: EMPTY
48885: LIST
48886: LIST
48887: PUSH
48888: LD_INT 1
48890: PUSH
48891: LD_INT 4
48893: PUSH
48894: EMPTY
48895: LIST
48896: LIST
48897: PUSH
48898: LD_INT 0
48900: PUSH
48901: LD_INT 4
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: PUSH
48908: LD_INT 1
48910: NEG
48911: PUSH
48912: LD_INT 3
48914: PUSH
48915: EMPTY
48916: LIST
48917: LIST
48918: PUSH
48919: LD_INT 1
48921: NEG
48922: PUSH
48923: LD_INT 2
48925: PUSH
48926: EMPTY
48927: LIST
48928: LIST
48929: PUSH
48930: LD_INT 2
48932: PUSH
48933: LD_INT 4
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PUSH
48940: LD_INT 2
48942: NEG
48943: PUSH
48944: LD_INT 2
48946: PUSH
48947: EMPTY
48948: LIST
48949: LIST
48950: PUSH
48951: LD_INT 4
48953: NEG
48954: PUSH
48955: LD_INT 0
48957: PUSH
48958: EMPTY
48959: LIST
48960: LIST
48961: PUSH
48962: LD_INT 4
48964: NEG
48965: PUSH
48966: LD_INT 1
48968: NEG
48969: PUSH
48970: EMPTY
48971: LIST
48972: LIST
48973: PUSH
48974: LD_INT 3
48976: NEG
48977: PUSH
48978: LD_INT 0
48980: PUSH
48981: EMPTY
48982: LIST
48983: LIST
48984: PUSH
48985: LD_INT 3
48987: NEG
48988: PUSH
48989: LD_INT 1
48991: PUSH
48992: EMPTY
48993: LIST
48994: LIST
48995: PUSH
48996: LD_INT 4
48998: NEG
48999: PUSH
49000: LD_INT 1
49002: PUSH
49003: EMPTY
49004: LIST
49005: LIST
49006: PUSH
49007: LD_INT 5
49009: NEG
49010: PUSH
49011: LD_INT 0
49013: PUSH
49014: EMPTY
49015: LIST
49016: LIST
49017: PUSH
49018: LD_INT 5
49020: NEG
49021: PUSH
49022: LD_INT 1
49024: NEG
49025: PUSH
49026: EMPTY
49027: LIST
49028: LIST
49029: PUSH
49030: LD_INT 5
49032: NEG
49033: PUSH
49034: LD_INT 2
49036: NEG
49037: PUSH
49038: EMPTY
49039: LIST
49040: LIST
49041: PUSH
49042: LD_INT 3
49044: NEG
49045: PUSH
49046: LD_INT 2
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PUSH
49053: LD_INT 3
49055: NEG
49056: PUSH
49057: LD_INT 3
49059: NEG
49060: PUSH
49061: EMPTY
49062: LIST
49063: LIST
49064: PUSH
49065: LD_INT 3
49067: NEG
49068: PUSH
49069: LD_INT 4
49071: NEG
49072: PUSH
49073: EMPTY
49074: LIST
49075: LIST
49076: PUSH
49077: LD_INT 2
49079: NEG
49080: PUSH
49081: LD_INT 3
49083: NEG
49084: PUSH
49085: EMPTY
49086: LIST
49087: LIST
49088: PUSH
49089: LD_INT 2
49091: NEG
49092: PUSH
49093: LD_INT 2
49095: NEG
49096: PUSH
49097: EMPTY
49098: LIST
49099: LIST
49100: PUSH
49101: LD_INT 3
49103: NEG
49104: PUSH
49105: LD_INT 2
49107: NEG
49108: PUSH
49109: EMPTY
49110: LIST
49111: LIST
49112: PUSH
49113: LD_INT 4
49115: NEG
49116: PUSH
49117: LD_INT 3
49119: NEG
49120: PUSH
49121: EMPTY
49122: LIST
49123: LIST
49124: PUSH
49125: LD_INT 4
49127: NEG
49128: PUSH
49129: LD_INT 4
49131: NEG
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: LD_INT 2
49139: NEG
49140: PUSH
49141: LD_INT 4
49143: NEG
49144: PUSH
49145: EMPTY
49146: LIST
49147: LIST
49148: PUSH
49149: LD_INT 4
49151: NEG
49152: PUSH
49153: LD_INT 2
49155: NEG
49156: PUSH
49157: EMPTY
49158: LIST
49159: LIST
49160: PUSH
49161: LD_INT 0
49163: PUSH
49164: LD_INT 4
49166: NEG
49167: PUSH
49168: EMPTY
49169: LIST
49170: LIST
49171: PUSH
49172: LD_INT 0
49174: PUSH
49175: LD_INT 5
49177: NEG
49178: PUSH
49179: EMPTY
49180: LIST
49181: LIST
49182: PUSH
49183: LD_INT 1
49185: PUSH
49186: LD_INT 4
49188: NEG
49189: PUSH
49190: EMPTY
49191: LIST
49192: LIST
49193: PUSH
49194: LD_INT 1
49196: PUSH
49197: LD_INT 3
49199: NEG
49200: PUSH
49201: EMPTY
49202: LIST
49203: LIST
49204: PUSH
49205: LD_INT 0
49207: PUSH
49208: LD_INT 3
49210: NEG
49211: PUSH
49212: EMPTY
49213: LIST
49214: LIST
49215: PUSH
49216: LD_INT 1
49218: NEG
49219: PUSH
49220: LD_INT 4
49222: NEG
49223: PUSH
49224: EMPTY
49225: LIST
49226: LIST
49227: PUSH
49228: LD_INT 1
49230: NEG
49231: PUSH
49232: LD_INT 5
49234: NEG
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: LD_INT 2
49242: PUSH
49243: LD_INT 3
49245: NEG
49246: PUSH
49247: EMPTY
49248: LIST
49249: LIST
49250: PUSH
49251: LD_INT 2
49253: NEG
49254: PUSH
49255: LD_INT 5
49257: NEG
49258: PUSH
49259: EMPTY
49260: LIST
49261: LIST
49262: PUSH
49263: EMPTY
49264: LIST
49265: LIST
49266: LIST
49267: LIST
49268: LIST
49269: LIST
49270: LIST
49271: LIST
49272: LIST
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: LIST
49279: LIST
49280: LIST
49281: LIST
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: LIST
49288: LIST
49289: LIST
49290: LIST
49291: LIST
49292: LIST
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49310: LD_ADDR_VAR 0 31
49314: PUSH
49315: LD_INT 0
49317: PUSH
49318: LD_INT 4
49320: PUSH
49321: EMPTY
49322: LIST
49323: LIST
49324: PUSH
49325: LD_INT 0
49327: PUSH
49328: LD_INT 3
49330: PUSH
49331: EMPTY
49332: LIST
49333: LIST
49334: PUSH
49335: LD_INT 1
49337: PUSH
49338: LD_INT 4
49340: PUSH
49341: EMPTY
49342: LIST
49343: LIST
49344: PUSH
49345: LD_INT 1
49347: PUSH
49348: LD_INT 5
49350: PUSH
49351: EMPTY
49352: LIST
49353: LIST
49354: PUSH
49355: LD_INT 0
49357: PUSH
49358: LD_INT 5
49360: PUSH
49361: EMPTY
49362: LIST
49363: LIST
49364: PUSH
49365: LD_INT 1
49367: NEG
49368: PUSH
49369: LD_INT 4
49371: PUSH
49372: EMPTY
49373: LIST
49374: LIST
49375: PUSH
49376: LD_INT 1
49378: NEG
49379: PUSH
49380: LD_INT 3
49382: PUSH
49383: EMPTY
49384: LIST
49385: LIST
49386: PUSH
49387: LD_INT 2
49389: PUSH
49390: LD_INT 5
49392: PUSH
49393: EMPTY
49394: LIST
49395: LIST
49396: PUSH
49397: LD_INT 2
49399: NEG
49400: PUSH
49401: LD_INT 3
49403: PUSH
49404: EMPTY
49405: LIST
49406: LIST
49407: PUSH
49408: LD_INT 3
49410: NEG
49411: PUSH
49412: LD_INT 0
49414: PUSH
49415: EMPTY
49416: LIST
49417: LIST
49418: PUSH
49419: LD_INT 3
49421: NEG
49422: PUSH
49423: LD_INT 1
49425: NEG
49426: PUSH
49427: EMPTY
49428: LIST
49429: LIST
49430: PUSH
49431: LD_INT 2
49433: NEG
49434: PUSH
49435: LD_INT 0
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: PUSH
49442: LD_INT 2
49444: NEG
49445: PUSH
49446: LD_INT 1
49448: PUSH
49449: EMPTY
49450: LIST
49451: LIST
49452: PUSH
49453: LD_INT 3
49455: NEG
49456: PUSH
49457: LD_INT 1
49459: PUSH
49460: EMPTY
49461: LIST
49462: LIST
49463: PUSH
49464: LD_INT 4
49466: NEG
49467: PUSH
49468: LD_INT 0
49470: PUSH
49471: EMPTY
49472: LIST
49473: LIST
49474: PUSH
49475: LD_INT 4
49477: NEG
49478: PUSH
49479: LD_INT 1
49481: NEG
49482: PUSH
49483: EMPTY
49484: LIST
49485: LIST
49486: PUSH
49487: LD_INT 4
49489: NEG
49490: PUSH
49491: LD_INT 2
49493: NEG
49494: PUSH
49495: EMPTY
49496: LIST
49497: LIST
49498: PUSH
49499: LD_INT 2
49501: NEG
49502: PUSH
49503: LD_INT 2
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 4
49512: NEG
49513: PUSH
49514: LD_INT 4
49516: NEG
49517: PUSH
49518: EMPTY
49519: LIST
49520: LIST
49521: PUSH
49522: LD_INT 4
49524: NEG
49525: PUSH
49526: LD_INT 5
49528: NEG
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PUSH
49534: LD_INT 3
49536: NEG
49537: PUSH
49538: LD_INT 4
49540: NEG
49541: PUSH
49542: EMPTY
49543: LIST
49544: LIST
49545: PUSH
49546: LD_INT 3
49548: NEG
49549: PUSH
49550: LD_INT 3
49552: NEG
49553: PUSH
49554: EMPTY
49555: LIST
49556: LIST
49557: PUSH
49558: LD_INT 4
49560: NEG
49561: PUSH
49562: LD_INT 3
49564: NEG
49565: PUSH
49566: EMPTY
49567: LIST
49568: LIST
49569: PUSH
49570: LD_INT 5
49572: NEG
49573: PUSH
49574: LD_INT 4
49576: NEG
49577: PUSH
49578: EMPTY
49579: LIST
49580: LIST
49581: PUSH
49582: LD_INT 5
49584: NEG
49585: PUSH
49586: LD_INT 5
49588: NEG
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: PUSH
49594: LD_INT 3
49596: NEG
49597: PUSH
49598: LD_INT 5
49600: NEG
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PUSH
49606: LD_INT 5
49608: NEG
49609: PUSH
49610: LD_INT 3
49612: NEG
49613: PUSH
49614: EMPTY
49615: LIST
49616: LIST
49617: PUSH
49618: LD_INT 0
49620: PUSH
49621: LD_INT 3
49623: NEG
49624: PUSH
49625: EMPTY
49626: LIST
49627: LIST
49628: PUSH
49629: LD_INT 0
49631: PUSH
49632: LD_INT 4
49634: NEG
49635: PUSH
49636: EMPTY
49637: LIST
49638: LIST
49639: PUSH
49640: LD_INT 1
49642: PUSH
49643: LD_INT 3
49645: NEG
49646: PUSH
49647: EMPTY
49648: LIST
49649: LIST
49650: PUSH
49651: LD_INT 1
49653: PUSH
49654: LD_INT 2
49656: NEG
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: LD_INT 0
49664: PUSH
49665: LD_INT 2
49667: NEG
49668: PUSH
49669: EMPTY
49670: LIST
49671: LIST
49672: PUSH
49673: LD_INT 1
49675: NEG
49676: PUSH
49677: LD_INT 3
49679: NEG
49680: PUSH
49681: EMPTY
49682: LIST
49683: LIST
49684: PUSH
49685: LD_INT 1
49687: NEG
49688: PUSH
49689: LD_INT 4
49691: NEG
49692: PUSH
49693: EMPTY
49694: LIST
49695: LIST
49696: PUSH
49697: LD_INT 2
49699: PUSH
49700: LD_INT 2
49702: NEG
49703: PUSH
49704: EMPTY
49705: LIST
49706: LIST
49707: PUSH
49708: LD_INT 2
49710: NEG
49711: PUSH
49712: LD_INT 4
49714: NEG
49715: PUSH
49716: EMPTY
49717: LIST
49718: LIST
49719: PUSH
49720: LD_INT 4
49722: PUSH
49723: LD_INT 0
49725: PUSH
49726: EMPTY
49727: LIST
49728: LIST
49729: PUSH
49730: LD_INT 4
49732: PUSH
49733: LD_INT 1
49735: NEG
49736: PUSH
49737: EMPTY
49738: LIST
49739: LIST
49740: PUSH
49741: LD_INT 5
49743: PUSH
49744: LD_INT 0
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: PUSH
49751: LD_INT 5
49753: PUSH
49754: LD_INT 1
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: LD_INT 4
49763: PUSH
49764: LD_INT 1
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: PUSH
49771: LD_INT 3
49773: PUSH
49774: LD_INT 0
49776: PUSH
49777: EMPTY
49778: LIST
49779: LIST
49780: PUSH
49781: LD_INT 3
49783: PUSH
49784: LD_INT 1
49786: NEG
49787: PUSH
49788: EMPTY
49789: LIST
49790: LIST
49791: PUSH
49792: LD_INT 3
49794: PUSH
49795: LD_INT 2
49797: NEG
49798: PUSH
49799: EMPTY
49800: LIST
49801: LIST
49802: PUSH
49803: LD_INT 5
49805: PUSH
49806: LD_INT 2
49808: PUSH
49809: EMPTY
49810: LIST
49811: LIST
49812: PUSH
49813: EMPTY
49814: LIST
49815: LIST
49816: LIST
49817: LIST
49818: LIST
49819: LIST
49820: LIST
49821: LIST
49822: LIST
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: LIST
49828: LIST
49829: LIST
49830: LIST
49831: LIST
49832: LIST
49833: LIST
49834: LIST
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: LIST
49840: LIST
49841: LIST
49842: LIST
49843: LIST
49844: LIST
49845: LIST
49846: LIST
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: LIST
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49860: LD_ADDR_VAR 0 32
49864: PUSH
49865: LD_INT 4
49867: NEG
49868: PUSH
49869: LD_INT 0
49871: PUSH
49872: EMPTY
49873: LIST
49874: LIST
49875: PUSH
49876: LD_INT 4
49878: NEG
49879: PUSH
49880: LD_INT 1
49882: NEG
49883: PUSH
49884: EMPTY
49885: LIST
49886: LIST
49887: PUSH
49888: LD_INT 3
49890: NEG
49891: PUSH
49892: LD_INT 0
49894: PUSH
49895: EMPTY
49896: LIST
49897: LIST
49898: PUSH
49899: LD_INT 3
49901: NEG
49902: PUSH
49903: LD_INT 1
49905: PUSH
49906: EMPTY
49907: LIST
49908: LIST
49909: PUSH
49910: LD_INT 4
49912: NEG
49913: PUSH
49914: LD_INT 1
49916: PUSH
49917: EMPTY
49918: LIST
49919: LIST
49920: PUSH
49921: LD_INT 5
49923: NEG
49924: PUSH
49925: LD_INT 0
49927: PUSH
49928: EMPTY
49929: LIST
49930: LIST
49931: PUSH
49932: LD_INT 5
49934: NEG
49935: PUSH
49936: LD_INT 1
49938: NEG
49939: PUSH
49940: EMPTY
49941: LIST
49942: LIST
49943: PUSH
49944: LD_INT 5
49946: NEG
49947: PUSH
49948: LD_INT 2
49950: NEG
49951: PUSH
49952: EMPTY
49953: LIST
49954: LIST
49955: PUSH
49956: LD_INT 3
49958: NEG
49959: PUSH
49960: LD_INT 2
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: LD_INT 3
49969: NEG
49970: PUSH
49971: LD_INT 3
49973: NEG
49974: PUSH
49975: EMPTY
49976: LIST
49977: LIST
49978: PUSH
49979: LD_INT 3
49981: NEG
49982: PUSH
49983: LD_INT 4
49985: NEG
49986: PUSH
49987: EMPTY
49988: LIST
49989: LIST
49990: PUSH
49991: LD_INT 2
49993: NEG
49994: PUSH
49995: LD_INT 3
49997: NEG
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: PUSH
50003: LD_INT 2
50005: NEG
50006: PUSH
50007: LD_INT 2
50009: NEG
50010: PUSH
50011: EMPTY
50012: LIST
50013: LIST
50014: PUSH
50015: LD_INT 3
50017: NEG
50018: PUSH
50019: LD_INT 2
50021: NEG
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: PUSH
50027: LD_INT 4
50029: NEG
50030: PUSH
50031: LD_INT 3
50033: NEG
50034: PUSH
50035: EMPTY
50036: LIST
50037: LIST
50038: PUSH
50039: LD_INT 4
50041: NEG
50042: PUSH
50043: LD_INT 4
50045: NEG
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: PUSH
50051: LD_INT 2
50053: NEG
50054: PUSH
50055: LD_INT 4
50057: NEG
50058: PUSH
50059: EMPTY
50060: LIST
50061: LIST
50062: PUSH
50063: LD_INT 4
50065: NEG
50066: PUSH
50067: LD_INT 2
50069: NEG
50070: PUSH
50071: EMPTY
50072: LIST
50073: LIST
50074: PUSH
50075: LD_INT 0
50077: PUSH
50078: LD_INT 4
50080: NEG
50081: PUSH
50082: EMPTY
50083: LIST
50084: LIST
50085: PUSH
50086: LD_INT 0
50088: PUSH
50089: LD_INT 5
50091: NEG
50092: PUSH
50093: EMPTY
50094: LIST
50095: LIST
50096: PUSH
50097: LD_INT 1
50099: PUSH
50100: LD_INT 4
50102: NEG
50103: PUSH
50104: EMPTY
50105: LIST
50106: LIST
50107: PUSH
50108: LD_INT 1
50110: PUSH
50111: LD_INT 3
50113: NEG
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: PUSH
50119: LD_INT 0
50121: PUSH
50122: LD_INT 3
50124: NEG
50125: PUSH
50126: EMPTY
50127: LIST
50128: LIST
50129: PUSH
50130: LD_INT 1
50132: NEG
50133: PUSH
50134: LD_INT 4
50136: NEG
50137: PUSH
50138: EMPTY
50139: LIST
50140: LIST
50141: PUSH
50142: LD_INT 1
50144: NEG
50145: PUSH
50146: LD_INT 5
50148: NEG
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: LD_INT 2
50156: PUSH
50157: LD_INT 3
50159: NEG
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: PUSH
50165: LD_INT 2
50167: NEG
50168: PUSH
50169: LD_INT 5
50171: NEG
50172: PUSH
50173: EMPTY
50174: LIST
50175: LIST
50176: PUSH
50177: LD_INT 3
50179: PUSH
50180: LD_INT 0
50182: PUSH
50183: EMPTY
50184: LIST
50185: LIST
50186: PUSH
50187: LD_INT 3
50189: PUSH
50190: LD_INT 1
50192: NEG
50193: PUSH
50194: EMPTY
50195: LIST
50196: LIST
50197: PUSH
50198: LD_INT 4
50200: PUSH
50201: LD_INT 0
50203: PUSH
50204: EMPTY
50205: LIST
50206: LIST
50207: PUSH
50208: LD_INT 4
50210: PUSH
50211: LD_INT 1
50213: PUSH
50214: EMPTY
50215: LIST
50216: LIST
50217: PUSH
50218: LD_INT 3
50220: PUSH
50221: LD_INT 1
50223: PUSH
50224: EMPTY
50225: LIST
50226: LIST
50227: PUSH
50228: LD_INT 2
50230: PUSH
50231: LD_INT 0
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: LD_INT 2
50240: PUSH
50241: LD_INT 1
50243: NEG
50244: PUSH
50245: EMPTY
50246: LIST
50247: LIST
50248: PUSH
50249: LD_INT 2
50251: PUSH
50252: LD_INT 2
50254: NEG
50255: PUSH
50256: EMPTY
50257: LIST
50258: LIST
50259: PUSH
50260: LD_INT 4
50262: PUSH
50263: LD_INT 2
50265: PUSH
50266: EMPTY
50267: LIST
50268: LIST
50269: PUSH
50270: LD_INT 4
50272: PUSH
50273: LD_INT 4
50275: PUSH
50276: EMPTY
50277: LIST
50278: LIST
50279: PUSH
50280: LD_INT 4
50282: PUSH
50283: LD_INT 3
50285: PUSH
50286: EMPTY
50287: LIST
50288: LIST
50289: PUSH
50290: LD_INT 5
50292: PUSH
50293: LD_INT 4
50295: PUSH
50296: EMPTY
50297: LIST
50298: LIST
50299: PUSH
50300: LD_INT 5
50302: PUSH
50303: LD_INT 5
50305: PUSH
50306: EMPTY
50307: LIST
50308: LIST
50309: PUSH
50310: LD_INT 4
50312: PUSH
50313: LD_INT 5
50315: PUSH
50316: EMPTY
50317: LIST
50318: LIST
50319: PUSH
50320: LD_INT 3
50322: PUSH
50323: LD_INT 4
50325: PUSH
50326: EMPTY
50327: LIST
50328: LIST
50329: PUSH
50330: LD_INT 3
50332: PUSH
50333: LD_INT 3
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: PUSH
50340: LD_INT 5
50342: PUSH
50343: LD_INT 3
50345: PUSH
50346: EMPTY
50347: LIST
50348: LIST
50349: PUSH
50350: LD_INT 3
50352: PUSH
50353: LD_INT 5
50355: PUSH
50356: EMPTY
50357: LIST
50358: LIST
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: LIST
50364: LIST
50365: LIST
50366: LIST
50367: LIST
50368: LIST
50369: LIST
50370: LIST
50371: LIST
50372: LIST
50373: LIST
50374: LIST
50375: LIST
50376: LIST
50377: LIST
50378: LIST
50379: LIST
50380: LIST
50381: LIST
50382: LIST
50383: LIST
50384: LIST
50385: LIST
50386: LIST
50387: LIST
50388: LIST
50389: LIST
50390: LIST
50391: LIST
50392: LIST
50393: LIST
50394: LIST
50395: LIST
50396: LIST
50397: LIST
50398: LIST
50399: LIST
50400: LIST
50401: LIST
50402: LIST
50403: LIST
50404: LIST
50405: LIST
50406: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50407: LD_ADDR_VAR 0 33
50411: PUSH
50412: LD_INT 4
50414: NEG
50415: PUSH
50416: LD_INT 4
50418: NEG
50419: PUSH
50420: EMPTY
50421: LIST
50422: LIST
50423: PUSH
50424: LD_INT 4
50426: NEG
50427: PUSH
50428: LD_INT 5
50430: NEG
50431: PUSH
50432: EMPTY
50433: LIST
50434: LIST
50435: PUSH
50436: LD_INT 3
50438: NEG
50439: PUSH
50440: LD_INT 4
50442: NEG
50443: PUSH
50444: EMPTY
50445: LIST
50446: LIST
50447: PUSH
50448: LD_INT 3
50450: NEG
50451: PUSH
50452: LD_INT 3
50454: NEG
50455: PUSH
50456: EMPTY
50457: LIST
50458: LIST
50459: PUSH
50460: LD_INT 4
50462: NEG
50463: PUSH
50464: LD_INT 3
50466: NEG
50467: PUSH
50468: EMPTY
50469: LIST
50470: LIST
50471: PUSH
50472: LD_INT 5
50474: NEG
50475: PUSH
50476: LD_INT 4
50478: NEG
50479: PUSH
50480: EMPTY
50481: LIST
50482: LIST
50483: PUSH
50484: LD_INT 5
50486: NEG
50487: PUSH
50488: LD_INT 5
50490: NEG
50491: PUSH
50492: EMPTY
50493: LIST
50494: LIST
50495: PUSH
50496: LD_INT 3
50498: NEG
50499: PUSH
50500: LD_INT 5
50502: NEG
50503: PUSH
50504: EMPTY
50505: LIST
50506: LIST
50507: PUSH
50508: LD_INT 5
50510: NEG
50511: PUSH
50512: LD_INT 3
50514: NEG
50515: PUSH
50516: EMPTY
50517: LIST
50518: LIST
50519: PUSH
50520: LD_INT 0
50522: PUSH
50523: LD_INT 3
50525: NEG
50526: PUSH
50527: EMPTY
50528: LIST
50529: LIST
50530: PUSH
50531: LD_INT 0
50533: PUSH
50534: LD_INT 4
50536: NEG
50537: PUSH
50538: EMPTY
50539: LIST
50540: LIST
50541: PUSH
50542: LD_INT 1
50544: PUSH
50545: LD_INT 3
50547: NEG
50548: PUSH
50549: EMPTY
50550: LIST
50551: LIST
50552: PUSH
50553: LD_INT 1
50555: PUSH
50556: LD_INT 2
50558: NEG
50559: PUSH
50560: EMPTY
50561: LIST
50562: LIST
50563: PUSH
50564: LD_INT 0
50566: PUSH
50567: LD_INT 2
50569: NEG
50570: PUSH
50571: EMPTY
50572: LIST
50573: LIST
50574: PUSH
50575: LD_INT 1
50577: NEG
50578: PUSH
50579: LD_INT 3
50581: NEG
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: PUSH
50587: LD_INT 1
50589: NEG
50590: PUSH
50591: LD_INT 4
50593: NEG
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: PUSH
50599: LD_INT 2
50601: PUSH
50602: LD_INT 2
50604: NEG
50605: PUSH
50606: EMPTY
50607: LIST
50608: LIST
50609: PUSH
50610: LD_INT 2
50612: NEG
50613: PUSH
50614: LD_INT 4
50616: NEG
50617: PUSH
50618: EMPTY
50619: LIST
50620: LIST
50621: PUSH
50622: LD_INT 4
50624: PUSH
50625: LD_INT 0
50627: PUSH
50628: EMPTY
50629: LIST
50630: LIST
50631: PUSH
50632: LD_INT 4
50634: PUSH
50635: LD_INT 1
50637: NEG
50638: PUSH
50639: EMPTY
50640: LIST
50641: LIST
50642: PUSH
50643: LD_INT 5
50645: PUSH
50646: LD_INT 0
50648: PUSH
50649: EMPTY
50650: LIST
50651: LIST
50652: PUSH
50653: LD_INT 5
50655: PUSH
50656: LD_INT 1
50658: PUSH
50659: EMPTY
50660: LIST
50661: LIST
50662: PUSH
50663: LD_INT 4
50665: PUSH
50666: LD_INT 1
50668: PUSH
50669: EMPTY
50670: LIST
50671: LIST
50672: PUSH
50673: LD_INT 3
50675: PUSH
50676: LD_INT 0
50678: PUSH
50679: EMPTY
50680: LIST
50681: LIST
50682: PUSH
50683: LD_INT 3
50685: PUSH
50686: LD_INT 1
50688: NEG
50689: PUSH
50690: EMPTY
50691: LIST
50692: LIST
50693: PUSH
50694: LD_INT 3
50696: PUSH
50697: LD_INT 2
50699: NEG
50700: PUSH
50701: EMPTY
50702: LIST
50703: LIST
50704: PUSH
50705: LD_INT 5
50707: PUSH
50708: LD_INT 2
50710: PUSH
50711: EMPTY
50712: LIST
50713: LIST
50714: PUSH
50715: LD_INT 3
50717: PUSH
50718: LD_INT 3
50720: PUSH
50721: EMPTY
50722: LIST
50723: LIST
50724: PUSH
50725: LD_INT 3
50727: PUSH
50728: LD_INT 2
50730: PUSH
50731: EMPTY
50732: LIST
50733: LIST
50734: PUSH
50735: LD_INT 4
50737: PUSH
50738: LD_INT 3
50740: PUSH
50741: EMPTY
50742: LIST
50743: LIST
50744: PUSH
50745: LD_INT 4
50747: PUSH
50748: LD_INT 4
50750: PUSH
50751: EMPTY
50752: LIST
50753: LIST
50754: PUSH
50755: LD_INT 3
50757: PUSH
50758: LD_INT 4
50760: PUSH
50761: EMPTY
50762: LIST
50763: LIST
50764: PUSH
50765: LD_INT 2
50767: PUSH
50768: LD_INT 3
50770: PUSH
50771: EMPTY
50772: LIST
50773: LIST
50774: PUSH
50775: LD_INT 2
50777: PUSH
50778: LD_INT 2
50780: PUSH
50781: EMPTY
50782: LIST
50783: LIST
50784: PUSH
50785: LD_INT 4
50787: PUSH
50788: LD_INT 2
50790: PUSH
50791: EMPTY
50792: LIST
50793: LIST
50794: PUSH
50795: LD_INT 2
50797: PUSH
50798: LD_INT 4
50800: PUSH
50801: EMPTY
50802: LIST
50803: LIST
50804: PUSH
50805: LD_INT 0
50807: PUSH
50808: LD_INT 4
50810: PUSH
50811: EMPTY
50812: LIST
50813: LIST
50814: PUSH
50815: LD_INT 0
50817: PUSH
50818: LD_INT 3
50820: PUSH
50821: EMPTY
50822: LIST
50823: LIST
50824: PUSH
50825: LD_INT 1
50827: PUSH
50828: LD_INT 4
50830: PUSH
50831: EMPTY
50832: LIST
50833: LIST
50834: PUSH
50835: LD_INT 1
50837: PUSH
50838: LD_INT 5
50840: PUSH
50841: EMPTY
50842: LIST
50843: LIST
50844: PUSH
50845: LD_INT 0
50847: PUSH
50848: LD_INT 5
50850: PUSH
50851: EMPTY
50852: LIST
50853: LIST
50854: PUSH
50855: LD_INT 1
50857: NEG
50858: PUSH
50859: LD_INT 4
50861: PUSH
50862: EMPTY
50863: LIST
50864: LIST
50865: PUSH
50866: LD_INT 1
50868: NEG
50869: PUSH
50870: LD_INT 3
50872: PUSH
50873: EMPTY
50874: LIST
50875: LIST
50876: PUSH
50877: LD_INT 2
50879: PUSH
50880: LD_INT 5
50882: PUSH
50883: EMPTY
50884: LIST
50885: LIST
50886: PUSH
50887: LD_INT 2
50889: NEG
50890: PUSH
50891: LD_INT 3
50893: PUSH
50894: EMPTY
50895: LIST
50896: LIST
50897: PUSH
50898: EMPTY
50899: LIST
50900: LIST
50901: LIST
50902: LIST
50903: LIST
50904: LIST
50905: LIST
50906: LIST
50907: LIST
50908: LIST
50909: LIST
50910: LIST
50911: LIST
50912: LIST
50913: LIST
50914: LIST
50915: LIST
50916: LIST
50917: LIST
50918: LIST
50919: LIST
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: LIST
50927: LIST
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: LIST
50933: LIST
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: LIST
50942: LIST
50943: LIST
50944: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50945: LD_ADDR_VAR 0 34
50949: PUSH
50950: LD_INT 0
50952: PUSH
50953: LD_INT 4
50955: NEG
50956: PUSH
50957: EMPTY
50958: LIST
50959: LIST
50960: PUSH
50961: LD_INT 0
50963: PUSH
50964: LD_INT 5
50966: NEG
50967: PUSH
50968: EMPTY
50969: LIST
50970: LIST
50971: PUSH
50972: LD_INT 1
50974: PUSH
50975: LD_INT 4
50977: NEG
50978: PUSH
50979: EMPTY
50980: LIST
50981: LIST
50982: PUSH
50983: LD_INT 1
50985: PUSH
50986: LD_INT 3
50988: NEG
50989: PUSH
50990: EMPTY
50991: LIST
50992: LIST
50993: PUSH
50994: LD_INT 0
50996: PUSH
50997: LD_INT 3
50999: NEG
51000: PUSH
51001: EMPTY
51002: LIST
51003: LIST
51004: PUSH
51005: LD_INT 1
51007: NEG
51008: PUSH
51009: LD_INT 4
51011: NEG
51012: PUSH
51013: EMPTY
51014: LIST
51015: LIST
51016: PUSH
51017: LD_INT 1
51019: NEG
51020: PUSH
51021: LD_INT 5
51023: NEG
51024: PUSH
51025: EMPTY
51026: LIST
51027: LIST
51028: PUSH
51029: LD_INT 2
51031: PUSH
51032: LD_INT 3
51034: NEG
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: PUSH
51040: LD_INT 2
51042: NEG
51043: PUSH
51044: LD_INT 5
51046: NEG
51047: PUSH
51048: EMPTY
51049: LIST
51050: LIST
51051: PUSH
51052: LD_INT 3
51054: PUSH
51055: LD_INT 0
51057: PUSH
51058: EMPTY
51059: LIST
51060: LIST
51061: PUSH
51062: LD_INT 3
51064: PUSH
51065: LD_INT 1
51067: NEG
51068: PUSH
51069: EMPTY
51070: LIST
51071: LIST
51072: PUSH
51073: LD_INT 4
51075: PUSH
51076: LD_INT 0
51078: PUSH
51079: EMPTY
51080: LIST
51081: LIST
51082: PUSH
51083: LD_INT 4
51085: PUSH
51086: LD_INT 1
51088: PUSH
51089: EMPTY
51090: LIST
51091: LIST
51092: PUSH
51093: LD_INT 3
51095: PUSH
51096: LD_INT 1
51098: PUSH
51099: EMPTY
51100: LIST
51101: LIST
51102: PUSH
51103: LD_INT 2
51105: PUSH
51106: LD_INT 0
51108: PUSH
51109: EMPTY
51110: LIST
51111: LIST
51112: PUSH
51113: LD_INT 2
51115: PUSH
51116: LD_INT 1
51118: NEG
51119: PUSH
51120: EMPTY
51121: LIST
51122: LIST
51123: PUSH
51124: LD_INT 2
51126: PUSH
51127: LD_INT 2
51129: NEG
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: PUSH
51135: LD_INT 4
51137: PUSH
51138: LD_INT 2
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: PUSH
51145: LD_INT 4
51147: PUSH
51148: LD_INT 4
51150: PUSH
51151: EMPTY
51152: LIST
51153: LIST
51154: PUSH
51155: LD_INT 4
51157: PUSH
51158: LD_INT 3
51160: PUSH
51161: EMPTY
51162: LIST
51163: LIST
51164: PUSH
51165: LD_INT 5
51167: PUSH
51168: LD_INT 4
51170: PUSH
51171: EMPTY
51172: LIST
51173: LIST
51174: PUSH
51175: LD_INT 5
51177: PUSH
51178: LD_INT 5
51180: PUSH
51181: EMPTY
51182: LIST
51183: LIST
51184: PUSH
51185: LD_INT 4
51187: PUSH
51188: LD_INT 5
51190: PUSH
51191: EMPTY
51192: LIST
51193: LIST
51194: PUSH
51195: LD_INT 3
51197: PUSH
51198: LD_INT 4
51200: PUSH
51201: EMPTY
51202: LIST
51203: LIST
51204: PUSH
51205: LD_INT 3
51207: PUSH
51208: LD_INT 3
51210: PUSH
51211: EMPTY
51212: LIST
51213: LIST
51214: PUSH
51215: LD_INT 5
51217: PUSH
51218: LD_INT 3
51220: PUSH
51221: EMPTY
51222: LIST
51223: LIST
51224: PUSH
51225: LD_INT 3
51227: PUSH
51228: LD_INT 5
51230: PUSH
51231: EMPTY
51232: LIST
51233: LIST
51234: PUSH
51235: LD_INT 0
51237: PUSH
51238: LD_INT 3
51240: PUSH
51241: EMPTY
51242: LIST
51243: LIST
51244: PUSH
51245: LD_INT 0
51247: PUSH
51248: LD_INT 2
51250: PUSH
51251: EMPTY
51252: LIST
51253: LIST
51254: PUSH
51255: LD_INT 1
51257: PUSH
51258: LD_INT 3
51260: PUSH
51261: EMPTY
51262: LIST
51263: LIST
51264: PUSH
51265: LD_INT 1
51267: PUSH
51268: LD_INT 4
51270: PUSH
51271: EMPTY
51272: LIST
51273: LIST
51274: PUSH
51275: LD_INT 0
51277: PUSH
51278: LD_INT 4
51280: PUSH
51281: EMPTY
51282: LIST
51283: LIST
51284: PUSH
51285: LD_INT 1
51287: NEG
51288: PUSH
51289: LD_INT 3
51291: PUSH
51292: EMPTY
51293: LIST
51294: LIST
51295: PUSH
51296: LD_INT 1
51298: NEG
51299: PUSH
51300: LD_INT 2
51302: PUSH
51303: EMPTY
51304: LIST
51305: LIST
51306: PUSH
51307: LD_INT 2
51309: PUSH
51310: LD_INT 4
51312: PUSH
51313: EMPTY
51314: LIST
51315: LIST
51316: PUSH
51317: LD_INT 2
51319: NEG
51320: PUSH
51321: LD_INT 2
51323: PUSH
51324: EMPTY
51325: LIST
51326: LIST
51327: PUSH
51328: LD_INT 4
51330: NEG
51331: PUSH
51332: LD_INT 0
51334: PUSH
51335: EMPTY
51336: LIST
51337: LIST
51338: PUSH
51339: LD_INT 4
51341: NEG
51342: PUSH
51343: LD_INT 1
51345: NEG
51346: PUSH
51347: EMPTY
51348: LIST
51349: LIST
51350: PUSH
51351: LD_INT 3
51353: NEG
51354: PUSH
51355: LD_INT 0
51357: PUSH
51358: EMPTY
51359: LIST
51360: LIST
51361: PUSH
51362: LD_INT 3
51364: NEG
51365: PUSH
51366: LD_INT 1
51368: PUSH
51369: EMPTY
51370: LIST
51371: LIST
51372: PUSH
51373: LD_INT 4
51375: NEG
51376: PUSH
51377: LD_INT 1
51379: PUSH
51380: EMPTY
51381: LIST
51382: LIST
51383: PUSH
51384: LD_INT 5
51386: NEG
51387: PUSH
51388: LD_INT 0
51390: PUSH
51391: EMPTY
51392: LIST
51393: LIST
51394: PUSH
51395: LD_INT 5
51397: NEG
51398: PUSH
51399: LD_INT 1
51401: NEG
51402: PUSH
51403: EMPTY
51404: LIST
51405: LIST
51406: PUSH
51407: LD_INT 5
51409: NEG
51410: PUSH
51411: LD_INT 2
51413: NEG
51414: PUSH
51415: EMPTY
51416: LIST
51417: LIST
51418: PUSH
51419: LD_INT 3
51421: NEG
51422: PUSH
51423: LD_INT 2
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: EMPTY
51431: LIST
51432: LIST
51433: LIST
51434: LIST
51435: LIST
51436: LIST
51437: LIST
51438: LIST
51439: LIST
51440: LIST
51441: LIST
51442: LIST
51443: LIST
51444: LIST
51445: LIST
51446: LIST
51447: LIST
51448: LIST
51449: LIST
51450: LIST
51451: LIST
51452: LIST
51453: LIST
51454: LIST
51455: LIST
51456: LIST
51457: LIST
51458: LIST
51459: LIST
51460: LIST
51461: LIST
51462: LIST
51463: LIST
51464: LIST
51465: LIST
51466: LIST
51467: LIST
51468: LIST
51469: LIST
51470: LIST
51471: LIST
51472: LIST
51473: LIST
51474: LIST
51475: LIST
51476: ST_TO_ADDR
// end ; end ;
51477: GO 51480
51479: POP
// case btype of b_depot , b_warehouse :
51480: LD_VAR 0 1
51484: PUSH
51485: LD_INT 0
51487: DOUBLE
51488: EQUAL
51489: IFTRUE 51499
51491: LD_INT 1
51493: DOUBLE
51494: EQUAL
51495: IFTRUE 51499
51497: GO 51700
51499: POP
// case nation of nation_american :
51500: LD_VAR 0 5
51504: PUSH
51505: LD_INT 1
51507: DOUBLE
51508: EQUAL
51509: IFTRUE 51513
51511: GO 51569
51513: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51514: LD_ADDR_VAR 0 9
51518: PUSH
51519: LD_VAR 0 11
51523: PUSH
51524: LD_VAR 0 12
51528: PUSH
51529: LD_VAR 0 13
51533: PUSH
51534: LD_VAR 0 14
51538: PUSH
51539: LD_VAR 0 15
51543: PUSH
51544: LD_VAR 0 16
51548: PUSH
51549: EMPTY
51550: LIST
51551: LIST
51552: LIST
51553: LIST
51554: LIST
51555: LIST
51556: PUSH
51557: LD_VAR 0 4
51561: PUSH
51562: LD_INT 1
51564: PLUS
51565: ARRAY
51566: ST_TO_ADDR
51567: GO 51698
51569: LD_INT 2
51571: DOUBLE
51572: EQUAL
51573: IFTRUE 51577
51575: GO 51633
51577: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51578: LD_ADDR_VAR 0 9
51582: PUSH
51583: LD_VAR 0 17
51587: PUSH
51588: LD_VAR 0 18
51592: PUSH
51593: LD_VAR 0 19
51597: PUSH
51598: LD_VAR 0 20
51602: PUSH
51603: LD_VAR 0 21
51607: PUSH
51608: LD_VAR 0 22
51612: PUSH
51613: EMPTY
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: PUSH
51621: LD_VAR 0 4
51625: PUSH
51626: LD_INT 1
51628: PLUS
51629: ARRAY
51630: ST_TO_ADDR
51631: GO 51698
51633: LD_INT 3
51635: DOUBLE
51636: EQUAL
51637: IFTRUE 51641
51639: GO 51697
51641: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51642: LD_ADDR_VAR 0 9
51646: PUSH
51647: LD_VAR 0 23
51651: PUSH
51652: LD_VAR 0 24
51656: PUSH
51657: LD_VAR 0 25
51661: PUSH
51662: LD_VAR 0 26
51666: PUSH
51667: LD_VAR 0 27
51671: PUSH
51672: LD_VAR 0 28
51676: PUSH
51677: EMPTY
51678: LIST
51679: LIST
51680: LIST
51681: LIST
51682: LIST
51683: LIST
51684: PUSH
51685: LD_VAR 0 4
51689: PUSH
51690: LD_INT 1
51692: PLUS
51693: ARRAY
51694: ST_TO_ADDR
51695: GO 51698
51697: POP
51698: GO 52253
51700: LD_INT 2
51702: DOUBLE
51703: EQUAL
51704: IFTRUE 51714
51706: LD_INT 3
51708: DOUBLE
51709: EQUAL
51710: IFTRUE 51714
51712: GO 51770
51714: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51715: LD_ADDR_VAR 0 9
51719: PUSH
51720: LD_VAR 0 29
51724: PUSH
51725: LD_VAR 0 30
51729: PUSH
51730: LD_VAR 0 31
51734: PUSH
51735: LD_VAR 0 32
51739: PUSH
51740: LD_VAR 0 33
51744: PUSH
51745: LD_VAR 0 34
51749: PUSH
51750: EMPTY
51751: LIST
51752: LIST
51753: LIST
51754: LIST
51755: LIST
51756: LIST
51757: PUSH
51758: LD_VAR 0 4
51762: PUSH
51763: LD_INT 1
51765: PLUS
51766: ARRAY
51767: ST_TO_ADDR
51768: GO 52253
51770: LD_INT 16
51772: DOUBLE
51773: EQUAL
51774: IFTRUE 51832
51776: LD_INT 17
51778: DOUBLE
51779: EQUAL
51780: IFTRUE 51832
51782: LD_INT 18
51784: DOUBLE
51785: EQUAL
51786: IFTRUE 51832
51788: LD_INT 19
51790: DOUBLE
51791: EQUAL
51792: IFTRUE 51832
51794: LD_INT 22
51796: DOUBLE
51797: EQUAL
51798: IFTRUE 51832
51800: LD_INT 20
51802: DOUBLE
51803: EQUAL
51804: IFTRUE 51832
51806: LD_INT 21
51808: DOUBLE
51809: EQUAL
51810: IFTRUE 51832
51812: LD_INT 23
51814: DOUBLE
51815: EQUAL
51816: IFTRUE 51832
51818: LD_INT 24
51820: DOUBLE
51821: EQUAL
51822: IFTRUE 51832
51824: LD_INT 25
51826: DOUBLE
51827: EQUAL
51828: IFTRUE 51832
51830: GO 51888
51832: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51833: LD_ADDR_VAR 0 9
51837: PUSH
51838: LD_VAR 0 35
51842: PUSH
51843: LD_VAR 0 36
51847: PUSH
51848: LD_VAR 0 37
51852: PUSH
51853: LD_VAR 0 38
51857: PUSH
51858: LD_VAR 0 39
51862: PUSH
51863: LD_VAR 0 40
51867: PUSH
51868: EMPTY
51869: LIST
51870: LIST
51871: LIST
51872: LIST
51873: LIST
51874: LIST
51875: PUSH
51876: LD_VAR 0 4
51880: PUSH
51881: LD_INT 1
51883: PLUS
51884: ARRAY
51885: ST_TO_ADDR
51886: GO 52253
51888: LD_INT 6
51890: DOUBLE
51891: EQUAL
51892: IFTRUE 51944
51894: LD_INT 7
51896: DOUBLE
51897: EQUAL
51898: IFTRUE 51944
51900: LD_INT 8
51902: DOUBLE
51903: EQUAL
51904: IFTRUE 51944
51906: LD_INT 13
51908: DOUBLE
51909: EQUAL
51910: IFTRUE 51944
51912: LD_INT 12
51914: DOUBLE
51915: EQUAL
51916: IFTRUE 51944
51918: LD_INT 15
51920: DOUBLE
51921: EQUAL
51922: IFTRUE 51944
51924: LD_INT 11
51926: DOUBLE
51927: EQUAL
51928: IFTRUE 51944
51930: LD_INT 14
51932: DOUBLE
51933: EQUAL
51934: IFTRUE 51944
51936: LD_INT 10
51938: DOUBLE
51939: EQUAL
51940: IFTRUE 51944
51942: GO 52000
51944: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51945: LD_ADDR_VAR 0 9
51949: PUSH
51950: LD_VAR 0 41
51954: PUSH
51955: LD_VAR 0 42
51959: PUSH
51960: LD_VAR 0 43
51964: PUSH
51965: LD_VAR 0 44
51969: PUSH
51970: LD_VAR 0 45
51974: PUSH
51975: LD_VAR 0 46
51979: PUSH
51980: EMPTY
51981: LIST
51982: LIST
51983: LIST
51984: LIST
51985: LIST
51986: LIST
51987: PUSH
51988: LD_VAR 0 4
51992: PUSH
51993: LD_INT 1
51995: PLUS
51996: ARRAY
51997: ST_TO_ADDR
51998: GO 52253
52000: LD_INT 36
52002: DOUBLE
52003: EQUAL
52004: IFTRUE 52008
52006: GO 52064
52008: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52009: LD_ADDR_VAR 0 9
52013: PUSH
52014: LD_VAR 0 47
52018: PUSH
52019: LD_VAR 0 48
52023: PUSH
52024: LD_VAR 0 49
52028: PUSH
52029: LD_VAR 0 50
52033: PUSH
52034: LD_VAR 0 51
52038: PUSH
52039: LD_VAR 0 52
52043: PUSH
52044: EMPTY
52045: LIST
52046: LIST
52047: LIST
52048: LIST
52049: LIST
52050: LIST
52051: PUSH
52052: LD_VAR 0 4
52056: PUSH
52057: LD_INT 1
52059: PLUS
52060: ARRAY
52061: ST_TO_ADDR
52062: GO 52253
52064: LD_INT 4
52066: DOUBLE
52067: EQUAL
52068: IFTRUE 52090
52070: LD_INT 5
52072: DOUBLE
52073: EQUAL
52074: IFTRUE 52090
52076: LD_INT 34
52078: DOUBLE
52079: EQUAL
52080: IFTRUE 52090
52082: LD_INT 37
52084: DOUBLE
52085: EQUAL
52086: IFTRUE 52090
52088: GO 52146
52090: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52091: LD_ADDR_VAR 0 9
52095: PUSH
52096: LD_VAR 0 53
52100: PUSH
52101: LD_VAR 0 54
52105: PUSH
52106: LD_VAR 0 55
52110: PUSH
52111: LD_VAR 0 56
52115: PUSH
52116: LD_VAR 0 57
52120: PUSH
52121: LD_VAR 0 58
52125: PUSH
52126: EMPTY
52127: LIST
52128: LIST
52129: LIST
52130: LIST
52131: LIST
52132: LIST
52133: PUSH
52134: LD_VAR 0 4
52138: PUSH
52139: LD_INT 1
52141: PLUS
52142: ARRAY
52143: ST_TO_ADDR
52144: GO 52253
52146: LD_INT 31
52148: DOUBLE
52149: EQUAL
52150: IFTRUE 52196
52152: LD_INT 32
52154: DOUBLE
52155: EQUAL
52156: IFTRUE 52196
52158: LD_INT 33
52160: DOUBLE
52161: EQUAL
52162: IFTRUE 52196
52164: LD_INT 27
52166: DOUBLE
52167: EQUAL
52168: IFTRUE 52196
52170: LD_INT 26
52172: DOUBLE
52173: EQUAL
52174: IFTRUE 52196
52176: LD_INT 28
52178: DOUBLE
52179: EQUAL
52180: IFTRUE 52196
52182: LD_INT 29
52184: DOUBLE
52185: EQUAL
52186: IFTRUE 52196
52188: LD_INT 30
52190: DOUBLE
52191: EQUAL
52192: IFTRUE 52196
52194: GO 52252
52196: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52197: LD_ADDR_VAR 0 9
52201: PUSH
52202: LD_VAR 0 59
52206: PUSH
52207: LD_VAR 0 60
52211: PUSH
52212: LD_VAR 0 61
52216: PUSH
52217: LD_VAR 0 62
52221: PUSH
52222: LD_VAR 0 63
52226: PUSH
52227: LD_VAR 0 64
52231: PUSH
52232: EMPTY
52233: LIST
52234: LIST
52235: LIST
52236: LIST
52237: LIST
52238: LIST
52239: PUSH
52240: LD_VAR 0 4
52244: PUSH
52245: LD_INT 1
52247: PLUS
52248: ARRAY
52249: ST_TO_ADDR
52250: GO 52253
52252: POP
// temp_list2 = [ ] ;
52253: LD_ADDR_VAR 0 10
52257: PUSH
52258: EMPTY
52259: ST_TO_ADDR
// for i in temp_list do
52260: LD_ADDR_VAR 0 8
52264: PUSH
52265: LD_VAR 0 9
52269: PUSH
52270: FOR_IN
52271: IFFALSE 52323
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52273: LD_ADDR_VAR 0 10
52277: PUSH
52278: LD_VAR 0 10
52282: PUSH
52283: LD_VAR 0 8
52287: PUSH
52288: LD_INT 1
52290: ARRAY
52291: PUSH
52292: LD_VAR 0 2
52296: PLUS
52297: PUSH
52298: LD_VAR 0 8
52302: PUSH
52303: LD_INT 2
52305: ARRAY
52306: PUSH
52307: LD_VAR 0 3
52311: PLUS
52312: PUSH
52313: EMPTY
52314: LIST
52315: LIST
52316: PUSH
52317: EMPTY
52318: LIST
52319: ADD
52320: ST_TO_ADDR
52321: GO 52270
52323: POP
52324: POP
// result = temp_list2 ;
52325: LD_ADDR_VAR 0 7
52329: PUSH
52330: LD_VAR 0 10
52334: ST_TO_ADDR
// end ;
52335: LD_VAR 0 7
52339: RET
// export function EnemyInRange ( unit , dist ) ; begin
52340: LD_INT 0
52342: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52343: LD_ADDR_VAR 0 3
52347: PUSH
52348: LD_VAR 0 1
52352: PPUSH
52353: CALL_OW 255
52357: PPUSH
52358: LD_VAR 0 1
52362: PPUSH
52363: CALL_OW 250
52367: PPUSH
52368: LD_VAR 0 1
52372: PPUSH
52373: CALL_OW 251
52377: PPUSH
52378: LD_VAR 0 2
52382: PPUSH
52383: CALL 25742 0 4
52387: PUSH
52388: LD_INT 4
52390: ARRAY
52391: ST_TO_ADDR
// end ;
52392: LD_VAR 0 3
52396: RET
// export function PlayerSeeMe ( unit ) ; begin
52397: LD_INT 0
52399: PPUSH
// result := See ( your_side , unit ) ;
52400: LD_ADDR_VAR 0 2
52404: PUSH
52405: LD_OWVAR 2
52409: PPUSH
52410: LD_VAR 0 1
52414: PPUSH
52415: CALL_OW 292
52419: ST_TO_ADDR
// end ;
52420: LD_VAR 0 2
52424: RET
// export function ReverseDir ( unit ) ; begin
52425: LD_INT 0
52427: PPUSH
// if not unit then
52428: LD_VAR 0 1
52432: NOT
52433: IFFALSE 52437
// exit ;
52435: GO 52460
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52437: LD_ADDR_VAR 0 2
52441: PUSH
52442: LD_VAR 0 1
52446: PPUSH
52447: CALL_OW 254
52451: PUSH
52452: LD_INT 3
52454: PLUS
52455: PUSH
52456: LD_INT 6
52458: MOD
52459: ST_TO_ADDR
// end ;
52460: LD_VAR 0 2
52464: RET
// export function ReverseArray ( array ) ; var i ; begin
52465: LD_INT 0
52467: PPUSH
52468: PPUSH
// if not array then
52469: LD_VAR 0 1
52473: NOT
52474: IFFALSE 52478
// exit ;
52476: GO 52533
// result := [ ] ;
52478: LD_ADDR_VAR 0 2
52482: PUSH
52483: EMPTY
52484: ST_TO_ADDR
// for i := array downto 1 do
52485: LD_ADDR_VAR 0 3
52489: PUSH
52490: DOUBLE
52491: LD_VAR 0 1
52495: INC
52496: ST_TO_ADDR
52497: LD_INT 1
52499: PUSH
52500: FOR_DOWNTO
52501: IFFALSE 52531
// result := Join ( result , array [ i ] ) ;
52503: LD_ADDR_VAR 0 2
52507: PUSH
52508: LD_VAR 0 2
52512: PPUSH
52513: LD_VAR 0 1
52517: PUSH
52518: LD_VAR 0 3
52522: ARRAY
52523: PPUSH
52524: CALL 57176 0 2
52528: ST_TO_ADDR
52529: GO 52500
52531: POP
52532: POP
// end ;
52533: LD_VAR 0 2
52537: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52538: LD_INT 0
52540: PPUSH
52541: PPUSH
52542: PPUSH
52543: PPUSH
52544: PPUSH
52545: PPUSH
// if not unit or not hexes then
52546: LD_VAR 0 1
52550: NOT
52551: PUSH
52552: LD_VAR 0 2
52556: NOT
52557: OR
52558: IFFALSE 52562
// exit ;
52560: GO 52685
// dist := 9999 ;
52562: LD_ADDR_VAR 0 5
52566: PUSH
52567: LD_INT 9999
52569: ST_TO_ADDR
// for i = 1 to hexes do
52570: LD_ADDR_VAR 0 4
52574: PUSH
52575: DOUBLE
52576: LD_INT 1
52578: DEC
52579: ST_TO_ADDR
52580: LD_VAR 0 2
52584: PUSH
52585: FOR_TO
52586: IFFALSE 52673
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52588: LD_ADDR_VAR 0 6
52592: PUSH
52593: LD_VAR 0 1
52597: PPUSH
52598: LD_VAR 0 2
52602: PUSH
52603: LD_VAR 0 4
52607: ARRAY
52608: PUSH
52609: LD_INT 1
52611: ARRAY
52612: PPUSH
52613: LD_VAR 0 2
52617: PUSH
52618: LD_VAR 0 4
52622: ARRAY
52623: PUSH
52624: LD_INT 2
52626: ARRAY
52627: PPUSH
52628: CALL_OW 297
52632: ST_TO_ADDR
// if tdist < dist then
52633: LD_VAR 0 6
52637: PUSH
52638: LD_VAR 0 5
52642: LESS
52643: IFFALSE 52671
// begin hex := hexes [ i ] ;
52645: LD_ADDR_VAR 0 8
52649: PUSH
52650: LD_VAR 0 2
52654: PUSH
52655: LD_VAR 0 4
52659: ARRAY
52660: ST_TO_ADDR
// dist := tdist ;
52661: LD_ADDR_VAR 0 5
52665: PUSH
52666: LD_VAR 0 6
52670: ST_TO_ADDR
// end ; end ;
52671: GO 52585
52673: POP
52674: POP
// result := hex ;
52675: LD_ADDR_VAR 0 3
52679: PUSH
52680: LD_VAR 0 8
52684: ST_TO_ADDR
// end ;
52685: LD_VAR 0 3
52689: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52690: LD_INT 0
52692: PPUSH
52693: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52694: LD_VAR 0 1
52698: NOT
52699: PUSH
52700: LD_VAR 0 1
52704: PUSH
52705: LD_INT 21
52707: PUSH
52708: LD_INT 2
52710: PUSH
52711: EMPTY
52712: LIST
52713: LIST
52714: PUSH
52715: LD_INT 23
52717: PUSH
52718: LD_INT 2
52720: PUSH
52721: EMPTY
52722: LIST
52723: LIST
52724: PUSH
52725: EMPTY
52726: LIST
52727: LIST
52728: PPUSH
52729: CALL_OW 69
52733: IN
52734: NOT
52735: OR
52736: IFFALSE 52740
// exit ;
52738: GO 52787
// for i = 1 to 3 do
52740: LD_ADDR_VAR 0 3
52744: PUSH
52745: DOUBLE
52746: LD_INT 1
52748: DEC
52749: ST_TO_ADDR
52750: LD_INT 3
52752: PUSH
52753: FOR_TO
52754: IFFALSE 52785
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52756: LD_VAR 0 1
52760: PPUSH
52761: CALL_OW 250
52765: PPUSH
52766: LD_VAR 0 1
52770: PPUSH
52771: CALL_OW 251
52775: PPUSH
52776: LD_INT 1
52778: PPUSH
52779: CALL_OW 453
52783: GO 52753
52785: POP
52786: POP
// end ;
52787: LD_VAR 0 2
52791: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52792: LD_INT 0
52794: PPUSH
52795: PPUSH
52796: PPUSH
52797: PPUSH
52798: PPUSH
52799: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52800: LD_VAR 0 1
52804: NOT
52805: PUSH
52806: LD_VAR 0 2
52810: NOT
52811: OR
52812: PUSH
52813: LD_VAR 0 1
52817: PPUSH
52818: CALL_OW 314
52822: OR
52823: IFFALSE 52827
// exit ;
52825: GO 53294
// if GetLives ( i ) < 250 then
52827: LD_VAR 0 4
52831: PPUSH
52832: CALL_OW 256
52836: PUSH
52837: LD_INT 250
52839: LESS
52840: IFFALSE 52853
// begin ComAutodestruct ( i ) ;
52842: LD_VAR 0 4
52846: PPUSH
52847: CALL 52690 0 1
// exit ;
52851: GO 53294
// end ; x := GetX ( enemy_unit ) ;
52853: LD_ADDR_VAR 0 7
52857: PUSH
52858: LD_VAR 0 2
52862: PPUSH
52863: CALL_OW 250
52867: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52868: LD_ADDR_VAR 0 8
52872: PUSH
52873: LD_VAR 0 2
52877: PPUSH
52878: CALL_OW 251
52882: ST_TO_ADDR
// if not x or not y then
52883: LD_VAR 0 7
52887: NOT
52888: PUSH
52889: LD_VAR 0 8
52893: NOT
52894: OR
52895: IFFALSE 52899
// exit ;
52897: GO 53294
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52899: LD_ADDR_VAR 0 6
52903: PUSH
52904: LD_VAR 0 7
52908: PPUSH
52909: LD_INT 0
52911: PPUSH
52912: LD_INT 4
52914: PPUSH
52915: CALL_OW 272
52919: PUSH
52920: LD_VAR 0 8
52924: PPUSH
52925: LD_INT 0
52927: PPUSH
52928: LD_INT 4
52930: PPUSH
52931: CALL_OW 273
52935: PUSH
52936: EMPTY
52937: LIST
52938: LIST
52939: PUSH
52940: LD_VAR 0 7
52944: PPUSH
52945: LD_INT 1
52947: PPUSH
52948: LD_INT 4
52950: PPUSH
52951: CALL_OW 272
52955: PUSH
52956: LD_VAR 0 8
52960: PPUSH
52961: LD_INT 1
52963: PPUSH
52964: LD_INT 4
52966: PPUSH
52967: CALL_OW 273
52971: PUSH
52972: EMPTY
52973: LIST
52974: LIST
52975: PUSH
52976: LD_VAR 0 7
52980: PPUSH
52981: LD_INT 2
52983: PPUSH
52984: LD_INT 4
52986: PPUSH
52987: CALL_OW 272
52991: PUSH
52992: LD_VAR 0 8
52996: PPUSH
52997: LD_INT 2
52999: PPUSH
53000: LD_INT 4
53002: PPUSH
53003: CALL_OW 273
53007: PUSH
53008: EMPTY
53009: LIST
53010: LIST
53011: PUSH
53012: LD_VAR 0 7
53016: PPUSH
53017: LD_INT 3
53019: PPUSH
53020: LD_INT 4
53022: PPUSH
53023: CALL_OW 272
53027: PUSH
53028: LD_VAR 0 8
53032: PPUSH
53033: LD_INT 3
53035: PPUSH
53036: LD_INT 4
53038: PPUSH
53039: CALL_OW 273
53043: PUSH
53044: EMPTY
53045: LIST
53046: LIST
53047: PUSH
53048: LD_VAR 0 7
53052: PPUSH
53053: LD_INT 4
53055: PPUSH
53056: LD_INT 4
53058: PPUSH
53059: CALL_OW 272
53063: PUSH
53064: LD_VAR 0 8
53068: PPUSH
53069: LD_INT 4
53071: PPUSH
53072: LD_INT 4
53074: PPUSH
53075: CALL_OW 273
53079: PUSH
53080: EMPTY
53081: LIST
53082: LIST
53083: PUSH
53084: LD_VAR 0 7
53088: PPUSH
53089: LD_INT 5
53091: PPUSH
53092: LD_INT 4
53094: PPUSH
53095: CALL_OW 272
53099: PUSH
53100: LD_VAR 0 8
53104: PPUSH
53105: LD_INT 5
53107: PPUSH
53108: LD_INT 4
53110: PPUSH
53111: CALL_OW 273
53115: PUSH
53116: EMPTY
53117: LIST
53118: LIST
53119: PUSH
53120: EMPTY
53121: LIST
53122: LIST
53123: LIST
53124: LIST
53125: LIST
53126: LIST
53127: ST_TO_ADDR
// for i = tmp downto 1 do
53128: LD_ADDR_VAR 0 4
53132: PUSH
53133: DOUBLE
53134: LD_VAR 0 6
53138: INC
53139: ST_TO_ADDR
53140: LD_INT 1
53142: PUSH
53143: FOR_DOWNTO
53144: IFFALSE 53245
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53146: LD_VAR 0 6
53150: PUSH
53151: LD_VAR 0 4
53155: ARRAY
53156: PUSH
53157: LD_INT 1
53159: ARRAY
53160: PPUSH
53161: LD_VAR 0 6
53165: PUSH
53166: LD_VAR 0 4
53170: ARRAY
53171: PUSH
53172: LD_INT 2
53174: ARRAY
53175: PPUSH
53176: CALL_OW 488
53180: NOT
53181: PUSH
53182: LD_VAR 0 6
53186: PUSH
53187: LD_VAR 0 4
53191: ARRAY
53192: PUSH
53193: LD_INT 1
53195: ARRAY
53196: PPUSH
53197: LD_VAR 0 6
53201: PUSH
53202: LD_VAR 0 4
53206: ARRAY
53207: PUSH
53208: LD_INT 2
53210: ARRAY
53211: PPUSH
53212: CALL_OW 428
53216: PUSH
53217: LD_INT 0
53219: NONEQUAL
53220: OR
53221: IFFALSE 53243
// tmp := Delete ( tmp , i ) ;
53223: LD_ADDR_VAR 0 6
53227: PUSH
53228: LD_VAR 0 6
53232: PPUSH
53233: LD_VAR 0 4
53237: PPUSH
53238: CALL_OW 3
53242: ST_TO_ADDR
53243: GO 53143
53245: POP
53246: POP
// j := GetClosestHex ( unit , tmp ) ;
53247: LD_ADDR_VAR 0 5
53251: PUSH
53252: LD_VAR 0 1
53256: PPUSH
53257: LD_VAR 0 6
53261: PPUSH
53262: CALL 52538 0 2
53266: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53267: LD_VAR 0 1
53271: PPUSH
53272: LD_VAR 0 5
53276: PUSH
53277: LD_INT 1
53279: ARRAY
53280: PPUSH
53281: LD_VAR 0 5
53285: PUSH
53286: LD_INT 2
53288: ARRAY
53289: PPUSH
53290: CALL_OW 111
// end ;
53294: LD_VAR 0 3
53298: RET
// export function PrepareApemanSoldier ( ) ; begin
53299: LD_INT 0
53301: PPUSH
// uc_nation := 0 ;
53302: LD_ADDR_OWVAR 21
53306: PUSH
53307: LD_INT 0
53309: ST_TO_ADDR
// hc_sex := sex_male ;
53310: LD_ADDR_OWVAR 27
53314: PUSH
53315: LD_INT 1
53317: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
53318: LD_ADDR_OWVAR 28
53322: PUSH
53323: LD_INT 15
53325: ST_TO_ADDR
// hc_gallery :=  ;
53326: LD_ADDR_OWVAR 33
53330: PUSH
53331: LD_STRING 
53333: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53334: LD_ADDR_OWVAR 31
53338: PUSH
53339: LD_INT 0
53341: PPUSH
53342: LD_INT 3
53344: PPUSH
53345: CALL_OW 12
53349: PUSH
53350: LD_INT 0
53352: PPUSH
53353: LD_INT 3
53355: PPUSH
53356: CALL_OW 12
53360: PUSH
53361: LD_INT 0
53363: PUSH
53364: LD_INT 0
53366: PUSH
53367: EMPTY
53368: LIST
53369: LIST
53370: LIST
53371: LIST
53372: ST_TO_ADDR
// end ;
53373: LD_VAR 0 1
53377: RET
// export function PrepareApemanEngineer ( ) ; begin
53378: LD_INT 0
53380: PPUSH
// uc_nation := 0 ;
53381: LD_ADDR_OWVAR 21
53385: PUSH
53386: LD_INT 0
53388: ST_TO_ADDR
// hc_sex := sex_male ;
53389: LD_ADDR_OWVAR 27
53393: PUSH
53394: LD_INT 1
53396: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
53397: LD_ADDR_OWVAR 28
53401: PUSH
53402: LD_INT 16
53404: ST_TO_ADDR
// hc_gallery :=  ;
53405: LD_ADDR_OWVAR 33
53409: PUSH
53410: LD_STRING 
53412: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53413: LD_ADDR_OWVAR 31
53417: PUSH
53418: LD_INT 0
53420: PPUSH
53421: LD_INT 3
53423: PPUSH
53424: CALL_OW 12
53428: PUSH
53429: LD_INT 0
53431: PPUSH
53432: LD_INT 3
53434: PPUSH
53435: CALL_OW 12
53439: PUSH
53440: LD_INT 0
53442: PUSH
53443: LD_INT 0
53445: PUSH
53446: EMPTY
53447: LIST
53448: LIST
53449: LIST
53450: LIST
53451: ST_TO_ADDR
// end ;
53452: LD_VAR 0 1
53456: RET
// export function PrepareApeman ( agressivity ) ; begin
53457: LD_INT 0
53459: PPUSH
// uc_side := 0 ;
53460: LD_ADDR_OWVAR 20
53464: PUSH
53465: LD_INT 0
53467: ST_TO_ADDR
// uc_nation := 0 ;
53468: LD_ADDR_OWVAR 21
53472: PUSH
53473: LD_INT 0
53475: ST_TO_ADDR
// hc_sex := sex_male ;
53476: LD_ADDR_OWVAR 27
53480: PUSH
53481: LD_INT 1
53483: ST_TO_ADDR
// hc_class := class_apeman ;
53484: LD_ADDR_OWVAR 28
53488: PUSH
53489: LD_INT 12
53491: ST_TO_ADDR
// hc_gallery :=  ;
53492: LD_ADDR_OWVAR 33
53496: PUSH
53497: LD_STRING 
53499: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53500: LD_ADDR_OWVAR 35
53504: PUSH
53505: LD_VAR 0 1
53509: NEG
53510: PPUSH
53511: LD_VAR 0 1
53515: PPUSH
53516: CALL_OW 12
53520: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53521: LD_ADDR_OWVAR 31
53525: PUSH
53526: LD_INT 0
53528: PPUSH
53529: LD_INT 3
53531: PPUSH
53532: CALL_OW 12
53536: PUSH
53537: LD_INT 0
53539: PPUSH
53540: LD_INT 3
53542: PPUSH
53543: CALL_OW 12
53547: PUSH
53548: LD_INT 0
53550: PUSH
53551: LD_INT 0
53553: PUSH
53554: EMPTY
53555: LIST
53556: LIST
53557: LIST
53558: LIST
53559: ST_TO_ADDR
// end ;
53560: LD_VAR 0 2
53564: RET
// export function PrepareTiger ( agressivity ) ; begin
53565: LD_INT 0
53567: PPUSH
// uc_side := 0 ;
53568: LD_ADDR_OWVAR 20
53572: PUSH
53573: LD_INT 0
53575: ST_TO_ADDR
// uc_nation := 0 ;
53576: LD_ADDR_OWVAR 21
53580: PUSH
53581: LD_INT 0
53583: ST_TO_ADDR
// hc_class := class_tiger ;
53584: LD_ADDR_OWVAR 28
53588: PUSH
53589: LD_INT 14
53591: ST_TO_ADDR
// hc_gallery :=  ;
53592: LD_ADDR_OWVAR 33
53596: PUSH
53597: LD_STRING 
53599: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53600: LD_ADDR_OWVAR 35
53604: PUSH
53605: LD_VAR 0 1
53609: NEG
53610: PPUSH
53611: LD_VAR 0 1
53615: PPUSH
53616: CALL_OW 12
53620: ST_TO_ADDR
// end ;
53621: LD_VAR 0 2
53625: RET
// export function PrepareEnchidna ( ) ; begin
53626: LD_INT 0
53628: PPUSH
// uc_side := 0 ;
53629: LD_ADDR_OWVAR 20
53633: PUSH
53634: LD_INT 0
53636: ST_TO_ADDR
// uc_nation := 0 ;
53637: LD_ADDR_OWVAR 21
53641: PUSH
53642: LD_INT 0
53644: ST_TO_ADDR
// hc_class := class_baggie ;
53645: LD_ADDR_OWVAR 28
53649: PUSH
53650: LD_INT 13
53652: ST_TO_ADDR
// hc_gallery :=  ;
53653: LD_ADDR_OWVAR 33
53657: PUSH
53658: LD_STRING 
53660: ST_TO_ADDR
// end ;
53661: LD_VAR 0 1
53665: RET
// export function PrepareFrog ( ) ; begin
53666: LD_INT 0
53668: PPUSH
// uc_side := 0 ;
53669: LD_ADDR_OWVAR 20
53673: PUSH
53674: LD_INT 0
53676: ST_TO_ADDR
// uc_nation := 0 ;
53677: LD_ADDR_OWVAR 21
53681: PUSH
53682: LD_INT 0
53684: ST_TO_ADDR
// hc_class := class_frog ;
53685: LD_ADDR_OWVAR 28
53689: PUSH
53690: LD_INT 19
53692: ST_TO_ADDR
// hc_gallery :=  ;
53693: LD_ADDR_OWVAR 33
53697: PUSH
53698: LD_STRING 
53700: ST_TO_ADDR
// end ;
53701: LD_VAR 0 1
53705: RET
// export function PrepareFish ( ) ; begin
53706: LD_INT 0
53708: PPUSH
// uc_side := 0 ;
53709: LD_ADDR_OWVAR 20
53713: PUSH
53714: LD_INT 0
53716: ST_TO_ADDR
// uc_nation := 0 ;
53717: LD_ADDR_OWVAR 21
53721: PUSH
53722: LD_INT 0
53724: ST_TO_ADDR
// hc_class := class_fish ;
53725: LD_ADDR_OWVAR 28
53729: PUSH
53730: LD_INT 20
53732: ST_TO_ADDR
// hc_gallery :=  ;
53733: LD_ADDR_OWVAR 33
53737: PUSH
53738: LD_STRING 
53740: ST_TO_ADDR
// end ;
53741: LD_VAR 0 1
53745: RET
// export function PrepareBird ( ) ; begin
53746: LD_INT 0
53748: PPUSH
// uc_side := 0 ;
53749: LD_ADDR_OWVAR 20
53753: PUSH
53754: LD_INT 0
53756: ST_TO_ADDR
// uc_nation := 0 ;
53757: LD_ADDR_OWVAR 21
53761: PUSH
53762: LD_INT 0
53764: ST_TO_ADDR
// hc_class := class_phororhacos ;
53765: LD_ADDR_OWVAR 28
53769: PUSH
53770: LD_INT 18
53772: ST_TO_ADDR
// hc_gallery :=  ;
53773: LD_ADDR_OWVAR 33
53777: PUSH
53778: LD_STRING 
53780: ST_TO_ADDR
// end ;
53781: LD_VAR 0 1
53785: RET
// export function PrepareHorse ( ) ; begin
53786: LD_INT 0
53788: PPUSH
// uc_side := 0 ;
53789: LD_ADDR_OWVAR 20
53793: PUSH
53794: LD_INT 0
53796: ST_TO_ADDR
// uc_nation := 0 ;
53797: LD_ADDR_OWVAR 21
53801: PUSH
53802: LD_INT 0
53804: ST_TO_ADDR
// hc_class := class_horse ;
53805: LD_ADDR_OWVAR 28
53809: PUSH
53810: LD_INT 21
53812: ST_TO_ADDR
// hc_gallery :=  ;
53813: LD_ADDR_OWVAR 33
53817: PUSH
53818: LD_STRING 
53820: ST_TO_ADDR
// end ;
53821: LD_VAR 0 1
53825: RET
// export function PrepareMastodont ( ) ; begin
53826: LD_INT 0
53828: PPUSH
// uc_side := 0 ;
53829: LD_ADDR_OWVAR 20
53833: PUSH
53834: LD_INT 0
53836: ST_TO_ADDR
// uc_nation := 0 ;
53837: LD_ADDR_OWVAR 21
53841: PUSH
53842: LD_INT 0
53844: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53845: LD_ADDR_OWVAR 37
53849: PUSH
53850: LD_INT 31
53852: ST_TO_ADDR
// vc_control := control_rider ;
53853: LD_ADDR_OWVAR 38
53857: PUSH
53858: LD_INT 4
53860: ST_TO_ADDR
// end ;
53861: LD_VAR 0 1
53865: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53866: LD_INT 0
53868: PPUSH
53869: PPUSH
53870: PPUSH
// uc_side = 0 ;
53871: LD_ADDR_OWVAR 20
53875: PUSH
53876: LD_INT 0
53878: ST_TO_ADDR
// uc_nation = 0 ;
53879: LD_ADDR_OWVAR 21
53883: PUSH
53884: LD_INT 0
53886: ST_TO_ADDR
// InitHc_All ( ) ;
53887: CALL_OW 584
// InitVc ;
53891: CALL_OW 20
// if mastodonts then
53895: LD_VAR 0 6
53899: IFFALSE 53966
// for i = 1 to mastodonts do
53901: LD_ADDR_VAR 0 11
53905: PUSH
53906: DOUBLE
53907: LD_INT 1
53909: DEC
53910: ST_TO_ADDR
53911: LD_VAR 0 6
53915: PUSH
53916: FOR_TO
53917: IFFALSE 53964
// begin vc_chassis := 31 ;
53919: LD_ADDR_OWVAR 37
53923: PUSH
53924: LD_INT 31
53926: ST_TO_ADDR
// vc_control := control_rider ;
53927: LD_ADDR_OWVAR 38
53931: PUSH
53932: LD_INT 4
53934: ST_TO_ADDR
// animal := CreateVehicle ;
53935: LD_ADDR_VAR 0 12
53939: PUSH
53940: CALL_OW 45
53944: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53945: LD_VAR 0 12
53949: PPUSH
53950: LD_VAR 0 8
53954: PPUSH
53955: LD_INT 0
53957: PPUSH
53958: CALL 56094 0 3
// end ;
53962: GO 53916
53964: POP
53965: POP
// if horses then
53966: LD_VAR 0 5
53970: IFFALSE 54037
// for i = 1 to horses do
53972: LD_ADDR_VAR 0 11
53976: PUSH
53977: DOUBLE
53978: LD_INT 1
53980: DEC
53981: ST_TO_ADDR
53982: LD_VAR 0 5
53986: PUSH
53987: FOR_TO
53988: IFFALSE 54035
// begin hc_class := 21 ;
53990: LD_ADDR_OWVAR 28
53994: PUSH
53995: LD_INT 21
53997: ST_TO_ADDR
// hc_gallery :=  ;
53998: LD_ADDR_OWVAR 33
54002: PUSH
54003: LD_STRING 
54005: ST_TO_ADDR
// animal := CreateHuman ;
54006: LD_ADDR_VAR 0 12
54010: PUSH
54011: CALL_OW 44
54015: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54016: LD_VAR 0 12
54020: PPUSH
54021: LD_VAR 0 8
54025: PPUSH
54026: LD_INT 0
54028: PPUSH
54029: CALL 56094 0 3
// end ;
54033: GO 53987
54035: POP
54036: POP
// if birds then
54037: LD_VAR 0 1
54041: IFFALSE 54108
// for i = 1 to birds do
54043: LD_ADDR_VAR 0 11
54047: PUSH
54048: DOUBLE
54049: LD_INT 1
54051: DEC
54052: ST_TO_ADDR
54053: LD_VAR 0 1
54057: PUSH
54058: FOR_TO
54059: IFFALSE 54106
// begin hc_class = 18 ;
54061: LD_ADDR_OWVAR 28
54065: PUSH
54066: LD_INT 18
54068: ST_TO_ADDR
// hc_gallery =  ;
54069: LD_ADDR_OWVAR 33
54073: PUSH
54074: LD_STRING 
54076: ST_TO_ADDR
// animal := CreateHuman ;
54077: LD_ADDR_VAR 0 12
54081: PUSH
54082: CALL_OW 44
54086: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54087: LD_VAR 0 12
54091: PPUSH
54092: LD_VAR 0 8
54096: PPUSH
54097: LD_INT 0
54099: PPUSH
54100: CALL 56094 0 3
// end ;
54104: GO 54058
54106: POP
54107: POP
// if tigers then
54108: LD_VAR 0 2
54112: IFFALSE 54196
// for i = 1 to tigers do
54114: LD_ADDR_VAR 0 11
54118: PUSH
54119: DOUBLE
54120: LD_INT 1
54122: DEC
54123: ST_TO_ADDR
54124: LD_VAR 0 2
54128: PUSH
54129: FOR_TO
54130: IFFALSE 54194
// begin hc_class = class_tiger ;
54132: LD_ADDR_OWVAR 28
54136: PUSH
54137: LD_INT 14
54139: ST_TO_ADDR
// hc_gallery =  ;
54140: LD_ADDR_OWVAR 33
54144: PUSH
54145: LD_STRING 
54147: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
54148: LD_ADDR_OWVAR 35
54152: PUSH
54153: LD_INT 7
54155: NEG
54156: PPUSH
54157: LD_INT 7
54159: PPUSH
54160: CALL_OW 12
54164: ST_TO_ADDR
// animal := CreateHuman ;
54165: LD_ADDR_VAR 0 12
54169: PUSH
54170: CALL_OW 44
54174: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54175: LD_VAR 0 12
54179: PPUSH
54180: LD_VAR 0 8
54184: PPUSH
54185: LD_INT 0
54187: PPUSH
54188: CALL 56094 0 3
// end ;
54192: GO 54129
54194: POP
54195: POP
// if apemans then
54196: LD_VAR 0 3
54200: IFFALSE 54323
// for i = 1 to apemans do
54202: LD_ADDR_VAR 0 11
54206: PUSH
54207: DOUBLE
54208: LD_INT 1
54210: DEC
54211: ST_TO_ADDR
54212: LD_VAR 0 3
54216: PUSH
54217: FOR_TO
54218: IFFALSE 54321
// begin hc_class = class_apeman ;
54220: LD_ADDR_OWVAR 28
54224: PUSH
54225: LD_INT 12
54227: ST_TO_ADDR
// hc_gallery =  ;
54228: LD_ADDR_OWVAR 33
54232: PUSH
54233: LD_STRING 
54235: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
54236: LD_ADDR_OWVAR 35
54240: PUSH
54241: LD_INT 2
54243: NEG
54244: PPUSH
54245: LD_INT 2
54247: PPUSH
54248: CALL_OW 12
54252: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
54253: LD_ADDR_OWVAR 31
54257: PUSH
54258: LD_INT 1
54260: PPUSH
54261: LD_INT 3
54263: PPUSH
54264: CALL_OW 12
54268: PUSH
54269: LD_INT 1
54271: PPUSH
54272: LD_INT 3
54274: PPUSH
54275: CALL_OW 12
54279: PUSH
54280: LD_INT 0
54282: PUSH
54283: LD_INT 0
54285: PUSH
54286: EMPTY
54287: LIST
54288: LIST
54289: LIST
54290: LIST
54291: ST_TO_ADDR
// animal := CreateHuman ;
54292: LD_ADDR_VAR 0 12
54296: PUSH
54297: CALL_OW 44
54301: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54302: LD_VAR 0 12
54306: PPUSH
54307: LD_VAR 0 8
54311: PPUSH
54312: LD_INT 0
54314: PPUSH
54315: CALL 56094 0 3
// end ;
54319: GO 54217
54321: POP
54322: POP
// if enchidnas then
54323: LD_VAR 0 4
54327: IFFALSE 54394
// for i = 1 to enchidnas do
54329: LD_ADDR_VAR 0 11
54333: PUSH
54334: DOUBLE
54335: LD_INT 1
54337: DEC
54338: ST_TO_ADDR
54339: LD_VAR 0 4
54343: PUSH
54344: FOR_TO
54345: IFFALSE 54392
// begin hc_class = 13 ;
54347: LD_ADDR_OWVAR 28
54351: PUSH
54352: LD_INT 13
54354: ST_TO_ADDR
// hc_gallery =  ;
54355: LD_ADDR_OWVAR 33
54359: PUSH
54360: LD_STRING 
54362: ST_TO_ADDR
// animal := CreateHuman ;
54363: LD_ADDR_VAR 0 12
54367: PUSH
54368: CALL_OW 44
54372: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54373: LD_VAR 0 12
54377: PPUSH
54378: LD_VAR 0 8
54382: PPUSH
54383: LD_INT 0
54385: PPUSH
54386: CALL 56094 0 3
// end ;
54390: GO 54344
54392: POP
54393: POP
// if fishes then
54394: LD_VAR 0 7
54398: IFFALSE 54465
// for i = 1 to fishes do
54400: LD_ADDR_VAR 0 11
54404: PUSH
54405: DOUBLE
54406: LD_INT 1
54408: DEC
54409: ST_TO_ADDR
54410: LD_VAR 0 7
54414: PUSH
54415: FOR_TO
54416: IFFALSE 54463
// begin hc_class = 20 ;
54418: LD_ADDR_OWVAR 28
54422: PUSH
54423: LD_INT 20
54425: ST_TO_ADDR
// hc_gallery =  ;
54426: LD_ADDR_OWVAR 33
54430: PUSH
54431: LD_STRING 
54433: ST_TO_ADDR
// animal := CreateHuman ;
54434: LD_ADDR_VAR 0 12
54438: PUSH
54439: CALL_OW 44
54443: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
54444: LD_VAR 0 12
54448: PPUSH
54449: LD_VAR 0 9
54453: PPUSH
54454: LD_INT 0
54456: PPUSH
54457: CALL 56094 0 3
// end ;
54461: GO 54415
54463: POP
54464: POP
// end ;
54465: LD_VAR 0 10
54469: RET
// export function WantHeal ( sci , unit ) ; begin
54470: LD_INT 0
54472: PPUSH
// if GetTaskList ( sci ) > 0 then
54473: LD_VAR 0 1
54477: PPUSH
54478: CALL_OW 437
54482: PUSH
54483: LD_INT 0
54485: GREATER
54486: IFFALSE 54556
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54488: LD_VAR 0 1
54492: PPUSH
54493: CALL_OW 437
54497: PUSH
54498: LD_INT 1
54500: ARRAY
54501: PUSH
54502: LD_INT 1
54504: ARRAY
54505: PUSH
54506: LD_STRING l
54508: EQUAL
54509: PUSH
54510: LD_VAR 0 1
54514: PPUSH
54515: CALL_OW 437
54519: PUSH
54520: LD_INT 1
54522: ARRAY
54523: PUSH
54524: LD_INT 4
54526: ARRAY
54527: PUSH
54528: LD_VAR 0 2
54532: EQUAL
54533: AND
54534: IFFALSE 54546
// result := true else
54536: LD_ADDR_VAR 0 3
54540: PUSH
54541: LD_INT 1
54543: ST_TO_ADDR
54544: GO 54554
// result := false ;
54546: LD_ADDR_VAR 0 3
54550: PUSH
54551: LD_INT 0
54553: ST_TO_ADDR
// end else
54554: GO 54564
// result := false ;
54556: LD_ADDR_VAR 0 3
54560: PUSH
54561: LD_INT 0
54563: ST_TO_ADDR
// end ;
54564: LD_VAR 0 3
54568: RET
// export function HealTarget ( sci ) ; begin
54569: LD_INT 0
54571: PPUSH
// if not sci then
54572: LD_VAR 0 1
54576: NOT
54577: IFFALSE 54581
// exit ;
54579: GO 54646
// result := 0 ;
54581: LD_ADDR_VAR 0 2
54585: PUSH
54586: LD_INT 0
54588: ST_TO_ADDR
// if GetTaskList ( sci ) then
54589: LD_VAR 0 1
54593: PPUSH
54594: CALL_OW 437
54598: IFFALSE 54646
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54600: LD_VAR 0 1
54604: PPUSH
54605: CALL_OW 437
54609: PUSH
54610: LD_INT 1
54612: ARRAY
54613: PUSH
54614: LD_INT 1
54616: ARRAY
54617: PUSH
54618: LD_STRING l
54620: EQUAL
54621: IFFALSE 54646
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54623: LD_ADDR_VAR 0 2
54627: PUSH
54628: LD_VAR 0 1
54632: PPUSH
54633: CALL_OW 437
54637: PUSH
54638: LD_INT 1
54640: ARRAY
54641: PUSH
54642: LD_INT 4
54644: ARRAY
54645: ST_TO_ADDR
// end ;
54646: LD_VAR 0 2
54650: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54651: LD_INT 0
54653: PPUSH
54654: PPUSH
54655: PPUSH
54656: PPUSH
// if not base_units then
54657: LD_VAR 0 1
54661: NOT
54662: IFFALSE 54666
// exit ;
54664: GO 54753
// result := false ;
54666: LD_ADDR_VAR 0 2
54670: PUSH
54671: LD_INT 0
54673: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54674: LD_ADDR_VAR 0 5
54678: PUSH
54679: LD_VAR 0 1
54683: PPUSH
54684: LD_INT 21
54686: PUSH
54687: LD_INT 3
54689: PUSH
54690: EMPTY
54691: LIST
54692: LIST
54693: PPUSH
54694: CALL_OW 72
54698: ST_TO_ADDR
// if not tmp then
54699: LD_VAR 0 5
54703: NOT
54704: IFFALSE 54708
// exit ;
54706: GO 54753
// for i in tmp do
54708: LD_ADDR_VAR 0 3
54712: PUSH
54713: LD_VAR 0 5
54717: PUSH
54718: FOR_IN
54719: IFFALSE 54751
// begin result := EnemyInRange ( i , 22 ) ;
54721: LD_ADDR_VAR 0 2
54725: PUSH
54726: LD_VAR 0 3
54730: PPUSH
54731: LD_INT 22
54733: PPUSH
54734: CALL 52340 0 2
54738: ST_TO_ADDR
// if result then
54739: LD_VAR 0 2
54743: IFFALSE 54749
// exit ;
54745: POP
54746: POP
54747: GO 54753
// end ;
54749: GO 54718
54751: POP
54752: POP
// end ;
54753: LD_VAR 0 2
54757: RET
// export function FilterByTag ( units , tag ) ; begin
54758: LD_INT 0
54760: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54761: LD_ADDR_VAR 0 3
54765: PUSH
54766: LD_VAR 0 1
54770: PPUSH
54771: LD_INT 120
54773: PUSH
54774: LD_VAR 0 2
54778: PUSH
54779: EMPTY
54780: LIST
54781: LIST
54782: PPUSH
54783: CALL_OW 72
54787: ST_TO_ADDR
// end ;
54788: LD_VAR 0 3
54792: RET
// export function IsDriver ( un ) ; begin
54793: LD_INT 0
54795: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54796: LD_ADDR_VAR 0 2
54800: PUSH
54801: LD_VAR 0 1
54805: PUSH
54806: LD_INT 55
54808: PUSH
54809: EMPTY
54810: LIST
54811: PPUSH
54812: CALL_OW 69
54816: IN
54817: ST_TO_ADDR
// end ;
54818: LD_VAR 0 2
54822: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54823: LD_INT 0
54825: PPUSH
54826: PPUSH
// list := [ ] ;
54827: LD_ADDR_VAR 0 5
54831: PUSH
54832: EMPTY
54833: ST_TO_ADDR
// case d of 0 :
54834: LD_VAR 0 3
54838: PUSH
54839: LD_INT 0
54841: DOUBLE
54842: EQUAL
54843: IFTRUE 54847
54845: GO 54980
54847: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54848: LD_ADDR_VAR 0 5
54852: PUSH
54853: LD_VAR 0 1
54857: PUSH
54858: LD_INT 4
54860: MINUS
54861: PUSH
54862: LD_VAR 0 2
54866: PUSH
54867: LD_INT 4
54869: MINUS
54870: PUSH
54871: LD_INT 2
54873: PUSH
54874: EMPTY
54875: LIST
54876: LIST
54877: LIST
54878: PUSH
54879: LD_VAR 0 1
54883: PUSH
54884: LD_INT 3
54886: MINUS
54887: PUSH
54888: LD_VAR 0 2
54892: PUSH
54893: LD_INT 1
54895: PUSH
54896: EMPTY
54897: LIST
54898: LIST
54899: LIST
54900: PUSH
54901: LD_VAR 0 1
54905: PUSH
54906: LD_INT 4
54908: PLUS
54909: PUSH
54910: LD_VAR 0 2
54914: PUSH
54915: LD_INT 4
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: LIST
54922: PUSH
54923: LD_VAR 0 1
54927: PUSH
54928: LD_INT 3
54930: PLUS
54931: PUSH
54932: LD_VAR 0 2
54936: PUSH
54937: LD_INT 3
54939: PLUS
54940: PUSH
54941: LD_INT 5
54943: PUSH
54944: EMPTY
54945: LIST
54946: LIST
54947: LIST
54948: PUSH
54949: LD_VAR 0 1
54953: PUSH
54954: LD_VAR 0 2
54958: PUSH
54959: LD_INT 4
54961: PLUS
54962: PUSH
54963: LD_INT 0
54965: PUSH
54966: EMPTY
54967: LIST
54968: LIST
54969: LIST
54970: PUSH
54971: EMPTY
54972: LIST
54973: LIST
54974: LIST
54975: LIST
54976: LIST
54977: ST_TO_ADDR
// end ; 1 :
54978: GO 55678
54980: LD_INT 1
54982: DOUBLE
54983: EQUAL
54984: IFTRUE 54988
54986: GO 55121
54988: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54989: LD_ADDR_VAR 0 5
54993: PUSH
54994: LD_VAR 0 1
54998: PUSH
54999: LD_VAR 0 2
55003: PUSH
55004: LD_INT 4
55006: MINUS
55007: PUSH
55008: LD_INT 3
55010: PUSH
55011: EMPTY
55012: LIST
55013: LIST
55014: LIST
55015: PUSH
55016: LD_VAR 0 1
55020: PUSH
55021: LD_INT 3
55023: MINUS
55024: PUSH
55025: LD_VAR 0 2
55029: PUSH
55030: LD_INT 3
55032: MINUS
55033: PUSH
55034: LD_INT 2
55036: PUSH
55037: EMPTY
55038: LIST
55039: LIST
55040: LIST
55041: PUSH
55042: LD_VAR 0 1
55046: PUSH
55047: LD_INT 4
55049: MINUS
55050: PUSH
55051: LD_VAR 0 2
55055: PUSH
55056: LD_INT 1
55058: PUSH
55059: EMPTY
55060: LIST
55061: LIST
55062: LIST
55063: PUSH
55064: LD_VAR 0 1
55068: PUSH
55069: LD_VAR 0 2
55073: PUSH
55074: LD_INT 3
55076: PLUS
55077: PUSH
55078: LD_INT 0
55080: PUSH
55081: EMPTY
55082: LIST
55083: LIST
55084: LIST
55085: PUSH
55086: LD_VAR 0 1
55090: PUSH
55091: LD_INT 4
55093: PLUS
55094: PUSH
55095: LD_VAR 0 2
55099: PUSH
55100: LD_INT 4
55102: PLUS
55103: PUSH
55104: LD_INT 5
55106: PUSH
55107: EMPTY
55108: LIST
55109: LIST
55110: LIST
55111: PUSH
55112: EMPTY
55113: LIST
55114: LIST
55115: LIST
55116: LIST
55117: LIST
55118: ST_TO_ADDR
// end ; 2 :
55119: GO 55678
55121: LD_INT 2
55123: DOUBLE
55124: EQUAL
55125: IFTRUE 55129
55127: GO 55258
55129: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55130: LD_ADDR_VAR 0 5
55134: PUSH
55135: LD_VAR 0 1
55139: PUSH
55140: LD_VAR 0 2
55144: PUSH
55145: LD_INT 3
55147: MINUS
55148: PUSH
55149: LD_INT 3
55151: PUSH
55152: EMPTY
55153: LIST
55154: LIST
55155: LIST
55156: PUSH
55157: LD_VAR 0 1
55161: PUSH
55162: LD_INT 4
55164: PLUS
55165: PUSH
55166: LD_VAR 0 2
55170: PUSH
55171: LD_INT 4
55173: PUSH
55174: EMPTY
55175: LIST
55176: LIST
55177: LIST
55178: PUSH
55179: LD_VAR 0 1
55183: PUSH
55184: LD_VAR 0 2
55188: PUSH
55189: LD_INT 4
55191: PLUS
55192: PUSH
55193: LD_INT 0
55195: PUSH
55196: EMPTY
55197: LIST
55198: LIST
55199: LIST
55200: PUSH
55201: LD_VAR 0 1
55205: PUSH
55206: LD_INT 3
55208: MINUS
55209: PUSH
55210: LD_VAR 0 2
55214: PUSH
55215: LD_INT 1
55217: PUSH
55218: EMPTY
55219: LIST
55220: LIST
55221: LIST
55222: PUSH
55223: LD_VAR 0 1
55227: PUSH
55228: LD_INT 4
55230: MINUS
55231: PUSH
55232: LD_VAR 0 2
55236: PUSH
55237: LD_INT 4
55239: MINUS
55240: PUSH
55241: LD_INT 2
55243: PUSH
55244: EMPTY
55245: LIST
55246: LIST
55247: LIST
55248: PUSH
55249: EMPTY
55250: LIST
55251: LIST
55252: LIST
55253: LIST
55254: LIST
55255: ST_TO_ADDR
// end ; 3 :
55256: GO 55678
55258: LD_INT 3
55260: DOUBLE
55261: EQUAL
55262: IFTRUE 55266
55264: GO 55399
55266: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55267: LD_ADDR_VAR 0 5
55271: PUSH
55272: LD_VAR 0 1
55276: PUSH
55277: LD_INT 3
55279: PLUS
55280: PUSH
55281: LD_VAR 0 2
55285: PUSH
55286: LD_INT 4
55288: PUSH
55289: EMPTY
55290: LIST
55291: LIST
55292: LIST
55293: PUSH
55294: LD_VAR 0 1
55298: PUSH
55299: LD_INT 4
55301: PLUS
55302: PUSH
55303: LD_VAR 0 2
55307: PUSH
55308: LD_INT 4
55310: PLUS
55311: PUSH
55312: LD_INT 5
55314: PUSH
55315: EMPTY
55316: LIST
55317: LIST
55318: LIST
55319: PUSH
55320: LD_VAR 0 1
55324: PUSH
55325: LD_INT 4
55327: MINUS
55328: PUSH
55329: LD_VAR 0 2
55333: PUSH
55334: LD_INT 1
55336: PUSH
55337: EMPTY
55338: LIST
55339: LIST
55340: LIST
55341: PUSH
55342: LD_VAR 0 1
55346: PUSH
55347: LD_VAR 0 2
55351: PUSH
55352: LD_INT 4
55354: MINUS
55355: PUSH
55356: LD_INT 3
55358: PUSH
55359: EMPTY
55360: LIST
55361: LIST
55362: LIST
55363: PUSH
55364: LD_VAR 0 1
55368: PUSH
55369: LD_INT 3
55371: MINUS
55372: PUSH
55373: LD_VAR 0 2
55377: PUSH
55378: LD_INT 3
55380: MINUS
55381: PUSH
55382: LD_INT 2
55384: PUSH
55385: EMPTY
55386: LIST
55387: LIST
55388: LIST
55389: PUSH
55390: EMPTY
55391: LIST
55392: LIST
55393: LIST
55394: LIST
55395: LIST
55396: ST_TO_ADDR
// end ; 4 :
55397: GO 55678
55399: LD_INT 4
55401: DOUBLE
55402: EQUAL
55403: IFTRUE 55407
55405: GO 55540
55407: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55408: LD_ADDR_VAR 0 5
55412: PUSH
55413: LD_VAR 0 1
55417: PUSH
55418: LD_VAR 0 2
55422: PUSH
55423: LD_INT 4
55425: PLUS
55426: PUSH
55427: LD_INT 0
55429: PUSH
55430: EMPTY
55431: LIST
55432: LIST
55433: LIST
55434: PUSH
55435: LD_VAR 0 1
55439: PUSH
55440: LD_INT 3
55442: PLUS
55443: PUSH
55444: LD_VAR 0 2
55448: PUSH
55449: LD_INT 3
55451: PLUS
55452: PUSH
55453: LD_INT 5
55455: PUSH
55456: EMPTY
55457: LIST
55458: LIST
55459: LIST
55460: PUSH
55461: LD_VAR 0 1
55465: PUSH
55466: LD_INT 4
55468: PLUS
55469: PUSH
55470: LD_VAR 0 2
55474: PUSH
55475: LD_INT 4
55477: PUSH
55478: EMPTY
55479: LIST
55480: LIST
55481: LIST
55482: PUSH
55483: LD_VAR 0 1
55487: PUSH
55488: LD_VAR 0 2
55492: PUSH
55493: LD_INT 3
55495: MINUS
55496: PUSH
55497: LD_INT 3
55499: PUSH
55500: EMPTY
55501: LIST
55502: LIST
55503: LIST
55504: PUSH
55505: LD_VAR 0 1
55509: PUSH
55510: LD_INT 4
55512: MINUS
55513: PUSH
55514: LD_VAR 0 2
55518: PUSH
55519: LD_INT 4
55521: MINUS
55522: PUSH
55523: LD_INT 2
55525: PUSH
55526: EMPTY
55527: LIST
55528: LIST
55529: LIST
55530: PUSH
55531: EMPTY
55532: LIST
55533: LIST
55534: LIST
55535: LIST
55536: LIST
55537: ST_TO_ADDR
// end ; 5 :
55538: GO 55678
55540: LD_INT 5
55542: DOUBLE
55543: EQUAL
55544: IFTRUE 55548
55546: GO 55677
55548: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55549: LD_ADDR_VAR 0 5
55553: PUSH
55554: LD_VAR 0 1
55558: PUSH
55559: LD_INT 4
55561: MINUS
55562: PUSH
55563: LD_VAR 0 2
55567: PUSH
55568: LD_INT 1
55570: PUSH
55571: EMPTY
55572: LIST
55573: LIST
55574: LIST
55575: PUSH
55576: LD_VAR 0 1
55580: PUSH
55581: LD_VAR 0 2
55585: PUSH
55586: LD_INT 4
55588: MINUS
55589: PUSH
55590: LD_INT 3
55592: PUSH
55593: EMPTY
55594: LIST
55595: LIST
55596: LIST
55597: PUSH
55598: LD_VAR 0 1
55602: PUSH
55603: LD_INT 4
55605: PLUS
55606: PUSH
55607: LD_VAR 0 2
55611: PUSH
55612: LD_INT 4
55614: PLUS
55615: PUSH
55616: LD_INT 5
55618: PUSH
55619: EMPTY
55620: LIST
55621: LIST
55622: LIST
55623: PUSH
55624: LD_VAR 0 1
55628: PUSH
55629: LD_INT 3
55631: PLUS
55632: PUSH
55633: LD_VAR 0 2
55637: PUSH
55638: LD_INT 4
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: LIST
55645: PUSH
55646: LD_VAR 0 1
55650: PUSH
55651: LD_VAR 0 2
55655: PUSH
55656: LD_INT 3
55658: PLUS
55659: PUSH
55660: LD_INT 0
55662: PUSH
55663: EMPTY
55664: LIST
55665: LIST
55666: LIST
55667: PUSH
55668: EMPTY
55669: LIST
55670: LIST
55671: LIST
55672: LIST
55673: LIST
55674: ST_TO_ADDR
// end ; end ;
55675: GO 55678
55677: POP
// result := list ;
55678: LD_ADDR_VAR 0 4
55682: PUSH
55683: LD_VAR 0 5
55687: ST_TO_ADDR
// end ;
55688: LD_VAR 0 4
55692: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55693: LD_INT 0
55695: PPUSH
55696: PPUSH
55697: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55698: LD_VAR 0 1
55702: NOT
55703: PUSH
55704: LD_VAR 0 2
55708: PUSH
55709: LD_INT 1
55711: PUSH
55712: LD_INT 2
55714: PUSH
55715: LD_INT 3
55717: PUSH
55718: LD_INT 4
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: LIST
55725: LIST
55726: IN
55727: NOT
55728: OR
55729: IFFALSE 55733
// exit ;
55731: GO 55816
// tmp := [ ] ;
55733: LD_ADDR_VAR 0 5
55737: PUSH
55738: EMPTY
55739: ST_TO_ADDR
// for i in units do
55740: LD_ADDR_VAR 0 4
55744: PUSH
55745: LD_VAR 0 1
55749: PUSH
55750: FOR_IN
55751: IFFALSE 55785
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
55753: LD_ADDR_VAR 0 5
55757: PUSH
55758: LD_VAR 0 5
55762: PPUSH
55763: LD_VAR 0 4
55767: PPUSH
55768: LD_VAR 0 2
55772: PPUSH
55773: CALL_OW 259
55777: PPUSH
55778: CALL 57176 0 2
55782: ST_TO_ADDR
55783: GO 55750
55785: POP
55786: POP
// if not tmp then
55787: LD_VAR 0 5
55791: NOT
55792: IFFALSE 55796
// exit ;
55794: GO 55816
// result := SortListByListDesc ( units , tmp ) ;
55796: LD_ADDR_VAR 0 3
55800: PUSH
55801: LD_VAR 0 1
55805: PPUSH
55806: LD_VAR 0 5
55810: PPUSH
55811: CALL_OW 77
55815: ST_TO_ADDR
// end ;
55816: LD_VAR 0 3
55820: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55821: LD_INT 0
55823: PPUSH
55824: PPUSH
55825: PPUSH
// result := false ;
55826: LD_ADDR_VAR 0 3
55830: PUSH
55831: LD_INT 0
55833: ST_TO_ADDR
// if not building then
55834: LD_VAR 0 2
55838: NOT
55839: IFFALSE 55843
// exit ;
55841: GO 55981
// x := GetX ( building ) ;
55843: LD_ADDR_VAR 0 4
55847: PUSH
55848: LD_VAR 0 2
55852: PPUSH
55853: CALL_OW 250
55857: ST_TO_ADDR
// y := GetY ( building ) ;
55858: LD_ADDR_VAR 0 5
55862: PUSH
55863: LD_VAR 0 2
55867: PPUSH
55868: CALL_OW 251
55872: ST_TO_ADDR
// if not x or not y then
55873: LD_VAR 0 4
55877: NOT
55878: PUSH
55879: LD_VAR 0 5
55883: NOT
55884: OR
55885: IFFALSE 55889
// exit ;
55887: GO 55981
// if GetTaskList ( unit ) then
55889: LD_VAR 0 1
55893: PPUSH
55894: CALL_OW 437
55898: IFFALSE 55981
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55900: LD_STRING e
55902: PUSH
55903: LD_VAR 0 1
55907: PPUSH
55908: CALL_OW 437
55912: PUSH
55913: LD_INT 1
55915: ARRAY
55916: PUSH
55917: LD_INT 1
55919: ARRAY
55920: EQUAL
55921: PUSH
55922: LD_VAR 0 4
55926: PUSH
55927: LD_VAR 0 1
55931: PPUSH
55932: CALL_OW 437
55936: PUSH
55937: LD_INT 1
55939: ARRAY
55940: PUSH
55941: LD_INT 2
55943: ARRAY
55944: EQUAL
55945: AND
55946: PUSH
55947: LD_VAR 0 5
55951: PUSH
55952: LD_VAR 0 1
55956: PPUSH
55957: CALL_OW 437
55961: PUSH
55962: LD_INT 1
55964: ARRAY
55965: PUSH
55966: LD_INT 3
55968: ARRAY
55969: EQUAL
55970: AND
55971: IFFALSE 55981
// result := true end ;
55973: LD_ADDR_VAR 0 3
55977: PUSH
55978: LD_INT 1
55980: ST_TO_ADDR
// end ;
55981: LD_VAR 0 3
55985: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
55986: LD_INT 0
55988: PPUSH
// result := false ;
55989: LD_ADDR_VAR 0 4
55993: PUSH
55994: LD_INT 0
55996: ST_TO_ADDR
// if GetTaskList ( unit ) then
55997: LD_VAR 0 1
56001: PPUSH
56002: CALL_OW 437
56006: IFFALSE 56089
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56008: LD_STRING M
56010: PUSH
56011: LD_VAR 0 1
56015: PPUSH
56016: CALL_OW 437
56020: PUSH
56021: LD_INT 1
56023: ARRAY
56024: PUSH
56025: LD_INT 1
56027: ARRAY
56028: EQUAL
56029: PUSH
56030: LD_VAR 0 2
56034: PUSH
56035: LD_VAR 0 1
56039: PPUSH
56040: CALL_OW 437
56044: PUSH
56045: LD_INT 1
56047: ARRAY
56048: PUSH
56049: LD_INT 2
56051: ARRAY
56052: EQUAL
56053: AND
56054: PUSH
56055: LD_VAR 0 3
56059: PUSH
56060: LD_VAR 0 1
56064: PPUSH
56065: CALL_OW 437
56069: PUSH
56070: LD_INT 1
56072: ARRAY
56073: PUSH
56074: LD_INT 3
56076: ARRAY
56077: EQUAL
56078: AND
56079: IFFALSE 56089
// result := true ;
56081: LD_ADDR_VAR 0 4
56085: PUSH
56086: LD_INT 1
56088: ST_TO_ADDR
// end ; end ;
56089: LD_VAR 0 4
56093: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56094: LD_INT 0
56096: PPUSH
56097: PPUSH
56098: PPUSH
56099: PPUSH
// if not unit or not area then
56100: LD_VAR 0 1
56104: NOT
56105: PUSH
56106: LD_VAR 0 2
56110: NOT
56111: OR
56112: IFFALSE 56116
// exit ;
56114: GO 56279
// tmp := AreaToList ( area , i ) ;
56116: LD_ADDR_VAR 0 6
56120: PUSH
56121: LD_VAR 0 2
56125: PPUSH
56126: LD_VAR 0 5
56130: PPUSH
56131: CALL_OW 517
56135: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56136: LD_ADDR_VAR 0 5
56140: PUSH
56141: DOUBLE
56142: LD_INT 1
56144: DEC
56145: ST_TO_ADDR
56146: LD_VAR 0 6
56150: PUSH
56151: LD_INT 1
56153: ARRAY
56154: PUSH
56155: FOR_TO
56156: IFFALSE 56277
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56158: LD_ADDR_VAR 0 7
56162: PUSH
56163: LD_VAR 0 6
56167: PUSH
56168: LD_INT 1
56170: ARRAY
56171: PUSH
56172: LD_VAR 0 5
56176: ARRAY
56177: PUSH
56178: LD_VAR 0 6
56182: PUSH
56183: LD_INT 2
56185: ARRAY
56186: PUSH
56187: LD_VAR 0 5
56191: ARRAY
56192: PUSH
56193: EMPTY
56194: LIST
56195: LIST
56196: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
56197: LD_INT 92
56199: PUSH
56200: LD_VAR 0 7
56204: PUSH
56205: LD_INT 1
56207: ARRAY
56208: PUSH
56209: LD_VAR 0 7
56213: PUSH
56214: LD_INT 2
56216: ARRAY
56217: PUSH
56218: LD_INT 3
56220: PUSH
56221: EMPTY
56222: LIST
56223: LIST
56224: LIST
56225: LIST
56226: PPUSH
56227: CALL_OW 69
56231: PUSH
56232: LD_INT 0
56234: EQUAL
56235: IFFALSE 56275
// begin PlaceUnitArea ( unit , area , mode ) ;
56237: LD_VAR 0 1
56241: PPUSH
56242: LD_VAR 0 2
56246: PPUSH
56247: LD_VAR 0 3
56251: PPUSH
56252: CALL_OW 49
// result := IsPlaced ( unit ) ;
56256: LD_ADDR_VAR 0 4
56260: PUSH
56261: LD_VAR 0 1
56265: PPUSH
56266: CALL_OW 305
56270: ST_TO_ADDR
// exit ;
56271: POP
56272: POP
56273: GO 56279
// end ; end ;
56275: GO 56155
56277: POP
56278: POP
// end ;
56279: LD_VAR 0 4
56283: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56284: LD_INT 0
56286: PPUSH
56287: PPUSH
56288: PPUSH
// if not side or side > 8 then
56289: LD_VAR 0 1
56293: NOT
56294: PUSH
56295: LD_VAR 0 1
56299: PUSH
56300: LD_INT 8
56302: GREATER
56303: OR
56304: IFFALSE 56308
// exit ;
56306: GO 56495
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56308: LD_ADDR_VAR 0 4
56312: PUSH
56313: LD_INT 22
56315: PUSH
56316: LD_VAR 0 1
56320: PUSH
56321: EMPTY
56322: LIST
56323: LIST
56324: PUSH
56325: LD_INT 21
56327: PUSH
56328: LD_INT 3
56330: PUSH
56331: EMPTY
56332: LIST
56333: LIST
56334: PUSH
56335: EMPTY
56336: LIST
56337: LIST
56338: PPUSH
56339: CALL_OW 69
56343: ST_TO_ADDR
// if not tmp then
56344: LD_VAR 0 4
56348: NOT
56349: IFFALSE 56353
// exit ;
56351: GO 56495
// enable_addtolog := true ;
56353: LD_ADDR_OWVAR 81
56357: PUSH
56358: LD_INT 1
56360: ST_TO_ADDR
// AddToLog ( [ ) ;
56361: LD_STRING [
56363: PPUSH
56364: CALL_OW 561
// for i in tmp do
56368: LD_ADDR_VAR 0 3
56372: PUSH
56373: LD_VAR 0 4
56377: PUSH
56378: FOR_IN
56379: IFFALSE 56486
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56381: LD_STRING [
56383: PUSH
56384: LD_VAR 0 3
56388: PPUSH
56389: CALL_OW 266
56393: STR
56394: PUSH
56395: LD_STRING , 
56397: STR
56398: PUSH
56399: LD_VAR 0 3
56403: PPUSH
56404: CALL_OW 250
56408: STR
56409: PUSH
56410: LD_STRING , 
56412: STR
56413: PUSH
56414: LD_VAR 0 3
56418: PPUSH
56419: CALL_OW 251
56423: STR
56424: PUSH
56425: LD_STRING , 
56427: STR
56428: PUSH
56429: LD_VAR 0 3
56433: PPUSH
56434: CALL_OW 254
56438: STR
56439: PUSH
56440: LD_STRING , 
56442: STR
56443: PUSH
56444: LD_VAR 0 3
56448: PPUSH
56449: LD_INT 1
56451: PPUSH
56452: CALL_OW 268
56456: STR
56457: PUSH
56458: LD_STRING , 
56460: STR
56461: PUSH
56462: LD_VAR 0 3
56466: PPUSH
56467: LD_INT 2
56469: PPUSH
56470: CALL_OW 268
56474: STR
56475: PUSH
56476: LD_STRING ],
56478: STR
56479: PPUSH
56480: CALL_OW 561
// end ;
56484: GO 56378
56486: POP
56487: POP
// AddToLog ( ]; ) ;
56488: LD_STRING ];
56490: PPUSH
56491: CALL_OW 561
// end ;
56495: LD_VAR 0 2
56499: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56500: LD_INT 0
56502: PPUSH
56503: PPUSH
56504: PPUSH
56505: PPUSH
56506: PPUSH
// if not area or not rate or not max then
56507: LD_VAR 0 1
56511: NOT
56512: PUSH
56513: LD_VAR 0 2
56517: NOT
56518: OR
56519: PUSH
56520: LD_VAR 0 4
56524: NOT
56525: OR
56526: IFFALSE 56530
// exit ;
56528: GO 56719
// while 1 do
56530: LD_INT 1
56532: IFFALSE 56719
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56534: LD_ADDR_VAR 0 9
56538: PUSH
56539: LD_VAR 0 1
56543: PPUSH
56544: LD_INT 1
56546: PPUSH
56547: CALL_OW 287
56551: PUSH
56552: LD_INT 10
56554: MUL
56555: ST_TO_ADDR
// r := rate / 10 ;
56556: LD_ADDR_VAR 0 7
56560: PUSH
56561: LD_VAR 0 2
56565: PUSH
56566: LD_INT 10
56568: DIVREAL
56569: ST_TO_ADDR
// time := 1 1$00 ;
56570: LD_ADDR_VAR 0 8
56574: PUSH
56575: LD_INT 2100
56577: ST_TO_ADDR
// if amount < min then
56578: LD_VAR 0 9
56582: PUSH
56583: LD_VAR 0 3
56587: LESS
56588: IFFALSE 56606
// r := r * 2 else
56590: LD_ADDR_VAR 0 7
56594: PUSH
56595: LD_VAR 0 7
56599: PUSH
56600: LD_INT 2
56602: MUL
56603: ST_TO_ADDR
56604: GO 56632
// if amount > max then
56606: LD_VAR 0 9
56610: PUSH
56611: LD_VAR 0 4
56615: GREATER
56616: IFFALSE 56632
// r := r / 2 ;
56618: LD_ADDR_VAR 0 7
56622: PUSH
56623: LD_VAR 0 7
56627: PUSH
56628: LD_INT 2
56630: DIVREAL
56631: ST_TO_ADDR
// time := time / r ;
56632: LD_ADDR_VAR 0 8
56636: PUSH
56637: LD_VAR 0 8
56641: PUSH
56642: LD_VAR 0 7
56646: DIVREAL
56647: ST_TO_ADDR
// if time < 0 then
56648: LD_VAR 0 8
56652: PUSH
56653: LD_INT 0
56655: LESS
56656: IFFALSE 56673
// time := time * - 1 ;
56658: LD_ADDR_VAR 0 8
56662: PUSH
56663: LD_VAR 0 8
56667: PUSH
56668: LD_INT 1
56670: NEG
56671: MUL
56672: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56673: LD_VAR 0 8
56677: PUSH
56678: LD_INT 35
56680: PPUSH
56681: LD_INT 875
56683: PPUSH
56684: CALL_OW 12
56688: PLUS
56689: PPUSH
56690: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56694: LD_INT 1
56696: PPUSH
56697: LD_INT 5
56699: PPUSH
56700: CALL_OW 12
56704: PPUSH
56705: LD_VAR 0 1
56709: PPUSH
56710: LD_INT 1
56712: PPUSH
56713: CALL_OW 55
// end ;
56717: GO 56530
// end ;
56719: LD_VAR 0 5
56723: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56724: LD_INT 0
56726: PPUSH
56727: PPUSH
56728: PPUSH
56729: PPUSH
56730: PPUSH
56731: PPUSH
56732: PPUSH
56733: PPUSH
// if not turrets or not factories then
56734: LD_VAR 0 1
56738: NOT
56739: PUSH
56740: LD_VAR 0 2
56744: NOT
56745: OR
56746: IFFALSE 56750
// exit ;
56748: GO 57057
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56750: LD_ADDR_VAR 0 10
56754: PUSH
56755: LD_INT 5
56757: PUSH
56758: LD_INT 6
56760: PUSH
56761: EMPTY
56762: LIST
56763: LIST
56764: PUSH
56765: LD_INT 2
56767: PUSH
56768: LD_INT 4
56770: PUSH
56771: EMPTY
56772: LIST
56773: LIST
56774: PUSH
56775: LD_INT 3
56777: PUSH
56778: LD_INT 5
56780: PUSH
56781: EMPTY
56782: LIST
56783: LIST
56784: PUSH
56785: EMPTY
56786: LIST
56787: LIST
56788: LIST
56789: PUSH
56790: LD_INT 24
56792: PUSH
56793: LD_INT 25
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PUSH
56800: LD_INT 23
56802: PUSH
56803: LD_INT 27
56805: PUSH
56806: EMPTY
56807: LIST
56808: LIST
56809: PUSH
56810: EMPTY
56811: LIST
56812: LIST
56813: PUSH
56814: LD_INT 42
56816: PUSH
56817: LD_INT 43
56819: PUSH
56820: EMPTY
56821: LIST
56822: LIST
56823: PUSH
56824: LD_INT 44
56826: PUSH
56827: LD_INT 46
56829: PUSH
56830: EMPTY
56831: LIST
56832: LIST
56833: PUSH
56834: LD_INT 45
56836: PUSH
56837: LD_INT 47
56839: PUSH
56840: EMPTY
56841: LIST
56842: LIST
56843: PUSH
56844: EMPTY
56845: LIST
56846: LIST
56847: LIST
56848: PUSH
56849: EMPTY
56850: LIST
56851: LIST
56852: LIST
56853: ST_TO_ADDR
// result := [ ] ;
56854: LD_ADDR_VAR 0 3
56858: PUSH
56859: EMPTY
56860: ST_TO_ADDR
// for i in turrets do
56861: LD_ADDR_VAR 0 4
56865: PUSH
56866: LD_VAR 0 1
56870: PUSH
56871: FOR_IN
56872: IFFALSE 57055
// begin nat := GetNation ( i ) ;
56874: LD_ADDR_VAR 0 7
56878: PUSH
56879: LD_VAR 0 4
56883: PPUSH
56884: CALL_OW 248
56888: ST_TO_ADDR
// weapon := 0 ;
56889: LD_ADDR_VAR 0 8
56893: PUSH
56894: LD_INT 0
56896: ST_TO_ADDR
// if not nat then
56897: LD_VAR 0 7
56901: NOT
56902: IFFALSE 56906
// continue ;
56904: GO 56871
// for j in list [ nat ] do
56906: LD_ADDR_VAR 0 5
56910: PUSH
56911: LD_VAR 0 10
56915: PUSH
56916: LD_VAR 0 7
56920: ARRAY
56921: PUSH
56922: FOR_IN
56923: IFFALSE 56964
// if GetBWeapon ( i ) = j [ 1 ] then
56925: LD_VAR 0 4
56929: PPUSH
56930: CALL_OW 269
56934: PUSH
56935: LD_VAR 0 5
56939: PUSH
56940: LD_INT 1
56942: ARRAY
56943: EQUAL
56944: IFFALSE 56962
// begin weapon := j [ 2 ] ;
56946: LD_ADDR_VAR 0 8
56950: PUSH
56951: LD_VAR 0 5
56955: PUSH
56956: LD_INT 2
56958: ARRAY
56959: ST_TO_ADDR
// break ;
56960: GO 56964
// end ;
56962: GO 56922
56964: POP
56965: POP
// if not weapon then
56966: LD_VAR 0 8
56970: NOT
56971: IFFALSE 56975
// continue ;
56973: GO 56871
// for k in factories do
56975: LD_ADDR_VAR 0 6
56979: PUSH
56980: LD_VAR 0 2
56984: PUSH
56985: FOR_IN
56986: IFFALSE 57051
// begin weapons := AvailableWeaponList ( k ) ;
56988: LD_ADDR_VAR 0 9
56992: PUSH
56993: LD_VAR 0 6
56997: PPUSH
56998: CALL_OW 478
57002: ST_TO_ADDR
// if not weapons then
57003: LD_VAR 0 9
57007: NOT
57008: IFFALSE 57012
// continue ;
57010: GO 56985
// if weapon in weapons then
57012: LD_VAR 0 8
57016: PUSH
57017: LD_VAR 0 9
57021: IN
57022: IFFALSE 57049
// begin result := [ i , weapon ] ;
57024: LD_ADDR_VAR 0 3
57028: PUSH
57029: LD_VAR 0 4
57033: PUSH
57034: LD_VAR 0 8
57038: PUSH
57039: EMPTY
57040: LIST
57041: LIST
57042: ST_TO_ADDR
// exit ;
57043: POP
57044: POP
57045: POP
57046: POP
57047: GO 57057
// end ; end ;
57049: GO 56985
57051: POP
57052: POP
// end ;
57053: GO 56871
57055: POP
57056: POP
// end ;
57057: LD_VAR 0 3
57061: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57062: LD_INT 0
57064: PPUSH
// if not side or side > 8 then
57065: LD_VAR 0 3
57069: NOT
57070: PUSH
57071: LD_VAR 0 3
57075: PUSH
57076: LD_INT 8
57078: GREATER
57079: OR
57080: IFFALSE 57084
// exit ;
57082: GO 57143
// if not range then
57084: LD_VAR 0 4
57088: NOT
57089: IFFALSE 57100
// range := - 12 ;
57091: LD_ADDR_VAR 0 4
57095: PUSH
57096: LD_INT 12
57098: NEG
57099: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57100: LD_VAR 0 1
57104: PPUSH
57105: LD_VAR 0 2
57109: PPUSH
57110: LD_VAR 0 3
57114: PPUSH
57115: LD_VAR 0 4
57119: PPUSH
57120: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57124: LD_VAR 0 1
57128: PPUSH
57129: LD_VAR 0 2
57133: PPUSH
57134: LD_VAR 0 3
57138: PPUSH
57139: CALL_OW 331
// end ;
57143: LD_VAR 0 5
57147: RET
// export function Video ( mode ) ; begin
57148: LD_INT 0
57150: PPUSH
// ingame_video = mode ;
57151: LD_ADDR_OWVAR 52
57155: PUSH
57156: LD_VAR 0 1
57160: ST_TO_ADDR
// interface_hidden = mode ;
57161: LD_ADDR_OWVAR 54
57165: PUSH
57166: LD_VAR 0 1
57170: ST_TO_ADDR
// end ;
57171: LD_VAR 0 2
57175: RET
// export function Join ( array , element ) ; begin
57176: LD_INT 0
57178: PPUSH
// result := Replace ( array , array + 1 , element ) ;
57179: LD_ADDR_VAR 0 3
57183: PUSH
57184: LD_VAR 0 1
57188: PPUSH
57189: LD_VAR 0 1
57193: PUSH
57194: LD_INT 1
57196: PLUS
57197: PPUSH
57198: LD_VAR 0 2
57202: PPUSH
57203: CALL_OW 1
57207: ST_TO_ADDR
// end ;
57208: LD_VAR 0 3
57212: RET
// export function JoinUnion ( array , element ) ; begin
57213: LD_INT 0
57215: PPUSH
// result := array union element ;
57216: LD_ADDR_VAR 0 3
57220: PUSH
57221: LD_VAR 0 1
57225: PUSH
57226: LD_VAR 0 2
57230: UNION
57231: ST_TO_ADDR
// end ;
57232: LD_VAR 0 3
57236: RET
// export function GetBehemoths ( side ) ; begin
57237: LD_INT 0
57239: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
57240: LD_ADDR_VAR 0 2
57244: PUSH
57245: LD_INT 22
57247: PUSH
57248: LD_VAR 0 1
57252: PUSH
57253: EMPTY
57254: LIST
57255: LIST
57256: PUSH
57257: LD_INT 31
57259: PUSH
57260: LD_INT 25
57262: PUSH
57263: EMPTY
57264: LIST
57265: LIST
57266: PUSH
57267: EMPTY
57268: LIST
57269: LIST
57270: PPUSH
57271: CALL_OW 69
57275: ST_TO_ADDR
// end ;
57276: LD_VAR 0 2
57280: RET
// export function Shuffle ( array ) ; var i , index ; begin
57281: LD_INT 0
57283: PPUSH
57284: PPUSH
57285: PPUSH
// result := [ ] ;
57286: LD_ADDR_VAR 0 2
57290: PUSH
57291: EMPTY
57292: ST_TO_ADDR
// if not array then
57293: LD_VAR 0 1
57297: NOT
57298: IFFALSE 57302
// exit ;
57300: GO 57401
// Randomize ;
57302: CALL_OW 10
// for i = array downto 1 do
57306: LD_ADDR_VAR 0 3
57310: PUSH
57311: DOUBLE
57312: LD_VAR 0 1
57316: INC
57317: ST_TO_ADDR
57318: LD_INT 1
57320: PUSH
57321: FOR_DOWNTO
57322: IFFALSE 57399
// begin index := rand ( 1 , array ) ;
57324: LD_ADDR_VAR 0 4
57328: PUSH
57329: LD_INT 1
57331: PPUSH
57332: LD_VAR 0 1
57336: PPUSH
57337: CALL_OW 12
57341: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57342: LD_ADDR_VAR 0 2
57346: PUSH
57347: LD_VAR 0 2
57351: PPUSH
57352: LD_VAR 0 2
57356: PUSH
57357: LD_INT 1
57359: PLUS
57360: PPUSH
57361: LD_VAR 0 1
57365: PUSH
57366: LD_VAR 0 4
57370: ARRAY
57371: PPUSH
57372: CALL_OW 2
57376: ST_TO_ADDR
// array := Delete ( array , index ) ;
57377: LD_ADDR_VAR 0 1
57381: PUSH
57382: LD_VAR 0 1
57386: PPUSH
57387: LD_VAR 0 4
57391: PPUSH
57392: CALL_OW 3
57396: ST_TO_ADDR
// end ;
57397: GO 57321
57399: POP
57400: POP
// end ;
57401: LD_VAR 0 2
57405: RET
// export function GetBaseMaterials ( base ) ; begin
57406: LD_INT 0
57408: PPUSH
// result := [ 0 , 0 , 0 ] ;
57409: LD_ADDR_VAR 0 2
57413: PUSH
57414: LD_INT 0
57416: PUSH
57417: LD_INT 0
57419: PUSH
57420: LD_INT 0
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: LIST
57427: ST_TO_ADDR
// if not base then
57428: LD_VAR 0 1
57432: NOT
57433: IFFALSE 57437
// exit ;
57435: GO 57486
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57437: LD_ADDR_VAR 0 2
57441: PUSH
57442: LD_VAR 0 1
57446: PPUSH
57447: LD_INT 1
57449: PPUSH
57450: CALL_OW 275
57454: PUSH
57455: LD_VAR 0 1
57459: PPUSH
57460: LD_INT 2
57462: PPUSH
57463: CALL_OW 275
57467: PUSH
57468: LD_VAR 0 1
57472: PPUSH
57473: LD_INT 3
57475: PPUSH
57476: CALL_OW 275
57480: PUSH
57481: EMPTY
57482: LIST
57483: LIST
57484: LIST
57485: ST_TO_ADDR
// end ;
57486: LD_VAR 0 2
57490: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57491: LD_INT 0
57493: PPUSH
57494: PPUSH
// result := array ;
57495: LD_ADDR_VAR 0 3
57499: PUSH
57500: LD_VAR 0 1
57504: ST_TO_ADDR
// if size >= result then
57505: LD_VAR 0 2
57509: PUSH
57510: LD_VAR 0 3
57514: GREATEREQUAL
57515: IFFALSE 57519
// exit ;
57517: GO 57569
// if size then
57519: LD_VAR 0 2
57523: IFFALSE 57569
// for i := array downto size do
57525: LD_ADDR_VAR 0 4
57529: PUSH
57530: DOUBLE
57531: LD_VAR 0 1
57535: INC
57536: ST_TO_ADDR
57537: LD_VAR 0 2
57541: PUSH
57542: FOR_DOWNTO
57543: IFFALSE 57567
// result := Delete ( result , result ) ;
57545: LD_ADDR_VAR 0 3
57549: PUSH
57550: LD_VAR 0 3
57554: PPUSH
57555: LD_VAR 0 3
57559: PPUSH
57560: CALL_OW 3
57564: ST_TO_ADDR
57565: GO 57542
57567: POP
57568: POP
// end ;
57569: LD_VAR 0 3
57573: RET
// export function ComExit ( unit ) ; var tmp ; begin
57574: LD_INT 0
57576: PPUSH
57577: PPUSH
// if not IsInUnit ( unit ) then
57578: LD_VAR 0 1
57582: PPUSH
57583: CALL_OW 310
57587: NOT
57588: IFFALSE 57592
// exit ;
57590: GO 57652
// tmp := IsInUnit ( unit ) ;
57592: LD_ADDR_VAR 0 3
57596: PUSH
57597: LD_VAR 0 1
57601: PPUSH
57602: CALL_OW 310
57606: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57607: LD_VAR 0 3
57611: PPUSH
57612: CALL_OW 247
57616: PUSH
57617: LD_INT 2
57619: EQUAL
57620: IFFALSE 57633
// ComExitVehicle ( unit ) else
57622: LD_VAR 0 1
57626: PPUSH
57627: CALL_OW 121
57631: GO 57642
// ComExitBuilding ( unit ) ;
57633: LD_VAR 0 1
57637: PPUSH
57638: CALL_OW 122
// result := tmp ;
57642: LD_ADDR_VAR 0 2
57646: PUSH
57647: LD_VAR 0 3
57651: ST_TO_ADDR
// end ;
57652: LD_VAR 0 2
57656: RET
// export function ComExitAll ( units ) ; var i ; begin
57657: LD_INT 0
57659: PPUSH
57660: PPUSH
// if not units then
57661: LD_VAR 0 1
57665: NOT
57666: IFFALSE 57670
// exit ;
57668: GO 57696
// for i in units do
57670: LD_ADDR_VAR 0 3
57674: PUSH
57675: LD_VAR 0 1
57679: PUSH
57680: FOR_IN
57681: IFFALSE 57694
// ComExit ( i ) ;
57683: LD_VAR 0 3
57687: PPUSH
57688: CALL 57574 0 1
57692: GO 57680
57694: POP
57695: POP
// end ;
57696: LD_VAR 0 2
57700: RET
// export function ResetHc ; begin
57701: LD_INT 0
57703: PPUSH
// InitHc ;
57704: CALL_OW 19
// hc_importance := 0 ;
57708: LD_ADDR_OWVAR 32
57712: PUSH
57713: LD_INT 0
57715: ST_TO_ADDR
// end ;
57716: LD_VAR 0 1
57720: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57721: LD_INT 0
57723: PPUSH
57724: PPUSH
57725: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57726: LD_ADDR_VAR 0 6
57730: PUSH
57731: LD_VAR 0 1
57735: PUSH
57736: LD_VAR 0 3
57740: PLUS
57741: PUSH
57742: LD_INT 2
57744: DIV
57745: ST_TO_ADDR
// if _x < 0 then
57746: LD_VAR 0 6
57750: PUSH
57751: LD_INT 0
57753: LESS
57754: IFFALSE 57771
// _x := _x * - 1 ;
57756: LD_ADDR_VAR 0 6
57760: PUSH
57761: LD_VAR 0 6
57765: PUSH
57766: LD_INT 1
57768: NEG
57769: MUL
57770: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57771: LD_ADDR_VAR 0 7
57775: PUSH
57776: LD_VAR 0 2
57780: PUSH
57781: LD_VAR 0 4
57785: PLUS
57786: PUSH
57787: LD_INT 2
57789: DIV
57790: ST_TO_ADDR
// if _y < 0 then
57791: LD_VAR 0 7
57795: PUSH
57796: LD_INT 0
57798: LESS
57799: IFFALSE 57816
// _y := _y * - 1 ;
57801: LD_ADDR_VAR 0 7
57805: PUSH
57806: LD_VAR 0 7
57810: PUSH
57811: LD_INT 1
57813: NEG
57814: MUL
57815: ST_TO_ADDR
// result := [ _x , _y ] ;
57816: LD_ADDR_VAR 0 5
57820: PUSH
57821: LD_VAR 0 6
57825: PUSH
57826: LD_VAR 0 7
57830: PUSH
57831: EMPTY
57832: LIST
57833: LIST
57834: ST_TO_ADDR
// end ;
57835: LD_VAR 0 5
57839: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57840: LD_INT 0
57842: PPUSH
57843: PPUSH
57844: PPUSH
57845: PPUSH
// task := GetTaskList ( unit ) ;
57846: LD_ADDR_VAR 0 7
57850: PUSH
57851: LD_VAR 0 1
57855: PPUSH
57856: CALL_OW 437
57860: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57861: LD_VAR 0 7
57865: NOT
57866: PUSH
57867: LD_VAR 0 1
57871: PPUSH
57872: LD_VAR 0 2
57876: PPUSH
57877: CALL_OW 308
57881: NOT
57882: AND
57883: IFFALSE 57887
// exit ;
57885: GO 58005
// if IsInArea ( unit , area ) then
57887: LD_VAR 0 1
57891: PPUSH
57892: LD_VAR 0 2
57896: PPUSH
57897: CALL_OW 308
57901: IFFALSE 57919
// begin ComMoveToArea ( unit , goAway ) ;
57903: LD_VAR 0 1
57907: PPUSH
57908: LD_VAR 0 3
57912: PPUSH
57913: CALL_OW 113
// exit ;
57917: GO 58005
// end ; if task [ 1 ] [ 1 ] <> M then
57919: LD_VAR 0 7
57923: PUSH
57924: LD_INT 1
57926: ARRAY
57927: PUSH
57928: LD_INT 1
57930: ARRAY
57931: PUSH
57932: LD_STRING M
57934: NONEQUAL
57935: IFFALSE 57939
// exit ;
57937: GO 58005
// x := task [ 1 ] [ 2 ] ;
57939: LD_ADDR_VAR 0 5
57943: PUSH
57944: LD_VAR 0 7
57948: PUSH
57949: LD_INT 1
57951: ARRAY
57952: PUSH
57953: LD_INT 2
57955: ARRAY
57956: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
57957: LD_ADDR_VAR 0 6
57961: PUSH
57962: LD_VAR 0 7
57966: PUSH
57967: LD_INT 1
57969: ARRAY
57970: PUSH
57971: LD_INT 3
57973: ARRAY
57974: ST_TO_ADDR
// if InArea ( x , y , area ) then
57975: LD_VAR 0 5
57979: PPUSH
57980: LD_VAR 0 6
57984: PPUSH
57985: LD_VAR 0 2
57989: PPUSH
57990: CALL_OW 309
57994: IFFALSE 58005
// ComStop ( unit ) ;
57996: LD_VAR 0 1
58000: PPUSH
58001: CALL_OW 141
// end ;
58005: LD_VAR 0 4
58009: RET
// export function Abs ( value ) ; begin
58010: LD_INT 0
58012: PPUSH
// result := value ;
58013: LD_ADDR_VAR 0 2
58017: PUSH
58018: LD_VAR 0 1
58022: ST_TO_ADDR
// if value < 0 then
58023: LD_VAR 0 1
58027: PUSH
58028: LD_INT 0
58030: LESS
58031: IFFALSE 58048
// result := value * - 1 ;
58033: LD_ADDR_VAR 0 2
58037: PUSH
58038: LD_VAR 0 1
58042: PUSH
58043: LD_INT 1
58045: NEG
58046: MUL
58047: ST_TO_ADDR
// end ;
58048: LD_VAR 0 2
58052: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58053: LD_INT 0
58055: PPUSH
58056: PPUSH
58057: PPUSH
58058: PPUSH
58059: PPUSH
58060: PPUSH
58061: PPUSH
58062: PPUSH
// if not unit or not building then
58063: LD_VAR 0 1
58067: NOT
58068: PUSH
58069: LD_VAR 0 2
58073: NOT
58074: OR
58075: IFFALSE 58079
// exit ;
58077: GO 58305
// x := GetX ( building ) ;
58079: LD_ADDR_VAR 0 4
58083: PUSH
58084: LD_VAR 0 2
58088: PPUSH
58089: CALL_OW 250
58093: ST_TO_ADDR
// y := GetY ( building ) ;
58094: LD_ADDR_VAR 0 6
58098: PUSH
58099: LD_VAR 0 2
58103: PPUSH
58104: CALL_OW 251
58108: ST_TO_ADDR
// d := GetDir ( building ) ;
58109: LD_ADDR_VAR 0 8
58113: PUSH
58114: LD_VAR 0 2
58118: PPUSH
58119: CALL_OW 254
58123: ST_TO_ADDR
// r := 4 ;
58124: LD_ADDR_VAR 0 9
58128: PUSH
58129: LD_INT 4
58131: ST_TO_ADDR
// for i := 1 to 5 do
58132: LD_ADDR_VAR 0 10
58136: PUSH
58137: DOUBLE
58138: LD_INT 1
58140: DEC
58141: ST_TO_ADDR
58142: LD_INT 5
58144: PUSH
58145: FOR_TO
58146: IFFALSE 58303
// begin _x := ShiftX ( x , d , r + i ) ;
58148: LD_ADDR_VAR 0 5
58152: PUSH
58153: LD_VAR 0 4
58157: PPUSH
58158: LD_VAR 0 8
58162: PPUSH
58163: LD_VAR 0 9
58167: PUSH
58168: LD_VAR 0 10
58172: PLUS
58173: PPUSH
58174: CALL_OW 272
58178: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
58179: LD_ADDR_VAR 0 7
58183: PUSH
58184: LD_VAR 0 6
58188: PPUSH
58189: LD_VAR 0 8
58193: PPUSH
58194: LD_VAR 0 9
58198: PUSH
58199: LD_VAR 0 10
58203: PLUS
58204: PPUSH
58205: CALL_OW 273
58209: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
58210: LD_VAR 0 5
58214: PPUSH
58215: LD_VAR 0 7
58219: PPUSH
58220: CALL_OW 488
58224: PUSH
58225: LD_VAR 0 5
58229: PPUSH
58230: LD_VAR 0 7
58234: PPUSH
58235: CALL_OW 428
58239: PPUSH
58240: CALL_OW 247
58244: PUSH
58245: LD_INT 3
58247: PUSH
58248: LD_INT 2
58250: PUSH
58251: EMPTY
58252: LIST
58253: LIST
58254: IN
58255: NOT
58256: AND
58257: IFFALSE 58301
// begin ComMoveXY ( unit , _x , _y ) ;
58259: LD_VAR 0 1
58263: PPUSH
58264: LD_VAR 0 5
58268: PPUSH
58269: LD_VAR 0 7
58273: PPUSH
58274: CALL_OW 111
// result := [ _x , _y ] ;
58278: LD_ADDR_VAR 0 3
58282: PUSH
58283: LD_VAR 0 5
58287: PUSH
58288: LD_VAR 0 7
58292: PUSH
58293: EMPTY
58294: LIST
58295: LIST
58296: ST_TO_ADDR
// exit ;
58297: POP
58298: POP
58299: GO 58305
// end ; end ;
58301: GO 58145
58303: POP
58304: POP
// end ;
58305: LD_VAR 0 3
58309: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
58310: LD_INT 0
58312: PPUSH
58313: PPUSH
58314: PPUSH
// result := 0 ;
58315: LD_ADDR_VAR 0 3
58319: PUSH
58320: LD_INT 0
58322: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
58323: LD_VAR 0 1
58327: PUSH
58328: LD_INT 0
58330: LESS
58331: PUSH
58332: LD_VAR 0 1
58336: PUSH
58337: LD_INT 8
58339: GREATER
58340: OR
58341: PUSH
58342: LD_VAR 0 2
58346: PUSH
58347: LD_INT 0
58349: LESS
58350: OR
58351: PUSH
58352: LD_VAR 0 2
58356: PUSH
58357: LD_INT 8
58359: GREATER
58360: OR
58361: IFFALSE 58365
// exit ;
58363: GO 58440
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
58365: LD_ADDR_VAR 0 4
58369: PUSH
58370: LD_INT 22
58372: PUSH
58373: LD_VAR 0 2
58377: PUSH
58378: EMPTY
58379: LIST
58380: LIST
58381: PPUSH
58382: CALL_OW 69
58386: PUSH
58387: FOR_IN
58388: IFFALSE 58438
// begin un := UnitShoot ( i ) ;
58390: LD_ADDR_VAR 0 5
58394: PUSH
58395: LD_VAR 0 4
58399: PPUSH
58400: CALL_OW 504
58404: ST_TO_ADDR
// if GetSide ( un ) = side1 then
58405: LD_VAR 0 5
58409: PPUSH
58410: CALL_OW 255
58414: PUSH
58415: LD_VAR 0 1
58419: EQUAL
58420: IFFALSE 58436
// begin result := un ;
58422: LD_ADDR_VAR 0 3
58426: PUSH
58427: LD_VAR 0 5
58431: ST_TO_ADDR
// exit ;
58432: POP
58433: POP
58434: GO 58440
// end ; end ;
58436: GO 58387
58438: POP
58439: POP
// end ;
58440: LD_VAR 0 3
58444: RET
// export function GetCargoBay ( units ) ; begin
58445: LD_INT 0
58447: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
58448: LD_ADDR_VAR 0 2
58452: PUSH
58453: LD_VAR 0 1
58457: PPUSH
58458: LD_INT 2
58460: PUSH
58461: LD_INT 34
58463: PUSH
58464: LD_INT 12
58466: PUSH
58467: EMPTY
58468: LIST
58469: LIST
58470: PUSH
58471: LD_INT 34
58473: PUSH
58474: LD_INT 51
58476: PUSH
58477: EMPTY
58478: LIST
58479: LIST
58480: PUSH
58481: LD_INT 34
58483: PUSH
58484: LD_INT 32
58486: PUSH
58487: EMPTY
58488: LIST
58489: LIST
58490: PUSH
58491: LD_INT 34
58493: PUSH
58494: LD_INT 89
58496: PUSH
58497: EMPTY
58498: LIST
58499: LIST
58500: PUSH
58501: EMPTY
58502: LIST
58503: LIST
58504: LIST
58505: LIST
58506: LIST
58507: PPUSH
58508: CALL_OW 72
58512: ST_TO_ADDR
// end ;
58513: LD_VAR 0 2
58517: RET
// export function Negate ( value ) ; begin
58518: LD_INT 0
58520: PPUSH
// result := not value ;
58521: LD_ADDR_VAR 0 2
58525: PUSH
58526: LD_VAR 0 1
58530: NOT
58531: ST_TO_ADDR
// end ;
58532: LD_VAR 0 2
58536: RET
// export function Inc ( value ) ; begin
58537: LD_INT 0
58539: PPUSH
// result := value + 1 ;
58540: LD_ADDR_VAR 0 2
58544: PUSH
58545: LD_VAR 0 1
58549: PUSH
58550: LD_INT 1
58552: PLUS
58553: ST_TO_ADDR
// end ;
58554: LD_VAR 0 2
58558: RET
// export function Dec ( value ) ; begin
58559: LD_INT 0
58561: PPUSH
// result := value - 1 ;
58562: LD_ADDR_VAR 0 2
58566: PUSH
58567: LD_VAR 0 1
58571: PUSH
58572: LD_INT 1
58574: MINUS
58575: ST_TO_ADDR
// end ;
58576: LD_VAR 0 2
58580: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58581: LD_INT 0
58583: PPUSH
58584: PPUSH
58585: PPUSH
58586: PPUSH
58587: PPUSH
58588: PPUSH
58589: PPUSH
58590: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58591: LD_VAR 0 1
58595: PPUSH
58596: LD_VAR 0 2
58600: PPUSH
58601: CALL_OW 488
58605: NOT
58606: PUSH
58607: LD_VAR 0 3
58611: PPUSH
58612: LD_VAR 0 4
58616: PPUSH
58617: CALL_OW 488
58621: NOT
58622: OR
58623: IFFALSE 58636
// begin result := - 1 ;
58625: LD_ADDR_VAR 0 5
58629: PUSH
58630: LD_INT 1
58632: NEG
58633: ST_TO_ADDR
// exit ;
58634: GO 58871
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58636: LD_ADDR_VAR 0 12
58640: PUSH
58641: LD_VAR 0 1
58645: PPUSH
58646: LD_VAR 0 2
58650: PPUSH
58651: LD_VAR 0 3
58655: PPUSH
58656: LD_VAR 0 4
58660: PPUSH
58661: CALL 57721 0 4
58665: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58666: LD_ADDR_VAR 0 11
58670: PUSH
58671: LD_VAR 0 1
58675: PPUSH
58676: LD_VAR 0 2
58680: PPUSH
58681: LD_VAR 0 12
58685: PUSH
58686: LD_INT 1
58688: ARRAY
58689: PPUSH
58690: LD_VAR 0 12
58694: PUSH
58695: LD_INT 2
58697: ARRAY
58698: PPUSH
58699: CALL_OW 298
58703: ST_TO_ADDR
// distance := 9999 ;
58704: LD_ADDR_VAR 0 10
58708: PUSH
58709: LD_INT 9999
58711: ST_TO_ADDR
// for i := 0 to 5 do
58712: LD_ADDR_VAR 0 6
58716: PUSH
58717: DOUBLE
58718: LD_INT 0
58720: DEC
58721: ST_TO_ADDR
58722: LD_INT 5
58724: PUSH
58725: FOR_TO
58726: IFFALSE 58869
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58728: LD_ADDR_VAR 0 7
58732: PUSH
58733: LD_VAR 0 1
58737: PPUSH
58738: LD_VAR 0 6
58742: PPUSH
58743: LD_VAR 0 11
58747: PPUSH
58748: CALL_OW 272
58752: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58753: LD_ADDR_VAR 0 8
58757: PUSH
58758: LD_VAR 0 2
58762: PPUSH
58763: LD_VAR 0 6
58767: PPUSH
58768: LD_VAR 0 11
58772: PPUSH
58773: CALL_OW 273
58777: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58778: LD_VAR 0 7
58782: PPUSH
58783: LD_VAR 0 8
58787: PPUSH
58788: CALL_OW 488
58792: NOT
58793: IFFALSE 58797
// continue ;
58795: GO 58725
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58797: LD_ADDR_VAR 0 9
58801: PUSH
58802: LD_VAR 0 12
58806: PUSH
58807: LD_INT 1
58809: ARRAY
58810: PPUSH
58811: LD_VAR 0 12
58815: PUSH
58816: LD_INT 2
58818: ARRAY
58819: PPUSH
58820: LD_VAR 0 7
58824: PPUSH
58825: LD_VAR 0 8
58829: PPUSH
58830: CALL_OW 298
58834: ST_TO_ADDR
// if tmp < distance then
58835: LD_VAR 0 9
58839: PUSH
58840: LD_VAR 0 10
58844: LESS
58845: IFFALSE 58867
// begin result := i ;
58847: LD_ADDR_VAR 0 5
58851: PUSH
58852: LD_VAR 0 6
58856: ST_TO_ADDR
// distance := tmp ;
58857: LD_ADDR_VAR 0 10
58861: PUSH
58862: LD_VAR 0 9
58866: ST_TO_ADDR
// end ; end ;
58867: GO 58725
58869: POP
58870: POP
// end ;
58871: LD_VAR 0 5
58875: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58876: LD_INT 0
58878: PPUSH
58879: PPUSH
// if not driver or not IsInUnit ( driver ) then
58880: LD_VAR 0 1
58884: NOT
58885: PUSH
58886: LD_VAR 0 1
58890: PPUSH
58891: CALL_OW 310
58895: NOT
58896: OR
58897: IFFALSE 58901
// exit ;
58899: GO 58991
// vehicle := IsInUnit ( driver ) ;
58901: LD_ADDR_VAR 0 3
58905: PUSH
58906: LD_VAR 0 1
58910: PPUSH
58911: CALL_OW 310
58915: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58916: LD_VAR 0 1
58920: PPUSH
58921: LD_STRING \
58923: PUSH
58924: LD_INT 0
58926: PUSH
58927: LD_INT 0
58929: PUSH
58930: LD_INT 0
58932: PUSH
58933: LD_INT 0
58935: PUSH
58936: LD_INT 0
58938: PUSH
58939: LD_INT 0
58941: PUSH
58942: EMPTY
58943: LIST
58944: LIST
58945: LIST
58946: LIST
58947: LIST
58948: LIST
58949: LIST
58950: PUSH
58951: LD_STRING E
58953: PUSH
58954: LD_INT 0
58956: PUSH
58957: LD_INT 0
58959: PUSH
58960: LD_VAR 0 3
58964: PUSH
58965: LD_INT 0
58967: PUSH
58968: LD_INT 0
58970: PUSH
58971: LD_INT 0
58973: PUSH
58974: EMPTY
58975: LIST
58976: LIST
58977: LIST
58978: LIST
58979: LIST
58980: LIST
58981: LIST
58982: PUSH
58983: EMPTY
58984: LIST
58985: LIST
58986: PPUSH
58987: CALL_OW 446
// end ;
58991: LD_VAR 0 2
58995: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58996: LD_INT 0
58998: PPUSH
58999: PPUSH
// if not driver or not IsInUnit ( driver ) then
59000: LD_VAR 0 1
59004: NOT
59005: PUSH
59006: LD_VAR 0 1
59010: PPUSH
59011: CALL_OW 310
59015: NOT
59016: OR
59017: IFFALSE 59021
// exit ;
59019: GO 59111
// vehicle := IsInUnit ( driver ) ;
59021: LD_ADDR_VAR 0 3
59025: PUSH
59026: LD_VAR 0 1
59030: PPUSH
59031: CALL_OW 310
59035: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59036: LD_VAR 0 1
59040: PPUSH
59041: LD_STRING \
59043: PUSH
59044: LD_INT 0
59046: PUSH
59047: LD_INT 0
59049: PUSH
59050: LD_INT 0
59052: PUSH
59053: LD_INT 0
59055: PUSH
59056: LD_INT 0
59058: PUSH
59059: LD_INT 0
59061: PUSH
59062: EMPTY
59063: LIST
59064: LIST
59065: LIST
59066: LIST
59067: LIST
59068: LIST
59069: LIST
59070: PUSH
59071: LD_STRING E
59073: PUSH
59074: LD_INT 0
59076: PUSH
59077: LD_INT 0
59079: PUSH
59080: LD_VAR 0 3
59084: PUSH
59085: LD_INT 0
59087: PUSH
59088: LD_INT 0
59090: PUSH
59091: LD_INT 0
59093: PUSH
59094: EMPTY
59095: LIST
59096: LIST
59097: LIST
59098: LIST
59099: LIST
59100: LIST
59101: LIST
59102: PUSH
59103: EMPTY
59104: LIST
59105: LIST
59106: PPUSH
59107: CALL_OW 447
// end ;
59111: LD_VAR 0 2
59115: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
59116: LD_INT 0
59118: PPUSH
59119: PPUSH
59120: PPUSH
// tmp := [ ] ;
59121: LD_ADDR_VAR 0 5
59125: PUSH
59126: EMPTY
59127: ST_TO_ADDR
// for i in units do
59128: LD_ADDR_VAR 0 4
59132: PUSH
59133: LD_VAR 0 1
59137: PUSH
59138: FOR_IN
59139: IFFALSE 59177
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
59141: LD_ADDR_VAR 0 5
59145: PUSH
59146: LD_VAR 0 5
59150: PPUSH
59151: LD_VAR 0 5
59155: PUSH
59156: LD_INT 1
59158: PLUS
59159: PPUSH
59160: LD_VAR 0 4
59164: PPUSH
59165: CALL_OW 256
59169: PPUSH
59170: CALL_OW 2
59174: ST_TO_ADDR
59175: GO 59138
59177: POP
59178: POP
// if not tmp then
59179: LD_VAR 0 5
59183: NOT
59184: IFFALSE 59188
// exit ;
59186: GO 59236
// if asc then
59188: LD_VAR 0 2
59192: IFFALSE 59216
// result := SortListByListAsc ( units , tmp ) else
59194: LD_ADDR_VAR 0 3
59198: PUSH
59199: LD_VAR 0 1
59203: PPUSH
59204: LD_VAR 0 5
59208: PPUSH
59209: CALL_OW 76
59213: ST_TO_ADDR
59214: GO 59236
// result := SortListByListDesc ( units , tmp ) ;
59216: LD_ADDR_VAR 0 3
59220: PUSH
59221: LD_VAR 0 1
59225: PPUSH
59226: LD_VAR 0 5
59230: PPUSH
59231: CALL_OW 77
59235: ST_TO_ADDR
// end ;
59236: LD_VAR 0 3
59240: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
59241: LD_INT 0
59243: PPUSH
59244: PPUSH
// task := GetTaskList ( mech ) ;
59245: LD_ADDR_VAR 0 4
59249: PUSH
59250: LD_VAR 0 1
59254: PPUSH
59255: CALL_OW 437
59259: ST_TO_ADDR
// if not task then
59260: LD_VAR 0 4
59264: NOT
59265: IFFALSE 59269
// exit ;
59267: GO 59311
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
59269: LD_ADDR_VAR 0 3
59273: PUSH
59274: LD_VAR 0 4
59278: PUSH
59279: LD_INT 1
59281: ARRAY
59282: PUSH
59283: LD_INT 1
59285: ARRAY
59286: PUSH
59287: LD_STRING r
59289: EQUAL
59290: PUSH
59291: LD_VAR 0 4
59295: PUSH
59296: LD_INT 1
59298: ARRAY
59299: PUSH
59300: LD_INT 4
59302: ARRAY
59303: PUSH
59304: LD_VAR 0 2
59308: EQUAL
59309: AND
59310: ST_TO_ADDR
// end ;
59311: LD_VAR 0 3
59315: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
59316: LD_INT 0
59318: PPUSH
// SetDir ( unit , d ) ;
59319: LD_VAR 0 1
59323: PPUSH
59324: LD_VAR 0 4
59328: PPUSH
59329: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
59333: LD_VAR 0 1
59337: PPUSH
59338: LD_VAR 0 2
59342: PPUSH
59343: LD_VAR 0 3
59347: PPUSH
59348: LD_VAR 0 5
59352: PPUSH
59353: CALL_OW 48
// end ;
59357: LD_VAR 0 6
59361: RET
// export function ToNaturalNumber ( number ) ; begin
59362: LD_INT 0
59364: PPUSH
// result := number div 1 ;
59365: LD_ADDR_VAR 0 2
59369: PUSH
59370: LD_VAR 0 1
59374: PUSH
59375: LD_INT 1
59377: DIV
59378: ST_TO_ADDR
// if number < 0 then
59379: LD_VAR 0 1
59383: PUSH
59384: LD_INT 0
59386: LESS
59387: IFFALSE 59397
// result := 0 ;
59389: LD_ADDR_VAR 0 2
59393: PUSH
59394: LD_INT 0
59396: ST_TO_ADDR
// end ;
59397: LD_VAR 0 2
59401: RET
// export function SortByClass ( units , class ) ; var un ; begin
59402: LD_INT 0
59404: PPUSH
59405: PPUSH
// if not units or not class then
59406: LD_VAR 0 1
59410: NOT
59411: PUSH
59412: LD_VAR 0 2
59416: NOT
59417: OR
59418: IFFALSE 59422
// exit ;
59420: GO 59517
// result := [ ] ;
59422: LD_ADDR_VAR 0 3
59426: PUSH
59427: EMPTY
59428: ST_TO_ADDR
// for un in units do
59429: LD_ADDR_VAR 0 4
59433: PUSH
59434: LD_VAR 0 1
59438: PUSH
59439: FOR_IN
59440: IFFALSE 59515
// if GetClass ( un ) = class then
59442: LD_VAR 0 4
59446: PPUSH
59447: CALL_OW 257
59451: PUSH
59452: LD_VAR 0 2
59456: EQUAL
59457: IFFALSE 59484
// result := Insert ( result , 1 , un ) else
59459: LD_ADDR_VAR 0 3
59463: PUSH
59464: LD_VAR 0 3
59468: PPUSH
59469: LD_INT 1
59471: PPUSH
59472: LD_VAR 0 4
59476: PPUSH
59477: CALL_OW 2
59481: ST_TO_ADDR
59482: GO 59513
// result := Replace ( result , result + 1 , un ) ;
59484: LD_ADDR_VAR 0 3
59488: PUSH
59489: LD_VAR 0 3
59493: PPUSH
59494: LD_VAR 0 3
59498: PUSH
59499: LD_INT 1
59501: PLUS
59502: PPUSH
59503: LD_VAR 0 4
59507: PPUSH
59508: CALL_OW 1
59512: ST_TO_ADDR
59513: GO 59439
59515: POP
59516: POP
// end ;
59517: LD_VAR 0 3
59521: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59522: LD_INT 0
59524: PPUSH
59525: PPUSH
59526: PPUSH
59527: PPUSH
59528: PPUSH
59529: PPUSH
59530: PPUSH
// result := [ ] ;
59531: LD_ADDR_VAR 0 4
59535: PUSH
59536: EMPTY
59537: ST_TO_ADDR
// if x - r < 0 then
59538: LD_VAR 0 1
59542: PUSH
59543: LD_VAR 0 3
59547: MINUS
59548: PUSH
59549: LD_INT 0
59551: LESS
59552: IFFALSE 59564
// min_x := 0 else
59554: LD_ADDR_VAR 0 8
59558: PUSH
59559: LD_INT 0
59561: ST_TO_ADDR
59562: GO 59580
// min_x := x - r ;
59564: LD_ADDR_VAR 0 8
59568: PUSH
59569: LD_VAR 0 1
59573: PUSH
59574: LD_VAR 0 3
59578: MINUS
59579: ST_TO_ADDR
// if y - r < 0 then
59580: LD_VAR 0 2
59584: PUSH
59585: LD_VAR 0 3
59589: MINUS
59590: PUSH
59591: LD_INT 0
59593: LESS
59594: IFFALSE 59606
// min_y := 0 else
59596: LD_ADDR_VAR 0 7
59600: PUSH
59601: LD_INT 0
59603: ST_TO_ADDR
59604: GO 59622
// min_y := y - r ;
59606: LD_ADDR_VAR 0 7
59610: PUSH
59611: LD_VAR 0 2
59615: PUSH
59616: LD_VAR 0 3
59620: MINUS
59621: ST_TO_ADDR
// max_x := x + r ;
59622: LD_ADDR_VAR 0 9
59626: PUSH
59627: LD_VAR 0 1
59631: PUSH
59632: LD_VAR 0 3
59636: PLUS
59637: ST_TO_ADDR
// max_y := y + r ;
59638: LD_ADDR_VAR 0 10
59642: PUSH
59643: LD_VAR 0 2
59647: PUSH
59648: LD_VAR 0 3
59652: PLUS
59653: ST_TO_ADDR
// for _x = min_x to max_x do
59654: LD_ADDR_VAR 0 5
59658: PUSH
59659: DOUBLE
59660: LD_VAR 0 8
59664: DEC
59665: ST_TO_ADDR
59666: LD_VAR 0 9
59670: PUSH
59671: FOR_TO
59672: IFFALSE 59773
// for _y = min_y to max_y do
59674: LD_ADDR_VAR 0 6
59678: PUSH
59679: DOUBLE
59680: LD_VAR 0 7
59684: DEC
59685: ST_TO_ADDR
59686: LD_VAR 0 10
59690: PUSH
59691: FOR_TO
59692: IFFALSE 59769
// begin if not ValidHex ( _x , _y ) then
59694: LD_VAR 0 5
59698: PPUSH
59699: LD_VAR 0 6
59703: PPUSH
59704: CALL_OW 488
59708: NOT
59709: IFFALSE 59713
// continue ;
59711: GO 59691
// if GetResourceTypeXY ( _x , _y ) then
59713: LD_VAR 0 5
59717: PPUSH
59718: LD_VAR 0 6
59722: PPUSH
59723: CALL_OW 283
59727: IFFALSE 59767
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59729: LD_ADDR_VAR 0 4
59733: PUSH
59734: LD_VAR 0 4
59738: PPUSH
59739: LD_VAR 0 4
59743: PUSH
59744: LD_INT 1
59746: PLUS
59747: PPUSH
59748: LD_VAR 0 5
59752: PUSH
59753: LD_VAR 0 6
59757: PUSH
59758: EMPTY
59759: LIST
59760: LIST
59761: PPUSH
59762: CALL_OW 1
59766: ST_TO_ADDR
// end ;
59767: GO 59691
59769: POP
59770: POP
59771: GO 59671
59773: POP
59774: POP
// end ;
59775: LD_VAR 0 4
59779: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59780: LD_INT 0
59782: PPUSH
59783: PPUSH
59784: PPUSH
59785: PPUSH
59786: PPUSH
59787: PPUSH
59788: PPUSH
59789: PPUSH
// if not units then
59790: LD_VAR 0 1
59794: NOT
59795: IFFALSE 59799
// exit ;
59797: GO 60323
// result := UnitFilter ( units , [ f_ok ] ) ;
59799: LD_ADDR_VAR 0 3
59803: PUSH
59804: LD_VAR 0 1
59808: PPUSH
59809: LD_INT 50
59811: PUSH
59812: EMPTY
59813: LIST
59814: PPUSH
59815: CALL_OW 72
59819: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59820: LD_ADDR_VAR 0 8
59824: PUSH
59825: LD_VAR 0 1
59829: PUSH
59830: LD_INT 1
59832: ARRAY
59833: PPUSH
59834: CALL_OW 255
59838: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59839: LD_ADDR_VAR 0 10
59843: PUSH
59844: LD_INT 29
59846: PUSH
59847: LD_INT 91
59849: PUSH
59850: LD_INT 49
59852: PUSH
59853: EMPTY
59854: LIST
59855: LIST
59856: LIST
59857: ST_TO_ADDR
// if not result then
59858: LD_VAR 0 3
59862: NOT
59863: IFFALSE 59867
// exit ;
59865: GO 60323
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59867: LD_ADDR_VAR 0 5
59871: PUSH
59872: LD_INT 81
59874: PUSH
59875: LD_VAR 0 8
59879: PUSH
59880: EMPTY
59881: LIST
59882: LIST
59883: PPUSH
59884: CALL_OW 69
59888: ST_TO_ADDR
// for i in result do
59889: LD_ADDR_VAR 0 4
59893: PUSH
59894: LD_VAR 0 3
59898: PUSH
59899: FOR_IN
59900: IFFALSE 60321
// begin tag := GetTag ( i ) + 1 ;
59902: LD_ADDR_VAR 0 9
59906: PUSH
59907: LD_VAR 0 4
59911: PPUSH
59912: CALL_OW 110
59916: PUSH
59917: LD_INT 1
59919: PLUS
59920: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
59921: LD_ADDR_VAR 0 7
59925: PUSH
59926: LD_VAR 0 4
59930: PPUSH
59931: CALL_OW 250
59935: PPUSH
59936: LD_VAR 0 4
59940: PPUSH
59941: CALL_OW 251
59945: PPUSH
59946: LD_INT 6
59948: PPUSH
59949: CALL 59522 0 3
59953: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
59954: LD_VAR 0 4
59958: PPUSH
59959: CALL_OW 247
59963: PUSH
59964: LD_INT 2
59966: EQUAL
59967: PUSH
59968: LD_VAR 0 7
59972: AND
59973: PUSH
59974: LD_VAR 0 4
59978: PPUSH
59979: CALL_OW 264
59983: PUSH
59984: LD_VAR 0 10
59988: IN
59989: NOT
59990: AND
59991: IFFALSE 60030
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
59993: LD_VAR 0 4
59997: PPUSH
59998: LD_VAR 0 7
60002: PUSH
60003: LD_INT 1
60005: ARRAY
60006: PUSH
60007: LD_INT 1
60009: ARRAY
60010: PPUSH
60011: LD_VAR 0 7
60015: PUSH
60016: LD_INT 1
60018: ARRAY
60019: PUSH
60020: LD_INT 2
60022: ARRAY
60023: PPUSH
60024: CALL_OW 116
60028: GO 60319
// if path > tag then
60030: LD_VAR 0 2
60034: PUSH
60035: LD_VAR 0 9
60039: GREATER
60040: IFFALSE 60248
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
60042: LD_ADDR_VAR 0 6
60046: PUSH
60047: LD_VAR 0 5
60051: PPUSH
60052: LD_INT 91
60054: PUSH
60055: LD_VAR 0 4
60059: PUSH
60060: LD_INT 8
60062: PUSH
60063: EMPTY
60064: LIST
60065: LIST
60066: LIST
60067: PPUSH
60068: CALL_OW 72
60072: ST_TO_ADDR
// if nearEnemy then
60073: LD_VAR 0 6
60077: IFFALSE 60146
// begin if GetWeapon ( i ) = ru_time_lapser then
60079: LD_VAR 0 4
60083: PPUSH
60084: CALL_OW 264
60088: PUSH
60089: LD_INT 49
60091: EQUAL
60092: IFFALSE 60120
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
60094: LD_VAR 0 4
60098: PPUSH
60099: LD_VAR 0 6
60103: PPUSH
60104: LD_VAR 0 4
60108: PPUSH
60109: CALL_OW 74
60113: PPUSH
60114: CALL_OW 112
60118: GO 60144
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
60120: LD_VAR 0 4
60124: PPUSH
60125: LD_VAR 0 6
60129: PPUSH
60130: LD_VAR 0 4
60134: PPUSH
60135: CALL_OW 74
60139: PPUSH
60140: CALL_OW 115
// end else
60144: GO 60246
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
60146: LD_VAR 0 4
60150: PPUSH
60151: LD_VAR 0 2
60155: PUSH
60156: LD_VAR 0 9
60160: ARRAY
60161: PUSH
60162: LD_INT 1
60164: ARRAY
60165: PPUSH
60166: LD_VAR 0 2
60170: PUSH
60171: LD_VAR 0 9
60175: ARRAY
60176: PUSH
60177: LD_INT 2
60179: ARRAY
60180: PPUSH
60181: CALL_OW 297
60185: PUSH
60186: LD_INT 6
60188: GREATER
60189: IFFALSE 60232
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
60191: LD_VAR 0 4
60195: PPUSH
60196: LD_VAR 0 2
60200: PUSH
60201: LD_VAR 0 9
60205: ARRAY
60206: PUSH
60207: LD_INT 1
60209: ARRAY
60210: PPUSH
60211: LD_VAR 0 2
60215: PUSH
60216: LD_VAR 0 9
60220: ARRAY
60221: PUSH
60222: LD_INT 2
60224: ARRAY
60225: PPUSH
60226: CALL_OW 114
60230: GO 60246
// SetTag ( i , tag ) ;
60232: LD_VAR 0 4
60236: PPUSH
60237: LD_VAR 0 9
60241: PPUSH
60242: CALL_OW 109
// end else
60246: GO 60319
// if enemy then
60248: LD_VAR 0 5
60252: IFFALSE 60319
// begin if GetWeapon ( i ) = ru_time_lapser then
60254: LD_VAR 0 4
60258: PPUSH
60259: CALL_OW 264
60263: PUSH
60264: LD_INT 49
60266: EQUAL
60267: IFFALSE 60295
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60269: LD_VAR 0 4
60273: PPUSH
60274: LD_VAR 0 5
60278: PPUSH
60279: LD_VAR 0 4
60283: PPUSH
60284: CALL_OW 74
60288: PPUSH
60289: CALL_OW 112
60293: GO 60319
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
60295: LD_VAR 0 4
60299: PPUSH
60300: LD_VAR 0 5
60304: PPUSH
60305: LD_VAR 0 4
60309: PPUSH
60310: CALL_OW 74
60314: PPUSH
60315: CALL_OW 115
// end ; end ;
60319: GO 59899
60321: POP
60322: POP
// end ;
60323: LD_VAR 0 3
60327: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
60328: LD_INT 0
60330: PPUSH
60331: PPUSH
60332: PPUSH
// if not unit or IsInUnit ( unit ) then
60333: LD_VAR 0 1
60337: NOT
60338: PUSH
60339: LD_VAR 0 1
60343: PPUSH
60344: CALL_OW 310
60348: OR
60349: IFFALSE 60353
// exit ;
60351: GO 60444
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
60353: LD_ADDR_VAR 0 4
60357: PUSH
60358: LD_VAR 0 1
60362: PPUSH
60363: CALL_OW 250
60367: PPUSH
60368: LD_VAR 0 2
60372: PPUSH
60373: LD_INT 1
60375: PPUSH
60376: CALL_OW 272
60380: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
60381: LD_ADDR_VAR 0 5
60385: PUSH
60386: LD_VAR 0 1
60390: PPUSH
60391: CALL_OW 251
60395: PPUSH
60396: LD_VAR 0 2
60400: PPUSH
60401: LD_INT 1
60403: PPUSH
60404: CALL_OW 273
60408: ST_TO_ADDR
// if ValidHex ( x , y ) then
60409: LD_VAR 0 4
60413: PPUSH
60414: LD_VAR 0 5
60418: PPUSH
60419: CALL_OW 488
60423: IFFALSE 60444
// ComTurnXY ( unit , x , y ) ;
60425: LD_VAR 0 1
60429: PPUSH
60430: LD_VAR 0 4
60434: PPUSH
60435: LD_VAR 0 5
60439: PPUSH
60440: CALL_OW 118
// end ;
60444: LD_VAR 0 3
60448: RET
// export function SeeUnits ( side , units ) ; var i ; begin
60449: LD_INT 0
60451: PPUSH
60452: PPUSH
// result := false ;
60453: LD_ADDR_VAR 0 3
60457: PUSH
60458: LD_INT 0
60460: ST_TO_ADDR
// if not units then
60461: LD_VAR 0 2
60465: NOT
60466: IFFALSE 60470
// exit ;
60468: GO 60515
// for i in units do
60470: LD_ADDR_VAR 0 4
60474: PUSH
60475: LD_VAR 0 2
60479: PUSH
60480: FOR_IN
60481: IFFALSE 60513
// if See ( side , i ) then
60483: LD_VAR 0 1
60487: PPUSH
60488: LD_VAR 0 4
60492: PPUSH
60493: CALL_OW 292
60497: IFFALSE 60511
// begin result := true ;
60499: LD_ADDR_VAR 0 3
60503: PUSH
60504: LD_INT 1
60506: ST_TO_ADDR
// exit ;
60507: POP
60508: POP
60509: GO 60515
// end ;
60511: GO 60480
60513: POP
60514: POP
// end ;
60515: LD_VAR 0 3
60519: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60520: LD_INT 0
60522: PPUSH
60523: PPUSH
60524: PPUSH
60525: PPUSH
// if not unit or not points then
60526: LD_VAR 0 1
60530: NOT
60531: PUSH
60532: LD_VAR 0 2
60536: NOT
60537: OR
60538: IFFALSE 60542
// exit ;
60540: GO 60632
// dist := 99999 ;
60542: LD_ADDR_VAR 0 5
60546: PUSH
60547: LD_INT 99999
60549: ST_TO_ADDR
// for i in points do
60550: LD_ADDR_VAR 0 4
60554: PUSH
60555: LD_VAR 0 2
60559: PUSH
60560: FOR_IN
60561: IFFALSE 60630
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60563: LD_ADDR_VAR 0 6
60567: PUSH
60568: LD_VAR 0 1
60572: PPUSH
60573: LD_VAR 0 4
60577: PUSH
60578: LD_INT 1
60580: ARRAY
60581: PPUSH
60582: LD_VAR 0 4
60586: PUSH
60587: LD_INT 2
60589: ARRAY
60590: PPUSH
60591: CALL_OW 297
60595: ST_TO_ADDR
// if tmpDist < dist then
60596: LD_VAR 0 6
60600: PUSH
60601: LD_VAR 0 5
60605: LESS
60606: IFFALSE 60628
// begin result := i ;
60608: LD_ADDR_VAR 0 3
60612: PUSH
60613: LD_VAR 0 4
60617: ST_TO_ADDR
// dist := tmpDist ;
60618: LD_ADDR_VAR 0 5
60622: PUSH
60623: LD_VAR 0 6
60627: ST_TO_ADDR
// end ; end ;
60628: GO 60560
60630: POP
60631: POP
// end ;
60632: LD_VAR 0 3
60636: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60637: LD_INT 0
60639: PPUSH
// uc_side := side ;
60640: LD_ADDR_OWVAR 20
60644: PUSH
60645: LD_VAR 0 1
60649: ST_TO_ADDR
// uc_nation := 3 ;
60650: LD_ADDR_OWVAR 21
60654: PUSH
60655: LD_INT 3
60657: ST_TO_ADDR
// vc_chassis := 25 ;
60658: LD_ADDR_OWVAR 37
60662: PUSH
60663: LD_INT 25
60665: ST_TO_ADDR
// vc_engine := engine_siberite ;
60666: LD_ADDR_OWVAR 39
60670: PUSH
60671: LD_INT 3
60673: ST_TO_ADDR
// vc_control := control_computer ;
60674: LD_ADDR_OWVAR 38
60678: PUSH
60679: LD_INT 3
60681: ST_TO_ADDR
// vc_weapon := 59 ;
60682: LD_ADDR_OWVAR 40
60686: PUSH
60687: LD_INT 59
60689: ST_TO_ADDR
// result := CreateVehicle ;
60690: LD_ADDR_VAR 0 5
60694: PUSH
60695: CALL_OW 45
60699: ST_TO_ADDR
// SetDir ( result , d ) ;
60700: LD_VAR 0 5
60704: PPUSH
60705: LD_VAR 0 4
60709: PPUSH
60710: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60714: LD_VAR 0 5
60718: PPUSH
60719: LD_VAR 0 2
60723: PPUSH
60724: LD_VAR 0 3
60728: PPUSH
60729: LD_INT 0
60731: PPUSH
60732: CALL_OW 48
// end ;
60736: LD_VAR 0 5
60740: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60741: LD_INT 0
60743: PPUSH
60744: PPUSH
60745: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60746: LD_ADDR_VAR 0 2
60750: PUSH
60751: LD_INT 0
60753: PUSH
60754: LD_INT 0
60756: PUSH
60757: LD_INT 0
60759: PUSH
60760: LD_INT 0
60762: PUSH
60763: EMPTY
60764: LIST
60765: LIST
60766: LIST
60767: LIST
60768: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60769: LD_VAR 0 1
60773: NOT
60774: PUSH
60775: LD_VAR 0 1
60779: PPUSH
60780: CALL_OW 264
60784: PUSH
60785: LD_INT 12
60787: PUSH
60788: LD_INT 51
60790: PUSH
60791: LD_INT 32
60793: PUSH
60794: LD_INT 89
60796: PUSH
60797: EMPTY
60798: LIST
60799: LIST
60800: LIST
60801: LIST
60802: IN
60803: NOT
60804: OR
60805: IFFALSE 60809
// exit ;
60807: GO 60907
// for i := 1 to 3 do
60809: LD_ADDR_VAR 0 3
60813: PUSH
60814: DOUBLE
60815: LD_INT 1
60817: DEC
60818: ST_TO_ADDR
60819: LD_INT 3
60821: PUSH
60822: FOR_TO
60823: IFFALSE 60905
// begin tmp := GetCargo ( cargo , i ) ;
60825: LD_ADDR_VAR 0 4
60829: PUSH
60830: LD_VAR 0 1
60834: PPUSH
60835: LD_VAR 0 3
60839: PPUSH
60840: CALL_OW 289
60844: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
60845: LD_ADDR_VAR 0 2
60849: PUSH
60850: LD_VAR 0 2
60854: PPUSH
60855: LD_VAR 0 3
60859: PPUSH
60860: LD_VAR 0 4
60864: PPUSH
60865: CALL_OW 1
60869: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
60870: LD_ADDR_VAR 0 2
60874: PUSH
60875: LD_VAR 0 2
60879: PPUSH
60880: LD_INT 4
60882: PPUSH
60883: LD_VAR 0 2
60887: PUSH
60888: LD_INT 4
60890: ARRAY
60891: PUSH
60892: LD_VAR 0 4
60896: PLUS
60897: PPUSH
60898: CALL_OW 1
60902: ST_TO_ADDR
// end ;
60903: GO 60822
60905: POP
60906: POP
// end ;
60907: LD_VAR 0 2
60911: RET
// export function Length ( array ) ; begin
60912: LD_INT 0
60914: PPUSH
// result := array + 0 ;
60915: LD_ADDR_VAR 0 2
60919: PUSH
60920: LD_VAR 0 1
60924: PUSH
60925: LD_INT 0
60927: PLUS
60928: ST_TO_ADDR
// end ;
60929: LD_VAR 0 2
60933: RET
// export function PrepareArray ( array ) ; begin
60934: LD_INT 0
60936: PPUSH
// result := array diff 0 ;
60937: LD_ADDR_VAR 0 2
60941: PUSH
60942: LD_VAR 0 1
60946: PUSH
60947: LD_INT 0
60949: DIFF
60950: ST_TO_ADDR
// if not result [ 1 ] then
60951: LD_VAR 0 2
60955: PUSH
60956: LD_INT 1
60958: ARRAY
60959: NOT
60960: IFFALSE 60980
// result := Delete ( result , 1 ) ;
60962: LD_ADDR_VAR 0 2
60966: PUSH
60967: LD_VAR 0 2
60971: PPUSH
60972: LD_INT 1
60974: PPUSH
60975: CALL_OW 3
60979: ST_TO_ADDR
// end ;
60980: LD_VAR 0 2
60984: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
60985: LD_INT 0
60987: PPUSH
60988: PPUSH
60989: PPUSH
60990: PPUSH
// sibRocketRange := 25 ;
60991: LD_ADDR_VAR 0 6
60995: PUSH
60996: LD_INT 25
60998: ST_TO_ADDR
// result := false ;
60999: LD_ADDR_VAR 0 4
61003: PUSH
61004: LD_INT 0
61006: ST_TO_ADDR
// for i := 0 to 5 do
61007: LD_ADDR_VAR 0 5
61011: PUSH
61012: DOUBLE
61013: LD_INT 0
61015: DEC
61016: ST_TO_ADDR
61017: LD_INT 5
61019: PUSH
61020: FOR_TO
61021: IFFALSE 61088
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
61023: LD_VAR 0 1
61027: PPUSH
61028: LD_VAR 0 5
61032: PPUSH
61033: LD_VAR 0 6
61037: PPUSH
61038: CALL_OW 272
61042: PPUSH
61043: LD_VAR 0 2
61047: PPUSH
61048: LD_VAR 0 5
61052: PPUSH
61053: LD_VAR 0 6
61057: PPUSH
61058: CALL_OW 273
61062: PPUSH
61063: LD_VAR 0 3
61067: PPUSH
61068: CALL_OW 309
61072: IFFALSE 61086
// begin result := true ;
61074: LD_ADDR_VAR 0 4
61078: PUSH
61079: LD_INT 1
61081: ST_TO_ADDR
// exit ;
61082: POP
61083: POP
61084: GO 61090
// end ;
61086: GO 61020
61088: POP
61089: POP
// end ;
61090: LD_VAR 0 4
61094: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
61095: LD_INT 0
61097: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
61098: LD_VAR 0 1
61102: PPUSH
61103: LD_VAR 0 2
61107: PPUSH
61108: LD_INT 0
61110: PPUSH
61111: LD_INT 0
61113: PPUSH
61114: LD_INT 1
61116: PPUSH
61117: LD_INT 0
61119: PPUSH
61120: CALL_OW 587
// end ;
61124: LD_VAR 0 3
61128: RET
// export function CenterOnNow ( unit ) ; begin
61129: LD_INT 0
61131: PPUSH
// result := IsInUnit ( unit ) ;
61132: LD_ADDR_VAR 0 2
61136: PUSH
61137: LD_VAR 0 1
61141: PPUSH
61142: CALL_OW 310
61146: ST_TO_ADDR
// if not result then
61147: LD_VAR 0 2
61151: NOT
61152: IFFALSE 61164
// result := unit ;
61154: LD_ADDR_VAR 0 2
61158: PUSH
61159: LD_VAR 0 1
61163: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
61164: LD_VAR 0 1
61168: PPUSH
61169: CALL_OW 87
// end ;
61173: LD_VAR 0 2
61177: RET
// export function ComMoveHex ( unit , hex ) ; begin
61178: LD_INT 0
61180: PPUSH
// if not hex then
61181: LD_VAR 0 2
61185: NOT
61186: IFFALSE 61190
// exit ;
61188: GO 61243
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
61190: LD_VAR 0 2
61194: PUSH
61195: LD_INT 1
61197: ARRAY
61198: PPUSH
61199: LD_VAR 0 2
61203: PUSH
61204: LD_INT 2
61206: ARRAY
61207: PPUSH
61208: CALL_OW 428
61212: IFFALSE 61216
// exit ;
61214: GO 61243
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
61216: LD_VAR 0 1
61220: PPUSH
61221: LD_VAR 0 2
61225: PUSH
61226: LD_INT 1
61228: ARRAY
61229: PPUSH
61230: LD_VAR 0 2
61234: PUSH
61235: LD_INT 2
61237: ARRAY
61238: PPUSH
61239: CALL_OW 111
// end ; end_of_file
61243: LD_VAR 0 3
61247: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
61248: LD_INT 0
61250: PPUSH
61251: PPUSH
// skirmish := false ;
61252: LD_ADDR_EXP 29
61256: PUSH
61257: LD_INT 0
61259: ST_TO_ADDR
// debug_mc := false ;
61260: LD_ADDR_EXP 30
61264: PUSH
61265: LD_INT 0
61267: ST_TO_ADDR
// mc_bases := [ ] ;
61268: LD_ADDR_EXP 31
61272: PUSH
61273: EMPTY
61274: ST_TO_ADDR
// mc_sides := [ ] ;
61275: LD_ADDR_EXP 57
61279: PUSH
61280: EMPTY
61281: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61282: LD_ADDR_EXP 32
61286: PUSH
61287: EMPTY
61288: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61289: LD_ADDR_EXP 33
61293: PUSH
61294: EMPTY
61295: ST_TO_ADDR
// mc_need_heal := [ ] ;
61296: LD_ADDR_EXP 34
61300: PUSH
61301: EMPTY
61302: ST_TO_ADDR
// mc_healers := [ ] ;
61303: LD_ADDR_EXP 35
61307: PUSH
61308: EMPTY
61309: ST_TO_ADDR
// mc_build_list := [ ] ;
61310: LD_ADDR_EXP 36
61314: PUSH
61315: EMPTY
61316: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61317: LD_ADDR_EXP 63
61321: PUSH
61322: EMPTY
61323: ST_TO_ADDR
// mc_builders := [ ] ;
61324: LD_ADDR_EXP 37
61328: PUSH
61329: EMPTY
61330: ST_TO_ADDR
// mc_construct_list := [ ] ;
61331: LD_ADDR_EXP 38
61335: PUSH
61336: EMPTY
61337: ST_TO_ADDR
// mc_turret_list := [ ] ;
61338: LD_ADDR_EXP 39
61342: PUSH
61343: EMPTY
61344: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61345: LD_ADDR_EXP 40
61349: PUSH
61350: EMPTY
61351: ST_TO_ADDR
// mc_miners := [ ] ;
61352: LD_ADDR_EXP 45
61356: PUSH
61357: EMPTY
61358: ST_TO_ADDR
// mc_mines := [ ] ;
61359: LD_ADDR_EXP 44
61363: PUSH
61364: EMPTY
61365: ST_TO_ADDR
// mc_minefields := [ ] ;
61366: LD_ADDR_EXP 46
61370: PUSH
61371: EMPTY
61372: ST_TO_ADDR
// mc_crates := [ ] ;
61373: LD_ADDR_EXP 47
61377: PUSH
61378: EMPTY
61379: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61380: LD_ADDR_EXP 48
61384: PUSH
61385: EMPTY
61386: ST_TO_ADDR
// mc_crates_area := [ ] ;
61387: LD_ADDR_EXP 49
61391: PUSH
61392: EMPTY
61393: ST_TO_ADDR
// mc_vehicles := [ ] ;
61394: LD_ADDR_EXP 50
61398: PUSH
61399: EMPTY
61400: ST_TO_ADDR
// mc_attack := [ ] ;
61401: LD_ADDR_EXP 51
61405: PUSH
61406: EMPTY
61407: ST_TO_ADDR
// mc_produce := [ ] ;
61408: LD_ADDR_EXP 52
61412: PUSH
61413: EMPTY
61414: ST_TO_ADDR
// mc_defender := [ ] ;
61415: LD_ADDR_EXP 53
61419: PUSH
61420: EMPTY
61421: ST_TO_ADDR
// mc_parking := [ ] ;
61422: LD_ADDR_EXP 55
61426: PUSH
61427: EMPTY
61428: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61429: LD_ADDR_EXP 41
61433: PUSH
61434: EMPTY
61435: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61436: LD_ADDR_EXP 43
61440: PUSH
61441: EMPTY
61442: ST_TO_ADDR
// mc_scan := [ ] ;
61443: LD_ADDR_EXP 54
61447: PUSH
61448: EMPTY
61449: ST_TO_ADDR
// mc_scan_area := [ ] ;
61450: LD_ADDR_EXP 56
61454: PUSH
61455: EMPTY
61456: ST_TO_ADDR
// mc_tech := [ ] ;
61457: LD_ADDR_EXP 58
61461: PUSH
61462: EMPTY
61463: ST_TO_ADDR
// mc_class := [ ] ;
61464: LD_ADDR_EXP 72
61468: PUSH
61469: EMPTY
61470: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61471: LD_ADDR_EXP 73
61475: PUSH
61476: EMPTY
61477: ST_TO_ADDR
// mc_is_defending := [ ] ;
61478: LD_ADDR_EXP 74
61482: PUSH
61483: EMPTY
61484: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
61485: LD_ADDR_EXP 65
61489: PUSH
61490: EMPTY
61491: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
61492: LD_ADDR_EXP 75
61496: PUSH
61497: LD_INT 0
61499: ST_TO_ADDR
// end ;
61500: LD_VAR 0 1
61504: RET
// export function MC_Kill ( base ) ; begin
61505: LD_INT 0
61507: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61508: LD_ADDR_EXP 31
61512: PUSH
61513: LD_EXP 31
61517: PPUSH
61518: LD_VAR 0 1
61522: PPUSH
61523: EMPTY
61524: PPUSH
61525: CALL_OW 1
61529: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61530: LD_ADDR_EXP 32
61534: PUSH
61535: LD_EXP 32
61539: PPUSH
61540: LD_VAR 0 1
61544: PPUSH
61545: EMPTY
61546: PPUSH
61547: CALL_OW 1
61551: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61552: LD_ADDR_EXP 33
61556: PUSH
61557: LD_EXP 33
61561: PPUSH
61562: LD_VAR 0 1
61566: PPUSH
61567: EMPTY
61568: PPUSH
61569: CALL_OW 1
61573: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61574: LD_ADDR_EXP 34
61578: PUSH
61579: LD_EXP 34
61583: PPUSH
61584: LD_VAR 0 1
61588: PPUSH
61589: EMPTY
61590: PPUSH
61591: CALL_OW 1
61595: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61596: LD_ADDR_EXP 35
61600: PUSH
61601: LD_EXP 35
61605: PPUSH
61606: LD_VAR 0 1
61610: PPUSH
61611: EMPTY
61612: PPUSH
61613: CALL_OW 1
61617: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61618: LD_ADDR_EXP 36
61622: PUSH
61623: LD_EXP 36
61627: PPUSH
61628: LD_VAR 0 1
61632: PPUSH
61633: EMPTY
61634: PPUSH
61635: CALL_OW 1
61639: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61640: LD_ADDR_EXP 37
61644: PUSH
61645: LD_EXP 37
61649: PPUSH
61650: LD_VAR 0 1
61654: PPUSH
61655: EMPTY
61656: PPUSH
61657: CALL_OW 1
61661: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61662: LD_ADDR_EXP 38
61666: PUSH
61667: LD_EXP 38
61671: PPUSH
61672: LD_VAR 0 1
61676: PPUSH
61677: EMPTY
61678: PPUSH
61679: CALL_OW 1
61683: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61684: LD_ADDR_EXP 39
61688: PUSH
61689: LD_EXP 39
61693: PPUSH
61694: LD_VAR 0 1
61698: PPUSH
61699: EMPTY
61700: PPUSH
61701: CALL_OW 1
61705: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61706: LD_ADDR_EXP 40
61710: PUSH
61711: LD_EXP 40
61715: PPUSH
61716: LD_VAR 0 1
61720: PPUSH
61721: EMPTY
61722: PPUSH
61723: CALL_OW 1
61727: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61728: LD_ADDR_EXP 41
61732: PUSH
61733: LD_EXP 41
61737: PPUSH
61738: LD_VAR 0 1
61742: PPUSH
61743: EMPTY
61744: PPUSH
61745: CALL_OW 1
61749: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61750: LD_ADDR_EXP 42
61754: PUSH
61755: LD_EXP 42
61759: PPUSH
61760: LD_VAR 0 1
61764: PPUSH
61765: LD_INT 0
61767: PPUSH
61768: CALL_OW 1
61772: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61773: LD_ADDR_EXP 43
61777: PUSH
61778: LD_EXP 43
61782: PPUSH
61783: LD_VAR 0 1
61787: PPUSH
61788: EMPTY
61789: PPUSH
61790: CALL_OW 1
61794: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61795: LD_ADDR_EXP 44
61799: PUSH
61800: LD_EXP 44
61804: PPUSH
61805: LD_VAR 0 1
61809: PPUSH
61810: EMPTY
61811: PPUSH
61812: CALL_OW 1
61816: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61817: LD_ADDR_EXP 45
61821: PUSH
61822: LD_EXP 45
61826: PPUSH
61827: LD_VAR 0 1
61831: PPUSH
61832: EMPTY
61833: PPUSH
61834: CALL_OW 1
61838: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61839: LD_ADDR_EXP 46
61843: PUSH
61844: LD_EXP 46
61848: PPUSH
61849: LD_VAR 0 1
61853: PPUSH
61854: EMPTY
61855: PPUSH
61856: CALL_OW 1
61860: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61861: LD_ADDR_EXP 47
61865: PUSH
61866: LD_EXP 47
61870: PPUSH
61871: LD_VAR 0 1
61875: PPUSH
61876: EMPTY
61877: PPUSH
61878: CALL_OW 1
61882: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61883: LD_ADDR_EXP 48
61887: PUSH
61888: LD_EXP 48
61892: PPUSH
61893: LD_VAR 0 1
61897: PPUSH
61898: EMPTY
61899: PPUSH
61900: CALL_OW 1
61904: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61905: LD_ADDR_EXP 49
61909: PUSH
61910: LD_EXP 49
61914: PPUSH
61915: LD_VAR 0 1
61919: PPUSH
61920: EMPTY
61921: PPUSH
61922: CALL_OW 1
61926: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61927: LD_ADDR_EXP 50
61931: PUSH
61932: LD_EXP 50
61936: PPUSH
61937: LD_VAR 0 1
61941: PPUSH
61942: EMPTY
61943: PPUSH
61944: CALL_OW 1
61948: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61949: LD_ADDR_EXP 51
61953: PUSH
61954: LD_EXP 51
61958: PPUSH
61959: LD_VAR 0 1
61963: PPUSH
61964: EMPTY
61965: PPUSH
61966: CALL_OW 1
61970: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61971: LD_ADDR_EXP 52
61975: PUSH
61976: LD_EXP 52
61980: PPUSH
61981: LD_VAR 0 1
61985: PPUSH
61986: EMPTY
61987: PPUSH
61988: CALL_OW 1
61992: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61993: LD_ADDR_EXP 53
61997: PUSH
61998: LD_EXP 53
62002: PPUSH
62003: LD_VAR 0 1
62007: PPUSH
62008: EMPTY
62009: PPUSH
62010: CALL_OW 1
62014: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62015: LD_ADDR_EXP 54
62019: PUSH
62020: LD_EXP 54
62024: PPUSH
62025: LD_VAR 0 1
62029: PPUSH
62030: EMPTY
62031: PPUSH
62032: CALL_OW 1
62036: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62037: LD_ADDR_EXP 55
62041: PUSH
62042: LD_EXP 55
62046: PPUSH
62047: LD_VAR 0 1
62051: PPUSH
62052: EMPTY
62053: PPUSH
62054: CALL_OW 1
62058: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62059: LD_ADDR_EXP 56
62063: PUSH
62064: LD_EXP 56
62068: PPUSH
62069: LD_VAR 0 1
62073: PPUSH
62074: EMPTY
62075: PPUSH
62076: CALL_OW 1
62080: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62081: LD_ADDR_EXP 58
62085: PUSH
62086: LD_EXP 58
62090: PPUSH
62091: LD_VAR 0 1
62095: PPUSH
62096: EMPTY
62097: PPUSH
62098: CALL_OW 1
62102: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62103: LD_ADDR_EXP 60
62107: PUSH
62108: LD_EXP 60
62112: PPUSH
62113: LD_VAR 0 1
62117: PPUSH
62118: EMPTY
62119: PPUSH
62120: CALL_OW 1
62124: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62125: LD_ADDR_EXP 61
62129: PUSH
62130: LD_EXP 61
62134: PPUSH
62135: LD_VAR 0 1
62139: PPUSH
62140: EMPTY
62141: PPUSH
62142: CALL_OW 1
62146: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62147: LD_ADDR_EXP 62
62151: PUSH
62152: LD_EXP 62
62156: PPUSH
62157: LD_VAR 0 1
62161: PPUSH
62162: EMPTY
62163: PPUSH
62164: CALL_OW 1
62168: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62169: LD_ADDR_EXP 63
62173: PUSH
62174: LD_EXP 63
62178: PPUSH
62179: LD_VAR 0 1
62183: PPUSH
62184: EMPTY
62185: PPUSH
62186: CALL_OW 1
62190: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62191: LD_ADDR_EXP 64
62195: PUSH
62196: LD_EXP 64
62200: PPUSH
62201: LD_VAR 0 1
62205: PPUSH
62206: EMPTY
62207: PPUSH
62208: CALL_OW 1
62212: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62213: LD_ADDR_EXP 65
62217: PUSH
62218: LD_EXP 65
62222: PPUSH
62223: LD_VAR 0 1
62227: PPUSH
62228: EMPTY
62229: PPUSH
62230: CALL_OW 1
62234: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62235: LD_ADDR_EXP 66
62239: PUSH
62240: LD_EXP 66
62244: PPUSH
62245: LD_VAR 0 1
62249: PPUSH
62250: EMPTY
62251: PPUSH
62252: CALL_OW 1
62256: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62257: LD_ADDR_EXP 67
62261: PUSH
62262: LD_EXP 67
62266: PPUSH
62267: LD_VAR 0 1
62271: PPUSH
62272: EMPTY
62273: PPUSH
62274: CALL_OW 1
62278: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62279: LD_ADDR_EXP 68
62283: PUSH
62284: LD_EXP 68
62288: PPUSH
62289: LD_VAR 0 1
62293: PPUSH
62294: EMPTY
62295: PPUSH
62296: CALL_OW 1
62300: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62301: LD_ADDR_EXP 69
62305: PUSH
62306: LD_EXP 69
62310: PPUSH
62311: LD_VAR 0 1
62315: PPUSH
62316: EMPTY
62317: PPUSH
62318: CALL_OW 1
62322: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62323: LD_ADDR_EXP 70
62327: PUSH
62328: LD_EXP 70
62332: PPUSH
62333: LD_VAR 0 1
62337: PPUSH
62338: EMPTY
62339: PPUSH
62340: CALL_OW 1
62344: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62345: LD_ADDR_EXP 71
62349: PUSH
62350: LD_EXP 71
62354: PPUSH
62355: LD_VAR 0 1
62359: PPUSH
62360: EMPTY
62361: PPUSH
62362: CALL_OW 1
62366: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62367: LD_ADDR_EXP 72
62371: PUSH
62372: LD_EXP 72
62376: PPUSH
62377: LD_VAR 0 1
62381: PPUSH
62382: EMPTY
62383: PPUSH
62384: CALL_OW 1
62388: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62389: LD_ADDR_EXP 73
62393: PUSH
62394: LD_EXP 73
62398: PPUSH
62399: LD_VAR 0 1
62403: PPUSH
62404: LD_INT 0
62406: PPUSH
62407: CALL_OW 1
62411: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62412: LD_ADDR_EXP 74
62416: PUSH
62417: LD_EXP 74
62421: PPUSH
62422: LD_VAR 0 1
62426: PPUSH
62427: LD_INT 0
62429: PPUSH
62430: CALL_OW 1
62434: ST_TO_ADDR
// end ;
62435: LD_VAR 0 2
62439: RET
// export function MC_Add ( side , units ) ; var base ; begin
62440: LD_INT 0
62442: PPUSH
62443: PPUSH
// base := mc_bases + 1 ;
62444: LD_ADDR_VAR 0 4
62448: PUSH
62449: LD_EXP 31
62453: PUSH
62454: LD_INT 1
62456: PLUS
62457: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62458: LD_ADDR_EXP 57
62462: PUSH
62463: LD_EXP 57
62467: PPUSH
62468: LD_VAR 0 4
62472: PPUSH
62473: LD_VAR 0 1
62477: PPUSH
62478: CALL_OW 1
62482: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62483: LD_ADDR_EXP 31
62487: PUSH
62488: LD_EXP 31
62492: PPUSH
62493: LD_VAR 0 4
62497: PPUSH
62498: LD_VAR 0 2
62502: PPUSH
62503: CALL_OW 1
62507: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62508: LD_ADDR_EXP 32
62512: PUSH
62513: LD_EXP 32
62517: PPUSH
62518: LD_VAR 0 4
62522: PPUSH
62523: EMPTY
62524: PPUSH
62525: CALL_OW 1
62529: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62530: LD_ADDR_EXP 33
62534: PUSH
62535: LD_EXP 33
62539: PPUSH
62540: LD_VAR 0 4
62544: PPUSH
62545: EMPTY
62546: PPUSH
62547: CALL_OW 1
62551: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62552: LD_ADDR_EXP 34
62556: PUSH
62557: LD_EXP 34
62561: PPUSH
62562: LD_VAR 0 4
62566: PPUSH
62567: EMPTY
62568: PPUSH
62569: CALL_OW 1
62573: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62574: LD_ADDR_EXP 35
62578: PUSH
62579: LD_EXP 35
62583: PPUSH
62584: LD_VAR 0 4
62588: PPUSH
62589: EMPTY
62590: PPUSH
62591: CALL_OW 1
62595: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62596: LD_ADDR_EXP 36
62600: PUSH
62601: LD_EXP 36
62605: PPUSH
62606: LD_VAR 0 4
62610: PPUSH
62611: EMPTY
62612: PPUSH
62613: CALL_OW 1
62617: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62618: LD_ADDR_EXP 37
62622: PUSH
62623: LD_EXP 37
62627: PPUSH
62628: LD_VAR 0 4
62632: PPUSH
62633: EMPTY
62634: PPUSH
62635: CALL_OW 1
62639: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62640: LD_ADDR_EXP 38
62644: PUSH
62645: LD_EXP 38
62649: PPUSH
62650: LD_VAR 0 4
62654: PPUSH
62655: EMPTY
62656: PPUSH
62657: CALL_OW 1
62661: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62662: LD_ADDR_EXP 39
62666: PUSH
62667: LD_EXP 39
62671: PPUSH
62672: LD_VAR 0 4
62676: PPUSH
62677: EMPTY
62678: PPUSH
62679: CALL_OW 1
62683: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62684: LD_ADDR_EXP 40
62688: PUSH
62689: LD_EXP 40
62693: PPUSH
62694: LD_VAR 0 4
62698: PPUSH
62699: EMPTY
62700: PPUSH
62701: CALL_OW 1
62705: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62706: LD_ADDR_EXP 41
62710: PUSH
62711: LD_EXP 41
62715: PPUSH
62716: LD_VAR 0 4
62720: PPUSH
62721: EMPTY
62722: PPUSH
62723: CALL_OW 1
62727: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62728: LD_ADDR_EXP 42
62732: PUSH
62733: LD_EXP 42
62737: PPUSH
62738: LD_VAR 0 4
62742: PPUSH
62743: LD_INT 0
62745: PPUSH
62746: CALL_OW 1
62750: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62751: LD_ADDR_EXP 43
62755: PUSH
62756: LD_EXP 43
62760: PPUSH
62761: LD_VAR 0 4
62765: PPUSH
62766: EMPTY
62767: PPUSH
62768: CALL_OW 1
62772: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62773: LD_ADDR_EXP 44
62777: PUSH
62778: LD_EXP 44
62782: PPUSH
62783: LD_VAR 0 4
62787: PPUSH
62788: EMPTY
62789: PPUSH
62790: CALL_OW 1
62794: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62795: LD_ADDR_EXP 45
62799: PUSH
62800: LD_EXP 45
62804: PPUSH
62805: LD_VAR 0 4
62809: PPUSH
62810: EMPTY
62811: PPUSH
62812: CALL_OW 1
62816: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62817: LD_ADDR_EXP 46
62821: PUSH
62822: LD_EXP 46
62826: PPUSH
62827: LD_VAR 0 4
62831: PPUSH
62832: EMPTY
62833: PPUSH
62834: CALL_OW 1
62838: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62839: LD_ADDR_EXP 47
62843: PUSH
62844: LD_EXP 47
62848: PPUSH
62849: LD_VAR 0 4
62853: PPUSH
62854: EMPTY
62855: PPUSH
62856: CALL_OW 1
62860: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62861: LD_ADDR_EXP 48
62865: PUSH
62866: LD_EXP 48
62870: PPUSH
62871: LD_VAR 0 4
62875: PPUSH
62876: EMPTY
62877: PPUSH
62878: CALL_OW 1
62882: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62883: LD_ADDR_EXP 49
62887: PUSH
62888: LD_EXP 49
62892: PPUSH
62893: LD_VAR 0 4
62897: PPUSH
62898: EMPTY
62899: PPUSH
62900: CALL_OW 1
62904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62905: LD_ADDR_EXP 50
62909: PUSH
62910: LD_EXP 50
62914: PPUSH
62915: LD_VAR 0 4
62919: PPUSH
62920: EMPTY
62921: PPUSH
62922: CALL_OW 1
62926: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62927: LD_ADDR_EXP 51
62931: PUSH
62932: LD_EXP 51
62936: PPUSH
62937: LD_VAR 0 4
62941: PPUSH
62942: EMPTY
62943: PPUSH
62944: CALL_OW 1
62948: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62949: LD_ADDR_EXP 52
62953: PUSH
62954: LD_EXP 52
62958: PPUSH
62959: LD_VAR 0 4
62963: PPUSH
62964: EMPTY
62965: PPUSH
62966: CALL_OW 1
62970: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62971: LD_ADDR_EXP 53
62975: PUSH
62976: LD_EXP 53
62980: PPUSH
62981: LD_VAR 0 4
62985: PPUSH
62986: EMPTY
62987: PPUSH
62988: CALL_OW 1
62992: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62993: LD_ADDR_EXP 54
62997: PUSH
62998: LD_EXP 54
63002: PPUSH
63003: LD_VAR 0 4
63007: PPUSH
63008: EMPTY
63009: PPUSH
63010: CALL_OW 1
63014: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63015: LD_ADDR_EXP 55
63019: PUSH
63020: LD_EXP 55
63024: PPUSH
63025: LD_VAR 0 4
63029: PPUSH
63030: EMPTY
63031: PPUSH
63032: CALL_OW 1
63036: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63037: LD_ADDR_EXP 56
63041: PUSH
63042: LD_EXP 56
63046: PPUSH
63047: LD_VAR 0 4
63051: PPUSH
63052: EMPTY
63053: PPUSH
63054: CALL_OW 1
63058: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63059: LD_ADDR_EXP 58
63063: PUSH
63064: LD_EXP 58
63068: PPUSH
63069: LD_VAR 0 4
63073: PPUSH
63074: EMPTY
63075: PPUSH
63076: CALL_OW 1
63080: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63081: LD_ADDR_EXP 60
63085: PUSH
63086: LD_EXP 60
63090: PPUSH
63091: LD_VAR 0 4
63095: PPUSH
63096: EMPTY
63097: PPUSH
63098: CALL_OW 1
63102: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63103: LD_ADDR_EXP 61
63107: PUSH
63108: LD_EXP 61
63112: PPUSH
63113: LD_VAR 0 4
63117: PPUSH
63118: EMPTY
63119: PPUSH
63120: CALL_OW 1
63124: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63125: LD_ADDR_EXP 62
63129: PUSH
63130: LD_EXP 62
63134: PPUSH
63135: LD_VAR 0 4
63139: PPUSH
63140: EMPTY
63141: PPUSH
63142: CALL_OW 1
63146: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63147: LD_ADDR_EXP 63
63151: PUSH
63152: LD_EXP 63
63156: PPUSH
63157: LD_VAR 0 4
63161: PPUSH
63162: EMPTY
63163: PPUSH
63164: CALL_OW 1
63168: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63169: LD_ADDR_EXP 64
63173: PUSH
63174: LD_EXP 64
63178: PPUSH
63179: LD_VAR 0 4
63183: PPUSH
63184: EMPTY
63185: PPUSH
63186: CALL_OW 1
63190: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63191: LD_ADDR_EXP 65
63195: PUSH
63196: LD_EXP 65
63200: PPUSH
63201: LD_VAR 0 4
63205: PPUSH
63206: EMPTY
63207: PPUSH
63208: CALL_OW 1
63212: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63213: LD_ADDR_EXP 66
63217: PUSH
63218: LD_EXP 66
63222: PPUSH
63223: LD_VAR 0 4
63227: PPUSH
63228: EMPTY
63229: PPUSH
63230: CALL_OW 1
63234: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63235: LD_ADDR_EXP 67
63239: PUSH
63240: LD_EXP 67
63244: PPUSH
63245: LD_VAR 0 4
63249: PPUSH
63250: EMPTY
63251: PPUSH
63252: CALL_OW 1
63256: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63257: LD_ADDR_EXP 68
63261: PUSH
63262: LD_EXP 68
63266: PPUSH
63267: LD_VAR 0 4
63271: PPUSH
63272: EMPTY
63273: PPUSH
63274: CALL_OW 1
63278: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63279: LD_ADDR_EXP 69
63283: PUSH
63284: LD_EXP 69
63288: PPUSH
63289: LD_VAR 0 4
63293: PPUSH
63294: EMPTY
63295: PPUSH
63296: CALL_OW 1
63300: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63301: LD_ADDR_EXP 70
63305: PUSH
63306: LD_EXP 70
63310: PPUSH
63311: LD_VAR 0 4
63315: PPUSH
63316: EMPTY
63317: PPUSH
63318: CALL_OW 1
63322: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63323: LD_ADDR_EXP 71
63327: PUSH
63328: LD_EXP 71
63332: PPUSH
63333: LD_VAR 0 4
63337: PPUSH
63338: EMPTY
63339: PPUSH
63340: CALL_OW 1
63344: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63345: LD_ADDR_EXP 72
63349: PUSH
63350: LD_EXP 72
63354: PPUSH
63355: LD_VAR 0 4
63359: PPUSH
63360: EMPTY
63361: PPUSH
63362: CALL_OW 1
63366: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63367: LD_ADDR_EXP 73
63371: PUSH
63372: LD_EXP 73
63376: PPUSH
63377: LD_VAR 0 4
63381: PPUSH
63382: LD_INT 0
63384: PPUSH
63385: CALL_OW 1
63389: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63390: LD_ADDR_EXP 74
63394: PUSH
63395: LD_EXP 74
63399: PPUSH
63400: LD_VAR 0 4
63404: PPUSH
63405: LD_INT 0
63407: PPUSH
63408: CALL_OW 1
63412: ST_TO_ADDR
// result := base ;
63413: LD_ADDR_VAR 0 3
63417: PUSH
63418: LD_VAR 0 4
63422: ST_TO_ADDR
// end ;
63423: LD_VAR 0 3
63427: RET
// export function MC_Start ( ) ; var i ; begin
63428: LD_INT 0
63430: PPUSH
63431: PPUSH
// for i = 1 to mc_bases do
63432: LD_ADDR_VAR 0 2
63436: PUSH
63437: DOUBLE
63438: LD_INT 1
63440: DEC
63441: ST_TO_ADDR
63442: LD_EXP 31
63446: PUSH
63447: FOR_TO
63448: IFFALSE 64548
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63450: LD_ADDR_EXP 31
63454: PUSH
63455: LD_EXP 31
63459: PPUSH
63460: LD_VAR 0 2
63464: PPUSH
63465: LD_EXP 31
63469: PUSH
63470: LD_VAR 0 2
63474: ARRAY
63475: PUSH
63476: LD_INT 0
63478: DIFF
63479: PPUSH
63480: CALL_OW 1
63484: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63485: LD_ADDR_EXP 32
63489: PUSH
63490: LD_EXP 32
63494: PPUSH
63495: LD_VAR 0 2
63499: PPUSH
63500: EMPTY
63501: PPUSH
63502: CALL_OW 1
63506: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63507: LD_ADDR_EXP 33
63511: PUSH
63512: LD_EXP 33
63516: PPUSH
63517: LD_VAR 0 2
63521: PPUSH
63522: EMPTY
63523: PPUSH
63524: CALL_OW 1
63528: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63529: LD_ADDR_EXP 34
63533: PUSH
63534: LD_EXP 34
63538: PPUSH
63539: LD_VAR 0 2
63543: PPUSH
63544: EMPTY
63545: PPUSH
63546: CALL_OW 1
63550: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63551: LD_ADDR_EXP 35
63555: PUSH
63556: LD_EXP 35
63560: PPUSH
63561: LD_VAR 0 2
63565: PPUSH
63566: EMPTY
63567: PUSH
63568: EMPTY
63569: PUSH
63570: EMPTY
63571: LIST
63572: LIST
63573: PPUSH
63574: CALL_OW 1
63578: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63579: LD_ADDR_EXP 36
63583: PUSH
63584: LD_EXP 36
63588: PPUSH
63589: LD_VAR 0 2
63593: PPUSH
63594: EMPTY
63595: PPUSH
63596: CALL_OW 1
63600: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63601: LD_ADDR_EXP 63
63605: PUSH
63606: LD_EXP 63
63610: PPUSH
63611: LD_VAR 0 2
63615: PPUSH
63616: EMPTY
63617: PPUSH
63618: CALL_OW 1
63622: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63623: LD_ADDR_EXP 37
63627: PUSH
63628: LD_EXP 37
63632: PPUSH
63633: LD_VAR 0 2
63637: PPUSH
63638: EMPTY
63639: PPUSH
63640: CALL_OW 1
63644: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63645: LD_ADDR_EXP 38
63649: PUSH
63650: LD_EXP 38
63654: PPUSH
63655: LD_VAR 0 2
63659: PPUSH
63660: EMPTY
63661: PPUSH
63662: CALL_OW 1
63666: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63667: LD_ADDR_EXP 39
63671: PUSH
63672: LD_EXP 39
63676: PPUSH
63677: LD_VAR 0 2
63681: PPUSH
63682: LD_EXP 31
63686: PUSH
63687: LD_VAR 0 2
63691: ARRAY
63692: PPUSH
63693: LD_INT 2
63695: PUSH
63696: LD_INT 30
63698: PUSH
63699: LD_INT 32
63701: PUSH
63702: EMPTY
63703: LIST
63704: LIST
63705: PUSH
63706: LD_INT 30
63708: PUSH
63709: LD_INT 33
63711: PUSH
63712: EMPTY
63713: LIST
63714: LIST
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: LIST
63720: PPUSH
63721: CALL_OW 72
63725: PPUSH
63726: CALL_OW 1
63730: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63731: LD_ADDR_EXP 40
63735: PUSH
63736: LD_EXP 40
63740: PPUSH
63741: LD_VAR 0 2
63745: PPUSH
63746: LD_EXP 31
63750: PUSH
63751: LD_VAR 0 2
63755: ARRAY
63756: PPUSH
63757: LD_INT 2
63759: PUSH
63760: LD_INT 30
63762: PUSH
63763: LD_INT 32
63765: PUSH
63766: EMPTY
63767: LIST
63768: LIST
63769: PUSH
63770: LD_INT 30
63772: PUSH
63773: LD_INT 31
63775: PUSH
63776: EMPTY
63777: LIST
63778: LIST
63779: PUSH
63780: EMPTY
63781: LIST
63782: LIST
63783: LIST
63784: PUSH
63785: LD_INT 58
63787: PUSH
63788: EMPTY
63789: LIST
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PPUSH
63795: CALL_OW 72
63799: PPUSH
63800: CALL_OW 1
63804: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63805: LD_ADDR_EXP 41
63809: PUSH
63810: LD_EXP 41
63814: PPUSH
63815: LD_VAR 0 2
63819: PPUSH
63820: EMPTY
63821: PPUSH
63822: CALL_OW 1
63826: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
63827: LD_ADDR_EXP 45
63831: PUSH
63832: LD_EXP 45
63836: PPUSH
63837: LD_VAR 0 2
63841: PPUSH
63842: EMPTY
63843: PPUSH
63844: CALL_OW 1
63848: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
63849: LD_ADDR_EXP 44
63853: PUSH
63854: LD_EXP 44
63858: PPUSH
63859: LD_VAR 0 2
63863: PPUSH
63864: EMPTY
63865: PPUSH
63866: CALL_OW 1
63870: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
63871: LD_ADDR_EXP 46
63875: PUSH
63876: LD_EXP 46
63880: PPUSH
63881: LD_VAR 0 2
63885: PPUSH
63886: EMPTY
63887: PPUSH
63888: CALL_OW 1
63892: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
63893: LD_ADDR_EXP 47
63897: PUSH
63898: LD_EXP 47
63902: PPUSH
63903: LD_VAR 0 2
63907: PPUSH
63908: EMPTY
63909: PPUSH
63910: CALL_OW 1
63914: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63915: LD_ADDR_EXP 48
63919: PUSH
63920: LD_EXP 48
63924: PPUSH
63925: LD_VAR 0 2
63929: PPUSH
63930: EMPTY
63931: PPUSH
63932: CALL_OW 1
63936: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
63937: LD_ADDR_EXP 49
63941: PUSH
63942: LD_EXP 49
63946: PPUSH
63947: LD_VAR 0 2
63951: PPUSH
63952: EMPTY
63953: PPUSH
63954: CALL_OW 1
63958: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
63959: LD_ADDR_EXP 50
63963: PUSH
63964: LD_EXP 50
63968: PPUSH
63969: LD_VAR 0 2
63973: PPUSH
63974: EMPTY
63975: PPUSH
63976: CALL_OW 1
63980: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63981: LD_ADDR_EXP 51
63985: PUSH
63986: LD_EXP 51
63990: PPUSH
63991: LD_VAR 0 2
63995: PPUSH
63996: EMPTY
63997: PPUSH
63998: CALL_OW 1
64002: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
64003: LD_ADDR_EXP 52
64007: PUSH
64008: LD_EXP 52
64012: PPUSH
64013: LD_VAR 0 2
64017: PPUSH
64018: EMPTY
64019: PPUSH
64020: CALL_OW 1
64024: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64025: LD_ADDR_EXP 53
64029: PUSH
64030: LD_EXP 53
64034: PPUSH
64035: LD_VAR 0 2
64039: PPUSH
64040: EMPTY
64041: PPUSH
64042: CALL_OW 1
64046: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
64047: LD_ADDR_EXP 42
64051: PUSH
64052: LD_EXP 42
64056: PPUSH
64057: LD_VAR 0 2
64061: PPUSH
64062: LD_INT 0
64064: PPUSH
64065: CALL_OW 1
64069: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
64070: LD_ADDR_EXP 55
64074: PUSH
64075: LD_EXP 55
64079: PPUSH
64080: LD_VAR 0 2
64084: PPUSH
64085: LD_INT 0
64087: PPUSH
64088: CALL_OW 1
64092: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64093: LD_ADDR_EXP 43
64097: PUSH
64098: LD_EXP 43
64102: PPUSH
64103: LD_VAR 0 2
64107: PPUSH
64108: EMPTY
64109: PPUSH
64110: CALL_OW 1
64114: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
64115: LD_ADDR_EXP 54
64119: PUSH
64120: LD_EXP 54
64124: PPUSH
64125: LD_VAR 0 2
64129: PPUSH
64130: LD_INT 0
64132: PPUSH
64133: CALL_OW 1
64137: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
64138: LD_ADDR_EXP 56
64142: PUSH
64143: LD_EXP 56
64147: PPUSH
64148: LD_VAR 0 2
64152: PPUSH
64153: EMPTY
64154: PPUSH
64155: CALL_OW 1
64159: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
64160: LD_ADDR_EXP 59
64164: PUSH
64165: LD_EXP 59
64169: PPUSH
64170: LD_VAR 0 2
64174: PPUSH
64175: LD_INT 0
64177: PPUSH
64178: CALL_OW 1
64182: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
64183: LD_ADDR_EXP 60
64187: PUSH
64188: LD_EXP 60
64192: PPUSH
64193: LD_VAR 0 2
64197: PPUSH
64198: EMPTY
64199: PPUSH
64200: CALL_OW 1
64204: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64205: LD_ADDR_EXP 61
64209: PUSH
64210: LD_EXP 61
64214: PPUSH
64215: LD_VAR 0 2
64219: PPUSH
64220: EMPTY
64221: PPUSH
64222: CALL_OW 1
64226: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64227: LD_ADDR_EXP 62
64231: PUSH
64232: LD_EXP 62
64236: PPUSH
64237: LD_VAR 0 2
64241: PPUSH
64242: EMPTY
64243: PPUSH
64244: CALL_OW 1
64248: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64249: LD_ADDR_EXP 64
64253: PUSH
64254: LD_EXP 64
64258: PPUSH
64259: LD_VAR 0 2
64263: PPUSH
64264: LD_EXP 31
64268: PUSH
64269: LD_VAR 0 2
64273: ARRAY
64274: PPUSH
64275: LD_INT 2
64277: PUSH
64278: LD_INT 30
64280: PUSH
64281: LD_INT 6
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: PUSH
64288: LD_INT 30
64290: PUSH
64291: LD_INT 7
64293: PUSH
64294: EMPTY
64295: LIST
64296: LIST
64297: PUSH
64298: LD_INT 30
64300: PUSH
64301: LD_INT 8
64303: PUSH
64304: EMPTY
64305: LIST
64306: LIST
64307: PUSH
64308: EMPTY
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: PPUSH
64314: CALL_OW 72
64318: PPUSH
64319: CALL_OW 1
64323: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64324: LD_ADDR_EXP 65
64328: PUSH
64329: LD_EXP 65
64333: PPUSH
64334: LD_VAR 0 2
64338: PPUSH
64339: EMPTY
64340: PPUSH
64341: CALL_OW 1
64345: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64346: LD_ADDR_EXP 66
64350: PUSH
64351: LD_EXP 66
64355: PPUSH
64356: LD_VAR 0 2
64360: PPUSH
64361: EMPTY
64362: PPUSH
64363: CALL_OW 1
64367: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64368: LD_ADDR_EXP 67
64372: PUSH
64373: LD_EXP 67
64377: PPUSH
64378: LD_VAR 0 2
64382: PPUSH
64383: EMPTY
64384: PPUSH
64385: CALL_OW 1
64389: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64390: LD_ADDR_EXP 68
64394: PUSH
64395: LD_EXP 68
64399: PPUSH
64400: LD_VAR 0 2
64404: PPUSH
64405: EMPTY
64406: PPUSH
64407: CALL_OW 1
64411: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64412: LD_ADDR_EXP 69
64416: PUSH
64417: LD_EXP 69
64421: PPUSH
64422: LD_VAR 0 2
64426: PPUSH
64427: EMPTY
64428: PPUSH
64429: CALL_OW 1
64433: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64434: LD_ADDR_EXP 70
64438: PUSH
64439: LD_EXP 70
64443: PPUSH
64444: LD_VAR 0 2
64448: PPUSH
64449: EMPTY
64450: PPUSH
64451: CALL_OW 1
64455: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64456: LD_ADDR_EXP 71
64460: PUSH
64461: LD_EXP 71
64465: PPUSH
64466: LD_VAR 0 2
64470: PPUSH
64471: EMPTY
64472: PPUSH
64473: CALL_OW 1
64477: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64478: LD_ADDR_EXP 72
64482: PUSH
64483: LD_EXP 72
64487: PPUSH
64488: LD_VAR 0 2
64492: PPUSH
64493: EMPTY
64494: PPUSH
64495: CALL_OW 1
64499: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64500: LD_ADDR_EXP 73
64504: PUSH
64505: LD_EXP 73
64509: PPUSH
64510: LD_VAR 0 2
64514: PPUSH
64515: LD_INT 0
64517: PPUSH
64518: CALL_OW 1
64522: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64523: LD_ADDR_EXP 74
64527: PUSH
64528: LD_EXP 74
64532: PPUSH
64533: LD_VAR 0 2
64537: PPUSH
64538: LD_INT 0
64540: PPUSH
64541: CALL_OW 1
64545: ST_TO_ADDR
// end ;
64546: GO 63447
64548: POP
64549: POP
// MC_InitSides ( ) ;
64550: CALL 64836 0 0
// MC_InitResearch ( ) ;
64554: CALL 64575 0 0
// CustomInitMacro ( ) ;
64558: CALL 1411 0 0
// skirmish := true ;
64562: LD_ADDR_EXP 29
64566: PUSH
64567: LD_INT 1
64569: ST_TO_ADDR
// end ;
64570: LD_VAR 0 1
64574: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64575: LD_INT 0
64577: PPUSH
64578: PPUSH
64579: PPUSH
64580: PPUSH
64581: PPUSH
64582: PPUSH
// if not mc_bases then
64583: LD_EXP 31
64587: NOT
64588: IFFALSE 64592
// exit ;
64590: GO 64831
// for i = 1 to 8 do
64592: LD_ADDR_VAR 0 2
64596: PUSH
64597: DOUBLE
64598: LD_INT 1
64600: DEC
64601: ST_TO_ADDR
64602: LD_INT 8
64604: PUSH
64605: FOR_TO
64606: IFFALSE 64632
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64608: LD_ADDR_EXP 58
64612: PUSH
64613: LD_EXP 58
64617: PPUSH
64618: LD_VAR 0 2
64622: PPUSH
64623: EMPTY
64624: PPUSH
64625: CALL_OW 1
64629: ST_TO_ADDR
64630: GO 64605
64632: POP
64633: POP
// tmp := [ ] ;
64634: LD_ADDR_VAR 0 5
64638: PUSH
64639: EMPTY
64640: ST_TO_ADDR
// for i = 1 to mc_sides do
64641: LD_ADDR_VAR 0 2
64645: PUSH
64646: DOUBLE
64647: LD_INT 1
64649: DEC
64650: ST_TO_ADDR
64651: LD_EXP 57
64655: PUSH
64656: FOR_TO
64657: IFFALSE 64715
// if not mc_sides [ i ] in tmp then
64659: LD_EXP 57
64663: PUSH
64664: LD_VAR 0 2
64668: ARRAY
64669: PUSH
64670: LD_VAR 0 5
64674: IN
64675: NOT
64676: IFFALSE 64713
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64678: LD_ADDR_VAR 0 5
64682: PUSH
64683: LD_VAR 0 5
64687: PPUSH
64688: LD_VAR 0 5
64692: PUSH
64693: LD_INT 1
64695: PLUS
64696: PPUSH
64697: LD_EXP 57
64701: PUSH
64702: LD_VAR 0 2
64706: ARRAY
64707: PPUSH
64708: CALL_OW 2
64712: ST_TO_ADDR
64713: GO 64656
64715: POP
64716: POP
// if not tmp then
64717: LD_VAR 0 5
64721: NOT
64722: IFFALSE 64726
// exit ;
64724: GO 64831
// for j in tmp do
64726: LD_ADDR_VAR 0 3
64730: PUSH
64731: LD_VAR 0 5
64735: PUSH
64736: FOR_IN
64737: IFFALSE 64829
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64739: LD_ADDR_VAR 0 6
64743: PUSH
64744: LD_INT 22
64746: PUSH
64747: LD_VAR 0 3
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PPUSH
64756: CALL_OW 69
64760: ST_TO_ADDR
// if not un then
64761: LD_VAR 0 6
64765: NOT
64766: IFFALSE 64770
// continue ;
64768: GO 64736
// nation := GetNation ( un [ 1 ] ) ;
64770: LD_ADDR_VAR 0 4
64774: PUSH
64775: LD_VAR 0 6
64779: PUSH
64780: LD_INT 1
64782: ARRAY
64783: PPUSH
64784: CALL_OW 248
64788: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64789: LD_ADDR_EXP 58
64793: PUSH
64794: LD_EXP 58
64798: PPUSH
64799: LD_VAR 0 3
64803: PPUSH
64804: LD_VAR 0 3
64808: PPUSH
64809: LD_VAR 0 4
64813: PPUSH
64814: LD_INT 1
64816: PPUSH
64817: CALL 19947 0 3
64821: PPUSH
64822: CALL_OW 1
64826: ST_TO_ADDR
// end ;
64827: GO 64736
64829: POP
64830: POP
// end ;
64831: LD_VAR 0 1
64835: RET
// export function MC_InitSides ( ) ; var i ; begin
64836: LD_INT 0
64838: PPUSH
64839: PPUSH
// if not mc_bases then
64840: LD_EXP 31
64844: NOT
64845: IFFALSE 64849
// exit ;
64847: GO 64923
// for i = 1 to mc_bases do
64849: LD_ADDR_VAR 0 2
64853: PUSH
64854: DOUBLE
64855: LD_INT 1
64857: DEC
64858: ST_TO_ADDR
64859: LD_EXP 31
64863: PUSH
64864: FOR_TO
64865: IFFALSE 64921
// if mc_bases [ i ] then
64867: LD_EXP 31
64871: PUSH
64872: LD_VAR 0 2
64876: ARRAY
64877: IFFALSE 64919
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
64879: LD_ADDR_EXP 57
64883: PUSH
64884: LD_EXP 57
64888: PPUSH
64889: LD_VAR 0 2
64893: PPUSH
64894: LD_EXP 31
64898: PUSH
64899: LD_VAR 0 2
64903: ARRAY
64904: PUSH
64905: LD_INT 1
64907: ARRAY
64908: PPUSH
64909: CALL_OW 255
64913: PPUSH
64914: CALL_OW 1
64918: ST_TO_ADDR
64919: GO 64864
64921: POP
64922: POP
// end ;
64923: LD_VAR 0 1
64927: RET
// every 0 0$03 trigger skirmish do
64928: LD_EXP 29
64932: IFFALSE 65086
64934: GO 64936
64936: DISABLE
// begin enable ;
64937: ENABLE
// MC_CheckBuildings ( ) ;
64938: CALL 69584 0 0
// MC_CheckPeopleLife ( ) ;
64942: CALL 69745 0 0
// RaiseSailEvent ( 100 ) ;
64946: LD_INT 100
64948: PPUSH
64949: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
64953: LD_INT 103
64955: PPUSH
64956: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
64960: LD_INT 104
64962: PPUSH
64963: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
64967: LD_INT 105
64969: PPUSH
64970: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
64974: LD_INT 106
64976: PPUSH
64977: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
64981: LD_INT 107
64983: PPUSH
64984: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
64988: LD_INT 108
64990: PPUSH
64991: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
64995: LD_INT 109
64997: PPUSH
64998: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
65002: LD_INT 110
65004: PPUSH
65005: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
65009: LD_INT 111
65011: PPUSH
65012: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
65016: LD_INT 112
65018: PPUSH
65019: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
65023: LD_INT 113
65025: PPUSH
65026: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
65030: LD_INT 120
65032: PPUSH
65033: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
65037: LD_INT 121
65039: PPUSH
65040: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
65044: LD_INT 122
65046: PPUSH
65047: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
65051: LD_INT 123
65053: PPUSH
65054: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
65058: LD_INT 124
65060: PPUSH
65061: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
65065: LD_INT 125
65067: PPUSH
65068: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
65072: LD_INT 126
65074: PPUSH
65075: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
65079: LD_INT 200
65081: PPUSH
65082: CALL_OW 427
// end ;
65086: END
// on SailEvent ( event ) do begin if event < 100 then
65087: LD_VAR 0 1
65091: PUSH
65092: LD_INT 100
65094: LESS
65095: IFFALSE 65106
// CustomEvent ( event ) ;
65097: LD_VAR 0 1
65101: PPUSH
65102: CALL 19111 0 1
// if event = 100 then
65106: LD_VAR 0 1
65110: PUSH
65111: LD_INT 100
65113: EQUAL
65114: IFFALSE 65120
// MC_ClassManager ( ) ;
65116: CALL 65512 0 0
// if event = 101 then
65120: LD_VAR 0 1
65124: PUSH
65125: LD_INT 101
65127: EQUAL
65128: IFFALSE 65134
// MC_RepairBuildings ( ) ;
65130: CALL 70330 0 0
// if event = 102 then
65134: LD_VAR 0 1
65138: PUSH
65139: LD_INT 102
65141: EQUAL
65142: IFFALSE 65148
// MC_Heal ( ) ;
65144: CALL 71265 0 0
// if event = 103 then
65148: LD_VAR 0 1
65152: PUSH
65153: LD_INT 103
65155: EQUAL
65156: IFFALSE 65162
// MC_Build ( ) ;
65158: CALL 71687 0 0
// if event = 104 then
65162: LD_VAR 0 1
65166: PUSH
65167: LD_INT 104
65169: EQUAL
65170: IFFALSE 65176
// MC_TurretWeapon ( ) ;
65172: CALL 73321 0 0
// if event = 105 then
65176: LD_VAR 0 1
65180: PUSH
65181: LD_INT 105
65183: EQUAL
65184: IFFALSE 65190
// MC_BuildUpgrade ( ) ;
65186: CALL 72872 0 0
// if event = 106 then
65190: LD_VAR 0 1
65194: PUSH
65195: LD_INT 106
65197: EQUAL
65198: IFFALSE 65204
// MC_PlantMines ( ) ;
65200: CALL 73751 0 0
// if event = 107 then
65204: LD_VAR 0 1
65208: PUSH
65209: LD_INT 107
65211: EQUAL
65212: IFFALSE 65218
// MC_CollectCrates ( ) ;
65214: CALL 74549 0 0
// if event = 108 then
65218: LD_VAR 0 1
65222: PUSH
65223: LD_INT 108
65225: EQUAL
65226: IFFALSE 65232
// MC_LinkRemoteControl ( ) ;
65228: CALL 76399 0 0
// if event = 109 then
65232: LD_VAR 0 1
65236: PUSH
65237: LD_INT 109
65239: EQUAL
65240: IFFALSE 65246
// MC_ProduceVehicle ( ) ;
65242: CALL 76580 0 0
// if event = 110 then
65246: LD_VAR 0 1
65250: PUSH
65251: LD_INT 110
65253: EQUAL
65254: IFFALSE 65260
// MC_SendAttack ( ) ;
65256: CALL 77046 0 0
// if event = 111 then
65260: LD_VAR 0 1
65264: PUSH
65265: LD_INT 111
65267: EQUAL
65268: IFFALSE 65274
// MC_Defend ( ) ;
65270: CALL 77154 0 0
// if event = 112 then
65274: LD_VAR 0 1
65278: PUSH
65279: LD_INT 112
65281: EQUAL
65282: IFFALSE 65288
// MC_Research ( ) ;
65284: CALL 78034 0 0
// if event = 113 then
65288: LD_VAR 0 1
65292: PUSH
65293: LD_INT 113
65295: EQUAL
65296: IFFALSE 65302
// MC_MinesTrigger ( ) ;
65298: CALL 79148 0 0
// if event = 120 then
65302: LD_VAR 0 1
65306: PUSH
65307: LD_INT 120
65309: EQUAL
65310: IFFALSE 65316
// MC_RepairVehicle ( ) ;
65312: CALL 79247 0 0
// if event = 121 then
65316: LD_VAR 0 1
65320: PUSH
65321: LD_INT 121
65323: EQUAL
65324: IFFALSE 65330
// MC_TameApe ( ) ;
65326: CALL 80016 0 0
// if event = 122 then
65330: LD_VAR 0 1
65334: PUSH
65335: LD_INT 122
65337: EQUAL
65338: IFFALSE 65344
// MC_ChangeApeClass ( ) ;
65340: CALL 80845 0 0
// if event = 123 then
65344: LD_VAR 0 1
65348: PUSH
65349: LD_INT 123
65351: EQUAL
65352: IFFALSE 65358
// MC_Bazooka ( ) ;
65354: CALL 81495 0 0
// if event = 124 then
65358: LD_VAR 0 1
65362: PUSH
65363: LD_INT 124
65365: EQUAL
65366: IFFALSE 65372
// MC_TeleportExit ( ) ;
65368: CALL 81693 0 0
// if event = 125 then
65372: LD_VAR 0 1
65376: PUSH
65377: LD_INT 125
65379: EQUAL
65380: IFFALSE 65386
// MC_Deposits ( ) ;
65382: CALL 82340 0 0
// if event = 126 then
65386: LD_VAR 0 1
65390: PUSH
65391: LD_INT 126
65393: EQUAL
65394: IFFALSE 65400
// MC_RemoteDriver ( ) ;
65396: CALL 82965 0 0
// if event = 200 then
65400: LD_VAR 0 1
65404: PUSH
65405: LD_INT 200
65407: EQUAL
65408: IFFALSE 65414
// MC_Idle ( ) ;
65410: CALL 84872 0 0
// end ;
65414: PPOPN 1
65416: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65417: LD_INT 0
65419: PPUSH
65420: PPUSH
// if not mc_bases [ base ] or not tag then
65421: LD_EXP 31
65425: PUSH
65426: LD_VAR 0 1
65430: ARRAY
65431: NOT
65432: PUSH
65433: LD_VAR 0 2
65437: NOT
65438: OR
65439: IFFALSE 65443
// exit ;
65441: GO 65507
// for i in mc_bases [ base ] union mc_ape [ base ] do
65443: LD_ADDR_VAR 0 4
65447: PUSH
65448: LD_EXP 31
65452: PUSH
65453: LD_VAR 0 1
65457: ARRAY
65458: PUSH
65459: LD_EXP 60
65463: PUSH
65464: LD_VAR 0 1
65468: ARRAY
65469: UNION
65470: PUSH
65471: FOR_IN
65472: IFFALSE 65505
// if GetTag ( i ) = tag then
65474: LD_VAR 0 4
65478: PPUSH
65479: CALL_OW 110
65483: PUSH
65484: LD_VAR 0 2
65488: EQUAL
65489: IFFALSE 65503
// SetTag ( i , 0 ) ;
65491: LD_VAR 0 4
65495: PPUSH
65496: LD_INT 0
65498: PPUSH
65499: CALL_OW 109
65503: GO 65471
65505: POP
65506: POP
// end ;
65507: LD_VAR 0 3
65511: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65512: LD_INT 0
65514: PPUSH
65515: PPUSH
65516: PPUSH
65517: PPUSH
65518: PPUSH
65519: PPUSH
65520: PPUSH
65521: PPUSH
// if not mc_bases then
65522: LD_EXP 31
65526: NOT
65527: IFFALSE 65531
// exit ;
65529: GO 65989
// for i = 1 to mc_bases do
65531: LD_ADDR_VAR 0 2
65535: PUSH
65536: DOUBLE
65537: LD_INT 1
65539: DEC
65540: ST_TO_ADDR
65541: LD_EXP 31
65545: PUSH
65546: FOR_TO
65547: IFFALSE 65987
// begin tmp := MC_ClassCheckReq ( i ) ;
65549: LD_ADDR_VAR 0 4
65553: PUSH
65554: LD_VAR 0 2
65558: PPUSH
65559: CALL 65994 0 1
65563: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65564: LD_ADDR_EXP 72
65568: PUSH
65569: LD_EXP 72
65573: PPUSH
65574: LD_VAR 0 2
65578: PPUSH
65579: LD_VAR 0 4
65583: PPUSH
65584: CALL_OW 1
65588: ST_TO_ADDR
// if not tmp then
65589: LD_VAR 0 4
65593: NOT
65594: IFFALSE 65598
// continue ;
65596: GO 65546
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65598: LD_ADDR_VAR 0 6
65602: PUSH
65603: LD_EXP 31
65607: PUSH
65608: LD_VAR 0 2
65612: ARRAY
65613: PPUSH
65614: LD_INT 2
65616: PUSH
65617: LD_INT 30
65619: PUSH
65620: LD_INT 4
65622: PUSH
65623: EMPTY
65624: LIST
65625: LIST
65626: PUSH
65627: LD_INT 30
65629: PUSH
65630: LD_INT 5
65632: PUSH
65633: EMPTY
65634: LIST
65635: LIST
65636: PUSH
65637: EMPTY
65638: LIST
65639: LIST
65640: LIST
65641: PPUSH
65642: CALL_OW 72
65646: PUSH
65647: LD_EXP 31
65651: PUSH
65652: LD_VAR 0 2
65656: ARRAY
65657: PPUSH
65658: LD_INT 2
65660: PUSH
65661: LD_INT 30
65663: PUSH
65664: LD_INT 0
65666: PUSH
65667: EMPTY
65668: LIST
65669: LIST
65670: PUSH
65671: LD_INT 30
65673: PUSH
65674: LD_INT 1
65676: PUSH
65677: EMPTY
65678: LIST
65679: LIST
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: LIST
65685: PPUSH
65686: CALL_OW 72
65690: PUSH
65691: LD_EXP 31
65695: PUSH
65696: LD_VAR 0 2
65700: ARRAY
65701: PPUSH
65702: LD_INT 30
65704: PUSH
65705: LD_INT 3
65707: PUSH
65708: EMPTY
65709: LIST
65710: LIST
65711: PPUSH
65712: CALL_OW 72
65716: PUSH
65717: LD_EXP 31
65721: PUSH
65722: LD_VAR 0 2
65726: ARRAY
65727: PPUSH
65728: LD_INT 2
65730: PUSH
65731: LD_INT 30
65733: PUSH
65734: LD_INT 6
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: PUSH
65741: LD_INT 30
65743: PUSH
65744: LD_INT 7
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: PUSH
65751: LD_INT 30
65753: PUSH
65754: LD_INT 8
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: PUSH
65761: EMPTY
65762: LIST
65763: LIST
65764: LIST
65765: LIST
65766: PPUSH
65767: CALL_OW 72
65771: PUSH
65772: EMPTY
65773: LIST
65774: LIST
65775: LIST
65776: LIST
65777: ST_TO_ADDR
// for j = 1 to 4 do
65778: LD_ADDR_VAR 0 3
65782: PUSH
65783: DOUBLE
65784: LD_INT 1
65786: DEC
65787: ST_TO_ADDR
65788: LD_INT 4
65790: PUSH
65791: FOR_TO
65792: IFFALSE 65983
// begin if not tmp [ j ] then
65794: LD_VAR 0 4
65798: PUSH
65799: LD_VAR 0 3
65803: ARRAY
65804: NOT
65805: IFFALSE 65809
// continue ;
65807: GO 65791
// for p in tmp [ j ] do
65809: LD_ADDR_VAR 0 5
65813: PUSH
65814: LD_VAR 0 4
65818: PUSH
65819: LD_VAR 0 3
65823: ARRAY
65824: PUSH
65825: FOR_IN
65826: IFFALSE 65979
// begin if not b [ j ] then
65828: LD_VAR 0 6
65832: PUSH
65833: LD_VAR 0 3
65837: ARRAY
65838: NOT
65839: IFFALSE 65843
// break ;
65841: GO 65979
// e := 0 ;
65843: LD_ADDR_VAR 0 7
65847: PUSH
65848: LD_INT 0
65850: ST_TO_ADDR
// for k in b [ j ] do
65851: LD_ADDR_VAR 0 8
65855: PUSH
65856: LD_VAR 0 6
65860: PUSH
65861: LD_VAR 0 3
65865: ARRAY
65866: PUSH
65867: FOR_IN
65868: IFFALSE 65895
// if IsNotFull ( k ) then
65870: LD_VAR 0 8
65874: PPUSH
65875: CALL 22068 0 1
65879: IFFALSE 65893
// begin e := k ;
65881: LD_ADDR_VAR 0 7
65885: PUSH
65886: LD_VAR 0 8
65890: ST_TO_ADDR
// break ;
65891: GO 65895
// end ;
65893: GO 65867
65895: POP
65896: POP
// if e and not UnitGoingToBuilding ( p , e ) then
65897: LD_VAR 0 7
65901: PUSH
65902: LD_VAR 0 5
65906: PPUSH
65907: LD_VAR 0 7
65911: PPUSH
65912: CALL 55821 0 2
65916: NOT
65917: AND
65918: IFFALSE 65977
// begin if IsInUnit ( p ) then
65920: LD_VAR 0 5
65924: PPUSH
65925: CALL_OW 310
65929: IFFALSE 65940
// ComExitBuilding ( p ) ;
65931: LD_VAR 0 5
65935: PPUSH
65936: CALL_OW 122
// ComEnterUnit ( p , e ) ;
65940: LD_VAR 0 5
65944: PPUSH
65945: LD_VAR 0 7
65949: PPUSH
65950: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
65954: LD_VAR 0 5
65958: PPUSH
65959: LD_VAR 0 3
65963: PPUSH
65964: CALL_OW 183
// AddComExitBuilding ( p ) ;
65968: LD_VAR 0 5
65972: PPUSH
65973: CALL_OW 182
// end ; end ;
65977: GO 65825
65979: POP
65980: POP
// end ;
65981: GO 65791
65983: POP
65984: POP
// end ;
65985: GO 65546
65987: POP
65988: POP
// end ;
65989: LD_VAR 0 1
65993: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
65994: LD_INT 0
65996: PPUSH
65997: PPUSH
65998: PPUSH
65999: PPUSH
66000: PPUSH
66001: PPUSH
66002: PPUSH
66003: PPUSH
66004: PPUSH
66005: PPUSH
66006: PPUSH
66007: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66008: LD_VAR 0 1
66012: NOT
66013: PUSH
66014: LD_EXP 31
66018: PUSH
66019: LD_VAR 0 1
66023: ARRAY
66024: NOT
66025: OR
66026: PUSH
66027: LD_EXP 31
66031: PUSH
66032: LD_VAR 0 1
66036: ARRAY
66037: PPUSH
66038: LD_INT 2
66040: PUSH
66041: LD_INT 30
66043: PUSH
66044: LD_INT 0
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PUSH
66051: LD_INT 30
66053: PUSH
66054: LD_INT 1
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: LIST
66065: PPUSH
66066: CALL_OW 72
66070: NOT
66071: OR
66072: IFFALSE 66076
// exit ;
66074: GO 69579
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66076: LD_ADDR_VAR 0 4
66080: PUSH
66081: LD_EXP 31
66085: PUSH
66086: LD_VAR 0 1
66090: ARRAY
66091: PPUSH
66092: LD_INT 2
66094: PUSH
66095: LD_INT 25
66097: PUSH
66098: LD_INT 1
66100: PUSH
66101: EMPTY
66102: LIST
66103: LIST
66104: PUSH
66105: LD_INT 25
66107: PUSH
66108: LD_INT 2
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 25
66117: PUSH
66118: LD_INT 3
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PUSH
66125: LD_INT 25
66127: PUSH
66128: LD_INT 4
66130: PUSH
66131: EMPTY
66132: LIST
66133: LIST
66134: PUSH
66135: LD_INT 25
66137: PUSH
66138: LD_INT 5
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PUSH
66145: LD_INT 25
66147: PUSH
66148: LD_INT 8
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PUSH
66155: LD_INT 25
66157: PUSH
66158: LD_INT 9
66160: PUSH
66161: EMPTY
66162: LIST
66163: LIST
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: PPUSH
66175: CALL_OW 72
66179: ST_TO_ADDR
// if not tmp then
66180: LD_VAR 0 4
66184: NOT
66185: IFFALSE 66189
// exit ;
66187: GO 69579
// for i in tmp do
66189: LD_ADDR_VAR 0 3
66193: PUSH
66194: LD_VAR 0 4
66198: PUSH
66199: FOR_IN
66200: IFFALSE 66231
// if GetTag ( i ) then
66202: LD_VAR 0 3
66206: PPUSH
66207: CALL_OW 110
66211: IFFALSE 66229
// tmp := tmp diff i ;
66213: LD_ADDR_VAR 0 4
66217: PUSH
66218: LD_VAR 0 4
66222: PUSH
66223: LD_VAR 0 3
66227: DIFF
66228: ST_TO_ADDR
66229: GO 66199
66231: POP
66232: POP
// if not tmp then
66233: LD_VAR 0 4
66237: NOT
66238: IFFALSE 66242
// exit ;
66240: GO 69579
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66242: LD_ADDR_VAR 0 5
66246: PUSH
66247: LD_EXP 31
66251: PUSH
66252: LD_VAR 0 1
66256: ARRAY
66257: PPUSH
66258: LD_INT 2
66260: PUSH
66261: LD_INT 25
66263: PUSH
66264: LD_INT 1
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: LD_INT 25
66273: PUSH
66274: LD_INT 5
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 25
66283: PUSH
66284: LD_INT 8
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 25
66293: PUSH
66294: LD_INT 9
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: LIST
66307: PPUSH
66308: CALL_OW 72
66312: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66313: LD_ADDR_VAR 0 6
66317: PUSH
66318: LD_EXP 31
66322: PUSH
66323: LD_VAR 0 1
66327: ARRAY
66328: PPUSH
66329: LD_INT 25
66331: PUSH
66332: LD_INT 2
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PPUSH
66339: CALL_OW 72
66343: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66344: LD_ADDR_VAR 0 7
66348: PUSH
66349: LD_EXP 31
66353: PUSH
66354: LD_VAR 0 1
66358: ARRAY
66359: PPUSH
66360: LD_INT 25
66362: PUSH
66363: LD_INT 3
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PPUSH
66370: CALL_OW 72
66374: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66375: LD_ADDR_VAR 0 8
66379: PUSH
66380: LD_EXP 31
66384: PUSH
66385: LD_VAR 0 1
66389: ARRAY
66390: PPUSH
66391: LD_INT 25
66393: PUSH
66394: LD_INT 4
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 24
66403: PUSH
66404: LD_INT 251
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: PPUSH
66415: CALL_OW 72
66419: ST_TO_ADDR
// if mc_is_defending [ base ] then
66420: LD_EXP 74
66424: PUSH
66425: LD_VAR 0 1
66429: ARRAY
66430: IFFALSE 66891
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66432: LD_ADDR_EXP 73
66436: PUSH
66437: LD_EXP 73
66441: PPUSH
66442: LD_VAR 0 1
66446: PPUSH
66447: LD_INT 4
66449: PPUSH
66450: CALL_OW 1
66454: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66455: LD_ADDR_VAR 0 12
66459: PUSH
66460: LD_EXP 31
66464: PUSH
66465: LD_VAR 0 1
66469: ARRAY
66470: PPUSH
66471: LD_INT 2
66473: PUSH
66474: LD_INT 30
66476: PUSH
66477: LD_INT 4
66479: PUSH
66480: EMPTY
66481: LIST
66482: LIST
66483: PUSH
66484: LD_INT 30
66486: PUSH
66487: LD_INT 5
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: LIST
66498: PPUSH
66499: CALL_OW 72
66503: ST_TO_ADDR
// if not b then
66504: LD_VAR 0 12
66508: NOT
66509: IFFALSE 66513
// exit ;
66511: GO 69579
// p := [ ] ;
66513: LD_ADDR_VAR 0 11
66517: PUSH
66518: EMPTY
66519: ST_TO_ADDR
// if sci >= 2 then
66520: LD_VAR 0 8
66524: PUSH
66525: LD_INT 2
66527: GREATEREQUAL
66528: IFFALSE 66559
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66530: LD_ADDR_VAR 0 8
66534: PUSH
66535: LD_VAR 0 8
66539: PUSH
66540: LD_INT 1
66542: ARRAY
66543: PUSH
66544: LD_VAR 0 8
66548: PUSH
66549: LD_INT 2
66551: ARRAY
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: ST_TO_ADDR
66557: GO 66620
// if sci = 1 then
66559: LD_VAR 0 8
66563: PUSH
66564: LD_INT 1
66566: EQUAL
66567: IFFALSE 66588
// sci := [ sci [ 1 ] ] else
66569: LD_ADDR_VAR 0 8
66573: PUSH
66574: LD_VAR 0 8
66578: PUSH
66579: LD_INT 1
66581: ARRAY
66582: PUSH
66583: EMPTY
66584: LIST
66585: ST_TO_ADDR
66586: GO 66620
// if sci = 0 then
66588: LD_VAR 0 8
66592: PUSH
66593: LD_INT 0
66595: EQUAL
66596: IFFALSE 66620
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66598: LD_ADDR_VAR 0 11
66602: PUSH
66603: LD_VAR 0 4
66607: PPUSH
66608: LD_INT 4
66610: PPUSH
66611: CALL 55693 0 2
66615: PUSH
66616: LD_INT 1
66618: ARRAY
66619: ST_TO_ADDR
// if eng > 4 then
66620: LD_VAR 0 6
66624: PUSH
66625: LD_INT 4
66627: GREATER
66628: IFFALSE 66674
// for i = eng downto 4 do
66630: LD_ADDR_VAR 0 3
66634: PUSH
66635: DOUBLE
66636: LD_VAR 0 6
66640: INC
66641: ST_TO_ADDR
66642: LD_INT 4
66644: PUSH
66645: FOR_DOWNTO
66646: IFFALSE 66672
// eng := eng diff eng [ i ] ;
66648: LD_ADDR_VAR 0 6
66652: PUSH
66653: LD_VAR 0 6
66657: PUSH
66658: LD_VAR 0 6
66662: PUSH
66663: LD_VAR 0 3
66667: ARRAY
66668: DIFF
66669: ST_TO_ADDR
66670: GO 66645
66672: POP
66673: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66674: LD_ADDR_VAR 0 4
66678: PUSH
66679: LD_VAR 0 4
66683: PUSH
66684: LD_VAR 0 5
66688: PUSH
66689: LD_VAR 0 6
66693: UNION
66694: PUSH
66695: LD_VAR 0 7
66699: UNION
66700: PUSH
66701: LD_VAR 0 8
66705: UNION
66706: DIFF
66707: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66708: LD_ADDR_VAR 0 13
66712: PUSH
66713: LD_EXP 31
66717: PUSH
66718: LD_VAR 0 1
66722: ARRAY
66723: PPUSH
66724: LD_INT 2
66726: PUSH
66727: LD_INT 30
66729: PUSH
66730: LD_INT 32
66732: PUSH
66733: EMPTY
66734: LIST
66735: LIST
66736: PUSH
66737: LD_INT 30
66739: PUSH
66740: LD_INT 31
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: LIST
66751: PPUSH
66752: CALL_OW 72
66756: PUSH
66757: LD_EXP 31
66761: PUSH
66762: LD_VAR 0 1
66766: ARRAY
66767: PPUSH
66768: LD_INT 2
66770: PUSH
66771: LD_INT 30
66773: PUSH
66774: LD_INT 4
66776: PUSH
66777: EMPTY
66778: LIST
66779: LIST
66780: PUSH
66781: LD_INT 30
66783: PUSH
66784: LD_INT 5
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: LIST
66795: PPUSH
66796: CALL_OW 72
66800: PUSH
66801: LD_INT 6
66803: MUL
66804: PLUS
66805: ST_TO_ADDR
// if bcount < tmp then
66806: LD_VAR 0 13
66810: PUSH
66811: LD_VAR 0 4
66815: LESS
66816: IFFALSE 66862
// for i = tmp downto bcount do
66818: LD_ADDR_VAR 0 3
66822: PUSH
66823: DOUBLE
66824: LD_VAR 0 4
66828: INC
66829: ST_TO_ADDR
66830: LD_VAR 0 13
66834: PUSH
66835: FOR_DOWNTO
66836: IFFALSE 66860
// tmp := Delete ( tmp , tmp ) ;
66838: LD_ADDR_VAR 0 4
66842: PUSH
66843: LD_VAR 0 4
66847: PPUSH
66848: LD_VAR 0 4
66852: PPUSH
66853: CALL_OW 3
66857: ST_TO_ADDR
66858: GO 66835
66860: POP
66861: POP
// result := [ tmp , 0 , 0 , p ] ;
66862: LD_ADDR_VAR 0 2
66866: PUSH
66867: LD_VAR 0 4
66871: PUSH
66872: LD_INT 0
66874: PUSH
66875: LD_INT 0
66877: PUSH
66878: LD_VAR 0 11
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: ST_TO_ADDR
// exit ;
66889: GO 69579
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66891: LD_EXP 31
66895: PUSH
66896: LD_VAR 0 1
66900: ARRAY
66901: PPUSH
66902: LD_INT 2
66904: PUSH
66905: LD_INT 30
66907: PUSH
66908: LD_INT 6
66910: PUSH
66911: EMPTY
66912: LIST
66913: LIST
66914: PUSH
66915: LD_INT 30
66917: PUSH
66918: LD_INT 7
66920: PUSH
66921: EMPTY
66922: LIST
66923: LIST
66924: PUSH
66925: LD_INT 30
66927: PUSH
66928: LD_INT 8
66930: PUSH
66931: EMPTY
66932: LIST
66933: LIST
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: LIST
66939: LIST
66940: PPUSH
66941: CALL_OW 72
66945: NOT
66946: PUSH
66947: LD_EXP 31
66951: PUSH
66952: LD_VAR 0 1
66956: ARRAY
66957: PPUSH
66958: LD_INT 30
66960: PUSH
66961: LD_INT 3
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PPUSH
66968: CALL_OW 72
66972: NOT
66973: AND
66974: IFFALSE 67046
// begin if eng = tmp then
66976: LD_VAR 0 6
66980: PUSH
66981: LD_VAR 0 4
66985: EQUAL
66986: IFFALSE 66990
// exit ;
66988: GO 69579
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
66990: LD_ADDR_EXP 73
66994: PUSH
66995: LD_EXP 73
66999: PPUSH
67000: LD_VAR 0 1
67004: PPUSH
67005: LD_INT 1
67007: PPUSH
67008: CALL_OW 1
67012: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
67013: LD_ADDR_VAR 0 2
67017: PUSH
67018: LD_INT 0
67020: PUSH
67021: LD_VAR 0 4
67025: PUSH
67026: LD_VAR 0 6
67030: DIFF
67031: PUSH
67032: LD_INT 0
67034: PUSH
67035: LD_INT 0
67037: PUSH
67038: EMPTY
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: ST_TO_ADDR
// exit ;
67044: GO 69579
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67046: LD_EXP 58
67050: PUSH
67051: LD_EXP 57
67055: PUSH
67056: LD_VAR 0 1
67060: ARRAY
67061: ARRAY
67062: PUSH
67063: LD_EXP 31
67067: PUSH
67068: LD_VAR 0 1
67072: ARRAY
67073: PPUSH
67074: LD_INT 2
67076: PUSH
67077: LD_INT 30
67079: PUSH
67080: LD_INT 6
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 30
67089: PUSH
67090: LD_INT 7
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PUSH
67097: LD_INT 30
67099: PUSH
67100: LD_INT 8
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: PPUSH
67113: CALL_OW 72
67117: AND
67118: PUSH
67119: LD_EXP 31
67123: PUSH
67124: LD_VAR 0 1
67128: ARRAY
67129: PPUSH
67130: LD_INT 30
67132: PUSH
67133: LD_INT 3
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PPUSH
67140: CALL_OW 72
67144: NOT
67145: AND
67146: IFFALSE 67360
// begin if sci >= 6 then
67148: LD_VAR 0 8
67152: PUSH
67153: LD_INT 6
67155: GREATEREQUAL
67156: IFFALSE 67160
// exit ;
67158: GO 69579
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
67160: LD_ADDR_EXP 73
67164: PUSH
67165: LD_EXP 73
67169: PPUSH
67170: LD_VAR 0 1
67174: PPUSH
67175: LD_INT 2
67177: PPUSH
67178: CALL_OW 1
67182: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
67183: LD_ADDR_VAR 0 9
67187: PUSH
67188: LD_VAR 0 4
67192: PUSH
67193: LD_VAR 0 8
67197: DIFF
67198: PPUSH
67199: LD_INT 4
67201: PPUSH
67202: CALL 55693 0 2
67206: ST_TO_ADDR
// p := [ ] ;
67207: LD_ADDR_VAR 0 11
67211: PUSH
67212: EMPTY
67213: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67214: LD_VAR 0 8
67218: PUSH
67219: LD_INT 6
67221: LESS
67222: PUSH
67223: LD_VAR 0 9
67227: PUSH
67228: LD_INT 6
67230: GREATER
67231: AND
67232: IFFALSE 67313
// begin for i = 1 to 6 - sci do
67234: LD_ADDR_VAR 0 3
67238: PUSH
67239: DOUBLE
67240: LD_INT 1
67242: DEC
67243: ST_TO_ADDR
67244: LD_INT 6
67246: PUSH
67247: LD_VAR 0 8
67251: MINUS
67252: PUSH
67253: FOR_TO
67254: IFFALSE 67309
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67256: LD_ADDR_VAR 0 11
67260: PUSH
67261: LD_VAR 0 11
67265: PPUSH
67266: LD_VAR 0 11
67270: PUSH
67271: LD_INT 1
67273: PLUS
67274: PPUSH
67275: LD_VAR 0 9
67279: PUSH
67280: LD_INT 1
67282: ARRAY
67283: PPUSH
67284: CALL_OW 2
67288: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67289: LD_ADDR_VAR 0 9
67293: PUSH
67294: LD_VAR 0 9
67298: PPUSH
67299: LD_INT 1
67301: PPUSH
67302: CALL_OW 3
67306: ST_TO_ADDR
// end ;
67307: GO 67253
67309: POP
67310: POP
// end else
67311: GO 67333
// if sort then
67313: LD_VAR 0 9
67317: IFFALSE 67333
// p := sort [ 1 ] ;
67319: LD_ADDR_VAR 0 11
67323: PUSH
67324: LD_VAR 0 9
67328: PUSH
67329: LD_INT 1
67331: ARRAY
67332: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67333: LD_ADDR_VAR 0 2
67337: PUSH
67338: LD_INT 0
67340: PUSH
67341: LD_INT 0
67343: PUSH
67344: LD_INT 0
67346: PUSH
67347: LD_VAR 0 11
67351: PUSH
67352: EMPTY
67353: LIST
67354: LIST
67355: LIST
67356: LIST
67357: ST_TO_ADDR
// exit ;
67358: GO 69579
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67360: LD_EXP 58
67364: PUSH
67365: LD_EXP 57
67369: PUSH
67370: LD_VAR 0 1
67374: ARRAY
67375: ARRAY
67376: PUSH
67377: LD_EXP 31
67381: PUSH
67382: LD_VAR 0 1
67386: ARRAY
67387: PPUSH
67388: LD_INT 2
67390: PUSH
67391: LD_INT 30
67393: PUSH
67394: LD_INT 6
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: LD_INT 30
67403: PUSH
67404: LD_INT 7
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 30
67413: PUSH
67414: LD_INT 8
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: LIST
67425: LIST
67426: PPUSH
67427: CALL_OW 72
67431: AND
67432: PUSH
67433: LD_EXP 31
67437: PUSH
67438: LD_VAR 0 1
67442: ARRAY
67443: PPUSH
67444: LD_INT 30
67446: PUSH
67447: LD_INT 3
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PPUSH
67454: CALL_OW 72
67458: AND
67459: IFFALSE 68193
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67461: LD_ADDR_EXP 73
67465: PUSH
67466: LD_EXP 73
67470: PPUSH
67471: LD_VAR 0 1
67475: PPUSH
67476: LD_INT 3
67478: PPUSH
67479: CALL_OW 1
67483: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67484: LD_ADDR_VAR 0 2
67488: PUSH
67489: LD_INT 0
67491: PUSH
67492: LD_INT 0
67494: PUSH
67495: LD_INT 0
67497: PUSH
67498: LD_INT 0
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: ST_TO_ADDR
// if not eng then
67507: LD_VAR 0 6
67511: NOT
67512: IFFALSE 67575
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67514: LD_ADDR_VAR 0 11
67518: PUSH
67519: LD_VAR 0 4
67523: PPUSH
67524: LD_INT 2
67526: PPUSH
67527: CALL 55693 0 2
67531: PUSH
67532: LD_INT 1
67534: ARRAY
67535: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67536: LD_ADDR_VAR 0 2
67540: PUSH
67541: LD_VAR 0 2
67545: PPUSH
67546: LD_INT 2
67548: PPUSH
67549: LD_VAR 0 11
67553: PPUSH
67554: CALL_OW 1
67558: ST_TO_ADDR
// tmp := tmp diff p ;
67559: LD_ADDR_VAR 0 4
67563: PUSH
67564: LD_VAR 0 4
67568: PUSH
67569: LD_VAR 0 11
67573: DIFF
67574: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67575: LD_VAR 0 4
67579: PUSH
67580: LD_VAR 0 8
67584: PUSH
67585: LD_INT 6
67587: LESS
67588: AND
67589: IFFALSE 67777
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67591: LD_ADDR_VAR 0 9
67595: PUSH
67596: LD_VAR 0 4
67600: PUSH
67601: LD_VAR 0 8
67605: PUSH
67606: LD_VAR 0 7
67610: UNION
67611: DIFF
67612: PPUSH
67613: LD_INT 4
67615: PPUSH
67616: CALL 55693 0 2
67620: ST_TO_ADDR
// p := [ ] ;
67621: LD_ADDR_VAR 0 11
67625: PUSH
67626: EMPTY
67627: ST_TO_ADDR
// if sort then
67628: LD_VAR 0 9
67632: IFFALSE 67748
// for i = 1 to 6 - sci do
67634: LD_ADDR_VAR 0 3
67638: PUSH
67639: DOUBLE
67640: LD_INT 1
67642: DEC
67643: ST_TO_ADDR
67644: LD_INT 6
67646: PUSH
67647: LD_VAR 0 8
67651: MINUS
67652: PUSH
67653: FOR_TO
67654: IFFALSE 67746
// begin if i = sort then
67656: LD_VAR 0 3
67660: PUSH
67661: LD_VAR 0 9
67665: EQUAL
67666: IFFALSE 67670
// break ;
67668: GO 67746
// if GetClass ( i ) = 4 then
67670: LD_VAR 0 3
67674: PPUSH
67675: CALL_OW 257
67679: PUSH
67680: LD_INT 4
67682: EQUAL
67683: IFFALSE 67687
// continue ;
67685: GO 67653
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67687: LD_ADDR_VAR 0 11
67691: PUSH
67692: LD_VAR 0 11
67696: PPUSH
67697: LD_VAR 0 11
67701: PUSH
67702: LD_INT 1
67704: PLUS
67705: PPUSH
67706: LD_VAR 0 9
67710: PUSH
67711: LD_VAR 0 3
67715: ARRAY
67716: PPUSH
67717: CALL_OW 2
67721: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67722: LD_ADDR_VAR 0 4
67726: PUSH
67727: LD_VAR 0 4
67731: PUSH
67732: LD_VAR 0 9
67736: PUSH
67737: LD_VAR 0 3
67741: ARRAY
67742: DIFF
67743: ST_TO_ADDR
// end ;
67744: GO 67653
67746: POP
67747: POP
// if p then
67748: LD_VAR 0 11
67752: IFFALSE 67777
// result := Replace ( result , 4 , p ) ;
67754: LD_ADDR_VAR 0 2
67758: PUSH
67759: LD_VAR 0 2
67763: PPUSH
67764: LD_INT 4
67766: PPUSH
67767: LD_VAR 0 11
67771: PPUSH
67772: CALL_OW 1
67776: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67777: LD_VAR 0 4
67781: PUSH
67782: LD_VAR 0 7
67786: PUSH
67787: LD_INT 6
67789: LESS
67790: AND
67791: IFFALSE 67979
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67793: LD_ADDR_VAR 0 9
67797: PUSH
67798: LD_VAR 0 4
67802: PUSH
67803: LD_VAR 0 8
67807: PUSH
67808: LD_VAR 0 7
67812: UNION
67813: DIFF
67814: PPUSH
67815: LD_INT 3
67817: PPUSH
67818: CALL 55693 0 2
67822: ST_TO_ADDR
// p := [ ] ;
67823: LD_ADDR_VAR 0 11
67827: PUSH
67828: EMPTY
67829: ST_TO_ADDR
// if sort then
67830: LD_VAR 0 9
67834: IFFALSE 67950
// for i = 1 to 6 - mech do
67836: LD_ADDR_VAR 0 3
67840: PUSH
67841: DOUBLE
67842: LD_INT 1
67844: DEC
67845: ST_TO_ADDR
67846: LD_INT 6
67848: PUSH
67849: LD_VAR 0 7
67853: MINUS
67854: PUSH
67855: FOR_TO
67856: IFFALSE 67948
// begin if i = sort then
67858: LD_VAR 0 3
67862: PUSH
67863: LD_VAR 0 9
67867: EQUAL
67868: IFFALSE 67872
// break ;
67870: GO 67948
// if GetClass ( i ) = 3 then
67872: LD_VAR 0 3
67876: PPUSH
67877: CALL_OW 257
67881: PUSH
67882: LD_INT 3
67884: EQUAL
67885: IFFALSE 67889
// continue ;
67887: GO 67855
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67889: LD_ADDR_VAR 0 11
67893: PUSH
67894: LD_VAR 0 11
67898: PPUSH
67899: LD_VAR 0 11
67903: PUSH
67904: LD_INT 1
67906: PLUS
67907: PPUSH
67908: LD_VAR 0 9
67912: PUSH
67913: LD_VAR 0 3
67917: ARRAY
67918: PPUSH
67919: CALL_OW 2
67923: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67924: LD_ADDR_VAR 0 4
67928: PUSH
67929: LD_VAR 0 4
67933: PUSH
67934: LD_VAR 0 9
67938: PUSH
67939: LD_VAR 0 3
67943: ARRAY
67944: DIFF
67945: ST_TO_ADDR
// end ;
67946: GO 67855
67948: POP
67949: POP
// if p then
67950: LD_VAR 0 11
67954: IFFALSE 67979
// result := Replace ( result , 3 , p ) ;
67956: LD_ADDR_VAR 0 2
67960: PUSH
67961: LD_VAR 0 2
67965: PPUSH
67966: LD_INT 3
67968: PPUSH
67969: LD_VAR 0 11
67973: PPUSH
67974: CALL_OW 1
67978: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
67979: LD_VAR 0 4
67983: PUSH
67984: LD_INT 6
67986: GREATER
67987: PUSH
67988: LD_VAR 0 6
67992: PUSH
67993: LD_INT 6
67995: LESS
67996: AND
67997: IFFALSE 68191
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67999: LD_ADDR_VAR 0 9
68003: PUSH
68004: LD_VAR 0 4
68008: PUSH
68009: LD_VAR 0 8
68013: PUSH
68014: LD_VAR 0 7
68018: UNION
68019: PUSH
68020: LD_VAR 0 6
68024: UNION
68025: DIFF
68026: PPUSH
68027: LD_INT 2
68029: PPUSH
68030: CALL 55693 0 2
68034: ST_TO_ADDR
// p := [ ] ;
68035: LD_ADDR_VAR 0 11
68039: PUSH
68040: EMPTY
68041: ST_TO_ADDR
// if sort then
68042: LD_VAR 0 9
68046: IFFALSE 68162
// for i = 1 to 6 - eng do
68048: LD_ADDR_VAR 0 3
68052: PUSH
68053: DOUBLE
68054: LD_INT 1
68056: DEC
68057: ST_TO_ADDR
68058: LD_INT 6
68060: PUSH
68061: LD_VAR 0 6
68065: MINUS
68066: PUSH
68067: FOR_TO
68068: IFFALSE 68160
// begin if i = sort then
68070: LD_VAR 0 3
68074: PUSH
68075: LD_VAR 0 9
68079: EQUAL
68080: IFFALSE 68084
// break ;
68082: GO 68160
// if GetClass ( i ) = 2 then
68084: LD_VAR 0 3
68088: PPUSH
68089: CALL_OW 257
68093: PUSH
68094: LD_INT 2
68096: EQUAL
68097: IFFALSE 68101
// continue ;
68099: GO 68067
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68101: LD_ADDR_VAR 0 11
68105: PUSH
68106: LD_VAR 0 11
68110: PPUSH
68111: LD_VAR 0 11
68115: PUSH
68116: LD_INT 1
68118: PLUS
68119: PPUSH
68120: LD_VAR 0 9
68124: PUSH
68125: LD_VAR 0 3
68129: ARRAY
68130: PPUSH
68131: CALL_OW 2
68135: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68136: LD_ADDR_VAR 0 4
68140: PUSH
68141: LD_VAR 0 4
68145: PUSH
68146: LD_VAR 0 9
68150: PUSH
68151: LD_VAR 0 3
68155: ARRAY
68156: DIFF
68157: ST_TO_ADDR
// end ;
68158: GO 68067
68160: POP
68161: POP
// if p then
68162: LD_VAR 0 11
68166: IFFALSE 68191
// result := Replace ( result , 2 , p ) ;
68168: LD_ADDR_VAR 0 2
68172: PUSH
68173: LD_VAR 0 2
68177: PPUSH
68178: LD_INT 2
68180: PPUSH
68181: LD_VAR 0 11
68185: PPUSH
68186: CALL_OW 1
68190: ST_TO_ADDR
// end ; exit ;
68191: GO 69579
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
68193: LD_EXP 58
68197: PUSH
68198: LD_EXP 57
68202: PUSH
68203: LD_VAR 0 1
68207: ARRAY
68208: ARRAY
68209: NOT
68210: PUSH
68211: LD_EXP 31
68215: PUSH
68216: LD_VAR 0 1
68220: ARRAY
68221: PPUSH
68222: LD_INT 30
68224: PUSH
68225: LD_INT 3
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PPUSH
68232: CALL_OW 72
68236: AND
68237: PUSH
68238: LD_EXP 36
68242: PUSH
68243: LD_VAR 0 1
68247: ARRAY
68248: AND
68249: IFFALSE 68857
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68251: LD_ADDR_EXP 73
68255: PUSH
68256: LD_EXP 73
68260: PPUSH
68261: LD_VAR 0 1
68265: PPUSH
68266: LD_INT 5
68268: PPUSH
68269: CALL_OW 1
68273: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68274: LD_ADDR_VAR 0 2
68278: PUSH
68279: LD_INT 0
68281: PUSH
68282: LD_INT 0
68284: PUSH
68285: LD_INT 0
68287: PUSH
68288: LD_INT 0
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: ST_TO_ADDR
// if sci > 1 then
68297: LD_VAR 0 8
68301: PUSH
68302: LD_INT 1
68304: GREATER
68305: IFFALSE 68333
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68307: LD_ADDR_VAR 0 4
68311: PUSH
68312: LD_VAR 0 4
68316: PUSH
68317: LD_VAR 0 8
68321: PUSH
68322: LD_VAR 0 8
68326: PUSH
68327: LD_INT 1
68329: ARRAY
68330: DIFF
68331: DIFF
68332: ST_TO_ADDR
// if tmp and not sci then
68333: LD_VAR 0 4
68337: PUSH
68338: LD_VAR 0 8
68342: NOT
68343: AND
68344: IFFALSE 68413
// begin sort := SortBySkill ( tmp , 4 ) ;
68346: LD_ADDR_VAR 0 9
68350: PUSH
68351: LD_VAR 0 4
68355: PPUSH
68356: LD_INT 4
68358: PPUSH
68359: CALL 55693 0 2
68363: ST_TO_ADDR
// if sort then
68364: LD_VAR 0 9
68368: IFFALSE 68384
// p := sort [ 1 ] ;
68370: LD_ADDR_VAR 0 11
68374: PUSH
68375: LD_VAR 0 9
68379: PUSH
68380: LD_INT 1
68382: ARRAY
68383: ST_TO_ADDR
// if p then
68384: LD_VAR 0 11
68388: IFFALSE 68413
// result := Replace ( result , 4 , p ) ;
68390: LD_ADDR_VAR 0 2
68394: PUSH
68395: LD_VAR 0 2
68399: PPUSH
68400: LD_INT 4
68402: PPUSH
68403: LD_VAR 0 11
68407: PPUSH
68408: CALL_OW 1
68412: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68413: LD_ADDR_VAR 0 4
68417: PUSH
68418: LD_VAR 0 4
68422: PUSH
68423: LD_VAR 0 7
68427: DIFF
68428: ST_TO_ADDR
// if tmp and mech < 6 then
68429: LD_VAR 0 4
68433: PUSH
68434: LD_VAR 0 7
68438: PUSH
68439: LD_INT 6
68441: LESS
68442: AND
68443: IFFALSE 68631
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68445: LD_ADDR_VAR 0 9
68449: PUSH
68450: LD_VAR 0 4
68454: PUSH
68455: LD_VAR 0 8
68459: PUSH
68460: LD_VAR 0 7
68464: UNION
68465: DIFF
68466: PPUSH
68467: LD_INT 3
68469: PPUSH
68470: CALL 55693 0 2
68474: ST_TO_ADDR
// p := [ ] ;
68475: LD_ADDR_VAR 0 11
68479: PUSH
68480: EMPTY
68481: ST_TO_ADDR
// if sort then
68482: LD_VAR 0 9
68486: IFFALSE 68602
// for i = 1 to 6 - mech do
68488: LD_ADDR_VAR 0 3
68492: PUSH
68493: DOUBLE
68494: LD_INT 1
68496: DEC
68497: ST_TO_ADDR
68498: LD_INT 6
68500: PUSH
68501: LD_VAR 0 7
68505: MINUS
68506: PUSH
68507: FOR_TO
68508: IFFALSE 68600
// begin if i = sort then
68510: LD_VAR 0 3
68514: PUSH
68515: LD_VAR 0 9
68519: EQUAL
68520: IFFALSE 68524
// break ;
68522: GO 68600
// if GetClass ( i ) = 3 then
68524: LD_VAR 0 3
68528: PPUSH
68529: CALL_OW 257
68533: PUSH
68534: LD_INT 3
68536: EQUAL
68537: IFFALSE 68541
// continue ;
68539: GO 68507
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68541: LD_ADDR_VAR 0 11
68545: PUSH
68546: LD_VAR 0 11
68550: PPUSH
68551: LD_VAR 0 11
68555: PUSH
68556: LD_INT 1
68558: PLUS
68559: PPUSH
68560: LD_VAR 0 9
68564: PUSH
68565: LD_VAR 0 3
68569: ARRAY
68570: PPUSH
68571: CALL_OW 2
68575: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68576: LD_ADDR_VAR 0 4
68580: PUSH
68581: LD_VAR 0 4
68585: PUSH
68586: LD_VAR 0 9
68590: PUSH
68591: LD_VAR 0 3
68595: ARRAY
68596: DIFF
68597: ST_TO_ADDR
// end ;
68598: GO 68507
68600: POP
68601: POP
// if p then
68602: LD_VAR 0 11
68606: IFFALSE 68631
// result := Replace ( result , 3 , p ) ;
68608: LD_ADDR_VAR 0 2
68612: PUSH
68613: LD_VAR 0 2
68617: PPUSH
68618: LD_INT 3
68620: PPUSH
68621: LD_VAR 0 11
68625: PPUSH
68626: CALL_OW 1
68630: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68631: LD_ADDR_VAR 0 4
68635: PUSH
68636: LD_VAR 0 4
68640: PUSH
68641: LD_VAR 0 6
68645: DIFF
68646: ST_TO_ADDR
// if tmp and eng < 6 then
68647: LD_VAR 0 4
68651: PUSH
68652: LD_VAR 0 6
68656: PUSH
68657: LD_INT 6
68659: LESS
68660: AND
68661: IFFALSE 68855
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68663: LD_ADDR_VAR 0 9
68667: PUSH
68668: LD_VAR 0 4
68672: PUSH
68673: LD_VAR 0 8
68677: PUSH
68678: LD_VAR 0 7
68682: UNION
68683: PUSH
68684: LD_VAR 0 6
68688: UNION
68689: DIFF
68690: PPUSH
68691: LD_INT 2
68693: PPUSH
68694: CALL 55693 0 2
68698: ST_TO_ADDR
// p := [ ] ;
68699: LD_ADDR_VAR 0 11
68703: PUSH
68704: EMPTY
68705: ST_TO_ADDR
// if sort then
68706: LD_VAR 0 9
68710: IFFALSE 68826
// for i = 1 to 6 - eng do
68712: LD_ADDR_VAR 0 3
68716: PUSH
68717: DOUBLE
68718: LD_INT 1
68720: DEC
68721: ST_TO_ADDR
68722: LD_INT 6
68724: PUSH
68725: LD_VAR 0 6
68729: MINUS
68730: PUSH
68731: FOR_TO
68732: IFFALSE 68824
// begin if i = sort then
68734: LD_VAR 0 3
68738: PUSH
68739: LD_VAR 0 9
68743: EQUAL
68744: IFFALSE 68748
// break ;
68746: GO 68824
// if GetClass ( i ) = 2 then
68748: LD_VAR 0 3
68752: PPUSH
68753: CALL_OW 257
68757: PUSH
68758: LD_INT 2
68760: EQUAL
68761: IFFALSE 68765
// continue ;
68763: GO 68731
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68765: LD_ADDR_VAR 0 11
68769: PUSH
68770: LD_VAR 0 11
68774: PPUSH
68775: LD_VAR 0 11
68779: PUSH
68780: LD_INT 1
68782: PLUS
68783: PPUSH
68784: LD_VAR 0 9
68788: PUSH
68789: LD_VAR 0 3
68793: ARRAY
68794: PPUSH
68795: CALL_OW 2
68799: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68800: LD_ADDR_VAR 0 4
68804: PUSH
68805: LD_VAR 0 4
68809: PUSH
68810: LD_VAR 0 9
68814: PUSH
68815: LD_VAR 0 3
68819: ARRAY
68820: DIFF
68821: ST_TO_ADDR
// end ;
68822: GO 68731
68824: POP
68825: POP
// if p then
68826: LD_VAR 0 11
68830: IFFALSE 68855
// result := Replace ( result , 2 , p ) ;
68832: LD_ADDR_VAR 0 2
68836: PUSH
68837: LD_VAR 0 2
68841: PPUSH
68842: LD_INT 2
68844: PPUSH
68845: LD_VAR 0 11
68849: PPUSH
68850: CALL_OW 1
68854: ST_TO_ADDR
// end ; exit ;
68855: GO 69579
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
68857: LD_EXP 58
68861: PUSH
68862: LD_EXP 57
68866: PUSH
68867: LD_VAR 0 1
68871: ARRAY
68872: ARRAY
68873: NOT
68874: PUSH
68875: LD_EXP 31
68879: PUSH
68880: LD_VAR 0 1
68884: ARRAY
68885: PPUSH
68886: LD_INT 30
68888: PUSH
68889: LD_INT 3
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PPUSH
68896: CALL_OW 72
68900: AND
68901: PUSH
68902: LD_EXP 36
68906: PUSH
68907: LD_VAR 0 1
68911: ARRAY
68912: NOT
68913: AND
68914: IFFALSE 69579
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
68916: LD_ADDR_EXP 73
68920: PUSH
68921: LD_EXP 73
68925: PPUSH
68926: LD_VAR 0 1
68930: PPUSH
68931: LD_INT 6
68933: PPUSH
68934: CALL_OW 1
68938: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68939: LD_ADDR_VAR 0 2
68943: PUSH
68944: LD_INT 0
68946: PUSH
68947: LD_INT 0
68949: PUSH
68950: LD_INT 0
68952: PUSH
68953: LD_INT 0
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: ST_TO_ADDR
// if sci >= 1 then
68962: LD_VAR 0 8
68966: PUSH
68967: LD_INT 1
68969: GREATEREQUAL
68970: IFFALSE 68992
// tmp := tmp diff sci [ 1 ] ;
68972: LD_ADDR_VAR 0 4
68976: PUSH
68977: LD_VAR 0 4
68981: PUSH
68982: LD_VAR 0 8
68986: PUSH
68987: LD_INT 1
68989: ARRAY
68990: DIFF
68991: ST_TO_ADDR
// if tmp and not sci then
68992: LD_VAR 0 4
68996: PUSH
68997: LD_VAR 0 8
69001: NOT
69002: AND
69003: IFFALSE 69072
// begin sort := SortBySkill ( tmp , 4 ) ;
69005: LD_ADDR_VAR 0 9
69009: PUSH
69010: LD_VAR 0 4
69014: PPUSH
69015: LD_INT 4
69017: PPUSH
69018: CALL 55693 0 2
69022: ST_TO_ADDR
// if sort then
69023: LD_VAR 0 9
69027: IFFALSE 69043
// p := sort [ 1 ] ;
69029: LD_ADDR_VAR 0 11
69033: PUSH
69034: LD_VAR 0 9
69038: PUSH
69039: LD_INT 1
69041: ARRAY
69042: ST_TO_ADDR
// if p then
69043: LD_VAR 0 11
69047: IFFALSE 69072
// result := Replace ( result , 4 , p ) ;
69049: LD_ADDR_VAR 0 2
69053: PUSH
69054: LD_VAR 0 2
69058: PPUSH
69059: LD_INT 4
69061: PPUSH
69062: LD_VAR 0 11
69066: PPUSH
69067: CALL_OW 1
69071: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69072: LD_ADDR_VAR 0 4
69076: PUSH
69077: LD_VAR 0 4
69081: PUSH
69082: LD_VAR 0 7
69086: DIFF
69087: ST_TO_ADDR
// if tmp and mech < 6 then
69088: LD_VAR 0 4
69092: PUSH
69093: LD_VAR 0 7
69097: PUSH
69098: LD_INT 6
69100: LESS
69101: AND
69102: IFFALSE 69284
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
69104: LD_ADDR_VAR 0 9
69108: PUSH
69109: LD_VAR 0 4
69113: PUSH
69114: LD_VAR 0 7
69118: DIFF
69119: PPUSH
69120: LD_INT 3
69122: PPUSH
69123: CALL 55693 0 2
69127: ST_TO_ADDR
// p := [ ] ;
69128: LD_ADDR_VAR 0 11
69132: PUSH
69133: EMPTY
69134: ST_TO_ADDR
// if sort then
69135: LD_VAR 0 9
69139: IFFALSE 69255
// for i = 1 to 6 - mech do
69141: LD_ADDR_VAR 0 3
69145: PUSH
69146: DOUBLE
69147: LD_INT 1
69149: DEC
69150: ST_TO_ADDR
69151: LD_INT 6
69153: PUSH
69154: LD_VAR 0 7
69158: MINUS
69159: PUSH
69160: FOR_TO
69161: IFFALSE 69253
// begin if i = sort then
69163: LD_VAR 0 3
69167: PUSH
69168: LD_VAR 0 9
69172: EQUAL
69173: IFFALSE 69177
// break ;
69175: GO 69253
// if GetClass ( i ) = 3 then
69177: LD_VAR 0 3
69181: PPUSH
69182: CALL_OW 257
69186: PUSH
69187: LD_INT 3
69189: EQUAL
69190: IFFALSE 69194
// continue ;
69192: GO 69160
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69194: LD_ADDR_VAR 0 11
69198: PUSH
69199: LD_VAR 0 11
69203: PPUSH
69204: LD_VAR 0 11
69208: PUSH
69209: LD_INT 1
69211: PLUS
69212: PPUSH
69213: LD_VAR 0 9
69217: PUSH
69218: LD_VAR 0 3
69222: ARRAY
69223: PPUSH
69224: CALL_OW 2
69228: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69229: LD_ADDR_VAR 0 4
69233: PUSH
69234: LD_VAR 0 4
69238: PUSH
69239: LD_VAR 0 9
69243: PUSH
69244: LD_VAR 0 3
69248: ARRAY
69249: DIFF
69250: ST_TO_ADDR
// end ;
69251: GO 69160
69253: POP
69254: POP
// if p then
69255: LD_VAR 0 11
69259: IFFALSE 69284
// result := Replace ( result , 3 , p ) ;
69261: LD_ADDR_VAR 0 2
69265: PUSH
69266: LD_VAR 0 2
69270: PPUSH
69271: LD_INT 3
69273: PPUSH
69274: LD_VAR 0 11
69278: PPUSH
69279: CALL_OW 1
69283: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69284: LD_ADDR_VAR 0 4
69288: PUSH
69289: LD_VAR 0 4
69293: PUSH
69294: LD_VAR 0 6
69298: DIFF
69299: ST_TO_ADDR
// if tmp and eng < 4 then
69300: LD_VAR 0 4
69304: PUSH
69305: LD_VAR 0 6
69309: PUSH
69310: LD_INT 4
69312: LESS
69313: AND
69314: IFFALSE 69504
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69316: LD_ADDR_VAR 0 9
69320: PUSH
69321: LD_VAR 0 4
69325: PUSH
69326: LD_VAR 0 7
69330: PUSH
69331: LD_VAR 0 6
69335: UNION
69336: DIFF
69337: PPUSH
69338: LD_INT 2
69340: PPUSH
69341: CALL 55693 0 2
69345: ST_TO_ADDR
// p := [ ] ;
69346: LD_ADDR_VAR 0 11
69350: PUSH
69351: EMPTY
69352: ST_TO_ADDR
// if sort then
69353: LD_VAR 0 9
69357: IFFALSE 69473
// for i = 1 to 4 - eng do
69359: LD_ADDR_VAR 0 3
69363: PUSH
69364: DOUBLE
69365: LD_INT 1
69367: DEC
69368: ST_TO_ADDR
69369: LD_INT 4
69371: PUSH
69372: LD_VAR 0 6
69376: MINUS
69377: PUSH
69378: FOR_TO
69379: IFFALSE 69471
// begin if i = sort then
69381: LD_VAR 0 3
69385: PUSH
69386: LD_VAR 0 9
69390: EQUAL
69391: IFFALSE 69395
// break ;
69393: GO 69471
// if GetClass ( i ) = 2 then
69395: LD_VAR 0 3
69399: PPUSH
69400: CALL_OW 257
69404: PUSH
69405: LD_INT 2
69407: EQUAL
69408: IFFALSE 69412
// continue ;
69410: GO 69378
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69412: LD_ADDR_VAR 0 11
69416: PUSH
69417: LD_VAR 0 11
69421: PPUSH
69422: LD_VAR 0 11
69426: PUSH
69427: LD_INT 1
69429: PLUS
69430: PPUSH
69431: LD_VAR 0 9
69435: PUSH
69436: LD_VAR 0 3
69440: ARRAY
69441: PPUSH
69442: CALL_OW 2
69446: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69447: LD_ADDR_VAR 0 4
69451: PUSH
69452: LD_VAR 0 4
69456: PUSH
69457: LD_VAR 0 9
69461: PUSH
69462: LD_VAR 0 3
69466: ARRAY
69467: DIFF
69468: ST_TO_ADDR
// end ;
69469: GO 69378
69471: POP
69472: POP
// if p then
69473: LD_VAR 0 11
69477: IFFALSE 69502
// result := Replace ( result , 2 , p ) ;
69479: LD_ADDR_VAR 0 2
69483: PUSH
69484: LD_VAR 0 2
69488: PPUSH
69489: LD_INT 2
69491: PPUSH
69492: LD_VAR 0 11
69496: PPUSH
69497: CALL_OW 1
69501: ST_TO_ADDR
// end else
69502: GO 69548
// for i = eng downto 5 do
69504: LD_ADDR_VAR 0 3
69508: PUSH
69509: DOUBLE
69510: LD_VAR 0 6
69514: INC
69515: ST_TO_ADDR
69516: LD_INT 5
69518: PUSH
69519: FOR_DOWNTO
69520: IFFALSE 69546
// tmp := tmp union eng [ i ] ;
69522: LD_ADDR_VAR 0 4
69526: PUSH
69527: LD_VAR 0 4
69531: PUSH
69532: LD_VAR 0 6
69536: PUSH
69537: LD_VAR 0 3
69541: ARRAY
69542: UNION
69543: ST_TO_ADDR
69544: GO 69519
69546: POP
69547: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69548: LD_ADDR_VAR 0 2
69552: PUSH
69553: LD_VAR 0 2
69557: PPUSH
69558: LD_INT 1
69560: PPUSH
69561: LD_VAR 0 4
69565: PUSH
69566: LD_VAR 0 5
69570: DIFF
69571: PPUSH
69572: CALL_OW 1
69576: ST_TO_ADDR
// exit ;
69577: GO 69579
// end ; end ;
69579: LD_VAR 0 2
69583: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69584: LD_INT 0
69586: PPUSH
69587: PPUSH
69588: PPUSH
// if not mc_bases then
69589: LD_EXP 31
69593: NOT
69594: IFFALSE 69598
// exit ;
69596: GO 69740
// for i = 1 to mc_bases do
69598: LD_ADDR_VAR 0 2
69602: PUSH
69603: DOUBLE
69604: LD_INT 1
69606: DEC
69607: ST_TO_ADDR
69608: LD_EXP 31
69612: PUSH
69613: FOR_TO
69614: IFFALSE 69731
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69616: LD_ADDR_VAR 0 3
69620: PUSH
69621: LD_EXP 31
69625: PUSH
69626: LD_VAR 0 2
69630: ARRAY
69631: PPUSH
69632: LD_INT 21
69634: PUSH
69635: LD_INT 3
69637: PUSH
69638: EMPTY
69639: LIST
69640: LIST
69641: PUSH
69642: LD_INT 3
69644: PUSH
69645: LD_INT 2
69647: PUSH
69648: LD_INT 30
69650: PUSH
69651: LD_INT 29
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: PUSH
69658: LD_INT 30
69660: PUSH
69661: LD_INT 30
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: LIST
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 3
69679: PUSH
69680: LD_INT 24
69682: PUSH
69683: LD_INT 1000
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: LIST
69698: PPUSH
69699: CALL_OW 72
69703: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69704: LD_ADDR_EXP 32
69708: PUSH
69709: LD_EXP 32
69713: PPUSH
69714: LD_VAR 0 2
69718: PPUSH
69719: LD_VAR 0 3
69723: PPUSH
69724: CALL_OW 1
69728: ST_TO_ADDR
// end ;
69729: GO 69613
69731: POP
69732: POP
// RaiseSailEvent ( 101 ) ;
69733: LD_INT 101
69735: PPUSH
69736: CALL_OW 427
// end ;
69740: LD_VAR 0 1
69744: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69745: LD_INT 0
69747: PPUSH
69748: PPUSH
69749: PPUSH
69750: PPUSH
69751: PPUSH
69752: PPUSH
69753: PPUSH
// if not mc_bases then
69754: LD_EXP 31
69758: NOT
69759: IFFALSE 69763
// exit ;
69761: GO 70325
// for i = 1 to mc_bases do
69763: LD_ADDR_VAR 0 2
69767: PUSH
69768: DOUBLE
69769: LD_INT 1
69771: DEC
69772: ST_TO_ADDR
69773: LD_EXP 31
69777: PUSH
69778: FOR_TO
69779: IFFALSE 70316
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69781: LD_ADDR_VAR 0 5
69785: PUSH
69786: LD_EXP 31
69790: PUSH
69791: LD_VAR 0 2
69795: ARRAY
69796: PUSH
69797: LD_EXP 60
69801: PUSH
69802: LD_VAR 0 2
69806: ARRAY
69807: UNION
69808: PPUSH
69809: LD_INT 21
69811: PUSH
69812: LD_INT 1
69814: PUSH
69815: EMPTY
69816: LIST
69817: LIST
69818: PUSH
69819: LD_INT 1
69821: PUSH
69822: LD_INT 3
69824: PUSH
69825: LD_INT 54
69827: PUSH
69828: EMPTY
69829: LIST
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: PUSH
69835: LD_INT 3
69837: PUSH
69838: LD_INT 24
69840: PUSH
69841: LD_INT 1000
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: LIST
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PPUSH
69861: CALL_OW 72
69865: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
69866: LD_ADDR_VAR 0 6
69870: PUSH
69871: LD_EXP 31
69875: PUSH
69876: LD_VAR 0 2
69880: ARRAY
69881: PPUSH
69882: LD_INT 21
69884: PUSH
69885: LD_INT 1
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: LD_INT 1
69894: PUSH
69895: LD_INT 3
69897: PUSH
69898: LD_INT 54
69900: PUSH
69901: EMPTY
69902: LIST
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 3
69910: PUSH
69911: LD_INT 24
69913: PUSH
69914: LD_INT 250
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: LIST
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PPUSH
69934: CALL_OW 72
69938: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
69939: LD_ADDR_VAR 0 7
69943: PUSH
69944: LD_VAR 0 5
69948: PUSH
69949: LD_VAR 0 6
69953: DIFF
69954: ST_TO_ADDR
// if not need_heal_1 then
69955: LD_VAR 0 6
69959: NOT
69960: IFFALSE 69993
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
69962: LD_ADDR_EXP 34
69966: PUSH
69967: LD_EXP 34
69971: PPUSH
69972: LD_VAR 0 2
69976: PUSH
69977: LD_INT 1
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PPUSH
69984: EMPTY
69985: PPUSH
69986: CALL 24846 0 3
69990: ST_TO_ADDR
69991: GO 70063
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
69993: LD_ADDR_EXP 34
69997: PUSH
69998: LD_EXP 34
70002: PPUSH
70003: LD_VAR 0 2
70007: PUSH
70008: LD_INT 1
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PPUSH
70015: LD_EXP 34
70019: PUSH
70020: LD_VAR 0 2
70024: ARRAY
70025: PUSH
70026: LD_INT 1
70028: ARRAY
70029: PPUSH
70030: LD_INT 3
70032: PUSH
70033: LD_INT 24
70035: PUSH
70036: LD_INT 1000
70038: PUSH
70039: EMPTY
70040: LIST
70041: LIST
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PPUSH
70047: CALL_OW 72
70051: PUSH
70052: LD_VAR 0 6
70056: UNION
70057: PPUSH
70058: CALL 24846 0 3
70062: ST_TO_ADDR
// if not need_heal_2 then
70063: LD_VAR 0 7
70067: NOT
70068: IFFALSE 70101
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
70070: LD_ADDR_EXP 34
70074: PUSH
70075: LD_EXP 34
70079: PPUSH
70080: LD_VAR 0 2
70084: PUSH
70085: LD_INT 2
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PPUSH
70092: EMPTY
70093: PPUSH
70094: CALL 24846 0 3
70098: ST_TO_ADDR
70099: GO 70133
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
70101: LD_ADDR_EXP 34
70105: PUSH
70106: LD_EXP 34
70110: PPUSH
70111: LD_VAR 0 2
70115: PUSH
70116: LD_INT 2
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: PPUSH
70123: LD_VAR 0 7
70127: PPUSH
70128: CALL 24846 0 3
70132: ST_TO_ADDR
// if need_heal_2 then
70133: LD_VAR 0 7
70137: IFFALSE 70298
// for j in need_heal_2 do
70139: LD_ADDR_VAR 0 3
70143: PUSH
70144: LD_VAR 0 7
70148: PUSH
70149: FOR_IN
70150: IFFALSE 70296
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70152: LD_ADDR_VAR 0 5
70156: PUSH
70157: LD_EXP 31
70161: PUSH
70162: LD_VAR 0 2
70166: ARRAY
70167: PPUSH
70168: LD_INT 2
70170: PUSH
70171: LD_INT 30
70173: PUSH
70174: LD_INT 6
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 30
70183: PUSH
70184: LD_INT 7
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 30
70193: PUSH
70194: LD_INT 8
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 30
70203: PUSH
70204: LD_INT 0
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 30
70213: PUSH
70214: LD_INT 1
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: PPUSH
70229: CALL_OW 72
70233: ST_TO_ADDR
// if tmp then
70234: LD_VAR 0 5
70238: IFFALSE 70294
// begin k := NearestUnitToUnit ( tmp , j ) ;
70240: LD_ADDR_VAR 0 4
70244: PUSH
70245: LD_VAR 0 5
70249: PPUSH
70250: LD_VAR 0 3
70254: PPUSH
70255: CALL_OW 74
70259: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70260: LD_VAR 0 3
70264: PPUSH
70265: LD_VAR 0 4
70269: PPUSH
70270: CALL_OW 296
70274: PUSH
70275: LD_INT 5
70277: GREATER
70278: IFFALSE 70294
// ComMoveToNearbyEntrance ( j , k ) ;
70280: LD_VAR 0 3
70284: PPUSH
70285: LD_VAR 0 4
70289: PPUSH
70290: CALL 58053 0 2
// end ; end ;
70294: GO 70149
70296: POP
70297: POP
// if not need_heal_1 and not need_heal_2 then
70298: LD_VAR 0 6
70302: NOT
70303: PUSH
70304: LD_VAR 0 7
70308: NOT
70309: AND
70310: IFFALSE 70314
// continue ;
70312: GO 69778
// end ;
70314: GO 69778
70316: POP
70317: POP
// RaiseSailEvent ( 102 ) ;
70318: LD_INT 102
70320: PPUSH
70321: CALL_OW 427
// end ;
70325: LD_VAR 0 1
70329: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70330: LD_INT 0
70332: PPUSH
70333: PPUSH
70334: PPUSH
70335: PPUSH
70336: PPUSH
70337: PPUSH
70338: PPUSH
70339: PPUSH
// if not mc_bases then
70340: LD_EXP 31
70344: NOT
70345: IFFALSE 70349
// exit ;
70347: GO 71260
// for i = 1 to mc_bases do
70349: LD_ADDR_VAR 0 2
70353: PUSH
70354: DOUBLE
70355: LD_INT 1
70357: DEC
70358: ST_TO_ADDR
70359: LD_EXP 31
70363: PUSH
70364: FOR_TO
70365: IFFALSE 71258
// begin if not mc_building_need_repair [ i ] then
70367: LD_EXP 32
70371: PUSH
70372: LD_VAR 0 2
70376: ARRAY
70377: NOT
70378: IFFALSE 70563
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70380: LD_ADDR_VAR 0 6
70384: PUSH
70385: LD_EXP 50
70389: PUSH
70390: LD_VAR 0 2
70394: ARRAY
70395: PPUSH
70396: LD_INT 3
70398: PUSH
70399: LD_INT 24
70401: PUSH
70402: LD_INT 1000
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 2
70415: PUSH
70416: LD_INT 34
70418: PUSH
70419: LD_INT 13
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 34
70428: PUSH
70429: LD_INT 52
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 34
70438: PUSH
70439: LD_INT 88
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: LIST
70450: LIST
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PPUSH
70456: CALL_OW 72
70460: ST_TO_ADDR
// if cranes then
70461: LD_VAR 0 6
70465: IFFALSE 70527
// for j in cranes do
70467: LD_ADDR_VAR 0 3
70471: PUSH
70472: LD_VAR 0 6
70476: PUSH
70477: FOR_IN
70478: IFFALSE 70525
// if not IsInArea ( j , mc_parking [ i ] ) then
70480: LD_VAR 0 3
70484: PPUSH
70485: LD_EXP 55
70489: PUSH
70490: LD_VAR 0 2
70494: ARRAY
70495: PPUSH
70496: CALL_OW 308
70500: NOT
70501: IFFALSE 70523
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70503: LD_VAR 0 3
70507: PPUSH
70508: LD_EXP 55
70512: PUSH
70513: LD_VAR 0 2
70517: ARRAY
70518: PPUSH
70519: CALL_OW 113
70523: GO 70477
70525: POP
70526: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70527: LD_ADDR_EXP 33
70531: PUSH
70532: LD_EXP 33
70536: PPUSH
70537: LD_VAR 0 2
70541: PPUSH
70542: EMPTY
70543: PPUSH
70544: CALL_OW 1
70548: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70549: LD_VAR 0 2
70553: PPUSH
70554: LD_INT 101
70556: PPUSH
70557: CALL 65417 0 2
// continue ;
70561: GO 70364
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70563: LD_ADDR_EXP 37
70567: PUSH
70568: LD_EXP 37
70572: PPUSH
70573: LD_VAR 0 2
70577: PPUSH
70578: EMPTY
70579: PPUSH
70580: CALL_OW 1
70584: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70585: LD_VAR 0 2
70589: PPUSH
70590: LD_INT 103
70592: PPUSH
70593: CALL 65417 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70597: LD_ADDR_VAR 0 5
70601: PUSH
70602: LD_EXP 31
70606: PUSH
70607: LD_VAR 0 2
70611: ARRAY
70612: PUSH
70613: LD_EXP 60
70617: PUSH
70618: LD_VAR 0 2
70622: ARRAY
70623: UNION
70624: PPUSH
70625: LD_INT 2
70627: PUSH
70628: LD_INT 25
70630: PUSH
70631: LD_INT 2
70633: PUSH
70634: EMPTY
70635: LIST
70636: LIST
70637: PUSH
70638: LD_INT 25
70640: PUSH
70641: LD_INT 16
70643: PUSH
70644: EMPTY
70645: LIST
70646: LIST
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: LIST
70652: PUSH
70653: EMPTY
70654: LIST
70655: PPUSH
70656: CALL_OW 72
70660: ST_TO_ADDR
// if mc_need_heal [ i ] then
70661: LD_EXP 34
70665: PUSH
70666: LD_VAR 0 2
70670: ARRAY
70671: IFFALSE 70715
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70673: LD_ADDR_VAR 0 5
70677: PUSH
70678: LD_VAR 0 5
70682: PUSH
70683: LD_EXP 34
70687: PUSH
70688: LD_VAR 0 2
70692: ARRAY
70693: PUSH
70694: LD_INT 1
70696: ARRAY
70697: PUSH
70698: LD_EXP 34
70702: PUSH
70703: LD_VAR 0 2
70707: ARRAY
70708: PUSH
70709: LD_INT 2
70711: ARRAY
70712: UNION
70713: DIFF
70714: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70715: LD_ADDR_VAR 0 6
70719: PUSH
70720: LD_EXP 50
70724: PUSH
70725: LD_VAR 0 2
70729: ARRAY
70730: PPUSH
70731: LD_INT 2
70733: PUSH
70734: LD_INT 34
70736: PUSH
70737: LD_INT 13
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 34
70746: PUSH
70747: LD_INT 52
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 34
70756: PUSH
70757: LD_INT 88
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: PPUSH
70770: CALL_OW 72
70774: ST_TO_ADDR
// if cranes then
70775: LD_VAR 0 6
70779: IFFALSE 70947
// begin for j in cranes do
70781: LD_ADDR_VAR 0 3
70785: PUSH
70786: LD_VAR 0 6
70790: PUSH
70791: FOR_IN
70792: IFFALSE 70945
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70794: LD_VAR 0 3
70798: PPUSH
70799: CALL_OW 256
70803: PUSH
70804: LD_INT 1000
70806: EQUAL
70807: PUSH
70808: LD_VAR 0 3
70812: PPUSH
70813: CALL_OW 314
70817: NOT
70818: AND
70819: IFFALSE 70885
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
70821: LD_ADDR_VAR 0 8
70825: PUSH
70826: LD_EXP 32
70830: PUSH
70831: LD_VAR 0 2
70835: ARRAY
70836: PPUSH
70837: LD_VAR 0 3
70841: PPUSH
70842: CALL_OW 74
70846: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
70847: LD_VAR 0 8
70851: PPUSH
70852: LD_INT 16
70854: PPUSH
70855: CALL 27443 0 2
70859: PUSH
70860: LD_INT 4
70862: ARRAY
70863: PUSH
70864: LD_INT 10
70866: LESS
70867: IFFALSE 70883
// ComRepairBuilding ( j , to_repair ) ;
70869: LD_VAR 0 3
70873: PPUSH
70874: LD_VAR 0 8
70878: PPUSH
70879: CALL_OW 130
// end else
70883: GO 70943
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
70885: LD_VAR 0 3
70889: PPUSH
70890: CALL_OW 256
70894: PUSH
70895: LD_INT 500
70897: LESS
70898: PUSH
70899: LD_VAR 0 3
70903: PPUSH
70904: LD_EXP 55
70908: PUSH
70909: LD_VAR 0 2
70913: ARRAY
70914: PPUSH
70915: CALL_OW 308
70919: NOT
70920: AND
70921: IFFALSE 70943
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70923: LD_VAR 0 3
70927: PPUSH
70928: LD_EXP 55
70932: PUSH
70933: LD_VAR 0 2
70937: ARRAY
70938: PPUSH
70939: CALL_OW 113
// end ;
70943: GO 70791
70945: POP
70946: POP
// end ; if tmp > 3 then
70947: LD_VAR 0 5
70951: PUSH
70952: LD_INT 3
70954: GREATER
70955: IFFALSE 70975
// tmp := ShrinkArray ( tmp , 4 ) ;
70957: LD_ADDR_VAR 0 5
70961: PUSH
70962: LD_VAR 0 5
70966: PPUSH
70967: LD_INT 4
70969: PPUSH
70970: CALL 57491 0 2
70974: ST_TO_ADDR
// if not tmp then
70975: LD_VAR 0 5
70979: NOT
70980: IFFALSE 70984
// continue ;
70982: GO 70364
// for j in tmp do
70984: LD_ADDR_VAR 0 3
70988: PUSH
70989: LD_VAR 0 5
70993: PUSH
70994: FOR_IN
70995: IFFALSE 71254
// begin if IsInUnit ( j ) then
70997: LD_VAR 0 3
71001: PPUSH
71002: CALL_OW 310
71006: IFFALSE 71017
// ComExitBuilding ( j ) ;
71008: LD_VAR 0 3
71012: PPUSH
71013: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
71017: LD_VAR 0 3
71021: PUSH
71022: LD_EXP 33
71026: PUSH
71027: LD_VAR 0 2
71031: ARRAY
71032: IN
71033: NOT
71034: IFFALSE 71092
// begin SetTag ( j , 101 ) ;
71036: LD_VAR 0 3
71040: PPUSH
71041: LD_INT 101
71043: PPUSH
71044: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
71048: LD_ADDR_EXP 33
71052: PUSH
71053: LD_EXP 33
71057: PPUSH
71058: LD_VAR 0 2
71062: PUSH
71063: LD_EXP 33
71067: PUSH
71068: LD_VAR 0 2
71072: ARRAY
71073: PUSH
71074: LD_INT 1
71076: PLUS
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PPUSH
71082: LD_VAR 0 3
71086: PPUSH
71087: CALL 24846 0 3
71091: ST_TO_ADDR
// end ; wait ( 1 ) ;
71092: LD_INT 1
71094: PPUSH
71095: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
71099: LD_ADDR_VAR 0 7
71103: PUSH
71104: LD_EXP 32
71108: PUSH
71109: LD_VAR 0 2
71113: ARRAY
71114: ST_TO_ADDR
// if mc_scan [ i ] then
71115: LD_EXP 54
71119: PUSH
71120: LD_VAR 0 2
71124: ARRAY
71125: IFFALSE 71187
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
71127: LD_ADDR_VAR 0 7
71131: PUSH
71132: LD_EXP 32
71136: PUSH
71137: LD_VAR 0 2
71141: ARRAY
71142: PPUSH
71143: LD_INT 3
71145: PUSH
71146: LD_INT 30
71148: PUSH
71149: LD_INT 32
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 30
71158: PUSH
71159: LD_INT 33
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 30
71168: PUSH
71169: LD_INT 31
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: LIST
71180: LIST
71181: PPUSH
71182: CALL_OW 72
71186: ST_TO_ADDR
// if not to_repair_tmp then
71187: LD_VAR 0 7
71191: NOT
71192: IFFALSE 71196
// continue ;
71194: GO 70994
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
71196: LD_ADDR_VAR 0 8
71200: PUSH
71201: LD_VAR 0 7
71205: PPUSH
71206: LD_VAR 0 3
71210: PPUSH
71211: CALL_OW 74
71215: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
71216: LD_VAR 0 8
71220: PPUSH
71221: LD_INT 16
71223: PPUSH
71224: CALL 27443 0 2
71228: PUSH
71229: LD_INT 4
71231: ARRAY
71232: PUSH
71233: LD_INT 14
71235: LESS
71236: IFFALSE 71252
// ComRepairBuilding ( j , to_repair ) ;
71238: LD_VAR 0 3
71242: PPUSH
71243: LD_VAR 0 8
71247: PPUSH
71248: CALL_OW 130
// end ;
71252: GO 70994
71254: POP
71255: POP
// end ;
71256: GO 70364
71258: POP
71259: POP
// end ;
71260: LD_VAR 0 1
71264: RET
// export function MC_Heal ; var i , j , tmp ; begin
71265: LD_INT 0
71267: PPUSH
71268: PPUSH
71269: PPUSH
71270: PPUSH
// if not mc_bases then
71271: LD_EXP 31
71275: NOT
71276: IFFALSE 71280
// exit ;
71278: GO 71682
// for i = 1 to mc_bases do
71280: LD_ADDR_VAR 0 2
71284: PUSH
71285: DOUBLE
71286: LD_INT 1
71288: DEC
71289: ST_TO_ADDR
71290: LD_EXP 31
71294: PUSH
71295: FOR_TO
71296: IFFALSE 71680
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71298: LD_EXP 34
71302: PUSH
71303: LD_VAR 0 2
71307: ARRAY
71308: PUSH
71309: LD_INT 1
71311: ARRAY
71312: NOT
71313: PUSH
71314: LD_EXP 34
71318: PUSH
71319: LD_VAR 0 2
71323: ARRAY
71324: PUSH
71325: LD_INT 2
71327: ARRAY
71328: NOT
71329: AND
71330: IFFALSE 71368
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71332: LD_ADDR_EXP 35
71336: PUSH
71337: LD_EXP 35
71341: PPUSH
71342: LD_VAR 0 2
71346: PPUSH
71347: EMPTY
71348: PPUSH
71349: CALL_OW 1
71353: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71354: LD_VAR 0 2
71358: PPUSH
71359: LD_INT 102
71361: PPUSH
71362: CALL 65417 0 2
// continue ;
71366: GO 71295
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71368: LD_ADDR_VAR 0 4
71372: PUSH
71373: LD_EXP 31
71377: PUSH
71378: LD_VAR 0 2
71382: ARRAY
71383: PPUSH
71384: LD_INT 25
71386: PUSH
71387: LD_INT 4
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PPUSH
71394: CALL_OW 72
71398: ST_TO_ADDR
// if not tmp then
71399: LD_VAR 0 4
71403: NOT
71404: IFFALSE 71408
// continue ;
71406: GO 71295
// if mc_taming [ i ] then
71408: LD_EXP 62
71412: PUSH
71413: LD_VAR 0 2
71417: ARRAY
71418: IFFALSE 71442
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71420: LD_ADDR_EXP 62
71424: PUSH
71425: LD_EXP 62
71429: PPUSH
71430: LD_VAR 0 2
71434: PPUSH
71435: EMPTY
71436: PPUSH
71437: CALL_OW 1
71441: ST_TO_ADDR
// for j in tmp do
71442: LD_ADDR_VAR 0 3
71446: PUSH
71447: LD_VAR 0 4
71451: PUSH
71452: FOR_IN
71453: IFFALSE 71676
// begin if IsInUnit ( j ) then
71455: LD_VAR 0 3
71459: PPUSH
71460: CALL_OW 310
71464: IFFALSE 71475
// ComExitBuilding ( j ) ;
71466: LD_VAR 0 3
71470: PPUSH
71471: CALL_OW 122
// if not j in mc_healers [ i ] then
71475: LD_VAR 0 3
71479: PUSH
71480: LD_EXP 35
71484: PUSH
71485: LD_VAR 0 2
71489: ARRAY
71490: IN
71491: NOT
71492: IFFALSE 71538
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71494: LD_ADDR_EXP 35
71498: PUSH
71499: LD_EXP 35
71503: PPUSH
71504: LD_VAR 0 2
71508: PUSH
71509: LD_EXP 35
71513: PUSH
71514: LD_VAR 0 2
71518: ARRAY
71519: PUSH
71520: LD_INT 1
71522: PLUS
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PPUSH
71528: LD_VAR 0 3
71532: PPUSH
71533: CALL 24846 0 3
71537: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71538: LD_VAR 0 3
71542: PPUSH
71543: CALL_OW 110
71547: PUSH
71548: LD_INT 102
71550: NONEQUAL
71551: IFFALSE 71565
// SetTag ( j , 102 ) ;
71553: LD_VAR 0 3
71557: PPUSH
71558: LD_INT 102
71560: PPUSH
71561: CALL_OW 109
// Wait ( 3 ) ;
71565: LD_INT 3
71567: PPUSH
71568: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71572: LD_EXP 34
71576: PUSH
71577: LD_VAR 0 2
71581: ARRAY
71582: PUSH
71583: LD_INT 1
71585: ARRAY
71586: IFFALSE 71618
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71588: LD_VAR 0 3
71592: PPUSH
71593: LD_EXP 34
71597: PUSH
71598: LD_VAR 0 2
71602: ARRAY
71603: PUSH
71604: LD_INT 1
71606: ARRAY
71607: PUSH
71608: LD_INT 1
71610: ARRAY
71611: PPUSH
71612: CALL_OW 128
71616: GO 71674
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71618: LD_VAR 0 3
71622: PPUSH
71623: CALL_OW 314
71627: NOT
71628: PUSH
71629: LD_EXP 34
71633: PUSH
71634: LD_VAR 0 2
71638: ARRAY
71639: PUSH
71640: LD_INT 2
71642: ARRAY
71643: AND
71644: IFFALSE 71674
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71646: LD_VAR 0 3
71650: PPUSH
71651: LD_EXP 34
71655: PUSH
71656: LD_VAR 0 2
71660: ARRAY
71661: PUSH
71662: LD_INT 2
71664: ARRAY
71665: PUSH
71666: LD_INT 1
71668: ARRAY
71669: PPUSH
71670: CALL_OW 128
// end ;
71674: GO 71452
71676: POP
71677: POP
// end ;
71678: GO 71295
71680: POP
71681: POP
// end ;
71682: LD_VAR 0 1
71686: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
71687: LD_INT 0
71689: PPUSH
71690: PPUSH
71691: PPUSH
71692: PPUSH
71693: PPUSH
71694: PPUSH
// if not mc_bases then
71695: LD_EXP 31
71699: NOT
71700: IFFALSE 71704
// exit ;
71702: GO 72867
// for i = 1 to mc_bases do
71704: LD_ADDR_VAR 0 2
71708: PUSH
71709: DOUBLE
71710: LD_INT 1
71712: DEC
71713: ST_TO_ADDR
71714: LD_EXP 31
71718: PUSH
71719: FOR_TO
71720: IFFALSE 72865
// begin if mc_scan [ i ] then
71722: LD_EXP 54
71726: PUSH
71727: LD_VAR 0 2
71731: ARRAY
71732: IFFALSE 71736
// continue ;
71734: GO 71719
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71736: LD_EXP 36
71740: PUSH
71741: LD_VAR 0 2
71745: ARRAY
71746: NOT
71747: PUSH
71748: LD_EXP 38
71752: PUSH
71753: LD_VAR 0 2
71757: ARRAY
71758: NOT
71759: AND
71760: PUSH
71761: LD_EXP 37
71765: PUSH
71766: LD_VAR 0 2
71770: ARRAY
71771: AND
71772: IFFALSE 71810
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71774: LD_ADDR_EXP 37
71778: PUSH
71779: LD_EXP 37
71783: PPUSH
71784: LD_VAR 0 2
71788: PPUSH
71789: EMPTY
71790: PPUSH
71791: CALL_OW 1
71795: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71796: LD_VAR 0 2
71800: PPUSH
71801: LD_INT 103
71803: PPUSH
71804: CALL 65417 0 2
// continue ;
71808: GO 71719
// end ; if mc_construct_list [ i ] then
71810: LD_EXP 38
71814: PUSH
71815: LD_VAR 0 2
71819: ARRAY
71820: IFFALSE 72040
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71822: LD_ADDR_VAR 0 5
71826: PUSH
71827: LD_EXP 31
71831: PUSH
71832: LD_VAR 0 2
71836: ARRAY
71837: PPUSH
71838: LD_INT 25
71840: PUSH
71841: LD_INT 2
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PPUSH
71848: CALL_OW 72
71852: PUSH
71853: LD_EXP 33
71857: PUSH
71858: LD_VAR 0 2
71862: ARRAY
71863: DIFF
71864: ST_TO_ADDR
// if not tmp then
71865: LD_VAR 0 5
71869: NOT
71870: IFFALSE 71874
// continue ;
71872: GO 71719
// for j in tmp do
71874: LD_ADDR_VAR 0 3
71878: PUSH
71879: LD_VAR 0 5
71883: PUSH
71884: FOR_IN
71885: IFFALSE 72036
// begin if not mc_builders [ i ] then
71887: LD_EXP 37
71891: PUSH
71892: LD_VAR 0 2
71896: ARRAY
71897: NOT
71898: IFFALSE 71956
// begin SetTag ( j , 103 ) ;
71900: LD_VAR 0 3
71904: PPUSH
71905: LD_INT 103
71907: PPUSH
71908: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71912: LD_ADDR_EXP 37
71916: PUSH
71917: LD_EXP 37
71921: PPUSH
71922: LD_VAR 0 2
71926: PUSH
71927: LD_EXP 37
71931: PUSH
71932: LD_VAR 0 2
71936: ARRAY
71937: PUSH
71938: LD_INT 1
71940: PLUS
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PPUSH
71946: LD_VAR 0 3
71950: PPUSH
71951: CALL 24846 0 3
71955: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71956: LD_VAR 0 3
71960: PPUSH
71961: CALL_OW 310
71965: IFFALSE 71976
// ComExitBuilding ( j ) ;
71967: LD_VAR 0 3
71971: PPUSH
71972: CALL_OW 122
// wait ( 3 ) ;
71976: LD_INT 3
71978: PPUSH
71979: CALL_OW 67
// if not mc_construct_list [ i ] then
71983: LD_EXP 38
71987: PUSH
71988: LD_VAR 0 2
71992: ARRAY
71993: NOT
71994: IFFALSE 71998
// break ;
71996: GO 72036
// if not HasTask ( j ) then
71998: LD_VAR 0 3
72002: PPUSH
72003: CALL_OW 314
72007: NOT
72008: IFFALSE 72034
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
72010: LD_VAR 0 3
72014: PPUSH
72015: LD_EXP 38
72019: PUSH
72020: LD_VAR 0 2
72024: ARRAY
72025: PUSH
72026: LD_INT 1
72028: ARRAY
72029: PPUSH
72030: CALL 27707 0 2
// end ;
72034: GO 71884
72036: POP
72037: POP
// end else
72038: GO 72863
// if mc_build_list [ i ] then
72040: LD_EXP 36
72044: PUSH
72045: LD_VAR 0 2
72049: ARRAY
72050: IFFALSE 72863
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
72052: LD_EXP 36
72056: PUSH
72057: LD_VAR 0 2
72061: ARRAY
72062: PUSH
72063: LD_INT 1
72065: ARRAY
72066: PUSH
72067: LD_INT 1
72069: ARRAY
72070: PPUSH
72071: CALL 27531 0 1
72075: PUSH
72076: LD_EXP 31
72080: PUSH
72081: LD_VAR 0 2
72085: ARRAY
72086: PPUSH
72087: LD_INT 2
72089: PUSH
72090: LD_INT 30
72092: PUSH
72093: LD_INT 2
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 30
72102: PUSH
72103: LD_INT 3
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: LIST
72114: PPUSH
72115: CALL_OW 72
72119: NOT
72120: AND
72121: IFFALSE 72226
// begin for j = 1 to mc_build_list [ i ] do
72123: LD_ADDR_VAR 0 3
72127: PUSH
72128: DOUBLE
72129: LD_INT 1
72131: DEC
72132: ST_TO_ADDR
72133: LD_EXP 36
72137: PUSH
72138: LD_VAR 0 2
72142: ARRAY
72143: PUSH
72144: FOR_TO
72145: IFFALSE 72224
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
72147: LD_EXP 36
72151: PUSH
72152: LD_VAR 0 2
72156: ARRAY
72157: PUSH
72158: LD_VAR 0 3
72162: ARRAY
72163: PUSH
72164: LD_INT 1
72166: ARRAY
72167: PUSH
72168: LD_INT 2
72170: EQUAL
72171: IFFALSE 72222
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72173: LD_ADDR_EXP 36
72177: PUSH
72178: LD_EXP 36
72182: PPUSH
72183: LD_VAR 0 2
72187: PPUSH
72188: LD_EXP 36
72192: PUSH
72193: LD_VAR 0 2
72197: ARRAY
72198: PPUSH
72199: LD_VAR 0 3
72203: PPUSH
72204: LD_INT 1
72206: PPUSH
72207: LD_INT 0
72209: PPUSH
72210: CALL 24264 0 4
72214: PPUSH
72215: CALL_OW 1
72219: ST_TO_ADDR
// break ;
72220: GO 72224
// end ;
72222: GO 72144
72224: POP
72225: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72226: LD_ADDR_VAR 0 6
72230: PUSH
72231: LD_EXP 31
72235: PUSH
72236: LD_VAR 0 2
72240: ARRAY
72241: PPUSH
72242: LD_INT 2
72244: PUSH
72245: LD_INT 30
72247: PUSH
72248: LD_INT 0
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 30
72257: PUSH
72258: LD_INT 1
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: LIST
72269: PPUSH
72270: CALL_OW 72
72274: ST_TO_ADDR
// for k := 1 to depot do
72275: LD_ADDR_VAR 0 4
72279: PUSH
72280: DOUBLE
72281: LD_INT 1
72283: DEC
72284: ST_TO_ADDR
72285: LD_VAR 0 6
72289: PUSH
72290: FOR_TO
72291: IFFALSE 72861
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
72293: LD_EXP 36
72297: PUSH
72298: LD_VAR 0 2
72302: ARRAY
72303: PUSH
72304: LD_INT 1
72306: ARRAY
72307: PUSH
72308: LD_INT 1
72310: ARRAY
72311: PUSH
72312: LD_INT 0
72314: EQUAL
72315: PUSH
72316: LD_VAR 0 6
72320: PUSH
72321: LD_VAR 0 4
72325: ARRAY
72326: PPUSH
72327: LD_EXP 36
72331: PUSH
72332: LD_VAR 0 2
72336: ARRAY
72337: PUSH
72338: LD_INT 1
72340: ARRAY
72341: PUSH
72342: LD_INT 1
72344: ARRAY
72345: PPUSH
72346: LD_EXP 36
72350: PUSH
72351: LD_VAR 0 2
72355: ARRAY
72356: PUSH
72357: LD_INT 1
72359: ARRAY
72360: PUSH
72361: LD_INT 2
72363: ARRAY
72364: PPUSH
72365: LD_EXP 36
72369: PUSH
72370: LD_VAR 0 2
72374: ARRAY
72375: PUSH
72376: LD_INT 1
72378: ARRAY
72379: PUSH
72380: LD_INT 3
72382: ARRAY
72383: PPUSH
72384: LD_EXP 36
72388: PUSH
72389: LD_VAR 0 2
72393: ARRAY
72394: PUSH
72395: LD_INT 1
72397: ARRAY
72398: PUSH
72399: LD_INT 4
72401: ARRAY
72402: PPUSH
72403: CALL 32943 0 5
72407: OR
72408: IFFALSE 72689
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72410: LD_ADDR_VAR 0 5
72414: PUSH
72415: LD_EXP 31
72419: PUSH
72420: LD_VAR 0 2
72424: ARRAY
72425: PPUSH
72426: LD_INT 25
72428: PUSH
72429: LD_INT 2
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PPUSH
72436: CALL_OW 72
72440: PUSH
72441: LD_EXP 33
72445: PUSH
72446: LD_VAR 0 2
72450: ARRAY
72451: DIFF
72452: ST_TO_ADDR
// if not tmp then
72453: LD_VAR 0 5
72457: NOT
72458: IFFALSE 72462
// continue ;
72460: GO 72290
// for j in tmp do
72462: LD_ADDR_VAR 0 3
72466: PUSH
72467: LD_VAR 0 5
72471: PUSH
72472: FOR_IN
72473: IFFALSE 72685
// begin if not mc_builders [ i ] then
72475: LD_EXP 37
72479: PUSH
72480: LD_VAR 0 2
72484: ARRAY
72485: NOT
72486: IFFALSE 72544
// begin SetTag ( j , 103 ) ;
72488: LD_VAR 0 3
72492: PPUSH
72493: LD_INT 103
72495: PPUSH
72496: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72500: LD_ADDR_EXP 37
72504: PUSH
72505: LD_EXP 37
72509: PPUSH
72510: LD_VAR 0 2
72514: PUSH
72515: LD_EXP 37
72519: PUSH
72520: LD_VAR 0 2
72524: ARRAY
72525: PUSH
72526: LD_INT 1
72528: PLUS
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PPUSH
72534: LD_VAR 0 3
72538: PPUSH
72539: CALL 24846 0 3
72543: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72544: LD_VAR 0 3
72548: PPUSH
72549: CALL_OW 310
72553: IFFALSE 72564
// ComExitBuilding ( j ) ;
72555: LD_VAR 0 3
72559: PPUSH
72560: CALL_OW 122
// wait ( 3 ) ;
72564: LD_INT 3
72566: PPUSH
72567: CALL_OW 67
// if not mc_build_list [ i ] then
72571: LD_EXP 36
72575: PUSH
72576: LD_VAR 0 2
72580: ARRAY
72581: NOT
72582: IFFALSE 72586
// break ;
72584: GO 72685
// if not HasTask ( j ) then
72586: LD_VAR 0 3
72590: PPUSH
72591: CALL_OW 314
72595: NOT
72596: IFFALSE 72683
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72598: LD_VAR 0 3
72602: PPUSH
72603: LD_EXP 36
72607: PUSH
72608: LD_VAR 0 2
72612: ARRAY
72613: PUSH
72614: LD_INT 1
72616: ARRAY
72617: PUSH
72618: LD_INT 1
72620: ARRAY
72621: PPUSH
72622: LD_EXP 36
72626: PUSH
72627: LD_VAR 0 2
72631: ARRAY
72632: PUSH
72633: LD_INT 1
72635: ARRAY
72636: PUSH
72637: LD_INT 2
72639: ARRAY
72640: PPUSH
72641: LD_EXP 36
72645: PUSH
72646: LD_VAR 0 2
72650: ARRAY
72651: PUSH
72652: LD_INT 1
72654: ARRAY
72655: PUSH
72656: LD_INT 3
72658: ARRAY
72659: PPUSH
72660: LD_EXP 36
72664: PUSH
72665: LD_VAR 0 2
72669: ARRAY
72670: PUSH
72671: LD_INT 1
72673: ARRAY
72674: PUSH
72675: LD_INT 4
72677: ARRAY
72678: PPUSH
72679: CALL_OW 145
// end ;
72683: GO 72472
72685: POP
72686: POP
// end else
72687: GO 72859
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72689: LD_EXP 31
72693: PUSH
72694: LD_VAR 0 2
72698: ARRAY
72699: PPUSH
72700: LD_EXP 36
72704: PUSH
72705: LD_VAR 0 2
72709: ARRAY
72710: PUSH
72711: LD_INT 1
72713: ARRAY
72714: PUSH
72715: LD_INT 1
72717: ARRAY
72718: PPUSH
72719: LD_EXP 36
72723: PUSH
72724: LD_VAR 0 2
72728: ARRAY
72729: PUSH
72730: LD_INT 1
72732: ARRAY
72733: PUSH
72734: LD_INT 2
72736: ARRAY
72737: PPUSH
72738: LD_EXP 36
72742: PUSH
72743: LD_VAR 0 2
72747: ARRAY
72748: PUSH
72749: LD_INT 1
72751: ARRAY
72752: PUSH
72753: LD_INT 3
72755: ARRAY
72756: PPUSH
72757: LD_EXP 36
72761: PUSH
72762: LD_VAR 0 2
72766: ARRAY
72767: PUSH
72768: LD_INT 1
72770: ARRAY
72771: PUSH
72772: LD_INT 4
72774: ARRAY
72775: PPUSH
72776: LD_EXP 31
72780: PUSH
72781: LD_VAR 0 2
72785: ARRAY
72786: PPUSH
72787: LD_INT 21
72789: PUSH
72790: LD_INT 3
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PPUSH
72797: CALL_OW 72
72801: PPUSH
72802: EMPTY
72803: PPUSH
72804: CALL 31697 0 7
72808: NOT
72809: IFFALSE 72859
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
72811: LD_ADDR_EXP 36
72815: PUSH
72816: LD_EXP 36
72820: PPUSH
72821: LD_VAR 0 2
72825: PPUSH
72826: LD_EXP 36
72830: PUSH
72831: LD_VAR 0 2
72835: ARRAY
72836: PPUSH
72837: LD_INT 1
72839: PPUSH
72840: LD_INT 1
72842: NEG
72843: PPUSH
72844: LD_INT 0
72846: PPUSH
72847: CALL 24264 0 4
72851: PPUSH
72852: CALL_OW 1
72856: ST_TO_ADDR
// continue ;
72857: GO 72290
// end ; end ;
72859: GO 72290
72861: POP
72862: POP
// end ; end ;
72863: GO 71719
72865: POP
72866: POP
// end ;
72867: LD_VAR 0 1
72871: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
72872: LD_INT 0
72874: PPUSH
72875: PPUSH
72876: PPUSH
72877: PPUSH
72878: PPUSH
72879: PPUSH
// if not mc_bases then
72880: LD_EXP 31
72884: NOT
72885: IFFALSE 72889
// exit ;
72887: GO 73316
// for i = 1 to mc_bases do
72889: LD_ADDR_VAR 0 2
72893: PUSH
72894: DOUBLE
72895: LD_INT 1
72897: DEC
72898: ST_TO_ADDR
72899: LD_EXP 31
72903: PUSH
72904: FOR_TO
72905: IFFALSE 73314
// begin tmp := mc_build_upgrade [ i ] ;
72907: LD_ADDR_VAR 0 4
72911: PUSH
72912: LD_EXP 63
72916: PUSH
72917: LD_VAR 0 2
72921: ARRAY
72922: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
72923: LD_ADDR_VAR 0 6
72927: PUSH
72928: LD_EXP 64
72932: PUSH
72933: LD_VAR 0 2
72937: ARRAY
72938: PPUSH
72939: LD_INT 2
72941: PUSH
72942: LD_INT 30
72944: PUSH
72945: LD_INT 6
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PUSH
72952: LD_INT 30
72954: PUSH
72955: LD_INT 7
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: LIST
72966: PPUSH
72967: CALL_OW 72
72971: ST_TO_ADDR
// if not tmp and not lab then
72972: LD_VAR 0 4
72976: NOT
72977: PUSH
72978: LD_VAR 0 6
72982: NOT
72983: AND
72984: IFFALSE 72988
// continue ;
72986: GO 72904
// if tmp then
72988: LD_VAR 0 4
72992: IFFALSE 73112
// for j in tmp do
72994: LD_ADDR_VAR 0 3
72998: PUSH
72999: LD_VAR 0 4
73003: PUSH
73004: FOR_IN
73005: IFFALSE 73110
// begin if UpgradeCost ( j ) then
73007: LD_VAR 0 3
73011: PPUSH
73012: CALL 31357 0 1
73016: IFFALSE 73108
// begin ComUpgrade ( j ) ;
73018: LD_VAR 0 3
73022: PPUSH
73023: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
73027: LD_ADDR_EXP 63
73031: PUSH
73032: LD_EXP 63
73036: PPUSH
73037: LD_VAR 0 2
73041: PPUSH
73042: LD_EXP 63
73046: PUSH
73047: LD_VAR 0 2
73051: ARRAY
73052: PUSH
73053: LD_VAR 0 3
73057: DIFF
73058: PPUSH
73059: CALL_OW 1
73063: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73064: LD_ADDR_EXP 38
73068: PUSH
73069: LD_EXP 38
73073: PPUSH
73074: LD_VAR 0 2
73078: PUSH
73079: LD_EXP 38
73083: PUSH
73084: LD_VAR 0 2
73088: ARRAY
73089: PUSH
73090: LD_INT 1
73092: PLUS
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PPUSH
73098: LD_VAR 0 3
73102: PPUSH
73103: CALL 24846 0 3
73107: ST_TO_ADDR
// end ; end ;
73108: GO 73004
73110: POP
73111: POP
// if not lab or not mc_lab_upgrade [ i ] then
73112: LD_VAR 0 6
73116: NOT
73117: PUSH
73118: LD_EXP 65
73122: PUSH
73123: LD_VAR 0 2
73127: ARRAY
73128: NOT
73129: OR
73130: IFFALSE 73134
// continue ;
73132: GO 72904
// for j in lab do
73134: LD_ADDR_VAR 0 3
73138: PUSH
73139: LD_VAR 0 6
73143: PUSH
73144: FOR_IN
73145: IFFALSE 73310
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
73147: LD_VAR 0 3
73151: PPUSH
73152: CALL_OW 266
73156: PUSH
73157: LD_INT 6
73159: PUSH
73160: LD_INT 7
73162: PUSH
73163: EMPTY
73164: LIST
73165: LIST
73166: IN
73167: PUSH
73168: LD_VAR 0 3
73172: PPUSH
73173: CALL_OW 461
73177: PUSH
73178: LD_INT 1
73180: NONEQUAL
73181: AND
73182: IFFALSE 73308
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
73184: LD_VAR 0 3
73188: PPUSH
73189: LD_EXP 65
73193: PUSH
73194: LD_VAR 0 2
73198: ARRAY
73199: PUSH
73200: LD_INT 1
73202: ARRAY
73203: PPUSH
73204: CALL 31562 0 2
73208: IFFALSE 73308
// begin ComCancel ( j ) ;
73210: LD_VAR 0 3
73214: PPUSH
73215: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73219: LD_VAR 0 3
73223: PPUSH
73224: LD_EXP 65
73228: PUSH
73229: LD_VAR 0 2
73233: ARRAY
73234: PUSH
73235: LD_INT 1
73237: ARRAY
73238: PPUSH
73239: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73243: LD_VAR 0 3
73247: PUSH
73248: LD_EXP 38
73252: PUSH
73253: LD_VAR 0 2
73257: ARRAY
73258: IN
73259: NOT
73260: IFFALSE 73306
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73262: LD_ADDR_EXP 38
73266: PUSH
73267: LD_EXP 38
73271: PPUSH
73272: LD_VAR 0 2
73276: PUSH
73277: LD_EXP 38
73281: PUSH
73282: LD_VAR 0 2
73286: ARRAY
73287: PUSH
73288: LD_INT 1
73290: PLUS
73291: PUSH
73292: EMPTY
73293: LIST
73294: LIST
73295: PPUSH
73296: LD_VAR 0 3
73300: PPUSH
73301: CALL 24846 0 3
73305: ST_TO_ADDR
// break ;
73306: GO 73310
// end ; end ; end ;
73308: GO 73144
73310: POP
73311: POP
// end ;
73312: GO 72904
73314: POP
73315: POP
// end ;
73316: LD_VAR 0 1
73320: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73321: LD_INT 0
73323: PPUSH
73324: PPUSH
73325: PPUSH
73326: PPUSH
73327: PPUSH
73328: PPUSH
73329: PPUSH
73330: PPUSH
73331: PPUSH
// if not mc_bases then
73332: LD_EXP 31
73336: NOT
73337: IFFALSE 73341
// exit ;
73339: GO 73746
// for i = 1 to mc_bases do
73341: LD_ADDR_VAR 0 2
73345: PUSH
73346: DOUBLE
73347: LD_INT 1
73349: DEC
73350: ST_TO_ADDR
73351: LD_EXP 31
73355: PUSH
73356: FOR_TO
73357: IFFALSE 73744
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73359: LD_EXP 39
73363: PUSH
73364: LD_VAR 0 2
73368: ARRAY
73369: NOT
73370: PUSH
73371: LD_EXP 31
73375: PUSH
73376: LD_VAR 0 2
73380: ARRAY
73381: PPUSH
73382: LD_INT 30
73384: PUSH
73385: LD_INT 3
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: PPUSH
73392: CALL_OW 72
73396: NOT
73397: OR
73398: IFFALSE 73402
// continue ;
73400: GO 73356
// busy := false ;
73402: LD_ADDR_VAR 0 8
73406: PUSH
73407: LD_INT 0
73409: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73410: LD_ADDR_VAR 0 4
73414: PUSH
73415: LD_EXP 31
73419: PUSH
73420: LD_VAR 0 2
73424: ARRAY
73425: PPUSH
73426: LD_INT 30
73428: PUSH
73429: LD_INT 3
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: PPUSH
73436: CALL_OW 72
73440: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73441: LD_ADDR_VAR 0 6
73445: PUSH
73446: LD_EXP 39
73450: PUSH
73451: LD_VAR 0 2
73455: ARRAY
73456: PPUSH
73457: LD_INT 2
73459: PUSH
73460: LD_INT 30
73462: PUSH
73463: LD_INT 32
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 30
73472: PUSH
73473: LD_INT 33
73475: PUSH
73476: EMPTY
73477: LIST
73478: LIST
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: LIST
73484: PPUSH
73485: CALL_OW 72
73489: ST_TO_ADDR
// if not t then
73490: LD_VAR 0 6
73494: NOT
73495: IFFALSE 73499
// continue ;
73497: GO 73356
// for j in tmp do
73499: LD_ADDR_VAR 0 3
73503: PUSH
73504: LD_VAR 0 4
73508: PUSH
73509: FOR_IN
73510: IFFALSE 73540
// if not BuildingStatus ( j ) = bs_idle then
73512: LD_VAR 0 3
73516: PPUSH
73517: CALL_OW 461
73521: PUSH
73522: LD_INT 2
73524: EQUAL
73525: NOT
73526: IFFALSE 73538
// begin busy := true ;
73528: LD_ADDR_VAR 0 8
73532: PUSH
73533: LD_INT 1
73535: ST_TO_ADDR
// break ;
73536: GO 73540
// end ;
73538: GO 73509
73540: POP
73541: POP
// if busy then
73542: LD_VAR 0 8
73546: IFFALSE 73550
// continue ;
73548: GO 73356
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73550: LD_ADDR_VAR 0 7
73554: PUSH
73555: LD_VAR 0 6
73559: PPUSH
73560: LD_INT 35
73562: PUSH
73563: LD_INT 0
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PPUSH
73570: CALL_OW 72
73574: ST_TO_ADDR
// if tw then
73575: LD_VAR 0 7
73579: IFFALSE 73656
// begin tw := tw [ 1 ] ;
73581: LD_ADDR_VAR 0 7
73585: PUSH
73586: LD_VAR 0 7
73590: PUSH
73591: LD_INT 1
73593: ARRAY
73594: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73595: LD_ADDR_VAR 0 9
73599: PUSH
73600: LD_VAR 0 7
73604: PPUSH
73605: LD_EXP 56
73609: PUSH
73610: LD_VAR 0 2
73614: ARRAY
73615: PPUSH
73616: CALL 29854 0 2
73620: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73621: LD_EXP 70
73625: PUSH
73626: LD_VAR 0 2
73630: ARRAY
73631: IFFALSE 73654
// if not weapon in mc_allowed_tower_weapons [ i ] then
73633: LD_VAR 0 9
73637: PUSH
73638: LD_EXP 70
73642: PUSH
73643: LD_VAR 0 2
73647: ARRAY
73648: IN
73649: NOT
73650: IFFALSE 73654
// continue ;
73652: GO 73356
// end else
73654: GO 73719
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73656: LD_ADDR_VAR 0 5
73660: PUSH
73661: LD_EXP 39
73665: PUSH
73666: LD_VAR 0 2
73670: ARRAY
73671: PPUSH
73672: LD_VAR 0 4
73676: PPUSH
73677: CALL 56724 0 2
73681: ST_TO_ADDR
// if not tmp2 then
73682: LD_VAR 0 5
73686: NOT
73687: IFFALSE 73691
// continue ;
73689: GO 73356
// tw := tmp2 [ 1 ] ;
73691: LD_ADDR_VAR 0 7
73695: PUSH
73696: LD_VAR 0 5
73700: PUSH
73701: LD_INT 1
73703: ARRAY
73704: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73705: LD_ADDR_VAR 0 9
73709: PUSH
73710: LD_VAR 0 5
73714: PUSH
73715: LD_INT 2
73717: ARRAY
73718: ST_TO_ADDR
// end ; if not weapon then
73719: LD_VAR 0 9
73723: NOT
73724: IFFALSE 73728
// continue ;
73726: GO 73356
// ComPlaceWeapon ( tw , weapon ) ;
73728: LD_VAR 0 7
73732: PPUSH
73733: LD_VAR 0 9
73737: PPUSH
73738: CALL_OW 148
// end ;
73742: GO 73356
73744: POP
73745: POP
// end ;
73746: LD_VAR 0 1
73750: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73751: LD_INT 0
73753: PPUSH
73754: PPUSH
73755: PPUSH
73756: PPUSH
73757: PPUSH
73758: PPUSH
73759: PPUSH
// if not mc_bases then
73760: LD_EXP 31
73764: NOT
73765: IFFALSE 73769
// exit ;
73767: GO 74544
// for i = 1 to mc_bases do
73769: LD_ADDR_VAR 0 2
73773: PUSH
73774: DOUBLE
73775: LD_INT 1
73777: DEC
73778: ST_TO_ADDR
73779: LD_EXP 31
73783: PUSH
73784: FOR_TO
73785: IFFALSE 74542
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73787: LD_EXP 44
73791: PUSH
73792: LD_VAR 0 2
73796: ARRAY
73797: NOT
73798: PUSH
73799: LD_EXP 44
73803: PUSH
73804: LD_VAR 0 2
73808: ARRAY
73809: PUSH
73810: LD_EXP 45
73814: PUSH
73815: LD_VAR 0 2
73819: ARRAY
73820: EQUAL
73821: OR
73822: PUSH
73823: LD_EXP 54
73827: PUSH
73828: LD_VAR 0 2
73832: ARRAY
73833: OR
73834: IFFALSE 73838
// continue ;
73836: GO 73784
// if mc_miners [ i ] then
73838: LD_EXP 45
73842: PUSH
73843: LD_VAR 0 2
73847: ARRAY
73848: IFFALSE 74229
// begin for j = mc_miners [ i ] downto 1 do
73850: LD_ADDR_VAR 0 3
73854: PUSH
73855: DOUBLE
73856: LD_EXP 45
73860: PUSH
73861: LD_VAR 0 2
73865: ARRAY
73866: INC
73867: ST_TO_ADDR
73868: LD_INT 1
73870: PUSH
73871: FOR_DOWNTO
73872: IFFALSE 74227
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
73874: LD_EXP 45
73878: PUSH
73879: LD_VAR 0 2
73883: ARRAY
73884: PUSH
73885: LD_VAR 0 3
73889: ARRAY
73890: PPUSH
73891: CALL_OW 301
73895: PUSH
73896: LD_EXP 45
73900: PUSH
73901: LD_VAR 0 2
73905: ARRAY
73906: PUSH
73907: LD_VAR 0 3
73911: ARRAY
73912: PPUSH
73913: CALL_OW 257
73917: PUSH
73918: LD_INT 1
73920: NONEQUAL
73921: OR
73922: IFFALSE 73985
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
73924: LD_ADDR_VAR 0 5
73928: PUSH
73929: LD_EXP 45
73933: PUSH
73934: LD_VAR 0 2
73938: ARRAY
73939: PUSH
73940: LD_EXP 45
73944: PUSH
73945: LD_VAR 0 2
73949: ARRAY
73950: PUSH
73951: LD_VAR 0 3
73955: ARRAY
73956: DIFF
73957: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
73958: LD_ADDR_EXP 45
73962: PUSH
73963: LD_EXP 45
73967: PPUSH
73968: LD_VAR 0 2
73972: PPUSH
73973: LD_VAR 0 5
73977: PPUSH
73978: CALL_OW 1
73982: ST_TO_ADDR
// continue ;
73983: GO 73871
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
73985: LD_EXP 45
73989: PUSH
73990: LD_VAR 0 2
73994: ARRAY
73995: PUSH
73996: LD_VAR 0 3
74000: ARRAY
74001: PPUSH
74002: CALL_OW 257
74006: PUSH
74007: LD_INT 1
74009: EQUAL
74010: PUSH
74011: LD_EXP 45
74015: PUSH
74016: LD_VAR 0 2
74020: ARRAY
74021: PUSH
74022: LD_VAR 0 3
74026: ARRAY
74027: PPUSH
74028: CALL_OW 459
74032: NOT
74033: AND
74034: PUSH
74035: LD_EXP 45
74039: PUSH
74040: LD_VAR 0 2
74044: ARRAY
74045: PUSH
74046: LD_VAR 0 3
74050: ARRAY
74051: PPUSH
74052: CALL_OW 314
74056: NOT
74057: AND
74058: IFFALSE 74225
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
74060: LD_EXP 45
74064: PUSH
74065: LD_VAR 0 2
74069: ARRAY
74070: PUSH
74071: LD_VAR 0 3
74075: ARRAY
74076: PPUSH
74077: CALL_OW 310
74081: IFFALSE 74104
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
74083: LD_EXP 45
74087: PUSH
74088: LD_VAR 0 2
74092: ARRAY
74093: PUSH
74094: LD_VAR 0 3
74098: ARRAY
74099: PPUSH
74100: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
74104: LD_EXP 45
74108: PUSH
74109: LD_VAR 0 2
74113: ARRAY
74114: PUSH
74115: LD_VAR 0 3
74119: ARRAY
74120: PPUSH
74121: CALL_OW 314
74125: NOT
74126: IFFALSE 74225
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
74128: LD_ADDR_VAR 0 7
74132: PUSH
74133: LD_VAR 0 3
74137: PUSH
74138: LD_EXP 44
74142: PUSH
74143: LD_VAR 0 2
74147: ARRAY
74148: PPUSH
74149: CALL 21986 0 1
74153: MOD
74154: PUSH
74155: LD_INT 1
74157: PLUS
74158: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
74159: LD_EXP 45
74163: PUSH
74164: LD_VAR 0 2
74168: ARRAY
74169: PUSH
74170: LD_VAR 0 3
74174: ARRAY
74175: PPUSH
74176: LD_EXP 44
74180: PUSH
74181: LD_VAR 0 2
74185: ARRAY
74186: PUSH
74187: LD_VAR 0 7
74191: ARRAY
74192: PUSH
74193: LD_INT 1
74195: ARRAY
74196: PPUSH
74197: LD_EXP 44
74201: PUSH
74202: LD_VAR 0 2
74206: ARRAY
74207: PUSH
74208: LD_VAR 0 7
74212: ARRAY
74213: PUSH
74214: LD_INT 2
74216: ARRAY
74217: PPUSH
74218: LD_INT 0
74220: PPUSH
74221: CALL_OW 193
// end ; end ; end ;
74225: GO 73871
74227: POP
74228: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74229: LD_ADDR_VAR 0 5
74233: PUSH
74234: LD_EXP 31
74238: PUSH
74239: LD_VAR 0 2
74243: ARRAY
74244: PPUSH
74245: LD_INT 2
74247: PUSH
74248: LD_INT 30
74250: PUSH
74251: LD_INT 4
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: PUSH
74258: LD_INT 30
74260: PUSH
74261: LD_INT 5
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: LD_INT 30
74270: PUSH
74271: LD_INT 32
74273: PUSH
74274: EMPTY
74275: LIST
74276: LIST
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: PPUSH
74284: CALL_OW 72
74288: ST_TO_ADDR
// if not tmp then
74289: LD_VAR 0 5
74293: NOT
74294: IFFALSE 74298
// continue ;
74296: GO 73784
// list := [ ] ;
74298: LD_ADDR_VAR 0 6
74302: PUSH
74303: EMPTY
74304: ST_TO_ADDR
// for j in tmp do
74305: LD_ADDR_VAR 0 3
74309: PUSH
74310: LD_VAR 0 5
74314: PUSH
74315: FOR_IN
74316: IFFALSE 74385
// begin for k in UnitsInside ( j ) do
74318: LD_ADDR_VAR 0 4
74322: PUSH
74323: LD_VAR 0 3
74327: PPUSH
74328: CALL_OW 313
74332: PUSH
74333: FOR_IN
74334: IFFALSE 74381
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74336: LD_VAR 0 4
74340: PPUSH
74341: CALL_OW 257
74345: PUSH
74346: LD_INT 1
74348: EQUAL
74349: PUSH
74350: LD_VAR 0 4
74354: PPUSH
74355: CALL_OW 459
74359: NOT
74360: AND
74361: IFFALSE 74379
// list := list ^ k ;
74363: LD_ADDR_VAR 0 6
74367: PUSH
74368: LD_VAR 0 6
74372: PUSH
74373: LD_VAR 0 4
74377: ADD
74378: ST_TO_ADDR
74379: GO 74333
74381: POP
74382: POP
// end ;
74383: GO 74315
74385: POP
74386: POP
// list := list diff mc_miners [ i ] ;
74387: LD_ADDR_VAR 0 6
74391: PUSH
74392: LD_VAR 0 6
74396: PUSH
74397: LD_EXP 45
74401: PUSH
74402: LD_VAR 0 2
74406: ARRAY
74407: DIFF
74408: ST_TO_ADDR
// if not list then
74409: LD_VAR 0 6
74413: NOT
74414: IFFALSE 74418
// continue ;
74416: GO 73784
// k := mc_mines [ i ] - mc_miners [ i ] ;
74418: LD_ADDR_VAR 0 4
74422: PUSH
74423: LD_EXP 44
74427: PUSH
74428: LD_VAR 0 2
74432: ARRAY
74433: PUSH
74434: LD_EXP 45
74438: PUSH
74439: LD_VAR 0 2
74443: ARRAY
74444: MINUS
74445: ST_TO_ADDR
// if k > list then
74446: LD_VAR 0 4
74450: PUSH
74451: LD_VAR 0 6
74455: GREATER
74456: IFFALSE 74468
// k := list ;
74458: LD_ADDR_VAR 0 4
74462: PUSH
74463: LD_VAR 0 6
74467: ST_TO_ADDR
// for j = 1 to k do
74468: LD_ADDR_VAR 0 3
74472: PUSH
74473: DOUBLE
74474: LD_INT 1
74476: DEC
74477: ST_TO_ADDR
74478: LD_VAR 0 4
74482: PUSH
74483: FOR_TO
74484: IFFALSE 74538
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74486: LD_ADDR_EXP 45
74490: PUSH
74491: LD_EXP 45
74495: PPUSH
74496: LD_VAR 0 2
74500: PUSH
74501: LD_EXP 45
74505: PUSH
74506: LD_VAR 0 2
74510: ARRAY
74511: PUSH
74512: LD_INT 1
74514: PLUS
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PPUSH
74520: LD_VAR 0 6
74524: PUSH
74525: LD_VAR 0 3
74529: ARRAY
74530: PPUSH
74531: CALL 24846 0 3
74535: ST_TO_ADDR
74536: GO 74483
74538: POP
74539: POP
// end ;
74540: GO 73784
74542: POP
74543: POP
// end ;
74544: LD_VAR 0 1
74548: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74549: LD_INT 0
74551: PPUSH
74552: PPUSH
74553: PPUSH
74554: PPUSH
74555: PPUSH
74556: PPUSH
74557: PPUSH
74558: PPUSH
74559: PPUSH
74560: PPUSH
74561: PPUSH
// if not mc_bases then
74562: LD_EXP 31
74566: NOT
74567: IFFALSE 74571
// exit ;
74569: GO 76394
// for i = 1 to mc_bases do
74571: LD_ADDR_VAR 0 2
74575: PUSH
74576: DOUBLE
74577: LD_INT 1
74579: DEC
74580: ST_TO_ADDR
74581: LD_EXP 31
74585: PUSH
74586: FOR_TO
74587: IFFALSE 76392
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74589: LD_EXP 31
74593: PUSH
74594: LD_VAR 0 2
74598: ARRAY
74599: NOT
74600: PUSH
74601: LD_EXP 38
74605: PUSH
74606: LD_VAR 0 2
74610: ARRAY
74611: OR
74612: IFFALSE 74616
// continue ;
74614: GO 74586
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74616: LD_EXP 47
74620: PUSH
74621: LD_VAR 0 2
74625: ARRAY
74626: NOT
74627: PUSH
74628: LD_EXP 48
74632: PUSH
74633: LD_VAR 0 2
74637: ARRAY
74638: AND
74639: IFFALSE 74677
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74641: LD_ADDR_EXP 48
74645: PUSH
74646: LD_EXP 48
74650: PPUSH
74651: LD_VAR 0 2
74655: PPUSH
74656: EMPTY
74657: PPUSH
74658: CALL_OW 1
74662: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74663: LD_VAR 0 2
74667: PPUSH
74668: LD_INT 107
74670: PPUSH
74671: CALL 65417 0 2
// continue ;
74675: GO 74586
// end ; target := [ ] ;
74677: LD_ADDR_VAR 0 7
74681: PUSH
74682: EMPTY
74683: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74684: LD_ADDR_VAR 0 6
74688: PUSH
74689: LD_EXP 31
74693: PUSH
74694: LD_VAR 0 2
74698: ARRAY
74699: PUSH
74700: LD_INT 1
74702: ARRAY
74703: PPUSH
74704: CALL_OW 255
74708: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74709: LD_ADDR_VAR 0 9
74713: PUSH
74714: LD_EXP 31
74718: PUSH
74719: LD_VAR 0 2
74723: ARRAY
74724: PPUSH
74725: LD_INT 2
74727: PUSH
74728: LD_INT 30
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 30
74740: PUSH
74741: LD_INT 1
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: LIST
74752: PPUSH
74753: CALL_OW 72
74757: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74758: LD_ADDR_VAR 0 3
74762: PUSH
74763: DOUBLE
74764: LD_EXP 47
74768: PUSH
74769: LD_VAR 0 2
74773: ARRAY
74774: INC
74775: ST_TO_ADDR
74776: LD_INT 1
74778: PUSH
74779: FOR_DOWNTO
74780: IFFALSE 75025
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74782: LD_EXP 47
74786: PUSH
74787: LD_VAR 0 2
74791: ARRAY
74792: PUSH
74793: LD_VAR 0 3
74797: ARRAY
74798: PUSH
74799: LD_INT 2
74801: ARRAY
74802: PPUSH
74803: LD_EXP 47
74807: PUSH
74808: LD_VAR 0 2
74812: ARRAY
74813: PUSH
74814: LD_VAR 0 3
74818: ARRAY
74819: PUSH
74820: LD_INT 3
74822: ARRAY
74823: PPUSH
74824: CALL_OW 488
74828: PUSH
74829: LD_EXP 47
74833: PUSH
74834: LD_VAR 0 2
74838: ARRAY
74839: PUSH
74840: LD_VAR 0 3
74844: ARRAY
74845: PUSH
74846: LD_INT 2
74848: ARRAY
74849: PPUSH
74850: LD_EXP 47
74854: PUSH
74855: LD_VAR 0 2
74859: ARRAY
74860: PUSH
74861: LD_VAR 0 3
74865: ARRAY
74866: PUSH
74867: LD_INT 3
74869: ARRAY
74870: PPUSH
74871: CALL_OW 284
74875: PUSH
74876: LD_INT 0
74878: EQUAL
74879: AND
74880: IFFALSE 74935
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
74882: LD_ADDR_VAR 0 5
74886: PUSH
74887: LD_EXP 47
74891: PUSH
74892: LD_VAR 0 2
74896: ARRAY
74897: PPUSH
74898: LD_VAR 0 3
74902: PPUSH
74903: CALL_OW 3
74907: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
74908: LD_ADDR_EXP 47
74912: PUSH
74913: LD_EXP 47
74917: PPUSH
74918: LD_VAR 0 2
74922: PPUSH
74923: LD_VAR 0 5
74927: PPUSH
74928: CALL_OW 1
74932: ST_TO_ADDR
// continue ;
74933: GO 74779
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
74935: LD_VAR 0 6
74939: PPUSH
74940: LD_EXP 47
74944: PUSH
74945: LD_VAR 0 2
74949: ARRAY
74950: PUSH
74951: LD_VAR 0 3
74955: ARRAY
74956: PUSH
74957: LD_INT 2
74959: ARRAY
74960: PPUSH
74961: LD_EXP 47
74965: PUSH
74966: LD_VAR 0 2
74970: ARRAY
74971: PUSH
74972: LD_VAR 0 3
74976: ARRAY
74977: PUSH
74978: LD_INT 3
74980: ARRAY
74981: PPUSH
74982: LD_INT 30
74984: PPUSH
74985: CALL 25742 0 4
74989: PUSH
74990: LD_INT 4
74992: ARRAY
74993: PUSH
74994: LD_INT 0
74996: EQUAL
74997: IFFALSE 75023
// begin target := mc_crates [ i ] [ j ] ;
74999: LD_ADDR_VAR 0 7
75003: PUSH
75004: LD_EXP 47
75008: PUSH
75009: LD_VAR 0 2
75013: ARRAY
75014: PUSH
75015: LD_VAR 0 3
75019: ARRAY
75020: ST_TO_ADDR
// break ;
75021: GO 75025
// end ; end ;
75023: GO 74779
75025: POP
75026: POP
// if not target then
75027: LD_VAR 0 7
75031: NOT
75032: IFFALSE 75036
// continue ;
75034: GO 74586
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75036: LD_ADDR_VAR 0 8
75040: PUSH
75041: LD_EXP 50
75045: PUSH
75046: LD_VAR 0 2
75050: ARRAY
75051: PPUSH
75052: LD_INT 2
75054: PUSH
75055: LD_INT 3
75057: PUSH
75058: LD_INT 58
75060: PUSH
75061: EMPTY
75062: LIST
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: LD_INT 61
75070: PUSH
75071: EMPTY
75072: LIST
75073: PUSH
75074: LD_INT 33
75076: PUSH
75077: LD_INT 5
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 33
75086: PUSH
75087: LD_INT 3
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: LIST
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 2
75103: PUSH
75104: LD_INT 34
75106: PUSH
75107: LD_INT 32
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 34
75116: PUSH
75117: LD_INT 51
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 34
75126: PUSH
75127: LD_INT 12
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PPUSH
75144: CALL_OW 72
75148: ST_TO_ADDR
// if not cargo then
75149: LD_VAR 0 8
75153: NOT
75154: IFFALSE 75860
// begin if mc_crates_collector [ i ] < 5 then
75156: LD_EXP 48
75160: PUSH
75161: LD_VAR 0 2
75165: ARRAY
75166: PUSH
75167: LD_INT 5
75169: LESS
75170: IFFALSE 75536
// begin if mc_ape [ i ] then
75172: LD_EXP 60
75176: PUSH
75177: LD_VAR 0 2
75181: ARRAY
75182: IFFALSE 75229
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75184: LD_ADDR_VAR 0 5
75188: PUSH
75189: LD_EXP 60
75193: PUSH
75194: LD_VAR 0 2
75198: ARRAY
75199: PPUSH
75200: LD_INT 25
75202: PUSH
75203: LD_INT 16
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 24
75212: PUSH
75213: LD_INT 750
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: PPUSH
75224: CALL_OW 72
75228: ST_TO_ADDR
// if not tmp then
75229: LD_VAR 0 5
75233: NOT
75234: IFFALSE 75281
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75236: LD_ADDR_VAR 0 5
75240: PUSH
75241: LD_EXP 31
75245: PUSH
75246: LD_VAR 0 2
75250: ARRAY
75251: PPUSH
75252: LD_INT 25
75254: PUSH
75255: LD_INT 2
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PUSH
75262: LD_INT 24
75264: PUSH
75265: LD_INT 750
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PPUSH
75276: CALL_OW 72
75280: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75281: LD_EXP 60
75285: PUSH
75286: LD_VAR 0 2
75290: ARRAY
75291: PUSH
75292: LD_EXP 31
75296: PUSH
75297: LD_VAR 0 2
75301: ARRAY
75302: PPUSH
75303: LD_INT 25
75305: PUSH
75306: LD_INT 2
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: LD_INT 24
75315: PUSH
75316: LD_INT 750
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PPUSH
75327: CALL_OW 72
75331: AND
75332: PUSH
75333: LD_VAR 0 5
75337: PUSH
75338: LD_INT 5
75340: LESS
75341: AND
75342: IFFALSE 75424
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75344: LD_ADDR_VAR 0 3
75348: PUSH
75349: LD_EXP 31
75353: PUSH
75354: LD_VAR 0 2
75358: ARRAY
75359: PPUSH
75360: LD_INT 25
75362: PUSH
75363: LD_INT 2
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: LD_INT 24
75372: PUSH
75373: LD_INT 750
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PPUSH
75384: CALL_OW 72
75388: PUSH
75389: FOR_IN
75390: IFFALSE 75422
// begin tmp := tmp union j ;
75392: LD_ADDR_VAR 0 5
75396: PUSH
75397: LD_VAR 0 5
75401: PUSH
75402: LD_VAR 0 3
75406: UNION
75407: ST_TO_ADDR
// if tmp >= 5 then
75408: LD_VAR 0 5
75412: PUSH
75413: LD_INT 5
75415: GREATEREQUAL
75416: IFFALSE 75420
// break ;
75418: GO 75422
// end ;
75420: GO 75389
75422: POP
75423: POP
// end ; if not tmp then
75424: LD_VAR 0 5
75428: NOT
75429: IFFALSE 75433
// continue ;
75431: GO 74586
// for j in tmp do
75433: LD_ADDR_VAR 0 3
75437: PUSH
75438: LD_VAR 0 5
75442: PUSH
75443: FOR_IN
75444: IFFALSE 75534
// if not GetTag ( j ) then
75446: LD_VAR 0 3
75450: PPUSH
75451: CALL_OW 110
75455: NOT
75456: IFFALSE 75532
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75458: LD_ADDR_EXP 48
75462: PUSH
75463: LD_EXP 48
75467: PPUSH
75468: LD_VAR 0 2
75472: PUSH
75473: LD_EXP 48
75477: PUSH
75478: LD_VAR 0 2
75482: ARRAY
75483: PUSH
75484: LD_INT 1
75486: PLUS
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: PPUSH
75492: LD_VAR 0 3
75496: PPUSH
75497: CALL 24846 0 3
75501: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75502: LD_VAR 0 3
75506: PPUSH
75507: LD_INT 107
75509: PPUSH
75510: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75514: LD_EXP 48
75518: PUSH
75519: LD_VAR 0 2
75523: ARRAY
75524: PUSH
75525: LD_INT 5
75527: GREATEREQUAL
75528: IFFALSE 75532
// break ;
75530: GO 75534
// end ;
75532: GO 75443
75534: POP
75535: POP
// end ; if mc_crates_collector [ i ] and target then
75536: LD_EXP 48
75540: PUSH
75541: LD_VAR 0 2
75545: ARRAY
75546: PUSH
75547: LD_VAR 0 7
75551: AND
75552: IFFALSE 75858
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75554: LD_EXP 48
75558: PUSH
75559: LD_VAR 0 2
75563: ARRAY
75564: PUSH
75565: LD_VAR 0 7
75569: PUSH
75570: LD_INT 1
75572: ARRAY
75573: LESS
75574: IFFALSE 75594
// tmp := mc_crates_collector [ i ] else
75576: LD_ADDR_VAR 0 5
75580: PUSH
75581: LD_EXP 48
75585: PUSH
75586: LD_VAR 0 2
75590: ARRAY
75591: ST_TO_ADDR
75592: GO 75608
// tmp := target [ 1 ] ;
75594: LD_ADDR_VAR 0 5
75598: PUSH
75599: LD_VAR 0 7
75603: PUSH
75604: LD_INT 1
75606: ARRAY
75607: ST_TO_ADDR
// k := 0 ;
75608: LD_ADDR_VAR 0 4
75612: PUSH
75613: LD_INT 0
75615: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75616: LD_ADDR_VAR 0 3
75620: PUSH
75621: LD_EXP 48
75625: PUSH
75626: LD_VAR 0 2
75630: ARRAY
75631: PUSH
75632: FOR_IN
75633: IFFALSE 75856
// begin k := k + 1 ;
75635: LD_ADDR_VAR 0 4
75639: PUSH
75640: LD_VAR 0 4
75644: PUSH
75645: LD_INT 1
75647: PLUS
75648: ST_TO_ADDR
// if k > tmp then
75649: LD_VAR 0 4
75653: PUSH
75654: LD_VAR 0 5
75658: GREATER
75659: IFFALSE 75663
// break ;
75661: GO 75856
// if not GetClass ( j ) in [ 2 , 16 ] then
75663: LD_VAR 0 3
75667: PPUSH
75668: CALL_OW 257
75672: PUSH
75673: LD_INT 2
75675: PUSH
75676: LD_INT 16
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: IN
75683: NOT
75684: IFFALSE 75737
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75686: LD_ADDR_EXP 48
75690: PUSH
75691: LD_EXP 48
75695: PPUSH
75696: LD_VAR 0 2
75700: PPUSH
75701: LD_EXP 48
75705: PUSH
75706: LD_VAR 0 2
75710: ARRAY
75711: PUSH
75712: LD_VAR 0 3
75716: DIFF
75717: PPUSH
75718: CALL_OW 1
75722: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75723: LD_VAR 0 3
75727: PPUSH
75728: LD_INT 0
75730: PPUSH
75731: CALL_OW 109
// continue ;
75735: GO 75632
// end ; if IsInUnit ( j ) then
75737: LD_VAR 0 3
75741: PPUSH
75742: CALL_OW 310
75746: IFFALSE 75757
// ComExitBuilding ( j ) ;
75748: LD_VAR 0 3
75752: PPUSH
75753: CALL_OW 122
// wait ( 3 ) ;
75757: LD_INT 3
75759: PPUSH
75760: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75764: LD_VAR 0 3
75768: PPUSH
75769: CALL_OW 314
75773: PUSH
75774: LD_VAR 0 6
75778: PPUSH
75779: LD_VAR 0 7
75783: PUSH
75784: LD_INT 2
75786: ARRAY
75787: PPUSH
75788: LD_VAR 0 7
75792: PUSH
75793: LD_INT 3
75795: ARRAY
75796: PPUSH
75797: LD_INT 30
75799: PPUSH
75800: CALL 25742 0 4
75804: PUSH
75805: LD_INT 4
75807: ARRAY
75808: AND
75809: IFFALSE 75827
// ComStandNearbyBuilding ( j , depot ) else
75811: LD_VAR 0 3
75815: PPUSH
75816: LD_VAR 0 9
75820: PPUSH
75821: CALL 21448 0 2
75825: GO 75854
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75827: LD_VAR 0 3
75831: PPUSH
75832: LD_VAR 0 7
75836: PUSH
75837: LD_INT 2
75839: ARRAY
75840: PPUSH
75841: LD_VAR 0 7
75845: PUSH
75846: LD_INT 3
75848: ARRAY
75849: PPUSH
75850: CALL_OW 117
// end ;
75854: GO 75632
75856: POP
75857: POP
// end ; end else
75858: GO 76390
// begin for j in cargo do
75860: LD_ADDR_VAR 0 3
75864: PUSH
75865: LD_VAR 0 8
75869: PUSH
75870: FOR_IN
75871: IFFALSE 76388
// begin if GetTag ( j ) <> 0 then
75873: LD_VAR 0 3
75877: PPUSH
75878: CALL_OW 110
75882: PUSH
75883: LD_INT 0
75885: NONEQUAL
75886: IFFALSE 75890
// continue ;
75888: GO 75870
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
75890: LD_VAR 0 3
75894: PPUSH
75895: CALL_OW 256
75899: PUSH
75900: LD_INT 1000
75902: LESS
75903: PUSH
75904: LD_VAR 0 3
75908: PPUSH
75909: LD_EXP 55
75913: PUSH
75914: LD_VAR 0 2
75918: ARRAY
75919: PPUSH
75920: CALL_OW 308
75924: NOT
75925: AND
75926: IFFALSE 75948
// ComMoveToArea ( j , mc_parking [ i ] ) ;
75928: LD_VAR 0 3
75932: PPUSH
75933: LD_EXP 55
75937: PUSH
75938: LD_VAR 0 2
75942: ARRAY
75943: PPUSH
75944: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
75948: LD_VAR 0 3
75952: PPUSH
75953: CALL_OW 256
75957: PUSH
75958: LD_INT 1000
75960: LESS
75961: PUSH
75962: LD_VAR 0 3
75966: PPUSH
75967: LD_EXP 55
75971: PUSH
75972: LD_VAR 0 2
75976: ARRAY
75977: PPUSH
75978: CALL_OW 308
75982: AND
75983: IFFALSE 75987
// continue ;
75985: GO 75870
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
75987: LD_VAR 0 3
75991: PPUSH
75992: CALL_OW 262
75996: PUSH
75997: LD_INT 2
75999: EQUAL
76000: PUSH
76001: LD_VAR 0 3
76005: PPUSH
76006: CALL_OW 261
76010: PUSH
76011: LD_INT 15
76013: LESS
76014: AND
76015: IFFALSE 76019
// continue ;
76017: GO 75870
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
76019: LD_VAR 0 3
76023: PPUSH
76024: CALL_OW 262
76028: PUSH
76029: LD_INT 1
76031: EQUAL
76032: PUSH
76033: LD_VAR 0 3
76037: PPUSH
76038: CALL_OW 261
76042: PUSH
76043: LD_INT 10
76045: LESS
76046: AND
76047: IFFALSE 76327
// begin if not depot then
76049: LD_VAR 0 9
76053: NOT
76054: IFFALSE 76058
// continue ;
76056: GO 75870
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76058: LD_VAR 0 3
76062: PPUSH
76063: LD_VAR 0 9
76067: PPUSH
76068: LD_VAR 0 3
76072: PPUSH
76073: CALL_OW 74
76077: PPUSH
76078: CALL_OW 296
76082: PUSH
76083: LD_INT 6
76085: LESS
76086: IFFALSE 76102
// SetFuel ( j , 100 ) else
76088: LD_VAR 0 3
76092: PPUSH
76093: LD_INT 100
76095: PPUSH
76096: CALL_OW 240
76100: GO 76327
// if GetFuel ( j ) = 0 then
76102: LD_VAR 0 3
76106: PPUSH
76107: CALL_OW 261
76111: PUSH
76112: LD_INT 0
76114: EQUAL
76115: IFFALSE 76327
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
76117: LD_ADDR_EXP 50
76121: PUSH
76122: LD_EXP 50
76126: PPUSH
76127: LD_VAR 0 2
76131: PPUSH
76132: LD_EXP 50
76136: PUSH
76137: LD_VAR 0 2
76141: ARRAY
76142: PUSH
76143: LD_VAR 0 3
76147: DIFF
76148: PPUSH
76149: CALL_OW 1
76153: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
76154: LD_VAR 0 3
76158: PPUSH
76159: CALL_OW 263
76163: PUSH
76164: LD_INT 1
76166: EQUAL
76167: IFFALSE 76183
// ComExitVehicle ( IsInUnit ( j ) ) ;
76169: LD_VAR 0 3
76173: PPUSH
76174: CALL_OW 310
76178: PPUSH
76179: CALL_OW 121
// if GetControl ( j ) = control_remote then
76183: LD_VAR 0 3
76187: PPUSH
76188: CALL_OW 263
76192: PUSH
76193: LD_INT 2
76195: EQUAL
76196: IFFALSE 76207
// ComUnlink ( j ) ;
76198: LD_VAR 0 3
76202: PPUSH
76203: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76207: LD_ADDR_VAR 0 10
76211: PUSH
76212: LD_VAR 0 2
76216: PPUSH
76217: LD_INT 3
76219: PPUSH
76220: CALL 85971 0 2
76224: ST_TO_ADDR
// if fac then
76225: LD_VAR 0 10
76229: IFFALSE 76325
// begin for k in fac do
76231: LD_ADDR_VAR 0 4
76235: PUSH
76236: LD_VAR 0 10
76240: PUSH
76241: FOR_IN
76242: IFFALSE 76323
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76244: LD_ADDR_VAR 0 11
76248: PUSH
76249: LD_VAR 0 10
76253: PPUSH
76254: LD_VAR 0 3
76258: PPUSH
76259: CALL_OW 265
76263: PPUSH
76264: LD_VAR 0 3
76268: PPUSH
76269: CALL_OW 262
76273: PPUSH
76274: LD_VAR 0 3
76278: PPUSH
76279: CALL_OW 263
76283: PPUSH
76284: LD_VAR 0 3
76288: PPUSH
76289: CALL_OW 264
76293: PPUSH
76294: CALL 22344 0 5
76298: ST_TO_ADDR
// if components then
76299: LD_VAR 0 11
76303: IFFALSE 76321
// begin MC_InsertProduceList ( i , components ) ;
76305: LD_VAR 0 2
76309: PPUSH
76310: LD_VAR 0 11
76314: PPUSH
76315: CALL 85516 0 2
// break ;
76319: GO 76323
// end ; end ;
76321: GO 76241
76323: POP
76324: POP
// end ; continue ;
76325: GO 75870
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76327: LD_VAR 0 3
76331: PPUSH
76332: LD_INT 1
76334: PPUSH
76335: CALL_OW 289
76339: PUSH
76340: LD_INT 100
76342: LESS
76343: PUSH
76344: LD_VAR 0 3
76348: PPUSH
76349: CALL_OW 314
76353: NOT
76354: AND
76355: IFFALSE 76384
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76357: LD_VAR 0 3
76361: PPUSH
76362: LD_VAR 0 7
76366: PUSH
76367: LD_INT 2
76369: ARRAY
76370: PPUSH
76371: LD_VAR 0 7
76375: PUSH
76376: LD_INT 3
76378: ARRAY
76379: PPUSH
76380: CALL_OW 117
// break ;
76384: GO 76388
// end ;
76386: GO 75870
76388: POP
76389: POP
// end ; end ;
76390: GO 74586
76392: POP
76393: POP
// end ;
76394: LD_VAR 0 1
76398: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76399: LD_INT 0
76401: PPUSH
76402: PPUSH
76403: PPUSH
76404: PPUSH
// if not mc_bases then
76405: LD_EXP 31
76409: NOT
76410: IFFALSE 76414
// exit ;
76412: GO 76575
// for i = 1 to mc_bases do
76414: LD_ADDR_VAR 0 2
76418: PUSH
76419: DOUBLE
76420: LD_INT 1
76422: DEC
76423: ST_TO_ADDR
76424: LD_EXP 31
76428: PUSH
76429: FOR_TO
76430: IFFALSE 76573
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76432: LD_ADDR_VAR 0 4
76436: PUSH
76437: LD_EXP 50
76441: PUSH
76442: LD_VAR 0 2
76446: ARRAY
76447: PUSH
76448: LD_EXP 53
76452: PUSH
76453: LD_VAR 0 2
76457: ARRAY
76458: UNION
76459: PPUSH
76460: LD_INT 33
76462: PUSH
76463: LD_INT 2
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PPUSH
76470: CALL_OW 72
76474: ST_TO_ADDR
// if tmp then
76475: LD_VAR 0 4
76479: IFFALSE 76571
// for j in tmp do
76481: LD_ADDR_VAR 0 3
76485: PUSH
76486: LD_VAR 0 4
76490: PUSH
76491: FOR_IN
76492: IFFALSE 76569
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76494: LD_VAR 0 3
76498: PPUSH
76499: CALL_OW 312
76503: NOT
76504: PUSH
76505: LD_VAR 0 3
76509: PPUSH
76510: CALL_OW 256
76514: PUSH
76515: LD_INT 250
76517: GREATEREQUAL
76518: AND
76519: IFFALSE 76532
// Connect ( j ) else
76521: LD_VAR 0 3
76525: PPUSH
76526: CALL 27815 0 1
76530: GO 76567
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76532: LD_VAR 0 3
76536: PPUSH
76537: CALL_OW 256
76541: PUSH
76542: LD_INT 250
76544: LESS
76545: PUSH
76546: LD_VAR 0 3
76550: PPUSH
76551: CALL_OW 312
76555: AND
76556: IFFALSE 76567
// ComUnlink ( j ) ;
76558: LD_VAR 0 3
76562: PPUSH
76563: CALL_OW 136
76567: GO 76491
76569: POP
76570: POP
// end ;
76571: GO 76429
76573: POP
76574: POP
// end ;
76575: LD_VAR 0 1
76579: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76580: LD_INT 0
76582: PPUSH
76583: PPUSH
76584: PPUSH
76585: PPUSH
76586: PPUSH
// if not mc_bases then
76587: LD_EXP 31
76591: NOT
76592: IFFALSE 76596
// exit ;
76594: GO 77041
// for i = 1 to mc_bases do
76596: LD_ADDR_VAR 0 2
76600: PUSH
76601: DOUBLE
76602: LD_INT 1
76604: DEC
76605: ST_TO_ADDR
76606: LD_EXP 31
76610: PUSH
76611: FOR_TO
76612: IFFALSE 77039
// begin if not mc_produce [ i ] then
76614: LD_EXP 52
76618: PUSH
76619: LD_VAR 0 2
76623: ARRAY
76624: NOT
76625: IFFALSE 76629
// continue ;
76627: GO 76611
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76629: LD_ADDR_VAR 0 5
76633: PUSH
76634: LD_EXP 31
76638: PUSH
76639: LD_VAR 0 2
76643: ARRAY
76644: PPUSH
76645: LD_INT 30
76647: PUSH
76648: LD_INT 3
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PPUSH
76655: CALL_OW 72
76659: ST_TO_ADDR
// if not fac then
76660: LD_VAR 0 5
76664: NOT
76665: IFFALSE 76669
// continue ;
76667: GO 76611
// for j in fac do
76669: LD_ADDR_VAR 0 3
76673: PUSH
76674: LD_VAR 0 5
76678: PUSH
76679: FOR_IN
76680: IFFALSE 77035
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76682: LD_VAR 0 3
76686: PPUSH
76687: CALL_OW 461
76691: PUSH
76692: LD_INT 2
76694: NONEQUAL
76695: PUSH
76696: LD_VAR 0 3
76700: PPUSH
76701: LD_INT 15
76703: PPUSH
76704: CALL 27443 0 2
76708: PUSH
76709: LD_INT 4
76711: ARRAY
76712: OR
76713: IFFALSE 76717
// continue ;
76715: GO 76679
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76717: LD_VAR 0 3
76721: PPUSH
76722: LD_EXP 52
76726: PUSH
76727: LD_VAR 0 2
76731: ARRAY
76732: PUSH
76733: LD_INT 1
76735: ARRAY
76736: PUSH
76737: LD_INT 1
76739: ARRAY
76740: PPUSH
76741: LD_EXP 52
76745: PUSH
76746: LD_VAR 0 2
76750: ARRAY
76751: PUSH
76752: LD_INT 1
76754: ARRAY
76755: PUSH
76756: LD_INT 2
76758: ARRAY
76759: PPUSH
76760: LD_EXP 52
76764: PUSH
76765: LD_VAR 0 2
76769: ARRAY
76770: PUSH
76771: LD_INT 1
76773: ARRAY
76774: PUSH
76775: LD_INT 3
76777: ARRAY
76778: PPUSH
76779: LD_EXP 52
76783: PUSH
76784: LD_VAR 0 2
76788: ARRAY
76789: PUSH
76790: LD_INT 1
76792: ARRAY
76793: PUSH
76794: LD_INT 4
76796: ARRAY
76797: PPUSH
76798: CALL_OW 448
76802: PUSH
76803: LD_VAR 0 3
76807: PPUSH
76808: LD_EXP 52
76812: PUSH
76813: LD_VAR 0 2
76817: ARRAY
76818: PUSH
76819: LD_INT 1
76821: ARRAY
76822: PUSH
76823: LD_INT 1
76825: ARRAY
76826: PUSH
76827: LD_EXP 52
76831: PUSH
76832: LD_VAR 0 2
76836: ARRAY
76837: PUSH
76838: LD_INT 1
76840: ARRAY
76841: PUSH
76842: LD_INT 2
76844: ARRAY
76845: PUSH
76846: LD_EXP 52
76850: PUSH
76851: LD_VAR 0 2
76855: ARRAY
76856: PUSH
76857: LD_INT 1
76859: ARRAY
76860: PUSH
76861: LD_INT 3
76863: ARRAY
76864: PUSH
76865: LD_EXP 52
76869: PUSH
76870: LD_VAR 0 2
76874: ARRAY
76875: PUSH
76876: LD_INT 1
76878: ARRAY
76879: PUSH
76880: LD_INT 4
76882: ARRAY
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: LIST
76888: LIST
76889: PPUSH
76890: CALL 31210 0 2
76894: AND
76895: IFFALSE 77033
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
76897: LD_VAR 0 3
76901: PPUSH
76902: LD_EXP 52
76906: PUSH
76907: LD_VAR 0 2
76911: ARRAY
76912: PUSH
76913: LD_INT 1
76915: ARRAY
76916: PUSH
76917: LD_INT 1
76919: ARRAY
76920: PPUSH
76921: LD_EXP 52
76925: PUSH
76926: LD_VAR 0 2
76930: ARRAY
76931: PUSH
76932: LD_INT 1
76934: ARRAY
76935: PUSH
76936: LD_INT 2
76938: ARRAY
76939: PPUSH
76940: LD_EXP 52
76944: PUSH
76945: LD_VAR 0 2
76949: ARRAY
76950: PUSH
76951: LD_INT 1
76953: ARRAY
76954: PUSH
76955: LD_INT 3
76957: ARRAY
76958: PPUSH
76959: LD_EXP 52
76963: PUSH
76964: LD_VAR 0 2
76968: ARRAY
76969: PUSH
76970: LD_INT 1
76972: ARRAY
76973: PUSH
76974: LD_INT 4
76976: ARRAY
76977: PPUSH
76978: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
76982: LD_ADDR_VAR 0 4
76986: PUSH
76987: LD_EXP 52
76991: PUSH
76992: LD_VAR 0 2
76996: ARRAY
76997: PPUSH
76998: LD_INT 1
77000: PPUSH
77001: CALL_OW 3
77005: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77006: LD_ADDR_EXP 52
77010: PUSH
77011: LD_EXP 52
77015: PPUSH
77016: LD_VAR 0 2
77020: PPUSH
77021: LD_VAR 0 4
77025: PPUSH
77026: CALL_OW 1
77030: ST_TO_ADDR
// break ;
77031: GO 77035
// end ; end ;
77033: GO 76679
77035: POP
77036: POP
// end ;
77037: GO 76611
77039: POP
77040: POP
// end ;
77041: LD_VAR 0 1
77045: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77046: LD_INT 0
77048: PPUSH
77049: PPUSH
77050: PPUSH
// if not mc_bases then
77051: LD_EXP 31
77055: NOT
77056: IFFALSE 77060
// exit ;
77058: GO 77149
// for i = 1 to mc_bases do
77060: LD_ADDR_VAR 0 2
77064: PUSH
77065: DOUBLE
77066: LD_INT 1
77068: DEC
77069: ST_TO_ADDR
77070: LD_EXP 31
77074: PUSH
77075: FOR_TO
77076: IFFALSE 77147
// begin if mc_attack [ i ] then
77078: LD_EXP 51
77082: PUSH
77083: LD_VAR 0 2
77087: ARRAY
77088: IFFALSE 77145
// begin tmp := mc_attack [ i ] [ 1 ] ;
77090: LD_ADDR_VAR 0 3
77094: PUSH
77095: LD_EXP 51
77099: PUSH
77100: LD_VAR 0 2
77104: ARRAY
77105: PUSH
77106: LD_INT 1
77108: ARRAY
77109: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
77110: LD_ADDR_EXP 51
77114: PUSH
77115: LD_EXP 51
77119: PPUSH
77120: LD_VAR 0 2
77124: PPUSH
77125: EMPTY
77126: PPUSH
77127: CALL_OW 1
77131: ST_TO_ADDR
// Attack ( tmp ) ;
77132: LD_VAR 0 3
77136: PPUSH
77137: CALL 112025 0 1
// exit ;
77141: POP
77142: POP
77143: GO 77149
// end ; end ;
77145: GO 77075
77147: POP
77148: POP
// end ;
77149: LD_VAR 0 1
77153: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77154: LD_INT 0
77156: PPUSH
77157: PPUSH
77158: PPUSH
77159: PPUSH
77160: PPUSH
77161: PPUSH
77162: PPUSH
// if not mc_bases then
77163: LD_EXP 31
77167: NOT
77168: IFFALSE 77172
// exit ;
77170: GO 78029
// for i = 1 to mc_bases do
77172: LD_ADDR_VAR 0 2
77176: PUSH
77177: DOUBLE
77178: LD_INT 1
77180: DEC
77181: ST_TO_ADDR
77182: LD_EXP 31
77186: PUSH
77187: FOR_TO
77188: IFFALSE 78027
// begin if not mc_bases [ i ] then
77190: LD_EXP 31
77194: PUSH
77195: LD_VAR 0 2
77199: ARRAY
77200: NOT
77201: IFFALSE 77205
// continue ;
77203: GO 77187
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77205: LD_ADDR_VAR 0 7
77209: PUSH
77210: LD_EXP 31
77214: PUSH
77215: LD_VAR 0 2
77219: ARRAY
77220: PUSH
77221: LD_INT 1
77223: ARRAY
77224: PPUSH
77225: CALL 21670 0 1
77229: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77230: LD_ADDR_EXP 54
77234: PUSH
77235: LD_EXP 54
77239: PPUSH
77240: LD_VAR 0 2
77244: PPUSH
77245: LD_EXP 31
77249: PUSH
77250: LD_VAR 0 2
77254: ARRAY
77255: PUSH
77256: LD_INT 1
77258: ARRAY
77259: PPUSH
77260: CALL_OW 255
77264: PPUSH
77265: LD_EXP 56
77269: PUSH
77270: LD_VAR 0 2
77274: ARRAY
77275: PPUSH
77276: CALL 21635 0 2
77280: PPUSH
77281: CALL_OW 1
77285: ST_TO_ADDR
// if not mc_scan [ i ] then
77286: LD_EXP 54
77290: PUSH
77291: LD_VAR 0 2
77295: ARRAY
77296: NOT
77297: IFFALSE 77475
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77299: LD_ADDR_EXP 74
77303: PUSH
77304: LD_EXP 74
77308: PPUSH
77309: LD_VAR 0 2
77313: PPUSH
77314: LD_INT 0
77316: PPUSH
77317: CALL_OW 1
77321: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77322: LD_ADDR_VAR 0 4
77326: PUSH
77327: LD_EXP 31
77331: PUSH
77332: LD_VAR 0 2
77336: ARRAY
77337: PPUSH
77338: LD_INT 2
77340: PUSH
77341: LD_INT 25
77343: PUSH
77344: LD_INT 5
77346: PUSH
77347: EMPTY
77348: LIST
77349: LIST
77350: PUSH
77351: LD_INT 25
77353: PUSH
77354: LD_INT 8
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: LD_INT 25
77363: PUSH
77364: LD_INT 9
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: LIST
77375: LIST
77376: PPUSH
77377: CALL_OW 72
77381: ST_TO_ADDR
// if not tmp then
77382: LD_VAR 0 4
77386: NOT
77387: IFFALSE 77391
// continue ;
77389: GO 77187
// for j in tmp do
77391: LD_ADDR_VAR 0 3
77395: PUSH
77396: LD_VAR 0 4
77400: PUSH
77401: FOR_IN
77402: IFFALSE 77473
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77404: LD_VAR 0 3
77408: PPUSH
77409: CALL_OW 310
77413: PPUSH
77414: CALL_OW 266
77418: PUSH
77419: LD_INT 5
77421: EQUAL
77422: PUSH
77423: LD_VAR 0 3
77427: PPUSH
77428: CALL_OW 257
77432: PUSH
77433: LD_INT 1
77435: EQUAL
77436: AND
77437: PUSH
77438: LD_VAR 0 3
77442: PPUSH
77443: CALL_OW 459
77447: NOT
77448: AND
77449: PUSH
77450: LD_VAR 0 7
77454: AND
77455: IFFALSE 77471
// ComChangeProfession ( j , class ) ;
77457: LD_VAR 0 3
77461: PPUSH
77462: LD_VAR 0 7
77466: PPUSH
77467: CALL_OW 123
77471: GO 77401
77473: POP
77474: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77475: LD_EXP 54
77479: PUSH
77480: LD_VAR 0 2
77484: ARRAY
77485: PUSH
77486: LD_EXP 74
77490: PUSH
77491: LD_VAR 0 2
77495: ARRAY
77496: NOT
77497: AND
77498: PUSH
77499: LD_EXP 53
77503: PUSH
77504: LD_VAR 0 2
77508: ARRAY
77509: NOT
77510: AND
77511: PUSH
77512: LD_EXP 31
77516: PUSH
77517: LD_VAR 0 2
77521: ARRAY
77522: PPUSH
77523: LD_INT 50
77525: PUSH
77526: EMPTY
77527: LIST
77528: PUSH
77529: LD_INT 2
77531: PUSH
77532: LD_INT 30
77534: PUSH
77535: LD_INT 32
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 30
77544: PUSH
77545: LD_INT 33
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 30
77554: PUSH
77555: LD_INT 4
77557: PUSH
77558: EMPTY
77559: LIST
77560: LIST
77561: PUSH
77562: LD_INT 30
77564: PUSH
77565: LD_INT 5
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PPUSH
77583: CALL_OW 72
77587: PUSH
77588: LD_INT 4
77590: LESS
77591: PUSH
77592: LD_EXP 31
77596: PUSH
77597: LD_VAR 0 2
77601: ARRAY
77602: PPUSH
77603: LD_INT 3
77605: PUSH
77606: LD_INT 24
77608: PUSH
77609: LD_INT 1000
77611: PUSH
77612: EMPTY
77613: LIST
77614: LIST
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 2
77622: PUSH
77623: LD_INT 30
77625: PUSH
77626: LD_INT 0
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: LD_INT 30
77635: PUSH
77636: LD_INT 1
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: LIST
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PPUSH
77652: CALL_OW 72
77656: OR
77657: AND
77658: IFFALSE 77909
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77660: LD_ADDR_EXP 74
77664: PUSH
77665: LD_EXP 74
77669: PPUSH
77670: LD_VAR 0 2
77674: PPUSH
77675: LD_INT 1
77677: PPUSH
77678: CALL_OW 1
77682: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77683: LD_ADDR_VAR 0 4
77687: PUSH
77688: LD_EXP 31
77692: PUSH
77693: LD_VAR 0 2
77697: ARRAY
77698: PPUSH
77699: LD_INT 2
77701: PUSH
77702: LD_INT 25
77704: PUSH
77705: LD_INT 1
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 25
77714: PUSH
77715: LD_INT 5
77717: PUSH
77718: EMPTY
77719: LIST
77720: LIST
77721: PUSH
77722: LD_INT 25
77724: PUSH
77725: LD_INT 8
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: LD_INT 25
77734: PUSH
77735: LD_INT 9
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: LIST
77748: PPUSH
77749: CALL_OW 72
77753: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77754: LD_ADDR_VAR 0 4
77758: PUSH
77759: LD_VAR 0 4
77763: PUSH
77764: LD_VAR 0 4
77768: PPUSH
77769: LD_INT 18
77771: PPUSH
77772: CALL 54758 0 2
77776: DIFF
77777: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77778: LD_VAR 0 4
77782: NOT
77783: PUSH
77784: LD_EXP 31
77788: PUSH
77789: LD_VAR 0 2
77793: ARRAY
77794: PPUSH
77795: LD_INT 2
77797: PUSH
77798: LD_INT 30
77800: PUSH
77801: LD_INT 4
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 30
77810: PUSH
77811: LD_INT 5
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: LIST
77822: PPUSH
77823: CALL_OW 72
77827: NOT
77828: AND
77829: IFFALSE 77891
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
77831: LD_ADDR_VAR 0 4
77835: PUSH
77836: LD_EXP 31
77840: PUSH
77841: LD_VAR 0 2
77845: ARRAY
77846: PPUSH
77847: LD_INT 2
77849: PUSH
77850: LD_INT 25
77852: PUSH
77853: LD_INT 2
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: LD_INT 25
77862: PUSH
77863: LD_INT 3
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 25
77872: PUSH
77873: LD_INT 4
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: LIST
77884: LIST
77885: PPUSH
77886: CALL_OW 72
77890: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
77891: LD_VAR 0 2
77895: PPUSH
77896: LD_VAR 0 4
77900: PPUSH
77901: CALL 116734 0 2
// exit ;
77905: POP
77906: POP
77907: GO 78029
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
77909: LD_EXP 54
77913: PUSH
77914: LD_VAR 0 2
77918: ARRAY
77919: PUSH
77920: LD_EXP 74
77924: PUSH
77925: LD_VAR 0 2
77929: ARRAY
77930: NOT
77931: AND
77932: PUSH
77933: LD_EXP 53
77937: PUSH
77938: LD_VAR 0 2
77942: ARRAY
77943: AND
77944: IFFALSE 78025
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77946: LD_ADDR_EXP 74
77950: PUSH
77951: LD_EXP 74
77955: PPUSH
77956: LD_VAR 0 2
77960: PPUSH
77961: LD_INT 1
77963: PPUSH
77964: CALL_OW 1
77968: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
77969: LD_ADDR_VAR 0 4
77973: PUSH
77974: LD_EXP 53
77978: PUSH
77979: LD_VAR 0 2
77983: ARRAY
77984: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
77985: LD_ADDR_EXP 53
77989: PUSH
77990: LD_EXP 53
77994: PPUSH
77995: LD_VAR 0 2
77999: PPUSH
78000: EMPTY
78001: PPUSH
78002: CALL_OW 1
78006: ST_TO_ADDR
// Defend ( i , tmp ) ;
78007: LD_VAR 0 2
78011: PPUSH
78012: LD_VAR 0 4
78016: PPUSH
78017: CALL 117330 0 2
// exit ;
78021: POP
78022: POP
78023: GO 78029
// end ; end ;
78025: GO 77187
78027: POP
78028: POP
// end ;
78029: LD_VAR 0 1
78033: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78034: LD_INT 0
78036: PPUSH
78037: PPUSH
78038: PPUSH
78039: PPUSH
78040: PPUSH
78041: PPUSH
78042: PPUSH
78043: PPUSH
78044: PPUSH
78045: PPUSH
78046: PPUSH
// if not mc_bases then
78047: LD_EXP 31
78051: NOT
78052: IFFALSE 78056
// exit ;
78054: GO 79143
// for i = 1 to mc_bases do
78056: LD_ADDR_VAR 0 2
78060: PUSH
78061: DOUBLE
78062: LD_INT 1
78064: DEC
78065: ST_TO_ADDR
78066: LD_EXP 31
78070: PUSH
78071: FOR_TO
78072: IFFALSE 79141
// begin tmp := mc_lab [ i ] ;
78074: LD_ADDR_VAR 0 6
78078: PUSH
78079: LD_EXP 64
78083: PUSH
78084: LD_VAR 0 2
78088: ARRAY
78089: ST_TO_ADDR
// if not tmp then
78090: LD_VAR 0 6
78094: NOT
78095: IFFALSE 78099
// continue ;
78097: GO 78071
// idle_lab := 0 ;
78099: LD_ADDR_VAR 0 11
78103: PUSH
78104: LD_INT 0
78106: ST_TO_ADDR
// for j in tmp do
78107: LD_ADDR_VAR 0 3
78111: PUSH
78112: LD_VAR 0 6
78116: PUSH
78117: FOR_IN
78118: IFFALSE 79137
// begin researching := false ;
78120: LD_ADDR_VAR 0 10
78124: PUSH
78125: LD_INT 0
78127: ST_TO_ADDR
// side := GetSide ( j ) ;
78128: LD_ADDR_VAR 0 4
78132: PUSH
78133: LD_VAR 0 3
78137: PPUSH
78138: CALL_OW 255
78142: ST_TO_ADDR
// if not mc_tech [ side ] then
78143: LD_EXP 58
78147: PUSH
78148: LD_VAR 0 4
78152: ARRAY
78153: NOT
78154: IFFALSE 78158
// continue ;
78156: GO 78117
// if BuildingStatus ( j ) = bs_idle then
78158: LD_VAR 0 3
78162: PPUSH
78163: CALL_OW 461
78167: PUSH
78168: LD_INT 2
78170: EQUAL
78171: IFFALSE 78359
// begin if idle_lab and UnitsInside ( j ) < 6 then
78173: LD_VAR 0 11
78177: PUSH
78178: LD_VAR 0 3
78182: PPUSH
78183: CALL_OW 313
78187: PUSH
78188: LD_INT 6
78190: LESS
78191: AND
78192: IFFALSE 78263
// begin tmp2 := UnitsInside ( idle_lab ) ;
78194: LD_ADDR_VAR 0 9
78198: PUSH
78199: LD_VAR 0 11
78203: PPUSH
78204: CALL_OW 313
78208: ST_TO_ADDR
// if tmp2 then
78209: LD_VAR 0 9
78213: IFFALSE 78255
// for x in tmp2 do
78215: LD_ADDR_VAR 0 7
78219: PUSH
78220: LD_VAR 0 9
78224: PUSH
78225: FOR_IN
78226: IFFALSE 78253
// begin ComExitBuilding ( x ) ;
78228: LD_VAR 0 7
78232: PPUSH
78233: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78237: LD_VAR 0 7
78241: PPUSH
78242: LD_VAR 0 3
78246: PPUSH
78247: CALL_OW 180
// end ;
78251: GO 78225
78253: POP
78254: POP
// idle_lab := 0 ;
78255: LD_ADDR_VAR 0 11
78259: PUSH
78260: LD_INT 0
78262: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78263: LD_ADDR_VAR 0 5
78267: PUSH
78268: LD_EXP 58
78272: PUSH
78273: LD_VAR 0 4
78277: ARRAY
78278: PUSH
78279: FOR_IN
78280: IFFALSE 78340
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78282: LD_VAR 0 3
78286: PPUSH
78287: LD_VAR 0 5
78291: PPUSH
78292: CALL_OW 430
78296: PUSH
78297: LD_VAR 0 4
78301: PPUSH
78302: LD_VAR 0 5
78306: PPUSH
78307: CALL 20740 0 2
78311: AND
78312: IFFALSE 78338
// begin researching := true ;
78314: LD_ADDR_VAR 0 10
78318: PUSH
78319: LD_INT 1
78321: ST_TO_ADDR
// ComResearch ( j , t ) ;
78322: LD_VAR 0 3
78326: PPUSH
78327: LD_VAR 0 5
78331: PPUSH
78332: CALL_OW 124
// break ;
78336: GO 78340
// end ;
78338: GO 78279
78340: POP
78341: POP
// if not researching then
78342: LD_VAR 0 10
78346: NOT
78347: IFFALSE 78359
// idle_lab := j ;
78349: LD_ADDR_VAR 0 11
78353: PUSH
78354: LD_VAR 0 3
78358: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78359: LD_VAR 0 3
78363: PPUSH
78364: CALL_OW 461
78368: PUSH
78369: LD_INT 10
78371: EQUAL
78372: IFFALSE 78960
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78374: LD_EXP 60
78378: PUSH
78379: LD_VAR 0 2
78383: ARRAY
78384: NOT
78385: PUSH
78386: LD_EXP 61
78390: PUSH
78391: LD_VAR 0 2
78395: ARRAY
78396: NOT
78397: AND
78398: PUSH
78399: LD_EXP 58
78403: PUSH
78404: LD_VAR 0 4
78408: ARRAY
78409: PUSH
78410: LD_INT 1
78412: GREATER
78413: AND
78414: IFFALSE 78545
// begin ComCancel ( j ) ;
78416: LD_VAR 0 3
78420: PPUSH
78421: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78425: LD_ADDR_EXP 58
78429: PUSH
78430: LD_EXP 58
78434: PPUSH
78435: LD_VAR 0 4
78439: PPUSH
78440: LD_EXP 58
78444: PUSH
78445: LD_VAR 0 4
78449: ARRAY
78450: PPUSH
78451: LD_EXP 58
78455: PUSH
78456: LD_VAR 0 4
78460: ARRAY
78461: PUSH
78462: LD_INT 1
78464: MINUS
78465: PPUSH
78466: LD_EXP 58
78470: PUSH
78471: LD_VAR 0 4
78475: ARRAY
78476: PPUSH
78477: LD_INT 0
78479: PPUSH
78480: CALL 24264 0 4
78484: PPUSH
78485: CALL_OW 1
78489: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78490: LD_ADDR_EXP 58
78494: PUSH
78495: LD_EXP 58
78499: PPUSH
78500: LD_VAR 0 4
78504: PPUSH
78505: LD_EXP 58
78509: PUSH
78510: LD_VAR 0 4
78514: ARRAY
78515: PPUSH
78516: LD_EXP 58
78520: PUSH
78521: LD_VAR 0 4
78525: ARRAY
78526: PPUSH
78527: LD_INT 1
78529: PPUSH
78530: LD_INT 0
78532: PPUSH
78533: CALL 24264 0 4
78537: PPUSH
78538: CALL_OW 1
78542: ST_TO_ADDR
// continue ;
78543: GO 78117
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78545: LD_EXP 60
78549: PUSH
78550: LD_VAR 0 2
78554: ARRAY
78555: PUSH
78556: LD_EXP 61
78560: PUSH
78561: LD_VAR 0 2
78565: ARRAY
78566: NOT
78567: AND
78568: IFFALSE 78695
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78570: LD_ADDR_EXP 61
78574: PUSH
78575: LD_EXP 61
78579: PPUSH
78580: LD_VAR 0 2
78584: PUSH
78585: LD_EXP 61
78589: PUSH
78590: LD_VAR 0 2
78594: ARRAY
78595: PUSH
78596: LD_INT 1
78598: PLUS
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PPUSH
78604: LD_EXP 60
78608: PUSH
78609: LD_VAR 0 2
78613: ARRAY
78614: PUSH
78615: LD_INT 1
78617: ARRAY
78618: PPUSH
78619: CALL 24846 0 3
78623: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78624: LD_EXP 60
78628: PUSH
78629: LD_VAR 0 2
78633: ARRAY
78634: PUSH
78635: LD_INT 1
78637: ARRAY
78638: PPUSH
78639: LD_INT 112
78641: PPUSH
78642: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78646: LD_ADDR_VAR 0 9
78650: PUSH
78651: LD_EXP 60
78655: PUSH
78656: LD_VAR 0 2
78660: ARRAY
78661: PPUSH
78662: LD_INT 1
78664: PPUSH
78665: CALL_OW 3
78669: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78670: LD_ADDR_EXP 60
78674: PUSH
78675: LD_EXP 60
78679: PPUSH
78680: LD_VAR 0 2
78684: PPUSH
78685: LD_VAR 0 9
78689: PPUSH
78690: CALL_OW 1
78694: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78695: LD_EXP 60
78699: PUSH
78700: LD_VAR 0 2
78704: ARRAY
78705: PUSH
78706: LD_EXP 61
78710: PUSH
78711: LD_VAR 0 2
78715: ARRAY
78716: AND
78717: PUSH
78718: LD_EXP 61
78722: PUSH
78723: LD_VAR 0 2
78727: ARRAY
78728: PUSH
78729: LD_INT 1
78731: ARRAY
78732: PPUSH
78733: CALL_OW 310
78737: NOT
78738: AND
78739: PUSH
78740: LD_VAR 0 3
78744: PPUSH
78745: CALL_OW 313
78749: PUSH
78750: LD_INT 6
78752: EQUAL
78753: AND
78754: IFFALSE 78810
// begin tmp2 := UnitsInside ( j ) ;
78756: LD_ADDR_VAR 0 9
78760: PUSH
78761: LD_VAR 0 3
78765: PPUSH
78766: CALL_OW 313
78770: ST_TO_ADDR
// if tmp2 = 6 then
78771: LD_VAR 0 9
78775: PUSH
78776: LD_INT 6
78778: EQUAL
78779: IFFALSE 78810
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78781: LD_VAR 0 9
78785: PUSH
78786: LD_INT 1
78788: ARRAY
78789: PPUSH
78790: LD_INT 112
78792: PPUSH
78793: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78797: LD_VAR 0 9
78801: PUSH
78802: LD_INT 1
78804: ARRAY
78805: PPUSH
78806: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78810: LD_EXP 61
78814: PUSH
78815: LD_VAR 0 2
78819: ARRAY
78820: PUSH
78821: LD_EXP 61
78825: PUSH
78826: LD_VAR 0 2
78830: ARRAY
78831: PUSH
78832: LD_INT 1
78834: ARRAY
78835: PPUSH
78836: CALL_OW 314
78840: NOT
78841: AND
78842: PUSH
78843: LD_EXP 61
78847: PUSH
78848: LD_VAR 0 2
78852: ARRAY
78853: PUSH
78854: LD_INT 1
78856: ARRAY
78857: PPUSH
78858: CALL_OW 310
78862: NOT
78863: AND
78864: IFFALSE 78890
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78866: LD_EXP 61
78870: PUSH
78871: LD_VAR 0 2
78875: ARRAY
78876: PUSH
78877: LD_INT 1
78879: ARRAY
78880: PPUSH
78881: LD_VAR 0 3
78885: PPUSH
78886: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78890: LD_EXP 61
78894: PUSH
78895: LD_VAR 0 2
78899: ARRAY
78900: PUSH
78901: LD_INT 1
78903: ARRAY
78904: PPUSH
78905: CALL_OW 310
78909: PUSH
78910: LD_EXP 61
78914: PUSH
78915: LD_VAR 0 2
78919: ARRAY
78920: PUSH
78921: LD_INT 1
78923: ARRAY
78924: PPUSH
78925: CALL_OW 310
78929: PPUSH
78930: CALL_OW 461
78934: PUSH
78935: LD_INT 3
78937: NONEQUAL
78938: AND
78939: IFFALSE 78960
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78941: LD_EXP 61
78945: PUSH
78946: LD_VAR 0 2
78950: ARRAY
78951: PUSH
78952: LD_INT 1
78954: ARRAY
78955: PPUSH
78956: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
78960: LD_VAR 0 3
78964: PPUSH
78965: CALL_OW 461
78969: PUSH
78970: LD_INT 6
78972: EQUAL
78973: PUSH
78974: LD_VAR 0 6
78978: PUSH
78979: LD_INT 1
78981: GREATER
78982: AND
78983: IFFALSE 79135
// begin sci := [ ] ;
78985: LD_ADDR_VAR 0 8
78989: PUSH
78990: EMPTY
78991: ST_TO_ADDR
// for x in ( tmp diff j ) do
78992: LD_ADDR_VAR 0 7
78996: PUSH
78997: LD_VAR 0 6
79001: PUSH
79002: LD_VAR 0 3
79006: DIFF
79007: PUSH
79008: FOR_IN
79009: IFFALSE 79061
// begin if sci = 6 then
79011: LD_VAR 0 8
79015: PUSH
79016: LD_INT 6
79018: EQUAL
79019: IFFALSE 79023
// break ;
79021: GO 79061
// if BuildingStatus ( x ) = bs_idle then
79023: LD_VAR 0 7
79027: PPUSH
79028: CALL_OW 461
79032: PUSH
79033: LD_INT 2
79035: EQUAL
79036: IFFALSE 79059
// sci := sci ^ UnitsInside ( x ) ;
79038: LD_ADDR_VAR 0 8
79042: PUSH
79043: LD_VAR 0 8
79047: PUSH
79048: LD_VAR 0 7
79052: PPUSH
79053: CALL_OW 313
79057: ADD
79058: ST_TO_ADDR
// end ;
79059: GO 79008
79061: POP
79062: POP
// if not sci then
79063: LD_VAR 0 8
79067: NOT
79068: IFFALSE 79072
// continue ;
79070: GO 78117
// for x in sci do
79072: LD_ADDR_VAR 0 7
79076: PUSH
79077: LD_VAR 0 8
79081: PUSH
79082: FOR_IN
79083: IFFALSE 79133
// if IsInUnit ( x ) and not HasTask ( x ) then
79085: LD_VAR 0 7
79089: PPUSH
79090: CALL_OW 310
79094: PUSH
79095: LD_VAR 0 7
79099: PPUSH
79100: CALL_OW 314
79104: NOT
79105: AND
79106: IFFALSE 79131
// begin ComExitBuilding ( x ) ;
79108: LD_VAR 0 7
79112: PPUSH
79113: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79117: LD_VAR 0 7
79121: PPUSH
79122: LD_VAR 0 3
79126: PPUSH
79127: CALL_OW 180
// end ;
79131: GO 79082
79133: POP
79134: POP
// end ; end ;
79135: GO 78117
79137: POP
79138: POP
// end ;
79139: GO 78071
79141: POP
79142: POP
// end ;
79143: LD_VAR 0 1
79147: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79148: LD_INT 0
79150: PPUSH
79151: PPUSH
// if not mc_bases then
79152: LD_EXP 31
79156: NOT
79157: IFFALSE 79161
// exit ;
79159: GO 79242
// for i = 1 to mc_bases do
79161: LD_ADDR_VAR 0 2
79165: PUSH
79166: DOUBLE
79167: LD_INT 1
79169: DEC
79170: ST_TO_ADDR
79171: LD_EXP 31
79175: PUSH
79176: FOR_TO
79177: IFFALSE 79240
// if mc_mines [ i ] and mc_miners [ i ] then
79179: LD_EXP 44
79183: PUSH
79184: LD_VAR 0 2
79188: ARRAY
79189: PUSH
79190: LD_EXP 45
79194: PUSH
79195: LD_VAR 0 2
79199: ARRAY
79200: AND
79201: IFFALSE 79238
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79203: LD_EXP 45
79207: PUSH
79208: LD_VAR 0 2
79212: ARRAY
79213: PUSH
79214: LD_INT 1
79216: ARRAY
79217: PPUSH
79218: CALL_OW 255
79222: PPUSH
79223: LD_EXP 44
79227: PUSH
79228: LD_VAR 0 2
79232: ARRAY
79233: PPUSH
79234: CALL 21823 0 2
79238: GO 79176
79240: POP
79241: POP
// end ;
79242: LD_VAR 0 1
79246: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79247: LD_INT 0
79249: PPUSH
79250: PPUSH
79251: PPUSH
79252: PPUSH
79253: PPUSH
79254: PPUSH
79255: PPUSH
79256: PPUSH
// if not mc_bases or not mc_parking then
79257: LD_EXP 31
79261: NOT
79262: PUSH
79263: LD_EXP 55
79267: NOT
79268: OR
79269: IFFALSE 79273
// exit ;
79271: GO 80011
// for i = 1 to mc_bases do
79273: LD_ADDR_VAR 0 2
79277: PUSH
79278: DOUBLE
79279: LD_INT 1
79281: DEC
79282: ST_TO_ADDR
79283: LD_EXP 31
79287: PUSH
79288: FOR_TO
79289: IFFALSE 80009
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79291: LD_EXP 31
79295: PUSH
79296: LD_VAR 0 2
79300: ARRAY
79301: NOT
79302: PUSH
79303: LD_EXP 55
79307: PUSH
79308: LD_VAR 0 2
79312: ARRAY
79313: NOT
79314: OR
79315: IFFALSE 79319
// continue ;
79317: GO 79288
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79319: LD_ADDR_VAR 0 5
79323: PUSH
79324: LD_EXP 31
79328: PUSH
79329: LD_VAR 0 2
79333: ARRAY
79334: PUSH
79335: LD_INT 1
79337: ARRAY
79338: PPUSH
79339: CALL_OW 255
79343: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79344: LD_ADDR_VAR 0 6
79348: PUSH
79349: LD_EXP 31
79353: PUSH
79354: LD_VAR 0 2
79358: ARRAY
79359: PPUSH
79360: LD_INT 30
79362: PUSH
79363: LD_INT 3
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PPUSH
79370: CALL_OW 72
79374: ST_TO_ADDR
// if not fac then
79375: LD_VAR 0 6
79379: NOT
79380: IFFALSE 79431
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79382: LD_ADDR_VAR 0 6
79386: PUSH
79387: LD_EXP 31
79391: PUSH
79392: LD_VAR 0 2
79396: ARRAY
79397: PPUSH
79398: LD_INT 2
79400: PUSH
79401: LD_INT 30
79403: PUSH
79404: LD_INT 0
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: PUSH
79411: LD_INT 30
79413: PUSH
79414: LD_INT 1
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: LIST
79425: PPUSH
79426: CALL_OW 72
79430: ST_TO_ADDR
// if not fac then
79431: LD_VAR 0 6
79435: NOT
79436: IFFALSE 79440
// continue ;
79438: GO 79288
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79440: LD_ADDR_VAR 0 7
79444: PUSH
79445: LD_EXP 55
79449: PUSH
79450: LD_VAR 0 2
79454: ARRAY
79455: PPUSH
79456: LD_INT 22
79458: PUSH
79459: LD_VAR 0 5
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 21
79470: PUSH
79471: LD_INT 2
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 3
79480: PUSH
79481: LD_INT 60
79483: PUSH
79484: EMPTY
79485: LIST
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 3
79493: PUSH
79494: LD_INT 24
79496: PUSH
79497: LD_INT 1000
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: PPUSH
79514: CALL_OW 70
79518: ST_TO_ADDR
// for j in fac do
79519: LD_ADDR_VAR 0 3
79523: PUSH
79524: LD_VAR 0 6
79528: PUSH
79529: FOR_IN
79530: IFFALSE 79625
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79532: LD_ADDR_VAR 0 7
79536: PUSH
79537: LD_VAR 0 7
79541: PUSH
79542: LD_INT 22
79544: PUSH
79545: LD_VAR 0 5
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 91
79556: PUSH
79557: LD_VAR 0 3
79561: PUSH
79562: LD_INT 15
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: LIST
79569: PUSH
79570: LD_INT 21
79572: PUSH
79573: LD_INT 2
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PUSH
79580: LD_INT 3
79582: PUSH
79583: LD_INT 60
79585: PUSH
79586: EMPTY
79587: LIST
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 3
79595: PUSH
79596: LD_INT 24
79598: PUSH
79599: LD_INT 1000
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: PPUSH
79617: CALL_OW 69
79621: UNION
79622: ST_TO_ADDR
79623: GO 79529
79625: POP
79626: POP
// if not vehs then
79627: LD_VAR 0 7
79631: NOT
79632: IFFALSE 79658
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79634: LD_ADDR_EXP 43
79638: PUSH
79639: LD_EXP 43
79643: PPUSH
79644: LD_VAR 0 2
79648: PPUSH
79649: EMPTY
79650: PPUSH
79651: CALL_OW 1
79655: ST_TO_ADDR
// continue ;
79656: GO 79288
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79658: LD_ADDR_VAR 0 8
79662: PUSH
79663: LD_EXP 31
79667: PUSH
79668: LD_VAR 0 2
79672: ARRAY
79673: PPUSH
79674: LD_INT 30
79676: PUSH
79677: LD_INT 3
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PPUSH
79684: CALL_OW 72
79688: ST_TO_ADDR
// if tmp then
79689: LD_VAR 0 8
79693: IFFALSE 79796
// begin for j in tmp do
79695: LD_ADDR_VAR 0 3
79699: PUSH
79700: LD_VAR 0 8
79704: PUSH
79705: FOR_IN
79706: IFFALSE 79794
// for k in UnitsInside ( j ) do
79708: LD_ADDR_VAR 0 4
79712: PUSH
79713: LD_VAR 0 3
79717: PPUSH
79718: CALL_OW 313
79722: PUSH
79723: FOR_IN
79724: IFFALSE 79790
// if k then
79726: LD_VAR 0 4
79730: IFFALSE 79788
// if not k in mc_repair_vehicle [ i ] then
79732: LD_VAR 0 4
79736: PUSH
79737: LD_EXP 43
79741: PUSH
79742: LD_VAR 0 2
79746: ARRAY
79747: IN
79748: NOT
79749: IFFALSE 79788
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79751: LD_ADDR_EXP 43
79755: PUSH
79756: LD_EXP 43
79760: PPUSH
79761: LD_VAR 0 2
79765: PPUSH
79766: LD_EXP 43
79770: PUSH
79771: LD_VAR 0 2
79775: ARRAY
79776: PUSH
79777: LD_VAR 0 4
79781: UNION
79782: PPUSH
79783: CALL_OW 1
79787: ST_TO_ADDR
79788: GO 79723
79790: POP
79791: POP
79792: GO 79705
79794: POP
79795: POP
// end ; if not mc_repair_vehicle [ i ] then
79796: LD_EXP 43
79800: PUSH
79801: LD_VAR 0 2
79805: ARRAY
79806: NOT
79807: IFFALSE 79811
// continue ;
79809: GO 79288
// for j in mc_repair_vehicle [ i ] do
79811: LD_ADDR_VAR 0 3
79815: PUSH
79816: LD_EXP 43
79820: PUSH
79821: LD_VAR 0 2
79825: ARRAY
79826: PUSH
79827: FOR_IN
79828: IFFALSE 80005
// begin if GetClass ( j ) <> 3 then
79830: LD_VAR 0 3
79834: PPUSH
79835: CALL_OW 257
79839: PUSH
79840: LD_INT 3
79842: NONEQUAL
79843: IFFALSE 79884
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79845: LD_ADDR_EXP 43
79849: PUSH
79850: LD_EXP 43
79854: PPUSH
79855: LD_VAR 0 2
79859: PPUSH
79860: LD_EXP 43
79864: PUSH
79865: LD_VAR 0 2
79869: ARRAY
79870: PUSH
79871: LD_VAR 0 3
79875: DIFF
79876: PPUSH
79877: CALL_OW 1
79881: ST_TO_ADDR
// continue ;
79882: GO 79827
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79884: LD_VAR 0 3
79888: PPUSH
79889: CALL_OW 311
79893: NOT
79894: PUSH
79895: LD_VAR 0 3
79899: PUSH
79900: LD_EXP 34
79904: PUSH
79905: LD_VAR 0 2
79909: ARRAY
79910: PUSH
79911: LD_INT 1
79913: ARRAY
79914: IN
79915: NOT
79916: AND
79917: PUSH
79918: LD_VAR 0 3
79922: PUSH
79923: LD_EXP 34
79927: PUSH
79928: LD_VAR 0 2
79932: ARRAY
79933: PUSH
79934: LD_INT 2
79936: ARRAY
79937: IN
79938: NOT
79939: AND
79940: IFFALSE 80003
// begin if IsInUnit ( j ) then
79942: LD_VAR 0 3
79946: PPUSH
79947: CALL_OW 310
79951: IFFALSE 79964
// ComExitBuilding ( j ) else
79953: LD_VAR 0 3
79957: PPUSH
79958: CALL_OW 122
79962: GO 80003
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
79964: LD_VAR 0 3
79968: PPUSH
79969: LD_VAR 0 7
79973: PUSH
79974: LD_INT 1
79976: ARRAY
79977: PPUSH
79978: CALL 59241 0 2
79982: NOT
79983: IFFALSE 80003
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
79985: LD_VAR 0 3
79989: PPUSH
79990: LD_VAR 0 7
79994: PUSH
79995: LD_INT 1
79997: ARRAY
79998: PPUSH
79999: CALL_OW 129
// end ; end ;
80003: GO 79827
80005: POP
80006: POP
// end ;
80007: GO 79288
80009: POP
80010: POP
// end ;
80011: LD_VAR 0 1
80015: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
80016: LD_INT 0
80018: PPUSH
80019: PPUSH
80020: PPUSH
80021: PPUSH
80022: PPUSH
80023: PPUSH
80024: PPUSH
80025: PPUSH
80026: PPUSH
80027: PPUSH
80028: PPUSH
// if not mc_bases then
80029: LD_EXP 31
80033: NOT
80034: IFFALSE 80038
// exit ;
80036: GO 80840
// for i = 1 to mc_bases do
80038: LD_ADDR_VAR 0 2
80042: PUSH
80043: DOUBLE
80044: LD_INT 1
80046: DEC
80047: ST_TO_ADDR
80048: LD_EXP 31
80052: PUSH
80053: FOR_TO
80054: IFFALSE 80838
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
80056: LD_EXP 59
80060: PUSH
80061: LD_VAR 0 2
80065: ARRAY
80066: NOT
80067: PUSH
80068: LD_EXP 34
80072: PUSH
80073: LD_VAR 0 2
80077: ARRAY
80078: PUSH
80079: LD_INT 1
80081: ARRAY
80082: OR
80083: PUSH
80084: LD_EXP 34
80088: PUSH
80089: LD_VAR 0 2
80093: ARRAY
80094: PUSH
80095: LD_INT 2
80097: ARRAY
80098: OR
80099: PUSH
80100: LD_EXP 57
80104: PUSH
80105: LD_VAR 0 2
80109: ARRAY
80110: PPUSH
80111: LD_INT 1
80113: PPUSH
80114: CALL_OW 325
80118: NOT
80119: OR
80120: PUSH
80121: LD_EXP 54
80125: PUSH
80126: LD_VAR 0 2
80130: ARRAY
80131: OR
80132: IFFALSE 80136
// continue ;
80134: GO 80053
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80136: LD_ADDR_VAR 0 8
80140: PUSH
80141: LD_EXP 31
80145: PUSH
80146: LD_VAR 0 2
80150: ARRAY
80151: PPUSH
80152: LD_INT 25
80154: PUSH
80155: LD_INT 4
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: LD_INT 50
80164: PUSH
80165: EMPTY
80166: LIST
80167: PUSH
80168: LD_INT 3
80170: PUSH
80171: LD_INT 60
80173: PUSH
80174: EMPTY
80175: LIST
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: LIST
80185: PPUSH
80186: CALL_OW 72
80190: PUSH
80191: LD_EXP 35
80195: PUSH
80196: LD_VAR 0 2
80200: ARRAY
80201: DIFF
80202: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80203: LD_ADDR_VAR 0 9
80207: PUSH
80208: LD_EXP 31
80212: PUSH
80213: LD_VAR 0 2
80217: ARRAY
80218: PPUSH
80219: LD_INT 2
80221: PUSH
80222: LD_INT 30
80224: PUSH
80225: LD_INT 0
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 30
80234: PUSH
80235: LD_INT 1
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: LIST
80246: PPUSH
80247: CALL_OW 72
80251: ST_TO_ADDR
// if not tmp or not dep then
80252: LD_VAR 0 8
80256: NOT
80257: PUSH
80258: LD_VAR 0 9
80262: NOT
80263: OR
80264: IFFALSE 80268
// continue ;
80266: GO 80053
// side := GetSide ( tmp [ 1 ] ) ;
80268: LD_ADDR_VAR 0 11
80272: PUSH
80273: LD_VAR 0 8
80277: PUSH
80278: LD_INT 1
80280: ARRAY
80281: PPUSH
80282: CALL_OW 255
80286: ST_TO_ADDR
// dep := dep [ 1 ] ;
80287: LD_ADDR_VAR 0 9
80291: PUSH
80292: LD_VAR 0 9
80296: PUSH
80297: LD_INT 1
80299: ARRAY
80300: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80301: LD_ADDR_VAR 0 7
80305: PUSH
80306: LD_EXP 59
80310: PUSH
80311: LD_VAR 0 2
80315: ARRAY
80316: PPUSH
80317: LD_INT 22
80319: PUSH
80320: LD_INT 0
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 25
80329: PUSH
80330: LD_INT 12
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PPUSH
80341: CALL_OW 70
80345: PUSH
80346: LD_INT 22
80348: PUSH
80349: LD_INT 0
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 25
80358: PUSH
80359: LD_INT 12
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 91
80368: PUSH
80369: LD_VAR 0 9
80373: PUSH
80374: LD_INT 20
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: LIST
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: LIST
80386: PPUSH
80387: CALL_OW 69
80391: UNION
80392: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80393: LD_ADDR_VAR 0 10
80397: PUSH
80398: LD_EXP 59
80402: PUSH
80403: LD_VAR 0 2
80407: ARRAY
80408: PPUSH
80409: LD_INT 81
80411: PUSH
80412: LD_VAR 0 11
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PPUSH
80421: CALL_OW 70
80425: ST_TO_ADDR
// if not apes or danger_at_area then
80426: LD_VAR 0 7
80430: NOT
80431: PUSH
80432: LD_VAR 0 10
80436: OR
80437: IFFALSE 80487
// begin if mc_taming [ i ] then
80439: LD_EXP 62
80443: PUSH
80444: LD_VAR 0 2
80448: ARRAY
80449: IFFALSE 80485
// begin MC_Reset ( i , 121 ) ;
80451: LD_VAR 0 2
80455: PPUSH
80456: LD_INT 121
80458: PPUSH
80459: CALL 65417 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80463: LD_ADDR_EXP 62
80467: PUSH
80468: LD_EXP 62
80472: PPUSH
80473: LD_VAR 0 2
80477: PPUSH
80478: EMPTY
80479: PPUSH
80480: CALL_OW 1
80484: ST_TO_ADDR
// end ; continue ;
80485: GO 80053
// end ; for j in tmp do
80487: LD_ADDR_VAR 0 3
80491: PUSH
80492: LD_VAR 0 8
80496: PUSH
80497: FOR_IN
80498: IFFALSE 80834
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80500: LD_VAR 0 3
80504: PUSH
80505: LD_EXP 62
80509: PUSH
80510: LD_VAR 0 2
80514: ARRAY
80515: IN
80516: NOT
80517: PUSH
80518: LD_EXP 62
80522: PUSH
80523: LD_VAR 0 2
80527: ARRAY
80528: PUSH
80529: LD_INT 3
80531: LESS
80532: AND
80533: IFFALSE 80591
// begin SetTag ( j , 121 ) ;
80535: LD_VAR 0 3
80539: PPUSH
80540: LD_INT 121
80542: PPUSH
80543: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80547: LD_ADDR_EXP 62
80551: PUSH
80552: LD_EXP 62
80556: PPUSH
80557: LD_VAR 0 2
80561: PUSH
80562: LD_EXP 62
80566: PUSH
80567: LD_VAR 0 2
80571: ARRAY
80572: PUSH
80573: LD_INT 1
80575: PLUS
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PPUSH
80581: LD_VAR 0 3
80585: PPUSH
80586: CALL 24846 0 3
80590: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80591: LD_VAR 0 3
80595: PUSH
80596: LD_EXP 62
80600: PUSH
80601: LD_VAR 0 2
80605: ARRAY
80606: IN
80607: IFFALSE 80832
// begin if GetClass ( j ) <> 4 then
80609: LD_VAR 0 3
80613: PPUSH
80614: CALL_OW 257
80618: PUSH
80619: LD_INT 4
80621: NONEQUAL
80622: IFFALSE 80675
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80624: LD_ADDR_EXP 62
80628: PUSH
80629: LD_EXP 62
80633: PPUSH
80634: LD_VAR 0 2
80638: PPUSH
80639: LD_EXP 62
80643: PUSH
80644: LD_VAR 0 2
80648: ARRAY
80649: PUSH
80650: LD_VAR 0 3
80654: DIFF
80655: PPUSH
80656: CALL_OW 1
80660: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80661: LD_VAR 0 3
80665: PPUSH
80666: LD_INT 0
80668: PPUSH
80669: CALL_OW 109
// continue ;
80673: GO 80497
// end ; if IsInUnit ( j ) then
80675: LD_VAR 0 3
80679: PPUSH
80680: CALL_OW 310
80684: IFFALSE 80695
// ComExitBuilding ( j ) ;
80686: LD_VAR 0 3
80690: PPUSH
80691: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80695: LD_ADDR_VAR 0 6
80699: PUSH
80700: LD_VAR 0 7
80704: PPUSH
80705: LD_VAR 0 3
80709: PPUSH
80710: CALL_OW 74
80714: ST_TO_ADDR
// if not ape then
80715: LD_VAR 0 6
80719: NOT
80720: IFFALSE 80724
// break ;
80722: GO 80834
// x := GetX ( ape ) ;
80724: LD_ADDR_VAR 0 4
80728: PUSH
80729: LD_VAR 0 6
80733: PPUSH
80734: CALL_OW 250
80738: ST_TO_ADDR
// y := GetY ( ape ) ;
80739: LD_ADDR_VAR 0 5
80743: PUSH
80744: LD_VAR 0 6
80748: PPUSH
80749: CALL_OW 251
80753: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80754: LD_VAR 0 4
80758: PPUSH
80759: LD_VAR 0 5
80763: PPUSH
80764: CALL_OW 488
80768: NOT
80769: PUSH
80770: LD_VAR 0 11
80774: PPUSH
80775: LD_VAR 0 4
80779: PPUSH
80780: LD_VAR 0 5
80784: PPUSH
80785: LD_INT 20
80787: PPUSH
80788: CALL 25742 0 4
80792: PUSH
80793: LD_INT 4
80795: ARRAY
80796: OR
80797: IFFALSE 80801
// break ;
80799: GO 80834
// if not HasTask ( j ) then
80801: LD_VAR 0 3
80805: PPUSH
80806: CALL_OW 314
80810: NOT
80811: IFFALSE 80832
// ComTameXY ( j , x , y ) ;
80813: LD_VAR 0 3
80817: PPUSH
80818: LD_VAR 0 4
80822: PPUSH
80823: LD_VAR 0 5
80827: PPUSH
80828: CALL_OW 131
// end ; end ;
80832: GO 80497
80834: POP
80835: POP
// end ;
80836: GO 80053
80838: POP
80839: POP
// end ;
80840: LD_VAR 0 1
80844: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80845: LD_INT 0
80847: PPUSH
80848: PPUSH
80849: PPUSH
80850: PPUSH
80851: PPUSH
80852: PPUSH
80853: PPUSH
80854: PPUSH
// if not mc_bases then
80855: LD_EXP 31
80859: NOT
80860: IFFALSE 80864
// exit ;
80862: GO 81490
// for i = 1 to mc_bases do
80864: LD_ADDR_VAR 0 2
80868: PUSH
80869: DOUBLE
80870: LD_INT 1
80872: DEC
80873: ST_TO_ADDR
80874: LD_EXP 31
80878: PUSH
80879: FOR_TO
80880: IFFALSE 81488
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80882: LD_EXP 60
80886: PUSH
80887: LD_VAR 0 2
80891: ARRAY
80892: NOT
80893: PUSH
80894: LD_EXP 60
80898: PUSH
80899: LD_VAR 0 2
80903: ARRAY
80904: PPUSH
80905: LD_INT 25
80907: PUSH
80908: LD_INT 12
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PPUSH
80915: CALL_OW 72
80919: NOT
80920: OR
80921: IFFALSE 80925
// continue ;
80923: GO 80879
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80925: LD_ADDR_VAR 0 5
80929: PUSH
80930: LD_EXP 60
80934: PUSH
80935: LD_VAR 0 2
80939: ARRAY
80940: PUSH
80941: LD_INT 1
80943: ARRAY
80944: PPUSH
80945: CALL_OW 255
80949: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80950: LD_VAR 0 5
80954: PPUSH
80955: LD_INT 2
80957: PPUSH
80958: CALL_OW 325
80962: IFFALSE 81215
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80964: LD_ADDR_VAR 0 4
80968: PUSH
80969: LD_EXP 60
80973: PUSH
80974: LD_VAR 0 2
80978: ARRAY
80979: PPUSH
80980: LD_INT 25
80982: PUSH
80983: LD_INT 16
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: PPUSH
80990: CALL_OW 72
80994: ST_TO_ADDR
// if tmp < 6 then
80995: LD_VAR 0 4
80999: PUSH
81000: LD_INT 6
81002: LESS
81003: IFFALSE 81215
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81005: LD_ADDR_VAR 0 6
81009: PUSH
81010: LD_EXP 31
81014: PUSH
81015: LD_VAR 0 2
81019: ARRAY
81020: PPUSH
81021: LD_INT 2
81023: PUSH
81024: LD_INT 30
81026: PUSH
81027: LD_INT 0
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: LD_INT 30
81036: PUSH
81037: LD_INT 1
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: LIST
81048: PPUSH
81049: CALL_OW 72
81053: ST_TO_ADDR
// if depot then
81054: LD_VAR 0 6
81058: IFFALSE 81215
// begin selected := 0 ;
81060: LD_ADDR_VAR 0 7
81064: PUSH
81065: LD_INT 0
81067: ST_TO_ADDR
// for j in depot do
81068: LD_ADDR_VAR 0 3
81072: PUSH
81073: LD_VAR 0 6
81077: PUSH
81078: FOR_IN
81079: IFFALSE 81110
// begin if UnitsInside ( j ) < 6 then
81081: LD_VAR 0 3
81085: PPUSH
81086: CALL_OW 313
81090: PUSH
81091: LD_INT 6
81093: LESS
81094: IFFALSE 81108
// begin selected := j ;
81096: LD_ADDR_VAR 0 7
81100: PUSH
81101: LD_VAR 0 3
81105: ST_TO_ADDR
// break ;
81106: GO 81110
// end ; end ;
81108: GO 81078
81110: POP
81111: POP
// if selected then
81112: LD_VAR 0 7
81116: IFFALSE 81215
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81118: LD_ADDR_VAR 0 3
81122: PUSH
81123: LD_EXP 60
81127: PUSH
81128: LD_VAR 0 2
81132: ARRAY
81133: PPUSH
81134: LD_INT 25
81136: PUSH
81137: LD_INT 12
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PPUSH
81144: CALL_OW 72
81148: PUSH
81149: FOR_IN
81150: IFFALSE 81213
// if not HasTask ( j ) then
81152: LD_VAR 0 3
81156: PPUSH
81157: CALL_OW 314
81161: NOT
81162: IFFALSE 81211
// begin if not IsInUnit ( j ) then
81164: LD_VAR 0 3
81168: PPUSH
81169: CALL_OW 310
81173: NOT
81174: IFFALSE 81190
// ComEnterUnit ( j , selected ) ;
81176: LD_VAR 0 3
81180: PPUSH
81181: LD_VAR 0 7
81185: PPUSH
81186: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81190: LD_VAR 0 3
81194: PPUSH
81195: LD_INT 16
81197: PPUSH
81198: CALL_OW 183
// AddComExitBuilding ( j ) ;
81202: LD_VAR 0 3
81206: PPUSH
81207: CALL_OW 182
// end ;
81211: GO 81149
81213: POP
81214: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81215: LD_VAR 0 5
81219: PPUSH
81220: LD_INT 11
81222: PPUSH
81223: CALL_OW 325
81227: IFFALSE 81486
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81229: LD_ADDR_VAR 0 4
81233: PUSH
81234: LD_EXP 60
81238: PUSH
81239: LD_VAR 0 2
81243: ARRAY
81244: PPUSH
81245: LD_INT 25
81247: PUSH
81248: LD_INT 16
81250: PUSH
81251: EMPTY
81252: LIST
81253: LIST
81254: PPUSH
81255: CALL_OW 72
81259: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81260: LD_VAR 0 4
81264: PUSH
81265: LD_INT 6
81267: GREATEREQUAL
81268: PUSH
81269: LD_VAR 0 5
81273: PPUSH
81274: LD_INT 2
81276: PPUSH
81277: CALL_OW 325
81281: NOT
81282: OR
81283: IFFALSE 81486
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81285: LD_ADDR_VAR 0 8
81289: PUSH
81290: LD_EXP 31
81294: PUSH
81295: LD_VAR 0 2
81299: ARRAY
81300: PPUSH
81301: LD_INT 2
81303: PUSH
81304: LD_INT 30
81306: PUSH
81307: LD_INT 4
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 30
81316: PUSH
81317: LD_INT 5
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: LIST
81328: PPUSH
81329: CALL_OW 72
81333: ST_TO_ADDR
// if barracks then
81334: LD_VAR 0 8
81338: IFFALSE 81486
// begin selected := 0 ;
81340: LD_ADDR_VAR 0 7
81344: PUSH
81345: LD_INT 0
81347: ST_TO_ADDR
// for j in barracks do
81348: LD_ADDR_VAR 0 3
81352: PUSH
81353: LD_VAR 0 8
81357: PUSH
81358: FOR_IN
81359: IFFALSE 81390
// begin if UnitsInside ( j ) < 6 then
81361: LD_VAR 0 3
81365: PPUSH
81366: CALL_OW 313
81370: PUSH
81371: LD_INT 6
81373: LESS
81374: IFFALSE 81388
// begin selected := j ;
81376: LD_ADDR_VAR 0 7
81380: PUSH
81381: LD_VAR 0 3
81385: ST_TO_ADDR
// break ;
81386: GO 81390
// end ; end ;
81388: GO 81358
81390: POP
81391: POP
// if selected then
81392: LD_VAR 0 7
81396: IFFALSE 81486
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81398: LD_ADDR_VAR 0 3
81402: PUSH
81403: LD_EXP 60
81407: PUSH
81408: LD_VAR 0 2
81412: ARRAY
81413: PPUSH
81414: LD_INT 25
81416: PUSH
81417: LD_INT 12
81419: PUSH
81420: EMPTY
81421: LIST
81422: LIST
81423: PPUSH
81424: CALL_OW 72
81428: PUSH
81429: FOR_IN
81430: IFFALSE 81484
// if not IsInUnit ( j ) and not HasTask ( j ) then
81432: LD_VAR 0 3
81436: PPUSH
81437: CALL_OW 310
81441: NOT
81442: PUSH
81443: LD_VAR 0 3
81447: PPUSH
81448: CALL_OW 314
81452: NOT
81453: AND
81454: IFFALSE 81482
// begin ComEnterUnit ( j , selected ) ;
81456: LD_VAR 0 3
81460: PPUSH
81461: LD_VAR 0 7
81465: PPUSH
81466: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81470: LD_VAR 0 3
81474: PPUSH
81475: LD_INT 15
81477: PPUSH
81478: CALL_OW 183
// end ;
81482: GO 81429
81484: POP
81485: POP
// end ; end ; end ; end ; end ;
81486: GO 80879
81488: POP
81489: POP
// end ;
81490: LD_VAR 0 1
81494: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81495: LD_INT 0
81497: PPUSH
81498: PPUSH
81499: PPUSH
81500: PPUSH
// if not mc_bases then
81501: LD_EXP 31
81505: NOT
81506: IFFALSE 81510
// exit ;
81508: GO 81688
// for i = 1 to mc_bases do
81510: LD_ADDR_VAR 0 2
81514: PUSH
81515: DOUBLE
81516: LD_INT 1
81518: DEC
81519: ST_TO_ADDR
81520: LD_EXP 31
81524: PUSH
81525: FOR_TO
81526: IFFALSE 81686
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81528: LD_ADDR_VAR 0 4
81532: PUSH
81533: LD_EXP 31
81537: PUSH
81538: LD_VAR 0 2
81542: ARRAY
81543: PPUSH
81544: LD_INT 25
81546: PUSH
81547: LD_INT 9
81549: PUSH
81550: EMPTY
81551: LIST
81552: LIST
81553: PPUSH
81554: CALL_OW 72
81558: ST_TO_ADDR
// if not tmp then
81559: LD_VAR 0 4
81563: NOT
81564: IFFALSE 81568
// continue ;
81566: GO 81525
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81568: LD_EXP 57
81572: PUSH
81573: LD_VAR 0 2
81577: ARRAY
81578: PPUSH
81579: LD_INT 29
81581: PPUSH
81582: CALL_OW 325
81586: NOT
81587: PUSH
81588: LD_EXP 57
81592: PUSH
81593: LD_VAR 0 2
81597: ARRAY
81598: PPUSH
81599: LD_INT 28
81601: PPUSH
81602: CALL_OW 325
81606: NOT
81607: AND
81608: IFFALSE 81612
// continue ;
81610: GO 81525
// for j in tmp do
81612: LD_ADDR_VAR 0 3
81616: PUSH
81617: LD_VAR 0 4
81621: PUSH
81622: FOR_IN
81623: IFFALSE 81682
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81625: LD_VAR 0 3
81629: PUSH
81630: LD_EXP 34
81634: PUSH
81635: LD_VAR 0 2
81639: ARRAY
81640: PUSH
81641: LD_INT 1
81643: ARRAY
81644: IN
81645: NOT
81646: PUSH
81647: LD_VAR 0 3
81651: PUSH
81652: LD_EXP 34
81656: PUSH
81657: LD_VAR 0 2
81661: ARRAY
81662: PUSH
81663: LD_INT 2
81665: ARRAY
81666: IN
81667: NOT
81668: AND
81669: IFFALSE 81680
// ComSpaceTimeShoot ( j ) ;
81671: LD_VAR 0 3
81675: PPUSH
81676: CALL 20831 0 1
81680: GO 81622
81682: POP
81683: POP
// end ;
81684: GO 81525
81686: POP
81687: POP
// end ;
81688: LD_VAR 0 1
81692: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81693: LD_INT 0
81695: PPUSH
81696: PPUSH
81697: PPUSH
81698: PPUSH
81699: PPUSH
81700: PPUSH
81701: PPUSH
81702: PPUSH
81703: PPUSH
// if not mc_bases then
81704: LD_EXP 31
81708: NOT
81709: IFFALSE 81713
// exit ;
81711: GO 82335
// for i = 1 to mc_bases do
81713: LD_ADDR_VAR 0 2
81717: PUSH
81718: DOUBLE
81719: LD_INT 1
81721: DEC
81722: ST_TO_ADDR
81723: LD_EXP 31
81727: PUSH
81728: FOR_TO
81729: IFFALSE 82333
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81731: LD_EXP 66
81735: PUSH
81736: LD_VAR 0 2
81740: ARRAY
81741: NOT
81742: PUSH
81743: LD_INT 38
81745: PPUSH
81746: LD_EXP 57
81750: PUSH
81751: LD_VAR 0 2
81755: ARRAY
81756: PPUSH
81757: CALL_OW 321
81761: PUSH
81762: LD_INT 2
81764: NONEQUAL
81765: OR
81766: IFFALSE 81770
// continue ;
81768: GO 81728
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81770: LD_ADDR_VAR 0 8
81774: PUSH
81775: LD_EXP 31
81779: PUSH
81780: LD_VAR 0 2
81784: ARRAY
81785: PPUSH
81786: LD_INT 30
81788: PUSH
81789: LD_INT 34
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PPUSH
81796: CALL_OW 72
81800: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81801: LD_ADDR_VAR 0 9
81805: PUSH
81806: LD_EXP 31
81810: PUSH
81811: LD_VAR 0 2
81815: ARRAY
81816: PPUSH
81817: LD_INT 25
81819: PUSH
81820: LD_INT 4
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PPUSH
81827: CALL_OW 72
81831: PPUSH
81832: LD_INT 0
81834: PPUSH
81835: CALL 54758 0 2
81839: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81840: LD_VAR 0 9
81844: NOT
81845: PUSH
81846: LD_VAR 0 8
81850: NOT
81851: OR
81852: PUSH
81853: LD_EXP 31
81857: PUSH
81858: LD_VAR 0 2
81862: ARRAY
81863: PPUSH
81864: LD_INT 124
81866: PPUSH
81867: CALL 54758 0 2
81871: OR
81872: IFFALSE 81876
// continue ;
81874: GO 81728
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81876: LD_EXP 67
81880: PUSH
81881: LD_VAR 0 2
81885: ARRAY
81886: PUSH
81887: LD_EXP 66
81891: PUSH
81892: LD_VAR 0 2
81896: ARRAY
81897: LESS
81898: PUSH
81899: LD_EXP 67
81903: PUSH
81904: LD_VAR 0 2
81908: ARRAY
81909: PUSH
81910: LD_VAR 0 8
81914: LESS
81915: AND
81916: IFFALSE 82331
// begin tmp := sci [ 1 ] ;
81918: LD_ADDR_VAR 0 7
81922: PUSH
81923: LD_VAR 0 9
81927: PUSH
81928: LD_INT 1
81930: ARRAY
81931: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81932: LD_VAR 0 7
81936: PPUSH
81937: LD_INT 124
81939: PPUSH
81940: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81944: LD_ADDR_VAR 0 3
81948: PUSH
81949: DOUBLE
81950: LD_EXP 66
81954: PUSH
81955: LD_VAR 0 2
81959: ARRAY
81960: INC
81961: ST_TO_ADDR
81962: LD_EXP 66
81966: PUSH
81967: LD_VAR 0 2
81971: ARRAY
81972: PUSH
81973: FOR_DOWNTO
81974: IFFALSE 82317
// begin if IsInUnit ( tmp ) then
81976: LD_VAR 0 7
81980: PPUSH
81981: CALL_OW 310
81985: IFFALSE 81996
// ComExitBuilding ( tmp ) ;
81987: LD_VAR 0 7
81991: PPUSH
81992: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
81996: LD_INT 35
81998: PPUSH
81999: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
82003: LD_VAR 0 7
82007: PPUSH
82008: CALL_OW 310
82012: NOT
82013: PUSH
82014: LD_VAR 0 7
82018: PPUSH
82019: CALL_OW 314
82023: NOT
82024: AND
82025: IFFALSE 81996
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
82027: LD_ADDR_VAR 0 6
82031: PUSH
82032: LD_VAR 0 7
82036: PPUSH
82037: CALL_OW 250
82041: PUSH
82042: LD_VAR 0 7
82046: PPUSH
82047: CALL_OW 251
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
82056: LD_INT 35
82058: PPUSH
82059: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82063: LD_ADDR_VAR 0 4
82067: PUSH
82068: LD_EXP 66
82072: PUSH
82073: LD_VAR 0 2
82077: ARRAY
82078: PUSH
82079: LD_VAR 0 3
82083: ARRAY
82084: PUSH
82085: LD_INT 1
82087: ARRAY
82088: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82089: LD_ADDR_VAR 0 5
82093: PUSH
82094: LD_EXP 66
82098: PUSH
82099: LD_VAR 0 2
82103: ARRAY
82104: PUSH
82105: LD_VAR 0 3
82109: ARRAY
82110: PUSH
82111: LD_INT 2
82113: ARRAY
82114: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82115: LD_VAR 0 7
82119: PPUSH
82120: LD_INT 10
82122: PPUSH
82123: CALL 27443 0 2
82127: PUSH
82128: LD_INT 4
82130: ARRAY
82131: IFFALSE 82169
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82133: LD_VAR 0 7
82137: PPUSH
82138: LD_VAR 0 6
82142: PUSH
82143: LD_INT 1
82145: ARRAY
82146: PPUSH
82147: LD_VAR 0 6
82151: PUSH
82152: LD_INT 2
82154: ARRAY
82155: PPUSH
82156: CALL_OW 111
// wait ( 0 0$10 ) ;
82160: LD_INT 350
82162: PPUSH
82163: CALL_OW 67
// end else
82167: GO 82195
// begin ComMoveXY ( tmp , x , y ) ;
82169: LD_VAR 0 7
82173: PPUSH
82174: LD_VAR 0 4
82178: PPUSH
82179: LD_VAR 0 5
82183: PPUSH
82184: CALL_OW 111
// wait ( 0 0$3 ) ;
82188: LD_INT 105
82190: PPUSH
82191: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82195: LD_VAR 0 7
82199: PPUSH
82200: LD_VAR 0 4
82204: PPUSH
82205: LD_VAR 0 5
82209: PPUSH
82210: CALL_OW 307
82214: IFFALSE 82056
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82216: LD_VAR 0 7
82220: PPUSH
82221: LD_VAR 0 4
82225: PPUSH
82226: LD_VAR 0 5
82230: PPUSH
82231: LD_VAR 0 8
82235: PUSH
82236: LD_VAR 0 3
82240: ARRAY
82241: PPUSH
82242: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82246: LD_INT 35
82248: PPUSH
82249: CALL_OW 67
// until not HasTask ( tmp ) ;
82253: LD_VAR 0 7
82257: PPUSH
82258: CALL_OW 314
82262: NOT
82263: IFFALSE 82246
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82265: LD_ADDR_EXP 67
82269: PUSH
82270: LD_EXP 67
82274: PPUSH
82275: LD_VAR 0 2
82279: PUSH
82280: LD_EXP 67
82284: PUSH
82285: LD_VAR 0 2
82289: ARRAY
82290: PUSH
82291: LD_INT 1
82293: PLUS
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PPUSH
82299: LD_VAR 0 8
82303: PUSH
82304: LD_VAR 0 3
82308: ARRAY
82309: PPUSH
82310: CALL 24846 0 3
82314: ST_TO_ADDR
// end ;
82315: GO 81973
82317: POP
82318: POP
// MC_Reset ( i , 124 ) ;
82319: LD_VAR 0 2
82323: PPUSH
82324: LD_INT 124
82326: PPUSH
82327: CALL 65417 0 2
// end ; end ;
82331: GO 81728
82333: POP
82334: POP
// end ;
82335: LD_VAR 0 1
82339: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82340: LD_INT 0
82342: PPUSH
82343: PPUSH
82344: PPUSH
// if not mc_bases then
82345: LD_EXP 31
82349: NOT
82350: IFFALSE 82354
// exit ;
82352: GO 82960
// for i = 1 to mc_bases do
82354: LD_ADDR_VAR 0 2
82358: PUSH
82359: DOUBLE
82360: LD_INT 1
82362: DEC
82363: ST_TO_ADDR
82364: LD_EXP 31
82368: PUSH
82369: FOR_TO
82370: IFFALSE 82958
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82372: LD_ADDR_VAR 0 3
82376: PUSH
82377: LD_EXP 31
82381: PUSH
82382: LD_VAR 0 2
82386: ARRAY
82387: PPUSH
82388: LD_INT 25
82390: PUSH
82391: LD_INT 4
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PPUSH
82398: CALL_OW 72
82402: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82403: LD_VAR 0 3
82407: NOT
82408: PUSH
82409: LD_EXP 68
82413: PUSH
82414: LD_VAR 0 2
82418: ARRAY
82419: NOT
82420: OR
82421: PUSH
82422: LD_EXP 31
82426: PUSH
82427: LD_VAR 0 2
82431: ARRAY
82432: PPUSH
82433: LD_INT 2
82435: PUSH
82436: LD_INT 30
82438: PUSH
82439: LD_INT 0
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 30
82448: PUSH
82449: LD_INT 1
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: LIST
82460: PPUSH
82461: CALL_OW 72
82465: NOT
82466: OR
82467: IFFALSE 82517
// begin if mc_deposits_finder [ i ] then
82469: LD_EXP 69
82473: PUSH
82474: LD_VAR 0 2
82478: ARRAY
82479: IFFALSE 82515
// begin MC_Reset ( i , 125 ) ;
82481: LD_VAR 0 2
82485: PPUSH
82486: LD_INT 125
82488: PPUSH
82489: CALL 65417 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82493: LD_ADDR_EXP 69
82497: PUSH
82498: LD_EXP 69
82502: PPUSH
82503: LD_VAR 0 2
82507: PPUSH
82508: EMPTY
82509: PPUSH
82510: CALL_OW 1
82514: ST_TO_ADDR
// end ; continue ;
82515: GO 82369
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82517: LD_EXP 68
82521: PUSH
82522: LD_VAR 0 2
82526: ARRAY
82527: PUSH
82528: LD_INT 1
82530: ARRAY
82531: PUSH
82532: LD_INT 3
82534: ARRAY
82535: PUSH
82536: LD_INT 1
82538: EQUAL
82539: PUSH
82540: LD_INT 20
82542: PPUSH
82543: LD_EXP 57
82547: PUSH
82548: LD_VAR 0 2
82552: ARRAY
82553: PPUSH
82554: CALL_OW 321
82558: PUSH
82559: LD_INT 2
82561: NONEQUAL
82562: AND
82563: IFFALSE 82613
// begin if mc_deposits_finder [ i ] then
82565: LD_EXP 69
82569: PUSH
82570: LD_VAR 0 2
82574: ARRAY
82575: IFFALSE 82611
// begin MC_Reset ( i , 125 ) ;
82577: LD_VAR 0 2
82581: PPUSH
82582: LD_INT 125
82584: PPUSH
82585: CALL 65417 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82589: LD_ADDR_EXP 69
82593: PUSH
82594: LD_EXP 69
82598: PPUSH
82599: LD_VAR 0 2
82603: PPUSH
82604: EMPTY
82605: PPUSH
82606: CALL_OW 1
82610: ST_TO_ADDR
// end ; continue ;
82611: GO 82369
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82613: LD_EXP 68
82617: PUSH
82618: LD_VAR 0 2
82622: ARRAY
82623: PUSH
82624: LD_INT 1
82626: ARRAY
82627: PUSH
82628: LD_INT 1
82630: ARRAY
82631: PPUSH
82632: LD_EXP 68
82636: PUSH
82637: LD_VAR 0 2
82641: ARRAY
82642: PUSH
82643: LD_INT 1
82645: ARRAY
82646: PUSH
82647: LD_INT 2
82649: ARRAY
82650: PPUSH
82651: LD_EXP 57
82655: PUSH
82656: LD_VAR 0 2
82660: ARRAY
82661: PPUSH
82662: CALL_OW 440
82666: IFFALSE 82709
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82668: LD_ADDR_EXP 68
82672: PUSH
82673: LD_EXP 68
82677: PPUSH
82678: LD_VAR 0 2
82682: PPUSH
82683: LD_EXP 68
82687: PUSH
82688: LD_VAR 0 2
82692: ARRAY
82693: PPUSH
82694: LD_INT 1
82696: PPUSH
82697: CALL_OW 3
82701: PPUSH
82702: CALL_OW 1
82706: ST_TO_ADDR
82707: GO 82956
// begin if not mc_deposits_finder [ i ] then
82709: LD_EXP 69
82713: PUSH
82714: LD_VAR 0 2
82718: ARRAY
82719: NOT
82720: IFFALSE 82772
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82722: LD_ADDR_EXP 69
82726: PUSH
82727: LD_EXP 69
82731: PPUSH
82732: LD_VAR 0 2
82736: PPUSH
82737: LD_VAR 0 3
82741: PUSH
82742: LD_INT 1
82744: ARRAY
82745: PUSH
82746: EMPTY
82747: LIST
82748: PPUSH
82749: CALL_OW 1
82753: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82754: LD_VAR 0 3
82758: PUSH
82759: LD_INT 1
82761: ARRAY
82762: PPUSH
82763: LD_INT 125
82765: PPUSH
82766: CALL_OW 109
// end else
82770: GO 82956
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82772: LD_EXP 69
82776: PUSH
82777: LD_VAR 0 2
82781: ARRAY
82782: PUSH
82783: LD_INT 1
82785: ARRAY
82786: PPUSH
82787: CALL_OW 310
82791: IFFALSE 82814
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82793: LD_EXP 69
82797: PUSH
82798: LD_VAR 0 2
82802: ARRAY
82803: PUSH
82804: LD_INT 1
82806: ARRAY
82807: PPUSH
82808: CALL_OW 122
82812: GO 82956
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82814: LD_EXP 69
82818: PUSH
82819: LD_VAR 0 2
82823: ARRAY
82824: PUSH
82825: LD_INT 1
82827: ARRAY
82828: PPUSH
82829: CALL_OW 314
82833: NOT
82834: PUSH
82835: LD_EXP 69
82839: PUSH
82840: LD_VAR 0 2
82844: ARRAY
82845: PUSH
82846: LD_INT 1
82848: ARRAY
82849: PPUSH
82850: LD_EXP 68
82854: PUSH
82855: LD_VAR 0 2
82859: ARRAY
82860: PUSH
82861: LD_INT 1
82863: ARRAY
82864: PUSH
82865: LD_INT 1
82867: ARRAY
82868: PPUSH
82869: LD_EXP 68
82873: PUSH
82874: LD_VAR 0 2
82878: ARRAY
82879: PUSH
82880: LD_INT 1
82882: ARRAY
82883: PUSH
82884: LD_INT 2
82886: ARRAY
82887: PPUSH
82888: CALL_OW 297
82892: PUSH
82893: LD_INT 6
82895: GREATER
82896: AND
82897: IFFALSE 82956
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82899: LD_EXP 69
82903: PUSH
82904: LD_VAR 0 2
82908: ARRAY
82909: PUSH
82910: LD_INT 1
82912: ARRAY
82913: PPUSH
82914: LD_EXP 68
82918: PUSH
82919: LD_VAR 0 2
82923: ARRAY
82924: PUSH
82925: LD_INT 1
82927: ARRAY
82928: PUSH
82929: LD_INT 1
82931: ARRAY
82932: PPUSH
82933: LD_EXP 68
82937: PUSH
82938: LD_VAR 0 2
82942: ARRAY
82943: PUSH
82944: LD_INT 1
82946: ARRAY
82947: PUSH
82948: LD_INT 2
82950: ARRAY
82951: PPUSH
82952: CALL_OW 111
// end ; end ; end ;
82956: GO 82369
82958: POP
82959: POP
// end ;
82960: LD_VAR 0 1
82964: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
82965: LD_INT 0
82967: PPUSH
82968: PPUSH
82969: PPUSH
82970: PPUSH
82971: PPUSH
82972: PPUSH
82973: PPUSH
82974: PPUSH
82975: PPUSH
82976: PPUSH
82977: PPUSH
// if not mc_bases then
82978: LD_EXP 31
82982: NOT
82983: IFFALSE 82987
// exit ;
82985: GO 83927
// for i = 1 to mc_bases do
82987: LD_ADDR_VAR 0 2
82991: PUSH
82992: DOUBLE
82993: LD_INT 1
82995: DEC
82996: ST_TO_ADDR
82997: LD_EXP 31
83001: PUSH
83002: FOR_TO
83003: IFFALSE 83925
// begin if not mc_bases [ i ] or mc_scan [ i ] then
83005: LD_EXP 31
83009: PUSH
83010: LD_VAR 0 2
83014: ARRAY
83015: NOT
83016: PUSH
83017: LD_EXP 54
83021: PUSH
83022: LD_VAR 0 2
83026: ARRAY
83027: OR
83028: IFFALSE 83032
// continue ;
83030: GO 83002
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
83032: LD_ADDR_VAR 0 7
83036: PUSH
83037: LD_EXP 31
83041: PUSH
83042: LD_VAR 0 2
83046: ARRAY
83047: PUSH
83048: LD_INT 1
83050: ARRAY
83051: PPUSH
83052: CALL_OW 248
83056: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83057: LD_VAR 0 7
83061: PUSH
83062: LD_INT 3
83064: EQUAL
83065: PUSH
83066: LD_EXP 50
83070: PUSH
83071: LD_VAR 0 2
83075: ARRAY
83076: PUSH
83077: LD_EXP 53
83081: PUSH
83082: LD_VAR 0 2
83086: ARRAY
83087: UNION
83088: PPUSH
83089: LD_INT 33
83091: PUSH
83092: LD_INT 2
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PPUSH
83099: CALL_OW 72
83103: NOT
83104: OR
83105: IFFALSE 83109
// continue ;
83107: GO 83002
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83109: LD_ADDR_VAR 0 9
83113: PUSH
83114: LD_EXP 31
83118: PUSH
83119: LD_VAR 0 2
83123: ARRAY
83124: PPUSH
83125: LD_INT 30
83127: PUSH
83128: LD_INT 36
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PPUSH
83135: CALL_OW 72
83139: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83140: LD_ADDR_VAR 0 10
83144: PUSH
83145: LD_EXP 50
83149: PUSH
83150: LD_VAR 0 2
83154: ARRAY
83155: PPUSH
83156: LD_INT 34
83158: PUSH
83159: LD_INT 31
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PPUSH
83166: CALL_OW 72
83170: ST_TO_ADDR
// if not cts and not mcts then
83171: LD_VAR 0 9
83175: NOT
83176: PUSH
83177: LD_VAR 0 10
83181: NOT
83182: AND
83183: IFFALSE 83187
// continue ;
83185: GO 83002
// x := cts ;
83187: LD_ADDR_VAR 0 11
83191: PUSH
83192: LD_VAR 0 9
83196: ST_TO_ADDR
// if not x then
83197: LD_VAR 0 11
83201: NOT
83202: IFFALSE 83214
// x := mcts ;
83204: LD_ADDR_VAR 0 11
83208: PUSH
83209: LD_VAR 0 10
83213: ST_TO_ADDR
// if not x then
83214: LD_VAR 0 11
83218: NOT
83219: IFFALSE 83223
// continue ;
83221: GO 83002
// if mc_remote_driver [ i ] then
83223: LD_EXP 71
83227: PUSH
83228: LD_VAR 0 2
83232: ARRAY
83233: IFFALSE 83620
// for j in mc_remote_driver [ i ] do
83235: LD_ADDR_VAR 0 3
83239: PUSH
83240: LD_EXP 71
83244: PUSH
83245: LD_VAR 0 2
83249: ARRAY
83250: PUSH
83251: FOR_IN
83252: IFFALSE 83618
// begin if GetClass ( j ) <> 3 then
83254: LD_VAR 0 3
83258: PPUSH
83259: CALL_OW 257
83263: PUSH
83264: LD_INT 3
83266: NONEQUAL
83267: IFFALSE 83320
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83269: LD_ADDR_EXP 71
83273: PUSH
83274: LD_EXP 71
83278: PPUSH
83279: LD_VAR 0 2
83283: PPUSH
83284: LD_EXP 71
83288: PUSH
83289: LD_VAR 0 2
83293: ARRAY
83294: PUSH
83295: LD_VAR 0 3
83299: DIFF
83300: PPUSH
83301: CALL_OW 1
83305: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83306: LD_VAR 0 3
83310: PPUSH
83311: LD_INT 0
83313: PPUSH
83314: CALL_OW 109
// continue ;
83318: GO 83251
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83320: LD_EXP 50
83324: PUSH
83325: LD_VAR 0 2
83329: ARRAY
83330: PPUSH
83331: LD_INT 34
83333: PUSH
83334: LD_INT 31
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 58
83343: PUSH
83344: EMPTY
83345: LIST
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PPUSH
83351: CALL_OW 72
83355: PUSH
83356: LD_VAR 0 3
83360: PPUSH
83361: CALL 54793 0 1
83365: NOT
83366: AND
83367: IFFALSE 83438
// begin if IsInUnit ( j ) then
83369: LD_VAR 0 3
83373: PPUSH
83374: CALL_OW 310
83378: IFFALSE 83389
// ComExitBuilding ( j ) ;
83380: LD_VAR 0 3
83384: PPUSH
83385: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83389: LD_VAR 0 3
83393: PPUSH
83394: LD_EXP 50
83398: PUSH
83399: LD_VAR 0 2
83403: ARRAY
83404: PPUSH
83405: LD_INT 34
83407: PUSH
83408: LD_INT 31
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 58
83417: PUSH
83418: EMPTY
83419: LIST
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PPUSH
83425: CALL_OW 72
83429: PUSH
83430: LD_INT 1
83432: ARRAY
83433: PPUSH
83434: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83438: LD_VAR 0 3
83442: PPUSH
83443: CALL_OW 310
83447: NOT
83448: PUSH
83449: LD_VAR 0 3
83453: PPUSH
83454: CALL_OW 310
83458: PPUSH
83459: CALL_OW 266
83463: PUSH
83464: LD_INT 36
83466: NONEQUAL
83467: PUSH
83468: LD_VAR 0 3
83472: PPUSH
83473: CALL 54793 0 1
83477: NOT
83478: AND
83479: OR
83480: IFFALSE 83616
// begin if IsInUnit ( j ) then
83482: LD_VAR 0 3
83486: PPUSH
83487: CALL_OW 310
83491: IFFALSE 83502
// ComExitBuilding ( j ) ;
83493: LD_VAR 0 3
83497: PPUSH
83498: CALL_OW 122
// ct := 0 ;
83502: LD_ADDR_VAR 0 8
83506: PUSH
83507: LD_INT 0
83509: ST_TO_ADDR
// for k in x do
83510: LD_ADDR_VAR 0 4
83514: PUSH
83515: LD_VAR 0 11
83519: PUSH
83520: FOR_IN
83521: IFFALSE 83594
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83523: LD_VAR 0 4
83527: PPUSH
83528: CALL_OW 264
83532: PUSH
83533: LD_INT 31
83535: EQUAL
83536: PUSH
83537: LD_VAR 0 4
83541: PPUSH
83542: CALL_OW 311
83546: NOT
83547: AND
83548: PUSH
83549: LD_VAR 0 4
83553: PPUSH
83554: CALL_OW 266
83558: PUSH
83559: LD_INT 36
83561: EQUAL
83562: PUSH
83563: LD_VAR 0 4
83567: PPUSH
83568: CALL_OW 313
83572: PUSH
83573: LD_INT 3
83575: LESS
83576: AND
83577: OR
83578: IFFALSE 83592
// begin ct := k ;
83580: LD_ADDR_VAR 0 8
83584: PUSH
83585: LD_VAR 0 4
83589: ST_TO_ADDR
// break ;
83590: GO 83594
// end ;
83592: GO 83520
83594: POP
83595: POP
// if ct then
83596: LD_VAR 0 8
83600: IFFALSE 83616
// ComEnterUnit ( j , ct ) ;
83602: LD_VAR 0 3
83606: PPUSH
83607: LD_VAR 0 8
83611: PPUSH
83612: CALL_OW 120
// end ; end ;
83616: GO 83251
83618: POP
83619: POP
// places := 0 ;
83620: LD_ADDR_VAR 0 5
83624: PUSH
83625: LD_INT 0
83627: ST_TO_ADDR
// for j = 1 to x do
83628: LD_ADDR_VAR 0 3
83632: PUSH
83633: DOUBLE
83634: LD_INT 1
83636: DEC
83637: ST_TO_ADDR
83638: LD_VAR 0 11
83642: PUSH
83643: FOR_TO
83644: IFFALSE 83720
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83646: LD_VAR 0 11
83650: PUSH
83651: LD_VAR 0 3
83655: ARRAY
83656: PPUSH
83657: CALL_OW 264
83661: PUSH
83662: LD_INT 31
83664: EQUAL
83665: IFFALSE 83683
// places := places + 1 else
83667: LD_ADDR_VAR 0 5
83671: PUSH
83672: LD_VAR 0 5
83676: PUSH
83677: LD_INT 1
83679: PLUS
83680: ST_TO_ADDR
83681: GO 83718
// if GetBType ( x [ j ] ) = b_control_tower then
83683: LD_VAR 0 11
83687: PUSH
83688: LD_VAR 0 3
83692: ARRAY
83693: PPUSH
83694: CALL_OW 266
83698: PUSH
83699: LD_INT 36
83701: EQUAL
83702: IFFALSE 83718
// places := places + 3 ;
83704: LD_ADDR_VAR 0 5
83708: PUSH
83709: LD_VAR 0 5
83713: PUSH
83714: LD_INT 3
83716: PLUS
83717: ST_TO_ADDR
83718: GO 83643
83720: POP
83721: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83722: LD_VAR 0 5
83726: PUSH
83727: LD_INT 0
83729: EQUAL
83730: PUSH
83731: LD_VAR 0 5
83735: PUSH
83736: LD_EXP 71
83740: PUSH
83741: LD_VAR 0 2
83745: ARRAY
83746: LESSEQUAL
83747: OR
83748: IFFALSE 83752
// continue ;
83750: GO 83002
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83752: LD_ADDR_VAR 0 6
83756: PUSH
83757: LD_EXP 31
83761: PUSH
83762: LD_VAR 0 2
83766: ARRAY
83767: PPUSH
83768: LD_INT 25
83770: PUSH
83771: LD_INT 3
83773: PUSH
83774: EMPTY
83775: LIST
83776: LIST
83777: PPUSH
83778: CALL_OW 72
83782: PUSH
83783: LD_EXP 71
83787: PUSH
83788: LD_VAR 0 2
83792: ARRAY
83793: DIFF
83794: PPUSH
83795: LD_INT 3
83797: PPUSH
83798: CALL 55693 0 2
83802: ST_TO_ADDR
// for j in tmp do
83803: LD_ADDR_VAR 0 3
83807: PUSH
83808: LD_VAR 0 6
83812: PUSH
83813: FOR_IN
83814: IFFALSE 83849
// if GetTag ( j ) > 0 then
83816: LD_VAR 0 3
83820: PPUSH
83821: CALL_OW 110
83825: PUSH
83826: LD_INT 0
83828: GREATER
83829: IFFALSE 83847
// tmp := tmp diff j ;
83831: LD_ADDR_VAR 0 6
83835: PUSH
83836: LD_VAR 0 6
83840: PUSH
83841: LD_VAR 0 3
83845: DIFF
83846: ST_TO_ADDR
83847: GO 83813
83849: POP
83850: POP
// if not tmp then
83851: LD_VAR 0 6
83855: NOT
83856: IFFALSE 83860
// continue ;
83858: GO 83002
// if places then
83860: LD_VAR 0 5
83864: IFFALSE 83923
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83866: LD_ADDR_EXP 71
83870: PUSH
83871: LD_EXP 71
83875: PPUSH
83876: LD_VAR 0 2
83880: PPUSH
83881: LD_EXP 71
83885: PUSH
83886: LD_VAR 0 2
83890: ARRAY
83891: PUSH
83892: LD_VAR 0 6
83896: PUSH
83897: LD_INT 1
83899: ARRAY
83900: UNION
83901: PPUSH
83902: CALL_OW 1
83906: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83907: LD_VAR 0 6
83911: PUSH
83912: LD_INT 1
83914: ARRAY
83915: PPUSH
83916: LD_INT 126
83918: PPUSH
83919: CALL_OW 109
// end ; end ;
83923: GO 83002
83925: POP
83926: POP
// end ;
83927: LD_VAR 0 1
83931: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83932: LD_INT 0
83934: PPUSH
83935: PPUSH
83936: PPUSH
83937: PPUSH
83938: PPUSH
83939: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83940: LD_VAR 0 1
83944: NOT
83945: PUSH
83946: LD_VAR 0 2
83950: NOT
83951: OR
83952: PUSH
83953: LD_VAR 0 3
83957: NOT
83958: OR
83959: PUSH
83960: LD_VAR 0 4
83964: PUSH
83965: LD_INT 1
83967: PUSH
83968: LD_INT 2
83970: PUSH
83971: LD_INT 3
83973: PUSH
83974: LD_INT 4
83976: PUSH
83977: LD_INT 5
83979: PUSH
83980: LD_INT 8
83982: PUSH
83983: LD_INT 9
83985: PUSH
83986: LD_INT 15
83988: PUSH
83989: LD_INT 16
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: IN
84003: NOT
84004: OR
84005: IFFALSE 84009
// exit ;
84007: GO 84867
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
84009: LD_ADDR_VAR 0 2
84013: PUSH
84014: LD_VAR 0 2
84018: PPUSH
84019: LD_INT 21
84021: PUSH
84022: LD_INT 3
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 24
84031: PUSH
84032: LD_INT 250
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PPUSH
84043: CALL_OW 72
84047: ST_TO_ADDR
// case class of 1 , 15 :
84048: LD_VAR 0 4
84052: PUSH
84053: LD_INT 1
84055: DOUBLE
84056: EQUAL
84057: IFTRUE 84067
84059: LD_INT 15
84061: DOUBLE
84062: EQUAL
84063: IFTRUE 84067
84065: GO 84152
84067: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84068: LD_ADDR_VAR 0 8
84072: PUSH
84073: LD_VAR 0 2
84077: PPUSH
84078: LD_INT 2
84080: PUSH
84081: LD_INT 30
84083: PUSH
84084: LD_INT 32
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 30
84093: PUSH
84094: LD_INT 31
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PUSH
84101: EMPTY
84102: LIST
84103: LIST
84104: LIST
84105: PPUSH
84106: CALL_OW 72
84110: PUSH
84111: LD_VAR 0 2
84115: PPUSH
84116: LD_INT 2
84118: PUSH
84119: LD_INT 30
84121: PUSH
84122: LD_INT 4
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 30
84131: PUSH
84132: LD_INT 5
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: LIST
84143: PPUSH
84144: CALL_OW 72
84148: ADD
84149: ST_TO_ADDR
84150: GO 84398
84152: LD_INT 2
84154: DOUBLE
84155: EQUAL
84156: IFTRUE 84166
84158: LD_INT 16
84160: DOUBLE
84161: EQUAL
84162: IFTRUE 84166
84164: GO 84212
84166: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84167: LD_ADDR_VAR 0 8
84171: PUSH
84172: LD_VAR 0 2
84176: PPUSH
84177: LD_INT 2
84179: PUSH
84180: LD_INT 30
84182: PUSH
84183: LD_INT 0
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: PUSH
84190: LD_INT 30
84192: PUSH
84193: LD_INT 1
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: LIST
84204: PPUSH
84205: CALL_OW 72
84209: ST_TO_ADDR
84210: GO 84398
84212: LD_INT 3
84214: DOUBLE
84215: EQUAL
84216: IFTRUE 84220
84218: GO 84266
84220: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84221: LD_ADDR_VAR 0 8
84225: PUSH
84226: LD_VAR 0 2
84230: PPUSH
84231: LD_INT 2
84233: PUSH
84234: LD_INT 30
84236: PUSH
84237: LD_INT 2
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 30
84246: PUSH
84247: LD_INT 3
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: LIST
84258: PPUSH
84259: CALL_OW 72
84263: ST_TO_ADDR
84264: GO 84398
84266: LD_INT 4
84268: DOUBLE
84269: EQUAL
84270: IFTRUE 84274
84272: GO 84331
84274: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84275: LD_ADDR_VAR 0 8
84279: PUSH
84280: LD_VAR 0 2
84284: PPUSH
84285: LD_INT 2
84287: PUSH
84288: LD_INT 30
84290: PUSH
84291: LD_INT 6
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: PUSH
84298: LD_INT 30
84300: PUSH
84301: LD_INT 7
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: LD_INT 30
84310: PUSH
84311: LD_INT 8
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: PPUSH
84324: CALL_OW 72
84328: ST_TO_ADDR
84329: GO 84398
84331: LD_INT 5
84333: DOUBLE
84334: EQUAL
84335: IFTRUE 84351
84337: LD_INT 8
84339: DOUBLE
84340: EQUAL
84341: IFTRUE 84351
84343: LD_INT 9
84345: DOUBLE
84346: EQUAL
84347: IFTRUE 84351
84349: GO 84397
84351: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84352: LD_ADDR_VAR 0 8
84356: PUSH
84357: LD_VAR 0 2
84361: PPUSH
84362: LD_INT 2
84364: PUSH
84365: LD_INT 30
84367: PUSH
84368: LD_INT 4
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 30
84377: PUSH
84378: LD_INT 5
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: LIST
84389: PPUSH
84390: CALL_OW 72
84394: ST_TO_ADDR
84395: GO 84398
84397: POP
// if not tmp then
84398: LD_VAR 0 8
84402: NOT
84403: IFFALSE 84407
// exit ;
84405: GO 84867
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84407: LD_VAR 0 4
84411: PUSH
84412: LD_INT 1
84414: PUSH
84415: LD_INT 15
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: IN
84422: PUSH
84423: LD_EXP 40
84427: PUSH
84428: LD_VAR 0 1
84432: ARRAY
84433: AND
84434: IFFALSE 84590
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84436: LD_ADDR_VAR 0 9
84440: PUSH
84441: LD_EXP 40
84445: PUSH
84446: LD_VAR 0 1
84450: ARRAY
84451: PUSH
84452: LD_INT 1
84454: ARRAY
84455: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84456: LD_VAR 0 9
84460: PUSH
84461: LD_EXP 41
84465: PUSH
84466: LD_VAR 0 1
84470: ARRAY
84471: IN
84472: NOT
84473: IFFALSE 84588
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84475: LD_ADDR_EXP 41
84479: PUSH
84480: LD_EXP 41
84484: PPUSH
84485: LD_VAR 0 1
84489: PUSH
84490: LD_EXP 41
84494: PUSH
84495: LD_VAR 0 1
84499: ARRAY
84500: PUSH
84501: LD_INT 1
84503: PLUS
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: PPUSH
84509: LD_VAR 0 9
84513: PPUSH
84514: CALL 24846 0 3
84518: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84519: LD_ADDR_EXP 40
84523: PUSH
84524: LD_EXP 40
84528: PPUSH
84529: LD_VAR 0 1
84533: PPUSH
84534: LD_EXP 40
84538: PUSH
84539: LD_VAR 0 1
84543: ARRAY
84544: PUSH
84545: LD_VAR 0 9
84549: DIFF
84550: PPUSH
84551: CALL_OW 1
84555: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84556: LD_VAR 0 3
84560: PPUSH
84561: LD_EXP 41
84565: PUSH
84566: LD_VAR 0 1
84570: ARRAY
84571: PUSH
84572: LD_EXP 41
84576: PUSH
84577: LD_VAR 0 1
84581: ARRAY
84582: ARRAY
84583: PPUSH
84584: CALL_OW 120
// end ; exit ;
84588: GO 84867
// end ; if tmp > 1 then
84590: LD_VAR 0 8
84594: PUSH
84595: LD_INT 1
84597: GREATER
84598: IFFALSE 84702
// for i = 2 to tmp do
84600: LD_ADDR_VAR 0 6
84604: PUSH
84605: DOUBLE
84606: LD_INT 2
84608: DEC
84609: ST_TO_ADDR
84610: LD_VAR 0 8
84614: PUSH
84615: FOR_TO
84616: IFFALSE 84700
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84618: LD_VAR 0 8
84622: PUSH
84623: LD_VAR 0 6
84627: ARRAY
84628: PPUSH
84629: CALL_OW 461
84633: PUSH
84634: LD_INT 6
84636: EQUAL
84637: IFFALSE 84698
// begin x := tmp [ i ] ;
84639: LD_ADDR_VAR 0 9
84643: PUSH
84644: LD_VAR 0 8
84648: PUSH
84649: LD_VAR 0 6
84653: ARRAY
84654: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84655: LD_ADDR_VAR 0 8
84659: PUSH
84660: LD_VAR 0 8
84664: PPUSH
84665: LD_VAR 0 6
84669: PPUSH
84670: CALL_OW 3
84674: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84675: LD_ADDR_VAR 0 8
84679: PUSH
84680: LD_VAR 0 8
84684: PPUSH
84685: LD_INT 1
84687: PPUSH
84688: LD_VAR 0 9
84692: PPUSH
84693: CALL_OW 2
84697: ST_TO_ADDR
// end ;
84698: GO 84615
84700: POP
84701: POP
// for i in tmp do
84702: LD_ADDR_VAR 0 6
84706: PUSH
84707: LD_VAR 0 8
84711: PUSH
84712: FOR_IN
84713: IFFALSE 84740
// begin if IsNotFull ( i ) then
84715: LD_VAR 0 6
84719: PPUSH
84720: CALL 22068 0 1
84724: IFFALSE 84738
// begin j := i ;
84726: LD_ADDR_VAR 0 7
84730: PUSH
84731: LD_VAR 0 6
84735: ST_TO_ADDR
// break ;
84736: GO 84740
// end ; end ;
84738: GO 84712
84740: POP
84741: POP
// if j then
84742: LD_VAR 0 7
84746: IFFALSE 84764
// ComEnterUnit ( unit , j ) else
84748: LD_VAR 0 3
84752: PPUSH
84753: LD_VAR 0 7
84757: PPUSH
84758: CALL_OW 120
84762: GO 84867
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84764: LD_ADDR_VAR 0 10
84768: PUSH
84769: LD_VAR 0 2
84773: PPUSH
84774: LD_INT 2
84776: PUSH
84777: LD_INT 30
84779: PUSH
84780: LD_INT 0
84782: PUSH
84783: EMPTY
84784: LIST
84785: LIST
84786: PUSH
84787: LD_INT 30
84789: PUSH
84790: LD_INT 1
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: LIST
84801: PPUSH
84802: CALL_OW 72
84806: ST_TO_ADDR
// if depot then
84807: LD_VAR 0 10
84811: IFFALSE 84867
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84813: LD_ADDR_VAR 0 10
84817: PUSH
84818: LD_VAR 0 10
84822: PPUSH
84823: LD_VAR 0 3
84827: PPUSH
84828: CALL_OW 74
84832: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84833: LD_VAR 0 3
84837: PPUSH
84838: LD_VAR 0 10
84842: PPUSH
84843: CALL_OW 296
84847: PUSH
84848: LD_INT 10
84850: GREATER
84851: IFFALSE 84867
// ComStandNearbyBuilding ( unit , depot ) ;
84853: LD_VAR 0 3
84857: PPUSH
84858: LD_VAR 0 10
84862: PPUSH
84863: CALL 21448 0 2
// end ; end ; end ;
84867: LD_VAR 0 5
84871: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84872: LD_INT 0
84874: PPUSH
84875: PPUSH
84876: PPUSH
84877: PPUSH
// if not mc_bases then
84878: LD_EXP 31
84882: NOT
84883: IFFALSE 84887
// exit ;
84885: GO 85126
// for i = 1 to mc_bases do
84887: LD_ADDR_VAR 0 2
84891: PUSH
84892: DOUBLE
84893: LD_INT 1
84895: DEC
84896: ST_TO_ADDR
84897: LD_EXP 31
84901: PUSH
84902: FOR_TO
84903: IFFALSE 85124
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84905: LD_ADDR_VAR 0 4
84909: PUSH
84910: LD_EXP 31
84914: PUSH
84915: LD_VAR 0 2
84919: ARRAY
84920: PPUSH
84921: LD_INT 21
84923: PUSH
84924: LD_INT 1
84926: PUSH
84927: EMPTY
84928: LIST
84929: LIST
84930: PPUSH
84931: CALL_OW 72
84935: PUSH
84936: LD_EXP 60
84940: PUSH
84941: LD_VAR 0 2
84945: ARRAY
84946: UNION
84947: ST_TO_ADDR
// if not tmp then
84948: LD_VAR 0 4
84952: NOT
84953: IFFALSE 84957
// continue ;
84955: GO 84902
// for j in tmp do
84957: LD_ADDR_VAR 0 3
84961: PUSH
84962: LD_VAR 0 4
84966: PUSH
84967: FOR_IN
84968: IFFALSE 85120
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
84970: LD_VAR 0 3
84974: PPUSH
84975: CALL_OW 110
84979: NOT
84980: PUSH
84981: LD_VAR 0 3
84985: PPUSH
84986: CALL_OW 314
84990: NOT
84991: AND
84992: PUSH
84993: LD_VAR 0 3
84997: PPUSH
84998: CALL_OW 311
85002: NOT
85003: AND
85004: PUSH
85005: LD_VAR 0 3
85009: PPUSH
85010: CALL_OW 310
85014: NOT
85015: AND
85016: PUSH
85017: LD_VAR 0 3
85021: PUSH
85022: LD_EXP 34
85026: PUSH
85027: LD_VAR 0 2
85031: ARRAY
85032: PUSH
85033: LD_INT 1
85035: ARRAY
85036: IN
85037: NOT
85038: AND
85039: PUSH
85040: LD_VAR 0 3
85044: PUSH
85045: LD_EXP 34
85049: PUSH
85050: LD_VAR 0 2
85054: ARRAY
85055: PUSH
85056: LD_INT 2
85058: ARRAY
85059: IN
85060: NOT
85061: AND
85062: PUSH
85063: LD_VAR 0 3
85067: PUSH
85068: LD_EXP 43
85072: PUSH
85073: LD_VAR 0 2
85077: ARRAY
85078: IN
85079: NOT
85080: AND
85081: IFFALSE 85118
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85083: LD_VAR 0 2
85087: PPUSH
85088: LD_EXP 31
85092: PUSH
85093: LD_VAR 0 2
85097: ARRAY
85098: PPUSH
85099: LD_VAR 0 3
85103: PPUSH
85104: LD_VAR 0 3
85108: PPUSH
85109: CALL_OW 257
85113: PPUSH
85114: CALL 83932 0 4
// end ;
85118: GO 84967
85120: POP
85121: POP
// end ;
85122: GO 84902
85124: POP
85125: POP
// end ;
85126: LD_VAR 0 1
85130: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
85131: LD_INT 0
85133: PPUSH
85134: PPUSH
85135: PPUSH
85136: PPUSH
85137: PPUSH
85138: PPUSH
// if not mc_bases [ base ] then
85139: LD_EXP 31
85143: PUSH
85144: LD_VAR 0 1
85148: ARRAY
85149: NOT
85150: IFFALSE 85154
// exit ;
85152: GO 85355
// tmp := [ ] ;
85154: LD_ADDR_VAR 0 6
85158: PUSH
85159: EMPTY
85160: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85161: LD_ADDR_VAR 0 7
85165: PUSH
85166: LD_VAR 0 3
85170: PPUSH
85171: LD_INT 0
85173: PPUSH
85174: CALL_OW 517
85178: ST_TO_ADDR
// if not list then
85179: LD_VAR 0 7
85183: NOT
85184: IFFALSE 85188
// exit ;
85186: GO 85355
// c := Count ( list [ 1 ] ) ;
85188: LD_ADDR_VAR 0 9
85192: PUSH
85193: LD_VAR 0 7
85197: PUSH
85198: LD_INT 1
85200: ARRAY
85201: PPUSH
85202: CALL 21986 0 1
85206: ST_TO_ADDR
// if amount > c then
85207: LD_VAR 0 2
85211: PUSH
85212: LD_VAR 0 9
85216: GREATER
85217: IFFALSE 85229
// amount := c ;
85219: LD_ADDR_VAR 0 2
85223: PUSH
85224: LD_VAR 0 9
85228: ST_TO_ADDR
// for i := 1 to amount do
85229: LD_ADDR_VAR 0 5
85233: PUSH
85234: DOUBLE
85235: LD_INT 1
85237: DEC
85238: ST_TO_ADDR
85239: LD_VAR 0 2
85243: PUSH
85244: FOR_TO
85245: IFFALSE 85303
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
85247: LD_ADDR_VAR 0 6
85251: PUSH
85252: LD_VAR 0 6
85256: PPUSH
85257: LD_VAR 0 5
85261: PPUSH
85262: LD_VAR 0 7
85266: PUSH
85267: LD_INT 1
85269: ARRAY
85270: PUSH
85271: LD_VAR 0 5
85275: ARRAY
85276: PUSH
85277: LD_VAR 0 7
85281: PUSH
85282: LD_INT 2
85284: ARRAY
85285: PUSH
85286: LD_VAR 0 5
85290: ARRAY
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PPUSH
85296: CALL_OW 1
85300: ST_TO_ADDR
85301: GO 85244
85303: POP
85304: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85305: LD_ADDR_EXP 44
85309: PUSH
85310: LD_EXP 44
85314: PPUSH
85315: LD_VAR 0 1
85319: PPUSH
85320: LD_VAR 0 6
85324: PPUSH
85325: CALL_OW 1
85329: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85330: LD_ADDR_EXP 46
85334: PUSH
85335: LD_EXP 46
85339: PPUSH
85340: LD_VAR 0 1
85344: PPUSH
85345: LD_VAR 0 3
85349: PPUSH
85350: CALL_OW 1
85354: ST_TO_ADDR
// end ;
85355: LD_VAR 0 4
85359: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85360: LD_INT 0
85362: PPUSH
// if not mc_bases [ base ] then
85363: LD_EXP 31
85367: PUSH
85368: LD_VAR 0 1
85372: ARRAY
85373: NOT
85374: IFFALSE 85378
// exit ;
85376: GO 85403
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85378: LD_ADDR_EXP 36
85382: PUSH
85383: LD_EXP 36
85387: PPUSH
85388: LD_VAR 0 1
85392: PPUSH
85393: LD_VAR 0 2
85397: PPUSH
85398: CALL_OW 1
85402: ST_TO_ADDR
// end ;
85403: LD_VAR 0 3
85407: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85408: LD_INT 0
85410: PPUSH
// if not mc_bases [ base ] then
85411: LD_EXP 31
85415: PUSH
85416: LD_VAR 0 1
85420: ARRAY
85421: NOT
85422: IFFALSE 85426
// exit ;
85424: GO 85463
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85426: LD_ADDR_EXP 36
85430: PUSH
85431: LD_EXP 36
85435: PPUSH
85436: LD_VAR 0 1
85440: PPUSH
85441: LD_EXP 36
85445: PUSH
85446: LD_VAR 0 1
85450: ARRAY
85451: PUSH
85452: LD_VAR 0 2
85456: UNION
85457: PPUSH
85458: CALL_OW 1
85462: ST_TO_ADDR
// end ;
85463: LD_VAR 0 3
85467: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85468: LD_INT 0
85470: PPUSH
// if not mc_bases [ base ] then
85471: LD_EXP 31
85475: PUSH
85476: LD_VAR 0 1
85480: ARRAY
85481: NOT
85482: IFFALSE 85486
// exit ;
85484: GO 85511
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85486: LD_ADDR_EXP 52
85490: PUSH
85491: LD_EXP 52
85495: PPUSH
85496: LD_VAR 0 1
85500: PPUSH
85501: LD_VAR 0 2
85505: PPUSH
85506: CALL_OW 1
85510: ST_TO_ADDR
// end ;
85511: LD_VAR 0 3
85515: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85516: LD_INT 0
85518: PPUSH
// if not mc_bases [ base ] then
85519: LD_EXP 31
85523: PUSH
85524: LD_VAR 0 1
85528: ARRAY
85529: NOT
85530: IFFALSE 85534
// exit ;
85532: GO 85571
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85534: LD_ADDR_EXP 52
85538: PUSH
85539: LD_EXP 52
85543: PPUSH
85544: LD_VAR 0 1
85548: PPUSH
85549: LD_EXP 52
85553: PUSH
85554: LD_VAR 0 1
85558: ARRAY
85559: PUSH
85560: LD_VAR 0 2
85564: ADD
85565: PPUSH
85566: CALL_OW 1
85570: ST_TO_ADDR
// end ;
85571: LD_VAR 0 3
85575: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85576: LD_INT 0
85578: PPUSH
// if not mc_bases [ base ] then
85579: LD_EXP 31
85583: PUSH
85584: LD_VAR 0 1
85588: ARRAY
85589: NOT
85590: IFFALSE 85594
// exit ;
85592: GO 85648
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85594: LD_ADDR_EXP 53
85598: PUSH
85599: LD_EXP 53
85603: PPUSH
85604: LD_VAR 0 1
85608: PPUSH
85609: LD_VAR 0 2
85613: PPUSH
85614: CALL_OW 1
85618: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85619: LD_ADDR_EXP 42
85623: PUSH
85624: LD_EXP 42
85628: PPUSH
85629: LD_VAR 0 1
85633: PPUSH
85634: LD_VAR 0 2
85638: PUSH
85639: LD_INT 0
85641: PLUS
85642: PPUSH
85643: CALL_OW 1
85647: ST_TO_ADDR
// end ;
85648: LD_VAR 0 3
85652: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85653: LD_INT 0
85655: PPUSH
// if not mc_bases [ base ] then
85656: LD_EXP 31
85660: PUSH
85661: LD_VAR 0 1
85665: ARRAY
85666: NOT
85667: IFFALSE 85671
// exit ;
85669: GO 85696
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85671: LD_ADDR_EXP 42
85675: PUSH
85676: LD_EXP 42
85680: PPUSH
85681: LD_VAR 0 1
85685: PPUSH
85686: LD_VAR 0 2
85690: PPUSH
85691: CALL_OW 1
85695: ST_TO_ADDR
// end ;
85696: LD_VAR 0 3
85700: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85701: LD_INT 0
85703: PPUSH
85704: PPUSH
85705: PPUSH
85706: PPUSH
// if not mc_bases [ base ] then
85707: LD_EXP 31
85711: PUSH
85712: LD_VAR 0 1
85716: ARRAY
85717: NOT
85718: IFFALSE 85722
// exit ;
85720: GO 85787
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85722: LD_ADDR_EXP 51
85726: PUSH
85727: LD_EXP 51
85731: PPUSH
85732: LD_VAR 0 1
85736: PUSH
85737: LD_EXP 51
85741: PUSH
85742: LD_VAR 0 1
85746: ARRAY
85747: PUSH
85748: LD_INT 1
85750: PLUS
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PPUSH
85756: LD_VAR 0 1
85760: PUSH
85761: LD_VAR 0 2
85765: PUSH
85766: LD_VAR 0 3
85770: PUSH
85771: LD_VAR 0 4
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: PPUSH
85782: CALL 24846 0 3
85786: ST_TO_ADDR
// end ;
85787: LD_VAR 0 5
85791: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85792: LD_INT 0
85794: PPUSH
// if not mc_bases [ base ] then
85795: LD_EXP 31
85799: PUSH
85800: LD_VAR 0 1
85804: ARRAY
85805: NOT
85806: IFFALSE 85810
// exit ;
85808: GO 85835
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85810: LD_ADDR_EXP 68
85814: PUSH
85815: LD_EXP 68
85819: PPUSH
85820: LD_VAR 0 1
85824: PPUSH
85825: LD_VAR 0 2
85829: PPUSH
85830: CALL_OW 1
85834: ST_TO_ADDR
// end ;
85835: LD_VAR 0 3
85839: RET
// export function MC_GetMinesField ( base ) ; begin
85840: LD_INT 0
85842: PPUSH
// result := mc_mines [ base ] ;
85843: LD_ADDR_VAR 0 2
85847: PUSH
85848: LD_EXP 44
85852: PUSH
85853: LD_VAR 0 1
85857: ARRAY
85858: ST_TO_ADDR
// end ;
85859: LD_VAR 0 2
85863: RET
// export function MC_GetProduceList ( base ) ; begin
85864: LD_INT 0
85866: PPUSH
// result := mc_produce [ base ] ;
85867: LD_ADDR_VAR 0 2
85871: PUSH
85872: LD_EXP 52
85876: PUSH
85877: LD_VAR 0 1
85881: ARRAY
85882: ST_TO_ADDR
// end ;
85883: LD_VAR 0 2
85887: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85888: LD_INT 0
85890: PPUSH
85891: PPUSH
// if not mc_bases then
85892: LD_EXP 31
85896: NOT
85897: IFFALSE 85901
// exit ;
85899: GO 85966
// if mc_bases [ base ] then
85901: LD_EXP 31
85905: PUSH
85906: LD_VAR 0 1
85910: ARRAY
85911: IFFALSE 85966
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85913: LD_ADDR_VAR 0 3
85917: PUSH
85918: LD_EXP 31
85922: PUSH
85923: LD_VAR 0 1
85927: ARRAY
85928: PPUSH
85929: LD_INT 30
85931: PUSH
85932: LD_VAR 0 2
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PPUSH
85941: CALL_OW 72
85945: ST_TO_ADDR
// if result then
85946: LD_VAR 0 3
85950: IFFALSE 85966
// result := result [ 1 ] ;
85952: LD_ADDR_VAR 0 3
85956: PUSH
85957: LD_VAR 0 3
85961: PUSH
85962: LD_INT 1
85964: ARRAY
85965: ST_TO_ADDR
// end ; end ;
85966: LD_VAR 0 3
85970: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
85971: LD_INT 0
85973: PPUSH
85974: PPUSH
// if not mc_bases then
85975: LD_EXP 31
85979: NOT
85980: IFFALSE 85984
// exit ;
85982: GO 86029
// if mc_bases [ base ] then
85984: LD_EXP 31
85988: PUSH
85989: LD_VAR 0 1
85993: ARRAY
85994: IFFALSE 86029
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85996: LD_ADDR_VAR 0 3
86000: PUSH
86001: LD_EXP 31
86005: PUSH
86006: LD_VAR 0 1
86010: ARRAY
86011: PPUSH
86012: LD_INT 30
86014: PUSH
86015: LD_VAR 0 2
86019: PUSH
86020: EMPTY
86021: LIST
86022: LIST
86023: PPUSH
86024: CALL_OW 72
86028: ST_TO_ADDR
// end ;
86029: LD_VAR 0 3
86033: RET
// export function MC_SetTame ( base , area ) ; begin
86034: LD_INT 0
86036: PPUSH
// if not mc_bases or not base then
86037: LD_EXP 31
86041: NOT
86042: PUSH
86043: LD_VAR 0 1
86047: NOT
86048: OR
86049: IFFALSE 86053
// exit ;
86051: GO 86078
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86053: LD_ADDR_EXP 59
86057: PUSH
86058: LD_EXP 59
86062: PPUSH
86063: LD_VAR 0 1
86067: PPUSH
86068: LD_VAR 0 2
86072: PPUSH
86073: CALL_OW 1
86077: ST_TO_ADDR
// end ;
86078: LD_VAR 0 3
86082: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86083: LD_INT 0
86085: PPUSH
86086: PPUSH
// if not mc_bases or not base then
86087: LD_EXP 31
86091: NOT
86092: PUSH
86093: LD_VAR 0 1
86097: NOT
86098: OR
86099: IFFALSE 86103
// exit ;
86101: GO 86205
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86103: LD_ADDR_VAR 0 4
86107: PUSH
86108: LD_EXP 31
86112: PUSH
86113: LD_VAR 0 1
86117: ARRAY
86118: PPUSH
86119: LD_INT 30
86121: PUSH
86122: LD_VAR 0 2
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PPUSH
86131: CALL_OW 72
86135: ST_TO_ADDR
// if not tmp then
86136: LD_VAR 0 4
86140: NOT
86141: IFFALSE 86145
// exit ;
86143: GO 86205
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86145: LD_ADDR_EXP 63
86149: PUSH
86150: LD_EXP 63
86154: PPUSH
86155: LD_VAR 0 1
86159: PPUSH
86160: LD_EXP 63
86164: PUSH
86165: LD_VAR 0 1
86169: ARRAY
86170: PPUSH
86171: LD_EXP 63
86175: PUSH
86176: LD_VAR 0 1
86180: ARRAY
86181: PUSH
86182: LD_INT 1
86184: PLUS
86185: PPUSH
86186: LD_VAR 0 4
86190: PUSH
86191: LD_INT 1
86193: ARRAY
86194: PPUSH
86195: CALL_OW 2
86199: PPUSH
86200: CALL_OW 1
86204: ST_TO_ADDR
// end ;
86205: LD_VAR 0 3
86209: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86210: LD_INT 0
86212: PPUSH
86213: PPUSH
// if not mc_bases or not base or not kinds then
86214: LD_EXP 31
86218: NOT
86219: PUSH
86220: LD_VAR 0 1
86224: NOT
86225: OR
86226: PUSH
86227: LD_VAR 0 2
86231: NOT
86232: OR
86233: IFFALSE 86237
// exit ;
86235: GO 86298
// for i in kinds do
86237: LD_ADDR_VAR 0 4
86241: PUSH
86242: LD_VAR 0 2
86246: PUSH
86247: FOR_IN
86248: IFFALSE 86296
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86250: LD_ADDR_EXP 65
86254: PUSH
86255: LD_EXP 65
86259: PPUSH
86260: LD_VAR 0 1
86264: PUSH
86265: LD_EXP 65
86269: PUSH
86270: LD_VAR 0 1
86274: ARRAY
86275: PUSH
86276: LD_INT 1
86278: PLUS
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: PPUSH
86284: LD_VAR 0 4
86288: PPUSH
86289: CALL 24846 0 3
86293: ST_TO_ADDR
86294: GO 86247
86296: POP
86297: POP
// end ;
86298: LD_VAR 0 3
86302: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86303: LD_INT 0
86305: PPUSH
// if not mc_bases or not base or not areas then
86306: LD_EXP 31
86310: NOT
86311: PUSH
86312: LD_VAR 0 1
86316: NOT
86317: OR
86318: PUSH
86319: LD_VAR 0 2
86323: NOT
86324: OR
86325: IFFALSE 86329
// exit ;
86327: GO 86354
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86329: LD_ADDR_EXP 49
86333: PUSH
86334: LD_EXP 49
86338: PPUSH
86339: LD_VAR 0 1
86343: PPUSH
86344: LD_VAR 0 2
86348: PPUSH
86349: CALL_OW 1
86353: ST_TO_ADDR
// end ;
86354: LD_VAR 0 3
86358: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86359: LD_INT 0
86361: PPUSH
// if not mc_bases or not base or not teleports_exit then
86362: LD_EXP 31
86366: NOT
86367: PUSH
86368: LD_VAR 0 1
86372: NOT
86373: OR
86374: PUSH
86375: LD_VAR 0 2
86379: NOT
86380: OR
86381: IFFALSE 86385
// exit ;
86383: GO 86410
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86385: LD_ADDR_EXP 66
86389: PUSH
86390: LD_EXP 66
86394: PPUSH
86395: LD_VAR 0 1
86399: PPUSH
86400: LD_VAR 0 2
86404: PPUSH
86405: CALL_OW 1
86409: ST_TO_ADDR
// end ;
86410: LD_VAR 0 3
86414: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86415: LD_INT 0
86417: PPUSH
86418: PPUSH
86419: PPUSH
// if not mc_bases or not base or not ext_list then
86420: LD_EXP 31
86424: NOT
86425: PUSH
86426: LD_VAR 0 1
86430: NOT
86431: OR
86432: PUSH
86433: LD_VAR 0 5
86437: NOT
86438: OR
86439: IFFALSE 86443
// exit ;
86441: GO 86616
// tmp := GetFacExtXYD ( x , y , d ) ;
86443: LD_ADDR_VAR 0 8
86447: PUSH
86448: LD_VAR 0 2
86452: PPUSH
86453: LD_VAR 0 3
86457: PPUSH
86458: LD_VAR 0 4
86462: PPUSH
86463: CALL 54823 0 3
86467: ST_TO_ADDR
// if not tmp then
86468: LD_VAR 0 8
86472: NOT
86473: IFFALSE 86477
// exit ;
86475: GO 86616
// for i in tmp do
86477: LD_ADDR_VAR 0 7
86481: PUSH
86482: LD_VAR 0 8
86486: PUSH
86487: FOR_IN
86488: IFFALSE 86614
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86490: LD_ADDR_EXP 36
86494: PUSH
86495: LD_EXP 36
86499: PPUSH
86500: LD_VAR 0 1
86504: PPUSH
86505: LD_EXP 36
86509: PUSH
86510: LD_VAR 0 1
86514: ARRAY
86515: PPUSH
86516: LD_EXP 36
86520: PUSH
86521: LD_VAR 0 1
86525: ARRAY
86526: PUSH
86527: LD_INT 1
86529: PLUS
86530: PPUSH
86531: LD_VAR 0 5
86535: PUSH
86536: LD_INT 1
86538: ARRAY
86539: PUSH
86540: LD_VAR 0 7
86544: PUSH
86545: LD_INT 1
86547: ARRAY
86548: PUSH
86549: LD_VAR 0 7
86553: PUSH
86554: LD_INT 2
86556: ARRAY
86557: PUSH
86558: LD_VAR 0 7
86562: PUSH
86563: LD_INT 3
86565: ARRAY
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: PPUSH
86573: CALL_OW 2
86577: PPUSH
86578: CALL_OW 1
86582: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86583: LD_ADDR_VAR 0 5
86587: PUSH
86588: LD_VAR 0 5
86592: PPUSH
86593: LD_INT 1
86595: PPUSH
86596: CALL_OW 3
86600: ST_TO_ADDR
// if not ext_list then
86601: LD_VAR 0 5
86605: NOT
86606: IFFALSE 86612
// exit ;
86608: POP
86609: POP
86610: GO 86616
// end ;
86612: GO 86487
86614: POP
86615: POP
// end ;
86616: LD_VAR 0 6
86620: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86621: LD_INT 0
86623: PPUSH
// if not mc_bases or not base or not weapon_list then
86624: LD_EXP 31
86628: NOT
86629: PUSH
86630: LD_VAR 0 1
86634: NOT
86635: OR
86636: PUSH
86637: LD_VAR 0 2
86641: NOT
86642: OR
86643: IFFALSE 86647
// exit ;
86645: GO 86672
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86647: LD_ADDR_EXP 70
86651: PUSH
86652: LD_EXP 70
86656: PPUSH
86657: LD_VAR 0 1
86661: PPUSH
86662: LD_VAR 0 2
86666: PPUSH
86667: CALL_OW 1
86671: ST_TO_ADDR
// end ;
86672: LD_VAR 0 3
86676: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86677: LD_INT 0
86679: PPUSH
// if not mc_bases or not base or not tech_list then
86680: LD_EXP 31
86684: NOT
86685: PUSH
86686: LD_VAR 0 1
86690: NOT
86691: OR
86692: PUSH
86693: LD_VAR 0 2
86697: NOT
86698: OR
86699: IFFALSE 86703
// exit ;
86701: GO 86728
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86703: LD_ADDR_EXP 58
86707: PUSH
86708: LD_EXP 58
86712: PPUSH
86713: LD_VAR 0 1
86717: PPUSH
86718: LD_VAR 0 2
86722: PPUSH
86723: CALL_OW 1
86727: ST_TO_ADDR
// end ;
86728: LD_VAR 0 3
86732: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86733: LD_INT 0
86735: PPUSH
// if not mc_bases or not parking_area or not base then
86736: LD_EXP 31
86740: NOT
86741: PUSH
86742: LD_VAR 0 2
86746: NOT
86747: OR
86748: PUSH
86749: LD_VAR 0 1
86753: NOT
86754: OR
86755: IFFALSE 86759
// exit ;
86757: GO 86784
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86759: LD_ADDR_EXP 55
86763: PUSH
86764: LD_EXP 55
86768: PPUSH
86769: LD_VAR 0 1
86773: PPUSH
86774: LD_VAR 0 2
86778: PPUSH
86779: CALL_OW 1
86783: ST_TO_ADDR
// end ;
86784: LD_VAR 0 3
86788: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86789: LD_INT 0
86791: PPUSH
// if not mc_bases or not base or not scan_area then
86792: LD_EXP 31
86796: NOT
86797: PUSH
86798: LD_VAR 0 1
86802: NOT
86803: OR
86804: PUSH
86805: LD_VAR 0 2
86809: NOT
86810: OR
86811: IFFALSE 86815
// exit ;
86813: GO 86840
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86815: LD_ADDR_EXP 56
86819: PUSH
86820: LD_EXP 56
86824: PPUSH
86825: LD_VAR 0 1
86829: PPUSH
86830: LD_VAR 0 2
86834: PPUSH
86835: CALL_OW 1
86839: ST_TO_ADDR
// end ;
86840: LD_VAR 0 3
86844: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86845: LD_INT 0
86847: PPUSH
86848: PPUSH
// if not mc_bases or not base then
86849: LD_EXP 31
86853: NOT
86854: PUSH
86855: LD_VAR 0 1
86859: NOT
86860: OR
86861: IFFALSE 86865
// exit ;
86863: GO 86929
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86865: LD_ADDR_VAR 0 3
86869: PUSH
86870: LD_INT 1
86872: PUSH
86873: LD_INT 2
86875: PUSH
86876: LD_INT 3
86878: PUSH
86879: LD_INT 4
86881: PUSH
86882: LD_INT 11
86884: PUSH
86885: EMPTY
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86892: LD_ADDR_EXP 58
86896: PUSH
86897: LD_EXP 58
86901: PPUSH
86902: LD_VAR 0 1
86906: PPUSH
86907: LD_EXP 58
86911: PUSH
86912: LD_VAR 0 1
86916: ARRAY
86917: PUSH
86918: LD_VAR 0 3
86922: DIFF
86923: PPUSH
86924: CALL_OW 1
86928: ST_TO_ADDR
// end ;
86929: LD_VAR 0 2
86933: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86934: LD_INT 0
86936: PPUSH
// result := mc_vehicles [ base ] ;
86937: LD_ADDR_VAR 0 3
86941: PUSH
86942: LD_EXP 50
86946: PUSH
86947: LD_VAR 0 1
86951: ARRAY
86952: ST_TO_ADDR
// if onlyCombat then
86953: LD_VAR 0 2
86957: IFFALSE 87129
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
86959: LD_ADDR_VAR 0 3
86963: PUSH
86964: LD_VAR 0 3
86968: PUSH
86969: LD_VAR 0 3
86973: PPUSH
86974: LD_INT 2
86976: PUSH
86977: LD_INT 34
86979: PUSH
86980: LD_INT 12
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 34
86989: PUSH
86990: LD_INT 51
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 34
86999: PUSH
87000: LD_INT 89
87002: PUSH
87003: EMPTY
87004: LIST
87005: LIST
87006: PUSH
87007: LD_INT 34
87009: PUSH
87010: LD_INT 32
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PUSH
87017: LD_INT 34
87019: PUSH
87020: LD_INT 13
87022: PUSH
87023: EMPTY
87024: LIST
87025: LIST
87026: PUSH
87027: LD_INT 34
87029: PUSH
87030: LD_INT 52
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: LD_INT 34
87039: PUSH
87040: LD_INT 88
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 34
87049: PUSH
87050: LD_INT 14
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 34
87059: PUSH
87060: LD_INT 53
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 34
87069: PUSH
87070: LD_INT 98
87072: PUSH
87073: EMPTY
87074: LIST
87075: LIST
87076: PUSH
87077: LD_INT 34
87079: PUSH
87080: LD_INT 31
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PUSH
87087: LD_INT 34
87089: PUSH
87090: LD_INT 48
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: PUSH
87097: LD_INT 34
87099: PUSH
87100: LD_INT 8
87102: PUSH
87103: EMPTY
87104: LIST
87105: LIST
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: PPUSH
87123: CALL_OW 72
87127: DIFF
87128: ST_TO_ADDR
// end ; end_of_file
87129: LD_VAR 0 3
87133: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87134: LD_INT 0
87136: PPUSH
87137: PPUSH
87138: PPUSH
// if not mc_bases or not skirmish then
87139: LD_EXP 31
87143: NOT
87144: PUSH
87145: LD_EXP 29
87149: NOT
87150: OR
87151: IFFALSE 87155
// exit ;
87153: GO 87320
// for i = 1 to mc_bases do
87155: LD_ADDR_VAR 0 4
87159: PUSH
87160: DOUBLE
87161: LD_INT 1
87163: DEC
87164: ST_TO_ADDR
87165: LD_EXP 31
87169: PUSH
87170: FOR_TO
87171: IFFALSE 87318
// begin if sci in mc_bases [ i ] then
87173: LD_VAR 0 2
87177: PUSH
87178: LD_EXP 31
87182: PUSH
87183: LD_VAR 0 4
87187: ARRAY
87188: IN
87189: IFFALSE 87316
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87191: LD_ADDR_EXP 60
87195: PUSH
87196: LD_EXP 60
87200: PPUSH
87201: LD_VAR 0 4
87205: PUSH
87206: LD_EXP 60
87210: PUSH
87211: LD_VAR 0 4
87215: ARRAY
87216: PUSH
87217: LD_INT 1
87219: PLUS
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: PPUSH
87225: LD_VAR 0 1
87229: PPUSH
87230: CALL 24846 0 3
87234: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87235: LD_ADDR_VAR 0 5
87239: PUSH
87240: LD_EXP 31
87244: PUSH
87245: LD_VAR 0 4
87249: ARRAY
87250: PPUSH
87251: LD_INT 2
87253: PUSH
87254: LD_INT 30
87256: PUSH
87257: LD_INT 0
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 30
87266: PUSH
87267: LD_INT 1
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: LIST
87278: PPUSH
87279: CALL_OW 72
87283: PPUSH
87284: LD_VAR 0 1
87288: PPUSH
87289: CALL_OW 74
87293: ST_TO_ADDR
// if tmp then
87294: LD_VAR 0 5
87298: IFFALSE 87314
// ComStandNearbyBuilding ( ape , tmp ) ;
87300: LD_VAR 0 1
87304: PPUSH
87305: LD_VAR 0 5
87309: PPUSH
87310: CALL 21448 0 2
// break ;
87314: GO 87318
// end ; end ;
87316: GO 87170
87318: POP
87319: POP
// end ;
87320: LD_VAR 0 3
87324: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87325: LD_INT 0
87327: PPUSH
87328: PPUSH
87329: PPUSH
// if not mc_bases or not skirmish then
87330: LD_EXP 31
87334: NOT
87335: PUSH
87336: LD_EXP 29
87340: NOT
87341: OR
87342: IFFALSE 87346
// exit ;
87344: GO 87435
// for i = 1 to mc_bases do
87346: LD_ADDR_VAR 0 4
87350: PUSH
87351: DOUBLE
87352: LD_INT 1
87354: DEC
87355: ST_TO_ADDR
87356: LD_EXP 31
87360: PUSH
87361: FOR_TO
87362: IFFALSE 87433
// begin if building in mc_busy_turret_list [ i ] then
87364: LD_VAR 0 1
87368: PUSH
87369: LD_EXP 41
87373: PUSH
87374: LD_VAR 0 4
87378: ARRAY
87379: IN
87380: IFFALSE 87431
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87382: LD_ADDR_VAR 0 5
87386: PUSH
87387: LD_EXP 41
87391: PUSH
87392: LD_VAR 0 4
87396: ARRAY
87397: PUSH
87398: LD_VAR 0 1
87402: DIFF
87403: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87404: LD_ADDR_EXP 41
87408: PUSH
87409: LD_EXP 41
87413: PPUSH
87414: LD_VAR 0 4
87418: PPUSH
87419: LD_VAR 0 5
87423: PPUSH
87424: CALL_OW 1
87428: ST_TO_ADDR
// break ;
87429: GO 87433
// end ; end ;
87431: GO 87361
87433: POP
87434: POP
// end ;
87435: LD_VAR 0 3
87439: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87440: LD_INT 0
87442: PPUSH
87443: PPUSH
87444: PPUSH
// if not mc_bases or not skirmish then
87445: LD_EXP 31
87449: NOT
87450: PUSH
87451: LD_EXP 29
87455: NOT
87456: OR
87457: IFFALSE 87461
// exit ;
87459: GO 87660
// for i = 1 to mc_bases do
87461: LD_ADDR_VAR 0 5
87465: PUSH
87466: DOUBLE
87467: LD_INT 1
87469: DEC
87470: ST_TO_ADDR
87471: LD_EXP 31
87475: PUSH
87476: FOR_TO
87477: IFFALSE 87658
// if building in mc_bases [ i ] then
87479: LD_VAR 0 1
87483: PUSH
87484: LD_EXP 31
87488: PUSH
87489: LD_VAR 0 5
87493: ARRAY
87494: IN
87495: IFFALSE 87656
// begin tmp := mc_bases [ i ] diff building ;
87497: LD_ADDR_VAR 0 6
87501: PUSH
87502: LD_EXP 31
87506: PUSH
87507: LD_VAR 0 5
87511: ARRAY
87512: PUSH
87513: LD_VAR 0 1
87517: DIFF
87518: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87519: LD_ADDR_EXP 31
87523: PUSH
87524: LD_EXP 31
87528: PPUSH
87529: LD_VAR 0 5
87533: PPUSH
87534: LD_VAR 0 6
87538: PPUSH
87539: CALL_OW 1
87543: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87544: LD_VAR 0 1
87548: PUSH
87549: LD_EXP 39
87553: PUSH
87554: LD_VAR 0 5
87558: ARRAY
87559: IN
87560: IFFALSE 87599
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87562: LD_ADDR_EXP 39
87566: PUSH
87567: LD_EXP 39
87571: PPUSH
87572: LD_VAR 0 5
87576: PPUSH
87577: LD_EXP 39
87581: PUSH
87582: LD_VAR 0 5
87586: ARRAY
87587: PUSH
87588: LD_VAR 0 1
87592: DIFF
87593: PPUSH
87594: CALL_OW 1
87598: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87599: LD_VAR 0 1
87603: PUSH
87604: LD_EXP 40
87608: PUSH
87609: LD_VAR 0 5
87613: ARRAY
87614: IN
87615: IFFALSE 87654
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87617: LD_ADDR_EXP 40
87621: PUSH
87622: LD_EXP 40
87626: PPUSH
87627: LD_VAR 0 5
87631: PPUSH
87632: LD_EXP 40
87636: PUSH
87637: LD_VAR 0 5
87641: ARRAY
87642: PUSH
87643: LD_VAR 0 1
87647: DIFF
87648: PPUSH
87649: CALL_OW 1
87653: ST_TO_ADDR
// break ;
87654: GO 87658
// end ;
87656: GO 87476
87658: POP
87659: POP
// end ;
87660: LD_VAR 0 4
87664: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87665: LD_INT 0
87667: PPUSH
87668: PPUSH
87669: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87670: LD_EXP 31
87674: NOT
87675: PUSH
87676: LD_EXP 29
87680: NOT
87681: OR
87682: PUSH
87683: LD_VAR 0 3
87687: PUSH
87688: LD_EXP 57
87692: IN
87693: NOT
87694: OR
87695: IFFALSE 87699
// exit ;
87697: GO 87822
// for i = 1 to mc_vehicles do
87699: LD_ADDR_VAR 0 6
87703: PUSH
87704: DOUBLE
87705: LD_INT 1
87707: DEC
87708: ST_TO_ADDR
87709: LD_EXP 50
87713: PUSH
87714: FOR_TO
87715: IFFALSE 87820
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87717: LD_VAR 0 2
87721: PUSH
87722: LD_EXP 50
87726: PUSH
87727: LD_VAR 0 6
87731: ARRAY
87732: IN
87733: PUSH
87734: LD_VAR 0 1
87738: PUSH
87739: LD_EXP 50
87743: PUSH
87744: LD_VAR 0 6
87748: ARRAY
87749: IN
87750: OR
87751: IFFALSE 87818
// begin tmp := mc_vehicles [ i ] diff old ;
87753: LD_ADDR_VAR 0 7
87757: PUSH
87758: LD_EXP 50
87762: PUSH
87763: LD_VAR 0 6
87767: ARRAY
87768: PUSH
87769: LD_VAR 0 2
87773: DIFF
87774: ST_TO_ADDR
// tmp := tmp diff new ;
87775: LD_ADDR_VAR 0 7
87779: PUSH
87780: LD_VAR 0 7
87784: PUSH
87785: LD_VAR 0 1
87789: DIFF
87790: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87791: LD_ADDR_EXP 50
87795: PUSH
87796: LD_EXP 50
87800: PPUSH
87801: LD_VAR 0 6
87805: PPUSH
87806: LD_VAR 0 7
87810: PPUSH
87811: CALL_OW 1
87815: ST_TO_ADDR
// break ;
87816: GO 87820
// end ;
87818: GO 87714
87820: POP
87821: POP
// end ;
87822: LD_VAR 0 5
87826: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87827: LD_INT 0
87829: PPUSH
87830: PPUSH
87831: PPUSH
87832: PPUSH
// if not mc_bases or not skirmish then
87833: LD_EXP 31
87837: NOT
87838: PUSH
87839: LD_EXP 29
87843: NOT
87844: OR
87845: IFFALSE 87849
// exit ;
87847: GO 88269
// repeat wait ( 0 0$1 ) ;
87849: LD_INT 35
87851: PPUSH
87852: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
87856: LD_EXP 75
87860: NOT
87861: IFFALSE 87849
// mc_block_vehicle_constructed_thread := true ;
87863: LD_ADDR_EXP 75
87867: PUSH
87868: LD_INT 1
87870: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
87871: LD_ADDR_VAR 0 5
87875: PUSH
87876: LD_VAR 0 1
87880: PPUSH
87881: CALL_OW 255
87885: ST_TO_ADDR
// for i = 1 to mc_bases do
87886: LD_ADDR_VAR 0 4
87890: PUSH
87891: DOUBLE
87892: LD_INT 1
87894: DEC
87895: ST_TO_ADDR
87896: LD_EXP 31
87900: PUSH
87901: FOR_TO
87902: IFFALSE 88259
// begin if factory in mc_bases [ i ] then
87904: LD_VAR 0 2
87908: PUSH
87909: LD_EXP 31
87913: PUSH
87914: LD_VAR 0 4
87918: ARRAY
87919: IN
87920: IFFALSE 88257
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87922: LD_EXP 53
87926: PUSH
87927: LD_VAR 0 4
87931: ARRAY
87932: PUSH
87933: LD_EXP 42
87937: PUSH
87938: LD_VAR 0 4
87942: ARRAY
87943: LESS
87944: PUSH
87945: LD_VAR 0 1
87949: PPUSH
87950: CALL_OW 264
87954: PUSH
87955: LD_INT 31
87957: PUSH
87958: LD_INT 32
87960: PUSH
87961: LD_INT 51
87963: PUSH
87964: LD_INT 89
87966: PUSH
87967: LD_INT 12
87969: PUSH
87970: LD_INT 30
87972: PUSH
87973: LD_INT 98
87975: PUSH
87976: LD_INT 11
87978: PUSH
87979: LD_INT 53
87981: PUSH
87982: LD_INT 14
87984: PUSH
87985: LD_INT 91
87987: PUSH
87988: LD_INT 29
87990: PUSH
87991: LD_INT 99
87993: PUSH
87994: LD_INT 13
87996: PUSH
87997: LD_INT 52
87999: PUSH
88000: LD_INT 88
88002: PUSH
88003: LD_INT 48
88005: PUSH
88006: LD_INT 8
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: IN
88029: NOT
88030: AND
88031: IFFALSE 88079
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88033: LD_ADDR_EXP 53
88037: PUSH
88038: LD_EXP 53
88042: PPUSH
88043: LD_VAR 0 4
88047: PUSH
88048: LD_EXP 53
88052: PUSH
88053: LD_VAR 0 4
88057: ARRAY
88058: PUSH
88059: LD_INT 1
88061: PLUS
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PPUSH
88067: LD_VAR 0 1
88071: PPUSH
88072: CALL 24846 0 3
88076: ST_TO_ADDR
88077: GO 88123
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88079: LD_ADDR_EXP 50
88083: PUSH
88084: LD_EXP 50
88088: PPUSH
88089: LD_VAR 0 4
88093: PUSH
88094: LD_EXP 50
88098: PUSH
88099: LD_VAR 0 4
88103: ARRAY
88104: PUSH
88105: LD_INT 1
88107: PLUS
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PPUSH
88113: LD_VAR 0 1
88117: PPUSH
88118: CALL 24846 0 3
88122: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
88123: LD_ADDR_EXP 75
88127: PUSH
88128: LD_INT 0
88130: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88131: LD_VAR 0 1
88135: PPUSH
88136: CALL_OW 263
88140: PUSH
88141: LD_INT 2
88143: EQUAL
88144: IFFALSE 88173
// begin repeat wait ( 0 0$3 ) ;
88146: LD_INT 105
88148: PPUSH
88149: CALL_OW 67
// Connect ( vehicle ) ;
88153: LD_VAR 0 1
88157: PPUSH
88158: CALL 27815 0 1
// until IsControledBy ( vehicle ) ;
88162: LD_VAR 0 1
88166: PPUSH
88167: CALL_OW 312
88171: IFFALSE 88146
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88173: LD_VAR 0 1
88177: PPUSH
88178: LD_EXP 55
88182: PUSH
88183: LD_VAR 0 4
88187: ARRAY
88188: PPUSH
88189: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88193: LD_VAR 0 1
88197: PPUSH
88198: CALL_OW 263
88202: PUSH
88203: LD_INT 1
88205: NONEQUAL
88206: IFFALSE 88210
// break ;
88208: GO 88259
// repeat wait ( 0 0$1 ) ;
88210: LD_INT 35
88212: PPUSH
88213: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88217: LD_VAR 0 1
88221: PPUSH
88222: LD_EXP 55
88226: PUSH
88227: LD_VAR 0 4
88231: ARRAY
88232: PPUSH
88233: CALL_OW 308
88237: IFFALSE 88210
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88239: LD_VAR 0 1
88243: PPUSH
88244: CALL_OW 311
88248: PPUSH
88249: CALL_OW 121
// exit ;
88253: POP
88254: POP
88255: GO 88269
// end ; end ;
88257: GO 87901
88259: POP
88260: POP
// mc_block_vehicle_constructed_thread := false ;
88261: LD_ADDR_EXP 75
88265: PUSH
88266: LD_INT 0
88268: ST_TO_ADDR
// end ;
88269: LD_VAR 0 3
88273: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88274: LD_INT 0
88276: PPUSH
88277: PPUSH
88278: PPUSH
88279: PPUSH
// if not mc_bases or not skirmish then
88280: LD_EXP 31
88284: NOT
88285: PUSH
88286: LD_EXP 29
88290: NOT
88291: OR
88292: IFFALSE 88296
// exit ;
88294: GO 88649
// repeat wait ( 0 0$1 ) ;
88296: LD_INT 35
88298: PPUSH
88299: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88303: LD_VAR 0 2
88307: PPUSH
88308: LD_VAR 0 3
88312: PPUSH
88313: CALL_OW 284
88317: IFFALSE 88296
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88319: LD_VAR 0 2
88323: PPUSH
88324: LD_VAR 0 3
88328: PPUSH
88329: CALL_OW 283
88333: PUSH
88334: LD_INT 4
88336: EQUAL
88337: IFFALSE 88341
// exit ;
88339: GO 88649
// for i = 1 to mc_bases do
88341: LD_ADDR_VAR 0 7
88345: PUSH
88346: DOUBLE
88347: LD_INT 1
88349: DEC
88350: ST_TO_ADDR
88351: LD_EXP 31
88355: PUSH
88356: FOR_TO
88357: IFFALSE 88647
// begin if mc_crates_area [ i ] then
88359: LD_EXP 49
88363: PUSH
88364: LD_VAR 0 7
88368: ARRAY
88369: IFFALSE 88480
// for j in mc_crates_area [ i ] do
88371: LD_ADDR_VAR 0 8
88375: PUSH
88376: LD_EXP 49
88380: PUSH
88381: LD_VAR 0 7
88385: ARRAY
88386: PUSH
88387: FOR_IN
88388: IFFALSE 88478
// if InArea ( x , y , j ) then
88390: LD_VAR 0 2
88394: PPUSH
88395: LD_VAR 0 3
88399: PPUSH
88400: LD_VAR 0 8
88404: PPUSH
88405: CALL_OW 309
88409: IFFALSE 88476
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88411: LD_ADDR_EXP 47
88415: PUSH
88416: LD_EXP 47
88420: PPUSH
88421: LD_VAR 0 7
88425: PUSH
88426: LD_EXP 47
88430: PUSH
88431: LD_VAR 0 7
88435: ARRAY
88436: PUSH
88437: LD_INT 1
88439: PLUS
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PPUSH
88445: LD_VAR 0 4
88449: PUSH
88450: LD_VAR 0 2
88454: PUSH
88455: LD_VAR 0 3
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: LIST
88464: PPUSH
88465: CALL 24846 0 3
88469: ST_TO_ADDR
// exit ;
88470: POP
88471: POP
88472: POP
88473: POP
88474: GO 88649
// end ;
88476: GO 88387
88478: POP
88479: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88480: LD_ADDR_VAR 0 9
88484: PUSH
88485: LD_EXP 31
88489: PUSH
88490: LD_VAR 0 7
88494: ARRAY
88495: PPUSH
88496: LD_INT 2
88498: PUSH
88499: LD_INT 30
88501: PUSH
88502: LD_INT 0
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 30
88511: PUSH
88512: LD_INT 1
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: EMPTY
88520: LIST
88521: LIST
88522: LIST
88523: PPUSH
88524: CALL_OW 72
88528: ST_TO_ADDR
// if not depot then
88529: LD_VAR 0 9
88533: NOT
88534: IFFALSE 88538
// continue ;
88536: GO 88356
// for j in depot do
88538: LD_ADDR_VAR 0 8
88542: PUSH
88543: LD_VAR 0 9
88547: PUSH
88548: FOR_IN
88549: IFFALSE 88643
// if GetDistUnitXY ( j , x , y ) < 30 then
88551: LD_VAR 0 8
88555: PPUSH
88556: LD_VAR 0 2
88560: PPUSH
88561: LD_VAR 0 3
88565: PPUSH
88566: CALL_OW 297
88570: PUSH
88571: LD_INT 30
88573: LESS
88574: IFFALSE 88641
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88576: LD_ADDR_EXP 47
88580: PUSH
88581: LD_EXP 47
88585: PPUSH
88586: LD_VAR 0 7
88590: PUSH
88591: LD_EXP 47
88595: PUSH
88596: LD_VAR 0 7
88600: ARRAY
88601: PUSH
88602: LD_INT 1
88604: PLUS
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PPUSH
88610: LD_VAR 0 4
88614: PUSH
88615: LD_VAR 0 2
88619: PUSH
88620: LD_VAR 0 3
88624: PUSH
88625: EMPTY
88626: LIST
88627: LIST
88628: LIST
88629: PPUSH
88630: CALL 24846 0 3
88634: ST_TO_ADDR
// exit ;
88635: POP
88636: POP
88637: POP
88638: POP
88639: GO 88649
// end ;
88641: GO 88548
88643: POP
88644: POP
// end ;
88645: GO 88356
88647: POP
88648: POP
// end ;
88649: LD_VAR 0 6
88653: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88654: LD_INT 0
88656: PPUSH
88657: PPUSH
88658: PPUSH
88659: PPUSH
// if not mc_bases or not skirmish then
88660: LD_EXP 31
88664: NOT
88665: PUSH
88666: LD_EXP 29
88670: NOT
88671: OR
88672: IFFALSE 88676
// exit ;
88674: GO 88953
// side := GetSide ( lab ) ;
88676: LD_ADDR_VAR 0 4
88680: PUSH
88681: LD_VAR 0 2
88685: PPUSH
88686: CALL_OW 255
88690: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88691: LD_VAR 0 4
88695: PUSH
88696: LD_EXP 57
88700: IN
88701: NOT
88702: PUSH
88703: LD_EXP 58
88707: NOT
88708: OR
88709: PUSH
88710: LD_EXP 31
88714: NOT
88715: OR
88716: IFFALSE 88720
// exit ;
88718: GO 88953
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88720: LD_ADDR_EXP 58
88724: PUSH
88725: LD_EXP 58
88729: PPUSH
88730: LD_VAR 0 4
88734: PPUSH
88735: LD_EXP 58
88739: PUSH
88740: LD_VAR 0 4
88744: ARRAY
88745: PUSH
88746: LD_VAR 0 1
88750: DIFF
88751: PPUSH
88752: CALL_OW 1
88756: ST_TO_ADDR
// for i = 1 to mc_bases do
88757: LD_ADDR_VAR 0 5
88761: PUSH
88762: DOUBLE
88763: LD_INT 1
88765: DEC
88766: ST_TO_ADDR
88767: LD_EXP 31
88771: PUSH
88772: FOR_TO
88773: IFFALSE 88951
// begin if lab in mc_bases [ i ] then
88775: LD_VAR 0 2
88779: PUSH
88780: LD_EXP 31
88784: PUSH
88785: LD_VAR 0 5
88789: ARRAY
88790: IN
88791: IFFALSE 88949
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88793: LD_VAR 0 1
88797: PUSH
88798: LD_INT 11
88800: PUSH
88801: LD_INT 4
88803: PUSH
88804: LD_INT 3
88806: PUSH
88807: LD_INT 2
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: IN
88816: PUSH
88817: LD_EXP 61
88821: PUSH
88822: LD_VAR 0 5
88826: ARRAY
88827: AND
88828: IFFALSE 88949
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88830: LD_ADDR_VAR 0 6
88834: PUSH
88835: LD_EXP 61
88839: PUSH
88840: LD_VAR 0 5
88844: ARRAY
88845: PUSH
88846: LD_INT 1
88848: ARRAY
88849: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88850: LD_ADDR_EXP 61
88854: PUSH
88855: LD_EXP 61
88859: PPUSH
88860: LD_VAR 0 5
88864: PPUSH
88865: EMPTY
88866: PPUSH
88867: CALL_OW 1
88871: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88872: LD_VAR 0 6
88876: PPUSH
88877: LD_INT 0
88879: PPUSH
88880: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88884: LD_VAR 0 6
88888: PPUSH
88889: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88893: LD_ADDR_EXP 60
88897: PUSH
88898: LD_EXP 60
88902: PPUSH
88903: LD_VAR 0 5
88907: PPUSH
88908: LD_EXP 60
88912: PUSH
88913: LD_VAR 0 5
88917: ARRAY
88918: PPUSH
88919: LD_INT 1
88921: PPUSH
88922: LD_VAR 0 6
88926: PPUSH
88927: CALL_OW 2
88931: PPUSH
88932: CALL_OW 1
88936: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88937: LD_VAR 0 5
88941: PPUSH
88942: LD_INT 112
88944: PPUSH
88945: CALL 65417 0 2
// end ; end ; end ;
88949: GO 88772
88951: POP
88952: POP
// end ;
88953: LD_VAR 0 3
88957: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
88958: LD_INT 0
88960: PPUSH
88961: PPUSH
88962: PPUSH
88963: PPUSH
88964: PPUSH
88965: PPUSH
88966: PPUSH
88967: PPUSH
// if not mc_bases or not skirmish then
88968: LD_EXP 31
88972: NOT
88973: PUSH
88974: LD_EXP 29
88978: NOT
88979: OR
88980: IFFALSE 88984
// exit ;
88982: GO 90353
// for i = 1 to mc_bases do
88984: LD_ADDR_VAR 0 3
88988: PUSH
88989: DOUBLE
88990: LD_INT 1
88992: DEC
88993: ST_TO_ADDR
88994: LD_EXP 31
88998: PUSH
88999: FOR_TO
89000: IFFALSE 90351
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
89002: LD_VAR 0 1
89006: PUSH
89007: LD_EXP 31
89011: PUSH
89012: LD_VAR 0 3
89016: ARRAY
89017: IN
89018: PUSH
89019: LD_VAR 0 1
89023: PUSH
89024: LD_EXP 38
89028: PUSH
89029: LD_VAR 0 3
89033: ARRAY
89034: IN
89035: OR
89036: PUSH
89037: LD_VAR 0 1
89041: PUSH
89042: LD_EXP 53
89046: PUSH
89047: LD_VAR 0 3
89051: ARRAY
89052: IN
89053: OR
89054: PUSH
89055: LD_VAR 0 1
89059: PUSH
89060: LD_EXP 50
89064: PUSH
89065: LD_VAR 0 3
89069: ARRAY
89070: IN
89071: OR
89072: PUSH
89073: LD_VAR 0 1
89077: PUSH
89078: LD_EXP 60
89082: PUSH
89083: LD_VAR 0 3
89087: ARRAY
89088: IN
89089: OR
89090: PUSH
89091: LD_VAR 0 1
89095: PUSH
89096: LD_EXP 61
89100: PUSH
89101: LD_VAR 0 3
89105: ARRAY
89106: IN
89107: OR
89108: IFFALSE 90349
// begin if un in mc_ape [ i ] then
89110: LD_VAR 0 1
89114: PUSH
89115: LD_EXP 60
89119: PUSH
89120: LD_VAR 0 3
89124: ARRAY
89125: IN
89126: IFFALSE 89165
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89128: LD_ADDR_EXP 60
89132: PUSH
89133: LD_EXP 60
89137: PPUSH
89138: LD_VAR 0 3
89142: PPUSH
89143: LD_EXP 60
89147: PUSH
89148: LD_VAR 0 3
89152: ARRAY
89153: PUSH
89154: LD_VAR 0 1
89158: DIFF
89159: PPUSH
89160: CALL_OW 1
89164: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89165: LD_VAR 0 1
89169: PUSH
89170: LD_EXP 61
89174: PUSH
89175: LD_VAR 0 3
89179: ARRAY
89180: IN
89181: IFFALSE 89205
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89183: LD_ADDR_EXP 61
89187: PUSH
89188: LD_EXP 61
89192: PPUSH
89193: LD_VAR 0 3
89197: PPUSH
89198: EMPTY
89199: PPUSH
89200: CALL_OW 1
89204: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89205: LD_VAR 0 1
89209: PPUSH
89210: CALL_OW 247
89214: PUSH
89215: LD_INT 2
89217: EQUAL
89218: PUSH
89219: LD_VAR 0 1
89223: PPUSH
89224: CALL_OW 110
89228: PUSH
89229: LD_INT 20
89231: EQUAL
89232: PUSH
89233: LD_VAR 0 1
89237: PUSH
89238: LD_EXP 53
89242: PUSH
89243: LD_VAR 0 3
89247: ARRAY
89248: IN
89249: OR
89250: PUSH
89251: LD_VAR 0 1
89255: PPUSH
89256: CALL_OW 264
89260: PUSH
89261: LD_INT 12
89263: PUSH
89264: LD_INT 51
89266: PUSH
89267: LD_INT 89
89269: PUSH
89270: LD_INT 32
89272: PUSH
89273: LD_INT 13
89275: PUSH
89276: LD_INT 52
89278: PUSH
89279: LD_INT 31
89281: PUSH
89282: EMPTY
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: IN
89291: OR
89292: AND
89293: IFFALSE 89601
// begin if un in mc_defender [ i ] then
89295: LD_VAR 0 1
89299: PUSH
89300: LD_EXP 53
89304: PUSH
89305: LD_VAR 0 3
89309: ARRAY
89310: IN
89311: IFFALSE 89350
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89313: LD_ADDR_EXP 53
89317: PUSH
89318: LD_EXP 53
89322: PPUSH
89323: LD_VAR 0 3
89327: PPUSH
89328: LD_EXP 53
89332: PUSH
89333: LD_VAR 0 3
89337: ARRAY
89338: PUSH
89339: LD_VAR 0 1
89343: DIFF
89344: PPUSH
89345: CALL_OW 1
89349: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89350: LD_ADDR_VAR 0 8
89354: PUSH
89355: LD_VAR 0 3
89359: PPUSH
89360: LD_INT 3
89362: PPUSH
89363: CALL 85971 0 2
89367: ST_TO_ADDR
// if fac then
89368: LD_VAR 0 8
89372: IFFALSE 89601
// begin for j in fac do
89374: LD_ADDR_VAR 0 4
89378: PUSH
89379: LD_VAR 0 8
89383: PUSH
89384: FOR_IN
89385: IFFALSE 89599
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89387: LD_ADDR_VAR 0 9
89391: PUSH
89392: LD_VAR 0 8
89396: PPUSH
89397: LD_VAR 0 1
89401: PPUSH
89402: CALL_OW 265
89406: PPUSH
89407: LD_VAR 0 1
89411: PPUSH
89412: CALL_OW 262
89416: PPUSH
89417: LD_VAR 0 1
89421: PPUSH
89422: CALL_OW 263
89426: PPUSH
89427: LD_VAR 0 1
89431: PPUSH
89432: CALL_OW 264
89436: PPUSH
89437: CALL 22344 0 5
89441: ST_TO_ADDR
// if components then
89442: LD_VAR 0 9
89446: IFFALSE 89597
// begin if GetWeapon ( un ) = ar_control_tower then
89448: LD_VAR 0 1
89452: PPUSH
89453: CALL_OW 264
89457: PUSH
89458: LD_INT 31
89460: EQUAL
89461: IFFALSE 89578
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89463: LD_VAR 0 1
89467: PPUSH
89468: CALL_OW 311
89472: PPUSH
89473: LD_INT 0
89475: PPUSH
89476: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89480: LD_ADDR_EXP 71
89484: PUSH
89485: LD_EXP 71
89489: PPUSH
89490: LD_VAR 0 3
89494: PPUSH
89495: LD_EXP 71
89499: PUSH
89500: LD_VAR 0 3
89504: ARRAY
89505: PUSH
89506: LD_VAR 0 1
89510: PPUSH
89511: CALL_OW 311
89515: DIFF
89516: PPUSH
89517: CALL_OW 1
89521: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89522: LD_ADDR_VAR 0 7
89526: PUSH
89527: LD_EXP 52
89531: PUSH
89532: LD_VAR 0 3
89536: ARRAY
89537: PPUSH
89538: LD_INT 1
89540: PPUSH
89541: LD_VAR 0 9
89545: PPUSH
89546: CALL_OW 2
89550: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89551: LD_ADDR_EXP 52
89555: PUSH
89556: LD_EXP 52
89560: PPUSH
89561: LD_VAR 0 3
89565: PPUSH
89566: LD_VAR 0 7
89570: PPUSH
89571: CALL_OW 1
89575: ST_TO_ADDR
// end else
89576: GO 89595
// MC_InsertProduceList ( i , [ components ] ) ;
89578: LD_VAR 0 3
89582: PPUSH
89583: LD_VAR 0 9
89587: PUSH
89588: EMPTY
89589: LIST
89590: PPUSH
89591: CALL 85516 0 2
// break ;
89595: GO 89599
// end ; end ;
89597: GO 89384
89599: POP
89600: POP
// end ; end ; if GetType ( un ) = unit_building then
89601: LD_VAR 0 1
89605: PPUSH
89606: CALL_OW 247
89610: PUSH
89611: LD_INT 3
89613: EQUAL
89614: IFFALSE 90017
// begin btype := GetBType ( un ) ;
89616: LD_ADDR_VAR 0 5
89620: PUSH
89621: LD_VAR 0 1
89625: PPUSH
89626: CALL_OW 266
89630: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89631: LD_VAR 0 5
89635: PUSH
89636: LD_INT 29
89638: PUSH
89639: LD_INT 30
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: IN
89646: IFFALSE 89719
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89648: LD_VAR 0 1
89652: PPUSH
89653: CALL_OW 250
89657: PPUSH
89658: LD_VAR 0 1
89662: PPUSH
89663: CALL_OW 251
89667: PPUSH
89668: LD_VAR 0 1
89672: PPUSH
89673: CALL_OW 255
89677: PPUSH
89678: CALL_OW 440
89682: NOT
89683: IFFALSE 89719
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89685: LD_VAR 0 1
89689: PPUSH
89690: CALL_OW 250
89694: PPUSH
89695: LD_VAR 0 1
89699: PPUSH
89700: CALL_OW 251
89704: PPUSH
89705: LD_VAR 0 1
89709: PPUSH
89710: CALL_OW 255
89714: PPUSH
89715: CALL_OW 441
// end ; if btype = b_warehouse then
89719: LD_VAR 0 5
89723: PUSH
89724: LD_INT 1
89726: EQUAL
89727: IFFALSE 89745
// begin btype := b_depot ;
89729: LD_ADDR_VAR 0 5
89733: PUSH
89734: LD_INT 0
89736: ST_TO_ADDR
// pos := 1 ;
89737: LD_ADDR_VAR 0 6
89741: PUSH
89742: LD_INT 1
89744: ST_TO_ADDR
// end ; if btype = b_factory then
89745: LD_VAR 0 5
89749: PUSH
89750: LD_INT 3
89752: EQUAL
89753: IFFALSE 89771
// begin btype := b_workshop ;
89755: LD_ADDR_VAR 0 5
89759: PUSH
89760: LD_INT 2
89762: ST_TO_ADDR
// pos := 1 ;
89763: LD_ADDR_VAR 0 6
89767: PUSH
89768: LD_INT 1
89770: ST_TO_ADDR
// end ; if btype = b_barracks then
89771: LD_VAR 0 5
89775: PUSH
89776: LD_INT 5
89778: EQUAL
89779: IFFALSE 89789
// btype := b_armoury ;
89781: LD_ADDR_VAR 0 5
89785: PUSH
89786: LD_INT 4
89788: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89789: LD_VAR 0 5
89793: PUSH
89794: LD_INT 7
89796: PUSH
89797: LD_INT 8
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: IN
89804: IFFALSE 89814
// btype := b_lab ;
89806: LD_ADDR_VAR 0 5
89810: PUSH
89811: LD_INT 6
89813: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89814: LD_ADDR_EXP 36
89818: PUSH
89819: LD_EXP 36
89823: PPUSH
89824: LD_VAR 0 3
89828: PUSH
89829: LD_EXP 36
89833: PUSH
89834: LD_VAR 0 3
89838: ARRAY
89839: PUSH
89840: LD_INT 1
89842: PLUS
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: PPUSH
89848: LD_VAR 0 5
89852: PUSH
89853: LD_VAR 0 1
89857: PPUSH
89858: CALL_OW 250
89862: PUSH
89863: LD_VAR 0 1
89867: PPUSH
89868: CALL_OW 251
89872: PUSH
89873: LD_VAR 0 1
89877: PPUSH
89878: CALL_OW 254
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: PPUSH
89889: CALL 24846 0 3
89893: ST_TO_ADDR
// if pos = 1 then
89894: LD_VAR 0 6
89898: PUSH
89899: LD_INT 1
89901: EQUAL
89902: IFFALSE 90017
// begin tmp := mc_build_list [ i ] ;
89904: LD_ADDR_VAR 0 7
89908: PUSH
89909: LD_EXP 36
89913: PUSH
89914: LD_VAR 0 3
89918: ARRAY
89919: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89920: LD_VAR 0 7
89924: PPUSH
89925: LD_INT 2
89927: PUSH
89928: LD_INT 30
89930: PUSH
89931: LD_INT 0
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: PUSH
89938: LD_INT 30
89940: PUSH
89941: LD_INT 1
89943: PUSH
89944: EMPTY
89945: LIST
89946: LIST
89947: PUSH
89948: EMPTY
89949: LIST
89950: LIST
89951: LIST
89952: PPUSH
89953: CALL_OW 72
89957: IFFALSE 89967
// pos := 2 ;
89959: LD_ADDR_VAR 0 6
89963: PUSH
89964: LD_INT 2
89966: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
89967: LD_ADDR_VAR 0 7
89971: PUSH
89972: LD_VAR 0 7
89976: PPUSH
89977: LD_VAR 0 6
89981: PPUSH
89982: LD_VAR 0 7
89986: PPUSH
89987: CALL 25172 0 3
89991: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
89992: LD_ADDR_EXP 36
89996: PUSH
89997: LD_EXP 36
90001: PPUSH
90002: LD_VAR 0 3
90006: PPUSH
90007: LD_VAR 0 7
90011: PPUSH
90012: CALL_OW 1
90016: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
90017: LD_VAR 0 1
90021: PUSH
90022: LD_EXP 31
90026: PUSH
90027: LD_VAR 0 3
90031: ARRAY
90032: IN
90033: IFFALSE 90072
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90035: LD_ADDR_EXP 31
90039: PUSH
90040: LD_EXP 31
90044: PPUSH
90045: LD_VAR 0 3
90049: PPUSH
90050: LD_EXP 31
90054: PUSH
90055: LD_VAR 0 3
90059: ARRAY
90060: PUSH
90061: LD_VAR 0 1
90065: DIFF
90066: PPUSH
90067: CALL_OW 1
90071: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90072: LD_VAR 0 1
90076: PUSH
90077: LD_EXP 38
90081: PUSH
90082: LD_VAR 0 3
90086: ARRAY
90087: IN
90088: IFFALSE 90127
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90090: LD_ADDR_EXP 38
90094: PUSH
90095: LD_EXP 38
90099: PPUSH
90100: LD_VAR 0 3
90104: PPUSH
90105: LD_EXP 38
90109: PUSH
90110: LD_VAR 0 3
90114: ARRAY
90115: PUSH
90116: LD_VAR 0 1
90120: DIFF
90121: PPUSH
90122: CALL_OW 1
90126: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90127: LD_VAR 0 1
90131: PUSH
90132: LD_EXP 50
90136: PUSH
90137: LD_VAR 0 3
90141: ARRAY
90142: IN
90143: IFFALSE 90182
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90145: LD_ADDR_EXP 50
90149: PUSH
90150: LD_EXP 50
90154: PPUSH
90155: LD_VAR 0 3
90159: PPUSH
90160: LD_EXP 50
90164: PUSH
90165: LD_VAR 0 3
90169: ARRAY
90170: PUSH
90171: LD_VAR 0 1
90175: DIFF
90176: PPUSH
90177: CALL_OW 1
90181: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90182: LD_VAR 0 1
90186: PUSH
90187: LD_EXP 53
90191: PUSH
90192: LD_VAR 0 3
90196: ARRAY
90197: IN
90198: IFFALSE 90237
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90200: LD_ADDR_EXP 53
90204: PUSH
90205: LD_EXP 53
90209: PPUSH
90210: LD_VAR 0 3
90214: PPUSH
90215: LD_EXP 53
90219: PUSH
90220: LD_VAR 0 3
90224: ARRAY
90225: PUSH
90226: LD_VAR 0 1
90230: DIFF
90231: PPUSH
90232: CALL_OW 1
90236: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90237: LD_VAR 0 1
90241: PUSH
90242: LD_EXP 40
90246: PUSH
90247: LD_VAR 0 3
90251: ARRAY
90252: IN
90253: IFFALSE 90292
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90255: LD_ADDR_EXP 40
90259: PUSH
90260: LD_EXP 40
90264: PPUSH
90265: LD_VAR 0 3
90269: PPUSH
90270: LD_EXP 40
90274: PUSH
90275: LD_VAR 0 3
90279: ARRAY
90280: PUSH
90281: LD_VAR 0 1
90285: DIFF
90286: PPUSH
90287: CALL_OW 1
90291: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90292: LD_VAR 0 1
90296: PUSH
90297: LD_EXP 39
90301: PUSH
90302: LD_VAR 0 3
90306: ARRAY
90307: IN
90308: IFFALSE 90347
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90310: LD_ADDR_EXP 39
90314: PUSH
90315: LD_EXP 39
90319: PPUSH
90320: LD_VAR 0 3
90324: PPUSH
90325: LD_EXP 39
90329: PUSH
90330: LD_VAR 0 3
90334: ARRAY
90335: PUSH
90336: LD_VAR 0 1
90340: DIFF
90341: PPUSH
90342: CALL_OW 1
90346: ST_TO_ADDR
// end ; break ;
90347: GO 90351
// end ;
90349: GO 88999
90351: POP
90352: POP
// end ;
90353: LD_VAR 0 2
90357: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90358: LD_INT 0
90360: PPUSH
90361: PPUSH
90362: PPUSH
// if not mc_bases or not skirmish then
90363: LD_EXP 31
90367: NOT
90368: PUSH
90369: LD_EXP 29
90373: NOT
90374: OR
90375: IFFALSE 90379
// exit ;
90377: GO 90594
// for i = 1 to mc_bases do
90379: LD_ADDR_VAR 0 3
90383: PUSH
90384: DOUBLE
90385: LD_INT 1
90387: DEC
90388: ST_TO_ADDR
90389: LD_EXP 31
90393: PUSH
90394: FOR_TO
90395: IFFALSE 90592
// begin if building in mc_construct_list [ i ] then
90397: LD_VAR 0 1
90401: PUSH
90402: LD_EXP 38
90406: PUSH
90407: LD_VAR 0 3
90411: ARRAY
90412: IN
90413: IFFALSE 90590
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90415: LD_ADDR_EXP 38
90419: PUSH
90420: LD_EXP 38
90424: PPUSH
90425: LD_VAR 0 3
90429: PPUSH
90430: LD_EXP 38
90434: PUSH
90435: LD_VAR 0 3
90439: ARRAY
90440: PUSH
90441: LD_VAR 0 1
90445: DIFF
90446: PPUSH
90447: CALL_OW 1
90451: ST_TO_ADDR
// if building in mc_lab [ i ] then
90452: LD_VAR 0 1
90456: PUSH
90457: LD_EXP 64
90461: PUSH
90462: LD_VAR 0 3
90466: ARRAY
90467: IN
90468: IFFALSE 90523
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90470: LD_ADDR_EXP 65
90474: PUSH
90475: LD_EXP 65
90479: PPUSH
90480: LD_VAR 0 3
90484: PPUSH
90485: LD_EXP 65
90489: PUSH
90490: LD_VAR 0 3
90494: ARRAY
90495: PPUSH
90496: LD_INT 1
90498: PPUSH
90499: LD_EXP 65
90503: PUSH
90504: LD_VAR 0 3
90508: ARRAY
90509: PPUSH
90510: LD_INT 0
90512: PPUSH
90513: CALL 24264 0 4
90517: PPUSH
90518: CALL_OW 1
90522: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90523: LD_VAR 0 1
90527: PUSH
90528: LD_EXP 31
90532: PUSH
90533: LD_VAR 0 3
90537: ARRAY
90538: IN
90539: NOT
90540: IFFALSE 90586
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90542: LD_ADDR_EXP 31
90546: PUSH
90547: LD_EXP 31
90551: PPUSH
90552: LD_VAR 0 3
90556: PUSH
90557: LD_EXP 31
90561: PUSH
90562: LD_VAR 0 3
90566: ARRAY
90567: PUSH
90568: LD_INT 1
90570: PLUS
90571: PUSH
90572: EMPTY
90573: LIST
90574: LIST
90575: PPUSH
90576: LD_VAR 0 1
90580: PPUSH
90581: CALL 24846 0 3
90585: ST_TO_ADDR
// exit ;
90586: POP
90587: POP
90588: GO 90594
// end ; end ;
90590: GO 90394
90592: POP
90593: POP
// end ;
90594: LD_VAR 0 2
90598: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90599: LD_INT 0
90601: PPUSH
90602: PPUSH
90603: PPUSH
90604: PPUSH
90605: PPUSH
90606: PPUSH
90607: PPUSH
// if not mc_bases or not skirmish then
90608: LD_EXP 31
90612: NOT
90613: PUSH
90614: LD_EXP 29
90618: NOT
90619: OR
90620: IFFALSE 90624
// exit ;
90622: GO 91285
// for i = 1 to mc_bases do
90624: LD_ADDR_VAR 0 3
90628: PUSH
90629: DOUBLE
90630: LD_INT 1
90632: DEC
90633: ST_TO_ADDR
90634: LD_EXP 31
90638: PUSH
90639: FOR_TO
90640: IFFALSE 91283
// begin if building in mc_construct_list [ i ] then
90642: LD_VAR 0 1
90646: PUSH
90647: LD_EXP 38
90651: PUSH
90652: LD_VAR 0 3
90656: ARRAY
90657: IN
90658: IFFALSE 91281
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90660: LD_ADDR_EXP 38
90664: PUSH
90665: LD_EXP 38
90669: PPUSH
90670: LD_VAR 0 3
90674: PPUSH
90675: LD_EXP 38
90679: PUSH
90680: LD_VAR 0 3
90684: ARRAY
90685: PUSH
90686: LD_VAR 0 1
90690: DIFF
90691: PPUSH
90692: CALL_OW 1
90696: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90697: LD_ADDR_EXP 31
90701: PUSH
90702: LD_EXP 31
90706: PPUSH
90707: LD_VAR 0 3
90711: PUSH
90712: LD_EXP 31
90716: PUSH
90717: LD_VAR 0 3
90721: ARRAY
90722: PUSH
90723: LD_INT 1
90725: PLUS
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PPUSH
90731: LD_VAR 0 1
90735: PPUSH
90736: CALL 24846 0 3
90740: ST_TO_ADDR
// btype := GetBType ( building ) ;
90741: LD_ADDR_VAR 0 5
90745: PUSH
90746: LD_VAR 0 1
90750: PPUSH
90751: CALL_OW 266
90755: ST_TO_ADDR
// side := GetSide ( building ) ;
90756: LD_ADDR_VAR 0 8
90760: PUSH
90761: LD_VAR 0 1
90765: PPUSH
90766: CALL_OW 255
90770: ST_TO_ADDR
// if btype = b_lab then
90771: LD_VAR 0 5
90775: PUSH
90776: LD_INT 6
90778: EQUAL
90779: IFFALSE 90829
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90781: LD_ADDR_EXP 64
90785: PUSH
90786: LD_EXP 64
90790: PPUSH
90791: LD_VAR 0 3
90795: PUSH
90796: LD_EXP 64
90800: PUSH
90801: LD_VAR 0 3
90805: ARRAY
90806: PUSH
90807: LD_INT 1
90809: PLUS
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PPUSH
90815: LD_VAR 0 1
90819: PPUSH
90820: CALL 24846 0 3
90824: ST_TO_ADDR
// exit ;
90825: POP
90826: POP
90827: GO 91285
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90829: LD_VAR 0 5
90833: PUSH
90834: LD_INT 0
90836: PUSH
90837: LD_INT 2
90839: PUSH
90840: LD_INT 4
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: LIST
90847: IN
90848: IFFALSE 90972
// begin if btype = b_armoury then
90850: LD_VAR 0 5
90854: PUSH
90855: LD_INT 4
90857: EQUAL
90858: IFFALSE 90868
// btype := b_barracks ;
90860: LD_ADDR_VAR 0 5
90864: PUSH
90865: LD_INT 5
90867: ST_TO_ADDR
// if btype = b_depot then
90868: LD_VAR 0 5
90872: PUSH
90873: LD_INT 0
90875: EQUAL
90876: IFFALSE 90886
// btype := b_warehouse ;
90878: LD_ADDR_VAR 0 5
90882: PUSH
90883: LD_INT 1
90885: ST_TO_ADDR
// if btype = b_workshop then
90886: LD_VAR 0 5
90890: PUSH
90891: LD_INT 2
90893: EQUAL
90894: IFFALSE 90904
// btype := b_factory ;
90896: LD_ADDR_VAR 0 5
90900: PUSH
90901: LD_INT 3
90903: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90904: LD_VAR 0 5
90908: PPUSH
90909: LD_VAR 0 8
90913: PPUSH
90914: CALL_OW 323
90918: PUSH
90919: LD_INT 1
90921: EQUAL
90922: IFFALSE 90968
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90924: LD_ADDR_EXP 63
90928: PUSH
90929: LD_EXP 63
90933: PPUSH
90934: LD_VAR 0 3
90938: PUSH
90939: LD_EXP 63
90943: PUSH
90944: LD_VAR 0 3
90948: ARRAY
90949: PUSH
90950: LD_INT 1
90952: PLUS
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PPUSH
90958: LD_VAR 0 1
90962: PPUSH
90963: CALL 24846 0 3
90967: ST_TO_ADDR
// exit ;
90968: POP
90969: POP
90970: GO 91285
// end ; if btype in [ b_bunker , b_turret ] then
90972: LD_VAR 0 5
90976: PUSH
90977: LD_INT 32
90979: PUSH
90980: LD_INT 33
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: IN
90987: IFFALSE 91277
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
90989: LD_ADDR_EXP 39
90993: PUSH
90994: LD_EXP 39
90998: PPUSH
90999: LD_VAR 0 3
91003: PUSH
91004: LD_EXP 39
91008: PUSH
91009: LD_VAR 0 3
91013: ARRAY
91014: PUSH
91015: LD_INT 1
91017: PLUS
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PPUSH
91023: LD_VAR 0 1
91027: PPUSH
91028: CALL 24846 0 3
91032: ST_TO_ADDR
// if btype = b_bunker then
91033: LD_VAR 0 5
91037: PUSH
91038: LD_INT 32
91040: EQUAL
91041: IFFALSE 91277
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91043: LD_ADDR_EXP 40
91047: PUSH
91048: LD_EXP 40
91052: PPUSH
91053: LD_VAR 0 3
91057: PUSH
91058: LD_EXP 40
91062: PUSH
91063: LD_VAR 0 3
91067: ARRAY
91068: PUSH
91069: LD_INT 1
91071: PLUS
91072: PUSH
91073: EMPTY
91074: LIST
91075: LIST
91076: PPUSH
91077: LD_VAR 0 1
91081: PPUSH
91082: CALL 24846 0 3
91086: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91087: LD_ADDR_VAR 0 6
91091: PUSH
91092: LD_EXP 31
91096: PUSH
91097: LD_VAR 0 3
91101: ARRAY
91102: PPUSH
91103: LD_INT 25
91105: PUSH
91106: LD_INT 1
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: PUSH
91113: LD_INT 3
91115: PUSH
91116: LD_INT 54
91118: PUSH
91119: EMPTY
91120: LIST
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PPUSH
91130: CALL_OW 72
91134: ST_TO_ADDR
// if tmp then
91135: LD_VAR 0 6
91139: IFFALSE 91145
// exit ;
91141: POP
91142: POP
91143: GO 91285
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91145: LD_ADDR_VAR 0 6
91149: PUSH
91150: LD_EXP 31
91154: PUSH
91155: LD_VAR 0 3
91159: ARRAY
91160: PPUSH
91161: LD_INT 2
91163: PUSH
91164: LD_INT 30
91166: PUSH
91167: LD_INT 4
91169: PUSH
91170: EMPTY
91171: LIST
91172: LIST
91173: PUSH
91174: LD_INT 30
91176: PUSH
91177: LD_INT 5
91179: PUSH
91180: EMPTY
91181: LIST
91182: LIST
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: LIST
91188: PPUSH
91189: CALL_OW 72
91193: ST_TO_ADDR
// if not tmp then
91194: LD_VAR 0 6
91198: NOT
91199: IFFALSE 91205
// exit ;
91201: POP
91202: POP
91203: GO 91285
// for j in tmp do
91205: LD_ADDR_VAR 0 4
91209: PUSH
91210: LD_VAR 0 6
91214: PUSH
91215: FOR_IN
91216: IFFALSE 91275
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91218: LD_ADDR_VAR 0 7
91222: PUSH
91223: LD_VAR 0 4
91227: PPUSH
91228: CALL_OW 313
91232: PPUSH
91233: LD_INT 25
91235: PUSH
91236: LD_INT 1
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PPUSH
91243: CALL_OW 72
91247: ST_TO_ADDR
// if units then
91248: LD_VAR 0 7
91252: IFFALSE 91273
// begin ComExitBuilding ( units [ 1 ] ) ;
91254: LD_VAR 0 7
91258: PUSH
91259: LD_INT 1
91261: ARRAY
91262: PPUSH
91263: CALL_OW 122
// exit ;
91267: POP
91268: POP
91269: POP
91270: POP
91271: GO 91285
// end ; end ;
91273: GO 91215
91275: POP
91276: POP
// end ; end ; exit ;
91277: POP
91278: POP
91279: GO 91285
// end ; end ;
91281: GO 90639
91283: POP
91284: POP
// end ;
91285: LD_VAR 0 2
91289: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91290: LD_INT 0
91292: PPUSH
91293: PPUSH
91294: PPUSH
91295: PPUSH
91296: PPUSH
91297: PPUSH
91298: PPUSH
// if not mc_bases or not skirmish then
91299: LD_EXP 31
91303: NOT
91304: PUSH
91305: LD_EXP 29
91309: NOT
91310: OR
91311: IFFALSE 91315
// exit ;
91313: GO 91580
// btype := GetBType ( building ) ;
91315: LD_ADDR_VAR 0 6
91319: PUSH
91320: LD_VAR 0 1
91324: PPUSH
91325: CALL_OW 266
91329: ST_TO_ADDR
// x := GetX ( building ) ;
91330: LD_ADDR_VAR 0 7
91334: PUSH
91335: LD_VAR 0 1
91339: PPUSH
91340: CALL_OW 250
91344: ST_TO_ADDR
// y := GetY ( building ) ;
91345: LD_ADDR_VAR 0 8
91349: PUSH
91350: LD_VAR 0 1
91354: PPUSH
91355: CALL_OW 251
91359: ST_TO_ADDR
// d := GetDir ( building ) ;
91360: LD_ADDR_VAR 0 9
91364: PUSH
91365: LD_VAR 0 1
91369: PPUSH
91370: CALL_OW 254
91374: ST_TO_ADDR
// for i = 1 to mc_bases do
91375: LD_ADDR_VAR 0 4
91379: PUSH
91380: DOUBLE
91381: LD_INT 1
91383: DEC
91384: ST_TO_ADDR
91385: LD_EXP 31
91389: PUSH
91390: FOR_TO
91391: IFFALSE 91578
// begin if not mc_build_list [ i ] then
91393: LD_EXP 36
91397: PUSH
91398: LD_VAR 0 4
91402: ARRAY
91403: NOT
91404: IFFALSE 91408
// continue ;
91406: GO 91390
// for j := 1 to mc_build_list [ i ] do
91408: LD_ADDR_VAR 0 5
91412: PUSH
91413: DOUBLE
91414: LD_INT 1
91416: DEC
91417: ST_TO_ADDR
91418: LD_EXP 36
91422: PUSH
91423: LD_VAR 0 4
91427: ARRAY
91428: PUSH
91429: FOR_TO
91430: IFFALSE 91574
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91432: LD_VAR 0 6
91436: PUSH
91437: LD_VAR 0 7
91441: PUSH
91442: LD_VAR 0 8
91446: PUSH
91447: LD_VAR 0 9
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: PPUSH
91458: LD_EXP 36
91462: PUSH
91463: LD_VAR 0 4
91467: ARRAY
91468: PUSH
91469: LD_VAR 0 5
91473: ARRAY
91474: PPUSH
91475: CALL 31026 0 2
91479: IFFALSE 91572
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91481: LD_ADDR_EXP 36
91485: PUSH
91486: LD_EXP 36
91490: PPUSH
91491: LD_VAR 0 4
91495: PPUSH
91496: LD_EXP 36
91500: PUSH
91501: LD_VAR 0 4
91505: ARRAY
91506: PPUSH
91507: LD_VAR 0 5
91511: PPUSH
91512: CALL_OW 3
91516: PPUSH
91517: CALL_OW 1
91521: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91522: LD_ADDR_EXP 38
91526: PUSH
91527: LD_EXP 38
91531: PPUSH
91532: LD_VAR 0 4
91536: PUSH
91537: LD_EXP 38
91541: PUSH
91542: LD_VAR 0 4
91546: ARRAY
91547: PUSH
91548: LD_INT 1
91550: PLUS
91551: PUSH
91552: EMPTY
91553: LIST
91554: LIST
91555: PPUSH
91556: LD_VAR 0 1
91560: PPUSH
91561: CALL 24846 0 3
91565: ST_TO_ADDR
// exit ;
91566: POP
91567: POP
91568: POP
91569: POP
91570: GO 91580
// end ;
91572: GO 91429
91574: POP
91575: POP
// end ;
91576: GO 91390
91578: POP
91579: POP
// end ;
91580: LD_VAR 0 3
91584: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91585: LD_INT 0
91587: PPUSH
91588: PPUSH
91589: PPUSH
// if not mc_bases or not skirmish then
91590: LD_EXP 31
91594: NOT
91595: PUSH
91596: LD_EXP 29
91600: NOT
91601: OR
91602: IFFALSE 91606
// exit ;
91604: GO 91796
// for i = 1 to mc_bases do
91606: LD_ADDR_VAR 0 4
91610: PUSH
91611: DOUBLE
91612: LD_INT 1
91614: DEC
91615: ST_TO_ADDR
91616: LD_EXP 31
91620: PUSH
91621: FOR_TO
91622: IFFALSE 91709
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91624: LD_VAR 0 1
91628: PUSH
91629: LD_EXP 39
91633: PUSH
91634: LD_VAR 0 4
91638: ARRAY
91639: IN
91640: PUSH
91641: LD_VAR 0 1
91645: PUSH
91646: LD_EXP 40
91650: PUSH
91651: LD_VAR 0 4
91655: ARRAY
91656: IN
91657: NOT
91658: AND
91659: IFFALSE 91707
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91661: LD_ADDR_EXP 40
91665: PUSH
91666: LD_EXP 40
91670: PPUSH
91671: LD_VAR 0 4
91675: PUSH
91676: LD_EXP 40
91680: PUSH
91681: LD_VAR 0 4
91685: ARRAY
91686: PUSH
91687: LD_INT 1
91689: PLUS
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: PPUSH
91695: LD_VAR 0 1
91699: PPUSH
91700: CALL 24846 0 3
91704: ST_TO_ADDR
// break ;
91705: GO 91709
// end ; end ;
91707: GO 91621
91709: POP
91710: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91711: LD_VAR 0 1
91715: PPUSH
91716: CALL_OW 257
91720: PUSH
91721: LD_EXP 57
91725: IN
91726: PUSH
91727: LD_VAR 0 1
91731: PPUSH
91732: CALL_OW 266
91736: PUSH
91737: LD_INT 5
91739: EQUAL
91740: AND
91741: PUSH
91742: LD_VAR 0 2
91746: PPUSH
91747: CALL_OW 110
91751: PUSH
91752: LD_INT 18
91754: NONEQUAL
91755: AND
91756: IFFALSE 91796
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91758: LD_VAR 0 2
91762: PPUSH
91763: CALL_OW 257
91767: PUSH
91768: LD_INT 5
91770: PUSH
91771: LD_INT 8
91773: PUSH
91774: LD_INT 9
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: LIST
91781: IN
91782: IFFALSE 91796
// SetClass ( unit , 1 ) ;
91784: LD_VAR 0 2
91788: PPUSH
91789: LD_INT 1
91791: PPUSH
91792: CALL_OW 336
// end ;
91796: LD_VAR 0 3
91800: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91801: LD_INT 0
91803: PPUSH
91804: PPUSH
// if not mc_bases or not skirmish then
91805: LD_EXP 31
91809: NOT
91810: PUSH
91811: LD_EXP 29
91815: NOT
91816: OR
91817: IFFALSE 91821
// exit ;
91819: GO 91937
// if GetLives ( abandoned_vehicle ) > 250 then
91821: LD_VAR 0 2
91825: PPUSH
91826: CALL_OW 256
91830: PUSH
91831: LD_INT 250
91833: GREATER
91834: IFFALSE 91838
// exit ;
91836: GO 91937
// for i = 1 to mc_bases do
91838: LD_ADDR_VAR 0 6
91842: PUSH
91843: DOUBLE
91844: LD_INT 1
91846: DEC
91847: ST_TO_ADDR
91848: LD_EXP 31
91852: PUSH
91853: FOR_TO
91854: IFFALSE 91935
// begin if driver in mc_bases [ i ] then
91856: LD_VAR 0 1
91860: PUSH
91861: LD_EXP 31
91865: PUSH
91866: LD_VAR 0 6
91870: ARRAY
91871: IN
91872: IFFALSE 91933
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91874: LD_VAR 0 1
91878: PPUSH
91879: LD_EXP 31
91883: PUSH
91884: LD_VAR 0 6
91888: ARRAY
91889: PPUSH
91890: LD_INT 2
91892: PUSH
91893: LD_INT 30
91895: PUSH
91896: LD_INT 0
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 30
91905: PUSH
91906: LD_INT 1
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: LIST
91917: PPUSH
91918: CALL_OW 72
91922: PUSH
91923: LD_INT 1
91925: ARRAY
91926: PPUSH
91927: CALL 58053 0 2
// break ;
91931: GO 91935
// end ; end ;
91933: GO 91853
91935: POP
91936: POP
// end ; end_of_file end_of_file
91937: LD_VAR 0 5
91941: RET
// export globalGameSaveCounter ; every 0 0$1 do
91942: GO 91944
91944: DISABLE
// begin enable ;
91945: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91946: LD_STRING updateTimer(
91948: PUSH
91949: LD_OWVAR 1
91953: STR
91954: PUSH
91955: LD_STRING );
91957: STR
91958: PPUSH
91959: CALL_OW 559
// end ;
91963: END
// every 0 0$1 do
91964: GO 91966
91966: DISABLE
// begin globalGameSaveCounter := 0 ;
91967: LD_ADDR_EXP 76
91971: PUSH
91972: LD_INT 0
91974: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
91975: LD_STRING setGameSaveCounter(0)
91977: PPUSH
91978: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
91982: LD_STRING initStreamRollete();
91984: PPUSH
91985: CALL_OW 559
// InitStreamMode ;
91989: CALL 93315 0 0
// DefineStreamItems ( false ) ;
91993: LD_INT 0
91995: PPUSH
91996: CALL 93779 0 1
// end ;
92000: END
// export function SOS_MapStart ( ) ; begin
92001: LD_INT 0
92003: PPUSH
// if streamModeActive then
92004: LD_EXP 77
92008: IFFALSE 92017
// DefineStreamItems ( true ) ;
92010: LD_INT 1
92012: PPUSH
92013: CALL 93779 0 1
// UpdateLuaVariables ( ) ;
92017: CALL 92034 0 0
// UpdateFactoryWaypoints ( ) ;
92021: CALL 106640 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92025: CALL 106897 0 0
// end ;
92029: LD_VAR 0 1
92033: RET
// function UpdateLuaVariables ( ) ; begin
92034: LD_INT 0
92036: PPUSH
// if globalGameSaveCounter then
92037: LD_EXP 76
92041: IFFALSE 92075
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92043: LD_ADDR_EXP 76
92047: PUSH
92048: LD_EXP 76
92052: PPUSH
92053: CALL 58537 0 1
92057: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92058: LD_STRING setGameSaveCounter(
92060: PUSH
92061: LD_EXP 76
92065: STR
92066: PUSH
92067: LD_STRING )
92069: STR
92070: PPUSH
92071: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92075: LD_STRING setGameDifficulty(
92077: PUSH
92078: LD_OWVAR 67
92082: STR
92083: PUSH
92084: LD_STRING )
92086: STR
92087: PPUSH
92088: CALL_OW 559
// end ;
92092: LD_VAR 0 1
92096: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92097: LD_INT 0
92099: PPUSH
// if p2 = stream_mode then
92100: LD_VAR 0 2
92104: PUSH
92105: LD_INT 100
92107: EQUAL
92108: IFFALSE 93111
// begin if not StreamModeActive then
92110: LD_EXP 77
92114: NOT
92115: IFFALSE 92125
// StreamModeActive := true ;
92117: LD_ADDR_EXP 77
92121: PUSH
92122: LD_INT 1
92124: ST_TO_ADDR
// if p3 = 0 then
92125: LD_VAR 0 3
92129: PUSH
92130: LD_INT 0
92132: EQUAL
92133: IFFALSE 92139
// InitStreamMode ;
92135: CALL 93315 0 0
// if p3 = 1 then
92139: LD_VAR 0 3
92143: PUSH
92144: LD_INT 1
92146: EQUAL
92147: IFFALSE 92157
// sRocket := true ;
92149: LD_ADDR_EXP 82
92153: PUSH
92154: LD_INT 1
92156: ST_TO_ADDR
// if p3 = 2 then
92157: LD_VAR 0 3
92161: PUSH
92162: LD_INT 2
92164: EQUAL
92165: IFFALSE 92175
// sSpeed := true ;
92167: LD_ADDR_EXP 81
92171: PUSH
92172: LD_INT 1
92174: ST_TO_ADDR
// if p3 = 3 then
92175: LD_VAR 0 3
92179: PUSH
92180: LD_INT 3
92182: EQUAL
92183: IFFALSE 92193
// sEngine := true ;
92185: LD_ADDR_EXP 83
92189: PUSH
92190: LD_INT 1
92192: ST_TO_ADDR
// if p3 = 4 then
92193: LD_VAR 0 3
92197: PUSH
92198: LD_INT 4
92200: EQUAL
92201: IFFALSE 92211
// sSpec := true ;
92203: LD_ADDR_EXP 80
92207: PUSH
92208: LD_INT 1
92210: ST_TO_ADDR
// if p3 = 5 then
92211: LD_VAR 0 3
92215: PUSH
92216: LD_INT 5
92218: EQUAL
92219: IFFALSE 92229
// sLevel := true ;
92221: LD_ADDR_EXP 84
92225: PUSH
92226: LD_INT 1
92228: ST_TO_ADDR
// if p3 = 6 then
92229: LD_VAR 0 3
92233: PUSH
92234: LD_INT 6
92236: EQUAL
92237: IFFALSE 92247
// sArmoury := true ;
92239: LD_ADDR_EXP 85
92243: PUSH
92244: LD_INT 1
92246: ST_TO_ADDR
// if p3 = 7 then
92247: LD_VAR 0 3
92251: PUSH
92252: LD_INT 7
92254: EQUAL
92255: IFFALSE 92265
// sRadar := true ;
92257: LD_ADDR_EXP 86
92261: PUSH
92262: LD_INT 1
92264: ST_TO_ADDR
// if p3 = 8 then
92265: LD_VAR 0 3
92269: PUSH
92270: LD_INT 8
92272: EQUAL
92273: IFFALSE 92283
// sBunker := true ;
92275: LD_ADDR_EXP 87
92279: PUSH
92280: LD_INT 1
92282: ST_TO_ADDR
// if p3 = 9 then
92283: LD_VAR 0 3
92287: PUSH
92288: LD_INT 9
92290: EQUAL
92291: IFFALSE 92301
// sHack := true ;
92293: LD_ADDR_EXP 88
92297: PUSH
92298: LD_INT 1
92300: ST_TO_ADDR
// if p3 = 10 then
92301: LD_VAR 0 3
92305: PUSH
92306: LD_INT 10
92308: EQUAL
92309: IFFALSE 92319
// sFire := true ;
92311: LD_ADDR_EXP 89
92315: PUSH
92316: LD_INT 1
92318: ST_TO_ADDR
// if p3 = 11 then
92319: LD_VAR 0 3
92323: PUSH
92324: LD_INT 11
92326: EQUAL
92327: IFFALSE 92337
// sRefresh := true ;
92329: LD_ADDR_EXP 90
92333: PUSH
92334: LD_INT 1
92336: ST_TO_ADDR
// if p3 = 12 then
92337: LD_VAR 0 3
92341: PUSH
92342: LD_INT 12
92344: EQUAL
92345: IFFALSE 92355
// sExp := true ;
92347: LD_ADDR_EXP 91
92351: PUSH
92352: LD_INT 1
92354: ST_TO_ADDR
// if p3 = 13 then
92355: LD_VAR 0 3
92359: PUSH
92360: LD_INT 13
92362: EQUAL
92363: IFFALSE 92373
// sDepot := true ;
92365: LD_ADDR_EXP 92
92369: PUSH
92370: LD_INT 1
92372: ST_TO_ADDR
// if p3 = 14 then
92373: LD_VAR 0 3
92377: PUSH
92378: LD_INT 14
92380: EQUAL
92381: IFFALSE 92391
// sFlag := true ;
92383: LD_ADDR_EXP 93
92387: PUSH
92388: LD_INT 1
92390: ST_TO_ADDR
// if p3 = 15 then
92391: LD_VAR 0 3
92395: PUSH
92396: LD_INT 15
92398: EQUAL
92399: IFFALSE 92409
// sKamikadze := true ;
92401: LD_ADDR_EXP 101
92405: PUSH
92406: LD_INT 1
92408: ST_TO_ADDR
// if p3 = 16 then
92409: LD_VAR 0 3
92413: PUSH
92414: LD_INT 16
92416: EQUAL
92417: IFFALSE 92427
// sTroll := true ;
92419: LD_ADDR_EXP 102
92423: PUSH
92424: LD_INT 1
92426: ST_TO_ADDR
// if p3 = 17 then
92427: LD_VAR 0 3
92431: PUSH
92432: LD_INT 17
92434: EQUAL
92435: IFFALSE 92445
// sSlow := true ;
92437: LD_ADDR_EXP 103
92441: PUSH
92442: LD_INT 1
92444: ST_TO_ADDR
// if p3 = 18 then
92445: LD_VAR 0 3
92449: PUSH
92450: LD_INT 18
92452: EQUAL
92453: IFFALSE 92463
// sLack := true ;
92455: LD_ADDR_EXP 104
92459: PUSH
92460: LD_INT 1
92462: ST_TO_ADDR
// if p3 = 19 then
92463: LD_VAR 0 3
92467: PUSH
92468: LD_INT 19
92470: EQUAL
92471: IFFALSE 92481
// sTank := true ;
92473: LD_ADDR_EXP 106
92477: PUSH
92478: LD_INT 1
92480: ST_TO_ADDR
// if p3 = 20 then
92481: LD_VAR 0 3
92485: PUSH
92486: LD_INT 20
92488: EQUAL
92489: IFFALSE 92499
// sRemote := true ;
92491: LD_ADDR_EXP 107
92495: PUSH
92496: LD_INT 1
92498: ST_TO_ADDR
// if p3 = 21 then
92499: LD_VAR 0 3
92503: PUSH
92504: LD_INT 21
92506: EQUAL
92507: IFFALSE 92517
// sPowell := true ;
92509: LD_ADDR_EXP 108
92513: PUSH
92514: LD_INT 1
92516: ST_TO_ADDR
// if p3 = 22 then
92517: LD_VAR 0 3
92521: PUSH
92522: LD_INT 22
92524: EQUAL
92525: IFFALSE 92535
// sTeleport := true ;
92527: LD_ADDR_EXP 111
92531: PUSH
92532: LD_INT 1
92534: ST_TO_ADDR
// if p3 = 23 then
92535: LD_VAR 0 3
92539: PUSH
92540: LD_INT 23
92542: EQUAL
92543: IFFALSE 92553
// sOilTower := true ;
92545: LD_ADDR_EXP 113
92549: PUSH
92550: LD_INT 1
92552: ST_TO_ADDR
// if p3 = 24 then
92553: LD_VAR 0 3
92557: PUSH
92558: LD_INT 24
92560: EQUAL
92561: IFFALSE 92571
// sShovel := true ;
92563: LD_ADDR_EXP 114
92567: PUSH
92568: LD_INT 1
92570: ST_TO_ADDR
// if p3 = 25 then
92571: LD_VAR 0 3
92575: PUSH
92576: LD_INT 25
92578: EQUAL
92579: IFFALSE 92589
// sSheik := true ;
92581: LD_ADDR_EXP 115
92585: PUSH
92586: LD_INT 1
92588: ST_TO_ADDR
// if p3 = 26 then
92589: LD_VAR 0 3
92593: PUSH
92594: LD_INT 26
92596: EQUAL
92597: IFFALSE 92607
// sEarthquake := true ;
92599: LD_ADDR_EXP 117
92603: PUSH
92604: LD_INT 1
92606: ST_TO_ADDR
// if p3 = 27 then
92607: LD_VAR 0 3
92611: PUSH
92612: LD_INT 27
92614: EQUAL
92615: IFFALSE 92625
// sAI := true ;
92617: LD_ADDR_EXP 118
92621: PUSH
92622: LD_INT 1
92624: ST_TO_ADDR
// if p3 = 28 then
92625: LD_VAR 0 3
92629: PUSH
92630: LD_INT 28
92632: EQUAL
92633: IFFALSE 92643
// sCargo := true ;
92635: LD_ADDR_EXP 121
92639: PUSH
92640: LD_INT 1
92642: ST_TO_ADDR
// if p3 = 29 then
92643: LD_VAR 0 3
92647: PUSH
92648: LD_INT 29
92650: EQUAL
92651: IFFALSE 92661
// sDLaser := true ;
92653: LD_ADDR_EXP 122
92657: PUSH
92658: LD_INT 1
92660: ST_TO_ADDR
// if p3 = 30 then
92661: LD_VAR 0 3
92665: PUSH
92666: LD_INT 30
92668: EQUAL
92669: IFFALSE 92679
// sExchange := true ;
92671: LD_ADDR_EXP 123
92675: PUSH
92676: LD_INT 1
92678: ST_TO_ADDR
// if p3 = 31 then
92679: LD_VAR 0 3
92683: PUSH
92684: LD_INT 31
92686: EQUAL
92687: IFFALSE 92697
// sFac := true ;
92689: LD_ADDR_EXP 124
92693: PUSH
92694: LD_INT 1
92696: ST_TO_ADDR
// if p3 = 32 then
92697: LD_VAR 0 3
92701: PUSH
92702: LD_INT 32
92704: EQUAL
92705: IFFALSE 92715
// sPower := true ;
92707: LD_ADDR_EXP 125
92711: PUSH
92712: LD_INT 1
92714: ST_TO_ADDR
// if p3 = 33 then
92715: LD_VAR 0 3
92719: PUSH
92720: LD_INT 33
92722: EQUAL
92723: IFFALSE 92733
// sRandom := true ;
92725: LD_ADDR_EXP 126
92729: PUSH
92730: LD_INT 1
92732: ST_TO_ADDR
// if p3 = 34 then
92733: LD_VAR 0 3
92737: PUSH
92738: LD_INT 34
92740: EQUAL
92741: IFFALSE 92751
// sShield := true ;
92743: LD_ADDR_EXP 127
92747: PUSH
92748: LD_INT 1
92750: ST_TO_ADDR
// if p3 = 35 then
92751: LD_VAR 0 3
92755: PUSH
92756: LD_INT 35
92758: EQUAL
92759: IFFALSE 92769
// sTime := true ;
92761: LD_ADDR_EXP 128
92765: PUSH
92766: LD_INT 1
92768: ST_TO_ADDR
// if p3 = 36 then
92769: LD_VAR 0 3
92773: PUSH
92774: LD_INT 36
92776: EQUAL
92777: IFFALSE 92787
// sTools := true ;
92779: LD_ADDR_EXP 129
92783: PUSH
92784: LD_INT 1
92786: ST_TO_ADDR
// if p3 = 101 then
92787: LD_VAR 0 3
92791: PUSH
92792: LD_INT 101
92794: EQUAL
92795: IFFALSE 92805
// sSold := true ;
92797: LD_ADDR_EXP 94
92801: PUSH
92802: LD_INT 1
92804: ST_TO_ADDR
// if p3 = 102 then
92805: LD_VAR 0 3
92809: PUSH
92810: LD_INT 102
92812: EQUAL
92813: IFFALSE 92823
// sDiff := true ;
92815: LD_ADDR_EXP 95
92819: PUSH
92820: LD_INT 1
92822: ST_TO_ADDR
// if p3 = 103 then
92823: LD_VAR 0 3
92827: PUSH
92828: LD_INT 103
92830: EQUAL
92831: IFFALSE 92841
// sFog := true ;
92833: LD_ADDR_EXP 98
92837: PUSH
92838: LD_INT 1
92840: ST_TO_ADDR
// if p3 = 104 then
92841: LD_VAR 0 3
92845: PUSH
92846: LD_INT 104
92848: EQUAL
92849: IFFALSE 92859
// sReset := true ;
92851: LD_ADDR_EXP 99
92855: PUSH
92856: LD_INT 1
92858: ST_TO_ADDR
// if p3 = 105 then
92859: LD_VAR 0 3
92863: PUSH
92864: LD_INT 105
92866: EQUAL
92867: IFFALSE 92877
// sSun := true ;
92869: LD_ADDR_EXP 100
92873: PUSH
92874: LD_INT 1
92876: ST_TO_ADDR
// if p3 = 106 then
92877: LD_VAR 0 3
92881: PUSH
92882: LD_INT 106
92884: EQUAL
92885: IFFALSE 92895
// sTiger := true ;
92887: LD_ADDR_EXP 96
92891: PUSH
92892: LD_INT 1
92894: ST_TO_ADDR
// if p3 = 107 then
92895: LD_VAR 0 3
92899: PUSH
92900: LD_INT 107
92902: EQUAL
92903: IFFALSE 92913
// sBomb := true ;
92905: LD_ADDR_EXP 97
92909: PUSH
92910: LD_INT 1
92912: ST_TO_ADDR
// if p3 = 108 then
92913: LD_VAR 0 3
92917: PUSH
92918: LD_INT 108
92920: EQUAL
92921: IFFALSE 92931
// sWound := true ;
92923: LD_ADDR_EXP 105
92927: PUSH
92928: LD_INT 1
92930: ST_TO_ADDR
// if p3 = 109 then
92931: LD_VAR 0 3
92935: PUSH
92936: LD_INT 109
92938: EQUAL
92939: IFFALSE 92949
// sBetray := true ;
92941: LD_ADDR_EXP 109
92945: PUSH
92946: LD_INT 1
92948: ST_TO_ADDR
// if p3 = 110 then
92949: LD_VAR 0 3
92953: PUSH
92954: LD_INT 110
92956: EQUAL
92957: IFFALSE 92967
// sContamin := true ;
92959: LD_ADDR_EXP 110
92963: PUSH
92964: LD_INT 1
92966: ST_TO_ADDR
// if p3 = 111 then
92967: LD_VAR 0 3
92971: PUSH
92972: LD_INT 111
92974: EQUAL
92975: IFFALSE 92985
// sOil := true ;
92977: LD_ADDR_EXP 112
92981: PUSH
92982: LD_INT 1
92984: ST_TO_ADDR
// if p3 = 112 then
92985: LD_VAR 0 3
92989: PUSH
92990: LD_INT 112
92992: EQUAL
92993: IFFALSE 93003
// sStu := true ;
92995: LD_ADDR_EXP 116
92999: PUSH
93000: LD_INT 1
93002: ST_TO_ADDR
// if p3 = 113 then
93003: LD_VAR 0 3
93007: PUSH
93008: LD_INT 113
93010: EQUAL
93011: IFFALSE 93021
// sBazooka := true ;
93013: LD_ADDR_EXP 119
93017: PUSH
93018: LD_INT 1
93020: ST_TO_ADDR
// if p3 = 114 then
93021: LD_VAR 0 3
93025: PUSH
93026: LD_INT 114
93028: EQUAL
93029: IFFALSE 93039
// sMortar := true ;
93031: LD_ADDR_EXP 120
93035: PUSH
93036: LD_INT 1
93038: ST_TO_ADDR
// if p3 = 115 then
93039: LD_VAR 0 3
93043: PUSH
93044: LD_INT 115
93046: EQUAL
93047: IFFALSE 93057
// sRanger := true ;
93049: LD_ADDR_EXP 130
93053: PUSH
93054: LD_INT 1
93056: ST_TO_ADDR
// if p3 = 116 then
93057: LD_VAR 0 3
93061: PUSH
93062: LD_INT 116
93064: EQUAL
93065: IFFALSE 93075
// sComputer := true ;
93067: LD_ADDR_EXP 131
93071: PUSH
93072: LD_INT 1
93074: ST_TO_ADDR
// if p3 = 117 then
93075: LD_VAR 0 3
93079: PUSH
93080: LD_INT 117
93082: EQUAL
93083: IFFALSE 93093
// s30 := true ;
93085: LD_ADDR_EXP 132
93089: PUSH
93090: LD_INT 1
93092: ST_TO_ADDR
// if p3 = 118 then
93093: LD_VAR 0 3
93097: PUSH
93098: LD_INT 118
93100: EQUAL
93101: IFFALSE 93111
// s60 := true ;
93103: LD_ADDR_EXP 133
93107: PUSH
93108: LD_INT 1
93110: ST_TO_ADDR
// end ; if p2 = hack_mode then
93111: LD_VAR 0 2
93115: PUSH
93116: LD_INT 101
93118: EQUAL
93119: IFFALSE 93247
// begin case p3 of 1 :
93121: LD_VAR 0 3
93125: PUSH
93126: LD_INT 1
93128: DOUBLE
93129: EQUAL
93130: IFTRUE 93134
93132: GO 93141
93134: POP
// hHackUnlimitedResources ; 2 :
93135: CALL 105386 0 0
93139: GO 93247
93141: LD_INT 2
93143: DOUBLE
93144: EQUAL
93145: IFTRUE 93149
93147: GO 93156
93149: POP
// hHackSetLevel10 ; 3 :
93150: CALL 105519 0 0
93154: GO 93247
93156: LD_INT 3
93158: DOUBLE
93159: EQUAL
93160: IFTRUE 93164
93162: GO 93171
93164: POP
// hHackSetLevel10YourUnits ; 4 :
93165: CALL 105604 0 0
93169: GO 93247
93171: LD_INT 4
93173: DOUBLE
93174: EQUAL
93175: IFTRUE 93179
93177: GO 93186
93179: POP
// hHackInvincible ; 5 :
93180: CALL 106052 0 0
93184: GO 93247
93186: LD_INT 5
93188: DOUBLE
93189: EQUAL
93190: IFTRUE 93194
93192: GO 93201
93194: POP
// hHackInvisible ; 6 :
93195: CALL 106163 0 0
93199: GO 93247
93201: LD_INT 6
93203: DOUBLE
93204: EQUAL
93205: IFTRUE 93209
93207: GO 93216
93209: POP
// hHackChangeYourSide ; 7 :
93210: CALL 106220 0 0
93214: GO 93247
93216: LD_INT 7
93218: DOUBLE
93219: EQUAL
93220: IFTRUE 93224
93222: GO 93231
93224: POP
// hHackChangeUnitSide ; 8 :
93225: CALL 106262 0 0
93229: GO 93247
93231: LD_INT 8
93233: DOUBLE
93234: EQUAL
93235: IFTRUE 93239
93237: GO 93246
93239: POP
// hHackFog ; end ;
93240: CALL 106363 0 0
93244: GO 93247
93246: POP
// end ; if p2 = game_save_mode then
93247: LD_VAR 0 2
93251: PUSH
93252: LD_INT 102
93254: EQUAL
93255: IFFALSE 93310
// begin if p3 = 1 then
93257: LD_VAR 0 3
93261: PUSH
93262: LD_INT 1
93264: EQUAL
93265: IFFALSE 93277
// globalGameSaveCounter := p4 ;
93267: LD_ADDR_EXP 76
93271: PUSH
93272: LD_VAR 0 4
93276: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93277: LD_VAR 0 3
93281: PUSH
93282: LD_INT 2
93284: EQUAL
93285: PUSH
93286: LD_EXP 76
93290: AND
93291: IFFALSE 93310
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93293: LD_STRING setGameSaveCounter(
93295: PUSH
93296: LD_EXP 76
93300: STR
93301: PUSH
93302: LD_STRING )
93304: STR
93305: PPUSH
93306: CALL_OW 559
// end ; end ;
93310: LD_VAR 0 7
93314: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93315: LD_INT 0
93317: PPUSH
// streamModeActive := false ;
93318: LD_ADDR_EXP 77
93322: PUSH
93323: LD_INT 0
93325: ST_TO_ADDR
// normalCounter := 36 ;
93326: LD_ADDR_EXP 78
93330: PUSH
93331: LD_INT 36
93333: ST_TO_ADDR
// hardcoreCounter := 18 ;
93334: LD_ADDR_EXP 79
93338: PUSH
93339: LD_INT 18
93341: ST_TO_ADDR
// sRocket := false ;
93342: LD_ADDR_EXP 82
93346: PUSH
93347: LD_INT 0
93349: ST_TO_ADDR
// sSpeed := false ;
93350: LD_ADDR_EXP 81
93354: PUSH
93355: LD_INT 0
93357: ST_TO_ADDR
// sEngine := false ;
93358: LD_ADDR_EXP 83
93362: PUSH
93363: LD_INT 0
93365: ST_TO_ADDR
// sSpec := false ;
93366: LD_ADDR_EXP 80
93370: PUSH
93371: LD_INT 0
93373: ST_TO_ADDR
// sLevel := false ;
93374: LD_ADDR_EXP 84
93378: PUSH
93379: LD_INT 0
93381: ST_TO_ADDR
// sArmoury := false ;
93382: LD_ADDR_EXP 85
93386: PUSH
93387: LD_INT 0
93389: ST_TO_ADDR
// sRadar := false ;
93390: LD_ADDR_EXP 86
93394: PUSH
93395: LD_INT 0
93397: ST_TO_ADDR
// sBunker := false ;
93398: LD_ADDR_EXP 87
93402: PUSH
93403: LD_INT 0
93405: ST_TO_ADDR
// sHack := false ;
93406: LD_ADDR_EXP 88
93410: PUSH
93411: LD_INT 0
93413: ST_TO_ADDR
// sFire := false ;
93414: LD_ADDR_EXP 89
93418: PUSH
93419: LD_INT 0
93421: ST_TO_ADDR
// sRefresh := false ;
93422: LD_ADDR_EXP 90
93426: PUSH
93427: LD_INT 0
93429: ST_TO_ADDR
// sExp := false ;
93430: LD_ADDR_EXP 91
93434: PUSH
93435: LD_INT 0
93437: ST_TO_ADDR
// sDepot := false ;
93438: LD_ADDR_EXP 92
93442: PUSH
93443: LD_INT 0
93445: ST_TO_ADDR
// sFlag := false ;
93446: LD_ADDR_EXP 93
93450: PUSH
93451: LD_INT 0
93453: ST_TO_ADDR
// sKamikadze := false ;
93454: LD_ADDR_EXP 101
93458: PUSH
93459: LD_INT 0
93461: ST_TO_ADDR
// sTroll := false ;
93462: LD_ADDR_EXP 102
93466: PUSH
93467: LD_INT 0
93469: ST_TO_ADDR
// sSlow := false ;
93470: LD_ADDR_EXP 103
93474: PUSH
93475: LD_INT 0
93477: ST_TO_ADDR
// sLack := false ;
93478: LD_ADDR_EXP 104
93482: PUSH
93483: LD_INT 0
93485: ST_TO_ADDR
// sTank := false ;
93486: LD_ADDR_EXP 106
93490: PUSH
93491: LD_INT 0
93493: ST_TO_ADDR
// sRemote := false ;
93494: LD_ADDR_EXP 107
93498: PUSH
93499: LD_INT 0
93501: ST_TO_ADDR
// sPowell := false ;
93502: LD_ADDR_EXP 108
93506: PUSH
93507: LD_INT 0
93509: ST_TO_ADDR
// sTeleport := false ;
93510: LD_ADDR_EXP 111
93514: PUSH
93515: LD_INT 0
93517: ST_TO_ADDR
// sOilTower := false ;
93518: LD_ADDR_EXP 113
93522: PUSH
93523: LD_INT 0
93525: ST_TO_ADDR
// sShovel := false ;
93526: LD_ADDR_EXP 114
93530: PUSH
93531: LD_INT 0
93533: ST_TO_ADDR
// sSheik := false ;
93534: LD_ADDR_EXP 115
93538: PUSH
93539: LD_INT 0
93541: ST_TO_ADDR
// sEarthquake := false ;
93542: LD_ADDR_EXP 117
93546: PUSH
93547: LD_INT 0
93549: ST_TO_ADDR
// sAI := false ;
93550: LD_ADDR_EXP 118
93554: PUSH
93555: LD_INT 0
93557: ST_TO_ADDR
// sCargo := false ;
93558: LD_ADDR_EXP 121
93562: PUSH
93563: LD_INT 0
93565: ST_TO_ADDR
// sDLaser := false ;
93566: LD_ADDR_EXP 122
93570: PUSH
93571: LD_INT 0
93573: ST_TO_ADDR
// sExchange := false ;
93574: LD_ADDR_EXP 123
93578: PUSH
93579: LD_INT 0
93581: ST_TO_ADDR
// sFac := false ;
93582: LD_ADDR_EXP 124
93586: PUSH
93587: LD_INT 0
93589: ST_TO_ADDR
// sPower := false ;
93590: LD_ADDR_EXP 125
93594: PUSH
93595: LD_INT 0
93597: ST_TO_ADDR
// sRandom := false ;
93598: LD_ADDR_EXP 126
93602: PUSH
93603: LD_INT 0
93605: ST_TO_ADDR
// sShield := false ;
93606: LD_ADDR_EXP 127
93610: PUSH
93611: LD_INT 0
93613: ST_TO_ADDR
// sTime := false ;
93614: LD_ADDR_EXP 128
93618: PUSH
93619: LD_INT 0
93621: ST_TO_ADDR
// sTools := false ;
93622: LD_ADDR_EXP 129
93626: PUSH
93627: LD_INT 0
93629: ST_TO_ADDR
// sSold := false ;
93630: LD_ADDR_EXP 94
93634: PUSH
93635: LD_INT 0
93637: ST_TO_ADDR
// sDiff := false ;
93638: LD_ADDR_EXP 95
93642: PUSH
93643: LD_INT 0
93645: ST_TO_ADDR
// sFog := false ;
93646: LD_ADDR_EXP 98
93650: PUSH
93651: LD_INT 0
93653: ST_TO_ADDR
// sReset := false ;
93654: LD_ADDR_EXP 99
93658: PUSH
93659: LD_INT 0
93661: ST_TO_ADDR
// sSun := false ;
93662: LD_ADDR_EXP 100
93666: PUSH
93667: LD_INT 0
93669: ST_TO_ADDR
// sTiger := false ;
93670: LD_ADDR_EXP 96
93674: PUSH
93675: LD_INT 0
93677: ST_TO_ADDR
// sBomb := false ;
93678: LD_ADDR_EXP 97
93682: PUSH
93683: LD_INT 0
93685: ST_TO_ADDR
// sWound := false ;
93686: LD_ADDR_EXP 105
93690: PUSH
93691: LD_INT 0
93693: ST_TO_ADDR
// sBetray := false ;
93694: LD_ADDR_EXP 109
93698: PUSH
93699: LD_INT 0
93701: ST_TO_ADDR
// sContamin := false ;
93702: LD_ADDR_EXP 110
93706: PUSH
93707: LD_INT 0
93709: ST_TO_ADDR
// sOil := false ;
93710: LD_ADDR_EXP 112
93714: PUSH
93715: LD_INT 0
93717: ST_TO_ADDR
// sStu := false ;
93718: LD_ADDR_EXP 116
93722: PUSH
93723: LD_INT 0
93725: ST_TO_ADDR
// sBazooka := false ;
93726: LD_ADDR_EXP 119
93730: PUSH
93731: LD_INT 0
93733: ST_TO_ADDR
// sMortar := false ;
93734: LD_ADDR_EXP 120
93738: PUSH
93739: LD_INT 0
93741: ST_TO_ADDR
// sRanger := false ;
93742: LD_ADDR_EXP 130
93746: PUSH
93747: LD_INT 0
93749: ST_TO_ADDR
// sComputer := false ;
93750: LD_ADDR_EXP 131
93754: PUSH
93755: LD_INT 0
93757: ST_TO_ADDR
// s30 := false ;
93758: LD_ADDR_EXP 132
93762: PUSH
93763: LD_INT 0
93765: ST_TO_ADDR
// s60 := false ;
93766: LD_ADDR_EXP 133
93770: PUSH
93771: LD_INT 0
93773: ST_TO_ADDR
// end ;
93774: LD_VAR 0 1
93778: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93779: LD_INT 0
93781: PPUSH
93782: PPUSH
93783: PPUSH
93784: PPUSH
93785: PPUSH
93786: PPUSH
93787: PPUSH
// result := [ ] ;
93788: LD_ADDR_VAR 0 2
93792: PUSH
93793: EMPTY
93794: ST_TO_ADDR
// if campaign_id = 1 then
93795: LD_OWVAR 69
93799: PUSH
93800: LD_INT 1
93802: EQUAL
93803: IFFALSE 96969
// begin case mission_number of 1 :
93805: LD_OWVAR 70
93809: PUSH
93810: LD_INT 1
93812: DOUBLE
93813: EQUAL
93814: IFTRUE 93818
93816: GO 93894
93818: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93819: LD_ADDR_VAR 0 2
93823: PUSH
93824: LD_INT 2
93826: PUSH
93827: LD_INT 4
93829: PUSH
93830: LD_INT 11
93832: PUSH
93833: LD_INT 12
93835: PUSH
93836: LD_INT 15
93838: PUSH
93839: LD_INT 16
93841: PUSH
93842: LD_INT 22
93844: PUSH
93845: LD_INT 23
93847: PUSH
93848: LD_INT 26
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: PUSH
93862: LD_INT 101
93864: PUSH
93865: LD_INT 102
93867: PUSH
93868: LD_INT 106
93870: PUSH
93871: LD_INT 116
93873: PUSH
93874: LD_INT 117
93876: PUSH
93877: LD_INT 118
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: ST_TO_ADDR
93892: GO 96967
93894: LD_INT 2
93896: DOUBLE
93897: EQUAL
93898: IFTRUE 93902
93900: GO 93986
93902: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93903: LD_ADDR_VAR 0 2
93907: PUSH
93908: LD_INT 2
93910: PUSH
93911: LD_INT 4
93913: PUSH
93914: LD_INT 11
93916: PUSH
93917: LD_INT 12
93919: PUSH
93920: LD_INT 15
93922: PUSH
93923: LD_INT 16
93925: PUSH
93926: LD_INT 22
93928: PUSH
93929: LD_INT 23
93931: PUSH
93932: LD_INT 26
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: PUSH
93946: LD_INT 101
93948: PUSH
93949: LD_INT 102
93951: PUSH
93952: LD_INT 105
93954: PUSH
93955: LD_INT 106
93957: PUSH
93958: LD_INT 108
93960: PUSH
93961: LD_INT 116
93963: PUSH
93964: LD_INT 117
93966: PUSH
93967: LD_INT 118
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: ST_TO_ADDR
93984: GO 96967
93986: LD_INT 3
93988: DOUBLE
93989: EQUAL
93990: IFTRUE 93994
93992: GO 94082
93994: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93995: LD_ADDR_VAR 0 2
93999: PUSH
94000: LD_INT 2
94002: PUSH
94003: LD_INT 4
94005: PUSH
94006: LD_INT 5
94008: PUSH
94009: LD_INT 11
94011: PUSH
94012: LD_INT 12
94014: PUSH
94015: LD_INT 15
94017: PUSH
94018: LD_INT 16
94020: PUSH
94021: LD_INT 22
94023: PUSH
94024: LD_INT 26
94026: PUSH
94027: LD_INT 36
94029: PUSH
94030: EMPTY
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: PUSH
94042: LD_INT 101
94044: PUSH
94045: LD_INT 102
94047: PUSH
94048: LD_INT 105
94050: PUSH
94051: LD_INT 106
94053: PUSH
94054: LD_INT 108
94056: PUSH
94057: LD_INT 116
94059: PUSH
94060: LD_INT 117
94062: PUSH
94063: LD_INT 118
94065: PUSH
94066: EMPTY
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: ST_TO_ADDR
94080: GO 96967
94082: LD_INT 4
94084: DOUBLE
94085: EQUAL
94086: IFTRUE 94090
94088: GO 94186
94090: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94091: LD_ADDR_VAR 0 2
94095: PUSH
94096: LD_INT 2
94098: PUSH
94099: LD_INT 4
94101: PUSH
94102: LD_INT 5
94104: PUSH
94105: LD_INT 8
94107: PUSH
94108: LD_INT 11
94110: PUSH
94111: LD_INT 12
94113: PUSH
94114: LD_INT 15
94116: PUSH
94117: LD_INT 16
94119: PUSH
94120: LD_INT 22
94122: PUSH
94123: LD_INT 23
94125: PUSH
94126: LD_INT 26
94128: PUSH
94129: LD_INT 36
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: PUSH
94146: LD_INT 101
94148: PUSH
94149: LD_INT 102
94151: PUSH
94152: LD_INT 105
94154: PUSH
94155: LD_INT 106
94157: PUSH
94158: LD_INT 108
94160: PUSH
94161: LD_INT 116
94163: PUSH
94164: LD_INT 117
94166: PUSH
94167: LD_INT 118
94169: PUSH
94170: EMPTY
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: ST_TO_ADDR
94184: GO 96967
94186: LD_INT 5
94188: DOUBLE
94189: EQUAL
94190: IFTRUE 94194
94192: GO 94306
94194: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94195: LD_ADDR_VAR 0 2
94199: PUSH
94200: LD_INT 2
94202: PUSH
94203: LD_INT 4
94205: PUSH
94206: LD_INT 5
94208: PUSH
94209: LD_INT 6
94211: PUSH
94212: LD_INT 8
94214: PUSH
94215: LD_INT 11
94217: PUSH
94218: LD_INT 12
94220: PUSH
94221: LD_INT 15
94223: PUSH
94224: LD_INT 16
94226: PUSH
94227: LD_INT 22
94229: PUSH
94230: LD_INT 23
94232: PUSH
94233: LD_INT 25
94235: PUSH
94236: LD_INT 26
94238: PUSH
94239: LD_INT 36
94241: PUSH
94242: EMPTY
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: PUSH
94258: LD_INT 101
94260: PUSH
94261: LD_INT 102
94263: PUSH
94264: LD_INT 105
94266: PUSH
94267: LD_INT 106
94269: PUSH
94270: LD_INT 108
94272: PUSH
94273: LD_INT 109
94275: PUSH
94276: LD_INT 112
94278: PUSH
94279: LD_INT 116
94281: PUSH
94282: LD_INT 117
94284: PUSH
94285: LD_INT 118
94287: PUSH
94288: EMPTY
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: ST_TO_ADDR
94304: GO 96967
94306: LD_INT 6
94308: DOUBLE
94309: EQUAL
94310: IFTRUE 94314
94312: GO 94446
94314: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94315: LD_ADDR_VAR 0 2
94319: PUSH
94320: LD_INT 2
94322: PUSH
94323: LD_INT 4
94325: PUSH
94326: LD_INT 5
94328: PUSH
94329: LD_INT 6
94331: PUSH
94332: LD_INT 8
94334: PUSH
94335: LD_INT 11
94337: PUSH
94338: LD_INT 12
94340: PUSH
94341: LD_INT 15
94343: PUSH
94344: LD_INT 16
94346: PUSH
94347: LD_INT 20
94349: PUSH
94350: LD_INT 21
94352: PUSH
94353: LD_INT 22
94355: PUSH
94356: LD_INT 23
94358: PUSH
94359: LD_INT 25
94361: PUSH
94362: LD_INT 26
94364: PUSH
94365: LD_INT 30
94367: PUSH
94368: LD_INT 31
94370: PUSH
94371: LD_INT 32
94373: PUSH
94374: LD_INT 36
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: PUSH
94398: LD_INT 101
94400: PUSH
94401: LD_INT 102
94403: PUSH
94404: LD_INT 105
94406: PUSH
94407: LD_INT 106
94409: PUSH
94410: LD_INT 108
94412: PUSH
94413: LD_INT 109
94415: PUSH
94416: LD_INT 112
94418: PUSH
94419: LD_INT 116
94421: PUSH
94422: LD_INT 117
94424: PUSH
94425: LD_INT 118
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: ST_TO_ADDR
94444: GO 96967
94446: LD_INT 7
94448: DOUBLE
94449: EQUAL
94450: IFTRUE 94454
94452: GO 94566
94454: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94455: LD_ADDR_VAR 0 2
94459: PUSH
94460: LD_INT 2
94462: PUSH
94463: LD_INT 4
94465: PUSH
94466: LD_INT 5
94468: PUSH
94469: LD_INT 7
94471: PUSH
94472: LD_INT 11
94474: PUSH
94475: LD_INT 12
94477: PUSH
94478: LD_INT 15
94480: PUSH
94481: LD_INT 16
94483: PUSH
94484: LD_INT 20
94486: PUSH
94487: LD_INT 21
94489: PUSH
94490: LD_INT 22
94492: PUSH
94493: LD_INT 23
94495: PUSH
94496: LD_INT 25
94498: PUSH
94499: LD_INT 26
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: PUSH
94518: LD_INT 101
94520: PUSH
94521: LD_INT 102
94523: PUSH
94524: LD_INT 103
94526: PUSH
94527: LD_INT 105
94529: PUSH
94530: LD_INT 106
94532: PUSH
94533: LD_INT 108
94535: PUSH
94536: LD_INT 112
94538: PUSH
94539: LD_INT 116
94541: PUSH
94542: LD_INT 117
94544: PUSH
94545: LD_INT 118
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: PUSH
94560: EMPTY
94561: LIST
94562: LIST
94563: ST_TO_ADDR
94564: GO 96967
94566: LD_INT 8
94568: DOUBLE
94569: EQUAL
94570: IFTRUE 94574
94572: GO 94714
94574: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94575: LD_ADDR_VAR 0 2
94579: PUSH
94580: LD_INT 2
94582: PUSH
94583: LD_INT 4
94585: PUSH
94586: LD_INT 5
94588: PUSH
94589: LD_INT 6
94591: PUSH
94592: LD_INT 7
94594: PUSH
94595: LD_INT 8
94597: PUSH
94598: LD_INT 11
94600: PUSH
94601: LD_INT 12
94603: PUSH
94604: LD_INT 15
94606: PUSH
94607: LD_INT 16
94609: PUSH
94610: LD_INT 20
94612: PUSH
94613: LD_INT 21
94615: PUSH
94616: LD_INT 22
94618: PUSH
94619: LD_INT 23
94621: PUSH
94622: LD_INT 25
94624: PUSH
94625: LD_INT 26
94627: PUSH
94628: LD_INT 30
94630: PUSH
94631: LD_INT 31
94633: PUSH
94634: LD_INT 32
94636: PUSH
94637: LD_INT 36
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: LIST
94659: LIST
94660: LIST
94661: PUSH
94662: LD_INT 101
94664: PUSH
94665: LD_INT 102
94667: PUSH
94668: LD_INT 103
94670: PUSH
94671: LD_INT 105
94673: PUSH
94674: LD_INT 106
94676: PUSH
94677: LD_INT 108
94679: PUSH
94680: LD_INT 109
94682: PUSH
94683: LD_INT 112
94685: PUSH
94686: LD_INT 116
94688: PUSH
94689: LD_INT 117
94691: PUSH
94692: LD_INT 118
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: PUSH
94708: EMPTY
94709: LIST
94710: LIST
94711: ST_TO_ADDR
94712: GO 96967
94714: LD_INT 9
94716: DOUBLE
94717: EQUAL
94718: IFTRUE 94722
94720: GO 94870
94722: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94723: LD_ADDR_VAR 0 2
94727: PUSH
94728: LD_INT 2
94730: PUSH
94731: LD_INT 4
94733: PUSH
94734: LD_INT 5
94736: PUSH
94737: LD_INT 6
94739: PUSH
94740: LD_INT 7
94742: PUSH
94743: LD_INT 8
94745: PUSH
94746: LD_INT 11
94748: PUSH
94749: LD_INT 12
94751: PUSH
94752: LD_INT 15
94754: PUSH
94755: LD_INT 16
94757: PUSH
94758: LD_INT 20
94760: PUSH
94761: LD_INT 21
94763: PUSH
94764: LD_INT 22
94766: PUSH
94767: LD_INT 23
94769: PUSH
94770: LD_INT 25
94772: PUSH
94773: LD_INT 26
94775: PUSH
94776: LD_INT 28
94778: PUSH
94779: LD_INT 30
94781: PUSH
94782: LD_INT 31
94784: PUSH
94785: LD_INT 32
94787: PUSH
94788: LD_INT 36
94790: PUSH
94791: EMPTY
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: PUSH
94814: LD_INT 101
94816: PUSH
94817: LD_INT 102
94819: PUSH
94820: LD_INT 103
94822: PUSH
94823: LD_INT 105
94825: PUSH
94826: LD_INT 106
94828: PUSH
94829: LD_INT 108
94831: PUSH
94832: LD_INT 109
94834: PUSH
94835: LD_INT 112
94837: PUSH
94838: LD_INT 114
94840: PUSH
94841: LD_INT 116
94843: PUSH
94844: LD_INT 117
94846: PUSH
94847: LD_INT 118
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: PUSH
94864: EMPTY
94865: LIST
94866: LIST
94867: ST_TO_ADDR
94868: GO 96967
94870: LD_INT 10
94872: DOUBLE
94873: EQUAL
94874: IFTRUE 94878
94876: GO 95074
94878: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94879: LD_ADDR_VAR 0 2
94883: PUSH
94884: LD_INT 2
94886: PUSH
94887: LD_INT 4
94889: PUSH
94890: LD_INT 5
94892: PUSH
94893: LD_INT 6
94895: PUSH
94896: LD_INT 7
94898: PUSH
94899: LD_INT 8
94901: PUSH
94902: LD_INT 9
94904: PUSH
94905: LD_INT 10
94907: PUSH
94908: LD_INT 11
94910: PUSH
94911: LD_INT 12
94913: PUSH
94914: LD_INT 13
94916: PUSH
94917: LD_INT 14
94919: PUSH
94920: LD_INT 15
94922: PUSH
94923: LD_INT 16
94925: PUSH
94926: LD_INT 17
94928: PUSH
94929: LD_INT 18
94931: PUSH
94932: LD_INT 19
94934: PUSH
94935: LD_INT 20
94937: PUSH
94938: LD_INT 21
94940: PUSH
94941: LD_INT 22
94943: PUSH
94944: LD_INT 23
94946: PUSH
94947: LD_INT 24
94949: PUSH
94950: LD_INT 25
94952: PUSH
94953: LD_INT 26
94955: PUSH
94956: LD_INT 28
94958: PUSH
94959: LD_INT 30
94961: PUSH
94962: LD_INT 31
94964: PUSH
94965: LD_INT 32
94967: PUSH
94968: LD_INT 36
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: PUSH
95002: LD_INT 101
95004: PUSH
95005: LD_INT 102
95007: PUSH
95008: LD_INT 103
95010: PUSH
95011: LD_INT 104
95013: PUSH
95014: LD_INT 105
95016: PUSH
95017: LD_INT 106
95019: PUSH
95020: LD_INT 107
95022: PUSH
95023: LD_INT 108
95025: PUSH
95026: LD_INT 109
95028: PUSH
95029: LD_INT 110
95031: PUSH
95032: LD_INT 111
95034: PUSH
95035: LD_INT 112
95037: PUSH
95038: LD_INT 114
95040: PUSH
95041: LD_INT 116
95043: PUSH
95044: LD_INT 117
95046: PUSH
95047: LD_INT 118
95049: PUSH
95050: EMPTY
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: ST_TO_ADDR
95072: GO 96967
95074: LD_INT 11
95076: DOUBLE
95077: EQUAL
95078: IFTRUE 95082
95080: GO 95286
95082: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95083: LD_ADDR_VAR 0 2
95087: PUSH
95088: LD_INT 2
95090: PUSH
95091: LD_INT 3
95093: PUSH
95094: LD_INT 4
95096: PUSH
95097: LD_INT 5
95099: PUSH
95100: LD_INT 6
95102: PUSH
95103: LD_INT 7
95105: PUSH
95106: LD_INT 8
95108: PUSH
95109: LD_INT 9
95111: PUSH
95112: LD_INT 10
95114: PUSH
95115: LD_INT 11
95117: PUSH
95118: LD_INT 12
95120: PUSH
95121: LD_INT 13
95123: PUSH
95124: LD_INT 14
95126: PUSH
95127: LD_INT 15
95129: PUSH
95130: LD_INT 16
95132: PUSH
95133: LD_INT 17
95135: PUSH
95136: LD_INT 18
95138: PUSH
95139: LD_INT 19
95141: PUSH
95142: LD_INT 20
95144: PUSH
95145: LD_INT 21
95147: PUSH
95148: LD_INT 22
95150: PUSH
95151: LD_INT 23
95153: PUSH
95154: LD_INT 24
95156: PUSH
95157: LD_INT 25
95159: PUSH
95160: LD_INT 26
95162: PUSH
95163: LD_INT 28
95165: PUSH
95166: LD_INT 30
95168: PUSH
95169: LD_INT 31
95171: PUSH
95172: LD_INT 32
95174: PUSH
95175: LD_INT 34
95177: PUSH
95178: LD_INT 36
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: PUSH
95214: LD_INT 101
95216: PUSH
95217: LD_INT 102
95219: PUSH
95220: LD_INT 103
95222: PUSH
95223: LD_INT 104
95225: PUSH
95226: LD_INT 105
95228: PUSH
95229: LD_INT 106
95231: PUSH
95232: LD_INT 107
95234: PUSH
95235: LD_INT 108
95237: PUSH
95238: LD_INT 109
95240: PUSH
95241: LD_INT 110
95243: PUSH
95244: LD_INT 111
95246: PUSH
95247: LD_INT 112
95249: PUSH
95250: LD_INT 114
95252: PUSH
95253: LD_INT 116
95255: PUSH
95256: LD_INT 117
95258: PUSH
95259: LD_INT 118
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: ST_TO_ADDR
95284: GO 96967
95286: LD_INT 12
95288: DOUBLE
95289: EQUAL
95290: IFTRUE 95294
95292: GO 95514
95294: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95295: LD_ADDR_VAR 0 2
95299: PUSH
95300: LD_INT 1
95302: PUSH
95303: LD_INT 2
95305: PUSH
95306: LD_INT 3
95308: PUSH
95309: LD_INT 4
95311: PUSH
95312: LD_INT 5
95314: PUSH
95315: LD_INT 6
95317: PUSH
95318: LD_INT 7
95320: PUSH
95321: LD_INT 8
95323: PUSH
95324: LD_INT 9
95326: PUSH
95327: LD_INT 10
95329: PUSH
95330: LD_INT 11
95332: PUSH
95333: LD_INT 12
95335: PUSH
95336: LD_INT 13
95338: PUSH
95339: LD_INT 14
95341: PUSH
95342: LD_INT 15
95344: PUSH
95345: LD_INT 16
95347: PUSH
95348: LD_INT 17
95350: PUSH
95351: LD_INT 18
95353: PUSH
95354: LD_INT 19
95356: PUSH
95357: LD_INT 20
95359: PUSH
95360: LD_INT 21
95362: PUSH
95363: LD_INT 22
95365: PUSH
95366: LD_INT 23
95368: PUSH
95369: LD_INT 24
95371: PUSH
95372: LD_INT 25
95374: PUSH
95375: LD_INT 26
95377: PUSH
95378: LD_INT 27
95380: PUSH
95381: LD_INT 28
95383: PUSH
95384: LD_INT 30
95386: PUSH
95387: LD_INT 31
95389: PUSH
95390: LD_INT 32
95392: PUSH
95393: LD_INT 33
95395: PUSH
95396: LD_INT 34
95398: PUSH
95399: LD_INT 36
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 101
95440: PUSH
95441: LD_INT 102
95443: PUSH
95444: LD_INT 103
95446: PUSH
95447: LD_INT 104
95449: PUSH
95450: LD_INT 105
95452: PUSH
95453: LD_INT 106
95455: PUSH
95456: LD_INT 107
95458: PUSH
95459: LD_INT 108
95461: PUSH
95462: LD_INT 109
95464: PUSH
95465: LD_INT 110
95467: PUSH
95468: LD_INT 111
95470: PUSH
95471: LD_INT 112
95473: PUSH
95474: LD_INT 113
95476: PUSH
95477: LD_INT 114
95479: PUSH
95480: LD_INT 116
95482: PUSH
95483: LD_INT 117
95485: PUSH
95486: LD_INT 118
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: ST_TO_ADDR
95512: GO 96967
95514: LD_INT 13
95516: DOUBLE
95517: EQUAL
95518: IFTRUE 95522
95520: GO 95730
95522: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95523: LD_ADDR_VAR 0 2
95527: PUSH
95528: LD_INT 1
95530: PUSH
95531: LD_INT 2
95533: PUSH
95534: LD_INT 3
95536: PUSH
95537: LD_INT 4
95539: PUSH
95540: LD_INT 5
95542: PUSH
95543: LD_INT 8
95545: PUSH
95546: LD_INT 9
95548: PUSH
95549: LD_INT 10
95551: PUSH
95552: LD_INT 11
95554: PUSH
95555: LD_INT 12
95557: PUSH
95558: LD_INT 14
95560: PUSH
95561: LD_INT 15
95563: PUSH
95564: LD_INT 16
95566: PUSH
95567: LD_INT 17
95569: PUSH
95570: LD_INT 18
95572: PUSH
95573: LD_INT 19
95575: PUSH
95576: LD_INT 20
95578: PUSH
95579: LD_INT 21
95581: PUSH
95582: LD_INT 22
95584: PUSH
95585: LD_INT 23
95587: PUSH
95588: LD_INT 24
95590: PUSH
95591: LD_INT 25
95593: PUSH
95594: LD_INT 26
95596: PUSH
95597: LD_INT 27
95599: PUSH
95600: LD_INT 28
95602: PUSH
95603: LD_INT 30
95605: PUSH
95606: LD_INT 31
95608: PUSH
95609: LD_INT 32
95611: PUSH
95612: LD_INT 33
95614: PUSH
95615: LD_INT 34
95617: PUSH
95618: LD_INT 36
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: PUSH
95654: LD_INT 101
95656: PUSH
95657: LD_INT 102
95659: PUSH
95660: LD_INT 103
95662: PUSH
95663: LD_INT 104
95665: PUSH
95666: LD_INT 105
95668: PUSH
95669: LD_INT 106
95671: PUSH
95672: LD_INT 107
95674: PUSH
95675: LD_INT 108
95677: PUSH
95678: LD_INT 109
95680: PUSH
95681: LD_INT 110
95683: PUSH
95684: LD_INT 111
95686: PUSH
95687: LD_INT 112
95689: PUSH
95690: LD_INT 113
95692: PUSH
95693: LD_INT 114
95695: PUSH
95696: LD_INT 116
95698: PUSH
95699: LD_INT 117
95701: PUSH
95702: LD_INT 118
95704: PUSH
95705: EMPTY
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: PUSH
95724: EMPTY
95725: LIST
95726: LIST
95727: ST_TO_ADDR
95728: GO 96967
95730: LD_INT 14
95732: DOUBLE
95733: EQUAL
95734: IFTRUE 95738
95736: GO 95962
95738: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95739: LD_ADDR_VAR 0 2
95743: PUSH
95744: LD_INT 1
95746: PUSH
95747: LD_INT 2
95749: PUSH
95750: LD_INT 3
95752: PUSH
95753: LD_INT 4
95755: PUSH
95756: LD_INT 5
95758: PUSH
95759: LD_INT 6
95761: PUSH
95762: LD_INT 7
95764: PUSH
95765: LD_INT 8
95767: PUSH
95768: LD_INT 9
95770: PUSH
95771: LD_INT 10
95773: PUSH
95774: LD_INT 11
95776: PUSH
95777: LD_INT 12
95779: PUSH
95780: LD_INT 13
95782: PUSH
95783: LD_INT 14
95785: PUSH
95786: LD_INT 15
95788: PUSH
95789: LD_INT 16
95791: PUSH
95792: LD_INT 17
95794: PUSH
95795: LD_INT 18
95797: PUSH
95798: LD_INT 19
95800: PUSH
95801: LD_INT 20
95803: PUSH
95804: LD_INT 21
95806: PUSH
95807: LD_INT 22
95809: PUSH
95810: LD_INT 23
95812: PUSH
95813: LD_INT 24
95815: PUSH
95816: LD_INT 25
95818: PUSH
95819: LD_INT 26
95821: PUSH
95822: LD_INT 27
95824: PUSH
95825: LD_INT 28
95827: PUSH
95828: LD_INT 29
95830: PUSH
95831: LD_INT 30
95833: PUSH
95834: LD_INT 31
95836: PUSH
95837: LD_INT 32
95839: PUSH
95840: LD_INT 33
95842: PUSH
95843: LD_INT 34
95845: PUSH
95846: LD_INT 36
95848: PUSH
95849: EMPTY
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 101
95888: PUSH
95889: LD_INT 102
95891: PUSH
95892: LD_INT 103
95894: PUSH
95895: LD_INT 104
95897: PUSH
95898: LD_INT 105
95900: PUSH
95901: LD_INT 106
95903: PUSH
95904: LD_INT 107
95906: PUSH
95907: LD_INT 108
95909: PUSH
95910: LD_INT 109
95912: PUSH
95913: LD_INT 110
95915: PUSH
95916: LD_INT 111
95918: PUSH
95919: LD_INT 112
95921: PUSH
95922: LD_INT 113
95924: PUSH
95925: LD_INT 114
95927: PUSH
95928: LD_INT 116
95930: PUSH
95931: LD_INT 117
95933: PUSH
95934: LD_INT 118
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: PUSH
95956: EMPTY
95957: LIST
95958: LIST
95959: ST_TO_ADDR
95960: GO 96967
95962: LD_INT 15
95964: DOUBLE
95965: EQUAL
95966: IFTRUE 95970
95968: GO 96194
95970: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95971: LD_ADDR_VAR 0 2
95975: PUSH
95976: LD_INT 1
95978: PUSH
95979: LD_INT 2
95981: PUSH
95982: LD_INT 3
95984: PUSH
95985: LD_INT 4
95987: PUSH
95988: LD_INT 5
95990: PUSH
95991: LD_INT 6
95993: PUSH
95994: LD_INT 7
95996: PUSH
95997: LD_INT 8
95999: PUSH
96000: LD_INT 9
96002: PUSH
96003: LD_INT 10
96005: PUSH
96006: LD_INT 11
96008: PUSH
96009: LD_INT 12
96011: PUSH
96012: LD_INT 13
96014: PUSH
96015: LD_INT 14
96017: PUSH
96018: LD_INT 15
96020: PUSH
96021: LD_INT 16
96023: PUSH
96024: LD_INT 17
96026: PUSH
96027: LD_INT 18
96029: PUSH
96030: LD_INT 19
96032: PUSH
96033: LD_INT 20
96035: PUSH
96036: LD_INT 21
96038: PUSH
96039: LD_INT 22
96041: PUSH
96042: LD_INT 23
96044: PUSH
96045: LD_INT 24
96047: PUSH
96048: LD_INT 25
96050: PUSH
96051: LD_INT 26
96053: PUSH
96054: LD_INT 27
96056: PUSH
96057: LD_INT 28
96059: PUSH
96060: LD_INT 29
96062: PUSH
96063: LD_INT 30
96065: PUSH
96066: LD_INT 31
96068: PUSH
96069: LD_INT 32
96071: PUSH
96072: LD_INT 33
96074: PUSH
96075: LD_INT 34
96077: PUSH
96078: LD_INT 36
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 101
96120: PUSH
96121: LD_INT 102
96123: PUSH
96124: LD_INT 103
96126: PUSH
96127: LD_INT 104
96129: PUSH
96130: LD_INT 105
96132: PUSH
96133: LD_INT 106
96135: PUSH
96136: LD_INT 107
96138: PUSH
96139: LD_INT 108
96141: PUSH
96142: LD_INT 109
96144: PUSH
96145: LD_INT 110
96147: PUSH
96148: LD_INT 111
96150: PUSH
96151: LD_INT 112
96153: PUSH
96154: LD_INT 113
96156: PUSH
96157: LD_INT 114
96159: PUSH
96160: LD_INT 116
96162: PUSH
96163: LD_INT 117
96165: PUSH
96166: LD_INT 118
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: ST_TO_ADDR
96192: GO 96967
96194: LD_INT 16
96196: DOUBLE
96197: EQUAL
96198: IFTRUE 96202
96200: GO 96338
96202: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96203: LD_ADDR_VAR 0 2
96207: PUSH
96208: LD_INT 2
96210: PUSH
96211: LD_INT 4
96213: PUSH
96214: LD_INT 5
96216: PUSH
96217: LD_INT 7
96219: PUSH
96220: LD_INT 11
96222: PUSH
96223: LD_INT 12
96225: PUSH
96226: LD_INT 15
96228: PUSH
96229: LD_INT 16
96231: PUSH
96232: LD_INT 20
96234: PUSH
96235: LD_INT 21
96237: PUSH
96238: LD_INT 22
96240: PUSH
96241: LD_INT 23
96243: PUSH
96244: LD_INT 25
96246: PUSH
96247: LD_INT 26
96249: PUSH
96250: LD_INT 30
96252: PUSH
96253: LD_INT 31
96255: PUSH
96256: LD_INT 32
96258: PUSH
96259: LD_INT 33
96261: PUSH
96262: LD_INT 34
96264: PUSH
96265: EMPTY
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: PUSH
96286: LD_INT 101
96288: PUSH
96289: LD_INT 102
96291: PUSH
96292: LD_INT 103
96294: PUSH
96295: LD_INT 106
96297: PUSH
96298: LD_INT 108
96300: PUSH
96301: LD_INT 112
96303: PUSH
96304: LD_INT 113
96306: PUSH
96307: LD_INT 114
96309: PUSH
96310: LD_INT 116
96312: PUSH
96313: LD_INT 117
96315: PUSH
96316: LD_INT 118
96318: PUSH
96319: EMPTY
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: ST_TO_ADDR
96336: GO 96967
96338: LD_INT 17
96340: DOUBLE
96341: EQUAL
96342: IFTRUE 96346
96344: GO 96570
96346: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96347: LD_ADDR_VAR 0 2
96351: PUSH
96352: LD_INT 1
96354: PUSH
96355: LD_INT 2
96357: PUSH
96358: LD_INT 3
96360: PUSH
96361: LD_INT 4
96363: PUSH
96364: LD_INT 5
96366: PUSH
96367: LD_INT 6
96369: PUSH
96370: LD_INT 7
96372: PUSH
96373: LD_INT 8
96375: PUSH
96376: LD_INT 9
96378: PUSH
96379: LD_INT 10
96381: PUSH
96382: LD_INT 11
96384: PUSH
96385: LD_INT 12
96387: PUSH
96388: LD_INT 13
96390: PUSH
96391: LD_INT 14
96393: PUSH
96394: LD_INT 15
96396: PUSH
96397: LD_INT 16
96399: PUSH
96400: LD_INT 17
96402: PUSH
96403: LD_INT 18
96405: PUSH
96406: LD_INT 19
96408: PUSH
96409: LD_INT 20
96411: PUSH
96412: LD_INT 21
96414: PUSH
96415: LD_INT 22
96417: PUSH
96418: LD_INT 23
96420: PUSH
96421: LD_INT 24
96423: PUSH
96424: LD_INT 25
96426: PUSH
96427: LD_INT 26
96429: PUSH
96430: LD_INT 27
96432: PUSH
96433: LD_INT 28
96435: PUSH
96436: LD_INT 29
96438: PUSH
96439: LD_INT 30
96441: PUSH
96442: LD_INT 31
96444: PUSH
96445: LD_INT 32
96447: PUSH
96448: LD_INT 33
96450: PUSH
96451: LD_INT 34
96453: PUSH
96454: LD_INT 36
96456: PUSH
96457: EMPTY
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: PUSH
96494: LD_INT 101
96496: PUSH
96497: LD_INT 102
96499: PUSH
96500: LD_INT 103
96502: PUSH
96503: LD_INT 104
96505: PUSH
96506: LD_INT 105
96508: PUSH
96509: LD_INT 106
96511: PUSH
96512: LD_INT 107
96514: PUSH
96515: LD_INT 108
96517: PUSH
96518: LD_INT 109
96520: PUSH
96521: LD_INT 110
96523: PUSH
96524: LD_INT 111
96526: PUSH
96527: LD_INT 112
96529: PUSH
96530: LD_INT 113
96532: PUSH
96533: LD_INT 114
96535: PUSH
96536: LD_INT 116
96538: PUSH
96539: LD_INT 117
96541: PUSH
96542: LD_INT 118
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: PUSH
96564: EMPTY
96565: LIST
96566: LIST
96567: ST_TO_ADDR
96568: GO 96967
96570: LD_INT 18
96572: DOUBLE
96573: EQUAL
96574: IFTRUE 96578
96576: GO 96726
96578: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96579: LD_ADDR_VAR 0 2
96583: PUSH
96584: LD_INT 2
96586: PUSH
96587: LD_INT 4
96589: PUSH
96590: LD_INT 5
96592: PUSH
96593: LD_INT 7
96595: PUSH
96596: LD_INT 11
96598: PUSH
96599: LD_INT 12
96601: PUSH
96602: LD_INT 15
96604: PUSH
96605: LD_INT 16
96607: PUSH
96608: LD_INT 20
96610: PUSH
96611: LD_INT 21
96613: PUSH
96614: LD_INT 22
96616: PUSH
96617: LD_INT 23
96619: PUSH
96620: LD_INT 25
96622: PUSH
96623: LD_INT 26
96625: PUSH
96626: LD_INT 30
96628: PUSH
96629: LD_INT 31
96631: PUSH
96632: LD_INT 32
96634: PUSH
96635: LD_INT 33
96637: PUSH
96638: LD_INT 34
96640: PUSH
96641: LD_INT 35
96643: PUSH
96644: LD_INT 36
96646: PUSH
96647: EMPTY
96648: LIST
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: PUSH
96670: LD_INT 101
96672: PUSH
96673: LD_INT 102
96675: PUSH
96676: LD_INT 103
96678: PUSH
96679: LD_INT 106
96681: PUSH
96682: LD_INT 108
96684: PUSH
96685: LD_INT 112
96687: PUSH
96688: LD_INT 113
96690: PUSH
96691: LD_INT 114
96693: PUSH
96694: LD_INT 115
96696: PUSH
96697: LD_INT 116
96699: PUSH
96700: LD_INT 117
96702: PUSH
96703: LD_INT 118
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: LIST
96717: LIST
96718: LIST
96719: PUSH
96720: EMPTY
96721: LIST
96722: LIST
96723: ST_TO_ADDR
96724: GO 96967
96726: LD_INT 19
96728: DOUBLE
96729: EQUAL
96730: IFTRUE 96734
96732: GO 96966
96734: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96735: LD_ADDR_VAR 0 2
96739: PUSH
96740: LD_INT 1
96742: PUSH
96743: LD_INT 2
96745: PUSH
96746: LD_INT 3
96748: PUSH
96749: LD_INT 4
96751: PUSH
96752: LD_INT 5
96754: PUSH
96755: LD_INT 6
96757: PUSH
96758: LD_INT 7
96760: PUSH
96761: LD_INT 8
96763: PUSH
96764: LD_INT 9
96766: PUSH
96767: LD_INT 10
96769: PUSH
96770: LD_INT 11
96772: PUSH
96773: LD_INT 12
96775: PUSH
96776: LD_INT 13
96778: PUSH
96779: LD_INT 14
96781: PUSH
96782: LD_INT 15
96784: PUSH
96785: LD_INT 16
96787: PUSH
96788: LD_INT 17
96790: PUSH
96791: LD_INT 18
96793: PUSH
96794: LD_INT 19
96796: PUSH
96797: LD_INT 20
96799: PUSH
96800: LD_INT 21
96802: PUSH
96803: LD_INT 22
96805: PUSH
96806: LD_INT 23
96808: PUSH
96809: LD_INT 24
96811: PUSH
96812: LD_INT 25
96814: PUSH
96815: LD_INT 26
96817: PUSH
96818: LD_INT 27
96820: PUSH
96821: LD_INT 28
96823: PUSH
96824: LD_INT 29
96826: PUSH
96827: LD_INT 30
96829: PUSH
96830: LD_INT 31
96832: PUSH
96833: LD_INT 32
96835: PUSH
96836: LD_INT 33
96838: PUSH
96839: LD_INT 34
96841: PUSH
96842: LD_INT 35
96844: PUSH
96845: LD_INT 36
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 101
96888: PUSH
96889: LD_INT 102
96891: PUSH
96892: LD_INT 103
96894: PUSH
96895: LD_INT 104
96897: PUSH
96898: LD_INT 105
96900: PUSH
96901: LD_INT 106
96903: PUSH
96904: LD_INT 107
96906: PUSH
96907: LD_INT 108
96909: PUSH
96910: LD_INT 109
96912: PUSH
96913: LD_INT 110
96915: PUSH
96916: LD_INT 111
96918: PUSH
96919: LD_INT 112
96921: PUSH
96922: LD_INT 113
96924: PUSH
96925: LD_INT 114
96927: PUSH
96928: LD_INT 115
96930: PUSH
96931: LD_INT 116
96933: PUSH
96934: LD_INT 117
96936: PUSH
96937: LD_INT 118
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: ST_TO_ADDR
96964: GO 96967
96966: POP
// end else
96967: GO 97198
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96969: LD_ADDR_VAR 0 2
96973: PUSH
96974: LD_INT 1
96976: PUSH
96977: LD_INT 2
96979: PUSH
96980: LD_INT 3
96982: PUSH
96983: LD_INT 4
96985: PUSH
96986: LD_INT 5
96988: PUSH
96989: LD_INT 6
96991: PUSH
96992: LD_INT 7
96994: PUSH
96995: LD_INT 8
96997: PUSH
96998: LD_INT 9
97000: PUSH
97001: LD_INT 10
97003: PUSH
97004: LD_INT 11
97006: PUSH
97007: LD_INT 12
97009: PUSH
97010: LD_INT 13
97012: PUSH
97013: LD_INT 14
97015: PUSH
97016: LD_INT 15
97018: PUSH
97019: LD_INT 16
97021: PUSH
97022: LD_INT 17
97024: PUSH
97025: LD_INT 18
97027: PUSH
97028: LD_INT 19
97030: PUSH
97031: LD_INT 20
97033: PUSH
97034: LD_INT 21
97036: PUSH
97037: LD_INT 22
97039: PUSH
97040: LD_INT 23
97042: PUSH
97043: LD_INT 24
97045: PUSH
97046: LD_INT 25
97048: PUSH
97049: LD_INT 26
97051: PUSH
97052: LD_INT 27
97054: PUSH
97055: LD_INT 28
97057: PUSH
97058: LD_INT 29
97060: PUSH
97061: LD_INT 30
97063: PUSH
97064: LD_INT 31
97066: PUSH
97067: LD_INT 32
97069: PUSH
97070: LD_INT 33
97072: PUSH
97073: LD_INT 34
97075: PUSH
97076: LD_INT 35
97078: PUSH
97079: LD_INT 36
97081: PUSH
97082: EMPTY
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: PUSH
97120: LD_INT 101
97122: PUSH
97123: LD_INT 102
97125: PUSH
97126: LD_INT 103
97128: PUSH
97129: LD_INT 104
97131: PUSH
97132: LD_INT 105
97134: PUSH
97135: LD_INT 106
97137: PUSH
97138: LD_INT 107
97140: PUSH
97141: LD_INT 108
97143: PUSH
97144: LD_INT 109
97146: PUSH
97147: LD_INT 110
97149: PUSH
97150: LD_INT 111
97152: PUSH
97153: LD_INT 112
97155: PUSH
97156: LD_INT 113
97158: PUSH
97159: LD_INT 114
97161: PUSH
97162: LD_INT 115
97164: PUSH
97165: LD_INT 116
97167: PUSH
97168: LD_INT 117
97170: PUSH
97171: LD_INT 118
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: ST_TO_ADDR
// if result then
97198: LD_VAR 0 2
97202: IFFALSE 97988
// begin normal :=  ;
97204: LD_ADDR_VAR 0 5
97208: PUSH
97209: LD_STRING 
97211: ST_TO_ADDR
// hardcore :=  ;
97212: LD_ADDR_VAR 0 6
97216: PUSH
97217: LD_STRING 
97219: ST_TO_ADDR
// active :=  ;
97220: LD_ADDR_VAR 0 7
97224: PUSH
97225: LD_STRING 
97227: ST_TO_ADDR
// for i = 1 to normalCounter do
97228: LD_ADDR_VAR 0 8
97232: PUSH
97233: DOUBLE
97234: LD_INT 1
97236: DEC
97237: ST_TO_ADDR
97238: LD_EXP 78
97242: PUSH
97243: FOR_TO
97244: IFFALSE 97345
// begin tmp := 0 ;
97246: LD_ADDR_VAR 0 3
97250: PUSH
97251: LD_STRING 0
97253: ST_TO_ADDR
// if result [ 1 ] then
97254: LD_VAR 0 2
97258: PUSH
97259: LD_INT 1
97261: ARRAY
97262: IFFALSE 97327
// if result [ 1 ] [ 1 ] = i then
97264: LD_VAR 0 2
97268: PUSH
97269: LD_INT 1
97271: ARRAY
97272: PUSH
97273: LD_INT 1
97275: ARRAY
97276: PUSH
97277: LD_VAR 0 8
97281: EQUAL
97282: IFFALSE 97327
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97284: LD_ADDR_VAR 0 2
97288: PUSH
97289: LD_VAR 0 2
97293: PPUSH
97294: LD_INT 1
97296: PPUSH
97297: LD_VAR 0 2
97301: PUSH
97302: LD_INT 1
97304: ARRAY
97305: PPUSH
97306: LD_INT 1
97308: PPUSH
97309: CALL_OW 3
97313: PPUSH
97314: CALL_OW 1
97318: ST_TO_ADDR
// tmp := 1 ;
97319: LD_ADDR_VAR 0 3
97323: PUSH
97324: LD_STRING 1
97326: ST_TO_ADDR
// end ; normal := normal & tmp ;
97327: LD_ADDR_VAR 0 5
97331: PUSH
97332: LD_VAR 0 5
97336: PUSH
97337: LD_VAR 0 3
97341: STR
97342: ST_TO_ADDR
// end ;
97343: GO 97243
97345: POP
97346: POP
// for i = 1 to hardcoreCounter do
97347: LD_ADDR_VAR 0 8
97351: PUSH
97352: DOUBLE
97353: LD_INT 1
97355: DEC
97356: ST_TO_ADDR
97357: LD_EXP 79
97361: PUSH
97362: FOR_TO
97363: IFFALSE 97468
// begin tmp := 0 ;
97365: LD_ADDR_VAR 0 3
97369: PUSH
97370: LD_STRING 0
97372: ST_TO_ADDR
// if result [ 2 ] then
97373: LD_VAR 0 2
97377: PUSH
97378: LD_INT 2
97380: ARRAY
97381: IFFALSE 97450
// if result [ 2 ] [ 1 ] = 100 + i then
97383: LD_VAR 0 2
97387: PUSH
97388: LD_INT 2
97390: ARRAY
97391: PUSH
97392: LD_INT 1
97394: ARRAY
97395: PUSH
97396: LD_INT 100
97398: PUSH
97399: LD_VAR 0 8
97403: PLUS
97404: EQUAL
97405: IFFALSE 97450
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97407: LD_ADDR_VAR 0 2
97411: PUSH
97412: LD_VAR 0 2
97416: PPUSH
97417: LD_INT 2
97419: PPUSH
97420: LD_VAR 0 2
97424: PUSH
97425: LD_INT 2
97427: ARRAY
97428: PPUSH
97429: LD_INT 1
97431: PPUSH
97432: CALL_OW 3
97436: PPUSH
97437: CALL_OW 1
97441: ST_TO_ADDR
// tmp := 1 ;
97442: LD_ADDR_VAR 0 3
97446: PUSH
97447: LD_STRING 1
97449: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97450: LD_ADDR_VAR 0 6
97454: PUSH
97455: LD_VAR 0 6
97459: PUSH
97460: LD_VAR 0 3
97464: STR
97465: ST_TO_ADDR
// end ;
97466: GO 97362
97468: POP
97469: POP
// if isGameLoad then
97470: LD_VAR 0 1
97474: IFFALSE 97949
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97476: LD_ADDR_VAR 0 4
97480: PUSH
97481: LD_EXP 82
97485: PUSH
97486: LD_EXP 81
97490: PUSH
97491: LD_EXP 83
97495: PUSH
97496: LD_EXP 80
97500: PUSH
97501: LD_EXP 84
97505: PUSH
97506: LD_EXP 85
97510: PUSH
97511: LD_EXP 86
97515: PUSH
97516: LD_EXP 87
97520: PUSH
97521: LD_EXP 88
97525: PUSH
97526: LD_EXP 89
97530: PUSH
97531: LD_EXP 90
97535: PUSH
97536: LD_EXP 91
97540: PUSH
97541: LD_EXP 92
97545: PUSH
97546: LD_EXP 93
97550: PUSH
97551: LD_EXP 101
97555: PUSH
97556: LD_EXP 102
97560: PUSH
97561: LD_EXP 103
97565: PUSH
97566: LD_EXP 104
97570: PUSH
97571: LD_EXP 106
97575: PUSH
97576: LD_EXP 107
97580: PUSH
97581: LD_EXP 108
97585: PUSH
97586: LD_EXP 111
97590: PUSH
97591: LD_EXP 113
97595: PUSH
97596: LD_EXP 114
97600: PUSH
97601: LD_EXP 115
97605: PUSH
97606: LD_EXP 117
97610: PUSH
97611: LD_EXP 118
97615: PUSH
97616: LD_EXP 121
97620: PUSH
97621: LD_EXP 122
97625: PUSH
97626: LD_EXP 123
97630: PUSH
97631: LD_EXP 124
97635: PUSH
97636: LD_EXP 125
97640: PUSH
97641: LD_EXP 126
97645: PUSH
97646: LD_EXP 127
97650: PUSH
97651: LD_EXP 128
97655: PUSH
97656: LD_EXP 129
97660: PUSH
97661: LD_EXP 94
97665: PUSH
97666: LD_EXP 95
97670: PUSH
97671: LD_EXP 98
97675: PUSH
97676: LD_EXP 99
97680: PUSH
97681: LD_EXP 100
97685: PUSH
97686: LD_EXP 96
97690: PUSH
97691: LD_EXP 97
97695: PUSH
97696: LD_EXP 105
97700: PUSH
97701: LD_EXP 109
97705: PUSH
97706: LD_EXP 110
97710: PUSH
97711: LD_EXP 112
97715: PUSH
97716: LD_EXP 116
97720: PUSH
97721: LD_EXP 119
97725: PUSH
97726: LD_EXP 120
97730: PUSH
97731: LD_EXP 130
97735: PUSH
97736: LD_EXP 131
97740: PUSH
97741: LD_EXP 132
97745: PUSH
97746: LD_EXP 133
97750: PUSH
97751: EMPTY
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: LIST
97760: LIST
97761: LIST
97762: LIST
97763: LIST
97764: LIST
97765: LIST
97766: LIST
97767: LIST
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: ST_TO_ADDR
// tmp :=  ;
97807: LD_ADDR_VAR 0 3
97811: PUSH
97812: LD_STRING 
97814: ST_TO_ADDR
// for i = 1 to normalCounter do
97815: LD_ADDR_VAR 0 8
97819: PUSH
97820: DOUBLE
97821: LD_INT 1
97823: DEC
97824: ST_TO_ADDR
97825: LD_EXP 78
97829: PUSH
97830: FOR_TO
97831: IFFALSE 97867
// begin if flags [ i ] then
97833: LD_VAR 0 4
97837: PUSH
97838: LD_VAR 0 8
97842: ARRAY
97843: IFFALSE 97865
// tmp := tmp & i & ; ;
97845: LD_ADDR_VAR 0 3
97849: PUSH
97850: LD_VAR 0 3
97854: PUSH
97855: LD_VAR 0 8
97859: STR
97860: PUSH
97861: LD_STRING ;
97863: STR
97864: ST_TO_ADDR
// end ;
97865: GO 97830
97867: POP
97868: POP
// for i = 1 to hardcoreCounter do
97869: LD_ADDR_VAR 0 8
97873: PUSH
97874: DOUBLE
97875: LD_INT 1
97877: DEC
97878: ST_TO_ADDR
97879: LD_EXP 79
97883: PUSH
97884: FOR_TO
97885: IFFALSE 97931
// begin if flags [ normalCounter + i ] then
97887: LD_VAR 0 4
97891: PUSH
97892: LD_EXP 78
97896: PUSH
97897: LD_VAR 0 8
97901: PLUS
97902: ARRAY
97903: IFFALSE 97929
// tmp := tmp & ( 100 + i ) & ; ;
97905: LD_ADDR_VAR 0 3
97909: PUSH
97910: LD_VAR 0 3
97914: PUSH
97915: LD_INT 100
97917: PUSH
97918: LD_VAR 0 8
97922: PLUS
97923: STR
97924: PUSH
97925: LD_STRING ;
97927: STR
97928: ST_TO_ADDR
// end ;
97929: GO 97884
97931: POP
97932: POP
// if tmp then
97933: LD_VAR 0 3
97937: IFFALSE 97949
// active := tmp ;
97939: LD_ADDR_VAR 0 7
97943: PUSH
97944: LD_VAR 0 3
97948: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97949: LD_STRING getStreamItemsFromMission("
97951: PUSH
97952: LD_VAR 0 5
97956: STR
97957: PUSH
97958: LD_STRING ","
97960: STR
97961: PUSH
97962: LD_VAR 0 6
97966: STR
97967: PUSH
97968: LD_STRING ","
97970: STR
97971: PUSH
97972: LD_VAR 0 7
97976: STR
97977: PUSH
97978: LD_STRING ")
97980: STR
97981: PPUSH
97982: CALL_OW 559
// end else
97986: GO 97995
// ToLua ( getStreamItemsFromMission("","","") ) ;
97988: LD_STRING getStreamItemsFromMission("","","")
97990: PPUSH
97991: CALL_OW 559
// end ;
97995: LD_VAR 0 2
97999: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98000: LD_EXP 77
98004: PUSH
98005: LD_EXP 82
98009: AND
98010: IFFALSE 98134
98012: GO 98014
98014: DISABLE
98015: LD_INT 0
98017: PPUSH
98018: PPUSH
// begin enable ;
98019: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98020: LD_ADDR_VAR 0 2
98024: PUSH
98025: LD_INT 22
98027: PUSH
98028: LD_OWVAR 2
98032: PUSH
98033: EMPTY
98034: LIST
98035: LIST
98036: PUSH
98037: LD_INT 2
98039: PUSH
98040: LD_INT 34
98042: PUSH
98043: LD_INT 7
98045: PUSH
98046: EMPTY
98047: LIST
98048: LIST
98049: PUSH
98050: LD_INT 34
98052: PUSH
98053: LD_INT 45
98055: PUSH
98056: EMPTY
98057: LIST
98058: LIST
98059: PUSH
98060: LD_INT 34
98062: PUSH
98063: LD_INT 28
98065: PUSH
98066: EMPTY
98067: LIST
98068: LIST
98069: PUSH
98070: LD_INT 34
98072: PUSH
98073: LD_INT 47
98075: PUSH
98076: EMPTY
98077: LIST
98078: LIST
98079: PUSH
98080: EMPTY
98081: LIST
98082: LIST
98083: LIST
98084: LIST
98085: LIST
98086: PUSH
98087: EMPTY
98088: LIST
98089: LIST
98090: PPUSH
98091: CALL_OW 69
98095: ST_TO_ADDR
// if not tmp then
98096: LD_VAR 0 2
98100: NOT
98101: IFFALSE 98105
// exit ;
98103: GO 98134
// for i in tmp do
98105: LD_ADDR_VAR 0 1
98109: PUSH
98110: LD_VAR 0 2
98114: PUSH
98115: FOR_IN
98116: IFFALSE 98132
// begin SetLives ( i , 0 ) ;
98118: LD_VAR 0 1
98122: PPUSH
98123: LD_INT 0
98125: PPUSH
98126: CALL_OW 234
// end ;
98130: GO 98115
98132: POP
98133: POP
// end ;
98134: PPOPN 2
98136: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98137: LD_EXP 77
98141: PUSH
98142: LD_EXP 83
98146: AND
98147: IFFALSE 98231
98149: GO 98151
98151: DISABLE
98152: LD_INT 0
98154: PPUSH
98155: PPUSH
// begin enable ;
98156: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98157: LD_ADDR_VAR 0 2
98161: PUSH
98162: LD_INT 22
98164: PUSH
98165: LD_OWVAR 2
98169: PUSH
98170: EMPTY
98171: LIST
98172: LIST
98173: PUSH
98174: LD_INT 32
98176: PUSH
98177: LD_INT 3
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: PUSH
98184: EMPTY
98185: LIST
98186: LIST
98187: PPUSH
98188: CALL_OW 69
98192: ST_TO_ADDR
// if not tmp then
98193: LD_VAR 0 2
98197: NOT
98198: IFFALSE 98202
// exit ;
98200: GO 98231
// for i in tmp do
98202: LD_ADDR_VAR 0 1
98206: PUSH
98207: LD_VAR 0 2
98211: PUSH
98212: FOR_IN
98213: IFFALSE 98229
// begin SetLives ( i , 0 ) ;
98215: LD_VAR 0 1
98219: PPUSH
98220: LD_INT 0
98222: PPUSH
98223: CALL_OW 234
// end ;
98227: GO 98212
98229: POP
98230: POP
// end ;
98231: PPOPN 2
98233: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98234: LD_EXP 77
98238: PUSH
98239: LD_EXP 80
98243: AND
98244: IFFALSE 98337
98246: GO 98248
98248: DISABLE
98249: LD_INT 0
98251: PPUSH
// begin enable ;
98252: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98253: LD_ADDR_VAR 0 1
98257: PUSH
98258: LD_INT 22
98260: PUSH
98261: LD_OWVAR 2
98265: PUSH
98266: EMPTY
98267: LIST
98268: LIST
98269: PUSH
98270: LD_INT 2
98272: PUSH
98273: LD_INT 25
98275: PUSH
98276: LD_INT 5
98278: PUSH
98279: EMPTY
98280: LIST
98281: LIST
98282: PUSH
98283: LD_INT 25
98285: PUSH
98286: LD_INT 9
98288: PUSH
98289: EMPTY
98290: LIST
98291: LIST
98292: PUSH
98293: LD_INT 25
98295: PUSH
98296: LD_INT 8
98298: PUSH
98299: EMPTY
98300: LIST
98301: LIST
98302: PUSH
98303: EMPTY
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: PUSH
98309: EMPTY
98310: LIST
98311: LIST
98312: PPUSH
98313: CALL_OW 69
98317: PUSH
98318: FOR_IN
98319: IFFALSE 98335
// begin SetClass ( i , 1 ) ;
98321: LD_VAR 0 1
98325: PPUSH
98326: LD_INT 1
98328: PPUSH
98329: CALL_OW 336
// end ;
98333: GO 98318
98335: POP
98336: POP
// end ;
98337: PPOPN 1
98339: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98340: LD_EXP 77
98344: PUSH
98345: LD_EXP 81
98349: AND
98350: PUSH
98351: LD_OWVAR 65
98355: PUSH
98356: LD_INT 7
98358: LESS
98359: AND
98360: IFFALSE 98374
98362: GO 98364
98364: DISABLE
// begin enable ;
98365: ENABLE
// game_speed := 7 ;
98366: LD_ADDR_OWVAR 65
98370: PUSH
98371: LD_INT 7
98373: ST_TO_ADDR
// end ;
98374: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98375: LD_EXP 77
98379: PUSH
98380: LD_EXP 84
98384: AND
98385: IFFALSE 98587
98387: GO 98389
98389: DISABLE
98390: LD_INT 0
98392: PPUSH
98393: PPUSH
98394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98395: LD_ADDR_VAR 0 3
98399: PUSH
98400: LD_INT 81
98402: PUSH
98403: LD_OWVAR 2
98407: PUSH
98408: EMPTY
98409: LIST
98410: LIST
98411: PUSH
98412: LD_INT 21
98414: PUSH
98415: LD_INT 1
98417: PUSH
98418: EMPTY
98419: LIST
98420: LIST
98421: PUSH
98422: EMPTY
98423: LIST
98424: LIST
98425: PPUSH
98426: CALL_OW 69
98430: ST_TO_ADDR
// if not tmp then
98431: LD_VAR 0 3
98435: NOT
98436: IFFALSE 98440
// exit ;
98438: GO 98587
// if tmp > 5 then
98440: LD_VAR 0 3
98444: PUSH
98445: LD_INT 5
98447: GREATER
98448: IFFALSE 98460
// k := 5 else
98450: LD_ADDR_VAR 0 2
98454: PUSH
98455: LD_INT 5
98457: ST_TO_ADDR
98458: GO 98470
// k := tmp ;
98460: LD_ADDR_VAR 0 2
98464: PUSH
98465: LD_VAR 0 3
98469: ST_TO_ADDR
// for i := 1 to k do
98470: LD_ADDR_VAR 0 1
98474: PUSH
98475: DOUBLE
98476: LD_INT 1
98478: DEC
98479: ST_TO_ADDR
98480: LD_VAR 0 2
98484: PUSH
98485: FOR_TO
98486: IFFALSE 98585
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98488: LD_VAR 0 3
98492: PUSH
98493: LD_VAR 0 1
98497: ARRAY
98498: PPUSH
98499: LD_VAR 0 1
98503: PUSH
98504: LD_INT 4
98506: MOD
98507: PUSH
98508: LD_INT 1
98510: PLUS
98511: PPUSH
98512: CALL_OW 259
98516: PUSH
98517: LD_INT 10
98519: LESS
98520: IFFALSE 98583
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98522: LD_VAR 0 3
98526: PUSH
98527: LD_VAR 0 1
98531: ARRAY
98532: PPUSH
98533: LD_VAR 0 1
98537: PUSH
98538: LD_INT 4
98540: MOD
98541: PUSH
98542: LD_INT 1
98544: PLUS
98545: PPUSH
98546: LD_VAR 0 3
98550: PUSH
98551: LD_VAR 0 1
98555: ARRAY
98556: PPUSH
98557: LD_VAR 0 1
98561: PUSH
98562: LD_INT 4
98564: MOD
98565: PUSH
98566: LD_INT 1
98568: PLUS
98569: PPUSH
98570: CALL_OW 259
98574: PUSH
98575: LD_INT 1
98577: PLUS
98578: PPUSH
98579: CALL_OW 237
98583: GO 98485
98585: POP
98586: POP
// end ;
98587: PPOPN 3
98589: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98590: LD_EXP 77
98594: PUSH
98595: LD_EXP 85
98599: AND
98600: IFFALSE 98620
98602: GO 98604
98604: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98605: LD_INT 4
98607: PPUSH
98608: LD_OWVAR 2
98612: PPUSH
98613: LD_INT 0
98615: PPUSH
98616: CALL_OW 324
98620: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98621: LD_EXP 77
98625: PUSH
98626: LD_EXP 114
98630: AND
98631: IFFALSE 98651
98633: GO 98635
98635: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98636: LD_INT 19
98638: PPUSH
98639: LD_OWVAR 2
98643: PPUSH
98644: LD_INT 0
98646: PPUSH
98647: CALL_OW 324
98651: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98652: LD_EXP 77
98656: PUSH
98657: LD_EXP 86
98661: AND
98662: IFFALSE 98764
98664: GO 98666
98666: DISABLE
98667: LD_INT 0
98669: PPUSH
98670: PPUSH
// begin enable ;
98671: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98672: LD_ADDR_VAR 0 2
98676: PUSH
98677: LD_INT 22
98679: PUSH
98680: LD_OWVAR 2
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: PUSH
98689: LD_INT 2
98691: PUSH
98692: LD_INT 34
98694: PUSH
98695: LD_INT 11
98697: PUSH
98698: EMPTY
98699: LIST
98700: LIST
98701: PUSH
98702: LD_INT 34
98704: PUSH
98705: LD_INT 30
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PUSH
98712: EMPTY
98713: LIST
98714: LIST
98715: LIST
98716: PUSH
98717: EMPTY
98718: LIST
98719: LIST
98720: PPUSH
98721: CALL_OW 69
98725: ST_TO_ADDR
// if not tmp then
98726: LD_VAR 0 2
98730: NOT
98731: IFFALSE 98735
// exit ;
98733: GO 98764
// for i in tmp do
98735: LD_ADDR_VAR 0 1
98739: PUSH
98740: LD_VAR 0 2
98744: PUSH
98745: FOR_IN
98746: IFFALSE 98762
// begin SetLives ( i , 0 ) ;
98748: LD_VAR 0 1
98752: PPUSH
98753: LD_INT 0
98755: PPUSH
98756: CALL_OW 234
// end ;
98760: GO 98745
98762: POP
98763: POP
// end ;
98764: PPOPN 2
98766: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98767: LD_EXP 77
98771: PUSH
98772: LD_EXP 87
98776: AND
98777: IFFALSE 98797
98779: GO 98781
98781: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98782: LD_INT 32
98784: PPUSH
98785: LD_OWVAR 2
98789: PPUSH
98790: LD_INT 0
98792: PPUSH
98793: CALL_OW 324
98797: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98798: LD_EXP 77
98802: PUSH
98803: LD_EXP 88
98807: AND
98808: IFFALSE 98989
98810: GO 98812
98812: DISABLE
98813: LD_INT 0
98815: PPUSH
98816: PPUSH
98817: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98818: LD_ADDR_VAR 0 2
98822: PUSH
98823: LD_INT 22
98825: PUSH
98826: LD_OWVAR 2
98830: PUSH
98831: EMPTY
98832: LIST
98833: LIST
98834: PUSH
98835: LD_INT 33
98837: PUSH
98838: LD_INT 3
98840: PUSH
98841: EMPTY
98842: LIST
98843: LIST
98844: PUSH
98845: EMPTY
98846: LIST
98847: LIST
98848: PPUSH
98849: CALL_OW 69
98853: ST_TO_ADDR
// if not tmp then
98854: LD_VAR 0 2
98858: NOT
98859: IFFALSE 98863
// exit ;
98861: GO 98989
// side := 0 ;
98863: LD_ADDR_VAR 0 3
98867: PUSH
98868: LD_INT 0
98870: ST_TO_ADDR
// for i := 1 to 8 do
98871: LD_ADDR_VAR 0 1
98875: PUSH
98876: DOUBLE
98877: LD_INT 1
98879: DEC
98880: ST_TO_ADDR
98881: LD_INT 8
98883: PUSH
98884: FOR_TO
98885: IFFALSE 98933
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98887: LD_OWVAR 2
98891: PUSH
98892: LD_VAR 0 1
98896: NONEQUAL
98897: PUSH
98898: LD_OWVAR 2
98902: PPUSH
98903: LD_VAR 0 1
98907: PPUSH
98908: CALL_OW 81
98912: PUSH
98913: LD_INT 2
98915: EQUAL
98916: AND
98917: IFFALSE 98931
// begin side := i ;
98919: LD_ADDR_VAR 0 3
98923: PUSH
98924: LD_VAR 0 1
98928: ST_TO_ADDR
// break ;
98929: GO 98933
// end ;
98931: GO 98884
98933: POP
98934: POP
// if not side then
98935: LD_VAR 0 3
98939: NOT
98940: IFFALSE 98944
// exit ;
98942: GO 98989
// for i := 1 to tmp do
98944: LD_ADDR_VAR 0 1
98948: PUSH
98949: DOUBLE
98950: LD_INT 1
98952: DEC
98953: ST_TO_ADDR
98954: LD_VAR 0 2
98958: PUSH
98959: FOR_TO
98960: IFFALSE 98987
// if Prob ( 60 ) then
98962: LD_INT 60
98964: PPUSH
98965: CALL_OW 13
98969: IFFALSE 98985
// SetSide ( i , side ) ;
98971: LD_VAR 0 1
98975: PPUSH
98976: LD_VAR 0 3
98980: PPUSH
98981: CALL_OW 235
98985: GO 98959
98987: POP
98988: POP
// end ;
98989: PPOPN 3
98991: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98992: LD_EXP 77
98996: PUSH
98997: LD_EXP 90
99001: AND
99002: IFFALSE 99121
99004: GO 99006
99006: DISABLE
99007: LD_INT 0
99009: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99010: LD_ADDR_VAR 0 1
99014: PUSH
99015: LD_INT 22
99017: PUSH
99018: LD_OWVAR 2
99022: PUSH
99023: EMPTY
99024: LIST
99025: LIST
99026: PUSH
99027: LD_INT 21
99029: PUSH
99030: LD_INT 1
99032: PUSH
99033: EMPTY
99034: LIST
99035: LIST
99036: PUSH
99037: LD_INT 3
99039: PUSH
99040: LD_INT 23
99042: PUSH
99043: LD_INT 0
99045: PUSH
99046: EMPTY
99047: LIST
99048: LIST
99049: PUSH
99050: EMPTY
99051: LIST
99052: LIST
99053: PUSH
99054: EMPTY
99055: LIST
99056: LIST
99057: LIST
99058: PPUSH
99059: CALL_OW 69
99063: PUSH
99064: FOR_IN
99065: IFFALSE 99119
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99067: LD_VAR 0 1
99071: PPUSH
99072: CALL_OW 257
99076: PUSH
99077: LD_INT 1
99079: PUSH
99080: LD_INT 2
99082: PUSH
99083: LD_INT 3
99085: PUSH
99086: LD_INT 4
99088: PUSH
99089: EMPTY
99090: LIST
99091: LIST
99092: LIST
99093: LIST
99094: IN
99095: IFFALSE 99117
// SetClass ( un , rand ( 1 , 4 ) ) ;
99097: LD_VAR 0 1
99101: PPUSH
99102: LD_INT 1
99104: PPUSH
99105: LD_INT 4
99107: PPUSH
99108: CALL_OW 12
99112: PPUSH
99113: CALL_OW 336
99117: GO 99064
99119: POP
99120: POP
// end ;
99121: PPOPN 1
99123: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99124: LD_EXP 77
99128: PUSH
99129: LD_EXP 89
99133: AND
99134: IFFALSE 99213
99136: GO 99138
99138: DISABLE
99139: LD_INT 0
99141: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99142: LD_ADDR_VAR 0 1
99146: PUSH
99147: LD_INT 22
99149: PUSH
99150: LD_OWVAR 2
99154: PUSH
99155: EMPTY
99156: LIST
99157: LIST
99158: PUSH
99159: LD_INT 21
99161: PUSH
99162: LD_INT 3
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: PPUSH
99173: CALL_OW 69
99177: ST_TO_ADDR
// if not tmp then
99178: LD_VAR 0 1
99182: NOT
99183: IFFALSE 99187
// exit ;
99185: GO 99213
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99187: LD_VAR 0 1
99191: PUSH
99192: LD_INT 1
99194: PPUSH
99195: LD_VAR 0 1
99199: PPUSH
99200: CALL_OW 12
99204: ARRAY
99205: PPUSH
99206: LD_INT 100
99208: PPUSH
99209: CALL_OW 234
// end ;
99213: PPOPN 1
99215: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99216: LD_EXP 77
99220: PUSH
99221: LD_EXP 91
99225: AND
99226: IFFALSE 99324
99228: GO 99230
99230: DISABLE
99231: LD_INT 0
99233: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99234: LD_ADDR_VAR 0 1
99238: PUSH
99239: LD_INT 22
99241: PUSH
99242: LD_OWVAR 2
99246: PUSH
99247: EMPTY
99248: LIST
99249: LIST
99250: PUSH
99251: LD_INT 21
99253: PUSH
99254: LD_INT 1
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: PUSH
99261: EMPTY
99262: LIST
99263: LIST
99264: PPUSH
99265: CALL_OW 69
99269: ST_TO_ADDR
// if not tmp then
99270: LD_VAR 0 1
99274: NOT
99275: IFFALSE 99279
// exit ;
99277: GO 99324
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99279: LD_VAR 0 1
99283: PUSH
99284: LD_INT 1
99286: PPUSH
99287: LD_VAR 0 1
99291: PPUSH
99292: CALL_OW 12
99296: ARRAY
99297: PPUSH
99298: LD_INT 1
99300: PPUSH
99301: LD_INT 4
99303: PPUSH
99304: CALL_OW 12
99308: PPUSH
99309: LD_INT 3000
99311: PPUSH
99312: LD_INT 9000
99314: PPUSH
99315: CALL_OW 12
99319: PPUSH
99320: CALL_OW 492
// end ;
99324: PPOPN 1
99326: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99327: LD_EXP 77
99331: PUSH
99332: LD_EXP 92
99336: AND
99337: IFFALSE 99357
99339: GO 99341
99341: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99342: LD_INT 1
99344: PPUSH
99345: LD_OWVAR 2
99349: PPUSH
99350: LD_INT 0
99352: PPUSH
99353: CALL_OW 324
99357: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99358: LD_EXP 77
99362: PUSH
99363: LD_EXP 93
99367: AND
99368: IFFALSE 99451
99370: GO 99372
99372: DISABLE
99373: LD_INT 0
99375: PPUSH
99376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99377: LD_ADDR_VAR 0 2
99381: PUSH
99382: LD_INT 22
99384: PUSH
99385: LD_OWVAR 2
99389: PUSH
99390: EMPTY
99391: LIST
99392: LIST
99393: PUSH
99394: LD_INT 21
99396: PUSH
99397: LD_INT 3
99399: PUSH
99400: EMPTY
99401: LIST
99402: LIST
99403: PUSH
99404: EMPTY
99405: LIST
99406: LIST
99407: PPUSH
99408: CALL_OW 69
99412: ST_TO_ADDR
// if not tmp then
99413: LD_VAR 0 2
99417: NOT
99418: IFFALSE 99422
// exit ;
99420: GO 99451
// for i in tmp do
99422: LD_ADDR_VAR 0 1
99426: PUSH
99427: LD_VAR 0 2
99431: PUSH
99432: FOR_IN
99433: IFFALSE 99449
// SetBLevel ( i , 10 ) ;
99435: LD_VAR 0 1
99439: PPUSH
99440: LD_INT 10
99442: PPUSH
99443: CALL_OW 241
99447: GO 99432
99449: POP
99450: POP
// end ;
99451: PPOPN 2
99453: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99454: LD_EXP 77
99458: PUSH
99459: LD_EXP 94
99463: AND
99464: IFFALSE 99575
99466: GO 99468
99468: DISABLE
99469: LD_INT 0
99471: PPUSH
99472: PPUSH
99473: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99474: LD_ADDR_VAR 0 3
99478: PUSH
99479: LD_INT 22
99481: PUSH
99482: LD_OWVAR 2
99486: PUSH
99487: EMPTY
99488: LIST
99489: LIST
99490: PUSH
99491: LD_INT 25
99493: PUSH
99494: LD_INT 1
99496: PUSH
99497: EMPTY
99498: LIST
99499: LIST
99500: PUSH
99501: EMPTY
99502: LIST
99503: LIST
99504: PPUSH
99505: CALL_OW 69
99509: ST_TO_ADDR
// if not tmp then
99510: LD_VAR 0 3
99514: NOT
99515: IFFALSE 99519
// exit ;
99517: GO 99575
// un := tmp [ rand ( 1 , tmp ) ] ;
99519: LD_ADDR_VAR 0 2
99523: PUSH
99524: LD_VAR 0 3
99528: PUSH
99529: LD_INT 1
99531: PPUSH
99532: LD_VAR 0 3
99536: PPUSH
99537: CALL_OW 12
99541: ARRAY
99542: ST_TO_ADDR
// if Crawls ( un ) then
99543: LD_VAR 0 2
99547: PPUSH
99548: CALL_OW 318
99552: IFFALSE 99563
// ComWalk ( un ) ;
99554: LD_VAR 0 2
99558: PPUSH
99559: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99563: LD_VAR 0 2
99567: PPUSH
99568: LD_INT 5
99570: PPUSH
99571: CALL_OW 336
// end ;
99575: PPOPN 3
99577: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99578: LD_EXP 77
99582: PUSH
99583: LD_EXP 95
99587: AND
99588: PUSH
99589: LD_OWVAR 67
99593: PUSH
99594: LD_INT 4
99596: LESS
99597: AND
99598: IFFALSE 99617
99600: GO 99602
99602: DISABLE
// begin Difficulty := Difficulty + 1 ;
99603: LD_ADDR_OWVAR 67
99607: PUSH
99608: LD_OWVAR 67
99612: PUSH
99613: LD_INT 1
99615: PLUS
99616: ST_TO_ADDR
// end ;
99617: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99618: LD_EXP 77
99622: PUSH
99623: LD_EXP 96
99627: AND
99628: IFFALSE 99731
99630: GO 99632
99632: DISABLE
99633: LD_INT 0
99635: PPUSH
// begin for i := 1 to 5 do
99636: LD_ADDR_VAR 0 1
99640: PUSH
99641: DOUBLE
99642: LD_INT 1
99644: DEC
99645: ST_TO_ADDR
99646: LD_INT 5
99648: PUSH
99649: FOR_TO
99650: IFFALSE 99729
// begin uc_nation := nation_nature ;
99652: LD_ADDR_OWVAR 21
99656: PUSH
99657: LD_INT 0
99659: ST_TO_ADDR
// uc_side := 0 ;
99660: LD_ADDR_OWVAR 20
99664: PUSH
99665: LD_INT 0
99667: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99668: LD_ADDR_OWVAR 29
99672: PUSH
99673: LD_INT 12
99675: PUSH
99676: LD_INT 12
99678: PUSH
99679: EMPTY
99680: LIST
99681: LIST
99682: ST_TO_ADDR
// hc_agressivity := 20 ;
99683: LD_ADDR_OWVAR 35
99687: PUSH
99688: LD_INT 20
99690: ST_TO_ADDR
// hc_class := class_tiger ;
99691: LD_ADDR_OWVAR 28
99695: PUSH
99696: LD_INT 14
99698: ST_TO_ADDR
// hc_gallery :=  ;
99699: LD_ADDR_OWVAR 33
99703: PUSH
99704: LD_STRING 
99706: ST_TO_ADDR
// hc_name :=  ;
99707: LD_ADDR_OWVAR 26
99711: PUSH
99712: LD_STRING 
99714: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99715: CALL_OW 44
99719: PPUSH
99720: LD_INT 0
99722: PPUSH
99723: CALL_OW 51
// end ;
99727: GO 99649
99729: POP
99730: POP
// end ;
99731: PPOPN 1
99733: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99734: LD_EXP 77
99738: PUSH
99739: LD_EXP 97
99743: AND
99744: IFFALSE 99753
99746: GO 99748
99748: DISABLE
// StreamSibBomb ;
99749: CALL 99754 0 0
99753: END
// export function StreamSibBomb ; var i , x , y ; begin
99754: LD_INT 0
99756: PPUSH
99757: PPUSH
99758: PPUSH
99759: PPUSH
// result := false ;
99760: LD_ADDR_VAR 0 1
99764: PUSH
99765: LD_INT 0
99767: ST_TO_ADDR
// for i := 1 to 16 do
99768: LD_ADDR_VAR 0 2
99772: PUSH
99773: DOUBLE
99774: LD_INT 1
99776: DEC
99777: ST_TO_ADDR
99778: LD_INT 16
99780: PUSH
99781: FOR_TO
99782: IFFALSE 99981
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99784: LD_ADDR_VAR 0 3
99788: PUSH
99789: LD_INT 10
99791: PUSH
99792: LD_INT 20
99794: PUSH
99795: LD_INT 30
99797: PUSH
99798: LD_INT 40
99800: PUSH
99801: LD_INT 50
99803: PUSH
99804: LD_INT 60
99806: PUSH
99807: LD_INT 70
99809: PUSH
99810: LD_INT 80
99812: PUSH
99813: LD_INT 90
99815: PUSH
99816: LD_INT 100
99818: PUSH
99819: LD_INT 110
99821: PUSH
99822: LD_INT 120
99824: PUSH
99825: LD_INT 130
99827: PUSH
99828: LD_INT 140
99830: PUSH
99831: LD_INT 150
99833: PUSH
99834: EMPTY
99835: LIST
99836: LIST
99837: LIST
99838: LIST
99839: LIST
99840: LIST
99841: LIST
99842: LIST
99843: LIST
99844: LIST
99845: LIST
99846: LIST
99847: LIST
99848: LIST
99849: LIST
99850: PUSH
99851: LD_INT 1
99853: PPUSH
99854: LD_INT 15
99856: PPUSH
99857: CALL_OW 12
99861: ARRAY
99862: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99863: LD_ADDR_VAR 0 4
99867: PUSH
99868: LD_INT 10
99870: PUSH
99871: LD_INT 20
99873: PUSH
99874: LD_INT 30
99876: PUSH
99877: LD_INT 40
99879: PUSH
99880: LD_INT 50
99882: PUSH
99883: LD_INT 60
99885: PUSH
99886: LD_INT 70
99888: PUSH
99889: LD_INT 80
99891: PUSH
99892: LD_INT 90
99894: PUSH
99895: LD_INT 100
99897: PUSH
99898: LD_INT 110
99900: PUSH
99901: LD_INT 120
99903: PUSH
99904: LD_INT 130
99906: PUSH
99907: LD_INT 140
99909: PUSH
99910: LD_INT 150
99912: PUSH
99913: EMPTY
99914: LIST
99915: LIST
99916: LIST
99917: LIST
99918: LIST
99919: LIST
99920: LIST
99921: LIST
99922: LIST
99923: LIST
99924: LIST
99925: LIST
99926: LIST
99927: LIST
99928: LIST
99929: PUSH
99930: LD_INT 1
99932: PPUSH
99933: LD_INT 15
99935: PPUSH
99936: CALL_OW 12
99940: ARRAY
99941: ST_TO_ADDR
// if ValidHex ( x , y ) then
99942: LD_VAR 0 3
99946: PPUSH
99947: LD_VAR 0 4
99951: PPUSH
99952: CALL_OW 488
99956: IFFALSE 99979
// begin result := [ x , y ] ;
99958: LD_ADDR_VAR 0 1
99962: PUSH
99963: LD_VAR 0 3
99967: PUSH
99968: LD_VAR 0 4
99972: PUSH
99973: EMPTY
99974: LIST
99975: LIST
99976: ST_TO_ADDR
// break ;
99977: GO 99981
// end ; end ;
99979: GO 99781
99981: POP
99982: POP
// if result then
99983: LD_VAR 0 1
99987: IFFALSE 100047
// begin ToLua ( playSibBomb() ) ;
99989: LD_STRING playSibBomb()
99991: PPUSH
99992: CALL_OW 559
// wait ( 0 0$14 ) ;
99996: LD_INT 490
99998: PPUSH
99999: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100003: LD_VAR 0 1
100007: PUSH
100008: LD_INT 1
100010: ARRAY
100011: PPUSH
100012: LD_VAR 0 1
100016: PUSH
100017: LD_INT 2
100019: ARRAY
100020: PPUSH
100021: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100025: LD_VAR 0 1
100029: PUSH
100030: LD_INT 1
100032: ARRAY
100033: PPUSH
100034: LD_VAR 0 1
100038: PUSH
100039: LD_INT 2
100041: ARRAY
100042: PPUSH
100043: CALL_OW 429
// end ; end ;
100047: LD_VAR 0 1
100051: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100052: LD_EXP 77
100056: PUSH
100057: LD_EXP 99
100061: AND
100062: IFFALSE 100074
100064: GO 100066
100066: DISABLE
// YouLost (  ) ;
100067: LD_STRING 
100069: PPUSH
100070: CALL_OW 104
100074: END
// every 0 0$1 trigger StreamModeActive and sFog do
100075: LD_EXP 77
100079: PUSH
100080: LD_EXP 98
100084: AND
100085: IFFALSE 100099
100087: GO 100089
100089: DISABLE
// FogOff ( your_side ) ;
100090: LD_OWVAR 2
100094: PPUSH
100095: CALL_OW 344
100099: END
// every 0 0$1 trigger StreamModeActive and sSun do
100100: LD_EXP 77
100104: PUSH
100105: LD_EXP 100
100109: AND
100110: IFFALSE 100138
100112: GO 100114
100114: DISABLE
// begin solar_recharge_percent := 0 ;
100115: LD_ADDR_OWVAR 79
100119: PUSH
100120: LD_INT 0
100122: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100123: LD_INT 10500
100125: PPUSH
100126: CALL_OW 67
// solar_recharge_percent := 100 ;
100130: LD_ADDR_OWVAR 79
100134: PUSH
100135: LD_INT 100
100137: ST_TO_ADDR
// end ;
100138: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100139: LD_EXP 77
100143: PUSH
100144: LD_EXP 101
100148: AND
100149: IFFALSE 100388
100151: GO 100153
100153: DISABLE
100154: LD_INT 0
100156: PPUSH
100157: PPUSH
100158: PPUSH
// begin tmp := [ ] ;
100159: LD_ADDR_VAR 0 3
100163: PUSH
100164: EMPTY
100165: ST_TO_ADDR
// for i := 1 to 6 do
100166: LD_ADDR_VAR 0 1
100170: PUSH
100171: DOUBLE
100172: LD_INT 1
100174: DEC
100175: ST_TO_ADDR
100176: LD_INT 6
100178: PUSH
100179: FOR_TO
100180: IFFALSE 100285
// begin uc_nation := nation_nature ;
100182: LD_ADDR_OWVAR 21
100186: PUSH
100187: LD_INT 0
100189: ST_TO_ADDR
// uc_side := 0 ;
100190: LD_ADDR_OWVAR 20
100194: PUSH
100195: LD_INT 0
100197: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100198: LD_ADDR_OWVAR 29
100202: PUSH
100203: LD_INT 12
100205: PUSH
100206: LD_INT 12
100208: PUSH
100209: EMPTY
100210: LIST
100211: LIST
100212: ST_TO_ADDR
// hc_agressivity := 20 ;
100213: LD_ADDR_OWVAR 35
100217: PUSH
100218: LD_INT 20
100220: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100221: LD_ADDR_OWVAR 28
100225: PUSH
100226: LD_INT 17
100228: ST_TO_ADDR
// hc_gallery :=  ;
100229: LD_ADDR_OWVAR 33
100233: PUSH
100234: LD_STRING 
100236: ST_TO_ADDR
// hc_name :=  ;
100237: LD_ADDR_OWVAR 26
100241: PUSH
100242: LD_STRING 
100244: ST_TO_ADDR
// un := CreateHuman ;
100245: LD_ADDR_VAR 0 2
100249: PUSH
100250: CALL_OW 44
100254: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100255: LD_VAR 0 2
100259: PPUSH
100260: LD_INT 1
100262: PPUSH
100263: CALL_OW 51
// tmp := tmp ^ un ;
100267: LD_ADDR_VAR 0 3
100271: PUSH
100272: LD_VAR 0 3
100276: PUSH
100277: LD_VAR 0 2
100281: ADD
100282: ST_TO_ADDR
// end ;
100283: GO 100179
100285: POP
100286: POP
// repeat wait ( 0 0$1 ) ;
100287: LD_INT 35
100289: PPUSH
100290: CALL_OW 67
// for un in tmp do
100294: LD_ADDR_VAR 0 2
100298: PUSH
100299: LD_VAR 0 3
100303: PUSH
100304: FOR_IN
100305: IFFALSE 100379
// begin if IsDead ( un ) then
100307: LD_VAR 0 2
100311: PPUSH
100312: CALL_OW 301
100316: IFFALSE 100336
// begin tmp := tmp diff un ;
100318: LD_ADDR_VAR 0 3
100322: PUSH
100323: LD_VAR 0 3
100327: PUSH
100328: LD_VAR 0 2
100332: DIFF
100333: ST_TO_ADDR
// continue ;
100334: GO 100304
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100336: LD_VAR 0 2
100340: PPUSH
100341: LD_INT 3
100343: PUSH
100344: LD_INT 22
100346: PUSH
100347: LD_INT 0
100349: PUSH
100350: EMPTY
100351: LIST
100352: LIST
100353: PUSH
100354: EMPTY
100355: LIST
100356: LIST
100357: PPUSH
100358: CALL_OW 69
100362: PPUSH
100363: LD_VAR 0 2
100367: PPUSH
100368: CALL_OW 74
100372: PPUSH
100373: CALL_OW 115
// end ;
100377: GO 100304
100379: POP
100380: POP
// until not tmp ;
100381: LD_VAR 0 3
100385: NOT
100386: IFFALSE 100287
// end ;
100388: PPOPN 3
100390: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100391: LD_EXP 77
100395: PUSH
100396: LD_EXP 102
100400: AND
100401: IFFALSE 100455
100403: GO 100405
100405: DISABLE
// begin ToLua ( displayTroll(); ) ;
100406: LD_STRING displayTroll();
100408: PPUSH
100409: CALL_OW 559
// wait ( 3 3$00 ) ;
100413: LD_INT 6300
100415: PPUSH
100416: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100420: LD_STRING hideTroll();
100422: PPUSH
100423: CALL_OW 559
// wait ( 1 1$00 ) ;
100427: LD_INT 2100
100429: PPUSH
100430: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100434: LD_STRING displayTroll();
100436: PPUSH
100437: CALL_OW 559
// wait ( 1 1$00 ) ;
100441: LD_INT 2100
100443: PPUSH
100444: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100448: LD_STRING hideTroll();
100450: PPUSH
100451: CALL_OW 559
// end ;
100455: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100456: LD_EXP 77
100460: PUSH
100461: LD_EXP 103
100465: AND
100466: IFFALSE 100529
100468: GO 100470
100470: DISABLE
100471: LD_INT 0
100473: PPUSH
// begin p := 0 ;
100474: LD_ADDR_VAR 0 1
100478: PUSH
100479: LD_INT 0
100481: ST_TO_ADDR
// repeat game_speed := 1 ;
100482: LD_ADDR_OWVAR 65
100486: PUSH
100487: LD_INT 1
100489: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100490: LD_INT 35
100492: PPUSH
100493: CALL_OW 67
// p := p + 1 ;
100497: LD_ADDR_VAR 0 1
100501: PUSH
100502: LD_VAR 0 1
100506: PUSH
100507: LD_INT 1
100509: PLUS
100510: ST_TO_ADDR
// until p >= 60 ;
100511: LD_VAR 0 1
100515: PUSH
100516: LD_INT 60
100518: GREATEREQUAL
100519: IFFALSE 100482
// game_speed := 4 ;
100521: LD_ADDR_OWVAR 65
100525: PUSH
100526: LD_INT 4
100528: ST_TO_ADDR
// end ;
100529: PPOPN 1
100531: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100532: LD_EXP 77
100536: PUSH
100537: LD_EXP 104
100541: AND
100542: IFFALSE 100688
100544: GO 100546
100546: DISABLE
100547: LD_INT 0
100549: PPUSH
100550: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100551: LD_ADDR_VAR 0 1
100555: PUSH
100556: LD_INT 22
100558: PUSH
100559: LD_OWVAR 2
100563: PUSH
100564: EMPTY
100565: LIST
100566: LIST
100567: PUSH
100568: LD_INT 2
100570: PUSH
100571: LD_INT 30
100573: PUSH
100574: LD_INT 0
100576: PUSH
100577: EMPTY
100578: LIST
100579: LIST
100580: PUSH
100581: LD_INT 30
100583: PUSH
100584: LD_INT 1
100586: PUSH
100587: EMPTY
100588: LIST
100589: LIST
100590: PUSH
100591: EMPTY
100592: LIST
100593: LIST
100594: LIST
100595: PUSH
100596: EMPTY
100597: LIST
100598: LIST
100599: PPUSH
100600: CALL_OW 69
100604: ST_TO_ADDR
// if not depot then
100605: LD_VAR 0 1
100609: NOT
100610: IFFALSE 100614
// exit ;
100612: GO 100688
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100614: LD_ADDR_VAR 0 2
100618: PUSH
100619: LD_VAR 0 1
100623: PUSH
100624: LD_INT 1
100626: PPUSH
100627: LD_VAR 0 1
100631: PPUSH
100632: CALL_OW 12
100636: ARRAY
100637: PPUSH
100638: CALL_OW 274
100642: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100643: LD_VAR 0 2
100647: PPUSH
100648: LD_INT 1
100650: PPUSH
100651: LD_INT 0
100653: PPUSH
100654: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100658: LD_VAR 0 2
100662: PPUSH
100663: LD_INT 2
100665: PPUSH
100666: LD_INT 0
100668: PPUSH
100669: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100673: LD_VAR 0 2
100677: PPUSH
100678: LD_INT 3
100680: PPUSH
100681: LD_INT 0
100683: PPUSH
100684: CALL_OW 277
// end ;
100688: PPOPN 2
100690: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100691: LD_EXP 77
100695: PUSH
100696: LD_EXP 105
100700: AND
100701: IFFALSE 100798
100703: GO 100705
100705: DISABLE
100706: LD_INT 0
100708: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100709: LD_ADDR_VAR 0 1
100713: PUSH
100714: LD_INT 22
100716: PUSH
100717: LD_OWVAR 2
100721: PUSH
100722: EMPTY
100723: LIST
100724: LIST
100725: PUSH
100726: LD_INT 21
100728: PUSH
100729: LD_INT 1
100731: PUSH
100732: EMPTY
100733: LIST
100734: LIST
100735: PUSH
100736: LD_INT 3
100738: PUSH
100739: LD_INT 23
100741: PUSH
100742: LD_INT 0
100744: PUSH
100745: EMPTY
100746: LIST
100747: LIST
100748: PUSH
100749: EMPTY
100750: LIST
100751: LIST
100752: PUSH
100753: EMPTY
100754: LIST
100755: LIST
100756: LIST
100757: PPUSH
100758: CALL_OW 69
100762: ST_TO_ADDR
// if not tmp then
100763: LD_VAR 0 1
100767: NOT
100768: IFFALSE 100772
// exit ;
100770: GO 100798
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100772: LD_VAR 0 1
100776: PUSH
100777: LD_INT 1
100779: PPUSH
100780: LD_VAR 0 1
100784: PPUSH
100785: CALL_OW 12
100789: ARRAY
100790: PPUSH
100791: LD_INT 200
100793: PPUSH
100794: CALL_OW 234
// end ;
100798: PPOPN 1
100800: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100801: LD_EXP 77
100805: PUSH
100806: LD_EXP 106
100810: AND
100811: IFFALSE 100890
100813: GO 100815
100815: DISABLE
100816: LD_INT 0
100818: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100819: LD_ADDR_VAR 0 1
100823: PUSH
100824: LD_INT 22
100826: PUSH
100827: LD_OWVAR 2
100831: PUSH
100832: EMPTY
100833: LIST
100834: LIST
100835: PUSH
100836: LD_INT 21
100838: PUSH
100839: LD_INT 2
100841: PUSH
100842: EMPTY
100843: LIST
100844: LIST
100845: PUSH
100846: EMPTY
100847: LIST
100848: LIST
100849: PPUSH
100850: CALL_OW 69
100854: ST_TO_ADDR
// if not tmp then
100855: LD_VAR 0 1
100859: NOT
100860: IFFALSE 100864
// exit ;
100862: GO 100890
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100864: LD_VAR 0 1
100868: PUSH
100869: LD_INT 1
100871: PPUSH
100872: LD_VAR 0 1
100876: PPUSH
100877: CALL_OW 12
100881: ARRAY
100882: PPUSH
100883: LD_INT 60
100885: PPUSH
100886: CALL_OW 234
// end ;
100890: PPOPN 1
100892: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100893: LD_EXP 77
100897: PUSH
100898: LD_EXP 107
100902: AND
100903: IFFALSE 101002
100905: GO 100907
100907: DISABLE
100908: LD_INT 0
100910: PPUSH
100911: PPUSH
// begin enable ;
100912: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100913: LD_ADDR_VAR 0 1
100917: PUSH
100918: LD_INT 22
100920: PUSH
100921: LD_OWVAR 2
100925: PUSH
100926: EMPTY
100927: LIST
100928: LIST
100929: PUSH
100930: LD_INT 61
100932: PUSH
100933: EMPTY
100934: LIST
100935: PUSH
100936: LD_INT 33
100938: PUSH
100939: LD_INT 2
100941: PUSH
100942: EMPTY
100943: LIST
100944: LIST
100945: PUSH
100946: EMPTY
100947: LIST
100948: LIST
100949: LIST
100950: PPUSH
100951: CALL_OW 69
100955: ST_TO_ADDR
// if not tmp then
100956: LD_VAR 0 1
100960: NOT
100961: IFFALSE 100965
// exit ;
100963: GO 101002
// for i in tmp do
100965: LD_ADDR_VAR 0 2
100969: PUSH
100970: LD_VAR 0 1
100974: PUSH
100975: FOR_IN
100976: IFFALSE 101000
// if IsControledBy ( i ) then
100978: LD_VAR 0 2
100982: PPUSH
100983: CALL_OW 312
100987: IFFALSE 100998
// ComUnlink ( i ) ;
100989: LD_VAR 0 2
100993: PPUSH
100994: CALL_OW 136
100998: GO 100975
101000: POP
101001: POP
// end ;
101002: PPOPN 2
101004: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101005: LD_EXP 77
101009: PUSH
101010: LD_EXP 108
101014: AND
101015: IFFALSE 101155
101017: GO 101019
101019: DISABLE
101020: LD_INT 0
101022: PPUSH
101023: PPUSH
// begin ToLua ( displayPowell(); ) ;
101024: LD_STRING displayPowell();
101026: PPUSH
101027: CALL_OW 559
// uc_side := 0 ;
101031: LD_ADDR_OWVAR 20
101035: PUSH
101036: LD_INT 0
101038: ST_TO_ADDR
// uc_nation := 2 ;
101039: LD_ADDR_OWVAR 21
101043: PUSH
101044: LD_INT 2
101046: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101047: LD_ADDR_OWVAR 37
101051: PUSH
101052: LD_INT 14
101054: ST_TO_ADDR
// vc_engine := engine_siberite ;
101055: LD_ADDR_OWVAR 39
101059: PUSH
101060: LD_INT 3
101062: ST_TO_ADDR
// vc_control := control_apeman ;
101063: LD_ADDR_OWVAR 38
101067: PUSH
101068: LD_INT 5
101070: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101071: LD_ADDR_OWVAR 40
101075: PUSH
101076: LD_INT 29
101078: ST_TO_ADDR
// un := CreateVehicle ;
101079: LD_ADDR_VAR 0 2
101083: PUSH
101084: CALL_OW 45
101088: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101089: LD_VAR 0 2
101093: PPUSH
101094: LD_INT 1
101096: PPUSH
101097: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101101: LD_INT 35
101103: PPUSH
101104: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101108: LD_VAR 0 2
101112: PPUSH
101113: LD_INT 22
101115: PUSH
101116: LD_OWVAR 2
101120: PUSH
101121: EMPTY
101122: LIST
101123: LIST
101124: PPUSH
101125: CALL_OW 69
101129: PPUSH
101130: LD_VAR 0 2
101134: PPUSH
101135: CALL_OW 74
101139: PPUSH
101140: CALL_OW 115
// until IsDead ( un ) ;
101144: LD_VAR 0 2
101148: PPUSH
101149: CALL_OW 301
101153: IFFALSE 101101
// end ;
101155: PPOPN 2
101157: END
// every 0 0$1 trigger StreamModeActive and sStu do
101158: LD_EXP 77
101162: PUSH
101163: LD_EXP 116
101167: AND
101168: IFFALSE 101184
101170: GO 101172
101172: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101173: LD_STRING displayStucuk();
101175: PPUSH
101176: CALL_OW 559
// ResetFog ;
101180: CALL_OW 335
// end ;
101184: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101185: LD_EXP 77
101189: PUSH
101190: LD_EXP 109
101194: AND
101195: IFFALSE 101336
101197: GO 101199
101199: DISABLE
101200: LD_INT 0
101202: PPUSH
101203: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101204: LD_ADDR_VAR 0 2
101208: PUSH
101209: LD_INT 22
101211: PUSH
101212: LD_OWVAR 2
101216: PUSH
101217: EMPTY
101218: LIST
101219: LIST
101220: PUSH
101221: LD_INT 21
101223: PUSH
101224: LD_INT 1
101226: PUSH
101227: EMPTY
101228: LIST
101229: LIST
101230: PUSH
101231: EMPTY
101232: LIST
101233: LIST
101234: PPUSH
101235: CALL_OW 69
101239: ST_TO_ADDR
// if not tmp then
101240: LD_VAR 0 2
101244: NOT
101245: IFFALSE 101249
// exit ;
101247: GO 101336
// un := tmp [ rand ( 1 , tmp ) ] ;
101249: LD_ADDR_VAR 0 1
101253: PUSH
101254: LD_VAR 0 2
101258: PUSH
101259: LD_INT 1
101261: PPUSH
101262: LD_VAR 0 2
101266: PPUSH
101267: CALL_OW 12
101271: ARRAY
101272: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101273: LD_VAR 0 1
101277: PPUSH
101278: LD_INT 0
101280: PPUSH
101281: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101285: LD_VAR 0 1
101289: PPUSH
101290: LD_OWVAR 3
101294: PUSH
101295: LD_VAR 0 1
101299: DIFF
101300: PPUSH
101301: LD_VAR 0 1
101305: PPUSH
101306: CALL_OW 74
101310: PPUSH
101311: CALL_OW 115
// wait ( 0 0$20 ) ;
101315: LD_INT 700
101317: PPUSH
101318: CALL_OW 67
// SetSide ( un , your_side ) ;
101322: LD_VAR 0 1
101326: PPUSH
101327: LD_OWVAR 2
101331: PPUSH
101332: CALL_OW 235
// end ;
101336: PPOPN 2
101338: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101339: LD_EXP 77
101343: PUSH
101344: LD_EXP 110
101348: AND
101349: IFFALSE 101455
101351: GO 101353
101353: DISABLE
101354: LD_INT 0
101356: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101357: LD_ADDR_VAR 0 1
101361: PUSH
101362: LD_INT 22
101364: PUSH
101365: LD_OWVAR 2
101369: PUSH
101370: EMPTY
101371: LIST
101372: LIST
101373: PUSH
101374: LD_INT 2
101376: PUSH
101377: LD_INT 30
101379: PUSH
101380: LD_INT 0
101382: PUSH
101383: EMPTY
101384: LIST
101385: LIST
101386: PUSH
101387: LD_INT 30
101389: PUSH
101390: LD_INT 1
101392: PUSH
101393: EMPTY
101394: LIST
101395: LIST
101396: PUSH
101397: EMPTY
101398: LIST
101399: LIST
101400: LIST
101401: PUSH
101402: EMPTY
101403: LIST
101404: LIST
101405: PPUSH
101406: CALL_OW 69
101410: ST_TO_ADDR
// if not depot then
101411: LD_VAR 0 1
101415: NOT
101416: IFFALSE 101420
// exit ;
101418: GO 101455
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101420: LD_VAR 0 1
101424: PUSH
101425: LD_INT 1
101427: ARRAY
101428: PPUSH
101429: CALL_OW 250
101433: PPUSH
101434: LD_VAR 0 1
101438: PUSH
101439: LD_INT 1
101441: ARRAY
101442: PPUSH
101443: CALL_OW 251
101447: PPUSH
101448: LD_INT 70
101450: PPUSH
101451: CALL_OW 495
// end ;
101455: PPOPN 1
101457: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101458: LD_EXP 77
101462: PUSH
101463: LD_EXP 111
101467: AND
101468: IFFALSE 101679
101470: GO 101472
101472: DISABLE
101473: LD_INT 0
101475: PPUSH
101476: PPUSH
101477: PPUSH
101478: PPUSH
101479: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101480: LD_ADDR_VAR 0 5
101484: PUSH
101485: LD_INT 22
101487: PUSH
101488: LD_OWVAR 2
101492: PUSH
101493: EMPTY
101494: LIST
101495: LIST
101496: PUSH
101497: LD_INT 21
101499: PUSH
101500: LD_INT 1
101502: PUSH
101503: EMPTY
101504: LIST
101505: LIST
101506: PUSH
101507: EMPTY
101508: LIST
101509: LIST
101510: PPUSH
101511: CALL_OW 69
101515: ST_TO_ADDR
// if not tmp then
101516: LD_VAR 0 5
101520: NOT
101521: IFFALSE 101525
// exit ;
101523: GO 101679
// for i in tmp do
101525: LD_ADDR_VAR 0 1
101529: PUSH
101530: LD_VAR 0 5
101534: PUSH
101535: FOR_IN
101536: IFFALSE 101677
// begin d := rand ( 0 , 5 ) ;
101538: LD_ADDR_VAR 0 4
101542: PUSH
101543: LD_INT 0
101545: PPUSH
101546: LD_INT 5
101548: PPUSH
101549: CALL_OW 12
101553: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101554: LD_ADDR_VAR 0 2
101558: PUSH
101559: LD_VAR 0 1
101563: PPUSH
101564: CALL_OW 250
101568: PPUSH
101569: LD_VAR 0 4
101573: PPUSH
101574: LD_INT 3
101576: PPUSH
101577: LD_INT 12
101579: PPUSH
101580: CALL_OW 12
101584: PPUSH
101585: CALL_OW 272
101589: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101590: LD_ADDR_VAR 0 3
101594: PUSH
101595: LD_VAR 0 1
101599: PPUSH
101600: CALL_OW 251
101604: PPUSH
101605: LD_VAR 0 4
101609: PPUSH
101610: LD_INT 3
101612: PPUSH
101613: LD_INT 12
101615: PPUSH
101616: CALL_OW 12
101620: PPUSH
101621: CALL_OW 273
101625: ST_TO_ADDR
// if ValidHex ( x , y ) then
101626: LD_VAR 0 2
101630: PPUSH
101631: LD_VAR 0 3
101635: PPUSH
101636: CALL_OW 488
101640: IFFALSE 101675
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101642: LD_VAR 0 1
101646: PPUSH
101647: LD_VAR 0 2
101651: PPUSH
101652: LD_VAR 0 3
101656: PPUSH
101657: LD_INT 3
101659: PPUSH
101660: LD_INT 6
101662: PPUSH
101663: CALL_OW 12
101667: PPUSH
101668: LD_INT 1
101670: PPUSH
101671: CALL_OW 483
// end ;
101675: GO 101535
101677: POP
101678: POP
// end ;
101679: PPOPN 5
101681: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101682: LD_EXP 77
101686: PUSH
101687: LD_EXP 112
101691: AND
101692: IFFALSE 101786
101694: GO 101696
101696: DISABLE
101697: LD_INT 0
101699: PPUSH
101700: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101701: LD_ADDR_VAR 0 2
101705: PUSH
101706: LD_INT 22
101708: PUSH
101709: LD_OWVAR 2
101713: PUSH
101714: EMPTY
101715: LIST
101716: LIST
101717: PUSH
101718: LD_INT 32
101720: PUSH
101721: LD_INT 1
101723: PUSH
101724: EMPTY
101725: LIST
101726: LIST
101727: PUSH
101728: LD_INT 21
101730: PUSH
101731: LD_INT 2
101733: PUSH
101734: EMPTY
101735: LIST
101736: LIST
101737: PUSH
101738: EMPTY
101739: LIST
101740: LIST
101741: LIST
101742: PPUSH
101743: CALL_OW 69
101747: ST_TO_ADDR
// if not tmp then
101748: LD_VAR 0 2
101752: NOT
101753: IFFALSE 101757
// exit ;
101755: GO 101786
// for i in tmp do
101757: LD_ADDR_VAR 0 1
101761: PUSH
101762: LD_VAR 0 2
101766: PUSH
101767: FOR_IN
101768: IFFALSE 101784
// SetFuel ( i , 0 ) ;
101770: LD_VAR 0 1
101774: PPUSH
101775: LD_INT 0
101777: PPUSH
101778: CALL_OW 240
101782: GO 101767
101784: POP
101785: POP
// end ;
101786: PPOPN 2
101788: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101789: LD_EXP 77
101793: PUSH
101794: LD_EXP 113
101798: AND
101799: IFFALSE 101865
101801: GO 101803
101803: DISABLE
101804: LD_INT 0
101806: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101807: LD_ADDR_VAR 0 1
101811: PUSH
101812: LD_INT 22
101814: PUSH
101815: LD_OWVAR 2
101819: PUSH
101820: EMPTY
101821: LIST
101822: LIST
101823: PUSH
101824: LD_INT 30
101826: PUSH
101827: LD_INT 29
101829: PUSH
101830: EMPTY
101831: LIST
101832: LIST
101833: PUSH
101834: EMPTY
101835: LIST
101836: LIST
101837: PPUSH
101838: CALL_OW 69
101842: ST_TO_ADDR
// if not tmp then
101843: LD_VAR 0 1
101847: NOT
101848: IFFALSE 101852
// exit ;
101850: GO 101865
// DestroyUnit ( tmp [ 1 ] ) ;
101852: LD_VAR 0 1
101856: PUSH
101857: LD_INT 1
101859: ARRAY
101860: PPUSH
101861: CALL_OW 65
// end ;
101865: PPOPN 1
101867: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101868: LD_EXP 77
101872: PUSH
101873: LD_EXP 115
101877: AND
101878: IFFALSE 102007
101880: GO 101882
101882: DISABLE
101883: LD_INT 0
101885: PPUSH
// begin uc_side := 0 ;
101886: LD_ADDR_OWVAR 20
101890: PUSH
101891: LD_INT 0
101893: ST_TO_ADDR
// uc_nation := nation_arabian ;
101894: LD_ADDR_OWVAR 21
101898: PUSH
101899: LD_INT 2
101901: ST_TO_ADDR
// hc_gallery :=  ;
101902: LD_ADDR_OWVAR 33
101906: PUSH
101907: LD_STRING 
101909: ST_TO_ADDR
// hc_name :=  ;
101910: LD_ADDR_OWVAR 26
101914: PUSH
101915: LD_STRING 
101917: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101918: LD_INT 1
101920: PPUSH
101921: LD_INT 11
101923: PPUSH
101924: LD_INT 10
101926: PPUSH
101927: CALL_OW 380
// un := CreateHuman ;
101931: LD_ADDR_VAR 0 1
101935: PUSH
101936: CALL_OW 44
101940: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101941: LD_VAR 0 1
101945: PPUSH
101946: LD_INT 1
101948: PPUSH
101949: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101953: LD_INT 35
101955: PPUSH
101956: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101960: LD_VAR 0 1
101964: PPUSH
101965: LD_INT 22
101967: PUSH
101968: LD_OWVAR 2
101972: PUSH
101973: EMPTY
101974: LIST
101975: LIST
101976: PPUSH
101977: CALL_OW 69
101981: PPUSH
101982: LD_VAR 0 1
101986: PPUSH
101987: CALL_OW 74
101991: PPUSH
101992: CALL_OW 115
// until IsDead ( un ) ;
101996: LD_VAR 0 1
102000: PPUSH
102001: CALL_OW 301
102005: IFFALSE 101953
// end ;
102007: PPOPN 1
102009: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102010: LD_EXP 77
102014: PUSH
102015: LD_EXP 117
102019: AND
102020: IFFALSE 102032
102022: GO 102024
102024: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102025: LD_STRING earthquake(getX(game), 0, 32)
102027: PPUSH
102028: CALL_OW 559
102032: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102033: LD_EXP 77
102037: PUSH
102038: LD_EXP 118
102042: AND
102043: IFFALSE 102134
102045: GO 102047
102047: DISABLE
102048: LD_INT 0
102050: PPUSH
// begin enable ;
102051: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102052: LD_ADDR_VAR 0 1
102056: PUSH
102057: LD_INT 22
102059: PUSH
102060: LD_OWVAR 2
102064: PUSH
102065: EMPTY
102066: LIST
102067: LIST
102068: PUSH
102069: LD_INT 21
102071: PUSH
102072: LD_INT 2
102074: PUSH
102075: EMPTY
102076: LIST
102077: LIST
102078: PUSH
102079: LD_INT 33
102081: PUSH
102082: LD_INT 3
102084: PUSH
102085: EMPTY
102086: LIST
102087: LIST
102088: PUSH
102089: EMPTY
102090: LIST
102091: LIST
102092: LIST
102093: PPUSH
102094: CALL_OW 69
102098: ST_TO_ADDR
// if not tmp then
102099: LD_VAR 0 1
102103: NOT
102104: IFFALSE 102108
// exit ;
102106: GO 102134
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102108: LD_VAR 0 1
102112: PUSH
102113: LD_INT 1
102115: PPUSH
102116: LD_VAR 0 1
102120: PPUSH
102121: CALL_OW 12
102125: ARRAY
102126: PPUSH
102127: LD_INT 1
102129: PPUSH
102130: CALL_OW 234
// end ;
102134: PPOPN 1
102136: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102137: LD_EXP 77
102141: PUSH
102142: LD_EXP 119
102146: AND
102147: IFFALSE 102288
102149: GO 102151
102151: DISABLE
102152: LD_INT 0
102154: PPUSH
102155: PPUSH
102156: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102157: LD_ADDR_VAR 0 3
102161: PUSH
102162: LD_INT 22
102164: PUSH
102165: LD_OWVAR 2
102169: PUSH
102170: EMPTY
102171: LIST
102172: LIST
102173: PUSH
102174: LD_INT 25
102176: PUSH
102177: LD_INT 1
102179: PUSH
102180: EMPTY
102181: LIST
102182: LIST
102183: PUSH
102184: EMPTY
102185: LIST
102186: LIST
102187: PPUSH
102188: CALL_OW 69
102192: ST_TO_ADDR
// if not tmp then
102193: LD_VAR 0 3
102197: NOT
102198: IFFALSE 102202
// exit ;
102200: GO 102288
// un := tmp [ rand ( 1 , tmp ) ] ;
102202: LD_ADDR_VAR 0 2
102206: PUSH
102207: LD_VAR 0 3
102211: PUSH
102212: LD_INT 1
102214: PPUSH
102215: LD_VAR 0 3
102219: PPUSH
102220: CALL_OW 12
102224: ARRAY
102225: ST_TO_ADDR
// if Crawls ( un ) then
102226: LD_VAR 0 2
102230: PPUSH
102231: CALL_OW 318
102235: IFFALSE 102246
// ComWalk ( un ) ;
102237: LD_VAR 0 2
102241: PPUSH
102242: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102246: LD_VAR 0 2
102250: PPUSH
102251: LD_INT 9
102253: PPUSH
102254: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102258: LD_INT 28
102260: PPUSH
102261: LD_OWVAR 2
102265: PPUSH
102266: LD_INT 2
102268: PPUSH
102269: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102273: LD_INT 29
102275: PPUSH
102276: LD_OWVAR 2
102280: PPUSH
102281: LD_INT 2
102283: PPUSH
102284: CALL_OW 322
// end ;
102288: PPOPN 3
102290: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102291: LD_EXP 77
102295: PUSH
102296: LD_EXP 120
102300: AND
102301: IFFALSE 102412
102303: GO 102305
102305: DISABLE
102306: LD_INT 0
102308: PPUSH
102309: PPUSH
102310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102311: LD_ADDR_VAR 0 3
102315: PUSH
102316: LD_INT 22
102318: PUSH
102319: LD_OWVAR 2
102323: PUSH
102324: EMPTY
102325: LIST
102326: LIST
102327: PUSH
102328: LD_INT 25
102330: PUSH
102331: LD_INT 1
102333: PUSH
102334: EMPTY
102335: LIST
102336: LIST
102337: PUSH
102338: EMPTY
102339: LIST
102340: LIST
102341: PPUSH
102342: CALL_OW 69
102346: ST_TO_ADDR
// if not tmp then
102347: LD_VAR 0 3
102351: NOT
102352: IFFALSE 102356
// exit ;
102354: GO 102412
// un := tmp [ rand ( 1 , tmp ) ] ;
102356: LD_ADDR_VAR 0 2
102360: PUSH
102361: LD_VAR 0 3
102365: PUSH
102366: LD_INT 1
102368: PPUSH
102369: LD_VAR 0 3
102373: PPUSH
102374: CALL_OW 12
102378: ARRAY
102379: ST_TO_ADDR
// if Crawls ( un ) then
102380: LD_VAR 0 2
102384: PPUSH
102385: CALL_OW 318
102389: IFFALSE 102400
// ComWalk ( un ) ;
102391: LD_VAR 0 2
102395: PPUSH
102396: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102400: LD_VAR 0 2
102404: PPUSH
102405: LD_INT 8
102407: PPUSH
102408: CALL_OW 336
// end ;
102412: PPOPN 3
102414: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102415: LD_EXP 77
102419: PUSH
102420: LD_EXP 121
102424: AND
102425: IFFALSE 102569
102427: GO 102429
102429: DISABLE
102430: LD_INT 0
102432: PPUSH
102433: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102434: LD_ADDR_VAR 0 2
102438: PUSH
102439: LD_INT 22
102441: PUSH
102442: LD_OWVAR 2
102446: PUSH
102447: EMPTY
102448: LIST
102449: LIST
102450: PUSH
102451: LD_INT 21
102453: PUSH
102454: LD_INT 2
102456: PUSH
102457: EMPTY
102458: LIST
102459: LIST
102460: PUSH
102461: LD_INT 2
102463: PUSH
102464: LD_INT 34
102466: PUSH
102467: LD_INT 12
102469: PUSH
102470: EMPTY
102471: LIST
102472: LIST
102473: PUSH
102474: LD_INT 34
102476: PUSH
102477: LD_INT 51
102479: PUSH
102480: EMPTY
102481: LIST
102482: LIST
102483: PUSH
102484: LD_INT 34
102486: PUSH
102487: LD_INT 32
102489: PUSH
102490: EMPTY
102491: LIST
102492: LIST
102493: PUSH
102494: EMPTY
102495: LIST
102496: LIST
102497: LIST
102498: LIST
102499: PUSH
102500: EMPTY
102501: LIST
102502: LIST
102503: LIST
102504: PPUSH
102505: CALL_OW 69
102509: ST_TO_ADDR
// if not tmp then
102510: LD_VAR 0 2
102514: NOT
102515: IFFALSE 102519
// exit ;
102517: GO 102569
// for i in tmp do
102519: LD_ADDR_VAR 0 1
102523: PUSH
102524: LD_VAR 0 2
102528: PUSH
102529: FOR_IN
102530: IFFALSE 102567
// if GetCargo ( i , mat_artifact ) = 0 then
102532: LD_VAR 0 1
102536: PPUSH
102537: LD_INT 4
102539: PPUSH
102540: CALL_OW 289
102544: PUSH
102545: LD_INT 0
102547: EQUAL
102548: IFFALSE 102565
// SetCargo ( i , mat_siberit , 100 ) ;
102550: LD_VAR 0 1
102554: PPUSH
102555: LD_INT 3
102557: PPUSH
102558: LD_INT 100
102560: PPUSH
102561: CALL_OW 290
102565: GO 102529
102567: POP
102568: POP
// end ;
102569: PPOPN 2
102571: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102572: LD_EXP 77
102576: PUSH
102577: LD_EXP 122
102581: AND
102582: IFFALSE 102765
102584: GO 102586
102586: DISABLE
102587: LD_INT 0
102589: PPUSH
102590: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102591: LD_ADDR_VAR 0 2
102595: PUSH
102596: LD_INT 22
102598: PUSH
102599: LD_OWVAR 2
102603: PUSH
102604: EMPTY
102605: LIST
102606: LIST
102607: PPUSH
102608: CALL_OW 69
102612: ST_TO_ADDR
// if not tmp then
102613: LD_VAR 0 2
102617: NOT
102618: IFFALSE 102622
// exit ;
102620: GO 102765
// for i := 1 to 2 do
102622: LD_ADDR_VAR 0 1
102626: PUSH
102627: DOUBLE
102628: LD_INT 1
102630: DEC
102631: ST_TO_ADDR
102632: LD_INT 2
102634: PUSH
102635: FOR_TO
102636: IFFALSE 102763
// begin uc_side := your_side ;
102638: LD_ADDR_OWVAR 20
102642: PUSH
102643: LD_OWVAR 2
102647: ST_TO_ADDR
// uc_nation := nation_american ;
102648: LD_ADDR_OWVAR 21
102652: PUSH
102653: LD_INT 1
102655: ST_TO_ADDR
// vc_chassis := us_morphling ;
102656: LD_ADDR_OWVAR 37
102660: PUSH
102661: LD_INT 5
102663: ST_TO_ADDR
// vc_engine := engine_siberite ;
102664: LD_ADDR_OWVAR 39
102668: PUSH
102669: LD_INT 3
102671: ST_TO_ADDR
// vc_control := control_computer ;
102672: LD_ADDR_OWVAR 38
102676: PUSH
102677: LD_INT 3
102679: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102680: LD_ADDR_OWVAR 40
102684: PUSH
102685: LD_INT 10
102687: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102688: LD_VAR 0 2
102692: PUSH
102693: LD_INT 1
102695: ARRAY
102696: PPUSH
102697: CALL_OW 310
102701: NOT
102702: IFFALSE 102749
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102704: CALL_OW 45
102708: PPUSH
102709: LD_VAR 0 2
102713: PUSH
102714: LD_INT 1
102716: ARRAY
102717: PPUSH
102718: CALL_OW 250
102722: PPUSH
102723: LD_VAR 0 2
102727: PUSH
102728: LD_INT 1
102730: ARRAY
102731: PPUSH
102732: CALL_OW 251
102736: PPUSH
102737: LD_INT 12
102739: PPUSH
102740: LD_INT 1
102742: PPUSH
102743: CALL_OW 50
102747: GO 102761
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102749: CALL_OW 45
102753: PPUSH
102754: LD_INT 1
102756: PPUSH
102757: CALL_OW 51
// end ;
102761: GO 102635
102763: POP
102764: POP
// end ;
102765: PPOPN 2
102767: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102768: LD_EXP 77
102772: PUSH
102773: LD_EXP 123
102777: AND
102778: IFFALSE 103000
102780: GO 102782
102782: DISABLE
102783: LD_INT 0
102785: PPUSH
102786: PPUSH
102787: PPUSH
102788: PPUSH
102789: PPUSH
102790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102791: LD_ADDR_VAR 0 6
102795: PUSH
102796: LD_INT 22
102798: PUSH
102799: LD_OWVAR 2
102803: PUSH
102804: EMPTY
102805: LIST
102806: LIST
102807: PUSH
102808: LD_INT 21
102810: PUSH
102811: LD_INT 1
102813: PUSH
102814: EMPTY
102815: LIST
102816: LIST
102817: PUSH
102818: LD_INT 3
102820: PUSH
102821: LD_INT 23
102823: PUSH
102824: LD_INT 0
102826: PUSH
102827: EMPTY
102828: LIST
102829: LIST
102830: PUSH
102831: EMPTY
102832: LIST
102833: LIST
102834: PUSH
102835: EMPTY
102836: LIST
102837: LIST
102838: LIST
102839: PPUSH
102840: CALL_OW 69
102844: ST_TO_ADDR
// if not tmp then
102845: LD_VAR 0 6
102849: NOT
102850: IFFALSE 102854
// exit ;
102852: GO 103000
// s1 := rand ( 1 , 4 ) ;
102854: LD_ADDR_VAR 0 2
102858: PUSH
102859: LD_INT 1
102861: PPUSH
102862: LD_INT 4
102864: PPUSH
102865: CALL_OW 12
102869: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102870: LD_ADDR_VAR 0 4
102874: PUSH
102875: LD_VAR 0 6
102879: PUSH
102880: LD_INT 1
102882: ARRAY
102883: PPUSH
102884: LD_VAR 0 2
102888: PPUSH
102889: CALL_OW 259
102893: ST_TO_ADDR
// if s1 = 1 then
102894: LD_VAR 0 2
102898: PUSH
102899: LD_INT 1
102901: EQUAL
102902: IFFALSE 102922
// s2 := rand ( 2 , 4 ) else
102904: LD_ADDR_VAR 0 3
102908: PUSH
102909: LD_INT 2
102911: PPUSH
102912: LD_INT 4
102914: PPUSH
102915: CALL_OW 12
102919: ST_TO_ADDR
102920: GO 102930
// s2 := 1 ;
102922: LD_ADDR_VAR 0 3
102926: PUSH
102927: LD_INT 1
102929: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102930: LD_ADDR_VAR 0 5
102934: PUSH
102935: LD_VAR 0 6
102939: PUSH
102940: LD_INT 1
102942: ARRAY
102943: PPUSH
102944: LD_VAR 0 3
102948: PPUSH
102949: CALL_OW 259
102953: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102954: LD_VAR 0 6
102958: PUSH
102959: LD_INT 1
102961: ARRAY
102962: PPUSH
102963: LD_VAR 0 2
102967: PPUSH
102968: LD_VAR 0 5
102972: PPUSH
102973: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102977: LD_VAR 0 6
102981: PUSH
102982: LD_INT 1
102984: ARRAY
102985: PPUSH
102986: LD_VAR 0 3
102990: PPUSH
102991: LD_VAR 0 4
102995: PPUSH
102996: CALL_OW 237
// end ;
103000: PPOPN 6
103002: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103003: LD_EXP 77
103007: PUSH
103008: LD_EXP 124
103012: AND
103013: IFFALSE 103092
103015: GO 103017
103017: DISABLE
103018: LD_INT 0
103020: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103021: LD_ADDR_VAR 0 1
103025: PUSH
103026: LD_INT 22
103028: PUSH
103029: LD_OWVAR 2
103033: PUSH
103034: EMPTY
103035: LIST
103036: LIST
103037: PUSH
103038: LD_INT 30
103040: PUSH
103041: LD_INT 3
103043: PUSH
103044: EMPTY
103045: LIST
103046: LIST
103047: PUSH
103048: EMPTY
103049: LIST
103050: LIST
103051: PPUSH
103052: CALL_OW 69
103056: ST_TO_ADDR
// if not tmp then
103057: LD_VAR 0 1
103061: NOT
103062: IFFALSE 103066
// exit ;
103064: GO 103092
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103066: LD_VAR 0 1
103070: PUSH
103071: LD_INT 1
103073: PPUSH
103074: LD_VAR 0 1
103078: PPUSH
103079: CALL_OW 12
103083: ARRAY
103084: PPUSH
103085: LD_INT 1
103087: PPUSH
103088: CALL_OW 234
// end ;
103092: PPOPN 1
103094: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103095: LD_EXP 77
103099: PUSH
103100: LD_EXP 125
103104: AND
103105: IFFALSE 103217
103107: GO 103109
103109: DISABLE
103110: LD_INT 0
103112: PPUSH
103113: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103114: LD_ADDR_VAR 0 2
103118: PUSH
103119: LD_INT 22
103121: PUSH
103122: LD_OWVAR 2
103126: PUSH
103127: EMPTY
103128: LIST
103129: LIST
103130: PUSH
103131: LD_INT 2
103133: PUSH
103134: LD_INT 30
103136: PUSH
103137: LD_INT 27
103139: PUSH
103140: EMPTY
103141: LIST
103142: LIST
103143: PUSH
103144: LD_INT 30
103146: PUSH
103147: LD_INT 26
103149: PUSH
103150: EMPTY
103151: LIST
103152: LIST
103153: PUSH
103154: LD_INT 30
103156: PUSH
103157: LD_INT 28
103159: PUSH
103160: EMPTY
103161: LIST
103162: LIST
103163: PUSH
103164: EMPTY
103165: LIST
103166: LIST
103167: LIST
103168: LIST
103169: PUSH
103170: EMPTY
103171: LIST
103172: LIST
103173: PPUSH
103174: CALL_OW 69
103178: ST_TO_ADDR
// if not tmp then
103179: LD_VAR 0 2
103183: NOT
103184: IFFALSE 103188
// exit ;
103186: GO 103217
// for i in tmp do
103188: LD_ADDR_VAR 0 1
103192: PUSH
103193: LD_VAR 0 2
103197: PUSH
103198: FOR_IN
103199: IFFALSE 103215
// SetLives ( i , 1 ) ;
103201: LD_VAR 0 1
103205: PPUSH
103206: LD_INT 1
103208: PPUSH
103209: CALL_OW 234
103213: GO 103198
103215: POP
103216: POP
// end ;
103217: PPOPN 2
103219: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103220: LD_EXP 77
103224: PUSH
103225: LD_EXP 126
103229: AND
103230: IFFALSE 103517
103232: GO 103234
103234: DISABLE
103235: LD_INT 0
103237: PPUSH
103238: PPUSH
103239: PPUSH
// begin i := rand ( 1 , 7 ) ;
103240: LD_ADDR_VAR 0 1
103244: PUSH
103245: LD_INT 1
103247: PPUSH
103248: LD_INT 7
103250: PPUSH
103251: CALL_OW 12
103255: ST_TO_ADDR
// case i of 1 :
103256: LD_VAR 0 1
103260: PUSH
103261: LD_INT 1
103263: DOUBLE
103264: EQUAL
103265: IFTRUE 103269
103267: GO 103279
103269: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103270: LD_STRING earthquake(getX(game), 0, 32)
103272: PPUSH
103273: CALL_OW 559
103277: GO 103517
103279: LD_INT 2
103281: DOUBLE
103282: EQUAL
103283: IFTRUE 103287
103285: GO 103301
103287: POP
// begin ToLua ( displayStucuk(); ) ;
103288: LD_STRING displayStucuk();
103290: PPUSH
103291: CALL_OW 559
// ResetFog ;
103295: CALL_OW 335
// end ; 3 :
103299: GO 103517
103301: LD_INT 3
103303: DOUBLE
103304: EQUAL
103305: IFTRUE 103309
103307: GO 103413
103309: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103310: LD_ADDR_VAR 0 2
103314: PUSH
103315: LD_INT 22
103317: PUSH
103318: LD_OWVAR 2
103322: PUSH
103323: EMPTY
103324: LIST
103325: LIST
103326: PUSH
103327: LD_INT 25
103329: PUSH
103330: LD_INT 1
103332: PUSH
103333: EMPTY
103334: LIST
103335: LIST
103336: PUSH
103337: EMPTY
103338: LIST
103339: LIST
103340: PPUSH
103341: CALL_OW 69
103345: ST_TO_ADDR
// if not tmp then
103346: LD_VAR 0 2
103350: NOT
103351: IFFALSE 103355
// exit ;
103353: GO 103517
// un := tmp [ rand ( 1 , tmp ) ] ;
103355: LD_ADDR_VAR 0 3
103359: PUSH
103360: LD_VAR 0 2
103364: PUSH
103365: LD_INT 1
103367: PPUSH
103368: LD_VAR 0 2
103372: PPUSH
103373: CALL_OW 12
103377: ARRAY
103378: ST_TO_ADDR
// if Crawls ( un ) then
103379: LD_VAR 0 3
103383: PPUSH
103384: CALL_OW 318
103388: IFFALSE 103399
// ComWalk ( un ) ;
103390: LD_VAR 0 3
103394: PPUSH
103395: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103399: LD_VAR 0 3
103403: PPUSH
103404: LD_INT 8
103406: PPUSH
103407: CALL_OW 336
// end ; 4 :
103411: GO 103517
103413: LD_INT 4
103415: DOUBLE
103416: EQUAL
103417: IFTRUE 103421
103419: GO 103495
103421: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103422: LD_ADDR_VAR 0 2
103426: PUSH
103427: LD_INT 22
103429: PUSH
103430: LD_OWVAR 2
103434: PUSH
103435: EMPTY
103436: LIST
103437: LIST
103438: PUSH
103439: LD_INT 30
103441: PUSH
103442: LD_INT 29
103444: PUSH
103445: EMPTY
103446: LIST
103447: LIST
103448: PUSH
103449: EMPTY
103450: LIST
103451: LIST
103452: PPUSH
103453: CALL_OW 69
103457: ST_TO_ADDR
// if not tmp then
103458: LD_VAR 0 2
103462: NOT
103463: IFFALSE 103467
// exit ;
103465: GO 103517
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103467: LD_VAR 0 2
103471: PUSH
103472: LD_INT 1
103474: ARRAY
103475: PPUSH
103476: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103480: LD_VAR 0 2
103484: PUSH
103485: LD_INT 1
103487: ARRAY
103488: PPUSH
103489: CALL_OW 65
// end ; 5 .. 7 :
103493: GO 103517
103495: LD_INT 5
103497: DOUBLE
103498: GREATEREQUAL
103499: IFFALSE 103507
103501: LD_INT 7
103503: DOUBLE
103504: LESSEQUAL
103505: IFTRUE 103509
103507: GO 103516
103509: POP
// StreamSibBomb ; end ;
103510: CALL 99754 0 0
103514: GO 103517
103516: POP
// end ;
103517: PPOPN 3
103519: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103520: LD_EXP 77
103524: PUSH
103525: LD_EXP 127
103529: AND
103530: IFFALSE 103686
103532: GO 103534
103534: DISABLE
103535: LD_INT 0
103537: PPUSH
103538: PPUSH
103539: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103540: LD_ADDR_VAR 0 2
103544: PUSH
103545: LD_INT 81
103547: PUSH
103548: LD_OWVAR 2
103552: PUSH
103553: EMPTY
103554: LIST
103555: LIST
103556: PUSH
103557: LD_INT 2
103559: PUSH
103560: LD_INT 21
103562: PUSH
103563: LD_INT 1
103565: PUSH
103566: EMPTY
103567: LIST
103568: LIST
103569: PUSH
103570: LD_INT 21
103572: PUSH
103573: LD_INT 2
103575: PUSH
103576: EMPTY
103577: LIST
103578: LIST
103579: PUSH
103580: EMPTY
103581: LIST
103582: LIST
103583: LIST
103584: PUSH
103585: EMPTY
103586: LIST
103587: LIST
103588: PPUSH
103589: CALL_OW 69
103593: ST_TO_ADDR
// if not tmp then
103594: LD_VAR 0 2
103598: NOT
103599: IFFALSE 103603
// exit ;
103601: GO 103686
// p := 0 ;
103603: LD_ADDR_VAR 0 3
103607: PUSH
103608: LD_INT 0
103610: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103611: LD_INT 35
103613: PPUSH
103614: CALL_OW 67
// p := p + 1 ;
103618: LD_ADDR_VAR 0 3
103622: PUSH
103623: LD_VAR 0 3
103627: PUSH
103628: LD_INT 1
103630: PLUS
103631: ST_TO_ADDR
// for i in tmp do
103632: LD_ADDR_VAR 0 1
103636: PUSH
103637: LD_VAR 0 2
103641: PUSH
103642: FOR_IN
103643: IFFALSE 103674
// if GetLives ( i ) < 1000 then
103645: LD_VAR 0 1
103649: PPUSH
103650: CALL_OW 256
103654: PUSH
103655: LD_INT 1000
103657: LESS
103658: IFFALSE 103672
// SetLives ( i , 1000 ) ;
103660: LD_VAR 0 1
103664: PPUSH
103665: LD_INT 1000
103667: PPUSH
103668: CALL_OW 234
103672: GO 103642
103674: POP
103675: POP
// until p > 20 ;
103676: LD_VAR 0 3
103680: PUSH
103681: LD_INT 20
103683: GREATER
103684: IFFALSE 103611
// end ;
103686: PPOPN 3
103688: END
// every 0 0$1 trigger StreamModeActive and sTime do
103689: LD_EXP 77
103693: PUSH
103694: LD_EXP 128
103698: AND
103699: IFFALSE 103734
103701: GO 103703
103703: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103704: LD_INT 28
103706: PPUSH
103707: LD_OWVAR 2
103711: PPUSH
103712: LD_INT 2
103714: PPUSH
103715: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103719: LD_INT 30
103721: PPUSH
103722: LD_OWVAR 2
103726: PPUSH
103727: LD_INT 2
103729: PPUSH
103730: CALL_OW 322
// end ;
103734: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103735: LD_EXP 77
103739: PUSH
103740: LD_EXP 129
103744: AND
103745: IFFALSE 103866
103747: GO 103749
103749: DISABLE
103750: LD_INT 0
103752: PPUSH
103753: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103754: LD_ADDR_VAR 0 2
103758: PUSH
103759: LD_INT 22
103761: PUSH
103762: LD_OWVAR 2
103766: PUSH
103767: EMPTY
103768: LIST
103769: LIST
103770: PUSH
103771: LD_INT 21
103773: PUSH
103774: LD_INT 1
103776: PUSH
103777: EMPTY
103778: LIST
103779: LIST
103780: PUSH
103781: LD_INT 3
103783: PUSH
103784: LD_INT 23
103786: PUSH
103787: LD_INT 0
103789: PUSH
103790: EMPTY
103791: LIST
103792: LIST
103793: PUSH
103794: EMPTY
103795: LIST
103796: LIST
103797: PUSH
103798: EMPTY
103799: LIST
103800: LIST
103801: LIST
103802: PPUSH
103803: CALL_OW 69
103807: ST_TO_ADDR
// if not tmp then
103808: LD_VAR 0 2
103812: NOT
103813: IFFALSE 103817
// exit ;
103815: GO 103866
// for i in tmp do
103817: LD_ADDR_VAR 0 1
103821: PUSH
103822: LD_VAR 0 2
103826: PUSH
103827: FOR_IN
103828: IFFALSE 103864
// begin if Crawls ( i ) then
103830: LD_VAR 0 1
103834: PPUSH
103835: CALL_OW 318
103839: IFFALSE 103850
// ComWalk ( i ) ;
103841: LD_VAR 0 1
103845: PPUSH
103846: CALL_OW 138
// SetClass ( i , 2 ) ;
103850: LD_VAR 0 1
103854: PPUSH
103855: LD_INT 2
103857: PPUSH
103858: CALL_OW 336
// end ;
103862: GO 103827
103864: POP
103865: POP
// end ;
103866: PPOPN 2
103868: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103869: LD_EXP 77
103873: PUSH
103874: LD_EXP 130
103878: AND
103879: IFFALSE 104167
103881: GO 103883
103883: DISABLE
103884: LD_INT 0
103886: PPUSH
103887: PPUSH
103888: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103889: LD_OWVAR 2
103893: PPUSH
103894: LD_INT 9
103896: PPUSH
103897: LD_INT 1
103899: PPUSH
103900: LD_INT 1
103902: PPUSH
103903: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103907: LD_INT 9
103909: PPUSH
103910: LD_OWVAR 2
103914: PPUSH
103915: CALL_OW 343
// uc_side := 9 ;
103919: LD_ADDR_OWVAR 20
103923: PUSH
103924: LD_INT 9
103926: ST_TO_ADDR
// uc_nation := 2 ;
103927: LD_ADDR_OWVAR 21
103931: PUSH
103932: LD_INT 2
103934: ST_TO_ADDR
// hc_name := Dark Warrior ;
103935: LD_ADDR_OWVAR 26
103939: PUSH
103940: LD_STRING Dark Warrior
103942: ST_TO_ADDR
// hc_gallery :=  ;
103943: LD_ADDR_OWVAR 33
103947: PUSH
103948: LD_STRING 
103950: ST_TO_ADDR
// hc_noskilllimit := true ;
103951: LD_ADDR_OWVAR 76
103955: PUSH
103956: LD_INT 1
103958: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103959: LD_ADDR_OWVAR 31
103963: PUSH
103964: LD_INT 30
103966: PUSH
103967: LD_INT 30
103969: PUSH
103970: LD_INT 30
103972: PUSH
103973: LD_INT 30
103975: PUSH
103976: EMPTY
103977: LIST
103978: LIST
103979: LIST
103980: LIST
103981: ST_TO_ADDR
// un := CreateHuman ;
103982: LD_ADDR_VAR 0 3
103986: PUSH
103987: CALL_OW 44
103991: ST_TO_ADDR
// hc_noskilllimit := false ;
103992: LD_ADDR_OWVAR 76
103996: PUSH
103997: LD_INT 0
103999: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104000: LD_VAR 0 3
104004: PPUSH
104005: LD_INT 1
104007: PPUSH
104008: CALL_OW 51
// ToLua ( playRanger() ) ;
104012: LD_STRING playRanger()
104014: PPUSH
104015: CALL_OW 559
// p := 0 ;
104019: LD_ADDR_VAR 0 2
104023: PUSH
104024: LD_INT 0
104026: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104027: LD_INT 35
104029: PPUSH
104030: CALL_OW 67
// p := p + 1 ;
104034: LD_ADDR_VAR 0 2
104038: PUSH
104039: LD_VAR 0 2
104043: PUSH
104044: LD_INT 1
104046: PLUS
104047: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104048: LD_VAR 0 3
104052: PPUSH
104053: CALL_OW 256
104057: PUSH
104058: LD_INT 1000
104060: LESS
104061: IFFALSE 104075
// SetLives ( un , 1000 ) ;
104063: LD_VAR 0 3
104067: PPUSH
104068: LD_INT 1000
104070: PPUSH
104071: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104075: LD_VAR 0 3
104079: PPUSH
104080: LD_INT 81
104082: PUSH
104083: LD_OWVAR 2
104087: PUSH
104088: EMPTY
104089: LIST
104090: LIST
104091: PUSH
104092: LD_INT 91
104094: PUSH
104095: LD_VAR 0 3
104099: PUSH
104100: LD_INT 30
104102: PUSH
104103: EMPTY
104104: LIST
104105: LIST
104106: LIST
104107: PUSH
104108: EMPTY
104109: LIST
104110: LIST
104111: PPUSH
104112: CALL_OW 69
104116: PPUSH
104117: LD_VAR 0 3
104121: PPUSH
104122: CALL_OW 74
104126: PPUSH
104127: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104131: LD_VAR 0 2
104135: PUSH
104136: LD_INT 80
104138: GREATER
104139: PUSH
104140: LD_VAR 0 3
104144: PPUSH
104145: CALL_OW 301
104149: OR
104150: IFFALSE 104027
// if un then
104152: LD_VAR 0 3
104156: IFFALSE 104167
// RemoveUnit ( un ) ;
104158: LD_VAR 0 3
104162: PPUSH
104163: CALL_OW 64
// end ;
104167: PPOPN 3
104169: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104170: LD_EXP 131
104174: IFFALSE 104290
104176: GO 104178
104178: DISABLE
104179: LD_INT 0
104181: PPUSH
104182: PPUSH
104183: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104184: LD_ADDR_VAR 0 2
104188: PUSH
104189: LD_INT 81
104191: PUSH
104192: LD_OWVAR 2
104196: PUSH
104197: EMPTY
104198: LIST
104199: LIST
104200: PUSH
104201: LD_INT 21
104203: PUSH
104204: LD_INT 1
104206: PUSH
104207: EMPTY
104208: LIST
104209: LIST
104210: PUSH
104211: EMPTY
104212: LIST
104213: LIST
104214: PPUSH
104215: CALL_OW 69
104219: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104220: LD_STRING playComputer()
104222: PPUSH
104223: CALL_OW 559
// if not tmp then
104227: LD_VAR 0 2
104231: NOT
104232: IFFALSE 104236
// exit ;
104234: GO 104290
// for i in tmp do
104236: LD_ADDR_VAR 0 1
104240: PUSH
104241: LD_VAR 0 2
104245: PUSH
104246: FOR_IN
104247: IFFALSE 104288
// for j := 1 to 4 do
104249: LD_ADDR_VAR 0 3
104253: PUSH
104254: DOUBLE
104255: LD_INT 1
104257: DEC
104258: ST_TO_ADDR
104259: LD_INT 4
104261: PUSH
104262: FOR_TO
104263: IFFALSE 104284
// SetSkill ( i , j , 10 ) ;
104265: LD_VAR 0 1
104269: PPUSH
104270: LD_VAR 0 3
104274: PPUSH
104275: LD_INT 10
104277: PPUSH
104278: CALL_OW 237
104282: GO 104262
104284: POP
104285: POP
104286: GO 104246
104288: POP
104289: POP
// end ;
104290: PPOPN 3
104292: END
// every 0 0$1 trigger s30 do var i , tmp ;
104293: LD_EXP 132
104297: IFFALSE 104366
104299: GO 104301
104301: DISABLE
104302: LD_INT 0
104304: PPUSH
104305: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104306: LD_ADDR_VAR 0 2
104310: PUSH
104311: LD_INT 22
104313: PUSH
104314: LD_OWVAR 2
104318: PUSH
104319: EMPTY
104320: LIST
104321: LIST
104322: PPUSH
104323: CALL_OW 69
104327: ST_TO_ADDR
// if not tmp then
104328: LD_VAR 0 2
104332: NOT
104333: IFFALSE 104337
// exit ;
104335: GO 104366
// for i in tmp do
104337: LD_ADDR_VAR 0 1
104341: PUSH
104342: LD_VAR 0 2
104346: PUSH
104347: FOR_IN
104348: IFFALSE 104364
// SetLives ( i , 300 ) ;
104350: LD_VAR 0 1
104354: PPUSH
104355: LD_INT 300
104357: PPUSH
104358: CALL_OW 234
104362: GO 104347
104364: POP
104365: POP
// end ;
104366: PPOPN 2
104368: END
// every 0 0$1 trigger s60 do var i , tmp ;
104369: LD_EXP 133
104373: IFFALSE 104442
104375: GO 104377
104377: DISABLE
104378: LD_INT 0
104380: PPUSH
104381: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104382: LD_ADDR_VAR 0 2
104386: PUSH
104387: LD_INT 22
104389: PUSH
104390: LD_OWVAR 2
104394: PUSH
104395: EMPTY
104396: LIST
104397: LIST
104398: PPUSH
104399: CALL_OW 69
104403: ST_TO_ADDR
// if not tmp then
104404: LD_VAR 0 2
104408: NOT
104409: IFFALSE 104413
// exit ;
104411: GO 104442
// for i in tmp do
104413: LD_ADDR_VAR 0 1
104417: PUSH
104418: LD_VAR 0 2
104422: PUSH
104423: FOR_IN
104424: IFFALSE 104440
// SetLives ( i , 600 ) ;
104426: LD_VAR 0 1
104430: PPUSH
104431: LD_INT 600
104433: PPUSH
104434: CALL_OW 234
104438: GO 104423
104440: POP
104441: POP
// end ;
104442: PPOPN 2
104444: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104445: LD_INT 0
104447: PPUSH
// case cmd of 301 :
104448: LD_VAR 0 1
104452: PUSH
104453: LD_INT 301
104455: DOUBLE
104456: EQUAL
104457: IFTRUE 104461
104459: GO 104493
104461: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104462: LD_VAR 0 6
104466: PPUSH
104467: LD_VAR 0 7
104471: PPUSH
104472: LD_VAR 0 8
104476: PPUSH
104477: LD_VAR 0 4
104481: PPUSH
104482: LD_VAR 0 5
104486: PPUSH
104487: CALL 105694 0 5
104491: GO 104614
104493: LD_INT 302
104495: DOUBLE
104496: EQUAL
104497: IFTRUE 104501
104499: GO 104538
104501: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104502: LD_VAR 0 6
104506: PPUSH
104507: LD_VAR 0 7
104511: PPUSH
104512: LD_VAR 0 8
104516: PPUSH
104517: LD_VAR 0 9
104521: PPUSH
104522: LD_VAR 0 4
104526: PPUSH
104527: LD_VAR 0 5
104531: PPUSH
104532: CALL 105785 0 6
104536: GO 104614
104538: LD_INT 303
104540: DOUBLE
104541: EQUAL
104542: IFTRUE 104546
104544: GO 104583
104546: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104547: LD_VAR 0 6
104551: PPUSH
104552: LD_VAR 0 7
104556: PPUSH
104557: LD_VAR 0 8
104561: PPUSH
104562: LD_VAR 0 9
104566: PPUSH
104567: LD_VAR 0 4
104571: PPUSH
104572: LD_VAR 0 5
104576: PPUSH
104577: CALL 104619 0 6
104581: GO 104614
104583: LD_INT 304
104585: DOUBLE
104586: EQUAL
104587: IFTRUE 104591
104589: GO 104613
104591: POP
// hHackTeleport ( unit , x , y ) ; end ;
104592: LD_VAR 0 2
104596: PPUSH
104597: LD_VAR 0 4
104601: PPUSH
104602: LD_VAR 0 5
104606: PPUSH
104607: CALL 106378 0 3
104611: GO 104614
104613: POP
// end ;
104614: LD_VAR 0 12
104618: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104619: LD_INT 0
104621: PPUSH
104622: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104623: LD_VAR 0 1
104627: PUSH
104628: LD_INT 1
104630: LESS
104631: PUSH
104632: LD_VAR 0 1
104636: PUSH
104637: LD_INT 3
104639: GREATER
104640: OR
104641: PUSH
104642: LD_VAR 0 5
104646: PPUSH
104647: LD_VAR 0 6
104651: PPUSH
104652: CALL_OW 428
104656: OR
104657: IFFALSE 104661
// exit ;
104659: GO 105381
// uc_side := your_side ;
104661: LD_ADDR_OWVAR 20
104665: PUSH
104666: LD_OWVAR 2
104670: ST_TO_ADDR
// uc_nation := nation ;
104671: LD_ADDR_OWVAR 21
104675: PUSH
104676: LD_VAR 0 1
104680: ST_TO_ADDR
// bc_level = 1 ;
104681: LD_ADDR_OWVAR 43
104685: PUSH
104686: LD_INT 1
104688: ST_TO_ADDR
// case btype of 1 :
104689: LD_VAR 0 2
104693: PUSH
104694: LD_INT 1
104696: DOUBLE
104697: EQUAL
104698: IFTRUE 104702
104700: GO 104713
104702: POP
// bc_type := b_depot ; 2 :
104703: LD_ADDR_OWVAR 42
104707: PUSH
104708: LD_INT 0
104710: ST_TO_ADDR
104711: GO 105325
104713: LD_INT 2
104715: DOUBLE
104716: EQUAL
104717: IFTRUE 104721
104719: GO 104732
104721: POP
// bc_type := b_warehouse ; 3 :
104722: LD_ADDR_OWVAR 42
104726: PUSH
104727: LD_INT 1
104729: ST_TO_ADDR
104730: GO 105325
104732: LD_INT 3
104734: DOUBLE
104735: EQUAL
104736: IFTRUE 104740
104738: GO 104751
104740: POP
// bc_type := b_lab ; 4 .. 9 :
104741: LD_ADDR_OWVAR 42
104745: PUSH
104746: LD_INT 6
104748: ST_TO_ADDR
104749: GO 105325
104751: LD_INT 4
104753: DOUBLE
104754: GREATEREQUAL
104755: IFFALSE 104763
104757: LD_INT 9
104759: DOUBLE
104760: LESSEQUAL
104761: IFTRUE 104765
104763: GO 104817
104765: POP
// begin bc_type := b_lab_half ;
104766: LD_ADDR_OWVAR 42
104770: PUSH
104771: LD_INT 7
104773: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104774: LD_ADDR_OWVAR 44
104778: PUSH
104779: LD_INT 10
104781: PUSH
104782: LD_INT 11
104784: PUSH
104785: LD_INT 12
104787: PUSH
104788: LD_INT 15
104790: PUSH
104791: LD_INT 14
104793: PUSH
104794: LD_INT 13
104796: PUSH
104797: EMPTY
104798: LIST
104799: LIST
104800: LIST
104801: LIST
104802: LIST
104803: LIST
104804: PUSH
104805: LD_VAR 0 2
104809: PUSH
104810: LD_INT 3
104812: MINUS
104813: ARRAY
104814: ST_TO_ADDR
// end ; 10 .. 13 :
104815: GO 105325
104817: LD_INT 10
104819: DOUBLE
104820: GREATEREQUAL
104821: IFFALSE 104829
104823: LD_INT 13
104825: DOUBLE
104826: LESSEQUAL
104827: IFTRUE 104831
104829: GO 104908
104831: POP
// begin bc_type := b_lab_full ;
104832: LD_ADDR_OWVAR 42
104836: PUSH
104837: LD_INT 8
104839: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104840: LD_ADDR_OWVAR 44
104844: PUSH
104845: LD_INT 10
104847: PUSH
104848: LD_INT 12
104850: PUSH
104851: LD_INT 14
104853: PUSH
104854: LD_INT 13
104856: PUSH
104857: EMPTY
104858: LIST
104859: LIST
104860: LIST
104861: LIST
104862: PUSH
104863: LD_VAR 0 2
104867: PUSH
104868: LD_INT 9
104870: MINUS
104871: ARRAY
104872: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104873: LD_ADDR_OWVAR 45
104877: PUSH
104878: LD_INT 11
104880: PUSH
104881: LD_INT 15
104883: PUSH
104884: LD_INT 12
104886: PUSH
104887: LD_INT 15
104889: PUSH
104890: EMPTY
104891: LIST
104892: LIST
104893: LIST
104894: LIST
104895: PUSH
104896: LD_VAR 0 2
104900: PUSH
104901: LD_INT 9
104903: MINUS
104904: ARRAY
104905: ST_TO_ADDR
// end ; 14 :
104906: GO 105325
104908: LD_INT 14
104910: DOUBLE
104911: EQUAL
104912: IFTRUE 104916
104914: GO 104927
104916: POP
// bc_type := b_workshop ; 15 :
104917: LD_ADDR_OWVAR 42
104921: PUSH
104922: LD_INT 2
104924: ST_TO_ADDR
104925: GO 105325
104927: LD_INT 15
104929: DOUBLE
104930: EQUAL
104931: IFTRUE 104935
104933: GO 104946
104935: POP
// bc_type := b_factory ; 16 :
104936: LD_ADDR_OWVAR 42
104940: PUSH
104941: LD_INT 3
104943: ST_TO_ADDR
104944: GO 105325
104946: LD_INT 16
104948: DOUBLE
104949: EQUAL
104950: IFTRUE 104954
104952: GO 104965
104954: POP
// bc_type := b_ext_gun ; 17 :
104955: LD_ADDR_OWVAR 42
104959: PUSH
104960: LD_INT 17
104962: ST_TO_ADDR
104963: GO 105325
104965: LD_INT 17
104967: DOUBLE
104968: EQUAL
104969: IFTRUE 104973
104971: GO 105001
104973: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104974: LD_ADDR_OWVAR 42
104978: PUSH
104979: LD_INT 19
104981: PUSH
104982: LD_INT 23
104984: PUSH
104985: LD_INT 19
104987: PUSH
104988: EMPTY
104989: LIST
104990: LIST
104991: LIST
104992: PUSH
104993: LD_VAR 0 1
104997: ARRAY
104998: ST_TO_ADDR
104999: GO 105325
105001: LD_INT 18
105003: DOUBLE
105004: EQUAL
105005: IFTRUE 105009
105007: GO 105020
105009: POP
// bc_type := b_ext_radar ; 19 :
105010: LD_ADDR_OWVAR 42
105014: PUSH
105015: LD_INT 20
105017: ST_TO_ADDR
105018: GO 105325
105020: LD_INT 19
105022: DOUBLE
105023: EQUAL
105024: IFTRUE 105028
105026: GO 105039
105028: POP
// bc_type := b_ext_radio ; 20 :
105029: LD_ADDR_OWVAR 42
105033: PUSH
105034: LD_INT 22
105036: ST_TO_ADDR
105037: GO 105325
105039: LD_INT 20
105041: DOUBLE
105042: EQUAL
105043: IFTRUE 105047
105045: GO 105058
105047: POP
// bc_type := b_ext_siberium ; 21 :
105048: LD_ADDR_OWVAR 42
105052: PUSH
105053: LD_INT 21
105055: ST_TO_ADDR
105056: GO 105325
105058: LD_INT 21
105060: DOUBLE
105061: EQUAL
105062: IFTRUE 105066
105064: GO 105077
105066: POP
// bc_type := b_ext_computer ; 22 :
105067: LD_ADDR_OWVAR 42
105071: PUSH
105072: LD_INT 24
105074: ST_TO_ADDR
105075: GO 105325
105077: LD_INT 22
105079: DOUBLE
105080: EQUAL
105081: IFTRUE 105085
105083: GO 105096
105085: POP
// bc_type := b_ext_track ; 23 :
105086: LD_ADDR_OWVAR 42
105090: PUSH
105091: LD_INT 16
105093: ST_TO_ADDR
105094: GO 105325
105096: LD_INT 23
105098: DOUBLE
105099: EQUAL
105100: IFTRUE 105104
105102: GO 105115
105104: POP
// bc_type := b_ext_laser ; 24 :
105105: LD_ADDR_OWVAR 42
105109: PUSH
105110: LD_INT 25
105112: ST_TO_ADDR
105113: GO 105325
105115: LD_INT 24
105117: DOUBLE
105118: EQUAL
105119: IFTRUE 105123
105121: GO 105134
105123: POP
// bc_type := b_control_tower ; 25 :
105124: LD_ADDR_OWVAR 42
105128: PUSH
105129: LD_INT 36
105131: ST_TO_ADDR
105132: GO 105325
105134: LD_INT 25
105136: DOUBLE
105137: EQUAL
105138: IFTRUE 105142
105140: GO 105153
105142: POP
// bc_type := b_breastwork ; 26 :
105143: LD_ADDR_OWVAR 42
105147: PUSH
105148: LD_INT 31
105150: ST_TO_ADDR
105151: GO 105325
105153: LD_INT 26
105155: DOUBLE
105156: EQUAL
105157: IFTRUE 105161
105159: GO 105172
105161: POP
// bc_type := b_bunker ; 27 :
105162: LD_ADDR_OWVAR 42
105166: PUSH
105167: LD_INT 32
105169: ST_TO_ADDR
105170: GO 105325
105172: LD_INT 27
105174: DOUBLE
105175: EQUAL
105176: IFTRUE 105180
105178: GO 105191
105180: POP
// bc_type := b_turret ; 28 :
105181: LD_ADDR_OWVAR 42
105185: PUSH
105186: LD_INT 33
105188: ST_TO_ADDR
105189: GO 105325
105191: LD_INT 28
105193: DOUBLE
105194: EQUAL
105195: IFTRUE 105199
105197: GO 105210
105199: POP
// bc_type := b_armoury ; 29 :
105200: LD_ADDR_OWVAR 42
105204: PUSH
105205: LD_INT 4
105207: ST_TO_ADDR
105208: GO 105325
105210: LD_INT 29
105212: DOUBLE
105213: EQUAL
105214: IFTRUE 105218
105216: GO 105229
105218: POP
// bc_type := b_barracks ; 30 :
105219: LD_ADDR_OWVAR 42
105223: PUSH
105224: LD_INT 5
105226: ST_TO_ADDR
105227: GO 105325
105229: LD_INT 30
105231: DOUBLE
105232: EQUAL
105233: IFTRUE 105237
105235: GO 105248
105237: POP
// bc_type := b_solar_power ; 31 :
105238: LD_ADDR_OWVAR 42
105242: PUSH
105243: LD_INT 27
105245: ST_TO_ADDR
105246: GO 105325
105248: LD_INT 31
105250: DOUBLE
105251: EQUAL
105252: IFTRUE 105256
105254: GO 105267
105256: POP
// bc_type := b_oil_power ; 32 :
105257: LD_ADDR_OWVAR 42
105261: PUSH
105262: LD_INT 26
105264: ST_TO_ADDR
105265: GO 105325
105267: LD_INT 32
105269: DOUBLE
105270: EQUAL
105271: IFTRUE 105275
105273: GO 105286
105275: POP
// bc_type := b_siberite_power ; 33 :
105276: LD_ADDR_OWVAR 42
105280: PUSH
105281: LD_INT 28
105283: ST_TO_ADDR
105284: GO 105325
105286: LD_INT 33
105288: DOUBLE
105289: EQUAL
105290: IFTRUE 105294
105292: GO 105305
105294: POP
// bc_type := b_oil_mine ; 34 :
105295: LD_ADDR_OWVAR 42
105299: PUSH
105300: LD_INT 29
105302: ST_TO_ADDR
105303: GO 105325
105305: LD_INT 34
105307: DOUBLE
105308: EQUAL
105309: IFTRUE 105313
105311: GO 105324
105313: POP
// bc_type := b_siberite_mine ; end ;
105314: LD_ADDR_OWVAR 42
105318: PUSH
105319: LD_INT 30
105321: ST_TO_ADDR
105322: GO 105325
105324: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105325: LD_ADDR_VAR 0 8
105329: PUSH
105330: LD_VAR 0 5
105334: PPUSH
105335: LD_VAR 0 6
105339: PPUSH
105340: LD_VAR 0 3
105344: PPUSH
105345: CALL_OW 47
105349: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105350: LD_OWVAR 42
105354: PUSH
105355: LD_INT 32
105357: PUSH
105358: LD_INT 33
105360: PUSH
105361: EMPTY
105362: LIST
105363: LIST
105364: IN
105365: IFFALSE 105381
// PlaceWeaponTurret ( b , weapon ) ;
105367: LD_VAR 0 8
105371: PPUSH
105372: LD_VAR 0 4
105376: PPUSH
105377: CALL_OW 431
// end ;
105381: LD_VAR 0 7
105385: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105386: LD_INT 0
105388: PPUSH
105389: PPUSH
105390: PPUSH
105391: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105392: LD_ADDR_VAR 0 4
105396: PUSH
105397: LD_INT 22
105399: PUSH
105400: LD_OWVAR 2
105404: PUSH
105405: EMPTY
105406: LIST
105407: LIST
105408: PUSH
105409: LD_INT 2
105411: PUSH
105412: LD_INT 30
105414: PUSH
105415: LD_INT 0
105417: PUSH
105418: EMPTY
105419: LIST
105420: LIST
105421: PUSH
105422: LD_INT 30
105424: PUSH
105425: LD_INT 1
105427: PUSH
105428: EMPTY
105429: LIST
105430: LIST
105431: PUSH
105432: EMPTY
105433: LIST
105434: LIST
105435: LIST
105436: PUSH
105437: EMPTY
105438: LIST
105439: LIST
105440: PPUSH
105441: CALL_OW 69
105445: ST_TO_ADDR
// if not tmp then
105446: LD_VAR 0 4
105450: NOT
105451: IFFALSE 105455
// exit ;
105453: GO 105514
// for i in tmp do
105455: LD_ADDR_VAR 0 2
105459: PUSH
105460: LD_VAR 0 4
105464: PUSH
105465: FOR_IN
105466: IFFALSE 105512
// for j = 1 to 3 do
105468: LD_ADDR_VAR 0 3
105472: PUSH
105473: DOUBLE
105474: LD_INT 1
105476: DEC
105477: ST_TO_ADDR
105478: LD_INT 3
105480: PUSH
105481: FOR_TO
105482: IFFALSE 105508
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105484: LD_VAR 0 2
105488: PPUSH
105489: CALL_OW 274
105493: PPUSH
105494: LD_VAR 0 3
105498: PPUSH
105499: LD_INT 99999
105501: PPUSH
105502: CALL_OW 277
105506: GO 105481
105508: POP
105509: POP
105510: GO 105465
105512: POP
105513: POP
// end ;
105514: LD_VAR 0 1
105518: RET
// export function hHackSetLevel10 ; var i , j ; begin
105519: LD_INT 0
105521: PPUSH
105522: PPUSH
105523: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105524: LD_ADDR_VAR 0 2
105528: PUSH
105529: LD_INT 21
105531: PUSH
105532: LD_INT 1
105534: PUSH
105535: EMPTY
105536: LIST
105537: LIST
105538: PPUSH
105539: CALL_OW 69
105543: PUSH
105544: FOR_IN
105545: IFFALSE 105597
// if IsSelected ( i ) then
105547: LD_VAR 0 2
105551: PPUSH
105552: CALL_OW 306
105556: IFFALSE 105595
// begin for j := 1 to 4 do
105558: LD_ADDR_VAR 0 3
105562: PUSH
105563: DOUBLE
105564: LD_INT 1
105566: DEC
105567: ST_TO_ADDR
105568: LD_INT 4
105570: PUSH
105571: FOR_TO
105572: IFFALSE 105593
// SetSkill ( i , j , 10 ) ;
105574: LD_VAR 0 2
105578: PPUSH
105579: LD_VAR 0 3
105583: PPUSH
105584: LD_INT 10
105586: PPUSH
105587: CALL_OW 237
105591: GO 105571
105593: POP
105594: POP
// end ;
105595: GO 105544
105597: POP
105598: POP
// end ;
105599: LD_VAR 0 1
105603: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105604: LD_INT 0
105606: PPUSH
105607: PPUSH
105608: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105609: LD_ADDR_VAR 0 2
105613: PUSH
105614: LD_INT 22
105616: PUSH
105617: LD_OWVAR 2
105621: PUSH
105622: EMPTY
105623: LIST
105624: LIST
105625: PUSH
105626: LD_INT 21
105628: PUSH
105629: LD_INT 1
105631: PUSH
105632: EMPTY
105633: LIST
105634: LIST
105635: PUSH
105636: EMPTY
105637: LIST
105638: LIST
105639: PPUSH
105640: CALL_OW 69
105644: PUSH
105645: FOR_IN
105646: IFFALSE 105687
// begin for j := 1 to 4 do
105648: LD_ADDR_VAR 0 3
105652: PUSH
105653: DOUBLE
105654: LD_INT 1
105656: DEC
105657: ST_TO_ADDR
105658: LD_INT 4
105660: PUSH
105661: FOR_TO
105662: IFFALSE 105683
// SetSkill ( i , j , 10 ) ;
105664: LD_VAR 0 2
105668: PPUSH
105669: LD_VAR 0 3
105673: PPUSH
105674: LD_INT 10
105676: PPUSH
105677: CALL_OW 237
105681: GO 105661
105683: POP
105684: POP
// end ;
105685: GO 105645
105687: POP
105688: POP
// end ;
105689: LD_VAR 0 1
105693: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105694: LD_INT 0
105696: PPUSH
// uc_side := your_side ;
105697: LD_ADDR_OWVAR 20
105701: PUSH
105702: LD_OWVAR 2
105706: ST_TO_ADDR
// uc_nation := nation ;
105707: LD_ADDR_OWVAR 21
105711: PUSH
105712: LD_VAR 0 1
105716: ST_TO_ADDR
// InitHc ;
105717: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105721: LD_INT 0
105723: PPUSH
105724: LD_VAR 0 2
105728: PPUSH
105729: LD_VAR 0 3
105733: PPUSH
105734: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105738: LD_VAR 0 4
105742: PPUSH
105743: LD_VAR 0 5
105747: PPUSH
105748: CALL_OW 428
105752: PUSH
105753: LD_INT 0
105755: EQUAL
105756: IFFALSE 105780
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105758: CALL_OW 44
105762: PPUSH
105763: LD_VAR 0 4
105767: PPUSH
105768: LD_VAR 0 5
105772: PPUSH
105773: LD_INT 1
105775: PPUSH
105776: CALL_OW 48
// end ;
105780: LD_VAR 0 6
105784: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105785: LD_INT 0
105787: PPUSH
105788: PPUSH
// uc_side := your_side ;
105789: LD_ADDR_OWVAR 20
105793: PUSH
105794: LD_OWVAR 2
105798: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105799: LD_VAR 0 1
105803: PUSH
105804: LD_INT 1
105806: PUSH
105807: LD_INT 2
105809: PUSH
105810: LD_INT 3
105812: PUSH
105813: LD_INT 4
105815: PUSH
105816: LD_INT 5
105818: PUSH
105819: EMPTY
105820: LIST
105821: LIST
105822: LIST
105823: LIST
105824: LIST
105825: IN
105826: IFFALSE 105838
// uc_nation := nation_american else
105828: LD_ADDR_OWVAR 21
105832: PUSH
105833: LD_INT 1
105835: ST_TO_ADDR
105836: GO 105881
// if chassis in [ 11 , 12 , 13 , 14 ] then
105838: LD_VAR 0 1
105842: PUSH
105843: LD_INT 11
105845: PUSH
105846: LD_INT 12
105848: PUSH
105849: LD_INT 13
105851: PUSH
105852: LD_INT 14
105854: PUSH
105855: EMPTY
105856: LIST
105857: LIST
105858: LIST
105859: LIST
105860: IN
105861: IFFALSE 105873
// uc_nation := nation_arabian else
105863: LD_ADDR_OWVAR 21
105867: PUSH
105868: LD_INT 2
105870: ST_TO_ADDR
105871: GO 105881
// uc_nation := nation_russian ;
105873: LD_ADDR_OWVAR 21
105877: PUSH
105878: LD_INT 3
105880: ST_TO_ADDR
// vc_chassis := chassis ;
105881: LD_ADDR_OWVAR 37
105885: PUSH
105886: LD_VAR 0 1
105890: ST_TO_ADDR
// vc_engine := engine ;
105891: LD_ADDR_OWVAR 39
105895: PUSH
105896: LD_VAR 0 2
105900: ST_TO_ADDR
// vc_control := control ;
105901: LD_ADDR_OWVAR 38
105905: PUSH
105906: LD_VAR 0 3
105910: ST_TO_ADDR
// vc_weapon := weapon ;
105911: LD_ADDR_OWVAR 40
105915: PUSH
105916: LD_VAR 0 4
105920: ST_TO_ADDR
// un := CreateVehicle ;
105921: LD_ADDR_VAR 0 8
105925: PUSH
105926: CALL_OW 45
105930: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105931: LD_VAR 0 8
105935: PPUSH
105936: LD_INT 0
105938: PPUSH
105939: LD_INT 5
105941: PPUSH
105942: CALL_OW 12
105946: PPUSH
105947: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105951: LD_VAR 0 8
105955: PPUSH
105956: LD_VAR 0 5
105960: PPUSH
105961: LD_VAR 0 6
105965: PPUSH
105966: LD_INT 1
105968: PPUSH
105969: CALL_OW 48
// end ;
105973: LD_VAR 0 7
105977: RET
// export hInvincible ; every 1 do
105978: GO 105980
105980: DISABLE
// hInvincible := [ ] ;
105981: LD_ADDR_EXP 134
105985: PUSH
105986: EMPTY
105987: ST_TO_ADDR
105988: END
// every 10 do var i ;
105989: GO 105991
105991: DISABLE
105992: LD_INT 0
105994: PPUSH
// begin enable ;
105995: ENABLE
// if not hInvincible then
105996: LD_EXP 134
106000: NOT
106001: IFFALSE 106005
// exit ;
106003: GO 106049
// for i in hInvincible do
106005: LD_ADDR_VAR 0 1
106009: PUSH
106010: LD_EXP 134
106014: PUSH
106015: FOR_IN
106016: IFFALSE 106047
// if GetLives ( i ) < 1000 then
106018: LD_VAR 0 1
106022: PPUSH
106023: CALL_OW 256
106027: PUSH
106028: LD_INT 1000
106030: LESS
106031: IFFALSE 106045
// SetLives ( i , 1000 ) ;
106033: LD_VAR 0 1
106037: PPUSH
106038: LD_INT 1000
106040: PPUSH
106041: CALL_OW 234
106045: GO 106015
106047: POP
106048: POP
// end ;
106049: PPOPN 1
106051: END
// export function hHackInvincible ; var i ; begin
106052: LD_INT 0
106054: PPUSH
106055: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106056: LD_ADDR_VAR 0 2
106060: PUSH
106061: LD_INT 2
106063: PUSH
106064: LD_INT 21
106066: PUSH
106067: LD_INT 1
106069: PUSH
106070: EMPTY
106071: LIST
106072: LIST
106073: PUSH
106074: LD_INT 21
106076: PUSH
106077: LD_INT 2
106079: PUSH
106080: EMPTY
106081: LIST
106082: LIST
106083: PUSH
106084: EMPTY
106085: LIST
106086: LIST
106087: LIST
106088: PPUSH
106089: CALL_OW 69
106093: PUSH
106094: FOR_IN
106095: IFFALSE 106156
// if IsSelected ( i ) then
106097: LD_VAR 0 2
106101: PPUSH
106102: CALL_OW 306
106106: IFFALSE 106154
// begin if i in hInvincible then
106108: LD_VAR 0 2
106112: PUSH
106113: LD_EXP 134
106117: IN
106118: IFFALSE 106138
// hInvincible := hInvincible diff i else
106120: LD_ADDR_EXP 134
106124: PUSH
106125: LD_EXP 134
106129: PUSH
106130: LD_VAR 0 2
106134: DIFF
106135: ST_TO_ADDR
106136: GO 106154
// hInvincible := hInvincible union i ;
106138: LD_ADDR_EXP 134
106142: PUSH
106143: LD_EXP 134
106147: PUSH
106148: LD_VAR 0 2
106152: UNION
106153: ST_TO_ADDR
// end ;
106154: GO 106094
106156: POP
106157: POP
// end ;
106158: LD_VAR 0 1
106162: RET
// export function hHackInvisible ; var i , j ; begin
106163: LD_INT 0
106165: PPUSH
106166: PPUSH
106167: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106168: LD_ADDR_VAR 0 2
106172: PUSH
106173: LD_INT 21
106175: PUSH
106176: LD_INT 1
106178: PUSH
106179: EMPTY
106180: LIST
106181: LIST
106182: PPUSH
106183: CALL_OW 69
106187: PUSH
106188: FOR_IN
106189: IFFALSE 106213
// if IsSelected ( i ) then
106191: LD_VAR 0 2
106195: PPUSH
106196: CALL_OW 306
106200: IFFALSE 106211
// ComForceInvisible ( i ) ;
106202: LD_VAR 0 2
106206: PPUSH
106207: CALL_OW 496
106211: GO 106188
106213: POP
106214: POP
// end ;
106215: LD_VAR 0 1
106219: RET
// export function hHackChangeYourSide ; begin
106220: LD_INT 0
106222: PPUSH
// if your_side = 8 then
106223: LD_OWVAR 2
106227: PUSH
106228: LD_INT 8
106230: EQUAL
106231: IFFALSE 106243
// your_side := 0 else
106233: LD_ADDR_OWVAR 2
106237: PUSH
106238: LD_INT 0
106240: ST_TO_ADDR
106241: GO 106257
// your_side := your_side + 1 ;
106243: LD_ADDR_OWVAR 2
106247: PUSH
106248: LD_OWVAR 2
106252: PUSH
106253: LD_INT 1
106255: PLUS
106256: ST_TO_ADDR
// end ;
106257: LD_VAR 0 1
106261: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106262: LD_INT 0
106264: PPUSH
106265: PPUSH
106266: PPUSH
// for i in all_units do
106267: LD_ADDR_VAR 0 2
106271: PUSH
106272: LD_OWVAR 3
106276: PUSH
106277: FOR_IN
106278: IFFALSE 106356
// if IsSelected ( i ) then
106280: LD_VAR 0 2
106284: PPUSH
106285: CALL_OW 306
106289: IFFALSE 106354
// begin j := GetSide ( i ) ;
106291: LD_ADDR_VAR 0 3
106295: PUSH
106296: LD_VAR 0 2
106300: PPUSH
106301: CALL_OW 255
106305: ST_TO_ADDR
// if j = 8 then
106306: LD_VAR 0 3
106310: PUSH
106311: LD_INT 8
106313: EQUAL
106314: IFFALSE 106326
// j := 0 else
106316: LD_ADDR_VAR 0 3
106320: PUSH
106321: LD_INT 0
106323: ST_TO_ADDR
106324: GO 106340
// j := j + 1 ;
106326: LD_ADDR_VAR 0 3
106330: PUSH
106331: LD_VAR 0 3
106335: PUSH
106336: LD_INT 1
106338: PLUS
106339: ST_TO_ADDR
// SetSide ( i , j ) ;
106340: LD_VAR 0 2
106344: PPUSH
106345: LD_VAR 0 3
106349: PPUSH
106350: CALL_OW 235
// end ;
106354: GO 106277
106356: POP
106357: POP
// end ;
106358: LD_VAR 0 1
106362: RET
// export function hHackFog ; begin
106363: LD_INT 0
106365: PPUSH
// FogOff ( true ) ;
106366: LD_INT 1
106368: PPUSH
106369: CALL_OW 344
// end ;
106373: LD_VAR 0 1
106377: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106378: LD_INT 0
106380: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106381: LD_VAR 0 1
106385: PPUSH
106386: LD_VAR 0 2
106390: PPUSH
106391: LD_VAR 0 3
106395: PPUSH
106396: LD_INT 1
106398: PPUSH
106399: LD_INT 1
106401: PPUSH
106402: CALL_OW 483
// CenterOnXY ( x , y ) ;
106406: LD_VAR 0 2
106410: PPUSH
106411: LD_VAR 0 3
106415: PPUSH
106416: CALL_OW 84
// end ;
106420: LD_VAR 0 4
106424: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106425: LD_INT 0
106427: PPUSH
106428: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106429: LD_VAR 0 1
106433: NOT
106434: PUSH
106435: LD_VAR 0 2
106439: PPUSH
106440: LD_VAR 0 3
106444: PPUSH
106445: CALL_OW 488
106449: NOT
106450: OR
106451: PUSH
106452: LD_VAR 0 1
106456: PPUSH
106457: CALL_OW 266
106461: PUSH
106462: LD_INT 3
106464: NONEQUAL
106465: PUSH
106466: LD_VAR 0 1
106470: PPUSH
106471: CALL_OW 247
106475: PUSH
106476: LD_INT 1
106478: EQUAL
106479: NOT
106480: AND
106481: OR
106482: IFFALSE 106486
// exit ;
106484: GO 106635
// if GetType ( factory ) = unit_human then
106486: LD_VAR 0 1
106490: PPUSH
106491: CALL_OW 247
106495: PUSH
106496: LD_INT 1
106498: EQUAL
106499: IFFALSE 106516
// factory := IsInUnit ( factory ) ;
106501: LD_ADDR_VAR 0 1
106505: PUSH
106506: LD_VAR 0 1
106510: PPUSH
106511: CALL_OW 310
106515: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106516: LD_VAR 0 1
106520: PPUSH
106521: CALL_OW 266
106525: PUSH
106526: LD_INT 3
106528: NONEQUAL
106529: IFFALSE 106533
// exit ;
106531: GO 106635
// if HexInfo ( x , y ) = factory then
106533: LD_VAR 0 2
106537: PPUSH
106538: LD_VAR 0 3
106542: PPUSH
106543: CALL_OW 428
106547: PUSH
106548: LD_VAR 0 1
106552: EQUAL
106553: IFFALSE 106580
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
106555: LD_ADDR_EXP 135
106559: PUSH
106560: LD_EXP 135
106564: PPUSH
106565: LD_VAR 0 1
106569: PPUSH
106570: LD_INT 0
106572: PPUSH
106573: CALL_OW 1
106577: ST_TO_ADDR
106578: GO 106631
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
106580: LD_ADDR_EXP 135
106584: PUSH
106585: LD_EXP 135
106589: PPUSH
106590: LD_VAR 0 1
106594: PPUSH
106595: LD_VAR 0 1
106599: PPUSH
106600: CALL_OW 255
106604: PUSH
106605: LD_VAR 0 1
106609: PUSH
106610: LD_VAR 0 2
106614: PUSH
106615: LD_VAR 0 3
106619: PUSH
106620: EMPTY
106621: LIST
106622: LIST
106623: LIST
106624: LIST
106625: PPUSH
106626: CALL_OW 1
106630: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106631: CALL 106640 0 0
// end ;
106635: LD_VAR 0 4
106639: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106640: LD_INT 0
106642: PPUSH
106643: PPUSH
106644: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106645: LD_STRING resetFactoryWaypoint();
106647: PPUSH
106648: CALL_OW 559
// if factoryWaypoints then
106652: LD_EXP 135
106656: IFFALSE 106782
// begin list := PrepareArray ( factoryWaypoints ) ;
106658: LD_ADDR_VAR 0 3
106662: PUSH
106663: LD_EXP 135
106667: PPUSH
106668: CALL 60934 0 1
106672: ST_TO_ADDR
// for i := 1 to list do
106673: LD_ADDR_VAR 0 2
106677: PUSH
106678: DOUBLE
106679: LD_INT 1
106681: DEC
106682: ST_TO_ADDR
106683: LD_VAR 0 3
106687: PUSH
106688: FOR_TO
106689: IFFALSE 106780
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106691: LD_STRING setFactoryWaypointXY(
106693: PUSH
106694: LD_VAR 0 3
106698: PUSH
106699: LD_VAR 0 2
106703: ARRAY
106704: PUSH
106705: LD_INT 1
106707: ARRAY
106708: STR
106709: PUSH
106710: LD_STRING ,
106712: STR
106713: PUSH
106714: LD_VAR 0 3
106718: PUSH
106719: LD_VAR 0 2
106723: ARRAY
106724: PUSH
106725: LD_INT 2
106727: ARRAY
106728: STR
106729: PUSH
106730: LD_STRING ,
106732: STR
106733: PUSH
106734: LD_VAR 0 3
106738: PUSH
106739: LD_VAR 0 2
106743: ARRAY
106744: PUSH
106745: LD_INT 3
106747: ARRAY
106748: STR
106749: PUSH
106750: LD_STRING ,
106752: STR
106753: PUSH
106754: LD_VAR 0 3
106758: PUSH
106759: LD_VAR 0 2
106763: ARRAY
106764: PUSH
106765: LD_INT 4
106767: ARRAY
106768: STR
106769: PUSH
106770: LD_STRING )
106772: STR
106773: PPUSH
106774: CALL_OW 559
106778: GO 106688
106780: POP
106781: POP
// end ; end ;
106782: LD_VAR 0 1
106786: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106787: LD_INT 0
106789: PPUSH
// if HexInfo ( x , y ) = warehouse then
106790: LD_VAR 0 2
106794: PPUSH
106795: LD_VAR 0 3
106799: PPUSH
106800: CALL_OW 428
106804: PUSH
106805: LD_VAR 0 1
106809: EQUAL
106810: IFFALSE 106837
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106812: LD_ADDR_EXP 136
106816: PUSH
106817: LD_EXP 136
106821: PPUSH
106822: LD_VAR 0 1
106826: PPUSH
106827: LD_INT 0
106829: PPUSH
106830: CALL_OW 1
106834: ST_TO_ADDR
106835: GO 106888
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106837: LD_ADDR_EXP 136
106841: PUSH
106842: LD_EXP 136
106846: PPUSH
106847: LD_VAR 0 1
106851: PPUSH
106852: LD_VAR 0 1
106856: PPUSH
106857: CALL_OW 255
106861: PUSH
106862: LD_VAR 0 1
106866: PUSH
106867: LD_VAR 0 2
106871: PUSH
106872: LD_VAR 0 3
106876: PUSH
106877: EMPTY
106878: LIST
106879: LIST
106880: LIST
106881: LIST
106882: PPUSH
106883: CALL_OW 1
106887: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106888: CALL 106897 0 0
// end ;
106892: LD_VAR 0 4
106896: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106897: LD_INT 0
106899: PPUSH
106900: PPUSH
106901: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106902: LD_STRING resetWarehouseGatheringPoints();
106904: PPUSH
106905: CALL_OW 559
// if warehouseGatheringPoints then
106909: LD_EXP 136
106913: IFFALSE 107039
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106915: LD_ADDR_VAR 0 3
106919: PUSH
106920: LD_EXP 136
106924: PPUSH
106925: CALL 60934 0 1
106929: ST_TO_ADDR
// for i := 1 to list do
106930: LD_ADDR_VAR 0 2
106934: PUSH
106935: DOUBLE
106936: LD_INT 1
106938: DEC
106939: ST_TO_ADDR
106940: LD_VAR 0 3
106944: PUSH
106945: FOR_TO
106946: IFFALSE 107037
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106948: LD_STRING setWarehouseGatheringPointXY(
106950: PUSH
106951: LD_VAR 0 3
106955: PUSH
106956: LD_VAR 0 2
106960: ARRAY
106961: PUSH
106962: LD_INT 1
106964: ARRAY
106965: STR
106966: PUSH
106967: LD_STRING ,
106969: STR
106970: PUSH
106971: LD_VAR 0 3
106975: PUSH
106976: LD_VAR 0 2
106980: ARRAY
106981: PUSH
106982: LD_INT 2
106984: ARRAY
106985: STR
106986: PUSH
106987: LD_STRING ,
106989: STR
106990: PUSH
106991: LD_VAR 0 3
106995: PUSH
106996: LD_VAR 0 2
107000: ARRAY
107001: PUSH
107002: LD_INT 3
107004: ARRAY
107005: STR
107006: PUSH
107007: LD_STRING ,
107009: STR
107010: PUSH
107011: LD_VAR 0 3
107015: PUSH
107016: LD_VAR 0 2
107020: ARRAY
107021: PUSH
107022: LD_INT 4
107024: ARRAY
107025: STR
107026: PUSH
107027: LD_STRING )
107029: STR
107030: PPUSH
107031: CALL_OW 559
107035: GO 106945
107037: POP
107038: POP
// end ; end ;
107039: LD_VAR 0 1
107043: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107044: LD_EXP 136
107048: IFFALSE 107733
107050: GO 107052
107052: DISABLE
107053: LD_INT 0
107055: PPUSH
107056: PPUSH
107057: PPUSH
107058: PPUSH
107059: PPUSH
107060: PPUSH
107061: PPUSH
107062: PPUSH
107063: PPUSH
// begin enable ;
107064: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107065: LD_ADDR_VAR 0 3
107069: PUSH
107070: LD_EXP 136
107074: PPUSH
107075: CALL 60934 0 1
107079: ST_TO_ADDR
// if not list then
107080: LD_VAR 0 3
107084: NOT
107085: IFFALSE 107089
// exit ;
107087: GO 107733
// for i := 1 to list do
107089: LD_ADDR_VAR 0 1
107093: PUSH
107094: DOUBLE
107095: LD_INT 1
107097: DEC
107098: ST_TO_ADDR
107099: LD_VAR 0 3
107103: PUSH
107104: FOR_TO
107105: IFFALSE 107731
// begin depot := list [ i ] [ 2 ] ;
107107: LD_ADDR_VAR 0 8
107111: PUSH
107112: LD_VAR 0 3
107116: PUSH
107117: LD_VAR 0 1
107121: ARRAY
107122: PUSH
107123: LD_INT 2
107125: ARRAY
107126: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107127: LD_ADDR_VAR 0 5
107131: PUSH
107132: LD_VAR 0 3
107136: PUSH
107137: LD_VAR 0 1
107141: ARRAY
107142: PUSH
107143: LD_INT 1
107145: ARRAY
107146: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107147: LD_VAR 0 8
107151: PPUSH
107152: CALL_OW 301
107156: PUSH
107157: LD_VAR 0 5
107161: PUSH
107162: LD_VAR 0 8
107166: PPUSH
107167: CALL_OW 255
107171: NONEQUAL
107172: OR
107173: IFFALSE 107202
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107175: LD_ADDR_EXP 136
107179: PUSH
107180: LD_EXP 136
107184: PPUSH
107185: LD_VAR 0 8
107189: PPUSH
107190: LD_INT 0
107192: PPUSH
107193: CALL_OW 1
107197: ST_TO_ADDR
// exit ;
107198: POP
107199: POP
107200: GO 107733
// end ; x := list [ i ] [ 3 ] ;
107202: LD_ADDR_VAR 0 6
107206: PUSH
107207: LD_VAR 0 3
107211: PUSH
107212: LD_VAR 0 1
107216: ARRAY
107217: PUSH
107218: LD_INT 3
107220: ARRAY
107221: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107222: LD_ADDR_VAR 0 7
107226: PUSH
107227: LD_VAR 0 3
107231: PUSH
107232: LD_VAR 0 1
107236: ARRAY
107237: PUSH
107238: LD_INT 4
107240: ARRAY
107241: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107242: LD_ADDR_VAR 0 9
107246: PUSH
107247: LD_VAR 0 6
107251: PPUSH
107252: LD_VAR 0 7
107256: PPUSH
107257: LD_INT 16
107259: PPUSH
107260: CALL 59522 0 3
107264: ST_TO_ADDR
// if not cratesNearbyPoint then
107265: LD_VAR 0 9
107269: NOT
107270: IFFALSE 107276
// exit ;
107272: POP
107273: POP
107274: GO 107733
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107276: LD_ADDR_VAR 0 4
107280: PUSH
107281: LD_INT 22
107283: PUSH
107284: LD_VAR 0 5
107288: PUSH
107289: EMPTY
107290: LIST
107291: LIST
107292: PUSH
107293: LD_INT 3
107295: PUSH
107296: LD_INT 60
107298: PUSH
107299: EMPTY
107300: LIST
107301: PUSH
107302: EMPTY
107303: LIST
107304: LIST
107305: PUSH
107306: LD_INT 91
107308: PUSH
107309: LD_VAR 0 8
107313: PUSH
107314: LD_INT 6
107316: PUSH
107317: EMPTY
107318: LIST
107319: LIST
107320: LIST
107321: PUSH
107322: LD_INT 2
107324: PUSH
107325: LD_INT 25
107327: PUSH
107328: LD_INT 2
107330: PUSH
107331: EMPTY
107332: LIST
107333: LIST
107334: PUSH
107335: LD_INT 25
107337: PUSH
107338: LD_INT 16
107340: PUSH
107341: EMPTY
107342: LIST
107343: LIST
107344: PUSH
107345: EMPTY
107346: LIST
107347: LIST
107348: LIST
107349: PUSH
107350: EMPTY
107351: LIST
107352: LIST
107353: LIST
107354: LIST
107355: PPUSH
107356: CALL_OW 69
107360: PUSH
107361: LD_VAR 0 8
107365: PPUSH
107366: CALL_OW 313
107370: PPUSH
107371: LD_INT 3
107373: PUSH
107374: LD_INT 60
107376: PUSH
107377: EMPTY
107378: LIST
107379: PUSH
107380: EMPTY
107381: LIST
107382: LIST
107383: PUSH
107384: LD_INT 2
107386: PUSH
107387: LD_INT 25
107389: PUSH
107390: LD_INT 2
107392: PUSH
107393: EMPTY
107394: LIST
107395: LIST
107396: PUSH
107397: LD_INT 25
107399: PUSH
107400: LD_INT 16
107402: PUSH
107403: EMPTY
107404: LIST
107405: LIST
107406: PUSH
107407: EMPTY
107408: LIST
107409: LIST
107410: LIST
107411: PUSH
107412: EMPTY
107413: LIST
107414: LIST
107415: PPUSH
107416: CALL_OW 72
107420: UNION
107421: ST_TO_ADDR
// if tmp then
107422: LD_VAR 0 4
107426: IFFALSE 107506
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107428: LD_ADDR_VAR 0 4
107432: PUSH
107433: LD_VAR 0 4
107437: PPUSH
107438: LD_INT 3
107440: PPUSH
107441: CALL 57491 0 2
107445: ST_TO_ADDR
// for j in tmp do
107446: LD_ADDR_VAR 0 2
107450: PUSH
107451: LD_VAR 0 4
107455: PUSH
107456: FOR_IN
107457: IFFALSE 107500
// begin if IsInUnit ( j ) then
107459: LD_VAR 0 2
107463: PPUSH
107464: CALL_OW 310
107468: IFFALSE 107479
// ComExit ( j ) ;
107470: LD_VAR 0 2
107474: PPUSH
107475: CALL 57574 0 1
// AddComCollect ( j , x , y ) ;
107479: LD_VAR 0 2
107483: PPUSH
107484: LD_VAR 0 6
107488: PPUSH
107489: LD_VAR 0 7
107493: PPUSH
107494: CALL_OW 177
// end ;
107498: GO 107456
107500: POP
107501: POP
// exit ;
107502: POP
107503: POP
107504: GO 107733
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107506: LD_ADDR_VAR 0 4
107510: PUSH
107511: LD_INT 22
107513: PUSH
107514: LD_VAR 0 5
107518: PUSH
107519: EMPTY
107520: LIST
107521: LIST
107522: PUSH
107523: LD_INT 91
107525: PUSH
107526: LD_VAR 0 8
107530: PUSH
107531: LD_INT 8
107533: PUSH
107534: EMPTY
107535: LIST
107536: LIST
107537: LIST
107538: PUSH
107539: LD_INT 2
107541: PUSH
107542: LD_INT 34
107544: PUSH
107545: LD_INT 12
107547: PUSH
107548: EMPTY
107549: LIST
107550: LIST
107551: PUSH
107552: LD_INT 34
107554: PUSH
107555: LD_INT 51
107557: PUSH
107558: EMPTY
107559: LIST
107560: LIST
107561: PUSH
107562: LD_INT 34
107564: PUSH
107565: LD_INT 32
107567: PUSH
107568: EMPTY
107569: LIST
107570: LIST
107571: PUSH
107572: LD_INT 34
107574: PUSH
107575: LD_INT 89
107577: PUSH
107578: EMPTY
107579: LIST
107580: LIST
107581: PUSH
107582: EMPTY
107583: LIST
107584: LIST
107585: LIST
107586: LIST
107587: LIST
107588: PUSH
107589: EMPTY
107590: LIST
107591: LIST
107592: LIST
107593: PPUSH
107594: CALL_OW 69
107598: ST_TO_ADDR
// if tmp then
107599: LD_VAR 0 4
107603: IFFALSE 107729
// begin for j in tmp do
107605: LD_ADDR_VAR 0 2
107609: PUSH
107610: LD_VAR 0 4
107614: PUSH
107615: FOR_IN
107616: IFFALSE 107727
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107618: LD_VAR 0 2
107622: PPUSH
107623: CALL_OW 262
107627: PUSH
107628: LD_INT 3
107630: EQUAL
107631: PUSH
107632: LD_VAR 0 2
107636: PPUSH
107637: CALL_OW 261
107641: PUSH
107642: LD_INT 20
107644: GREATER
107645: OR
107646: PUSH
107647: LD_VAR 0 2
107651: PPUSH
107652: CALL_OW 314
107656: NOT
107657: AND
107658: PUSH
107659: LD_VAR 0 2
107663: PPUSH
107664: CALL_OW 263
107668: PUSH
107669: LD_INT 1
107671: NONEQUAL
107672: PUSH
107673: LD_VAR 0 2
107677: PPUSH
107678: CALL_OW 311
107682: OR
107683: AND
107684: IFFALSE 107725
// begin ComCollect ( j , x , y ) ;
107686: LD_VAR 0 2
107690: PPUSH
107691: LD_VAR 0 6
107695: PPUSH
107696: LD_VAR 0 7
107700: PPUSH
107701: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107705: LD_VAR 0 2
107709: PPUSH
107710: LD_VAR 0 8
107714: PPUSH
107715: CALL_OW 172
// exit ;
107719: POP
107720: POP
107721: POP
107722: POP
107723: GO 107733
// end ;
107725: GO 107615
107727: POP
107728: POP
// end ; end ;
107729: GO 107104
107731: POP
107732: POP
// end ; end_of_file
107733: PPOPN 9
107735: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107736: LD_INT 0
107738: PPUSH
107739: PPUSH
107740: PPUSH
107741: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107742: LD_VAR 0 1
107746: PPUSH
107747: CALL_OW 264
107751: PUSH
107752: LD_INT 91
107754: EQUAL
107755: IFFALSE 107827
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107757: LD_INT 68
107759: PPUSH
107760: LD_VAR 0 1
107764: PPUSH
107765: CALL_OW 255
107769: PPUSH
107770: CALL_OW 321
107774: PUSH
107775: LD_INT 2
107777: EQUAL
107778: IFFALSE 107790
// eff := 70 else
107780: LD_ADDR_VAR 0 4
107784: PUSH
107785: LD_INT 70
107787: ST_TO_ADDR
107788: GO 107798
// eff := 30 ;
107790: LD_ADDR_VAR 0 4
107794: PUSH
107795: LD_INT 30
107797: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107798: LD_VAR 0 1
107802: PPUSH
107803: CALL_OW 250
107807: PPUSH
107808: LD_VAR 0 1
107812: PPUSH
107813: CALL_OW 251
107817: PPUSH
107818: LD_VAR 0 4
107822: PPUSH
107823: CALL_OW 495
// end ; end ;
107827: LD_VAR 0 2
107831: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107832: LD_INT 0
107834: PPUSH
// end ;
107835: LD_VAR 0 4
107839: RET
// export function SOS_Command ( cmd ) ; begin
107840: LD_INT 0
107842: PPUSH
// end ;
107843: LD_VAR 0 2
107847: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107848: LD_INT 0
107850: PPUSH
// end ;
107851: LD_VAR 0 6
107855: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107856: LD_INT 0
107858: PPUSH
107859: PPUSH
// if not vehicle or not factory then
107860: LD_VAR 0 1
107864: NOT
107865: PUSH
107866: LD_VAR 0 2
107870: NOT
107871: OR
107872: IFFALSE 107876
// exit ;
107874: GO 108107
// if factoryWaypoints >= factory then
107876: LD_EXP 135
107880: PUSH
107881: LD_VAR 0 2
107885: GREATEREQUAL
107886: IFFALSE 108107
// if factoryWaypoints [ factory ] then
107888: LD_EXP 135
107892: PUSH
107893: LD_VAR 0 2
107897: ARRAY
107898: IFFALSE 108107
// begin if GetControl ( vehicle ) = control_manual then
107900: LD_VAR 0 1
107904: PPUSH
107905: CALL_OW 263
107909: PUSH
107910: LD_INT 1
107912: EQUAL
107913: IFFALSE 107994
// begin driver := IsDrivenBy ( vehicle ) ;
107915: LD_ADDR_VAR 0 4
107919: PUSH
107920: LD_VAR 0 1
107924: PPUSH
107925: CALL_OW 311
107929: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107930: LD_VAR 0 4
107934: PPUSH
107935: LD_EXP 135
107939: PUSH
107940: LD_VAR 0 2
107944: ARRAY
107945: PUSH
107946: LD_INT 3
107948: ARRAY
107949: PPUSH
107950: LD_EXP 135
107954: PUSH
107955: LD_VAR 0 2
107959: ARRAY
107960: PUSH
107961: LD_INT 4
107963: ARRAY
107964: PPUSH
107965: CALL_OW 171
// AddComExitVehicle ( driver ) ;
107969: LD_VAR 0 4
107973: PPUSH
107974: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
107978: LD_VAR 0 4
107982: PPUSH
107983: LD_VAR 0 2
107987: PPUSH
107988: CALL_OW 180
// end else
107992: GO 108107
// if GetControl ( vehicle ) = control_remote then
107994: LD_VAR 0 1
107998: PPUSH
107999: CALL_OW 263
108003: PUSH
108004: LD_INT 2
108006: EQUAL
108007: IFFALSE 108068
// begin wait ( 0 0$2 ) ;
108009: LD_INT 70
108011: PPUSH
108012: CALL_OW 67
// if Connect ( vehicle ) then
108016: LD_VAR 0 1
108020: PPUSH
108021: CALL 27815 0 1
108025: IFFALSE 108066
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108027: LD_VAR 0 1
108031: PPUSH
108032: LD_EXP 135
108036: PUSH
108037: LD_VAR 0 2
108041: ARRAY
108042: PUSH
108043: LD_INT 3
108045: ARRAY
108046: PPUSH
108047: LD_EXP 135
108051: PUSH
108052: LD_VAR 0 2
108056: ARRAY
108057: PUSH
108058: LD_INT 4
108060: ARRAY
108061: PPUSH
108062: CALL_OW 171
// end else
108066: GO 108107
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108068: LD_VAR 0 1
108072: PPUSH
108073: LD_EXP 135
108077: PUSH
108078: LD_VAR 0 2
108082: ARRAY
108083: PUSH
108084: LD_INT 3
108086: ARRAY
108087: PPUSH
108088: LD_EXP 135
108092: PUSH
108093: LD_VAR 0 2
108097: ARRAY
108098: PUSH
108099: LD_INT 4
108101: ARRAY
108102: PPUSH
108103: CALL_OW 171
// end ; end ;
108107: LD_VAR 0 3
108111: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108112: LD_INT 0
108114: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108115: LD_VAR 0 1
108119: PUSH
108120: LD_INT 250
108122: EQUAL
108123: PUSH
108124: LD_VAR 0 2
108128: PPUSH
108129: CALL_OW 264
108133: PUSH
108134: LD_INT 81
108136: EQUAL
108137: AND
108138: IFFALSE 108159
// MinerPlaceMine ( unit , x , y ) ;
108140: LD_VAR 0 2
108144: PPUSH
108145: LD_VAR 0 4
108149: PPUSH
108150: LD_VAR 0 5
108154: PPUSH
108155: CALL 110544 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108159: LD_VAR 0 1
108163: PUSH
108164: LD_INT 251
108166: EQUAL
108167: PUSH
108168: LD_VAR 0 2
108172: PPUSH
108173: CALL_OW 264
108177: PUSH
108178: LD_INT 81
108180: EQUAL
108181: AND
108182: IFFALSE 108203
// MinerDetonateMine ( unit , x , y ) ;
108184: LD_VAR 0 2
108188: PPUSH
108189: LD_VAR 0 4
108193: PPUSH
108194: LD_VAR 0 5
108198: PPUSH
108199: CALL 110819 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108203: LD_VAR 0 1
108207: PUSH
108208: LD_INT 252
108210: EQUAL
108211: PUSH
108212: LD_VAR 0 2
108216: PPUSH
108217: CALL_OW 264
108221: PUSH
108222: LD_INT 81
108224: EQUAL
108225: AND
108226: IFFALSE 108247
// MinerCreateMinefield ( unit , x , y ) ;
108228: LD_VAR 0 2
108232: PPUSH
108233: LD_VAR 0 4
108237: PPUSH
108238: LD_VAR 0 5
108242: PPUSH
108243: CALL 111236 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108247: LD_VAR 0 1
108251: PUSH
108252: LD_INT 253
108254: EQUAL
108255: PUSH
108256: LD_VAR 0 2
108260: PPUSH
108261: CALL_OW 257
108265: PUSH
108266: LD_INT 5
108268: EQUAL
108269: AND
108270: IFFALSE 108291
// ComBinocular ( unit , x , y ) ;
108272: LD_VAR 0 2
108276: PPUSH
108277: LD_VAR 0 4
108281: PPUSH
108282: LD_VAR 0 5
108286: PPUSH
108287: CALL 111605 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108291: LD_VAR 0 1
108295: PUSH
108296: LD_INT 254
108298: EQUAL
108299: PUSH
108300: LD_VAR 0 2
108304: PPUSH
108305: CALL_OW 264
108309: PUSH
108310: LD_INT 99
108312: EQUAL
108313: AND
108314: PUSH
108315: LD_VAR 0 3
108319: PPUSH
108320: CALL_OW 263
108324: PUSH
108325: LD_INT 3
108327: EQUAL
108328: AND
108329: IFFALSE 108345
// HackDestroyVehicle ( unit , selectedUnit ) ;
108331: LD_VAR 0 2
108335: PPUSH
108336: LD_VAR 0 3
108340: PPUSH
108341: CALL 109908 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108345: LD_VAR 0 1
108349: PUSH
108350: LD_INT 255
108352: EQUAL
108353: PUSH
108354: LD_VAR 0 2
108358: PPUSH
108359: CALL_OW 264
108363: PUSH
108364: LD_INT 14
108366: PUSH
108367: LD_INT 53
108369: PUSH
108370: EMPTY
108371: LIST
108372: LIST
108373: IN
108374: AND
108375: PUSH
108376: LD_VAR 0 4
108380: PPUSH
108381: LD_VAR 0 5
108385: PPUSH
108386: CALL_OW 488
108390: AND
108391: IFFALSE 108415
// CutTreeXYR ( unit , x , y , 12 ) ;
108393: LD_VAR 0 2
108397: PPUSH
108398: LD_VAR 0 4
108402: PPUSH
108403: LD_VAR 0 5
108407: PPUSH
108408: LD_INT 12
108410: PPUSH
108411: CALL 108478 0 4
// if cmd = 256 then
108415: LD_VAR 0 1
108419: PUSH
108420: LD_INT 256
108422: EQUAL
108423: IFFALSE 108444
// SetFactoryWaypoint ( unit , x , y ) ;
108425: LD_VAR 0 2
108429: PPUSH
108430: LD_VAR 0 4
108434: PPUSH
108435: LD_VAR 0 5
108439: PPUSH
108440: CALL 106425 0 3
// if cmd = 257 then
108444: LD_VAR 0 1
108448: PUSH
108449: LD_INT 257
108451: EQUAL
108452: IFFALSE 108473
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108454: LD_VAR 0 2
108458: PPUSH
108459: LD_VAR 0 4
108463: PPUSH
108464: LD_VAR 0 5
108468: PPUSH
108469: CALL 106787 0 3
// end ;
108473: LD_VAR 0 6
108477: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108478: LD_INT 0
108480: PPUSH
108481: PPUSH
108482: PPUSH
108483: PPUSH
108484: PPUSH
108485: PPUSH
108486: PPUSH
108487: PPUSH
108488: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108489: LD_VAR 0 1
108493: NOT
108494: PUSH
108495: LD_VAR 0 2
108499: PPUSH
108500: LD_VAR 0 3
108504: PPUSH
108505: CALL_OW 488
108509: NOT
108510: OR
108511: PUSH
108512: LD_VAR 0 4
108516: NOT
108517: OR
108518: IFFALSE 108522
// exit ;
108520: GO 108862
// list := [ ] ;
108522: LD_ADDR_VAR 0 13
108526: PUSH
108527: EMPTY
108528: ST_TO_ADDR
// if x - r < 0 then
108529: LD_VAR 0 2
108533: PUSH
108534: LD_VAR 0 4
108538: MINUS
108539: PUSH
108540: LD_INT 0
108542: LESS
108543: IFFALSE 108555
// min_x := 0 else
108545: LD_ADDR_VAR 0 7
108549: PUSH
108550: LD_INT 0
108552: ST_TO_ADDR
108553: GO 108571
// min_x := x - r ;
108555: LD_ADDR_VAR 0 7
108559: PUSH
108560: LD_VAR 0 2
108564: PUSH
108565: LD_VAR 0 4
108569: MINUS
108570: ST_TO_ADDR
// if y - r < 0 then
108571: LD_VAR 0 3
108575: PUSH
108576: LD_VAR 0 4
108580: MINUS
108581: PUSH
108582: LD_INT 0
108584: LESS
108585: IFFALSE 108597
// min_y := 0 else
108587: LD_ADDR_VAR 0 8
108591: PUSH
108592: LD_INT 0
108594: ST_TO_ADDR
108595: GO 108613
// min_y := y - r ;
108597: LD_ADDR_VAR 0 8
108601: PUSH
108602: LD_VAR 0 3
108606: PUSH
108607: LD_VAR 0 4
108611: MINUS
108612: ST_TO_ADDR
// max_x := x + r ;
108613: LD_ADDR_VAR 0 9
108617: PUSH
108618: LD_VAR 0 2
108622: PUSH
108623: LD_VAR 0 4
108627: PLUS
108628: ST_TO_ADDR
// max_y := y + r ;
108629: LD_ADDR_VAR 0 10
108633: PUSH
108634: LD_VAR 0 3
108638: PUSH
108639: LD_VAR 0 4
108643: PLUS
108644: ST_TO_ADDR
// for _x = min_x to max_x do
108645: LD_ADDR_VAR 0 11
108649: PUSH
108650: DOUBLE
108651: LD_VAR 0 7
108655: DEC
108656: ST_TO_ADDR
108657: LD_VAR 0 9
108661: PUSH
108662: FOR_TO
108663: IFFALSE 108780
// for _y = min_y to max_y do
108665: LD_ADDR_VAR 0 12
108669: PUSH
108670: DOUBLE
108671: LD_VAR 0 8
108675: DEC
108676: ST_TO_ADDR
108677: LD_VAR 0 10
108681: PUSH
108682: FOR_TO
108683: IFFALSE 108776
// begin if not ValidHex ( _x , _y ) then
108685: LD_VAR 0 11
108689: PPUSH
108690: LD_VAR 0 12
108694: PPUSH
108695: CALL_OW 488
108699: NOT
108700: IFFALSE 108704
// continue ;
108702: GO 108682
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108704: LD_VAR 0 11
108708: PPUSH
108709: LD_VAR 0 12
108713: PPUSH
108714: CALL_OW 351
108718: PUSH
108719: LD_VAR 0 11
108723: PPUSH
108724: LD_VAR 0 12
108728: PPUSH
108729: CALL_OW 554
108733: AND
108734: IFFALSE 108774
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108736: LD_ADDR_VAR 0 13
108740: PUSH
108741: LD_VAR 0 13
108745: PPUSH
108746: LD_VAR 0 13
108750: PUSH
108751: LD_INT 1
108753: PLUS
108754: PPUSH
108755: LD_VAR 0 11
108759: PUSH
108760: LD_VAR 0 12
108764: PUSH
108765: EMPTY
108766: LIST
108767: LIST
108768: PPUSH
108769: CALL_OW 2
108773: ST_TO_ADDR
// end ;
108774: GO 108682
108776: POP
108777: POP
108778: GO 108662
108780: POP
108781: POP
// if not list then
108782: LD_VAR 0 13
108786: NOT
108787: IFFALSE 108791
// exit ;
108789: GO 108862
// for i in list do
108791: LD_ADDR_VAR 0 6
108795: PUSH
108796: LD_VAR 0 13
108800: PUSH
108801: FOR_IN
108802: IFFALSE 108860
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108804: LD_VAR 0 1
108808: PPUSH
108809: LD_STRING M
108811: PUSH
108812: LD_VAR 0 6
108816: PUSH
108817: LD_INT 1
108819: ARRAY
108820: PUSH
108821: LD_VAR 0 6
108825: PUSH
108826: LD_INT 2
108828: ARRAY
108829: PUSH
108830: LD_INT 0
108832: PUSH
108833: LD_INT 0
108835: PUSH
108836: LD_INT 0
108838: PUSH
108839: LD_INT 0
108841: PUSH
108842: EMPTY
108843: LIST
108844: LIST
108845: LIST
108846: LIST
108847: LIST
108848: LIST
108849: LIST
108850: PUSH
108851: EMPTY
108852: LIST
108853: PPUSH
108854: CALL_OW 447
108858: GO 108801
108860: POP
108861: POP
// end ;
108862: LD_VAR 0 5
108866: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108867: LD_EXP 138
108871: NOT
108872: IFFALSE 108922
108874: GO 108876
108876: DISABLE
// begin initHack := true ;
108877: LD_ADDR_EXP 138
108881: PUSH
108882: LD_INT 1
108884: ST_TO_ADDR
// hackTanks := [ ] ;
108885: LD_ADDR_EXP 139
108889: PUSH
108890: EMPTY
108891: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108892: LD_ADDR_EXP 140
108896: PUSH
108897: EMPTY
108898: ST_TO_ADDR
// hackLimit := 3 ;
108899: LD_ADDR_EXP 141
108903: PUSH
108904: LD_INT 3
108906: ST_TO_ADDR
// hackDist := 12 ;
108907: LD_ADDR_EXP 142
108911: PUSH
108912: LD_INT 12
108914: ST_TO_ADDR
// hackCounter := [ ] ;
108915: LD_ADDR_EXP 143
108919: PUSH
108920: EMPTY
108921: ST_TO_ADDR
// end ;
108922: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108923: LD_EXP 138
108927: PUSH
108928: LD_INT 34
108930: PUSH
108931: LD_INT 99
108933: PUSH
108934: EMPTY
108935: LIST
108936: LIST
108937: PPUSH
108938: CALL_OW 69
108942: AND
108943: IFFALSE 109196
108945: GO 108947
108947: DISABLE
108948: LD_INT 0
108950: PPUSH
108951: PPUSH
// begin enable ;
108952: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108953: LD_ADDR_VAR 0 1
108957: PUSH
108958: LD_INT 34
108960: PUSH
108961: LD_INT 99
108963: PUSH
108964: EMPTY
108965: LIST
108966: LIST
108967: PPUSH
108968: CALL_OW 69
108972: PUSH
108973: FOR_IN
108974: IFFALSE 109194
// begin if not i in hackTanks then
108976: LD_VAR 0 1
108980: PUSH
108981: LD_EXP 139
108985: IN
108986: NOT
108987: IFFALSE 109070
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108989: LD_ADDR_EXP 139
108993: PUSH
108994: LD_EXP 139
108998: PPUSH
108999: LD_EXP 139
109003: PUSH
109004: LD_INT 1
109006: PLUS
109007: PPUSH
109008: LD_VAR 0 1
109012: PPUSH
109013: CALL_OW 1
109017: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109018: LD_ADDR_EXP 140
109022: PUSH
109023: LD_EXP 140
109027: PPUSH
109028: LD_EXP 140
109032: PUSH
109033: LD_INT 1
109035: PLUS
109036: PPUSH
109037: EMPTY
109038: PPUSH
109039: CALL_OW 1
109043: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
109044: LD_ADDR_EXP 143
109048: PUSH
109049: LD_EXP 143
109053: PPUSH
109054: LD_EXP 143
109058: PUSH
109059: LD_INT 1
109061: PLUS
109062: PPUSH
109063: EMPTY
109064: PPUSH
109065: CALL_OW 1
109069: ST_TO_ADDR
// end ; if not IsOk ( i ) then
109070: LD_VAR 0 1
109074: PPUSH
109075: CALL_OW 302
109079: NOT
109080: IFFALSE 109093
// begin HackUnlinkAll ( i ) ;
109082: LD_VAR 0 1
109086: PPUSH
109087: CALL 109199 0 1
// continue ;
109091: GO 108973
// end ; HackCheckCapturedStatus ( i ) ;
109093: LD_VAR 0 1
109097: PPUSH
109098: CALL 109642 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
109102: LD_ADDR_VAR 0 2
109106: PUSH
109107: LD_INT 81
109109: PUSH
109110: LD_VAR 0 1
109114: PPUSH
109115: CALL_OW 255
109119: PUSH
109120: EMPTY
109121: LIST
109122: LIST
109123: PUSH
109124: LD_INT 33
109126: PUSH
109127: LD_INT 3
109129: PUSH
109130: EMPTY
109131: LIST
109132: LIST
109133: PUSH
109134: LD_INT 91
109136: PUSH
109137: LD_VAR 0 1
109141: PUSH
109142: LD_EXP 142
109146: PUSH
109147: EMPTY
109148: LIST
109149: LIST
109150: LIST
109151: PUSH
109152: LD_INT 50
109154: PUSH
109155: EMPTY
109156: LIST
109157: PUSH
109158: EMPTY
109159: LIST
109160: LIST
109161: LIST
109162: LIST
109163: PPUSH
109164: CALL_OW 69
109168: ST_TO_ADDR
// if not tmp then
109169: LD_VAR 0 2
109173: NOT
109174: IFFALSE 109178
// continue ;
109176: GO 108973
// HackLink ( i , tmp ) ;
109178: LD_VAR 0 1
109182: PPUSH
109183: LD_VAR 0 2
109187: PPUSH
109188: CALL 109335 0 2
// end ;
109192: GO 108973
109194: POP
109195: POP
// end ;
109196: PPOPN 2
109198: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109199: LD_INT 0
109201: PPUSH
109202: PPUSH
109203: PPUSH
// if not hack in hackTanks then
109204: LD_VAR 0 1
109208: PUSH
109209: LD_EXP 139
109213: IN
109214: NOT
109215: IFFALSE 109219
// exit ;
109217: GO 109330
// index := GetElementIndex ( hackTanks , hack ) ;
109219: LD_ADDR_VAR 0 4
109223: PUSH
109224: LD_EXP 139
109228: PPUSH
109229: LD_VAR 0 1
109233: PPUSH
109234: CALL 24631 0 2
109238: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109239: LD_EXP 140
109243: PUSH
109244: LD_VAR 0 4
109248: ARRAY
109249: IFFALSE 109330
// begin for i in hackTanksCaptured [ index ] do
109251: LD_ADDR_VAR 0 3
109255: PUSH
109256: LD_EXP 140
109260: PUSH
109261: LD_VAR 0 4
109265: ARRAY
109266: PUSH
109267: FOR_IN
109268: IFFALSE 109294
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109270: LD_VAR 0 3
109274: PUSH
109275: LD_INT 1
109277: ARRAY
109278: PPUSH
109279: LD_VAR 0 3
109283: PUSH
109284: LD_INT 2
109286: ARRAY
109287: PPUSH
109288: CALL_OW 235
109292: GO 109267
109294: POP
109295: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109296: LD_ADDR_EXP 140
109300: PUSH
109301: LD_EXP 140
109305: PPUSH
109306: LD_VAR 0 4
109310: PPUSH
109311: EMPTY
109312: PPUSH
109313: CALL_OW 1
109317: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109318: LD_VAR 0 1
109322: PPUSH
109323: LD_INT 0
109325: PPUSH
109326: CALL_OW 505
// end ; end ;
109330: LD_VAR 0 2
109334: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109335: LD_INT 0
109337: PPUSH
109338: PPUSH
109339: PPUSH
// if not hack in hackTanks or not vehicles then
109340: LD_VAR 0 1
109344: PUSH
109345: LD_EXP 139
109349: IN
109350: NOT
109351: PUSH
109352: LD_VAR 0 2
109356: NOT
109357: OR
109358: IFFALSE 109362
// exit ;
109360: GO 109637
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109362: LD_ADDR_VAR 0 2
109366: PUSH
109367: LD_VAR 0 1
109371: PPUSH
109372: LD_VAR 0 2
109376: PPUSH
109377: LD_INT 1
109379: PPUSH
109380: LD_INT 1
109382: PPUSH
109383: CALL 25281 0 4
109387: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109388: LD_ADDR_VAR 0 5
109392: PUSH
109393: LD_EXP 139
109397: PPUSH
109398: LD_VAR 0 1
109402: PPUSH
109403: CALL 24631 0 2
109407: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109408: LD_EXP 140
109412: PUSH
109413: LD_VAR 0 5
109417: ARRAY
109418: PUSH
109419: LD_EXP 141
109423: LESS
109424: IFFALSE 109613
// begin for i := 1 to vehicles do
109426: LD_ADDR_VAR 0 4
109430: PUSH
109431: DOUBLE
109432: LD_INT 1
109434: DEC
109435: ST_TO_ADDR
109436: LD_VAR 0 2
109440: PUSH
109441: FOR_TO
109442: IFFALSE 109611
// begin if hackTanksCaptured [ index ] = hackLimit then
109444: LD_EXP 140
109448: PUSH
109449: LD_VAR 0 5
109453: ARRAY
109454: PUSH
109455: LD_EXP 141
109459: EQUAL
109460: IFFALSE 109464
// break ;
109462: GO 109611
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109464: LD_ADDR_EXP 143
109468: PUSH
109469: LD_EXP 143
109473: PPUSH
109474: LD_VAR 0 5
109478: PPUSH
109479: LD_EXP 143
109483: PUSH
109484: LD_VAR 0 5
109488: ARRAY
109489: PUSH
109490: LD_INT 1
109492: PLUS
109493: PPUSH
109494: CALL_OW 1
109498: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109499: LD_ADDR_EXP 140
109503: PUSH
109504: LD_EXP 140
109508: PPUSH
109509: LD_VAR 0 5
109513: PUSH
109514: LD_EXP 140
109518: PUSH
109519: LD_VAR 0 5
109523: ARRAY
109524: PUSH
109525: LD_INT 1
109527: PLUS
109528: PUSH
109529: EMPTY
109530: LIST
109531: LIST
109532: PPUSH
109533: LD_VAR 0 2
109537: PUSH
109538: LD_VAR 0 4
109542: ARRAY
109543: PUSH
109544: LD_VAR 0 2
109548: PUSH
109549: LD_VAR 0 4
109553: ARRAY
109554: PPUSH
109555: CALL_OW 255
109559: PUSH
109560: EMPTY
109561: LIST
109562: LIST
109563: PPUSH
109564: CALL 24846 0 3
109568: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109569: LD_VAR 0 2
109573: PUSH
109574: LD_VAR 0 4
109578: ARRAY
109579: PPUSH
109580: LD_VAR 0 1
109584: PPUSH
109585: CALL_OW 255
109589: PPUSH
109590: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109594: LD_VAR 0 2
109598: PUSH
109599: LD_VAR 0 4
109603: ARRAY
109604: PPUSH
109605: CALL_OW 141
// end ;
109609: GO 109441
109611: POP
109612: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109613: LD_VAR 0 1
109617: PPUSH
109618: LD_EXP 140
109622: PUSH
109623: LD_VAR 0 5
109627: ARRAY
109628: PUSH
109629: LD_INT 0
109631: PLUS
109632: PPUSH
109633: CALL_OW 505
// end ;
109637: LD_VAR 0 3
109641: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109642: LD_INT 0
109644: PPUSH
109645: PPUSH
109646: PPUSH
109647: PPUSH
// if not hack in hackTanks then
109648: LD_VAR 0 1
109652: PUSH
109653: LD_EXP 139
109657: IN
109658: NOT
109659: IFFALSE 109663
// exit ;
109661: GO 109903
// index := GetElementIndex ( hackTanks , hack ) ;
109663: LD_ADDR_VAR 0 4
109667: PUSH
109668: LD_EXP 139
109672: PPUSH
109673: LD_VAR 0 1
109677: PPUSH
109678: CALL 24631 0 2
109682: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109683: LD_ADDR_VAR 0 3
109687: PUSH
109688: DOUBLE
109689: LD_EXP 140
109693: PUSH
109694: LD_VAR 0 4
109698: ARRAY
109699: INC
109700: ST_TO_ADDR
109701: LD_INT 1
109703: PUSH
109704: FOR_DOWNTO
109705: IFFALSE 109877
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109707: LD_ADDR_VAR 0 5
109711: PUSH
109712: LD_EXP 140
109716: PUSH
109717: LD_VAR 0 4
109721: ARRAY
109722: PUSH
109723: LD_VAR 0 3
109727: ARRAY
109728: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109729: LD_VAR 0 5
109733: PUSH
109734: LD_INT 1
109736: ARRAY
109737: PPUSH
109738: CALL_OW 302
109742: NOT
109743: PUSH
109744: LD_VAR 0 5
109748: PUSH
109749: LD_INT 1
109751: ARRAY
109752: PPUSH
109753: CALL_OW 255
109757: PUSH
109758: LD_VAR 0 1
109762: PPUSH
109763: CALL_OW 255
109767: NONEQUAL
109768: OR
109769: IFFALSE 109875
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109771: LD_VAR 0 5
109775: PUSH
109776: LD_INT 1
109778: ARRAY
109779: PPUSH
109780: CALL_OW 305
109784: PUSH
109785: LD_VAR 0 5
109789: PUSH
109790: LD_INT 1
109792: ARRAY
109793: PPUSH
109794: CALL_OW 255
109798: PUSH
109799: LD_VAR 0 1
109803: PPUSH
109804: CALL_OW 255
109808: EQUAL
109809: AND
109810: IFFALSE 109834
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109812: LD_VAR 0 5
109816: PUSH
109817: LD_INT 1
109819: ARRAY
109820: PPUSH
109821: LD_VAR 0 5
109825: PUSH
109826: LD_INT 2
109828: ARRAY
109829: PPUSH
109830: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109834: LD_ADDR_EXP 140
109838: PUSH
109839: LD_EXP 140
109843: PPUSH
109844: LD_VAR 0 4
109848: PPUSH
109849: LD_EXP 140
109853: PUSH
109854: LD_VAR 0 4
109858: ARRAY
109859: PPUSH
109860: LD_VAR 0 3
109864: PPUSH
109865: CALL_OW 3
109869: PPUSH
109870: CALL_OW 1
109874: ST_TO_ADDR
// end ; end ;
109875: GO 109704
109877: POP
109878: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109879: LD_VAR 0 1
109883: PPUSH
109884: LD_EXP 140
109888: PUSH
109889: LD_VAR 0 4
109893: ARRAY
109894: PUSH
109895: LD_INT 0
109897: PLUS
109898: PPUSH
109899: CALL_OW 505
// end ;
109903: LD_VAR 0 2
109907: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109908: LD_INT 0
109910: PPUSH
109911: PPUSH
109912: PPUSH
109913: PPUSH
// if not hack in hackTanks then
109914: LD_VAR 0 1
109918: PUSH
109919: LD_EXP 139
109923: IN
109924: NOT
109925: IFFALSE 109929
// exit ;
109927: GO 110014
// index := GetElementIndex ( hackTanks , hack ) ;
109929: LD_ADDR_VAR 0 5
109933: PUSH
109934: LD_EXP 139
109938: PPUSH
109939: LD_VAR 0 1
109943: PPUSH
109944: CALL 24631 0 2
109948: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109949: LD_ADDR_VAR 0 4
109953: PUSH
109954: DOUBLE
109955: LD_INT 1
109957: DEC
109958: ST_TO_ADDR
109959: LD_EXP 140
109963: PUSH
109964: LD_VAR 0 5
109968: ARRAY
109969: PUSH
109970: FOR_TO
109971: IFFALSE 110012
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109973: LD_EXP 140
109977: PUSH
109978: LD_VAR 0 5
109982: ARRAY
109983: PUSH
109984: LD_VAR 0 4
109988: ARRAY
109989: PUSH
109990: LD_INT 1
109992: ARRAY
109993: PUSH
109994: LD_VAR 0 2
109998: EQUAL
109999: IFFALSE 110010
// KillUnit ( vehicle ) ;
110001: LD_VAR 0 2
110005: PPUSH
110006: CALL_OW 66
110010: GO 109970
110012: POP
110013: POP
// end ;
110014: LD_VAR 0 3
110018: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110019: LD_EXP 144
110023: NOT
110024: IFFALSE 110059
110026: GO 110028
110028: DISABLE
// begin initMiner := true ;
110029: LD_ADDR_EXP 144
110033: PUSH
110034: LD_INT 1
110036: ST_TO_ADDR
// minersList := [ ] ;
110037: LD_ADDR_EXP 145
110041: PUSH
110042: EMPTY
110043: ST_TO_ADDR
// minerMinesList := [ ] ;
110044: LD_ADDR_EXP 146
110048: PUSH
110049: EMPTY
110050: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
110051: LD_ADDR_EXP 147
110055: PUSH
110056: LD_INT 5
110058: ST_TO_ADDR
// end ;
110059: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
110060: LD_EXP 144
110064: PUSH
110065: LD_INT 34
110067: PUSH
110068: LD_INT 81
110070: PUSH
110071: EMPTY
110072: LIST
110073: LIST
110074: PPUSH
110075: CALL_OW 69
110079: AND
110080: IFFALSE 110541
110082: GO 110084
110084: DISABLE
110085: LD_INT 0
110087: PPUSH
110088: PPUSH
110089: PPUSH
110090: PPUSH
// begin enable ;
110091: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
110092: LD_ADDR_VAR 0 1
110096: PUSH
110097: LD_INT 34
110099: PUSH
110100: LD_INT 81
110102: PUSH
110103: EMPTY
110104: LIST
110105: LIST
110106: PPUSH
110107: CALL_OW 69
110111: PUSH
110112: FOR_IN
110113: IFFALSE 110185
// begin if not i in minersList then
110115: LD_VAR 0 1
110119: PUSH
110120: LD_EXP 145
110124: IN
110125: NOT
110126: IFFALSE 110183
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
110128: LD_ADDR_EXP 145
110132: PUSH
110133: LD_EXP 145
110137: PPUSH
110138: LD_EXP 145
110142: PUSH
110143: LD_INT 1
110145: PLUS
110146: PPUSH
110147: LD_VAR 0 1
110151: PPUSH
110152: CALL_OW 1
110156: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110157: LD_ADDR_EXP 146
110161: PUSH
110162: LD_EXP 146
110166: PPUSH
110167: LD_EXP 146
110171: PUSH
110172: LD_INT 1
110174: PLUS
110175: PPUSH
110176: EMPTY
110177: PPUSH
110178: CALL_OW 1
110182: ST_TO_ADDR
// end end ;
110183: GO 110112
110185: POP
110186: POP
// for i := minerMinesList downto 1 do
110187: LD_ADDR_VAR 0 1
110191: PUSH
110192: DOUBLE
110193: LD_EXP 146
110197: INC
110198: ST_TO_ADDR
110199: LD_INT 1
110201: PUSH
110202: FOR_DOWNTO
110203: IFFALSE 110539
// begin if IsLive ( minersList [ i ] ) then
110205: LD_EXP 145
110209: PUSH
110210: LD_VAR 0 1
110214: ARRAY
110215: PPUSH
110216: CALL_OW 300
110220: IFFALSE 110248
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110222: LD_EXP 145
110226: PUSH
110227: LD_VAR 0 1
110231: ARRAY
110232: PPUSH
110233: LD_EXP 146
110237: PUSH
110238: LD_VAR 0 1
110242: ARRAY
110243: PPUSH
110244: CALL_OW 505
// if not minerMinesList [ i ] then
110248: LD_EXP 146
110252: PUSH
110253: LD_VAR 0 1
110257: ARRAY
110258: NOT
110259: IFFALSE 110263
// continue ;
110261: GO 110202
// for j := minerMinesList [ i ] downto 1 do
110263: LD_ADDR_VAR 0 2
110267: PUSH
110268: DOUBLE
110269: LD_EXP 146
110273: PUSH
110274: LD_VAR 0 1
110278: ARRAY
110279: INC
110280: ST_TO_ADDR
110281: LD_INT 1
110283: PUSH
110284: FOR_DOWNTO
110285: IFFALSE 110535
// begin side := GetSide ( minersList [ i ] ) ;
110287: LD_ADDR_VAR 0 3
110291: PUSH
110292: LD_EXP 145
110296: PUSH
110297: LD_VAR 0 1
110301: ARRAY
110302: PPUSH
110303: CALL_OW 255
110307: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110308: LD_ADDR_VAR 0 4
110312: PUSH
110313: LD_EXP 146
110317: PUSH
110318: LD_VAR 0 1
110322: ARRAY
110323: PUSH
110324: LD_VAR 0 2
110328: ARRAY
110329: PUSH
110330: LD_INT 1
110332: ARRAY
110333: PPUSH
110334: LD_EXP 146
110338: PUSH
110339: LD_VAR 0 1
110343: ARRAY
110344: PUSH
110345: LD_VAR 0 2
110349: ARRAY
110350: PUSH
110351: LD_INT 2
110353: ARRAY
110354: PPUSH
110355: CALL_OW 428
110359: ST_TO_ADDR
// if not tmp then
110360: LD_VAR 0 4
110364: NOT
110365: IFFALSE 110369
// continue ;
110367: GO 110284
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110369: LD_VAR 0 4
110373: PUSH
110374: LD_INT 81
110376: PUSH
110377: LD_VAR 0 3
110381: PUSH
110382: EMPTY
110383: LIST
110384: LIST
110385: PPUSH
110386: CALL_OW 69
110390: IN
110391: PUSH
110392: LD_EXP 146
110396: PUSH
110397: LD_VAR 0 1
110401: ARRAY
110402: PUSH
110403: LD_VAR 0 2
110407: ARRAY
110408: PUSH
110409: LD_INT 1
110411: ARRAY
110412: PPUSH
110413: LD_EXP 146
110417: PUSH
110418: LD_VAR 0 1
110422: ARRAY
110423: PUSH
110424: LD_VAR 0 2
110428: ARRAY
110429: PUSH
110430: LD_INT 2
110432: ARRAY
110433: PPUSH
110434: CALL_OW 458
110438: AND
110439: IFFALSE 110533
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110441: LD_EXP 146
110445: PUSH
110446: LD_VAR 0 1
110450: ARRAY
110451: PUSH
110452: LD_VAR 0 2
110456: ARRAY
110457: PUSH
110458: LD_INT 1
110460: ARRAY
110461: PPUSH
110462: LD_EXP 146
110466: PUSH
110467: LD_VAR 0 1
110471: ARRAY
110472: PUSH
110473: LD_VAR 0 2
110477: ARRAY
110478: PUSH
110479: LD_INT 2
110481: ARRAY
110482: PPUSH
110483: LD_VAR 0 3
110487: PPUSH
110488: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110492: LD_ADDR_EXP 146
110496: PUSH
110497: LD_EXP 146
110501: PPUSH
110502: LD_VAR 0 1
110506: PPUSH
110507: LD_EXP 146
110511: PUSH
110512: LD_VAR 0 1
110516: ARRAY
110517: PPUSH
110518: LD_VAR 0 2
110522: PPUSH
110523: CALL_OW 3
110527: PPUSH
110528: CALL_OW 1
110532: ST_TO_ADDR
// end ; end ;
110533: GO 110284
110535: POP
110536: POP
// end ;
110537: GO 110202
110539: POP
110540: POP
// end ;
110541: PPOPN 4
110543: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110544: LD_INT 0
110546: PPUSH
110547: PPUSH
// result := false ;
110548: LD_ADDR_VAR 0 4
110552: PUSH
110553: LD_INT 0
110555: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110556: LD_VAR 0 1
110560: PPUSH
110561: CALL_OW 264
110565: PUSH
110566: LD_INT 81
110568: EQUAL
110569: NOT
110570: IFFALSE 110574
// exit ;
110572: GO 110814
// index := GetElementIndex ( minersList , unit ) ;
110574: LD_ADDR_VAR 0 5
110578: PUSH
110579: LD_EXP 145
110583: PPUSH
110584: LD_VAR 0 1
110588: PPUSH
110589: CALL 24631 0 2
110593: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110594: LD_EXP 146
110598: PUSH
110599: LD_VAR 0 5
110603: ARRAY
110604: PUSH
110605: LD_EXP 147
110609: GREATEREQUAL
110610: IFFALSE 110614
// exit ;
110612: GO 110814
// ComMoveXY ( unit , x , y ) ;
110614: LD_VAR 0 1
110618: PPUSH
110619: LD_VAR 0 2
110623: PPUSH
110624: LD_VAR 0 3
110628: PPUSH
110629: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110633: LD_INT 35
110635: PPUSH
110636: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110640: LD_VAR 0 1
110644: PPUSH
110645: LD_VAR 0 2
110649: PPUSH
110650: LD_VAR 0 3
110654: PPUSH
110655: CALL 55986 0 3
110659: NOT
110660: PUSH
110661: LD_VAR 0 1
110665: PPUSH
110666: CALL_OW 314
110670: AND
110671: IFFALSE 110675
// exit ;
110673: GO 110814
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110675: LD_VAR 0 2
110679: PPUSH
110680: LD_VAR 0 3
110684: PPUSH
110685: CALL_OW 428
110689: PUSH
110690: LD_VAR 0 1
110694: EQUAL
110695: PUSH
110696: LD_VAR 0 1
110700: PPUSH
110701: CALL_OW 314
110705: NOT
110706: AND
110707: IFFALSE 110633
// PlaySoundXY ( x , y , PlantMine ) ;
110709: LD_VAR 0 2
110713: PPUSH
110714: LD_VAR 0 3
110718: PPUSH
110719: LD_STRING PlantMine
110721: PPUSH
110722: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110726: LD_VAR 0 2
110730: PPUSH
110731: LD_VAR 0 3
110735: PPUSH
110736: LD_VAR 0 1
110740: PPUSH
110741: CALL_OW 255
110745: PPUSH
110746: LD_INT 0
110748: PPUSH
110749: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110753: LD_ADDR_EXP 146
110757: PUSH
110758: LD_EXP 146
110762: PPUSH
110763: LD_VAR 0 5
110767: PUSH
110768: LD_EXP 146
110772: PUSH
110773: LD_VAR 0 5
110777: ARRAY
110778: PUSH
110779: LD_INT 1
110781: PLUS
110782: PUSH
110783: EMPTY
110784: LIST
110785: LIST
110786: PPUSH
110787: LD_VAR 0 2
110791: PUSH
110792: LD_VAR 0 3
110796: PUSH
110797: EMPTY
110798: LIST
110799: LIST
110800: PPUSH
110801: CALL 24846 0 3
110805: ST_TO_ADDR
// result := true ;
110806: LD_ADDR_VAR 0 4
110810: PUSH
110811: LD_INT 1
110813: ST_TO_ADDR
// end ;
110814: LD_VAR 0 4
110818: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110819: LD_INT 0
110821: PPUSH
110822: PPUSH
110823: PPUSH
// if not unit in minersList then
110824: LD_VAR 0 1
110828: PUSH
110829: LD_EXP 145
110833: IN
110834: NOT
110835: IFFALSE 110839
// exit ;
110837: GO 111231
// index := GetElementIndex ( minersList , unit ) ;
110839: LD_ADDR_VAR 0 6
110843: PUSH
110844: LD_EXP 145
110848: PPUSH
110849: LD_VAR 0 1
110853: PPUSH
110854: CALL 24631 0 2
110858: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110859: LD_ADDR_VAR 0 5
110863: PUSH
110864: DOUBLE
110865: LD_EXP 146
110869: PUSH
110870: LD_VAR 0 6
110874: ARRAY
110875: INC
110876: ST_TO_ADDR
110877: LD_INT 1
110879: PUSH
110880: FOR_DOWNTO
110881: IFFALSE 111042
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110883: LD_EXP 146
110887: PUSH
110888: LD_VAR 0 6
110892: ARRAY
110893: PUSH
110894: LD_VAR 0 5
110898: ARRAY
110899: PUSH
110900: LD_INT 1
110902: ARRAY
110903: PUSH
110904: LD_VAR 0 2
110908: EQUAL
110909: PUSH
110910: LD_EXP 146
110914: PUSH
110915: LD_VAR 0 6
110919: ARRAY
110920: PUSH
110921: LD_VAR 0 5
110925: ARRAY
110926: PUSH
110927: LD_INT 2
110929: ARRAY
110930: PUSH
110931: LD_VAR 0 3
110935: EQUAL
110936: AND
110937: IFFALSE 111040
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110939: LD_EXP 146
110943: PUSH
110944: LD_VAR 0 6
110948: ARRAY
110949: PUSH
110950: LD_VAR 0 5
110954: ARRAY
110955: PUSH
110956: LD_INT 1
110958: ARRAY
110959: PPUSH
110960: LD_EXP 146
110964: PUSH
110965: LD_VAR 0 6
110969: ARRAY
110970: PUSH
110971: LD_VAR 0 5
110975: ARRAY
110976: PUSH
110977: LD_INT 2
110979: ARRAY
110980: PPUSH
110981: LD_VAR 0 1
110985: PPUSH
110986: CALL_OW 255
110990: PPUSH
110991: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110995: LD_ADDR_EXP 146
110999: PUSH
111000: LD_EXP 146
111004: PPUSH
111005: LD_VAR 0 6
111009: PPUSH
111010: LD_EXP 146
111014: PUSH
111015: LD_VAR 0 6
111019: ARRAY
111020: PPUSH
111021: LD_VAR 0 5
111025: PPUSH
111026: CALL_OW 3
111030: PPUSH
111031: CALL_OW 1
111035: ST_TO_ADDR
// exit ;
111036: POP
111037: POP
111038: GO 111231
// end ; end ;
111040: GO 110880
111042: POP
111043: POP
// for i := minerMinesList [ index ] downto 1 do
111044: LD_ADDR_VAR 0 5
111048: PUSH
111049: DOUBLE
111050: LD_EXP 146
111054: PUSH
111055: LD_VAR 0 6
111059: ARRAY
111060: INC
111061: ST_TO_ADDR
111062: LD_INT 1
111064: PUSH
111065: FOR_DOWNTO
111066: IFFALSE 111229
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
111068: LD_EXP 146
111072: PUSH
111073: LD_VAR 0 6
111077: ARRAY
111078: PUSH
111079: LD_VAR 0 5
111083: ARRAY
111084: PUSH
111085: LD_INT 1
111087: ARRAY
111088: PPUSH
111089: LD_EXP 146
111093: PUSH
111094: LD_VAR 0 6
111098: ARRAY
111099: PUSH
111100: LD_VAR 0 5
111104: ARRAY
111105: PUSH
111106: LD_INT 2
111108: ARRAY
111109: PPUSH
111110: LD_VAR 0 2
111114: PPUSH
111115: LD_VAR 0 3
111119: PPUSH
111120: CALL_OW 298
111124: PUSH
111125: LD_INT 6
111127: LESS
111128: IFFALSE 111227
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111130: LD_EXP 146
111134: PUSH
111135: LD_VAR 0 6
111139: ARRAY
111140: PUSH
111141: LD_VAR 0 5
111145: ARRAY
111146: PUSH
111147: LD_INT 1
111149: ARRAY
111150: PPUSH
111151: LD_EXP 146
111155: PUSH
111156: LD_VAR 0 6
111160: ARRAY
111161: PUSH
111162: LD_VAR 0 5
111166: ARRAY
111167: PUSH
111168: LD_INT 2
111170: ARRAY
111171: PPUSH
111172: LD_VAR 0 1
111176: PPUSH
111177: CALL_OW 255
111181: PPUSH
111182: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111186: LD_ADDR_EXP 146
111190: PUSH
111191: LD_EXP 146
111195: PPUSH
111196: LD_VAR 0 6
111200: PPUSH
111201: LD_EXP 146
111205: PUSH
111206: LD_VAR 0 6
111210: ARRAY
111211: PPUSH
111212: LD_VAR 0 5
111216: PPUSH
111217: CALL_OW 3
111221: PPUSH
111222: CALL_OW 1
111226: ST_TO_ADDR
// end ; end ;
111227: GO 111065
111229: POP
111230: POP
// end ;
111231: LD_VAR 0 4
111235: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111236: LD_INT 0
111238: PPUSH
111239: PPUSH
111240: PPUSH
111241: PPUSH
111242: PPUSH
111243: PPUSH
111244: PPUSH
111245: PPUSH
111246: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111247: LD_VAR 0 1
111251: PPUSH
111252: CALL_OW 264
111256: PUSH
111257: LD_INT 81
111259: EQUAL
111260: NOT
111261: PUSH
111262: LD_VAR 0 1
111266: PUSH
111267: LD_EXP 145
111271: IN
111272: NOT
111273: OR
111274: IFFALSE 111278
// exit ;
111276: GO 111600
// index := GetElementIndex ( minersList , unit ) ;
111278: LD_ADDR_VAR 0 6
111282: PUSH
111283: LD_EXP 145
111287: PPUSH
111288: LD_VAR 0 1
111292: PPUSH
111293: CALL 24631 0 2
111297: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111298: LD_ADDR_VAR 0 8
111302: PUSH
111303: LD_EXP 147
111307: PUSH
111308: LD_EXP 146
111312: PUSH
111313: LD_VAR 0 6
111317: ARRAY
111318: MINUS
111319: ST_TO_ADDR
// if not minesFreeAmount then
111320: LD_VAR 0 8
111324: NOT
111325: IFFALSE 111329
// exit ;
111327: GO 111600
// tmp := [ ] ;
111329: LD_ADDR_VAR 0 7
111333: PUSH
111334: EMPTY
111335: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111336: LD_ADDR_VAR 0 5
111340: PUSH
111341: DOUBLE
111342: LD_INT 1
111344: DEC
111345: ST_TO_ADDR
111346: LD_VAR 0 8
111350: PUSH
111351: FOR_TO
111352: IFFALSE 111547
// begin _d := rand ( 0 , 5 ) ;
111354: LD_ADDR_VAR 0 11
111358: PUSH
111359: LD_INT 0
111361: PPUSH
111362: LD_INT 5
111364: PPUSH
111365: CALL_OW 12
111369: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111370: LD_ADDR_VAR 0 12
111374: PUSH
111375: LD_INT 2
111377: PPUSH
111378: LD_INT 6
111380: PPUSH
111381: CALL_OW 12
111385: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111386: LD_ADDR_VAR 0 9
111390: PUSH
111391: LD_VAR 0 2
111395: PPUSH
111396: LD_VAR 0 11
111400: PPUSH
111401: LD_VAR 0 12
111405: PPUSH
111406: CALL_OW 272
111410: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111411: LD_ADDR_VAR 0 10
111415: PUSH
111416: LD_VAR 0 3
111420: PPUSH
111421: LD_VAR 0 11
111425: PPUSH
111426: LD_VAR 0 12
111430: PPUSH
111431: CALL_OW 273
111435: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111436: LD_VAR 0 9
111440: PPUSH
111441: LD_VAR 0 10
111445: PPUSH
111446: CALL_OW 488
111450: PUSH
111451: LD_VAR 0 9
111455: PUSH
111456: LD_VAR 0 10
111460: PUSH
111461: EMPTY
111462: LIST
111463: LIST
111464: PUSH
111465: LD_VAR 0 7
111469: IN
111470: NOT
111471: AND
111472: PUSH
111473: LD_VAR 0 9
111477: PPUSH
111478: LD_VAR 0 10
111482: PPUSH
111483: CALL_OW 458
111487: NOT
111488: AND
111489: IFFALSE 111531
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111491: LD_ADDR_VAR 0 7
111495: PUSH
111496: LD_VAR 0 7
111500: PPUSH
111501: LD_VAR 0 7
111505: PUSH
111506: LD_INT 1
111508: PLUS
111509: PPUSH
111510: LD_VAR 0 9
111514: PUSH
111515: LD_VAR 0 10
111519: PUSH
111520: EMPTY
111521: LIST
111522: LIST
111523: PPUSH
111524: CALL_OW 1
111528: ST_TO_ADDR
111529: GO 111545
// i := i - 1 ;
111531: LD_ADDR_VAR 0 5
111535: PUSH
111536: LD_VAR 0 5
111540: PUSH
111541: LD_INT 1
111543: MINUS
111544: ST_TO_ADDR
// end ;
111545: GO 111351
111547: POP
111548: POP
// for i in tmp do
111549: LD_ADDR_VAR 0 5
111553: PUSH
111554: LD_VAR 0 7
111558: PUSH
111559: FOR_IN
111560: IFFALSE 111598
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111562: LD_VAR 0 1
111566: PPUSH
111567: LD_VAR 0 5
111571: PUSH
111572: LD_INT 1
111574: ARRAY
111575: PPUSH
111576: LD_VAR 0 5
111580: PUSH
111581: LD_INT 2
111583: ARRAY
111584: PPUSH
111585: CALL 110544 0 3
111589: NOT
111590: IFFALSE 111596
// exit ;
111592: POP
111593: POP
111594: GO 111600
111596: GO 111559
111598: POP
111599: POP
// end ;
111600: LD_VAR 0 4
111604: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111605: LD_INT 0
111607: PPUSH
111608: PPUSH
111609: PPUSH
111610: PPUSH
111611: PPUSH
111612: PPUSH
111613: PPUSH
// if not GetClass ( unit ) = class_sniper then
111614: LD_VAR 0 1
111618: PPUSH
111619: CALL_OW 257
111623: PUSH
111624: LD_INT 5
111626: EQUAL
111627: NOT
111628: IFFALSE 111632
// exit ;
111630: GO 112020
// dist := 8 ;
111632: LD_ADDR_VAR 0 5
111636: PUSH
111637: LD_INT 8
111639: ST_TO_ADDR
// viewRange := 12 ;
111640: LD_ADDR_VAR 0 7
111644: PUSH
111645: LD_INT 12
111647: ST_TO_ADDR
// side := GetSide ( unit ) ;
111648: LD_ADDR_VAR 0 6
111652: PUSH
111653: LD_VAR 0 1
111657: PPUSH
111658: CALL_OW 255
111662: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111663: LD_INT 61
111665: PPUSH
111666: LD_VAR 0 6
111670: PPUSH
111671: CALL_OW 321
111675: PUSH
111676: LD_INT 2
111678: EQUAL
111679: IFFALSE 111689
// viewRange := 16 ;
111681: LD_ADDR_VAR 0 7
111685: PUSH
111686: LD_INT 16
111688: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111689: LD_VAR 0 1
111693: PPUSH
111694: LD_VAR 0 2
111698: PPUSH
111699: LD_VAR 0 3
111703: PPUSH
111704: CALL_OW 297
111708: PUSH
111709: LD_VAR 0 5
111713: GREATER
111714: IFFALSE 111793
// begin ComMoveXY ( unit , x , y ) ;
111716: LD_VAR 0 1
111720: PPUSH
111721: LD_VAR 0 2
111725: PPUSH
111726: LD_VAR 0 3
111730: PPUSH
111731: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111735: LD_INT 35
111737: PPUSH
111738: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111742: LD_VAR 0 1
111746: PPUSH
111747: LD_VAR 0 2
111751: PPUSH
111752: LD_VAR 0 3
111756: PPUSH
111757: CALL 55986 0 3
111761: NOT
111762: IFFALSE 111766
// exit ;
111764: GO 112020
// until GetDistUnitXY ( unit , x , y ) < dist ;
111766: LD_VAR 0 1
111770: PPUSH
111771: LD_VAR 0 2
111775: PPUSH
111776: LD_VAR 0 3
111780: PPUSH
111781: CALL_OW 297
111785: PUSH
111786: LD_VAR 0 5
111790: LESS
111791: IFFALSE 111735
// end ; ComTurnXY ( unit , x , y ) ;
111793: LD_VAR 0 1
111797: PPUSH
111798: LD_VAR 0 2
111802: PPUSH
111803: LD_VAR 0 3
111807: PPUSH
111808: CALL_OW 118
// wait ( 5 ) ;
111812: LD_INT 5
111814: PPUSH
111815: CALL_OW 67
// _d := GetDir ( unit ) ;
111819: LD_ADDR_VAR 0 10
111823: PUSH
111824: LD_VAR 0 1
111828: PPUSH
111829: CALL_OW 254
111833: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111834: LD_ADDR_VAR 0 8
111838: PUSH
111839: LD_VAR 0 1
111843: PPUSH
111844: CALL_OW 250
111848: PPUSH
111849: LD_VAR 0 10
111853: PPUSH
111854: LD_VAR 0 5
111858: PPUSH
111859: CALL_OW 272
111863: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111864: LD_ADDR_VAR 0 9
111868: PUSH
111869: LD_VAR 0 1
111873: PPUSH
111874: CALL_OW 251
111878: PPUSH
111879: LD_VAR 0 10
111883: PPUSH
111884: LD_VAR 0 5
111888: PPUSH
111889: CALL_OW 273
111893: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111894: LD_VAR 0 8
111898: PPUSH
111899: LD_VAR 0 9
111903: PPUSH
111904: CALL_OW 488
111908: NOT
111909: IFFALSE 111913
// exit ;
111911: GO 112020
// ComAnimCustom ( unit , 1 ) ;
111913: LD_VAR 0 1
111917: PPUSH
111918: LD_INT 1
111920: PPUSH
111921: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111925: LD_VAR 0 8
111929: PPUSH
111930: LD_VAR 0 9
111934: PPUSH
111935: LD_VAR 0 6
111939: PPUSH
111940: LD_VAR 0 7
111944: PPUSH
111945: CALL_OW 330
// repeat wait ( 1 ) ;
111949: LD_INT 1
111951: PPUSH
111952: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111956: LD_VAR 0 1
111960: PPUSH
111961: CALL_OW 316
111965: PUSH
111966: LD_VAR 0 1
111970: PPUSH
111971: CALL_OW 314
111975: OR
111976: PUSH
111977: LD_VAR 0 1
111981: PPUSH
111982: CALL_OW 302
111986: NOT
111987: OR
111988: PUSH
111989: LD_VAR 0 1
111993: PPUSH
111994: CALL_OW 301
111998: OR
111999: IFFALSE 111949
// RemoveSeeing ( _x , _y , side ) ;
112001: LD_VAR 0 8
112005: PPUSH
112006: LD_VAR 0 9
112010: PPUSH
112011: LD_VAR 0 6
112015: PPUSH
112016: CALL_OW 331
// end ; end_of_file
112020: LD_VAR 0 4
112024: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112025: LD_INT 0
112027: PPUSH
112028: PPUSH
112029: PPUSH
112030: PPUSH
112031: PPUSH
112032: PPUSH
112033: PPUSH
112034: PPUSH
112035: PPUSH
112036: PPUSH
112037: PPUSH
112038: PPUSH
112039: PPUSH
112040: PPUSH
112041: PPUSH
112042: PPUSH
112043: PPUSH
112044: PPUSH
112045: PPUSH
112046: PPUSH
112047: PPUSH
112048: PPUSH
112049: PPUSH
112050: PPUSH
112051: PPUSH
112052: PPUSH
112053: PPUSH
112054: PPUSH
112055: PPUSH
112056: PPUSH
112057: PPUSH
112058: PPUSH
112059: PPUSH
112060: PPUSH
// if not list then
112061: LD_VAR 0 1
112065: NOT
112066: IFFALSE 112070
// exit ;
112068: GO 116729
// base := list [ 1 ] ;
112070: LD_ADDR_VAR 0 3
112074: PUSH
112075: LD_VAR 0 1
112079: PUSH
112080: LD_INT 1
112082: ARRAY
112083: ST_TO_ADDR
// group := list [ 2 ] ;
112084: LD_ADDR_VAR 0 4
112088: PUSH
112089: LD_VAR 0 1
112093: PUSH
112094: LD_INT 2
112096: ARRAY
112097: ST_TO_ADDR
// path := list [ 3 ] ;
112098: LD_ADDR_VAR 0 5
112102: PUSH
112103: LD_VAR 0 1
112107: PUSH
112108: LD_INT 3
112110: ARRAY
112111: ST_TO_ADDR
// flags := list [ 4 ] ;
112112: LD_ADDR_VAR 0 6
112116: PUSH
112117: LD_VAR 0 1
112121: PUSH
112122: LD_INT 4
112124: ARRAY
112125: ST_TO_ADDR
// mined := [ ] ;
112126: LD_ADDR_VAR 0 27
112130: PUSH
112131: EMPTY
112132: ST_TO_ADDR
// bombed := [ ] ;
112133: LD_ADDR_VAR 0 28
112137: PUSH
112138: EMPTY
112139: ST_TO_ADDR
// healers := [ ] ;
112140: LD_ADDR_VAR 0 31
112144: PUSH
112145: EMPTY
112146: ST_TO_ADDR
// to_heal := [ ] ;
112147: LD_ADDR_VAR 0 30
112151: PUSH
112152: EMPTY
112153: ST_TO_ADDR
// repairs := [ ] ;
112154: LD_ADDR_VAR 0 33
112158: PUSH
112159: EMPTY
112160: ST_TO_ADDR
// to_repair := [ ] ;
112161: LD_ADDR_VAR 0 32
112165: PUSH
112166: EMPTY
112167: ST_TO_ADDR
// if not group or not path then
112168: LD_VAR 0 4
112172: NOT
112173: PUSH
112174: LD_VAR 0 5
112178: NOT
112179: OR
112180: IFFALSE 112184
// exit ;
112182: GO 116729
// side := GetSide ( group [ 1 ] ) ;
112184: LD_ADDR_VAR 0 35
112188: PUSH
112189: LD_VAR 0 4
112193: PUSH
112194: LD_INT 1
112196: ARRAY
112197: PPUSH
112198: CALL_OW 255
112202: ST_TO_ADDR
// if flags then
112203: LD_VAR 0 6
112207: IFFALSE 112351
// begin f_ignore_area := flags [ 1 ] ;
112209: LD_ADDR_VAR 0 17
112213: PUSH
112214: LD_VAR 0 6
112218: PUSH
112219: LD_INT 1
112221: ARRAY
112222: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112223: LD_ADDR_VAR 0 18
112227: PUSH
112228: LD_VAR 0 6
112232: PUSH
112233: LD_INT 2
112235: ARRAY
112236: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112237: LD_ADDR_VAR 0 19
112241: PUSH
112242: LD_VAR 0 6
112246: PUSH
112247: LD_INT 3
112249: ARRAY
112250: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112251: LD_ADDR_VAR 0 20
112255: PUSH
112256: LD_VAR 0 6
112260: PUSH
112261: LD_INT 4
112263: ARRAY
112264: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112265: LD_ADDR_VAR 0 21
112269: PUSH
112270: LD_VAR 0 6
112274: PUSH
112275: LD_INT 5
112277: ARRAY
112278: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112279: LD_ADDR_VAR 0 22
112283: PUSH
112284: LD_VAR 0 6
112288: PUSH
112289: LD_INT 6
112291: ARRAY
112292: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112293: LD_ADDR_VAR 0 23
112297: PUSH
112298: LD_VAR 0 6
112302: PUSH
112303: LD_INT 7
112305: ARRAY
112306: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112307: LD_ADDR_VAR 0 24
112311: PUSH
112312: LD_VAR 0 6
112316: PUSH
112317: LD_INT 8
112319: ARRAY
112320: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112321: LD_ADDR_VAR 0 25
112325: PUSH
112326: LD_VAR 0 6
112330: PUSH
112331: LD_INT 9
112333: ARRAY
112334: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112335: LD_ADDR_VAR 0 26
112339: PUSH
112340: LD_VAR 0 6
112344: PUSH
112345: LD_INT 10
112347: ARRAY
112348: ST_TO_ADDR
// end else
112349: GO 112431
// begin f_ignore_area := false ;
112351: LD_ADDR_VAR 0 17
112355: PUSH
112356: LD_INT 0
112358: ST_TO_ADDR
// f_capture := false ;
112359: LD_ADDR_VAR 0 18
112363: PUSH
112364: LD_INT 0
112366: ST_TO_ADDR
// f_ignore_civ := false ;
112367: LD_ADDR_VAR 0 19
112371: PUSH
112372: LD_INT 0
112374: ST_TO_ADDR
// f_murder := false ;
112375: LD_ADDR_VAR 0 20
112379: PUSH
112380: LD_INT 0
112382: ST_TO_ADDR
// f_mines := false ;
112383: LD_ADDR_VAR 0 21
112387: PUSH
112388: LD_INT 0
112390: ST_TO_ADDR
// f_repair := false ;
112391: LD_ADDR_VAR 0 22
112395: PUSH
112396: LD_INT 0
112398: ST_TO_ADDR
// f_heal := false ;
112399: LD_ADDR_VAR 0 23
112403: PUSH
112404: LD_INT 0
112406: ST_TO_ADDR
// f_spacetime := false ;
112407: LD_ADDR_VAR 0 24
112411: PUSH
112412: LD_INT 0
112414: ST_TO_ADDR
// f_attack_depot := false ;
112415: LD_ADDR_VAR 0 25
112419: PUSH
112420: LD_INT 0
112422: ST_TO_ADDR
// f_crawl := false ;
112423: LD_ADDR_VAR 0 26
112427: PUSH
112428: LD_INT 0
112430: ST_TO_ADDR
// end ; if f_heal then
112431: LD_VAR 0 23
112435: IFFALSE 112462
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112437: LD_ADDR_VAR 0 31
112441: PUSH
112442: LD_VAR 0 4
112446: PPUSH
112447: LD_INT 25
112449: PUSH
112450: LD_INT 4
112452: PUSH
112453: EMPTY
112454: LIST
112455: LIST
112456: PPUSH
112457: CALL_OW 72
112461: ST_TO_ADDR
// if f_repair then
112462: LD_VAR 0 22
112466: IFFALSE 112493
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112468: LD_ADDR_VAR 0 33
112472: PUSH
112473: LD_VAR 0 4
112477: PPUSH
112478: LD_INT 25
112480: PUSH
112481: LD_INT 3
112483: PUSH
112484: EMPTY
112485: LIST
112486: LIST
112487: PPUSH
112488: CALL_OW 72
112492: ST_TO_ADDR
// units_path := [ ] ;
112493: LD_ADDR_VAR 0 16
112497: PUSH
112498: EMPTY
112499: ST_TO_ADDR
// for i = 1 to group do
112500: LD_ADDR_VAR 0 7
112504: PUSH
112505: DOUBLE
112506: LD_INT 1
112508: DEC
112509: ST_TO_ADDR
112510: LD_VAR 0 4
112514: PUSH
112515: FOR_TO
112516: IFFALSE 112545
// units_path := Replace ( units_path , i , path ) ;
112518: LD_ADDR_VAR 0 16
112522: PUSH
112523: LD_VAR 0 16
112527: PPUSH
112528: LD_VAR 0 7
112532: PPUSH
112533: LD_VAR 0 5
112537: PPUSH
112538: CALL_OW 1
112542: ST_TO_ADDR
112543: GO 112515
112545: POP
112546: POP
// repeat for i = group downto 1 do
112547: LD_ADDR_VAR 0 7
112551: PUSH
112552: DOUBLE
112553: LD_VAR 0 4
112557: INC
112558: ST_TO_ADDR
112559: LD_INT 1
112561: PUSH
112562: FOR_DOWNTO
112563: IFFALSE 116685
// begin wait ( 5 ) ;
112565: LD_INT 5
112567: PPUSH
112568: CALL_OW 67
// tmp := [ ] ;
112572: LD_ADDR_VAR 0 14
112576: PUSH
112577: EMPTY
112578: ST_TO_ADDR
// attacking := false ;
112579: LD_ADDR_VAR 0 29
112583: PUSH
112584: LD_INT 0
112586: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112587: LD_VAR 0 4
112591: PUSH
112592: LD_VAR 0 7
112596: ARRAY
112597: PPUSH
112598: CALL_OW 301
112602: PUSH
112603: LD_VAR 0 4
112607: PUSH
112608: LD_VAR 0 7
112612: ARRAY
112613: NOT
112614: OR
112615: IFFALSE 112724
// begin if GetType ( group [ i ] ) = unit_human then
112617: LD_VAR 0 4
112621: PUSH
112622: LD_VAR 0 7
112626: ARRAY
112627: PPUSH
112628: CALL_OW 247
112632: PUSH
112633: LD_INT 1
112635: EQUAL
112636: IFFALSE 112682
// begin to_heal := to_heal diff group [ i ] ;
112638: LD_ADDR_VAR 0 30
112642: PUSH
112643: LD_VAR 0 30
112647: PUSH
112648: LD_VAR 0 4
112652: PUSH
112653: LD_VAR 0 7
112657: ARRAY
112658: DIFF
112659: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112660: LD_ADDR_VAR 0 31
112664: PUSH
112665: LD_VAR 0 31
112669: PUSH
112670: LD_VAR 0 4
112674: PUSH
112675: LD_VAR 0 7
112679: ARRAY
112680: DIFF
112681: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112682: LD_ADDR_VAR 0 4
112686: PUSH
112687: LD_VAR 0 4
112691: PPUSH
112692: LD_VAR 0 7
112696: PPUSH
112697: CALL_OW 3
112701: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112702: LD_ADDR_VAR 0 16
112706: PUSH
112707: LD_VAR 0 16
112711: PPUSH
112712: LD_VAR 0 7
112716: PPUSH
112717: CALL_OW 3
112721: ST_TO_ADDR
// continue ;
112722: GO 112562
// end ; if f_repair then
112724: LD_VAR 0 22
112728: IFFALSE 113217
// begin if GetType ( group [ i ] ) = unit_vehicle then
112730: LD_VAR 0 4
112734: PUSH
112735: LD_VAR 0 7
112739: ARRAY
112740: PPUSH
112741: CALL_OW 247
112745: PUSH
112746: LD_INT 2
112748: EQUAL
112749: IFFALSE 112939
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112751: LD_VAR 0 4
112755: PUSH
112756: LD_VAR 0 7
112760: ARRAY
112761: PPUSH
112762: CALL_OW 256
112766: PUSH
112767: LD_INT 700
112769: LESS
112770: PUSH
112771: LD_VAR 0 4
112775: PUSH
112776: LD_VAR 0 7
112780: ARRAY
112781: PUSH
112782: LD_VAR 0 32
112786: IN
112787: NOT
112788: AND
112789: IFFALSE 112813
// to_repair := to_repair union group [ i ] ;
112791: LD_ADDR_VAR 0 32
112795: PUSH
112796: LD_VAR 0 32
112800: PUSH
112801: LD_VAR 0 4
112805: PUSH
112806: LD_VAR 0 7
112810: ARRAY
112811: UNION
112812: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112813: LD_VAR 0 4
112817: PUSH
112818: LD_VAR 0 7
112822: ARRAY
112823: PPUSH
112824: CALL_OW 256
112828: PUSH
112829: LD_INT 1000
112831: EQUAL
112832: PUSH
112833: LD_VAR 0 4
112837: PUSH
112838: LD_VAR 0 7
112842: ARRAY
112843: PUSH
112844: LD_VAR 0 32
112848: IN
112849: AND
112850: IFFALSE 112874
// to_repair := to_repair diff group [ i ] ;
112852: LD_ADDR_VAR 0 32
112856: PUSH
112857: LD_VAR 0 32
112861: PUSH
112862: LD_VAR 0 4
112866: PUSH
112867: LD_VAR 0 7
112871: ARRAY
112872: DIFF
112873: ST_TO_ADDR
// if group [ i ] in to_repair then
112874: LD_VAR 0 4
112878: PUSH
112879: LD_VAR 0 7
112883: ARRAY
112884: PUSH
112885: LD_VAR 0 32
112889: IN
112890: IFFALSE 112937
// begin if not IsInArea ( group [ i ] , f_repair ) then
112892: LD_VAR 0 4
112896: PUSH
112897: LD_VAR 0 7
112901: ARRAY
112902: PPUSH
112903: LD_VAR 0 22
112907: PPUSH
112908: CALL_OW 308
112912: NOT
112913: IFFALSE 112935
// ComMoveToArea ( group [ i ] , f_repair ) ;
112915: LD_VAR 0 4
112919: PUSH
112920: LD_VAR 0 7
112924: ARRAY
112925: PPUSH
112926: LD_VAR 0 22
112930: PPUSH
112931: CALL_OW 113
// continue ;
112935: GO 112562
// end ; end else
112937: GO 113217
// if group [ i ] in repairs then
112939: LD_VAR 0 4
112943: PUSH
112944: LD_VAR 0 7
112948: ARRAY
112949: PUSH
112950: LD_VAR 0 33
112954: IN
112955: IFFALSE 113217
// begin if IsInUnit ( group [ i ] ) then
112957: LD_VAR 0 4
112961: PUSH
112962: LD_VAR 0 7
112966: ARRAY
112967: PPUSH
112968: CALL_OW 310
112972: IFFALSE 113040
// begin z := IsInUnit ( group [ i ] ) ;
112974: LD_ADDR_VAR 0 13
112978: PUSH
112979: LD_VAR 0 4
112983: PUSH
112984: LD_VAR 0 7
112988: ARRAY
112989: PPUSH
112990: CALL_OW 310
112994: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112995: LD_VAR 0 13
112999: PUSH
113000: LD_VAR 0 32
113004: IN
113005: PUSH
113006: LD_VAR 0 13
113010: PPUSH
113011: LD_VAR 0 22
113015: PPUSH
113016: CALL_OW 308
113020: AND
113021: IFFALSE 113038
// ComExitVehicle ( group [ i ] ) ;
113023: LD_VAR 0 4
113027: PUSH
113028: LD_VAR 0 7
113032: ARRAY
113033: PPUSH
113034: CALL_OW 121
// end else
113038: GO 113217
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113040: LD_ADDR_VAR 0 13
113044: PUSH
113045: LD_VAR 0 4
113049: PPUSH
113050: LD_INT 95
113052: PUSH
113053: LD_VAR 0 22
113057: PUSH
113058: EMPTY
113059: LIST
113060: LIST
113061: PUSH
113062: LD_INT 58
113064: PUSH
113065: EMPTY
113066: LIST
113067: PUSH
113068: EMPTY
113069: LIST
113070: LIST
113071: PPUSH
113072: CALL_OW 72
113076: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113077: LD_VAR 0 4
113081: PUSH
113082: LD_VAR 0 7
113086: ARRAY
113087: PPUSH
113088: CALL_OW 314
113092: NOT
113093: IFFALSE 113215
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113095: LD_ADDR_VAR 0 10
113099: PUSH
113100: LD_VAR 0 13
113104: PPUSH
113105: LD_VAR 0 4
113109: PUSH
113110: LD_VAR 0 7
113114: ARRAY
113115: PPUSH
113116: CALL_OW 74
113120: ST_TO_ADDR
// if not x then
113121: LD_VAR 0 10
113125: NOT
113126: IFFALSE 113130
// continue ;
113128: GO 112562
// if GetLives ( x ) < 1000 then
113130: LD_VAR 0 10
113134: PPUSH
113135: CALL_OW 256
113139: PUSH
113140: LD_INT 1000
113142: LESS
113143: IFFALSE 113167
// ComRepairVehicle ( group [ i ] , x ) else
113145: LD_VAR 0 4
113149: PUSH
113150: LD_VAR 0 7
113154: ARRAY
113155: PPUSH
113156: LD_VAR 0 10
113160: PPUSH
113161: CALL_OW 129
113165: GO 113215
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113167: LD_VAR 0 23
113171: PUSH
113172: LD_VAR 0 4
113176: PUSH
113177: LD_VAR 0 7
113181: ARRAY
113182: PPUSH
113183: CALL_OW 256
113187: PUSH
113188: LD_INT 1000
113190: LESS
113191: AND
113192: NOT
113193: IFFALSE 113215
// ComEnterUnit ( group [ i ] , x ) ;
113195: LD_VAR 0 4
113199: PUSH
113200: LD_VAR 0 7
113204: ARRAY
113205: PPUSH
113206: LD_VAR 0 10
113210: PPUSH
113211: CALL_OW 120
// end ; continue ;
113215: GO 112562
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113217: LD_VAR 0 23
113221: PUSH
113222: LD_VAR 0 4
113226: PUSH
113227: LD_VAR 0 7
113231: ARRAY
113232: PPUSH
113233: CALL_OW 247
113237: PUSH
113238: LD_INT 1
113240: EQUAL
113241: AND
113242: IFFALSE 113720
// begin if group [ i ] in healers then
113244: LD_VAR 0 4
113248: PUSH
113249: LD_VAR 0 7
113253: ARRAY
113254: PUSH
113255: LD_VAR 0 31
113259: IN
113260: IFFALSE 113533
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113262: LD_VAR 0 4
113266: PUSH
113267: LD_VAR 0 7
113271: ARRAY
113272: PPUSH
113273: LD_VAR 0 23
113277: PPUSH
113278: CALL_OW 308
113282: NOT
113283: PUSH
113284: LD_VAR 0 4
113288: PUSH
113289: LD_VAR 0 7
113293: ARRAY
113294: PPUSH
113295: CALL_OW 314
113299: NOT
113300: AND
113301: IFFALSE 113325
// ComMoveToArea ( group [ i ] , f_heal ) else
113303: LD_VAR 0 4
113307: PUSH
113308: LD_VAR 0 7
113312: ARRAY
113313: PPUSH
113314: LD_VAR 0 23
113318: PPUSH
113319: CALL_OW 113
113323: GO 113531
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113325: LD_VAR 0 4
113329: PUSH
113330: LD_VAR 0 7
113334: ARRAY
113335: PPUSH
113336: CALL 54569 0 1
113340: PPUSH
113341: CALL_OW 256
113345: PUSH
113346: LD_INT 1000
113348: EQUAL
113349: IFFALSE 113368
// ComStop ( group [ i ] ) else
113351: LD_VAR 0 4
113355: PUSH
113356: LD_VAR 0 7
113360: ARRAY
113361: PPUSH
113362: CALL_OW 141
113366: GO 113531
// if not HasTask ( group [ i ] ) and to_heal then
113368: LD_VAR 0 4
113372: PUSH
113373: LD_VAR 0 7
113377: ARRAY
113378: PPUSH
113379: CALL_OW 314
113383: NOT
113384: PUSH
113385: LD_VAR 0 30
113389: AND
113390: IFFALSE 113531
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113392: LD_ADDR_VAR 0 13
113396: PUSH
113397: LD_VAR 0 30
113401: PPUSH
113402: LD_INT 3
113404: PUSH
113405: LD_INT 54
113407: PUSH
113408: EMPTY
113409: LIST
113410: PUSH
113411: EMPTY
113412: LIST
113413: LIST
113414: PPUSH
113415: CALL_OW 72
113419: PPUSH
113420: LD_VAR 0 4
113424: PUSH
113425: LD_VAR 0 7
113429: ARRAY
113430: PPUSH
113431: CALL_OW 74
113435: ST_TO_ADDR
// if z then
113436: LD_VAR 0 13
113440: IFFALSE 113531
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113442: LD_INT 91
113444: PUSH
113445: LD_VAR 0 13
113449: PUSH
113450: LD_INT 10
113452: PUSH
113453: EMPTY
113454: LIST
113455: LIST
113456: LIST
113457: PUSH
113458: LD_INT 81
113460: PUSH
113461: LD_VAR 0 13
113465: PPUSH
113466: CALL_OW 255
113470: PUSH
113471: EMPTY
113472: LIST
113473: LIST
113474: PUSH
113475: EMPTY
113476: LIST
113477: LIST
113478: PPUSH
113479: CALL_OW 69
113483: PUSH
113484: LD_INT 0
113486: EQUAL
113487: IFFALSE 113511
// ComHeal ( group [ i ] , z ) else
113489: LD_VAR 0 4
113493: PUSH
113494: LD_VAR 0 7
113498: ARRAY
113499: PPUSH
113500: LD_VAR 0 13
113504: PPUSH
113505: CALL_OW 128
113509: GO 113531
// ComMoveToArea ( group [ i ] , f_heal ) ;
113511: LD_VAR 0 4
113515: PUSH
113516: LD_VAR 0 7
113520: ARRAY
113521: PPUSH
113522: LD_VAR 0 23
113526: PPUSH
113527: CALL_OW 113
// end ; continue ;
113531: GO 112562
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113533: LD_VAR 0 4
113537: PUSH
113538: LD_VAR 0 7
113542: ARRAY
113543: PPUSH
113544: CALL_OW 256
113548: PUSH
113549: LD_INT 700
113551: LESS
113552: PUSH
113553: LD_VAR 0 4
113557: PUSH
113558: LD_VAR 0 7
113562: ARRAY
113563: PUSH
113564: LD_VAR 0 30
113568: IN
113569: NOT
113570: AND
113571: IFFALSE 113595
// to_heal := to_heal union group [ i ] ;
113573: LD_ADDR_VAR 0 30
113577: PUSH
113578: LD_VAR 0 30
113582: PUSH
113583: LD_VAR 0 4
113587: PUSH
113588: LD_VAR 0 7
113592: ARRAY
113593: UNION
113594: ST_TO_ADDR
// if group [ i ] in to_heal then
113595: LD_VAR 0 4
113599: PUSH
113600: LD_VAR 0 7
113604: ARRAY
113605: PUSH
113606: LD_VAR 0 30
113610: IN
113611: IFFALSE 113720
// begin if GetLives ( group [ i ] ) = 1000 then
113613: LD_VAR 0 4
113617: PUSH
113618: LD_VAR 0 7
113622: ARRAY
113623: PPUSH
113624: CALL_OW 256
113628: PUSH
113629: LD_INT 1000
113631: EQUAL
113632: IFFALSE 113658
// to_heal := to_heal diff group [ i ] else
113634: LD_ADDR_VAR 0 30
113638: PUSH
113639: LD_VAR 0 30
113643: PUSH
113644: LD_VAR 0 4
113648: PUSH
113649: LD_VAR 0 7
113653: ARRAY
113654: DIFF
113655: ST_TO_ADDR
113656: GO 113720
// begin if not IsInArea ( group [ i ] , to_heal ) then
113658: LD_VAR 0 4
113662: PUSH
113663: LD_VAR 0 7
113667: ARRAY
113668: PPUSH
113669: LD_VAR 0 30
113673: PPUSH
113674: CALL_OW 308
113678: NOT
113679: IFFALSE 113703
// ComMoveToArea ( group [ i ] , f_heal ) else
113681: LD_VAR 0 4
113685: PUSH
113686: LD_VAR 0 7
113690: ARRAY
113691: PPUSH
113692: LD_VAR 0 23
113696: PPUSH
113697: CALL_OW 113
113701: GO 113718
// ComHold ( group [ i ] ) ;
113703: LD_VAR 0 4
113707: PUSH
113708: LD_VAR 0 7
113712: ARRAY
113713: PPUSH
113714: CALL_OW 140
// continue ;
113718: GO 112562
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113720: LD_VAR 0 4
113724: PUSH
113725: LD_VAR 0 7
113729: ARRAY
113730: PPUSH
113731: LD_INT 10
113733: PPUSH
113734: CALL 52340 0 2
113738: NOT
113739: PUSH
113740: LD_VAR 0 16
113744: PUSH
113745: LD_VAR 0 7
113749: ARRAY
113750: PUSH
113751: EMPTY
113752: EQUAL
113753: NOT
113754: AND
113755: IFFALSE 114021
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113757: LD_VAR 0 4
113761: PUSH
113762: LD_VAR 0 7
113766: ARRAY
113767: PPUSH
113768: CALL_OW 262
113772: PUSH
113773: LD_INT 1
113775: PUSH
113776: LD_INT 2
113778: PUSH
113779: EMPTY
113780: LIST
113781: LIST
113782: IN
113783: IFFALSE 113824
// if GetFuel ( group [ i ] ) < 10 then
113785: LD_VAR 0 4
113789: PUSH
113790: LD_VAR 0 7
113794: ARRAY
113795: PPUSH
113796: CALL_OW 261
113800: PUSH
113801: LD_INT 10
113803: LESS
113804: IFFALSE 113824
// SetFuel ( group [ i ] , 12 ) ;
113806: LD_VAR 0 4
113810: PUSH
113811: LD_VAR 0 7
113815: ARRAY
113816: PPUSH
113817: LD_INT 12
113819: PPUSH
113820: CALL_OW 240
// if units_path [ i ] then
113824: LD_VAR 0 16
113828: PUSH
113829: LD_VAR 0 7
113833: ARRAY
113834: IFFALSE 114019
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113836: LD_VAR 0 4
113840: PUSH
113841: LD_VAR 0 7
113845: ARRAY
113846: PPUSH
113847: LD_VAR 0 16
113851: PUSH
113852: LD_VAR 0 7
113856: ARRAY
113857: PUSH
113858: LD_INT 1
113860: ARRAY
113861: PUSH
113862: LD_INT 1
113864: ARRAY
113865: PPUSH
113866: LD_VAR 0 16
113870: PUSH
113871: LD_VAR 0 7
113875: ARRAY
113876: PUSH
113877: LD_INT 1
113879: ARRAY
113880: PUSH
113881: LD_INT 2
113883: ARRAY
113884: PPUSH
113885: CALL_OW 297
113889: PUSH
113890: LD_INT 6
113892: GREATER
113893: IFFALSE 113968
// begin if not HasTask ( group [ i ] ) then
113895: LD_VAR 0 4
113899: PUSH
113900: LD_VAR 0 7
113904: ARRAY
113905: PPUSH
113906: CALL_OW 314
113910: NOT
113911: IFFALSE 113966
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113913: LD_VAR 0 4
113917: PUSH
113918: LD_VAR 0 7
113922: ARRAY
113923: PPUSH
113924: LD_VAR 0 16
113928: PUSH
113929: LD_VAR 0 7
113933: ARRAY
113934: PUSH
113935: LD_INT 1
113937: ARRAY
113938: PUSH
113939: LD_INT 1
113941: ARRAY
113942: PPUSH
113943: LD_VAR 0 16
113947: PUSH
113948: LD_VAR 0 7
113952: ARRAY
113953: PUSH
113954: LD_INT 1
113956: ARRAY
113957: PUSH
113958: LD_INT 2
113960: ARRAY
113961: PPUSH
113962: CALL_OW 114
// end else
113966: GO 114019
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113968: LD_ADDR_VAR 0 15
113972: PUSH
113973: LD_VAR 0 16
113977: PUSH
113978: LD_VAR 0 7
113982: ARRAY
113983: PPUSH
113984: LD_INT 1
113986: PPUSH
113987: CALL_OW 3
113991: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113992: LD_ADDR_VAR 0 16
113996: PUSH
113997: LD_VAR 0 16
114001: PPUSH
114002: LD_VAR 0 7
114006: PPUSH
114007: LD_VAR 0 15
114011: PPUSH
114012: CALL_OW 1
114016: ST_TO_ADDR
// continue ;
114017: GO 112562
// end ; end ; end else
114019: GO 116683
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114021: LD_ADDR_VAR 0 14
114025: PUSH
114026: LD_INT 81
114028: PUSH
114029: LD_VAR 0 4
114033: PUSH
114034: LD_VAR 0 7
114038: ARRAY
114039: PPUSH
114040: CALL_OW 255
114044: PUSH
114045: EMPTY
114046: LIST
114047: LIST
114048: PPUSH
114049: CALL_OW 69
114053: ST_TO_ADDR
// if not tmp then
114054: LD_VAR 0 14
114058: NOT
114059: IFFALSE 114063
// continue ;
114061: GO 112562
// if f_ignore_area then
114063: LD_VAR 0 17
114067: IFFALSE 114155
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114069: LD_ADDR_VAR 0 15
114073: PUSH
114074: LD_VAR 0 14
114078: PPUSH
114079: LD_INT 3
114081: PUSH
114082: LD_INT 92
114084: PUSH
114085: LD_VAR 0 17
114089: PUSH
114090: LD_INT 1
114092: ARRAY
114093: PUSH
114094: LD_VAR 0 17
114098: PUSH
114099: LD_INT 2
114101: ARRAY
114102: PUSH
114103: LD_VAR 0 17
114107: PUSH
114108: LD_INT 3
114110: ARRAY
114111: PUSH
114112: EMPTY
114113: LIST
114114: LIST
114115: LIST
114116: LIST
114117: PUSH
114118: EMPTY
114119: LIST
114120: LIST
114121: PPUSH
114122: CALL_OW 72
114126: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114127: LD_VAR 0 14
114131: PUSH
114132: LD_VAR 0 15
114136: DIFF
114137: IFFALSE 114155
// tmp := tmp diff tmp2 ;
114139: LD_ADDR_VAR 0 14
114143: PUSH
114144: LD_VAR 0 14
114148: PUSH
114149: LD_VAR 0 15
114153: DIFF
114154: ST_TO_ADDR
// end ; if not f_murder then
114155: LD_VAR 0 20
114159: NOT
114160: IFFALSE 114218
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114162: LD_ADDR_VAR 0 15
114166: PUSH
114167: LD_VAR 0 14
114171: PPUSH
114172: LD_INT 3
114174: PUSH
114175: LD_INT 50
114177: PUSH
114178: EMPTY
114179: LIST
114180: PUSH
114181: EMPTY
114182: LIST
114183: LIST
114184: PPUSH
114185: CALL_OW 72
114189: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114190: LD_VAR 0 14
114194: PUSH
114195: LD_VAR 0 15
114199: DIFF
114200: IFFALSE 114218
// tmp := tmp diff tmp2 ;
114202: LD_ADDR_VAR 0 14
114206: PUSH
114207: LD_VAR 0 14
114211: PUSH
114212: LD_VAR 0 15
114216: DIFF
114217: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114218: LD_ADDR_VAR 0 14
114222: PUSH
114223: LD_VAR 0 4
114227: PUSH
114228: LD_VAR 0 7
114232: ARRAY
114233: PPUSH
114234: LD_VAR 0 14
114238: PPUSH
114239: LD_INT 1
114241: PPUSH
114242: LD_INT 1
114244: PPUSH
114245: CALL 25281 0 4
114249: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114250: LD_VAR 0 4
114254: PUSH
114255: LD_VAR 0 7
114259: ARRAY
114260: PPUSH
114261: CALL_OW 257
114265: PUSH
114266: LD_INT 1
114268: EQUAL
114269: IFFALSE 114717
// begin if WantPlant ( group [ i ] ) then
114271: LD_VAR 0 4
114275: PUSH
114276: LD_VAR 0 7
114280: ARRAY
114281: PPUSH
114282: CALL 24782 0 1
114286: IFFALSE 114290
// continue ;
114288: GO 112562
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114290: LD_VAR 0 18
114294: PUSH
114295: LD_VAR 0 4
114299: PUSH
114300: LD_VAR 0 7
114304: ARRAY
114305: PPUSH
114306: CALL_OW 310
114310: NOT
114311: AND
114312: PUSH
114313: LD_VAR 0 14
114317: PUSH
114318: LD_INT 1
114320: ARRAY
114321: PUSH
114322: LD_VAR 0 14
114326: PPUSH
114327: LD_INT 21
114329: PUSH
114330: LD_INT 2
114332: PUSH
114333: EMPTY
114334: LIST
114335: LIST
114336: PUSH
114337: LD_INT 58
114339: PUSH
114340: EMPTY
114341: LIST
114342: PUSH
114343: EMPTY
114344: LIST
114345: LIST
114346: PPUSH
114347: CALL_OW 72
114351: IN
114352: AND
114353: IFFALSE 114389
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114355: LD_VAR 0 4
114359: PUSH
114360: LD_VAR 0 7
114364: ARRAY
114365: PPUSH
114366: LD_VAR 0 14
114370: PUSH
114371: LD_INT 1
114373: ARRAY
114374: PPUSH
114375: CALL_OW 120
// attacking := true ;
114379: LD_ADDR_VAR 0 29
114383: PUSH
114384: LD_INT 1
114386: ST_TO_ADDR
// continue ;
114387: GO 112562
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114389: LD_VAR 0 26
114393: PUSH
114394: LD_VAR 0 4
114398: PUSH
114399: LD_VAR 0 7
114403: ARRAY
114404: PPUSH
114405: CALL_OW 257
114409: PUSH
114410: LD_INT 1
114412: EQUAL
114413: AND
114414: PUSH
114415: LD_VAR 0 4
114419: PUSH
114420: LD_VAR 0 7
114424: ARRAY
114425: PPUSH
114426: CALL_OW 256
114430: PUSH
114431: LD_INT 800
114433: LESS
114434: AND
114435: PUSH
114436: LD_VAR 0 4
114440: PUSH
114441: LD_VAR 0 7
114445: ARRAY
114446: PPUSH
114447: CALL_OW 318
114451: NOT
114452: AND
114453: IFFALSE 114470
// ComCrawl ( group [ i ] ) ;
114455: LD_VAR 0 4
114459: PUSH
114460: LD_VAR 0 7
114464: ARRAY
114465: PPUSH
114466: CALL_OW 137
// if f_mines then
114470: LD_VAR 0 21
114474: IFFALSE 114717
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114476: LD_VAR 0 14
114480: PUSH
114481: LD_INT 1
114483: ARRAY
114484: PPUSH
114485: CALL_OW 247
114489: PUSH
114490: LD_INT 3
114492: EQUAL
114493: PUSH
114494: LD_VAR 0 14
114498: PUSH
114499: LD_INT 1
114501: ARRAY
114502: PUSH
114503: LD_VAR 0 27
114507: IN
114508: NOT
114509: AND
114510: IFFALSE 114717
// begin x := GetX ( tmp [ 1 ] ) ;
114512: LD_ADDR_VAR 0 10
114516: PUSH
114517: LD_VAR 0 14
114521: PUSH
114522: LD_INT 1
114524: ARRAY
114525: PPUSH
114526: CALL_OW 250
114530: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114531: LD_ADDR_VAR 0 11
114535: PUSH
114536: LD_VAR 0 14
114540: PUSH
114541: LD_INT 1
114543: ARRAY
114544: PPUSH
114545: CALL_OW 251
114549: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114550: LD_ADDR_VAR 0 12
114554: PUSH
114555: LD_VAR 0 4
114559: PUSH
114560: LD_VAR 0 7
114564: ARRAY
114565: PPUSH
114566: CALL 52425 0 1
114570: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114571: LD_VAR 0 4
114575: PUSH
114576: LD_VAR 0 7
114580: ARRAY
114581: PPUSH
114582: LD_VAR 0 10
114586: PPUSH
114587: LD_VAR 0 11
114591: PPUSH
114592: LD_VAR 0 14
114596: PUSH
114597: LD_INT 1
114599: ARRAY
114600: PPUSH
114601: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114605: LD_VAR 0 4
114609: PUSH
114610: LD_VAR 0 7
114614: ARRAY
114615: PPUSH
114616: LD_VAR 0 10
114620: PPUSH
114621: LD_VAR 0 12
114625: PPUSH
114626: LD_INT 7
114628: PPUSH
114629: CALL_OW 272
114633: PPUSH
114634: LD_VAR 0 11
114638: PPUSH
114639: LD_VAR 0 12
114643: PPUSH
114644: LD_INT 7
114646: PPUSH
114647: CALL_OW 273
114651: PPUSH
114652: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114656: LD_VAR 0 4
114660: PUSH
114661: LD_VAR 0 7
114665: ARRAY
114666: PPUSH
114667: LD_INT 71
114669: PPUSH
114670: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114674: LD_ADDR_VAR 0 27
114678: PUSH
114679: LD_VAR 0 27
114683: PPUSH
114684: LD_VAR 0 27
114688: PUSH
114689: LD_INT 1
114691: PLUS
114692: PPUSH
114693: LD_VAR 0 14
114697: PUSH
114698: LD_INT 1
114700: ARRAY
114701: PPUSH
114702: CALL_OW 1
114706: ST_TO_ADDR
// attacking := true ;
114707: LD_ADDR_VAR 0 29
114711: PUSH
114712: LD_INT 1
114714: ST_TO_ADDR
// continue ;
114715: GO 112562
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114717: LD_VAR 0 4
114721: PUSH
114722: LD_VAR 0 7
114726: ARRAY
114727: PPUSH
114728: CALL_OW 257
114732: PUSH
114733: LD_INT 17
114735: EQUAL
114736: PUSH
114737: LD_VAR 0 4
114741: PUSH
114742: LD_VAR 0 7
114746: ARRAY
114747: PPUSH
114748: CALL_OW 110
114752: PUSH
114753: LD_INT 71
114755: EQUAL
114756: NOT
114757: AND
114758: IFFALSE 114904
// begin attacking := false ;
114760: LD_ADDR_VAR 0 29
114764: PUSH
114765: LD_INT 0
114767: ST_TO_ADDR
// k := 5 ;
114768: LD_ADDR_VAR 0 9
114772: PUSH
114773: LD_INT 5
114775: ST_TO_ADDR
// if tmp < k then
114776: LD_VAR 0 14
114780: PUSH
114781: LD_VAR 0 9
114785: LESS
114786: IFFALSE 114798
// k := tmp ;
114788: LD_ADDR_VAR 0 9
114792: PUSH
114793: LD_VAR 0 14
114797: ST_TO_ADDR
// for j = 1 to k do
114798: LD_ADDR_VAR 0 8
114802: PUSH
114803: DOUBLE
114804: LD_INT 1
114806: DEC
114807: ST_TO_ADDR
114808: LD_VAR 0 9
114812: PUSH
114813: FOR_TO
114814: IFFALSE 114902
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114816: LD_VAR 0 14
114820: PUSH
114821: LD_VAR 0 8
114825: ARRAY
114826: PUSH
114827: LD_VAR 0 14
114831: PPUSH
114832: LD_INT 58
114834: PUSH
114835: EMPTY
114836: LIST
114837: PPUSH
114838: CALL_OW 72
114842: IN
114843: NOT
114844: IFFALSE 114900
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114846: LD_VAR 0 4
114850: PUSH
114851: LD_VAR 0 7
114855: ARRAY
114856: PPUSH
114857: LD_VAR 0 14
114861: PUSH
114862: LD_VAR 0 8
114866: ARRAY
114867: PPUSH
114868: CALL_OW 115
// attacking := true ;
114872: LD_ADDR_VAR 0 29
114876: PUSH
114877: LD_INT 1
114879: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114880: LD_VAR 0 4
114884: PUSH
114885: LD_VAR 0 7
114889: ARRAY
114890: PPUSH
114891: LD_INT 71
114893: PPUSH
114894: CALL_OW 109
// continue ;
114898: GO 114813
// end ; end ;
114900: GO 114813
114902: POP
114903: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114904: LD_VAR 0 4
114908: PUSH
114909: LD_VAR 0 7
114913: ARRAY
114914: PPUSH
114915: CALL_OW 257
114919: PUSH
114920: LD_INT 8
114922: EQUAL
114923: PUSH
114924: LD_VAR 0 4
114928: PUSH
114929: LD_VAR 0 7
114933: ARRAY
114934: PPUSH
114935: CALL_OW 264
114939: PUSH
114940: LD_INT 28
114942: PUSH
114943: LD_INT 45
114945: PUSH
114946: LD_INT 7
114948: PUSH
114949: LD_INT 47
114951: PUSH
114952: EMPTY
114953: LIST
114954: LIST
114955: LIST
114956: LIST
114957: IN
114958: OR
114959: IFFALSE 115215
// begin attacking := false ;
114961: LD_ADDR_VAR 0 29
114965: PUSH
114966: LD_INT 0
114968: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114969: LD_VAR 0 14
114973: PUSH
114974: LD_INT 1
114976: ARRAY
114977: PPUSH
114978: CALL_OW 266
114982: PUSH
114983: LD_INT 32
114985: PUSH
114986: LD_INT 31
114988: PUSH
114989: LD_INT 33
114991: PUSH
114992: LD_INT 4
114994: PUSH
114995: LD_INT 5
114997: PUSH
114998: EMPTY
114999: LIST
115000: LIST
115001: LIST
115002: LIST
115003: LIST
115004: IN
115005: IFFALSE 115191
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115007: LD_ADDR_VAR 0 9
115011: PUSH
115012: LD_VAR 0 14
115016: PUSH
115017: LD_INT 1
115019: ARRAY
115020: PPUSH
115021: CALL_OW 266
115025: PPUSH
115026: LD_VAR 0 14
115030: PUSH
115031: LD_INT 1
115033: ARRAY
115034: PPUSH
115035: CALL_OW 250
115039: PPUSH
115040: LD_VAR 0 14
115044: PUSH
115045: LD_INT 1
115047: ARRAY
115048: PPUSH
115049: CALL_OW 251
115053: PPUSH
115054: LD_VAR 0 14
115058: PUSH
115059: LD_INT 1
115061: ARRAY
115062: PPUSH
115063: CALL_OW 254
115067: PPUSH
115068: LD_VAR 0 14
115072: PUSH
115073: LD_INT 1
115075: ARRAY
115076: PPUSH
115077: CALL_OW 248
115081: PPUSH
115082: LD_INT 0
115084: PPUSH
115085: CALL 33795 0 6
115089: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115090: LD_ADDR_VAR 0 8
115094: PUSH
115095: LD_VAR 0 4
115099: PUSH
115100: LD_VAR 0 7
115104: ARRAY
115105: PPUSH
115106: LD_VAR 0 9
115110: PPUSH
115111: CALL 52538 0 2
115115: ST_TO_ADDR
// if j then
115116: LD_VAR 0 8
115120: IFFALSE 115189
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115122: LD_VAR 0 8
115126: PUSH
115127: LD_INT 1
115129: ARRAY
115130: PPUSH
115131: LD_VAR 0 8
115135: PUSH
115136: LD_INT 2
115138: ARRAY
115139: PPUSH
115140: CALL_OW 488
115144: IFFALSE 115189
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115146: LD_VAR 0 4
115150: PUSH
115151: LD_VAR 0 7
115155: ARRAY
115156: PPUSH
115157: LD_VAR 0 8
115161: PUSH
115162: LD_INT 1
115164: ARRAY
115165: PPUSH
115166: LD_VAR 0 8
115170: PUSH
115171: LD_INT 2
115173: ARRAY
115174: PPUSH
115175: CALL_OW 116
// attacking := true ;
115179: LD_ADDR_VAR 0 29
115183: PUSH
115184: LD_INT 1
115186: ST_TO_ADDR
// continue ;
115187: GO 112562
// end ; end else
115189: GO 115215
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115191: LD_VAR 0 4
115195: PUSH
115196: LD_VAR 0 7
115200: ARRAY
115201: PPUSH
115202: LD_VAR 0 14
115206: PUSH
115207: LD_INT 1
115209: ARRAY
115210: PPUSH
115211: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115215: LD_VAR 0 4
115219: PUSH
115220: LD_VAR 0 7
115224: ARRAY
115225: PPUSH
115226: CALL_OW 265
115230: PUSH
115231: LD_INT 11
115233: EQUAL
115234: IFFALSE 115512
// begin k := 10 ;
115236: LD_ADDR_VAR 0 9
115240: PUSH
115241: LD_INT 10
115243: ST_TO_ADDR
// x := 0 ;
115244: LD_ADDR_VAR 0 10
115248: PUSH
115249: LD_INT 0
115251: ST_TO_ADDR
// if tmp < k then
115252: LD_VAR 0 14
115256: PUSH
115257: LD_VAR 0 9
115261: LESS
115262: IFFALSE 115274
// k := tmp ;
115264: LD_ADDR_VAR 0 9
115268: PUSH
115269: LD_VAR 0 14
115273: ST_TO_ADDR
// for j = k downto 1 do
115274: LD_ADDR_VAR 0 8
115278: PUSH
115279: DOUBLE
115280: LD_VAR 0 9
115284: INC
115285: ST_TO_ADDR
115286: LD_INT 1
115288: PUSH
115289: FOR_DOWNTO
115290: IFFALSE 115365
// begin if GetType ( tmp [ j ] ) = unit_human then
115292: LD_VAR 0 14
115296: PUSH
115297: LD_VAR 0 8
115301: ARRAY
115302: PPUSH
115303: CALL_OW 247
115307: PUSH
115308: LD_INT 1
115310: EQUAL
115311: IFFALSE 115363
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115313: LD_VAR 0 4
115317: PUSH
115318: LD_VAR 0 7
115322: ARRAY
115323: PPUSH
115324: LD_VAR 0 14
115328: PUSH
115329: LD_VAR 0 8
115333: ARRAY
115334: PPUSH
115335: CALL 52792 0 2
// x := tmp [ j ] ;
115339: LD_ADDR_VAR 0 10
115343: PUSH
115344: LD_VAR 0 14
115348: PUSH
115349: LD_VAR 0 8
115353: ARRAY
115354: ST_TO_ADDR
// attacking := true ;
115355: LD_ADDR_VAR 0 29
115359: PUSH
115360: LD_INT 1
115362: ST_TO_ADDR
// end ; end ;
115363: GO 115289
115365: POP
115366: POP
// if not x then
115367: LD_VAR 0 10
115371: NOT
115372: IFFALSE 115512
// begin attacking := true ;
115374: LD_ADDR_VAR 0 29
115378: PUSH
115379: LD_INT 1
115381: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115382: LD_VAR 0 4
115386: PUSH
115387: LD_VAR 0 7
115391: ARRAY
115392: PPUSH
115393: CALL_OW 250
115397: PPUSH
115398: LD_VAR 0 4
115402: PUSH
115403: LD_VAR 0 7
115407: ARRAY
115408: PPUSH
115409: CALL_OW 251
115413: PPUSH
115414: CALL_OW 546
115418: PUSH
115419: LD_INT 2
115421: ARRAY
115422: PUSH
115423: LD_VAR 0 14
115427: PUSH
115428: LD_INT 1
115430: ARRAY
115431: PPUSH
115432: CALL_OW 250
115436: PPUSH
115437: LD_VAR 0 14
115441: PUSH
115442: LD_INT 1
115444: ARRAY
115445: PPUSH
115446: CALL_OW 251
115450: PPUSH
115451: CALL_OW 546
115455: PUSH
115456: LD_INT 2
115458: ARRAY
115459: EQUAL
115460: IFFALSE 115488
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115462: LD_VAR 0 4
115466: PUSH
115467: LD_VAR 0 7
115471: ARRAY
115472: PPUSH
115473: LD_VAR 0 14
115477: PUSH
115478: LD_INT 1
115480: ARRAY
115481: PPUSH
115482: CALL 52792 0 2
115486: GO 115512
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115488: LD_VAR 0 4
115492: PUSH
115493: LD_VAR 0 7
115497: ARRAY
115498: PPUSH
115499: LD_VAR 0 14
115503: PUSH
115504: LD_INT 1
115506: ARRAY
115507: PPUSH
115508: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115512: LD_VAR 0 4
115516: PUSH
115517: LD_VAR 0 7
115521: ARRAY
115522: PPUSH
115523: CALL_OW 264
115527: PUSH
115528: LD_INT 29
115530: EQUAL
115531: IFFALSE 115897
// begin if WantsToAttack ( group [ i ] ) in bombed then
115533: LD_VAR 0 4
115537: PUSH
115538: LD_VAR 0 7
115542: ARRAY
115543: PPUSH
115544: CALL_OW 319
115548: PUSH
115549: LD_VAR 0 28
115553: IN
115554: IFFALSE 115558
// continue ;
115556: GO 112562
// k := 8 ;
115558: LD_ADDR_VAR 0 9
115562: PUSH
115563: LD_INT 8
115565: ST_TO_ADDR
// x := 0 ;
115566: LD_ADDR_VAR 0 10
115570: PUSH
115571: LD_INT 0
115573: ST_TO_ADDR
// if tmp < k then
115574: LD_VAR 0 14
115578: PUSH
115579: LD_VAR 0 9
115583: LESS
115584: IFFALSE 115596
// k := tmp ;
115586: LD_ADDR_VAR 0 9
115590: PUSH
115591: LD_VAR 0 14
115595: ST_TO_ADDR
// for j = 1 to k do
115596: LD_ADDR_VAR 0 8
115600: PUSH
115601: DOUBLE
115602: LD_INT 1
115604: DEC
115605: ST_TO_ADDR
115606: LD_VAR 0 9
115610: PUSH
115611: FOR_TO
115612: IFFALSE 115744
// begin if GetType ( tmp [ j ] ) = unit_building then
115614: LD_VAR 0 14
115618: PUSH
115619: LD_VAR 0 8
115623: ARRAY
115624: PPUSH
115625: CALL_OW 247
115629: PUSH
115630: LD_INT 3
115632: EQUAL
115633: IFFALSE 115742
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115635: LD_VAR 0 14
115639: PUSH
115640: LD_VAR 0 8
115644: ARRAY
115645: PUSH
115646: LD_VAR 0 28
115650: IN
115651: NOT
115652: PUSH
115653: LD_VAR 0 14
115657: PUSH
115658: LD_VAR 0 8
115662: ARRAY
115663: PPUSH
115664: CALL_OW 313
115668: AND
115669: IFFALSE 115742
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115671: LD_VAR 0 4
115675: PUSH
115676: LD_VAR 0 7
115680: ARRAY
115681: PPUSH
115682: LD_VAR 0 14
115686: PUSH
115687: LD_VAR 0 8
115691: ARRAY
115692: PPUSH
115693: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115697: LD_ADDR_VAR 0 28
115701: PUSH
115702: LD_VAR 0 28
115706: PPUSH
115707: LD_VAR 0 28
115711: PUSH
115712: LD_INT 1
115714: PLUS
115715: PPUSH
115716: LD_VAR 0 14
115720: PUSH
115721: LD_VAR 0 8
115725: ARRAY
115726: PPUSH
115727: CALL_OW 1
115731: ST_TO_ADDR
// attacking := true ;
115732: LD_ADDR_VAR 0 29
115736: PUSH
115737: LD_INT 1
115739: ST_TO_ADDR
// break ;
115740: GO 115744
// end ; end ;
115742: GO 115611
115744: POP
115745: POP
// if not attacking and f_attack_depot then
115746: LD_VAR 0 29
115750: NOT
115751: PUSH
115752: LD_VAR 0 25
115756: AND
115757: IFFALSE 115852
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115759: LD_ADDR_VAR 0 13
115763: PUSH
115764: LD_VAR 0 14
115768: PPUSH
115769: LD_INT 2
115771: PUSH
115772: LD_INT 30
115774: PUSH
115775: LD_INT 0
115777: PUSH
115778: EMPTY
115779: LIST
115780: LIST
115781: PUSH
115782: LD_INT 30
115784: PUSH
115785: LD_INT 1
115787: PUSH
115788: EMPTY
115789: LIST
115790: LIST
115791: PUSH
115792: EMPTY
115793: LIST
115794: LIST
115795: LIST
115796: PPUSH
115797: CALL_OW 72
115801: ST_TO_ADDR
// if z then
115802: LD_VAR 0 13
115806: IFFALSE 115852
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115808: LD_VAR 0 4
115812: PUSH
115813: LD_VAR 0 7
115817: ARRAY
115818: PPUSH
115819: LD_VAR 0 13
115823: PPUSH
115824: LD_VAR 0 4
115828: PUSH
115829: LD_VAR 0 7
115833: ARRAY
115834: PPUSH
115835: CALL_OW 74
115839: PPUSH
115840: CALL_OW 115
// attacking := true ;
115844: LD_ADDR_VAR 0 29
115848: PUSH
115849: LD_INT 1
115851: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115852: LD_VAR 0 4
115856: PUSH
115857: LD_VAR 0 7
115861: ARRAY
115862: PPUSH
115863: CALL_OW 256
115867: PUSH
115868: LD_INT 500
115870: LESS
115871: IFFALSE 115897
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115873: LD_VAR 0 4
115877: PUSH
115878: LD_VAR 0 7
115882: ARRAY
115883: PPUSH
115884: LD_VAR 0 14
115888: PUSH
115889: LD_INT 1
115891: ARRAY
115892: PPUSH
115893: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115897: LD_VAR 0 4
115901: PUSH
115902: LD_VAR 0 7
115906: ARRAY
115907: PPUSH
115908: CALL_OW 264
115912: PUSH
115913: LD_INT 49
115915: EQUAL
115916: IFFALSE 116037
// begin if not HasTask ( group [ i ] ) then
115918: LD_VAR 0 4
115922: PUSH
115923: LD_VAR 0 7
115927: ARRAY
115928: PPUSH
115929: CALL_OW 314
115933: NOT
115934: IFFALSE 116037
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115936: LD_ADDR_VAR 0 9
115940: PUSH
115941: LD_INT 81
115943: PUSH
115944: LD_VAR 0 4
115948: PUSH
115949: LD_VAR 0 7
115953: ARRAY
115954: PPUSH
115955: CALL_OW 255
115959: PUSH
115960: EMPTY
115961: LIST
115962: LIST
115963: PPUSH
115964: CALL_OW 69
115968: PPUSH
115969: LD_VAR 0 4
115973: PUSH
115974: LD_VAR 0 7
115978: ARRAY
115979: PPUSH
115980: CALL_OW 74
115984: ST_TO_ADDR
// if k then
115985: LD_VAR 0 9
115989: IFFALSE 116037
// if GetDistUnits ( group [ i ] , k ) > 10 then
115991: LD_VAR 0 4
115995: PUSH
115996: LD_VAR 0 7
116000: ARRAY
116001: PPUSH
116002: LD_VAR 0 9
116006: PPUSH
116007: CALL_OW 296
116011: PUSH
116012: LD_INT 10
116014: GREATER
116015: IFFALSE 116037
// ComMoveUnit ( group [ i ] , k ) ;
116017: LD_VAR 0 4
116021: PUSH
116022: LD_VAR 0 7
116026: ARRAY
116027: PPUSH
116028: LD_VAR 0 9
116032: PPUSH
116033: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116037: LD_VAR 0 4
116041: PUSH
116042: LD_VAR 0 7
116046: ARRAY
116047: PPUSH
116048: CALL_OW 256
116052: PUSH
116053: LD_INT 250
116055: LESS
116056: PUSH
116057: LD_VAR 0 4
116061: PUSH
116062: LD_VAR 0 7
116066: ARRAY
116067: PUSH
116068: LD_INT 21
116070: PUSH
116071: LD_INT 2
116073: PUSH
116074: EMPTY
116075: LIST
116076: LIST
116077: PUSH
116078: LD_INT 23
116080: PUSH
116081: LD_INT 2
116083: PUSH
116084: EMPTY
116085: LIST
116086: LIST
116087: PUSH
116088: EMPTY
116089: LIST
116090: LIST
116091: PPUSH
116092: CALL_OW 69
116096: IN
116097: AND
116098: IFFALSE 116223
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116100: LD_ADDR_VAR 0 9
116104: PUSH
116105: LD_OWVAR 3
116109: PUSH
116110: LD_VAR 0 4
116114: PUSH
116115: LD_VAR 0 7
116119: ARRAY
116120: DIFF
116121: PPUSH
116122: LD_VAR 0 4
116126: PUSH
116127: LD_VAR 0 7
116131: ARRAY
116132: PPUSH
116133: CALL_OW 74
116137: ST_TO_ADDR
// if not k then
116138: LD_VAR 0 9
116142: NOT
116143: IFFALSE 116147
// continue ;
116145: GO 112562
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116147: LD_VAR 0 9
116151: PUSH
116152: LD_INT 81
116154: PUSH
116155: LD_VAR 0 4
116159: PUSH
116160: LD_VAR 0 7
116164: ARRAY
116165: PPUSH
116166: CALL_OW 255
116170: PUSH
116171: EMPTY
116172: LIST
116173: LIST
116174: PPUSH
116175: CALL_OW 69
116179: IN
116180: PUSH
116181: LD_VAR 0 9
116185: PPUSH
116186: LD_VAR 0 4
116190: PUSH
116191: LD_VAR 0 7
116195: ARRAY
116196: PPUSH
116197: CALL_OW 296
116201: PUSH
116202: LD_INT 5
116204: LESS
116205: AND
116206: IFFALSE 116223
// ComAutodestruct ( group [ i ] ) ;
116208: LD_VAR 0 4
116212: PUSH
116213: LD_VAR 0 7
116217: ARRAY
116218: PPUSH
116219: CALL 52690 0 1
// end ; if f_attack_depot then
116223: LD_VAR 0 25
116227: IFFALSE 116339
// begin k := 6 ;
116229: LD_ADDR_VAR 0 9
116233: PUSH
116234: LD_INT 6
116236: ST_TO_ADDR
// if tmp < k then
116237: LD_VAR 0 14
116241: PUSH
116242: LD_VAR 0 9
116246: LESS
116247: IFFALSE 116259
// k := tmp ;
116249: LD_ADDR_VAR 0 9
116253: PUSH
116254: LD_VAR 0 14
116258: ST_TO_ADDR
// for j = 1 to k do
116259: LD_ADDR_VAR 0 8
116263: PUSH
116264: DOUBLE
116265: LD_INT 1
116267: DEC
116268: ST_TO_ADDR
116269: LD_VAR 0 9
116273: PUSH
116274: FOR_TO
116275: IFFALSE 116337
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116277: LD_VAR 0 8
116281: PPUSH
116282: CALL_OW 266
116286: PUSH
116287: LD_INT 0
116289: PUSH
116290: LD_INT 1
116292: PUSH
116293: EMPTY
116294: LIST
116295: LIST
116296: IN
116297: IFFALSE 116335
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116299: LD_VAR 0 4
116303: PUSH
116304: LD_VAR 0 7
116308: ARRAY
116309: PPUSH
116310: LD_VAR 0 14
116314: PUSH
116315: LD_VAR 0 8
116319: ARRAY
116320: PPUSH
116321: CALL_OW 115
// attacking := true ;
116325: LD_ADDR_VAR 0 29
116329: PUSH
116330: LD_INT 1
116332: ST_TO_ADDR
// break ;
116333: GO 116337
// end ;
116335: GO 116274
116337: POP
116338: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116339: LD_VAR 0 4
116343: PUSH
116344: LD_VAR 0 7
116348: ARRAY
116349: PPUSH
116350: CALL_OW 302
116354: PUSH
116355: LD_VAR 0 29
116359: NOT
116360: AND
116361: IFFALSE 116683
// begin if GetTag ( group [ i ] ) = 71 then
116363: LD_VAR 0 4
116367: PUSH
116368: LD_VAR 0 7
116372: ARRAY
116373: PPUSH
116374: CALL_OW 110
116378: PUSH
116379: LD_INT 71
116381: EQUAL
116382: IFFALSE 116423
// begin if HasTask ( group [ i ] ) then
116384: LD_VAR 0 4
116388: PUSH
116389: LD_VAR 0 7
116393: ARRAY
116394: PPUSH
116395: CALL_OW 314
116399: IFFALSE 116405
// continue else
116401: GO 112562
116403: GO 116423
// SetTag ( group [ i ] , 0 ) ;
116405: LD_VAR 0 4
116409: PUSH
116410: LD_VAR 0 7
116414: ARRAY
116415: PPUSH
116416: LD_INT 0
116418: PPUSH
116419: CALL_OW 109
// end ; k := 8 ;
116423: LD_ADDR_VAR 0 9
116427: PUSH
116428: LD_INT 8
116430: ST_TO_ADDR
// x := 0 ;
116431: LD_ADDR_VAR 0 10
116435: PUSH
116436: LD_INT 0
116438: ST_TO_ADDR
// if tmp < k then
116439: LD_VAR 0 14
116443: PUSH
116444: LD_VAR 0 9
116448: LESS
116449: IFFALSE 116461
// k := tmp ;
116451: LD_ADDR_VAR 0 9
116455: PUSH
116456: LD_VAR 0 14
116460: ST_TO_ADDR
// for j = 1 to k do
116461: LD_ADDR_VAR 0 8
116465: PUSH
116466: DOUBLE
116467: LD_INT 1
116469: DEC
116470: ST_TO_ADDR
116471: LD_VAR 0 9
116475: PUSH
116476: FOR_TO
116477: IFFALSE 116575
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116479: LD_VAR 0 14
116483: PUSH
116484: LD_VAR 0 8
116488: ARRAY
116489: PPUSH
116490: CALL_OW 247
116494: PUSH
116495: LD_INT 1
116497: EQUAL
116498: PUSH
116499: LD_VAR 0 14
116503: PUSH
116504: LD_VAR 0 8
116508: ARRAY
116509: PPUSH
116510: CALL_OW 256
116514: PUSH
116515: LD_INT 250
116517: LESS
116518: PUSH
116519: LD_VAR 0 20
116523: AND
116524: PUSH
116525: LD_VAR 0 20
116529: NOT
116530: PUSH
116531: LD_VAR 0 14
116535: PUSH
116536: LD_VAR 0 8
116540: ARRAY
116541: PPUSH
116542: CALL_OW 256
116546: PUSH
116547: LD_INT 250
116549: GREATEREQUAL
116550: AND
116551: OR
116552: AND
116553: IFFALSE 116573
// begin x := tmp [ j ] ;
116555: LD_ADDR_VAR 0 10
116559: PUSH
116560: LD_VAR 0 14
116564: PUSH
116565: LD_VAR 0 8
116569: ARRAY
116570: ST_TO_ADDR
// break ;
116571: GO 116575
// end ;
116573: GO 116476
116575: POP
116576: POP
// if x then
116577: LD_VAR 0 10
116581: IFFALSE 116605
// ComAttackUnit ( group [ i ] , x ) else
116583: LD_VAR 0 4
116587: PUSH
116588: LD_VAR 0 7
116592: ARRAY
116593: PPUSH
116594: LD_VAR 0 10
116598: PPUSH
116599: CALL_OW 115
116603: GO 116629
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116605: LD_VAR 0 4
116609: PUSH
116610: LD_VAR 0 7
116614: ARRAY
116615: PPUSH
116616: LD_VAR 0 14
116620: PUSH
116621: LD_INT 1
116623: ARRAY
116624: PPUSH
116625: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116629: LD_VAR 0 4
116633: PUSH
116634: LD_VAR 0 7
116638: ARRAY
116639: PPUSH
116640: CALL_OW 314
116644: NOT
116645: IFFALSE 116683
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116647: LD_VAR 0 4
116651: PUSH
116652: LD_VAR 0 7
116656: ARRAY
116657: PPUSH
116658: LD_VAR 0 14
116662: PPUSH
116663: LD_VAR 0 4
116667: PUSH
116668: LD_VAR 0 7
116672: ARRAY
116673: PPUSH
116674: CALL_OW 74
116678: PPUSH
116679: CALL_OW 115
// end ; end ; end ;
116683: GO 112562
116685: POP
116686: POP
// wait ( 0 0$2 ) ;
116687: LD_INT 70
116689: PPUSH
116690: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116694: LD_VAR 0 4
116698: NOT
116699: PUSH
116700: LD_VAR 0 4
116704: PUSH
116705: EMPTY
116706: EQUAL
116707: OR
116708: PUSH
116709: LD_INT 81
116711: PUSH
116712: LD_VAR 0 35
116716: PUSH
116717: EMPTY
116718: LIST
116719: LIST
116720: PPUSH
116721: CALL_OW 69
116725: NOT
116726: OR
116727: IFFALSE 112547
// end ;
116729: LD_VAR 0 2
116733: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116734: LD_INT 0
116736: PPUSH
116737: PPUSH
116738: PPUSH
116739: PPUSH
116740: PPUSH
116741: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116742: LD_VAR 0 1
116746: NOT
116747: PUSH
116748: LD_EXP 31
116752: PUSH
116753: LD_VAR 0 1
116757: ARRAY
116758: NOT
116759: OR
116760: PUSH
116761: LD_VAR 0 2
116765: NOT
116766: OR
116767: IFFALSE 116771
// exit ;
116769: GO 117325
// side := mc_sides [ base ] ;
116771: LD_ADDR_VAR 0 6
116775: PUSH
116776: LD_EXP 57
116780: PUSH
116781: LD_VAR 0 1
116785: ARRAY
116786: ST_TO_ADDR
// if not side then
116787: LD_VAR 0 6
116791: NOT
116792: IFFALSE 116796
// exit ;
116794: GO 117325
// for i in solds do
116796: LD_ADDR_VAR 0 7
116800: PUSH
116801: LD_VAR 0 2
116805: PUSH
116806: FOR_IN
116807: IFFALSE 116868
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116809: LD_VAR 0 7
116813: PPUSH
116814: CALL_OW 310
116818: PPUSH
116819: CALL_OW 266
116823: PUSH
116824: LD_INT 32
116826: PUSH
116827: LD_INT 31
116829: PUSH
116830: EMPTY
116831: LIST
116832: LIST
116833: IN
116834: IFFALSE 116854
// solds := solds diff i else
116836: LD_ADDR_VAR 0 2
116840: PUSH
116841: LD_VAR 0 2
116845: PUSH
116846: LD_VAR 0 7
116850: DIFF
116851: ST_TO_ADDR
116852: GO 116866
// SetTag ( i , 18 ) ;
116854: LD_VAR 0 7
116858: PPUSH
116859: LD_INT 18
116861: PPUSH
116862: CALL_OW 109
116866: GO 116806
116868: POP
116869: POP
// if not solds then
116870: LD_VAR 0 2
116874: NOT
116875: IFFALSE 116879
// exit ;
116877: GO 117325
// repeat wait ( 0 0$2 ) ;
116879: LD_INT 70
116881: PPUSH
116882: CALL_OW 67
// enemy := mc_scan [ base ] ;
116886: LD_ADDR_VAR 0 4
116890: PUSH
116891: LD_EXP 54
116895: PUSH
116896: LD_VAR 0 1
116900: ARRAY
116901: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116902: LD_EXP 31
116906: PUSH
116907: LD_VAR 0 1
116911: ARRAY
116912: NOT
116913: PUSH
116914: LD_EXP 31
116918: PUSH
116919: LD_VAR 0 1
116923: ARRAY
116924: PUSH
116925: EMPTY
116926: EQUAL
116927: OR
116928: IFFALSE 116965
// begin for i in solds do
116930: LD_ADDR_VAR 0 7
116934: PUSH
116935: LD_VAR 0 2
116939: PUSH
116940: FOR_IN
116941: IFFALSE 116954
// ComStop ( i ) ;
116943: LD_VAR 0 7
116947: PPUSH
116948: CALL_OW 141
116952: GO 116940
116954: POP
116955: POP
// solds := [ ] ;
116956: LD_ADDR_VAR 0 2
116960: PUSH
116961: EMPTY
116962: ST_TO_ADDR
// exit ;
116963: GO 117325
// end ; for i in solds do
116965: LD_ADDR_VAR 0 7
116969: PUSH
116970: LD_VAR 0 2
116974: PUSH
116975: FOR_IN
116976: IFFALSE 117297
// begin if IsInUnit ( i ) then
116978: LD_VAR 0 7
116982: PPUSH
116983: CALL_OW 310
116987: IFFALSE 116998
// ComExitBuilding ( i ) ;
116989: LD_VAR 0 7
116993: PPUSH
116994: CALL_OW 122
// if GetLives ( i ) > 500 then
116998: LD_VAR 0 7
117002: PPUSH
117003: CALL_OW 256
117007: PUSH
117008: LD_INT 500
117010: GREATER
117011: IFFALSE 117064
// begin e := NearestUnitToUnit ( enemy , i ) ;
117013: LD_ADDR_VAR 0 5
117017: PUSH
117018: LD_VAR 0 4
117022: PPUSH
117023: LD_VAR 0 7
117027: PPUSH
117028: CALL_OW 74
117032: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117033: LD_VAR 0 7
117037: PPUSH
117038: LD_VAR 0 5
117042: PPUSH
117043: CALL_OW 250
117047: PPUSH
117048: LD_VAR 0 5
117052: PPUSH
117053: CALL_OW 251
117057: PPUSH
117058: CALL_OW 114
// end else
117062: GO 117295
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
117064: LD_VAR 0 7
117068: PPUSH
117069: LD_EXP 31
117073: PUSH
117074: LD_VAR 0 1
117078: ARRAY
117079: PPUSH
117080: LD_INT 2
117082: PUSH
117083: LD_INT 30
117085: PUSH
117086: LD_INT 0
117088: PUSH
117089: EMPTY
117090: LIST
117091: LIST
117092: PUSH
117093: LD_INT 30
117095: PUSH
117096: LD_INT 1
117098: PUSH
117099: EMPTY
117100: LIST
117101: LIST
117102: PUSH
117103: LD_INT 30
117105: PUSH
117106: LD_INT 6
117108: PUSH
117109: EMPTY
117110: LIST
117111: LIST
117112: PUSH
117113: EMPTY
117114: LIST
117115: LIST
117116: LIST
117117: LIST
117118: PPUSH
117119: CALL_OW 72
117123: PPUSH
117124: LD_VAR 0 7
117128: PPUSH
117129: CALL_OW 74
117133: PPUSH
117134: CALL_OW 296
117138: PUSH
117139: LD_INT 10
117141: GREATER
117142: IFFALSE 117295
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117144: LD_ADDR_VAR 0 8
117148: PUSH
117149: LD_EXP 31
117153: PUSH
117154: LD_VAR 0 1
117158: ARRAY
117159: PPUSH
117160: LD_INT 2
117162: PUSH
117163: LD_INT 30
117165: PUSH
117166: LD_INT 0
117168: PUSH
117169: EMPTY
117170: LIST
117171: LIST
117172: PUSH
117173: LD_INT 30
117175: PUSH
117176: LD_INT 1
117178: PUSH
117179: EMPTY
117180: LIST
117181: LIST
117182: PUSH
117183: LD_INT 30
117185: PUSH
117186: LD_INT 6
117188: PUSH
117189: EMPTY
117190: LIST
117191: LIST
117192: PUSH
117193: EMPTY
117194: LIST
117195: LIST
117196: LIST
117197: LIST
117198: PPUSH
117199: CALL_OW 72
117203: PPUSH
117204: LD_VAR 0 7
117208: PPUSH
117209: CALL_OW 74
117213: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117214: LD_VAR 0 7
117218: PPUSH
117219: LD_VAR 0 8
117223: PPUSH
117224: CALL_OW 250
117228: PPUSH
117229: LD_INT 3
117231: PPUSH
117232: LD_INT 5
117234: PPUSH
117235: CALL_OW 272
117239: PPUSH
117240: LD_VAR 0 8
117244: PPUSH
117245: CALL_OW 251
117249: PPUSH
117250: LD_INT 3
117252: PPUSH
117253: LD_INT 5
117255: PPUSH
117256: CALL_OW 273
117260: PPUSH
117261: CALL_OW 111
// SetTag ( i , 0 ) ;
117265: LD_VAR 0 7
117269: PPUSH
117270: LD_INT 0
117272: PPUSH
117273: CALL_OW 109
// solds := solds diff i ;
117277: LD_ADDR_VAR 0 2
117281: PUSH
117282: LD_VAR 0 2
117286: PUSH
117287: LD_VAR 0 7
117291: DIFF
117292: ST_TO_ADDR
// continue ;
117293: GO 116975
// end ; end ;
117295: GO 116975
117297: POP
117298: POP
// until not solds or not enemy ;
117299: LD_VAR 0 2
117303: NOT
117304: PUSH
117305: LD_VAR 0 4
117309: NOT
117310: OR
117311: IFFALSE 116879
// MC_Reset ( base , 18 ) ;
117313: LD_VAR 0 1
117317: PPUSH
117318: LD_INT 18
117320: PPUSH
117321: CALL 65417 0 2
// end ;
117325: LD_VAR 0 3
117329: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117330: LD_INT 0
117332: PPUSH
117333: PPUSH
117334: PPUSH
117335: PPUSH
117336: PPUSH
117337: PPUSH
117338: PPUSH
117339: PPUSH
117340: PPUSH
117341: PPUSH
117342: PPUSH
117343: PPUSH
117344: PPUSH
117345: PPUSH
117346: PPUSH
117347: PPUSH
117348: PPUSH
117349: PPUSH
117350: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117351: LD_ADDR_VAR 0 12
117355: PUSH
117356: LD_EXP 31
117360: PUSH
117361: LD_VAR 0 1
117365: ARRAY
117366: PPUSH
117367: LD_INT 25
117369: PUSH
117370: LD_INT 3
117372: PUSH
117373: EMPTY
117374: LIST
117375: LIST
117376: PPUSH
117377: CALL_OW 72
117381: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117382: LD_EXP 71
117386: PUSH
117387: LD_VAR 0 1
117391: ARRAY
117392: IFFALSE 117416
// mechs := mechs diff mc_remote_driver [ base ] ;
117394: LD_ADDR_VAR 0 12
117398: PUSH
117399: LD_VAR 0 12
117403: PUSH
117404: LD_EXP 71
117408: PUSH
117409: LD_VAR 0 1
117413: ARRAY
117414: DIFF
117415: ST_TO_ADDR
// for i in mechs do
117416: LD_ADDR_VAR 0 4
117420: PUSH
117421: LD_VAR 0 12
117425: PUSH
117426: FOR_IN
117427: IFFALSE 117462
// if GetTag ( i ) > 0 then
117429: LD_VAR 0 4
117433: PPUSH
117434: CALL_OW 110
117438: PUSH
117439: LD_INT 0
117441: GREATER
117442: IFFALSE 117460
// mechs := mechs diff i ;
117444: LD_ADDR_VAR 0 12
117448: PUSH
117449: LD_VAR 0 12
117453: PUSH
117454: LD_VAR 0 4
117458: DIFF
117459: ST_TO_ADDR
117460: GO 117426
117462: POP
117463: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117464: LD_ADDR_VAR 0 8
117468: PUSH
117469: LD_EXP 31
117473: PUSH
117474: LD_VAR 0 1
117478: ARRAY
117479: PPUSH
117480: LD_INT 2
117482: PUSH
117483: LD_INT 25
117485: PUSH
117486: LD_INT 1
117488: PUSH
117489: EMPTY
117490: LIST
117491: LIST
117492: PUSH
117493: LD_INT 25
117495: PUSH
117496: LD_INT 5
117498: PUSH
117499: EMPTY
117500: LIST
117501: LIST
117502: PUSH
117503: LD_INT 25
117505: PUSH
117506: LD_INT 8
117508: PUSH
117509: EMPTY
117510: LIST
117511: LIST
117512: PUSH
117513: LD_INT 25
117515: PUSH
117516: LD_INT 9
117518: PUSH
117519: EMPTY
117520: LIST
117521: LIST
117522: PUSH
117523: EMPTY
117524: LIST
117525: LIST
117526: LIST
117527: LIST
117528: LIST
117529: PPUSH
117530: CALL_OW 72
117534: ST_TO_ADDR
// if not defenders and not solds then
117535: LD_VAR 0 2
117539: NOT
117540: PUSH
117541: LD_VAR 0 8
117545: NOT
117546: AND
117547: IFFALSE 117551
// exit ;
117549: GO 119321
// depot_under_attack := false ;
117551: LD_ADDR_VAR 0 16
117555: PUSH
117556: LD_INT 0
117558: ST_TO_ADDR
// sold_defenders := [ ] ;
117559: LD_ADDR_VAR 0 17
117563: PUSH
117564: EMPTY
117565: ST_TO_ADDR
// if mechs then
117566: LD_VAR 0 12
117570: IFFALSE 117723
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117572: LD_ADDR_VAR 0 4
117576: PUSH
117577: LD_VAR 0 2
117581: PPUSH
117582: LD_INT 21
117584: PUSH
117585: LD_INT 2
117587: PUSH
117588: EMPTY
117589: LIST
117590: LIST
117591: PPUSH
117592: CALL_OW 72
117596: PUSH
117597: FOR_IN
117598: IFFALSE 117721
// begin if GetTag ( i ) <> 20 then
117600: LD_VAR 0 4
117604: PPUSH
117605: CALL_OW 110
117609: PUSH
117610: LD_INT 20
117612: NONEQUAL
117613: IFFALSE 117627
// SetTag ( i , 20 ) ;
117615: LD_VAR 0 4
117619: PPUSH
117620: LD_INT 20
117622: PPUSH
117623: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117627: LD_VAR 0 4
117631: PPUSH
117632: CALL_OW 263
117636: PUSH
117637: LD_INT 1
117639: EQUAL
117640: PUSH
117641: LD_VAR 0 4
117645: PPUSH
117646: CALL_OW 311
117650: NOT
117651: AND
117652: IFFALSE 117719
// begin un := mechs [ 1 ] ;
117654: LD_ADDR_VAR 0 10
117658: PUSH
117659: LD_VAR 0 12
117663: PUSH
117664: LD_INT 1
117666: ARRAY
117667: ST_TO_ADDR
// ComExit ( un ) ;
117668: LD_VAR 0 10
117672: PPUSH
117673: CALL 57574 0 1
// AddComEnterUnit ( un , i ) ;
117677: LD_VAR 0 10
117681: PPUSH
117682: LD_VAR 0 4
117686: PPUSH
117687: CALL_OW 180
// SetTag ( un , 19 ) ;
117691: LD_VAR 0 10
117695: PPUSH
117696: LD_INT 19
117698: PPUSH
117699: CALL_OW 109
// mechs := mechs diff un ;
117703: LD_ADDR_VAR 0 12
117707: PUSH
117708: LD_VAR 0 12
117712: PUSH
117713: LD_VAR 0 10
117717: DIFF
117718: ST_TO_ADDR
// end ; end ;
117719: GO 117597
117721: POP
117722: POP
// if solds then
117723: LD_VAR 0 8
117727: IFFALSE 117786
// for i in solds do
117729: LD_ADDR_VAR 0 4
117733: PUSH
117734: LD_VAR 0 8
117738: PUSH
117739: FOR_IN
117740: IFFALSE 117784
// if not GetTag ( i ) then
117742: LD_VAR 0 4
117746: PPUSH
117747: CALL_OW 110
117751: NOT
117752: IFFALSE 117782
// begin defenders := defenders union i ;
117754: LD_ADDR_VAR 0 2
117758: PUSH
117759: LD_VAR 0 2
117763: PUSH
117764: LD_VAR 0 4
117768: UNION
117769: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117770: LD_VAR 0 4
117774: PPUSH
117775: LD_INT 18
117777: PPUSH
117778: CALL_OW 109
// end ;
117782: GO 117739
117784: POP
117785: POP
// repeat wait ( 0 0$2 ) ;
117786: LD_INT 70
117788: PPUSH
117789: CALL_OW 67
// enemy := mc_scan [ base ] ;
117793: LD_ADDR_VAR 0 21
117797: PUSH
117798: LD_EXP 54
117802: PUSH
117803: LD_VAR 0 1
117807: ARRAY
117808: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117809: LD_EXP 31
117813: PUSH
117814: LD_VAR 0 1
117818: ARRAY
117819: NOT
117820: PUSH
117821: LD_EXP 31
117825: PUSH
117826: LD_VAR 0 1
117830: ARRAY
117831: PUSH
117832: EMPTY
117833: EQUAL
117834: OR
117835: IFFALSE 117872
// begin for i in defenders do
117837: LD_ADDR_VAR 0 4
117841: PUSH
117842: LD_VAR 0 2
117846: PUSH
117847: FOR_IN
117848: IFFALSE 117861
// ComStop ( i ) ;
117850: LD_VAR 0 4
117854: PPUSH
117855: CALL_OW 141
117859: GO 117847
117861: POP
117862: POP
// defenders := [ ] ;
117863: LD_ADDR_VAR 0 2
117867: PUSH
117868: EMPTY
117869: ST_TO_ADDR
// exit ;
117870: GO 119321
// end ; for i in defenders do
117872: LD_ADDR_VAR 0 4
117876: PUSH
117877: LD_VAR 0 2
117881: PUSH
117882: FOR_IN
117883: IFFALSE 118781
// begin e := NearestUnitToUnit ( enemy , i ) ;
117885: LD_ADDR_VAR 0 13
117889: PUSH
117890: LD_VAR 0 21
117894: PPUSH
117895: LD_VAR 0 4
117899: PPUSH
117900: CALL_OW 74
117904: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117905: LD_ADDR_VAR 0 7
117909: PUSH
117910: LD_EXP 31
117914: PUSH
117915: LD_VAR 0 1
117919: ARRAY
117920: PPUSH
117921: LD_INT 2
117923: PUSH
117924: LD_INT 30
117926: PUSH
117927: LD_INT 0
117929: PUSH
117930: EMPTY
117931: LIST
117932: LIST
117933: PUSH
117934: LD_INT 30
117936: PUSH
117937: LD_INT 1
117939: PUSH
117940: EMPTY
117941: LIST
117942: LIST
117943: PUSH
117944: EMPTY
117945: LIST
117946: LIST
117947: LIST
117948: PPUSH
117949: CALL_OW 72
117953: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117954: LD_ADDR_VAR 0 16
117958: PUSH
117959: LD_VAR 0 7
117963: NOT
117964: PUSH
117965: LD_VAR 0 7
117969: PPUSH
117970: LD_INT 3
117972: PUSH
117973: LD_INT 24
117975: PUSH
117976: LD_INT 600
117978: PUSH
117979: EMPTY
117980: LIST
117981: LIST
117982: PUSH
117983: EMPTY
117984: LIST
117985: LIST
117986: PPUSH
117987: CALL_OW 72
117991: OR
117992: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117993: LD_VAR 0 4
117997: PPUSH
117998: CALL_OW 247
118002: PUSH
118003: LD_INT 2
118005: DOUBLE
118006: EQUAL
118007: IFTRUE 118011
118009: GO 118407
118011: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118012: LD_VAR 0 4
118016: PPUSH
118017: CALL_OW 256
118021: PUSH
118022: LD_INT 1000
118024: EQUAL
118025: PUSH
118026: LD_VAR 0 4
118030: PPUSH
118031: LD_VAR 0 13
118035: PPUSH
118036: CALL_OW 296
118040: PUSH
118041: LD_INT 40
118043: LESS
118044: PUSH
118045: LD_VAR 0 13
118049: PPUSH
118050: LD_EXP 56
118054: PUSH
118055: LD_VAR 0 1
118059: ARRAY
118060: PPUSH
118061: CALL_OW 308
118065: OR
118066: AND
118067: IFFALSE 118189
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118069: LD_VAR 0 4
118073: PPUSH
118074: CALL_OW 262
118078: PUSH
118079: LD_INT 1
118081: EQUAL
118082: PUSH
118083: LD_VAR 0 4
118087: PPUSH
118088: CALL_OW 261
118092: PUSH
118093: LD_INT 30
118095: LESS
118096: AND
118097: PUSH
118098: LD_VAR 0 7
118102: AND
118103: IFFALSE 118173
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118105: LD_VAR 0 4
118109: PPUSH
118110: LD_VAR 0 7
118114: PPUSH
118115: LD_VAR 0 4
118119: PPUSH
118120: CALL_OW 74
118124: PPUSH
118125: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118129: LD_VAR 0 4
118133: PPUSH
118134: LD_VAR 0 7
118138: PPUSH
118139: LD_VAR 0 4
118143: PPUSH
118144: CALL_OW 74
118148: PPUSH
118149: CALL_OW 296
118153: PUSH
118154: LD_INT 6
118156: LESS
118157: IFFALSE 118171
// SetFuel ( i , 100 ) ;
118159: LD_VAR 0 4
118163: PPUSH
118164: LD_INT 100
118166: PPUSH
118167: CALL_OW 240
// end else
118171: GO 118187
// ComAttackUnit ( i , e ) ;
118173: LD_VAR 0 4
118177: PPUSH
118178: LD_VAR 0 13
118182: PPUSH
118183: CALL_OW 115
// end else
118187: GO 118290
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118189: LD_VAR 0 13
118193: PPUSH
118194: LD_EXP 56
118198: PUSH
118199: LD_VAR 0 1
118203: ARRAY
118204: PPUSH
118205: CALL_OW 308
118209: NOT
118210: PUSH
118211: LD_VAR 0 4
118215: PPUSH
118216: LD_VAR 0 13
118220: PPUSH
118221: CALL_OW 296
118225: PUSH
118226: LD_INT 40
118228: GREATEREQUAL
118229: AND
118230: PUSH
118231: LD_VAR 0 4
118235: PPUSH
118236: CALL_OW 256
118240: PUSH
118241: LD_INT 650
118243: LESSEQUAL
118244: OR
118245: PUSH
118246: LD_VAR 0 4
118250: PPUSH
118251: LD_EXP 55
118255: PUSH
118256: LD_VAR 0 1
118260: ARRAY
118261: PPUSH
118262: CALL_OW 308
118266: NOT
118267: AND
118268: IFFALSE 118290
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118270: LD_VAR 0 4
118274: PPUSH
118275: LD_EXP 55
118279: PUSH
118280: LD_VAR 0 1
118284: ARRAY
118285: PPUSH
118286: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118290: LD_VAR 0 4
118294: PPUSH
118295: CALL_OW 256
118299: PUSH
118300: LD_INT 1000
118302: LESS
118303: PUSH
118304: LD_VAR 0 4
118308: PPUSH
118309: CALL_OW 263
118313: PUSH
118314: LD_INT 1
118316: EQUAL
118317: AND
118318: PUSH
118319: LD_VAR 0 4
118323: PPUSH
118324: CALL_OW 311
118328: AND
118329: PUSH
118330: LD_VAR 0 4
118334: PPUSH
118335: LD_EXP 55
118339: PUSH
118340: LD_VAR 0 1
118344: ARRAY
118345: PPUSH
118346: CALL_OW 308
118350: AND
118351: IFFALSE 118405
// begin mech := IsDrivenBy ( i ) ;
118353: LD_ADDR_VAR 0 9
118357: PUSH
118358: LD_VAR 0 4
118362: PPUSH
118363: CALL_OW 311
118367: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118368: LD_VAR 0 9
118372: PPUSH
118373: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118377: LD_VAR 0 9
118381: PPUSH
118382: LD_VAR 0 4
118386: PPUSH
118387: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118391: LD_VAR 0 9
118395: PPUSH
118396: LD_VAR 0 4
118400: PPUSH
118401: CALL_OW 180
// end ; end ; unit_human :
118405: GO 118752
118407: LD_INT 1
118409: DOUBLE
118410: EQUAL
118411: IFTRUE 118415
118413: GO 118751
118415: POP
// begin b := IsInUnit ( i ) ;
118416: LD_ADDR_VAR 0 18
118420: PUSH
118421: LD_VAR 0 4
118425: PPUSH
118426: CALL_OW 310
118430: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118431: LD_ADDR_VAR 0 19
118435: PUSH
118436: LD_VAR 0 18
118440: NOT
118441: PUSH
118442: LD_VAR 0 18
118446: PPUSH
118447: CALL_OW 266
118451: PUSH
118452: LD_INT 32
118454: PUSH
118455: LD_INT 31
118457: PUSH
118458: EMPTY
118459: LIST
118460: LIST
118461: IN
118462: OR
118463: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118464: LD_VAR 0 18
118468: PPUSH
118469: CALL_OW 266
118473: PUSH
118474: LD_INT 5
118476: EQUAL
118477: PUSH
118478: LD_VAR 0 4
118482: PPUSH
118483: CALL_OW 257
118487: PUSH
118488: LD_INT 1
118490: PUSH
118491: LD_INT 2
118493: PUSH
118494: LD_INT 3
118496: PUSH
118497: LD_INT 4
118499: PUSH
118500: EMPTY
118501: LIST
118502: LIST
118503: LIST
118504: LIST
118505: IN
118506: AND
118507: IFFALSE 118544
// begin class := AllowSpecClass ( i ) ;
118509: LD_ADDR_VAR 0 20
118513: PUSH
118514: LD_VAR 0 4
118518: PPUSH
118519: CALL 21670 0 1
118523: ST_TO_ADDR
// if class then
118524: LD_VAR 0 20
118528: IFFALSE 118544
// ComChangeProfession ( i , class ) ;
118530: LD_VAR 0 4
118534: PPUSH
118535: LD_VAR 0 20
118539: PPUSH
118540: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118544: LD_VAR 0 16
118548: PUSH
118549: LD_VAR 0 2
118553: PPUSH
118554: LD_INT 21
118556: PUSH
118557: LD_INT 2
118559: PUSH
118560: EMPTY
118561: LIST
118562: LIST
118563: PPUSH
118564: CALL_OW 72
118568: PUSH
118569: LD_INT 1
118571: LESSEQUAL
118572: OR
118573: PUSH
118574: LD_VAR 0 19
118578: AND
118579: PUSH
118580: LD_VAR 0 4
118584: PUSH
118585: LD_VAR 0 17
118589: IN
118590: NOT
118591: AND
118592: IFFALSE 118685
// begin if b then
118594: LD_VAR 0 18
118598: IFFALSE 118647
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118600: LD_VAR 0 18
118604: PPUSH
118605: LD_VAR 0 21
118609: PPUSH
118610: LD_VAR 0 18
118614: PPUSH
118615: CALL_OW 74
118619: PPUSH
118620: CALL_OW 296
118624: PUSH
118625: LD_INT 10
118627: LESS
118628: PUSH
118629: LD_VAR 0 18
118633: PPUSH
118634: CALL_OW 461
118638: PUSH
118639: LD_INT 7
118641: NONEQUAL
118642: AND
118643: IFFALSE 118647
// continue ;
118645: GO 117882
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118647: LD_ADDR_VAR 0 17
118651: PUSH
118652: LD_VAR 0 17
118656: PPUSH
118657: LD_VAR 0 17
118661: PUSH
118662: LD_INT 1
118664: PLUS
118665: PPUSH
118666: LD_VAR 0 4
118670: PPUSH
118671: CALL_OW 1
118675: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118676: LD_VAR 0 4
118680: PPUSH
118681: CALL_OW 122
// end ; if sold_defenders then
118685: LD_VAR 0 17
118689: IFFALSE 118749
// if i in sold_defenders then
118691: LD_VAR 0 4
118695: PUSH
118696: LD_VAR 0 17
118700: IN
118701: IFFALSE 118749
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118703: LD_VAR 0 4
118707: PPUSH
118708: CALL_OW 314
118712: NOT
118713: PUSH
118714: LD_VAR 0 4
118718: PPUSH
118719: LD_VAR 0 13
118723: PPUSH
118724: CALL_OW 296
118728: PUSH
118729: LD_INT 30
118731: LESS
118732: AND
118733: IFFALSE 118749
// ComAttackUnit ( i , e ) ;
118735: LD_VAR 0 4
118739: PPUSH
118740: LD_VAR 0 13
118744: PPUSH
118745: CALL_OW 115
// end ; end ; end ;
118749: GO 118752
118751: POP
// if IsDead ( i ) then
118752: LD_VAR 0 4
118756: PPUSH
118757: CALL_OW 301
118761: IFFALSE 118779
// defenders := defenders diff i ;
118763: LD_ADDR_VAR 0 2
118767: PUSH
118768: LD_VAR 0 2
118772: PUSH
118773: LD_VAR 0 4
118777: DIFF
118778: ST_TO_ADDR
// end ;
118779: GO 117882
118781: POP
118782: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118783: LD_VAR 0 21
118787: NOT
118788: PUSH
118789: LD_VAR 0 2
118793: NOT
118794: OR
118795: PUSH
118796: LD_EXP 31
118800: PUSH
118801: LD_VAR 0 1
118805: ARRAY
118806: NOT
118807: OR
118808: IFFALSE 117786
// MC_Reset ( base , 18 ) ;
118810: LD_VAR 0 1
118814: PPUSH
118815: LD_INT 18
118817: PPUSH
118818: CALL 65417 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118822: LD_ADDR_VAR 0 2
118826: PUSH
118827: LD_VAR 0 2
118831: PUSH
118832: LD_VAR 0 2
118836: PPUSH
118837: LD_INT 2
118839: PUSH
118840: LD_INT 25
118842: PUSH
118843: LD_INT 1
118845: PUSH
118846: EMPTY
118847: LIST
118848: LIST
118849: PUSH
118850: LD_INT 25
118852: PUSH
118853: LD_INT 5
118855: PUSH
118856: EMPTY
118857: LIST
118858: LIST
118859: PUSH
118860: LD_INT 25
118862: PUSH
118863: LD_INT 8
118865: PUSH
118866: EMPTY
118867: LIST
118868: LIST
118869: PUSH
118870: LD_INT 25
118872: PUSH
118873: LD_INT 9
118875: PUSH
118876: EMPTY
118877: LIST
118878: LIST
118879: PUSH
118880: EMPTY
118881: LIST
118882: LIST
118883: LIST
118884: LIST
118885: LIST
118886: PPUSH
118887: CALL_OW 72
118891: DIFF
118892: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118893: LD_VAR 0 21
118897: NOT
118898: PUSH
118899: LD_VAR 0 2
118903: PPUSH
118904: LD_INT 21
118906: PUSH
118907: LD_INT 2
118909: PUSH
118910: EMPTY
118911: LIST
118912: LIST
118913: PPUSH
118914: CALL_OW 72
118918: AND
118919: IFFALSE 119257
// begin tmp := FilterByTag ( defenders , 19 ) ;
118921: LD_ADDR_VAR 0 11
118925: PUSH
118926: LD_VAR 0 2
118930: PPUSH
118931: LD_INT 19
118933: PPUSH
118934: CALL 54758 0 2
118938: ST_TO_ADDR
// if tmp then
118939: LD_VAR 0 11
118943: IFFALSE 119013
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118945: LD_ADDR_VAR 0 11
118949: PUSH
118950: LD_VAR 0 11
118954: PPUSH
118955: LD_INT 25
118957: PUSH
118958: LD_INT 3
118960: PUSH
118961: EMPTY
118962: LIST
118963: LIST
118964: PPUSH
118965: CALL_OW 72
118969: ST_TO_ADDR
// if tmp then
118970: LD_VAR 0 11
118974: IFFALSE 119013
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118976: LD_ADDR_EXP 43
118980: PUSH
118981: LD_EXP 43
118985: PPUSH
118986: LD_VAR 0 1
118990: PPUSH
118991: LD_EXP 43
118995: PUSH
118996: LD_VAR 0 1
119000: ARRAY
119001: PUSH
119002: LD_VAR 0 11
119006: UNION
119007: PPUSH
119008: CALL_OW 1
119012: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119013: LD_VAR 0 1
119017: PPUSH
119018: LD_INT 19
119020: PPUSH
119021: CALL 65417 0 2
// repeat wait ( 0 0$1 ) ;
119025: LD_INT 35
119027: PPUSH
119028: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119032: LD_EXP 31
119036: PUSH
119037: LD_VAR 0 1
119041: ARRAY
119042: NOT
119043: PUSH
119044: LD_EXP 31
119048: PUSH
119049: LD_VAR 0 1
119053: ARRAY
119054: PUSH
119055: EMPTY
119056: EQUAL
119057: OR
119058: IFFALSE 119095
// begin for i in defenders do
119060: LD_ADDR_VAR 0 4
119064: PUSH
119065: LD_VAR 0 2
119069: PUSH
119070: FOR_IN
119071: IFFALSE 119084
// ComStop ( i ) ;
119073: LD_VAR 0 4
119077: PPUSH
119078: CALL_OW 141
119082: GO 119070
119084: POP
119085: POP
// defenders := [ ] ;
119086: LD_ADDR_VAR 0 2
119090: PUSH
119091: EMPTY
119092: ST_TO_ADDR
// exit ;
119093: GO 119321
// end ; for i in defenders do
119095: LD_ADDR_VAR 0 4
119099: PUSH
119100: LD_VAR 0 2
119104: PUSH
119105: FOR_IN
119106: IFFALSE 119195
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119108: LD_VAR 0 4
119112: PPUSH
119113: LD_EXP 55
119117: PUSH
119118: LD_VAR 0 1
119122: ARRAY
119123: PPUSH
119124: CALL_OW 308
119128: NOT
119129: IFFALSE 119153
// ComMoveToArea ( i , mc_parking [ base ] ) else
119131: LD_VAR 0 4
119135: PPUSH
119136: LD_EXP 55
119140: PUSH
119141: LD_VAR 0 1
119145: ARRAY
119146: PPUSH
119147: CALL_OW 113
119151: GO 119193
// if GetControl ( i ) = control_manual then
119153: LD_VAR 0 4
119157: PPUSH
119158: CALL_OW 263
119162: PUSH
119163: LD_INT 1
119165: EQUAL
119166: IFFALSE 119193
// if IsDrivenBy ( i ) then
119168: LD_VAR 0 4
119172: PPUSH
119173: CALL_OW 311
119177: IFFALSE 119193
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119179: LD_VAR 0 4
119183: PPUSH
119184: CALL_OW 311
119188: PPUSH
119189: CALL_OW 121
// end ;
119193: GO 119105
119195: POP
119196: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119197: LD_VAR 0 2
119201: PPUSH
119202: LD_INT 95
119204: PUSH
119205: LD_EXP 55
119209: PUSH
119210: LD_VAR 0 1
119214: ARRAY
119215: PUSH
119216: EMPTY
119217: LIST
119218: LIST
119219: PPUSH
119220: CALL_OW 72
119224: PUSH
119225: LD_VAR 0 2
119229: EQUAL
119230: PUSH
119231: LD_EXP 54
119235: PUSH
119236: LD_VAR 0 1
119240: ARRAY
119241: OR
119242: PUSH
119243: LD_EXP 31
119247: PUSH
119248: LD_VAR 0 1
119252: ARRAY
119253: NOT
119254: OR
119255: IFFALSE 119025
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119257: LD_ADDR_EXP 53
119261: PUSH
119262: LD_EXP 53
119266: PPUSH
119267: LD_VAR 0 1
119271: PPUSH
119272: LD_VAR 0 2
119276: PPUSH
119277: LD_INT 21
119279: PUSH
119280: LD_INT 2
119282: PUSH
119283: EMPTY
119284: LIST
119285: LIST
119286: PPUSH
119287: CALL_OW 72
119291: PPUSH
119292: CALL_OW 1
119296: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119297: LD_VAR 0 1
119301: PPUSH
119302: LD_INT 19
119304: PPUSH
119305: CALL 65417 0 2
// MC_Reset ( base , 20 ) ;
119309: LD_VAR 0 1
119313: PPUSH
119314: LD_INT 20
119316: PPUSH
119317: CALL 65417 0 2
// end ; end_of_file
119321: LD_VAR 0 3
119325: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119326: LD_VAR 0 1
119330: PUSH
119331: LD_INT 200
119333: DOUBLE
119334: GREATEREQUAL
119335: IFFALSE 119343
119337: LD_INT 299
119339: DOUBLE
119340: LESSEQUAL
119341: IFTRUE 119345
119343: GO 119377
119345: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119346: LD_VAR 0 1
119350: PPUSH
119351: LD_VAR 0 2
119355: PPUSH
119356: LD_VAR 0 3
119360: PPUSH
119361: LD_VAR 0 4
119365: PPUSH
119366: LD_VAR 0 5
119370: PPUSH
119371: CALL 108112 0 5
119375: GO 119454
119377: LD_INT 300
119379: DOUBLE
119380: GREATEREQUAL
119381: IFFALSE 119389
119383: LD_INT 399
119385: DOUBLE
119386: LESSEQUAL
119387: IFTRUE 119391
119389: GO 119453
119391: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119392: LD_VAR 0 1
119396: PPUSH
119397: LD_VAR 0 2
119401: PPUSH
119402: LD_VAR 0 3
119406: PPUSH
119407: LD_VAR 0 4
119411: PPUSH
119412: LD_VAR 0 5
119416: PPUSH
119417: LD_VAR 0 6
119421: PPUSH
119422: LD_VAR 0 7
119426: PPUSH
119427: LD_VAR 0 8
119431: PPUSH
119432: LD_VAR 0 9
119436: PPUSH
119437: LD_VAR 0 10
119441: PPUSH
119442: LD_VAR 0 11
119446: PPUSH
119447: CALL 104445 0 11
119451: GO 119454
119453: POP
// end ;
119454: PPOPN 11
119456: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119457: LD_VAR 0 1
119461: PPUSH
119462: LD_VAR 0 2
119466: PPUSH
119467: LD_VAR 0 3
119471: PPUSH
119472: LD_VAR 0 4
119476: PPUSH
119477: LD_VAR 0 5
119481: PPUSH
119482: CALL 107848 0 5
// end ; end_of_file
119486: PPOPN 5
119488: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119489: LD_VAR 0 1
119493: PPUSH
119494: LD_VAR 0 2
119498: PPUSH
119499: LD_VAR 0 3
119503: PPUSH
119504: LD_VAR 0 4
119508: PPUSH
119509: LD_VAR 0 5
119513: PPUSH
119514: LD_VAR 0 6
119518: PPUSH
119519: CALL 92097 0 6
// end ;
119523: PPOPN 6
119525: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119526: LD_INT 0
119528: PPUSH
// begin if not units then
119529: LD_VAR 0 1
119533: NOT
119534: IFFALSE 119538
// exit ;
119536: GO 119538
// end ;
119538: PPOPN 7
119540: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119541: CALL 92001 0 0
// end ;
119545: PPOPN 1
119547: END
