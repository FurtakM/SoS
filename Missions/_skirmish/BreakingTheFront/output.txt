// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 602 0 0
// SetDiplomacy ;
  42: CALL 814 0 0
// PrepareGame ;
  46: CALL 896 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := 0 ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 0 0$1 trigger game and GameType = 1 and not disableGlobalTimer do
 229: LD_EXP 3
 233: PUSH
 234: LD_EXP 2
 238: PUSH
 239: LD_INT 1
 241: EQUAL
 242: AND
 243: PUSH
 244: LD_EXP 4
 248: NOT
 249: AND
 250: IFFALSE 273
 252: GO 254
 254: DISABLE
// begin enable ;
 255: ENABLE
// display_strings := [ #SkrTime , tick ] ;
 256: LD_ADDR_OWVAR 47
 260: PUSH
 261: LD_STRING #SkrTime
 263: PUSH
 264: LD_OWVAR 1
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: ST_TO_ADDR
// end ;
 273: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 274: LD_EXP 19
 278: PUSH
 279: LD_EXP 3
 283: AND
 284: PUSH
 285: LD_EXP 2
 289: PUSH
 290: LD_INT 1
 292: EQUAL
 293: AND
 294: IFFALSE 355
 296: GO 298
 298: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 299: LD_EXP 19
 303: PUSH
 304: LD_INT 1
 306: ARRAY
 307: PUSH
 308: LD_INT 1
 310: ARRAY
 311: PPUSH
 312: LD_EXP 19
 316: PUSH
 317: LD_INT 1
 319: ARRAY
 320: PUSH
 321: LD_INT 2
 323: ARRAY
 324: PPUSH
 325: LD_EXP 19
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 3
 336: ARRAY
 337: PPUSH
 338: LD_EXP 19
 342: PUSH
 343: LD_INT 1
 345: ARRAY
 346: PUSH
 347: LD_INT 4
 349: ARRAY
 350: PPUSH
 351: CALL 56676 0 4
 355: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 356: LD_EXP 19
 360: PUSH
 361: LD_EXP 3
 365: AND
 366: PUSH
 367: LD_EXP 2
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: IFFALSE 437
 378: GO 380
 380: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 381: LD_EXP 19
 385: PUSH
 386: LD_INT 2
 388: ARRAY
 389: PUSH
 390: LD_INT 1
 392: ARRAY
 393: PPUSH
 394: LD_EXP 19
 398: PUSH
 399: LD_INT 2
 401: ARRAY
 402: PUSH
 403: LD_INT 2
 405: ARRAY
 406: PPUSH
 407: LD_EXP 19
 411: PUSH
 412: LD_INT 2
 414: ARRAY
 415: PUSH
 416: LD_INT 3
 418: ARRAY
 419: PPUSH
 420: LD_EXP 19
 424: PUSH
 425: LD_INT 2
 427: ARRAY
 428: PUSH
 429: LD_INT 4
 431: ARRAY
 432: PPUSH
 433: CALL 56676 0 4
 437: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 438: LD_EXP 19
 442: PUSH
 443: LD_EXP 3
 447: AND
 448: PUSH
 449: LD_EXP 2
 453: PUSH
 454: LD_INT 1
 456: EQUAL
 457: AND
 458: IFFALSE 519
 460: GO 462
 462: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 463: LD_EXP 19
 467: PUSH
 468: LD_INT 3
 470: ARRAY
 471: PUSH
 472: LD_INT 1
 474: ARRAY
 475: PPUSH
 476: LD_EXP 19
 480: PUSH
 481: LD_INT 3
 483: ARRAY
 484: PUSH
 485: LD_INT 2
 487: ARRAY
 488: PPUSH
 489: LD_EXP 19
 493: PUSH
 494: LD_INT 3
 496: ARRAY
 497: PUSH
 498: LD_INT 3
 500: ARRAY
 501: PPUSH
 502: LD_EXP 19
 506: PUSH
 507: LD_INT 3
 509: ARRAY
 510: PUSH
 511: LD_INT 4
 513: ARRAY
 514: PPUSH
 515: CALL 56676 0 4
 519: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 520: LD_EXP 19
 524: PUSH
 525: LD_EXP 3
 529: AND
 530: PUSH
 531: LD_EXP 2
 535: PUSH
 536: LD_INT 1
 538: EQUAL
 539: AND
 540: IFFALSE 601
 542: GO 544
 544: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 545: LD_EXP 19
 549: PUSH
 550: LD_INT 4
 552: ARRAY
 553: PUSH
 554: LD_INT 1
 556: ARRAY
 557: PPUSH
 558: LD_EXP 19
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PPUSH
 571: LD_EXP 19
 575: PUSH
 576: LD_INT 4
 578: ARRAY
 579: PUSH
 580: LD_INT 3
 582: ARRAY
 583: PPUSH
 584: LD_EXP 19
 588: PUSH
 589: LD_INT 4
 591: ARRAY
 592: PUSH
 593: LD_INT 4
 595: ARRAY
 596: PPUSH
 597: CALL 56676 0 4
 601: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 602: LD_INT 0
 604: PPUSH
 605: PPUSH
 606: PPUSH
 607: PPUSH
 608: PPUSH
// if GameType = 1 then
 609: LD_EXP 2
 613: PUSH
 614: LD_INT 1
 616: EQUAL
 617: IFFALSE 686
// begin ban_techs := [ ] ;
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// if sibBombAllowed < 2 then
 626: LD_EXP 23
 630: PUSH
 631: LD_INT 2
 633: LESS
 634: IFFALSE 647
// ban_techs := [ tech_sibFiss ] ;
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: LD_INT 25
 643: PUSH
 644: EMPTY
 645: LIST
 646: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_INT 46
 654: PUSH
 655: LD_INT 47
 657: PUSH
 658: LD_INT 48
 660: PUSH
 661: LD_INT 49
 663: PUSH
 664: LD_INT 50
 666: PUSH
 667: LD_INT 39
 669: PUSH
 670: LD_INT 69
 672: PUSH
 673: LD_INT 40
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: ST_TO_ADDR
// end ; for i = 1 to 8 do
 686: LD_ADDR_VAR 0 2
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_INT 8
 698: PUSH
 699: FOR_TO
 700: IFFALSE 784
// begin if res_techs then
 702: LD_VAR 0 5
 706: IFFALSE 742
// for j in res_techs do
 708: LD_ADDR_VAR 0 3
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: FOR_IN
 719: IFFALSE 740
// SetTech ( j , i , state_researched ) ;
 721: LD_VAR 0 3
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: LD_INT 2
 733: PPUSH
 734: CALL_OW 322
 738: GO 718
 740: POP
 741: POP
// if ban_techs then
 742: LD_VAR 0 4
 746: IFFALSE 782
// for j in ban_techs do
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_VAR 0 4
 757: PUSH
 758: FOR_IN
 759: IFFALSE 780
// SetTech ( j , i , state_disabled ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 322
 778: GO 758
 780: POP
 781: POP
// end ;
 782: GO 699
 784: POP
 785: POP
// if sibBombAllowed = 1 then
 786: LD_EXP 23
 790: PUSH
 791: LD_INT 1
 793: EQUAL
 794: IFFALSE 809
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 796: LD_INT 25
 798: PPUSH
 799: LD_INT 3
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 322
// end ;
 809: LD_VAR 0 1
 813: RET
// export function SetDiplomacy ; begin
 814: LD_INT 0
 816: PPUSH
// if GameType = 1 then
 817: LD_EXP 2
 821: PUSH
 822: LD_INT 1
 824: EQUAL
 825: IFFALSE 891
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 827: LD_INT 1
 829: PPUSH
 830: LD_INT 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 843: LD_INT 3
 845: PPUSH
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 8
 864: PPUSH
 865: LD_INT 1
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 875: LD_INT 6
 877: PPUSH
 878: LD_INT 8
 880: PPUSH
 881: LD_INT 1
 883: PPUSH
 884: LD_INT 1
 886: PPUSH
 887: CALL_OW 80
// end ; end ;
 891: LD_VAR 0 1
 895: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 896: LD_INT 0
 898: PPUSH
 899: PPUSH
 900: PPUSH
 901: PPUSH
// if GameType = 1 then
 902: LD_EXP 2
 906: PUSH
 907: LD_INT 1
 909: EQUAL
 910: IFFALSE 1406
// begin game := false ;
 912: LD_ADDR_EXP 3
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// your_side := 1 ;
 920: LD_ADDR_OWVAR 2
 924: PUSH
 925: LD_INT 1
 927: ST_TO_ADDR
// mc_amer := 1 ;
 928: LD_ADDR_EXP 5
 932: PUSH
 933: LD_INT 1
 935: ST_TO_ADDR
// mc_leg := 2 ;
 936: LD_ADDR_EXP 6
 940: PUSH
 941: LD_INT 2
 943: ST_TO_ADDR
// mc_rus_1 := 3 ;
 944: LD_ADDR_EXP 7
 948: PUSH
 949: LD_INT 3
 951: ST_TO_ADDR
// mc_rus_2 := 4 ;
 952: LD_ADDR_EXP 8
 956: PUSH
 957: LD_INT 4
 959: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 960: LD_ADDR_EXP 19
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: LD_INT 200
 976: PUSH
 977: LD_INT 250
 979: PUSH
 980: LD_INT 300
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_EXP 26
 992: ARRAY
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 13
1002: PUSH
1003: LD_INT 8
1005: PUSH
1006: LD_INT 50
1008: PUSH
1009: LD_INT 500
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 17
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 50
1026: PUSH
1027: LD_INT 300
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 18
1038: PUSH
1039: LD_INT 4
1041: PUSH
1042: LD_INT 5
1044: PUSH
1045: LD_INT 6
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_EXP 26
1057: ARRAY
1058: PUSH
1059: LD_INT 30
1061: PUSH
1062: LD_INT 300
1064: PUSH
1065: LD_INT 450
1067: PUSH
1068: LD_INT 500
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_EXP 26
1080: ARRAY
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: LD_INT 190
1101: PUSH
1102: LD_INT 193
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 182
1115: PUSH
1116: LD_INT 117
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 114
1143: PUSH
1144: LD_INT 152
1146: PUSH
1147: LD_INT 2
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 85
1157: PUSH
1158: LD_INT 38
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i in sources do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: PUSH
1186: FOR_IN
1187: IFFALSE 1222
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1189: LD_VAR 0 2
1193: PUSH
1194: LD_INT 1
1196: ARRAY
1197: PPUSH
1198: LD_VAR 0 2
1202: PUSH
1203: LD_INT 2
1205: ARRAY
1206: PPUSH
1207: LD_VAR 0 2
1211: PUSH
1212: LD_INT 3
1214: ARRAY
1215: PPUSH
1216: CALL_OW 62
1220: GO 1186
1222: POP
1223: POP
// disableGlobalTimer := false ;
1224: LD_ADDR_EXP 4
1228: PUSH
1229: LD_INT 0
1231: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1232: LD_ADDR_EXP 15
1236: PUSH
1237: LD_INT 0
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_OWVAR 67
1258: ARRAY
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: ST_TO_ADDR
// ruOutpost := [ ] ;
1264: LD_ADDR_EXP 14
1268: PUSH
1269: EMPTY
1270: ST_TO_ADDR
// staticMines := [ ] ;
1271: LD_ADDR_EXP 16
1275: PUSH
1276: EMPTY
1277: ST_TO_ADDR
// baseCaptured := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// legDestCounter := 0 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 0
1293: ST_TO_ADDR
// legOfferAccepted := false ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_INT 0
1301: ST_TO_ADDR
// legChangeSide := false ;
1302: LD_ADDR_EXP 21
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// allyDestCounter := 0 ;
1310: LD_ADDR_EXP 22
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// outpostEscape := false ;
1318: LD_ADDR_EXP 27
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// dialogueMineDetected := false ;
1326: LD_ADDR_EXP 28
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// PrepareAmericans ;
1334: CALL 7604 0 0
// PrepareLegion ;
1338: CALL 5538 0 0
// PrepareRussians ;
1342: CALL 2504 0 0
// playerForces := PreparePlayer ;
1346: LD_ADDR_EXP 10
1350: PUSH
1351: CALL 8847 0 0
1355: ST_TO_ADDR
// AnimateTrees ( true ) ;
1356: LD_INT 1
1358: PPUSH
1359: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1363: LD_INT 4
1365: PPUSH
1366: LD_INT 3
1368: PPUSH
1369: LD_INT 8
1371: PPUSH
1372: LD_INT 5
1374: PPUSH
1375: LD_INT 3
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 8
1383: PPUSH
1384: LD_INT 2
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: CALL 54041 0 9
// MC_Start ;
1394: CALL 63477 0 0
// SetAdditionalRussianForces ;
1398: CALL 7273 0 0
// Action ;
1402: CALL 11204 0 0
// end ; end ;
1406: LD_VAR 0 1
1410: RET
// export function CustomInitMacro ; begin
1411: LD_INT 0
1413: PPUSH
// if GameType <> 1 then
1414: LD_EXP 2
1418: PUSH
1419: LD_INT 1
1421: NONEQUAL
1422: IFFALSE 1426
// exit ;
1424: GO 2499
// MC_SetScanArea ( mc_amer , amerBase ) ;
1426: LD_EXP 5
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: CALL 86854 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1438: LD_EXP 5
1442: PPUSH
1443: LD_INT 4
1445: PPUSH
1446: CALL 86798 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1450: LD_EXP 5
1454: PPUSH
1455: LD_INT 11
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 7
1463: PUSH
1464: LD_INT 9
1466: PUSH
1467: LD_INT 10
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: PPUSH
1477: CALL 86686 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1481: LD_EXP 5
1485: PPUSH
1486: LD_INT 5
1488: PPUSH
1489: CALL 86368 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1493: LD_EXP 5
1497: PPUSH
1498: LD_INT 3
1500: PPUSH
1501: CALL 86099 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1505: LD_EXP 5
1509: PPUSH
1510: LD_INT 4
1512: PPUSH
1513: CALL 85718 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1517: LD_EXP 5
1521: PPUSH
1522: LD_INT 3
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 2
1530: PUSH
1531: LD_INT 5
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: LD_INT 9
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 4
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: LD_INT 2
1566: PUSH
1567: LD_INT 7
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: PUSH
1576: LD_INT 4
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: LD_INT 2
1584: PUSH
1585: LD_INT 6
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL 85533 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1604: LD_EXP 5
1608: PPUSH
1609: LD_INT 33
1611: PUSH
1612: LD_INT 114
1614: PUSH
1615: LD_INT 16
1617: PUSH
1618: LD_INT 0
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 110
1632: PUSH
1633: LD_INT 12
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL 85425 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1653: LD_EXP 5
1657: PPUSH
1658: LD_INT 10
1660: PUSH
1661: LD_INT 15
1663: PUSH
1664: LD_INT 12
1666: PUSH
1667: LD_INT 11
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL 86275 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1680: LD_EXP 6
1684: PPUSH
1685: LD_INT 6
1687: PPUSH
1688: CALL 86854 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1692: LD_EXP 6
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL 86798 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1704: LD_EXP 6
1708: PPUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 27
1714: PUSH
1715: LD_INT 28
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL 86686 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1731: LD_EXP 6
1735: PPUSH
1736: LD_INT 17
1738: PPUSH
1739: CALL 86368 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1743: LD_EXP 6
1747: PPUSH
1748: LD_INT 6
1750: PPUSH
1751: CALL 86099 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1755: LD_EXP 6
1759: PPUSH
1760: LD_INT 5
1762: PPUSH
1763: CALL 85718 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1767: LD_EXP 6
1771: PPUSH
1772: LD_INT 10
1774: PPUSH
1775: LD_INT 9
1777: PPUSH
1778: CALL 85215 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1782: LD_EXP 6
1786: PPUSH
1787: LD_INT 4
1789: PUSH
1790: LD_INT 157
1792: PUSH
1793: LD_INT 144
1795: PUSH
1796: LD_INT 0
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 32
1807: PUSH
1808: LD_INT 151
1810: PUSH
1811: LD_INT 142
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 32
1825: PUSH
1826: LD_INT 161
1828: PUSH
1829: LD_INT 144
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 32
1843: PUSH
1844: LD_INT 140
1846: PUSH
1847: LD_INT 133
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL 85425 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1869: LD_EXP 6
1873: PPUSH
1874: LD_INT 13
1876: PUSH
1877: LD_INT 2
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 31
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 13
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 31
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 13
1912: PUSH
1913: LD_INT 1
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 27
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: LD_INT 13
1930: PUSH
1931: LD_INT 1
1933: PUSH
1934: LD_INT 2
1936: PUSH
1937: LD_INT 27
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: PUSH
1946: LD_INT 13
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 27
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 13
1966: PUSH
1967: LD_INT 1
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 28
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 13
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 28
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 13
2002: PUSH
2003: LD_INT 1
2005: PUSH
2006: LD_INT 2
2008: PUSH
2009: LD_INT 32
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_INT 13
2020: PUSH
2021: LD_INT 1
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 88
2029: PUSH
2030: EMPTY
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 85533 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2051: LD_INT 165
2053: PPUSH
2054: LD_INT 156
2056: PPUSH
2057: LD_INT 8
2059: PPUSH
2060: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2064: LD_EXP 7
2068: PPUSH
2069: LD_INT 15
2071: PPUSH
2072: CALL 86854 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2076: LD_EXP 7
2080: PPUSH
2081: LD_INT 16
2083: PPUSH
2084: CALL 86798 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2088: LD_EXP 7
2092: PPUSH
2093: LD_INT 43
2095: PUSH
2096: LD_INT 47
2098: PUSH
2099: LD_INT 45
2101: PUSH
2102: LD_INT 49
2104: PUSH
2105: LD_INT 46
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PPUSH
2115: CALL 86686 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2119: LD_EXP 7
2123: PPUSH
2124: LD_INT 13
2126: PPUSH
2127: CALL 86368 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2131: LD_EXP 7
2135: PPUSH
2136: LD_INT 15
2138: PPUSH
2139: CALL 86099 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2143: LD_EXP 7
2147: PPUSH
2148: LD_INT 5
2150: PPUSH
2151: CALL 85718 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2155: LD_EXP 7
2159: PPUSH
2160: LD_INT 23
2162: PUSH
2163: LD_INT 1
2165: PUSH
2166: LD_INT 3
2168: PUSH
2169: LD_INT 46
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: PUSH
2178: LD_INT 23
2180: PUSH
2181: LD_INT 1
2183: PUSH
2184: LD_INT 1
2186: PUSH
2187: LD_INT 46
2189: PUSH
2190: EMPTY
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_INT 23
2198: PUSH
2199: LD_INT 1
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 45
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 23
2216: PUSH
2217: LD_INT 1
2219: PUSH
2220: LD_INT 1
2222: PUSH
2223: LD_INT 47
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 23
2234: PUSH
2235: LD_INT 1
2237: PUSH
2238: LD_INT 3
2240: PUSH
2241: LD_INT 46
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 21
2252: PUSH
2253: LD_INT 1
2255: PUSH
2256: LD_INT 3
2258: PUSH
2259: LD_INT 51
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: LD_INT 21
2270: PUSH
2271: LD_INT 1
2273: PUSH
2274: LD_INT 3
2276: PUSH
2277: LD_INT 52
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: LIST
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: PPUSH
2295: CALL 85533 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2299: LD_EXP 8
2303: PPUSH
2304: LD_INT 11
2306: PPUSH
2307: CALL 86854 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2311: LD_EXP 8
2315: PPUSH
2316: LD_INT 12
2318: PPUSH
2319: CALL 86798 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2323: LD_EXP 8
2327: PPUSH
2328: LD_INT 43
2330: PUSH
2331: LD_INT 47
2333: PUSH
2334: LD_INT 45
2336: PUSH
2337: LD_INT 49
2339: PUSH
2340: LD_INT 46
2342: PUSH
2343: EMPTY
2344: LIST
2345: LIST
2346: LIST
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL 86686 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2354: LD_EXP 8
2358: PPUSH
2359: LD_INT 13
2361: PPUSH
2362: CALL 86368 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2366: LD_EXP 8
2370: PPUSH
2371: LD_INT 11
2373: PPUSH
2374: CALL 86099 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2378: LD_EXP 8
2382: PPUSH
2383: LD_INT 4
2385: PPUSH
2386: CALL 85718 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2390: LD_EXP 8
2394: PPUSH
2395: LD_INT 115
2397: PUSH
2398: LD_INT 201
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: EMPTY
2406: LIST
2407: PPUSH
2408: CALL 86424 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2412: LD_EXP 8
2416: PPUSH
2417: LD_INT 24
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 3
2425: PUSH
2426: LD_INT 46
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_INT 24
2437: PUSH
2438: LD_INT 3
2440: PUSH
2441: LD_INT 3
2443: PUSH
2444: LD_INT 46
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 24
2455: PUSH
2456: LD_INT 3
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 46
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 24
2473: PUSH
2474: LD_INT 3
2476: PUSH
2477: LD_INT 3
2479: PUSH
2480: LD_INT 46
2482: PUSH
2483: EMPTY
2484: LIST
2485: LIST
2486: LIST
2487: LIST
2488: PUSH
2489: EMPTY
2490: LIST
2491: LIST
2492: LIST
2493: LIST
2494: PPUSH
2495: CALL 85533 0 2
// end ;
2499: LD_VAR 0 1
2503: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2504: LD_INT 0
2506: PPUSH
2507: PPUSH
2508: PPUSH
2509: PPUSH
2510: PPUSH
2511: PPUSH
2512: PPUSH
2513: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2514: LD_INT 0
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: LD_INT 0
2525: PPUSH
2526: LD_INT 0
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 0
2534: PPUSH
2535: LD_INT 14
2537: PPUSH
2538: LD_INT 0
2540: PPUSH
2541: CALL 54041 0 9
// side := 3 ;
2545: LD_ADDR_VAR 0 5
2549: PUSH
2550: LD_INT 3
2552: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2553: LD_INT 38
2555: PPUSH
2556: LD_VAR 0 5
2560: PPUSH
2561: LD_INT 2
2563: PPUSH
2564: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2568: LD_INT 39
2570: PPUSH
2571: LD_VAR 0 5
2575: PPUSH
2576: LD_INT 2
2578: PPUSH
2579: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2583: LD_INT 34
2585: PPUSH
2586: LD_VAR 0 5
2590: PPUSH
2591: LD_INT 2
2593: PPUSH
2594: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2598: LD_ADDR_VAR 0 4
2602: PUSH
2603: LD_INT 0
2605: PUSH
2606: LD_INT 208
2608: PUSH
2609: LD_INT 163
2611: PUSH
2612: LD_INT 4
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: LD_INT 0
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 3
2631: PUSH
2632: LD_INT 194
2634: PUSH
2635: LD_INT 161
2637: PUSH
2638: LD_INT 1
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: LD_INT 0
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: PUSH
2655: LD_INT 17
2657: PUSH
2658: LD_INT 190
2660: PUSH
2661: LD_INT 161
2663: PUSH
2664: LD_INT 1
2666: PUSH
2667: LD_INT 0
2669: PUSH
2670: LD_INT 0
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: LIST
2680: PUSH
2681: LD_INT 5
2683: PUSH
2684: LD_INT 200
2686: PUSH
2687: LD_INT 145
2689: PUSH
2690: LD_INT 3
2692: PUSH
2693: LD_INT 0
2695: PUSH
2696: LD_INT 0
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 32
2709: PUSH
2710: LD_INT 192
2712: PUSH
2713: LD_INT 144
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: LD_INT 0
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PUSH
2733: LD_INT 26
2735: PUSH
2736: LD_INT 216
2738: PUSH
2739: LD_INT 172
2741: PUSH
2742: LD_INT 3
2744: PUSH
2745: LD_INT 0
2747: PUSH
2748: LD_INT 0
2750: PUSH
2751: EMPTY
2752: LIST
2753: LIST
2754: LIST
2755: LIST
2756: LIST
2757: LIST
2758: PUSH
2759: LD_INT 26
2761: PUSH
2762: LD_INT 218
2764: PUSH
2765: LD_INT 176
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: LD_INT 0
2773: PUSH
2774: LD_INT 0
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 29
2787: PUSH
2788: LD_INT 182
2790: PUSH
2791: LD_INT 149
2793: PUSH
2794: LD_INT 3
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: LD_INT 0
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: LD_INT 201
2816: PUSH
2817: LD_INT 171
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: LD_INT 11
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 32
2839: PUSH
2840: LD_INT 188
2842: PUSH
2843: LD_INT 167
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: LD_INT 0
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: PUSH
2863: LD_INT 32
2865: PUSH
2866: LD_INT 202
2868: PUSH
2869: LD_INT 179
2871: PUSH
2872: LD_INT 0
2874: PUSH
2875: LD_INT 0
2877: PUSH
2878: LD_INT 0
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: PUSH
2889: LD_INT 32
2891: PUSH
2892: LD_INT 209
2894: PUSH
2895: LD_INT 182
2897: PUSH
2898: LD_INT 0
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: LD_INT 0
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: PUSH
2915: LD_INT 32
2917: PUSH
2918: LD_INT 220
2920: PUSH
2921: LD_INT 183
2923: PUSH
2924: LD_INT 5
2926: PUSH
2927: LD_INT 0
2929: PUSH
2930: LD_INT 0
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: PUSH
2941: LD_INT 32
2943: PUSH
2944: LD_INT 225
2946: PUSH
2947: LD_INT 181
2949: PUSH
2950: LD_INT 5
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 0
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: PUSH
2967: LD_INT 26
2969: PUSH
2970: LD_INT 220
2972: PUSH
2973: LD_INT 174
2975: PUSH
2976: LD_INT 5
2978: PUSH
2979: LD_INT 0
2981: PUSH
2982: LD_INT 0
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 84
2998: PUSH
2999: LD_INT 128
3001: PUSH
3002: LD_INT 4
3004: PUSH
3005: LD_INT 0
3007: PUSH
3008: LD_INT 0
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 3
3021: PUSH
3022: LD_INT 68
3024: PUSH
3025: LD_INT 121
3027: PUSH
3028: LD_INT 1
3030: PUSH
3031: LD_INT 0
3033: PUSH
3034: LD_INT 0
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 19
3047: PUSH
3048: LD_INT 72
3050: PUSH
3051: LD_INT 125
3053: PUSH
3054: LD_INT 5
3056: PUSH
3057: LD_INT 0
3059: PUSH
3060: LD_INT 0
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: PUSH
3071: LD_INT 18
3073: PUSH
3074: LD_INT 68
3076: PUSH
3077: LD_INT 124
3079: PUSH
3080: LD_INT 0
3082: PUSH
3083: LD_INT 0
3085: PUSH
3086: LD_INT 0
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_INT 24
3099: PUSH
3100: LD_INT 64
3102: PUSH
3103: LD_INT 121
3105: PUSH
3106: LD_INT 1
3108: PUSH
3109: LD_INT 0
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 17
3125: PUSH
3126: LD_INT 65
3128: PUSH
3129: LD_INT 118
3131: PUSH
3132: LD_INT 2
3134: PUSH
3135: LD_INT 0
3137: PUSH
3138: LD_INT 0
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 21
3151: PUSH
3152: LD_INT 68
3154: PUSH
3155: LD_INT 117
3157: PUSH
3158: LD_INT 3
3160: PUSH
3161: LD_INT 0
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: PUSH
3175: LD_INT 8
3177: PUSH
3178: LD_INT 68
3180: PUSH
3181: LD_INT 130
3183: PUSH
3184: LD_INT 1
3186: PUSH
3187: LD_INT 14
3189: PUSH
3190: LD_INT 10
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: PUSH
3201: LD_INT 8
3203: PUSH
3204: LD_INT 67
3206: PUSH
3207: LD_INT 110
3209: PUSH
3210: LD_INT 2
3212: PUSH
3213: LD_INT 11
3215: PUSH
3216: LD_INT 12
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 28
3229: PUSH
3230: LD_INT 85
3232: PUSH
3233: LD_INT 108
3235: PUSH
3236: LD_INT 2
3238: PUSH
3239: LD_INT 0
3241: PUSH
3242: LD_INT 0
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 28
3255: PUSH
3256: LD_INT 85
3258: PUSH
3259: LD_INT 124
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: LD_INT 0
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 30
3281: PUSH
3282: LD_INT 97
3284: PUSH
3285: LD_INT 119
3287: PUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 0
3293: PUSH
3294: LD_INT 0
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: PUSH
3305: LD_INT 5
3307: PUSH
3308: LD_INT 111
3310: PUSH
3311: LD_INT 138
3313: PUSH
3314: LD_INT 4
3316: PUSH
3317: LD_INT 0
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 33
3333: PUSH
3334: LD_INT 104
3336: PUSH
3337: LD_INT 130
3339: PUSH
3340: LD_INT 3
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 33
3359: PUSH
3360: LD_INT 110
3362: PUSH
3363: LD_INT 142
3365: PUSH
3366: LD_INT 5
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 33
3385: PUSH
3386: LD_INT 91
3388: PUSH
3389: LD_INT 131
3391: PUSH
3392: LD_INT 5
3394: PUSH
3395: LD_INT 0
3397: PUSH
3398: LD_INT 0
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 33
3411: PUSH
3412: LD_INT 107
3414: PUSH
3415: LD_INT 157
3417: PUSH
3418: LD_INT 5
3420: PUSH
3421: LD_INT 0
3423: PUSH
3424: LD_INT 0
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 33
3437: PUSH
3438: LD_INT 104
3440: PUSH
3441: LD_INT 160
3443: PUSH
3444: LD_INT 5
3446: PUSH
3447: LD_INT 0
3449: PUSH
3450: LD_INT 0
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 33
3463: PUSH
3464: LD_INT 101
3466: PUSH
3467: LD_INT 162
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 0
3475: PUSH
3476: LD_INT 0
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 32
3489: PUSH
3490: LD_INT 87
3492: PUSH
3493: LD_INT 157
3495: PUSH
3496: LD_INT 5
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: LD_INT 0
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 32
3515: PUSH
3516: LD_INT 105
3518: PUSH
3519: LD_INT 158
3521: PUSH
3522: LD_INT 5
3524: PUSH
3525: LD_INT 0
3527: PUSH
3528: LD_INT 0
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 33
3541: PUSH
3542: LD_INT 91
3544: PUSH
3545: LD_INT 118
3547: PUSH
3548: LD_INT 4
3550: PUSH
3551: LD_INT 0
3553: PUSH
3554: LD_INT 0
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 33
3567: PUSH
3568: LD_INT 89
3570: PUSH
3571: LD_INT 107
3573: PUSH
3574: LD_INT 4
3576: PUSH
3577: LD_INT 0
3579: PUSH
3580: LD_INT 0
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 86
3596: PUSH
3597: LD_INT 96
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: LD_INT 0
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 33
3619: PUSH
3620: LD_INT 91
3622: PUSH
3623: LD_INT 102
3625: PUSH
3626: LD_INT 4
3628: PUSH
3629: LD_INT 0
3631: PUSH
3632: LD_INT 0
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 32
3645: PUSH
3646: LD_INT 80
3648: PUSH
3649: LD_INT 95
3651: PUSH
3652: LD_INT 3
3654: PUSH
3655: LD_INT 0
3657: PUSH
3658: LD_INT 0
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 28
3671: PUSH
3672: LD_INT 77
3674: PUSH
3675: LD_INT 105
3677: PUSH
3678: LD_INT 3
3680: PUSH
3681: LD_INT 0
3683: PUSH
3684: LD_INT 0
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: LIST
3692: LIST
3693: LIST
3694: PUSH
3695: LD_INT 28
3697: PUSH
3698: LD_INT 85
3700: PUSH
3701: LD_INT 113
3703: PUSH
3704: LD_INT 3
3706: PUSH
3707: LD_INT 0
3709: PUSH
3710: LD_INT 0
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 28
3723: PUSH
3724: LD_INT 55
3726: PUSH
3727: LD_INT 97
3729: PUSH
3730: LD_INT 3
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 0
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 28
3749: PUSH
3750: LD_INT 88
3752: PUSH
3753: LD_INT 128
3755: PUSH
3756: LD_INT 3
3758: PUSH
3759: LD_INT 0
3761: PUSH
3762: LD_INT 0
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 32
3775: PUSH
3776: LD_INT 69
3778: PUSH
3779: LD_INT 101
3781: PUSH
3782: LD_INT 2
3784: PUSH
3785: LD_INT 0
3787: PUSH
3788: LD_INT 0
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: PUSH
3799: LD_INT 1
3801: PUSH
3802: LD_INT 34
3804: PUSH
3805: LD_INT 23
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: LD_INT 0
3813: PUSH
3814: LD_INT 0
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 25
3830: PUSH
3831: LD_INT 4
3833: PUSH
3834: LD_INT 3
3836: PUSH
3837: LD_INT 11
3839: PUSH
3840: LD_INT 10
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 8
3853: PUSH
3854: LD_INT 15
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: LD_INT 2
3862: PUSH
3863: LD_INT 14
3865: PUSH
3866: LD_INT 12
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 29
3879: PUSH
3880: LD_INT 55
3882: PUSH
3883: LD_INT 35
3885: PUSH
3886: LD_INT 2
3888: PUSH
3889: LD_INT 0
3891: PUSH
3892: LD_INT 0
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 29
3905: PUSH
3906: LD_INT 24
3908: PUSH
3909: LD_INT 44
3911: PUSH
3912: LD_INT 2
3914: PUSH
3915: LD_INT 0
3917: PUSH
3918: LD_INT 0
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: PUSH
3929: LD_INT 34
3931: PUSH
3932: LD_INT 34
3934: PUSH
3935: LD_INT 32
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: LD_INT 0
3943: PUSH
3944: LD_INT 0
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: PUSH
3955: LD_INT 3
3957: PUSH
3958: LD_INT 14
3960: PUSH
3961: LD_INT 16
3963: PUSH
3964: LD_INT 1
3966: PUSH
3967: LD_INT 0
3969: PUSH
3970: LD_INT 0
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: PUSH
3981: LD_INT 24
3983: PUSH
3984: LD_INT 10
3986: PUSH
3987: LD_INT 16
3989: PUSH
3990: LD_INT 1
3992: PUSH
3993: LD_INT 0
3995: PUSH
3996: LD_INT 0
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_INT 21
4009: PUSH
4010: LD_INT 11
4012: PUSH
4013: LD_INT 13
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: LD_INT 0
4021: PUSH
4022: LD_INT 0
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: PUSH
4033: LD_INT 18
4035: PUSH
4036: LD_INT 14
4038: PUSH
4039: LD_INT 12
4041: PUSH
4042: LD_INT 3
4044: PUSH
4045: LD_INT 0
4047: PUSH
4048: LD_INT 0
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: PUSH
4059: LD_INT 16
4061: PUSH
4062: LD_INT 14
4064: PUSH
4065: LD_INT 19
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: LD_INT 0
4073: PUSH
4074: LD_INT 0
4076: PUSH
4077: EMPTY
4078: LIST
4079: LIST
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 17
4087: PUSH
4088: LD_INT 18
4090: PUSH
4091: LD_INT 20
4093: PUSH
4094: LD_INT 5
4096: PUSH
4097: LD_INT 0
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: PUSH
4111: LD_INT 28
4113: PUSH
4114: LD_INT 10
4116: PUSH
4117: LD_INT 5
4119: PUSH
4120: LD_INT 1
4122: PUSH
4123: LD_INT 0
4125: PUSH
4126: LD_INT 0
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: PUSH
4137: LD_INT 28
4139: PUSH
4140: LD_INT 8
4142: PUSH
4143: LD_INT 8
4145: PUSH
4146: LD_INT 1
4148: PUSH
4149: LD_INT 0
4151: PUSH
4152: LD_INT 0
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: PUSH
4163: LD_INT 26
4165: PUSH
4166: LD_INT 19
4168: PUSH
4169: LD_INT 2
4171: PUSH
4172: LD_INT 1
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: LD_INT 0
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: PUSH
4189: LD_INT 26
4191: PUSH
4192: LD_INT 30
4194: PUSH
4195: LD_INT 2
4197: PUSH
4198: LD_INT 1
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: LD_INT 0
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 5
4217: PUSH
4218: LD_INT 59
4220: PUSH
4221: LD_INT 20
4223: PUSH
4224: LD_INT 4
4226: PUSH
4227: LD_INT 0
4229: PUSH
4230: LD_INT 0
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 32
4243: PUSH
4244: LD_INT 60
4246: PUSH
4247: LD_INT 24
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: LD_INT 0
4255: PUSH
4256: LD_INT 0
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 32
4269: PUSH
4270: LD_INT 61
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 5
4278: PUSH
4279: LD_INT 0
4281: PUSH
4282: LD_INT 0
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 32
4295: PUSH
4296: LD_INT 52
4298: PUSH
4299: LD_INT 51
4301: PUSH
4302: LD_INT 5
4304: PUSH
4305: LD_INT 0
4307: PUSH
4308: LD_INT 0
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: LD_INT 56
4324: PUSH
4325: LD_INT 51
4327: PUSH
4328: LD_INT 5
4330: PUSH
4331: LD_INT 0
4333: PUSH
4334: LD_INT 0
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 33
4347: PUSH
4348: LD_INT 62
4350: PUSH
4351: LD_INT 49
4353: PUSH
4354: LD_INT 5
4356: PUSH
4357: LD_INT 0
4359: PUSH
4360: LD_INT 0
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 33
4373: PUSH
4374: LD_INT 41
4376: PUSH
4377: LD_INT 47
4379: PUSH
4380: LD_INT 5
4382: PUSH
4383: LD_INT 0
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 33
4399: PUSH
4400: LD_INT 33
4402: PUSH
4403: LD_INT 52
4405: PUSH
4406: LD_INT 5
4408: PUSH
4409: LD_INT 0
4411: PUSH
4412: LD_INT 0
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: LD_INT 31
4428: PUSH
4429: LD_INT 40
4431: PUSH
4432: LD_INT 0
4434: PUSH
4435: LD_INT 0
4437: PUSH
4438: LD_INT 0
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: PUSH
4449: LD_INT 33
4451: PUSH
4452: LD_INT 65
4454: PUSH
4455: LD_INT 37
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: LD_INT 0
4463: PUSH
4464: LD_INT 0
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 33
4477: PUSH
4478: LD_INT 63
4480: PUSH
4481: LD_INT 29
4483: PUSH
4484: LD_INT 4
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: LD_INT 0
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: PUSH
4501: LD_INT 33
4503: PUSH
4504: LD_INT 54
4506: PUSH
4507: LD_INT 11
4509: PUSH
4510: LD_INT 4
4512: PUSH
4513: LD_INT 0
4515: PUSH
4516: LD_INT 0
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 33
4529: PUSH
4530: LD_INT 56
4532: PUSH
4533: LD_INT 15
4535: PUSH
4536: LD_INT 4
4538: PUSH
4539: LD_INT 0
4541: PUSH
4542: LD_INT 0
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 33
4555: PUSH
4556: LD_INT 51
4558: PUSH
4559: LD_INT 6
4561: PUSH
4562: LD_INT 4
4564: PUSH
4565: LD_INT 0
4567: PUSH
4568: LD_INT 0
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 26
4581: PUSH
4582: LD_INT 39
4584: PUSH
4585: LD_INT 25
4587: PUSH
4588: LD_INT 0
4590: PUSH
4591: LD_INT 0
4593: PUSH
4594: LD_INT 0
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: PUSH
4605: LD_INT 26
4607: PUSH
4608: LD_INT 37
4610: PUSH
4611: LD_INT 21
4613: PUSH
4614: LD_INT 0
4616: PUSH
4617: LD_INT 0
4619: PUSH
4620: LD_INT 0
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: PUSH
4631: LD_INT 32
4633: PUSH
4634: LD_INT 35
4636: PUSH
4637: LD_INT 17
4639: PUSH
4640: LD_INT 4
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 0
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 33
4659: PUSH
4660: LD_INT 35
4662: PUSH
4663: LD_INT 28
4665: PUSH
4666: LD_INT 4
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: LD_INT 0
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 28
4688: PUSH
4689: LD_INT 46
4691: PUSH
4692: LD_INT 5
4694: PUSH
4695: LD_INT 0
4697: PUSH
4698: LD_INT 0
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: PUSH
4709: LD_INT 33
4711: PUSH
4712: LD_INT 31
4714: PUSH
4715: LD_INT 6
4717: PUSH
4718: LD_INT 4
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: LD_INT 0
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 26
4737: PUSH
4738: LD_INT 54
4740: PUSH
4741: LD_INT 38
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 0
4749: PUSH
4750: LD_INT 0
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_INT 33
4763: PUSH
4764: LD_INT 207
4766: PUSH
4767: LD_INT 167
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: LD_INT 0
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 30
4789: PUSH
4790: LD_INT 43
4792: PUSH
4793: LD_INT 2
4795: PUSH
4796: LD_INT 4
4798: PUSH
4799: LD_INT 0
4801: PUSH
4802: LD_INT 0
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: ST_TO_ADDR
// for i in tmp do
4900: LD_ADDR_VAR 0 2
4904: PUSH
4905: LD_VAR 0 4
4909: PUSH
4910: FOR_IN
4911: IFFALSE 5142
// begin uc_side := side ;
4913: LD_ADDR_OWVAR 20
4917: PUSH
4918: LD_VAR 0 5
4922: ST_TO_ADDR
// uc_nation := nation_russian ;
4923: LD_ADDR_OWVAR 21
4927: PUSH
4928: LD_INT 3
4930: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4931: LD_ADDR_OWVAR 42
4935: PUSH
4936: LD_VAR 0 2
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4945: LD_ADDR_OWVAR 43
4949: PUSH
4950: LD_INT 5
4952: PPUSH
4953: LD_INT 6
4955: PPUSH
4956: CALL_OW 12
4960: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4961: LD_ADDR_OWVAR 44
4965: PUSH
4966: LD_VAR 0 2
4970: PUSH
4971: LD_INT 5
4973: ARRAY
4974: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4975: LD_ADDR_OWVAR 45
4979: PUSH
4980: LD_VAR 0 2
4984: PUSH
4985: LD_INT 6
4987: ARRAY
4988: ST_TO_ADDR
// sr := 0 ;
4989: LD_ADDR_VAR 0 6
4993: PUSH
4994: LD_INT 0
4996: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4997: LD_VAR 0 2
5001: PUSH
5002: LD_INT 1
5004: ARRAY
5005: PUSH
5006: LD_INT 29
5008: EQUAL
5009: IFFALSE 5021
// sr := mat_oil else
5011: LD_ADDR_VAR 0 6
5015: PUSH
5016: LD_INT 2
5018: ST_TO_ADDR
5019: GO 5043
// if i [ 1 ] = b_siberite_mine then
5021: LD_VAR 0 2
5025: PUSH
5026: LD_INT 1
5028: ARRAY
5029: PUSH
5030: LD_INT 30
5032: EQUAL
5033: IFFALSE 5043
// sr := mat_siberit ;
5035: LD_ADDR_VAR 0 6
5039: PUSH
5040: LD_INT 3
5042: ST_TO_ADDR
// if sr then
5043: LD_VAR 0 6
5047: IFFALSE 5103
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5049: LD_VAR 0 2
5053: PUSH
5054: LD_INT 2
5056: ARRAY
5057: PPUSH
5058: LD_VAR 0 2
5062: PUSH
5063: LD_INT 3
5065: ARRAY
5066: PPUSH
5067: LD_VAR 0 6
5071: PPUSH
5072: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5076: LD_VAR 0 2
5080: PUSH
5081: LD_INT 2
5083: ARRAY
5084: PPUSH
5085: LD_VAR 0 2
5089: PUSH
5090: LD_INT 3
5092: ARRAY
5093: PPUSH
5094: LD_VAR 0 5
5098: PPUSH
5099: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5103: LD_ADDR_VAR 0 3
5107: PUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_INT 2
5115: ARRAY
5116: PPUSH
5117: LD_VAR 0 2
5121: PUSH
5122: LD_INT 3
5124: ARRAY
5125: PPUSH
5126: LD_VAR 0 2
5130: PUSH
5131: LD_INT 4
5133: ARRAY
5134: PPUSH
5135: CALL_OW 47
5139: ST_TO_ADDR
// end ;
5140: GO 4910
5142: POP
5143: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5144: LD_ADDR_VAR 0 7
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_VAR 0 5
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PUSH
5161: LD_INT 30
5163: PUSH
5164: LD_INT 1
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PPUSH
5175: CALL_OW 69
5179: ST_TO_ADDR
// if not depot then
5180: LD_VAR 0 7
5184: NOT
5185: IFFALSE 5189
// exit ;
5187: GO 5533
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5189: LD_ADDR_VAR 0 8
5193: PUSH
5194: LD_INT 84
5196: PPUSH
5197: LD_INT 128
5199: PPUSH
5200: CALL_OW 428
5204: PPUSH
5205: LD_INT 15
5207: PPUSH
5208: LD_INT 0
5210: PPUSH
5211: LD_INT 6
5213: PUSH
5214: LD_INT 7
5216: PUSH
5217: LD_INT 8
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: LIST
5224: PUSH
5225: LD_OWVAR 67
5229: ARRAY
5230: PPUSH
5231: LD_INT 3000
5233: PUSH
5234: LD_INT 300
5236: PUSH
5237: LD_INT 100
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: LD_INT 12
5247: PUSH
5248: LD_INT 6
5250: PUSH
5251: LD_INT 6
5253: PUSH
5254: LD_INT 4
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL 28343 0 6
5267: ST_TO_ADDR
// if not base then
5268: LD_VAR 0 8
5272: NOT
5273: IFFALSE 5277
// exit ;
5275: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5277: LD_ADDR_EXP 31
5281: PUSH
5282: LD_EXP 31
5286: PPUSH
5287: LD_EXP 7
5291: PPUSH
5292: LD_VAR 0 8
5296: PPUSH
5297: CALL_OW 1
5301: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5302: LD_ADDR_VAR 0 8
5306: PUSH
5307: LD_INT 34
5309: PPUSH
5310: LD_INT 23
5312: PPUSH
5313: CALL_OW 428
5317: PPUSH
5318: LD_INT 11
5320: PPUSH
5321: LD_INT 0
5323: PPUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 7
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PPUSH
5344: LD_INT 20000
5346: PUSH
5347: LD_INT 3000
5349: PUSH
5350: LD_INT 1000
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: PPUSH
5358: LD_INT 12
5360: PUSH
5361: LD_INT 6
5363: PUSH
5364: LD_INT 6
5366: PUSH
5367: LD_INT 4
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL 28343 0 6
5380: ST_TO_ADDR
// if not base then
5381: LD_VAR 0 8
5385: NOT
5386: IFFALSE 5390
// exit ;
5388: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5390: LD_ADDR_EXP 31
5394: PUSH
5395: LD_EXP 31
5399: PPUSH
5400: LD_EXP 8
5404: PPUSH
5405: LD_VAR 0 8
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5415: LD_ADDR_EXP 14
5419: PUSH
5420: LD_INT 22
5422: PUSH
5423: LD_INT 3
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 30
5432: PUSH
5433: LD_INT 0
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: PUSH
5449: LD_INT 1
5451: ARRAY
5452: PPUSH
5453: LD_INT 25
5455: PPUSH
5456: LD_INT 0
5458: PPUSH
5459: LD_INT 6
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: LD_INT 8
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_OWVAR 67
5477: ARRAY
5478: PPUSH
5479: LD_INT 500
5481: PUSH
5482: LD_INT 100
5484: PUSH
5485: LD_INT 10
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: PPUSH
5493: LD_INT 6
5495: PUSH
5496: LD_INT 7
5498: PUSH
5499: LD_INT 8
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: LIST
5506: PUSH
5507: LD_OWVAR 67
5511: ARRAY
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: LD_INT 0
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: PPUSH
5528: CALL 28343 0 6
5532: ST_TO_ADDR
// end ;
5533: LD_VAR 0 1
5537: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5538: LD_INT 0
5540: PPUSH
5541: PPUSH
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5551: LD_INT 0
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: LD_INT 6
5559: PPUSH
5560: LD_INT 0
5562: PPUSH
5563: LD_INT 0
5565: PPUSH
5566: LD_INT 0
5568: PPUSH
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 8
5574: PPUSH
5575: LD_INT 0
5577: PPUSH
5578: CALL 54041 0 9
// side := 8 ;
5582: LD_ADDR_VAR 0 8
5586: PUSH
5587: LD_INT 8
5589: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5590: LD_ADDR_VAR 0 5
5594: PUSH
5595: LD_INT 20
5597: PPUSH
5598: LD_INT 0
5600: PPUSH
5601: CALL_OW 517
5605: ST_TO_ADDR
// if Difficulty > 2 then
5606: LD_OWVAR 67
5610: PUSH
5611: LD_INT 2
5613: GREATER
5614: IFFALSE 5758
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5616: LD_ADDR_VAR 0 6
5620: PUSH
5621: LD_INT 27
5623: PPUSH
5624: LD_INT 0
5626: PPUSH
5627: CALL_OW 517
5631: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5632: LD_ADDR_VAR 0 2
5636: PUSH
5637: DOUBLE
5638: LD_INT 1
5640: DEC
5641: ST_TO_ADDR
5642: LD_VAR 0 6
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PUSH
5651: FOR_TO
5652: IFFALSE 5756
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5654: LD_ADDR_VAR 0 5
5658: PUSH
5659: LD_VAR 0 5
5663: PPUSH
5664: LD_INT 1
5666: PUSH
5667: LD_VAR 0 5
5671: PUSH
5672: LD_INT 1
5674: ARRAY
5675: PUSH
5676: LD_INT 1
5678: PLUS
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PPUSH
5684: LD_VAR 0 6
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: CALL 25021 0 3
5703: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5704: LD_ADDR_VAR 0 5
5708: PUSH
5709: LD_VAR 0 5
5713: PPUSH
5714: LD_INT 2
5716: PUSH
5717: LD_VAR 0 5
5721: PUSH
5722: LD_INT 2
5724: ARRAY
5725: PUSH
5726: LD_INT 1
5728: PLUS
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: PPUSH
5734: LD_VAR 0 6
5738: PUSH
5739: LD_INT 2
5741: ARRAY
5742: PUSH
5743: LD_VAR 0 2
5747: ARRAY
5748: PPUSH
5749: CALL 25021 0 3
5753: ST_TO_ADDR
// end ;
5754: GO 5651
5756: POP
5757: POP
// end ; if tmp then
5758: LD_VAR 0 5
5762: IFFALSE 5890
// begin for i = 1 to tmp [ 1 ] do
5764: LD_ADDR_VAR 0 2
5768: PUSH
5769: DOUBLE
5770: LD_INT 1
5772: DEC
5773: ST_TO_ADDR
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 1
5781: ARRAY
5782: PUSH
5783: FOR_TO
5784: IFFALSE 5888
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5786: LD_VAR 0 5
5790: PUSH
5791: LD_INT 1
5793: ARRAY
5794: PUSH
5795: LD_VAR 0 2
5799: ARRAY
5800: PPUSH
5801: LD_VAR 0 5
5805: PUSH
5806: LD_INT 2
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 2
5814: ARRAY
5815: PPUSH
5816: LD_VAR 0 8
5820: PPUSH
5821: LD_INT 0
5823: PPUSH
5824: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5828: LD_ADDR_EXP 16
5832: PUSH
5833: LD_EXP 16
5837: PPUSH
5838: LD_EXP 16
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PPUSH
5847: LD_VAR 0 5
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PUSH
5856: LD_VAR 0 2
5860: ARRAY
5861: PUSH
5862: LD_VAR 0 5
5866: PUSH
5867: LD_INT 2
5869: ARRAY
5870: PUSH
5871: LD_VAR 0 2
5875: ARRAY
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: PPUSH
5881: CALL_OW 2
5885: ST_TO_ADDR
// end ;
5886: GO 5783
5888: POP
5889: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5890: LD_ADDR_VAR 0 7
5894: PUSH
5895: LD_INT 165
5897: PUSH
5898: LD_INT 156
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 143
5907: PUSH
5908: LD_INT 145
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 152
5917: PUSH
5918: LD_INT 165
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 123
5927: PUSH
5928: LD_INT 153
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 161
5937: PUSH
5938: LD_INT 215
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PUSH
5945: LD_INT 172
5947: PUSH
5948: LD_INT 100
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PUSH
5955: LD_INT 148
5957: PUSH
5958: LD_INT 83
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: PUSH
5965: LD_INT 122
5967: PUSH
5968: LD_INT 68
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 105
5977: PUSH
5978: LD_INT 74
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 113
5987: PUSH
5988: LD_INT 97
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: ST_TO_ADDR
// for i in cameras do
6007: LD_ADDR_VAR 0 2
6011: PUSH
6012: LD_VAR 0 7
6016: PUSH
6017: FOR_IN
6018: IFFALSE 6049
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
6020: LD_VAR 0 2
6024: PUSH
6025: LD_INT 1
6027: ARRAY
6028: PPUSH
6029: LD_VAR 0 2
6033: PUSH
6034: LD_INT 2
6036: ARRAY
6037: PPUSH
6038: LD_VAR 0 8
6042: PPUSH
6043: CALL_OW 244
6047: GO 6017
6049: POP
6050: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6051: LD_ADDR_VAR 0 5
6055: PUSH
6056: LD_INT 1
6058: PUSH
6059: LD_INT 144
6061: PUSH
6062: LD_INT 110
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: LD_INT 0
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 3
6084: PUSH
6085: LD_INT 151
6087: PUSH
6088: LD_INT 118
6090: PUSH
6091: LD_INT 0
6093: PUSH
6094: LD_INT 0
6096: PUSH
6097: LD_INT 0
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: LD_INT 158
6113: PUSH
6114: LD_INT 110
6116: PUSH
6117: LD_INT 4
6119: PUSH
6120: LD_INT 10
6122: PUSH
6123: LD_INT 15
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: PUSH
6134: LD_INT 23
6136: PUSH
6137: LD_INT 154
6139: PUSH
6140: LD_INT 121
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 155
6165: PUSH
6166: LD_INT 118
6168: PUSH
6169: LD_INT 4
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: LD_INT 0
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_INT 21
6188: PUSH
6189: LD_INT 151
6191: PUSH
6192: LD_INT 122
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: LD_INT 0
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 18
6214: PUSH
6215: LD_INT 148
6217: PUSH
6218: LD_INT 118
6220: PUSH
6221: LD_INT 1
6223: PUSH
6224: LD_INT 0
6226: PUSH
6227: LD_INT 0
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 17
6240: PUSH
6241: LD_INT 147
6243: PUSH
6244: LD_INT 114
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 0
6252: PUSH
6253: LD_INT 0
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 29
6266: PUSH
6267: LD_INT 163
6269: PUSH
6270: LD_INT 120
6272: PUSH
6273: LD_INT 5
6275: PUSH
6276: LD_INT 0
6278: PUSH
6279: LD_INT 0
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 27
6292: PUSH
6293: LD_INT 137
6295: PUSH
6296: LD_INT 116
6298: PUSH
6299: LD_INT 3
6301: PUSH
6302: LD_INT 0
6304: PUSH
6305: LD_INT 0
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 27
6318: PUSH
6319: LD_INT 133
6321: PUSH
6322: LD_INT 111
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: LD_INT 0
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 27
6344: PUSH
6345: LD_INT 132
6347: PUSH
6348: LD_INT 106
6350: PUSH
6351: LD_INT 4
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 26
6370: PUSH
6371: LD_INT 137
6373: PUSH
6374: LD_INT 111
6376: PUSH
6377: LD_INT 0
6379: PUSH
6380: LD_INT 0
6382: PUSH
6383: LD_INT 0
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 141
6399: PUSH
6400: LD_INT 117
6402: PUSH
6403: LD_INT 1
6405: PUSH
6406: LD_INT 13
6408: PUSH
6409: LD_INT 11
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 30
6422: PUSH
6423: LD_INT 140
6425: PUSH
6426: LD_INT 128
6428: PUSH
6429: LD_INT 1
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: LD_INT 0
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 5
6448: PUSH
6449: LD_INT 146
6451: PUSH
6452: LD_INT 96
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 32
6474: PUSH
6475: LD_INT 150
6477: PUSH
6478: LD_INT 98
6480: PUSH
6481: LD_INT 3
6483: PUSH
6484: LD_INT 0
6486: PUSH
6487: LD_INT 0
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 32
6500: PUSH
6501: LD_INT 142
6503: PUSH
6504: LD_INT 95
6506: PUSH
6507: LD_INT 3
6509: PUSH
6510: LD_INT 0
6512: PUSH
6513: LD_INT 0
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 32
6526: PUSH
6527: LD_INT 159
6529: PUSH
6530: LD_INT 104
6532: PUSH
6533: LD_INT 3
6535: PUSH
6536: LD_INT 0
6538: PUSH
6539: LD_INT 0
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: LD_INT 32
6552: PUSH
6553: LD_INT 133
6555: PUSH
6556: LD_INT 95
6558: PUSH
6559: LD_INT 3
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: LD_INT 0
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 32
6578: PUSH
6579: LD_INT 131
6581: PUSH
6582: LD_INT 102
6584: PUSH
6585: LD_INT 2
6587: PUSH
6588: LD_INT 0
6590: PUSH
6591: LD_INT 0
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 32
6604: PUSH
6605: LD_INT 164
6607: PUSH
6608: LD_INT 144
6610: PUSH
6611: LD_INT 0
6613: PUSH
6614: LD_INT 0
6616: PUSH
6617: LD_INT 0
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: LD_INT 146
6633: PUSH
6634: LD_INT 139
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: LD_INT 0
6642: PUSH
6643: LD_INT 0
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 26
6656: PUSH
6657: LD_INT 143
6659: PUSH
6660: LD_INT 122
6662: PUSH
6663: LD_INT 4
6665: PUSH
6666: LD_INT 0
6668: PUSH
6669: LD_INT 0
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 164
6685: PUSH
6686: LD_INT 116
6688: PUSH
6689: LD_INT 2
6691: PUSH
6692: LD_INT 0
6694: PUSH
6695: LD_INT 0
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: ST_TO_ADDR
// for i in tmp do
6733: LD_ADDR_VAR 0 2
6737: PUSH
6738: LD_VAR 0 5
6742: PUSH
6743: FOR_IN
6744: IFFALSE 6975
// begin uc_side := side ;
6746: LD_ADDR_OWVAR 20
6750: PUSH
6751: LD_VAR 0 8
6755: ST_TO_ADDR
// uc_nation := nation_arabian ;
6756: LD_ADDR_OWVAR 21
6760: PUSH
6761: LD_INT 2
6763: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6764: LD_ADDR_OWVAR 42
6768: PUSH
6769: LD_VAR 0 2
6773: PUSH
6774: LD_INT 1
6776: ARRAY
6777: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6778: LD_ADDR_OWVAR 43
6782: PUSH
6783: LD_INT 5
6785: PPUSH
6786: LD_INT 6
6788: PPUSH
6789: CALL_OW 12
6793: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6794: LD_ADDR_OWVAR 44
6798: PUSH
6799: LD_VAR 0 2
6803: PUSH
6804: LD_INT 5
6806: ARRAY
6807: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6808: LD_ADDR_OWVAR 45
6812: PUSH
6813: LD_VAR 0 2
6817: PUSH
6818: LD_INT 6
6820: ARRAY
6821: ST_TO_ADDR
// sr := 0 ;
6822: LD_ADDR_VAR 0 9
6826: PUSH
6827: LD_INT 0
6829: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6830: LD_VAR 0 2
6834: PUSH
6835: LD_INT 1
6837: ARRAY
6838: PUSH
6839: LD_INT 29
6841: EQUAL
6842: IFFALSE 6854
// sr := mat_oil else
6844: LD_ADDR_VAR 0 9
6848: PUSH
6849: LD_INT 2
6851: ST_TO_ADDR
6852: GO 6876
// if i [ 1 ] = b_siberite_mine then
6854: LD_VAR 0 2
6858: PUSH
6859: LD_INT 1
6861: ARRAY
6862: PUSH
6863: LD_INT 30
6865: EQUAL
6866: IFFALSE 6876
// sr := mat_siberit ;
6868: LD_ADDR_VAR 0 9
6872: PUSH
6873: LD_INT 3
6875: ST_TO_ADDR
// if sr then
6876: LD_VAR 0 9
6880: IFFALSE 6936
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6882: LD_VAR 0 2
6886: PUSH
6887: LD_INT 2
6889: ARRAY
6890: PPUSH
6891: LD_VAR 0 2
6895: PUSH
6896: LD_INT 3
6898: ARRAY
6899: PPUSH
6900: LD_VAR 0 9
6904: PPUSH
6905: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6909: LD_VAR 0 2
6913: PUSH
6914: LD_INT 2
6916: ARRAY
6917: PPUSH
6918: LD_VAR 0 2
6922: PUSH
6923: LD_INT 3
6925: ARRAY
6926: PPUSH
6927: LD_VAR 0 8
6931: PPUSH
6932: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6936: LD_ADDR_VAR 0 3
6940: PUSH
6941: LD_VAR 0 2
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PPUSH
6950: LD_VAR 0 2
6954: PUSH
6955: LD_INT 3
6957: ARRAY
6958: PPUSH
6959: LD_VAR 0 2
6963: PUSH
6964: LD_INT 4
6966: ARRAY
6967: PPUSH
6968: CALL_OW 47
6972: ST_TO_ADDR
// end ;
6973: GO 6743
6975: POP
6976: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6977: LD_ADDR_VAR 0 10
6981: PUSH
6982: LD_INT 22
6984: PUSH
6985: LD_VAR 0 8
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PPUSH
7008: CALL_OW 69
7012: ST_TO_ADDR
// if not depot then
7013: LD_VAR 0 10
7017: NOT
7018: IFFALSE 7022
// exit ;
7020: GO 7268
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
7022: LD_ADDR_VAR 0 11
7026: PUSH
7027: LD_VAR 0 10
7031: PUSH
7032: LD_INT 1
7034: ARRAY
7035: PPUSH
7036: LD_INT 6
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: LD_INT 7
7044: PUSH
7045: LD_INT 8
7047: PUSH
7048: LD_INT 10
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: LIST
7055: PUSH
7056: LD_OWVAR 67
7060: ARRAY
7061: PPUSH
7062: LD_INT 3000
7064: PUSH
7065: LD_INT 300
7067: PUSH
7068: LD_INT 100
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: PPUSH
7076: LD_INT 14
7078: PUSH
7079: LD_INT 6
7081: PUSH
7082: LD_INT 6
7084: PUSH
7085: LD_INT 5
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL 28343 0 6
7098: ST_TO_ADDR
// if not base then
7099: LD_VAR 0 11
7103: NOT
7104: IFFALSE 7108
// exit ;
7106: GO 7268
// if Difficulty > 1 then
7108: LD_OWVAR 67
7112: PUSH
7113: LD_INT 1
7115: GREATER
7116: IFFALSE 7189
// begin InitHc ;
7118: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7122: LD_INT 1
7124: PPUSH
7125: LD_INT 5
7127: PPUSH
7128: LD_INT 5
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: PUSH
7143: LD_INT 1
7145: MINUS
7146: ARRAY
7147: PPUSH
7148: CALL_OW 380
// for i = 1 to Difficulty do
7152: LD_ADDR_VAR 0 2
7156: PUSH
7157: DOUBLE
7158: LD_INT 1
7160: DEC
7161: ST_TO_ADDR
7162: LD_OWVAR 67
7166: PUSH
7167: FOR_TO
7168: IFFALSE 7187
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7170: CALL_OW 44
7174: PPUSH
7175: LD_INT 24
7177: PPUSH
7178: LD_INT 0
7180: PPUSH
7181: CALL_OW 49
7185: GO 7167
7187: POP
7188: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7189: LD_ADDR_EXP 31
7193: PUSH
7194: LD_EXP 31
7198: PPUSH
7199: LD_EXP 6
7203: PPUSH
7204: LD_VAR 0 11
7208: PPUSH
7209: CALL_OW 1
7213: ST_TO_ADDR
// hc_gallery := ru ;
7214: LD_ADDR_OWVAR 33
7218: PUSH
7219: LD_STRING ru
7221: ST_TO_ADDR
// hc_face_number := 44 ;
7222: LD_ADDR_OWVAR 34
7226: PUSH
7227: LD_INT 44
7229: ST_TO_ADDR
// hc_name := Robert Farmer ;
7230: LD_ADDR_OWVAR 26
7234: PUSH
7235: LD_STRING Robert Farmer
7237: ST_TO_ADDR
// hc_sex := sex_male ;
7238: LD_ADDR_OWVAR 27
7242: PUSH
7243: LD_INT 1
7245: ST_TO_ADDR
// hc_class := 1 ;
7246: LD_ADDR_OWVAR 28
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// Farmer := CreateHuman ;
7254: LD_ADDR_EXP 13
7258: PUSH
7259: CALL_OW 44
7263: ST_TO_ADDR
// InitHc ;
7264: CALL_OW 19
// end ;
7268: LD_VAR 0 1
7272: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7273: LD_INT 0
7275: PPUSH
7276: PPUSH
7277: PPUSH
7278: PPUSH
// tmp := [ ] ;
7279: LD_ADDR_VAR 0 3
7283: PUSH
7284: EMPTY
7285: ST_TO_ADDR
// for i := 1 to 3 do
7286: LD_ADDR_VAR 0 2
7290: PUSH
7291: DOUBLE
7292: LD_INT 1
7294: DEC
7295: ST_TO_ADDR
7296: LD_INT 3
7298: PUSH
7299: FOR_TO
7300: IFFALSE 7412
// begin uc_side := 3 ;
7302: LD_ADDR_OWVAR 20
7306: PUSH
7307: LD_INT 3
7309: ST_TO_ADDR
// uc_nation := 3 ;
7310: LD_ADDR_OWVAR 21
7314: PUSH
7315: LD_INT 3
7317: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7318: LD_ADDR_OWVAR 37
7322: PUSH
7323: LD_INT 22
7325: ST_TO_ADDR
// vc_engine := engine_siberite ;
7326: LD_ADDR_OWVAR 39
7330: PUSH
7331: LD_INT 3
7333: ST_TO_ADDR
// vc_control := control_computer ;
7334: LD_ADDR_OWVAR 38
7338: PUSH
7339: LD_INT 3
7341: ST_TO_ADDR
// vc_weapon := ru_crane ;
7342: LD_ADDR_OWVAR 40
7346: PUSH
7347: LD_INT 52
7349: ST_TO_ADDR
// veh := CreateVehicle ;
7350: LD_ADDR_VAR 0 4
7354: PUSH
7355: CALL_OW 45
7359: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7360: LD_VAR 0 4
7364: PPUSH
7365: LD_INT 73
7367: PPUSH
7368: LD_INT 122
7370: PPUSH
7371: LD_INT 3
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7381: LD_ADDR_VAR 0 3
7385: PUSH
7386: LD_VAR 0 3
7390: PPUSH
7391: LD_VAR 0 3
7395: PUSH
7396: LD_INT 1
7398: PLUS
7399: PPUSH
7400: LD_VAR 0 4
7404: PPUSH
7405: CALL_OW 1
7409: ST_TO_ADDR
// end ;
7410: GO 7299
7412: POP
7413: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7414: LD_ADDR_EXP 50
7418: PUSH
7419: LD_EXP 50
7423: PPUSH
7424: LD_EXP 7
7428: PPUSH
7429: LD_VAR 0 3
7433: PPUSH
7434: CALL_OW 1
7438: ST_TO_ADDR
// tmp := [ ] ;
7439: LD_ADDR_VAR 0 3
7443: PUSH
7444: EMPTY
7445: ST_TO_ADDR
// for i := 1 to 3 do
7446: LD_ADDR_VAR 0 2
7450: PUSH
7451: DOUBLE
7452: LD_INT 1
7454: DEC
7455: ST_TO_ADDR
7456: LD_INT 3
7458: PUSH
7459: FOR_TO
7460: IFFALSE 7572
// begin uc_side := 3 ;
7462: LD_ADDR_OWVAR 20
7466: PUSH
7467: LD_INT 3
7469: ST_TO_ADDR
// uc_nation := 3 ;
7470: LD_ADDR_OWVAR 21
7474: PUSH
7475: LD_INT 3
7477: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7478: LD_ADDR_OWVAR 37
7482: PUSH
7483: LD_INT 22
7485: ST_TO_ADDR
// vc_engine := engine_siberite ;
7486: LD_ADDR_OWVAR 39
7490: PUSH
7491: LD_INT 3
7493: ST_TO_ADDR
// vc_control := control_computer ;
7494: LD_ADDR_OWVAR 38
7498: PUSH
7499: LD_INT 3
7501: ST_TO_ADDR
// vc_weapon := ru_crane ;
7502: LD_ADDR_OWVAR 40
7506: PUSH
7507: LD_INT 52
7509: ST_TO_ADDR
// veh := CreateVehicle ;
7510: LD_ADDR_VAR 0 4
7514: PUSH
7515: CALL_OW 45
7519: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7520: LD_VAR 0 4
7524: PPUSH
7525: LD_INT 22
7527: PPUSH
7528: LD_INT 28
7530: PPUSH
7531: LD_INT 3
7533: PPUSH
7534: LD_INT 0
7536: PPUSH
7537: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7541: LD_ADDR_VAR 0 3
7545: PUSH
7546: LD_VAR 0 3
7550: PPUSH
7551: LD_VAR 0 3
7555: PUSH
7556: LD_INT 1
7558: PLUS
7559: PPUSH
7560: LD_VAR 0 4
7564: PPUSH
7565: CALL_OW 1
7569: ST_TO_ADDR
// end ;
7570: GO 7459
7572: POP
7573: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7574: LD_ADDR_EXP 50
7578: PUSH
7579: LD_EXP 50
7583: PPUSH
7584: LD_EXP 8
7588: PPUSH
7589: LD_VAR 0 3
7593: PPUSH
7594: CALL_OW 1
7598: ST_TO_ADDR
// end ;
7599: LD_VAR 0 1
7603: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7604: LD_INT 0
7606: PPUSH
7607: PPUSH
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
7613: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7614: LD_INT 0
7616: PPUSH
7617: LD_INT 0
7619: PPUSH
7620: LD_INT 4
7622: PPUSH
7623: LD_INT 0
7625: PPUSH
7626: LD_INT 0
7628: PPUSH
7629: LD_INT 0
7631: PPUSH
7632: LD_INT 0
7634: PPUSH
7635: LD_INT 10
7637: PPUSH
7638: LD_INT 0
7640: PPUSH
7641: CALL 54041 0 9
// side := 4 ;
7645: LD_ADDR_VAR 0 5
7649: PUSH
7650: LD_INT 4
7652: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7653: LD_ADDR_VAR 0 4
7657: PUSH
7658: LD_INT 1
7660: PUSH
7661: LD_INT 144
7663: PUSH
7664: LD_INT 18
7666: PUSH
7667: LD_INT 4
7669: PUSH
7670: LD_INT 0
7672: PUSH
7673: LD_INT 0
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: PUSH
7684: LD_INT 3
7686: PUSH
7687: LD_INT 137
7689: PUSH
7690: LD_INT 8
7692: PUSH
7693: LD_INT 4
7695: PUSH
7696: LD_INT 0
7698: PUSH
7699: LD_INT 0
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_INT 141
7715: PUSH
7716: LD_INT 8
7718: PUSH
7719: LD_INT 4
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: LD_INT 0
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 25
7738: PUSH
7739: LD_INT 137
7741: PUSH
7742: LD_INT 5
7744: PUSH
7745: LD_INT 3
7747: PUSH
7748: LD_INT 0
7750: PUSH
7751: LD_INT 0
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 18
7764: PUSH
7765: LD_INT 137
7767: PUSH
7768: LD_INT 12
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: LD_INT 0
7776: PUSH
7777: LD_INT 0
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 17
7790: PUSH
7791: LD_INT 133
7793: PUSH
7794: LD_INT 4
7796: PUSH
7797: LD_INT 2
7799: PUSH
7800: LD_INT 0
7802: PUSH
7803: LD_INT 0
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 16
7816: PUSH
7817: LD_INT 140
7819: PUSH
7820: LD_INT 11
7822: PUSH
7823: LD_INT 5
7825: PUSH
7826: LD_INT 0
7828: PUSH
7829: LD_INT 0
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: PUSH
7840: LD_INT 8
7842: PUSH
7843: LD_INT 149
7845: PUSH
7846: LD_INT 26
7848: PUSH
7849: LD_INT 4
7851: PUSH
7852: LD_INT 10
7854: PUSH
7855: LD_INT 15
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 8
7868: PUSH
7869: LD_INT 142
7871: PUSH
7872: LD_INT 26
7874: PUSH
7875: LD_INT 1
7877: PUSH
7878: LD_INT 11
7880: PUSH
7881: LD_INT 12
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 27
7894: PUSH
7895: LD_INT 153
7897: PUSH
7898: LD_INT 32
7900: PUSH
7901: LD_INT 5
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: LD_INT 0
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 27
7920: PUSH
7921: LD_INT 145
7923: PUSH
7924: LD_INT 32
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 0
7932: PUSH
7933: LD_INT 0
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: LIST
7941: LIST
7942: LIST
7943: PUSH
7944: LD_INT 27
7946: PUSH
7947: LD_INT 138
7949: PUSH
7950: LD_INT 2
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: LD_INT 0
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: LIST
7968: LIST
7969: PUSH
7970: LD_INT 27
7972: PUSH
7973: LD_INT 144
7975: PUSH
7976: LD_INT 13
7978: PUSH
7979: LD_INT 0
7981: PUSH
7982: LD_INT 0
7984: PUSH
7985: LD_INT 0
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 26
7998: PUSH
7999: LD_INT 124
8001: PUSH
8002: LD_INT 2
8004: PUSH
8005: LD_INT 4
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: LD_INT 0
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 26
8024: PUSH
8025: LD_INT 121
8027: PUSH
8028: LD_INT 2
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: LD_INT 0
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 26
8050: PUSH
8051: LD_INT 118
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: LD_INT 1
8059: PUSH
8060: LD_INT 0
8062: PUSH
8063: LD_INT 0
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 29
8076: PUSH
8077: LD_INT 159
8079: PUSH
8080: LD_INT 47
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 0
8088: PUSH
8089: LD_INT 0
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: PUSH
8100: LD_INT 32
8102: PUSH
8103: LD_INT 146
8105: PUSH
8106: LD_INT 41
8108: PUSH
8109: LD_INT 0
8111: PUSH
8112: LD_INT 0
8114: PUSH
8115: LD_INT 0
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 33
8128: PUSH
8129: LD_INT 136
8131: PUSH
8132: LD_INT 37
8134: PUSH
8135: LD_INT 0
8137: PUSH
8138: LD_INT 0
8140: PUSH
8141: LD_INT 0
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 33
8154: PUSH
8155: LD_INT 132
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 0
8163: PUSH
8164: LD_INT 0
8166: PUSH
8167: LD_INT 0
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: PUSH
8178: LD_INT 36
8180: PUSH
8181: LD_INT 124
8183: PUSH
8184: LD_INT 7
8186: PUSH
8187: LD_INT 1
8189: PUSH
8190: LD_INT 0
8192: PUSH
8193: LD_INT 0
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 5
8206: PUSH
8207: LD_INT 124
8209: PUSH
8210: LD_INT 19
8212: PUSH
8213: LD_INT 0
8215: PUSH
8216: LD_INT 0
8218: PUSH
8219: LD_INT 0
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: PUSH
8230: LD_INT 32
8232: PUSH
8233: LD_INT 127
8235: PUSH
8236: LD_INT 23
8238: PUSH
8239: LD_INT 0
8241: PUSH
8242: LD_INT 0
8244: PUSH
8245: LD_INT 0
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
// for i in tmp do
8281: LD_ADDR_VAR 0 2
8285: PUSH
8286: LD_VAR 0 4
8290: PUSH
8291: FOR_IN
8292: IFFALSE 8523
// begin uc_side := side ;
8294: LD_ADDR_OWVAR 20
8298: PUSH
8299: LD_VAR 0 5
8303: ST_TO_ADDR
// uc_nation := nation_american ;
8304: LD_ADDR_OWVAR 21
8308: PUSH
8309: LD_INT 1
8311: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8312: LD_ADDR_OWVAR 42
8316: PUSH
8317: LD_VAR 0 2
8321: PUSH
8322: LD_INT 1
8324: ARRAY
8325: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8326: LD_ADDR_OWVAR 43
8330: PUSH
8331: LD_INT 5
8333: PPUSH
8334: LD_INT 6
8336: PPUSH
8337: CALL_OW 12
8341: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8342: LD_ADDR_OWVAR 44
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 5
8354: ARRAY
8355: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8356: LD_ADDR_OWVAR 45
8360: PUSH
8361: LD_VAR 0 2
8365: PUSH
8366: LD_INT 6
8368: ARRAY
8369: ST_TO_ADDR
// sr := 0 ;
8370: LD_ADDR_VAR 0 6
8374: PUSH
8375: LD_INT 0
8377: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8378: LD_VAR 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PUSH
8387: LD_INT 29
8389: EQUAL
8390: IFFALSE 8402
// sr := mat_oil else
8392: LD_ADDR_VAR 0 6
8396: PUSH
8397: LD_INT 2
8399: ST_TO_ADDR
8400: GO 8424
// if i [ 1 ] = b_siberite_mine then
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PUSH
8411: LD_INT 30
8413: EQUAL
8414: IFFALSE 8424
// sr := mat_siberit ;
8416: LD_ADDR_VAR 0 6
8420: PUSH
8421: LD_INT 3
8423: ST_TO_ADDR
// if sr then
8424: LD_VAR 0 6
8428: IFFALSE 8484
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8430: LD_VAR 0 2
8434: PUSH
8435: LD_INT 2
8437: ARRAY
8438: PPUSH
8439: LD_VAR 0 2
8443: PUSH
8444: LD_INT 3
8446: ARRAY
8447: PPUSH
8448: LD_VAR 0 6
8452: PPUSH
8453: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8457: LD_VAR 0 2
8461: PUSH
8462: LD_INT 2
8464: ARRAY
8465: PPUSH
8466: LD_VAR 0 2
8470: PUSH
8471: LD_INT 3
8473: ARRAY
8474: PPUSH
8475: LD_VAR 0 5
8479: PPUSH
8480: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8484: LD_ADDR_VAR 0 3
8488: PUSH
8489: LD_VAR 0 2
8493: PUSH
8494: LD_INT 2
8496: ARRAY
8497: PPUSH
8498: LD_VAR 0 2
8502: PUSH
8503: LD_INT 3
8505: ARRAY
8506: PPUSH
8507: LD_VAR 0 2
8511: PUSH
8512: LD_INT 4
8514: ARRAY
8515: PPUSH
8516: CALL_OW 47
8520: ST_TO_ADDR
// end ;
8521: GO 8291
8523: POP
8524: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8525: LD_ADDR_VAR 0 8
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 5
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 30
8544: PUSH
8545: LD_INT 1
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL_OW 69
8560: ST_TO_ADDR
// if not depot then
8561: LD_VAR 0 8
8565: NOT
8566: IFFALSE 8570
// exit ;
8568: GO 8842
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8570: LD_ADDR_VAR 0 7
8574: PUSH
8575: LD_VAR 0 8
8579: PUSH
8580: LD_INT 1
8582: ARRAY
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_STRING theta3
8589: PPUSH
8590: LD_INT 8
8592: PUSH
8593: LD_INT 7
8595: PUSH
8596: LD_INT 6
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: LD_OWVAR 67
8608: ARRAY
8609: PPUSH
8610: LD_INT 2500
8612: PUSH
8613: LD_INT 2000
8615: PUSH
8616: LD_INT 1750
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: LIST
8623: PUSH
8624: LD_OWVAR 67
8628: ARRAY
8629: PUSH
8630: LD_INT 300
8632: PUSH
8633: LD_INT 250
8635: PUSH
8636: LD_INT 200
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: LD_INT 80
8652: PUSH
8653: LD_INT 60
8655: PUSH
8656: LD_INT 50
8658: PUSH
8659: EMPTY
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_OWVAR 67
8668: ARRAY
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PPUSH
8675: LD_INT 7
8677: PUSH
8678: LD_INT 6
8680: PUSH
8681: LD_INT 5
8683: PUSH
8684: LD_INT 5
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: CALL 28343 0 6
8697: ST_TO_ADDR
// if not base then
8698: LD_VAR 0 7
8702: NOT
8703: IFFALSE 8707
// exit ;
8705: GO 8842
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8707: LD_ADDR_EXP 31
8711: PUSH
8712: LD_EXP 31
8716: PPUSH
8717: LD_EXP 5
8721: PPUSH
8722: LD_VAR 0 7
8726: PPUSH
8727: CALL_OW 1
8731: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8732: LD_INT 1
8734: PPUSH
8735: LD_INT 1
8737: PPUSH
8738: LD_INT 7
8740: PPUSH
8741: CALL_OW 380
// allyCommander := CreateHuman ;
8745: LD_ADDR_EXP 11
8749: PUSH
8750: CALL_OW 44
8754: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8755: LD_EXP 11
8759: PPUSH
8760: LD_INT 139
8762: PPUSH
8763: LD_INT 15
8765: PPUSH
8766: LD_INT 0
8768: PPUSH
8769: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8773: LD_EXP 11
8777: PPUSH
8778: LD_INT 137
8780: PPUSH
8781: LD_INT 15
8783: PPUSH
8784: CALL_OW 118
// hc_gallery := us ;
8788: LD_ADDR_OWVAR 33
8792: PUSH
8793: LD_STRING us
8795: ST_TO_ADDR
// hc_face_number := 7 ;
8796: LD_ADDR_OWVAR 34
8800: PUSH
8801: LD_INT 7
8803: ST_TO_ADDR
// hc_name := Arthur Powell ;
8804: LD_ADDR_OWVAR 26
8808: PUSH
8809: LD_STRING Arthur Powell
8811: ST_TO_ADDR
// hc_sex := sex_male ;
8812: LD_ADDR_OWVAR 27
8816: PUSH
8817: LD_INT 1
8819: ST_TO_ADDR
// hc_class := 1 ;
8820: LD_ADDR_OWVAR 28
8824: PUSH
8825: LD_INT 1
8827: ST_TO_ADDR
// Powell := CreateHuman ;
8828: LD_ADDR_EXP 12
8832: PUSH
8833: CALL_OW 44
8837: ST_TO_ADDR
// InitHc ;
8838: CALL_OW 19
// end ;
8842: LD_VAR 0 1
8846: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8847: LD_INT 0
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
// side := 1 ;
8858: LD_ADDR_VAR 0 3
8862: PUSH
8863: LD_INT 1
8865: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8866: LD_ADDR_VAR 0 1
8870: PUSH
8871: EMPTY
8872: PUSH
8873: EMPTY
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: ST_TO_ADDR
// uc_side := side ;
8879: LD_ADDR_OWVAR 20
8883: PUSH
8884: LD_VAR 0 3
8888: ST_TO_ADDR
// uc_nation := nation_american ;
8889: LD_ADDR_OWVAR 21
8893: PUSH
8894: LD_INT 1
8896: ST_TO_ADDR
// InitHc ;
8897: CALL_OW 19
// InitVc ;
8901: CALL_OW 20
// hc_importance := 0 ;
8905: LD_ADDR_OWVAR 32
8909: PUSH
8910: LD_INT 0
8912: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8913: LD_ADDR_VAR 0 7
8917: PUSH
8918: LD_INT 2
8920: PUSH
8921: LD_INT 3
8923: PUSH
8924: LD_INT 3
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// if commander = 2 then
8932: LD_EXP 25
8936: PUSH
8937: LD_INT 2
8939: EQUAL
8940: IFFALSE 8961
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8942: LD_ADDR_VAR 0 7
8946: PUSH
8947: LD_INT 3
8949: PUSH
8950: LD_INT 4
8952: PUSH
8953: LD_INT 4
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: LIST
8960: ST_TO_ADDR
// if commander = 3 then
8961: LD_EXP 25
8965: PUSH
8966: LD_INT 3
8968: EQUAL
8969: IFFALSE 8990
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8971: LD_ADDR_VAR 0 7
8975: PUSH
8976: LD_INT 2
8978: PUSH
8979: LD_INT 5
8981: PUSH
8982: LD_INT 5
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8990: LD_ADDR_VAR 0 8
8994: PUSH
8995: LD_INT 2
8997: PUSH
8998: LD_INT 2
9000: PUSH
9001: LD_INT 1
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: LIST
9008: ST_TO_ADDR
// if commander = 2 then
9009: LD_EXP 25
9013: PUSH
9014: LD_INT 2
9016: EQUAL
9017: IFFALSE 9038
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
9019: LD_ADDR_VAR 0 8
9023: PUSH
9024: LD_INT 1
9026: PUSH
9027: LD_INT 1
9029: PUSH
9030: LD_INT 3
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: ST_TO_ADDR
// if commander = 3 then
9038: LD_EXP 25
9042: PUSH
9043: LD_INT 3
9045: EQUAL
9046: IFFALSE 9067
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9048: LD_ADDR_VAR 0 8
9052: PUSH
9053: LD_INT 3
9055: PUSH
9056: LD_INT 3
9058: PUSH
9059: LD_INT 1
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: LIST
9066: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9067: LD_ADDR_VAR 0 9
9071: PUSH
9072: LD_INT 5
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: LD_INT 4
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// if commander = 2 then
9086: LD_EXP 25
9090: PUSH
9091: LD_INT 2
9093: EQUAL
9094: IFFALSE 9115
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9096: LD_ADDR_VAR 0 9
9100: PUSH
9101: LD_INT 7
9103: PUSH
9104: LD_INT 5
9106: PUSH
9107: LD_INT 6
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: ST_TO_ADDR
// if commander = 3 then
9115: LD_EXP 25
9119: PUSH
9120: LD_INT 3
9122: EQUAL
9123: IFFALSE 9144
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9125: LD_ADDR_VAR 0 9
9129: PUSH
9130: LD_INT 9
9132: PUSH
9133: LD_INT 10
9135: PUSH
9136: LD_INT 7
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: LIST
9143: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9144: LD_ADDR_VAR 0 5
9148: PUSH
9149: LD_INT 5
9151: PUSH
9152: LD_INT 5
9154: PUSH
9155: LD_INT 4
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_OWVAR 67
9167: ARRAY
9168: ST_TO_ADDR
// if commander = 2 then
9169: LD_EXP 25
9173: PUSH
9174: LD_INT 2
9176: EQUAL
9177: IFFALSE 9193
// tanks := tanks + 3 ;
9179: LD_ADDR_VAR 0 5
9183: PUSH
9184: LD_VAR 0 5
9188: PUSH
9189: LD_INT 3
9191: PLUS
9192: ST_TO_ADDR
// for i = 1 to tanks do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_VAR 0 5
9207: PUSH
9208: FOR_TO
9209: IFFALSE 9319
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9211: LD_VAR 0 7
9215: PUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 3
9223: MOD
9224: PUSH
9225: LD_INT 1
9227: PLUS
9228: ARRAY
9229: PPUSH
9230: LD_VAR 0 8
9234: PUSH
9235: LD_INT 1
9237: PPUSH
9238: LD_INT 3
9240: PPUSH
9241: CALL_OW 12
9245: ARRAY
9246: PPUSH
9247: LD_INT 1
9249: PPUSH
9250: LD_VAR 0 9
9254: PUSH
9255: LD_VAR 0 2
9259: PUSH
9260: LD_INT 3
9262: MOD
9263: PUSH
9264: LD_INT 1
9266: PLUS
9267: ARRAY
9268: PPUSH
9269: LD_INT 60
9271: PPUSH
9272: LD_INT 70
9274: PPUSH
9275: CALL_OW 12
9279: PPUSH
9280: CALL 24899 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9284: LD_ADDR_VAR 0 1
9288: PUSH
9289: LD_VAR 0 1
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: LD_VAR 0 1
9301: PUSH
9302: LD_INT 1
9304: ARRAY
9305: PUSH
9306: CALL_OW 45
9310: ADD
9311: PPUSH
9312: CALL_OW 1
9316: ST_TO_ADDR
// end ;
9317: GO 9208
9319: POP
9320: POP
// cl := 1 ;
9321: LD_ADDR_VAR 0 6
9325: PUSH
9326: LD_INT 1
9328: ST_TO_ADDR
// for i = 1 to 10 do
9329: LD_ADDR_VAR 0 2
9333: PUSH
9334: DOUBLE
9335: LD_INT 1
9337: DEC
9338: ST_TO_ADDR
9339: LD_INT 10
9341: PUSH
9342: FOR_TO
9343: IFFALSE 9458
// begin if i mod 4 = 0 then
9345: LD_VAR 0 2
9349: PUSH
9350: LD_INT 4
9352: MOD
9353: PUSH
9354: LD_INT 0
9356: EQUAL
9357: IFFALSE 9373
// cl := cl + 1 ;
9359: LD_ADDR_VAR 0 6
9363: PUSH
9364: LD_VAR 0 6
9368: PUSH
9369: LD_INT 1
9371: PLUS
9372: ST_TO_ADDR
// if cl = 2 then
9373: LD_VAR 0 6
9377: PUSH
9378: LD_INT 2
9380: EQUAL
9381: IFFALSE 9391
// cl := 3 ;
9383: LD_ADDR_VAR 0 6
9387: PUSH
9388: LD_INT 3
9390: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9391: LD_INT 0
9393: PPUSH
9394: LD_VAR 0 6
9398: PPUSH
9399: LD_INT 6
9401: PUSH
9402: LD_INT 6
9404: PUSH
9405: LD_INT 5
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PPUSH
9419: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: LD_VAR 0 1
9432: PPUSH
9433: LD_INT 2
9435: PPUSH
9436: LD_VAR 0 1
9440: PUSH
9441: LD_INT 2
9443: ARRAY
9444: PUSH
9445: CALL_OW 44
9449: ADD
9450: PPUSH
9451: CALL_OW 1
9455: ST_TO_ADDR
// end ;
9456: GO 9342
9458: POP
9459: POP
// if commander = 1 then
9460: LD_EXP 25
9464: PUSH
9465: LD_INT 1
9467: EQUAL
9468: IFFALSE 9536
// for i = 1 to 4 do
9470: LD_ADDR_VAR 0 2
9474: PUSH
9475: DOUBLE
9476: LD_INT 1
9478: DEC
9479: ST_TO_ADDR
9480: LD_INT 4
9482: PUSH
9483: FOR_TO
9484: IFFALSE 9534
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9486: LD_INT 0
9488: PPUSH
9489: LD_INT 1
9491: PPUSH
9492: LD_INT 8
9494: PPUSH
9495: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9499: LD_ADDR_VAR 0 1
9503: PUSH
9504: LD_VAR 0 1
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: LD_VAR 0 1
9516: PUSH
9517: LD_INT 2
9519: ARRAY
9520: PUSH
9521: CALL_OW 44
9525: ADD
9526: PPUSH
9527: CALL_OW 1
9531: ST_TO_ADDR
// end ;
9532: GO 9483
9534: POP
9535: POP
// techs := [ ] ;
9536: LD_ADDR_VAR 0 4
9540: PUSH
9541: EMPTY
9542: ST_TO_ADDR
// if commander = 1 then
9543: LD_EXP 25
9547: PUSH
9548: LD_INT 1
9550: EQUAL
9551: IFFALSE 9576
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9553: LD_ADDR_VAR 0 4
9557: PUSH
9558: LD_INT 51
9560: PUSH
9561: LD_INT 52
9563: PUSH
9564: LD_INT 53
9566: PUSH
9567: LD_INT 12
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: ST_TO_ADDR
// if commander = 2 then
9576: LD_EXP 25
9580: PUSH
9581: LD_INT 2
9583: EQUAL
9584: IFFALSE 9621
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9586: LD_ADDR_VAR 0 4
9590: PUSH
9591: LD_INT 48
9593: PUSH
9594: LD_INT 47
9596: PUSH
9597: LD_INT 46
9599: PUSH
9600: LD_INT 45
9602: PUSH
9603: LD_INT 35
9605: PUSH
9606: LD_INT 60
9608: PUSH
9609: LD_INT 6
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: ST_TO_ADDR
// if commander = 3 then
9621: LD_EXP 25
9625: PUSH
9626: LD_INT 3
9628: EQUAL
9629: IFFALSE 9678
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9631: LD_ADDR_VAR 0 4
9635: PUSH
9636: LD_INT 27
9638: PUSH
9639: LD_INT 36
9641: PUSH
9642: LD_INT 32
9644: PUSH
9645: LD_INT 57
9647: PUSH
9648: LD_INT 58
9650: PUSH
9651: LD_INT 47
9653: PUSH
9654: LD_INT 46
9656: PUSH
9657: LD_INT 51
9659: PUSH
9660: LD_INT 69
9662: PUSH
9663: LD_INT 39
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// if techs then
9678: LD_VAR 0 4
9682: IFFALSE 9716
// for i in techs do
9684: LD_ADDR_VAR 0 2
9688: PUSH
9689: LD_VAR 0 4
9693: PUSH
9694: FOR_IN
9695: IFFALSE 9714
// SetTech ( i , 1 , state_researched ) ;
9697: LD_VAR 0 2
9701: PPUSH
9702: LD_INT 1
9704: PPUSH
9705: LD_INT 2
9707: PPUSH
9708: CALL_OW 322
9712: GO 9694
9714: POP
9715: POP
// hc_gallery := skirmish ;
9716: LD_ADDR_OWVAR 33
9720: PUSH
9721: LD_STRING skirmish
9723: ST_TO_ADDR
// hc_face_number := commander ;
9724: LD_ADDR_OWVAR 34
9728: PUSH
9729: LD_EXP 25
9733: ST_TO_ADDR
// hc_importance := 100 ;
9734: LD_ADDR_OWVAR 32
9738: PUSH
9739: LD_INT 100
9741: ST_TO_ADDR
// case commander of 1 :
9742: LD_EXP 25
9746: PUSH
9747: LD_INT 1
9749: DOUBLE
9750: EQUAL
9751: IFTRUE 9755
9753: GO 9779
9755: POP
// begin hc_name := Jeff Ironside ;
9756: LD_ADDR_OWVAR 26
9760: PUSH
9761: LD_STRING Jeff Ironside
9763: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9764: LD_INT 1
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 7
9772: PPUSH
9773: CALL_OW 380
// end ; 2 :
9777: GO 9844
9779: LD_INT 2
9781: DOUBLE
9782: EQUAL
9783: IFTRUE 9787
9785: GO 9811
9787: POP
// begin hc_name := Paul Johnson ;
9788: LD_ADDR_OWVAR 26
9792: PUSH
9793: LD_STRING Paul Johnson
9795: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9796: LD_INT 1
9798: PPUSH
9799: LD_INT 3
9801: PPUSH
9802: LD_INT 7
9804: PPUSH
9805: CALL_OW 380
// end ; 3 :
9809: GO 9844
9811: LD_INT 3
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9843
9819: POP
// begin hc_name := Lisa Stuart ;
9820: LD_ADDR_OWVAR 26
9824: PUSH
9825: LD_STRING Lisa Stuart
9827: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9828: LD_INT 2
9830: PPUSH
9831: LD_INT 4
9833: PPUSH
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 380
// end ; end ;
9841: GO 9844
9843: POP
// playerCommander := CreateHuman ;
9844: LD_ADDR_EXP 9
9848: PUSH
9849: CALL_OW 44
9853: ST_TO_ADDR
// hc_importance := 0 ;
9854: LD_ADDR_OWVAR 32
9858: PUSH
9859: LD_INT 0
9861: ST_TO_ADDR
// hc_gallery :=  ;
9862: LD_ADDR_OWVAR 33
9866: PUSH
9867: LD_STRING 
9869: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9870: LD_ADDR_VAR 0 1
9874: PUSH
9875: LD_VAR 0 1
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_INT 2
9890: ARRAY
9891: PUSH
9892: LD_EXP 9
9896: ADD
9897: PPUSH
9898: CALL_OW 1
9902: ST_TO_ADDR
// end ;
9903: LD_VAR 0 1
9907: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9908: LD_INT 0
9910: PPUSH
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// uc_side := 1 ;
9916: LD_ADDR_OWVAR 20
9920: PUSH
9921: LD_INT 1
9923: ST_TO_ADDR
// uc_nation := 1 ;
9924: LD_ADDR_OWVAR 21
9928: PUSH
9929: LD_INT 1
9931: ST_TO_ADDR
// InitHc ;
9932: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9936: LD_ADDR_VAR 0 3
9940: PUSH
9941: LD_INT 3
9943: PUSH
9944: LD_INT 3
9946: PUSH
9947: LD_INT 2
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: LIST
9954: PUSH
9955: LD_OWVAR 67
9959: ARRAY
9960: ST_TO_ADDR
// for i = 1 to peopleAmount do
9961: LD_ADDR_VAR 0 2
9965: PUSH
9966: DOUBLE
9967: LD_INT 1
9969: DEC
9970: ST_TO_ADDR
9971: LD_VAR 0 3
9975: PUSH
9976: FOR_TO
9977: IFFALSE 10026
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9979: LD_INT 0
9981: PPUSH
9982: LD_INT 2
9984: PPUSH
9985: LD_INT 7
9987: PUSH
9988: LD_INT 6
9990: PUSH
9991: LD_INT 5
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: PUSH
9999: LD_OWVAR 67
10003: ARRAY
10004: PPUSH
10005: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
10009: CALL_OW 44
10013: PPUSH
10014: LD_INT 19
10016: PPUSH
10017: LD_INT 0
10019: PPUSH
10020: CALL 56269 0 3
// end ;
10024: GO 9976
10026: POP
10027: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
10028: LD_INT 2
10030: PPUSH
10031: LD_INT 1
10033: PPUSH
10034: LD_INT 3
10036: PPUSH
10037: LD_INT 13
10039: PPUSH
10040: LD_INT 58
10042: PPUSH
10043: CALL 24899 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10047: CALL_OW 45
10051: PPUSH
10052: LD_INT 19
10054: PPUSH
10055: LD_INT 0
10057: PPUSH
10058: CALL 56269 0 3
// if commander = 1 then
10062: LD_EXP 25
10066: PUSH
10067: LD_INT 1
10069: EQUAL
10070: IFFALSE 10081
// wait ( 6 6$00 ) else
10072: LD_INT 12600
10074: PPUSH
10075: CALL_OW 67
10079: GO 10088
// wait ( 8 8$00 ) ;
10081: LD_INT 16800
10083: PPUSH
10084: CALL_OW 67
// uc_side := 1 ;
10088: LD_ADDR_OWVAR 20
10092: PUSH
10093: LD_INT 1
10095: ST_TO_ADDR
// uc_nation := 1 ;
10096: LD_ADDR_OWVAR 21
10100: PUSH
10101: LD_INT 1
10103: ST_TO_ADDR
// InitVc ;
10104: CALL_OW 20
// InitHc ;
10108: CALL_OW 19
// for i = 1 to 5 do
10112: LD_ADDR_VAR 0 2
10116: PUSH
10117: DOUBLE
10118: LD_INT 1
10120: DEC
10121: ST_TO_ADDR
10122: LD_INT 5
10124: PUSH
10125: FOR_TO
10126: IFFALSE 10370
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10128: LD_INT 4
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 1
10136: PUSH
10137: EMPTY
10138: LIST
10139: LIST
10140: LIST
10141: PUSH
10142: LD_VAR 0 2
10146: PUSH
10147: LD_INT 3
10149: MOD
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 1
10158: PPUSH
10159: LD_INT 1
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 2
10177: PUSH
10178: LD_INT 3
10180: MOD
10181: PUSH
10182: LD_INT 1
10184: PLUS
10185: ARRAY
10186: PPUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 12
10192: PUSH
10193: LD_INT 11
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: PUSH
10201: LD_VAR 0 2
10205: PUSH
10206: LD_INT 3
10208: MOD
10209: PUSH
10210: LD_INT 1
10212: PLUS
10213: ARRAY
10214: PPUSH
10215: LD_INT 40
10217: PPUSH
10218: LD_INT 55
10220: PPUSH
10221: CALL_OW 12
10225: PPUSH
10226: CALL 24899 0 5
// veh := CreateVehicle ;
10230: LD_ADDR_VAR 0 6
10234: PUSH
10235: CALL_OW 45
10239: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10240: LD_VAR 0 6
10244: PPUSH
10245: LD_INT 19
10247: PPUSH
10248: LD_INT 0
10250: PPUSH
10251: CALL 56269 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10255: LD_VAR 0 6
10259: PPUSH
10260: CALL_OW 264
10264: PUSH
10265: LD_INT 12
10267: EQUAL
10268: IFFALSE 10300
// begin AddCargo ( veh , mat_cans , 70 ) ;
10270: LD_VAR 0 6
10274: PPUSH
10275: LD_INT 1
10277: PPUSH
10278: LD_INT 70
10280: PPUSH
10281: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10285: LD_VAR 0 6
10289: PPUSH
10290: LD_INT 3
10292: PPUSH
10293: LD_INT 30
10295: PPUSH
10296: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10300: LD_VAR 0 6
10304: PPUSH
10305: CALL_OW 263
10309: PUSH
10310: LD_INT 1
10312: EQUAL
10313: IFFALSE 10368
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10315: LD_INT 1
10317: PPUSH
10318: LD_INT 3
10320: PPUSH
10321: LD_INT 6
10323: PPUSH
10324: CALL_OW 380
// un := CreateHuman ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: CALL_OW 44
10337: ST_TO_ADDR
// tmp := tmp ^ un ;
10338: LD_ADDR_VAR 0 4
10342: PUSH
10343: LD_VAR 0 4
10347: PUSH
10348: LD_VAR 0 5
10352: ADD
10353: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10354: LD_VAR 0 5
10358: PPUSH
10359: LD_VAR 0 6
10363: PPUSH
10364: CALL_OW 52
// end ; end ;
10368: GO 10125
10370: POP
10371: POP
// if tmp then
10372: LD_VAR 0 4
10376: IFFALSE 10440
// begin CenterNowOnUnits ( tmp ) ;
10378: LD_VAR 0 4
10382: PPUSH
10383: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10387: LD_VAR 0 4
10391: PUSH
10392: LD_INT 1
10394: ARRAY
10395: PPUSH
10396: LD_STRING DAR-1
10398: PPUSH
10399: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10403: LD_EXP 9
10407: PPUSH
10408: LD_STRING D
10410: PUSH
10411: LD_STRING I
10413: PUSH
10414: LD_STRING J
10416: PUSH
10417: LD_STRING S
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_EXP 25
10429: ARRAY
10430: STR
10431: PUSH
10432: LD_STRING -1-DAR
10434: STR
10435: PPUSH
10436: CALL_OW 88
// end ; if not reinforceAllowed then
10440: LD_EXP 24
10444: NOT
10445: IFFALSE 10449
// exit ;
10447: GO 10603
// wait ( 25 25$00 ) ;
10449: LD_INT 52500
10451: PPUSH
10452: CALL_OW 67
// uc_side := 1 ;
10456: LD_ADDR_OWVAR 20
10460: PUSH
10461: LD_INT 1
10463: ST_TO_ADDR
// uc_nation := 1 ;
10464: LD_ADDR_OWVAR 21
10468: PUSH
10469: LD_INT 1
10471: ST_TO_ADDR
// InitVc ;
10472: CALL_OW 20
// InitHc ;
10476: CALL_OW 19
// for i = 1 to 4 do
10480: LD_ADDR_VAR 0 2
10484: PUSH
10485: DOUBLE
10486: LD_INT 1
10488: DEC
10489: ST_TO_ADDR
10490: LD_INT 4
10492: PUSH
10493: FOR_TO
10494: IFFALSE 10601
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10496: LD_INT 5
10498: PPUSH
10499: LD_INT 3
10501: PPUSH
10502: LD_INT 1
10504: PPUSH
10505: LD_INT 6
10507: PPUSH
10508: LD_INT 1
10510: PPUSH
10511: CALL 24899 0 5
// veh := CreateVehicle ;
10515: LD_ADDR_VAR 0 6
10519: PUSH
10520: CALL_OW 45
10524: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10525: LD_VAR 0 6
10529: PPUSH
10530: LD_INT 19
10532: PPUSH
10533: LD_INT 0
10535: PPUSH
10536: CALL 56269 0 3
// if GetControl ( veh ) = control_manual then
10540: LD_VAR 0 6
10544: PPUSH
10545: CALL_OW 263
10549: PUSH
10550: LD_INT 1
10552: EQUAL
10553: IFFALSE 10599
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10555: LD_INT 0
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_INT 7
10563: PUSH
10564: LD_INT 6
10566: PUSH
10567: LD_INT 5
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: LIST
10574: PUSH
10575: LD_OWVAR 67
10579: ARRAY
10580: PPUSH
10581: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10585: CALL_OW 44
10589: PPUSH
10590: LD_VAR 0 6
10594: PPUSH
10595: CALL_OW 52
// end ; end ;
10599: GO 10493
10601: POP
10602: POP
// end ;
10603: LD_VAR 0 1
10607: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10608: LD_INT 0
10610: PPUSH
10611: PPUSH
10612: PPUSH
10613: PPUSH
10614: PPUSH
// uc_side := 8 ;
10615: LD_ADDR_OWVAR 20
10619: PUSH
10620: LD_INT 8
10622: ST_TO_ADDR
// uc_nation := nation_arabian ;
10623: LD_ADDR_OWVAR 21
10627: PUSH
10628: LD_INT 2
10630: ST_TO_ADDR
// for i = 1 to 2 do
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: DOUBLE
10637: LD_INT 1
10639: DEC
10640: ST_TO_ADDR
10641: LD_INT 2
10643: PUSH
10644: FOR_TO
10645: IFFALSE 10725
// for j = 1 to 4 do
10647: LD_ADDR_VAR 0 4
10651: PUSH
10652: DOUBLE
10653: LD_INT 1
10655: DEC
10656: ST_TO_ADDR
10657: LD_INT 4
10659: PUSH
10660: FOR_TO
10661: IFFALSE 10721
// begin PrepareHuman ( false , j , 8 ) ;
10663: LD_INT 0
10665: PPUSH
10666: LD_VAR 0 4
10670: PPUSH
10671: LD_INT 8
10673: PPUSH
10674: CALL_OW 380
// un := CreateHuman ;
10678: LD_ADDR_VAR 0 3
10682: PUSH
10683: CALL_OW 44
10687: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10688: LD_VAR 0 3
10692: PPUSH
10693: LD_INT 23
10695: PPUSH
10696: LD_INT 0
10698: PPUSH
10699: CALL_OW 49
// tmp := tmp union un ;
10703: LD_ADDR_VAR 0 5
10707: PUSH
10708: LD_VAR 0 5
10712: PUSH
10713: LD_VAR 0 3
10717: UNION
10718: ST_TO_ADDR
// end ;
10719: GO 10660
10721: POP
10722: POP
10723: GO 10644
10725: POP
10726: POP
// for i in tmp do
10727: LD_ADDR_VAR 0 2
10731: PUSH
10732: LD_VAR 0 5
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10757
// ComMoveXY ( i , 150 , 136 ) ;
10740: LD_VAR 0 2
10744: PPUSH
10745: LD_INT 150
10747: PPUSH
10748: LD_INT 136
10750: PPUSH
10751: CALL_OW 111
10755: GO 10737
10757: POP
10758: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10759: LD_ADDR_EXP 31
10763: PUSH
10764: LD_EXP 31
10768: PPUSH
10769: LD_EXP 6
10773: PPUSH
10774: LD_EXP 31
10778: PUSH
10779: LD_EXP 6
10783: ARRAY
10784: PUSH
10785: LD_VAR 0 5
10789: UNION
10790: PPUSH
10791: CALL_OW 1
10795: ST_TO_ADDR
// end ;
10796: LD_VAR 0 1
10800: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10801: LD_OWVAR 67
10805: PUSH
10806: LD_INT 1
10808: GREATER
10809: PUSH
10810: LD_INT 31
10812: PPUSH
10813: LD_INT 3
10815: PPUSH
10816: CALL_OW 321
10820: PUSH
10821: LD_INT 2
10823: EQUAL
10824: AND
10825: IFFALSE 11042
10827: GO 10829
10829: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10830: LD_EXP 7
10834: PPUSH
10835: LD_INT 33
10837: PUSH
10838: LD_INT 101
10840: PUSH
10841: LD_INT 159
10843: PUSH
10844: LD_INT 5
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 33
10855: PUSH
10856: LD_INT 105
10858: PUSH
10859: LD_INT 158
10861: PUSH
10862: LD_INT 5
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 33
10873: PUSH
10874: LD_INT 96
10876: PUSH
10877: LD_INT 136
10879: PUSH
10880: LD_INT 5
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PUSH
10889: LD_INT 33
10891: PUSH
10892: LD_INT 94
10894: PUSH
10895: LD_INT 133
10897: PUSH
10898: LD_INT 4
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: LD_INT 33
10909: PUSH
10910: LD_INT 84
10912: PUSH
10913: LD_INT 102
10915: PUSH
10916: LD_INT 4
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PPUSH
10932: CALL 85473 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10936: LD_EXP 8
10940: PPUSH
10941: LD_INT 33
10943: PUSH
10944: LD_INT 50
10946: PUSH
10947: LD_INT 17
10949: PUSH
10950: LD_INT 4
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: PUSH
10959: LD_INT 33
10961: PUSH
10962: LD_INT 52
10964: PUSH
10965: LD_INT 20
10967: PUSH
10968: LD_INT 4
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 33
10979: PUSH
10980: LD_INT 53
10982: PUSH
10983: LD_INT 23
10985: PUSH
10986: LD_INT 4
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 33
10997: PUSH
10998: LD_INT 45
11000: PUSH
11001: LD_INT 32
11003: PUSH
11004: LD_INT 4
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: LIST
11011: LIST
11012: PUSH
11013: LD_INT 33
11015: PUSH
11016: LD_INT 45
11018: PUSH
11019: LD_INT 39
11021: PUSH
11022: LD_INT 4
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL 85473 0 2
// end ;
11042: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11043: LD_INT 3
11045: PUSH
11046: LD_INT 22
11048: PUSH
11049: LD_OWVAR 2
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PUSH
11062: LD_INT 33
11064: PUSH
11065: LD_INT 2
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: LD_INT 50
11074: PUSH
11075: EMPTY
11076: LIST
11077: PUSH
11078: LD_INT 3
11080: PUSH
11081: LD_INT 61
11083: PUSH
11084: EMPTY
11085: LIST
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PUSH
11091: EMPTY
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: PPUSH
11097: CALL_OW 69
11101: IFFALSE 11201
11103: GO 11105
11105: DISABLE
11106: LD_INT 0
11108: PPUSH
11109: PPUSH
// begin enable ;
11110: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11111: LD_ADDR_VAR 0 2
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 22
11121: PUSH
11122: LD_OWVAR 2
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 33
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 50
11147: PUSH
11148: EMPTY
11149: LIST
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: LD_INT 61
11156: PUSH
11157: EMPTY
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: PPUSH
11170: CALL_OW 69
11174: ST_TO_ADDR
// for i in tmp do
11175: LD_ADDR_VAR 0 1
11179: PUSH
11180: LD_VAR 0 2
11184: PUSH
11185: FOR_IN
11186: IFFALSE 11199
// Connect ( i ) ;
11188: LD_VAR 0 1
11192: PPUSH
11193: CALL 27990 0 1
11197: GO 11185
11199: POP
11200: POP
// end ; end_of_file
11201: PPOPN 2
11203: END
// export function Action ; var i , tmp ; begin
11204: LD_INT 0
11206: PPUSH
11207: PPUSH
11208: PPUSH
// InGameOn ;
11209: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11213: LD_INT 225
11215: PPUSH
11216: LD_INT 217
11218: PPUSH
11219: CALL_OW 86
// for i in playerForces [ 2 ] do
11223: LD_ADDR_VAR 0 2
11227: PUSH
11228: LD_EXP 10
11232: PUSH
11233: LD_INT 2
11235: ARRAY
11236: PUSH
11237: FOR_IN
11238: IFFALSE 11371
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11240: LD_EXP 10
11244: PUSH
11245: LD_INT 1
11247: ARRAY
11248: PUSH
11249: LD_VAR 0 2
11253: PPUSH
11254: CALL_OW 257
11258: PUSH
11259: LD_INT 3
11261: PUSH
11262: LD_INT 4
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: IN
11269: AND
11270: IFFALSE 11354
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11272: LD_EXP 10
11276: PUSH
11277: LD_INT 1
11279: ARRAY
11280: PUSH
11281: LD_INT 1
11283: ARRAY
11284: PPUSH
11285: LD_INT 19
11287: PPUSH
11288: LD_INT 0
11290: PPUSH
11291: CALL 56269 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11295: LD_VAR 0 2
11299: PPUSH
11300: LD_EXP 10
11304: PUSH
11305: LD_INT 1
11307: ARRAY
11308: PUSH
11309: LD_INT 1
11311: ARRAY
11312: PPUSH
11313: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11317: LD_ADDR_EXP 10
11321: PUSH
11322: LD_EXP 10
11326: PPUSH
11327: LD_INT 1
11329: PPUSH
11330: LD_EXP 10
11334: PUSH
11335: LD_INT 1
11337: ARRAY
11338: PPUSH
11339: LD_INT 1
11341: PPUSH
11342: CALL_OW 3
11346: PPUSH
11347: CALL_OW 1
11351: ST_TO_ADDR
// end else
11352: GO 11369
// PlaceUnitInArea ( i , startArea , false ) ;
11354: LD_VAR 0 2
11358: PPUSH
11359: LD_INT 19
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL 56269 0 3
// end ;
11369: GO 11237
11371: POP
11372: POP
// wait ( 0 0$2 ) ;
11373: LD_INT 70
11375: PPUSH
11376: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11380: LD_EXP 9
11384: PPUSH
11385: LD_STRING D
11387: PUSH
11388: LD_STRING I
11390: PUSH
11391: LD_STRING J
11393: PUSH
11394: LD_STRING S
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: LIST
11401: PUSH
11402: LD_EXP 25
11406: ARRAY
11407: STR
11408: PUSH
11409: LD_STRING -1
11411: STR
11412: PPUSH
11413: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11417: LD_EXP 12
11421: PPUSH
11422: LD_STRING DP-1
11424: PPUSH
11425: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11429: LD_EXP 12
11433: PPUSH
11434: LD_STRING DP-2
11436: PPUSH
11437: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11441: LD_EXP 9
11445: PPUSH
11446: LD_STRING D
11448: PUSH
11449: LD_STRING I
11451: PUSH
11452: LD_STRING J
11454: PUSH
11455: LD_STRING S
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: PUSH
11463: LD_EXP 25
11467: ARRAY
11468: STR
11469: PUSH
11470: LD_STRING -2
11472: STR
11473: PPUSH
11474: CALL_OW 88
// InGameOff ;
11478: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11482: LD_STRING O1
11484: PPUSH
11485: CALL_OW 337
// game := true ;
11489: LD_ADDR_EXP 3
11493: PUSH
11494: LD_INT 1
11496: ST_TO_ADDR
// SaveForQuickRestart ;
11497: CALL_OW 22
// wait ( 0 0$5 ) ;
11501: LD_INT 175
11503: PPUSH
11504: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11508: LD_EXP 9
11512: PPUSH
11513: LD_STRING D
11515: PUSH
11516: LD_STRING I
11518: PUSH
11519: LD_STRING J
11521: PUSH
11522: LD_STRING S
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: LIST
11529: PUSH
11530: LD_EXP 25
11534: ARRAY
11535: STR
11536: PUSH
11537: LD_STRING -3
11539: STR
11540: PPUSH
11541: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11545: LD_INT 35
11547: PPUSH
11548: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11552: LD_EXP 15
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PUSH
11561: LD_EXP 15
11565: PUSH
11566: LD_INT 2
11568: ARRAY
11569: GREATEREQUAL
11570: IFFALSE 11545
// outpostEscape := true ;
11572: LD_ADDR_EXP 27
11576: PUSH
11577: LD_INT 1
11579: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11580: LD_ADDR_VAR 0 3
11584: PUSH
11585: LD_EXP 14
11589: PPUSH
11590: LD_INT 26
11592: PUSH
11593: LD_INT 1
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PPUSH
11600: CALL_OW 72
11604: ST_TO_ADDR
// if tmp then
11605: LD_VAR 0 3
11609: IFFALSE 11627
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11611: LD_VAR 0 3
11615: PUSH
11616: LD_INT 1
11618: ARRAY
11619: PPUSH
11620: LD_STRING DR-1-Escape
11622: PPUSH
11623: CALL_OW 88
// wait ( 0 0$1 ) ;
11627: LD_INT 35
11629: PPUSH
11630: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11634: LD_EXP 9
11638: PPUSH
11639: LD_STRING D
11641: PUSH
11642: LD_STRING I
11644: PUSH
11645: LD_STRING J
11647: PUSH
11648: LD_STRING S
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: LIST
11655: PUSH
11656: LD_EXP 25
11660: ARRAY
11661: STR
11662: PUSH
11663: LD_STRING -1-Escape
11665: STR
11666: PPUSH
11667: CALL_OW 88
// for i in ruOutpost do
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_EXP 14
11680: PUSH
11681: FOR_IN
11682: IFFALSE 11736
// begin if IsInUnit ( i ) then
11684: LD_VAR 0 2
11688: PPUSH
11689: CALL_OW 310
11693: IFFALSE 11704
// ComExitBuilding ( i ) ;
11695: LD_VAR 0 2
11699: PPUSH
11700: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11704: LD_VAR 0 2
11708: PPUSH
11709: LD_INT 179
11711: PPUSH
11712: LD_INT 102
11714: PPUSH
11715: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11719: LD_VAR 0 2
11723: PPUSH
11724: LD_INT 28
11726: PPUSH
11727: LD_INT 20
11729: PPUSH
11730: CALL_OW 171
// end ;
11734: GO 11681
11736: POP
11737: POP
// tmp := [ ] ;
11738: LD_ADDR_VAR 0 3
11742: PUSH
11743: EMPTY
11744: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11745: LD_INT 35
11747: PPUSH
11748: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11752: LD_ADDR_VAR 0 3
11756: PUSH
11757: LD_EXP 14
11761: PPUSH
11762: LD_INT 95
11764: PUSH
11765: LD_INT 11
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PPUSH
11772: CALL_OW 72
11776: ST_TO_ADDR
// if tmp then
11777: LD_VAR 0 3
11781: IFFALSE 11860
// for i in tmp do
11783: LD_ADDR_VAR 0 2
11787: PUSH
11788: LD_VAR 0 3
11792: PUSH
11793: FOR_IN
11794: IFFALSE 11858
// begin ruOutpost := ruOutpost diff i ;
11796: LD_ADDR_EXP 14
11800: PUSH
11801: LD_EXP 14
11805: PUSH
11806: LD_VAR 0 2
11810: DIFF
11811: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11812: LD_ADDR_EXP 31
11816: PUSH
11817: LD_EXP 31
11821: PPUSH
11822: LD_EXP 8
11826: PUSH
11827: LD_EXP 31
11831: PUSH
11832: LD_EXP 8
11836: ARRAY
11837: PUSH
11838: LD_INT 1
11840: PLUS
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: PPUSH
11846: LD_VAR 0 2
11850: PPUSH
11851: CALL 25021 0 3
11855: ST_TO_ADDR
// end ;
11856: GO 11793
11858: POP
11859: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11860: LD_EXP 14
11864: PPUSH
11865: LD_INT 21
11867: PUSH
11868: LD_INT 1
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: PPUSH
11875: CALL_OW 72
11879: NOT
11880: IFFALSE 11745
// ruOutpost := [ ] ;
11882: LD_ADDR_EXP 14
11886: PUSH
11887: EMPTY
11888: ST_TO_ADDR
// end ;
11889: LD_VAR 0 1
11893: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11894: LD_EXP 27
11898: IFFALSE 12087
11900: GO 11902
11902: DISABLE
11903: LD_INT 0
11905: PPUSH
11906: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11907: LD_INT 875
11909: PPUSH
11910: LD_INT 1225
11912: PPUSH
11913: CALL_OW 12
11917: PPUSH
11918: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11922: LD_ADDR_VAR 0 2
11926: PUSH
11927: LD_INT 208
11929: PUSH
11930: LD_INT 166
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: PUSH
11937: LD_INT 218
11939: PUSH
11940: LD_INT 174
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 201
11949: PUSH
11950: LD_INT 173
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 189
11959: PUSH
11960: LD_INT 167
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 191
11969: PUSH
11970: LD_INT 160
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 209
11979: PUSH
11980: LD_INT 181
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 192
11989: PUSH
11990: LD_INT 162
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: LD_INT 197
11999: PUSH
12000: LD_INT 166
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
12017: LD_ADDR_VAR 0 1
12021: PUSH
12022: DOUBLE
12023: LD_INT 1
12025: DEC
12026: ST_TO_ADDR
12027: LD_INT 5
12029: PUSH
12030: LD_OWVAR 67
12034: PLUS
12035: PUSH
12036: FOR_TO
12037: IFFALSE 12085
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12039: LD_VAR 0 2
12043: PUSH
12044: LD_VAR 0 1
12048: ARRAY
12049: PUSH
12050: LD_INT 1
12052: ARRAY
12053: PPUSH
12054: LD_VAR 0 2
12058: PUSH
12059: LD_VAR 0 1
12063: ARRAY
12064: PUSH
12065: LD_INT 2
12067: ARRAY
12068: PPUSH
12069: LD_INT 1
12071: PPUSH
12072: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12076: LD_INT 28
12078: PPUSH
12079: CALL_OW 67
// end ;
12083: GO 12036
12085: POP
12086: POP
// end ;
12087: PPOPN 2
12089: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12090: LD_EXP 27
12094: NOT
12095: IFFALSE 12749
12097: GO 12099
12099: DISABLE
12100: LD_INT 0
12102: PPUSH
12103: PPUSH
12104: PPUSH
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// begin enable ;
12109: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12110: LD_ADDR_VAR 0 1
12114: PUSH
12115: LD_EXP 14
12119: PPUSH
12120: LD_INT 22
12122: PUSH
12123: LD_INT 3
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 25
12132: PUSH
12133: LD_INT 1
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PPUSH
12144: CALL_OW 72
12148: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12149: LD_ADDR_VAR 0 2
12153: PUSH
12154: LD_EXP 14
12158: PPUSH
12159: LD_INT 22
12161: PUSH
12162: LD_INT 3
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 25
12171: PUSH
12172: LD_INT 2
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 72
12187: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12188: LD_ADDR_VAR 0 3
12192: PUSH
12193: LD_EXP 14
12197: PPUSH
12198: LD_INT 22
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 21
12210: PUSH
12211: LD_INT 3
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 3
12220: PUSH
12221: LD_INT 24
12223: PUSH
12224: LD_INT 1000
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: LIST
12239: PPUSH
12240: CALL_OW 72
12244: ST_TO_ADDR
// if engs and buildings then
12245: LD_VAR 0 2
12249: PUSH
12250: LD_VAR 0 3
12254: AND
12255: IFFALSE 12328
// begin for i in engs do
12257: LD_ADDR_VAR 0 5
12261: PUSH
12262: LD_VAR 0 2
12266: PUSH
12267: FOR_IN
12268: IFFALSE 12324
// if IsInUnit ( i ) then
12270: LD_VAR 0 5
12274: PPUSH
12275: CALL_OW 310
12279: IFFALSE 12292
// ComExitBuilding ( i ) else
12281: LD_VAR 0 5
12285: PPUSH
12286: CALL_OW 122
12290: GO 12322
// if not HasTask ( i ) then
12292: LD_VAR 0 5
12296: PPUSH
12297: CALL_OW 314
12301: NOT
12302: IFFALSE 12322
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12304: LD_VAR 0 5
12308: PPUSH
12309: LD_VAR 0 3
12313: PUSH
12314: LD_INT 1
12316: ARRAY
12317: PPUSH
12318: CALL_OW 130
12322: GO 12267
12324: POP
12325: POP
// end else
12326: GO 12431
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12328: LD_VAR 0 3
12332: NOT
12333: PUSH
12334: LD_EXP 14
12338: PPUSH
12339: LD_INT 30
12341: PUSH
12342: LD_INT 0
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL_OW 72
12353: AND
12354: PUSH
12355: LD_VAR 0 2
12359: PPUSH
12360: LD_INT 3
12362: PUSH
12363: LD_INT 54
12365: PUSH
12366: EMPTY
12367: LIST
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 72
12377: AND
12378: IFFALSE 12431
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12380: LD_VAR 0 2
12384: PPUSH
12385: LD_INT 3
12387: PUSH
12388: LD_INT 54
12390: PUSH
12391: EMPTY
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 72
12402: PPUSH
12403: LD_EXP 14
12407: PPUSH
12408: LD_INT 30
12410: PUSH
12411: LD_INT 0
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PPUSH
12418: CALL_OW 72
12422: PUSH
12423: LD_INT 1
12425: ARRAY
12426: PPUSH
12427: CALL_OW 120
// if not tmp then
12431: LD_VAR 0 1
12435: NOT
12436: IFFALSE 12440
// exit ;
12438: GO 12749
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12440: LD_INT 26
12442: PPUSH
12443: LD_INT 81
12445: PUSH
12446: LD_INT 3
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PPUSH
12453: CALL_OW 70
12457: PUSH
12458: LD_INT 1
12460: GREATER
12461: IFFALSE 12517
// begin for i in tmp do
12463: LD_ADDR_VAR 0 5
12467: PUSH
12468: LD_VAR 0 1
12472: PUSH
12473: FOR_IN
12474: IFFALSE 12513
// begin if IsInUnit ( i ) then
12476: LD_VAR 0 5
12480: PPUSH
12481: CALL_OW 310
12485: IFFALSE 12496
// ComExitBuilding ( i ) ;
12487: LD_VAR 0 5
12491: PPUSH
12492: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12496: LD_VAR 0 5
12500: PPUSH
12501: LD_INT 204
12503: PPUSH
12504: LD_INT 164
12506: PPUSH
12507: CALL_OW 174
// end ;
12511: GO 12473
12513: POP
12514: POP
// end else
12515: GO 12749
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 3
12524: PUSH
12525: LD_INT 54
12527: PUSH
12528: EMPTY
12529: LIST
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL_OW 72
12539: IFFALSE 12749
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12541: LD_ADDR_VAR 0 4
12545: PUSH
12546: LD_EXP 14
12550: PPUSH
12551: LD_INT 30
12553: PUSH
12554: LD_INT 32
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 58
12563: PUSH
12564: EMPTY
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PPUSH
12571: CALL_OW 72
12575: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12576: LD_VAR 0 4
12580: NOT
12581: PUSH
12582: LD_EXP 14
12586: PPUSH
12587: LD_INT 30
12589: PUSH
12590: LD_INT 5
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: PPUSH
12597: CALL_OW 72
12601: AND
12602: IFFALSE 12639
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: LD_EXP 14
12613: PPUSH
12614: LD_INT 30
12616: PUSH
12617: LD_INT 5
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PPUSH
12624: CALL_OW 72
12628: PUSH
12629: LD_INT 1
12631: ARRAY
12632: PPUSH
12633: CALL_OW 120
// exit ;
12637: GO 12749
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12639: LD_ADDR_VAR 0 6
12643: PUSH
12644: LD_VAR 0 1
12648: PPUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 54
12654: PUSH
12655: EMPTY
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 72
12666: ST_TO_ADDR
// if j < empty then
12667: LD_VAR 0 6
12671: PUSH
12672: LD_VAR 0 4
12676: LESS
12677: IFFALSE 12691
// k := j else
12679: LD_ADDR_VAR 0 7
12683: PUSH
12684: LD_VAR 0 6
12688: ST_TO_ADDR
12689: GO 12701
// k := empty ;
12691: LD_ADDR_VAR 0 7
12695: PUSH
12696: LD_VAR 0 4
12700: ST_TO_ADDR
// for i = 1 to k do
12701: LD_ADDR_VAR 0 5
12705: PUSH
12706: DOUBLE
12707: LD_INT 1
12709: DEC
12710: ST_TO_ADDR
12711: LD_VAR 0 7
12715: PUSH
12716: FOR_TO
12717: IFFALSE 12747
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12719: LD_VAR 0 6
12723: PUSH
12724: LD_VAR 0 5
12728: ARRAY
12729: PPUSH
12730: LD_VAR 0 4
12734: PUSH
12735: LD_VAR 0 5
12739: ARRAY
12740: PPUSH
12741: CALL_OW 120
12745: GO 12716
12747: POP
12748: POP
// end ; end ;
12749: PPOPN 7
12751: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12752: LD_EXP 2
12756: PUSH
12757: LD_INT 1
12759: EQUAL
12760: PUSH
12761: LD_EXP 27
12765: AND
12766: PUSH
12767: LD_INT 22
12769: PUSH
12770: LD_INT 1
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 92
12779: PUSH
12780: LD_INT 208
12782: PUSH
12783: LD_INT 163
12785: PUSH
12786: LD_INT 8
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: AND
12804: PUSH
12805: LD_INT 22
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: LD_INT 21
12817: PUSH
12818: LD_INT 1
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 92
12827: PUSH
12828: LD_INT 208
12830: PUSH
12831: LD_INT 163
12833: PUSH
12834: LD_INT 14
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL_OW 69
12852: NOT
12853: AND
12854: IFFALSE 13159
12856: GO 12858
12858: DISABLE
12859: LD_INT 0
12861: PPUSH
// begin InGameOn ;
12862: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12866: LD_EXP 9
12870: PPUSH
12871: CALL_OW 87
// wait ( 0 0$1 ) ;
12875: LD_INT 35
12877: PPUSH
12878: CALL_OW 67
// DialogueOn ;
12882: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12886: LD_EXP 9
12890: PPUSH
12891: LD_STRING D
12893: PUSH
12894: LD_STRING I
12896: PUSH
12897: LD_STRING J
12899: PUSH
12900: LD_STRING S
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: LIST
12907: PUSH
12908: LD_EXP 25
12912: ARRAY
12913: STR
12914: PUSH
12915: LD_STRING -1-BaseCaptured
12917: STR
12918: PPUSH
12919: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12923: LD_EXP 12
12927: PPUSH
12928: LD_STRING DP-1-BaseCaptured
12930: PPUSH
12931: CALL_OW 94
// if sibBombAllowed then
12935: LD_EXP 23
12939: IFFALSE 13081
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12941: LD_EXP 9
12945: PPUSH
12946: LD_STRING D
12948: PUSH
12949: LD_STRING I
12951: PUSH
12952: LD_STRING J
12954: PUSH
12955: LD_STRING S
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: PUSH
12963: LD_EXP 25
12967: ARRAY
12968: STR
12969: PUSH
12970: LD_STRING -2-BaseCaptured
12972: STR
12973: PPUSH
12974: CALL_OW 88
// if commander = 1 then
12978: LD_EXP 25
12982: PUSH
12983: LD_INT 1
12985: EQUAL
12986: IFFALSE 13000
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12988: LD_EXP 12
12992: PPUSH
12993: LD_STRING DP-2b-BaseCaptured
12995: PPUSH
12996: CALL_OW 94
// if commander = 2 then
13000: LD_EXP 25
13004: PUSH
13005: LD_INT 2
13007: EQUAL
13008: IFFALSE 13022
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
13010: LD_EXP 12
13014: PPUSH
13015: LD_STRING DP-2-BaseCaptured
13017: PPUSH
13018: CALL_OW 94
// if commander = 3 then
13022: LD_EXP 25
13026: PUSH
13027: LD_INT 3
13029: EQUAL
13030: IFFALSE 13044
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13032: LD_EXP 12
13036: PPUSH
13037: LD_STRING DP-2a-BaseCaptured
13039: PPUSH
13040: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13044: LD_EXP 9
13048: PPUSH
13049: LD_STRING D
13051: PUSH
13052: LD_STRING I
13054: PUSH
13055: LD_STRING J
13057: PUSH
13058: LD_STRING S
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: LIST
13065: PUSH
13066: LD_EXP 25
13070: ARRAY
13071: STR
13072: PUSH
13073: LD_STRING -3-BaseCaptured
13075: STR
13076: PPUSH
13077: CALL_OW 88
// end ; DialogueOff ;
13081: CALL_OW 7
// InGameOff ;
13085: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13089: LD_STRING O2
13091: PPUSH
13092: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13096: LD_ADDR_VAR 0 1
13100: PUSH
13101: LD_EXP 14
13105: PPUSH
13106: LD_INT 21
13108: PUSH
13109: LD_INT 3
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PPUSH
13116: CALL_OW 72
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13138
// SetSide ( i , 1 ) ;
13124: LD_VAR 0 1
13128: PPUSH
13129: LD_INT 1
13131: PPUSH
13132: CALL_OW 235
13136: GO 13121
13138: POP
13139: POP
// baseCaptured := true ;
13140: LD_ADDR_EXP 17
13144: PUSH
13145: LD_INT 1
13147: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13148: LD_INT 1225
13150: PPUSH
13151: CALL_OW 67
// PrepareReinforcements ;
13155: CALL 9908 0 0
// end ;
13159: PPOPN 1
13161: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13162: LD_INT 22
13164: PUSH
13165: LD_INT 3
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 92
13174: PUSH
13175: LD_INT 167
13177: PUSH
13178: LD_INT 197
13180: PUSH
13181: LD_INT 20
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 69
13198: PUSH
13199: LD_INT 3
13201: GREATER
13202: IFFALSE 13219
13204: GO 13206
13206: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13207: LD_EXP 12
13211: PPUSH
13212: LD_STRING DP-RuAttack
13214: PPUSH
13215: CALL_OW 94
13219: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13220: LD_EXP 1
13224: NOT
13225: PUSH
13226: LD_INT 1
13228: PPUSH
13229: LD_INT 168
13231: PPUSH
13232: LD_INT 74
13234: PPUSH
13235: CALL_OW 293
13239: AND
13240: PUSH
13241: LD_INT 168
13243: PPUSH
13244: LD_INT 72
13246: PPUSH
13247: CALL_OW 553
13251: AND
13252: IFFALSE 13304
13254: GO 13256
13256: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13257: LD_INT 168
13259: PPUSH
13260: LD_INT 72
13262: PPUSH
13263: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13267: LD_EXP 9
13271: PPUSH
13272: LD_STRING D
13274: PUSH
13275: LD_STRING I
13277: PUSH
13278: LD_STRING J
13280: PUSH
13281: LD_STRING S
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_EXP 25
13293: ARRAY
13294: STR
13295: PUSH
13296: LD_STRING -1-Blockade
13298: STR
13299: PPUSH
13300: CALL_OW 88
// end ;
13304: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13305: LD_EXP 2
13309: PUSH
13310: LD_INT 1
13312: EQUAL
13313: PUSH
13314: LD_INT 22
13316: PUSH
13317: LD_INT 1
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: LD_INT 101
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: AND
13343: IFFALSE 13875
13345: GO 13347
13347: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13348: LD_INT 4
13350: PPUSH
13351: LD_INT 1
13353: PPUSH
13354: CALL_OW 343
// DialogueOn ;
13358: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13362: LD_EXP 11
13366: PPUSH
13367: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13371: LD_EXP 11
13375: PPUSH
13376: LD_STRING DM-1-Contact
13378: PPUSH
13379: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13383: LD_EXP 9
13387: PPUSH
13388: LD_STRING D
13390: PUSH
13391: LD_STRING I
13393: PUSH
13394: LD_STRING J
13396: PUSH
13397: LD_STRING S
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: LIST
13404: PUSH
13405: LD_EXP 25
13409: ARRAY
13410: STR
13411: PUSH
13412: LD_STRING -1-Contact
13414: STR
13415: PPUSH
13416: CALL_OW 88
// if commander = 1 then
13420: LD_EXP 25
13424: PUSH
13425: LD_INT 1
13427: EQUAL
13428: IFFALSE 13560
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13430: LD_EXP 11
13434: PPUSH
13435: LD_STRING DM-2-Contact
13437: PPUSH
13438: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13442: LD_EXP 9
13446: PPUSH
13447: LD_STRING DI-2-Contact
13449: PPUSH
13450: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13454: LD_INT 22
13456: PUSH
13457: LD_INT 8
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 21
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PPUSH
13478: CALL_OW 69
13482: PUSH
13483: LD_INT 8
13485: PPUSH
13486: LD_INT 1
13488: PPUSH
13489: CALL_OW 81
13493: PUSH
13494: LD_INT 2
13496: EQUAL
13497: AND
13498: IFFALSE 13524
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13500: LD_EXP 11
13504: PPUSH
13505: LD_STRING DM-3-Contact
13507: PPUSH
13508: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13512: LD_EXP 9
13516: PPUSH
13517: LD_STRING DI-3-Contact
13519: PPUSH
13520: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13524: LD_EXP 11
13528: PPUSH
13529: LD_STRING DM-4-Contact
13531: PPUSH
13532: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13536: LD_EXP 9
13540: PPUSH
13541: LD_STRING DI-4-Contact
13543: PPUSH
13544: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13548: LD_EXP 11
13552: PPUSH
13553: LD_STRING DM-5-Contact
13555: PPUSH
13556: CALL_OW 94
// end ; if commander = 2 then
13560: LD_EXP 25
13564: PUSH
13565: LD_INT 2
13567: EQUAL
13568: IFFALSE 13700
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13570: LD_EXP 11
13574: PPUSH
13575: LD_STRING DM-2c-Contact
13577: PPUSH
13578: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13582: LD_EXP 9
13586: PPUSH
13587: LD_STRING DJ-2-Contact
13589: PPUSH
13590: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13594: LD_INT 22
13596: PUSH
13597: LD_INT 8
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: LD_INT 21
13606: PUSH
13607: LD_INT 1
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PPUSH
13618: CALL_OW 69
13622: PUSH
13623: LD_INT 8
13625: PPUSH
13626: LD_INT 1
13628: PPUSH
13629: CALL_OW 81
13633: PUSH
13634: LD_INT 2
13636: EQUAL
13637: AND
13638: IFFALSE 13664
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13640: LD_EXP 11
13644: PPUSH
13645: LD_STRING DM-3-Contact
13647: PPUSH
13648: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13652: LD_EXP 9
13656: PPUSH
13657: LD_STRING DJ-3-Contact
13659: PPUSH
13660: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13664: LD_EXP 11
13668: PPUSH
13669: LD_STRING DM-4-Contact
13671: PPUSH
13672: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13676: LD_EXP 9
13680: PPUSH
13681: LD_STRING DJ-4-Contact
13683: PPUSH
13684: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13688: LD_EXP 11
13692: PPUSH
13693: LD_STRING DM-5a-Contact
13695: PPUSH
13696: CALL_OW 94
// end ; if commander = 3 then
13700: LD_EXP 25
13704: PUSH
13705: LD_INT 3
13707: EQUAL
13708: IFFALSE 13864
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13710: LD_EXP 11
13714: PPUSH
13715: LD_STRING DM-2a-Contact
13717: PPUSH
13718: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13722: LD_EXP 9
13726: PPUSH
13727: LD_STRING DS-2a-Contact
13729: PPUSH
13730: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13734: LD_EXP 11
13738: PPUSH
13739: LD_STRING DM-2b-Contact
13741: PPUSH
13742: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13746: LD_EXP 9
13750: PPUSH
13751: LD_STRING DS-2b-Contact
13753: PPUSH
13754: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13758: LD_INT 22
13760: PUSH
13761: LD_INT 8
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PUSH
13768: LD_INT 21
13770: PUSH
13771: LD_INT 1
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_INT 8
13789: PPUSH
13790: LD_INT 1
13792: PPUSH
13793: CALL_OW 81
13797: PUSH
13798: LD_INT 2
13800: EQUAL
13801: AND
13802: IFFALSE 13828
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13804: LD_EXP 11
13808: PPUSH
13809: LD_STRING DM-3-Contact
13811: PPUSH
13812: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13816: LD_EXP 9
13820: PPUSH
13821: LD_STRING DS-3-Contact
13823: PPUSH
13824: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13828: LD_EXP 11
13832: PPUSH
13833: LD_STRING DM-4-Contact
13835: PPUSH
13836: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13840: LD_EXP 9
13844: PPUSH
13845: LD_STRING DS-4-Contact
13847: PPUSH
13848: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13852: LD_EXP 11
13856: PPUSH
13857: LD_STRING DM-5-Contact
13859: PPUSH
13860: CALL_OW 94
// end ; DialogueOff ;
13864: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13868: LD_STRING O3
13870: PPUSH
13871: CALL_OW 337
// end ;
13875: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13876: LD_EXP 2
13880: PUSH
13881: LD_INT 1
13883: EQUAL
13884: PUSH
13885: LD_EXP 18
13889: PUSH
13890: LD_INT 15
13892: PUSH
13893: LD_INT 20
13895: PUSH
13896: LD_INT 25
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: LIST
13903: PUSH
13904: LD_OWVAR 67
13908: ARRAY
13909: GREATEREQUAL
13910: AND
13911: PUSH
13912: LD_INT 22
13914: PUSH
13915: LD_INT 8
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: LD_INT 30
13924: PUSH
13925: LD_INT 1
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PPUSH
13936: CALL_OW 69
13940: AND
13941: PUSH
13942: LD_INT 22
13944: PUSH
13945: LD_INT 8
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 21
13954: PUSH
13955: LD_INT 3
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PPUSH
13966: CALL_OW 69
13970: PUSH
13971: LD_INT 5
13973: GREATEREQUAL
13974: AND
13975: IFFALSE 14498
13977: GO 13979
13979: DISABLE
13980: LD_INT 0
13982: PPUSH
13983: PPUSH
13984: PPUSH
13985: PPUSH
// begin DialogueOn ;
13986: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13990: LD_EXP 13
13994: PPUSH
13995: LD_STRING DF-1-Leg
13997: PPUSH
13998: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14002: LD_EXP 9
14006: PPUSH
14007: LD_STRING D
14009: PUSH
14010: LD_STRING I
14012: PUSH
14013: LD_STRING J
14015: PUSH
14016: LD_STRING S
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: LIST
14023: PUSH
14024: LD_EXP 25
14028: ARRAY
14029: STR
14030: PUSH
14031: LD_STRING -1-Leg
14033: STR
14034: PPUSH
14035: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14039: LD_EXP 13
14043: PPUSH
14044: LD_STRING DF-2-Leg
14046: PPUSH
14047: CALL_OW 94
// DialogueOff ;
14051: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14055: LD_STRING QLegionOffer
14057: PPUSH
14058: CALL_OW 97
14062: PUSH
14063: LD_INT 1
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14074
14071: POP
// ; 2 :
14072: GO 14088
14074: LD_INT 2
14076: DOUBLE
14077: EQUAL
14078: IFTRUE 14082
14080: GO 14087
14082: POP
// exit ; end ;
14083: GO 14498
14085: GO 14088
14087: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14088: LD_EXP 9
14092: PPUSH
14093: LD_STRING D
14095: PUSH
14096: LD_STRING I
14098: PUSH
14099: LD_STRING J
14101: PUSH
14102: LD_STRING S
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PUSH
14110: LD_EXP 25
14114: ARRAY
14115: STR
14116: PUSH
14117: LD_STRING -2-Leg
14119: STR
14120: PPUSH
14121: CALL_OW 88
// legOfferAccepted := true ;
14125: LD_ADDR_EXP 20
14129: PUSH
14130: LD_INT 1
14132: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14133: LD_INT 21
14135: PPUSH
14136: LD_INT 1
14138: PPUSH
14139: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14143: LD_INT 190
14145: PPUSH
14146: LD_INT 227
14148: PPUSH
14149: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14153: LD_ADDR_VAR 0 1
14157: PUSH
14158: LD_INT 16800
14160: PUSH
14161: LD_INT 14700
14163: PUSH
14164: LD_INT 12600
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: LIST
14171: PUSH
14172: LD_OWVAR 67
14176: ARRAY
14177: ST_TO_ADDR
// sib := 100 ;
14178: LD_ADDR_VAR 0 2
14182: PUSH
14183: LD_INT 100
14185: ST_TO_ADDR
// disableGlobalTimer := true ;
14186: LD_ADDR_EXP 4
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14194: LD_INT 35
14196: PPUSH
14197: CALL_OW 67
// time := time - 0 0$1 ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_VAR 0 1
14210: PUSH
14211: LD_INT 35
14213: MINUS
14214: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14215: LD_ADDR_VAR 0 3
14219: PUSH
14220: LD_INT 21
14222: PPUSH
14223: LD_INT 3
14225: PPUSH
14226: CALL_OW 287
14230: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14231: LD_ADDR_OWVAR 47
14235: PUSH
14236: LD_STRING #SkrTime
14238: PUSH
14239: LD_OWVAR 1
14243: PUSH
14244: LD_STRING #Skr-LegOffer
14246: PUSH
14247: LD_VAR 0 2
14251: PUSH
14252: LD_VAR 0 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: ST_TO_ADDR
// if sources then
14264: LD_VAR 0 3
14268: IFFALSE 14300
// begin sib := sib - sources * 10 ;
14270: LD_ADDR_VAR 0 2
14274: PUSH
14275: LD_VAR 0 2
14279: PUSH
14280: LD_VAR 0 3
14284: PUSH
14285: LD_INT 10
14287: MUL
14288: MINUS
14289: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14290: LD_INT 21
14292: PPUSH
14293: LD_INT 3
14295: PPUSH
14296: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14300: LD_VAR 0 1
14304: PUSH
14305: LD_INT 0
14307: EQUAL
14308: PUSH
14309: LD_VAR 0 2
14313: PUSH
14314: LD_INT 0
14316: LESSEQUAL
14317: OR
14318: PUSH
14319: LD_INT 22
14321: PUSH
14322: LD_INT 8
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PPUSH
14329: CALL_OW 69
14333: NOT
14334: OR
14335: IFFALSE 14194
// SetAreaMapShow ( legOfferArea , 0 ) ;
14337: LD_INT 21
14339: PPUSH
14340: LD_INT 0
14342: PPUSH
14343: CALL_OW 424
// disableGlobalTimer := false ;
14347: LD_ADDR_EXP 4
14351: PUSH
14352: LD_INT 0
14354: ST_TO_ADDR
// if sib <= 0 then
14355: LD_VAR 0 2
14359: PUSH
14360: LD_INT 0
14362: LESSEQUAL
14363: IFFALSE 14479
// begin legChangeSide := true ;
14365: LD_ADDR_EXP 21
14369: PUSH
14370: LD_INT 1
14372: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14373: LD_EXP 13
14377: PPUSH
14378: LD_STRING DF-4y-Leg
14380: PPUSH
14381: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14385: LD_STRING O3a
14387: PPUSH
14388: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14392: LD_INT 8
14394: PPUSH
14395: LD_INT 1
14397: PPUSH
14398: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14402: LD_INT 8
14404: PPUSH
14405: LD_INT 1
14407: PPUSH
14408: LD_INT 1
14410: PPUSH
14411: LD_INT 1
14413: PPUSH
14414: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14418: LD_INT 8
14420: PPUSH
14421: LD_INT 4
14423: PPUSH
14424: LD_INT 1
14426: PPUSH
14427: LD_INT 1
14429: PPUSH
14430: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14434: LD_INT 8
14436: PPUSH
14437: LD_INT 6
14439: PPUSH
14440: LD_INT 2
14442: PPUSH
14443: LD_INT 1
14445: PPUSH
14446: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14450: LD_INT 8
14452: PPUSH
14453: LD_INT 3
14455: PPUSH
14456: LD_INT 2
14458: PPUSH
14459: LD_INT 1
14461: PPUSH
14462: CALL_OW 80
// wait ( 0 0$30 ) ;
14466: LD_INT 1050
14468: PPUSH
14469: CALL_OW 67
// PrepareLegionReinforcements ;
14473: CALL 10608 0 0
// end else
14477: GO 14498
// begin ChangeMissionObjectives ( O3a ) ;
14479: LD_STRING O3a
14481: PPUSH
14482: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14486: LD_EXP 13
14490: PPUSH
14491: LD_STRING DF-4n-Leg
14493: PPUSH
14494: CALL_OW 94
// end ; end ;
14498: PPOPN 4
14500: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14501: LD_INT 22
14503: PUSH
14504: LD_INT 8
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PPUSH
14525: CALL_OW 69
14529: PUSH
14530: LD_INT 0
14532: EQUAL
14533: PUSH
14534: LD_INT 8
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: CALL_OW 81
14544: PUSH
14545: LD_INT 2
14547: EQUAL
14548: AND
14549: IFFALSE 14561
14551: GO 14553
14553: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14554: LD_STRING O3a
14556: PPUSH
14557: CALL_OW 337
14561: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14562: LD_EXP 2
14566: PUSH
14567: LD_INT 1
14569: EQUAL
14570: PUSH
14571: LD_EXP 3
14575: AND
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 1
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_INT 0
14608: EQUAL
14609: AND
14610: PUSH
14611: LD_INT 22
14613: PUSH
14614: LD_INT 3
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 30
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: PUSH
14640: LD_INT 0
14642: EQUAL
14643: AND
14644: IFFALSE 14882
14646: GO 14648
14648: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14649: LD_EXP 9
14653: PPUSH
14654: LD_STRING D
14656: PUSH
14657: LD_STRING I
14659: PUSH
14660: LD_STRING J
14662: PUSH
14663: LD_STRING S
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: PUSH
14671: LD_EXP 25
14675: ARRAY
14676: STR
14677: PUSH
14678: LD_STRING -1-Win
14680: STR
14681: PPUSH
14682: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14686: LD_OWVAR 1
14690: PUSH
14691: LD_INT 315000
14693: PUSH
14694: LD_INT 273000
14696: PUSH
14697: LD_INT 231000
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: LIST
14704: PUSH
14705: LD_OWVAR 67
14709: ARRAY
14710: GREATEREQUAL
14711: IFFALSE 14726
// AddMedal ( med1 , - 1 ) else
14713: LD_STRING med1
14715: PPUSH
14716: LD_INT 1
14718: NEG
14719: PPUSH
14720: CALL_OW 101
14724: GO 14736
// AddMedal ( med1 , 1 ) ;
14726: LD_STRING med1
14728: PPUSH
14729: LD_INT 1
14731: PPUSH
14732: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14736: LD_EXP 22
14740: PUSH
14741: LD_INT 20
14743: PUSH
14744: LD_INT 15
14746: PUSH
14747: LD_INT 10
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: LIST
14754: PUSH
14755: LD_OWVAR 67
14759: ARRAY
14760: GREATEREQUAL
14761: IFFALSE 14776
// AddMedal ( med2 , - 1 ) else
14763: LD_STRING med2
14765: PPUSH
14766: LD_INT 1
14768: NEG
14769: PPUSH
14770: CALL_OW 101
14774: GO 14786
// AddMedal ( med2 , 1 ) ;
14776: LD_STRING med2
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14786: LD_INT 8
14788: PPUSH
14789: LD_INT 1
14791: PPUSH
14792: CALL_OW 81
14796: PUSH
14797: LD_INT 1
14799: EQUAL
14800: IFFALSE 14814
// AddMedal ( med3 , 1 ) else
14802: LD_STRING med3
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL_OW 101
14812: GO 14871
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14814: LD_INT 22
14816: PUSH
14817: LD_INT 8
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: PUSH
14824: LD_INT 21
14826: PUSH
14827: LD_INT 1
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: PPUSH
14838: CALL_OW 69
14842: PUSH
14843: LD_INT 0
14845: EQUAL
14846: IFFALSE 14860
// AddMedal ( med3 , 2 ) else
14848: LD_STRING med3
14850: PPUSH
14851: LD_INT 2
14853: PPUSH
14854: CALL_OW 101
14858: GO 14871
// AddMedal ( med3 , - 1 ) ;
14860: LD_STRING med3
14862: PPUSH
14863: LD_INT 1
14865: NEG
14866: PPUSH
14867: CALL_OW 101
// GiveMedals ( MAIN ) ;
14871: LD_STRING MAIN
14873: PPUSH
14874: CALL_OW 102
// YouWin ;
14878: CALL_OW 103
// end ;
14882: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14883: LD_EXP 2
14887: PUSH
14888: LD_INT 1
14890: EQUAL
14891: PUSH
14892: LD_EXP 16
14896: AND
14897: PUSH
14898: LD_INT 20
14900: PPUSH
14901: LD_INT 81
14903: PUSH
14904: LD_INT 8
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PPUSH
14911: CALL_OW 70
14915: AND
14916: IFFALSE 15195
14918: GO 14920
14920: DISABLE
14921: LD_INT 0
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
14927: PPUSH
// begin enable ;
14928: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14929: LD_ADDR_VAR 0 3
14933: PUSH
14934: LD_INT 20
14936: PPUSH
14937: LD_INT 81
14939: PUSH
14940: LD_INT 8
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL_OW 70
14951: ST_TO_ADDR
// if not tmp then
14952: LD_VAR 0 3
14956: NOT
14957: IFFALSE 14961
// exit ;
14959: GO 15195
// for i in tmp do
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_VAR 0 3
14970: PUSH
14971: FOR_IN
14972: IFFALSE 15193
// begin x := GetX ( i ) ;
14974: LD_ADDR_VAR 0 4
14978: PUSH
14979: LD_VAR 0 1
14983: PPUSH
14984: CALL_OW 250
14988: ST_TO_ADDR
// y := GetY ( i ) ;
14989: LD_ADDR_VAR 0 5
14993: PUSH
14994: LD_VAR 0 1
14998: PPUSH
14999: CALL_OW 251
15003: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15004: LD_VAR 0 4
15008: PPUSH
15009: LD_VAR 0 5
15013: PPUSH
15014: CALL_OW 458
15018: IFFALSE 15191
// begin LaunchMineAtPos ( x , y , 8 ) ;
15020: LD_VAR 0 4
15024: PPUSH
15025: LD_VAR 0 5
15029: PPUSH
15030: LD_INT 8
15032: PPUSH
15033: CALL_OW 456
// if not dialogueMineDetected then
15037: LD_EXP 28
15041: NOT
15042: IFFALSE 15103
// begin dialogueMineDetected := true ;
15044: LD_ADDR_EXP 28
15048: PUSH
15049: LD_INT 1
15051: ST_TO_ADDR
// CenterNowOnXY ( x , y ) ;
15052: LD_VAR 0 4
15056: PPUSH
15057: LD_VAR 0 5
15061: PPUSH
15062: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15066: LD_EXP 9
15070: PPUSH
15071: LD_STRING D
15073: PUSH
15074: LD_STRING I
15076: PUSH
15077: LD_STRING J
15079: PUSH
15080: LD_STRING S
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: LIST
15087: PUSH
15088: LD_EXP 25
15092: ARRAY
15093: STR
15094: PUSH
15095: LD_STRING -1-Mine
15097: STR
15098: PPUSH
15099: CALL_OW 88
// end ; for j = 1 to staticMines do
15103: LD_ADDR_VAR 0 2
15107: PUSH
15108: DOUBLE
15109: LD_INT 1
15111: DEC
15112: ST_TO_ADDR
15113: LD_EXP 16
15117: PUSH
15118: FOR_TO
15119: IFFALSE 15189
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15121: LD_EXP 16
15125: PUSH
15126: LD_VAR 0 2
15130: ARRAY
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 4
15140: EQUAL
15141: PUSH
15142: LD_EXP 16
15146: PUSH
15147: LD_VAR 0 2
15151: ARRAY
15152: PUSH
15153: LD_INT 2
15155: ARRAY
15156: PUSH
15157: LD_VAR 0 5
15161: EQUAL
15162: AND
15163: IFFALSE 15187
// begin staticMines := Delete ( staticMines , j ) ;
15165: LD_ADDR_EXP 16
15169: PUSH
15170: LD_EXP 16
15174: PPUSH
15175: LD_VAR 0 2
15179: PPUSH
15180: CALL_OW 3
15184: ST_TO_ADDR
// break ;
15185: GO 15189
// end ;
15187: GO 15118
15189: POP
15190: POP
// end ; end ;
15191: GO 14971
15193: POP
15194: POP
// end ;
15195: PPOPN 5
15197: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15198: LD_EXP 2
15202: PUSH
15203: LD_INT 1
15205: EQUAL
15206: PUSH
15207: LD_EXP 3
15211: AND
15212: PUSH
15213: LD_EXP 23
15217: AND
15218: PUSH
15219: LD_EXP 31
15223: PUSH
15224: LD_EXP 7
15228: ARRAY
15229: PPUSH
15230: LD_INT 30
15232: PUSH
15233: LD_INT 3
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 72
15244: AND
15245: IFFALSE 15449
15247: GO 15249
15249: DISABLE
15250: LD_INT 0
15252: PPUSH
15253: PPUSH
// begin enable ;
15254: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15255: LD_EXP 7
15259: PPUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 3
15265: PUSH
15266: LD_INT 3
15268: PUSH
15269: LD_INT 48
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: PUSH
15278: EMPTY
15279: LIST
15280: PPUSH
15281: CALL 85581 0 2
// repeat wait ( 0 0$1 ) ;
15285: LD_INT 35
15287: PPUSH
15288: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15292: LD_INT 22
15294: PUSH
15295: LD_INT 3
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: LD_INT 34
15304: PUSH
15305: LD_INT 48
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PPUSH
15316: CALL_OW 69
15320: IFFALSE 15285
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: LD_INT 22
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 34
15339: PUSH
15340: LD_INT 48
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: PPUSH
15351: CALL_OW 69
15355: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15356: LD_ADDR_VAR 0 2
15360: PUSH
15361: LD_INT 81
15363: PUSH
15364: LD_INT 3
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: LD_INT 21
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PPUSH
15385: CALL_OW 69
15389: ST_TO_ADDR
// if e then
15390: LD_VAR 0 2
15394: IFFALSE 15420
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15396: LD_ADDR_VAR 0 2
15400: PUSH
15401: LD_VAR 0 2
15405: PPUSH
15406: LD_VAR 0 1
15410: PUSH
15411: LD_INT 1
15413: ARRAY
15414: PPUSH
15415: CALL_OW 74
15419: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15420: LD_VAR 0 1
15424: PPUSH
15425: LD_VAR 0 2
15429: PPUSH
15430: CALL_OW 250
15434: PPUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: CALL_OW 251
15444: PPUSH
15445: CALL_OW 116
// end ;
15449: PPOPN 2
15451: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15452: LD_OWVAR 67
15456: PUSH
15457: LD_INT 1
15459: GREATER
15460: PUSH
15461: LD_EXP 31
15465: PUSH
15466: LD_EXP 7
15470: ARRAY
15471: PPUSH
15472: LD_INT 25
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 72
15486: AND
15487: PUSH
15488: LD_EXP 2
15492: PUSH
15493: LD_INT 1
15495: EQUAL
15496: AND
15497: PUSH
15498: LD_EXP 3
15502: AND
15503: PUSH
15504: LD_INT 23
15506: PPUSH
15507: LD_INT 3
15509: PPUSH
15510: CALL_OW 321
15514: PUSH
15515: LD_INT 2
15517: EQUAL
15518: AND
15519: IFFALSE 15646
15521: GO 15523
15523: DISABLE
15524: LD_INT 0
15526: PPUSH
15527: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15528: LD_ADDR_VAR 0 1
15532: PUSH
15533: LD_EXP 31
15537: PUSH
15538: LD_EXP 7
15542: ARRAY
15543: PPUSH
15544: LD_INT 25
15546: PUSH
15547: LD_INT 3
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 72
15558: ST_TO_ADDR
// if not tmp then
15559: LD_VAR 0 1
15563: NOT
15564: IFFALSE 15568
// exit ;
15566: GO 15646
// for i in tmp do
15568: LD_ADDR_VAR 0 2
15572: PUSH
15573: LD_VAR 0 1
15577: PUSH
15578: FOR_IN
15579: IFFALSE 15625
// begin SetTag ( i , 29 ) ;
15581: LD_VAR 0 2
15585: PPUSH
15586: LD_INT 29
15588: PPUSH
15589: CALL_OW 109
// ComExitBuilding ( i ) ;
15593: LD_VAR 0 2
15597: PPUSH
15598: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15602: LD_VAR 0 2
15606: PPUSH
15607: LD_INT 37
15609: PPUSH
15610: LD_INT 97
15612: PPUSH
15613: LD_INT 133
15615: PPUSH
15616: LD_INT 0
15618: PPUSH
15619: CALL_OW 230
// end ;
15623: GO 15578
15625: POP
15626: POP
// wait ( 1 1$00 ) ;
15627: LD_INT 2100
15629: PPUSH
15630: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15634: LD_EXP 7
15638: PPUSH
15639: LD_INT 29
15641: PPUSH
15642: CALL 65466 0 2
// end ;
15646: PPOPN 2
15648: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15649: LD_EXP 2
15653: PUSH
15654: LD_INT 1
15656: EQUAL
15657: PUSH
15658: LD_INT 84
15660: PPUSH
15661: LD_INT 128
15663: PPUSH
15664: CALL_OW 428
15668: PPUSH
15669: CALL_OW 266
15673: PUSH
15674: LD_INT 1
15676: EQUAL
15677: AND
15678: PUSH
15679: LD_INT 84
15681: PPUSH
15682: LD_INT 128
15684: PPUSH
15685: CALL_OW 428
15689: PPUSH
15690: CALL_OW 255
15694: PUSH
15695: LD_INT 3
15697: EQUAL
15698: AND
15699: IFFALSE 15872
15701: GO 15703
15703: DISABLE
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// begin enable ;
15708: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15709: LD_ADDR_VAR 0 2
15713: PUSH
15714: LD_INT 84
15716: PPUSH
15717: LD_INT 128
15719: PPUSH
15720: CALL_OW 428
15724: ST_TO_ADDR
// uc_side := 3 ;
15725: LD_ADDR_OWVAR 20
15729: PUSH
15730: LD_INT 3
15732: ST_TO_ADDR
// uc_nation := 3 ;
15733: LD_ADDR_OWVAR 21
15737: PUSH
15738: LD_INT 3
15740: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15741: LD_INT 21
15743: PPUSH
15744: LD_INT 3
15746: PPUSH
15747: LD_INT 3
15749: PPUSH
15750: LD_INT 51
15752: PPUSH
15753: LD_INT 0
15755: PPUSH
15756: CALL 24899 0 5
// veh := CreateVehicle ;
15760: LD_ADDR_VAR 0 1
15764: PUSH
15765: CALL_OW 45
15769: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_INT 126
15777: PPUSH
15778: LD_INT 227
15780: PPUSH
15781: LD_INT 0
15783: PPUSH
15784: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15788: LD_VAR 0 1
15792: PPUSH
15793: LD_INT 2
15795: PPUSH
15796: LD_INT 100
15798: PPUSH
15799: CALL_OW 290
// ComGive ( veh , depot ) ;
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_VAR 0 2
15812: PPUSH
15813: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15817: LD_VAR 0 1
15821: PPUSH
15822: LD_INT 126
15824: PPUSH
15825: LD_INT 227
15827: PPUSH
15828: CALL_OW 171
// wait ( 0 0$10 ) ;
15832: LD_INT 350
15834: PPUSH
15835: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15839: LD_INT 35
15841: PPUSH
15842: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15846: LD_VAR 0 1
15850: PPUSH
15851: LD_INT 126
15853: PPUSH
15854: LD_INT 227
15856: PPUSH
15857: CALL_OW 307
15861: IFFALSE 15839
// RemoveUnit ( veh ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 64
// end ;
15872: PPOPN 2
15874: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15875: LD_EXP 2
15879: PUSH
15880: LD_INT 1
15882: EQUAL
15883: PUSH
15884: LD_EXP 27
15888: AND
15889: PUSH
15890: LD_EXP 25
15894: PUSH
15895: LD_INT 2
15897: EQUAL
15898: AND
15899: IFFALSE 16091
15901: GO 15903
15903: DISABLE
15904: LD_INT 0
15906: PPUSH
15907: PPUSH
// begin enable ;
15908: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15909: LD_OWVAR 1
15913: PUSH
15914: LD_INT 105000
15916: PUSH
15917: LD_INT 84000
15919: PUSH
15920: LD_INT 63000
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: LIST
15927: PUSH
15928: LD_OWVAR 67
15932: ARRAY
15933: GREATEREQUAL
15934: IFFALSE 15937
// disable ;
15936: DISABLE
// uc_side := 4 ;
15937: LD_ADDR_OWVAR 20
15941: PUSH
15942: LD_INT 4
15944: ST_TO_ADDR
// uc_nation := 1 ;
15945: LD_ADDR_OWVAR 21
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15953: LD_INT 2
15955: PPUSH
15956: LD_INT 3
15958: PPUSH
15959: LD_INT 3
15961: PPUSH
15962: LD_INT 12
15964: PPUSH
15965: LD_INT 0
15967: PPUSH
15968: CALL 24899 0 5
// veh := CreateVehicle ;
15972: LD_ADDR_VAR 0 1
15976: PUSH
15977: CALL_OW 45
15981: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 229
15989: PPUSH
15990: LD_INT 226
15992: PPUSH
15993: LD_INT 0
15995: PPUSH
15996: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16000: LD_VAR 0 1
16004: PPUSH
16005: LD_INT 1
16007: PPUSH
16008: LD_INT 100
16010: PPUSH
16011: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16015: LD_VAR 0 1
16019: PPUSH
16020: LD_INT 25
16022: PPUSH
16023: CALL_OW 173
// AddComUnload ( veh ) ;
16027: LD_VAR 0 1
16031: PPUSH
16032: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_INT 229
16043: PPUSH
16044: LD_INT 226
16046: PPUSH
16047: CALL_OW 171
// wait ( 0 0$10 ) ;
16051: LD_INT 350
16053: PPUSH
16054: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16058: LD_INT 35
16060: PPUSH
16061: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16065: LD_VAR 0 1
16069: PPUSH
16070: LD_INT 229
16072: PPUSH
16073: LD_INT 226
16075: PPUSH
16076: CALL_OW 307
16080: IFFALSE 16058
// RemoveUnit ( veh ) ;
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 64
// end ;
16091: PPOPN 2
16093: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16094: LD_EXP 2
16098: PUSH
16099: LD_INT 1
16101: EQUAL
16102: PUSH
16103: LD_EXP 3
16107: AND
16108: PUSH
16109: LD_EXP 24
16113: AND
16114: IFFALSE 16447
16116: GO 16118
16118: DISABLE
16119: LD_INT 0
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
16125: PPUSH
// begin enable ;
16126: ENABLE
// tmp := [ ] ;
16127: LD_ADDR_VAR 0 4
16131: PUSH
16132: EMPTY
16133: ST_TO_ADDR
// if commander = 1 then
16134: LD_EXP 25
16138: PUSH
16139: LD_INT 1
16141: EQUAL
16142: IFFALSE 16154
// amount := 3 else
16144: LD_ADDR_VAR 0 5
16148: PUSH
16149: LD_INT 3
16151: ST_TO_ADDR
16152: GO 16162
// amount := 2 ;
16154: LD_ADDR_VAR 0 5
16158: PUSH
16159: LD_INT 2
16161: ST_TO_ADDR
// for i = 1 to amount do
16162: LD_ADDR_VAR 0 1
16166: PUSH
16167: DOUBLE
16168: LD_INT 1
16170: DEC
16171: ST_TO_ADDR
16172: LD_VAR 0 5
16176: PUSH
16177: FOR_TO
16178: IFFALSE 16342
// begin wait ( 0 0$5 ) ;
16180: LD_INT 175
16182: PPUSH
16183: CALL_OW 67
// for j = 1 to 3 do
16187: LD_ADDR_VAR 0 2
16191: PUSH
16192: DOUBLE
16193: LD_INT 1
16195: DEC
16196: ST_TO_ADDR
16197: LD_INT 3
16199: PUSH
16200: FOR_TO
16201: IFFALSE 16338
// begin uc_side := 4 ;
16203: LD_ADDR_OWVAR 20
16207: PUSH
16208: LD_INT 4
16210: ST_TO_ADDR
// uc_nation := 1 ;
16211: LD_ADDR_OWVAR 21
16215: PUSH
16216: LD_INT 1
16218: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16219: LD_INT 3
16221: PUSH
16222: LD_INT 5
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PUSH
16229: LD_INT 1
16231: PPUSH
16232: LD_INT 2
16234: PPUSH
16235: CALL_OW 12
16239: ARRAY
16240: PPUSH
16241: LD_INT 3
16243: PPUSH
16244: LD_INT 3
16246: PPUSH
16247: LD_INT 9
16249: PUSH
16250: LD_INT 5
16252: PUSH
16253: LD_INT 7
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: PUSH
16261: LD_INT 1
16263: PPUSH
16264: LD_INT 3
16266: PPUSH
16267: CALL_OW 12
16271: ARRAY
16272: PPUSH
16273: LD_INT 100
16275: PPUSH
16276: CALL 24899 0 5
// veh := CreateVehicle ;
16280: LD_ADDR_VAR 0 3
16284: PUSH
16285: CALL_OW 45
16289: ST_TO_ADDR
// tmp := tmp ^ veh ;
16290: LD_ADDR_VAR 0 4
16294: PUSH
16295: LD_VAR 0 4
16299: PUSH
16300: LD_VAR 0 3
16304: ADD
16305: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16306: LD_VAR 0 3
16310: PPUSH
16311: LD_INT 22
16313: PPUSH
16314: LD_INT 0
16316: PPUSH
16317: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16321: LD_VAR 0 3
16325: PPUSH
16326: LD_INT 119
16328: PPUSH
16329: LD_INT 215
16331: PPUSH
16332: CALL_OW 111
// end ;
16336: GO 16200
16338: POP
16339: POP
// end ;
16340: GO 16177
16342: POP
16343: POP
// wait ( 0 0$3 ) ;
16344: LD_INT 105
16346: PPUSH
16347: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16351: LD_INT 35
16353: PPUSH
16354: CALL_OW 67
// for i in tmp do
16358: LD_ADDR_VAR 0 1
16362: PUSH
16363: LD_VAR 0 4
16367: PUSH
16368: FOR_IN
16369: IFFALSE 16436
// if IsDead ( i ) then
16371: LD_VAR 0 1
16375: PPUSH
16376: CALL_OW 301
16380: IFFALSE 16400
// tmp := tmp diff i else
16382: LD_ADDR_VAR 0 4
16386: PUSH
16387: LD_VAR 0 4
16391: PUSH
16392: LD_VAR 0 1
16396: DIFF
16397: ST_TO_ADDR
16398: GO 16434
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_INT 81
16407: PUSH
16408: LD_INT 4
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL_OW 69
16419: PPUSH
16420: LD_VAR 0 1
16424: PPUSH
16425: CALL_OW 74
16429: PPUSH
16430: CALL_OW 115
16434: GO 16368
16436: POP
16437: POP
// until tmp = [ ] ;
16438: LD_VAR 0 4
16442: PUSH
16443: EMPTY
16444: EQUAL
16445: IFFALSE 16351
// end ;
16447: PPOPN 5
16449: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16450: LD_EXP 2
16454: PUSH
16455: LD_INT 1
16457: EQUAL
16458: PUSH
16459: LD_EXP 3
16463: AND
16464: IFFALSE 16565
16466: GO 16468
16468: DISABLE
16469: LD_INT 0
16471: PPUSH
16472: PPUSH
// begin enable ;
16473: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16474: LD_ADDR_VAR 0 2
16478: PUSH
16479: LD_INT 3
16481: PUSH
16482: LD_INT 22
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 32
16498: PUSH
16499: LD_INT 1
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PPUSH
16510: CALL_OW 69
16514: ST_TO_ADDR
// if tmp then
16515: LD_VAR 0 2
16519: IFFALSE 16565
// for i in tmp do
16521: LD_ADDR_VAR 0 1
16525: PUSH
16526: LD_VAR 0 2
16530: PUSH
16531: FOR_IN
16532: IFFALSE 16563
// if GetFuel ( i ) < 3 then
16534: LD_VAR 0 1
16538: PPUSH
16539: CALL_OW 261
16543: PUSH
16544: LD_INT 3
16546: LESS
16547: IFFALSE 16561
// SetFuel ( i , 3 ) ;
16549: LD_VAR 0 1
16553: PPUSH
16554: LD_INT 3
16556: PPUSH
16557: CALL_OW 240
16561: GO 16531
16563: POP
16564: POP
// end ;
16565: PPOPN 2
16567: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16568: LD_EXP 3
16572: PUSH
16573: LD_INT 8
16575: PPUSH
16576: LD_INT 4
16578: PPUSH
16579: CALL_OW 81
16583: PUSH
16584: LD_INT 2
16586: EQUAL
16587: AND
16588: IFFALSE 16798
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin enable ;
16598: ENABLE
// tmp := [ ] ;
16599: LD_ADDR_VAR 0 3
16603: PUSH
16604: EMPTY
16605: ST_TO_ADDR
// for i = 1 to 4 do
16606: LD_ADDR_VAR 0 1
16610: PUSH
16611: DOUBLE
16612: LD_INT 1
16614: DEC
16615: ST_TO_ADDR
16616: LD_INT 4
16618: PUSH
16619: FOR_TO
16620: IFFALSE 16764
// begin uc_side := 8 ;
16622: LD_ADDR_OWVAR 20
16626: PUSH
16627: LD_INT 8
16629: ST_TO_ADDR
// uc_nation := nation_arabian ;
16630: LD_ADDR_OWVAR 21
16634: PUSH
16635: LD_INT 2
16637: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16638: LD_INT 11
16640: PPUSH
16641: LD_INT 1
16643: PPUSH
16644: LD_INT 5
16646: PPUSH
16647: LD_INT 24
16649: PUSH
16650: LD_INT 23
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PUSH
16657: LD_INT 1
16659: PPUSH
16660: LD_INT 2
16662: PPUSH
16663: CALL_OW 12
16667: ARRAY
16668: PPUSH
16669: LD_INT 60
16671: PPUSH
16672: LD_INT 80
16674: PPUSH
16675: CALL_OW 12
16679: PPUSH
16680: CALL 24899 0 5
// un := CreateVehicle ;
16684: LD_ADDR_VAR 0 2
16688: PUSH
16689: CALL_OW 45
16693: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16694: LD_VAR 0 2
16698: PPUSH
16699: LD_INT 2
16701: PPUSH
16702: CALL_OW 233
// tmp := tmp ^ un ;
16706: LD_ADDR_VAR 0 3
16710: PUSH
16711: LD_VAR 0 3
16715: PUSH
16716: LD_VAR 0 2
16720: ADD
16721: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16722: LD_VAR 0 2
16726: PPUSH
16727: LD_INT 88
16729: PPUSH
16730: LD_INT 2
16732: PPUSH
16733: LD_INT 0
16735: PPUSH
16736: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16740: LD_VAR 0 2
16744: PPUSH
16745: LD_INT 93
16747: PPUSH
16748: LD_INT 13
16750: PPUSH
16751: CALL_OW 111
// wait ( 0 0$2 ) ;
16755: LD_INT 70
16757: PPUSH
16758: CALL_OW 67
// end ;
16762: GO 16619
16764: POP
16765: POP
// for i in tmp do
16766: LD_ADDR_VAR 0 1
16770: PUSH
16771: LD_VAR 0 3
16775: PUSH
16776: FOR_IN
16777: IFFALSE 16796
// AddComMoveXY ( i , 136 , 19 ) ;
16779: LD_VAR 0 1
16783: PPUSH
16784: LD_INT 136
16786: PPUSH
16787: LD_INT 19
16789: PPUSH
16790: CALL_OW 171
16794: GO 16776
16796: POP
16797: POP
// end ;
16798: PPOPN 3
16800: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16801: LD_EXP 3
16805: IFFALSE 17724
16807: GO 16809
16809: DISABLE
16810: LD_INT 0
16812: PPUSH
16813: PPUSH
16814: PPUSH
16815: PPUSH
// begin enable ;
16816: ENABLE
// base := mc_leg ;
16817: LD_ADDR_VAR 0 2
16821: PUSH
16822: LD_EXP 6
16826: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16827: LD_INT 22
16829: PUSH
16830: LD_INT 8
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 23
16839: PUSH
16840: LD_INT 2
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 3
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 69
16866: NOT
16867: IFFALSE 16871
// exit ;
16869: GO 17724
// if Prob ( 40 ) then
16871: LD_INT 40
16873: PPUSH
16874: CALL_OW 13
16878: IFFALSE 17007
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16880: LD_VAR 0 2
16884: PPUSH
16885: LD_INT 13
16887: PUSH
16888: LD_INT 1
16890: PUSH
16891: LD_INT 2
16893: PUSH
16894: LD_INT 28
16896: PUSH
16897: EMPTY
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 13
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 28
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: PUSH
16921: LD_INT 13
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: LD_INT 2
16929: PUSH
16930: LD_INT 28
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 13
16941: PUSH
16942: LD_INT 1
16944: PUSH
16945: LD_INT 2
16947: PUSH
16948: LD_INT 28
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 13
16959: PUSH
16960: LD_INT 1
16962: PUSH
16963: LD_INT 2
16965: PUSH
16966: LD_INT 28
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: PUSH
16975: LD_INT 13
16977: PUSH
16978: LD_INT 1
16980: PUSH
16981: LD_INT 2
16983: PUSH
16984: LD_INT 26
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: PPUSH
17001: CALL 85581 0 2
// end else
17005: GO 17224
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17007: LD_VAR 0 2
17011: PPUSH
17012: LD_INT 13
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: LD_INT 2
17020: PUSH
17021: LD_INT 27
17023: PUSH
17024: LD_INT 26
17026: PUSH
17027: LD_INT 26
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 1
17037: PPUSH
17038: LD_INT 3
17040: PPUSH
17041: CALL_OW 12
17045: ARRAY
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: PUSH
17053: LD_INT 13
17055: PUSH
17056: LD_INT 1
17058: PUSH
17059: LD_INT 2
17061: PUSH
17062: LD_INT 27
17064: PUSH
17065: LD_INT 26
17067: PUSH
17068: LD_INT 26
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 3
17081: PPUSH
17082: CALL_OW 12
17086: ARRAY
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 13
17096: PUSH
17097: LD_INT 1
17099: PUSH
17100: LD_INT 2
17102: PUSH
17103: LD_INT 26
17105: PUSH
17106: LD_INT 26
17108: PUSH
17109: LD_INT 29
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 1
17119: PPUSH
17120: LD_INT 3
17122: PPUSH
17123: CALL_OW 12
17127: ARRAY
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 13
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: LD_INT 2
17143: PUSH
17144: LD_INT 26
17146: PUSH
17147: LD_INT 29
17149: PUSH
17150: LD_INT 29
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: LIST
17157: PUSH
17158: LD_INT 1
17160: PPUSH
17161: LD_INT 3
17163: PPUSH
17164: CALL_OW 12
17168: ARRAY
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: PUSH
17176: LD_INT 13
17178: PUSH
17179: LD_INT 1
17181: PUSH
17182: LD_INT 2
17184: PUSH
17185: LD_INT 29
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 13
17196: PUSH
17197: LD_INT 1
17199: PUSH
17200: LD_INT 2
17202: PUSH
17203: LD_INT 26
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: PPUSH
17220: CALL 85581 0 2
// end ; repeat wait ( 0 0$1 ) ;
17224: LD_INT 35
17226: PPUSH
17227: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17231: LD_VAR 0 2
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: CALL 86999 0 2
17243: PUSH
17244: LD_INT 6
17246: GREATEREQUAL
17247: PUSH
17248: LD_OWVAR 1
17252: PUSH
17253: LD_INT 21000
17255: MOD
17256: PUSH
17257: LD_INT 0
17259: EQUAL
17260: OR
17261: IFFALSE 17224
// wait ( 0 0$30 ) ;
17263: LD_INT 1050
17265: PPUSH
17266: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17270: LD_ADDR_VAR 0 3
17274: PUSH
17275: LD_VAR 0 2
17279: PPUSH
17280: LD_INT 1
17282: PPUSH
17283: CALL 86999 0 2
17287: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17288: LD_ADDR_EXP 50
17292: PUSH
17293: LD_EXP 50
17297: PPUSH
17298: LD_VAR 0 2
17302: PPUSH
17303: LD_EXP 50
17307: PUSH
17308: LD_VAR 0 2
17312: ARRAY
17313: PUSH
17314: LD_VAR 0 3
17318: DIFF
17319: PPUSH
17320: CALL_OW 1
17324: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17325: LD_ADDR_VAR 0 4
17329: PUSH
17330: LD_INT 0
17332: PPUSH
17333: LD_INT 2
17335: PPUSH
17336: CALL_OW 12
17340: ST_TO_ADDR
// if legChangeSide then
17341: LD_EXP 21
17345: IFFALSE 17355
// target := 2 ;
17347: LD_ADDR_VAR 0 4
17351: PUSH
17352: LD_INT 2
17354: ST_TO_ADDR
// if target = 2 then
17355: LD_VAR 0 4
17359: PUSH
17360: LD_INT 2
17362: EQUAL
17363: IFFALSE 17491
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_VAR 0 3
17374: PPUSH
17375: LD_INT 24
17377: PUSH
17378: LD_INT 250
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: PPUSH
17385: CALL_OW 72
17389: ST_TO_ADDR
// for i in tmp do
17390: LD_ADDR_VAR 0 1
17394: PUSH
17395: LD_VAR 0 3
17399: PUSH
17400: FOR_IN
17401: IFFALSE 17441
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17403: LD_VAR 0 1
17407: PPUSH
17408: LD_INT 112
17410: PPUSH
17411: LD_INT 64
17413: PPUSH
17414: CALL_OW 297
17418: PUSH
17419: LD_INT 9
17421: GREATER
17422: IFFALSE 17439
// ComMoveXY ( i , 112 , 64 ) ;
17424: LD_VAR 0 1
17428: PPUSH
17429: LD_INT 112
17431: PPUSH
17432: LD_INT 64
17434: PPUSH
17435: CALL_OW 111
17439: GO 17400
17441: POP
17442: POP
// wait ( 0 0$1 ) ;
17443: LD_INT 35
17445: PPUSH
17446: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17450: LD_VAR 0 3
17454: PPUSH
17455: LD_INT 92
17457: PUSH
17458: LD_INT 112
17460: PUSH
17461: LD_INT 64
17463: PUSH
17464: LD_INT 9
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: LIST
17472: PPUSH
17473: CALL_OW 72
17477: PUSH
17478: LD_VAR 0 3
17482: PUSH
17483: LD_INT 1
17485: MINUS
17486: GREATEREQUAL
17487: IFFALSE 17365
// end else
17489: GO 17615
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17491: LD_ADDR_VAR 0 3
17495: PUSH
17496: LD_VAR 0 3
17500: PPUSH
17501: LD_INT 24
17503: PUSH
17504: LD_INT 250
17506: PUSH
17507: EMPTY
17508: LIST
17509: LIST
17510: PPUSH
17511: CALL_OW 72
17515: ST_TO_ADDR
// for i in tmp do
17516: LD_ADDR_VAR 0 1
17520: PUSH
17521: LD_VAR 0 3
17525: PUSH
17526: FOR_IN
17527: IFFALSE 17567
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17529: LD_VAR 0 1
17533: PPUSH
17534: LD_INT 174
17536: PPUSH
17537: LD_INT 94
17539: PPUSH
17540: CALL_OW 297
17544: PUSH
17545: LD_INT 9
17547: GREATER
17548: IFFALSE 17565
// ComMoveXY ( i , 174 , 94 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 174
17557: PPUSH
17558: LD_INT 94
17560: PPUSH
17561: CALL_OW 111
17565: GO 17526
17567: POP
17568: POP
// wait ( 0 0$1 ) ;
17569: LD_INT 35
17571: PPUSH
17572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17576: LD_VAR 0 3
17580: PPUSH
17581: LD_INT 92
17583: PUSH
17584: LD_INT 174
17586: PUSH
17587: LD_INT 94
17589: PUSH
17590: LD_INT 9
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: PPUSH
17599: CALL_OW 72
17603: PUSH
17604: LD_VAR 0 3
17608: PUSH
17609: LD_INT 1
17611: MINUS
17612: GREATEREQUAL
17613: IFFALSE 17491
// end ; repeat wait ( 0 0$1 ) ;
17615: LD_INT 35
17617: PPUSH
17618: CALL_OW 67
// for i in tmp do
17622: LD_ADDR_VAR 0 1
17626: PUSH
17627: LD_VAR 0 3
17631: PUSH
17632: FOR_IN
17633: IFFALSE 17715
// begin if GetLives ( i ) > 251 then
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL_OW 256
17644: PUSH
17645: LD_INT 251
17647: GREATER
17648: IFFALSE 17686
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17650: LD_VAR 0 1
17654: PPUSH
17655: LD_INT 81
17657: PUSH
17658: LD_INT 8
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: PPUSH
17665: CALL_OW 69
17669: PPUSH
17670: LD_VAR 0 1
17674: PPUSH
17675: CALL_OW 74
17679: PPUSH
17680: CALL_OW 115
17684: GO 17713
// if IsDead ( i ) then
17686: LD_VAR 0 1
17690: PPUSH
17691: CALL_OW 301
17695: IFFALSE 17713
// tmp := tmp diff i ;
17697: LD_ADDR_VAR 0 3
17701: PUSH
17702: LD_VAR 0 3
17706: PUSH
17707: LD_VAR 0 1
17711: DIFF
17712: ST_TO_ADDR
// end ;
17713: GO 17632
17715: POP
17716: POP
// until not tmp ;
17717: LD_VAR 0 3
17721: NOT
17722: IFFALSE 17615
// end ;
17724: PPOPN 4
17726: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17727: LD_EXP 3
17731: IFFALSE 18719
17733: GO 17735
17735: DISABLE
17736: LD_INT 0
17738: PPUSH
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
// begin enable ;
17743: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17744: LD_EXP 31
17748: PUSH
17749: LD_EXP 8
17753: ARRAY
17754: PPUSH
17755: LD_INT 22
17757: PUSH
17758: LD_INT 3
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 3
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: PPUSH
17779: CALL_OW 72
17783: NOT
17784: IFFALSE 17788
// exit ;
17786: GO 18719
// base := mc_rus_2 ;
17788: LD_ADDR_VAR 0 2
17792: PUSH
17793: LD_EXP 8
17797: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17798: LD_ADDR_VAR 0 5
17802: PUSH
17803: LD_INT 22
17805: PUSH
17806: LD_INT 3
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: PUSH
17813: LD_INT 30
17815: PUSH
17816: LD_INT 34
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: PPUSH
17827: CALL_OW 69
17831: ST_TO_ADDR
// if Prob ( 40 ) then
17832: LD_INT 40
17834: PPUSH
17835: CALL_OW 13
17839: IFFALSE 17968
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17841: LD_VAR 0 2
17845: PPUSH
17846: LD_INT 22
17848: PUSH
17849: LD_INT 3
17851: PUSH
17852: LD_INT 3
17854: PUSH
17855: LD_INT 49
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: PUSH
17864: LD_INT 22
17866: PUSH
17867: LD_INT 3
17869: PUSH
17870: LD_INT 3
17872: PUSH
17873: LD_INT 49
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: PUSH
17882: LD_INT 22
17884: PUSH
17885: LD_INT 3
17887: PUSH
17888: LD_INT 3
17890: PUSH
17891: LD_INT 49
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 24
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: LD_INT 46
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: LIST
17916: LIST
17917: PUSH
17918: LD_INT 24
17920: PUSH
17921: LD_INT 3
17923: PUSH
17924: LD_INT 3
17926: PUSH
17927: LD_INT 46
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: LIST
17934: LIST
17935: PUSH
17936: LD_INT 24
17938: PUSH
17939: LD_INT 3
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 46
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: PPUSH
17962: CALL 85581 0 2
// end else
17966: GO 18093
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17968: LD_VAR 0 2
17972: PPUSH
17973: LD_INT 24
17975: PUSH
17976: LD_INT 3
17978: PUSH
17979: LD_INT 3
17981: PUSH
17982: LD_INT 47
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: PUSH
17991: LD_INT 24
17993: PUSH
17994: LD_INT 3
17996: PUSH
17997: LD_INT 3
17999: PUSH
18000: LD_INT 47
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 24
18011: PUSH
18012: LD_INT 3
18014: PUSH
18015: LD_INT 3
18017: PUSH
18018: LD_INT 47
18020: PUSH
18021: EMPTY
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 24
18029: PUSH
18030: LD_INT 3
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: LD_INT 46
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 24
18047: PUSH
18048: LD_INT 3
18050: PUSH
18051: LD_INT 3
18053: PUSH
18054: LD_INT 46
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: PUSH
18063: LD_INT 24
18065: PUSH
18066: LD_INT 3
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 46
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: PPUSH
18089: CALL 85581 0 2
// end ; if Difficulty > 1 then
18093: LD_OWVAR 67
18097: PUSH
18098: LD_INT 1
18100: GREATER
18101: IFFALSE 18133
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18103: LD_VAR 0 2
18107: PPUSH
18108: LD_INT 24
18110: PUSH
18111: LD_INT 3
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 47
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: PPUSH
18129: CALL 85581 0 2
// repeat wait ( 0 0$1 ) ;
18133: LD_INT 35
18135: PPUSH
18136: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18140: LD_VAR 0 2
18144: PPUSH
18145: LD_INT 1
18147: PPUSH
18148: CALL 86999 0 2
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 7
18158: PUSH
18159: LD_INT 7
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: PUSH
18167: LD_OWVAR 67
18171: ARRAY
18172: GREATEREQUAL
18173: PUSH
18174: LD_OWVAR 1
18178: PUSH
18179: LD_INT 21000
18181: MOD
18182: PUSH
18183: LD_INT 0
18185: EQUAL
18186: OR
18187: IFFALSE 18133
// wait ( 0 0$45 ) ;
18189: LD_INT 1575
18191: PPUSH
18192: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_VAR 0 2
18205: PPUSH
18206: LD_INT 1
18208: PPUSH
18209: CALL 86999 0 2
18213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18214: LD_ADDR_EXP 50
18218: PUSH
18219: LD_EXP 50
18223: PPUSH
18224: LD_VAR 0 2
18228: PPUSH
18229: LD_EXP 50
18233: PUSH
18234: LD_VAR 0 2
18238: ARRAY
18239: PUSH
18240: LD_VAR 0 3
18244: DIFF
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18251: LD_ADDR_VAR 0 4
18255: PUSH
18256: LD_INT 0
18258: PPUSH
18259: LD_INT 1
18261: PPUSH
18262: CALL_OW 12
18266: ST_TO_ADDR
// if target then
18267: LD_VAR 0 4
18271: IFFALSE 18399
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18273: LD_ADDR_VAR 0 3
18277: PUSH
18278: LD_VAR 0 3
18282: PPUSH
18283: LD_INT 24
18285: PUSH
18286: LD_INT 250
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 72
18297: ST_TO_ADDR
// for i in tmp do
18298: LD_ADDR_VAR 0 1
18302: PUSH
18303: LD_VAR 0 3
18307: PUSH
18308: FOR_IN
18309: IFFALSE 18349
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18311: LD_VAR 0 1
18315: PPUSH
18316: LD_INT 84
18318: PPUSH
18319: LD_INT 32
18321: PPUSH
18322: CALL_OW 297
18326: PUSH
18327: LD_INT 9
18329: GREATER
18330: IFFALSE 18347
// ComMoveXY ( i , 84 , 32 ) ;
18332: LD_VAR 0 1
18336: PPUSH
18337: LD_INT 84
18339: PPUSH
18340: LD_INT 32
18342: PPUSH
18343: CALL_OW 111
18347: GO 18308
18349: POP
18350: POP
// wait ( 0 0$1 ) ;
18351: LD_INT 35
18353: PPUSH
18354: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18358: LD_VAR 0 3
18362: PPUSH
18363: LD_INT 92
18365: PUSH
18366: LD_INT 84
18368: PUSH
18369: LD_INT 32
18371: PUSH
18372: LD_INT 9
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: PPUSH
18381: CALL_OW 72
18385: PUSH
18386: LD_VAR 0 3
18390: PUSH
18391: LD_INT 1
18393: MINUS
18394: GREATEREQUAL
18395: IFFALSE 18273
// end else
18397: GO 18559
// begin if teleport then
18399: LD_VAR 0 5
18403: IFFALSE 18423
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18405: LD_VAR 0 3
18409: PPUSH
18410: LD_VAR 0 5
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18423: LD_ADDR_VAR 0 3
18427: PUSH
18428: LD_VAR 0 3
18432: PPUSH
18433: LD_INT 24
18435: PUSH
18436: LD_INT 250
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: PPUSH
18443: CALL_OW 72
18447: ST_TO_ADDR
// for i in tmp do
18448: LD_ADDR_VAR 0 1
18452: PUSH
18453: LD_VAR 0 3
18457: PUSH
18458: FOR_IN
18459: IFFALSE 18511
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 140
18468: PPUSH
18469: LD_INT 219
18471: PPUSH
18472: CALL_OW 297
18476: PUSH
18477: LD_INT 9
18479: GREATER
18480: PUSH
18481: LD_VAR 0 1
18485: PPUSH
18486: CALL_OW 314
18490: NOT
18491: AND
18492: IFFALSE 18509
// AddComMoveXY ( i , 140 , 219 ) ;
18494: LD_VAR 0 1
18498: PPUSH
18499: LD_INT 140
18501: PPUSH
18502: LD_INT 219
18504: PPUSH
18505: CALL_OW 171
18509: GO 18458
18511: POP
18512: POP
// wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_INT 92
18527: PUSH
18528: LD_INT 140
18530: PUSH
18531: LD_INT 219
18533: PUSH
18534: LD_INT 9
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 72
18547: PUSH
18548: LD_VAR 0 3
18552: PUSH
18553: LD_INT 1
18555: MINUS
18556: GREATEREQUAL
18557: IFFALSE 18423
// end ; repeat wait ( 0 0$1 ) ;
18559: LD_INT 35
18561: PPUSH
18562: CALL_OW 67
// for i in tmp do
18566: LD_ADDR_VAR 0 1
18570: PUSH
18571: LD_VAR 0 3
18575: PUSH
18576: FOR_IN
18577: IFFALSE 18710
// begin if GetLives ( i ) > 251 then
18579: LD_VAR 0 1
18583: PPUSH
18584: CALL_OW 256
18588: PUSH
18589: LD_INT 251
18591: GREATER
18592: IFFALSE 18681
// begin if GetWeapon ( i ) = ru_time_lapser then
18594: LD_VAR 0 1
18598: PPUSH
18599: CALL_OW 264
18603: PUSH
18604: LD_INT 49
18606: EQUAL
18607: IFFALSE 18645
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18609: LD_VAR 0 1
18613: PPUSH
18614: LD_INT 81
18616: PUSH
18617: LD_INT 3
18619: PUSH
18620: EMPTY
18621: LIST
18622: LIST
18623: PPUSH
18624: CALL_OW 69
18628: PPUSH
18629: LD_VAR 0 1
18633: PPUSH
18634: CALL_OW 74
18638: PPUSH
18639: CALL_OW 112
18643: GO 18679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18645: LD_VAR 0 1
18649: PPUSH
18650: LD_INT 81
18652: PUSH
18653: LD_INT 3
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL_OW 69
18664: PPUSH
18665: LD_VAR 0 1
18669: PPUSH
18670: CALL_OW 74
18674: PPUSH
18675: CALL_OW 115
// end else
18679: GO 18708
// if IsDead ( i ) then
18681: LD_VAR 0 1
18685: PPUSH
18686: CALL_OW 301
18690: IFFALSE 18708
// tmp := tmp diff i ;
18692: LD_ADDR_VAR 0 3
18696: PUSH
18697: LD_VAR 0 3
18701: PUSH
18702: LD_VAR 0 1
18706: DIFF
18707: ST_TO_ADDR
// end ;
18708: GO 18576
18710: POP
18711: POP
// until not tmp ;
18712: LD_VAR 0 3
18716: NOT
18717: IFFALSE 18559
// end ;
18719: PPOPN 5
18721: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18722: LD_EXP 3
18726: IFFALSE 19108
18728: GO 18730
18730: DISABLE
18731: LD_INT 0
18733: PPUSH
18734: PPUSH
18735: PPUSH
18736: PPUSH
// begin enable ;
18737: ENABLE
// base := mc_amer ;
18738: LD_ADDR_VAR 0 2
18742: PUSH
18743: LD_EXP 5
18747: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18748: LD_INT 22
18750: PUSH
18751: LD_INT 4
18753: PUSH
18754: EMPTY
18755: LIST
18756: LIST
18757: PUSH
18758: LD_INT 23
18760: PUSH
18761: LD_INT 1
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 3
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL_OW 69
18787: NOT
18788: IFFALSE 18792
// exit ;
18790: GO 19108
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18792: LD_VAR 0 2
18796: PPUSH
18797: LD_INT 3
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 5
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 3
18817: PUSH
18818: LD_INT 1
18820: PUSH
18821: LD_INT 2
18823: PUSH
18824: LD_INT 9
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: LIST
18831: LIST
18832: PUSH
18833: LD_INT 3
18835: PUSH
18836: LD_INT 1
18838: PUSH
18839: LD_INT 2
18841: PUSH
18842: LD_INT 7
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: PUSH
18851: LD_INT 3
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: LD_INT 2
18859: PUSH
18860: LD_INT 7
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: LD_INT 1
18874: PUSH
18875: LD_INT 2
18877: PUSH
18878: LD_INT 7
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: PPUSH
18894: CALL 85581 0 2
// repeat wait ( 0 0$1 ) ;
18898: LD_INT 35
18900: PPUSH
18901: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18905: LD_VAR 0 2
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 86999 0 2
18917: PUSH
18918: LD_INT 5
18920: GREATEREQUAL
18921: PUSH
18922: LD_OWVAR 1
18926: PUSH
18927: LD_INT 21000
18929: MOD
18930: PUSH
18931: LD_INT 0
18933: EQUAL
18934: OR
18935: IFFALSE 18898
// wait ( 0 0$30 ) ;
18937: LD_INT 1050
18939: PPUSH
18940: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_VAR 0 2
18953: PPUSH
18954: LD_INT 1
18956: PPUSH
18957: CALL 86999 0 2
18961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18962: LD_ADDR_EXP 50
18966: PUSH
18967: LD_EXP 50
18971: PPUSH
18972: LD_VAR 0 2
18976: PPUSH
18977: LD_EXP 50
18981: PUSH
18982: LD_VAR 0 2
18986: ARRAY
18987: PUSH
18988: LD_VAR 0 3
18992: DIFF
18993: PPUSH
18994: CALL_OW 1
18998: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18999: LD_INT 35
19001: PPUSH
19002: CALL_OW 67
// for i in tmp do
19006: LD_ADDR_VAR 0 1
19010: PUSH
19011: LD_VAR 0 3
19015: PUSH
19016: FOR_IN
19017: IFFALSE 19099
// begin if GetLives ( i ) > 251 then
19019: LD_VAR 0 1
19023: PPUSH
19024: CALL_OW 256
19028: PUSH
19029: LD_INT 251
19031: GREATER
19032: IFFALSE 19070
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19034: LD_VAR 0 1
19038: PPUSH
19039: LD_INT 81
19041: PUSH
19042: LD_INT 4
19044: PUSH
19045: EMPTY
19046: LIST
19047: LIST
19048: PPUSH
19049: CALL_OW 69
19053: PPUSH
19054: LD_VAR 0 1
19058: PPUSH
19059: CALL_OW 74
19063: PPUSH
19064: CALL_OW 115
19068: GO 19097
// if IsDead ( i ) then
19070: LD_VAR 0 1
19074: PPUSH
19075: CALL_OW 301
19079: IFFALSE 19097
// tmp := tmp diff i ;
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_VAR 0 3
19090: PUSH
19091: LD_VAR 0 1
19095: DIFF
19096: ST_TO_ADDR
// end ;
19097: GO 19016
19099: POP
19100: POP
// until not tmp ;
19101: LD_VAR 0 3
19105: NOT
19106: IFFALSE 18999
// end ; end_of_file
19108: PPOPN 4
19110: END
// export function CustomEvent ( event ) ; begin
19111: LD_INT 0
19113: PPUSH
// end ;
19114: LD_VAR 0 2
19118: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19119: LD_VAR 0 1
19123: PUSH
19124: LD_INT 1
19126: EQUAL
19127: PUSH
19128: LD_VAR 0 2
19132: PUSH
19133: LD_INT 4
19135: EQUAL
19136: AND
19137: IFFALSE 19165
// begin SayRadio ( Powell , DP-Lost ) ;
19139: LD_EXP 12
19143: PPUSH
19144: LD_STRING DP-Lost
19146: PPUSH
19147: CALL_OW 94
// wait ( 0 0$2 ) ;
19151: LD_INT 70
19153: PPUSH
19154: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19158: LD_STRING FriendlyFire
19160: PPUSH
19161: CALL_OW 104
// end ; end ;
19165: PPOPN 2
19167: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19168: LD_VAR 0 1
19172: PPUSH
19173: CALL 107768 0 1
// if GameType = 1 then
19177: LD_EXP 2
19181: PUSH
19182: LD_INT 1
19184: EQUAL
19185: IFFALSE 19420
// begin if un = playerCommander then
19187: LD_VAR 0 1
19191: PUSH
19192: LD_EXP 9
19196: EQUAL
19197: IFFALSE 19206
// YouLost ( commanderDied ) ;
19199: LD_STRING commanderDied
19201: PPUSH
19202: CALL_OW 104
// if un = allyCommander then
19206: LD_VAR 0 1
19210: PUSH
19211: LD_EXP 11
19215: EQUAL
19216: IFFALSE 19225
// YouLost ( Theta ) ;
19218: LD_STRING Theta
19220: PPUSH
19221: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19225: LD_VAR 0 1
19229: PUSH
19230: LD_INT 22
19232: PUSH
19233: LD_INT 8
19235: PUSH
19236: EMPTY
19237: LIST
19238: LIST
19239: PUSH
19240: LD_INT 2
19242: PUSH
19243: LD_INT 21
19245: PUSH
19246: LD_INT 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 69
19276: IN
19277: IFFALSE 19293
// legDestCounter := legDestCounter + 1 ;
19279: LD_ADDR_EXP 18
19283: PUSH
19284: LD_EXP 18
19288: PUSH
19289: LD_INT 1
19291: PLUS
19292: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19293: LD_VAR 0 1
19297: PUSH
19298: LD_INT 22
19300: PUSH
19301: LD_INT 4
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: PUSH
19308: LD_INT 2
19310: PUSH
19311: LD_INT 21
19313: PUSH
19314: LD_INT 1
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PUSH
19321: LD_INT 21
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PPUSH
19340: CALL_OW 69
19344: IN
19345: IFFALSE 19361
// allyDestCounter := allyDestCounter + 1 ;
19347: LD_ADDR_EXP 22
19351: PUSH
19352: LD_EXP 22
19356: PUSH
19357: LD_INT 1
19359: PLUS
19360: ST_TO_ADDR
// if un in ruOutpost then
19361: LD_VAR 0 1
19365: PUSH
19366: LD_EXP 14
19370: IN
19371: IFFALSE 19420
// begin ruOutpost := ruOutpost diff un ;
19373: LD_ADDR_EXP 14
19377: PUSH
19378: LD_EXP 14
19382: PUSH
19383: LD_VAR 0 1
19387: DIFF
19388: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19389: LD_ADDR_EXP 15
19393: PUSH
19394: LD_EXP 15
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: LD_EXP 15
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_INT 1
19413: PLUS
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19420: LD_VAR 0 1
19424: PPUSH
19425: CALL 88985 0 1
// end ;
19429: PPOPN 1
19431: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: LD_VAR 0 2
19441: PPUSH
19442: CALL 91317 0 2
// end ;
19446: PPOPN 2
19448: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19449: LD_VAR 0 1
19453: PPUSH
19454: CALL 90385 0 1
// end ;
19458: PPOPN 1
19460: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19461: LD_VAR 0 1
19465: PPUSH
19466: CALL 90626 0 1
// end ;
19470: PPOPN 1
19472: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19473: LD_VAR 0 1
19477: PUSH
19478: LD_INT 14
19480: EQUAL
19481: PUSH
19482: LD_VAR 0 2
19486: PPUSH
19487: CALL_OW 255
19491: PUSH
19492: LD_INT 1
19494: EQUAL
19495: AND
19496: IFFALSE 19537
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19498: LD_EXP 9
19502: PPUSH
19503: LD_STRING D
19505: PUSH
19506: LD_STRING I
19508: PUSH
19509: LD_STRING J
19511: PUSH
19512: LD_STRING S
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: LIST
19519: PUSH
19520: LD_EXP 25
19524: ARRAY
19525: STR
19526: PUSH
19527: LD_STRING -1-Laser
19529: STR
19530: PPUSH
19531: CALL_OW 88
// exit ;
19535: GO 19679
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19537: LD_VAR 0 1
19541: PUSH
19542: LD_INT 7
19544: EQUAL
19545: PUSH
19546: LD_VAR 0 2
19550: PPUSH
19551: CALL_OW 255
19555: PUSH
19556: LD_INT 1
19558: EQUAL
19559: AND
19560: IFFALSE 19601
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19562: LD_EXP 9
19566: PPUSH
19567: LD_STRING D
19569: PUSH
19570: LD_STRING I
19572: PUSH
19573: LD_STRING J
19575: PUSH
19576: LD_STRING S
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_EXP 25
19588: ARRAY
19589: STR
19590: PUSH
19591: LD_STRING -1-Materialization
19593: STR
19594: PPUSH
19595: CALL_OW 88
// exit ;
19599: GO 19679
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19601: LD_VAR 0 1
19605: PUSH
19606: LD_INT 25
19608: EQUAL
19609: PUSH
19610: LD_VAR 0 2
19614: PPUSH
19615: CALL_OW 255
19619: PUSH
19620: LD_INT 1
19622: EQUAL
19623: AND
19624: IFFALSE 19665
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19626: LD_EXP 9
19630: PPUSH
19631: LD_STRING D
19633: PUSH
19634: LD_STRING I
19636: PUSH
19637: LD_STRING J
19639: PUSH
19640: LD_STRING S
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: LIST
19647: PUSH
19648: LD_EXP 25
19652: ARRAY
19653: STR
19654: PUSH
19655: LD_STRING -1-Rocket
19657: STR
19658: PPUSH
19659: CALL_OW 88
// exit ;
19663: GO 19679
// end ; MCE_ResearchComplete ( tech , lab ) ;
19665: LD_VAR 0 1
19669: PPUSH
19670: LD_VAR 0 2
19674: PPUSH
19675: CALL 88681 0 2
// end ;
19679: PPOPN 2
19681: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19682: LD_VAR 0 1
19686: PPUSH
19687: LD_VAR 0 2
19691: PPUSH
19692: LD_VAR 0 3
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: LD_VAR 0 5
19706: PPUSH
19707: CALL 88301 0 5
// end ;
19711: PPOPN 5
19713: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19714: LD_VAR 0 1
19718: PPUSH
19719: LD_VAR 0 2
19723: PPUSH
19724: CALL 107888 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19728: LD_VAR 0 1
19732: PPUSH
19733: LD_VAR 0 2
19737: PPUSH
19738: CALL 87892 0 2
// end ;
19742: PPOPN 2
19744: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19745: LD_VAR 0 1
19749: PPUSH
19750: LD_VAR 0 2
19754: PPUSH
19755: LD_VAR 0 3
19759: PPUSH
19760: LD_VAR 0 4
19764: PPUSH
19765: CALL 87730 0 4
// end ;
19769: PPOPN 4
19771: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19772: LD_VAR 0 1
19776: PPUSH
19777: LD_VAR 0 2
19781: PPUSH
19782: LD_VAR 0 3
19786: PPUSH
19787: CALL 87505 0 3
// end ;
19791: PPOPN 3
19793: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19794: LD_VAR 0 1
19798: PPUSH
19799: LD_VAR 0 2
19803: PPUSH
19804: CALL 87390 0 2
// end ;
19808: PPOPN 2
19810: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19811: LD_VAR 0 1
19815: PPUSH
19816: LD_VAR 0 2
19820: PPUSH
19821: CALL 91612 0 2
// end ;
19825: PPOPN 2
19827: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19828: LD_VAR 0 1
19832: PPUSH
19833: LD_VAR 0 2
19837: PPUSH
19838: LD_VAR 0 3
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: CALL 91828 0 4
// end ;
19852: PPOPN 4
19854: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19855: LD_VAR 0 1
19859: PPUSH
19860: LD_VAR 0 2
19864: PPUSH
19865: CALL 87199 0 2
// end ;
19869: PPOPN 2
19871: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19872: LD_VAR 0 1
19876: PPUSH
19877: CALL 107872 0 1
// end ; end_of_file
19881: PPOPN 1
19883: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19884: LD_INT 0
19886: PPUSH
19887: PPUSH
// if exist_mode then
19888: LD_VAR 0 2
19892: IFFALSE 19917
// unit := CreateCharacter ( prefix & ident ) else
19894: LD_ADDR_VAR 0 5
19898: PUSH
19899: LD_VAR 0 3
19903: PUSH
19904: LD_VAR 0 1
19908: STR
19909: PPUSH
19910: CALL_OW 34
19914: ST_TO_ADDR
19915: GO 19932
// unit := NewCharacter ( ident ) ;
19917: LD_ADDR_VAR 0 5
19921: PUSH
19922: LD_VAR 0 1
19926: PPUSH
19927: CALL_OW 25
19931: ST_TO_ADDR
// result := unit ;
19932: LD_ADDR_VAR 0 4
19936: PUSH
19937: LD_VAR 0 5
19941: ST_TO_ADDR
// end ;
19942: LD_VAR 0 4
19946: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19947: LD_INT 0
19949: PPUSH
19950: PPUSH
// if not side or not nation then
19951: LD_VAR 0 1
19955: NOT
19956: PUSH
19957: LD_VAR 0 2
19961: NOT
19962: OR
19963: IFFALSE 19967
// exit ;
19965: GO 20735
// case nation of nation_american :
19967: LD_VAR 0 2
19971: PUSH
19972: LD_INT 1
19974: DOUBLE
19975: EQUAL
19976: IFTRUE 19980
19978: GO 20194
19980: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19981: LD_ADDR_VAR 0 4
19985: PUSH
19986: LD_INT 35
19988: PUSH
19989: LD_INT 45
19991: PUSH
19992: LD_INT 46
19994: PUSH
19995: LD_INT 47
19997: PUSH
19998: LD_INT 82
20000: PUSH
20001: LD_INT 83
20003: PUSH
20004: LD_INT 84
20006: PUSH
20007: LD_INT 85
20009: PUSH
20010: LD_INT 86
20012: PUSH
20013: LD_INT 1
20015: PUSH
20016: LD_INT 2
20018: PUSH
20019: LD_INT 6
20021: PUSH
20022: LD_INT 15
20024: PUSH
20025: LD_INT 16
20027: PUSH
20028: LD_INT 7
20030: PUSH
20031: LD_INT 12
20033: PUSH
20034: LD_INT 13
20036: PUSH
20037: LD_INT 10
20039: PUSH
20040: LD_INT 14
20042: PUSH
20043: LD_INT 20
20045: PUSH
20046: LD_INT 21
20048: PUSH
20049: LD_INT 22
20051: PUSH
20052: LD_INT 25
20054: PUSH
20055: LD_INT 32
20057: PUSH
20058: LD_INT 27
20060: PUSH
20061: LD_INT 36
20063: PUSH
20064: LD_INT 69
20066: PUSH
20067: LD_INT 39
20069: PUSH
20070: LD_INT 34
20072: PUSH
20073: LD_INT 40
20075: PUSH
20076: LD_INT 48
20078: PUSH
20079: LD_INT 49
20081: PUSH
20082: LD_INT 50
20084: PUSH
20085: LD_INT 51
20087: PUSH
20088: LD_INT 52
20090: PUSH
20091: LD_INT 53
20093: PUSH
20094: LD_INT 54
20096: PUSH
20097: LD_INT 55
20099: PUSH
20100: LD_INT 56
20102: PUSH
20103: LD_INT 57
20105: PUSH
20106: LD_INT 58
20108: PUSH
20109: LD_INT 59
20111: PUSH
20112: LD_INT 60
20114: PUSH
20115: LD_INT 61
20117: PUSH
20118: LD_INT 62
20120: PUSH
20121: LD_INT 80
20123: PUSH
20124: LD_INT 82
20126: PUSH
20127: LD_INT 83
20129: PUSH
20130: LD_INT 84
20132: PUSH
20133: LD_INT 85
20135: PUSH
20136: LD_INT 86
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: ST_TO_ADDR
20192: GO 20659
20194: LD_INT 2
20196: DOUBLE
20197: EQUAL
20198: IFTRUE 20202
20200: GO 20428
20202: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20203: LD_ADDR_VAR 0 4
20207: PUSH
20208: LD_INT 35
20210: PUSH
20211: LD_INT 45
20213: PUSH
20214: LD_INT 46
20216: PUSH
20217: LD_INT 47
20219: PUSH
20220: LD_INT 82
20222: PUSH
20223: LD_INT 83
20225: PUSH
20226: LD_INT 84
20228: PUSH
20229: LD_INT 85
20231: PUSH
20232: LD_INT 87
20234: PUSH
20235: LD_INT 70
20237: PUSH
20238: LD_INT 1
20240: PUSH
20241: LD_INT 11
20243: PUSH
20244: LD_INT 3
20246: PUSH
20247: LD_INT 4
20249: PUSH
20250: LD_INT 5
20252: PUSH
20253: LD_INT 6
20255: PUSH
20256: LD_INT 15
20258: PUSH
20259: LD_INT 18
20261: PUSH
20262: LD_INT 7
20264: PUSH
20265: LD_INT 17
20267: PUSH
20268: LD_INT 8
20270: PUSH
20271: LD_INT 20
20273: PUSH
20274: LD_INT 21
20276: PUSH
20277: LD_INT 22
20279: PUSH
20280: LD_INT 72
20282: PUSH
20283: LD_INT 26
20285: PUSH
20286: LD_INT 69
20288: PUSH
20289: LD_INT 39
20291: PUSH
20292: LD_INT 40
20294: PUSH
20295: LD_INT 41
20297: PUSH
20298: LD_INT 42
20300: PUSH
20301: LD_INT 43
20303: PUSH
20304: LD_INT 48
20306: PUSH
20307: LD_INT 49
20309: PUSH
20310: LD_INT 50
20312: PUSH
20313: LD_INT 51
20315: PUSH
20316: LD_INT 52
20318: PUSH
20319: LD_INT 53
20321: PUSH
20322: LD_INT 54
20324: PUSH
20325: LD_INT 55
20327: PUSH
20328: LD_INT 56
20330: PUSH
20331: LD_INT 60
20333: PUSH
20334: LD_INT 61
20336: PUSH
20337: LD_INT 62
20339: PUSH
20340: LD_INT 66
20342: PUSH
20343: LD_INT 67
20345: PUSH
20346: LD_INT 68
20348: PUSH
20349: LD_INT 81
20351: PUSH
20352: LD_INT 82
20354: PUSH
20355: LD_INT 83
20357: PUSH
20358: LD_INT 84
20360: PUSH
20361: LD_INT 85
20363: PUSH
20364: LD_INT 87
20366: PUSH
20367: LD_INT 88
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: ST_TO_ADDR
20426: GO 20659
20428: LD_INT 3
20430: DOUBLE
20431: EQUAL
20432: IFTRUE 20436
20434: GO 20658
20436: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20437: LD_ADDR_VAR 0 4
20441: PUSH
20442: LD_INT 46
20444: PUSH
20445: LD_INT 47
20447: PUSH
20448: LD_INT 1
20450: PUSH
20451: LD_INT 2
20453: PUSH
20454: LD_INT 82
20456: PUSH
20457: LD_INT 83
20459: PUSH
20460: LD_INT 84
20462: PUSH
20463: LD_INT 85
20465: PUSH
20466: LD_INT 86
20468: PUSH
20469: LD_INT 11
20471: PUSH
20472: LD_INT 9
20474: PUSH
20475: LD_INT 20
20477: PUSH
20478: LD_INT 19
20480: PUSH
20481: LD_INT 21
20483: PUSH
20484: LD_INT 24
20486: PUSH
20487: LD_INT 22
20489: PUSH
20490: LD_INT 25
20492: PUSH
20493: LD_INT 28
20495: PUSH
20496: LD_INT 29
20498: PUSH
20499: LD_INT 30
20501: PUSH
20502: LD_INT 31
20504: PUSH
20505: LD_INT 37
20507: PUSH
20508: LD_INT 38
20510: PUSH
20511: LD_INT 32
20513: PUSH
20514: LD_INT 27
20516: PUSH
20517: LD_INT 33
20519: PUSH
20520: LD_INT 69
20522: PUSH
20523: LD_INT 39
20525: PUSH
20526: LD_INT 34
20528: PUSH
20529: LD_INT 40
20531: PUSH
20532: LD_INT 71
20534: PUSH
20535: LD_INT 23
20537: PUSH
20538: LD_INT 44
20540: PUSH
20541: LD_INT 48
20543: PUSH
20544: LD_INT 49
20546: PUSH
20547: LD_INT 50
20549: PUSH
20550: LD_INT 51
20552: PUSH
20553: LD_INT 52
20555: PUSH
20556: LD_INT 53
20558: PUSH
20559: LD_INT 54
20561: PUSH
20562: LD_INT 55
20564: PUSH
20565: LD_INT 56
20567: PUSH
20568: LD_INT 57
20570: PUSH
20571: LD_INT 58
20573: PUSH
20574: LD_INT 59
20576: PUSH
20577: LD_INT 63
20579: PUSH
20580: LD_INT 64
20582: PUSH
20583: LD_INT 65
20585: PUSH
20586: LD_INT 82
20588: PUSH
20589: LD_INT 83
20591: PUSH
20592: LD_INT 84
20594: PUSH
20595: LD_INT 85
20597: PUSH
20598: LD_INT 86
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: ST_TO_ADDR
20656: GO 20659
20658: POP
// if state > - 1 and state < 3 then
20659: LD_VAR 0 3
20663: PUSH
20664: LD_INT 1
20666: NEG
20667: GREATER
20668: PUSH
20669: LD_VAR 0 3
20673: PUSH
20674: LD_INT 3
20676: LESS
20677: AND
20678: IFFALSE 20735
// for i in result do
20680: LD_ADDR_VAR 0 5
20684: PUSH
20685: LD_VAR 0 4
20689: PUSH
20690: FOR_IN
20691: IFFALSE 20733
// if GetTech ( i , side ) <> state then
20693: LD_VAR 0 5
20697: PPUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: CALL_OW 321
20707: PUSH
20708: LD_VAR 0 3
20712: NONEQUAL
20713: IFFALSE 20731
// result := result diff i ;
20715: LD_ADDR_VAR 0 4
20719: PUSH
20720: LD_VAR 0 4
20724: PUSH
20725: LD_VAR 0 5
20729: DIFF
20730: ST_TO_ADDR
20731: GO 20690
20733: POP
20734: POP
// end ;
20735: LD_VAR 0 4
20739: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20740: LD_INT 0
20742: PPUSH
20743: PPUSH
20744: PPUSH
// result := true ;
20745: LD_ADDR_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20753: LD_ADDR_VAR 0 5
20757: PUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: CALL_OW 480
20767: ST_TO_ADDR
// if not tmp then
20768: LD_VAR 0 5
20772: NOT
20773: IFFALSE 20777
// exit ;
20775: GO 20826
// for i in tmp do
20777: LD_ADDR_VAR 0 4
20781: PUSH
20782: LD_VAR 0 5
20786: PUSH
20787: FOR_IN
20788: IFFALSE 20824
// if GetTech ( i , side ) <> state_researched then
20790: LD_VAR 0 4
20794: PPUSH
20795: LD_VAR 0 1
20799: PPUSH
20800: CALL_OW 321
20804: PUSH
20805: LD_INT 2
20807: NONEQUAL
20808: IFFALSE 20822
// begin result := false ;
20810: LD_ADDR_VAR 0 3
20814: PUSH
20815: LD_INT 0
20817: ST_TO_ADDR
// exit ;
20818: POP
20819: POP
20820: GO 20826
// end ;
20822: GO 20787
20824: POP
20825: POP
// end ;
20826: LD_VAR 0 3
20830: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20831: LD_INT 0
20833: PPUSH
20834: PPUSH
20835: PPUSH
20836: PPUSH
20837: PPUSH
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
20845: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20846: LD_VAR 0 1
20850: NOT
20851: PUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: CALL_OW 257
20861: PUSH
20862: LD_INT 9
20864: NONEQUAL
20865: OR
20866: IFFALSE 20870
// exit ;
20868: GO 21443
// side := GetSide ( unit ) ;
20870: LD_ADDR_VAR 0 9
20874: PUSH
20875: LD_VAR 0 1
20879: PPUSH
20880: CALL_OW 255
20884: ST_TO_ADDR
// tech_space := tech_spacanom ;
20885: LD_ADDR_VAR 0 12
20889: PUSH
20890: LD_INT 29
20892: ST_TO_ADDR
// tech_time := tech_taurad ;
20893: LD_ADDR_VAR 0 13
20897: PUSH
20898: LD_INT 28
20900: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20901: LD_ADDR_VAR 0 11
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 310
20915: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20916: LD_VAR 0 11
20920: PPUSH
20921: CALL_OW 247
20925: PUSH
20926: LD_INT 2
20928: EQUAL
20929: IFFALSE 20933
// exit ;
20931: GO 21443
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20933: LD_ADDR_VAR 0 8
20937: PUSH
20938: LD_INT 81
20940: PUSH
20941: LD_VAR 0 9
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: PUSH
20950: LD_INT 3
20952: PUSH
20953: LD_INT 21
20955: PUSH
20956: LD_INT 3
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PPUSH
20971: CALL_OW 69
20975: ST_TO_ADDR
// if not tmp then
20976: LD_VAR 0 8
20980: NOT
20981: IFFALSE 20985
// exit ;
20983: GO 21443
// if in_unit then
20985: LD_VAR 0 11
20989: IFFALSE 21013
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20991: LD_ADDR_VAR 0 10
20995: PUSH
20996: LD_VAR 0 8
21000: PPUSH
21001: LD_VAR 0 11
21005: PPUSH
21006: CALL_OW 74
21010: ST_TO_ADDR
21011: GO 21033
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21013: LD_ADDR_VAR 0 10
21017: PUSH
21018: LD_VAR 0 8
21022: PPUSH
21023: LD_VAR 0 1
21027: PPUSH
21028: CALL_OW 74
21032: ST_TO_ADDR
// if not enemy then
21033: LD_VAR 0 10
21037: NOT
21038: IFFALSE 21042
// exit ;
21040: GO 21443
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21042: LD_VAR 0 11
21046: PUSH
21047: LD_VAR 0 11
21051: PPUSH
21052: LD_VAR 0 10
21056: PPUSH
21057: CALL_OW 296
21061: PUSH
21062: LD_INT 13
21064: GREATER
21065: AND
21066: PUSH
21067: LD_VAR 0 1
21071: PPUSH
21072: LD_VAR 0 10
21076: PPUSH
21077: CALL_OW 296
21081: PUSH
21082: LD_INT 12
21084: GREATER
21085: OR
21086: IFFALSE 21090
// exit ;
21088: GO 21443
// missile := [ 1 ] ;
21090: LD_ADDR_VAR 0 14
21094: PUSH
21095: LD_INT 1
21097: PUSH
21098: EMPTY
21099: LIST
21100: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21101: LD_VAR 0 9
21105: PPUSH
21106: LD_VAR 0 12
21110: PPUSH
21111: CALL_OW 325
21115: IFFALSE 21144
// missile := Replace ( missile , missile + 1 , 2 ) ;
21117: LD_ADDR_VAR 0 14
21121: PUSH
21122: LD_VAR 0 14
21126: PPUSH
21127: LD_VAR 0 14
21131: PUSH
21132: LD_INT 1
21134: PLUS
21135: PPUSH
21136: LD_INT 2
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21144: LD_VAR 0 9
21148: PPUSH
21149: LD_VAR 0 13
21153: PPUSH
21154: CALL_OW 325
21158: PUSH
21159: LD_VAR 0 10
21163: PPUSH
21164: CALL_OW 255
21168: PPUSH
21169: LD_VAR 0 13
21173: PPUSH
21174: CALL_OW 325
21178: NOT
21179: AND
21180: IFFALSE 21209
// missile := Replace ( missile , missile + 1 , 3 ) ;
21182: LD_ADDR_VAR 0 14
21186: PUSH
21187: LD_VAR 0 14
21191: PPUSH
21192: LD_VAR 0 14
21196: PUSH
21197: LD_INT 1
21199: PLUS
21200: PPUSH
21201: LD_INT 3
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// if missile < 2 then
21209: LD_VAR 0 14
21213: PUSH
21214: LD_INT 2
21216: LESS
21217: IFFALSE 21221
// exit ;
21219: GO 21443
// x := GetX ( enemy ) ;
21221: LD_ADDR_VAR 0 4
21225: PUSH
21226: LD_VAR 0 10
21230: PPUSH
21231: CALL_OW 250
21235: ST_TO_ADDR
// y := GetY ( enemy ) ;
21236: LD_ADDR_VAR 0 5
21240: PUSH
21241: LD_VAR 0 10
21245: PPUSH
21246: CALL_OW 251
21250: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21251: LD_ADDR_VAR 0 6
21255: PUSH
21256: LD_VAR 0 4
21260: PUSH
21261: LD_INT 1
21263: NEG
21264: PPUSH
21265: LD_INT 1
21267: PPUSH
21268: CALL_OW 12
21272: PLUS
21273: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21274: LD_ADDR_VAR 0 7
21278: PUSH
21279: LD_VAR 0 5
21283: PUSH
21284: LD_INT 1
21286: NEG
21287: PPUSH
21288: LD_INT 1
21290: PPUSH
21291: CALL_OW 12
21295: PLUS
21296: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21297: LD_VAR 0 6
21301: PPUSH
21302: LD_VAR 0 7
21306: PPUSH
21307: CALL_OW 488
21311: NOT
21312: IFFALSE 21334
// begin _x := x ;
21314: LD_ADDR_VAR 0 6
21318: PUSH
21319: LD_VAR 0 4
21323: ST_TO_ADDR
// _y := y ;
21324: LD_ADDR_VAR 0 7
21328: PUSH
21329: LD_VAR 0 5
21333: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21334: LD_ADDR_VAR 0 3
21338: PUSH
21339: LD_INT 1
21341: PPUSH
21342: LD_VAR 0 14
21346: PPUSH
21347: CALL_OW 12
21351: ST_TO_ADDR
// case i of 1 :
21352: LD_VAR 0 3
21356: PUSH
21357: LD_INT 1
21359: DOUBLE
21360: EQUAL
21361: IFTRUE 21365
21363: GO 21382
21365: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21366: LD_VAR 0 1
21370: PPUSH
21371: LD_VAR 0 10
21375: PPUSH
21376: CALL_OW 115
21380: GO 21443
21382: LD_INT 2
21384: DOUBLE
21385: EQUAL
21386: IFTRUE 21390
21388: GO 21412
21390: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21391: LD_VAR 0 1
21395: PPUSH
21396: LD_VAR 0 6
21400: PPUSH
21401: LD_VAR 0 7
21405: PPUSH
21406: CALL_OW 153
21410: GO 21443
21412: LD_INT 3
21414: DOUBLE
21415: EQUAL
21416: IFTRUE 21420
21418: GO 21442
21420: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21421: LD_VAR 0 1
21425: PPUSH
21426: LD_VAR 0 6
21430: PPUSH
21431: LD_VAR 0 7
21435: PPUSH
21436: CALL_OW 154
21440: GO 21443
21442: POP
// end ;
21443: LD_VAR 0 2
21447: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
21453: PPUSH
21454: PPUSH
21455: PPUSH
// if not unit or not building then
21456: LD_VAR 0 1
21460: NOT
21461: PUSH
21462: LD_VAR 0 2
21466: NOT
21467: OR
21468: IFFALSE 21472
// exit ;
21470: GO 21630
// x := GetX ( building ) ;
21472: LD_ADDR_VAR 0 5
21476: PUSH
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 250
21486: ST_TO_ADDR
// y := GetY ( building ) ;
21487: LD_ADDR_VAR 0 6
21491: PUSH
21492: LD_VAR 0 2
21496: PPUSH
21497: CALL_OW 251
21501: ST_TO_ADDR
// for i = 0 to 5 do
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: DOUBLE
21508: LD_INT 0
21510: DEC
21511: ST_TO_ADDR
21512: LD_INT 5
21514: PUSH
21515: FOR_TO
21516: IFFALSE 21628
// begin _x := ShiftX ( x , i , 3 ) ;
21518: LD_ADDR_VAR 0 7
21522: PUSH
21523: LD_VAR 0 5
21527: PPUSH
21528: LD_VAR 0 4
21532: PPUSH
21533: LD_INT 3
21535: PPUSH
21536: CALL_OW 272
21540: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21541: LD_ADDR_VAR 0 8
21545: PUSH
21546: LD_VAR 0 6
21550: PPUSH
21551: LD_VAR 0 4
21555: PPUSH
21556: LD_INT 3
21558: PPUSH
21559: CALL_OW 273
21563: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21564: LD_VAR 0 7
21568: PPUSH
21569: LD_VAR 0 8
21573: PPUSH
21574: CALL_OW 488
21578: NOT
21579: IFFALSE 21583
// continue ;
21581: GO 21515
// if HexInfo ( _x , _y ) = 0 then
21583: LD_VAR 0 7
21587: PPUSH
21588: LD_VAR 0 8
21592: PPUSH
21593: CALL_OW 428
21597: PUSH
21598: LD_INT 0
21600: EQUAL
21601: IFFALSE 21626
// begin ComMoveXY ( unit , _x , _y ) ;
21603: LD_VAR 0 1
21607: PPUSH
21608: LD_VAR 0 7
21612: PPUSH
21613: LD_VAR 0 8
21617: PPUSH
21618: CALL_OW 111
// exit ;
21622: POP
21623: POP
21624: GO 21630
// end ; end ;
21626: GO 21515
21628: POP
21629: POP
// end ;
21630: LD_VAR 0 3
21634: RET
// export function ScanBase ( side , base_area ) ; begin
21635: LD_INT 0
21637: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21638: LD_ADDR_VAR 0 3
21642: PUSH
21643: LD_VAR 0 2
21647: PPUSH
21648: LD_INT 81
21650: PUSH
21651: LD_VAR 0 1
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PPUSH
21660: CALL_OW 70
21664: ST_TO_ADDR
// end ;
21665: LD_VAR 0 3
21669: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21670: LD_INT 0
21672: PPUSH
21673: PPUSH
21674: PPUSH
21675: PPUSH
// result := false ;
21676: LD_ADDR_VAR 0 2
21680: PUSH
21681: LD_INT 0
21683: ST_TO_ADDR
// side := GetSide ( unit ) ;
21684: LD_ADDR_VAR 0 3
21688: PUSH
21689: LD_VAR 0 1
21693: PPUSH
21694: CALL_OW 255
21698: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21699: LD_ADDR_VAR 0 4
21703: PUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 248
21713: ST_TO_ADDR
// case nat of 1 :
21714: LD_VAR 0 4
21718: PUSH
21719: LD_INT 1
21721: DOUBLE
21722: EQUAL
21723: IFTRUE 21727
21725: GO 21738
21727: POP
// tech := tech_lassight ; 2 :
21728: LD_ADDR_VAR 0 5
21732: PUSH
21733: LD_INT 12
21735: ST_TO_ADDR
21736: GO 21777
21738: LD_INT 2
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 21757
21746: POP
// tech := tech_mortar ; 3 :
21747: LD_ADDR_VAR 0 5
21751: PUSH
21752: LD_INT 41
21754: ST_TO_ADDR
21755: GO 21777
21757: LD_INT 3
21759: DOUBLE
21760: EQUAL
21761: IFTRUE 21765
21763: GO 21776
21765: POP
// tech := tech_bazooka ; end ;
21766: LD_ADDR_VAR 0 5
21770: PUSH
21771: LD_INT 44
21773: ST_TO_ADDR
21774: GO 21777
21776: POP
// if Researched ( side , tech ) then
21777: LD_VAR 0 3
21781: PPUSH
21782: LD_VAR 0 5
21786: PPUSH
21787: CALL_OW 325
21791: IFFALSE 21818
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21793: LD_ADDR_VAR 0 2
21797: PUSH
21798: LD_INT 5
21800: PUSH
21801: LD_INT 8
21803: PUSH
21804: LD_INT 9
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: PUSH
21812: LD_VAR 0 4
21816: ARRAY
21817: ST_TO_ADDR
// end ;
21818: LD_VAR 0 2
21822: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21823: LD_INT 0
21825: PPUSH
21826: PPUSH
21827: PPUSH
// if not mines then
21828: LD_VAR 0 2
21832: NOT
21833: IFFALSE 21837
// exit ;
21835: GO 21981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21837: LD_ADDR_VAR 0 5
21841: PUSH
21842: LD_INT 81
21844: PUSH
21845: LD_VAR 0 1
21849: PUSH
21850: EMPTY
21851: LIST
21852: LIST
21853: PUSH
21854: LD_INT 3
21856: PUSH
21857: LD_INT 21
21859: PUSH
21860: LD_INT 3
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PPUSH
21875: CALL_OW 69
21879: ST_TO_ADDR
// for i in mines do
21880: LD_ADDR_VAR 0 4
21884: PUSH
21885: LD_VAR 0 2
21889: PUSH
21890: FOR_IN
21891: IFFALSE 21979
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21893: LD_VAR 0 4
21897: PUSH
21898: LD_INT 1
21900: ARRAY
21901: PPUSH
21902: LD_VAR 0 4
21906: PUSH
21907: LD_INT 2
21909: ARRAY
21910: PPUSH
21911: CALL_OW 458
21915: NOT
21916: IFFALSE 21920
// continue ;
21918: GO 21890
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21920: LD_VAR 0 4
21924: PUSH
21925: LD_INT 1
21927: ARRAY
21928: PPUSH
21929: LD_VAR 0 4
21933: PUSH
21934: LD_INT 2
21936: ARRAY
21937: PPUSH
21938: CALL_OW 428
21942: PUSH
21943: LD_VAR 0 5
21947: IN
21948: IFFALSE 21977
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21950: LD_VAR 0 4
21954: PUSH
21955: LD_INT 1
21957: ARRAY
21958: PPUSH
21959: LD_VAR 0 4
21963: PUSH
21964: LD_INT 2
21966: ARRAY
21967: PPUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: CALL_OW 456
// end ;
21977: GO 21890
21979: POP
21980: POP
// end ;
21981: LD_VAR 0 3
21985: RET
// export function Count ( array ) ; var i ; begin
21986: LD_INT 0
21988: PPUSH
21989: PPUSH
// result := 0 ;
21990: LD_ADDR_VAR 0 2
21994: PUSH
21995: LD_INT 0
21997: ST_TO_ADDR
// for i in array do
21998: LD_ADDR_VAR 0 3
22002: PUSH
22003: LD_VAR 0 1
22007: PUSH
22008: FOR_IN
22009: IFFALSE 22033
// if i then
22011: LD_VAR 0 3
22015: IFFALSE 22031
// result := result + 1 ;
22017: LD_ADDR_VAR 0 2
22021: PUSH
22022: LD_VAR 0 2
22026: PUSH
22027: LD_INT 1
22029: PLUS
22030: ST_TO_ADDR
22031: GO 22008
22033: POP
22034: POP
// end ;
22035: LD_VAR 0 2
22039: RET
// export function IsEmpty ( building ) ; begin
22040: LD_INT 0
22042: PPUSH
// if not building then
22043: LD_VAR 0 1
22047: NOT
22048: IFFALSE 22052
// exit ;
22050: GO 22095
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22052: LD_ADDR_VAR 0 2
22056: PUSH
22057: LD_VAR 0 1
22061: PUSH
22062: LD_INT 22
22064: PUSH
22065: LD_VAR 0 1
22069: PPUSH
22070: CALL_OW 255
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: PUSH
22079: LD_INT 58
22081: PUSH
22082: EMPTY
22083: LIST
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: PPUSH
22089: CALL_OW 69
22093: IN
22094: ST_TO_ADDR
// end ;
22095: LD_VAR 0 2
22099: RET
// export function IsNotFull ( building ) ; var places ; begin
22100: LD_INT 0
22102: PPUSH
22103: PPUSH
// if not building then
22104: LD_VAR 0 1
22108: NOT
22109: IFFALSE 22113
// exit ;
22111: GO 22284
// result := false ;
22113: LD_ADDR_VAR 0 2
22117: PUSH
22118: LD_INT 0
22120: ST_TO_ADDR
// places := 0 ;
22121: LD_ADDR_VAR 0 3
22125: PUSH
22126: LD_INT 0
22128: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
22129: LD_VAR 0 1
22133: PPUSH
22134: CALL_OW 266
22138: PUSH
22139: LD_INT 0
22141: DOUBLE
22142: EQUAL
22143: IFTRUE 22201
22145: LD_INT 1
22147: DOUBLE
22148: EQUAL
22149: IFTRUE 22201
22151: LD_INT 6
22153: DOUBLE
22154: EQUAL
22155: IFTRUE 22201
22157: LD_INT 7
22159: DOUBLE
22160: EQUAL
22161: IFTRUE 22201
22163: LD_INT 8
22165: DOUBLE
22166: EQUAL
22167: IFTRUE 22201
22169: LD_INT 4
22171: DOUBLE
22172: EQUAL
22173: IFTRUE 22201
22175: LD_INT 5
22177: DOUBLE
22178: EQUAL
22179: IFTRUE 22201
22181: LD_INT 2
22183: DOUBLE
22184: EQUAL
22185: IFTRUE 22201
22187: LD_INT 3
22189: DOUBLE
22190: EQUAL
22191: IFTRUE 22201
22193: LD_INT 35
22195: DOUBLE
22196: EQUAL
22197: IFTRUE 22201
22199: GO 22212
22201: POP
// places := 6 ; b_bunker , b_breastwork :
22202: LD_ADDR_VAR 0 3
22206: PUSH
22207: LD_INT 6
22209: ST_TO_ADDR
22210: GO 22257
22212: LD_INT 32
22214: DOUBLE
22215: EQUAL
22216: IFTRUE 22226
22218: LD_INT 31
22220: DOUBLE
22221: EQUAL
22222: IFTRUE 22226
22224: GO 22237
22226: POP
// places := 1 ; b_control_tower :
22227: LD_ADDR_VAR 0 3
22231: PUSH
22232: LD_INT 1
22234: ST_TO_ADDR
22235: GO 22257
22237: LD_INT 36
22239: DOUBLE
22240: EQUAL
22241: IFTRUE 22245
22243: GO 22256
22245: POP
// places := 3 ; end ;
22246: LD_ADDR_VAR 0 3
22250: PUSH
22251: LD_INT 3
22253: ST_TO_ADDR
22254: GO 22257
22256: POP
// if places then
22257: LD_VAR 0 3
22261: IFFALSE 22284
// result := UnitsInside ( building ) < places ;
22263: LD_ADDR_VAR 0 2
22267: PUSH
22268: LD_VAR 0 1
22272: PPUSH
22273: CALL_OW 313
22277: PUSH
22278: LD_VAR 0 3
22282: LESS
22283: ST_TO_ADDR
// end ;
22284: LD_VAR 0 2
22288: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22289: LD_INT 0
22291: PPUSH
22292: PPUSH
22293: PPUSH
22294: PPUSH
// tmp := [ ] ;
22295: LD_ADDR_VAR 0 3
22299: PUSH
22300: EMPTY
22301: ST_TO_ADDR
// list := [ ] ;
22302: LD_ADDR_VAR 0 5
22306: PUSH
22307: EMPTY
22308: ST_TO_ADDR
// for i = 16 to 25 do
22309: LD_ADDR_VAR 0 4
22313: PUSH
22314: DOUBLE
22315: LD_INT 16
22317: DEC
22318: ST_TO_ADDR
22319: LD_INT 25
22321: PUSH
22322: FOR_TO
22323: IFFALSE 22396
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22325: LD_ADDR_VAR 0 3
22329: PUSH
22330: LD_VAR 0 3
22334: PUSH
22335: LD_INT 22
22337: PUSH
22338: LD_VAR 0 1
22342: PPUSH
22343: CALL_OW 255
22347: PUSH
22348: EMPTY
22349: LIST
22350: LIST
22351: PUSH
22352: LD_INT 91
22354: PUSH
22355: LD_VAR 0 1
22359: PUSH
22360: LD_INT 6
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: LIST
22367: PUSH
22368: LD_INT 30
22370: PUSH
22371: LD_VAR 0 4
22375: PUSH
22376: EMPTY
22377: LIST
22378: LIST
22379: PUSH
22380: EMPTY
22381: LIST
22382: LIST
22383: LIST
22384: PUSH
22385: EMPTY
22386: LIST
22387: PPUSH
22388: CALL_OW 69
22392: ADD
22393: ST_TO_ADDR
22394: GO 22322
22396: POP
22397: POP
// for i = 1 to tmp do
22398: LD_ADDR_VAR 0 4
22402: PUSH
22403: DOUBLE
22404: LD_INT 1
22406: DEC
22407: ST_TO_ADDR
22408: LD_VAR 0 3
22412: PUSH
22413: FOR_TO
22414: IFFALSE 22502
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22416: LD_ADDR_VAR 0 5
22420: PUSH
22421: LD_VAR 0 5
22425: PUSH
22426: LD_VAR 0 3
22430: PUSH
22431: LD_VAR 0 4
22435: ARRAY
22436: PPUSH
22437: CALL_OW 266
22441: PUSH
22442: LD_VAR 0 3
22446: PUSH
22447: LD_VAR 0 4
22451: ARRAY
22452: PPUSH
22453: CALL_OW 250
22457: PUSH
22458: LD_VAR 0 3
22462: PUSH
22463: LD_VAR 0 4
22467: ARRAY
22468: PPUSH
22469: CALL_OW 251
22473: PUSH
22474: LD_VAR 0 3
22478: PUSH
22479: LD_VAR 0 4
22483: ARRAY
22484: PPUSH
22485: CALL_OW 254
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: LIST
22494: LIST
22495: PUSH
22496: EMPTY
22497: LIST
22498: ADD
22499: ST_TO_ADDR
22500: GO 22413
22502: POP
22503: POP
// result := list ;
22504: LD_ADDR_VAR 0 2
22508: PUSH
22509: LD_VAR 0 5
22513: ST_TO_ADDR
// end ;
22514: LD_VAR 0 2
22518: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22519: LD_INT 0
22521: PPUSH
22522: PPUSH
22523: PPUSH
22524: PPUSH
22525: PPUSH
22526: PPUSH
22527: PPUSH
// if not factory then
22528: LD_VAR 0 1
22532: NOT
22533: IFFALSE 22537
// exit ;
22535: GO 23130
// if control = control_apeman then
22537: LD_VAR 0 4
22541: PUSH
22542: LD_INT 5
22544: EQUAL
22545: IFFALSE 22654
// begin tmp := UnitsInside ( factory ) ;
22547: LD_ADDR_VAR 0 8
22551: PUSH
22552: LD_VAR 0 1
22556: PPUSH
22557: CALL_OW 313
22561: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22562: LD_VAR 0 8
22566: PPUSH
22567: LD_INT 25
22569: PUSH
22570: LD_INT 12
22572: PUSH
22573: EMPTY
22574: LIST
22575: LIST
22576: PPUSH
22577: CALL_OW 72
22581: NOT
22582: IFFALSE 22592
// control := control_manual ;
22584: LD_ADDR_VAR 0 4
22588: PUSH
22589: LD_INT 1
22591: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22592: LD_ADDR_VAR 0 8
22596: PUSH
22597: LD_VAR 0 1
22601: PPUSH
22602: CALL 22289 0 1
22606: ST_TO_ADDR
// if tmp then
22607: LD_VAR 0 8
22611: IFFALSE 22654
// begin for i in tmp do
22613: LD_ADDR_VAR 0 7
22617: PUSH
22618: LD_VAR 0 8
22622: PUSH
22623: FOR_IN
22624: IFFALSE 22652
// if i [ 1 ] = b_ext_radio then
22626: LD_VAR 0 7
22630: PUSH
22631: LD_INT 1
22633: ARRAY
22634: PUSH
22635: LD_INT 22
22637: EQUAL
22638: IFFALSE 22650
// begin control := control_remote ;
22640: LD_ADDR_VAR 0 4
22644: PUSH
22645: LD_INT 2
22647: ST_TO_ADDR
// break ;
22648: GO 22652
// end ;
22650: GO 22623
22652: POP
22653: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 2
22663: PPUSH
22664: LD_VAR 0 3
22668: PPUSH
22669: LD_VAR 0 4
22673: PPUSH
22674: LD_VAR 0 5
22678: PPUSH
22679: CALL_OW 448
22683: IFFALSE 22718
// begin result := [ chassis , engine , control , weapon ] ;
22685: LD_ADDR_VAR 0 6
22689: PUSH
22690: LD_VAR 0 2
22694: PUSH
22695: LD_VAR 0 3
22699: PUSH
22700: LD_VAR 0 4
22704: PUSH
22705: LD_VAR 0 5
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: LIST
22714: LIST
22715: ST_TO_ADDR
// exit ;
22716: GO 23130
// end ; _chassis := AvailableChassisList ( factory ) ;
22718: LD_ADDR_VAR 0 9
22722: PUSH
22723: LD_VAR 0 1
22727: PPUSH
22728: CALL_OW 475
22732: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22733: LD_ADDR_VAR 0 11
22737: PUSH
22738: LD_VAR 0 1
22742: PPUSH
22743: CALL_OW 476
22747: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22748: LD_ADDR_VAR 0 12
22752: PUSH
22753: LD_VAR 0 1
22757: PPUSH
22758: CALL_OW 477
22762: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22763: LD_ADDR_VAR 0 10
22767: PUSH
22768: LD_VAR 0 1
22772: PPUSH
22773: CALL_OW 478
22777: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22778: LD_VAR 0 9
22782: NOT
22783: PUSH
22784: LD_VAR 0 11
22788: NOT
22789: OR
22790: PUSH
22791: LD_VAR 0 12
22795: NOT
22796: OR
22797: PUSH
22798: LD_VAR 0 10
22802: NOT
22803: OR
22804: IFFALSE 22839
// begin result := [ chassis , engine , control , weapon ] ;
22806: LD_ADDR_VAR 0 6
22810: PUSH
22811: LD_VAR 0 2
22815: PUSH
22816: LD_VAR 0 3
22820: PUSH
22821: LD_VAR 0 4
22825: PUSH
22826: LD_VAR 0 5
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: ST_TO_ADDR
// exit ;
22837: GO 23130
// end ; if not chassis in _chassis then
22839: LD_VAR 0 2
22843: PUSH
22844: LD_VAR 0 9
22848: IN
22849: NOT
22850: IFFALSE 22876
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22852: LD_ADDR_VAR 0 2
22856: PUSH
22857: LD_VAR 0 9
22861: PUSH
22862: LD_INT 1
22864: PPUSH
22865: LD_VAR 0 9
22869: PPUSH
22870: CALL_OW 12
22874: ARRAY
22875: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22876: LD_VAR 0 2
22880: PPUSH
22881: LD_VAR 0 3
22885: PPUSH
22886: CALL 23135 0 2
22890: NOT
22891: IFFALSE 22950
// repeat engine := _engine [ 1 ] ;
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_VAR 0 11
22902: PUSH
22903: LD_INT 1
22905: ARRAY
22906: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22907: LD_ADDR_VAR 0 11
22911: PUSH
22912: LD_VAR 0 11
22916: PPUSH
22917: LD_INT 1
22919: PPUSH
22920: CALL_OW 3
22924: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22925: LD_VAR 0 2
22929: PPUSH
22930: LD_VAR 0 3
22934: PPUSH
22935: CALL 23135 0 2
22939: PUSH
22940: LD_VAR 0 11
22944: PUSH
22945: EMPTY
22946: EQUAL
22947: OR
22948: IFFALSE 22893
// if not control in _control then
22950: LD_VAR 0 4
22954: PUSH
22955: LD_VAR 0 12
22959: IN
22960: NOT
22961: IFFALSE 22987
// control := _control [ rand ( 1 , _control ) ] ;
22963: LD_ADDR_VAR 0 4
22967: PUSH
22968: LD_VAR 0 12
22972: PUSH
22973: LD_INT 1
22975: PPUSH
22976: LD_VAR 0 12
22980: PPUSH
22981: CALL_OW 12
22985: ARRAY
22986: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22987: LD_VAR 0 2
22991: PPUSH
22992: LD_VAR 0 5
22996: PPUSH
22997: CALL 23355 0 2
23001: NOT
23002: IFFALSE 23061
// repeat weapon := _weapon [ 1 ] ;
23004: LD_ADDR_VAR 0 5
23008: PUSH
23009: LD_VAR 0 10
23013: PUSH
23014: LD_INT 1
23016: ARRAY
23017: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
23018: LD_ADDR_VAR 0 10
23022: PUSH
23023: LD_VAR 0 10
23027: PPUSH
23028: LD_INT 1
23030: PPUSH
23031: CALL_OW 3
23035: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
23036: LD_VAR 0 2
23040: PPUSH
23041: LD_VAR 0 5
23045: PPUSH
23046: CALL 23355 0 2
23050: PUSH
23051: LD_VAR 0 10
23055: PUSH
23056: EMPTY
23057: EQUAL
23058: OR
23059: IFFALSE 23004
// result := [ ] ;
23061: LD_ADDR_VAR 0 6
23065: PUSH
23066: EMPTY
23067: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
23068: LD_VAR 0 1
23072: PPUSH
23073: LD_VAR 0 2
23077: PPUSH
23078: LD_VAR 0 3
23082: PPUSH
23083: LD_VAR 0 4
23087: PPUSH
23088: LD_VAR 0 5
23092: PPUSH
23093: CALL_OW 448
23097: IFFALSE 23130
// result := [ chassis , engine , control , weapon ] ;
23099: LD_ADDR_VAR 0 6
23103: PUSH
23104: LD_VAR 0 2
23108: PUSH
23109: LD_VAR 0 3
23113: PUSH
23114: LD_VAR 0 4
23118: PUSH
23119: LD_VAR 0 5
23123: PUSH
23124: EMPTY
23125: LIST
23126: LIST
23127: LIST
23128: LIST
23129: ST_TO_ADDR
// end ;
23130: LD_VAR 0 6
23134: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
23135: LD_INT 0
23137: PPUSH
// if not chassis or not engine then
23138: LD_VAR 0 1
23142: NOT
23143: PUSH
23144: LD_VAR 0 2
23148: NOT
23149: OR
23150: IFFALSE 23154
// exit ;
23152: GO 23350
// case engine of engine_solar :
23154: LD_VAR 0 2
23158: PUSH
23159: LD_INT 2
23161: DOUBLE
23162: EQUAL
23163: IFTRUE 23167
23165: GO 23205
23167: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
23168: LD_ADDR_VAR 0 3
23172: PUSH
23173: LD_INT 11
23175: PUSH
23176: LD_INT 12
23178: PUSH
23179: LD_INT 13
23181: PUSH
23182: LD_INT 14
23184: PUSH
23185: LD_INT 1
23187: PUSH
23188: LD_INT 2
23190: PUSH
23191: LD_INT 3
23193: PUSH
23194: EMPTY
23195: LIST
23196: LIST
23197: LIST
23198: LIST
23199: LIST
23200: LIST
23201: LIST
23202: ST_TO_ADDR
23203: GO 23334
23205: LD_INT 1
23207: DOUBLE
23208: EQUAL
23209: IFTRUE 23213
23211: GO 23275
23213: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23214: LD_ADDR_VAR 0 3
23218: PUSH
23219: LD_INT 11
23221: PUSH
23222: LD_INT 12
23224: PUSH
23225: LD_INT 13
23227: PUSH
23228: LD_INT 14
23230: PUSH
23231: LD_INT 1
23233: PUSH
23234: LD_INT 2
23236: PUSH
23237: LD_INT 3
23239: PUSH
23240: LD_INT 4
23242: PUSH
23243: LD_INT 5
23245: PUSH
23246: LD_INT 21
23248: PUSH
23249: LD_INT 23
23251: PUSH
23252: LD_INT 22
23254: PUSH
23255: LD_INT 24
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: LIST
23266: LIST
23267: LIST
23268: LIST
23269: LIST
23270: LIST
23271: LIST
23272: ST_TO_ADDR
23273: GO 23334
23275: LD_INT 3
23277: DOUBLE
23278: EQUAL
23279: IFTRUE 23283
23281: GO 23333
23283: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23284: LD_ADDR_VAR 0 3
23288: PUSH
23289: LD_INT 13
23291: PUSH
23292: LD_INT 14
23294: PUSH
23295: LD_INT 2
23297: PUSH
23298: LD_INT 3
23300: PUSH
23301: LD_INT 4
23303: PUSH
23304: LD_INT 5
23306: PUSH
23307: LD_INT 21
23309: PUSH
23310: LD_INT 22
23312: PUSH
23313: LD_INT 23
23315: PUSH
23316: LD_INT 24
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: ST_TO_ADDR
23331: GO 23334
23333: POP
// result := ( chassis in result ) ;
23334: LD_ADDR_VAR 0 3
23338: PUSH
23339: LD_VAR 0 1
23343: PUSH
23344: LD_VAR 0 3
23348: IN
23349: ST_TO_ADDR
// end ;
23350: LD_VAR 0 3
23354: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23355: LD_INT 0
23357: PPUSH
// if not chassis or not weapon then
23358: LD_VAR 0 1
23362: NOT
23363: PUSH
23364: LD_VAR 0 2
23368: NOT
23369: OR
23370: IFFALSE 23374
// exit ;
23372: GO 24434
// case weapon of us_machine_gun :
23374: LD_VAR 0 2
23378: PUSH
23379: LD_INT 2
23381: DOUBLE
23382: EQUAL
23383: IFTRUE 23387
23385: GO 23417
23387: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23388: LD_ADDR_VAR 0 3
23392: PUSH
23393: LD_INT 1
23395: PUSH
23396: LD_INT 2
23398: PUSH
23399: LD_INT 3
23401: PUSH
23402: LD_INT 4
23404: PUSH
23405: LD_INT 5
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: ST_TO_ADDR
23415: GO 24418
23417: LD_INT 3
23419: DOUBLE
23420: EQUAL
23421: IFTRUE 23425
23423: GO 23455
23425: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23426: LD_ADDR_VAR 0 3
23430: PUSH
23431: LD_INT 1
23433: PUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 3
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: LD_INT 5
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: LIST
23452: ST_TO_ADDR
23453: GO 24418
23455: LD_INT 11
23457: DOUBLE
23458: EQUAL
23459: IFTRUE 23463
23461: GO 23493
23463: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23464: LD_ADDR_VAR 0 3
23468: PUSH
23469: LD_INT 1
23471: PUSH
23472: LD_INT 2
23474: PUSH
23475: LD_INT 3
23477: PUSH
23478: LD_INT 4
23480: PUSH
23481: LD_INT 5
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: LIST
23488: LIST
23489: LIST
23490: ST_TO_ADDR
23491: GO 24418
23493: LD_INT 4
23495: DOUBLE
23496: EQUAL
23497: IFTRUE 23501
23499: GO 23527
23501: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23502: LD_ADDR_VAR 0 3
23506: PUSH
23507: LD_INT 2
23509: PUSH
23510: LD_INT 3
23512: PUSH
23513: LD_INT 4
23515: PUSH
23516: LD_INT 5
23518: PUSH
23519: EMPTY
23520: LIST
23521: LIST
23522: LIST
23523: LIST
23524: ST_TO_ADDR
23525: GO 24418
23527: LD_INT 5
23529: DOUBLE
23530: EQUAL
23531: IFTRUE 23535
23533: GO 23561
23535: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23536: LD_ADDR_VAR 0 3
23540: PUSH
23541: LD_INT 2
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 4
23549: PUSH
23550: LD_INT 5
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: LIST
23557: LIST
23558: ST_TO_ADDR
23559: GO 24418
23561: LD_INT 9
23563: DOUBLE
23564: EQUAL
23565: IFTRUE 23569
23567: GO 23595
23569: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23570: LD_ADDR_VAR 0 3
23574: PUSH
23575: LD_INT 2
23577: PUSH
23578: LD_INT 3
23580: PUSH
23581: LD_INT 4
23583: PUSH
23584: LD_INT 5
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: LIST
23591: LIST
23592: ST_TO_ADDR
23593: GO 24418
23595: LD_INT 7
23597: DOUBLE
23598: EQUAL
23599: IFTRUE 23603
23601: GO 23629
23603: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23604: LD_ADDR_VAR 0 3
23608: PUSH
23609: LD_INT 2
23611: PUSH
23612: LD_INT 3
23614: PUSH
23615: LD_INT 4
23617: PUSH
23618: LD_INT 5
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: LIST
23625: LIST
23626: ST_TO_ADDR
23627: GO 24418
23629: LD_INT 12
23631: DOUBLE
23632: EQUAL
23633: IFTRUE 23637
23635: GO 23663
23637: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23638: LD_ADDR_VAR 0 3
23642: PUSH
23643: LD_INT 2
23645: PUSH
23646: LD_INT 3
23648: PUSH
23649: LD_INT 4
23651: PUSH
23652: LD_INT 5
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: LIST
23659: LIST
23660: ST_TO_ADDR
23661: GO 24418
23663: LD_INT 13
23665: DOUBLE
23666: EQUAL
23667: IFTRUE 23671
23669: GO 23697
23671: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23672: LD_ADDR_VAR 0 3
23676: PUSH
23677: LD_INT 2
23679: PUSH
23680: LD_INT 3
23682: PUSH
23683: LD_INT 4
23685: PUSH
23686: LD_INT 5
23688: PUSH
23689: EMPTY
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: ST_TO_ADDR
23695: GO 24418
23697: LD_INT 14
23699: DOUBLE
23700: EQUAL
23701: IFTRUE 23705
23703: GO 23723
23705: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23706: LD_ADDR_VAR 0 3
23710: PUSH
23711: LD_INT 4
23713: PUSH
23714: LD_INT 5
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: ST_TO_ADDR
23721: GO 24418
23723: LD_INT 6
23725: DOUBLE
23726: EQUAL
23727: IFTRUE 23731
23729: GO 23749
23731: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23732: LD_ADDR_VAR 0 3
23736: PUSH
23737: LD_INT 4
23739: PUSH
23740: LD_INT 5
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: ST_TO_ADDR
23747: GO 24418
23749: LD_INT 10
23751: DOUBLE
23752: EQUAL
23753: IFTRUE 23757
23755: GO 23775
23757: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23758: LD_ADDR_VAR 0 3
23762: PUSH
23763: LD_INT 4
23765: PUSH
23766: LD_INT 5
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: ST_TO_ADDR
23773: GO 24418
23775: LD_INT 22
23777: DOUBLE
23778: EQUAL
23779: IFTRUE 23783
23781: GO 23809
23783: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23784: LD_ADDR_VAR 0 3
23788: PUSH
23789: LD_INT 11
23791: PUSH
23792: LD_INT 12
23794: PUSH
23795: LD_INT 13
23797: PUSH
23798: LD_INT 14
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: LIST
23805: LIST
23806: ST_TO_ADDR
23807: GO 24418
23809: LD_INT 23
23811: DOUBLE
23812: EQUAL
23813: IFTRUE 23817
23815: GO 23843
23817: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23818: LD_ADDR_VAR 0 3
23822: PUSH
23823: LD_INT 11
23825: PUSH
23826: LD_INT 12
23828: PUSH
23829: LD_INT 13
23831: PUSH
23832: LD_INT 14
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: ST_TO_ADDR
23841: GO 24418
23843: LD_INT 24
23845: DOUBLE
23846: EQUAL
23847: IFTRUE 23851
23849: GO 23877
23851: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23852: LD_ADDR_VAR 0 3
23856: PUSH
23857: LD_INT 11
23859: PUSH
23860: LD_INT 12
23862: PUSH
23863: LD_INT 13
23865: PUSH
23866: LD_INT 14
23868: PUSH
23869: EMPTY
23870: LIST
23871: LIST
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 24418
23877: LD_INT 30
23879: DOUBLE
23880: EQUAL
23881: IFTRUE 23885
23883: GO 23911
23885: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23886: LD_ADDR_VAR 0 3
23890: PUSH
23891: LD_INT 11
23893: PUSH
23894: LD_INT 12
23896: PUSH
23897: LD_INT 13
23899: PUSH
23900: LD_INT 14
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: LIST
23907: LIST
23908: ST_TO_ADDR
23909: GO 24418
23911: LD_INT 25
23913: DOUBLE
23914: EQUAL
23915: IFTRUE 23919
23917: GO 23937
23919: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23920: LD_ADDR_VAR 0 3
23924: PUSH
23925: LD_INT 13
23927: PUSH
23928: LD_INT 14
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: ST_TO_ADDR
23935: GO 24418
23937: LD_INT 27
23939: DOUBLE
23940: EQUAL
23941: IFTRUE 23945
23943: GO 23963
23945: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23946: LD_ADDR_VAR 0 3
23950: PUSH
23951: LD_INT 13
23953: PUSH
23954: LD_INT 14
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: ST_TO_ADDR
23961: GO 24418
23963: LD_INT 92
23965: DOUBLE
23966: EQUAL
23967: IFTRUE 23971
23969: GO 23997
23971: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23972: LD_ADDR_VAR 0 3
23976: PUSH
23977: LD_INT 11
23979: PUSH
23980: LD_INT 12
23982: PUSH
23983: LD_INT 13
23985: PUSH
23986: LD_INT 14
23988: PUSH
23989: EMPTY
23990: LIST
23991: LIST
23992: LIST
23993: LIST
23994: ST_TO_ADDR
23995: GO 24418
23997: LD_INT 28
23999: DOUBLE
24000: EQUAL
24001: IFTRUE 24005
24003: GO 24023
24005: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
24006: LD_ADDR_VAR 0 3
24010: PUSH
24011: LD_INT 13
24013: PUSH
24014: LD_INT 14
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: ST_TO_ADDR
24021: GO 24418
24023: LD_INT 29
24025: DOUBLE
24026: EQUAL
24027: IFTRUE 24031
24029: GO 24049
24031: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
24032: LD_ADDR_VAR 0 3
24036: PUSH
24037: LD_INT 13
24039: PUSH
24040: LD_INT 14
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: ST_TO_ADDR
24047: GO 24418
24049: LD_INT 31
24051: DOUBLE
24052: EQUAL
24053: IFTRUE 24057
24055: GO 24075
24057: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
24058: LD_ADDR_VAR 0 3
24062: PUSH
24063: LD_INT 13
24065: PUSH
24066: LD_INT 14
24068: PUSH
24069: EMPTY
24070: LIST
24071: LIST
24072: ST_TO_ADDR
24073: GO 24418
24075: LD_INT 26
24077: DOUBLE
24078: EQUAL
24079: IFTRUE 24083
24081: GO 24101
24083: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
24084: LD_ADDR_VAR 0 3
24088: PUSH
24089: LD_INT 13
24091: PUSH
24092: LD_INT 14
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: ST_TO_ADDR
24099: GO 24418
24101: LD_INT 42
24103: DOUBLE
24104: EQUAL
24105: IFTRUE 24109
24107: GO 24135
24109: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
24110: LD_ADDR_VAR 0 3
24114: PUSH
24115: LD_INT 21
24117: PUSH
24118: LD_INT 22
24120: PUSH
24121: LD_INT 23
24123: PUSH
24124: LD_INT 24
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: ST_TO_ADDR
24133: GO 24418
24135: LD_INT 43
24137: DOUBLE
24138: EQUAL
24139: IFTRUE 24143
24141: GO 24169
24143: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
24144: LD_ADDR_VAR 0 3
24148: PUSH
24149: LD_INT 21
24151: PUSH
24152: LD_INT 22
24154: PUSH
24155: LD_INT 23
24157: PUSH
24158: LD_INT 24
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: ST_TO_ADDR
24167: GO 24418
24169: LD_INT 44
24171: DOUBLE
24172: EQUAL
24173: IFTRUE 24177
24175: GO 24203
24177: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24178: LD_ADDR_VAR 0 3
24182: PUSH
24183: LD_INT 21
24185: PUSH
24186: LD_INT 22
24188: PUSH
24189: LD_INT 23
24191: PUSH
24192: LD_INT 24
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: LIST
24199: LIST
24200: ST_TO_ADDR
24201: GO 24418
24203: LD_INT 45
24205: DOUBLE
24206: EQUAL
24207: IFTRUE 24211
24209: GO 24237
24211: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24212: LD_ADDR_VAR 0 3
24216: PUSH
24217: LD_INT 21
24219: PUSH
24220: LD_INT 22
24222: PUSH
24223: LD_INT 23
24225: PUSH
24226: LD_INT 24
24228: PUSH
24229: EMPTY
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: ST_TO_ADDR
24235: GO 24418
24237: LD_INT 49
24239: DOUBLE
24240: EQUAL
24241: IFTRUE 24245
24243: GO 24271
24245: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24246: LD_ADDR_VAR 0 3
24250: PUSH
24251: LD_INT 21
24253: PUSH
24254: LD_INT 22
24256: PUSH
24257: LD_INT 23
24259: PUSH
24260: LD_INT 24
24262: PUSH
24263: EMPTY
24264: LIST
24265: LIST
24266: LIST
24267: LIST
24268: ST_TO_ADDR
24269: GO 24418
24271: LD_INT 51
24273: DOUBLE
24274: EQUAL
24275: IFTRUE 24279
24277: GO 24305
24279: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24280: LD_ADDR_VAR 0 3
24284: PUSH
24285: LD_INT 21
24287: PUSH
24288: LD_INT 22
24290: PUSH
24291: LD_INT 23
24293: PUSH
24294: LD_INT 24
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: ST_TO_ADDR
24303: GO 24418
24305: LD_INT 52
24307: DOUBLE
24308: EQUAL
24309: IFTRUE 24313
24311: GO 24339
24313: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24314: LD_ADDR_VAR 0 3
24318: PUSH
24319: LD_INT 21
24321: PUSH
24322: LD_INT 22
24324: PUSH
24325: LD_INT 23
24327: PUSH
24328: LD_INT 24
24330: PUSH
24331: EMPTY
24332: LIST
24333: LIST
24334: LIST
24335: LIST
24336: ST_TO_ADDR
24337: GO 24418
24339: LD_INT 53
24341: DOUBLE
24342: EQUAL
24343: IFTRUE 24347
24345: GO 24365
24347: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24348: LD_ADDR_VAR 0 3
24352: PUSH
24353: LD_INT 23
24355: PUSH
24356: LD_INT 24
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: ST_TO_ADDR
24363: GO 24418
24365: LD_INT 46
24367: DOUBLE
24368: EQUAL
24369: IFTRUE 24373
24371: GO 24391
24373: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24374: LD_ADDR_VAR 0 3
24378: PUSH
24379: LD_INT 23
24381: PUSH
24382: LD_INT 24
24384: PUSH
24385: EMPTY
24386: LIST
24387: LIST
24388: ST_TO_ADDR
24389: GO 24418
24391: LD_INT 47
24393: DOUBLE
24394: EQUAL
24395: IFTRUE 24399
24397: GO 24417
24399: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24400: LD_ADDR_VAR 0 3
24404: PUSH
24405: LD_INT 23
24407: PUSH
24408: LD_INT 24
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: ST_TO_ADDR
24415: GO 24418
24417: POP
// result := ( chassis in result ) ;
24418: LD_ADDR_VAR 0 3
24422: PUSH
24423: LD_VAR 0 1
24427: PUSH
24428: LD_VAR 0 3
24432: IN
24433: ST_TO_ADDR
// end ;
24434: LD_VAR 0 3
24438: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24439: LD_INT 0
24441: PPUSH
24442: PPUSH
24443: PPUSH
24444: PPUSH
24445: PPUSH
24446: PPUSH
24447: PPUSH
// result := array ;
24448: LD_ADDR_VAR 0 5
24452: PUSH
24453: LD_VAR 0 1
24457: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24458: LD_VAR 0 1
24462: NOT
24463: PUSH
24464: LD_VAR 0 2
24468: NOT
24469: OR
24470: PUSH
24471: LD_VAR 0 3
24475: NOT
24476: OR
24477: PUSH
24478: LD_VAR 0 2
24482: PUSH
24483: LD_VAR 0 1
24487: GREATER
24488: OR
24489: PUSH
24490: LD_VAR 0 3
24494: PUSH
24495: LD_VAR 0 1
24499: GREATER
24500: OR
24501: IFFALSE 24505
// exit ;
24503: GO 24801
// if direction then
24505: LD_VAR 0 4
24509: IFFALSE 24573
// begin d := 1 ;
24511: LD_ADDR_VAR 0 9
24515: PUSH
24516: LD_INT 1
24518: ST_TO_ADDR
// if i_from > i_to then
24519: LD_VAR 0 2
24523: PUSH
24524: LD_VAR 0 3
24528: GREATER
24529: IFFALSE 24555
// length := ( array - i_from ) + i_to else
24531: LD_ADDR_VAR 0 11
24535: PUSH
24536: LD_VAR 0 1
24540: PUSH
24541: LD_VAR 0 2
24545: MINUS
24546: PUSH
24547: LD_VAR 0 3
24551: PLUS
24552: ST_TO_ADDR
24553: GO 24571
// length := i_to - i_from ;
24555: LD_ADDR_VAR 0 11
24559: PUSH
24560: LD_VAR 0 3
24564: PUSH
24565: LD_VAR 0 2
24569: MINUS
24570: ST_TO_ADDR
// end else
24571: GO 24634
// begin d := - 1 ;
24573: LD_ADDR_VAR 0 9
24577: PUSH
24578: LD_INT 1
24580: NEG
24581: ST_TO_ADDR
// if i_from > i_to then
24582: LD_VAR 0 2
24586: PUSH
24587: LD_VAR 0 3
24591: GREATER
24592: IFFALSE 24612
// length := i_from - i_to else
24594: LD_ADDR_VAR 0 11
24598: PUSH
24599: LD_VAR 0 2
24603: PUSH
24604: LD_VAR 0 3
24608: MINUS
24609: ST_TO_ADDR
24610: GO 24634
// length := ( array - i_to ) + i_from ;
24612: LD_ADDR_VAR 0 11
24616: PUSH
24617: LD_VAR 0 1
24621: PUSH
24622: LD_VAR 0 3
24626: MINUS
24627: PUSH
24628: LD_VAR 0 2
24632: PLUS
24633: ST_TO_ADDR
// end ; if not length then
24634: LD_VAR 0 11
24638: NOT
24639: IFFALSE 24643
// exit ;
24641: GO 24801
// tmp := array ;
24643: LD_ADDR_VAR 0 10
24647: PUSH
24648: LD_VAR 0 1
24652: ST_TO_ADDR
// for i = 1 to length do
24653: LD_ADDR_VAR 0 6
24657: PUSH
24658: DOUBLE
24659: LD_INT 1
24661: DEC
24662: ST_TO_ADDR
24663: LD_VAR 0 11
24667: PUSH
24668: FOR_TO
24669: IFFALSE 24789
// begin for j = 1 to array do
24671: LD_ADDR_VAR 0 7
24675: PUSH
24676: DOUBLE
24677: LD_INT 1
24679: DEC
24680: ST_TO_ADDR
24681: LD_VAR 0 1
24685: PUSH
24686: FOR_TO
24687: IFFALSE 24775
// begin k := j + d ;
24689: LD_ADDR_VAR 0 8
24693: PUSH
24694: LD_VAR 0 7
24698: PUSH
24699: LD_VAR 0 9
24703: PLUS
24704: ST_TO_ADDR
// if k > array then
24705: LD_VAR 0 8
24709: PUSH
24710: LD_VAR 0 1
24714: GREATER
24715: IFFALSE 24725
// k := 1 ;
24717: LD_ADDR_VAR 0 8
24721: PUSH
24722: LD_INT 1
24724: ST_TO_ADDR
// if not k then
24725: LD_VAR 0 8
24729: NOT
24730: IFFALSE 24742
// k := array ;
24732: LD_ADDR_VAR 0 8
24736: PUSH
24737: LD_VAR 0 1
24741: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24742: LD_ADDR_VAR 0 10
24746: PUSH
24747: LD_VAR 0 10
24751: PPUSH
24752: LD_VAR 0 8
24756: PPUSH
24757: LD_VAR 0 1
24761: PUSH
24762: LD_VAR 0 7
24766: ARRAY
24767: PPUSH
24768: CALL_OW 1
24772: ST_TO_ADDR
// end ;
24773: GO 24686
24775: POP
24776: POP
// array := tmp ;
24777: LD_ADDR_VAR 0 1
24781: PUSH
24782: LD_VAR 0 10
24786: ST_TO_ADDR
// end ;
24787: GO 24668
24789: POP
24790: POP
// result := array ;
24791: LD_ADDR_VAR 0 5
24795: PUSH
24796: LD_VAR 0 1
24800: ST_TO_ADDR
// end ;
24801: LD_VAR 0 5
24805: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24806: LD_INT 0
24808: PPUSH
24809: PPUSH
// result := 0 ;
24810: LD_ADDR_VAR 0 3
24814: PUSH
24815: LD_INT 0
24817: ST_TO_ADDR
// if not array or not value in array then
24818: LD_VAR 0 1
24822: NOT
24823: PUSH
24824: LD_VAR 0 2
24828: PUSH
24829: LD_VAR 0 1
24833: IN
24834: NOT
24835: OR
24836: IFFALSE 24840
// exit ;
24838: GO 24894
// for i = 1 to array do
24840: LD_ADDR_VAR 0 4
24844: PUSH
24845: DOUBLE
24846: LD_INT 1
24848: DEC
24849: ST_TO_ADDR
24850: LD_VAR 0 1
24854: PUSH
24855: FOR_TO
24856: IFFALSE 24892
// if value = array [ i ] then
24858: LD_VAR 0 2
24862: PUSH
24863: LD_VAR 0 1
24867: PUSH
24868: LD_VAR 0 4
24872: ARRAY
24873: EQUAL
24874: IFFALSE 24890
// begin result := i ;
24876: LD_ADDR_VAR 0 3
24880: PUSH
24881: LD_VAR 0 4
24885: ST_TO_ADDR
// exit ;
24886: POP
24887: POP
24888: GO 24894
// end ;
24890: GO 24855
24892: POP
24893: POP
// end ;
24894: LD_VAR 0 3
24898: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24899: LD_INT 0
24901: PPUSH
// vc_chassis := chassis ;
24902: LD_ADDR_OWVAR 37
24906: PUSH
24907: LD_VAR 0 1
24911: ST_TO_ADDR
// vc_engine := engine ;
24912: LD_ADDR_OWVAR 39
24916: PUSH
24917: LD_VAR 0 2
24921: ST_TO_ADDR
// vc_control := control ;
24922: LD_ADDR_OWVAR 38
24926: PUSH
24927: LD_VAR 0 3
24931: ST_TO_ADDR
// vc_weapon := weapon ;
24932: LD_ADDR_OWVAR 40
24936: PUSH
24937: LD_VAR 0 4
24941: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24942: LD_ADDR_OWVAR 41
24946: PUSH
24947: LD_VAR 0 5
24951: ST_TO_ADDR
// end ;
24952: LD_VAR 0 6
24956: RET
// export function WantPlant ( unit ) ; var task ; begin
24957: LD_INT 0
24959: PPUSH
24960: PPUSH
// result := false ;
24961: LD_ADDR_VAR 0 2
24965: PUSH
24966: LD_INT 0
24968: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24969: LD_ADDR_VAR 0 3
24973: PUSH
24974: LD_VAR 0 1
24978: PPUSH
24979: CALL_OW 437
24983: ST_TO_ADDR
// if task then
24984: LD_VAR 0 3
24988: IFFALSE 25016
// if task [ 1 ] [ 1 ] = p then
24990: LD_VAR 0 3
24994: PUSH
24995: LD_INT 1
24997: ARRAY
24998: PUSH
24999: LD_INT 1
25001: ARRAY
25002: PUSH
25003: LD_STRING p
25005: EQUAL
25006: IFFALSE 25016
// result := true ;
25008: LD_ADDR_VAR 0 2
25012: PUSH
25013: LD_INT 1
25015: ST_TO_ADDR
// end ;
25016: LD_VAR 0 2
25020: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
25021: LD_INT 0
25023: PPUSH
25024: PPUSH
25025: PPUSH
25026: PPUSH
// if pos < 1 then
25027: LD_VAR 0 2
25031: PUSH
25032: LD_INT 1
25034: LESS
25035: IFFALSE 25039
// exit ;
25037: GO 25342
// if pos = 1 then
25039: LD_VAR 0 2
25043: PUSH
25044: LD_INT 1
25046: EQUAL
25047: IFFALSE 25080
// result := Replace ( arr , pos [ 1 ] , value ) else
25049: LD_ADDR_VAR 0 4
25053: PUSH
25054: LD_VAR 0 1
25058: PPUSH
25059: LD_VAR 0 2
25063: PUSH
25064: LD_INT 1
25066: ARRAY
25067: PPUSH
25068: LD_VAR 0 3
25072: PPUSH
25073: CALL_OW 1
25077: ST_TO_ADDR
25078: GO 25342
// begin tmp := arr ;
25080: LD_ADDR_VAR 0 6
25084: PUSH
25085: LD_VAR 0 1
25089: ST_TO_ADDR
// s_arr := [ tmp ] ;
25090: LD_ADDR_VAR 0 7
25094: PUSH
25095: LD_VAR 0 6
25099: PUSH
25100: EMPTY
25101: LIST
25102: ST_TO_ADDR
// for i = 1 to pos - 1 do
25103: LD_ADDR_VAR 0 5
25107: PUSH
25108: DOUBLE
25109: LD_INT 1
25111: DEC
25112: ST_TO_ADDR
25113: LD_VAR 0 2
25117: PUSH
25118: LD_INT 1
25120: MINUS
25121: PUSH
25122: FOR_TO
25123: IFFALSE 25168
// begin tmp := tmp [ pos [ i ] ] ;
25125: LD_ADDR_VAR 0 6
25129: PUSH
25130: LD_VAR 0 6
25134: PUSH
25135: LD_VAR 0 2
25139: PUSH
25140: LD_VAR 0 5
25144: ARRAY
25145: ARRAY
25146: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
25147: LD_ADDR_VAR 0 7
25151: PUSH
25152: LD_VAR 0 7
25156: PUSH
25157: LD_VAR 0 6
25161: PUSH
25162: EMPTY
25163: LIST
25164: ADD
25165: ST_TO_ADDR
// end ;
25166: GO 25122
25168: POP
25169: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
25170: LD_ADDR_VAR 0 6
25174: PUSH
25175: LD_VAR 0 6
25179: PPUSH
25180: LD_VAR 0 2
25184: PUSH
25185: LD_VAR 0 2
25189: ARRAY
25190: PPUSH
25191: LD_VAR 0 3
25195: PPUSH
25196: CALL_OW 1
25200: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25201: LD_ADDR_VAR 0 7
25205: PUSH
25206: LD_VAR 0 7
25210: PPUSH
25211: LD_VAR 0 7
25215: PPUSH
25216: LD_VAR 0 6
25220: PPUSH
25221: CALL_OW 1
25225: ST_TO_ADDR
// for i = s_arr downto 2 do
25226: LD_ADDR_VAR 0 5
25230: PUSH
25231: DOUBLE
25232: LD_VAR 0 7
25236: INC
25237: ST_TO_ADDR
25238: LD_INT 2
25240: PUSH
25241: FOR_DOWNTO
25242: IFFALSE 25326
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 7
25253: PUSH
25254: LD_VAR 0 5
25258: PUSH
25259: LD_INT 1
25261: MINUS
25262: ARRAY
25263: PPUSH
25264: LD_VAR 0 2
25268: PUSH
25269: LD_VAR 0 5
25273: PUSH
25274: LD_INT 1
25276: MINUS
25277: ARRAY
25278: PPUSH
25279: LD_VAR 0 7
25283: PUSH
25284: LD_VAR 0 5
25288: ARRAY
25289: PPUSH
25290: CALL_OW 1
25294: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25295: LD_ADDR_VAR 0 7
25299: PUSH
25300: LD_VAR 0 7
25304: PPUSH
25305: LD_VAR 0 5
25309: PUSH
25310: LD_INT 1
25312: MINUS
25313: PPUSH
25314: LD_VAR 0 6
25318: PPUSH
25319: CALL_OW 1
25323: ST_TO_ADDR
// end ;
25324: GO 25241
25326: POP
25327: POP
// result := s_arr [ 1 ] ;
25328: LD_ADDR_VAR 0 4
25332: PUSH
25333: LD_VAR 0 7
25337: PUSH
25338: LD_INT 1
25340: ARRAY
25341: ST_TO_ADDR
// end ; end ;
25342: LD_VAR 0 4
25346: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25347: LD_INT 0
25349: PPUSH
25350: PPUSH
// if not list then
25351: LD_VAR 0 1
25355: NOT
25356: IFFALSE 25360
// exit ;
25358: GO 25451
// i := list [ pos1 ] ;
25360: LD_ADDR_VAR 0 5
25364: PUSH
25365: LD_VAR 0 1
25369: PUSH
25370: LD_VAR 0 2
25374: ARRAY
25375: ST_TO_ADDR
// if not i then
25376: LD_VAR 0 5
25380: NOT
25381: IFFALSE 25385
// exit ;
25383: GO 25451
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25385: LD_ADDR_VAR 0 1
25389: PUSH
25390: LD_VAR 0 1
25394: PPUSH
25395: LD_VAR 0 2
25399: PPUSH
25400: LD_VAR 0 1
25404: PUSH
25405: LD_VAR 0 3
25409: ARRAY
25410: PPUSH
25411: CALL_OW 1
25415: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25416: LD_ADDR_VAR 0 1
25420: PUSH
25421: LD_VAR 0 1
25425: PPUSH
25426: LD_VAR 0 3
25430: PPUSH
25431: LD_VAR 0 5
25435: PPUSH
25436: CALL_OW 1
25440: ST_TO_ADDR
// result := list ;
25441: LD_ADDR_VAR 0 4
25445: PUSH
25446: LD_VAR 0 1
25450: ST_TO_ADDR
// end ;
25451: LD_VAR 0 4
25455: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25456: LD_INT 0
25458: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25459: LD_ADDR_VAR 0 5
25463: PUSH
25464: LD_VAR 0 1
25468: PPUSH
25469: CALL_OW 250
25473: PPUSH
25474: LD_VAR 0 1
25478: PPUSH
25479: CALL_OW 251
25483: PPUSH
25484: LD_VAR 0 2
25488: PPUSH
25489: LD_VAR 0 3
25493: PPUSH
25494: LD_VAR 0 4
25498: PPUSH
25499: CALL 25509 0 5
25503: ST_TO_ADDR
// end ;
25504: LD_VAR 0 5
25508: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25509: LD_INT 0
25511: PPUSH
25512: PPUSH
25513: PPUSH
25514: PPUSH
// if not list then
25515: LD_VAR 0 3
25519: NOT
25520: IFFALSE 25524
// exit ;
25522: GO 25912
// result := [ ] ;
25524: LD_ADDR_VAR 0 6
25528: PUSH
25529: EMPTY
25530: ST_TO_ADDR
// for i in list do
25531: LD_ADDR_VAR 0 7
25535: PUSH
25536: LD_VAR 0 3
25540: PUSH
25541: FOR_IN
25542: IFFALSE 25744
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25544: LD_ADDR_VAR 0 9
25548: PUSH
25549: LD_VAR 0 7
25553: PPUSH
25554: LD_VAR 0 1
25558: PPUSH
25559: LD_VAR 0 2
25563: PPUSH
25564: CALL_OW 297
25568: ST_TO_ADDR
// if not result then
25569: LD_VAR 0 6
25573: NOT
25574: IFFALSE 25600
// result := [ [ i , tmp ] ] else
25576: LD_ADDR_VAR 0 6
25580: PUSH
25581: LD_VAR 0 7
25585: PUSH
25586: LD_VAR 0 9
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: PUSH
25595: EMPTY
25596: LIST
25597: ST_TO_ADDR
25598: GO 25742
// begin if result [ result ] [ 2 ] < tmp then
25600: LD_VAR 0 6
25604: PUSH
25605: LD_VAR 0 6
25609: ARRAY
25610: PUSH
25611: LD_INT 2
25613: ARRAY
25614: PUSH
25615: LD_VAR 0 9
25619: LESS
25620: IFFALSE 25662
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25622: LD_ADDR_VAR 0 6
25626: PUSH
25627: LD_VAR 0 6
25631: PPUSH
25632: LD_VAR 0 6
25636: PUSH
25637: LD_INT 1
25639: PLUS
25640: PPUSH
25641: LD_VAR 0 7
25645: PUSH
25646: LD_VAR 0 9
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PPUSH
25655: CALL_OW 2
25659: ST_TO_ADDR
25660: GO 25742
// for j = 1 to result do
25662: LD_ADDR_VAR 0 8
25666: PUSH
25667: DOUBLE
25668: LD_INT 1
25670: DEC
25671: ST_TO_ADDR
25672: LD_VAR 0 6
25676: PUSH
25677: FOR_TO
25678: IFFALSE 25740
// begin if tmp < result [ j ] [ 2 ] then
25680: LD_VAR 0 9
25684: PUSH
25685: LD_VAR 0 6
25689: PUSH
25690: LD_VAR 0 8
25694: ARRAY
25695: PUSH
25696: LD_INT 2
25698: ARRAY
25699: LESS
25700: IFFALSE 25738
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25702: LD_ADDR_VAR 0 6
25706: PUSH
25707: LD_VAR 0 6
25711: PPUSH
25712: LD_VAR 0 8
25716: PPUSH
25717: LD_VAR 0 7
25721: PUSH
25722: LD_VAR 0 9
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PPUSH
25731: CALL_OW 2
25735: ST_TO_ADDR
// break ;
25736: GO 25740
// end ; end ;
25738: GO 25677
25740: POP
25741: POP
// end ; end ;
25742: GO 25541
25744: POP
25745: POP
// if result and not asc then
25746: LD_VAR 0 6
25750: PUSH
25751: LD_VAR 0 4
25755: NOT
25756: AND
25757: IFFALSE 25832
// begin tmp := result ;
25759: LD_ADDR_VAR 0 9
25763: PUSH
25764: LD_VAR 0 6
25768: ST_TO_ADDR
// for i = tmp downto 1 do
25769: LD_ADDR_VAR 0 7
25773: PUSH
25774: DOUBLE
25775: LD_VAR 0 9
25779: INC
25780: ST_TO_ADDR
25781: LD_INT 1
25783: PUSH
25784: FOR_DOWNTO
25785: IFFALSE 25830
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25787: LD_ADDR_VAR 0 6
25791: PUSH
25792: LD_VAR 0 6
25796: PPUSH
25797: LD_VAR 0 9
25801: PUSH
25802: LD_VAR 0 7
25806: MINUS
25807: PUSH
25808: LD_INT 1
25810: PLUS
25811: PPUSH
25812: LD_VAR 0 9
25816: PUSH
25817: LD_VAR 0 7
25821: ARRAY
25822: PPUSH
25823: CALL_OW 1
25827: ST_TO_ADDR
25828: GO 25784
25830: POP
25831: POP
// end ; tmp := [ ] ;
25832: LD_ADDR_VAR 0 9
25836: PUSH
25837: EMPTY
25838: ST_TO_ADDR
// if mode then
25839: LD_VAR 0 5
25843: IFFALSE 25912
// begin for i = 1 to result do
25845: LD_ADDR_VAR 0 7
25849: PUSH
25850: DOUBLE
25851: LD_INT 1
25853: DEC
25854: ST_TO_ADDR
25855: LD_VAR 0 6
25859: PUSH
25860: FOR_TO
25861: IFFALSE 25900
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25863: LD_ADDR_VAR 0 9
25867: PUSH
25868: LD_VAR 0 9
25872: PPUSH
25873: LD_VAR 0 7
25877: PPUSH
25878: LD_VAR 0 6
25882: PUSH
25883: LD_VAR 0 7
25887: ARRAY
25888: PUSH
25889: LD_INT 1
25891: ARRAY
25892: PPUSH
25893: CALL_OW 1
25897: ST_TO_ADDR
25898: GO 25860
25900: POP
25901: POP
// result := tmp ;
25902: LD_ADDR_VAR 0 6
25906: PUSH
25907: LD_VAR 0 9
25911: ST_TO_ADDR
// end ; end ;
25912: LD_VAR 0 6
25916: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25917: LD_INT 0
25919: PPUSH
25920: PPUSH
25921: PPUSH
25922: PPUSH
25923: PPUSH
25924: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25925: LD_ADDR_VAR 0 5
25929: PUSH
25930: LD_INT 0
25932: PUSH
25933: LD_INT 0
25935: PUSH
25936: LD_INT 0
25938: PUSH
25939: EMPTY
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: ST_TO_ADDR
// if not x or not y then
25947: LD_VAR 0 2
25951: NOT
25952: PUSH
25953: LD_VAR 0 3
25957: NOT
25958: OR
25959: IFFALSE 25963
// exit ;
25961: GO 27613
// if not range then
25963: LD_VAR 0 4
25967: NOT
25968: IFFALSE 25978
// range := 10 ;
25970: LD_ADDR_VAR 0 4
25974: PUSH
25975: LD_INT 10
25977: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25978: LD_ADDR_VAR 0 8
25982: PUSH
25983: LD_INT 81
25985: PUSH
25986: LD_VAR 0 1
25990: PUSH
25991: EMPTY
25992: LIST
25993: LIST
25994: PUSH
25995: LD_INT 92
25997: PUSH
25998: LD_VAR 0 2
26002: PUSH
26003: LD_VAR 0 3
26007: PUSH
26008: LD_VAR 0 4
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 3
26021: PUSH
26022: LD_INT 21
26024: PUSH
26025: LD_INT 3
26027: PUSH
26028: EMPTY
26029: LIST
26030: LIST
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: LIST
26040: PPUSH
26041: CALL_OW 69
26045: ST_TO_ADDR
// if not tmp then
26046: LD_VAR 0 8
26050: NOT
26051: IFFALSE 26055
// exit ;
26053: GO 27613
// for i in tmp do
26055: LD_ADDR_VAR 0 6
26059: PUSH
26060: LD_VAR 0 8
26064: PUSH
26065: FOR_IN
26066: IFFALSE 27588
// begin points := [ 0 , 0 , 0 ] ;
26068: LD_ADDR_VAR 0 9
26072: PUSH
26073: LD_INT 0
26075: PUSH
26076: LD_INT 0
26078: PUSH
26079: LD_INT 0
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: LIST
26086: ST_TO_ADDR
// bpoints := 1 ;
26087: LD_ADDR_VAR 0 10
26091: PUSH
26092: LD_INT 1
26094: ST_TO_ADDR
// case GetType ( i ) of unit_human :
26095: LD_VAR 0 6
26099: PPUSH
26100: CALL_OW 247
26104: PUSH
26105: LD_INT 1
26107: DOUBLE
26108: EQUAL
26109: IFTRUE 26113
26111: GO 26691
26113: POP
// begin if GetClass ( i ) = 1 then
26114: LD_VAR 0 6
26118: PPUSH
26119: CALL_OW 257
26123: PUSH
26124: LD_INT 1
26126: EQUAL
26127: IFFALSE 26148
// points := [ 10 , 5 , 3 ] ;
26129: LD_ADDR_VAR 0 9
26133: PUSH
26134: LD_INT 10
26136: PUSH
26137: LD_INT 5
26139: PUSH
26140: LD_INT 3
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: LIST
26147: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
26148: LD_VAR 0 6
26152: PPUSH
26153: CALL_OW 257
26157: PUSH
26158: LD_INT 2
26160: PUSH
26161: LD_INT 3
26163: PUSH
26164: LD_INT 4
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: LIST
26171: IN
26172: IFFALSE 26193
// points := [ 3 , 2 , 1 ] ;
26174: LD_ADDR_VAR 0 9
26178: PUSH
26179: LD_INT 3
26181: PUSH
26182: LD_INT 2
26184: PUSH
26185: LD_INT 1
26187: PUSH
26188: EMPTY
26189: LIST
26190: LIST
26191: LIST
26192: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26193: LD_VAR 0 6
26197: PPUSH
26198: CALL_OW 257
26202: PUSH
26203: LD_INT 5
26205: EQUAL
26206: IFFALSE 26227
// points := [ 130 , 5 , 2 ] ;
26208: LD_ADDR_VAR 0 9
26212: PUSH
26213: LD_INT 130
26215: PUSH
26216: LD_INT 5
26218: PUSH
26219: LD_INT 2
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: LIST
26226: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26227: LD_VAR 0 6
26231: PPUSH
26232: CALL_OW 257
26236: PUSH
26237: LD_INT 8
26239: EQUAL
26240: IFFALSE 26261
// points := [ 35 , 35 , 30 ] ;
26242: LD_ADDR_VAR 0 9
26246: PUSH
26247: LD_INT 35
26249: PUSH
26250: LD_INT 35
26252: PUSH
26253: LD_INT 30
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: LIST
26260: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26261: LD_VAR 0 6
26265: PPUSH
26266: CALL_OW 257
26270: PUSH
26271: LD_INT 9
26273: EQUAL
26274: IFFALSE 26295
// points := [ 20 , 55 , 40 ] ;
26276: LD_ADDR_VAR 0 9
26280: PUSH
26281: LD_INT 20
26283: PUSH
26284: LD_INT 55
26286: PUSH
26287: LD_INT 40
26289: PUSH
26290: EMPTY
26291: LIST
26292: LIST
26293: LIST
26294: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26295: LD_VAR 0 6
26299: PPUSH
26300: CALL_OW 257
26304: PUSH
26305: LD_INT 12
26307: PUSH
26308: LD_INT 16
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: IN
26315: IFFALSE 26336
// points := [ 5 , 3 , 2 ] ;
26317: LD_ADDR_VAR 0 9
26321: PUSH
26322: LD_INT 5
26324: PUSH
26325: LD_INT 3
26327: PUSH
26328: LD_INT 2
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26336: LD_VAR 0 6
26340: PPUSH
26341: CALL_OW 257
26345: PUSH
26346: LD_INT 17
26348: EQUAL
26349: IFFALSE 26370
// points := [ 100 , 50 , 75 ] ;
26351: LD_ADDR_VAR 0 9
26355: PUSH
26356: LD_INT 100
26358: PUSH
26359: LD_INT 50
26361: PUSH
26362: LD_INT 75
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: LIST
26369: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26370: LD_VAR 0 6
26374: PPUSH
26375: CALL_OW 257
26379: PUSH
26380: LD_INT 15
26382: EQUAL
26383: IFFALSE 26404
// points := [ 10 , 5 , 3 ] ;
26385: LD_ADDR_VAR 0 9
26389: PUSH
26390: LD_INT 10
26392: PUSH
26393: LD_INT 5
26395: PUSH
26396: LD_INT 3
26398: PUSH
26399: EMPTY
26400: LIST
26401: LIST
26402: LIST
26403: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26404: LD_VAR 0 6
26408: PPUSH
26409: CALL_OW 257
26413: PUSH
26414: LD_INT 14
26416: EQUAL
26417: IFFALSE 26438
// points := [ 10 , 0 , 0 ] ;
26419: LD_ADDR_VAR 0 9
26423: PUSH
26424: LD_INT 10
26426: PUSH
26427: LD_INT 0
26429: PUSH
26430: LD_INT 0
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: LIST
26437: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 257
26447: PUSH
26448: LD_INT 11
26450: EQUAL
26451: IFFALSE 26472
// points := [ 30 , 10 , 5 ] ;
26453: LD_ADDR_VAR 0 9
26457: PUSH
26458: LD_INT 30
26460: PUSH
26461: LD_INT 10
26463: PUSH
26464: LD_INT 5
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: LIST
26471: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26472: LD_VAR 0 1
26476: PPUSH
26477: LD_INT 5
26479: PPUSH
26480: CALL_OW 321
26484: PUSH
26485: LD_INT 2
26487: EQUAL
26488: IFFALSE 26505
// bpoints := bpoints * 1.8 ;
26490: LD_ADDR_VAR 0 10
26494: PUSH
26495: LD_VAR 0 10
26499: PUSH
26500: LD_REAL  1.80000000000000E+0000
26503: MUL
26504: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26505: LD_VAR 0 6
26509: PPUSH
26510: CALL_OW 257
26514: PUSH
26515: LD_INT 1
26517: PUSH
26518: LD_INT 2
26520: PUSH
26521: LD_INT 3
26523: PUSH
26524: LD_INT 4
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: LIST
26531: LIST
26532: IN
26533: PUSH
26534: LD_VAR 0 1
26538: PPUSH
26539: LD_INT 51
26541: PPUSH
26542: CALL_OW 321
26546: PUSH
26547: LD_INT 2
26549: EQUAL
26550: AND
26551: IFFALSE 26568
// bpoints := bpoints * 1.2 ;
26553: LD_ADDR_VAR 0 10
26557: PUSH
26558: LD_VAR 0 10
26562: PUSH
26563: LD_REAL  1.20000000000000E+0000
26566: MUL
26567: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26568: LD_VAR 0 6
26572: PPUSH
26573: CALL_OW 257
26577: PUSH
26578: LD_INT 5
26580: PUSH
26581: LD_INT 7
26583: PUSH
26584: LD_INT 9
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: LIST
26591: IN
26592: PUSH
26593: LD_VAR 0 1
26597: PPUSH
26598: LD_INT 52
26600: PPUSH
26601: CALL_OW 321
26605: PUSH
26606: LD_INT 2
26608: EQUAL
26609: AND
26610: IFFALSE 26627
// bpoints := bpoints * 1.5 ;
26612: LD_ADDR_VAR 0 10
26616: PUSH
26617: LD_VAR 0 10
26621: PUSH
26622: LD_REAL  1.50000000000000E+0000
26625: MUL
26626: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26627: LD_VAR 0 1
26631: PPUSH
26632: LD_INT 66
26634: PPUSH
26635: CALL_OW 321
26639: PUSH
26640: LD_INT 2
26642: EQUAL
26643: IFFALSE 26660
// bpoints := bpoints * 1.1 ;
26645: LD_ADDR_VAR 0 10
26649: PUSH
26650: LD_VAR 0 10
26654: PUSH
26655: LD_REAL  1.10000000000000E+0000
26658: MUL
26659: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26660: LD_ADDR_VAR 0 10
26664: PUSH
26665: LD_VAR 0 10
26669: PUSH
26670: LD_VAR 0 6
26674: PPUSH
26675: LD_INT 1
26677: PPUSH
26678: CALL_OW 259
26682: PUSH
26683: LD_REAL  1.15000000000000E+0000
26686: MUL
26687: MUL
26688: ST_TO_ADDR
// end ; unit_vehicle :
26689: GO 27517
26691: LD_INT 2
26693: DOUBLE
26694: EQUAL
26695: IFTRUE 26699
26697: GO 27505
26699: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26700: LD_VAR 0 6
26704: PPUSH
26705: CALL_OW 264
26709: PUSH
26710: LD_INT 2
26712: PUSH
26713: LD_INT 42
26715: PUSH
26716: LD_INT 24
26718: PUSH
26719: EMPTY
26720: LIST
26721: LIST
26722: LIST
26723: IN
26724: IFFALSE 26745
// points := [ 25 , 5 , 3 ] ;
26726: LD_ADDR_VAR 0 9
26730: PUSH
26731: LD_INT 25
26733: PUSH
26734: LD_INT 5
26736: PUSH
26737: LD_INT 3
26739: PUSH
26740: EMPTY
26741: LIST
26742: LIST
26743: LIST
26744: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26745: LD_VAR 0 6
26749: PPUSH
26750: CALL_OW 264
26754: PUSH
26755: LD_INT 4
26757: PUSH
26758: LD_INT 43
26760: PUSH
26761: LD_INT 25
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: IN
26769: IFFALSE 26790
// points := [ 40 , 15 , 5 ] ;
26771: LD_ADDR_VAR 0 9
26775: PUSH
26776: LD_INT 40
26778: PUSH
26779: LD_INT 15
26781: PUSH
26782: LD_INT 5
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: LIST
26789: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26790: LD_VAR 0 6
26794: PPUSH
26795: CALL_OW 264
26799: PUSH
26800: LD_INT 3
26802: PUSH
26803: LD_INT 23
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: IN
26810: IFFALSE 26831
// points := [ 7 , 25 , 8 ] ;
26812: LD_ADDR_VAR 0 9
26816: PUSH
26817: LD_INT 7
26819: PUSH
26820: LD_INT 25
26822: PUSH
26823: LD_INT 8
26825: PUSH
26826: EMPTY
26827: LIST
26828: LIST
26829: LIST
26830: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26831: LD_VAR 0 6
26835: PPUSH
26836: CALL_OW 264
26840: PUSH
26841: LD_INT 5
26843: PUSH
26844: LD_INT 27
26846: PUSH
26847: LD_INT 44
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: LIST
26854: IN
26855: IFFALSE 26876
// points := [ 14 , 50 , 16 ] ;
26857: LD_ADDR_VAR 0 9
26861: PUSH
26862: LD_INT 14
26864: PUSH
26865: LD_INT 50
26867: PUSH
26868: LD_INT 16
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: LIST
26875: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26876: LD_VAR 0 6
26880: PPUSH
26881: CALL_OW 264
26885: PUSH
26886: LD_INT 6
26888: PUSH
26889: LD_INT 46
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: IN
26896: IFFALSE 26917
// points := [ 32 , 120 , 70 ] ;
26898: LD_ADDR_VAR 0 9
26902: PUSH
26903: LD_INT 32
26905: PUSH
26906: LD_INT 120
26908: PUSH
26909: LD_INT 70
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: LIST
26916: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26917: LD_VAR 0 6
26921: PPUSH
26922: CALL_OW 264
26926: PUSH
26927: LD_INT 7
26929: PUSH
26930: LD_INT 28
26932: PUSH
26933: LD_INT 45
26935: PUSH
26936: LD_INT 92
26938: PUSH
26939: EMPTY
26940: LIST
26941: LIST
26942: LIST
26943: LIST
26944: IN
26945: IFFALSE 26966
// points := [ 35 , 20 , 45 ] ;
26947: LD_ADDR_VAR 0 9
26951: PUSH
26952: LD_INT 35
26954: PUSH
26955: LD_INT 20
26957: PUSH
26958: LD_INT 45
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: LIST
26965: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26966: LD_VAR 0 6
26970: PPUSH
26971: CALL_OW 264
26975: PUSH
26976: LD_INT 47
26978: PUSH
26979: EMPTY
26980: LIST
26981: IN
26982: IFFALSE 27003
// points := [ 67 , 45 , 75 ] ;
26984: LD_ADDR_VAR 0 9
26988: PUSH
26989: LD_INT 67
26991: PUSH
26992: LD_INT 45
26994: PUSH
26995: LD_INT 75
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: LIST
27002: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
27003: LD_VAR 0 6
27007: PPUSH
27008: CALL_OW 264
27012: PUSH
27013: LD_INT 26
27015: PUSH
27016: EMPTY
27017: LIST
27018: IN
27019: IFFALSE 27040
// points := [ 120 , 30 , 80 ] ;
27021: LD_ADDR_VAR 0 9
27025: PUSH
27026: LD_INT 120
27028: PUSH
27029: LD_INT 30
27031: PUSH
27032: LD_INT 80
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: LIST
27039: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
27040: LD_VAR 0 6
27044: PPUSH
27045: CALL_OW 264
27049: PUSH
27050: LD_INT 22
27052: PUSH
27053: EMPTY
27054: LIST
27055: IN
27056: IFFALSE 27077
// points := [ 40 , 1 , 1 ] ;
27058: LD_ADDR_VAR 0 9
27062: PUSH
27063: LD_INT 40
27065: PUSH
27066: LD_INT 1
27068: PUSH
27069: LD_INT 1
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: LIST
27076: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
27077: LD_VAR 0 6
27081: PPUSH
27082: CALL_OW 264
27086: PUSH
27087: LD_INT 29
27089: PUSH
27090: EMPTY
27091: LIST
27092: IN
27093: IFFALSE 27114
// points := [ 70 , 200 , 400 ] ;
27095: LD_ADDR_VAR 0 9
27099: PUSH
27100: LD_INT 70
27102: PUSH
27103: LD_INT 200
27105: PUSH
27106: LD_INT 400
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: LIST
27113: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
27114: LD_VAR 0 6
27118: PPUSH
27119: CALL_OW 264
27123: PUSH
27124: LD_INT 14
27126: PUSH
27127: LD_INT 53
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: IN
27134: IFFALSE 27155
// points := [ 40 , 10 , 20 ] ;
27136: LD_ADDR_VAR 0 9
27140: PUSH
27141: LD_INT 40
27143: PUSH
27144: LD_INT 10
27146: PUSH
27147: LD_INT 20
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: LIST
27154: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
27155: LD_VAR 0 6
27159: PPUSH
27160: CALL_OW 264
27164: PUSH
27165: LD_INT 9
27167: PUSH
27168: EMPTY
27169: LIST
27170: IN
27171: IFFALSE 27192
// points := [ 5 , 70 , 20 ] ;
27173: LD_ADDR_VAR 0 9
27177: PUSH
27178: LD_INT 5
27180: PUSH
27181: LD_INT 70
27183: PUSH
27184: LD_INT 20
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: LIST
27191: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27192: LD_VAR 0 6
27196: PPUSH
27197: CALL_OW 264
27201: PUSH
27202: LD_INT 10
27204: PUSH
27205: EMPTY
27206: LIST
27207: IN
27208: IFFALSE 27229
// points := [ 35 , 110 , 70 ] ;
27210: LD_ADDR_VAR 0 9
27214: PUSH
27215: LD_INT 35
27217: PUSH
27218: LD_INT 110
27220: PUSH
27221: LD_INT 70
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: LIST
27228: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27229: LD_VAR 0 6
27233: PPUSH
27234: CALL_OW 265
27238: PUSH
27239: LD_INT 25
27241: EQUAL
27242: IFFALSE 27263
// points := [ 80 , 65 , 100 ] ;
27244: LD_ADDR_VAR 0 9
27248: PUSH
27249: LD_INT 80
27251: PUSH
27252: LD_INT 65
27254: PUSH
27255: LD_INT 100
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: LIST
27262: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27263: LD_VAR 0 6
27267: PPUSH
27268: CALL_OW 263
27272: PUSH
27273: LD_INT 1
27275: EQUAL
27276: IFFALSE 27311
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27278: LD_ADDR_VAR 0 10
27282: PUSH
27283: LD_VAR 0 10
27287: PUSH
27288: LD_VAR 0 6
27292: PPUSH
27293: CALL_OW 311
27297: PPUSH
27298: LD_INT 3
27300: PPUSH
27301: CALL_OW 259
27305: PUSH
27306: LD_INT 4
27308: MUL
27309: MUL
27310: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27311: LD_VAR 0 6
27315: PPUSH
27316: CALL_OW 263
27320: PUSH
27321: LD_INT 2
27323: EQUAL
27324: IFFALSE 27375
// begin j := IsControledBy ( i ) ;
27326: LD_ADDR_VAR 0 7
27330: PUSH
27331: LD_VAR 0 6
27335: PPUSH
27336: CALL_OW 312
27340: ST_TO_ADDR
// if j then
27341: LD_VAR 0 7
27345: IFFALSE 27375
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27347: LD_ADDR_VAR 0 10
27351: PUSH
27352: LD_VAR 0 10
27356: PUSH
27357: LD_VAR 0 7
27361: PPUSH
27362: LD_INT 3
27364: PPUSH
27365: CALL_OW 259
27369: PUSH
27370: LD_INT 3
27372: MUL
27373: MUL
27374: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27375: LD_VAR 0 6
27379: PPUSH
27380: CALL_OW 264
27384: PUSH
27385: LD_INT 5
27387: PUSH
27388: LD_INT 6
27390: PUSH
27391: LD_INT 46
27393: PUSH
27394: LD_INT 44
27396: PUSH
27397: LD_INT 47
27399: PUSH
27400: LD_INT 45
27402: PUSH
27403: LD_INT 28
27405: PUSH
27406: LD_INT 7
27408: PUSH
27409: LD_INT 27
27411: PUSH
27412: LD_INT 29
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: LIST
27419: LIST
27420: LIST
27421: LIST
27422: LIST
27423: LIST
27424: LIST
27425: LIST
27426: IN
27427: PUSH
27428: LD_VAR 0 1
27432: PPUSH
27433: LD_INT 52
27435: PPUSH
27436: CALL_OW 321
27440: PUSH
27441: LD_INT 2
27443: EQUAL
27444: AND
27445: IFFALSE 27462
// bpoints := bpoints * 1.2 ;
27447: LD_ADDR_VAR 0 10
27451: PUSH
27452: LD_VAR 0 10
27456: PUSH
27457: LD_REAL  1.20000000000000E+0000
27460: MUL
27461: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27462: LD_VAR 0 6
27466: PPUSH
27467: CALL_OW 264
27471: PUSH
27472: LD_INT 6
27474: PUSH
27475: LD_INT 46
27477: PUSH
27478: LD_INT 47
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: LIST
27485: IN
27486: IFFALSE 27503
// bpoints := bpoints * 1.2 ;
27488: LD_ADDR_VAR 0 10
27492: PUSH
27493: LD_VAR 0 10
27497: PUSH
27498: LD_REAL  1.20000000000000E+0000
27501: MUL
27502: ST_TO_ADDR
// end ; unit_building :
27503: GO 27517
27505: LD_INT 3
27507: DOUBLE
27508: EQUAL
27509: IFTRUE 27513
27511: GO 27516
27513: POP
// ; end ;
27514: GO 27517
27516: POP
// for j = 1 to 3 do
27517: LD_ADDR_VAR 0 7
27521: PUSH
27522: DOUBLE
27523: LD_INT 1
27525: DEC
27526: ST_TO_ADDR
27527: LD_INT 3
27529: PUSH
27530: FOR_TO
27531: IFFALSE 27584
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27533: LD_ADDR_VAR 0 5
27537: PUSH
27538: LD_VAR 0 5
27542: PPUSH
27543: LD_VAR 0 7
27547: PPUSH
27548: LD_VAR 0 5
27552: PUSH
27553: LD_VAR 0 7
27557: ARRAY
27558: PUSH
27559: LD_VAR 0 9
27563: PUSH
27564: LD_VAR 0 7
27568: ARRAY
27569: PUSH
27570: LD_VAR 0 10
27574: MUL
27575: PLUS
27576: PPUSH
27577: CALL_OW 1
27581: ST_TO_ADDR
27582: GO 27530
27584: POP
27585: POP
// end ;
27586: GO 26065
27588: POP
27589: POP
// result := Replace ( result , 4 , tmp ) ;
27590: LD_ADDR_VAR 0 5
27594: PUSH
27595: LD_VAR 0 5
27599: PPUSH
27600: LD_INT 4
27602: PPUSH
27603: LD_VAR 0 8
27607: PPUSH
27608: CALL_OW 1
27612: ST_TO_ADDR
// end ;
27613: LD_VAR 0 5
27617: RET
// export function DangerAtRange ( unit , range ) ; begin
27618: LD_INT 0
27620: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27621: LD_ADDR_VAR 0 3
27625: PUSH
27626: LD_VAR 0 1
27630: PPUSH
27631: CALL_OW 255
27635: PPUSH
27636: LD_VAR 0 1
27640: PPUSH
27641: CALL_OW 250
27645: PPUSH
27646: LD_VAR 0 1
27650: PPUSH
27651: CALL_OW 251
27655: PPUSH
27656: LD_VAR 0 2
27660: PPUSH
27661: CALL 25917 0 4
27665: ST_TO_ADDR
// end ;
27666: LD_VAR 0 3
27670: RET
// export function DangerInArea ( side , area ) ; begin
27671: LD_INT 0
27673: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27674: LD_ADDR_VAR 0 3
27678: PUSH
27679: LD_VAR 0 2
27683: PPUSH
27684: LD_INT 81
27686: PUSH
27687: LD_VAR 0 1
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PPUSH
27696: CALL_OW 70
27700: ST_TO_ADDR
// end ;
27701: LD_VAR 0 3
27705: RET
// export function IsExtension ( b ) ; begin
27706: LD_INT 0
27708: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27709: LD_ADDR_VAR 0 2
27713: PUSH
27714: LD_VAR 0 1
27718: PUSH
27719: LD_INT 23
27721: PUSH
27722: LD_INT 20
27724: PUSH
27725: LD_INT 22
27727: PUSH
27728: LD_INT 17
27730: PUSH
27731: LD_INT 24
27733: PUSH
27734: LD_INT 21
27736: PUSH
27737: LD_INT 19
27739: PUSH
27740: LD_INT 16
27742: PUSH
27743: LD_INT 25
27745: PUSH
27746: LD_INT 18
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: LIST
27759: LIST
27760: IN
27761: ST_TO_ADDR
// end ;
27762: LD_VAR 0 2
27766: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27767: LD_INT 0
27769: PPUSH
27770: PPUSH
27771: PPUSH
// result := [ ] ;
27772: LD_ADDR_VAR 0 4
27776: PUSH
27777: EMPTY
27778: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27779: LD_ADDR_VAR 0 5
27783: PUSH
27784: LD_VAR 0 2
27788: PPUSH
27789: LD_INT 21
27791: PUSH
27792: LD_INT 3
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PPUSH
27799: CALL_OW 70
27803: ST_TO_ADDR
// if not tmp then
27804: LD_VAR 0 5
27808: NOT
27809: IFFALSE 27813
// exit ;
27811: GO 27877
// if checkLink then
27813: LD_VAR 0 3
27817: IFFALSE 27867
// begin for i in tmp do
27819: LD_ADDR_VAR 0 6
27823: PUSH
27824: LD_VAR 0 5
27828: PUSH
27829: FOR_IN
27830: IFFALSE 27865
// if GetBase ( i ) <> base then
27832: LD_VAR 0 6
27836: PPUSH
27837: CALL_OW 274
27841: PUSH
27842: LD_VAR 0 1
27846: NONEQUAL
27847: IFFALSE 27863
// ComLinkToBase ( base , i ) ;
27849: LD_VAR 0 1
27853: PPUSH
27854: LD_VAR 0 6
27858: PPUSH
27859: CALL_OW 169
27863: GO 27829
27865: POP
27866: POP
// end ; result := tmp ;
27867: LD_ADDR_VAR 0 4
27871: PUSH
27872: LD_VAR 0 5
27876: ST_TO_ADDR
// end ;
27877: LD_VAR 0 4
27881: RET
// export function ComComplete ( units , b ) ; var i ; begin
27882: LD_INT 0
27884: PPUSH
27885: PPUSH
// if not units then
27886: LD_VAR 0 1
27890: NOT
27891: IFFALSE 27895
// exit ;
27893: GO 27985
// for i in units do
27895: LD_ADDR_VAR 0 4
27899: PUSH
27900: LD_VAR 0 1
27904: PUSH
27905: FOR_IN
27906: IFFALSE 27983
// if BuildingStatus ( b ) = bs_build then
27908: LD_VAR 0 2
27912: PPUSH
27913: CALL_OW 461
27917: PUSH
27918: LD_INT 1
27920: EQUAL
27921: IFFALSE 27981
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27923: LD_VAR 0 4
27927: PPUSH
27928: LD_STRING h
27930: PUSH
27931: LD_VAR 0 2
27935: PPUSH
27936: CALL_OW 250
27940: PUSH
27941: LD_VAR 0 2
27945: PPUSH
27946: CALL_OW 251
27950: PUSH
27951: LD_VAR 0 2
27955: PUSH
27956: LD_INT 0
27958: PUSH
27959: LD_INT 0
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: LIST
27969: LIST
27970: LIST
27971: LIST
27972: LIST
27973: PUSH
27974: EMPTY
27975: LIST
27976: PPUSH
27977: CALL_OW 446
27981: GO 27905
27983: POP
27984: POP
// end ;
27985: LD_VAR 0 3
27989: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27990: LD_INT 0
27992: PPUSH
27993: PPUSH
27994: PPUSH
27995: PPUSH
27996: PPUSH
27997: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27998: LD_VAR 0 1
28002: NOT
28003: PUSH
28004: LD_VAR 0 1
28008: PPUSH
28009: CALL_OW 263
28013: PUSH
28014: LD_INT 2
28016: NONEQUAL
28017: OR
28018: IFFALSE 28022
// exit ;
28020: GO 28338
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
28022: LD_ADDR_VAR 0 6
28026: PUSH
28027: LD_INT 22
28029: PUSH
28030: LD_VAR 0 1
28034: PPUSH
28035: CALL_OW 255
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 2
28046: PUSH
28047: LD_INT 30
28049: PUSH
28050: LD_INT 36
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 34
28059: PUSH
28060: LD_INT 31
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: LIST
28070: LIST
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PPUSH
28076: CALL_OW 69
28080: ST_TO_ADDR
// if not tmp then
28081: LD_VAR 0 6
28085: NOT
28086: IFFALSE 28090
// exit ;
28088: GO 28338
// result := [ ] ;
28090: LD_ADDR_VAR 0 2
28094: PUSH
28095: EMPTY
28096: ST_TO_ADDR
// for i in tmp do
28097: LD_ADDR_VAR 0 3
28101: PUSH
28102: LD_VAR 0 6
28106: PUSH
28107: FOR_IN
28108: IFFALSE 28179
// begin t := UnitsInside ( i ) ;
28110: LD_ADDR_VAR 0 4
28114: PUSH
28115: LD_VAR 0 3
28119: PPUSH
28120: CALL_OW 313
28124: ST_TO_ADDR
// if t then
28125: LD_VAR 0 4
28129: IFFALSE 28177
// for j in t do
28131: LD_ADDR_VAR 0 7
28135: PUSH
28136: LD_VAR 0 4
28140: PUSH
28141: FOR_IN
28142: IFFALSE 28175
// result := Replace ( result , result + 1 , j ) ;
28144: LD_ADDR_VAR 0 2
28148: PUSH
28149: LD_VAR 0 2
28153: PPUSH
28154: LD_VAR 0 2
28158: PUSH
28159: LD_INT 1
28161: PLUS
28162: PPUSH
28163: LD_VAR 0 7
28167: PPUSH
28168: CALL_OW 1
28172: ST_TO_ADDR
28173: GO 28141
28175: POP
28176: POP
// end ;
28177: GO 28107
28179: POP
28180: POP
// if not result then
28181: LD_VAR 0 2
28185: NOT
28186: IFFALSE 28190
// exit ;
28188: GO 28338
// mech := result [ 1 ] ;
28190: LD_ADDR_VAR 0 5
28194: PUSH
28195: LD_VAR 0 2
28199: PUSH
28200: LD_INT 1
28202: ARRAY
28203: ST_TO_ADDR
// if result > 1 then
28204: LD_VAR 0 2
28208: PUSH
28209: LD_INT 1
28211: GREATER
28212: IFFALSE 28324
// begin for i = 2 to result do
28214: LD_ADDR_VAR 0 3
28218: PUSH
28219: DOUBLE
28220: LD_INT 2
28222: DEC
28223: ST_TO_ADDR
28224: LD_VAR 0 2
28228: PUSH
28229: FOR_TO
28230: IFFALSE 28322
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28232: LD_ADDR_VAR 0 4
28236: PUSH
28237: LD_VAR 0 2
28241: PUSH
28242: LD_VAR 0 3
28246: ARRAY
28247: PPUSH
28248: LD_INT 3
28250: PPUSH
28251: CALL_OW 259
28255: PUSH
28256: LD_VAR 0 2
28260: PUSH
28261: LD_VAR 0 3
28265: ARRAY
28266: PPUSH
28267: CALL_OW 432
28271: MINUS
28272: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28273: LD_VAR 0 4
28277: PUSH
28278: LD_VAR 0 5
28282: PPUSH
28283: LD_INT 3
28285: PPUSH
28286: CALL_OW 259
28290: PUSH
28291: LD_VAR 0 5
28295: PPUSH
28296: CALL_OW 432
28300: MINUS
28301: GREATEREQUAL
28302: IFFALSE 28320
// mech := result [ i ] ;
28304: LD_ADDR_VAR 0 5
28308: PUSH
28309: LD_VAR 0 2
28313: PUSH
28314: LD_VAR 0 3
28318: ARRAY
28319: ST_TO_ADDR
// end ;
28320: GO 28229
28322: POP
28323: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28324: LD_VAR 0 1
28328: PPUSH
28329: LD_VAR 0 5
28333: PPUSH
28334: CALL_OW 135
// end ;
28338: LD_VAR 0 2
28342: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28343: LD_INT 0
28345: PPUSH
28346: PPUSH
28347: PPUSH
28348: PPUSH
28349: PPUSH
28350: PPUSH
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
28356: PPUSH
28357: PPUSH
// result := [ ] ;
28358: LD_ADDR_VAR 0 7
28362: PUSH
28363: EMPTY
28364: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28365: LD_VAR 0 1
28369: PPUSH
28370: CALL_OW 266
28374: PUSH
28375: LD_INT 0
28377: PUSH
28378: LD_INT 1
28380: PUSH
28381: EMPTY
28382: LIST
28383: LIST
28384: IN
28385: NOT
28386: IFFALSE 28390
// exit ;
28388: GO 30024
// if name then
28390: LD_VAR 0 3
28394: IFFALSE 28410
// SetBName ( base_dep , name ) ;
28396: LD_VAR 0 1
28400: PPUSH
28401: LD_VAR 0 3
28405: PPUSH
28406: CALL_OW 500
// base := GetBase ( base_dep ) ;
28410: LD_ADDR_VAR 0 15
28414: PUSH
28415: LD_VAR 0 1
28419: PPUSH
28420: CALL_OW 274
28424: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28425: LD_ADDR_VAR 0 16
28429: PUSH
28430: LD_VAR 0 1
28434: PPUSH
28435: CALL_OW 255
28439: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28440: LD_ADDR_VAR 0 17
28444: PUSH
28445: LD_VAR 0 1
28449: PPUSH
28450: CALL_OW 248
28454: ST_TO_ADDR
// if sources then
28455: LD_VAR 0 5
28459: IFFALSE 28506
// for i = 1 to 3 do
28461: LD_ADDR_VAR 0 8
28465: PUSH
28466: DOUBLE
28467: LD_INT 1
28469: DEC
28470: ST_TO_ADDR
28471: LD_INT 3
28473: PUSH
28474: FOR_TO
28475: IFFALSE 28504
// AddResourceType ( base , i , sources [ i ] ) ;
28477: LD_VAR 0 15
28481: PPUSH
28482: LD_VAR 0 8
28486: PPUSH
28487: LD_VAR 0 5
28491: PUSH
28492: LD_VAR 0 8
28496: ARRAY
28497: PPUSH
28498: CALL_OW 276
28502: GO 28474
28504: POP
28505: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28506: LD_ADDR_VAR 0 18
28510: PUSH
28511: LD_VAR 0 15
28515: PPUSH
28516: LD_VAR 0 2
28520: PPUSH
28521: LD_INT 1
28523: PPUSH
28524: CALL 27767 0 3
28528: ST_TO_ADDR
// InitHc ;
28529: CALL_OW 19
// InitUc ;
28533: CALL_OW 18
// uc_side := side ;
28537: LD_ADDR_OWVAR 20
28541: PUSH
28542: LD_VAR 0 16
28546: ST_TO_ADDR
// uc_nation := nation ;
28547: LD_ADDR_OWVAR 21
28551: PUSH
28552: LD_VAR 0 17
28556: ST_TO_ADDR
// if buildings then
28557: LD_VAR 0 18
28561: IFFALSE 29883
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28563: LD_ADDR_VAR 0 19
28567: PUSH
28568: LD_VAR 0 18
28572: PPUSH
28573: LD_INT 2
28575: PUSH
28576: LD_INT 30
28578: PUSH
28579: LD_INT 29
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 30
28588: PUSH
28589: LD_INT 30
28591: PUSH
28592: EMPTY
28593: LIST
28594: LIST
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: PPUSH
28601: CALL_OW 72
28605: ST_TO_ADDR
// if tmp then
28606: LD_VAR 0 19
28610: IFFALSE 28658
// for i in tmp do
28612: LD_ADDR_VAR 0 8
28616: PUSH
28617: LD_VAR 0 19
28621: PUSH
28622: FOR_IN
28623: IFFALSE 28656
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28625: LD_VAR 0 8
28629: PPUSH
28630: CALL_OW 250
28634: PPUSH
28635: LD_VAR 0 8
28639: PPUSH
28640: CALL_OW 251
28644: PPUSH
28645: LD_VAR 0 16
28649: PPUSH
28650: CALL_OW 441
28654: GO 28622
28656: POP
28657: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28658: LD_VAR 0 18
28662: PPUSH
28663: LD_INT 2
28665: PUSH
28666: LD_INT 30
28668: PUSH
28669: LD_INT 32
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: LD_INT 30
28678: PUSH
28679: LD_INT 33
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: LIST
28690: PPUSH
28691: CALL_OW 72
28695: IFFALSE 28783
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28697: LD_ADDR_VAR 0 8
28701: PUSH
28702: LD_VAR 0 18
28706: PPUSH
28707: LD_INT 2
28709: PUSH
28710: LD_INT 30
28712: PUSH
28713: LD_INT 32
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 30
28722: PUSH
28723: LD_INT 33
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: LIST
28734: PPUSH
28735: CALL_OW 72
28739: PUSH
28740: FOR_IN
28741: IFFALSE 28781
// begin if not GetBWeapon ( i ) then
28743: LD_VAR 0 8
28747: PPUSH
28748: CALL_OW 269
28752: NOT
28753: IFFALSE 28779
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28755: LD_VAR 0 8
28759: PPUSH
28760: LD_VAR 0 8
28764: PPUSH
28765: LD_VAR 0 2
28769: PPUSH
28770: CALL 30029 0 2
28774: PPUSH
28775: CALL_OW 431
// end ;
28779: GO 28740
28781: POP
28782: POP
// end ; for i = 1 to personel do
28783: LD_ADDR_VAR 0 8
28787: PUSH
28788: DOUBLE
28789: LD_INT 1
28791: DEC
28792: ST_TO_ADDR
28793: LD_VAR 0 6
28797: PUSH
28798: FOR_TO
28799: IFFALSE 29863
// begin if i > 4 then
28801: LD_VAR 0 8
28805: PUSH
28806: LD_INT 4
28808: GREATER
28809: IFFALSE 28813
// break ;
28811: GO 29863
// case i of 1 :
28813: LD_VAR 0 8
28817: PUSH
28818: LD_INT 1
28820: DOUBLE
28821: EQUAL
28822: IFTRUE 28826
28824: GO 28906
28826: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28827: LD_ADDR_VAR 0 12
28831: PUSH
28832: LD_VAR 0 18
28836: PPUSH
28837: LD_INT 22
28839: PUSH
28840: LD_VAR 0 16
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 58
28851: PUSH
28852: EMPTY
28853: LIST
28854: PUSH
28855: LD_INT 2
28857: PUSH
28858: LD_INT 30
28860: PUSH
28861: LD_INT 32
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 30
28870: PUSH
28871: LD_INT 4
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 30
28880: PUSH
28881: LD_INT 5
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: LIST
28898: PPUSH
28899: CALL_OW 72
28903: ST_TO_ADDR
28904: GO 29128
28906: LD_INT 2
28908: DOUBLE
28909: EQUAL
28910: IFTRUE 28914
28912: GO 28976
28914: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28915: LD_ADDR_VAR 0 12
28919: PUSH
28920: LD_VAR 0 18
28924: PPUSH
28925: LD_INT 22
28927: PUSH
28928: LD_VAR 0 16
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 2
28939: PUSH
28940: LD_INT 30
28942: PUSH
28943: LD_INT 0
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 30
28952: PUSH
28953: LD_INT 1
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: LIST
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PPUSH
28969: CALL_OW 72
28973: ST_TO_ADDR
28974: GO 29128
28976: LD_INT 3
28978: DOUBLE
28979: EQUAL
28980: IFTRUE 28984
28982: GO 29046
28984: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28985: LD_ADDR_VAR 0 12
28989: PUSH
28990: LD_VAR 0 18
28994: PPUSH
28995: LD_INT 22
28997: PUSH
28998: LD_VAR 0 16
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 2
29009: PUSH
29010: LD_INT 30
29012: PUSH
29013: LD_INT 2
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: LD_INT 30
29022: PUSH
29023: LD_INT 3
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: LIST
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PPUSH
29039: CALL_OW 72
29043: ST_TO_ADDR
29044: GO 29128
29046: LD_INT 4
29048: DOUBLE
29049: EQUAL
29050: IFTRUE 29054
29052: GO 29127
29054: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
29055: LD_ADDR_VAR 0 12
29059: PUSH
29060: LD_VAR 0 18
29064: PPUSH
29065: LD_INT 22
29067: PUSH
29068: LD_VAR 0 16
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 2
29079: PUSH
29080: LD_INT 30
29082: PUSH
29083: LD_INT 6
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 30
29092: PUSH
29093: LD_INT 7
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: LD_INT 30
29102: PUSH
29103: LD_INT 8
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: LIST
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PPUSH
29120: CALL_OW 72
29124: ST_TO_ADDR
29125: GO 29128
29127: POP
// if i = 1 then
29128: LD_VAR 0 8
29132: PUSH
29133: LD_INT 1
29135: EQUAL
29136: IFFALSE 29247
// begin tmp := [ ] ;
29138: LD_ADDR_VAR 0 19
29142: PUSH
29143: EMPTY
29144: ST_TO_ADDR
// for j in f do
29145: LD_ADDR_VAR 0 9
29149: PUSH
29150: LD_VAR 0 12
29154: PUSH
29155: FOR_IN
29156: IFFALSE 29229
// if GetBType ( j ) = b_bunker then
29158: LD_VAR 0 9
29162: PPUSH
29163: CALL_OW 266
29167: PUSH
29168: LD_INT 32
29170: EQUAL
29171: IFFALSE 29198
// tmp := Insert ( tmp , 1 , j ) else
29173: LD_ADDR_VAR 0 19
29177: PUSH
29178: LD_VAR 0 19
29182: PPUSH
29183: LD_INT 1
29185: PPUSH
29186: LD_VAR 0 9
29190: PPUSH
29191: CALL_OW 2
29195: ST_TO_ADDR
29196: GO 29227
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29198: LD_ADDR_VAR 0 19
29202: PUSH
29203: LD_VAR 0 19
29207: PPUSH
29208: LD_VAR 0 19
29212: PUSH
29213: LD_INT 1
29215: PLUS
29216: PPUSH
29217: LD_VAR 0 9
29221: PPUSH
29222: CALL_OW 2
29226: ST_TO_ADDR
29227: GO 29155
29229: POP
29230: POP
// if tmp then
29231: LD_VAR 0 19
29235: IFFALSE 29247
// f := tmp ;
29237: LD_ADDR_VAR 0 12
29241: PUSH
29242: LD_VAR 0 19
29246: ST_TO_ADDR
// end ; x := personel [ i ] ;
29247: LD_ADDR_VAR 0 13
29251: PUSH
29252: LD_VAR 0 6
29256: PUSH
29257: LD_VAR 0 8
29261: ARRAY
29262: ST_TO_ADDR
// if x = - 1 then
29263: LD_VAR 0 13
29267: PUSH
29268: LD_INT 1
29270: NEG
29271: EQUAL
29272: IFFALSE 29481
// begin for j in f do
29274: LD_ADDR_VAR 0 9
29278: PUSH
29279: LD_VAR 0 12
29283: PUSH
29284: FOR_IN
29285: IFFALSE 29477
// repeat InitHc ;
29287: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29291: LD_VAR 0 9
29295: PPUSH
29296: CALL_OW 266
29300: PUSH
29301: LD_INT 5
29303: EQUAL
29304: IFFALSE 29374
// begin if UnitsInside ( j ) < 3 then
29306: LD_VAR 0 9
29310: PPUSH
29311: CALL_OW 313
29315: PUSH
29316: LD_INT 3
29318: LESS
29319: IFFALSE 29355
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29321: LD_INT 0
29323: PPUSH
29324: LD_INT 5
29326: PUSH
29327: LD_INT 8
29329: PUSH
29330: LD_INT 9
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: LIST
29337: PUSH
29338: LD_VAR 0 17
29342: ARRAY
29343: PPUSH
29344: LD_VAR 0 4
29348: PPUSH
29349: CALL_OW 380
29353: GO 29372
// PrepareHuman ( false , i , skill ) ;
29355: LD_INT 0
29357: PPUSH
29358: LD_VAR 0 8
29362: PPUSH
29363: LD_VAR 0 4
29367: PPUSH
29368: CALL_OW 380
// end else
29372: GO 29391
// PrepareHuman ( false , i , skill ) ;
29374: LD_INT 0
29376: PPUSH
29377: LD_VAR 0 8
29381: PPUSH
29382: LD_VAR 0 4
29386: PPUSH
29387: CALL_OW 380
// un := CreateHuman ;
29391: LD_ADDR_VAR 0 14
29395: PUSH
29396: CALL_OW 44
29400: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29401: LD_ADDR_VAR 0 7
29405: PUSH
29406: LD_VAR 0 7
29410: PPUSH
29411: LD_INT 1
29413: PPUSH
29414: LD_VAR 0 14
29418: PPUSH
29419: CALL_OW 2
29423: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29424: LD_VAR 0 14
29428: PPUSH
29429: LD_VAR 0 9
29433: PPUSH
29434: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29438: LD_VAR 0 9
29442: PPUSH
29443: CALL_OW 313
29447: PUSH
29448: LD_INT 6
29450: EQUAL
29451: PUSH
29452: LD_VAR 0 9
29456: PPUSH
29457: CALL_OW 266
29461: PUSH
29462: LD_INT 32
29464: PUSH
29465: LD_INT 31
29467: PUSH
29468: EMPTY
29469: LIST
29470: LIST
29471: IN
29472: OR
29473: IFFALSE 29287
29475: GO 29284
29477: POP
29478: POP
// end else
29479: GO 29861
// for j = 1 to x do
29481: LD_ADDR_VAR 0 9
29485: PUSH
29486: DOUBLE
29487: LD_INT 1
29489: DEC
29490: ST_TO_ADDR
29491: LD_VAR 0 13
29495: PUSH
29496: FOR_TO
29497: IFFALSE 29859
// begin InitHc ;
29499: CALL_OW 19
// if not f then
29503: LD_VAR 0 12
29507: NOT
29508: IFFALSE 29597
// begin PrepareHuman ( false , i , skill ) ;
29510: LD_INT 0
29512: PPUSH
29513: LD_VAR 0 8
29517: PPUSH
29518: LD_VAR 0 4
29522: PPUSH
29523: CALL_OW 380
// un := CreateHuman ;
29527: LD_ADDR_VAR 0 14
29531: PUSH
29532: CALL_OW 44
29536: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29537: LD_ADDR_VAR 0 7
29541: PUSH
29542: LD_VAR 0 7
29546: PPUSH
29547: LD_INT 1
29549: PPUSH
29550: LD_VAR 0 14
29554: PPUSH
29555: CALL_OW 2
29559: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29560: LD_VAR 0 14
29564: PPUSH
29565: LD_VAR 0 1
29569: PPUSH
29570: CALL_OW 250
29574: PPUSH
29575: LD_VAR 0 1
29579: PPUSH
29580: CALL_OW 251
29584: PPUSH
29585: LD_INT 10
29587: PPUSH
29588: LD_INT 0
29590: PPUSH
29591: CALL_OW 50
// continue ;
29595: GO 29496
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29597: LD_VAR 0 12
29601: PUSH
29602: LD_INT 1
29604: ARRAY
29605: PPUSH
29606: CALL_OW 313
29610: PUSH
29611: LD_VAR 0 12
29615: PUSH
29616: LD_INT 1
29618: ARRAY
29619: PPUSH
29620: CALL_OW 266
29624: PUSH
29625: LD_INT 32
29627: PUSH
29628: LD_INT 31
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: IN
29635: AND
29636: PUSH
29637: LD_VAR 0 12
29641: PUSH
29642: LD_INT 1
29644: ARRAY
29645: PPUSH
29646: CALL_OW 313
29650: PUSH
29651: LD_INT 6
29653: EQUAL
29654: OR
29655: IFFALSE 29675
// f := Delete ( f , 1 ) ;
29657: LD_ADDR_VAR 0 12
29661: PUSH
29662: LD_VAR 0 12
29666: PPUSH
29667: LD_INT 1
29669: PPUSH
29670: CALL_OW 3
29674: ST_TO_ADDR
// if not f then
29675: LD_VAR 0 12
29679: NOT
29680: IFFALSE 29698
// begin x := x + 2 ;
29682: LD_ADDR_VAR 0 13
29686: PUSH
29687: LD_VAR 0 13
29691: PUSH
29692: LD_INT 2
29694: PLUS
29695: ST_TO_ADDR
// continue ;
29696: GO 29496
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29698: LD_VAR 0 12
29702: PUSH
29703: LD_INT 1
29705: ARRAY
29706: PPUSH
29707: CALL_OW 266
29711: PUSH
29712: LD_INT 5
29714: EQUAL
29715: IFFALSE 29789
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29717: LD_VAR 0 12
29721: PUSH
29722: LD_INT 1
29724: ARRAY
29725: PPUSH
29726: CALL_OW 313
29730: PUSH
29731: LD_INT 3
29733: LESS
29734: IFFALSE 29770
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29736: LD_INT 0
29738: PPUSH
29739: LD_INT 5
29741: PUSH
29742: LD_INT 8
29744: PUSH
29745: LD_INT 9
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: LIST
29752: PUSH
29753: LD_VAR 0 17
29757: ARRAY
29758: PPUSH
29759: LD_VAR 0 4
29763: PPUSH
29764: CALL_OW 380
29768: GO 29787
// PrepareHuman ( false , i , skill ) ;
29770: LD_INT 0
29772: PPUSH
29773: LD_VAR 0 8
29777: PPUSH
29778: LD_VAR 0 4
29782: PPUSH
29783: CALL_OW 380
// end else
29787: GO 29806
// PrepareHuman ( false , i , skill ) ;
29789: LD_INT 0
29791: PPUSH
29792: LD_VAR 0 8
29796: PPUSH
29797: LD_VAR 0 4
29801: PPUSH
29802: CALL_OW 380
// un := CreateHuman ;
29806: LD_ADDR_VAR 0 14
29810: PUSH
29811: CALL_OW 44
29815: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29816: LD_ADDR_VAR 0 7
29820: PUSH
29821: LD_VAR 0 7
29825: PPUSH
29826: LD_INT 1
29828: PPUSH
29829: LD_VAR 0 14
29833: PPUSH
29834: CALL_OW 2
29838: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29839: LD_VAR 0 14
29843: PPUSH
29844: LD_VAR 0 12
29848: PUSH
29849: LD_INT 1
29851: ARRAY
29852: PPUSH
29853: CALL_OW 52
// end ;
29857: GO 29496
29859: POP
29860: POP
// end ;
29861: GO 28798
29863: POP
29864: POP
// result := result ^ buildings ;
29865: LD_ADDR_VAR 0 7
29869: PUSH
29870: LD_VAR 0 7
29874: PUSH
29875: LD_VAR 0 18
29879: ADD
29880: ST_TO_ADDR
// end else
29881: GO 30024
// begin for i = 1 to personel do
29883: LD_ADDR_VAR 0 8
29887: PUSH
29888: DOUBLE
29889: LD_INT 1
29891: DEC
29892: ST_TO_ADDR
29893: LD_VAR 0 6
29897: PUSH
29898: FOR_TO
29899: IFFALSE 30022
// begin if i > 4 then
29901: LD_VAR 0 8
29905: PUSH
29906: LD_INT 4
29908: GREATER
29909: IFFALSE 29913
// break ;
29911: GO 30022
// x := personel [ i ] ;
29913: LD_ADDR_VAR 0 13
29917: PUSH
29918: LD_VAR 0 6
29922: PUSH
29923: LD_VAR 0 8
29927: ARRAY
29928: ST_TO_ADDR
// if x = - 1 then
29929: LD_VAR 0 13
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: EQUAL
29938: IFFALSE 29942
// continue ;
29940: GO 29898
// PrepareHuman ( false , i , skill ) ;
29942: LD_INT 0
29944: PPUSH
29945: LD_VAR 0 8
29949: PPUSH
29950: LD_VAR 0 4
29954: PPUSH
29955: CALL_OW 380
// un := CreateHuman ;
29959: LD_ADDR_VAR 0 14
29963: PUSH
29964: CALL_OW 44
29968: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29969: LD_VAR 0 14
29973: PPUSH
29974: LD_VAR 0 1
29978: PPUSH
29979: CALL_OW 250
29983: PPUSH
29984: LD_VAR 0 1
29988: PPUSH
29989: CALL_OW 251
29993: PPUSH
29994: LD_INT 10
29996: PPUSH
29997: LD_INT 0
29999: PPUSH
30000: CALL_OW 50
// result := result ^ un ;
30004: LD_ADDR_VAR 0 7
30008: PUSH
30009: LD_VAR 0 7
30013: PUSH
30014: LD_VAR 0 14
30018: ADD
30019: ST_TO_ADDR
// end ;
30020: GO 29898
30022: POP
30023: POP
// end ; end ;
30024: LD_VAR 0 7
30028: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
30029: LD_INT 0
30031: PPUSH
30032: PPUSH
30033: PPUSH
30034: PPUSH
30035: PPUSH
30036: PPUSH
30037: PPUSH
30038: PPUSH
30039: PPUSH
30040: PPUSH
30041: PPUSH
30042: PPUSH
30043: PPUSH
30044: PPUSH
30045: PPUSH
30046: PPUSH
// result := false ;
30047: LD_ADDR_VAR 0 3
30051: PUSH
30052: LD_INT 0
30054: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
30055: LD_VAR 0 1
30059: NOT
30060: PUSH
30061: LD_VAR 0 1
30065: PPUSH
30066: CALL_OW 266
30070: PUSH
30071: LD_INT 32
30073: PUSH
30074: LD_INT 33
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: IN
30081: NOT
30082: OR
30083: IFFALSE 30087
// exit ;
30085: GO 31196
// nat := GetNation ( tower ) ;
30087: LD_ADDR_VAR 0 12
30091: PUSH
30092: LD_VAR 0 1
30096: PPUSH
30097: CALL_OW 248
30101: ST_TO_ADDR
// side := GetSide ( tower ) ;
30102: LD_ADDR_VAR 0 16
30106: PUSH
30107: LD_VAR 0 1
30111: PPUSH
30112: CALL_OW 255
30116: ST_TO_ADDR
// x := GetX ( tower ) ;
30117: LD_ADDR_VAR 0 10
30121: PUSH
30122: LD_VAR 0 1
30126: PPUSH
30127: CALL_OW 250
30131: ST_TO_ADDR
// y := GetY ( tower ) ;
30132: LD_ADDR_VAR 0 11
30136: PUSH
30137: LD_VAR 0 1
30141: PPUSH
30142: CALL_OW 251
30146: ST_TO_ADDR
// if not x or not y then
30147: LD_VAR 0 10
30151: NOT
30152: PUSH
30153: LD_VAR 0 11
30157: NOT
30158: OR
30159: IFFALSE 30163
// exit ;
30161: GO 31196
// weapon := 0 ;
30163: LD_ADDR_VAR 0 18
30167: PUSH
30168: LD_INT 0
30170: ST_TO_ADDR
// fac_list := [ ] ;
30171: LD_ADDR_VAR 0 17
30175: PUSH
30176: EMPTY
30177: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30178: LD_ADDR_VAR 0 6
30182: PUSH
30183: LD_VAR 0 1
30187: PPUSH
30188: CALL_OW 274
30192: PPUSH
30193: LD_VAR 0 2
30197: PPUSH
30198: LD_INT 0
30200: PPUSH
30201: CALL 27767 0 3
30205: PPUSH
30206: LD_INT 30
30208: PUSH
30209: LD_INT 3
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PPUSH
30216: CALL_OW 72
30220: ST_TO_ADDR
// if not factories then
30221: LD_VAR 0 6
30225: NOT
30226: IFFALSE 30230
// exit ;
30228: GO 31196
// for i in factories do
30230: LD_ADDR_VAR 0 8
30234: PUSH
30235: LD_VAR 0 6
30239: PUSH
30240: FOR_IN
30241: IFFALSE 30266
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30243: LD_ADDR_VAR 0 17
30247: PUSH
30248: LD_VAR 0 17
30252: PUSH
30253: LD_VAR 0 8
30257: PPUSH
30258: CALL_OW 478
30262: UNION
30263: ST_TO_ADDR
30264: GO 30240
30266: POP
30267: POP
// if not fac_list then
30268: LD_VAR 0 17
30272: NOT
30273: IFFALSE 30277
// exit ;
30275: GO 31196
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30277: LD_ADDR_VAR 0 5
30281: PUSH
30282: LD_INT 4
30284: PUSH
30285: LD_INT 5
30287: PUSH
30288: LD_INT 9
30290: PUSH
30291: LD_INT 10
30293: PUSH
30294: LD_INT 6
30296: PUSH
30297: LD_INT 7
30299: PUSH
30300: LD_INT 11
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: PUSH
30312: LD_INT 27
30314: PUSH
30315: LD_INT 28
30317: PUSH
30318: LD_INT 26
30320: PUSH
30321: LD_INT 30
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 43
30332: PUSH
30333: LD_INT 44
30335: PUSH
30336: LD_INT 46
30338: PUSH
30339: LD_INT 45
30341: PUSH
30342: LD_INT 47
30344: PUSH
30345: LD_INT 49
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: LIST
30360: PUSH
30361: LD_VAR 0 12
30365: ARRAY
30366: ST_TO_ADDR
// list := list isect fac_list ;
30367: LD_ADDR_VAR 0 5
30371: PUSH
30372: LD_VAR 0 5
30376: PUSH
30377: LD_VAR 0 17
30381: ISECT
30382: ST_TO_ADDR
// if not list then
30383: LD_VAR 0 5
30387: NOT
30388: IFFALSE 30392
// exit ;
30390: GO 31196
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30392: LD_VAR 0 12
30396: PUSH
30397: LD_INT 3
30399: EQUAL
30400: PUSH
30401: LD_INT 49
30403: PUSH
30404: LD_VAR 0 5
30408: IN
30409: AND
30410: PUSH
30411: LD_INT 31
30413: PPUSH
30414: LD_VAR 0 16
30418: PPUSH
30419: CALL_OW 321
30423: PUSH
30424: LD_INT 2
30426: EQUAL
30427: AND
30428: IFFALSE 30488
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30430: LD_INT 22
30432: PUSH
30433: LD_VAR 0 16
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 35
30444: PUSH
30445: LD_INT 49
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 91
30454: PUSH
30455: LD_VAR 0 1
30459: PUSH
30460: LD_INT 10
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: LIST
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: LIST
30472: PPUSH
30473: CALL_OW 69
30477: NOT
30478: IFFALSE 30488
// weapon := ru_time_lapser ;
30480: LD_ADDR_VAR 0 18
30484: PUSH
30485: LD_INT 49
30487: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30488: LD_VAR 0 12
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: IN
30503: PUSH
30504: LD_INT 11
30506: PUSH
30507: LD_VAR 0 5
30511: IN
30512: PUSH
30513: LD_INT 30
30515: PUSH
30516: LD_VAR 0 5
30520: IN
30521: OR
30522: AND
30523: PUSH
30524: LD_INT 6
30526: PPUSH
30527: LD_VAR 0 16
30531: PPUSH
30532: CALL_OW 321
30536: PUSH
30537: LD_INT 2
30539: EQUAL
30540: AND
30541: IFFALSE 30706
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30543: LD_INT 22
30545: PUSH
30546: LD_VAR 0 16
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 2
30557: PUSH
30558: LD_INT 35
30560: PUSH
30561: LD_INT 11
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 35
30570: PUSH
30571: LD_INT 30
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 91
30585: PUSH
30586: LD_VAR 0 1
30590: PUSH
30591: LD_INT 18
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: LIST
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: LIST
30603: PPUSH
30604: CALL_OW 69
30608: NOT
30609: PUSH
30610: LD_INT 22
30612: PUSH
30613: LD_VAR 0 16
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 2
30624: PUSH
30625: LD_INT 30
30627: PUSH
30628: LD_INT 32
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 30
30637: PUSH
30638: LD_INT 33
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 91
30652: PUSH
30653: LD_VAR 0 1
30657: PUSH
30658: LD_INT 12
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: LIST
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: LIST
30670: PUSH
30671: EMPTY
30672: LIST
30673: PPUSH
30674: CALL_OW 69
30678: PUSH
30679: LD_INT 2
30681: GREATER
30682: AND
30683: IFFALSE 30706
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30685: LD_ADDR_VAR 0 18
30689: PUSH
30690: LD_INT 11
30692: PUSH
30693: LD_INT 30
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_VAR 0 12
30704: ARRAY
30705: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30706: LD_VAR 0 18
30710: NOT
30711: PUSH
30712: LD_INT 40
30714: PPUSH
30715: LD_VAR 0 16
30719: PPUSH
30720: CALL_OW 321
30724: PUSH
30725: LD_INT 2
30727: EQUAL
30728: AND
30729: PUSH
30730: LD_INT 7
30732: PUSH
30733: LD_VAR 0 5
30737: IN
30738: PUSH
30739: LD_INT 28
30741: PUSH
30742: LD_VAR 0 5
30746: IN
30747: OR
30748: PUSH
30749: LD_INT 45
30751: PUSH
30752: LD_VAR 0 5
30756: IN
30757: OR
30758: AND
30759: IFFALSE 31013
// begin hex := GetHexInfo ( x , y ) ;
30761: LD_ADDR_VAR 0 4
30765: PUSH
30766: LD_VAR 0 10
30770: PPUSH
30771: LD_VAR 0 11
30775: PPUSH
30776: CALL_OW 546
30780: ST_TO_ADDR
// if hex [ 1 ] then
30781: LD_VAR 0 4
30785: PUSH
30786: LD_INT 1
30788: ARRAY
30789: IFFALSE 30793
// exit ;
30791: GO 31196
// height := hex [ 2 ] ;
30793: LD_ADDR_VAR 0 15
30797: PUSH
30798: LD_VAR 0 4
30802: PUSH
30803: LD_INT 2
30805: ARRAY
30806: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30807: LD_ADDR_VAR 0 14
30811: PUSH
30812: LD_INT 0
30814: PUSH
30815: LD_INT 2
30817: PUSH
30818: LD_INT 3
30820: PUSH
30821: LD_INT 5
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: LIST
30828: LIST
30829: ST_TO_ADDR
// for i in tmp do
30830: LD_ADDR_VAR 0 8
30834: PUSH
30835: LD_VAR 0 14
30839: PUSH
30840: FOR_IN
30841: IFFALSE 31011
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30843: LD_ADDR_VAR 0 9
30847: PUSH
30848: LD_VAR 0 10
30852: PPUSH
30853: LD_VAR 0 8
30857: PPUSH
30858: LD_INT 5
30860: PPUSH
30861: CALL_OW 272
30865: PUSH
30866: LD_VAR 0 11
30870: PPUSH
30871: LD_VAR 0 8
30875: PPUSH
30876: LD_INT 5
30878: PPUSH
30879: CALL_OW 273
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30888: LD_VAR 0 9
30892: PUSH
30893: LD_INT 1
30895: ARRAY
30896: PPUSH
30897: LD_VAR 0 9
30901: PUSH
30902: LD_INT 2
30904: ARRAY
30905: PPUSH
30906: CALL_OW 488
30910: IFFALSE 31009
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30912: LD_ADDR_VAR 0 4
30916: PUSH
30917: LD_VAR 0 9
30921: PUSH
30922: LD_INT 1
30924: ARRAY
30925: PPUSH
30926: LD_VAR 0 9
30930: PUSH
30931: LD_INT 2
30933: ARRAY
30934: PPUSH
30935: CALL_OW 546
30939: ST_TO_ADDR
// if hex [ 1 ] then
30940: LD_VAR 0 4
30944: PUSH
30945: LD_INT 1
30947: ARRAY
30948: IFFALSE 30952
// continue ;
30950: GO 30840
// h := hex [ 2 ] ;
30952: LD_ADDR_VAR 0 13
30956: PUSH
30957: LD_VAR 0 4
30961: PUSH
30962: LD_INT 2
30964: ARRAY
30965: ST_TO_ADDR
// if h + 7 < height then
30966: LD_VAR 0 13
30970: PUSH
30971: LD_INT 7
30973: PLUS
30974: PUSH
30975: LD_VAR 0 15
30979: LESS
30980: IFFALSE 31009
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30982: LD_ADDR_VAR 0 18
30986: PUSH
30987: LD_INT 7
30989: PUSH
30990: LD_INT 28
30992: PUSH
30993: LD_INT 45
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: LIST
31000: PUSH
31001: LD_VAR 0 12
31005: ARRAY
31006: ST_TO_ADDR
// break ;
31007: GO 31011
// end ; end ; end ;
31009: GO 30840
31011: POP
31012: POP
// end ; if not weapon then
31013: LD_VAR 0 18
31017: NOT
31018: IFFALSE 31078
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
31020: LD_ADDR_VAR 0 5
31024: PUSH
31025: LD_VAR 0 5
31029: PUSH
31030: LD_INT 11
31032: PUSH
31033: LD_INT 30
31035: PUSH
31036: LD_INT 49
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: LIST
31043: DIFF
31044: ST_TO_ADDR
// if not list then
31045: LD_VAR 0 5
31049: NOT
31050: IFFALSE 31054
// exit ;
31052: GO 31196
// weapon := list [ rand ( 1 , list ) ] ;
31054: LD_ADDR_VAR 0 18
31058: PUSH
31059: LD_VAR 0 5
31063: PUSH
31064: LD_INT 1
31066: PPUSH
31067: LD_VAR 0 5
31071: PPUSH
31072: CALL_OW 12
31076: ARRAY
31077: ST_TO_ADDR
// end ; if weapon then
31078: LD_VAR 0 18
31082: IFFALSE 31196
// begin tmp := CostOfWeapon ( weapon ) ;
31084: LD_ADDR_VAR 0 14
31088: PUSH
31089: LD_VAR 0 18
31093: PPUSH
31094: CALL_OW 451
31098: ST_TO_ADDR
// j := GetBase ( tower ) ;
31099: LD_ADDR_VAR 0 9
31103: PUSH
31104: LD_VAR 0 1
31108: PPUSH
31109: CALL_OW 274
31113: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
31114: LD_VAR 0 9
31118: PPUSH
31119: LD_INT 1
31121: PPUSH
31122: CALL_OW 275
31126: PUSH
31127: LD_VAR 0 14
31131: PUSH
31132: LD_INT 1
31134: ARRAY
31135: GREATEREQUAL
31136: PUSH
31137: LD_VAR 0 9
31141: PPUSH
31142: LD_INT 2
31144: PPUSH
31145: CALL_OW 275
31149: PUSH
31150: LD_VAR 0 14
31154: PUSH
31155: LD_INT 2
31157: ARRAY
31158: GREATEREQUAL
31159: AND
31160: PUSH
31161: LD_VAR 0 9
31165: PPUSH
31166: LD_INT 3
31168: PPUSH
31169: CALL_OW 275
31173: PUSH
31174: LD_VAR 0 14
31178: PUSH
31179: LD_INT 3
31181: ARRAY
31182: GREATEREQUAL
31183: AND
31184: IFFALSE 31196
// result := weapon ;
31186: LD_ADDR_VAR 0 3
31190: PUSH
31191: LD_VAR 0 18
31195: ST_TO_ADDR
// end ; end ;
31196: LD_VAR 0 3
31200: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31201: LD_INT 0
31203: PPUSH
31204: PPUSH
// result := true ;
31205: LD_ADDR_VAR 0 3
31209: PUSH
31210: LD_INT 1
31212: ST_TO_ADDR
// if array1 = array2 then
31213: LD_VAR 0 1
31217: PUSH
31218: LD_VAR 0 2
31222: EQUAL
31223: IFFALSE 31283
// begin for i = 1 to array1 do
31225: LD_ADDR_VAR 0 4
31229: PUSH
31230: DOUBLE
31231: LD_INT 1
31233: DEC
31234: ST_TO_ADDR
31235: LD_VAR 0 1
31239: PUSH
31240: FOR_TO
31241: IFFALSE 31279
// if array1 [ i ] <> array2 [ i ] then
31243: LD_VAR 0 1
31247: PUSH
31248: LD_VAR 0 4
31252: ARRAY
31253: PUSH
31254: LD_VAR 0 2
31258: PUSH
31259: LD_VAR 0 4
31263: ARRAY
31264: NONEQUAL
31265: IFFALSE 31277
// begin result := false ;
31267: LD_ADDR_VAR 0 3
31271: PUSH
31272: LD_INT 0
31274: ST_TO_ADDR
// break ;
31275: GO 31279
// end ;
31277: GO 31240
31279: POP
31280: POP
// end else
31281: GO 31291
// result := false ;
31283: LD_ADDR_VAR 0 3
31287: PUSH
31288: LD_INT 0
31290: ST_TO_ADDR
// end ;
31291: LD_VAR 0 3
31295: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31296: LD_INT 0
31298: PPUSH
31299: PPUSH
// if not array1 or not array2 then
31300: LD_VAR 0 1
31304: NOT
31305: PUSH
31306: LD_VAR 0 2
31310: NOT
31311: OR
31312: IFFALSE 31316
// exit ;
31314: GO 31380
// result := true ;
31316: LD_ADDR_VAR 0 3
31320: PUSH
31321: LD_INT 1
31323: ST_TO_ADDR
// for i = 1 to array1 do
31324: LD_ADDR_VAR 0 4
31328: PUSH
31329: DOUBLE
31330: LD_INT 1
31332: DEC
31333: ST_TO_ADDR
31334: LD_VAR 0 1
31338: PUSH
31339: FOR_TO
31340: IFFALSE 31378
// if array1 [ i ] <> array2 [ i ] then
31342: LD_VAR 0 1
31346: PUSH
31347: LD_VAR 0 4
31351: ARRAY
31352: PUSH
31353: LD_VAR 0 2
31357: PUSH
31358: LD_VAR 0 4
31362: ARRAY
31363: NONEQUAL
31364: IFFALSE 31376
// begin result := false ;
31366: LD_ADDR_VAR 0 3
31370: PUSH
31371: LD_INT 0
31373: ST_TO_ADDR
// break ;
31374: GO 31378
// end ;
31376: GO 31339
31378: POP
31379: POP
// end ;
31380: LD_VAR 0 3
31384: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31385: LD_INT 0
31387: PPUSH
31388: PPUSH
31389: PPUSH
// pom := GetBase ( fac ) ;
31390: LD_ADDR_VAR 0 5
31394: PUSH
31395: LD_VAR 0 1
31399: PPUSH
31400: CALL_OW 274
31404: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31405: LD_ADDR_VAR 0 4
31409: PUSH
31410: LD_VAR 0 2
31414: PUSH
31415: LD_INT 1
31417: ARRAY
31418: PPUSH
31419: LD_VAR 0 2
31423: PUSH
31424: LD_INT 2
31426: ARRAY
31427: PPUSH
31428: LD_VAR 0 2
31432: PUSH
31433: LD_INT 3
31435: ARRAY
31436: PPUSH
31437: LD_VAR 0 2
31441: PUSH
31442: LD_INT 4
31444: ARRAY
31445: PPUSH
31446: CALL_OW 449
31450: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31451: LD_ADDR_VAR 0 3
31455: PUSH
31456: LD_VAR 0 5
31460: PPUSH
31461: LD_INT 1
31463: PPUSH
31464: CALL_OW 275
31468: PUSH
31469: LD_VAR 0 4
31473: PUSH
31474: LD_INT 1
31476: ARRAY
31477: GREATEREQUAL
31478: PUSH
31479: LD_VAR 0 5
31483: PPUSH
31484: LD_INT 2
31486: PPUSH
31487: CALL_OW 275
31491: PUSH
31492: LD_VAR 0 4
31496: PUSH
31497: LD_INT 2
31499: ARRAY
31500: GREATEREQUAL
31501: AND
31502: PUSH
31503: LD_VAR 0 5
31507: PPUSH
31508: LD_INT 3
31510: PPUSH
31511: CALL_OW 275
31515: PUSH
31516: LD_VAR 0 4
31520: PUSH
31521: LD_INT 3
31523: ARRAY
31524: GREATEREQUAL
31525: AND
31526: ST_TO_ADDR
// end ;
31527: LD_VAR 0 3
31531: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31532: LD_INT 0
31534: PPUSH
31535: PPUSH
31536: PPUSH
31537: PPUSH
// pom := GetBase ( building ) ;
31538: LD_ADDR_VAR 0 3
31542: PUSH
31543: LD_VAR 0 1
31547: PPUSH
31548: CALL_OW 274
31552: ST_TO_ADDR
// if not pom then
31553: LD_VAR 0 3
31557: NOT
31558: IFFALSE 31562
// exit ;
31560: GO 31732
// btype := GetBType ( building ) ;
31562: LD_ADDR_VAR 0 5
31566: PUSH
31567: LD_VAR 0 1
31571: PPUSH
31572: CALL_OW 266
31576: ST_TO_ADDR
// if btype = b_armoury then
31577: LD_VAR 0 5
31581: PUSH
31582: LD_INT 4
31584: EQUAL
31585: IFFALSE 31595
// btype := b_barracks ;
31587: LD_ADDR_VAR 0 5
31591: PUSH
31592: LD_INT 5
31594: ST_TO_ADDR
// if btype = b_depot then
31595: LD_VAR 0 5
31599: PUSH
31600: LD_INT 0
31602: EQUAL
31603: IFFALSE 31613
// btype := b_warehouse ;
31605: LD_ADDR_VAR 0 5
31609: PUSH
31610: LD_INT 1
31612: ST_TO_ADDR
// if btype = b_workshop then
31613: LD_VAR 0 5
31617: PUSH
31618: LD_INT 2
31620: EQUAL
31621: IFFALSE 31631
// btype := b_factory ;
31623: LD_ADDR_VAR 0 5
31627: PUSH
31628: LD_INT 3
31630: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31631: LD_ADDR_VAR 0 4
31635: PUSH
31636: LD_VAR 0 5
31640: PPUSH
31641: LD_VAR 0 1
31645: PPUSH
31646: CALL_OW 248
31650: PPUSH
31651: CALL_OW 450
31655: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31656: LD_ADDR_VAR 0 2
31660: PUSH
31661: LD_VAR 0 3
31665: PPUSH
31666: LD_INT 1
31668: PPUSH
31669: CALL_OW 275
31673: PUSH
31674: LD_VAR 0 4
31678: PUSH
31679: LD_INT 1
31681: ARRAY
31682: GREATEREQUAL
31683: PUSH
31684: LD_VAR 0 3
31688: PPUSH
31689: LD_INT 2
31691: PPUSH
31692: CALL_OW 275
31696: PUSH
31697: LD_VAR 0 4
31701: PUSH
31702: LD_INT 2
31704: ARRAY
31705: GREATEREQUAL
31706: AND
31707: PUSH
31708: LD_VAR 0 3
31712: PPUSH
31713: LD_INT 3
31715: PPUSH
31716: CALL_OW 275
31720: PUSH
31721: LD_VAR 0 4
31725: PUSH
31726: LD_INT 3
31728: ARRAY
31729: GREATEREQUAL
31730: AND
31731: ST_TO_ADDR
// end ;
31732: LD_VAR 0 2
31736: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31737: LD_INT 0
31739: PPUSH
31740: PPUSH
31741: PPUSH
// pom := GetBase ( building ) ;
31742: LD_ADDR_VAR 0 4
31746: PUSH
31747: LD_VAR 0 1
31751: PPUSH
31752: CALL_OW 274
31756: ST_TO_ADDR
// if not pom then
31757: LD_VAR 0 4
31761: NOT
31762: IFFALSE 31766
// exit ;
31764: GO 31867
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31766: LD_ADDR_VAR 0 5
31770: PUSH
31771: LD_VAR 0 2
31775: PPUSH
31776: LD_VAR 0 1
31780: PPUSH
31781: CALL_OW 248
31785: PPUSH
31786: CALL_OW 450
31790: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31791: LD_ADDR_VAR 0 3
31795: PUSH
31796: LD_VAR 0 4
31800: PPUSH
31801: LD_INT 1
31803: PPUSH
31804: CALL_OW 275
31808: PUSH
31809: LD_VAR 0 5
31813: PUSH
31814: LD_INT 1
31816: ARRAY
31817: GREATEREQUAL
31818: PUSH
31819: LD_VAR 0 4
31823: PPUSH
31824: LD_INT 2
31826: PPUSH
31827: CALL_OW 275
31831: PUSH
31832: LD_VAR 0 5
31836: PUSH
31837: LD_INT 2
31839: ARRAY
31840: GREATEREQUAL
31841: AND
31842: PUSH
31843: LD_VAR 0 4
31847: PPUSH
31848: LD_INT 3
31850: PPUSH
31851: CALL_OW 275
31855: PUSH
31856: LD_VAR 0 5
31860: PUSH
31861: LD_INT 3
31863: ARRAY
31864: GREATEREQUAL
31865: AND
31866: ST_TO_ADDR
// end ;
31867: LD_VAR 0 3
31871: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31872: LD_INT 0
31874: PPUSH
31875: PPUSH
31876: PPUSH
31877: PPUSH
31878: PPUSH
31879: PPUSH
31880: PPUSH
31881: PPUSH
31882: PPUSH
31883: PPUSH
31884: PPUSH
// result := false ;
31885: LD_ADDR_VAR 0 8
31889: PUSH
31890: LD_INT 0
31892: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31893: LD_VAR 0 5
31897: NOT
31898: PUSH
31899: LD_VAR 0 1
31903: NOT
31904: OR
31905: PUSH
31906: LD_VAR 0 2
31910: NOT
31911: OR
31912: PUSH
31913: LD_VAR 0 3
31917: NOT
31918: OR
31919: IFFALSE 31923
// exit ;
31921: GO 32737
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31923: LD_ADDR_VAR 0 14
31927: PUSH
31928: LD_VAR 0 1
31932: PPUSH
31933: LD_VAR 0 2
31937: PPUSH
31938: LD_VAR 0 3
31942: PPUSH
31943: LD_VAR 0 4
31947: PPUSH
31948: LD_VAR 0 5
31952: PUSH
31953: LD_INT 1
31955: ARRAY
31956: PPUSH
31957: CALL_OW 248
31961: PPUSH
31962: LD_INT 0
31964: PPUSH
31965: CALL 33970 0 6
31969: ST_TO_ADDR
// if not hexes then
31970: LD_VAR 0 14
31974: NOT
31975: IFFALSE 31979
// exit ;
31977: GO 32737
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31979: LD_ADDR_VAR 0 17
31983: PUSH
31984: LD_VAR 0 5
31988: PPUSH
31989: LD_INT 22
31991: PUSH
31992: LD_VAR 0 13
31996: PPUSH
31997: CALL_OW 255
32001: PUSH
32002: EMPTY
32003: LIST
32004: LIST
32005: PUSH
32006: LD_INT 2
32008: PUSH
32009: LD_INT 30
32011: PUSH
32012: LD_INT 0
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 30
32021: PUSH
32022: LD_INT 1
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: LIST
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PPUSH
32038: CALL_OW 72
32042: ST_TO_ADDR
// for i = 1 to hexes do
32043: LD_ADDR_VAR 0 9
32047: PUSH
32048: DOUBLE
32049: LD_INT 1
32051: DEC
32052: ST_TO_ADDR
32053: LD_VAR 0 14
32057: PUSH
32058: FOR_TO
32059: IFFALSE 32735
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32061: LD_ADDR_VAR 0 13
32065: PUSH
32066: LD_VAR 0 14
32070: PUSH
32071: LD_VAR 0 9
32075: ARRAY
32076: PUSH
32077: LD_INT 1
32079: ARRAY
32080: PPUSH
32081: LD_VAR 0 14
32085: PUSH
32086: LD_VAR 0 9
32090: ARRAY
32091: PUSH
32092: LD_INT 2
32094: ARRAY
32095: PPUSH
32096: CALL_OW 428
32100: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
32101: LD_VAR 0 14
32105: PUSH
32106: LD_VAR 0 9
32110: ARRAY
32111: PUSH
32112: LD_INT 1
32114: ARRAY
32115: PPUSH
32116: LD_VAR 0 14
32120: PUSH
32121: LD_VAR 0 9
32125: ARRAY
32126: PUSH
32127: LD_INT 2
32129: ARRAY
32130: PPUSH
32131: CALL_OW 351
32135: PUSH
32136: LD_VAR 0 14
32140: PUSH
32141: LD_VAR 0 9
32145: ARRAY
32146: PUSH
32147: LD_INT 1
32149: ARRAY
32150: PPUSH
32151: LD_VAR 0 14
32155: PUSH
32156: LD_VAR 0 9
32160: ARRAY
32161: PUSH
32162: LD_INT 2
32164: ARRAY
32165: PPUSH
32166: CALL_OW 488
32170: NOT
32171: OR
32172: PUSH
32173: LD_VAR 0 13
32177: PPUSH
32178: CALL_OW 247
32182: PUSH
32183: LD_INT 3
32185: EQUAL
32186: OR
32187: IFFALSE 32193
// exit ;
32189: POP
32190: POP
32191: GO 32737
// if not tmp then
32193: LD_VAR 0 13
32197: NOT
32198: IFFALSE 32202
// continue ;
32200: GO 32058
// result := true ;
32202: LD_ADDR_VAR 0 8
32206: PUSH
32207: LD_INT 1
32209: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32210: LD_VAR 0 6
32214: PUSH
32215: LD_VAR 0 13
32219: PPUSH
32220: CALL_OW 247
32224: PUSH
32225: LD_INT 2
32227: EQUAL
32228: AND
32229: PUSH
32230: LD_VAR 0 13
32234: PPUSH
32235: CALL_OW 263
32239: PUSH
32240: LD_INT 1
32242: EQUAL
32243: AND
32244: IFFALSE 32408
// begin if IsDrivenBy ( tmp ) then
32246: LD_VAR 0 13
32250: PPUSH
32251: CALL_OW 311
32255: IFFALSE 32259
// continue ;
32257: GO 32058
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32259: LD_VAR 0 6
32263: PPUSH
32264: LD_INT 3
32266: PUSH
32267: LD_INT 60
32269: PUSH
32270: EMPTY
32271: LIST
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 3
32279: PUSH
32280: LD_INT 55
32282: PUSH
32283: EMPTY
32284: LIST
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PPUSH
32294: CALL_OW 72
32298: IFFALSE 32406
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32300: LD_ADDR_VAR 0 18
32304: PUSH
32305: LD_VAR 0 6
32309: PPUSH
32310: LD_INT 3
32312: PUSH
32313: LD_INT 60
32315: PUSH
32316: EMPTY
32317: LIST
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 3
32325: PUSH
32326: LD_INT 55
32328: PUSH
32329: EMPTY
32330: LIST
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PPUSH
32340: CALL_OW 72
32344: PUSH
32345: LD_INT 1
32347: ARRAY
32348: ST_TO_ADDR
// if IsInUnit ( driver ) then
32349: LD_VAR 0 18
32353: PPUSH
32354: CALL_OW 310
32358: IFFALSE 32369
// ComExit ( driver ) ;
32360: LD_VAR 0 18
32364: PPUSH
32365: CALL 57750 0 1
// AddComEnterUnit ( driver , tmp ) ;
32369: LD_VAR 0 18
32373: PPUSH
32374: LD_VAR 0 13
32378: PPUSH
32379: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32383: LD_VAR 0 18
32387: PPUSH
32388: LD_VAR 0 7
32392: PPUSH
32393: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32397: LD_VAR 0 18
32401: PPUSH
32402: CALL_OW 181
// end ; continue ;
32406: GO 32058
// end ; if not cleaners or not tmp in cleaners then
32408: LD_VAR 0 6
32412: NOT
32413: PUSH
32414: LD_VAR 0 13
32418: PUSH
32419: LD_VAR 0 6
32423: IN
32424: NOT
32425: OR
32426: IFFALSE 32733
// begin if dep then
32428: LD_VAR 0 17
32432: IFFALSE 32568
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32434: LD_ADDR_VAR 0 16
32438: PUSH
32439: LD_VAR 0 17
32443: PUSH
32444: LD_INT 1
32446: ARRAY
32447: PPUSH
32448: CALL_OW 250
32452: PPUSH
32453: LD_VAR 0 17
32457: PUSH
32458: LD_INT 1
32460: ARRAY
32461: PPUSH
32462: CALL_OW 254
32466: PPUSH
32467: LD_INT 5
32469: PPUSH
32470: CALL_OW 272
32474: PUSH
32475: LD_VAR 0 17
32479: PUSH
32480: LD_INT 1
32482: ARRAY
32483: PPUSH
32484: CALL_OW 251
32488: PPUSH
32489: LD_VAR 0 17
32493: PUSH
32494: LD_INT 1
32496: ARRAY
32497: PPUSH
32498: CALL_OW 254
32502: PPUSH
32503: LD_INT 5
32505: PPUSH
32506: CALL_OW 273
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32515: LD_VAR 0 16
32519: PUSH
32520: LD_INT 1
32522: ARRAY
32523: PPUSH
32524: LD_VAR 0 16
32528: PUSH
32529: LD_INT 2
32531: ARRAY
32532: PPUSH
32533: CALL_OW 488
32537: IFFALSE 32568
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32539: LD_VAR 0 13
32543: PPUSH
32544: LD_VAR 0 16
32548: PUSH
32549: LD_INT 1
32551: ARRAY
32552: PPUSH
32553: LD_VAR 0 16
32557: PUSH
32558: LD_INT 2
32560: ARRAY
32561: PPUSH
32562: CALL_OW 111
// continue ;
32566: GO 32058
// end ; end ; r := GetDir ( tmp ) ;
32568: LD_ADDR_VAR 0 15
32572: PUSH
32573: LD_VAR 0 13
32577: PPUSH
32578: CALL_OW 254
32582: ST_TO_ADDR
// if r = 5 then
32583: LD_VAR 0 15
32587: PUSH
32588: LD_INT 5
32590: EQUAL
32591: IFFALSE 32601
// r := 0 ;
32593: LD_ADDR_VAR 0 15
32597: PUSH
32598: LD_INT 0
32600: ST_TO_ADDR
// for j = r to 5 do
32601: LD_ADDR_VAR 0 10
32605: PUSH
32606: DOUBLE
32607: LD_VAR 0 15
32611: DEC
32612: ST_TO_ADDR
32613: LD_INT 5
32615: PUSH
32616: FOR_TO
32617: IFFALSE 32731
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32619: LD_ADDR_VAR 0 11
32623: PUSH
32624: LD_VAR 0 13
32628: PPUSH
32629: CALL_OW 250
32633: PPUSH
32634: LD_VAR 0 10
32638: PPUSH
32639: LD_INT 2
32641: PPUSH
32642: CALL_OW 272
32646: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32647: LD_ADDR_VAR 0 12
32651: PUSH
32652: LD_VAR 0 13
32656: PPUSH
32657: CALL_OW 251
32661: PPUSH
32662: LD_VAR 0 10
32666: PPUSH
32667: LD_INT 2
32669: PPUSH
32670: CALL_OW 273
32674: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32675: LD_VAR 0 11
32679: PPUSH
32680: LD_VAR 0 12
32684: PPUSH
32685: CALL_OW 488
32689: PUSH
32690: LD_VAR 0 11
32694: PPUSH
32695: LD_VAR 0 12
32699: PPUSH
32700: CALL_OW 428
32704: NOT
32705: AND
32706: IFFALSE 32729
// begin ComMoveXY ( tmp , _x , _y ) ;
32708: LD_VAR 0 13
32712: PPUSH
32713: LD_VAR 0 11
32717: PPUSH
32718: LD_VAR 0 12
32722: PPUSH
32723: CALL_OW 111
// break ;
32727: GO 32731
// end ; end ;
32729: GO 32616
32731: POP
32732: POP
// end ; end ;
32733: GO 32058
32735: POP
32736: POP
// end ;
32737: LD_VAR 0 8
32741: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32742: LD_INT 0
32744: PPUSH
// result := true ;
32745: LD_ADDR_VAR 0 3
32749: PUSH
32750: LD_INT 1
32752: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32753: LD_VAR 0 2
32757: PUSH
32758: LD_INT 24
32760: DOUBLE
32761: EQUAL
32762: IFTRUE 32772
32764: LD_INT 33
32766: DOUBLE
32767: EQUAL
32768: IFTRUE 32772
32770: GO 32797
32772: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32773: LD_ADDR_VAR 0 3
32777: PUSH
32778: LD_INT 32
32780: PPUSH
32781: LD_VAR 0 1
32785: PPUSH
32786: CALL_OW 321
32790: PUSH
32791: LD_INT 2
32793: EQUAL
32794: ST_TO_ADDR
32795: GO 33113
32797: LD_INT 20
32799: DOUBLE
32800: EQUAL
32801: IFTRUE 32805
32803: GO 32830
32805: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32806: LD_ADDR_VAR 0 3
32810: PUSH
32811: LD_INT 6
32813: PPUSH
32814: LD_VAR 0 1
32818: PPUSH
32819: CALL_OW 321
32823: PUSH
32824: LD_INT 2
32826: EQUAL
32827: ST_TO_ADDR
32828: GO 33113
32830: LD_INT 22
32832: DOUBLE
32833: EQUAL
32834: IFTRUE 32844
32836: LD_INT 36
32838: DOUBLE
32839: EQUAL
32840: IFTRUE 32844
32842: GO 32869
32844: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32845: LD_ADDR_VAR 0 3
32849: PUSH
32850: LD_INT 15
32852: PPUSH
32853: LD_VAR 0 1
32857: PPUSH
32858: CALL_OW 321
32862: PUSH
32863: LD_INT 2
32865: EQUAL
32866: ST_TO_ADDR
32867: GO 33113
32869: LD_INT 30
32871: DOUBLE
32872: EQUAL
32873: IFTRUE 32877
32875: GO 32902
32877: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32878: LD_ADDR_VAR 0 3
32882: PUSH
32883: LD_INT 20
32885: PPUSH
32886: LD_VAR 0 1
32890: PPUSH
32891: CALL_OW 321
32895: PUSH
32896: LD_INT 2
32898: EQUAL
32899: ST_TO_ADDR
32900: GO 33113
32902: LD_INT 28
32904: DOUBLE
32905: EQUAL
32906: IFTRUE 32916
32908: LD_INT 21
32910: DOUBLE
32911: EQUAL
32912: IFTRUE 32916
32914: GO 32941
32916: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32917: LD_ADDR_VAR 0 3
32921: PUSH
32922: LD_INT 21
32924: PPUSH
32925: LD_VAR 0 1
32929: PPUSH
32930: CALL_OW 321
32934: PUSH
32935: LD_INT 2
32937: EQUAL
32938: ST_TO_ADDR
32939: GO 33113
32941: LD_INT 16
32943: DOUBLE
32944: EQUAL
32945: IFTRUE 32949
32947: GO 32974
32949: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32950: LD_ADDR_VAR 0 3
32954: PUSH
32955: LD_INT 84
32957: PPUSH
32958: LD_VAR 0 1
32962: PPUSH
32963: CALL_OW 321
32967: PUSH
32968: LD_INT 2
32970: EQUAL
32971: ST_TO_ADDR
32972: GO 33113
32974: LD_INT 19
32976: DOUBLE
32977: EQUAL
32978: IFTRUE 32988
32980: LD_INT 23
32982: DOUBLE
32983: EQUAL
32984: IFTRUE 32988
32986: GO 33013
32988: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32989: LD_ADDR_VAR 0 3
32993: PUSH
32994: LD_INT 83
32996: PPUSH
32997: LD_VAR 0 1
33001: PPUSH
33002: CALL_OW 321
33006: PUSH
33007: LD_INT 2
33009: EQUAL
33010: ST_TO_ADDR
33011: GO 33113
33013: LD_INT 17
33015: DOUBLE
33016: EQUAL
33017: IFTRUE 33021
33019: GO 33046
33021: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
33022: LD_ADDR_VAR 0 3
33026: PUSH
33027: LD_INT 39
33029: PPUSH
33030: LD_VAR 0 1
33034: PPUSH
33035: CALL_OW 321
33039: PUSH
33040: LD_INT 2
33042: EQUAL
33043: ST_TO_ADDR
33044: GO 33113
33046: LD_INT 18
33048: DOUBLE
33049: EQUAL
33050: IFTRUE 33054
33052: GO 33079
33054: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
33055: LD_ADDR_VAR 0 3
33059: PUSH
33060: LD_INT 40
33062: PPUSH
33063: LD_VAR 0 1
33067: PPUSH
33068: CALL_OW 321
33072: PUSH
33073: LD_INT 2
33075: EQUAL
33076: ST_TO_ADDR
33077: GO 33113
33079: LD_INT 27
33081: DOUBLE
33082: EQUAL
33083: IFTRUE 33087
33085: GO 33112
33087: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
33088: LD_ADDR_VAR 0 3
33092: PUSH
33093: LD_INT 35
33095: PPUSH
33096: LD_VAR 0 1
33100: PPUSH
33101: CALL_OW 321
33105: PUSH
33106: LD_INT 2
33108: EQUAL
33109: ST_TO_ADDR
33110: GO 33113
33112: POP
// end ;
33113: LD_VAR 0 3
33117: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
33118: LD_INT 0
33120: PPUSH
33121: PPUSH
33122: PPUSH
33123: PPUSH
33124: PPUSH
33125: PPUSH
33126: PPUSH
33127: PPUSH
33128: PPUSH
33129: PPUSH
33130: PPUSH
// result := false ;
33131: LD_ADDR_VAR 0 6
33135: PUSH
33136: LD_INT 0
33138: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
33139: LD_VAR 0 1
33143: NOT
33144: PUSH
33145: LD_VAR 0 1
33149: PPUSH
33150: CALL_OW 266
33154: PUSH
33155: LD_INT 0
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: IN
33165: NOT
33166: OR
33167: PUSH
33168: LD_VAR 0 2
33172: NOT
33173: OR
33174: PUSH
33175: LD_VAR 0 5
33179: PUSH
33180: LD_INT 0
33182: PUSH
33183: LD_INT 1
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: LD_INT 3
33191: PUSH
33192: LD_INT 4
33194: PUSH
33195: LD_INT 5
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: IN
33206: NOT
33207: OR
33208: PUSH
33209: LD_VAR 0 3
33213: PPUSH
33214: LD_VAR 0 4
33218: PPUSH
33219: CALL_OW 488
33223: NOT
33224: OR
33225: IFFALSE 33229
// exit ;
33227: GO 33965
// side := GetSide ( depot ) ;
33229: LD_ADDR_VAR 0 9
33233: PUSH
33234: LD_VAR 0 1
33238: PPUSH
33239: CALL_OW 255
33243: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33244: LD_VAR 0 9
33248: PPUSH
33249: LD_VAR 0 2
33253: PPUSH
33254: CALL 32742 0 2
33258: NOT
33259: IFFALSE 33263
// exit ;
33261: GO 33965
// pom := GetBase ( depot ) ;
33263: LD_ADDR_VAR 0 10
33267: PUSH
33268: LD_VAR 0 1
33272: PPUSH
33273: CALL_OW 274
33277: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33278: LD_ADDR_VAR 0 11
33282: PUSH
33283: LD_VAR 0 2
33287: PPUSH
33288: LD_VAR 0 1
33292: PPUSH
33293: CALL_OW 248
33297: PPUSH
33298: CALL_OW 450
33302: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33303: LD_VAR 0 10
33307: PPUSH
33308: LD_INT 1
33310: PPUSH
33311: CALL_OW 275
33315: PUSH
33316: LD_VAR 0 11
33320: PUSH
33321: LD_INT 1
33323: ARRAY
33324: GREATEREQUAL
33325: PUSH
33326: LD_VAR 0 10
33330: PPUSH
33331: LD_INT 2
33333: PPUSH
33334: CALL_OW 275
33338: PUSH
33339: LD_VAR 0 11
33343: PUSH
33344: LD_INT 2
33346: ARRAY
33347: GREATEREQUAL
33348: AND
33349: PUSH
33350: LD_VAR 0 10
33354: PPUSH
33355: LD_INT 3
33357: PPUSH
33358: CALL_OW 275
33362: PUSH
33363: LD_VAR 0 11
33367: PUSH
33368: LD_INT 3
33370: ARRAY
33371: GREATEREQUAL
33372: AND
33373: NOT
33374: IFFALSE 33378
// exit ;
33376: GO 33965
// if GetBType ( depot ) = b_depot then
33378: LD_VAR 0 1
33382: PPUSH
33383: CALL_OW 266
33387: PUSH
33388: LD_INT 0
33390: EQUAL
33391: IFFALSE 33403
// dist := 28 else
33393: LD_ADDR_VAR 0 14
33397: PUSH
33398: LD_INT 28
33400: ST_TO_ADDR
33401: GO 33411
// dist := 36 ;
33403: LD_ADDR_VAR 0 14
33407: PUSH
33408: LD_INT 36
33410: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33411: LD_VAR 0 1
33415: PPUSH
33416: LD_VAR 0 3
33420: PPUSH
33421: LD_VAR 0 4
33425: PPUSH
33426: CALL_OW 297
33430: PUSH
33431: LD_VAR 0 14
33435: GREATER
33436: IFFALSE 33440
// exit ;
33438: GO 33965
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33440: LD_ADDR_VAR 0 12
33444: PUSH
33445: LD_VAR 0 2
33449: PPUSH
33450: LD_VAR 0 3
33454: PPUSH
33455: LD_VAR 0 4
33459: PPUSH
33460: LD_VAR 0 5
33464: PPUSH
33465: LD_VAR 0 1
33469: PPUSH
33470: CALL_OW 248
33474: PPUSH
33475: LD_INT 0
33477: PPUSH
33478: CALL 33970 0 6
33482: ST_TO_ADDR
// if not hexes then
33483: LD_VAR 0 12
33487: NOT
33488: IFFALSE 33492
// exit ;
33490: GO 33965
// hex := GetHexInfo ( x , y ) ;
33492: LD_ADDR_VAR 0 15
33496: PUSH
33497: LD_VAR 0 3
33501: PPUSH
33502: LD_VAR 0 4
33506: PPUSH
33507: CALL_OW 546
33511: ST_TO_ADDR
// if hex [ 1 ] then
33512: LD_VAR 0 15
33516: PUSH
33517: LD_INT 1
33519: ARRAY
33520: IFFALSE 33524
// exit ;
33522: GO 33965
// height := hex [ 2 ] ;
33524: LD_ADDR_VAR 0 13
33528: PUSH
33529: LD_VAR 0 15
33533: PUSH
33534: LD_INT 2
33536: ARRAY
33537: ST_TO_ADDR
// for i = 1 to hexes do
33538: LD_ADDR_VAR 0 7
33542: PUSH
33543: DOUBLE
33544: LD_INT 1
33546: DEC
33547: ST_TO_ADDR
33548: LD_VAR 0 12
33552: PUSH
33553: FOR_TO
33554: IFFALSE 33884
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33556: LD_VAR 0 12
33560: PUSH
33561: LD_VAR 0 7
33565: ARRAY
33566: PUSH
33567: LD_INT 1
33569: ARRAY
33570: PPUSH
33571: LD_VAR 0 12
33575: PUSH
33576: LD_VAR 0 7
33580: ARRAY
33581: PUSH
33582: LD_INT 2
33584: ARRAY
33585: PPUSH
33586: CALL_OW 488
33590: NOT
33591: PUSH
33592: LD_VAR 0 12
33596: PUSH
33597: LD_VAR 0 7
33601: ARRAY
33602: PUSH
33603: LD_INT 1
33605: ARRAY
33606: PPUSH
33607: LD_VAR 0 12
33611: PUSH
33612: LD_VAR 0 7
33616: ARRAY
33617: PUSH
33618: LD_INT 2
33620: ARRAY
33621: PPUSH
33622: CALL_OW 428
33626: PUSH
33627: LD_INT 0
33629: GREATER
33630: OR
33631: PUSH
33632: LD_VAR 0 12
33636: PUSH
33637: LD_VAR 0 7
33641: ARRAY
33642: PUSH
33643: LD_INT 1
33645: ARRAY
33646: PPUSH
33647: LD_VAR 0 12
33651: PUSH
33652: LD_VAR 0 7
33656: ARRAY
33657: PUSH
33658: LD_INT 2
33660: ARRAY
33661: PPUSH
33662: CALL_OW 351
33666: OR
33667: IFFALSE 33673
// exit ;
33669: POP
33670: POP
33671: GO 33965
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33673: LD_ADDR_VAR 0 8
33677: PUSH
33678: LD_VAR 0 12
33682: PUSH
33683: LD_VAR 0 7
33687: ARRAY
33688: PUSH
33689: LD_INT 1
33691: ARRAY
33692: PPUSH
33693: LD_VAR 0 12
33697: PUSH
33698: LD_VAR 0 7
33702: ARRAY
33703: PUSH
33704: LD_INT 2
33706: ARRAY
33707: PPUSH
33708: CALL_OW 546
33712: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33713: LD_VAR 0 8
33717: PUSH
33718: LD_INT 1
33720: ARRAY
33721: PUSH
33722: LD_VAR 0 8
33726: PUSH
33727: LD_INT 2
33729: ARRAY
33730: PUSH
33731: LD_VAR 0 13
33735: PUSH
33736: LD_INT 2
33738: PLUS
33739: GREATER
33740: OR
33741: PUSH
33742: LD_VAR 0 8
33746: PUSH
33747: LD_INT 2
33749: ARRAY
33750: PUSH
33751: LD_VAR 0 13
33755: PUSH
33756: LD_INT 2
33758: MINUS
33759: LESS
33760: OR
33761: PUSH
33762: LD_VAR 0 8
33766: PUSH
33767: LD_INT 3
33769: ARRAY
33770: PUSH
33771: LD_INT 0
33773: PUSH
33774: LD_INT 8
33776: PUSH
33777: LD_INT 9
33779: PUSH
33780: LD_INT 10
33782: PUSH
33783: LD_INT 11
33785: PUSH
33786: LD_INT 12
33788: PUSH
33789: LD_INT 13
33791: PUSH
33792: LD_INT 16
33794: PUSH
33795: LD_INT 17
33797: PUSH
33798: LD_INT 18
33800: PUSH
33801: LD_INT 19
33803: PUSH
33804: LD_INT 20
33806: PUSH
33807: LD_INT 21
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: IN
33825: NOT
33826: OR
33827: PUSH
33828: LD_VAR 0 8
33832: PUSH
33833: LD_INT 5
33835: ARRAY
33836: NOT
33837: OR
33838: PUSH
33839: LD_VAR 0 8
33843: PUSH
33844: LD_INT 6
33846: ARRAY
33847: PUSH
33848: LD_INT 1
33850: PUSH
33851: LD_INT 2
33853: PUSH
33854: LD_INT 7
33856: PUSH
33857: LD_INT 9
33859: PUSH
33860: LD_INT 10
33862: PUSH
33863: LD_INT 11
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: IN
33874: NOT
33875: OR
33876: IFFALSE 33882
// exit ;
33878: POP
33879: POP
33880: GO 33965
// end ;
33882: GO 33553
33884: POP
33885: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33886: LD_VAR 0 9
33890: PPUSH
33891: LD_VAR 0 3
33895: PPUSH
33896: LD_VAR 0 4
33900: PPUSH
33901: LD_INT 20
33903: PPUSH
33904: CALL 25917 0 4
33908: PUSH
33909: LD_INT 4
33911: ARRAY
33912: IFFALSE 33916
// exit ;
33914: GO 33965
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33916: LD_VAR 0 2
33920: PUSH
33921: LD_INT 29
33923: PUSH
33924: LD_INT 30
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: IN
33931: PUSH
33932: LD_VAR 0 3
33936: PPUSH
33937: LD_VAR 0 4
33941: PPUSH
33942: LD_VAR 0 9
33946: PPUSH
33947: CALL_OW 440
33951: NOT
33952: AND
33953: IFFALSE 33957
// exit ;
33955: GO 33965
// result := true ;
33957: LD_ADDR_VAR 0 6
33961: PUSH
33962: LD_INT 1
33964: ST_TO_ADDR
// end ;
33965: LD_VAR 0 6
33969: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33970: LD_INT 0
33972: PPUSH
33973: PPUSH
33974: PPUSH
33975: PPUSH
33976: PPUSH
33977: PPUSH
33978: PPUSH
33979: PPUSH
33980: PPUSH
33981: PPUSH
33982: PPUSH
33983: PPUSH
33984: PPUSH
33985: PPUSH
33986: PPUSH
33987: PPUSH
33988: PPUSH
33989: PPUSH
33990: PPUSH
33991: PPUSH
33992: PPUSH
33993: PPUSH
33994: PPUSH
33995: PPUSH
33996: PPUSH
33997: PPUSH
33998: PPUSH
33999: PPUSH
34000: PPUSH
34001: PPUSH
34002: PPUSH
34003: PPUSH
34004: PPUSH
34005: PPUSH
34006: PPUSH
34007: PPUSH
34008: PPUSH
34009: PPUSH
34010: PPUSH
34011: PPUSH
34012: PPUSH
34013: PPUSH
34014: PPUSH
34015: PPUSH
34016: PPUSH
34017: PPUSH
34018: PPUSH
34019: PPUSH
34020: PPUSH
34021: PPUSH
34022: PPUSH
34023: PPUSH
34024: PPUSH
34025: PPUSH
34026: PPUSH
34027: PPUSH
34028: PPUSH
34029: PPUSH
// result = [ ] ;
34030: LD_ADDR_VAR 0 7
34034: PUSH
34035: EMPTY
34036: ST_TO_ADDR
// temp_list = [ ] ;
34037: LD_ADDR_VAR 0 9
34041: PUSH
34042: EMPTY
34043: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
34044: LD_VAR 0 4
34048: PUSH
34049: LD_INT 0
34051: PUSH
34052: LD_INT 1
34054: PUSH
34055: LD_INT 2
34057: PUSH
34058: LD_INT 3
34060: PUSH
34061: LD_INT 4
34063: PUSH
34064: LD_INT 5
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: IN
34075: NOT
34076: PUSH
34077: LD_VAR 0 1
34081: PUSH
34082: LD_INT 0
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: IN
34092: PUSH
34093: LD_VAR 0 5
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: LD_INT 2
34103: PUSH
34104: LD_INT 3
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: LIST
34111: IN
34112: NOT
34113: AND
34114: OR
34115: IFFALSE 34119
// exit ;
34117: GO 52510
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
34119: LD_VAR 0 1
34123: PUSH
34124: LD_INT 6
34126: PUSH
34127: LD_INT 7
34129: PUSH
34130: LD_INT 8
34132: PUSH
34133: LD_INT 13
34135: PUSH
34136: LD_INT 12
34138: PUSH
34139: LD_INT 15
34141: PUSH
34142: LD_INT 11
34144: PUSH
34145: LD_INT 14
34147: PUSH
34148: LD_INT 10
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: IN
34162: IFFALSE 34172
// btype = b_lab ;
34164: LD_ADDR_VAR 0 1
34168: PUSH
34169: LD_INT 6
34171: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34172: LD_VAR 0 6
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: LD_INT 1
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: LIST
34190: IN
34191: NOT
34192: PUSH
34193: LD_VAR 0 1
34197: PUSH
34198: LD_INT 0
34200: PUSH
34201: LD_INT 1
34203: PUSH
34204: LD_INT 2
34206: PUSH
34207: LD_INT 3
34209: PUSH
34210: LD_INT 6
34212: PUSH
34213: LD_INT 36
34215: PUSH
34216: LD_INT 4
34218: PUSH
34219: LD_INT 5
34221: PUSH
34222: LD_INT 31
34224: PUSH
34225: LD_INT 32
34227: PUSH
34228: LD_INT 33
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: IN
34244: NOT
34245: PUSH
34246: LD_VAR 0 6
34250: PUSH
34251: LD_INT 1
34253: EQUAL
34254: AND
34255: OR
34256: PUSH
34257: LD_VAR 0 1
34261: PUSH
34262: LD_INT 2
34264: PUSH
34265: LD_INT 3
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: IN
34272: NOT
34273: PUSH
34274: LD_VAR 0 6
34278: PUSH
34279: LD_INT 2
34281: EQUAL
34282: AND
34283: OR
34284: IFFALSE 34294
// mode = 0 ;
34286: LD_ADDR_VAR 0 6
34290: PUSH
34291: LD_INT 0
34293: ST_TO_ADDR
// case mode of 0 :
34294: LD_VAR 0 6
34298: PUSH
34299: LD_INT 0
34301: DOUBLE
34302: EQUAL
34303: IFTRUE 34307
34305: GO 45760
34307: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34308: LD_ADDR_VAR 0 11
34312: PUSH
34313: LD_INT 0
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: LD_INT 1
34328: NEG
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 1
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 1
34377: NEG
34378: PUSH
34379: LD_INT 1
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: NEG
34390: PUSH
34391: LD_INT 2
34393: NEG
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: LD_INT 2
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 1
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 2
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: LD_INT 2
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 1
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: PUSH
34455: LD_INT 3
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: LD_INT 3
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: LD_INT 2
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34501: LD_ADDR_VAR 0 12
34505: PUSH
34506: LD_INT 0
34508: PUSH
34509: LD_INT 0
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 0
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 1
34539: PUSH
34540: LD_INT 1
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 0
34549: PUSH
34550: LD_INT 1
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: LD_INT 0
34563: PUSH
34564: EMPTY
34565: LIST
34566: LIST
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: LD_INT 1
34574: NEG
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 1
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 2
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: PUSH
34604: LD_INT 1
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: LD_INT 1
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 2
34624: NEG
34625: PUSH
34626: LD_INT 0
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 2
34635: NEG
34636: PUSH
34637: LD_INT 1
34639: NEG
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: NEG
34648: PUSH
34649: LD_INT 1
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 3
34658: NEG
34659: PUSH
34660: LD_INT 0
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 3
34669: NEG
34670: PUSH
34671: LD_INT 1
34673: NEG
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34697: LD_ADDR_VAR 0 13
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 0
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 1
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 1
34778: NEG
34779: PUSH
34780: LD_INT 2
34782: NEG
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 2
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: LD_INT 2
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 1
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 2
34820: NEG
34821: PUSH
34822: LD_INT 1
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 2
34832: NEG
34833: PUSH
34834: LD_INT 2
34836: NEG
34837: PUSH
34838: EMPTY
34839: LIST
34840: LIST
34841: PUSH
34842: LD_INT 2
34844: NEG
34845: PUSH
34846: LD_INT 3
34848: NEG
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 3
34856: NEG
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 3
34868: NEG
34869: PUSH
34870: LD_INT 3
34872: NEG
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: LIST
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34896: LD_ADDR_VAR 0 14
34900: PUSH
34901: LD_INT 0
34903: PUSH
34904: LD_INT 0
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: LD_INT 1
34916: NEG
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 1
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 1
34934: PUSH
34935: LD_INT 1
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 0
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 1
34965: NEG
34966: PUSH
34967: LD_INT 1
34969: NEG
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: LD_INT 2
34981: NEG
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 0
34989: PUSH
34990: LD_INT 2
34992: NEG
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: LD_INT 1
35000: PUSH
35001: LD_INT 1
35003: NEG
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 1
35011: PUSH
35012: LD_INT 2
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: LD_INT 2
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 1
35031: NEG
35032: PUSH
35033: LD_INT 1
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 3
35046: NEG
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 0
35054: PUSH
35055: LD_INT 3
35057: NEG
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 1
35065: PUSH
35066: LD_INT 2
35068: NEG
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35092: LD_ADDR_VAR 0 15
35096: PUSH
35097: LD_INT 0
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 0
35109: PUSH
35110: LD_INT 1
35112: NEG
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: PUSH
35121: LD_INT 0
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 1
35130: PUSH
35131: LD_INT 1
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 1
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: NEG
35151: PUSH
35152: LD_INT 0
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: NEG
35162: PUSH
35163: LD_INT 1
35165: NEG
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: LD_INT 1
35176: NEG
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 2
35184: PUSH
35185: LD_INT 0
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 1
35204: NEG
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 2
35215: NEG
35216: PUSH
35217: LD_INT 0
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 2
35226: NEG
35227: PUSH
35228: LD_INT 1
35230: NEG
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 2
35238: PUSH
35239: LD_INT 1
35241: NEG
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 3
35249: PUSH
35250: LD_INT 0
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 3
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35285: LD_ADDR_VAR 0 16
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 2
35378: PUSH
35379: LD_INT 1
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PUSH
35386: LD_INT 2
35388: PUSH
35389: LD_INT 2
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: LD_INT 2
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: PUSH
35406: LD_INT 2
35408: NEG
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: NEG
35421: PUSH
35422: LD_INT 2
35424: NEG
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 3
35432: PUSH
35433: LD_INT 2
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 3
35442: PUSH
35443: LD_INT 3
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 2
35452: PUSH
35453: LD_INT 3
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35478: LD_ADDR_VAR 0 17
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: LD_INT 1
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 0
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 1
35547: NEG
35548: PUSH
35549: LD_INT 1
35551: NEG
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: LD_INT 2
35563: NEG
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: LD_INT 2
35574: NEG
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 1
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 2
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: PUSH
35614: LD_INT 2
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 1
35623: PUSH
35624: LD_INT 2
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: LD_INT 2
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: LD_INT 1
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 2
35654: NEG
35655: PUSH
35656: LD_INT 0
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 2
35665: NEG
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 2
35677: NEG
35678: PUSH
35679: LD_INT 2
35681: NEG
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: LIST
35691: LIST
35692: LIST
35693: LIST
35694: LIST
35695: LIST
35696: LIST
35697: LIST
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35708: LD_ADDR_VAR 0 18
35712: PUSH
35713: LD_INT 0
35715: PUSH
35716: LD_INT 0
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 0
35725: PUSH
35726: LD_INT 1
35728: NEG
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 1
35736: PUSH
35737: LD_INT 0
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: LD_INT 1
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: LD_INT 1
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: LD_INT 0
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 1
35777: NEG
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: LD_INT 2
35793: NEG
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 2
35804: NEG
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 2
35823: PUSH
35824: LD_INT 0
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: PUSH
35844: LD_INT 2
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: PUSH
35854: LD_INT 2
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 2
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: NEG
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 2
35884: NEG
35885: PUSH
35886: LD_INT 0
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 2
35895: NEG
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 2
35907: NEG
35908: PUSH
35909: LD_INT 2
35911: NEG
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35938: LD_ADDR_VAR 0 19
35942: PUSH
35943: LD_INT 0
35945: PUSH
35946: LD_INT 0
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PUSH
35953: LD_INT 0
35955: PUSH
35956: LD_INT 1
35958: NEG
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 1
35966: PUSH
35967: LD_INT 0
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 1
35976: PUSH
35977: LD_INT 1
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: LD_INT 1
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 1
36007: NEG
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 1
36019: NEG
36020: PUSH
36021: LD_INT 2
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 0
36031: PUSH
36032: LD_INT 2
36034: NEG
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 1
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 2
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 2
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: LD_INT 2
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 1
36083: PUSH
36084: LD_INT 2
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: LD_INT 2
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 1
36103: NEG
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 2
36114: NEG
36115: PUSH
36116: LD_INT 0
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 2
36125: NEG
36126: PUSH
36127: LD_INT 1
36129: NEG
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 2
36137: NEG
36138: PUSH
36139: LD_INT 2
36141: NEG
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36168: LD_ADDR_VAR 0 20
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 0
36185: PUSH
36186: LD_INT 1
36188: NEG
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 1
36196: PUSH
36197: LD_INT 0
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 1
36206: PUSH
36207: LD_INT 1
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 1
36226: NEG
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: NEG
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 1
36249: NEG
36250: PUSH
36251: LD_INT 2
36253: NEG
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 0
36261: PUSH
36262: LD_INT 2
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 1
36272: PUSH
36273: LD_INT 1
36275: NEG
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 2
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: LD_INT 1
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 2
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: PUSH
36314: LD_INT 2
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: LD_INT 2
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 1
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 2
36344: NEG
36345: PUSH
36346: LD_INT 0
36348: PUSH
36349: EMPTY
36350: LIST
36351: LIST
36352: PUSH
36353: LD_INT 2
36355: NEG
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 2
36367: NEG
36368: PUSH
36369: LD_INT 2
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: LIST
36381: LIST
36382: LIST
36383: LIST
36384: LIST
36385: LIST
36386: LIST
36387: LIST
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36398: LD_ADDR_VAR 0 21
36402: PUSH
36403: LD_INT 0
36405: PUSH
36406: LD_INT 0
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 0
36415: PUSH
36416: LD_INT 1
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 1
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: LD_INT 1
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 0
36446: PUSH
36447: LD_INT 1
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 1
36456: NEG
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: PUSH
36465: LD_INT 1
36467: NEG
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: EMPTY
36474: LIST
36475: LIST
36476: PUSH
36477: LD_INT 1
36479: NEG
36480: PUSH
36481: LD_INT 2
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: LD_INT 2
36494: NEG
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: LD_INT 1
36505: NEG
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 2
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 2
36523: PUSH
36524: LD_INT 1
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 2
36533: PUSH
36534: LD_INT 2
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 1
36543: PUSH
36544: LD_INT 2
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 0
36553: PUSH
36554: LD_INT 2
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: LD_INT 1
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 2
36574: NEG
36575: PUSH
36576: LD_INT 0
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 2
36585: NEG
36586: PUSH
36587: LD_INT 1
36589: NEG
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 2
36597: NEG
36598: PUSH
36599: LD_INT 2
36601: NEG
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36628: LD_ADDR_VAR 0 22
36632: PUSH
36633: LD_INT 0
36635: PUSH
36636: LD_INT 0
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: PUSH
36657: LD_INT 0
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 1
36666: PUSH
36667: LD_INT 1
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: LD_INT 1
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 1
36686: NEG
36687: PUSH
36688: LD_INT 0
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 1
36697: NEG
36698: PUSH
36699: LD_INT 1
36701: NEG
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 1
36709: NEG
36710: PUSH
36711: LD_INT 2
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 0
36721: PUSH
36722: LD_INT 2
36724: NEG
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: LD_INT 1
36735: NEG
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: PUSH
36741: LD_INT 2
36743: PUSH
36744: LD_INT 0
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 2
36753: PUSH
36754: LD_INT 1
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: LD_INT 2
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 1
36773: PUSH
36774: LD_INT 2
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: LD_INT 2
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 1
36793: NEG
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 2
36804: NEG
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 2
36815: NEG
36816: PUSH
36817: LD_INT 1
36819: NEG
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 2
36827: NEG
36828: PUSH
36829: LD_INT 2
36831: NEG
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36858: LD_ADDR_VAR 0 23
36862: PUSH
36863: LD_INT 0
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 1
36886: PUSH
36887: LD_INT 0
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: LD_INT 1
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 0
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 1
36916: NEG
36917: PUSH
36918: LD_INT 0
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 1
36927: NEG
36928: PUSH
36929: LD_INT 1
36931: NEG
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 1
36939: NEG
36940: PUSH
36941: LD_INT 2
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 0
36951: PUSH
36952: LD_INT 2
36954: NEG
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 1
36962: PUSH
36963: LD_INT 1
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 2
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 2
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 2
36993: PUSH
36994: LD_INT 2
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: LD_INT 2
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: LD_INT 2
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 1
37023: NEG
37024: PUSH
37025: LD_INT 1
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 2
37034: NEG
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 2
37045: NEG
37046: PUSH
37047: LD_INT 1
37049: NEG
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: LD_INT 2
37057: NEG
37058: PUSH
37059: LD_INT 2
37061: NEG
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 2
37069: NEG
37070: PUSH
37071: LD_INT 3
37073: NEG
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 1
37081: NEG
37082: PUSH
37083: LD_INT 3
37085: NEG
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 1
37093: PUSH
37094: LD_INT 2
37096: NEG
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 2
37104: PUSH
37105: LD_INT 1
37107: NEG
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
37138: LD_ADDR_VAR 0 24
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: LD_INT 0
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: LD_INT 1
37158: NEG
37159: PUSH
37160: EMPTY
37161: LIST
37162: LIST
37163: PUSH
37164: LD_INT 1
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 1
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: LD_INT 0
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 1
37207: NEG
37208: PUSH
37209: LD_INT 1
37211: NEG
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: LD_INT 2
37223: NEG
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 2
37234: NEG
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: LD_INT 1
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 2
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 2
37263: PUSH
37264: LD_INT 1
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 2
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 1
37283: PUSH
37284: LD_INT 2
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 0
37293: PUSH
37294: LD_INT 2
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 1
37303: NEG
37304: PUSH
37305: LD_INT 1
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 2
37314: NEG
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 2
37325: NEG
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 2
37337: NEG
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 1
37349: PUSH
37350: LD_INT 2
37352: NEG
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 2
37360: PUSH
37361: LD_INT 1
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 3
37371: PUSH
37372: LD_INT 1
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 3
37381: PUSH
37382: LD_INT 2
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37414: LD_ADDR_VAR 0 25
37418: PUSH
37419: LD_INT 0
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 0
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 1
37442: PUSH
37443: LD_INT 0
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 1
37452: PUSH
37453: LD_INT 1
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 0
37462: PUSH
37463: LD_INT 1
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 1
37483: NEG
37484: PUSH
37485: LD_INT 1
37487: NEG
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 1
37495: NEG
37496: PUSH
37497: LD_INT 2
37499: NEG
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 0
37507: PUSH
37508: LD_INT 2
37510: NEG
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 1
37518: PUSH
37519: LD_INT 1
37521: NEG
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 2
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 2
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 2
37549: PUSH
37550: LD_INT 2
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: LD_INT 2
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 0
37569: PUSH
37570: LD_INT 2
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 1
37579: NEG
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 2
37590: NEG
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 2
37601: NEG
37602: PUSH
37603: LD_INT 1
37605: NEG
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 2
37613: NEG
37614: PUSH
37615: LD_INT 2
37617: NEG
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 3
37625: PUSH
37626: LD_INT 1
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 3
37635: PUSH
37636: LD_INT 2
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 2
37645: PUSH
37646: LD_INT 3
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: LD_INT 1
37655: PUSH
37656: LD_INT 3
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37688: LD_ADDR_VAR 0 26
37692: PUSH
37693: LD_INT 0
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 1
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 0
37736: PUSH
37737: LD_INT 1
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 1
37746: NEG
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: LD_INT 2
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: LD_INT 2
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 1
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 2
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 2
37813: PUSH
37814: LD_INT 1
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 2
37823: PUSH
37824: LD_INT 2
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 1
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: LD_INT 1
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 2
37864: NEG
37865: PUSH
37866: LD_INT 0
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 2
37875: NEG
37876: PUSH
37877: LD_INT 1
37879: NEG
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: LD_INT 2
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 2
37899: PUSH
37900: LD_INT 3
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 1
37909: PUSH
37910: LD_INT 3
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: NEG
37920: PUSH
37921: LD_INT 2
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 2
37930: NEG
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37964: LD_ADDR_VAR 0 27
37968: PUSH
37969: LD_INT 0
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 0
37981: PUSH
37982: LD_INT 1
37984: NEG
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 1
37992: PUSH
37993: LD_INT 0
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 1
38002: PUSH
38003: LD_INT 1
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 0
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 1
38022: NEG
38023: PUSH
38024: LD_INT 0
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 1
38033: NEG
38034: PUSH
38035: LD_INT 1
38037: NEG
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 1
38045: NEG
38046: PUSH
38047: LD_INT 2
38049: NEG
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 0
38057: PUSH
38058: LD_INT 2
38060: NEG
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 1
38068: PUSH
38069: LD_INT 1
38071: NEG
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 2
38079: PUSH
38080: LD_INT 0
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 2
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 2
38099: PUSH
38100: LD_INT 2
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: LD_INT 2
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 1
38129: NEG
38130: PUSH
38131: LD_INT 1
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 2
38140: NEG
38141: PUSH
38142: LD_INT 0
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 2
38163: NEG
38164: PUSH
38165: LD_INT 2
38167: NEG
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 1
38175: NEG
38176: PUSH
38177: LD_INT 2
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 2
38186: NEG
38187: PUSH
38188: LD_INT 1
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 3
38197: NEG
38198: PUSH
38199: LD_INT 1
38201: NEG
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 3
38209: NEG
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: LIST
38233: LIST
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38244: LD_ADDR_VAR 0 28
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: LD_INT 0
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 0
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 1
38272: PUSH
38273: LD_INT 0
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 1
38302: NEG
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: NEG
38314: PUSH
38315: LD_INT 1
38317: NEG
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: LD_INT 2
38329: NEG
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: LD_INT 2
38340: NEG
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 1
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 2
38359: PUSH
38360: LD_INT 0
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: LD_INT 2
38369: PUSH
38370: LD_INT 1
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 2
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 0
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 1
38409: NEG
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 2
38431: NEG
38432: PUSH
38433: LD_INT 1
38435: NEG
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 2
38455: NEG
38456: PUSH
38457: LD_INT 3
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 1
38467: NEG
38468: PUSH
38469: LD_INT 3
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 3
38479: NEG
38480: PUSH
38481: LD_INT 1
38483: NEG
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 3
38491: NEG
38492: PUSH
38493: LD_INT 2
38495: NEG
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38526: LD_ADDR_VAR 0 29
38530: PUSH
38531: LD_INT 0
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 0
38543: PUSH
38544: LD_INT 1
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: PUSH
38565: LD_INT 1
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 1
38595: NEG
38596: PUSH
38597: LD_INT 1
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 1
38607: NEG
38608: PUSH
38609: LD_INT 2
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: LD_INT 2
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 1
38630: PUSH
38631: LD_INT 1
38633: NEG
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: LD_INT 2
38641: PUSH
38642: LD_INT 0
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 2
38651: PUSH
38652: LD_INT 1
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: LD_INT 2
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: LD_INT 2
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 1
38681: NEG
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 2
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: NEG
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 2
38704: NEG
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 2
38716: NEG
38717: PUSH
38718: LD_INT 3
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 2
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 3
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 1
38749: PUSH
38750: LD_INT 3
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 1
38759: NEG
38760: PUSH
38761: LD_INT 2
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 3
38770: NEG
38771: PUSH
38772: LD_INT 2
38774: NEG
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38805: LD_ADDR_VAR 0 30
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: LD_INT 0
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 1
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: LD_INT 0
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 1
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 1
38863: NEG
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: NEG
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: LD_INT 2
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 2
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: PUSH
38921: LD_INT 0
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 2
38930: PUSH
38931: LD_INT 1
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: LD_INT 2
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: LD_INT 2
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 2
38971: NEG
38972: PUSH
38973: LD_INT 0
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 2
38982: NEG
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 1
38994: NEG
38995: PUSH
38996: LD_INT 3
38998: NEG
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 1
39006: PUSH
39007: LD_INT 2
39009: NEG
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 3
39017: PUSH
39018: LD_INT 2
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 2
39027: PUSH
39028: LD_INT 3
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 2
39037: NEG
39038: PUSH
39039: LD_INT 1
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 3
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39083: LD_ADDR_VAR 0 31
39087: PUSH
39088: LD_INT 0
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 1
39121: PUSH
39122: LD_INT 1
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 1
39152: NEG
39153: PUSH
39154: LD_INT 1
39156: NEG
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: LD_INT 2
39168: NEG
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: LD_INT 1
39179: NEG
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 2
39187: PUSH
39188: LD_INT 0
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 2
39197: PUSH
39198: LD_INT 1
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 2
39207: PUSH
39208: LD_INT 2
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 1
39217: PUSH
39218: LD_INT 2
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: LD_INT 2
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 1
39237: NEG
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 2
39248: NEG
39249: PUSH
39250: LD_INT 1
39252: NEG
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 2
39260: NEG
39261: PUSH
39262: LD_INT 2
39264: NEG
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: LD_INT 3
39276: NEG
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 3
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 1
39305: PUSH
39306: LD_INT 3
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: NEG
39316: PUSH
39317: LD_INT 2
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 3
39326: NEG
39327: PUSH
39328: LD_INT 2
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39361: LD_ADDR_VAR 0 32
39365: PUSH
39366: LD_INT 0
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 0
39378: PUSH
39379: LD_INT 1
39381: NEG
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: LD_INT 1
39389: PUSH
39390: LD_INT 0
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: LD_INT 1
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: LD_INT 0
39409: PUSH
39410: LD_INT 1
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: NEG
39420: PUSH
39421: LD_INT 0
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 1
39430: NEG
39431: PUSH
39432: LD_INT 1
39434: NEG
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 1
39442: NEG
39443: PUSH
39444: LD_INT 2
39446: NEG
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 0
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 1
39465: PUSH
39466: LD_INT 1
39468: NEG
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 2
39476: PUSH
39477: LD_INT 1
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: LD_INT 2
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 1
39496: PUSH
39497: LD_INT 2
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: LD_INT 2
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 1
39516: NEG
39517: PUSH
39518: LD_INT 1
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 2
39527: NEG
39528: PUSH
39529: LD_INT 0
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 2
39538: NEG
39539: PUSH
39540: LD_INT 1
39542: NEG
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 1
39550: NEG
39551: PUSH
39552: LD_INT 3
39554: NEG
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: LD_INT 1
39562: PUSH
39563: LD_INT 2
39565: NEG
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 3
39573: PUSH
39574: LD_INT 2
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 2
39583: PUSH
39584: LD_INT 3
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 2
39593: NEG
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 3
39604: NEG
39605: PUSH
39606: LD_INT 1
39608: NEG
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: EMPTY
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39639: LD_ADDR_VAR 0 33
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 0
39656: PUSH
39657: LD_INT 1
39659: NEG
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 1
39667: PUSH
39668: LD_INT 0
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 1
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: LD_INT 1
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: NEG
39698: PUSH
39699: LD_INT 0
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 1
39708: NEG
39709: PUSH
39710: LD_INT 1
39712: NEG
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: LD_INT 1
39720: NEG
39721: PUSH
39722: LD_INT 2
39724: NEG
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 1
39732: PUSH
39733: LD_INT 1
39735: NEG
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 2
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: LD_INT 1
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: LD_INT 2
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 1
39783: NEG
39784: PUSH
39785: LD_INT 1
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 2
39794: NEG
39795: PUSH
39796: LD_INT 0
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 2
39805: NEG
39806: PUSH
39807: LD_INT 1
39809: NEG
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 2
39817: NEG
39818: PUSH
39819: LD_INT 2
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 2
39829: NEG
39830: PUSH
39831: LD_INT 3
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 2
39841: PUSH
39842: LD_INT 1
39844: NEG
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 3
39852: PUSH
39853: LD_INT 1
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: PUSH
39863: LD_INT 3
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 1
39872: NEG
39873: PUSH
39874: LD_INT 2
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PUSH
39881: LD_INT 3
39883: NEG
39884: PUSH
39885: LD_INT 2
39887: NEG
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39918: LD_ADDR_VAR 0 34
39922: PUSH
39923: LD_INT 0
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: EMPTY
39930: LIST
39931: LIST
39932: PUSH
39933: LD_INT 0
39935: PUSH
39936: LD_INT 1
39938: NEG
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 1
39946: PUSH
39947: LD_INT 0
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 1
39956: PUSH
39957: LD_INT 1
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: LD_INT 1
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 1
39976: NEG
39977: PUSH
39978: LD_INT 0
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 1
39987: NEG
39988: PUSH
39989: LD_INT 1
39991: NEG
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 1
39999: NEG
40000: PUSH
40001: LD_INT 2
40003: NEG
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 0
40011: PUSH
40012: LD_INT 2
40014: NEG
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: PUSH
40023: LD_INT 1
40025: NEG
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 2
40033: PUSH
40034: LD_INT 1
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 2
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 1
40053: PUSH
40054: LD_INT 2
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: NEG
40064: PUSH
40065: LD_INT 1
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 2
40074: NEG
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: LD_INT 2
40097: NEG
40098: PUSH
40099: LD_INT 2
40101: NEG
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: PUSH
40107: LD_INT 1
40109: NEG
40110: PUSH
40111: LD_INT 3
40113: NEG
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 1
40121: PUSH
40122: LD_INT 2
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 3
40132: PUSH
40133: LD_INT 2
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 2
40142: PUSH
40143: LD_INT 3
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 2
40152: NEG
40153: PUSH
40154: LD_INT 1
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 3
40163: NEG
40164: PUSH
40165: LD_INT 1
40167: NEG
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40198: LD_ADDR_VAR 0 35
40202: PUSH
40203: LD_INT 0
40205: PUSH
40206: LD_INT 0
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 0
40215: PUSH
40216: LD_INT 1
40218: NEG
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 1
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 1
40236: PUSH
40237: LD_INT 1
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 0
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: NEG
40257: PUSH
40258: LD_INT 0
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 1
40267: NEG
40268: PUSH
40269: LD_INT 1
40271: NEG
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 2
40279: PUSH
40280: LD_INT 1
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 2
40289: NEG
40290: PUSH
40291: LD_INT 1
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40310: LD_ADDR_VAR 0 36
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: LD_INT 0
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: LD_INT 1
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 1
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 1
40348: PUSH
40349: LD_INT 1
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 0
40358: PUSH
40359: LD_INT 1
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 0
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 1
40391: NEG
40392: PUSH
40393: LD_INT 2
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 1
40403: PUSH
40404: LD_INT 2
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40422: LD_ADDR_VAR 0 37
40426: PUSH
40427: LD_INT 0
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: LD_INT 1
40442: NEG
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: PUSH
40451: LD_INT 0
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: PUSH
40461: LD_INT 1
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: LD_INT 0
40470: PUSH
40471: LD_INT 1
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: PUSH
40478: LD_INT 1
40480: NEG
40481: PUSH
40482: LD_INT 0
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: LD_INT 1
40495: NEG
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 1
40503: PUSH
40504: LD_INT 1
40506: NEG
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 1
40514: NEG
40515: PUSH
40516: LD_INT 1
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40534: LD_ADDR_VAR 0 38
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 0
40551: PUSH
40552: LD_INT 1
40554: NEG
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 1
40562: PUSH
40563: LD_INT 0
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 1
40572: PUSH
40573: LD_INT 1
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 0
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 1
40592: NEG
40593: PUSH
40594: LD_INT 0
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 1
40603: NEG
40604: PUSH
40605: LD_INT 1
40607: NEG
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 2
40615: PUSH
40616: LD_INT 1
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 2
40625: NEG
40626: PUSH
40627: LD_INT 1
40629: NEG
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40646: LD_ADDR_VAR 0 39
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: LD_INT 1
40666: NEG
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 1
40674: PUSH
40675: LD_INT 0
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 1
40684: PUSH
40685: LD_INT 1
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 0
40694: PUSH
40695: LD_INT 1
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 0
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 1
40715: NEG
40716: PUSH
40717: LD_INT 1
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 2
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: LD_INT 2
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40758: LD_ADDR_VAR 0 40
40762: PUSH
40763: LD_INT 0
40765: PUSH
40766: LD_INT 0
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: LD_INT 1
40778: NEG
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: LD_INT 1
40786: PUSH
40787: LD_INT 0
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 1
40796: PUSH
40797: LD_INT 1
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 0
40806: PUSH
40807: LD_INT 1
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 1
40816: NEG
40817: PUSH
40818: LD_INT 0
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 1
40827: NEG
40828: PUSH
40829: LD_INT 1
40831: NEG
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 1
40839: PUSH
40840: LD_INT 1
40842: NEG
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 1
40850: NEG
40851: PUSH
40852: LD_INT 1
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40870: LD_ADDR_VAR 0 41
40874: PUSH
40875: LD_INT 0
40877: PUSH
40878: LD_INT 0
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 0
40887: PUSH
40888: LD_INT 1
40890: NEG
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PUSH
40896: LD_INT 1
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 1
40908: PUSH
40909: LD_INT 1
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 0
40918: PUSH
40919: LD_INT 1
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 1
40928: NEG
40929: PUSH
40930: LD_INT 0
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: LD_INT 1
40943: NEG
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 1
40951: NEG
40952: PUSH
40953: LD_INT 2
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: PUSH
40964: LD_INT 1
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 2
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 2
40984: PUSH
40985: LD_INT 1
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 2
40994: PUSH
40995: LD_INT 2
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: PUSH
41005: LD_INT 2
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 1
41014: NEG
41015: PUSH
41016: LD_INT 1
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 2
41025: NEG
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: LD_INT 2
41036: NEG
41037: PUSH
41038: LD_INT 1
41040: NEG
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 2
41048: NEG
41049: PUSH
41050: LD_INT 2
41052: NEG
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 2
41060: NEG
41061: PUSH
41062: LD_INT 3
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 2
41072: PUSH
41073: LD_INT 1
41075: NEG
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 3
41083: PUSH
41084: LD_INT 0
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 3
41093: PUSH
41094: LD_INT 1
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: LD_INT 3
41103: PUSH
41104: LD_INT 2
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 3
41113: PUSH
41114: LD_INT 3
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 2
41123: PUSH
41124: LD_INT 3
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 2
41133: NEG
41134: PUSH
41135: LD_INT 1
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 3
41144: NEG
41145: PUSH
41146: LD_INT 0
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 3
41155: NEG
41156: PUSH
41157: LD_INT 1
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 3
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 3
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: LIST
41193: LIST
41194: LIST
41195: LIST
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41220: LD_ADDR_VAR 0 42
41224: PUSH
41225: LD_INT 0
41227: PUSH
41228: LD_INT 0
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 0
41237: PUSH
41238: LD_INT 1
41240: NEG
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 1
41248: PUSH
41249: LD_INT 0
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 1
41258: PUSH
41259: LD_INT 1
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 0
41268: PUSH
41269: LD_INT 1
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 1
41278: NEG
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 1
41289: NEG
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 1
41301: NEG
41302: PUSH
41303: LD_INT 2
41305: NEG
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 0
41313: PUSH
41314: LD_INT 2
41316: NEG
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 1
41324: PUSH
41325: LD_INT 1
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 2
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 2
41345: PUSH
41346: LD_INT 2
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 1
41355: PUSH
41356: LD_INT 2
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: LD_INT 2
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 1
41375: NEG
41376: PUSH
41377: LD_INT 1
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PUSH
41384: LD_INT 2
41386: NEG
41387: PUSH
41388: LD_INT 1
41390: NEG
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 2
41398: NEG
41399: PUSH
41400: LD_INT 2
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 2
41410: NEG
41411: PUSH
41412: LD_INT 3
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: LD_INT 0
41434: PUSH
41435: LD_INT 3
41437: NEG
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 1
41445: PUSH
41446: LD_INT 2
41448: NEG
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: LD_INT 3
41456: PUSH
41457: LD_INT 2
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 3
41466: PUSH
41467: LD_INT 3
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 2
41476: PUSH
41477: LD_INT 3
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 1
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: LD_INT 3
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 1
41506: NEG
41507: PUSH
41508: LD_INT 2
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 3
41517: NEG
41518: PUSH
41519: LD_INT 2
41521: NEG
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 3
41529: NEG
41530: PUSH
41531: LD_INT 3
41533: NEG
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41570: LD_ADDR_VAR 0 43
41574: PUSH
41575: LD_INT 0
41577: PUSH
41578: LD_INT 0
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 0
41587: PUSH
41588: LD_INT 1
41590: NEG
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 1
41598: PUSH
41599: LD_INT 0
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 1
41608: PUSH
41609: LD_INT 1
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: LD_INT 1
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 1
41628: NEG
41629: PUSH
41630: LD_INT 0
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 1
41639: NEG
41640: PUSH
41641: LD_INT 1
41643: NEG
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 1
41651: NEG
41652: PUSH
41653: LD_INT 2
41655: NEG
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: PUSH
41661: LD_INT 0
41663: PUSH
41664: LD_INT 2
41666: NEG
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 1
41674: PUSH
41675: LD_INT 1
41677: NEG
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 2
41685: PUSH
41686: LD_INT 0
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 2
41695: PUSH
41696: LD_INT 1
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: PUSH
41706: LD_INT 2
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: LD_INT 0
41715: PUSH
41716: LD_INT 2
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 1
41725: NEG
41726: PUSH
41727: LD_INT 1
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 2
41736: NEG
41737: PUSH
41738: LD_INT 0
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: LD_INT 2
41747: NEG
41748: PUSH
41749: LD_INT 1
41751: NEG
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 1
41759: NEG
41760: PUSH
41761: LD_INT 3
41763: NEG
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: LD_INT 3
41774: NEG
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 1
41782: PUSH
41783: LD_INT 2
41785: NEG
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: LD_INT 1
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 3
41804: PUSH
41805: LD_INT 0
41807: PUSH
41808: EMPTY
41809: LIST
41810: LIST
41811: PUSH
41812: LD_INT 3
41814: PUSH
41815: LD_INT 1
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: LD_INT 3
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: LD_INT 0
41834: PUSH
41835: LD_INT 3
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 1
41844: NEG
41845: PUSH
41846: LD_INT 2
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: LD_INT 2
41855: NEG
41856: PUSH
41857: LD_INT 1
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 3
41866: NEG
41867: PUSH
41868: LD_INT 0
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 3
41877: NEG
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: LIST
41903: LIST
41904: LIST
41905: LIST
41906: LIST
41907: LIST
41908: LIST
41909: LIST
41910: LIST
41911: LIST
41912: LIST
41913: LIST
41914: LIST
41915: LIST
41916: LIST
41917: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41918: LD_ADDR_VAR 0 44
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: LD_INT 0
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 0
41935: PUSH
41936: LD_INT 1
41938: NEG
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 1
41946: PUSH
41947: LD_INT 0
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 1
41956: PUSH
41957: LD_INT 1
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 0
41966: PUSH
41967: LD_INT 1
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 1
41976: NEG
41977: PUSH
41978: LD_INT 0
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: NEG
41988: PUSH
41989: LD_INT 1
41991: NEG
41992: PUSH
41993: EMPTY
41994: LIST
41995: LIST
41996: PUSH
41997: LD_INT 1
41999: NEG
42000: PUSH
42001: LD_INT 2
42003: NEG
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 1
42011: PUSH
42012: LD_INT 1
42014: NEG
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: LD_INT 2
42022: PUSH
42023: LD_INT 0
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 2
42032: PUSH
42033: LD_INT 1
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: LD_INT 2
42042: PUSH
42043: LD_INT 2
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 1
42052: PUSH
42053: LD_INT 2
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 1
42062: NEG
42063: PUSH
42064: LD_INT 1
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 2
42073: NEG
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: LD_INT 2
42084: NEG
42085: PUSH
42086: LD_INT 1
42088: NEG
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PUSH
42094: LD_INT 2
42096: NEG
42097: PUSH
42098: LD_INT 2
42100: NEG
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 2
42108: NEG
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 2
42120: PUSH
42121: LD_INT 1
42123: NEG
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 3
42131: PUSH
42132: LD_INT 0
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 3
42141: PUSH
42142: LD_INT 1
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 3
42151: PUSH
42152: LD_INT 2
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 3
42161: PUSH
42162: LD_INT 3
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: LD_INT 2
42171: PUSH
42172: LD_INT 3
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: NEG
42182: PUSH
42183: LD_INT 1
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 3
42192: NEG
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 3
42203: NEG
42204: PUSH
42205: LD_INT 1
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: NEG
42216: PUSH
42217: LD_INT 2
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: LIST
42267: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42268: LD_ADDR_VAR 0 45
42272: PUSH
42273: LD_INT 0
42275: PUSH
42276: LD_INT 0
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 0
42285: PUSH
42286: LD_INT 1
42288: NEG
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: LD_INT 0
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 1
42306: PUSH
42307: LD_INT 1
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: LD_INT 1
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: LD_INT 1
42326: NEG
42327: PUSH
42328: LD_INT 0
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 1
42337: NEG
42338: PUSH
42339: LD_INT 1
42341: NEG
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 1
42349: NEG
42350: PUSH
42351: LD_INT 2
42353: NEG
42354: PUSH
42355: EMPTY
42356: LIST
42357: LIST
42358: PUSH
42359: LD_INT 0
42361: PUSH
42362: LD_INT 2
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 1
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 2
42383: PUSH
42384: LD_INT 1
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 2
42393: PUSH
42394: LD_INT 2
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 1
42403: PUSH
42404: LD_INT 2
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 0
42413: PUSH
42414: LD_INT 2
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 1
42423: NEG
42424: PUSH
42425: LD_INT 1
42427: PUSH
42428: EMPTY
42429: LIST
42430: LIST
42431: PUSH
42432: LD_INT 2
42434: NEG
42435: PUSH
42436: LD_INT 1
42438: NEG
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: LD_INT 2
42446: NEG
42447: PUSH
42448: LD_INT 2
42450: NEG
42451: PUSH
42452: EMPTY
42453: LIST
42454: LIST
42455: PUSH
42456: LD_INT 2
42458: NEG
42459: PUSH
42460: LD_INT 3
42462: NEG
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 1
42470: NEG
42471: PUSH
42472: LD_INT 3
42474: NEG
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 0
42482: PUSH
42483: LD_INT 3
42485: NEG
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 1
42493: PUSH
42494: LD_INT 2
42496: NEG
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: LD_INT 3
42504: PUSH
42505: LD_INT 2
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 3
42514: PUSH
42515: LD_INT 3
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 2
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: PUSH
42535: LD_INT 3
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 0
42544: PUSH
42545: LD_INT 3
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 1
42554: NEG
42555: PUSH
42556: LD_INT 2
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 3
42565: NEG
42566: PUSH
42567: LD_INT 2
42569: NEG
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: PUSH
42575: LD_INT 3
42577: NEG
42578: PUSH
42579: LD_INT 3
42581: NEG
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42618: LD_ADDR_VAR 0 46
42622: PUSH
42623: LD_INT 0
42625: PUSH
42626: LD_INT 0
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: LD_INT 1
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 1
42646: PUSH
42647: LD_INT 0
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 1
42656: PUSH
42657: LD_INT 1
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: LD_INT 1
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: LD_INT 0
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 1
42687: NEG
42688: PUSH
42689: LD_INT 1
42691: NEG
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 1
42699: NEG
42700: PUSH
42701: LD_INT 2
42703: NEG
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 0
42711: PUSH
42712: LD_INT 2
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 1
42722: PUSH
42723: LD_INT 1
42725: NEG
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: LD_INT 2
42733: PUSH
42734: LD_INT 0
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 2
42743: PUSH
42744: LD_INT 1
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 1
42753: PUSH
42754: LD_INT 2
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PUSH
42761: LD_INT 0
42763: PUSH
42764: LD_INT 2
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 1
42773: NEG
42774: PUSH
42775: LD_INT 1
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 2
42784: NEG
42785: PUSH
42786: LD_INT 0
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 2
42795: NEG
42796: PUSH
42797: LD_INT 1
42799: NEG
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PUSH
42805: LD_INT 1
42807: NEG
42808: PUSH
42809: LD_INT 3
42811: NEG
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 0
42819: PUSH
42820: LD_INT 3
42822: NEG
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 1
42830: PUSH
42831: LD_INT 2
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: LD_INT 1
42844: NEG
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: PUSH
42850: LD_INT 3
42852: PUSH
42853: LD_INT 0
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: LD_INT 3
42862: PUSH
42863: LD_INT 1
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 1
42872: PUSH
42873: LD_INT 3
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: LD_INT 3
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 1
42892: NEG
42893: PUSH
42894: LD_INT 2
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: LD_INT 1
42907: PUSH
42908: EMPTY
42909: LIST
42910: LIST
42911: PUSH
42912: LD_INT 3
42914: NEG
42915: PUSH
42916: LD_INT 0
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: PUSH
42923: LD_INT 3
42925: NEG
42926: PUSH
42927: LD_INT 1
42929: NEG
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: LIST
42939: LIST
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: LIST
42945: LIST
42946: LIST
42947: LIST
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: LIST
42953: LIST
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42966: LD_ADDR_VAR 0 47
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: LD_INT 0
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: LD_INT 1
42986: NEG
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: LD_INT 0
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_INT 1
43004: PUSH
43005: LD_INT 1
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: PUSH
43012: LD_INT 0
43014: PUSH
43015: LD_INT 1
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 1
43024: NEG
43025: PUSH
43026: LD_INT 0
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 1
43035: NEG
43036: PUSH
43037: LD_INT 1
43039: NEG
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 1
43047: NEG
43048: PUSH
43049: LD_INT 2
43051: NEG
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 0
43059: PUSH
43060: LD_INT 2
43062: NEG
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: LD_INT 1
43070: PUSH
43071: LD_INT 1
43073: NEG
43074: PUSH
43075: EMPTY
43076: LIST
43077: LIST
43078: PUSH
43079: LD_INT 2
43081: NEG
43082: PUSH
43083: LD_INT 1
43085: NEG
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 2
43093: NEG
43094: PUSH
43095: LD_INT 2
43097: NEG
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: LIST
43108: LIST
43109: LIST
43110: LIST
43111: LIST
43112: LIST
43113: LIST
43114: LIST
43115: LIST
43116: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43117: LD_ADDR_VAR 0 48
43121: PUSH
43122: LD_INT 0
43124: PUSH
43125: LD_INT 0
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 0
43134: PUSH
43135: LD_INT 1
43137: NEG
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 1
43145: PUSH
43146: LD_INT 0
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 1
43155: PUSH
43156: LD_INT 1
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 0
43165: PUSH
43166: LD_INT 1
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: LD_INT 1
43175: NEG
43176: PUSH
43177: LD_INT 0
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: LD_INT 1
43186: NEG
43187: PUSH
43188: LD_INT 1
43190: NEG
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 1
43198: NEG
43199: PUSH
43200: LD_INT 2
43202: NEG
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 0
43210: PUSH
43211: LD_INT 2
43213: NEG
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 1
43221: PUSH
43222: LD_INT 1
43224: NEG
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 2
43232: PUSH
43233: LD_INT 0
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: LD_INT 2
43242: PUSH
43243: LD_INT 1
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: LIST
43254: LIST
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43264: LD_ADDR_VAR 0 49
43268: PUSH
43269: LD_INT 0
43271: PUSH
43272: LD_INT 0
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 0
43281: PUSH
43282: LD_INT 1
43284: NEG
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 1
43292: PUSH
43293: LD_INT 0
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: LD_INT 1
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 0
43312: PUSH
43313: LD_INT 1
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 1
43322: NEG
43323: PUSH
43324: LD_INT 0
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 1
43333: NEG
43334: PUSH
43335: LD_INT 1
43337: NEG
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 1
43345: PUSH
43346: LD_INT 1
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: LD_INT 0
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: LD_INT 1
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 2
43376: PUSH
43377: LD_INT 2
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 1
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43408: LD_ADDR_VAR 0 50
43412: PUSH
43413: LD_INT 0
43415: PUSH
43416: LD_INT 0
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 0
43425: PUSH
43426: LD_INT 1
43428: NEG
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 1
43436: PUSH
43437: LD_INT 0
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: LD_INT 1
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 0
43456: PUSH
43457: LD_INT 1
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: LD_INT 0
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 1
43477: NEG
43478: PUSH
43479: LD_INT 1
43481: NEG
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 2
43489: PUSH
43490: LD_INT 1
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 2
43499: PUSH
43500: LD_INT 2
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 1
43509: PUSH
43510: LD_INT 2
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: LD_INT 0
43519: PUSH
43520: LD_INT 2
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 1
43529: NEG
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43552: LD_ADDR_VAR 0 51
43556: PUSH
43557: LD_INT 0
43559: PUSH
43560: LD_INT 0
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 0
43569: PUSH
43570: LD_INT 1
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 1
43580: PUSH
43581: LD_INT 0
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 1
43590: PUSH
43591: LD_INT 1
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: LD_INT 0
43600: PUSH
43601: LD_INT 1
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: PUSH
43608: LD_INT 1
43610: NEG
43611: PUSH
43612: LD_INT 0
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 1
43621: NEG
43622: PUSH
43623: LD_INT 1
43625: NEG
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: LD_INT 2
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 0
43643: PUSH
43644: LD_INT 2
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 1
43653: NEG
43654: PUSH
43655: LD_INT 1
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: LD_INT 2
43664: NEG
43665: PUSH
43666: LD_INT 0
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 2
43675: NEG
43676: PUSH
43677: LD_INT 1
43679: NEG
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43699: LD_ADDR_VAR 0 52
43703: PUSH
43704: LD_INT 0
43706: PUSH
43707: LD_INT 0
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 0
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 1
43727: PUSH
43728: LD_INT 0
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 1
43737: PUSH
43738: LD_INT 1
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 0
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 1
43757: NEG
43758: PUSH
43759: LD_INT 0
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 1
43768: NEG
43769: PUSH
43770: LD_INT 1
43772: NEG
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 1
43780: NEG
43781: PUSH
43782: LD_INT 2
43784: NEG
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 1
43792: NEG
43793: PUSH
43794: LD_INT 1
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 2
43803: NEG
43804: PUSH
43805: LD_INT 0
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 2
43814: NEG
43815: PUSH
43816: LD_INT 1
43818: NEG
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 2
43826: NEG
43827: PUSH
43828: LD_INT 2
43830: NEG
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43850: LD_ADDR_VAR 0 53
43854: PUSH
43855: LD_INT 0
43857: PUSH
43858: LD_INT 0
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 1
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 1
43878: PUSH
43879: LD_INT 0
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: LD_INT 1
43891: PUSH
43892: EMPTY
43893: LIST
43894: LIST
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: LD_INT 1
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 1
43908: NEG
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 1
43919: NEG
43920: PUSH
43921: LD_INT 1
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 1
43931: NEG
43932: PUSH
43933: LD_INT 2
43935: NEG
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 0
43943: PUSH
43944: LD_INT 2
43946: NEG
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: LD_INT 1
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 2
43965: PUSH
43966: LD_INT 0
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 2
43975: PUSH
43976: LD_INT 1
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 2
43985: PUSH
43986: LD_INT 2
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PUSH
43993: LD_INT 1
43995: PUSH
43996: LD_INT 2
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 0
44005: PUSH
44006: LD_INT 2
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 1
44015: NEG
44016: PUSH
44017: LD_INT 1
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 2
44026: NEG
44027: PUSH
44028: LD_INT 0
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 2
44037: NEG
44038: PUSH
44039: LD_INT 1
44041: NEG
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 2
44049: NEG
44050: PUSH
44051: LD_INT 2
44053: NEG
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44080: LD_ADDR_VAR 0 54
44084: PUSH
44085: LD_INT 0
44087: PUSH
44088: LD_INT 0
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 0
44097: PUSH
44098: LD_INT 1
44100: NEG
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 1
44108: PUSH
44109: LD_INT 0
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_INT 1
44118: PUSH
44119: LD_INT 1
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 0
44128: PUSH
44129: LD_INT 1
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 1
44138: NEG
44139: PUSH
44140: LD_INT 0
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: PUSH
44147: LD_INT 1
44149: NEG
44150: PUSH
44151: LD_INT 1
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 1
44161: NEG
44162: PUSH
44163: LD_INT 2
44165: NEG
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 0
44173: PUSH
44174: LD_INT 2
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 1
44184: PUSH
44185: LD_INT 1
44187: NEG
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 2
44195: PUSH
44196: LD_INT 0
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: PUSH
44206: LD_INT 1
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 2
44215: PUSH
44216: LD_INT 2
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 1
44225: PUSH
44226: LD_INT 2
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 0
44235: PUSH
44236: LD_INT 2
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 1
44245: NEG
44246: PUSH
44247: LD_INT 1
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 2
44256: NEG
44257: PUSH
44258: LD_INT 0
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 2
44267: NEG
44268: PUSH
44269: LD_INT 1
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 2
44279: NEG
44280: PUSH
44281: LD_INT 2
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: LIST
44309: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44310: LD_ADDR_VAR 0 55
44314: PUSH
44315: LD_INT 0
44317: PUSH
44318: LD_INT 0
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 0
44327: PUSH
44328: LD_INT 1
44330: NEG
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: PUSH
44336: LD_INT 1
44338: PUSH
44339: LD_INT 0
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: LD_INT 1
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 0
44358: PUSH
44359: LD_INT 1
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 1
44368: NEG
44369: PUSH
44370: LD_INT 0
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: LD_INT 1
44379: NEG
44380: PUSH
44381: LD_INT 1
44383: NEG
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 1
44391: NEG
44392: PUSH
44393: LD_INT 2
44395: NEG
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 0
44403: PUSH
44404: LD_INT 2
44406: NEG
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 1
44414: PUSH
44415: LD_INT 1
44417: NEG
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PUSH
44423: LD_INT 2
44425: PUSH
44426: LD_INT 0
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 2
44435: PUSH
44436: LD_INT 1
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 2
44445: PUSH
44446: LD_INT 2
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 1
44455: PUSH
44456: LD_INT 2
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 0
44465: PUSH
44466: LD_INT 2
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 1
44475: NEG
44476: PUSH
44477: LD_INT 1
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 2
44486: NEG
44487: PUSH
44488: LD_INT 0
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 2
44497: NEG
44498: PUSH
44499: LD_INT 1
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 2
44509: NEG
44510: PUSH
44511: LD_INT 2
44513: NEG
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44540: LD_ADDR_VAR 0 56
44544: PUSH
44545: LD_INT 0
44547: PUSH
44548: LD_INT 0
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: LD_INT 0
44557: PUSH
44558: LD_INT 1
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 1
44568: PUSH
44569: LD_INT 0
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 1
44578: PUSH
44579: LD_INT 1
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 0
44588: PUSH
44589: LD_INT 1
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 1
44598: NEG
44599: PUSH
44600: LD_INT 0
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: LD_INT 1
44609: NEG
44610: PUSH
44611: LD_INT 1
44613: NEG
44614: PUSH
44615: EMPTY
44616: LIST
44617: LIST
44618: PUSH
44619: LD_INT 1
44621: NEG
44622: PUSH
44623: LD_INT 2
44625: NEG
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: LD_INT 0
44633: PUSH
44634: LD_INT 2
44636: NEG
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: PUSH
44642: LD_INT 1
44644: PUSH
44645: LD_INT 1
44647: NEG
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: PUSH
44653: LD_INT 2
44655: PUSH
44656: LD_INT 0
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: PUSH
44663: LD_INT 2
44665: PUSH
44666: LD_INT 1
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 2
44675: PUSH
44676: LD_INT 2
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 1
44685: PUSH
44686: LD_INT 2
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: LD_INT 0
44695: PUSH
44696: LD_INT 2
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 1
44705: NEG
44706: PUSH
44707: LD_INT 1
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 2
44716: NEG
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 2
44727: NEG
44728: PUSH
44729: LD_INT 1
44731: NEG
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: LD_INT 2
44739: NEG
44740: PUSH
44741: LD_INT 2
44743: NEG
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: LIST
44758: LIST
44759: LIST
44760: LIST
44761: LIST
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44770: LD_ADDR_VAR 0 57
44774: PUSH
44775: LD_INT 0
44777: PUSH
44778: LD_INT 0
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: LD_INT 1
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 1
44798: PUSH
44799: LD_INT 0
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 1
44808: PUSH
44809: LD_INT 1
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: PUSH
44816: LD_INT 0
44818: PUSH
44819: LD_INT 1
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 1
44828: NEG
44829: PUSH
44830: LD_INT 0
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: PUSH
44837: LD_INT 1
44839: NEG
44840: PUSH
44841: LD_INT 1
44843: NEG
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 1
44851: NEG
44852: PUSH
44853: LD_INT 2
44855: NEG
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 0
44863: PUSH
44864: LD_INT 2
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 1
44874: PUSH
44875: LD_INT 1
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 2
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 2
44895: PUSH
44896: LD_INT 1
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 2
44905: PUSH
44906: LD_INT 2
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 1
44915: PUSH
44916: LD_INT 2
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 0
44925: PUSH
44926: LD_INT 2
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 1
44935: NEG
44936: PUSH
44937: LD_INT 1
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 2
44946: NEG
44947: PUSH
44948: LD_INT 0
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 2
44957: NEG
44958: PUSH
44959: LD_INT 1
44961: NEG
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: PUSH
44967: LD_INT 2
44969: NEG
44970: PUSH
44971: LD_INT 2
44973: NEG
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: LIST
44990: LIST
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45000: LD_ADDR_VAR 0 58
45004: PUSH
45005: LD_INT 0
45007: PUSH
45008: LD_INT 0
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 0
45017: PUSH
45018: LD_INT 1
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 1
45028: PUSH
45029: LD_INT 0
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 1
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 0
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 1
45058: NEG
45059: PUSH
45060: LD_INT 0
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 1
45069: NEG
45070: PUSH
45071: LD_INT 1
45073: NEG
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: PUSH
45079: LD_INT 1
45081: NEG
45082: PUSH
45083: LD_INT 2
45085: NEG
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 0
45093: PUSH
45094: LD_INT 2
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 1
45104: PUSH
45105: LD_INT 1
45107: NEG
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: LD_INT 0
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: PUSH
45123: LD_INT 2
45125: PUSH
45126: LD_INT 1
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 2
45135: PUSH
45136: LD_INT 2
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 1
45145: PUSH
45146: LD_INT 2
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 0
45155: PUSH
45156: LD_INT 2
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 1
45165: NEG
45166: PUSH
45167: LD_INT 1
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 2
45176: NEG
45177: PUSH
45178: LD_INT 0
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 2
45187: NEG
45188: PUSH
45189: LD_INT 1
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 2
45199: NEG
45200: PUSH
45201: LD_INT 2
45203: NEG
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45230: LD_ADDR_VAR 0 59
45234: PUSH
45235: LD_INT 0
45237: PUSH
45238: LD_INT 0
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PUSH
45245: LD_INT 0
45247: PUSH
45248: LD_INT 1
45250: NEG
45251: PUSH
45252: EMPTY
45253: LIST
45254: LIST
45255: PUSH
45256: LD_INT 1
45258: PUSH
45259: LD_INT 0
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: PUSH
45266: LD_INT 1
45268: PUSH
45269: LD_INT 1
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 0
45278: PUSH
45279: LD_INT 1
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 1
45288: NEG
45289: PUSH
45290: LD_INT 0
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 1
45299: NEG
45300: PUSH
45301: LD_INT 1
45303: NEG
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45318: LD_ADDR_VAR 0 60
45322: PUSH
45323: LD_INT 0
45325: PUSH
45326: LD_INT 0
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: PUSH
45333: LD_INT 0
45335: PUSH
45336: LD_INT 1
45338: NEG
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 1
45346: PUSH
45347: LD_INT 0
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 1
45356: PUSH
45357: LD_INT 1
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 0
45366: PUSH
45367: LD_INT 1
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 1
45376: NEG
45377: PUSH
45378: LD_INT 0
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 1
45387: NEG
45388: PUSH
45389: LD_INT 1
45391: NEG
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45406: LD_ADDR_VAR 0 61
45410: PUSH
45411: LD_INT 0
45413: PUSH
45414: LD_INT 0
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 0
45423: PUSH
45424: LD_INT 1
45426: NEG
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 1
45434: PUSH
45435: LD_INT 0
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: LD_INT 1
45444: PUSH
45445: LD_INT 1
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 0
45454: PUSH
45455: LD_INT 1
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 1
45464: NEG
45465: PUSH
45466: LD_INT 0
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 1
45475: NEG
45476: PUSH
45477: LD_INT 1
45479: NEG
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45494: LD_ADDR_VAR 0 62
45498: PUSH
45499: LD_INT 0
45501: PUSH
45502: LD_INT 0
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: LD_INT 1
45514: NEG
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: PUSH
45520: LD_INT 1
45522: PUSH
45523: LD_INT 0
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 1
45532: PUSH
45533: LD_INT 1
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 0
45542: PUSH
45543: LD_INT 1
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 1
45552: NEG
45553: PUSH
45554: LD_INT 0
45556: PUSH
45557: EMPTY
45558: LIST
45559: LIST
45560: PUSH
45561: LD_INT 1
45563: NEG
45564: PUSH
45565: LD_INT 1
45567: NEG
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: PUSH
45573: EMPTY
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45582: LD_ADDR_VAR 0 63
45586: PUSH
45587: LD_INT 0
45589: PUSH
45590: LD_INT 0
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 0
45599: PUSH
45600: LD_INT 1
45602: NEG
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: LD_INT 1
45610: PUSH
45611: LD_INT 0
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: PUSH
45618: LD_INT 1
45620: PUSH
45621: LD_INT 1
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 0
45630: PUSH
45631: LD_INT 1
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: PUSH
45638: LD_INT 1
45640: NEG
45641: PUSH
45642: LD_INT 0
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 1
45651: NEG
45652: PUSH
45653: LD_INT 1
45655: NEG
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45670: LD_ADDR_VAR 0 64
45674: PUSH
45675: LD_INT 0
45677: PUSH
45678: LD_INT 0
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 0
45687: PUSH
45688: LD_INT 1
45690: NEG
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 1
45698: PUSH
45699: LD_INT 0
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 1
45708: PUSH
45709: LD_INT 1
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 0
45718: PUSH
45719: LD_INT 1
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 1
45728: NEG
45729: PUSH
45730: LD_INT 0
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 1
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: ST_TO_ADDR
// end ; 1 :
45758: GO 51655
45760: LD_INT 1
45762: DOUBLE
45763: EQUAL
45764: IFTRUE 45768
45766: GO 48391
45768: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45769: LD_ADDR_VAR 0 11
45773: PUSH
45774: LD_INT 1
45776: NEG
45777: PUSH
45778: LD_INT 3
45780: NEG
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 0
45788: PUSH
45789: LD_INT 3
45791: NEG
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 1
45799: PUSH
45800: LD_INT 2
45802: NEG
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: LIST
45812: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45813: LD_ADDR_VAR 0 12
45817: PUSH
45818: LD_INT 2
45820: PUSH
45821: LD_INT 1
45823: NEG
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: PUSH
45829: LD_INT 3
45831: PUSH
45832: LD_INT 0
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 3
45841: PUSH
45842: LD_INT 1
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: LIST
45853: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45854: LD_ADDR_VAR 0 13
45858: PUSH
45859: LD_INT 3
45861: PUSH
45862: LD_INT 2
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 3
45871: PUSH
45872: LD_INT 3
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 2
45881: PUSH
45882: LD_INT 3
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: LIST
45893: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45894: LD_ADDR_VAR 0 14
45898: PUSH
45899: LD_INT 1
45901: PUSH
45902: LD_INT 3
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 0
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 1
45921: NEG
45922: PUSH
45923: LD_INT 2
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: LIST
45934: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45935: LD_ADDR_VAR 0 15
45939: PUSH
45940: LD_INT 2
45942: NEG
45943: PUSH
45944: LD_INT 1
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 3
45953: NEG
45954: PUSH
45955: LD_INT 0
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: LD_INT 3
45964: NEG
45965: PUSH
45966: LD_INT 1
45968: NEG
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: LIST
45978: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45979: LD_ADDR_VAR 0 16
45983: PUSH
45984: LD_INT 2
45986: NEG
45987: PUSH
45988: LD_INT 3
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 3
45998: NEG
45999: PUSH
46000: LD_INT 2
46002: NEG
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 3
46010: NEG
46011: PUSH
46012: LD_INT 3
46014: NEG
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: LIST
46024: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46025: LD_ADDR_VAR 0 17
46029: PUSH
46030: LD_INT 1
46032: NEG
46033: PUSH
46034: LD_INT 3
46036: NEG
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 0
46044: PUSH
46045: LD_INT 3
46047: NEG
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: PUSH
46053: LD_INT 1
46055: PUSH
46056: LD_INT 2
46058: NEG
46059: PUSH
46060: EMPTY
46061: LIST
46062: LIST
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: LIST
46068: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46069: LD_ADDR_VAR 0 18
46073: PUSH
46074: LD_INT 2
46076: PUSH
46077: LD_INT 1
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 3
46087: PUSH
46088: LD_INT 0
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 3
46097: PUSH
46098: LD_INT 1
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: EMPTY
46106: LIST
46107: LIST
46108: LIST
46109: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46110: LD_ADDR_VAR 0 19
46114: PUSH
46115: LD_INT 3
46117: PUSH
46118: LD_INT 2
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 3
46127: PUSH
46128: LD_INT 3
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: LD_INT 3
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: LIST
46149: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46150: LD_ADDR_VAR 0 20
46154: PUSH
46155: LD_INT 1
46157: PUSH
46158: LD_INT 3
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: PUSH
46165: LD_INT 0
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: PUSH
46175: LD_INT 1
46177: NEG
46178: PUSH
46179: LD_INT 2
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: LIST
46190: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46191: LD_ADDR_VAR 0 21
46195: PUSH
46196: LD_INT 2
46198: NEG
46199: PUSH
46200: LD_INT 1
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 3
46209: NEG
46210: PUSH
46211: LD_INT 0
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 3
46220: NEG
46221: PUSH
46222: LD_INT 1
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: LIST
46234: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46235: LD_ADDR_VAR 0 22
46239: PUSH
46240: LD_INT 2
46242: NEG
46243: PUSH
46244: LD_INT 3
46246: NEG
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: PUSH
46252: LD_INT 3
46254: NEG
46255: PUSH
46256: LD_INT 2
46258: NEG
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 3
46266: NEG
46267: PUSH
46268: LD_INT 3
46270: NEG
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: LIST
46280: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46281: LD_ADDR_VAR 0 23
46285: PUSH
46286: LD_INT 0
46288: PUSH
46289: LD_INT 3
46291: NEG
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PUSH
46297: LD_INT 1
46299: NEG
46300: PUSH
46301: LD_INT 4
46303: NEG
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: LD_INT 1
46311: PUSH
46312: LD_INT 3
46314: NEG
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: LIST
46324: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46325: LD_ADDR_VAR 0 24
46329: PUSH
46330: LD_INT 3
46332: PUSH
46333: LD_INT 0
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: LD_INT 1
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 4
46353: PUSH
46354: LD_INT 1
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: LIST
46365: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46366: LD_ADDR_VAR 0 25
46370: PUSH
46371: LD_INT 3
46373: PUSH
46374: LD_INT 3
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 4
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 3
46393: PUSH
46394: LD_INT 4
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: LIST
46405: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46406: LD_ADDR_VAR 0 26
46410: PUSH
46411: LD_INT 0
46413: PUSH
46414: LD_INT 3
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 1
46423: PUSH
46424: LD_INT 4
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 1
46433: NEG
46434: PUSH
46435: LD_INT 3
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: LIST
46446: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46447: LD_ADDR_VAR 0 27
46451: PUSH
46452: LD_INT 3
46454: NEG
46455: PUSH
46456: LD_INT 0
46458: PUSH
46459: EMPTY
46460: LIST
46461: LIST
46462: PUSH
46463: LD_INT 3
46465: NEG
46466: PUSH
46467: LD_INT 1
46469: PUSH
46470: EMPTY
46471: LIST
46472: LIST
46473: PUSH
46474: LD_INT 4
46476: NEG
46477: PUSH
46478: LD_INT 1
46480: NEG
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: LIST
46490: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46491: LD_ADDR_VAR 0 28
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 3
46502: NEG
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 3
46510: NEG
46511: PUSH
46512: LD_INT 4
46514: NEG
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 4
46522: NEG
46523: PUSH
46524: LD_INT 3
46526: NEG
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46537: LD_ADDR_VAR 0 29
46541: PUSH
46542: LD_INT 1
46544: NEG
46545: PUSH
46546: LD_INT 3
46548: NEG
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PUSH
46554: LD_INT 0
46556: PUSH
46557: LD_INT 3
46559: NEG
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: PUSH
46565: LD_INT 1
46567: PUSH
46568: LD_INT 2
46570: NEG
46571: PUSH
46572: EMPTY
46573: LIST
46574: LIST
46575: PUSH
46576: LD_INT 1
46578: NEG
46579: PUSH
46580: LD_INT 4
46582: NEG
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: PUSH
46588: LD_INT 0
46590: PUSH
46591: LD_INT 4
46593: NEG
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 1
46601: PUSH
46602: LD_INT 3
46604: NEG
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: PUSH
46610: LD_INT 1
46612: NEG
46613: PUSH
46614: LD_INT 5
46616: NEG
46617: PUSH
46618: EMPTY
46619: LIST
46620: LIST
46621: PUSH
46622: LD_INT 0
46624: PUSH
46625: LD_INT 5
46627: NEG
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 1
46635: PUSH
46636: LD_INT 4
46638: NEG
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 1
46646: NEG
46647: PUSH
46648: LD_INT 6
46650: NEG
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 0
46658: PUSH
46659: LD_INT 6
46661: NEG
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: LD_INT 1
46669: PUSH
46670: LD_INT 5
46672: NEG
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: EMPTY
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46692: LD_ADDR_VAR 0 30
46696: PUSH
46697: LD_INT 2
46699: PUSH
46700: LD_INT 1
46702: NEG
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 3
46710: PUSH
46711: LD_INT 0
46713: PUSH
46714: EMPTY
46715: LIST
46716: LIST
46717: PUSH
46718: LD_INT 3
46720: PUSH
46721: LD_INT 1
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: LD_INT 3
46730: PUSH
46731: LD_INT 1
46733: NEG
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PUSH
46739: LD_INT 4
46741: PUSH
46742: LD_INT 0
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: LD_INT 4
46751: PUSH
46752: LD_INT 1
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: PUSH
46759: LD_INT 4
46761: PUSH
46762: LD_INT 1
46764: NEG
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 5
46772: PUSH
46773: LD_INT 0
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 5
46782: PUSH
46783: LD_INT 1
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: LD_INT 5
46792: PUSH
46793: LD_INT 1
46795: NEG
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: PUSH
46801: LD_INT 6
46803: PUSH
46804: LD_INT 0
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 6
46813: PUSH
46814: LD_INT 1
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: EMPTY
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46835: LD_ADDR_VAR 0 31
46839: PUSH
46840: LD_INT 3
46842: PUSH
46843: LD_INT 2
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: LD_INT 3
46852: PUSH
46853: LD_INT 3
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: PUSH
46860: LD_INT 2
46862: PUSH
46863: LD_INT 3
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: PUSH
46870: LD_INT 4
46872: PUSH
46873: LD_INT 3
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 4
46882: PUSH
46883: LD_INT 4
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PUSH
46890: LD_INT 3
46892: PUSH
46893: LD_INT 4
46895: PUSH
46896: EMPTY
46897: LIST
46898: LIST
46899: PUSH
46900: LD_INT 5
46902: PUSH
46903: LD_INT 4
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: PUSH
46910: LD_INT 5
46912: PUSH
46913: LD_INT 5
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: PUSH
46920: LD_INT 4
46922: PUSH
46923: LD_INT 5
46925: PUSH
46926: EMPTY
46927: LIST
46928: LIST
46929: PUSH
46930: LD_INT 6
46932: PUSH
46933: LD_INT 5
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: PUSH
46940: LD_INT 6
46942: PUSH
46943: LD_INT 6
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_INT 5
46952: PUSH
46953: LD_INT 6
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46974: LD_ADDR_VAR 0 32
46978: PUSH
46979: LD_INT 1
46981: PUSH
46982: LD_INT 3
46984: PUSH
46985: EMPTY
46986: LIST
46987: LIST
46988: PUSH
46989: LD_INT 0
46991: PUSH
46992: LD_INT 3
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 1
47001: NEG
47002: PUSH
47003: LD_INT 2
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 1
47012: PUSH
47013: LD_INT 4
47015: PUSH
47016: EMPTY
47017: LIST
47018: LIST
47019: PUSH
47020: LD_INT 0
47022: PUSH
47023: LD_INT 4
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: PUSH
47030: LD_INT 1
47032: NEG
47033: PUSH
47034: LD_INT 3
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: LD_INT 1
47043: PUSH
47044: LD_INT 5
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 0
47053: PUSH
47054: LD_INT 5
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: LD_INT 1
47063: NEG
47064: PUSH
47065: LD_INT 4
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: PUSH
47072: LD_INT 1
47074: PUSH
47075: LD_INT 6
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: PUSH
47082: LD_INT 0
47084: PUSH
47085: LD_INT 6
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: PUSH
47092: LD_INT 1
47094: NEG
47095: PUSH
47096: LD_INT 5
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
47117: LD_ADDR_VAR 0 33
47121: PUSH
47122: LD_INT 2
47124: NEG
47125: PUSH
47126: LD_INT 1
47128: PUSH
47129: EMPTY
47130: LIST
47131: LIST
47132: PUSH
47133: LD_INT 3
47135: NEG
47136: PUSH
47137: LD_INT 0
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PUSH
47144: LD_INT 3
47146: NEG
47147: PUSH
47148: LD_INT 1
47150: NEG
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 3
47158: NEG
47159: PUSH
47160: LD_INT 1
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 4
47169: NEG
47170: PUSH
47171: LD_INT 0
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 4
47180: NEG
47181: PUSH
47182: LD_INT 1
47184: NEG
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PUSH
47190: LD_INT 4
47192: NEG
47193: PUSH
47194: LD_INT 1
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: PUSH
47201: LD_INT 5
47203: NEG
47204: PUSH
47205: LD_INT 0
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 5
47214: NEG
47215: PUSH
47216: LD_INT 1
47218: NEG
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: PUSH
47224: LD_INT 5
47226: NEG
47227: PUSH
47228: LD_INT 1
47230: PUSH
47231: EMPTY
47232: LIST
47233: LIST
47234: PUSH
47235: LD_INT 6
47237: NEG
47238: PUSH
47239: LD_INT 0
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PUSH
47246: LD_INT 6
47248: NEG
47249: PUSH
47250: LD_INT 1
47252: NEG
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47272: LD_ADDR_VAR 0 34
47276: PUSH
47277: LD_INT 2
47279: NEG
47280: PUSH
47281: LD_INT 3
47283: NEG
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: LD_INT 3
47291: NEG
47292: PUSH
47293: LD_INT 2
47295: NEG
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: PUSH
47301: LD_INT 3
47303: NEG
47304: PUSH
47305: LD_INT 3
47307: NEG
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: PUSH
47313: LD_INT 3
47315: NEG
47316: PUSH
47317: LD_INT 4
47319: NEG
47320: PUSH
47321: EMPTY
47322: LIST
47323: LIST
47324: PUSH
47325: LD_INT 4
47327: NEG
47328: PUSH
47329: LD_INT 3
47331: NEG
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 4
47339: NEG
47340: PUSH
47341: LD_INT 4
47343: NEG
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: PUSH
47349: LD_INT 4
47351: NEG
47352: PUSH
47353: LD_INT 5
47355: NEG
47356: PUSH
47357: EMPTY
47358: LIST
47359: LIST
47360: PUSH
47361: LD_INT 5
47363: NEG
47364: PUSH
47365: LD_INT 4
47367: NEG
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: PUSH
47373: LD_INT 5
47375: NEG
47376: PUSH
47377: LD_INT 5
47379: NEG
47380: PUSH
47381: EMPTY
47382: LIST
47383: LIST
47384: PUSH
47385: LD_INT 5
47387: NEG
47388: PUSH
47389: LD_INT 6
47391: NEG
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PUSH
47397: LD_INT 6
47399: NEG
47400: PUSH
47401: LD_INT 5
47403: NEG
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: LD_INT 6
47411: NEG
47412: PUSH
47413: LD_INT 6
47415: NEG
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: EMPTY
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47435: LD_ADDR_VAR 0 41
47439: PUSH
47440: LD_INT 0
47442: PUSH
47443: LD_INT 2
47445: NEG
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: PUSH
47451: LD_INT 1
47453: NEG
47454: PUSH
47455: LD_INT 3
47457: NEG
47458: PUSH
47459: EMPTY
47460: LIST
47461: LIST
47462: PUSH
47463: LD_INT 1
47465: PUSH
47466: LD_INT 2
47468: NEG
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: LIST
47478: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47479: LD_ADDR_VAR 0 42
47483: PUSH
47484: LD_INT 2
47486: PUSH
47487: LD_INT 0
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: PUSH
47494: LD_INT 2
47496: PUSH
47497: LD_INT 1
47499: NEG
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: PUSH
47505: LD_INT 3
47507: PUSH
47508: LD_INT 1
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PUSH
47515: EMPTY
47516: LIST
47517: LIST
47518: LIST
47519: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47520: LD_ADDR_VAR 0 43
47524: PUSH
47525: LD_INT 2
47527: PUSH
47528: LD_INT 2
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 3
47537: PUSH
47538: LD_INT 2
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: LD_INT 2
47547: PUSH
47548: LD_INT 3
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: EMPTY
47556: LIST
47557: LIST
47558: LIST
47559: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47560: LD_ADDR_VAR 0 44
47564: PUSH
47565: LD_INT 0
47567: PUSH
47568: LD_INT 2
47570: PUSH
47571: EMPTY
47572: LIST
47573: LIST
47574: PUSH
47575: LD_INT 1
47577: PUSH
47578: LD_INT 3
47580: PUSH
47581: EMPTY
47582: LIST
47583: LIST
47584: PUSH
47585: LD_INT 1
47587: NEG
47588: PUSH
47589: LD_INT 2
47591: PUSH
47592: EMPTY
47593: LIST
47594: LIST
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: LIST
47600: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47601: LD_ADDR_VAR 0 45
47605: PUSH
47606: LD_INT 2
47608: NEG
47609: PUSH
47610: LD_INT 0
47612: PUSH
47613: EMPTY
47614: LIST
47615: LIST
47616: PUSH
47617: LD_INT 2
47619: NEG
47620: PUSH
47621: LD_INT 1
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: PUSH
47628: LD_INT 3
47630: NEG
47631: PUSH
47632: LD_INT 1
47634: NEG
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PUSH
47640: EMPTY
47641: LIST
47642: LIST
47643: LIST
47644: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47645: LD_ADDR_VAR 0 46
47649: PUSH
47650: LD_INT 2
47652: NEG
47653: PUSH
47654: LD_INT 2
47656: NEG
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: PUSH
47662: LD_INT 2
47664: NEG
47665: PUSH
47666: LD_INT 3
47668: NEG
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: PUSH
47674: LD_INT 3
47676: NEG
47677: PUSH
47678: LD_INT 2
47680: NEG
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: LIST
47690: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47691: LD_ADDR_VAR 0 47
47695: PUSH
47696: LD_INT 2
47698: NEG
47699: PUSH
47700: LD_INT 3
47702: NEG
47703: PUSH
47704: EMPTY
47705: LIST
47706: LIST
47707: PUSH
47708: LD_INT 1
47710: NEG
47711: PUSH
47712: LD_INT 3
47714: NEG
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47724: LD_ADDR_VAR 0 48
47728: PUSH
47729: LD_INT 1
47731: PUSH
47732: LD_INT 2
47734: NEG
47735: PUSH
47736: EMPTY
47737: LIST
47738: LIST
47739: PUSH
47740: LD_INT 2
47742: PUSH
47743: LD_INT 1
47745: NEG
47746: PUSH
47747: EMPTY
47748: LIST
47749: LIST
47750: PUSH
47751: EMPTY
47752: LIST
47753: LIST
47754: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47755: LD_ADDR_VAR 0 49
47759: PUSH
47760: LD_INT 3
47762: PUSH
47763: LD_INT 1
47765: PUSH
47766: EMPTY
47767: LIST
47768: LIST
47769: PUSH
47770: LD_INT 3
47772: PUSH
47773: LD_INT 2
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47784: LD_ADDR_VAR 0 50
47788: PUSH
47789: LD_INT 2
47791: PUSH
47792: LD_INT 3
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: PUSH
47799: LD_INT 1
47801: PUSH
47802: LD_INT 3
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47813: LD_ADDR_VAR 0 51
47817: PUSH
47818: LD_INT 1
47820: NEG
47821: PUSH
47822: LD_INT 2
47824: PUSH
47825: EMPTY
47826: LIST
47827: LIST
47828: PUSH
47829: LD_INT 2
47831: NEG
47832: PUSH
47833: LD_INT 1
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47844: LD_ADDR_VAR 0 52
47848: PUSH
47849: LD_INT 3
47851: NEG
47852: PUSH
47853: LD_INT 1
47855: NEG
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: PUSH
47861: LD_INT 3
47863: NEG
47864: PUSH
47865: LD_INT 2
47867: NEG
47868: PUSH
47869: EMPTY
47870: LIST
47871: LIST
47872: PUSH
47873: EMPTY
47874: LIST
47875: LIST
47876: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47877: LD_ADDR_VAR 0 53
47881: PUSH
47882: LD_INT 1
47884: NEG
47885: PUSH
47886: LD_INT 3
47888: NEG
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PUSH
47894: LD_INT 0
47896: PUSH
47897: LD_INT 3
47899: NEG
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: LD_INT 1
47907: PUSH
47908: LD_INT 2
47910: NEG
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: LIST
47920: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47921: LD_ADDR_VAR 0 54
47925: PUSH
47926: LD_INT 2
47928: PUSH
47929: LD_INT 1
47931: NEG
47932: PUSH
47933: EMPTY
47934: LIST
47935: LIST
47936: PUSH
47937: LD_INT 3
47939: PUSH
47940: LD_INT 0
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 3
47949: PUSH
47950: LD_INT 1
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: LIST
47961: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47962: LD_ADDR_VAR 0 55
47966: PUSH
47967: LD_INT 3
47969: PUSH
47970: LD_INT 2
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 3
47979: PUSH
47980: LD_INT 3
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 2
47989: PUSH
47990: LD_INT 3
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
48002: LD_ADDR_VAR 0 56
48006: PUSH
48007: LD_INT 1
48009: PUSH
48010: LD_INT 3
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 0
48019: PUSH
48020: LD_INT 3
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 1
48029: NEG
48030: PUSH
48031: LD_INT 2
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: LIST
48042: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
48043: LD_ADDR_VAR 0 57
48047: PUSH
48048: LD_INT 2
48050: NEG
48051: PUSH
48052: LD_INT 1
48054: PUSH
48055: EMPTY
48056: LIST
48057: LIST
48058: PUSH
48059: LD_INT 3
48061: NEG
48062: PUSH
48063: LD_INT 0
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: PUSH
48070: LD_INT 3
48072: NEG
48073: PUSH
48074: LD_INT 1
48076: NEG
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: LIST
48086: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
48087: LD_ADDR_VAR 0 58
48091: PUSH
48092: LD_INT 2
48094: NEG
48095: PUSH
48096: LD_INT 3
48098: NEG
48099: PUSH
48100: EMPTY
48101: LIST
48102: LIST
48103: PUSH
48104: LD_INT 3
48106: NEG
48107: PUSH
48108: LD_INT 2
48110: NEG
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: PUSH
48116: LD_INT 3
48118: NEG
48119: PUSH
48120: LD_INT 3
48122: NEG
48123: PUSH
48124: EMPTY
48125: LIST
48126: LIST
48127: PUSH
48128: EMPTY
48129: LIST
48130: LIST
48131: LIST
48132: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
48133: LD_ADDR_VAR 0 59
48137: PUSH
48138: LD_INT 1
48140: NEG
48141: PUSH
48142: LD_INT 2
48144: NEG
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PUSH
48150: LD_INT 0
48152: PUSH
48153: LD_INT 2
48155: NEG
48156: PUSH
48157: EMPTY
48158: LIST
48159: LIST
48160: PUSH
48161: LD_INT 1
48163: PUSH
48164: LD_INT 1
48166: NEG
48167: PUSH
48168: EMPTY
48169: LIST
48170: LIST
48171: PUSH
48172: EMPTY
48173: LIST
48174: LIST
48175: LIST
48176: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48177: LD_ADDR_VAR 0 60
48181: PUSH
48182: LD_INT 1
48184: PUSH
48185: LD_INT 1
48187: NEG
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 2
48195: PUSH
48196: LD_INT 0
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 2
48205: PUSH
48206: LD_INT 1
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: LIST
48217: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48218: LD_ADDR_VAR 0 61
48222: PUSH
48223: LD_INT 2
48225: PUSH
48226: LD_INT 1
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: LD_INT 2
48235: PUSH
48236: LD_INT 2
48238: PUSH
48239: EMPTY
48240: LIST
48241: LIST
48242: PUSH
48243: LD_INT 1
48245: PUSH
48246: LD_INT 2
48248: PUSH
48249: EMPTY
48250: LIST
48251: LIST
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: LIST
48257: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48258: LD_ADDR_VAR 0 62
48262: PUSH
48263: LD_INT 1
48265: PUSH
48266: LD_INT 2
48268: PUSH
48269: EMPTY
48270: LIST
48271: LIST
48272: PUSH
48273: LD_INT 0
48275: PUSH
48276: LD_INT 2
48278: PUSH
48279: EMPTY
48280: LIST
48281: LIST
48282: PUSH
48283: LD_INT 1
48285: NEG
48286: PUSH
48287: LD_INT 1
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: LIST
48298: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48299: LD_ADDR_VAR 0 63
48303: PUSH
48304: LD_INT 1
48306: NEG
48307: PUSH
48308: LD_INT 1
48310: PUSH
48311: EMPTY
48312: LIST
48313: LIST
48314: PUSH
48315: LD_INT 2
48317: NEG
48318: PUSH
48319: LD_INT 0
48321: PUSH
48322: EMPTY
48323: LIST
48324: LIST
48325: PUSH
48326: LD_INT 2
48328: NEG
48329: PUSH
48330: LD_INT 1
48332: NEG
48333: PUSH
48334: EMPTY
48335: LIST
48336: LIST
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: LIST
48342: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48343: LD_ADDR_VAR 0 64
48347: PUSH
48348: LD_INT 1
48350: NEG
48351: PUSH
48352: LD_INT 2
48354: NEG
48355: PUSH
48356: EMPTY
48357: LIST
48358: LIST
48359: PUSH
48360: LD_INT 2
48362: NEG
48363: PUSH
48364: LD_INT 1
48366: NEG
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: PUSH
48372: LD_INT 2
48374: NEG
48375: PUSH
48376: LD_INT 2
48378: NEG
48379: PUSH
48380: EMPTY
48381: LIST
48382: LIST
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: LIST
48388: ST_TO_ADDR
// end ; 2 :
48389: GO 51655
48391: LD_INT 2
48393: DOUBLE
48394: EQUAL
48395: IFTRUE 48399
48397: GO 51654
48399: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48400: LD_ADDR_VAR 0 29
48404: PUSH
48405: LD_INT 4
48407: PUSH
48408: LD_INT 0
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 4
48417: PUSH
48418: LD_INT 1
48420: NEG
48421: PUSH
48422: EMPTY
48423: LIST
48424: LIST
48425: PUSH
48426: LD_INT 5
48428: PUSH
48429: LD_INT 0
48431: PUSH
48432: EMPTY
48433: LIST
48434: LIST
48435: PUSH
48436: LD_INT 5
48438: PUSH
48439: LD_INT 1
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PUSH
48446: LD_INT 4
48448: PUSH
48449: LD_INT 1
48451: PUSH
48452: EMPTY
48453: LIST
48454: LIST
48455: PUSH
48456: LD_INT 3
48458: PUSH
48459: LD_INT 0
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: PUSH
48466: LD_INT 3
48468: PUSH
48469: LD_INT 1
48471: NEG
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: PUSH
48477: LD_INT 3
48479: PUSH
48480: LD_INT 2
48482: NEG
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: PUSH
48488: LD_INT 5
48490: PUSH
48491: LD_INT 2
48493: PUSH
48494: EMPTY
48495: LIST
48496: LIST
48497: PUSH
48498: LD_INT 3
48500: PUSH
48501: LD_INT 3
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 3
48510: PUSH
48511: LD_INT 2
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PUSH
48518: LD_INT 4
48520: PUSH
48521: LD_INT 3
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: PUSH
48528: LD_INT 4
48530: PUSH
48531: LD_INT 4
48533: PUSH
48534: EMPTY
48535: LIST
48536: LIST
48537: PUSH
48538: LD_INT 3
48540: PUSH
48541: LD_INT 4
48543: PUSH
48544: EMPTY
48545: LIST
48546: LIST
48547: PUSH
48548: LD_INT 2
48550: PUSH
48551: LD_INT 3
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PUSH
48558: LD_INT 2
48560: PUSH
48561: LD_INT 2
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 4
48570: PUSH
48571: LD_INT 2
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 2
48580: PUSH
48581: LD_INT 4
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: LD_INT 0
48590: PUSH
48591: LD_INT 4
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 0
48600: PUSH
48601: LD_INT 3
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: PUSH
48608: LD_INT 1
48610: PUSH
48611: LD_INT 4
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: PUSH
48618: LD_INT 1
48620: PUSH
48621: LD_INT 5
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: PUSH
48628: LD_INT 0
48630: PUSH
48631: LD_INT 5
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: PUSH
48638: LD_INT 1
48640: NEG
48641: PUSH
48642: LD_INT 4
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: PUSH
48649: LD_INT 1
48651: NEG
48652: PUSH
48653: LD_INT 3
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: PUSH
48660: LD_INT 2
48662: PUSH
48663: LD_INT 5
48665: PUSH
48666: EMPTY
48667: LIST
48668: LIST
48669: PUSH
48670: LD_INT 2
48672: NEG
48673: PUSH
48674: LD_INT 3
48676: PUSH
48677: EMPTY
48678: LIST
48679: LIST
48680: PUSH
48681: LD_INT 3
48683: NEG
48684: PUSH
48685: LD_INT 0
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 3
48694: NEG
48695: PUSH
48696: LD_INT 1
48698: NEG
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PUSH
48704: LD_INT 2
48706: NEG
48707: PUSH
48708: LD_INT 0
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 2
48717: NEG
48718: PUSH
48719: LD_INT 1
48721: PUSH
48722: EMPTY
48723: LIST
48724: LIST
48725: PUSH
48726: LD_INT 3
48728: NEG
48729: PUSH
48730: LD_INT 1
48732: PUSH
48733: EMPTY
48734: LIST
48735: LIST
48736: PUSH
48737: LD_INT 4
48739: NEG
48740: PUSH
48741: LD_INT 0
48743: PUSH
48744: EMPTY
48745: LIST
48746: LIST
48747: PUSH
48748: LD_INT 4
48750: NEG
48751: PUSH
48752: LD_INT 1
48754: NEG
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: PUSH
48760: LD_INT 4
48762: NEG
48763: PUSH
48764: LD_INT 2
48766: NEG
48767: PUSH
48768: EMPTY
48769: LIST
48770: LIST
48771: PUSH
48772: LD_INT 2
48774: NEG
48775: PUSH
48776: LD_INT 2
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: PUSH
48783: LD_INT 4
48785: NEG
48786: PUSH
48787: LD_INT 4
48789: NEG
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PUSH
48795: LD_INT 4
48797: NEG
48798: PUSH
48799: LD_INT 5
48801: NEG
48802: PUSH
48803: EMPTY
48804: LIST
48805: LIST
48806: PUSH
48807: LD_INT 3
48809: NEG
48810: PUSH
48811: LD_INT 4
48813: NEG
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: PUSH
48819: LD_INT 3
48821: NEG
48822: PUSH
48823: LD_INT 3
48825: NEG
48826: PUSH
48827: EMPTY
48828: LIST
48829: LIST
48830: PUSH
48831: LD_INT 4
48833: NEG
48834: PUSH
48835: LD_INT 3
48837: NEG
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: PUSH
48843: LD_INT 5
48845: NEG
48846: PUSH
48847: LD_INT 4
48849: NEG
48850: PUSH
48851: EMPTY
48852: LIST
48853: LIST
48854: PUSH
48855: LD_INT 5
48857: NEG
48858: PUSH
48859: LD_INT 5
48861: NEG
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: PUSH
48867: LD_INT 3
48869: NEG
48870: PUSH
48871: LD_INT 5
48873: NEG
48874: PUSH
48875: EMPTY
48876: LIST
48877: LIST
48878: PUSH
48879: LD_INT 5
48881: NEG
48882: PUSH
48883: LD_INT 3
48885: NEG
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PUSH
48891: EMPTY
48892: LIST
48893: LIST
48894: LIST
48895: LIST
48896: LIST
48897: LIST
48898: LIST
48899: LIST
48900: LIST
48901: LIST
48902: LIST
48903: LIST
48904: LIST
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48938: LD_ADDR_VAR 0 30
48942: PUSH
48943: LD_INT 4
48945: PUSH
48946: LD_INT 4
48948: PUSH
48949: EMPTY
48950: LIST
48951: LIST
48952: PUSH
48953: LD_INT 4
48955: PUSH
48956: LD_INT 3
48958: PUSH
48959: EMPTY
48960: LIST
48961: LIST
48962: PUSH
48963: LD_INT 5
48965: PUSH
48966: LD_INT 4
48968: PUSH
48969: EMPTY
48970: LIST
48971: LIST
48972: PUSH
48973: LD_INT 5
48975: PUSH
48976: LD_INT 5
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: PUSH
48983: LD_INT 4
48985: PUSH
48986: LD_INT 5
48988: PUSH
48989: EMPTY
48990: LIST
48991: LIST
48992: PUSH
48993: LD_INT 3
48995: PUSH
48996: LD_INT 4
48998: PUSH
48999: EMPTY
49000: LIST
49001: LIST
49002: PUSH
49003: LD_INT 3
49005: PUSH
49006: LD_INT 3
49008: PUSH
49009: EMPTY
49010: LIST
49011: LIST
49012: PUSH
49013: LD_INT 5
49015: PUSH
49016: LD_INT 3
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: PUSH
49023: LD_INT 3
49025: PUSH
49026: LD_INT 5
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PUSH
49033: LD_INT 0
49035: PUSH
49036: LD_INT 3
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 0
49045: PUSH
49046: LD_INT 2
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PUSH
49053: LD_INT 1
49055: PUSH
49056: LD_INT 3
49058: PUSH
49059: EMPTY
49060: LIST
49061: LIST
49062: PUSH
49063: LD_INT 1
49065: PUSH
49066: LD_INT 4
49068: PUSH
49069: EMPTY
49070: LIST
49071: LIST
49072: PUSH
49073: LD_INT 0
49075: PUSH
49076: LD_INT 4
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: LD_INT 1
49085: NEG
49086: PUSH
49087: LD_INT 3
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: LD_INT 1
49096: NEG
49097: PUSH
49098: LD_INT 2
49100: PUSH
49101: EMPTY
49102: LIST
49103: LIST
49104: PUSH
49105: LD_INT 2
49107: PUSH
49108: LD_INT 4
49110: PUSH
49111: EMPTY
49112: LIST
49113: LIST
49114: PUSH
49115: LD_INT 2
49117: NEG
49118: PUSH
49119: LD_INT 2
49121: PUSH
49122: EMPTY
49123: LIST
49124: LIST
49125: PUSH
49126: LD_INT 4
49128: NEG
49129: PUSH
49130: LD_INT 0
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: LD_INT 4
49139: NEG
49140: PUSH
49141: LD_INT 1
49143: NEG
49144: PUSH
49145: EMPTY
49146: LIST
49147: LIST
49148: PUSH
49149: LD_INT 3
49151: NEG
49152: PUSH
49153: LD_INT 0
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: PUSH
49160: LD_INT 3
49162: NEG
49163: PUSH
49164: LD_INT 1
49166: PUSH
49167: EMPTY
49168: LIST
49169: LIST
49170: PUSH
49171: LD_INT 4
49173: NEG
49174: PUSH
49175: LD_INT 1
49177: PUSH
49178: EMPTY
49179: LIST
49180: LIST
49181: PUSH
49182: LD_INT 5
49184: NEG
49185: PUSH
49186: LD_INT 0
49188: PUSH
49189: EMPTY
49190: LIST
49191: LIST
49192: PUSH
49193: LD_INT 5
49195: NEG
49196: PUSH
49197: LD_INT 1
49199: NEG
49200: PUSH
49201: EMPTY
49202: LIST
49203: LIST
49204: PUSH
49205: LD_INT 5
49207: NEG
49208: PUSH
49209: LD_INT 2
49211: NEG
49212: PUSH
49213: EMPTY
49214: LIST
49215: LIST
49216: PUSH
49217: LD_INT 3
49219: NEG
49220: PUSH
49221: LD_INT 2
49223: PUSH
49224: EMPTY
49225: LIST
49226: LIST
49227: PUSH
49228: LD_INT 3
49230: NEG
49231: PUSH
49232: LD_INT 3
49234: NEG
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: LD_INT 3
49242: NEG
49243: PUSH
49244: LD_INT 4
49246: NEG
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PUSH
49252: LD_INT 2
49254: NEG
49255: PUSH
49256: LD_INT 3
49258: NEG
49259: PUSH
49260: EMPTY
49261: LIST
49262: LIST
49263: PUSH
49264: LD_INT 2
49266: NEG
49267: PUSH
49268: LD_INT 2
49270: NEG
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: PUSH
49276: LD_INT 3
49278: NEG
49279: PUSH
49280: LD_INT 2
49282: NEG
49283: PUSH
49284: EMPTY
49285: LIST
49286: LIST
49287: PUSH
49288: LD_INT 4
49290: NEG
49291: PUSH
49292: LD_INT 3
49294: NEG
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: PUSH
49300: LD_INT 4
49302: NEG
49303: PUSH
49304: LD_INT 4
49306: NEG
49307: PUSH
49308: EMPTY
49309: LIST
49310: LIST
49311: PUSH
49312: LD_INT 2
49314: NEG
49315: PUSH
49316: LD_INT 4
49318: NEG
49319: PUSH
49320: EMPTY
49321: LIST
49322: LIST
49323: PUSH
49324: LD_INT 4
49326: NEG
49327: PUSH
49328: LD_INT 2
49330: NEG
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: LD_INT 0
49338: PUSH
49339: LD_INT 4
49341: NEG
49342: PUSH
49343: EMPTY
49344: LIST
49345: LIST
49346: PUSH
49347: LD_INT 0
49349: PUSH
49350: LD_INT 5
49352: NEG
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: PUSH
49358: LD_INT 1
49360: PUSH
49361: LD_INT 4
49363: NEG
49364: PUSH
49365: EMPTY
49366: LIST
49367: LIST
49368: PUSH
49369: LD_INT 1
49371: PUSH
49372: LD_INT 3
49374: NEG
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: PUSH
49380: LD_INT 0
49382: PUSH
49383: LD_INT 3
49385: NEG
49386: PUSH
49387: EMPTY
49388: LIST
49389: LIST
49390: PUSH
49391: LD_INT 1
49393: NEG
49394: PUSH
49395: LD_INT 4
49397: NEG
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PUSH
49403: LD_INT 1
49405: NEG
49406: PUSH
49407: LD_INT 5
49409: NEG
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PUSH
49415: LD_INT 2
49417: PUSH
49418: LD_INT 3
49420: NEG
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: PUSH
49426: LD_INT 2
49428: NEG
49429: PUSH
49430: LD_INT 5
49432: NEG
49433: PUSH
49434: EMPTY
49435: LIST
49436: LIST
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: LIST
49442: LIST
49443: LIST
49444: LIST
49445: LIST
49446: LIST
49447: LIST
49448: LIST
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49485: LD_ADDR_VAR 0 31
49489: PUSH
49490: LD_INT 0
49492: PUSH
49493: LD_INT 4
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 0
49502: PUSH
49503: LD_INT 3
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 1
49512: PUSH
49513: LD_INT 4
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: PUSH
49520: LD_INT 1
49522: PUSH
49523: LD_INT 5
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: LD_INT 0
49532: PUSH
49533: LD_INT 5
49535: PUSH
49536: EMPTY
49537: LIST
49538: LIST
49539: PUSH
49540: LD_INT 1
49542: NEG
49543: PUSH
49544: LD_INT 4
49546: PUSH
49547: EMPTY
49548: LIST
49549: LIST
49550: PUSH
49551: LD_INT 1
49553: NEG
49554: PUSH
49555: LD_INT 3
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 2
49564: PUSH
49565: LD_INT 5
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: PUSH
49572: LD_INT 2
49574: NEG
49575: PUSH
49576: LD_INT 3
49578: PUSH
49579: EMPTY
49580: LIST
49581: LIST
49582: PUSH
49583: LD_INT 3
49585: NEG
49586: PUSH
49587: LD_INT 0
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: PUSH
49594: LD_INT 3
49596: NEG
49597: PUSH
49598: LD_INT 1
49600: NEG
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PUSH
49606: LD_INT 2
49608: NEG
49609: PUSH
49610: LD_INT 0
49612: PUSH
49613: EMPTY
49614: LIST
49615: LIST
49616: PUSH
49617: LD_INT 2
49619: NEG
49620: PUSH
49621: LD_INT 1
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: PUSH
49628: LD_INT 3
49630: NEG
49631: PUSH
49632: LD_INT 1
49634: PUSH
49635: EMPTY
49636: LIST
49637: LIST
49638: PUSH
49639: LD_INT 4
49641: NEG
49642: PUSH
49643: LD_INT 0
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 4
49652: NEG
49653: PUSH
49654: LD_INT 1
49656: NEG
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: LD_INT 4
49664: NEG
49665: PUSH
49666: LD_INT 2
49668: NEG
49669: PUSH
49670: EMPTY
49671: LIST
49672: LIST
49673: PUSH
49674: LD_INT 2
49676: NEG
49677: PUSH
49678: LD_INT 2
49680: PUSH
49681: EMPTY
49682: LIST
49683: LIST
49684: PUSH
49685: LD_INT 4
49687: NEG
49688: PUSH
49689: LD_INT 4
49691: NEG
49692: PUSH
49693: EMPTY
49694: LIST
49695: LIST
49696: PUSH
49697: LD_INT 4
49699: NEG
49700: PUSH
49701: LD_INT 5
49703: NEG
49704: PUSH
49705: EMPTY
49706: LIST
49707: LIST
49708: PUSH
49709: LD_INT 3
49711: NEG
49712: PUSH
49713: LD_INT 4
49715: NEG
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PUSH
49721: LD_INT 3
49723: NEG
49724: PUSH
49725: LD_INT 3
49727: NEG
49728: PUSH
49729: EMPTY
49730: LIST
49731: LIST
49732: PUSH
49733: LD_INT 4
49735: NEG
49736: PUSH
49737: LD_INT 3
49739: NEG
49740: PUSH
49741: EMPTY
49742: LIST
49743: LIST
49744: PUSH
49745: LD_INT 5
49747: NEG
49748: PUSH
49749: LD_INT 4
49751: NEG
49752: PUSH
49753: EMPTY
49754: LIST
49755: LIST
49756: PUSH
49757: LD_INT 5
49759: NEG
49760: PUSH
49761: LD_INT 5
49763: NEG
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: PUSH
49769: LD_INT 3
49771: NEG
49772: PUSH
49773: LD_INT 5
49775: NEG
49776: PUSH
49777: EMPTY
49778: LIST
49779: LIST
49780: PUSH
49781: LD_INT 5
49783: NEG
49784: PUSH
49785: LD_INT 3
49787: NEG
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: PUSH
49793: LD_INT 0
49795: PUSH
49796: LD_INT 3
49798: NEG
49799: PUSH
49800: EMPTY
49801: LIST
49802: LIST
49803: PUSH
49804: LD_INT 0
49806: PUSH
49807: LD_INT 4
49809: NEG
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: LD_INT 1
49817: PUSH
49818: LD_INT 3
49820: NEG
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: PUSH
49826: LD_INT 1
49828: PUSH
49829: LD_INT 2
49831: NEG
49832: PUSH
49833: EMPTY
49834: LIST
49835: LIST
49836: PUSH
49837: LD_INT 0
49839: PUSH
49840: LD_INT 2
49842: NEG
49843: PUSH
49844: EMPTY
49845: LIST
49846: LIST
49847: PUSH
49848: LD_INT 1
49850: NEG
49851: PUSH
49852: LD_INT 3
49854: NEG
49855: PUSH
49856: EMPTY
49857: LIST
49858: LIST
49859: PUSH
49860: LD_INT 1
49862: NEG
49863: PUSH
49864: LD_INT 4
49866: NEG
49867: PUSH
49868: EMPTY
49869: LIST
49870: LIST
49871: PUSH
49872: LD_INT 2
49874: PUSH
49875: LD_INT 2
49877: NEG
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: PUSH
49883: LD_INT 2
49885: NEG
49886: PUSH
49887: LD_INT 4
49889: NEG
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 4
49897: PUSH
49898: LD_INT 0
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: LD_INT 4
49907: PUSH
49908: LD_INT 1
49910: NEG
49911: PUSH
49912: EMPTY
49913: LIST
49914: LIST
49915: PUSH
49916: LD_INT 5
49918: PUSH
49919: LD_INT 0
49921: PUSH
49922: EMPTY
49923: LIST
49924: LIST
49925: PUSH
49926: LD_INT 5
49928: PUSH
49929: LD_INT 1
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: PUSH
49936: LD_INT 4
49938: PUSH
49939: LD_INT 1
49941: PUSH
49942: EMPTY
49943: LIST
49944: LIST
49945: PUSH
49946: LD_INT 3
49948: PUSH
49949: LD_INT 0
49951: PUSH
49952: EMPTY
49953: LIST
49954: LIST
49955: PUSH
49956: LD_INT 3
49958: PUSH
49959: LD_INT 1
49961: NEG
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: LD_INT 3
49969: PUSH
49970: LD_INT 2
49972: NEG
49973: PUSH
49974: EMPTY
49975: LIST
49976: LIST
49977: PUSH
49978: LD_INT 5
49980: PUSH
49981: LD_INT 2
49983: PUSH
49984: EMPTY
49985: LIST
49986: LIST
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: LIST
49992: LIST
49993: LIST
49994: LIST
49995: LIST
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: LIST
50009: LIST
50010: LIST
50011: LIST
50012: LIST
50013: LIST
50014: LIST
50015: LIST
50016: LIST
50017: LIST
50018: LIST
50019: LIST
50020: LIST
50021: LIST
50022: LIST
50023: LIST
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: LIST
50029: LIST
50030: LIST
50031: LIST
50032: LIST
50033: LIST
50034: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
50035: LD_ADDR_VAR 0 32
50039: PUSH
50040: LD_INT 4
50042: NEG
50043: PUSH
50044: LD_INT 0
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: PUSH
50051: LD_INT 4
50053: NEG
50054: PUSH
50055: LD_INT 1
50057: NEG
50058: PUSH
50059: EMPTY
50060: LIST
50061: LIST
50062: PUSH
50063: LD_INT 3
50065: NEG
50066: PUSH
50067: LD_INT 0
50069: PUSH
50070: EMPTY
50071: LIST
50072: LIST
50073: PUSH
50074: LD_INT 3
50076: NEG
50077: PUSH
50078: LD_INT 1
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PUSH
50085: LD_INT 4
50087: NEG
50088: PUSH
50089: LD_INT 1
50091: PUSH
50092: EMPTY
50093: LIST
50094: LIST
50095: PUSH
50096: LD_INT 5
50098: NEG
50099: PUSH
50100: LD_INT 0
50102: PUSH
50103: EMPTY
50104: LIST
50105: LIST
50106: PUSH
50107: LD_INT 5
50109: NEG
50110: PUSH
50111: LD_INT 1
50113: NEG
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: PUSH
50119: LD_INT 5
50121: NEG
50122: PUSH
50123: LD_INT 2
50125: NEG
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: PUSH
50131: LD_INT 3
50133: NEG
50134: PUSH
50135: LD_INT 2
50137: PUSH
50138: EMPTY
50139: LIST
50140: LIST
50141: PUSH
50142: LD_INT 3
50144: NEG
50145: PUSH
50146: LD_INT 3
50148: NEG
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: LD_INT 3
50156: NEG
50157: PUSH
50158: LD_INT 4
50160: NEG
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PUSH
50166: LD_INT 2
50168: NEG
50169: PUSH
50170: LD_INT 3
50172: NEG
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 2
50180: NEG
50181: PUSH
50182: LD_INT 2
50184: NEG
50185: PUSH
50186: EMPTY
50187: LIST
50188: LIST
50189: PUSH
50190: LD_INT 3
50192: NEG
50193: PUSH
50194: LD_INT 2
50196: NEG
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PUSH
50202: LD_INT 4
50204: NEG
50205: PUSH
50206: LD_INT 3
50208: NEG
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PUSH
50214: LD_INT 4
50216: NEG
50217: PUSH
50218: LD_INT 4
50220: NEG
50221: PUSH
50222: EMPTY
50223: LIST
50224: LIST
50225: PUSH
50226: LD_INT 2
50228: NEG
50229: PUSH
50230: LD_INT 4
50232: NEG
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: LD_INT 4
50240: NEG
50241: PUSH
50242: LD_INT 2
50244: NEG
50245: PUSH
50246: EMPTY
50247: LIST
50248: LIST
50249: PUSH
50250: LD_INT 0
50252: PUSH
50253: LD_INT 4
50255: NEG
50256: PUSH
50257: EMPTY
50258: LIST
50259: LIST
50260: PUSH
50261: LD_INT 0
50263: PUSH
50264: LD_INT 5
50266: NEG
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: PUSH
50272: LD_INT 1
50274: PUSH
50275: LD_INT 4
50277: NEG
50278: PUSH
50279: EMPTY
50280: LIST
50281: LIST
50282: PUSH
50283: LD_INT 1
50285: PUSH
50286: LD_INT 3
50288: NEG
50289: PUSH
50290: EMPTY
50291: LIST
50292: LIST
50293: PUSH
50294: LD_INT 0
50296: PUSH
50297: LD_INT 3
50299: NEG
50300: PUSH
50301: EMPTY
50302: LIST
50303: LIST
50304: PUSH
50305: LD_INT 1
50307: NEG
50308: PUSH
50309: LD_INT 4
50311: NEG
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: PUSH
50317: LD_INT 1
50319: NEG
50320: PUSH
50321: LD_INT 5
50323: NEG
50324: PUSH
50325: EMPTY
50326: LIST
50327: LIST
50328: PUSH
50329: LD_INT 2
50331: PUSH
50332: LD_INT 3
50334: NEG
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: PUSH
50340: LD_INT 2
50342: NEG
50343: PUSH
50344: LD_INT 5
50346: NEG
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 3
50354: PUSH
50355: LD_INT 0
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: LD_INT 3
50364: PUSH
50365: LD_INT 1
50367: NEG
50368: PUSH
50369: EMPTY
50370: LIST
50371: LIST
50372: PUSH
50373: LD_INT 4
50375: PUSH
50376: LD_INT 0
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: LD_INT 4
50385: PUSH
50386: LD_INT 1
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: PUSH
50393: LD_INT 3
50395: PUSH
50396: LD_INT 1
50398: PUSH
50399: EMPTY
50400: LIST
50401: LIST
50402: PUSH
50403: LD_INT 2
50405: PUSH
50406: LD_INT 0
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: PUSH
50413: LD_INT 2
50415: PUSH
50416: LD_INT 1
50418: NEG
50419: PUSH
50420: EMPTY
50421: LIST
50422: LIST
50423: PUSH
50424: LD_INT 2
50426: PUSH
50427: LD_INT 2
50429: NEG
50430: PUSH
50431: EMPTY
50432: LIST
50433: LIST
50434: PUSH
50435: LD_INT 4
50437: PUSH
50438: LD_INT 2
50440: PUSH
50441: EMPTY
50442: LIST
50443: LIST
50444: PUSH
50445: LD_INT 4
50447: PUSH
50448: LD_INT 4
50450: PUSH
50451: EMPTY
50452: LIST
50453: LIST
50454: PUSH
50455: LD_INT 4
50457: PUSH
50458: LD_INT 3
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: PUSH
50465: LD_INT 5
50467: PUSH
50468: LD_INT 4
50470: PUSH
50471: EMPTY
50472: LIST
50473: LIST
50474: PUSH
50475: LD_INT 5
50477: PUSH
50478: LD_INT 5
50480: PUSH
50481: EMPTY
50482: LIST
50483: LIST
50484: PUSH
50485: LD_INT 4
50487: PUSH
50488: LD_INT 5
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PUSH
50495: LD_INT 3
50497: PUSH
50498: LD_INT 4
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 3
50507: PUSH
50508: LD_INT 3
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 5
50517: PUSH
50518: LD_INT 3
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 3
50527: PUSH
50528: LD_INT 5
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: LIST
50539: LIST
50540: LIST
50541: LIST
50542: LIST
50543: LIST
50544: LIST
50545: LIST
50546: LIST
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: LIST
50552: LIST
50553: LIST
50554: LIST
50555: LIST
50556: LIST
50557: LIST
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: LIST
50563: LIST
50564: LIST
50565: LIST
50566: LIST
50567: LIST
50568: LIST
50569: LIST
50570: LIST
50571: LIST
50572: LIST
50573: LIST
50574: LIST
50575: LIST
50576: LIST
50577: LIST
50578: LIST
50579: LIST
50580: LIST
50581: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50582: LD_ADDR_VAR 0 33
50586: PUSH
50587: LD_INT 4
50589: NEG
50590: PUSH
50591: LD_INT 4
50593: NEG
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: PUSH
50599: LD_INT 4
50601: NEG
50602: PUSH
50603: LD_INT 5
50605: NEG
50606: PUSH
50607: EMPTY
50608: LIST
50609: LIST
50610: PUSH
50611: LD_INT 3
50613: NEG
50614: PUSH
50615: LD_INT 4
50617: NEG
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PUSH
50623: LD_INT 3
50625: NEG
50626: PUSH
50627: LD_INT 3
50629: NEG
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 4
50637: NEG
50638: PUSH
50639: LD_INT 3
50641: NEG
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: PUSH
50647: LD_INT 5
50649: NEG
50650: PUSH
50651: LD_INT 4
50653: NEG
50654: PUSH
50655: EMPTY
50656: LIST
50657: LIST
50658: PUSH
50659: LD_INT 5
50661: NEG
50662: PUSH
50663: LD_INT 5
50665: NEG
50666: PUSH
50667: EMPTY
50668: LIST
50669: LIST
50670: PUSH
50671: LD_INT 3
50673: NEG
50674: PUSH
50675: LD_INT 5
50677: NEG
50678: PUSH
50679: EMPTY
50680: LIST
50681: LIST
50682: PUSH
50683: LD_INT 5
50685: NEG
50686: PUSH
50687: LD_INT 3
50689: NEG
50690: PUSH
50691: EMPTY
50692: LIST
50693: LIST
50694: PUSH
50695: LD_INT 0
50697: PUSH
50698: LD_INT 3
50700: NEG
50701: PUSH
50702: EMPTY
50703: LIST
50704: LIST
50705: PUSH
50706: LD_INT 0
50708: PUSH
50709: LD_INT 4
50711: NEG
50712: PUSH
50713: EMPTY
50714: LIST
50715: LIST
50716: PUSH
50717: LD_INT 1
50719: PUSH
50720: LD_INT 3
50722: NEG
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: PUSH
50728: LD_INT 1
50730: PUSH
50731: LD_INT 2
50733: NEG
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 0
50741: PUSH
50742: LD_INT 2
50744: NEG
50745: PUSH
50746: EMPTY
50747: LIST
50748: LIST
50749: PUSH
50750: LD_INT 1
50752: NEG
50753: PUSH
50754: LD_INT 3
50756: NEG
50757: PUSH
50758: EMPTY
50759: LIST
50760: LIST
50761: PUSH
50762: LD_INT 1
50764: NEG
50765: PUSH
50766: LD_INT 4
50768: NEG
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: PUSH
50774: LD_INT 2
50776: PUSH
50777: LD_INT 2
50779: NEG
50780: PUSH
50781: EMPTY
50782: LIST
50783: LIST
50784: PUSH
50785: LD_INT 2
50787: NEG
50788: PUSH
50789: LD_INT 4
50791: NEG
50792: PUSH
50793: EMPTY
50794: LIST
50795: LIST
50796: PUSH
50797: LD_INT 4
50799: PUSH
50800: LD_INT 0
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: PUSH
50807: LD_INT 4
50809: PUSH
50810: LD_INT 1
50812: NEG
50813: PUSH
50814: EMPTY
50815: LIST
50816: LIST
50817: PUSH
50818: LD_INT 5
50820: PUSH
50821: LD_INT 0
50823: PUSH
50824: EMPTY
50825: LIST
50826: LIST
50827: PUSH
50828: LD_INT 5
50830: PUSH
50831: LD_INT 1
50833: PUSH
50834: EMPTY
50835: LIST
50836: LIST
50837: PUSH
50838: LD_INT 4
50840: PUSH
50841: LD_INT 1
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: PUSH
50848: LD_INT 3
50850: PUSH
50851: LD_INT 0
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PUSH
50858: LD_INT 3
50860: PUSH
50861: LD_INT 1
50863: NEG
50864: PUSH
50865: EMPTY
50866: LIST
50867: LIST
50868: PUSH
50869: LD_INT 3
50871: PUSH
50872: LD_INT 2
50874: NEG
50875: PUSH
50876: EMPTY
50877: LIST
50878: LIST
50879: PUSH
50880: LD_INT 5
50882: PUSH
50883: LD_INT 2
50885: PUSH
50886: EMPTY
50887: LIST
50888: LIST
50889: PUSH
50890: LD_INT 3
50892: PUSH
50893: LD_INT 3
50895: PUSH
50896: EMPTY
50897: LIST
50898: LIST
50899: PUSH
50900: LD_INT 3
50902: PUSH
50903: LD_INT 2
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 4
50912: PUSH
50913: LD_INT 3
50915: PUSH
50916: EMPTY
50917: LIST
50918: LIST
50919: PUSH
50920: LD_INT 4
50922: PUSH
50923: LD_INT 4
50925: PUSH
50926: EMPTY
50927: LIST
50928: LIST
50929: PUSH
50930: LD_INT 3
50932: PUSH
50933: LD_INT 4
50935: PUSH
50936: EMPTY
50937: LIST
50938: LIST
50939: PUSH
50940: LD_INT 2
50942: PUSH
50943: LD_INT 3
50945: PUSH
50946: EMPTY
50947: LIST
50948: LIST
50949: PUSH
50950: LD_INT 2
50952: PUSH
50953: LD_INT 2
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PUSH
50960: LD_INT 4
50962: PUSH
50963: LD_INT 2
50965: PUSH
50966: EMPTY
50967: LIST
50968: LIST
50969: PUSH
50970: LD_INT 2
50972: PUSH
50973: LD_INT 4
50975: PUSH
50976: EMPTY
50977: LIST
50978: LIST
50979: PUSH
50980: LD_INT 0
50982: PUSH
50983: LD_INT 4
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: PUSH
50990: LD_INT 0
50992: PUSH
50993: LD_INT 3
50995: PUSH
50996: EMPTY
50997: LIST
50998: LIST
50999: PUSH
51000: LD_INT 1
51002: PUSH
51003: LD_INT 4
51005: PUSH
51006: EMPTY
51007: LIST
51008: LIST
51009: PUSH
51010: LD_INT 1
51012: PUSH
51013: LD_INT 5
51015: PUSH
51016: EMPTY
51017: LIST
51018: LIST
51019: PUSH
51020: LD_INT 0
51022: PUSH
51023: LD_INT 5
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PUSH
51030: LD_INT 1
51032: NEG
51033: PUSH
51034: LD_INT 4
51036: PUSH
51037: EMPTY
51038: LIST
51039: LIST
51040: PUSH
51041: LD_INT 1
51043: NEG
51044: PUSH
51045: LD_INT 3
51047: PUSH
51048: EMPTY
51049: LIST
51050: LIST
51051: PUSH
51052: LD_INT 2
51054: PUSH
51055: LD_INT 5
51057: PUSH
51058: EMPTY
51059: LIST
51060: LIST
51061: PUSH
51062: LD_INT 2
51064: NEG
51065: PUSH
51066: LD_INT 3
51068: PUSH
51069: EMPTY
51070: LIST
51071: LIST
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: LIST
51077: LIST
51078: LIST
51079: LIST
51080: LIST
51081: LIST
51082: LIST
51083: LIST
51084: LIST
51085: LIST
51086: LIST
51087: LIST
51088: LIST
51089: LIST
51090: LIST
51091: LIST
51092: LIST
51093: LIST
51094: LIST
51095: LIST
51096: LIST
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
51120: LD_ADDR_VAR 0 34
51124: PUSH
51125: LD_INT 0
51127: PUSH
51128: LD_INT 4
51130: NEG
51131: PUSH
51132: EMPTY
51133: LIST
51134: LIST
51135: PUSH
51136: LD_INT 0
51138: PUSH
51139: LD_INT 5
51141: NEG
51142: PUSH
51143: EMPTY
51144: LIST
51145: LIST
51146: PUSH
51147: LD_INT 1
51149: PUSH
51150: LD_INT 4
51152: NEG
51153: PUSH
51154: EMPTY
51155: LIST
51156: LIST
51157: PUSH
51158: LD_INT 1
51160: PUSH
51161: LD_INT 3
51163: NEG
51164: PUSH
51165: EMPTY
51166: LIST
51167: LIST
51168: PUSH
51169: LD_INT 0
51171: PUSH
51172: LD_INT 3
51174: NEG
51175: PUSH
51176: EMPTY
51177: LIST
51178: LIST
51179: PUSH
51180: LD_INT 1
51182: NEG
51183: PUSH
51184: LD_INT 4
51186: NEG
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: PUSH
51192: LD_INT 1
51194: NEG
51195: PUSH
51196: LD_INT 5
51198: NEG
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: LD_INT 2
51206: PUSH
51207: LD_INT 3
51209: NEG
51210: PUSH
51211: EMPTY
51212: LIST
51213: LIST
51214: PUSH
51215: LD_INT 2
51217: NEG
51218: PUSH
51219: LD_INT 5
51221: NEG
51222: PUSH
51223: EMPTY
51224: LIST
51225: LIST
51226: PUSH
51227: LD_INT 3
51229: PUSH
51230: LD_INT 0
51232: PUSH
51233: EMPTY
51234: LIST
51235: LIST
51236: PUSH
51237: LD_INT 3
51239: PUSH
51240: LD_INT 1
51242: NEG
51243: PUSH
51244: EMPTY
51245: LIST
51246: LIST
51247: PUSH
51248: LD_INT 4
51250: PUSH
51251: LD_INT 0
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PUSH
51258: LD_INT 4
51260: PUSH
51261: LD_INT 1
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 3
51270: PUSH
51271: LD_INT 1
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PUSH
51278: LD_INT 2
51280: PUSH
51281: LD_INT 0
51283: PUSH
51284: EMPTY
51285: LIST
51286: LIST
51287: PUSH
51288: LD_INT 2
51290: PUSH
51291: LD_INT 1
51293: NEG
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: PUSH
51299: LD_INT 2
51301: PUSH
51302: LD_INT 2
51304: NEG
51305: PUSH
51306: EMPTY
51307: LIST
51308: LIST
51309: PUSH
51310: LD_INT 4
51312: PUSH
51313: LD_INT 2
51315: PUSH
51316: EMPTY
51317: LIST
51318: LIST
51319: PUSH
51320: LD_INT 4
51322: PUSH
51323: LD_INT 4
51325: PUSH
51326: EMPTY
51327: LIST
51328: LIST
51329: PUSH
51330: LD_INT 4
51332: PUSH
51333: LD_INT 3
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: PUSH
51340: LD_INT 5
51342: PUSH
51343: LD_INT 4
51345: PUSH
51346: EMPTY
51347: LIST
51348: LIST
51349: PUSH
51350: LD_INT 5
51352: PUSH
51353: LD_INT 5
51355: PUSH
51356: EMPTY
51357: LIST
51358: LIST
51359: PUSH
51360: LD_INT 4
51362: PUSH
51363: LD_INT 5
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: PUSH
51370: LD_INT 3
51372: PUSH
51373: LD_INT 4
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 3
51382: PUSH
51383: LD_INT 3
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: PUSH
51390: LD_INT 5
51392: PUSH
51393: LD_INT 3
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PUSH
51400: LD_INT 3
51402: PUSH
51403: LD_INT 5
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 0
51412: PUSH
51413: LD_INT 3
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PUSH
51420: LD_INT 0
51422: PUSH
51423: LD_INT 2
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 1
51432: PUSH
51433: LD_INT 3
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: PUSH
51440: LD_INT 1
51442: PUSH
51443: LD_INT 4
51445: PUSH
51446: EMPTY
51447: LIST
51448: LIST
51449: PUSH
51450: LD_INT 0
51452: PUSH
51453: LD_INT 4
51455: PUSH
51456: EMPTY
51457: LIST
51458: LIST
51459: PUSH
51460: LD_INT 1
51462: NEG
51463: PUSH
51464: LD_INT 3
51466: PUSH
51467: EMPTY
51468: LIST
51469: LIST
51470: PUSH
51471: LD_INT 1
51473: NEG
51474: PUSH
51475: LD_INT 2
51477: PUSH
51478: EMPTY
51479: LIST
51480: LIST
51481: PUSH
51482: LD_INT 2
51484: PUSH
51485: LD_INT 4
51487: PUSH
51488: EMPTY
51489: LIST
51490: LIST
51491: PUSH
51492: LD_INT 2
51494: NEG
51495: PUSH
51496: LD_INT 2
51498: PUSH
51499: EMPTY
51500: LIST
51501: LIST
51502: PUSH
51503: LD_INT 4
51505: NEG
51506: PUSH
51507: LD_INT 0
51509: PUSH
51510: EMPTY
51511: LIST
51512: LIST
51513: PUSH
51514: LD_INT 4
51516: NEG
51517: PUSH
51518: LD_INT 1
51520: NEG
51521: PUSH
51522: EMPTY
51523: LIST
51524: LIST
51525: PUSH
51526: LD_INT 3
51528: NEG
51529: PUSH
51530: LD_INT 0
51532: PUSH
51533: EMPTY
51534: LIST
51535: LIST
51536: PUSH
51537: LD_INT 3
51539: NEG
51540: PUSH
51541: LD_INT 1
51543: PUSH
51544: EMPTY
51545: LIST
51546: LIST
51547: PUSH
51548: LD_INT 4
51550: NEG
51551: PUSH
51552: LD_INT 1
51554: PUSH
51555: EMPTY
51556: LIST
51557: LIST
51558: PUSH
51559: LD_INT 5
51561: NEG
51562: PUSH
51563: LD_INT 0
51565: PUSH
51566: EMPTY
51567: LIST
51568: LIST
51569: PUSH
51570: LD_INT 5
51572: NEG
51573: PUSH
51574: LD_INT 1
51576: NEG
51577: PUSH
51578: EMPTY
51579: LIST
51580: LIST
51581: PUSH
51582: LD_INT 5
51584: NEG
51585: PUSH
51586: LD_INT 2
51588: NEG
51589: PUSH
51590: EMPTY
51591: LIST
51592: LIST
51593: PUSH
51594: LD_INT 3
51596: NEG
51597: PUSH
51598: LD_INT 2
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: LIST
51627: LIST
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: LIST
51650: LIST
51651: ST_TO_ADDR
// end ; end ;
51652: GO 51655
51654: POP
// case btype of b_depot , b_warehouse :
51655: LD_VAR 0 1
51659: PUSH
51660: LD_INT 0
51662: DOUBLE
51663: EQUAL
51664: IFTRUE 51674
51666: LD_INT 1
51668: DOUBLE
51669: EQUAL
51670: IFTRUE 51674
51672: GO 51875
51674: POP
// case nation of nation_american :
51675: LD_VAR 0 5
51679: PUSH
51680: LD_INT 1
51682: DOUBLE
51683: EQUAL
51684: IFTRUE 51688
51686: GO 51744
51688: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51689: LD_ADDR_VAR 0 9
51693: PUSH
51694: LD_VAR 0 11
51698: PUSH
51699: LD_VAR 0 12
51703: PUSH
51704: LD_VAR 0 13
51708: PUSH
51709: LD_VAR 0 14
51713: PUSH
51714: LD_VAR 0 15
51718: PUSH
51719: LD_VAR 0 16
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: LIST
51728: LIST
51729: LIST
51730: LIST
51731: PUSH
51732: LD_VAR 0 4
51736: PUSH
51737: LD_INT 1
51739: PLUS
51740: ARRAY
51741: ST_TO_ADDR
51742: GO 51873
51744: LD_INT 2
51746: DOUBLE
51747: EQUAL
51748: IFTRUE 51752
51750: GO 51808
51752: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51753: LD_ADDR_VAR 0 9
51757: PUSH
51758: LD_VAR 0 17
51762: PUSH
51763: LD_VAR 0 18
51767: PUSH
51768: LD_VAR 0 19
51772: PUSH
51773: LD_VAR 0 20
51777: PUSH
51778: LD_VAR 0 21
51782: PUSH
51783: LD_VAR 0 22
51787: PUSH
51788: EMPTY
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: PUSH
51796: LD_VAR 0 4
51800: PUSH
51801: LD_INT 1
51803: PLUS
51804: ARRAY
51805: ST_TO_ADDR
51806: GO 51873
51808: LD_INT 3
51810: DOUBLE
51811: EQUAL
51812: IFTRUE 51816
51814: GO 51872
51816: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51817: LD_ADDR_VAR 0 9
51821: PUSH
51822: LD_VAR 0 23
51826: PUSH
51827: LD_VAR 0 24
51831: PUSH
51832: LD_VAR 0 25
51836: PUSH
51837: LD_VAR 0 26
51841: PUSH
51842: LD_VAR 0 27
51846: PUSH
51847: LD_VAR 0 28
51851: PUSH
51852: EMPTY
51853: LIST
51854: LIST
51855: LIST
51856: LIST
51857: LIST
51858: LIST
51859: PUSH
51860: LD_VAR 0 4
51864: PUSH
51865: LD_INT 1
51867: PLUS
51868: ARRAY
51869: ST_TO_ADDR
51870: GO 51873
51872: POP
51873: GO 52428
51875: LD_INT 2
51877: DOUBLE
51878: EQUAL
51879: IFTRUE 51889
51881: LD_INT 3
51883: DOUBLE
51884: EQUAL
51885: IFTRUE 51889
51887: GO 51945
51889: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51890: LD_ADDR_VAR 0 9
51894: PUSH
51895: LD_VAR 0 29
51899: PUSH
51900: LD_VAR 0 30
51904: PUSH
51905: LD_VAR 0 31
51909: PUSH
51910: LD_VAR 0 32
51914: PUSH
51915: LD_VAR 0 33
51919: PUSH
51920: LD_VAR 0 34
51924: PUSH
51925: EMPTY
51926: LIST
51927: LIST
51928: LIST
51929: LIST
51930: LIST
51931: LIST
51932: PUSH
51933: LD_VAR 0 4
51937: PUSH
51938: LD_INT 1
51940: PLUS
51941: ARRAY
51942: ST_TO_ADDR
51943: GO 52428
51945: LD_INT 16
51947: DOUBLE
51948: EQUAL
51949: IFTRUE 52007
51951: LD_INT 17
51953: DOUBLE
51954: EQUAL
51955: IFTRUE 52007
51957: LD_INT 18
51959: DOUBLE
51960: EQUAL
51961: IFTRUE 52007
51963: LD_INT 19
51965: DOUBLE
51966: EQUAL
51967: IFTRUE 52007
51969: LD_INT 22
51971: DOUBLE
51972: EQUAL
51973: IFTRUE 52007
51975: LD_INT 20
51977: DOUBLE
51978: EQUAL
51979: IFTRUE 52007
51981: LD_INT 21
51983: DOUBLE
51984: EQUAL
51985: IFTRUE 52007
51987: LD_INT 23
51989: DOUBLE
51990: EQUAL
51991: IFTRUE 52007
51993: LD_INT 24
51995: DOUBLE
51996: EQUAL
51997: IFTRUE 52007
51999: LD_INT 25
52001: DOUBLE
52002: EQUAL
52003: IFTRUE 52007
52005: GO 52063
52007: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
52008: LD_ADDR_VAR 0 9
52012: PUSH
52013: LD_VAR 0 35
52017: PUSH
52018: LD_VAR 0 36
52022: PUSH
52023: LD_VAR 0 37
52027: PUSH
52028: LD_VAR 0 38
52032: PUSH
52033: LD_VAR 0 39
52037: PUSH
52038: LD_VAR 0 40
52042: PUSH
52043: EMPTY
52044: LIST
52045: LIST
52046: LIST
52047: LIST
52048: LIST
52049: LIST
52050: PUSH
52051: LD_VAR 0 4
52055: PUSH
52056: LD_INT 1
52058: PLUS
52059: ARRAY
52060: ST_TO_ADDR
52061: GO 52428
52063: LD_INT 6
52065: DOUBLE
52066: EQUAL
52067: IFTRUE 52119
52069: LD_INT 7
52071: DOUBLE
52072: EQUAL
52073: IFTRUE 52119
52075: LD_INT 8
52077: DOUBLE
52078: EQUAL
52079: IFTRUE 52119
52081: LD_INT 13
52083: DOUBLE
52084: EQUAL
52085: IFTRUE 52119
52087: LD_INT 12
52089: DOUBLE
52090: EQUAL
52091: IFTRUE 52119
52093: LD_INT 15
52095: DOUBLE
52096: EQUAL
52097: IFTRUE 52119
52099: LD_INT 11
52101: DOUBLE
52102: EQUAL
52103: IFTRUE 52119
52105: LD_INT 14
52107: DOUBLE
52108: EQUAL
52109: IFTRUE 52119
52111: LD_INT 10
52113: DOUBLE
52114: EQUAL
52115: IFTRUE 52119
52117: GO 52175
52119: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
52120: LD_ADDR_VAR 0 9
52124: PUSH
52125: LD_VAR 0 41
52129: PUSH
52130: LD_VAR 0 42
52134: PUSH
52135: LD_VAR 0 43
52139: PUSH
52140: LD_VAR 0 44
52144: PUSH
52145: LD_VAR 0 45
52149: PUSH
52150: LD_VAR 0 46
52154: PUSH
52155: EMPTY
52156: LIST
52157: LIST
52158: LIST
52159: LIST
52160: LIST
52161: LIST
52162: PUSH
52163: LD_VAR 0 4
52167: PUSH
52168: LD_INT 1
52170: PLUS
52171: ARRAY
52172: ST_TO_ADDR
52173: GO 52428
52175: LD_INT 36
52177: DOUBLE
52178: EQUAL
52179: IFTRUE 52183
52181: GO 52239
52183: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52184: LD_ADDR_VAR 0 9
52188: PUSH
52189: LD_VAR 0 47
52193: PUSH
52194: LD_VAR 0 48
52198: PUSH
52199: LD_VAR 0 49
52203: PUSH
52204: LD_VAR 0 50
52208: PUSH
52209: LD_VAR 0 51
52213: PUSH
52214: LD_VAR 0 52
52218: PUSH
52219: EMPTY
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: LIST
52226: PUSH
52227: LD_VAR 0 4
52231: PUSH
52232: LD_INT 1
52234: PLUS
52235: ARRAY
52236: ST_TO_ADDR
52237: GO 52428
52239: LD_INT 4
52241: DOUBLE
52242: EQUAL
52243: IFTRUE 52265
52245: LD_INT 5
52247: DOUBLE
52248: EQUAL
52249: IFTRUE 52265
52251: LD_INT 34
52253: DOUBLE
52254: EQUAL
52255: IFTRUE 52265
52257: LD_INT 37
52259: DOUBLE
52260: EQUAL
52261: IFTRUE 52265
52263: GO 52321
52265: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52266: LD_ADDR_VAR 0 9
52270: PUSH
52271: LD_VAR 0 53
52275: PUSH
52276: LD_VAR 0 54
52280: PUSH
52281: LD_VAR 0 55
52285: PUSH
52286: LD_VAR 0 56
52290: PUSH
52291: LD_VAR 0 57
52295: PUSH
52296: LD_VAR 0 58
52300: PUSH
52301: EMPTY
52302: LIST
52303: LIST
52304: LIST
52305: LIST
52306: LIST
52307: LIST
52308: PUSH
52309: LD_VAR 0 4
52313: PUSH
52314: LD_INT 1
52316: PLUS
52317: ARRAY
52318: ST_TO_ADDR
52319: GO 52428
52321: LD_INT 31
52323: DOUBLE
52324: EQUAL
52325: IFTRUE 52371
52327: LD_INT 32
52329: DOUBLE
52330: EQUAL
52331: IFTRUE 52371
52333: LD_INT 33
52335: DOUBLE
52336: EQUAL
52337: IFTRUE 52371
52339: LD_INT 27
52341: DOUBLE
52342: EQUAL
52343: IFTRUE 52371
52345: LD_INT 26
52347: DOUBLE
52348: EQUAL
52349: IFTRUE 52371
52351: LD_INT 28
52353: DOUBLE
52354: EQUAL
52355: IFTRUE 52371
52357: LD_INT 29
52359: DOUBLE
52360: EQUAL
52361: IFTRUE 52371
52363: LD_INT 30
52365: DOUBLE
52366: EQUAL
52367: IFTRUE 52371
52369: GO 52427
52371: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52372: LD_ADDR_VAR 0 9
52376: PUSH
52377: LD_VAR 0 59
52381: PUSH
52382: LD_VAR 0 60
52386: PUSH
52387: LD_VAR 0 61
52391: PUSH
52392: LD_VAR 0 62
52396: PUSH
52397: LD_VAR 0 63
52401: PUSH
52402: LD_VAR 0 64
52406: PUSH
52407: EMPTY
52408: LIST
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: PUSH
52415: LD_VAR 0 4
52419: PUSH
52420: LD_INT 1
52422: PLUS
52423: ARRAY
52424: ST_TO_ADDR
52425: GO 52428
52427: POP
// temp_list2 = [ ] ;
52428: LD_ADDR_VAR 0 10
52432: PUSH
52433: EMPTY
52434: ST_TO_ADDR
// for i in temp_list do
52435: LD_ADDR_VAR 0 8
52439: PUSH
52440: LD_VAR 0 9
52444: PUSH
52445: FOR_IN
52446: IFFALSE 52498
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52448: LD_ADDR_VAR 0 10
52452: PUSH
52453: LD_VAR 0 10
52457: PUSH
52458: LD_VAR 0 8
52462: PUSH
52463: LD_INT 1
52465: ARRAY
52466: PUSH
52467: LD_VAR 0 2
52471: PLUS
52472: PUSH
52473: LD_VAR 0 8
52477: PUSH
52478: LD_INT 2
52480: ARRAY
52481: PUSH
52482: LD_VAR 0 3
52486: PLUS
52487: PUSH
52488: EMPTY
52489: LIST
52490: LIST
52491: PUSH
52492: EMPTY
52493: LIST
52494: ADD
52495: ST_TO_ADDR
52496: GO 52445
52498: POP
52499: POP
// result = temp_list2 ;
52500: LD_ADDR_VAR 0 7
52504: PUSH
52505: LD_VAR 0 10
52509: ST_TO_ADDR
// end ;
52510: LD_VAR 0 7
52514: RET
// export function EnemyInRange ( unit , dist ) ; begin
52515: LD_INT 0
52517: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52518: LD_ADDR_VAR 0 3
52522: PUSH
52523: LD_VAR 0 1
52527: PPUSH
52528: CALL_OW 255
52532: PPUSH
52533: LD_VAR 0 1
52537: PPUSH
52538: CALL_OW 250
52542: PPUSH
52543: LD_VAR 0 1
52547: PPUSH
52548: CALL_OW 251
52552: PPUSH
52553: LD_VAR 0 2
52557: PPUSH
52558: CALL 25917 0 4
52562: PUSH
52563: LD_INT 4
52565: ARRAY
52566: ST_TO_ADDR
// end ;
52567: LD_VAR 0 3
52571: RET
// export function PlayerSeeMe ( unit ) ; begin
52572: LD_INT 0
52574: PPUSH
// result := See ( your_side , unit ) ;
52575: LD_ADDR_VAR 0 2
52579: PUSH
52580: LD_OWVAR 2
52584: PPUSH
52585: LD_VAR 0 1
52589: PPUSH
52590: CALL_OW 292
52594: ST_TO_ADDR
// end ;
52595: LD_VAR 0 2
52599: RET
// export function ReverseDir ( unit ) ; begin
52600: LD_INT 0
52602: PPUSH
// if not unit then
52603: LD_VAR 0 1
52607: NOT
52608: IFFALSE 52612
// exit ;
52610: GO 52635
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52612: LD_ADDR_VAR 0 2
52616: PUSH
52617: LD_VAR 0 1
52621: PPUSH
52622: CALL_OW 254
52626: PUSH
52627: LD_INT 3
52629: PLUS
52630: PUSH
52631: LD_INT 6
52633: MOD
52634: ST_TO_ADDR
// end ;
52635: LD_VAR 0 2
52639: RET
// export function ReverseArray ( array ) ; var i ; begin
52640: LD_INT 0
52642: PPUSH
52643: PPUSH
// if not array then
52644: LD_VAR 0 1
52648: NOT
52649: IFFALSE 52653
// exit ;
52651: GO 52708
// result := [ ] ;
52653: LD_ADDR_VAR 0 2
52657: PUSH
52658: EMPTY
52659: ST_TO_ADDR
// for i := array downto 1 do
52660: LD_ADDR_VAR 0 3
52664: PUSH
52665: DOUBLE
52666: LD_VAR 0 1
52670: INC
52671: ST_TO_ADDR
52672: LD_INT 1
52674: PUSH
52675: FOR_DOWNTO
52676: IFFALSE 52706
// result := Join ( result , array [ i ] ) ;
52678: LD_ADDR_VAR 0 2
52682: PUSH
52683: LD_VAR 0 2
52687: PPUSH
52688: LD_VAR 0 1
52692: PUSH
52693: LD_VAR 0 3
52697: ARRAY
52698: PPUSH
52699: CALL 57352 0 2
52703: ST_TO_ADDR
52704: GO 52675
52706: POP
52707: POP
// end ;
52708: LD_VAR 0 2
52712: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52713: LD_INT 0
52715: PPUSH
52716: PPUSH
52717: PPUSH
52718: PPUSH
52719: PPUSH
52720: PPUSH
// if not unit or not hexes then
52721: LD_VAR 0 1
52725: NOT
52726: PUSH
52727: LD_VAR 0 2
52731: NOT
52732: OR
52733: IFFALSE 52737
// exit ;
52735: GO 52860
// dist := 9999 ;
52737: LD_ADDR_VAR 0 5
52741: PUSH
52742: LD_INT 9999
52744: ST_TO_ADDR
// for i = 1 to hexes do
52745: LD_ADDR_VAR 0 4
52749: PUSH
52750: DOUBLE
52751: LD_INT 1
52753: DEC
52754: ST_TO_ADDR
52755: LD_VAR 0 2
52759: PUSH
52760: FOR_TO
52761: IFFALSE 52848
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52763: LD_ADDR_VAR 0 6
52767: PUSH
52768: LD_VAR 0 1
52772: PPUSH
52773: LD_VAR 0 2
52777: PUSH
52778: LD_VAR 0 4
52782: ARRAY
52783: PUSH
52784: LD_INT 1
52786: ARRAY
52787: PPUSH
52788: LD_VAR 0 2
52792: PUSH
52793: LD_VAR 0 4
52797: ARRAY
52798: PUSH
52799: LD_INT 2
52801: ARRAY
52802: PPUSH
52803: CALL_OW 297
52807: ST_TO_ADDR
// if tdist < dist then
52808: LD_VAR 0 6
52812: PUSH
52813: LD_VAR 0 5
52817: LESS
52818: IFFALSE 52846
// begin hex := hexes [ i ] ;
52820: LD_ADDR_VAR 0 8
52824: PUSH
52825: LD_VAR 0 2
52829: PUSH
52830: LD_VAR 0 4
52834: ARRAY
52835: ST_TO_ADDR
// dist := tdist ;
52836: LD_ADDR_VAR 0 5
52840: PUSH
52841: LD_VAR 0 6
52845: ST_TO_ADDR
// end ; end ;
52846: GO 52760
52848: POP
52849: POP
// result := hex ;
52850: LD_ADDR_VAR 0 3
52854: PUSH
52855: LD_VAR 0 8
52859: ST_TO_ADDR
// end ;
52860: LD_VAR 0 3
52864: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52865: LD_INT 0
52867: PPUSH
52868: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52869: LD_VAR 0 1
52873: NOT
52874: PUSH
52875: LD_VAR 0 1
52879: PUSH
52880: LD_INT 21
52882: PUSH
52883: LD_INT 2
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PUSH
52890: LD_INT 23
52892: PUSH
52893: LD_INT 2
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: PUSH
52900: EMPTY
52901: LIST
52902: LIST
52903: PPUSH
52904: CALL_OW 69
52908: IN
52909: NOT
52910: OR
52911: IFFALSE 52915
// exit ;
52913: GO 52962
// for i = 1 to 3 do
52915: LD_ADDR_VAR 0 3
52919: PUSH
52920: DOUBLE
52921: LD_INT 1
52923: DEC
52924: ST_TO_ADDR
52925: LD_INT 3
52927: PUSH
52928: FOR_TO
52929: IFFALSE 52960
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52931: LD_VAR 0 1
52935: PPUSH
52936: CALL_OW 250
52940: PPUSH
52941: LD_VAR 0 1
52945: PPUSH
52946: CALL_OW 251
52950: PPUSH
52951: LD_INT 1
52953: PPUSH
52954: CALL_OW 453
52958: GO 52928
52960: POP
52961: POP
// end ;
52962: LD_VAR 0 2
52966: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52967: LD_INT 0
52969: PPUSH
52970: PPUSH
52971: PPUSH
52972: PPUSH
52973: PPUSH
52974: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52975: LD_VAR 0 1
52979: NOT
52980: PUSH
52981: LD_VAR 0 2
52985: NOT
52986: OR
52987: PUSH
52988: LD_VAR 0 1
52992: PPUSH
52993: CALL_OW 314
52997: OR
52998: IFFALSE 53002
// exit ;
53000: GO 53469
// if GetLives ( i ) < 250 then
53002: LD_VAR 0 4
53006: PPUSH
53007: CALL_OW 256
53011: PUSH
53012: LD_INT 250
53014: LESS
53015: IFFALSE 53028
// begin ComAutodestruct ( i ) ;
53017: LD_VAR 0 4
53021: PPUSH
53022: CALL 52865 0 1
// exit ;
53026: GO 53469
// end ; x := GetX ( enemy_unit ) ;
53028: LD_ADDR_VAR 0 7
53032: PUSH
53033: LD_VAR 0 2
53037: PPUSH
53038: CALL_OW 250
53042: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
53043: LD_ADDR_VAR 0 8
53047: PUSH
53048: LD_VAR 0 2
53052: PPUSH
53053: CALL_OW 251
53057: ST_TO_ADDR
// if not x or not y then
53058: LD_VAR 0 7
53062: NOT
53063: PUSH
53064: LD_VAR 0 8
53068: NOT
53069: OR
53070: IFFALSE 53074
// exit ;
53072: GO 53469
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
53074: LD_ADDR_VAR 0 6
53078: PUSH
53079: LD_VAR 0 7
53083: PPUSH
53084: LD_INT 0
53086: PPUSH
53087: LD_INT 4
53089: PPUSH
53090: CALL_OW 272
53094: PUSH
53095: LD_VAR 0 8
53099: PPUSH
53100: LD_INT 0
53102: PPUSH
53103: LD_INT 4
53105: PPUSH
53106: CALL_OW 273
53110: PUSH
53111: EMPTY
53112: LIST
53113: LIST
53114: PUSH
53115: LD_VAR 0 7
53119: PPUSH
53120: LD_INT 1
53122: PPUSH
53123: LD_INT 4
53125: PPUSH
53126: CALL_OW 272
53130: PUSH
53131: LD_VAR 0 8
53135: PPUSH
53136: LD_INT 1
53138: PPUSH
53139: LD_INT 4
53141: PPUSH
53142: CALL_OW 273
53146: PUSH
53147: EMPTY
53148: LIST
53149: LIST
53150: PUSH
53151: LD_VAR 0 7
53155: PPUSH
53156: LD_INT 2
53158: PPUSH
53159: LD_INT 4
53161: PPUSH
53162: CALL_OW 272
53166: PUSH
53167: LD_VAR 0 8
53171: PPUSH
53172: LD_INT 2
53174: PPUSH
53175: LD_INT 4
53177: PPUSH
53178: CALL_OW 273
53182: PUSH
53183: EMPTY
53184: LIST
53185: LIST
53186: PUSH
53187: LD_VAR 0 7
53191: PPUSH
53192: LD_INT 3
53194: PPUSH
53195: LD_INT 4
53197: PPUSH
53198: CALL_OW 272
53202: PUSH
53203: LD_VAR 0 8
53207: PPUSH
53208: LD_INT 3
53210: PPUSH
53211: LD_INT 4
53213: PPUSH
53214: CALL_OW 273
53218: PUSH
53219: EMPTY
53220: LIST
53221: LIST
53222: PUSH
53223: LD_VAR 0 7
53227: PPUSH
53228: LD_INT 4
53230: PPUSH
53231: LD_INT 4
53233: PPUSH
53234: CALL_OW 272
53238: PUSH
53239: LD_VAR 0 8
53243: PPUSH
53244: LD_INT 4
53246: PPUSH
53247: LD_INT 4
53249: PPUSH
53250: CALL_OW 273
53254: PUSH
53255: EMPTY
53256: LIST
53257: LIST
53258: PUSH
53259: LD_VAR 0 7
53263: PPUSH
53264: LD_INT 5
53266: PPUSH
53267: LD_INT 4
53269: PPUSH
53270: CALL_OW 272
53274: PUSH
53275: LD_VAR 0 8
53279: PPUSH
53280: LD_INT 5
53282: PPUSH
53283: LD_INT 4
53285: PPUSH
53286: CALL_OW 273
53290: PUSH
53291: EMPTY
53292: LIST
53293: LIST
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: LIST
53299: LIST
53300: LIST
53301: LIST
53302: ST_TO_ADDR
// for i = tmp downto 1 do
53303: LD_ADDR_VAR 0 4
53307: PUSH
53308: DOUBLE
53309: LD_VAR 0 6
53313: INC
53314: ST_TO_ADDR
53315: LD_INT 1
53317: PUSH
53318: FOR_DOWNTO
53319: IFFALSE 53420
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53321: LD_VAR 0 6
53325: PUSH
53326: LD_VAR 0 4
53330: ARRAY
53331: PUSH
53332: LD_INT 1
53334: ARRAY
53335: PPUSH
53336: LD_VAR 0 6
53340: PUSH
53341: LD_VAR 0 4
53345: ARRAY
53346: PUSH
53347: LD_INT 2
53349: ARRAY
53350: PPUSH
53351: CALL_OW 488
53355: NOT
53356: PUSH
53357: LD_VAR 0 6
53361: PUSH
53362: LD_VAR 0 4
53366: ARRAY
53367: PUSH
53368: LD_INT 1
53370: ARRAY
53371: PPUSH
53372: LD_VAR 0 6
53376: PUSH
53377: LD_VAR 0 4
53381: ARRAY
53382: PUSH
53383: LD_INT 2
53385: ARRAY
53386: PPUSH
53387: CALL_OW 428
53391: PUSH
53392: LD_INT 0
53394: NONEQUAL
53395: OR
53396: IFFALSE 53418
// tmp := Delete ( tmp , i ) ;
53398: LD_ADDR_VAR 0 6
53402: PUSH
53403: LD_VAR 0 6
53407: PPUSH
53408: LD_VAR 0 4
53412: PPUSH
53413: CALL_OW 3
53417: ST_TO_ADDR
53418: GO 53318
53420: POP
53421: POP
// j := GetClosestHex ( unit , tmp ) ;
53422: LD_ADDR_VAR 0 5
53426: PUSH
53427: LD_VAR 0 1
53431: PPUSH
53432: LD_VAR 0 6
53436: PPUSH
53437: CALL 52713 0 2
53441: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53442: LD_VAR 0 1
53446: PPUSH
53447: LD_VAR 0 5
53451: PUSH
53452: LD_INT 1
53454: ARRAY
53455: PPUSH
53456: LD_VAR 0 5
53460: PUSH
53461: LD_INT 2
53463: ARRAY
53464: PPUSH
53465: CALL_OW 111
// end ;
53469: LD_VAR 0 3
53473: RET
// export function PrepareApemanSoldier ( ) ; begin
53474: LD_INT 0
53476: PPUSH
// uc_nation := 0 ;
53477: LD_ADDR_OWVAR 21
53481: PUSH
53482: LD_INT 0
53484: ST_TO_ADDR
// hc_sex := sex_male ;
53485: LD_ADDR_OWVAR 27
53489: PUSH
53490: LD_INT 1
53492: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
53493: LD_ADDR_OWVAR 28
53497: PUSH
53498: LD_INT 15
53500: ST_TO_ADDR
// hc_gallery :=  ;
53501: LD_ADDR_OWVAR 33
53505: PUSH
53506: LD_STRING 
53508: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53509: LD_ADDR_OWVAR 31
53513: PUSH
53514: LD_INT 0
53516: PPUSH
53517: LD_INT 3
53519: PPUSH
53520: CALL_OW 12
53524: PUSH
53525: LD_INT 0
53527: PPUSH
53528: LD_INT 3
53530: PPUSH
53531: CALL_OW 12
53535: PUSH
53536: LD_INT 0
53538: PUSH
53539: LD_INT 0
53541: PUSH
53542: EMPTY
53543: LIST
53544: LIST
53545: LIST
53546: LIST
53547: ST_TO_ADDR
// end ;
53548: LD_VAR 0 1
53552: RET
// export function PrepareApemanEngineer ( ) ; begin
53553: LD_INT 0
53555: PPUSH
// uc_nation := 0 ;
53556: LD_ADDR_OWVAR 21
53560: PUSH
53561: LD_INT 0
53563: ST_TO_ADDR
// hc_sex := sex_male ;
53564: LD_ADDR_OWVAR 27
53568: PUSH
53569: LD_INT 1
53571: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
53572: LD_ADDR_OWVAR 28
53576: PUSH
53577: LD_INT 16
53579: ST_TO_ADDR
// hc_gallery :=  ;
53580: LD_ADDR_OWVAR 33
53584: PUSH
53585: LD_STRING 
53587: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53588: LD_ADDR_OWVAR 31
53592: PUSH
53593: LD_INT 0
53595: PPUSH
53596: LD_INT 3
53598: PPUSH
53599: CALL_OW 12
53603: PUSH
53604: LD_INT 0
53606: PPUSH
53607: LD_INT 3
53609: PPUSH
53610: CALL_OW 12
53614: PUSH
53615: LD_INT 0
53617: PUSH
53618: LD_INT 0
53620: PUSH
53621: EMPTY
53622: LIST
53623: LIST
53624: LIST
53625: LIST
53626: ST_TO_ADDR
// end ;
53627: LD_VAR 0 1
53631: RET
// export function PrepareApeman ( agressivity ) ; begin
53632: LD_INT 0
53634: PPUSH
// uc_side := 0 ;
53635: LD_ADDR_OWVAR 20
53639: PUSH
53640: LD_INT 0
53642: ST_TO_ADDR
// uc_nation := 0 ;
53643: LD_ADDR_OWVAR 21
53647: PUSH
53648: LD_INT 0
53650: ST_TO_ADDR
// hc_sex := sex_male ;
53651: LD_ADDR_OWVAR 27
53655: PUSH
53656: LD_INT 1
53658: ST_TO_ADDR
// hc_class := class_apeman ;
53659: LD_ADDR_OWVAR 28
53663: PUSH
53664: LD_INT 12
53666: ST_TO_ADDR
// hc_gallery :=  ;
53667: LD_ADDR_OWVAR 33
53671: PUSH
53672: LD_STRING 
53674: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53675: LD_ADDR_OWVAR 35
53679: PUSH
53680: LD_VAR 0 1
53684: NEG
53685: PPUSH
53686: LD_VAR 0 1
53690: PPUSH
53691: CALL_OW 12
53695: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53696: LD_ADDR_OWVAR 31
53700: PUSH
53701: LD_INT 0
53703: PPUSH
53704: LD_INT 3
53706: PPUSH
53707: CALL_OW 12
53711: PUSH
53712: LD_INT 0
53714: PPUSH
53715: LD_INT 3
53717: PPUSH
53718: CALL_OW 12
53722: PUSH
53723: LD_INT 0
53725: PUSH
53726: LD_INT 0
53728: PUSH
53729: EMPTY
53730: LIST
53731: LIST
53732: LIST
53733: LIST
53734: ST_TO_ADDR
// end ;
53735: LD_VAR 0 2
53739: RET
// export function PrepareTiger ( agressivity ) ; begin
53740: LD_INT 0
53742: PPUSH
// uc_side := 0 ;
53743: LD_ADDR_OWVAR 20
53747: PUSH
53748: LD_INT 0
53750: ST_TO_ADDR
// uc_nation := 0 ;
53751: LD_ADDR_OWVAR 21
53755: PUSH
53756: LD_INT 0
53758: ST_TO_ADDR
// hc_class := class_tiger ;
53759: LD_ADDR_OWVAR 28
53763: PUSH
53764: LD_INT 14
53766: ST_TO_ADDR
// hc_gallery :=  ;
53767: LD_ADDR_OWVAR 33
53771: PUSH
53772: LD_STRING 
53774: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53775: LD_ADDR_OWVAR 35
53779: PUSH
53780: LD_VAR 0 1
53784: NEG
53785: PPUSH
53786: LD_VAR 0 1
53790: PPUSH
53791: CALL_OW 12
53795: ST_TO_ADDR
// end ;
53796: LD_VAR 0 2
53800: RET
// export function PrepareEnchidna ( ) ; begin
53801: LD_INT 0
53803: PPUSH
// uc_side := 0 ;
53804: LD_ADDR_OWVAR 20
53808: PUSH
53809: LD_INT 0
53811: ST_TO_ADDR
// uc_nation := 0 ;
53812: LD_ADDR_OWVAR 21
53816: PUSH
53817: LD_INT 0
53819: ST_TO_ADDR
// hc_class := class_baggie ;
53820: LD_ADDR_OWVAR 28
53824: PUSH
53825: LD_INT 13
53827: ST_TO_ADDR
// hc_gallery :=  ;
53828: LD_ADDR_OWVAR 33
53832: PUSH
53833: LD_STRING 
53835: ST_TO_ADDR
// end ;
53836: LD_VAR 0 1
53840: RET
// export function PrepareFrog ( ) ; begin
53841: LD_INT 0
53843: PPUSH
// uc_side := 0 ;
53844: LD_ADDR_OWVAR 20
53848: PUSH
53849: LD_INT 0
53851: ST_TO_ADDR
// uc_nation := 0 ;
53852: LD_ADDR_OWVAR 21
53856: PUSH
53857: LD_INT 0
53859: ST_TO_ADDR
// hc_class := class_frog ;
53860: LD_ADDR_OWVAR 28
53864: PUSH
53865: LD_INT 19
53867: ST_TO_ADDR
// hc_gallery :=  ;
53868: LD_ADDR_OWVAR 33
53872: PUSH
53873: LD_STRING 
53875: ST_TO_ADDR
// end ;
53876: LD_VAR 0 1
53880: RET
// export function PrepareFish ( ) ; begin
53881: LD_INT 0
53883: PPUSH
// uc_side := 0 ;
53884: LD_ADDR_OWVAR 20
53888: PUSH
53889: LD_INT 0
53891: ST_TO_ADDR
// uc_nation := 0 ;
53892: LD_ADDR_OWVAR 21
53896: PUSH
53897: LD_INT 0
53899: ST_TO_ADDR
// hc_class := class_fish ;
53900: LD_ADDR_OWVAR 28
53904: PUSH
53905: LD_INT 20
53907: ST_TO_ADDR
// hc_gallery :=  ;
53908: LD_ADDR_OWVAR 33
53912: PUSH
53913: LD_STRING 
53915: ST_TO_ADDR
// end ;
53916: LD_VAR 0 1
53920: RET
// export function PrepareBird ( ) ; begin
53921: LD_INT 0
53923: PPUSH
// uc_side := 0 ;
53924: LD_ADDR_OWVAR 20
53928: PUSH
53929: LD_INT 0
53931: ST_TO_ADDR
// uc_nation := 0 ;
53932: LD_ADDR_OWVAR 21
53936: PUSH
53937: LD_INT 0
53939: ST_TO_ADDR
// hc_class := class_phororhacos ;
53940: LD_ADDR_OWVAR 28
53944: PUSH
53945: LD_INT 18
53947: ST_TO_ADDR
// hc_gallery :=  ;
53948: LD_ADDR_OWVAR 33
53952: PUSH
53953: LD_STRING 
53955: ST_TO_ADDR
// end ;
53956: LD_VAR 0 1
53960: RET
// export function PrepareHorse ( ) ; begin
53961: LD_INT 0
53963: PPUSH
// uc_side := 0 ;
53964: LD_ADDR_OWVAR 20
53968: PUSH
53969: LD_INT 0
53971: ST_TO_ADDR
// uc_nation := 0 ;
53972: LD_ADDR_OWVAR 21
53976: PUSH
53977: LD_INT 0
53979: ST_TO_ADDR
// hc_class := class_horse ;
53980: LD_ADDR_OWVAR 28
53984: PUSH
53985: LD_INT 21
53987: ST_TO_ADDR
// hc_gallery :=  ;
53988: LD_ADDR_OWVAR 33
53992: PUSH
53993: LD_STRING 
53995: ST_TO_ADDR
// end ;
53996: LD_VAR 0 1
54000: RET
// export function PrepareMastodont ( ) ; begin
54001: LD_INT 0
54003: PPUSH
// uc_side := 0 ;
54004: LD_ADDR_OWVAR 20
54008: PUSH
54009: LD_INT 0
54011: ST_TO_ADDR
// uc_nation := 0 ;
54012: LD_ADDR_OWVAR 21
54016: PUSH
54017: LD_INT 0
54019: ST_TO_ADDR
// vc_chassis := class_mastodont ;
54020: LD_ADDR_OWVAR 37
54024: PUSH
54025: LD_INT 31
54027: ST_TO_ADDR
// vc_control := control_rider ;
54028: LD_ADDR_OWVAR 38
54032: PUSH
54033: LD_INT 4
54035: ST_TO_ADDR
// end ;
54036: LD_VAR 0 1
54040: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
54041: LD_INT 0
54043: PPUSH
54044: PPUSH
54045: PPUSH
// uc_side = 0 ;
54046: LD_ADDR_OWVAR 20
54050: PUSH
54051: LD_INT 0
54053: ST_TO_ADDR
// uc_nation = 0 ;
54054: LD_ADDR_OWVAR 21
54058: PUSH
54059: LD_INT 0
54061: ST_TO_ADDR
// InitHc_All ( ) ;
54062: CALL_OW 584
// InitVc ;
54066: CALL_OW 20
// if mastodonts then
54070: LD_VAR 0 6
54074: IFFALSE 54141
// for i = 1 to mastodonts do
54076: LD_ADDR_VAR 0 11
54080: PUSH
54081: DOUBLE
54082: LD_INT 1
54084: DEC
54085: ST_TO_ADDR
54086: LD_VAR 0 6
54090: PUSH
54091: FOR_TO
54092: IFFALSE 54139
// begin vc_chassis := 31 ;
54094: LD_ADDR_OWVAR 37
54098: PUSH
54099: LD_INT 31
54101: ST_TO_ADDR
// vc_control := control_rider ;
54102: LD_ADDR_OWVAR 38
54106: PUSH
54107: LD_INT 4
54109: ST_TO_ADDR
// animal := CreateVehicle ;
54110: LD_ADDR_VAR 0 12
54114: PUSH
54115: CALL_OW 45
54119: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54120: LD_VAR 0 12
54124: PPUSH
54125: LD_VAR 0 8
54129: PPUSH
54130: LD_INT 0
54132: PPUSH
54133: CALL 56269 0 3
// end ;
54137: GO 54091
54139: POP
54140: POP
// if horses then
54141: LD_VAR 0 5
54145: IFFALSE 54212
// for i = 1 to horses do
54147: LD_ADDR_VAR 0 11
54151: PUSH
54152: DOUBLE
54153: LD_INT 1
54155: DEC
54156: ST_TO_ADDR
54157: LD_VAR 0 5
54161: PUSH
54162: FOR_TO
54163: IFFALSE 54210
// begin hc_class := 21 ;
54165: LD_ADDR_OWVAR 28
54169: PUSH
54170: LD_INT 21
54172: ST_TO_ADDR
// hc_gallery :=  ;
54173: LD_ADDR_OWVAR 33
54177: PUSH
54178: LD_STRING 
54180: ST_TO_ADDR
// animal := CreateHuman ;
54181: LD_ADDR_VAR 0 12
54185: PUSH
54186: CALL_OW 44
54190: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54191: LD_VAR 0 12
54195: PPUSH
54196: LD_VAR 0 8
54200: PPUSH
54201: LD_INT 0
54203: PPUSH
54204: CALL 56269 0 3
// end ;
54208: GO 54162
54210: POP
54211: POP
// if birds then
54212: LD_VAR 0 1
54216: IFFALSE 54283
// for i = 1 to birds do
54218: LD_ADDR_VAR 0 11
54222: PUSH
54223: DOUBLE
54224: LD_INT 1
54226: DEC
54227: ST_TO_ADDR
54228: LD_VAR 0 1
54232: PUSH
54233: FOR_TO
54234: IFFALSE 54281
// begin hc_class = 18 ;
54236: LD_ADDR_OWVAR 28
54240: PUSH
54241: LD_INT 18
54243: ST_TO_ADDR
// hc_gallery =  ;
54244: LD_ADDR_OWVAR 33
54248: PUSH
54249: LD_STRING 
54251: ST_TO_ADDR
// animal := CreateHuman ;
54252: LD_ADDR_VAR 0 12
54256: PUSH
54257: CALL_OW 44
54261: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54262: LD_VAR 0 12
54266: PPUSH
54267: LD_VAR 0 8
54271: PPUSH
54272: LD_INT 0
54274: PPUSH
54275: CALL 56269 0 3
// end ;
54279: GO 54233
54281: POP
54282: POP
// if tigers then
54283: LD_VAR 0 2
54287: IFFALSE 54371
// for i = 1 to tigers do
54289: LD_ADDR_VAR 0 11
54293: PUSH
54294: DOUBLE
54295: LD_INT 1
54297: DEC
54298: ST_TO_ADDR
54299: LD_VAR 0 2
54303: PUSH
54304: FOR_TO
54305: IFFALSE 54369
// begin hc_class = class_tiger ;
54307: LD_ADDR_OWVAR 28
54311: PUSH
54312: LD_INT 14
54314: ST_TO_ADDR
// hc_gallery =  ;
54315: LD_ADDR_OWVAR 33
54319: PUSH
54320: LD_STRING 
54322: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
54323: LD_ADDR_OWVAR 35
54327: PUSH
54328: LD_INT 7
54330: NEG
54331: PPUSH
54332: LD_INT 7
54334: PPUSH
54335: CALL_OW 12
54339: ST_TO_ADDR
// animal := CreateHuman ;
54340: LD_ADDR_VAR 0 12
54344: PUSH
54345: CALL_OW 44
54349: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54350: LD_VAR 0 12
54354: PPUSH
54355: LD_VAR 0 8
54359: PPUSH
54360: LD_INT 0
54362: PPUSH
54363: CALL 56269 0 3
// end ;
54367: GO 54304
54369: POP
54370: POP
// if apemans then
54371: LD_VAR 0 3
54375: IFFALSE 54498
// for i = 1 to apemans do
54377: LD_ADDR_VAR 0 11
54381: PUSH
54382: DOUBLE
54383: LD_INT 1
54385: DEC
54386: ST_TO_ADDR
54387: LD_VAR 0 3
54391: PUSH
54392: FOR_TO
54393: IFFALSE 54496
// begin hc_class = class_apeman ;
54395: LD_ADDR_OWVAR 28
54399: PUSH
54400: LD_INT 12
54402: ST_TO_ADDR
// hc_gallery =  ;
54403: LD_ADDR_OWVAR 33
54407: PUSH
54408: LD_STRING 
54410: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
54411: LD_ADDR_OWVAR 35
54415: PUSH
54416: LD_INT 2
54418: NEG
54419: PPUSH
54420: LD_INT 2
54422: PPUSH
54423: CALL_OW 12
54427: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
54428: LD_ADDR_OWVAR 31
54432: PUSH
54433: LD_INT 1
54435: PPUSH
54436: LD_INT 3
54438: PPUSH
54439: CALL_OW 12
54443: PUSH
54444: LD_INT 1
54446: PPUSH
54447: LD_INT 3
54449: PPUSH
54450: CALL_OW 12
54454: PUSH
54455: LD_INT 0
54457: PUSH
54458: LD_INT 0
54460: PUSH
54461: EMPTY
54462: LIST
54463: LIST
54464: LIST
54465: LIST
54466: ST_TO_ADDR
// animal := CreateHuman ;
54467: LD_ADDR_VAR 0 12
54471: PUSH
54472: CALL_OW 44
54476: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54477: LD_VAR 0 12
54481: PPUSH
54482: LD_VAR 0 8
54486: PPUSH
54487: LD_INT 0
54489: PPUSH
54490: CALL 56269 0 3
// end ;
54494: GO 54392
54496: POP
54497: POP
// if enchidnas then
54498: LD_VAR 0 4
54502: IFFALSE 54569
// for i = 1 to enchidnas do
54504: LD_ADDR_VAR 0 11
54508: PUSH
54509: DOUBLE
54510: LD_INT 1
54512: DEC
54513: ST_TO_ADDR
54514: LD_VAR 0 4
54518: PUSH
54519: FOR_TO
54520: IFFALSE 54567
// begin hc_class = 13 ;
54522: LD_ADDR_OWVAR 28
54526: PUSH
54527: LD_INT 13
54529: ST_TO_ADDR
// hc_gallery =  ;
54530: LD_ADDR_OWVAR 33
54534: PUSH
54535: LD_STRING 
54537: ST_TO_ADDR
// animal := CreateHuman ;
54538: LD_ADDR_VAR 0 12
54542: PUSH
54543: CALL_OW 44
54547: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54548: LD_VAR 0 12
54552: PPUSH
54553: LD_VAR 0 8
54557: PPUSH
54558: LD_INT 0
54560: PPUSH
54561: CALL 56269 0 3
// end ;
54565: GO 54519
54567: POP
54568: POP
// if fishes then
54569: LD_VAR 0 7
54573: IFFALSE 54640
// for i = 1 to fishes do
54575: LD_ADDR_VAR 0 11
54579: PUSH
54580: DOUBLE
54581: LD_INT 1
54583: DEC
54584: ST_TO_ADDR
54585: LD_VAR 0 7
54589: PUSH
54590: FOR_TO
54591: IFFALSE 54638
// begin hc_class = 20 ;
54593: LD_ADDR_OWVAR 28
54597: PUSH
54598: LD_INT 20
54600: ST_TO_ADDR
// hc_gallery =  ;
54601: LD_ADDR_OWVAR 33
54605: PUSH
54606: LD_STRING 
54608: ST_TO_ADDR
// animal := CreateHuman ;
54609: LD_ADDR_VAR 0 12
54613: PUSH
54614: CALL_OW 44
54618: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
54619: LD_VAR 0 12
54623: PPUSH
54624: LD_VAR 0 9
54628: PPUSH
54629: LD_INT 0
54631: PPUSH
54632: CALL 56269 0 3
// end ;
54636: GO 54590
54638: POP
54639: POP
// end ;
54640: LD_VAR 0 10
54644: RET
// export function WantHeal ( sci , unit ) ; begin
54645: LD_INT 0
54647: PPUSH
// if GetTaskList ( sci ) > 0 then
54648: LD_VAR 0 1
54652: PPUSH
54653: CALL_OW 437
54657: PUSH
54658: LD_INT 0
54660: GREATER
54661: IFFALSE 54731
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54663: LD_VAR 0 1
54667: PPUSH
54668: CALL_OW 437
54672: PUSH
54673: LD_INT 1
54675: ARRAY
54676: PUSH
54677: LD_INT 1
54679: ARRAY
54680: PUSH
54681: LD_STRING l
54683: EQUAL
54684: PUSH
54685: LD_VAR 0 1
54689: PPUSH
54690: CALL_OW 437
54694: PUSH
54695: LD_INT 1
54697: ARRAY
54698: PUSH
54699: LD_INT 4
54701: ARRAY
54702: PUSH
54703: LD_VAR 0 2
54707: EQUAL
54708: AND
54709: IFFALSE 54721
// result := true else
54711: LD_ADDR_VAR 0 3
54715: PUSH
54716: LD_INT 1
54718: ST_TO_ADDR
54719: GO 54729
// result := false ;
54721: LD_ADDR_VAR 0 3
54725: PUSH
54726: LD_INT 0
54728: ST_TO_ADDR
// end else
54729: GO 54739
// result := false ;
54731: LD_ADDR_VAR 0 3
54735: PUSH
54736: LD_INT 0
54738: ST_TO_ADDR
// end ;
54739: LD_VAR 0 3
54743: RET
// export function HealTarget ( sci ) ; begin
54744: LD_INT 0
54746: PPUSH
// if not sci then
54747: LD_VAR 0 1
54751: NOT
54752: IFFALSE 54756
// exit ;
54754: GO 54821
// result := 0 ;
54756: LD_ADDR_VAR 0 2
54760: PUSH
54761: LD_INT 0
54763: ST_TO_ADDR
// if GetTaskList ( sci ) then
54764: LD_VAR 0 1
54768: PPUSH
54769: CALL_OW 437
54773: IFFALSE 54821
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54775: LD_VAR 0 1
54779: PPUSH
54780: CALL_OW 437
54784: PUSH
54785: LD_INT 1
54787: ARRAY
54788: PUSH
54789: LD_INT 1
54791: ARRAY
54792: PUSH
54793: LD_STRING l
54795: EQUAL
54796: IFFALSE 54821
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54798: LD_ADDR_VAR 0 2
54802: PUSH
54803: LD_VAR 0 1
54807: PPUSH
54808: CALL_OW 437
54812: PUSH
54813: LD_INT 1
54815: ARRAY
54816: PUSH
54817: LD_INT 4
54819: ARRAY
54820: ST_TO_ADDR
// end ;
54821: LD_VAR 0 2
54825: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54826: LD_INT 0
54828: PPUSH
54829: PPUSH
54830: PPUSH
54831: PPUSH
// if not base_units then
54832: LD_VAR 0 1
54836: NOT
54837: IFFALSE 54841
// exit ;
54839: GO 54928
// result := false ;
54841: LD_ADDR_VAR 0 2
54845: PUSH
54846: LD_INT 0
54848: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54849: LD_ADDR_VAR 0 5
54853: PUSH
54854: LD_VAR 0 1
54858: PPUSH
54859: LD_INT 21
54861: PUSH
54862: LD_INT 3
54864: PUSH
54865: EMPTY
54866: LIST
54867: LIST
54868: PPUSH
54869: CALL_OW 72
54873: ST_TO_ADDR
// if not tmp then
54874: LD_VAR 0 5
54878: NOT
54879: IFFALSE 54883
// exit ;
54881: GO 54928
// for i in tmp do
54883: LD_ADDR_VAR 0 3
54887: PUSH
54888: LD_VAR 0 5
54892: PUSH
54893: FOR_IN
54894: IFFALSE 54926
// begin result := EnemyInRange ( i , 22 ) ;
54896: LD_ADDR_VAR 0 2
54900: PUSH
54901: LD_VAR 0 3
54905: PPUSH
54906: LD_INT 22
54908: PPUSH
54909: CALL 52515 0 2
54913: ST_TO_ADDR
// if result then
54914: LD_VAR 0 2
54918: IFFALSE 54924
// exit ;
54920: POP
54921: POP
54922: GO 54928
// end ;
54924: GO 54893
54926: POP
54927: POP
// end ;
54928: LD_VAR 0 2
54932: RET
// export function FilterByTag ( units , tag ) ; begin
54933: LD_INT 0
54935: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54936: LD_ADDR_VAR 0 3
54940: PUSH
54941: LD_VAR 0 1
54945: PPUSH
54946: LD_INT 120
54948: PUSH
54949: LD_VAR 0 2
54953: PUSH
54954: EMPTY
54955: LIST
54956: LIST
54957: PPUSH
54958: CALL_OW 72
54962: ST_TO_ADDR
// end ;
54963: LD_VAR 0 3
54967: RET
// export function IsDriver ( un ) ; begin
54968: LD_INT 0
54970: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54971: LD_ADDR_VAR 0 2
54975: PUSH
54976: LD_VAR 0 1
54980: PUSH
54981: LD_INT 55
54983: PUSH
54984: EMPTY
54985: LIST
54986: PPUSH
54987: CALL_OW 69
54991: IN
54992: ST_TO_ADDR
// end ;
54993: LD_VAR 0 2
54997: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54998: LD_INT 0
55000: PPUSH
55001: PPUSH
// list := [ ] ;
55002: LD_ADDR_VAR 0 5
55006: PUSH
55007: EMPTY
55008: ST_TO_ADDR
// case d of 0 :
55009: LD_VAR 0 3
55013: PUSH
55014: LD_INT 0
55016: DOUBLE
55017: EQUAL
55018: IFTRUE 55022
55020: GO 55155
55022: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
55023: LD_ADDR_VAR 0 5
55027: PUSH
55028: LD_VAR 0 1
55032: PUSH
55033: LD_INT 4
55035: MINUS
55036: PUSH
55037: LD_VAR 0 2
55041: PUSH
55042: LD_INT 4
55044: MINUS
55045: PUSH
55046: LD_INT 2
55048: PUSH
55049: EMPTY
55050: LIST
55051: LIST
55052: LIST
55053: PUSH
55054: LD_VAR 0 1
55058: PUSH
55059: LD_INT 3
55061: MINUS
55062: PUSH
55063: LD_VAR 0 2
55067: PUSH
55068: LD_INT 1
55070: PUSH
55071: EMPTY
55072: LIST
55073: LIST
55074: LIST
55075: PUSH
55076: LD_VAR 0 1
55080: PUSH
55081: LD_INT 4
55083: PLUS
55084: PUSH
55085: LD_VAR 0 2
55089: PUSH
55090: LD_INT 4
55092: PUSH
55093: EMPTY
55094: LIST
55095: LIST
55096: LIST
55097: PUSH
55098: LD_VAR 0 1
55102: PUSH
55103: LD_INT 3
55105: PLUS
55106: PUSH
55107: LD_VAR 0 2
55111: PUSH
55112: LD_INT 3
55114: PLUS
55115: PUSH
55116: LD_INT 5
55118: PUSH
55119: EMPTY
55120: LIST
55121: LIST
55122: LIST
55123: PUSH
55124: LD_VAR 0 1
55128: PUSH
55129: LD_VAR 0 2
55133: PUSH
55134: LD_INT 4
55136: PLUS
55137: PUSH
55138: LD_INT 0
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: LIST
55145: PUSH
55146: EMPTY
55147: LIST
55148: LIST
55149: LIST
55150: LIST
55151: LIST
55152: ST_TO_ADDR
// end ; 1 :
55153: GO 55853
55155: LD_INT 1
55157: DOUBLE
55158: EQUAL
55159: IFTRUE 55163
55161: GO 55296
55163: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55164: LD_ADDR_VAR 0 5
55168: PUSH
55169: LD_VAR 0 1
55173: PUSH
55174: LD_VAR 0 2
55178: PUSH
55179: LD_INT 4
55181: MINUS
55182: PUSH
55183: LD_INT 3
55185: PUSH
55186: EMPTY
55187: LIST
55188: LIST
55189: LIST
55190: PUSH
55191: LD_VAR 0 1
55195: PUSH
55196: LD_INT 3
55198: MINUS
55199: PUSH
55200: LD_VAR 0 2
55204: PUSH
55205: LD_INT 3
55207: MINUS
55208: PUSH
55209: LD_INT 2
55211: PUSH
55212: EMPTY
55213: LIST
55214: LIST
55215: LIST
55216: PUSH
55217: LD_VAR 0 1
55221: PUSH
55222: LD_INT 4
55224: MINUS
55225: PUSH
55226: LD_VAR 0 2
55230: PUSH
55231: LD_INT 1
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: LIST
55238: PUSH
55239: LD_VAR 0 1
55243: PUSH
55244: LD_VAR 0 2
55248: PUSH
55249: LD_INT 3
55251: PLUS
55252: PUSH
55253: LD_INT 0
55255: PUSH
55256: EMPTY
55257: LIST
55258: LIST
55259: LIST
55260: PUSH
55261: LD_VAR 0 1
55265: PUSH
55266: LD_INT 4
55268: PLUS
55269: PUSH
55270: LD_VAR 0 2
55274: PUSH
55275: LD_INT 4
55277: PLUS
55278: PUSH
55279: LD_INT 5
55281: PUSH
55282: EMPTY
55283: LIST
55284: LIST
55285: LIST
55286: PUSH
55287: EMPTY
55288: LIST
55289: LIST
55290: LIST
55291: LIST
55292: LIST
55293: ST_TO_ADDR
// end ; 2 :
55294: GO 55853
55296: LD_INT 2
55298: DOUBLE
55299: EQUAL
55300: IFTRUE 55304
55302: GO 55433
55304: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55305: LD_ADDR_VAR 0 5
55309: PUSH
55310: LD_VAR 0 1
55314: PUSH
55315: LD_VAR 0 2
55319: PUSH
55320: LD_INT 3
55322: MINUS
55323: PUSH
55324: LD_INT 3
55326: PUSH
55327: EMPTY
55328: LIST
55329: LIST
55330: LIST
55331: PUSH
55332: LD_VAR 0 1
55336: PUSH
55337: LD_INT 4
55339: PLUS
55340: PUSH
55341: LD_VAR 0 2
55345: PUSH
55346: LD_INT 4
55348: PUSH
55349: EMPTY
55350: LIST
55351: LIST
55352: LIST
55353: PUSH
55354: LD_VAR 0 1
55358: PUSH
55359: LD_VAR 0 2
55363: PUSH
55364: LD_INT 4
55366: PLUS
55367: PUSH
55368: LD_INT 0
55370: PUSH
55371: EMPTY
55372: LIST
55373: LIST
55374: LIST
55375: PUSH
55376: LD_VAR 0 1
55380: PUSH
55381: LD_INT 3
55383: MINUS
55384: PUSH
55385: LD_VAR 0 2
55389: PUSH
55390: LD_INT 1
55392: PUSH
55393: EMPTY
55394: LIST
55395: LIST
55396: LIST
55397: PUSH
55398: LD_VAR 0 1
55402: PUSH
55403: LD_INT 4
55405: MINUS
55406: PUSH
55407: LD_VAR 0 2
55411: PUSH
55412: LD_INT 4
55414: MINUS
55415: PUSH
55416: LD_INT 2
55418: PUSH
55419: EMPTY
55420: LIST
55421: LIST
55422: LIST
55423: PUSH
55424: EMPTY
55425: LIST
55426: LIST
55427: LIST
55428: LIST
55429: LIST
55430: ST_TO_ADDR
// end ; 3 :
55431: GO 55853
55433: LD_INT 3
55435: DOUBLE
55436: EQUAL
55437: IFTRUE 55441
55439: GO 55574
55441: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55442: LD_ADDR_VAR 0 5
55446: PUSH
55447: LD_VAR 0 1
55451: PUSH
55452: LD_INT 3
55454: PLUS
55455: PUSH
55456: LD_VAR 0 2
55460: PUSH
55461: LD_INT 4
55463: PUSH
55464: EMPTY
55465: LIST
55466: LIST
55467: LIST
55468: PUSH
55469: LD_VAR 0 1
55473: PUSH
55474: LD_INT 4
55476: PLUS
55477: PUSH
55478: LD_VAR 0 2
55482: PUSH
55483: LD_INT 4
55485: PLUS
55486: PUSH
55487: LD_INT 5
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: LIST
55494: PUSH
55495: LD_VAR 0 1
55499: PUSH
55500: LD_INT 4
55502: MINUS
55503: PUSH
55504: LD_VAR 0 2
55508: PUSH
55509: LD_INT 1
55511: PUSH
55512: EMPTY
55513: LIST
55514: LIST
55515: LIST
55516: PUSH
55517: LD_VAR 0 1
55521: PUSH
55522: LD_VAR 0 2
55526: PUSH
55527: LD_INT 4
55529: MINUS
55530: PUSH
55531: LD_INT 3
55533: PUSH
55534: EMPTY
55535: LIST
55536: LIST
55537: LIST
55538: PUSH
55539: LD_VAR 0 1
55543: PUSH
55544: LD_INT 3
55546: MINUS
55547: PUSH
55548: LD_VAR 0 2
55552: PUSH
55553: LD_INT 3
55555: MINUS
55556: PUSH
55557: LD_INT 2
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: LIST
55564: PUSH
55565: EMPTY
55566: LIST
55567: LIST
55568: LIST
55569: LIST
55570: LIST
55571: ST_TO_ADDR
// end ; 4 :
55572: GO 55853
55574: LD_INT 4
55576: DOUBLE
55577: EQUAL
55578: IFTRUE 55582
55580: GO 55715
55582: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55583: LD_ADDR_VAR 0 5
55587: PUSH
55588: LD_VAR 0 1
55592: PUSH
55593: LD_VAR 0 2
55597: PUSH
55598: LD_INT 4
55600: PLUS
55601: PUSH
55602: LD_INT 0
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: LIST
55609: PUSH
55610: LD_VAR 0 1
55614: PUSH
55615: LD_INT 3
55617: PLUS
55618: PUSH
55619: LD_VAR 0 2
55623: PUSH
55624: LD_INT 3
55626: PLUS
55627: PUSH
55628: LD_INT 5
55630: PUSH
55631: EMPTY
55632: LIST
55633: LIST
55634: LIST
55635: PUSH
55636: LD_VAR 0 1
55640: PUSH
55641: LD_INT 4
55643: PLUS
55644: PUSH
55645: LD_VAR 0 2
55649: PUSH
55650: LD_INT 4
55652: PUSH
55653: EMPTY
55654: LIST
55655: LIST
55656: LIST
55657: PUSH
55658: LD_VAR 0 1
55662: PUSH
55663: LD_VAR 0 2
55667: PUSH
55668: LD_INT 3
55670: MINUS
55671: PUSH
55672: LD_INT 3
55674: PUSH
55675: EMPTY
55676: LIST
55677: LIST
55678: LIST
55679: PUSH
55680: LD_VAR 0 1
55684: PUSH
55685: LD_INT 4
55687: MINUS
55688: PUSH
55689: LD_VAR 0 2
55693: PUSH
55694: LD_INT 4
55696: MINUS
55697: PUSH
55698: LD_INT 2
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: LIST
55705: PUSH
55706: EMPTY
55707: LIST
55708: LIST
55709: LIST
55710: LIST
55711: LIST
55712: ST_TO_ADDR
// end ; 5 :
55713: GO 55853
55715: LD_INT 5
55717: DOUBLE
55718: EQUAL
55719: IFTRUE 55723
55721: GO 55852
55723: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55724: LD_ADDR_VAR 0 5
55728: PUSH
55729: LD_VAR 0 1
55733: PUSH
55734: LD_INT 4
55736: MINUS
55737: PUSH
55738: LD_VAR 0 2
55742: PUSH
55743: LD_INT 1
55745: PUSH
55746: EMPTY
55747: LIST
55748: LIST
55749: LIST
55750: PUSH
55751: LD_VAR 0 1
55755: PUSH
55756: LD_VAR 0 2
55760: PUSH
55761: LD_INT 4
55763: MINUS
55764: PUSH
55765: LD_INT 3
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: LIST
55772: PUSH
55773: LD_VAR 0 1
55777: PUSH
55778: LD_INT 4
55780: PLUS
55781: PUSH
55782: LD_VAR 0 2
55786: PUSH
55787: LD_INT 4
55789: PLUS
55790: PUSH
55791: LD_INT 5
55793: PUSH
55794: EMPTY
55795: LIST
55796: LIST
55797: LIST
55798: PUSH
55799: LD_VAR 0 1
55803: PUSH
55804: LD_INT 3
55806: PLUS
55807: PUSH
55808: LD_VAR 0 2
55812: PUSH
55813: LD_INT 4
55815: PUSH
55816: EMPTY
55817: LIST
55818: LIST
55819: LIST
55820: PUSH
55821: LD_VAR 0 1
55825: PUSH
55826: LD_VAR 0 2
55830: PUSH
55831: LD_INT 3
55833: PLUS
55834: PUSH
55835: LD_INT 0
55837: PUSH
55838: EMPTY
55839: LIST
55840: LIST
55841: LIST
55842: PUSH
55843: EMPTY
55844: LIST
55845: LIST
55846: LIST
55847: LIST
55848: LIST
55849: ST_TO_ADDR
// end ; end ;
55850: GO 55853
55852: POP
// result := list ;
55853: LD_ADDR_VAR 0 4
55857: PUSH
55858: LD_VAR 0 5
55862: ST_TO_ADDR
// end ;
55863: LD_VAR 0 4
55867: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55868: LD_INT 0
55870: PPUSH
55871: PPUSH
55872: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55873: LD_VAR 0 1
55877: NOT
55878: PUSH
55879: LD_VAR 0 2
55883: PUSH
55884: LD_INT 1
55886: PUSH
55887: LD_INT 2
55889: PUSH
55890: LD_INT 3
55892: PUSH
55893: LD_INT 4
55895: PUSH
55896: EMPTY
55897: LIST
55898: LIST
55899: LIST
55900: LIST
55901: IN
55902: NOT
55903: OR
55904: IFFALSE 55908
// exit ;
55906: GO 55991
// tmp := [ ] ;
55908: LD_ADDR_VAR 0 5
55912: PUSH
55913: EMPTY
55914: ST_TO_ADDR
// for i in units do
55915: LD_ADDR_VAR 0 4
55919: PUSH
55920: LD_VAR 0 1
55924: PUSH
55925: FOR_IN
55926: IFFALSE 55960
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
55928: LD_ADDR_VAR 0 5
55932: PUSH
55933: LD_VAR 0 5
55937: PPUSH
55938: LD_VAR 0 4
55942: PPUSH
55943: LD_VAR 0 2
55947: PPUSH
55948: CALL_OW 259
55952: PPUSH
55953: CALL 57352 0 2
55957: ST_TO_ADDR
55958: GO 55925
55960: POP
55961: POP
// if not tmp then
55962: LD_VAR 0 5
55966: NOT
55967: IFFALSE 55971
// exit ;
55969: GO 55991
// result := SortListByListDesc ( units , tmp ) ;
55971: LD_ADDR_VAR 0 3
55975: PUSH
55976: LD_VAR 0 1
55980: PPUSH
55981: LD_VAR 0 5
55985: PPUSH
55986: CALL_OW 77
55990: ST_TO_ADDR
// end ;
55991: LD_VAR 0 3
55995: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55996: LD_INT 0
55998: PPUSH
55999: PPUSH
56000: PPUSH
// result := false ;
56001: LD_ADDR_VAR 0 3
56005: PUSH
56006: LD_INT 0
56008: ST_TO_ADDR
// if not building then
56009: LD_VAR 0 2
56013: NOT
56014: IFFALSE 56018
// exit ;
56016: GO 56156
// x := GetX ( building ) ;
56018: LD_ADDR_VAR 0 4
56022: PUSH
56023: LD_VAR 0 2
56027: PPUSH
56028: CALL_OW 250
56032: ST_TO_ADDR
// y := GetY ( building ) ;
56033: LD_ADDR_VAR 0 5
56037: PUSH
56038: LD_VAR 0 2
56042: PPUSH
56043: CALL_OW 251
56047: ST_TO_ADDR
// if not x or not y then
56048: LD_VAR 0 4
56052: NOT
56053: PUSH
56054: LD_VAR 0 5
56058: NOT
56059: OR
56060: IFFALSE 56064
// exit ;
56062: GO 56156
// if GetTaskList ( unit ) then
56064: LD_VAR 0 1
56068: PPUSH
56069: CALL_OW 437
56073: IFFALSE 56156
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56075: LD_STRING e
56077: PUSH
56078: LD_VAR 0 1
56082: PPUSH
56083: CALL_OW 437
56087: PUSH
56088: LD_INT 1
56090: ARRAY
56091: PUSH
56092: LD_INT 1
56094: ARRAY
56095: EQUAL
56096: PUSH
56097: LD_VAR 0 4
56101: PUSH
56102: LD_VAR 0 1
56106: PPUSH
56107: CALL_OW 437
56111: PUSH
56112: LD_INT 1
56114: ARRAY
56115: PUSH
56116: LD_INT 2
56118: ARRAY
56119: EQUAL
56120: AND
56121: PUSH
56122: LD_VAR 0 5
56126: PUSH
56127: LD_VAR 0 1
56131: PPUSH
56132: CALL_OW 437
56136: PUSH
56137: LD_INT 1
56139: ARRAY
56140: PUSH
56141: LD_INT 3
56143: ARRAY
56144: EQUAL
56145: AND
56146: IFFALSE 56156
// result := true end ;
56148: LD_ADDR_VAR 0 3
56152: PUSH
56153: LD_INT 1
56155: ST_TO_ADDR
// end ;
56156: LD_VAR 0 3
56160: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56161: LD_INT 0
56163: PPUSH
// result := false ;
56164: LD_ADDR_VAR 0 4
56168: PUSH
56169: LD_INT 0
56171: ST_TO_ADDR
// if GetTaskList ( unit ) then
56172: LD_VAR 0 1
56176: PPUSH
56177: CALL_OW 437
56181: IFFALSE 56264
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56183: LD_STRING M
56185: PUSH
56186: LD_VAR 0 1
56190: PPUSH
56191: CALL_OW 437
56195: PUSH
56196: LD_INT 1
56198: ARRAY
56199: PUSH
56200: LD_INT 1
56202: ARRAY
56203: EQUAL
56204: PUSH
56205: LD_VAR 0 2
56209: PUSH
56210: LD_VAR 0 1
56214: PPUSH
56215: CALL_OW 437
56219: PUSH
56220: LD_INT 1
56222: ARRAY
56223: PUSH
56224: LD_INT 2
56226: ARRAY
56227: EQUAL
56228: AND
56229: PUSH
56230: LD_VAR 0 3
56234: PUSH
56235: LD_VAR 0 1
56239: PPUSH
56240: CALL_OW 437
56244: PUSH
56245: LD_INT 1
56247: ARRAY
56248: PUSH
56249: LD_INT 3
56251: ARRAY
56252: EQUAL
56253: AND
56254: IFFALSE 56264
// result := true ;
56256: LD_ADDR_VAR 0 4
56260: PUSH
56261: LD_INT 1
56263: ST_TO_ADDR
// end ; end ;
56264: LD_VAR 0 4
56268: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56269: LD_INT 0
56271: PPUSH
56272: PPUSH
56273: PPUSH
56274: PPUSH
// if not unit or not area then
56275: LD_VAR 0 1
56279: NOT
56280: PUSH
56281: LD_VAR 0 2
56285: NOT
56286: OR
56287: IFFALSE 56291
// exit ;
56289: GO 56455
// tmp := AreaToList ( area , i ) ;
56291: LD_ADDR_VAR 0 6
56295: PUSH
56296: LD_VAR 0 2
56300: PPUSH
56301: LD_VAR 0 5
56305: PPUSH
56306: CALL_OW 517
56310: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56311: LD_ADDR_VAR 0 5
56315: PUSH
56316: DOUBLE
56317: LD_INT 1
56319: DEC
56320: ST_TO_ADDR
56321: LD_VAR 0 6
56325: PUSH
56326: LD_INT 1
56328: ARRAY
56329: PUSH
56330: FOR_TO
56331: IFFALSE 56453
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56333: LD_ADDR_VAR 0 7
56337: PUSH
56338: LD_VAR 0 6
56342: PUSH
56343: LD_INT 1
56345: ARRAY
56346: PUSH
56347: LD_VAR 0 5
56351: ARRAY
56352: PUSH
56353: LD_VAR 0 6
56357: PUSH
56358: LD_INT 2
56360: ARRAY
56361: PUSH
56362: LD_VAR 0 5
56366: ARRAY
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56372: LD_VAR 0 7
56376: PUSH
56377: LD_INT 1
56379: ARRAY
56380: PPUSH
56381: LD_VAR 0 7
56385: PUSH
56386: LD_INT 2
56388: ARRAY
56389: PPUSH
56390: CALL_OW 428
56394: PUSH
56395: LD_INT 0
56397: EQUAL
56398: IFFALSE 56451
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56400: LD_VAR 0 1
56404: PPUSH
56405: LD_VAR 0 7
56409: PUSH
56410: LD_INT 1
56412: ARRAY
56413: PPUSH
56414: LD_VAR 0 7
56418: PUSH
56419: LD_INT 2
56421: ARRAY
56422: PPUSH
56423: LD_VAR 0 3
56427: PPUSH
56428: CALL_OW 48
// result := IsPlaced ( unit ) ;
56432: LD_ADDR_VAR 0 4
56436: PUSH
56437: LD_VAR 0 1
56441: PPUSH
56442: CALL_OW 305
56446: ST_TO_ADDR
// exit ;
56447: POP
56448: POP
56449: GO 56455
// end ; end ;
56451: GO 56330
56453: POP
56454: POP
// end ;
56455: LD_VAR 0 4
56459: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56460: LD_INT 0
56462: PPUSH
56463: PPUSH
56464: PPUSH
// if not side or side > 8 then
56465: LD_VAR 0 1
56469: NOT
56470: PUSH
56471: LD_VAR 0 1
56475: PUSH
56476: LD_INT 8
56478: GREATER
56479: OR
56480: IFFALSE 56484
// exit ;
56482: GO 56671
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56484: LD_ADDR_VAR 0 4
56488: PUSH
56489: LD_INT 22
56491: PUSH
56492: LD_VAR 0 1
56496: PUSH
56497: EMPTY
56498: LIST
56499: LIST
56500: PUSH
56501: LD_INT 21
56503: PUSH
56504: LD_INT 3
56506: PUSH
56507: EMPTY
56508: LIST
56509: LIST
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: PPUSH
56515: CALL_OW 69
56519: ST_TO_ADDR
// if not tmp then
56520: LD_VAR 0 4
56524: NOT
56525: IFFALSE 56529
// exit ;
56527: GO 56671
// enable_addtolog := true ;
56529: LD_ADDR_OWVAR 81
56533: PUSH
56534: LD_INT 1
56536: ST_TO_ADDR
// AddToLog ( [ ) ;
56537: LD_STRING [
56539: PPUSH
56540: CALL_OW 561
// for i in tmp do
56544: LD_ADDR_VAR 0 3
56548: PUSH
56549: LD_VAR 0 4
56553: PUSH
56554: FOR_IN
56555: IFFALSE 56662
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56557: LD_STRING [
56559: PUSH
56560: LD_VAR 0 3
56564: PPUSH
56565: CALL_OW 266
56569: STR
56570: PUSH
56571: LD_STRING , 
56573: STR
56574: PUSH
56575: LD_VAR 0 3
56579: PPUSH
56580: CALL_OW 250
56584: STR
56585: PUSH
56586: LD_STRING , 
56588: STR
56589: PUSH
56590: LD_VAR 0 3
56594: PPUSH
56595: CALL_OW 251
56599: STR
56600: PUSH
56601: LD_STRING , 
56603: STR
56604: PUSH
56605: LD_VAR 0 3
56609: PPUSH
56610: CALL_OW 254
56614: STR
56615: PUSH
56616: LD_STRING , 
56618: STR
56619: PUSH
56620: LD_VAR 0 3
56624: PPUSH
56625: LD_INT 1
56627: PPUSH
56628: CALL_OW 268
56632: STR
56633: PUSH
56634: LD_STRING , 
56636: STR
56637: PUSH
56638: LD_VAR 0 3
56642: PPUSH
56643: LD_INT 2
56645: PPUSH
56646: CALL_OW 268
56650: STR
56651: PUSH
56652: LD_STRING ],
56654: STR
56655: PPUSH
56656: CALL_OW 561
// end ;
56660: GO 56554
56662: POP
56663: POP
// AddToLog ( ]; ) ;
56664: LD_STRING ];
56666: PPUSH
56667: CALL_OW 561
// end ;
56671: LD_VAR 0 2
56675: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56676: LD_INT 0
56678: PPUSH
56679: PPUSH
56680: PPUSH
56681: PPUSH
56682: PPUSH
// if not area or not rate or not max then
56683: LD_VAR 0 1
56687: NOT
56688: PUSH
56689: LD_VAR 0 2
56693: NOT
56694: OR
56695: PUSH
56696: LD_VAR 0 4
56700: NOT
56701: OR
56702: IFFALSE 56706
// exit ;
56704: GO 56895
// while 1 do
56706: LD_INT 1
56708: IFFALSE 56895
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56710: LD_ADDR_VAR 0 9
56714: PUSH
56715: LD_VAR 0 1
56719: PPUSH
56720: LD_INT 1
56722: PPUSH
56723: CALL_OW 287
56727: PUSH
56728: LD_INT 10
56730: MUL
56731: ST_TO_ADDR
// r := rate / 10 ;
56732: LD_ADDR_VAR 0 7
56736: PUSH
56737: LD_VAR 0 2
56741: PUSH
56742: LD_INT 10
56744: DIVREAL
56745: ST_TO_ADDR
// time := 1 1$00 ;
56746: LD_ADDR_VAR 0 8
56750: PUSH
56751: LD_INT 2100
56753: ST_TO_ADDR
// if amount < min then
56754: LD_VAR 0 9
56758: PUSH
56759: LD_VAR 0 3
56763: LESS
56764: IFFALSE 56782
// r := r * 2 else
56766: LD_ADDR_VAR 0 7
56770: PUSH
56771: LD_VAR 0 7
56775: PUSH
56776: LD_INT 2
56778: MUL
56779: ST_TO_ADDR
56780: GO 56808
// if amount > max then
56782: LD_VAR 0 9
56786: PUSH
56787: LD_VAR 0 4
56791: GREATER
56792: IFFALSE 56808
// r := r / 2 ;
56794: LD_ADDR_VAR 0 7
56798: PUSH
56799: LD_VAR 0 7
56803: PUSH
56804: LD_INT 2
56806: DIVREAL
56807: ST_TO_ADDR
// time := time / r ;
56808: LD_ADDR_VAR 0 8
56812: PUSH
56813: LD_VAR 0 8
56817: PUSH
56818: LD_VAR 0 7
56822: DIVREAL
56823: ST_TO_ADDR
// if time < 0 then
56824: LD_VAR 0 8
56828: PUSH
56829: LD_INT 0
56831: LESS
56832: IFFALSE 56849
// time := time * - 1 ;
56834: LD_ADDR_VAR 0 8
56838: PUSH
56839: LD_VAR 0 8
56843: PUSH
56844: LD_INT 1
56846: NEG
56847: MUL
56848: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56849: LD_VAR 0 8
56853: PUSH
56854: LD_INT 35
56856: PPUSH
56857: LD_INT 875
56859: PPUSH
56860: CALL_OW 12
56864: PLUS
56865: PPUSH
56866: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56870: LD_INT 1
56872: PPUSH
56873: LD_INT 5
56875: PPUSH
56876: CALL_OW 12
56880: PPUSH
56881: LD_VAR 0 1
56885: PPUSH
56886: LD_INT 1
56888: PPUSH
56889: CALL_OW 55
// end ;
56893: GO 56706
// end ;
56895: LD_VAR 0 5
56899: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56900: LD_INT 0
56902: PPUSH
56903: PPUSH
56904: PPUSH
56905: PPUSH
56906: PPUSH
56907: PPUSH
56908: PPUSH
56909: PPUSH
// if not turrets or not factories then
56910: LD_VAR 0 1
56914: NOT
56915: PUSH
56916: LD_VAR 0 2
56920: NOT
56921: OR
56922: IFFALSE 56926
// exit ;
56924: GO 57233
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56926: LD_ADDR_VAR 0 10
56930: PUSH
56931: LD_INT 5
56933: PUSH
56934: LD_INT 6
56936: PUSH
56937: EMPTY
56938: LIST
56939: LIST
56940: PUSH
56941: LD_INT 2
56943: PUSH
56944: LD_INT 4
56946: PUSH
56947: EMPTY
56948: LIST
56949: LIST
56950: PUSH
56951: LD_INT 3
56953: PUSH
56954: LD_INT 5
56956: PUSH
56957: EMPTY
56958: LIST
56959: LIST
56960: PUSH
56961: EMPTY
56962: LIST
56963: LIST
56964: LIST
56965: PUSH
56966: LD_INT 24
56968: PUSH
56969: LD_INT 25
56971: PUSH
56972: EMPTY
56973: LIST
56974: LIST
56975: PUSH
56976: LD_INT 23
56978: PUSH
56979: LD_INT 27
56981: PUSH
56982: EMPTY
56983: LIST
56984: LIST
56985: PUSH
56986: EMPTY
56987: LIST
56988: LIST
56989: PUSH
56990: LD_INT 42
56992: PUSH
56993: LD_INT 43
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: PUSH
57000: LD_INT 44
57002: PUSH
57003: LD_INT 46
57005: PUSH
57006: EMPTY
57007: LIST
57008: LIST
57009: PUSH
57010: LD_INT 45
57012: PUSH
57013: LD_INT 47
57015: PUSH
57016: EMPTY
57017: LIST
57018: LIST
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: LIST
57024: PUSH
57025: EMPTY
57026: LIST
57027: LIST
57028: LIST
57029: ST_TO_ADDR
// result := [ ] ;
57030: LD_ADDR_VAR 0 3
57034: PUSH
57035: EMPTY
57036: ST_TO_ADDR
// for i in turrets do
57037: LD_ADDR_VAR 0 4
57041: PUSH
57042: LD_VAR 0 1
57046: PUSH
57047: FOR_IN
57048: IFFALSE 57231
// begin nat := GetNation ( i ) ;
57050: LD_ADDR_VAR 0 7
57054: PUSH
57055: LD_VAR 0 4
57059: PPUSH
57060: CALL_OW 248
57064: ST_TO_ADDR
// weapon := 0 ;
57065: LD_ADDR_VAR 0 8
57069: PUSH
57070: LD_INT 0
57072: ST_TO_ADDR
// if not nat then
57073: LD_VAR 0 7
57077: NOT
57078: IFFALSE 57082
// continue ;
57080: GO 57047
// for j in list [ nat ] do
57082: LD_ADDR_VAR 0 5
57086: PUSH
57087: LD_VAR 0 10
57091: PUSH
57092: LD_VAR 0 7
57096: ARRAY
57097: PUSH
57098: FOR_IN
57099: IFFALSE 57140
// if GetBWeapon ( i ) = j [ 1 ] then
57101: LD_VAR 0 4
57105: PPUSH
57106: CALL_OW 269
57110: PUSH
57111: LD_VAR 0 5
57115: PUSH
57116: LD_INT 1
57118: ARRAY
57119: EQUAL
57120: IFFALSE 57138
// begin weapon := j [ 2 ] ;
57122: LD_ADDR_VAR 0 8
57126: PUSH
57127: LD_VAR 0 5
57131: PUSH
57132: LD_INT 2
57134: ARRAY
57135: ST_TO_ADDR
// break ;
57136: GO 57140
// end ;
57138: GO 57098
57140: POP
57141: POP
// if not weapon then
57142: LD_VAR 0 8
57146: NOT
57147: IFFALSE 57151
// continue ;
57149: GO 57047
// for k in factories do
57151: LD_ADDR_VAR 0 6
57155: PUSH
57156: LD_VAR 0 2
57160: PUSH
57161: FOR_IN
57162: IFFALSE 57227
// begin weapons := AvailableWeaponList ( k ) ;
57164: LD_ADDR_VAR 0 9
57168: PUSH
57169: LD_VAR 0 6
57173: PPUSH
57174: CALL_OW 478
57178: ST_TO_ADDR
// if not weapons then
57179: LD_VAR 0 9
57183: NOT
57184: IFFALSE 57188
// continue ;
57186: GO 57161
// if weapon in weapons then
57188: LD_VAR 0 8
57192: PUSH
57193: LD_VAR 0 9
57197: IN
57198: IFFALSE 57225
// begin result := [ i , weapon ] ;
57200: LD_ADDR_VAR 0 3
57204: PUSH
57205: LD_VAR 0 4
57209: PUSH
57210: LD_VAR 0 8
57214: PUSH
57215: EMPTY
57216: LIST
57217: LIST
57218: ST_TO_ADDR
// exit ;
57219: POP
57220: POP
57221: POP
57222: POP
57223: GO 57233
// end ; end ;
57225: GO 57161
57227: POP
57228: POP
// end ;
57229: GO 57047
57231: POP
57232: POP
// end ;
57233: LD_VAR 0 3
57237: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57238: LD_INT 0
57240: PPUSH
// if not side or side > 8 then
57241: LD_VAR 0 3
57245: NOT
57246: PUSH
57247: LD_VAR 0 3
57251: PUSH
57252: LD_INT 8
57254: GREATER
57255: OR
57256: IFFALSE 57260
// exit ;
57258: GO 57319
// if not range then
57260: LD_VAR 0 4
57264: NOT
57265: IFFALSE 57276
// range := - 12 ;
57267: LD_ADDR_VAR 0 4
57271: PUSH
57272: LD_INT 12
57274: NEG
57275: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57276: LD_VAR 0 1
57280: PPUSH
57281: LD_VAR 0 2
57285: PPUSH
57286: LD_VAR 0 3
57290: PPUSH
57291: LD_VAR 0 4
57295: PPUSH
57296: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57300: LD_VAR 0 1
57304: PPUSH
57305: LD_VAR 0 2
57309: PPUSH
57310: LD_VAR 0 3
57314: PPUSH
57315: CALL_OW 331
// end ;
57319: LD_VAR 0 5
57323: RET
// export function Video ( mode ) ; begin
57324: LD_INT 0
57326: PPUSH
// ingame_video = mode ;
57327: LD_ADDR_OWVAR 52
57331: PUSH
57332: LD_VAR 0 1
57336: ST_TO_ADDR
// interface_hidden = mode ;
57337: LD_ADDR_OWVAR 54
57341: PUSH
57342: LD_VAR 0 1
57346: ST_TO_ADDR
// end ;
57347: LD_VAR 0 2
57351: RET
// export function Join ( array , element ) ; begin
57352: LD_INT 0
57354: PPUSH
// result := Replace ( array , array + 1 , element ) ;
57355: LD_ADDR_VAR 0 3
57359: PUSH
57360: LD_VAR 0 1
57364: PPUSH
57365: LD_VAR 0 1
57369: PUSH
57370: LD_INT 1
57372: PLUS
57373: PPUSH
57374: LD_VAR 0 2
57378: PPUSH
57379: CALL_OW 1
57383: ST_TO_ADDR
// end ;
57384: LD_VAR 0 3
57388: RET
// export function JoinUnion ( array , element ) ; begin
57389: LD_INT 0
57391: PPUSH
// result := array union element ;
57392: LD_ADDR_VAR 0 3
57396: PUSH
57397: LD_VAR 0 1
57401: PUSH
57402: LD_VAR 0 2
57406: UNION
57407: ST_TO_ADDR
// end ;
57408: LD_VAR 0 3
57412: RET
// export function GetBehemoths ( side ) ; begin
57413: LD_INT 0
57415: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
57416: LD_ADDR_VAR 0 2
57420: PUSH
57421: LD_INT 22
57423: PUSH
57424: LD_VAR 0 1
57428: PUSH
57429: EMPTY
57430: LIST
57431: LIST
57432: PUSH
57433: LD_INT 31
57435: PUSH
57436: LD_INT 25
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: PUSH
57443: EMPTY
57444: LIST
57445: LIST
57446: PPUSH
57447: CALL_OW 69
57451: ST_TO_ADDR
// end ;
57452: LD_VAR 0 2
57456: RET
// export function Shuffle ( array ) ; var i , index ; begin
57457: LD_INT 0
57459: PPUSH
57460: PPUSH
57461: PPUSH
// result := [ ] ;
57462: LD_ADDR_VAR 0 2
57466: PUSH
57467: EMPTY
57468: ST_TO_ADDR
// if not array then
57469: LD_VAR 0 1
57473: NOT
57474: IFFALSE 57478
// exit ;
57476: GO 57577
// Randomize ;
57478: CALL_OW 10
// for i = array downto 1 do
57482: LD_ADDR_VAR 0 3
57486: PUSH
57487: DOUBLE
57488: LD_VAR 0 1
57492: INC
57493: ST_TO_ADDR
57494: LD_INT 1
57496: PUSH
57497: FOR_DOWNTO
57498: IFFALSE 57575
// begin index := rand ( 1 , array ) ;
57500: LD_ADDR_VAR 0 4
57504: PUSH
57505: LD_INT 1
57507: PPUSH
57508: LD_VAR 0 1
57512: PPUSH
57513: CALL_OW 12
57517: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57518: LD_ADDR_VAR 0 2
57522: PUSH
57523: LD_VAR 0 2
57527: PPUSH
57528: LD_VAR 0 2
57532: PUSH
57533: LD_INT 1
57535: PLUS
57536: PPUSH
57537: LD_VAR 0 1
57541: PUSH
57542: LD_VAR 0 4
57546: ARRAY
57547: PPUSH
57548: CALL_OW 2
57552: ST_TO_ADDR
// array := Delete ( array , index ) ;
57553: LD_ADDR_VAR 0 1
57557: PUSH
57558: LD_VAR 0 1
57562: PPUSH
57563: LD_VAR 0 4
57567: PPUSH
57568: CALL_OW 3
57572: ST_TO_ADDR
// end ;
57573: GO 57497
57575: POP
57576: POP
// end ;
57577: LD_VAR 0 2
57581: RET
// export function GetBaseMaterials ( base ) ; begin
57582: LD_INT 0
57584: PPUSH
// result := [ 0 , 0 , 0 ] ;
57585: LD_ADDR_VAR 0 2
57589: PUSH
57590: LD_INT 0
57592: PUSH
57593: LD_INT 0
57595: PUSH
57596: LD_INT 0
57598: PUSH
57599: EMPTY
57600: LIST
57601: LIST
57602: LIST
57603: ST_TO_ADDR
// if not base then
57604: LD_VAR 0 1
57608: NOT
57609: IFFALSE 57613
// exit ;
57611: GO 57662
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57613: LD_ADDR_VAR 0 2
57617: PUSH
57618: LD_VAR 0 1
57622: PPUSH
57623: LD_INT 1
57625: PPUSH
57626: CALL_OW 275
57630: PUSH
57631: LD_VAR 0 1
57635: PPUSH
57636: LD_INT 2
57638: PPUSH
57639: CALL_OW 275
57643: PUSH
57644: LD_VAR 0 1
57648: PPUSH
57649: LD_INT 3
57651: PPUSH
57652: CALL_OW 275
57656: PUSH
57657: EMPTY
57658: LIST
57659: LIST
57660: LIST
57661: ST_TO_ADDR
// end ;
57662: LD_VAR 0 2
57666: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57667: LD_INT 0
57669: PPUSH
57670: PPUSH
// result := array ;
57671: LD_ADDR_VAR 0 3
57675: PUSH
57676: LD_VAR 0 1
57680: ST_TO_ADDR
// if size >= result then
57681: LD_VAR 0 2
57685: PUSH
57686: LD_VAR 0 3
57690: GREATEREQUAL
57691: IFFALSE 57695
// exit ;
57693: GO 57745
// if size then
57695: LD_VAR 0 2
57699: IFFALSE 57745
// for i := array downto size do
57701: LD_ADDR_VAR 0 4
57705: PUSH
57706: DOUBLE
57707: LD_VAR 0 1
57711: INC
57712: ST_TO_ADDR
57713: LD_VAR 0 2
57717: PUSH
57718: FOR_DOWNTO
57719: IFFALSE 57743
// result := Delete ( result , result ) ;
57721: LD_ADDR_VAR 0 3
57725: PUSH
57726: LD_VAR 0 3
57730: PPUSH
57731: LD_VAR 0 3
57735: PPUSH
57736: CALL_OW 3
57740: ST_TO_ADDR
57741: GO 57718
57743: POP
57744: POP
// end ;
57745: LD_VAR 0 3
57749: RET
// export function ComExit ( unit ) ; var tmp ; begin
57750: LD_INT 0
57752: PPUSH
57753: PPUSH
// if not IsInUnit ( unit ) then
57754: LD_VAR 0 1
57758: PPUSH
57759: CALL_OW 310
57763: NOT
57764: IFFALSE 57768
// exit ;
57766: GO 57828
// tmp := IsInUnit ( unit ) ;
57768: LD_ADDR_VAR 0 3
57772: PUSH
57773: LD_VAR 0 1
57777: PPUSH
57778: CALL_OW 310
57782: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57783: LD_VAR 0 3
57787: PPUSH
57788: CALL_OW 247
57792: PUSH
57793: LD_INT 2
57795: EQUAL
57796: IFFALSE 57809
// ComExitVehicle ( unit ) else
57798: LD_VAR 0 1
57802: PPUSH
57803: CALL_OW 121
57807: GO 57818
// ComExitBuilding ( unit ) ;
57809: LD_VAR 0 1
57813: PPUSH
57814: CALL_OW 122
// result := tmp ;
57818: LD_ADDR_VAR 0 2
57822: PUSH
57823: LD_VAR 0 3
57827: ST_TO_ADDR
// end ;
57828: LD_VAR 0 2
57832: RET
// export function ComExitAll ( units ) ; var i ; begin
57833: LD_INT 0
57835: PPUSH
57836: PPUSH
// if not units then
57837: LD_VAR 0 1
57841: NOT
57842: IFFALSE 57846
// exit ;
57844: GO 57872
// for i in units do
57846: LD_ADDR_VAR 0 3
57850: PUSH
57851: LD_VAR 0 1
57855: PUSH
57856: FOR_IN
57857: IFFALSE 57870
// ComExit ( i ) ;
57859: LD_VAR 0 3
57863: PPUSH
57864: CALL 57750 0 1
57868: GO 57856
57870: POP
57871: POP
// end ;
57872: LD_VAR 0 2
57876: RET
// export function ResetHc ; begin
57877: LD_INT 0
57879: PPUSH
// InitHc ;
57880: CALL_OW 19
// hc_importance := 0 ;
57884: LD_ADDR_OWVAR 32
57888: PUSH
57889: LD_INT 0
57891: ST_TO_ADDR
// end ;
57892: LD_VAR 0 1
57896: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57897: LD_INT 0
57899: PPUSH
57900: PPUSH
57901: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57902: LD_ADDR_VAR 0 6
57906: PUSH
57907: LD_VAR 0 1
57911: PUSH
57912: LD_VAR 0 3
57916: PLUS
57917: PUSH
57918: LD_INT 2
57920: DIV
57921: ST_TO_ADDR
// if _x < 0 then
57922: LD_VAR 0 6
57926: PUSH
57927: LD_INT 0
57929: LESS
57930: IFFALSE 57947
// _x := _x * - 1 ;
57932: LD_ADDR_VAR 0 6
57936: PUSH
57937: LD_VAR 0 6
57941: PUSH
57942: LD_INT 1
57944: NEG
57945: MUL
57946: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57947: LD_ADDR_VAR 0 7
57951: PUSH
57952: LD_VAR 0 2
57956: PUSH
57957: LD_VAR 0 4
57961: PLUS
57962: PUSH
57963: LD_INT 2
57965: DIV
57966: ST_TO_ADDR
// if _y < 0 then
57967: LD_VAR 0 7
57971: PUSH
57972: LD_INT 0
57974: LESS
57975: IFFALSE 57992
// _y := _y * - 1 ;
57977: LD_ADDR_VAR 0 7
57981: PUSH
57982: LD_VAR 0 7
57986: PUSH
57987: LD_INT 1
57989: NEG
57990: MUL
57991: ST_TO_ADDR
// result := [ _x , _y ] ;
57992: LD_ADDR_VAR 0 5
57996: PUSH
57997: LD_VAR 0 6
58001: PUSH
58002: LD_VAR 0 7
58006: PUSH
58007: EMPTY
58008: LIST
58009: LIST
58010: ST_TO_ADDR
// end ;
58011: LD_VAR 0 5
58015: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
58016: LD_INT 0
58018: PPUSH
58019: PPUSH
58020: PPUSH
58021: PPUSH
// task := GetTaskList ( unit ) ;
58022: LD_ADDR_VAR 0 7
58026: PUSH
58027: LD_VAR 0 1
58031: PPUSH
58032: CALL_OW 437
58036: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
58037: LD_VAR 0 7
58041: NOT
58042: PUSH
58043: LD_VAR 0 1
58047: PPUSH
58048: LD_VAR 0 2
58052: PPUSH
58053: CALL_OW 308
58057: NOT
58058: AND
58059: IFFALSE 58063
// exit ;
58061: GO 58181
// if IsInArea ( unit , area ) then
58063: LD_VAR 0 1
58067: PPUSH
58068: LD_VAR 0 2
58072: PPUSH
58073: CALL_OW 308
58077: IFFALSE 58095
// begin ComMoveToArea ( unit , goAway ) ;
58079: LD_VAR 0 1
58083: PPUSH
58084: LD_VAR 0 3
58088: PPUSH
58089: CALL_OW 113
// exit ;
58093: GO 58181
// end ; if task [ 1 ] [ 1 ] <> M then
58095: LD_VAR 0 7
58099: PUSH
58100: LD_INT 1
58102: ARRAY
58103: PUSH
58104: LD_INT 1
58106: ARRAY
58107: PUSH
58108: LD_STRING M
58110: NONEQUAL
58111: IFFALSE 58115
// exit ;
58113: GO 58181
// x := task [ 1 ] [ 2 ] ;
58115: LD_ADDR_VAR 0 5
58119: PUSH
58120: LD_VAR 0 7
58124: PUSH
58125: LD_INT 1
58127: ARRAY
58128: PUSH
58129: LD_INT 2
58131: ARRAY
58132: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
58133: LD_ADDR_VAR 0 6
58137: PUSH
58138: LD_VAR 0 7
58142: PUSH
58143: LD_INT 1
58145: ARRAY
58146: PUSH
58147: LD_INT 3
58149: ARRAY
58150: ST_TO_ADDR
// if InArea ( x , y , area ) then
58151: LD_VAR 0 5
58155: PPUSH
58156: LD_VAR 0 6
58160: PPUSH
58161: LD_VAR 0 2
58165: PPUSH
58166: CALL_OW 309
58170: IFFALSE 58181
// ComStop ( unit ) ;
58172: LD_VAR 0 1
58176: PPUSH
58177: CALL_OW 141
// end ;
58181: LD_VAR 0 4
58185: RET
// export function Abs ( value ) ; begin
58186: LD_INT 0
58188: PPUSH
// result := value ;
58189: LD_ADDR_VAR 0 2
58193: PUSH
58194: LD_VAR 0 1
58198: ST_TO_ADDR
// if value < 0 then
58199: LD_VAR 0 1
58203: PUSH
58204: LD_INT 0
58206: LESS
58207: IFFALSE 58224
// result := value * - 1 ;
58209: LD_ADDR_VAR 0 2
58213: PUSH
58214: LD_VAR 0 1
58218: PUSH
58219: LD_INT 1
58221: NEG
58222: MUL
58223: ST_TO_ADDR
// end ;
58224: LD_VAR 0 2
58228: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58229: LD_INT 0
58231: PPUSH
58232: PPUSH
58233: PPUSH
58234: PPUSH
58235: PPUSH
58236: PPUSH
58237: PPUSH
58238: PPUSH
// if not unit or not building then
58239: LD_VAR 0 1
58243: NOT
58244: PUSH
58245: LD_VAR 0 2
58249: NOT
58250: OR
58251: IFFALSE 58255
// exit ;
58253: GO 58481
// x := GetX ( building ) ;
58255: LD_ADDR_VAR 0 4
58259: PUSH
58260: LD_VAR 0 2
58264: PPUSH
58265: CALL_OW 250
58269: ST_TO_ADDR
// y := GetY ( building ) ;
58270: LD_ADDR_VAR 0 6
58274: PUSH
58275: LD_VAR 0 2
58279: PPUSH
58280: CALL_OW 251
58284: ST_TO_ADDR
// d := GetDir ( building ) ;
58285: LD_ADDR_VAR 0 8
58289: PUSH
58290: LD_VAR 0 2
58294: PPUSH
58295: CALL_OW 254
58299: ST_TO_ADDR
// r := 4 ;
58300: LD_ADDR_VAR 0 9
58304: PUSH
58305: LD_INT 4
58307: ST_TO_ADDR
// for i := 1 to 5 do
58308: LD_ADDR_VAR 0 10
58312: PUSH
58313: DOUBLE
58314: LD_INT 1
58316: DEC
58317: ST_TO_ADDR
58318: LD_INT 5
58320: PUSH
58321: FOR_TO
58322: IFFALSE 58479
// begin _x := ShiftX ( x , d , r + i ) ;
58324: LD_ADDR_VAR 0 5
58328: PUSH
58329: LD_VAR 0 4
58333: PPUSH
58334: LD_VAR 0 8
58338: PPUSH
58339: LD_VAR 0 9
58343: PUSH
58344: LD_VAR 0 10
58348: PLUS
58349: PPUSH
58350: CALL_OW 272
58354: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
58355: LD_ADDR_VAR 0 7
58359: PUSH
58360: LD_VAR 0 6
58364: PPUSH
58365: LD_VAR 0 8
58369: PPUSH
58370: LD_VAR 0 9
58374: PUSH
58375: LD_VAR 0 10
58379: PLUS
58380: PPUSH
58381: CALL_OW 273
58385: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
58386: LD_VAR 0 5
58390: PPUSH
58391: LD_VAR 0 7
58395: PPUSH
58396: CALL_OW 488
58400: PUSH
58401: LD_VAR 0 5
58405: PPUSH
58406: LD_VAR 0 7
58410: PPUSH
58411: CALL_OW 428
58415: PPUSH
58416: CALL_OW 247
58420: PUSH
58421: LD_INT 3
58423: PUSH
58424: LD_INT 2
58426: PUSH
58427: EMPTY
58428: LIST
58429: LIST
58430: IN
58431: NOT
58432: AND
58433: IFFALSE 58477
// begin ComMoveXY ( unit , _x , _y ) ;
58435: LD_VAR 0 1
58439: PPUSH
58440: LD_VAR 0 5
58444: PPUSH
58445: LD_VAR 0 7
58449: PPUSH
58450: CALL_OW 111
// result := [ _x , _y ] ;
58454: LD_ADDR_VAR 0 3
58458: PUSH
58459: LD_VAR 0 5
58463: PUSH
58464: LD_VAR 0 7
58468: PUSH
58469: EMPTY
58470: LIST
58471: LIST
58472: ST_TO_ADDR
// exit ;
58473: POP
58474: POP
58475: GO 58481
// end ; end ;
58477: GO 58321
58479: POP
58480: POP
// end ;
58481: LD_VAR 0 3
58485: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
58486: LD_INT 0
58488: PPUSH
58489: PPUSH
58490: PPUSH
// result := 0 ;
58491: LD_ADDR_VAR 0 3
58495: PUSH
58496: LD_INT 0
58498: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
58499: LD_VAR 0 1
58503: PUSH
58504: LD_INT 0
58506: LESS
58507: PUSH
58508: LD_VAR 0 1
58512: PUSH
58513: LD_INT 8
58515: GREATER
58516: OR
58517: PUSH
58518: LD_VAR 0 2
58522: PUSH
58523: LD_INT 0
58525: LESS
58526: OR
58527: PUSH
58528: LD_VAR 0 2
58532: PUSH
58533: LD_INT 8
58535: GREATER
58536: OR
58537: IFFALSE 58541
// exit ;
58539: GO 58616
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
58541: LD_ADDR_VAR 0 4
58545: PUSH
58546: LD_INT 22
58548: PUSH
58549: LD_VAR 0 2
58553: PUSH
58554: EMPTY
58555: LIST
58556: LIST
58557: PPUSH
58558: CALL_OW 69
58562: PUSH
58563: FOR_IN
58564: IFFALSE 58614
// begin un := UnitShoot ( i ) ;
58566: LD_ADDR_VAR 0 5
58570: PUSH
58571: LD_VAR 0 4
58575: PPUSH
58576: CALL_OW 504
58580: ST_TO_ADDR
// if GetSide ( un ) = side1 then
58581: LD_VAR 0 5
58585: PPUSH
58586: CALL_OW 255
58590: PUSH
58591: LD_VAR 0 1
58595: EQUAL
58596: IFFALSE 58612
// begin result := un ;
58598: LD_ADDR_VAR 0 3
58602: PUSH
58603: LD_VAR 0 5
58607: ST_TO_ADDR
// exit ;
58608: POP
58609: POP
58610: GO 58616
// end ; end ;
58612: GO 58563
58614: POP
58615: POP
// end ;
58616: LD_VAR 0 3
58620: RET
// export function GetCargoBay ( units ) ; begin
58621: LD_INT 0
58623: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
58624: LD_ADDR_VAR 0 2
58628: PUSH
58629: LD_VAR 0 1
58633: PPUSH
58634: LD_INT 2
58636: PUSH
58637: LD_INT 34
58639: PUSH
58640: LD_INT 12
58642: PUSH
58643: EMPTY
58644: LIST
58645: LIST
58646: PUSH
58647: LD_INT 34
58649: PUSH
58650: LD_INT 51
58652: PUSH
58653: EMPTY
58654: LIST
58655: LIST
58656: PUSH
58657: LD_INT 34
58659: PUSH
58660: LD_INT 32
58662: PUSH
58663: EMPTY
58664: LIST
58665: LIST
58666: PUSH
58667: LD_INT 34
58669: PUSH
58670: LD_INT 89
58672: PUSH
58673: EMPTY
58674: LIST
58675: LIST
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: LIST
58681: LIST
58682: LIST
58683: PPUSH
58684: CALL_OW 72
58688: ST_TO_ADDR
// end ;
58689: LD_VAR 0 2
58693: RET
// export function Negate ( value ) ; begin
58694: LD_INT 0
58696: PPUSH
// result := not value ;
58697: LD_ADDR_VAR 0 2
58701: PUSH
58702: LD_VAR 0 1
58706: NOT
58707: ST_TO_ADDR
// end ;
58708: LD_VAR 0 2
58712: RET
// export function Inc ( value ) ; begin
58713: LD_INT 0
58715: PPUSH
// result := value + 1 ;
58716: LD_ADDR_VAR 0 2
58720: PUSH
58721: LD_VAR 0 1
58725: PUSH
58726: LD_INT 1
58728: PLUS
58729: ST_TO_ADDR
// end ;
58730: LD_VAR 0 2
58734: RET
// export function Dec ( value ) ; begin
58735: LD_INT 0
58737: PPUSH
// result := value - 1 ;
58738: LD_ADDR_VAR 0 2
58742: PUSH
58743: LD_VAR 0 1
58747: PUSH
58748: LD_INT 1
58750: MINUS
58751: ST_TO_ADDR
// end ;
58752: LD_VAR 0 2
58756: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58757: LD_INT 0
58759: PPUSH
58760: PPUSH
58761: PPUSH
58762: PPUSH
58763: PPUSH
58764: PPUSH
58765: PPUSH
58766: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58767: LD_VAR 0 1
58771: PPUSH
58772: LD_VAR 0 2
58776: PPUSH
58777: CALL_OW 488
58781: NOT
58782: PUSH
58783: LD_VAR 0 3
58787: PPUSH
58788: LD_VAR 0 4
58792: PPUSH
58793: CALL_OW 488
58797: NOT
58798: OR
58799: IFFALSE 58812
// begin result := - 1 ;
58801: LD_ADDR_VAR 0 5
58805: PUSH
58806: LD_INT 1
58808: NEG
58809: ST_TO_ADDR
// exit ;
58810: GO 59047
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58812: LD_ADDR_VAR 0 12
58816: PUSH
58817: LD_VAR 0 1
58821: PPUSH
58822: LD_VAR 0 2
58826: PPUSH
58827: LD_VAR 0 3
58831: PPUSH
58832: LD_VAR 0 4
58836: PPUSH
58837: CALL 57897 0 4
58841: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58842: LD_ADDR_VAR 0 11
58846: PUSH
58847: LD_VAR 0 1
58851: PPUSH
58852: LD_VAR 0 2
58856: PPUSH
58857: LD_VAR 0 12
58861: PUSH
58862: LD_INT 1
58864: ARRAY
58865: PPUSH
58866: LD_VAR 0 12
58870: PUSH
58871: LD_INT 2
58873: ARRAY
58874: PPUSH
58875: CALL_OW 298
58879: ST_TO_ADDR
// distance := 9999 ;
58880: LD_ADDR_VAR 0 10
58884: PUSH
58885: LD_INT 9999
58887: ST_TO_ADDR
// for i := 0 to 5 do
58888: LD_ADDR_VAR 0 6
58892: PUSH
58893: DOUBLE
58894: LD_INT 0
58896: DEC
58897: ST_TO_ADDR
58898: LD_INT 5
58900: PUSH
58901: FOR_TO
58902: IFFALSE 59045
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58904: LD_ADDR_VAR 0 7
58908: PUSH
58909: LD_VAR 0 1
58913: PPUSH
58914: LD_VAR 0 6
58918: PPUSH
58919: LD_VAR 0 11
58923: PPUSH
58924: CALL_OW 272
58928: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58929: LD_ADDR_VAR 0 8
58933: PUSH
58934: LD_VAR 0 2
58938: PPUSH
58939: LD_VAR 0 6
58943: PPUSH
58944: LD_VAR 0 11
58948: PPUSH
58949: CALL_OW 273
58953: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58954: LD_VAR 0 7
58958: PPUSH
58959: LD_VAR 0 8
58963: PPUSH
58964: CALL_OW 488
58968: NOT
58969: IFFALSE 58973
// continue ;
58971: GO 58901
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58973: LD_ADDR_VAR 0 9
58977: PUSH
58978: LD_VAR 0 12
58982: PUSH
58983: LD_INT 1
58985: ARRAY
58986: PPUSH
58987: LD_VAR 0 12
58991: PUSH
58992: LD_INT 2
58994: ARRAY
58995: PPUSH
58996: LD_VAR 0 7
59000: PPUSH
59001: LD_VAR 0 8
59005: PPUSH
59006: CALL_OW 298
59010: ST_TO_ADDR
// if tmp < distance then
59011: LD_VAR 0 9
59015: PUSH
59016: LD_VAR 0 10
59020: LESS
59021: IFFALSE 59043
// begin result := i ;
59023: LD_ADDR_VAR 0 5
59027: PUSH
59028: LD_VAR 0 6
59032: ST_TO_ADDR
// distance := tmp ;
59033: LD_ADDR_VAR 0 10
59037: PUSH
59038: LD_VAR 0 9
59042: ST_TO_ADDR
// end ; end ;
59043: GO 58901
59045: POP
59046: POP
// end ;
59047: LD_VAR 0 5
59051: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59052: LD_INT 0
59054: PPUSH
59055: PPUSH
// if not driver or not IsInUnit ( driver ) then
59056: LD_VAR 0 1
59060: NOT
59061: PUSH
59062: LD_VAR 0 1
59066: PPUSH
59067: CALL_OW 310
59071: NOT
59072: OR
59073: IFFALSE 59077
// exit ;
59075: GO 59167
// vehicle := IsInUnit ( driver ) ;
59077: LD_ADDR_VAR 0 3
59081: PUSH
59082: LD_VAR 0 1
59086: PPUSH
59087: CALL_OW 310
59091: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59092: LD_VAR 0 1
59096: PPUSH
59097: LD_STRING \
59099: PUSH
59100: LD_INT 0
59102: PUSH
59103: LD_INT 0
59105: PUSH
59106: LD_INT 0
59108: PUSH
59109: LD_INT 0
59111: PUSH
59112: LD_INT 0
59114: PUSH
59115: LD_INT 0
59117: PUSH
59118: EMPTY
59119: LIST
59120: LIST
59121: LIST
59122: LIST
59123: LIST
59124: LIST
59125: LIST
59126: PUSH
59127: LD_STRING E
59129: PUSH
59130: LD_INT 0
59132: PUSH
59133: LD_INT 0
59135: PUSH
59136: LD_VAR 0 3
59140: PUSH
59141: LD_INT 0
59143: PUSH
59144: LD_INT 0
59146: PUSH
59147: LD_INT 0
59149: PUSH
59150: EMPTY
59151: LIST
59152: LIST
59153: LIST
59154: LIST
59155: LIST
59156: LIST
59157: LIST
59158: PUSH
59159: EMPTY
59160: LIST
59161: LIST
59162: PPUSH
59163: CALL_OW 446
// end ;
59167: LD_VAR 0 2
59171: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59172: LD_INT 0
59174: PPUSH
59175: PPUSH
// if not driver or not IsInUnit ( driver ) then
59176: LD_VAR 0 1
59180: NOT
59181: PUSH
59182: LD_VAR 0 1
59186: PPUSH
59187: CALL_OW 310
59191: NOT
59192: OR
59193: IFFALSE 59197
// exit ;
59195: GO 59287
// vehicle := IsInUnit ( driver ) ;
59197: LD_ADDR_VAR 0 3
59201: PUSH
59202: LD_VAR 0 1
59206: PPUSH
59207: CALL_OW 310
59211: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59212: LD_VAR 0 1
59216: PPUSH
59217: LD_STRING \
59219: PUSH
59220: LD_INT 0
59222: PUSH
59223: LD_INT 0
59225: PUSH
59226: LD_INT 0
59228: PUSH
59229: LD_INT 0
59231: PUSH
59232: LD_INT 0
59234: PUSH
59235: LD_INT 0
59237: PUSH
59238: EMPTY
59239: LIST
59240: LIST
59241: LIST
59242: LIST
59243: LIST
59244: LIST
59245: LIST
59246: PUSH
59247: LD_STRING E
59249: PUSH
59250: LD_INT 0
59252: PUSH
59253: LD_INT 0
59255: PUSH
59256: LD_VAR 0 3
59260: PUSH
59261: LD_INT 0
59263: PUSH
59264: LD_INT 0
59266: PUSH
59267: LD_INT 0
59269: PUSH
59270: EMPTY
59271: LIST
59272: LIST
59273: LIST
59274: LIST
59275: LIST
59276: LIST
59277: LIST
59278: PUSH
59279: EMPTY
59280: LIST
59281: LIST
59282: PPUSH
59283: CALL_OW 447
// end ;
59287: LD_VAR 0 2
59291: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
59292: LD_INT 0
59294: PPUSH
59295: PPUSH
59296: PPUSH
// tmp := [ ] ;
59297: LD_ADDR_VAR 0 5
59301: PUSH
59302: EMPTY
59303: ST_TO_ADDR
// for i in units do
59304: LD_ADDR_VAR 0 4
59308: PUSH
59309: LD_VAR 0 1
59313: PUSH
59314: FOR_IN
59315: IFFALSE 59353
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
59317: LD_ADDR_VAR 0 5
59321: PUSH
59322: LD_VAR 0 5
59326: PPUSH
59327: LD_VAR 0 5
59331: PUSH
59332: LD_INT 1
59334: PLUS
59335: PPUSH
59336: LD_VAR 0 4
59340: PPUSH
59341: CALL_OW 256
59345: PPUSH
59346: CALL_OW 2
59350: ST_TO_ADDR
59351: GO 59314
59353: POP
59354: POP
// if not tmp then
59355: LD_VAR 0 5
59359: NOT
59360: IFFALSE 59364
// exit ;
59362: GO 59412
// if asc then
59364: LD_VAR 0 2
59368: IFFALSE 59392
// result := SortListByListAsc ( units , tmp ) else
59370: LD_ADDR_VAR 0 3
59374: PUSH
59375: LD_VAR 0 1
59379: PPUSH
59380: LD_VAR 0 5
59384: PPUSH
59385: CALL_OW 76
59389: ST_TO_ADDR
59390: GO 59412
// result := SortListByListDesc ( units , tmp ) ;
59392: LD_ADDR_VAR 0 3
59396: PUSH
59397: LD_VAR 0 1
59401: PPUSH
59402: LD_VAR 0 5
59406: PPUSH
59407: CALL_OW 77
59411: ST_TO_ADDR
// end ;
59412: LD_VAR 0 3
59416: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
59417: LD_INT 0
59419: PPUSH
59420: PPUSH
// task := GetTaskList ( mech ) ;
59421: LD_ADDR_VAR 0 4
59425: PUSH
59426: LD_VAR 0 1
59430: PPUSH
59431: CALL_OW 437
59435: ST_TO_ADDR
// if not task then
59436: LD_VAR 0 4
59440: NOT
59441: IFFALSE 59445
// exit ;
59443: GO 59487
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
59445: LD_ADDR_VAR 0 3
59449: PUSH
59450: LD_VAR 0 4
59454: PUSH
59455: LD_INT 1
59457: ARRAY
59458: PUSH
59459: LD_INT 1
59461: ARRAY
59462: PUSH
59463: LD_STRING r
59465: EQUAL
59466: PUSH
59467: LD_VAR 0 4
59471: PUSH
59472: LD_INT 1
59474: ARRAY
59475: PUSH
59476: LD_INT 4
59478: ARRAY
59479: PUSH
59480: LD_VAR 0 2
59484: EQUAL
59485: AND
59486: ST_TO_ADDR
// end ;
59487: LD_VAR 0 3
59491: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
59492: LD_INT 0
59494: PPUSH
// SetDir ( unit , d ) ;
59495: LD_VAR 0 1
59499: PPUSH
59500: LD_VAR 0 4
59504: PPUSH
59505: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
59509: LD_VAR 0 1
59513: PPUSH
59514: LD_VAR 0 2
59518: PPUSH
59519: LD_VAR 0 3
59523: PPUSH
59524: LD_VAR 0 5
59528: PPUSH
59529: CALL_OW 48
// end ;
59533: LD_VAR 0 6
59537: RET
// export function ToNaturalNumber ( number ) ; begin
59538: LD_INT 0
59540: PPUSH
// result := number div 1 ;
59541: LD_ADDR_VAR 0 2
59545: PUSH
59546: LD_VAR 0 1
59550: PUSH
59551: LD_INT 1
59553: DIV
59554: ST_TO_ADDR
// if number < 0 then
59555: LD_VAR 0 1
59559: PUSH
59560: LD_INT 0
59562: LESS
59563: IFFALSE 59573
// result := 0 ;
59565: LD_ADDR_VAR 0 2
59569: PUSH
59570: LD_INT 0
59572: ST_TO_ADDR
// end ;
59573: LD_VAR 0 2
59577: RET
// export function SortByClass ( units , class ) ; var un ; begin
59578: LD_INT 0
59580: PPUSH
59581: PPUSH
// if not units or not class then
59582: LD_VAR 0 1
59586: NOT
59587: PUSH
59588: LD_VAR 0 2
59592: NOT
59593: OR
59594: IFFALSE 59598
// exit ;
59596: GO 59693
// result := [ ] ;
59598: LD_ADDR_VAR 0 3
59602: PUSH
59603: EMPTY
59604: ST_TO_ADDR
// for un in units do
59605: LD_ADDR_VAR 0 4
59609: PUSH
59610: LD_VAR 0 1
59614: PUSH
59615: FOR_IN
59616: IFFALSE 59691
// if GetClass ( un ) = class then
59618: LD_VAR 0 4
59622: PPUSH
59623: CALL_OW 257
59627: PUSH
59628: LD_VAR 0 2
59632: EQUAL
59633: IFFALSE 59660
// result := Insert ( result , 1 , un ) else
59635: LD_ADDR_VAR 0 3
59639: PUSH
59640: LD_VAR 0 3
59644: PPUSH
59645: LD_INT 1
59647: PPUSH
59648: LD_VAR 0 4
59652: PPUSH
59653: CALL_OW 2
59657: ST_TO_ADDR
59658: GO 59689
// result := Replace ( result , result + 1 , un ) ;
59660: LD_ADDR_VAR 0 3
59664: PUSH
59665: LD_VAR 0 3
59669: PPUSH
59670: LD_VAR 0 3
59674: PUSH
59675: LD_INT 1
59677: PLUS
59678: PPUSH
59679: LD_VAR 0 4
59683: PPUSH
59684: CALL_OW 1
59688: ST_TO_ADDR
59689: GO 59615
59691: POP
59692: POP
// end ;
59693: LD_VAR 0 3
59697: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59698: LD_INT 0
59700: PPUSH
59701: PPUSH
59702: PPUSH
59703: PPUSH
59704: PPUSH
59705: PPUSH
59706: PPUSH
// result := [ ] ;
59707: LD_ADDR_VAR 0 4
59711: PUSH
59712: EMPTY
59713: ST_TO_ADDR
// if x - r < 0 then
59714: LD_VAR 0 1
59718: PUSH
59719: LD_VAR 0 3
59723: MINUS
59724: PUSH
59725: LD_INT 0
59727: LESS
59728: IFFALSE 59740
// min_x := 0 else
59730: LD_ADDR_VAR 0 8
59734: PUSH
59735: LD_INT 0
59737: ST_TO_ADDR
59738: GO 59756
// min_x := x - r ;
59740: LD_ADDR_VAR 0 8
59744: PUSH
59745: LD_VAR 0 1
59749: PUSH
59750: LD_VAR 0 3
59754: MINUS
59755: ST_TO_ADDR
// if y - r < 0 then
59756: LD_VAR 0 2
59760: PUSH
59761: LD_VAR 0 3
59765: MINUS
59766: PUSH
59767: LD_INT 0
59769: LESS
59770: IFFALSE 59782
// min_y := 0 else
59772: LD_ADDR_VAR 0 7
59776: PUSH
59777: LD_INT 0
59779: ST_TO_ADDR
59780: GO 59798
// min_y := y - r ;
59782: LD_ADDR_VAR 0 7
59786: PUSH
59787: LD_VAR 0 2
59791: PUSH
59792: LD_VAR 0 3
59796: MINUS
59797: ST_TO_ADDR
// max_x := x + r ;
59798: LD_ADDR_VAR 0 9
59802: PUSH
59803: LD_VAR 0 1
59807: PUSH
59808: LD_VAR 0 3
59812: PLUS
59813: ST_TO_ADDR
// max_y := y + r ;
59814: LD_ADDR_VAR 0 10
59818: PUSH
59819: LD_VAR 0 2
59823: PUSH
59824: LD_VAR 0 3
59828: PLUS
59829: ST_TO_ADDR
// for _x = min_x to max_x do
59830: LD_ADDR_VAR 0 5
59834: PUSH
59835: DOUBLE
59836: LD_VAR 0 8
59840: DEC
59841: ST_TO_ADDR
59842: LD_VAR 0 9
59846: PUSH
59847: FOR_TO
59848: IFFALSE 59949
// for _y = min_y to max_y do
59850: LD_ADDR_VAR 0 6
59854: PUSH
59855: DOUBLE
59856: LD_VAR 0 7
59860: DEC
59861: ST_TO_ADDR
59862: LD_VAR 0 10
59866: PUSH
59867: FOR_TO
59868: IFFALSE 59945
// begin if not ValidHex ( _x , _y ) then
59870: LD_VAR 0 5
59874: PPUSH
59875: LD_VAR 0 6
59879: PPUSH
59880: CALL_OW 488
59884: NOT
59885: IFFALSE 59889
// continue ;
59887: GO 59867
// if GetResourceTypeXY ( _x , _y ) then
59889: LD_VAR 0 5
59893: PPUSH
59894: LD_VAR 0 6
59898: PPUSH
59899: CALL_OW 283
59903: IFFALSE 59943
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59905: LD_ADDR_VAR 0 4
59909: PUSH
59910: LD_VAR 0 4
59914: PPUSH
59915: LD_VAR 0 4
59919: PUSH
59920: LD_INT 1
59922: PLUS
59923: PPUSH
59924: LD_VAR 0 5
59928: PUSH
59929: LD_VAR 0 6
59933: PUSH
59934: EMPTY
59935: LIST
59936: LIST
59937: PPUSH
59938: CALL_OW 1
59942: ST_TO_ADDR
// end ;
59943: GO 59867
59945: POP
59946: POP
59947: GO 59847
59949: POP
59950: POP
// end ;
59951: LD_VAR 0 4
59955: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59956: LD_INT 0
59958: PPUSH
59959: PPUSH
59960: PPUSH
59961: PPUSH
59962: PPUSH
59963: PPUSH
59964: PPUSH
59965: PPUSH
// if not units then
59966: LD_VAR 0 1
59970: NOT
59971: IFFALSE 59975
// exit ;
59973: GO 60499
// result := UnitFilter ( units , [ f_ok ] ) ;
59975: LD_ADDR_VAR 0 3
59979: PUSH
59980: LD_VAR 0 1
59984: PPUSH
59985: LD_INT 50
59987: PUSH
59988: EMPTY
59989: LIST
59990: PPUSH
59991: CALL_OW 72
59995: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59996: LD_ADDR_VAR 0 8
60000: PUSH
60001: LD_VAR 0 1
60005: PUSH
60006: LD_INT 1
60008: ARRAY
60009: PPUSH
60010: CALL_OW 255
60014: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
60015: LD_ADDR_VAR 0 10
60019: PUSH
60020: LD_INT 29
60022: PUSH
60023: LD_INT 91
60025: PUSH
60026: LD_INT 49
60028: PUSH
60029: EMPTY
60030: LIST
60031: LIST
60032: LIST
60033: ST_TO_ADDR
// if not result then
60034: LD_VAR 0 3
60038: NOT
60039: IFFALSE 60043
// exit ;
60041: GO 60499
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
60043: LD_ADDR_VAR 0 5
60047: PUSH
60048: LD_INT 81
60050: PUSH
60051: LD_VAR 0 8
60055: PUSH
60056: EMPTY
60057: LIST
60058: LIST
60059: PPUSH
60060: CALL_OW 69
60064: ST_TO_ADDR
// for i in result do
60065: LD_ADDR_VAR 0 4
60069: PUSH
60070: LD_VAR 0 3
60074: PUSH
60075: FOR_IN
60076: IFFALSE 60497
// begin tag := GetTag ( i ) + 1 ;
60078: LD_ADDR_VAR 0 9
60082: PUSH
60083: LD_VAR 0 4
60087: PPUSH
60088: CALL_OW 110
60092: PUSH
60093: LD_INT 1
60095: PLUS
60096: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
60097: LD_ADDR_VAR 0 7
60101: PUSH
60102: LD_VAR 0 4
60106: PPUSH
60107: CALL_OW 250
60111: PPUSH
60112: LD_VAR 0 4
60116: PPUSH
60117: CALL_OW 251
60121: PPUSH
60122: LD_INT 6
60124: PPUSH
60125: CALL 59698 0 3
60129: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
60130: LD_VAR 0 4
60134: PPUSH
60135: CALL_OW 247
60139: PUSH
60140: LD_INT 2
60142: EQUAL
60143: PUSH
60144: LD_VAR 0 7
60148: AND
60149: PUSH
60150: LD_VAR 0 4
60154: PPUSH
60155: CALL_OW 264
60159: PUSH
60160: LD_VAR 0 10
60164: IN
60165: NOT
60166: AND
60167: IFFALSE 60206
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
60169: LD_VAR 0 4
60173: PPUSH
60174: LD_VAR 0 7
60178: PUSH
60179: LD_INT 1
60181: ARRAY
60182: PUSH
60183: LD_INT 1
60185: ARRAY
60186: PPUSH
60187: LD_VAR 0 7
60191: PUSH
60192: LD_INT 1
60194: ARRAY
60195: PUSH
60196: LD_INT 2
60198: ARRAY
60199: PPUSH
60200: CALL_OW 116
60204: GO 60495
// if path > tag then
60206: LD_VAR 0 2
60210: PUSH
60211: LD_VAR 0 9
60215: GREATER
60216: IFFALSE 60424
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
60218: LD_ADDR_VAR 0 6
60222: PUSH
60223: LD_VAR 0 5
60227: PPUSH
60228: LD_INT 91
60230: PUSH
60231: LD_VAR 0 4
60235: PUSH
60236: LD_INT 8
60238: PUSH
60239: EMPTY
60240: LIST
60241: LIST
60242: LIST
60243: PPUSH
60244: CALL_OW 72
60248: ST_TO_ADDR
// if nearEnemy then
60249: LD_VAR 0 6
60253: IFFALSE 60322
// begin if GetWeapon ( i ) = ru_time_lapser then
60255: LD_VAR 0 4
60259: PPUSH
60260: CALL_OW 264
60264: PUSH
60265: LD_INT 49
60267: EQUAL
60268: IFFALSE 60296
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
60270: LD_VAR 0 4
60274: PPUSH
60275: LD_VAR 0 6
60279: PPUSH
60280: LD_VAR 0 4
60284: PPUSH
60285: CALL_OW 74
60289: PPUSH
60290: CALL_OW 112
60294: GO 60320
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
60296: LD_VAR 0 4
60300: PPUSH
60301: LD_VAR 0 6
60305: PPUSH
60306: LD_VAR 0 4
60310: PPUSH
60311: CALL_OW 74
60315: PPUSH
60316: CALL_OW 115
// end else
60320: GO 60422
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
60322: LD_VAR 0 4
60326: PPUSH
60327: LD_VAR 0 2
60331: PUSH
60332: LD_VAR 0 9
60336: ARRAY
60337: PUSH
60338: LD_INT 1
60340: ARRAY
60341: PPUSH
60342: LD_VAR 0 2
60346: PUSH
60347: LD_VAR 0 9
60351: ARRAY
60352: PUSH
60353: LD_INT 2
60355: ARRAY
60356: PPUSH
60357: CALL_OW 297
60361: PUSH
60362: LD_INT 6
60364: GREATER
60365: IFFALSE 60408
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
60367: LD_VAR 0 4
60371: PPUSH
60372: LD_VAR 0 2
60376: PUSH
60377: LD_VAR 0 9
60381: ARRAY
60382: PUSH
60383: LD_INT 1
60385: ARRAY
60386: PPUSH
60387: LD_VAR 0 2
60391: PUSH
60392: LD_VAR 0 9
60396: ARRAY
60397: PUSH
60398: LD_INT 2
60400: ARRAY
60401: PPUSH
60402: CALL_OW 114
60406: GO 60422
// SetTag ( i , tag ) ;
60408: LD_VAR 0 4
60412: PPUSH
60413: LD_VAR 0 9
60417: PPUSH
60418: CALL_OW 109
// end else
60422: GO 60495
// if enemy then
60424: LD_VAR 0 5
60428: IFFALSE 60495
// begin if GetWeapon ( i ) = ru_time_lapser then
60430: LD_VAR 0 4
60434: PPUSH
60435: CALL_OW 264
60439: PUSH
60440: LD_INT 49
60442: EQUAL
60443: IFFALSE 60471
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60445: LD_VAR 0 4
60449: PPUSH
60450: LD_VAR 0 5
60454: PPUSH
60455: LD_VAR 0 4
60459: PPUSH
60460: CALL_OW 74
60464: PPUSH
60465: CALL_OW 112
60469: GO 60495
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
60471: LD_VAR 0 4
60475: PPUSH
60476: LD_VAR 0 5
60480: PPUSH
60481: LD_VAR 0 4
60485: PPUSH
60486: CALL_OW 74
60490: PPUSH
60491: CALL_OW 115
// end ; end ;
60495: GO 60075
60497: POP
60498: POP
// end ;
60499: LD_VAR 0 3
60503: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
60504: LD_INT 0
60506: PPUSH
60507: PPUSH
60508: PPUSH
// if not unit or IsInUnit ( unit ) then
60509: LD_VAR 0 1
60513: NOT
60514: PUSH
60515: LD_VAR 0 1
60519: PPUSH
60520: CALL_OW 310
60524: OR
60525: IFFALSE 60529
// exit ;
60527: GO 60620
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
60529: LD_ADDR_VAR 0 4
60533: PUSH
60534: LD_VAR 0 1
60538: PPUSH
60539: CALL_OW 250
60543: PPUSH
60544: LD_VAR 0 2
60548: PPUSH
60549: LD_INT 1
60551: PPUSH
60552: CALL_OW 272
60556: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
60557: LD_ADDR_VAR 0 5
60561: PUSH
60562: LD_VAR 0 1
60566: PPUSH
60567: CALL_OW 251
60571: PPUSH
60572: LD_VAR 0 2
60576: PPUSH
60577: LD_INT 1
60579: PPUSH
60580: CALL_OW 273
60584: ST_TO_ADDR
// if ValidHex ( x , y ) then
60585: LD_VAR 0 4
60589: PPUSH
60590: LD_VAR 0 5
60594: PPUSH
60595: CALL_OW 488
60599: IFFALSE 60620
// ComTurnXY ( unit , x , y ) ;
60601: LD_VAR 0 1
60605: PPUSH
60606: LD_VAR 0 4
60610: PPUSH
60611: LD_VAR 0 5
60615: PPUSH
60616: CALL_OW 118
// end ;
60620: LD_VAR 0 3
60624: RET
// export function SeeUnits ( side , units ) ; var i ; begin
60625: LD_INT 0
60627: PPUSH
60628: PPUSH
// result := false ;
60629: LD_ADDR_VAR 0 3
60633: PUSH
60634: LD_INT 0
60636: ST_TO_ADDR
// if not units then
60637: LD_VAR 0 2
60641: NOT
60642: IFFALSE 60646
// exit ;
60644: GO 60691
// for i in units do
60646: LD_ADDR_VAR 0 4
60650: PUSH
60651: LD_VAR 0 2
60655: PUSH
60656: FOR_IN
60657: IFFALSE 60689
// if See ( side , i ) then
60659: LD_VAR 0 1
60663: PPUSH
60664: LD_VAR 0 4
60668: PPUSH
60669: CALL_OW 292
60673: IFFALSE 60687
// begin result := true ;
60675: LD_ADDR_VAR 0 3
60679: PUSH
60680: LD_INT 1
60682: ST_TO_ADDR
// exit ;
60683: POP
60684: POP
60685: GO 60691
// end ;
60687: GO 60656
60689: POP
60690: POP
// end ;
60691: LD_VAR 0 3
60695: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60696: LD_INT 0
60698: PPUSH
60699: PPUSH
60700: PPUSH
60701: PPUSH
// if not unit or not points then
60702: LD_VAR 0 1
60706: NOT
60707: PUSH
60708: LD_VAR 0 2
60712: NOT
60713: OR
60714: IFFALSE 60718
// exit ;
60716: GO 60808
// dist := 99999 ;
60718: LD_ADDR_VAR 0 5
60722: PUSH
60723: LD_INT 99999
60725: ST_TO_ADDR
// for i in points do
60726: LD_ADDR_VAR 0 4
60730: PUSH
60731: LD_VAR 0 2
60735: PUSH
60736: FOR_IN
60737: IFFALSE 60806
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60739: LD_ADDR_VAR 0 6
60743: PUSH
60744: LD_VAR 0 1
60748: PPUSH
60749: LD_VAR 0 4
60753: PUSH
60754: LD_INT 1
60756: ARRAY
60757: PPUSH
60758: LD_VAR 0 4
60762: PUSH
60763: LD_INT 2
60765: ARRAY
60766: PPUSH
60767: CALL_OW 297
60771: ST_TO_ADDR
// if tmpDist < dist then
60772: LD_VAR 0 6
60776: PUSH
60777: LD_VAR 0 5
60781: LESS
60782: IFFALSE 60804
// begin result := i ;
60784: LD_ADDR_VAR 0 3
60788: PUSH
60789: LD_VAR 0 4
60793: ST_TO_ADDR
// dist := tmpDist ;
60794: LD_ADDR_VAR 0 5
60798: PUSH
60799: LD_VAR 0 6
60803: ST_TO_ADDR
// end ; end ;
60804: GO 60736
60806: POP
60807: POP
// end ;
60808: LD_VAR 0 3
60812: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60813: LD_INT 0
60815: PPUSH
// uc_side := side ;
60816: LD_ADDR_OWVAR 20
60820: PUSH
60821: LD_VAR 0 1
60825: ST_TO_ADDR
// uc_nation := 3 ;
60826: LD_ADDR_OWVAR 21
60830: PUSH
60831: LD_INT 3
60833: ST_TO_ADDR
// vc_chassis := 25 ;
60834: LD_ADDR_OWVAR 37
60838: PUSH
60839: LD_INT 25
60841: ST_TO_ADDR
// vc_engine := engine_siberite ;
60842: LD_ADDR_OWVAR 39
60846: PUSH
60847: LD_INT 3
60849: ST_TO_ADDR
// vc_control := control_computer ;
60850: LD_ADDR_OWVAR 38
60854: PUSH
60855: LD_INT 3
60857: ST_TO_ADDR
// vc_weapon := 59 ;
60858: LD_ADDR_OWVAR 40
60862: PUSH
60863: LD_INT 59
60865: ST_TO_ADDR
// result := CreateVehicle ;
60866: LD_ADDR_VAR 0 5
60870: PUSH
60871: CALL_OW 45
60875: ST_TO_ADDR
// SetDir ( result , d ) ;
60876: LD_VAR 0 5
60880: PPUSH
60881: LD_VAR 0 4
60885: PPUSH
60886: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60890: LD_VAR 0 5
60894: PPUSH
60895: LD_VAR 0 2
60899: PPUSH
60900: LD_VAR 0 3
60904: PPUSH
60905: LD_INT 0
60907: PPUSH
60908: CALL_OW 48
// end ;
60912: LD_VAR 0 5
60916: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60917: LD_INT 0
60919: PPUSH
60920: PPUSH
60921: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60922: LD_ADDR_VAR 0 2
60926: PUSH
60927: LD_INT 0
60929: PUSH
60930: LD_INT 0
60932: PUSH
60933: LD_INT 0
60935: PUSH
60936: LD_INT 0
60938: PUSH
60939: EMPTY
60940: LIST
60941: LIST
60942: LIST
60943: LIST
60944: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60945: LD_VAR 0 1
60949: NOT
60950: PUSH
60951: LD_VAR 0 1
60955: PPUSH
60956: CALL_OW 264
60960: PUSH
60961: LD_INT 12
60963: PUSH
60964: LD_INT 51
60966: PUSH
60967: LD_INT 32
60969: PUSH
60970: LD_INT 89
60972: PUSH
60973: EMPTY
60974: LIST
60975: LIST
60976: LIST
60977: LIST
60978: IN
60979: NOT
60980: OR
60981: IFFALSE 60985
// exit ;
60983: GO 61083
// for i := 1 to 3 do
60985: LD_ADDR_VAR 0 3
60989: PUSH
60990: DOUBLE
60991: LD_INT 1
60993: DEC
60994: ST_TO_ADDR
60995: LD_INT 3
60997: PUSH
60998: FOR_TO
60999: IFFALSE 61081
// begin tmp := GetCargo ( cargo , i ) ;
61001: LD_ADDR_VAR 0 4
61005: PUSH
61006: LD_VAR 0 1
61010: PPUSH
61011: LD_VAR 0 3
61015: PPUSH
61016: CALL_OW 289
61020: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
61021: LD_ADDR_VAR 0 2
61025: PUSH
61026: LD_VAR 0 2
61030: PPUSH
61031: LD_VAR 0 3
61035: PPUSH
61036: LD_VAR 0 4
61040: PPUSH
61041: CALL_OW 1
61045: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
61046: LD_ADDR_VAR 0 2
61050: PUSH
61051: LD_VAR 0 2
61055: PPUSH
61056: LD_INT 4
61058: PPUSH
61059: LD_VAR 0 2
61063: PUSH
61064: LD_INT 4
61066: ARRAY
61067: PUSH
61068: LD_VAR 0 4
61072: PLUS
61073: PPUSH
61074: CALL_OW 1
61078: ST_TO_ADDR
// end ;
61079: GO 60998
61081: POP
61082: POP
// end ;
61083: LD_VAR 0 2
61087: RET
// export function Length ( array ) ; begin
61088: LD_INT 0
61090: PPUSH
// result := array + 0 ;
61091: LD_ADDR_VAR 0 2
61095: PUSH
61096: LD_VAR 0 1
61100: PUSH
61101: LD_INT 0
61103: PLUS
61104: ST_TO_ADDR
// end ;
61105: LD_VAR 0 2
61109: RET
// export function PrepareArray ( array ) ; begin
61110: LD_INT 0
61112: PPUSH
// result := array diff 0 ;
61113: LD_ADDR_VAR 0 2
61117: PUSH
61118: LD_VAR 0 1
61122: PUSH
61123: LD_INT 0
61125: DIFF
61126: ST_TO_ADDR
// if not result [ 1 ] then
61127: LD_VAR 0 2
61131: PUSH
61132: LD_INT 1
61134: ARRAY
61135: NOT
61136: IFFALSE 61156
// result := Delete ( result , 1 ) ;
61138: LD_ADDR_VAR 0 2
61142: PUSH
61143: LD_VAR 0 2
61147: PPUSH
61148: LD_INT 1
61150: PPUSH
61151: CALL_OW 3
61155: ST_TO_ADDR
// end ;
61156: LD_VAR 0 2
61160: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
61161: LD_INT 0
61163: PPUSH
61164: PPUSH
61165: PPUSH
61166: PPUSH
// sibRocketRange := 25 ;
61167: LD_ADDR_VAR 0 6
61171: PUSH
61172: LD_INT 25
61174: ST_TO_ADDR
// result := false ;
61175: LD_ADDR_VAR 0 4
61179: PUSH
61180: LD_INT 0
61182: ST_TO_ADDR
// for i := 0 to 5 do
61183: LD_ADDR_VAR 0 5
61187: PUSH
61188: DOUBLE
61189: LD_INT 0
61191: DEC
61192: ST_TO_ADDR
61193: LD_INT 5
61195: PUSH
61196: FOR_TO
61197: IFFALSE 61264
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
61199: LD_VAR 0 1
61203: PPUSH
61204: LD_VAR 0 5
61208: PPUSH
61209: LD_VAR 0 6
61213: PPUSH
61214: CALL_OW 272
61218: PPUSH
61219: LD_VAR 0 2
61223: PPUSH
61224: LD_VAR 0 5
61228: PPUSH
61229: LD_VAR 0 6
61233: PPUSH
61234: CALL_OW 273
61238: PPUSH
61239: LD_VAR 0 3
61243: PPUSH
61244: CALL_OW 309
61248: IFFALSE 61262
// begin result := true ;
61250: LD_ADDR_VAR 0 4
61254: PUSH
61255: LD_INT 1
61257: ST_TO_ADDR
// exit ;
61258: POP
61259: POP
61260: GO 61266
// end ;
61262: GO 61196
61264: POP
61265: POP
// end ;
61266: LD_VAR 0 4
61270: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
61271: LD_INT 0
61273: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
61274: LD_VAR 0 1
61278: PPUSH
61279: LD_VAR 0 2
61283: PPUSH
61284: LD_INT 0
61286: PPUSH
61287: LD_INT 0
61289: PPUSH
61290: LD_INT 1
61292: PPUSH
61293: LD_INT 0
61295: PPUSH
61296: CALL_OW 587
// end ; end_of_file
61300: LD_VAR 0 3
61304: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
61305: LD_INT 0
61307: PPUSH
61308: PPUSH
// skirmish := false ;
61309: LD_ADDR_EXP 29
61313: PUSH
61314: LD_INT 0
61316: ST_TO_ADDR
// debug_mc := false ;
61317: LD_ADDR_EXP 30
61321: PUSH
61322: LD_INT 0
61324: ST_TO_ADDR
// mc_bases := [ ] ;
61325: LD_ADDR_EXP 31
61329: PUSH
61330: EMPTY
61331: ST_TO_ADDR
// mc_sides := [ ] ;
61332: LD_ADDR_EXP 57
61336: PUSH
61337: EMPTY
61338: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61339: LD_ADDR_EXP 32
61343: PUSH
61344: EMPTY
61345: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61346: LD_ADDR_EXP 33
61350: PUSH
61351: EMPTY
61352: ST_TO_ADDR
// mc_need_heal := [ ] ;
61353: LD_ADDR_EXP 34
61357: PUSH
61358: EMPTY
61359: ST_TO_ADDR
// mc_healers := [ ] ;
61360: LD_ADDR_EXP 35
61364: PUSH
61365: EMPTY
61366: ST_TO_ADDR
// mc_build_list := [ ] ;
61367: LD_ADDR_EXP 36
61371: PUSH
61372: EMPTY
61373: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61374: LD_ADDR_EXP 63
61378: PUSH
61379: EMPTY
61380: ST_TO_ADDR
// mc_builders := [ ] ;
61381: LD_ADDR_EXP 37
61385: PUSH
61386: EMPTY
61387: ST_TO_ADDR
// mc_construct_list := [ ] ;
61388: LD_ADDR_EXP 38
61392: PUSH
61393: EMPTY
61394: ST_TO_ADDR
// mc_turret_list := [ ] ;
61395: LD_ADDR_EXP 39
61399: PUSH
61400: EMPTY
61401: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61402: LD_ADDR_EXP 40
61406: PUSH
61407: EMPTY
61408: ST_TO_ADDR
// mc_miners := [ ] ;
61409: LD_ADDR_EXP 45
61413: PUSH
61414: EMPTY
61415: ST_TO_ADDR
// mc_mines := [ ] ;
61416: LD_ADDR_EXP 44
61420: PUSH
61421: EMPTY
61422: ST_TO_ADDR
// mc_minefields := [ ] ;
61423: LD_ADDR_EXP 46
61427: PUSH
61428: EMPTY
61429: ST_TO_ADDR
// mc_crates := [ ] ;
61430: LD_ADDR_EXP 47
61434: PUSH
61435: EMPTY
61436: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61437: LD_ADDR_EXP 48
61441: PUSH
61442: EMPTY
61443: ST_TO_ADDR
// mc_crates_area := [ ] ;
61444: LD_ADDR_EXP 49
61448: PUSH
61449: EMPTY
61450: ST_TO_ADDR
// mc_vehicles := [ ] ;
61451: LD_ADDR_EXP 50
61455: PUSH
61456: EMPTY
61457: ST_TO_ADDR
// mc_attack := [ ] ;
61458: LD_ADDR_EXP 51
61462: PUSH
61463: EMPTY
61464: ST_TO_ADDR
// mc_produce := [ ] ;
61465: LD_ADDR_EXP 52
61469: PUSH
61470: EMPTY
61471: ST_TO_ADDR
// mc_defender := [ ] ;
61472: LD_ADDR_EXP 53
61476: PUSH
61477: EMPTY
61478: ST_TO_ADDR
// mc_parking := [ ] ;
61479: LD_ADDR_EXP 55
61483: PUSH
61484: EMPTY
61485: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61486: LD_ADDR_EXP 41
61490: PUSH
61491: EMPTY
61492: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61493: LD_ADDR_EXP 43
61497: PUSH
61498: EMPTY
61499: ST_TO_ADDR
// mc_scan := [ ] ;
61500: LD_ADDR_EXP 54
61504: PUSH
61505: EMPTY
61506: ST_TO_ADDR
// mc_scan_area := [ ] ;
61507: LD_ADDR_EXP 56
61511: PUSH
61512: EMPTY
61513: ST_TO_ADDR
// mc_tech := [ ] ;
61514: LD_ADDR_EXP 58
61518: PUSH
61519: EMPTY
61520: ST_TO_ADDR
// mc_class := [ ] ;
61521: LD_ADDR_EXP 72
61525: PUSH
61526: EMPTY
61527: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61528: LD_ADDR_EXP 73
61532: PUSH
61533: EMPTY
61534: ST_TO_ADDR
// mc_is_defending := [ ] ;
61535: LD_ADDR_EXP 74
61539: PUSH
61540: EMPTY
61541: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
61542: LD_ADDR_EXP 65
61546: PUSH
61547: EMPTY
61548: ST_TO_ADDR
// end ;
61549: LD_VAR 0 1
61553: RET
// export function MC_Kill ( base ) ; begin
61554: LD_INT 0
61556: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61557: LD_ADDR_EXP 31
61561: PUSH
61562: LD_EXP 31
61566: PPUSH
61567: LD_VAR 0 1
61571: PPUSH
61572: EMPTY
61573: PPUSH
61574: CALL_OW 1
61578: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61579: LD_ADDR_EXP 32
61583: PUSH
61584: LD_EXP 32
61588: PPUSH
61589: LD_VAR 0 1
61593: PPUSH
61594: EMPTY
61595: PPUSH
61596: CALL_OW 1
61600: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61601: LD_ADDR_EXP 33
61605: PUSH
61606: LD_EXP 33
61610: PPUSH
61611: LD_VAR 0 1
61615: PPUSH
61616: EMPTY
61617: PPUSH
61618: CALL_OW 1
61622: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61623: LD_ADDR_EXP 34
61627: PUSH
61628: LD_EXP 34
61632: PPUSH
61633: LD_VAR 0 1
61637: PPUSH
61638: EMPTY
61639: PPUSH
61640: CALL_OW 1
61644: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61645: LD_ADDR_EXP 35
61649: PUSH
61650: LD_EXP 35
61654: PPUSH
61655: LD_VAR 0 1
61659: PPUSH
61660: EMPTY
61661: PPUSH
61662: CALL_OW 1
61666: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61667: LD_ADDR_EXP 36
61671: PUSH
61672: LD_EXP 36
61676: PPUSH
61677: LD_VAR 0 1
61681: PPUSH
61682: EMPTY
61683: PPUSH
61684: CALL_OW 1
61688: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61689: LD_ADDR_EXP 37
61693: PUSH
61694: LD_EXP 37
61698: PPUSH
61699: LD_VAR 0 1
61703: PPUSH
61704: EMPTY
61705: PPUSH
61706: CALL_OW 1
61710: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61711: LD_ADDR_EXP 38
61715: PUSH
61716: LD_EXP 38
61720: PPUSH
61721: LD_VAR 0 1
61725: PPUSH
61726: EMPTY
61727: PPUSH
61728: CALL_OW 1
61732: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61733: LD_ADDR_EXP 39
61737: PUSH
61738: LD_EXP 39
61742: PPUSH
61743: LD_VAR 0 1
61747: PPUSH
61748: EMPTY
61749: PPUSH
61750: CALL_OW 1
61754: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61755: LD_ADDR_EXP 40
61759: PUSH
61760: LD_EXP 40
61764: PPUSH
61765: LD_VAR 0 1
61769: PPUSH
61770: EMPTY
61771: PPUSH
61772: CALL_OW 1
61776: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61777: LD_ADDR_EXP 41
61781: PUSH
61782: LD_EXP 41
61786: PPUSH
61787: LD_VAR 0 1
61791: PPUSH
61792: EMPTY
61793: PPUSH
61794: CALL_OW 1
61798: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61799: LD_ADDR_EXP 42
61803: PUSH
61804: LD_EXP 42
61808: PPUSH
61809: LD_VAR 0 1
61813: PPUSH
61814: LD_INT 0
61816: PPUSH
61817: CALL_OW 1
61821: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61822: LD_ADDR_EXP 43
61826: PUSH
61827: LD_EXP 43
61831: PPUSH
61832: LD_VAR 0 1
61836: PPUSH
61837: EMPTY
61838: PPUSH
61839: CALL_OW 1
61843: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61844: LD_ADDR_EXP 44
61848: PUSH
61849: LD_EXP 44
61853: PPUSH
61854: LD_VAR 0 1
61858: PPUSH
61859: EMPTY
61860: PPUSH
61861: CALL_OW 1
61865: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61866: LD_ADDR_EXP 45
61870: PUSH
61871: LD_EXP 45
61875: PPUSH
61876: LD_VAR 0 1
61880: PPUSH
61881: EMPTY
61882: PPUSH
61883: CALL_OW 1
61887: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61888: LD_ADDR_EXP 46
61892: PUSH
61893: LD_EXP 46
61897: PPUSH
61898: LD_VAR 0 1
61902: PPUSH
61903: EMPTY
61904: PPUSH
61905: CALL_OW 1
61909: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61910: LD_ADDR_EXP 47
61914: PUSH
61915: LD_EXP 47
61919: PPUSH
61920: LD_VAR 0 1
61924: PPUSH
61925: EMPTY
61926: PPUSH
61927: CALL_OW 1
61931: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61932: LD_ADDR_EXP 48
61936: PUSH
61937: LD_EXP 48
61941: PPUSH
61942: LD_VAR 0 1
61946: PPUSH
61947: EMPTY
61948: PPUSH
61949: CALL_OW 1
61953: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61954: LD_ADDR_EXP 49
61958: PUSH
61959: LD_EXP 49
61963: PPUSH
61964: LD_VAR 0 1
61968: PPUSH
61969: EMPTY
61970: PPUSH
61971: CALL_OW 1
61975: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61976: LD_ADDR_EXP 50
61980: PUSH
61981: LD_EXP 50
61985: PPUSH
61986: LD_VAR 0 1
61990: PPUSH
61991: EMPTY
61992: PPUSH
61993: CALL_OW 1
61997: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61998: LD_ADDR_EXP 51
62002: PUSH
62003: LD_EXP 51
62007: PPUSH
62008: LD_VAR 0 1
62012: PPUSH
62013: EMPTY
62014: PPUSH
62015: CALL_OW 1
62019: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62020: LD_ADDR_EXP 52
62024: PUSH
62025: LD_EXP 52
62029: PPUSH
62030: LD_VAR 0 1
62034: PPUSH
62035: EMPTY
62036: PPUSH
62037: CALL_OW 1
62041: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62042: LD_ADDR_EXP 53
62046: PUSH
62047: LD_EXP 53
62051: PPUSH
62052: LD_VAR 0 1
62056: PPUSH
62057: EMPTY
62058: PPUSH
62059: CALL_OW 1
62063: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62064: LD_ADDR_EXP 54
62068: PUSH
62069: LD_EXP 54
62073: PPUSH
62074: LD_VAR 0 1
62078: PPUSH
62079: EMPTY
62080: PPUSH
62081: CALL_OW 1
62085: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62086: LD_ADDR_EXP 55
62090: PUSH
62091: LD_EXP 55
62095: PPUSH
62096: LD_VAR 0 1
62100: PPUSH
62101: EMPTY
62102: PPUSH
62103: CALL_OW 1
62107: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62108: LD_ADDR_EXP 56
62112: PUSH
62113: LD_EXP 56
62117: PPUSH
62118: LD_VAR 0 1
62122: PPUSH
62123: EMPTY
62124: PPUSH
62125: CALL_OW 1
62129: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62130: LD_ADDR_EXP 58
62134: PUSH
62135: LD_EXP 58
62139: PPUSH
62140: LD_VAR 0 1
62144: PPUSH
62145: EMPTY
62146: PPUSH
62147: CALL_OW 1
62151: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62152: LD_ADDR_EXP 60
62156: PUSH
62157: LD_EXP 60
62161: PPUSH
62162: LD_VAR 0 1
62166: PPUSH
62167: EMPTY
62168: PPUSH
62169: CALL_OW 1
62173: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62174: LD_ADDR_EXP 61
62178: PUSH
62179: LD_EXP 61
62183: PPUSH
62184: LD_VAR 0 1
62188: PPUSH
62189: EMPTY
62190: PPUSH
62191: CALL_OW 1
62195: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62196: LD_ADDR_EXP 62
62200: PUSH
62201: LD_EXP 62
62205: PPUSH
62206: LD_VAR 0 1
62210: PPUSH
62211: EMPTY
62212: PPUSH
62213: CALL_OW 1
62217: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62218: LD_ADDR_EXP 63
62222: PUSH
62223: LD_EXP 63
62227: PPUSH
62228: LD_VAR 0 1
62232: PPUSH
62233: EMPTY
62234: PPUSH
62235: CALL_OW 1
62239: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62240: LD_ADDR_EXP 64
62244: PUSH
62245: LD_EXP 64
62249: PPUSH
62250: LD_VAR 0 1
62254: PPUSH
62255: EMPTY
62256: PPUSH
62257: CALL_OW 1
62261: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62262: LD_ADDR_EXP 65
62266: PUSH
62267: LD_EXP 65
62271: PPUSH
62272: LD_VAR 0 1
62276: PPUSH
62277: EMPTY
62278: PPUSH
62279: CALL_OW 1
62283: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62284: LD_ADDR_EXP 66
62288: PUSH
62289: LD_EXP 66
62293: PPUSH
62294: LD_VAR 0 1
62298: PPUSH
62299: EMPTY
62300: PPUSH
62301: CALL_OW 1
62305: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62306: LD_ADDR_EXP 67
62310: PUSH
62311: LD_EXP 67
62315: PPUSH
62316: LD_VAR 0 1
62320: PPUSH
62321: EMPTY
62322: PPUSH
62323: CALL_OW 1
62327: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62328: LD_ADDR_EXP 68
62332: PUSH
62333: LD_EXP 68
62337: PPUSH
62338: LD_VAR 0 1
62342: PPUSH
62343: EMPTY
62344: PPUSH
62345: CALL_OW 1
62349: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62350: LD_ADDR_EXP 69
62354: PUSH
62355: LD_EXP 69
62359: PPUSH
62360: LD_VAR 0 1
62364: PPUSH
62365: EMPTY
62366: PPUSH
62367: CALL_OW 1
62371: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62372: LD_ADDR_EXP 70
62376: PUSH
62377: LD_EXP 70
62381: PPUSH
62382: LD_VAR 0 1
62386: PPUSH
62387: EMPTY
62388: PPUSH
62389: CALL_OW 1
62393: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62394: LD_ADDR_EXP 71
62398: PUSH
62399: LD_EXP 71
62403: PPUSH
62404: LD_VAR 0 1
62408: PPUSH
62409: EMPTY
62410: PPUSH
62411: CALL_OW 1
62415: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62416: LD_ADDR_EXP 72
62420: PUSH
62421: LD_EXP 72
62425: PPUSH
62426: LD_VAR 0 1
62430: PPUSH
62431: EMPTY
62432: PPUSH
62433: CALL_OW 1
62437: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62438: LD_ADDR_EXP 73
62442: PUSH
62443: LD_EXP 73
62447: PPUSH
62448: LD_VAR 0 1
62452: PPUSH
62453: LD_INT 0
62455: PPUSH
62456: CALL_OW 1
62460: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62461: LD_ADDR_EXP 74
62465: PUSH
62466: LD_EXP 74
62470: PPUSH
62471: LD_VAR 0 1
62475: PPUSH
62476: LD_INT 0
62478: PPUSH
62479: CALL_OW 1
62483: ST_TO_ADDR
// end ;
62484: LD_VAR 0 2
62488: RET
// export function MC_Add ( side , units ) ; var base ; begin
62489: LD_INT 0
62491: PPUSH
62492: PPUSH
// base := mc_bases + 1 ;
62493: LD_ADDR_VAR 0 4
62497: PUSH
62498: LD_EXP 31
62502: PUSH
62503: LD_INT 1
62505: PLUS
62506: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62507: LD_ADDR_EXP 57
62511: PUSH
62512: LD_EXP 57
62516: PPUSH
62517: LD_VAR 0 4
62521: PPUSH
62522: LD_VAR 0 1
62526: PPUSH
62527: CALL_OW 1
62531: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62532: LD_ADDR_EXP 31
62536: PUSH
62537: LD_EXP 31
62541: PPUSH
62542: LD_VAR 0 4
62546: PPUSH
62547: LD_VAR 0 2
62551: PPUSH
62552: CALL_OW 1
62556: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62557: LD_ADDR_EXP 32
62561: PUSH
62562: LD_EXP 32
62566: PPUSH
62567: LD_VAR 0 4
62571: PPUSH
62572: EMPTY
62573: PPUSH
62574: CALL_OW 1
62578: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62579: LD_ADDR_EXP 33
62583: PUSH
62584: LD_EXP 33
62588: PPUSH
62589: LD_VAR 0 4
62593: PPUSH
62594: EMPTY
62595: PPUSH
62596: CALL_OW 1
62600: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62601: LD_ADDR_EXP 34
62605: PUSH
62606: LD_EXP 34
62610: PPUSH
62611: LD_VAR 0 4
62615: PPUSH
62616: EMPTY
62617: PPUSH
62618: CALL_OW 1
62622: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62623: LD_ADDR_EXP 35
62627: PUSH
62628: LD_EXP 35
62632: PPUSH
62633: LD_VAR 0 4
62637: PPUSH
62638: EMPTY
62639: PPUSH
62640: CALL_OW 1
62644: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62645: LD_ADDR_EXP 36
62649: PUSH
62650: LD_EXP 36
62654: PPUSH
62655: LD_VAR 0 4
62659: PPUSH
62660: EMPTY
62661: PPUSH
62662: CALL_OW 1
62666: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62667: LD_ADDR_EXP 37
62671: PUSH
62672: LD_EXP 37
62676: PPUSH
62677: LD_VAR 0 4
62681: PPUSH
62682: EMPTY
62683: PPUSH
62684: CALL_OW 1
62688: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62689: LD_ADDR_EXP 38
62693: PUSH
62694: LD_EXP 38
62698: PPUSH
62699: LD_VAR 0 4
62703: PPUSH
62704: EMPTY
62705: PPUSH
62706: CALL_OW 1
62710: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62711: LD_ADDR_EXP 39
62715: PUSH
62716: LD_EXP 39
62720: PPUSH
62721: LD_VAR 0 4
62725: PPUSH
62726: EMPTY
62727: PPUSH
62728: CALL_OW 1
62732: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62733: LD_ADDR_EXP 40
62737: PUSH
62738: LD_EXP 40
62742: PPUSH
62743: LD_VAR 0 4
62747: PPUSH
62748: EMPTY
62749: PPUSH
62750: CALL_OW 1
62754: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62755: LD_ADDR_EXP 41
62759: PUSH
62760: LD_EXP 41
62764: PPUSH
62765: LD_VAR 0 4
62769: PPUSH
62770: EMPTY
62771: PPUSH
62772: CALL_OW 1
62776: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62777: LD_ADDR_EXP 42
62781: PUSH
62782: LD_EXP 42
62786: PPUSH
62787: LD_VAR 0 4
62791: PPUSH
62792: LD_INT 0
62794: PPUSH
62795: CALL_OW 1
62799: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62800: LD_ADDR_EXP 43
62804: PUSH
62805: LD_EXP 43
62809: PPUSH
62810: LD_VAR 0 4
62814: PPUSH
62815: EMPTY
62816: PPUSH
62817: CALL_OW 1
62821: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62822: LD_ADDR_EXP 44
62826: PUSH
62827: LD_EXP 44
62831: PPUSH
62832: LD_VAR 0 4
62836: PPUSH
62837: EMPTY
62838: PPUSH
62839: CALL_OW 1
62843: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62844: LD_ADDR_EXP 45
62848: PUSH
62849: LD_EXP 45
62853: PPUSH
62854: LD_VAR 0 4
62858: PPUSH
62859: EMPTY
62860: PPUSH
62861: CALL_OW 1
62865: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62866: LD_ADDR_EXP 46
62870: PUSH
62871: LD_EXP 46
62875: PPUSH
62876: LD_VAR 0 4
62880: PPUSH
62881: EMPTY
62882: PPUSH
62883: CALL_OW 1
62887: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62888: LD_ADDR_EXP 47
62892: PUSH
62893: LD_EXP 47
62897: PPUSH
62898: LD_VAR 0 4
62902: PPUSH
62903: EMPTY
62904: PPUSH
62905: CALL_OW 1
62909: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62910: LD_ADDR_EXP 48
62914: PUSH
62915: LD_EXP 48
62919: PPUSH
62920: LD_VAR 0 4
62924: PPUSH
62925: EMPTY
62926: PPUSH
62927: CALL_OW 1
62931: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62932: LD_ADDR_EXP 49
62936: PUSH
62937: LD_EXP 49
62941: PPUSH
62942: LD_VAR 0 4
62946: PPUSH
62947: EMPTY
62948: PPUSH
62949: CALL_OW 1
62953: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62954: LD_ADDR_EXP 50
62958: PUSH
62959: LD_EXP 50
62963: PPUSH
62964: LD_VAR 0 4
62968: PPUSH
62969: EMPTY
62970: PPUSH
62971: CALL_OW 1
62975: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62976: LD_ADDR_EXP 51
62980: PUSH
62981: LD_EXP 51
62985: PPUSH
62986: LD_VAR 0 4
62990: PPUSH
62991: EMPTY
62992: PPUSH
62993: CALL_OW 1
62997: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62998: LD_ADDR_EXP 52
63002: PUSH
63003: LD_EXP 52
63007: PPUSH
63008: LD_VAR 0 4
63012: PPUSH
63013: EMPTY
63014: PPUSH
63015: CALL_OW 1
63019: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
63020: LD_ADDR_EXP 53
63024: PUSH
63025: LD_EXP 53
63029: PPUSH
63030: LD_VAR 0 4
63034: PPUSH
63035: EMPTY
63036: PPUSH
63037: CALL_OW 1
63041: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
63042: LD_ADDR_EXP 54
63046: PUSH
63047: LD_EXP 54
63051: PPUSH
63052: LD_VAR 0 4
63056: PPUSH
63057: EMPTY
63058: PPUSH
63059: CALL_OW 1
63063: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63064: LD_ADDR_EXP 55
63068: PUSH
63069: LD_EXP 55
63073: PPUSH
63074: LD_VAR 0 4
63078: PPUSH
63079: EMPTY
63080: PPUSH
63081: CALL_OW 1
63085: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63086: LD_ADDR_EXP 56
63090: PUSH
63091: LD_EXP 56
63095: PPUSH
63096: LD_VAR 0 4
63100: PPUSH
63101: EMPTY
63102: PPUSH
63103: CALL_OW 1
63107: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63108: LD_ADDR_EXP 58
63112: PUSH
63113: LD_EXP 58
63117: PPUSH
63118: LD_VAR 0 4
63122: PPUSH
63123: EMPTY
63124: PPUSH
63125: CALL_OW 1
63129: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63130: LD_ADDR_EXP 60
63134: PUSH
63135: LD_EXP 60
63139: PPUSH
63140: LD_VAR 0 4
63144: PPUSH
63145: EMPTY
63146: PPUSH
63147: CALL_OW 1
63151: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63152: LD_ADDR_EXP 61
63156: PUSH
63157: LD_EXP 61
63161: PPUSH
63162: LD_VAR 0 4
63166: PPUSH
63167: EMPTY
63168: PPUSH
63169: CALL_OW 1
63173: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63174: LD_ADDR_EXP 62
63178: PUSH
63179: LD_EXP 62
63183: PPUSH
63184: LD_VAR 0 4
63188: PPUSH
63189: EMPTY
63190: PPUSH
63191: CALL_OW 1
63195: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63196: LD_ADDR_EXP 63
63200: PUSH
63201: LD_EXP 63
63205: PPUSH
63206: LD_VAR 0 4
63210: PPUSH
63211: EMPTY
63212: PPUSH
63213: CALL_OW 1
63217: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63218: LD_ADDR_EXP 64
63222: PUSH
63223: LD_EXP 64
63227: PPUSH
63228: LD_VAR 0 4
63232: PPUSH
63233: EMPTY
63234: PPUSH
63235: CALL_OW 1
63239: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63240: LD_ADDR_EXP 65
63244: PUSH
63245: LD_EXP 65
63249: PPUSH
63250: LD_VAR 0 4
63254: PPUSH
63255: EMPTY
63256: PPUSH
63257: CALL_OW 1
63261: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63262: LD_ADDR_EXP 66
63266: PUSH
63267: LD_EXP 66
63271: PPUSH
63272: LD_VAR 0 4
63276: PPUSH
63277: EMPTY
63278: PPUSH
63279: CALL_OW 1
63283: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63284: LD_ADDR_EXP 67
63288: PUSH
63289: LD_EXP 67
63293: PPUSH
63294: LD_VAR 0 4
63298: PPUSH
63299: EMPTY
63300: PPUSH
63301: CALL_OW 1
63305: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63306: LD_ADDR_EXP 68
63310: PUSH
63311: LD_EXP 68
63315: PPUSH
63316: LD_VAR 0 4
63320: PPUSH
63321: EMPTY
63322: PPUSH
63323: CALL_OW 1
63327: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63328: LD_ADDR_EXP 69
63332: PUSH
63333: LD_EXP 69
63337: PPUSH
63338: LD_VAR 0 4
63342: PPUSH
63343: EMPTY
63344: PPUSH
63345: CALL_OW 1
63349: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63350: LD_ADDR_EXP 70
63354: PUSH
63355: LD_EXP 70
63359: PPUSH
63360: LD_VAR 0 4
63364: PPUSH
63365: EMPTY
63366: PPUSH
63367: CALL_OW 1
63371: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63372: LD_ADDR_EXP 71
63376: PUSH
63377: LD_EXP 71
63381: PPUSH
63382: LD_VAR 0 4
63386: PPUSH
63387: EMPTY
63388: PPUSH
63389: CALL_OW 1
63393: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63394: LD_ADDR_EXP 72
63398: PUSH
63399: LD_EXP 72
63403: PPUSH
63404: LD_VAR 0 4
63408: PPUSH
63409: EMPTY
63410: PPUSH
63411: CALL_OW 1
63415: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63416: LD_ADDR_EXP 73
63420: PUSH
63421: LD_EXP 73
63425: PPUSH
63426: LD_VAR 0 4
63430: PPUSH
63431: LD_INT 0
63433: PPUSH
63434: CALL_OW 1
63438: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63439: LD_ADDR_EXP 74
63443: PUSH
63444: LD_EXP 74
63448: PPUSH
63449: LD_VAR 0 4
63453: PPUSH
63454: LD_INT 0
63456: PPUSH
63457: CALL_OW 1
63461: ST_TO_ADDR
// result := base ;
63462: LD_ADDR_VAR 0 3
63466: PUSH
63467: LD_VAR 0 4
63471: ST_TO_ADDR
// end ;
63472: LD_VAR 0 3
63476: RET
// export function MC_Start ( ) ; var i ; begin
63477: LD_INT 0
63479: PPUSH
63480: PPUSH
// for i = 1 to mc_bases do
63481: LD_ADDR_VAR 0 2
63485: PUSH
63486: DOUBLE
63487: LD_INT 1
63489: DEC
63490: ST_TO_ADDR
63491: LD_EXP 31
63495: PUSH
63496: FOR_TO
63497: IFFALSE 64597
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63499: LD_ADDR_EXP 31
63503: PUSH
63504: LD_EXP 31
63508: PPUSH
63509: LD_VAR 0 2
63513: PPUSH
63514: LD_EXP 31
63518: PUSH
63519: LD_VAR 0 2
63523: ARRAY
63524: PUSH
63525: LD_INT 0
63527: DIFF
63528: PPUSH
63529: CALL_OW 1
63533: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63534: LD_ADDR_EXP 32
63538: PUSH
63539: LD_EXP 32
63543: PPUSH
63544: LD_VAR 0 2
63548: PPUSH
63549: EMPTY
63550: PPUSH
63551: CALL_OW 1
63555: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63556: LD_ADDR_EXP 33
63560: PUSH
63561: LD_EXP 33
63565: PPUSH
63566: LD_VAR 0 2
63570: PPUSH
63571: EMPTY
63572: PPUSH
63573: CALL_OW 1
63577: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63578: LD_ADDR_EXP 34
63582: PUSH
63583: LD_EXP 34
63587: PPUSH
63588: LD_VAR 0 2
63592: PPUSH
63593: EMPTY
63594: PPUSH
63595: CALL_OW 1
63599: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63600: LD_ADDR_EXP 35
63604: PUSH
63605: LD_EXP 35
63609: PPUSH
63610: LD_VAR 0 2
63614: PPUSH
63615: EMPTY
63616: PUSH
63617: EMPTY
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: PPUSH
63623: CALL_OW 1
63627: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63628: LD_ADDR_EXP 36
63632: PUSH
63633: LD_EXP 36
63637: PPUSH
63638: LD_VAR 0 2
63642: PPUSH
63643: EMPTY
63644: PPUSH
63645: CALL_OW 1
63649: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63650: LD_ADDR_EXP 63
63654: PUSH
63655: LD_EXP 63
63659: PPUSH
63660: LD_VAR 0 2
63664: PPUSH
63665: EMPTY
63666: PPUSH
63667: CALL_OW 1
63671: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63672: LD_ADDR_EXP 37
63676: PUSH
63677: LD_EXP 37
63681: PPUSH
63682: LD_VAR 0 2
63686: PPUSH
63687: EMPTY
63688: PPUSH
63689: CALL_OW 1
63693: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63694: LD_ADDR_EXP 38
63698: PUSH
63699: LD_EXP 38
63703: PPUSH
63704: LD_VAR 0 2
63708: PPUSH
63709: EMPTY
63710: PPUSH
63711: CALL_OW 1
63715: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63716: LD_ADDR_EXP 39
63720: PUSH
63721: LD_EXP 39
63725: PPUSH
63726: LD_VAR 0 2
63730: PPUSH
63731: LD_EXP 31
63735: PUSH
63736: LD_VAR 0 2
63740: ARRAY
63741: PPUSH
63742: LD_INT 2
63744: PUSH
63745: LD_INT 30
63747: PUSH
63748: LD_INT 32
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: PUSH
63755: LD_INT 30
63757: PUSH
63758: LD_INT 33
63760: PUSH
63761: EMPTY
63762: LIST
63763: LIST
63764: PUSH
63765: EMPTY
63766: LIST
63767: LIST
63768: LIST
63769: PPUSH
63770: CALL_OW 72
63774: PPUSH
63775: CALL_OW 1
63779: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63780: LD_ADDR_EXP 40
63784: PUSH
63785: LD_EXP 40
63789: PPUSH
63790: LD_VAR 0 2
63794: PPUSH
63795: LD_EXP 31
63799: PUSH
63800: LD_VAR 0 2
63804: ARRAY
63805: PPUSH
63806: LD_INT 2
63808: PUSH
63809: LD_INT 30
63811: PUSH
63812: LD_INT 32
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: PUSH
63819: LD_INT 30
63821: PUSH
63822: LD_INT 31
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: PUSH
63829: EMPTY
63830: LIST
63831: LIST
63832: LIST
63833: PUSH
63834: LD_INT 58
63836: PUSH
63837: EMPTY
63838: LIST
63839: PUSH
63840: EMPTY
63841: LIST
63842: LIST
63843: PPUSH
63844: CALL_OW 72
63848: PPUSH
63849: CALL_OW 1
63853: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63854: LD_ADDR_EXP 41
63858: PUSH
63859: LD_EXP 41
63863: PPUSH
63864: LD_VAR 0 2
63868: PPUSH
63869: EMPTY
63870: PPUSH
63871: CALL_OW 1
63875: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
63876: LD_ADDR_EXP 45
63880: PUSH
63881: LD_EXP 45
63885: PPUSH
63886: LD_VAR 0 2
63890: PPUSH
63891: EMPTY
63892: PPUSH
63893: CALL_OW 1
63897: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
63898: LD_ADDR_EXP 44
63902: PUSH
63903: LD_EXP 44
63907: PPUSH
63908: LD_VAR 0 2
63912: PPUSH
63913: EMPTY
63914: PPUSH
63915: CALL_OW 1
63919: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
63920: LD_ADDR_EXP 46
63924: PUSH
63925: LD_EXP 46
63929: PPUSH
63930: LD_VAR 0 2
63934: PPUSH
63935: EMPTY
63936: PPUSH
63937: CALL_OW 1
63941: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
63942: LD_ADDR_EXP 47
63946: PUSH
63947: LD_EXP 47
63951: PPUSH
63952: LD_VAR 0 2
63956: PPUSH
63957: EMPTY
63958: PPUSH
63959: CALL_OW 1
63963: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63964: LD_ADDR_EXP 48
63968: PUSH
63969: LD_EXP 48
63973: PPUSH
63974: LD_VAR 0 2
63978: PPUSH
63979: EMPTY
63980: PPUSH
63981: CALL_OW 1
63985: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
63986: LD_ADDR_EXP 49
63990: PUSH
63991: LD_EXP 49
63995: PPUSH
63996: LD_VAR 0 2
64000: PPUSH
64001: EMPTY
64002: PPUSH
64003: CALL_OW 1
64007: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
64008: LD_ADDR_EXP 50
64012: PUSH
64013: LD_EXP 50
64017: PPUSH
64018: LD_VAR 0 2
64022: PPUSH
64023: EMPTY
64024: PPUSH
64025: CALL_OW 1
64029: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
64030: LD_ADDR_EXP 51
64034: PUSH
64035: LD_EXP 51
64039: PPUSH
64040: LD_VAR 0 2
64044: PPUSH
64045: EMPTY
64046: PPUSH
64047: CALL_OW 1
64051: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
64052: LD_ADDR_EXP 52
64056: PUSH
64057: LD_EXP 52
64061: PPUSH
64062: LD_VAR 0 2
64066: PPUSH
64067: EMPTY
64068: PPUSH
64069: CALL_OW 1
64073: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64074: LD_ADDR_EXP 53
64078: PUSH
64079: LD_EXP 53
64083: PPUSH
64084: LD_VAR 0 2
64088: PPUSH
64089: EMPTY
64090: PPUSH
64091: CALL_OW 1
64095: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
64096: LD_ADDR_EXP 42
64100: PUSH
64101: LD_EXP 42
64105: PPUSH
64106: LD_VAR 0 2
64110: PPUSH
64111: LD_INT 0
64113: PPUSH
64114: CALL_OW 1
64118: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
64119: LD_ADDR_EXP 55
64123: PUSH
64124: LD_EXP 55
64128: PPUSH
64129: LD_VAR 0 2
64133: PPUSH
64134: LD_INT 0
64136: PPUSH
64137: CALL_OW 1
64141: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64142: LD_ADDR_EXP 43
64146: PUSH
64147: LD_EXP 43
64151: PPUSH
64152: LD_VAR 0 2
64156: PPUSH
64157: EMPTY
64158: PPUSH
64159: CALL_OW 1
64163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
64164: LD_ADDR_EXP 54
64168: PUSH
64169: LD_EXP 54
64173: PPUSH
64174: LD_VAR 0 2
64178: PPUSH
64179: LD_INT 0
64181: PPUSH
64182: CALL_OW 1
64186: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
64187: LD_ADDR_EXP 56
64191: PUSH
64192: LD_EXP 56
64196: PPUSH
64197: LD_VAR 0 2
64201: PPUSH
64202: EMPTY
64203: PPUSH
64204: CALL_OW 1
64208: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
64209: LD_ADDR_EXP 59
64213: PUSH
64214: LD_EXP 59
64218: PPUSH
64219: LD_VAR 0 2
64223: PPUSH
64224: LD_INT 0
64226: PPUSH
64227: CALL_OW 1
64231: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
64232: LD_ADDR_EXP 60
64236: PUSH
64237: LD_EXP 60
64241: PPUSH
64242: LD_VAR 0 2
64246: PPUSH
64247: EMPTY
64248: PPUSH
64249: CALL_OW 1
64253: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64254: LD_ADDR_EXP 61
64258: PUSH
64259: LD_EXP 61
64263: PPUSH
64264: LD_VAR 0 2
64268: PPUSH
64269: EMPTY
64270: PPUSH
64271: CALL_OW 1
64275: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64276: LD_ADDR_EXP 62
64280: PUSH
64281: LD_EXP 62
64285: PPUSH
64286: LD_VAR 0 2
64290: PPUSH
64291: EMPTY
64292: PPUSH
64293: CALL_OW 1
64297: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64298: LD_ADDR_EXP 64
64302: PUSH
64303: LD_EXP 64
64307: PPUSH
64308: LD_VAR 0 2
64312: PPUSH
64313: LD_EXP 31
64317: PUSH
64318: LD_VAR 0 2
64322: ARRAY
64323: PPUSH
64324: LD_INT 2
64326: PUSH
64327: LD_INT 30
64329: PUSH
64330: LD_INT 6
64332: PUSH
64333: EMPTY
64334: LIST
64335: LIST
64336: PUSH
64337: LD_INT 30
64339: PUSH
64340: LD_INT 7
64342: PUSH
64343: EMPTY
64344: LIST
64345: LIST
64346: PUSH
64347: LD_INT 30
64349: PUSH
64350: LD_INT 8
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: PUSH
64357: EMPTY
64358: LIST
64359: LIST
64360: LIST
64361: LIST
64362: PPUSH
64363: CALL_OW 72
64367: PPUSH
64368: CALL_OW 1
64372: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64373: LD_ADDR_EXP 65
64377: PUSH
64378: LD_EXP 65
64382: PPUSH
64383: LD_VAR 0 2
64387: PPUSH
64388: EMPTY
64389: PPUSH
64390: CALL_OW 1
64394: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64395: LD_ADDR_EXP 66
64399: PUSH
64400: LD_EXP 66
64404: PPUSH
64405: LD_VAR 0 2
64409: PPUSH
64410: EMPTY
64411: PPUSH
64412: CALL_OW 1
64416: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64417: LD_ADDR_EXP 67
64421: PUSH
64422: LD_EXP 67
64426: PPUSH
64427: LD_VAR 0 2
64431: PPUSH
64432: EMPTY
64433: PPUSH
64434: CALL_OW 1
64438: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64439: LD_ADDR_EXP 68
64443: PUSH
64444: LD_EXP 68
64448: PPUSH
64449: LD_VAR 0 2
64453: PPUSH
64454: EMPTY
64455: PPUSH
64456: CALL_OW 1
64460: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64461: LD_ADDR_EXP 69
64465: PUSH
64466: LD_EXP 69
64470: PPUSH
64471: LD_VAR 0 2
64475: PPUSH
64476: EMPTY
64477: PPUSH
64478: CALL_OW 1
64482: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64483: LD_ADDR_EXP 70
64487: PUSH
64488: LD_EXP 70
64492: PPUSH
64493: LD_VAR 0 2
64497: PPUSH
64498: EMPTY
64499: PPUSH
64500: CALL_OW 1
64504: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64505: LD_ADDR_EXP 71
64509: PUSH
64510: LD_EXP 71
64514: PPUSH
64515: LD_VAR 0 2
64519: PPUSH
64520: EMPTY
64521: PPUSH
64522: CALL_OW 1
64526: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64527: LD_ADDR_EXP 72
64531: PUSH
64532: LD_EXP 72
64536: PPUSH
64537: LD_VAR 0 2
64541: PPUSH
64542: EMPTY
64543: PPUSH
64544: CALL_OW 1
64548: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64549: LD_ADDR_EXP 73
64553: PUSH
64554: LD_EXP 73
64558: PPUSH
64559: LD_VAR 0 2
64563: PPUSH
64564: LD_INT 0
64566: PPUSH
64567: CALL_OW 1
64571: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64572: LD_ADDR_EXP 74
64576: PUSH
64577: LD_EXP 74
64581: PPUSH
64582: LD_VAR 0 2
64586: PPUSH
64587: LD_INT 0
64589: PPUSH
64590: CALL_OW 1
64594: ST_TO_ADDR
// end ;
64595: GO 63496
64597: POP
64598: POP
// MC_InitSides ( ) ;
64599: CALL 64885 0 0
// MC_InitResearch ( ) ;
64603: CALL 64624 0 0
// CustomInitMacro ( ) ;
64607: CALL 1411 0 0
// skirmish := true ;
64611: LD_ADDR_EXP 29
64615: PUSH
64616: LD_INT 1
64618: ST_TO_ADDR
// end ;
64619: LD_VAR 0 1
64623: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64624: LD_INT 0
64626: PPUSH
64627: PPUSH
64628: PPUSH
64629: PPUSH
64630: PPUSH
64631: PPUSH
// if not mc_bases then
64632: LD_EXP 31
64636: NOT
64637: IFFALSE 64641
// exit ;
64639: GO 64880
// for i = 1 to 8 do
64641: LD_ADDR_VAR 0 2
64645: PUSH
64646: DOUBLE
64647: LD_INT 1
64649: DEC
64650: ST_TO_ADDR
64651: LD_INT 8
64653: PUSH
64654: FOR_TO
64655: IFFALSE 64681
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64657: LD_ADDR_EXP 58
64661: PUSH
64662: LD_EXP 58
64666: PPUSH
64667: LD_VAR 0 2
64671: PPUSH
64672: EMPTY
64673: PPUSH
64674: CALL_OW 1
64678: ST_TO_ADDR
64679: GO 64654
64681: POP
64682: POP
// tmp := [ ] ;
64683: LD_ADDR_VAR 0 5
64687: PUSH
64688: EMPTY
64689: ST_TO_ADDR
// for i = 1 to mc_sides do
64690: LD_ADDR_VAR 0 2
64694: PUSH
64695: DOUBLE
64696: LD_INT 1
64698: DEC
64699: ST_TO_ADDR
64700: LD_EXP 57
64704: PUSH
64705: FOR_TO
64706: IFFALSE 64764
// if not mc_sides [ i ] in tmp then
64708: LD_EXP 57
64712: PUSH
64713: LD_VAR 0 2
64717: ARRAY
64718: PUSH
64719: LD_VAR 0 5
64723: IN
64724: NOT
64725: IFFALSE 64762
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64727: LD_ADDR_VAR 0 5
64731: PUSH
64732: LD_VAR 0 5
64736: PPUSH
64737: LD_VAR 0 5
64741: PUSH
64742: LD_INT 1
64744: PLUS
64745: PPUSH
64746: LD_EXP 57
64750: PUSH
64751: LD_VAR 0 2
64755: ARRAY
64756: PPUSH
64757: CALL_OW 2
64761: ST_TO_ADDR
64762: GO 64705
64764: POP
64765: POP
// if not tmp then
64766: LD_VAR 0 5
64770: NOT
64771: IFFALSE 64775
// exit ;
64773: GO 64880
// for j in tmp do
64775: LD_ADDR_VAR 0 3
64779: PUSH
64780: LD_VAR 0 5
64784: PUSH
64785: FOR_IN
64786: IFFALSE 64878
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64788: LD_ADDR_VAR 0 6
64792: PUSH
64793: LD_INT 22
64795: PUSH
64796: LD_VAR 0 3
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PPUSH
64805: CALL_OW 69
64809: ST_TO_ADDR
// if not un then
64810: LD_VAR 0 6
64814: NOT
64815: IFFALSE 64819
// continue ;
64817: GO 64785
// nation := GetNation ( un [ 1 ] ) ;
64819: LD_ADDR_VAR 0 4
64823: PUSH
64824: LD_VAR 0 6
64828: PUSH
64829: LD_INT 1
64831: ARRAY
64832: PPUSH
64833: CALL_OW 248
64837: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64838: LD_ADDR_EXP 58
64842: PUSH
64843: LD_EXP 58
64847: PPUSH
64848: LD_VAR 0 3
64852: PPUSH
64853: LD_VAR 0 3
64857: PPUSH
64858: LD_VAR 0 4
64862: PPUSH
64863: LD_INT 1
64865: PPUSH
64866: CALL 19947 0 3
64870: PPUSH
64871: CALL_OW 1
64875: ST_TO_ADDR
// end ;
64876: GO 64785
64878: POP
64879: POP
// end ;
64880: LD_VAR 0 1
64884: RET
// export function MC_InitSides ( ) ; var i ; begin
64885: LD_INT 0
64887: PPUSH
64888: PPUSH
// if not mc_bases then
64889: LD_EXP 31
64893: NOT
64894: IFFALSE 64898
// exit ;
64896: GO 64972
// for i = 1 to mc_bases do
64898: LD_ADDR_VAR 0 2
64902: PUSH
64903: DOUBLE
64904: LD_INT 1
64906: DEC
64907: ST_TO_ADDR
64908: LD_EXP 31
64912: PUSH
64913: FOR_TO
64914: IFFALSE 64970
// if mc_bases [ i ] then
64916: LD_EXP 31
64920: PUSH
64921: LD_VAR 0 2
64925: ARRAY
64926: IFFALSE 64968
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
64928: LD_ADDR_EXP 57
64932: PUSH
64933: LD_EXP 57
64937: PPUSH
64938: LD_VAR 0 2
64942: PPUSH
64943: LD_EXP 31
64947: PUSH
64948: LD_VAR 0 2
64952: ARRAY
64953: PUSH
64954: LD_INT 1
64956: ARRAY
64957: PPUSH
64958: CALL_OW 255
64962: PPUSH
64963: CALL_OW 1
64967: ST_TO_ADDR
64968: GO 64913
64970: POP
64971: POP
// end ;
64972: LD_VAR 0 1
64976: RET
// every 0 0$03 trigger skirmish do
64977: LD_EXP 29
64981: IFFALSE 65135
64983: GO 64985
64985: DISABLE
// begin enable ;
64986: ENABLE
// MC_CheckBuildings ( ) ;
64987: CALL 69633 0 0
// MC_CheckPeopleLife ( ) ;
64991: CALL 69794 0 0
// RaiseSailEvent ( 100 ) ;
64995: LD_INT 100
64997: PPUSH
64998: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
65002: LD_INT 103
65004: PPUSH
65005: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
65009: LD_INT 104
65011: PPUSH
65012: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
65016: LD_INT 105
65018: PPUSH
65019: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
65023: LD_INT 106
65025: PPUSH
65026: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
65030: LD_INT 107
65032: PPUSH
65033: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
65037: LD_INT 108
65039: PPUSH
65040: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
65044: LD_INT 109
65046: PPUSH
65047: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
65051: LD_INT 110
65053: PPUSH
65054: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
65058: LD_INT 111
65060: PPUSH
65061: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
65065: LD_INT 112
65067: PPUSH
65068: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
65072: LD_INT 113
65074: PPUSH
65075: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
65079: LD_INT 120
65081: PPUSH
65082: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
65086: LD_INT 121
65088: PPUSH
65089: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
65093: LD_INT 122
65095: PPUSH
65096: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
65100: LD_INT 123
65102: PPUSH
65103: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
65107: LD_INT 124
65109: PPUSH
65110: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
65114: LD_INT 125
65116: PPUSH
65117: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
65121: LD_INT 126
65123: PPUSH
65124: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
65128: LD_INT 200
65130: PPUSH
65131: CALL_OW 427
// end ;
65135: END
// on SailEvent ( event ) do begin if event < 100 then
65136: LD_VAR 0 1
65140: PUSH
65141: LD_INT 100
65143: LESS
65144: IFFALSE 65155
// CustomEvent ( event ) ;
65146: LD_VAR 0 1
65150: PPUSH
65151: CALL 19111 0 1
// if event = 100 then
65155: LD_VAR 0 1
65159: PUSH
65160: LD_INT 100
65162: EQUAL
65163: IFFALSE 65169
// MC_ClassManager ( ) ;
65165: CALL 65561 0 0
// if event = 101 then
65169: LD_VAR 0 1
65173: PUSH
65174: LD_INT 101
65176: EQUAL
65177: IFFALSE 65183
// MC_RepairBuildings ( ) ;
65179: CALL 70379 0 0
// if event = 102 then
65183: LD_VAR 0 1
65187: PUSH
65188: LD_INT 102
65190: EQUAL
65191: IFFALSE 65197
// MC_Heal ( ) ;
65193: CALL 71314 0 0
// if event = 103 then
65197: LD_VAR 0 1
65201: PUSH
65202: LD_INT 103
65204: EQUAL
65205: IFFALSE 65211
// MC_Build ( ) ;
65207: CALL 71736 0 0
// if event = 104 then
65211: LD_VAR 0 1
65215: PUSH
65216: LD_INT 104
65218: EQUAL
65219: IFFALSE 65225
// MC_TurretWeapon ( ) ;
65221: CALL 73370 0 0
// if event = 105 then
65225: LD_VAR 0 1
65229: PUSH
65230: LD_INT 105
65232: EQUAL
65233: IFFALSE 65239
// MC_BuildUpgrade ( ) ;
65235: CALL 72921 0 0
// if event = 106 then
65239: LD_VAR 0 1
65243: PUSH
65244: LD_INT 106
65246: EQUAL
65247: IFFALSE 65253
// MC_PlantMines ( ) ;
65249: CALL 73800 0 0
// if event = 107 then
65253: LD_VAR 0 1
65257: PUSH
65258: LD_INT 107
65260: EQUAL
65261: IFFALSE 65267
// MC_CollectCrates ( ) ;
65263: CALL 74591 0 0
// if event = 108 then
65267: LD_VAR 0 1
65271: PUSH
65272: LD_INT 108
65274: EQUAL
65275: IFFALSE 65281
// MC_LinkRemoteControl ( ) ;
65277: CALL 76441 0 0
// if event = 109 then
65281: LD_VAR 0 1
65285: PUSH
65286: LD_INT 109
65288: EQUAL
65289: IFFALSE 65295
// MC_ProduceVehicle ( ) ;
65291: CALL 76622 0 0
// if event = 110 then
65295: LD_VAR 0 1
65299: PUSH
65300: LD_INT 110
65302: EQUAL
65303: IFFALSE 65309
// MC_SendAttack ( ) ;
65305: CALL 77088 0 0
// if event = 111 then
65309: LD_VAR 0 1
65313: PUSH
65314: LD_INT 111
65316: EQUAL
65317: IFFALSE 65323
// MC_Defend ( ) ;
65319: CALL 77196 0 0
// if event = 112 then
65323: LD_VAR 0 1
65327: PUSH
65328: LD_INT 112
65330: EQUAL
65331: IFFALSE 65337
// MC_Research ( ) ;
65333: CALL 78076 0 0
// if event = 113 then
65337: LD_VAR 0 1
65341: PUSH
65342: LD_INT 113
65344: EQUAL
65345: IFFALSE 65351
// MC_MinesTrigger ( ) ;
65347: CALL 79190 0 0
// if event = 120 then
65351: LD_VAR 0 1
65355: PUSH
65356: LD_INT 120
65358: EQUAL
65359: IFFALSE 65365
// MC_RepairVehicle ( ) ;
65361: CALL 79289 0 0
// if event = 121 then
65365: LD_VAR 0 1
65369: PUSH
65370: LD_INT 121
65372: EQUAL
65373: IFFALSE 65379
// MC_TameApe ( ) ;
65375: CALL 80058 0 0
// if event = 122 then
65379: LD_VAR 0 1
65383: PUSH
65384: LD_INT 122
65386: EQUAL
65387: IFFALSE 65393
// MC_ChangeApeClass ( ) ;
65389: CALL 80887 0 0
// if event = 123 then
65393: LD_VAR 0 1
65397: PUSH
65398: LD_INT 123
65400: EQUAL
65401: IFFALSE 65407
// MC_Bazooka ( ) ;
65403: CALL 81537 0 0
// if event = 124 then
65407: LD_VAR 0 1
65411: PUSH
65412: LD_INT 124
65414: EQUAL
65415: IFFALSE 65421
// MC_TeleportExit ( ) ;
65417: CALL 81735 0 0
// if event = 125 then
65421: LD_VAR 0 1
65425: PUSH
65426: LD_INT 125
65428: EQUAL
65429: IFFALSE 65435
// MC_Deposits ( ) ;
65431: CALL 82382 0 0
// if event = 126 then
65435: LD_VAR 0 1
65439: PUSH
65440: LD_INT 126
65442: EQUAL
65443: IFFALSE 65449
// MC_RemoteDriver ( ) ;
65445: CALL 83007 0 0
// if event = 200 then
65449: LD_VAR 0 1
65453: PUSH
65454: LD_INT 200
65456: EQUAL
65457: IFFALSE 65463
// MC_Idle ( ) ;
65459: CALL 84956 0 0
// end ;
65463: PPOPN 1
65465: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65466: LD_INT 0
65468: PPUSH
65469: PPUSH
// if not mc_bases [ base ] or not tag then
65470: LD_EXP 31
65474: PUSH
65475: LD_VAR 0 1
65479: ARRAY
65480: NOT
65481: PUSH
65482: LD_VAR 0 2
65486: NOT
65487: OR
65488: IFFALSE 65492
// exit ;
65490: GO 65556
// for i in mc_bases [ base ] union mc_ape [ base ] do
65492: LD_ADDR_VAR 0 4
65496: PUSH
65497: LD_EXP 31
65501: PUSH
65502: LD_VAR 0 1
65506: ARRAY
65507: PUSH
65508: LD_EXP 60
65512: PUSH
65513: LD_VAR 0 1
65517: ARRAY
65518: UNION
65519: PUSH
65520: FOR_IN
65521: IFFALSE 65554
// if GetTag ( i ) = tag then
65523: LD_VAR 0 4
65527: PPUSH
65528: CALL_OW 110
65532: PUSH
65533: LD_VAR 0 2
65537: EQUAL
65538: IFFALSE 65552
// SetTag ( i , 0 ) ;
65540: LD_VAR 0 4
65544: PPUSH
65545: LD_INT 0
65547: PPUSH
65548: CALL_OW 109
65552: GO 65520
65554: POP
65555: POP
// end ;
65556: LD_VAR 0 3
65560: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65561: LD_INT 0
65563: PPUSH
65564: PPUSH
65565: PPUSH
65566: PPUSH
65567: PPUSH
65568: PPUSH
65569: PPUSH
65570: PPUSH
// if not mc_bases then
65571: LD_EXP 31
65575: NOT
65576: IFFALSE 65580
// exit ;
65578: GO 66038
// for i = 1 to mc_bases do
65580: LD_ADDR_VAR 0 2
65584: PUSH
65585: DOUBLE
65586: LD_INT 1
65588: DEC
65589: ST_TO_ADDR
65590: LD_EXP 31
65594: PUSH
65595: FOR_TO
65596: IFFALSE 66036
// begin tmp := MC_ClassCheckReq ( i ) ;
65598: LD_ADDR_VAR 0 4
65602: PUSH
65603: LD_VAR 0 2
65607: PPUSH
65608: CALL 66043 0 1
65612: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65613: LD_ADDR_EXP 72
65617: PUSH
65618: LD_EXP 72
65622: PPUSH
65623: LD_VAR 0 2
65627: PPUSH
65628: LD_VAR 0 4
65632: PPUSH
65633: CALL_OW 1
65637: ST_TO_ADDR
// if not tmp then
65638: LD_VAR 0 4
65642: NOT
65643: IFFALSE 65647
// continue ;
65645: GO 65595
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65647: LD_ADDR_VAR 0 6
65651: PUSH
65652: LD_EXP 31
65656: PUSH
65657: LD_VAR 0 2
65661: ARRAY
65662: PPUSH
65663: LD_INT 2
65665: PUSH
65666: LD_INT 30
65668: PUSH
65669: LD_INT 4
65671: PUSH
65672: EMPTY
65673: LIST
65674: LIST
65675: PUSH
65676: LD_INT 30
65678: PUSH
65679: LD_INT 5
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: LIST
65690: PPUSH
65691: CALL_OW 72
65695: PUSH
65696: LD_EXP 31
65700: PUSH
65701: LD_VAR 0 2
65705: ARRAY
65706: PPUSH
65707: LD_INT 2
65709: PUSH
65710: LD_INT 30
65712: PUSH
65713: LD_INT 0
65715: PUSH
65716: EMPTY
65717: LIST
65718: LIST
65719: PUSH
65720: LD_INT 30
65722: PUSH
65723: LD_INT 1
65725: PUSH
65726: EMPTY
65727: LIST
65728: LIST
65729: PUSH
65730: EMPTY
65731: LIST
65732: LIST
65733: LIST
65734: PPUSH
65735: CALL_OW 72
65739: PUSH
65740: LD_EXP 31
65744: PUSH
65745: LD_VAR 0 2
65749: ARRAY
65750: PPUSH
65751: LD_INT 30
65753: PUSH
65754: LD_INT 3
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: PPUSH
65761: CALL_OW 72
65765: PUSH
65766: LD_EXP 31
65770: PUSH
65771: LD_VAR 0 2
65775: ARRAY
65776: PPUSH
65777: LD_INT 2
65779: PUSH
65780: LD_INT 30
65782: PUSH
65783: LD_INT 6
65785: PUSH
65786: EMPTY
65787: LIST
65788: LIST
65789: PUSH
65790: LD_INT 30
65792: PUSH
65793: LD_INT 7
65795: PUSH
65796: EMPTY
65797: LIST
65798: LIST
65799: PUSH
65800: LD_INT 30
65802: PUSH
65803: LD_INT 8
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: PPUSH
65816: CALL_OW 72
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: ST_TO_ADDR
// for j = 1 to 4 do
65827: LD_ADDR_VAR 0 3
65831: PUSH
65832: DOUBLE
65833: LD_INT 1
65835: DEC
65836: ST_TO_ADDR
65837: LD_INT 4
65839: PUSH
65840: FOR_TO
65841: IFFALSE 66032
// begin if not tmp [ j ] then
65843: LD_VAR 0 4
65847: PUSH
65848: LD_VAR 0 3
65852: ARRAY
65853: NOT
65854: IFFALSE 65858
// continue ;
65856: GO 65840
// for p in tmp [ j ] do
65858: LD_ADDR_VAR 0 5
65862: PUSH
65863: LD_VAR 0 4
65867: PUSH
65868: LD_VAR 0 3
65872: ARRAY
65873: PUSH
65874: FOR_IN
65875: IFFALSE 66028
// begin if not b [ j ] then
65877: LD_VAR 0 6
65881: PUSH
65882: LD_VAR 0 3
65886: ARRAY
65887: NOT
65888: IFFALSE 65892
// break ;
65890: GO 66028
// e := 0 ;
65892: LD_ADDR_VAR 0 7
65896: PUSH
65897: LD_INT 0
65899: ST_TO_ADDR
// for k in b [ j ] do
65900: LD_ADDR_VAR 0 8
65904: PUSH
65905: LD_VAR 0 6
65909: PUSH
65910: LD_VAR 0 3
65914: ARRAY
65915: PUSH
65916: FOR_IN
65917: IFFALSE 65944
// if IsNotFull ( k ) then
65919: LD_VAR 0 8
65923: PPUSH
65924: CALL 22100 0 1
65928: IFFALSE 65942
// begin e := k ;
65930: LD_ADDR_VAR 0 7
65934: PUSH
65935: LD_VAR 0 8
65939: ST_TO_ADDR
// break ;
65940: GO 65944
// end ;
65942: GO 65916
65944: POP
65945: POP
// if e and not UnitGoingToBuilding ( p , e ) then
65946: LD_VAR 0 7
65950: PUSH
65951: LD_VAR 0 5
65955: PPUSH
65956: LD_VAR 0 7
65960: PPUSH
65961: CALL 55996 0 2
65965: NOT
65966: AND
65967: IFFALSE 66026
// begin if IsInUnit ( p ) then
65969: LD_VAR 0 5
65973: PPUSH
65974: CALL_OW 310
65978: IFFALSE 65989
// ComExitBuilding ( p ) ;
65980: LD_VAR 0 5
65984: PPUSH
65985: CALL_OW 122
// ComEnterUnit ( p , e ) ;
65989: LD_VAR 0 5
65993: PPUSH
65994: LD_VAR 0 7
65998: PPUSH
65999: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
66003: LD_VAR 0 5
66007: PPUSH
66008: LD_VAR 0 3
66012: PPUSH
66013: CALL_OW 183
// AddComExitBuilding ( p ) ;
66017: LD_VAR 0 5
66021: PPUSH
66022: CALL_OW 182
// end ; end ;
66026: GO 65874
66028: POP
66029: POP
// end ;
66030: GO 65840
66032: POP
66033: POP
// end ;
66034: GO 65595
66036: POP
66037: POP
// end ;
66038: LD_VAR 0 1
66042: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
66043: LD_INT 0
66045: PPUSH
66046: PPUSH
66047: PPUSH
66048: PPUSH
66049: PPUSH
66050: PPUSH
66051: PPUSH
66052: PPUSH
66053: PPUSH
66054: PPUSH
66055: PPUSH
66056: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66057: LD_VAR 0 1
66061: NOT
66062: PUSH
66063: LD_EXP 31
66067: PUSH
66068: LD_VAR 0 1
66072: ARRAY
66073: NOT
66074: OR
66075: PUSH
66076: LD_EXP 31
66080: PUSH
66081: LD_VAR 0 1
66085: ARRAY
66086: PPUSH
66087: LD_INT 2
66089: PUSH
66090: LD_INT 30
66092: PUSH
66093: LD_INT 0
66095: PUSH
66096: EMPTY
66097: LIST
66098: LIST
66099: PUSH
66100: LD_INT 30
66102: PUSH
66103: LD_INT 1
66105: PUSH
66106: EMPTY
66107: LIST
66108: LIST
66109: PUSH
66110: EMPTY
66111: LIST
66112: LIST
66113: LIST
66114: PPUSH
66115: CALL_OW 72
66119: NOT
66120: OR
66121: IFFALSE 66125
// exit ;
66123: GO 69628
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66125: LD_ADDR_VAR 0 4
66129: PUSH
66130: LD_EXP 31
66134: PUSH
66135: LD_VAR 0 1
66139: ARRAY
66140: PPUSH
66141: LD_INT 2
66143: PUSH
66144: LD_INT 25
66146: PUSH
66147: LD_INT 1
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: PUSH
66154: LD_INT 25
66156: PUSH
66157: LD_INT 2
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PUSH
66164: LD_INT 25
66166: PUSH
66167: LD_INT 3
66169: PUSH
66170: EMPTY
66171: LIST
66172: LIST
66173: PUSH
66174: LD_INT 25
66176: PUSH
66177: LD_INT 4
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 25
66186: PUSH
66187: LD_INT 5
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: LD_INT 25
66196: PUSH
66197: LD_INT 8
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 25
66206: PUSH
66207: LD_INT 9
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: PPUSH
66224: CALL_OW 72
66228: ST_TO_ADDR
// if not tmp then
66229: LD_VAR 0 4
66233: NOT
66234: IFFALSE 66238
// exit ;
66236: GO 69628
// for i in tmp do
66238: LD_ADDR_VAR 0 3
66242: PUSH
66243: LD_VAR 0 4
66247: PUSH
66248: FOR_IN
66249: IFFALSE 66280
// if GetTag ( i ) then
66251: LD_VAR 0 3
66255: PPUSH
66256: CALL_OW 110
66260: IFFALSE 66278
// tmp := tmp diff i ;
66262: LD_ADDR_VAR 0 4
66266: PUSH
66267: LD_VAR 0 4
66271: PUSH
66272: LD_VAR 0 3
66276: DIFF
66277: ST_TO_ADDR
66278: GO 66248
66280: POP
66281: POP
// if not tmp then
66282: LD_VAR 0 4
66286: NOT
66287: IFFALSE 66291
// exit ;
66289: GO 69628
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66291: LD_ADDR_VAR 0 5
66295: PUSH
66296: LD_EXP 31
66300: PUSH
66301: LD_VAR 0 1
66305: ARRAY
66306: PPUSH
66307: LD_INT 2
66309: PUSH
66310: LD_INT 25
66312: PUSH
66313: LD_INT 1
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: LD_INT 25
66322: PUSH
66323: LD_INT 5
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: PUSH
66330: LD_INT 25
66332: PUSH
66333: LD_INT 8
66335: PUSH
66336: EMPTY
66337: LIST
66338: LIST
66339: PUSH
66340: LD_INT 25
66342: PUSH
66343: LD_INT 9
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: PUSH
66350: EMPTY
66351: LIST
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: PPUSH
66357: CALL_OW 72
66361: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66362: LD_ADDR_VAR 0 6
66366: PUSH
66367: LD_EXP 31
66371: PUSH
66372: LD_VAR 0 1
66376: ARRAY
66377: PPUSH
66378: LD_INT 25
66380: PUSH
66381: LD_INT 2
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: PPUSH
66388: CALL_OW 72
66392: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66393: LD_ADDR_VAR 0 7
66397: PUSH
66398: LD_EXP 31
66402: PUSH
66403: LD_VAR 0 1
66407: ARRAY
66408: PPUSH
66409: LD_INT 25
66411: PUSH
66412: LD_INT 3
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PPUSH
66419: CALL_OW 72
66423: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66424: LD_ADDR_VAR 0 8
66428: PUSH
66429: LD_EXP 31
66433: PUSH
66434: LD_VAR 0 1
66438: ARRAY
66439: PPUSH
66440: LD_INT 25
66442: PUSH
66443: LD_INT 4
66445: PUSH
66446: EMPTY
66447: LIST
66448: LIST
66449: PUSH
66450: LD_INT 24
66452: PUSH
66453: LD_INT 251
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PPUSH
66464: CALL_OW 72
66468: ST_TO_ADDR
// if mc_is_defending [ base ] then
66469: LD_EXP 74
66473: PUSH
66474: LD_VAR 0 1
66478: ARRAY
66479: IFFALSE 66940
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66481: LD_ADDR_EXP 73
66485: PUSH
66486: LD_EXP 73
66490: PPUSH
66491: LD_VAR 0 1
66495: PPUSH
66496: LD_INT 4
66498: PPUSH
66499: CALL_OW 1
66503: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66504: LD_ADDR_VAR 0 12
66508: PUSH
66509: LD_EXP 31
66513: PUSH
66514: LD_VAR 0 1
66518: ARRAY
66519: PPUSH
66520: LD_INT 2
66522: PUSH
66523: LD_INT 30
66525: PUSH
66526: LD_INT 4
66528: PUSH
66529: EMPTY
66530: LIST
66531: LIST
66532: PUSH
66533: LD_INT 30
66535: PUSH
66536: LD_INT 5
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: LIST
66547: PPUSH
66548: CALL_OW 72
66552: ST_TO_ADDR
// if not b then
66553: LD_VAR 0 12
66557: NOT
66558: IFFALSE 66562
// exit ;
66560: GO 69628
// p := [ ] ;
66562: LD_ADDR_VAR 0 11
66566: PUSH
66567: EMPTY
66568: ST_TO_ADDR
// if sci >= 2 then
66569: LD_VAR 0 8
66573: PUSH
66574: LD_INT 2
66576: GREATEREQUAL
66577: IFFALSE 66608
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66579: LD_ADDR_VAR 0 8
66583: PUSH
66584: LD_VAR 0 8
66588: PUSH
66589: LD_INT 1
66591: ARRAY
66592: PUSH
66593: LD_VAR 0 8
66597: PUSH
66598: LD_INT 2
66600: ARRAY
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: ST_TO_ADDR
66606: GO 66669
// if sci = 1 then
66608: LD_VAR 0 8
66612: PUSH
66613: LD_INT 1
66615: EQUAL
66616: IFFALSE 66637
// sci := [ sci [ 1 ] ] else
66618: LD_ADDR_VAR 0 8
66622: PUSH
66623: LD_VAR 0 8
66627: PUSH
66628: LD_INT 1
66630: ARRAY
66631: PUSH
66632: EMPTY
66633: LIST
66634: ST_TO_ADDR
66635: GO 66669
// if sci = 0 then
66637: LD_VAR 0 8
66641: PUSH
66642: LD_INT 0
66644: EQUAL
66645: IFFALSE 66669
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66647: LD_ADDR_VAR 0 11
66651: PUSH
66652: LD_VAR 0 4
66656: PPUSH
66657: LD_INT 4
66659: PPUSH
66660: CALL 55868 0 2
66664: PUSH
66665: LD_INT 1
66667: ARRAY
66668: ST_TO_ADDR
// if eng > 4 then
66669: LD_VAR 0 6
66673: PUSH
66674: LD_INT 4
66676: GREATER
66677: IFFALSE 66723
// for i = eng downto 4 do
66679: LD_ADDR_VAR 0 3
66683: PUSH
66684: DOUBLE
66685: LD_VAR 0 6
66689: INC
66690: ST_TO_ADDR
66691: LD_INT 4
66693: PUSH
66694: FOR_DOWNTO
66695: IFFALSE 66721
// eng := eng diff eng [ i ] ;
66697: LD_ADDR_VAR 0 6
66701: PUSH
66702: LD_VAR 0 6
66706: PUSH
66707: LD_VAR 0 6
66711: PUSH
66712: LD_VAR 0 3
66716: ARRAY
66717: DIFF
66718: ST_TO_ADDR
66719: GO 66694
66721: POP
66722: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66723: LD_ADDR_VAR 0 4
66727: PUSH
66728: LD_VAR 0 4
66732: PUSH
66733: LD_VAR 0 5
66737: PUSH
66738: LD_VAR 0 6
66742: UNION
66743: PUSH
66744: LD_VAR 0 7
66748: UNION
66749: PUSH
66750: LD_VAR 0 8
66754: UNION
66755: DIFF
66756: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66757: LD_ADDR_VAR 0 13
66761: PUSH
66762: LD_EXP 31
66766: PUSH
66767: LD_VAR 0 1
66771: ARRAY
66772: PPUSH
66773: LD_INT 2
66775: PUSH
66776: LD_INT 30
66778: PUSH
66779: LD_INT 32
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: LD_INT 30
66788: PUSH
66789: LD_INT 31
66791: PUSH
66792: EMPTY
66793: LIST
66794: LIST
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: LIST
66800: PPUSH
66801: CALL_OW 72
66805: PUSH
66806: LD_EXP 31
66810: PUSH
66811: LD_VAR 0 1
66815: ARRAY
66816: PPUSH
66817: LD_INT 2
66819: PUSH
66820: LD_INT 30
66822: PUSH
66823: LD_INT 4
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 30
66832: PUSH
66833: LD_INT 5
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: LIST
66844: PPUSH
66845: CALL_OW 72
66849: PUSH
66850: LD_INT 6
66852: MUL
66853: PLUS
66854: ST_TO_ADDR
// if bcount < tmp then
66855: LD_VAR 0 13
66859: PUSH
66860: LD_VAR 0 4
66864: LESS
66865: IFFALSE 66911
// for i = tmp downto bcount do
66867: LD_ADDR_VAR 0 3
66871: PUSH
66872: DOUBLE
66873: LD_VAR 0 4
66877: INC
66878: ST_TO_ADDR
66879: LD_VAR 0 13
66883: PUSH
66884: FOR_DOWNTO
66885: IFFALSE 66909
// tmp := Delete ( tmp , tmp ) ;
66887: LD_ADDR_VAR 0 4
66891: PUSH
66892: LD_VAR 0 4
66896: PPUSH
66897: LD_VAR 0 4
66901: PPUSH
66902: CALL_OW 3
66906: ST_TO_ADDR
66907: GO 66884
66909: POP
66910: POP
// result := [ tmp , 0 , 0 , p ] ;
66911: LD_ADDR_VAR 0 2
66915: PUSH
66916: LD_VAR 0 4
66920: PUSH
66921: LD_INT 0
66923: PUSH
66924: LD_INT 0
66926: PUSH
66927: LD_VAR 0 11
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: ST_TO_ADDR
// exit ;
66938: GO 69628
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66940: LD_EXP 31
66944: PUSH
66945: LD_VAR 0 1
66949: ARRAY
66950: PPUSH
66951: LD_INT 2
66953: PUSH
66954: LD_INT 30
66956: PUSH
66957: LD_INT 6
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 30
66966: PUSH
66967: LD_INT 7
66969: PUSH
66970: EMPTY
66971: LIST
66972: LIST
66973: PUSH
66974: LD_INT 30
66976: PUSH
66977: LD_INT 8
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: LIST
66988: LIST
66989: PPUSH
66990: CALL_OW 72
66994: NOT
66995: PUSH
66996: LD_EXP 31
67000: PUSH
67001: LD_VAR 0 1
67005: ARRAY
67006: PPUSH
67007: LD_INT 30
67009: PUSH
67010: LD_INT 3
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PPUSH
67017: CALL_OW 72
67021: NOT
67022: AND
67023: IFFALSE 67095
// begin if eng = tmp then
67025: LD_VAR 0 6
67029: PUSH
67030: LD_VAR 0 4
67034: EQUAL
67035: IFFALSE 67039
// exit ;
67037: GO 69628
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
67039: LD_ADDR_EXP 73
67043: PUSH
67044: LD_EXP 73
67048: PPUSH
67049: LD_VAR 0 1
67053: PPUSH
67054: LD_INT 1
67056: PPUSH
67057: CALL_OW 1
67061: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
67062: LD_ADDR_VAR 0 2
67066: PUSH
67067: LD_INT 0
67069: PUSH
67070: LD_VAR 0 4
67074: PUSH
67075: LD_VAR 0 6
67079: DIFF
67080: PUSH
67081: LD_INT 0
67083: PUSH
67084: LD_INT 0
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: LIST
67091: LIST
67092: ST_TO_ADDR
// exit ;
67093: GO 69628
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67095: LD_EXP 58
67099: PUSH
67100: LD_EXP 57
67104: PUSH
67105: LD_VAR 0 1
67109: ARRAY
67110: ARRAY
67111: PUSH
67112: LD_EXP 31
67116: PUSH
67117: LD_VAR 0 1
67121: ARRAY
67122: PPUSH
67123: LD_INT 2
67125: PUSH
67126: LD_INT 30
67128: PUSH
67129: LD_INT 6
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: PUSH
67136: LD_INT 30
67138: PUSH
67139: LD_INT 7
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 30
67148: PUSH
67149: LD_INT 8
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: PPUSH
67162: CALL_OW 72
67166: AND
67167: PUSH
67168: LD_EXP 31
67172: PUSH
67173: LD_VAR 0 1
67177: ARRAY
67178: PPUSH
67179: LD_INT 30
67181: PUSH
67182: LD_INT 3
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PPUSH
67189: CALL_OW 72
67193: NOT
67194: AND
67195: IFFALSE 67409
// begin if sci >= 6 then
67197: LD_VAR 0 8
67201: PUSH
67202: LD_INT 6
67204: GREATEREQUAL
67205: IFFALSE 67209
// exit ;
67207: GO 69628
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
67209: LD_ADDR_EXP 73
67213: PUSH
67214: LD_EXP 73
67218: PPUSH
67219: LD_VAR 0 1
67223: PPUSH
67224: LD_INT 2
67226: PPUSH
67227: CALL_OW 1
67231: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
67232: LD_ADDR_VAR 0 9
67236: PUSH
67237: LD_VAR 0 4
67241: PUSH
67242: LD_VAR 0 8
67246: DIFF
67247: PPUSH
67248: LD_INT 4
67250: PPUSH
67251: CALL 55868 0 2
67255: ST_TO_ADDR
// p := [ ] ;
67256: LD_ADDR_VAR 0 11
67260: PUSH
67261: EMPTY
67262: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67263: LD_VAR 0 8
67267: PUSH
67268: LD_INT 6
67270: LESS
67271: PUSH
67272: LD_VAR 0 9
67276: PUSH
67277: LD_INT 6
67279: GREATER
67280: AND
67281: IFFALSE 67362
// begin for i = 1 to 6 - sci do
67283: LD_ADDR_VAR 0 3
67287: PUSH
67288: DOUBLE
67289: LD_INT 1
67291: DEC
67292: ST_TO_ADDR
67293: LD_INT 6
67295: PUSH
67296: LD_VAR 0 8
67300: MINUS
67301: PUSH
67302: FOR_TO
67303: IFFALSE 67358
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67305: LD_ADDR_VAR 0 11
67309: PUSH
67310: LD_VAR 0 11
67314: PPUSH
67315: LD_VAR 0 11
67319: PUSH
67320: LD_INT 1
67322: PLUS
67323: PPUSH
67324: LD_VAR 0 9
67328: PUSH
67329: LD_INT 1
67331: ARRAY
67332: PPUSH
67333: CALL_OW 2
67337: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67338: LD_ADDR_VAR 0 9
67342: PUSH
67343: LD_VAR 0 9
67347: PPUSH
67348: LD_INT 1
67350: PPUSH
67351: CALL_OW 3
67355: ST_TO_ADDR
// end ;
67356: GO 67302
67358: POP
67359: POP
// end else
67360: GO 67382
// if sort then
67362: LD_VAR 0 9
67366: IFFALSE 67382
// p := sort [ 1 ] ;
67368: LD_ADDR_VAR 0 11
67372: PUSH
67373: LD_VAR 0 9
67377: PUSH
67378: LD_INT 1
67380: ARRAY
67381: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67382: LD_ADDR_VAR 0 2
67386: PUSH
67387: LD_INT 0
67389: PUSH
67390: LD_INT 0
67392: PUSH
67393: LD_INT 0
67395: PUSH
67396: LD_VAR 0 11
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: LIST
67405: LIST
67406: ST_TO_ADDR
// exit ;
67407: GO 69628
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67409: LD_EXP 58
67413: PUSH
67414: LD_EXP 57
67418: PUSH
67419: LD_VAR 0 1
67423: ARRAY
67424: ARRAY
67425: PUSH
67426: LD_EXP 31
67430: PUSH
67431: LD_VAR 0 1
67435: ARRAY
67436: PPUSH
67437: LD_INT 2
67439: PUSH
67440: LD_INT 30
67442: PUSH
67443: LD_INT 6
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 30
67452: PUSH
67453: LD_INT 7
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: LD_INT 30
67462: PUSH
67463: LD_INT 8
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: PPUSH
67476: CALL_OW 72
67480: AND
67481: PUSH
67482: LD_EXP 31
67486: PUSH
67487: LD_VAR 0 1
67491: ARRAY
67492: PPUSH
67493: LD_INT 30
67495: PUSH
67496: LD_INT 3
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PPUSH
67503: CALL_OW 72
67507: AND
67508: IFFALSE 68242
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67510: LD_ADDR_EXP 73
67514: PUSH
67515: LD_EXP 73
67519: PPUSH
67520: LD_VAR 0 1
67524: PPUSH
67525: LD_INT 3
67527: PPUSH
67528: CALL_OW 1
67532: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67533: LD_ADDR_VAR 0 2
67537: PUSH
67538: LD_INT 0
67540: PUSH
67541: LD_INT 0
67543: PUSH
67544: LD_INT 0
67546: PUSH
67547: LD_INT 0
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: LIST
67554: LIST
67555: ST_TO_ADDR
// if not eng then
67556: LD_VAR 0 6
67560: NOT
67561: IFFALSE 67624
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67563: LD_ADDR_VAR 0 11
67567: PUSH
67568: LD_VAR 0 4
67572: PPUSH
67573: LD_INT 2
67575: PPUSH
67576: CALL 55868 0 2
67580: PUSH
67581: LD_INT 1
67583: ARRAY
67584: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67585: LD_ADDR_VAR 0 2
67589: PUSH
67590: LD_VAR 0 2
67594: PPUSH
67595: LD_INT 2
67597: PPUSH
67598: LD_VAR 0 11
67602: PPUSH
67603: CALL_OW 1
67607: ST_TO_ADDR
// tmp := tmp diff p ;
67608: LD_ADDR_VAR 0 4
67612: PUSH
67613: LD_VAR 0 4
67617: PUSH
67618: LD_VAR 0 11
67622: DIFF
67623: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67624: LD_VAR 0 4
67628: PUSH
67629: LD_VAR 0 8
67633: PUSH
67634: LD_INT 6
67636: LESS
67637: AND
67638: IFFALSE 67826
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67640: LD_ADDR_VAR 0 9
67644: PUSH
67645: LD_VAR 0 4
67649: PUSH
67650: LD_VAR 0 8
67654: PUSH
67655: LD_VAR 0 7
67659: UNION
67660: DIFF
67661: PPUSH
67662: LD_INT 4
67664: PPUSH
67665: CALL 55868 0 2
67669: ST_TO_ADDR
// p := [ ] ;
67670: LD_ADDR_VAR 0 11
67674: PUSH
67675: EMPTY
67676: ST_TO_ADDR
// if sort then
67677: LD_VAR 0 9
67681: IFFALSE 67797
// for i = 1 to 6 - sci do
67683: LD_ADDR_VAR 0 3
67687: PUSH
67688: DOUBLE
67689: LD_INT 1
67691: DEC
67692: ST_TO_ADDR
67693: LD_INT 6
67695: PUSH
67696: LD_VAR 0 8
67700: MINUS
67701: PUSH
67702: FOR_TO
67703: IFFALSE 67795
// begin if i = sort then
67705: LD_VAR 0 3
67709: PUSH
67710: LD_VAR 0 9
67714: EQUAL
67715: IFFALSE 67719
// break ;
67717: GO 67795
// if GetClass ( i ) = 4 then
67719: LD_VAR 0 3
67723: PPUSH
67724: CALL_OW 257
67728: PUSH
67729: LD_INT 4
67731: EQUAL
67732: IFFALSE 67736
// continue ;
67734: GO 67702
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67736: LD_ADDR_VAR 0 11
67740: PUSH
67741: LD_VAR 0 11
67745: PPUSH
67746: LD_VAR 0 11
67750: PUSH
67751: LD_INT 1
67753: PLUS
67754: PPUSH
67755: LD_VAR 0 9
67759: PUSH
67760: LD_VAR 0 3
67764: ARRAY
67765: PPUSH
67766: CALL_OW 2
67770: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67771: LD_ADDR_VAR 0 4
67775: PUSH
67776: LD_VAR 0 4
67780: PUSH
67781: LD_VAR 0 9
67785: PUSH
67786: LD_VAR 0 3
67790: ARRAY
67791: DIFF
67792: ST_TO_ADDR
// end ;
67793: GO 67702
67795: POP
67796: POP
// if p then
67797: LD_VAR 0 11
67801: IFFALSE 67826
// result := Replace ( result , 4 , p ) ;
67803: LD_ADDR_VAR 0 2
67807: PUSH
67808: LD_VAR 0 2
67812: PPUSH
67813: LD_INT 4
67815: PPUSH
67816: LD_VAR 0 11
67820: PPUSH
67821: CALL_OW 1
67825: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67826: LD_VAR 0 4
67830: PUSH
67831: LD_VAR 0 7
67835: PUSH
67836: LD_INT 6
67838: LESS
67839: AND
67840: IFFALSE 68028
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67842: LD_ADDR_VAR 0 9
67846: PUSH
67847: LD_VAR 0 4
67851: PUSH
67852: LD_VAR 0 8
67856: PUSH
67857: LD_VAR 0 7
67861: UNION
67862: DIFF
67863: PPUSH
67864: LD_INT 3
67866: PPUSH
67867: CALL 55868 0 2
67871: ST_TO_ADDR
// p := [ ] ;
67872: LD_ADDR_VAR 0 11
67876: PUSH
67877: EMPTY
67878: ST_TO_ADDR
// if sort then
67879: LD_VAR 0 9
67883: IFFALSE 67999
// for i = 1 to 6 - mech do
67885: LD_ADDR_VAR 0 3
67889: PUSH
67890: DOUBLE
67891: LD_INT 1
67893: DEC
67894: ST_TO_ADDR
67895: LD_INT 6
67897: PUSH
67898: LD_VAR 0 7
67902: MINUS
67903: PUSH
67904: FOR_TO
67905: IFFALSE 67997
// begin if i = sort then
67907: LD_VAR 0 3
67911: PUSH
67912: LD_VAR 0 9
67916: EQUAL
67917: IFFALSE 67921
// break ;
67919: GO 67997
// if GetClass ( i ) = 3 then
67921: LD_VAR 0 3
67925: PPUSH
67926: CALL_OW 257
67930: PUSH
67931: LD_INT 3
67933: EQUAL
67934: IFFALSE 67938
// continue ;
67936: GO 67904
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67938: LD_ADDR_VAR 0 11
67942: PUSH
67943: LD_VAR 0 11
67947: PPUSH
67948: LD_VAR 0 11
67952: PUSH
67953: LD_INT 1
67955: PLUS
67956: PPUSH
67957: LD_VAR 0 9
67961: PUSH
67962: LD_VAR 0 3
67966: ARRAY
67967: PPUSH
67968: CALL_OW 2
67972: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67973: LD_ADDR_VAR 0 4
67977: PUSH
67978: LD_VAR 0 4
67982: PUSH
67983: LD_VAR 0 9
67987: PUSH
67988: LD_VAR 0 3
67992: ARRAY
67993: DIFF
67994: ST_TO_ADDR
// end ;
67995: GO 67904
67997: POP
67998: POP
// if p then
67999: LD_VAR 0 11
68003: IFFALSE 68028
// result := Replace ( result , 3 , p ) ;
68005: LD_ADDR_VAR 0 2
68009: PUSH
68010: LD_VAR 0 2
68014: PPUSH
68015: LD_INT 3
68017: PPUSH
68018: LD_VAR 0 11
68022: PPUSH
68023: CALL_OW 1
68027: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
68028: LD_VAR 0 4
68032: PUSH
68033: LD_INT 6
68035: GREATER
68036: PUSH
68037: LD_VAR 0 6
68041: PUSH
68042: LD_INT 6
68044: LESS
68045: AND
68046: IFFALSE 68240
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68048: LD_ADDR_VAR 0 9
68052: PUSH
68053: LD_VAR 0 4
68057: PUSH
68058: LD_VAR 0 8
68062: PUSH
68063: LD_VAR 0 7
68067: UNION
68068: PUSH
68069: LD_VAR 0 6
68073: UNION
68074: DIFF
68075: PPUSH
68076: LD_INT 2
68078: PPUSH
68079: CALL 55868 0 2
68083: ST_TO_ADDR
// p := [ ] ;
68084: LD_ADDR_VAR 0 11
68088: PUSH
68089: EMPTY
68090: ST_TO_ADDR
// if sort then
68091: LD_VAR 0 9
68095: IFFALSE 68211
// for i = 1 to 6 - eng do
68097: LD_ADDR_VAR 0 3
68101: PUSH
68102: DOUBLE
68103: LD_INT 1
68105: DEC
68106: ST_TO_ADDR
68107: LD_INT 6
68109: PUSH
68110: LD_VAR 0 6
68114: MINUS
68115: PUSH
68116: FOR_TO
68117: IFFALSE 68209
// begin if i = sort then
68119: LD_VAR 0 3
68123: PUSH
68124: LD_VAR 0 9
68128: EQUAL
68129: IFFALSE 68133
// break ;
68131: GO 68209
// if GetClass ( i ) = 2 then
68133: LD_VAR 0 3
68137: PPUSH
68138: CALL_OW 257
68142: PUSH
68143: LD_INT 2
68145: EQUAL
68146: IFFALSE 68150
// continue ;
68148: GO 68116
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68150: LD_ADDR_VAR 0 11
68154: PUSH
68155: LD_VAR 0 11
68159: PPUSH
68160: LD_VAR 0 11
68164: PUSH
68165: LD_INT 1
68167: PLUS
68168: PPUSH
68169: LD_VAR 0 9
68173: PUSH
68174: LD_VAR 0 3
68178: ARRAY
68179: PPUSH
68180: CALL_OW 2
68184: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68185: LD_ADDR_VAR 0 4
68189: PUSH
68190: LD_VAR 0 4
68194: PUSH
68195: LD_VAR 0 9
68199: PUSH
68200: LD_VAR 0 3
68204: ARRAY
68205: DIFF
68206: ST_TO_ADDR
// end ;
68207: GO 68116
68209: POP
68210: POP
// if p then
68211: LD_VAR 0 11
68215: IFFALSE 68240
// result := Replace ( result , 2 , p ) ;
68217: LD_ADDR_VAR 0 2
68221: PUSH
68222: LD_VAR 0 2
68226: PPUSH
68227: LD_INT 2
68229: PPUSH
68230: LD_VAR 0 11
68234: PPUSH
68235: CALL_OW 1
68239: ST_TO_ADDR
// end ; exit ;
68240: GO 69628
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
68242: LD_EXP 58
68246: PUSH
68247: LD_EXP 57
68251: PUSH
68252: LD_VAR 0 1
68256: ARRAY
68257: ARRAY
68258: NOT
68259: PUSH
68260: LD_EXP 31
68264: PUSH
68265: LD_VAR 0 1
68269: ARRAY
68270: PPUSH
68271: LD_INT 30
68273: PUSH
68274: LD_INT 3
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: PPUSH
68281: CALL_OW 72
68285: AND
68286: PUSH
68287: LD_EXP 36
68291: PUSH
68292: LD_VAR 0 1
68296: ARRAY
68297: AND
68298: IFFALSE 68906
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68300: LD_ADDR_EXP 73
68304: PUSH
68305: LD_EXP 73
68309: PPUSH
68310: LD_VAR 0 1
68314: PPUSH
68315: LD_INT 5
68317: PPUSH
68318: CALL_OW 1
68322: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68323: LD_ADDR_VAR 0 2
68327: PUSH
68328: LD_INT 0
68330: PUSH
68331: LD_INT 0
68333: PUSH
68334: LD_INT 0
68336: PUSH
68337: LD_INT 0
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: ST_TO_ADDR
// if sci > 1 then
68346: LD_VAR 0 8
68350: PUSH
68351: LD_INT 1
68353: GREATER
68354: IFFALSE 68382
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68356: LD_ADDR_VAR 0 4
68360: PUSH
68361: LD_VAR 0 4
68365: PUSH
68366: LD_VAR 0 8
68370: PUSH
68371: LD_VAR 0 8
68375: PUSH
68376: LD_INT 1
68378: ARRAY
68379: DIFF
68380: DIFF
68381: ST_TO_ADDR
// if tmp and not sci then
68382: LD_VAR 0 4
68386: PUSH
68387: LD_VAR 0 8
68391: NOT
68392: AND
68393: IFFALSE 68462
// begin sort := SortBySkill ( tmp , 4 ) ;
68395: LD_ADDR_VAR 0 9
68399: PUSH
68400: LD_VAR 0 4
68404: PPUSH
68405: LD_INT 4
68407: PPUSH
68408: CALL 55868 0 2
68412: ST_TO_ADDR
// if sort then
68413: LD_VAR 0 9
68417: IFFALSE 68433
// p := sort [ 1 ] ;
68419: LD_ADDR_VAR 0 11
68423: PUSH
68424: LD_VAR 0 9
68428: PUSH
68429: LD_INT 1
68431: ARRAY
68432: ST_TO_ADDR
// if p then
68433: LD_VAR 0 11
68437: IFFALSE 68462
// result := Replace ( result , 4 , p ) ;
68439: LD_ADDR_VAR 0 2
68443: PUSH
68444: LD_VAR 0 2
68448: PPUSH
68449: LD_INT 4
68451: PPUSH
68452: LD_VAR 0 11
68456: PPUSH
68457: CALL_OW 1
68461: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68462: LD_ADDR_VAR 0 4
68466: PUSH
68467: LD_VAR 0 4
68471: PUSH
68472: LD_VAR 0 7
68476: DIFF
68477: ST_TO_ADDR
// if tmp and mech < 6 then
68478: LD_VAR 0 4
68482: PUSH
68483: LD_VAR 0 7
68487: PUSH
68488: LD_INT 6
68490: LESS
68491: AND
68492: IFFALSE 68680
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68494: LD_ADDR_VAR 0 9
68498: PUSH
68499: LD_VAR 0 4
68503: PUSH
68504: LD_VAR 0 8
68508: PUSH
68509: LD_VAR 0 7
68513: UNION
68514: DIFF
68515: PPUSH
68516: LD_INT 3
68518: PPUSH
68519: CALL 55868 0 2
68523: ST_TO_ADDR
// p := [ ] ;
68524: LD_ADDR_VAR 0 11
68528: PUSH
68529: EMPTY
68530: ST_TO_ADDR
// if sort then
68531: LD_VAR 0 9
68535: IFFALSE 68651
// for i = 1 to 6 - mech do
68537: LD_ADDR_VAR 0 3
68541: PUSH
68542: DOUBLE
68543: LD_INT 1
68545: DEC
68546: ST_TO_ADDR
68547: LD_INT 6
68549: PUSH
68550: LD_VAR 0 7
68554: MINUS
68555: PUSH
68556: FOR_TO
68557: IFFALSE 68649
// begin if i = sort then
68559: LD_VAR 0 3
68563: PUSH
68564: LD_VAR 0 9
68568: EQUAL
68569: IFFALSE 68573
// break ;
68571: GO 68649
// if GetClass ( i ) = 3 then
68573: LD_VAR 0 3
68577: PPUSH
68578: CALL_OW 257
68582: PUSH
68583: LD_INT 3
68585: EQUAL
68586: IFFALSE 68590
// continue ;
68588: GO 68556
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68590: LD_ADDR_VAR 0 11
68594: PUSH
68595: LD_VAR 0 11
68599: PPUSH
68600: LD_VAR 0 11
68604: PUSH
68605: LD_INT 1
68607: PLUS
68608: PPUSH
68609: LD_VAR 0 9
68613: PUSH
68614: LD_VAR 0 3
68618: ARRAY
68619: PPUSH
68620: CALL_OW 2
68624: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68625: LD_ADDR_VAR 0 4
68629: PUSH
68630: LD_VAR 0 4
68634: PUSH
68635: LD_VAR 0 9
68639: PUSH
68640: LD_VAR 0 3
68644: ARRAY
68645: DIFF
68646: ST_TO_ADDR
// end ;
68647: GO 68556
68649: POP
68650: POP
// if p then
68651: LD_VAR 0 11
68655: IFFALSE 68680
// result := Replace ( result , 3 , p ) ;
68657: LD_ADDR_VAR 0 2
68661: PUSH
68662: LD_VAR 0 2
68666: PPUSH
68667: LD_INT 3
68669: PPUSH
68670: LD_VAR 0 11
68674: PPUSH
68675: CALL_OW 1
68679: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68680: LD_ADDR_VAR 0 4
68684: PUSH
68685: LD_VAR 0 4
68689: PUSH
68690: LD_VAR 0 6
68694: DIFF
68695: ST_TO_ADDR
// if tmp and eng < 6 then
68696: LD_VAR 0 4
68700: PUSH
68701: LD_VAR 0 6
68705: PUSH
68706: LD_INT 6
68708: LESS
68709: AND
68710: IFFALSE 68904
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68712: LD_ADDR_VAR 0 9
68716: PUSH
68717: LD_VAR 0 4
68721: PUSH
68722: LD_VAR 0 8
68726: PUSH
68727: LD_VAR 0 7
68731: UNION
68732: PUSH
68733: LD_VAR 0 6
68737: UNION
68738: DIFF
68739: PPUSH
68740: LD_INT 2
68742: PPUSH
68743: CALL 55868 0 2
68747: ST_TO_ADDR
// p := [ ] ;
68748: LD_ADDR_VAR 0 11
68752: PUSH
68753: EMPTY
68754: ST_TO_ADDR
// if sort then
68755: LD_VAR 0 9
68759: IFFALSE 68875
// for i = 1 to 6 - eng do
68761: LD_ADDR_VAR 0 3
68765: PUSH
68766: DOUBLE
68767: LD_INT 1
68769: DEC
68770: ST_TO_ADDR
68771: LD_INT 6
68773: PUSH
68774: LD_VAR 0 6
68778: MINUS
68779: PUSH
68780: FOR_TO
68781: IFFALSE 68873
// begin if i = sort then
68783: LD_VAR 0 3
68787: PUSH
68788: LD_VAR 0 9
68792: EQUAL
68793: IFFALSE 68797
// break ;
68795: GO 68873
// if GetClass ( i ) = 2 then
68797: LD_VAR 0 3
68801: PPUSH
68802: CALL_OW 257
68806: PUSH
68807: LD_INT 2
68809: EQUAL
68810: IFFALSE 68814
// continue ;
68812: GO 68780
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68814: LD_ADDR_VAR 0 11
68818: PUSH
68819: LD_VAR 0 11
68823: PPUSH
68824: LD_VAR 0 11
68828: PUSH
68829: LD_INT 1
68831: PLUS
68832: PPUSH
68833: LD_VAR 0 9
68837: PUSH
68838: LD_VAR 0 3
68842: ARRAY
68843: PPUSH
68844: CALL_OW 2
68848: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68849: LD_ADDR_VAR 0 4
68853: PUSH
68854: LD_VAR 0 4
68858: PUSH
68859: LD_VAR 0 9
68863: PUSH
68864: LD_VAR 0 3
68868: ARRAY
68869: DIFF
68870: ST_TO_ADDR
// end ;
68871: GO 68780
68873: POP
68874: POP
// if p then
68875: LD_VAR 0 11
68879: IFFALSE 68904
// result := Replace ( result , 2 , p ) ;
68881: LD_ADDR_VAR 0 2
68885: PUSH
68886: LD_VAR 0 2
68890: PPUSH
68891: LD_INT 2
68893: PPUSH
68894: LD_VAR 0 11
68898: PPUSH
68899: CALL_OW 1
68903: ST_TO_ADDR
// end ; exit ;
68904: GO 69628
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
68906: LD_EXP 58
68910: PUSH
68911: LD_EXP 57
68915: PUSH
68916: LD_VAR 0 1
68920: ARRAY
68921: ARRAY
68922: NOT
68923: PUSH
68924: LD_EXP 31
68928: PUSH
68929: LD_VAR 0 1
68933: ARRAY
68934: PPUSH
68935: LD_INT 30
68937: PUSH
68938: LD_INT 3
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PPUSH
68945: CALL_OW 72
68949: AND
68950: PUSH
68951: LD_EXP 36
68955: PUSH
68956: LD_VAR 0 1
68960: ARRAY
68961: NOT
68962: AND
68963: IFFALSE 69628
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
68965: LD_ADDR_EXP 73
68969: PUSH
68970: LD_EXP 73
68974: PPUSH
68975: LD_VAR 0 1
68979: PPUSH
68980: LD_INT 6
68982: PPUSH
68983: CALL_OW 1
68987: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68988: LD_ADDR_VAR 0 2
68992: PUSH
68993: LD_INT 0
68995: PUSH
68996: LD_INT 0
68998: PUSH
68999: LD_INT 0
69001: PUSH
69002: LD_INT 0
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: ST_TO_ADDR
// if sci >= 1 then
69011: LD_VAR 0 8
69015: PUSH
69016: LD_INT 1
69018: GREATEREQUAL
69019: IFFALSE 69041
// tmp := tmp diff sci [ 1 ] ;
69021: LD_ADDR_VAR 0 4
69025: PUSH
69026: LD_VAR 0 4
69030: PUSH
69031: LD_VAR 0 8
69035: PUSH
69036: LD_INT 1
69038: ARRAY
69039: DIFF
69040: ST_TO_ADDR
// if tmp and not sci then
69041: LD_VAR 0 4
69045: PUSH
69046: LD_VAR 0 8
69050: NOT
69051: AND
69052: IFFALSE 69121
// begin sort := SortBySkill ( tmp , 4 ) ;
69054: LD_ADDR_VAR 0 9
69058: PUSH
69059: LD_VAR 0 4
69063: PPUSH
69064: LD_INT 4
69066: PPUSH
69067: CALL 55868 0 2
69071: ST_TO_ADDR
// if sort then
69072: LD_VAR 0 9
69076: IFFALSE 69092
// p := sort [ 1 ] ;
69078: LD_ADDR_VAR 0 11
69082: PUSH
69083: LD_VAR 0 9
69087: PUSH
69088: LD_INT 1
69090: ARRAY
69091: ST_TO_ADDR
// if p then
69092: LD_VAR 0 11
69096: IFFALSE 69121
// result := Replace ( result , 4 , p ) ;
69098: LD_ADDR_VAR 0 2
69102: PUSH
69103: LD_VAR 0 2
69107: PPUSH
69108: LD_INT 4
69110: PPUSH
69111: LD_VAR 0 11
69115: PPUSH
69116: CALL_OW 1
69120: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69121: LD_ADDR_VAR 0 4
69125: PUSH
69126: LD_VAR 0 4
69130: PUSH
69131: LD_VAR 0 7
69135: DIFF
69136: ST_TO_ADDR
// if tmp and mech < 6 then
69137: LD_VAR 0 4
69141: PUSH
69142: LD_VAR 0 7
69146: PUSH
69147: LD_INT 6
69149: LESS
69150: AND
69151: IFFALSE 69333
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
69153: LD_ADDR_VAR 0 9
69157: PUSH
69158: LD_VAR 0 4
69162: PUSH
69163: LD_VAR 0 7
69167: DIFF
69168: PPUSH
69169: LD_INT 3
69171: PPUSH
69172: CALL 55868 0 2
69176: ST_TO_ADDR
// p := [ ] ;
69177: LD_ADDR_VAR 0 11
69181: PUSH
69182: EMPTY
69183: ST_TO_ADDR
// if sort then
69184: LD_VAR 0 9
69188: IFFALSE 69304
// for i = 1 to 6 - mech do
69190: LD_ADDR_VAR 0 3
69194: PUSH
69195: DOUBLE
69196: LD_INT 1
69198: DEC
69199: ST_TO_ADDR
69200: LD_INT 6
69202: PUSH
69203: LD_VAR 0 7
69207: MINUS
69208: PUSH
69209: FOR_TO
69210: IFFALSE 69302
// begin if i = sort then
69212: LD_VAR 0 3
69216: PUSH
69217: LD_VAR 0 9
69221: EQUAL
69222: IFFALSE 69226
// break ;
69224: GO 69302
// if GetClass ( i ) = 3 then
69226: LD_VAR 0 3
69230: PPUSH
69231: CALL_OW 257
69235: PUSH
69236: LD_INT 3
69238: EQUAL
69239: IFFALSE 69243
// continue ;
69241: GO 69209
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69243: LD_ADDR_VAR 0 11
69247: PUSH
69248: LD_VAR 0 11
69252: PPUSH
69253: LD_VAR 0 11
69257: PUSH
69258: LD_INT 1
69260: PLUS
69261: PPUSH
69262: LD_VAR 0 9
69266: PUSH
69267: LD_VAR 0 3
69271: ARRAY
69272: PPUSH
69273: CALL_OW 2
69277: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69278: LD_ADDR_VAR 0 4
69282: PUSH
69283: LD_VAR 0 4
69287: PUSH
69288: LD_VAR 0 9
69292: PUSH
69293: LD_VAR 0 3
69297: ARRAY
69298: DIFF
69299: ST_TO_ADDR
// end ;
69300: GO 69209
69302: POP
69303: POP
// if p then
69304: LD_VAR 0 11
69308: IFFALSE 69333
// result := Replace ( result , 3 , p ) ;
69310: LD_ADDR_VAR 0 2
69314: PUSH
69315: LD_VAR 0 2
69319: PPUSH
69320: LD_INT 3
69322: PPUSH
69323: LD_VAR 0 11
69327: PPUSH
69328: CALL_OW 1
69332: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69333: LD_ADDR_VAR 0 4
69337: PUSH
69338: LD_VAR 0 4
69342: PUSH
69343: LD_VAR 0 6
69347: DIFF
69348: ST_TO_ADDR
// if tmp and eng < 4 then
69349: LD_VAR 0 4
69353: PUSH
69354: LD_VAR 0 6
69358: PUSH
69359: LD_INT 4
69361: LESS
69362: AND
69363: IFFALSE 69553
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69365: LD_ADDR_VAR 0 9
69369: PUSH
69370: LD_VAR 0 4
69374: PUSH
69375: LD_VAR 0 7
69379: PUSH
69380: LD_VAR 0 6
69384: UNION
69385: DIFF
69386: PPUSH
69387: LD_INT 2
69389: PPUSH
69390: CALL 55868 0 2
69394: ST_TO_ADDR
// p := [ ] ;
69395: LD_ADDR_VAR 0 11
69399: PUSH
69400: EMPTY
69401: ST_TO_ADDR
// if sort then
69402: LD_VAR 0 9
69406: IFFALSE 69522
// for i = 1 to 4 - eng do
69408: LD_ADDR_VAR 0 3
69412: PUSH
69413: DOUBLE
69414: LD_INT 1
69416: DEC
69417: ST_TO_ADDR
69418: LD_INT 4
69420: PUSH
69421: LD_VAR 0 6
69425: MINUS
69426: PUSH
69427: FOR_TO
69428: IFFALSE 69520
// begin if i = sort then
69430: LD_VAR 0 3
69434: PUSH
69435: LD_VAR 0 9
69439: EQUAL
69440: IFFALSE 69444
// break ;
69442: GO 69520
// if GetClass ( i ) = 2 then
69444: LD_VAR 0 3
69448: PPUSH
69449: CALL_OW 257
69453: PUSH
69454: LD_INT 2
69456: EQUAL
69457: IFFALSE 69461
// continue ;
69459: GO 69427
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69461: LD_ADDR_VAR 0 11
69465: PUSH
69466: LD_VAR 0 11
69470: PPUSH
69471: LD_VAR 0 11
69475: PUSH
69476: LD_INT 1
69478: PLUS
69479: PPUSH
69480: LD_VAR 0 9
69484: PUSH
69485: LD_VAR 0 3
69489: ARRAY
69490: PPUSH
69491: CALL_OW 2
69495: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69496: LD_ADDR_VAR 0 4
69500: PUSH
69501: LD_VAR 0 4
69505: PUSH
69506: LD_VAR 0 9
69510: PUSH
69511: LD_VAR 0 3
69515: ARRAY
69516: DIFF
69517: ST_TO_ADDR
// end ;
69518: GO 69427
69520: POP
69521: POP
// if p then
69522: LD_VAR 0 11
69526: IFFALSE 69551
// result := Replace ( result , 2 , p ) ;
69528: LD_ADDR_VAR 0 2
69532: PUSH
69533: LD_VAR 0 2
69537: PPUSH
69538: LD_INT 2
69540: PPUSH
69541: LD_VAR 0 11
69545: PPUSH
69546: CALL_OW 1
69550: ST_TO_ADDR
// end else
69551: GO 69597
// for i = eng downto 5 do
69553: LD_ADDR_VAR 0 3
69557: PUSH
69558: DOUBLE
69559: LD_VAR 0 6
69563: INC
69564: ST_TO_ADDR
69565: LD_INT 5
69567: PUSH
69568: FOR_DOWNTO
69569: IFFALSE 69595
// tmp := tmp union eng [ i ] ;
69571: LD_ADDR_VAR 0 4
69575: PUSH
69576: LD_VAR 0 4
69580: PUSH
69581: LD_VAR 0 6
69585: PUSH
69586: LD_VAR 0 3
69590: ARRAY
69591: UNION
69592: ST_TO_ADDR
69593: GO 69568
69595: POP
69596: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69597: LD_ADDR_VAR 0 2
69601: PUSH
69602: LD_VAR 0 2
69606: PPUSH
69607: LD_INT 1
69609: PPUSH
69610: LD_VAR 0 4
69614: PUSH
69615: LD_VAR 0 5
69619: DIFF
69620: PPUSH
69621: CALL_OW 1
69625: ST_TO_ADDR
// exit ;
69626: GO 69628
// end ; end ;
69628: LD_VAR 0 2
69632: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69633: LD_INT 0
69635: PPUSH
69636: PPUSH
69637: PPUSH
// if not mc_bases then
69638: LD_EXP 31
69642: NOT
69643: IFFALSE 69647
// exit ;
69645: GO 69789
// for i = 1 to mc_bases do
69647: LD_ADDR_VAR 0 2
69651: PUSH
69652: DOUBLE
69653: LD_INT 1
69655: DEC
69656: ST_TO_ADDR
69657: LD_EXP 31
69661: PUSH
69662: FOR_TO
69663: IFFALSE 69780
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69665: LD_ADDR_VAR 0 3
69669: PUSH
69670: LD_EXP 31
69674: PUSH
69675: LD_VAR 0 2
69679: ARRAY
69680: PPUSH
69681: LD_INT 21
69683: PUSH
69684: LD_INT 3
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 3
69693: PUSH
69694: LD_INT 2
69696: PUSH
69697: LD_INT 30
69699: PUSH
69700: LD_INT 29
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PUSH
69707: LD_INT 30
69709: PUSH
69710: LD_INT 30
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: LIST
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 3
69728: PUSH
69729: LD_INT 24
69731: PUSH
69732: LD_INT 1000
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: LIST
69747: PPUSH
69748: CALL_OW 72
69752: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69753: LD_ADDR_EXP 32
69757: PUSH
69758: LD_EXP 32
69762: PPUSH
69763: LD_VAR 0 2
69767: PPUSH
69768: LD_VAR 0 3
69772: PPUSH
69773: CALL_OW 1
69777: ST_TO_ADDR
// end ;
69778: GO 69662
69780: POP
69781: POP
// RaiseSailEvent ( 101 ) ;
69782: LD_INT 101
69784: PPUSH
69785: CALL_OW 427
// end ;
69789: LD_VAR 0 1
69793: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69794: LD_INT 0
69796: PPUSH
69797: PPUSH
69798: PPUSH
69799: PPUSH
69800: PPUSH
69801: PPUSH
69802: PPUSH
// if not mc_bases then
69803: LD_EXP 31
69807: NOT
69808: IFFALSE 69812
// exit ;
69810: GO 70374
// for i = 1 to mc_bases do
69812: LD_ADDR_VAR 0 2
69816: PUSH
69817: DOUBLE
69818: LD_INT 1
69820: DEC
69821: ST_TO_ADDR
69822: LD_EXP 31
69826: PUSH
69827: FOR_TO
69828: IFFALSE 70365
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69830: LD_ADDR_VAR 0 5
69834: PUSH
69835: LD_EXP 31
69839: PUSH
69840: LD_VAR 0 2
69844: ARRAY
69845: PUSH
69846: LD_EXP 60
69850: PUSH
69851: LD_VAR 0 2
69855: ARRAY
69856: UNION
69857: PPUSH
69858: LD_INT 21
69860: PUSH
69861: LD_INT 1
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: LD_INT 1
69870: PUSH
69871: LD_INT 3
69873: PUSH
69874: LD_INT 54
69876: PUSH
69877: EMPTY
69878: LIST
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 3
69886: PUSH
69887: LD_INT 24
69889: PUSH
69890: LD_INT 1000
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: LIST
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PPUSH
69910: CALL_OW 72
69914: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
69915: LD_ADDR_VAR 0 6
69919: PUSH
69920: LD_EXP 31
69924: PUSH
69925: LD_VAR 0 2
69929: ARRAY
69930: PPUSH
69931: LD_INT 21
69933: PUSH
69934: LD_INT 1
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 1
69943: PUSH
69944: LD_INT 3
69946: PUSH
69947: LD_INT 54
69949: PUSH
69950: EMPTY
69951: LIST
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 3
69959: PUSH
69960: LD_INT 24
69962: PUSH
69963: LD_INT 250
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: EMPTY
69975: LIST
69976: LIST
69977: LIST
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PPUSH
69983: CALL_OW 72
69987: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
69988: LD_ADDR_VAR 0 7
69992: PUSH
69993: LD_VAR 0 5
69997: PUSH
69998: LD_VAR 0 6
70002: DIFF
70003: ST_TO_ADDR
// if not need_heal_1 then
70004: LD_VAR 0 6
70008: NOT
70009: IFFALSE 70042
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
70011: LD_ADDR_EXP 34
70015: PUSH
70016: LD_EXP 34
70020: PPUSH
70021: LD_VAR 0 2
70025: PUSH
70026: LD_INT 1
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PPUSH
70033: EMPTY
70034: PPUSH
70035: CALL 25021 0 3
70039: ST_TO_ADDR
70040: GO 70112
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
70042: LD_ADDR_EXP 34
70046: PUSH
70047: LD_EXP 34
70051: PPUSH
70052: LD_VAR 0 2
70056: PUSH
70057: LD_INT 1
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: PPUSH
70064: LD_EXP 34
70068: PUSH
70069: LD_VAR 0 2
70073: ARRAY
70074: PUSH
70075: LD_INT 1
70077: ARRAY
70078: PPUSH
70079: LD_INT 3
70081: PUSH
70082: LD_INT 24
70084: PUSH
70085: LD_INT 1000
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PPUSH
70096: CALL_OW 72
70100: PUSH
70101: LD_VAR 0 6
70105: UNION
70106: PPUSH
70107: CALL 25021 0 3
70111: ST_TO_ADDR
// if not need_heal_2 then
70112: LD_VAR 0 7
70116: NOT
70117: IFFALSE 70150
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
70119: LD_ADDR_EXP 34
70123: PUSH
70124: LD_EXP 34
70128: PPUSH
70129: LD_VAR 0 2
70133: PUSH
70134: LD_INT 2
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PPUSH
70141: EMPTY
70142: PPUSH
70143: CALL 25021 0 3
70147: ST_TO_ADDR
70148: GO 70182
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
70150: LD_ADDR_EXP 34
70154: PUSH
70155: LD_EXP 34
70159: PPUSH
70160: LD_VAR 0 2
70164: PUSH
70165: LD_INT 2
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: PPUSH
70172: LD_VAR 0 7
70176: PPUSH
70177: CALL 25021 0 3
70181: ST_TO_ADDR
// if need_heal_2 then
70182: LD_VAR 0 7
70186: IFFALSE 70347
// for j in need_heal_2 do
70188: LD_ADDR_VAR 0 3
70192: PUSH
70193: LD_VAR 0 7
70197: PUSH
70198: FOR_IN
70199: IFFALSE 70345
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70201: LD_ADDR_VAR 0 5
70205: PUSH
70206: LD_EXP 31
70210: PUSH
70211: LD_VAR 0 2
70215: ARRAY
70216: PPUSH
70217: LD_INT 2
70219: PUSH
70220: LD_INT 30
70222: PUSH
70223: LD_INT 6
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 30
70232: PUSH
70233: LD_INT 7
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 30
70242: PUSH
70243: LD_INT 8
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: LD_INT 30
70252: PUSH
70253: LD_INT 0
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 30
70262: PUSH
70263: LD_INT 1
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: PPUSH
70278: CALL_OW 72
70282: ST_TO_ADDR
// if tmp then
70283: LD_VAR 0 5
70287: IFFALSE 70343
// begin k := NearestUnitToUnit ( tmp , j ) ;
70289: LD_ADDR_VAR 0 4
70293: PUSH
70294: LD_VAR 0 5
70298: PPUSH
70299: LD_VAR 0 3
70303: PPUSH
70304: CALL_OW 74
70308: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70309: LD_VAR 0 3
70313: PPUSH
70314: LD_VAR 0 4
70318: PPUSH
70319: CALL_OW 296
70323: PUSH
70324: LD_INT 5
70326: GREATER
70327: IFFALSE 70343
// ComMoveToNearbyEntrance ( j , k ) ;
70329: LD_VAR 0 3
70333: PPUSH
70334: LD_VAR 0 4
70338: PPUSH
70339: CALL 58229 0 2
// end ; end ;
70343: GO 70198
70345: POP
70346: POP
// if not need_heal_1 and not need_heal_2 then
70347: LD_VAR 0 6
70351: NOT
70352: PUSH
70353: LD_VAR 0 7
70357: NOT
70358: AND
70359: IFFALSE 70363
// continue ;
70361: GO 69827
// end ;
70363: GO 69827
70365: POP
70366: POP
// RaiseSailEvent ( 102 ) ;
70367: LD_INT 102
70369: PPUSH
70370: CALL_OW 427
// end ;
70374: LD_VAR 0 1
70378: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70379: LD_INT 0
70381: PPUSH
70382: PPUSH
70383: PPUSH
70384: PPUSH
70385: PPUSH
70386: PPUSH
70387: PPUSH
70388: PPUSH
// if not mc_bases then
70389: LD_EXP 31
70393: NOT
70394: IFFALSE 70398
// exit ;
70396: GO 71309
// for i = 1 to mc_bases do
70398: LD_ADDR_VAR 0 2
70402: PUSH
70403: DOUBLE
70404: LD_INT 1
70406: DEC
70407: ST_TO_ADDR
70408: LD_EXP 31
70412: PUSH
70413: FOR_TO
70414: IFFALSE 71307
// begin if not mc_building_need_repair [ i ] then
70416: LD_EXP 32
70420: PUSH
70421: LD_VAR 0 2
70425: ARRAY
70426: NOT
70427: IFFALSE 70612
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70429: LD_ADDR_VAR 0 6
70433: PUSH
70434: LD_EXP 50
70438: PUSH
70439: LD_VAR 0 2
70443: ARRAY
70444: PPUSH
70445: LD_INT 3
70447: PUSH
70448: LD_INT 24
70450: PUSH
70451: LD_INT 1000
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PUSH
70462: LD_INT 2
70464: PUSH
70465: LD_INT 34
70467: PUSH
70468: LD_INT 13
70470: PUSH
70471: EMPTY
70472: LIST
70473: LIST
70474: PUSH
70475: LD_INT 34
70477: PUSH
70478: LD_INT 52
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 34
70487: PUSH
70488: LD_INT 88
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: LIST
70499: LIST
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PPUSH
70505: CALL_OW 72
70509: ST_TO_ADDR
// if cranes then
70510: LD_VAR 0 6
70514: IFFALSE 70576
// for j in cranes do
70516: LD_ADDR_VAR 0 3
70520: PUSH
70521: LD_VAR 0 6
70525: PUSH
70526: FOR_IN
70527: IFFALSE 70574
// if not IsInArea ( j , mc_parking [ i ] ) then
70529: LD_VAR 0 3
70533: PPUSH
70534: LD_EXP 55
70538: PUSH
70539: LD_VAR 0 2
70543: ARRAY
70544: PPUSH
70545: CALL_OW 308
70549: NOT
70550: IFFALSE 70572
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70552: LD_VAR 0 3
70556: PPUSH
70557: LD_EXP 55
70561: PUSH
70562: LD_VAR 0 2
70566: ARRAY
70567: PPUSH
70568: CALL_OW 113
70572: GO 70526
70574: POP
70575: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70576: LD_ADDR_EXP 33
70580: PUSH
70581: LD_EXP 33
70585: PPUSH
70586: LD_VAR 0 2
70590: PPUSH
70591: EMPTY
70592: PPUSH
70593: CALL_OW 1
70597: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70598: LD_VAR 0 2
70602: PPUSH
70603: LD_INT 101
70605: PPUSH
70606: CALL 65466 0 2
// continue ;
70610: GO 70413
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70612: LD_ADDR_EXP 37
70616: PUSH
70617: LD_EXP 37
70621: PPUSH
70622: LD_VAR 0 2
70626: PPUSH
70627: EMPTY
70628: PPUSH
70629: CALL_OW 1
70633: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70634: LD_VAR 0 2
70638: PPUSH
70639: LD_INT 103
70641: PPUSH
70642: CALL 65466 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70646: LD_ADDR_VAR 0 5
70650: PUSH
70651: LD_EXP 31
70655: PUSH
70656: LD_VAR 0 2
70660: ARRAY
70661: PUSH
70662: LD_EXP 60
70666: PUSH
70667: LD_VAR 0 2
70671: ARRAY
70672: UNION
70673: PPUSH
70674: LD_INT 2
70676: PUSH
70677: LD_INT 25
70679: PUSH
70680: LD_INT 2
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 25
70689: PUSH
70690: LD_INT 16
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: LIST
70701: PUSH
70702: EMPTY
70703: LIST
70704: PPUSH
70705: CALL_OW 72
70709: ST_TO_ADDR
// if mc_need_heal [ i ] then
70710: LD_EXP 34
70714: PUSH
70715: LD_VAR 0 2
70719: ARRAY
70720: IFFALSE 70764
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70722: LD_ADDR_VAR 0 5
70726: PUSH
70727: LD_VAR 0 5
70731: PUSH
70732: LD_EXP 34
70736: PUSH
70737: LD_VAR 0 2
70741: ARRAY
70742: PUSH
70743: LD_INT 1
70745: ARRAY
70746: PUSH
70747: LD_EXP 34
70751: PUSH
70752: LD_VAR 0 2
70756: ARRAY
70757: PUSH
70758: LD_INT 2
70760: ARRAY
70761: UNION
70762: DIFF
70763: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70764: LD_ADDR_VAR 0 6
70768: PUSH
70769: LD_EXP 50
70773: PUSH
70774: LD_VAR 0 2
70778: ARRAY
70779: PPUSH
70780: LD_INT 2
70782: PUSH
70783: LD_INT 34
70785: PUSH
70786: LD_INT 13
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: PUSH
70793: LD_INT 34
70795: PUSH
70796: LD_INT 52
70798: PUSH
70799: EMPTY
70800: LIST
70801: LIST
70802: PUSH
70803: LD_INT 34
70805: PUSH
70806: LD_INT 88
70808: PUSH
70809: EMPTY
70810: LIST
70811: LIST
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: PPUSH
70819: CALL_OW 72
70823: ST_TO_ADDR
// if cranes then
70824: LD_VAR 0 6
70828: IFFALSE 70996
// begin for j in cranes do
70830: LD_ADDR_VAR 0 3
70834: PUSH
70835: LD_VAR 0 6
70839: PUSH
70840: FOR_IN
70841: IFFALSE 70994
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70843: LD_VAR 0 3
70847: PPUSH
70848: CALL_OW 256
70852: PUSH
70853: LD_INT 1000
70855: EQUAL
70856: PUSH
70857: LD_VAR 0 3
70861: PPUSH
70862: CALL_OW 314
70866: NOT
70867: AND
70868: IFFALSE 70934
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
70870: LD_ADDR_VAR 0 8
70874: PUSH
70875: LD_EXP 32
70879: PUSH
70880: LD_VAR 0 2
70884: ARRAY
70885: PPUSH
70886: LD_VAR 0 3
70890: PPUSH
70891: CALL_OW 74
70895: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
70896: LD_VAR 0 8
70900: PPUSH
70901: LD_INT 16
70903: PPUSH
70904: CALL 27618 0 2
70908: PUSH
70909: LD_INT 4
70911: ARRAY
70912: PUSH
70913: LD_INT 10
70915: LESS
70916: IFFALSE 70932
// ComRepairBuilding ( j , to_repair ) ;
70918: LD_VAR 0 3
70922: PPUSH
70923: LD_VAR 0 8
70927: PPUSH
70928: CALL_OW 130
// end else
70932: GO 70992
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
70934: LD_VAR 0 3
70938: PPUSH
70939: CALL_OW 256
70943: PUSH
70944: LD_INT 500
70946: LESS
70947: PUSH
70948: LD_VAR 0 3
70952: PPUSH
70953: LD_EXP 55
70957: PUSH
70958: LD_VAR 0 2
70962: ARRAY
70963: PPUSH
70964: CALL_OW 308
70968: NOT
70969: AND
70970: IFFALSE 70992
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70972: LD_VAR 0 3
70976: PPUSH
70977: LD_EXP 55
70981: PUSH
70982: LD_VAR 0 2
70986: ARRAY
70987: PPUSH
70988: CALL_OW 113
// end ;
70992: GO 70840
70994: POP
70995: POP
// end ; if tmp > 3 then
70996: LD_VAR 0 5
71000: PUSH
71001: LD_INT 3
71003: GREATER
71004: IFFALSE 71024
// tmp := ShrinkArray ( tmp , 4 ) ;
71006: LD_ADDR_VAR 0 5
71010: PUSH
71011: LD_VAR 0 5
71015: PPUSH
71016: LD_INT 4
71018: PPUSH
71019: CALL 57667 0 2
71023: ST_TO_ADDR
// if not tmp then
71024: LD_VAR 0 5
71028: NOT
71029: IFFALSE 71033
// continue ;
71031: GO 70413
// for j in tmp do
71033: LD_ADDR_VAR 0 3
71037: PUSH
71038: LD_VAR 0 5
71042: PUSH
71043: FOR_IN
71044: IFFALSE 71303
// begin if IsInUnit ( j ) then
71046: LD_VAR 0 3
71050: PPUSH
71051: CALL_OW 310
71055: IFFALSE 71066
// ComExitBuilding ( j ) ;
71057: LD_VAR 0 3
71061: PPUSH
71062: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
71066: LD_VAR 0 3
71070: PUSH
71071: LD_EXP 33
71075: PUSH
71076: LD_VAR 0 2
71080: ARRAY
71081: IN
71082: NOT
71083: IFFALSE 71141
// begin SetTag ( j , 101 ) ;
71085: LD_VAR 0 3
71089: PPUSH
71090: LD_INT 101
71092: PPUSH
71093: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
71097: LD_ADDR_EXP 33
71101: PUSH
71102: LD_EXP 33
71106: PPUSH
71107: LD_VAR 0 2
71111: PUSH
71112: LD_EXP 33
71116: PUSH
71117: LD_VAR 0 2
71121: ARRAY
71122: PUSH
71123: LD_INT 1
71125: PLUS
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: PPUSH
71131: LD_VAR 0 3
71135: PPUSH
71136: CALL 25021 0 3
71140: ST_TO_ADDR
// end ; wait ( 1 ) ;
71141: LD_INT 1
71143: PPUSH
71144: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
71148: LD_ADDR_VAR 0 7
71152: PUSH
71153: LD_EXP 32
71157: PUSH
71158: LD_VAR 0 2
71162: ARRAY
71163: ST_TO_ADDR
// if mc_scan [ i ] then
71164: LD_EXP 54
71168: PUSH
71169: LD_VAR 0 2
71173: ARRAY
71174: IFFALSE 71236
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
71176: LD_ADDR_VAR 0 7
71180: PUSH
71181: LD_EXP 32
71185: PUSH
71186: LD_VAR 0 2
71190: ARRAY
71191: PPUSH
71192: LD_INT 3
71194: PUSH
71195: LD_INT 30
71197: PUSH
71198: LD_INT 32
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 30
71207: PUSH
71208: LD_INT 33
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: PUSH
71215: LD_INT 30
71217: PUSH
71218: LD_INT 31
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: LIST
71229: LIST
71230: PPUSH
71231: CALL_OW 72
71235: ST_TO_ADDR
// if not to_repair_tmp then
71236: LD_VAR 0 7
71240: NOT
71241: IFFALSE 71245
// continue ;
71243: GO 71043
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
71245: LD_ADDR_VAR 0 8
71249: PUSH
71250: LD_VAR 0 7
71254: PPUSH
71255: LD_VAR 0 3
71259: PPUSH
71260: CALL_OW 74
71264: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
71265: LD_VAR 0 8
71269: PPUSH
71270: LD_INT 16
71272: PPUSH
71273: CALL 27618 0 2
71277: PUSH
71278: LD_INT 4
71280: ARRAY
71281: PUSH
71282: LD_INT 14
71284: LESS
71285: IFFALSE 71301
// ComRepairBuilding ( j , to_repair ) ;
71287: LD_VAR 0 3
71291: PPUSH
71292: LD_VAR 0 8
71296: PPUSH
71297: CALL_OW 130
// end ;
71301: GO 71043
71303: POP
71304: POP
// end ;
71305: GO 70413
71307: POP
71308: POP
// end ;
71309: LD_VAR 0 1
71313: RET
// export function MC_Heal ; var i , j , tmp ; begin
71314: LD_INT 0
71316: PPUSH
71317: PPUSH
71318: PPUSH
71319: PPUSH
// if not mc_bases then
71320: LD_EXP 31
71324: NOT
71325: IFFALSE 71329
// exit ;
71327: GO 71731
// for i = 1 to mc_bases do
71329: LD_ADDR_VAR 0 2
71333: PUSH
71334: DOUBLE
71335: LD_INT 1
71337: DEC
71338: ST_TO_ADDR
71339: LD_EXP 31
71343: PUSH
71344: FOR_TO
71345: IFFALSE 71729
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71347: LD_EXP 34
71351: PUSH
71352: LD_VAR 0 2
71356: ARRAY
71357: PUSH
71358: LD_INT 1
71360: ARRAY
71361: NOT
71362: PUSH
71363: LD_EXP 34
71367: PUSH
71368: LD_VAR 0 2
71372: ARRAY
71373: PUSH
71374: LD_INT 2
71376: ARRAY
71377: NOT
71378: AND
71379: IFFALSE 71417
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71381: LD_ADDR_EXP 35
71385: PUSH
71386: LD_EXP 35
71390: PPUSH
71391: LD_VAR 0 2
71395: PPUSH
71396: EMPTY
71397: PPUSH
71398: CALL_OW 1
71402: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71403: LD_VAR 0 2
71407: PPUSH
71408: LD_INT 102
71410: PPUSH
71411: CALL 65466 0 2
// continue ;
71415: GO 71344
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71417: LD_ADDR_VAR 0 4
71421: PUSH
71422: LD_EXP 31
71426: PUSH
71427: LD_VAR 0 2
71431: ARRAY
71432: PPUSH
71433: LD_INT 25
71435: PUSH
71436: LD_INT 4
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PPUSH
71443: CALL_OW 72
71447: ST_TO_ADDR
// if not tmp then
71448: LD_VAR 0 4
71452: NOT
71453: IFFALSE 71457
// continue ;
71455: GO 71344
// if mc_taming [ i ] then
71457: LD_EXP 62
71461: PUSH
71462: LD_VAR 0 2
71466: ARRAY
71467: IFFALSE 71491
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71469: LD_ADDR_EXP 62
71473: PUSH
71474: LD_EXP 62
71478: PPUSH
71479: LD_VAR 0 2
71483: PPUSH
71484: EMPTY
71485: PPUSH
71486: CALL_OW 1
71490: ST_TO_ADDR
// for j in tmp do
71491: LD_ADDR_VAR 0 3
71495: PUSH
71496: LD_VAR 0 4
71500: PUSH
71501: FOR_IN
71502: IFFALSE 71725
// begin if IsInUnit ( j ) then
71504: LD_VAR 0 3
71508: PPUSH
71509: CALL_OW 310
71513: IFFALSE 71524
// ComExitBuilding ( j ) ;
71515: LD_VAR 0 3
71519: PPUSH
71520: CALL_OW 122
// if not j in mc_healers [ i ] then
71524: LD_VAR 0 3
71528: PUSH
71529: LD_EXP 35
71533: PUSH
71534: LD_VAR 0 2
71538: ARRAY
71539: IN
71540: NOT
71541: IFFALSE 71587
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71543: LD_ADDR_EXP 35
71547: PUSH
71548: LD_EXP 35
71552: PPUSH
71553: LD_VAR 0 2
71557: PUSH
71558: LD_EXP 35
71562: PUSH
71563: LD_VAR 0 2
71567: ARRAY
71568: PUSH
71569: LD_INT 1
71571: PLUS
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PPUSH
71577: LD_VAR 0 3
71581: PPUSH
71582: CALL 25021 0 3
71586: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71587: LD_VAR 0 3
71591: PPUSH
71592: CALL_OW 110
71596: PUSH
71597: LD_INT 102
71599: NONEQUAL
71600: IFFALSE 71614
// SetTag ( j , 102 ) ;
71602: LD_VAR 0 3
71606: PPUSH
71607: LD_INT 102
71609: PPUSH
71610: CALL_OW 109
// Wait ( 3 ) ;
71614: LD_INT 3
71616: PPUSH
71617: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71621: LD_EXP 34
71625: PUSH
71626: LD_VAR 0 2
71630: ARRAY
71631: PUSH
71632: LD_INT 1
71634: ARRAY
71635: IFFALSE 71667
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71637: LD_VAR 0 3
71641: PPUSH
71642: LD_EXP 34
71646: PUSH
71647: LD_VAR 0 2
71651: ARRAY
71652: PUSH
71653: LD_INT 1
71655: ARRAY
71656: PUSH
71657: LD_INT 1
71659: ARRAY
71660: PPUSH
71661: CALL_OW 128
71665: GO 71723
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71667: LD_VAR 0 3
71671: PPUSH
71672: CALL_OW 314
71676: NOT
71677: PUSH
71678: LD_EXP 34
71682: PUSH
71683: LD_VAR 0 2
71687: ARRAY
71688: PUSH
71689: LD_INT 2
71691: ARRAY
71692: AND
71693: IFFALSE 71723
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71695: LD_VAR 0 3
71699: PPUSH
71700: LD_EXP 34
71704: PUSH
71705: LD_VAR 0 2
71709: ARRAY
71710: PUSH
71711: LD_INT 2
71713: ARRAY
71714: PUSH
71715: LD_INT 1
71717: ARRAY
71718: PPUSH
71719: CALL_OW 128
// end ;
71723: GO 71501
71725: POP
71726: POP
// end ;
71727: GO 71344
71729: POP
71730: POP
// end ;
71731: LD_VAR 0 1
71735: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
71736: LD_INT 0
71738: PPUSH
71739: PPUSH
71740: PPUSH
71741: PPUSH
71742: PPUSH
71743: PPUSH
// if not mc_bases then
71744: LD_EXP 31
71748: NOT
71749: IFFALSE 71753
// exit ;
71751: GO 72916
// for i = 1 to mc_bases do
71753: LD_ADDR_VAR 0 2
71757: PUSH
71758: DOUBLE
71759: LD_INT 1
71761: DEC
71762: ST_TO_ADDR
71763: LD_EXP 31
71767: PUSH
71768: FOR_TO
71769: IFFALSE 72914
// begin if mc_scan [ i ] then
71771: LD_EXP 54
71775: PUSH
71776: LD_VAR 0 2
71780: ARRAY
71781: IFFALSE 71785
// continue ;
71783: GO 71768
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71785: LD_EXP 36
71789: PUSH
71790: LD_VAR 0 2
71794: ARRAY
71795: NOT
71796: PUSH
71797: LD_EXP 38
71801: PUSH
71802: LD_VAR 0 2
71806: ARRAY
71807: NOT
71808: AND
71809: PUSH
71810: LD_EXP 37
71814: PUSH
71815: LD_VAR 0 2
71819: ARRAY
71820: AND
71821: IFFALSE 71859
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71823: LD_ADDR_EXP 37
71827: PUSH
71828: LD_EXP 37
71832: PPUSH
71833: LD_VAR 0 2
71837: PPUSH
71838: EMPTY
71839: PPUSH
71840: CALL_OW 1
71844: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71845: LD_VAR 0 2
71849: PPUSH
71850: LD_INT 103
71852: PPUSH
71853: CALL 65466 0 2
// continue ;
71857: GO 71768
// end ; if mc_construct_list [ i ] then
71859: LD_EXP 38
71863: PUSH
71864: LD_VAR 0 2
71868: ARRAY
71869: IFFALSE 72089
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71871: LD_ADDR_VAR 0 5
71875: PUSH
71876: LD_EXP 31
71880: PUSH
71881: LD_VAR 0 2
71885: ARRAY
71886: PPUSH
71887: LD_INT 25
71889: PUSH
71890: LD_INT 2
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: PPUSH
71897: CALL_OW 72
71901: PUSH
71902: LD_EXP 33
71906: PUSH
71907: LD_VAR 0 2
71911: ARRAY
71912: DIFF
71913: ST_TO_ADDR
// if not tmp then
71914: LD_VAR 0 5
71918: NOT
71919: IFFALSE 71923
// continue ;
71921: GO 71768
// for j in tmp do
71923: LD_ADDR_VAR 0 3
71927: PUSH
71928: LD_VAR 0 5
71932: PUSH
71933: FOR_IN
71934: IFFALSE 72085
// begin if not mc_builders [ i ] then
71936: LD_EXP 37
71940: PUSH
71941: LD_VAR 0 2
71945: ARRAY
71946: NOT
71947: IFFALSE 72005
// begin SetTag ( j , 103 ) ;
71949: LD_VAR 0 3
71953: PPUSH
71954: LD_INT 103
71956: PPUSH
71957: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71961: LD_ADDR_EXP 37
71965: PUSH
71966: LD_EXP 37
71970: PPUSH
71971: LD_VAR 0 2
71975: PUSH
71976: LD_EXP 37
71980: PUSH
71981: LD_VAR 0 2
71985: ARRAY
71986: PUSH
71987: LD_INT 1
71989: PLUS
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PPUSH
71995: LD_VAR 0 3
71999: PPUSH
72000: CALL 25021 0 3
72004: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72005: LD_VAR 0 3
72009: PPUSH
72010: CALL_OW 310
72014: IFFALSE 72025
// ComExitBuilding ( j ) ;
72016: LD_VAR 0 3
72020: PPUSH
72021: CALL_OW 122
// wait ( 3 ) ;
72025: LD_INT 3
72027: PPUSH
72028: CALL_OW 67
// if not mc_construct_list [ i ] then
72032: LD_EXP 38
72036: PUSH
72037: LD_VAR 0 2
72041: ARRAY
72042: NOT
72043: IFFALSE 72047
// break ;
72045: GO 72085
// if not HasTask ( j ) then
72047: LD_VAR 0 3
72051: PPUSH
72052: CALL_OW 314
72056: NOT
72057: IFFALSE 72083
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
72059: LD_VAR 0 3
72063: PPUSH
72064: LD_EXP 38
72068: PUSH
72069: LD_VAR 0 2
72073: ARRAY
72074: PUSH
72075: LD_INT 1
72077: ARRAY
72078: PPUSH
72079: CALL 27882 0 2
// end ;
72083: GO 71933
72085: POP
72086: POP
// end else
72087: GO 72912
// if mc_build_list [ i ] then
72089: LD_EXP 36
72093: PUSH
72094: LD_VAR 0 2
72098: ARRAY
72099: IFFALSE 72912
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
72101: LD_EXP 36
72105: PUSH
72106: LD_VAR 0 2
72110: ARRAY
72111: PUSH
72112: LD_INT 1
72114: ARRAY
72115: PUSH
72116: LD_INT 1
72118: ARRAY
72119: PPUSH
72120: CALL 27706 0 1
72124: PUSH
72125: LD_EXP 31
72129: PUSH
72130: LD_VAR 0 2
72134: ARRAY
72135: PPUSH
72136: LD_INT 2
72138: PUSH
72139: LD_INT 30
72141: PUSH
72142: LD_INT 2
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: PUSH
72149: LD_INT 30
72151: PUSH
72152: LD_INT 3
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: LIST
72163: PPUSH
72164: CALL_OW 72
72168: NOT
72169: AND
72170: IFFALSE 72275
// begin for j = 1 to mc_build_list [ i ] do
72172: LD_ADDR_VAR 0 3
72176: PUSH
72177: DOUBLE
72178: LD_INT 1
72180: DEC
72181: ST_TO_ADDR
72182: LD_EXP 36
72186: PUSH
72187: LD_VAR 0 2
72191: ARRAY
72192: PUSH
72193: FOR_TO
72194: IFFALSE 72273
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
72196: LD_EXP 36
72200: PUSH
72201: LD_VAR 0 2
72205: ARRAY
72206: PUSH
72207: LD_VAR 0 3
72211: ARRAY
72212: PUSH
72213: LD_INT 1
72215: ARRAY
72216: PUSH
72217: LD_INT 2
72219: EQUAL
72220: IFFALSE 72271
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72222: LD_ADDR_EXP 36
72226: PUSH
72227: LD_EXP 36
72231: PPUSH
72232: LD_VAR 0 2
72236: PPUSH
72237: LD_EXP 36
72241: PUSH
72242: LD_VAR 0 2
72246: ARRAY
72247: PPUSH
72248: LD_VAR 0 3
72252: PPUSH
72253: LD_INT 1
72255: PPUSH
72256: LD_INT 0
72258: PPUSH
72259: CALL 24439 0 4
72263: PPUSH
72264: CALL_OW 1
72268: ST_TO_ADDR
// break ;
72269: GO 72273
// end ;
72271: GO 72193
72273: POP
72274: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72275: LD_ADDR_VAR 0 6
72279: PUSH
72280: LD_EXP 31
72284: PUSH
72285: LD_VAR 0 2
72289: ARRAY
72290: PPUSH
72291: LD_INT 2
72293: PUSH
72294: LD_INT 30
72296: PUSH
72297: LD_INT 0
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 30
72306: PUSH
72307: LD_INT 1
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: LIST
72318: PPUSH
72319: CALL_OW 72
72323: ST_TO_ADDR
// for k := 1 to depot do
72324: LD_ADDR_VAR 0 4
72328: PUSH
72329: DOUBLE
72330: LD_INT 1
72332: DEC
72333: ST_TO_ADDR
72334: LD_VAR 0 6
72338: PUSH
72339: FOR_TO
72340: IFFALSE 72910
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
72342: LD_EXP 36
72346: PUSH
72347: LD_VAR 0 2
72351: ARRAY
72352: PUSH
72353: LD_INT 1
72355: ARRAY
72356: PUSH
72357: LD_INT 1
72359: ARRAY
72360: PUSH
72361: LD_INT 0
72363: EQUAL
72364: PUSH
72365: LD_VAR 0 6
72369: PUSH
72370: LD_VAR 0 4
72374: ARRAY
72375: PPUSH
72376: LD_EXP 36
72380: PUSH
72381: LD_VAR 0 2
72385: ARRAY
72386: PUSH
72387: LD_INT 1
72389: ARRAY
72390: PUSH
72391: LD_INT 1
72393: ARRAY
72394: PPUSH
72395: LD_EXP 36
72399: PUSH
72400: LD_VAR 0 2
72404: ARRAY
72405: PUSH
72406: LD_INT 1
72408: ARRAY
72409: PUSH
72410: LD_INT 2
72412: ARRAY
72413: PPUSH
72414: LD_EXP 36
72418: PUSH
72419: LD_VAR 0 2
72423: ARRAY
72424: PUSH
72425: LD_INT 1
72427: ARRAY
72428: PUSH
72429: LD_INT 3
72431: ARRAY
72432: PPUSH
72433: LD_EXP 36
72437: PUSH
72438: LD_VAR 0 2
72442: ARRAY
72443: PUSH
72444: LD_INT 1
72446: ARRAY
72447: PUSH
72448: LD_INT 4
72450: ARRAY
72451: PPUSH
72452: CALL 33118 0 5
72456: OR
72457: IFFALSE 72738
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72459: LD_ADDR_VAR 0 5
72463: PUSH
72464: LD_EXP 31
72468: PUSH
72469: LD_VAR 0 2
72473: ARRAY
72474: PPUSH
72475: LD_INT 25
72477: PUSH
72478: LD_INT 2
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: PPUSH
72485: CALL_OW 72
72489: PUSH
72490: LD_EXP 33
72494: PUSH
72495: LD_VAR 0 2
72499: ARRAY
72500: DIFF
72501: ST_TO_ADDR
// if not tmp then
72502: LD_VAR 0 5
72506: NOT
72507: IFFALSE 72511
// continue ;
72509: GO 72339
// for j in tmp do
72511: LD_ADDR_VAR 0 3
72515: PUSH
72516: LD_VAR 0 5
72520: PUSH
72521: FOR_IN
72522: IFFALSE 72734
// begin if not mc_builders [ i ] then
72524: LD_EXP 37
72528: PUSH
72529: LD_VAR 0 2
72533: ARRAY
72534: NOT
72535: IFFALSE 72593
// begin SetTag ( j , 103 ) ;
72537: LD_VAR 0 3
72541: PPUSH
72542: LD_INT 103
72544: PPUSH
72545: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72549: LD_ADDR_EXP 37
72553: PUSH
72554: LD_EXP 37
72558: PPUSH
72559: LD_VAR 0 2
72563: PUSH
72564: LD_EXP 37
72568: PUSH
72569: LD_VAR 0 2
72573: ARRAY
72574: PUSH
72575: LD_INT 1
72577: PLUS
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PPUSH
72583: LD_VAR 0 3
72587: PPUSH
72588: CALL 25021 0 3
72592: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72593: LD_VAR 0 3
72597: PPUSH
72598: CALL_OW 310
72602: IFFALSE 72613
// ComExitBuilding ( j ) ;
72604: LD_VAR 0 3
72608: PPUSH
72609: CALL_OW 122
// wait ( 3 ) ;
72613: LD_INT 3
72615: PPUSH
72616: CALL_OW 67
// if not mc_build_list [ i ] then
72620: LD_EXP 36
72624: PUSH
72625: LD_VAR 0 2
72629: ARRAY
72630: NOT
72631: IFFALSE 72635
// break ;
72633: GO 72734
// if not HasTask ( j ) then
72635: LD_VAR 0 3
72639: PPUSH
72640: CALL_OW 314
72644: NOT
72645: IFFALSE 72732
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72647: LD_VAR 0 3
72651: PPUSH
72652: LD_EXP 36
72656: PUSH
72657: LD_VAR 0 2
72661: ARRAY
72662: PUSH
72663: LD_INT 1
72665: ARRAY
72666: PUSH
72667: LD_INT 1
72669: ARRAY
72670: PPUSH
72671: LD_EXP 36
72675: PUSH
72676: LD_VAR 0 2
72680: ARRAY
72681: PUSH
72682: LD_INT 1
72684: ARRAY
72685: PUSH
72686: LD_INT 2
72688: ARRAY
72689: PPUSH
72690: LD_EXP 36
72694: PUSH
72695: LD_VAR 0 2
72699: ARRAY
72700: PUSH
72701: LD_INT 1
72703: ARRAY
72704: PUSH
72705: LD_INT 3
72707: ARRAY
72708: PPUSH
72709: LD_EXP 36
72713: PUSH
72714: LD_VAR 0 2
72718: ARRAY
72719: PUSH
72720: LD_INT 1
72722: ARRAY
72723: PUSH
72724: LD_INT 4
72726: ARRAY
72727: PPUSH
72728: CALL_OW 145
// end ;
72732: GO 72521
72734: POP
72735: POP
// end else
72736: GO 72908
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72738: LD_EXP 31
72742: PUSH
72743: LD_VAR 0 2
72747: ARRAY
72748: PPUSH
72749: LD_EXP 36
72753: PUSH
72754: LD_VAR 0 2
72758: ARRAY
72759: PUSH
72760: LD_INT 1
72762: ARRAY
72763: PUSH
72764: LD_INT 1
72766: ARRAY
72767: PPUSH
72768: LD_EXP 36
72772: PUSH
72773: LD_VAR 0 2
72777: ARRAY
72778: PUSH
72779: LD_INT 1
72781: ARRAY
72782: PUSH
72783: LD_INT 2
72785: ARRAY
72786: PPUSH
72787: LD_EXP 36
72791: PUSH
72792: LD_VAR 0 2
72796: ARRAY
72797: PUSH
72798: LD_INT 1
72800: ARRAY
72801: PUSH
72802: LD_INT 3
72804: ARRAY
72805: PPUSH
72806: LD_EXP 36
72810: PUSH
72811: LD_VAR 0 2
72815: ARRAY
72816: PUSH
72817: LD_INT 1
72819: ARRAY
72820: PUSH
72821: LD_INT 4
72823: ARRAY
72824: PPUSH
72825: LD_EXP 31
72829: PUSH
72830: LD_VAR 0 2
72834: ARRAY
72835: PPUSH
72836: LD_INT 21
72838: PUSH
72839: LD_INT 3
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: PPUSH
72846: CALL_OW 72
72850: PPUSH
72851: EMPTY
72852: PPUSH
72853: CALL 31872 0 7
72857: NOT
72858: IFFALSE 72908
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
72860: LD_ADDR_EXP 36
72864: PUSH
72865: LD_EXP 36
72869: PPUSH
72870: LD_VAR 0 2
72874: PPUSH
72875: LD_EXP 36
72879: PUSH
72880: LD_VAR 0 2
72884: ARRAY
72885: PPUSH
72886: LD_INT 1
72888: PPUSH
72889: LD_INT 1
72891: NEG
72892: PPUSH
72893: LD_INT 0
72895: PPUSH
72896: CALL 24439 0 4
72900: PPUSH
72901: CALL_OW 1
72905: ST_TO_ADDR
// continue ;
72906: GO 72339
// end ; end ;
72908: GO 72339
72910: POP
72911: POP
// end ; end ;
72912: GO 71768
72914: POP
72915: POP
// end ;
72916: LD_VAR 0 1
72920: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
72921: LD_INT 0
72923: PPUSH
72924: PPUSH
72925: PPUSH
72926: PPUSH
72927: PPUSH
72928: PPUSH
// if not mc_bases then
72929: LD_EXP 31
72933: NOT
72934: IFFALSE 72938
// exit ;
72936: GO 73365
// for i = 1 to mc_bases do
72938: LD_ADDR_VAR 0 2
72942: PUSH
72943: DOUBLE
72944: LD_INT 1
72946: DEC
72947: ST_TO_ADDR
72948: LD_EXP 31
72952: PUSH
72953: FOR_TO
72954: IFFALSE 73363
// begin tmp := mc_build_upgrade [ i ] ;
72956: LD_ADDR_VAR 0 4
72960: PUSH
72961: LD_EXP 63
72965: PUSH
72966: LD_VAR 0 2
72970: ARRAY
72971: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
72972: LD_ADDR_VAR 0 6
72976: PUSH
72977: LD_EXP 64
72981: PUSH
72982: LD_VAR 0 2
72986: ARRAY
72987: PPUSH
72988: LD_INT 2
72990: PUSH
72991: LD_INT 30
72993: PUSH
72994: LD_INT 6
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: LD_INT 30
73003: PUSH
73004: LD_INT 7
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: LIST
73015: PPUSH
73016: CALL_OW 72
73020: ST_TO_ADDR
// if not tmp and not lab then
73021: LD_VAR 0 4
73025: NOT
73026: PUSH
73027: LD_VAR 0 6
73031: NOT
73032: AND
73033: IFFALSE 73037
// continue ;
73035: GO 72953
// if tmp then
73037: LD_VAR 0 4
73041: IFFALSE 73161
// for j in tmp do
73043: LD_ADDR_VAR 0 3
73047: PUSH
73048: LD_VAR 0 4
73052: PUSH
73053: FOR_IN
73054: IFFALSE 73159
// begin if UpgradeCost ( j ) then
73056: LD_VAR 0 3
73060: PPUSH
73061: CALL 31532 0 1
73065: IFFALSE 73157
// begin ComUpgrade ( j ) ;
73067: LD_VAR 0 3
73071: PPUSH
73072: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
73076: LD_ADDR_EXP 63
73080: PUSH
73081: LD_EXP 63
73085: PPUSH
73086: LD_VAR 0 2
73090: PPUSH
73091: LD_EXP 63
73095: PUSH
73096: LD_VAR 0 2
73100: ARRAY
73101: PUSH
73102: LD_VAR 0 3
73106: DIFF
73107: PPUSH
73108: CALL_OW 1
73112: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73113: LD_ADDR_EXP 38
73117: PUSH
73118: LD_EXP 38
73122: PPUSH
73123: LD_VAR 0 2
73127: PUSH
73128: LD_EXP 38
73132: PUSH
73133: LD_VAR 0 2
73137: ARRAY
73138: PUSH
73139: LD_INT 1
73141: PLUS
73142: PUSH
73143: EMPTY
73144: LIST
73145: LIST
73146: PPUSH
73147: LD_VAR 0 3
73151: PPUSH
73152: CALL 25021 0 3
73156: ST_TO_ADDR
// end ; end ;
73157: GO 73053
73159: POP
73160: POP
// if not lab or not mc_lab_upgrade [ i ] then
73161: LD_VAR 0 6
73165: NOT
73166: PUSH
73167: LD_EXP 65
73171: PUSH
73172: LD_VAR 0 2
73176: ARRAY
73177: NOT
73178: OR
73179: IFFALSE 73183
// continue ;
73181: GO 72953
// for j in lab do
73183: LD_ADDR_VAR 0 3
73187: PUSH
73188: LD_VAR 0 6
73192: PUSH
73193: FOR_IN
73194: IFFALSE 73359
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
73196: LD_VAR 0 3
73200: PPUSH
73201: CALL_OW 266
73205: PUSH
73206: LD_INT 6
73208: PUSH
73209: LD_INT 7
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: IN
73216: PUSH
73217: LD_VAR 0 3
73221: PPUSH
73222: CALL_OW 461
73226: PUSH
73227: LD_INT 1
73229: NONEQUAL
73230: AND
73231: IFFALSE 73357
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
73233: LD_VAR 0 3
73237: PPUSH
73238: LD_EXP 65
73242: PUSH
73243: LD_VAR 0 2
73247: ARRAY
73248: PUSH
73249: LD_INT 1
73251: ARRAY
73252: PPUSH
73253: CALL 31737 0 2
73257: IFFALSE 73357
// begin ComCancel ( j ) ;
73259: LD_VAR 0 3
73263: PPUSH
73264: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73268: LD_VAR 0 3
73272: PPUSH
73273: LD_EXP 65
73277: PUSH
73278: LD_VAR 0 2
73282: ARRAY
73283: PUSH
73284: LD_INT 1
73286: ARRAY
73287: PPUSH
73288: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73292: LD_VAR 0 3
73296: PUSH
73297: LD_EXP 38
73301: PUSH
73302: LD_VAR 0 2
73306: ARRAY
73307: IN
73308: NOT
73309: IFFALSE 73355
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73311: LD_ADDR_EXP 38
73315: PUSH
73316: LD_EXP 38
73320: PPUSH
73321: LD_VAR 0 2
73325: PUSH
73326: LD_EXP 38
73330: PUSH
73331: LD_VAR 0 2
73335: ARRAY
73336: PUSH
73337: LD_INT 1
73339: PLUS
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PPUSH
73345: LD_VAR 0 3
73349: PPUSH
73350: CALL 25021 0 3
73354: ST_TO_ADDR
// break ;
73355: GO 73359
// end ; end ; end ;
73357: GO 73193
73359: POP
73360: POP
// end ;
73361: GO 72953
73363: POP
73364: POP
// end ;
73365: LD_VAR 0 1
73369: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73370: LD_INT 0
73372: PPUSH
73373: PPUSH
73374: PPUSH
73375: PPUSH
73376: PPUSH
73377: PPUSH
73378: PPUSH
73379: PPUSH
73380: PPUSH
// if not mc_bases then
73381: LD_EXP 31
73385: NOT
73386: IFFALSE 73390
// exit ;
73388: GO 73795
// for i = 1 to mc_bases do
73390: LD_ADDR_VAR 0 2
73394: PUSH
73395: DOUBLE
73396: LD_INT 1
73398: DEC
73399: ST_TO_ADDR
73400: LD_EXP 31
73404: PUSH
73405: FOR_TO
73406: IFFALSE 73793
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73408: LD_EXP 39
73412: PUSH
73413: LD_VAR 0 2
73417: ARRAY
73418: NOT
73419: PUSH
73420: LD_EXP 31
73424: PUSH
73425: LD_VAR 0 2
73429: ARRAY
73430: PPUSH
73431: LD_INT 30
73433: PUSH
73434: LD_INT 3
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PPUSH
73441: CALL_OW 72
73445: NOT
73446: OR
73447: IFFALSE 73451
// continue ;
73449: GO 73405
// busy := false ;
73451: LD_ADDR_VAR 0 8
73455: PUSH
73456: LD_INT 0
73458: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73459: LD_ADDR_VAR 0 4
73463: PUSH
73464: LD_EXP 31
73468: PUSH
73469: LD_VAR 0 2
73473: ARRAY
73474: PPUSH
73475: LD_INT 30
73477: PUSH
73478: LD_INT 3
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PPUSH
73485: CALL_OW 72
73489: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73490: LD_ADDR_VAR 0 6
73494: PUSH
73495: LD_EXP 39
73499: PUSH
73500: LD_VAR 0 2
73504: ARRAY
73505: PPUSH
73506: LD_INT 2
73508: PUSH
73509: LD_INT 30
73511: PUSH
73512: LD_INT 32
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: PUSH
73519: LD_INT 30
73521: PUSH
73522: LD_INT 33
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: LIST
73533: PPUSH
73534: CALL_OW 72
73538: ST_TO_ADDR
// if not t then
73539: LD_VAR 0 6
73543: NOT
73544: IFFALSE 73548
// continue ;
73546: GO 73405
// for j in tmp do
73548: LD_ADDR_VAR 0 3
73552: PUSH
73553: LD_VAR 0 4
73557: PUSH
73558: FOR_IN
73559: IFFALSE 73589
// if not BuildingStatus ( j ) = bs_idle then
73561: LD_VAR 0 3
73565: PPUSH
73566: CALL_OW 461
73570: PUSH
73571: LD_INT 2
73573: EQUAL
73574: NOT
73575: IFFALSE 73587
// begin busy := true ;
73577: LD_ADDR_VAR 0 8
73581: PUSH
73582: LD_INT 1
73584: ST_TO_ADDR
// break ;
73585: GO 73589
// end ;
73587: GO 73558
73589: POP
73590: POP
// if busy then
73591: LD_VAR 0 8
73595: IFFALSE 73599
// continue ;
73597: GO 73405
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73599: LD_ADDR_VAR 0 7
73603: PUSH
73604: LD_VAR 0 6
73608: PPUSH
73609: LD_INT 35
73611: PUSH
73612: LD_INT 0
73614: PUSH
73615: EMPTY
73616: LIST
73617: LIST
73618: PPUSH
73619: CALL_OW 72
73623: ST_TO_ADDR
// if tw then
73624: LD_VAR 0 7
73628: IFFALSE 73705
// begin tw := tw [ 1 ] ;
73630: LD_ADDR_VAR 0 7
73634: PUSH
73635: LD_VAR 0 7
73639: PUSH
73640: LD_INT 1
73642: ARRAY
73643: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73644: LD_ADDR_VAR 0 9
73648: PUSH
73649: LD_VAR 0 7
73653: PPUSH
73654: LD_EXP 56
73658: PUSH
73659: LD_VAR 0 2
73663: ARRAY
73664: PPUSH
73665: CALL 30029 0 2
73669: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73670: LD_EXP 70
73674: PUSH
73675: LD_VAR 0 2
73679: ARRAY
73680: IFFALSE 73703
// if not weapon in mc_allowed_tower_weapons [ i ] then
73682: LD_VAR 0 9
73686: PUSH
73687: LD_EXP 70
73691: PUSH
73692: LD_VAR 0 2
73696: ARRAY
73697: IN
73698: NOT
73699: IFFALSE 73703
// continue ;
73701: GO 73405
// end else
73703: GO 73768
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73705: LD_ADDR_VAR 0 5
73709: PUSH
73710: LD_EXP 39
73714: PUSH
73715: LD_VAR 0 2
73719: ARRAY
73720: PPUSH
73721: LD_VAR 0 4
73725: PPUSH
73726: CALL 56900 0 2
73730: ST_TO_ADDR
// if not tmp2 then
73731: LD_VAR 0 5
73735: NOT
73736: IFFALSE 73740
// continue ;
73738: GO 73405
// tw := tmp2 [ 1 ] ;
73740: LD_ADDR_VAR 0 7
73744: PUSH
73745: LD_VAR 0 5
73749: PUSH
73750: LD_INT 1
73752: ARRAY
73753: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73754: LD_ADDR_VAR 0 9
73758: PUSH
73759: LD_VAR 0 5
73763: PUSH
73764: LD_INT 2
73766: ARRAY
73767: ST_TO_ADDR
// end ; if not weapon then
73768: LD_VAR 0 9
73772: NOT
73773: IFFALSE 73777
// continue ;
73775: GO 73405
// ComPlaceWeapon ( tw , weapon ) ;
73777: LD_VAR 0 7
73781: PPUSH
73782: LD_VAR 0 9
73786: PPUSH
73787: CALL_OW 148
// end ;
73791: GO 73405
73793: POP
73794: POP
// end ;
73795: LD_VAR 0 1
73799: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73800: LD_INT 0
73802: PPUSH
73803: PPUSH
73804: PPUSH
73805: PPUSH
73806: PPUSH
73807: PPUSH
73808: PPUSH
// if not mc_bases then
73809: LD_EXP 31
73813: NOT
73814: IFFALSE 73818
// exit ;
73816: GO 74586
// for i = 1 to mc_bases do
73818: LD_ADDR_VAR 0 2
73822: PUSH
73823: DOUBLE
73824: LD_INT 1
73826: DEC
73827: ST_TO_ADDR
73828: LD_EXP 31
73832: PUSH
73833: FOR_TO
73834: IFFALSE 74584
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73836: LD_EXP 44
73840: PUSH
73841: LD_VAR 0 2
73845: ARRAY
73846: NOT
73847: PUSH
73848: LD_EXP 44
73852: PUSH
73853: LD_VAR 0 2
73857: ARRAY
73858: PUSH
73859: LD_EXP 45
73863: PUSH
73864: LD_VAR 0 2
73868: ARRAY
73869: EQUAL
73870: OR
73871: PUSH
73872: LD_EXP 54
73876: PUSH
73877: LD_VAR 0 2
73881: ARRAY
73882: OR
73883: IFFALSE 73887
// continue ;
73885: GO 73833
// if mc_miners [ i ] then
73887: LD_EXP 45
73891: PUSH
73892: LD_VAR 0 2
73896: ARRAY
73897: IFFALSE 74271
// begin for j = mc_miners [ i ] downto 1 do
73899: LD_ADDR_VAR 0 3
73903: PUSH
73904: DOUBLE
73905: LD_EXP 45
73909: PUSH
73910: LD_VAR 0 2
73914: ARRAY
73915: INC
73916: ST_TO_ADDR
73917: LD_INT 1
73919: PUSH
73920: FOR_DOWNTO
73921: IFFALSE 74269
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
73923: LD_EXP 45
73927: PUSH
73928: LD_VAR 0 2
73932: ARRAY
73933: PUSH
73934: LD_VAR 0 3
73938: ARRAY
73939: PPUSH
73940: CALL_OW 301
73944: PUSH
73945: LD_EXP 45
73949: PUSH
73950: LD_VAR 0 2
73954: ARRAY
73955: PUSH
73956: LD_VAR 0 3
73960: ARRAY
73961: PPUSH
73962: CALL_OW 257
73966: PUSH
73967: LD_INT 1
73969: NONEQUAL
73970: OR
73971: IFFALSE 74034
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
73973: LD_ADDR_VAR 0 5
73977: PUSH
73978: LD_EXP 45
73982: PUSH
73983: LD_VAR 0 2
73987: ARRAY
73988: PUSH
73989: LD_EXP 45
73993: PUSH
73994: LD_VAR 0 2
73998: ARRAY
73999: PUSH
74000: LD_VAR 0 3
74004: ARRAY
74005: DIFF
74006: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
74007: LD_ADDR_EXP 45
74011: PUSH
74012: LD_EXP 45
74016: PPUSH
74017: LD_VAR 0 2
74021: PPUSH
74022: LD_VAR 0 5
74026: PPUSH
74027: CALL_OW 1
74031: ST_TO_ADDR
// continue ;
74032: GO 73920
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
74034: LD_EXP 45
74038: PUSH
74039: LD_VAR 0 2
74043: ARRAY
74044: PUSH
74045: LD_VAR 0 3
74049: ARRAY
74050: PPUSH
74051: CALL_OW 257
74055: PUSH
74056: LD_INT 1
74058: EQUAL
74059: PUSH
74060: LD_EXP 45
74064: PUSH
74065: LD_VAR 0 2
74069: ARRAY
74070: PUSH
74071: LD_VAR 0 3
74075: ARRAY
74076: PPUSH
74077: CALL_OW 459
74081: NOT
74082: AND
74083: PUSH
74084: LD_EXP 45
74088: PUSH
74089: LD_VAR 0 2
74093: ARRAY
74094: PUSH
74095: LD_VAR 0 3
74099: ARRAY
74100: PPUSH
74101: CALL_OW 314
74105: NOT
74106: AND
74107: IFFALSE 74267
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
74109: LD_EXP 45
74113: PUSH
74114: LD_VAR 0 2
74118: ARRAY
74119: PUSH
74120: LD_VAR 0 3
74124: ARRAY
74125: PPUSH
74126: CALL_OW 310
74130: IFFALSE 74153
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
74132: LD_EXP 45
74136: PUSH
74137: LD_VAR 0 2
74141: ARRAY
74142: PUSH
74143: LD_VAR 0 3
74147: ARRAY
74148: PPUSH
74149: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
74153: LD_EXP 45
74157: PUSH
74158: LD_VAR 0 2
74162: ARRAY
74163: PUSH
74164: LD_VAR 0 3
74168: ARRAY
74169: PPUSH
74170: CALL_OW 314
74174: NOT
74175: IFFALSE 74267
// begin r := rand ( 1 , mc_mines [ i ] ) ;
74177: LD_ADDR_VAR 0 7
74181: PUSH
74182: LD_INT 1
74184: PPUSH
74185: LD_EXP 44
74189: PUSH
74190: LD_VAR 0 2
74194: ARRAY
74195: PPUSH
74196: CALL_OW 12
74200: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
74201: LD_EXP 45
74205: PUSH
74206: LD_VAR 0 2
74210: ARRAY
74211: PUSH
74212: LD_VAR 0 3
74216: ARRAY
74217: PPUSH
74218: LD_EXP 44
74222: PUSH
74223: LD_VAR 0 2
74227: ARRAY
74228: PUSH
74229: LD_VAR 0 7
74233: ARRAY
74234: PUSH
74235: LD_INT 1
74237: ARRAY
74238: PPUSH
74239: LD_EXP 44
74243: PUSH
74244: LD_VAR 0 2
74248: ARRAY
74249: PUSH
74250: LD_VAR 0 7
74254: ARRAY
74255: PUSH
74256: LD_INT 2
74258: ARRAY
74259: PPUSH
74260: LD_INT 0
74262: PPUSH
74263: CALL_OW 193
// end ; end ; end ;
74267: GO 73920
74269: POP
74270: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74271: LD_ADDR_VAR 0 5
74275: PUSH
74276: LD_EXP 31
74280: PUSH
74281: LD_VAR 0 2
74285: ARRAY
74286: PPUSH
74287: LD_INT 2
74289: PUSH
74290: LD_INT 30
74292: PUSH
74293: LD_INT 4
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: PUSH
74300: LD_INT 30
74302: PUSH
74303: LD_INT 5
74305: PUSH
74306: EMPTY
74307: LIST
74308: LIST
74309: PUSH
74310: LD_INT 30
74312: PUSH
74313: LD_INT 32
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: LIST
74324: LIST
74325: PPUSH
74326: CALL_OW 72
74330: ST_TO_ADDR
// if not tmp then
74331: LD_VAR 0 5
74335: NOT
74336: IFFALSE 74340
// continue ;
74338: GO 73833
// list := [ ] ;
74340: LD_ADDR_VAR 0 6
74344: PUSH
74345: EMPTY
74346: ST_TO_ADDR
// for j in tmp do
74347: LD_ADDR_VAR 0 3
74351: PUSH
74352: LD_VAR 0 5
74356: PUSH
74357: FOR_IN
74358: IFFALSE 74427
// begin for k in UnitsInside ( j ) do
74360: LD_ADDR_VAR 0 4
74364: PUSH
74365: LD_VAR 0 3
74369: PPUSH
74370: CALL_OW 313
74374: PUSH
74375: FOR_IN
74376: IFFALSE 74423
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74378: LD_VAR 0 4
74382: PPUSH
74383: CALL_OW 257
74387: PUSH
74388: LD_INT 1
74390: EQUAL
74391: PUSH
74392: LD_VAR 0 4
74396: PPUSH
74397: CALL_OW 459
74401: NOT
74402: AND
74403: IFFALSE 74421
// list := list ^ k ;
74405: LD_ADDR_VAR 0 6
74409: PUSH
74410: LD_VAR 0 6
74414: PUSH
74415: LD_VAR 0 4
74419: ADD
74420: ST_TO_ADDR
74421: GO 74375
74423: POP
74424: POP
// end ;
74425: GO 74357
74427: POP
74428: POP
// list := list diff mc_miners [ i ] ;
74429: LD_ADDR_VAR 0 6
74433: PUSH
74434: LD_VAR 0 6
74438: PUSH
74439: LD_EXP 45
74443: PUSH
74444: LD_VAR 0 2
74448: ARRAY
74449: DIFF
74450: ST_TO_ADDR
// if not list then
74451: LD_VAR 0 6
74455: NOT
74456: IFFALSE 74460
// continue ;
74458: GO 73833
// k := mc_mines [ i ] - mc_miners [ i ] ;
74460: LD_ADDR_VAR 0 4
74464: PUSH
74465: LD_EXP 44
74469: PUSH
74470: LD_VAR 0 2
74474: ARRAY
74475: PUSH
74476: LD_EXP 45
74480: PUSH
74481: LD_VAR 0 2
74485: ARRAY
74486: MINUS
74487: ST_TO_ADDR
// if k > list then
74488: LD_VAR 0 4
74492: PUSH
74493: LD_VAR 0 6
74497: GREATER
74498: IFFALSE 74510
// k := list ;
74500: LD_ADDR_VAR 0 4
74504: PUSH
74505: LD_VAR 0 6
74509: ST_TO_ADDR
// for j = 1 to k do
74510: LD_ADDR_VAR 0 3
74514: PUSH
74515: DOUBLE
74516: LD_INT 1
74518: DEC
74519: ST_TO_ADDR
74520: LD_VAR 0 4
74524: PUSH
74525: FOR_TO
74526: IFFALSE 74580
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74528: LD_ADDR_EXP 45
74532: PUSH
74533: LD_EXP 45
74537: PPUSH
74538: LD_VAR 0 2
74542: PUSH
74543: LD_EXP 45
74547: PUSH
74548: LD_VAR 0 2
74552: ARRAY
74553: PUSH
74554: LD_INT 1
74556: PLUS
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PPUSH
74562: LD_VAR 0 6
74566: PUSH
74567: LD_VAR 0 3
74571: ARRAY
74572: PPUSH
74573: CALL 25021 0 3
74577: ST_TO_ADDR
74578: GO 74525
74580: POP
74581: POP
// end ;
74582: GO 73833
74584: POP
74585: POP
// end ;
74586: LD_VAR 0 1
74590: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74591: LD_INT 0
74593: PPUSH
74594: PPUSH
74595: PPUSH
74596: PPUSH
74597: PPUSH
74598: PPUSH
74599: PPUSH
74600: PPUSH
74601: PPUSH
74602: PPUSH
74603: PPUSH
// if not mc_bases then
74604: LD_EXP 31
74608: NOT
74609: IFFALSE 74613
// exit ;
74611: GO 76436
// for i = 1 to mc_bases do
74613: LD_ADDR_VAR 0 2
74617: PUSH
74618: DOUBLE
74619: LD_INT 1
74621: DEC
74622: ST_TO_ADDR
74623: LD_EXP 31
74627: PUSH
74628: FOR_TO
74629: IFFALSE 76434
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74631: LD_EXP 31
74635: PUSH
74636: LD_VAR 0 2
74640: ARRAY
74641: NOT
74642: PUSH
74643: LD_EXP 38
74647: PUSH
74648: LD_VAR 0 2
74652: ARRAY
74653: OR
74654: IFFALSE 74658
// continue ;
74656: GO 74628
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74658: LD_EXP 47
74662: PUSH
74663: LD_VAR 0 2
74667: ARRAY
74668: NOT
74669: PUSH
74670: LD_EXP 48
74674: PUSH
74675: LD_VAR 0 2
74679: ARRAY
74680: AND
74681: IFFALSE 74719
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74683: LD_ADDR_EXP 48
74687: PUSH
74688: LD_EXP 48
74692: PPUSH
74693: LD_VAR 0 2
74697: PPUSH
74698: EMPTY
74699: PPUSH
74700: CALL_OW 1
74704: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74705: LD_VAR 0 2
74709: PPUSH
74710: LD_INT 107
74712: PPUSH
74713: CALL 65466 0 2
// continue ;
74717: GO 74628
// end ; target := [ ] ;
74719: LD_ADDR_VAR 0 7
74723: PUSH
74724: EMPTY
74725: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74726: LD_ADDR_VAR 0 6
74730: PUSH
74731: LD_EXP 31
74735: PUSH
74736: LD_VAR 0 2
74740: ARRAY
74741: PUSH
74742: LD_INT 1
74744: ARRAY
74745: PPUSH
74746: CALL_OW 255
74750: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74751: LD_ADDR_VAR 0 9
74755: PUSH
74756: LD_EXP 31
74760: PUSH
74761: LD_VAR 0 2
74765: ARRAY
74766: PPUSH
74767: LD_INT 2
74769: PUSH
74770: LD_INT 30
74772: PUSH
74773: LD_INT 0
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: LD_INT 30
74782: PUSH
74783: LD_INT 1
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: LIST
74794: PPUSH
74795: CALL_OW 72
74799: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74800: LD_ADDR_VAR 0 3
74804: PUSH
74805: DOUBLE
74806: LD_EXP 47
74810: PUSH
74811: LD_VAR 0 2
74815: ARRAY
74816: INC
74817: ST_TO_ADDR
74818: LD_INT 1
74820: PUSH
74821: FOR_DOWNTO
74822: IFFALSE 75067
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74824: LD_EXP 47
74828: PUSH
74829: LD_VAR 0 2
74833: ARRAY
74834: PUSH
74835: LD_VAR 0 3
74839: ARRAY
74840: PUSH
74841: LD_INT 2
74843: ARRAY
74844: PPUSH
74845: LD_EXP 47
74849: PUSH
74850: LD_VAR 0 2
74854: ARRAY
74855: PUSH
74856: LD_VAR 0 3
74860: ARRAY
74861: PUSH
74862: LD_INT 3
74864: ARRAY
74865: PPUSH
74866: CALL_OW 488
74870: PUSH
74871: LD_EXP 47
74875: PUSH
74876: LD_VAR 0 2
74880: ARRAY
74881: PUSH
74882: LD_VAR 0 3
74886: ARRAY
74887: PUSH
74888: LD_INT 2
74890: ARRAY
74891: PPUSH
74892: LD_EXP 47
74896: PUSH
74897: LD_VAR 0 2
74901: ARRAY
74902: PUSH
74903: LD_VAR 0 3
74907: ARRAY
74908: PUSH
74909: LD_INT 3
74911: ARRAY
74912: PPUSH
74913: CALL_OW 284
74917: PUSH
74918: LD_INT 0
74920: EQUAL
74921: AND
74922: IFFALSE 74977
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
74924: LD_ADDR_VAR 0 5
74928: PUSH
74929: LD_EXP 47
74933: PUSH
74934: LD_VAR 0 2
74938: ARRAY
74939: PPUSH
74940: LD_VAR 0 3
74944: PPUSH
74945: CALL_OW 3
74949: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
74950: LD_ADDR_EXP 47
74954: PUSH
74955: LD_EXP 47
74959: PPUSH
74960: LD_VAR 0 2
74964: PPUSH
74965: LD_VAR 0 5
74969: PPUSH
74970: CALL_OW 1
74974: ST_TO_ADDR
// continue ;
74975: GO 74821
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
74977: LD_VAR 0 6
74981: PPUSH
74982: LD_EXP 47
74986: PUSH
74987: LD_VAR 0 2
74991: ARRAY
74992: PUSH
74993: LD_VAR 0 3
74997: ARRAY
74998: PUSH
74999: LD_INT 2
75001: ARRAY
75002: PPUSH
75003: LD_EXP 47
75007: PUSH
75008: LD_VAR 0 2
75012: ARRAY
75013: PUSH
75014: LD_VAR 0 3
75018: ARRAY
75019: PUSH
75020: LD_INT 3
75022: ARRAY
75023: PPUSH
75024: LD_INT 30
75026: PPUSH
75027: CALL 25917 0 4
75031: PUSH
75032: LD_INT 4
75034: ARRAY
75035: PUSH
75036: LD_INT 0
75038: EQUAL
75039: IFFALSE 75065
// begin target := mc_crates [ i ] [ j ] ;
75041: LD_ADDR_VAR 0 7
75045: PUSH
75046: LD_EXP 47
75050: PUSH
75051: LD_VAR 0 2
75055: ARRAY
75056: PUSH
75057: LD_VAR 0 3
75061: ARRAY
75062: ST_TO_ADDR
// break ;
75063: GO 75067
// end ; end ;
75065: GO 74821
75067: POP
75068: POP
// if not target then
75069: LD_VAR 0 7
75073: NOT
75074: IFFALSE 75078
// continue ;
75076: GO 74628
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75078: LD_ADDR_VAR 0 8
75082: PUSH
75083: LD_EXP 50
75087: PUSH
75088: LD_VAR 0 2
75092: ARRAY
75093: PPUSH
75094: LD_INT 2
75096: PUSH
75097: LD_INT 3
75099: PUSH
75100: LD_INT 58
75102: PUSH
75103: EMPTY
75104: LIST
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PUSH
75110: LD_INT 61
75112: PUSH
75113: EMPTY
75114: LIST
75115: PUSH
75116: LD_INT 33
75118: PUSH
75119: LD_INT 5
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: PUSH
75126: LD_INT 33
75128: PUSH
75129: LD_INT 3
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: PUSH
75143: LD_INT 2
75145: PUSH
75146: LD_INT 34
75148: PUSH
75149: LD_INT 32
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 34
75158: PUSH
75159: LD_INT 51
75161: PUSH
75162: EMPTY
75163: LIST
75164: LIST
75165: PUSH
75166: LD_INT 34
75168: PUSH
75169: LD_INT 12
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: LIST
75180: LIST
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PPUSH
75186: CALL_OW 72
75190: ST_TO_ADDR
// if not cargo then
75191: LD_VAR 0 8
75195: NOT
75196: IFFALSE 75902
// begin if mc_crates_collector [ i ] < 5 then
75198: LD_EXP 48
75202: PUSH
75203: LD_VAR 0 2
75207: ARRAY
75208: PUSH
75209: LD_INT 5
75211: LESS
75212: IFFALSE 75578
// begin if mc_ape [ i ] then
75214: LD_EXP 60
75218: PUSH
75219: LD_VAR 0 2
75223: ARRAY
75224: IFFALSE 75271
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75226: LD_ADDR_VAR 0 5
75230: PUSH
75231: LD_EXP 60
75235: PUSH
75236: LD_VAR 0 2
75240: ARRAY
75241: PPUSH
75242: LD_INT 25
75244: PUSH
75245: LD_INT 16
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 24
75254: PUSH
75255: LD_INT 750
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PPUSH
75266: CALL_OW 72
75270: ST_TO_ADDR
// if not tmp then
75271: LD_VAR 0 5
75275: NOT
75276: IFFALSE 75323
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75278: LD_ADDR_VAR 0 5
75282: PUSH
75283: LD_EXP 31
75287: PUSH
75288: LD_VAR 0 2
75292: ARRAY
75293: PPUSH
75294: LD_INT 25
75296: PUSH
75297: LD_INT 2
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: PUSH
75304: LD_INT 24
75306: PUSH
75307: LD_INT 750
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PPUSH
75318: CALL_OW 72
75322: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75323: LD_EXP 60
75327: PUSH
75328: LD_VAR 0 2
75332: ARRAY
75333: PUSH
75334: LD_EXP 31
75338: PUSH
75339: LD_VAR 0 2
75343: ARRAY
75344: PPUSH
75345: LD_INT 25
75347: PUSH
75348: LD_INT 2
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 24
75357: PUSH
75358: LD_INT 750
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: PPUSH
75369: CALL_OW 72
75373: AND
75374: PUSH
75375: LD_VAR 0 5
75379: PUSH
75380: LD_INT 5
75382: LESS
75383: AND
75384: IFFALSE 75466
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75386: LD_ADDR_VAR 0 3
75390: PUSH
75391: LD_EXP 31
75395: PUSH
75396: LD_VAR 0 2
75400: ARRAY
75401: PPUSH
75402: LD_INT 25
75404: PUSH
75405: LD_INT 2
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: LD_INT 24
75414: PUSH
75415: LD_INT 750
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PPUSH
75426: CALL_OW 72
75430: PUSH
75431: FOR_IN
75432: IFFALSE 75464
// begin tmp := tmp union j ;
75434: LD_ADDR_VAR 0 5
75438: PUSH
75439: LD_VAR 0 5
75443: PUSH
75444: LD_VAR 0 3
75448: UNION
75449: ST_TO_ADDR
// if tmp >= 5 then
75450: LD_VAR 0 5
75454: PUSH
75455: LD_INT 5
75457: GREATEREQUAL
75458: IFFALSE 75462
// break ;
75460: GO 75464
// end ;
75462: GO 75431
75464: POP
75465: POP
// end ; if not tmp then
75466: LD_VAR 0 5
75470: NOT
75471: IFFALSE 75475
// continue ;
75473: GO 74628
// for j in tmp do
75475: LD_ADDR_VAR 0 3
75479: PUSH
75480: LD_VAR 0 5
75484: PUSH
75485: FOR_IN
75486: IFFALSE 75576
// if not GetTag ( j ) then
75488: LD_VAR 0 3
75492: PPUSH
75493: CALL_OW 110
75497: NOT
75498: IFFALSE 75574
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75500: LD_ADDR_EXP 48
75504: PUSH
75505: LD_EXP 48
75509: PPUSH
75510: LD_VAR 0 2
75514: PUSH
75515: LD_EXP 48
75519: PUSH
75520: LD_VAR 0 2
75524: ARRAY
75525: PUSH
75526: LD_INT 1
75528: PLUS
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PPUSH
75534: LD_VAR 0 3
75538: PPUSH
75539: CALL 25021 0 3
75543: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75544: LD_VAR 0 3
75548: PPUSH
75549: LD_INT 107
75551: PPUSH
75552: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75556: LD_EXP 48
75560: PUSH
75561: LD_VAR 0 2
75565: ARRAY
75566: PUSH
75567: LD_INT 5
75569: GREATEREQUAL
75570: IFFALSE 75574
// break ;
75572: GO 75576
// end ;
75574: GO 75485
75576: POP
75577: POP
// end ; if mc_crates_collector [ i ] and target then
75578: LD_EXP 48
75582: PUSH
75583: LD_VAR 0 2
75587: ARRAY
75588: PUSH
75589: LD_VAR 0 7
75593: AND
75594: IFFALSE 75900
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75596: LD_EXP 48
75600: PUSH
75601: LD_VAR 0 2
75605: ARRAY
75606: PUSH
75607: LD_VAR 0 7
75611: PUSH
75612: LD_INT 1
75614: ARRAY
75615: LESS
75616: IFFALSE 75636
// tmp := mc_crates_collector [ i ] else
75618: LD_ADDR_VAR 0 5
75622: PUSH
75623: LD_EXP 48
75627: PUSH
75628: LD_VAR 0 2
75632: ARRAY
75633: ST_TO_ADDR
75634: GO 75650
// tmp := target [ 1 ] ;
75636: LD_ADDR_VAR 0 5
75640: PUSH
75641: LD_VAR 0 7
75645: PUSH
75646: LD_INT 1
75648: ARRAY
75649: ST_TO_ADDR
// k := 0 ;
75650: LD_ADDR_VAR 0 4
75654: PUSH
75655: LD_INT 0
75657: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75658: LD_ADDR_VAR 0 3
75662: PUSH
75663: LD_EXP 48
75667: PUSH
75668: LD_VAR 0 2
75672: ARRAY
75673: PUSH
75674: FOR_IN
75675: IFFALSE 75898
// begin k := k + 1 ;
75677: LD_ADDR_VAR 0 4
75681: PUSH
75682: LD_VAR 0 4
75686: PUSH
75687: LD_INT 1
75689: PLUS
75690: ST_TO_ADDR
// if k > tmp then
75691: LD_VAR 0 4
75695: PUSH
75696: LD_VAR 0 5
75700: GREATER
75701: IFFALSE 75705
// break ;
75703: GO 75898
// if not GetClass ( j ) in [ 2 , 16 ] then
75705: LD_VAR 0 3
75709: PPUSH
75710: CALL_OW 257
75714: PUSH
75715: LD_INT 2
75717: PUSH
75718: LD_INT 16
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: IN
75725: NOT
75726: IFFALSE 75779
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75728: LD_ADDR_EXP 48
75732: PUSH
75733: LD_EXP 48
75737: PPUSH
75738: LD_VAR 0 2
75742: PPUSH
75743: LD_EXP 48
75747: PUSH
75748: LD_VAR 0 2
75752: ARRAY
75753: PUSH
75754: LD_VAR 0 3
75758: DIFF
75759: PPUSH
75760: CALL_OW 1
75764: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75765: LD_VAR 0 3
75769: PPUSH
75770: LD_INT 0
75772: PPUSH
75773: CALL_OW 109
// continue ;
75777: GO 75674
// end ; if IsInUnit ( j ) then
75779: LD_VAR 0 3
75783: PPUSH
75784: CALL_OW 310
75788: IFFALSE 75799
// ComExitBuilding ( j ) ;
75790: LD_VAR 0 3
75794: PPUSH
75795: CALL_OW 122
// wait ( 3 ) ;
75799: LD_INT 3
75801: PPUSH
75802: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75806: LD_VAR 0 3
75810: PPUSH
75811: CALL_OW 314
75815: PUSH
75816: LD_VAR 0 6
75820: PPUSH
75821: LD_VAR 0 7
75825: PUSH
75826: LD_INT 2
75828: ARRAY
75829: PPUSH
75830: LD_VAR 0 7
75834: PUSH
75835: LD_INT 3
75837: ARRAY
75838: PPUSH
75839: LD_INT 30
75841: PPUSH
75842: CALL 25917 0 4
75846: PUSH
75847: LD_INT 4
75849: ARRAY
75850: AND
75851: IFFALSE 75869
// ComStandNearbyBuilding ( j , depot ) else
75853: LD_VAR 0 3
75857: PPUSH
75858: LD_VAR 0 9
75862: PPUSH
75863: CALL 21448 0 2
75867: GO 75896
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75869: LD_VAR 0 3
75873: PPUSH
75874: LD_VAR 0 7
75878: PUSH
75879: LD_INT 2
75881: ARRAY
75882: PPUSH
75883: LD_VAR 0 7
75887: PUSH
75888: LD_INT 3
75890: ARRAY
75891: PPUSH
75892: CALL_OW 117
// end ;
75896: GO 75674
75898: POP
75899: POP
// end ; end else
75900: GO 76432
// begin for j in cargo do
75902: LD_ADDR_VAR 0 3
75906: PUSH
75907: LD_VAR 0 8
75911: PUSH
75912: FOR_IN
75913: IFFALSE 76430
// begin if GetTag ( j ) <> 0 then
75915: LD_VAR 0 3
75919: PPUSH
75920: CALL_OW 110
75924: PUSH
75925: LD_INT 0
75927: NONEQUAL
75928: IFFALSE 75932
// continue ;
75930: GO 75912
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
75932: LD_VAR 0 3
75936: PPUSH
75937: CALL_OW 256
75941: PUSH
75942: LD_INT 1000
75944: LESS
75945: PUSH
75946: LD_VAR 0 3
75950: PPUSH
75951: LD_EXP 55
75955: PUSH
75956: LD_VAR 0 2
75960: ARRAY
75961: PPUSH
75962: CALL_OW 308
75966: NOT
75967: AND
75968: IFFALSE 75990
// ComMoveToArea ( j , mc_parking [ i ] ) ;
75970: LD_VAR 0 3
75974: PPUSH
75975: LD_EXP 55
75979: PUSH
75980: LD_VAR 0 2
75984: ARRAY
75985: PPUSH
75986: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
75990: LD_VAR 0 3
75994: PPUSH
75995: CALL_OW 256
75999: PUSH
76000: LD_INT 1000
76002: LESS
76003: PUSH
76004: LD_VAR 0 3
76008: PPUSH
76009: LD_EXP 55
76013: PUSH
76014: LD_VAR 0 2
76018: ARRAY
76019: PPUSH
76020: CALL_OW 308
76024: AND
76025: IFFALSE 76029
// continue ;
76027: GO 75912
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
76029: LD_VAR 0 3
76033: PPUSH
76034: CALL_OW 262
76038: PUSH
76039: LD_INT 2
76041: EQUAL
76042: PUSH
76043: LD_VAR 0 3
76047: PPUSH
76048: CALL_OW 261
76052: PUSH
76053: LD_INT 15
76055: LESS
76056: AND
76057: IFFALSE 76061
// continue ;
76059: GO 75912
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
76061: LD_VAR 0 3
76065: PPUSH
76066: CALL_OW 262
76070: PUSH
76071: LD_INT 1
76073: EQUAL
76074: PUSH
76075: LD_VAR 0 3
76079: PPUSH
76080: CALL_OW 261
76084: PUSH
76085: LD_INT 10
76087: LESS
76088: AND
76089: IFFALSE 76369
// begin if not depot then
76091: LD_VAR 0 9
76095: NOT
76096: IFFALSE 76100
// continue ;
76098: GO 75912
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76100: LD_VAR 0 3
76104: PPUSH
76105: LD_VAR 0 9
76109: PPUSH
76110: LD_VAR 0 3
76114: PPUSH
76115: CALL_OW 74
76119: PPUSH
76120: CALL_OW 296
76124: PUSH
76125: LD_INT 6
76127: LESS
76128: IFFALSE 76144
// SetFuel ( j , 100 ) else
76130: LD_VAR 0 3
76134: PPUSH
76135: LD_INT 100
76137: PPUSH
76138: CALL_OW 240
76142: GO 76369
// if GetFuel ( j ) = 0 then
76144: LD_VAR 0 3
76148: PPUSH
76149: CALL_OW 261
76153: PUSH
76154: LD_INT 0
76156: EQUAL
76157: IFFALSE 76369
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
76159: LD_ADDR_EXP 50
76163: PUSH
76164: LD_EXP 50
76168: PPUSH
76169: LD_VAR 0 2
76173: PPUSH
76174: LD_EXP 50
76178: PUSH
76179: LD_VAR 0 2
76183: ARRAY
76184: PUSH
76185: LD_VAR 0 3
76189: DIFF
76190: PPUSH
76191: CALL_OW 1
76195: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
76196: LD_VAR 0 3
76200: PPUSH
76201: CALL_OW 263
76205: PUSH
76206: LD_INT 1
76208: EQUAL
76209: IFFALSE 76225
// ComExitVehicle ( IsInUnit ( j ) ) ;
76211: LD_VAR 0 3
76215: PPUSH
76216: CALL_OW 310
76220: PPUSH
76221: CALL_OW 121
// if GetControl ( j ) = control_remote then
76225: LD_VAR 0 3
76229: PPUSH
76230: CALL_OW 263
76234: PUSH
76235: LD_INT 2
76237: EQUAL
76238: IFFALSE 76249
// ComUnlink ( j ) ;
76240: LD_VAR 0 3
76244: PPUSH
76245: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76249: LD_ADDR_VAR 0 10
76253: PUSH
76254: LD_VAR 0 2
76258: PPUSH
76259: LD_INT 3
76261: PPUSH
76262: CALL 86036 0 2
76266: ST_TO_ADDR
// if fac then
76267: LD_VAR 0 10
76271: IFFALSE 76367
// begin for k in fac do
76273: LD_ADDR_VAR 0 4
76277: PUSH
76278: LD_VAR 0 10
76282: PUSH
76283: FOR_IN
76284: IFFALSE 76365
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76286: LD_ADDR_VAR 0 11
76290: PUSH
76291: LD_VAR 0 10
76295: PPUSH
76296: LD_VAR 0 3
76300: PPUSH
76301: CALL_OW 265
76305: PPUSH
76306: LD_VAR 0 3
76310: PPUSH
76311: CALL_OW 262
76315: PPUSH
76316: LD_VAR 0 3
76320: PPUSH
76321: CALL_OW 263
76325: PPUSH
76326: LD_VAR 0 3
76330: PPUSH
76331: CALL_OW 264
76335: PPUSH
76336: CALL 22519 0 5
76340: ST_TO_ADDR
// if components then
76341: LD_VAR 0 11
76345: IFFALSE 76363
// begin MC_InsertProduceList ( i , components ) ;
76347: LD_VAR 0 2
76351: PPUSH
76352: LD_VAR 0 11
76356: PPUSH
76357: CALL 85581 0 2
// break ;
76361: GO 76365
// end ; end ;
76363: GO 76283
76365: POP
76366: POP
// end ; continue ;
76367: GO 75912
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76369: LD_VAR 0 3
76373: PPUSH
76374: LD_INT 1
76376: PPUSH
76377: CALL_OW 289
76381: PUSH
76382: LD_INT 100
76384: LESS
76385: PUSH
76386: LD_VAR 0 3
76390: PPUSH
76391: CALL_OW 314
76395: NOT
76396: AND
76397: IFFALSE 76426
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76399: LD_VAR 0 3
76403: PPUSH
76404: LD_VAR 0 7
76408: PUSH
76409: LD_INT 2
76411: ARRAY
76412: PPUSH
76413: LD_VAR 0 7
76417: PUSH
76418: LD_INT 3
76420: ARRAY
76421: PPUSH
76422: CALL_OW 117
// break ;
76426: GO 76430
// end ;
76428: GO 75912
76430: POP
76431: POP
// end ; end ;
76432: GO 74628
76434: POP
76435: POP
// end ;
76436: LD_VAR 0 1
76440: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76441: LD_INT 0
76443: PPUSH
76444: PPUSH
76445: PPUSH
76446: PPUSH
// if not mc_bases then
76447: LD_EXP 31
76451: NOT
76452: IFFALSE 76456
// exit ;
76454: GO 76617
// for i = 1 to mc_bases do
76456: LD_ADDR_VAR 0 2
76460: PUSH
76461: DOUBLE
76462: LD_INT 1
76464: DEC
76465: ST_TO_ADDR
76466: LD_EXP 31
76470: PUSH
76471: FOR_TO
76472: IFFALSE 76615
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76474: LD_ADDR_VAR 0 4
76478: PUSH
76479: LD_EXP 50
76483: PUSH
76484: LD_VAR 0 2
76488: ARRAY
76489: PUSH
76490: LD_EXP 53
76494: PUSH
76495: LD_VAR 0 2
76499: ARRAY
76500: UNION
76501: PPUSH
76502: LD_INT 33
76504: PUSH
76505: LD_INT 2
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PPUSH
76512: CALL_OW 72
76516: ST_TO_ADDR
// if tmp then
76517: LD_VAR 0 4
76521: IFFALSE 76613
// for j in tmp do
76523: LD_ADDR_VAR 0 3
76527: PUSH
76528: LD_VAR 0 4
76532: PUSH
76533: FOR_IN
76534: IFFALSE 76611
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76536: LD_VAR 0 3
76540: PPUSH
76541: CALL_OW 312
76545: NOT
76546: PUSH
76547: LD_VAR 0 3
76551: PPUSH
76552: CALL_OW 256
76556: PUSH
76557: LD_INT 250
76559: GREATEREQUAL
76560: AND
76561: IFFALSE 76574
// Connect ( j ) else
76563: LD_VAR 0 3
76567: PPUSH
76568: CALL 27990 0 1
76572: GO 76609
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76574: LD_VAR 0 3
76578: PPUSH
76579: CALL_OW 256
76583: PUSH
76584: LD_INT 250
76586: LESS
76587: PUSH
76588: LD_VAR 0 3
76592: PPUSH
76593: CALL_OW 312
76597: AND
76598: IFFALSE 76609
// ComUnlink ( j ) ;
76600: LD_VAR 0 3
76604: PPUSH
76605: CALL_OW 136
76609: GO 76533
76611: POP
76612: POP
// end ;
76613: GO 76471
76615: POP
76616: POP
// end ;
76617: LD_VAR 0 1
76621: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76622: LD_INT 0
76624: PPUSH
76625: PPUSH
76626: PPUSH
76627: PPUSH
76628: PPUSH
// if not mc_bases then
76629: LD_EXP 31
76633: NOT
76634: IFFALSE 76638
// exit ;
76636: GO 77083
// for i = 1 to mc_bases do
76638: LD_ADDR_VAR 0 2
76642: PUSH
76643: DOUBLE
76644: LD_INT 1
76646: DEC
76647: ST_TO_ADDR
76648: LD_EXP 31
76652: PUSH
76653: FOR_TO
76654: IFFALSE 77081
// begin if not mc_produce [ i ] then
76656: LD_EXP 52
76660: PUSH
76661: LD_VAR 0 2
76665: ARRAY
76666: NOT
76667: IFFALSE 76671
// continue ;
76669: GO 76653
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76671: LD_ADDR_VAR 0 5
76675: PUSH
76676: LD_EXP 31
76680: PUSH
76681: LD_VAR 0 2
76685: ARRAY
76686: PPUSH
76687: LD_INT 30
76689: PUSH
76690: LD_INT 3
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PPUSH
76697: CALL_OW 72
76701: ST_TO_ADDR
// if not fac then
76702: LD_VAR 0 5
76706: NOT
76707: IFFALSE 76711
// continue ;
76709: GO 76653
// for j in fac do
76711: LD_ADDR_VAR 0 3
76715: PUSH
76716: LD_VAR 0 5
76720: PUSH
76721: FOR_IN
76722: IFFALSE 77077
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76724: LD_VAR 0 3
76728: PPUSH
76729: CALL_OW 461
76733: PUSH
76734: LD_INT 2
76736: NONEQUAL
76737: PUSH
76738: LD_VAR 0 3
76742: PPUSH
76743: LD_INT 15
76745: PPUSH
76746: CALL 27618 0 2
76750: PUSH
76751: LD_INT 4
76753: ARRAY
76754: OR
76755: IFFALSE 76759
// continue ;
76757: GO 76721
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76759: LD_VAR 0 3
76763: PPUSH
76764: LD_EXP 52
76768: PUSH
76769: LD_VAR 0 2
76773: ARRAY
76774: PUSH
76775: LD_INT 1
76777: ARRAY
76778: PUSH
76779: LD_INT 1
76781: ARRAY
76782: PPUSH
76783: LD_EXP 52
76787: PUSH
76788: LD_VAR 0 2
76792: ARRAY
76793: PUSH
76794: LD_INT 1
76796: ARRAY
76797: PUSH
76798: LD_INT 2
76800: ARRAY
76801: PPUSH
76802: LD_EXP 52
76806: PUSH
76807: LD_VAR 0 2
76811: ARRAY
76812: PUSH
76813: LD_INT 1
76815: ARRAY
76816: PUSH
76817: LD_INT 3
76819: ARRAY
76820: PPUSH
76821: LD_EXP 52
76825: PUSH
76826: LD_VAR 0 2
76830: ARRAY
76831: PUSH
76832: LD_INT 1
76834: ARRAY
76835: PUSH
76836: LD_INT 4
76838: ARRAY
76839: PPUSH
76840: CALL_OW 448
76844: PUSH
76845: LD_VAR 0 3
76849: PPUSH
76850: LD_EXP 52
76854: PUSH
76855: LD_VAR 0 2
76859: ARRAY
76860: PUSH
76861: LD_INT 1
76863: ARRAY
76864: PUSH
76865: LD_INT 1
76867: ARRAY
76868: PUSH
76869: LD_EXP 52
76873: PUSH
76874: LD_VAR 0 2
76878: ARRAY
76879: PUSH
76880: LD_INT 1
76882: ARRAY
76883: PUSH
76884: LD_INT 2
76886: ARRAY
76887: PUSH
76888: LD_EXP 52
76892: PUSH
76893: LD_VAR 0 2
76897: ARRAY
76898: PUSH
76899: LD_INT 1
76901: ARRAY
76902: PUSH
76903: LD_INT 3
76905: ARRAY
76906: PUSH
76907: LD_EXP 52
76911: PUSH
76912: LD_VAR 0 2
76916: ARRAY
76917: PUSH
76918: LD_INT 1
76920: ARRAY
76921: PUSH
76922: LD_INT 4
76924: ARRAY
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: LIST
76930: LIST
76931: PPUSH
76932: CALL 31385 0 2
76936: AND
76937: IFFALSE 77075
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
76939: LD_VAR 0 3
76943: PPUSH
76944: LD_EXP 52
76948: PUSH
76949: LD_VAR 0 2
76953: ARRAY
76954: PUSH
76955: LD_INT 1
76957: ARRAY
76958: PUSH
76959: LD_INT 1
76961: ARRAY
76962: PPUSH
76963: LD_EXP 52
76967: PUSH
76968: LD_VAR 0 2
76972: ARRAY
76973: PUSH
76974: LD_INT 1
76976: ARRAY
76977: PUSH
76978: LD_INT 2
76980: ARRAY
76981: PPUSH
76982: LD_EXP 52
76986: PUSH
76987: LD_VAR 0 2
76991: ARRAY
76992: PUSH
76993: LD_INT 1
76995: ARRAY
76996: PUSH
76997: LD_INT 3
76999: ARRAY
77000: PPUSH
77001: LD_EXP 52
77005: PUSH
77006: LD_VAR 0 2
77010: ARRAY
77011: PUSH
77012: LD_INT 1
77014: ARRAY
77015: PUSH
77016: LD_INT 4
77018: ARRAY
77019: PPUSH
77020: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
77024: LD_ADDR_VAR 0 4
77028: PUSH
77029: LD_EXP 52
77033: PUSH
77034: LD_VAR 0 2
77038: ARRAY
77039: PPUSH
77040: LD_INT 1
77042: PPUSH
77043: CALL_OW 3
77047: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77048: LD_ADDR_EXP 52
77052: PUSH
77053: LD_EXP 52
77057: PPUSH
77058: LD_VAR 0 2
77062: PPUSH
77063: LD_VAR 0 4
77067: PPUSH
77068: CALL_OW 1
77072: ST_TO_ADDR
// break ;
77073: GO 77077
// end ; end ;
77075: GO 76721
77077: POP
77078: POP
// end ;
77079: GO 76653
77081: POP
77082: POP
// end ;
77083: LD_VAR 0 1
77087: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77088: LD_INT 0
77090: PPUSH
77091: PPUSH
77092: PPUSH
// if not mc_bases then
77093: LD_EXP 31
77097: NOT
77098: IFFALSE 77102
// exit ;
77100: GO 77191
// for i = 1 to mc_bases do
77102: LD_ADDR_VAR 0 2
77106: PUSH
77107: DOUBLE
77108: LD_INT 1
77110: DEC
77111: ST_TO_ADDR
77112: LD_EXP 31
77116: PUSH
77117: FOR_TO
77118: IFFALSE 77189
// begin if mc_attack [ i ] then
77120: LD_EXP 51
77124: PUSH
77125: LD_VAR 0 2
77129: ARRAY
77130: IFFALSE 77187
// begin tmp := mc_attack [ i ] [ 1 ] ;
77132: LD_ADDR_VAR 0 3
77136: PUSH
77137: LD_EXP 51
77141: PUSH
77142: LD_VAR 0 2
77146: ARRAY
77147: PUSH
77148: LD_INT 1
77150: ARRAY
77151: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
77152: LD_ADDR_EXP 51
77156: PUSH
77157: LD_EXP 51
77161: PPUSH
77162: LD_VAR 0 2
77166: PPUSH
77167: EMPTY
77168: PPUSH
77169: CALL_OW 1
77173: ST_TO_ADDR
// Attack ( tmp ) ;
77174: LD_VAR 0 3
77178: PPUSH
77179: CALL 112057 0 1
// exit ;
77183: POP
77184: POP
77185: GO 77191
// end ; end ;
77187: GO 77117
77189: POP
77190: POP
// end ;
77191: LD_VAR 0 1
77195: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77196: LD_INT 0
77198: PPUSH
77199: PPUSH
77200: PPUSH
77201: PPUSH
77202: PPUSH
77203: PPUSH
77204: PPUSH
// if not mc_bases then
77205: LD_EXP 31
77209: NOT
77210: IFFALSE 77214
// exit ;
77212: GO 78071
// for i = 1 to mc_bases do
77214: LD_ADDR_VAR 0 2
77218: PUSH
77219: DOUBLE
77220: LD_INT 1
77222: DEC
77223: ST_TO_ADDR
77224: LD_EXP 31
77228: PUSH
77229: FOR_TO
77230: IFFALSE 78069
// begin if not mc_bases [ i ] then
77232: LD_EXP 31
77236: PUSH
77237: LD_VAR 0 2
77241: ARRAY
77242: NOT
77243: IFFALSE 77247
// continue ;
77245: GO 77229
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77247: LD_ADDR_VAR 0 7
77251: PUSH
77252: LD_EXP 31
77256: PUSH
77257: LD_VAR 0 2
77261: ARRAY
77262: PUSH
77263: LD_INT 1
77265: ARRAY
77266: PPUSH
77267: CALL 21670 0 1
77271: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77272: LD_ADDR_EXP 54
77276: PUSH
77277: LD_EXP 54
77281: PPUSH
77282: LD_VAR 0 2
77286: PPUSH
77287: LD_EXP 31
77291: PUSH
77292: LD_VAR 0 2
77296: ARRAY
77297: PUSH
77298: LD_INT 1
77300: ARRAY
77301: PPUSH
77302: CALL_OW 255
77306: PPUSH
77307: LD_EXP 56
77311: PUSH
77312: LD_VAR 0 2
77316: ARRAY
77317: PPUSH
77318: CALL 21635 0 2
77322: PPUSH
77323: CALL_OW 1
77327: ST_TO_ADDR
// if not mc_scan [ i ] then
77328: LD_EXP 54
77332: PUSH
77333: LD_VAR 0 2
77337: ARRAY
77338: NOT
77339: IFFALSE 77517
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77341: LD_ADDR_EXP 74
77345: PUSH
77346: LD_EXP 74
77350: PPUSH
77351: LD_VAR 0 2
77355: PPUSH
77356: LD_INT 0
77358: PPUSH
77359: CALL_OW 1
77363: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77364: LD_ADDR_VAR 0 4
77368: PUSH
77369: LD_EXP 31
77373: PUSH
77374: LD_VAR 0 2
77378: ARRAY
77379: PPUSH
77380: LD_INT 2
77382: PUSH
77383: LD_INT 25
77385: PUSH
77386: LD_INT 5
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 25
77395: PUSH
77396: LD_INT 8
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: PUSH
77403: LD_INT 25
77405: PUSH
77406: LD_INT 9
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: LIST
77417: LIST
77418: PPUSH
77419: CALL_OW 72
77423: ST_TO_ADDR
// if not tmp then
77424: LD_VAR 0 4
77428: NOT
77429: IFFALSE 77433
// continue ;
77431: GO 77229
// for j in tmp do
77433: LD_ADDR_VAR 0 3
77437: PUSH
77438: LD_VAR 0 4
77442: PUSH
77443: FOR_IN
77444: IFFALSE 77515
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77446: LD_VAR 0 3
77450: PPUSH
77451: CALL_OW 310
77455: PPUSH
77456: CALL_OW 266
77460: PUSH
77461: LD_INT 5
77463: EQUAL
77464: PUSH
77465: LD_VAR 0 3
77469: PPUSH
77470: CALL_OW 257
77474: PUSH
77475: LD_INT 1
77477: EQUAL
77478: AND
77479: PUSH
77480: LD_VAR 0 3
77484: PPUSH
77485: CALL_OW 459
77489: NOT
77490: AND
77491: PUSH
77492: LD_VAR 0 7
77496: AND
77497: IFFALSE 77513
// ComChangeProfession ( j , class ) ;
77499: LD_VAR 0 3
77503: PPUSH
77504: LD_VAR 0 7
77508: PPUSH
77509: CALL_OW 123
77513: GO 77443
77515: POP
77516: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77517: LD_EXP 54
77521: PUSH
77522: LD_VAR 0 2
77526: ARRAY
77527: PUSH
77528: LD_EXP 74
77532: PUSH
77533: LD_VAR 0 2
77537: ARRAY
77538: NOT
77539: AND
77540: PUSH
77541: LD_EXP 53
77545: PUSH
77546: LD_VAR 0 2
77550: ARRAY
77551: NOT
77552: AND
77553: PUSH
77554: LD_EXP 31
77558: PUSH
77559: LD_VAR 0 2
77563: ARRAY
77564: PPUSH
77565: LD_INT 50
77567: PUSH
77568: EMPTY
77569: LIST
77570: PUSH
77571: LD_INT 2
77573: PUSH
77574: LD_INT 30
77576: PUSH
77577: LD_INT 32
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 30
77586: PUSH
77587: LD_INT 33
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 30
77596: PUSH
77597: LD_INT 4
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 30
77606: PUSH
77607: LD_INT 5
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PPUSH
77625: CALL_OW 72
77629: PUSH
77630: LD_INT 4
77632: LESS
77633: PUSH
77634: LD_EXP 31
77638: PUSH
77639: LD_VAR 0 2
77643: ARRAY
77644: PPUSH
77645: LD_INT 3
77647: PUSH
77648: LD_INT 24
77650: PUSH
77651: LD_INT 1000
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: LD_INT 2
77664: PUSH
77665: LD_INT 30
77667: PUSH
77668: LD_INT 0
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 30
77677: PUSH
77678: LD_INT 1
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: EMPTY
77686: LIST
77687: LIST
77688: LIST
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PPUSH
77694: CALL_OW 72
77698: OR
77699: AND
77700: IFFALSE 77951
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77702: LD_ADDR_EXP 74
77706: PUSH
77707: LD_EXP 74
77711: PPUSH
77712: LD_VAR 0 2
77716: PPUSH
77717: LD_INT 1
77719: PPUSH
77720: CALL_OW 1
77724: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77725: LD_ADDR_VAR 0 4
77729: PUSH
77730: LD_EXP 31
77734: PUSH
77735: LD_VAR 0 2
77739: ARRAY
77740: PPUSH
77741: LD_INT 2
77743: PUSH
77744: LD_INT 25
77746: PUSH
77747: LD_INT 1
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 25
77756: PUSH
77757: LD_INT 5
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: PUSH
77764: LD_INT 25
77766: PUSH
77767: LD_INT 8
77769: PUSH
77770: EMPTY
77771: LIST
77772: LIST
77773: PUSH
77774: LD_INT 25
77776: PUSH
77777: LD_INT 9
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: LIST
77788: LIST
77789: LIST
77790: PPUSH
77791: CALL_OW 72
77795: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77796: LD_ADDR_VAR 0 4
77800: PUSH
77801: LD_VAR 0 4
77805: PUSH
77806: LD_VAR 0 4
77810: PPUSH
77811: LD_INT 18
77813: PPUSH
77814: CALL 54933 0 2
77818: DIFF
77819: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77820: LD_VAR 0 4
77824: NOT
77825: PUSH
77826: LD_EXP 31
77830: PUSH
77831: LD_VAR 0 2
77835: ARRAY
77836: PPUSH
77837: LD_INT 2
77839: PUSH
77840: LD_INT 30
77842: PUSH
77843: LD_INT 4
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 30
77852: PUSH
77853: LD_INT 5
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: LIST
77864: PPUSH
77865: CALL_OW 72
77869: NOT
77870: AND
77871: IFFALSE 77933
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
77873: LD_ADDR_VAR 0 4
77877: PUSH
77878: LD_EXP 31
77882: PUSH
77883: LD_VAR 0 2
77887: ARRAY
77888: PPUSH
77889: LD_INT 2
77891: PUSH
77892: LD_INT 25
77894: PUSH
77895: LD_INT 2
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 25
77904: PUSH
77905: LD_INT 3
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: LD_INT 25
77914: PUSH
77915: LD_INT 4
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: EMPTY
77923: LIST
77924: LIST
77925: LIST
77926: LIST
77927: PPUSH
77928: CALL_OW 72
77932: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
77933: LD_VAR 0 2
77937: PPUSH
77938: LD_VAR 0 4
77942: PPUSH
77943: CALL 116766 0 2
// exit ;
77947: POP
77948: POP
77949: GO 78071
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
77951: LD_EXP 54
77955: PUSH
77956: LD_VAR 0 2
77960: ARRAY
77961: PUSH
77962: LD_EXP 74
77966: PUSH
77967: LD_VAR 0 2
77971: ARRAY
77972: NOT
77973: AND
77974: PUSH
77975: LD_EXP 53
77979: PUSH
77980: LD_VAR 0 2
77984: ARRAY
77985: AND
77986: IFFALSE 78067
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77988: LD_ADDR_EXP 74
77992: PUSH
77993: LD_EXP 74
77997: PPUSH
77998: LD_VAR 0 2
78002: PPUSH
78003: LD_INT 1
78005: PPUSH
78006: CALL_OW 1
78010: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
78011: LD_ADDR_VAR 0 4
78015: PUSH
78016: LD_EXP 53
78020: PUSH
78021: LD_VAR 0 2
78025: ARRAY
78026: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
78027: LD_ADDR_EXP 53
78031: PUSH
78032: LD_EXP 53
78036: PPUSH
78037: LD_VAR 0 2
78041: PPUSH
78042: EMPTY
78043: PPUSH
78044: CALL_OW 1
78048: ST_TO_ADDR
// Defend ( i , tmp ) ;
78049: LD_VAR 0 2
78053: PPUSH
78054: LD_VAR 0 4
78058: PPUSH
78059: CALL 117362 0 2
// exit ;
78063: POP
78064: POP
78065: GO 78071
// end ; end ;
78067: GO 77229
78069: POP
78070: POP
// end ;
78071: LD_VAR 0 1
78075: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78076: LD_INT 0
78078: PPUSH
78079: PPUSH
78080: PPUSH
78081: PPUSH
78082: PPUSH
78083: PPUSH
78084: PPUSH
78085: PPUSH
78086: PPUSH
78087: PPUSH
78088: PPUSH
// if not mc_bases then
78089: LD_EXP 31
78093: NOT
78094: IFFALSE 78098
// exit ;
78096: GO 79185
// for i = 1 to mc_bases do
78098: LD_ADDR_VAR 0 2
78102: PUSH
78103: DOUBLE
78104: LD_INT 1
78106: DEC
78107: ST_TO_ADDR
78108: LD_EXP 31
78112: PUSH
78113: FOR_TO
78114: IFFALSE 79183
// begin tmp := mc_lab [ i ] ;
78116: LD_ADDR_VAR 0 6
78120: PUSH
78121: LD_EXP 64
78125: PUSH
78126: LD_VAR 0 2
78130: ARRAY
78131: ST_TO_ADDR
// if not tmp then
78132: LD_VAR 0 6
78136: NOT
78137: IFFALSE 78141
// continue ;
78139: GO 78113
// idle_lab := 0 ;
78141: LD_ADDR_VAR 0 11
78145: PUSH
78146: LD_INT 0
78148: ST_TO_ADDR
// for j in tmp do
78149: LD_ADDR_VAR 0 3
78153: PUSH
78154: LD_VAR 0 6
78158: PUSH
78159: FOR_IN
78160: IFFALSE 79179
// begin researching := false ;
78162: LD_ADDR_VAR 0 10
78166: PUSH
78167: LD_INT 0
78169: ST_TO_ADDR
// side := GetSide ( j ) ;
78170: LD_ADDR_VAR 0 4
78174: PUSH
78175: LD_VAR 0 3
78179: PPUSH
78180: CALL_OW 255
78184: ST_TO_ADDR
// if not mc_tech [ side ] then
78185: LD_EXP 58
78189: PUSH
78190: LD_VAR 0 4
78194: ARRAY
78195: NOT
78196: IFFALSE 78200
// continue ;
78198: GO 78159
// if BuildingStatus ( j ) = bs_idle then
78200: LD_VAR 0 3
78204: PPUSH
78205: CALL_OW 461
78209: PUSH
78210: LD_INT 2
78212: EQUAL
78213: IFFALSE 78401
// begin if idle_lab and UnitsInside ( j ) < 6 then
78215: LD_VAR 0 11
78219: PUSH
78220: LD_VAR 0 3
78224: PPUSH
78225: CALL_OW 313
78229: PUSH
78230: LD_INT 6
78232: LESS
78233: AND
78234: IFFALSE 78305
// begin tmp2 := UnitsInside ( idle_lab ) ;
78236: LD_ADDR_VAR 0 9
78240: PUSH
78241: LD_VAR 0 11
78245: PPUSH
78246: CALL_OW 313
78250: ST_TO_ADDR
// if tmp2 then
78251: LD_VAR 0 9
78255: IFFALSE 78297
// for x in tmp2 do
78257: LD_ADDR_VAR 0 7
78261: PUSH
78262: LD_VAR 0 9
78266: PUSH
78267: FOR_IN
78268: IFFALSE 78295
// begin ComExitBuilding ( x ) ;
78270: LD_VAR 0 7
78274: PPUSH
78275: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78279: LD_VAR 0 7
78283: PPUSH
78284: LD_VAR 0 3
78288: PPUSH
78289: CALL_OW 180
// end ;
78293: GO 78267
78295: POP
78296: POP
// idle_lab := 0 ;
78297: LD_ADDR_VAR 0 11
78301: PUSH
78302: LD_INT 0
78304: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78305: LD_ADDR_VAR 0 5
78309: PUSH
78310: LD_EXP 58
78314: PUSH
78315: LD_VAR 0 4
78319: ARRAY
78320: PUSH
78321: FOR_IN
78322: IFFALSE 78382
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78324: LD_VAR 0 3
78328: PPUSH
78329: LD_VAR 0 5
78333: PPUSH
78334: CALL_OW 430
78338: PUSH
78339: LD_VAR 0 4
78343: PPUSH
78344: LD_VAR 0 5
78348: PPUSH
78349: CALL 20740 0 2
78353: AND
78354: IFFALSE 78380
// begin researching := true ;
78356: LD_ADDR_VAR 0 10
78360: PUSH
78361: LD_INT 1
78363: ST_TO_ADDR
// ComResearch ( j , t ) ;
78364: LD_VAR 0 3
78368: PPUSH
78369: LD_VAR 0 5
78373: PPUSH
78374: CALL_OW 124
// break ;
78378: GO 78382
// end ;
78380: GO 78321
78382: POP
78383: POP
// if not researching then
78384: LD_VAR 0 10
78388: NOT
78389: IFFALSE 78401
// idle_lab := j ;
78391: LD_ADDR_VAR 0 11
78395: PUSH
78396: LD_VAR 0 3
78400: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78401: LD_VAR 0 3
78405: PPUSH
78406: CALL_OW 461
78410: PUSH
78411: LD_INT 10
78413: EQUAL
78414: IFFALSE 79002
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78416: LD_EXP 60
78420: PUSH
78421: LD_VAR 0 2
78425: ARRAY
78426: NOT
78427: PUSH
78428: LD_EXP 61
78432: PUSH
78433: LD_VAR 0 2
78437: ARRAY
78438: NOT
78439: AND
78440: PUSH
78441: LD_EXP 58
78445: PUSH
78446: LD_VAR 0 4
78450: ARRAY
78451: PUSH
78452: LD_INT 1
78454: GREATER
78455: AND
78456: IFFALSE 78587
// begin ComCancel ( j ) ;
78458: LD_VAR 0 3
78462: PPUSH
78463: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78467: LD_ADDR_EXP 58
78471: PUSH
78472: LD_EXP 58
78476: PPUSH
78477: LD_VAR 0 4
78481: PPUSH
78482: LD_EXP 58
78486: PUSH
78487: LD_VAR 0 4
78491: ARRAY
78492: PPUSH
78493: LD_EXP 58
78497: PUSH
78498: LD_VAR 0 4
78502: ARRAY
78503: PUSH
78504: LD_INT 1
78506: MINUS
78507: PPUSH
78508: LD_EXP 58
78512: PUSH
78513: LD_VAR 0 4
78517: ARRAY
78518: PPUSH
78519: LD_INT 0
78521: PPUSH
78522: CALL 24439 0 4
78526: PPUSH
78527: CALL_OW 1
78531: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78532: LD_ADDR_EXP 58
78536: PUSH
78537: LD_EXP 58
78541: PPUSH
78542: LD_VAR 0 4
78546: PPUSH
78547: LD_EXP 58
78551: PUSH
78552: LD_VAR 0 4
78556: ARRAY
78557: PPUSH
78558: LD_EXP 58
78562: PUSH
78563: LD_VAR 0 4
78567: ARRAY
78568: PPUSH
78569: LD_INT 1
78571: PPUSH
78572: LD_INT 0
78574: PPUSH
78575: CALL 24439 0 4
78579: PPUSH
78580: CALL_OW 1
78584: ST_TO_ADDR
// continue ;
78585: GO 78159
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78587: LD_EXP 60
78591: PUSH
78592: LD_VAR 0 2
78596: ARRAY
78597: PUSH
78598: LD_EXP 61
78602: PUSH
78603: LD_VAR 0 2
78607: ARRAY
78608: NOT
78609: AND
78610: IFFALSE 78737
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78612: LD_ADDR_EXP 61
78616: PUSH
78617: LD_EXP 61
78621: PPUSH
78622: LD_VAR 0 2
78626: PUSH
78627: LD_EXP 61
78631: PUSH
78632: LD_VAR 0 2
78636: ARRAY
78637: PUSH
78638: LD_INT 1
78640: PLUS
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PPUSH
78646: LD_EXP 60
78650: PUSH
78651: LD_VAR 0 2
78655: ARRAY
78656: PUSH
78657: LD_INT 1
78659: ARRAY
78660: PPUSH
78661: CALL 25021 0 3
78665: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78666: LD_EXP 60
78670: PUSH
78671: LD_VAR 0 2
78675: ARRAY
78676: PUSH
78677: LD_INT 1
78679: ARRAY
78680: PPUSH
78681: LD_INT 112
78683: PPUSH
78684: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78688: LD_ADDR_VAR 0 9
78692: PUSH
78693: LD_EXP 60
78697: PUSH
78698: LD_VAR 0 2
78702: ARRAY
78703: PPUSH
78704: LD_INT 1
78706: PPUSH
78707: CALL_OW 3
78711: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78712: LD_ADDR_EXP 60
78716: PUSH
78717: LD_EXP 60
78721: PPUSH
78722: LD_VAR 0 2
78726: PPUSH
78727: LD_VAR 0 9
78731: PPUSH
78732: CALL_OW 1
78736: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78737: LD_EXP 60
78741: PUSH
78742: LD_VAR 0 2
78746: ARRAY
78747: PUSH
78748: LD_EXP 61
78752: PUSH
78753: LD_VAR 0 2
78757: ARRAY
78758: AND
78759: PUSH
78760: LD_EXP 61
78764: PUSH
78765: LD_VAR 0 2
78769: ARRAY
78770: PUSH
78771: LD_INT 1
78773: ARRAY
78774: PPUSH
78775: CALL_OW 310
78779: NOT
78780: AND
78781: PUSH
78782: LD_VAR 0 3
78786: PPUSH
78787: CALL_OW 313
78791: PUSH
78792: LD_INT 6
78794: EQUAL
78795: AND
78796: IFFALSE 78852
// begin tmp2 := UnitsInside ( j ) ;
78798: LD_ADDR_VAR 0 9
78802: PUSH
78803: LD_VAR 0 3
78807: PPUSH
78808: CALL_OW 313
78812: ST_TO_ADDR
// if tmp2 = 6 then
78813: LD_VAR 0 9
78817: PUSH
78818: LD_INT 6
78820: EQUAL
78821: IFFALSE 78852
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78823: LD_VAR 0 9
78827: PUSH
78828: LD_INT 1
78830: ARRAY
78831: PPUSH
78832: LD_INT 112
78834: PPUSH
78835: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78839: LD_VAR 0 9
78843: PUSH
78844: LD_INT 1
78846: ARRAY
78847: PPUSH
78848: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78852: LD_EXP 61
78856: PUSH
78857: LD_VAR 0 2
78861: ARRAY
78862: PUSH
78863: LD_EXP 61
78867: PUSH
78868: LD_VAR 0 2
78872: ARRAY
78873: PUSH
78874: LD_INT 1
78876: ARRAY
78877: PPUSH
78878: CALL_OW 314
78882: NOT
78883: AND
78884: PUSH
78885: LD_EXP 61
78889: PUSH
78890: LD_VAR 0 2
78894: ARRAY
78895: PUSH
78896: LD_INT 1
78898: ARRAY
78899: PPUSH
78900: CALL_OW 310
78904: NOT
78905: AND
78906: IFFALSE 78932
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78908: LD_EXP 61
78912: PUSH
78913: LD_VAR 0 2
78917: ARRAY
78918: PUSH
78919: LD_INT 1
78921: ARRAY
78922: PPUSH
78923: LD_VAR 0 3
78927: PPUSH
78928: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78932: LD_EXP 61
78936: PUSH
78937: LD_VAR 0 2
78941: ARRAY
78942: PUSH
78943: LD_INT 1
78945: ARRAY
78946: PPUSH
78947: CALL_OW 310
78951: PUSH
78952: LD_EXP 61
78956: PUSH
78957: LD_VAR 0 2
78961: ARRAY
78962: PUSH
78963: LD_INT 1
78965: ARRAY
78966: PPUSH
78967: CALL_OW 310
78971: PPUSH
78972: CALL_OW 461
78976: PUSH
78977: LD_INT 3
78979: NONEQUAL
78980: AND
78981: IFFALSE 79002
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78983: LD_EXP 61
78987: PUSH
78988: LD_VAR 0 2
78992: ARRAY
78993: PUSH
78994: LD_INT 1
78996: ARRAY
78997: PPUSH
78998: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
79002: LD_VAR 0 3
79006: PPUSH
79007: CALL_OW 461
79011: PUSH
79012: LD_INT 6
79014: EQUAL
79015: PUSH
79016: LD_VAR 0 6
79020: PUSH
79021: LD_INT 1
79023: GREATER
79024: AND
79025: IFFALSE 79177
// begin sci := [ ] ;
79027: LD_ADDR_VAR 0 8
79031: PUSH
79032: EMPTY
79033: ST_TO_ADDR
// for x in ( tmp diff j ) do
79034: LD_ADDR_VAR 0 7
79038: PUSH
79039: LD_VAR 0 6
79043: PUSH
79044: LD_VAR 0 3
79048: DIFF
79049: PUSH
79050: FOR_IN
79051: IFFALSE 79103
// begin if sci = 6 then
79053: LD_VAR 0 8
79057: PUSH
79058: LD_INT 6
79060: EQUAL
79061: IFFALSE 79065
// break ;
79063: GO 79103
// if BuildingStatus ( x ) = bs_idle then
79065: LD_VAR 0 7
79069: PPUSH
79070: CALL_OW 461
79074: PUSH
79075: LD_INT 2
79077: EQUAL
79078: IFFALSE 79101
// sci := sci ^ UnitsInside ( x ) ;
79080: LD_ADDR_VAR 0 8
79084: PUSH
79085: LD_VAR 0 8
79089: PUSH
79090: LD_VAR 0 7
79094: PPUSH
79095: CALL_OW 313
79099: ADD
79100: ST_TO_ADDR
// end ;
79101: GO 79050
79103: POP
79104: POP
// if not sci then
79105: LD_VAR 0 8
79109: NOT
79110: IFFALSE 79114
// continue ;
79112: GO 78159
// for x in sci do
79114: LD_ADDR_VAR 0 7
79118: PUSH
79119: LD_VAR 0 8
79123: PUSH
79124: FOR_IN
79125: IFFALSE 79175
// if IsInUnit ( x ) and not HasTask ( x ) then
79127: LD_VAR 0 7
79131: PPUSH
79132: CALL_OW 310
79136: PUSH
79137: LD_VAR 0 7
79141: PPUSH
79142: CALL_OW 314
79146: NOT
79147: AND
79148: IFFALSE 79173
// begin ComExitBuilding ( x ) ;
79150: LD_VAR 0 7
79154: PPUSH
79155: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79159: LD_VAR 0 7
79163: PPUSH
79164: LD_VAR 0 3
79168: PPUSH
79169: CALL_OW 180
// end ;
79173: GO 79124
79175: POP
79176: POP
// end ; end ;
79177: GO 78159
79179: POP
79180: POP
// end ;
79181: GO 78113
79183: POP
79184: POP
// end ;
79185: LD_VAR 0 1
79189: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79190: LD_INT 0
79192: PPUSH
79193: PPUSH
// if not mc_bases then
79194: LD_EXP 31
79198: NOT
79199: IFFALSE 79203
// exit ;
79201: GO 79284
// for i = 1 to mc_bases do
79203: LD_ADDR_VAR 0 2
79207: PUSH
79208: DOUBLE
79209: LD_INT 1
79211: DEC
79212: ST_TO_ADDR
79213: LD_EXP 31
79217: PUSH
79218: FOR_TO
79219: IFFALSE 79282
// if mc_mines [ i ] and mc_miners [ i ] then
79221: LD_EXP 44
79225: PUSH
79226: LD_VAR 0 2
79230: ARRAY
79231: PUSH
79232: LD_EXP 45
79236: PUSH
79237: LD_VAR 0 2
79241: ARRAY
79242: AND
79243: IFFALSE 79280
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79245: LD_EXP 45
79249: PUSH
79250: LD_VAR 0 2
79254: ARRAY
79255: PUSH
79256: LD_INT 1
79258: ARRAY
79259: PPUSH
79260: CALL_OW 255
79264: PPUSH
79265: LD_EXP 44
79269: PUSH
79270: LD_VAR 0 2
79274: ARRAY
79275: PPUSH
79276: CALL 21823 0 2
79280: GO 79218
79282: POP
79283: POP
// end ;
79284: LD_VAR 0 1
79288: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79289: LD_INT 0
79291: PPUSH
79292: PPUSH
79293: PPUSH
79294: PPUSH
79295: PPUSH
79296: PPUSH
79297: PPUSH
79298: PPUSH
// if not mc_bases or not mc_parking then
79299: LD_EXP 31
79303: NOT
79304: PUSH
79305: LD_EXP 55
79309: NOT
79310: OR
79311: IFFALSE 79315
// exit ;
79313: GO 80053
// for i = 1 to mc_bases do
79315: LD_ADDR_VAR 0 2
79319: PUSH
79320: DOUBLE
79321: LD_INT 1
79323: DEC
79324: ST_TO_ADDR
79325: LD_EXP 31
79329: PUSH
79330: FOR_TO
79331: IFFALSE 80051
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79333: LD_EXP 31
79337: PUSH
79338: LD_VAR 0 2
79342: ARRAY
79343: NOT
79344: PUSH
79345: LD_EXP 55
79349: PUSH
79350: LD_VAR 0 2
79354: ARRAY
79355: NOT
79356: OR
79357: IFFALSE 79361
// continue ;
79359: GO 79330
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79361: LD_ADDR_VAR 0 5
79365: PUSH
79366: LD_EXP 31
79370: PUSH
79371: LD_VAR 0 2
79375: ARRAY
79376: PUSH
79377: LD_INT 1
79379: ARRAY
79380: PPUSH
79381: CALL_OW 255
79385: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79386: LD_ADDR_VAR 0 6
79390: PUSH
79391: LD_EXP 31
79395: PUSH
79396: LD_VAR 0 2
79400: ARRAY
79401: PPUSH
79402: LD_INT 30
79404: PUSH
79405: LD_INT 3
79407: PUSH
79408: EMPTY
79409: LIST
79410: LIST
79411: PPUSH
79412: CALL_OW 72
79416: ST_TO_ADDR
// if not fac then
79417: LD_VAR 0 6
79421: NOT
79422: IFFALSE 79473
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79424: LD_ADDR_VAR 0 6
79428: PUSH
79429: LD_EXP 31
79433: PUSH
79434: LD_VAR 0 2
79438: ARRAY
79439: PPUSH
79440: LD_INT 2
79442: PUSH
79443: LD_INT 30
79445: PUSH
79446: LD_INT 0
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 30
79455: PUSH
79456: LD_INT 1
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: LIST
79467: PPUSH
79468: CALL_OW 72
79472: ST_TO_ADDR
// if not fac then
79473: LD_VAR 0 6
79477: NOT
79478: IFFALSE 79482
// continue ;
79480: GO 79330
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79482: LD_ADDR_VAR 0 7
79486: PUSH
79487: LD_EXP 55
79491: PUSH
79492: LD_VAR 0 2
79496: ARRAY
79497: PPUSH
79498: LD_INT 22
79500: PUSH
79501: LD_VAR 0 5
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 21
79512: PUSH
79513: LD_INT 2
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 3
79522: PUSH
79523: LD_INT 60
79525: PUSH
79526: EMPTY
79527: LIST
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 3
79535: PUSH
79536: LD_INT 24
79538: PUSH
79539: LD_INT 1000
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: LIST
79554: LIST
79555: PPUSH
79556: CALL_OW 70
79560: ST_TO_ADDR
// for j in fac do
79561: LD_ADDR_VAR 0 3
79565: PUSH
79566: LD_VAR 0 6
79570: PUSH
79571: FOR_IN
79572: IFFALSE 79667
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79574: LD_ADDR_VAR 0 7
79578: PUSH
79579: LD_VAR 0 7
79583: PUSH
79584: LD_INT 22
79586: PUSH
79587: LD_VAR 0 5
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 91
79598: PUSH
79599: LD_VAR 0 3
79603: PUSH
79604: LD_INT 15
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 21
79614: PUSH
79615: LD_INT 2
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: LD_INT 3
79624: PUSH
79625: LD_INT 60
79627: PUSH
79628: EMPTY
79629: LIST
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: LD_INT 3
79637: PUSH
79638: LD_INT 24
79640: PUSH
79641: LD_INT 1000
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: PPUSH
79659: CALL_OW 69
79663: UNION
79664: ST_TO_ADDR
79665: GO 79571
79667: POP
79668: POP
// if not vehs then
79669: LD_VAR 0 7
79673: NOT
79674: IFFALSE 79700
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79676: LD_ADDR_EXP 43
79680: PUSH
79681: LD_EXP 43
79685: PPUSH
79686: LD_VAR 0 2
79690: PPUSH
79691: EMPTY
79692: PPUSH
79693: CALL_OW 1
79697: ST_TO_ADDR
// continue ;
79698: GO 79330
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79700: LD_ADDR_VAR 0 8
79704: PUSH
79705: LD_EXP 31
79709: PUSH
79710: LD_VAR 0 2
79714: ARRAY
79715: PPUSH
79716: LD_INT 30
79718: PUSH
79719: LD_INT 3
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PPUSH
79726: CALL_OW 72
79730: ST_TO_ADDR
// if tmp then
79731: LD_VAR 0 8
79735: IFFALSE 79838
// begin for j in tmp do
79737: LD_ADDR_VAR 0 3
79741: PUSH
79742: LD_VAR 0 8
79746: PUSH
79747: FOR_IN
79748: IFFALSE 79836
// for k in UnitsInside ( j ) do
79750: LD_ADDR_VAR 0 4
79754: PUSH
79755: LD_VAR 0 3
79759: PPUSH
79760: CALL_OW 313
79764: PUSH
79765: FOR_IN
79766: IFFALSE 79832
// if k then
79768: LD_VAR 0 4
79772: IFFALSE 79830
// if not k in mc_repair_vehicle [ i ] then
79774: LD_VAR 0 4
79778: PUSH
79779: LD_EXP 43
79783: PUSH
79784: LD_VAR 0 2
79788: ARRAY
79789: IN
79790: NOT
79791: IFFALSE 79830
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79793: LD_ADDR_EXP 43
79797: PUSH
79798: LD_EXP 43
79802: PPUSH
79803: LD_VAR 0 2
79807: PPUSH
79808: LD_EXP 43
79812: PUSH
79813: LD_VAR 0 2
79817: ARRAY
79818: PUSH
79819: LD_VAR 0 4
79823: UNION
79824: PPUSH
79825: CALL_OW 1
79829: ST_TO_ADDR
79830: GO 79765
79832: POP
79833: POP
79834: GO 79747
79836: POP
79837: POP
// end ; if not mc_repair_vehicle [ i ] then
79838: LD_EXP 43
79842: PUSH
79843: LD_VAR 0 2
79847: ARRAY
79848: NOT
79849: IFFALSE 79853
// continue ;
79851: GO 79330
// for j in mc_repair_vehicle [ i ] do
79853: LD_ADDR_VAR 0 3
79857: PUSH
79858: LD_EXP 43
79862: PUSH
79863: LD_VAR 0 2
79867: ARRAY
79868: PUSH
79869: FOR_IN
79870: IFFALSE 80047
// begin if GetClass ( j ) <> 3 then
79872: LD_VAR 0 3
79876: PPUSH
79877: CALL_OW 257
79881: PUSH
79882: LD_INT 3
79884: NONEQUAL
79885: IFFALSE 79926
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79887: LD_ADDR_EXP 43
79891: PUSH
79892: LD_EXP 43
79896: PPUSH
79897: LD_VAR 0 2
79901: PPUSH
79902: LD_EXP 43
79906: PUSH
79907: LD_VAR 0 2
79911: ARRAY
79912: PUSH
79913: LD_VAR 0 3
79917: DIFF
79918: PPUSH
79919: CALL_OW 1
79923: ST_TO_ADDR
// continue ;
79924: GO 79869
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79926: LD_VAR 0 3
79930: PPUSH
79931: CALL_OW 311
79935: NOT
79936: PUSH
79937: LD_VAR 0 3
79941: PUSH
79942: LD_EXP 34
79946: PUSH
79947: LD_VAR 0 2
79951: ARRAY
79952: PUSH
79953: LD_INT 1
79955: ARRAY
79956: IN
79957: NOT
79958: AND
79959: PUSH
79960: LD_VAR 0 3
79964: PUSH
79965: LD_EXP 34
79969: PUSH
79970: LD_VAR 0 2
79974: ARRAY
79975: PUSH
79976: LD_INT 2
79978: ARRAY
79979: IN
79980: NOT
79981: AND
79982: IFFALSE 80045
// begin if IsInUnit ( j ) then
79984: LD_VAR 0 3
79988: PPUSH
79989: CALL_OW 310
79993: IFFALSE 80006
// ComExitBuilding ( j ) else
79995: LD_VAR 0 3
79999: PPUSH
80000: CALL_OW 122
80004: GO 80045
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
80006: LD_VAR 0 3
80010: PPUSH
80011: LD_VAR 0 7
80015: PUSH
80016: LD_INT 1
80018: ARRAY
80019: PPUSH
80020: CALL 59417 0 2
80024: NOT
80025: IFFALSE 80045
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
80027: LD_VAR 0 3
80031: PPUSH
80032: LD_VAR 0 7
80036: PUSH
80037: LD_INT 1
80039: ARRAY
80040: PPUSH
80041: CALL_OW 129
// end ; end ;
80045: GO 79869
80047: POP
80048: POP
// end ;
80049: GO 79330
80051: POP
80052: POP
// end ;
80053: LD_VAR 0 1
80057: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
80058: LD_INT 0
80060: PPUSH
80061: PPUSH
80062: PPUSH
80063: PPUSH
80064: PPUSH
80065: PPUSH
80066: PPUSH
80067: PPUSH
80068: PPUSH
80069: PPUSH
80070: PPUSH
// if not mc_bases then
80071: LD_EXP 31
80075: NOT
80076: IFFALSE 80080
// exit ;
80078: GO 80882
// for i = 1 to mc_bases do
80080: LD_ADDR_VAR 0 2
80084: PUSH
80085: DOUBLE
80086: LD_INT 1
80088: DEC
80089: ST_TO_ADDR
80090: LD_EXP 31
80094: PUSH
80095: FOR_TO
80096: IFFALSE 80880
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
80098: LD_EXP 59
80102: PUSH
80103: LD_VAR 0 2
80107: ARRAY
80108: NOT
80109: PUSH
80110: LD_EXP 34
80114: PUSH
80115: LD_VAR 0 2
80119: ARRAY
80120: PUSH
80121: LD_INT 1
80123: ARRAY
80124: OR
80125: PUSH
80126: LD_EXP 34
80130: PUSH
80131: LD_VAR 0 2
80135: ARRAY
80136: PUSH
80137: LD_INT 2
80139: ARRAY
80140: OR
80141: PUSH
80142: LD_EXP 57
80146: PUSH
80147: LD_VAR 0 2
80151: ARRAY
80152: PPUSH
80153: LD_INT 1
80155: PPUSH
80156: CALL_OW 325
80160: NOT
80161: OR
80162: PUSH
80163: LD_EXP 54
80167: PUSH
80168: LD_VAR 0 2
80172: ARRAY
80173: OR
80174: IFFALSE 80178
// continue ;
80176: GO 80095
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80178: LD_ADDR_VAR 0 8
80182: PUSH
80183: LD_EXP 31
80187: PUSH
80188: LD_VAR 0 2
80192: ARRAY
80193: PPUSH
80194: LD_INT 25
80196: PUSH
80197: LD_INT 4
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 50
80206: PUSH
80207: EMPTY
80208: LIST
80209: PUSH
80210: LD_INT 3
80212: PUSH
80213: LD_INT 60
80215: PUSH
80216: EMPTY
80217: LIST
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: LIST
80227: PPUSH
80228: CALL_OW 72
80232: PUSH
80233: LD_EXP 35
80237: PUSH
80238: LD_VAR 0 2
80242: ARRAY
80243: DIFF
80244: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80245: LD_ADDR_VAR 0 9
80249: PUSH
80250: LD_EXP 31
80254: PUSH
80255: LD_VAR 0 2
80259: ARRAY
80260: PPUSH
80261: LD_INT 2
80263: PUSH
80264: LD_INT 30
80266: PUSH
80267: LD_INT 0
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 30
80276: PUSH
80277: LD_INT 1
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: LIST
80288: PPUSH
80289: CALL_OW 72
80293: ST_TO_ADDR
// if not tmp or not dep then
80294: LD_VAR 0 8
80298: NOT
80299: PUSH
80300: LD_VAR 0 9
80304: NOT
80305: OR
80306: IFFALSE 80310
// continue ;
80308: GO 80095
// side := GetSide ( tmp [ 1 ] ) ;
80310: LD_ADDR_VAR 0 11
80314: PUSH
80315: LD_VAR 0 8
80319: PUSH
80320: LD_INT 1
80322: ARRAY
80323: PPUSH
80324: CALL_OW 255
80328: ST_TO_ADDR
// dep := dep [ 1 ] ;
80329: LD_ADDR_VAR 0 9
80333: PUSH
80334: LD_VAR 0 9
80338: PUSH
80339: LD_INT 1
80341: ARRAY
80342: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80343: LD_ADDR_VAR 0 7
80347: PUSH
80348: LD_EXP 59
80352: PUSH
80353: LD_VAR 0 2
80357: ARRAY
80358: PPUSH
80359: LD_INT 22
80361: PUSH
80362: LD_INT 0
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 25
80371: PUSH
80372: LD_INT 12
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PPUSH
80383: CALL_OW 70
80387: PUSH
80388: LD_INT 22
80390: PUSH
80391: LD_INT 0
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 25
80400: PUSH
80401: LD_INT 12
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 91
80410: PUSH
80411: LD_VAR 0 9
80415: PUSH
80416: LD_INT 20
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: LIST
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: LIST
80428: PPUSH
80429: CALL_OW 69
80433: UNION
80434: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80435: LD_ADDR_VAR 0 10
80439: PUSH
80440: LD_EXP 59
80444: PUSH
80445: LD_VAR 0 2
80449: ARRAY
80450: PPUSH
80451: LD_INT 81
80453: PUSH
80454: LD_VAR 0 11
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PPUSH
80463: CALL_OW 70
80467: ST_TO_ADDR
// if not apes or danger_at_area then
80468: LD_VAR 0 7
80472: NOT
80473: PUSH
80474: LD_VAR 0 10
80478: OR
80479: IFFALSE 80529
// begin if mc_taming [ i ] then
80481: LD_EXP 62
80485: PUSH
80486: LD_VAR 0 2
80490: ARRAY
80491: IFFALSE 80527
// begin MC_Reset ( i , 121 ) ;
80493: LD_VAR 0 2
80497: PPUSH
80498: LD_INT 121
80500: PPUSH
80501: CALL 65466 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80505: LD_ADDR_EXP 62
80509: PUSH
80510: LD_EXP 62
80514: PPUSH
80515: LD_VAR 0 2
80519: PPUSH
80520: EMPTY
80521: PPUSH
80522: CALL_OW 1
80526: ST_TO_ADDR
// end ; continue ;
80527: GO 80095
// end ; for j in tmp do
80529: LD_ADDR_VAR 0 3
80533: PUSH
80534: LD_VAR 0 8
80538: PUSH
80539: FOR_IN
80540: IFFALSE 80876
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80542: LD_VAR 0 3
80546: PUSH
80547: LD_EXP 62
80551: PUSH
80552: LD_VAR 0 2
80556: ARRAY
80557: IN
80558: NOT
80559: PUSH
80560: LD_EXP 62
80564: PUSH
80565: LD_VAR 0 2
80569: ARRAY
80570: PUSH
80571: LD_INT 3
80573: LESS
80574: AND
80575: IFFALSE 80633
// begin SetTag ( j , 121 ) ;
80577: LD_VAR 0 3
80581: PPUSH
80582: LD_INT 121
80584: PPUSH
80585: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80589: LD_ADDR_EXP 62
80593: PUSH
80594: LD_EXP 62
80598: PPUSH
80599: LD_VAR 0 2
80603: PUSH
80604: LD_EXP 62
80608: PUSH
80609: LD_VAR 0 2
80613: ARRAY
80614: PUSH
80615: LD_INT 1
80617: PLUS
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PPUSH
80623: LD_VAR 0 3
80627: PPUSH
80628: CALL 25021 0 3
80632: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80633: LD_VAR 0 3
80637: PUSH
80638: LD_EXP 62
80642: PUSH
80643: LD_VAR 0 2
80647: ARRAY
80648: IN
80649: IFFALSE 80874
// begin if GetClass ( j ) <> 4 then
80651: LD_VAR 0 3
80655: PPUSH
80656: CALL_OW 257
80660: PUSH
80661: LD_INT 4
80663: NONEQUAL
80664: IFFALSE 80717
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80666: LD_ADDR_EXP 62
80670: PUSH
80671: LD_EXP 62
80675: PPUSH
80676: LD_VAR 0 2
80680: PPUSH
80681: LD_EXP 62
80685: PUSH
80686: LD_VAR 0 2
80690: ARRAY
80691: PUSH
80692: LD_VAR 0 3
80696: DIFF
80697: PPUSH
80698: CALL_OW 1
80702: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80703: LD_VAR 0 3
80707: PPUSH
80708: LD_INT 0
80710: PPUSH
80711: CALL_OW 109
// continue ;
80715: GO 80539
// end ; if IsInUnit ( j ) then
80717: LD_VAR 0 3
80721: PPUSH
80722: CALL_OW 310
80726: IFFALSE 80737
// ComExitBuilding ( j ) ;
80728: LD_VAR 0 3
80732: PPUSH
80733: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80737: LD_ADDR_VAR 0 6
80741: PUSH
80742: LD_VAR 0 7
80746: PPUSH
80747: LD_VAR 0 3
80751: PPUSH
80752: CALL_OW 74
80756: ST_TO_ADDR
// if not ape then
80757: LD_VAR 0 6
80761: NOT
80762: IFFALSE 80766
// break ;
80764: GO 80876
// x := GetX ( ape ) ;
80766: LD_ADDR_VAR 0 4
80770: PUSH
80771: LD_VAR 0 6
80775: PPUSH
80776: CALL_OW 250
80780: ST_TO_ADDR
// y := GetY ( ape ) ;
80781: LD_ADDR_VAR 0 5
80785: PUSH
80786: LD_VAR 0 6
80790: PPUSH
80791: CALL_OW 251
80795: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80796: LD_VAR 0 4
80800: PPUSH
80801: LD_VAR 0 5
80805: PPUSH
80806: CALL_OW 488
80810: NOT
80811: PUSH
80812: LD_VAR 0 11
80816: PPUSH
80817: LD_VAR 0 4
80821: PPUSH
80822: LD_VAR 0 5
80826: PPUSH
80827: LD_INT 20
80829: PPUSH
80830: CALL 25917 0 4
80834: PUSH
80835: LD_INT 4
80837: ARRAY
80838: OR
80839: IFFALSE 80843
// break ;
80841: GO 80876
// if not HasTask ( j ) then
80843: LD_VAR 0 3
80847: PPUSH
80848: CALL_OW 314
80852: NOT
80853: IFFALSE 80874
// ComTameXY ( j , x , y ) ;
80855: LD_VAR 0 3
80859: PPUSH
80860: LD_VAR 0 4
80864: PPUSH
80865: LD_VAR 0 5
80869: PPUSH
80870: CALL_OW 131
// end ; end ;
80874: GO 80539
80876: POP
80877: POP
// end ;
80878: GO 80095
80880: POP
80881: POP
// end ;
80882: LD_VAR 0 1
80886: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80887: LD_INT 0
80889: PPUSH
80890: PPUSH
80891: PPUSH
80892: PPUSH
80893: PPUSH
80894: PPUSH
80895: PPUSH
80896: PPUSH
// if not mc_bases then
80897: LD_EXP 31
80901: NOT
80902: IFFALSE 80906
// exit ;
80904: GO 81532
// for i = 1 to mc_bases do
80906: LD_ADDR_VAR 0 2
80910: PUSH
80911: DOUBLE
80912: LD_INT 1
80914: DEC
80915: ST_TO_ADDR
80916: LD_EXP 31
80920: PUSH
80921: FOR_TO
80922: IFFALSE 81530
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80924: LD_EXP 60
80928: PUSH
80929: LD_VAR 0 2
80933: ARRAY
80934: NOT
80935: PUSH
80936: LD_EXP 60
80940: PUSH
80941: LD_VAR 0 2
80945: ARRAY
80946: PPUSH
80947: LD_INT 25
80949: PUSH
80950: LD_INT 12
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PPUSH
80957: CALL_OW 72
80961: NOT
80962: OR
80963: IFFALSE 80967
// continue ;
80965: GO 80921
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80967: LD_ADDR_VAR 0 5
80971: PUSH
80972: LD_EXP 60
80976: PUSH
80977: LD_VAR 0 2
80981: ARRAY
80982: PUSH
80983: LD_INT 1
80985: ARRAY
80986: PPUSH
80987: CALL_OW 255
80991: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80992: LD_VAR 0 5
80996: PPUSH
80997: LD_INT 2
80999: PPUSH
81000: CALL_OW 325
81004: IFFALSE 81257
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81006: LD_ADDR_VAR 0 4
81010: PUSH
81011: LD_EXP 60
81015: PUSH
81016: LD_VAR 0 2
81020: ARRAY
81021: PPUSH
81022: LD_INT 25
81024: PUSH
81025: LD_INT 16
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PPUSH
81032: CALL_OW 72
81036: ST_TO_ADDR
// if tmp < 6 then
81037: LD_VAR 0 4
81041: PUSH
81042: LD_INT 6
81044: LESS
81045: IFFALSE 81257
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81047: LD_ADDR_VAR 0 6
81051: PUSH
81052: LD_EXP 31
81056: PUSH
81057: LD_VAR 0 2
81061: ARRAY
81062: PPUSH
81063: LD_INT 2
81065: PUSH
81066: LD_INT 30
81068: PUSH
81069: LD_INT 0
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 30
81078: PUSH
81079: LD_INT 1
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: LIST
81090: PPUSH
81091: CALL_OW 72
81095: ST_TO_ADDR
// if depot then
81096: LD_VAR 0 6
81100: IFFALSE 81257
// begin selected := 0 ;
81102: LD_ADDR_VAR 0 7
81106: PUSH
81107: LD_INT 0
81109: ST_TO_ADDR
// for j in depot do
81110: LD_ADDR_VAR 0 3
81114: PUSH
81115: LD_VAR 0 6
81119: PUSH
81120: FOR_IN
81121: IFFALSE 81152
// begin if UnitsInside ( j ) < 6 then
81123: LD_VAR 0 3
81127: PPUSH
81128: CALL_OW 313
81132: PUSH
81133: LD_INT 6
81135: LESS
81136: IFFALSE 81150
// begin selected := j ;
81138: LD_ADDR_VAR 0 7
81142: PUSH
81143: LD_VAR 0 3
81147: ST_TO_ADDR
// break ;
81148: GO 81152
// end ; end ;
81150: GO 81120
81152: POP
81153: POP
// if selected then
81154: LD_VAR 0 7
81158: IFFALSE 81257
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81160: LD_ADDR_VAR 0 3
81164: PUSH
81165: LD_EXP 60
81169: PUSH
81170: LD_VAR 0 2
81174: ARRAY
81175: PPUSH
81176: LD_INT 25
81178: PUSH
81179: LD_INT 12
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PPUSH
81186: CALL_OW 72
81190: PUSH
81191: FOR_IN
81192: IFFALSE 81255
// if not HasTask ( j ) then
81194: LD_VAR 0 3
81198: PPUSH
81199: CALL_OW 314
81203: NOT
81204: IFFALSE 81253
// begin if not IsInUnit ( j ) then
81206: LD_VAR 0 3
81210: PPUSH
81211: CALL_OW 310
81215: NOT
81216: IFFALSE 81232
// ComEnterUnit ( j , selected ) ;
81218: LD_VAR 0 3
81222: PPUSH
81223: LD_VAR 0 7
81227: PPUSH
81228: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81232: LD_VAR 0 3
81236: PPUSH
81237: LD_INT 16
81239: PPUSH
81240: CALL_OW 183
// AddComExitBuilding ( j ) ;
81244: LD_VAR 0 3
81248: PPUSH
81249: CALL_OW 182
// end ;
81253: GO 81191
81255: POP
81256: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81257: LD_VAR 0 5
81261: PPUSH
81262: LD_INT 11
81264: PPUSH
81265: CALL_OW 325
81269: IFFALSE 81528
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81271: LD_ADDR_VAR 0 4
81275: PUSH
81276: LD_EXP 60
81280: PUSH
81281: LD_VAR 0 2
81285: ARRAY
81286: PPUSH
81287: LD_INT 25
81289: PUSH
81290: LD_INT 16
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PPUSH
81297: CALL_OW 72
81301: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81302: LD_VAR 0 4
81306: PUSH
81307: LD_INT 6
81309: GREATEREQUAL
81310: PUSH
81311: LD_VAR 0 5
81315: PPUSH
81316: LD_INT 2
81318: PPUSH
81319: CALL_OW 325
81323: NOT
81324: OR
81325: IFFALSE 81528
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81327: LD_ADDR_VAR 0 8
81331: PUSH
81332: LD_EXP 31
81336: PUSH
81337: LD_VAR 0 2
81341: ARRAY
81342: PPUSH
81343: LD_INT 2
81345: PUSH
81346: LD_INT 30
81348: PUSH
81349: LD_INT 4
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 30
81358: PUSH
81359: LD_INT 5
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: LIST
81370: PPUSH
81371: CALL_OW 72
81375: ST_TO_ADDR
// if barracks then
81376: LD_VAR 0 8
81380: IFFALSE 81528
// begin selected := 0 ;
81382: LD_ADDR_VAR 0 7
81386: PUSH
81387: LD_INT 0
81389: ST_TO_ADDR
// for j in barracks do
81390: LD_ADDR_VAR 0 3
81394: PUSH
81395: LD_VAR 0 8
81399: PUSH
81400: FOR_IN
81401: IFFALSE 81432
// begin if UnitsInside ( j ) < 6 then
81403: LD_VAR 0 3
81407: PPUSH
81408: CALL_OW 313
81412: PUSH
81413: LD_INT 6
81415: LESS
81416: IFFALSE 81430
// begin selected := j ;
81418: LD_ADDR_VAR 0 7
81422: PUSH
81423: LD_VAR 0 3
81427: ST_TO_ADDR
// break ;
81428: GO 81432
// end ; end ;
81430: GO 81400
81432: POP
81433: POP
// if selected then
81434: LD_VAR 0 7
81438: IFFALSE 81528
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81440: LD_ADDR_VAR 0 3
81444: PUSH
81445: LD_EXP 60
81449: PUSH
81450: LD_VAR 0 2
81454: ARRAY
81455: PPUSH
81456: LD_INT 25
81458: PUSH
81459: LD_INT 12
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PPUSH
81466: CALL_OW 72
81470: PUSH
81471: FOR_IN
81472: IFFALSE 81526
// if not IsInUnit ( j ) and not HasTask ( j ) then
81474: LD_VAR 0 3
81478: PPUSH
81479: CALL_OW 310
81483: NOT
81484: PUSH
81485: LD_VAR 0 3
81489: PPUSH
81490: CALL_OW 314
81494: NOT
81495: AND
81496: IFFALSE 81524
// begin ComEnterUnit ( j , selected ) ;
81498: LD_VAR 0 3
81502: PPUSH
81503: LD_VAR 0 7
81507: PPUSH
81508: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81512: LD_VAR 0 3
81516: PPUSH
81517: LD_INT 15
81519: PPUSH
81520: CALL_OW 183
// end ;
81524: GO 81471
81526: POP
81527: POP
// end ; end ; end ; end ; end ;
81528: GO 80921
81530: POP
81531: POP
// end ;
81532: LD_VAR 0 1
81536: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81537: LD_INT 0
81539: PPUSH
81540: PPUSH
81541: PPUSH
81542: PPUSH
// if not mc_bases then
81543: LD_EXP 31
81547: NOT
81548: IFFALSE 81552
// exit ;
81550: GO 81730
// for i = 1 to mc_bases do
81552: LD_ADDR_VAR 0 2
81556: PUSH
81557: DOUBLE
81558: LD_INT 1
81560: DEC
81561: ST_TO_ADDR
81562: LD_EXP 31
81566: PUSH
81567: FOR_TO
81568: IFFALSE 81728
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81570: LD_ADDR_VAR 0 4
81574: PUSH
81575: LD_EXP 31
81579: PUSH
81580: LD_VAR 0 2
81584: ARRAY
81585: PPUSH
81586: LD_INT 25
81588: PUSH
81589: LD_INT 9
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PPUSH
81596: CALL_OW 72
81600: ST_TO_ADDR
// if not tmp then
81601: LD_VAR 0 4
81605: NOT
81606: IFFALSE 81610
// continue ;
81608: GO 81567
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81610: LD_EXP 57
81614: PUSH
81615: LD_VAR 0 2
81619: ARRAY
81620: PPUSH
81621: LD_INT 29
81623: PPUSH
81624: CALL_OW 325
81628: NOT
81629: PUSH
81630: LD_EXP 57
81634: PUSH
81635: LD_VAR 0 2
81639: ARRAY
81640: PPUSH
81641: LD_INT 28
81643: PPUSH
81644: CALL_OW 325
81648: NOT
81649: AND
81650: IFFALSE 81654
// continue ;
81652: GO 81567
// for j in tmp do
81654: LD_ADDR_VAR 0 3
81658: PUSH
81659: LD_VAR 0 4
81663: PUSH
81664: FOR_IN
81665: IFFALSE 81724
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81667: LD_VAR 0 3
81671: PUSH
81672: LD_EXP 34
81676: PUSH
81677: LD_VAR 0 2
81681: ARRAY
81682: PUSH
81683: LD_INT 1
81685: ARRAY
81686: IN
81687: NOT
81688: PUSH
81689: LD_VAR 0 3
81693: PUSH
81694: LD_EXP 34
81698: PUSH
81699: LD_VAR 0 2
81703: ARRAY
81704: PUSH
81705: LD_INT 2
81707: ARRAY
81708: IN
81709: NOT
81710: AND
81711: IFFALSE 81722
// ComSpaceTimeShoot ( j ) ;
81713: LD_VAR 0 3
81717: PPUSH
81718: CALL 20831 0 1
81722: GO 81664
81724: POP
81725: POP
// end ;
81726: GO 81567
81728: POP
81729: POP
// end ;
81730: LD_VAR 0 1
81734: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81735: LD_INT 0
81737: PPUSH
81738: PPUSH
81739: PPUSH
81740: PPUSH
81741: PPUSH
81742: PPUSH
81743: PPUSH
81744: PPUSH
81745: PPUSH
// if not mc_bases then
81746: LD_EXP 31
81750: NOT
81751: IFFALSE 81755
// exit ;
81753: GO 82377
// for i = 1 to mc_bases do
81755: LD_ADDR_VAR 0 2
81759: PUSH
81760: DOUBLE
81761: LD_INT 1
81763: DEC
81764: ST_TO_ADDR
81765: LD_EXP 31
81769: PUSH
81770: FOR_TO
81771: IFFALSE 82375
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81773: LD_EXP 66
81777: PUSH
81778: LD_VAR 0 2
81782: ARRAY
81783: NOT
81784: PUSH
81785: LD_INT 38
81787: PPUSH
81788: LD_EXP 57
81792: PUSH
81793: LD_VAR 0 2
81797: ARRAY
81798: PPUSH
81799: CALL_OW 321
81803: PUSH
81804: LD_INT 2
81806: NONEQUAL
81807: OR
81808: IFFALSE 81812
// continue ;
81810: GO 81770
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81812: LD_ADDR_VAR 0 8
81816: PUSH
81817: LD_EXP 31
81821: PUSH
81822: LD_VAR 0 2
81826: ARRAY
81827: PPUSH
81828: LD_INT 30
81830: PUSH
81831: LD_INT 34
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PPUSH
81838: CALL_OW 72
81842: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81843: LD_ADDR_VAR 0 9
81847: PUSH
81848: LD_EXP 31
81852: PUSH
81853: LD_VAR 0 2
81857: ARRAY
81858: PPUSH
81859: LD_INT 25
81861: PUSH
81862: LD_INT 4
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PPUSH
81869: CALL_OW 72
81873: PPUSH
81874: LD_INT 0
81876: PPUSH
81877: CALL 54933 0 2
81881: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81882: LD_VAR 0 9
81886: NOT
81887: PUSH
81888: LD_VAR 0 8
81892: NOT
81893: OR
81894: PUSH
81895: LD_EXP 31
81899: PUSH
81900: LD_VAR 0 2
81904: ARRAY
81905: PPUSH
81906: LD_INT 124
81908: PPUSH
81909: CALL 54933 0 2
81913: OR
81914: IFFALSE 81918
// continue ;
81916: GO 81770
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81918: LD_EXP 67
81922: PUSH
81923: LD_VAR 0 2
81927: ARRAY
81928: PUSH
81929: LD_EXP 66
81933: PUSH
81934: LD_VAR 0 2
81938: ARRAY
81939: LESS
81940: PUSH
81941: LD_EXP 67
81945: PUSH
81946: LD_VAR 0 2
81950: ARRAY
81951: PUSH
81952: LD_VAR 0 8
81956: LESS
81957: AND
81958: IFFALSE 82373
// begin tmp := sci [ 1 ] ;
81960: LD_ADDR_VAR 0 7
81964: PUSH
81965: LD_VAR 0 9
81969: PUSH
81970: LD_INT 1
81972: ARRAY
81973: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81974: LD_VAR 0 7
81978: PPUSH
81979: LD_INT 124
81981: PPUSH
81982: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81986: LD_ADDR_VAR 0 3
81990: PUSH
81991: DOUBLE
81992: LD_EXP 66
81996: PUSH
81997: LD_VAR 0 2
82001: ARRAY
82002: INC
82003: ST_TO_ADDR
82004: LD_EXP 66
82008: PUSH
82009: LD_VAR 0 2
82013: ARRAY
82014: PUSH
82015: FOR_DOWNTO
82016: IFFALSE 82359
// begin if IsInUnit ( tmp ) then
82018: LD_VAR 0 7
82022: PPUSH
82023: CALL_OW 310
82027: IFFALSE 82038
// ComExitBuilding ( tmp ) ;
82029: LD_VAR 0 7
82033: PPUSH
82034: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
82038: LD_INT 35
82040: PPUSH
82041: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
82045: LD_VAR 0 7
82049: PPUSH
82050: CALL_OW 310
82054: NOT
82055: PUSH
82056: LD_VAR 0 7
82060: PPUSH
82061: CALL_OW 314
82065: NOT
82066: AND
82067: IFFALSE 82038
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
82069: LD_ADDR_VAR 0 6
82073: PUSH
82074: LD_VAR 0 7
82078: PPUSH
82079: CALL_OW 250
82083: PUSH
82084: LD_VAR 0 7
82088: PPUSH
82089: CALL_OW 251
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
82098: LD_INT 35
82100: PPUSH
82101: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82105: LD_ADDR_VAR 0 4
82109: PUSH
82110: LD_EXP 66
82114: PUSH
82115: LD_VAR 0 2
82119: ARRAY
82120: PUSH
82121: LD_VAR 0 3
82125: ARRAY
82126: PUSH
82127: LD_INT 1
82129: ARRAY
82130: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82131: LD_ADDR_VAR 0 5
82135: PUSH
82136: LD_EXP 66
82140: PUSH
82141: LD_VAR 0 2
82145: ARRAY
82146: PUSH
82147: LD_VAR 0 3
82151: ARRAY
82152: PUSH
82153: LD_INT 2
82155: ARRAY
82156: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82157: LD_VAR 0 7
82161: PPUSH
82162: LD_INT 10
82164: PPUSH
82165: CALL 27618 0 2
82169: PUSH
82170: LD_INT 4
82172: ARRAY
82173: IFFALSE 82211
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82175: LD_VAR 0 7
82179: PPUSH
82180: LD_VAR 0 6
82184: PUSH
82185: LD_INT 1
82187: ARRAY
82188: PPUSH
82189: LD_VAR 0 6
82193: PUSH
82194: LD_INT 2
82196: ARRAY
82197: PPUSH
82198: CALL_OW 111
// wait ( 0 0$10 ) ;
82202: LD_INT 350
82204: PPUSH
82205: CALL_OW 67
// end else
82209: GO 82237
// begin ComMoveXY ( tmp , x , y ) ;
82211: LD_VAR 0 7
82215: PPUSH
82216: LD_VAR 0 4
82220: PPUSH
82221: LD_VAR 0 5
82225: PPUSH
82226: CALL_OW 111
// wait ( 0 0$3 ) ;
82230: LD_INT 105
82232: PPUSH
82233: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82237: LD_VAR 0 7
82241: PPUSH
82242: LD_VAR 0 4
82246: PPUSH
82247: LD_VAR 0 5
82251: PPUSH
82252: CALL_OW 307
82256: IFFALSE 82098
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82258: LD_VAR 0 7
82262: PPUSH
82263: LD_VAR 0 4
82267: PPUSH
82268: LD_VAR 0 5
82272: PPUSH
82273: LD_VAR 0 8
82277: PUSH
82278: LD_VAR 0 3
82282: ARRAY
82283: PPUSH
82284: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82288: LD_INT 35
82290: PPUSH
82291: CALL_OW 67
// until not HasTask ( tmp ) ;
82295: LD_VAR 0 7
82299: PPUSH
82300: CALL_OW 314
82304: NOT
82305: IFFALSE 82288
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82307: LD_ADDR_EXP 67
82311: PUSH
82312: LD_EXP 67
82316: PPUSH
82317: LD_VAR 0 2
82321: PUSH
82322: LD_EXP 67
82326: PUSH
82327: LD_VAR 0 2
82331: ARRAY
82332: PUSH
82333: LD_INT 1
82335: PLUS
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PPUSH
82341: LD_VAR 0 8
82345: PUSH
82346: LD_VAR 0 3
82350: ARRAY
82351: PPUSH
82352: CALL 25021 0 3
82356: ST_TO_ADDR
// end ;
82357: GO 82015
82359: POP
82360: POP
// MC_Reset ( i , 124 ) ;
82361: LD_VAR 0 2
82365: PPUSH
82366: LD_INT 124
82368: PPUSH
82369: CALL 65466 0 2
// end ; end ;
82373: GO 81770
82375: POP
82376: POP
// end ;
82377: LD_VAR 0 1
82381: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82382: LD_INT 0
82384: PPUSH
82385: PPUSH
82386: PPUSH
// if not mc_bases then
82387: LD_EXP 31
82391: NOT
82392: IFFALSE 82396
// exit ;
82394: GO 83002
// for i = 1 to mc_bases do
82396: LD_ADDR_VAR 0 2
82400: PUSH
82401: DOUBLE
82402: LD_INT 1
82404: DEC
82405: ST_TO_ADDR
82406: LD_EXP 31
82410: PUSH
82411: FOR_TO
82412: IFFALSE 83000
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82414: LD_ADDR_VAR 0 3
82418: PUSH
82419: LD_EXP 31
82423: PUSH
82424: LD_VAR 0 2
82428: ARRAY
82429: PPUSH
82430: LD_INT 25
82432: PUSH
82433: LD_INT 4
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PPUSH
82440: CALL_OW 72
82444: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82445: LD_VAR 0 3
82449: NOT
82450: PUSH
82451: LD_EXP 68
82455: PUSH
82456: LD_VAR 0 2
82460: ARRAY
82461: NOT
82462: OR
82463: PUSH
82464: LD_EXP 31
82468: PUSH
82469: LD_VAR 0 2
82473: ARRAY
82474: PPUSH
82475: LD_INT 2
82477: PUSH
82478: LD_INT 30
82480: PUSH
82481: LD_INT 0
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 30
82490: PUSH
82491: LD_INT 1
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: LIST
82502: PPUSH
82503: CALL_OW 72
82507: NOT
82508: OR
82509: IFFALSE 82559
// begin if mc_deposits_finder [ i ] then
82511: LD_EXP 69
82515: PUSH
82516: LD_VAR 0 2
82520: ARRAY
82521: IFFALSE 82557
// begin MC_Reset ( i , 125 ) ;
82523: LD_VAR 0 2
82527: PPUSH
82528: LD_INT 125
82530: PPUSH
82531: CALL 65466 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82535: LD_ADDR_EXP 69
82539: PUSH
82540: LD_EXP 69
82544: PPUSH
82545: LD_VAR 0 2
82549: PPUSH
82550: EMPTY
82551: PPUSH
82552: CALL_OW 1
82556: ST_TO_ADDR
// end ; continue ;
82557: GO 82411
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82559: LD_EXP 68
82563: PUSH
82564: LD_VAR 0 2
82568: ARRAY
82569: PUSH
82570: LD_INT 1
82572: ARRAY
82573: PUSH
82574: LD_INT 3
82576: ARRAY
82577: PUSH
82578: LD_INT 1
82580: EQUAL
82581: PUSH
82582: LD_INT 20
82584: PPUSH
82585: LD_EXP 57
82589: PUSH
82590: LD_VAR 0 2
82594: ARRAY
82595: PPUSH
82596: CALL_OW 321
82600: PUSH
82601: LD_INT 2
82603: NONEQUAL
82604: AND
82605: IFFALSE 82655
// begin if mc_deposits_finder [ i ] then
82607: LD_EXP 69
82611: PUSH
82612: LD_VAR 0 2
82616: ARRAY
82617: IFFALSE 82653
// begin MC_Reset ( i , 125 ) ;
82619: LD_VAR 0 2
82623: PPUSH
82624: LD_INT 125
82626: PPUSH
82627: CALL 65466 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82631: LD_ADDR_EXP 69
82635: PUSH
82636: LD_EXP 69
82640: PPUSH
82641: LD_VAR 0 2
82645: PPUSH
82646: EMPTY
82647: PPUSH
82648: CALL_OW 1
82652: ST_TO_ADDR
// end ; continue ;
82653: GO 82411
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82655: LD_EXP 68
82659: PUSH
82660: LD_VAR 0 2
82664: ARRAY
82665: PUSH
82666: LD_INT 1
82668: ARRAY
82669: PUSH
82670: LD_INT 1
82672: ARRAY
82673: PPUSH
82674: LD_EXP 68
82678: PUSH
82679: LD_VAR 0 2
82683: ARRAY
82684: PUSH
82685: LD_INT 1
82687: ARRAY
82688: PUSH
82689: LD_INT 2
82691: ARRAY
82692: PPUSH
82693: LD_EXP 57
82697: PUSH
82698: LD_VAR 0 2
82702: ARRAY
82703: PPUSH
82704: CALL_OW 440
82708: IFFALSE 82751
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82710: LD_ADDR_EXP 68
82714: PUSH
82715: LD_EXP 68
82719: PPUSH
82720: LD_VAR 0 2
82724: PPUSH
82725: LD_EXP 68
82729: PUSH
82730: LD_VAR 0 2
82734: ARRAY
82735: PPUSH
82736: LD_INT 1
82738: PPUSH
82739: CALL_OW 3
82743: PPUSH
82744: CALL_OW 1
82748: ST_TO_ADDR
82749: GO 82998
// begin if not mc_deposits_finder [ i ] then
82751: LD_EXP 69
82755: PUSH
82756: LD_VAR 0 2
82760: ARRAY
82761: NOT
82762: IFFALSE 82814
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82764: LD_ADDR_EXP 69
82768: PUSH
82769: LD_EXP 69
82773: PPUSH
82774: LD_VAR 0 2
82778: PPUSH
82779: LD_VAR 0 3
82783: PUSH
82784: LD_INT 1
82786: ARRAY
82787: PUSH
82788: EMPTY
82789: LIST
82790: PPUSH
82791: CALL_OW 1
82795: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82796: LD_VAR 0 3
82800: PUSH
82801: LD_INT 1
82803: ARRAY
82804: PPUSH
82805: LD_INT 125
82807: PPUSH
82808: CALL_OW 109
// end else
82812: GO 82998
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82814: LD_EXP 69
82818: PUSH
82819: LD_VAR 0 2
82823: ARRAY
82824: PUSH
82825: LD_INT 1
82827: ARRAY
82828: PPUSH
82829: CALL_OW 310
82833: IFFALSE 82856
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82835: LD_EXP 69
82839: PUSH
82840: LD_VAR 0 2
82844: ARRAY
82845: PUSH
82846: LD_INT 1
82848: ARRAY
82849: PPUSH
82850: CALL_OW 122
82854: GO 82998
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82856: LD_EXP 69
82860: PUSH
82861: LD_VAR 0 2
82865: ARRAY
82866: PUSH
82867: LD_INT 1
82869: ARRAY
82870: PPUSH
82871: CALL_OW 314
82875: NOT
82876: PUSH
82877: LD_EXP 69
82881: PUSH
82882: LD_VAR 0 2
82886: ARRAY
82887: PUSH
82888: LD_INT 1
82890: ARRAY
82891: PPUSH
82892: LD_EXP 68
82896: PUSH
82897: LD_VAR 0 2
82901: ARRAY
82902: PUSH
82903: LD_INT 1
82905: ARRAY
82906: PUSH
82907: LD_INT 1
82909: ARRAY
82910: PPUSH
82911: LD_EXP 68
82915: PUSH
82916: LD_VAR 0 2
82920: ARRAY
82921: PUSH
82922: LD_INT 1
82924: ARRAY
82925: PUSH
82926: LD_INT 2
82928: ARRAY
82929: PPUSH
82930: CALL_OW 297
82934: PUSH
82935: LD_INT 6
82937: GREATER
82938: AND
82939: IFFALSE 82998
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82941: LD_EXP 69
82945: PUSH
82946: LD_VAR 0 2
82950: ARRAY
82951: PUSH
82952: LD_INT 1
82954: ARRAY
82955: PPUSH
82956: LD_EXP 68
82960: PUSH
82961: LD_VAR 0 2
82965: ARRAY
82966: PUSH
82967: LD_INT 1
82969: ARRAY
82970: PUSH
82971: LD_INT 1
82973: ARRAY
82974: PPUSH
82975: LD_EXP 68
82979: PUSH
82980: LD_VAR 0 2
82984: ARRAY
82985: PUSH
82986: LD_INT 1
82988: ARRAY
82989: PUSH
82990: LD_INT 2
82992: ARRAY
82993: PPUSH
82994: CALL_OW 111
// end ; end ; end ;
82998: GO 82411
83000: POP
83001: POP
// end ;
83002: LD_VAR 0 1
83006: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
83007: LD_INT 0
83009: PPUSH
83010: PPUSH
83011: PPUSH
83012: PPUSH
83013: PPUSH
83014: PPUSH
83015: PPUSH
83016: PPUSH
83017: PPUSH
83018: PPUSH
83019: PPUSH
// if not mc_bases then
83020: LD_EXP 31
83024: NOT
83025: IFFALSE 83029
// exit ;
83027: GO 83969
// for i = 1 to mc_bases do
83029: LD_ADDR_VAR 0 2
83033: PUSH
83034: DOUBLE
83035: LD_INT 1
83037: DEC
83038: ST_TO_ADDR
83039: LD_EXP 31
83043: PUSH
83044: FOR_TO
83045: IFFALSE 83967
// begin if not mc_bases [ i ] or mc_scan [ i ] then
83047: LD_EXP 31
83051: PUSH
83052: LD_VAR 0 2
83056: ARRAY
83057: NOT
83058: PUSH
83059: LD_EXP 54
83063: PUSH
83064: LD_VAR 0 2
83068: ARRAY
83069: OR
83070: IFFALSE 83074
// continue ;
83072: GO 83044
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
83074: LD_ADDR_VAR 0 7
83078: PUSH
83079: LD_EXP 31
83083: PUSH
83084: LD_VAR 0 2
83088: ARRAY
83089: PUSH
83090: LD_INT 1
83092: ARRAY
83093: PPUSH
83094: CALL_OW 248
83098: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83099: LD_VAR 0 7
83103: PUSH
83104: LD_INT 3
83106: EQUAL
83107: PUSH
83108: LD_EXP 50
83112: PUSH
83113: LD_VAR 0 2
83117: ARRAY
83118: PUSH
83119: LD_EXP 53
83123: PUSH
83124: LD_VAR 0 2
83128: ARRAY
83129: UNION
83130: PPUSH
83131: LD_INT 33
83133: PUSH
83134: LD_INT 2
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PPUSH
83141: CALL_OW 72
83145: NOT
83146: OR
83147: IFFALSE 83151
// continue ;
83149: GO 83044
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83151: LD_ADDR_VAR 0 9
83155: PUSH
83156: LD_EXP 31
83160: PUSH
83161: LD_VAR 0 2
83165: ARRAY
83166: PPUSH
83167: LD_INT 30
83169: PUSH
83170: LD_INT 36
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PPUSH
83177: CALL_OW 72
83181: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83182: LD_ADDR_VAR 0 10
83186: PUSH
83187: LD_EXP 50
83191: PUSH
83192: LD_VAR 0 2
83196: ARRAY
83197: PPUSH
83198: LD_INT 34
83200: PUSH
83201: LD_INT 31
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PPUSH
83208: CALL_OW 72
83212: ST_TO_ADDR
// if not cts and not mcts then
83213: LD_VAR 0 9
83217: NOT
83218: PUSH
83219: LD_VAR 0 10
83223: NOT
83224: AND
83225: IFFALSE 83229
// continue ;
83227: GO 83044
// x := cts ;
83229: LD_ADDR_VAR 0 11
83233: PUSH
83234: LD_VAR 0 9
83238: ST_TO_ADDR
// if not x then
83239: LD_VAR 0 11
83243: NOT
83244: IFFALSE 83256
// x := mcts ;
83246: LD_ADDR_VAR 0 11
83250: PUSH
83251: LD_VAR 0 10
83255: ST_TO_ADDR
// if not x then
83256: LD_VAR 0 11
83260: NOT
83261: IFFALSE 83265
// continue ;
83263: GO 83044
// if mc_remote_driver [ i ] then
83265: LD_EXP 71
83269: PUSH
83270: LD_VAR 0 2
83274: ARRAY
83275: IFFALSE 83662
// for j in mc_remote_driver [ i ] do
83277: LD_ADDR_VAR 0 3
83281: PUSH
83282: LD_EXP 71
83286: PUSH
83287: LD_VAR 0 2
83291: ARRAY
83292: PUSH
83293: FOR_IN
83294: IFFALSE 83660
// begin if GetClass ( j ) <> 3 then
83296: LD_VAR 0 3
83300: PPUSH
83301: CALL_OW 257
83305: PUSH
83306: LD_INT 3
83308: NONEQUAL
83309: IFFALSE 83362
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83311: LD_ADDR_EXP 71
83315: PUSH
83316: LD_EXP 71
83320: PPUSH
83321: LD_VAR 0 2
83325: PPUSH
83326: LD_EXP 71
83330: PUSH
83331: LD_VAR 0 2
83335: ARRAY
83336: PUSH
83337: LD_VAR 0 3
83341: DIFF
83342: PPUSH
83343: CALL_OW 1
83347: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83348: LD_VAR 0 3
83352: PPUSH
83353: LD_INT 0
83355: PPUSH
83356: CALL_OW 109
// continue ;
83360: GO 83293
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83362: LD_EXP 50
83366: PUSH
83367: LD_VAR 0 2
83371: ARRAY
83372: PPUSH
83373: LD_INT 34
83375: PUSH
83376: LD_INT 31
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 58
83385: PUSH
83386: EMPTY
83387: LIST
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PPUSH
83393: CALL_OW 72
83397: PUSH
83398: LD_VAR 0 3
83402: PPUSH
83403: CALL 54968 0 1
83407: NOT
83408: AND
83409: IFFALSE 83480
// begin if IsInUnit ( j ) then
83411: LD_VAR 0 3
83415: PPUSH
83416: CALL_OW 310
83420: IFFALSE 83431
// ComExitBuilding ( j ) ;
83422: LD_VAR 0 3
83426: PPUSH
83427: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83431: LD_VAR 0 3
83435: PPUSH
83436: LD_EXP 50
83440: PUSH
83441: LD_VAR 0 2
83445: ARRAY
83446: PPUSH
83447: LD_INT 34
83449: PUSH
83450: LD_INT 31
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PUSH
83457: LD_INT 58
83459: PUSH
83460: EMPTY
83461: LIST
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PPUSH
83467: CALL_OW 72
83471: PUSH
83472: LD_INT 1
83474: ARRAY
83475: PPUSH
83476: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83480: LD_VAR 0 3
83484: PPUSH
83485: CALL_OW 310
83489: NOT
83490: PUSH
83491: LD_VAR 0 3
83495: PPUSH
83496: CALL_OW 310
83500: PPUSH
83501: CALL_OW 266
83505: PUSH
83506: LD_INT 36
83508: NONEQUAL
83509: PUSH
83510: LD_VAR 0 3
83514: PPUSH
83515: CALL 54968 0 1
83519: NOT
83520: AND
83521: OR
83522: IFFALSE 83658
// begin if IsInUnit ( j ) then
83524: LD_VAR 0 3
83528: PPUSH
83529: CALL_OW 310
83533: IFFALSE 83544
// ComExitBuilding ( j ) ;
83535: LD_VAR 0 3
83539: PPUSH
83540: CALL_OW 122
// ct := 0 ;
83544: LD_ADDR_VAR 0 8
83548: PUSH
83549: LD_INT 0
83551: ST_TO_ADDR
// for k in x do
83552: LD_ADDR_VAR 0 4
83556: PUSH
83557: LD_VAR 0 11
83561: PUSH
83562: FOR_IN
83563: IFFALSE 83636
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83565: LD_VAR 0 4
83569: PPUSH
83570: CALL_OW 264
83574: PUSH
83575: LD_INT 31
83577: EQUAL
83578: PUSH
83579: LD_VAR 0 4
83583: PPUSH
83584: CALL_OW 311
83588: NOT
83589: AND
83590: PUSH
83591: LD_VAR 0 4
83595: PPUSH
83596: CALL_OW 266
83600: PUSH
83601: LD_INT 36
83603: EQUAL
83604: PUSH
83605: LD_VAR 0 4
83609: PPUSH
83610: CALL_OW 313
83614: PUSH
83615: LD_INT 3
83617: LESS
83618: AND
83619: OR
83620: IFFALSE 83634
// begin ct := k ;
83622: LD_ADDR_VAR 0 8
83626: PUSH
83627: LD_VAR 0 4
83631: ST_TO_ADDR
// break ;
83632: GO 83636
// end ;
83634: GO 83562
83636: POP
83637: POP
// if ct then
83638: LD_VAR 0 8
83642: IFFALSE 83658
// ComEnterUnit ( j , ct ) ;
83644: LD_VAR 0 3
83648: PPUSH
83649: LD_VAR 0 8
83653: PPUSH
83654: CALL_OW 120
// end ; end ;
83658: GO 83293
83660: POP
83661: POP
// places := 0 ;
83662: LD_ADDR_VAR 0 5
83666: PUSH
83667: LD_INT 0
83669: ST_TO_ADDR
// for j = 1 to x do
83670: LD_ADDR_VAR 0 3
83674: PUSH
83675: DOUBLE
83676: LD_INT 1
83678: DEC
83679: ST_TO_ADDR
83680: LD_VAR 0 11
83684: PUSH
83685: FOR_TO
83686: IFFALSE 83762
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83688: LD_VAR 0 11
83692: PUSH
83693: LD_VAR 0 3
83697: ARRAY
83698: PPUSH
83699: CALL_OW 264
83703: PUSH
83704: LD_INT 31
83706: EQUAL
83707: IFFALSE 83725
// places := places + 1 else
83709: LD_ADDR_VAR 0 5
83713: PUSH
83714: LD_VAR 0 5
83718: PUSH
83719: LD_INT 1
83721: PLUS
83722: ST_TO_ADDR
83723: GO 83760
// if GetBType ( x [ j ] ) = b_control_tower then
83725: LD_VAR 0 11
83729: PUSH
83730: LD_VAR 0 3
83734: ARRAY
83735: PPUSH
83736: CALL_OW 266
83740: PUSH
83741: LD_INT 36
83743: EQUAL
83744: IFFALSE 83760
// places := places + 3 ;
83746: LD_ADDR_VAR 0 5
83750: PUSH
83751: LD_VAR 0 5
83755: PUSH
83756: LD_INT 3
83758: PLUS
83759: ST_TO_ADDR
83760: GO 83685
83762: POP
83763: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83764: LD_VAR 0 5
83768: PUSH
83769: LD_INT 0
83771: EQUAL
83772: PUSH
83773: LD_VAR 0 5
83777: PUSH
83778: LD_EXP 71
83782: PUSH
83783: LD_VAR 0 2
83787: ARRAY
83788: LESSEQUAL
83789: OR
83790: IFFALSE 83794
// continue ;
83792: GO 83044
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83794: LD_ADDR_VAR 0 6
83798: PUSH
83799: LD_EXP 31
83803: PUSH
83804: LD_VAR 0 2
83808: ARRAY
83809: PPUSH
83810: LD_INT 25
83812: PUSH
83813: LD_INT 3
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: PPUSH
83820: CALL_OW 72
83824: PUSH
83825: LD_EXP 71
83829: PUSH
83830: LD_VAR 0 2
83834: ARRAY
83835: DIFF
83836: PPUSH
83837: LD_INT 3
83839: PPUSH
83840: CALL 55868 0 2
83844: ST_TO_ADDR
// for j in tmp do
83845: LD_ADDR_VAR 0 3
83849: PUSH
83850: LD_VAR 0 6
83854: PUSH
83855: FOR_IN
83856: IFFALSE 83891
// if GetTag ( j ) > 0 then
83858: LD_VAR 0 3
83862: PPUSH
83863: CALL_OW 110
83867: PUSH
83868: LD_INT 0
83870: GREATER
83871: IFFALSE 83889
// tmp := tmp diff j ;
83873: LD_ADDR_VAR 0 6
83877: PUSH
83878: LD_VAR 0 6
83882: PUSH
83883: LD_VAR 0 3
83887: DIFF
83888: ST_TO_ADDR
83889: GO 83855
83891: POP
83892: POP
// if not tmp then
83893: LD_VAR 0 6
83897: NOT
83898: IFFALSE 83902
// continue ;
83900: GO 83044
// if places then
83902: LD_VAR 0 5
83906: IFFALSE 83965
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83908: LD_ADDR_EXP 71
83912: PUSH
83913: LD_EXP 71
83917: PPUSH
83918: LD_VAR 0 2
83922: PPUSH
83923: LD_EXP 71
83927: PUSH
83928: LD_VAR 0 2
83932: ARRAY
83933: PUSH
83934: LD_VAR 0 6
83938: PUSH
83939: LD_INT 1
83941: ARRAY
83942: UNION
83943: PPUSH
83944: CALL_OW 1
83948: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83949: LD_VAR 0 6
83953: PUSH
83954: LD_INT 1
83956: ARRAY
83957: PPUSH
83958: LD_INT 126
83960: PPUSH
83961: CALL_OW 109
// end ; end ;
83965: GO 83044
83967: POP
83968: POP
// end ;
83969: LD_VAR 0 1
83973: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83974: LD_INT 0
83976: PPUSH
83977: PPUSH
83978: PPUSH
83979: PPUSH
83980: PPUSH
83981: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83982: LD_VAR 0 1
83986: NOT
83987: PUSH
83988: LD_VAR 0 2
83992: NOT
83993: OR
83994: PUSH
83995: LD_VAR 0 3
83999: NOT
84000: OR
84001: PUSH
84002: LD_VAR 0 4
84006: PUSH
84007: LD_INT 1
84009: PUSH
84010: LD_INT 2
84012: PUSH
84013: LD_INT 3
84015: PUSH
84016: LD_INT 4
84018: PUSH
84019: LD_INT 5
84021: PUSH
84022: LD_INT 8
84024: PUSH
84025: LD_INT 9
84027: PUSH
84028: LD_INT 15
84030: PUSH
84031: LD_INT 16
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: LIST
84044: IN
84045: NOT
84046: OR
84047: IFFALSE 84051
// exit ;
84049: GO 84951
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
84051: LD_ADDR_VAR 0 2
84055: PUSH
84056: LD_VAR 0 2
84060: PPUSH
84061: LD_INT 21
84063: PUSH
84064: LD_INT 3
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: PUSH
84071: LD_INT 24
84073: PUSH
84074: LD_INT 250
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: EMPTY
84082: LIST
84083: LIST
84084: PPUSH
84085: CALL_OW 72
84089: ST_TO_ADDR
// case class of 1 , 15 :
84090: LD_VAR 0 4
84094: PUSH
84095: LD_INT 1
84097: DOUBLE
84098: EQUAL
84099: IFTRUE 84109
84101: LD_INT 15
84103: DOUBLE
84104: EQUAL
84105: IFTRUE 84109
84107: GO 84194
84109: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84110: LD_ADDR_VAR 0 8
84114: PUSH
84115: LD_VAR 0 2
84119: PPUSH
84120: LD_INT 2
84122: PUSH
84123: LD_INT 30
84125: PUSH
84126: LD_INT 32
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 30
84135: PUSH
84136: LD_INT 31
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: LIST
84147: PPUSH
84148: CALL_OW 72
84152: PUSH
84153: LD_VAR 0 2
84157: PPUSH
84158: LD_INT 2
84160: PUSH
84161: LD_INT 30
84163: PUSH
84164: LD_INT 4
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 30
84173: PUSH
84174: LD_INT 5
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: LIST
84185: PPUSH
84186: CALL_OW 72
84190: ADD
84191: ST_TO_ADDR
84192: GO 84440
84194: LD_INT 2
84196: DOUBLE
84197: EQUAL
84198: IFTRUE 84208
84200: LD_INT 16
84202: DOUBLE
84203: EQUAL
84204: IFTRUE 84208
84206: GO 84254
84208: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84209: LD_ADDR_VAR 0 8
84213: PUSH
84214: LD_VAR 0 2
84218: PPUSH
84219: LD_INT 2
84221: PUSH
84222: LD_INT 30
84224: PUSH
84225: LD_INT 0
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 30
84234: PUSH
84235: LD_INT 1
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PUSH
84242: EMPTY
84243: LIST
84244: LIST
84245: LIST
84246: PPUSH
84247: CALL_OW 72
84251: ST_TO_ADDR
84252: GO 84440
84254: LD_INT 3
84256: DOUBLE
84257: EQUAL
84258: IFTRUE 84262
84260: GO 84308
84262: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84263: LD_ADDR_VAR 0 8
84267: PUSH
84268: LD_VAR 0 2
84272: PPUSH
84273: LD_INT 2
84275: PUSH
84276: LD_INT 30
84278: PUSH
84279: LD_INT 2
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: PUSH
84286: LD_INT 30
84288: PUSH
84289: LD_INT 3
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: PUSH
84296: EMPTY
84297: LIST
84298: LIST
84299: LIST
84300: PPUSH
84301: CALL_OW 72
84305: ST_TO_ADDR
84306: GO 84440
84308: LD_INT 4
84310: DOUBLE
84311: EQUAL
84312: IFTRUE 84316
84314: GO 84373
84316: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84317: LD_ADDR_VAR 0 8
84321: PUSH
84322: LD_VAR 0 2
84326: PPUSH
84327: LD_INT 2
84329: PUSH
84330: LD_INT 30
84332: PUSH
84333: LD_INT 6
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 30
84342: PUSH
84343: LD_INT 7
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: PUSH
84350: LD_INT 30
84352: PUSH
84353: LD_INT 8
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: PPUSH
84366: CALL_OW 72
84370: ST_TO_ADDR
84371: GO 84440
84373: LD_INT 5
84375: DOUBLE
84376: EQUAL
84377: IFTRUE 84393
84379: LD_INT 8
84381: DOUBLE
84382: EQUAL
84383: IFTRUE 84393
84385: LD_INT 9
84387: DOUBLE
84388: EQUAL
84389: IFTRUE 84393
84391: GO 84439
84393: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84394: LD_ADDR_VAR 0 8
84398: PUSH
84399: LD_VAR 0 2
84403: PPUSH
84404: LD_INT 2
84406: PUSH
84407: LD_INT 30
84409: PUSH
84410: LD_INT 4
84412: PUSH
84413: EMPTY
84414: LIST
84415: LIST
84416: PUSH
84417: LD_INT 30
84419: PUSH
84420: LD_INT 5
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: LIST
84431: PPUSH
84432: CALL_OW 72
84436: ST_TO_ADDR
84437: GO 84440
84439: POP
// if not tmp then
84440: LD_VAR 0 8
84444: NOT
84445: IFFALSE 84449
// exit ;
84447: GO 84951
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84449: LD_VAR 0 4
84453: PUSH
84454: LD_INT 1
84456: PUSH
84457: LD_INT 15
84459: PUSH
84460: EMPTY
84461: LIST
84462: LIST
84463: IN
84464: PUSH
84465: LD_EXP 40
84469: PUSH
84470: LD_VAR 0 1
84474: ARRAY
84475: AND
84476: IFFALSE 84632
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84478: LD_ADDR_VAR 0 9
84482: PUSH
84483: LD_EXP 40
84487: PUSH
84488: LD_VAR 0 1
84492: ARRAY
84493: PUSH
84494: LD_INT 1
84496: ARRAY
84497: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84498: LD_VAR 0 9
84502: PUSH
84503: LD_EXP 41
84507: PUSH
84508: LD_VAR 0 1
84512: ARRAY
84513: IN
84514: NOT
84515: IFFALSE 84630
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84517: LD_ADDR_EXP 41
84521: PUSH
84522: LD_EXP 41
84526: PPUSH
84527: LD_VAR 0 1
84531: PUSH
84532: LD_EXP 41
84536: PUSH
84537: LD_VAR 0 1
84541: ARRAY
84542: PUSH
84543: LD_INT 1
84545: PLUS
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PPUSH
84551: LD_VAR 0 9
84555: PPUSH
84556: CALL 25021 0 3
84560: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84561: LD_ADDR_EXP 40
84565: PUSH
84566: LD_EXP 40
84570: PPUSH
84571: LD_VAR 0 1
84575: PPUSH
84576: LD_EXP 40
84580: PUSH
84581: LD_VAR 0 1
84585: ARRAY
84586: PUSH
84587: LD_VAR 0 9
84591: DIFF
84592: PPUSH
84593: CALL_OW 1
84597: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84598: LD_VAR 0 3
84602: PPUSH
84603: LD_EXP 41
84607: PUSH
84608: LD_VAR 0 1
84612: ARRAY
84613: PUSH
84614: LD_EXP 41
84618: PUSH
84619: LD_VAR 0 1
84623: ARRAY
84624: ARRAY
84625: PPUSH
84626: CALL_OW 120
// end ; exit ;
84630: GO 84951
// end ; if tmp > 1 then
84632: LD_VAR 0 8
84636: PUSH
84637: LD_INT 1
84639: GREATER
84640: IFFALSE 84744
// for i = 2 to tmp do
84642: LD_ADDR_VAR 0 6
84646: PUSH
84647: DOUBLE
84648: LD_INT 2
84650: DEC
84651: ST_TO_ADDR
84652: LD_VAR 0 8
84656: PUSH
84657: FOR_TO
84658: IFFALSE 84742
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84660: LD_VAR 0 8
84664: PUSH
84665: LD_VAR 0 6
84669: ARRAY
84670: PPUSH
84671: CALL_OW 461
84675: PUSH
84676: LD_INT 6
84678: EQUAL
84679: IFFALSE 84740
// begin x := tmp [ i ] ;
84681: LD_ADDR_VAR 0 9
84685: PUSH
84686: LD_VAR 0 8
84690: PUSH
84691: LD_VAR 0 6
84695: ARRAY
84696: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84697: LD_ADDR_VAR 0 8
84701: PUSH
84702: LD_VAR 0 8
84706: PPUSH
84707: LD_VAR 0 6
84711: PPUSH
84712: CALL_OW 3
84716: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84717: LD_ADDR_VAR 0 8
84721: PUSH
84722: LD_VAR 0 8
84726: PPUSH
84727: LD_INT 1
84729: PPUSH
84730: LD_VAR 0 9
84734: PPUSH
84735: CALL_OW 2
84739: ST_TO_ADDR
// end ;
84740: GO 84657
84742: POP
84743: POP
// for i in tmp do
84744: LD_ADDR_VAR 0 6
84748: PUSH
84749: LD_VAR 0 8
84753: PUSH
84754: FOR_IN
84755: IFFALSE 84824
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
84757: LD_VAR 0 6
84761: PPUSH
84762: CALL_OW 313
84766: PUSH
84767: LD_INT 6
84769: LESS
84770: PUSH
84771: LD_VAR 0 6
84775: PPUSH
84776: CALL_OW 266
84780: PUSH
84781: LD_INT 31
84783: PUSH
84784: LD_INT 32
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: IN
84791: NOT
84792: AND
84793: PUSH
84794: LD_VAR 0 6
84798: PPUSH
84799: CALL_OW 313
84803: PUSH
84804: LD_INT 0
84806: EQUAL
84807: OR
84808: IFFALSE 84822
// begin j := i ;
84810: LD_ADDR_VAR 0 7
84814: PUSH
84815: LD_VAR 0 6
84819: ST_TO_ADDR
// break ;
84820: GO 84824
// end ; end ;
84822: GO 84754
84824: POP
84825: POP
// if j then
84826: LD_VAR 0 7
84830: IFFALSE 84848
// ComEnterUnit ( unit , j ) else
84832: LD_VAR 0 3
84836: PPUSH
84837: LD_VAR 0 7
84841: PPUSH
84842: CALL_OW 120
84846: GO 84951
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84848: LD_ADDR_VAR 0 10
84852: PUSH
84853: LD_VAR 0 2
84857: PPUSH
84858: LD_INT 2
84860: PUSH
84861: LD_INT 30
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: PUSH
84871: LD_INT 30
84873: PUSH
84874: LD_INT 1
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: LIST
84885: PPUSH
84886: CALL_OW 72
84890: ST_TO_ADDR
// if depot then
84891: LD_VAR 0 10
84895: IFFALSE 84951
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84897: LD_ADDR_VAR 0 10
84901: PUSH
84902: LD_VAR 0 10
84906: PPUSH
84907: LD_VAR 0 3
84911: PPUSH
84912: CALL_OW 74
84916: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84917: LD_VAR 0 3
84921: PPUSH
84922: LD_VAR 0 10
84926: PPUSH
84927: CALL_OW 296
84931: PUSH
84932: LD_INT 10
84934: GREATER
84935: IFFALSE 84951
// ComStandNearbyBuilding ( unit , depot ) ;
84937: LD_VAR 0 3
84941: PPUSH
84942: LD_VAR 0 10
84946: PPUSH
84947: CALL 21448 0 2
// end ; end ; end ;
84951: LD_VAR 0 5
84955: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84956: LD_INT 0
84958: PPUSH
84959: PPUSH
84960: PPUSH
84961: PPUSH
// if not mc_bases then
84962: LD_EXP 31
84966: NOT
84967: IFFALSE 84971
// exit ;
84969: GO 85210
// for i = 1 to mc_bases do
84971: LD_ADDR_VAR 0 2
84975: PUSH
84976: DOUBLE
84977: LD_INT 1
84979: DEC
84980: ST_TO_ADDR
84981: LD_EXP 31
84985: PUSH
84986: FOR_TO
84987: IFFALSE 85208
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84989: LD_ADDR_VAR 0 4
84993: PUSH
84994: LD_EXP 31
84998: PUSH
84999: LD_VAR 0 2
85003: ARRAY
85004: PPUSH
85005: LD_INT 21
85007: PUSH
85008: LD_INT 1
85010: PUSH
85011: EMPTY
85012: LIST
85013: LIST
85014: PPUSH
85015: CALL_OW 72
85019: PUSH
85020: LD_EXP 60
85024: PUSH
85025: LD_VAR 0 2
85029: ARRAY
85030: UNION
85031: ST_TO_ADDR
// if not tmp then
85032: LD_VAR 0 4
85036: NOT
85037: IFFALSE 85041
// continue ;
85039: GO 84986
// for j in tmp do
85041: LD_ADDR_VAR 0 3
85045: PUSH
85046: LD_VAR 0 4
85050: PUSH
85051: FOR_IN
85052: IFFALSE 85204
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
85054: LD_VAR 0 3
85058: PPUSH
85059: CALL_OW 110
85063: NOT
85064: PUSH
85065: LD_VAR 0 3
85069: PPUSH
85070: CALL_OW 314
85074: NOT
85075: AND
85076: PUSH
85077: LD_VAR 0 3
85081: PPUSH
85082: CALL_OW 311
85086: NOT
85087: AND
85088: PUSH
85089: LD_VAR 0 3
85093: PPUSH
85094: CALL_OW 310
85098: NOT
85099: AND
85100: PUSH
85101: LD_VAR 0 3
85105: PUSH
85106: LD_EXP 34
85110: PUSH
85111: LD_VAR 0 2
85115: ARRAY
85116: PUSH
85117: LD_INT 1
85119: ARRAY
85120: IN
85121: NOT
85122: AND
85123: PUSH
85124: LD_VAR 0 3
85128: PUSH
85129: LD_EXP 34
85133: PUSH
85134: LD_VAR 0 2
85138: ARRAY
85139: PUSH
85140: LD_INT 2
85142: ARRAY
85143: IN
85144: NOT
85145: AND
85146: PUSH
85147: LD_VAR 0 3
85151: PUSH
85152: LD_EXP 43
85156: PUSH
85157: LD_VAR 0 2
85161: ARRAY
85162: IN
85163: NOT
85164: AND
85165: IFFALSE 85202
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85167: LD_VAR 0 2
85171: PPUSH
85172: LD_EXP 31
85176: PUSH
85177: LD_VAR 0 2
85181: ARRAY
85182: PPUSH
85183: LD_VAR 0 3
85187: PPUSH
85188: LD_VAR 0 3
85192: PPUSH
85193: CALL_OW 257
85197: PPUSH
85198: CALL 83974 0 4
// end ;
85202: GO 85051
85204: POP
85205: POP
// end ;
85206: GO 84986
85208: POP
85209: POP
// end ;
85210: LD_VAR 0 1
85214: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
85215: LD_INT 0
85217: PPUSH
85218: PPUSH
85219: PPUSH
85220: PPUSH
85221: PPUSH
85222: PPUSH
// if not mc_bases [ base ] then
85223: LD_EXP 31
85227: PUSH
85228: LD_VAR 0 1
85232: ARRAY
85233: NOT
85234: IFFALSE 85238
// exit ;
85236: GO 85420
// tmp := [ ] ;
85238: LD_ADDR_VAR 0 6
85242: PUSH
85243: EMPTY
85244: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85245: LD_ADDR_VAR 0 7
85249: PUSH
85250: LD_VAR 0 3
85254: PPUSH
85255: LD_INT 0
85257: PPUSH
85258: CALL_OW 517
85262: ST_TO_ADDR
// if not list then
85263: LD_VAR 0 7
85267: NOT
85268: IFFALSE 85272
// exit ;
85270: GO 85420
// for i = 1 to amount do
85272: LD_ADDR_VAR 0 5
85276: PUSH
85277: DOUBLE
85278: LD_INT 1
85280: DEC
85281: ST_TO_ADDR
85282: LD_VAR 0 2
85286: PUSH
85287: FOR_TO
85288: IFFALSE 85368
// begin x := rand ( 1 , list [ 1 ] ) ;
85290: LD_ADDR_VAR 0 8
85294: PUSH
85295: LD_INT 1
85297: PPUSH
85298: LD_VAR 0 7
85302: PUSH
85303: LD_INT 1
85305: ARRAY
85306: PPUSH
85307: CALL_OW 12
85311: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
85312: LD_ADDR_VAR 0 6
85316: PUSH
85317: LD_VAR 0 6
85321: PPUSH
85322: LD_VAR 0 5
85326: PPUSH
85327: LD_VAR 0 7
85331: PUSH
85332: LD_INT 1
85334: ARRAY
85335: PUSH
85336: LD_VAR 0 8
85340: ARRAY
85341: PUSH
85342: LD_VAR 0 7
85346: PUSH
85347: LD_INT 2
85349: ARRAY
85350: PUSH
85351: LD_VAR 0 8
85355: ARRAY
85356: PUSH
85357: EMPTY
85358: LIST
85359: LIST
85360: PPUSH
85361: CALL_OW 1
85365: ST_TO_ADDR
// end ;
85366: GO 85287
85368: POP
85369: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85370: LD_ADDR_EXP 44
85374: PUSH
85375: LD_EXP 44
85379: PPUSH
85380: LD_VAR 0 1
85384: PPUSH
85385: LD_VAR 0 6
85389: PPUSH
85390: CALL_OW 1
85394: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85395: LD_ADDR_EXP 46
85399: PUSH
85400: LD_EXP 46
85404: PPUSH
85405: LD_VAR 0 1
85409: PPUSH
85410: LD_VAR 0 3
85414: PPUSH
85415: CALL_OW 1
85419: ST_TO_ADDR
// end ;
85420: LD_VAR 0 4
85424: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85425: LD_INT 0
85427: PPUSH
// if not mc_bases [ base ] then
85428: LD_EXP 31
85432: PUSH
85433: LD_VAR 0 1
85437: ARRAY
85438: NOT
85439: IFFALSE 85443
// exit ;
85441: GO 85468
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85443: LD_ADDR_EXP 36
85447: PUSH
85448: LD_EXP 36
85452: PPUSH
85453: LD_VAR 0 1
85457: PPUSH
85458: LD_VAR 0 2
85462: PPUSH
85463: CALL_OW 1
85467: ST_TO_ADDR
// end ;
85468: LD_VAR 0 3
85472: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85473: LD_INT 0
85475: PPUSH
// if not mc_bases [ base ] then
85476: LD_EXP 31
85480: PUSH
85481: LD_VAR 0 1
85485: ARRAY
85486: NOT
85487: IFFALSE 85491
// exit ;
85489: GO 85528
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85491: LD_ADDR_EXP 36
85495: PUSH
85496: LD_EXP 36
85500: PPUSH
85501: LD_VAR 0 1
85505: PPUSH
85506: LD_EXP 36
85510: PUSH
85511: LD_VAR 0 1
85515: ARRAY
85516: PUSH
85517: LD_VAR 0 2
85521: UNION
85522: PPUSH
85523: CALL_OW 1
85527: ST_TO_ADDR
// end ;
85528: LD_VAR 0 3
85532: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85533: LD_INT 0
85535: PPUSH
// if not mc_bases [ base ] then
85536: LD_EXP 31
85540: PUSH
85541: LD_VAR 0 1
85545: ARRAY
85546: NOT
85547: IFFALSE 85551
// exit ;
85549: GO 85576
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85551: LD_ADDR_EXP 52
85555: PUSH
85556: LD_EXP 52
85560: PPUSH
85561: LD_VAR 0 1
85565: PPUSH
85566: LD_VAR 0 2
85570: PPUSH
85571: CALL_OW 1
85575: ST_TO_ADDR
// end ;
85576: LD_VAR 0 3
85580: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85581: LD_INT 0
85583: PPUSH
// if not mc_bases [ base ] then
85584: LD_EXP 31
85588: PUSH
85589: LD_VAR 0 1
85593: ARRAY
85594: NOT
85595: IFFALSE 85599
// exit ;
85597: GO 85636
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85599: LD_ADDR_EXP 52
85603: PUSH
85604: LD_EXP 52
85608: PPUSH
85609: LD_VAR 0 1
85613: PPUSH
85614: LD_EXP 52
85618: PUSH
85619: LD_VAR 0 1
85623: ARRAY
85624: PUSH
85625: LD_VAR 0 2
85629: ADD
85630: PPUSH
85631: CALL_OW 1
85635: ST_TO_ADDR
// end ;
85636: LD_VAR 0 3
85640: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85641: LD_INT 0
85643: PPUSH
// if not mc_bases [ base ] then
85644: LD_EXP 31
85648: PUSH
85649: LD_VAR 0 1
85653: ARRAY
85654: NOT
85655: IFFALSE 85659
// exit ;
85657: GO 85713
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85659: LD_ADDR_EXP 53
85663: PUSH
85664: LD_EXP 53
85668: PPUSH
85669: LD_VAR 0 1
85673: PPUSH
85674: LD_VAR 0 2
85678: PPUSH
85679: CALL_OW 1
85683: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85684: LD_ADDR_EXP 42
85688: PUSH
85689: LD_EXP 42
85693: PPUSH
85694: LD_VAR 0 1
85698: PPUSH
85699: LD_VAR 0 2
85703: PUSH
85704: LD_INT 0
85706: PLUS
85707: PPUSH
85708: CALL_OW 1
85712: ST_TO_ADDR
// end ;
85713: LD_VAR 0 3
85717: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85718: LD_INT 0
85720: PPUSH
// if not mc_bases [ base ] then
85721: LD_EXP 31
85725: PUSH
85726: LD_VAR 0 1
85730: ARRAY
85731: NOT
85732: IFFALSE 85736
// exit ;
85734: GO 85761
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85736: LD_ADDR_EXP 42
85740: PUSH
85741: LD_EXP 42
85745: PPUSH
85746: LD_VAR 0 1
85750: PPUSH
85751: LD_VAR 0 2
85755: PPUSH
85756: CALL_OW 1
85760: ST_TO_ADDR
// end ;
85761: LD_VAR 0 3
85765: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85766: LD_INT 0
85768: PPUSH
85769: PPUSH
85770: PPUSH
85771: PPUSH
// if not mc_bases [ base ] then
85772: LD_EXP 31
85776: PUSH
85777: LD_VAR 0 1
85781: ARRAY
85782: NOT
85783: IFFALSE 85787
// exit ;
85785: GO 85852
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85787: LD_ADDR_EXP 51
85791: PUSH
85792: LD_EXP 51
85796: PPUSH
85797: LD_VAR 0 1
85801: PUSH
85802: LD_EXP 51
85806: PUSH
85807: LD_VAR 0 1
85811: ARRAY
85812: PUSH
85813: LD_INT 1
85815: PLUS
85816: PUSH
85817: EMPTY
85818: LIST
85819: LIST
85820: PPUSH
85821: LD_VAR 0 1
85825: PUSH
85826: LD_VAR 0 2
85830: PUSH
85831: LD_VAR 0 3
85835: PUSH
85836: LD_VAR 0 4
85840: PUSH
85841: EMPTY
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: PPUSH
85847: CALL 25021 0 3
85851: ST_TO_ADDR
// end ;
85852: LD_VAR 0 5
85856: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85857: LD_INT 0
85859: PPUSH
// if not mc_bases [ base ] then
85860: LD_EXP 31
85864: PUSH
85865: LD_VAR 0 1
85869: ARRAY
85870: NOT
85871: IFFALSE 85875
// exit ;
85873: GO 85900
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85875: LD_ADDR_EXP 68
85879: PUSH
85880: LD_EXP 68
85884: PPUSH
85885: LD_VAR 0 1
85889: PPUSH
85890: LD_VAR 0 2
85894: PPUSH
85895: CALL_OW 1
85899: ST_TO_ADDR
// end ;
85900: LD_VAR 0 3
85904: RET
// export function MC_GetMinesField ( base ) ; begin
85905: LD_INT 0
85907: PPUSH
// result := mc_mines [ base ] ;
85908: LD_ADDR_VAR 0 2
85912: PUSH
85913: LD_EXP 44
85917: PUSH
85918: LD_VAR 0 1
85922: ARRAY
85923: ST_TO_ADDR
// end ;
85924: LD_VAR 0 2
85928: RET
// export function MC_GetProduceList ( base ) ; begin
85929: LD_INT 0
85931: PPUSH
// result := mc_produce [ base ] ;
85932: LD_ADDR_VAR 0 2
85936: PUSH
85937: LD_EXP 52
85941: PUSH
85942: LD_VAR 0 1
85946: ARRAY
85947: ST_TO_ADDR
// end ;
85948: LD_VAR 0 2
85952: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85953: LD_INT 0
85955: PPUSH
85956: PPUSH
// if not mc_bases then
85957: LD_EXP 31
85961: NOT
85962: IFFALSE 85966
// exit ;
85964: GO 86031
// if mc_bases [ base ] then
85966: LD_EXP 31
85970: PUSH
85971: LD_VAR 0 1
85975: ARRAY
85976: IFFALSE 86031
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85978: LD_ADDR_VAR 0 3
85982: PUSH
85983: LD_EXP 31
85987: PUSH
85988: LD_VAR 0 1
85992: ARRAY
85993: PPUSH
85994: LD_INT 30
85996: PUSH
85997: LD_VAR 0 2
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PPUSH
86006: CALL_OW 72
86010: ST_TO_ADDR
// if result then
86011: LD_VAR 0 3
86015: IFFALSE 86031
// result := result [ 1 ] ;
86017: LD_ADDR_VAR 0 3
86021: PUSH
86022: LD_VAR 0 3
86026: PUSH
86027: LD_INT 1
86029: ARRAY
86030: ST_TO_ADDR
// end ; end ;
86031: LD_VAR 0 3
86035: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
86036: LD_INT 0
86038: PPUSH
86039: PPUSH
// if not mc_bases then
86040: LD_EXP 31
86044: NOT
86045: IFFALSE 86049
// exit ;
86047: GO 86094
// if mc_bases [ base ] then
86049: LD_EXP 31
86053: PUSH
86054: LD_VAR 0 1
86058: ARRAY
86059: IFFALSE 86094
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86061: LD_ADDR_VAR 0 3
86065: PUSH
86066: LD_EXP 31
86070: PUSH
86071: LD_VAR 0 1
86075: ARRAY
86076: PPUSH
86077: LD_INT 30
86079: PUSH
86080: LD_VAR 0 2
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PPUSH
86089: CALL_OW 72
86093: ST_TO_ADDR
// end ;
86094: LD_VAR 0 3
86098: RET
// export function MC_SetTame ( base , area ) ; begin
86099: LD_INT 0
86101: PPUSH
// if not mc_bases or not base then
86102: LD_EXP 31
86106: NOT
86107: PUSH
86108: LD_VAR 0 1
86112: NOT
86113: OR
86114: IFFALSE 86118
// exit ;
86116: GO 86143
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86118: LD_ADDR_EXP 59
86122: PUSH
86123: LD_EXP 59
86127: PPUSH
86128: LD_VAR 0 1
86132: PPUSH
86133: LD_VAR 0 2
86137: PPUSH
86138: CALL_OW 1
86142: ST_TO_ADDR
// end ;
86143: LD_VAR 0 3
86147: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86148: LD_INT 0
86150: PPUSH
86151: PPUSH
// if not mc_bases or not base then
86152: LD_EXP 31
86156: NOT
86157: PUSH
86158: LD_VAR 0 1
86162: NOT
86163: OR
86164: IFFALSE 86168
// exit ;
86166: GO 86270
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86168: LD_ADDR_VAR 0 4
86172: PUSH
86173: LD_EXP 31
86177: PUSH
86178: LD_VAR 0 1
86182: ARRAY
86183: PPUSH
86184: LD_INT 30
86186: PUSH
86187: LD_VAR 0 2
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PPUSH
86196: CALL_OW 72
86200: ST_TO_ADDR
// if not tmp then
86201: LD_VAR 0 4
86205: NOT
86206: IFFALSE 86210
// exit ;
86208: GO 86270
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86210: LD_ADDR_EXP 63
86214: PUSH
86215: LD_EXP 63
86219: PPUSH
86220: LD_VAR 0 1
86224: PPUSH
86225: LD_EXP 63
86229: PUSH
86230: LD_VAR 0 1
86234: ARRAY
86235: PPUSH
86236: LD_EXP 63
86240: PUSH
86241: LD_VAR 0 1
86245: ARRAY
86246: PUSH
86247: LD_INT 1
86249: PLUS
86250: PPUSH
86251: LD_VAR 0 4
86255: PUSH
86256: LD_INT 1
86258: ARRAY
86259: PPUSH
86260: CALL_OW 2
86264: PPUSH
86265: CALL_OW 1
86269: ST_TO_ADDR
// end ;
86270: LD_VAR 0 3
86274: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86275: LD_INT 0
86277: PPUSH
86278: PPUSH
// if not mc_bases or not base or not kinds then
86279: LD_EXP 31
86283: NOT
86284: PUSH
86285: LD_VAR 0 1
86289: NOT
86290: OR
86291: PUSH
86292: LD_VAR 0 2
86296: NOT
86297: OR
86298: IFFALSE 86302
// exit ;
86300: GO 86363
// for i in kinds do
86302: LD_ADDR_VAR 0 4
86306: PUSH
86307: LD_VAR 0 2
86311: PUSH
86312: FOR_IN
86313: IFFALSE 86361
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86315: LD_ADDR_EXP 65
86319: PUSH
86320: LD_EXP 65
86324: PPUSH
86325: LD_VAR 0 1
86329: PUSH
86330: LD_EXP 65
86334: PUSH
86335: LD_VAR 0 1
86339: ARRAY
86340: PUSH
86341: LD_INT 1
86343: PLUS
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PPUSH
86349: LD_VAR 0 4
86353: PPUSH
86354: CALL 25021 0 3
86358: ST_TO_ADDR
86359: GO 86312
86361: POP
86362: POP
// end ;
86363: LD_VAR 0 3
86367: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86368: LD_INT 0
86370: PPUSH
// if not mc_bases or not base or not areas then
86371: LD_EXP 31
86375: NOT
86376: PUSH
86377: LD_VAR 0 1
86381: NOT
86382: OR
86383: PUSH
86384: LD_VAR 0 2
86388: NOT
86389: OR
86390: IFFALSE 86394
// exit ;
86392: GO 86419
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86394: LD_ADDR_EXP 49
86398: PUSH
86399: LD_EXP 49
86403: PPUSH
86404: LD_VAR 0 1
86408: PPUSH
86409: LD_VAR 0 2
86413: PPUSH
86414: CALL_OW 1
86418: ST_TO_ADDR
// end ;
86419: LD_VAR 0 3
86423: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86424: LD_INT 0
86426: PPUSH
// if not mc_bases or not base or not teleports_exit then
86427: LD_EXP 31
86431: NOT
86432: PUSH
86433: LD_VAR 0 1
86437: NOT
86438: OR
86439: PUSH
86440: LD_VAR 0 2
86444: NOT
86445: OR
86446: IFFALSE 86450
// exit ;
86448: GO 86475
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86450: LD_ADDR_EXP 66
86454: PUSH
86455: LD_EXP 66
86459: PPUSH
86460: LD_VAR 0 1
86464: PPUSH
86465: LD_VAR 0 2
86469: PPUSH
86470: CALL_OW 1
86474: ST_TO_ADDR
// end ;
86475: LD_VAR 0 3
86479: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86480: LD_INT 0
86482: PPUSH
86483: PPUSH
86484: PPUSH
// if not mc_bases or not base or not ext_list then
86485: LD_EXP 31
86489: NOT
86490: PUSH
86491: LD_VAR 0 1
86495: NOT
86496: OR
86497: PUSH
86498: LD_VAR 0 5
86502: NOT
86503: OR
86504: IFFALSE 86508
// exit ;
86506: GO 86681
// tmp := GetFacExtXYD ( x , y , d ) ;
86508: LD_ADDR_VAR 0 8
86512: PUSH
86513: LD_VAR 0 2
86517: PPUSH
86518: LD_VAR 0 3
86522: PPUSH
86523: LD_VAR 0 4
86527: PPUSH
86528: CALL 54998 0 3
86532: ST_TO_ADDR
// if not tmp then
86533: LD_VAR 0 8
86537: NOT
86538: IFFALSE 86542
// exit ;
86540: GO 86681
// for i in tmp do
86542: LD_ADDR_VAR 0 7
86546: PUSH
86547: LD_VAR 0 8
86551: PUSH
86552: FOR_IN
86553: IFFALSE 86679
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86555: LD_ADDR_EXP 36
86559: PUSH
86560: LD_EXP 36
86564: PPUSH
86565: LD_VAR 0 1
86569: PPUSH
86570: LD_EXP 36
86574: PUSH
86575: LD_VAR 0 1
86579: ARRAY
86580: PPUSH
86581: LD_EXP 36
86585: PUSH
86586: LD_VAR 0 1
86590: ARRAY
86591: PUSH
86592: LD_INT 1
86594: PLUS
86595: PPUSH
86596: LD_VAR 0 5
86600: PUSH
86601: LD_INT 1
86603: ARRAY
86604: PUSH
86605: LD_VAR 0 7
86609: PUSH
86610: LD_INT 1
86612: ARRAY
86613: PUSH
86614: LD_VAR 0 7
86618: PUSH
86619: LD_INT 2
86621: ARRAY
86622: PUSH
86623: LD_VAR 0 7
86627: PUSH
86628: LD_INT 3
86630: ARRAY
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: LIST
86636: LIST
86637: PPUSH
86638: CALL_OW 2
86642: PPUSH
86643: CALL_OW 1
86647: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86648: LD_ADDR_VAR 0 5
86652: PUSH
86653: LD_VAR 0 5
86657: PPUSH
86658: LD_INT 1
86660: PPUSH
86661: CALL_OW 3
86665: ST_TO_ADDR
// if not ext_list then
86666: LD_VAR 0 5
86670: NOT
86671: IFFALSE 86677
// exit ;
86673: POP
86674: POP
86675: GO 86681
// end ;
86677: GO 86552
86679: POP
86680: POP
// end ;
86681: LD_VAR 0 6
86685: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86686: LD_INT 0
86688: PPUSH
// if not mc_bases or not base or not weapon_list then
86689: LD_EXP 31
86693: NOT
86694: PUSH
86695: LD_VAR 0 1
86699: NOT
86700: OR
86701: PUSH
86702: LD_VAR 0 2
86706: NOT
86707: OR
86708: IFFALSE 86712
// exit ;
86710: GO 86737
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86712: LD_ADDR_EXP 70
86716: PUSH
86717: LD_EXP 70
86721: PPUSH
86722: LD_VAR 0 1
86726: PPUSH
86727: LD_VAR 0 2
86731: PPUSH
86732: CALL_OW 1
86736: ST_TO_ADDR
// end ;
86737: LD_VAR 0 3
86741: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86742: LD_INT 0
86744: PPUSH
// if not mc_bases or not base or not tech_list then
86745: LD_EXP 31
86749: NOT
86750: PUSH
86751: LD_VAR 0 1
86755: NOT
86756: OR
86757: PUSH
86758: LD_VAR 0 2
86762: NOT
86763: OR
86764: IFFALSE 86768
// exit ;
86766: GO 86793
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86768: LD_ADDR_EXP 58
86772: PUSH
86773: LD_EXP 58
86777: PPUSH
86778: LD_VAR 0 1
86782: PPUSH
86783: LD_VAR 0 2
86787: PPUSH
86788: CALL_OW 1
86792: ST_TO_ADDR
// end ;
86793: LD_VAR 0 3
86797: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86798: LD_INT 0
86800: PPUSH
// if not mc_bases or not parking_area or not base then
86801: LD_EXP 31
86805: NOT
86806: PUSH
86807: LD_VAR 0 2
86811: NOT
86812: OR
86813: PUSH
86814: LD_VAR 0 1
86818: NOT
86819: OR
86820: IFFALSE 86824
// exit ;
86822: GO 86849
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86824: LD_ADDR_EXP 55
86828: PUSH
86829: LD_EXP 55
86833: PPUSH
86834: LD_VAR 0 1
86838: PPUSH
86839: LD_VAR 0 2
86843: PPUSH
86844: CALL_OW 1
86848: ST_TO_ADDR
// end ;
86849: LD_VAR 0 3
86853: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86854: LD_INT 0
86856: PPUSH
// if not mc_bases or not base or not scan_area then
86857: LD_EXP 31
86861: NOT
86862: PUSH
86863: LD_VAR 0 1
86867: NOT
86868: OR
86869: PUSH
86870: LD_VAR 0 2
86874: NOT
86875: OR
86876: IFFALSE 86880
// exit ;
86878: GO 86905
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86880: LD_ADDR_EXP 56
86884: PUSH
86885: LD_EXP 56
86889: PPUSH
86890: LD_VAR 0 1
86894: PPUSH
86895: LD_VAR 0 2
86899: PPUSH
86900: CALL_OW 1
86904: ST_TO_ADDR
// end ;
86905: LD_VAR 0 3
86909: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86910: LD_INT 0
86912: PPUSH
86913: PPUSH
// if not mc_bases or not base then
86914: LD_EXP 31
86918: NOT
86919: PUSH
86920: LD_VAR 0 1
86924: NOT
86925: OR
86926: IFFALSE 86930
// exit ;
86928: GO 86994
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86930: LD_ADDR_VAR 0 3
86934: PUSH
86935: LD_INT 1
86937: PUSH
86938: LD_INT 2
86940: PUSH
86941: LD_INT 3
86943: PUSH
86944: LD_INT 4
86946: PUSH
86947: LD_INT 11
86949: PUSH
86950: EMPTY
86951: LIST
86952: LIST
86953: LIST
86954: LIST
86955: LIST
86956: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86957: LD_ADDR_EXP 58
86961: PUSH
86962: LD_EXP 58
86966: PPUSH
86967: LD_VAR 0 1
86971: PPUSH
86972: LD_EXP 58
86976: PUSH
86977: LD_VAR 0 1
86981: ARRAY
86982: PUSH
86983: LD_VAR 0 3
86987: DIFF
86988: PPUSH
86989: CALL_OW 1
86993: ST_TO_ADDR
// end ;
86994: LD_VAR 0 2
86998: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86999: LD_INT 0
87001: PPUSH
// result := mc_vehicles [ base ] ;
87002: LD_ADDR_VAR 0 3
87006: PUSH
87007: LD_EXP 50
87011: PUSH
87012: LD_VAR 0 1
87016: ARRAY
87017: ST_TO_ADDR
// if onlyCombat then
87018: LD_VAR 0 2
87022: IFFALSE 87194
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
87024: LD_ADDR_VAR 0 3
87028: PUSH
87029: LD_VAR 0 3
87033: PUSH
87034: LD_VAR 0 3
87038: PPUSH
87039: LD_INT 2
87041: PUSH
87042: LD_INT 34
87044: PUSH
87045: LD_INT 12
87047: PUSH
87048: EMPTY
87049: LIST
87050: LIST
87051: PUSH
87052: LD_INT 34
87054: PUSH
87055: LD_INT 51
87057: PUSH
87058: EMPTY
87059: LIST
87060: LIST
87061: PUSH
87062: LD_INT 34
87064: PUSH
87065: LD_INT 89
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: PUSH
87072: LD_INT 34
87074: PUSH
87075: LD_INT 32
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 34
87084: PUSH
87085: LD_INT 13
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 34
87094: PUSH
87095: LD_INT 52
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 34
87104: PUSH
87105: LD_INT 88
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 34
87114: PUSH
87115: LD_INT 14
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 34
87124: PUSH
87125: LD_INT 53
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: LD_INT 34
87134: PUSH
87135: LD_INT 98
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: LD_INT 34
87144: PUSH
87145: LD_INT 31
87147: PUSH
87148: EMPTY
87149: LIST
87150: LIST
87151: PUSH
87152: LD_INT 34
87154: PUSH
87155: LD_INT 48
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 34
87164: PUSH
87165: LD_INT 8
87167: PUSH
87168: EMPTY
87169: LIST
87170: LIST
87171: PUSH
87172: EMPTY
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: PPUSH
87188: CALL_OW 72
87192: DIFF
87193: ST_TO_ADDR
// end ; end_of_file
87194: LD_VAR 0 3
87198: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87199: LD_INT 0
87201: PPUSH
87202: PPUSH
87203: PPUSH
// if not mc_bases or not skirmish then
87204: LD_EXP 31
87208: NOT
87209: PUSH
87210: LD_EXP 29
87214: NOT
87215: OR
87216: IFFALSE 87220
// exit ;
87218: GO 87385
// for i = 1 to mc_bases do
87220: LD_ADDR_VAR 0 4
87224: PUSH
87225: DOUBLE
87226: LD_INT 1
87228: DEC
87229: ST_TO_ADDR
87230: LD_EXP 31
87234: PUSH
87235: FOR_TO
87236: IFFALSE 87383
// begin if sci in mc_bases [ i ] then
87238: LD_VAR 0 2
87242: PUSH
87243: LD_EXP 31
87247: PUSH
87248: LD_VAR 0 4
87252: ARRAY
87253: IN
87254: IFFALSE 87381
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87256: LD_ADDR_EXP 60
87260: PUSH
87261: LD_EXP 60
87265: PPUSH
87266: LD_VAR 0 4
87270: PUSH
87271: LD_EXP 60
87275: PUSH
87276: LD_VAR 0 4
87280: ARRAY
87281: PUSH
87282: LD_INT 1
87284: PLUS
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PPUSH
87290: LD_VAR 0 1
87294: PPUSH
87295: CALL 25021 0 3
87299: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87300: LD_ADDR_VAR 0 5
87304: PUSH
87305: LD_EXP 31
87309: PUSH
87310: LD_VAR 0 4
87314: ARRAY
87315: PPUSH
87316: LD_INT 2
87318: PUSH
87319: LD_INT 30
87321: PUSH
87322: LD_INT 0
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 30
87331: PUSH
87332: LD_INT 1
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: LIST
87343: PPUSH
87344: CALL_OW 72
87348: PPUSH
87349: LD_VAR 0 1
87353: PPUSH
87354: CALL_OW 74
87358: ST_TO_ADDR
// if tmp then
87359: LD_VAR 0 5
87363: IFFALSE 87379
// ComStandNearbyBuilding ( ape , tmp ) ;
87365: LD_VAR 0 1
87369: PPUSH
87370: LD_VAR 0 5
87374: PPUSH
87375: CALL 21448 0 2
// break ;
87379: GO 87383
// end ; end ;
87381: GO 87235
87383: POP
87384: POP
// end ;
87385: LD_VAR 0 3
87389: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87390: LD_INT 0
87392: PPUSH
87393: PPUSH
87394: PPUSH
// if not mc_bases or not skirmish then
87395: LD_EXP 31
87399: NOT
87400: PUSH
87401: LD_EXP 29
87405: NOT
87406: OR
87407: IFFALSE 87411
// exit ;
87409: GO 87500
// for i = 1 to mc_bases do
87411: LD_ADDR_VAR 0 4
87415: PUSH
87416: DOUBLE
87417: LD_INT 1
87419: DEC
87420: ST_TO_ADDR
87421: LD_EXP 31
87425: PUSH
87426: FOR_TO
87427: IFFALSE 87498
// begin if building in mc_busy_turret_list [ i ] then
87429: LD_VAR 0 1
87433: PUSH
87434: LD_EXP 41
87438: PUSH
87439: LD_VAR 0 4
87443: ARRAY
87444: IN
87445: IFFALSE 87496
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87447: LD_ADDR_VAR 0 5
87451: PUSH
87452: LD_EXP 41
87456: PUSH
87457: LD_VAR 0 4
87461: ARRAY
87462: PUSH
87463: LD_VAR 0 1
87467: DIFF
87468: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87469: LD_ADDR_EXP 41
87473: PUSH
87474: LD_EXP 41
87478: PPUSH
87479: LD_VAR 0 4
87483: PPUSH
87484: LD_VAR 0 5
87488: PPUSH
87489: CALL_OW 1
87493: ST_TO_ADDR
// break ;
87494: GO 87498
// end ; end ;
87496: GO 87426
87498: POP
87499: POP
// end ;
87500: LD_VAR 0 3
87504: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87505: LD_INT 0
87507: PPUSH
87508: PPUSH
87509: PPUSH
// if not mc_bases or not skirmish then
87510: LD_EXP 31
87514: NOT
87515: PUSH
87516: LD_EXP 29
87520: NOT
87521: OR
87522: IFFALSE 87526
// exit ;
87524: GO 87725
// for i = 1 to mc_bases do
87526: LD_ADDR_VAR 0 5
87530: PUSH
87531: DOUBLE
87532: LD_INT 1
87534: DEC
87535: ST_TO_ADDR
87536: LD_EXP 31
87540: PUSH
87541: FOR_TO
87542: IFFALSE 87723
// if building in mc_bases [ i ] then
87544: LD_VAR 0 1
87548: PUSH
87549: LD_EXP 31
87553: PUSH
87554: LD_VAR 0 5
87558: ARRAY
87559: IN
87560: IFFALSE 87721
// begin tmp := mc_bases [ i ] diff building ;
87562: LD_ADDR_VAR 0 6
87566: PUSH
87567: LD_EXP 31
87571: PUSH
87572: LD_VAR 0 5
87576: ARRAY
87577: PUSH
87578: LD_VAR 0 1
87582: DIFF
87583: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87584: LD_ADDR_EXP 31
87588: PUSH
87589: LD_EXP 31
87593: PPUSH
87594: LD_VAR 0 5
87598: PPUSH
87599: LD_VAR 0 6
87603: PPUSH
87604: CALL_OW 1
87608: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87609: LD_VAR 0 1
87613: PUSH
87614: LD_EXP 39
87618: PUSH
87619: LD_VAR 0 5
87623: ARRAY
87624: IN
87625: IFFALSE 87664
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87627: LD_ADDR_EXP 39
87631: PUSH
87632: LD_EXP 39
87636: PPUSH
87637: LD_VAR 0 5
87641: PPUSH
87642: LD_EXP 39
87646: PUSH
87647: LD_VAR 0 5
87651: ARRAY
87652: PUSH
87653: LD_VAR 0 1
87657: DIFF
87658: PPUSH
87659: CALL_OW 1
87663: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87664: LD_VAR 0 1
87668: PUSH
87669: LD_EXP 40
87673: PUSH
87674: LD_VAR 0 5
87678: ARRAY
87679: IN
87680: IFFALSE 87719
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87682: LD_ADDR_EXP 40
87686: PUSH
87687: LD_EXP 40
87691: PPUSH
87692: LD_VAR 0 5
87696: PPUSH
87697: LD_EXP 40
87701: PUSH
87702: LD_VAR 0 5
87706: ARRAY
87707: PUSH
87708: LD_VAR 0 1
87712: DIFF
87713: PPUSH
87714: CALL_OW 1
87718: ST_TO_ADDR
// break ;
87719: GO 87723
// end ;
87721: GO 87541
87723: POP
87724: POP
// end ;
87725: LD_VAR 0 4
87729: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87730: LD_INT 0
87732: PPUSH
87733: PPUSH
87734: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87735: LD_EXP 31
87739: NOT
87740: PUSH
87741: LD_EXP 29
87745: NOT
87746: OR
87747: PUSH
87748: LD_VAR 0 3
87752: PUSH
87753: LD_EXP 57
87757: IN
87758: NOT
87759: OR
87760: IFFALSE 87764
// exit ;
87762: GO 87887
// for i = 1 to mc_vehicles do
87764: LD_ADDR_VAR 0 6
87768: PUSH
87769: DOUBLE
87770: LD_INT 1
87772: DEC
87773: ST_TO_ADDR
87774: LD_EXP 50
87778: PUSH
87779: FOR_TO
87780: IFFALSE 87885
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87782: LD_VAR 0 2
87786: PUSH
87787: LD_EXP 50
87791: PUSH
87792: LD_VAR 0 6
87796: ARRAY
87797: IN
87798: PUSH
87799: LD_VAR 0 1
87803: PUSH
87804: LD_EXP 50
87808: PUSH
87809: LD_VAR 0 6
87813: ARRAY
87814: IN
87815: OR
87816: IFFALSE 87883
// begin tmp := mc_vehicles [ i ] diff old ;
87818: LD_ADDR_VAR 0 7
87822: PUSH
87823: LD_EXP 50
87827: PUSH
87828: LD_VAR 0 6
87832: ARRAY
87833: PUSH
87834: LD_VAR 0 2
87838: DIFF
87839: ST_TO_ADDR
// tmp := tmp diff new ;
87840: LD_ADDR_VAR 0 7
87844: PUSH
87845: LD_VAR 0 7
87849: PUSH
87850: LD_VAR 0 1
87854: DIFF
87855: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87856: LD_ADDR_EXP 50
87860: PUSH
87861: LD_EXP 50
87865: PPUSH
87866: LD_VAR 0 6
87870: PPUSH
87871: LD_VAR 0 7
87875: PPUSH
87876: CALL_OW 1
87880: ST_TO_ADDR
// break ;
87881: GO 87885
// end ;
87883: GO 87779
87885: POP
87886: POP
// end ;
87887: LD_VAR 0 5
87891: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87892: LD_INT 0
87894: PPUSH
87895: PPUSH
87896: PPUSH
87897: PPUSH
// if not mc_bases or not skirmish then
87898: LD_EXP 31
87902: NOT
87903: PUSH
87904: LD_EXP 29
87908: NOT
87909: OR
87910: IFFALSE 87914
// exit ;
87912: GO 88296
// side := GetSide ( vehicle ) ;
87914: LD_ADDR_VAR 0 5
87918: PUSH
87919: LD_VAR 0 1
87923: PPUSH
87924: CALL_OW 255
87928: ST_TO_ADDR
// for i = 1 to mc_bases do
87929: LD_ADDR_VAR 0 4
87933: PUSH
87934: DOUBLE
87935: LD_INT 1
87937: DEC
87938: ST_TO_ADDR
87939: LD_EXP 31
87943: PUSH
87944: FOR_TO
87945: IFFALSE 88294
// begin if factory in mc_bases [ i ] then
87947: LD_VAR 0 2
87951: PUSH
87952: LD_EXP 31
87956: PUSH
87957: LD_VAR 0 4
87961: ARRAY
87962: IN
87963: IFFALSE 88292
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87965: LD_EXP 53
87969: PUSH
87970: LD_VAR 0 4
87974: ARRAY
87975: PUSH
87976: LD_EXP 42
87980: PUSH
87981: LD_VAR 0 4
87985: ARRAY
87986: LESS
87987: PUSH
87988: LD_VAR 0 1
87992: PPUSH
87993: CALL_OW 264
87997: PUSH
87998: LD_INT 31
88000: PUSH
88001: LD_INT 32
88003: PUSH
88004: LD_INT 51
88006: PUSH
88007: LD_INT 89
88009: PUSH
88010: LD_INT 12
88012: PUSH
88013: LD_INT 30
88015: PUSH
88016: LD_INT 98
88018: PUSH
88019: LD_INT 11
88021: PUSH
88022: LD_INT 53
88024: PUSH
88025: LD_INT 14
88027: PUSH
88028: LD_INT 91
88030: PUSH
88031: LD_INT 29
88033: PUSH
88034: LD_INT 99
88036: PUSH
88037: LD_INT 13
88039: PUSH
88040: LD_INT 52
88042: PUSH
88043: LD_INT 88
88045: PUSH
88046: LD_INT 48
88048: PUSH
88049: LD_INT 8
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: LIST
88071: IN
88072: NOT
88073: AND
88074: IFFALSE 88122
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88076: LD_ADDR_EXP 53
88080: PUSH
88081: LD_EXP 53
88085: PPUSH
88086: LD_VAR 0 4
88090: PUSH
88091: LD_EXP 53
88095: PUSH
88096: LD_VAR 0 4
88100: ARRAY
88101: PUSH
88102: LD_INT 1
88104: PLUS
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PPUSH
88110: LD_VAR 0 1
88114: PPUSH
88115: CALL 25021 0 3
88119: ST_TO_ADDR
88120: GO 88166
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88122: LD_ADDR_EXP 50
88126: PUSH
88127: LD_EXP 50
88131: PPUSH
88132: LD_VAR 0 4
88136: PUSH
88137: LD_EXP 50
88141: PUSH
88142: LD_VAR 0 4
88146: ARRAY
88147: PUSH
88148: LD_INT 1
88150: PLUS
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PPUSH
88156: LD_VAR 0 1
88160: PPUSH
88161: CALL 25021 0 3
88165: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88166: LD_VAR 0 1
88170: PPUSH
88171: CALL_OW 263
88175: PUSH
88176: LD_INT 2
88178: EQUAL
88179: IFFALSE 88208
// begin repeat wait ( 0 0$3 ) ;
88181: LD_INT 105
88183: PPUSH
88184: CALL_OW 67
// Connect ( vehicle ) ;
88188: LD_VAR 0 1
88192: PPUSH
88193: CALL 27990 0 1
// until IsControledBy ( vehicle ) ;
88197: LD_VAR 0 1
88201: PPUSH
88202: CALL_OW 312
88206: IFFALSE 88181
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88208: LD_VAR 0 1
88212: PPUSH
88213: LD_EXP 55
88217: PUSH
88218: LD_VAR 0 4
88222: ARRAY
88223: PPUSH
88224: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88228: LD_VAR 0 1
88232: PPUSH
88233: CALL_OW 263
88237: PUSH
88238: LD_INT 1
88240: NONEQUAL
88241: IFFALSE 88245
// break ;
88243: GO 88294
// repeat wait ( 0 0$1 ) ;
88245: LD_INT 35
88247: PPUSH
88248: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88252: LD_VAR 0 1
88256: PPUSH
88257: LD_EXP 55
88261: PUSH
88262: LD_VAR 0 4
88266: ARRAY
88267: PPUSH
88268: CALL_OW 308
88272: IFFALSE 88245
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88274: LD_VAR 0 1
88278: PPUSH
88279: CALL_OW 311
88283: PPUSH
88284: CALL_OW 121
// exit ;
88288: POP
88289: POP
88290: GO 88296
// end ; end ;
88292: GO 87944
88294: POP
88295: POP
// end ;
88296: LD_VAR 0 3
88300: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88301: LD_INT 0
88303: PPUSH
88304: PPUSH
88305: PPUSH
88306: PPUSH
// if not mc_bases or not skirmish then
88307: LD_EXP 31
88311: NOT
88312: PUSH
88313: LD_EXP 29
88317: NOT
88318: OR
88319: IFFALSE 88323
// exit ;
88321: GO 88676
// repeat wait ( 0 0$1 ) ;
88323: LD_INT 35
88325: PPUSH
88326: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88330: LD_VAR 0 2
88334: PPUSH
88335: LD_VAR 0 3
88339: PPUSH
88340: CALL_OW 284
88344: IFFALSE 88323
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88346: LD_VAR 0 2
88350: PPUSH
88351: LD_VAR 0 3
88355: PPUSH
88356: CALL_OW 283
88360: PUSH
88361: LD_INT 4
88363: EQUAL
88364: IFFALSE 88368
// exit ;
88366: GO 88676
// for i = 1 to mc_bases do
88368: LD_ADDR_VAR 0 7
88372: PUSH
88373: DOUBLE
88374: LD_INT 1
88376: DEC
88377: ST_TO_ADDR
88378: LD_EXP 31
88382: PUSH
88383: FOR_TO
88384: IFFALSE 88674
// begin if mc_crates_area [ i ] then
88386: LD_EXP 49
88390: PUSH
88391: LD_VAR 0 7
88395: ARRAY
88396: IFFALSE 88507
// for j in mc_crates_area [ i ] do
88398: LD_ADDR_VAR 0 8
88402: PUSH
88403: LD_EXP 49
88407: PUSH
88408: LD_VAR 0 7
88412: ARRAY
88413: PUSH
88414: FOR_IN
88415: IFFALSE 88505
// if InArea ( x , y , j ) then
88417: LD_VAR 0 2
88421: PPUSH
88422: LD_VAR 0 3
88426: PPUSH
88427: LD_VAR 0 8
88431: PPUSH
88432: CALL_OW 309
88436: IFFALSE 88503
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88438: LD_ADDR_EXP 47
88442: PUSH
88443: LD_EXP 47
88447: PPUSH
88448: LD_VAR 0 7
88452: PUSH
88453: LD_EXP 47
88457: PUSH
88458: LD_VAR 0 7
88462: ARRAY
88463: PUSH
88464: LD_INT 1
88466: PLUS
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PPUSH
88472: LD_VAR 0 4
88476: PUSH
88477: LD_VAR 0 2
88481: PUSH
88482: LD_VAR 0 3
88486: PUSH
88487: EMPTY
88488: LIST
88489: LIST
88490: LIST
88491: PPUSH
88492: CALL 25021 0 3
88496: ST_TO_ADDR
// exit ;
88497: POP
88498: POP
88499: POP
88500: POP
88501: GO 88676
// end ;
88503: GO 88414
88505: POP
88506: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88507: LD_ADDR_VAR 0 9
88511: PUSH
88512: LD_EXP 31
88516: PUSH
88517: LD_VAR 0 7
88521: ARRAY
88522: PPUSH
88523: LD_INT 2
88525: PUSH
88526: LD_INT 30
88528: PUSH
88529: LD_INT 0
88531: PUSH
88532: EMPTY
88533: LIST
88534: LIST
88535: PUSH
88536: LD_INT 30
88538: PUSH
88539: LD_INT 1
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: LIST
88550: PPUSH
88551: CALL_OW 72
88555: ST_TO_ADDR
// if not depot then
88556: LD_VAR 0 9
88560: NOT
88561: IFFALSE 88565
// continue ;
88563: GO 88383
// for j in depot do
88565: LD_ADDR_VAR 0 8
88569: PUSH
88570: LD_VAR 0 9
88574: PUSH
88575: FOR_IN
88576: IFFALSE 88670
// if GetDistUnitXY ( j , x , y ) < 30 then
88578: LD_VAR 0 8
88582: PPUSH
88583: LD_VAR 0 2
88587: PPUSH
88588: LD_VAR 0 3
88592: PPUSH
88593: CALL_OW 297
88597: PUSH
88598: LD_INT 30
88600: LESS
88601: IFFALSE 88668
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88603: LD_ADDR_EXP 47
88607: PUSH
88608: LD_EXP 47
88612: PPUSH
88613: LD_VAR 0 7
88617: PUSH
88618: LD_EXP 47
88622: PUSH
88623: LD_VAR 0 7
88627: ARRAY
88628: PUSH
88629: LD_INT 1
88631: PLUS
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PPUSH
88637: LD_VAR 0 4
88641: PUSH
88642: LD_VAR 0 2
88646: PUSH
88647: LD_VAR 0 3
88651: PUSH
88652: EMPTY
88653: LIST
88654: LIST
88655: LIST
88656: PPUSH
88657: CALL 25021 0 3
88661: ST_TO_ADDR
// exit ;
88662: POP
88663: POP
88664: POP
88665: POP
88666: GO 88676
// end ;
88668: GO 88575
88670: POP
88671: POP
// end ;
88672: GO 88383
88674: POP
88675: POP
// end ;
88676: LD_VAR 0 6
88680: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88681: LD_INT 0
88683: PPUSH
88684: PPUSH
88685: PPUSH
88686: PPUSH
// if not mc_bases or not skirmish then
88687: LD_EXP 31
88691: NOT
88692: PUSH
88693: LD_EXP 29
88697: NOT
88698: OR
88699: IFFALSE 88703
// exit ;
88701: GO 88980
// side := GetSide ( lab ) ;
88703: LD_ADDR_VAR 0 4
88707: PUSH
88708: LD_VAR 0 2
88712: PPUSH
88713: CALL_OW 255
88717: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88718: LD_VAR 0 4
88722: PUSH
88723: LD_EXP 57
88727: IN
88728: NOT
88729: PUSH
88730: LD_EXP 58
88734: NOT
88735: OR
88736: PUSH
88737: LD_EXP 31
88741: NOT
88742: OR
88743: IFFALSE 88747
// exit ;
88745: GO 88980
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88747: LD_ADDR_EXP 58
88751: PUSH
88752: LD_EXP 58
88756: PPUSH
88757: LD_VAR 0 4
88761: PPUSH
88762: LD_EXP 58
88766: PUSH
88767: LD_VAR 0 4
88771: ARRAY
88772: PUSH
88773: LD_VAR 0 1
88777: DIFF
88778: PPUSH
88779: CALL_OW 1
88783: ST_TO_ADDR
// for i = 1 to mc_bases do
88784: LD_ADDR_VAR 0 5
88788: PUSH
88789: DOUBLE
88790: LD_INT 1
88792: DEC
88793: ST_TO_ADDR
88794: LD_EXP 31
88798: PUSH
88799: FOR_TO
88800: IFFALSE 88978
// begin if lab in mc_bases [ i ] then
88802: LD_VAR 0 2
88806: PUSH
88807: LD_EXP 31
88811: PUSH
88812: LD_VAR 0 5
88816: ARRAY
88817: IN
88818: IFFALSE 88976
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88820: LD_VAR 0 1
88824: PUSH
88825: LD_INT 11
88827: PUSH
88828: LD_INT 4
88830: PUSH
88831: LD_INT 3
88833: PUSH
88834: LD_INT 2
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: IN
88843: PUSH
88844: LD_EXP 61
88848: PUSH
88849: LD_VAR 0 5
88853: ARRAY
88854: AND
88855: IFFALSE 88976
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88857: LD_ADDR_VAR 0 6
88861: PUSH
88862: LD_EXP 61
88866: PUSH
88867: LD_VAR 0 5
88871: ARRAY
88872: PUSH
88873: LD_INT 1
88875: ARRAY
88876: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88877: LD_ADDR_EXP 61
88881: PUSH
88882: LD_EXP 61
88886: PPUSH
88887: LD_VAR 0 5
88891: PPUSH
88892: EMPTY
88893: PPUSH
88894: CALL_OW 1
88898: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88899: LD_VAR 0 6
88903: PPUSH
88904: LD_INT 0
88906: PPUSH
88907: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88911: LD_VAR 0 6
88915: PPUSH
88916: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88920: LD_ADDR_EXP 60
88924: PUSH
88925: LD_EXP 60
88929: PPUSH
88930: LD_VAR 0 5
88934: PPUSH
88935: LD_EXP 60
88939: PUSH
88940: LD_VAR 0 5
88944: ARRAY
88945: PPUSH
88946: LD_INT 1
88948: PPUSH
88949: LD_VAR 0 6
88953: PPUSH
88954: CALL_OW 2
88958: PPUSH
88959: CALL_OW 1
88963: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88964: LD_VAR 0 5
88968: PPUSH
88969: LD_INT 112
88971: PPUSH
88972: CALL 65466 0 2
// end ; end ; end ;
88976: GO 88799
88978: POP
88979: POP
// end ;
88980: LD_VAR 0 3
88984: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
88985: LD_INT 0
88987: PPUSH
88988: PPUSH
88989: PPUSH
88990: PPUSH
88991: PPUSH
88992: PPUSH
88993: PPUSH
88994: PPUSH
// if not mc_bases or not skirmish then
88995: LD_EXP 31
88999: NOT
89000: PUSH
89001: LD_EXP 29
89005: NOT
89006: OR
89007: IFFALSE 89011
// exit ;
89009: GO 90380
// for i = 1 to mc_bases do
89011: LD_ADDR_VAR 0 3
89015: PUSH
89016: DOUBLE
89017: LD_INT 1
89019: DEC
89020: ST_TO_ADDR
89021: LD_EXP 31
89025: PUSH
89026: FOR_TO
89027: IFFALSE 90378
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
89029: LD_VAR 0 1
89033: PUSH
89034: LD_EXP 31
89038: PUSH
89039: LD_VAR 0 3
89043: ARRAY
89044: IN
89045: PUSH
89046: LD_VAR 0 1
89050: PUSH
89051: LD_EXP 38
89055: PUSH
89056: LD_VAR 0 3
89060: ARRAY
89061: IN
89062: OR
89063: PUSH
89064: LD_VAR 0 1
89068: PUSH
89069: LD_EXP 53
89073: PUSH
89074: LD_VAR 0 3
89078: ARRAY
89079: IN
89080: OR
89081: PUSH
89082: LD_VAR 0 1
89086: PUSH
89087: LD_EXP 50
89091: PUSH
89092: LD_VAR 0 3
89096: ARRAY
89097: IN
89098: OR
89099: PUSH
89100: LD_VAR 0 1
89104: PUSH
89105: LD_EXP 60
89109: PUSH
89110: LD_VAR 0 3
89114: ARRAY
89115: IN
89116: OR
89117: PUSH
89118: LD_VAR 0 1
89122: PUSH
89123: LD_EXP 61
89127: PUSH
89128: LD_VAR 0 3
89132: ARRAY
89133: IN
89134: OR
89135: IFFALSE 90376
// begin if un in mc_ape [ i ] then
89137: LD_VAR 0 1
89141: PUSH
89142: LD_EXP 60
89146: PUSH
89147: LD_VAR 0 3
89151: ARRAY
89152: IN
89153: IFFALSE 89192
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89155: LD_ADDR_EXP 60
89159: PUSH
89160: LD_EXP 60
89164: PPUSH
89165: LD_VAR 0 3
89169: PPUSH
89170: LD_EXP 60
89174: PUSH
89175: LD_VAR 0 3
89179: ARRAY
89180: PUSH
89181: LD_VAR 0 1
89185: DIFF
89186: PPUSH
89187: CALL_OW 1
89191: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89192: LD_VAR 0 1
89196: PUSH
89197: LD_EXP 61
89201: PUSH
89202: LD_VAR 0 3
89206: ARRAY
89207: IN
89208: IFFALSE 89232
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89210: LD_ADDR_EXP 61
89214: PUSH
89215: LD_EXP 61
89219: PPUSH
89220: LD_VAR 0 3
89224: PPUSH
89225: EMPTY
89226: PPUSH
89227: CALL_OW 1
89231: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89232: LD_VAR 0 1
89236: PPUSH
89237: CALL_OW 247
89241: PUSH
89242: LD_INT 2
89244: EQUAL
89245: PUSH
89246: LD_VAR 0 1
89250: PPUSH
89251: CALL_OW 110
89255: PUSH
89256: LD_INT 20
89258: EQUAL
89259: PUSH
89260: LD_VAR 0 1
89264: PUSH
89265: LD_EXP 53
89269: PUSH
89270: LD_VAR 0 3
89274: ARRAY
89275: IN
89276: OR
89277: PUSH
89278: LD_VAR 0 1
89282: PPUSH
89283: CALL_OW 264
89287: PUSH
89288: LD_INT 12
89290: PUSH
89291: LD_INT 51
89293: PUSH
89294: LD_INT 89
89296: PUSH
89297: LD_INT 32
89299: PUSH
89300: LD_INT 13
89302: PUSH
89303: LD_INT 52
89305: PUSH
89306: LD_INT 31
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: IN
89318: OR
89319: AND
89320: IFFALSE 89628
// begin if un in mc_defender [ i ] then
89322: LD_VAR 0 1
89326: PUSH
89327: LD_EXP 53
89331: PUSH
89332: LD_VAR 0 3
89336: ARRAY
89337: IN
89338: IFFALSE 89377
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89340: LD_ADDR_EXP 53
89344: PUSH
89345: LD_EXP 53
89349: PPUSH
89350: LD_VAR 0 3
89354: PPUSH
89355: LD_EXP 53
89359: PUSH
89360: LD_VAR 0 3
89364: ARRAY
89365: PUSH
89366: LD_VAR 0 1
89370: DIFF
89371: PPUSH
89372: CALL_OW 1
89376: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89377: LD_ADDR_VAR 0 8
89381: PUSH
89382: LD_VAR 0 3
89386: PPUSH
89387: LD_INT 3
89389: PPUSH
89390: CALL 86036 0 2
89394: ST_TO_ADDR
// if fac then
89395: LD_VAR 0 8
89399: IFFALSE 89628
// begin for j in fac do
89401: LD_ADDR_VAR 0 4
89405: PUSH
89406: LD_VAR 0 8
89410: PUSH
89411: FOR_IN
89412: IFFALSE 89626
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89414: LD_ADDR_VAR 0 9
89418: PUSH
89419: LD_VAR 0 8
89423: PPUSH
89424: LD_VAR 0 1
89428: PPUSH
89429: CALL_OW 265
89433: PPUSH
89434: LD_VAR 0 1
89438: PPUSH
89439: CALL_OW 262
89443: PPUSH
89444: LD_VAR 0 1
89448: PPUSH
89449: CALL_OW 263
89453: PPUSH
89454: LD_VAR 0 1
89458: PPUSH
89459: CALL_OW 264
89463: PPUSH
89464: CALL 22519 0 5
89468: ST_TO_ADDR
// if components then
89469: LD_VAR 0 9
89473: IFFALSE 89624
// begin if GetWeapon ( un ) = ar_control_tower then
89475: LD_VAR 0 1
89479: PPUSH
89480: CALL_OW 264
89484: PUSH
89485: LD_INT 31
89487: EQUAL
89488: IFFALSE 89605
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89490: LD_VAR 0 1
89494: PPUSH
89495: CALL_OW 311
89499: PPUSH
89500: LD_INT 0
89502: PPUSH
89503: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89507: LD_ADDR_EXP 71
89511: PUSH
89512: LD_EXP 71
89516: PPUSH
89517: LD_VAR 0 3
89521: PPUSH
89522: LD_EXP 71
89526: PUSH
89527: LD_VAR 0 3
89531: ARRAY
89532: PUSH
89533: LD_VAR 0 1
89537: PPUSH
89538: CALL_OW 311
89542: DIFF
89543: PPUSH
89544: CALL_OW 1
89548: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89549: LD_ADDR_VAR 0 7
89553: PUSH
89554: LD_EXP 52
89558: PUSH
89559: LD_VAR 0 3
89563: ARRAY
89564: PPUSH
89565: LD_INT 1
89567: PPUSH
89568: LD_VAR 0 9
89572: PPUSH
89573: CALL_OW 2
89577: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89578: LD_ADDR_EXP 52
89582: PUSH
89583: LD_EXP 52
89587: PPUSH
89588: LD_VAR 0 3
89592: PPUSH
89593: LD_VAR 0 7
89597: PPUSH
89598: CALL_OW 1
89602: ST_TO_ADDR
// end else
89603: GO 89622
// MC_InsertProduceList ( i , [ components ] ) ;
89605: LD_VAR 0 3
89609: PPUSH
89610: LD_VAR 0 9
89614: PUSH
89615: EMPTY
89616: LIST
89617: PPUSH
89618: CALL 85581 0 2
// break ;
89622: GO 89626
// end ; end ;
89624: GO 89411
89626: POP
89627: POP
// end ; end ; if GetType ( un ) = unit_building then
89628: LD_VAR 0 1
89632: PPUSH
89633: CALL_OW 247
89637: PUSH
89638: LD_INT 3
89640: EQUAL
89641: IFFALSE 90044
// begin btype := GetBType ( un ) ;
89643: LD_ADDR_VAR 0 5
89647: PUSH
89648: LD_VAR 0 1
89652: PPUSH
89653: CALL_OW 266
89657: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89658: LD_VAR 0 5
89662: PUSH
89663: LD_INT 29
89665: PUSH
89666: LD_INT 30
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: IN
89673: IFFALSE 89746
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89675: LD_VAR 0 1
89679: PPUSH
89680: CALL_OW 250
89684: PPUSH
89685: LD_VAR 0 1
89689: PPUSH
89690: CALL_OW 251
89694: PPUSH
89695: LD_VAR 0 1
89699: PPUSH
89700: CALL_OW 255
89704: PPUSH
89705: CALL_OW 440
89709: NOT
89710: IFFALSE 89746
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89712: LD_VAR 0 1
89716: PPUSH
89717: CALL_OW 250
89721: PPUSH
89722: LD_VAR 0 1
89726: PPUSH
89727: CALL_OW 251
89731: PPUSH
89732: LD_VAR 0 1
89736: PPUSH
89737: CALL_OW 255
89741: PPUSH
89742: CALL_OW 441
// end ; if btype = b_warehouse then
89746: LD_VAR 0 5
89750: PUSH
89751: LD_INT 1
89753: EQUAL
89754: IFFALSE 89772
// begin btype := b_depot ;
89756: LD_ADDR_VAR 0 5
89760: PUSH
89761: LD_INT 0
89763: ST_TO_ADDR
// pos := 1 ;
89764: LD_ADDR_VAR 0 6
89768: PUSH
89769: LD_INT 1
89771: ST_TO_ADDR
// end ; if btype = b_factory then
89772: LD_VAR 0 5
89776: PUSH
89777: LD_INT 3
89779: EQUAL
89780: IFFALSE 89798
// begin btype := b_workshop ;
89782: LD_ADDR_VAR 0 5
89786: PUSH
89787: LD_INT 2
89789: ST_TO_ADDR
// pos := 1 ;
89790: LD_ADDR_VAR 0 6
89794: PUSH
89795: LD_INT 1
89797: ST_TO_ADDR
// end ; if btype = b_barracks then
89798: LD_VAR 0 5
89802: PUSH
89803: LD_INT 5
89805: EQUAL
89806: IFFALSE 89816
// btype := b_armoury ;
89808: LD_ADDR_VAR 0 5
89812: PUSH
89813: LD_INT 4
89815: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89816: LD_VAR 0 5
89820: PUSH
89821: LD_INT 7
89823: PUSH
89824: LD_INT 8
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: IN
89831: IFFALSE 89841
// btype := b_lab ;
89833: LD_ADDR_VAR 0 5
89837: PUSH
89838: LD_INT 6
89840: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89841: LD_ADDR_EXP 36
89845: PUSH
89846: LD_EXP 36
89850: PPUSH
89851: LD_VAR 0 3
89855: PUSH
89856: LD_EXP 36
89860: PUSH
89861: LD_VAR 0 3
89865: ARRAY
89866: PUSH
89867: LD_INT 1
89869: PLUS
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PPUSH
89875: LD_VAR 0 5
89879: PUSH
89880: LD_VAR 0 1
89884: PPUSH
89885: CALL_OW 250
89889: PUSH
89890: LD_VAR 0 1
89894: PPUSH
89895: CALL_OW 251
89899: PUSH
89900: LD_VAR 0 1
89904: PPUSH
89905: CALL_OW 254
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: PPUSH
89916: CALL 25021 0 3
89920: ST_TO_ADDR
// if pos = 1 then
89921: LD_VAR 0 6
89925: PUSH
89926: LD_INT 1
89928: EQUAL
89929: IFFALSE 90044
// begin tmp := mc_build_list [ i ] ;
89931: LD_ADDR_VAR 0 7
89935: PUSH
89936: LD_EXP 36
89940: PUSH
89941: LD_VAR 0 3
89945: ARRAY
89946: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89947: LD_VAR 0 7
89951: PPUSH
89952: LD_INT 2
89954: PUSH
89955: LD_INT 30
89957: PUSH
89958: LD_INT 0
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: PUSH
89965: LD_INT 30
89967: PUSH
89968: LD_INT 1
89970: PUSH
89971: EMPTY
89972: LIST
89973: LIST
89974: PUSH
89975: EMPTY
89976: LIST
89977: LIST
89978: LIST
89979: PPUSH
89980: CALL_OW 72
89984: IFFALSE 89994
// pos := 2 ;
89986: LD_ADDR_VAR 0 6
89990: PUSH
89991: LD_INT 2
89993: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
89994: LD_ADDR_VAR 0 7
89998: PUSH
89999: LD_VAR 0 7
90003: PPUSH
90004: LD_VAR 0 6
90008: PPUSH
90009: LD_VAR 0 7
90013: PPUSH
90014: CALL 25347 0 3
90018: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
90019: LD_ADDR_EXP 36
90023: PUSH
90024: LD_EXP 36
90028: PPUSH
90029: LD_VAR 0 3
90033: PPUSH
90034: LD_VAR 0 7
90038: PPUSH
90039: CALL_OW 1
90043: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
90044: LD_VAR 0 1
90048: PUSH
90049: LD_EXP 31
90053: PUSH
90054: LD_VAR 0 3
90058: ARRAY
90059: IN
90060: IFFALSE 90099
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90062: LD_ADDR_EXP 31
90066: PUSH
90067: LD_EXP 31
90071: PPUSH
90072: LD_VAR 0 3
90076: PPUSH
90077: LD_EXP 31
90081: PUSH
90082: LD_VAR 0 3
90086: ARRAY
90087: PUSH
90088: LD_VAR 0 1
90092: DIFF
90093: PPUSH
90094: CALL_OW 1
90098: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90099: LD_VAR 0 1
90103: PUSH
90104: LD_EXP 38
90108: PUSH
90109: LD_VAR 0 3
90113: ARRAY
90114: IN
90115: IFFALSE 90154
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90117: LD_ADDR_EXP 38
90121: PUSH
90122: LD_EXP 38
90126: PPUSH
90127: LD_VAR 0 3
90131: PPUSH
90132: LD_EXP 38
90136: PUSH
90137: LD_VAR 0 3
90141: ARRAY
90142: PUSH
90143: LD_VAR 0 1
90147: DIFF
90148: PPUSH
90149: CALL_OW 1
90153: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90154: LD_VAR 0 1
90158: PUSH
90159: LD_EXP 50
90163: PUSH
90164: LD_VAR 0 3
90168: ARRAY
90169: IN
90170: IFFALSE 90209
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90172: LD_ADDR_EXP 50
90176: PUSH
90177: LD_EXP 50
90181: PPUSH
90182: LD_VAR 0 3
90186: PPUSH
90187: LD_EXP 50
90191: PUSH
90192: LD_VAR 0 3
90196: ARRAY
90197: PUSH
90198: LD_VAR 0 1
90202: DIFF
90203: PPUSH
90204: CALL_OW 1
90208: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90209: LD_VAR 0 1
90213: PUSH
90214: LD_EXP 53
90218: PUSH
90219: LD_VAR 0 3
90223: ARRAY
90224: IN
90225: IFFALSE 90264
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90227: LD_ADDR_EXP 53
90231: PUSH
90232: LD_EXP 53
90236: PPUSH
90237: LD_VAR 0 3
90241: PPUSH
90242: LD_EXP 53
90246: PUSH
90247: LD_VAR 0 3
90251: ARRAY
90252: PUSH
90253: LD_VAR 0 1
90257: DIFF
90258: PPUSH
90259: CALL_OW 1
90263: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90264: LD_VAR 0 1
90268: PUSH
90269: LD_EXP 40
90273: PUSH
90274: LD_VAR 0 3
90278: ARRAY
90279: IN
90280: IFFALSE 90319
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90282: LD_ADDR_EXP 40
90286: PUSH
90287: LD_EXP 40
90291: PPUSH
90292: LD_VAR 0 3
90296: PPUSH
90297: LD_EXP 40
90301: PUSH
90302: LD_VAR 0 3
90306: ARRAY
90307: PUSH
90308: LD_VAR 0 1
90312: DIFF
90313: PPUSH
90314: CALL_OW 1
90318: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90319: LD_VAR 0 1
90323: PUSH
90324: LD_EXP 39
90328: PUSH
90329: LD_VAR 0 3
90333: ARRAY
90334: IN
90335: IFFALSE 90374
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90337: LD_ADDR_EXP 39
90341: PUSH
90342: LD_EXP 39
90346: PPUSH
90347: LD_VAR 0 3
90351: PPUSH
90352: LD_EXP 39
90356: PUSH
90357: LD_VAR 0 3
90361: ARRAY
90362: PUSH
90363: LD_VAR 0 1
90367: DIFF
90368: PPUSH
90369: CALL_OW 1
90373: ST_TO_ADDR
// end ; break ;
90374: GO 90378
// end ;
90376: GO 89026
90378: POP
90379: POP
// end ;
90380: LD_VAR 0 2
90384: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90385: LD_INT 0
90387: PPUSH
90388: PPUSH
90389: PPUSH
// if not mc_bases or not skirmish then
90390: LD_EXP 31
90394: NOT
90395: PUSH
90396: LD_EXP 29
90400: NOT
90401: OR
90402: IFFALSE 90406
// exit ;
90404: GO 90621
// for i = 1 to mc_bases do
90406: LD_ADDR_VAR 0 3
90410: PUSH
90411: DOUBLE
90412: LD_INT 1
90414: DEC
90415: ST_TO_ADDR
90416: LD_EXP 31
90420: PUSH
90421: FOR_TO
90422: IFFALSE 90619
// begin if building in mc_construct_list [ i ] then
90424: LD_VAR 0 1
90428: PUSH
90429: LD_EXP 38
90433: PUSH
90434: LD_VAR 0 3
90438: ARRAY
90439: IN
90440: IFFALSE 90617
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90442: LD_ADDR_EXP 38
90446: PUSH
90447: LD_EXP 38
90451: PPUSH
90452: LD_VAR 0 3
90456: PPUSH
90457: LD_EXP 38
90461: PUSH
90462: LD_VAR 0 3
90466: ARRAY
90467: PUSH
90468: LD_VAR 0 1
90472: DIFF
90473: PPUSH
90474: CALL_OW 1
90478: ST_TO_ADDR
// if building in mc_lab [ i ] then
90479: LD_VAR 0 1
90483: PUSH
90484: LD_EXP 64
90488: PUSH
90489: LD_VAR 0 3
90493: ARRAY
90494: IN
90495: IFFALSE 90550
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90497: LD_ADDR_EXP 65
90501: PUSH
90502: LD_EXP 65
90506: PPUSH
90507: LD_VAR 0 3
90511: PPUSH
90512: LD_EXP 65
90516: PUSH
90517: LD_VAR 0 3
90521: ARRAY
90522: PPUSH
90523: LD_INT 1
90525: PPUSH
90526: LD_EXP 65
90530: PUSH
90531: LD_VAR 0 3
90535: ARRAY
90536: PPUSH
90537: LD_INT 0
90539: PPUSH
90540: CALL 24439 0 4
90544: PPUSH
90545: CALL_OW 1
90549: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90550: LD_VAR 0 1
90554: PUSH
90555: LD_EXP 31
90559: PUSH
90560: LD_VAR 0 3
90564: ARRAY
90565: IN
90566: NOT
90567: IFFALSE 90613
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90569: LD_ADDR_EXP 31
90573: PUSH
90574: LD_EXP 31
90578: PPUSH
90579: LD_VAR 0 3
90583: PUSH
90584: LD_EXP 31
90588: PUSH
90589: LD_VAR 0 3
90593: ARRAY
90594: PUSH
90595: LD_INT 1
90597: PLUS
90598: PUSH
90599: EMPTY
90600: LIST
90601: LIST
90602: PPUSH
90603: LD_VAR 0 1
90607: PPUSH
90608: CALL 25021 0 3
90612: ST_TO_ADDR
// exit ;
90613: POP
90614: POP
90615: GO 90621
// end ; end ;
90617: GO 90421
90619: POP
90620: POP
// end ;
90621: LD_VAR 0 2
90625: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90626: LD_INT 0
90628: PPUSH
90629: PPUSH
90630: PPUSH
90631: PPUSH
90632: PPUSH
90633: PPUSH
90634: PPUSH
// if not mc_bases or not skirmish then
90635: LD_EXP 31
90639: NOT
90640: PUSH
90641: LD_EXP 29
90645: NOT
90646: OR
90647: IFFALSE 90651
// exit ;
90649: GO 91312
// for i = 1 to mc_bases do
90651: LD_ADDR_VAR 0 3
90655: PUSH
90656: DOUBLE
90657: LD_INT 1
90659: DEC
90660: ST_TO_ADDR
90661: LD_EXP 31
90665: PUSH
90666: FOR_TO
90667: IFFALSE 91310
// begin if building in mc_construct_list [ i ] then
90669: LD_VAR 0 1
90673: PUSH
90674: LD_EXP 38
90678: PUSH
90679: LD_VAR 0 3
90683: ARRAY
90684: IN
90685: IFFALSE 91308
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90687: LD_ADDR_EXP 38
90691: PUSH
90692: LD_EXP 38
90696: PPUSH
90697: LD_VAR 0 3
90701: PPUSH
90702: LD_EXP 38
90706: PUSH
90707: LD_VAR 0 3
90711: ARRAY
90712: PUSH
90713: LD_VAR 0 1
90717: DIFF
90718: PPUSH
90719: CALL_OW 1
90723: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90724: LD_ADDR_EXP 31
90728: PUSH
90729: LD_EXP 31
90733: PPUSH
90734: LD_VAR 0 3
90738: PUSH
90739: LD_EXP 31
90743: PUSH
90744: LD_VAR 0 3
90748: ARRAY
90749: PUSH
90750: LD_INT 1
90752: PLUS
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PPUSH
90758: LD_VAR 0 1
90762: PPUSH
90763: CALL 25021 0 3
90767: ST_TO_ADDR
// btype := GetBType ( building ) ;
90768: LD_ADDR_VAR 0 5
90772: PUSH
90773: LD_VAR 0 1
90777: PPUSH
90778: CALL_OW 266
90782: ST_TO_ADDR
// side := GetSide ( building ) ;
90783: LD_ADDR_VAR 0 8
90787: PUSH
90788: LD_VAR 0 1
90792: PPUSH
90793: CALL_OW 255
90797: ST_TO_ADDR
// if btype = b_lab then
90798: LD_VAR 0 5
90802: PUSH
90803: LD_INT 6
90805: EQUAL
90806: IFFALSE 90856
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90808: LD_ADDR_EXP 64
90812: PUSH
90813: LD_EXP 64
90817: PPUSH
90818: LD_VAR 0 3
90822: PUSH
90823: LD_EXP 64
90827: PUSH
90828: LD_VAR 0 3
90832: ARRAY
90833: PUSH
90834: LD_INT 1
90836: PLUS
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: PPUSH
90842: LD_VAR 0 1
90846: PPUSH
90847: CALL 25021 0 3
90851: ST_TO_ADDR
// exit ;
90852: POP
90853: POP
90854: GO 91312
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90856: LD_VAR 0 5
90860: PUSH
90861: LD_INT 0
90863: PUSH
90864: LD_INT 2
90866: PUSH
90867: LD_INT 4
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: LIST
90874: IN
90875: IFFALSE 90999
// begin if btype = b_armoury then
90877: LD_VAR 0 5
90881: PUSH
90882: LD_INT 4
90884: EQUAL
90885: IFFALSE 90895
// btype := b_barracks ;
90887: LD_ADDR_VAR 0 5
90891: PUSH
90892: LD_INT 5
90894: ST_TO_ADDR
// if btype = b_depot then
90895: LD_VAR 0 5
90899: PUSH
90900: LD_INT 0
90902: EQUAL
90903: IFFALSE 90913
// btype := b_warehouse ;
90905: LD_ADDR_VAR 0 5
90909: PUSH
90910: LD_INT 1
90912: ST_TO_ADDR
// if btype = b_workshop then
90913: LD_VAR 0 5
90917: PUSH
90918: LD_INT 2
90920: EQUAL
90921: IFFALSE 90931
// btype := b_factory ;
90923: LD_ADDR_VAR 0 5
90927: PUSH
90928: LD_INT 3
90930: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90931: LD_VAR 0 5
90935: PPUSH
90936: LD_VAR 0 8
90940: PPUSH
90941: CALL_OW 323
90945: PUSH
90946: LD_INT 1
90948: EQUAL
90949: IFFALSE 90995
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90951: LD_ADDR_EXP 63
90955: PUSH
90956: LD_EXP 63
90960: PPUSH
90961: LD_VAR 0 3
90965: PUSH
90966: LD_EXP 63
90970: PUSH
90971: LD_VAR 0 3
90975: ARRAY
90976: PUSH
90977: LD_INT 1
90979: PLUS
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PPUSH
90985: LD_VAR 0 1
90989: PPUSH
90990: CALL 25021 0 3
90994: ST_TO_ADDR
// exit ;
90995: POP
90996: POP
90997: GO 91312
// end ; if btype in [ b_bunker , b_turret ] then
90999: LD_VAR 0 5
91003: PUSH
91004: LD_INT 32
91006: PUSH
91007: LD_INT 33
91009: PUSH
91010: EMPTY
91011: LIST
91012: LIST
91013: IN
91014: IFFALSE 91304
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
91016: LD_ADDR_EXP 39
91020: PUSH
91021: LD_EXP 39
91025: PPUSH
91026: LD_VAR 0 3
91030: PUSH
91031: LD_EXP 39
91035: PUSH
91036: LD_VAR 0 3
91040: ARRAY
91041: PUSH
91042: LD_INT 1
91044: PLUS
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: PPUSH
91050: LD_VAR 0 1
91054: PPUSH
91055: CALL 25021 0 3
91059: ST_TO_ADDR
// if btype = b_bunker then
91060: LD_VAR 0 5
91064: PUSH
91065: LD_INT 32
91067: EQUAL
91068: IFFALSE 91304
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91070: LD_ADDR_EXP 40
91074: PUSH
91075: LD_EXP 40
91079: PPUSH
91080: LD_VAR 0 3
91084: PUSH
91085: LD_EXP 40
91089: PUSH
91090: LD_VAR 0 3
91094: ARRAY
91095: PUSH
91096: LD_INT 1
91098: PLUS
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PPUSH
91104: LD_VAR 0 1
91108: PPUSH
91109: CALL 25021 0 3
91113: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91114: LD_ADDR_VAR 0 6
91118: PUSH
91119: LD_EXP 31
91123: PUSH
91124: LD_VAR 0 3
91128: ARRAY
91129: PPUSH
91130: LD_INT 25
91132: PUSH
91133: LD_INT 1
91135: PUSH
91136: EMPTY
91137: LIST
91138: LIST
91139: PUSH
91140: LD_INT 3
91142: PUSH
91143: LD_INT 54
91145: PUSH
91146: EMPTY
91147: LIST
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PPUSH
91157: CALL_OW 72
91161: ST_TO_ADDR
// if tmp then
91162: LD_VAR 0 6
91166: IFFALSE 91172
// exit ;
91168: POP
91169: POP
91170: GO 91312
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91172: LD_ADDR_VAR 0 6
91176: PUSH
91177: LD_EXP 31
91181: PUSH
91182: LD_VAR 0 3
91186: ARRAY
91187: PPUSH
91188: LD_INT 2
91190: PUSH
91191: LD_INT 30
91193: PUSH
91194: LD_INT 4
91196: PUSH
91197: EMPTY
91198: LIST
91199: LIST
91200: PUSH
91201: LD_INT 30
91203: PUSH
91204: LD_INT 5
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: LIST
91215: PPUSH
91216: CALL_OW 72
91220: ST_TO_ADDR
// if not tmp then
91221: LD_VAR 0 6
91225: NOT
91226: IFFALSE 91232
// exit ;
91228: POP
91229: POP
91230: GO 91312
// for j in tmp do
91232: LD_ADDR_VAR 0 4
91236: PUSH
91237: LD_VAR 0 6
91241: PUSH
91242: FOR_IN
91243: IFFALSE 91302
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91245: LD_ADDR_VAR 0 7
91249: PUSH
91250: LD_VAR 0 4
91254: PPUSH
91255: CALL_OW 313
91259: PPUSH
91260: LD_INT 25
91262: PUSH
91263: LD_INT 1
91265: PUSH
91266: EMPTY
91267: LIST
91268: LIST
91269: PPUSH
91270: CALL_OW 72
91274: ST_TO_ADDR
// if units then
91275: LD_VAR 0 7
91279: IFFALSE 91300
// begin ComExitBuilding ( units [ 1 ] ) ;
91281: LD_VAR 0 7
91285: PUSH
91286: LD_INT 1
91288: ARRAY
91289: PPUSH
91290: CALL_OW 122
// exit ;
91294: POP
91295: POP
91296: POP
91297: POP
91298: GO 91312
// end ; end ;
91300: GO 91242
91302: POP
91303: POP
// end ; end ; exit ;
91304: POP
91305: POP
91306: GO 91312
// end ; end ;
91308: GO 90666
91310: POP
91311: POP
// end ;
91312: LD_VAR 0 2
91316: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91317: LD_INT 0
91319: PPUSH
91320: PPUSH
91321: PPUSH
91322: PPUSH
91323: PPUSH
91324: PPUSH
91325: PPUSH
// if not mc_bases or not skirmish then
91326: LD_EXP 31
91330: NOT
91331: PUSH
91332: LD_EXP 29
91336: NOT
91337: OR
91338: IFFALSE 91342
// exit ;
91340: GO 91607
// btype := GetBType ( building ) ;
91342: LD_ADDR_VAR 0 6
91346: PUSH
91347: LD_VAR 0 1
91351: PPUSH
91352: CALL_OW 266
91356: ST_TO_ADDR
// x := GetX ( building ) ;
91357: LD_ADDR_VAR 0 7
91361: PUSH
91362: LD_VAR 0 1
91366: PPUSH
91367: CALL_OW 250
91371: ST_TO_ADDR
// y := GetY ( building ) ;
91372: LD_ADDR_VAR 0 8
91376: PUSH
91377: LD_VAR 0 1
91381: PPUSH
91382: CALL_OW 251
91386: ST_TO_ADDR
// d := GetDir ( building ) ;
91387: LD_ADDR_VAR 0 9
91391: PUSH
91392: LD_VAR 0 1
91396: PPUSH
91397: CALL_OW 254
91401: ST_TO_ADDR
// for i = 1 to mc_bases do
91402: LD_ADDR_VAR 0 4
91406: PUSH
91407: DOUBLE
91408: LD_INT 1
91410: DEC
91411: ST_TO_ADDR
91412: LD_EXP 31
91416: PUSH
91417: FOR_TO
91418: IFFALSE 91605
// begin if not mc_build_list [ i ] then
91420: LD_EXP 36
91424: PUSH
91425: LD_VAR 0 4
91429: ARRAY
91430: NOT
91431: IFFALSE 91435
// continue ;
91433: GO 91417
// for j := 1 to mc_build_list [ i ] do
91435: LD_ADDR_VAR 0 5
91439: PUSH
91440: DOUBLE
91441: LD_INT 1
91443: DEC
91444: ST_TO_ADDR
91445: LD_EXP 36
91449: PUSH
91450: LD_VAR 0 4
91454: ARRAY
91455: PUSH
91456: FOR_TO
91457: IFFALSE 91601
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91459: LD_VAR 0 6
91463: PUSH
91464: LD_VAR 0 7
91468: PUSH
91469: LD_VAR 0 8
91473: PUSH
91474: LD_VAR 0 9
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: PPUSH
91485: LD_EXP 36
91489: PUSH
91490: LD_VAR 0 4
91494: ARRAY
91495: PUSH
91496: LD_VAR 0 5
91500: ARRAY
91501: PPUSH
91502: CALL 31201 0 2
91506: IFFALSE 91599
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91508: LD_ADDR_EXP 36
91512: PUSH
91513: LD_EXP 36
91517: PPUSH
91518: LD_VAR 0 4
91522: PPUSH
91523: LD_EXP 36
91527: PUSH
91528: LD_VAR 0 4
91532: ARRAY
91533: PPUSH
91534: LD_VAR 0 5
91538: PPUSH
91539: CALL_OW 3
91543: PPUSH
91544: CALL_OW 1
91548: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91549: LD_ADDR_EXP 38
91553: PUSH
91554: LD_EXP 38
91558: PPUSH
91559: LD_VAR 0 4
91563: PUSH
91564: LD_EXP 38
91568: PUSH
91569: LD_VAR 0 4
91573: ARRAY
91574: PUSH
91575: LD_INT 1
91577: PLUS
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PPUSH
91583: LD_VAR 0 1
91587: PPUSH
91588: CALL 25021 0 3
91592: ST_TO_ADDR
// exit ;
91593: POP
91594: POP
91595: POP
91596: POP
91597: GO 91607
// end ;
91599: GO 91456
91601: POP
91602: POP
// end ;
91603: GO 91417
91605: POP
91606: POP
// end ;
91607: LD_VAR 0 3
91611: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91612: LD_INT 0
91614: PPUSH
91615: PPUSH
91616: PPUSH
// if not mc_bases or not skirmish then
91617: LD_EXP 31
91621: NOT
91622: PUSH
91623: LD_EXP 29
91627: NOT
91628: OR
91629: IFFALSE 91633
// exit ;
91631: GO 91823
// for i = 1 to mc_bases do
91633: LD_ADDR_VAR 0 4
91637: PUSH
91638: DOUBLE
91639: LD_INT 1
91641: DEC
91642: ST_TO_ADDR
91643: LD_EXP 31
91647: PUSH
91648: FOR_TO
91649: IFFALSE 91736
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91651: LD_VAR 0 1
91655: PUSH
91656: LD_EXP 39
91660: PUSH
91661: LD_VAR 0 4
91665: ARRAY
91666: IN
91667: PUSH
91668: LD_VAR 0 1
91672: PUSH
91673: LD_EXP 40
91677: PUSH
91678: LD_VAR 0 4
91682: ARRAY
91683: IN
91684: NOT
91685: AND
91686: IFFALSE 91734
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91688: LD_ADDR_EXP 40
91692: PUSH
91693: LD_EXP 40
91697: PPUSH
91698: LD_VAR 0 4
91702: PUSH
91703: LD_EXP 40
91707: PUSH
91708: LD_VAR 0 4
91712: ARRAY
91713: PUSH
91714: LD_INT 1
91716: PLUS
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PPUSH
91722: LD_VAR 0 1
91726: PPUSH
91727: CALL 25021 0 3
91731: ST_TO_ADDR
// break ;
91732: GO 91736
// end ; end ;
91734: GO 91648
91736: POP
91737: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91738: LD_VAR 0 1
91742: PPUSH
91743: CALL_OW 257
91747: PUSH
91748: LD_EXP 57
91752: IN
91753: PUSH
91754: LD_VAR 0 1
91758: PPUSH
91759: CALL_OW 266
91763: PUSH
91764: LD_INT 5
91766: EQUAL
91767: AND
91768: PUSH
91769: LD_VAR 0 2
91773: PPUSH
91774: CALL_OW 110
91778: PUSH
91779: LD_INT 18
91781: NONEQUAL
91782: AND
91783: IFFALSE 91823
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91785: LD_VAR 0 2
91789: PPUSH
91790: CALL_OW 257
91794: PUSH
91795: LD_INT 5
91797: PUSH
91798: LD_INT 8
91800: PUSH
91801: LD_INT 9
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: LIST
91808: IN
91809: IFFALSE 91823
// SetClass ( unit , 1 ) ;
91811: LD_VAR 0 2
91815: PPUSH
91816: LD_INT 1
91818: PPUSH
91819: CALL_OW 336
// end ;
91823: LD_VAR 0 3
91827: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91828: LD_INT 0
91830: PPUSH
91831: PPUSH
// if not mc_bases or not skirmish then
91832: LD_EXP 31
91836: NOT
91837: PUSH
91838: LD_EXP 29
91842: NOT
91843: OR
91844: IFFALSE 91848
// exit ;
91846: GO 91964
// if GetLives ( abandoned_vehicle ) > 250 then
91848: LD_VAR 0 2
91852: PPUSH
91853: CALL_OW 256
91857: PUSH
91858: LD_INT 250
91860: GREATER
91861: IFFALSE 91865
// exit ;
91863: GO 91964
// for i = 1 to mc_bases do
91865: LD_ADDR_VAR 0 6
91869: PUSH
91870: DOUBLE
91871: LD_INT 1
91873: DEC
91874: ST_TO_ADDR
91875: LD_EXP 31
91879: PUSH
91880: FOR_TO
91881: IFFALSE 91962
// begin if driver in mc_bases [ i ] then
91883: LD_VAR 0 1
91887: PUSH
91888: LD_EXP 31
91892: PUSH
91893: LD_VAR 0 6
91897: ARRAY
91898: IN
91899: IFFALSE 91960
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91901: LD_VAR 0 1
91905: PPUSH
91906: LD_EXP 31
91910: PUSH
91911: LD_VAR 0 6
91915: ARRAY
91916: PPUSH
91917: LD_INT 2
91919: PUSH
91920: LD_INT 30
91922: PUSH
91923: LD_INT 0
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: PUSH
91930: LD_INT 30
91932: PUSH
91933: LD_INT 1
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PUSH
91940: EMPTY
91941: LIST
91942: LIST
91943: LIST
91944: PPUSH
91945: CALL_OW 72
91949: PUSH
91950: LD_INT 1
91952: ARRAY
91953: PPUSH
91954: CALL 58229 0 2
// break ;
91958: GO 91962
// end ; end ;
91960: GO 91880
91962: POP
91963: POP
// end ; end_of_file end_of_file
91964: LD_VAR 0 5
91968: RET
// every 0 0$1 do
91969: GO 91971
91971: DISABLE
// begin enable ;
91972: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91973: LD_STRING updateTimer(
91975: PUSH
91976: LD_OWVAR 1
91980: STR
91981: PUSH
91982: LD_STRING );
91984: STR
91985: PPUSH
91986: CALL_OW 559
// end ;
91990: END
// export function SOS_MapStart ( ) ; begin
91991: LD_INT 0
91993: PPUSH
// if streamModeActive then
91994: LD_EXP 76
91998: IFFALSE 92007
// DefineStreamItems ( true ) ;
92000: LD_INT 1
92002: PPUSH
92003: CALL 93811 0 1
// UpdateLuaVariables ( ) ;
92007: CALL 92024 0 0
// UpdateFactoryWaypoints ( ) ;
92011: CALL 106672 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92015: CALL 106929 0 0
// end ;
92019: LD_VAR 0 1
92023: RET
// export globalGameSaveCounter ; function UpdateLuaVariables ( ) ; begin
92024: LD_INT 0
92026: PPUSH
// if not globalGameSaveCounter then
92027: LD_EXP 75
92031: NOT
92032: IFFALSE 92043
// ToLua ( setGameSaveCounter(0) ) else
92034: LD_STRING setGameSaveCounter(0)
92036: PPUSH
92037: CALL_OW 559
92041: GO 92075
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92043: LD_ADDR_EXP 75
92047: PUSH
92048: LD_EXP 75
92052: PPUSH
92053: CALL 58713 0 1
92057: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92058: LD_STRING setGameSaveCounter(
92060: PUSH
92061: LD_EXP 75
92065: STR
92066: PUSH
92067: LD_STRING )
92069: STR
92070: PPUSH
92071: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92075: LD_STRING setGameDifficulty(
92077: PUSH
92078: LD_OWVAR 67
92082: STR
92083: PUSH
92084: LD_STRING )
92086: STR
92087: PPUSH
92088: CALL_OW 559
// end ;
92092: LD_VAR 0 1
92096: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92097: LD_INT 0
92099: PPUSH
// if p2 = stream_mode then
92100: LD_VAR 0 2
92104: PUSH
92105: LD_INT 100
92107: EQUAL
92108: IFFALSE 93111
// begin if not StreamModeActive then
92110: LD_EXP 76
92114: NOT
92115: IFFALSE 92125
// StreamModeActive := true ;
92117: LD_ADDR_EXP 76
92121: PUSH
92122: LD_INT 1
92124: ST_TO_ADDR
// if p3 = 0 then
92125: LD_VAR 0 3
92129: PUSH
92130: LD_INT 0
92132: EQUAL
92133: IFFALSE 92139
// InitStreamMode ;
92135: CALL 93347 0 0
// if p3 = 1 then
92139: LD_VAR 0 3
92143: PUSH
92144: LD_INT 1
92146: EQUAL
92147: IFFALSE 92157
// sRocket := true ;
92149: LD_ADDR_EXP 81
92153: PUSH
92154: LD_INT 1
92156: ST_TO_ADDR
// if p3 = 2 then
92157: LD_VAR 0 3
92161: PUSH
92162: LD_INT 2
92164: EQUAL
92165: IFFALSE 92175
// sSpeed := true ;
92167: LD_ADDR_EXP 80
92171: PUSH
92172: LD_INT 1
92174: ST_TO_ADDR
// if p3 = 3 then
92175: LD_VAR 0 3
92179: PUSH
92180: LD_INT 3
92182: EQUAL
92183: IFFALSE 92193
// sEngine := true ;
92185: LD_ADDR_EXP 82
92189: PUSH
92190: LD_INT 1
92192: ST_TO_ADDR
// if p3 = 4 then
92193: LD_VAR 0 3
92197: PUSH
92198: LD_INT 4
92200: EQUAL
92201: IFFALSE 92211
// sSpec := true ;
92203: LD_ADDR_EXP 79
92207: PUSH
92208: LD_INT 1
92210: ST_TO_ADDR
// if p3 = 5 then
92211: LD_VAR 0 3
92215: PUSH
92216: LD_INT 5
92218: EQUAL
92219: IFFALSE 92229
// sLevel := true ;
92221: LD_ADDR_EXP 83
92225: PUSH
92226: LD_INT 1
92228: ST_TO_ADDR
// if p3 = 6 then
92229: LD_VAR 0 3
92233: PUSH
92234: LD_INT 6
92236: EQUAL
92237: IFFALSE 92247
// sArmoury := true ;
92239: LD_ADDR_EXP 84
92243: PUSH
92244: LD_INT 1
92246: ST_TO_ADDR
// if p3 = 7 then
92247: LD_VAR 0 3
92251: PUSH
92252: LD_INT 7
92254: EQUAL
92255: IFFALSE 92265
// sRadar := true ;
92257: LD_ADDR_EXP 85
92261: PUSH
92262: LD_INT 1
92264: ST_TO_ADDR
// if p3 = 8 then
92265: LD_VAR 0 3
92269: PUSH
92270: LD_INT 8
92272: EQUAL
92273: IFFALSE 92283
// sBunker := true ;
92275: LD_ADDR_EXP 86
92279: PUSH
92280: LD_INT 1
92282: ST_TO_ADDR
// if p3 = 9 then
92283: LD_VAR 0 3
92287: PUSH
92288: LD_INT 9
92290: EQUAL
92291: IFFALSE 92301
// sHack := true ;
92293: LD_ADDR_EXP 87
92297: PUSH
92298: LD_INT 1
92300: ST_TO_ADDR
// if p3 = 10 then
92301: LD_VAR 0 3
92305: PUSH
92306: LD_INT 10
92308: EQUAL
92309: IFFALSE 92319
// sFire := true ;
92311: LD_ADDR_EXP 88
92315: PUSH
92316: LD_INT 1
92318: ST_TO_ADDR
// if p3 = 11 then
92319: LD_VAR 0 3
92323: PUSH
92324: LD_INT 11
92326: EQUAL
92327: IFFALSE 92337
// sRefresh := true ;
92329: LD_ADDR_EXP 89
92333: PUSH
92334: LD_INT 1
92336: ST_TO_ADDR
// if p3 = 12 then
92337: LD_VAR 0 3
92341: PUSH
92342: LD_INT 12
92344: EQUAL
92345: IFFALSE 92355
// sExp := true ;
92347: LD_ADDR_EXP 90
92351: PUSH
92352: LD_INT 1
92354: ST_TO_ADDR
// if p3 = 13 then
92355: LD_VAR 0 3
92359: PUSH
92360: LD_INT 13
92362: EQUAL
92363: IFFALSE 92373
// sDepot := true ;
92365: LD_ADDR_EXP 91
92369: PUSH
92370: LD_INT 1
92372: ST_TO_ADDR
// if p3 = 14 then
92373: LD_VAR 0 3
92377: PUSH
92378: LD_INT 14
92380: EQUAL
92381: IFFALSE 92391
// sFlag := true ;
92383: LD_ADDR_EXP 92
92387: PUSH
92388: LD_INT 1
92390: ST_TO_ADDR
// if p3 = 15 then
92391: LD_VAR 0 3
92395: PUSH
92396: LD_INT 15
92398: EQUAL
92399: IFFALSE 92409
// sKamikadze := true ;
92401: LD_ADDR_EXP 100
92405: PUSH
92406: LD_INT 1
92408: ST_TO_ADDR
// if p3 = 16 then
92409: LD_VAR 0 3
92413: PUSH
92414: LD_INT 16
92416: EQUAL
92417: IFFALSE 92427
// sTroll := true ;
92419: LD_ADDR_EXP 101
92423: PUSH
92424: LD_INT 1
92426: ST_TO_ADDR
// if p3 = 17 then
92427: LD_VAR 0 3
92431: PUSH
92432: LD_INT 17
92434: EQUAL
92435: IFFALSE 92445
// sSlow := true ;
92437: LD_ADDR_EXP 102
92441: PUSH
92442: LD_INT 1
92444: ST_TO_ADDR
// if p3 = 18 then
92445: LD_VAR 0 3
92449: PUSH
92450: LD_INT 18
92452: EQUAL
92453: IFFALSE 92463
// sLack := true ;
92455: LD_ADDR_EXP 103
92459: PUSH
92460: LD_INT 1
92462: ST_TO_ADDR
// if p3 = 19 then
92463: LD_VAR 0 3
92467: PUSH
92468: LD_INT 19
92470: EQUAL
92471: IFFALSE 92481
// sTank := true ;
92473: LD_ADDR_EXP 105
92477: PUSH
92478: LD_INT 1
92480: ST_TO_ADDR
// if p3 = 20 then
92481: LD_VAR 0 3
92485: PUSH
92486: LD_INT 20
92488: EQUAL
92489: IFFALSE 92499
// sRemote := true ;
92491: LD_ADDR_EXP 106
92495: PUSH
92496: LD_INT 1
92498: ST_TO_ADDR
// if p3 = 21 then
92499: LD_VAR 0 3
92503: PUSH
92504: LD_INT 21
92506: EQUAL
92507: IFFALSE 92517
// sPowell := true ;
92509: LD_ADDR_EXP 107
92513: PUSH
92514: LD_INT 1
92516: ST_TO_ADDR
// if p3 = 22 then
92517: LD_VAR 0 3
92521: PUSH
92522: LD_INT 22
92524: EQUAL
92525: IFFALSE 92535
// sTeleport := true ;
92527: LD_ADDR_EXP 110
92531: PUSH
92532: LD_INT 1
92534: ST_TO_ADDR
// if p3 = 23 then
92535: LD_VAR 0 3
92539: PUSH
92540: LD_INT 23
92542: EQUAL
92543: IFFALSE 92553
// sOilTower := true ;
92545: LD_ADDR_EXP 112
92549: PUSH
92550: LD_INT 1
92552: ST_TO_ADDR
// if p3 = 24 then
92553: LD_VAR 0 3
92557: PUSH
92558: LD_INT 24
92560: EQUAL
92561: IFFALSE 92571
// sShovel := true ;
92563: LD_ADDR_EXP 113
92567: PUSH
92568: LD_INT 1
92570: ST_TO_ADDR
// if p3 = 25 then
92571: LD_VAR 0 3
92575: PUSH
92576: LD_INT 25
92578: EQUAL
92579: IFFALSE 92589
// sSheik := true ;
92581: LD_ADDR_EXP 114
92585: PUSH
92586: LD_INT 1
92588: ST_TO_ADDR
// if p3 = 26 then
92589: LD_VAR 0 3
92593: PUSH
92594: LD_INT 26
92596: EQUAL
92597: IFFALSE 92607
// sEarthquake := true ;
92599: LD_ADDR_EXP 116
92603: PUSH
92604: LD_INT 1
92606: ST_TO_ADDR
// if p3 = 27 then
92607: LD_VAR 0 3
92611: PUSH
92612: LD_INT 27
92614: EQUAL
92615: IFFALSE 92625
// sAI := true ;
92617: LD_ADDR_EXP 117
92621: PUSH
92622: LD_INT 1
92624: ST_TO_ADDR
// if p3 = 28 then
92625: LD_VAR 0 3
92629: PUSH
92630: LD_INT 28
92632: EQUAL
92633: IFFALSE 92643
// sCargo := true ;
92635: LD_ADDR_EXP 120
92639: PUSH
92640: LD_INT 1
92642: ST_TO_ADDR
// if p3 = 29 then
92643: LD_VAR 0 3
92647: PUSH
92648: LD_INT 29
92650: EQUAL
92651: IFFALSE 92661
// sDLaser := true ;
92653: LD_ADDR_EXP 121
92657: PUSH
92658: LD_INT 1
92660: ST_TO_ADDR
// if p3 = 30 then
92661: LD_VAR 0 3
92665: PUSH
92666: LD_INT 30
92668: EQUAL
92669: IFFALSE 92679
// sExchange := true ;
92671: LD_ADDR_EXP 122
92675: PUSH
92676: LD_INT 1
92678: ST_TO_ADDR
// if p3 = 31 then
92679: LD_VAR 0 3
92683: PUSH
92684: LD_INT 31
92686: EQUAL
92687: IFFALSE 92697
// sFac := true ;
92689: LD_ADDR_EXP 123
92693: PUSH
92694: LD_INT 1
92696: ST_TO_ADDR
// if p3 = 32 then
92697: LD_VAR 0 3
92701: PUSH
92702: LD_INT 32
92704: EQUAL
92705: IFFALSE 92715
// sPower := true ;
92707: LD_ADDR_EXP 124
92711: PUSH
92712: LD_INT 1
92714: ST_TO_ADDR
// if p3 = 33 then
92715: LD_VAR 0 3
92719: PUSH
92720: LD_INT 33
92722: EQUAL
92723: IFFALSE 92733
// sRandom := true ;
92725: LD_ADDR_EXP 125
92729: PUSH
92730: LD_INT 1
92732: ST_TO_ADDR
// if p3 = 34 then
92733: LD_VAR 0 3
92737: PUSH
92738: LD_INT 34
92740: EQUAL
92741: IFFALSE 92751
// sShield := true ;
92743: LD_ADDR_EXP 126
92747: PUSH
92748: LD_INT 1
92750: ST_TO_ADDR
// if p3 = 35 then
92751: LD_VAR 0 3
92755: PUSH
92756: LD_INT 35
92758: EQUAL
92759: IFFALSE 92769
// sTime := true ;
92761: LD_ADDR_EXP 127
92765: PUSH
92766: LD_INT 1
92768: ST_TO_ADDR
// if p3 = 36 then
92769: LD_VAR 0 3
92773: PUSH
92774: LD_INT 36
92776: EQUAL
92777: IFFALSE 92787
// sTools := true ;
92779: LD_ADDR_EXP 128
92783: PUSH
92784: LD_INT 1
92786: ST_TO_ADDR
// if p3 = 101 then
92787: LD_VAR 0 3
92791: PUSH
92792: LD_INT 101
92794: EQUAL
92795: IFFALSE 92805
// sSold := true ;
92797: LD_ADDR_EXP 93
92801: PUSH
92802: LD_INT 1
92804: ST_TO_ADDR
// if p3 = 102 then
92805: LD_VAR 0 3
92809: PUSH
92810: LD_INT 102
92812: EQUAL
92813: IFFALSE 92823
// sDiff := true ;
92815: LD_ADDR_EXP 94
92819: PUSH
92820: LD_INT 1
92822: ST_TO_ADDR
// if p3 = 103 then
92823: LD_VAR 0 3
92827: PUSH
92828: LD_INT 103
92830: EQUAL
92831: IFFALSE 92841
// sFog := true ;
92833: LD_ADDR_EXP 97
92837: PUSH
92838: LD_INT 1
92840: ST_TO_ADDR
// if p3 = 104 then
92841: LD_VAR 0 3
92845: PUSH
92846: LD_INT 104
92848: EQUAL
92849: IFFALSE 92859
// sReset := true ;
92851: LD_ADDR_EXP 98
92855: PUSH
92856: LD_INT 1
92858: ST_TO_ADDR
// if p3 = 105 then
92859: LD_VAR 0 3
92863: PUSH
92864: LD_INT 105
92866: EQUAL
92867: IFFALSE 92877
// sSun := true ;
92869: LD_ADDR_EXP 99
92873: PUSH
92874: LD_INT 1
92876: ST_TO_ADDR
// if p3 = 106 then
92877: LD_VAR 0 3
92881: PUSH
92882: LD_INT 106
92884: EQUAL
92885: IFFALSE 92895
// sTiger := true ;
92887: LD_ADDR_EXP 95
92891: PUSH
92892: LD_INT 1
92894: ST_TO_ADDR
// if p3 = 107 then
92895: LD_VAR 0 3
92899: PUSH
92900: LD_INT 107
92902: EQUAL
92903: IFFALSE 92913
// sBomb := true ;
92905: LD_ADDR_EXP 96
92909: PUSH
92910: LD_INT 1
92912: ST_TO_ADDR
// if p3 = 108 then
92913: LD_VAR 0 3
92917: PUSH
92918: LD_INT 108
92920: EQUAL
92921: IFFALSE 92931
// sWound := true ;
92923: LD_ADDR_EXP 104
92927: PUSH
92928: LD_INT 1
92930: ST_TO_ADDR
// if p3 = 109 then
92931: LD_VAR 0 3
92935: PUSH
92936: LD_INT 109
92938: EQUAL
92939: IFFALSE 92949
// sBetray := true ;
92941: LD_ADDR_EXP 108
92945: PUSH
92946: LD_INT 1
92948: ST_TO_ADDR
// if p3 = 110 then
92949: LD_VAR 0 3
92953: PUSH
92954: LD_INT 110
92956: EQUAL
92957: IFFALSE 92967
// sContamin := true ;
92959: LD_ADDR_EXP 109
92963: PUSH
92964: LD_INT 1
92966: ST_TO_ADDR
// if p3 = 111 then
92967: LD_VAR 0 3
92971: PUSH
92972: LD_INT 111
92974: EQUAL
92975: IFFALSE 92985
// sOil := true ;
92977: LD_ADDR_EXP 111
92981: PUSH
92982: LD_INT 1
92984: ST_TO_ADDR
// if p3 = 112 then
92985: LD_VAR 0 3
92989: PUSH
92990: LD_INT 112
92992: EQUAL
92993: IFFALSE 93003
// sStu := true ;
92995: LD_ADDR_EXP 115
92999: PUSH
93000: LD_INT 1
93002: ST_TO_ADDR
// if p3 = 113 then
93003: LD_VAR 0 3
93007: PUSH
93008: LD_INT 113
93010: EQUAL
93011: IFFALSE 93021
// sBazooka := true ;
93013: LD_ADDR_EXP 118
93017: PUSH
93018: LD_INT 1
93020: ST_TO_ADDR
// if p3 = 114 then
93021: LD_VAR 0 3
93025: PUSH
93026: LD_INT 114
93028: EQUAL
93029: IFFALSE 93039
// sMortar := true ;
93031: LD_ADDR_EXP 119
93035: PUSH
93036: LD_INT 1
93038: ST_TO_ADDR
// if p3 = 115 then
93039: LD_VAR 0 3
93043: PUSH
93044: LD_INT 115
93046: EQUAL
93047: IFFALSE 93057
// sRanger := true ;
93049: LD_ADDR_EXP 129
93053: PUSH
93054: LD_INT 1
93056: ST_TO_ADDR
// if p3 = 116 then
93057: LD_VAR 0 3
93061: PUSH
93062: LD_INT 116
93064: EQUAL
93065: IFFALSE 93075
// sComputer := true ;
93067: LD_ADDR_EXP 130
93071: PUSH
93072: LD_INT 1
93074: ST_TO_ADDR
// if p3 = 117 then
93075: LD_VAR 0 3
93079: PUSH
93080: LD_INT 117
93082: EQUAL
93083: IFFALSE 93093
// s30 := true ;
93085: LD_ADDR_EXP 131
93089: PUSH
93090: LD_INT 1
93092: ST_TO_ADDR
// if p3 = 118 then
93093: LD_VAR 0 3
93097: PUSH
93098: LD_INT 118
93100: EQUAL
93101: IFFALSE 93111
// s60 := true ;
93103: LD_ADDR_EXP 132
93107: PUSH
93108: LD_INT 1
93110: ST_TO_ADDR
// end ; if p2 = hack_mode then
93111: LD_VAR 0 2
93115: PUSH
93116: LD_INT 101
93118: EQUAL
93119: IFFALSE 93247
// begin case p3 of 1 :
93121: LD_VAR 0 3
93125: PUSH
93126: LD_INT 1
93128: DOUBLE
93129: EQUAL
93130: IFTRUE 93134
93132: GO 93141
93134: POP
// hHackUnlimitedResources ; 2 :
93135: CALL 105418 0 0
93139: GO 93247
93141: LD_INT 2
93143: DOUBLE
93144: EQUAL
93145: IFTRUE 93149
93147: GO 93156
93149: POP
// hHackSetLevel10 ; 3 :
93150: CALL 105551 0 0
93154: GO 93247
93156: LD_INT 3
93158: DOUBLE
93159: EQUAL
93160: IFTRUE 93164
93162: GO 93171
93164: POP
// hHackSetLevel10YourUnits ; 4 :
93165: CALL 105636 0 0
93169: GO 93247
93171: LD_INT 4
93173: DOUBLE
93174: EQUAL
93175: IFTRUE 93179
93177: GO 93186
93179: POP
// hHackInvincible ; 5 :
93180: CALL 106084 0 0
93184: GO 93247
93186: LD_INT 5
93188: DOUBLE
93189: EQUAL
93190: IFTRUE 93194
93192: GO 93201
93194: POP
// hHackInvisible ; 6 :
93195: CALL 106195 0 0
93199: GO 93247
93201: LD_INT 6
93203: DOUBLE
93204: EQUAL
93205: IFTRUE 93209
93207: GO 93216
93209: POP
// hHackChangeYourSide ; 7 :
93210: CALL 106252 0 0
93214: GO 93247
93216: LD_INT 7
93218: DOUBLE
93219: EQUAL
93220: IFTRUE 93224
93222: GO 93231
93224: POP
// hHackChangeUnitSide ; 8 :
93225: CALL 106294 0 0
93229: GO 93247
93231: LD_INT 8
93233: DOUBLE
93234: EQUAL
93235: IFTRUE 93239
93237: GO 93246
93239: POP
// hHackFog ; end ;
93240: CALL 106395 0 0
93244: GO 93247
93246: POP
// end ; if p2 = game_save_mode then
93247: LD_VAR 0 2
93251: PUSH
93252: LD_INT 102
93254: EQUAL
93255: IFFALSE 93320
// begin if p3 = 1 then
93257: LD_VAR 0 3
93261: PUSH
93262: LD_INT 1
93264: EQUAL
93265: IFFALSE 93277
// globalGameSaveCounter := p4 ;
93267: LD_ADDR_EXP 75
93271: PUSH
93272: LD_VAR 0 4
93276: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93277: LD_VAR 0 3
93281: PUSH
93282: LD_INT 2
93284: EQUAL
93285: PUSH
93286: LD_EXP 75
93290: AND
93291: IFFALSE 93310
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93293: LD_STRING setGameSaveCounter(
93295: PUSH
93296: LD_EXP 75
93300: STR
93301: PUSH
93302: LD_STRING )
93304: STR
93305: PPUSH
93306: CALL_OW 559
// display_strings := globalGameSaveCounter ;
93310: LD_ADDR_OWVAR 47
93314: PUSH
93315: LD_EXP 75
93319: ST_TO_ADDR
// end ; end ;
93320: LD_VAR 0 7
93324: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
93325: GO 93327
93327: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93328: LD_STRING initStreamRollete();
93330: PPUSH
93331: CALL_OW 559
// InitStreamMode ;
93335: CALL 93347 0 0
// DefineStreamItems ( false ) ;
93339: LD_INT 0
93341: PPUSH
93342: CALL 93811 0 1
// end ;
93346: END
// function InitStreamMode ; begin
93347: LD_INT 0
93349: PPUSH
// streamModeActive := false ;
93350: LD_ADDR_EXP 76
93354: PUSH
93355: LD_INT 0
93357: ST_TO_ADDR
// normalCounter := 36 ;
93358: LD_ADDR_EXP 77
93362: PUSH
93363: LD_INT 36
93365: ST_TO_ADDR
// hardcoreCounter := 18 ;
93366: LD_ADDR_EXP 78
93370: PUSH
93371: LD_INT 18
93373: ST_TO_ADDR
// sRocket := false ;
93374: LD_ADDR_EXP 81
93378: PUSH
93379: LD_INT 0
93381: ST_TO_ADDR
// sSpeed := false ;
93382: LD_ADDR_EXP 80
93386: PUSH
93387: LD_INT 0
93389: ST_TO_ADDR
// sEngine := false ;
93390: LD_ADDR_EXP 82
93394: PUSH
93395: LD_INT 0
93397: ST_TO_ADDR
// sSpec := false ;
93398: LD_ADDR_EXP 79
93402: PUSH
93403: LD_INT 0
93405: ST_TO_ADDR
// sLevel := false ;
93406: LD_ADDR_EXP 83
93410: PUSH
93411: LD_INT 0
93413: ST_TO_ADDR
// sArmoury := false ;
93414: LD_ADDR_EXP 84
93418: PUSH
93419: LD_INT 0
93421: ST_TO_ADDR
// sRadar := false ;
93422: LD_ADDR_EXP 85
93426: PUSH
93427: LD_INT 0
93429: ST_TO_ADDR
// sBunker := false ;
93430: LD_ADDR_EXP 86
93434: PUSH
93435: LD_INT 0
93437: ST_TO_ADDR
// sHack := false ;
93438: LD_ADDR_EXP 87
93442: PUSH
93443: LD_INT 0
93445: ST_TO_ADDR
// sFire := false ;
93446: LD_ADDR_EXP 88
93450: PUSH
93451: LD_INT 0
93453: ST_TO_ADDR
// sRefresh := false ;
93454: LD_ADDR_EXP 89
93458: PUSH
93459: LD_INT 0
93461: ST_TO_ADDR
// sExp := false ;
93462: LD_ADDR_EXP 90
93466: PUSH
93467: LD_INT 0
93469: ST_TO_ADDR
// sDepot := false ;
93470: LD_ADDR_EXP 91
93474: PUSH
93475: LD_INT 0
93477: ST_TO_ADDR
// sFlag := false ;
93478: LD_ADDR_EXP 92
93482: PUSH
93483: LD_INT 0
93485: ST_TO_ADDR
// sKamikadze := false ;
93486: LD_ADDR_EXP 100
93490: PUSH
93491: LD_INT 0
93493: ST_TO_ADDR
// sTroll := false ;
93494: LD_ADDR_EXP 101
93498: PUSH
93499: LD_INT 0
93501: ST_TO_ADDR
// sSlow := false ;
93502: LD_ADDR_EXP 102
93506: PUSH
93507: LD_INT 0
93509: ST_TO_ADDR
// sLack := false ;
93510: LD_ADDR_EXP 103
93514: PUSH
93515: LD_INT 0
93517: ST_TO_ADDR
// sTank := false ;
93518: LD_ADDR_EXP 105
93522: PUSH
93523: LD_INT 0
93525: ST_TO_ADDR
// sRemote := false ;
93526: LD_ADDR_EXP 106
93530: PUSH
93531: LD_INT 0
93533: ST_TO_ADDR
// sPowell := false ;
93534: LD_ADDR_EXP 107
93538: PUSH
93539: LD_INT 0
93541: ST_TO_ADDR
// sTeleport := false ;
93542: LD_ADDR_EXP 110
93546: PUSH
93547: LD_INT 0
93549: ST_TO_ADDR
// sOilTower := false ;
93550: LD_ADDR_EXP 112
93554: PUSH
93555: LD_INT 0
93557: ST_TO_ADDR
// sShovel := false ;
93558: LD_ADDR_EXP 113
93562: PUSH
93563: LD_INT 0
93565: ST_TO_ADDR
// sSheik := false ;
93566: LD_ADDR_EXP 114
93570: PUSH
93571: LD_INT 0
93573: ST_TO_ADDR
// sEarthquake := false ;
93574: LD_ADDR_EXP 116
93578: PUSH
93579: LD_INT 0
93581: ST_TO_ADDR
// sAI := false ;
93582: LD_ADDR_EXP 117
93586: PUSH
93587: LD_INT 0
93589: ST_TO_ADDR
// sCargo := false ;
93590: LD_ADDR_EXP 120
93594: PUSH
93595: LD_INT 0
93597: ST_TO_ADDR
// sDLaser := false ;
93598: LD_ADDR_EXP 121
93602: PUSH
93603: LD_INT 0
93605: ST_TO_ADDR
// sExchange := false ;
93606: LD_ADDR_EXP 122
93610: PUSH
93611: LD_INT 0
93613: ST_TO_ADDR
// sFac := false ;
93614: LD_ADDR_EXP 123
93618: PUSH
93619: LD_INT 0
93621: ST_TO_ADDR
// sPower := false ;
93622: LD_ADDR_EXP 124
93626: PUSH
93627: LD_INT 0
93629: ST_TO_ADDR
// sRandom := false ;
93630: LD_ADDR_EXP 125
93634: PUSH
93635: LD_INT 0
93637: ST_TO_ADDR
// sShield := false ;
93638: LD_ADDR_EXP 126
93642: PUSH
93643: LD_INT 0
93645: ST_TO_ADDR
// sTime := false ;
93646: LD_ADDR_EXP 127
93650: PUSH
93651: LD_INT 0
93653: ST_TO_ADDR
// sTools := false ;
93654: LD_ADDR_EXP 128
93658: PUSH
93659: LD_INT 0
93661: ST_TO_ADDR
// sSold := false ;
93662: LD_ADDR_EXP 93
93666: PUSH
93667: LD_INT 0
93669: ST_TO_ADDR
// sDiff := false ;
93670: LD_ADDR_EXP 94
93674: PUSH
93675: LD_INT 0
93677: ST_TO_ADDR
// sFog := false ;
93678: LD_ADDR_EXP 97
93682: PUSH
93683: LD_INT 0
93685: ST_TO_ADDR
// sReset := false ;
93686: LD_ADDR_EXP 98
93690: PUSH
93691: LD_INT 0
93693: ST_TO_ADDR
// sSun := false ;
93694: LD_ADDR_EXP 99
93698: PUSH
93699: LD_INT 0
93701: ST_TO_ADDR
// sTiger := false ;
93702: LD_ADDR_EXP 95
93706: PUSH
93707: LD_INT 0
93709: ST_TO_ADDR
// sBomb := false ;
93710: LD_ADDR_EXP 96
93714: PUSH
93715: LD_INT 0
93717: ST_TO_ADDR
// sWound := false ;
93718: LD_ADDR_EXP 104
93722: PUSH
93723: LD_INT 0
93725: ST_TO_ADDR
// sBetray := false ;
93726: LD_ADDR_EXP 108
93730: PUSH
93731: LD_INT 0
93733: ST_TO_ADDR
// sContamin := false ;
93734: LD_ADDR_EXP 109
93738: PUSH
93739: LD_INT 0
93741: ST_TO_ADDR
// sOil := false ;
93742: LD_ADDR_EXP 111
93746: PUSH
93747: LD_INT 0
93749: ST_TO_ADDR
// sStu := false ;
93750: LD_ADDR_EXP 115
93754: PUSH
93755: LD_INT 0
93757: ST_TO_ADDR
// sBazooka := false ;
93758: LD_ADDR_EXP 118
93762: PUSH
93763: LD_INT 0
93765: ST_TO_ADDR
// sMortar := false ;
93766: LD_ADDR_EXP 119
93770: PUSH
93771: LD_INT 0
93773: ST_TO_ADDR
// sRanger := false ;
93774: LD_ADDR_EXP 129
93778: PUSH
93779: LD_INT 0
93781: ST_TO_ADDR
// sComputer := false ;
93782: LD_ADDR_EXP 130
93786: PUSH
93787: LD_INT 0
93789: ST_TO_ADDR
// s30 := false ;
93790: LD_ADDR_EXP 131
93794: PUSH
93795: LD_INT 0
93797: ST_TO_ADDR
// s60 := false ;
93798: LD_ADDR_EXP 132
93802: PUSH
93803: LD_INT 0
93805: ST_TO_ADDR
// end ;
93806: LD_VAR 0 1
93810: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93811: LD_INT 0
93813: PPUSH
93814: PPUSH
93815: PPUSH
93816: PPUSH
93817: PPUSH
93818: PPUSH
93819: PPUSH
// result := [ ] ;
93820: LD_ADDR_VAR 0 2
93824: PUSH
93825: EMPTY
93826: ST_TO_ADDR
// if campaign_id = 1 then
93827: LD_OWVAR 69
93831: PUSH
93832: LD_INT 1
93834: EQUAL
93835: IFFALSE 97001
// begin case mission_number of 1 :
93837: LD_OWVAR 70
93841: PUSH
93842: LD_INT 1
93844: DOUBLE
93845: EQUAL
93846: IFTRUE 93850
93848: GO 93926
93850: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93851: LD_ADDR_VAR 0 2
93855: PUSH
93856: LD_INT 2
93858: PUSH
93859: LD_INT 4
93861: PUSH
93862: LD_INT 11
93864: PUSH
93865: LD_INT 12
93867: PUSH
93868: LD_INT 15
93870: PUSH
93871: LD_INT 16
93873: PUSH
93874: LD_INT 22
93876: PUSH
93877: LD_INT 23
93879: PUSH
93880: LD_INT 26
93882: PUSH
93883: EMPTY
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: PUSH
93894: LD_INT 101
93896: PUSH
93897: LD_INT 102
93899: PUSH
93900: LD_INT 106
93902: PUSH
93903: LD_INT 116
93905: PUSH
93906: LD_INT 117
93908: PUSH
93909: LD_INT 118
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: PUSH
93920: EMPTY
93921: LIST
93922: LIST
93923: ST_TO_ADDR
93924: GO 96999
93926: LD_INT 2
93928: DOUBLE
93929: EQUAL
93930: IFTRUE 93934
93932: GO 94018
93934: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93935: LD_ADDR_VAR 0 2
93939: PUSH
93940: LD_INT 2
93942: PUSH
93943: LD_INT 4
93945: PUSH
93946: LD_INT 11
93948: PUSH
93949: LD_INT 12
93951: PUSH
93952: LD_INT 15
93954: PUSH
93955: LD_INT 16
93957: PUSH
93958: LD_INT 22
93960: PUSH
93961: LD_INT 23
93963: PUSH
93964: LD_INT 26
93966: PUSH
93967: EMPTY
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: PUSH
93978: LD_INT 101
93980: PUSH
93981: LD_INT 102
93983: PUSH
93984: LD_INT 105
93986: PUSH
93987: LD_INT 106
93989: PUSH
93990: LD_INT 108
93992: PUSH
93993: LD_INT 116
93995: PUSH
93996: LD_INT 117
93998: PUSH
93999: LD_INT 118
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: ST_TO_ADDR
94016: GO 96999
94018: LD_INT 3
94020: DOUBLE
94021: EQUAL
94022: IFTRUE 94026
94024: GO 94114
94026: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94027: LD_ADDR_VAR 0 2
94031: PUSH
94032: LD_INT 2
94034: PUSH
94035: LD_INT 4
94037: PUSH
94038: LD_INT 5
94040: PUSH
94041: LD_INT 11
94043: PUSH
94044: LD_INT 12
94046: PUSH
94047: LD_INT 15
94049: PUSH
94050: LD_INT 16
94052: PUSH
94053: LD_INT 22
94055: PUSH
94056: LD_INT 26
94058: PUSH
94059: LD_INT 36
94061: PUSH
94062: EMPTY
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 101
94076: PUSH
94077: LD_INT 102
94079: PUSH
94080: LD_INT 105
94082: PUSH
94083: LD_INT 106
94085: PUSH
94086: LD_INT 108
94088: PUSH
94089: LD_INT 116
94091: PUSH
94092: LD_INT 117
94094: PUSH
94095: LD_INT 118
94097: PUSH
94098: EMPTY
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: ST_TO_ADDR
94112: GO 96999
94114: LD_INT 4
94116: DOUBLE
94117: EQUAL
94118: IFTRUE 94122
94120: GO 94218
94122: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94123: LD_ADDR_VAR 0 2
94127: PUSH
94128: LD_INT 2
94130: PUSH
94131: LD_INT 4
94133: PUSH
94134: LD_INT 5
94136: PUSH
94137: LD_INT 8
94139: PUSH
94140: LD_INT 11
94142: PUSH
94143: LD_INT 12
94145: PUSH
94146: LD_INT 15
94148: PUSH
94149: LD_INT 16
94151: PUSH
94152: LD_INT 22
94154: PUSH
94155: LD_INT 23
94157: PUSH
94158: LD_INT 26
94160: PUSH
94161: LD_INT 36
94163: PUSH
94164: EMPTY
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: PUSH
94178: LD_INT 101
94180: PUSH
94181: LD_INT 102
94183: PUSH
94184: LD_INT 105
94186: PUSH
94187: LD_INT 106
94189: PUSH
94190: LD_INT 108
94192: PUSH
94193: LD_INT 116
94195: PUSH
94196: LD_INT 117
94198: PUSH
94199: LD_INT 118
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: ST_TO_ADDR
94216: GO 96999
94218: LD_INT 5
94220: DOUBLE
94221: EQUAL
94222: IFTRUE 94226
94224: GO 94338
94226: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94227: LD_ADDR_VAR 0 2
94231: PUSH
94232: LD_INT 2
94234: PUSH
94235: LD_INT 4
94237: PUSH
94238: LD_INT 5
94240: PUSH
94241: LD_INT 6
94243: PUSH
94244: LD_INT 8
94246: PUSH
94247: LD_INT 11
94249: PUSH
94250: LD_INT 12
94252: PUSH
94253: LD_INT 15
94255: PUSH
94256: LD_INT 16
94258: PUSH
94259: LD_INT 22
94261: PUSH
94262: LD_INT 23
94264: PUSH
94265: LD_INT 25
94267: PUSH
94268: LD_INT 26
94270: PUSH
94271: LD_INT 36
94273: PUSH
94274: EMPTY
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: PUSH
94290: LD_INT 101
94292: PUSH
94293: LD_INT 102
94295: PUSH
94296: LD_INT 105
94298: PUSH
94299: LD_INT 106
94301: PUSH
94302: LD_INT 108
94304: PUSH
94305: LD_INT 109
94307: PUSH
94308: LD_INT 112
94310: PUSH
94311: LD_INT 116
94313: PUSH
94314: LD_INT 117
94316: PUSH
94317: LD_INT 118
94319: PUSH
94320: EMPTY
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: PUSH
94332: EMPTY
94333: LIST
94334: LIST
94335: ST_TO_ADDR
94336: GO 96999
94338: LD_INT 6
94340: DOUBLE
94341: EQUAL
94342: IFTRUE 94346
94344: GO 94478
94346: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94347: LD_ADDR_VAR 0 2
94351: PUSH
94352: LD_INT 2
94354: PUSH
94355: LD_INT 4
94357: PUSH
94358: LD_INT 5
94360: PUSH
94361: LD_INT 6
94363: PUSH
94364: LD_INT 8
94366: PUSH
94367: LD_INT 11
94369: PUSH
94370: LD_INT 12
94372: PUSH
94373: LD_INT 15
94375: PUSH
94376: LD_INT 16
94378: PUSH
94379: LD_INT 20
94381: PUSH
94382: LD_INT 21
94384: PUSH
94385: LD_INT 22
94387: PUSH
94388: LD_INT 23
94390: PUSH
94391: LD_INT 25
94393: PUSH
94394: LD_INT 26
94396: PUSH
94397: LD_INT 30
94399: PUSH
94400: LD_INT 31
94402: PUSH
94403: LD_INT 32
94405: PUSH
94406: LD_INT 36
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: PUSH
94430: LD_INT 101
94432: PUSH
94433: LD_INT 102
94435: PUSH
94436: LD_INT 105
94438: PUSH
94439: LD_INT 106
94441: PUSH
94442: LD_INT 108
94444: PUSH
94445: LD_INT 109
94447: PUSH
94448: LD_INT 112
94450: PUSH
94451: LD_INT 116
94453: PUSH
94454: LD_INT 117
94456: PUSH
94457: LD_INT 118
94459: PUSH
94460: EMPTY
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: ST_TO_ADDR
94476: GO 96999
94478: LD_INT 7
94480: DOUBLE
94481: EQUAL
94482: IFTRUE 94486
94484: GO 94598
94486: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94487: LD_ADDR_VAR 0 2
94491: PUSH
94492: LD_INT 2
94494: PUSH
94495: LD_INT 4
94497: PUSH
94498: LD_INT 5
94500: PUSH
94501: LD_INT 7
94503: PUSH
94504: LD_INT 11
94506: PUSH
94507: LD_INT 12
94509: PUSH
94510: LD_INT 15
94512: PUSH
94513: LD_INT 16
94515: PUSH
94516: LD_INT 20
94518: PUSH
94519: LD_INT 21
94521: PUSH
94522: LD_INT 22
94524: PUSH
94525: LD_INT 23
94527: PUSH
94528: LD_INT 25
94530: PUSH
94531: LD_INT 26
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: PUSH
94550: LD_INT 101
94552: PUSH
94553: LD_INT 102
94555: PUSH
94556: LD_INT 103
94558: PUSH
94559: LD_INT 105
94561: PUSH
94562: LD_INT 106
94564: PUSH
94565: LD_INT 108
94567: PUSH
94568: LD_INT 112
94570: PUSH
94571: LD_INT 116
94573: PUSH
94574: LD_INT 117
94576: PUSH
94577: LD_INT 118
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: ST_TO_ADDR
94596: GO 96999
94598: LD_INT 8
94600: DOUBLE
94601: EQUAL
94602: IFTRUE 94606
94604: GO 94746
94606: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94607: LD_ADDR_VAR 0 2
94611: PUSH
94612: LD_INT 2
94614: PUSH
94615: LD_INT 4
94617: PUSH
94618: LD_INT 5
94620: PUSH
94621: LD_INT 6
94623: PUSH
94624: LD_INT 7
94626: PUSH
94627: LD_INT 8
94629: PUSH
94630: LD_INT 11
94632: PUSH
94633: LD_INT 12
94635: PUSH
94636: LD_INT 15
94638: PUSH
94639: LD_INT 16
94641: PUSH
94642: LD_INT 20
94644: PUSH
94645: LD_INT 21
94647: PUSH
94648: LD_INT 22
94650: PUSH
94651: LD_INT 23
94653: PUSH
94654: LD_INT 25
94656: PUSH
94657: LD_INT 26
94659: PUSH
94660: LD_INT 30
94662: PUSH
94663: LD_INT 31
94665: PUSH
94666: LD_INT 32
94668: PUSH
94669: LD_INT 36
94671: PUSH
94672: EMPTY
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: PUSH
94694: LD_INT 101
94696: PUSH
94697: LD_INT 102
94699: PUSH
94700: LD_INT 103
94702: PUSH
94703: LD_INT 105
94705: PUSH
94706: LD_INT 106
94708: PUSH
94709: LD_INT 108
94711: PUSH
94712: LD_INT 109
94714: PUSH
94715: LD_INT 112
94717: PUSH
94718: LD_INT 116
94720: PUSH
94721: LD_INT 117
94723: PUSH
94724: LD_INT 118
94726: PUSH
94727: EMPTY
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: LIST
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: ST_TO_ADDR
94744: GO 96999
94746: LD_INT 9
94748: DOUBLE
94749: EQUAL
94750: IFTRUE 94754
94752: GO 94902
94754: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94755: LD_ADDR_VAR 0 2
94759: PUSH
94760: LD_INT 2
94762: PUSH
94763: LD_INT 4
94765: PUSH
94766: LD_INT 5
94768: PUSH
94769: LD_INT 6
94771: PUSH
94772: LD_INT 7
94774: PUSH
94775: LD_INT 8
94777: PUSH
94778: LD_INT 11
94780: PUSH
94781: LD_INT 12
94783: PUSH
94784: LD_INT 15
94786: PUSH
94787: LD_INT 16
94789: PUSH
94790: LD_INT 20
94792: PUSH
94793: LD_INT 21
94795: PUSH
94796: LD_INT 22
94798: PUSH
94799: LD_INT 23
94801: PUSH
94802: LD_INT 25
94804: PUSH
94805: LD_INT 26
94807: PUSH
94808: LD_INT 28
94810: PUSH
94811: LD_INT 30
94813: PUSH
94814: LD_INT 31
94816: PUSH
94817: LD_INT 32
94819: PUSH
94820: LD_INT 36
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: PUSH
94846: LD_INT 101
94848: PUSH
94849: LD_INT 102
94851: PUSH
94852: LD_INT 103
94854: PUSH
94855: LD_INT 105
94857: PUSH
94858: LD_INT 106
94860: PUSH
94861: LD_INT 108
94863: PUSH
94864: LD_INT 109
94866: PUSH
94867: LD_INT 112
94869: PUSH
94870: LD_INT 114
94872: PUSH
94873: LD_INT 116
94875: PUSH
94876: LD_INT 117
94878: PUSH
94879: LD_INT 118
94881: PUSH
94882: EMPTY
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: ST_TO_ADDR
94900: GO 96999
94902: LD_INT 10
94904: DOUBLE
94905: EQUAL
94906: IFTRUE 94910
94908: GO 95106
94910: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94911: LD_ADDR_VAR 0 2
94915: PUSH
94916: LD_INT 2
94918: PUSH
94919: LD_INT 4
94921: PUSH
94922: LD_INT 5
94924: PUSH
94925: LD_INT 6
94927: PUSH
94928: LD_INT 7
94930: PUSH
94931: LD_INT 8
94933: PUSH
94934: LD_INT 9
94936: PUSH
94937: LD_INT 10
94939: PUSH
94940: LD_INT 11
94942: PUSH
94943: LD_INT 12
94945: PUSH
94946: LD_INT 13
94948: PUSH
94949: LD_INT 14
94951: PUSH
94952: LD_INT 15
94954: PUSH
94955: LD_INT 16
94957: PUSH
94958: LD_INT 17
94960: PUSH
94961: LD_INT 18
94963: PUSH
94964: LD_INT 19
94966: PUSH
94967: LD_INT 20
94969: PUSH
94970: LD_INT 21
94972: PUSH
94973: LD_INT 22
94975: PUSH
94976: LD_INT 23
94978: PUSH
94979: LD_INT 24
94981: PUSH
94982: LD_INT 25
94984: PUSH
94985: LD_INT 26
94987: PUSH
94988: LD_INT 28
94990: PUSH
94991: LD_INT 30
94993: PUSH
94994: LD_INT 31
94996: PUSH
94997: LD_INT 32
94999: PUSH
95000: LD_INT 36
95002: PUSH
95003: EMPTY
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: PUSH
95034: LD_INT 101
95036: PUSH
95037: LD_INT 102
95039: PUSH
95040: LD_INT 103
95042: PUSH
95043: LD_INT 104
95045: PUSH
95046: LD_INT 105
95048: PUSH
95049: LD_INT 106
95051: PUSH
95052: LD_INT 107
95054: PUSH
95055: LD_INT 108
95057: PUSH
95058: LD_INT 109
95060: PUSH
95061: LD_INT 110
95063: PUSH
95064: LD_INT 111
95066: PUSH
95067: LD_INT 112
95069: PUSH
95070: LD_INT 114
95072: PUSH
95073: LD_INT 116
95075: PUSH
95076: LD_INT 117
95078: PUSH
95079: LD_INT 118
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: PUSH
95100: EMPTY
95101: LIST
95102: LIST
95103: ST_TO_ADDR
95104: GO 96999
95106: LD_INT 11
95108: DOUBLE
95109: EQUAL
95110: IFTRUE 95114
95112: GO 95318
95114: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95115: LD_ADDR_VAR 0 2
95119: PUSH
95120: LD_INT 2
95122: PUSH
95123: LD_INT 3
95125: PUSH
95126: LD_INT 4
95128: PUSH
95129: LD_INT 5
95131: PUSH
95132: LD_INT 6
95134: PUSH
95135: LD_INT 7
95137: PUSH
95138: LD_INT 8
95140: PUSH
95141: LD_INT 9
95143: PUSH
95144: LD_INT 10
95146: PUSH
95147: LD_INT 11
95149: PUSH
95150: LD_INT 12
95152: PUSH
95153: LD_INT 13
95155: PUSH
95156: LD_INT 14
95158: PUSH
95159: LD_INT 15
95161: PUSH
95162: LD_INT 16
95164: PUSH
95165: LD_INT 17
95167: PUSH
95168: LD_INT 18
95170: PUSH
95171: LD_INT 19
95173: PUSH
95174: LD_INT 20
95176: PUSH
95177: LD_INT 21
95179: PUSH
95180: LD_INT 22
95182: PUSH
95183: LD_INT 23
95185: PUSH
95186: LD_INT 24
95188: PUSH
95189: LD_INT 25
95191: PUSH
95192: LD_INT 26
95194: PUSH
95195: LD_INT 28
95197: PUSH
95198: LD_INT 30
95200: PUSH
95201: LD_INT 31
95203: PUSH
95204: LD_INT 32
95206: PUSH
95207: LD_INT 34
95209: PUSH
95210: LD_INT 36
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: PUSH
95246: LD_INT 101
95248: PUSH
95249: LD_INT 102
95251: PUSH
95252: LD_INT 103
95254: PUSH
95255: LD_INT 104
95257: PUSH
95258: LD_INT 105
95260: PUSH
95261: LD_INT 106
95263: PUSH
95264: LD_INT 107
95266: PUSH
95267: LD_INT 108
95269: PUSH
95270: LD_INT 109
95272: PUSH
95273: LD_INT 110
95275: PUSH
95276: LD_INT 111
95278: PUSH
95279: LD_INT 112
95281: PUSH
95282: LD_INT 114
95284: PUSH
95285: LD_INT 116
95287: PUSH
95288: LD_INT 117
95290: PUSH
95291: LD_INT 118
95293: PUSH
95294: EMPTY
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: PUSH
95312: EMPTY
95313: LIST
95314: LIST
95315: ST_TO_ADDR
95316: GO 96999
95318: LD_INT 12
95320: DOUBLE
95321: EQUAL
95322: IFTRUE 95326
95324: GO 95546
95326: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95327: LD_ADDR_VAR 0 2
95331: PUSH
95332: LD_INT 1
95334: PUSH
95335: LD_INT 2
95337: PUSH
95338: LD_INT 3
95340: PUSH
95341: LD_INT 4
95343: PUSH
95344: LD_INT 5
95346: PUSH
95347: LD_INT 6
95349: PUSH
95350: LD_INT 7
95352: PUSH
95353: LD_INT 8
95355: PUSH
95356: LD_INT 9
95358: PUSH
95359: LD_INT 10
95361: PUSH
95362: LD_INT 11
95364: PUSH
95365: LD_INT 12
95367: PUSH
95368: LD_INT 13
95370: PUSH
95371: LD_INT 14
95373: PUSH
95374: LD_INT 15
95376: PUSH
95377: LD_INT 16
95379: PUSH
95380: LD_INT 17
95382: PUSH
95383: LD_INT 18
95385: PUSH
95386: LD_INT 19
95388: PUSH
95389: LD_INT 20
95391: PUSH
95392: LD_INT 21
95394: PUSH
95395: LD_INT 22
95397: PUSH
95398: LD_INT 23
95400: PUSH
95401: LD_INT 24
95403: PUSH
95404: LD_INT 25
95406: PUSH
95407: LD_INT 26
95409: PUSH
95410: LD_INT 27
95412: PUSH
95413: LD_INT 28
95415: PUSH
95416: LD_INT 30
95418: PUSH
95419: LD_INT 31
95421: PUSH
95422: LD_INT 32
95424: PUSH
95425: LD_INT 33
95427: PUSH
95428: LD_INT 34
95430: PUSH
95431: LD_INT 36
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: PUSH
95470: LD_INT 101
95472: PUSH
95473: LD_INT 102
95475: PUSH
95476: LD_INT 103
95478: PUSH
95479: LD_INT 104
95481: PUSH
95482: LD_INT 105
95484: PUSH
95485: LD_INT 106
95487: PUSH
95488: LD_INT 107
95490: PUSH
95491: LD_INT 108
95493: PUSH
95494: LD_INT 109
95496: PUSH
95497: LD_INT 110
95499: PUSH
95500: LD_INT 111
95502: PUSH
95503: LD_INT 112
95505: PUSH
95506: LD_INT 113
95508: PUSH
95509: LD_INT 114
95511: PUSH
95512: LD_INT 116
95514: PUSH
95515: LD_INT 117
95517: PUSH
95518: LD_INT 118
95520: PUSH
95521: EMPTY
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: ST_TO_ADDR
95544: GO 96999
95546: LD_INT 13
95548: DOUBLE
95549: EQUAL
95550: IFTRUE 95554
95552: GO 95762
95554: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95555: LD_ADDR_VAR 0 2
95559: PUSH
95560: LD_INT 1
95562: PUSH
95563: LD_INT 2
95565: PUSH
95566: LD_INT 3
95568: PUSH
95569: LD_INT 4
95571: PUSH
95572: LD_INT 5
95574: PUSH
95575: LD_INT 8
95577: PUSH
95578: LD_INT 9
95580: PUSH
95581: LD_INT 10
95583: PUSH
95584: LD_INT 11
95586: PUSH
95587: LD_INT 12
95589: PUSH
95590: LD_INT 14
95592: PUSH
95593: LD_INT 15
95595: PUSH
95596: LD_INT 16
95598: PUSH
95599: LD_INT 17
95601: PUSH
95602: LD_INT 18
95604: PUSH
95605: LD_INT 19
95607: PUSH
95608: LD_INT 20
95610: PUSH
95611: LD_INT 21
95613: PUSH
95614: LD_INT 22
95616: PUSH
95617: LD_INT 23
95619: PUSH
95620: LD_INT 24
95622: PUSH
95623: LD_INT 25
95625: PUSH
95626: LD_INT 26
95628: PUSH
95629: LD_INT 27
95631: PUSH
95632: LD_INT 28
95634: PUSH
95635: LD_INT 30
95637: PUSH
95638: LD_INT 31
95640: PUSH
95641: LD_INT 32
95643: PUSH
95644: LD_INT 33
95646: PUSH
95647: LD_INT 34
95649: PUSH
95650: LD_INT 36
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: PUSH
95686: LD_INT 101
95688: PUSH
95689: LD_INT 102
95691: PUSH
95692: LD_INT 103
95694: PUSH
95695: LD_INT 104
95697: PUSH
95698: LD_INT 105
95700: PUSH
95701: LD_INT 106
95703: PUSH
95704: LD_INT 107
95706: PUSH
95707: LD_INT 108
95709: PUSH
95710: LD_INT 109
95712: PUSH
95713: LD_INT 110
95715: PUSH
95716: LD_INT 111
95718: PUSH
95719: LD_INT 112
95721: PUSH
95722: LD_INT 113
95724: PUSH
95725: LD_INT 114
95727: PUSH
95728: LD_INT 116
95730: PUSH
95731: LD_INT 117
95733: PUSH
95734: LD_INT 118
95736: PUSH
95737: EMPTY
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: PUSH
95756: EMPTY
95757: LIST
95758: LIST
95759: ST_TO_ADDR
95760: GO 96999
95762: LD_INT 14
95764: DOUBLE
95765: EQUAL
95766: IFTRUE 95770
95768: GO 95994
95770: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95771: LD_ADDR_VAR 0 2
95775: PUSH
95776: LD_INT 1
95778: PUSH
95779: LD_INT 2
95781: PUSH
95782: LD_INT 3
95784: PUSH
95785: LD_INT 4
95787: PUSH
95788: LD_INT 5
95790: PUSH
95791: LD_INT 6
95793: PUSH
95794: LD_INT 7
95796: PUSH
95797: LD_INT 8
95799: PUSH
95800: LD_INT 9
95802: PUSH
95803: LD_INT 10
95805: PUSH
95806: LD_INT 11
95808: PUSH
95809: LD_INT 12
95811: PUSH
95812: LD_INT 13
95814: PUSH
95815: LD_INT 14
95817: PUSH
95818: LD_INT 15
95820: PUSH
95821: LD_INT 16
95823: PUSH
95824: LD_INT 17
95826: PUSH
95827: LD_INT 18
95829: PUSH
95830: LD_INT 19
95832: PUSH
95833: LD_INT 20
95835: PUSH
95836: LD_INT 21
95838: PUSH
95839: LD_INT 22
95841: PUSH
95842: LD_INT 23
95844: PUSH
95845: LD_INT 24
95847: PUSH
95848: LD_INT 25
95850: PUSH
95851: LD_INT 26
95853: PUSH
95854: LD_INT 27
95856: PUSH
95857: LD_INT 28
95859: PUSH
95860: LD_INT 29
95862: PUSH
95863: LD_INT 30
95865: PUSH
95866: LD_INT 31
95868: PUSH
95869: LD_INT 32
95871: PUSH
95872: LD_INT 33
95874: PUSH
95875: LD_INT 34
95877: PUSH
95878: LD_INT 36
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: PUSH
95918: LD_INT 101
95920: PUSH
95921: LD_INT 102
95923: PUSH
95924: LD_INT 103
95926: PUSH
95927: LD_INT 104
95929: PUSH
95930: LD_INT 105
95932: PUSH
95933: LD_INT 106
95935: PUSH
95936: LD_INT 107
95938: PUSH
95939: LD_INT 108
95941: PUSH
95942: LD_INT 109
95944: PUSH
95945: LD_INT 110
95947: PUSH
95948: LD_INT 111
95950: PUSH
95951: LD_INT 112
95953: PUSH
95954: LD_INT 113
95956: PUSH
95957: LD_INT 114
95959: PUSH
95960: LD_INT 116
95962: PUSH
95963: LD_INT 117
95965: PUSH
95966: LD_INT 118
95968: PUSH
95969: EMPTY
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: LIST
95987: PUSH
95988: EMPTY
95989: LIST
95990: LIST
95991: ST_TO_ADDR
95992: GO 96999
95994: LD_INT 15
95996: DOUBLE
95997: EQUAL
95998: IFTRUE 96002
96000: GO 96226
96002: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96003: LD_ADDR_VAR 0 2
96007: PUSH
96008: LD_INT 1
96010: PUSH
96011: LD_INT 2
96013: PUSH
96014: LD_INT 3
96016: PUSH
96017: LD_INT 4
96019: PUSH
96020: LD_INT 5
96022: PUSH
96023: LD_INT 6
96025: PUSH
96026: LD_INT 7
96028: PUSH
96029: LD_INT 8
96031: PUSH
96032: LD_INT 9
96034: PUSH
96035: LD_INT 10
96037: PUSH
96038: LD_INT 11
96040: PUSH
96041: LD_INT 12
96043: PUSH
96044: LD_INT 13
96046: PUSH
96047: LD_INT 14
96049: PUSH
96050: LD_INT 15
96052: PUSH
96053: LD_INT 16
96055: PUSH
96056: LD_INT 17
96058: PUSH
96059: LD_INT 18
96061: PUSH
96062: LD_INT 19
96064: PUSH
96065: LD_INT 20
96067: PUSH
96068: LD_INT 21
96070: PUSH
96071: LD_INT 22
96073: PUSH
96074: LD_INT 23
96076: PUSH
96077: LD_INT 24
96079: PUSH
96080: LD_INT 25
96082: PUSH
96083: LD_INT 26
96085: PUSH
96086: LD_INT 27
96088: PUSH
96089: LD_INT 28
96091: PUSH
96092: LD_INT 29
96094: PUSH
96095: LD_INT 30
96097: PUSH
96098: LD_INT 31
96100: PUSH
96101: LD_INT 32
96103: PUSH
96104: LD_INT 33
96106: PUSH
96107: LD_INT 34
96109: PUSH
96110: LD_INT 36
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 101
96152: PUSH
96153: LD_INT 102
96155: PUSH
96156: LD_INT 103
96158: PUSH
96159: LD_INT 104
96161: PUSH
96162: LD_INT 105
96164: PUSH
96165: LD_INT 106
96167: PUSH
96168: LD_INT 107
96170: PUSH
96171: LD_INT 108
96173: PUSH
96174: LD_INT 109
96176: PUSH
96177: LD_INT 110
96179: PUSH
96180: LD_INT 111
96182: PUSH
96183: LD_INT 112
96185: PUSH
96186: LD_INT 113
96188: PUSH
96189: LD_INT 114
96191: PUSH
96192: LD_INT 116
96194: PUSH
96195: LD_INT 117
96197: PUSH
96198: LD_INT 118
96200: PUSH
96201: EMPTY
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: LIST
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: ST_TO_ADDR
96224: GO 96999
96226: LD_INT 16
96228: DOUBLE
96229: EQUAL
96230: IFTRUE 96234
96232: GO 96370
96234: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96235: LD_ADDR_VAR 0 2
96239: PUSH
96240: LD_INT 2
96242: PUSH
96243: LD_INT 4
96245: PUSH
96246: LD_INT 5
96248: PUSH
96249: LD_INT 7
96251: PUSH
96252: LD_INT 11
96254: PUSH
96255: LD_INT 12
96257: PUSH
96258: LD_INT 15
96260: PUSH
96261: LD_INT 16
96263: PUSH
96264: LD_INT 20
96266: PUSH
96267: LD_INT 21
96269: PUSH
96270: LD_INT 22
96272: PUSH
96273: LD_INT 23
96275: PUSH
96276: LD_INT 25
96278: PUSH
96279: LD_INT 26
96281: PUSH
96282: LD_INT 30
96284: PUSH
96285: LD_INT 31
96287: PUSH
96288: LD_INT 32
96290: PUSH
96291: LD_INT 33
96293: PUSH
96294: LD_INT 34
96296: PUSH
96297: EMPTY
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: LIST
96314: LIST
96315: LIST
96316: LIST
96317: PUSH
96318: LD_INT 101
96320: PUSH
96321: LD_INT 102
96323: PUSH
96324: LD_INT 103
96326: PUSH
96327: LD_INT 106
96329: PUSH
96330: LD_INT 108
96332: PUSH
96333: LD_INT 112
96335: PUSH
96336: LD_INT 113
96338: PUSH
96339: LD_INT 114
96341: PUSH
96342: LD_INT 116
96344: PUSH
96345: LD_INT 117
96347: PUSH
96348: LD_INT 118
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: PUSH
96364: EMPTY
96365: LIST
96366: LIST
96367: ST_TO_ADDR
96368: GO 96999
96370: LD_INT 17
96372: DOUBLE
96373: EQUAL
96374: IFTRUE 96378
96376: GO 96602
96378: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96379: LD_ADDR_VAR 0 2
96383: PUSH
96384: LD_INT 1
96386: PUSH
96387: LD_INT 2
96389: PUSH
96390: LD_INT 3
96392: PUSH
96393: LD_INT 4
96395: PUSH
96396: LD_INT 5
96398: PUSH
96399: LD_INT 6
96401: PUSH
96402: LD_INT 7
96404: PUSH
96405: LD_INT 8
96407: PUSH
96408: LD_INT 9
96410: PUSH
96411: LD_INT 10
96413: PUSH
96414: LD_INT 11
96416: PUSH
96417: LD_INT 12
96419: PUSH
96420: LD_INT 13
96422: PUSH
96423: LD_INT 14
96425: PUSH
96426: LD_INT 15
96428: PUSH
96429: LD_INT 16
96431: PUSH
96432: LD_INT 17
96434: PUSH
96435: LD_INT 18
96437: PUSH
96438: LD_INT 19
96440: PUSH
96441: LD_INT 20
96443: PUSH
96444: LD_INT 21
96446: PUSH
96447: LD_INT 22
96449: PUSH
96450: LD_INT 23
96452: PUSH
96453: LD_INT 24
96455: PUSH
96456: LD_INT 25
96458: PUSH
96459: LD_INT 26
96461: PUSH
96462: LD_INT 27
96464: PUSH
96465: LD_INT 28
96467: PUSH
96468: LD_INT 29
96470: PUSH
96471: LD_INT 30
96473: PUSH
96474: LD_INT 31
96476: PUSH
96477: LD_INT 32
96479: PUSH
96480: LD_INT 33
96482: PUSH
96483: LD_INT 34
96485: PUSH
96486: LD_INT 36
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: PUSH
96526: LD_INT 101
96528: PUSH
96529: LD_INT 102
96531: PUSH
96532: LD_INT 103
96534: PUSH
96535: LD_INT 104
96537: PUSH
96538: LD_INT 105
96540: PUSH
96541: LD_INT 106
96543: PUSH
96544: LD_INT 107
96546: PUSH
96547: LD_INT 108
96549: PUSH
96550: LD_INT 109
96552: PUSH
96553: LD_INT 110
96555: PUSH
96556: LD_INT 111
96558: PUSH
96559: LD_INT 112
96561: PUSH
96562: LD_INT 113
96564: PUSH
96565: LD_INT 114
96567: PUSH
96568: LD_INT 116
96570: PUSH
96571: LD_INT 117
96573: PUSH
96574: LD_INT 118
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: PUSH
96596: EMPTY
96597: LIST
96598: LIST
96599: ST_TO_ADDR
96600: GO 96999
96602: LD_INT 18
96604: DOUBLE
96605: EQUAL
96606: IFTRUE 96610
96608: GO 96758
96610: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96611: LD_ADDR_VAR 0 2
96615: PUSH
96616: LD_INT 2
96618: PUSH
96619: LD_INT 4
96621: PUSH
96622: LD_INT 5
96624: PUSH
96625: LD_INT 7
96627: PUSH
96628: LD_INT 11
96630: PUSH
96631: LD_INT 12
96633: PUSH
96634: LD_INT 15
96636: PUSH
96637: LD_INT 16
96639: PUSH
96640: LD_INT 20
96642: PUSH
96643: LD_INT 21
96645: PUSH
96646: LD_INT 22
96648: PUSH
96649: LD_INT 23
96651: PUSH
96652: LD_INT 25
96654: PUSH
96655: LD_INT 26
96657: PUSH
96658: LD_INT 30
96660: PUSH
96661: LD_INT 31
96663: PUSH
96664: LD_INT 32
96666: PUSH
96667: LD_INT 33
96669: PUSH
96670: LD_INT 34
96672: PUSH
96673: LD_INT 35
96675: PUSH
96676: LD_INT 36
96678: PUSH
96679: EMPTY
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: PUSH
96702: LD_INT 101
96704: PUSH
96705: LD_INT 102
96707: PUSH
96708: LD_INT 103
96710: PUSH
96711: LD_INT 106
96713: PUSH
96714: LD_INT 108
96716: PUSH
96717: LD_INT 112
96719: PUSH
96720: LD_INT 113
96722: PUSH
96723: LD_INT 114
96725: PUSH
96726: LD_INT 115
96728: PUSH
96729: LD_INT 116
96731: PUSH
96732: LD_INT 117
96734: PUSH
96735: LD_INT 118
96737: PUSH
96738: EMPTY
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: ST_TO_ADDR
96756: GO 96999
96758: LD_INT 19
96760: DOUBLE
96761: EQUAL
96762: IFTRUE 96766
96764: GO 96998
96766: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96767: LD_ADDR_VAR 0 2
96771: PUSH
96772: LD_INT 1
96774: PUSH
96775: LD_INT 2
96777: PUSH
96778: LD_INT 3
96780: PUSH
96781: LD_INT 4
96783: PUSH
96784: LD_INT 5
96786: PUSH
96787: LD_INT 6
96789: PUSH
96790: LD_INT 7
96792: PUSH
96793: LD_INT 8
96795: PUSH
96796: LD_INT 9
96798: PUSH
96799: LD_INT 10
96801: PUSH
96802: LD_INT 11
96804: PUSH
96805: LD_INT 12
96807: PUSH
96808: LD_INT 13
96810: PUSH
96811: LD_INT 14
96813: PUSH
96814: LD_INT 15
96816: PUSH
96817: LD_INT 16
96819: PUSH
96820: LD_INT 17
96822: PUSH
96823: LD_INT 18
96825: PUSH
96826: LD_INT 19
96828: PUSH
96829: LD_INT 20
96831: PUSH
96832: LD_INT 21
96834: PUSH
96835: LD_INT 22
96837: PUSH
96838: LD_INT 23
96840: PUSH
96841: LD_INT 24
96843: PUSH
96844: LD_INT 25
96846: PUSH
96847: LD_INT 26
96849: PUSH
96850: LD_INT 27
96852: PUSH
96853: LD_INT 28
96855: PUSH
96856: LD_INT 29
96858: PUSH
96859: LD_INT 30
96861: PUSH
96862: LD_INT 31
96864: PUSH
96865: LD_INT 32
96867: PUSH
96868: LD_INT 33
96870: PUSH
96871: LD_INT 34
96873: PUSH
96874: LD_INT 35
96876: PUSH
96877: LD_INT 36
96879: PUSH
96880: EMPTY
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: PUSH
96918: LD_INT 101
96920: PUSH
96921: LD_INT 102
96923: PUSH
96924: LD_INT 103
96926: PUSH
96927: LD_INT 104
96929: PUSH
96930: LD_INT 105
96932: PUSH
96933: LD_INT 106
96935: PUSH
96936: LD_INT 107
96938: PUSH
96939: LD_INT 108
96941: PUSH
96942: LD_INT 109
96944: PUSH
96945: LD_INT 110
96947: PUSH
96948: LD_INT 111
96950: PUSH
96951: LD_INT 112
96953: PUSH
96954: LD_INT 113
96956: PUSH
96957: LD_INT 114
96959: PUSH
96960: LD_INT 115
96962: PUSH
96963: LD_INT 116
96965: PUSH
96966: LD_INT 117
96968: PUSH
96969: LD_INT 118
96971: PUSH
96972: EMPTY
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: ST_TO_ADDR
96996: GO 96999
96998: POP
// end else
96999: GO 97230
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97001: LD_ADDR_VAR 0 2
97005: PUSH
97006: LD_INT 1
97008: PUSH
97009: LD_INT 2
97011: PUSH
97012: LD_INT 3
97014: PUSH
97015: LD_INT 4
97017: PUSH
97018: LD_INT 5
97020: PUSH
97021: LD_INT 6
97023: PUSH
97024: LD_INT 7
97026: PUSH
97027: LD_INT 8
97029: PUSH
97030: LD_INT 9
97032: PUSH
97033: LD_INT 10
97035: PUSH
97036: LD_INT 11
97038: PUSH
97039: LD_INT 12
97041: PUSH
97042: LD_INT 13
97044: PUSH
97045: LD_INT 14
97047: PUSH
97048: LD_INT 15
97050: PUSH
97051: LD_INT 16
97053: PUSH
97054: LD_INT 17
97056: PUSH
97057: LD_INT 18
97059: PUSH
97060: LD_INT 19
97062: PUSH
97063: LD_INT 20
97065: PUSH
97066: LD_INT 21
97068: PUSH
97069: LD_INT 22
97071: PUSH
97072: LD_INT 23
97074: PUSH
97075: LD_INT 24
97077: PUSH
97078: LD_INT 25
97080: PUSH
97081: LD_INT 26
97083: PUSH
97084: LD_INT 27
97086: PUSH
97087: LD_INT 28
97089: PUSH
97090: LD_INT 29
97092: PUSH
97093: LD_INT 30
97095: PUSH
97096: LD_INT 31
97098: PUSH
97099: LD_INT 32
97101: PUSH
97102: LD_INT 33
97104: PUSH
97105: LD_INT 34
97107: PUSH
97108: LD_INT 35
97110: PUSH
97111: LD_INT 36
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: PUSH
97152: LD_INT 101
97154: PUSH
97155: LD_INT 102
97157: PUSH
97158: LD_INT 103
97160: PUSH
97161: LD_INT 104
97163: PUSH
97164: LD_INT 105
97166: PUSH
97167: LD_INT 106
97169: PUSH
97170: LD_INT 107
97172: PUSH
97173: LD_INT 108
97175: PUSH
97176: LD_INT 109
97178: PUSH
97179: LD_INT 110
97181: PUSH
97182: LD_INT 111
97184: PUSH
97185: LD_INT 112
97187: PUSH
97188: LD_INT 113
97190: PUSH
97191: LD_INT 114
97193: PUSH
97194: LD_INT 115
97196: PUSH
97197: LD_INT 116
97199: PUSH
97200: LD_INT 117
97202: PUSH
97203: LD_INT 118
97205: PUSH
97206: EMPTY
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: ST_TO_ADDR
// if result then
97230: LD_VAR 0 2
97234: IFFALSE 98020
// begin normal :=  ;
97236: LD_ADDR_VAR 0 5
97240: PUSH
97241: LD_STRING 
97243: ST_TO_ADDR
// hardcore :=  ;
97244: LD_ADDR_VAR 0 6
97248: PUSH
97249: LD_STRING 
97251: ST_TO_ADDR
// active :=  ;
97252: LD_ADDR_VAR 0 7
97256: PUSH
97257: LD_STRING 
97259: ST_TO_ADDR
// for i = 1 to normalCounter do
97260: LD_ADDR_VAR 0 8
97264: PUSH
97265: DOUBLE
97266: LD_INT 1
97268: DEC
97269: ST_TO_ADDR
97270: LD_EXP 77
97274: PUSH
97275: FOR_TO
97276: IFFALSE 97377
// begin tmp := 0 ;
97278: LD_ADDR_VAR 0 3
97282: PUSH
97283: LD_STRING 0
97285: ST_TO_ADDR
// if result [ 1 ] then
97286: LD_VAR 0 2
97290: PUSH
97291: LD_INT 1
97293: ARRAY
97294: IFFALSE 97359
// if result [ 1 ] [ 1 ] = i then
97296: LD_VAR 0 2
97300: PUSH
97301: LD_INT 1
97303: ARRAY
97304: PUSH
97305: LD_INT 1
97307: ARRAY
97308: PUSH
97309: LD_VAR 0 8
97313: EQUAL
97314: IFFALSE 97359
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97316: LD_ADDR_VAR 0 2
97320: PUSH
97321: LD_VAR 0 2
97325: PPUSH
97326: LD_INT 1
97328: PPUSH
97329: LD_VAR 0 2
97333: PUSH
97334: LD_INT 1
97336: ARRAY
97337: PPUSH
97338: LD_INT 1
97340: PPUSH
97341: CALL_OW 3
97345: PPUSH
97346: CALL_OW 1
97350: ST_TO_ADDR
// tmp := 1 ;
97351: LD_ADDR_VAR 0 3
97355: PUSH
97356: LD_STRING 1
97358: ST_TO_ADDR
// end ; normal := normal & tmp ;
97359: LD_ADDR_VAR 0 5
97363: PUSH
97364: LD_VAR 0 5
97368: PUSH
97369: LD_VAR 0 3
97373: STR
97374: ST_TO_ADDR
// end ;
97375: GO 97275
97377: POP
97378: POP
// for i = 1 to hardcoreCounter do
97379: LD_ADDR_VAR 0 8
97383: PUSH
97384: DOUBLE
97385: LD_INT 1
97387: DEC
97388: ST_TO_ADDR
97389: LD_EXP 78
97393: PUSH
97394: FOR_TO
97395: IFFALSE 97500
// begin tmp := 0 ;
97397: LD_ADDR_VAR 0 3
97401: PUSH
97402: LD_STRING 0
97404: ST_TO_ADDR
// if result [ 2 ] then
97405: LD_VAR 0 2
97409: PUSH
97410: LD_INT 2
97412: ARRAY
97413: IFFALSE 97482
// if result [ 2 ] [ 1 ] = 100 + i then
97415: LD_VAR 0 2
97419: PUSH
97420: LD_INT 2
97422: ARRAY
97423: PUSH
97424: LD_INT 1
97426: ARRAY
97427: PUSH
97428: LD_INT 100
97430: PUSH
97431: LD_VAR 0 8
97435: PLUS
97436: EQUAL
97437: IFFALSE 97482
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97439: LD_ADDR_VAR 0 2
97443: PUSH
97444: LD_VAR 0 2
97448: PPUSH
97449: LD_INT 2
97451: PPUSH
97452: LD_VAR 0 2
97456: PUSH
97457: LD_INT 2
97459: ARRAY
97460: PPUSH
97461: LD_INT 1
97463: PPUSH
97464: CALL_OW 3
97468: PPUSH
97469: CALL_OW 1
97473: ST_TO_ADDR
// tmp := 1 ;
97474: LD_ADDR_VAR 0 3
97478: PUSH
97479: LD_STRING 1
97481: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97482: LD_ADDR_VAR 0 6
97486: PUSH
97487: LD_VAR 0 6
97491: PUSH
97492: LD_VAR 0 3
97496: STR
97497: ST_TO_ADDR
// end ;
97498: GO 97394
97500: POP
97501: POP
// if isGameLoad then
97502: LD_VAR 0 1
97506: IFFALSE 97981
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97508: LD_ADDR_VAR 0 4
97512: PUSH
97513: LD_EXP 81
97517: PUSH
97518: LD_EXP 80
97522: PUSH
97523: LD_EXP 82
97527: PUSH
97528: LD_EXP 79
97532: PUSH
97533: LD_EXP 83
97537: PUSH
97538: LD_EXP 84
97542: PUSH
97543: LD_EXP 85
97547: PUSH
97548: LD_EXP 86
97552: PUSH
97553: LD_EXP 87
97557: PUSH
97558: LD_EXP 88
97562: PUSH
97563: LD_EXP 89
97567: PUSH
97568: LD_EXP 90
97572: PUSH
97573: LD_EXP 91
97577: PUSH
97578: LD_EXP 92
97582: PUSH
97583: LD_EXP 100
97587: PUSH
97588: LD_EXP 101
97592: PUSH
97593: LD_EXP 102
97597: PUSH
97598: LD_EXP 103
97602: PUSH
97603: LD_EXP 105
97607: PUSH
97608: LD_EXP 106
97612: PUSH
97613: LD_EXP 107
97617: PUSH
97618: LD_EXP 110
97622: PUSH
97623: LD_EXP 112
97627: PUSH
97628: LD_EXP 113
97632: PUSH
97633: LD_EXP 114
97637: PUSH
97638: LD_EXP 116
97642: PUSH
97643: LD_EXP 117
97647: PUSH
97648: LD_EXP 120
97652: PUSH
97653: LD_EXP 121
97657: PUSH
97658: LD_EXP 122
97662: PUSH
97663: LD_EXP 123
97667: PUSH
97668: LD_EXP 124
97672: PUSH
97673: LD_EXP 125
97677: PUSH
97678: LD_EXP 126
97682: PUSH
97683: LD_EXP 127
97687: PUSH
97688: LD_EXP 128
97692: PUSH
97693: LD_EXP 93
97697: PUSH
97698: LD_EXP 94
97702: PUSH
97703: LD_EXP 97
97707: PUSH
97708: LD_EXP 98
97712: PUSH
97713: LD_EXP 99
97717: PUSH
97718: LD_EXP 95
97722: PUSH
97723: LD_EXP 96
97727: PUSH
97728: LD_EXP 104
97732: PUSH
97733: LD_EXP 108
97737: PUSH
97738: LD_EXP 109
97742: PUSH
97743: LD_EXP 111
97747: PUSH
97748: LD_EXP 115
97752: PUSH
97753: LD_EXP 118
97757: PUSH
97758: LD_EXP 119
97762: PUSH
97763: LD_EXP 129
97767: PUSH
97768: LD_EXP 130
97772: PUSH
97773: LD_EXP 131
97777: PUSH
97778: LD_EXP 132
97782: PUSH
97783: EMPTY
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: ST_TO_ADDR
// tmp :=  ;
97839: LD_ADDR_VAR 0 3
97843: PUSH
97844: LD_STRING 
97846: ST_TO_ADDR
// for i = 1 to normalCounter do
97847: LD_ADDR_VAR 0 8
97851: PUSH
97852: DOUBLE
97853: LD_INT 1
97855: DEC
97856: ST_TO_ADDR
97857: LD_EXP 77
97861: PUSH
97862: FOR_TO
97863: IFFALSE 97899
// begin if flags [ i ] then
97865: LD_VAR 0 4
97869: PUSH
97870: LD_VAR 0 8
97874: ARRAY
97875: IFFALSE 97897
// tmp := tmp & i & ; ;
97877: LD_ADDR_VAR 0 3
97881: PUSH
97882: LD_VAR 0 3
97886: PUSH
97887: LD_VAR 0 8
97891: STR
97892: PUSH
97893: LD_STRING ;
97895: STR
97896: ST_TO_ADDR
// end ;
97897: GO 97862
97899: POP
97900: POP
// for i = 1 to hardcoreCounter do
97901: LD_ADDR_VAR 0 8
97905: PUSH
97906: DOUBLE
97907: LD_INT 1
97909: DEC
97910: ST_TO_ADDR
97911: LD_EXP 78
97915: PUSH
97916: FOR_TO
97917: IFFALSE 97963
// begin if flags [ normalCounter + i ] then
97919: LD_VAR 0 4
97923: PUSH
97924: LD_EXP 77
97928: PUSH
97929: LD_VAR 0 8
97933: PLUS
97934: ARRAY
97935: IFFALSE 97961
// tmp := tmp & ( 100 + i ) & ; ;
97937: LD_ADDR_VAR 0 3
97941: PUSH
97942: LD_VAR 0 3
97946: PUSH
97947: LD_INT 100
97949: PUSH
97950: LD_VAR 0 8
97954: PLUS
97955: STR
97956: PUSH
97957: LD_STRING ;
97959: STR
97960: ST_TO_ADDR
// end ;
97961: GO 97916
97963: POP
97964: POP
// if tmp then
97965: LD_VAR 0 3
97969: IFFALSE 97981
// active := tmp ;
97971: LD_ADDR_VAR 0 7
97975: PUSH
97976: LD_VAR 0 3
97980: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97981: LD_STRING getStreamItemsFromMission("
97983: PUSH
97984: LD_VAR 0 5
97988: STR
97989: PUSH
97990: LD_STRING ","
97992: STR
97993: PUSH
97994: LD_VAR 0 6
97998: STR
97999: PUSH
98000: LD_STRING ","
98002: STR
98003: PUSH
98004: LD_VAR 0 7
98008: STR
98009: PUSH
98010: LD_STRING ")
98012: STR
98013: PPUSH
98014: CALL_OW 559
// end else
98018: GO 98027
// ToLua ( getStreamItemsFromMission("","","") ) ;
98020: LD_STRING getStreamItemsFromMission("","","")
98022: PPUSH
98023: CALL_OW 559
// end ;
98027: LD_VAR 0 2
98031: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98032: LD_EXP 76
98036: PUSH
98037: LD_EXP 81
98041: AND
98042: IFFALSE 98166
98044: GO 98046
98046: DISABLE
98047: LD_INT 0
98049: PPUSH
98050: PPUSH
// begin enable ;
98051: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98052: LD_ADDR_VAR 0 2
98056: PUSH
98057: LD_INT 22
98059: PUSH
98060: LD_OWVAR 2
98064: PUSH
98065: EMPTY
98066: LIST
98067: LIST
98068: PUSH
98069: LD_INT 2
98071: PUSH
98072: LD_INT 34
98074: PUSH
98075: LD_INT 7
98077: PUSH
98078: EMPTY
98079: LIST
98080: LIST
98081: PUSH
98082: LD_INT 34
98084: PUSH
98085: LD_INT 45
98087: PUSH
98088: EMPTY
98089: LIST
98090: LIST
98091: PUSH
98092: LD_INT 34
98094: PUSH
98095: LD_INT 28
98097: PUSH
98098: EMPTY
98099: LIST
98100: LIST
98101: PUSH
98102: LD_INT 34
98104: PUSH
98105: LD_INT 47
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: PUSH
98119: EMPTY
98120: LIST
98121: LIST
98122: PPUSH
98123: CALL_OW 69
98127: ST_TO_ADDR
// if not tmp then
98128: LD_VAR 0 2
98132: NOT
98133: IFFALSE 98137
// exit ;
98135: GO 98166
// for i in tmp do
98137: LD_ADDR_VAR 0 1
98141: PUSH
98142: LD_VAR 0 2
98146: PUSH
98147: FOR_IN
98148: IFFALSE 98164
// begin SetLives ( i , 0 ) ;
98150: LD_VAR 0 1
98154: PPUSH
98155: LD_INT 0
98157: PPUSH
98158: CALL_OW 234
// end ;
98162: GO 98147
98164: POP
98165: POP
// end ;
98166: PPOPN 2
98168: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98169: LD_EXP 76
98173: PUSH
98174: LD_EXP 82
98178: AND
98179: IFFALSE 98263
98181: GO 98183
98183: DISABLE
98184: LD_INT 0
98186: PPUSH
98187: PPUSH
// begin enable ;
98188: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98189: LD_ADDR_VAR 0 2
98193: PUSH
98194: LD_INT 22
98196: PUSH
98197: LD_OWVAR 2
98201: PUSH
98202: EMPTY
98203: LIST
98204: LIST
98205: PUSH
98206: LD_INT 32
98208: PUSH
98209: LD_INT 3
98211: PUSH
98212: EMPTY
98213: LIST
98214: LIST
98215: PUSH
98216: EMPTY
98217: LIST
98218: LIST
98219: PPUSH
98220: CALL_OW 69
98224: ST_TO_ADDR
// if not tmp then
98225: LD_VAR 0 2
98229: NOT
98230: IFFALSE 98234
// exit ;
98232: GO 98263
// for i in tmp do
98234: LD_ADDR_VAR 0 1
98238: PUSH
98239: LD_VAR 0 2
98243: PUSH
98244: FOR_IN
98245: IFFALSE 98261
// begin SetLives ( i , 0 ) ;
98247: LD_VAR 0 1
98251: PPUSH
98252: LD_INT 0
98254: PPUSH
98255: CALL_OW 234
// end ;
98259: GO 98244
98261: POP
98262: POP
// end ;
98263: PPOPN 2
98265: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98266: LD_EXP 76
98270: PUSH
98271: LD_EXP 79
98275: AND
98276: IFFALSE 98369
98278: GO 98280
98280: DISABLE
98281: LD_INT 0
98283: PPUSH
// begin enable ;
98284: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98285: LD_ADDR_VAR 0 1
98289: PUSH
98290: LD_INT 22
98292: PUSH
98293: LD_OWVAR 2
98297: PUSH
98298: EMPTY
98299: LIST
98300: LIST
98301: PUSH
98302: LD_INT 2
98304: PUSH
98305: LD_INT 25
98307: PUSH
98308: LD_INT 5
98310: PUSH
98311: EMPTY
98312: LIST
98313: LIST
98314: PUSH
98315: LD_INT 25
98317: PUSH
98318: LD_INT 9
98320: PUSH
98321: EMPTY
98322: LIST
98323: LIST
98324: PUSH
98325: LD_INT 25
98327: PUSH
98328: LD_INT 8
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: PUSH
98335: EMPTY
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: PUSH
98341: EMPTY
98342: LIST
98343: LIST
98344: PPUSH
98345: CALL_OW 69
98349: PUSH
98350: FOR_IN
98351: IFFALSE 98367
// begin SetClass ( i , 1 ) ;
98353: LD_VAR 0 1
98357: PPUSH
98358: LD_INT 1
98360: PPUSH
98361: CALL_OW 336
// end ;
98365: GO 98350
98367: POP
98368: POP
// end ;
98369: PPOPN 1
98371: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98372: LD_EXP 76
98376: PUSH
98377: LD_EXP 80
98381: AND
98382: PUSH
98383: LD_OWVAR 65
98387: PUSH
98388: LD_INT 7
98390: LESS
98391: AND
98392: IFFALSE 98406
98394: GO 98396
98396: DISABLE
// begin enable ;
98397: ENABLE
// game_speed := 7 ;
98398: LD_ADDR_OWVAR 65
98402: PUSH
98403: LD_INT 7
98405: ST_TO_ADDR
// end ;
98406: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98407: LD_EXP 76
98411: PUSH
98412: LD_EXP 83
98416: AND
98417: IFFALSE 98619
98419: GO 98421
98421: DISABLE
98422: LD_INT 0
98424: PPUSH
98425: PPUSH
98426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98427: LD_ADDR_VAR 0 3
98431: PUSH
98432: LD_INT 81
98434: PUSH
98435: LD_OWVAR 2
98439: PUSH
98440: EMPTY
98441: LIST
98442: LIST
98443: PUSH
98444: LD_INT 21
98446: PUSH
98447: LD_INT 1
98449: PUSH
98450: EMPTY
98451: LIST
98452: LIST
98453: PUSH
98454: EMPTY
98455: LIST
98456: LIST
98457: PPUSH
98458: CALL_OW 69
98462: ST_TO_ADDR
// if not tmp then
98463: LD_VAR 0 3
98467: NOT
98468: IFFALSE 98472
// exit ;
98470: GO 98619
// if tmp > 5 then
98472: LD_VAR 0 3
98476: PUSH
98477: LD_INT 5
98479: GREATER
98480: IFFALSE 98492
// k := 5 else
98482: LD_ADDR_VAR 0 2
98486: PUSH
98487: LD_INT 5
98489: ST_TO_ADDR
98490: GO 98502
// k := tmp ;
98492: LD_ADDR_VAR 0 2
98496: PUSH
98497: LD_VAR 0 3
98501: ST_TO_ADDR
// for i := 1 to k do
98502: LD_ADDR_VAR 0 1
98506: PUSH
98507: DOUBLE
98508: LD_INT 1
98510: DEC
98511: ST_TO_ADDR
98512: LD_VAR 0 2
98516: PUSH
98517: FOR_TO
98518: IFFALSE 98617
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98520: LD_VAR 0 3
98524: PUSH
98525: LD_VAR 0 1
98529: ARRAY
98530: PPUSH
98531: LD_VAR 0 1
98535: PUSH
98536: LD_INT 4
98538: MOD
98539: PUSH
98540: LD_INT 1
98542: PLUS
98543: PPUSH
98544: CALL_OW 259
98548: PUSH
98549: LD_INT 10
98551: LESS
98552: IFFALSE 98615
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98554: LD_VAR 0 3
98558: PUSH
98559: LD_VAR 0 1
98563: ARRAY
98564: PPUSH
98565: LD_VAR 0 1
98569: PUSH
98570: LD_INT 4
98572: MOD
98573: PUSH
98574: LD_INT 1
98576: PLUS
98577: PPUSH
98578: LD_VAR 0 3
98582: PUSH
98583: LD_VAR 0 1
98587: ARRAY
98588: PPUSH
98589: LD_VAR 0 1
98593: PUSH
98594: LD_INT 4
98596: MOD
98597: PUSH
98598: LD_INT 1
98600: PLUS
98601: PPUSH
98602: CALL_OW 259
98606: PUSH
98607: LD_INT 1
98609: PLUS
98610: PPUSH
98611: CALL_OW 237
98615: GO 98517
98617: POP
98618: POP
// end ;
98619: PPOPN 3
98621: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98622: LD_EXP 76
98626: PUSH
98627: LD_EXP 84
98631: AND
98632: IFFALSE 98652
98634: GO 98636
98636: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98637: LD_INT 4
98639: PPUSH
98640: LD_OWVAR 2
98644: PPUSH
98645: LD_INT 0
98647: PPUSH
98648: CALL_OW 324
98652: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98653: LD_EXP 76
98657: PUSH
98658: LD_EXP 113
98662: AND
98663: IFFALSE 98683
98665: GO 98667
98667: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98668: LD_INT 19
98670: PPUSH
98671: LD_OWVAR 2
98675: PPUSH
98676: LD_INT 0
98678: PPUSH
98679: CALL_OW 324
98683: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98684: LD_EXP 76
98688: PUSH
98689: LD_EXP 85
98693: AND
98694: IFFALSE 98796
98696: GO 98698
98698: DISABLE
98699: LD_INT 0
98701: PPUSH
98702: PPUSH
// begin enable ;
98703: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98704: LD_ADDR_VAR 0 2
98708: PUSH
98709: LD_INT 22
98711: PUSH
98712: LD_OWVAR 2
98716: PUSH
98717: EMPTY
98718: LIST
98719: LIST
98720: PUSH
98721: LD_INT 2
98723: PUSH
98724: LD_INT 34
98726: PUSH
98727: LD_INT 11
98729: PUSH
98730: EMPTY
98731: LIST
98732: LIST
98733: PUSH
98734: LD_INT 34
98736: PUSH
98737: LD_INT 30
98739: PUSH
98740: EMPTY
98741: LIST
98742: LIST
98743: PUSH
98744: EMPTY
98745: LIST
98746: LIST
98747: LIST
98748: PUSH
98749: EMPTY
98750: LIST
98751: LIST
98752: PPUSH
98753: CALL_OW 69
98757: ST_TO_ADDR
// if not tmp then
98758: LD_VAR 0 2
98762: NOT
98763: IFFALSE 98767
// exit ;
98765: GO 98796
// for i in tmp do
98767: LD_ADDR_VAR 0 1
98771: PUSH
98772: LD_VAR 0 2
98776: PUSH
98777: FOR_IN
98778: IFFALSE 98794
// begin SetLives ( i , 0 ) ;
98780: LD_VAR 0 1
98784: PPUSH
98785: LD_INT 0
98787: PPUSH
98788: CALL_OW 234
// end ;
98792: GO 98777
98794: POP
98795: POP
// end ;
98796: PPOPN 2
98798: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98799: LD_EXP 76
98803: PUSH
98804: LD_EXP 86
98808: AND
98809: IFFALSE 98829
98811: GO 98813
98813: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98814: LD_INT 32
98816: PPUSH
98817: LD_OWVAR 2
98821: PPUSH
98822: LD_INT 0
98824: PPUSH
98825: CALL_OW 324
98829: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98830: LD_EXP 76
98834: PUSH
98835: LD_EXP 87
98839: AND
98840: IFFALSE 99021
98842: GO 98844
98844: DISABLE
98845: LD_INT 0
98847: PPUSH
98848: PPUSH
98849: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98850: LD_ADDR_VAR 0 2
98854: PUSH
98855: LD_INT 22
98857: PUSH
98858: LD_OWVAR 2
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: PUSH
98867: LD_INT 33
98869: PUSH
98870: LD_INT 3
98872: PUSH
98873: EMPTY
98874: LIST
98875: LIST
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: PPUSH
98881: CALL_OW 69
98885: ST_TO_ADDR
// if not tmp then
98886: LD_VAR 0 2
98890: NOT
98891: IFFALSE 98895
// exit ;
98893: GO 99021
// side := 0 ;
98895: LD_ADDR_VAR 0 3
98899: PUSH
98900: LD_INT 0
98902: ST_TO_ADDR
// for i := 1 to 8 do
98903: LD_ADDR_VAR 0 1
98907: PUSH
98908: DOUBLE
98909: LD_INT 1
98911: DEC
98912: ST_TO_ADDR
98913: LD_INT 8
98915: PUSH
98916: FOR_TO
98917: IFFALSE 98965
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98919: LD_OWVAR 2
98923: PUSH
98924: LD_VAR 0 1
98928: NONEQUAL
98929: PUSH
98930: LD_OWVAR 2
98934: PPUSH
98935: LD_VAR 0 1
98939: PPUSH
98940: CALL_OW 81
98944: PUSH
98945: LD_INT 2
98947: EQUAL
98948: AND
98949: IFFALSE 98963
// begin side := i ;
98951: LD_ADDR_VAR 0 3
98955: PUSH
98956: LD_VAR 0 1
98960: ST_TO_ADDR
// break ;
98961: GO 98965
// end ;
98963: GO 98916
98965: POP
98966: POP
// if not side then
98967: LD_VAR 0 3
98971: NOT
98972: IFFALSE 98976
// exit ;
98974: GO 99021
// for i := 1 to tmp do
98976: LD_ADDR_VAR 0 1
98980: PUSH
98981: DOUBLE
98982: LD_INT 1
98984: DEC
98985: ST_TO_ADDR
98986: LD_VAR 0 2
98990: PUSH
98991: FOR_TO
98992: IFFALSE 99019
// if Prob ( 60 ) then
98994: LD_INT 60
98996: PPUSH
98997: CALL_OW 13
99001: IFFALSE 99017
// SetSide ( i , side ) ;
99003: LD_VAR 0 1
99007: PPUSH
99008: LD_VAR 0 3
99012: PPUSH
99013: CALL_OW 235
99017: GO 98991
99019: POP
99020: POP
// end ;
99021: PPOPN 3
99023: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99024: LD_EXP 76
99028: PUSH
99029: LD_EXP 89
99033: AND
99034: IFFALSE 99153
99036: GO 99038
99038: DISABLE
99039: LD_INT 0
99041: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99042: LD_ADDR_VAR 0 1
99046: PUSH
99047: LD_INT 22
99049: PUSH
99050: LD_OWVAR 2
99054: PUSH
99055: EMPTY
99056: LIST
99057: LIST
99058: PUSH
99059: LD_INT 21
99061: PUSH
99062: LD_INT 1
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: PUSH
99069: LD_INT 3
99071: PUSH
99072: LD_INT 23
99074: PUSH
99075: LD_INT 0
99077: PUSH
99078: EMPTY
99079: LIST
99080: LIST
99081: PUSH
99082: EMPTY
99083: LIST
99084: LIST
99085: PUSH
99086: EMPTY
99087: LIST
99088: LIST
99089: LIST
99090: PPUSH
99091: CALL_OW 69
99095: PUSH
99096: FOR_IN
99097: IFFALSE 99151
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99099: LD_VAR 0 1
99103: PPUSH
99104: CALL_OW 257
99108: PUSH
99109: LD_INT 1
99111: PUSH
99112: LD_INT 2
99114: PUSH
99115: LD_INT 3
99117: PUSH
99118: LD_INT 4
99120: PUSH
99121: EMPTY
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: IN
99127: IFFALSE 99149
// SetClass ( un , rand ( 1 , 4 ) ) ;
99129: LD_VAR 0 1
99133: PPUSH
99134: LD_INT 1
99136: PPUSH
99137: LD_INT 4
99139: PPUSH
99140: CALL_OW 12
99144: PPUSH
99145: CALL_OW 336
99149: GO 99096
99151: POP
99152: POP
// end ;
99153: PPOPN 1
99155: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99156: LD_EXP 76
99160: PUSH
99161: LD_EXP 88
99165: AND
99166: IFFALSE 99245
99168: GO 99170
99170: DISABLE
99171: LD_INT 0
99173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99174: LD_ADDR_VAR 0 1
99178: PUSH
99179: LD_INT 22
99181: PUSH
99182: LD_OWVAR 2
99186: PUSH
99187: EMPTY
99188: LIST
99189: LIST
99190: PUSH
99191: LD_INT 21
99193: PUSH
99194: LD_INT 3
99196: PUSH
99197: EMPTY
99198: LIST
99199: LIST
99200: PUSH
99201: EMPTY
99202: LIST
99203: LIST
99204: PPUSH
99205: CALL_OW 69
99209: ST_TO_ADDR
// if not tmp then
99210: LD_VAR 0 1
99214: NOT
99215: IFFALSE 99219
// exit ;
99217: GO 99245
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99219: LD_VAR 0 1
99223: PUSH
99224: LD_INT 1
99226: PPUSH
99227: LD_VAR 0 1
99231: PPUSH
99232: CALL_OW 12
99236: ARRAY
99237: PPUSH
99238: LD_INT 100
99240: PPUSH
99241: CALL_OW 234
// end ;
99245: PPOPN 1
99247: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99248: LD_EXP 76
99252: PUSH
99253: LD_EXP 90
99257: AND
99258: IFFALSE 99356
99260: GO 99262
99262: DISABLE
99263: LD_INT 0
99265: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99266: LD_ADDR_VAR 0 1
99270: PUSH
99271: LD_INT 22
99273: PUSH
99274: LD_OWVAR 2
99278: PUSH
99279: EMPTY
99280: LIST
99281: LIST
99282: PUSH
99283: LD_INT 21
99285: PUSH
99286: LD_INT 1
99288: PUSH
99289: EMPTY
99290: LIST
99291: LIST
99292: PUSH
99293: EMPTY
99294: LIST
99295: LIST
99296: PPUSH
99297: CALL_OW 69
99301: ST_TO_ADDR
// if not tmp then
99302: LD_VAR 0 1
99306: NOT
99307: IFFALSE 99311
// exit ;
99309: GO 99356
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99311: LD_VAR 0 1
99315: PUSH
99316: LD_INT 1
99318: PPUSH
99319: LD_VAR 0 1
99323: PPUSH
99324: CALL_OW 12
99328: ARRAY
99329: PPUSH
99330: LD_INT 1
99332: PPUSH
99333: LD_INT 4
99335: PPUSH
99336: CALL_OW 12
99340: PPUSH
99341: LD_INT 3000
99343: PPUSH
99344: LD_INT 9000
99346: PPUSH
99347: CALL_OW 12
99351: PPUSH
99352: CALL_OW 492
// end ;
99356: PPOPN 1
99358: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99359: LD_EXP 76
99363: PUSH
99364: LD_EXP 91
99368: AND
99369: IFFALSE 99389
99371: GO 99373
99373: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99374: LD_INT 1
99376: PPUSH
99377: LD_OWVAR 2
99381: PPUSH
99382: LD_INT 0
99384: PPUSH
99385: CALL_OW 324
99389: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99390: LD_EXP 76
99394: PUSH
99395: LD_EXP 92
99399: AND
99400: IFFALSE 99483
99402: GO 99404
99404: DISABLE
99405: LD_INT 0
99407: PPUSH
99408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99409: LD_ADDR_VAR 0 2
99413: PUSH
99414: LD_INT 22
99416: PUSH
99417: LD_OWVAR 2
99421: PUSH
99422: EMPTY
99423: LIST
99424: LIST
99425: PUSH
99426: LD_INT 21
99428: PUSH
99429: LD_INT 3
99431: PUSH
99432: EMPTY
99433: LIST
99434: LIST
99435: PUSH
99436: EMPTY
99437: LIST
99438: LIST
99439: PPUSH
99440: CALL_OW 69
99444: ST_TO_ADDR
// if not tmp then
99445: LD_VAR 0 2
99449: NOT
99450: IFFALSE 99454
// exit ;
99452: GO 99483
// for i in tmp do
99454: LD_ADDR_VAR 0 1
99458: PUSH
99459: LD_VAR 0 2
99463: PUSH
99464: FOR_IN
99465: IFFALSE 99481
// SetBLevel ( i , 10 ) ;
99467: LD_VAR 0 1
99471: PPUSH
99472: LD_INT 10
99474: PPUSH
99475: CALL_OW 241
99479: GO 99464
99481: POP
99482: POP
// end ;
99483: PPOPN 2
99485: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99486: LD_EXP 76
99490: PUSH
99491: LD_EXP 93
99495: AND
99496: IFFALSE 99607
99498: GO 99500
99500: DISABLE
99501: LD_INT 0
99503: PPUSH
99504: PPUSH
99505: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99506: LD_ADDR_VAR 0 3
99510: PUSH
99511: LD_INT 22
99513: PUSH
99514: LD_OWVAR 2
99518: PUSH
99519: EMPTY
99520: LIST
99521: LIST
99522: PUSH
99523: LD_INT 25
99525: PUSH
99526: LD_INT 1
99528: PUSH
99529: EMPTY
99530: LIST
99531: LIST
99532: PUSH
99533: EMPTY
99534: LIST
99535: LIST
99536: PPUSH
99537: CALL_OW 69
99541: ST_TO_ADDR
// if not tmp then
99542: LD_VAR 0 3
99546: NOT
99547: IFFALSE 99551
// exit ;
99549: GO 99607
// un := tmp [ rand ( 1 , tmp ) ] ;
99551: LD_ADDR_VAR 0 2
99555: PUSH
99556: LD_VAR 0 3
99560: PUSH
99561: LD_INT 1
99563: PPUSH
99564: LD_VAR 0 3
99568: PPUSH
99569: CALL_OW 12
99573: ARRAY
99574: ST_TO_ADDR
// if Crawls ( un ) then
99575: LD_VAR 0 2
99579: PPUSH
99580: CALL_OW 318
99584: IFFALSE 99595
// ComWalk ( un ) ;
99586: LD_VAR 0 2
99590: PPUSH
99591: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99595: LD_VAR 0 2
99599: PPUSH
99600: LD_INT 5
99602: PPUSH
99603: CALL_OW 336
// end ;
99607: PPOPN 3
99609: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99610: LD_EXP 76
99614: PUSH
99615: LD_EXP 94
99619: AND
99620: PUSH
99621: LD_OWVAR 67
99625: PUSH
99626: LD_INT 4
99628: LESS
99629: AND
99630: IFFALSE 99649
99632: GO 99634
99634: DISABLE
// begin Difficulty := Difficulty + 1 ;
99635: LD_ADDR_OWVAR 67
99639: PUSH
99640: LD_OWVAR 67
99644: PUSH
99645: LD_INT 1
99647: PLUS
99648: ST_TO_ADDR
// end ;
99649: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99650: LD_EXP 76
99654: PUSH
99655: LD_EXP 95
99659: AND
99660: IFFALSE 99763
99662: GO 99664
99664: DISABLE
99665: LD_INT 0
99667: PPUSH
// begin for i := 1 to 5 do
99668: LD_ADDR_VAR 0 1
99672: PUSH
99673: DOUBLE
99674: LD_INT 1
99676: DEC
99677: ST_TO_ADDR
99678: LD_INT 5
99680: PUSH
99681: FOR_TO
99682: IFFALSE 99761
// begin uc_nation := nation_nature ;
99684: LD_ADDR_OWVAR 21
99688: PUSH
99689: LD_INT 0
99691: ST_TO_ADDR
// uc_side := 0 ;
99692: LD_ADDR_OWVAR 20
99696: PUSH
99697: LD_INT 0
99699: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99700: LD_ADDR_OWVAR 29
99704: PUSH
99705: LD_INT 12
99707: PUSH
99708: LD_INT 12
99710: PUSH
99711: EMPTY
99712: LIST
99713: LIST
99714: ST_TO_ADDR
// hc_agressivity := 20 ;
99715: LD_ADDR_OWVAR 35
99719: PUSH
99720: LD_INT 20
99722: ST_TO_ADDR
// hc_class := class_tiger ;
99723: LD_ADDR_OWVAR 28
99727: PUSH
99728: LD_INT 14
99730: ST_TO_ADDR
// hc_gallery :=  ;
99731: LD_ADDR_OWVAR 33
99735: PUSH
99736: LD_STRING 
99738: ST_TO_ADDR
// hc_name :=  ;
99739: LD_ADDR_OWVAR 26
99743: PUSH
99744: LD_STRING 
99746: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99747: CALL_OW 44
99751: PPUSH
99752: LD_INT 0
99754: PPUSH
99755: CALL_OW 51
// end ;
99759: GO 99681
99761: POP
99762: POP
// end ;
99763: PPOPN 1
99765: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99766: LD_EXP 76
99770: PUSH
99771: LD_EXP 96
99775: AND
99776: IFFALSE 99785
99778: GO 99780
99780: DISABLE
// StreamSibBomb ;
99781: CALL 99786 0 0
99785: END
// export function StreamSibBomb ; var i , x , y ; begin
99786: LD_INT 0
99788: PPUSH
99789: PPUSH
99790: PPUSH
99791: PPUSH
// result := false ;
99792: LD_ADDR_VAR 0 1
99796: PUSH
99797: LD_INT 0
99799: ST_TO_ADDR
// for i := 1 to 16 do
99800: LD_ADDR_VAR 0 2
99804: PUSH
99805: DOUBLE
99806: LD_INT 1
99808: DEC
99809: ST_TO_ADDR
99810: LD_INT 16
99812: PUSH
99813: FOR_TO
99814: IFFALSE 100013
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99816: LD_ADDR_VAR 0 3
99820: PUSH
99821: LD_INT 10
99823: PUSH
99824: LD_INT 20
99826: PUSH
99827: LD_INT 30
99829: PUSH
99830: LD_INT 40
99832: PUSH
99833: LD_INT 50
99835: PUSH
99836: LD_INT 60
99838: PUSH
99839: LD_INT 70
99841: PUSH
99842: LD_INT 80
99844: PUSH
99845: LD_INT 90
99847: PUSH
99848: LD_INT 100
99850: PUSH
99851: LD_INT 110
99853: PUSH
99854: LD_INT 120
99856: PUSH
99857: LD_INT 130
99859: PUSH
99860: LD_INT 140
99862: PUSH
99863: LD_INT 150
99865: PUSH
99866: EMPTY
99867: LIST
99868: LIST
99869: LIST
99870: LIST
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: PUSH
99883: LD_INT 1
99885: PPUSH
99886: LD_INT 15
99888: PPUSH
99889: CALL_OW 12
99893: ARRAY
99894: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99895: LD_ADDR_VAR 0 4
99899: PUSH
99900: LD_INT 10
99902: PUSH
99903: LD_INT 20
99905: PUSH
99906: LD_INT 30
99908: PUSH
99909: LD_INT 40
99911: PUSH
99912: LD_INT 50
99914: PUSH
99915: LD_INT 60
99917: PUSH
99918: LD_INT 70
99920: PUSH
99921: LD_INT 80
99923: PUSH
99924: LD_INT 90
99926: PUSH
99927: LD_INT 100
99929: PUSH
99930: LD_INT 110
99932: PUSH
99933: LD_INT 120
99935: PUSH
99936: LD_INT 130
99938: PUSH
99939: LD_INT 140
99941: PUSH
99942: LD_INT 150
99944: PUSH
99945: EMPTY
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: LIST
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: LIST
99961: PUSH
99962: LD_INT 1
99964: PPUSH
99965: LD_INT 15
99967: PPUSH
99968: CALL_OW 12
99972: ARRAY
99973: ST_TO_ADDR
// if ValidHex ( x , y ) then
99974: LD_VAR 0 3
99978: PPUSH
99979: LD_VAR 0 4
99983: PPUSH
99984: CALL_OW 488
99988: IFFALSE 100011
// begin result := [ x , y ] ;
99990: LD_ADDR_VAR 0 1
99994: PUSH
99995: LD_VAR 0 3
99999: PUSH
100000: LD_VAR 0 4
100004: PUSH
100005: EMPTY
100006: LIST
100007: LIST
100008: ST_TO_ADDR
// break ;
100009: GO 100013
// end ; end ;
100011: GO 99813
100013: POP
100014: POP
// if result then
100015: LD_VAR 0 1
100019: IFFALSE 100079
// begin ToLua ( playSibBomb() ) ;
100021: LD_STRING playSibBomb()
100023: PPUSH
100024: CALL_OW 559
// wait ( 0 0$14 ) ;
100028: LD_INT 490
100030: PPUSH
100031: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100035: LD_VAR 0 1
100039: PUSH
100040: LD_INT 1
100042: ARRAY
100043: PPUSH
100044: LD_VAR 0 1
100048: PUSH
100049: LD_INT 2
100051: ARRAY
100052: PPUSH
100053: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100057: LD_VAR 0 1
100061: PUSH
100062: LD_INT 1
100064: ARRAY
100065: PPUSH
100066: LD_VAR 0 1
100070: PUSH
100071: LD_INT 2
100073: ARRAY
100074: PPUSH
100075: CALL_OW 429
// end ; end ;
100079: LD_VAR 0 1
100083: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100084: LD_EXP 76
100088: PUSH
100089: LD_EXP 98
100093: AND
100094: IFFALSE 100106
100096: GO 100098
100098: DISABLE
// YouLost (  ) ;
100099: LD_STRING 
100101: PPUSH
100102: CALL_OW 104
100106: END
// every 0 0$1 trigger StreamModeActive and sFog do
100107: LD_EXP 76
100111: PUSH
100112: LD_EXP 97
100116: AND
100117: IFFALSE 100131
100119: GO 100121
100121: DISABLE
// FogOff ( your_side ) ;
100122: LD_OWVAR 2
100126: PPUSH
100127: CALL_OW 344
100131: END
// every 0 0$1 trigger StreamModeActive and sSun do
100132: LD_EXP 76
100136: PUSH
100137: LD_EXP 99
100141: AND
100142: IFFALSE 100170
100144: GO 100146
100146: DISABLE
// begin solar_recharge_percent := 0 ;
100147: LD_ADDR_OWVAR 79
100151: PUSH
100152: LD_INT 0
100154: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100155: LD_INT 10500
100157: PPUSH
100158: CALL_OW 67
// solar_recharge_percent := 100 ;
100162: LD_ADDR_OWVAR 79
100166: PUSH
100167: LD_INT 100
100169: ST_TO_ADDR
// end ;
100170: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100171: LD_EXP 76
100175: PUSH
100176: LD_EXP 100
100180: AND
100181: IFFALSE 100420
100183: GO 100185
100185: DISABLE
100186: LD_INT 0
100188: PPUSH
100189: PPUSH
100190: PPUSH
// begin tmp := [ ] ;
100191: LD_ADDR_VAR 0 3
100195: PUSH
100196: EMPTY
100197: ST_TO_ADDR
// for i := 1 to 6 do
100198: LD_ADDR_VAR 0 1
100202: PUSH
100203: DOUBLE
100204: LD_INT 1
100206: DEC
100207: ST_TO_ADDR
100208: LD_INT 6
100210: PUSH
100211: FOR_TO
100212: IFFALSE 100317
// begin uc_nation := nation_nature ;
100214: LD_ADDR_OWVAR 21
100218: PUSH
100219: LD_INT 0
100221: ST_TO_ADDR
// uc_side := 0 ;
100222: LD_ADDR_OWVAR 20
100226: PUSH
100227: LD_INT 0
100229: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100230: LD_ADDR_OWVAR 29
100234: PUSH
100235: LD_INT 12
100237: PUSH
100238: LD_INT 12
100240: PUSH
100241: EMPTY
100242: LIST
100243: LIST
100244: ST_TO_ADDR
// hc_agressivity := 20 ;
100245: LD_ADDR_OWVAR 35
100249: PUSH
100250: LD_INT 20
100252: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100253: LD_ADDR_OWVAR 28
100257: PUSH
100258: LD_INT 17
100260: ST_TO_ADDR
// hc_gallery :=  ;
100261: LD_ADDR_OWVAR 33
100265: PUSH
100266: LD_STRING 
100268: ST_TO_ADDR
// hc_name :=  ;
100269: LD_ADDR_OWVAR 26
100273: PUSH
100274: LD_STRING 
100276: ST_TO_ADDR
// un := CreateHuman ;
100277: LD_ADDR_VAR 0 2
100281: PUSH
100282: CALL_OW 44
100286: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100287: LD_VAR 0 2
100291: PPUSH
100292: LD_INT 1
100294: PPUSH
100295: CALL_OW 51
// tmp := tmp ^ un ;
100299: LD_ADDR_VAR 0 3
100303: PUSH
100304: LD_VAR 0 3
100308: PUSH
100309: LD_VAR 0 2
100313: ADD
100314: ST_TO_ADDR
// end ;
100315: GO 100211
100317: POP
100318: POP
// repeat wait ( 0 0$1 ) ;
100319: LD_INT 35
100321: PPUSH
100322: CALL_OW 67
// for un in tmp do
100326: LD_ADDR_VAR 0 2
100330: PUSH
100331: LD_VAR 0 3
100335: PUSH
100336: FOR_IN
100337: IFFALSE 100411
// begin if IsDead ( un ) then
100339: LD_VAR 0 2
100343: PPUSH
100344: CALL_OW 301
100348: IFFALSE 100368
// begin tmp := tmp diff un ;
100350: LD_ADDR_VAR 0 3
100354: PUSH
100355: LD_VAR 0 3
100359: PUSH
100360: LD_VAR 0 2
100364: DIFF
100365: ST_TO_ADDR
// continue ;
100366: GO 100336
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100368: LD_VAR 0 2
100372: PPUSH
100373: LD_INT 3
100375: PUSH
100376: LD_INT 22
100378: PUSH
100379: LD_INT 0
100381: PUSH
100382: EMPTY
100383: LIST
100384: LIST
100385: PUSH
100386: EMPTY
100387: LIST
100388: LIST
100389: PPUSH
100390: CALL_OW 69
100394: PPUSH
100395: LD_VAR 0 2
100399: PPUSH
100400: CALL_OW 74
100404: PPUSH
100405: CALL_OW 115
// end ;
100409: GO 100336
100411: POP
100412: POP
// until not tmp ;
100413: LD_VAR 0 3
100417: NOT
100418: IFFALSE 100319
// end ;
100420: PPOPN 3
100422: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100423: LD_EXP 76
100427: PUSH
100428: LD_EXP 101
100432: AND
100433: IFFALSE 100487
100435: GO 100437
100437: DISABLE
// begin ToLua ( displayTroll(); ) ;
100438: LD_STRING displayTroll();
100440: PPUSH
100441: CALL_OW 559
// wait ( 3 3$00 ) ;
100445: LD_INT 6300
100447: PPUSH
100448: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100452: LD_STRING hideTroll();
100454: PPUSH
100455: CALL_OW 559
// wait ( 1 1$00 ) ;
100459: LD_INT 2100
100461: PPUSH
100462: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100466: LD_STRING displayTroll();
100468: PPUSH
100469: CALL_OW 559
// wait ( 1 1$00 ) ;
100473: LD_INT 2100
100475: PPUSH
100476: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100480: LD_STRING hideTroll();
100482: PPUSH
100483: CALL_OW 559
// end ;
100487: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100488: LD_EXP 76
100492: PUSH
100493: LD_EXP 102
100497: AND
100498: IFFALSE 100561
100500: GO 100502
100502: DISABLE
100503: LD_INT 0
100505: PPUSH
// begin p := 0 ;
100506: LD_ADDR_VAR 0 1
100510: PUSH
100511: LD_INT 0
100513: ST_TO_ADDR
// repeat game_speed := 1 ;
100514: LD_ADDR_OWVAR 65
100518: PUSH
100519: LD_INT 1
100521: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100522: LD_INT 35
100524: PPUSH
100525: CALL_OW 67
// p := p + 1 ;
100529: LD_ADDR_VAR 0 1
100533: PUSH
100534: LD_VAR 0 1
100538: PUSH
100539: LD_INT 1
100541: PLUS
100542: ST_TO_ADDR
// until p >= 60 ;
100543: LD_VAR 0 1
100547: PUSH
100548: LD_INT 60
100550: GREATEREQUAL
100551: IFFALSE 100514
// game_speed := 4 ;
100553: LD_ADDR_OWVAR 65
100557: PUSH
100558: LD_INT 4
100560: ST_TO_ADDR
// end ;
100561: PPOPN 1
100563: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100564: LD_EXP 76
100568: PUSH
100569: LD_EXP 103
100573: AND
100574: IFFALSE 100720
100576: GO 100578
100578: DISABLE
100579: LD_INT 0
100581: PPUSH
100582: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100583: LD_ADDR_VAR 0 1
100587: PUSH
100588: LD_INT 22
100590: PUSH
100591: LD_OWVAR 2
100595: PUSH
100596: EMPTY
100597: LIST
100598: LIST
100599: PUSH
100600: LD_INT 2
100602: PUSH
100603: LD_INT 30
100605: PUSH
100606: LD_INT 0
100608: PUSH
100609: EMPTY
100610: LIST
100611: LIST
100612: PUSH
100613: LD_INT 30
100615: PUSH
100616: LD_INT 1
100618: PUSH
100619: EMPTY
100620: LIST
100621: LIST
100622: PUSH
100623: EMPTY
100624: LIST
100625: LIST
100626: LIST
100627: PUSH
100628: EMPTY
100629: LIST
100630: LIST
100631: PPUSH
100632: CALL_OW 69
100636: ST_TO_ADDR
// if not depot then
100637: LD_VAR 0 1
100641: NOT
100642: IFFALSE 100646
// exit ;
100644: GO 100720
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100646: LD_ADDR_VAR 0 2
100650: PUSH
100651: LD_VAR 0 1
100655: PUSH
100656: LD_INT 1
100658: PPUSH
100659: LD_VAR 0 1
100663: PPUSH
100664: CALL_OW 12
100668: ARRAY
100669: PPUSH
100670: CALL_OW 274
100674: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100675: LD_VAR 0 2
100679: PPUSH
100680: LD_INT 1
100682: PPUSH
100683: LD_INT 0
100685: PPUSH
100686: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100690: LD_VAR 0 2
100694: PPUSH
100695: LD_INT 2
100697: PPUSH
100698: LD_INT 0
100700: PPUSH
100701: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100705: LD_VAR 0 2
100709: PPUSH
100710: LD_INT 3
100712: PPUSH
100713: LD_INT 0
100715: PPUSH
100716: CALL_OW 277
// end ;
100720: PPOPN 2
100722: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100723: LD_EXP 76
100727: PUSH
100728: LD_EXP 104
100732: AND
100733: IFFALSE 100830
100735: GO 100737
100737: DISABLE
100738: LD_INT 0
100740: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100741: LD_ADDR_VAR 0 1
100745: PUSH
100746: LD_INT 22
100748: PUSH
100749: LD_OWVAR 2
100753: PUSH
100754: EMPTY
100755: LIST
100756: LIST
100757: PUSH
100758: LD_INT 21
100760: PUSH
100761: LD_INT 1
100763: PUSH
100764: EMPTY
100765: LIST
100766: LIST
100767: PUSH
100768: LD_INT 3
100770: PUSH
100771: LD_INT 23
100773: PUSH
100774: LD_INT 0
100776: PUSH
100777: EMPTY
100778: LIST
100779: LIST
100780: PUSH
100781: EMPTY
100782: LIST
100783: LIST
100784: PUSH
100785: EMPTY
100786: LIST
100787: LIST
100788: LIST
100789: PPUSH
100790: CALL_OW 69
100794: ST_TO_ADDR
// if not tmp then
100795: LD_VAR 0 1
100799: NOT
100800: IFFALSE 100804
// exit ;
100802: GO 100830
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100804: LD_VAR 0 1
100808: PUSH
100809: LD_INT 1
100811: PPUSH
100812: LD_VAR 0 1
100816: PPUSH
100817: CALL_OW 12
100821: ARRAY
100822: PPUSH
100823: LD_INT 200
100825: PPUSH
100826: CALL_OW 234
// end ;
100830: PPOPN 1
100832: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100833: LD_EXP 76
100837: PUSH
100838: LD_EXP 105
100842: AND
100843: IFFALSE 100922
100845: GO 100847
100847: DISABLE
100848: LD_INT 0
100850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100851: LD_ADDR_VAR 0 1
100855: PUSH
100856: LD_INT 22
100858: PUSH
100859: LD_OWVAR 2
100863: PUSH
100864: EMPTY
100865: LIST
100866: LIST
100867: PUSH
100868: LD_INT 21
100870: PUSH
100871: LD_INT 2
100873: PUSH
100874: EMPTY
100875: LIST
100876: LIST
100877: PUSH
100878: EMPTY
100879: LIST
100880: LIST
100881: PPUSH
100882: CALL_OW 69
100886: ST_TO_ADDR
// if not tmp then
100887: LD_VAR 0 1
100891: NOT
100892: IFFALSE 100896
// exit ;
100894: GO 100922
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100896: LD_VAR 0 1
100900: PUSH
100901: LD_INT 1
100903: PPUSH
100904: LD_VAR 0 1
100908: PPUSH
100909: CALL_OW 12
100913: ARRAY
100914: PPUSH
100915: LD_INT 60
100917: PPUSH
100918: CALL_OW 234
// end ;
100922: PPOPN 1
100924: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100925: LD_EXP 76
100929: PUSH
100930: LD_EXP 106
100934: AND
100935: IFFALSE 101034
100937: GO 100939
100939: DISABLE
100940: LD_INT 0
100942: PPUSH
100943: PPUSH
// begin enable ;
100944: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100945: LD_ADDR_VAR 0 1
100949: PUSH
100950: LD_INT 22
100952: PUSH
100953: LD_OWVAR 2
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: PUSH
100962: LD_INT 61
100964: PUSH
100965: EMPTY
100966: LIST
100967: PUSH
100968: LD_INT 33
100970: PUSH
100971: LD_INT 2
100973: PUSH
100974: EMPTY
100975: LIST
100976: LIST
100977: PUSH
100978: EMPTY
100979: LIST
100980: LIST
100981: LIST
100982: PPUSH
100983: CALL_OW 69
100987: ST_TO_ADDR
// if not tmp then
100988: LD_VAR 0 1
100992: NOT
100993: IFFALSE 100997
// exit ;
100995: GO 101034
// for i in tmp do
100997: LD_ADDR_VAR 0 2
101001: PUSH
101002: LD_VAR 0 1
101006: PUSH
101007: FOR_IN
101008: IFFALSE 101032
// if IsControledBy ( i ) then
101010: LD_VAR 0 2
101014: PPUSH
101015: CALL_OW 312
101019: IFFALSE 101030
// ComUnlink ( i ) ;
101021: LD_VAR 0 2
101025: PPUSH
101026: CALL_OW 136
101030: GO 101007
101032: POP
101033: POP
// end ;
101034: PPOPN 2
101036: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101037: LD_EXP 76
101041: PUSH
101042: LD_EXP 107
101046: AND
101047: IFFALSE 101187
101049: GO 101051
101051: DISABLE
101052: LD_INT 0
101054: PPUSH
101055: PPUSH
// begin ToLua ( displayPowell(); ) ;
101056: LD_STRING displayPowell();
101058: PPUSH
101059: CALL_OW 559
// uc_side := 0 ;
101063: LD_ADDR_OWVAR 20
101067: PUSH
101068: LD_INT 0
101070: ST_TO_ADDR
// uc_nation := 2 ;
101071: LD_ADDR_OWVAR 21
101075: PUSH
101076: LD_INT 2
101078: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101079: LD_ADDR_OWVAR 37
101083: PUSH
101084: LD_INT 14
101086: ST_TO_ADDR
// vc_engine := engine_siberite ;
101087: LD_ADDR_OWVAR 39
101091: PUSH
101092: LD_INT 3
101094: ST_TO_ADDR
// vc_control := control_apeman ;
101095: LD_ADDR_OWVAR 38
101099: PUSH
101100: LD_INT 5
101102: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101103: LD_ADDR_OWVAR 40
101107: PUSH
101108: LD_INT 29
101110: ST_TO_ADDR
// un := CreateVehicle ;
101111: LD_ADDR_VAR 0 2
101115: PUSH
101116: CALL_OW 45
101120: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101121: LD_VAR 0 2
101125: PPUSH
101126: LD_INT 1
101128: PPUSH
101129: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101133: LD_INT 35
101135: PPUSH
101136: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101140: LD_VAR 0 2
101144: PPUSH
101145: LD_INT 22
101147: PUSH
101148: LD_OWVAR 2
101152: PUSH
101153: EMPTY
101154: LIST
101155: LIST
101156: PPUSH
101157: CALL_OW 69
101161: PPUSH
101162: LD_VAR 0 2
101166: PPUSH
101167: CALL_OW 74
101171: PPUSH
101172: CALL_OW 115
// until IsDead ( un ) ;
101176: LD_VAR 0 2
101180: PPUSH
101181: CALL_OW 301
101185: IFFALSE 101133
// end ;
101187: PPOPN 2
101189: END
// every 0 0$1 trigger StreamModeActive and sStu do
101190: LD_EXP 76
101194: PUSH
101195: LD_EXP 115
101199: AND
101200: IFFALSE 101216
101202: GO 101204
101204: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101205: LD_STRING displayStucuk();
101207: PPUSH
101208: CALL_OW 559
// ResetFog ;
101212: CALL_OW 335
// end ;
101216: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101217: LD_EXP 76
101221: PUSH
101222: LD_EXP 108
101226: AND
101227: IFFALSE 101368
101229: GO 101231
101231: DISABLE
101232: LD_INT 0
101234: PPUSH
101235: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101236: LD_ADDR_VAR 0 2
101240: PUSH
101241: LD_INT 22
101243: PUSH
101244: LD_OWVAR 2
101248: PUSH
101249: EMPTY
101250: LIST
101251: LIST
101252: PUSH
101253: LD_INT 21
101255: PUSH
101256: LD_INT 1
101258: PUSH
101259: EMPTY
101260: LIST
101261: LIST
101262: PUSH
101263: EMPTY
101264: LIST
101265: LIST
101266: PPUSH
101267: CALL_OW 69
101271: ST_TO_ADDR
// if not tmp then
101272: LD_VAR 0 2
101276: NOT
101277: IFFALSE 101281
// exit ;
101279: GO 101368
// un := tmp [ rand ( 1 , tmp ) ] ;
101281: LD_ADDR_VAR 0 1
101285: PUSH
101286: LD_VAR 0 2
101290: PUSH
101291: LD_INT 1
101293: PPUSH
101294: LD_VAR 0 2
101298: PPUSH
101299: CALL_OW 12
101303: ARRAY
101304: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101305: LD_VAR 0 1
101309: PPUSH
101310: LD_INT 0
101312: PPUSH
101313: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101317: LD_VAR 0 1
101321: PPUSH
101322: LD_OWVAR 3
101326: PUSH
101327: LD_VAR 0 1
101331: DIFF
101332: PPUSH
101333: LD_VAR 0 1
101337: PPUSH
101338: CALL_OW 74
101342: PPUSH
101343: CALL_OW 115
// wait ( 0 0$20 ) ;
101347: LD_INT 700
101349: PPUSH
101350: CALL_OW 67
// SetSide ( un , your_side ) ;
101354: LD_VAR 0 1
101358: PPUSH
101359: LD_OWVAR 2
101363: PPUSH
101364: CALL_OW 235
// end ;
101368: PPOPN 2
101370: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101371: LD_EXP 76
101375: PUSH
101376: LD_EXP 109
101380: AND
101381: IFFALSE 101487
101383: GO 101385
101385: DISABLE
101386: LD_INT 0
101388: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101389: LD_ADDR_VAR 0 1
101393: PUSH
101394: LD_INT 22
101396: PUSH
101397: LD_OWVAR 2
101401: PUSH
101402: EMPTY
101403: LIST
101404: LIST
101405: PUSH
101406: LD_INT 2
101408: PUSH
101409: LD_INT 30
101411: PUSH
101412: LD_INT 0
101414: PUSH
101415: EMPTY
101416: LIST
101417: LIST
101418: PUSH
101419: LD_INT 30
101421: PUSH
101422: LD_INT 1
101424: PUSH
101425: EMPTY
101426: LIST
101427: LIST
101428: PUSH
101429: EMPTY
101430: LIST
101431: LIST
101432: LIST
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PPUSH
101438: CALL_OW 69
101442: ST_TO_ADDR
// if not depot then
101443: LD_VAR 0 1
101447: NOT
101448: IFFALSE 101452
// exit ;
101450: GO 101487
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101452: LD_VAR 0 1
101456: PUSH
101457: LD_INT 1
101459: ARRAY
101460: PPUSH
101461: CALL_OW 250
101465: PPUSH
101466: LD_VAR 0 1
101470: PUSH
101471: LD_INT 1
101473: ARRAY
101474: PPUSH
101475: CALL_OW 251
101479: PPUSH
101480: LD_INT 70
101482: PPUSH
101483: CALL_OW 495
// end ;
101487: PPOPN 1
101489: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101490: LD_EXP 76
101494: PUSH
101495: LD_EXP 110
101499: AND
101500: IFFALSE 101711
101502: GO 101504
101504: DISABLE
101505: LD_INT 0
101507: PPUSH
101508: PPUSH
101509: PPUSH
101510: PPUSH
101511: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101512: LD_ADDR_VAR 0 5
101516: PUSH
101517: LD_INT 22
101519: PUSH
101520: LD_OWVAR 2
101524: PUSH
101525: EMPTY
101526: LIST
101527: LIST
101528: PUSH
101529: LD_INT 21
101531: PUSH
101532: LD_INT 1
101534: PUSH
101535: EMPTY
101536: LIST
101537: LIST
101538: PUSH
101539: EMPTY
101540: LIST
101541: LIST
101542: PPUSH
101543: CALL_OW 69
101547: ST_TO_ADDR
// if not tmp then
101548: LD_VAR 0 5
101552: NOT
101553: IFFALSE 101557
// exit ;
101555: GO 101711
// for i in tmp do
101557: LD_ADDR_VAR 0 1
101561: PUSH
101562: LD_VAR 0 5
101566: PUSH
101567: FOR_IN
101568: IFFALSE 101709
// begin d := rand ( 0 , 5 ) ;
101570: LD_ADDR_VAR 0 4
101574: PUSH
101575: LD_INT 0
101577: PPUSH
101578: LD_INT 5
101580: PPUSH
101581: CALL_OW 12
101585: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101586: LD_ADDR_VAR 0 2
101590: PUSH
101591: LD_VAR 0 1
101595: PPUSH
101596: CALL_OW 250
101600: PPUSH
101601: LD_VAR 0 4
101605: PPUSH
101606: LD_INT 3
101608: PPUSH
101609: LD_INT 12
101611: PPUSH
101612: CALL_OW 12
101616: PPUSH
101617: CALL_OW 272
101621: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101622: LD_ADDR_VAR 0 3
101626: PUSH
101627: LD_VAR 0 1
101631: PPUSH
101632: CALL_OW 251
101636: PPUSH
101637: LD_VAR 0 4
101641: PPUSH
101642: LD_INT 3
101644: PPUSH
101645: LD_INT 12
101647: PPUSH
101648: CALL_OW 12
101652: PPUSH
101653: CALL_OW 273
101657: ST_TO_ADDR
// if ValidHex ( x , y ) then
101658: LD_VAR 0 2
101662: PPUSH
101663: LD_VAR 0 3
101667: PPUSH
101668: CALL_OW 488
101672: IFFALSE 101707
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101674: LD_VAR 0 1
101678: PPUSH
101679: LD_VAR 0 2
101683: PPUSH
101684: LD_VAR 0 3
101688: PPUSH
101689: LD_INT 3
101691: PPUSH
101692: LD_INT 6
101694: PPUSH
101695: CALL_OW 12
101699: PPUSH
101700: LD_INT 1
101702: PPUSH
101703: CALL_OW 483
// end ;
101707: GO 101567
101709: POP
101710: POP
// end ;
101711: PPOPN 5
101713: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101714: LD_EXP 76
101718: PUSH
101719: LD_EXP 111
101723: AND
101724: IFFALSE 101818
101726: GO 101728
101728: DISABLE
101729: LD_INT 0
101731: PPUSH
101732: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101733: LD_ADDR_VAR 0 2
101737: PUSH
101738: LD_INT 22
101740: PUSH
101741: LD_OWVAR 2
101745: PUSH
101746: EMPTY
101747: LIST
101748: LIST
101749: PUSH
101750: LD_INT 32
101752: PUSH
101753: LD_INT 1
101755: PUSH
101756: EMPTY
101757: LIST
101758: LIST
101759: PUSH
101760: LD_INT 21
101762: PUSH
101763: LD_INT 2
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: PUSH
101770: EMPTY
101771: LIST
101772: LIST
101773: LIST
101774: PPUSH
101775: CALL_OW 69
101779: ST_TO_ADDR
// if not tmp then
101780: LD_VAR 0 2
101784: NOT
101785: IFFALSE 101789
// exit ;
101787: GO 101818
// for i in tmp do
101789: LD_ADDR_VAR 0 1
101793: PUSH
101794: LD_VAR 0 2
101798: PUSH
101799: FOR_IN
101800: IFFALSE 101816
// SetFuel ( i , 0 ) ;
101802: LD_VAR 0 1
101806: PPUSH
101807: LD_INT 0
101809: PPUSH
101810: CALL_OW 240
101814: GO 101799
101816: POP
101817: POP
// end ;
101818: PPOPN 2
101820: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101821: LD_EXP 76
101825: PUSH
101826: LD_EXP 112
101830: AND
101831: IFFALSE 101897
101833: GO 101835
101835: DISABLE
101836: LD_INT 0
101838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101839: LD_ADDR_VAR 0 1
101843: PUSH
101844: LD_INT 22
101846: PUSH
101847: LD_OWVAR 2
101851: PUSH
101852: EMPTY
101853: LIST
101854: LIST
101855: PUSH
101856: LD_INT 30
101858: PUSH
101859: LD_INT 29
101861: PUSH
101862: EMPTY
101863: LIST
101864: LIST
101865: PUSH
101866: EMPTY
101867: LIST
101868: LIST
101869: PPUSH
101870: CALL_OW 69
101874: ST_TO_ADDR
// if not tmp then
101875: LD_VAR 0 1
101879: NOT
101880: IFFALSE 101884
// exit ;
101882: GO 101897
// DestroyUnit ( tmp [ 1 ] ) ;
101884: LD_VAR 0 1
101888: PUSH
101889: LD_INT 1
101891: ARRAY
101892: PPUSH
101893: CALL_OW 65
// end ;
101897: PPOPN 1
101899: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101900: LD_EXP 76
101904: PUSH
101905: LD_EXP 114
101909: AND
101910: IFFALSE 102039
101912: GO 101914
101914: DISABLE
101915: LD_INT 0
101917: PPUSH
// begin uc_side := 0 ;
101918: LD_ADDR_OWVAR 20
101922: PUSH
101923: LD_INT 0
101925: ST_TO_ADDR
// uc_nation := nation_arabian ;
101926: LD_ADDR_OWVAR 21
101930: PUSH
101931: LD_INT 2
101933: ST_TO_ADDR
// hc_gallery :=  ;
101934: LD_ADDR_OWVAR 33
101938: PUSH
101939: LD_STRING 
101941: ST_TO_ADDR
// hc_name :=  ;
101942: LD_ADDR_OWVAR 26
101946: PUSH
101947: LD_STRING 
101949: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101950: LD_INT 1
101952: PPUSH
101953: LD_INT 11
101955: PPUSH
101956: LD_INT 10
101958: PPUSH
101959: CALL_OW 380
// un := CreateHuman ;
101963: LD_ADDR_VAR 0 1
101967: PUSH
101968: CALL_OW 44
101972: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101973: LD_VAR 0 1
101977: PPUSH
101978: LD_INT 1
101980: PPUSH
101981: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101985: LD_INT 35
101987: PPUSH
101988: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101992: LD_VAR 0 1
101996: PPUSH
101997: LD_INT 22
101999: PUSH
102000: LD_OWVAR 2
102004: PUSH
102005: EMPTY
102006: LIST
102007: LIST
102008: PPUSH
102009: CALL_OW 69
102013: PPUSH
102014: LD_VAR 0 1
102018: PPUSH
102019: CALL_OW 74
102023: PPUSH
102024: CALL_OW 115
// until IsDead ( un ) ;
102028: LD_VAR 0 1
102032: PPUSH
102033: CALL_OW 301
102037: IFFALSE 101985
// end ;
102039: PPOPN 1
102041: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102042: LD_EXP 76
102046: PUSH
102047: LD_EXP 116
102051: AND
102052: IFFALSE 102064
102054: GO 102056
102056: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102057: LD_STRING earthquake(getX(game), 0, 32)
102059: PPUSH
102060: CALL_OW 559
102064: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102065: LD_EXP 76
102069: PUSH
102070: LD_EXP 117
102074: AND
102075: IFFALSE 102166
102077: GO 102079
102079: DISABLE
102080: LD_INT 0
102082: PPUSH
// begin enable ;
102083: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102084: LD_ADDR_VAR 0 1
102088: PUSH
102089: LD_INT 22
102091: PUSH
102092: LD_OWVAR 2
102096: PUSH
102097: EMPTY
102098: LIST
102099: LIST
102100: PUSH
102101: LD_INT 21
102103: PUSH
102104: LD_INT 2
102106: PUSH
102107: EMPTY
102108: LIST
102109: LIST
102110: PUSH
102111: LD_INT 33
102113: PUSH
102114: LD_INT 3
102116: PUSH
102117: EMPTY
102118: LIST
102119: LIST
102120: PUSH
102121: EMPTY
102122: LIST
102123: LIST
102124: LIST
102125: PPUSH
102126: CALL_OW 69
102130: ST_TO_ADDR
// if not tmp then
102131: LD_VAR 0 1
102135: NOT
102136: IFFALSE 102140
// exit ;
102138: GO 102166
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102140: LD_VAR 0 1
102144: PUSH
102145: LD_INT 1
102147: PPUSH
102148: LD_VAR 0 1
102152: PPUSH
102153: CALL_OW 12
102157: ARRAY
102158: PPUSH
102159: LD_INT 1
102161: PPUSH
102162: CALL_OW 234
// end ;
102166: PPOPN 1
102168: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102169: LD_EXP 76
102173: PUSH
102174: LD_EXP 118
102178: AND
102179: IFFALSE 102320
102181: GO 102183
102183: DISABLE
102184: LD_INT 0
102186: PPUSH
102187: PPUSH
102188: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102189: LD_ADDR_VAR 0 3
102193: PUSH
102194: LD_INT 22
102196: PUSH
102197: LD_OWVAR 2
102201: PUSH
102202: EMPTY
102203: LIST
102204: LIST
102205: PUSH
102206: LD_INT 25
102208: PUSH
102209: LD_INT 1
102211: PUSH
102212: EMPTY
102213: LIST
102214: LIST
102215: PUSH
102216: EMPTY
102217: LIST
102218: LIST
102219: PPUSH
102220: CALL_OW 69
102224: ST_TO_ADDR
// if not tmp then
102225: LD_VAR 0 3
102229: NOT
102230: IFFALSE 102234
// exit ;
102232: GO 102320
// un := tmp [ rand ( 1 , tmp ) ] ;
102234: LD_ADDR_VAR 0 2
102238: PUSH
102239: LD_VAR 0 3
102243: PUSH
102244: LD_INT 1
102246: PPUSH
102247: LD_VAR 0 3
102251: PPUSH
102252: CALL_OW 12
102256: ARRAY
102257: ST_TO_ADDR
// if Crawls ( un ) then
102258: LD_VAR 0 2
102262: PPUSH
102263: CALL_OW 318
102267: IFFALSE 102278
// ComWalk ( un ) ;
102269: LD_VAR 0 2
102273: PPUSH
102274: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102278: LD_VAR 0 2
102282: PPUSH
102283: LD_INT 9
102285: PPUSH
102286: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102290: LD_INT 28
102292: PPUSH
102293: LD_OWVAR 2
102297: PPUSH
102298: LD_INT 2
102300: PPUSH
102301: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102305: LD_INT 29
102307: PPUSH
102308: LD_OWVAR 2
102312: PPUSH
102313: LD_INT 2
102315: PPUSH
102316: CALL_OW 322
// end ;
102320: PPOPN 3
102322: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102323: LD_EXP 76
102327: PUSH
102328: LD_EXP 119
102332: AND
102333: IFFALSE 102444
102335: GO 102337
102337: DISABLE
102338: LD_INT 0
102340: PPUSH
102341: PPUSH
102342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102343: LD_ADDR_VAR 0 3
102347: PUSH
102348: LD_INT 22
102350: PUSH
102351: LD_OWVAR 2
102355: PUSH
102356: EMPTY
102357: LIST
102358: LIST
102359: PUSH
102360: LD_INT 25
102362: PUSH
102363: LD_INT 1
102365: PUSH
102366: EMPTY
102367: LIST
102368: LIST
102369: PUSH
102370: EMPTY
102371: LIST
102372: LIST
102373: PPUSH
102374: CALL_OW 69
102378: ST_TO_ADDR
// if not tmp then
102379: LD_VAR 0 3
102383: NOT
102384: IFFALSE 102388
// exit ;
102386: GO 102444
// un := tmp [ rand ( 1 , tmp ) ] ;
102388: LD_ADDR_VAR 0 2
102392: PUSH
102393: LD_VAR 0 3
102397: PUSH
102398: LD_INT 1
102400: PPUSH
102401: LD_VAR 0 3
102405: PPUSH
102406: CALL_OW 12
102410: ARRAY
102411: ST_TO_ADDR
// if Crawls ( un ) then
102412: LD_VAR 0 2
102416: PPUSH
102417: CALL_OW 318
102421: IFFALSE 102432
// ComWalk ( un ) ;
102423: LD_VAR 0 2
102427: PPUSH
102428: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102432: LD_VAR 0 2
102436: PPUSH
102437: LD_INT 8
102439: PPUSH
102440: CALL_OW 336
// end ;
102444: PPOPN 3
102446: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102447: LD_EXP 76
102451: PUSH
102452: LD_EXP 120
102456: AND
102457: IFFALSE 102601
102459: GO 102461
102461: DISABLE
102462: LD_INT 0
102464: PPUSH
102465: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102466: LD_ADDR_VAR 0 2
102470: PUSH
102471: LD_INT 22
102473: PUSH
102474: LD_OWVAR 2
102478: PUSH
102479: EMPTY
102480: LIST
102481: LIST
102482: PUSH
102483: LD_INT 21
102485: PUSH
102486: LD_INT 2
102488: PUSH
102489: EMPTY
102490: LIST
102491: LIST
102492: PUSH
102493: LD_INT 2
102495: PUSH
102496: LD_INT 34
102498: PUSH
102499: LD_INT 12
102501: PUSH
102502: EMPTY
102503: LIST
102504: LIST
102505: PUSH
102506: LD_INT 34
102508: PUSH
102509: LD_INT 51
102511: PUSH
102512: EMPTY
102513: LIST
102514: LIST
102515: PUSH
102516: LD_INT 34
102518: PUSH
102519: LD_INT 32
102521: PUSH
102522: EMPTY
102523: LIST
102524: LIST
102525: PUSH
102526: EMPTY
102527: LIST
102528: LIST
102529: LIST
102530: LIST
102531: PUSH
102532: EMPTY
102533: LIST
102534: LIST
102535: LIST
102536: PPUSH
102537: CALL_OW 69
102541: ST_TO_ADDR
// if not tmp then
102542: LD_VAR 0 2
102546: NOT
102547: IFFALSE 102551
// exit ;
102549: GO 102601
// for i in tmp do
102551: LD_ADDR_VAR 0 1
102555: PUSH
102556: LD_VAR 0 2
102560: PUSH
102561: FOR_IN
102562: IFFALSE 102599
// if GetCargo ( i , mat_artifact ) = 0 then
102564: LD_VAR 0 1
102568: PPUSH
102569: LD_INT 4
102571: PPUSH
102572: CALL_OW 289
102576: PUSH
102577: LD_INT 0
102579: EQUAL
102580: IFFALSE 102597
// SetCargo ( i , mat_siberit , 100 ) ;
102582: LD_VAR 0 1
102586: PPUSH
102587: LD_INT 3
102589: PPUSH
102590: LD_INT 100
102592: PPUSH
102593: CALL_OW 290
102597: GO 102561
102599: POP
102600: POP
// end ;
102601: PPOPN 2
102603: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102604: LD_EXP 76
102608: PUSH
102609: LD_EXP 121
102613: AND
102614: IFFALSE 102797
102616: GO 102618
102618: DISABLE
102619: LD_INT 0
102621: PPUSH
102622: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102623: LD_ADDR_VAR 0 2
102627: PUSH
102628: LD_INT 22
102630: PUSH
102631: LD_OWVAR 2
102635: PUSH
102636: EMPTY
102637: LIST
102638: LIST
102639: PPUSH
102640: CALL_OW 69
102644: ST_TO_ADDR
// if not tmp then
102645: LD_VAR 0 2
102649: NOT
102650: IFFALSE 102654
// exit ;
102652: GO 102797
// for i := 1 to 2 do
102654: LD_ADDR_VAR 0 1
102658: PUSH
102659: DOUBLE
102660: LD_INT 1
102662: DEC
102663: ST_TO_ADDR
102664: LD_INT 2
102666: PUSH
102667: FOR_TO
102668: IFFALSE 102795
// begin uc_side := your_side ;
102670: LD_ADDR_OWVAR 20
102674: PUSH
102675: LD_OWVAR 2
102679: ST_TO_ADDR
// uc_nation := nation_american ;
102680: LD_ADDR_OWVAR 21
102684: PUSH
102685: LD_INT 1
102687: ST_TO_ADDR
// vc_chassis := us_morphling ;
102688: LD_ADDR_OWVAR 37
102692: PUSH
102693: LD_INT 5
102695: ST_TO_ADDR
// vc_engine := engine_siberite ;
102696: LD_ADDR_OWVAR 39
102700: PUSH
102701: LD_INT 3
102703: ST_TO_ADDR
// vc_control := control_computer ;
102704: LD_ADDR_OWVAR 38
102708: PUSH
102709: LD_INT 3
102711: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102712: LD_ADDR_OWVAR 40
102716: PUSH
102717: LD_INT 10
102719: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102720: LD_VAR 0 2
102724: PUSH
102725: LD_INT 1
102727: ARRAY
102728: PPUSH
102729: CALL_OW 310
102733: NOT
102734: IFFALSE 102781
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102736: CALL_OW 45
102740: PPUSH
102741: LD_VAR 0 2
102745: PUSH
102746: LD_INT 1
102748: ARRAY
102749: PPUSH
102750: CALL_OW 250
102754: PPUSH
102755: LD_VAR 0 2
102759: PUSH
102760: LD_INT 1
102762: ARRAY
102763: PPUSH
102764: CALL_OW 251
102768: PPUSH
102769: LD_INT 12
102771: PPUSH
102772: LD_INT 1
102774: PPUSH
102775: CALL_OW 50
102779: GO 102793
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102781: CALL_OW 45
102785: PPUSH
102786: LD_INT 1
102788: PPUSH
102789: CALL_OW 51
// end ;
102793: GO 102667
102795: POP
102796: POP
// end ;
102797: PPOPN 2
102799: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102800: LD_EXP 76
102804: PUSH
102805: LD_EXP 122
102809: AND
102810: IFFALSE 103032
102812: GO 102814
102814: DISABLE
102815: LD_INT 0
102817: PPUSH
102818: PPUSH
102819: PPUSH
102820: PPUSH
102821: PPUSH
102822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102823: LD_ADDR_VAR 0 6
102827: PUSH
102828: LD_INT 22
102830: PUSH
102831: LD_OWVAR 2
102835: PUSH
102836: EMPTY
102837: LIST
102838: LIST
102839: PUSH
102840: LD_INT 21
102842: PUSH
102843: LD_INT 1
102845: PUSH
102846: EMPTY
102847: LIST
102848: LIST
102849: PUSH
102850: LD_INT 3
102852: PUSH
102853: LD_INT 23
102855: PUSH
102856: LD_INT 0
102858: PUSH
102859: EMPTY
102860: LIST
102861: LIST
102862: PUSH
102863: EMPTY
102864: LIST
102865: LIST
102866: PUSH
102867: EMPTY
102868: LIST
102869: LIST
102870: LIST
102871: PPUSH
102872: CALL_OW 69
102876: ST_TO_ADDR
// if not tmp then
102877: LD_VAR 0 6
102881: NOT
102882: IFFALSE 102886
// exit ;
102884: GO 103032
// s1 := rand ( 1 , 4 ) ;
102886: LD_ADDR_VAR 0 2
102890: PUSH
102891: LD_INT 1
102893: PPUSH
102894: LD_INT 4
102896: PPUSH
102897: CALL_OW 12
102901: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102902: LD_ADDR_VAR 0 4
102906: PUSH
102907: LD_VAR 0 6
102911: PUSH
102912: LD_INT 1
102914: ARRAY
102915: PPUSH
102916: LD_VAR 0 2
102920: PPUSH
102921: CALL_OW 259
102925: ST_TO_ADDR
// if s1 = 1 then
102926: LD_VAR 0 2
102930: PUSH
102931: LD_INT 1
102933: EQUAL
102934: IFFALSE 102954
// s2 := rand ( 2 , 4 ) else
102936: LD_ADDR_VAR 0 3
102940: PUSH
102941: LD_INT 2
102943: PPUSH
102944: LD_INT 4
102946: PPUSH
102947: CALL_OW 12
102951: ST_TO_ADDR
102952: GO 102962
// s2 := 1 ;
102954: LD_ADDR_VAR 0 3
102958: PUSH
102959: LD_INT 1
102961: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102962: LD_ADDR_VAR 0 5
102966: PUSH
102967: LD_VAR 0 6
102971: PUSH
102972: LD_INT 1
102974: ARRAY
102975: PPUSH
102976: LD_VAR 0 3
102980: PPUSH
102981: CALL_OW 259
102985: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102986: LD_VAR 0 6
102990: PUSH
102991: LD_INT 1
102993: ARRAY
102994: PPUSH
102995: LD_VAR 0 2
102999: PPUSH
103000: LD_VAR 0 5
103004: PPUSH
103005: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103009: LD_VAR 0 6
103013: PUSH
103014: LD_INT 1
103016: ARRAY
103017: PPUSH
103018: LD_VAR 0 3
103022: PPUSH
103023: LD_VAR 0 4
103027: PPUSH
103028: CALL_OW 237
// end ;
103032: PPOPN 6
103034: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103035: LD_EXP 76
103039: PUSH
103040: LD_EXP 123
103044: AND
103045: IFFALSE 103124
103047: GO 103049
103049: DISABLE
103050: LD_INT 0
103052: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103053: LD_ADDR_VAR 0 1
103057: PUSH
103058: LD_INT 22
103060: PUSH
103061: LD_OWVAR 2
103065: PUSH
103066: EMPTY
103067: LIST
103068: LIST
103069: PUSH
103070: LD_INT 30
103072: PUSH
103073: LD_INT 3
103075: PUSH
103076: EMPTY
103077: LIST
103078: LIST
103079: PUSH
103080: EMPTY
103081: LIST
103082: LIST
103083: PPUSH
103084: CALL_OW 69
103088: ST_TO_ADDR
// if not tmp then
103089: LD_VAR 0 1
103093: NOT
103094: IFFALSE 103098
// exit ;
103096: GO 103124
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103098: LD_VAR 0 1
103102: PUSH
103103: LD_INT 1
103105: PPUSH
103106: LD_VAR 0 1
103110: PPUSH
103111: CALL_OW 12
103115: ARRAY
103116: PPUSH
103117: LD_INT 1
103119: PPUSH
103120: CALL_OW 234
// end ;
103124: PPOPN 1
103126: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103127: LD_EXP 76
103131: PUSH
103132: LD_EXP 124
103136: AND
103137: IFFALSE 103249
103139: GO 103141
103141: DISABLE
103142: LD_INT 0
103144: PPUSH
103145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103146: LD_ADDR_VAR 0 2
103150: PUSH
103151: LD_INT 22
103153: PUSH
103154: LD_OWVAR 2
103158: PUSH
103159: EMPTY
103160: LIST
103161: LIST
103162: PUSH
103163: LD_INT 2
103165: PUSH
103166: LD_INT 30
103168: PUSH
103169: LD_INT 27
103171: PUSH
103172: EMPTY
103173: LIST
103174: LIST
103175: PUSH
103176: LD_INT 30
103178: PUSH
103179: LD_INT 26
103181: PUSH
103182: EMPTY
103183: LIST
103184: LIST
103185: PUSH
103186: LD_INT 30
103188: PUSH
103189: LD_INT 28
103191: PUSH
103192: EMPTY
103193: LIST
103194: LIST
103195: PUSH
103196: EMPTY
103197: LIST
103198: LIST
103199: LIST
103200: LIST
103201: PUSH
103202: EMPTY
103203: LIST
103204: LIST
103205: PPUSH
103206: CALL_OW 69
103210: ST_TO_ADDR
// if not tmp then
103211: LD_VAR 0 2
103215: NOT
103216: IFFALSE 103220
// exit ;
103218: GO 103249
// for i in tmp do
103220: LD_ADDR_VAR 0 1
103224: PUSH
103225: LD_VAR 0 2
103229: PUSH
103230: FOR_IN
103231: IFFALSE 103247
// SetLives ( i , 1 ) ;
103233: LD_VAR 0 1
103237: PPUSH
103238: LD_INT 1
103240: PPUSH
103241: CALL_OW 234
103245: GO 103230
103247: POP
103248: POP
// end ;
103249: PPOPN 2
103251: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103252: LD_EXP 76
103256: PUSH
103257: LD_EXP 125
103261: AND
103262: IFFALSE 103549
103264: GO 103266
103266: DISABLE
103267: LD_INT 0
103269: PPUSH
103270: PPUSH
103271: PPUSH
// begin i := rand ( 1 , 7 ) ;
103272: LD_ADDR_VAR 0 1
103276: PUSH
103277: LD_INT 1
103279: PPUSH
103280: LD_INT 7
103282: PPUSH
103283: CALL_OW 12
103287: ST_TO_ADDR
// case i of 1 :
103288: LD_VAR 0 1
103292: PUSH
103293: LD_INT 1
103295: DOUBLE
103296: EQUAL
103297: IFTRUE 103301
103299: GO 103311
103301: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103302: LD_STRING earthquake(getX(game), 0, 32)
103304: PPUSH
103305: CALL_OW 559
103309: GO 103549
103311: LD_INT 2
103313: DOUBLE
103314: EQUAL
103315: IFTRUE 103319
103317: GO 103333
103319: POP
// begin ToLua ( displayStucuk(); ) ;
103320: LD_STRING displayStucuk();
103322: PPUSH
103323: CALL_OW 559
// ResetFog ;
103327: CALL_OW 335
// end ; 3 :
103331: GO 103549
103333: LD_INT 3
103335: DOUBLE
103336: EQUAL
103337: IFTRUE 103341
103339: GO 103445
103341: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103342: LD_ADDR_VAR 0 2
103346: PUSH
103347: LD_INT 22
103349: PUSH
103350: LD_OWVAR 2
103354: PUSH
103355: EMPTY
103356: LIST
103357: LIST
103358: PUSH
103359: LD_INT 25
103361: PUSH
103362: LD_INT 1
103364: PUSH
103365: EMPTY
103366: LIST
103367: LIST
103368: PUSH
103369: EMPTY
103370: LIST
103371: LIST
103372: PPUSH
103373: CALL_OW 69
103377: ST_TO_ADDR
// if not tmp then
103378: LD_VAR 0 2
103382: NOT
103383: IFFALSE 103387
// exit ;
103385: GO 103549
// un := tmp [ rand ( 1 , tmp ) ] ;
103387: LD_ADDR_VAR 0 3
103391: PUSH
103392: LD_VAR 0 2
103396: PUSH
103397: LD_INT 1
103399: PPUSH
103400: LD_VAR 0 2
103404: PPUSH
103405: CALL_OW 12
103409: ARRAY
103410: ST_TO_ADDR
// if Crawls ( un ) then
103411: LD_VAR 0 3
103415: PPUSH
103416: CALL_OW 318
103420: IFFALSE 103431
// ComWalk ( un ) ;
103422: LD_VAR 0 3
103426: PPUSH
103427: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103431: LD_VAR 0 3
103435: PPUSH
103436: LD_INT 8
103438: PPUSH
103439: CALL_OW 336
// end ; 4 :
103443: GO 103549
103445: LD_INT 4
103447: DOUBLE
103448: EQUAL
103449: IFTRUE 103453
103451: GO 103527
103453: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103454: LD_ADDR_VAR 0 2
103458: PUSH
103459: LD_INT 22
103461: PUSH
103462: LD_OWVAR 2
103466: PUSH
103467: EMPTY
103468: LIST
103469: LIST
103470: PUSH
103471: LD_INT 30
103473: PUSH
103474: LD_INT 29
103476: PUSH
103477: EMPTY
103478: LIST
103479: LIST
103480: PUSH
103481: EMPTY
103482: LIST
103483: LIST
103484: PPUSH
103485: CALL_OW 69
103489: ST_TO_ADDR
// if not tmp then
103490: LD_VAR 0 2
103494: NOT
103495: IFFALSE 103499
// exit ;
103497: GO 103549
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103499: LD_VAR 0 2
103503: PUSH
103504: LD_INT 1
103506: ARRAY
103507: PPUSH
103508: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103512: LD_VAR 0 2
103516: PUSH
103517: LD_INT 1
103519: ARRAY
103520: PPUSH
103521: CALL_OW 65
// end ; 5 .. 7 :
103525: GO 103549
103527: LD_INT 5
103529: DOUBLE
103530: GREATEREQUAL
103531: IFFALSE 103539
103533: LD_INT 7
103535: DOUBLE
103536: LESSEQUAL
103537: IFTRUE 103541
103539: GO 103548
103541: POP
// StreamSibBomb ; end ;
103542: CALL 99786 0 0
103546: GO 103549
103548: POP
// end ;
103549: PPOPN 3
103551: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103552: LD_EXP 76
103556: PUSH
103557: LD_EXP 126
103561: AND
103562: IFFALSE 103718
103564: GO 103566
103566: DISABLE
103567: LD_INT 0
103569: PPUSH
103570: PPUSH
103571: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103572: LD_ADDR_VAR 0 2
103576: PUSH
103577: LD_INT 81
103579: PUSH
103580: LD_OWVAR 2
103584: PUSH
103585: EMPTY
103586: LIST
103587: LIST
103588: PUSH
103589: LD_INT 2
103591: PUSH
103592: LD_INT 21
103594: PUSH
103595: LD_INT 1
103597: PUSH
103598: EMPTY
103599: LIST
103600: LIST
103601: PUSH
103602: LD_INT 21
103604: PUSH
103605: LD_INT 2
103607: PUSH
103608: EMPTY
103609: LIST
103610: LIST
103611: PUSH
103612: EMPTY
103613: LIST
103614: LIST
103615: LIST
103616: PUSH
103617: EMPTY
103618: LIST
103619: LIST
103620: PPUSH
103621: CALL_OW 69
103625: ST_TO_ADDR
// if not tmp then
103626: LD_VAR 0 2
103630: NOT
103631: IFFALSE 103635
// exit ;
103633: GO 103718
// p := 0 ;
103635: LD_ADDR_VAR 0 3
103639: PUSH
103640: LD_INT 0
103642: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103643: LD_INT 35
103645: PPUSH
103646: CALL_OW 67
// p := p + 1 ;
103650: LD_ADDR_VAR 0 3
103654: PUSH
103655: LD_VAR 0 3
103659: PUSH
103660: LD_INT 1
103662: PLUS
103663: ST_TO_ADDR
// for i in tmp do
103664: LD_ADDR_VAR 0 1
103668: PUSH
103669: LD_VAR 0 2
103673: PUSH
103674: FOR_IN
103675: IFFALSE 103706
// if GetLives ( i ) < 1000 then
103677: LD_VAR 0 1
103681: PPUSH
103682: CALL_OW 256
103686: PUSH
103687: LD_INT 1000
103689: LESS
103690: IFFALSE 103704
// SetLives ( i , 1000 ) ;
103692: LD_VAR 0 1
103696: PPUSH
103697: LD_INT 1000
103699: PPUSH
103700: CALL_OW 234
103704: GO 103674
103706: POP
103707: POP
// until p > 20 ;
103708: LD_VAR 0 3
103712: PUSH
103713: LD_INT 20
103715: GREATER
103716: IFFALSE 103643
// end ;
103718: PPOPN 3
103720: END
// every 0 0$1 trigger StreamModeActive and sTime do
103721: LD_EXP 76
103725: PUSH
103726: LD_EXP 127
103730: AND
103731: IFFALSE 103766
103733: GO 103735
103735: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103736: LD_INT 28
103738: PPUSH
103739: LD_OWVAR 2
103743: PPUSH
103744: LD_INT 2
103746: PPUSH
103747: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103751: LD_INT 30
103753: PPUSH
103754: LD_OWVAR 2
103758: PPUSH
103759: LD_INT 2
103761: PPUSH
103762: CALL_OW 322
// end ;
103766: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103767: LD_EXP 76
103771: PUSH
103772: LD_EXP 128
103776: AND
103777: IFFALSE 103898
103779: GO 103781
103781: DISABLE
103782: LD_INT 0
103784: PPUSH
103785: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103786: LD_ADDR_VAR 0 2
103790: PUSH
103791: LD_INT 22
103793: PUSH
103794: LD_OWVAR 2
103798: PUSH
103799: EMPTY
103800: LIST
103801: LIST
103802: PUSH
103803: LD_INT 21
103805: PUSH
103806: LD_INT 1
103808: PUSH
103809: EMPTY
103810: LIST
103811: LIST
103812: PUSH
103813: LD_INT 3
103815: PUSH
103816: LD_INT 23
103818: PUSH
103819: LD_INT 0
103821: PUSH
103822: EMPTY
103823: LIST
103824: LIST
103825: PUSH
103826: EMPTY
103827: LIST
103828: LIST
103829: PUSH
103830: EMPTY
103831: LIST
103832: LIST
103833: LIST
103834: PPUSH
103835: CALL_OW 69
103839: ST_TO_ADDR
// if not tmp then
103840: LD_VAR 0 2
103844: NOT
103845: IFFALSE 103849
// exit ;
103847: GO 103898
// for i in tmp do
103849: LD_ADDR_VAR 0 1
103853: PUSH
103854: LD_VAR 0 2
103858: PUSH
103859: FOR_IN
103860: IFFALSE 103896
// begin if Crawls ( i ) then
103862: LD_VAR 0 1
103866: PPUSH
103867: CALL_OW 318
103871: IFFALSE 103882
// ComWalk ( i ) ;
103873: LD_VAR 0 1
103877: PPUSH
103878: CALL_OW 138
// SetClass ( i , 2 ) ;
103882: LD_VAR 0 1
103886: PPUSH
103887: LD_INT 2
103889: PPUSH
103890: CALL_OW 336
// end ;
103894: GO 103859
103896: POP
103897: POP
// end ;
103898: PPOPN 2
103900: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103901: LD_EXP 76
103905: PUSH
103906: LD_EXP 129
103910: AND
103911: IFFALSE 104199
103913: GO 103915
103915: DISABLE
103916: LD_INT 0
103918: PPUSH
103919: PPUSH
103920: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103921: LD_OWVAR 2
103925: PPUSH
103926: LD_INT 9
103928: PPUSH
103929: LD_INT 1
103931: PPUSH
103932: LD_INT 1
103934: PPUSH
103935: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103939: LD_INT 9
103941: PPUSH
103942: LD_OWVAR 2
103946: PPUSH
103947: CALL_OW 343
// uc_side := 9 ;
103951: LD_ADDR_OWVAR 20
103955: PUSH
103956: LD_INT 9
103958: ST_TO_ADDR
// uc_nation := 2 ;
103959: LD_ADDR_OWVAR 21
103963: PUSH
103964: LD_INT 2
103966: ST_TO_ADDR
// hc_name := Dark Warrior ;
103967: LD_ADDR_OWVAR 26
103971: PUSH
103972: LD_STRING Dark Warrior
103974: ST_TO_ADDR
// hc_gallery :=  ;
103975: LD_ADDR_OWVAR 33
103979: PUSH
103980: LD_STRING 
103982: ST_TO_ADDR
// hc_noskilllimit := true ;
103983: LD_ADDR_OWVAR 76
103987: PUSH
103988: LD_INT 1
103990: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103991: LD_ADDR_OWVAR 31
103995: PUSH
103996: LD_INT 30
103998: PUSH
103999: LD_INT 30
104001: PUSH
104002: LD_INT 30
104004: PUSH
104005: LD_INT 30
104007: PUSH
104008: EMPTY
104009: LIST
104010: LIST
104011: LIST
104012: LIST
104013: ST_TO_ADDR
// un := CreateHuman ;
104014: LD_ADDR_VAR 0 3
104018: PUSH
104019: CALL_OW 44
104023: ST_TO_ADDR
// hc_noskilllimit := false ;
104024: LD_ADDR_OWVAR 76
104028: PUSH
104029: LD_INT 0
104031: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104032: LD_VAR 0 3
104036: PPUSH
104037: LD_INT 1
104039: PPUSH
104040: CALL_OW 51
// ToLua ( playRanger() ) ;
104044: LD_STRING playRanger()
104046: PPUSH
104047: CALL_OW 559
// p := 0 ;
104051: LD_ADDR_VAR 0 2
104055: PUSH
104056: LD_INT 0
104058: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104059: LD_INT 35
104061: PPUSH
104062: CALL_OW 67
// p := p + 1 ;
104066: LD_ADDR_VAR 0 2
104070: PUSH
104071: LD_VAR 0 2
104075: PUSH
104076: LD_INT 1
104078: PLUS
104079: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104080: LD_VAR 0 3
104084: PPUSH
104085: CALL_OW 256
104089: PUSH
104090: LD_INT 1000
104092: LESS
104093: IFFALSE 104107
// SetLives ( un , 1000 ) ;
104095: LD_VAR 0 3
104099: PPUSH
104100: LD_INT 1000
104102: PPUSH
104103: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104107: LD_VAR 0 3
104111: PPUSH
104112: LD_INT 81
104114: PUSH
104115: LD_OWVAR 2
104119: PUSH
104120: EMPTY
104121: LIST
104122: LIST
104123: PUSH
104124: LD_INT 91
104126: PUSH
104127: LD_VAR 0 3
104131: PUSH
104132: LD_INT 30
104134: PUSH
104135: EMPTY
104136: LIST
104137: LIST
104138: LIST
104139: PUSH
104140: EMPTY
104141: LIST
104142: LIST
104143: PPUSH
104144: CALL_OW 69
104148: PPUSH
104149: LD_VAR 0 3
104153: PPUSH
104154: CALL_OW 74
104158: PPUSH
104159: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104163: LD_VAR 0 2
104167: PUSH
104168: LD_INT 80
104170: GREATER
104171: PUSH
104172: LD_VAR 0 3
104176: PPUSH
104177: CALL_OW 301
104181: OR
104182: IFFALSE 104059
// if un then
104184: LD_VAR 0 3
104188: IFFALSE 104199
// RemoveUnit ( un ) ;
104190: LD_VAR 0 3
104194: PPUSH
104195: CALL_OW 64
// end ;
104199: PPOPN 3
104201: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104202: LD_EXP 130
104206: IFFALSE 104322
104208: GO 104210
104210: DISABLE
104211: LD_INT 0
104213: PPUSH
104214: PPUSH
104215: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104216: LD_ADDR_VAR 0 2
104220: PUSH
104221: LD_INT 81
104223: PUSH
104224: LD_OWVAR 2
104228: PUSH
104229: EMPTY
104230: LIST
104231: LIST
104232: PUSH
104233: LD_INT 21
104235: PUSH
104236: LD_INT 1
104238: PUSH
104239: EMPTY
104240: LIST
104241: LIST
104242: PUSH
104243: EMPTY
104244: LIST
104245: LIST
104246: PPUSH
104247: CALL_OW 69
104251: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104252: LD_STRING playComputer()
104254: PPUSH
104255: CALL_OW 559
// if not tmp then
104259: LD_VAR 0 2
104263: NOT
104264: IFFALSE 104268
// exit ;
104266: GO 104322
// for i in tmp do
104268: LD_ADDR_VAR 0 1
104272: PUSH
104273: LD_VAR 0 2
104277: PUSH
104278: FOR_IN
104279: IFFALSE 104320
// for j := 1 to 4 do
104281: LD_ADDR_VAR 0 3
104285: PUSH
104286: DOUBLE
104287: LD_INT 1
104289: DEC
104290: ST_TO_ADDR
104291: LD_INT 4
104293: PUSH
104294: FOR_TO
104295: IFFALSE 104316
// SetSkill ( i , j , 10 ) ;
104297: LD_VAR 0 1
104301: PPUSH
104302: LD_VAR 0 3
104306: PPUSH
104307: LD_INT 10
104309: PPUSH
104310: CALL_OW 237
104314: GO 104294
104316: POP
104317: POP
104318: GO 104278
104320: POP
104321: POP
// end ;
104322: PPOPN 3
104324: END
// every 0 0$1 trigger s30 do var i , tmp ;
104325: LD_EXP 131
104329: IFFALSE 104398
104331: GO 104333
104333: DISABLE
104334: LD_INT 0
104336: PPUSH
104337: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104338: LD_ADDR_VAR 0 2
104342: PUSH
104343: LD_INT 22
104345: PUSH
104346: LD_OWVAR 2
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: PPUSH
104355: CALL_OW 69
104359: ST_TO_ADDR
// if not tmp then
104360: LD_VAR 0 2
104364: NOT
104365: IFFALSE 104369
// exit ;
104367: GO 104398
// for i in tmp do
104369: LD_ADDR_VAR 0 1
104373: PUSH
104374: LD_VAR 0 2
104378: PUSH
104379: FOR_IN
104380: IFFALSE 104396
// SetLives ( i , 300 ) ;
104382: LD_VAR 0 1
104386: PPUSH
104387: LD_INT 300
104389: PPUSH
104390: CALL_OW 234
104394: GO 104379
104396: POP
104397: POP
// end ;
104398: PPOPN 2
104400: END
// every 0 0$1 trigger s60 do var i , tmp ;
104401: LD_EXP 132
104405: IFFALSE 104474
104407: GO 104409
104409: DISABLE
104410: LD_INT 0
104412: PPUSH
104413: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104414: LD_ADDR_VAR 0 2
104418: PUSH
104419: LD_INT 22
104421: PUSH
104422: LD_OWVAR 2
104426: PUSH
104427: EMPTY
104428: LIST
104429: LIST
104430: PPUSH
104431: CALL_OW 69
104435: ST_TO_ADDR
// if not tmp then
104436: LD_VAR 0 2
104440: NOT
104441: IFFALSE 104445
// exit ;
104443: GO 104474
// for i in tmp do
104445: LD_ADDR_VAR 0 1
104449: PUSH
104450: LD_VAR 0 2
104454: PUSH
104455: FOR_IN
104456: IFFALSE 104472
// SetLives ( i , 600 ) ;
104458: LD_VAR 0 1
104462: PPUSH
104463: LD_INT 600
104465: PPUSH
104466: CALL_OW 234
104470: GO 104455
104472: POP
104473: POP
// end ;
104474: PPOPN 2
104476: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104477: LD_INT 0
104479: PPUSH
// case cmd of 301 :
104480: LD_VAR 0 1
104484: PUSH
104485: LD_INT 301
104487: DOUBLE
104488: EQUAL
104489: IFTRUE 104493
104491: GO 104525
104493: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104494: LD_VAR 0 6
104498: PPUSH
104499: LD_VAR 0 7
104503: PPUSH
104504: LD_VAR 0 8
104508: PPUSH
104509: LD_VAR 0 4
104513: PPUSH
104514: LD_VAR 0 5
104518: PPUSH
104519: CALL 105726 0 5
104523: GO 104646
104525: LD_INT 302
104527: DOUBLE
104528: EQUAL
104529: IFTRUE 104533
104531: GO 104570
104533: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104534: LD_VAR 0 6
104538: PPUSH
104539: LD_VAR 0 7
104543: PPUSH
104544: LD_VAR 0 8
104548: PPUSH
104549: LD_VAR 0 9
104553: PPUSH
104554: LD_VAR 0 4
104558: PPUSH
104559: LD_VAR 0 5
104563: PPUSH
104564: CALL 105817 0 6
104568: GO 104646
104570: LD_INT 303
104572: DOUBLE
104573: EQUAL
104574: IFTRUE 104578
104576: GO 104615
104578: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104579: LD_VAR 0 6
104583: PPUSH
104584: LD_VAR 0 7
104588: PPUSH
104589: LD_VAR 0 8
104593: PPUSH
104594: LD_VAR 0 9
104598: PPUSH
104599: LD_VAR 0 4
104603: PPUSH
104604: LD_VAR 0 5
104608: PPUSH
104609: CALL 104651 0 6
104613: GO 104646
104615: LD_INT 304
104617: DOUBLE
104618: EQUAL
104619: IFTRUE 104623
104621: GO 104645
104623: POP
// hHackTeleport ( unit , x , y ) ; end ;
104624: LD_VAR 0 2
104628: PPUSH
104629: LD_VAR 0 4
104633: PPUSH
104634: LD_VAR 0 5
104638: PPUSH
104639: CALL 106410 0 3
104643: GO 104646
104645: POP
// end ;
104646: LD_VAR 0 12
104650: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104651: LD_INT 0
104653: PPUSH
104654: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104655: LD_VAR 0 1
104659: PUSH
104660: LD_INT 1
104662: LESS
104663: PUSH
104664: LD_VAR 0 1
104668: PUSH
104669: LD_INT 3
104671: GREATER
104672: OR
104673: PUSH
104674: LD_VAR 0 5
104678: PPUSH
104679: LD_VAR 0 6
104683: PPUSH
104684: CALL_OW 428
104688: OR
104689: IFFALSE 104693
// exit ;
104691: GO 105413
// uc_side := your_side ;
104693: LD_ADDR_OWVAR 20
104697: PUSH
104698: LD_OWVAR 2
104702: ST_TO_ADDR
// uc_nation := nation ;
104703: LD_ADDR_OWVAR 21
104707: PUSH
104708: LD_VAR 0 1
104712: ST_TO_ADDR
// bc_level = 1 ;
104713: LD_ADDR_OWVAR 43
104717: PUSH
104718: LD_INT 1
104720: ST_TO_ADDR
// case btype of 1 :
104721: LD_VAR 0 2
104725: PUSH
104726: LD_INT 1
104728: DOUBLE
104729: EQUAL
104730: IFTRUE 104734
104732: GO 104745
104734: POP
// bc_type := b_depot ; 2 :
104735: LD_ADDR_OWVAR 42
104739: PUSH
104740: LD_INT 0
104742: ST_TO_ADDR
104743: GO 105357
104745: LD_INT 2
104747: DOUBLE
104748: EQUAL
104749: IFTRUE 104753
104751: GO 104764
104753: POP
// bc_type := b_warehouse ; 3 :
104754: LD_ADDR_OWVAR 42
104758: PUSH
104759: LD_INT 1
104761: ST_TO_ADDR
104762: GO 105357
104764: LD_INT 3
104766: DOUBLE
104767: EQUAL
104768: IFTRUE 104772
104770: GO 104783
104772: POP
// bc_type := b_lab ; 4 .. 9 :
104773: LD_ADDR_OWVAR 42
104777: PUSH
104778: LD_INT 6
104780: ST_TO_ADDR
104781: GO 105357
104783: LD_INT 4
104785: DOUBLE
104786: GREATEREQUAL
104787: IFFALSE 104795
104789: LD_INT 9
104791: DOUBLE
104792: LESSEQUAL
104793: IFTRUE 104797
104795: GO 104849
104797: POP
// begin bc_type := b_lab_half ;
104798: LD_ADDR_OWVAR 42
104802: PUSH
104803: LD_INT 7
104805: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104806: LD_ADDR_OWVAR 44
104810: PUSH
104811: LD_INT 10
104813: PUSH
104814: LD_INT 11
104816: PUSH
104817: LD_INT 12
104819: PUSH
104820: LD_INT 15
104822: PUSH
104823: LD_INT 14
104825: PUSH
104826: LD_INT 13
104828: PUSH
104829: EMPTY
104830: LIST
104831: LIST
104832: LIST
104833: LIST
104834: LIST
104835: LIST
104836: PUSH
104837: LD_VAR 0 2
104841: PUSH
104842: LD_INT 3
104844: MINUS
104845: ARRAY
104846: ST_TO_ADDR
// end ; 10 .. 13 :
104847: GO 105357
104849: LD_INT 10
104851: DOUBLE
104852: GREATEREQUAL
104853: IFFALSE 104861
104855: LD_INT 13
104857: DOUBLE
104858: LESSEQUAL
104859: IFTRUE 104863
104861: GO 104940
104863: POP
// begin bc_type := b_lab_full ;
104864: LD_ADDR_OWVAR 42
104868: PUSH
104869: LD_INT 8
104871: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104872: LD_ADDR_OWVAR 44
104876: PUSH
104877: LD_INT 10
104879: PUSH
104880: LD_INT 12
104882: PUSH
104883: LD_INT 14
104885: PUSH
104886: LD_INT 13
104888: PUSH
104889: EMPTY
104890: LIST
104891: LIST
104892: LIST
104893: LIST
104894: PUSH
104895: LD_VAR 0 2
104899: PUSH
104900: LD_INT 9
104902: MINUS
104903: ARRAY
104904: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104905: LD_ADDR_OWVAR 45
104909: PUSH
104910: LD_INT 11
104912: PUSH
104913: LD_INT 15
104915: PUSH
104916: LD_INT 12
104918: PUSH
104919: LD_INT 15
104921: PUSH
104922: EMPTY
104923: LIST
104924: LIST
104925: LIST
104926: LIST
104927: PUSH
104928: LD_VAR 0 2
104932: PUSH
104933: LD_INT 9
104935: MINUS
104936: ARRAY
104937: ST_TO_ADDR
// end ; 14 :
104938: GO 105357
104940: LD_INT 14
104942: DOUBLE
104943: EQUAL
104944: IFTRUE 104948
104946: GO 104959
104948: POP
// bc_type := b_workshop ; 15 :
104949: LD_ADDR_OWVAR 42
104953: PUSH
104954: LD_INT 2
104956: ST_TO_ADDR
104957: GO 105357
104959: LD_INT 15
104961: DOUBLE
104962: EQUAL
104963: IFTRUE 104967
104965: GO 104978
104967: POP
// bc_type := b_factory ; 16 :
104968: LD_ADDR_OWVAR 42
104972: PUSH
104973: LD_INT 3
104975: ST_TO_ADDR
104976: GO 105357
104978: LD_INT 16
104980: DOUBLE
104981: EQUAL
104982: IFTRUE 104986
104984: GO 104997
104986: POP
// bc_type := b_ext_gun ; 17 :
104987: LD_ADDR_OWVAR 42
104991: PUSH
104992: LD_INT 17
104994: ST_TO_ADDR
104995: GO 105357
104997: LD_INT 17
104999: DOUBLE
105000: EQUAL
105001: IFTRUE 105005
105003: GO 105033
105005: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105006: LD_ADDR_OWVAR 42
105010: PUSH
105011: LD_INT 19
105013: PUSH
105014: LD_INT 23
105016: PUSH
105017: LD_INT 19
105019: PUSH
105020: EMPTY
105021: LIST
105022: LIST
105023: LIST
105024: PUSH
105025: LD_VAR 0 1
105029: ARRAY
105030: ST_TO_ADDR
105031: GO 105357
105033: LD_INT 18
105035: DOUBLE
105036: EQUAL
105037: IFTRUE 105041
105039: GO 105052
105041: POP
// bc_type := b_ext_radar ; 19 :
105042: LD_ADDR_OWVAR 42
105046: PUSH
105047: LD_INT 20
105049: ST_TO_ADDR
105050: GO 105357
105052: LD_INT 19
105054: DOUBLE
105055: EQUAL
105056: IFTRUE 105060
105058: GO 105071
105060: POP
// bc_type := b_ext_radio ; 20 :
105061: LD_ADDR_OWVAR 42
105065: PUSH
105066: LD_INT 22
105068: ST_TO_ADDR
105069: GO 105357
105071: LD_INT 20
105073: DOUBLE
105074: EQUAL
105075: IFTRUE 105079
105077: GO 105090
105079: POP
// bc_type := b_ext_siberium ; 21 :
105080: LD_ADDR_OWVAR 42
105084: PUSH
105085: LD_INT 21
105087: ST_TO_ADDR
105088: GO 105357
105090: LD_INT 21
105092: DOUBLE
105093: EQUAL
105094: IFTRUE 105098
105096: GO 105109
105098: POP
// bc_type := b_ext_computer ; 22 :
105099: LD_ADDR_OWVAR 42
105103: PUSH
105104: LD_INT 24
105106: ST_TO_ADDR
105107: GO 105357
105109: LD_INT 22
105111: DOUBLE
105112: EQUAL
105113: IFTRUE 105117
105115: GO 105128
105117: POP
// bc_type := b_ext_track ; 23 :
105118: LD_ADDR_OWVAR 42
105122: PUSH
105123: LD_INT 16
105125: ST_TO_ADDR
105126: GO 105357
105128: LD_INT 23
105130: DOUBLE
105131: EQUAL
105132: IFTRUE 105136
105134: GO 105147
105136: POP
// bc_type := b_ext_laser ; 24 :
105137: LD_ADDR_OWVAR 42
105141: PUSH
105142: LD_INT 25
105144: ST_TO_ADDR
105145: GO 105357
105147: LD_INT 24
105149: DOUBLE
105150: EQUAL
105151: IFTRUE 105155
105153: GO 105166
105155: POP
// bc_type := b_control_tower ; 25 :
105156: LD_ADDR_OWVAR 42
105160: PUSH
105161: LD_INT 36
105163: ST_TO_ADDR
105164: GO 105357
105166: LD_INT 25
105168: DOUBLE
105169: EQUAL
105170: IFTRUE 105174
105172: GO 105185
105174: POP
// bc_type := b_breastwork ; 26 :
105175: LD_ADDR_OWVAR 42
105179: PUSH
105180: LD_INT 31
105182: ST_TO_ADDR
105183: GO 105357
105185: LD_INT 26
105187: DOUBLE
105188: EQUAL
105189: IFTRUE 105193
105191: GO 105204
105193: POP
// bc_type := b_bunker ; 27 :
105194: LD_ADDR_OWVAR 42
105198: PUSH
105199: LD_INT 32
105201: ST_TO_ADDR
105202: GO 105357
105204: LD_INT 27
105206: DOUBLE
105207: EQUAL
105208: IFTRUE 105212
105210: GO 105223
105212: POP
// bc_type := b_turret ; 28 :
105213: LD_ADDR_OWVAR 42
105217: PUSH
105218: LD_INT 33
105220: ST_TO_ADDR
105221: GO 105357
105223: LD_INT 28
105225: DOUBLE
105226: EQUAL
105227: IFTRUE 105231
105229: GO 105242
105231: POP
// bc_type := b_armoury ; 29 :
105232: LD_ADDR_OWVAR 42
105236: PUSH
105237: LD_INT 4
105239: ST_TO_ADDR
105240: GO 105357
105242: LD_INT 29
105244: DOUBLE
105245: EQUAL
105246: IFTRUE 105250
105248: GO 105261
105250: POP
// bc_type := b_barracks ; 30 :
105251: LD_ADDR_OWVAR 42
105255: PUSH
105256: LD_INT 5
105258: ST_TO_ADDR
105259: GO 105357
105261: LD_INT 30
105263: DOUBLE
105264: EQUAL
105265: IFTRUE 105269
105267: GO 105280
105269: POP
// bc_type := b_solar_power ; 31 :
105270: LD_ADDR_OWVAR 42
105274: PUSH
105275: LD_INT 27
105277: ST_TO_ADDR
105278: GO 105357
105280: LD_INT 31
105282: DOUBLE
105283: EQUAL
105284: IFTRUE 105288
105286: GO 105299
105288: POP
// bc_type := b_oil_power ; 32 :
105289: LD_ADDR_OWVAR 42
105293: PUSH
105294: LD_INT 26
105296: ST_TO_ADDR
105297: GO 105357
105299: LD_INT 32
105301: DOUBLE
105302: EQUAL
105303: IFTRUE 105307
105305: GO 105318
105307: POP
// bc_type := b_siberite_power ; 33 :
105308: LD_ADDR_OWVAR 42
105312: PUSH
105313: LD_INT 28
105315: ST_TO_ADDR
105316: GO 105357
105318: LD_INT 33
105320: DOUBLE
105321: EQUAL
105322: IFTRUE 105326
105324: GO 105337
105326: POP
// bc_type := b_oil_mine ; 34 :
105327: LD_ADDR_OWVAR 42
105331: PUSH
105332: LD_INT 29
105334: ST_TO_ADDR
105335: GO 105357
105337: LD_INT 34
105339: DOUBLE
105340: EQUAL
105341: IFTRUE 105345
105343: GO 105356
105345: POP
// bc_type := b_siberite_mine ; end ;
105346: LD_ADDR_OWVAR 42
105350: PUSH
105351: LD_INT 30
105353: ST_TO_ADDR
105354: GO 105357
105356: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105357: LD_ADDR_VAR 0 8
105361: PUSH
105362: LD_VAR 0 5
105366: PPUSH
105367: LD_VAR 0 6
105371: PPUSH
105372: LD_VAR 0 3
105376: PPUSH
105377: CALL_OW 47
105381: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105382: LD_OWVAR 42
105386: PUSH
105387: LD_INT 32
105389: PUSH
105390: LD_INT 33
105392: PUSH
105393: EMPTY
105394: LIST
105395: LIST
105396: IN
105397: IFFALSE 105413
// PlaceWeaponTurret ( b , weapon ) ;
105399: LD_VAR 0 8
105403: PPUSH
105404: LD_VAR 0 4
105408: PPUSH
105409: CALL_OW 431
// end ;
105413: LD_VAR 0 7
105417: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105418: LD_INT 0
105420: PPUSH
105421: PPUSH
105422: PPUSH
105423: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105424: LD_ADDR_VAR 0 4
105428: PUSH
105429: LD_INT 22
105431: PUSH
105432: LD_OWVAR 2
105436: PUSH
105437: EMPTY
105438: LIST
105439: LIST
105440: PUSH
105441: LD_INT 2
105443: PUSH
105444: LD_INT 30
105446: PUSH
105447: LD_INT 0
105449: PUSH
105450: EMPTY
105451: LIST
105452: LIST
105453: PUSH
105454: LD_INT 30
105456: PUSH
105457: LD_INT 1
105459: PUSH
105460: EMPTY
105461: LIST
105462: LIST
105463: PUSH
105464: EMPTY
105465: LIST
105466: LIST
105467: LIST
105468: PUSH
105469: EMPTY
105470: LIST
105471: LIST
105472: PPUSH
105473: CALL_OW 69
105477: ST_TO_ADDR
// if not tmp then
105478: LD_VAR 0 4
105482: NOT
105483: IFFALSE 105487
// exit ;
105485: GO 105546
// for i in tmp do
105487: LD_ADDR_VAR 0 2
105491: PUSH
105492: LD_VAR 0 4
105496: PUSH
105497: FOR_IN
105498: IFFALSE 105544
// for j = 1 to 3 do
105500: LD_ADDR_VAR 0 3
105504: PUSH
105505: DOUBLE
105506: LD_INT 1
105508: DEC
105509: ST_TO_ADDR
105510: LD_INT 3
105512: PUSH
105513: FOR_TO
105514: IFFALSE 105540
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105516: LD_VAR 0 2
105520: PPUSH
105521: CALL_OW 274
105525: PPUSH
105526: LD_VAR 0 3
105530: PPUSH
105531: LD_INT 99999
105533: PPUSH
105534: CALL_OW 277
105538: GO 105513
105540: POP
105541: POP
105542: GO 105497
105544: POP
105545: POP
// end ;
105546: LD_VAR 0 1
105550: RET
// export function hHackSetLevel10 ; var i , j ; begin
105551: LD_INT 0
105553: PPUSH
105554: PPUSH
105555: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105556: LD_ADDR_VAR 0 2
105560: PUSH
105561: LD_INT 21
105563: PUSH
105564: LD_INT 1
105566: PUSH
105567: EMPTY
105568: LIST
105569: LIST
105570: PPUSH
105571: CALL_OW 69
105575: PUSH
105576: FOR_IN
105577: IFFALSE 105629
// if IsSelected ( i ) then
105579: LD_VAR 0 2
105583: PPUSH
105584: CALL_OW 306
105588: IFFALSE 105627
// begin for j := 1 to 4 do
105590: LD_ADDR_VAR 0 3
105594: PUSH
105595: DOUBLE
105596: LD_INT 1
105598: DEC
105599: ST_TO_ADDR
105600: LD_INT 4
105602: PUSH
105603: FOR_TO
105604: IFFALSE 105625
// SetSkill ( i , j , 10 ) ;
105606: LD_VAR 0 2
105610: PPUSH
105611: LD_VAR 0 3
105615: PPUSH
105616: LD_INT 10
105618: PPUSH
105619: CALL_OW 237
105623: GO 105603
105625: POP
105626: POP
// end ;
105627: GO 105576
105629: POP
105630: POP
// end ;
105631: LD_VAR 0 1
105635: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105636: LD_INT 0
105638: PPUSH
105639: PPUSH
105640: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105641: LD_ADDR_VAR 0 2
105645: PUSH
105646: LD_INT 22
105648: PUSH
105649: LD_OWVAR 2
105653: PUSH
105654: EMPTY
105655: LIST
105656: LIST
105657: PUSH
105658: LD_INT 21
105660: PUSH
105661: LD_INT 1
105663: PUSH
105664: EMPTY
105665: LIST
105666: LIST
105667: PUSH
105668: EMPTY
105669: LIST
105670: LIST
105671: PPUSH
105672: CALL_OW 69
105676: PUSH
105677: FOR_IN
105678: IFFALSE 105719
// begin for j := 1 to 4 do
105680: LD_ADDR_VAR 0 3
105684: PUSH
105685: DOUBLE
105686: LD_INT 1
105688: DEC
105689: ST_TO_ADDR
105690: LD_INT 4
105692: PUSH
105693: FOR_TO
105694: IFFALSE 105715
// SetSkill ( i , j , 10 ) ;
105696: LD_VAR 0 2
105700: PPUSH
105701: LD_VAR 0 3
105705: PPUSH
105706: LD_INT 10
105708: PPUSH
105709: CALL_OW 237
105713: GO 105693
105715: POP
105716: POP
// end ;
105717: GO 105677
105719: POP
105720: POP
// end ;
105721: LD_VAR 0 1
105725: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105726: LD_INT 0
105728: PPUSH
// uc_side := your_side ;
105729: LD_ADDR_OWVAR 20
105733: PUSH
105734: LD_OWVAR 2
105738: ST_TO_ADDR
// uc_nation := nation ;
105739: LD_ADDR_OWVAR 21
105743: PUSH
105744: LD_VAR 0 1
105748: ST_TO_ADDR
// InitHc ;
105749: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105753: LD_INT 0
105755: PPUSH
105756: LD_VAR 0 2
105760: PPUSH
105761: LD_VAR 0 3
105765: PPUSH
105766: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105770: LD_VAR 0 4
105774: PPUSH
105775: LD_VAR 0 5
105779: PPUSH
105780: CALL_OW 428
105784: PUSH
105785: LD_INT 0
105787: EQUAL
105788: IFFALSE 105812
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105790: CALL_OW 44
105794: PPUSH
105795: LD_VAR 0 4
105799: PPUSH
105800: LD_VAR 0 5
105804: PPUSH
105805: LD_INT 1
105807: PPUSH
105808: CALL_OW 48
// end ;
105812: LD_VAR 0 6
105816: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105817: LD_INT 0
105819: PPUSH
105820: PPUSH
// uc_side := your_side ;
105821: LD_ADDR_OWVAR 20
105825: PUSH
105826: LD_OWVAR 2
105830: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105831: LD_VAR 0 1
105835: PUSH
105836: LD_INT 1
105838: PUSH
105839: LD_INT 2
105841: PUSH
105842: LD_INT 3
105844: PUSH
105845: LD_INT 4
105847: PUSH
105848: LD_INT 5
105850: PUSH
105851: EMPTY
105852: LIST
105853: LIST
105854: LIST
105855: LIST
105856: LIST
105857: IN
105858: IFFALSE 105870
// uc_nation := nation_american else
105860: LD_ADDR_OWVAR 21
105864: PUSH
105865: LD_INT 1
105867: ST_TO_ADDR
105868: GO 105913
// if chassis in [ 11 , 12 , 13 , 14 ] then
105870: LD_VAR 0 1
105874: PUSH
105875: LD_INT 11
105877: PUSH
105878: LD_INT 12
105880: PUSH
105881: LD_INT 13
105883: PUSH
105884: LD_INT 14
105886: PUSH
105887: EMPTY
105888: LIST
105889: LIST
105890: LIST
105891: LIST
105892: IN
105893: IFFALSE 105905
// uc_nation := nation_arabian else
105895: LD_ADDR_OWVAR 21
105899: PUSH
105900: LD_INT 2
105902: ST_TO_ADDR
105903: GO 105913
// uc_nation := nation_russian ;
105905: LD_ADDR_OWVAR 21
105909: PUSH
105910: LD_INT 3
105912: ST_TO_ADDR
// vc_chassis := chassis ;
105913: LD_ADDR_OWVAR 37
105917: PUSH
105918: LD_VAR 0 1
105922: ST_TO_ADDR
// vc_engine := engine ;
105923: LD_ADDR_OWVAR 39
105927: PUSH
105928: LD_VAR 0 2
105932: ST_TO_ADDR
// vc_control := control ;
105933: LD_ADDR_OWVAR 38
105937: PUSH
105938: LD_VAR 0 3
105942: ST_TO_ADDR
// vc_weapon := weapon ;
105943: LD_ADDR_OWVAR 40
105947: PUSH
105948: LD_VAR 0 4
105952: ST_TO_ADDR
// un := CreateVehicle ;
105953: LD_ADDR_VAR 0 8
105957: PUSH
105958: CALL_OW 45
105962: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105963: LD_VAR 0 8
105967: PPUSH
105968: LD_INT 0
105970: PPUSH
105971: LD_INT 5
105973: PPUSH
105974: CALL_OW 12
105978: PPUSH
105979: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105983: LD_VAR 0 8
105987: PPUSH
105988: LD_VAR 0 5
105992: PPUSH
105993: LD_VAR 0 6
105997: PPUSH
105998: LD_INT 1
106000: PPUSH
106001: CALL_OW 48
// end ;
106005: LD_VAR 0 7
106009: RET
// export hInvincible ; every 1 do
106010: GO 106012
106012: DISABLE
// hInvincible := [ ] ;
106013: LD_ADDR_EXP 133
106017: PUSH
106018: EMPTY
106019: ST_TO_ADDR
106020: END
// every 10 do var i ;
106021: GO 106023
106023: DISABLE
106024: LD_INT 0
106026: PPUSH
// begin enable ;
106027: ENABLE
// if not hInvincible then
106028: LD_EXP 133
106032: NOT
106033: IFFALSE 106037
// exit ;
106035: GO 106081
// for i in hInvincible do
106037: LD_ADDR_VAR 0 1
106041: PUSH
106042: LD_EXP 133
106046: PUSH
106047: FOR_IN
106048: IFFALSE 106079
// if GetLives ( i ) < 1000 then
106050: LD_VAR 0 1
106054: PPUSH
106055: CALL_OW 256
106059: PUSH
106060: LD_INT 1000
106062: LESS
106063: IFFALSE 106077
// SetLives ( i , 1000 ) ;
106065: LD_VAR 0 1
106069: PPUSH
106070: LD_INT 1000
106072: PPUSH
106073: CALL_OW 234
106077: GO 106047
106079: POP
106080: POP
// end ;
106081: PPOPN 1
106083: END
// export function hHackInvincible ; var i ; begin
106084: LD_INT 0
106086: PPUSH
106087: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106088: LD_ADDR_VAR 0 2
106092: PUSH
106093: LD_INT 2
106095: PUSH
106096: LD_INT 21
106098: PUSH
106099: LD_INT 1
106101: PUSH
106102: EMPTY
106103: LIST
106104: LIST
106105: PUSH
106106: LD_INT 21
106108: PUSH
106109: LD_INT 2
106111: PUSH
106112: EMPTY
106113: LIST
106114: LIST
106115: PUSH
106116: EMPTY
106117: LIST
106118: LIST
106119: LIST
106120: PPUSH
106121: CALL_OW 69
106125: PUSH
106126: FOR_IN
106127: IFFALSE 106188
// if IsSelected ( i ) then
106129: LD_VAR 0 2
106133: PPUSH
106134: CALL_OW 306
106138: IFFALSE 106186
// begin if i in hInvincible then
106140: LD_VAR 0 2
106144: PUSH
106145: LD_EXP 133
106149: IN
106150: IFFALSE 106170
// hInvincible := hInvincible diff i else
106152: LD_ADDR_EXP 133
106156: PUSH
106157: LD_EXP 133
106161: PUSH
106162: LD_VAR 0 2
106166: DIFF
106167: ST_TO_ADDR
106168: GO 106186
// hInvincible := hInvincible union i ;
106170: LD_ADDR_EXP 133
106174: PUSH
106175: LD_EXP 133
106179: PUSH
106180: LD_VAR 0 2
106184: UNION
106185: ST_TO_ADDR
// end ;
106186: GO 106126
106188: POP
106189: POP
// end ;
106190: LD_VAR 0 1
106194: RET
// export function hHackInvisible ; var i , j ; begin
106195: LD_INT 0
106197: PPUSH
106198: PPUSH
106199: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106200: LD_ADDR_VAR 0 2
106204: PUSH
106205: LD_INT 21
106207: PUSH
106208: LD_INT 1
106210: PUSH
106211: EMPTY
106212: LIST
106213: LIST
106214: PPUSH
106215: CALL_OW 69
106219: PUSH
106220: FOR_IN
106221: IFFALSE 106245
// if IsSelected ( i ) then
106223: LD_VAR 0 2
106227: PPUSH
106228: CALL_OW 306
106232: IFFALSE 106243
// ComForceInvisible ( i ) ;
106234: LD_VAR 0 2
106238: PPUSH
106239: CALL_OW 496
106243: GO 106220
106245: POP
106246: POP
// end ;
106247: LD_VAR 0 1
106251: RET
// export function hHackChangeYourSide ; begin
106252: LD_INT 0
106254: PPUSH
// if your_side = 8 then
106255: LD_OWVAR 2
106259: PUSH
106260: LD_INT 8
106262: EQUAL
106263: IFFALSE 106275
// your_side := 0 else
106265: LD_ADDR_OWVAR 2
106269: PUSH
106270: LD_INT 0
106272: ST_TO_ADDR
106273: GO 106289
// your_side := your_side + 1 ;
106275: LD_ADDR_OWVAR 2
106279: PUSH
106280: LD_OWVAR 2
106284: PUSH
106285: LD_INT 1
106287: PLUS
106288: ST_TO_ADDR
// end ;
106289: LD_VAR 0 1
106293: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106294: LD_INT 0
106296: PPUSH
106297: PPUSH
106298: PPUSH
// for i in all_units do
106299: LD_ADDR_VAR 0 2
106303: PUSH
106304: LD_OWVAR 3
106308: PUSH
106309: FOR_IN
106310: IFFALSE 106388
// if IsSelected ( i ) then
106312: LD_VAR 0 2
106316: PPUSH
106317: CALL_OW 306
106321: IFFALSE 106386
// begin j := GetSide ( i ) ;
106323: LD_ADDR_VAR 0 3
106327: PUSH
106328: LD_VAR 0 2
106332: PPUSH
106333: CALL_OW 255
106337: ST_TO_ADDR
// if j = 8 then
106338: LD_VAR 0 3
106342: PUSH
106343: LD_INT 8
106345: EQUAL
106346: IFFALSE 106358
// j := 0 else
106348: LD_ADDR_VAR 0 3
106352: PUSH
106353: LD_INT 0
106355: ST_TO_ADDR
106356: GO 106372
// j := j + 1 ;
106358: LD_ADDR_VAR 0 3
106362: PUSH
106363: LD_VAR 0 3
106367: PUSH
106368: LD_INT 1
106370: PLUS
106371: ST_TO_ADDR
// SetSide ( i , j ) ;
106372: LD_VAR 0 2
106376: PPUSH
106377: LD_VAR 0 3
106381: PPUSH
106382: CALL_OW 235
// end ;
106386: GO 106309
106388: POP
106389: POP
// end ;
106390: LD_VAR 0 1
106394: RET
// export function hHackFog ; begin
106395: LD_INT 0
106397: PPUSH
// FogOff ( true ) ;
106398: LD_INT 1
106400: PPUSH
106401: CALL_OW 344
// end ;
106405: LD_VAR 0 1
106409: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106410: LD_INT 0
106412: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106413: LD_VAR 0 1
106417: PPUSH
106418: LD_VAR 0 2
106422: PPUSH
106423: LD_VAR 0 3
106427: PPUSH
106428: LD_INT 1
106430: PPUSH
106431: LD_INT 1
106433: PPUSH
106434: CALL_OW 483
// CenterOnXY ( x , y ) ;
106438: LD_VAR 0 2
106442: PPUSH
106443: LD_VAR 0 3
106447: PPUSH
106448: CALL_OW 84
// end ;
106452: LD_VAR 0 4
106456: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106457: LD_INT 0
106459: PPUSH
106460: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106461: LD_VAR 0 1
106465: NOT
106466: PUSH
106467: LD_VAR 0 2
106471: PPUSH
106472: LD_VAR 0 3
106476: PPUSH
106477: CALL_OW 488
106481: NOT
106482: OR
106483: PUSH
106484: LD_VAR 0 1
106488: PPUSH
106489: CALL_OW 266
106493: PUSH
106494: LD_INT 3
106496: NONEQUAL
106497: PUSH
106498: LD_VAR 0 1
106502: PPUSH
106503: CALL_OW 247
106507: PUSH
106508: LD_INT 1
106510: EQUAL
106511: NOT
106512: AND
106513: OR
106514: IFFALSE 106518
// exit ;
106516: GO 106667
// if GetType ( factory ) = unit_human then
106518: LD_VAR 0 1
106522: PPUSH
106523: CALL_OW 247
106527: PUSH
106528: LD_INT 1
106530: EQUAL
106531: IFFALSE 106548
// factory := IsInUnit ( factory ) ;
106533: LD_ADDR_VAR 0 1
106537: PUSH
106538: LD_VAR 0 1
106542: PPUSH
106543: CALL_OW 310
106547: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106548: LD_VAR 0 1
106552: PPUSH
106553: CALL_OW 266
106557: PUSH
106558: LD_INT 3
106560: NONEQUAL
106561: IFFALSE 106565
// exit ;
106563: GO 106667
// if HexInfo ( x , y ) = factory then
106565: LD_VAR 0 2
106569: PPUSH
106570: LD_VAR 0 3
106574: PPUSH
106575: CALL_OW 428
106579: PUSH
106580: LD_VAR 0 1
106584: EQUAL
106585: IFFALSE 106612
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
106587: LD_ADDR_EXP 134
106591: PUSH
106592: LD_EXP 134
106596: PPUSH
106597: LD_VAR 0 1
106601: PPUSH
106602: LD_INT 0
106604: PPUSH
106605: CALL_OW 1
106609: ST_TO_ADDR
106610: GO 106663
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
106612: LD_ADDR_EXP 134
106616: PUSH
106617: LD_EXP 134
106621: PPUSH
106622: LD_VAR 0 1
106626: PPUSH
106627: LD_VAR 0 1
106631: PPUSH
106632: CALL_OW 255
106636: PUSH
106637: LD_VAR 0 1
106641: PUSH
106642: LD_VAR 0 2
106646: PUSH
106647: LD_VAR 0 3
106651: PUSH
106652: EMPTY
106653: LIST
106654: LIST
106655: LIST
106656: LIST
106657: PPUSH
106658: CALL_OW 1
106662: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106663: CALL 106672 0 0
// end ;
106667: LD_VAR 0 4
106671: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106672: LD_INT 0
106674: PPUSH
106675: PPUSH
106676: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106677: LD_STRING resetFactoryWaypoint();
106679: PPUSH
106680: CALL_OW 559
// if factoryWaypoints then
106684: LD_EXP 134
106688: IFFALSE 106814
// begin list := PrepareArray ( factoryWaypoints ) ;
106690: LD_ADDR_VAR 0 3
106694: PUSH
106695: LD_EXP 134
106699: PPUSH
106700: CALL 61110 0 1
106704: ST_TO_ADDR
// for i := 1 to list do
106705: LD_ADDR_VAR 0 2
106709: PUSH
106710: DOUBLE
106711: LD_INT 1
106713: DEC
106714: ST_TO_ADDR
106715: LD_VAR 0 3
106719: PUSH
106720: FOR_TO
106721: IFFALSE 106812
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106723: LD_STRING setFactoryWaypointXY(
106725: PUSH
106726: LD_VAR 0 3
106730: PUSH
106731: LD_VAR 0 2
106735: ARRAY
106736: PUSH
106737: LD_INT 1
106739: ARRAY
106740: STR
106741: PUSH
106742: LD_STRING ,
106744: STR
106745: PUSH
106746: LD_VAR 0 3
106750: PUSH
106751: LD_VAR 0 2
106755: ARRAY
106756: PUSH
106757: LD_INT 2
106759: ARRAY
106760: STR
106761: PUSH
106762: LD_STRING ,
106764: STR
106765: PUSH
106766: LD_VAR 0 3
106770: PUSH
106771: LD_VAR 0 2
106775: ARRAY
106776: PUSH
106777: LD_INT 3
106779: ARRAY
106780: STR
106781: PUSH
106782: LD_STRING ,
106784: STR
106785: PUSH
106786: LD_VAR 0 3
106790: PUSH
106791: LD_VAR 0 2
106795: ARRAY
106796: PUSH
106797: LD_INT 4
106799: ARRAY
106800: STR
106801: PUSH
106802: LD_STRING )
106804: STR
106805: PPUSH
106806: CALL_OW 559
106810: GO 106720
106812: POP
106813: POP
// end ; end ;
106814: LD_VAR 0 1
106818: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106819: LD_INT 0
106821: PPUSH
// if HexInfo ( x , y ) = warehouse then
106822: LD_VAR 0 2
106826: PPUSH
106827: LD_VAR 0 3
106831: PPUSH
106832: CALL_OW 428
106836: PUSH
106837: LD_VAR 0 1
106841: EQUAL
106842: IFFALSE 106869
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106844: LD_ADDR_EXP 135
106848: PUSH
106849: LD_EXP 135
106853: PPUSH
106854: LD_VAR 0 1
106858: PPUSH
106859: LD_INT 0
106861: PPUSH
106862: CALL_OW 1
106866: ST_TO_ADDR
106867: GO 106920
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106869: LD_ADDR_EXP 135
106873: PUSH
106874: LD_EXP 135
106878: PPUSH
106879: LD_VAR 0 1
106883: PPUSH
106884: LD_VAR 0 1
106888: PPUSH
106889: CALL_OW 255
106893: PUSH
106894: LD_VAR 0 1
106898: PUSH
106899: LD_VAR 0 2
106903: PUSH
106904: LD_VAR 0 3
106908: PUSH
106909: EMPTY
106910: LIST
106911: LIST
106912: LIST
106913: LIST
106914: PPUSH
106915: CALL_OW 1
106919: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106920: CALL 106929 0 0
// end ;
106924: LD_VAR 0 4
106928: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106929: LD_INT 0
106931: PPUSH
106932: PPUSH
106933: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106934: LD_STRING resetWarehouseGatheringPoints();
106936: PPUSH
106937: CALL_OW 559
// if warehouseGatheringPoints then
106941: LD_EXP 135
106945: IFFALSE 107071
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106947: LD_ADDR_VAR 0 3
106951: PUSH
106952: LD_EXP 135
106956: PPUSH
106957: CALL 61110 0 1
106961: ST_TO_ADDR
// for i := 1 to list do
106962: LD_ADDR_VAR 0 2
106966: PUSH
106967: DOUBLE
106968: LD_INT 1
106970: DEC
106971: ST_TO_ADDR
106972: LD_VAR 0 3
106976: PUSH
106977: FOR_TO
106978: IFFALSE 107069
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106980: LD_STRING setWarehouseGatheringPointXY(
106982: PUSH
106983: LD_VAR 0 3
106987: PUSH
106988: LD_VAR 0 2
106992: ARRAY
106993: PUSH
106994: LD_INT 1
106996: ARRAY
106997: STR
106998: PUSH
106999: LD_STRING ,
107001: STR
107002: PUSH
107003: LD_VAR 0 3
107007: PUSH
107008: LD_VAR 0 2
107012: ARRAY
107013: PUSH
107014: LD_INT 2
107016: ARRAY
107017: STR
107018: PUSH
107019: LD_STRING ,
107021: STR
107022: PUSH
107023: LD_VAR 0 3
107027: PUSH
107028: LD_VAR 0 2
107032: ARRAY
107033: PUSH
107034: LD_INT 3
107036: ARRAY
107037: STR
107038: PUSH
107039: LD_STRING ,
107041: STR
107042: PUSH
107043: LD_VAR 0 3
107047: PUSH
107048: LD_VAR 0 2
107052: ARRAY
107053: PUSH
107054: LD_INT 4
107056: ARRAY
107057: STR
107058: PUSH
107059: LD_STRING )
107061: STR
107062: PPUSH
107063: CALL_OW 559
107067: GO 106977
107069: POP
107070: POP
// end ; end ;
107071: LD_VAR 0 1
107075: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107076: LD_EXP 135
107080: IFFALSE 107765
107082: GO 107084
107084: DISABLE
107085: LD_INT 0
107087: PPUSH
107088: PPUSH
107089: PPUSH
107090: PPUSH
107091: PPUSH
107092: PPUSH
107093: PPUSH
107094: PPUSH
107095: PPUSH
// begin enable ;
107096: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107097: LD_ADDR_VAR 0 3
107101: PUSH
107102: LD_EXP 135
107106: PPUSH
107107: CALL 61110 0 1
107111: ST_TO_ADDR
// if not list then
107112: LD_VAR 0 3
107116: NOT
107117: IFFALSE 107121
// exit ;
107119: GO 107765
// for i := 1 to list do
107121: LD_ADDR_VAR 0 1
107125: PUSH
107126: DOUBLE
107127: LD_INT 1
107129: DEC
107130: ST_TO_ADDR
107131: LD_VAR 0 3
107135: PUSH
107136: FOR_TO
107137: IFFALSE 107763
// begin depot := list [ i ] [ 2 ] ;
107139: LD_ADDR_VAR 0 8
107143: PUSH
107144: LD_VAR 0 3
107148: PUSH
107149: LD_VAR 0 1
107153: ARRAY
107154: PUSH
107155: LD_INT 2
107157: ARRAY
107158: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107159: LD_ADDR_VAR 0 5
107163: PUSH
107164: LD_VAR 0 3
107168: PUSH
107169: LD_VAR 0 1
107173: ARRAY
107174: PUSH
107175: LD_INT 1
107177: ARRAY
107178: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107179: LD_VAR 0 8
107183: PPUSH
107184: CALL_OW 301
107188: PUSH
107189: LD_VAR 0 5
107193: PUSH
107194: LD_VAR 0 8
107198: PPUSH
107199: CALL_OW 255
107203: NONEQUAL
107204: OR
107205: IFFALSE 107234
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107207: LD_ADDR_EXP 135
107211: PUSH
107212: LD_EXP 135
107216: PPUSH
107217: LD_VAR 0 8
107221: PPUSH
107222: LD_INT 0
107224: PPUSH
107225: CALL_OW 1
107229: ST_TO_ADDR
// exit ;
107230: POP
107231: POP
107232: GO 107765
// end ; x := list [ i ] [ 3 ] ;
107234: LD_ADDR_VAR 0 6
107238: PUSH
107239: LD_VAR 0 3
107243: PUSH
107244: LD_VAR 0 1
107248: ARRAY
107249: PUSH
107250: LD_INT 3
107252: ARRAY
107253: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107254: LD_ADDR_VAR 0 7
107258: PUSH
107259: LD_VAR 0 3
107263: PUSH
107264: LD_VAR 0 1
107268: ARRAY
107269: PUSH
107270: LD_INT 4
107272: ARRAY
107273: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107274: LD_ADDR_VAR 0 9
107278: PUSH
107279: LD_VAR 0 6
107283: PPUSH
107284: LD_VAR 0 7
107288: PPUSH
107289: LD_INT 16
107291: PPUSH
107292: CALL 59698 0 3
107296: ST_TO_ADDR
// if not cratesNearbyPoint then
107297: LD_VAR 0 9
107301: NOT
107302: IFFALSE 107308
// exit ;
107304: POP
107305: POP
107306: GO 107765
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107308: LD_ADDR_VAR 0 4
107312: PUSH
107313: LD_INT 22
107315: PUSH
107316: LD_VAR 0 5
107320: PUSH
107321: EMPTY
107322: LIST
107323: LIST
107324: PUSH
107325: LD_INT 3
107327: PUSH
107328: LD_INT 60
107330: PUSH
107331: EMPTY
107332: LIST
107333: PUSH
107334: EMPTY
107335: LIST
107336: LIST
107337: PUSH
107338: LD_INT 91
107340: PUSH
107341: LD_VAR 0 8
107345: PUSH
107346: LD_INT 6
107348: PUSH
107349: EMPTY
107350: LIST
107351: LIST
107352: LIST
107353: PUSH
107354: LD_INT 2
107356: PUSH
107357: LD_INT 25
107359: PUSH
107360: LD_INT 2
107362: PUSH
107363: EMPTY
107364: LIST
107365: LIST
107366: PUSH
107367: LD_INT 25
107369: PUSH
107370: LD_INT 16
107372: PUSH
107373: EMPTY
107374: LIST
107375: LIST
107376: PUSH
107377: EMPTY
107378: LIST
107379: LIST
107380: LIST
107381: PUSH
107382: EMPTY
107383: LIST
107384: LIST
107385: LIST
107386: LIST
107387: PPUSH
107388: CALL_OW 69
107392: PUSH
107393: LD_VAR 0 8
107397: PPUSH
107398: CALL_OW 313
107402: PPUSH
107403: LD_INT 3
107405: PUSH
107406: LD_INT 60
107408: PUSH
107409: EMPTY
107410: LIST
107411: PUSH
107412: EMPTY
107413: LIST
107414: LIST
107415: PUSH
107416: LD_INT 2
107418: PUSH
107419: LD_INT 25
107421: PUSH
107422: LD_INT 2
107424: PUSH
107425: EMPTY
107426: LIST
107427: LIST
107428: PUSH
107429: LD_INT 25
107431: PUSH
107432: LD_INT 16
107434: PUSH
107435: EMPTY
107436: LIST
107437: LIST
107438: PUSH
107439: EMPTY
107440: LIST
107441: LIST
107442: LIST
107443: PUSH
107444: EMPTY
107445: LIST
107446: LIST
107447: PPUSH
107448: CALL_OW 72
107452: UNION
107453: ST_TO_ADDR
// if tmp then
107454: LD_VAR 0 4
107458: IFFALSE 107538
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107460: LD_ADDR_VAR 0 4
107464: PUSH
107465: LD_VAR 0 4
107469: PPUSH
107470: LD_INT 3
107472: PPUSH
107473: CALL 57667 0 2
107477: ST_TO_ADDR
// for j in tmp do
107478: LD_ADDR_VAR 0 2
107482: PUSH
107483: LD_VAR 0 4
107487: PUSH
107488: FOR_IN
107489: IFFALSE 107532
// begin if IsInUnit ( j ) then
107491: LD_VAR 0 2
107495: PPUSH
107496: CALL_OW 310
107500: IFFALSE 107511
// ComExit ( j ) ;
107502: LD_VAR 0 2
107506: PPUSH
107507: CALL 57750 0 1
// AddComCollect ( j , x , y ) ;
107511: LD_VAR 0 2
107515: PPUSH
107516: LD_VAR 0 6
107520: PPUSH
107521: LD_VAR 0 7
107525: PPUSH
107526: CALL_OW 177
// end ;
107530: GO 107488
107532: POP
107533: POP
// exit ;
107534: POP
107535: POP
107536: GO 107765
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107538: LD_ADDR_VAR 0 4
107542: PUSH
107543: LD_INT 22
107545: PUSH
107546: LD_VAR 0 5
107550: PUSH
107551: EMPTY
107552: LIST
107553: LIST
107554: PUSH
107555: LD_INT 91
107557: PUSH
107558: LD_VAR 0 8
107562: PUSH
107563: LD_INT 8
107565: PUSH
107566: EMPTY
107567: LIST
107568: LIST
107569: LIST
107570: PUSH
107571: LD_INT 2
107573: PUSH
107574: LD_INT 34
107576: PUSH
107577: LD_INT 12
107579: PUSH
107580: EMPTY
107581: LIST
107582: LIST
107583: PUSH
107584: LD_INT 34
107586: PUSH
107587: LD_INT 51
107589: PUSH
107590: EMPTY
107591: LIST
107592: LIST
107593: PUSH
107594: LD_INT 34
107596: PUSH
107597: LD_INT 32
107599: PUSH
107600: EMPTY
107601: LIST
107602: LIST
107603: PUSH
107604: LD_INT 34
107606: PUSH
107607: LD_INT 89
107609: PUSH
107610: EMPTY
107611: LIST
107612: LIST
107613: PUSH
107614: EMPTY
107615: LIST
107616: LIST
107617: LIST
107618: LIST
107619: LIST
107620: PUSH
107621: EMPTY
107622: LIST
107623: LIST
107624: LIST
107625: PPUSH
107626: CALL_OW 69
107630: ST_TO_ADDR
// if tmp then
107631: LD_VAR 0 4
107635: IFFALSE 107761
// begin for j in tmp do
107637: LD_ADDR_VAR 0 2
107641: PUSH
107642: LD_VAR 0 4
107646: PUSH
107647: FOR_IN
107648: IFFALSE 107759
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107650: LD_VAR 0 2
107654: PPUSH
107655: CALL_OW 262
107659: PUSH
107660: LD_INT 3
107662: EQUAL
107663: PUSH
107664: LD_VAR 0 2
107668: PPUSH
107669: CALL_OW 261
107673: PUSH
107674: LD_INT 20
107676: GREATER
107677: OR
107678: PUSH
107679: LD_VAR 0 2
107683: PPUSH
107684: CALL_OW 314
107688: NOT
107689: AND
107690: PUSH
107691: LD_VAR 0 2
107695: PPUSH
107696: CALL_OW 263
107700: PUSH
107701: LD_INT 1
107703: NONEQUAL
107704: PUSH
107705: LD_VAR 0 2
107709: PPUSH
107710: CALL_OW 311
107714: OR
107715: AND
107716: IFFALSE 107757
// begin ComCollect ( j , x , y ) ;
107718: LD_VAR 0 2
107722: PPUSH
107723: LD_VAR 0 6
107727: PPUSH
107728: LD_VAR 0 7
107732: PPUSH
107733: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107737: LD_VAR 0 2
107741: PPUSH
107742: LD_VAR 0 8
107746: PPUSH
107747: CALL_OW 172
// exit ;
107751: POP
107752: POP
107753: POP
107754: POP
107755: GO 107765
// end ;
107757: GO 107647
107759: POP
107760: POP
// end ; end ;
107761: GO 107136
107763: POP
107764: POP
// end ; end_of_file
107765: PPOPN 9
107767: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107768: LD_INT 0
107770: PPUSH
107771: PPUSH
107772: PPUSH
107773: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107774: LD_VAR 0 1
107778: PPUSH
107779: CALL_OW 264
107783: PUSH
107784: LD_INT 91
107786: EQUAL
107787: IFFALSE 107859
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107789: LD_INT 68
107791: PPUSH
107792: LD_VAR 0 1
107796: PPUSH
107797: CALL_OW 255
107801: PPUSH
107802: CALL_OW 321
107806: PUSH
107807: LD_INT 2
107809: EQUAL
107810: IFFALSE 107822
// eff := 70 else
107812: LD_ADDR_VAR 0 4
107816: PUSH
107817: LD_INT 70
107819: ST_TO_ADDR
107820: GO 107830
// eff := 30 ;
107822: LD_ADDR_VAR 0 4
107826: PUSH
107827: LD_INT 30
107829: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107830: LD_VAR 0 1
107834: PPUSH
107835: CALL_OW 250
107839: PPUSH
107840: LD_VAR 0 1
107844: PPUSH
107845: CALL_OW 251
107849: PPUSH
107850: LD_VAR 0 4
107854: PPUSH
107855: CALL_OW 495
// end ; end ;
107859: LD_VAR 0 2
107863: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107864: LD_INT 0
107866: PPUSH
// end ;
107867: LD_VAR 0 4
107871: RET
// export function SOS_Command ( cmd ) ; begin
107872: LD_INT 0
107874: PPUSH
// end ;
107875: LD_VAR 0 2
107879: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107880: LD_INT 0
107882: PPUSH
// end ;
107883: LD_VAR 0 6
107887: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107888: LD_INT 0
107890: PPUSH
107891: PPUSH
// if not vehicle or not factory then
107892: LD_VAR 0 1
107896: NOT
107897: PUSH
107898: LD_VAR 0 2
107902: NOT
107903: OR
107904: IFFALSE 107908
// exit ;
107906: GO 108139
// if factoryWaypoints >= factory then
107908: LD_EXP 134
107912: PUSH
107913: LD_VAR 0 2
107917: GREATEREQUAL
107918: IFFALSE 108139
// if factoryWaypoints [ factory ] then
107920: LD_EXP 134
107924: PUSH
107925: LD_VAR 0 2
107929: ARRAY
107930: IFFALSE 108139
// begin if GetControl ( vehicle ) = control_manual then
107932: LD_VAR 0 1
107936: PPUSH
107937: CALL_OW 263
107941: PUSH
107942: LD_INT 1
107944: EQUAL
107945: IFFALSE 108026
// begin driver := IsDrivenBy ( vehicle ) ;
107947: LD_ADDR_VAR 0 4
107951: PUSH
107952: LD_VAR 0 1
107956: PPUSH
107957: CALL_OW 311
107961: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107962: LD_VAR 0 4
107966: PPUSH
107967: LD_EXP 134
107971: PUSH
107972: LD_VAR 0 2
107976: ARRAY
107977: PUSH
107978: LD_INT 3
107980: ARRAY
107981: PPUSH
107982: LD_EXP 134
107986: PUSH
107987: LD_VAR 0 2
107991: ARRAY
107992: PUSH
107993: LD_INT 4
107995: ARRAY
107996: PPUSH
107997: CALL_OW 171
// AddComExitVehicle ( driver ) ;
108001: LD_VAR 0 4
108005: PPUSH
108006: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
108010: LD_VAR 0 4
108014: PPUSH
108015: LD_VAR 0 2
108019: PPUSH
108020: CALL_OW 180
// end else
108024: GO 108139
// if GetControl ( vehicle ) = control_remote then
108026: LD_VAR 0 1
108030: PPUSH
108031: CALL_OW 263
108035: PUSH
108036: LD_INT 2
108038: EQUAL
108039: IFFALSE 108100
// begin wait ( 0 0$2 ) ;
108041: LD_INT 70
108043: PPUSH
108044: CALL_OW 67
// if Connect ( vehicle ) then
108048: LD_VAR 0 1
108052: PPUSH
108053: CALL 27990 0 1
108057: IFFALSE 108098
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108059: LD_VAR 0 1
108063: PPUSH
108064: LD_EXP 134
108068: PUSH
108069: LD_VAR 0 2
108073: ARRAY
108074: PUSH
108075: LD_INT 3
108077: ARRAY
108078: PPUSH
108079: LD_EXP 134
108083: PUSH
108084: LD_VAR 0 2
108088: ARRAY
108089: PUSH
108090: LD_INT 4
108092: ARRAY
108093: PPUSH
108094: CALL_OW 171
// end else
108098: GO 108139
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108100: LD_VAR 0 1
108104: PPUSH
108105: LD_EXP 134
108109: PUSH
108110: LD_VAR 0 2
108114: ARRAY
108115: PUSH
108116: LD_INT 3
108118: ARRAY
108119: PPUSH
108120: LD_EXP 134
108124: PUSH
108125: LD_VAR 0 2
108129: ARRAY
108130: PUSH
108131: LD_INT 4
108133: ARRAY
108134: PPUSH
108135: CALL_OW 171
// end ; end ;
108139: LD_VAR 0 3
108143: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108144: LD_INT 0
108146: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108147: LD_VAR 0 1
108151: PUSH
108152: LD_INT 250
108154: EQUAL
108155: PUSH
108156: LD_VAR 0 2
108160: PPUSH
108161: CALL_OW 264
108165: PUSH
108166: LD_INT 81
108168: EQUAL
108169: AND
108170: IFFALSE 108191
// MinerPlaceMine ( unit , x , y ) ;
108172: LD_VAR 0 2
108176: PPUSH
108177: LD_VAR 0 4
108181: PPUSH
108182: LD_VAR 0 5
108186: PPUSH
108187: CALL 110576 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108191: LD_VAR 0 1
108195: PUSH
108196: LD_INT 251
108198: EQUAL
108199: PUSH
108200: LD_VAR 0 2
108204: PPUSH
108205: CALL_OW 264
108209: PUSH
108210: LD_INT 81
108212: EQUAL
108213: AND
108214: IFFALSE 108235
// MinerDetonateMine ( unit , x , y ) ;
108216: LD_VAR 0 2
108220: PPUSH
108221: LD_VAR 0 4
108225: PPUSH
108226: LD_VAR 0 5
108230: PPUSH
108231: CALL 110851 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108235: LD_VAR 0 1
108239: PUSH
108240: LD_INT 252
108242: EQUAL
108243: PUSH
108244: LD_VAR 0 2
108248: PPUSH
108249: CALL_OW 264
108253: PUSH
108254: LD_INT 81
108256: EQUAL
108257: AND
108258: IFFALSE 108279
// MinerCreateMinefield ( unit , x , y ) ;
108260: LD_VAR 0 2
108264: PPUSH
108265: LD_VAR 0 4
108269: PPUSH
108270: LD_VAR 0 5
108274: PPUSH
108275: CALL 111268 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108279: LD_VAR 0 1
108283: PUSH
108284: LD_INT 253
108286: EQUAL
108287: PUSH
108288: LD_VAR 0 2
108292: PPUSH
108293: CALL_OW 257
108297: PUSH
108298: LD_INT 5
108300: EQUAL
108301: AND
108302: IFFALSE 108323
// ComBinocular ( unit , x , y ) ;
108304: LD_VAR 0 2
108308: PPUSH
108309: LD_VAR 0 4
108313: PPUSH
108314: LD_VAR 0 5
108318: PPUSH
108319: CALL 111637 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108323: LD_VAR 0 1
108327: PUSH
108328: LD_INT 254
108330: EQUAL
108331: PUSH
108332: LD_VAR 0 2
108336: PPUSH
108337: CALL_OW 264
108341: PUSH
108342: LD_INT 99
108344: EQUAL
108345: AND
108346: PUSH
108347: LD_VAR 0 3
108351: PPUSH
108352: CALL_OW 263
108356: PUSH
108357: LD_INT 3
108359: EQUAL
108360: AND
108361: IFFALSE 108377
// HackDestroyVehicle ( unit , selectedUnit ) ;
108363: LD_VAR 0 2
108367: PPUSH
108368: LD_VAR 0 3
108372: PPUSH
108373: CALL 109940 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108377: LD_VAR 0 1
108381: PUSH
108382: LD_INT 255
108384: EQUAL
108385: PUSH
108386: LD_VAR 0 2
108390: PPUSH
108391: CALL_OW 264
108395: PUSH
108396: LD_INT 14
108398: PUSH
108399: LD_INT 53
108401: PUSH
108402: EMPTY
108403: LIST
108404: LIST
108405: IN
108406: AND
108407: PUSH
108408: LD_VAR 0 4
108412: PPUSH
108413: LD_VAR 0 5
108417: PPUSH
108418: CALL_OW 488
108422: AND
108423: IFFALSE 108447
// CutTreeXYR ( unit , x , y , 12 ) ;
108425: LD_VAR 0 2
108429: PPUSH
108430: LD_VAR 0 4
108434: PPUSH
108435: LD_VAR 0 5
108439: PPUSH
108440: LD_INT 12
108442: PPUSH
108443: CALL 108510 0 4
// if cmd = 256 then
108447: LD_VAR 0 1
108451: PUSH
108452: LD_INT 256
108454: EQUAL
108455: IFFALSE 108476
// SetFactoryWaypoint ( unit , x , y ) ;
108457: LD_VAR 0 2
108461: PPUSH
108462: LD_VAR 0 4
108466: PPUSH
108467: LD_VAR 0 5
108471: PPUSH
108472: CALL 106457 0 3
// if cmd = 257 then
108476: LD_VAR 0 1
108480: PUSH
108481: LD_INT 257
108483: EQUAL
108484: IFFALSE 108505
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108486: LD_VAR 0 2
108490: PPUSH
108491: LD_VAR 0 4
108495: PPUSH
108496: LD_VAR 0 5
108500: PPUSH
108501: CALL 106819 0 3
// end ;
108505: LD_VAR 0 6
108509: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108510: LD_INT 0
108512: PPUSH
108513: PPUSH
108514: PPUSH
108515: PPUSH
108516: PPUSH
108517: PPUSH
108518: PPUSH
108519: PPUSH
108520: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108521: LD_VAR 0 1
108525: NOT
108526: PUSH
108527: LD_VAR 0 2
108531: PPUSH
108532: LD_VAR 0 3
108536: PPUSH
108537: CALL_OW 488
108541: NOT
108542: OR
108543: PUSH
108544: LD_VAR 0 4
108548: NOT
108549: OR
108550: IFFALSE 108554
// exit ;
108552: GO 108894
// list := [ ] ;
108554: LD_ADDR_VAR 0 13
108558: PUSH
108559: EMPTY
108560: ST_TO_ADDR
// if x - r < 0 then
108561: LD_VAR 0 2
108565: PUSH
108566: LD_VAR 0 4
108570: MINUS
108571: PUSH
108572: LD_INT 0
108574: LESS
108575: IFFALSE 108587
// min_x := 0 else
108577: LD_ADDR_VAR 0 7
108581: PUSH
108582: LD_INT 0
108584: ST_TO_ADDR
108585: GO 108603
// min_x := x - r ;
108587: LD_ADDR_VAR 0 7
108591: PUSH
108592: LD_VAR 0 2
108596: PUSH
108597: LD_VAR 0 4
108601: MINUS
108602: ST_TO_ADDR
// if y - r < 0 then
108603: LD_VAR 0 3
108607: PUSH
108608: LD_VAR 0 4
108612: MINUS
108613: PUSH
108614: LD_INT 0
108616: LESS
108617: IFFALSE 108629
// min_y := 0 else
108619: LD_ADDR_VAR 0 8
108623: PUSH
108624: LD_INT 0
108626: ST_TO_ADDR
108627: GO 108645
// min_y := y - r ;
108629: LD_ADDR_VAR 0 8
108633: PUSH
108634: LD_VAR 0 3
108638: PUSH
108639: LD_VAR 0 4
108643: MINUS
108644: ST_TO_ADDR
// max_x := x + r ;
108645: LD_ADDR_VAR 0 9
108649: PUSH
108650: LD_VAR 0 2
108654: PUSH
108655: LD_VAR 0 4
108659: PLUS
108660: ST_TO_ADDR
// max_y := y + r ;
108661: LD_ADDR_VAR 0 10
108665: PUSH
108666: LD_VAR 0 3
108670: PUSH
108671: LD_VAR 0 4
108675: PLUS
108676: ST_TO_ADDR
// for _x = min_x to max_x do
108677: LD_ADDR_VAR 0 11
108681: PUSH
108682: DOUBLE
108683: LD_VAR 0 7
108687: DEC
108688: ST_TO_ADDR
108689: LD_VAR 0 9
108693: PUSH
108694: FOR_TO
108695: IFFALSE 108812
// for _y = min_y to max_y do
108697: LD_ADDR_VAR 0 12
108701: PUSH
108702: DOUBLE
108703: LD_VAR 0 8
108707: DEC
108708: ST_TO_ADDR
108709: LD_VAR 0 10
108713: PUSH
108714: FOR_TO
108715: IFFALSE 108808
// begin if not ValidHex ( _x , _y ) then
108717: LD_VAR 0 11
108721: PPUSH
108722: LD_VAR 0 12
108726: PPUSH
108727: CALL_OW 488
108731: NOT
108732: IFFALSE 108736
// continue ;
108734: GO 108714
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108736: LD_VAR 0 11
108740: PPUSH
108741: LD_VAR 0 12
108745: PPUSH
108746: CALL_OW 351
108750: PUSH
108751: LD_VAR 0 11
108755: PPUSH
108756: LD_VAR 0 12
108760: PPUSH
108761: CALL_OW 554
108765: AND
108766: IFFALSE 108806
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108768: LD_ADDR_VAR 0 13
108772: PUSH
108773: LD_VAR 0 13
108777: PPUSH
108778: LD_VAR 0 13
108782: PUSH
108783: LD_INT 1
108785: PLUS
108786: PPUSH
108787: LD_VAR 0 11
108791: PUSH
108792: LD_VAR 0 12
108796: PUSH
108797: EMPTY
108798: LIST
108799: LIST
108800: PPUSH
108801: CALL_OW 2
108805: ST_TO_ADDR
// end ;
108806: GO 108714
108808: POP
108809: POP
108810: GO 108694
108812: POP
108813: POP
// if not list then
108814: LD_VAR 0 13
108818: NOT
108819: IFFALSE 108823
// exit ;
108821: GO 108894
// for i in list do
108823: LD_ADDR_VAR 0 6
108827: PUSH
108828: LD_VAR 0 13
108832: PUSH
108833: FOR_IN
108834: IFFALSE 108892
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108836: LD_VAR 0 1
108840: PPUSH
108841: LD_STRING M
108843: PUSH
108844: LD_VAR 0 6
108848: PUSH
108849: LD_INT 1
108851: ARRAY
108852: PUSH
108853: LD_VAR 0 6
108857: PUSH
108858: LD_INT 2
108860: ARRAY
108861: PUSH
108862: LD_INT 0
108864: PUSH
108865: LD_INT 0
108867: PUSH
108868: LD_INT 0
108870: PUSH
108871: LD_INT 0
108873: PUSH
108874: EMPTY
108875: LIST
108876: LIST
108877: LIST
108878: LIST
108879: LIST
108880: LIST
108881: LIST
108882: PUSH
108883: EMPTY
108884: LIST
108885: PPUSH
108886: CALL_OW 447
108890: GO 108833
108892: POP
108893: POP
// end ;
108894: LD_VAR 0 5
108898: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108899: LD_EXP 137
108903: NOT
108904: IFFALSE 108954
108906: GO 108908
108908: DISABLE
// begin initHack := true ;
108909: LD_ADDR_EXP 137
108913: PUSH
108914: LD_INT 1
108916: ST_TO_ADDR
// hackTanks := [ ] ;
108917: LD_ADDR_EXP 138
108921: PUSH
108922: EMPTY
108923: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108924: LD_ADDR_EXP 139
108928: PUSH
108929: EMPTY
108930: ST_TO_ADDR
// hackLimit := 3 ;
108931: LD_ADDR_EXP 140
108935: PUSH
108936: LD_INT 3
108938: ST_TO_ADDR
// hackDist := 12 ;
108939: LD_ADDR_EXP 141
108943: PUSH
108944: LD_INT 12
108946: ST_TO_ADDR
// hackCounter := [ ] ;
108947: LD_ADDR_EXP 142
108951: PUSH
108952: EMPTY
108953: ST_TO_ADDR
// end ;
108954: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108955: LD_EXP 137
108959: PUSH
108960: LD_INT 34
108962: PUSH
108963: LD_INT 99
108965: PUSH
108966: EMPTY
108967: LIST
108968: LIST
108969: PPUSH
108970: CALL_OW 69
108974: AND
108975: IFFALSE 109228
108977: GO 108979
108979: DISABLE
108980: LD_INT 0
108982: PPUSH
108983: PPUSH
// begin enable ;
108984: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108985: LD_ADDR_VAR 0 1
108989: PUSH
108990: LD_INT 34
108992: PUSH
108993: LD_INT 99
108995: PUSH
108996: EMPTY
108997: LIST
108998: LIST
108999: PPUSH
109000: CALL_OW 69
109004: PUSH
109005: FOR_IN
109006: IFFALSE 109226
// begin if not i in hackTanks then
109008: LD_VAR 0 1
109012: PUSH
109013: LD_EXP 138
109017: IN
109018: NOT
109019: IFFALSE 109102
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
109021: LD_ADDR_EXP 138
109025: PUSH
109026: LD_EXP 138
109030: PPUSH
109031: LD_EXP 138
109035: PUSH
109036: LD_INT 1
109038: PLUS
109039: PPUSH
109040: LD_VAR 0 1
109044: PPUSH
109045: CALL_OW 1
109049: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109050: LD_ADDR_EXP 139
109054: PUSH
109055: LD_EXP 139
109059: PPUSH
109060: LD_EXP 139
109064: PUSH
109065: LD_INT 1
109067: PLUS
109068: PPUSH
109069: EMPTY
109070: PPUSH
109071: CALL_OW 1
109075: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
109076: LD_ADDR_EXP 142
109080: PUSH
109081: LD_EXP 142
109085: PPUSH
109086: LD_EXP 142
109090: PUSH
109091: LD_INT 1
109093: PLUS
109094: PPUSH
109095: EMPTY
109096: PPUSH
109097: CALL_OW 1
109101: ST_TO_ADDR
// end ; if not IsOk ( i ) then
109102: LD_VAR 0 1
109106: PPUSH
109107: CALL_OW 302
109111: NOT
109112: IFFALSE 109125
// begin HackUnlinkAll ( i ) ;
109114: LD_VAR 0 1
109118: PPUSH
109119: CALL 109231 0 1
// continue ;
109123: GO 109005
// end ; HackCheckCapturedStatus ( i ) ;
109125: LD_VAR 0 1
109129: PPUSH
109130: CALL 109674 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
109134: LD_ADDR_VAR 0 2
109138: PUSH
109139: LD_INT 81
109141: PUSH
109142: LD_VAR 0 1
109146: PPUSH
109147: CALL_OW 255
109151: PUSH
109152: EMPTY
109153: LIST
109154: LIST
109155: PUSH
109156: LD_INT 33
109158: PUSH
109159: LD_INT 3
109161: PUSH
109162: EMPTY
109163: LIST
109164: LIST
109165: PUSH
109166: LD_INT 91
109168: PUSH
109169: LD_VAR 0 1
109173: PUSH
109174: LD_EXP 141
109178: PUSH
109179: EMPTY
109180: LIST
109181: LIST
109182: LIST
109183: PUSH
109184: LD_INT 50
109186: PUSH
109187: EMPTY
109188: LIST
109189: PUSH
109190: EMPTY
109191: LIST
109192: LIST
109193: LIST
109194: LIST
109195: PPUSH
109196: CALL_OW 69
109200: ST_TO_ADDR
// if not tmp then
109201: LD_VAR 0 2
109205: NOT
109206: IFFALSE 109210
// continue ;
109208: GO 109005
// HackLink ( i , tmp ) ;
109210: LD_VAR 0 1
109214: PPUSH
109215: LD_VAR 0 2
109219: PPUSH
109220: CALL 109367 0 2
// end ;
109224: GO 109005
109226: POP
109227: POP
// end ;
109228: PPOPN 2
109230: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109231: LD_INT 0
109233: PPUSH
109234: PPUSH
109235: PPUSH
// if not hack in hackTanks then
109236: LD_VAR 0 1
109240: PUSH
109241: LD_EXP 138
109245: IN
109246: NOT
109247: IFFALSE 109251
// exit ;
109249: GO 109362
// index := GetElementIndex ( hackTanks , hack ) ;
109251: LD_ADDR_VAR 0 4
109255: PUSH
109256: LD_EXP 138
109260: PPUSH
109261: LD_VAR 0 1
109265: PPUSH
109266: CALL 24806 0 2
109270: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109271: LD_EXP 139
109275: PUSH
109276: LD_VAR 0 4
109280: ARRAY
109281: IFFALSE 109362
// begin for i in hackTanksCaptured [ index ] do
109283: LD_ADDR_VAR 0 3
109287: PUSH
109288: LD_EXP 139
109292: PUSH
109293: LD_VAR 0 4
109297: ARRAY
109298: PUSH
109299: FOR_IN
109300: IFFALSE 109326
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109302: LD_VAR 0 3
109306: PUSH
109307: LD_INT 1
109309: ARRAY
109310: PPUSH
109311: LD_VAR 0 3
109315: PUSH
109316: LD_INT 2
109318: ARRAY
109319: PPUSH
109320: CALL_OW 235
109324: GO 109299
109326: POP
109327: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109328: LD_ADDR_EXP 139
109332: PUSH
109333: LD_EXP 139
109337: PPUSH
109338: LD_VAR 0 4
109342: PPUSH
109343: EMPTY
109344: PPUSH
109345: CALL_OW 1
109349: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109350: LD_VAR 0 1
109354: PPUSH
109355: LD_INT 0
109357: PPUSH
109358: CALL_OW 505
// end ; end ;
109362: LD_VAR 0 2
109366: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109367: LD_INT 0
109369: PPUSH
109370: PPUSH
109371: PPUSH
// if not hack in hackTanks or not vehicles then
109372: LD_VAR 0 1
109376: PUSH
109377: LD_EXP 138
109381: IN
109382: NOT
109383: PUSH
109384: LD_VAR 0 2
109388: NOT
109389: OR
109390: IFFALSE 109394
// exit ;
109392: GO 109669
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109394: LD_ADDR_VAR 0 2
109398: PUSH
109399: LD_VAR 0 1
109403: PPUSH
109404: LD_VAR 0 2
109408: PPUSH
109409: LD_INT 1
109411: PPUSH
109412: LD_INT 1
109414: PPUSH
109415: CALL 25456 0 4
109419: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109420: LD_ADDR_VAR 0 5
109424: PUSH
109425: LD_EXP 138
109429: PPUSH
109430: LD_VAR 0 1
109434: PPUSH
109435: CALL 24806 0 2
109439: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109440: LD_EXP 139
109444: PUSH
109445: LD_VAR 0 5
109449: ARRAY
109450: PUSH
109451: LD_EXP 140
109455: LESS
109456: IFFALSE 109645
// begin for i := 1 to vehicles do
109458: LD_ADDR_VAR 0 4
109462: PUSH
109463: DOUBLE
109464: LD_INT 1
109466: DEC
109467: ST_TO_ADDR
109468: LD_VAR 0 2
109472: PUSH
109473: FOR_TO
109474: IFFALSE 109643
// begin if hackTanksCaptured [ index ] = hackLimit then
109476: LD_EXP 139
109480: PUSH
109481: LD_VAR 0 5
109485: ARRAY
109486: PUSH
109487: LD_EXP 140
109491: EQUAL
109492: IFFALSE 109496
// break ;
109494: GO 109643
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109496: LD_ADDR_EXP 142
109500: PUSH
109501: LD_EXP 142
109505: PPUSH
109506: LD_VAR 0 5
109510: PPUSH
109511: LD_EXP 142
109515: PUSH
109516: LD_VAR 0 5
109520: ARRAY
109521: PUSH
109522: LD_INT 1
109524: PLUS
109525: PPUSH
109526: CALL_OW 1
109530: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109531: LD_ADDR_EXP 139
109535: PUSH
109536: LD_EXP 139
109540: PPUSH
109541: LD_VAR 0 5
109545: PUSH
109546: LD_EXP 139
109550: PUSH
109551: LD_VAR 0 5
109555: ARRAY
109556: PUSH
109557: LD_INT 1
109559: PLUS
109560: PUSH
109561: EMPTY
109562: LIST
109563: LIST
109564: PPUSH
109565: LD_VAR 0 2
109569: PUSH
109570: LD_VAR 0 4
109574: ARRAY
109575: PUSH
109576: LD_VAR 0 2
109580: PUSH
109581: LD_VAR 0 4
109585: ARRAY
109586: PPUSH
109587: CALL_OW 255
109591: PUSH
109592: EMPTY
109593: LIST
109594: LIST
109595: PPUSH
109596: CALL 25021 0 3
109600: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109601: LD_VAR 0 2
109605: PUSH
109606: LD_VAR 0 4
109610: ARRAY
109611: PPUSH
109612: LD_VAR 0 1
109616: PPUSH
109617: CALL_OW 255
109621: PPUSH
109622: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109626: LD_VAR 0 2
109630: PUSH
109631: LD_VAR 0 4
109635: ARRAY
109636: PPUSH
109637: CALL_OW 141
// end ;
109641: GO 109473
109643: POP
109644: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109645: LD_VAR 0 1
109649: PPUSH
109650: LD_EXP 139
109654: PUSH
109655: LD_VAR 0 5
109659: ARRAY
109660: PUSH
109661: LD_INT 0
109663: PLUS
109664: PPUSH
109665: CALL_OW 505
// end ;
109669: LD_VAR 0 3
109673: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109674: LD_INT 0
109676: PPUSH
109677: PPUSH
109678: PPUSH
109679: PPUSH
// if not hack in hackTanks then
109680: LD_VAR 0 1
109684: PUSH
109685: LD_EXP 138
109689: IN
109690: NOT
109691: IFFALSE 109695
// exit ;
109693: GO 109935
// index := GetElementIndex ( hackTanks , hack ) ;
109695: LD_ADDR_VAR 0 4
109699: PUSH
109700: LD_EXP 138
109704: PPUSH
109705: LD_VAR 0 1
109709: PPUSH
109710: CALL 24806 0 2
109714: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109715: LD_ADDR_VAR 0 3
109719: PUSH
109720: DOUBLE
109721: LD_EXP 139
109725: PUSH
109726: LD_VAR 0 4
109730: ARRAY
109731: INC
109732: ST_TO_ADDR
109733: LD_INT 1
109735: PUSH
109736: FOR_DOWNTO
109737: IFFALSE 109909
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109739: LD_ADDR_VAR 0 5
109743: PUSH
109744: LD_EXP 139
109748: PUSH
109749: LD_VAR 0 4
109753: ARRAY
109754: PUSH
109755: LD_VAR 0 3
109759: ARRAY
109760: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109761: LD_VAR 0 5
109765: PUSH
109766: LD_INT 1
109768: ARRAY
109769: PPUSH
109770: CALL_OW 302
109774: NOT
109775: PUSH
109776: LD_VAR 0 5
109780: PUSH
109781: LD_INT 1
109783: ARRAY
109784: PPUSH
109785: CALL_OW 255
109789: PUSH
109790: LD_VAR 0 1
109794: PPUSH
109795: CALL_OW 255
109799: NONEQUAL
109800: OR
109801: IFFALSE 109907
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109803: LD_VAR 0 5
109807: PUSH
109808: LD_INT 1
109810: ARRAY
109811: PPUSH
109812: CALL_OW 305
109816: PUSH
109817: LD_VAR 0 5
109821: PUSH
109822: LD_INT 1
109824: ARRAY
109825: PPUSH
109826: CALL_OW 255
109830: PUSH
109831: LD_VAR 0 1
109835: PPUSH
109836: CALL_OW 255
109840: EQUAL
109841: AND
109842: IFFALSE 109866
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109844: LD_VAR 0 5
109848: PUSH
109849: LD_INT 1
109851: ARRAY
109852: PPUSH
109853: LD_VAR 0 5
109857: PUSH
109858: LD_INT 2
109860: ARRAY
109861: PPUSH
109862: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109866: LD_ADDR_EXP 139
109870: PUSH
109871: LD_EXP 139
109875: PPUSH
109876: LD_VAR 0 4
109880: PPUSH
109881: LD_EXP 139
109885: PUSH
109886: LD_VAR 0 4
109890: ARRAY
109891: PPUSH
109892: LD_VAR 0 3
109896: PPUSH
109897: CALL_OW 3
109901: PPUSH
109902: CALL_OW 1
109906: ST_TO_ADDR
// end ; end ;
109907: GO 109736
109909: POP
109910: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109911: LD_VAR 0 1
109915: PPUSH
109916: LD_EXP 139
109920: PUSH
109921: LD_VAR 0 4
109925: ARRAY
109926: PUSH
109927: LD_INT 0
109929: PLUS
109930: PPUSH
109931: CALL_OW 505
// end ;
109935: LD_VAR 0 2
109939: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109940: LD_INT 0
109942: PPUSH
109943: PPUSH
109944: PPUSH
109945: PPUSH
// if not hack in hackTanks then
109946: LD_VAR 0 1
109950: PUSH
109951: LD_EXP 138
109955: IN
109956: NOT
109957: IFFALSE 109961
// exit ;
109959: GO 110046
// index := GetElementIndex ( hackTanks , hack ) ;
109961: LD_ADDR_VAR 0 5
109965: PUSH
109966: LD_EXP 138
109970: PPUSH
109971: LD_VAR 0 1
109975: PPUSH
109976: CALL 24806 0 2
109980: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109981: LD_ADDR_VAR 0 4
109985: PUSH
109986: DOUBLE
109987: LD_INT 1
109989: DEC
109990: ST_TO_ADDR
109991: LD_EXP 139
109995: PUSH
109996: LD_VAR 0 5
110000: ARRAY
110001: PUSH
110002: FOR_TO
110003: IFFALSE 110044
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
110005: LD_EXP 139
110009: PUSH
110010: LD_VAR 0 5
110014: ARRAY
110015: PUSH
110016: LD_VAR 0 4
110020: ARRAY
110021: PUSH
110022: LD_INT 1
110024: ARRAY
110025: PUSH
110026: LD_VAR 0 2
110030: EQUAL
110031: IFFALSE 110042
// KillUnit ( vehicle ) ;
110033: LD_VAR 0 2
110037: PPUSH
110038: CALL_OW 66
110042: GO 110002
110044: POP
110045: POP
// end ;
110046: LD_VAR 0 3
110050: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110051: LD_EXP 143
110055: NOT
110056: IFFALSE 110091
110058: GO 110060
110060: DISABLE
// begin initMiner := true ;
110061: LD_ADDR_EXP 143
110065: PUSH
110066: LD_INT 1
110068: ST_TO_ADDR
// minersList := [ ] ;
110069: LD_ADDR_EXP 144
110073: PUSH
110074: EMPTY
110075: ST_TO_ADDR
// minerMinesList := [ ] ;
110076: LD_ADDR_EXP 145
110080: PUSH
110081: EMPTY
110082: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
110083: LD_ADDR_EXP 146
110087: PUSH
110088: LD_INT 5
110090: ST_TO_ADDR
// end ;
110091: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
110092: LD_EXP 143
110096: PUSH
110097: LD_INT 34
110099: PUSH
110100: LD_INT 81
110102: PUSH
110103: EMPTY
110104: LIST
110105: LIST
110106: PPUSH
110107: CALL_OW 69
110111: AND
110112: IFFALSE 110573
110114: GO 110116
110116: DISABLE
110117: LD_INT 0
110119: PPUSH
110120: PPUSH
110121: PPUSH
110122: PPUSH
// begin enable ;
110123: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
110124: LD_ADDR_VAR 0 1
110128: PUSH
110129: LD_INT 34
110131: PUSH
110132: LD_INT 81
110134: PUSH
110135: EMPTY
110136: LIST
110137: LIST
110138: PPUSH
110139: CALL_OW 69
110143: PUSH
110144: FOR_IN
110145: IFFALSE 110217
// begin if not i in minersList then
110147: LD_VAR 0 1
110151: PUSH
110152: LD_EXP 144
110156: IN
110157: NOT
110158: IFFALSE 110215
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
110160: LD_ADDR_EXP 144
110164: PUSH
110165: LD_EXP 144
110169: PPUSH
110170: LD_EXP 144
110174: PUSH
110175: LD_INT 1
110177: PLUS
110178: PPUSH
110179: LD_VAR 0 1
110183: PPUSH
110184: CALL_OW 1
110188: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110189: LD_ADDR_EXP 145
110193: PUSH
110194: LD_EXP 145
110198: PPUSH
110199: LD_EXP 145
110203: PUSH
110204: LD_INT 1
110206: PLUS
110207: PPUSH
110208: EMPTY
110209: PPUSH
110210: CALL_OW 1
110214: ST_TO_ADDR
// end end ;
110215: GO 110144
110217: POP
110218: POP
// for i := minerMinesList downto 1 do
110219: LD_ADDR_VAR 0 1
110223: PUSH
110224: DOUBLE
110225: LD_EXP 145
110229: INC
110230: ST_TO_ADDR
110231: LD_INT 1
110233: PUSH
110234: FOR_DOWNTO
110235: IFFALSE 110571
// begin if IsLive ( minersList [ i ] ) then
110237: LD_EXP 144
110241: PUSH
110242: LD_VAR 0 1
110246: ARRAY
110247: PPUSH
110248: CALL_OW 300
110252: IFFALSE 110280
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110254: LD_EXP 144
110258: PUSH
110259: LD_VAR 0 1
110263: ARRAY
110264: PPUSH
110265: LD_EXP 145
110269: PUSH
110270: LD_VAR 0 1
110274: ARRAY
110275: PPUSH
110276: CALL_OW 505
// if not minerMinesList [ i ] then
110280: LD_EXP 145
110284: PUSH
110285: LD_VAR 0 1
110289: ARRAY
110290: NOT
110291: IFFALSE 110295
// continue ;
110293: GO 110234
// for j := minerMinesList [ i ] downto 1 do
110295: LD_ADDR_VAR 0 2
110299: PUSH
110300: DOUBLE
110301: LD_EXP 145
110305: PUSH
110306: LD_VAR 0 1
110310: ARRAY
110311: INC
110312: ST_TO_ADDR
110313: LD_INT 1
110315: PUSH
110316: FOR_DOWNTO
110317: IFFALSE 110567
// begin side := GetSide ( minersList [ i ] ) ;
110319: LD_ADDR_VAR 0 3
110323: PUSH
110324: LD_EXP 144
110328: PUSH
110329: LD_VAR 0 1
110333: ARRAY
110334: PPUSH
110335: CALL_OW 255
110339: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110340: LD_ADDR_VAR 0 4
110344: PUSH
110345: LD_EXP 145
110349: PUSH
110350: LD_VAR 0 1
110354: ARRAY
110355: PUSH
110356: LD_VAR 0 2
110360: ARRAY
110361: PUSH
110362: LD_INT 1
110364: ARRAY
110365: PPUSH
110366: LD_EXP 145
110370: PUSH
110371: LD_VAR 0 1
110375: ARRAY
110376: PUSH
110377: LD_VAR 0 2
110381: ARRAY
110382: PUSH
110383: LD_INT 2
110385: ARRAY
110386: PPUSH
110387: CALL_OW 428
110391: ST_TO_ADDR
// if not tmp then
110392: LD_VAR 0 4
110396: NOT
110397: IFFALSE 110401
// continue ;
110399: GO 110316
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110401: LD_VAR 0 4
110405: PUSH
110406: LD_INT 81
110408: PUSH
110409: LD_VAR 0 3
110413: PUSH
110414: EMPTY
110415: LIST
110416: LIST
110417: PPUSH
110418: CALL_OW 69
110422: IN
110423: PUSH
110424: LD_EXP 145
110428: PUSH
110429: LD_VAR 0 1
110433: ARRAY
110434: PUSH
110435: LD_VAR 0 2
110439: ARRAY
110440: PUSH
110441: LD_INT 1
110443: ARRAY
110444: PPUSH
110445: LD_EXP 145
110449: PUSH
110450: LD_VAR 0 1
110454: ARRAY
110455: PUSH
110456: LD_VAR 0 2
110460: ARRAY
110461: PUSH
110462: LD_INT 2
110464: ARRAY
110465: PPUSH
110466: CALL_OW 458
110470: AND
110471: IFFALSE 110565
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110473: LD_EXP 145
110477: PUSH
110478: LD_VAR 0 1
110482: ARRAY
110483: PUSH
110484: LD_VAR 0 2
110488: ARRAY
110489: PUSH
110490: LD_INT 1
110492: ARRAY
110493: PPUSH
110494: LD_EXP 145
110498: PUSH
110499: LD_VAR 0 1
110503: ARRAY
110504: PUSH
110505: LD_VAR 0 2
110509: ARRAY
110510: PUSH
110511: LD_INT 2
110513: ARRAY
110514: PPUSH
110515: LD_VAR 0 3
110519: PPUSH
110520: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110524: LD_ADDR_EXP 145
110528: PUSH
110529: LD_EXP 145
110533: PPUSH
110534: LD_VAR 0 1
110538: PPUSH
110539: LD_EXP 145
110543: PUSH
110544: LD_VAR 0 1
110548: ARRAY
110549: PPUSH
110550: LD_VAR 0 2
110554: PPUSH
110555: CALL_OW 3
110559: PPUSH
110560: CALL_OW 1
110564: ST_TO_ADDR
// end ; end ;
110565: GO 110316
110567: POP
110568: POP
// end ;
110569: GO 110234
110571: POP
110572: POP
// end ;
110573: PPOPN 4
110575: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110576: LD_INT 0
110578: PPUSH
110579: PPUSH
// result := false ;
110580: LD_ADDR_VAR 0 4
110584: PUSH
110585: LD_INT 0
110587: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110588: LD_VAR 0 1
110592: PPUSH
110593: CALL_OW 264
110597: PUSH
110598: LD_INT 81
110600: EQUAL
110601: NOT
110602: IFFALSE 110606
// exit ;
110604: GO 110846
// index := GetElementIndex ( minersList , unit ) ;
110606: LD_ADDR_VAR 0 5
110610: PUSH
110611: LD_EXP 144
110615: PPUSH
110616: LD_VAR 0 1
110620: PPUSH
110621: CALL 24806 0 2
110625: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110626: LD_EXP 145
110630: PUSH
110631: LD_VAR 0 5
110635: ARRAY
110636: PUSH
110637: LD_EXP 146
110641: GREATEREQUAL
110642: IFFALSE 110646
// exit ;
110644: GO 110846
// ComMoveXY ( unit , x , y ) ;
110646: LD_VAR 0 1
110650: PPUSH
110651: LD_VAR 0 2
110655: PPUSH
110656: LD_VAR 0 3
110660: PPUSH
110661: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110665: LD_INT 35
110667: PPUSH
110668: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110672: LD_VAR 0 1
110676: PPUSH
110677: LD_VAR 0 2
110681: PPUSH
110682: LD_VAR 0 3
110686: PPUSH
110687: CALL 56161 0 3
110691: NOT
110692: PUSH
110693: LD_VAR 0 1
110697: PPUSH
110698: CALL_OW 314
110702: AND
110703: IFFALSE 110707
// exit ;
110705: GO 110846
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110707: LD_VAR 0 2
110711: PPUSH
110712: LD_VAR 0 3
110716: PPUSH
110717: CALL_OW 428
110721: PUSH
110722: LD_VAR 0 1
110726: EQUAL
110727: PUSH
110728: LD_VAR 0 1
110732: PPUSH
110733: CALL_OW 314
110737: NOT
110738: AND
110739: IFFALSE 110665
// PlaySoundXY ( x , y , PlantMine ) ;
110741: LD_VAR 0 2
110745: PPUSH
110746: LD_VAR 0 3
110750: PPUSH
110751: LD_STRING PlantMine
110753: PPUSH
110754: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110758: LD_VAR 0 2
110762: PPUSH
110763: LD_VAR 0 3
110767: PPUSH
110768: LD_VAR 0 1
110772: PPUSH
110773: CALL_OW 255
110777: PPUSH
110778: LD_INT 0
110780: PPUSH
110781: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110785: LD_ADDR_EXP 145
110789: PUSH
110790: LD_EXP 145
110794: PPUSH
110795: LD_VAR 0 5
110799: PUSH
110800: LD_EXP 145
110804: PUSH
110805: LD_VAR 0 5
110809: ARRAY
110810: PUSH
110811: LD_INT 1
110813: PLUS
110814: PUSH
110815: EMPTY
110816: LIST
110817: LIST
110818: PPUSH
110819: LD_VAR 0 2
110823: PUSH
110824: LD_VAR 0 3
110828: PUSH
110829: EMPTY
110830: LIST
110831: LIST
110832: PPUSH
110833: CALL 25021 0 3
110837: ST_TO_ADDR
// result := true ;
110838: LD_ADDR_VAR 0 4
110842: PUSH
110843: LD_INT 1
110845: ST_TO_ADDR
// end ;
110846: LD_VAR 0 4
110850: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110851: LD_INT 0
110853: PPUSH
110854: PPUSH
110855: PPUSH
// if not unit in minersList then
110856: LD_VAR 0 1
110860: PUSH
110861: LD_EXP 144
110865: IN
110866: NOT
110867: IFFALSE 110871
// exit ;
110869: GO 111263
// index := GetElementIndex ( minersList , unit ) ;
110871: LD_ADDR_VAR 0 6
110875: PUSH
110876: LD_EXP 144
110880: PPUSH
110881: LD_VAR 0 1
110885: PPUSH
110886: CALL 24806 0 2
110890: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110891: LD_ADDR_VAR 0 5
110895: PUSH
110896: DOUBLE
110897: LD_EXP 145
110901: PUSH
110902: LD_VAR 0 6
110906: ARRAY
110907: INC
110908: ST_TO_ADDR
110909: LD_INT 1
110911: PUSH
110912: FOR_DOWNTO
110913: IFFALSE 111074
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110915: LD_EXP 145
110919: PUSH
110920: LD_VAR 0 6
110924: ARRAY
110925: PUSH
110926: LD_VAR 0 5
110930: ARRAY
110931: PUSH
110932: LD_INT 1
110934: ARRAY
110935: PUSH
110936: LD_VAR 0 2
110940: EQUAL
110941: PUSH
110942: LD_EXP 145
110946: PUSH
110947: LD_VAR 0 6
110951: ARRAY
110952: PUSH
110953: LD_VAR 0 5
110957: ARRAY
110958: PUSH
110959: LD_INT 2
110961: ARRAY
110962: PUSH
110963: LD_VAR 0 3
110967: EQUAL
110968: AND
110969: IFFALSE 111072
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110971: LD_EXP 145
110975: PUSH
110976: LD_VAR 0 6
110980: ARRAY
110981: PUSH
110982: LD_VAR 0 5
110986: ARRAY
110987: PUSH
110988: LD_INT 1
110990: ARRAY
110991: PPUSH
110992: LD_EXP 145
110996: PUSH
110997: LD_VAR 0 6
111001: ARRAY
111002: PUSH
111003: LD_VAR 0 5
111007: ARRAY
111008: PUSH
111009: LD_INT 2
111011: ARRAY
111012: PPUSH
111013: LD_VAR 0 1
111017: PPUSH
111018: CALL_OW 255
111022: PPUSH
111023: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111027: LD_ADDR_EXP 145
111031: PUSH
111032: LD_EXP 145
111036: PPUSH
111037: LD_VAR 0 6
111041: PPUSH
111042: LD_EXP 145
111046: PUSH
111047: LD_VAR 0 6
111051: ARRAY
111052: PPUSH
111053: LD_VAR 0 5
111057: PPUSH
111058: CALL_OW 3
111062: PPUSH
111063: CALL_OW 1
111067: ST_TO_ADDR
// exit ;
111068: POP
111069: POP
111070: GO 111263
// end ; end ;
111072: GO 110912
111074: POP
111075: POP
// for i := minerMinesList [ index ] downto 1 do
111076: LD_ADDR_VAR 0 5
111080: PUSH
111081: DOUBLE
111082: LD_EXP 145
111086: PUSH
111087: LD_VAR 0 6
111091: ARRAY
111092: INC
111093: ST_TO_ADDR
111094: LD_INT 1
111096: PUSH
111097: FOR_DOWNTO
111098: IFFALSE 111261
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
111100: LD_EXP 145
111104: PUSH
111105: LD_VAR 0 6
111109: ARRAY
111110: PUSH
111111: LD_VAR 0 5
111115: ARRAY
111116: PUSH
111117: LD_INT 1
111119: ARRAY
111120: PPUSH
111121: LD_EXP 145
111125: PUSH
111126: LD_VAR 0 6
111130: ARRAY
111131: PUSH
111132: LD_VAR 0 5
111136: ARRAY
111137: PUSH
111138: LD_INT 2
111140: ARRAY
111141: PPUSH
111142: LD_VAR 0 2
111146: PPUSH
111147: LD_VAR 0 3
111151: PPUSH
111152: CALL_OW 298
111156: PUSH
111157: LD_INT 6
111159: LESS
111160: IFFALSE 111259
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111162: LD_EXP 145
111166: PUSH
111167: LD_VAR 0 6
111171: ARRAY
111172: PUSH
111173: LD_VAR 0 5
111177: ARRAY
111178: PUSH
111179: LD_INT 1
111181: ARRAY
111182: PPUSH
111183: LD_EXP 145
111187: PUSH
111188: LD_VAR 0 6
111192: ARRAY
111193: PUSH
111194: LD_VAR 0 5
111198: ARRAY
111199: PUSH
111200: LD_INT 2
111202: ARRAY
111203: PPUSH
111204: LD_VAR 0 1
111208: PPUSH
111209: CALL_OW 255
111213: PPUSH
111214: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111218: LD_ADDR_EXP 145
111222: PUSH
111223: LD_EXP 145
111227: PPUSH
111228: LD_VAR 0 6
111232: PPUSH
111233: LD_EXP 145
111237: PUSH
111238: LD_VAR 0 6
111242: ARRAY
111243: PPUSH
111244: LD_VAR 0 5
111248: PPUSH
111249: CALL_OW 3
111253: PPUSH
111254: CALL_OW 1
111258: ST_TO_ADDR
// end ; end ;
111259: GO 111097
111261: POP
111262: POP
// end ;
111263: LD_VAR 0 4
111267: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111268: LD_INT 0
111270: PPUSH
111271: PPUSH
111272: PPUSH
111273: PPUSH
111274: PPUSH
111275: PPUSH
111276: PPUSH
111277: PPUSH
111278: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111279: LD_VAR 0 1
111283: PPUSH
111284: CALL_OW 264
111288: PUSH
111289: LD_INT 81
111291: EQUAL
111292: NOT
111293: PUSH
111294: LD_VAR 0 1
111298: PUSH
111299: LD_EXP 144
111303: IN
111304: NOT
111305: OR
111306: IFFALSE 111310
// exit ;
111308: GO 111632
// index := GetElementIndex ( minersList , unit ) ;
111310: LD_ADDR_VAR 0 6
111314: PUSH
111315: LD_EXP 144
111319: PPUSH
111320: LD_VAR 0 1
111324: PPUSH
111325: CALL 24806 0 2
111329: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111330: LD_ADDR_VAR 0 8
111334: PUSH
111335: LD_EXP 146
111339: PUSH
111340: LD_EXP 145
111344: PUSH
111345: LD_VAR 0 6
111349: ARRAY
111350: MINUS
111351: ST_TO_ADDR
// if not minesFreeAmount then
111352: LD_VAR 0 8
111356: NOT
111357: IFFALSE 111361
// exit ;
111359: GO 111632
// tmp := [ ] ;
111361: LD_ADDR_VAR 0 7
111365: PUSH
111366: EMPTY
111367: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111368: LD_ADDR_VAR 0 5
111372: PUSH
111373: DOUBLE
111374: LD_INT 1
111376: DEC
111377: ST_TO_ADDR
111378: LD_VAR 0 8
111382: PUSH
111383: FOR_TO
111384: IFFALSE 111579
// begin _d := rand ( 0 , 5 ) ;
111386: LD_ADDR_VAR 0 11
111390: PUSH
111391: LD_INT 0
111393: PPUSH
111394: LD_INT 5
111396: PPUSH
111397: CALL_OW 12
111401: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111402: LD_ADDR_VAR 0 12
111406: PUSH
111407: LD_INT 2
111409: PPUSH
111410: LD_INT 6
111412: PPUSH
111413: CALL_OW 12
111417: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111418: LD_ADDR_VAR 0 9
111422: PUSH
111423: LD_VAR 0 2
111427: PPUSH
111428: LD_VAR 0 11
111432: PPUSH
111433: LD_VAR 0 12
111437: PPUSH
111438: CALL_OW 272
111442: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111443: LD_ADDR_VAR 0 10
111447: PUSH
111448: LD_VAR 0 3
111452: PPUSH
111453: LD_VAR 0 11
111457: PPUSH
111458: LD_VAR 0 12
111462: PPUSH
111463: CALL_OW 273
111467: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111468: LD_VAR 0 9
111472: PPUSH
111473: LD_VAR 0 10
111477: PPUSH
111478: CALL_OW 488
111482: PUSH
111483: LD_VAR 0 9
111487: PUSH
111488: LD_VAR 0 10
111492: PUSH
111493: EMPTY
111494: LIST
111495: LIST
111496: PUSH
111497: LD_VAR 0 7
111501: IN
111502: NOT
111503: AND
111504: PUSH
111505: LD_VAR 0 9
111509: PPUSH
111510: LD_VAR 0 10
111514: PPUSH
111515: CALL_OW 458
111519: NOT
111520: AND
111521: IFFALSE 111563
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111523: LD_ADDR_VAR 0 7
111527: PUSH
111528: LD_VAR 0 7
111532: PPUSH
111533: LD_VAR 0 7
111537: PUSH
111538: LD_INT 1
111540: PLUS
111541: PPUSH
111542: LD_VAR 0 9
111546: PUSH
111547: LD_VAR 0 10
111551: PUSH
111552: EMPTY
111553: LIST
111554: LIST
111555: PPUSH
111556: CALL_OW 1
111560: ST_TO_ADDR
111561: GO 111577
// i := i - 1 ;
111563: LD_ADDR_VAR 0 5
111567: PUSH
111568: LD_VAR 0 5
111572: PUSH
111573: LD_INT 1
111575: MINUS
111576: ST_TO_ADDR
// end ;
111577: GO 111383
111579: POP
111580: POP
// for i in tmp do
111581: LD_ADDR_VAR 0 5
111585: PUSH
111586: LD_VAR 0 7
111590: PUSH
111591: FOR_IN
111592: IFFALSE 111630
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111594: LD_VAR 0 1
111598: PPUSH
111599: LD_VAR 0 5
111603: PUSH
111604: LD_INT 1
111606: ARRAY
111607: PPUSH
111608: LD_VAR 0 5
111612: PUSH
111613: LD_INT 2
111615: ARRAY
111616: PPUSH
111617: CALL 110576 0 3
111621: NOT
111622: IFFALSE 111628
// exit ;
111624: POP
111625: POP
111626: GO 111632
111628: GO 111591
111630: POP
111631: POP
// end ;
111632: LD_VAR 0 4
111636: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111637: LD_INT 0
111639: PPUSH
111640: PPUSH
111641: PPUSH
111642: PPUSH
111643: PPUSH
111644: PPUSH
111645: PPUSH
// if not GetClass ( unit ) = class_sniper then
111646: LD_VAR 0 1
111650: PPUSH
111651: CALL_OW 257
111655: PUSH
111656: LD_INT 5
111658: EQUAL
111659: NOT
111660: IFFALSE 111664
// exit ;
111662: GO 112052
// dist := 8 ;
111664: LD_ADDR_VAR 0 5
111668: PUSH
111669: LD_INT 8
111671: ST_TO_ADDR
// viewRange := 12 ;
111672: LD_ADDR_VAR 0 7
111676: PUSH
111677: LD_INT 12
111679: ST_TO_ADDR
// side := GetSide ( unit ) ;
111680: LD_ADDR_VAR 0 6
111684: PUSH
111685: LD_VAR 0 1
111689: PPUSH
111690: CALL_OW 255
111694: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111695: LD_INT 61
111697: PPUSH
111698: LD_VAR 0 6
111702: PPUSH
111703: CALL_OW 321
111707: PUSH
111708: LD_INT 2
111710: EQUAL
111711: IFFALSE 111721
// viewRange := 16 ;
111713: LD_ADDR_VAR 0 7
111717: PUSH
111718: LD_INT 16
111720: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111721: LD_VAR 0 1
111725: PPUSH
111726: LD_VAR 0 2
111730: PPUSH
111731: LD_VAR 0 3
111735: PPUSH
111736: CALL_OW 297
111740: PUSH
111741: LD_VAR 0 5
111745: GREATER
111746: IFFALSE 111825
// begin ComMoveXY ( unit , x , y ) ;
111748: LD_VAR 0 1
111752: PPUSH
111753: LD_VAR 0 2
111757: PPUSH
111758: LD_VAR 0 3
111762: PPUSH
111763: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111767: LD_INT 35
111769: PPUSH
111770: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111774: LD_VAR 0 1
111778: PPUSH
111779: LD_VAR 0 2
111783: PPUSH
111784: LD_VAR 0 3
111788: PPUSH
111789: CALL 56161 0 3
111793: NOT
111794: IFFALSE 111798
// exit ;
111796: GO 112052
// until GetDistUnitXY ( unit , x , y ) < dist ;
111798: LD_VAR 0 1
111802: PPUSH
111803: LD_VAR 0 2
111807: PPUSH
111808: LD_VAR 0 3
111812: PPUSH
111813: CALL_OW 297
111817: PUSH
111818: LD_VAR 0 5
111822: LESS
111823: IFFALSE 111767
// end ; ComTurnXY ( unit , x , y ) ;
111825: LD_VAR 0 1
111829: PPUSH
111830: LD_VAR 0 2
111834: PPUSH
111835: LD_VAR 0 3
111839: PPUSH
111840: CALL_OW 118
// wait ( 5 ) ;
111844: LD_INT 5
111846: PPUSH
111847: CALL_OW 67
// _d := GetDir ( unit ) ;
111851: LD_ADDR_VAR 0 10
111855: PUSH
111856: LD_VAR 0 1
111860: PPUSH
111861: CALL_OW 254
111865: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111866: LD_ADDR_VAR 0 8
111870: PUSH
111871: LD_VAR 0 1
111875: PPUSH
111876: CALL_OW 250
111880: PPUSH
111881: LD_VAR 0 10
111885: PPUSH
111886: LD_VAR 0 5
111890: PPUSH
111891: CALL_OW 272
111895: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111896: LD_ADDR_VAR 0 9
111900: PUSH
111901: LD_VAR 0 1
111905: PPUSH
111906: CALL_OW 251
111910: PPUSH
111911: LD_VAR 0 10
111915: PPUSH
111916: LD_VAR 0 5
111920: PPUSH
111921: CALL_OW 273
111925: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111926: LD_VAR 0 8
111930: PPUSH
111931: LD_VAR 0 9
111935: PPUSH
111936: CALL_OW 488
111940: NOT
111941: IFFALSE 111945
// exit ;
111943: GO 112052
// ComAnimCustom ( unit , 1 ) ;
111945: LD_VAR 0 1
111949: PPUSH
111950: LD_INT 1
111952: PPUSH
111953: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111957: LD_VAR 0 8
111961: PPUSH
111962: LD_VAR 0 9
111966: PPUSH
111967: LD_VAR 0 6
111971: PPUSH
111972: LD_VAR 0 7
111976: PPUSH
111977: CALL_OW 330
// repeat wait ( 1 ) ;
111981: LD_INT 1
111983: PPUSH
111984: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111988: LD_VAR 0 1
111992: PPUSH
111993: CALL_OW 316
111997: PUSH
111998: LD_VAR 0 1
112002: PPUSH
112003: CALL_OW 314
112007: OR
112008: PUSH
112009: LD_VAR 0 1
112013: PPUSH
112014: CALL_OW 302
112018: NOT
112019: OR
112020: PUSH
112021: LD_VAR 0 1
112025: PPUSH
112026: CALL_OW 301
112030: OR
112031: IFFALSE 111981
// RemoveSeeing ( _x , _y , side ) ;
112033: LD_VAR 0 8
112037: PPUSH
112038: LD_VAR 0 9
112042: PPUSH
112043: LD_VAR 0 6
112047: PPUSH
112048: CALL_OW 331
// end ; end_of_file
112052: LD_VAR 0 4
112056: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112057: LD_INT 0
112059: PPUSH
112060: PPUSH
112061: PPUSH
112062: PPUSH
112063: PPUSH
112064: PPUSH
112065: PPUSH
112066: PPUSH
112067: PPUSH
112068: PPUSH
112069: PPUSH
112070: PPUSH
112071: PPUSH
112072: PPUSH
112073: PPUSH
112074: PPUSH
112075: PPUSH
112076: PPUSH
112077: PPUSH
112078: PPUSH
112079: PPUSH
112080: PPUSH
112081: PPUSH
112082: PPUSH
112083: PPUSH
112084: PPUSH
112085: PPUSH
112086: PPUSH
112087: PPUSH
112088: PPUSH
112089: PPUSH
112090: PPUSH
112091: PPUSH
112092: PPUSH
// if not list then
112093: LD_VAR 0 1
112097: NOT
112098: IFFALSE 112102
// exit ;
112100: GO 116761
// base := list [ 1 ] ;
112102: LD_ADDR_VAR 0 3
112106: PUSH
112107: LD_VAR 0 1
112111: PUSH
112112: LD_INT 1
112114: ARRAY
112115: ST_TO_ADDR
// group := list [ 2 ] ;
112116: LD_ADDR_VAR 0 4
112120: PUSH
112121: LD_VAR 0 1
112125: PUSH
112126: LD_INT 2
112128: ARRAY
112129: ST_TO_ADDR
// path := list [ 3 ] ;
112130: LD_ADDR_VAR 0 5
112134: PUSH
112135: LD_VAR 0 1
112139: PUSH
112140: LD_INT 3
112142: ARRAY
112143: ST_TO_ADDR
// flags := list [ 4 ] ;
112144: LD_ADDR_VAR 0 6
112148: PUSH
112149: LD_VAR 0 1
112153: PUSH
112154: LD_INT 4
112156: ARRAY
112157: ST_TO_ADDR
// mined := [ ] ;
112158: LD_ADDR_VAR 0 27
112162: PUSH
112163: EMPTY
112164: ST_TO_ADDR
// bombed := [ ] ;
112165: LD_ADDR_VAR 0 28
112169: PUSH
112170: EMPTY
112171: ST_TO_ADDR
// healers := [ ] ;
112172: LD_ADDR_VAR 0 31
112176: PUSH
112177: EMPTY
112178: ST_TO_ADDR
// to_heal := [ ] ;
112179: LD_ADDR_VAR 0 30
112183: PUSH
112184: EMPTY
112185: ST_TO_ADDR
// repairs := [ ] ;
112186: LD_ADDR_VAR 0 33
112190: PUSH
112191: EMPTY
112192: ST_TO_ADDR
// to_repair := [ ] ;
112193: LD_ADDR_VAR 0 32
112197: PUSH
112198: EMPTY
112199: ST_TO_ADDR
// if not group or not path then
112200: LD_VAR 0 4
112204: NOT
112205: PUSH
112206: LD_VAR 0 5
112210: NOT
112211: OR
112212: IFFALSE 112216
// exit ;
112214: GO 116761
// side := GetSide ( group [ 1 ] ) ;
112216: LD_ADDR_VAR 0 35
112220: PUSH
112221: LD_VAR 0 4
112225: PUSH
112226: LD_INT 1
112228: ARRAY
112229: PPUSH
112230: CALL_OW 255
112234: ST_TO_ADDR
// if flags then
112235: LD_VAR 0 6
112239: IFFALSE 112383
// begin f_ignore_area := flags [ 1 ] ;
112241: LD_ADDR_VAR 0 17
112245: PUSH
112246: LD_VAR 0 6
112250: PUSH
112251: LD_INT 1
112253: ARRAY
112254: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112255: LD_ADDR_VAR 0 18
112259: PUSH
112260: LD_VAR 0 6
112264: PUSH
112265: LD_INT 2
112267: ARRAY
112268: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112269: LD_ADDR_VAR 0 19
112273: PUSH
112274: LD_VAR 0 6
112278: PUSH
112279: LD_INT 3
112281: ARRAY
112282: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112283: LD_ADDR_VAR 0 20
112287: PUSH
112288: LD_VAR 0 6
112292: PUSH
112293: LD_INT 4
112295: ARRAY
112296: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112297: LD_ADDR_VAR 0 21
112301: PUSH
112302: LD_VAR 0 6
112306: PUSH
112307: LD_INT 5
112309: ARRAY
112310: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112311: LD_ADDR_VAR 0 22
112315: PUSH
112316: LD_VAR 0 6
112320: PUSH
112321: LD_INT 6
112323: ARRAY
112324: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112325: LD_ADDR_VAR 0 23
112329: PUSH
112330: LD_VAR 0 6
112334: PUSH
112335: LD_INT 7
112337: ARRAY
112338: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112339: LD_ADDR_VAR 0 24
112343: PUSH
112344: LD_VAR 0 6
112348: PUSH
112349: LD_INT 8
112351: ARRAY
112352: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112353: LD_ADDR_VAR 0 25
112357: PUSH
112358: LD_VAR 0 6
112362: PUSH
112363: LD_INT 9
112365: ARRAY
112366: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112367: LD_ADDR_VAR 0 26
112371: PUSH
112372: LD_VAR 0 6
112376: PUSH
112377: LD_INT 10
112379: ARRAY
112380: ST_TO_ADDR
// end else
112381: GO 112463
// begin f_ignore_area := false ;
112383: LD_ADDR_VAR 0 17
112387: PUSH
112388: LD_INT 0
112390: ST_TO_ADDR
// f_capture := false ;
112391: LD_ADDR_VAR 0 18
112395: PUSH
112396: LD_INT 0
112398: ST_TO_ADDR
// f_ignore_civ := false ;
112399: LD_ADDR_VAR 0 19
112403: PUSH
112404: LD_INT 0
112406: ST_TO_ADDR
// f_murder := false ;
112407: LD_ADDR_VAR 0 20
112411: PUSH
112412: LD_INT 0
112414: ST_TO_ADDR
// f_mines := false ;
112415: LD_ADDR_VAR 0 21
112419: PUSH
112420: LD_INT 0
112422: ST_TO_ADDR
// f_repair := false ;
112423: LD_ADDR_VAR 0 22
112427: PUSH
112428: LD_INT 0
112430: ST_TO_ADDR
// f_heal := false ;
112431: LD_ADDR_VAR 0 23
112435: PUSH
112436: LD_INT 0
112438: ST_TO_ADDR
// f_spacetime := false ;
112439: LD_ADDR_VAR 0 24
112443: PUSH
112444: LD_INT 0
112446: ST_TO_ADDR
// f_attack_depot := false ;
112447: LD_ADDR_VAR 0 25
112451: PUSH
112452: LD_INT 0
112454: ST_TO_ADDR
// f_crawl := false ;
112455: LD_ADDR_VAR 0 26
112459: PUSH
112460: LD_INT 0
112462: ST_TO_ADDR
// end ; if f_heal then
112463: LD_VAR 0 23
112467: IFFALSE 112494
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112469: LD_ADDR_VAR 0 31
112473: PUSH
112474: LD_VAR 0 4
112478: PPUSH
112479: LD_INT 25
112481: PUSH
112482: LD_INT 4
112484: PUSH
112485: EMPTY
112486: LIST
112487: LIST
112488: PPUSH
112489: CALL_OW 72
112493: ST_TO_ADDR
// if f_repair then
112494: LD_VAR 0 22
112498: IFFALSE 112525
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112500: LD_ADDR_VAR 0 33
112504: PUSH
112505: LD_VAR 0 4
112509: PPUSH
112510: LD_INT 25
112512: PUSH
112513: LD_INT 3
112515: PUSH
112516: EMPTY
112517: LIST
112518: LIST
112519: PPUSH
112520: CALL_OW 72
112524: ST_TO_ADDR
// units_path := [ ] ;
112525: LD_ADDR_VAR 0 16
112529: PUSH
112530: EMPTY
112531: ST_TO_ADDR
// for i = 1 to group do
112532: LD_ADDR_VAR 0 7
112536: PUSH
112537: DOUBLE
112538: LD_INT 1
112540: DEC
112541: ST_TO_ADDR
112542: LD_VAR 0 4
112546: PUSH
112547: FOR_TO
112548: IFFALSE 112577
// units_path := Replace ( units_path , i , path ) ;
112550: LD_ADDR_VAR 0 16
112554: PUSH
112555: LD_VAR 0 16
112559: PPUSH
112560: LD_VAR 0 7
112564: PPUSH
112565: LD_VAR 0 5
112569: PPUSH
112570: CALL_OW 1
112574: ST_TO_ADDR
112575: GO 112547
112577: POP
112578: POP
// repeat for i = group downto 1 do
112579: LD_ADDR_VAR 0 7
112583: PUSH
112584: DOUBLE
112585: LD_VAR 0 4
112589: INC
112590: ST_TO_ADDR
112591: LD_INT 1
112593: PUSH
112594: FOR_DOWNTO
112595: IFFALSE 116717
// begin wait ( 5 ) ;
112597: LD_INT 5
112599: PPUSH
112600: CALL_OW 67
// tmp := [ ] ;
112604: LD_ADDR_VAR 0 14
112608: PUSH
112609: EMPTY
112610: ST_TO_ADDR
// attacking := false ;
112611: LD_ADDR_VAR 0 29
112615: PUSH
112616: LD_INT 0
112618: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112619: LD_VAR 0 4
112623: PUSH
112624: LD_VAR 0 7
112628: ARRAY
112629: PPUSH
112630: CALL_OW 301
112634: PUSH
112635: LD_VAR 0 4
112639: PUSH
112640: LD_VAR 0 7
112644: ARRAY
112645: NOT
112646: OR
112647: IFFALSE 112756
// begin if GetType ( group [ i ] ) = unit_human then
112649: LD_VAR 0 4
112653: PUSH
112654: LD_VAR 0 7
112658: ARRAY
112659: PPUSH
112660: CALL_OW 247
112664: PUSH
112665: LD_INT 1
112667: EQUAL
112668: IFFALSE 112714
// begin to_heal := to_heal diff group [ i ] ;
112670: LD_ADDR_VAR 0 30
112674: PUSH
112675: LD_VAR 0 30
112679: PUSH
112680: LD_VAR 0 4
112684: PUSH
112685: LD_VAR 0 7
112689: ARRAY
112690: DIFF
112691: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112692: LD_ADDR_VAR 0 31
112696: PUSH
112697: LD_VAR 0 31
112701: PUSH
112702: LD_VAR 0 4
112706: PUSH
112707: LD_VAR 0 7
112711: ARRAY
112712: DIFF
112713: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112714: LD_ADDR_VAR 0 4
112718: PUSH
112719: LD_VAR 0 4
112723: PPUSH
112724: LD_VAR 0 7
112728: PPUSH
112729: CALL_OW 3
112733: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112734: LD_ADDR_VAR 0 16
112738: PUSH
112739: LD_VAR 0 16
112743: PPUSH
112744: LD_VAR 0 7
112748: PPUSH
112749: CALL_OW 3
112753: ST_TO_ADDR
// continue ;
112754: GO 112594
// end ; if f_repair then
112756: LD_VAR 0 22
112760: IFFALSE 113249
// begin if GetType ( group [ i ] ) = unit_vehicle then
112762: LD_VAR 0 4
112766: PUSH
112767: LD_VAR 0 7
112771: ARRAY
112772: PPUSH
112773: CALL_OW 247
112777: PUSH
112778: LD_INT 2
112780: EQUAL
112781: IFFALSE 112971
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112783: LD_VAR 0 4
112787: PUSH
112788: LD_VAR 0 7
112792: ARRAY
112793: PPUSH
112794: CALL_OW 256
112798: PUSH
112799: LD_INT 700
112801: LESS
112802: PUSH
112803: LD_VAR 0 4
112807: PUSH
112808: LD_VAR 0 7
112812: ARRAY
112813: PUSH
112814: LD_VAR 0 32
112818: IN
112819: NOT
112820: AND
112821: IFFALSE 112845
// to_repair := to_repair union group [ i ] ;
112823: LD_ADDR_VAR 0 32
112827: PUSH
112828: LD_VAR 0 32
112832: PUSH
112833: LD_VAR 0 4
112837: PUSH
112838: LD_VAR 0 7
112842: ARRAY
112843: UNION
112844: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112845: LD_VAR 0 4
112849: PUSH
112850: LD_VAR 0 7
112854: ARRAY
112855: PPUSH
112856: CALL_OW 256
112860: PUSH
112861: LD_INT 1000
112863: EQUAL
112864: PUSH
112865: LD_VAR 0 4
112869: PUSH
112870: LD_VAR 0 7
112874: ARRAY
112875: PUSH
112876: LD_VAR 0 32
112880: IN
112881: AND
112882: IFFALSE 112906
// to_repair := to_repair diff group [ i ] ;
112884: LD_ADDR_VAR 0 32
112888: PUSH
112889: LD_VAR 0 32
112893: PUSH
112894: LD_VAR 0 4
112898: PUSH
112899: LD_VAR 0 7
112903: ARRAY
112904: DIFF
112905: ST_TO_ADDR
// if group [ i ] in to_repair then
112906: LD_VAR 0 4
112910: PUSH
112911: LD_VAR 0 7
112915: ARRAY
112916: PUSH
112917: LD_VAR 0 32
112921: IN
112922: IFFALSE 112969
// begin if not IsInArea ( group [ i ] , f_repair ) then
112924: LD_VAR 0 4
112928: PUSH
112929: LD_VAR 0 7
112933: ARRAY
112934: PPUSH
112935: LD_VAR 0 22
112939: PPUSH
112940: CALL_OW 308
112944: NOT
112945: IFFALSE 112967
// ComMoveToArea ( group [ i ] , f_repair ) ;
112947: LD_VAR 0 4
112951: PUSH
112952: LD_VAR 0 7
112956: ARRAY
112957: PPUSH
112958: LD_VAR 0 22
112962: PPUSH
112963: CALL_OW 113
// continue ;
112967: GO 112594
// end ; end else
112969: GO 113249
// if group [ i ] in repairs then
112971: LD_VAR 0 4
112975: PUSH
112976: LD_VAR 0 7
112980: ARRAY
112981: PUSH
112982: LD_VAR 0 33
112986: IN
112987: IFFALSE 113249
// begin if IsInUnit ( group [ i ] ) then
112989: LD_VAR 0 4
112993: PUSH
112994: LD_VAR 0 7
112998: ARRAY
112999: PPUSH
113000: CALL_OW 310
113004: IFFALSE 113072
// begin z := IsInUnit ( group [ i ] ) ;
113006: LD_ADDR_VAR 0 13
113010: PUSH
113011: LD_VAR 0 4
113015: PUSH
113016: LD_VAR 0 7
113020: ARRAY
113021: PPUSH
113022: CALL_OW 310
113026: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113027: LD_VAR 0 13
113031: PUSH
113032: LD_VAR 0 32
113036: IN
113037: PUSH
113038: LD_VAR 0 13
113042: PPUSH
113043: LD_VAR 0 22
113047: PPUSH
113048: CALL_OW 308
113052: AND
113053: IFFALSE 113070
// ComExitVehicle ( group [ i ] ) ;
113055: LD_VAR 0 4
113059: PUSH
113060: LD_VAR 0 7
113064: ARRAY
113065: PPUSH
113066: CALL_OW 121
// end else
113070: GO 113249
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113072: LD_ADDR_VAR 0 13
113076: PUSH
113077: LD_VAR 0 4
113081: PPUSH
113082: LD_INT 95
113084: PUSH
113085: LD_VAR 0 22
113089: PUSH
113090: EMPTY
113091: LIST
113092: LIST
113093: PUSH
113094: LD_INT 58
113096: PUSH
113097: EMPTY
113098: LIST
113099: PUSH
113100: EMPTY
113101: LIST
113102: LIST
113103: PPUSH
113104: CALL_OW 72
113108: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113109: LD_VAR 0 4
113113: PUSH
113114: LD_VAR 0 7
113118: ARRAY
113119: PPUSH
113120: CALL_OW 314
113124: NOT
113125: IFFALSE 113247
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113127: LD_ADDR_VAR 0 10
113131: PUSH
113132: LD_VAR 0 13
113136: PPUSH
113137: LD_VAR 0 4
113141: PUSH
113142: LD_VAR 0 7
113146: ARRAY
113147: PPUSH
113148: CALL_OW 74
113152: ST_TO_ADDR
// if not x then
113153: LD_VAR 0 10
113157: NOT
113158: IFFALSE 113162
// continue ;
113160: GO 112594
// if GetLives ( x ) < 1000 then
113162: LD_VAR 0 10
113166: PPUSH
113167: CALL_OW 256
113171: PUSH
113172: LD_INT 1000
113174: LESS
113175: IFFALSE 113199
// ComRepairVehicle ( group [ i ] , x ) else
113177: LD_VAR 0 4
113181: PUSH
113182: LD_VAR 0 7
113186: ARRAY
113187: PPUSH
113188: LD_VAR 0 10
113192: PPUSH
113193: CALL_OW 129
113197: GO 113247
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113199: LD_VAR 0 23
113203: PUSH
113204: LD_VAR 0 4
113208: PUSH
113209: LD_VAR 0 7
113213: ARRAY
113214: PPUSH
113215: CALL_OW 256
113219: PUSH
113220: LD_INT 1000
113222: LESS
113223: AND
113224: NOT
113225: IFFALSE 113247
// ComEnterUnit ( group [ i ] , x ) ;
113227: LD_VAR 0 4
113231: PUSH
113232: LD_VAR 0 7
113236: ARRAY
113237: PPUSH
113238: LD_VAR 0 10
113242: PPUSH
113243: CALL_OW 120
// end ; continue ;
113247: GO 112594
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113249: LD_VAR 0 23
113253: PUSH
113254: LD_VAR 0 4
113258: PUSH
113259: LD_VAR 0 7
113263: ARRAY
113264: PPUSH
113265: CALL_OW 247
113269: PUSH
113270: LD_INT 1
113272: EQUAL
113273: AND
113274: IFFALSE 113752
// begin if group [ i ] in healers then
113276: LD_VAR 0 4
113280: PUSH
113281: LD_VAR 0 7
113285: ARRAY
113286: PUSH
113287: LD_VAR 0 31
113291: IN
113292: IFFALSE 113565
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113294: LD_VAR 0 4
113298: PUSH
113299: LD_VAR 0 7
113303: ARRAY
113304: PPUSH
113305: LD_VAR 0 23
113309: PPUSH
113310: CALL_OW 308
113314: NOT
113315: PUSH
113316: LD_VAR 0 4
113320: PUSH
113321: LD_VAR 0 7
113325: ARRAY
113326: PPUSH
113327: CALL_OW 314
113331: NOT
113332: AND
113333: IFFALSE 113357
// ComMoveToArea ( group [ i ] , f_heal ) else
113335: LD_VAR 0 4
113339: PUSH
113340: LD_VAR 0 7
113344: ARRAY
113345: PPUSH
113346: LD_VAR 0 23
113350: PPUSH
113351: CALL_OW 113
113355: GO 113563
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113357: LD_VAR 0 4
113361: PUSH
113362: LD_VAR 0 7
113366: ARRAY
113367: PPUSH
113368: CALL 54744 0 1
113372: PPUSH
113373: CALL_OW 256
113377: PUSH
113378: LD_INT 1000
113380: EQUAL
113381: IFFALSE 113400
// ComStop ( group [ i ] ) else
113383: LD_VAR 0 4
113387: PUSH
113388: LD_VAR 0 7
113392: ARRAY
113393: PPUSH
113394: CALL_OW 141
113398: GO 113563
// if not HasTask ( group [ i ] ) and to_heal then
113400: LD_VAR 0 4
113404: PUSH
113405: LD_VAR 0 7
113409: ARRAY
113410: PPUSH
113411: CALL_OW 314
113415: NOT
113416: PUSH
113417: LD_VAR 0 30
113421: AND
113422: IFFALSE 113563
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113424: LD_ADDR_VAR 0 13
113428: PUSH
113429: LD_VAR 0 30
113433: PPUSH
113434: LD_INT 3
113436: PUSH
113437: LD_INT 54
113439: PUSH
113440: EMPTY
113441: LIST
113442: PUSH
113443: EMPTY
113444: LIST
113445: LIST
113446: PPUSH
113447: CALL_OW 72
113451: PPUSH
113452: LD_VAR 0 4
113456: PUSH
113457: LD_VAR 0 7
113461: ARRAY
113462: PPUSH
113463: CALL_OW 74
113467: ST_TO_ADDR
// if z then
113468: LD_VAR 0 13
113472: IFFALSE 113563
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113474: LD_INT 91
113476: PUSH
113477: LD_VAR 0 13
113481: PUSH
113482: LD_INT 10
113484: PUSH
113485: EMPTY
113486: LIST
113487: LIST
113488: LIST
113489: PUSH
113490: LD_INT 81
113492: PUSH
113493: LD_VAR 0 13
113497: PPUSH
113498: CALL_OW 255
113502: PUSH
113503: EMPTY
113504: LIST
113505: LIST
113506: PUSH
113507: EMPTY
113508: LIST
113509: LIST
113510: PPUSH
113511: CALL_OW 69
113515: PUSH
113516: LD_INT 0
113518: EQUAL
113519: IFFALSE 113543
// ComHeal ( group [ i ] , z ) else
113521: LD_VAR 0 4
113525: PUSH
113526: LD_VAR 0 7
113530: ARRAY
113531: PPUSH
113532: LD_VAR 0 13
113536: PPUSH
113537: CALL_OW 128
113541: GO 113563
// ComMoveToArea ( group [ i ] , f_heal ) ;
113543: LD_VAR 0 4
113547: PUSH
113548: LD_VAR 0 7
113552: ARRAY
113553: PPUSH
113554: LD_VAR 0 23
113558: PPUSH
113559: CALL_OW 113
// end ; continue ;
113563: GO 112594
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113565: LD_VAR 0 4
113569: PUSH
113570: LD_VAR 0 7
113574: ARRAY
113575: PPUSH
113576: CALL_OW 256
113580: PUSH
113581: LD_INT 700
113583: LESS
113584: PUSH
113585: LD_VAR 0 4
113589: PUSH
113590: LD_VAR 0 7
113594: ARRAY
113595: PUSH
113596: LD_VAR 0 30
113600: IN
113601: NOT
113602: AND
113603: IFFALSE 113627
// to_heal := to_heal union group [ i ] ;
113605: LD_ADDR_VAR 0 30
113609: PUSH
113610: LD_VAR 0 30
113614: PUSH
113615: LD_VAR 0 4
113619: PUSH
113620: LD_VAR 0 7
113624: ARRAY
113625: UNION
113626: ST_TO_ADDR
// if group [ i ] in to_heal then
113627: LD_VAR 0 4
113631: PUSH
113632: LD_VAR 0 7
113636: ARRAY
113637: PUSH
113638: LD_VAR 0 30
113642: IN
113643: IFFALSE 113752
// begin if GetLives ( group [ i ] ) = 1000 then
113645: LD_VAR 0 4
113649: PUSH
113650: LD_VAR 0 7
113654: ARRAY
113655: PPUSH
113656: CALL_OW 256
113660: PUSH
113661: LD_INT 1000
113663: EQUAL
113664: IFFALSE 113690
// to_heal := to_heal diff group [ i ] else
113666: LD_ADDR_VAR 0 30
113670: PUSH
113671: LD_VAR 0 30
113675: PUSH
113676: LD_VAR 0 4
113680: PUSH
113681: LD_VAR 0 7
113685: ARRAY
113686: DIFF
113687: ST_TO_ADDR
113688: GO 113752
// begin if not IsInArea ( group [ i ] , to_heal ) then
113690: LD_VAR 0 4
113694: PUSH
113695: LD_VAR 0 7
113699: ARRAY
113700: PPUSH
113701: LD_VAR 0 30
113705: PPUSH
113706: CALL_OW 308
113710: NOT
113711: IFFALSE 113735
// ComMoveToArea ( group [ i ] , f_heal ) else
113713: LD_VAR 0 4
113717: PUSH
113718: LD_VAR 0 7
113722: ARRAY
113723: PPUSH
113724: LD_VAR 0 23
113728: PPUSH
113729: CALL_OW 113
113733: GO 113750
// ComHold ( group [ i ] ) ;
113735: LD_VAR 0 4
113739: PUSH
113740: LD_VAR 0 7
113744: ARRAY
113745: PPUSH
113746: CALL_OW 140
// continue ;
113750: GO 112594
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113752: LD_VAR 0 4
113756: PUSH
113757: LD_VAR 0 7
113761: ARRAY
113762: PPUSH
113763: LD_INT 10
113765: PPUSH
113766: CALL 52515 0 2
113770: NOT
113771: PUSH
113772: LD_VAR 0 16
113776: PUSH
113777: LD_VAR 0 7
113781: ARRAY
113782: PUSH
113783: EMPTY
113784: EQUAL
113785: NOT
113786: AND
113787: IFFALSE 114053
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113789: LD_VAR 0 4
113793: PUSH
113794: LD_VAR 0 7
113798: ARRAY
113799: PPUSH
113800: CALL_OW 262
113804: PUSH
113805: LD_INT 1
113807: PUSH
113808: LD_INT 2
113810: PUSH
113811: EMPTY
113812: LIST
113813: LIST
113814: IN
113815: IFFALSE 113856
// if GetFuel ( group [ i ] ) < 10 then
113817: LD_VAR 0 4
113821: PUSH
113822: LD_VAR 0 7
113826: ARRAY
113827: PPUSH
113828: CALL_OW 261
113832: PUSH
113833: LD_INT 10
113835: LESS
113836: IFFALSE 113856
// SetFuel ( group [ i ] , 12 ) ;
113838: LD_VAR 0 4
113842: PUSH
113843: LD_VAR 0 7
113847: ARRAY
113848: PPUSH
113849: LD_INT 12
113851: PPUSH
113852: CALL_OW 240
// if units_path [ i ] then
113856: LD_VAR 0 16
113860: PUSH
113861: LD_VAR 0 7
113865: ARRAY
113866: IFFALSE 114051
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113868: LD_VAR 0 4
113872: PUSH
113873: LD_VAR 0 7
113877: ARRAY
113878: PPUSH
113879: LD_VAR 0 16
113883: PUSH
113884: LD_VAR 0 7
113888: ARRAY
113889: PUSH
113890: LD_INT 1
113892: ARRAY
113893: PUSH
113894: LD_INT 1
113896: ARRAY
113897: PPUSH
113898: LD_VAR 0 16
113902: PUSH
113903: LD_VAR 0 7
113907: ARRAY
113908: PUSH
113909: LD_INT 1
113911: ARRAY
113912: PUSH
113913: LD_INT 2
113915: ARRAY
113916: PPUSH
113917: CALL_OW 297
113921: PUSH
113922: LD_INT 6
113924: GREATER
113925: IFFALSE 114000
// begin if not HasTask ( group [ i ] ) then
113927: LD_VAR 0 4
113931: PUSH
113932: LD_VAR 0 7
113936: ARRAY
113937: PPUSH
113938: CALL_OW 314
113942: NOT
113943: IFFALSE 113998
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113945: LD_VAR 0 4
113949: PUSH
113950: LD_VAR 0 7
113954: ARRAY
113955: PPUSH
113956: LD_VAR 0 16
113960: PUSH
113961: LD_VAR 0 7
113965: ARRAY
113966: PUSH
113967: LD_INT 1
113969: ARRAY
113970: PUSH
113971: LD_INT 1
113973: ARRAY
113974: PPUSH
113975: LD_VAR 0 16
113979: PUSH
113980: LD_VAR 0 7
113984: ARRAY
113985: PUSH
113986: LD_INT 1
113988: ARRAY
113989: PUSH
113990: LD_INT 2
113992: ARRAY
113993: PPUSH
113994: CALL_OW 114
// end else
113998: GO 114051
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114000: LD_ADDR_VAR 0 15
114004: PUSH
114005: LD_VAR 0 16
114009: PUSH
114010: LD_VAR 0 7
114014: ARRAY
114015: PPUSH
114016: LD_INT 1
114018: PPUSH
114019: CALL_OW 3
114023: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114024: LD_ADDR_VAR 0 16
114028: PUSH
114029: LD_VAR 0 16
114033: PPUSH
114034: LD_VAR 0 7
114038: PPUSH
114039: LD_VAR 0 15
114043: PPUSH
114044: CALL_OW 1
114048: ST_TO_ADDR
// continue ;
114049: GO 112594
// end ; end ; end else
114051: GO 116715
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114053: LD_ADDR_VAR 0 14
114057: PUSH
114058: LD_INT 81
114060: PUSH
114061: LD_VAR 0 4
114065: PUSH
114066: LD_VAR 0 7
114070: ARRAY
114071: PPUSH
114072: CALL_OW 255
114076: PUSH
114077: EMPTY
114078: LIST
114079: LIST
114080: PPUSH
114081: CALL_OW 69
114085: ST_TO_ADDR
// if not tmp then
114086: LD_VAR 0 14
114090: NOT
114091: IFFALSE 114095
// continue ;
114093: GO 112594
// if f_ignore_area then
114095: LD_VAR 0 17
114099: IFFALSE 114187
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114101: LD_ADDR_VAR 0 15
114105: PUSH
114106: LD_VAR 0 14
114110: PPUSH
114111: LD_INT 3
114113: PUSH
114114: LD_INT 92
114116: PUSH
114117: LD_VAR 0 17
114121: PUSH
114122: LD_INT 1
114124: ARRAY
114125: PUSH
114126: LD_VAR 0 17
114130: PUSH
114131: LD_INT 2
114133: ARRAY
114134: PUSH
114135: LD_VAR 0 17
114139: PUSH
114140: LD_INT 3
114142: ARRAY
114143: PUSH
114144: EMPTY
114145: LIST
114146: LIST
114147: LIST
114148: LIST
114149: PUSH
114150: EMPTY
114151: LIST
114152: LIST
114153: PPUSH
114154: CALL_OW 72
114158: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114159: LD_VAR 0 14
114163: PUSH
114164: LD_VAR 0 15
114168: DIFF
114169: IFFALSE 114187
// tmp := tmp diff tmp2 ;
114171: LD_ADDR_VAR 0 14
114175: PUSH
114176: LD_VAR 0 14
114180: PUSH
114181: LD_VAR 0 15
114185: DIFF
114186: ST_TO_ADDR
// end ; if not f_murder then
114187: LD_VAR 0 20
114191: NOT
114192: IFFALSE 114250
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114194: LD_ADDR_VAR 0 15
114198: PUSH
114199: LD_VAR 0 14
114203: PPUSH
114204: LD_INT 3
114206: PUSH
114207: LD_INT 50
114209: PUSH
114210: EMPTY
114211: LIST
114212: PUSH
114213: EMPTY
114214: LIST
114215: LIST
114216: PPUSH
114217: CALL_OW 72
114221: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114222: LD_VAR 0 14
114226: PUSH
114227: LD_VAR 0 15
114231: DIFF
114232: IFFALSE 114250
// tmp := tmp diff tmp2 ;
114234: LD_ADDR_VAR 0 14
114238: PUSH
114239: LD_VAR 0 14
114243: PUSH
114244: LD_VAR 0 15
114248: DIFF
114249: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114250: LD_ADDR_VAR 0 14
114254: PUSH
114255: LD_VAR 0 4
114259: PUSH
114260: LD_VAR 0 7
114264: ARRAY
114265: PPUSH
114266: LD_VAR 0 14
114270: PPUSH
114271: LD_INT 1
114273: PPUSH
114274: LD_INT 1
114276: PPUSH
114277: CALL 25456 0 4
114281: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114282: LD_VAR 0 4
114286: PUSH
114287: LD_VAR 0 7
114291: ARRAY
114292: PPUSH
114293: CALL_OW 257
114297: PUSH
114298: LD_INT 1
114300: EQUAL
114301: IFFALSE 114749
// begin if WantPlant ( group [ i ] ) then
114303: LD_VAR 0 4
114307: PUSH
114308: LD_VAR 0 7
114312: ARRAY
114313: PPUSH
114314: CALL 24957 0 1
114318: IFFALSE 114322
// continue ;
114320: GO 112594
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114322: LD_VAR 0 18
114326: PUSH
114327: LD_VAR 0 4
114331: PUSH
114332: LD_VAR 0 7
114336: ARRAY
114337: PPUSH
114338: CALL_OW 310
114342: NOT
114343: AND
114344: PUSH
114345: LD_VAR 0 14
114349: PUSH
114350: LD_INT 1
114352: ARRAY
114353: PUSH
114354: LD_VAR 0 14
114358: PPUSH
114359: LD_INT 21
114361: PUSH
114362: LD_INT 2
114364: PUSH
114365: EMPTY
114366: LIST
114367: LIST
114368: PUSH
114369: LD_INT 58
114371: PUSH
114372: EMPTY
114373: LIST
114374: PUSH
114375: EMPTY
114376: LIST
114377: LIST
114378: PPUSH
114379: CALL_OW 72
114383: IN
114384: AND
114385: IFFALSE 114421
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114387: LD_VAR 0 4
114391: PUSH
114392: LD_VAR 0 7
114396: ARRAY
114397: PPUSH
114398: LD_VAR 0 14
114402: PUSH
114403: LD_INT 1
114405: ARRAY
114406: PPUSH
114407: CALL_OW 120
// attacking := true ;
114411: LD_ADDR_VAR 0 29
114415: PUSH
114416: LD_INT 1
114418: ST_TO_ADDR
// continue ;
114419: GO 112594
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114421: LD_VAR 0 26
114425: PUSH
114426: LD_VAR 0 4
114430: PUSH
114431: LD_VAR 0 7
114435: ARRAY
114436: PPUSH
114437: CALL_OW 257
114441: PUSH
114442: LD_INT 1
114444: EQUAL
114445: AND
114446: PUSH
114447: LD_VAR 0 4
114451: PUSH
114452: LD_VAR 0 7
114456: ARRAY
114457: PPUSH
114458: CALL_OW 256
114462: PUSH
114463: LD_INT 800
114465: LESS
114466: AND
114467: PUSH
114468: LD_VAR 0 4
114472: PUSH
114473: LD_VAR 0 7
114477: ARRAY
114478: PPUSH
114479: CALL_OW 318
114483: NOT
114484: AND
114485: IFFALSE 114502
// ComCrawl ( group [ i ] ) ;
114487: LD_VAR 0 4
114491: PUSH
114492: LD_VAR 0 7
114496: ARRAY
114497: PPUSH
114498: CALL_OW 137
// if f_mines then
114502: LD_VAR 0 21
114506: IFFALSE 114749
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114508: LD_VAR 0 14
114512: PUSH
114513: LD_INT 1
114515: ARRAY
114516: PPUSH
114517: CALL_OW 247
114521: PUSH
114522: LD_INT 3
114524: EQUAL
114525: PUSH
114526: LD_VAR 0 14
114530: PUSH
114531: LD_INT 1
114533: ARRAY
114534: PUSH
114535: LD_VAR 0 27
114539: IN
114540: NOT
114541: AND
114542: IFFALSE 114749
// begin x := GetX ( tmp [ 1 ] ) ;
114544: LD_ADDR_VAR 0 10
114548: PUSH
114549: LD_VAR 0 14
114553: PUSH
114554: LD_INT 1
114556: ARRAY
114557: PPUSH
114558: CALL_OW 250
114562: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114563: LD_ADDR_VAR 0 11
114567: PUSH
114568: LD_VAR 0 14
114572: PUSH
114573: LD_INT 1
114575: ARRAY
114576: PPUSH
114577: CALL_OW 251
114581: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114582: LD_ADDR_VAR 0 12
114586: PUSH
114587: LD_VAR 0 4
114591: PUSH
114592: LD_VAR 0 7
114596: ARRAY
114597: PPUSH
114598: CALL 52600 0 1
114602: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114603: LD_VAR 0 4
114607: PUSH
114608: LD_VAR 0 7
114612: ARRAY
114613: PPUSH
114614: LD_VAR 0 10
114618: PPUSH
114619: LD_VAR 0 11
114623: PPUSH
114624: LD_VAR 0 14
114628: PUSH
114629: LD_INT 1
114631: ARRAY
114632: PPUSH
114633: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114637: LD_VAR 0 4
114641: PUSH
114642: LD_VAR 0 7
114646: ARRAY
114647: PPUSH
114648: LD_VAR 0 10
114652: PPUSH
114653: LD_VAR 0 12
114657: PPUSH
114658: LD_INT 7
114660: PPUSH
114661: CALL_OW 272
114665: PPUSH
114666: LD_VAR 0 11
114670: PPUSH
114671: LD_VAR 0 12
114675: PPUSH
114676: LD_INT 7
114678: PPUSH
114679: CALL_OW 273
114683: PPUSH
114684: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114688: LD_VAR 0 4
114692: PUSH
114693: LD_VAR 0 7
114697: ARRAY
114698: PPUSH
114699: LD_INT 71
114701: PPUSH
114702: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114706: LD_ADDR_VAR 0 27
114710: PUSH
114711: LD_VAR 0 27
114715: PPUSH
114716: LD_VAR 0 27
114720: PUSH
114721: LD_INT 1
114723: PLUS
114724: PPUSH
114725: LD_VAR 0 14
114729: PUSH
114730: LD_INT 1
114732: ARRAY
114733: PPUSH
114734: CALL_OW 1
114738: ST_TO_ADDR
// attacking := true ;
114739: LD_ADDR_VAR 0 29
114743: PUSH
114744: LD_INT 1
114746: ST_TO_ADDR
// continue ;
114747: GO 112594
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114749: LD_VAR 0 4
114753: PUSH
114754: LD_VAR 0 7
114758: ARRAY
114759: PPUSH
114760: CALL_OW 257
114764: PUSH
114765: LD_INT 17
114767: EQUAL
114768: PUSH
114769: LD_VAR 0 4
114773: PUSH
114774: LD_VAR 0 7
114778: ARRAY
114779: PPUSH
114780: CALL_OW 110
114784: PUSH
114785: LD_INT 71
114787: EQUAL
114788: NOT
114789: AND
114790: IFFALSE 114936
// begin attacking := false ;
114792: LD_ADDR_VAR 0 29
114796: PUSH
114797: LD_INT 0
114799: ST_TO_ADDR
// k := 5 ;
114800: LD_ADDR_VAR 0 9
114804: PUSH
114805: LD_INT 5
114807: ST_TO_ADDR
// if tmp < k then
114808: LD_VAR 0 14
114812: PUSH
114813: LD_VAR 0 9
114817: LESS
114818: IFFALSE 114830
// k := tmp ;
114820: LD_ADDR_VAR 0 9
114824: PUSH
114825: LD_VAR 0 14
114829: ST_TO_ADDR
// for j = 1 to k do
114830: LD_ADDR_VAR 0 8
114834: PUSH
114835: DOUBLE
114836: LD_INT 1
114838: DEC
114839: ST_TO_ADDR
114840: LD_VAR 0 9
114844: PUSH
114845: FOR_TO
114846: IFFALSE 114934
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114848: LD_VAR 0 14
114852: PUSH
114853: LD_VAR 0 8
114857: ARRAY
114858: PUSH
114859: LD_VAR 0 14
114863: PPUSH
114864: LD_INT 58
114866: PUSH
114867: EMPTY
114868: LIST
114869: PPUSH
114870: CALL_OW 72
114874: IN
114875: NOT
114876: IFFALSE 114932
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114878: LD_VAR 0 4
114882: PUSH
114883: LD_VAR 0 7
114887: ARRAY
114888: PPUSH
114889: LD_VAR 0 14
114893: PUSH
114894: LD_VAR 0 8
114898: ARRAY
114899: PPUSH
114900: CALL_OW 115
// attacking := true ;
114904: LD_ADDR_VAR 0 29
114908: PUSH
114909: LD_INT 1
114911: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114912: LD_VAR 0 4
114916: PUSH
114917: LD_VAR 0 7
114921: ARRAY
114922: PPUSH
114923: LD_INT 71
114925: PPUSH
114926: CALL_OW 109
// continue ;
114930: GO 114845
// end ; end ;
114932: GO 114845
114934: POP
114935: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114936: LD_VAR 0 4
114940: PUSH
114941: LD_VAR 0 7
114945: ARRAY
114946: PPUSH
114947: CALL_OW 257
114951: PUSH
114952: LD_INT 8
114954: EQUAL
114955: PUSH
114956: LD_VAR 0 4
114960: PUSH
114961: LD_VAR 0 7
114965: ARRAY
114966: PPUSH
114967: CALL_OW 264
114971: PUSH
114972: LD_INT 28
114974: PUSH
114975: LD_INT 45
114977: PUSH
114978: LD_INT 7
114980: PUSH
114981: LD_INT 47
114983: PUSH
114984: EMPTY
114985: LIST
114986: LIST
114987: LIST
114988: LIST
114989: IN
114990: OR
114991: IFFALSE 115247
// begin attacking := false ;
114993: LD_ADDR_VAR 0 29
114997: PUSH
114998: LD_INT 0
115000: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115001: LD_VAR 0 14
115005: PUSH
115006: LD_INT 1
115008: ARRAY
115009: PPUSH
115010: CALL_OW 266
115014: PUSH
115015: LD_INT 32
115017: PUSH
115018: LD_INT 31
115020: PUSH
115021: LD_INT 33
115023: PUSH
115024: LD_INT 4
115026: PUSH
115027: LD_INT 5
115029: PUSH
115030: EMPTY
115031: LIST
115032: LIST
115033: LIST
115034: LIST
115035: LIST
115036: IN
115037: IFFALSE 115223
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115039: LD_ADDR_VAR 0 9
115043: PUSH
115044: LD_VAR 0 14
115048: PUSH
115049: LD_INT 1
115051: ARRAY
115052: PPUSH
115053: CALL_OW 266
115057: PPUSH
115058: LD_VAR 0 14
115062: PUSH
115063: LD_INT 1
115065: ARRAY
115066: PPUSH
115067: CALL_OW 250
115071: PPUSH
115072: LD_VAR 0 14
115076: PUSH
115077: LD_INT 1
115079: ARRAY
115080: PPUSH
115081: CALL_OW 251
115085: PPUSH
115086: LD_VAR 0 14
115090: PUSH
115091: LD_INT 1
115093: ARRAY
115094: PPUSH
115095: CALL_OW 254
115099: PPUSH
115100: LD_VAR 0 14
115104: PUSH
115105: LD_INT 1
115107: ARRAY
115108: PPUSH
115109: CALL_OW 248
115113: PPUSH
115114: LD_INT 0
115116: PPUSH
115117: CALL 33970 0 6
115121: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115122: LD_ADDR_VAR 0 8
115126: PUSH
115127: LD_VAR 0 4
115131: PUSH
115132: LD_VAR 0 7
115136: ARRAY
115137: PPUSH
115138: LD_VAR 0 9
115142: PPUSH
115143: CALL 52713 0 2
115147: ST_TO_ADDR
// if j then
115148: LD_VAR 0 8
115152: IFFALSE 115221
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115154: LD_VAR 0 8
115158: PUSH
115159: LD_INT 1
115161: ARRAY
115162: PPUSH
115163: LD_VAR 0 8
115167: PUSH
115168: LD_INT 2
115170: ARRAY
115171: PPUSH
115172: CALL_OW 488
115176: IFFALSE 115221
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115178: LD_VAR 0 4
115182: PUSH
115183: LD_VAR 0 7
115187: ARRAY
115188: PPUSH
115189: LD_VAR 0 8
115193: PUSH
115194: LD_INT 1
115196: ARRAY
115197: PPUSH
115198: LD_VAR 0 8
115202: PUSH
115203: LD_INT 2
115205: ARRAY
115206: PPUSH
115207: CALL_OW 116
// attacking := true ;
115211: LD_ADDR_VAR 0 29
115215: PUSH
115216: LD_INT 1
115218: ST_TO_ADDR
// continue ;
115219: GO 112594
// end ; end else
115221: GO 115247
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115223: LD_VAR 0 4
115227: PUSH
115228: LD_VAR 0 7
115232: ARRAY
115233: PPUSH
115234: LD_VAR 0 14
115238: PUSH
115239: LD_INT 1
115241: ARRAY
115242: PPUSH
115243: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115247: LD_VAR 0 4
115251: PUSH
115252: LD_VAR 0 7
115256: ARRAY
115257: PPUSH
115258: CALL_OW 265
115262: PUSH
115263: LD_INT 11
115265: EQUAL
115266: IFFALSE 115544
// begin k := 10 ;
115268: LD_ADDR_VAR 0 9
115272: PUSH
115273: LD_INT 10
115275: ST_TO_ADDR
// x := 0 ;
115276: LD_ADDR_VAR 0 10
115280: PUSH
115281: LD_INT 0
115283: ST_TO_ADDR
// if tmp < k then
115284: LD_VAR 0 14
115288: PUSH
115289: LD_VAR 0 9
115293: LESS
115294: IFFALSE 115306
// k := tmp ;
115296: LD_ADDR_VAR 0 9
115300: PUSH
115301: LD_VAR 0 14
115305: ST_TO_ADDR
// for j = k downto 1 do
115306: LD_ADDR_VAR 0 8
115310: PUSH
115311: DOUBLE
115312: LD_VAR 0 9
115316: INC
115317: ST_TO_ADDR
115318: LD_INT 1
115320: PUSH
115321: FOR_DOWNTO
115322: IFFALSE 115397
// begin if GetType ( tmp [ j ] ) = unit_human then
115324: LD_VAR 0 14
115328: PUSH
115329: LD_VAR 0 8
115333: ARRAY
115334: PPUSH
115335: CALL_OW 247
115339: PUSH
115340: LD_INT 1
115342: EQUAL
115343: IFFALSE 115395
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115345: LD_VAR 0 4
115349: PUSH
115350: LD_VAR 0 7
115354: ARRAY
115355: PPUSH
115356: LD_VAR 0 14
115360: PUSH
115361: LD_VAR 0 8
115365: ARRAY
115366: PPUSH
115367: CALL 52967 0 2
// x := tmp [ j ] ;
115371: LD_ADDR_VAR 0 10
115375: PUSH
115376: LD_VAR 0 14
115380: PUSH
115381: LD_VAR 0 8
115385: ARRAY
115386: ST_TO_ADDR
// attacking := true ;
115387: LD_ADDR_VAR 0 29
115391: PUSH
115392: LD_INT 1
115394: ST_TO_ADDR
// end ; end ;
115395: GO 115321
115397: POP
115398: POP
// if not x then
115399: LD_VAR 0 10
115403: NOT
115404: IFFALSE 115544
// begin attacking := true ;
115406: LD_ADDR_VAR 0 29
115410: PUSH
115411: LD_INT 1
115413: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115414: LD_VAR 0 4
115418: PUSH
115419: LD_VAR 0 7
115423: ARRAY
115424: PPUSH
115425: CALL_OW 250
115429: PPUSH
115430: LD_VAR 0 4
115434: PUSH
115435: LD_VAR 0 7
115439: ARRAY
115440: PPUSH
115441: CALL_OW 251
115445: PPUSH
115446: CALL_OW 546
115450: PUSH
115451: LD_INT 2
115453: ARRAY
115454: PUSH
115455: LD_VAR 0 14
115459: PUSH
115460: LD_INT 1
115462: ARRAY
115463: PPUSH
115464: CALL_OW 250
115468: PPUSH
115469: LD_VAR 0 14
115473: PUSH
115474: LD_INT 1
115476: ARRAY
115477: PPUSH
115478: CALL_OW 251
115482: PPUSH
115483: CALL_OW 546
115487: PUSH
115488: LD_INT 2
115490: ARRAY
115491: EQUAL
115492: IFFALSE 115520
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115494: LD_VAR 0 4
115498: PUSH
115499: LD_VAR 0 7
115503: ARRAY
115504: PPUSH
115505: LD_VAR 0 14
115509: PUSH
115510: LD_INT 1
115512: ARRAY
115513: PPUSH
115514: CALL 52967 0 2
115518: GO 115544
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115520: LD_VAR 0 4
115524: PUSH
115525: LD_VAR 0 7
115529: ARRAY
115530: PPUSH
115531: LD_VAR 0 14
115535: PUSH
115536: LD_INT 1
115538: ARRAY
115539: PPUSH
115540: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115544: LD_VAR 0 4
115548: PUSH
115549: LD_VAR 0 7
115553: ARRAY
115554: PPUSH
115555: CALL_OW 264
115559: PUSH
115560: LD_INT 29
115562: EQUAL
115563: IFFALSE 115929
// begin if WantsToAttack ( group [ i ] ) in bombed then
115565: LD_VAR 0 4
115569: PUSH
115570: LD_VAR 0 7
115574: ARRAY
115575: PPUSH
115576: CALL_OW 319
115580: PUSH
115581: LD_VAR 0 28
115585: IN
115586: IFFALSE 115590
// continue ;
115588: GO 112594
// k := 8 ;
115590: LD_ADDR_VAR 0 9
115594: PUSH
115595: LD_INT 8
115597: ST_TO_ADDR
// x := 0 ;
115598: LD_ADDR_VAR 0 10
115602: PUSH
115603: LD_INT 0
115605: ST_TO_ADDR
// if tmp < k then
115606: LD_VAR 0 14
115610: PUSH
115611: LD_VAR 0 9
115615: LESS
115616: IFFALSE 115628
// k := tmp ;
115618: LD_ADDR_VAR 0 9
115622: PUSH
115623: LD_VAR 0 14
115627: ST_TO_ADDR
// for j = 1 to k do
115628: LD_ADDR_VAR 0 8
115632: PUSH
115633: DOUBLE
115634: LD_INT 1
115636: DEC
115637: ST_TO_ADDR
115638: LD_VAR 0 9
115642: PUSH
115643: FOR_TO
115644: IFFALSE 115776
// begin if GetType ( tmp [ j ] ) = unit_building then
115646: LD_VAR 0 14
115650: PUSH
115651: LD_VAR 0 8
115655: ARRAY
115656: PPUSH
115657: CALL_OW 247
115661: PUSH
115662: LD_INT 3
115664: EQUAL
115665: IFFALSE 115774
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115667: LD_VAR 0 14
115671: PUSH
115672: LD_VAR 0 8
115676: ARRAY
115677: PUSH
115678: LD_VAR 0 28
115682: IN
115683: NOT
115684: PUSH
115685: LD_VAR 0 14
115689: PUSH
115690: LD_VAR 0 8
115694: ARRAY
115695: PPUSH
115696: CALL_OW 313
115700: AND
115701: IFFALSE 115774
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115703: LD_VAR 0 4
115707: PUSH
115708: LD_VAR 0 7
115712: ARRAY
115713: PPUSH
115714: LD_VAR 0 14
115718: PUSH
115719: LD_VAR 0 8
115723: ARRAY
115724: PPUSH
115725: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115729: LD_ADDR_VAR 0 28
115733: PUSH
115734: LD_VAR 0 28
115738: PPUSH
115739: LD_VAR 0 28
115743: PUSH
115744: LD_INT 1
115746: PLUS
115747: PPUSH
115748: LD_VAR 0 14
115752: PUSH
115753: LD_VAR 0 8
115757: ARRAY
115758: PPUSH
115759: CALL_OW 1
115763: ST_TO_ADDR
// attacking := true ;
115764: LD_ADDR_VAR 0 29
115768: PUSH
115769: LD_INT 1
115771: ST_TO_ADDR
// break ;
115772: GO 115776
// end ; end ;
115774: GO 115643
115776: POP
115777: POP
// if not attacking and f_attack_depot then
115778: LD_VAR 0 29
115782: NOT
115783: PUSH
115784: LD_VAR 0 25
115788: AND
115789: IFFALSE 115884
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115791: LD_ADDR_VAR 0 13
115795: PUSH
115796: LD_VAR 0 14
115800: PPUSH
115801: LD_INT 2
115803: PUSH
115804: LD_INT 30
115806: PUSH
115807: LD_INT 0
115809: PUSH
115810: EMPTY
115811: LIST
115812: LIST
115813: PUSH
115814: LD_INT 30
115816: PUSH
115817: LD_INT 1
115819: PUSH
115820: EMPTY
115821: LIST
115822: LIST
115823: PUSH
115824: EMPTY
115825: LIST
115826: LIST
115827: LIST
115828: PPUSH
115829: CALL_OW 72
115833: ST_TO_ADDR
// if z then
115834: LD_VAR 0 13
115838: IFFALSE 115884
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115840: LD_VAR 0 4
115844: PUSH
115845: LD_VAR 0 7
115849: ARRAY
115850: PPUSH
115851: LD_VAR 0 13
115855: PPUSH
115856: LD_VAR 0 4
115860: PUSH
115861: LD_VAR 0 7
115865: ARRAY
115866: PPUSH
115867: CALL_OW 74
115871: PPUSH
115872: CALL_OW 115
// attacking := true ;
115876: LD_ADDR_VAR 0 29
115880: PUSH
115881: LD_INT 1
115883: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115884: LD_VAR 0 4
115888: PUSH
115889: LD_VAR 0 7
115893: ARRAY
115894: PPUSH
115895: CALL_OW 256
115899: PUSH
115900: LD_INT 500
115902: LESS
115903: IFFALSE 115929
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115905: LD_VAR 0 4
115909: PUSH
115910: LD_VAR 0 7
115914: ARRAY
115915: PPUSH
115916: LD_VAR 0 14
115920: PUSH
115921: LD_INT 1
115923: ARRAY
115924: PPUSH
115925: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115929: LD_VAR 0 4
115933: PUSH
115934: LD_VAR 0 7
115938: ARRAY
115939: PPUSH
115940: CALL_OW 264
115944: PUSH
115945: LD_INT 49
115947: EQUAL
115948: IFFALSE 116069
// begin if not HasTask ( group [ i ] ) then
115950: LD_VAR 0 4
115954: PUSH
115955: LD_VAR 0 7
115959: ARRAY
115960: PPUSH
115961: CALL_OW 314
115965: NOT
115966: IFFALSE 116069
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115968: LD_ADDR_VAR 0 9
115972: PUSH
115973: LD_INT 81
115975: PUSH
115976: LD_VAR 0 4
115980: PUSH
115981: LD_VAR 0 7
115985: ARRAY
115986: PPUSH
115987: CALL_OW 255
115991: PUSH
115992: EMPTY
115993: LIST
115994: LIST
115995: PPUSH
115996: CALL_OW 69
116000: PPUSH
116001: LD_VAR 0 4
116005: PUSH
116006: LD_VAR 0 7
116010: ARRAY
116011: PPUSH
116012: CALL_OW 74
116016: ST_TO_ADDR
// if k then
116017: LD_VAR 0 9
116021: IFFALSE 116069
// if GetDistUnits ( group [ i ] , k ) > 10 then
116023: LD_VAR 0 4
116027: PUSH
116028: LD_VAR 0 7
116032: ARRAY
116033: PPUSH
116034: LD_VAR 0 9
116038: PPUSH
116039: CALL_OW 296
116043: PUSH
116044: LD_INT 10
116046: GREATER
116047: IFFALSE 116069
// ComMoveUnit ( group [ i ] , k ) ;
116049: LD_VAR 0 4
116053: PUSH
116054: LD_VAR 0 7
116058: ARRAY
116059: PPUSH
116060: LD_VAR 0 9
116064: PPUSH
116065: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116069: LD_VAR 0 4
116073: PUSH
116074: LD_VAR 0 7
116078: ARRAY
116079: PPUSH
116080: CALL_OW 256
116084: PUSH
116085: LD_INT 250
116087: LESS
116088: PUSH
116089: LD_VAR 0 4
116093: PUSH
116094: LD_VAR 0 7
116098: ARRAY
116099: PUSH
116100: LD_INT 21
116102: PUSH
116103: LD_INT 2
116105: PUSH
116106: EMPTY
116107: LIST
116108: LIST
116109: PUSH
116110: LD_INT 23
116112: PUSH
116113: LD_INT 2
116115: PUSH
116116: EMPTY
116117: LIST
116118: LIST
116119: PUSH
116120: EMPTY
116121: LIST
116122: LIST
116123: PPUSH
116124: CALL_OW 69
116128: IN
116129: AND
116130: IFFALSE 116255
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116132: LD_ADDR_VAR 0 9
116136: PUSH
116137: LD_OWVAR 3
116141: PUSH
116142: LD_VAR 0 4
116146: PUSH
116147: LD_VAR 0 7
116151: ARRAY
116152: DIFF
116153: PPUSH
116154: LD_VAR 0 4
116158: PUSH
116159: LD_VAR 0 7
116163: ARRAY
116164: PPUSH
116165: CALL_OW 74
116169: ST_TO_ADDR
// if not k then
116170: LD_VAR 0 9
116174: NOT
116175: IFFALSE 116179
// continue ;
116177: GO 112594
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116179: LD_VAR 0 9
116183: PUSH
116184: LD_INT 81
116186: PUSH
116187: LD_VAR 0 4
116191: PUSH
116192: LD_VAR 0 7
116196: ARRAY
116197: PPUSH
116198: CALL_OW 255
116202: PUSH
116203: EMPTY
116204: LIST
116205: LIST
116206: PPUSH
116207: CALL_OW 69
116211: IN
116212: PUSH
116213: LD_VAR 0 9
116217: PPUSH
116218: LD_VAR 0 4
116222: PUSH
116223: LD_VAR 0 7
116227: ARRAY
116228: PPUSH
116229: CALL_OW 296
116233: PUSH
116234: LD_INT 5
116236: LESS
116237: AND
116238: IFFALSE 116255
// ComAutodestruct ( group [ i ] ) ;
116240: LD_VAR 0 4
116244: PUSH
116245: LD_VAR 0 7
116249: ARRAY
116250: PPUSH
116251: CALL 52865 0 1
// end ; if f_attack_depot then
116255: LD_VAR 0 25
116259: IFFALSE 116371
// begin k := 6 ;
116261: LD_ADDR_VAR 0 9
116265: PUSH
116266: LD_INT 6
116268: ST_TO_ADDR
// if tmp < k then
116269: LD_VAR 0 14
116273: PUSH
116274: LD_VAR 0 9
116278: LESS
116279: IFFALSE 116291
// k := tmp ;
116281: LD_ADDR_VAR 0 9
116285: PUSH
116286: LD_VAR 0 14
116290: ST_TO_ADDR
// for j = 1 to k do
116291: LD_ADDR_VAR 0 8
116295: PUSH
116296: DOUBLE
116297: LD_INT 1
116299: DEC
116300: ST_TO_ADDR
116301: LD_VAR 0 9
116305: PUSH
116306: FOR_TO
116307: IFFALSE 116369
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116309: LD_VAR 0 8
116313: PPUSH
116314: CALL_OW 266
116318: PUSH
116319: LD_INT 0
116321: PUSH
116322: LD_INT 1
116324: PUSH
116325: EMPTY
116326: LIST
116327: LIST
116328: IN
116329: IFFALSE 116367
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116331: LD_VAR 0 4
116335: PUSH
116336: LD_VAR 0 7
116340: ARRAY
116341: PPUSH
116342: LD_VAR 0 14
116346: PUSH
116347: LD_VAR 0 8
116351: ARRAY
116352: PPUSH
116353: CALL_OW 115
// attacking := true ;
116357: LD_ADDR_VAR 0 29
116361: PUSH
116362: LD_INT 1
116364: ST_TO_ADDR
// break ;
116365: GO 116369
// end ;
116367: GO 116306
116369: POP
116370: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116371: LD_VAR 0 4
116375: PUSH
116376: LD_VAR 0 7
116380: ARRAY
116381: PPUSH
116382: CALL_OW 302
116386: PUSH
116387: LD_VAR 0 29
116391: NOT
116392: AND
116393: IFFALSE 116715
// begin if GetTag ( group [ i ] ) = 71 then
116395: LD_VAR 0 4
116399: PUSH
116400: LD_VAR 0 7
116404: ARRAY
116405: PPUSH
116406: CALL_OW 110
116410: PUSH
116411: LD_INT 71
116413: EQUAL
116414: IFFALSE 116455
// begin if HasTask ( group [ i ] ) then
116416: LD_VAR 0 4
116420: PUSH
116421: LD_VAR 0 7
116425: ARRAY
116426: PPUSH
116427: CALL_OW 314
116431: IFFALSE 116437
// continue else
116433: GO 112594
116435: GO 116455
// SetTag ( group [ i ] , 0 ) ;
116437: LD_VAR 0 4
116441: PUSH
116442: LD_VAR 0 7
116446: ARRAY
116447: PPUSH
116448: LD_INT 0
116450: PPUSH
116451: CALL_OW 109
// end ; k := 8 ;
116455: LD_ADDR_VAR 0 9
116459: PUSH
116460: LD_INT 8
116462: ST_TO_ADDR
// x := 0 ;
116463: LD_ADDR_VAR 0 10
116467: PUSH
116468: LD_INT 0
116470: ST_TO_ADDR
// if tmp < k then
116471: LD_VAR 0 14
116475: PUSH
116476: LD_VAR 0 9
116480: LESS
116481: IFFALSE 116493
// k := tmp ;
116483: LD_ADDR_VAR 0 9
116487: PUSH
116488: LD_VAR 0 14
116492: ST_TO_ADDR
// for j = 1 to k do
116493: LD_ADDR_VAR 0 8
116497: PUSH
116498: DOUBLE
116499: LD_INT 1
116501: DEC
116502: ST_TO_ADDR
116503: LD_VAR 0 9
116507: PUSH
116508: FOR_TO
116509: IFFALSE 116607
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116511: LD_VAR 0 14
116515: PUSH
116516: LD_VAR 0 8
116520: ARRAY
116521: PPUSH
116522: CALL_OW 247
116526: PUSH
116527: LD_INT 1
116529: EQUAL
116530: PUSH
116531: LD_VAR 0 14
116535: PUSH
116536: LD_VAR 0 8
116540: ARRAY
116541: PPUSH
116542: CALL_OW 256
116546: PUSH
116547: LD_INT 250
116549: LESS
116550: PUSH
116551: LD_VAR 0 20
116555: AND
116556: PUSH
116557: LD_VAR 0 20
116561: NOT
116562: PUSH
116563: LD_VAR 0 14
116567: PUSH
116568: LD_VAR 0 8
116572: ARRAY
116573: PPUSH
116574: CALL_OW 256
116578: PUSH
116579: LD_INT 250
116581: GREATEREQUAL
116582: AND
116583: OR
116584: AND
116585: IFFALSE 116605
// begin x := tmp [ j ] ;
116587: LD_ADDR_VAR 0 10
116591: PUSH
116592: LD_VAR 0 14
116596: PUSH
116597: LD_VAR 0 8
116601: ARRAY
116602: ST_TO_ADDR
// break ;
116603: GO 116607
// end ;
116605: GO 116508
116607: POP
116608: POP
// if x then
116609: LD_VAR 0 10
116613: IFFALSE 116637
// ComAttackUnit ( group [ i ] , x ) else
116615: LD_VAR 0 4
116619: PUSH
116620: LD_VAR 0 7
116624: ARRAY
116625: PPUSH
116626: LD_VAR 0 10
116630: PPUSH
116631: CALL_OW 115
116635: GO 116661
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116637: LD_VAR 0 4
116641: PUSH
116642: LD_VAR 0 7
116646: ARRAY
116647: PPUSH
116648: LD_VAR 0 14
116652: PUSH
116653: LD_INT 1
116655: ARRAY
116656: PPUSH
116657: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116661: LD_VAR 0 4
116665: PUSH
116666: LD_VAR 0 7
116670: ARRAY
116671: PPUSH
116672: CALL_OW 314
116676: NOT
116677: IFFALSE 116715
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116679: LD_VAR 0 4
116683: PUSH
116684: LD_VAR 0 7
116688: ARRAY
116689: PPUSH
116690: LD_VAR 0 14
116694: PPUSH
116695: LD_VAR 0 4
116699: PUSH
116700: LD_VAR 0 7
116704: ARRAY
116705: PPUSH
116706: CALL_OW 74
116710: PPUSH
116711: CALL_OW 115
// end ; end ; end ;
116715: GO 112594
116717: POP
116718: POP
// wait ( 0 0$2 ) ;
116719: LD_INT 70
116721: PPUSH
116722: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116726: LD_VAR 0 4
116730: NOT
116731: PUSH
116732: LD_VAR 0 4
116736: PUSH
116737: EMPTY
116738: EQUAL
116739: OR
116740: PUSH
116741: LD_INT 81
116743: PUSH
116744: LD_VAR 0 35
116748: PUSH
116749: EMPTY
116750: LIST
116751: LIST
116752: PPUSH
116753: CALL_OW 69
116757: NOT
116758: OR
116759: IFFALSE 112579
// end ;
116761: LD_VAR 0 2
116765: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116766: LD_INT 0
116768: PPUSH
116769: PPUSH
116770: PPUSH
116771: PPUSH
116772: PPUSH
116773: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116774: LD_VAR 0 1
116778: NOT
116779: PUSH
116780: LD_EXP 31
116784: PUSH
116785: LD_VAR 0 1
116789: ARRAY
116790: NOT
116791: OR
116792: PUSH
116793: LD_VAR 0 2
116797: NOT
116798: OR
116799: IFFALSE 116803
// exit ;
116801: GO 117357
// side := mc_sides [ base ] ;
116803: LD_ADDR_VAR 0 6
116807: PUSH
116808: LD_EXP 57
116812: PUSH
116813: LD_VAR 0 1
116817: ARRAY
116818: ST_TO_ADDR
// if not side then
116819: LD_VAR 0 6
116823: NOT
116824: IFFALSE 116828
// exit ;
116826: GO 117357
// for i in solds do
116828: LD_ADDR_VAR 0 7
116832: PUSH
116833: LD_VAR 0 2
116837: PUSH
116838: FOR_IN
116839: IFFALSE 116900
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116841: LD_VAR 0 7
116845: PPUSH
116846: CALL_OW 310
116850: PPUSH
116851: CALL_OW 266
116855: PUSH
116856: LD_INT 32
116858: PUSH
116859: LD_INT 31
116861: PUSH
116862: EMPTY
116863: LIST
116864: LIST
116865: IN
116866: IFFALSE 116886
// solds := solds diff i else
116868: LD_ADDR_VAR 0 2
116872: PUSH
116873: LD_VAR 0 2
116877: PUSH
116878: LD_VAR 0 7
116882: DIFF
116883: ST_TO_ADDR
116884: GO 116898
// SetTag ( i , 18 ) ;
116886: LD_VAR 0 7
116890: PPUSH
116891: LD_INT 18
116893: PPUSH
116894: CALL_OW 109
116898: GO 116838
116900: POP
116901: POP
// if not solds then
116902: LD_VAR 0 2
116906: NOT
116907: IFFALSE 116911
// exit ;
116909: GO 117357
// repeat wait ( 0 0$2 ) ;
116911: LD_INT 70
116913: PPUSH
116914: CALL_OW 67
// enemy := mc_scan [ base ] ;
116918: LD_ADDR_VAR 0 4
116922: PUSH
116923: LD_EXP 54
116927: PUSH
116928: LD_VAR 0 1
116932: ARRAY
116933: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116934: LD_EXP 31
116938: PUSH
116939: LD_VAR 0 1
116943: ARRAY
116944: NOT
116945: PUSH
116946: LD_EXP 31
116950: PUSH
116951: LD_VAR 0 1
116955: ARRAY
116956: PUSH
116957: EMPTY
116958: EQUAL
116959: OR
116960: IFFALSE 116997
// begin for i in solds do
116962: LD_ADDR_VAR 0 7
116966: PUSH
116967: LD_VAR 0 2
116971: PUSH
116972: FOR_IN
116973: IFFALSE 116986
// ComStop ( i ) ;
116975: LD_VAR 0 7
116979: PPUSH
116980: CALL_OW 141
116984: GO 116972
116986: POP
116987: POP
// solds := [ ] ;
116988: LD_ADDR_VAR 0 2
116992: PUSH
116993: EMPTY
116994: ST_TO_ADDR
// exit ;
116995: GO 117357
// end ; for i in solds do
116997: LD_ADDR_VAR 0 7
117001: PUSH
117002: LD_VAR 0 2
117006: PUSH
117007: FOR_IN
117008: IFFALSE 117329
// begin if IsInUnit ( i ) then
117010: LD_VAR 0 7
117014: PPUSH
117015: CALL_OW 310
117019: IFFALSE 117030
// ComExitBuilding ( i ) ;
117021: LD_VAR 0 7
117025: PPUSH
117026: CALL_OW 122
// if GetLives ( i ) > 500 then
117030: LD_VAR 0 7
117034: PPUSH
117035: CALL_OW 256
117039: PUSH
117040: LD_INT 500
117042: GREATER
117043: IFFALSE 117096
// begin e := NearestUnitToUnit ( enemy , i ) ;
117045: LD_ADDR_VAR 0 5
117049: PUSH
117050: LD_VAR 0 4
117054: PPUSH
117055: LD_VAR 0 7
117059: PPUSH
117060: CALL_OW 74
117064: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117065: LD_VAR 0 7
117069: PPUSH
117070: LD_VAR 0 5
117074: PPUSH
117075: CALL_OW 250
117079: PPUSH
117080: LD_VAR 0 5
117084: PPUSH
117085: CALL_OW 251
117089: PPUSH
117090: CALL_OW 114
// end else
117094: GO 117327
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
117096: LD_VAR 0 7
117100: PPUSH
117101: LD_EXP 31
117105: PUSH
117106: LD_VAR 0 1
117110: ARRAY
117111: PPUSH
117112: LD_INT 2
117114: PUSH
117115: LD_INT 30
117117: PUSH
117118: LD_INT 0
117120: PUSH
117121: EMPTY
117122: LIST
117123: LIST
117124: PUSH
117125: LD_INT 30
117127: PUSH
117128: LD_INT 1
117130: PUSH
117131: EMPTY
117132: LIST
117133: LIST
117134: PUSH
117135: LD_INT 30
117137: PUSH
117138: LD_INT 6
117140: PUSH
117141: EMPTY
117142: LIST
117143: LIST
117144: PUSH
117145: EMPTY
117146: LIST
117147: LIST
117148: LIST
117149: LIST
117150: PPUSH
117151: CALL_OW 72
117155: PPUSH
117156: LD_VAR 0 7
117160: PPUSH
117161: CALL_OW 74
117165: PPUSH
117166: CALL_OW 296
117170: PUSH
117171: LD_INT 10
117173: GREATER
117174: IFFALSE 117327
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117176: LD_ADDR_VAR 0 8
117180: PUSH
117181: LD_EXP 31
117185: PUSH
117186: LD_VAR 0 1
117190: ARRAY
117191: PPUSH
117192: LD_INT 2
117194: PUSH
117195: LD_INT 30
117197: PUSH
117198: LD_INT 0
117200: PUSH
117201: EMPTY
117202: LIST
117203: LIST
117204: PUSH
117205: LD_INT 30
117207: PUSH
117208: LD_INT 1
117210: PUSH
117211: EMPTY
117212: LIST
117213: LIST
117214: PUSH
117215: LD_INT 30
117217: PUSH
117218: LD_INT 6
117220: PUSH
117221: EMPTY
117222: LIST
117223: LIST
117224: PUSH
117225: EMPTY
117226: LIST
117227: LIST
117228: LIST
117229: LIST
117230: PPUSH
117231: CALL_OW 72
117235: PPUSH
117236: LD_VAR 0 7
117240: PPUSH
117241: CALL_OW 74
117245: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117246: LD_VAR 0 7
117250: PPUSH
117251: LD_VAR 0 8
117255: PPUSH
117256: CALL_OW 250
117260: PPUSH
117261: LD_INT 3
117263: PPUSH
117264: LD_INT 5
117266: PPUSH
117267: CALL_OW 272
117271: PPUSH
117272: LD_VAR 0 8
117276: PPUSH
117277: CALL_OW 251
117281: PPUSH
117282: LD_INT 3
117284: PPUSH
117285: LD_INT 5
117287: PPUSH
117288: CALL_OW 273
117292: PPUSH
117293: CALL_OW 111
// SetTag ( i , 0 ) ;
117297: LD_VAR 0 7
117301: PPUSH
117302: LD_INT 0
117304: PPUSH
117305: CALL_OW 109
// solds := solds diff i ;
117309: LD_ADDR_VAR 0 2
117313: PUSH
117314: LD_VAR 0 2
117318: PUSH
117319: LD_VAR 0 7
117323: DIFF
117324: ST_TO_ADDR
// continue ;
117325: GO 117007
// end ; end ;
117327: GO 117007
117329: POP
117330: POP
// until not solds or not enemy ;
117331: LD_VAR 0 2
117335: NOT
117336: PUSH
117337: LD_VAR 0 4
117341: NOT
117342: OR
117343: IFFALSE 116911
// MC_Reset ( base , 18 ) ;
117345: LD_VAR 0 1
117349: PPUSH
117350: LD_INT 18
117352: PPUSH
117353: CALL 65466 0 2
// end ;
117357: LD_VAR 0 3
117361: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117362: LD_INT 0
117364: PPUSH
117365: PPUSH
117366: PPUSH
117367: PPUSH
117368: PPUSH
117369: PPUSH
117370: PPUSH
117371: PPUSH
117372: PPUSH
117373: PPUSH
117374: PPUSH
117375: PPUSH
117376: PPUSH
117377: PPUSH
117378: PPUSH
117379: PPUSH
117380: PPUSH
117381: PPUSH
117382: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117383: LD_ADDR_VAR 0 12
117387: PUSH
117388: LD_EXP 31
117392: PUSH
117393: LD_VAR 0 1
117397: ARRAY
117398: PPUSH
117399: LD_INT 25
117401: PUSH
117402: LD_INT 3
117404: PUSH
117405: EMPTY
117406: LIST
117407: LIST
117408: PPUSH
117409: CALL_OW 72
117413: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117414: LD_EXP 71
117418: PUSH
117419: LD_VAR 0 1
117423: ARRAY
117424: IFFALSE 117448
// mechs := mechs diff mc_remote_driver [ base ] ;
117426: LD_ADDR_VAR 0 12
117430: PUSH
117431: LD_VAR 0 12
117435: PUSH
117436: LD_EXP 71
117440: PUSH
117441: LD_VAR 0 1
117445: ARRAY
117446: DIFF
117447: ST_TO_ADDR
// for i in mechs do
117448: LD_ADDR_VAR 0 4
117452: PUSH
117453: LD_VAR 0 12
117457: PUSH
117458: FOR_IN
117459: IFFALSE 117494
// if GetTag ( i ) > 0 then
117461: LD_VAR 0 4
117465: PPUSH
117466: CALL_OW 110
117470: PUSH
117471: LD_INT 0
117473: GREATER
117474: IFFALSE 117492
// mechs := mechs diff i ;
117476: LD_ADDR_VAR 0 12
117480: PUSH
117481: LD_VAR 0 12
117485: PUSH
117486: LD_VAR 0 4
117490: DIFF
117491: ST_TO_ADDR
117492: GO 117458
117494: POP
117495: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117496: LD_ADDR_VAR 0 8
117500: PUSH
117501: LD_EXP 31
117505: PUSH
117506: LD_VAR 0 1
117510: ARRAY
117511: PPUSH
117512: LD_INT 2
117514: PUSH
117515: LD_INT 25
117517: PUSH
117518: LD_INT 1
117520: PUSH
117521: EMPTY
117522: LIST
117523: LIST
117524: PUSH
117525: LD_INT 25
117527: PUSH
117528: LD_INT 5
117530: PUSH
117531: EMPTY
117532: LIST
117533: LIST
117534: PUSH
117535: LD_INT 25
117537: PUSH
117538: LD_INT 8
117540: PUSH
117541: EMPTY
117542: LIST
117543: LIST
117544: PUSH
117545: LD_INT 25
117547: PUSH
117548: LD_INT 9
117550: PUSH
117551: EMPTY
117552: LIST
117553: LIST
117554: PUSH
117555: EMPTY
117556: LIST
117557: LIST
117558: LIST
117559: LIST
117560: LIST
117561: PPUSH
117562: CALL_OW 72
117566: ST_TO_ADDR
// if not defenders and not solds then
117567: LD_VAR 0 2
117571: NOT
117572: PUSH
117573: LD_VAR 0 8
117577: NOT
117578: AND
117579: IFFALSE 117583
// exit ;
117581: GO 119353
// depot_under_attack := false ;
117583: LD_ADDR_VAR 0 16
117587: PUSH
117588: LD_INT 0
117590: ST_TO_ADDR
// sold_defenders := [ ] ;
117591: LD_ADDR_VAR 0 17
117595: PUSH
117596: EMPTY
117597: ST_TO_ADDR
// if mechs then
117598: LD_VAR 0 12
117602: IFFALSE 117755
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117604: LD_ADDR_VAR 0 4
117608: PUSH
117609: LD_VAR 0 2
117613: PPUSH
117614: LD_INT 21
117616: PUSH
117617: LD_INT 2
117619: PUSH
117620: EMPTY
117621: LIST
117622: LIST
117623: PPUSH
117624: CALL_OW 72
117628: PUSH
117629: FOR_IN
117630: IFFALSE 117753
// begin if GetTag ( i ) <> 20 then
117632: LD_VAR 0 4
117636: PPUSH
117637: CALL_OW 110
117641: PUSH
117642: LD_INT 20
117644: NONEQUAL
117645: IFFALSE 117659
// SetTag ( i , 20 ) ;
117647: LD_VAR 0 4
117651: PPUSH
117652: LD_INT 20
117654: PPUSH
117655: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117659: LD_VAR 0 4
117663: PPUSH
117664: CALL_OW 263
117668: PUSH
117669: LD_INT 1
117671: EQUAL
117672: PUSH
117673: LD_VAR 0 4
117677: PPUSH
117678: CALL_OW 311
117682: NOT
117683: AND
117684: IFFALSE 117751
// begin un := mechs [ 1 ] ;
117686: LD_ADDR_VAR 0 10
117690: PUSH
117691: LD_VAR 0 12
117695: PUSH
117696: LD_INT 1
117698: ARRAY
117699: ST_TO_ADDR
// ComExit ( un ) ;
117700: LD_VAR 0 10
117704: PPUSH
117705: CALL 57750 0 1
// AddComEnterUnit ( un , i ) ;
117709: LD_VAR 0 10
117713: PPUSH
117714: LD_VAR 0 4
117718: PPUSH
117719: CALL_OW 180
// SetTag ( un , 19 ) ;
117723: LD_VAR 0 10
117727: PPUSH
117728: LD_INT 19
117730: PPUSH
117731: CALL_OW 109
// mechs := mechs diff un ;
117735: LD_ADDR_VAR 0 12
117739: PUSH
117740: LD_VAR 0 12
117744: PUSH
117745: LD_VAR 0 10
117749: DIFF
117750: ST_TO_ADDR
// end ; end ;
117751: GO 117629
117753: POP
117754: POP
// if solds then
117755: LD_VAR 0 8
117759: IFFALSE 117818
// for i in solds do
117761: LD_ADDR_VAR 0 4
117765: PUSH
117766: LD_VAR 0 8
117770: PUSH
117771: FOR_IN
117772: IFFALSE 117816
// if not GetTag ( i ) then
117774: LD_VAR 0 4
117778: PPUSH
117779: CALL_OW 110
117783: NOT
117784: IFFALSE 117814
// begin defenders := defenders union i ;
117786: LD_ADDR_VAR 0 2
117790: PUSH
117791: LD_VAR 0 2
117795: PUSH
117796: LD_VAR 0 4
117800: UNION
117801: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117802: LD_VAR 0 4
117806: PPUSH
117807: LD_INT 18
117809: PPUSH
117810: CALL_OW 109
// end ;
117814: GO 117771
117816: POP
117817: POP
// repeat wait ( 0 0$2 ) ;
117818: LD_INT 70
117820: PPUSH
117821: CALL_OW 67
// enemy := mc_scan [ base ] ;
117825: LD_ADDR_VAR 0 21
117829: PUSH
117830: LD_EXP 54
117834: PUSH
117835: LD_VAR 0 1
117839: ARRAY
117840: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117841: LD_EXP 31
117845: PUSH
117846: LD_VAR 0 1
117850: ARRAY
117851: NOT
117852: PUSH
117853: LD_EXP 31
117857: PUSH
117858: LD_VAR 0 1
117862: ARRAY
117863: PUSH
117864: EMPTY
117865: EQUAL
117866: OR
117867: IFFALSE 117904
// begin for i in defenders do
117869: LD_ADDR_VAR 0 4
117873: PUSH
117874: LD_VAR 0 2
117878: PUSH
117879: FOR_IN
117880: IFFALSE 117893
// ComStop ( i ) ;
117882: LD_VAR 0 4
117886: PPUSH
117887: CALL_OW 141
117891: GO 117879
117893: POP
117894: POP
// defenders := [ ] ;
117895: LD_ADDR_VAR 0 2
117899: PUSH
117900: EMPTY
117901: ST_TO_ADDR
// exit ;
117902: GO 119353
// end ; for i in defenders do
117904: LD_ADDR_VAR 0 4
117908: PUSH
117909: LD_VAR 0 2
117913: PUSH
117914: FOR_IN
117915: IFFALSE 118813
// begin e := NearestUnitToUnit ( enemy , i ) ;
117917: LD_ADDR_VAR 0 13
117921: PUSH
117922: LD_VAR 0 21
117926: PPUSH
117927: LD_VAR 0 4
117931: PPUSH
117932: CALL_OW 74
117936: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117937: LD_ADDR_VAR 0 7
117941: PUSH
117942: LD_EXP 31
117946: PUSH
117947: LD_VAR 0 1
117951: ARRAY
117952: PPUSH
117953: LD_INT 2
117955: PUSH
117956: LD_INT 30
117958: PUSH
117959: LD_INT 0
117961: PUSH
117962: EMPTY
117963: LIST
117964: LIST
117965: PUSH
117966: LD_INT 30
117968: PUSH
117969: LD_INT 1
117971: PUSH
117972: EMPTY
117973: LIST
117974: LIST
117975: PUSH
117976: EMPTY
117977: LIST
117978: LIST
117979: LIST
117980: PPUSH
117981: CALL_OW 72
117985: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117986: LD_ADDR_VAR 0 16
117990: PUSH
117991: LD_VAR 0 7
117995: NOT
117996: PUSH
117997: LD_VAR 0 7
118001: PPUSH
118002: LD_INT 3
118004: PUSH
118005: LD_INT 24
118007: PUSH
118008: LD_INT 600
118010: PUSH
118011: EMPTY
118012: LIST
118013: LIST
118014: PUSH
118015: EMPTY
118016: LIST
118017: LIST
118018: PPUSH
118019: CALL_OW 72
118023: OR
118024: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118025: LD_VAR 0 4
118029: PPUSH
118030: CALL_OW 247
118034: PUSH
118035: LD_INT 2
118037: DOUBLE
118038: EQUAL
118039: IFTRUE 118043
118041: GO 118439
118043: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118044: LD_VAR 0 4
118048: PPUSH
118049: CALL_OW 256
118053: PUSH
118054: LD_INT 1000
118056: EQUAL
118057: PUSH
118058: LD_VAR 0 4
118062: PPUSH
118063: LD_VAR 0 13
118067: PPUSH
118068: CALL_OW 296
118072: PUSH
118073: LD_INT 40
118075: LESS
118076: PUSH
118077: LD_VAR 0 13
118081: PPUSH
118082: LD_EXP 56
118086: PUSH
118087: LD_VAR 0 1
118091: ARRAY
118092: PPUSH
118093: CALL_OW 308
118097: OR
118098: AND
118099: IFFALSE 118221
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118101: LD_VAR 0 4
118105: PPUSH
118106: CALL_OW 262
118110: PUSH
118111: LD_INT 1
118113: EQUAL
118114: PUSH
118115: LD_VAR 0 4
118119: PPUSH
118120: CALL_OW 261
118124: PUSH
118125: LD_INT 30
118127: LESS
118128: AND
118129: PUSH
118130: LD_VAR 0 7
118134: AND
118135: IFFALSE 118205
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118137: LD_VAR 0 4
118141: PPUSH
118142: LD_VAR 0 7
118146: PPUSH
118147: LD_VAR 0 4
118151: PPUSH
118152: CALL_OW 74
118156: PPUSH
118157: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118161: LD_VAR 0 4
118165: PPUSH
118166: LD_VAR 0 7
118170: PPUSH
118171: LD_VAR 0 4
118175: PPUSH
118176: CALL_OW 74
118180: PPUSH
118181: CALL_OW 296
118185: PUSH
118186: LD_INT 6
118188: LESS
118189: IFFALSE 118203
// SetFuel ( i , 100 ) ;
118191: LD_VAR 0 4
118195: PPUSH
118196: LD_INT 100
118198: PPUSH
118199: CALL_OW 240
// end else
118203: GO 118219
// ComAttackUnit ( i , e ) ;
118205: LD_VAR 0 4
118209: PPUSH
118210: LD_VAR 0 13
118214: PPUSH
118215: CALL_OW 115
// end else
118219: GO 118322
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118221: LD_VAR 0 13
118225: PPUSH
118226: LD_EXP 56
118230: PUSH
118231: LD_VAR 0 1
118235: ARRAY
118236: PPUSH
118237: CALL_OW 308
118241: NOT
118242: PUSH
118243: LD_VAR 0 4
118247: PPUSH
118248: LD_VAR 0 13
118252: PPUSH
118253: CALL_OW 296
118257: PUSH
118258: LD_INT 40
118260: GREATEREQUAL
118261: AND
118262: PUSH
118263: LD_VAR 0 4
118267: PPUSH
118268: CALL_OW 256
118272: PUSH
118273: LD_INT 650
118275: LESSEQUAL
118276: OR
118277: PUSH
118278: LD_VAR 0 4
118282: PPUSH
118283: LD_EXP 55
118287: PUSH
118288: LD_VAR 0 1
118292: ARRAY
118293: PPUSH
118294: CALL_OW 308
118298: NOT
118299: AND
118300: IFFALSE 118322
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118302: LD_VAR 0 4
118306: PPUSH
118307: LD_EXP 55
118311: PUSH
118312: LD_VAR 0 1
118316: ARRAY
118317: PPUSH
118318: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118322: LD_VAR 0 4
118326: PPUSH
118327: CALL_OW 256
118331: PUSH
118332: LD_INT 1000
118334: LESS
118335: PUSH
118336: LD_VAR 0 4
118340: PPUSH
118341: CALL_OW 263
118345: PUSH
118346: LD_INT 1
118348: EQUAL
118349: AND
118350: PUSH
118351: LD_VAR 0 4
118355: PPUSH
118356: CALL_OW 311
118360: AND
118361: PUSH
118362: LD_VAR 0 4
118366: PPUSH
118367: LD_EXP 55
118371: PUSH
118372: LD_VAR 0 1
118376: ARRAY
118377: PPUSH
118378: CALL_OW 308
118382: AND
118383: IFFALSE 118437
// begin mech := IsDrivenBy ( i ) ;
118385: LD_ADDR_VAR 0 9
118389: PUSH
118390: LD_VAR 0 4
118394: PPUSH
118395: CALL_OW 311
118399: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118400: LD_VAR 0 9
118404: PPUSH
118405: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118409: LD_VAR 0 9
118413: PPUSH
118414: LD_VAR 0 4
118418: PPUSH
118419: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118423: LD_VAR 0 9
118427: PPUSH
118428: LD_VAR 0 4
118432: PPUSH
118433: CALL_OW 180
// end ; end ; unit_human :
118437: GO 118784
118439: LD_INT 1
118441: DOUBLE
118442: EQUAL
118443: IFTRUE 118447
118445: GO 118783
118447: POP
// begin b := IsInUnit ( i ) ;
118448: LD_ADDR_VAR 0 18
118452: PUSH
118453: LD_VAR 0 4
118457: PPUSH
118458: CALL_OW 310
118462: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118463: LD_ADDR_VAR 0 19
118467: PUSH
118468: LD_VAR 0 18
118472: NOT
118473: PUSH
118474: LD_VAR 0 18
118478: PPUSH
118479: CALL_OW 266
118483: PUSH
118484: LD_INT 32
118486: PUSH
118487: LD_INT 31
118489: PUSH
118490: EMPTY
118491: LIST
118492: LIST
118493: IN
118494: OR
118495: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118496: LD_VAR 0 18
118500: PPUSH
118501: CALL_OW 266
118505: PUSH
118506: LD_INT 5
118508: EQUAL
118509: PUSH
118510: LD_VAR 0 4
118514: PPUSH
118515: CALL_OW 257
118519: PUSH
118520: LD_INT 1
118522: PUSH
118523: LD_INT 2
118525: PUSH
118526: LD_INT 3
118528: PUSH
118529: LD_INT 4
118531: PUSH
118532: EMPTY
118533: LIST
118534: LIST
118535: LIST
118536: LIST
118537: IN
118538: AND
118539: IFFALSE 118576
// begin class := AllowSpecClass ( i ) ;
118541: LD_ADDR_VAR 0 20
118545: PUSH
118546: LD_VAR 0 4
118550: PPUSH
118551: CALL 21670 0 1
118555: ST_TO_ADDR
// if class then
118556: LD_VAR 0 20
118560: IFFALSE 118576
// ComChangeProfession ( i , class ) ;
118562: LD_VAR 0 4
118566: PPUSH
118567: LD_VAR 0 20
118571: PPUSH
118572: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118576: LD_VAR 0 16
118580: PUSH
118581: LD_VAR 0 2
118585: PPUSH
118586: LD_INT 21
118588: PUSH
118589: LD_INT 2
118591: PUSH
118592: EMPTY
118593: LIST
118594: LIST
118595: PPUSH
118596: CALL_OW 72
118600: PUSH
118601: LD_INT 1
118603: LESSEQUAL
118604: OR
118605: PUSH
118606: LD_VAR 0 19
118610: AND
118611: PUSH
118612: LD_VAR 0 4
118616: PUSH
118617: LD_VAR 0 17
118621: IN
118622: NOT
118623: AND
118624: IFFALSE 118717
// begin if b then
118626: LD_VAR 0 18
118630: IFFALSE 118679
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118632: LD_VAR 0 18
118636: PPUSH
118637: LD_VAR 0 21
118641: PPUSH
118642: LD_VAR 0 18
118646: PPUSH
118647: CALL_OW 74
118651: PPUSH
118652: CALL_OW 296
118656: PUSH
118657: LD_INT 10
118659: LESS
118660: PUSH
118661: LD_VAR 0 18
118665: PPUSH
118666: CALL_OW 461
118670: PUSH
118671: LD_INT 7
118673: NONEQUAL
118674: AND
118675: IFFALSE 118679
// continue ;
118677: GO 117914
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118679: LD_ADDR_VAR 0 17
118683: PUSH
118684: LD_VAR 0 17
118688: PPUSH
118689: LD_VAR 0 17
118693: PUSH
118694: LD_INT 1
118696: PLUS
118697: PPUSH
118698: LD_VAR 0 4
118702: PPUSH
118703: CALL_OW 1
118707: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118708: LD_VAR 0 4
118712: PPUSH
118713: CALL_OW 122
// end ; if sold_defenders then
118717: LD_VAR 0 17
118721: IFFALSE 118781
// if i in sold_defenders then
118723: LD_VAR 0 4
118727: PUSH
118728: LD_VAR 0 17
118732: IN
118733: IFFALSE 118781
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118735: LD_VAR 0 4
118739: PPUSH
118740: CALL_OW 314
118744: NOT
118745: PUSH
118746: LD_VAR 0 4
118750: PPUSH
118751: LD_VAR 0 13
118755: PPUSH
118756: CALL_OW 296
118760: PUSH
118761: LD_INT 30
118763: LESS
118764: AND
118765: IFFALSE 118781
// ComAttackUnit ( i , e ) ;
118767: LD_VAR 0 4
118771: PPUSH
118772: LD_VAR 0 13
118776: PPUSH
118777: CALL_OW 115
// end ; end ; end ;
118781: GO 118784
118783: POP
// if IsDead ( i ) then
118784: LD_VAR 0 4
118788: PPUSH
118789: CALL_OW 301
118793: IFFALSE 118811
// defenders := defenders diff i ;
118795: LD_ADDR_VAR 0 2
118799: PUSH
118800: LD_VAR 0 2
118804: PUSH
118805: LD_VAR 0 4
118809: DIFF
118810: ST_TO_ADDR
// end ;
118811: GO 117914
118813: POP
118814: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118815: LD_VAR 0 21
118819: NOT
118820: PUSH
118821: LD_VAR 0 2
118825: NOT
118826: OR
118827: PUSH
118828: LD_EXP 31
118832: PUSH
118833: LD_VAR 0 1
118837: ARRAY
118838: NOT
118839: OR
118840: IFFALSE 117818
// MC_Reset ( base , 18 ) ;
118842: LD_VAR 0 1
118846: PPUSH
118847: LD_INT 18
118849: PPUSH
118850: CALL 65466 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118854: LD_ADDR_VAR 0 2
118858: PUSH
118859: LD_VAR 0 2
118863: PUSH
118864: LD_VAR 0 2
118868: PPUSH
118869: LD_INT 2
118871: PUSH
118872: LD_INT 25
118874: PUSH
118875: LD_INT 1
118877: PUSH
118878: EMPTY
118879: LIST
118880: LIST
118881: PUSH
118882: LD_INT 25
118884: PUSH
118885: LD_INT 5
118887: PUSH
118888: EMPTY
118889: LIST
118890: LIST
118891: PUSH
118892: LD_INT 25
118894: PUSH
118895: LD_INT 8
118897: PUSH
118898: EMPTY
118899: LIST
118900: LIST
118901: PUSH
118902: LD_INT 25
118904: PUSH
118905: LD_INT 9
118907: PUSH
118908: EMPTY
118909: LIST
118910: LIST
118911: PUSH
118912: EMPTY
118913: LIST
118914: LIST
118915: LIST
118916: LIST
118917: LIST
118918: PPUSH
118919: CALL_OW 72
118923: DIFF
118924: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118925: LD_VAR 0 21
118929: NOT
118930: PUSH
118931: LD_VAR 0 2
118935: PPUSH
118936: LD_INT 21
118938: PUSH
118939: LD_INT 2
118941: PUSH
118942: EMPTY
118943: LIST
118944: LIST
118945: PPUSH
118946: CALL_OW 72
118950: AND
118951: IFFALSE 119289
// begin tmp := FilterByTag ( defenders , 19 ) ;
118953: LD_ADDR_VAR 0 11
118957: PUSH
118958: LD_VAR 0 2
118962: PPUSH
118963: LD_INT 19
118965: PPUSH
118966: CALL 54933 0 2
118970: ST_TO_ADDR
// if tmp then
118971: LD_VAR 0 11
118975: IFFALSE 119045
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118977: LD_ADDR_VAR 0 11
118981: PUSH
118982: LD_VAR 0 11
118986: PPUSH
118987: LD_INT 25
118989: PUSH
118990: LD_INT 3
118992: PUSH
118993: EMPTY
118994: LIST
118995: LIST
118996: PPUSH
118997: CALL_OW 72
119001: ST_TO_ADDR
// if tmp then
119002: LD_VAR 0 11
119006: IFFALSE 119045
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119008: LD_ADDR_EXP 43
119012: PUSH
119013: LD_EXP 43
119017: PPUSH
119018: LD_VAR 0 1
119022: PPUSH
119023: LD_EXP 43
119027: PUSH
119028: LD_VAR 0 1
119032: ARRAY
119033: PUSH
119034: LD_VAR 0 11
119038: UNION
119039: PPUSH
119040: CALL_OW 1
119044: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119045: LD_VAR 0 1
119049: PPUSH
119050: LD_INT 19
119052: PPUSH
119053: CALL 65466 0 2
// repeat wait ( 0 0$1 ) ;
119057: LD_INT 35
119059: PPUSH
119060: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119064: LD_EXP 31
119068: PUSH
119069: LD_VAR 0 1
119073: ARRAY
119074: NOT
119075: PUSH
119076: LD_EXP 31
119080: PUSH
119081: LD_VAR 0 1
119085: ARRAY
119086: PUSH
119087: EMPTY
119088: EQUAL
119089: OR
119090: IFFALSE 119127
// begin for i in defenders do
119092: LD_ADDR_VAR 0 4
119096: PUSH
119097: LD_VAR 0 2
119101: PUSH
119102: FOR_IN
119103: IFFALSE 119116
// ComStop ( i ) ;
119105: LD_VAR 0 4
119109: PPUSH
119110: CALL_OW 141
119114: GO 119102
119116: POP
119117: POP
// defenders := [ ] ;
119118: LD_ADDR_VAR 0 2
119122: PUSH
119123: EMPTY
119124: ST_TO_ADDR
// exit ;
119125: GO 119353
// end ; for i in defenders do
119127: LD_ADDR_VAR 0 4
119131: PUSH
119132: LD_VAR 0 2
119136: PUSH
119137: FOR_IN
119138: IFFALSE 119227
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119140: LD_VAR 0 4
119144: PPUSH
119145: LD_EXP 55
119149: PUSH
119150: LD_VAR 0 1
119154: ARRAY
119155: PPUSH
119156: CALL_OW 308
119160: NOT
119161: IFFALSE 119185
// ComMoveToArea ( i , mc_parking [ base ] ) else
119163: LD_VAR 0 4
119167: PPUSH
119168: LD_EXP 55
119172: PUSH
119173: LD_VAR 0 1
119177: ARRAY
119178: PPUSH
119179: CALL_OW 113
119183: GO 119225
// if GetControl ( i ) = control_manual then
119185: LD_VAR 0 4
119189: PPUSH
119190: CALL_OW 263
119194: PUSH
119195: LD_INT 1
119197: EQUAL
119198: IFFALSE 119225
// if IsDrivenBy ( i ) then
119200: LD_VAR 0 4
119204: PPUSH
119205: CALL_OW 311
119209: IFFALSE 119225
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119211: LD_VAR 0 4
119215: PPUSH
119216: CALL_OW 311
119220: PPUSH
119221: CALL_OW 121
// end ;
119225: GO 119137
119227: POP
119228: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119229: LD_VAR 0 2
119233: PPUSH
119234: LD_INT 95
119236: PUSH
119237: LD_EXP 55
119241: PUSH
119242: LD_VAR 0 1
119246: ARRAY
119247: PUSH
119248: EMPTY
119249: LIST
119250: LIST
119251: PPUSH
119252: CALL_OW 72
119256: PUSH
119257: LD_VAR 0 2
119261: EQUAL
119262: PUSH
119263: LD_EXP 54
119267: PUSH
119268: LD_VAR 0 1
119272: ARRAY
119273: OR
119274: PUSH
119275: LD_EXP 31
119279: PUSH
119280: LD_VAR 0 1
119284: ARRAY
119285: NOT
119286: OR
119287: IFFALSE 119057
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119289: LD_ADDR_EXP 53
119293: PUSH
119294: LD_EXP 53
119298: PPUSH
119299: LD_VAR 0 1
119303: PPUSH
119304: LD_VAR 0 2
119308: PPUSH
119309: LD_INT 21
119311: PUSH
119312: LD_INT 2
119314: PUSH
119315: EMPTY
119316: LIST
119317: LIST
119318: PPUSH
119319: CALL_OW 72
119323: PPUSH
119324: CALL_OW 1
119328: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119329: LD_VAR 0 1
119333: PPUSH
119334: LD_INT 19
119336: PPUSH
119337: CALL 65466 0 2
// MC_Reset ( base , 20 ) ;
119341: LD_VAR 0 1
119345: PPUSH
119346: LD_INT 20
119348: PPUSH
119349: CALL 65466 0 2
// end ; end_of_file
119353: LD_VAR 0 3
119357: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119358: LD_VAR 0 1
119362: PUSH
119363: LD_INT 200
119365: DOUBLE
119366: GREATEREQUAL
119367: IFFALSE 119375
119369: LD_INT 299
119371: DOUBLE
119372: LESSEQUAL
119373: IFTRUE 119377
119375: GO 119409
119377: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119378: LD_VAR 0 1
119382: PPUSH
119383: LD_VAR 0 2
119387: PPUSH
119388: LD_VAR 0 3
119392: PPUSH
119393: LD_VAR 0 4
119397: PPUSH
119398: LD_VAR 0 5
119402: PPUSH
119403: CALL 108144 0 5
119407: GO 119486
119409: LD_INT 300
119411: DOUBLE
119412: GREATEREQUAL
119413: IFFALSE 119421
119415: LD_INT 399
119417: DOUBLE
119418: LESSEQUAL
119419: IFTRUE 119423
119421: GO 119485
119423: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119424: LD_VAR 0 1
119428: PPUSH
119429: LD_VAR 0 2
119433: PPUSH
119434: LD_VAR 0 3
119438: PPUSH
119439: LD_VAR 0 4
119443: PPUSH
119444: LD_VAR 0 5
119448: PPUSH
119449: LD_VAR 0 6
119453: PPUSH
119454: LD_VAR 0 7
119458: PPUSH
119459: LD_VAR 0 8
119463: PPUSH
119464: LD_VAR 0 9
119468: PPUSH
119469: LD_VAR 0 10
119473: PPUSH
119474: LD_VAR 0 11
119478: PPUSH
119479: CALL 104477 0 11
119483: GO 119486
119485: POP
// end ;
119486: PPOPN 11
119488: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119489: LD_VAR 0 1
119493: PPUSH
119494: LD_VAR 0 2
119498: PPUSH
119499: LD_VAR 0 3
119503: PPUSH
119504: LD_VAR 0 4
119508: PPUSH
119509: LD_VAR 0 5
119513: PPUSH
119514: CALL 107880 0 5
// end ; end_of_file
119518: PPOPN 5
119520: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119521: LD_VAR 0 1
119525: PPUSH
119526: LD_VAR 0 2
119530: PPUSH
119531: LD_VAR 0 3
119535: PPUSH
119536: LD_VAR 0 4
119540: PPUSH
119541: LD_VAR 0 5
119545: PPUSH
119546: LD_VAR 0 6
119550: PPUSH
119551: CALL 92097 0 6
// end ;
119555: PPOPN 6
119557: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119558: LD_INT 0
119560: PPUSH
// begin if not units then
119561: LD_VAR 0 1
119565: NOT
119566: IFFALSE 119570
// exit ;
119568: GO 119570
// end ;
119570: PPOPN 7
119572: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119573: CALL 91991 0 0
// end ;
119577: PPOPN 1
119579: END
